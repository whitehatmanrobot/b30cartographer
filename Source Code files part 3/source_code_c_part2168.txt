e function returns STATUS_BUFFER_OVERFLOW, pszDest
                    will not contain a truncated string, it will remain unchanged.

Notes:
    Behavior is undefined if source and destination strings overlap.

    DestinationString and pszSrc should not be NULL unless the STRSAFE_IGNORE_NULLS flag
    is specified.  If STRSAFE_IGNORE_NULLS is passed, both DestinationString and pszSrc
    may be NULL.  An error may still be returned even though NULLS are ignored
    due to insufficient space.

Return Value:

    STATUS_SUCCESS -   if all of pszSrc or the first cchToAppend characters were
                       concatenated to DestinationString

    failure        -   the operation did not succeed

      STATUS_BUFFER_OVERFLOW
      Note: This status has the severity class Warning - IRPs completed with this
            status do have their data copied back to user mode
                   -   this return value is an indication that the 
                       operation failed due to insufficient space. When this
                       error occurs, the destination buffer is modified to
                       contain a truncated version of the ideal result.
                       This is useful for situations where truncation is ok.

    It is strongly recommended to use the NT_SUCCESS() macro to test the
    return value of this function

--*/

NTSTRSAFEDDI
RtlUnicodeStringCchCatStringNEx(
    __inout PUNICODE_STRING DestinationString,
    __in NTSTRSAFE_PCWSTR pszSrc,
    __in size_t cchToAppend,
    __out_opt PUNICODE_STRING RemainingString,
    __in DWORD dwFlags)
{
    NTSTATUS status;
    wchar_t* pszDest;
    size_t cchDest;
    size_t cchDestLength;

    status = RtlUnicodeStringValidateDestWorker(DestinationString,
                                                &pszDest,
                                                &cchDest,
                                                &cchDestLength,
                                                NTSTRSAFE_UNICODE_STRING_MAX_CCH,
                                                dwFlags);

    if (NT_SUCCESS(status))
    {
        wchar_t* pszDestEnd = pszDest + cchDestLength;
        size_t cchRemaining = cchDest - cchDestLength;
        size_t cchNewDestLength = cchDestLength;

        status = RtlStringExValidateSrcW(&pszSrc, &cchToAppend, NTSTRSAFE_UNICODE_STRING_MAX_CCH, dwFlags);
        
        if (NT_SUCCESS(status))
        {
            if (dwFlags & (~STRSAFE_UNICODE_STRING_VALID_FLAGS))
            {
                status = STATUS_INVALID_PARAMETER;
            }
            else if (cchRemaining == 0)
            {
                // only fail if there was actually src data to append
                if ((cchToAppend != 0) && (*pszSrc != L'\0'))
                {
                    if (pszDest == NULL)
                    {
                        status = STATUS_INVALID_PARAMETER;
                    }
                    else
                    {
                        status = STATUS_BUFFER_OVERFLOW;
                    }
                }
            }
            else
            {
                size_t cchCopied = 0;

                status = RtlWideCharArrayCopyStringWorker(pszDestEnd,
                                                          cchRemaining,
                                                          &cchCopied,
                                                          pszSrc,
                                                          cchToAppend);

                pszDestEnd = pszDestEnd + cchCopied;
                cchRemaining = cchRemaining - cchCopied;

                cchNewDestLength = cchDestLength + cchCopied;
                
                if (NT_SUCCESS(status)              &&
                    (dwFlags & STRSAFE_FILL_BEHIND) &&
                    (cchRemaining != 0))
                {
                    // handle the STRSAFE_FILL_BEHIND flag
                    RtlUnicodeStringExHandleFill(pszDestEnd, cchRemaining, dwFlags);
                }
            }
        }

        if (!NT_SUCCESS(status)                                                                                      &&
            (dwFlags & (STRSAFE_NO_TRUNCATION | STRSAFE_FILL_ON_FAILURE | STRSAFE_ZERO_LENGTH_ON_FAILURE))  &&
            (cchDest != 0))
        {
            // handle the STRSAFE_NO_TRUNCATION, STRSAFE_FILL_ON_FAILURE, and STRSAFE_ZERO_LENGTH_ON_FAILURE flags
            RtlUnicodeStringExHandleOtherFlags(pszDest,
                                               cchDest,
                                               cchDestLength,
                                               &cchNewDestLength,
                                               &pszDestEnd,
                                               &cchRemaining,
                                               dwFlags);
        }
        
        if (DestinationString)
        {
            // safe to multiply cchNewDestLength * sizeof(wchar_t) since cchDest < NTSTRSAFE_UNICODE_STRING_MAX_CCH and sizeof(wchar_t) is 2
            DestinationString->Length = (USHORT)(cchNewDestLength * sizeof(wchar_t));
        }

        if (NT_SUCCESS(status) || (status == STATUS_BUFFER_OVERFLOW))
        {   
            if (RemainingString)
            {
                RemainingString->Length = 0;
                // safe to multiply cchRemaining * sizeof(wchar_t) since cchRemaining < NTSTRSAFE_UNICODE_STRING_MAX_CCH and sizeof(wchar_t) is 2
                RemainingString->MaximumLength = (USHORT)(cchRemaining * sizeof(wchar_t));
                RemainingString->Buffer = pszDestEnd;
            }
        }
    }

    return status;
}
#endif  // !NTSTRSAFE_NO_CCH_FUNCTIONS


#ifndef NTSTRSAFE_NO_CB_FUNCTIONS
/*++

NTSTATUS
RtlUnicodeStringCbCatStringNEx(
    __inout                PUNICODE_STRING DestinationString   OPTIONAL,
    __in   LPCTSTR         pszSrc              OPTIONAL,
    __in                   size_t          cbToAppend,
    __out_opt              PUNICODE_STRING RemainingString     OPTIONAL,
    __in                   DWORD           dwFlags
    );

Routine Description:

    This routine is a safer version of the C built-in function 'strncat', with
    some additional parameters and for PUNICODE_STRINGs. In addition to the
    functionality provided by RtlUnicodeStringCbCatStringN, this routine
    also returns a PUNICODE_STRING which points to the end of the destination
    string. The flags parameter allows additional controls.
    
Arguments:

    DestinationString   -   pointer to the counted unicode destination string

    pszSrc              -   source string

    cbToAppend          -   maximum number of bytes to append

    RemainingString     -   if RemainingString is non-null, the function will format
                            the pointer with the remaining buffer and number of
                            bytes left in the destination string

    dwFlags             -   controls some details of the string copy:

        STRSAFE_FILL_BEHIND
                    if the function succeeds, the low byte of dwFlags will be
                    used to fill the uninitialize part of destination buffer

        STRSAFE_IGNORE_NULLS
                    do not fault if DestinationString is null and treat NULL pszSrc like
                    empty strings (L""). This flag is useful for emulating
                    functions like lstrcpy
                    
        STRSAFE_FILL_ON_FAILURE
                    if the function fails, the low byte of dwFlags will be
                    used to fill all of the destination buffer. This will
                    overwrite any truncated string returned when the failure is
                    STATUS_BUFFER_OVERFLOW

        STRSAFE_ZERO_LENGTH_ON_FAILURE
                    if the function fails, the destination Length will be set
                    to zero. This will overwrite any truncated string
                    returned when the failure is STATUS_BUFFER_OVERFLOW.

        STRSAFE_NO_TRUNCATION
                    if the function returns STATUS_BUFFER_OVERFLOW, pszDest
                    will not contain a truncated string, it will remain unchanged.

Notes:
    Behavior is undefined if source and destination strings overlap.

    DestinationString and pszSrc should not be NULL unless the STRSAFE_IGNORE_NULLS flag
    is specified.  If STRSAFE_IGNORE_NULLS is passed, both DestinationString and pszSrc
    may be NULL.  An error may still be returned even though NULLS are ignored
    due to insufficient space.

Return Value:

    STATUS_SUCCESS -   if all of pszSrc or the first cbToAppend bytes were
                       concatenated to pszDest

    failure        -   the operation did not succeed

      STATUS_BUFFER_OVERFLOW
      Note: This status has the severity class Warning - IRPs completed with this
            status do have their data copied back to user mode
                   -   this return value is an indication that the 
                       operation failed due to insufficient space. When this
                       error occurs, the destination buffer is modified to
                       contain a truncated version of the ideal result.
                       This is useful for situations where truncation is ok.

    It is strongly recommended to use the NT_SUCCESS() macro to test the
    return value of this function

--*/

NTSTRSAFEDDI
RtlUnicodeStringCbCatStringNEx(
    __inout PUNICODE_STRING DestinationString,
    __in NTSTRSAFE_PCWSTR pszSrc,
    __in size_t cbToAppend,
    __out_opt PUNICODE_STRING RemainingString,
    __in DWORD dwFlags)
{
    NTSTATUS status;
    wchar_t* pszDest;
    size_t cchDest;
    size_t cchDestLength;

    status = RtlUnicodeStringValidateDestWorker(DestinationString,
                                                &pszDest,
                                                &cchDest,
                                                &cchDestLength,
                                                NTSTRSAFE_UNICODE_STRING_MAX_CCH,
                                                dwFlags);

    if (NT_SUCCESS(status))
    {
        wchar_t* pszDestEnd = pszDest + cchDestLength;
        size_t cchRemaining = cchDest - cchDestLength;
        size_t cchNewDestLength = cchDestLength;
        size_t cchToAppend = cbToAppend / sizeof(wchar_t);

        status = RtlStringExValidateSrcW(&pszSrc, &cchToAppend, NTSTRSAFE_UNICODE_STRING_MAX_CCH, dwFlags);
        
        if (NT_SUCCESS(status))
        {
            if (dwFlags & (~STRSAFE_UNICODE_STRING_VALID_FLAGS))
            {
                status = STATUS_INVALID_PARAMETER;
            }
            else if (cchRemaining == 0)
            {
                // only fail if there was actually src data to append
                if ((cchToAppend != 0) && (*pszSrc != L'\0'))
                {
                    if (pszDest == NULL)
                    {
                        status = STATUS_INVALID_PARAMETER;
                    }
                    else
                    {
                        status = STATUS_BUFFER_OVERFLOW;
                    }
                }
            }
            else
            {
                size_t cchCopied = 0;
                
                status = RtlWideCharArrayCopyStringWorker(pszDestEnd,
                                                          cchRemaining,
                                                          &cchCopied,
                                                          pszSrc,
                                                          cchToAppend);

                pszDestEnd = pszDestEnd + cchCopied;
                cchRemaining = cchRemaining - cchCopied;

                cchNewDestLength = cchDestLength + cchCopied;
                
                if (NT_SUCCESS(status)              &&
                    (dwFlags & STRSAFE_FILL_BEHIND) &&
                    (cchRemaining != 0))
                {
                    // handle the STRSAFE_FILL_BEHIND flag
                    RtlUnicodeStringExHandleFill(pszDestEnd, cchRemaining, dwFlags);
                }
            }
        }

        if (!NT_SUCCESS(status)                                                                                      &&
            (dwFlags & (STRSAFE_NO_TRUNCATION | STRSAFE_FILL_ON_FAILURE | STRSAFE_ZERO_LENGTH_ON_FAILURE))  &&
            (cchDest != 0))
        {
            // handle the STRSAFE_NO_TRUNCATION, STRSAFE_FILL_ON_FAILURE, and STRSAFE_ZERO_LENGTH_ON_FAILURE flags
            RtlUnicodeStringExHandleOtherFlags(pszDest,
                                               cchDest,
                                               cchDestLength,
                                               &cchNewDestLength,
                                               &pszDestEnd,
                                               &cchRemaining,
                                               dwFlags);
        }
        
        if (DestinationString)
        {
            // safe to multiply cchNewDestLength * sizeof(wchar_t) since cchDest < NTSTRSAFE_UNICODE_STRING_MAX_CCH and sizeof(wchar_t) is 2
            DestinationString->Length = (USHORT)(cchNewDestLength * sizeof(wchar_t));
        }

        if (NT_SUCCESS(status) || (status == STATUS_BUFFER_OVERFLOW))
        {   
            if (RemainingString)
            {
                RemainingString->Length = 0;
                // safe to multiply cchRemaining * sizeof(wchar_t) since cchRemaining < NTSTRSAFE_UNICODE_STRING_MAX_CCH and sizeof(wchar_t) is 2
                RemainingString->MaximumLength = (USHORT)(cchRemaining * sizeof(wchar_t));
                RemainingString->Buffer = pszDestEnd;
            }
        }
    }

    return status;
}
#endif  // !NTSTRSAFE_NO_CB_FUNCTIONS


#ifndef NTSTRSAFE_NO_CCH_FUNCTIONS
/*++

NTSTATUS
RtlUnicodeStringCchCatNEx(
    __inout   PUNICODE_STRING     DestinationString   OPTIONAL,
    __in      PCUNICODE_STRING    SourceString        OPTIONAL,
    __in      size_t              cchToAppend,
    __out_opt PUNICODE_STRING     RemainingString     OPTIONAL,
    __in      DWORD               dwFlags
    );

Routine Description:

    This routine is a safer version of the C built-in function 'strncat', with
    some additional parameters and for PUNICODE_STRINGs. In addition to the
    functionality provided by RtlUnicodeStringCchCatN, this routine
    also returns a PUNICODE_STRING which points to the end of the destination
    string. The flags parameter allows additional controls.

Arguments:

    DestinationString   -   pointer to the counted unicode destination string

    SourceString        -   pointer to the counted unicode source string

    cchToAppend         -   maximum number of characters to append

    RemainingString     -   if RemainingString is non-null, the function will format
                            the pointer with the remaining buffer and number of
                            bytes left in the destination string

    dwFlags             -   controls some details of the string copy:

        STRSAFE_FILL_BEHIND
                    if the function succeeds, the low byte of dwFlags will be
                    used to fill the uninitialize part of destination buffer

        STRSAFE_IGNORE_NULLS
                    do not fault if DestinationString is null and treat NULL SourceString like
                    empty strings (L""). This flag is useful for emulating
                    functions like lstrcpy
                    
        STRSAFE_FILL_ON_FAILURE
                    if the function fails, the low byte of dwFlags will be
                    used to fill all of the destination buffer. This will
                    overwrite any truncated string returned when the failure is
                    STATUS_BUFFER_OVERFLOW

        STRSAFE_ZERO_LENGTH_ON_FAILURE
                    if the function fails, the destination Length will be set
                    to zero. This will overwrite any truncated string
                    returned when the failure is STATUS_BUFFER_OVERFLOW.

        STRSAFE_NO_TRUNCATION
                    if the function returns STATUS_BUFFER_OVERFLOW, pszDest
                    will not contain a truncated string, it will remain unchanged.

Notes:
    Behavior is undefined if source and destination strings overlap.

    DestinationString and SourceString should not be NULL unless the STRSAFE_IGNORE_NULLS flag
    is specified.  If STRSAFE_IGNORE_NULLS is passed, both DestinationString and SourceString
    may be NULL.  An error may still be returned even though NULLS are ignored
    due to insufficient space.

Return Value:

    STATUS_SUCCESS -   if all of SourceString or the first cchToAppend characters were
                       concatenated to DestinationString

    failure        -   the operation did not succeed


      STATUS_BUFFER_OVERFLOW
      Note: This status has the severity class Warning - IRPs completed with this
            status do have their data copied back to user mode
                   -   this return value is an indication that the 
                       operation failed due to insufficient space. When this
                       error occurs, the destination buffer is modified to
                       contain a truncated version of the ideal result.
                       This is useful for situations where truncation is ok.

    It is strongly recommended to use the NT_SUCCESS() macro to test the
    return value of this function

--*/

NTSTRSAFEDDI
RtlUnicodeStringCchCatNEx(
    __inout   PUNICODE_STRING  DestinationString,
    __in      PCUNICODE_STRING SourceString,
    __in      size_t           cchToAppend,
    __out_opt PUNICODE_STRING  RemainingString,
    __in      DWORD            dwFlags)
{
    NTSTATUS status;
    wchar_t* pszDest;
    size_t cchDest;
    size_t cchDestLength;

    status = RtlUnicodeStringValidateDestWorker(DestinationString,
                                                &pszDest,
                                                &cchDest,
                                                &cchDestLength,
                                                NTSTRSAFE_UNICODE_STRING_MAX_CCH,
                                                dwFlags);

    if (NT_SUCCESS(status))
    {
        wchar_t* pszSrc;
        size_t cchSrcLength;
        wchar_t* pszDestEnd = pszDest + cchDestLength;
        size_t cchRemaining = cchDest - cchDestLength;
        size_t cchNewDestLength = cchDestLength;

        status = RtlUnicodeStringValidateSrcWorker(SourceString,
                                                   &pszSrc,
                                                   &cchSrcLength,
                                                   NTSTRSAFE_UNICODE_STRING_MAX_CCH,
                                                   dwFlags);

        if (NT_SUCCESS(status))
        {
            if (cchToAppend > NTSTRSAFE_UNICODE_STRING_MAX_CCH)
            {
                status = STATUS_INVALID_PARAMETER;
            }
            else
            {
                if (cchSrcLength < cchToAppend)
                {
                    cchToAppend = cchSrcLength;
                }

                if (dwFlags & (~STRSAFE_UNICODE_STRING_VALID_FLAGS))
                {
                    status = STATUS_INVALID_PARAMETER;
                }
                else if (cchRemaining == 0)
                {
                    // only fail if there was actually src data to append
                    if (cchToAppend != 0)
                    {
                        if (pszDest == NULL)
                        {
                            status = STATUS_INVALID_PARAMETER;
                        }
                        else
                        {
                            status = STATUS_BUFFER_OVERFLOW;
                        }
                    }
                }
                else
                {
                    size_t cchCopied = 0;
                    
                    status = RtlWideCharArrayCopyStringWorker(pszDestEnd,
                                                              cchRemaining,
                                                              &cchCopied,
                                                              pszSrc,
                                                              cchToAppend);

                    pszDestEnd = pszDestEnd + cchCopied;
                    cchRemaining = cchRemaining - cchCopied;

                    cchNewDestLength = cchDestLength + cchCopied;
                    
                    if (NT_SUCCESS(status)              &&
                        (dwFlags & STRSAFE_FILL_BEHIND) &&
                        (cchRemaining != 0))
                    {
                        // handle the STRSAFE_FILL_BEHIND flag
                        RtlUnicodeStringExHandleFill(pszDestEnd, cchRemaining, dwFlags);
                    }
                }
            }
        }

        if (!NT_SUCCESS(status)                                                                                      &&
            (dwFlags & (STRSAFE_NO_TRUNCATION | STRSAFE_FILL_ON_FAILURE | STRSAFE_ZERO_LENGTH_ON_FAILURE))  &&
            (cchDest != 0))
        {
            // handle the STRSAFE_NO_TRUNCATION, STRSAFE_FILL_ON_FAILURE, and STRSAFE_ZERO_LENGTH_ON_FAILURE flags
            RtlUnicodeStringExHandleOtherFlags(pszDest,
                                               cchDest,
                                               cchDestLength,
                                               &cchNewDestLength,
                                               &pszDestEnd,
                                               &cchRemaining,
                                               dwFlags);
        }
        
        if (DestinationString)
        {
            // safe to multiply cchNewDestLength * sizeof(wchar_t) since cchDest < NTSTRSAFE_UNICODE_STRING_MAX_CCH and sizeof(wchar_t) is 2
            DestinationString->Length = (USHORT)(cchNewDestLength * sizeof(wchar_t));
        }

        if (NT_SUCCESS(status) || (status == STATUS_BUFFER_OVERFLOW))
        {   
            if (RemainingString)
            {
                RemainingString->Length = 0;
                // safe to multiply cchRemaining * sizeof(wchar_t) since cchRemaining < NTSTRSAFE_UNICODE_STRING_MAX_CCH and sizeof(wchar_t) is 2
                RemainingString->MaximumLength = (USHORT)(cchRemaining * sizeof(wchar_t));
                RemainingString->Buffer = pszDestEnd;
            }
        }
    }

    return status;
}
#endif  // !NTSTRSAFE_NO_CCH_FUNCTIONS


#ifndef NTSTRSAFE_NO_CB_FUNCTIONS
/*++

NTSTATUS
RtlUnicodeStringCbCatNEx(
    __inout   PUNICODE_STRING     DestinationString   OPTIONAL,
    __in      PCUNICODE_STRING    SourceString        OPTIONAL,
    __in      size_t              cbToAppend,
    __out_opt PUNICODE_STRING     RemainingString     OPTIONAL,
    __in      DWORD               dwFlags
    );

Routine Description:

    This routine is a safer version of the C built-in function 'strncat', with
    some additional parameters and for PUNICODE_STRINGs. In addition to the
    functionality provided by RtlUnicodeStringCbCatN, this routine
    also returns a PUNICODE_STRING which points to the end of the destination
    string. The flags parameter allows additional controls.

Arguments:

    DestinationString   -   pointer to the counted unicode destination string

    SourceString        -   pointer to the counted unicode source string

    cbToAppend          -   maximum number of bytes to append

    RemainingString     -   if RemainingString is non-null, the function will format
                            the pointer with the remaining buffer and number of
                            bytes left in the destination string

    dwFlags             -   controls some details of the string copy:

        STRSAFE_FILL_BEHIND
                    if the function succeeds, the low byte of dwFlags will be
                    used to fill the uninitialize part of destination buffer

        STRSAFE_IGNORE_NULLS
                    do not fault if DestinationString is null and treat NULL SourceString like
                    empty strings (L""). This flag is useful for emulating
                    functions like lstrcpy
                    
        STRSAFE_FILL_ON_FAILURE
                    if the function fails, the low byte of dwFlags will be
                    used to fill all of the destination buffer. This will
                    overwrite any truncated string returned when the failure is
                    STATUS_BUFFER_OVERFLOW

        STRSAFE_ZERO_LENGTH_ON_FAILURE
                    if the function fails, the destination Length will be set
                    to zero. This will overwrite any truncated string
                    returned when the failure is STATUS_BUFFER_OVERFLOW.

        STRSAFE_NO_TRUNCATION
                    if the function returns STATUS_BUFFER_OVERFLOW, pszDest
                    will not contain a truncated string, it will remain unchanged.

Notes:
    Behavior is undefined if source and destination strings overlap.

    DestinationString and SourceString should not be NULL unless the STRSAFE_IGNORE_NULLS flag
    is specified.  If STRSAFE_IGNORE_NULLS is passed, both DestinationString and SourceString
    may be NULL.  An error may still be returned even though NULLS are ignored
    due to insufficient space.

Return Value:

    STATUS_SUCCESS -   if all of SourceString or the first cbToAppend bytes were
                       concatenated to DestinationString

    failure        -   the operation did not succeed

      STATUS_BUFFER_OVERFLOW
      Note: This status has the severity class Warning - IRPs completed with this
            status do have their data copied back to user mode
                   -   this return value is an indication that the 
                       operation failed due to insufficient space. When this
                       error occurs, the destination buffer is modified to
                       contain a truncated version of the ideal result.
                       This is useful for situations where truncation is ok.

    It is strongly recommended to use the NT_SUCCESS() macro to test the
    return value of this function

--*/

NTSTRSAFEDDI
RtlUnicodeStringCbCatNEx(
    __inout PUNICODE_STRING DestinationString,
    __in PCUNICODE_STRING SourceString,
    __in size_t cbToAppend,
    __out_opt PUNICODE_STRING RemainingString,
    __in DWORD dwFlags)
{
    NTSTATUS status;
    wchar_t* pszDest;
    size_t cchDest;
    size_t cchDestLength;

    status = RtlUnicodeStringValidateDestWorker(DestinationString,
                                                &pszDest,
                                                &cchDest,
                                                &cchDestLength,
                                                NTSTRSAFE_UNICODE_STRING_MAX_CCH,
                                                dwFlags);

    if (NT_SUCCESS(status))
    {
        wchar_t* pszSrc;
        size_t cchSrcLength;
        wchar_t* pszDestEnd = pszDest + cchDestLength;
        size_t cchRemaining = cchDest - cchDestLength;
        size_t cchNewDestLength = cchDestLength;

        status = RtlUnicodeStringValidateSrcWorker(SourceString,
                                                   &pszSrc,
                                                   &cchSrcLength,
                                                   NTSTRSAFE_UNICODE_STRING_MAX_CCH,
                                                   dwFlags);

        if (NT_SUCCESS(status))
        {
            size_t cchToAppend = cbToAppend / sizeof(wchar_t);

            if (cchToAppend > NTSTRSAFE_UNICODE_STRING_MAX_CCH)
            {
                status = STATUS_INVALID_PARAMETER;
            }
            else
            {
                if (cchSrcLength < cchToAppend)
                {
                    cchToAppend = cchSrcLength;
                }

                if (dwFlags & (~STRSAFE_UNICODE_STRING_VALID_FLAGS))
                {
                    status = STATUS_INVALID_PARAMETER;
                }
                else if (cchRemaining == 0)
                {
                    // only fail if there was actually src data to append
                    if (cchToAppend != 0)
                    {
                        if (pszDest == NULL)
                        {
                            status = STATUS_INVALID_PARAMETER;
                        }
                        else
                        {
                            status = STATUS_BUFFER_OVERFLOW;
                        }
                    }
                }
                else
                {
                    size_t cchCopied = 0;
                    
                    status = RtlWideCharArrayCopyWorker(pszDestEnd,
                                                        cchRemaining,
                                                        &cchCopied,
                                                        pszSrc,
                                                        cchToAppend);

                    pszDestEnd = pszDestEnd + cchCopied;
                    cchRemaining = cchRemaining - cchCopied;

                    cchNewDestLength = cchDestLength + cchCopied;
                    
                    if (NT_SUCCESS(status)              &&
                        (dwFlags & STRSAFE_FILL_BEHIND) &&
                        (cchRemaining != 0))
                    {
                        // handle the STRSAFE_FILL_BEHIND flag
                        RtlUnicodeStringExHandleFill(pszDestEnd, cchRemaining, dwFlags);
                    }
                }
            }
        }

        if (!NT_SUCCESS(status)                                                                                      &&
            (dwFlags & (STRSAFE_NO_TRUNCATION | STRSAFE_FILL_ON_FAILURE | STRSAFE_ZERO_LENGTH_ON_FAILURE))  &&
            (cchDest != 0))
        {
            // handle the STRSAFE_NO_TRUNCATION, STRSAFE_FILL_ON_FAILURE, and STRSAFE_ZERO_LENGTH_ON_FAILURE flags
            RtlUnicodeStringExHandleOtherFlags(pszDest,
                                               cchDest,
                                               cchDestLength,
                                               &cchNewDestLength,
                                               &pszDestEnd,
                                               &cchRemaining,
                                               dwFlags);
        }
        
        if (DestinationString)
        {
            // safe to multiply cchNewDestLength * sizeof(wchar_t) since cchDest < NTSTRSAFE_UNICODE_STRING_MAX_CCH and sizeof(wchar_t) is 2
            DestinationString->Length = (USHORT)(cchNewDestLength * sizeof(wchar_t));
        }

        if (NT_SUCCESS(status) || (status == STATUS_BUFFER_OVERFLOW))
        {   
            if (RemainingString)
            {
                RemainingString->Length = 0;
                // safe to multiply cchRemaining * sizeof(wchar_t) since cchRemaining < NTSTRSAFE_UNICODE_STRING_MAX_CCH and sizeof(wchar_t) is 2
                RemainingString->MaximumLength = (USHORT)(cchRemaining * sizeof(wchar_t));
                RemainingString->Buffer = pszDestEnd;
            }
        }
    }

    return status;
}
#endif  // !NTSTRSAFE_NO_CB_FUNCTIONS


/*++

NTSTATUS
RtlUnicodeStringVPrintf(
    __out                 PUNICODE_STRING DestinationString,
    __in __format_string  PCWSTR          pszFormat,
    __in                  va_list         argList
    );

Routine Description:

    This routine is a safer version of the C built-in function 'vsprintf' for
    PUNICODE_STRINGs.

    This function returns an NTSTATUS value, and not a pointer. It returns
    STATUS_SUCCESS if the string was printed without truncation, otherwise it
    will return a failure code. In failure cases it will return a truncated
    version of the ideal result.

Arguments:

    DestinationString   -  pointer to the counted unicode destination string

    pszFormat           -  format string which must be null terminated

    argList             -  va_list from the variable arguments according to the
                           stdarg.h convention

Notes:
    Behavior is undefined if destination, format strings or any arguments
    strings overlap.

    DestinationString and pszFormat should not be NULL. See RtlUnicodeStringVPrintfEx if you
    require the handling of NULL values.

Return Value:

    STATUS_SUCCESS -   if there was sufficient space in the dest buffer for
                       the resultant string

    failure        -   the operation did not succeed

      STATUS_BUFFER_OVERFLOW
      Note: This status has the severity class Warning - IRPs completed with this
            status do have their data copied back to user mode
                   -   this return value is an indication that the print
                       operation failed due to insufficient space. When this
                       error occurs, the destination buffer is modified to
                       contain a truncated version of the ideal result. This is
                       useful for situations where truncation is ok.

    It is strongly recommended to use the NT_SUCCESS() macro to test the
    return value of this function

--*/

NTSTRSAFEDDI
RtlUnicodeStringVPrintf(
    __out PUNICODE_STRING DestinationString, 
    __in __format_string NTSTRSAFE_PCWSTR pszFormat, 
    __in va_list argList)
{
    NTSTATUS status;
    wchar_t* pszDest;
    size_t cchDest;
    
    status = RtlUnicodeStringValidateDestWorker(DestinationString,
                                                &pszDest,
                                                &cchDest,
                                                NULL,
                                                NTSTRSAFE_UNICODE_STRING_MAX_CCH,
                                                0);

    if (NT_SUCCESS(status))
    {
        size_t cchNewDestLength = 0;

        status = RtlWideCharArrayVPrintfWorker(pszDest,
                                               cchDest,
                                               &cchNewDestLength,
                                               pszFormat,
                                               argList);

        // safe to multiply cchNewDestLength * sizeof(wchar_t) since cchDest < NTSTRSAFE_UNICODE_STRING_MAX_CCH and sizeof(wchar_t) is 2
        DestinationString->Length = (USHORT)(cchNewDestLength * sizeof(wchar_t));
    }

    return status;
}


/*++

NTSTATUS
RtlUnicodeStringVPrintfEx(
    __out                PUNICODE_STRING DestinationString   OPTIONAL,
    __out_opt            PUNICODE_STRING RemainingString     OPTIONAL,
    __in                 DWORD   dwFlags,
    __in __format_string PCWSTR  pszFormat                   OPTIONAL,
    __in                 va_list argList
    );

Routine Description:

    This routine is a safer version of the C built-in function 'vsprintf' with
    some additional parameters for PUNICODE_STRING. In addition to the
    functionality provided by RtlUnicodeStringVPrintf, this routine also
    returns a PUNICODE_STRING which points to the end of the destination
    string. The flags parameter allows additional controls.
    
Arguments:

    DestinationString   -   pointer to the counted unicode destination string

    RemainingString     -   if RemainingString is non-null, the function will format
                            the pointer with the remaining buffer and number of
                            bytes left in the destination string

    dwFlags             -   controls some details of the string copy:

        STRSAFE_FILL_BEHIND
                    if the function succeeds, the low byte of dwFlags will be
                    used to fill the uninitialize part of destination buffer

        STRSAFE_IGNORE_NULLS
                    do not fault if DestinationString is null and treat NULL pszFormat like
                    empty strings (L"").

        STRSAFE_FILL_ON_FAILURE
                    if the function fails, the low byte of dwFlags will be
                    used to fill all of the destination buffer. This will
                    overwrite any truncated string returned when the failure is
                    STATUS_BUFFER_OVERFLOW

        STRSAFE_NO_TRUNCATION /
        STRSAFE_ZERO_LENGTH_ON_FAILURE
                    if the function fails, the destination Length will be set
                    to zero. This will overwrite any truncated string
                    returned when the failure is STATUS_BUFFER_OVERFLOW.

    pszFormat           -   format string which must be null terminated

    argList             -   va_list from the variable arguments according to the
                            stdarg.h convention

Notes:
    Behavior is undefined if destination, format strings or any arguments
    strings overlap.

    DestinationString and pszFormat should not be NULL unless the STRSAFE_IGNORE_NULLS
    flag is specified.  If STRSAFE_IGNORE_NULLS is passed, both DestinationString and
    pszFormat may be NULL.  An error may still be returned even though NULLS
    are ignored due to insufficient space.

Return Value:

    STATUS_SUCCESS -   if there was sufficient space in the dest buffer for
                       the resultant string

    failure        -   the operation did not succeed

      STATUS_BUFFER_OVERFLOW
      Note: This status has the severity class Warning - IRPs completed with this
            status do have their data copied back to user mode
                   -   this return value is an indication that the print
                       operation failed due to insufficient space. When this
                       error occurs, the destination buffer is modified to
                       contain a truncated version of the ideal result. This is
                       useful for situations where truncation is ok.

    It is strongly recommended to use the NT_SUCCESS() macro to test the
    return value of this function

--*/

NTSTRSAFEDDI
RtlUnicodeStringVPrintfEx(
    __out PUNICODE_STRING DestinationString, 
    __out_opt PUNICODE_STRING RemainingString, 
    __in DWORD dwFlags,
    __in __format_string NTSTRSAFE_PCWSTR pszFormat, 
    __in va_list argList)
{
    NTSTATUS status;
    wchar_t* pszDest;
    size_t cchDest;

    status = RtlUnicodeStringValidateDestWorker(DestinationString,
                                                &pszDest,
                                                &cchDest,
                                                NULL,
                                                NTSTRSAFE_UNICODE_STRING_MAX_CCH,
                                                dwFlags);

    if (NT_SUCCESS(status))
    {
        wchar_t* pszDestEnd = pszDest;
        size_t cchRemaining = cchDest;
        size_t cchNewDestLength = 0;

        status = RtlStringExValidateSrcW(&pszFormat, NULL, NTSTRSAFE_UNICODE_STRING_MAX_CCH, dwFlags);

        if (NT_SUCCESS(status))
        {
            if (dwFlags & (~STRSAFE_UNICODE_STRING_VALID_FLAGS))
            {
                status = STATUS_INVALID_PARAMETER;
            }
            else if (cchDest == 0)
            {
                // only fail if there was actually a non-empty format string
                if (*pszFormat != L'\0')
                {
                    if (pszDest == NULL)
                    {
                        status = STATUS_INVALID_PARAMETER;
                    }
                    else
                    {
                        status = STATUS_BUFFER_OVERFLOW;
                    }
                }
            }
            else
            {
                status = RtlWideCharArrayVPrintfWorker(pszDest,
                                                       cchDest,
                                                       &cchNewDestLength,
                                                       pszFormat,
                                                       argList);

                pszDestEnd = pszDest + cchNewDestLength;
                cchRemaining = cchDest - cchNewDestLength;
                
                if (NT_SUCCESS(status)              &&
                    (dwFlags & STRSAFE_FILL_BEHIND) &&
                    (cchRemaining != 0))
                {
                    // handle the STRSAFE_FILL_BEHIND flag
                    RtlUnicodeStringExHandleFill(pszDestEnd, cchRemaining, dwFlags);
                }
            }
        }

        if (!NT_SUCCESS(status)                                                                                      &&
            (dwFlags & (STRSAFE_NO_TRUNCATION | STRSAFE_FILL_ON_FAILURE | STRSAFE_ZERO_LENGTH_ON_FAILURE))  &&
            (cchDest != 0))
        {
            // handle the STRSAFE_NO_TRUNCATION, STRSAFE_FILL_ON_FAILURE, and STRSAFE_ZERO_LENGTH_ON_FAILURE flags
            RtlUnicodeStringExHandleOtherFlags(pszDest,
                                               cchDest,
                                               0,
                                               &cchNewDestLength,
                                               &pszDestEnd,
                                               &cchRemaining,
                                               dwFlags);
        }
        
        if (DestinationString)
        {
            // safe to multiply cchNewDestLength * sizeof(wchar_t) since cchDest < NTSTRSAFE_UNICODE_STRING_MAX_CCH and sizeof(wchar_t) is 2
            DestinationString->Length = (USHORT)(cchNewDestLength * sizeof(wchar_t));
        }

        if (NT_SUCCESS(status) || (status == STATUS_BUFFER_OVERFLOW))
        {   
            if (RemainingString)
            {
                RemainingString->Length = 0;
                // safe to multiply cchRemaining * sizeof(wchar_t) since cchRemaining < NTSTRSAFE_UNICODE_STRING_MAX_CCH and sizeof(wchar_t) is 2
                RemainingString->MaximumLength = (USHORT)(cchRemaining * sizeof(wchar_t));
                RemainingString->Buffer = pszDestEnd;
            }
        }
    }

    return status;
}


#ifndef _M_CEE_PURE

/*++

NTSTATUS
RtlUnicodeStringPrintf(
    __out                PUNICODE_STRING DestinationString,
    __in __format_string PCWSTR          pszFormat,
    ...
    );

Routine Description:

    This routine is a safer version of the C built-in function 'sprintf' for
    PUNICODE_STRINGs.

    This function returns an NTSTATUS value, and not a pointer. It returns
    STATUS_SUCCESS if the string was printed without truncation, otherwise it
    will return a failure code. In failure cases it will return a truncated
    version of the ideal result.

Arguments:

    DestinationString   -  pointer to the counted unicode destination string

    pszFormat           -  format string which must be null terminated

    ...                 -  additional parameters to be formatted according to
                           the format string

Notes:
    Behavior is undefined if destination, format strings or any arguments
    strings overlap.

    DestinationString and pszFormat should not be NULL.  See RtlUnicodeStringPrintfEx if you
    require the handling of NULL values.
    
Return Value:

    STATUS_SUCCESS -   if there was sufficient space in the dest buffer for
                       the resultant string

    failure        -   the operation did not succeed

      STATUS_BUFFER_OVERFLOW
      Note: This status has the severity class Warning - IRPs completed with this
            status do have their data copied back to user mode
                   -   this return value is an indication that the print
                       operation failed due to insufficient space. When this
                       error occurs, the destination buffer is modified to
                       contain a truncated version of the ideal result. This is
                       useful for situations where truncation is ok.

    It is strongly recommended to use the NT_SUCCESS() macro to test the
    return value of this function

--*/

NTSTRSAFEDDI
RtlUnicodeStringPrintf(
    __out PUNICODE_STRING DestinationString,
    __in __format_string NTSTRSAFE_PCWSTR pszFormat,
    ...)
{
    NTSTATUS status;
    wchar_t* pszDest;
    size_t cchDest;
    
    status = RtlUnicodeStringValidateDestWorker(DestinationString,
                                                &pszDest,
                                                &cchDest,
                                                NULL,
                                                NTSTRSAFE_UNICODE_STRING_MAX_CCH,
                                                0);

    if (NT_SUCCESS(status))
    {
        va_list argList;
        size_t cchNewDestLength = 0;

        va_start(argList, pszFormat);

        status = RtlWideCharArrayVPrintfWorker(pszDest,
                                               cchDest,
                                               &cchNewDestLength,
                                               pszFormat,
                                               argList);

        va_end(argList);

        // safe to multiply cchNewDestLength * sizeof(wchar_t) since cchDest < NTSTRSAFE_UNICODE_STRING_MAX_CCH and sizeof(wchar_t) is 2
        DestinationString->Length = (USHORT)(cchNewDestLength * sizeof(wchar_t));
    }

    return status;
}


/*++

NTSTATUS
RtlUnicodeStringPrintfEx(
    __out                PUNICODE_STRING DestinationString   OPTIONAL,
    __out_opt            PUNICODE_STRING RemainingString     OPTIONAL,
    __in                 DWORD           dwFlags,
    __in __format_string PCWSTR          pszFormat           OPTIONAL,
    ...
    );

Routine Description:

    This routine is a safer version of the C built-in function 'sprintf' with
    some additional parameters for PUNICODE_STRINGs. In addition to the
    functionality provided by RtlUnicodeStringPrintf, this routine also
    returns a PUNICODE_STRING which points to the end of the destination
    string. The flags parameter allows additional controls.

Arguments:

    DestinationString   -   pointer to the counted unicode destination string

    RemainingString     -   if RemainingString is non-null, the function will format
                            the pointer with the remaining buffer and number of
                            bytes left in the destination string

    dwFlags             -   controls some details of the string copy:

        STRSAFE_FILL_BEHIND
                    if the function succeeds, the low byte of dwFlags will be
                    used to fill the uninitialize part of destination buffer

        STRSAFE_IGNORE_NULLS
                    do not fault if DestinationString is null and treat NULL pszFormat like
                    empty strings (L"").

        STRSAFE_FILL_ON_FAILURE
                    if the function fails, the low byte of dwFlags will be
                    used to fill all of the destination buffer. This will
                    overwrite any truncated string returned when the failure is
                    STATUS_BUFFER_OVERFLOW

        STRSAFE_NO_TRUNCATION /
        STRSAFE_ZERO_LENGTH_ON_FAILURE
                    if the function fails, the destination Length will be set
                    to zero. This will overwrite any truncated string
                    returned when the failure is STATUS_BUFFER_OVERFLOW.

    pszFormat           -   format string which must be null terminated

    ...                 -   additional parameters to be formatted according to
                            the format string

Notes:
    Behavior is undefined if destination, format strings or any arguments
    strings overlap.

    DestinationString and pszFormat should not be NULL unless the STRSAFE_IGNORE_NULLS
    flag is specified.  If STRSAFE_IGNORE_NULLS is passed, both DestinationString and
    pszFormat may be NULL.  An error may still be returned even though NULLS
    are ignored due to insufficient space.

Return Value:

    STATUS_SUCCESS -   if there was sufficient space in the dest buffer for
                       the resultant string

    failure        -   the operation did not succeed


      STATUS_BUFFER_OVERFLOW
      Note: This status has the severity class Warning - IRPs completed with this
            status do have their data copied back to user mode
                   -   this return value is an indication that the print
                       operation failed due to insufficient space. When this
                       error occurs, the destination buffer is modified to
                       contain a truncated version of the ideal result. This is
                       useful for situations where truncation is ok.

    It is strongly recommended to use the NT_SUCCESS() macro to test the
    return value of this function

--*/

NTSTRSAFEDDI
RtlUnicodeStringPrintfEx(
    __out PUNICODE_STRING DestinationString,
    __out_opt PUNICODE_STRING RemainingString,
    __in DWORD dwFlags,
    __in __format_string NTSTRSAFE_PCWSTR pszFormat,
    ...)
{
    NTSTATUS status;
    wchar_t* pszDest;
    size_t cchDest;

    status = RtlUnicodeStringValidateDestWorker(DestinationString,
                                                &pszDest,
                                                &cchDest,
                                                NULL,
                                                NTSTRSAFE_UNICODE_STRING_MAX_CCH,
                                                dwFlags);

    if (NT_SUCCESS(status))
    {
        wchar_t* pszDestEnd = pszDest;
        size_t cchRemaining = cchDest;
        size_t cchNewDestLength = 0;

        status = RtlStringExValidateSrcW(&pszFormat, NULL, NTSTRSAFE_UNICODE_STRING_MAX_CCH, dwFlags);

        if (NT_SUCCESS(status))
        {
            if (dwFlags & (~STRSAFE_UNICODE_STRING_VALID_FLAGS))
            {
                status = STATUS_INVALID_PARAMETER;
            }
            else if (cchDest == 0)
            {
                // only fail if there was actually a non-empty format string
                if (*pszFormat != L'\0')
                {
                    if (pszDest == NULL)
                    {
                        status = STATUS_INVALID_PARAMETER;
                    }
                    else
                    {
                        status = STATUS_BUFFER_OVERFLOW;
                    }
                }
            }
            else
            {
                va_list argList;

                va_start(argList, pszFormat);
                
                status = RtlWideCharArrayVPrintfWorker(pszDest,
                                                       cchDest,
                                                       &cchNewDestLength,
                                                       pszFormat,
                                                       argList);

                va_end(argList);
                
                pszDestEnd = pszDest + cchNewDestLength;
                cchRemaining = cchDest - cchNewDestLength;
                
                if (NT_SUCCESS(status)              &&
                    (dwFlags & STRSAFE_FILL_BEHIND) &&
                    (cchRemaining != 0))
                {
                    // handle the STRSAFE_FILL_BEHIND flag
                    RtlUnicodeStringExHandleFill(pszDestEnd, cchRemaining, dwFlags);
                }
            }
        }

        if (!NT_SUCCESS(status)                                                                                      &&
            (dwFlags & (STRSAFE_NO_TRUNCATION | STRSAFE_FILL_ON_FAILURE | STRSAFE_ZERO_LENGTH_ON_FAILURE))  &&
            (cchDest != 0))
        {
            // handle the STRSAFE_NO_TRUNCATION, STRSAFE_FILL_ON_FAILURE, and STRSAFE_ZERO_LENGTH_ON_FAILURE flags
            RtlUnicodeStringExHandleOtherFlags(pszDest,
                                               cchDest,
                                               0,
                                               &cchNewDestLength,
                                               &pszDestEnd,
                                               &cchRemaining,
                                               dwFlags);
        }
        
        if (DestinationString)
        {
            // safe to multiply cchNewDestLength * sizeof(wchar_t) since cchDest < NTSTRSAFE_UNICODE_STRING_MAX_CCH and sizeof(wchar_t) is 2
            DestinationString->Length = (USHORT)(cchNewDestLength * sizeof(wchar_t));
        }

        if (NT_SUCCESS(status) || (status == STATUS_BUFFER_OVERFLOW))
        {   
            if (RemainingString)
            {
                RemainingString->Length = 0;
                // safe to multiply cchRemaining * sizeof(wchar_t) since cchRemaining < NTSTRSAFE_UNICODE_STRING_MAX_CCH and sizeof(wchar_t) is 2
                RemainingString->MaximumLength = (USHORT)(cchRemaining * sizeof(wchar_t));
                RemainingString->Buffer = pszDestEnd;
            }
        }
    }

    return status;
}

#endif  // !_M_CEE_PURE

#endif  // !NTSTRSAFE_NO_UNICODE_STRING_FUNCTIONS

#endif  // !NTSTRSAFE_LIB_IMPL


// Below here are the worker functions that actually do the work

#if defined(NTSTRSAFE_LIB_IMPL) || !defined(NTSTRSAFE_LIB)

NTSTRSAFEWORKERDDI
RtlStringLengthWorkerA(
    __in NTSTRSAFE_PCSTR psz,
    __in size_t cchMax,
    __out_opt size_t* pcchLength)
{
    NTSTATUS status = STATUS_SUCCESS;
    size_t cchOriginalMax = cchMax;

    while (cchMax && (*psz != '\0'))
    {
        psz++;
        cchMax--;
    }

    if (cchMax == 0)
    {
        // the string is longer than cchMax
        status = STATUS_INVALID_PARAMETER;
    }

    if (pcchLength)
    {
        if (NT_SUCCESS(status))
        {
            *pcchLength = cchOriginalMax - cchMax;
        }
        else
        {
            *pcchLength = 0;
        }
    }

    return status;
}

NTSTRSAFEWORKERDDI
RtlStringLengthWorkerW(
    __in NTSTRSAFE_PCWSTR psz,
    __in size_t cchMax,
    __out_opt size_t* pcchLength)
{
    NTSTATUS status = STATUS_SUCCESS;
    size_t cchOriginalMax = cchMax;

    while (cchMax && (*psz != L'\0'))
    {
        psz++;
        cchMax--;
    }

    if (cchMax == 0)
    {
        // the string is longer than cchMax
        status = STATUS_INVALID_PARAMETER;
    }

    if (pcchLength)
    {
        if (NT_SUCCESS(status))
        {
            *pcchLength = cchOriginalMax - cchMax;
        }
        else
        {
            *pcchLength = 0;
        }
    }

    return status;
}

#ifdef ALIGNMENT_MACHINE
NTSTRSAFEWORKERDDI
RtlUnalignedStringLengthWorkerW(
    __in NTSTRSAFE_PCUWSTR psz,
    __in size_t cchMax,
    __out_opt size_t* pcchLength)
{
    NTSTATUS status = STATUS_SUCCESS;
    size_t cchOriginalMax = cchMax;

    while (cchMax && (*psz != L'\0'))
    {
        psz++;
        cchMax--;
    }

    if (cchMax == 0)
    {
        // the string is longer than cchMax
        status = STATUS_INVALID_PARAMETER;
    }

    if (pcchLength)
    {
        if (NT_SUCCESS(status))
        {
            *pcchLength = cchOriginalMax - cchMax;
        }
        else
        {
            *pcchLength = 0;
        }
    }

    return status;
}
#endif  // ALIGNMENT_MACHINE

NTSTRSAFEWORKERDDI
RtlStringExValidateSrcA(
    __deref_inout_opt NTSTRSAFE_PCSTR* ppszSrc,
    __inout_opt size_t* pcchToRead,
    __in size_t cchMax,
    __in DWORD dwFlags)
{
    NTSTATUS status = STATUS_SUCCESS;

    if (pcchToRead && (*pcchToRead >= cchMax))
    {
        status = STATUS_INVALID_PARAMETER;
    }
    else if ((dwFlags & STRSAFE_IGNORE_NULLS) && (*ppszSrc == NULL))
    {
        *ppszSrc = "";

        if (pcchToRead)
        {
            *pcchToRead = 0;
        }
    }
    
    return status;
}

NTSTRSAFEWORKERDDI
RtlStringExValidateSrcW(
    __deref_inout_opt NTSTRSAFE_PCWSTR* ppszSrc,
    __inout_opt size_t* pcchToRead,
    __in size_t cchMax,
    __in DWORD dwFlags)
{
    NTSTATUS status = STATUS_SUCCESS;

    if (pcchToRead && (*pcchToRead >= cchMax))
    {
        status = STATUS_INVALID_PARAMETER;
    }
    else if ((dwFlags & STRSAFE_IGNORE_NULLS) && (*ppszSrc == NULL))
    {
        *ppszSrc = L"";
        
        if (pcchToRead)
        {
            *pcchToRead = 0;
        }
    }

    return status;
}

NTSTRSAFEWORKERDDI
RtlStringValidateDestA(
    __in_ecount_opt(cchDest) NTSTRSAFE_PSTR pszDest,
    __in size_t cchDest,
    __out_opt size_t* pcchDestLength,
    __in size_t cchMax)
{
    NTSTATUS status = STATUS_SUCCESS;

    if ((cchDest == 0) || (cchDest > cchMax))
    {
        status = STATUS_INVALID_PARAMETER;
    }

    if (pcchDestLength)
    {
        if (NT_SUCCESS(status))
        {
            status = RtlStringLengthWorkerA(pszDest, cchDest, pcchDestLength);
        }
        else
        {
            *pcchDestLength = 0;
        }
    }

    return status;
}

NTSTRSAFEWORKERDDI
RtlStringValidateDestW(
    __in_ecount_opt(cchDest) NTSTRSAFE_PWSTR pszDest,
    __in size_t cchDest,
    __out_opt size_t* pcchDestLength,
    __in size_t cchMax)
{
    NTSTATUS status = STATUS_SUCCESS;

    if ((cchDest == 0) || (cchDest > cchMax))
    {
        status = STATUS_INVALID_PARAMETER;
    }

    if (pcchDestLength)
    {
        if (NT_SUCCESS(status))
        {
            status = RtlStringLengthWorkerW(pszDest, cchDest, pcchDestLength);
        }
        else
        {
            *pcchDestLength = 0;
        }
    }

    return status;
}

NTSTRSAFEWORKERDDI
RtlStringExValidateDestA(
    __deref_inout_opt NTSTRSAFE_PSTR* ppszDest,
    __inout size_t* pcchDest,
    __out_opt size_t* pcchDestLength,
    __in size_t cchMax,
    __in DWORD dwFlags)
{
    NTSTATUS status = STATUS_SUCCESS;
    
    if (dwFlags & STRSAFE_IGNORE_NULLS)
    {
        if (((*ppszDest == NULL) && (*pcchDest != 0))   ||
            (*pcchDest > cchMax))
        {
            status = STATUS_INVALID_PARAMETER;
        }
        
        if (pcchDestLength)
        {
            if (!NT_SUCCESS(status) || (*pcchDest == 0))
            {
                *pcchDestLength = 0;
            }
            else
            {
                status = RtlStringLengthWorkerA(*ppszDest, *pcchDest, pcchDestLength);
            }
        }
    }
    else
    {
        status = RtlStringValidateDestA(*ppszDest, *pcchDest, pcchDestLength, cchMax);
    }

    return status;
}

NTSTRSAFEWORKERDDI
RtlStringExValidateDestW(
    __deref_inout_opt NTSTRSAFE_PWSTR* ppszDest,
    __inout size_t* pcchDest,
    __out_opt size_t* pcchDestLength,
    __in size_t cchMax,
    __in DWORD dwFlags)
{
    NTSTATUS status = STATUS_SUCCESS;
    
    if (dwFlags & STRSAFE_IGNORE_NULLS)
    {
        if (((*ppszDest == NULL) && (*pcchDest != 0))   ||
            (*pcchDest > cchMax))
        {
            status = STATUS_INVALID_PARAMETER;
        }
        
        if (pcchDestLength)
        {
            if (!NT_SUCCESS(status) || (*pcchDest == 0))
            {
                *pcchDestLength = 0;
            }
            else
            {
                status = RtlStringLengthWorkerW(*ppszDest, *pcchDest, pcchDestLength);
            }
        }
    }
    else
    {
        status = RtlStringValidateDestW(*ppszDest, *pcchDest, pcchDestLength, cchMax);
    }

    return status;
}

NTSTRSAFEWORKERDDI
RtlStringCopyWorkerA(
    __out_ecount(cchDest) NTSTRSAFE_PSTR pszDest,
    __in size_t cchDest,
    __out_opt size_t* pcchNewDestLength,
    __in NTSTRSAFE_PCSTR pszSrc,
    __in size_t cchToCopy)
{
    NTSTATUS status = STATUS_SUCCESS;
    size_t cchNewDestLength = 0;
    
    // ASSERT(cchDest != 0);

    while (cchDest && cchToCopy && (*pszSrc != '\0'))
    {
        *pszDest++ = *pszSrc++;
        cchDest--;
        cchToCopy--;

        cchNewDestLength++;
    }

    if (cchDest == 0)
    {
        // we are going to truncate pszDest
        pszDest--;
        cchNewDestLength--;

        status = STATUS_BUFFER_OVERFLOW;
    }

    *pszDest= '\0';

    if (pcchNewDestLength)
    {
        *pcchNewDestLength = cchNewDestLength;
    }

    return status;
}

NTSTRSAFEWORKERDDI
RtlStringCopyWorkerW(
    __out_ecount(cchDest) wchar_t* pszDest,
    __in size_t cchDest,
    __out_opt size_t* pcchNewDestLength,
    __in NTSTRSAFE_PCWSTR pszSrc,
    __in size_t cchToCopy)
{
    NTSTATUS status = STATUS_SUCCESS;
    size_t cchNewDestLength = 0;
    
    // ASSERT(cchDest != 0);

    while (cchDest && cchToCopy && (*pszSrc != L'\0'))
    {
        *pszDest++ = *pszSrc++;
        cchDest--;
        cchToCopy--;

        cchNewDestLength++;
    }

    if (cchDest == 0)
    {
        // we are going to truncate pszDest
        pszDest--;
        cchNewDestLength--;

        status = STATUS_BUFFER_OVERFLOW;
    }

    *pszDest= L'\0';

    if (pcchNewDestLength)
    {
        *pcchNewDestLength = cchNewDestLength;
    }

    return status;
}

NTSTRSAFEWORKERDDI
RtlStringVPrintfWorkerA(
    __out_ecount(cchDest) NTSTRSAFE_PSTR pszDest,
    __in size_t cchDest,
    __out_opt size_t* pcchNewDestLength,
    __in __format_string NTSTRSAFE_PCSTR pszFormat,
    __in va_list argList)
{
    NTSTATUS status = STATUS_SUCCESS;
    int iRet;
    size_t cchMax;
    size_t cchNewDestLength = 0;

    // leave the last space for the null terminator
    cchMax = cchDest - 1;

#if (NTSTRSAFE_USE_SECURE_CRT == 1) && !defined(NTSTRSAFE_LIB_IMPL)
    iRet = _vsnprintf_s(pszDest, cchDest, cchMax, pszFormat, argList);
#else
    iRet = _vsnprintf(pszDest, cchMax, pszFormat, argList);
#endif
    // ASSERT((iRet < 0) || (((size_t)iRet) <= cchMax));

    if ((iRet < 0) || (((size_t)iRet) > cchMax))
    {
        // need to null terminate the string
        pszDest += cchMax;
        *pszDest = '\0';

        cchNewDestLength = cchMax;

        // we have truncated pszDest
        status = STATUS_BUFFER_OVERFLOW;
    }
    else if (((size_t)iRet) == cchMax)
    {
        // need to null terminate the string
        pszDest += cchMax;
        *pszDest = '\0';

        cchNewDestLength = cchMax;
    }
    else
    {
        cchNewDestLength = (size_t)iRet;
    }

    if (pcchNewDestLength)
    {
        *pcchNewDestLength = cchNewDestLength;
    }

    return status;
}

NTSTRSAFEWORKERDDI
RtlStringVPrintfWorkerW(
    __out_ecount(cchDest) NTSTRSAFE_PWSTR pszDest,
    __in size_t cchDest,
    __out_opt size_t* pcchNewDestLength,
    __in __format_string NTSTRSAFE_PCWSTR pszFormat,
    __in va_list argList)
{
    NTSTATUS status = STATUS_SUCCESS;
    int iRet;
    size_t cchMax;
    size_t cchNewDestLength = 0;

    // leave the last space for the null terminator
    cchMax = cchDest - 1;

#if (NTSTRSAFE_USE_SECURE_CRT == 1) && !defined(NTSTRSAFE_LIB_IMPL)
    iRet = _vsnwprintf_s(pszDest, cchDest, cchMax, pszFormat, argList);
#else
    iRet = _vsnwprintf(pszDest, cchMax, pszFormat, argList);
#endif
    // ASSERT((iRet < 0) || (((size_t)iRet) <= cchMax));

    if ((iRet < 0) || (((size_t)iRet) > cchMax))
    {
        // need to null terminate the string
        pszDest += cchMax;
        *pszDest = L'\0';

        cchNewDestLength = cchMax;

        // we have truncated pszDest
        status = STATUS_BUFFER_OVERFLOW;
    }
    else if (((size_t)iRet) == cchMax)
    {
        // need to null terminate the string
        pszDest += cchMax;
        *pszDest = L'\0';

        cchNewDestLength = cchMax;
    }
    else
    {
        cchNewDestLength = (size_t)iRet;
    }

    if (pcchNewDestLength)
    {
        *pcchNewDestLength = cchNewDestLength;
    }

    return status;
}


NTSTRSAFEWORKERDDI
RtlStringExHandleFillBehindNullA(
    __out_bcount(cbRemaining) NTSTRSAFE_PSTR pszDestEnd,
    __in size_t cbRemaining,
    __in DWORD dwFlags)
{
    if (cbRemaining > sizeof(char))
    {
        memset(pszDestEnd + 1, STRSAFE_GET_FILL_PATTERN(dwFlags), cbRemaining - sizeof(char));
    }
    
    return STATUS_SUCCESS;
}

NTSTRSAFEWORKERDDI
RtlStringExHandleFillBehindNullW(
    __out_bcount(cbRemaining) NTSTRSAFE_PWSTR pszDestEnd,
    __in size_t cbRemaining,
    __in DWORD dwFlags)
{
    if (cbRemaining > sizeof(wchar_t))
    {
        memset(pszDestEnd + 1, STRSAFE_GET_FILL_PATTERN(dwFlags), cbRemaining - sizeof(wchar_t));
    }
    
    return STATUS_SUCCESS;
}

NTSTRSAFEWORKERDDI
RtlStringExHandleOtherFlagsA(
    __out_bcount(cbDest) NTSTRSAFE_PSTR pszDest,
    __in size_t cbDest,
    __in size_t cchOriginalDestLength,
    __deref_out_ecount(*pcchRemaining) NTSTRSAFE_PSTR* ppszDestEnd,
    __out size_t* pcchRemaining,
    __in DWORD dwFlags)
{
    size_t cchDest = cbDest / sizeof(char);
    
    if ((cchDest > 0) && (dwFlags & STRSAFE_NO_TRUNCATION))
    {
        char* pszOriginalDestEnd;

        pszOriginalDestEnd = pszDest + cchOriginalDestLength;

        *ppszDestEnd = pszOriginalDestEnd;
        *pcchRemaining = cchDest - cchOriginalDestLength;

        // null terminate the end of the original string
        *pszOriginalDestEnd = '\0';
    }

    if (dwFlags & STRSAFE_FILL_ON_FAILURE)
    {
        memset(pszDest, STRSAFE_GET_FILL_PATTERN(dwFlags), cbDest);

        if (STRSAFE_GET_FILL_PATTERN(dwFlags) == 0)
        {
            *ppszDestEnd = pszDest;
            *pcchRemaining = cchDest;
        }
        else if (cchDest > 0)
        {
            char* pszDestEnd;
            
            pszDestEnd = pszDest + cchDest - 1;

            *ppszDestEnd = pszDestEnd;
            *pcchRemaining = 1;

            // null terminate the end of the string
            *pszDestEnd = L'\0';
        }
    }

    if ((cchDest > 0) && (dwFlags & STRSAFE_NULL_ON_FAILURE))
    {
        *ppszDestEnd = pszDest;
        *pcchRemaining = cchDest;

        // null terminate the beginning of the string
        *pszDest = '\0';
    }

    return STATUS_SUCCESS;
}

NTSTRSAFEWORKERDDI
RtlStringExHandleOtherFlagsW(
    __out_bcount(cbDest) NTSTRSAFE_PWSTR pszDest,
    __in size_t cbDest,
    __in size_t cchOriginalDestLength,
    __deref_out_ecount(*pcchRemaining)NTSTRSAFE_PWSTR* ppszDestEnd,
    __out size_t* pcchRemaining,
    __in DWORD dwFlags)
{
    size_t cchDest = cbDest / sizeof(wchar_t);
    
    if ((cchDest > 0) && (dwFlags & STRSAFE_NO_TRUNCATION))
    {
        wchar_t* pszOriginalDestEnd;

        pszOriginalDestEnd = pszDest + cchOriginalDestLength;

        *ppszDestEnd = pszOriginalDestEnd;
        *pcchRemaining = cchDest - cchOriginalDestLength;

        // null terminate the end of the original string
        *pszOriginalDestEnd = L'\0';
    }

    if (dwFlags & STRSAFE_FILL_ON_FAILURE)
    {
        memset(pszDest, STRSAFE_GET_FILL_PATTERN(dwFlags), cbDest);

        if (STRSAFE_GET_FILL_PATTERN(dwFlags) == 0)
        {
            *ppszDestEnd = pszDest;
            *pcchRemaining = cchDest;
        }
        else if (cchDest > 0)
        {
            wchar_t* pszDestEnd;
            
            pszDestEnd = pszDest + cchDest - 1;

            *ppszDestEnd = pszDestEnd;
            *pcchRemaining = 1;

            // null terminate the end of the string
            *pszDestEnd = L'\0';
        }
    }

    if ((cchDest > 0) && (dwFlags & STRSAFE_NULL_ON_FAILURE))
    {
        *ppszDestEnd = pszDest;
        *pcchRemaining = cchDest;

        // null terminate the beginning of the string
        *pszDest = L'\0';
    }

    return STATUS_SUCCESS;
}

#ifndef NTSTRSAFE_NO_UNICODE_STRING_FUNCTIONS

NTSTRSAFEWORKERDDI
RtlUnicodeStringInitWorker(
    __out PUNICODE_STRING DestinationString,
    __in_opt NTSTRSAFE_PCWSTR pszSrc,
    __in size_t cchMax,
    __in DWORD dwFlags)
{
    NTSTATUS status = STATUS_SUCCESS;

    if (DestinationString || !(dwFlags & STRSAFE_IGNORE_NULLS))
    {
        DestinationString->Length = 0;
        DestinationString->MaximumLength = 0;
        DestinationString->Buffer = NULL;
    }

    if (pszSrc)
    {
        size_t cchSrcLength;

        status = RtlStringLengthWorkerW(pszSrc, cchMax, &cchSrcLength);

        if (NT_SUCCESS(status))
        {
            if (DestinationString)
            {
                size_t cbLength;
                
                // safe to multiply cchSrcLength * sizeof(wchar_t) since cchSrcLength < NTSTRSAFE_UNICODE_STRING_MAX_CCH and sizeof(wchar_t) is 2
                cbLength = cchSrcLength * sizeof(wchar_t);

                DestinationString->Length = (USHORT)cbLength;
                // safe to add cbLength + sizeof(wchar_t) since cchSrcLength < NTSTRSAFE_UNICODE_STRING_MAX_CCH
                DestinationString->MaximumLength = (USHORT)(cbLength + sizeof(wchar_t));
                DestinationString->Buffer = (PWSTR)pszSrc;
            }
            else
            {
                status = STATUS_INVALID_PARAMETER;
            }
        }
    }

    return status;
}

NTSTRSAFEWORKERDDI
RtlUnicodeStringValidateWorker(
    __in_opt PCUNICODE_STRING SourceString,
    __in size_t cchMax,
    __in DWORD dwFlags)
{
    NTSTATUS status = STATUS_SUCCESS;

    if (SourceString || !(dwFlags & STRSAFE_IGNORE_NULLS))
    {
        if (((SourceString->Length % sizeof(wchar_t)) != 0)         ||
            ((SourceString->MaximumLength % sizeof(wchar_t)) != 0)  ||
            (SourceString->Length > SourceString->MaximumLength)    ||
            (SourceString->MaximumLength > (cchMax * sizeof(wchar_t))))
        {
            status = STATUS_INVALID_PARAMETER;
        }
        else if ((SourceString->Buffer == NULL) &&
                 ((SourceString->Length != 0) || (SourceString->MaximumLength != 0)))
        {
            status = STATUS_INVALID_PARAMETER;
        }
    }

    return status;
}

NTSTRSAFEWORKERDDI
RtlUnicodeStringValidateSrcWorker(
    __in PCUNICODE_STRING SourceString,
    __deref_out_ecount(*pcchSrcLength) wchar_t** ppszSrc,
    __out size_t* pcchSrcLength,
    __in size_t cchMax,
    __in DWORD dwFlags)
{
    NTSTATUS status;

    *ppszSrc = NULL;
    *pcchSrcLength = 0;

    status = RtlUnicodeStringValidateWorker(SourceString, cchMax, dwFlags);

    if (NT_SUCCESS(status))
    {
        if (SourceString)
        {
            *ppszSrc = SourceString->Buffer;
            *pcchSrcLength = SourceString->Length / sizeof(wchar_t);
        }

        if ((*ppszSrc == NULL) && (dwFlags & STRSAFE_IGNORE_NULLS))
        {
            *ppszSrc = L"";
        }
    }

    return status;
}

NTSTRSAFEWORKERDDI
RtlUnicodeStringValidateDestWorker(
    __in PCUNICODE_STRING DestinationString,
    __deref_out_ecount(*pcchDest) wchar_t** ppszDest,
    __out size_t* pcchDest,
    __out_opt size_t* pcchDestLength,
    __in size_t cchMax,
    __in DWORD dwFlags)
{
    NTSTATUS status;

    *ppszDest = NULL;
    *pcchDest = 0;

    if (pcchDestLength)
    {
        *pcchDestLength = 0;
    }

    status = RtlUnicodeStringValidateWorker(DestinationString, cchMax, dwFlags);

    if (NT_SUCCESS(status) && DestinationString)
    {
        *ppszDest = DestinationString->Buffer;
        *pcchDest = DestinationString->MaximumLength / sizeof(wchar_t);

        if (pcchDestLength)
        {
            *pcchDestLength = DestinationString->Length / sizeof(wchar_t);
        }
    }

    return status;
}

NTSTRSAFEWORKERDDI
RtlStringCopyWideCharArrayWorker(
    __out_ecount(cchDest) NTSTRSAFE_PWSTR pszDest,
    __in size_t cchDest,
    __out_opt size_t* pcchNewDestLength,
    __in_ecount(cchSrcLength) const wchar_t* pszSrc,
    __in size_t cchSrcLength)
{
    NTSTATUS status = STATUS_SUCCESS;
    size_t cchNewDestLength = 0;

    // ASSERT(cchDest != 0);
    
    while (cchDest && cchSrcLength)
    {
        *pszDest++ = *pszSrc++;
        cchDest--;
        cchSrcLength--;

        cchNewDestLength++;
    }

    if (cchDest == 0)
    {
        // we are going to truncate pszDest
        pszDest--;
        cchNewDestLength--;

        status = STATUS_BUFFER_OVERFLOW;
    }

    *pszDest = L'\0';

    if (pcchNewDestLength)
    {
        *pcchNewDestLength = cchNewDestLength;
    }

    return status;
}

NTSTRSAFEWORKERDDI
RtlWideCharArrayCopyStringWorker(
    __out_ecount(cchDest) wchar_t* pszDest,
    __in size_t cchDest,
    __out size_t* pcchNewDestLength,
    __in NTSTRSAFE_PCWSTR pszSrc,
    __in size_t cchToCopy)
{
    NTSTATUS status = STATUS_SUCCESS;
    size_t cchNewDestLength = 0;

    while (cchDest && cchToCopy && (*pszSrc != L'\0'))
    {
        *pszDest++ = *pszSrc++;
        cchDest--;
        cchToCopy--;

        cchNewDestLength++;
    }

    if ((cchDest == 0) && (cchToCopy != 0) && (*pszSrc != L'\0'))
    {
        // we are going to truncate pszDest
        status = STATUS_BUFFER_OVERFLOW;
    }

    *pcchNewDestLength = cchNewDestLength;

    return status;
}

NTSTRSAFEWORKERDDI
RtlWideCharArrayCopyWorker(
    __out_ecount(cchDest) wchar_t* pszDest,
    __in size_t cchDest,
    __out size_t* pcchNewDestLength,
    __in_ecount(cchSrcLength) const wchar_t* pszSrc,
    __in size_t cchSrcLength)
{
    NTSTATUS status = STATUS_SUCCESS;
    size_t cchNewDestLength = 0;

    while (cchDest && cchSrcLength)
    {
        *pszDest++ = *pszSrc++;
        cchDest--;
        cchSrcLength--;

        cchNewDestLength++;
    }
    
    if ((cchDest == 0) && (cchSrcLength != 0))
    {
        // we are going to truncate pszDest
        status = STATUS_BUFFER_OVERFLOW;
    }

    *pcchNewDestLength = cchNewDestLength;

    return status;
}

NTSTRSAFEWORKERDDI
RtlWideCharArrayVPrintfWorker(
    __out_ecount(cchDest) wchar_t* pszDest,
    __in size_t cchDest,
    __out size_t* pcchNewDestLength,
    __in __format_string NTSTRSAFE_PCWSTR pszFormat,
    __in va_list argList)
{
    NTSTATUS status = STATUS_SUCCESS;
    int iRet;
    
    iRet = _vsnwprintf(pszDest, cchDest, pszFormat, argList);
    // ASSERT((iRet < 0) || (((size_t)iRet) <= cchMax));

    if ((iRet < 0) || (((size_t)iRet) > cchDest))
    {
        *pcchNewDestLength = cchDest;

        // we have truncated pszDest
        status = STATUS_BUFFER_OVERFLOW;
    }
    else
    {
        *pcchNewDestLength = (size_t)iRet;
    }

    return status;
}

NTSTRSAFEWORKERDDI
RtlUnicodeStringExHandleFill(
    __out_ecount(cchRemaining) wchar_t* pszDestEnd,
    __in size_t cchRemaining,
    __in DWORD dwFlags)
{
    size_t cbRemaining;

    // safe to multiply cchRemaining * sizeof(wchar_t) since cchRemaining < NTSTRSAFE_UNICODE_STRING_MAX_CCH and sizeof(wchar_t) is 2
    cbRemaining = cchRemaining * sizeof(wchar_t);

    memset(pszDestEnd, STRSAFE_GET_FILL_PATTERN(dwFlags), cbRemaining);
    
    return STATUS_SUCCESS;
}

NTSTRSAFEWORKERDDI
RtlUnicodeStringExHandleOtherFlags(
    __out_bcount(cchDest) wchar_t* pszDest,
    __in size_t cchDest,
    __in size_t cchOriginalDestLength,
    __out size_t* pcchNewDestLength,
    __deref_out_ecount(*pcchRemaining) wchar_t** ppszDestEnd,
    __out size_t* pcchRemaining,
    __in DWORD dwFlags)
{
    if (dwFlags & STRSAFE_NO_TRUNCATION)
    {
        *ppszDestEnd = pszDest + cchOriginalDestLength;
        *pcchRemaining = cchDest - cchOriginalDestLength;

        *pcchNewDestLength = cchOriginalDestLength;
    }
    
    if (dwFlags & STRSAFE_FILL_ON_FAILURE)
    {
        size_t cbDest;
        
        // safe to multiply cchDest * sizeof(wchar_t) since cchDest < NTSTRSAFE_UNICODE_STRING_MAX_CCH and sizeof(wchar_t) is 2
        cbDest = cchDest * sizeof(wchar_t);

        memset(pszDest, STRSAFE_GET_FILL_PATTERN(dwFlags), cbDest);

        *ppszDestEnd = pszDest;
        *pcchRemaining = cchDest;

        *pcchNewDestLength = 0;
    }
    
    if (dwFlags & STRSAFE_ZERO_LENGTH_ON_FAILURE)
    {
        *ppszDestEnd = pszDest;
        *pcchRemaining = cchDest;

        *pcchNewDestLength = 0;
    }

    return STATUS_SUCCESS;
}

#endif  // !NTSTRSAFE_NO_UNICODE_STRING_FUNCTIONS

#endif  // defined(NTSTRSAFE_LIB_IMPL) || !defined(NTSTRSAFE_LIB)


// Do not call these functions, they are worker functions for internal use within this file
#ifdef DEPRECATE_SUPPORTED
#pragma deprecated(RtlStringLengthWorkerA)
#pragma deprecated(RtlStringLengthWorkerW)
#pragma deprecated(RtlUnalignedStringLengthWorkerW)
#pragma deprecated(RtlStringExValidateSrcA)
#pragma deprecated(RtlStringExValidateSrcW)
#pragma deprecated(RtlStringValidateDestA)
#pragma deprecated(RtlStringValidateDestW)
#pragma deprecated(RtlStringExValidateDestA)
#pragma deprecated(RtlStringExValidateDestW)
#pragma deprecated(RtlStringCopyWorkerA)
#pragma deprecated(RtlStringCopyWorkerW)
#pragma deprecated(RtlStringVPrintfWorkerA)
#pragma deprecated(RtlStringVPrintfWorkerW)
#pragma deprecated(RtlStringExHandleFillBehindNullA)
#pragma deprecated(RtlStringExHandleFillBehindNullW)
#pragma deprecated(RtlStringExHandleOtherFlagsA)
#pragma deprecated(RtlStringExHandleOtherFlagsW)
#pragma deprecated(RtlUnicodeStringInitWorker)
#pragma deprecated(RtlUnicodeStringValidateWorker)
#pragma deprecated(RtlUnicodeStringValidateSrcWorker)
#pragma deprecated(RtlUnicodeStringValidateDestWorker)
#pragma deprecated(RtlStringCopyWideCharArrayWorker)
#pragma deprecated(RtlWideCharArrayCopyStringWorker)
#pragma deprecated(RtlWideCharArrayCopyWorker)
#pragma deprecated(RtlWideCharArrayVPrintfWorker)
#pragma deprecated(RtlUnicodeStringExHandleFill)
#pragma deprecated(RtlUnicodeStringExHandleOtherFlags)
#else
#define RtlStringLengthWorkerA             RtlStringLengthWorkerA_instead_use_StringCchLengthA_or_StringCbLengthA
#define RtlStringLengthWorkerW             RtlStringLengthWorkerW_instead_use_StringCchLengthW_or_StringCbLengthW
#define RtlUnalignedStringLengthWorkerW    RtlUnalignedStringLengthWorkerW_instead_use_UnalignedStringCchLengthW
#define RtlStringExValidateSrcA            RtlStringExValidateSrcA_do_not_call_this_function
#define RtlStringExValidateSrcW            RtlStringExValidateSrcW_do_not_call_this_function
#define RtlStringValidateDestA             RtlStringValidateDestA_do_not_call_this_function
#define RtlStringValidateDestW             RtlStringValidateDestW_do_not_call_this_function
#define RtlStringExValidateDestA           RtlStringExValidateDestA_do_not_call_this_function
#define RtlStringExValidateDestW           RtlStringExValidateDestW_do_not_call_this_function
#define RtlStringCopyWorkerA               RtlStringCopyWorkerA_instead_use_StringCchCopyA_or_StringCbCopyA
#define RtlStringCopyWorkerW               RtlStringCopyWorkerW_instead_use_StringCchCopyW_or_StringCbCopyW
#define RtlStringVPrintfWorkerA            RtlStringVPrintfWorkerA_instead_use_StringCchVPrintfA_or_StringCbVPrintfA
#define RtlStringVPrintfWorkerW            RtlStringVPrintfWorkerW_instead_use_StringCchVPrintfW_or_StringCbVPrintfW
#define RtlStringExHandleFillBehindNullA   RtlStringExHandleFillBehindNullA_do_not_call_this_function
#define RtlStringExHandleFillBehindNullW   RtlStringExHandleFillBehindNullW_do_not_call_this_function
#define RtlStringExHandleOtherFlagsA       RtlStringExHandleOtherFlagsA_do_not_call_this_function
#define RtlStringExHandleOtherFlagsW       RtlStringExHandleOtherFlagsW_do_not_call_this_function
#define RtlUnicodeStringInitWorker          RtlUnicodeStringInitWorker_instead_use_RtlUnicodeStringInit_or_RtlUnicodeStringInitEx
#define RtlUnicodeStringValidateWorker      RtlUnicodeStringValidateWorker_instead_use_RtlUnicodeStringValidate_or_RtlUnicodeStringValidateEx
#define RtlUnicodeStringValidateSrcWorker   RtlUnicodeStringValidateSrcWorker_do_not_call_this_function
#define RtlUnicodeStringValidateDestWorker  RtlUnicodeStringValidateDestWorker_do_not_call_this_function
#define RtlStringCopyWideCharArrayWorker    RtlStringCopyWideCharArrayWorker_instead_use_RtlStringCchCopyUnicodeString_or_RtlStringCbCopyUnicodeString
#define RtlWideCharArrayCopyStringWorker    RtlWideCharArrayCopyStringWorker_instead_use_RtlUnicodeStringCopyString_or_RtlUnicodeStringCopyStringEx
#define RtlWideCharArrayCopyWorker          RtlWideCharArrayCopyWorker_instead_use_RtlUnicodeStringCopy_or_RtlUnicodeStringCopyEx
#define RtlWideCharArrayVPrintfWorker       RtlWideCharArrayVPrintfWorker_instead_use_RtlUnicodeStringVPrintf_or_RtlUnicodeStringPrintf
#define RtlUnicodeStringExHandleFill        RtlUnicodeStringExHandleFill_do_not_call_this_function
#define RtlUnicodeStringExHandleOtherFlags  RtlUnicodeStringExHandleOtherFlags_do_not_call_this_function
#endif // !DEPRECATE_SUPPORTED


#ifndef NTSTRSAFE_NO_DEPRECATE
// Deprecate all of the unsafe functions to generate compiletime errors. If you do not want
// this then you can #define NTSTRSAFE_NO_DEPRECATE before including this file
#ifdef DEPRECATE_SUPPORTED

#pragma deprecated(strcpy)
#pragma deprecated(wcscpy)
#pragma deprecated(strcat)
#pragma deprecated(wcscat)
#pragma deprecated(sprintf)
#pragma deprecated(swprintf)
#pragma deprecated(vsprintf)
#pragma deprecated(vswprintf)
#pragma deprecated(_snprintf)
#pragma deprecated(_snwprintf)
#pragma deprecated(_vsnprintf)
#pragma deprecated(_vsnwprintf)

#else // DEPRECATE_SUPPORTED

#undef strcpy
#define strcpy      strcpy_instead_use_StringCchCopyA_or_StringCbCopyA;

#undef wcscpy
#define wcscpy      wcscpy_instead_use_StringCchCopyW_or_StringCbCopyW;

#undef strcat
#define strcat      strcat_instead_use_StringCchCatA_or_StringCbCatA;

#undef wcscat
#define wcscat      wcscat_instead_use_StringCchCatW_or_StringCbCatW;

#undef sprintf
#define sprintf     sprintf_instead_use_StringCchPrintfA_or_StringCbPrintfA;

#undef swprintf
#define swprintf    swprintf_instead_use_StringCchPrintfW_or_StringCbPrintfW;

#undef vsprintf
#define vsprintf    vsprintf_instead_use_StringCchVPrintfA_or_StringCbVPrintfA;

#undef vswprintf
#define vswprintf   vswprintf_instead_use_StringCchVPrintfW_or_StringCbVPrintfW;

#undef _snprintf
#define _snprintf   _snprintf_instead_use_StringCchPrintfA_or_StringCbPrintfA;

#undef _snwprintf
#define _snwprintf  _snwprintf_instead_use_StringCchPrintfW_or_StringCbPrintfW;

#undef _vsnprintf
#define _vsnprintf  _vsnprintf_instead_use_StringCchVPrintfA_or_StringCbVPrintfA;

#undef _vsnwprintf
#define _vsnwprintf _vsnwprintf_instead_use_StringCchVPrintfW_or_StringCbVPrintfW;

#endif  // DEPRECATE_SUPPORTED
#endif  // !NTSTRSAFE_NO_DEPRECATE

#pragma warning(pop)

#endif  // _NTSTRSAFE_H_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\parallel.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

	parallel.h

Abstract:

	This file defines the services supplied by the ParPort driver.

Revision History:

--*/

#ifndef _PARALLEL_
#define _PARALLEL_

#include <ntddpar.h>

//
// Define the parallel port device name strings.
//

#define DD_PARALLEL_PORT_BASE_NAME_U   L"ParallelPort"

//
// IEEE 1284.3 Daisy Chain (DC) Device ID's range from 0 to 3. Devices
//   are identified based on their connection order in the daisy chain
//   relative to the other 1284.3 DC devices.  Device 0 is the 1284.3 DC
//   device that is closest to host port.
//
#define IEEE_1284_3_DAISY_CHAIN_MAX_ID 3

//
// NtDeviceIoControlFile internal IoControlCode values for parallel device.
//

// Legacy - acquires entire parallel "bus"
#define IOCTL_INTERNAL_PARALLEL_PORT_ALLOCATE               CTL_CODE(FILE_DEVICE_PARALLEL_PORT, 11, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_INTERNAL_GET_PARALLEL_PORT_INFO               CTL_CODE(FILE_DEVICE_PARALLEL_PORT, 12, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_INTERNAL_PARALLEL_CONNECT_INTERRUPT           CTL_CODE(FILE_DEVICE_PARALLEL_PORT, 13, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_INTERNAL_PARALLEL_DISCONNECT_INTERRUPT        CTL_CODE(FILE_DEVICE_PARALLEL_PORT, 14, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_INTERNAL_RELEASE_PARALLEL_PORT_INFO           CTL_CODE(FILE_DEVICE_PARALLEL_PORT, 15, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_INTERNAL_GET_MORE_PARALLEL_PORT_INFO          CTL_CODE(FILE_DEVICE_PARALLEL_PORT, 17, METHOD_BUFFERED, FILE_ANY_ACCESS)

// Saves current chipset mode - puts the chipset into Specified mode (implemented in filter)
#define IOCTL_INTERNAL_PARCHIP_CONNECT                      CTL_CODE(FILE_DEVICE_PARALLEL_PORT, 18, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_INTERNAL_PARALLEL_SET_CHIP_MODE               CTL_CODE(FILE_DEVICE_PARALLEL_PORT, 19, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_INTERNAL_PARALLEL_CLEAR_CHIP_MODE             CTL_CODE(FILE_DEVICE_PARALLEL_PORT, 20, METHOD_BUFFERED, FILE_ANY_ACCESS)

// New parport IOCTLs
#define IOCTL_INTERNAL_GET_PARALLEL_PNP_INFO                CTL_CODE(FILE_DEVICE_PARALLEL_PORT, 21, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_INTERNAL_INIT_1284_3_BUS                      CTL_CODE(FILE_DEVICE_PARALLEL_PORT, 22, METHOD_BUFFERED, FILE_ANY_ACCESS)
// Takes a flat namespace Id for the device, also acquires the port
#define IOCTL_INTERNAL_SELECT_DEVICE                        CTL_CODE(FILE_DEVICE_PARALLEL_PORT, 23, METHOD_BUFFERED, FILE_ANY_ACCESS)
// Takes a flat namespace Id for the device, also releases the port
#define IOCTL_INTERNAL_DESELECT_DEVICE                      CTL_CODE(FILE_DEVICE_PARALLEL_PORT, 24, METHOD_BUFFERED, FILE_ANY_ACCESS) 

// New parclass IOCTLs
#if (NTDDI_VERSION >= NTDDI_WINXP) // Windows XP 
#define IOCTL_INTERNAL_GET_PARPORT_FDO                      CTL_CODE(FILE_DEVICE_PARALLEL_PORT, 29, METHOD_BUFFERED, FILE_ANY_ACCESS)
#endif
#define IOCTL_INTERNAL_PARCLASS_CONNECT                     CTL_CODE(FILE_DEVICE_PARALLEL_PORT, 30, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_INTERNAL_PARCLASS_DISCONNECT                  CTL_CODE(FILE_DEVICE_PARALLEL_PORT, 31, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_INTERNAL_DISCONNECT_IDLE                      CTL_CODE(FILE_DEVICE_PARALLEL_PORT, 32, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_INTERNAL_LOCK_PORT                            CTL_CODE(FILE_DEVICE_PARALLEL_PORT, 37, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_INTERNAL_UNLOCK_PORT                          CTL_CODE(FILE_DEVICE_PARALLEL_PORT, 38, METHOD_BUFFERED, FILE_ANY_ACCESS)

// IOCTL version of call to ParPort's FreePort function
#define IOCTL_INTERNAL_PARALLEL_PORT_FREE                   CTL_CODE(FILE_DEVICE_PARALLEL_PORT, 40, METHOD_BUFFERED, FILE_ANY_ACCESS)

// IOCTLs for IEEE1284.3
#define IOCTL_INTERNAL_PARDOT3_CONNECT                      CTL_CODE(FILE_DEVICE_PARALLEL_PORT, 41, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_INTERNAL_PARDOT3_DISCONNECT                   CTL_CODE(FILE_DEVICE_PARALLEL_PORT, 42, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_INTERNAL_PARDOT3_RESET                        CTL_CODE(FILE_DEVICE_PARALLEL_PORT, 43, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_INTERNAL_PARDOT3_SIGNAL                       CTL_CODE(FILE_DEVICE_PARALLEL_PORT, 44, METHOD_BUFFERED, FILE_ANY_ACCESS)


//
// IOCTLs for registering/unregistering for ParPort's RemovalRelations
// 
//  - A device object should register for removal relations with a 
//      parport device if the device is physically connected to the 
//      parallel port.
//
//  - Parport will report all devices that have registered with it for
//      removal relations in response to a PnP QUERY_DEVICE_RELATIONS of
//      type RemovalRelations. This allows PnP to remove all device stacks
//      that depend on the parport device prior to removing the parport 
//      device itself.
//
//  - The single Input parameter is a PARPORT_REMOVAL_RELATIONS 
//    structure that is defined below
// 
#define IOCTL_INTERNAL_REGISTER_FOR_REMOVAL_RELATIONS       CTL_CODE(FILE_DEVICE_PARALLEL_PORT, 50, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_INTERNAL_UNREGISTER_FOR_REMOVAL_RELATIONS     CTL_CODE(FILE_DEVICE_PARALLEL_PORT, 51, METHOD_BUFFERED, FILE_ANY_ACCESS)

typedef struct _PARPORT_REMOVAL_RELATIONS {
    PDEVICE_OBJECT  DeviceObject; // device object that is registering w/Parport
    ULONG           Flags;        // Flags - reserved - set to 0 for now
    PUNICODE_STRING DeviceName;   // DeviceName identifier of device registering for removal relations - used for debugging 
                                  // - printed in parport's debug spew - convention is to use same DeviceName that was passed to 
                                  //     IoCreateDevice
} PARPORT_REMOVAL_RELATIONS, *PPARPORT_REMOVAL_RELATIONS;

#if (NTDDI_VERSION >= NTDDI_WINXP) // Windows XP 
#define IOCTL_INTERNAL_LOCK_PORT_NO_SELECT                  CTL_CODE(FILE_DEVICE_PARALLEL_PORT, 52, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_INTERNAL_UNLOCK_PORT_NO_DESELECT              CTL_CODE(FILE_DEVICE_PARALLEL_PORT, 53, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_INTERNAL_DISABLE_END_OF_CHAIN_BUS_RESCAN      CTL_CODE(FILE_DEVICE_PARALLEL_PORT, 54, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_INTERNAL_ENABLE_END_OF_CHAIN_BUS_RESCAN       CTL_CODE(FILE_DEVICE_PARALLEL_PORT, 55, METHOD_BUFFERED, FILE_ANY_ACCESS)
#endif


// Define 1284.3 command qualifiers
#define MODE_LEN_1284_3         7       // # of magic sequence bytes
static UCHAR ModeQualifier[MODE_LEN_1284_3] = { 0xAA, 0x55, 0x00, 0xFF, 0x87, 0x78, 0xFF };

#define LEGACYZIP_MODE_LEN               3
static  UCHAR LegacyZipModeQualifier[LEGACYZIP_MODE_LEN] = { 0x00, 0x3c, 0x20 };

typedef enum {
    P12843DL_OFF,
    P12843DL_DOT3_DL,
    P12843DL_MLC_DL,
    P12843DL_DOT4_DL
} P12843_DL_MODES;

// Define 1284.3 Commands
#define CPP_ASSIGN_ADDR         0x00
#define CPP_SELECT              0xE0
#define CPP_DESELECT            0x30
#define CPP_QUERY_INT           0x08
#define CPP_DISABLE_INT         0x40
#define CPP_ENABLE_INT          0x48
#define CPP_CLEAR_INT_LAT       0x50
#define CPP_SET_INT_LAT         0x58
#define CPP_COMMAND_FILTER      0xF8


typedef
BOOLEAN
(*PPARALLEL_TRY_ALLOCATE_ROUTINE) (
	IN  PVOID   TryAllocateContext
	);

typedef
VOID
(*PPARALLEL_FREE_ROUTINE) (
	IN  PVOID   FreeContext
	);

typedef
ULONG
(*PPARALLEL_QUERY_WAITERS_ROUTINE) (
	IN  PVOID   QueryAllocsContext
	);

typedef
NTSTATUS
(*PPARALLEL_SET_CHIP_MODE) (
	IN  PVOID   SetChipContext,
	IN  UCHAR   ChipMode
	);

typedef
NTSTATUS
(*PPARALLEL_CLEAR_CHIP_MODE) (
	IN  PVOID   ClearChipContext,
	IN  UCHAR   ChipMode
	);

typedef
NTSTATUS
(*PPARALLEL_TRY_SELECT_ROUTINE) (
	IN  PVOID   TrySelectContext,
	IN  PVOID   TrySelectCommand
	);

typedef
NTSTATUS
(*PPARALLEL_DESELECT_ROUTINE) (
	IN  PVOID   DeselectContext,
	IN  PVOID   DeselectCommand
	);

typedef
NTSTATUS
(*PPARCHIP_SET_CHIP_MODE) (
	IN  PVOID   SetChipContext,
	IN  UCHAR   ChipMode
	);

typedef
NTSTATUS
(*PPARCHIP_CLEAR_CHIP_MODE) (
	IN  PVOID   ClearChipContext,
	IN  UCHAR   ChipMode
	);

//
// Hardware Capabilities
//
#define PPT_NO_HARDWARE_PRESENT     0x00000000
#define PPT_ECP_PRESENT             0x00000001
#define PPT_EPP_PRESENT             0x00000002
#define PPT_EPP_32_PRESENT          0x00000004
#define PPT_BYTE_PRESENT            0x00000008
#define PPT_BIDI_PRESENT            0x00000008 // deprecated - will be removed soon! dvdf
#define PPT_1284_3_PRESENT          0x00000010

//  Added DVDR 10-6-98

// Structure passed to the ParChip Filter when calling it
// with the IOCTL_INTERNAL_CHIP_FILTER_CONNECT ioctl
typedef struct _PARALLEL_PARCHIP_INFO {
    PUCHAR                      Controller;
    PUCHAR                      EcrController;
    ULONG                       HardwareModes;
    PPARCHIP_SET_CHIP_MODE      ParChipSetMode;
    PPARCHIP_CLEAR_CHIP_MODE    ParChipClearMode;
    PVOID                       Context;
    BOOLEAN                     success;
} PARALLEL_PARCHIP_INFO, *PPARALLEL_PARCHIP_INFO;

//  End Added by DVDR 10-6-1998


typedef struct _PARALLEL_PORT_INFORMATION {
    PHYSICAL_ADDRESS                OriginalController;
    PUCHAR                          Controller;
    ULONG                           SpanOfController;
    PPARALLEL_TRY_ALLOCATE_ROUTINE  TryAllocatePort;    // nonblocking callback to allocate port
    PPARALLEL_FREE_ROUTINE          FreePort;           // callback to free port
    PPARALLEL_QUERY_WAITERS_ROUTINE QueryNumWaiters;    // callback to query number of waiters for port allocation
    PVOID                           Context;            // context for callbacks to ParPort device
} PARALLEL_PORT_INFORMATION, *PPARALLEL_PORT_INFORMATION;

typedef struct _PARALLEL_PNP_INFORMATION {
    PHYSICAL_ADDRESS                OriginalEcpController;
    PUCHAR                          EcpController;
    ULONG                           SpanOfEcpController;
    ULONG                           PortNumber; // deprecated - do not use
    ULONG                           HardwareCapabilities;
    PPARALLEL_SET_CHIP_MODE         TrySetChipMode;
    PPARALLEL_CLEAR_CHIP_MODE       ClearChipMode;
    ULONG                           FifoDepth;
    ULONG                           FifoWidth;
    PHYSICAL_ADDRESS                EppControllerPhysicalAddress;
    ULONG                           SpanOfEppController;
    ULONG                           Ieee1284_3DeviceCount; // number of .3 daisy chain devices connected to this ParPort
    PPARALLEL_TRY_SELECT_ROUTINE    TrySelectDevice;
    PPARALLEL_DESELECT_ROUTINE      DeselectDevice;
    PVOID                           Context;
    ULONG                           CurrentMode;
    PWSTR                           PortName;              // symbolic link name for legacy device object
} PARALLEL_PNP_INFORMATION, *PPARALLEL_PNP_INFORMATION;

//  Start Added by DVDR 2-19-1998

//
// PARALLEL_1284_COMMAND CommandFlags
//

// this flag is deprecated - use 1284.3 daisy chain ID == 4 to indicate End-Of-Chain device
#define PAR_END_OF_CHAIN_DEVICE ((ULONG)0x00000001)        // The target device for this command
                                                           //   is an End-Of-Chain device, the
                                                           //   contents of the ID field are 
                                                           //   undefined and should be ignored

#define PAR_HAVE_PORT_KEEP_PORT ((ULONG)0x00000002)        // Indicates that the requesting driver 
                                                           //   has previously acquired the parallel port
                                                           //   and does is not ready to release it yet.
                                                           //
                                                           // On a SELECT_DEVICE ParPort should NOT 
                                                           //   try to acquire the port before selecting
                                                           //   the device.
                                                           //   
                                                           // On a DESELECT_DEVICE ParPort should NOT  
                                                           //   free the port after deselecting the device.

#define PAR_LEGACY_ZIP_DRIVE    ((ULONG)0x00000004)        // The target device for this command
                                                           //   is a Legacy Iomega Zip drive, the
                                                           //   contents of the ID field are 
                                                           //   undefined and should be ignored


#define PAR_LEGACY_ZIP_DRIVE_STD_MODE ((ULONG)0x00000010)  // The target device for these commands
#define PAR_LEGACY_ZIP_DRIVE_EPP_MODE ((ULONG)0x00000020)  //   are a Legacy Iomega Zip drive, the
                                                           //   contents of the ID field are 
                                                           //   undefined and should be ignored
                                                           //   This will select the Zip into DISK or EPP Mode

#define DOT3_END_OF_CHAIN_ID 4  // this ID used in a 1284.3 SELECT or DESELECT means the End-Of-Chain device
#define DOT3_LEGACY_ZIP_ID   5  // this ID used in a 1284.3 SELECT or DESELECT means Legacy Zip drive

//
// The following structure is passed in on an
//   IOCTL_INTERNAL_SELECT_DEVICE and on an
//   IOCTL_INTERNAL_DESELECT_DEVICE
typedef struct _PARALLEL_1284_COMMAND {
    UCHAR                       ID;           // 0..3 for 1284.3 daisy chain device, 4 for End-Of-Chain device, 5 for Legacy Zip
    UCHAR                       Port;         // reserved ( set == 0 )
    ULONG                       CommandFlags; // see above
} PARALLEL_1284_COMMAND, *PPARALLEL_1284_COMMAND;


//
// Hardware Modes
//
#define INITIAL_MODE        0x00000000

// Disable Parchip and ECR arbitrator
//       0 - Parchip and ecr arbritrator is off
//       1 - Parchip and ecr arbitrator is on
#define PARCHIP_ECR_ARBITRATOR 1

//
// The following structure is passed in on an
//   IOCTL_INTERNAL_PARALLEL_SET_CHIP_MODE and on an
//   IOCTL_INTERNAL_PARALLEL_CLEAR_CHIP_MODE
//
typedef struct _PARALLEL_CHIP_MODE {
    UCHAR                       ModeFlags;
    BOOLEAN                     success;
} PARALLEL_CHIP_MODE, *PPARALLEL_CHIP_MODE;

//  End Added by DVDR 2-19-1998

//
// The following structure is passed in on an
//   IOCTL_INTERNAL_PARALLEL_CONNECT_INTERRUPT and on an
//   IOCTL_INTERNAL_PARALLEL_DISCONNECT_INTERRUPT request.
//

typedef
VOID
(*PPARALLEL_DEFERRED_ROUTINE) (
	IN  PVOID   DeferredContext
	);

typedef struct _PARALLEL_INTERRUPT_SERVICE_ROUTINE {
	PKSERVICE_ROUTINE           InterruptServiceRoutine;
	PVOID                       InterruptServiceContext;
	PPARALLEL_DEFERRED_ROUTINE  DeferredPortCheckRoutine;   /* OPTIONAL */
	PVOID                       DeferredPortCheckContext;   /* OPTIONAL */
} PARALLEL_INTERRUPT_SERVICE_ROUTINE, *PPARALLEL_INTERRUPT_SERVICE_ROUTINE;

//
// The following structure is returned on an
// IOCTL_INTERNAL_PARALLEL_CONNECT_INTERRUPT request;
//

typedef struct _PARALLEL_INTERRUPT_INFORMATION {
	PKINTERRUPT                     InterruptObject;
	PPARALLEL_TRY_ALLOCATE_ROUTINE  TryAllocatePortAtInterruptLevel;
	PPARALLEL_FREE_ROUTINE          FreePortFromInterruptLevel;
	PVOID                           Context;
} PARALLEL_INTERRUPT_INFORMATION, *PPARALLEL_INTERRUPT_INFORMATION;

//
// The following structure is returned on an
// IOCTL_INTERNAL_GET_MORE_PARALLEL_PORT_INFO.
//

typedef struct _MORE_PARALLEL_PORT_INFORMATION {
	INTERFACE_TYPE  InterfaceType;
	ULONG           BusNumber;
	ULONG           InterruptLevel;
	ULONG           InterruptVector;
	KAFFINITY       InterruptAffinity;
	KINTERRUPT_MODE InterruptMode;
} MORE_PARALLEL_PORT_INFORMATION, *PMORE_PARALLEL_PORT_INFORMATION;

typedef enum {
    SAFE_MODE,
    UNSAFE_MODE         // Available only through kernel.  Your driver
                        // will be humiliated if you choose UNSAFE_MODE and
                        // then "make a mistake".  - dvrh (PCized by dvdf)
} PARALLEL_SAFETY;

//
// The following structure is returned by
// IOCTL_INTERNAL_PARCLASS_CONNECT.
//

typedef
USHORT
(*PDETERMINE_IEEE_MODES) (
    IN  PVOID   Context
    );

#define OLD_PARCLASS 0

#if OLD_PARCLASS
typedef 
NTSTATUS
(*PNEGOTIATE_IEEE_MODE) (
	IN  PVOID       Extension,
	IN  UCHAR       Extensibility
	);
#else
typedef 
NTSTATUS
(*PNEGOTIATE_IEEE_MODE) (
    IN PVOID           Context,
    IN USHORT          ModeMaskFwd,
    IN USHORT          ModeMaskRev,
    IN PARALLEL_SAFETY ModeSafety,
    IN BOOLEAN         IsForward
    );
#endif
	
typedef 
NTSTATUS
(*PTERMINATE_IEEE_MODE) (
	IN  PVOID       Context
	);
	
typedef
NTSTATUS
(*PPARALLEL_IEEE_FWD_TO_REV)(
    IN  PVOID       Context
    );

typedef
NTSTATUS
(*PPARALLEL_IEEE_REV_TO_FWD)(
    IN  PVOID       Context
    );

typedef
NTSTATUS
(*PPARALLEL_READ) (
	IN  PVOID       Context,
	OUT PVOID       Buffer,
	IN  ULONG       NumBytesToRead,
	OUT PULONG      NumBytesRead,
	IN  UCHAR       Channel
	);    
	
typedef
NTSTATUS
(*PPARALLEL_WRITE) (
	IN  PVOID       Context,
	OUT PVOID       Buffer,
	IN  ULONG       NumBytesToWrite,
	OUT PULONG      NumBytesWritten,
	IN  UCHAR       Channel
	);
    
typedef
NTSTATUS
(*PPARALLEL_TRYSELECT_DEVICE) (
    IN  PVOID                   Context,
    IN  PARALLEL_1284_COMMAND   Command
    );
    
typedef
NTSTATUS
(*PPARALLEL_DESELECT_DEVICE) (
    IN  PVOID                   Context,
    IN  PARALLEL_1284_COMMAND   Command
    );
	
typedef struct _PARCLASS_INFORMATION {
    PUCHAR                      Controller;
    PUCHAR                      EcrController;
    ULONG                       SpanOfController;
    PDETERMINE_IEEE_MODES       DetermineIeeeModes;
    PNEGOTIATE_IEEE_MODE        NegotiateIeeeMode;
    PTERMINATE_IEEE_MODE        TerminateIeeeMode;
    PPARALLEL_IEEE_FWD_TO_REV   IeeeFwdToRevMode;
    PPARALLEL_IEEE_REV_TO_FWD   IeeeRevToFwdMode;
    PPARALLEL_READ              ParallelRead;
    PPARALLEL_WRITE             ParallelWrite;
    PVOID                       ParclassContext;
    ULONG                       HardwareCapabilities;
    ULONG                       FifoDepth;
    ULONG                       FifoWidth;
    PPARALLEL_TRYSELECT_DEVICE  ParallelTryselect;
    PPARALLEL_DESELECT_DEVICE   ParallelDeSelect;
} PARCLASS_INFORMATION, *PPARCLASS_INFORMATION;

//
// Standard and ECP parallel port offsets.
//

#define DATA_OFFSET         0
#define OFFSET_ECP_AFIFO    0x0000              // ECP Mode Address FIFO
#define AFIFO_OFFSET        OFFSET_ECP_AFIFO   // ECP Mode Address FIFO
#define DSR_OFFSET          1
#define DCR_OFFSET          2
#define EPP_OFFSET          4

// default to the old defines - note that the old defines break on PCI cards
#ifndef DVRH_USE_PARPORT_ECP_ADDR
    #define DVRH_USE_PARPORT_ECP_ADDR 0
#endif

// DVRH_USE_PARPORT_ECP_ADDR settings
//  0   -   ECP registers are hardcoded to
//          Controller + 0x400
//  1   -   ECP registers are pulled from
//          Parport which hopefully got
//          them from PnP.

#if (0 == DVRH_USE_PARPORT_ECP_ADDR)
// ***Note: These do not hold for PCI parallel ports
    #define ECP_OFFSET          0x400
    #define CNFGB_OFFSET        0x401
    #define ECR_OFFSET          0x402
#else
    #define ECP_OFFSET          0x0
    #define CNFGB_OFFSET        0x1
    #define ECR_OFFSET          0x2
#endif

#define FIFO_OFFSET         ECP_OFFSET
#define CFIFO_OFFSET        ECP_OFFSET
#define CNFGA_OFFSET        ECP_OFFSET
#define ECP_DFIFO_OFFSET    ECP_OFFSET      // ECP Mode Data FIFO
#define TFIFO_OFFSET        ECP_OFFSET
#define OFFSET_ECP_DFIFO    ECP_OFFSET      // ECP Mode Data FIFO
#define OFFSET_TFIFO        ECP_OFFSET      // Test FIFO
#define OFFSET_CFIFO        ECP_OFFSET      // Fast Centronics Data FIFO
#define OFFSET_ECR          ECR_OFFSET      // Extended Control Register

#define OFFSET_PARALLEL_REGISTER_SPAN   0x0003

#define ECP_SPAN            3
#define EPP_SPAN            4

//
// Bit definitions for the DSR.
//

#define DSR_NOT_BUSY            0x80
#define DSR_NOT_ACK             0x40
#define DSR_PERROR              0x20
#define DSR_SELECT              0x10
#define DSR_NOT_FAULT           0x08

//
// More bit definitions for the DSR.
//

#define DSR_NOT_PTR_BUSY        0x80
#define DSR_NOT_PERIPH_ACK      0x80
#define DSR_WAIT                0x80
#define DSR_PTR_CLK             0x40
#define DSR_PERIPH_CLK          0x40
#define DSR_INTR                0x40
#define DSR_ACK_DATA_REQ        0x20
#define DSR_NOT_ACK_REVERSE     0x20
#define DSR_XFLAG               0x10
#define DSR_NOT_DATA_AVAIL      0x08
#define DSR_NOT_PERIPH_REQUEST  0x08

//
// Bit definitions for the DCR.
//

#define DCR_RESERVED            0xC0
#define DCR_DIRECTION           0x20
#define DCR_ACKINT_ENABLED      0x10
#define DCR_SELECT_IN           0x08
#define DCR_NOT_INIT            0x04
#define DCR_AUTOFEED            0x02
#define DCR_STROBE              0x01

//
// More bit definitions for the DCR.
//

#define DCR_NOT_1284_ACTIVE     0x08
#define DCR_ASTRB               0x08
#define DCR_NOT_REVERSE_REQUEST 0x04
#define DCR_NULL                0x04
#define DCR_NOT_HOST_BUSY       0x02
#define DCR_NOT_HOST_ACK        0x02
#define DCR_DSTRB               0x02
#define DCR_NOT_HOST_CLK        0x01
#define DCR_WRITE               0x01

//
// Bit definitions for configuration register A.
//

#define CNFGA_IMPID_MASK        0x70
#define CNFGA_IMPID_16BIT       0x00
#define CNFGA_IMPID_8BIT        0x10
#define CNFGA_IMPID_32BIT       0x20

#define CNFGA_NO_TRANS_BYTE     0x04

////////////////////////////////////////////////////////////////////////////////
// ECR values that establish basic hardware modes.  In each case, the default
// is to disable error interrupts, DMA, and service interrupts.
////////////////////////////////////////////////////////////////////////////////

#if (0 == PARCHIP_ECR_ARBITRATOR)
    #define DEFAULT_ECR_PS2                 0x34
    #define DEFAULT_ECR_ECP                 0x74
#endif

//
// Bit definitions for ECR register.
//

#define ECR_ERRINT_DISABLED        0x10
#define ECR_DMA_ENABLED            0x08
#define ECR_SVC_INT_DISABLED       0x04

#define ECR_MODE_MASK              0x1F
#define ECR_SPP_MODE               0x00
#define ECR_BYTE_MODE              0x20     // PS/2
#define ECR_BYTE_PIO_MODE          (ECR_BYTE_MODE | ECR_ERRINT_DISABLED | ECR_SVC_INT_DISABLED)

#define ECR_FASTCENT_MODE          0x40
#define ECR_ECP_MODE               0x60
#define ECR_ECP_PIO_MODE           (ECR_ECP_MODE | ECR_ERRINT_DISABLED | ECR_SVC_INT_DISABLED)

#define ECR_EPP_MODE               0x80
#define ECR_EPP_PIO_MODE           (ECR_EPP_MODE | ECR_ERRINT_DISABLED | ECR_SVC_INT_DISABLED)

#define ECR_RESERVED_MODE          0x10
#define ECR_TEST_MODE              0xC0
#define ECR_CONFIG_MODE            0xE0

#define DEFAULT_ECR_TEST                0xD4
#define DEFAULT_ECR_COMPATIBILITY       0x14

#define DEFAULT_ECR_CONFIGURATION       0xF4

#define ECR_FIFO_MASK              0x03        // Mask to isolate FIFO bits
#define ECR_FIFO_FULL              0x02        // FIFO completely full
#define ECR_FIFO_EMPTY             0x01        // FIFO completely empty
#define ECR_FIFO_SOME_DATA         0x00        // FIFO has some data in it

#define ECP_MAX_FIFO_DEPTH         4098        // Likely max for ECP HW FIFO size

//------------------------------------------------------------------------
// Mask and test values for extracting the Implementation ID from the
// ConfigA register
//------------------------------------------------------------------------

#define CNFGA_IMPID_MASK            0x70
#define CNFGA_IMPID_SHIFT           4

#define FIFO_PWORD_8BIT             1
#define FIFO_PWORD_16BIT            0
#define FIFO_PWORD_32BIT            2


#define TEST_ECR_FIFO(registerValue,testValue)  \
	( ( (registerValue) & ECR_FIFO_MASK ) == testValue )

//////////////////////////////////////////////////////////////////////////////
// The following BIT_x definitions provide a generic bit shift value
// based upon the bit's position in a hardware register or byte of
// memory.  These constants are used by some of the macros that are
// defined below.
//////////////////////////////////////////////////////////////////////////////

#define BIT_7   7
#define BIT_6   6
#define BIT_5   5
#define BIT_4   4
#define BIT_3   3
#define BIT_2   2
#define BIT_1   1
#define BIT_0   0

#define BIT_7_SET   0x80
#define BIT_6_SET   0x40
#define BIT_5_SET   0x20
#define BIT_4_SET   0x10
#define BIT_3_SET   0x8
#define BIT_2_SET   0x4
#define BIT_1_SET   0x2
#define BIT_0_SET   0x1

//////////////////////////////////////////////////////////////////////////////
// The following defines and macros may be used to set, test, and
// update the Device Control Register (DCR).
//////////////////////////////////////////////////////////////////////////////
#define DIR_READ  1
#define DIR_WRITE 0

#define IRQEN_ENABLE  1
#define IRQEN_DISABLE 0
             
#define ACTIVE    1
#define INACTIVE  0             
#define DONT_CARE 2

#define DVRH_USE_FAST_MACROS    1
#define DVRH_USE_NIBBLE_MACROS  1
//////////////////////////////////////////////////////////////////////////////
// The following defines may be used generically in any of the SET_xxx,
// TEST_xxx, or UPDATE_xxx macros that follow.
//////////////////////////////////////////////////////////////////////////////
#if (1 == DVRH_USE_FAST_MACROS)
    #define SET_DCR(b5,b4,b3,b2,b1,b0) \
    ((UCHAR)((b5==ACTIVE? BIT_5_SET : 0) | \
            (b4==ACTIVE?  BIT_4_SET : 0) | \
            (b3==ACTIVE?  0         : BIT_3_SET) | \
            (b2==ACTIVE?  BIT_2_SET : 0) | \
            (b1==ACTIVE?  0         : BIT_1_SET) | \
            (b0==ACTIVE?  0         : BIT_0_SET) ) )
#else
    #define SET_DCR(b5,b4,b3,b2,b1,b0) \
    ((UCHAR)(((b5==ACTIVE?1:0)<<BIT_5) | \
            ((b4==ACTIVE?1:0)<<BIT_4) | \
            ((b3==ACTIVE?0:1)<<BIT_3) | \
            ((b2==ACTIVE?1:0)<<BIT_2) | \
            ((b1==ACTIVE?0:1)<<BIT_1) | \
            ((b0==ACTIVE?0:1)<<BIT_0) ) )
#endif

typedef enum {
    PHASE_UNKNOWN,
    PHASE_NEGOTIATION,
    PHASE_SETUP,                    // Used in ECP mode only
    PHASE_FORWARD_IDLE,
    PHASE_FORWARD_XFER,
    PHASE_FWD_TO_REV,
    PHASE_REVERSE_IDLE,
    PHASE_REVERSE_XFER,
    PHASE_REV_TO_FWD,
    PHASE_TERMINATE,
    PHASE_DATA_AVAILABLE,           // Used in nibble and byte modes only
    PHASE_DATA_NOT_AVAIL,           // Used in nibble and byte modes only
    PHASE_INTERRUPT_HOST            // Used in nibble and byte modes only
} P1284_PHASE;

typedef enum {
    HW_MODE_COMPATIBILITY,
    HW_MODE_PS2,
    HW_MODE_FAST_CENTRONICS,
    HW_MODE_ECP,
    HW_MODE_EPP,
    HW_MODE_RESERVED,
    HW_MODE_TEST,
    HW_MODE_CONFIGURATION
} P1284_HW_MODE;


#endif // _PARALLEL_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\oprghdlr.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    oprghdlr.h

Abstract:

    This header file contains the shared structures for the ACPI op region
    registration DLL.

Author:

    Vincent Geglia 09-Feb-2000

Environment:

    Kernel mode

Notes:


Revision History:


--*/

#include "wdm.h"

//
// Make sure that we define the right calling convention
//

#ifdef EXPORT
  #undef EXPORT
#endif
#define EXPORT  __cdecl

//
// Op region handler and callback function prototypes
//

typedef VOID (EXPORT *PACPI_OP_REGION_CALLBACK)();

typedef
NTSTATUS
(EXPORT *PACPI_OP_REGION_HANDLER) (
    ULONG AccessType,
    PVOID OperationRegionObject,
    ULONG Address,
    ULONG Size,
    PULONG Data,
    ULONG_PTR Context,
    PACPI_OP_REGION_CALLBACK CompletionHandler,
    PVOID CompletionContext
    );

//
// Exposed function prototypes
//

NTSTATUS
RegisterOpRegionHandler (
    __in PDEVICE_OBJECT DeviceObject,
    __in ULONG AccessType,
    __in ULONG RegionSpace,
    __in PACPI_OP_REGION_HANDLER Handler,
    __in PVOID Context,
    __in ULONG Flags,
    __out PVOID *OperationRegionObject
    );

NTSTATUS
DeRegisterOpRegionHandler (
    __in PDEVICE_OBJECT DeviceObject,
    __in PVOID OperationRegionObject
    );

//
// Exposed definitions
//

//
// Access types for OpRegions
//
#define ACPI_OPREGION_ACCESS_AS_RAW                         0x1
#define ACPI_OPREGION_ACCESS_AS_COOKED                      0x2

//
// Allowable region spaces
//
#define ACPI_OPREGION_REGION_SPACE_MEMORY                   0x0
#define ACPI_OPREGION_REGION_SPACE_IO                       0x1
#define ACPI_OPREGION_REGION_SPACE_PCI_CONFIG               0x2
#define ACPI_OPREGION_REGION_SPACE_EC                       0x3
#define ACPI_OPREGION_REGION_SPACE_SMB                      0x4
#define ACPI_OPREGION_REGION_SPACE_CMOS_CONFIG              0x5
#define ACPI_OPREGION_REGION_SPACE_PCIBARTARGET             0x6

//
// Operation to perform on region
//
#define ACPI_OPREGION_READ                                  0x0
#define ACPI_OPREGION_WRITE                                 0x1

//
// Flag definitions for op region registration
//

#define ACPI_OPREGION_ACCESS_AT_HIGH_LEVEL                  0x1 // Indicates the handler function can be called at HIGH_LEVEL IRQL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\pfhook.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    pfhook.h

Abstract:

    Header file for Packet Filter driver extension hook.

--*/

#ifndef _PF_EXTEND_DEFS_H_
#define _PF_EXTEND_DEFS_H_

#define  INVALID_PF_IF_INDEX  0xffffffff
#define  ZERO_PF_IP_ADDR      0

//
// Enumeration constants for values that may be returned by an extension
// routine.
//

typedef enum _PF_FORWARD_ACTION
{
    PF_FORWARD       = 0,
    PF_DROP          = 1,
    PF_PASS          = 2,
    PF_ICMP_ON_DROP  = 3
} PF_FORWARD_ACTION;

//
// Definiton for a filter routine callout.
//

typedef PF_FORWARD_ACTION (*PacketFilterExtensionPtr)(
                              unsigned char   *PacketHeader,
                              unsigned char   *Packet,
                              unsigned int    PacketLength,
                              unsigned int    RecvInterfaceIndex,
                              unsigned int    SendInterfaceIndex,
                              IPAddr          RecvLinkNextHop,
                              IPAddr          SendLinkNextHop
                              );


//
// Structure to be passed to the IOCTL_PF_SET_EXTENSION_POINTER call
//

typedef struct _PF_SET_EXTENSION_HOOK_INFO 
{
    PacketFilterExtensionPtr       ExtensionPointer; 
} PF_SET_EXTENSION_HOOK_INFO, *PPF_SET_EXTENSION_HOOK_INFO;


#define DD_IPFLTRDRVR_DEVICE_NAME   L"\\Device\\IPFILTERDRIVER"

#define FSCTL_IPFLTRDRVR_BASE     FILE_DEVICE_NETWORK

#define _IPFLTRDRVR_CTL_CODE(function, method, access) \
                 CTL_CODE(FSCTL_IPFLTRDRVR_BASE, function, method, access)

#define IOCTL_PF_SET_EXTENSION_POINTER \
            _IPFLTRDRVR_CTL_CODE(22, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#endif // _PF_EXTEND_DEFS_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\poclass.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    poclass.h

Abstract:

    Defines power policy device driver interfaces.



Revision History:

--*/

//
// GUIDs are defined outside ifdef __POCLASS_ so that they can be instantiated
// easily using <initguid.h>.
//

//
// Custom device properties...
//

#include <devpropdef.h>

//
// This is of type DEVPROP_TYPE_UINT32 and represents the NT processor
// number.
//

DEFINE_DEVPROPKEY(PROCESSOR_NUMBER_PKEY,
                  0x5724c81d,
                  0xd5af,
                  0x4c1f,
                  0xa1, 0x03, 0xa0, 0x6e, 0x28, 0xf2, 0x04, 0xc6,
                  1);


//
// Power management policy device GUIDs
//

DEFINE_GUID( GUID_DEVICE_BATTERY,           0x72631e54L, 0x78A4, 0x11d0, 0xbc, 0xf7, 0x00, 0xaa, 0x00, 0xb7, 0xb3, 0x2a );
DEFINE_GUID( GUID_DEVICE_APPLICATIONLAUNCH_BUTTON, 0x629758eel, 0x986e, 0x4d9e, 0x8e, 0x47, 0xde, 0x27, 0xf8, 0xab, 0x05, 0x4d );
DEFINE_GUID( GUID_DEVICE_SYS_BUTTON,        0x4AFA3D53L, 0x74A7, 0x11d0, 0xbe, 0x5e, 0x00, 0xA0, 0xC9, 0x06, 0x28, 0x57 );
DEFINE_GUID( GUID_DEVICE_LID,               0x4AFA3D52L, 0x74A7, 0x11d0, 0xbe, 0x5e, 0x00, 0xA0, 0xC9, 0x06, 0x28, 0x57 );
DEFINE_GUID( GUID_DEVICE_THERMAL_ZONE,      0x4AFA3D51L, 0x74A7, 0x11d0, 0xbe, 0x5e, 0x00, 0xA0, 0xC9, 0x06, 0x28, 0x57 );
DEFINE_GUID( GUID_DEVICE_PROCESSOR,         0x97fadb10L, 0x4e33, 0x40ae, 0x35, 0x9c, 0x8b, 0xef, 0x02, 0x9d, 0xbd, 0xd0 );
DEFINE_GUID( GUID_DEVICE_MEMORY,            0x3fd0f03dL, 0x92e0, 0x45fb, 0xb7, 0x5c, 0x5e, 0xd8, 0xff, 0xb0, 0x10, 0x21 );
DEFINE_GUID( GUID_DEVICE_MESSAGE_INDICATOR, 0XCD48A365L, 0xfa94, 0x4ce2, 0xa2, 0x32, 0xa1, 0xb7, 0x64, 0xe5, 0xd8, 0xb4 );
// copied from hidclass.h
DEFINE_GUID( GUID_CLASS_INPUT,              0x4D1E55B2L, 0xF16F, 0x11CF, 0x88, 0xCB, 0x00, 0x11, 0x11, 0x00, 0x00, 0x30 );

#ifndef _POCLASS_
#define _POCLASS_

//
// Battery driver interface (devices of registrying as GUID_DEVICE_BATTERY)
//

typedef enum {
    BatteryInformation,
    BatteryGranularityInformation,
    BatteryTemperature,
    BatteryEstimatedTime,
    BatteryDeviceName,
    BatteryManufactureDate,
    BatteryManufactureName,
    BatteryUniqueID
} BATTERY_QUERY_INFORMATION_LEVEL;

typedef struct _BATTERY_QUERY_INFORMATION {
    ULONG                           BatteryTag;
    BATTERY_QUERY_INFORMATION_LEVEL InformationLevel;
    ULONG                           AtRate;
} BATTERY_QUERY_INFORMATION, *PBATTERY_QUERY_INFORMATION;

typedef struct _BATTERY_INFORMATION {
    ULONG       Capabilities;
    UCHAR       Technology;
    UCHAR       Reserved[3];
    UCHAR       Chemistry[4];
    ULONG       DesignedCapacity;
    ULONG       FullChargedCapacity;
    ULONG       DefaultAlert1;
    ULONG       DefaultAlert2;
    ULONG       CriticalBias;
    ULONG       CycleCount;
} BATTERY_INFORMATION, *PBATTERY_INFORMATION;

// BATTERY_INFORMATION.*Capacity constants
#define UNKNOWN_CAPACITY            0xFFFFFFFF

// BATTERY_INFORMATION.Capabilities flags
#define BATTERY_SYSTEM_BATTERY          0x80000000
#define BATTERY_CAPACITY_RELATIVE       0x40000000
#define BATTERY_IS_SHORT_TERM           0x20000000
#define BATTERY_SET_CHARGE_SUPPORTED    0x00000001
#define BATTERY_SET_DISCHARGE_SUPPORTED 0x00000002
#define BATTERY_SET_RESUME_SUPPORTED    0x00000004

typedef enum {
    BatteryCriticalBias,
    BatteryCharge,
    BatteryDischarge
} BATTERY_SET_INFORMATION_LEVEL;

typedef struct _BATTERY_SET_INFORMATION {
    ULONG                         BatteryTag;
    BATTERY_SET_INFORMATION_LEVEL InformationLevel;
    UCHAR                         Buffer[1];
} BATTERY_SET_INFORMATION, *PBATTERY_SET_INFORMATION;

typedef struct _BATTERY_WAIT_STATUS {
    ULONG       BatteryTag;
    ULONG       Timeout;
    ULONG       PowerState;
    ULONG       LowCapacity;
    ULONG       HighCapacity;
} BATTERY_WAIT_STATUS, *PBATTERY_WAIT_STATUS;

typedef struct _BATTERY_STATUS {
    ULONG       PowerState;
    ULONG       Capacity;
    ULONG       Voltage;
    LONG        Current;
} BATTERY_STATUS, *PBATTERY_STATUS;

// Battery Status Constants
#define UNKNOWN_RATE                0xFFFFFFFF
#define UNKNOWN_VOLTAGE             0xFFFFFFFF


// PowerState flags

#define BATTERY_POWER_ON_LINE   0x00000001
#define BATTERY_DISCHARGING     0x00000002
#define BATTERY_CHARGING        0x00000004
#define BATTERY_CRITICAL        0x00000008

// Max battery driver BATTERY_QUERY_INFORMATION_LEVEL string storage
// size in bytes.
#define MAX_BATTERY_STRING_SIZE 128

// Struct for accessing the packed date format in BatteryManufactureDate.
typedef struct _BATTERY_MANUFACTURE_DATE
{
    UCHAR   Day;
    UCHAR   Month;
    USHORT  Year;
} BATTERY_MANUFACTURE_DATE, *PBATTERY_MANUFACTURE_DATE;

// battery

#define IOCTL_BATTERY_QUERY_TAG         \
        CTL_CODE(FILE_DEVICE_BATTERY, 0x10, METHOD_BUFFERED, FILE_READ_ACCESS)

#define IOCTL_BATTERY_QUERY_INFORMATION \
        CTL_CODE(FILE_DEVICE_BATTERY, 0x11, METHOD_BUFFERED, FILE_READ_ACCESS)

#define IOCTL_BATTERY_SET_INFORMATION   \
        CTL_CODE(FILE_DEVICE_BATTERY, 0x12, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_BATTERY_QUERY_STATUS      \
        CTL_CODE(FILE_DEVICE_BATTERY, 0x13, METHOD_BUFFERED, FILE_READ_ACCESS)

#define BATTERY_TAG_INVALID     0

#ifndef _WINDOWS_

//
// Battery Class-Miniport interfaces
//

typedef
NTSTATUS
(*BCLASS_QUERY_TAG)(
    IN PVOID Context,
    OUT PULONG BatteryTag
    );

typedef
NTSTATUS
(*BCLASS_QUERY_INFORMATION)(
    IN PVOID Context,
    IN ULONG BatteryTag,
    IN BATTERY_QUERY_INFORMATION_LEVEL Level,
    IN ULONG AtRate OPTIONAL,
    OUT PVOID Buffer,
    IN  ULONG BufferLength,
    OUT PULONG ReturnedLength
    );

typedef
NTSTATUS
(*BCLASS_QUERY_STATUS)(
    IN PVOID Context,
    IN ULONG BatteryTag,
    OUT PBATTERY_STATUS BatteryStatus
    );

typedef struct {
    ULONG                   PowerState;
    ULONG                   LowCapacity;
    ULONG                   HighCapacity;
} BATTERY_NOTIFY, *PBATTERY_NOTIFY;

typedef
NTSTATUS
(*BCLASS_SET_STATUS_NOTIFY)(
    IN PVOID Context,
    IN ULONG BatteryTag,
    IN PBATTERY_NOTIFY BatteryNotify
    );

typedef
NTSTATUS
(*BCLASS_SET_INFORMATION)(
    IN PVOID Context,
    IN ULONG BatteryTag,
    IN BATTERY_SET_INFORMATION_LEVEL Level,
    IN PVOID Buffer OPTIONAL
    );

typedef
NTSTATUS
(*BCLASS_DISABLE_STATUS_NOTIFY)(
    IN PVOID Context
    );


typedef struct {
    USHORT                          MajorVersion;
    USHORT                          MinorVersion;

    PVOID                           Context;        // Miniport context

    BCLASS_QUERY_TAG                QueryTag;
    BCLASS_QUERY_INFORMATION        QueryInformation;
    BCLASS_SET_INFORMATION          SetInformation;
    BCLASS_QUERY_STATUS             QueryStatus;
    BCLASS_SET_STATUS_NOTIFY        SetStatusNotify;
    BCLASS_DISABLE_STATUS_NOTIFY    DisableStatusNotify;
    PDEVICE_OBJECT                  Pdo;
    PUNICODE_STRING                 DeviceName;
} BATTERY_MINIPORT_INFO, *PBATTERY_MINIPORT_INFO;



#define BATTERY_CLASS_MAJOR_VERSION     0x0001
#define BATTERY_CLASS_MINOR_VERSION     0x0000


//
// Battery class driver functions
//

#if !defined(BATTERYCLASS)
    #define BATTERYCLASSAPI DECLSPEC_IMPORT
#else
    #define BATTERYCLASSAPI
#endif


NTSTATUS
BATTERYCLASSAPI
BatteryClassInitializeDevice (
    IN PBATTERY_MINIPORT_INFO MiniportInfo,
    IN PVOID *ClassData
    );

NTSTATUS
BATTERYCLASSAPI
BatteryClassUnload (
    IN PVOID ClassData
    );

NTSTATUS
BATTERYCLASSAPI
BatteryClassIoctl (
    IN PVOID ClassData,
    IN PIRP Irp
    );

NTSTATUS
BATTERYCLASSAPI
BatteryClassStatusNotify (
    IN PVOID ClassData
    );

#endif // _WINDOWS_

//
// Thermal Zone driver interface (devices of registrying as GUID_DEVICE_THERMAL_ZONE)
//

#define MAX_ACTIVE_COOLING_LEVELS       10

//
// This structure has been depricated and the THERMAL_INFORMATION_EX
// structure should be used. THERMAL_INFORMATION has been left here for
// backward compatibility with the thermal WMI interface.
//
typedef struct _THERMAL_INFORMATION {
    ULONG           ThermalStamp;
    ULONG           ThermalConstant1;
    ULONG           ThermalConstant2;
    KAFFINITY       Processors;
    ULONG           SamplingPeriod;
    ULONG           CurrentTemperature;
    ULONG           PassiveTripPoint;
    ULONG           CriticalTripPoint;
    UCHAR           ActiveTripPointCount;
    ULONG           ActiveTripPoint[MAX_ACTIVE_COOLING_LEVELS];
} THERMAL_INFORMATION, *PTHERMAL_INFORMATION;

#if (NTDDI_VERSION >= NTDDI_VISTA) //

typedef struct _THERMAL_INFORMATION_EX {
    ULONG           ThermalStamp;
    ULONG           ThermalConstant1;
    ULONG           ThermalConstant2;
    KAFFINITY       Processors;
    ULONG           SamplingPeriod;
    ULONG           CurrentTemperature;
    ULONG           PassiveTripPoint;
    ULONG           CriticalTripPoint;
    UCHAR           ActiveTripPointCount;
    ULONG           ActiveTripPoint[MAX_ACTIVE_COOLING_LEVELS];
    ULONG           S4TransitionTripPoint;
    } THERMAL_INFORMATION_EX, *PTHERMAL_INFORMATION_EX;

#endif // (NTDDI_VERSION >= NTDDI_VISTA)

#define ACTIVE_COOLING          0x0
#define PASSIVE_COOLING         0x1

// thermal

#define IOCTL_THERMAL_QUERY_INFORMATION \
        CTL_CODE(FILE_DEVICE_BATTERY, 0x20, METHOD_BUFFERED, FILE_READ_ACCESS)

#define IOCTL_THERMAL_SET_COOLING_POLICY\
        CTL_CODE(FILE_DEVICE_BATTERY, 0x21, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_RUN_ACTIVE_COOLING_METHOD\
        CTL_CODE(FILE_DEVICE_BATTERY, 0x22, METHOD_BUFFERED, FILE_WRITE_ACCESS)


//
// Lid class driver functions
//

#define IOCTL_QUERY_LID\
        CTL_CODE(FILE_DEVICE_BATTERY, 0x30, METHOD_BUFFERED, FILE_READ_ACCESS)

//
// Switch class driver functions
//

#define IOCTL_NOTIFY_SWITCH_EVENT\
        CTL_CODE(FILE_DEVICE_BATTERY, 0x40, METHOD_BUFFERED, FILE_READ_ACCESS)

//
// System button class driver functions
//

#define IOCTL_GET_SYS_BUTTON_CAPS       \
        CTL_CODE(FILE_DEVICE_BATTERY, 0x50, METHOD_BUFFERED, FILE_READ_ACCESS)

#define IOCTL_GET_SYS_BUTTON_EVENT      \
        CTL_CODE(FILE_DEVICE_BATTERY, 0x51, METHOD_BUFFERED, FILE_READ_ACCESS)

#define SYS_BUTTON_POWER        0x00000001
#define SYS_BUTTON_SLEEP        0x00000002
#define SYS_BUTTON_LID          0x00000004
#define SYS_BUTTON_WAKE         0x80000000

//
// Lid-specific state embedded in the button event irp.
//

#define SYS_BUTTON_LID_STATE_MASK 0x00030000
#define SYS_BUTTON_LID_OPEN       0x00010000
#define SYS_BUTTON_LID_CLOSED     0x00020000
#define SYS_BUTTON_LID_INITIAL    0x00040000
#define SYS_BUTTON_LID_CHANGED    0x00080000

//
// Processor object class driver functions
//

typedef struct {
    ULONG   PhysicalID;
    ULONG   PBlkAddress;
    UCHAR   PBlkLength;
} PROCESSOR_OBJECT_INFO, *PPROCESSOR_OBJECT_INFO;

typedef struct {
    ULONG   PhysicalID;
    ULONG   PBlkAddress;
    UCHAR   PBlkLength;
    ULONG   InitialApicId;
} PROCESSOR_OBJECT_INFO_EX, *PPROCESSOR_OBJECT_INFO_EX;



#define IOCTL_GET_PROCESSOR_OBJ_INFO        \
        CTL_CODE(FILE_DEVICE_BATTERY, 0x60, METHOD_BUFFERED, FILE_READ_ACCESS)

//
// Message indicator class driver functions
//
#define IOCTL_SET_SYS_MESSAGE_INDICATOR     \
        CTL_CODE(FILE_DEVICE_BATTERY, 0x70, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#endif // _POCLASS_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\pciprop.h ===
/*++

Copyright (c) 2005 Microsoft Corporation

Module Name:

    pciprop.h

Abstract:

    This file contains custom property definitions for a PCI root bus and a PCI
    device.

--*/

#ifndef _PCIPROP_
#define _PCIPROP_

//
// The GUID {D817FC28-793E-4b9e-9970-469D8BE63073} is a seed for all properties
// defined for a root bus.
//

#define DEFINE_PCI_ROOT_BUS_DEVPKEY(_DevPkeyName, _Pid) \
    DEFINE_DEVPROPKEY((_DevPkeyName), 0xd817fc28, 0x793e, 0x4b9e, 0x99, 0x70, 0x46, 0x9d, 0x8b, 0xe6, 0x30, 0x73, (_Pid))

//
// This property describes the secondary side characteristics of a root bus.
// The values for this property field are interpreted as below:
//

#define DevProp_PciRootBus_SecondaryInterface_PciConventional       0
#define DevProp_PciRootBus_SecondaryInterface_PciXMode1             1
#define DevProp_PciRootBus_SecondaryInterface_PciXMode2             2
#define DevProp_PciRootBus_SecondaryInterface_PciExpress            3

DEFINE_PCI_ROOT_BUS_DEVPKEY(DEVPKEY_PciRootBus_SecondaryInterface, 1); //DEVPROP_TYPE_UINT32

//
// This field is valid for conventional PCI and PCI-X host bridges.
// The values for this property field are interpreted as below:
//

#define DevProp_PciRootBus_CurrentSpeedAndMode_Pci_Conventional_33Mhz           0
#define DevProp_PciRootBus_CurrentSpeedAndMode_Pci_Conventional_66Mhz           1
#define DevProp_PciRootBus_CurrentSpeedAndMode_Pci_X_Mode1_66Mhz                2
#define DevProp_PciRootBus_CurrentSpeedAndMode_Pci_X_Mode1_100Mhz               3
#define DevProp_PciRootBus_CurrentSpeedAndMode_Pci_X_Mode1_133Mhz               4
#define DevProp_PciRootBus_CurrentSpeedAndMode_Pci_X_Mode1_ECC_66Mhz            5
#define DevProp_PciRootBus_CurrentSpeedAndMode_Pci_X_Mode1_ECC_100Mhz           6
#define DevProp_PciRootBus_CurrentSpeedAndMode_Pci_X_Mode1_ECC_133Mhz           7
#define DevProp_PciRootBus_CurrentSpeedAndMode_Pci_X_266_Mode2_66Mhz            8
#define DevProp_PciRootBus_CurrentSpeedAndMode_Pci_X_266_Mode2_100Mhz           9
#define DevProp_PciRootBus_CurrentSpeedAndMode_Pci_X_266_Mode2_133Mhz          10
#define DevProp_PciRootBus_CurrentSpeedAndMode_Pci_X_533_Mode2_66Mhz           11
#define DevProp_PciRootBus_CurrentSpeedAndMode_Pci_X_533_Mode2_100Mhz          12
#define DevProp_PciRootBus_CurrentSpeedAndMode_Pci_X_533_Mode2_133Mhz          13

DEFINE_PCI_ROOT_BUS_DEVPKEY(DEVPKEY_PciRootBus_CurrentSpeedAndMode, 2); //DEVPROP_TYPE_UINT32

//
// This field is valid for conventional PCI and PCI-X host bridges.
// The values for this property field are interpreted as below:
//

#define DevProp_PciRootBus_SupportedSpeedsAndModes_Pci_Conventional_33Mhz       1
#define DevProp_PciRootBus_SupportedSpeedsAndModes_Pci_Conventional_66Mhz       2
#define DevProp_PciRootBus_SupportedSpeedsAndModes_Pci_X_66Mhz                  4
#define DevProp_PciRootBus_SupportedSpeedsAndModes_Pci_X_133Mhz                 8
#define DevProp_PciRootBus_SupportedSpeedsAndModes_Pci_X_266Mhz                16
#define DevProp_PciRootBus_SupportedSpeedsAndModes_Pci_X_533Mhz                32

DEFINE_PCI_ROOT_BUS_DEVPKEY(DEVPKEY_PciRootBus_SupportedSpeedsAndModes, 3); //DEVPROP_TYPE_UINT32

//
// This is boolean indicating if the host bridge is capable of forwarding
// Device ID Message transactions.
//

DEFINE_PCI_ROOT_BUS_DEVPKEY(DEVPKEY_PciRootBus_DeviceIDMessagingCapable, 4); // DEVPROP_TYPE_BOOLEAN

//
// Provides the width of a root bus interface.
//

#define DevProp_PciRootBus_BusWidth_32Bits      0
#define DevProp_PciRootBus_BusWidth_64Bits      1

DEFINE_PCI_ROOT_BUS_DEVPKEY(DEVPKEY_PciRootBus_SecondaryBusWidth, 5); //DEVPROP_TYPE_UINT32

//
// This is a boolean indicating that an extended config space is available
// on the secondary side of the root bus.
//

DEFINE_PCI_ROOT_BUS_DEVPKEY(DEVPKEY_PciRootBus_ExtendedConfigAvailable, 6); // DEVPROP_TYPE_BOOLEAN

//
// This is a boolean indicating an operating system support for an extended
// PCI config op region.
//

DEFINE_PCI_ROOT_BUS_DEVPKEY(DEVPKEY_PciRootBus_ExtendedPCIConfigOpRegionSupport, 7); // DEVPROP_TYPE_BOOLEAN

//
// This is a boolean indicating an operating system support for ASPM.
//

DEFINE_PCI_ROOT_BUS_DEVPKEY(DEVPKEY_PciRootBus_ASPMSupport, 8); // DEVPROP_TYPE_BOOLEAN

//
// This is a boolean indicating an operating system support for clock power
// management.
//

DEFINE_PCI_ROOT_BUS_DEVPKEY(DEVPKEY_PciRootBus_ClockPowerManagementSupport, 9); // DEVPROP_TYPE_BOOLEAN

//
// This is a boolean indicating an operating system support for PCI Segments.
//

DEFINE_PCI_ROOT_BUS_DEVPKEY(DEVPKEY_PciRootBus_PCISegmentGroupsSupport, 10); // DEVPROP_TYPE_BOOLEAN

//
// This is a boolean indicating an operating system support for Message
// Signaled Interrupts.
//

DEFINE_PCI_ROOT_BUS_DEVPKEY(DEVPKEY_PciRootBus_MSISupport, 11); // DEVPROP_TYPE_BOOLEAN

//
// This is a boolean indicating that the firmware has granted control of native
// hot plug interrupts to the operating system.
//

DEFINE_PCI_ROOT_BUS_DEVPKEY(DEVPKEY_PciRootBus_PCIExpressNativeHotPlugControl, 12);  // DEVPROP_TYPE_BOOLEAN

//
// This is a boolean indicating that the firmware has granted control of native
// SHPC to the operating system.
//

DEFINE_PCI_ROOT_BUS_DEVPKEY(DEVPKEY_PciRootBus_SHPCNativeHotPlugControl, 13);   // DEVPROP_TYPE_BOOLEAN

//
// This is a boolean indicating that the firmware has granted control over
// native PME interrupts to the operating system.
//

DEFINE_PCI_ROOT_BUS_DEVPKEY(DEVPKEY_PciRootBus_PCIExpressNativePMEControl, 14); // DEVPROP_TYPE_BOOLEAN

//
// This is a boolean indicating that the firmware has granted control over
// AER to the operating system.
//

DEFINE_PCI_ROOT_BUS_DEVPKEY(DEVPKEY_PciRootBus_PCIExpressAERControl, 15); // DEVPROP_TYPE_BOOLEAN

//
// This is a boolean indicating that the firmware has granted control over the
// PCI Express capability to the operating system.
//

DEFINE_PCI_ROOT_BUS_DEVPKEY(DEVPKEY_PciRootBus_PCIExpressCapabilityControl, 16); // DEVPROP_TYPE_BOOLEAN

//
// This is a boolean indicating that the operating system is controlling PCI
// Express features natively.  Generally this will be a reflection of the
// individual feature controls granted by the firmware and exposed by properties
// above, but the operating system might override the firmware.  The final
// control disposition is reflected here.
//

DEFINE_PCI_ROOT_BUS_DEVPKEY(DEVPKEY_PciRootBus_NativePciExpressControl, 17); // DEVPROP_TYPE_BOOLEAN

//
// This is a boolean indicating that the system is configured to support MSI.
// If this is FALSE no message-signaled interrupts will be allocated to devices
// on this system, even if the operating system supports MSI.
//

DEFINE_PCI_ROOT_BUS_DEVPKEY(DEVPKEY_PciRootBus_SystemMsiSupport, 18); // DEVPROP_TYPE_BOOLEAN


//
// The GUID {3AB22E31-8264-4b4e-9AF5-A8D2D8E33E62} is a seed for all properties
// defined for a PCI device.
//

#define DEFINE_PCI_DEVICE_DEVPKEY(_DevPkeyName, _Pid) \
   DEFINE_DEVPROPKEY((_DevPkeyName), 0x3ab22e31, 0x8264, 0x4b4e, 0x9a, 0xf5, 0xa8, 0xd2, 0xd8, 0xe3, 0x3e, 0x62, (_Pid))

//
// This property is defined to display the type of PCI device. The possible
// values are shown below.
//

#define DevProp_PciDevice_DeviceType_PciConventional                            0
#define DevProp_PciDevice_DeviceType_PciX                                       1
#define DevProp_PciDevice_DeviceType_PciExpressEndpoint                         2
#define DevProp_PciDevice_DeviceType_PciExpressLegacyEndpoint                   3
#define DevProp_PciDevice_DeviceType_PciExpressRootComplexIntegratedEndpoint    4
#define DevProp_PciDevice_DeviceType_PciExpressTreatedAsPci                     5
#define DevProp_PciDevice_BridgeType_PciConventional                            6
#define DevProp_PciDevice_BridgeType_PciX                                       7
#define DevProp_PciDevice_BridgeType_PciExpressRootPort                         8
#define DevProp_PciDevice_BridgeType_PciExpressUpstreamSwitchPort               9
#define DevProp_PciDevice_BridgeType_PciExpressDownstreamSwitchPort            10
#define DevProp_PciDevice_BridgeType_PciExpressToPciXBridge                    11
#define DevProp_PciDevice_BridgeType_PciXToExpressBridge                       12
#define DevProp_PciDevice_BridgeType_PciExpressTreatedAsPci                    13

DEFINE_PCI_DEVICE_DEVPKEY(DEVPKEY_PciDevice_DeviceType, 1);

//
// This property is valid for conventional PCI or PCI-X devices.
// For conventional PCI devices, the speed/mode is described by the following
// fields.
//

#define DevProp_PciDevice_CurrentSpeedAndMode_Pci_Conventional_33MHz        0
#define DevProp_PciDevice_CurrentSpeedAndMode_Pci_Conventional_66MHz        1

//
// For PCI-X devices, the speed/mode is encoded in the following fashion.
//

#define DevProp_PciDevice_CurrentSpeedAndMode_PciX_Mode_Conventional_Pci  0x0
#define DevProp_PciDevice_CurrentSpeedAndMode_PciX_Mode1_66Mhz            0x1
#define DevProp_PciDevice_CurrentSpeedAndMode_PciX_Mode1_100Mhz           0x2
#define DevProp_PciDevice_CurrentSpeedAndMode_PciX_Mode1_133MHZ           0x3
#define DevProp_PciDevice_CurrentSpeedAndMode_PciX_Mode2_266_66MHz        0x9
#define DevProp_PciDevice_CurrentSpeedAndMode_PciX_Mode2_266_100MHz       0xA
#define DevProp_PciDevice_CurrentSpeedAndMode_PciX_Mode2_266_133MHz       0xB
#define DevProp_PciDevice_CurrentSpeedAndMode_PciX_Mode2_533_66MHz        0xD
#define DevProp_PciDevice_CurrentSpeedAndMode_PciX_Mode2_533_100MHz       0xE
#define DevProp_PciDevice_CurrentSpeedAndMode_PciX_Mode2_533_133MHz       0xF

DEFINE_PCI_DEVICE_DEVPKEY(DEVPKEY_PciDevice_CurrentSpeedAndMode, 2);

//
// The BaseClass, SubClass and ProgIf fields are valid for all PCI devices.
//

DEFINE_PCI_DEVICE_DEVPKEY(DEVPKEY_PciDevice_BaseClass, 3);

DEFINE_PCI_DEVICE_DEVPKEY(DEVPKEY_PciDevice_SubClass, 4);

DEFINE_PCI_DEVICE_DEVPKEY(DEVPKEY_PciDevice_ProgIf, 5);

//
// This property describes the current payload size in the transaction layer
// for a PCI Express device. The encodings for this field are described below.
//

#define DevProp_PciExpressDevice_PayloadOrRequestSize_128Bytes          0
#define DevProp_PciExpressDevice_PayloadOrRequestSize_256Bytes          1
#define DevProp_PciExpressDevice_PayloadOrRequestSize_512Bytes          2
#define DevProp_PciExpressDevice_PayloadOrRequestSize_1024Bytes         3
#define DevProp_PciExpressDevice_PayloadOrRequestSize_2048Bytes         4
#define DevProp_PciExpressDevice_PayloadOrRequestSize_4096Bytes         5

DEFINE_PCI_DEVICE_DEVPKEY(DEVPKEY_PciDevice_CurrentPayloadSize, 6);

//
// This property describes the maximum payload size supported by an express
// device/function. The encodings are described above.
//

DEFINE_PCI_DEVICE_DEVPKEY(DEVPKEY_PciDevice_MaxPayloadSize, 7);

//
// This property describes the maximum read request size for an express device.
// The encoding for this field are given above.
//

DEFINE_PCI_DEVICE_DEVPKEY(DEVPKEY_PciDevice_MaxReadRequestSize, 8);

//
// This property is applicable to an express device with an express link. It
// describes the current link speed for the device. The encodings are defined
// as follows.
//

#define DevProp_PciExpressDevice_LinkSpeed_TwoAndHalf_Gbps      1

DEFINE_PCI_DEVICE_DEVPKEY(DEVPKEY_PciDevice_CurrentLinkSpeed, 9);

//
// This property is applicable to an express device with an express link. It
// describes the current link width whose encoding is as follows.
//

#define DevProp_PciExpressDevice_LinkWidth_By_1             1
#define DevProp_PciExpressDevice_LinkWidth_By_2             2
#define DevProp_PciExpressDevice_LinkWidth_By_4             4
#define DevProp_PciExpressDevice_LinkWidth_By_8             8
#define DevProp_PciExpressDevice_LinkWidth_By_12           12
#define DevProp_PciExpressDevice_LinkWidth_By_16           16
#define DevProp_PciExpressDevice_LinkWidth_By_32           32

DEFINE_PCI_DEVICE_DEVPKEY(DEVPKEY_PciDevice_CurrentLinkWidth, 10);

//
// This property describes the maximum link speed of an express link for an
// express device. The encodings for this field are:
//

#define DevProp_PciExpressDevice_LinkSpeed_TwoAndHalf_Gbps      1

DEFINE_PCI_DEVICE_DEVPKEY(DEVPKEY_PciDevice_MaxLinkSpeed, 11);

//
// This property describes the maximum link width implemented by an express
// link for an express devce. The encodings are same as described above.
//

DEFINE_PCI_DEVICE_DEVPKEY(DEVPKEY_PciDevice_MaxLinkWidth, 12);

//
// This property describes the specification version to which an express device
// was built.  The encodings for this field are:
//

#define DevProp_PciExpressDevice_Spec_Version_10        1
#define DevProp_PciExpressDevice_Spec_Version_11        2

DEFINE_PCI_DEVICE_DEVPKEY(DEVPKEY_PciDevice_ExpressSpecVersion, 13);

//
// This property describes the hardware support for interrupts on the device.
// It is a bitmask of supported interrupt types, with the following values:
//

#define DevProp_PciDevice_InterruptType_LineBased       1
#define DevProp_PciDevice_InterruptType_Msi             2
#define DevProp_PciDevice_InterruptType_MsiX            4

DEFINE_PCI_DEVICE_DEVPKEY(DEVPKEY_PciDevice_InterruptSupport, 14);

//
// This property describes the number of message interrupts a device supports
// in hardware.  This property is only valid if the device supports message
// interrupts.
//

DEFINE_PCI_DEVICE_DEVPKEY(DEVPKEY_PciDevice_InterruptMessageMaximum, 15);

//
// This property describes the number of Base Address Registers of various types
// supported by the device hardware.  The property data is a 32 bit value
// interpreted by the following macros:
//

#define DevProp_PciDevice_IoBarCount(_PropertyData)                             ((_PropertyData) & 0xFF)
#define DevProp_PciDevice_NonPrefetchable_MemoryBarCount(_PropertyData)         (((_PropertyData) >> 8) & 0xFF)
#define DevProp_PciDevice_32BitPrefetchable_MemoryBarCount(_PropertyData)       (((_PropertyData) >> 16) & 0xFF)
#define DevProp_PciDevice_64BitPrefetchable_MemoryBarCount(_PropertyData)       (((_PropertyData) >> 24) & 0xFF)

DEFINE_PCI_DEVICE_DEVPKEY(DEVPKEY_PciDevice_BarTypes, 16);

//
// This property is a BOOLEAN indicating if AER capability is present on an
// endpoint.
//

DEFINE_PCI_DEVICE_DEVPKEY(DEVPKEY_PciDevice_AERCapabilityPresent, 17);

//
// This property indicates if a device is configured for a firmware first
// error handling.
//

DEFINE_PCI_DEVICE_DEVPKEY(DEVPKEY_PciDevice_FirmwareErrorHandling, 18);

//
// This property provides the uncorrectable error mask for an endpoint. This
// field is interpreted in accordance to its definition in the PCI Express
// Base spec.
//

DEFINE_PCI_DEVICE_DEVPKEY(DEVPKEY_PciDevice_Uncorrectable_Error_Mask, 19);

//
// This property provides the uncorrectable error severity for an endpoint.
// This field is interpreted in accordance to its definition in the PCI Express
// Base spec.
//

DEFINE_PCI_DEVICE_DEVPKEY(DEVPKEY_PciDevice_Uncorrectable_Error_Severity, 20);

//
// This property provides the correctable error mask for an endpoint. This
// field is interpreted in accordance to its definition in the PCI Express
// Base spec.
//

DEFINE_PCI_DEVICE_DEVPKEY(DEVPKEY_PciDevice_Correctable_Error_Mask, 21);

//
// This property indicates if a device is capable of ECRC generation and
// checking. This field is interpreted in according to the advanced error
// capabilities and control register value in the PCI Express Base spec.
//

DEFINE_PCI_DEVICE_DEVPKEY(DEVPKEY_PciDevice_ECRC_Errors, 22);

//
// This property indicates if an endpoint is enabled for reporting different
// types of error messages. This field is interpreted in accordance to the
// device control register value as described in the PCI Express Base spec.
//

DEFINE_PCI_DEVICE_DEVPKEY(DEVPKEY_PciDevice_Error_Reporting, 23);

//
// This property indicates if a root port is enabled for reporting different
// types of error messages. This field is interpreted in accordance to the
// root control register value as described in the PCI Express Base spec.
//

DEFINE_PCI_DEVICE_DEVPKEY(DEVPKEY_PciDevice_RootError_Reporting, 24);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\portabledevice.h ===
/****************************************************************************
* Copyright (c) Microsoft Corporation. All rights reserved.
****************************************************************************/
#pragma once 
// Windows XP SP2, Windows Vista, or later (excluding Windows Server 2003)
#if ((NTDDI_VERSION >= NTDDI_WINXPSP2 && NTDDI_VERSION < NTDDI_WS03) || (NTDDI_VERSION >= NTDDI_WINLH))
#include "propkeydef.h" 

/**************************************************************************** 
* This section declares WPD guids used in PnP 
****************************************************************************/
// 
// GUID_DEVINTERFACE_WPD
//   This GUID is used to identify devices / drivers that support the WPD DDI. 
//   The WPD Class Extension component enables this device interface for WPD Drivers that use it. Clients use this PnP interface when registering for PnP device arrival messages for WPD devices. 
DEFINE_GUID(GUID_DEVINTERFACE_WPD, 0x6AC27878, 0xA6FA, 0x4155, 0xBA, 0x85, 0xF9, 0x8F, 0x49, 0x1D, 0x4F, 0x33 ); 
// 
// GUID_DEVINTERFACE_WPD_PRIVATE
//   This GUID is used to identify devices / drivers that can be used only by a specialized WPD client and will not show up in normal WPD enumeration. 
//   Devices identified with this interface cannot be used with normal WPD applications. Generic WPD drivers and clients should not use this interface. 
DEFINE_GUID(GUID_DEVINTERFACE_WPD_PRIVATE, 0xBA0C718F, 0x4DED, 0x49B7, 0xBD, 0xD3, 0xFA, 0xBE, 0x28, 0x66, 0x12, 0x11 ); 

/**************************************************************************** 
* This section declares WPD defines 
****************************************************************************/
// WPD specific function number used to construct WPD I/O control codes. Drivers should not use this define directly. 
// 
#define WPD_CONTROL_FUNCTION_GENERIC_MESSAGE 0x42 

// Defines WPD specific IOCTL number used by drivers to detect WPD requests that may require READ and WRITE access to the device. 
// 
#define IOCTL_WPD_MESSAGE_READWRITE_ACCESS CTL_CODE(FILE_DEVICE_WPD, WPD_CONTROL_FUNCTION_GENERIC_MESSAGE, METHOD_BUFFERED, (FILE_READ_ACCESS | FILE_WRITE_ACCESS)) 

// Defines WPD specific IOCTL number used by drivers to detect WPD requests that require READ-only access to the device. 
// 
#define IOCTL_WPD_MESSAGE_READ_ACCESS CTL_CODE(FILE_DEVICE_WPD, WPD_CONTROL_FUNCTION_GENERIC_MESSAGE, METHOD_BUFFERED, FILE_READ_ACCESS) 

// Drivers can use this macro to detect whether the incoming IOCTL is a WPD message or not. 
// 
#define IS_WPD_IOCTL(ControlCode) ((ControlCode == IOCTL_WPD_MESSAGE_READWRITE_ACCESS) || (ControlCode == IOCTL_WPD_MESSAGE_READ_ACCESS)) 

// Pre-defined ObjectID for the DEVICE object.
// 
#define WPD_DEVICE_OBJECT_ID L"DEVICE" 

// Pre-defined IWMDMDevice for the IWMDRMDeviceApp license/metering APIs.
// 
#define WMDRMDEVICEAPP_USE_WPD_DEVICE_PTR ((ULONG_PTR)-1) 

// Pre-defined name of a REG_DWORD value that defines the device type, used for representation purposes only. Functional characteristics of the device are decided through functional objects. 
// This value can be retrieved using IPortableDeviceManager::GetDeviceProperty(...). See WPD_DEVICE_TYPES enumeration for possible values. 
#define PORTABLE_DEVICE_TYPE L"PortableDeviceType" 

// Pre-defined name of a REG_SZ/REG_EXPAND_SZ/REG_MULTI_SZ value that indicates the location of the device icon file or device icon resource. 
// This value can be retrieved using IPortableDeviceManager::GetDeviceProperty(...). This REG_SZ/REG_EXPAND_SZ/REG_MULTI_SZ value is either in the form "file.dll, resourceID" or a full file path to an icon file. e.g.: "x:\file.ico" 
#define PORTABLE_DEVICE_ICON L"Icons" 

// Pre-defined name of a REG_DWORD value that indicates the amount of time in milliseconds the WPD Namespace Extension will keep its reference to the device open under idle conditions. 
// This value can be retrieved using IPortableDeviceManager::GetDeviceProperty(...). 
#define PORTABLE_DEVICE_NAMESPACE_TIMEOUT L"PortableDeviceNameSpaceTimeout" 

// Pre-defined name of a REG_DWORD value that is used as a flag to indicate whether the device should, or should not, be shown in the Explorer view. 
// This value can be retrieved using IPortableDeviceManager::GetDeviceProperty(...). Meaning of values are: 0 = include, 1 = exclude. 0 is assumed if this value doesn't exist. 
#define PORTABLE_DEVICE_NAMESPACE_EXCLUDE_FROM_SHELL L"PortableDeviceNameSpaceExcludeFromShell" 

// Pre-defined name of a REG_SZ or REG_MULTI_SZ value containing content type guids that are used indicate for what content types the portable device namespace should attempt to automatically generate a thumbnail when placing new content on the device. 
// This value can be retrieved using IPortableDeviceManager::GetDeviceProperty(...). Values should be a string representation of a GUID, in the form '{00000000-0000-0000-0000-000000000000}'. By default the portable device namespace attempts to automatically generate thumbnails for WPD_CONTENT_TYPE_IMAGE, if a device does not want this behavior it can set this value to an empty string. 
#define PORTABLE_DEVICE_NAMESPACE_THUMBNAIL_CONTENT_TYPES L"PortableDeviceNameSpaceThumbnailContentTypes" 

// Pre-defined name of a REG_DWORD value that indicates whether a Portable Device is a Mass Storage Class (MSC) device. This is used to avoid duplication of the device in certain views and scenarios that include both file system and Portable Devices. 
// This value can be retrieved using IPortableDeviceManager::GetDeviceProperty(...). Meaning of values are: 0 = device is not mass storage, 1 = device is mass storage. 0 is assumed if this value doesn't exist. 
#define PORTABLE_DEVICE_IS_MASS_STORAGE L"PortableDeviceIsMassStorage" 

// Pre-defined value identifying the "Windows Media Digital Rights Management 10 for Portable Devices" scheme for protecting content. 
// This value can be used by drivers to indicate they support WMDRM10-PD. See WPD_DEVICE_SUPPORTED_DRM_SCHEMES. 
#define PORTABLE_DEVICE_DRM_SCHEME_WMDRM10_PD L"WMDRM10-PD" 

// Pre-defined value identifying the "Portable Device Digital Rights Management" scheme for protecting content. 
// This value can be used by drivers to indicate they support PDDRM. See WPD_DEVICE_SUPPORTED_DRM_SCHEMES. 
#define PORTABLE_DEVICE_DRM_SCHEME_PDDRM L"PDDRM" 


/**************************************************************************** 
* This section defines flags used in API arguments 
****************************************************************************/

// Indicates whether the delete request should recursively delete any children.
typedef enum tagDELETE_OBJECT_OPTIONS
{ 
    PORTABLE_DEVICE_DELETE_NO_RECURSION = 0, 
    PORTABLE_DEVICE_DELETE_WITH_RECURSION = 1
} DELETE_OBJECT_OPTIONS; 

// Possible values for PORTABLE_DEVICE_TYPE registry value. 
typedef enum tagWPD_DEVICE_TYPES
{ 
    WPD_DEVICE_TYPE_GENERIC = 0, 
    WPD_DEVICE_TYPE_CAMERA = 1, 
    WPD_DEVICE_TYPE_MEDIA_PLAYER = 2, 
    WPD_DEVICE_TYPE_PHONE = 3, 
    WPD_DEVICE_TYPE_VIDEO = 4, 
    WPD_DEVICE_TYPE_PERSONAL_INFORMATION_MANAGER = 5, 
    WPD_DEVICE_TYPE_AUDIO_RECORDER = 6
} WPD_DEVICE_TYPES; 

// Possible values for WPD_PROPERTY_ATTRIBUTE_FORM 
typedef enum tagWpdAttributeForm
{ 
    WPD_PROPERTY_ATTRIBUTE_FORM_UNSPECIFIED = 0, 
    WPD_PROPERTY_ATTRIBUTE_FORM_RANGE = 1, 
    WPD_PROPERTY_ATTRIBUTE_FORM_ENUMERATION = 2, 
    WPD_PROPERTY_ATTRIBUTE_FORM_REGULAR_EXPRESSION = 3
} WpdAttributeForm; 

// Indicates the type of storage. 
typedef enum tagWPD_STORAGE_TYPE_VALUES
{ 
    WPD_STORAGE_TYPE_UNDEFINED = 0, 
    WPD_STORAGE_TYPE_FIXED_ROM = 1, 
    WPD_STORAGE_TYPE_REMOVABLE_ROM = 2, 
    WPD_STORAGE_TYPE_FIXED_RAM = 3, 
    WPD_STORAGE_TYPE_REMOVABLE_RAM = 4
} WPD_STORAGE_TYPE_VALUES; 

// Indicates write-protection that globally affects the storage. 
typedef enum tagWPD_STORAGE_ACCESS_CAPABILITY_VALUES
{ 
    WPD_STORAGE_ACCESS_CAPABILITY_READWRITE = 0, 
    WPD_STORAGE_ACCESS_CAPABILITY_READ_ONLY_WITHOUT_OBJECT_DELETION = 1, 
    WPD_STORAGE_ACCESS_CAPABILITY_READ_ONLY_WITH_OBJECT_DELETION = 2
} WPD_STORAGE_ACCESS_CAPABILITY_VALUES; 

// Possible values for WPD_SMS_ENCODING 
typedef enum tagWPD_SMS_ENCODING_TYPES
{ 
    SMS_ENCODING_7_BIT = 0, 
    SMS_ENCODING_8_BIT = 1, 
    SMS_ENCODING_UTF_16 = 2
} WPD_SMS_ENCODING_TYPES; 

// Possible values for WPD_PROPERTY_SMS_MESSAGE_TYPE 
typedef enum tagSMS_MESSAGE_TYPES
{ 
    SMS_TEXT_MESSAGE = 0, 
    SMS_BINARY_MESSAGE = 1
} SMS_MESSAGE_TYPES; 

// Indicates whether the device is on battery power or external power.
typedef enum tagWPD_POWER_SOURCES
{ 
    WPD_POWER_SOURCE_BATTERY = 0, 
    WPD_POWER_SOURCE_EXTERNAL = 1
} WPD_POWER_SOURCES; 

// Indicates the way the device weighs color channels.
typedef enum tagWPD_WHITE_BALANCE_SETTINGS
{ 
    WPD_WHITE_BALANCE_UNDEFINED = 0, 
    WPD_WHITE_BALANCE_MANUAL = 1, 
    WPD_WHITE_BALANCE_AUTOMATIC = 2, 
    WPD_WHITE_BALANCE_ONE_PUSH_AUTOMATIC = 3, 
    WPD_WHITE_BALANCE_DAYLIGHT = 4, 
    WPD_WHITE_BALANCE_FLORESCENT = 5, 
    WPD_WHITE_BALANCE_TUNGSTEN = 6, 
    WPD_WHITE_BALANCE_FLASH = 7
} WPD_WHITE_BALANCE_SETTINGS; 

// Indicates the focus mode of the device.
typedef enum tagWPD_FOCUS_MODES
{ 
    WPD_FOCUS_UNDEFINED = 0, 
    WPD_FOCUS_MANUAL = 1, 
    WPD_FOCUS_AUTOMATIC = 2, 
    WPD_FOCUS_AUTOMATIC_MACRO = 3
} WPD_FOCUS_MODES; 

// Indicates the metering mode of the device.
typedef enum tagWPD_EXPOSURE_METERING_MODES
{ 
    WPD_EXPOSURE_METERING_MODE_UNDEFINED = 0, 
    WPD_EXPOSURE_METERING_MODE_AVERAGE = 1, 
    WPD_EXPOSURE_METERING_MODE_CENTER_WEIGHTED_AVERAGE = 2, 
    WPD_EXPOSURE_METERING_MODE_MULTI_SPOT = 3, 
    WPD_EXPOSURE_METERING_MODE_CENTER_SPOT = 4
} WPD_EXPOSURE_METERING_MODES; 

// Indicates the flash mode of the device.
typedef enum tagWPD_FLASH_MODES
{ 
    WPD_FLASH_MODE_UNDEFINED = 0, 
    WPD_FLASH_MODE_AUTO = 1, 
    WPD_FLASH_MODE_OFF = 2, 
    WPD_FLASH_MODE_FILL = 3, 
    WPD_FLASH_MODE_RED_EYE_AUTO = 4, 
    WPD_FLASH_MODE_RED_EYE_FILL = 5, 
    WPD_FLASH_MODE_EXTERNAL_SYNC = 6
} WPD_FLASH_MODES; 

// Indicates the exposure program mode of the device.
typedef enum tagWPD_EXPOSURE_PROGRAM_MODES
{ 
    WPD_EXPOSURE_PROGRAM_MODE_UNDEFINED = 0, 
    WPD_EXPOSURE_PROGRAM_MODE_MANUAL = 1, 
    WPD_EXPOSURE_PROGRAM_MODE_AUTO = 2, 
    WPD_EXPOSURE_PROGRAM_MODE_APERTURE_PRIORITY = 3, 
    WPD_EXPOSURE_PROGRAM_MODE_SHUTTER_PRIORITY = 4, 
    WPD_EXPOSURE_PROGRAM_MODE_CREATIVE = 5, 
    WPD_EXPOSURE_PROGRAM_MODE_ACTION = 6, 
    WPD_EXPOSURE_PROGRAM_MODE_PORTRAIT = 7
} WPD_EXPOSURE_PROGRAM_MODES; 

// Indicates the capture mode of the device.
typedef enum tagWPD_CAPTURE_MODES
{ 
    WPD_CAPTURE_MODE_UNDEFINED = 0, 
    WPD_CAPTURE_MODE_NORMAL = 1, 
    WPD_CAPTURE_MODE_BURST = 2, 
    WPD_CAPTURE_MODE_TIMELAPSE = 3
} WPD_CAPTURE_MODES; 

// Indicates the effect mode of the capture device.
typedef enum tagWPD_EFFECT_MODES
{ 
    WPD_EFFECT_MODE_UNDEFINED = 0, 
    WPD_EFFECT_MODE_COLOR = 1, 
    WPD_EFFECT_MODE_BLACK_AND_WHITE = 2, 
    WPD_EFFECT_MODE_SEPIA = 3
} WPD_EFFECT_MODES; 

// Indicates the metering mode of the capture device.
typedef enum tagWPD_FOCUS_METERING_MODES
{ 
    WPD_FOCUS_METERING_MODE_UNDEFINED = 0, 
    WPD_FOCUS_METERING_MODE_CENTER_SPOT = 1, 
    WPD_FOCUS_METERING_MODE_MULTI_SPOT = 2
} WPD_FOCUS_METERING_MODES; 

// Indicates the type of bitrate for the audio/video data.
typedef enum tagWPD_BITRATE_TYPES
{ 
    WPD_BITRATE_TYPE_UNUSED = 0, 
    WPD_BITRATE_TYPE_DISCRETE = 1, 
    WPD_BITRATE_TYPE_VARIABLE = 2, 
    WPD_BITRATE_TYPE_FREE = 3
} WPD_BITRATE_TYPES; 

// Qualifies the object data in a contextual way.
typedef enum tagWPD_META_GENRES
{ 
    WPD_META_GENRE_UNUSED = 0x0, 
    WPD_META_GENRE_GENERIC_MUSIC_AUDIO_FILE = 0x1, 
    WPD_META_GENRE_GENERIC_NON_MUSIC_AUDIO_FILE = 0x11, 
    WPD_META_GENRE_SPOKEN_WORD_AUDIO_BOOK_FILES = 0x12, 
    WPD_META_GENRE_SPOKEN_WORD_FILES_NON_AUDIO_BOOK = 0x13, 
    WPD_META_GENRE_SPOKEN_WORD_NEWS = 0x14, 
    WPD_META_GENRE_SPOKEN_WORD_TALK_SHOWS = 0x15, 
    WPD_META_GENRE_GENERIC_VIDEO_FILE = 0x21, 
    WPD_META_GENRE_NEWS_VIDEO_FILE = 0x22, 
    WPD_META_GENRE_MUSIC_VIDEO_FILE = 0x23, 
    WPD_META_GENRE_HOME_VIDEO_FILE = 0x24, 
    WPD_META_GENRE_FEATURE_FILM_VIDEO_FILE = 0x25, 
    WPD_META_GENRE_TELEVISION_VIDEO_FILE = 0x26, 
    WPD_META_GENRE_TRAINING_EDUCATIONAL_VIDEO_FILE = 0x27, 
    WPD_META_GENRE_PHOTO_MONTAGE_VIDEO_FILE = 0x28, 
    WPD_META_GENRE_GENERIC_NON_AUDIO_NON_VIDEO = 0x30, 
    WPD_META_GENRE_AUDIO_PODCAST = 0x40, 
    WPD_META_GENRE_VIDEO_PODCAST = 0x41, 
    WPD_META_GENRE_MIXED_PODCAST = 0x42
} WPD_META_GENRES; 

// Indicates the cropped status of an image. 
typedef enum tagWPD_CROPPED_STATUS_VALUES
{ 
    WPD_CROPPED_STATUS_NOT_CROPPED = 0, 
    WPD_CROPPED_STATUS_CROPPED = 1, 
    WPD_CROPPED_STATUS_SHOULD_NOT_BE_CROPPED = 2
} WPD_CROPPED_STATUS_VALUES; 

// Indicates the color corrected status of an image. 
typedef enum tagWPD_COLOR_CORRECTED_STATUS_VALUES
{ 
    WPD_COLOR_CORRECTED_STATUS_NOT_CORRECTED = 0, 
    WPD_COLOR_CORRECTED_STATUS_CORRECTED = 1, 
    WPD_COLOR_CORRECTED_STATUS_SHOULD_NOT_BE_CORRECTED = 2
} WPD_COLOR_CORRECTED_STATUS_VALUES; 

// Identifies the video scan-type information. 
typedef enum tagWPD_VIDEO_SCAN_TYPES
{ 
    WPD_VIDEO_SCAN_TYPE_UNUSED = 0, 
    WPD_VIDEO_SCAN_TYPE_PROGRESSIVE = 1, 
    WPD_VIDEO_SCAN_TYPE_FIELD_INTERLEAVED_UPPER_FIRST = 2, 
    WPD_VIDEO_SCAN_TYPE_FIELD_INTERLEAVED_LOWER_FIRST = 3, 
    WPD_VIDEO_SCAN_TYPE_FIELD_SINGLE_UPPER_FIRST = 4, 
    WPD_VIDEO_SCAN_TYPE_FIELD_SINGLE_LOWER_FIRST = 5, 
    WPD_VIDEO_SCAN_TYPE_MIXED_INTERLACE = 6, 
    WPD_VIDEO_SCAN_TYPE_MIXED_INTERLACE_AND_PROGRESSIVE = 7
} WPD_VIDEO_SCAN_TYPES; 

// Indicates the current state of the operation in progress. 
typedef enum tagWPD_OPERATION_STATES
{ 
    WPD_OPERATION_STATE_UNSPECIFIED = 0, 
    WPD_OPERATION_STATE_STARTED = 1, 
    WPD_OPERATION_STATE_RUNNING = 2, 
    WPD_OPERATION_STATE_PAUSED = 3, 
    WPD_OPERATION_STATE_CANCELLED = 4, 
    WPD_OPERATION_STATE_FINISHED = 5, 
    WPD_OPERATION_STATE_ABORTED = 6
} WPD_OPERATION_STATES; 

// Indicates the units for a referenced section of data. 
typedef enum tagWPD_SECTION_DATA_UNITS_VALUES
{ 
    WPD_SECTION_DATA_UNITS_BYTES = 0, 
    WPD_SECTION_DATA_UNITS_MILLISECONDS = 1
} WPD_SECTION_DATA_UNITS_VALUES; 

// Indicates whether the rendering information profile entry corresponds to an Object or a Resource. 
typedef enum tagWPD_RENDERING_INFORMATION_PROFILE_ENTRY_TYPES
{ 
    WPD_RENDERING_INFORMATION_PROFILE_ENTRY_TYPE_OBJECT = 0, 
    WPD_RENDERING_INFORMATION_PROFILE_ENTRY_TYPE_RESOURCE = 1
} WPD_RENDERING_INFORMATION_PROFILE_ENTRY_TYPES; 

// Indicates the type of access the command requires. This is only used internally by the command access lookup table. There is no need to use these values directly. 
typedef enum tagWPD_COMMAND_ACCESS_TYPES
{ 
    WPD_COMMAND_ACCESS_READ = 1, 
    WPD_COMMAND_ACCESS_READWRITE = 3, 
    WPD_COMMAND_ACCESS_FROM_PROPERTY_WITH_STGM_ACCESS = 4, 
    WPD_COMMAND_ACCESS_FROM_PROPERTY_WITH_FILE_ACCESS = 8
} WPD_COMMAND_ACCESS_TYPES; 

/**************************************************************************** 
* This section declares WPD specific Errors 
****************************************************************************/
#define FACILITY_WPD 42 

#define E_WPD_DEVICE_ALREADY_OPENED MAKE_HRESULT( SEVERITY_ERROR , FACILITY_WPD, 1 ) /* 0x802A0001 */
#define E_WPD_DEVICE_NOT_OPEN MAKE_HRESULT( SEVERITY_ERROR , FACILITY_WPD, 2 ) /* 0x802A0002 */
#define E_WPD_OBJECT_ALREADY_ATTACHED_TO_DEVICE MAKE_HRESULT( SEVERITY_ERROR , FACILITY_WPD, 3 ) /* 0x802A0003 */
#define E_WPD_OBJECT_NOT_ATTACHED_TO_DEVICE MAKE_HRESULT( SEVERITY_ERROR , FACILITY_WPD, 4 ) /* 0x802A0004 */
#define E_WPD_OBJECT_NOT_COMMITED MAKE_HRESULT( SEVERITY_ERROR , FACILITY_WPD, 5 ) /* 0x802A0005 */
#define E_WPD_DEVICE_IS_HUNG MAKE_HRESULT( SEVERITY_ERROR , FACILITY_WPD, 6 ) /* 0x802A0006 */
#define E_WPD_SMS_INVALID_RECIPIENT MAKE_HRESULT( SEVERITY_ERROR , FACILITY_WPD, 100 ) /* 0x802A0064 */
#define E_WPD_SMS_INVALID_MESSAGE_BODY MAKE_HRESULT( SEVERITY_ERROR , FACILITY_WPD, 101 ) /* 0x802A0065 */
#define E_WPD_SMS_SERVICE_UNAVAILABLE MAKE_HRESULT( SEVERITY_ERROR , FACILITY_WPD, 102 ) /* 0x802A0066 */

/**************************************************************************** 
* This section defines all WPD Events 
****************************************************************************/
// 
// WPD_EVENT_NOTIFICATION
//   This GUID is used to identify all WPD driver events to the event sub-system. The driver uses this as the GUID identifier when it queues an event with IWdfDevice::PostEvent(). Applications never use this value. 
DEFINE_GUID(WPD_EVENT_NOTIFICATION, 0x2BA2E40A, 0x6B4C, 0x4295, 0xBB, 0x43, 0x26, 0x32, 0x2B, 0x99, 0xAE, 0xB2 ); 
// 
// WPD_EVENT_OBJECT_ADDED
//   This event is sent after a new object is available on the device. 
DEFINE_GUID(WPD_EVENT_OBJECT_ADDED, 0xA726DA95, 0xE207, 0x4B02, 0x8D, 0x44, 0xBE, 0xF2, 0xE8, 0x6C, 0xBF, 0xFC ); 
// 
// WPD_EVENT_OBJECT_REMOVED
//   This event is sent after a previously existing object has been removed from the device. 
DEFINE_GUID(WPD_EVENT_OBJECT_REMOVED, 0xBE82AB88, 0xA52C, 0x4823, 0x96, 0xE5, 0xD0, 0x27, 0x26, 0x71, 0xFC, 0x38 ); 
// 
// WPD_EVENT_OBJECT_UPDATED
//   This event is sent after an object has been updated such that any connected client should refresh its view of that object. 
DEFINE_GUID(WPD_EVENT_OBJECT_UPDATED, 0x1445A759, 0x2E01, 0x485D, 0x9F, 0x27, 0xFF, 0x07, 0xDA, 0xE6, 0x97, 0xAB ); 
// 
// WPD_EVENT_DEVICE_RESET
//   This event indicates that the device is about to be reset, and all connected clients should close their connection to the device. 
DEFINE_GUID(WPD_EVENT_DEVICE_RESET, 0x7755CF53, 0xC1ED, 0x44F3, 0xB5, 0xA2, 0x45, 0x1E, 0x2C, 0x37, 0x6B, 0x27 ); 
// 
// WPD_EVENT_DEVICE_CAPABILITIES_UPDATED
//   This event indicates that the device capabilities have changed. Clients should re-query the device if they have made any decisions based on device capabilities. 
DEFINE_GUID(WPD_EVENT_DEVICE_CAPABILITIES_UPDATED, 0x36885AA1, 0xCD54, 0x4DAA, 0xB3, 0xD0, 0xAF, 0xB3, 0xE0, 0x3F, 0x59, 0x99 ); 
// 
// WPD_EVENT_STORAGE_FORMAT
//   This event indicates the progress of a format operation on a storage object. 
DEFINE_GUID(WPD_EVENT_STORAGE_FORMAT, 0x3782616B, 0x22BC, 0x4474, 0xA2, 0x51, 0x30, 0x70, 0xF8, 0xD3, 0x88, 0x57 ); 
// 
// WPD_EVENT_OBJECT_TRANSFER_REQUESTED
//   This event is sent to request an application to transfer a particular object from the device. 
DEFINE_GUID(WPD_EVENT_OBJECT_TRANSFER_REQUESTED, 0x8D16A0A1, 0xF2C6, 0x41DA, 0x8F, 0x19, 0x5E, 0x53, 0x72, 0x1A, 0xDB, 0xF2 ); 
// 
// WPD_EVENT_DEVICE_REMOVED
//   This event is sent when a driver for a device is being unloaded. This is typically a result of the device being unplugged. 
DEFINE_GUID(WPD_EVENT_DEVICE_REMOVED, 0xE4CBCA1B, 0x6918, 0x48B9,0x85, 0xEE, 0x02, 0xBE, 0x7C, 0x85, 0x0A, 0xF9 ); 

/**************************************************************************** 
* This section defines all WPD content types 
****************************************************************************/
// 
// WPD_CONTENT_TYPE_FUNCTIONAL_OBJECT
//   Indicates this object represents a functional object, not content data on the device. 
DEFINE_GUID(WPD_CONTENT_TYPE_FUNCTIONAL_OBJECT, 0x99ED0160, 0x17FF, 0x4C44, 0x9D, 0x98, 0x1D, 0x7A, 0x6F, 0x94, 0x19, 0x21 );
// 
// WPD_CONTENT_TYPE_FOLDER
//   Indicates this object is a folder. 
DEFINE_GUID(WPD_CONTENT_TYPE_FOLDER, 0x27E2E392, 0xA111, 0x48E0, 0xAB, 0x0C, 0xE1, 0x77, 0x05, 0xA0, 0x5F, 0x85 );
// 
// WPD_CONTENT_TYPE_IMAGE
//   Indicates this object represents image data (e.g. a JPEG file) 
DEFINE_GUID(WPD_CONTENT_TYPE_IMAGE, 0xef2107d5, 0xa52a, 0x4243, 0xa2, 0x6b, 0x62, 0xd4, 0x17, 0x6d, 0x76, 0x03 );
// 
// WPD_CONTENT_TYPE_DOCUMENT
//   Indicates this object represents document data (e.g. a MS WORD file, TEXT file, etc.) 
DEFINE_GUID(WPD_CONTENT_TYPE_DOCUMENT, 0x680ADF52, 0x950A, 0x4041, 0x9B, 0x41, 0x65, 0xE3, 0x93, 0x64, 0x81, 0x55 );
// 
// WPD_CONTENT_TYPE_CONTACT
//   Indicates this object represents contact data (e.g. name/number, or a VCARD file) 
DEFINE_GUID(WPD_CONTENT_TYPE_CONTACT, 0xEABA8313, 0x4525, 0x4707, 0x9F, 0x0E, 0x87, 0xC6, 0x80, 0x8E, 0x94, 0x35 );
// 
// WPD_CONTENT_TYPE_CONTACT_GROUP
//   Indicates this object represents a group of contacts. 
DEFINE_GUID(WPD_CONTENT_TYPE_CONTACT_GROUP, 0x346B8932, 0x4C36, 0x40D8, 0x94, 0x15, 0x18, 0x28, 0x29, 0x1F, 0x9D, 0xE9 );
// 
// WPD_CONTENT_TYPE_AUDIO
//   Indicates this object represents audio data (e.g. a WMA or MP3 file) 
DEFINE_GUID(WPD_CONTENT_TYPE_AUDIO, 0x4AD2C85E, 0x5E2D, 0x45E5, 0x88, 0x64, 0x4F, 0x22, 0x9E, 0x3C, 0x6C, 0xF0 );
// 
// WPD_CONTENT_TYPE_VIDEO
//   Indicates this object represents video data (e.g. a WMV or AVI file) 
DEFINE_GUID(WPD_CONTENT_TYPE_VIDEO, 0x9261B03C, 0x3D78, 0x4519, 0x85, 0xE3, 0x02, 0xC5, 0xE1, 0xF5, 0x0B, 0xB9 );
// 
// WPD_CONTENT_TYPE_PLAYLIST
//   Indicates this object represents a playlist. 
DEFINE_GUID(WPD_CONTENT_TYPE_PLAYLIST, 0x1A33F7E4, 0xAF13, 0x48F5, 0x99, 0x4E, 0x77, 0x36, 0x9D, 0xFE, 0x04, 0xA3 );
// 
// WPD_CONTENT_TYPE_MIXED_CONTENT_ALBUM
//   Indicates this object represents an album, which may contain objects of different content types (typically, MUSIC, IMAGE and VIDEO). 
DEFINE_GUID(WPD_CONTENT_TYPE_MIXED_CONTENT_ALBUM, 0x00F0C3AC, 0xA593, 0x49AC, 0x92, 0x19, 0x24, 0xAB, 0xCA, 0x5A, 0x25, 0x63 );
// 
// WPD_CONTENT_TYPE_AUDIO_ALBUM
//   Indicates this object represents an audio album. 
DEFINE_GUID(WPD_CONTENT_TYPE_AUDIO_ALBUM, 0xAA18737E, 0x5009, 0x48FA, 0xAE, 0x21, 0x85, 0xF2, 0x43, 0x83, 0xB4, 0xE6 );
// 
// WPD_CONTENT_TYPE_IMAGE_ALBUM
//   Indicates this object represents an image album. 
DEFINE_GUID(WPD_CONTENT_TYPE_IMAGE_ALBUM, 0x75793148, 0x15F5, 0x4A30, 0xA8, 0x13, 0x54, 0xED, 0x8A, 0x37, 0xE2, 0x26 );
// 
// WPD_CONTENT_TYPE_VIDEO_ALBUM
//   Indicates this object represents a video album. 
DEFINE_GUID(WPD_CONTENT_TYPE_VIDEO_ALBUM, 0x012B0DB7, 0xD4C1, 0x45D6, 0xB0, 0x81, 0x94, 0xB8, 0x77, 0x79, 0x61, 0x4F );
// 
// WPD_CONTENT_TYPE_MEMO
//   Indicates this object represents memo data 
DEFINE_GUID(WPD_CONTENT_TYPE_MEMO, 0x9CD20ECF, 0x3B50, 0x414F, 0xA6, 0x41, 0xE4, 0x73, 0xFF, 0xE4, 0x57, 0x51 );
// 
// WPD_CONTENT_TYPE_EMAIL
//   Indicates this object represents e-mail data 
DEFINE_GUID(WPD_CONTENT_TYPE_EMAIL, 0x8038044A, 0x7E51, 0x4F8F, 0x88, 0x3D, 0x1D, 0x06, 0x23, 0xD1, 0x45, 0x33 );
// 
// WPD_CONTENT_TYPE_APPOINTMENT
//   Indicates this object represents an appointment in a calendar 
DEFINE_GUID(WPD_CONTENT_TYPE_APPOINTMENT, 0x0FED060E, 0x8793, 0x4B1E, 0x90, 0xC9, 0x48, 0xAC, 0x38, 0x9A, 0xC6, 0x31 );
// 
// WPD_CONTENT_TYPE_TASK
//   Indicates this object represents a task for tracking (e.g. a TODO list) 
DEFINE_GUID(WPD_CONTENT_TYPE_TASK, 0x63252F2C, 0x887F, 0x4CB6, 0xB1, 0xAC, 0xD2, 0x98, 0x55, 0xDC, 0xEF, 0x6C );
// 
// WPD_CONTENT_TYPE_PROGRAM
//   Indicates this object represents a file that can be run. This could be a script, executable and so on. 
DEFINE_GUID(WPD_CONTENT_TYPE_PROGRAM, 0xD269F96A, 0x247C, 0x4BFF, 0x98, 0xFB, 0x97, 0xF3, 0xC4, 0x92, 0x20, 0xE6 );
// 
// WPD_CONTENT_TYPE_GENERIC_FILE
//   Indicates this object represents a file that does not fall into any of the other predefined WPD types for files. 
DEFINE_GUID(WPD_CONTENT_TYPE_GENERIC_FILE, 0x0085E0A6, 0x8D34, 0x45D7, 0xBC, 0x5C, 0x44, 0x7E, 0x59, 0xC7, 0x3D, 0x48 );
// 
// WPD_CONTENT_TYPE_CALENDAR
//   Indicates this object represents a calender 
DEFINE_GUID(WPD_CONTENT_TYPE_CALENDAR, 0xA1FD5967, 0x6023, 0x49A0, 0x9D, 0xF1, 0xF8, 0x06, 0x0B, 0xE7, 0x51, 0xB0 );
// 
// WPD_CONTENT_TYPE_GENERIC_MESSAGE
//   Indicates this object represents a message (e.g. SMS message, E-Mail message, etc.) 
DEFINE_GUID(WPD_CONTENT_TYPE_GENERIC_MESSAGE, 0xE80EAAF8, 0xB2DB, 0x4133, 0xB6, 0x7E, 0x1B, 0xEF, 0x4B, 0x4A, 0x6E, 0x5F );
// 
// WPD_CONTENT_TYPE_NETWORK_ASSOCIATION
//   Indicates this object represents an association between a host and a device. 
DEFINE_GUID(WPD_CONTENT_TYPE_NETWORK_ASSOCIATION, 0x031DA7EE, 0x18C8, 0x4205, 0x84, 0x7E, 0x89, 0xA1, 0x12, 0x61, 0xD0, 0xF3 );
// 
// WPD_CONTENT_TYPE_CERTIFICATE
//   Indicates this object represents certificate used for authentication. 
DEFINE_GUID(WPD_CONTENT_TYPE_CERTIFICATE, 0xDC3876E8, 0xA948, 0x4060, 0x90, 0x50, 0xCB, 0xD7, 0x7E, 0x8A, 0x3D, 0x87 );
// 
// WPD_CONTENT_TYPE_WIRELESS_PROFILE
//   Indicates this object represents wireless network access information. 
DEFINE_GUID(WPD_CONTENT_TYPE_WIRELESS_PROFILE, 0x0BAC070A, 0x9F5F, 0x4DA4, 0xA8, 0xF6, 0x3D, 0xE4, 0x4D, 0x68, 0xFD, 0x6C );
// 
// WPD_CONTENT_TYPE_MEDIA_CAST
//   Indicates this object represents a media cast. A media cast object can be though of as a container object that groups related content, similar to how a playlist groups songs to play. Often, a media cast object is used to group media content originally published online. 
DEFINE_GUID(WPD_CONTENT_TYPE_MEDIA_CAST, 0x5E88B3CC, 0x3E65, 0x4E62, 0xBF, 0xFF, 0x22, 0x94, 0x95, 0x25, 0x3A, 0xB0 );
// 
// WPD_CONTENT_TYPE_SECTION
//   Indicates this object describes a section of data contained in another object. The WPD_OBJECT_REFERENCES property indicates which object contains the actual data. 
DEFINE_GUID(WPD_CONTENT_TYPE_SECTION, 0x821089F5, 0x1D91, 0x4DC9, 0xBE, 0x3C, 0xBB, 0xB1, 0xB3, 0x5B, 0x18, 0xCE );
// 
// WPD_CONTENT_TYPE_UNSPECIFIED
//   Indicates this object doesn't fall into the predefined WPD content types 
DEFINE_GUID(WPD_CONTENT_TYPE_UNSPECIFIED, 0x28D8D31E, 0x249C, 0x454E, 0xAA, 0xBC, 0x34, 0x88, 0x31, 0x68, 0xE6, 0x34 );
// 
// WPD_CONTENT_TYPE_ALL
//   This content type is only valid as a parameter to API functions and driver commands. It should not be reported as a supported content type by the driver. 
DEFINE_GUID(WPD_CONTENT_TYPE_ALL, 0x80E170D2, 0x1055, 0x4A3E, 0xB9, 0x52, 0x82, 0xCC, 0x4F, 0x8A, 0x86, 0x89 );

/**************************************************************************** 
* This section defines all WPD Functional Categories 
****************************************************************************/
// 
// WPD_FUNCTIONAL_CATEGORY_DEVICE
//   Used for the device object, which is always the top-most object of the device. 
DEFINE_GUID(WPD_FUNCTIONAL_CATEGORY_DEVICE, 0x08EA466B, 0xE3A4, 0x4336, 0xA1, 0xF3, 0xA4, 0x4D, 0x2B, 0x5C, 0x43, 0x8C ); 
// 
// WPD_FUNCTIONAL_CATEGORY_STORAGE
//   Indicates this object encapsulates storage functionality on the device (e.g. memory cards, internal memory) 
DEFINE_GUID(WPD_FUNCTIONAL_CATEGORY_STORAGE, 0x23F05BBC, 0x15DE, 0x4C2A, 0xA5, 0x5B, 0xA9, 0xAF, 0x5C, 0xE4, 0x12, 0xEF ); 
// 
// WPD_FUNCTIONAL_CATEGORY_STILL_IMAGE_CAPTURE
//   Indicates this object encapsulates still image capture functionality on the device (e.g. camera or camera attachment) 
DEFINE_GUID(WPD_FUNCTIONAL_CATEGORY_STILL_IMAGE_CAPTURE, 0x613CA327, 0xAB93, 0x4900, 0xB4, 0xFA, 0x89, 0x5B, 0xB5, 0x87, 0x4B, 0x79 ); 
// 
// WPD_FUNCTIONAL_CATEGORY_AUDIO_CAPTURE
//   Indicates this object encapsulates audio capture functionality on the device (e.g. voice recorder or other audio recording component)
DEFINE_GUID(WPD_FUNCTIONAL_CATEGORY_AUDIO_CAPTURE, 0x3F2A1919, 0xC7C2, 0x4A00, 0x85, 0x5D, 0xF5, 0x7C, 0xF0, 0x6D, 0xEB, 0xBB ); 
// 
// WPD_FUNCTIONAL_CATEGORY_VIDEO_CAPTURE
//   Indicates this object encapsulates video capture functionality on the device (e.g. video recorder or video recording component)
DEFINE_GUID(WPD_FUNCTIONAL_CATEGORY_VIDEO_CAPTURE, 0xE23E5F6B, 0x7243, 0x43AA, 0x8D, 0xF1, 0x0E, 0xB3, 0xD9, 0x68, 0xA9, 0x18 ); 
// 
// WPD_FUNCTIONAL_CATEGORY_SMS
//   Indicates this object encapsulates SMS sending functionality on the device (not the receiving or saved SMS messages since those are represented as content objects on the device)
DEFINE_GUID(WPD_FUNCTIONAL_CATEGORY_SMS, 0x0044A0B1, 0xC1E9, 0x4AFD, 0xB3, 0x58, 0xA6, 0x2C, 0x61, 0x17, 0xC9, 0xCF ); 
// 
// WPD_FUNCTIONAL_CATEGORY_RENDERING_INFORMATION
//   Indicates this object provides information about the rendering characteristics of the device. 
DEFINE_GUID(WPD_FUNCTIONAL_CATEGORY_RENDERING_INFORMATION, 0x08600BA4, 0xA7BA, 0x4A01, 0xAB, 0x0E, 0x00, 0x65, 0xD0, 0xA3, 0x56, 0xD3 ); 
// 
// WPD_FUNCTIONAL_CATEGORY_NETWORK_CONFIGURATION
//   Indicates this object encapsulates network configuration functionality on the device (e.g. WiFi Profiles, Partnerships). 
DEFINE_GUID(WPD_FUNCTIONAL_CATEGORY_NETWORK_CONFIGURATION, 0x48F4DB72, 0x7C6A, 0x4AB0, 0x9E, 0x1A, 0x47, 0x0E, 0x3C, 0xDB, 0xF2, 0x6A ); 
// 
// WPD_FUNCTIONAL_CATEGORY_ALL
//   This functional category is only valid as a parameter to API functions and driver commands. It should not be reported as a supported functional category by the driver. 
DEFINE_GUID(WPD_FUNCTIONAL_CATEGORY_ALL, 0x2D8A6512, 0xA74C, 0x448E, 0xBA, 0x8A, 0xF4, 0xAC, 0x07, 0xC4, 0x93, 0x99 ); 

/**************************************************************************** 
* This section defines all WPD Formats 
****************************************************************************/
// 
// WPD_OBJECT_FORMAT_PROPERTIES_ONLY
//   This object has no data stream and is completely specified by properties only. 
DEFINE_GUID(WPD_OBJECT_FORMAT_PROPERTIES_ONLY, 0x30010000, 0xAE6C, 0x4804, 0x98, 0xBA, 0xC5, 0x7B, 0x46, 0x96, 0x5F, 0xE7 );
// 
// WPD_OBJECT_FORMAT_UNSPECIFIED
//   An undefined object format on the device (e.g. objects that can not be classified by the other defined WPD format codes) 
DEFINE_GUID(WPD_OBJECT_FORMAT_UNSPECIFIED, 0x30000000, 0xAE6C, 0x4804, 0x98, 0xBA, 0xC5, 0x7B, 0x46, 0x96, 0x5F, 0xE7 );
// 
// WPD_OBJECT_FORMAT_SCRIPT
//   A device model-specific script 
DEFINE_GUID(WPD_OBJECT_FORMAT_SCRIPT, 0x30020000, 0xAE6C, 0x4804, 0x98, 0xBA, 0xC5, 0x7B, 0x46, 0x96, 0x5F, 0xE7 );
// 
// WPD_OBJECT_FORMAT_EXECUTABLE
//   A device model-specific binary executable 
DEFINE_GUID(WPD_OBJECT_FORMAT_EXECUTABLE, 0x30030000, 0xAE6C, 0x4804, 0x98, 0xBA, 0xC5, 0x7B, 0x46, 0x96, 0x5F, 0xE7 );
// 
// WPD_OBJECT_FORMAT_TEXT
//   A text file 
DEFINE_GUID(WPD_OBJECT_FORMAT_TEXT, 0x30040000, 0xAE6C, 0x4804, 0x98, 0xBA, 0xC5, 0x7B, 0x46, 0x96, 0x5F, 0xE7 );
// 
// WPD_OBJECT_FORMAT_HTML
//   A HyperText Markup Language file (text) 
DEFINE_GUID(WPD_OBJECT_FORMAT_HTML, 0x30050000, 0xAE6C, 0x4804, 0x98, 0xBA, 0xC5, 0x7B, 0x46, 0x96, 0x5F, 0xE7 );
// 
// WPD_OBJECT_FORMAT_DPOF
//   A Digital Print Order File (text) 
DEFINE_GUID(WPD_OBJECT_FORMAT_DPOF, 0x30060000, 0xAE6C, 0x4804, 0x98, 0xBA, 0xC5, 0x7B, 0x46, 0x96, 0x5F, 0xE7 );
// 
// WPD_OBJECT_FORMAT_AIFF
//   Audio file format 
DEFINE_GUID(WPD_OBJECT_FORMAT_AIFF, 0x30070000, 0xAE6C, 0x4804, 0x98, 0xBA, 0xC5, 0x7B, 0x46, 0x96, 0x5F, 0xE7 );
// 
// WPD_OBJECT_FORMAT_WAVE
//   Audio file format 
DEFINE_GUID(WPD_OBJECT_FORMAT_WAVE, 0x30080000, 0xAE6C, 0x4804, 0x98, 0xBA, 0xC5, 0x7B, 0x46, 0x96, 0x5F, 0xE7 );
// 
// WPD_OBJECT_FORMAT_MP3
//   Audio file format 
DEFINE_GUID(WPD_OBJECT_FORMAT_MP3, 0x30090000, 0xAE6C, 0x4804, 0x98, 0xBA, 0xC5, 0x7B, 0x46, 0x96, 0x5F, 0xE7 );
// 
// WPD_OBJECT_FORMAT_AVI
//   Video file format 
DEFINE_GUID(WPD_OBJECT_FORMAT_AVI, 0x300A0000, 0xAE6C, 0x4804, 0x98, 0xBA, 0xC5, 0x7B, 0x46, 0x96, 0x5F, 0xE7 );
// 
// WPD_OBJECT_FORMAT_MPEG
//   Video file format 
DEFINE_GUID(WPD_OBJECT_FORMAT_MPEG, 0x300B0000, 0xAE6C, 0x4804, 0x98, 0xBA, 0xC5, 0x7B, 0x46, 0x96, 0x5F, 0xE7 );
// 
// WPD_OBJECT_FORMAT_ASF
//   Video file format (Microsoft Advanced Streaming Format)
DEFINE_GUID(WPD_OBJECT_FORMAT_ASF, 0x300C0000, 0xAE6C, 0x4804, 0x98, 0xBA, 0xC5, 0x7B, 0x46, 0x96, 0x5F, 0xE7 );
// 
// WPD_OBJECT_FORMAT_EXIF
//   Image file format (Exchangeable File Format), JEIDA standard 
DEFINE_GUID(WPD_OBJECT_FORMAT_EXIF, 0x38010000, 0xAE6C, 0x4804, 0x98, 0xBA, 0xC5, 0x7B, 0x46, 0x96, 0x5F, 0xE7 );
// 
// WPD_OBJECT_FORMAT_TIFFEP
//   Image file format (Tag Image File Format for Electronic Photography) 
DEFINE_GUID(WPD_OBJECT_FORMAT_TIFFEP, 0x38020000, 0xAE6C, 0x4804, 0x98, 0xBA, 0xC5, 0x7B, 0x46, 0x96, 0x5F, 0xE7 );
// 
// WPD_OBJECT_FORMAT_FLASHPIX
//   Image file format (Structured Storage Image Format) 
DEFINE_GUID(WPD_OBJECT_FORMAT_FLASHPIX, 0x38030000, 0xAE6C, 0x4804, 0x98, 0xBA, 0xC5, 0x7B, 0x46, 0x96, 0x5F, 0xE7 );
// 
// WPD_OBJECT_FORMAT_BMP
//   Image file format (Microsoft Windows Bitmap file)
DEFINE_GUID(WPD_OBJECT_FORMAT_BMP, 0x38040000, 0xAE6C, 0x4804, 0x98, 0xBA, 0xC5, 0x7B, 0x46, 0x96, 0x5F, 0xE7 );
// 
// WPD_OBJECT_FORMAT_CIFF
//   Image file format (Canon Camera Image File Format) 
DEFINE_GUID(WPD_OBJECT_FORMAT_CIFF, 0x38050000, 0xAE6C, 0x4804, 0x98, 0xBA, 0xC5, 0x7B, 0x46, 0x96, 0x5F, 0xE7 );
// 
// WPD_OBJECT_FORMAT_GIF
//   Image file format (Graphics Interchange Format) 
DEFINE_GUID(WPD_OBJECT_FORMAT_GIF, 0x38070000, 0xAE6C, 0x4804, 0x98, 0xBA, 0xC5, 0x7B, 0x46, 0x96, 0x5F, 0xE7 );
// 
// WPD_OBJECT_FORMAT_JFIF
//   Image file format (JPEG Interchange Format) 
DEFINE_GUID(WPD_OBJECT_FORMAT_JFIF, 0x38080000, 0xAE6C, 0x4804, 0x98, 0xBA, 0xC5, 0x7B, 0x46, 0x96, 0x5F, 0xE7 );
// 
// WPD_OBJECT_FORMAT_PCD
//   Image file format (PhotoCD Image Pac) 
DEFINE_GUID(WPD_OBJECT_FORMAT_PCD, 0x38090000, 0xAE6C, 0x4804, 0x98, 0xBA, 0xC5, 0x7B, 0x46, 0x96, 0x5F, 0xE7 );
// 
// WPD_OBJECT_FORMAT_PICT
//   Image file format (Quickdraw Image Format)
DEFINE_GUID(WPD_OBJECT_FORMAT_PICT, 0x380A0000, 0xAE6C, 0x4804, 0x98, 0xBA, 0xC5, 0x7B, 0x46, 0x96, 0x5F, 0xE7 );
// 
// WPD_OBJECT_FORMAT_PNG
//   Image file format (Portable Network Graphics) 
DEFINE_GUID(WPD_OBJECT_FORMAT_PNG, 0x380B0000, 0xAE6C, 0x4804, 0x98, 0xBA, 0xC5, 0x7B, 0x46, 0x96, 0x5F, 0xE7 );
// 
// WPD_OBJECT_FORMAT_TIFF
//   Image file format (Tag Image File Format) 
DEFINE_GUID(WPD_OBJECT_FORMAT_TIFF, 0x380D0000, 0xAE6C, 0x4804, 0x98, 0xBA, 0xC5, 0x7B, 0x46, 0x96, 0x5F, 0xE7 );
// 
// WPD_OBJECT_FORMAT_TIFFIT
//   Image file format (Tag Image File Format for Informational Technology) Graphic Arts 
DEFINE_GUID(WPD_OBJECT_FORMAT_TIFFIT, 0x380E0000, 0xAE6C, 0x4804, 0x98, 0xBA, 0xC5, 0x7B, 0x46, 0x96, 0x5F, 0xE7 );
// 
// WPD_OBJECT_FORMAT_JP2
//   Image file format (JPEG2000 Baseline File Format) 
DEFINE_GUID(WPD_OBJECT_FORMAT_JP2, 0x380F0000, 0xAE6C, 0x4804, 0x98, 0xBA, 0xC5, 0x7B, 0x46, 0x96, 0x5F, 0xE7 );
// 
// WPD_OBJECT_FORMAT_JPX
//   Image file format (JPEG2000 Extended File Format) 
DEFINE_GUID(WPD_OBJECT_FORMAT_JPX, 0x38100000, 0xAE6C, 0x4804, 0x98, 0xBA, 0xC5, 0x7B, 0x46, 0x96, 0x5F, 0xE7 );
// 
// WPD_OBJECT_FORMAT_WINDOWSIMAGEFORMAT
//   Image file format 
DEFINE_GUID(WPD_OBJECT_FORMAT_WINDOWSIMAGEFORMAT, 0xB8810000, 0xAE6C, 0x4804, 0x98, 0xBA, 0xC5, 0x7B, 0x46, 0x96, 0x5F, 0xE7 );
// 
// WPD_OBJECT_FORMAT_WMA
//   Audio file format (Windows Media Audio) 
DEFINE_GUID(WPD_OBJECT_FORMAT_WMA, 0xB9010000, 0xAE6C, 0x4804, 0x98, 0xBA, 0xC5, 0x7B, 0x46, 0x96, 0x5F, 0xE7 );
// 
// WPD_OBJECT_FORMAT_WMV
//   Video file format (Windows Media Video) 
DEFINE_GUID(WPD_OBJECT_FORMAT_WMV, 0xB9810000, 0xAE6C, 0x4804, 0x98, 0xBA, 0xC5, 0x7B, 0x46, 0x96, 0x5F, 0xE7 );
// 
// WPD_OBJECT_FORMAT_WPLPLAYLIST
//   Playlist file format 
DEFINE_GUID(WPD_OBJECT_FORMAT_WPLPLAYLIST, 0xBA100000, 0xAE6C, 0x4804, 0x98, 0xBA, 0xC5, 0x7B, 0x46, 0x96, 0x5F, 0xE7 );
// 
// WPD_OBJECT_FORMAT_M3UPLAYLIST
//   Playlist file format 
DEFINE_GUID(WPD_OBJECT_FORMAT_M3UPLAYLIST, 0xBA110000, 0xAE6C, 0x4804, 0x98, 0xBA, 0xC5, 0x7B, 0x46, 0x96, 0x5F, 0xE7 );
// 
// WPD_OBJECT_FORMAT_MPLPLAYLIST
//   Playlist file format 
DEFINE_GUID(WPD_OBJECT_FORMAT_MPLPLAYLIST, 0xBA120000, 0xAE6C, 0x4804, 0x98, 0xBA, 0xC5, 0x7B, 0x46, 0x96, 0x5F, 0xE7 );
// 
// WPD_OBJECT_FORMAT_ASXPLAYLIST
//   Playlist file format 
DEFINE_GUID(WPD_OBJECT_FORMAT_ASXPLAYLIST, 0xBA130000, 0xAE6C, 0x4804, 0x98, 0xBA, 0xC5, 0x7B, 0x46, 0x96, 0x5F, 0xE7 );
// 
// WPD_OBJECT_FORMAT_PLSPLAYLIST
//   Playlist file format 
DEFINE_GUID(WPD_OBJECT_FORMAT_PLSPLAYLIST, 0xBA140000, 0xAE6C, 0x4804, 0x98, 0xBA, 0xC5, 0x7B, 0x46, 0x96, 0x5F, 0xE7 );
// 
// WPD_OBJECT_FORMAT_ABSTRACT_CONTACT_GROUP
//   Generic format for contact group objects 
DEFINE_GUID(WPD_OBJECT_FORMAT_ABSTRACT_CONTACT_GROUP, 0xBA060000, 0xAE6C, 0x4804, 0x98, 0xBA, 0xC5, 0x7B, 0x46, 0x96, 0x5F, 0xE7 );
// 
// WPD_OBJECT_FORMAT_ABSTRACT_MEDIA_CAST
//   MediaCast file format 
DEFINE_GUID(WPD_OBJECT_FORMAT_ABSTRACT_MEDIA_CAST, 0xBA0B0000, 0xAE6C, 0x4804, 0x98, 0xBA, 0xC5, 0x7B, 0x46, 0x96, 0x5F, 0xE7 );
// 
// WPD_OBJECT_FORMAT_VCALENDAR1
//   VCALENDAR file format (VCALENDAR Version 1) 
DEFINE_GUID(WPD_OBJECT_FORMAT_VCALENDAR1, 0xBE020000, 0xAE6C, 0x4804, 0x98, 0xBA, 0xC5, 0x7B, 0x46, 0x96, 0x5F, 0xE7 );
// 
// WPD_OBJECT_FORMAT_VCARD2
//   VCARD file format (VCARD Version 2)
DEFINE_GUID(WPD_OBJECT_FORMAT_VCARD2, 0xBB820000, 0xAE6C, 0x4804, 0x98, 0xBA, 0xC5, 0x7B, 0x46, 0x96, 0x5F, 0xE7 );
// 
// WPD_OBJECT_FORMAT_VCARD3
//   VCARD file format (VCARD Version 3)
DEFINE_GUID(WPD_OBJECT_FORMAT_VCARD3, 0xBB830000, 0xAE6C, 0x4804, 0x98, 0xBA, 0xC5, 0x7B, 0x46, 0x96, 0x5F, 0xE7 );
// 
// WPD_OBJECT_FORMAT_ICON
//   Standard Windows ICON format 
DEFINE_GUID(WPD_OBJECT_FORMAT_ICON, 0x077232ED, 0x102C, 0x4638, 0x9C, 0x22, 0x83, 0xF1, 0x42, 0xBF, 0xC8, 0x22 );
// 
// WPD_OBJECT_FORMAT_XML
//   XML file format. 
DEFINE_GUID(WPD_OBJECT_FORMAT_XML, 0xBA820000, 0xAE6C, 0x4804, 0x98, 0xBA, 0xC5, 0x7B, 0x46, 0x96, 0x5F, 0xE7 );
// 
// WPD_OBJECT_FORMAT_AAC
//   Audio file format 
DEFINE_GUID(WPD_OBJECT_FORMAT_AAC, 0xB9030000, 0xAE6C, 0x4804, 0x98, 0xBA, 0xC5, 0x7B, 0x46, 0x96, 0x5F, 0xE7 );
// 
// WPD_OBJECT_FORMAT_AUDIBLE
//   Audio file format 
DEFINE_GUID(WPD_OBJECT_FORMAT_AUDIBLE, 0xB9040000, 0xAE6C, 0x4804, 0x98, 0xBA, 0xC5, 0x7B, 0x46, 0x96, 0x5F, 0xE7 );
// 
// WPD_OBJECT_FORMAT_FLAC
//   Audio file format 
DEFINE_GUID(WPD_OBJECT_FORMAT_FLAC, 0xB9060000, 0xAE6C, 0x4804, 0x98, 0xBA, 0xC5, 0x7B, 0x46, 0x96, 0x5F, 0xE7 );
// 
// WPD_OBJECT_FORMAT_OGG
//   Audio file format 
DEFINE_GUID(WPD_OBJECT_FORMAT_OGG, 0xB9020000, 0xAE6C, 0x4804, 0x98, 0xBA, 0xC5, 0x7B, 0x46, 0x96, 0x5F, 0xE7 );
// 
// WPD_OBJECT_FORMAT_MP4
//   Audio or Video file format 
DEFINE_GUID(WPD_OBJECT_FORMAT_MP4, 0xB9820000, 0xAE6C, 0x4804, 0x98, 0xBA, 0xC5, 0x7B, 0x46, 0x96, 0x5F, 0xE7 );
// 
// WPD_OBJECT_FORMAT_MP2
//   Audio or Video file format 
DEFINE_GUID(WPD_OBJECT_FORMAT_MP2, 0xB9830000, 0xAE6C, 0x4804, 0x98, 0xBA, 0xC5, 0x7B, 0x46, 0x96, 0x5F, 0xE7 );
// 
// WPD_OBJECT_FORMAT_MICROSOFT_WORD
//   Microsoft Office Word Document file format. 
DEFINE_GUID(WPD_OBJECT_FORMAT_MICROSOFT_WORD, 0xBA830000, 0xAE6C, 0x4804, 0x98, 0xBA, 0xC5, 0x7B, 0x46, 0x96, 0x5F, 0xE7 );
// 
// WPD_OBJECT_FORMAT_MHT_COMPILED_HTML
//   MHT Compiled HTML Document file format. 
DEFINE_GUID(WPD_OBJECT_FORMAT_MHT_COMPILED_HTML, 0xBA840000, 0xAE6C, 0x4804, 0x98, 0xBA, 0xC5, 0x7B, 0x46, 0x96, 0x5F, 0xE7 );
// 
// WPD_OBJECT_FORMAT_MICROSOFT_EXCEL
//   Microsoft Office Excel Document file format. 
DEFINE_GUID(WPD_OBJECT_FORMAT_MICROSOFT_EXCEL, 0xBA850000, 0xAE6C, 0x4804, 0x98, 0xBA, 0xC5, 0x7B, 0x46, 0x96, 0x5F, 0xE7 );
// 
// WPD_OBJECT_FORMAT_MICROSOFT_POWERPOINT
//   Microsoft Office PowerPoint Document file format. 
DEFINE_GUID(WPD_OBJECT_FORMAT_MICROSOFT_POWERPOINT, 0xBA860000, 0xAE6C, 0x4804, 0x98, 0xBA, 0xC5, 0x7B, 0x46, 0x96, 0x5F, 0xE7 );
// 
// WPD_OBJECT_FORMAT_NETWORK_ASSOCIATION
//   Network Association file format. 
DEFINE_GUID(WPD_OBJECT_FORMAT_NETWORK_ASSOCIATION, 0xB1020000, 0xAE6C, 0x4804, 0x98, 0xBA, 0xC5, 0x7B, 0x46, 0x96, 0x5F, 0xE7 );
// 
// WPD_OBJECT_FORMAT_X509V3CERTIFICATE
//   X.509 V3 Certificate file format. 
DEFINE_GUID(WPD_OBJECT_FORMAT_X509V3CERTIFICATE, 0xB1030000, 0xAE6C, 0x4804, 0x98, 0xBA, 0xC5, 0x7B, 0x46, 0x96, 0x5F, 0xE7 );
// 
// WPD_OBJECT_FORMAT_MICROSOFT_WFC
//   Windows Connect Now file format. 
DEFINE_GUID(WPD_OBJECT_FORMAT_MICROSOFT_WFC, 0xB1040000, 0xAE6C, 0x4804, 0x98, 0xBA, 0xC5, 0x7B, 0x46, 0x96, 0x5F, 0xE7 );
// 
// WPD_OBJECT_FORMAT_3GP
//   Audio or Video file format 
DEFINE_GUID(WPD_OBJECT_FORMAT_3GP, 0xB9840000, 0xAE6C, 0x4804, 0x98, 0xBA, 0xC5, 0x7B, 0x46, 0x96, 0x5F, 0xE7 );
// 
// WPD_OBJECT_FORMAT_ALL
//   This format is only valid as a parameter to API functions and driver commands. It should not be reported as a supported format by the driver. 
DEFINE_GUID(WPD_OBJECT_FORMAT_ALL, 0xC1F62EB2, 0x4BB3, 0x479C, 0x9C, 0xFA, 0x05, 0xB5, 0xF3, 0xA5, 0x7B, 0x22 );

/**************************************************************************** 
* This section defines all Resource keys. Resources are place-holders for 
* binary data. 
* 
****************************************************************************/ 
// 
// WPD_RESOURCE_DEFAULT 
//   Represents the entire object's data. There can be only one default resource on an object. 
DEFINE_PROPERTYKEY( WPD_RESOURCE_DEFAULT , 0xE81E79BE, 0x34F0, 0x41BF, 0xB5, 0x3F, 0xF1, 0xA0, 0x6A, 0xE8, 0x78, 0x42 , 0 ); 
// 
// WPD_RESOURCE_CONTACT_PHOTO 
//   Represents the contact's photo data. 
DEFINE_PROPERTYKEY( WPD_RESOURCE_CONTACT_PHOTO , 0x2C4D6803, 0x80EA, 0x4580, 0xAF, 0x9A, 0x5B, 0xE1, 0xA2, 0x3E, 0xDD, 0xCB , 0 ); 
// 
// WPD_RESOURCE_THUMBNAIL 
//   Represents the thumbnail data for an object. 
DEFINE_PROPERTYKEY( WPD_RESOURCE_THUMBNAIL , 0xC7C407BA, 0x98FA, 0x46B5, 0x99, 0x60, 0x23, 0xFE, 0xC1, 0x24, 0xCF, 0xDE , 0 ); 
// 
// WPD_RESOURCE_ICON 
//   Represents the icon data for an object. 
DEFINE_PROPERTYKEY( WPD_RESOURCE_ICON , 0xF195FED8, 0xAA28, 0x4EE3, 0xB1, 0x53, 0xE1, 0x82, 0xDD, 0x5E, 0xDC, 0x39 , 0 ); 
// 
// WPD_RESOURCE_AUDIO_CLIP 
//   Represents an audio sample data for an object. 
DEFINE_PROPERTYKEY( WPD_RESOURCE_AUDIO_CLIP , 0x3BC13982, 0x85B1, 0x48E0, 0x95, 0xA6, 0x8D, 0x3A, 0xD0, 0x6B, 0xE1, 0x17 , 0 ); 
// 
// WPD_RESOURCE_ALBUM_ART 
//   Represents the album artwork this media originated from. 
DEFINE_PROPERTYKEY( WPD_RESOURCE_ALBUM_ART , 0xF02AA354, 0x2300, 0x4E2D, 0xA1, 0xB9, 0x3B, 0x67, 0x30, 0xF7, 0xFA, 0x21 , 0 ); 
// 
// WPD_RESOURCE_GENERIC 
//   Represents an arbitrary binary blob associated with this object. 
DEFINE_PROPERTYKEY( WPD_RESOURCE_GENERIC , 0xB9B9F515, 0xBA70, 0x4647, 0x94, 0xDC, 0xFA, 0x49, 0x25, 0xE9, 0x5A, 0x07 , 0 ); 
// 
// WPD_RESOURCE_VIDEO_CLIP 
//   Represents a video sample for an object. 
DEFINE_PROPERTYKEY( WPD_RESOURCE_VIDEO_CLIP , 0xB566EE42, 0x6368, 0x4290, 0x86, 0x62, 0x70, 0x18, 0x2F, 0xB7, 0x9F, 0x20 , 0 ); 
// 
// WPD_RESOURCE_BRANDING_ART 
//   Represents the product branding artwork or logo for an object. This resource is typically found on, but not limited to the device object. 
DEFINE_PROPERTYKEY( WPD_RESOURCE_BRANDING_ART , 0xB633B1AE, 0x6CAF, 0x4A87, 0x95, 0x89, 0x22, 0xDE, 0xD6, 0xDD, 0x58, 0x99 , 0 ); 

/**************************************************************************** 
* This section defines all Commands, Parameters and Options associated with: 
* WPD_CATEGORY_NULL 
* 
* This category is used exclusively for the NULL property key define. 
****************************************************************************/ 
DEFINE_GUID( WPD_CATEGORY_NULL , 0x00000000, 0x0000, 0x0000, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 ); 

// 
// WPD_PROPERTY_NULL 
//   [ VT_EMPTY ] A NULL property key. 
DEFINE_PROPERTYKEY( WPD_PROPERTY_NULL , 0x00000000, 0x0000, 0x0000, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 , 0 ); 

/**************************************************************************** 
* This section defines all Commands, Parameters and Options associated with: 
* WPD_OBJECT_PROPERTIES_V1 
* 
* This category is for all common object properties. 
****************************************************************************/ 
DEFINE_GUID( WPD_OBJECT_PROPERTIES_V1 , 0xEF6B490D, 0x5CD8, 0x437A, 0xAF, 0xFC, 0xDA, 0x8B, 0x60, 0xEE, 0x4A, 0x3C ); 

// 
// WPD_OBJECT_ID 
//   [ VT_LPWSTR ] Uniquely identifies object on the Portable Device. 
DEFINE_PROPERTYKEY( WPD_OBJECT_ID , 0xEF6B490D, 0x5CD8, 0x437A, 0xAF, 0xFC, 0xDA, 0x8B, 0x60, 0xEE, 0x4A, 0x3C , 2 ); 
// 
// WPD_OBJECT_PARENT_ID 
//   [ VT_LPWSTR ] Object identifier indicating the parent object. 
DEFINE_PROPERTYKEY( WPD_OBJECT_PARENT_ID , 0xEF6B490D, 0x5CD8, 0x437A, 0xAF, 0xFC, 0xDA, 0x8B, 0x60, 0xEE, 0x4A, 0x3C , 3 ); 
// 
// WPD_OBJECT_NAME 
//   [ VT_LPWSTR ] The display name for this object. 
DEFINE_PROPERTYKEY( WPD_OBJECT_NAME , 0xEF6B490D, 0x5CD8, 0x437A, 0xAF, 0xFC, 0xDA, 0x8B, 0x60, 0xEE, 0x4A, 0x3C , 4 ); 
// 
// WPD_OBJECT_PERSISTENT_UNIQUE_ID 
//   [ VT_LPWSTR ] Uniquely identifies the object on the Portable Device, similar to WPD_OBJECT_ID, but this ID will not change between sessions. 
DEFINE_PROPERTYKEY( WPD_OBJECT_PERSISTENT_UNIQUE_ID , 0xEF6B490D, 0x5CD8, 0x437A, 0xAF, 0xFC, 0xDA, 0x8B, 0x60, 0xEE, 0x4A, 0x3C , 5 ); 
// 
// WPD_OBJECT_FORMAT 
//   [ VT_CLSID ] Indicates the format of the object's data. 
DEFINE_PROPERTYKEY( WPD_OBJECT_FORMAT , 0xEF6B490D, 0x5CD8, 0x437A, 0xAF, 0xFC, 0xDA, 0x8B, 0x60, 0xEE, 0x4A, 0x3C , 6 ); 
// 
// WPD_OBJECT_CONTENT_TYPE 
//   [ VT_CLSID ] The abstract type for the object content, indicating the kinds of properties and data that may be supported on the object. 
DEFINE_PROPERTYKEY( WPD_OBJECT_CONTENT_TYPE , 0xEF6B490D, 0x5CD8, 0x437A, 0xAF, 0xFC, 0xDA, 0x8B, 0x60, 0xEE, 0x4A, 0x3C , 7 ); 
// 
// WPD_OBJECT_ISHIDDEN 
//   [ VT_BOOL ] Indicates whether the object should be hidden. 
DEFINE_PROPERTYKEY( WPD_OBJECT_ISHIDDEN , 0xEF6B490D, 0x5CD8, 0x437A, 0xAF, 0xFC, 0xDA, 0x8B, 0x60, 0xEE, 0x4A, 0x3C , 9 ); 
// 
// WPD_OBJECT_ISSYSTEM 
//   [ VT_BOOL ] Indicates whether the object represents system data. 
DEFINE_PROPERTYKEY( WPD_OBJECT_ISSYSTEM , 0xEF6B490D, 0x5CD8, 0x437A, 0xAF, 0xFC, 0xDA, 0x8B, 0x60, 0xEE, 0x4A, 0x3C , 10 ); 
// 
// WPD_OBJECT_SIZE 
//   [ VT_UI8 ] The size of the object data. 
DEFINE_PROPERTYKEY( WPD_OBJECT_SIZE , 0xEF6B490D, 0x5CD8, 0x437A, 0xAF, 0xFC, 0xDA, 0x8B, 0x60, 0xEE, 0x4A, 0x3C , 11 ); 
// 
// WPD_OBJECT_ORIGINAL_FILE_NAME 
//   [ VT_LPWSTR ] Contains the name of the file this object represents. 
DEFINE_PROPERTYKEY( WPD_OBJECT_ORIGINAL_FILE_NAME , 0xEF6B490D, 0x5CD8, 0x437A, 0xAF, 0xFC, 0xDA, 0x8B, 0x60, 0xEE, 0x4A, 0x3C , 12 ); 
// 
// WPD_OBJECT_NON_CONSUMABLE 
//   [ VT_BOOL ] This property determines whether or not this object is intended to be understood by the device, or whether it has been placed on the device just for storage. 
DEFINE_PROPERTYKEY( WPD_OBJECT_NON_CONSUMABLE , 0xEF6B490D, 0x5CD8, 0x437A, 0xAF, 0xFC, 0xDA, 0x8B, 0x60, 0xEE, 0x4A, 0x3C , 13 ); 
// 
// WPD_OBJECT_REFERENCES 
//   [ VT_UNKNOWN ] IPortableDevicePropVariantCollection of type VT_LPWSTR indicating a list of ObjectIDs. 
DEFINE_PROPERTYKEY( WPD_OBJECT_REFERENCES , 0xEF6B490D, 0x5CD8, 0x437A, 0xAF, 0xFC, 0xDA, 0x8B, 0x60, 0xEE, 0x4A, 0x3C , 14 ); 
// 
// WPD_OBJECT_KEYWORDS 
//   [ VT_LPWSTR ] String containing a list of keywords associated with this object. 
DEFINE_PROPERTYKEY( WPD_OBJECT_KEYWORDS , 0xEF6B490D, 0x5CD8, 0x437A, 0xAF, 0xFC, 0xDA, 0x8B, 0x60, 0xEE, 0x4A, 0x3C , 15 ); 
// 
// WPD_OBJECT_SYNC_ID 
//   [ VT_LPWSTR ] Opaque string set by client to retain state between sessions without retaining a catalogue of connected device content. 
DEFINE_PROPERTYKEY( WPD_OBJECT_SYNC_ID , 0xEF6B490D, 0x5CD8, 0x437A, 0xAF, 0xFC, 0xDA, 0x8B, 0x60, 0xEE, 0x4A, 0x3C , 16 ); 
// 
// WPD_OBJECT_IS_DRM_PROTECTED 
//   [ VT_BOOL ] Indicates whether the media data is DRM protected. 
DEFINE_PROPERTYKEY( WPD_OBJECT_IS_DRM_PROTECTED , 0xEF6B490D, 0x5CD8, 0x437A, 0xAF, 0xFC, 0xDA, 0x8B, 0x60, 0xEE, 0x4A, 0x3C , 17 ); 
// 
// WPD_OBJECT_DATE_CREATED 
//   [ VT_DATE ] Indicates the date and time the object was created on the device. 
DEFINE_PROPERTYKEY( WPD_OBJECT_DATE_CREATED , 0xEF6B490D, 0x5CD8, 0x437A, 0xAF, 0xFC, 0xDA, 0x8B, 0x60, 0xEE, 0x4A, 0x3C , 18 ); 
// 
// WPD_OBJECT_DATE_MODIFIED 
//   [ VT_DATE ] Indicates the date and time the object was modified on the device. 
DEFINE_PROPERTYKEY( WPD_OBJECT_DATE_MODIFIED , 0xEF6B490D, 0x5CD8, 0x437A, 0xAF, 0xFC, 0xDA, 0x8B, 0x60, 0xEE, 0x4A, 0x3C , 19 ); 
// 
// WPD_OBJECT_DATE_AUTHORED 
//   [ VT_DATE ] Indicates the date and time the object was authored (e.g. for music, this would be the date the music was recorded). 
DEFINE_PROPERTYKEY( WPD_OBJECT_DATE_AUTHORED , 0xEF6B490D, 0x5CD8, 0x437A, 0xAF, 0xFC, 0xDA, 0x8B, 0x60, 0xEE, 0x4A, 0x3C , 20 ); 
// 
// WPD_OBJECT_BACK_REFERENCES 
//   [ VT_LPWSTR ] IPortableDevicePropVariantCollection of type VT_LPWSTR indicating a list of ObjectIDs. 
DEFINE_PROPERTYKEY( WPD_OBJECT_BACK_REFERENCES , 0xEF6B490D, 0x5CD8, 0x437A, 0xAF, 0xFC, 0xDA, 0x8B, 0x60, 0xEE, 0x4A, 0x3C , 21 ); 
// 
// WPD_OBJECT_CONTAINER_FUNCTIONAL_OBJECT_ID 
//   [ VT_LPWSTR ] Indicates the Object ID of the closest functional object ancestor. For example, objects that represent files/folders under a Storage functional object, will have this property set to the object ID of the storage functional object. 
DEFINE_PROPERTYKEY( WPD_OBJECT_CONTAINER_FUNCTIONAL_OBJECT_ID , 0xEF6B490D, 0x5CD8, 0x437A, 0xAF, 0xFC, 0xDA, 0x8B, 0x60, 0xEE, 0x4A, 0x3C , 23 ); 
// 
// WPD_OBJECT_GENERATE_THUMBNAIL_FROM_RESOURCE 
//   [ VT_BOOL ] Indicates whether the thumbnail for this object should be generated from the default resource. 
DEFINE_PROPERTYKEY( WPD_OBJECT_GENERATE_THUMBNAIL_FROM_RESOURCE , 0xEF6B490D, 0x5CD8, 0x437A, 0xAF, 0xFC, 0xDA, 0x8B, 0x60, 0xEE, 0x4A, 0x3C , 24 ); 
// 
// WPD_OBJECT_HINT_LOCATION_DISPLAY_NAME 
//   [ VT_LPWSTR ] If this object appears as a hint location, this property indicates the hint-specific name to display instead of the object name. 
DEFINE_PROPERTYKEY( WPD_OBJECT_HINT_LOCATION_DISPLAY_NAME , 0xEF6B490D, 0x5CD8, 0x437A, 0xAF, 0xFC, 0xDA, 0x8B, 0x60, 0xEE, 0x4A, 0x3C , 25 ); 
// 
// WPD_OBJECT_CAN_DELETE 
//   [ VT_BOOL ] Indicates whether the object can be deleted, or not. 
DEFINE_PROPERTYKEY( WPD_OBJECT_CAN_DELETE , 0xEF6B490D, 0x5CD8, 0x437A, 0xAF, 0xFC, 0xDA, 0x8B, 0x60, 0xEE, 0x4A, 0x3C , 26 ); 

/**************************************************************************** 
* This section defines all Commands, Parameters and Options associated with: 
* WPD_FUNCTIONAL_OBJECT_PROPERTIES_V1 
* 
* This category is for properties common to all functional objects. 
****************************************************************************/ 
DEFINE_GUID( WPD_FUNCTIONAL_OBJECT_PROPERTIES_V1 , 0x8F052D93, 0xABCA, 0x4FC5, 0xA5, 0xAC, 0xB0, 0x1D, 0xF4, 0xDB, 0xE5, 0x98 ); 

// 
// WPD_FUNCTIONAL_OBJECT_CATEGORY 
//   [ VT_CLSID ] Indicates the object's functional category. 
DEFINE_PROPERTYKEY( WPD_FUNCTIONAL_OBJECT_CATEGORY , 0x8F052D93, 0xABCA, 0x4FC5, 0xA5, 0xAC, 0xB0, 0x1D, 0xF4, 0xDB, 0xE5, 0x98 , 2 ); 

/**************************************************************************** 
* This section defines all Commands, Parameters and Options associated with: 
* WPD_FOLDER_OBJECT_PROPERTIES_V1 
* 
* This category is for properties common to all folder objects. 
****************************************************************************/ 
DEFINE_GUID( WPD_FOLDER_OBJECT_PROPERTIES_V1 , 0x7E9A7ABF, 0xE568, 0x4B34, 0xAA, 0x2F, 0x13, 0xBB, 0x12, 0xAB, 0x17, 0x7D ); 

// 
// WPD_FOLDER_CONTENT_TYPES_ALLOWED 
//   [ VT_UNKNOWN ] Indicates the subset of content types that can be created in this folder directly (i.e. children may have different restrictions). 
DEFINE_PROPERTYKEY( WPD_FOLDER_CONTENT_TYPES_ALLOWED , 0x7E9A7ABF, 0xE568, 0x4B34, 0xAA, 0x2F, 0x13, 0xBB, 0x12, 0xAB, 0x17, 0x7D , 2 ); 

/**************************************************************************** 
* This section defines all Commands, Parameters and Options associated with: 
* WPD_IMAGE_OBJECT_PROPERTIES_V1 
* 
* This category is for properties common to all image objects. 
****************************************************************************/ 
DEFINE_GUID( WPD_IMAGE_OBJECT_PROPERTIES_V1 , 0x63D64908, 0x9FA1, 0x479F, 0x85, 0xBA, 0x99, 0x52, 0x21, 0x64, 0x47, 0xDB ); 

// 
// WPD_IMAGE_BITDEPTH 
//   [ VT_UI4 ] Indicates the bitdepth of an image 
DEFINE_PROPERTYKEY( WPD_IMAGE_BITDEPTH , 0x63D64908, 0x9FA1, 0x479F, 0x85, 0xBA, 0x99, 0x52, 0x21, 0x64, 0x47, 0xDB , 3 ); 
// 
// WPD_IMAGE_CROPPED_STATUS 
//   [ VT_UI4 ] Signals whether the file has been cropped. 
DEFINE_PROPERTYKEY( WPD_IMAGE_CROPPED_STATUS , 0x63D64908, 0x9FA1, 0x479F, 0x85, 0xBA, 0x99, 0x52, 0x21, 0x64, 0x47, 0xDB , 4 ); 
// 
// WPD_IMAGE_COLOR_CORRECTED_STATUS 
//   [ VT_UI4 ] Signals whether the file has been color corrected. 
DEFINE_PROPERTYKEY( WPD_IMAGE_COLOR_CORRECTED_STATUS , 0x63D64908, 0x9FA1, 0x479F, 0x85, 0xBA, 0x99, 0x52, 0x21, 0x64, 0x47, 0xDB , 5 ); 
// 
// WPD_IMAGE_FNUMBER 
//   [ VT_UI4 ] Identifies the aperture setting of the lens when this image was captured. 
DEFINE_PROPERTYKEY( WPD_IMAGE_FNUMBER , 0x63D64908, 0x9FA1, 0x479F, 0x85, 0xBA, 0x99, 0x52, 0x21, 0x64, 0x47, 0xDB , 6 ); 
// 
// WPD_IMAGE_EXPOSURE_TIME 
//   [ VT_UI4 ] Identifies the shutter speed of the device when this image was captured. 
DEFINE_PROPERTYKEY( WPD_IMAGE_EXPOSURE_TIME , 0x63D64908, 0x9FA1, 0x479F, 0x85, 0xBA, 0x99, 0x52, 0x21, 0x64, 0x47, 0xDB , 7 ); 
// 
// WPD_IMAGE_EXPOSURE_INDEX 
//   [ VT_UI4 ] Identifies the emulation of film speed settings when this image was captured. 
DEFINE_PROPERTYKEY( WPD_IMAGE_EXPOSURE_INDEX , 0x63D64908, 0x9FA1, 0x479F, 0x85, 0xBA, 0x99, 0x52, 0x21, 0x64, 0x47, 0xDB , 8 ); 

/**************************************************************************** 
* This section defines all Commands, Parameters and Options associated with: 
* WPD_DOCUMENT_OBJECT_PROPERTIES_V1 
* 
* This category is for properties common to all document objects. 
****************************************************************************/ 
DEFINE_GUID( WPD_DOCUMENT_OBJECT_PROPERTIES_V1 , 0x0B110203, 0xEB95, 0x4F02, 0x93, 0xE0, 0x97, 0xC6, 0x31, 0x49, 0x3A, 0xD5 ); 


/**************************************************************************** 
* This section defines all Commands, Parameters and Options associated with: 
* WPD_MEDIA_PROPERTIES_V1 
* 
* This category is for properties common to media objects (e.g. audio and video). 
****************************************************************************/ 
DEFINE_GUID( WPD_MEDIA_PROPERTIES_V1 , 0x2ED8BA05, 0x0AD3, 0x42DC, 0xB0, 0xD0, 0xBC, 0x95, 0xAC, 0x39, 0x6A, 0xC8 ); 

// 
// WPD_MEDIA_TOTAL_BITRATE 
//   [ VT_UI4 ] The total number of bits that one second will consume. 
DEFINE_PROPERTYKEY( WPD_MEDIA_TOTAL_BITRATE , 0x2ED8BA05, 0x0AD3, 0x42DC, 0xB0, 0xD0, 0xBC, 0x95, 0xAC, 0x39, 0x6A, 0xC8 , 2 ); 
// 
// WPD_MEDIA_BITRATE_TYPE 
//   [ VT_UI4 ] Further qualifies the bitrate of audio or video data. 
DEFINE_PROPERTYKEY( WPD_MEDIA_BITRATE_TYPE , 0x2ED8BA05, 0x0AD3, 0x42DC, 0xB0, 0xD0, 0xBC, 0x95, 0xAC, 0x39, 0x6A, 0xC8 , 3 ); 
// 
// WPD_MEDIA_COPYRIGHT 
//   [ VT_LPWSTR ] Indicates the copyright information. 
DEFINE_PROPERTYKEY( WPD_MEDIA_COPYRIGHT , 0x2ED8BA05, 0x0AD3, 0x42DC, 0xB0, 0xD0, 0xBC, 0x95, 0xAC, 0x39, 0x6A, 0xC8 , 4 ); 
// 
// WPD_MEDIA_SUBSCRIPTION_CONTENT_ID 
//   [ VT_LPWSTR ] Provides additional information to identify a piece of content relative to an online subscription service. 
DEFINE_PROPERTYKEY( WPD_MEDIA_SUBSCRIPTION_CONTENT_ID , 0x2ED8BA05, 0x0AD3, 0x42DC, 0xB0, 0xD0, 0xBC, 0x95, 0xAC, 0x39, 0x6A, 0xC8 , 5 ); 
// 
// WPD_MEDIA_USE_COUNT 
//   [ VT_UI4 ] Indicates the total number of times this media has been played or viewed on the device. 
DEFINE_PROPERTYKEY( WPD_MEDIA_USE_COUNT , 0x2ED8BA05, 0x0AD3, 0x42DC, 0xB0, 0xD0, 0xBC, 0x95, 0xAC, 0x39, 0x6A, 0xC8 , 6 ); 
// 
// WPD_MEDIA_SKIP_COUNT 
//   [ VT_UI4 ] Indicates the total number of times this media was setup to be played or viewed but was manually skipped by the user. 
DEFINE_PROPERTYKEY( WPD_MEDIA_SKIP_COUNT , 0x2ED8BA05, 0x0AD3, 0x42DC, 0xB0, 0xD0, 0xBC, 0x95, 0xAC, 0x39, 0x6A, 0xC8 , 7 ); 
// 
// WPD_MEDIA_LAST_ACCESSED_TIME 
//   [ VT_DATE ] Indicates the date and time the media was last accessed on the device. 
DEFINE_PROPERTYKEY( WPD_MEDIA_LAST_ACCESSED_TIME , 0x2ED8BA05, 0x0AD3, 0x42DC, 0xB0, 0xD0, 0xBC, 0x95, 0xAC, 0x39, 0x6A, 0xC8 , 8 ); 
// 
// WPD_MEDIA_PARENTAL_RATING 
//   [ VT_LPWSTR ] Indicates the parental rating of the media file. 
DEFINE_PROPERTYKEY( WPD_MEDIA_PARENTAL_RATING , 0x2ED8BA05, 0x0AD3, 0x42DC, 0xB0, 0xD0, 0xBC, 0x95, 0xAC, 0x39, 0x6A, 0xC8 , 9 ); 
// 
// WPD_MEDIA_META_GENRE 
//   [ VT_UI4 ] Further qualifies a piece of media in a contextual way. 
DEFINE_PROPERTYKEY( WPD_MEDIA_META_GENRE , 0x2ED8BA05, 0x0AD3, 0x42DC, 0xB0, 0xD0, 0xBC, 0x95, 0xAC, 0x39, 0x6A, 0xC8 , 10 ); 
// 
// WPD_MEDIA_COMPOSER 
//   [ VT_LPWSTR ] Identifies the composer when the composer is not the artist who performed it. 
DEFINE_PROPERTYKEY( WPD_MEDIA_COMPOSER , 0x2ED8BA05, 0x0AD3, 0x42DC, 0xB0, 0xD0, 0xBC, 0x95, 0xAC, 0x39, 0x6A, 0xC8 , 11 ); 
// 
// WPD_MEDIA_EFFECTIVE_RATING 
//   [ VT_UI4 ] Contains an assigned rating for media not set by the user, but is generated based upon usage statistics. 
DEFINE_PROPERTYKEY( WPD_MEDIA_EFFECTIVE_RATING , 0x2ED8BA05, 0x0AD3, 0x42DC, 0xB0, 0xD0, 0xBC, 0x95, 0xAC, 0x39, 0x6A, 0xC8 , 12 ); 
// 
// WPD_MEDIA_SUB_TITLE 
//   [ VT_LPWSTR ] Further qualifies the title when the title is ambiguous or general. 
DEFINE_PROPERTYKEY( WPD_MEDIA_SUB_TITLE , 0x2ED8BA05, 0x0AD3, 0x42DC, 0xB0, 0xD0, 0xBC, 0x95, 0xAC, 0x39, 0x6A, 0xC8 , 13 ); 
// 
// WPD_MEDIA_RELEASE_DATE 
//   [ VT_DATE ] Indicates when the media was released. 
DEFINE_PROPERTYKEY( WPD_MEDIA_RELEASE_DATE , 0x2ED8BA05, 0x0AD3, 0x42DC, 0xB0, 0xD0, 0xBC, 0x95, 0xAC, 0x39, 0x6A, 0xC8 , 14 ); 
// 
// WPD_MEDIA_SAMPLE_RATE 
//   [ VT_UI4 ] Indicates the number of times media selection was sampled per second during encoding. 
DEFINE_PROPERTYKEY( WPD_MEDIA_SAMPLE_RATE , 0x2ED8BA05, 0x0AD3, 0x42DC, 0xB0, 0xD0, 0xBC, 0x95, 0xAC, 0x39, 0x6A, 0xC8 , 15 ); 
// 
// WPD_MEDIA_STAR_RATING 
//   [ VT_UI4 ] Indicates the star rating for this media. 
DEFINE_PROPERTYKEY( WPD_MEDIA_STAR_RATING , 0x2ED8BA05, 0x0AD3, 0x42DC, 0xB0, 0xD0, 0xBC, 0x95, 0xAC, 0x39, 0x6A, 0xC8 , 16 ); 
// 
// WPD_MEDIA_USER_EFFECTIVE_RATING 
//   [ VT_UI4 ] Indicates the rating for this media. 
DEFINE_PROPERTYKEY( WPD_MEDIA_USER_EFFECTIVE_RATING , 0x2ED8BA05, 0x0AD3, 0x42DC, 0xB0, 0xD0, 0xBC, 0x95, 0xAC, 0x39, 0x6A, 0xC8 , 17 ); 
// 
// WPD_MEDIA_TITLE 
//   [ VT_LPWSTR ] Indicates the title of this media. 
DEFINE_PROPERTYKEY( WPD_MEDIA_TITLE , 0x2ED8BA05, 0x0AD3, 0x42DC, 0xB0, 0xD0, 0xBC, 0x95, 0xAC, 0x39, 0x6A, 0xC8 , 18 ); 
// 
// WPD_MEDIA_DURATION 
//   [ VT_UI8 ] Indicates the duration of this media in milliseconds. 
DEFINE_PROPERTYKEY( WPD_MEDIA_DURATION , 0x2ED8BA05, 0x0AD3, 0x42DC, 0xB0, 0xD0, 0xBC, 0x95, 0xAC, 0x39, 0x6A, 0xC8 , 19 ); 
// 
// WPD_MEDIA_BUY_NOW 
//   [ VT_BOOL ] TBD 
DEFINE_PROPERTYKEY( WPD_MEDIA_BUY_NOW , 0x2ED8BA05, 0x0AD3, 0x42DC, 0xB0, 0xD0, 0xBC, 0x95, 0xAC, 0x39, 0x6A, 0xC8 , 20 ); 
// 
// WPD_MEDIA_ENCODING_PROFILE 
//   [ VT_LPWSTR ] Media codecs may be encoded in accordance with a profile, which defines a particular encoding algorithm or optimization process. 
DEFINE_PROPERTYKEY( WPD_MEDIA_ENCODING_PROFILE , 0x2ED8BA05, 0x0AD3, 0x42DC, 0xB0, 0xD0, 0xBC, 0x95, 0xAC, 0x39, 0x6A, 0xC8 , 21 ); 
// 
// WPD_MEDIA_WIDTH 
//   [ VT_UI4 ] Indicates the width of an object in pixels 
DEFINE_PROPERTYKEY( WPD_MEDIA_WIDTH , 0x2ED8BA05, 0x0AD3, 0x42DC, 0xB0, 0xD0, 0xBC, 0x95, 0xAC, 0x39, 0x6A, 0xC8 , 22 ); 
// 
// WPD_MEDIA_HEIGHT 
//   [ VT_UI4 ] Indicates the height of an object in pixels 
DEFINE_PROPERTYKEY( WPD_MEDIA_HEIGHT , 0x2ED8BA05, 0x0AD3, 0x42DC, 0xB0, 0xD0, 0xBC, 0x95, 0xAC, 0x39, 0x6A, 0xC8 , 23 ); 
// 
// WPD_MEDIA_ARTIST 
//   [ VT_LPWSTR ] Indicates the artist for this media. 
DEFINE_PROPERTYKEY( WPD_MEDIA_ARTIST , 0x2ED8BA05, 0x0AD3, 0x42DC, 0xB0, 0xD0, 0xBC, 0x95, 0xAC, 0x39, 0x6A, 0xC8 , 24 ); 
// 
// WPD_MEDIA_ALBUM_ARTIST 
//   [ VT_LPWSTR ] Indicates the artist of the entire album rather than for a particular track. 
DEFINE_PROPERTYKEY( WPD_MEDIA_ALBUM_ARTIST , 0x2ED8BA05, 0x0AD3, 0x42DC, 0xB0, 0xD0, 0xBC, 0x95, 0xAC, 0x39, 0x6A, 0xC8 , 25 ); 
// 
// WPD_MEDIA_OWNER 
//   [ VT_LPWSTR ] Indicates the e-mail address of the owner for this media. 
DEFINE_PROPERTYKEY( WPD_MEDIA_OWNER , 0x2ED8BA05, 0x0AD3, 0x42DC, 0xB0, 0xD0, 0xBC, 0x95, 0xAC, 0x39, 0x6A, 0xC8 , 26 ); 
// 
// WPD_MEDIA_MANAGING_EDITOR 
//   [ VT_LPWSTR ] Indicates the e-mail address of the managing editor for this media. 
DEFINE_PROPERTYKEY( WPD_MEDIA_MANAGING_EDITOR , 0x2ED8BA05, 0x0AD3, 0x42DC, 0xB0, 0xD0, 0xBC, 0x95, 0xAC, 0x39, 0x6A, 0xC8 , 27 ); 
// 
// WPD_MEDIA_WEBMASTER 
//   [ VT_LPWSTR ] Indicates the e-mail address of the Webmaster for this media. 
DEFINE_PROPERTYKEY( WPD_MEDIA_WEBMASTER , 0x2ED8BA05, 0x0AD3, 0x42DC, 0xB0, 0xD0, 0xBC, 0x95, 0xAC, 0x39, 0x6A, 0xC8 , 28 ); 
// 
// WPD_MEDIA_SOURCE_URL 
//   [ VT_LPWSTR ] Identifies the source URL for this object. 
DEFINE_PROPERTYKEY( WPD_MEDIA_SOURCE_URL , 0x2ED8BA05, 0x0AD3, 0x42DC, 0xB0, 0xD0, 0xBC, 0x95, 0xAC, 0x39, 0x6A, 0xC8 , 29 ); 
// 
// WPD_MEDIA_DESTINATION_URL 
//   [ VT_LPWSTR ] Identifies the URL that an object is linked to if a user clicks on it. 
DEFINE_PROPERTYKEY( WPD_MEDIA_DESTINATION_URL , 0x2ED8BA05, 0x0AD3, 0x42DC, 0xB0, 0xD0, 0xBC, 0x95, 0xAC, 0x39, 0x6A, 0xC8 , 30 ); 
// 
// WPD_MEDIA_DESCRIPTION 
//   [ VT_LPWSTR ] Contains a description of the media content for this object. 
DEFINE_PROPERTYKEY( WPD_MEDIA_DESCRIPTION , 0x2ED8BA05, 0x0AD3, 0x42DC, 0xB0, 0xD0, 0xBC, 0x95, 0xAC, 0x39, 0x6A, 0xC8 , 31 ); 
// 
// WPD_MEDIA_GENRE 
//   [ VT_LPWSTR ] A text field indicating the genre this media belongs to. 
DEFINE_PROPERTYKEY( WPD_MEDIA_GENRE , 0x2ED8BA05, 0x0AD3, 0x42DC, 0xB0, 0xD0, 0xBC, 0x95, 0xAC, 0x39, 0x6A, 0xC8 , 32 ); 
// 
// WPD_MEDIA_TIME_BOOKMARK 
//   [ VT_UI8 ] Indicates a bookmark (in milliseconds) of the last position played or viewed on media that have duration. 
DEFINE_PROPERTYKEY( WPD_MEDIA_TIME_BOOKMARK , 0x2ED8BA05, 0x0AD3, 0x42DC, 0xB0, 0xD0, 0xBC, 0x95, 0xAC, 0x39, 0x6A, 0xC8 , 33 ); 
// 
// WPD_MEDIA_OBJECT_BOOKMARK 
//   [ VT_LPWSTR ] Indicates a WPD_OBJECT_ID of the last object viewed or played for those objects that refer to a list of objects (such as playlists or media casts). 
DEFINE_PROPERTYKEY( WPD_MEDIA_OBJECT_BOOKMARK , 0x2ED8BA05, 0x0AD3, 0x42DC, 0xB0, 0xD0, 0xBC, 0x95, 0xAC, 0x39, 0x6A, 0xC8 , 34 ); 
// 
// WPD_MEDIA_LAST_BUILD_DATE 
//   [ VT_DATE ] Indicates the last time a series in a media cast was changed or edited. 
DEFINE_PROPERTYKEY( WPD_MEDIA_LAST_BUILD_DATE , 0x2ED8BA05, 0x0AD3, 0x42DC, 0xB0, 0xD0, 0xBC, 0x95, 0xAC, 0x39, 0x6A, 0xC8 , 35 ); 
// 
// WPD_MEDIA_BYTE_BOOKMARK 
//   [ VT_UI8 ] Indicates a bookmark (as a zero-based byte offset) of the last position played or viewed on this media object. 
DEFINE_PROPERTYKEY( WPD_MEDIA_BYTE_BOOKMARK , 0x2ED8BA05, 0x0AD3, 0x42DC, 0xB0, 0xD0, 0xBC, 0x95, 0xAC, 0x39, 0x6A, 0xC8 , 36 ); 
// 
// WPD_MEDIA_TIME_TO_LIVE 
//   [ VT_UI8 ] It is the number of minutes that indicates how long a channel can be cached before refreshing from the source. Applies to WPD_CONTENT_TYPE_MEDIA_CAST objects. 
DEFINE_PROPERTYKEY( WPD_MEDIA_TIME_TO_LIVE , 0x2ED8BA05, 0x0AD3, 0x42DC, 0xB0, 0xD0, 0xBC, 0x95, 0xAC, 0x39, 0x6A, 0xC8 , 37 ); 
// 
// WPD_MEDIA_GUID 
//   [ VT_LPWSTR ] A text field indicating the GUID of this media. 
DEFINE_PROPERTYKEY( WPD_MEDIA_GUID , 0x2ED8BA05, 0x0AD3, 0x42DC, 0xB0, 0xD0, 0xBC, 0x95, 0xAC, 0x39, 0x6A, 0xC8 , 38 ); 
// 
// WPD_MEDIA_SUB_DESCRIPTION 
//   [ VT_LPWSTR ] Contains a sub description of the media content for this object. 
DEFINE_PROPERTYKEY( WPD_MEDIA_SUB_DESCRIPTION , 0x2ED8BA05, 0x0AD3, 0x42DC, 0xB0, 0xD0, 0xBC, 0x95, 0xAC, 0x39, 0x6A, 0xC8 , 39 ); 

/**************************************************************************** 
* This section defines all Commands, Parameters and Options associated with: 
* WPD_CONTACT_OBJECT_PROPERTIES_V1 
* 
* This category is for properties common to all contact objects. 
****************************************************************************/ 
DEFINE_GUID( WPD_CONTACT_OBJECT_PROPERTIES_V1 , 0xFBD4FDAB, 0x987D, 0x4777, 0xB3, 0xF9, 0x72, 0x61, 0x85, 0xA9, 0x31, 0x2B ); 

// 
// WPD_CONTACT_DISPLAY_NAME 
//   [ VT_LPWSTR ] Indicates the display name of the contact (e.g "John Doe")
DEFINE_PROPERTYKEY( WPD_CONTACT_DISPLAY_NAME , 0xFBD4FDAB, 0x987D, 0x4777, 0xB3, 0xF9, 0x72, 0x61, 0x85, 0xA9, 0x31, 0x2B , 2 ); 
// 
// WPD_CONTACT_FIRST_NAME 
//   [ VT_LPWSTR ] Indicates the first name of the contact (e.g. "John")
DEFINE_PROPERTYKEY( WPD_CONTACT_FIRST_NAME , 0xFBD4FDAB, 0x987D, 0x4777, 0xB3, 0xF9, 0x72, 0x61, 0x85, 0xA9, 0x31, 0x2B , 3 ); 
// 
// WPD_CONTACT_MIDDLE_NAMES 
//   [ VT_LPWSTR ] Indicates the middle name of the contact 
DEFINE_PROPERTYKEY( WPD_CONTACT_MIDDLE_NAMES , 0xFBD4FDAB, 0x987D, 0x4777, 0xB3, 0xF9, 0x72, 0x61, 0x85, 0xA9, 0x31, 0x2B , 4 ); 
// 
// WPD_CONTACT_LAST_NAME 
//   [ VT_LPWSTR ] Indicates the last name of the contact (e.g. "Doe")
DEFINE_PROPERTYKEY( WPD_CONTACT_LAST_NAME , 0xFBD4FDAB, 0x987D, 0x4777, 0xB3, 0xF9, 0x72, 0x61, 0x85, 0xA9, 0x31, 0x2B , 5 ); 
// 
// WPD_CONTACT_PREFIX 
//   [ VT_LPWSTR ] Indicates the prefix of the name of the contact (e.g. "Mr.")
DEFINE_PROPERTYKEY( WPD_CONTACT_PREFIX , 0xFBD4FDAB, 0x987D, 0x4777, 0xB3, 0xF9, 0x72, 0x61, 0x85, 0xA9, 0x31, 0x2B , 6 ); 
// 
// WPD_CONTACT_SUFFIX 
//   [ VT_LPWSTR ] Indicates the suffix of the name of the contact (e.g. "Jr.")
DEFINE_PROPERTYKEY( WPD_CONTACT_SUFFIX , 0xFBD4FDAB, 0x987D, 0x4777, 0xB3, 0xF9, 0x72, 0x61, 0x85, 0xA9, 0x31, 0x2B , 7 ); 
// 
// WPD_CONTACT_PHONETIC_FIRST_NAME 
//   [ VT_LPWSTR ] The phonetic guide for pronouncing the contact's first name. 
DEFINE_PROPERTYKEY( WPD_CONTACT_PHONETIC_FIRST_NAME , 0xFBD4FDAB, 0x987D, 0x4777, 0xB3, 0xF9, 0x72, 0x61, 0x85, 0xA9, 0x31, 0x2B , 8 ); 
// 
// WPD_CONTACT_PHONETIC_LAST_NAME 
//   [ VT_LPWSTR ] The phonetic guide for pronouncing the contact's last name. 
DEFINE_PROPERTYKEY( WPD_CONTACT_PHONETIC_LAST_NAME , 0xFBD4FDAB, 0x987D, 0x4777, 0xB3, 0xF9, 0x72, 0x61, 0x85, 0xA9, 0x31, 0x2B , 9 ); 
// 
// WPD_CONTACT_PERSONAL_FULL_POSTAL_ADDRESS 
//   [ VT_LPWSTR ] Indicates the full postal address of the contact (e.g. "555 Dial Drive, PhoneLand, WA 12345") 
DEFINE_PROPERTYKEY( WPD_CONTACT_PERSONAL_FULL_POSTAL_ADDRESS , 0xFBD4FDAB, 0x987D, 0x4777, 0xB3, 0xF9, 0x72, 0x61, 0x85, 0xA9, 0x31, 0x2B , 10 ); 
// 
// WPD_CONTACT_PERSONAL_POSTAL_ADDRESS_LINE1 
//   [ VT_LPWSTR ] Indicates the first line of a postal address of the contact (e.g. "555 Dial Drive") 
DEFINE_PROPERTYKEY( WPD_CONTACT_PERSONAL_POSTAL_ADDRESS_LINE1 , 0xFBD4FDAB, 0x987D, 0x4777, 0xB3, 0xF9, 0x72, 0x61, 0x85, 0xA9, 0x31, 0x2B , 11 ); 
// 
// WPD_CONTACT_PERSONAL_POSTAL_ADDRESS_LINE2 
//   [ VT_LPWSTR ] Indicates the second line of a postal address of the contact 
DEFINE_PROPERTYKEY( WPD_CONTACT_PERSONAL_POSTAL_ADDRESS_LINE2 , 0xFBD4FDAB, 0x987D, 0x4777, 0xB3, 0xF9, 0x72, 0x61, 0x85, 0xA9, 0x31, 0x2B , 12 ); 
// 
// WPD_CONTACT_PERSONAL_POSTAL_ADDRESS_CITY 
//   [ VT_LPWSTR ] Indicates the city of a postal address of the contact (e.g. "PhoneLand") 
DEFINE_PROPERTYKEY( WPD_CONTACT_PERSONAL_POSTAL_ADDRESS_CITY , 0xFBD4FDAB, 0x987D, 0x4777, 0xB3, 0xF9, 0x72, 0x61, 0x85, 0xA9, 0x31, 0x2B , 13 ); 
// 
// WPD_CONTACT_PERSONAL_POSTAL_ADDRESS_REGION 
//   [ VT_LPWSTR ] Indicates the region of a postal address of the contact 
DEFINE_PROPERTYKEY( WPD_CONTACT_PERSONAL_POSTAL_ADDRESS_REGION , 0xFBD4FDAB, 0x987D, 0x4777, 0xB3, 0xF9, 0x72, 0x61, 0x85, 0xA9, 0x31, 0x2B , 14 ); 
// 
// WPD_CONTACT_PERSONAL_POSTAL_ADDRESS_POSTAL_CODE 
//   [ VT_LPWSTR ] Indicates the postal code of the address. 
DEFINE_PROPERTYKEY( WPD_CONTACT_PERSONAL_POSTAL_ADDRESS_POSTAL_CODE , 0xFBD4FDAB, 0x987D, 0x4777, 0xB3, 0xF9, 0x72, 0x61, 0x85, 0xA9, 0x31, 0x2B , 15 ); 
// 
// WPD_CONTACT_PERSONAL_POSTAL_ADDRESS_COUNTRY 
//   [ VT_LPWSTR ] 
DEFINE_PROPERTYKEY( WPD_CONTACT_PERSONAL_POSTAL_ADDRESS_COUNTRY , 0xFBD4FDAB, 0x987D, 0x4777, 0xB3, 0xF9, 0x72, 0x61, 0x85, 0xA9, 0x31, 0x2B , 16 ); 
// 
// WPD_CONTACT_BUSINESS_FULL_POSTAL_ADDRESS 
//   [ VT_LPWSTR ] Indicates the full postal address of the contact (e.g. "555 Dial Drive, PhoneLand, WA 12345") 
DEFINE_PROPERTYKEY( WPD_CONTACT_BUSINESS_FULL_POSTAL_ADDRESS , 0xFBD4FDAB, 0x987D, 0x4777, 0xB3, 0xF9, 0x72, 0x61, 0x85, 0xA9, 0x31, 0x2B , 17 ); 
// 
// WPD_CONTACT_BUSINESS_POSTAL_ADDRESS_LINE1 
//   [ VT_LPWSTR ] Indicates the first line of a postal address of the contact (e.g. "555 Dial Drive") 
DEFINE_PROPERTYKEY( WPD_CONTACT_BUSINESS_POSTAL_ADDRESS_LINE1 , 0xFBD4FDAB, 0x987D, 0x4777, 0xB3, 0xF9, 0x72, 0x61, 0x85, 0xA9, 0x31, 0x2B , 18 ); 
// 
// WPD_CONTACT_BUSINESS_POSTAL_ADDRESS_LINE2 
//   [ VT_LPWSTR ] Indicates the second line of a postal address of the contact 
DEFINE_PROPERTYKEY( WPD_CONTACT_BUSINESS_POSTAL_ADDRESS_LINE2 , 0xFBD4FDAB, 0x987D, 0x4777, 0xB3, 0xF9, 0x72, 0x61, 0x85, 0xA9, 0x31, 0x2B , 19 ); 
// 
// WPD_CONTACT_BUSINESS_POSTAL_ADDRESS_CITY 
//   [ VT_LPWSTR ] Indicates the city of a postal address of the contact (e.g. "PhoneLand") 
DEFINE_PROPERTYKEY( WPD_CONTACT_BUSINESS_POSTAL_ADDRESS_CITY , 0xFBD4FDAB, 0x987D, 0x4777, 0xB3, 0xF9, 0x72, 0x61, 0x85, 0xA9, 0x31, 0x2B , 20 ); 
// 
// WPD_CONTACT_BUSINESS_POSTAL_ADDRESS_REGION 
//   [ VT_LPWSTR ] Indicates the region of a postal address of the contact 
DEFINE_PROPERTYKEY( WPD_CONTACT_BUSINESS_POSTAL_ADDRESS_REGION , 0xFBD4FDAB, 0x987D, 0x4777, 0xB3, 0xF9, 0x72, 0x61, 0x85, 0xA9, 0x31, 0x2B , 21 ); 
// 
// WPD_CONTACT_BUSINESS_POSTAL_ADDRESS_POSTAL_CODE 
//   [ VT_LPWSTR ] Indicates the postal code of the address. 
DEFINE_PROPERTYKEY( WPD_CONTACT_BUSINESS_POSTAL_ADDRESS_POSTAL_CODE , 0xFBD4FDAB, 0x987D, 0x4777, 0xB3, 0xF9, 0x72, 0x61, 0x85, 0xA9, 0x31, 0x2B , 22 ); 
// 
// WPD_CONTACT_BUSINESS_POSTAL_ADDRESS_COUNTRY 
//   [ VT_LPWSTR ] 
DEFINE_PROPERTYKEY( WPD_CONTACT_BUSINESS_POSTAL_ADDRESS_COUNTRY , 0xFBD4FDAB, 0x987D, 0x4777, 0xB3, 0xF9, 0x72, 0x61, 0x85, 0xA9, 0x31, 0x2B , 23 ); 
// 
// WPD_CONTACT_OTHER_FULL_POSTAL_ADDRESS 
//   [ VT_LPWSTR ] Indicates the full postal address of the contact (e.g. "555 Dial Drive, PhoneLand, WA 12345"). 
DEFINE_PROPERTYKEY( WPD_CONTACT_OTHER_FULL_POSTAL_ADDRESS , 0xFBD4FDAB, 0x987D, 0x4777, 0xB3, 0xF9, 0x72, 0x61, 0x85, 0xA9, 0x31, 0x2B , 24 ); 
// 
// WPD_CONTACT_OTHER_POSTAL_ADDRESS_LINE1 
//   [ VT_LPWSTR ] Indicates the first line of a postal address of the contact (e.g. "555 Dial Drive"). 
DEFINE_PROPERTYKEY( WPD_CONTACT_OTHER_POSTAL_ADDRESS_LINE1 , 0xFBD4FDAB, 0x987D, 0x4777, 0xB3, 0xF9, 0x72, 0x61, 0x85, 0xA9, 0x31, 0x2B , 25 ); 
// 
// WPD_CONTACT_OTHER_POSTAL_ADDRESS_LINE2 
//   [ VT_LPWSTR ] Indicates the second line of a postal address of the contact. 
DEFINE_PROPERTYKEY( WPD_CONTACT_OTHER_POSTAL_ADDRESS_LINE2 , 0xFBD4FDAB, 0x987D, 0x4777, 0xB3, 0xF9, 0x72, 0x61, 0x85, 0xA9, 0x31, 0x2B , 26 ); 
// 
// WPD_CONTACT_OTHER_POSTAL_ADDRESS_CITY 
//   [ VT_LPWSTR ] Indicates the city of a postal address of the contact (e.g. "PhoneLand"). 
DEFINE_PROPERTYKEY( WPD_CONTACT_OTHER_POSTAL_ADDRESS_CITY , 0xFBD4FDAB, 0x987D, 0x4777, 0xB3, 0xF9, 0x72, 0x61, 0x85, 0xA9, 0x31, 0x2B , 27 ); 
// 
// WPD_CONTACT_OTHER_POSTAL_ADDRESS_REGION 
//   [ VT_LPWSTR ] Indicates the region of a postal address of the contact. 
DEFINE_PROPERTYKEY( WPD_CONTACT_OTHER_POSTAL_ADDRESS_REGION , 0xFBD4FDAB, 0x987D, 0x4777, 0xB3, 0xF9, 0x72, 0x61, 0x85, 0xA9, 0x31, 0x2B , 28 ); 
// 
// WPD_CONTACT_OTHER_POSTAL_ADDRESS_POSTAL_CODE 
//   [ VT_LPWSTR ] Indicates the postal code of the address. 
DEFINE_PROPERTYKEY( WPD_CONTACT_OTHER_POSTAL_ADDRESS_POSTAL_CODE , 0xFBD4FDAB, 0x987D, 0x4777, 0xB3, 0xF9, 0x72, 0x61, 0x85, 0xA9, 0x31, 0x2B , 29 ); 
// 
// WPD_CONTACT_OTHER_POSTAL_ADDRESS_POSTAL_COUNTRY 
//   [ VT_LPWSTR ] Indicates the country of the postal address. 
DEFINE_PROPERTYKEY( WPD_CONTACT_OTHER_POSTAL_ADDRESS_POSTAL_COUNTRY , 0xFBD4FDAB, 0x987D, 0x4777, 0xB3, 0xF9, 0x72, 0x61, 0x85, 0xA9, 0x31, 0x2B , 30 ); 
// 
// WPD_CONTACT_PRIMARY_EMAIL_ADDRESS 
//   [ VT_LPWSTR ] Indicates the primary email address for the contact e.g. "someone@example.com"
DEFINE_PROPERTYKEY( WPD_CONTACT_PRIMARY_EMAIL_ADDRESS , 0xFBD4FDAB, 0x987D, 0x4777, 0xB3, 0xF9, 0x72, 0x61, 0x85, 0xA9, 0x31, 0x2B , 31 ); 
// 
// WPD_CONTACT_PERSONAL_EMAIL 
//   [ VT_LPWSTR ] Indicates the personal email address for the contact e.g. "someone@example.com"
DEFINE_PROPERTYKEY( WPD_CONTACT_PERSONAL_EMAIL , 0xFBD4FDAB, 0x987D, 0x4777, 0xB3, 0xF9, 0x72, 0x61, 0x85, 0xA9, 0x31, 0x2B , 32 ); 
// 
// WPD_CONTACT_PERSONAL_EMAIL2 
//   [ VT_LPWSTR ] Indicates an alternate personal email address for the contact e.g. "someone@example.com"
DEFINE_PROPERTYKEY( WPD_CONTACT_PERSONAL_EMAIL2 , 0xFBD4FDAB, 0x987D, 0x4777, 0xB3, 0xF9, 0x72, 0x61, 0x85, 0xA9, 0x31, 0x2B , 33 ); 
// 
// WPD_CONTACT_BUSINESS_EMAIL 
//   [ VT_LPWSTR ] Indicates the business email address for the contact e.g. "someone@example.com"
DEFINE_PROPERTYKEY( WPD_CONTACT_BUSINESS_EMAIL , 0xFBD4FDAB, 0x987D, 0x4777, 0xB3, 0xF9, 0x72, 0x61, 0x85, 0xA9, 0x31, 0x2B , 34 ); 
// 
// WPD_CONTACT_BUSINESS_EMAIL2 
//   [ VT_LPWSTR ] Indicates an alternate business email address for the contact e.g. "JohnDoe@PhoneCompany.com"
DEFINE_PROPERTYKEY( WPD_CONTACT_BUSINESS_EMAIL2 , 0xFBD4FDAB, 0x987D, 0x4777, 0xB3, 0xF9, 0x72, 0x61, 0x85, 0xA9, 0x31, 0x2B , 35 ); 
// 
// WPD_CONTACT_OTHER_EMAILS 
//   [ VT_UNKNOWN ] An IPortableDevicePropVariantCollection of type VT_LPWSTR, where each element is an alternate email addresses for the contact. 
DEFINE_PROPERTYKEY( WPD_CONTACT_OTHER_EMAILS , 0xFBD4FDAB, 0x987D, 0x4777, 0xB3, 0xF9, 0x72, 0x61, 0x85, 0xA9, 0x31, 0x2B , 36 ); 
// 
// WPD_CONTACT_PRIMARY_PHONE 
//   [ VT_LPWSTR ] Indicates the primary phone number for the contact. 
DEFINE_PROPERTYKEY( WPD_CONTACT_PRIMARY_PHONE , 0xFBD4FDAB, 0x987D, 0x4777, 0xB3, 0xF9, 0x72, 0x61, 0x85, 0xA9, 0x31, 0x2B , 37 ); 
// 
// WPD_CONTACT_PERSONAL_PHONE 
//   [ VT_LPWSTR ] Indicates the personal phone number for the contact. 
DEFINE_PROPERTYKEY( WPD_CONTACT_PERSONAL_PHONE , 0xFBD4FDAB, 0x987D, 0x4777, 0xB3, 0xF9, 0x72, 0x61, 0x85, 0xA9, 0x31, 0x2B , 38 ); 
// 
// WPD_CONTACT_PERSONAL_PHONE2 
//   [ VT_LPWSTR ] Indicates an alternate personal phone number for the contact. 
DEFINE_PROPERTYKEY( WPD_CONTACT_PERSONAL_PHONE2 , 0xFBD4FDAB, 0x987D, 0x4777, 0xB3, 0xF9, 0x72, 0x61, 0x85, 0xA9, 0x31, 0x2B , 39 ); 
// 
// WPD_CONTACT_BUSINESS_PHONE 
//   [ VT_LPWSTR ] Indicates the business phone number for the contact. 
DEFINE_PROPERTYKEY( WPD_CONTACT_BUSINESS_PHONE , 0xFBD4FDAB, 0x987D, 0x4777, 0xB3, 0xF9, 0x72, 0x61, 0x85, 0xA9, 0x31, 0x2B , 40 ); 
// 
// WPD_CONTACT_BUSINESS_PHONE2 
//   [ VT_LPWSTR ] Indicates an alternate business phone number for the contact. 
DEFINE_PROPERTYKEY( WPD_CONTACT_BUSINESS_PHONE2 , 0xFBD4FDAB, 0x987D, 0x4777, 0xB3, 0xF9, 0x72, 0x61, 0x85, 0xA9, 0x31, 0x2B , 41 ); 
// 
// WPD_CONTACT_MOBILE_PHONE 
//   [ VT_LPWSTR ] Indicates the mobile phone number for the contact. 
DEFINE_PROPERTYKEY( WPD_CONTACT_MOBILE_PHONE , 0xFBD4FDAB, 0x987D, 0x4777, 0xB3, 0xF9, 0x72, 0x61, 0x85, 0xA9, 0x31, 0x2B , 42 ); 
// 
// WPD_CONTACT_MOBILE_PHONE2 
//   [ VT_LPWSTR ] Indicates an alternate mobile phone number for the contact. 
DEFINE_PROPERTYKEY( WPD_CONTACT_MOBILE_PHONE2 , 0xFBD4FDAB, 0x987D, 0x4777, 0xB3, 0xF9, 0x72, 0x61, 0x85, 0xA9, 0x31, 0x2B , 43 ); 
// 
// WPD_CONTACT_PERSONAL_FAX 
//   [ VT_LPWSTR ] Indicates the personal fax number for the contact. 
DEFINE_PROPERTYKEY( WPD_CONTACT_PERSONAL_FAX , 0xFBD4FDAB, 0x987D, 0x4777, 0xB3, 0xF9, 0x72, 0x61, 0x85, 0xA9, 0x31, 0x2B , 44 ); 
// 
// WPD_CONTACT_BUSINESS_FAX 
//   [ VT_LPWSTR ] Indicates the business fax number for the contact. 
DEFINE_PROPERTYKEY( WPD_CONTACT_BUSINESS_FAX , 0xFBD4FDAB, 0x987D, 0x4777, 0xB3, 0xF9, 0x72, 0x61, 0x85, 0xA9, 0x31, 0x2B , 45 ); 
// 
// WPD_CONTACT_PAGER 
//   [ VT_LPWSTR ] Indicates the pager number for the contact. 
DEFINE_PROPERTYKEY( WPD_CONTACT_PAGER , 0xFBD4FDAB, 0x987D, 0x4777, 0xB3, 0xF9, 0x72, 0x61, 0x85, 0xA9, 0x31, 0x2B , 46 ); 
// 
// WPD_CONTACT_OTHER_PHONES 
//   [ VT_UNKNOWN ] An IPortableDevicePropVariantCollection of type VT_LPWSTR, where each element is an alternate phone number for the contact. 
DEFINE_PROPERTYKEY( WPD_CONTACT_OTHER_PHONES , 0xFBD4FDAB, 0x987D, 0x4777, 0xB3, 0xF9, 0x72, 0x61, 0x85, 0xA9, 0x31, 0x2B , 47 ); 
// 
// WPD_CONTACT_PRIMARY_WEB_ADDRESS 
//   [ VT_LPWSTR ] Indicates the primary web address for the contact. 
DEFINE_PROPERTYKEY( WPD_CONTACT_PRIMARY_WEB_ADDRESS , 0xFBD4FDAB, 0x987D, 0x4777, 0xB3, 0xF9, 0x72, 0x61, 0x85, 0xA9, 0x31, 0x2B , 48 ); 
// 
// WPD_CONTACT_PERSONAL_WEB_ADDRESS 
//   [ VT_LPWSTR ] Indicates the personal web address for the contact. 
DEFINE_PROPERTYKEY( WPD_CONTACT_PERSONAL_WEB_ADDRESS , 0xFBD4FDAB, 0x987D, 0x4777, 0xB3, 0xF9, 0x72, 0x61, 0x85, 0xA9, 0x31, 0x2B , 49 ); 
// 
// WPD_CONTACT_BUSINESS_WEB_ADDRESS 
//   [ VT_LPWSTR ] Indicates the business web address for the contact. 
DEFINE_PROPERTYKEY( WPD_CONTACT_BUSINESS_WEB_ADDRESS , 0xFBD4FDAB, 0x987D, 0x4777, 0xB3, 0xF9, 0x72, 0x61, 0x85, 0xA9, 0x31, 0x2B , 50 ); 
// 
// WPD_CONTACT_INSTANT_MESSENGER 
//   [ VT_LPWSTR ] Indicates the instant messenger address for the contact. 
DEFINE_PROPERTYKEY( WPD_CONTACT_INSTANT_MESSENGER , 0xFBD4FDAB, 0x987D, 0x4777, 0xB3, 0xF9, 0x72, 0x61, 0x85, 0xA9, 0x31, 0x2B , 51 ); 
// 
// WPD_CONTACT_INSTANT_MESSENGER2 
//   [ VT_LPWSTR ] Indicates an alternate instant messenger address for the contact. 
DEFINE_PROPERTYKEY( WPD_CONTACT_INSTANT_MESSENGER2 , 0xFBD4FDAB, 0x987D, 0x4777, 0xB3, 0xF9, 0x72, 0x61, 0x85, 0xA9, 0x31, 0x2B , 52 ); 
// 
// WPD_CONTACT_INSTANT_MESSENGER3 
//   [ VT_LPWSTR ] Indicates an alternate instant messenger address for the contact. 
DEFINE_PROPERTYKEY( WPD_CONTACT_INSTANT_MESSENGER3 , 0xFBD4FDAB, 0x987D, 0x4777, 0xB3, 0xF9, 0x72, 0x61, 0x85, 0xA9, 0x31, 0x2B , 53 ); 
// 
// WPD_CONTACT_COMPANY_NAME 
//   [ VT_LPWSTR ] Indicates the company name for the contact. 
DEFINE_PROPERTYKEY( WPD_CONTACT_COMPANY_NAME , 0xFBD4FDAB, 0x987D, 0x4777, 0xB3, 0xF9, 0x72, 0x61, 0x85, 0xA9, 0x31, 0x2B , 54 ); 
// 
// WPD_CONTACT_PHONETIC_COMPANY_NAME 
//   [ VT_LPWSTR ] The phonetic guide for pronouncing the contact's company name. 
DEFINE_PROPERTYKEY( WPD_CONTACT_PHONETIC_COMPANY_NAME , 0xFBD4FDAB, 0x987D, 0x4777, 0xB3, 0xF9, 0x72, 0x61, 0x85, 0xA9, 0x31, 0x2B , 55 ); 
// 
// WPD_CONTACT_ROLE 
//   [ VT_LPWSTR ] Indicates the role for the contact e.g. "Software Engineer". 
DEFINE_PROPERTYKEY( WPD_CONTACT_ROLE , 0xFBD4FDAB, 0x987D, 0x4777, 0xB3, 0xF9, 0x72, 0x61, 0x85, 0xA9, 0x31, 0x2B , 56 ); 
// 
// WPD_CONTACT_BIRTHDATE 
//   [ VT_DATE ] Indicates the birthdate for the contact. 
DEFINE_PROPERTYKEY( WPD_CONTACT_BIRTHDATE , 0xFBD4FDAB, 0x987D, 0x4777, 0xB3, 0xF9, 0x72, 0x61, 0x85, 0xA9, 0x31, 0x2B , 57 ); 
// 
// WPD_CONTACT_PRIMARY_FAX 
//   [ VT_LPWSTR ] Indicates the primary fax number for the contact. 
DEFINE_PROPERTYKEY( WPD_CONTACT_PRIMARY_FAX , 0xFBD4FDAB, 0x987D, 0x4777, 0xB3, 0xF9, 0x72, 0x61, 0x85, 0xA9, 0x31, 0x2B , 58 ); 
// 
// WPD_CONTACT_SPOUSE 
//   [ VT_LPWSTR ] Indicates the full name of the spouse for the contact. 
DEFINE_PROPERTYKEY( WPD_CONTACT_SPOUSE , 0xFBD4FDAB, 0x987D, 0x4777, 0xB3, 0xF9, 0x72, 0x61, 0x85, 0xA9, 0x31, 0x2B , 59 ); 
// 
// WPD_CONTACT_CHILDREN 
//   [ VT_UNKNOWN ] An IPortableDevicePropVariantCollection of type VT_LPWSTR, where each element is the full name of a child of the contact. 
DEFINE_PROPERTYKEY( WPD_CONTACT_CHILDREN , 0xFBD4FDAB, 0x987D, 0x4777, 0xB3, 0xF9, 0x72, 0x61, 0x85, 0xA9, 0x31, 0x2B , 60 ); 
// 
// WPD_CONTACT_ASSISTANT 
//   [ VT_LPWSTR ] Indicates the full name of the assistant for the contact. 
DEFINE_PROPERTYKEY( WPD_CONTACT_ASSISTANT , 0xFBD4FDAB, 0x987D, 0x4777, 0xB3, 0xF9, 0x72, 0x61, 0x85, 0xA9, 0x31, 0x2B , 61 ); 
// 
// WPD_CONTACT_ANNIVERSARY_DATE 
//   [ VT_DATE ] Indicates the anniversary date for the contact. 
DEFINE_PROPERTYKEY( WPD_CONTACT_ANNIVERSARY_DATE , 0xFBD4FDAB, 0x987D, 0x4777, 0xB3, 0xF9, 0x72, 0x61, 0x85, 0xA9, 0x31, 0x2B , 62 ); 

/**************************************************************************** 
* This section defines all Commands, Parameters and Options associated with: 
* WPD_MUSIC_OBJECT_PROPERTIES_V1 
* 
* This category is for properties common to all music objects. 
****************************************************************************/ 
DEFINE_GUID( WPD_MUSIC_OBJECT_PROPERTIES_V1 , 0xB324F56A, 0xDC5D, 0x46E5, 0xB6, 0xDF, 0xD2, 0xEA, 0x41, 0x48, 0x88, 0xC6 ); 

// 
// WPD_MUSIC_ALBUM 
//   [ VT_LPWSTR ] Indicates the album of the music file. 
DEFINE_PROPERTYKEY( WPD_MUSIC_ALBUM , 0xB324F56A, 0xDC5D, 0x46E5, 0xB6, 0xDF, 0xD2, 0xEA, 0x41, 0x48, 0x88, 0xC6 , 3 ); 
// 
// WPD_MUSIC_TRACK 
//   [ VT_UI4 ] Indicates the track number for the music file. 
DEFINE_PROPERTYKEY( WPD_MUSIC_TRACK , 0xB324F56A, 0xDC5D, 0x46E5, 0xB6, 0xDF, 0xD2, 0xEA, 0x41, 0x48, 0x88, 0xC6 , 4 ); 
// 
// WPD_MUSIC_LYRICS 
//   [ VT_LPWSTR ] Indicates the lyrics for the music file. 
DEFINE_PROPERTYKEY( WPD_MUSIC_LYRICS , 0xB324F56A, 0xDC5D, 0x46E5, 0xB6, 0xDF, 0xD2, 0xEA, 0x41, 0x48, 0x88, 0xC6 , 6 ); 
// 
// WPD_MUSIC_MOOD 
//   [ VT_LPWSTR ] Indicates the mood for the music file. 
DEFINE_PROPERTYKEY( WPD_MUSIC_MOOD , 0xB324F56A, 0xDC5D, 0x46E5, 0xB6, 0xDF, 0xD2, 0xEA, 0x41, 0x48, 0x88, 0xC6 , 8 ); 
// 
// WPD_AUDIO_BITRATE 
//   [ VT_UI4 ] Indicates the bit rate for the audio data, specified in bits per second. 
DEFINE_PROPERTYKEY( WPD_AUDIO_BITRATE , 0xB324F56A, 0xDC5D, 0x46E5, 0xB6, 0xDF, 0xD2, 0xEA, 0x41, 0x48, 0x88, 0xC6 , 9 ); 
// 
// WPD_AUDIO_CHANNEL_COUNT 
//   [ VT_R4 ] Indicates the number of channels in this audio file e.g. 1, 2, 5.1 etc. 
DEFINE_PROPERTYKEY( WPD_AUDIO_CHANNEL_COUNT , 0xB324F56A, 0xDC5D, 0x46E5, 0xB6, 0xDF, 0xD2, 0xEA, 0x41, 0x48, 0x88, 0xC6 , 10 ); 
// 
// WPD_AUDIO_FORMAT_CODE 
//   [ VT_UI4 ] Indicates the registered WAVE format code. 
DEFINE_PROPERTYKEY( WPD_AUDIO_FORMAT_CODE , 0xB324F56A, 0xDC5D, 0x46E5, 0xB6, 0xDF, 0xD2, 0xEA, 0x41, 0x48, 0x88, 0xC6 , 11 ); 
// 
// WPD_AUDIO_BIT_DEPTH 
//   [ VT_UI4 ] This property identifies the bit-depth of the audio. 
DEFINE_PROPERTYKEY( WPD_AUDIO_BIT_DEPTH , 0xB324F56A, 0xDC5D, 0x46E5, 0xB6, 0xDF, 0xD2, 0xEA, 0x41, 0x48, 0x88, 0xC6 , 12 ); 
// 
// WPD_AUDIO_BLOCK_ALIGNMENT 
//   [ VT_UI4 ] TBD 
DEFINE_PROPERTYKEY( WPD_AUDIO_BLOCK_ALIGNMENT , 0xB324F56A, 0xDC5D, 0x46E5, 0xB6, 0xDF, 0xD2, 0xEA, 0x41, 0x48, 0x88, 0xC6 , 13 ); 

/**************************************************************************** 
* This section defines all Commands, Parameters and Options associated with: 
* WPD_VIDEO_OBJECT_PROPERTIES_V1 
* 
* This category is for properties common to all video objects. 
****************************************************************************/ 
DEFINE_GUID( WPD_VIDEO_OBJECT_PROPERTIES_V1 , 0x346F2163, 0xF998, 0x4146, 0x8B, 0x01, 0xD1, 0x9B, 0x4C, 0x00, 0xDE, 0x9A ); 

// 
// WPD_VIDEO_AUTHOR 
//   [ VT_LPWSTR ] Indicates the author of the video file. 
DEFINE_PROPERTYKEY( WPD_VIDEO_AUTHOR , 0x346F2163, 0xF998, 0x4146, 0x8B, 0x01, 0xD1, 0x9B, 0x4C, 0x00, 0xDE, 0x9A , 2 ); 
// 
// WPD_VIDEO_RECORDEDTV_STATION_NAME 
//   [ VT_LPWSTR ] Indicates the TV station the video was recorded from. 
DEFINE_PROPERTYKEY( WPD_VIDEO_RECORDEDTV_STATION_NAME , 0x346F2163, 0xF998, 0x4146, 0x8B, 0x01, 0xD1, 0x9B, 0x4C, 0x00, 0xDE, 0x9A , 4 ); 
// 
// WPD_VIDEO_RECORDEDTV_CHANNEL_NUMBER 
//   [ VT_UI4 ] Indicates the TV channel number the video was recorded from. 
DEFINE_PROPERTYKEY( WPD_VIDEO_RECORDEDTV_CHANNEL_NUMBER , 0x346F2163, 0xF998, 0x4146, 0x8B, 0x01, 0xD1, 0x9B, 0x4C, 0x00, 0xDE, 0x9A , 5 ); 
// 
// WPD_VIDEO_RECORDEDTV_REPEAT 
//   [ VT_BOOL ] Indicates whether the recorded TV program was a repeat showing. 
DEFINE_PROPERTYKEY( WPD_VIDEO_RECORDEDTV_REPEAT , 0x346F2163, 0xF998, 0x4146, 0x8B, 0x01, 0xD1, 0x9B, 0x4C, 0x00, 0xDE, 0x9A , 7 ); 
// 
// WPD_VIDEO_BUFFER_SIZE 
//   [ VT_UI4 ] Indicates the video buffer size. 
DEFINE_PROPERTYKEY( WPD_VIDEO_BUFFER_SIZE , 0x346F2163, 0xF998, 0x4146, 0x8B, 0x01, 0xD1, 0x9B, 0x4C, 0x00, 0xDE, 0x9A , 8 ); 
// 
// WPD_VIDEO_CREDITS 
//   [ VT_LPWSTR ] Indicates the credit text for the video file. 
DEFINE_PROPERTYKEY( WPD_VIDEO_CREDITS , 0x346F2163, 0xF998, 0x4146, 0x8B, 0x01, 0xD1, 0x9B, 0x4C, 0x00, 0xDE, 0x9A , 9 ); 
// 
// WPD_VIDEO_KEY_FRAME_DISTANCE 
//   [ VT_UI4 ] Indicates the interval between key frames in milliseconds. 
DEFINE_PROPERTYKEY( WPD_VIDEO_KEY_FRAME_DISTANCE , 0x346F2163, 0xF998, 0x4146, 0x8B, 0x01, 0xD1, 0x9B, 0x4C, 0x00, 0xDE, 0x9A , 10 ); 
// 
// WPD_VIDEO_QUALITY_SETTING 
//   [ VT_UI4 ] Indicates the quality setting for the video file. 
DEFINE_PROPERTYKEY( WPD_VIDEO_QUALITY_SETTING , 0x346F2163, 0xF998, 0x4146, 0x8B, 0x01, 0xD1, 0x9B, 0x4C, 0x00, 0xDE, 0x9A , 11 ); 
// 
// WPD_VIDEO_SCAN_TYPE 
//   [ VT_UI4 ] This property identifies the video scan information. 
DEFINE_PROPERTYKEY( WPD_VIDEO_SCAN_TYPE , 0x346F2163, 0xF998, 0x4146, 0x8B, 0x01, 0xD1, 0x9B, 0x4C, 0x00, 0xDE, 0x9A , 12 ); 
// 
// WPD_VIDEO_BITRATE 
//   [ VT_UI4 ] Indicates the bitrate for the video data. 
DEFINE_PROPERTYKEY( WPD_VIDEO_BITRATE , 0x346F2163, 0xF998, 0x4146, 0x8B, 0x01, 0xD1, 0x9B, 0x4C, 0x00, 0xDE, 0x9A , 13 ); 
// 
// WPD_VIDEO_FOURCC_CODE 
//   [ VT_DWORD ] The registered FourCC code indicating the codec used for the video file. 
DEFINE_PROPERTYKEY( WPD_VIDEO_FOURCC_CODE , 0x346F2163, 0xF998, 0x4146, 0x8B, 0x01, 0xD1, 0x9B, 0x4C, 0x00, 0xDE, 0x9A , 14 ); 
// 
// WPD_VIDEO_FRAMERATE 
//   [ VT_UI4 ] Indicates the frame rate for the video data. 
DEFINE_PROPERTYKEY( WPD_VIDEO_FRAMERATE , 0x346F2163, 0xF998, 0x4146, 0x8B, 0x01, 0xD1, 0x9B, 0x4C, 0x00, 0xDE, 0x9A , 15 ); 

/**************************************************************************** 
* This section defines all Commands, Parameters and Options associated with: 
* WPD_COMMON_INFORMATION_OBJECT_PROPERTIES_V1 
* 
* This category is properties that pertain to informational objects such as appointments, tasks, memos and even documents. 
****************************************************************************/ 
DEFINE_GUID( WPD_COMMON_INFORMATION_OBJECT_PROPERTIES_V1 , 0xB28AE94B, 0x05A4, 0x4E8E, 0xBE, 0x01, 0x72, 0xCC, 0x7E, 0x09, 0x9D, 0x8F ); 

// 
// WPD_COMMON_INFORMATION_SUBJECT 
//   [ VT_LPWSTR ] Indicates the subject field of this object. 
DEFINE_PROPERTYKEY( WPD_COMMON_INFORMATION_SUBJECT , 0xB28AE94B, 0x05A4, 0x4E8E, 0xBE, 0x01, 0x72, 0xCC, 0x7E, 0x09, 0x9D, 0x8F , 2 ); 
// 
// WPD_COMMON_INFORMATION_BODY_TEXT 
//   [ VT_LPWSTR ] This property contains the body text of an object, in plaintext or HTML format. 
DEFINE_PROPERTYKEY( WPD_COMMON_INFORMATION_BODY_TEXT , 0xB28AE94B, 0x05A4, 0x4E8E, 0xBE, 0x01, 0x72, 0xCC, 0x7E, 0x09, 0x9D, 0x8F , 3 ); 
// 
// WPD_COMMON_INFORMATION_PRIORITY 
//   [ VT_UI4 ] Indicates the priority of this object. 
DEFINE_PROPERTYKEY( WPD_COMMON_INFORMATION_PRIORITY , 0xB28AE94B, 0x05A4, 0x4E8E, 0xBE, 0x01, 0x72, 0xCC, 0x7E, 0x09, 0x9D, 0x8F , 4 ); 
// 
// WPD_COMMON_INFORMATION_START_DATETIME 
//   [ VT_DATE ] For appointments, tasks and similar objects, this indicates the date/time that this item is scheduled to start. 
DEFINE_PROPERTYKEY( WPD_COMMON_INFORMATION_START_DATETIME , 0xB28AE94B, 0x05A4, 0x4E8E, 0xBE, 0x01, 0x72, 0xCC, 0x7E, 0x09, 0x9D, 0x8F , 5 ); 
// 
// WPD_COMMON_INFORMATION_END_DATETIME 
//   [ VT_DATE ] For appointments, tasks and similar objects, this indicates the date/time that this item is scheduled to end. 
DEFINE_PROPERTYKEY( WPD_COMMON_INFORMATION_END_DATETIME , 0xB28AE94B, 0x05A4, 0x4E8E, 0xBE, 0x01, 0x72, 0xCC, 0x7E, 0x09, 0x9D, 0x8F , 6 ); 
// 
// WPD_COMMON_INFORMATION_NOTES 
//   [ VT_LPWSTR ] For appointments, tasks and similar objects, this indicates any notes for this object. 
DEFINE_PROPERTYKEY( WPD_COMMON_INFORMATION_NOTES , 0xB28AE94B, 0x05A4, 0x4E8E, 0xBE, 0x01, 0x72, 0xCC, 0x7E, 0x09, 0x9D, 0x8F , 7); 

/**************************************************************************** 
* This section defines all Commands, Parameters and Options associated with: 
* WPD_MEMO_OBJECT_PROPERTIES_V1 
* 
* This category is for properties common to all memo objects. 
****************************************************************************/ 
DEFINE_GUID( WPD_MEMO_OBJECT_PROPERTIES_V1 , 0x5FFBFC7B, 0x7483, 0x41AD, 0xAF, 0xB9, 0xDA, 0x3F, 0x4E, 0x59, 0x2B, 0x8D ); 


/**************************************************************************** 
* This section defines all Commands, Parameters and Options associated with: 
* WPD_EMAIL_OBJECT_PROPERTIES_V1 
* 
* This category is for properties common to all email objects. 
****************************************************************************/ 
DEFINE_GUID( WPD_EMAIL_OBJECT_PROPERTIES_V1 , 0x41F8F65A, 0x5484, 0x4782, 0xB1, 0x3D, 0x47, 0x40, 0xDD, 0x7C, 0x37, 0xC5 ); 

// 
// WPD_EMAIL_TO_LINE 
//   [ VT_LPWSTR ] Indicates the normal recipients for the message. 
DEFINE_PROPERTYKEY( WPD_EMAIL_TO_LINE , 0x41F8F65A, 0x5484, 0x4782, 0xB1, 0x3D, 0x47, 0x40, 0xDD, 0x7C, 0x37, 0xC5 , 2 ); 
// 
// WPD_EMAIL_CC_LINE 
//   [ VT_LPWSTR ] Indicates the copied recipients for the message. 
DEFINE_PROPERTYKEY( WPD_EMAIL_CC_LINE , 0x41F8F65A, 0x5484, 0x4782, 0xB1, 0x3D, 0x47, 0x40, 0xDD, 0x7C, 0x37, 0xC5 , 3 ); 
// 
// WPD_EMAIL_BCC_LINE 
//   [ VT_LPWSTR ] Indicates the recipients for the message who receive a "blind copy". 
DEFINE_PROPERTYKEY( WPD_EMAIL_BCC_LINE , 0x41F8F65A, 0x5484, 0x4782, 0xB1, 0x3D, 0x47, 0x40, 0xDD, 0x7C, 0x37, 0xC5 , 4 ); 
// 
// WPD_EMAIL_HAS_BEEN_READ 
//   [ VT_BOOL ] Indicates whether the user has read this message. 
DEFINE_PROPERTYKEY( WPD_EMAIL_HAS_BEEN_READ , 0x41F8F65A, 0x5484, 0x4782, 0xB1, 0x3D, 0x47, 0x40, 0xDD, 0x7C, 0x37, 0xC5 , 7 ); 
// 
// WPD_EMAIL_RECEIVED_TIME 
//   [ VT_DATE ] Indicates at what time the message was received. 
DEFINE_PROPERTYKEY( WPD_EMAIL_RECEIVED_TIME , 0x41F8F65A, 0x5484, 0x4782, 0xB1, 0x3D, 0x47, 0x40, 0xDD, 0x7C, 0x37, 0xC5 , 8 ); 
// 
// WPD_EMAIL_HAS_ATTACHMENTS 
//   [ VT_BOOL ] Indicates whether this message has attachments. 
DEFINE_PROPERTYKEY( WPD_EMAIL_HAS_ATTACHMENTS , 0x41F8F65A, 0x5484, 0x4782, 0xB1, 0x3D, 0x47, 0x40, 0xDD, 0x7C, 0x37, 0xC5 , 9 ); 
// 
// WPD_EMAIL_SENDER_ADDRESS 
//   [ VT_LPWSTR ] Indicates who sent the message. 
DEFINE_PROPERTYKEY( WPD_EMAIL_SENDER_ADDRESS , 0x41F8F65A, 0x5484, 0x4782, 0xB1, 0x3D, 0x47, 0x40, 0xDD, 0x7C, 0x37, 0xC5 , 10 ); 

/**************************************************************************** 
* This section defines all Commands, Parameters and Options associated with: 
* WPD_APPOINTMENT_OBJECT_PROPERTIES_V1 
* 
* This category is for properties common to all appointment objects. 
****************************************************************************/ 
DEFINE_GUID( WPD_APPOINTMENT_OBJECT_PROPERTIES_V1 , 0xF99EFD03, 0x431D, 0x40D8, 0xA1, 0xC9, 0x4E, 0x22, 0x0D, 0x9C, 0x88, 0xD3 ); 

// 
// WPD_APPOINTMENT_LOCATION 
//   [ VT_LPWSTR ] Indicates the location of the appointment e.g. "Building 5, Conf. room 7". 
DEFINE_PROPERTYKEY( WPD_APPOINTMENT_LOCATION , 0xF99EFD03, 0x431D, 0x40D8, 0xA1, 0xC9, 0x4E, 0x22, 0x0D, 0x9C, 0x88, 0xD3 , 3 ); 
// 
// WPD_APPOINTMENT_TYPE 
//   [ VT_LPWSTR ] Indicates the type of appointment e.g. "Personal", "Business" etc. 
DEFINE_PROPERTYKEY( WPD_APPOINTMENT_TYPE , 0xF99EFD03, 0x431D, 0x40D8, 0xA1, 0xC9, 0x4E, 0x22, 0x0D, 0x9C, 0x88, 0xD3 , 7 ); 
// 
// WPD_APPOINTMENT_REQUIRED_ATTENDEES 
//   [ VT_LPWSTR ] Semi-colon separated list of required attendees. 
DEFINE_PROPERTYKEY( WPD_APPOINTMENT_REQUIRED_ATTENDEES , 0xF99EFD03, 0x431D, 0x40D8, 0xA1, 0xC9, 0x4E, 0x22, 0x0D, 0x9C, 0x88, 0xD3 , 8 ); 
// 
// WPD_APPOINTMENT_OPTIONAL_ATTENDEES 
//   [ VT_LPWSTR ] Semi-colon separated list of optional attendees. 
DEFINE_PROPERTYKEY( WPD_APPOINTMENT_OPTIONAL_ATTENDEES , 0xF99EFD03, 0x431D, 0x40D8, 0xA1, 0xC9, 0x4E, 0x22, 0x0D, 0x9C, 0x88, 0xD3 , 9 ); 
// 
// WPD_APPOINTMENT_ACCEPTED_ATTENDEES 
//   [ VT_LPWSTR ] Semi-colon separated list of attendees who have accepted the appointment. 
DEFINE_PROPERTYKEY( WPD_APPOINTMENT_ACCEPTED_ATTENDEES , 0xF99EFD03, 0x431D, 0x40D8, 0xA1, 0xC9, 0x4E, 0x22, 0x0D, 0x9C, 0x88, 0xD3 , 10 ); 
// 
// WPD_APPOINTMENT_RESOURCES 
//   [ VT_LPWSTR ] Semi-colon separated list of resources needed for the appointment. 
DEFINE_PROPERTYKEY( WPD_APPOINTMENT_RESOURCES , 0xF99EFD03, 0x431D, 0x40D8, 0xA1, 0xC9, 0x4E, 0x22, 0x0D, 0x9C, 0x88, 0xD3 , 11 ); 
// 
// WPD_APPOINTMENT_TENTATIVE_ATTENDEES 
//   [ VT_LPWSTR ] Semi-colon separated list of attendees who have tentatively accepted the appointment. 
DEFINE_PROPERTYKEY( WPD_APPOINTMENT_TENTATIVE_ATTENDEES , 0xF99EFD03, 0x431D, 0x40D8, 0xA1, 0xC9, 0x4E, 0x22, 0x0D, 0x9C, 0x88, 0xD3 , 12 ); 
// 
// WPD_APPOINTMENT_DECLINED_ATTENDEES 
//   [ VT_LPWSTR ] Semi-colon separated list of attendees who have declined the appointment. 
DEFINE_PROPERTYKEY( WPD_APPOINTMENT_DECLINED_ATTENDEES , 0xF99EFD03, 0x431D, 0x40D8, 0xA1, 0xC9, 0x4E, 0x22, 0x0D, 0x9C, 0x88, 0xD3 , 13 ); 

/**************************************************************************** 
* This section defines all Commands, Parameters and Options associated with: 
* WPD_TASK_OBJECT_PROPERTIES_V1 
* 
* This category is for properties common to all task objects. 
****************************************************************************/ 
DEFINE_GUID( WPD_TASK_OBJECT_PROPERTIES_V1 , 0xE354E95E, 0xD8A0, 0x4637, 0xA0, 0x3A, 0x0C, 0xB2, 0x68, 0x38, 0xDB, 0xC7 ); 

// 
// WPD_TASK_STATUS 
//   [ VT_LPWSTR ] Indicates the status of the task e.g. "In Progress". 
DEFINE_PROPERTYKEY( WPD_TASK_STATUS , 0xE354E95E, 0xD8A0, 0x4637, 0xA0, 0x3A, 0x0C, 0xB2, 0x68, 0x38, 0xDB, 0xC7 , 6 ); 
// 
// WPD_TASK_PERCENT_COMPLETE 
//   [ VT_UI4 ] Indicates how much of the task has been completed. 
DEFINE_PROPERTYKEY( WPD_TASK_PERCENT_COMPLETE , 0xE354E95E, 0xD8A0, 0x4637, 0xA0, 0x3A, 0x0C, 0xB2, 0x68, 0x38, 0xDB, 0xC7 , 8 ); 
// 
// WPD_TASK_REMINDER_DATE 
//   [ VT_DATE ] Indicates the date and time set for the reminder. If this value is 0, then it is assumed that this task has no reminder. 
DEFINE_PROPERTYKEY( WPD_TASK_REMINDER_DATE , 0xE354E95E, 0xD8A0, 0x4637, 0xA0, 0x3A, 0x0C, 0xB2, 0x68, 0x38, 0xDB, 0xC7 , 10 ); 
// 
// WPD_TASK_OWNER 
//   [ VT_LPWSTR ] Indicates the owner of the task. 
DEFINE_PROPERTYKEY( WPD_TASK_OWNER , 0xE354E95E, 0xD8A0, 0x4637, 0xA0, 0x3A, 0x0C, 0xB2, 0x68, 0x38, 0xDB, 0xC7 , 11 ); 

/**************************************************************************** 
* This section defines all Commands, Parameters and Options associated with: 
* WPD_STORAGE_OBJECT_PROPERTIES_V1 
* 
* This category is for properties common to all objects whose functional category is WPD_FUNCTIONAL_CATEGORY_STORAGE. 
****************************************************************************/ 
DEFINE_GUID( WPD_STORAGE_OBJECT_PROPERTIES_V1 , 0x01A3057A, 0x74D6, 0x4E80, 0xBE, 0xA7, 0xDC, 0x4C, 0x21, 0x2C, 0xE5, 0x0A ); 

// 
// WPD_STORAGE_TYPE 
//   [ VT_UI4 ] Indicates the type of storage e.g. fixed, removable etc. 
DEFINE_PROPERTYKEY( WPD_STORAGE_TYPE , 0x01A3057A, 0x74D6, 0x4E80, 0xBE, 0xA7, 0xDC, 0x4C, 0x21, 0x2C, 0xE5, 0x0A , 2 ); 
// 
// WPD_STORAGE_FILE_SYSTEM_TYPE 
//   [ VT_LPWSTR ] Indicates the file system type e.g. "FAT32" or "NTFS" or "My Special File System" 
DEFINE_PROPERTYKEY( WPD_STORAGE_FILE_SYSTEM_TYPE , 0x01A3057A, 0x74D6, 0x4E80, 0xBE, 0xA7, 0xDC, 0x4C, 0x21, 0x2C, 0xE5, 0x0A , 3 ); 
// 
// WPD_STORAGE_CAPACITY 
//   [ VT_UI8 ] Indicates the total storage capacity in bytes. 
DEFINE_PROPERTYKEY( WPD_STORAGE_CAPACITY , 0x01A3057A, 0x74D6, 0x4E80, 0xBE, 0xA7, 0xDC, 0x4C, 0x21, 0x2C, 0xE5, 0x0A , 4 ); 
// 
// WPD_STORAGE_FREE_SPACE_IN_BYTES 
//   [ VT_UI8 ] Indicates the available space in bytes. 
DEFINE_PROPERTYKEY( WPD_STORAGE_FREE_SPACE_IN_BYTES , 0x01A3057A, 0x74D6, 0x4E80, 0xBE, 0xA7, 0xDC, 0x4C, 0x21, 0x2C, 0xE5, 0x0A , 5 ); 
// 
// WPD_STORAGE_FREE_SPACE_IN_OBJECTS 
//   [ VT_UI8 ] Indicates the available space in objects e.g. available slots on a SIM card. 
DEFINE_PROPERTYKEY( WPD_STORAGE_FREE_SPACE_IN_OBJECTS , 0x01A3057A, 0x74D6, 0x4E80, 0xBE, 0xA7, 0xDC, 0x4C, 0x21, 0x2C, 0xE5, 0x0A , 6 ); 
// 
// WPD_STORAGE_DESCRIPTION 
//   [ VT_LPWSTR ] Contains a description of the storage. 
DEFINE_PROPERTYKEY( WPD_STORAGE_DESCRIPTION , 0x01A3057A, 0x74D6, 0x4E80, 0xBE, 0xA7, 0xDC, 0x4C, 0x21, 0x2C, 0xE5, 0x0A , 7 ); 
// 
// WPD_STORAGE_SERIAL_NUMBER 
//   [ VT_LPWSTR ] Contains the serial number of the storage. 
DEFINE_PROPERTYKEY( WPD_STORAGE_SERIAL_NUMBER , 0x01A3057A, 0x74D6, 0x4E80, 0xBE, 0xA7, 0xDC, 0x4C, 0x21, 0x2C, 0xE5, 0x0A , 8 ); 
// 
// WPD_STORAGE_MAX_OBJECT_SIZE 
//   [ VT_UI8 ] Specifies the maximum size of a single object (in bytes) that can be placed on this storage. 
DEFINE_PROPERTYKEY( WPD_STORAGE_MAX_OBJECT_SIZE , 0x01A3057A, 0x74D6, 0x4E80, 0xBE, 0xA7, 0xDC, 0x4C, 0x21, 0x2C, 0xE5, 0x0A , 9 ); 
// 
// WPD_STORAGE_CAPACITY_IN_OBJECTS 
//   [ VT_UI8 ] Indicates the total storage capacity in objects e.g. available slots on a SIM card. 
DEFINE_PROPERTYKEY( WPD_STORAGE_CAPACITY_IN_OBJECTS , 0x01A3057A, 0x74D6, 0x4E80, 0xBE, 0xA7, 0xDC, 0x4C, 0x21, 0x2C, 0xE5, 0x0A , 10 ); 
// 
// WPD_STORAGE_ACCESS_CAPABILITY 
//   [ VT_UI4 ] This property identifies any write-protection that globally affects this storage. This takes precedence over access specified on individual objects. 
DEFINE_PROPERTYKEY( WPD_STORAGE_ACCESS_CAPABILITY , 0x01A3057A, 0x74D6, 0x4E80, 0xBE, 0xA7, 0xDC, 0x4C, 0x21, 0x2C, 0xE5, 0x0A , 11 ); 

/**************************************************************************** 
* This section defines all Commands, Parameters and Options associated with: 
* WPD_NETWORK_ASSOCIATION_PROPERTIES_V1 
* 
* This category is for properties common to all network association objects. 
****************************************************************************/ 
DEFINE_GUID( WPD_NETWORK_ASSOCIATION_PROPERTIES_V1 , 0xE4C93C1F, 0xB203, 0x43F1, 0xA1, 0x00, 0x5A, 0x07, 0xD1, 0x1B, 0x02, 0x74 ); 

// 
// WPD_NETWORK_ASSOCIATION_HOST_NETWORK_IDENTIFIERS 
//   [ VT_VECTOR | VT_UI1 ] The list of EUI-64 host identifiers valid for this association. 
DEFINE_PROPERTYKEY( WPD_NETWORK_ASSOCIATION_HOST_NETWORK_IDENTIFIERS , 0xE4C93C1F, 0xB203, 0x43F1, 0xA1, 0x00, 0x5A, 0x07, 0xD1, 0x1B, 0x02, 0x74 , 2 ); 
// 
// WPD_NETWORK_ASSOCIATION_X509V3SEQUENCE 
//   [ VT_VECTOR | VT_UI1 ] The sequence of X.509 v3 certificates to be provided for TLS server authentication. 
DEFINE_PROPERTYKEY( WPD_NETWORK_ASSOCIATION_X509V3SEQUENCE , 0xE4C93C1F, 0xB203, 0x43F1, 0xA1, 0x00, 0x5A, 0x07, 0xD1, 0x1B, 0x02, 0x74 , 3 ); 

/**************************************************************************** 
* This section defines all Commands, Parameters and Options associated with: 
* WPD_STILL_IMAGE_CAPTURE_OBJECT_PROPERTIES_V1 
* 
* This category is for properties common to all objects whose functional category is WPD_FUNCTIONAL_CATEGORY_STILL_IMAGE_CAPTURE 
****************************************************************************/ 
DEFINE_GUID( WPD_STILL_IMAGE_CAPTURE_OBJECT_PROPERTIES_V1 , 0x58C571EC, 0x1BCB, 0x42A7, 0x8A, 0xC5, 0xBB, 0x29, 0x15, 0x73, 0xA2, 0x60 ); 

// 
// WPD_STILL_IMAGE_CAPTURE_RESOLUTION 
//   [ VT_LPWSTR ] Controls the size of the image dimensions to capture in pixel width and height. 
DEFINE_PROPERTYKEY( WPD_STILL_IMAGE_CAPTURE_RESOLUTION , 0x58C571EC, 0x1BCB, 0x42A7, 0x8A, 0xC5, 0xBB, 0x29, 0x15, 0x73, 0xA2, 0x60 , 2 ); 
// 
// WPD_STILL_IMAGE_CAPTURE_FORMAT 
//   [ VT_CLSID ] Controls the format of the image to capture. 
DEFINE_PROPERTYKEY( WPD_STILL_IMAGE_CAPTURE_FORMAT , 0x58C571EC, 0x1BCB, 0x42A7, 0x8A, 0xC5, 0xBB, 0x29, 0x15, 0x73, 0xA2, 0x60 , 3 ); 
// 
// WPD_STILL_IMAGE_COMPRESSION_SETTING 
//   [ VT_UI8 ] Controls the device-specific quality setting. 
DEFINE_PROPERTYKEY( WPD_STILL_IMAGE_COMPRESSION_SETTING , 0x58C571EC, 0x1BCB, 0x42A7, 0x8A, 0xC5, 0xBB, 0x29, 0x15, 0x73, 0xA2, 0x60 , 4 ); 
// 
// WPD_STILL_IMAGE_WHITE_BALANCE 
//   [ VT_UI4 ] Controls how the device weights color channels. 
DEFINE_PROPERTYKEY( WPD_STILL_IMAGE_WHITE_BALANCE , 0x58C571EC, 0x1BCB, 0x42A7, 0x8A, 0xC5, 0xBB, 0x29, 0x15, 0x73, 0xA2, 0x60 , 5 ); 
// 
// WPD_STILL_IMAGE_RGB_GAIN 
//   [ VT_LPWSTR ] Controls the RGB gain. 
DEFINE_PROPERTYKEY( WPD_STILL_IMAGE_RGB_GAIN , 0x58C571EC, 0x1BCB, 0x42A7, 0x8A, 0xC5, 0xBB, 0x29, 0x15, 0x73, 0xA2, 0x60 , 6 ); 
// 
// WPD_STILL_IMAGE_FNUMBER 
//   [ VT_UI4 ] Controls the aperture of the lens. 
DEFINE_PROPERTYKEY( WPD_STILL_IMAGE_FNUMBER , 0x58C571EC, 0x1BCB, 0x42A7, 0x8A, 0xC5, 0xBB, 0x29, 0x15, 0x73, 0xA2, 0x60 , 7 ); 
// 
// WPD_STILL_IMAGE_FOCAL_LENGTH 
//   [ VT_UI4 ] Controls the 35mm equivalent focal length. 
DEFINE_PROPERTYKEY( WPD_STILL_IMAGE_FOCAL_LENGTH , 0x58C571EC, 0x1BCB, 0x42A7, 0x8A, 0xC5, 0xBB, 0x29, 0x15, 0x73, 0xA2, 0x60 , 8 ); 
// 
// WPD_STILL_IMAGE_FOCUS_DISTANCE 
//   [ VT_UI4 ] This property corresponds to the focus distance in millimeters 
DEFINE_PROPERTYKEY( WPD_STILL_IMAGE_FOCUS_DISTANCE , 0x58C571EC, 0x1BCB, 0x42A7, 0x8A, 0xC5, 0xBB, 0x29, 0x15, 0x73, 0xA2, 0x60 , 9 ); 
// 
// WPD_STILL_IMAGE_FOCUS_MODE 
//   [ VT_UI4 ] Identifies the focusing mode used by the device for image capture. 
DEFINE_PROPERTYKEY( WPD_STILL_IMAGE_FOCUS_MODE , 0x58C571EC, 0x1BCB, 0x42A7, 0x8A, 0xC5, 0xBB, 0x29, 0x15, 0x73, 0xA2, 0x60 , 10 ); 
// 
// WPD_STILL_IMAGE_EXPOSURE_METERING_MODE 
//   [ VT_UI4 ] Identifies the exposure metering mode used by the device for image capture. 
DEFINE_PROPERTYKEY( WPD_STILL_IMAGE_EXPOSURE_METERING_MODE , 0x58C571EC, 0x1BCB, 0x42A7, 0x8A, 0xC5, 0xBB, 0x29, 0x15, 0x73, 0xA2, 0x60 , 11 ); 
// 
// WPD_STILL_IMAGE_FLASH_MODE 
//   [ VT_UI4 ] 
DEFINE_PROPERTYKEY( WPD_STILL_IMAGE_FLASH_MODE , 0x58C571EC, 0x1BCB, 0x42A7, 0x8A, 0xC5, 0xBB, 0x29, 0x15, 0x73, 0xA2, 0x60 , 12 ); 
// 
// WPD_STILL_IMAGE_EXPOSURE_TIME 
//   [ VT_UI4 ] Controls the shutter speed of the device. 
DEFINE_PROPERTYKEY( WPD_STILL_IMAGE_EXPOSURE_TIME , 0x58C571EC, 0x1BCB, 0x42A7, 0x8A, 0xC5, 0xBB, 0x29, 0x15, 0x73, 0xA2, 0x60 , 13 ); 
// 
// WPD_STILL_IMAGE_EXPOSURE_PROGRAM_MODE 
//   [ VT_UI4 ] Controls the exposure program mode of the device. 
DEFINE_PROPERTYKEY( WPD_STILL_IMAGE_EXPOSURE_PROGRAM_MODE , 0x58C571EC, 0x1BCB, 0x42A7, 0x8A, 0xC5, 0xBB, 0x29, 0x15, 0x73, 0xA2, 0x60 , 14 ); 
// 
// WPD_STILL_IMAGE_EXPOSURE_INDEX 
//   [ VT_UI4 ] Controls the emulation of film speed settings. 
DEFINE_PROPERTYKEY( WPD_STILL_IMAGE_EXPOSURE_INDEX , 0x58C571EC, 0x1BCB, 0x42A7, 0x8A, 0xC5, 0xBB, 0x29, 0x15, 0x73, 0xA2, 0x60 , 15 ); 
// 
// WPD_STILL_IMAGE_EXPOSURE_BIAS_COMPENSATION 
//   [ VT_I4 ] Controls the adjustment of the auto exposure control. 
DEFINE_PROPERTYKEY( WPD_STILL_IMAGE_EXPOSURE_BIAS_COMPENSATION , 0x58C571EC, 0x1BCB, 0x42A7, 0x8A, 0xC5, 0xBB, 0x29, 0x15, 0x73, 0xA2, 0x60 , 16 ); 
// 
// WPD_STILL_IMAGE_CAPTURE_DELAY 
//   [ VT_UI4 ] Controls the amount of time delay between the capture trigger and the actual data capture (in milliseconds). 
DEFINE_PROPERTYKEY( WPD_STILL_IMAGE_CAPTURE_DELAY , 0x58C571EC, 0x1BCB, 0x42A7, 0x8A, 0xC5, 0xBB, 0x29, 0x15, 0x73, 0xA2, 0x60 , 17 ); 
// 
// WPD_STILL_IMAGE_CAPTURE_MODE 
//   [ VT_UI4 ] Controls the type of still image capture. 
DEFINE_PROPERTYKEY( WPD_STILL_IMAGE_CAPTURE_MODE , 0x58C571EC, 0x1BCB, 0x42A7, 0x8A, 0xC5, 0xBB, 0x29, 0x15, 0x73, 0xA2, 0x60 , 18 ); 
// 
// WPD_STILL_IMAGE_CONTRAST 
//   [ VT_UI4 ] Controls the perceived contrast of captured images. 
DEFINE_PROPERTYKEY( WPD_STILL_IMAGE_CONTRAST , 0x58C571EC, 0x1BCB, 0x42A7, 0x8A, 0xC5, 0xBB, 0x29, 0x15, 0x73, 0xA2, 0x60 , 19 ); 
// 
// WPD_STILL_IMAGE_SHARPNESS 
//   [ VT_UI4 ] Controls the perceived sharpness of the captured image. 
DEFINE_PROPERTYKEY( WPD_STILL_IMAGE_SHARPNESS , 0x58C571EC, 0x1BCB, 0x42A7, 0x8A, 0xC5, 0xBB, 0x29, 0x15, 0x73, 0xA2, 0x60 , 20 ); 
// 
// WPD_STILL_IMAGE_DIGITAL_ZOOM 
//   [ VT_UI4 ] Controls the effective zoom ratio of a digital camera's acquired image scaled by a factor of 10. 
DEFINE_PROPERTYKEY( WPD_STILL_IMAGE_DIGITAL_ZOOM , 0x58C571EC, 0x1BCB, 0x42A7, 0x8A, 0xC5, 0xBB, 0x29, 0x15, 0x73, 0xA2, 0x60 , 21 ); 
// 
// WPD_STILL_IMAGE_EFFECT_MODE 
//   [ VT_UI4 ] Controls the special effect mode of the capture. 
DEFINE_PROPERTYKEY( WPD_STILL_IMAGE_EFFECT_MODE , 0x58C571EC, 0x1BCB, 0x42A7, 0x8A, 0xC5, 0xBB, 0x29, 0x15, 0x73, 0xA2, 0x60 , 22 ); 
// 
// WPD_STILL_IMAGE_BURST_NUMBER 
//   [ VT_UI4 ] Controls the number of images that the device will attempt to capture upon initiation of a burst operation. 
DEFINE_PROPERTYKEY( WPD_STILL_IMAGE_BURST_NUMBER , 0x58C571EC, 0x1BCB, 0x42A7, 0x8A, 0xC5, 0xBB, 0x29, 0x15, 0x73, 0xA2, 0x60 , 23 ); 
// 
// WPD_STILL_IMAGE_BURST_INTERVAL 
//   [ VT_UI4 ] Controls the time delay between captures upon initiation of a burst operation. 
DEFINE_PROPERTYKEY( WPD_STILL_IMAGE_BURST_INTERVAL , 0x58C571EC, 0x1BCB, 0x42A7, 0x8A, 0xC5, 0xBB, 0x29, 0x15, 0x73, 0xA2, 0x60 , 24 ); 
// 
// WPD_STILL_IMAGE_TIMELAPSE_NUMBER 
//   [ VT_UI4 ] Controls the number of images that the device will attempt to capture upon initiation of a time-lapse capture. 
DEFINE_PROPERTYKEY( WPD_STILL_IMAGE_TIMELAPSE_NUMBER , 0x58C571EC, 0x1BCB, 0x42A7, 0x8A, 0xC5, 0xBB, 0x29, 0x15, 0x73, 0xA2, 0x60 , 25 ); 
// 
// WPD_STILL_IMAGE_TIMELAPSE_INTERVAL 
//   [ VT_UI4 ] Controls the time delay between captures upon initiation of a time-lapse operation. 
DEFINE_PROPERTYKEY( WPD_STILL_IMAGE_TIMELAPSE_INTERVAL , 0x58C571EC, 0x1BCB, 0x42A7, 0x8A, 0xC5, 0xBB, 0x29, 0x15, 0x73, 0xA2, 0x60 , 26 ); 
// 
// WPD_STILL_IMAGE_FOCUS_METERING_MODE 
//   [ VT_UI4 ] Controls which automatic focus mechanism is used by the device. 
DEFINE_PROPERTYKEY( WPD_STILL_IMAGE_FOCUS_METERING_MODE , 0x58C571EC, 0x1BCB, 0x42A7, 0x8A, 0xC5, 0xBB, 0x29, 0x15, 0x73, 0xA2, 0x60 , 27 ); 
// 
// WPD_STILL_IMAGE_UPLOAD_URL 
//   [ VT_LPWSTR ] Used to describe the URL that the device may use to upload images upon capture. 
DEFINE_PROPERTYKEY( WPD_STILL_IMAGE_UPLOAD_URL , 0x58C571EC, 0x1BCB, 0x42A7, 0x8A, 0xC5, 0xBB, 0x29, 0x15, 0x73, 0xA2, 0x60 , 28 ); 
// 
// WPD_STILL_IMAGE_ARTIST 
//   [ VT_LPWSTR ] Contains the owner/user of the device, which may be inserted as meta-data into any images that are captured. 
DEFINE_PROPERTYKEY( WPD_STILL_IMAGE_ARTIST , 0x58C571EC, 0x1BCB, 0x42A7, 0x8A, 0xC5, 0xBB, 0x29, 0x15, 0x73, 0xA2, 0x60 , 29 ); 

/**************************************************************************** 
* This section defines all Commands, Parameters and Options associated with: 
* WPD_SMS_OBJECT_PROPERTIES_V1 
* 
* This category is for properties common to all objects whose functional category is WPD_FUNCTIONAL_CATEGORY_SMS 
****************************************************************************/ 
DEFINE_GUID( WPD_SMS_OBJECT_PROPERTIES_V1 , 0x7E1074CC, 0x50FF, 0x4DD1, 0xA7, 0x42, 0x53, 0xBE, 0x6F, 0x09, 0x3A, 0x0D ); 

// 
// WPD_SMS_PROVIDER 
//   [ VT_LPWSTR ] Indicates the service provider name. 
DEFINE_PROPERTYKEY( WPD_SMS_PROVIDER , 0x7E1074CC, 0x50FF, 0x4DD1, 0xA7, 0x42, 0x53, 0xBE, 0x6F, 0x09, 0x3A, 0x0D , 2 ); 
// 
// WPD_SMS_TIMEOUT 
//   [ VT_UI4 ] Indicates the number of milliseconds until a timeout is returned. 
DEFINE_PROPERTYKEY( WPD_SMS_TIMEOUT , 0x7E1074CC, 0x50FF, 0x4DD1, 0xA7, 0x42, 0x53, 0xBE, 0x6F, 0x09, 0x3A, 0x0D , 3 ); 
// 
// WPD_SMS_MAX_PAYLOAD 
//   [ VT_UI4 ] Indicates the maximum number of bytes that can be contained in a message. 
DEFINE_PROPERTYKEY( WPD_SMS_MAX_PAYLOAD , 0x7E1074CC, 0x50FF, 0x4DD1, 0xA7, 0x42, 0x53, 0xBE, 0x6F, 0x09, 0x3A, 0x0D , 4 ); 
// 
// WPD_SMS_ENCODING 
//   [ VT_UI4 ] Indicates how the driver will encode the text message sent by the client. 
DEFINE_PROPERTYKEY( WPD_SMS_ENCODING , 0x7E1074CC, 0x50FF, 0x4DD1, 0xA7, 0x42, 0x53, 0xBE, 0x6F, 0x09, 0x3A, 0x0D , 5 ); 

/**************************************************************************** 
* This section defines all Commands, Parameters and Options associated with: 
* WPD_SECTION_OBJECT_PROPERTIES_V1 
* 
* This category is for properties common to all objects whose content type is WPD_CONTENT_TYPE_SECTION 
****************************************************************************/ 
DEFINE_GUID( WPD_SECTION_OBJECT_PROPERTIES_V1 , 0x516AFD2B, 0xC64E, 0x44F0, 0x98, 0xDC, 0xBE, 0xE1, 0xC8, 0x8F, 0x7D, 0x66 ); 

// 
// WPD_SECTION_DATA_OFFSET 
//   [ VT_UI8 ] Indicates the zero-based offset of the data for the referenced object. 
DEFINE_PROPERTYKEY( WPD_SECTION_DATA_OFFSET , 0x516AFD2B, 0xC64E, 0x44F0, 0x98, 0xDC, 0xBE, 0xE1, 0xC8, 0x8F, 0x7D, 0x66 , 2 ); 
// 
// WPD_SECTION_DATA_LENGTH 
//   [ VT_UI8 ] Indicates the length of data for the referenced object. 
DEFINE_PROPERTYKEY( WPD_SECTION_DATA_LENGTH , 0x516AFD2B, 0xC64E, 0x44F0, 0x98, 0xDC, 0xBE, 0xE1, 0xC8, 0x8F, 0x7D, 0x66 , 3 ); 
// 
// WPD_SECTION_DATA_UNITS 
//   [ VT_UI4 ] Indicates the units for WPD_SECTION_DATA_OFFSET and WPD_SECTION_DATA_LENGTH properties on this object (e.g. offset in bytes, offset in milliseconds etc.). 
DEFINE_PROPERTYKEY( WPD_SECTION_DATA_UNITS , 0x516AFD2B, 0xC64E, 0x44F0, 0x98, 0xDC, 0xBE, 0xE1, 0xC8, 0x8F, 0x7D, 0x66 , 4 ); 
// 
// WPD_SECTION_DATA_REFERENCED_OBJECT_RESOURCE 
//   [ VT_UNKNOWN ] This is an IPortableDeviceKeyCollection containing a single value, which is the key identifying the resource on the referenced object which the WPD_SECTION_DATA_OFFSET and WPD_SECTION_DATA_LENGTH apply to. 
DEFINE_PROPERTYKEY( WPD_SECTION_DATA_REFERENCED_OBJECT_RESOURCE , 0x516AFD2B, 0xC64E, 0x44F0, 0x98, 0xDC, 0xBE, 0xE1, 0xC8, 0x8F, 0x7D, 0x66 , 5 ); 

/**************************************************************************** 
* This section defines all Commands, Parameters and Options associated with: 
* WPD_RENDERING_INFORMATION_OBJECT_PROPERTIES_V1 
* 
* This category is for properties common to all objects whose functional category is WPD_FUNCTIONAL_CATEGORY_AUDIO_RENDERING_INFORMATION 
****************************************************************************/ 
DEFINE_GUID( WPD_RENDERING_INFORMATION_OBJECT_PROPERTIES_V1 , 0xC53D039F, 0xEE23, 0x4A31, 0x85, 0x90, 0x76, 0x39, 0x87, 0x98, 0x70, 0xB4 ); 

// 
// WPD_RENDERING_INFORMATION_PROFILES 
//   [ VT_UNKNOWN ] IPortableDeviceValuesCollection, where each element indicates the property settings for a supported profile. 
DEFINE_PROPERTYKEY( WPD_RENDERING_INFORMATION_PROFILES , 0xC53D039F, 0xEE23, 0x4A31, 0x85, 0x90, 0x76, 0x39, 0x87, 0x98, 0x70, 0xB4 , 2 ); 
// 
// WPD_RENDERING_INFORMATION_PROFILE_ENTRY_TYPE 
//   [ VT_UI4 ] Indicates whether a given entry (i.e. an IPortableDeviceValues) in WPD_RENDERING_INFORMATION_PROFILES relates to an Object or a Resource. 
DEFINE_PROPERTYKEY( WPD_RENDERING_INFORMATION_PROFILE_ENTRY_TYPE , 0xC53D039F, 0xEE23, 0x4A31, 0x85, 0x90, 0x76, 0x39, 0x87, 0x98, 0x70, 0xB4 , 3 ); 
// 
// WPD_RENDERING_INFORMATION_PROFILE_ENTRY_CREATABLE_RESOURCES 
//   [ VT_UNKNOWN ] This is an IPortableDeviceKeyCollection identifying the resources that can be created on an object with this rendering profile. 
DEFINE_PROPERTYKEY( WPD_RENDERING_INFORMATION_PROFILE_ENTRY_CREATABLE_RESOURCES , 0xC53D039F, 0xEE23, 0x4A31, 0x85, 0x90, 0x76, 0x39, 0x87, 0x98, 0x70, 0xB4 , 4 ); 

/**************************************************************************** 
* This section defines all Commands, Parameters and Options associated with: 
* WPD_CLIENT_INFORMATION_PROPERTIES_V1 
* 
* 
****************************************************************************/ 
DEFINE_GUID( WPD_CLIENT_INFORMATION_PROPERTIES_V1 , 0x204D9F0C, 0x2292, 0x4080, 0x9F, 0x42, 0x40, 0x66, 0x4E, 0x70, 0xF8, 0x59 ); 

// 
// WPD_CLIENT_NAME 
//   [ VT_LPWSTR ] Specifies the name the client uses to identify itself. 
DEFINE_PROPERTYKEY( WPD_CLIENT_NAME , 0x204D9F0C, 0x2292, 0x4080, 0x9F, 0x42, 0x40, 0x66, 0x4E, 0x70, 0xF8, 0x59 , 2 ); 
// 
// WPD_CLIENT_MAJOR_VERSION 
//   [ VT_UI4 ] Specifies the major version of the client. 
DEFINE_PROPERTYKEY( WPD_CLIENT_MAJOR_VERSION , 0x204D9F0C, 0x2292, 0x4080, 0x9F, 0x42, 0x40, 0x66, 0x4E, 0x70, 0xF8, 0x59 , 3 ); 
// 
// WPD_CLIENT_MINOR_VERSION 
//   [ VT_UI4 ] Specifies the major version of the client. 
DEFINE_PROPERTYKEY( WPD_CLIENT_MINOR_VERSION , 0x204D9F0C, 0x2292, 0x4080, 0x9F, 0x42, 0x40, 0x66, 0x4E, 0x70, 0xF8, 0x59 , 4 ); 
// 
// WPD_CLIENT_REVISION 
//   [ VT_UI4 ] Specifies the revision (or build number) of the client. 
DEFINE_PROPERTYKEY( WPD_CLIENT_REVISION , 0x204D9F0C, 0x2292, 0x4080, 0x9F, 0x42, 0x40, 0x66, 0x4E, 0x70, 0xF8, 0x59 , 5 ); 
// 
// WPD_CLIENT_WMDRM_APPLICATION_PRIVATE_KEY 
//   [ VT_VECTOR | VT_UI1 ] Specifies the Windows Media DRM application private key of the client. 
DEFINE_PROPERTYKEY( WPD_CLIENT_WMDRM_APPLICATION_PRIVATE_KEY , 0x204D9F0C, 0x2292, 0x4080, 0x9F, 0x42, 0x40, 0x66, 0x4E, 0x70, 0xF8, 0x59 , 6 ); 
// 
// WPD_CLIENT_WMDRM_APPLICATION_CERTIFICATE 
//   [ VT_VECTOR | VT_UI1 ] Specifies the Windows Media DRM application certificate of the client. 
DEFINE_PROPERTYKEY( WPD_CLIENT_WMDRM_APPLICATION_CERTIFICATE , 0x204D9F0C, 0x2292, 0x4080, 0x9F, 0x42, 0x40, 0x66, 0x4E, 0x70, 0xF8, 0x59 , 7 ); 
// 
// WPD_CLIENT_SECURITY_QUALITY_OF_SERVICE 
//   [ VT_UI4 ] Specifies the Security Quality of Service for the connection to the driver. This relates to the Security Quality of Service flags for CreateFile. For example, these allow or disallow a driver to impersonate the client. 
DEFINE_PROPERTYKEY( WPD_CLIENT_SECURITY_QUALITY_OF_SERVICE , 0x204D9F0C, 0x2292, 0x4080, 0x9F, 0x42, 0x40, 0x66, 0x4E, 0x70, 0xF8, 0x59 , 8 ); 
// 
// WPD_CLIENT_DESIRED_ACCESS 
//   [ VT_UI4 ] Specifies the desired access the client is requesting to this driver. The possible values are the same as for CreateFile (e.g. GENERIC_READ, GENERIC_WRITE etc.). 
DEFINE_PROPERTYKEY( WPD_CLIENT_DESIRED_ACCESS , 0x204D9F0C, 0x2292, 0x4080, 0x9F, 0x42, 0x40, 0x66, 0x4E, 0x70, 0xF8, 0x59 , 9 ); 
// 
// WPD_CLIENT_SHARE_MODE 
//   [ VT_UI4 ] Specifies the share mode the client is requesting to this driver. The possible values are the same as for CreateFile (e.g. FILE_SHARE_READ, FILE_SHARE_WRITE etc.). 
DEFINE_PROPERTYKEY( WPD_CLIENT_SHARE_MODE , 0x204D9F0C, 0x2292, 0x4080, 0x9F, 0x42, 0x40, 0x66, 0x4E, 0x70, 0xF8, 0x59 , 10 ); 
// 
// WPD_CLIENT_EVENT_COOKIE 
//   [ VT_LPWSTR ] Client supplied cookie returned by the driver in events posted as a direct result of operations issued by this client. 
DEFINE_PROPERTYKEY( WPD_CLIENT_EVENT_COOKIE , 0x204D9F0C, 0x2292, 0x4080, 0x9F, 0x42, 0x40, 0x66, 0x4E, 0x70, 0xF8, 0x59 , 11 ); 

/**************************************************************************** 
* This section defines all Commands, Parameters and Options associated with: 
* WPD_PROPERTY_ATTRIBUTES_V1 
* 
* 
****************************************************************************/ 
DEFINE_GUID( WPD_PROPERTY_ATTRIBUTES_V1 , 0xAB7943D8, 0x6332, 0x445F, 0xA0, 0x0D, 0x8D, 0x5E, 0xF1, 0xE9, 0x6F, 0x37 ); 

// 
// WPD_PROPERTY_ATTRIBUTE_FORM 
//   [ VT_UI4 ] Specifies the form of the valid values allowed for this property. 
DEFINE_PROPERTYKEY( WPD_PROPERTY_ATTRIBUTE_FORM , 0xAB7943D8, 0x6332, 0x445F, 0xA0, 0x0D, 0x8D, 0x5E, 0xF1, 0xE9, 0x6F, 0x37 , 2 ); 
// 
// WPD_PROPERTY_ATTRIBUTE_CAN_READ 
//   [ VT_BOOL ] Indicates whether client applications have permission to Read the property. 
DEFINE_PROPERTYKEY( WPD_PROPERTY_ATTRIBUTE_CAN_READ , 0xAB7943D8, 0x6332, 0x445F, 0xA0, 0x0D, 0x8D, 0x5E, 0xF1, 0xE9, 0x6F, 0x37 , 3 ); 
// 
// WPD_PROPERTY_ATTRIBUTE_CAN_WRITE 
//   [ VT_BOOL ] Indicates whether client applications have permission to Write the property. 
DEFINE_PROPERTYKEY( WPD_PROPERTY_ATTRIBUTE_CAN_WRITE , 0xAB7943D8, 0x6332, 0x445F, 0xA0, 0x0D, 0x8D, 0x5E, 0xF1, 0xE9, 0x6F, 0x37 , 4 ); 
// 
// WPD_PROPERTY_ATTRIBUTE_CAN_DELETE 
//   [ VT_BOOL ] Indicates whether client applications have permission to Delete the property. 
DEFINE_PROPERTYKEY( WPD_PROPERTY_ATTRIBUTE_CAN_DELETE , 0xAB7943D8, 0x6332, 0x445F, 0xA0, 0x0D, 0x8D, 0x5E, 0xF1, 0xE9, 0x6F, 0x37 , 5 ); 
// 
// WPD_PROPERTY_ATTRIBUTE_DEFAULT_VALUE 
//   [ VT_XXXX ] Specifies the default value for a write-able property. 
DEFINE_PROPERTYKEY( WPD_PROPERTY_ATTRIBUTE_DEFAULT_VALUE , 0xAB7943D8, 0x6332, 0x445F, 0xA0, 0x0D, 0x8D, 0x5E, 0xF1, 0xE9, 0x6F, 0x37 , 6 ); 
// 
// WPD_PROPERTY_ATTRIBUTE_FAST_PROPERTY 
//   [ VT_BOOL ] If True, then this property belongs to the PORTABLE_DEVICE_FAST_PROPERTIES group.
DEFINE_PROPERTYKEY( WPD_PROPERTY_ATTRIBUTE_FAST_PROPERTY , 0xAB7943D8, 0x6332, 0x445F, 0xA0, 0x0D, 0x8D, 0x5E, 0xF1, 0xE9, 0x6F, 0x37 , 7 ); 
// 
// WPD_PROPERTY_ATTRIBUTE_RANGE_MIN 
//   [ VT_XXXX ] The minimum value for a property whose form is of WPD_PROPERTY_ATTRIBUTE_FORM_RANGE.
DEFINE_PROPERTYKEY( WPD_PROPERTY_ATTRIBUTE_RANGE_MIN , 0xAB7943D8, 0x6332, 0x445F, 0xA0, 0x0D, 0x8D, 0x5E, 0xF1, 0xE9, 0x6F, 0x37 , 8 ); 
// 
// WPD_PROPERTY_ATTRIBUTE_RANGE_MAX 
//   [ VT_XXXX ] The maximum value for a property whose form is of WPD_PROPERTY_ATTRIBUTE_FORM_RANGE.
DEFINE_PROPERTYKEY( WPD_PROPERTY_ATTRIBUTE_RANGE_MAX , 0xAB7943D8, 0x6332, 0x445F, 0xA0, 0x0D, 0x8D, 0x5E, 0xF1, 0xE9, 0x6F, 0x37 , 9 ); 
// 
// WPD_PROPERTY_ATTRIBUTE_RANGE_STEP 
//   [ VT_XXXX ] The step value for a property whose form is of WPD_PROPERTY_ATTRIBUTE_FORM_RANGE.
DEFINE_PROPERTYKEY( WPD_PROPERTY_ATTRIBUTE_RANGE_STEP , 0xAB7943D8, 0x6332, 0x445F, 0xA0, 0x0D, 0x8D, 0x5E, 0xF1, 0xE9, 0x6F, 0x37 , 10 ); 
// 
// WPD_PROPERTY_ATTRIBUTE_ENUMERATION_ELEMENTS 
//   [ VT_UNKNOWN ] An IPortableDevicePropVariantCollection containing the enumeration values. 
DEFINE_PROPERTYKEY( WPD_PROPERTY_ATTRIBUTE_ENUMERATION_ELEMENTS , 0xAB7943D8, 0x6332, 0x445F, 0xA0, 0x0D, 0x8D, 0x5E, 0xF1, 0xE9, 0x6F, 0x37 , 11 ); 
// 
// WPD_PROPERTY_ATTRIBUTE_REGULAR_EXPRESSION 
//   [ VT_LPWSTR ] A regular expression string indicating acceptable values for properties whose form is WPD_PROPERTY_ATTRIBUTE_FORM_REGULAR_EXPRESSION. 
DEFINE_PROPERTYKEY( WPD_PROPERTY_ATTRIBUTE_REGULAR_EXPRESSION , 0xAB7943D8, 0x6332, 0x445F, 0xA0, 0x0D, 0x8D, 0x5E, 0xF1, 0xE9, 0x6F, 0x37 , 12 ); 
// 
// WPD_PROPERTY_ATTRIBUTE_MAX_SIZE 
//   [ VT_UI8 ] This indicates the maximum size (in bytes) for the value of this property. 
DEFINE_PROPERTYKEY( WPD_PROPERTY_ATTRIBUTE_MAX_SIZE , 0xAB7943D8, 0x6332, 0x445F, 0xA0, 0x0D, 0x8D, 0x5E, 0xF1, 0xE9, 0x6F, 0x37 , 13 ); 

/**************************************************************************** 
* This section defines all Commands, Parameters and Options associated with: 
* WPD_CLASS_EXTENSION_OPTIONS_V1 
* 
* This category of properties relates to options used for the WPD device class extension 
****************************************************************************/ 
DEFINE_GUID( WPD_CLASS_EXTENSION_OPTIONS_V1 , 0x6309FFEF, 0xA87C, 0x4CA7, 0x84, 0x34, 0x79, 0x75, 0x76, 0xE4, 0x0A, 0x96 ); 

// 
// WPD_CLASS_EXTENSION_OPTIONS_SUPPORTED_CONTENT_TYPES 
//   [ VT_UNKNOWN ] Indicates the (super-set) list of content types supported by the driver (similar to calling WPD_COMMAND_CAPABILITIES_GET_SUPPORTED_CONTENT_TYPES on WPD_FUNCTIONAL_CATEGORY_ALL). 
DEFINE_PROPERTYKEY( WPD_CLASS_EXTENSION_OPTIONS_SUPPORTED_CONTENT_TYPES , 0x6309FFEF, 0xA87C, 0x4CA7, 0x84, 0x34, 0x79, 0x75, 0x76, 0xE4, 0x0A, 0x96 , 2 ); 
// 
// WPD_CLASS_EXTENSION_OPTIONS_DONT_REGISTER_WPD_DEVICE_INTERFACE 
//   [ VT_BOOL ] Indicates that the caller does not want the WPD class extension library to register the WPD Device Class interface. The caller will take responsibility for doing it. 
DEFINE_PROPERTYKEY( WPD_CLASS_EXTENSION_OPTIONS_DONT_REGISTER_WPD_DEVICE_INTERFACE , 0x6309FFEF, 0xA87C, 0x4CA7, 0x84, 0x34, 0x79, 0x75, 0x76, 0xE4, 0x0A, 0x96 , 3 ); 
// 
// WPD_CLASS_EXTENSION_OPTIONS_REGISTER_WPD_PRIVATE_DEVICE_INTERFACE 
//   [ VT_BOOL ] Indicates that the caller wants the WPD class extension library to register the private WPD Device Class interface. 
DEFINE_PROPERTYKEY( WPD_CLASS_EXTENSION_OPTIONS_REGISTER_WPD_PRIVATE_DEVICE_INTERFACE , 0x6309FFEF, 0xA87C, 0x4CA7, 0x84, 0x34, 0x79, 0x75, 0x76, 0xE4, 0x0A, 0x96 , 4 ); 

/**************************************************************************** 
* This section defines all Commands, Parameters and Options associated with: 
* WPD_RESOURCE_ATTRIBUTES_V1 
* 
* 
****************************************************************************/ 
DEFINE_GUID( WPD_RESOURCE_ATTRIBUTES_V1 , 0x1EB6F604, 0x9278, 0x429F, 0x93, 0xCC, 0x5B, 0xB8, 0xC0, 0x66, 0x56, 0xB6 ); 

// 
// WPD_RESOURCE_ATTRIBUTE_TOTAL_SIZE 
//   [ VT_UI8 ] Total size in bytes of the resource data. 
DEFINE_PROPERTYKEY( WPD_RESOURCE_ATTRIBUTE_TOTAL_SIZE , 0x1EB6F604, 0x9278, 0x429F, 0x93, 0xCC, 0x5B, 0xB8, 0xC0, 0x66, 0x56, 0xB6 , 2 ); 
// 
// WPD_RESOURCE_ATTRIBUTE_CAN_READ 
//   [ VT_BOOL ] Indicates whether client applications have permission to open the resource for Read access. 
DEFINE_PROPERTYKEY( WPD_RESOURCE_ATTRIBUTE_CAN_READ , 0x1EB6F604, 0x9278, 0x429F, 0x93, 0xCC, 0x5B, 0xB8, 0xC0, 0x66, 0x56, 0xB6 , 3 ); 
// 
// WPD_RESOURCE_ATTRIBUTE_CAN_WRITE 
//   [ VT_BOOL ] Indicates whether client applications have permission to open the resource for Write access. 
DEFINE_PROPERTYKEY( WPD_RESOURCE_ATTRIBUTE_CAN_WRITE , 0x1EB6F604, 0x9278, 0x429F, 0x93, 0xCC, 0x5B, 0xB8, 0xC0, 0x66, 0x56, 0xB6 , 4 ); 
// 
// WPD_RESOURCE_ATTRIBUTE_CAN_DELETE 
//   [ VT_BOOL ] Indicates whether client applications have permission to Delete a resource from the device. 
DEFINE_PROPERTYKEY( WPD_RESOURCE_ATTRIBUTE_CAN_DELETE , 0x1EB6F604, 0x9278, 0x429F, 0x93, 0xCC, 0x5B, 0xB8, 0xC0, 0x66, 0x56, 0xB6 , 5 ); 
// 
// WPD_RESOURCE_ATTRIBUTE_OPTIMAL_READ_BUFFER_SIZE 
//   [ VT_UI4 ] The recommended buffer size a caller should use when doing buffered reads on the resource. 
DEFINE_PROPERTYKEY( WPD_RESOURCE_ATTRIBUTE_OPTIMAL_READ_BUFFER_SIZE , 0x1EB6F604, 0x9278, 0x429F, 0x93, 0xCC, 0x5B, 0xB8, 0xC0, 0x66, 0x56, 0xB6 , 6 ); 
// 
// WPD_RESOURCE_ATTRIBUTE_OPTIMAL_WRITE_BUFFER_SIZE 
//   [ VT_UI4 ] The recommended buffer size a caller should use when doing buffered writes on the resource. 
DEFINE_PROPERTYKEY( WPD_RESOURCE_ATTRIBUTE_OPTIMAL_WRITE_BUFFER_SIZE , 0x1EB6F604, 0x9278, 0x429F, 0x93, 0xCC, 0x5B, 0xB8, 0xC0, 0x66, 0x56, 0xB6 , 7 ); 
// 
// WPD_RESOURCE_ATTRIBUTE_FORMAT 
//   [ VT_CLSID ] Indicates the format of the resource data. 
DEFINE_PROPERTYKEY( WPD_RESOURCE_ATTRIBUTE_FORMAT , 0x1EB6F604, 0x9278, 0x429F, 0x93, 0xCC, 0x5B, 0xB8, 0xC0, 0x66, 0x56, 0xB6 , 8 ); 
// 
// WPD_RESOURCE_ATTRIBUTE_RESOURCE_KEY 
//   [ VT_UNKNOWN ] This is an IPortableDeviceKeyCollection containing a single value, which is the key identifying the resource. 
DEFINE_PROPERTYKEY( WPD_RESOURCE_ATTRIBUTE_RESOURCE_KEY , 0x1EB6F604, 0x9278, 0x429F, 0x93, 0xCC, 0x5B, 0xB8, 0xC0, 0x66, 0x56, 0xB6 , 9 ); 

/**************************************************************************** 
* This section defines all Commands, Parameters and Options associated with: 
* WPD_DEVICE_PROPERTIES_V1 
* 
* 
****************************************************************************/ 
DEFINE_GUID( WPD_DEVICE_PROPERTIES_V1 , 0x26D4979A, 0xE643, 0x4626, 0x9E, 0x2B, 0x73, 0x6D, 0xC0, 0xC9, 0x2F, 0xDC ); 

// 
// WPD_DEVICE_SYNC_PARTNER 
//   [ VT_LPWSTR ] Indicates a human-readable description of a synchronization partner for the device. 
DEFINE_PROPERTYKEY( WPD_DEVICE_SYNC_PARTNER , 0x26D4979A, 0xE643, 0x4626, 0x9E, 0x2B, 0x73, 0x6D, 0xC0, 0xC9, 0x2F, 0xDC , 2 ); 
// 
// WPD_DEVICE_FIRMWARE_VERSION 
//   [ VT_LPWSTR ] Indicates the firmware version for the device. 
DEFINE_PROPERTYKEY( WPD_DEVICE_FIRMWARE_VERSION , 0x26D4979A, 0xE643, 0x4626, 0x9E, 0x2B, 0x73, 0x6D, 0xC0, 0xC9, 0x2F, 0xDC , 3 ); 
// 
// WPD_DEVICE_POWER_LEVEL 
//   [ VT_UI4 ] Indicates the power level of the device's battery. 
DEFINE_PROPERTYKEY( WPD_DEVICE_POWER_LEVEL , 0x26D4979A, 0xE643, 0x4626, 0x9E, 0x2B, 0x73, 0x6D, 0xC0, 0xC9, 0x2F, 0xDC , 4 ); 
// 
// WPD_DEVICE_POWER_SOURCE 
//   [ VT_UI4 ] Indicates the power source of the device e.g. whether it is battery or external. 
DEFINE_PROPERTYKEY( WPD_DEVICE_POWER_SOURCE , 0x26D4979A, 0xE643, 0x4626, 0x9E, 0x2B, 0x73, 0x6D, 0xC0, 0xC9, 0x2F, 0xDC , 5 ); 
// 
// WPD_DEVICE_PROTOCOL 
//   [ VT_LPWSTR ] Identifies the device protocol being used. 
DEFINE_PROPERTYKEY( WPD_DEVICE_PROTOCOL , 0x26D4979A, 0xE643, 0x4626, 0x9E, 0x2B, 0x73, 0x6D, 0xC0, 0xC9, 0x2F, 0xDC , 6 ); 
// 
// WPD_DEVICE_MANUFACTURER 
//   [ VT_LPWSTR ] Identifies the device manufacturer. 
DEFINE_PROPERTYKEY( WPD_DEVICE_MANUFACTURER , 0x26D4979A, 0xE643, 0x4626, 0x9E, 0x2B, 0x73, 0x6D, 0xC0, 0xC9, 0x2F, 0xDC , 7 ); 
// 
// WPD_DEVICE_MODEL 
//   [ VT_LPWSTR ] Identifies the device model. 
DEFINE_PROPERTYKEY( WPD_DEVICE_MODEL , 0x26D4979A, 0xE643, 0x4626, 0x9E, 0x2B, 0x73, 0x6D, 0xC0, 0xC9, 0x2F, 0xDC , 8 ); 
// 
// WPD_DEVICE_SERIAL_NUMBER 
//   [ VT_LPWSTR ] Identifies the serial number of the device. 
DEFINE_PROPERTYKEY( WPD_DEVICE_SERIAL_NUMBER , 0x26D4979A, 0xE643, 0x4626, 0x9E, 0x2B, 0x73, 0x6D, 0xC0, 0xC9, 0x2F, 0xDC , 9 ); 
// 
// WPD_DEVICE_SUPPORTS_NON_CONSUMABLE 
//   [ VT_BOOL ] Indicates whether the device supports non-consumable objects. 
DEFINE_PROPERTYKEY( WPD_DEVICE_SUPPORTS_NON_CONSUMABLE , 0x26D4979A, 0xE643, 0x4626, 0x9E, 0x2B, 0x73, 0x6D, 0xC0, 0xC9, 0x2F, 0xDC , 10 ); 
// 
// WPD_DEVICE_DATETIME 
//   [ VT_DATE ] Represents the current date and time settings of the device. 
DEFINE_PROPERTYKEY( WPD_DEVICE_DATETIME , 0x26D4979A, 0xE643, 0x4626, 0x9E, 0x2B, 0x73, 0x6D, 0xC0, 0xC9, 0x2F, 0xDC , 11 ); 
// 
// WPD_DEVICE_FRIENDLY_NAME 
//   [ VT_LPWSTR ] Represents the friendly name set by the user on the device. 
DEFINE_PROPERTYKEY( WPD_DEVICE_FRIENDLY_NAME , 0x26D4979A, 0xE643, 0x4626, 0x9E, 0x2B, 0x73, 0x6D, 0xC0, 0xC9, 0x2F, 0xDC , 12 ); 
// 
// WPD_DEVICE_SUPPORTED_DRM_SCHEMES 
//   [ VT_UNKNOWN ] An IPortableDevicePropVariantCollection of VT_LPWSTR values indicating the Digital Rights Management schemes supported by the driver. 
DEFINE_PROPERTYKEY( WPD_DEVICE_SUPPORTED_DRM_SCHEMES , 0x26D4979A, 0xE643, 0x4626, 0x9E, 0x2B, 0x73, 0x6D, 0xC0, 0xC9, 0x2F, 0xDC , 13 ); 
// 
// WPD_DEVICE_SUPPORTED_FORMATS_ARE_ORDERED 
//   [ VT_BOOL ] Indicates whether the supported formats returned from the device are in a preferred order. (First format in the list is most preferred by the device, while the last is the least preferred.) 
DEFINE_PROPERTYKEY( WPD_DEVICE_SUPPORTED_FORMATS_ARE_ORDERED , 0x26D4979A, 0xE643, 0x4626, 0x9E, 0x2B, 0x73, 0x6D, 0xC0, 0xC9, 0x2F, 0xDC , 14 ); 
// 
// WPD_DEVICE_TYPE 
//   [ VT_UI4 ] Indicates the device type, used for representation purposes only. Functional characteristics of the device are decided through functional objects. 
DEFINE_PROPERTYKEY( WPD_DEVICE_TYPE , 0x26D4979A, 0xE643, 0x4626, 0x9E, 0x2B, 0x73, 0x6D, 0xC0, 0xC9, 0x2F, 0xDC , 15 ); 
// 
// WPD_DEVICE_NETWORK_IDENTIFIER 
//   [ VT_UI8 ] Indicates the EUI-64 network identifier of the device, used for out-of-band Network Association operations. 
DEFINE_PROPERTYKEY( WPD_DEVICE_NETWORK_IDENTIFIER , 0x26D4979A, 0xE643, 0x4626, 0x9E, 0x2B, 0x73, 0x6D, 0xC0, 0xC9, 0x2F, 0xDC , 16 ); 

/**************************************************************************** 
* This section defines all Commands, Parameters and Options associated with: 
* WPD_EVENT_PROPERTIES_V1 
* 
* The properties in this category are for properties that may be needed for event processing, but do not have object property equivalents (i.e. they are not exposed as object properties, but rather, used only as event parameters).
****************************************************************************/ 
DEFINE_GUID( WPD_EVENT_PROPERTIES_V1 , 0x15AB1953, 0xF817, 0x4FEF, 0xA9, 0x21, 0x56, 0x76, 0xE8, 0x38, 0xF6, 0xE0 ); 

// 
// WPD_EVENT_PARAMETER_PNP_DEVICE_ID 
//   [ VT_LPWSTR ] Indicates the device that originated the event. 
DEFINE_PROPERTYKEY( WPD_EVENT_PARAMETER_PNP_DEVICE_ID , 0x15AB1953, 0xF817, 0x4FEF, 0xA9, 0x21, 0x56, 0x76, 0xE8, 0x38, 0xF6, 0xE0 , 2 ); 
// 
// WPD_EVENT_PARAMETER_EVENT_ID 
//   [ VT_CLSID ] Indicates the event sent. 
DEFINE_PROPERTYKEY( WPD_EVENT_PARAMETER_EVENT_ID , 0x15AB1953, 0xF817, 0x4FEF, 0xA9, 0x21, 0x56, 0x76, 0xE8, 0x38, 0xF6, 0xE0 , 3 ); 
// 
// WPD_EVENT_PARAMETER_OPERATION_STATE 
//   [ VT_UI4 ] Indicates the current state of the operation (e.g. started, running, stopped etc.). 
DEFINE_PROPERTYKEY( WPD_EVENT_PARAMETER_OPERATION_STATE , 0x15AB1953, 0xF817, 0x4FEF, 0xA9, 0x21, 0x56, 0x76, 0xE8, 0x38, 0xF6, 0xE0 , 4 ); 
// 
// WPD_EVENT_PARAMETER_OPERATION_PROGRESS 
//   [ VT_UI4 ] Indicates the progress of a currently executing operation. Value is from 0 to 100, with 100 indicating that the operation is complete. 
DEFINE_PROPERTYKEY( WPD_EVENT_PARAMETER_OPERATION_PROGRESS , 0x15AB1953, 0xF817, 0x4FEF, 0xA9, 0x21, 0x56, 0x76, 0xE8, 0x38, 0xF6, 0xE0 , 5 ); 
// 
// WPD_EVENT_PARAMETER_OBJECT_PARENT_PERSISTENT_UNIQUE_ID 
//   [ VT_LPWSTR ] Uniquely identifies the parent object, similar to WPD_OBJECT_PARENT_ID, but this ID will not change between sessions. 
DEFINE_PROPERTYKEY( WPD_EVENT_PARAMETER_OBJECT_PARENT_PERSISTENT_UNIQUE_ID , 0x15AB1953, 0xF817, 0x4FEF, 0xA9, 0x21, 0x56, 0x76, 0xE8, 0x38, 0xF6, 0xE0 , 6 ); 
// 
// WPD_EVENT_PARAMETER_OBJECT_CREATION_COOKIE 
//   [ VT_LPWSTR ] This is the cookie handed back to a client when it requested an object creation using the IPortableDeviceContent::CreateObjectWithPropertiesAndData method. 
DEFINE_PROPERTYKEY( WPD_EVENT_PARAMETER_OBJECT_CREATION_COOKIE , 0x15AB1953, 0xF817, 0x4FEF, 0xA9, 0x21, 0x56, 0x76, 0xE8, 0x38, 0xF6, 0xE0 , 7 ); 
// 
// WPD_EVENT_PARAMETER_CHILD_HIERARCHY_CHANGED 
//   [ VT_BOOL ] Indicates that the child hiearchy for the object has changed. 
DEFINE_PROPERTYKEY( WPD_EVENT_PARAMETER_CHILD_HIERARCHY_CHANGED , 0x15AB1953, 0xF817, 0x4FEF, 0xA9, 0x21, 0x56, 0x76, 0xE8, 0x38, 0xF6, 0xE0 , 8 ); 

/**************************************************************************** 
* This section defines all Commands, Parameters and Options associated with: 
* WPD_EVENT_OPTIONS_V1 
* 
* The properties in this category describe event options.
****************************************************************************/ 
DEFINE_GUID( WPD_EVENT_OPTIONS_V1 , 0xB3D8DAD7, 0xA361, 0x4B83, 0x8A, 0x48, 0x5B, 0x02, 0xCE, 0x10, 0x71, 0x3B ); 

// 
// WPD_EVENT_OPTION_IS_BROADCAST_EVENT 
//   [ VT_BOOL ] Indicates that the event is broadcast to all clients. 
DEFINE_PROPERTYKEY( WPD_EVENT_OPTION_IS_BROADCAST_EVENT , 0xB3D8DAD7, 0xA361, 0x4B83, 0x8A, 0x48, 0x5B, 0x02, 0xCE, 0x10, 0x71, 0x3B , 2 ); 
// 
// WPD_EVENT_OPTION_IS_AUTOPLAY_EVENT 
//   [ VT_BOOL ] Indicates that the event is sent to and handled by Autoplay. 
DEFINE_PROPERTYKEY( WPD_EVENT_OPTION_IS_AUTOPLAY_EVENT , 0xB3D8DAD7, 0xA361, 0x4B83, 0x8A, 0x48, 0x5B, 0x02, 0xCE, 0x10, 0x71, 0x3B , 3 ); 

/**************************************************************************** 
* This section defines all Commands, Parameters and Options associated with: 
* WPD_API_OPTIONS_V1 
* 
* The properties in this category describe API options.
****************************************************************************/ 
DEFINE_GUID( WPD_API_OPTIONS_V1 , 0x10E54A3E, 0x052D, 0x4777, 0xA1, 0x3C, 0xDE, 0x76, 0x14, 0xBE, 0x2B, 0xC4 ); 

// 
// WPD_API_OPTION_USE_CLEAR_DATA_STREAM 
//   [ VT_BOOL ] Indicates that the data stream created for data transfer will be clear only (i.e. No DRM will be involved). 
DEFINE_PROPERTYKEY( WPD_API_OPTION_USE_CLEAR_DATA_STREAM , 0x10E54A3E, 0x052D, 0x4777, 0xA1, 0x3C, 0xDE, 0x76, 0x14, 0xBE, 0x2B, 0xC4 , 2 ); 
// 
// WPD_API_OPTION_IOCTL_ACCESS 
//   [ VT_UI4 ] An optional property that clients can add to the IN parameter set of IPortableDevice::SendCommand to specify the access required for the command. The Portable Device API uses this to identify whether the IOCTL sent to the driver is sent with FILE_READ_ACCESS or (FILE_READ_ACCESS | FILE_WRITE_ACCESS) access flags. 
DEFINE_PROPERTYKEY( WPD_API_OPTION_IOCTL_ACCESS , 0x10E54A3E, 0x052D, 0x4777, 0xA1, 0x3C, 0xDE, 0x76, 0x14, 0xBE, 0x2B, 0xC4 , 3 ); 

/**************************************************************************** 
* This section defines all Commands, Parameters and Options associated with: 
* WPD_CATEGORY_COMMON 
* 
* 
****************************************************************************/ 
DEFINE_GUID( WPD_CATEGORY_COMMON , 0xF0422A9C, 0x5DC8, 0x4440, 0xB5, 0xBD, 0x5D, 0xF2, 0x88, 0x35, 0x65, 0x8A ); 

// ======== Commands ========

// 
// WPD_COMMAND_COMMON_RESET_DEVICE 
//     This command is sent by clients to reset the device. 
//  Access: 
//     (FILE_READ_ACCESS | FILE_WRITE_ACCESS) 
//  Parameters: 
//     None 
//  Results: 
//     None 
DEFINE_PROPERTYKEY( WPD_COMMAND_COMMON_RESET_DEVICE , 0xF0422A9C, 0x5DC8, 0x4440, 0xB5, 0xBD, 0x5D, 0xF2, 0x88, 0x35, 0x65, 0x8A , 2 ); 
// 
// WPD_COMMAND_COMMON_GET_OBJECT_IDS_FROM_PERSISTENT_UNIQUE_IDS 
//     This command is sent when a client wants to get current ObjectIDs representing objects specified by previously acquired Persistent Unique IDs. 
//  Access: 
//     FILE_READ_ACCESS 
//  Parameters: 
//     [ Required ] WPD_PROPERTY_COMMON_PERSISTENT_UNIQUE_IDS 
//  Results: 
//     [ Required ] WPD_PROPERTY_COMMON_OBJECT_IDS 
DEFINE_PROPERTYKEY( WPD_COMMAND_COMMON_GET_OBJECT_IDS_FROM_PERSISTENT_UNIQUE_IDS , 0xF0422A9C, 0x5DC8, 0x4440, 0xB5, 0xBD, 0x5D, 0xF2, 0x88, 0x35, 0x65, 0x8A , 3 ); 
// 
// WPD_COMMAND_COMMON_SAVE_CLIENT_INFORMATION 
//     This command is sent when a client first connects to a device. 
//  Access: 
//     FILE_READ_ACCESS 
//  Parameters: 
//     [ Required ] WPD_PROPERTY_COMMON_CLIENT_INFORMATION 
//  Results: 
//     [ Optional ] WPD_PROPERTY_COMMON_CLIENT_INFORMATION_CONTEXT 
DEFINE_PROPERTYKEY( WPD_COMMAND_COMMON_SAVE_CLIENT_INFORMATION , 0xF0422A9C, 0x5DC8, 0x4440, 0xB5, 0xBD, 0x5D, 0xF2, 0x88, 0x35, 0x65, 0x8A , 4 ); 

// ======== Command Parameters ======== 

// 
// WPD_PROPERTY_COMMON_COMMAND_CATEGORY 
//   [ VT_CLSID ] Specifies the command Category (i.e. the GUID portion of the PROPERTYKEY indicating the command). 
DEFINE_PROPERTYKEY( WPD_PROPERTY_COMMON_COMMAND_CATEGORY , 0xF0422A9C, 0x5DC8, 0x4440, 0xB5, 0xBD, 0x5D, 0xF2, 0x88, 0x35, 0x65, 0x8A , 1001 ); 
// 
// WPD_PROPERTY_COMMON_COMMAND_ID 
//   [ VT_UI4 ] Specifies the command ID, which is the PID portion of the PROPERTYKEY indicating the command. 
DEFINE_PROPERTYKEY( WPD_PROPERTY_COMMON_COMMAND_ID , 0xF0422A9C, 0x5DC8, 0x4440, 0xB5, 0xBD, 0x5D, 0xF2, 0x88, 0x35, 0x65, 0x8A , 1002 ); 
// 
// WPD_PROPERTY_COMMON_HRESULT 
//   [ VT_ERROR ] The driver sets this to be the HRESULT of the requested operation. 
DEFINE_PROPERTYKEY( WPD_PROPERTY_COMMON_HRESULT , 0xF0422A9C, 0x5DC8, 0x4440, 0xB5, 0xBD, 0x5D, 0xF2, 0x88, 0x35, 0x65, 0x8A , 1003 ); 
// 
// WPD_PROPERTY_COMMON_DRIVER_ERROR_CODE 
//   [ VT_UI4 ] Special driver specific code which driver may return on error. Typically only for use with diagnostic tools or vertical solutions. 
DEFINE_PROPERTYKEY( WPD_PROPERTY_COMMON_DRIVER_ERROR_CODE , 0xF0422A9C, 0x5DC8, 0x4440, 0xB5, 0xBD, 0x5D, 0xF2, 0x88, 0x35, 0x65, 0x8A , 1004 ); 
// 
// WPD_PROPERTY_COMMON_COMMAND_TARGET 
//   [ VT_LPWSTR ] Identifies the object which the command is intended for. 
DEFINE_PROPERTYKEY( WPD_PROPERTY_COMMON_COMMAND_TARGET , 0xF0422A9C, 0x5DC8, 0x4440, 0xB5, 0xBD, 0x5D, 0xF2, 0x88, 0x35, 0x65, 0x8A , 1006 ); 
// 
// WPD_PROPERTY_COMMON_PERSISTENT_UNIQUE_IDS 
//   [ VT_UNKNOWN ] IPortableDevicePropVariantCollection of type VT_LPWSTR specifying list of Persistent Unique IDs. 
DEFINE_PROPERTYKEY( WPD_PROPERTY_COMMON_PERSISTENT_UNIQUE_IDS , 0xF0422A9C, 0x5DC8, 0x4440, 0xB5, 0xBD, 0x5D, 0xF2, 0x88, 0x35, 0x65, 0x8A , 1007 ); 
// 
// WPD_PROPERTY_COMMON_OBJECT_IDS 
//   [ VT_UNKNOWN ] IPortableDevicePropVariantCollection of type VT_LPWSTR specifying list of Objects IDs. 
DEFINE_PROPERTYKEY( WPD_PROPERTY_COMMON_OBJECT_IDS , 0xF0422A9C, 0x5DC8, 0x4440, 0xB5, 0xBD, 0x5D, 0xF2, 0x88, 0x35, 0x65, 0x8A , 1008 ); 
// 
// WPD_PROPERTY_COMMON_CLIENT_INFORMATION 
//   [ VT_UNKNOWN ] IPortableDeviceValues used to identify itself to the driver. 
DEFINE_PROPERTYKEY( WPD_PROPERTY_COMMON_CLIENT_INFORMATION , 0xF0422A9C, 0x5DC8, 0x4440, 0xB5, 0xBD, 0x5D, 0xF2, 0x88, 0x35, 0x65, 0x8A , 1009 ); 
// 
// WPD_PROPERTY_COMMON_CLIENT_INFORMATION_CONTEXT 
//   [ VT_LPWSTR ] Driver specified context which will be sent for the particular client on all subsequent operations. 
DEFINE_PROPERTYKEY( WPD_PROPERTY_COMMON_CLIENT_INFORMATION_CONTEXT , 0xF0422A9C, 0x5DC8, 0x4440, 0xB5, 0xBD, 0x5D, 0xF2, 0x88, 0x35, 0x65, 0x8A , 1010 ); 

// ======== Command Options ========

// 
// WPD_OPTION_VALID_OBJECT_IDS 
//   [ VT_UNKNOWN ] IPortableDevicePropVariantCollection of type VT_LPWSTR specifying list of Objects IDs of the objects that support the command. 
DEFINE_PROPERTYKEY( WPD_OPTION_VALID_OBJECT_IDS , 0xF0422A9C, 0x5DC8, 0x4440, 0xB5, 0xBD, 0x5D, 0xF2, 0x88, 0x35, 0x65, 0x8A , 5001 ); 

/**************************************************************************** 
* This section defines all Commands, Parameters and Options associated with: 
* WPD_CATEGORY_OBJECT_ENUMERATION 
* 
* The commands in this category are used for basic object enumeration. 
****************************************************************************/ 
DEFINE_GUID( WPD_CATEGORY_OBJECT_ENUMERATION , 0xB7474E91, 0xE7F8, 0x4AD9, 0xB4, 0x00, 0xAD, 0x1A, 0x4B, 0x58, 0xEE, 0xEC ); 

// ======== Commands ========

// 
// WPD_COMMAND_OBJECT_ENUMERATION_START_FIND 
//     The driver receives this command when a client wishes to start enumeration. 
//  Access: 
//     FILE_READ_ACCESS 
//  Parameters: 
//     [ Required ] WPD_PROPERTY_OBJECT_ENUMERATION_PARENT_ID 
//     [ Optional ] WPD_PROPERTY_OBJECT_ENUMERATION_FILTER 
//  Results: 
//     [ Required ] WPD_PROPERTY_OBJECT_ENUMERATION_CONTEXT 
DEFINE_PROPERTYKEY( WPD_COMMAND_OBJECT_ENUMERATION_START_FIND , 0xB7474E91, 0xE7F8, 0x4AD9, 0xB4, 0x00, 0xAD, 0x1A, 0x4B, 0x58, 0xEE, 0xEC , 2 ); 
// 
// WPD_COMMAND_OBJECT_ENUMERATION_FIND_NEXT 
//     This command is used when the client requests the next batch of ObjectIDs during enumeration. Only objects that match the constraints set up in WPD_COMMAND_OBJECT_ENUMERATION_START_FIND should be returned. 
//  Access: 
//     FILE_READ_ACCESS 
//  Parameters: 
//     [ Required ] WPD_PROPERTY_OBJECT_ENUMERATION_CONTEXT 
//     [ Required ] WPD_PROPERTY_OBJECT_ENUMERATION_NUM_OBJECTS_REQUESTED 
//  Results: 
//     [ Required ] WPD_PROPERTY_OBJECT_ENUMERATION_OBJECT_IDS 
DEFINE_PROPERTYKEY( WPD_COMMAND_OBJECT_ENUMERATION_FIND_NEXT , 0xB7474E91, 0xE7F8, 0x4AD9, 0xB4, 0x00, 0xAD, 0x1A, 0x4B, 0x58, 0xEE, 0xEC , 3 ); 
// 
// WPD_COMMAND_OBJECT_ENUMERATION_END_FIND 
//     The driver should destroy any resources associated with this enumeration context. 
//  Access: 
//     FILE_READ_ACCESS 
//  Parameters: 
//     [ Required ] WPD_PROPERTY_OBJECT_ENUMERATION_CONTEXT 
//  Results: 
//     None 
DEFINE_PROPERTYKEY( WPD_COMMAND_OBJECT_ENUMERATION_END_FIND , 0xB7474E91, 0xE7F8, 0x4AD9, 0xB4, 0x00, 0xAD, 0x1A, 0x4B, 0x58, 0xEE, 0xEC , 4 ); 

// ======== Command Parameters ======== 

// 
// WPD_PROPERTY_OBJECT_ENUMERATION_PARENT_ID 
//   [ VT_LPWSTR ] The ObjectID specifying the parent object where enumeration should start. 
DEFINE_PROPERTYKEY( WPD_PROPERTY_OBJECT_ENUMERATION_PARENT_ID , 0xB7474E91, 0xE7F8, 0x4AD9, 0xB4, 0x00, 0xAD, 0x1A, 0x4B, 0x58, 0xEE, 0xEC , 1001 ); 
// 
// WPD_PROPERTY_OBJECT_ENUMERATION_FILTER 
//   [ VT_UNKNOWN ] This is an IPortableDeviceValues which specifies the properties used to filter on. If the caller does not want filtering, then this value will not be set. 
DEFINE_PROPERTYKEY( WPD_PROPERTY_OBJECT_ENUMERATION_FILTER , 0xB7474E91, 0xE7F8, 0x4AD9, 0xB4, 0x00, 0xAD, 0x1A, 0x4B, 0x58, 0xEE, 0xEC , 1002 ); 
// 
// WPD_PROPERTY_OBJECT_ENUMERATION_OBJECT_IDS 
//   [ VT_UNKNOWN ] This is an IPortableDevicePropVariantCollection of ObjectIDs (of type VT_LPWSTR). If 0 objects are returned, this should be an empty collection, not NULL. 
DEFINE_PROPERTYKEY( WPD_PROPERTY_OBJECT_ENUMERATION_OBJECT_IDS , 0xB7474E91, 0xE7F8, 0x4AD9, 0xB4, 0x00, 0xAD, 0x1A, 0x4B, 0x58, 0xEE, 0xEC , 1003 ); 
// 
// WPD_PROPERTY_OBJECT_ENUMERATION_CONTEXT 
//   [ VT_LPWSTR ] This is a driver-specified identifier for the context associated with this enumeration. 
DEFINE_PROPERTYKEY( WPD_PROPERTY_OBJECT_ENUMERATION_CONTEXT , 0xB7474E91, 0xE7F8, 0x4AD9, 0xB4, 0x00, 0xAD, 0x1A, 0x4B, 0x58, 0xEE, 0xEC , 1004 ); 
// 
// WPD_PROPERTY_OBJECT_ENUMERATION_NUM_OBJECTS_REQUESTED 
//   [ VT_UI4 ] The maximum number of ObjectIDs to return back to the client. 
DEFINE_PROPERTYKEY( WPD_PROPERTY_OBJECT_ENUMERATION_NUM_OBJECTS_REQUESTED , 0xB7474E91, 0xE7F8, 0x4AD9, 0xB4, 0x00, 0xAD, 0x1A, 0x4B, 0x58, 0xEE, 0xEC , 1005 ); 

/**************************************************************************** 
* This section defines all Commands, Parameters and Options associated with: 
* WPD_CATEGORY_OBJECT_PROPERTIES 
* 
* This category of commands is used to perform basic property operations such as Reading/Writing values, listing supported values and so on. 
****************************************************************************/ 
DEFINE_GUID( WPD_CATEGORY_OBJECT_PROPERTIES , 0x9E5582E4, 0x0814, 0x44E6, 0x98, 0x1A, 0xB2, 0x99, 0x8D, 0x58, 0x38, 0x04 ); 

// ======== Commands ========

// 
// WPD_COMMAND_OBJECT_PROPERTIES_GET_SUPPORTED 
//     This command is used when the client requests the list of properties supported by the specified object. 
//  Access: 
//     FILE_READ_ACCESS 
//  Parameters: 
//     [ Required ] WPD_PROPERTY_OBJECT_PROPERTIES_OBJECT_ID 
//  Results: 
//     [ Required ] WPD_PROPERTY_OBJECT_PROPERTIES_PROPERTY_KEYS 
DEFINE_PROPERTYKEY( WPD_COMMAND_OBJECT_PROPERTIES_GET_SUPPORTED , 0x9E5582E4, 0x0814, 0x44E6, 0x98, 0x1A, 0xB2, 0x99, 0x8D, 0x58, 0x38, 0x04 , 2 ); 
// 
// WPD_COMMAND_OBJECT_PROPERTIES_GET_ATTRIBUTES 
//     This command is used when the client requests the property attributes for the specified object properties. 
//  Access: 
//     FILE_READ_ACCESS 
//  Parameters: 
//     [ Required ] WPD_PROPERTY_OBJECT_PROPERTIES_OBJECT_ID 
//     [ Required ] WPD_PROPERTY_OBJECT_PROPERTIES_PROPERTY_KEYS 
//  Results: 
//     [ Required ] WPD_PROPERTY_OBJECT_PROPERTIES_PROPERTY_ATTRIBUTES 
DEFINE_PROPERTYKEY( WPD_COMMAND_OBJECT_PROPERTIES_GET_ATTRIBUTES , 0x9E5582E4, 0x0814, 0x44E6, 0x98, 0x1A, 0xB2, 0x99, 0x8D, 0x58, 0x38, 0x04 , 3 ); 
// 
// WPD_COMMAND_OBJECT_PROPERTIES_GET 
//     This command is used when the client requests a set of property values for the specified object. 
//  Access: 
//     FILE_READ_ACCESS 
//  Parameters: 
//     [ Required ] WPD_PROPERTY_OBJECT_PROPERTIES_OBJECT_ID 
//     [ Required ] WPD_PROPERTY_OBJECT_PROPERTIES_PROPERTY_KEYS 
//  Results: 
//     [ Required ] WPD_PROPERTY_OBJECT_PROPERTIES_PROPERTY_VALUES 
DEFINE_PROPERTYKEY( WPD_COMMAND_OBJECT_PROPERTIES_GET , 0x9E5582E4, 0x0814, 0x44E6, 0x98, 0x1A, 0xB2, 0x99, 0x8D, 0x58, 0x38, 0x04 , 4 ); 
// 
// WPD_COMMAND_OBJECT_PROPERTIES_SET 
//     This command is used when the client requests to write a set of property values on the specified object. 
//  Access: 
//     (FILE_READ_ACCESS | FILE_WRITE_ACCESS) 
//  Parameters: 
//     [ Required ] WPD_PROPERTY_OBJECT_PROPERTIES_OBJECT_ID 
//     [ Required ] WPD_PROPERTY_OBJECT_PROPERTIES_PROPERTY_VALUES 
//  Results: 
//     [ Required ] WPD_PROPERTY_OBJECT_PROPERTIES_PROPERTY_WRITE_RESULTS 
DEFINE_PROPERTYKEY( WPD_COMMAND_OBJECT_PROPERTIES_SET , 0x9E5582E4, 0x0814, 0x44E6, 0x98, 0x1A, 0xB2, 0x99, 0x8D, 0x58, 0x38, 0x04 , 5 ); 
// 
// WPD_COMMAND_OBJECT_PROPERTIES_GET_ALL 
//     This command is used when the client requests all property values for the specified object. 
//  Access: 
//     FILE_READ_ACCESS 
//  Parameters: 
//     [ Required ] WPD_PROPERTY_OBJECT_PROPERTIES_OBJECT_ID 
//  Results: 
//     [ Required ] WPD_PROPERTY_OBJECT_PROPERTIES_PROPERTY_VALUES 
DEFINE_PROPERTYKEY( WPD_COMMAND_OBJECT_PROPERTIES_GET_ALL , 0x9E5582E4, 0x0814, 0x44E6, 0x98, 0x1A, 0xB2, 0x99, 0x8D, 0x58, 0x38, 0x04 , 6 ); 
// 
// WPD_COMMAND_OBJECT_PROPERTIES_DELETE 
//     This command is sent when the caller wants to delete properties from the specified object. 
//  Access: 
//     (FILE_READ_ACCESS | FILE_WRITE_ACCESS) 
//  Parameters: 
//     [ Required ] WPD_PROPERTY_OBJECT_PROPERTIES_OBJECT_ID 
//     [ Required ] WPD_PROPERTY_OBJECT_PROPERTIES_PROPERTY_KEYS 
//  Results: 
//     None 
DEFINE_PROPERTYKEY( WPD_COMMAND_OBJECT_PROPERTIES_DELETE , 0x9E5582E4, 0x0814, 0x44E6, 0x98, 0x1A, 0xB2, 0x99, 0x8D, 0x58, 0x38, 0x04 , 7 ); 

// ======== Command Parameters ======== 

// 
// WPD_PROPERTY_OBJECT_PROPERTIES_OBJECT_ID 
//   [ VT_LPWSTR ] The ObjectID specifying the object whose properties are being queried/manipulated. 
DEFINE_PROPERTYKEY( WPD_PROPERTY_OBJECT_PROPERTIES_OBJECT_ID , 0x9E5582E4, 0x0814, 0x44E6, 0x98, 0x1A, 0xB2, 0x99, 0x8D, 0x58, 0x38, 0x04 , 1001 ); 
// 
// WPD_PROPERTY_OBJECT_PROPERTIES_PROPERTY_KEYS 
//   [ VT_UNKNOWN ] An IPortableDeviceKeyCollection identifying which specific property values we are querying/manipulating. 
DEFINE_PROPERTYKEY( WPD_PROPERTY_OBJECT_PROPERTIES_PROPERTY_KEYS , 0x9E5582E4, 0x0814, 0x44E6, 0x98, 0x1A, 0xB2, 0x99, 0x8D, 0x58, 0x38, 0x04 , 1002 ); 
// 
// WPD_PROPERTY_OBJECT_PROPERTIES_PROPERTY_ATTRIBUTES 
//   [ VT_UNKNOWN ] This is an IPortableDeviceValues which contains the attributes for each property requested.
DEFINE_PROPERTYKEY( WPD_PROPERTY_OBJECT_PROPERTIES_PROPERTY_ATTRIBUTES , 0x9E5582E4, 0x0814, 0x44E6, 0x98, 0x1A, 0xB2, 0x99, 0x8D, 0x58, 0x38, 0x04 , 1003 ); 
// 
// WPD_PROPERTY_OBJECT_PROPERTIES_PROPERTY_VALUES 
//   [ VT_UNKNOWN ] This is an IPortableDeviceValues which contains the values read. For any property whose value could not be read, the type must be set to VT_ERROR, and the 'scode' field must contain the failure HRESULT.
DEFINE_PROPERTYKEY( WPD_PROPERTY_OBJECT_PROPERTIES_PROPERTY_VALUES , 0x9E5582E4, 0x0814, 0x44E6, 0x98, 0x1A, 0xB2, 0x99, 0x8D, 0x58, 0x38, 0x04 , 1004 ); 
// 
// WPD_PROPERTY_OBJECT_PROPERTIES_PROPERTY_WRITE_RESULTS 
//   [ VT_UNKNOWN ] This is an IPortableDeviceValues which contains the result of each property write operation.
DEFINE_PROPERTYKEY( WPD_PROPERTY_OBJECT_PROPERTIES_PROPERTY_WRITE_RESULTS , 0x9E5582E4, 0x0814, 0x44E6, 0x98, 0x1A, 0xB2, 0x99, 0x8D, 0x58, 0x38, 0x04 , 1005 ); 

/**************************************************************************** 
* This section defines all Commands, Parameters and Options associated with: 
* WPD_CATEGORY_OBJECT_PROPERTIES_BULK 
* 
* This category contains commands and properties for property operations across multiple objects. 
****************************************************************************/ 
DEFINE_GUID( WPD_CATEGORY_OBJECT_PROPERTIES_BULK , 0x11C824DD, 0x04CD, 0x4E4E, 0x8C, 0x7B, 0xF6, 0xEF, 0xB7, 0x94, 0xD8, 0x4E ); 

// ======== Commands ========

// 
// WPD_COMMAND_OBJECT_PROPERTIES_BULK_GET_VALUES_BY_OBJECT_LIST_START 
//     Initializes the operation to get the property values for all caller-specified objects. 
//  Access: 
//     FILE_READ_ACCESS 
//  Parameters: 
//     [ Required ] WPD_PROPERTY_OBJECT_PROPERTIES_BULK_OBJECT_IDS 
//     [ Optional ] WPD_PROPERTY_OBJECT_PROPERTIES_BULK_PROPERTY_KEYS 
//  Results: 
//     [ Required ] WPD_PROPERTY_OBJECT_PROPERTIES_BULK_CONTEXT 
DEFINE_PROPERTYKEY( WPD_COMMAND_OBJECT_PROPERTIES_BULK_GET_VALUES_BY_OBJECT_LIST_START , 0x11C824DD, 0x04CD, 0x4E4E, 0x8C, 0x7B, 0xF6, 0xEF, 0xB7, 0x94, 0xD8, 0x4E , 2 ); 
// 
// WPD_COMMAND_OBJECT_PROPERTIES_BULK_GET_VALUES_BY_OBJECT_LIST_NEXT 
//     Get the next set of property values. 
//  Access: 
//     FILE_READ_ACCESS 
//  Parameters: 
//     [ Required ] WPD_PROPERTY_OBJECT_PROPERTIES_BULK_CONTEXT 
//  Results: 
//     [ Required ] WPD_PROPERTY_OBJECT_PROPERTIES_BULK_VALUES 
DEFINE_PROPERTYKEY( WPD_COMMAND_OBJECT_PROPERTIES_BULK_GET_VALUES_BY_OBJECT_LIST_NEXT , 0x11C824DD, 0x04CD, 0x4E4E, 0x8C, 0x7B, 0xF6, 0xEF, 0xB7, 0x94, 0xD8, 0x4E , 3 ); 
// 
// WPD_COMMAND_OBJECT_PROPERTIES_BULK_GET_VALUES_BY_OBJECT_LIST_END 
//     Ends the bulk property operation for getting property values by object list. 
//  Access: 
//     FILE_READ_ACCESS 
//  Parameters: 
//     [ Required ] WPD_PROPERTY_OBJECT_PROPERTIES_BULK_CONTEXT 
//  Results: 
//     None 
DEFINE_PROPERTYKEY( WPD_COMMAND_OBJECT_PROPERTIES_BULK_GET_VALUES_BY_OBJECT_LIST_END , 0x11C824DD, 0x04CD, 0x4E4E, 0x8C, 0x7B, 0xF6, 0xEF, 0xB7, 0x94, 0xD8, 0x4E , 4 ); 
// 
// WPD_COMMAND_OBJECT_PROPERTIES_BULK_GET_VALUES_BY_OBJECT_FORMAT_START 
//     Initializes the operation to get the property values for objects of the specified format 
//  Access: 
//     FILE_READ_ACCESS 
//  Parameters: 
//     [ Required ] WPD_PROPERTY_OBJECT_PROPERTIES_BULK_OBJECT_FORMAT 
//     [ Required ] WPD_PROPERTY_OBJECT_PROPERTIES_BULK_PARENT_OBJECT_ID 
//     [ Required ] WPD_PROPERTY_OBJECT_PROPERTIES_BULK_DEPTH 
//     [ Optional ] WPD_PROPERTY_OBJECT_PROPERTIES_BULK_PROPERTY_KEYS 
//  Results: 
//     [ Required ] WPD_PROPERTY_OBJECT_PROPERTIES_BULK_CONTEXT 
DEFINE_PROPERTYKEY( WPD_COMMAND_OBJECT_PROPERTIES_BULK_GET_VALUES_BY_OBJECT_FORMAT_START , 0x11C824DD, 0x04CD, 0x4E4E, 0x8C, 0x7B, 0xF6, 0xEF, 0xB7, 0x94, 0xD8, 0x4E , 5 ); 
// 
// WPD_COMMAND_OBJECT_PROPERTIES_BULK_GET_VALUES_BY_OBJECT_FORMAT_NEXT 
//     Get the next set of property values. 
//  Access: 
//     FILE_READ_ACCESS 
//  Parameters: 
//     [ Required ] WPD_PROPERTY_OBJECT_PROPERTIES_BULK_CONTEXT 
//  Results: 
//     [ Required ] WPD_PROPERTY_OBJECT_PROPERTIES_BULK_VALUES 
DEFINE_PROPERTYKEY( WPD_COMMAND_OBJECT_PROPERTIES_BULK_GET_VALUES_BY_OBJECT_FORMAT_NEXT , 0x11C824DD, 0x04CD, 0x4E4E, 0x8C, 0x7B, 0xF6, 0xEF, 0xB7, 0x94, 0xD8, 0x4E , 6 ); 
// 
// WPD_COMMAND_OBJECT_PROPERTIES_BULK_GET_VALUES_BY_OBJECT_FORMAT_END 
//     Ends the bulk property operation for getting property values by object format. 
//  Access: 
//     FILE_READ_ACCESS 
//  Parameters: 
//     [ Required ] WPD_PROPERTY_OBJECT_PROPERTIES_BULK_CONTEXT 
//  Results: 
//     None 
DEFINE_PROPERTYKEY( WPD_COMMAND_OBJECT_PROPERTIES_BULK_GET_VALUES_BY_OBJECT_FORMAT_END , 0x11C824DD, 0x04CD, 0x4E4E, 0x8C, 0x7B, 0xF6, 0xEF, 0xB7, 0x94, 0xD8, 0x4E , 7 ); 
// 
// WPD_COMMAND_OBJECT_PROPERTIES_BULK_SET_VALUES_BY_OBJECT_LIST_START 
//     Initializes the operation to set the property values for specified objects. 
//  Access: 
//     (FILE_READ_ACCESS | FILE_WRITE_ACCESS) 
//  Parameters: 
//     [ Required ] WPD_PROPERTY_OBJECT_PROPERTIES_BULK_VALUES 
//  Results: 
//     [ Required ] WPD_PROPERTY_OBJECT_PROPERTIES_BULK_CONTEXT 
DEFINE_PROPERTYKEY( WPD_COMMAND_OBJECT_PROPERTIES_BULK_SET_VALUES_BY_OBJECT_LIST_START , 0x11C824DD, 0x04CD, 0x4E4E, 0x8C, 0x7B, 0xF6, 0xEF, 0xB7, 0x94, 0xD8, 0x4E , 8 ); 
// 
// WPD_COMMAND_OBJECT_PROPERTIES_BULK_SET_VALUES_BY_OBJECT_LIST_NEXT 
//     Set the next set of property values. 
//  Access: 
//     (FILE_READ_ACCESS | FILE_WRITE_ACCESS) 
//  Parameters: 
//     [ Required ] WPD_PROPERTY_OBJECT_PROPERTIES_BULK_CONTEXT 
//  Results: 
//     [ Required ] WPD_PROPERTY_OBJECT_PROPERTIES_BULK_WRITE_RESULTS 
DEFINE_PROPERTYKEY( WPD_COMMAND_OBJECT_PROPERTIES_BULK_SET_VALUES_BY_OBJECT_LIST_NEXT , 0x11C824DD, 0x04CD, 0x4E4E, 0x8C, 0x7B, 0xF6, 0xEF, 0xB7, 0x94, 0xD8, 0x4E , 9 ); 
// 
// WPD_COMMAND_OBJECT_PROPERTIES_BULK_SET_VALUES_BY_OBJECT_LIST_END 
//     Ends the bulk property operation for setting property values by object list. 
//  Access: 
//     (FILE_READ_ACCESS | FILE_WRITE_ACCESS) 
//  Parameters: 
//     [ Required ] WPD_PROPERTY_OBJECT_PROPERTIES_BULK_CONTEXT 
//  Results: 
//     None 
DEFINE_PROPERTYKEY( WPD_COMMAND_OBJECT_PROPERTIES_BULK_SET_VALUES_BY_OBJECT_LIST_END , 0x11C824DD, 0x04CD, 0x4E4E, 0x8C, 0x7B, 0xF6, 0xEF, 0xB7, 0x94, 0xD8, 0x4E , 10 ); 

// ======== Command Parameters ======== 

// 
// WPD_PROPERTY_OBJECT_PROPERTIES_BULK_OBJECT_IDS 
//   [ VT_UNKNOWN ] A collection of ObjectIDs for which supported property list must be returned. 
DEFINE_PROPERTYKEY( WPD_PROPERTY_OBJECT_PROPERTIES_BULK_OBJECT_IDS , 0x11C824DD, 0x04CD, 0x4E4E, 0x8C, 0x7B, 0xF6, 0xEF, 0xB7, 0x94, 0xD8, 0x4E , 1001 ); 
// 
// WPD_PROPERTY_OBJECT_PROPERTIES_BULK_CONTEXT 
//   [ VT_LPWSTR ] The driver-specified context identifying this particular bulk operation. 
DEFINE_PROPERTYKEY( WPD_PROPERTY_OBJECT_PROPERTIES_BULK_CONTEXT , 0x11C824DD, 0x04CD, 0x4E4E, 0x8C, 0x7B, 0xF6, 0xEF, 0xB7, 0x94, 0xD8, 0x4E , 1002 ); 
// 
// WPD_PROPERTY_OBJECT_PROPERTIES_BULK_VALUES 
//   [ VT_UNKNOWN ] Contains an IPortableDeviceValuesCollection specifying the next set of IPortableDeviceValues elements. 
DEFINE_PROPERTYKEY( WPD_PROPERTY_OBJECT_PROPERTIES_BULK_VALUES , 0x11C824DD, 0x04CD, 0x4E4E, 0x8C, 0x7B, 0xF6, 0xEF, 0xB7, 0x94, 0xD8, 0x4E , 1003 ); 
// 
// WPD_PROPERTY_OBJECT_PROPERTIES_BULK_PROPERTY_KEYS 
//   [ VT_UNKNOWN ] Contains an IPortableDeviceKeyCollection specifying which properties the caller wants to return. May not exist, which indicates caller wants ALL properties. 
DEFINE_PROPERTYKEY( WPD_PROPERTY_OBJECT_PROPERTIES_BULK_PROPERTY_KEYS , 0x11C824DD, 0x04CD, 0x4E4E, 0x8C, 0x7B, 0xF6, 0xEF, 0xB7, 0x94, 0xD8, 0x4E , 1004 ); 
// 
// WPD_PROPERTY_OBJECT_PROPERTIES_BULK_DEPTH 
//   [ VT_UI4 ] Contains a value specifying the hierarchical depth from the parent to include in this operation. 
DEFINE_PROPERTYKEY( WPD_PROPERTY_OBJECT_PROPERTIES_BULK_DEPTH , 0x11C824DD, 0x04CD, 0x4E4E, 0x8C, 0x7B, 0xF6, 0xEF, 0xB7, 0x94, 0xD8, 0x4E , 1005 ); 
// 
// WPD_PROPERTY_OBJECT_PROPERTIES_BULK_PARENT_OBJECT_ID 
//   [ VT_LPWSTR ] Contains the ObjectID of the object to start the operation from. 
DEFINE_PROPERTYKEY( WPD_PROPERTY_OBJECT_PROPERTIES_BULK_PARENT_OBJECT_ID , 0x11C824DD, 0x04CD, 0x4E4E, 0x8C, 0x7B, 0xF6, 0xEF, 0xB7, 0x94, 0xD8, 0x4E , 1006 ); 
// 
// WPD_PROPERTY_OBJECT_PROPERTIES_BULK_OBJECT_FORMAT 
//   [ VT_CLSID ] Specifies the object format the client is interested in. 
DEFINE_PROPERTYKEY( WPD_PROPERTY_OBJECT_PROPERTIES_BULK_OBJECT_FORMAT , 0x11C824DD, 0x04CD, 0x4E4E, 0x8C, 0x7B, 0xF6, 0xEF, 0xB7, 0x94, 0xD8, 0x4E , 1007 ); 
// 
// WPD_PROPERTY_OBJECT_PROPERTIES_BULK_WRITE_RESULTS 
//   [ VT_UNKNOWN ] Contains an IPortableDeviceValuesCollection specifying the set of IPortableDeviceValues elements indicating the write results for each property set. 
DEFINE_PROPERTYKEY( WPD_PROPERTY_OBJECT_PROPERTIES_BULK_WRITE_RESULTS , 0x11C824DD, 0x04CD, 0x4E4E, 0x8C, 0x7B, 0xF6, 0xEF, 0xB7, 0x94, 0xD8, 0x4E , 1008 ); 

/**************************************************************************** 
* This section defines all Commands, Parameters and Options associated with: 
* WPD_CATEGORY_OBJECT_RESOURCES 
* 
* The commands in this category are used for basic object resource enumeration and transfer. 
****************************************************************************/ 
DEFINE_GUID( WPD_CATEGORY_OBJECT_RESOURCES , 0xB3A2B22D, 0xA595, 0x4108, 0xBE, 0x0A, 0xFC, 0x3C, 0x96, 0x5F, 0x3D, 0x4A ); 

// ======== Commands ========

// 
// WPD_COMMAND_OBJECT_RESOURCES_GET_SUPPORTED 
//     This command is sent when a client wants to get the list of resources supported on a particular object. 
//  Access: 
//     FILE_READ_ACCESS 
//  Parameters: 
//     [ Required ] WPD_PROPERTY_OBJECT_RESOURCES_OBJECT_ID 
//  Results: 
//     [ Required ] WPD_PROPERTY_OBJECT_RESOURCES_RESOURCE_KEYS 
DEFINE_PROPERTYKEY( WPD_COMMAND_OBJECT_RESOURCES_GET_SUPPORTED , 0xB3A2B22D, 0xA595, 0x4108, 0xBE, 0x0A, 0xFC, 0x3C, 0x96, 0x5F, 0x3D, 0x4A , 2 ); 
// 
// WPD_COMMAND_OBJECT_RESOURCES_GET_ATTRIBUTES 
//     This command is used when the client requests the attributes for the specified object resource. 
//  Access: 
//     FILE_READ_ACCESS 
//  Parameters: 
//     [ Required ] WPD_PROPERTY_OBJECT_RESOURCES_OBJECT_ID 
//     [ Required ] WPD_PROPERTY_OBJECT_RESOURCES_RESOURCE_KEYS 
//  Results: 
//     [ Required ] WPD_PROPERTY_OBJECT_RESOURCES_RESOURCE_ATTRIBUTES 
DEFINE_PROPERTYKEY( WPD_COMMAND_OBJECT_RESOURCES_GET_ATTRIBUTES , 0xB3A2B22D, 0xA595, 0x4108, 0xBE, 0x0A, 0xFC, 0x3C, 0x96, 0x5F, 0x3D, 0x4A , 3 ); 
// 
// WPD_COMMAND_OBJECT_RESOURCES_OPEN 
//     This command is sent when a client wants to use a particular resource on an object. 
//  Access: 
//     Dependent on the value of WPD_PROPERTY_OBJECT_RESOURCES_ACCESS_MODE. STGM_READ will indicate FILE_READ_ACCESS for the command, anything else will indicate (FILE_READ_ACCESS | FILE_WRITE_ACCESS). 
//  Parameters: 
//     [ Required ] WPD_PROPERTY_OBJECT_RESOURCES_OBJECT_ID 
//     [ Required ] WPD_PROPERTY_OBJECT_RESOURCES_RESOURCE_KEYS 
//     [ Required ] WPD_PROPERTY_OBJECT_RESOURCES_ACCESS_MODE 
//  Results: 
//     [ Required ] WPD_PROPERTY_OBJECT_RESOURCES_CONTEXT 
//     [ Required ] WPD_PROPERTY_OBJECT_RESOURCES_OPTIMAL_TRANSFER_BUFFER_SIZE 
DEFINE_PROPERTYKEY( WPD_COMMAND_OBJECT_RESOURCES_OPEN , 0xB3A2B22D, 0xA595, 0x4108, 0xBE, 0x0A, 0xFC, 0x3C, 0x96, 0x5F, 0x3D, 0x4A , 4 ); 
// 
// WPD_COMMAND_OBJECT_RESOURCES_READ 
//     This command is sent when a client wants to read the next band of data from a previously opened object resource. 
//  Access: 
//     FILE_READ_ACCESS 
//  Parameters: 
//     [ Required ] WPD_PROPERTY_OBJECT_RESOURCES_CONTEXT 
//     [ Required ] WPD_PROPERTY_OBJECT_RESOURCES_NUM_BYTES_TO_READ 
//     [ Required ] WPD_PROPERTY_OBJECT_RESOURCES_DATA 
//  Results: 
//     [ Required ] WPD_PROPERTY_OBJECT_RESOURCES_NUM_BYTES_READ 
//     [ Required ] WPD_PROPERTY_OBJECT_RESOURCES_DATA 
DEFINE_PROPERTYKEY( WPD_COMMAND_OBJECT_RESOURCES_READ , 0xB3A2B22D, 0xA595, 0x4108, 0xBE, 0x0A, 0xFC, 0x3C, 0x96, 0x5F, 0x3D, 0x4A , 5 ); 
// 
// WPD_COMMAND_OBJECT_RESOURCES_WRITE 
//     This command is sent when a client wants to write the next band of data to a previously opened object resource. 
//  Access: 
//     (FILE_READ_ACCESS | FILE_WRITE_ACCESS) 
//  Parameters: 
//     [ Required ] WPD_PROPERTY_OBJECT_RESOURCES_CONTEXT 
//     [ Required ] WPD_PROPERTY_OBJECT_RESOURCES_NUM_BYTES_TO_WRITE 
//     [ Required ] WPD_PROPERTY_OBJECT_RESOURCES_DATA 
//  Results: 
//     [ Required ] WPD_PROPERTY_OBJECT_RESOURCES_NUM_BYTES_WRITTEN 
DEFINE_PROPERTYKEY( WPD_COMMAND_OBJECT_RESOURCES_WRITE , 0xB3A2B22D, 0xA595, 0x4108, 0xBE, 0x0A, 0xFC, 0x3C, 0x96, 0x5F, 0x3D, 0x4A , 6 ); 
// 
// WPD_COMMAND_OBJECT_RESOURCES_CLOSE 
//     This command is sent when a client is finished transferring data to a previously opened object resource. 
//  Access: 
//     FILE_READ_ACCESS 
//  Parameters: 
//     [ Required ] WPD_PROPERTY_OBJECT_RESOURCES_CONTEXT 
//  Results: 
//     None 
DEFINE_PROPERTYKEY( WPD_COMMAND_OBJECT_RESOURCES_CLOSE , 0xB3A2B22D, 0xA595, 0x4108, 0xBE, 0x0A, 0xFC, 0x3C, 0x96, 0x5F, 0x3D, 0x4A , 7 ); 
// 
// WPD_COMMAND_OBJECT_RESOURCES_DELETE 
//     This command is sent when the client wants to delete the data associated with the specified resources from the specified object. 
//  Access: 
//     (FILE_READ_ACCESS | FILE_WRITE_ACCESS) 
//  Parameters: 
//     [ Required ] WPD_PROPERTY_OBJECT_RESOURCES_OBJECT_ID 
//     [ Required ] WPD_PROPERTY_OBJECT_RESOURCES_RESOURCE_KEYS 
//  Results: 
//     None 
DEFINE_PROPERTYKEY( WPD_COMMAND_OBJECT_RESOURCES_DELETE , 0xB3A2B22D, 0xA595, 0x4108, 0xBE, 0x0A, 0xFC, 0x3C, 0x96, 0x5F, 0x3D, 0x4A , 8 ); 
// 
// WPD_COMMAND_OBJECT_RESOURCES_CREATE_RESOURCE 
//     This command is sent when a client wants to create a new object resource on the device. 
//  Access: 
//     (FILE_READ_ACCESS | FILE_WRITE_ACCESS) 
//  Parameters: 
//     [ Required ] WPD_PROPERTY_OBJECT_RESOURCES_RESOURCE_ATTRIBUTES 
//  Results: 
//     [ Required ] WPD_PROPERTY_OBJECT_RESOURCES_CONTEXT 
//     [ Required ] WPD_PROPERTY_OBJECT_RESOURCES_OPTIMAL_TRANSFER_BUFFER_SIZE 
DEFINE_PROPERTYKEY( WPD_COMMAND_OBJECT_RESOURCES_CREATE_RESOURCE , 0xB3A2B22D, 0xA595, 0x4108, 0xBE, 0x0A, 0xFC, 0x3C, 0x96, 0x5F, 0x3D, 0x4A , 9 ); 
// 
// WPD_COMMAND_OBJECT_RESOURCES_REVERT 
//     This command is sent when a client wants to cancel the resource creation request that is currently still in progress. 
//  Access: 
//     (FILE_READ_ACCESS | FILE_WRITE_ACCESS) 
//  Parameters: 
//     [ Required ] WPD_PROPERTY_OBJECT_RESOURCES_CONTEXT 
//  Results: 
//     None 
DEFINE_PROPERTYKEY( WPD_COMMAND_OBJECT_RESOURCES_REVERT , 0xB3A2B22D, 0xA595, 0x4108, 0xBE, 0x0A, 0xFC, 0x3C, 0x96, 0x5F, 0x3D, 0x4A , 10 ); 
// 
// WPD_COMMAND_OBJECT_RESOURCES_SEEK 
//     This command is sent when a client wants to seek to a specific offset in the data stream. 
//  Access: 
//     FILE_READ_ACCESS 
//  Parameters: 
//     [ Required ] WPD_PROPERTY_OBJECT_RESOURCES_CONTEXT 
//     [ Required ] WPD_PROPERTY_OBJECT_RESOURCES_SEEK_OFFSET 
//     [ Required ] WPD_PROPERTY_OBJECT_RESOURCES_SEEK_ORIGIN_FLAG 
//  Results: 
//     [ Required ] WPD_PROPERTY_OBJECT_RESOURCES_POSITION_FROM_START 
DEFINE_PROPERTYKEY( WPD_COMMAND_OBJECT_RESOURCES_SEEK , 0xB3A2B22D, 0xA595, 0x4108, 0xBE, 0x0A, 0xFC, 0x3C, 0x96, 0x5F, 0x3D, 0x4A , 11 ); 

// ======== Command Parameters ======== 

// 
// WPD_PROPERTY_OBJECT_RESOURCES_OBJECT_ID 
//   [ VT_LPWSTR ] 
DEFINE_PROPERTYKEY( WPD_PROPERTY_OBJECT_RESOURCES_OBJECT_ID , 0xB3A2B22D, 0xA595, 0x4108, 0xBE, 0x0A, 0xFC, 0x3C, 0x96, 0x5F, 0x3D, 0x4A , 1001 ); 
// 
// WPD_PROPERTY_OBJECT_RESOURCES_ACCESS_MODE 
//   [ VT_UI4 ] Specifies the type of access the client is requesting for the resource. 
DEFINE_PROPERTYKEY( WPD_PROPERTY_OBJECT_RESOURCES_ACCESS_MODE , 0xB3A2B22D, 0xA595, 0x4108, 0xBE, 0x0A, 0xFC, 0x3C, 0x96, 0x5F, 0x3D, 0x4A , 1002 ); 
// 
// WPD_PROPERTY_OBJECT_RESOURCES_RESOURCE_KEYS 
//   [ VT_UNKNOWN ] 
DEFINE_PROPERTYKEY( WPD_PROPERTY_OBJECT_RESOURCES_RESOURCE_KEYS , 0xB3A2B22D, 0xA595, 0x4108, 0xBE, 0x0A, 0xFC, 0x3C, 0x96, 0x5F, 0x3D, 0x4A , 1003 ); 
// 
// WPD_PROPERTY_OBJECT_RESOURCES_RESOURCE_ATTRIBUTES 
//   [ VT_UNKNOWN ] This is an IPortableDeviceValues which contains the attributes for the resource requested. 
DEFINE_PROPERTYKEY( WPD_PROPERTY_OBJECT_RESOURCES_RESOURCE_ATTRIBUTES , 0xB3A2B22D, 0xA595, 0x4108, 0xBE, 0x0A, 0xFC, 0x3C, 0x96, 0x5F, 0x3D, 0x4A , 1004 ); 
// 
// WPD_PROPERTY_OBJECT_RESOURCES_CONTEXT 
//   [ VT_LPWSTR] This is a driver-specified identifier for the context associated with the resource operation. 
DEFINE_PROPERTYKEY( WPD_PROPERTY_OBJECT_RESOURCES_CONTEXT , 0xB3A2B22D, 0xA595, 0x4108, 0xBE, 0x0A, 0xFC, 0x3C, 0x96, 0x5F, 0x3D, 0x4A , 1005 ); 
// 
// WPD_PROPERTY_OBJECT_RESOURCES_NUM_BYTES_TO_READ 
//   [ VT_UI4 ] Specifies the number of bytes the client is requesting to read. 
DEFINE_PROPERTYKEY( WPD_PROPERTY_OBJECT_RESOURCES_NUM_BYTES_TO_READ , 0xB3A2B22D, 0xA595, 0x4108, 0xBE, 0x0A, 0xFC, 0x3C, 0x96, 0x5F, 0x3D, 0x4A , 1006 ); 
// 
// WPD_PROPERTY_OBJECT_RESOURCES_NUM_BYTES_READ 
//   [ VT_UI4 ] Specifies the number of bytes actually read from the resource. 
DEFINE_PROPERTYKEY( WPD_PROPERTY_OBJECT_RESOURCES_NUM_BYTES_READ , 0xB3A2B22D, 0xA595, 0x4108, 0xBE, 0x0A, 0xFC, 0x3C, 0x96, 0x5F, 0x3D, 0x4A , 1007 ); 
// 
// WPD_PROPERTY_OBJECT_RESOURCES_NUM_BYTES_TO_WRITE 
//   [ VT_UI4 ] Specifies the number of bytes the client is requesting to write. 
DEFINE_PROPERTYKEY( WPD_PROPERTY_OBJECT_RESOURCES_NUM_BYTES_TO_WRITE , 0xB3A2B22D, 0xA595, 0x4108, 0xBE, 0x0A, 0xFC, 0x3C, 0x96, 0x5F, 0x3D, 0x4A , 1008 ); 
// 
// WPD_PROPERTY_OBJECT_RESOURCES_NUM_BYTES_WRITTEN 
//   [ VT_UI4 ] Driver sets this to let caller know how many bytes were actually written. 
DEFINE_PROPERTYKEY( WPD_PROPERTY_OBJECT_RESOURCES_NUM_BYTES_WRITTEN , 0xB3A2B22D, 0xA595, 0x4108, 0xBE, 0x0A, 0xFC, 0x3C, 0x96, 0x5F, 0x3D, 0x4A , 1009 ); 
// 
// WPD_PROPERTY_OBJECT_RESOURCES_DATA 
//   [ VT_VECTOR|VT_UI1 ] 
DEFINE_PROPERTYKEY( WPD_PROPERTY_OBJECT_RESOURCES_DATA , 0xB3A2B22D, 0xA595, 0x4108, 0xBE, 0x0A, 0xFC, 0x3C, 0x96, 0x5F, 0x3D, 0x4A , 1010 ); 
// 
// WPD_PROPERTY_OBJECT_RESOURCES_OPTIMAL_TRANSFER_BUFFER_SIZE 
//   [ VT_UI4 ] Indicates the optimal transfer buffer size (in bytes) that clients should use when reading/writing this resource. 
DEFINE_PROPERTYKEY( WPD_PROPERTY_OBJECT_RESOURCES_OPTIMAL_TRANSFER_BUFFER_SIZE , 0xB3A2B22D, 0xA595, 0x4108, 0xBE, 0x0A, 0xFC, 0x3C, 0x96, 0x5F, 0x3D, 0x4A , 1011 ); 
// 
// WPD_PROPERTY_OBJECT_RESOURCES_SEEK_OFFSET 
//   [ VT_I8 ] Displacement to be added to the location indicated by the WPD_PROPERTY_OBJECT_RESOURCES_SEEK_ORIGIN_FLAG parameter. 
DEFINE_PROPERTYKEY( WPD_PROPERTY_OBJECT_RESOURCES_SEEK_OFFSET , 0xB3A2B22D, 0xA595, 0x4108, 0xBE, 0x0A, 0xFC, 0x3C, 0x96, 0x5F, 0x3D, 0x4A , 1012 ); 
// 
// WPD_PROPERTY_OBJECT_RESOURCES_SEEK_ORIGIN_FLAG 
//   [ VT_UI4 ] Specifies the origin of the displacement for the seek operation. 
DEFINE_PROPERTYKEY( WPD_PROPERTY_OBJECT_RESOURCES_SEEK_ORIGIN_FLAG , 0xB3A2B22D, 0xA595, 0x4108, 0xBE, 0x0A, 0xFC, 0x3C, 0x96, 0x5F, 0x3D, 0x4A , 1013 ); 
// 
// WPD_PROPERTY_OBJECT_RESOURCES_POSITION_FROM_START 
//   [ VT_UI8 ] Value of the new seek pointer from the beginning of the data stream. 
DEFINE_PROPERTYKEY( WPD_PROPERTY_OBJECT_RESOURCES_POSITION_FROM_START , 0xB3A2B22D, 0xA595, 0x4108, 0xBE, 0x0A, 0xFC, 0x3C, 0x96, 0x5F, 0x3D, 0x4A , 1014 ); 

// ======== Command Options ========

// 
// WPD_OPTION_OBJECT_RESOURCES_SEEK_ON_READ_SUPPORTED 
//   [ VT_BOOL ] Indicates whether the driver can Seek on a resource opened for Read access. 
DEFINE_PROPERTYKEY( WPD_OPTION_OBJECT_RESOURCES_SEEK_ON_READ_SUPPORTED , 0xB3A2B22D, 0xA595, 0x4108, 0xBE, 0x0A, 0xFC, 0x3C, 0x96, 0x5F, 0x3D, 0x4A , 5001 ); 
// 
// WPD_OPTION_OBJECT_RESOURCES_SEEK_ON_WRITE_SUPPORTED 
//   [ VT_BOOL ] Indicates whether the driver can Seek on a resource opened for Write access. 
DEFINE_PROPERTYKEY( WPD_OPTION_OBJECT_RESOURCES_SEEK_ON_WRITE_SUPPORTED , 0xB3A2B22D, 0xA595, 0x4108, 0xBE, 0x0A, 0xFC, 0x3C, 0x96, 0x5F, 0x3D, 0x4A , 5002 ); 

/**************************************************************************** 
* This section defines all Commands, Parameters and Options associated with: 
* WPD_CATEGORY_OBJECT_MANAGEMENT 
* 
* The commands specified in this category are used to Create/Delete objects on the device. 
****************************************************************************/ 
DEFINE_GUID( WPD_CATEGORY_OBJECT_MANAGEMENT , 0xEF1E43DD, 0xA9ED, 0x4341, 0x8B, 0xCC, 0x18, 0x61, 0x92, 0xAE, 0xA0, 0x89 ); 

// ======== Commands ========

// 
// WPD_COMMAND_OBJECT_MANAGEMENT_CREATE_OBJECT_WITH_PROPERTIES_ONLY 
//     This command is sent when a client wants to create a new object on the device, specified only by properties. 
//  Access: 
//     (FILE_READ_ACCESS | FILE_WRITE_ACCESS) 
//  Parameters: 
//     [ Required ] WPD_PROPERTY_OBJECT_MANAGEMENT_CREATION_PROPERTIES 
//  Results: 
//     [ Required ] WPD_PROPERTY_OBJECT_MANAGEMENT_OBJECT_ID 
DEFINE_PROPERTYKEY( WPD_COMMAND_OBJECT_MANAGEMENT_CREATE_OBJECT_WITH_PROPERTIES_ONLY , 0xEF1E43DD, 0xA9ED, 0x4341, 0x8B, 0xCC, 0x18, 0x61, 0x92, 0xAE, 0xA0, 0x89 , 2 ); 
// 
// WPD_COMMAND_OBJECT_MANAGEMENT_CREATE_OBJECT_WITH_PROPERTIES_AND_DATA 
//     This command is sent when a client wants to create a new object on the device, specified by properties and data. 
//  Access: 
//     (FILE_READ_ACCESS | FILE_WRITE_ACCESS) 
//  Parameters: 
//     [ Required ] WPD_PROPERTY_OBJECT_MANAGEMENT_CREATION_PROPERTIES 
//  Results: 
//     [ Required ] WPD_PROPERTY_OBJECT_MANAGEMENT_CONTEXT 
DEFINE_PROPERTYKEY( WPD_COMMAND_OBJECT_MANAGEMENT_CREATE_OBJECT_WITH_PROPERTIES_AND_DATA , 0xEF1E43DD, 0xA9ED, 0x4341, 0x8B, 0xCC, 0x18, 0x61, 0x92, 0xAE, 0xA0, 0x89 , 3 ); 
// 
// WPD_COMMAND_OBJECT_MANAGEMENT_WRITE_OBJECT_DATA 
//     This command is sent when a client wants to write the next band of data to a newly created object. 
//  Access: 
//     (FILE_READ_ACCESS | FILE_WRITE_ACCESS) 
//  Parameters: 
//     [ Required ] WPD_PROPERTY_OBJECT_MANAGEMENT_CONTEXT 
//     [ Required ] WPD_PROPERTY_OBJECT_MANAGEMENT_NUM_BYTES_TO_WRITE 
//     [ Required ] WPD_PROPERTY_OBJECT_MANAGEMENT_DATA 
//  Results: 
//     [ Required ] WPD_PROPERTY_OBJECT_MANAGEMENT_NUM_BYTES_WRITTEN 
DEFINE_PROPERTYKEY( WPD_COMMAND_OBJECT_MANAGEMENT_WRITE_OBJECT_DATA , 0xEF1E43DD, 0xA9ED, 0x4341, 0x8B, 0xCC, 0x18, 0x61, 0x92, 0xAE, 0xA0, 0x89 , 4 ); 
// 
// WPD_COMMAND_OBJECT_MANAGEMENT_COMMIT_OBJECT 
//     This command is sent when a client has finished sending all the data associated with an object creation request, and wishes to ensure that the object is saved to the device. 
//  Access: 
//     (FILE_READ_ACCESS | FILE_WRITE_ACCESS) 
//  Parameters: 
//     [ Required ] WPD_PROPERTY_OBJECT_MANAGEMENT_CONTEXT 
//  Results: 
//     [ Required ] WPD_PROPERTY_OBJECT_MANAGEMENT_OBJECT_ID 
DEFINE_PROPERTYKEY( WPD_COMMAND_OBJECT_MANAGEMENT_COMMIT_OBJECT , 0xEF1E43DD, 0xA9ED, 0x4341, 0x8B, 0xCC, 0x18, 0x61, 0x92, 0xAE, 0xA0, 0x89 , 5 ); 
// 
// WPD_COMMAND_OBJECT_MANAGEMENT_REVERT_OBJECT 
//     This command is sent when a client wants to cancel the object creation request that is currently still in progress. 
//  Access: 
//     (FILE_READ_ACCESS | FILE_WRITE_ACCESS) 
//  Parameters: 
//     [ Required ] WPD_PROPERTY_OBJECT_MANAGEMENT_CONTEXT 
//  Results: 
//     None 
DEFINE_PROPERTYKEY( WPD_COMMAND_OBJECT_MANAGEMENT_REVERT_OBJECT , 0xEF1E43DD, 0xA9ED, 0x4341, 0x8B, 0xCC, 0x18, 0x61, 0x92, 0xAE, 0xA0, 0x89 , 6 ); 
// 
// WPD_COMMAND_OBJECT_MANAGEMENT_DELETE_OBJECTS 
//     This command is sent when the client wishes to remove a set of objects from the device. 
//  Access: 
//     (FILE_READ_ACCESS | FILE_WRITE_ACCESS) 
//  Parameters: 
//     [ Required ] WPD_PROPERTY_OBJECT_MANAGEMENT_DELETE_OPTIONS 
//     [ Required ] WPD_PROPERTY_OBJECT_MANAGEMENT_OBJECT_IDS 
//  Results: 
//     [ Required ] WPD_PROPERTY_OBJECT_MANAGEMENT_DELETE_RESULTS 
DEFINE_PROPERTYKEY( WPD_COMMAND_OBJECT_MANAGEMENT_DELETE_OBJECTS , 0xEF1E43DD, 0xA9ED, 0x4341, 0x8B, 0xCC, 0x18, 0x61, 0x92, 0xAE, 0xA0, 0x89 , 7 ); 
// 
// WPD_COMMAND_OBJECT_MANAGEMENT_MOVE_OBJECTS 
//     This command will move the specified objects to the destination folder. 
//  Access: 
//     (FILE_READ_ACCESS | FILE_WRITE_ACCESS) 
//  Parameters: 
//     [ Required ] WPD_PROPERTY_OBJECT_MANAGEMENT_OBJECT_IDS 
//     [ Required ] WPD_PROPERTY_OBJECT_MANAGEMENT_DESTINATION_FOLDER_OBJECT_ID 
//  Results: 
//     [ Required ] WPD_PROPERTY_OBJECT_MANAGEMENT_MOVE_RESULTS 
DEFINE_PROPERTYKEY( WPD_COMMAND_OBJECT_MANAGEMENT_MOVE_OBJECTS , 0xEF1E43DD, 0xA9ED, 0x4341, 0x8B, 0xCC, 0x18, 0x61, 0x92, 0xAE, 0xA0, 0x89 , 8 ); 
// 
// WPD_COMMAND_OBJECT_MANAGEMENT_COPY_OBJECTS 
//     This command will copy the specified objects to the destination folder. 
//  Access: 
//     (FILE_READ_ACCESS | FILE_WRITE_ACCESS) 
//  Parameters: 
//     [ Required ] WPD_PROPERTY_OBJECT_MANAGEMENT_OBJECT_IDS 
//     [ Required ] WPD_PROPERTY_OBJECT_MANAGEMENT_DESTINATION_FOLDER_OBJECT_ID 
//  Results: 
//     [ Required ] WPD_PROPERTY_OBJECT_MANAGEMENT_COPY_RESULTS 
DEFINE_PROPERTYKEY( WPD_COMMAND_OBJECT_MANAGEMENT_COPY_OBJECTS , 0xEF1E43DD, 0xA9ED, 0x4341, 0x8B, 0xCC, 0x18, 0x61, 0x92, 0xAE, 0xA0, 0x89 , 9 ); 

// ======== Command Parameters ======== 

// 
// WPD_PROPERTY_OBJECT_MANAGEMENT_CREATION_PROPERTIES 
//   [ VT_UNKNOWN ] This is an IPortableDeviceValues which specifies the properties used to create the new object. 
DEFINE_PROPERTYKEY( WPD_PROPERTY_OBJECT_MANAGEMENT_CREATION_PROPERTIES , 0xEF1E43DD, 0xA9ED, 0x4341, 0x8B, 0xCC, 0x18, 0x61, 0x92, 0xAE, 0xA0, 0x89 , 1001 ); 
// 
// WPD_PROPERTY_OBJECT_MANAGEMENT_CONTEXT 
//   [ VT_LPWSTR ] This is a driver-specified identifier for the context associated with this 'create object' operation. 
DEFINE_PROPERTYKEY( WPD_PROPERTY_OBJECT_MANAGEMENT_CONTEXT , 0xEF1E43DD, 0xA9ED, 0x4341, 0x8B, 0xCC, 0x18, 0x61, 0x92, 0xAE, 0xA0, 0x89 , 1002 ); 
// 
// WPD_PROPERTY_OBJECT_MANAGEMENT_NUM_BYTES_TO_WRITE 
//   [ VT_UI4 ] Specifies the number of bytes the client is requesting to write. 
DEFINE_PROPERTYKEY( WPD_PROPERTY_OBJECT_MANAGEMENT_NUM_BYTES_TO_WRITE , 0xEF1E43DD, 0xA9ED, 0x4341, 0x8B, 0xCC, 0x18, 0x61, 0x92, 0xAE, 0xA0, 0x89 , 1003 ); 
// 
// WPD_PROPERTY_OBJECT_MANAGEMENT_NUM_BYTES_WRITTEN 
//   [ VT_UI4 ] Indicates the number of bytes written for the object. 
DEFINE_PROPERTYKEY( WPD_PROPERTY_OBJECT_MANAGEMENT_NUM_BYTES_WRITTEN , 0xEF1E43DD, 0xA9ED, 0x4341, 0x8B, 0xCC, 0x18, 0x61, 0x92, 0xAE, 0xA0, 0x89 , 1004 ); 
// 
// WPD_PROPERTY_OBJECT_MANAGEMENT_DATA 
//   [ VT_VECTOR|VT_UI1 ] Indicates binary data of the object being created on the device. 
DEFINE_PROPERTYKEY( WPD_PROPERTY_OBJECT_MANAGEMENT_DATA , 0xEF1E43DD, 0xA9ED, 0x4341, 0x8B, 0xCC, 0x18, 0x61, 0x92, 0xAE, 0xA0, 0x89 , 1005 ); 
// 
// WPD_PROPERTY_OBJECT_MANAGEMENT_OBJECT_ID 
//   [ VT_LPWSTR ] Identifies a newly created object on the device. 
DEFINE_PROPERTYKEY( WPD_PROPERTY_OBJECT_MANAGEMENT_OBJECT_ID , 0xEF1E43DD, 0xA9ED, 0x4341, 0x8B, 0xCC, 0x18, 0x61, 0x92, 0xAE, 0xA0, 0x89 , 1006 ); 
// 
// WPD_PROPERTY_OBJECT_MANAGEMENT_DELETE_OPTIONS 
//   [ VT_UI4 ] Indicates if the delete operation should be recursive or not. 
DEFINE_PROPERTYKEY( WPD_PROPERTY_OBJECT_MANAGEMENT_DELETE_OPTIONS , 0xEF1E43DD, 0xA9ED, 0x4341, 0x8B, 0xCC, 0x18, 0x61, 0x92, 0xAE, 0xA0, 0x89 , 1007 ); 
// 
// WPD_PROPERTY_OBJECT_MANAGEMENT_OPTIMAL_TRANSFER_BUFFER_SIZE 
//   [ VT_UI4 ] Indicates the optimal transfer buffer size (in bytes) that clients should use when writing this object's data. 
DEFINE_PROPERTYKEY( WPD_PROPERTY_OBJECT_MANAGEMENT_OPTIMAL_TRANSFER_BUFFER_SIZE , 0xEF1E43DD, 0xA9ED, 0x4341, 0x8B, 0xCC, 0x18, 0x61, 0x92, 0xAE, 0xA0, 0x89 , 1008 ); 
// 
// WPD_PROPERTY_OBJECT_MANAGEMENT_OBJECT_IDS 
//   [ VT_UNKNOWN ] IPortableDevicePropVariantCollection of type VT_LPWSTR, containing the ObjectIDs to delete. 
DEFINE_PROPERTYKEY( WPD_PROPERTY_OBJECT_MANAGEMENT_OBJECT_IDS , 0xEF1E43DD, 0xA9ED, 0x4341, 0x8B, 0xCC, 0x18, 0x61, 0x92, 0xAE, 0xA0, 0x89 , 1009 ); 
// 
// WPD_PROPERTY_OBJECT_MANAGEMENT_DELETE_RESULTS 
//   [ VT_UNKNOWN ] IPortableDevicePropVariantCollection of type VT_ERROR, where each element is the HRESULT indicating the success or failure of the operation. 
DEFINE_PROPERTYKEY( WPD_PROPERTY_OBJECT_MANAGEMENT_DELETE_RESULTS , 0xEF1E43DD, 0xA9ED, 0x4341, 0x8B, 0xCC, 0x18, 0x61, 0x92, 0xAE, 0xA0, 0x89 , 1010 ); 
// 
// WPD_PROPERTY_OBJECT_MANAGEMENT_DESTINATION_FOLDER_OBJECT_ID 
//   [ VT_LPWSTR ] Indicates the destination folder for the move operation. 
DEFINE_PROPERTYKEY( WPD_PROPERTY_OBJECT_MANAGEMENT_DESTINATION_FOLDER_OBJECT_ID , 0xEF1E43DD, 0xA9ED, 0x4341, 0x8B, 0xCC, 0x18, 0x61, 0x92, 0xAE, 0xA0, 0x89 , 1011 ); 
// 
// WPD_PROPERTY_OBJECT_MANAGEMENT_MOVE_RESULTS 
//   [ VT_UNKNOWN ] IPortableDevicePropVariantCollection of type VT_ERROR, where each element is the HRESULT indicating the success or failure of the operation. 
DEFINE_PROPERTYKEY( WPD_PROPERTY_OBJECT_MANAGEMENT_MOVE_RESULTS , 0xEF1E43DD, 0xA9ED, 0x4341, 0x8B, 0xCC, 0x18, 0x61, 0x92, 0xAE, 0xA0, 0x89 , 1012 ); 
// 
// WPD_PROPERTY_OBJECT_MANAGEMENT_COPY_RESULTS 
//   [ VT_UNKNOWN ] IPortableDevicePropVariantCollection of type VT_ERROR, where each element is the HRESULT indicating the success or failure of the operation. 
DEFINE_PROPERTYKEY( WPD_PROPERTY_OBJECT_MANAGEMENT_COPY_RESULTS , 0xEF1E43DD, 0xA9ED, 0x4341, 0x8B, 0xCC, 0x18, 0x61, 0x92, 0xAE, 0xA0, 0x89 , 1013 ); 

// ======== Command Options ========

// 
// WPD_OPTION_OBJECT_MANAGEMENT_RECURSIVE_DELETE_SUPPORTED 
//   [ VT_BOOL ] Indicates whether the driver supports recursive deletion. 
DEFINE_PROPERTYKEY( WPD_OPTION_OBJECT_MANAGEMENT_RECURSIVE_DELETE_SUPPORTED , 0xEF1E43DD, 0xA9ED, 0x4341, 0x8B, 0xCC, 0x18, 0x61, 0x92, 0xAE, 0xA0, 0x89 , 5001 ); 

/**************************************************************************** 
* This section defines all Commands, Parameters and Options associated with: 
* WPD_CATEGORY_CAPABILITIES 
* 
* This command category is used to query capabilities of the device. 
****************************************************************************/ 
DEFINE_GUID( WPD_CATEGORY_CAPABILITIES , 0x0CABEC78, 0x6B74, 0x41C6, 0x92, 0x16, 0x26, 0x39, 0xD1, 0xFC, 0xE3, 0x56 ); 

// ======== Commands ========

// 
// WPD_COMMAND_CAPABILITIES_GET_SUPPORTED_COMMANDS 
//     Return all commands supported by this driver. This includes custom commands, if any.
//  Access: 
//     FILE_READ_ACCESS 
//  Parameters: 
//     None 
//  Results: 
//     [ Required ] WPD_PROPERTY_CAPABILITIES_SUPPORTED_COMMANDS 
DEFINE_PROPERTYKEY( WPD_COMMAND_CAPABILITIES_GET_SUPPORTED_COMMANDS , 0x0CABEC78, 0x6B74, 0x41C6, 0x92, 0x16, 0x26, 0x39, 0xD1, 0xFC, 0xE3, 0x56 , 2 ); 
// 
// WPD_COMMAND_CAPABILITIES_GET_COMMAND_OPTIONS 
//     Returns the supported options for the specified command. 
//  Access: 
//     FILE_READ_ACCESS 
//  Parameters: 
//     [ Required ] WPD_PROPERTY_CAPABILITIES_COMMAND 
//  Results: 
//     [ Required ] WPD_PROPERTY_CAPABILITIES_COMMAND_OPTIONS 
DEFINE_PROPERTYKEY( WPD_COMMAND_CAPABILITIES_GET_COMMAND_OPTIONS , 0x0CABEC78, 0x6B74, 0x41C6, 0x92, 0x16, 0x26, 0x39, 0xD1, 0xFC, 0xE3, 0x56 , 3 ); 
// 
// WPD_COMMAND_CAPABILITIES_GET_SUPPORTED_FUNCTIONAL_CATEGORIES 
//     This command is used by clients to query the functional categories supported by the driver. 
//  Access: 
//     FILE_READ_ACCESS 
//  Parameters: 
//     None 
//  Results: 
//     [ Required ] WPD_PROPERTY_CAPABILITIES_FUNCTIONAL_CATEGORIES 
DEFINE_PROPERTYKEY( WPD_COMMAND_CAPABILITIES_GET_SUPPORTED_FUNCTIONAL_CATEGORIES , 0x0CABEC78, 0x6B74, 0x41C6, 0x92, 0x16, 0x26, 0x39, 0xD1, 0xFC, 0xE3, 0x56 , 4 ); 
// 
// WPD_COMMAND_CAPABILITIES_GET_FUNCTIONAL_OBJECTS 
//     Retrieves the ObjectIDs of the objects belonging to the specified functional category. 
//  Access: 
//     FILE_READ_ACCESS 
//  Parameters: 
//     [ Required ] WPD_PROPERTY_CAPABILITIES_FUNCTIONAL_CATEGORY 
//  Results: 
//     [ Required ] WPD_PROPERTY_CAPABILITIES_FUNCTIONAL_OBJECTS 
DEFINE_PROPERTYKEY( WPD_COMMAND_CAPABILITIES_GET_FUNCTIONAL_OBJECTS , 0x0CABEC78, 0x6B74, 0x41C6, 0x92, 0x16, 0x26, 0x39, 0xD1, 0xFC, 0xE3, 0x56 , 5 ); 
// 
// WPD_COMMAND_CAPABILITIES_GET_SUPPORTED_CONTENT_TYPES 
//     Retrieves the list of content types supported by this driver for the specified functional category. 
//  Access: 
//     FILE_READ_ACCESS 
//  Parameters: 
//     [ Required ] WPD_PROPERTY_CAPABILITIES_FUNCTIONAL_CATEGORY 
//  Results: 
//     [ Required ] WPD_PROPERTY_CAPABILITIES_CONTENT_TYPES 
DEFINE_PROPERTYKEY( WPD_COMMAND_CAPABILITIES_GET_SUPPORTED_CONTENT_TYPES , 0x0CABEC78, 0x6B74, 0x41C6, 0x92, 0x16, 0x26, 0x39, 0xD1, 0xFC, 0xE3, 0x56 , 6 ); 
// 
// WPD_COMMAND_CAPABILITIES_GET_SUPPORTED_FORMATS 
//     This command is used to query the possible formats supported by the specified content type (e.g. for image objects, the driver may choose to support JPEG and BMP files).
//  Access: 
//     FILE_READ_ACCESS 
//  Parameters: 
//     [ Required ] WPD_PROPERTY_CAPABILITIES_CONTENT_TYPE 
//  Results: 
//     [ Required ] WPD_PROPERTY_CAPABILITIES_FORMATS 
DEFINE_PROPERTYKEY( WPD_COMMAND_CAPABILITIES_GET_SUPPORTED_FORMATS , 0x0CABEC78, 0x6B74, 0x41C6, 0x92, 0x16, 0x26, 0x39, 0xD1, 0xFC, 0xE3, 0x56 , 7 ); 
// 
// WPD_COMMAND_CAPABILITIES_GET_SUPPORTED_FORMAT_PROPERTIES 
//     Get the list of properties that an object of the given format supports. 
//  Access: 
//     FILE_READ_ACCESS 
//  Parameters: 
//     [ Required ] WPD_PROPERTY_CAPABILITIES_FORMAT 
//  Results: 
//     [ Required ] WPD_PROPERTY_CAPABILITIES_PROPERTY_KEYS 
DEFINE_PROPERTYKEY( WPD_COMMAND_CAPABILITIES_GET_SUPPORTED_FORMAT_PROPERTIES , 0x0CABEC78, 0x6B74, 0x41C6, 0x92, 0x16, 0x26, 0x39, 0xD1, 0xFC, 0xE3, 0x56 , 8 ); 
// 
// WPD_COMMAND_CAPABILITIES_GET_FIXED_PROPERTY_ATTRIBUTES 
//     Returns the property attributes that are the same for all objects of the given format. 
//  Access: 
//     FILE_READ_ACCESS 
//  Parameters: 
//     [ Required ] WPD_PROPERTY_CAPABILITIES_FORMAT 
//     [ Required ] WPD_PROPERTY_CAPABILITIES_PROPERTY_KEYS 
//  Results: 
//     [ Required ] WPD_PROPERTY_CAPABILITIES_PROPERTY_ATTRIBUTES 
DEFINE_PROPERTYKEY( WPD_COMMAND_CAPABILITIES_GET_FIXED_PROPERTY_ATTRIBUTES , 0x0CABEC78, 0x6B74, 0x41C6, 0x92, 0x16, 0x26, 0x39, 0xD1, 0xFC, 0xE3, 0x56 , 9 ); 
// 
// WPD_COMMAND_CAPABILITIES_GET_SUPPORTED_EVENTS 
//     Return all events supported by this driver. This includes custom events, if any.
//  Access: 
//     FILE_READ_ACCESS 
//  Parameters: 
//     None 
//  Results: 
//     [ Required ] WPD_PROPERTY_CAPABILITIES_SUPPORTED_EVENTS 
DEFINE_PROPERTYKEY( WPD_COMMAND_CAPABILITIES_GET_SUPPORTED_EVENTS , 0x0CABEC78, 0x6B74, 0x41C6, 0x92, 0x16, 0x26, 0x39, 0xD1, 0xFC, 0xE3, 0x56 , 10 ); 
// 
// WPD_COMMAND_CAPABILITIES_GET_EVENT_OPTIONS 
//     Return extra information about a specified event, such as whether the event is for notification or action purposes. 
//  Access: 
//     FILE_READ_ACCESS 
//  Parameters: 
//     [ Required ] WPD_PROPERTY_CAPABILITIES_EVENT 
//  Results: 
//     [ Required ] WPD_PROPERTY_CAPABILITIES_EVENT_OPTIONS 
DEFINE_PROPERTYKEY( WPD_COMMAND_CAPABILITIES_GET_EVENT_OPTIONS , 0x0CABEC78, 0x6B74, 0x41C6, 0x92, 0x16, 0x26, 0x39, 0xD1, 0xFC, 0xE3, 0x56 , 11 ); 

// ======== Command Parameters ======== 

// 
// WPD_PROPERTY_CAPABILITIES_SUPPORTED_COMMANDS 
//   [ VT_UNKNOWN ] IPortableDeviceKeyCollection containing all commands a driver supports. 
DEFINE_PROPERTYKEY( WPD_PROPERTY_CAPABILITIES_SUPPORTED_COMMANDS , 0x0CABEC78, 0x6B74, 0x41C6, 0x92, 0x16, 0x26, 0x39, 0xD1, 0xFC, 0xE3, 0x56 , 1001 ); 
// 
// WPD_PROPERTY_CAPABILITIES_COMMAND 
//   [ VT_UNKNOWN ] Indicates the command whose options the caller is interested in. 
DEFINE_PROPERTYKEY( WPD_PROPERTY_CAPABILITIES_COMMAND , 0x0CABEC78, 0x6B74, 0x41C6, 0x92, 0x16, 0x26, 0x39, 0xD1, 0xFC, 0xE3, 0x56 , 1002 ); 
// 
// WPD_PROPERTY_CAPABILITIES_COMMAND_OPTIONS 
//   [ VT_UNKNOWN ] Contains an IPortableDeviceValues with the relevant command options. 
DEFINE_PROPERTYKEY( WPD_PROPERTY_CAPABILITIES_COMMAND_OPTIONS , 0x0CABEC78, 0x6B74, 0x41C6, 0x92, 0x16, 0x26, 0x39, 0xD1, 0xFC, 0xE3, 0x56 , 1003 ); 
// 
// WPD_PROPERTY_CAPABILITIES_FUNCTIONAL_CATEGORIES 
//   [ VT_UNKNOWN ] An IPortableDevicePropVariantCollection of type VT_CLSID which indicates the functional categories supported by the driver. 
DEFINE_PROPERTYKEY( WPD_PROPERTY_CAPABILITIES_FUNCTIONAL_CATEGORIES , 0x0CABEC78, 0x6B74, 0x41C6, 0x92, 0x16, 0x26, 0x39, 0xD1, 0xFC, 0xE3, 0x56 , 1004 ); 
// 
// WPD_PROPERTY_CAPABILITIES_FUNCTIONAL_CATEGORY 
//   [ VT_CLSID ] The category the caller is interested in. 
DEFINE_PROPERTYKEY( WPD_PROPERTY_CAPABILITIES_FUNCTIONAL_CATEGORY , 0x0CABEC78, 0x6B74, 0x41C6, 0x92, 0x16, 0x26, 0x39, 0xD1, 0xFC, 0xE3, 0x56 , 1005 ); 
// 
// WPD_PROPERTY_CAPABILITIES_FUNCTIONAL_OBJECTS 
//   [ VT_UNKNOWN ] An IPortableDevicePropVariantCollection (of type VT_LPWSTR) containing the ObjectIDs of the functional objects who belong to the specified functional category. 
DEFINE_PROPERTYKEY( WPD_PROPERTY_CAPABILITIES_FUNCTIONAL_OBJECTS , 0x0CABEC78, 0x6B74, 0x41C6, 0x92, 0x16, 0x26, 0x39, 0xD1, 0xFC, 0xE3, 0x56 , 1006 ); 
// 
// WPD_PROPERTY_CAPABILITIES_CONTENT_TYPES 
//   [ VT_UNKNOWN ] Indicates list of content types supported for the specified functional category. 
DEFINE_PROPERTYKEY( WPD_PROPERTY_CAPABILITIES_CONTENT_TYPES , 0x0CABEC78, 0x6B74, 0x41C6, 0x92, 0x16, 0x26, 0x39, 0xD1, 0xFC, 0xE3, 0x56 , 1007 ); 
// 
// WPD_PROPERTY_CAPABILITIES_CONTENT_TYPE 
//   [ VT_CLSID ] Indicates the content type whose formats the caller is interested in. 
DEFINE_PROPERTYKEY( WPD_PROPERTY_CAPABILITIES_CONTENT_TYPE , 0x0CABEC78, 0x6B74, 0x41C6, 0x92, 0x16, 0x26, 0x39, 0xD1, 0xFC, 0xE3, 0x56 , 1008 ); 
// 
// WPD_PROPERTY_CAPABILITIES_FORMATS 
//   [ VT_UNKNOWN ] An IPortableDevicePropVariantCollection of VT_CLSID values indicating the formats supported for the specified content type. 
DEFINE_PROPERTYKEY( WPD_PROPERTY_CAPABILITIES_FORMATS , 0x0CABEC78, 0x6B74, 0x41C6, 0x92, 0x16, 0x26, 0x39, 0xD1, 0xFC, 0xE3, 0x56 , 1009 ); 
// 
// WPD_PROPERTY_CAPABILITIES_FORMAT 
//   [ VT_CLSID ] Specifies the format the caller is interested in. 
DEFINE_PROPERTYKEY( WPD_PROPERTY_CAPABILITIES_FORMAT , 0x0CABEC78, 0x6B74, 0x41C6, 0x92, 0x16, 0x26, 0x39, 0xD1, 0xFC, 0xE3, 0x56 , 1010 ); 
// 
// WPD_PROPERTY_CAPABILITIES_PROPERTY_KEYS 
//   [ VT_UNKNOWN ] An IPortableDeviceKeyCollection containing the property keys. 
DEFINE_PROPERTYKEY( WPD_PROPERTY_CAPABILITIES_PROPERTY_KEYS , 0x0CABEC78, 0x6B74, 0x41C6, 0x92, 0x16, 0x26, 0x39, 0xD1, 0xFC, 0xE3, 0x56 , 1011 ); 
// 
// WPD_PROPERTY_CAPABILITIES_PROPERTY_ATTRIBUTES 
//   [ VT_UNKNOWN ] An IPortableDeviceValues containing the property attributes. 
DEFINE_PROPERTYKEY( WPD_PROPERTY_CAPABILITIES_PROPERTY_ATTRIBUTES , 0x0CABEC78, 0x6B74, 0x41C6, 0x92, 0x16, 0x26, 0x39, 0xD1, 0xFC, 0xE3, 0x56 , 1012 ); 
// 
// WPD_PROPERTY_CAPABILITIES_SUPPORTED_EVENTS 
//   [ VT_UNKNOWN ] IPortableDevicePropVariantCollection of VT_CLSID values containing all events a driver supports. 
DEFINE_PROPERTYKEY( WPD_PROPERTY_CAPABILITIES_SUPPORTED_EVENTS , 0x0CABEC78, 0x6B74, 0x41C6, 0x92, 0x16, 0x26, 0x39, 0xD1, 0xFC, 0xE3, 0x56 , 1013 ); 
// 
// WPD_PROPERTY_CAPABILITIES_EVENT 
//   [ VT_CLSID ] Indicates the event the caller is interested in. 
DEFINE_PROPERTYKEY( WPD_PROPERTY_CAPABILITIES_EVENT , 0x0CABEC78, 0x6B74, 0x41C6, 0x92, 0x16, 0x26, 0x39, 0xD1, 0xFC, 0xE3, 0x56 , 1014 ); 
// 
// WPD_PROPERTY_CAPABILITIES_EVENT_OPTIONS 
//   [ VT_UNKNOWN ] Contains an IPortableDeviceValues with the relevant event options. 
DEFINE_PROPERTYKEY( WPD_PROPERTY_CAPABILITIES_EVENT_OPTIONS , 0x0CABEC78, 0x6B74, 0x41C6, 0x92, 0x16, 0x26, 0x39, 0xD1, 0xFC, 0xE3, 0x56 , 1015 ); 

/**************************************************************************** 
* This section defines all Commands, Parameters and Options associated with: 
* WPD_CATEGORY_STORAGE 
* 
* This category is for commands and parameters for storage functional objects. 
****************************************************************************/ 
DEFINE_GUID( WPD_CATEGORY_STORAGE , 0xD8F907A6, 0x34CC, 0x45FA, 0x97, 0xFB, 0xD0, 0x07, 0xFA, 0x47, 0xEC, 0x94 ); 

// ======== Commands ========

// 
// WPD_COMMAND_STORAGE_FORMAT 
//     This command will format the storage. 
//  Access: 
//     (FILE_READ_ACCESS | FILE_WRITE_ACCESS) 
//  Parameters: 
//     [ Required ] WPD_PROPERTY_STORAGE_OBJECT_ID 
//  Results: 
//     None 
DEFINE_PROPERTYKEY( WPD_COMMAND_STORAGE_FORMAT , 0xD8F907A6, 0x34CC, 0x45FA, 0x97, 0xFB, 0xD0, 0x07, 0xFA, 0x47, 0xEC, 0x94 , 2 ); 
// 
// WPD_COMMAND_STORAGE_EJECT 
//     This will eject the storage, if it is a removable store and is capable of being ejected by the device. 
//  Access: 
//     (FILE_READ_ACCESS | FILE_WRITE_ACCESS) 
//  Parameters: 
//     [ Required ] WPD_PROPERTY_STORAGE_OBJECT_ID 
//  Results: 
//     None 
DEFINE_PROPERTYKEY( WPD_COMMAND_STORAGE_EJECT , 0xD8F907A6, 0x34CC, 0x45FA, 0x97, 0xFB, 0xD0, 0x07, 0xFA, 0x47, 0xEC, 0x94 , 4 ); 

// ======== Command Parameters ======== 

// 
// WPD_PROPERTY_STORAGE_OBJECT_ID 
//   [ VT_LPWSTR ] Indicates the object to format, move or eject. 
DEFINE_PROPERTYKEY( WPD_PROPERTY_STORAGE_OBJECT_ID , 0xD8F907A6, 0x34CC, 0x45FA, 0x97, 0xFB, 0xD0, 0x07, 0xFA, 0x47, 0xEC, 0x94 , 1001 ); 
// 
// WPD_PROPERTY_STORAGE_DESTINATION_OBJECT_ID 
//   [ VT_LPWSTR ] Indicates the (folder) object destination for a move operation. 
DEFINE_PROPERTYKEY( WPD_PROPERTY_STORAGE_DESTINATION_OBJECT_ID , 0xD8F907A6, 0x34CC, 0x45FA, 0x97, 0xFB, 0xD0, 0x07, 0xFA, 0x47, 0xEC, 0x94 , 1002 ); 

/**************************************************************************** 
* This section defines all Commands, Parameters and Options associated with: 
* WPD_CATEGORY_SMS 
* 
* The commands in this category relate to Short-Message-Service functionality, typically exposed on mobile phones. 
****************************************************************************/ 
DEFINE_GUID( WPD_CATEGORY_SMS , 0xAFC25D66, 0xFE0D, 0x4114, 0x90, 0x97, 0x97, 0x0C, 0x93, 0xE9, 0x20, 0xD1 ); 

// ======== Commands ========

// 
// WPD_COMMAND_SMS_SEND 
//     This command is used to initiate the sending of an SMS message. 
//  Access: 
//     (FILE_READ_ACCESS | FILE_WRITE_ACCESS) 
//  Parameters: 
//     [ Required ] WPD_PROPERTY_COMMON_COMMAND_TARGET 
//     [ Required ] WPD_PROPERTY_SMS_RECIPIENT 
//     [ Required ] WPD_PROPERTY_SMS_MESSAGE_TYPE 
//     [ Optional ] WPD_PROPERTY_SMS_TEXT_MESSAGE 
//     [ Optional ] WPD_PROPERTY_SMS_BINARY_MESSAGE 
//  Results: 
//     None 
DEFINE_PROPERTYKEY( WPD_COMMAND_SMS_SEND , 0xAFC25D66, 0xFE0D, 0x4114, 0x90, 0x97, 0x97, 0x0C, 0x93, 0xE9, 0x20, 0xD1 , 2 ); 

// ======== Command Parameters ======== 

// 
// WPD_PROPERTY_SMS_RECIPIENT 
//   [ VT_LPWSTR ] Indicates the recipient's address. 
DEFINE_PROPERTYKEY( WPD_PROPERTY_SMS_RECIPIENT , 0xAFC25D66, 0xFE0D, 0x4114, 0x90, 0x97, 0x97, 0x0C, 0x93, 0xE9, 0x20, 0xD1 , 1001 ); 
// 
// WPD_PROPERTY_SMS_MESSAGE_TYPE 
//   [ VT_UI4 ] Indicates whether the message is binary or text. 
DEFINE_PROPERTYKEY( WPD_PROPERTY_SMS_MESSAGE_TYPE , 0xAFC25D66, 0xFE0D, 0x4114, 0x90, 0x97, 0x97, 0x0C, 0x93, 0xE9, 0x20, 0xD1 , 1002 ); 
// 
// WPD_PROPERTY_SMS_TEXT_MESSAGE 
//   [ VT_LPWSTR ] if WPD_PROPERTY_SMS_MESSAGE_TYPE == SMS_TEXT_MESSAGE, then this will contain the message body. 
DEFINE_PROPERTYKEY( WPD_PROPERTY_SMS_TEXT_MESSAGE , 0xAFC25D66, 0xFE0D, 0x4114, 0x90, 0x97, 0x97, 0x0C, 0x93, 0xE9, 0x20, 0xD1 , 1003 ); 
// 
// WPD_PROPERTY_SMS_BINARY_MESSAGE 
//   [ VT_VECTOR|VT_UI1 ] if WPD_PROPERTY_SMS_MESSAGE_TYPE == SMS_BINARY_MESSAGE, then this will contain the binary message body. 
DEFINE_PROPERTYKEY( WPD_PROPERTY_SMS_BINARY_MESSAGE , 0xAFC25D66, 0xFE0D, 0x4114, 0x90, 0x97, 0x97, 0x0C, 0x93, 0xE9, 0x20, 0xD1 , 1004 ); 

// ======== Command Options ========

// 
// WPD_OPTION_SMS_BINARY_MESSAGE_SUPPORTED 
//   [ VT_BOOL ] Indicates whether the driver can support binary messages as well as text messages. 
DEFINE_PROPERTYKEY( WPD_OPTION_SMS_BINARY_MESSAGE_SUPPORTED , 0xAFC25D66, 0xFE0D, 0x4114, 0x90, 0x97, 0x97, 0x0C, 0x93, 0xE9, 0x20, 0xD1 , 5001 ); 

/**************************************************************************** 
* This section defines all Commands, Parameters and Options associated with: 
* WPD_CATEGORY_STILL_IMAGE_CAPTURE 
* 
* 
****************************************************************************/ 
DEFINE_GUID( WPD_CATEGORY_STILL_IMAGE_CAPTURE , 0x4FCD6982, 0x22A2, 0x4B05, 0xA4, 0x8B, 0x62, 0xD3, 0x8B, 0xF2, 0x7B, 0x32 ); 

// ======== Commands ========

// 
// WPD_COMMAND_STILL_IMAGE_CAPTURE_INITIATE 
//     Initiates a still image capture. This is processed as a single command i.e. there is no start or stop required. 
//  Access: 
//     (FILE_READ_ACCESS | FILE_WRITE_ACCESS) 
//  Parameters: 
//     [ Required ] WPD_PROPERTY_COMMON_COMMAND_TARGET 
//  Results: 
//     None 
DEFINE_PROPERTYKEY( WPD_COMMAND_STILL_IMAGE_CAPTURE_INITIATE , 0x4FCD6982, 0x22A2, 0x4B05, 0xA4, 0x8B, 0x62, 0xD3, 0x8B, 0xF2, 0x7B, 0x32 , 2 ); 

/**************************************************************************** 
* This section defines all Commands, Parameters and Options associated with: 
* WPD_CATEGORY_MEDIA_CAPTURE 
* 
* 
****************************************************************************/ 
DEFINE_GUID( WPD_CATEGORY_MEDIA_CAPTURE , 0x59B433BA, 0xFE44, 0x4D8D, 0x80, 0x8C, 0x6B, 0xCB, 0x9B, 0x0F, 0x15, 0xE8 ); 

// ======== Commands ========

// 
// WPD_COMMAND_MEDIA_CAPTURE_START 
//     Initiates a media capture operation that will only be ended by a subsequent WPD_COMMAND_MEDIA_CAPTURE_STOP command. Typically used to capture media streams such as audio and video. 
//  Access: 
//     (FILE_READ_ACCESS | FILE_WRITE_ACCESS) 
//  Parameters: 
//     [ Required ] WPD_PROPERTY_COMMON_COMMAND_TARGET 
//  Results: 
//     None 
DEFINE_PROPERTYKEY( WPD_COMMAND_MEDIA_CAPTURE_START , 0x59B433BA, 0xFE44, 0x4D8D, 0x80, 0x8C, 0x6B, 0xCB, 0x9B, 0x0F, 0x15, 0xE8 , 2 ); 
// 
// WPD_COMMAND_MEDIA_CAPTURE_STOP 
//     Ends a media capture operation started by a WPD_COMMAND_MEDIA_CAPTURE_START command. Typically used to end capture of media streams such as audio and video. 
//  Access: 
//     (FILE_READ_ACCESS | FILE_WRITE_ACCESS) 
//  Parameters: 
//     [ Required ] WPD_PROPERTY_COMMON_COMMAND_TARGET 
//  Results: 
//     None 
DEFINE_PROPERTYKEY( WPD_COMMAND_MEDIA_CAPTURE_STOP , 0x59B433BA, 0xFE44, 0x4D8D, 0x80, 0x8C, 0x6B, 0xCB, 0x9B, 0x0F, 0x15, 0xE8 , 3 ); 
// 
// WPD_COMMAND_MEDIA_CAPTURE_PAUSE 
//     Pauses a media capture operation started by a WPD_COMMAND_MEDIA_CAPTURE_START command. Typically used to pause capture of media streams such as audio and video. 
//  Access: 
//     (FILE_READ_ACCESS | FILE_WRITE_ACCESS) 
//  Parameters: 
//     [ Required ] WPD_PROPERTY_COMMON_COMMAND_TARGET 
//  Results: 
//     None 
DEFINE_PROPERTYKEY( WPD_COMMAND_MEDIA_CAPTURE_PAUSE , 0x59B433BA, 0xFE44, 0x4D8D, 0x80, 0x8C, 0x6B, 0xCB, 0x9B, 0x0F, 0x15, 0xE8 , 4 ); 

/**************************************************************************** 
* This section defines all Commands, Parameters and Options associated with: 
* WPD_CATEGORY_DEVICE_HINTS 
* 
* The commands in this category relate to hints that a device can provide to improve end-user experience. 
****************************************************************************/ 
DEFINE_GUID( WPD_CATEGORY_DEVICE_HINTS , 0x0D5FB92B, 0xCB46, 0x4C4F, 0x83, 0x43, 0x0B, 0xC3, 0xD3, 0xF1, 0x7C, 0x84 ); 

// ======== Commands ========

// 
// WPD_COMMAND_DEVICE_HINTS_GET_CONTENT_LOCATION 
//     This command is used to retrieve the ObjectIDs of folders that contain the specified content type. 
//  Access: 
//     FILE_READ_ACCESS 
//  Parameters: 
//     [ Required ] WPD_PROPERTY_DEVICE_HINTS_CONTENT_TYPE 
//  Results: 
//     [ Required ] WPD_PROPERTY_DEVICE_HINTS_CONTENT_LOCATIONS 
DEFINE_PROPERTYKEY( WPD_COMMAND_DEVICE_HINTS_GET_CONTENT_LOCATION , 0x0D5FB92B, 0xCB46, 0x4C4F, 0x83, 0x43, 0x0B, 0xC3, 0xD3, 0xF1, 0x7C, 0x84 , 2 ); 

// ======== Command Parameters ======== 

// 
// WPD_PROPERTY_DEVICE_HINTS_CONTENT_TYPE 
//   [ VT_CLSID ] Indicates the WPD content type that the caller is looking for. For example, to get the top-level folder objects that contain images, this parameter would be WPD_CONTENT_TYPE_IMAGE. 
DEFINE_PROPERTYKEY( WPD_PROPERTY_DEVICE_HINTS_CONTENT_TYPE , 0x0D5FB92B, 0xCB46, 0x4C4F, 0x83, 0x43, 0x0B, 0xC3, 0xD3, 0xF1, 0x7C, 0x84 , 1001 ); 
// 
// WPD_PROPERTY_DEVICE_HINTS_CONTENT_LOCATIONS 
//   [ VT_UNKNOWN ] IPortableDevicePropVariantCollection of type VT_LPWSTR indicating a list of folder ObjectIDs. 
DEFINE_PROPERTYKEY( WPD_PROPERTY_DEVICE_HINTS_CONTENT_LOCATIONS , 0x0D5FB92B, 0xCB46, 0x4C4F, 0x83, 0x43, 0x0B, 0xC3, 0xD3, 0xF1, 0x7C, 0x84 , 1002 ); 

/**************************************************************************** 
* This section defines all Commands, Parameters and Options associated with: 
* WPD_CLASS_EXTENSION_V1 
* 
* The commands in this category relate to the WPD device class extension. 
****************************************************************************/ 
DEFINE_GUID( WPD_CLASS_EXTENSION_V1 , 0x33FB0D11, 0x64A3, 0x4FAC, 0xB4, 0xC7, 0x3D, 0xFE, 0xAA, 0x99, 0xB0, 0x51 ); 

// ======== Commands ========

// 
// WPD_COMMAND_CLASS_EXTENSION_WRITE_DEVICE_INFORMATION 
//     This command is used to update the a cache of device-specific information. 
//  Access: 
//     (FILE_READ_ACCESS | FILE_WRITE_ACCESS) 
//  Parameters: 
//     [ Required ] WPD_PROPERTY_CLASS_EXTENSION_DEVICE_INFORMATION_VALUES 
//  Results: 
//     [ Required ] WPD_PROPERTY_CLASS_EXTENSION_DEVICE_INFORMATION_WRITE_RESULTS 
DEFINE_PROPERTYKEY( WPD_COMMAND_CLASS_EXTENSION_WRITE_DEVICE_INFORMATION , 0x33FB0D11, 0x64A3, 0x4FAC, 0xB4, 0xC7, 0x3D, 0xFE, 0xAA, 0x99, 0xB0, 0x51 , 2 ); 

// ======== Command Parameters ======== 

// 
// WPD_PROPERTY_CLASS_EXTENSION_DEVICE_INFORMATION_VALUES 
//   [ VT_UNKNOWN ] This is an IPortableDeviceValues which contains the values. 
DEFINE_PROPERTYKEY( WPD_PROPERTY_CLASS_EXTENSION_DEVICE_INFORMATION_VALUES , 0x33FB0D11, 0x64A3, 0x4FAC, 0xB4, 0xC7, 0x3D, 0xFE, 0xAA, 0x99, 0xB0, 0x51 , 1001 ); 
// 
// WPD_PROPERTY_CLASS_EXTENSION_DEVICE_INFORMATION_WRITE_RESULTS 
//   [ VT_UNKNOWN ] This is an IPortableDeviceValues which contains the result of each value write operation.
DEFINE_PROPERTYKEY( WPD_PROPERTY_CLASS_EXTENSION_DEVICE_INFORMATION_WRITE_RESULTS , 0x33FB0D11, 0x64A3, 0x4FAC, 0xB4, 0xC7, 0x3D, 0xFE, 0xAA, 0x99, 0xB0, 0x51 , 1002 ); 

/**************************************************************************** 
* This section defines all Commands, Parameters and Options associated with: 
* WPD_CATEGORY_NETWORK_CONFIGURATION 
* 
* The commands in this category are used for Network Association and WiFi Configuration. 
****************************************************************************/ 
DEFINE_GUID( WPD_CATEGORY_NETWORK_CONFIGURATION , 0x78F9C6FC, 0x79B8, 0x473C, 0x90, 0x60, 0x6B, 0xD2, 0x3D, 0xD0, 0x72, 0xC4 ); 

// ======== Commands ========

// 
// WPD_COMMAND_GENERATE_KEYPAIR 
//     Initiates the generation of a public/private key pair and returns the public key. 
//  Access: 
//     (FILE_READ_ACCESS | FILE_WRITE_ACCESS) 
//  Parameters: 
//     None 
//  Results: 
//     [ Required ] WPD_PROPERTY_PUBLIC_KEY 
DEFINE_PROPERTYKEY( WPD_COMMAND_GENERATE_KEYPAIR , 0x78F9C6FC, 0x79B8, 0x473C, 0x90, 0x60, 0x6B, 0xD2, 0x3D, 0xD0, 0x72, 0xC4 , 2 ); 
// 
// WPD_COMMAND_COMMIT_KEYPAIR 
//     Commits a public/private key pair. 
//  Access: 
//     (FILE_READ_ACCESS | FILE_WRITE_ACCESS) 
//  Parameters: 
//     None 
//  Results: 
//     None 
DEFINE_PROPERTYKEY( WPD_COMMAND_COMMIT_KEYPAIR , 0x78F9C6FC, 0x79B8, 0x473C, 0x90, 0x60, 0x6B, 0xD2, 0x3D, 0xD0, 0x72, 0xC4 , 3 ); 
// 
// WPD_COMMAND_PROCESS_WIRELESS_PROFILE 
//     Initiates the processing of a Wireless Profile file. 
//  Access: 
//     (FILE_READ_ACCESS | FILE_WRITE_ACCESS) 
//  Parameters: 
//     [ Required ] WPD_PROPERTY_OBJECT_PROPERTIES_OBJECT_ID 
//  Results: 
//     None 
DEFINE_PROPERTYKEY( WPD_COMMAND_PROCESS_WIRELESS_PROFILE , 0x78F9C6FC, 0x79B8, 0x473C, 0x90, 0x60, 0x6B, 0xD2, 0x3D, 0xD0, 0x72, 0xC4 , 4 ); 

// ======== Command Parameters ======== 

// 
// WPD_PROPERTY_PUBLIC_KEY 
//   [ VT_VECTOR|VT_UI1 ] A public key generated for RSA key exchange. 
DEFINE_PROPERTYKEY( WPD_PROPERTY_PUBLIC_KEY , 0x78F9C6FC, 0x79B8, 0x473C, 0x90, 0x60, 0x6B, 0xD2, 0x3D, 0xD0, 0x72, 0xC4 , 1001 ); 

/**************************************************************************** 
* This section defines Structures and Macros used by driver writers to 
* simplify Wpd Command Access checks. 
* Sample Usage: 
* 
* - Add table used to lookup the Access required for Wpd Commands 
* BEGIN_WPD_COMMAND_ACCESS_MAP(g_WpdCommandAccessMap) 
*    DECLARE_WPD_STANDARD_COMMAND_ACCESS_ENTRIES 
*    - Add any custom commands here e.g. 
*    WPD_COMMAND_ACCESS_ENTRY(MyCustomCommand, WPD_COMMAND_ACCESS_READWRITE) 
* END_WPD_COMMAND_ACCESS_MAP 
* - This enables the driver to use VERIFY_WPD_COMMAND_ACCESS to check command access function for us. 
* DECLARE_VERIFY_WPD_COMMAND_ACCESS; 
* ... 
* - When the driver receives a WPD IOCTL, it can check that the IOCTL specified matches 
* the command payload with: 
*    hr = VERIFY_WPD_COMMAND_ACCESS(ControlCode, pParams, g_WpdCommandAccessMap); 
****************************************************************************/ 

// Structure used as an entry in the Command / Access lookup table. 
typedef struct tagWPD_COMMAND_ACCESS_LOOKUP_ENTRY 
{ 
    PROPERTYKEY Command; 
    DWORD AccessType; 
    PROPERTYKEY AccessProperty; 
} WPD_COMMAND_ACCESS_LOOKUP_ENTRY; 

// Used to start a declaration of a WPD Command Access Lookup Map. This macro is usually followed by: 
// DECLARE_WPD_STANDARD_COMMAND_ACCESS_ENTRIES 
// Zero or more WPD_COMMAND_ACCESS_ENTRY or WPD_COMMAND_ACCESS_PROPERTY_ENTRY macros (one for every custom command). 
// The Map is ended with END_WPD_COMMAND_ACCESS_MAP. 
#define BEGIN_WPD_COMMAND_ACCESS_MAP(x) static WPD_COMMAND_ACCESS_LOOKUP_ENTRY x[] = {

// Ends a WPD Command Access Lookup Map started with BEGIN_WPD_COMMAND_ACCESS_MAP 
#define END_WPD_COMMAND_ACCESS_MAP { WPD_PROPERTY_NULL, 0, WPD_PROPERTY_NULL }, };

// Adds a custom entry to a WPD Command Access Lookup Map started with BEGIN_WPD_COMMAND_ACCESS_MAP 
#define WPD_COMMAND_ACCESS_ENTRY(WpdCommand, WpdCommandAccessType) { WpdCommand, WpdCommandAccessType, WPD_PROPERTY_NULL },

// Adds a custom entry to a WPD Command Access Lookup Map started with BEGIN_WPD_COMMAND_ACCESS_MAP 
#define WPD_COMMAND_ACCESS_PROPERTY_ENTRY(WpdCommand, WpdCommandAccessType, WpdAccessProperty) { WpdCommand, WpdCommandAccessType, WpdAccessProperty },

// Declares entries for all the WPD Commands contained in this header file. Used after BEGIN_WPD_COMMAND_ACCESS_MAP. 
#define DECLARE_WPD_STANDARD_COMMAND_ACCESS_ENTRIES \
   WPD_COMMAND_ACCESS_PROPERTY_ENTRY( WPD_COMMAND_COMMON_RESET_DEVICE, WPD_COMMAND_ACCESS_READWRITE, WPD_PROPERTY_NULL ) \
   WPD_COMMAND_ACCESS_PROPERTY_ENTRY( WPD_COMMAND_COMMON_GET_OBJECT_IDS_FROM_PERSISTENT_UNIQUE_IDS, WPD_COMMAND_ACCESS_READ, WPD_PROPERTY_NULL ) \
   WPD_COMMAND_ACCESS_PROPERTY_ENTRY( WPD_COMMAND_COMMON_SAVE_CLIENT_INFORMATION, WPD_COMMAND_ACCESS_READ, WPD_PROPERTY_NULL ) \
   WPD_COMMAND_ACCESS_PROPERTY_ENTRY( WPD_COMMAND_OBJECT_ENUMERATION_START_FIND, WPD_COMMAND_ACCESS_READ, WPD_PROPERTY_NULL ) \
   WPD_COMMAND_ACCESS_PROPERTY_ENTRY( WPD_COMMAND_OBJECT_ENUMERATION_FIND_NEXT, WPD_COMMAND_ACCESS_READ, WPD_PROPERTY_NULL ) \
   WPD_COMMAND_ACCESS_PROPERTY_ENTRY( WPD_COMMAND_OBJECT_ENUMERATION_END_FIND, WPD_COMMAND_ACCESS_READ, WPD_PROPERTY_NULL ) \
   WPD_COMMAND_ACCESS_PROPERTY_ENTRY( WPD_COMMAND_OBJECT_PROPERTIES_GET_SUPPORTED, WPD_COMMAND_ACCESS_READ, WPD_PROPERTY_NULL ) \
   WPD_COMMAND_ACCESS_PROPERTY_ENTRY( WPD_COMMAND_OBJECT_PROPERTIES_GET_ATTRIBUTES, WPD_COMMAND_ACCESS_READ, WPD_PROPERTY_NULL ) \
   WPD_COMMAND_ACCESS_PROPERTY_ENTRY( WPD_COMMAND_OBJECT_PROPERTIES_GET, WPD_COMMAND_ACCESS_READ, WPD_PROPERTY_NULL ) \
   WPD_COMMAND_ACCESS_PROPERTY_ENTRY( WPD_COMMAND_OBJECT_PROPERTIES_SET, WPD_COMMAND_ACCESS_READWRITE, WPD_PROPERTY_NULL ) \
   WPD_COMMAND_ACCESS_PROPERTY_ENTRY( WPD_COMMAND_OBJECT_PROPERTIES_GET_ALL, WPD_COMMAND_ACCESS_READ, WPD_PROPERTY_NULL ) \
   WPD_COMMAND_ACCESS_PROPERTY_ENTRY( WPD_COMMAND_OBJECT_PROPERTIES_DELETE, WPD_COMMAND_ACCESS_READWRITE, WPD_PROPERTY_NULL ) \
   WPD_COMMAND_ACCESS_PROPERTY_ENTRY( WPD_COMMAND_OBJECT_PROPERTIES_BULK_GET_VALUES_BY_OBJECT_LIST_START, WPD_COMMAND_ACCESS_READ, WPD_PROPERTY_NULL ) \
   WPD_COMMAND_ACCESS_PROPERTY_ENTRY( WPD_COMMAND_OBJECT_PROPERTIES_BULK_GET_VALUES_BY_OBJECT_LIST_NEXT, WPD_COMMAND_ACCESS_READ, WPD_PROPERTY_NULL ) \
   WPD_COMMAND_ACCESS_PROPERTY_ENTRY( WPD_COMMAND_OBJECT_PROPERTIES_BULK_GET_VALUES_BY_OBJECT_LIST_END, WPD_COMMAND_ACCESS_READ, WPD_PROPERTY_NULL ) \
   WPD_COMMAND_ACCESS_PROPERTY_ENTRY( WPD_COMMAND_OBJECT_PROPERTIES_BULK_GET_VALUES_BY_OBJECT_FORMAT_START, WPD_COMMAND_ACCESS_READ, WPD_PROPERTY_NULL ) \
   WPD_COMMAND_ACCESS_PROPERTY_ENTRY( WPD_COMMAND_OBJECT_PROPERTIES_BULK_GET_VALUES_BY_OBJECT_FORMAT_NEXT, WPD_COMMAND_ACCESS_READ, WPD_PROPERTY_NULL ) \
   WPD_COMMAND_ACCESS_PROPERTY_ENTRY( WPD_COMMAND_OBJECT_PROPERTIES_BULK_GET_VALUES_BY_OBJECT_FORMAT_END, WPD_COMMAND_ACCESS_READ, WPD_PROPERTY_NULL ) \
   WPD_COMMAND_ACCESS_PROPERTY_ENTRY( WPD_COMMAND_OBJECT_PROPERTIES_BULK_SET_VALUES_BY_OBJECT_LIST_START, WPD_COMMAND_ACCESS_READWRITE, WPD_PROPERTY_NULL ) \
   WPD_COMMAND_ACCESS_PROPERTY_ENTRY( WPD_COMMAND_OBJECT_PROPERTIES_BULK_SET_VALUES_BY_OBJECT_LIST_NEXT, WPD_COMMAND_ACCESS_READWRITE, WPD_PROPERTY_NULL ) \
   WPD_COMMAND_ACCESS_PROPERTY_ENTRY( WPD_COMMAND_OBJECT_PROPERTIES_BULK_SET_VALUES_BY_OBJECT_LIST_END, WPD_COMMAND_ACCESS_READWRITE, WPD_PROPERTY_NULL ) \
   WPD_COMMAND_ACCESS_PROPERTY_ENTRY( WPD_COMMAND_OBJECT_RESOURCES_GET_SUPPORTED, WPD_COMMAND_ACCESS_READ, WPD_PROPERTY_NULL ) \
   WPD_COMMAND_ACCESS_PROPERTY_ENTRY( WPD_COMMAND_OBJECT_RESOURCES_GET_ATTRIBUTES, WPD_COMMAND_ACCESS_READ, WPD_PROPERTY_NULL ) \
   WPD_COMMAND_ACCESS_PROPERTY_ENTRY( WPD_COMMAND_OBJECT_RESOURCES_OPEN, WPD_COMMAND_ACCESS_FROM_PROPERTY_WITH_STGM_ACCESS, WPD_PROPERTY_OBJECT_RESOURCES_ACCESS_MODE ) \
   WPD_COMMAND_ACCESS_PROPERTY_ENTRY( WPD_COMMAND_OBJECT_RESOURCES_READ, WPD_COMMAND_ACCESS_READ, WPD_PROPERTY_NULL ) \
   WPD_COMMAND_ACCESS_PROPERTY_ENTRY( WPD_COMMAND_OBJECT_RESOURCES_WRITE, WPD_COMMAND_ACCESS_READWRITE, WPD_PROPERTY_NULL ) \
   WPD_COMMAND_ACCESS_PROPERTY_ENTRY( WPD_COMMAND_OBJECT_RESOURCES_CLOSE, WPD_COMMAND_ACCESS_READ, WPD_PROPERTY_NULL ) \
   WPD_COMMAND_ACCESS_PROPERTY_ENTRY( WPD_COMMAND_OBJECT_RESOURCES_DELETE, WPD_COMMAND_ACCESS_READWRITE, WPD_PROPERTY_NULL ) \
   WPD_COMMAND_ACCESS_PROPERTY_ENTRY( WPD_COMMAND_OBJECT_RESOURCES_CREATE_RESOURCE, WPD_COMMAND_ACCESS_READWRITE, WPD_PROPERTY_NULL ) \
   WPD_COMMAND_ACCESS_PROPERTY_ENTRY( WPD_COMMAND_OBJECT_RESOURCES_REVERT, WPD_COMMAND_ACCESS_READWRITE, WPD_PROPERTY_NULL ) \
   WPD_COMMAND_ACCESS_PROPERTY_ENTRY( WPD_COMMAND_OBJECT_RESOURCES_SEEK, WPD_COMMAND_ACCESS_READ, WPD_PROPERTY_NULL ) \
   WPD_COMMAND_ACCESS_PROPERTY_ENTRY( WPD_COMMAND_OBJECT_MANAGEMENT_CREATE_OBJECT_WITH_PROPERTIES_ONLY, WPD_COMMAND_ACCESS_READWRITE, WPD_PROPERTY_NULL ) \
   WPD_COMMAND_ACCESS_PROPERTY_ENTRY( WPD_COMMAND_OBJECT_MANAGEMENT_CREATE_OBJECT_WITH_PROPERTIES_AND_DATA, WPD_COMMAND_ACCESS_READWRITE, WPD_PROPERTY_NULL ) \
   WPD_COMMAND_ACCESS_PROPERTY_ENTRY( WPD_COMMAND_OBJECT_MANAGEMENT_WRITE_OBJECT_DATA, WPD_COMMAND_ACCESS_READWRITE, WPD_PROPERTY_NULL ) \
   WPD_COMMAND_ACCESS_PROPERTY_ENTRY( WPD_COMMAND_OBJECT_MANAGEMENT_COMMIT_OBJECT, WPD_COMMAND_ACCESS_READWRITE, WPD_PROPERTY_NULL ) \
   WPD_COMMAND_ACCESS_PROPERTY_ENTRY( WPD_COMMAND_OBJECT_MANAGEMENT_REVERT_OBJECT, WPD_COMMAND_ACCESS_READWRITE, WPD_PROPERTY_NULL ) \
   WPD_COMMAND_ACCESS_PROPERTY_ENTRY( WPD_COMMAND_OBJECT_MANAGEMENT_DELETE_OBJECTS, WPD_COMMAND_ACCESS_READWRITE, WPD_PROPERTY_NULL ) \
   WPD_COMMAND_ACCESS_PROPERTY_ENTRY( WPD_COMMAND_OBJECT_MANAGEMENT_MOVE_OBJECTS, WPD_COMMAND_ACCESS_READWRITE, WPD_PROPERTY_NULL ) \
   WPD_COMMAND_ACCESS_PROPERTY_ENTRY( WPD_COMMAND_OBJECT_MANAGEMENT_COPY_OBJECTS, WPD_COMMAND_ACCESS_READWRITE, WPD_PROPERTY_NULL ) \
   WPD_COMMAND_ACCESS_PROPERTY_ENTRY( WPD_COMMAND_CAPABILITIES_GET_SUPPORTED_COMMANDS, WPD_COMMAND_ACCESS_READ, WPD_PROPERTY_NULL ) \
   WPD_COMMAND_ACCESS_PROPERTY_ENTRY( WPD_COMMAND_CAPABILITIES_GET_COMMAND_OPTIONS, WPD_COMMAND_ACCESS_READ, WPD_PROPERTY_NULL ) \
   WPD_COMMAND_ACCESS_PROPERTY_ENTRY( WPD_COMMAND_CAPABILITIES_GET_SUPPORTED_FUNCTIONAL_CATEGORIES, WPD_COMMAND_ACCESS_READ, WPD_PROPERTY_NULL ) \
   WPD_COMMAND_ACCESS_PROPERTY_ENTRY( WPD_COMMAND_CAPABILITIES_GET_FUNCTIONAL_OBJECTS, WPD_COMMAND_ACCESS_READ, WPD_PROPERTY_NULL ) \
   WPD_COMMAND_ACCESS_PROPERTY_ENTRY( WPD_COMMAND_CAPABILITIES_GET_SUPPORTED_CONTENT_TYPES, WPD_COMMAND_ACCESS_READ, WPD_PROPERTY_NULL ) \
   WPD_COMMAND_ACCESS_PROPERTY_ENTRY( WPD_COMMAND_CAPABILITIES_GET_SUPPORTED_FORMATS, WPD_COMMAND_ACCESS_READ, WPD_PROPERTY_NULL ) \
   WPD_COMMAND_ACCESS_PROPERTY_ENTRY( WPD_COMMAND_CAPABILITIES_GET_SUPPORTED_FORMAT_PROPERTIES, WPD_COMMAND_ACCESS_READ, WPD_PROPERTY_NULL ) \
   WPD_COMMAND_ACCESS_PROPERTY_ENTRY( WPD_COMMAND_CAPABILITIES_GET_FIXED_PROPERTY_ATTRIBUTES, WPD_COMMAND_ACCESS_READ, WPD_PROPERTY_NULL ) \
   WPD_COMMAND_ACCESS_PROPERTY_ENTRY( WPD_COMMAND_CAPABILITIES_GET_SUPPORTED_EVENTS, WPD_COMMAND_ACCESS_READ, WPD_PROPERTY_NULL ) \
   WPD_COMMAND_ACCESS_PROPERTY_ENTRY( WPD_COMMAND_CAPABILITIES_GET_EVENT_OPTIONS, WPD_COMMAND_ACCESS_READ, WPD_PROPERTY_NULL ) \
   WPD_COMMAND_ACCESS_PROPERTY_ENTRY( WPD_COMMAND_STORAGE_FORMAT, WPD_COMMAND_ACCESS_READWRITE, WPD_PROPERTY_NULL ) \
   WPD_COMMAND_ACCESS_PROPERTY_ENTRY( WPD_COMMAND_STORAGE_EJECT, WPD_COMMAND_ACCESS_READWRITE, WPD_PROPERTY_NULL ) \
   WPD_COMMAND_ACCESS_PROPERTY_ENTRY( WPD_COMMAND_SMS_SEND, WPD_COMMAND_ACCESS_READWRITE, WPD_PROPERTY_NULL ) \
   WPD_COMMAND_ACCESS_PROPERTY_ENTRY( WPD_COMMAND_STILL_IMAGE_CAPTURE_INITIATE, WPD_COMMAND_ACCESS_READWRITE, WPD_PROPERTY_NULL ) \
   WPD_COMMAND_ACCESS_PROPERTY_ENTRY( WPD_COMMAND_MEDIA_CAPTURE_START, WPD_COMMAND_ACCESS_READWRITE, WPD_PROPERTY_NULL ) \
   WPD_COMMAND_ACCESS_PROPERTY_ENTRY( WPD_COMMAND_MEDIA_CAPTURE_STOP, WPD_COMMAND_ACCESS_READWRITE, WPD_PROPERTY_NULL ) \
   WPD_COMMAND_ACCESS_PROPERTY_ENTRY( WPD_COMMAND_MEDIA_CAPTURE_PAUSE, WPD_COMMAND_ACCESS_READWRITE, WPD_PROPERTY_NULL ) \
   WPD_COMMAND_ACCESS_PROPERTY_ENTRY( WPD_COMMAND_DEVICE_HINTS_GET_CONTENT_LOCATION, WPD_COMMAND_ACCESS_READ, WPD_PROPERTY_NULL ) \
   WPD_COMMAND_ACCESS_PROPERTY_ENTRY( WPD_COMMAND_CLASS_EXTENSION_WRITE_DEVICE_INFORMATION, WPD_COMMAND_ACCESS_READWRITE, WPD_PROPERTY_NULL ) \
   WPD_COMMAND_ACCESS_PROPERTY_ENTRY( WPD_COMMAND_GENERATE_KEYPAIR, WPD_COMMAND_ACCESS_READWRITE, WPD_PROPERTY_NULL ) \
   WPD_COMMAND_ACCESS_PROPERTY_ENTRY( WPD_COMMAND_COMMIT_KEYPAIR, WPD_COMMAND_ACCESS_READWRITE, WPD_PROPERTY_NULL ) \
   WPD_COMMAND_ACCESS_PROPERTY_ENTRY( WPD_COMMAND_PROCESS_WIRELESS_PROFILE, WPD_COMMAND_ACCESS_READWRITE, WPD_PROPERTY_NULL ) \


// Declares an instance of the function used to check whether a WPD Command is in the driver's WPD Command Access Map. 
// Driver writers should not call this function directly, but should instead use the IS_COMMAND_IN_WPD_COMMAND_ACCESS_MAP alias. 
#define DECLARE_IS_COMMAND_IN_WPD_COMMAND_ACCESS_MAP() \
BOOL IsCommandInWpdCommandAccessMap( \
    REFPROPERTYKEY                       WpdCommand, \
    __in WPD_COMMAND_ACCESS_LOOKUP_ENTRY *pCommandAccessLookupMap) \
{ \
    BOOL bRet = FALSE; \
    if(pCommandParams == NULL) \
    { \
        return E_POINTER; \
    } \
    while(pCommandAccessLookupMap[dwMapIndex++].Command != WPD_PROPERTY_NULL) \
    { \
        if(IsEqualPropertyKey(pCommandAccessLookupMap[dwMapIndex].Command), WpdCommand) \
        { \
            bRet = TRUE; \
            break; \
        } \
        dwMapIndex++; \
    } \
    return bRet; \
};
        
// This macro is an alias for the function used to check whether a WPD Command is in the driver's WPD Command Access Map (see BEGIN_WPD_COMMAND_ACCESS_MAP) 
#define IS_COMMAND_IN_WPD_COMMAND_ACCESS_MAP IsCommandInWpdCommandAccessMap


// Declares an instance of the function used to verify that WPD Commands are sent with the appropriate Access Flags in the IOCTL.
// Driver writers should not call this function directly, but should instead use the VERIFY_WPD_COMMAND_ACCESS alias.
#define DECLARE_VERIFY_WPD_COMMAND_ACCESS \
HRESULT VerifyWpdCommandAccessFromMap(  \
    const DWORD                          ControlCode, \
    __in IPortableDeviceValues           *pCommandParams, \
    __in WPD_COMMAND_ACCESS_LOOKUP_ENTRY *pCommandAccessLookupMap) \
{ \
    HRESULT     hr                      = S_OK; \
    DWORD       dwMapIndex              = 0; \
    PROPERTYKEY WpdCommand              = WPD_PROPERTY_NULL; \
    DWORD       dwExpectedControlCode   = IOCTL_WPD_MESSAGE_READWRITE_ACCESS; \
    if((pCommandParams == NULL) || (pCommandAccessLookupMap == NULL)) \
    { \
        return E_POINTER; \
    } \
    if(ControlCode == IOCTL_WPD_MESSAGE_READWRITE_ACCESS) \
    { \
        return S_OK; \
    } \
    hr = pCommandParams->GetGuidValue(WPD_PROPERTY_COMMON_COMMAND_CATEGORY, &WpdCommand.fmtid); \
    if(SUCCEEDED(hr)) \
    { \
        hr = pCommandParams->GetUnsignedIntegerValue(WPD_PROPERTY_COMMON_COMMAND_ID, &WpdCommand.pid); \
        if(SUCCEEDED(hr)) \
        { \
            while(!IsEqualPropertyKey(pCommandAccessLookupMap[dwMapIndex].Command, WPD_PROPERTY_NULL)) \
            { \
                if(IsEqualPropertyKey(pCommandAccessLookupMap[dwMapIndex].Command, WpdCommand)) \
                { \
                    switch(pCommandAccessLookupMap[dwMapIndex].AccessType) \
                    { \
                        case WPD_COMMAND_ACCESS_READ: \
                            { \
                                dwExpectedControlCode = IOCTL_WPD_MESSAGE_READ_ACCESS; \
                            } \
                            break; \
                        case WPD_COMMAND_ACCESS_READWRITE: \
                            { \
                                dwExpectedControlCode = IOCTL_WPD_MESSAGE_READWRITE_ACCESS; \
                            } \
                            break; \
                        case WPD_COMMAND_ACCESS_FROM_PROPERTY_WITH_STGM_ACCESS: \
                            { \
                                DWORD dwAccessPropVal = STGM_READWRITE; \
                                HRESULT hrTemp = S_OK; \
                                hrTemp = pCommandParams->GetUnsignedIntegerValue(pCommandAccessLookupMap[dwMapIndex].AccessProperty, &dwAccessPropVal); \
                                if(dwAccessPropVal == STGM_READ) \
                                { \
                                    dwExpectedControlCode = IOCTL_WPD_MESSAGE_READ_ACCESS; \
                                } \
                                else \
                                { \
                                    dwExpectedControlCode = IOCTL_WPD_MESSAGE_READWRITE_ACCESS; \
                                } \
                            } \
                            break; \
                        case WPD_COMMAND_ACCESS_FROM_PROPERTY_WITH_FILE_ACCESS: \
                            { \
                                DWORD dwAccessPropVal = FILE_READ_ACCESS; \
                                HRESULT hrTemp = S_OK; \
                                hrTemp = pCommandParams->GetUnsignedIntegerValue(pCommandAccessLookupMap[dwMapIndex].AccessProperty, &dwAccessPropVal); \
                                if(dwAccessPropVal == FILE_READ_ACCESS) \
                                { \
                                    dwExpectedControlCode = IOCTL_WPD_MESSAGE_READ_ACCESS; \
                                } \
                                else \
                                { \
                                    dwExpectedControlCode = IOCTL_WPD_MESSAGE_READWRITE_ACCESS; \
                                } \
                            } \
                            break; \
                        default: \
                            { \
                                dwExpectedControlCode = IOCTL_WPD_MESSAGE_READWRITE_ACCESS; \
                            } \
                            break; \
                    } \
                    break; \
                } \
                dwMapIndex++; \
            } \
        } \
    } \
    if(SUCCEEDED(hr)) \
    { \
        if(ControlCode != dwExpectedControlCode) \
        { \
            return E_INVALIDARG; \
        } \
    } \
    return hr; \
};
        
// This macro is an alias for the function used to verify that WPD Commands are sent with the appropriate Access Flags in the IOCTL 
#define VERIFY_WPD_COMMAND_ACCESS VerifyWpdCommandAccessFromMap

#endif // ((NTDDI_VERSION >= NTDDI_WINXPSP2 && NTDDI_VERSION < NTDDI_WS03) || (NTDDI_VERSION >= NTDDI_WINLH))
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\portabledeviceclassextension.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0499 */
/* Compiler settings for PortableDeviceClassExtension.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __PortableDeviceClassExtension_h__
#define __PortableDeviceClassExtension_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IPortableDeviceClassExtension_FWD_DEFINED__
#define __IPortableDeviceClassExtension_FWD_DEFINED__
typedef interface IPortableDeviceClassExtension IPortableDeviceClassExtension;
#endif 	/* __IPortableDeviceClassExtension_FWD_DEFINED__ */


#ifndef __PortableDeviceClassExtension_FWD_DEFINED__
#define __PortableDeviceClassExtension_FWD_DEFINED__

#ifdef __cplusplus
typedef class PortableDeviceClassExtension PortableDeviceClassExtension;
#else
typedef struct PortableDeviceClassExtension PortableDeviceClassExtension;
#endif /* __cplusplus */

#endif 	/* __PortableDeviceClassExtension_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"
#include "propidl.h"
#include "PortableDeviceTypes.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_PortableDeviceClassExtension_0000_0000 */
/* [local] */ 

#if (_WIN32_WINNT >= 0x0501) // XP and later


extern RPC_IF_HANDLE __MIDL_itf_PortableDeviceClassExtension_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_PortableDeviceClassExtension_0000_0000_v0_0_s_ifspec;

#ifndef __IPortableDeviceClassExtension_INTERFACE_DEFINED__
#define __IPortableDeviceClassExtension_INTERFACE_DEFINED__

/* interface IPortableDeviceClassExtension */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IPortableDeviceClassExtension;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("bc08386a-9952-40cd-ba50-9541d64a4b4e")
    IPortableDeviceClassExtension : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            __RPC__in_opt IUnknown *pWdfDeviceUnknown,
            __RPC__in_opt IPortableDeviceValues *pOptions) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Uninitialize( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ProcessLibraryMessage( 
            __RPC__in_opt IPortableDeviceValues *pParams,
            __RPC__in_opt IPortableDeviceValues *pResults) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPortableDeviceClassExtensionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPortableDeviceClassExtension * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPortableDeviceClassExtension * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPortableDeviceClassExtension * This);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            IPortableDeviceClassExtension * This,
            __RPC__in_opt IUnknown *pWdfDeviceUnknown,
            __RPC__in_opt IPortableDeviceValues *pOptions);
        
        HRESULT ( STDMETHODCALLTYPE *Uninitialize )( 
            IPortableDeviceClassExtension * This);
        
        HRESULT ( STDMETHODCALLTYPE *ProcessLibraryMessage )( 
            IPortableDeviceClassExtension * This,
            __RPC__in_opt IPortableDeviceValues *pParams,
            __RPC__in_opt IPortableDeviceValues *pResults);
        
        END_INTERFACE
    } IPortableDeviceClassExtensionVtbl;

    interface IPortableDeviceClassExtension
    {
        CONST_VTBL struct IPortableDeviceClassExtensionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPortableDeviceClassExtension_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IPortableDeviceClassExtension_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IPortableDeviceClassExtension_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IPortableDeviceClassExtension_Initialize(This,pWdfDeviceUnknown,pOptions)	\
    ( (This)->lpVtbl -> Initialize(This,pWdfDeviceUnknown,pOptions) ) 

#define IPortableDeviceClassExtension_Uninitialize(This)	\
    ( (This)->lpVtbl -> Uninitialize(This) ) 

#define IPortableDeviceClassExtension_ProcessLibraryMessage(This,pParams,pResults)	\
    ( (This)->lpVtbl -> ProcessLibraryMessage(This,pParams,pResults) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IPortableDeviceClassExtension_INTERFACE_DEFINED__ */



#ifndef __PortableDeviceClassExtension_LIBRARY_DEFINED__
#define __PortableDeviceClassExtension_LIBRARY_DEFINED__

/* library PortableDeviceClassExtension */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_PortableDeviceClassExtension;

EXTERN_C const CLSID CLSID_PortableDeviceClassExtension;

#ifdef __cplusplus

class DECLSPEC_UUID("4cadfae1-5512-456a-9d65-5b5e7e9ca9a3")
PortableDeviceClassExtension;
#endif
#endif /* __PortableDeviceClassExtension_LIBRARY_DEFINED__ */

/* interface __MIDL_itf_PortableDeviceClassExtension_0000_0001 */
/* [local] */ 

#endif // (_WIN32_WINNT >= 0x0501)


extern RPC_IF_HANDLE __MIDL_itf_PortableDeviceClassExtension_0000_0001_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_PortableDeviceClassExtension_0000_0001_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\portabledevicetypes.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0499 */
/* Compiler settings for PortableDeviceTypes.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __PortableDeviceTypes_h__
#define __PortableDeviceTypes_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IWpdSerializer_FWD_DEFINED__
#define __IWpdSerializer_FWD_DEFINED__
typedef interface IWpdSerializer IWpdSerializer;
#endif 	/* __IWpdSerializer_FWD_DEFINED__ */


#ifndef __IPortableDeviceValues_FWD_DEFINED__
#define __IPortableDeviceValues_FWD_DEFINED__
typedef interface IPortableDeviceValues IPortableDeviceValues;
#endif 	/* __IPortableDeviceValues_FWD_DEFINED__ */


#ifndef __IPortableDeviceKeyCollection_FWD_DEFINED__
#define __IPortableDeviceKeyCollection_FWD_DEFINED__
typedef interface IPortableDeviceKeyCollection IPortableDeviceKeyCollection;
#endif 	/* __IPortableDeviceKeyCollection_FWD_DEFINED__ */


#ifndef __IPortableDevicePropVariantCollection_FWD_DEFINED__
#define __IPortableDevicePropVariantCollection_FWD_DEFINED__
typedef interface IPortableDevicePropVariantCollection IPortableDevicePropVariantCollection;
#endif 	/* __IPortableDevicePropVariantCollection_FWD_DEFINED__ */


#ifndef __IPortableDeviceValuesCollection_FWD_DEFINED__
#define __IPortableDeviceValuesCollection_FWD_DEFINED__
typedef interface IPortableDeviceValuesCollection IPortableDeviceValuesCollection;
#endif 	/* __IPortableDeviceValuesCollection_FWD_DEFINED__ */


#ifndef __WpdSerializer_FWD_DEFINED__
#define __WpdSerializer_FWD_DEFINED__

#ifdef __cplusplus
typedef class WpdSerializer WpdSerializer;
#else
typedef struct WpdSerializer WpdSerializer;
#endif /* __cplusplus */

#endif 	/* __WpdSerializer_FWD_DEFINED__ */


#ifndef __PortableDeviceValues_FWD_DEFINED__
#define __PortableDeviceValues_FWD_DEFINED__

#ifdef __cplusplus
typedef class PortableDeviceValues PortableDeviceValues;
#else
typedef struct PortableDeviceValues PortableDeviceValues;
#endif /* __cplusplus */

#endif 	/* __PortableDeviceValues_FWD_DEFINED__ */


#ifndef __PortableDeviceKeyCollection_FWD_DEFINED__
#define __PortableDeviceKeyCollection_FWD_DEFINED__

#ifdef __cplusplus
typedef class PortableDeviceKeyCollection PortableDeviceKeyCollection;
#else
typedef struct PortableDeviceKeyCollection PortableDeviceKeyCollection;
#endif /* __cplusplus */

#endif 	/* __PortableDeviceKeyCollection_FWD_DEFINED__ */


#ifndef __PortableDevicePropVariantCollection_FWD_DEFINED__
#define __PortableDevicePropVariantCollection_FWD_DEFINED__

#ifdef __cplusplus
typedef class PortableDevicePropVariantCollection PortableDevicePropVariantCollection;
#else
typedef struct PortableDevicePropVariantCollection PortableDevicePropVariantCollection;
#endif /* __cplusplus */

#endif 	/* __PortableDevicePropVariantCollection_FWD_DEFINED__ */


#ifndef __PortableDeviceValuesCollection_FWD_DEFINED__
#define __PortableDeviceValuesCollection_FWD_DEFINED__

#ifdef __cplusplus
typedef class PortableDeviceValuesCollection PortableDeviceValuesCollection;
#else
typedef struct PortableDeviceValuesCollection PortableDeviceValuesCollection;
#endif /* __cplusplus */

#endif 	/* __PortableDeviceValuesCollection_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"
#include "propsys.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_PortableDeviceTypes_0000_0000 */
/* [local] */ 

#if (_WIN32_WINNT >= 0x0501) // Longhorn and later







extern RPC_IF_HANDLE __MIDL_itf_PortableDeviceTypes_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_PortableDeviceTypes_0000_0000_v0_0_s_ifspec;

#ifndef __IWpdSerializer_INTERFACE_DEFINED__
#define __IWpdSerializer_INTERFACE_DEFINED__

/* interface IWpdSerializer */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IWpdSerializer;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("b32f4002-bb27-45ff-af4f-06631c1e8dad")
    IWpdSerializer : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetIPortableDeviceValuesFromBuffer( 
            /* [size_is][in] */ __RPC__in_ecount_full(dwInputBufferLength) BYTE *pBuffer,
            /* [in] */ DWORD dwInputBufferLength,
            /* [out] */ __RPC__deref_out_opt IPortableDeviceValues **ppParams) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE WriteIPortableDeviceValuesToBuffer( 
            /* [in] */ DWORD dwOutputBufferLength,
            /* [in] */ __RPC__in_opt IPortableDeviceValues *pResults,
            /* [length_is][size_is][out] */ __RPC__out_ecount_part(dwOutputBufferLength, *pdwBytesWritten) BYTE *pBuffer,
            /* [out] */ __RPC__out DWORD *pdwBytesWritten) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBufferFromIPortableDeviceValues( 
            /* [in] */ __RPC__in_opt IPortableDeviceValues *pSource,
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*pdwBufferSize) BYTE **ppBuffer,
            /* [out] */ __RPC__out DWORD *pdwBufferSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSerializedSize( 
            /* [in] */ __RPC__in_opt IPortableDeviceValues *pSource,
            /* [out] */ __RPC__out DWORD *pdwSize) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWpdSerializerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWpdSerializer * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWpdSerializer * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWpdSerializer * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetIPortableDeviceValuesFromBuffer )( 
            IWpdSerializer * This,
            /* [size_is][in] */ __RPC__in_ecount_full(dwInputBufferLength) BYTE *pBuffer,
            /* [in] */ DWORD dwInputBufferLength,
            /* [out] */ __RPC__deref_out_opt IPortableDeviceValues **ppParams);
        
        HRESULT ( STDMETHODCALLTYPE *WriteIPortableDeviceValuesToBuffer )( 
            IWpdSerializer * This,
            /* [in] */ DWORD dwOutputBufferLength,
            /* [in] */ __RPC__in_opt IPortableDeviceValues *pResults,
            /* [length_is][size_is][out] */ __RPC__out_ecount_part(dwOutputBufferLength, *pdwBytesWritten) BYTE *pBuffer,
            /* [out] */ __RPC__out DWORD *pdwBytesWritten);
        
        HRESULT ( STDMETHODCALLTYPE *GetBufferFromIPortableDeviceValues )( 
            IWpdSerializer * This,
            /* [in] */ __RPC__in_opt IPortableDeviceValues *pSource,
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*pdwBufferSize) BYTE **ppBuffer,
            /* [out] */ __RPC__out DWORD *pdwBufferSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetSerializedSize )( 
            IWpdSerializer * This,
            /* [in] */ __RPC__in_opt IPortableDeviceValues *pSource,
            /* [out] */ __RPC__out DWORD *pdwSize);
        
        END_INTERFACE
    } IWpdSerializerVtbl;

    interface IWpdSerializer
    {
        CONST_VTBL struct IWpdSerializerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWpdSerializer_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWpdSerializer_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWpdSerializer_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWpdSerializer_GetIPortableDeviceValuesFromBuffer(This,pBuffer,dwInputBufferLength,ppParams)	\
    ( (This)->lpVtbl -> GetIPortableDeviceValuesFromBuffer(This,pBuffer,dwInputBufferLength,ppParams) ) 

#define IWpdSerializer_WriteIPortableDeviceValuesToBuffer(This,dwOutputBufferLength,pResults,pBuffer,pdwBytesWritten)	\
    ( (This)->lpVtbl -> WriteIPortableDeviceValuesToBuffer(This,dwOutputBufferLength,pResults,pBuffer,pdwBytesWritten) ) 

#define IWpdSerializer_GetBufferFromIPortableDeviceValues(This,pSource,ppBuffer,pdwBufferSize)	\
    ( (This)->lpVtbl -> GetBufferFromIPortableDeviceValues(This,pSource,ppBuffer,pdwBufferSize) ) 

#define IWpdSerializer_GetSerializedSize(This,pSource,pdwSize)	\
    ( (This)->lpVtbl -> GetSerializedSize(This,pSource,pdwSize) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWpdSerializer_INTERFACE_DEFINED__ */


#ifndef __IPortableDeviceValues_INTERFACE_DEFINED__
#define __IPortableDeviceValues_INTERFACE_DEFINED__

/* interface IPortableDeviceValues */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IPortableDeviceValues;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6848f6f2-3155-4f86-b6f5-263eeeab3143")
    IPortableDeviceValues : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCount( 
            /* [in] */ __RPC__in DWORD *pcelt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAt( 
            /* [in] */ const DWORD index,
            /* [unique][out][in] */ __RPC__inout_opt PROPERTYKEY *pKey,
            /* [unique][out][in] */ __RPC__inout_opt PROPVARIANT *pValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetValue( 
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [in] */ __RPC__in const PROPVARIANT *pValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetValue( 
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [out] */ __RPC__out PROPVARIANT *pValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetStringValue( 
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [in] */ __RPC__in LPCWSTR Value) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStringValue( 
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [out] */ __RPC__deref_out_opt LPWSTR *pValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetUnsignedIntegerValue( 
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [in] */ const ULONG Value) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetUnsignedIntegerValue( 
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [out] */ __RPC__out ULONG *pValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetSignedIntegerValue( 
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [in] */ const LONG Value) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSignedIntegerValue( 
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [out] */ __RPC__out LONG *pValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetUnsignedLargeIntegerValue( 
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [in] */ const ULONGLONG Value) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetUnsignedLargeIntegerValue( 
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [out] */ __RPC__out ULONGLONG *pValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetSignedLargeIntegerValue( 
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [in] */ const LONGLONG Value) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSignedLargeIntegerValue( 
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [out] */ __RPC__out LONGLONG *pValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetFloatValue( 
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [in] */ const FLOAT Value) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFloatValue( 
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [out] */ __RPC__out FLOAT *pValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetErrorValue( 
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [in] */ const HRESULT Value) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetErrorValue( 
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [out] */ __RPC__out HRESULT *pValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetKeyValue( 
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [in] */ __RPC__in REFPROPERTYKEY Value) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetKeyValue( 
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [out] */ __RPC__out PROPERTYKEY *pValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetBoolValue( 
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [in] */ const BOOL Value) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBoolValue( 
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [out] */ __RPC__out BOOL *pValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetIUnknownValue( 
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [in] */ __RPC__in_opt IUnknown *pValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetIUnknownValue( 
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [out] */ __RPC__deref_out_opt IUnknown **ppValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetGuidValue( 
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [in] */ __RPC__in REFGUID Value) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetGuidValue( 
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [out] */ __RPC__out GUID *pValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetBufferValue( 
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [size_is][in] */ __RPC__in_ecount_full(cbValue) BYTE *pValue,
            /* [in] */ DWORD cbValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBufferValue( 
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*pcbValue) BYTE **ppValue,
            /* [out] */ __RPC__out DWORD *pcbValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetIPortableDeviceValuesValue( 
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [in] */ __RPC__in_opt IPortableDeviceValues *pValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetIPortableDeviceValuesValue( 
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [out] */ __RPC__deref_out_opt IPortableDeviceValues **ppValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetIPortableDevicePropVariantCollectionValue( 
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [in] */ __RPC__in_opt IPortableDevicePropVariantCollection *pValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetIPortableDevicePropVariantCollectionValue( 
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [out] */ __RPC__deref_out_opt IPortableDevicePropVariantCollection **ppValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetIPortableDeviceKeyCollectionValue( 
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [in] */ __RPC__in_opt IPortableDeviceKeyCollection *pValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetIPortableDeviceKeyCollectionValue( 
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [out] */ __RPC__deref_out_opt IPortableDeviceKeyCollection **ppValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetIPortableDeviceValuesCollectionValue( 
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [in] */ __RPC__in_opt IPortableDeviceValuesCollection *pValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetIPortableDeviceValuesCollectionValue( 
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [out] */ __RPC__deref_out_opt IPortableDeviceValuesCollection **ppValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveValue( 
            /* [in] */ __RPC__in REFPROPERTYKEY key) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CopyValuesFromPropertyStore( 
            /* [in] */ __RPC__in_opt IPropertyStore *pStore) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CopyValuesToPropertyStore( 
            /* [in] */ __RPC__in_opt IPropertyStore *pStore) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clear( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPortableDeviceValuesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPortableDeviceValues * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPortableDeviceValues * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPortableDeviceValues * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            IPortableDeviceValues * This,
            /* [in] */ __RPC__in DWORD *pcelt);
        
        HRESULT ( STDMETHODCALLTYPE *GetAt )( 
            IPortableDeviceValues * This,
            /* [in] */ const DWORD index,
            /* [unique][out][in] */ __RPC__inout_opt PROPERTYKEY *pKey,
            /* [unique][out][in] */ __RPC__inout_opt PROPVARIANT *pValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetValue )( 
            IPortableDeviceValues * This,
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [in] */ __RPC__in const PROPVARIANT *pValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetValue )( 
            IPortableDeviceValues * This,
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [out] */ __RPC__out PROPVARIANT *pValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetStringValue )( 
            IPortableDeviceValues * This,
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [in] */ __RPC__in LPCWSTR Value);
        
        HRESULT ( STDMETHODCALLTYPE *GetStringValue )( 
            IPortableDeviceValues * This,
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [out] */ __RPC__deref_out_opt LPWSTR *pValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetUnsignedIntegerValue )( 
            IPortableDeviceValues * This,
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [in] */ const ULONG Value);
        
        HRESULT ( STDMETHODCALLTYPE *GetUnsignedIntegerValue )( 
            IPortableDeviceValues * This,
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [out] */ __RPC__out ULONG *pValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetSignedIntegerValue )( 
            IPortableDeviceValues * This,
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [in] */ const LONG Value);
        
        HRESULT ( STDMETHODCALLTYPE *GetSignedIntegerValue )( 
            IPortableDeviceValues * This,
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [out] */ __RPC__out LONG *pValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetUnsignedLargeIntegerValue )( 
            IPortableDeviceValues * This,
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [in] */ const ULONGLONG Value);
        
        HRESULT ( STDMETHODCALLTYPE *GetUnsignedLargeIntegerValue )( 
            IPortableDeviceValues * This,
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [out] */ __RPC__out ULONGLONG *pValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetSignedLargeIntegerValue )( 
            IPortableDeviceValues * This,
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [in] */ const LONGLONG Value);
        
        HRESULT ( STDMETHODCALLTYPE *GetSignedLargeIntegerValue )( 
            IPortableDeviceValues * This,
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [out] */ __RPC__out LONGLONG *pValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetFloatValue )( 
            IPortableDeviceValues * This,
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [in] */ const FLOAT Value);
        
        HRESULT ( STDMETHODCALLTYPE *GetFloatValue )( 
            IPortableDeviceValues * This,
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [out] */ __RPC__out FLOAT *pValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetErrorValue )( 
            IPortableDeviceValues * This,
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [in] */ const HRESULT Value);
        
        HRESULT ( STDMETHODCALLTYPE *GetErrorValue )( 
            IPortableDeviceValues * This,
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [out] */ __RPC__out HRESULT *pValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetKeyValue )( 
            IPortableDeviceValues * This,
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [in] */ __RPC__in REFPROPERTYKEY Value);
        
        HRESULT ( STDMETHODCALLTYPE *GetKeyValue )( 
            IPortableDeviceValues * This,
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [out] */ __RPC__out PROPERTYKEY *pValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetBoolValue )( 
            IPortableDeviceValues * This,
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [in] */ const BOOL Value);
        
        HRESULT ( STDMETHODCALLTYPE *GetBoolValue )( 
            IPortableDeviceValues * This,
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [out] */ __RPC__out BOOL *pValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetIUnknownValue )( 
            IPortableDeviceValues * This,
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [in] */ __RPC__in_opt IUnknown *pValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetIUnknownValue )( 
            IPortableDeviceValues * This,
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [out] */ __RPC__deref_out_opt IUnknown **ppValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetGuidValue )( 
            IPortableDeviceValues * This,
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [in] */ __RPC__in REFGUID Value);
        
        HRESULT ( STDMETHODCALLTYPE *GetGuidValue )( 
            IPortableDeviceValues * This,
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [out] */ __RPC__out GUID *pValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetBufferValue )( 
            IPortableDeviceValues * This,
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [size_is][in] */ __RPC__in_ecount_full(cbValue) BYTE *pValue,
            /* [in] */ DWORD cbValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetBufferValue )( 
            IPortableDeviceValues * This,
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*pcbValue) BYTE **ppValue,
            /* [out] */ __RPC__out DWORD *pcbValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetIPortableDeviceValuesValue )( 
            IPortableDeviceValues * This,
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [in] */ __RPC__in_opt IPortableDeviceValues *pValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetIPortableDeviceValuesValue )( 
            IPortableDeviceValues * This,
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [out] */ __RPC__deref_out_opt IPortableDeviceValues **ppValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetIPortableDevicePropVariantCollectionValue )( 
            IPortableDeviceValues * This,
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [in] */ __RPC__in_opt IPortableDevicePropVariantCollection *pValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetIPortableDevicePropVariantCollectionValue )( 
            IPortableDeviceValues * This,
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [out] */ __RPC__deref_out_opt IPortableDevicePropVariantCollection **ppValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetIPortableDeviceKeyCollectionValue )( 
            IPortableDeviceValues * This,
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [in] */ __RPC__in_opt IPortableDeviceKeyCollection *pValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetIPortableDeviceKeyCollectionValue )( 
            IPortableDeviceValues * This,
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [out] */ __RPC__deref_out_opt IPortableDeviceKeyCollection **ppValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetIPortableDeviceValuesCollectionValue )( 
            IPortableDeviceValues * This,
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [in] */ __RPC__in_opt IPortableDeviceValuesCollection *pValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetIPortableDeviceValuesCollectionValue )( 
            IPortableDeviceValues * This,
            /* [in] */ __RPC__in REFPROPERTYKEY key,
            /* [out] */ __RPC__deref_out_opt IPortableDeviceValuesCollection **ppValue);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveValue )( 
            IPortableDeviceValues * This,
            /* [in] */ __RPC__in REFPROPERTYKEY key);
        
        HRESULT ( STDMETHODCALLTYPE *CopyValuesFromPropertyStore )( 
            IPortableDeviceValues * This,
            /* [in] */ __RPC__in_opt IPropertyStore *pStore);
        
        HRESULT ( STDMETHODCALLTYPE *CopyValuesToPropertyStore )( 
            IPortableDeviceValues * This,
            /* [in] */ __RPC__in_opt IPropertyStore *pStore);
        
        HRESULT ( STDMETHODCALLTYPE *Clear )( 
            IPortableDeviceValues * This);
        
        END_INTERFACE
    } IPortableDeviceValuesVtbl;

    interface IPortableDeviceValues
    {
        CONST_VTBL struct IPortableDeviceValuesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPortableDeviceValues_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IPortableDeviceValues_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IPortableDeviceValues_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IPortableDeviceValues_GetCount(This,pcelt)	\
    ( (This)->lpVtbl -> GetCount(This,pcelt) ) 

#define IPortableDeviceValues_GetAt(This,index,pKey,pValue)	\
    ( (This)->lpVtbl -> GetAt(This,index,pKey,pValue) ) 

#define IPortableDeviceValues_SetValue(This,key,pValue)	\
    ( (This)->lpVtbl -> SetValue(This,key,pValue) ) 

#define IPortableDeviceValues_GetValue(This,key,pValue)	\
    ( (This)->lpVtbl -> GetValue(This,key,pValue) ) 

#define IPortableDeviceValues_SetStringValue(This,key,Value)	\
    ( (This)->lpVtbl -> SetStringValue(This,key,Value) ) 

#define IPortableDeviceValues_GetStringValue(This,key,pValue)	\
    ( (This)->lpVtbl -> GetStringValue(This,key,pValue) ) 

#define IPortableDeviceValues_SetUnsignedIntegerValue(This,key,Value)	\
    ( (This)->lpVtbl -> SetUnsignedIntegerValue(This,key,Value) ) 

#define IPortableDeviceValues_GetUnsignedIntegerValue(This,key,pValue)	\
    ( (This)->lpVtbl -> GetUnsignedIntegerValue(This,key,pValue) ) 

#define IPortableDeviceValues_SetSignedIntegerValue(This,key,Value)	\
    ( (This)->lpVtbl -> SetSignedIntegerValue(This,key,Value) ) 

#define IPortableDeviceValues_GetSignedIntegerValue(This,key,pValue)	\
    ( (This)->lpVtbl -> GetSignedIntegerValue(This,key,pValue) ) 

#define IPortableDeviceValues_SetUnsignedLargeIntegerValue(This,key,Value)	\
    ( (This)->lpVtbl -> SetUnsignedLargeIntegerValue(This,key,Value) ) 

#define IPortableDeviceValues_GetUnsignedLargeIntegerValue(This,key,pValue)	\
    ( (This)->lpVtbl -> GetUnsignedLargeIntegerValue(This,key,pValue) ) 

#define IPortableDeviceValues_SetSignedLargeIntegerValue(This,key,Value)	\
    ( (This)->lpVtbl -> SetSignedLargeIntegerValue(This,key,Value) ) 

#define IPortableDeviceValues_GetSignedLargeIntegerValue(This,key,pValue)	\
    ( (This)->lpVtbl -> GetSignedLargeIntegerValue(This,key,pValue) ) 

#define IPortableDeviceValues_SetFloatValue(This,key,Value)	\
    ( (This)->lpVtbl -> SetFloatValue(This,key,Value) ) 

#define IPortableDeviceValues_GetFloatValue(This,key,pValue)	\
    ( (This)->lpVtbl -> GetFloatValue(This,key,pValue) ) 

#define IPortableDeviceValues_SetErrorValue(This,key,Value)	\
    ( (This)->lpVtbl -> SetErrorValue(This,key,Value) ) 

#define IPortableDeviceValues_GetErrorValue(This,key,pValue)	\
    ( (This)->lpVtbl -> GetErrorValue(This,key,pValue) ) 

#define IPortableDeviceValues_SetKeyValue(This,key,Value)	\
    ( (This)->lpVtbl -> SetKeyValue(This,key,Value) ) 

#define IPortableDeviceValues_GetKeyValue(This,key,pValue)	\
    ( (This)->lpVtbl -> GetKeyValue(This,key,pValue) ) 

#define IPortableDeviceValues_SetBoolValue(This,key,Value)	\
    ( (This)->lpVtbl -> SetBoolValue(This,key,Value) ) 

#define IPortableDeviceValues_GetBoolValue(This,key,pValue)	\
    ( (This)->lpVtbl -> GetBoolValue(This,key,pValue) ) 

#define IPortableDeviceValues_SetIUnknownValue(This,key,pValue)	\
    ( (This)->lpVtbl -> SetIUnknownValue(This,key,pValue) ) 

#define IPortableDeviceValues_GetIUnknownValue(This,key,ppValue)	\
    ( (This)->lpVtbl -> GetIUnknownValue(This,key,ppValue) ) 

#define IPortableDeviceValues_SetGuidValue(This,key,Value)	\
    ( (This)->lpVtbl -> SetGuidValue(This,key,Value) ) 

#define IPortableDeviceValues_GetGuidValue(This,key,pValue)	\
    ( (This)->lpVtbl -> GetGuidValue(This,key,pValue) ) 

#define IPortableDeviceValues_SetBufferValue(This,key,pValue,cbValue)	\
    ( (This)->lpVtbl -> SetBufferValue(This,key,pValue,cbValue) ) 

#define IPortableDeviceValues_GetBufferValue(This,key,ppValue,pcbValue)	\
    ( (This)->lpVtbl -> GetBufferValue(This,key,ppValue,pcbValue) ) 

#define IPortableDeviceValues_SetIPortableDeviceValuesValue(This,key,pValue)	\
    ( (This)->lpVtbl -> SetIPortableDeviceValuesValue(This,key,pValue) ) 

#define IPortableDeviceValues_GetIPortableDeviceValuesValue(This,key,ppValue)	\
    ( (This)->lpVtbl -> GetIPortableDeviceValuesValue(This,key,ppValue) ) 

#define IPortableDeviceValues_SetIPortableDevicePropVariantCollectionValue(This,key,pValue)	\
    ( (This)->lpVtbl -> SetIPortableDevicePropVariantCollectionValue(This,key,pValue) ) 

#define IPortableDeviceValues_GetIPortableDevicePropVariantCollectionValue(This,key,ppValue)	\
    ( (This)->lpVtbl -> GetIPortableDevicePropVariantCollectionValue(This,key,ppValue) ) 

#define IPortableDeviceValues_SetIPortableDeviceKeyCollectionValue(This,key,pValue)	\
    ( (This)->lpVtbl -> SetIPortableDeviceKeyCollectionValue(This,key,pValue) ) 

#define IPortableDeviceValues_GetIPortableDeviceKeyCollectionValue(This,key,ppValue)	\
    ( (This)->lpVtbl -> GetIPortableDeviceKeyCollectionValue(This,key,ppValue) ) 

#define IPortableDeviceValues_SetIPortableDeviceValuesCollectionValue(This,key,pValue)	\
    ( (This)->lpVtbl -> SetIPortableDeviceValuesCollectionValue(This,key,pValue) ) 

#define IPortableDeviceValues_GetIPortableDeviceValuesCollectionValue(This,key,ppValue)	\
    ( (This)->lpVtbl -> GetIPortableDeviceValuesCollectionValue(This,key,ppValue) ) 

#define IPortableDeviceValues_RemoveValue(This,key)	\
    ( (This)->lpVtbl -> RemoveValue(This,key) ) 

#define IPortableDeviceValues_CopyValuesFromPropertyStore(This,pStore)	\
    ( (This)->lpVtbl -> CopyValuesFromPropertyStore(This,pStore) ) 

#define IPortableDeviceValues_CopyValuesToPropertyStore(This,pStore)	\
    ( (This)->lpVtbl -> CopyValuesToPropertyStore(This,pStore) ) 

#define IPortableDeviceValues_Clear(This)	\
    ( (This)->lpVtbl -> Clear(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IPortableDeviceValues_INTERFACE_DEFINED__ */


#ifndef __IPortableDeviceKeyCollection_INTERFACE_DEFINED__
#define __IPortableDeviceKeyCollection_INTERFACE_DEFINED__

/* interface IPortableDeviceKeyCollection */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IPortableDeviceKeyCollection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("dada2357-e0ad-492e-98db-dd61c53ba353")
    IPortableDeviceKeyCollection : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCount( 
            /* [in] */ __RPC__in DWORD *pcElems) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAt( 
            /* [in] */ const DWORD dwIndex,
            /* [in] */ __RPC__in PROPERTYKEY *pKey) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Add( 
            /* [in] */ __RPC__in REFPROPERTYKEY Key) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clear( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveAt( 
            /* [in] */ const DWORD dwIndex) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPortableDeviceKeyCollectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPortableDeviceKeyCollection * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPortableDeviceKeyCollection * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPortableDeviceKeyCollection * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            IPortableDeviceKeyCollection * This,
            /* [in] */ __RPC__in DWORD *pcElems);
        
        HRESULT ( STDMETHODCALLTYPE *GetAt )( 
            IPortableDeviceKeyCollection * This,
            /* [in] */ const DWORD dwIndex,
            /* [in] */ __RPC__in PROPERTYKEY *pKey);
        
        HRESULT ( STDMETHODCALLTYPE *Add )( 
            IPortableDeviceKeyCollection * This,
            /* [in] */ __RPC__in REFPROPERTYKEY Key);
        
        HRESULT ( STDMETHODCALLTYPE *Clear )( 
            IPortableDeviceKeyCollection * This);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveAt )( 
            IPortableDeviceKeyCollection * This,
            /* [in] */ const DWORD dwIndex);
        
        END_INTERFACE
    } IPortableDeviceKeyCollectionVtbl;

    interface IPortableDeviceKeyCollection
    {
        CONST_VTBL struct IPortableDeviceKeyCollectionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPortableDeviceKeyCollection_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IPortableDeviceKeyCollection_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IPortableDeviceKeyCollection_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IPortableDeviceKeyCollection_GetCount(This,pcElems)	\
    ( (This)->lpVtbl -> GetCount(This,pcElems) ) 

#define IPortableDeviceKeyCollection_GetAt(This,dwIndex,pKey)	\
    ( (This)->lpVtbl -> GetAt(This,dwIndex,pKey) ) 

#define IPortableDeviceKeyCollection_Add(This,Key)	\
    ( (This)->lpVtbl -> Add(This,Key) ) 

#define IPortableDeviceKeyCollection_Clear(This)	\
    ( (This)->lpVtbl -> Clear(This) ) 

#define IPortableDeviceKeyCollection_RemoveAt(This,dwIndex)	\
    ( (This)->lpVtbl -> RemoveAt(This,dwIndex) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IPortableDeviceKeyCollection_INTERFACE_DEFINED__ */


#ifndef __IPortableDevicePropVariantCollection_INTERFACE_DEFINED__
#define __IPortableDevicePropVariantCollection_INTERFACE_DEFINED__

/* interface IPortableDevicePropVariantCollection */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IPortableDevicePropVariantCollection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("89b2e422-4f1b-4316-bcef-a44afea83eb3")
    IPortableDevicePropVariantCollection : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCount( 
            /* [in] */ __RPC__in DWORD *pcElems) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAt( 
            /* [in] */ const DWORD dwIndex,
            /* [in] */ __RPC__in PROPVARIANT *pValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Add( 
            /* [in] */ __RPC__in const PROPVARIANT *pValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetType( 
            /* [out] */ __RPC__out VARTYPE *pvt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ChangeType( 
            /* [in] */ const VARTYPE vt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clear( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveAt( 
            /* [in] */ const DWORD dwIndex) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPortableDevicePropVariantCollectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPortableDevicePropVariantCollection * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPortableDevicePropVariantCollection * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPortableDevicePropVariantCollection * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            IPortableDevicePropVariantCollection * This,
            /* [in] */ __RPC__in DWORD *pcElems);
        
        HRESULT ( STDMETHODCALLTYPE *GetAt )( 
            IPortableDevicePropVariantCollection * This,
            /* [in] */ const DWORD dwIndex,
            /* [in] */ __RPC__in PROPVARIANT *pValue);
        
        HRESULT ( STDMETHODCALLTYPE *Add )( 
            IPortableDevicePropVariantCollection * This,
            /* [in] */ __RPC__in const PROPVARIANT *pValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetType )( 
            IPortableDevicePropVariantCollection * This,
            /* [out] */ __RPC__out VARTYPE *pvt);
        
        HRESULT ( STDMETHODCALLTYPE *ChangeType )( 
            IPortableDevicePropVariantCollection * This,
            /* [in] */ const VARTYPE vt);
        
        HRESULT ( STDMETHODCALLTYPE *Clear )( 
            IPortableDevicePropVariantCollection * This);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveAt )( 
            IPortableDevicePropVariantCollection * This,
            /* [in] */ const DWORD dwIndex);
        
        END_INTERFACE
    } IPortableDevicePropVariantCollectionVtbl;

    interface IPortableDevicePropVariantCollection
    {
        CONST_VTBL struct IPortableDevicePropVariantCollectionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPortableDevicePropVariantCollection_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IPortableDevicePropVariantCollection_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IPortableDevicePropVariantCollection_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IPortableDevicePropVariantCollection_GetCount(This,pcElems)	\
    ( (This)->lpVtbl -> GetCount(This,pcElems) ) 

#define IPortableDevicePropVariantCollection_GetAt(This,dwIndex,pValue)	\
    ( (This)->lpVtbl -> GetAt(This,dwIndex,pValue) ) 

#define IPortableDevicePropVariantCollection_Add(This,pValue)	\
    ( (This)->lpVtbl -> Add(This,pValue) ) 

#define IPortableDevicePropVariantCollection_GetType(This,pvt)	\
    ( (This)->lpVtbl -> GetType(This,pvt) ) 

#define IPortableDevicePropVariantCollection_ChangeType(This,vt)	\
    ( (This)->lpVtbl -> ChangeType(This,vt) ) 

#define IPortableDevicePropVariantCollection_Clear(This)	\
    ( (This)->lpVtbl -> Clear(This) ) 

#define IPortableDevicePropVariantCollection_RemoveAt(This,dwIndex)	\
    ( (This)->lpVtbl -> RemoveAt(This,dwIndex) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IPortableDevicePropVariantCollection_INTERFACE_DEFINED__ */


#ifndef __IPortableDeviceValuesCollection_INTERFACE_DEFINED__
#define __IPortableDeviceValuesCollection_INTERFACE_DEFINED__

/* interface IPortableDeviceValuesCollection */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IPortableDeviceValuesCollection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6e3f2d79-4e07-48c4-8208-d8c2e5af4a99")
    IPortableDeviceValuesCollection : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCount( 
            /* [in] */ __RPC__in DWORD *pcElems) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAt( 
            /* [in] */ const DWORD dwIndex,
            /* [out] */ __RPC__deref_out_opt IPortableDeviceValues **ppValues) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Add( 
            /* [in] */ __RPC__in_opt IPortableDeviceValues *pValues) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clear( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveAt( 
            /* [in] */ const DWORD dwIndex) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPortableDeviceValuesCollectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPortableDeviceValuesCollection * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPortableDeviceValuesCollection * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPortableDeviceValuesCollection * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            IPortableDeviceValuesCollection * This,
            /* [in] */ __RPC__in DWORD *pcElems);
        
        HRESULT ( STDMETHODCALLTYPE *GetAt )( 
            IPortableDeviceValuesCollection * This,
            /* [in] */ const DWORD dwIndex,
            /* [out] */ __RPC__deref_out_opt IPortableDeviceValues **ppValues);
        
        HRESULT ( STDMETHODCALLTYPE *Add )( 
            IPortableDeviceValuesCollection * This,
            /* [in] */ __RPC__in_opt IPortableDeviceValues *pValues);
        
        HRESULT ( STDMETHODCALLTYPE *Clear )( 
            IPortableDeviceValuesCollection * This);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveAt )( 
            IPortableDeviceValuesCollection * This,
            /* [in] */ const DWORD dwIndex);
        
        END_INTERFACE
    } IPortableDeviceValuesCollectionVtbl;

    interface IPortableDeviceValuesCollection
    {
        CONST_VTBL struct IPortableDeviceValuesCollectionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPortableDeviceValuesCollection_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IPortableDeviceValuesCollection_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IPortableDeviceValuesCollection_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IPortableDeviceValuesCollection_GetCount(This,pcElems)	\
    ( (This)->lpVtbl -> GetCount(This,pcElems) ) 

#define IPortableDeviceValuesCollection_GetAt(This,dwIndex,ppValues)	\
    ( (This)->lpVtbl -> GetAt(This,dwIndex,ppValues) ) 

#define IPortableDeviceValuesCollection_Add(This,pValues)	\
    ( (This)->lpVtbl -> Add(This,pValues) ) 

#define IPortableDeviceValuesCollection_Clear(This)	\
    ( (This)->lpVtbl -> Clear(This) ) 

#define IPortableDeviceValuesCollection_RemoveAt(This,dwIndex)	\
    ( (This)->lpVtbl -> RemoveAt(This,dwIndex) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IPortableDeviceValuesCollection_INTERFACE_DEFINED__ */



#ifndef __PortableDeviceTypesLib_LIBRARY_DEFINED__
#define __PortableDeviceTypesLib_LIBRARY_DEFINED__

/* library PortableDeviceTypesLib */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_PortableDeviceTypesLib;

EXTERN_C const CLSID CLSID_WpdSerializer;

#ifdef __cplusplus

class DECLSPEC_UUID("0b91a74b-ad7c-4a9d-b563-29eef9167172")
WpdSerializer;
#endif

EXTERN_C const CLSID CLSID_PortableDeviceValues;

#ifdef __cplusplus

class DECLSPEC_UUID("0c15d503-d017-47ce-9016-7b3f978721cc")
PortableDeviceValues;
#endif

EXTERN_C const CLSID CLSID_PortableDeviceKeyCollection;

#ifdef __cplusplus

class DECLSPEC_UUID("de2d022d-2480-43be-97f0-d1fa2cf98f4f")
PortableDeviceKeyCollection;
#endif

EXTERN_C const CLSID CLSID_PortableDevicePropVariantCollection;

#ifdef __cplusplus

class DECLSPEC_UUID("08a99e2f-6d6d-4b80-af5a-baf2bcbe4cb9")
PortableDevicePropVariantCollection;
#endif

EXTERN_C const CLSID CLSID_PortableDeviceValuesCollection;

#ifdef __cplusplus

class DECLSPEC_UUID("3882134d-14cf-4220-9cb4-435f86d83f60")
PortableDeviceValuesCollection;
#endif
#endif /* __PortableDeviceTypesLib_LIBRARY_DEFINED__ */

/* interface __MIDL_itf_PortableDeviceTypes_0000_0005 */
/* [local] */ 

#endif // (_WIN32_WINNT >= 0x0501)


extern RPC_IF_HANDLE __MIDL_itf_PortableDeviceTypes_0000_0005_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_PortableDeviceTypes_0000_0005_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * ); 

unsigned long             __RPC_USER  LPSAFEARRAY_UserSize(     unsigned long *, unsigned long            , LPSAFEARRAY * ); 
unsigned char * __RPC_USER  LPSAFEARRAY_UserMarshal(  unsigned long *, unsigned char *, LPSAFEARRAY * ); 
unsigned char * __RPC_USER  LPSAFEARRAY_UserUnmarshal(unsigned long *, unsigned char *, LPSAFEARRAY * ); 
void                      __RPC_USER  LPSAFEARRAY_UserFree(     unsigned long *, LPSAFEARRAY * ); 

unsigned long             __RPC_USER  BSTR_UserSize64(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal64(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal64(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree64(     unsigned long *, BSTR * ); 

unsigned long             __RPC_USER  LPSAFEARRAY_UserSize64(     unsigned long *, unsigned long            , LPSAFEARRAY * ); 
unsigned char * __RPC_USER  LPSAFEARRAY_UserMarshal64(  unsigned long *, unsigned char *, LPSAFEARRAY * ); 
unsigned char * __RPC_USER  LPSAFEARRAY_UserUnmarshal64(unsigned long *, unsigned char *, LPSAFEARRAY * ); 
void                      __RPC_USER  LPSAFEARRAY_UserFree64(     unsigned long *, LPSAFEARRAY * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\richole.h ===
#ifndef _RICHOLE_
#define _RICHOLE_

#if _MSC_VER > 1000
#pragma once
#endif

/*
 *	RICHOLE.H
 *
 *	Purpose:
 *		OLE Extensions to the Rich Text Editor
 *
 *	Copyright (c) 1985-1999, Microsoft Corporation
 */

// Structure passed to GetObject and InsertObject
typedef struct _reobject
{
	DWORD			cbStruct;			// Size of structure
	LONG			cp;					// Character position of object
	CLSID			clsid;				// Class ID of object
	LPOLEOBJECT		poleobj;			// OLE object interface
	LPSTORAGE		pstg;				// Associated storage interface
	LPOLECLIENTSITE	polesite;			// Associated client site interface
	SIZEL			sizel;				// Size of object (may be 0,0)
	DWORD			dvaspect;			// Display aspect to use
	DWORD			dwFlags;			// Object status flags
	DWORD			dwUser;				// Dword for user's use
} REOBJECT;

// Flags to specify which interfaces should be returned in the structure above
#define REO_GETOBJ_NO_INTERFACES	(0x00000000L)
#define REO_GETOBJ_POLEOBJ			(0x00000001L)
#define REO_GETOBJ_PSTG				(0x00000002L)
#define REO_GETOBJ_POLESITE			(0x00000004L)
#define REO_GETOBJ_ALL_INTERFACES	(0x00000007L)

// Place object at selection
#define REO_CP_SELECTION ((ULONG) -1L)

// Use character position to specify object instead of index
#define REO_IOB_SELECTION ((ULONG) -1L)
#define REO_IOB_USE_CP ((ULONG) -2L)

// Object flags
#define REO_NULL			(0x00000000L)	// No flags
#define REO_READWRITEMASK	(0x0000003FL)	// Mask out RO bits
#define REO_DONTNEEDPALETTE	(0x00000020L)	// Object doesn't need palette
#define REO_BLANK			(0x00000010L)	// Object is blank
#define REO_DYNAMICSIZE		(0x00000008L)	// Object defines size always
#define REO_INVERTEDSELECT	(0x00000004L)	// Object drawn all inverted if sel
#define REO_BELOWBASELINE	(0x00000002L)	// Object sits below the baseline
#define REO_RESIZABLE		(0x00000001L)	// Object may be resized
#define REO_LINK			(0x80000000L)	// Object is a link (RO)
#define REO_STATIC			(0x40000000L)	// Object is static (RO)
#define REO_SELECTED		(0x08000000L)	// Object selected (RO)
#define REO_OPEN			(0x04000000L)	// Object open in its server (RO)
#define REO_INPLACEACTIVE	(0x02000000L)	// Object in place active (RO)
#define REO_HILITED			(0x01000000L)	// Object is to be hilited (RO)
#define REO_LINKAVAILABLE	(0x00800000L)	// Link believed available (RO)
#define REO_GETMETAFILE		(0x00400000L)	// Object requires metafile (RO)

// flags for IRichEditOle::GetClipboardData(),
// IRichEditOleCallback::GetClipboardData() and
// IRichEditOleCallback::QueryAcceptData()
#define RECO_PASTE			(0x00000000L)	// paste from clipboard
#define RECO_DROP			(0x00000001L)	// drop
#define RECO_COPY			(0x00000002L)	// copy to the clipboard
#define RECO_CUT			(0x00000003L)	// cut to the clipboard
#define RECO_DRAG			(0x00000004L)	// drag

/*
 *	IRichEditOle
 *
 *	Purpose:
 *		Interface used by the client of RichEdit to perform OLE-related
 *		operations.
 *
 *	//$ REVIEW:
 *		The methods herein may just want to be regular Windows messages.
 */
#undef INTERFACE
#define INTERFACE   IRichEditOle

DECLARE_INTERFACE_(IRichEditOle, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * lplpObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IRichEditOle methods ***
    STDMETHOD(GetClientSite) (THIS_ LPOLECLIENTSITE FAR * lplpolesite) PURE;
	STDMETHOD_(LONG,GetObjectCount) (THIS) PURE;
	STDMETHOD_(LONG,GetLinkCount) (THIS) PURE;
	STDMETHOD(GetObject) (THIS_ LONG iob, REOBJECT FAR * lpreobject,
						  DWORD dwFlags) PURE;
    STDMETHOD(InsertObject) (THIS_ REOBJECT FAR * lpreobject) PURE;
	STDMETHOD(ConvertObject) (THIS_ LONG iob, REFCLSID rclsidNew,
							  LPCSTR lpstrUserTypeNew) PURE;
	STDMETHOD(ActivateAs) (THIS_ REFCLSID rclsid, REFCLSID rclsidAs) PURE;
	STDMETHOD(SetHostNames) (THIS_ LPCSTR lpstrContainerApp,
							 LPCSTR lpstrContainerObj) PURE;
	STDMETHOD(SetLinkAvailable) (THIS_ LONG iob, BOOL fAvailable) PURE;
	STDMETHOD(SetDvaspect) (THIS_ LONG iob, DWORD dvaspect) PURE;
	STDMETHOD(HandsOffStorage) (THIS_ LONG iob) PURE;
	STDMETHOD(SaveCompleted) (THIS_ LONG iob, LPSTORAGE lpstg) PURE;
	STDMETHOD(InPlaceDeactivate) (THIS) PURE;
	STDMETHOD(ContextSensitiveHelp) (THIS_ BOOL fEnterMode) PURE;
	STDMETHOD(GetClipboardData) (THIS_ CHARRANGE FAR * lpchrg, DWORD reco,
									LPDATAOBJECT FAR * lplpdataobj) PURE;
	STDMETHOD(ImportDataObject) (THIS_ LPDATAOBJECT lpdataobj,
									CLIPFORMAT cf, HGLOBAL hMetaPict) PURE;
};
typedef         IRichEditOle FAR * LPRICHEDITOLE;

/*
 *	IRichEditOleCallback
 *
 *	Purpose:
 *		Interface used by the RichEdit to get OLE-related stuff from the
 *		application using RichEdit.
 */
#undef INTERFACE
#define INTERFACE   IRichEditOleCallback

DECLARE_INTERFACE_(IRichEditOleCallback, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * lplpObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IRichEditOleCallback methods ***
	STDMETHOD(GetNewStorage) (THIS_ LPSTORAGE FAR * lplpstg) PURE;
    STDMETHOD(GetInPlaceContext) (THIS_ LPOLEINPLACEFRAME FAR * lplpFrame,
								  LPOLEINPLACEUIWINDOW FAR * lplpDoc,
								  LPOLEINPLACEFRAMEINFO lpFrameInfo) PURE;
	STDMETHOD(ShowContainerUI) (THIS_ BOOL fShow) PURE;
	STDMETHOD(QueryInsertObject) (THIS_ LPCLSID lpclsid, LPSTORAGE lpstg,
									LONG cp) PURE;
	STDMETHOD(DeleteObject) (THIS_ LPOLEOBJECT lpoleobj) PURE;
	STDMETHOD(QueryAcceptData) (THIS_ LPDATAOBJECT lpdataobj,
								CLIPFORMAT FAR * lpcfFormat, DWORD reco,
								BOOL fReally, HGLOBAL hMetaPict) PURE;
	STDMETHOD(ContextSensitiveHelp) (THIS_ BOOL fEnterMode) PURE;
	STDMETHOD(GetClipboardData) (THIS_ CHARRANGE FAR * lpchrg, DWORD reco,
									LPDATAOBJECT FAR * lplpdataobj) PURE;
	STDMETHOD(GetDragDropEffect) (THIS_ BOOL fDrag, DWORD grfKeyState,
									LPDWORD pdwEffect) PURE;
	STDMETHOD(GetContextMenu) (THIS_ WORD seltype, LPOLEOBJECT lpoleobj,
									CHARRANGE FAR * lpchrg,
									HMENU FAR * lphmenu) PURE;
};
typedef         IRichEditOleCallback FAR * LPRICHEDITOLECALLBACK;

#ifndef MAC
// RichEdit interface GUIDs
DEFINE_GUID(IID_IRichEditOle,         0x00020D00, 0, 0, 0xC0,0,0,0,0,0,0,0x46);
DEFINE_GUID(IID_IRichEditOleCallback, 0x00020D03, 0, 0, 0xC0,0,0,0,0,0,0,0x46);
#endif // !MAC

#endif // _RICHOLE_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\prnasnot.h ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    prnasnot.h

Abstract:

    Header file for Print APIs

Revision History:

--*/
#ifndef _PRINTASYNCNOTIFY_H_
#define _PRINTASYNCNOTIFY_H_

#if (NTDDI_VERSION >= NTDDI_VISTA)

#include "initguid.h"
#include <objbase.h>

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif

DEFINE_GUID(IID_IPrintAsyncNotifyChannel,        0x4a5031b1, 0x1f3f, 0x4db0, 0xa4, 0x62, 0x45, 0x30, 0xed, 0x8b, 0x04, 0x51);
DEFINE_GUID(IID_IPrintAsyncNotifyCallback,       0x7def34c1, 0x9d92, 0x4c99, 0xb3, 0xb3, 0xdb, 0x94, 0xa9, 0xd4, 0x19, 0x1b);
DEFINE_GUID(IID_IPrintAsyncNotifyDataObject,     0x77cf513e, 0x5d49, 0x4789, 0x9f, 0x30, 0xd0, 0x82, 0x2b, 0x33, 0x5c, 0x0d);

DEFINE_GUID(NOTIFICATION_RELEASE,                0xba9a5027, 0xa70e, 0x4ae7, 0x9b, 0x7d, 0xeb, 0x3e, 0x06, 0xad, 0x41, 0x57);

//
// Global Application Bidi Notification Channel
//   All Apps interested in Bidi Notifications from the Print subsystem should register for
//   notifications on this Channel GUID
//
// {2ABAD223-B994-4aca-82FC-4571B1B585AC}
DEFINE_GUID(PRINT_APP_BIDI_NOTIFY_CHANNEL, 0x2ABAD223, 0xB994, 0x4aca, 0x82, 0xFC, 0x45, 0x71, 0xB1, 0xB5, 0x85, 0xAC);

//
// Global Port Monitor Bidi Notification Channel
//   This is the Global Channel GUID that all Bidi enabled Port Monitor should open to send
//   Bidi Schema notifications up
//
// {25DF3B0E-74A9-47f5-80CE-79B4B1EB5C58}
DEFINE_GUID(PRINT_PORT_MONITOR_NOTIFY_CHANNEL, 0x25df3b0e, 0x74a9, 0x47f5, 0x80, 0xce, 0x79, 0xb4, 0xb1, 0xeb, 0x5c, 0x58);

#ifdef __cplusplus
extern "C" {
#endif

typedef enum
{
    kPerUser,
    kAllUsers,

} PrintAsyncNotifyUserFilter;

typedef enum
{
    kBiDirectional,
    kUniDirectional

} PrintAsyncNotifyConversationStyle;

typedef GUID PrintAsyncNotificationType;

//#undef IUnknown

#undef  INTERFACE
#define INTERFACE IPrintAsyncNotifyDataObject
DECLARE_INTERFACE_(IPrintAsyncNotifyDataObject, IUnknown)
{
    STDMETHOD(QueryInterface)(
        THIS_
        REFIID riid,
        void** ppvObj
        ) PURE;

    STDMETHOD_(ULONG, AddRef)(
        THIS
        ) PURE;

    STDMETHOD_(ULONG, Release)(
        THIS
        ) PURE;

    STDMETHOD(AcquireData)(
         THIS_
         OUT BYTE**,
         OUT ULONG*,
         OUT PrintAsyncNotificationType**
         ) PURE;

    STDMETHOD(ReleaseData)(
        THIS
        ) PURE;
};

typedef interface IPrintAsyncNotifyCallback IPrintAsyncNotifyCallback;

#undef  INTERFACE
#define INTERFACE IPrintAsyncNotifyChannel
DECLARE_INTERFACE_(IPrintAsyncNotifyChannel, IUnknown)
{
    STDMETHOD(QueryInterface)(
        THIS_
        REFIID riid,
        void** ppvObj
        ) PURE;

    STDMETHOD_(ULONG, AddRef)(
        THIS
        ) PURE;

    STDMETHOD_(ULONG, Release)(
        THIS
        ) PURE;

    STDMETHOD(SendNotification)(
         THIS_
         IN IPrintAsyncNotifyDataObject*
         ) PURE;

    STDMETHOD(CloseChannel)(
         THIS_
         IN IPrintAsyncNotifyDataObject*
         ) PURE;
};


#undef  INTERFACE
#define INTERFACE IPrintAsyncNotifyCallback
DECLARE_INTERFACE_(IPrintAsyncNotifyCallback, IUnknown)
{
    STDMETHOD(QueryInterface)(
        THIS_
        REFIID riid,
        void** ppvObj
        ) PURE;

    STDMETHOD_(ULONG, AddRef)(
        THIS
        ) PURE;

    STDMETHOD_(ULONG, Release)(
        THIS
        ) PURE;

    STDMETHOD(OnEventNotify)(
         THIS_
         IN IPrintAsyncNotifyChannel*,
         IN IPrintAsyncNotifyDataObject*
         ) PURE;

    STDMETHOD(ChannelClosed)(
         THIS_
         IN IPrintAsyncNotifyChannel*,
         IN IPrintAsyncNotifyDataObject*
         ) PURE;
};

#undef INTERFACE

HRESULT
WINAPI
RegisterForPrintAsyncNotifications(
    __in_opt    PCWSTR                              pszName,
    __in        PrintAsyncNotificationType*         pNotificationType,
                PrintAsyncNotifyUserFilter          eUserFilter,
                PrintAsyncNotifyConversationStyle   eConversationStyle,
    __in        IPrintAsyncNotifyCallback*          pCallback,
    __out       HANDLE*                             phNotify
    );

HRESULT
WINAPI
UnRegisterForPrintAsyncNotifications(
    __in        HANDLE
    );

HRESULT
WINAPI
CreatePrintAsyncNotifyChannel(
    __in_opt    PCWSTR                              pszName,
    __in        PrintAsyncNotificationType*         pNotificationType,
                PrintAsyncNotifyUserFilter          eUserFilter,
                PrintAsyncNotifyConversationStyle   eConversationStyle,
    __in_opt    IPrintAsyncNotifyCallback*          pCallback,
    __out       IPrintAsyncNotifyChannel**          ppIAsynchNotification
    );

typedef enum
{
    CHANNEL_CLOSED_BY_SERVER                    = 0x01,
    CHANNEL_CLOSED_BY_ANOTHER_LISTENER          = 0x02,
    CHANNEL_CLOSED_BY_SAME_LISTENER             = 0x03,
    CHANNEL_RELEASED_BY_LISTENER                = 0x04,
    UNIRECTIONAL_NOTIFICATION_LOST              = 0x05,
    ASYNC_NOTIFICATION_FAILURE                  = 0x06,
    NO_LISTENERS                                = 0x07,
    CHANNEL_ALREADY_CLOSED                      = 0x08,
    CHANNEL_ALREADY_OPENED                      = 0x09,
    CHANNEL_WAITING_FOR_CLIENT_NOTIFICATION     = 0x0a,
    CHANNEL_NOT_OPENED                          = 0x0b,
    ASYNC_CALL_ALREADY_PARKED                   = 0x0c,
    NOT_REGISTERED                              = 0x0d,
    ALREADY_UNREGISTERED                        = 0x0e,
    ALREADY_REGISTERED                          = 0x0f,
    CHANNEL_ACQUIRED                            = 0x10,
    ASYNC_CALL_IN_PROGRESS                      = 0x11,
    MAX_NOTIFICATION_SIZE_EXCEEDED              = 0x12,
    INTERNAL_NOTIFICATION_QUEUE_IS_FULL         = 0x13,
    INVALID_NOTIFICATION_TYPE                   = 0x14,
    MAX_REGISTRATION_COUNT_EXCEEDED             = 0x15,
    MAX_CHANNEL_COUNT_EXCEEDED                  = 0x16,
    LOCAL_ONLY_REGISTRATION                     = 0x17,
    REMOTE_ONLY_REGISTRATION                    = 0x18,

} PrintAsyncNotifyError;

#ifdef __cplusplus
}
#endif

#endif // (NTDDI_VERSION >= NTDDI_VISTA)

#endif //  _PRINTASYNCNOTIFY_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\prefix.h ===
#if !defined(NTDDI_VERSION)

#error NTDDI_VERSION must be defined to include this file.

#elif (NTDDI_VERSION >= NTDDI_VISTA)

/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    prefix.h

Abstract:

    This module defines the data structures that enable the RDBSS to use the prefix package
    to catalog its server and netroot names. For the moment, file/directory names use the same stuff.

Author:
Revision History:

--*/

#ifndef _RXPREFIX_
#define _RXPREFIX_

// this stuff is implemented in prefix.c

/*
   The current implementation uses a table that has as components:

     1) a prefix table
     2) a queue
     3) a version
     4) a lock

   You use the lock in the normal way: shared to lookup; eclusive to change. the version changes
   eith each change. The reason that we have the queue is that the prefix table package allows
   caller to be enumerating at a time..... the Q/version approach allows multiple guys at a time.
   The Q could be used as a faster lookup for filenames but the prefix table is definitely the
   right thing for netroots.

*/

typedef struct _RX_CONNECTION_ID {
    union {
        ULONG SessionID;
        LUID  Luid;
    };
} RX_CONNECTION_ID, *PRX_CONNECTION_ID;

ULONG
RxTableComputeHashValue (
    IN  PUNICODE_STRING Name
    );

PVOID
RxPrefixTableLookupName (
    IN PRX_PREFIX_TABLE ThisTable,
    IN PUNICODE_STRING CanonicalName,
    OUT PUNICODE_STRING RemainingName,
    IN PRX_CONNECTION_ID ConnectionId
    );

PRX_PREFIX_ENTRY
RxPrefixTableInsertName (
    IN OUT PRX_PREFIX_TABLE ThisTable,
    IN OUT PRX_PREFIX_ENTRY ThisEntry,
    IN PVOID Container,
    IN PULONG ContainerRefCount,
    IN USHORT CaseInsensitiveLength,
    IN PRX_CONNECTION_ID ConnectionId
    );

VOID
RxRemovePrefixTableEntry (
    IN OUT PRX_PREFIX_TABLE ThisTable,
    IN OUT PRX_PREFIX_ENTRY Entry
    );

VOID
RxDereferenceEntryContainer (
    IN OUT PRX_PREFIX_ENTRY Entry,
    IN  PRX_PREFIX_TABLE PrefixTable
    );

BOOLEAN
RxIsNameTableEmpty (
    IN PRX_PREFIX_TABLE ThisTable
    );

VOID
RxInitializePrefixTable (
    IN OUT PRX_PREFIX_TABLE ThisTable,
    IN ULONG TableSize OPTIONAL, 
    IN BOOLEAN CaseInsensitiveMatch
    );

VOID
RxFinalizePrefixTable (
    IN OUT PRX_PREFIX_TABLE ThisTable
    );

//
//  Rx form of a table entry.
//

typedef struct _RX_PREFIX_ENTRY {

    //
    //  Normal Header for Refcounted Structure
    //

    NODE_TYPE_CODE NodeTypeCode;                 
    NODE_BYTE_SIZE NodeByteSize;

    //
    //  the initial part of the name that is always case insensitive
    //

    USHORT CaseInsensitiveLength;                
    USHORT Spare1;

    ULONG SavedHashValue;
    LIST_ENTRY HashLinks;

    //
    //  queue of the set members
    //

    LIST_ENTRY MemberQLinks;                   

    //
    //  Name of the entry
    //

    UNICODE_STRING Prefix;                       

    //
    //  Pointer to the reference count of the container
    //

    PULONG ContainerRefCount;            

    //
    //  don't know the parent type...nor do all callers!
    //  thus, i need this backptr.
    //

    PVOID ContainingRecord;             

    //
    //  some space that alternate table routines can use
    //
                                                 
    PVOID Context;                      

    //
    //  Used for controlled multiplexing
    //

    RX_CONNECTION_ID ConnectionId;               

} RX_PREFIX_ENTRY, *PRX_PREFIX_ENTRY;

//
//  Rx form of name table. wraps in a lock and a queue.  Originally, this implementation used the prefix tables
//  in Rtl which don't allow an empty string entry. so, we special case this.
//

#define RX_PREFIX_TABLE_DEFAULT_LENGTH 32

typedef
PVOID
(*PRX_TABLE_LOOKUPNAME) (
    IN PRX_PREFIX_TABLE ThisTable,
    IN PUNICODE_STRING CanonicalName,
    OUT PUNICODE_STRING RemainingName
    );

typedef
PRX_PREFIX_ENTRY
(*PRX_TABLE_INSERTENTRY) (
    IN OUT PRX_PREFIX_TABLE ThisTable,
    IN OUT PRX_PREFIX_ENTRY ThisEntry
    );

typedef
VOID
(*PRX_TABLE_REMOVEENTRY) (
    IN OUT PRX_PREFIX_TABLE ThisTable,
    IN OUT PRX_PREFIX_ENTRY Entry
    );

typedef struct _RX_PREFIX_TABLE {

    //
    //  Normal Header
    //

    NODE_TYPE_CODE NodeTypeCode;         
    NODE_BYTE_SIZE NodeByteSize;

    //
    //  version stamp changes on each insertion/removal
    //

    ULONG Version;                       

    //
    //  queue of the inserted names
    //

    LIST_ENTRY MemberQueue;              

    //
    //  Resource used to control table access
    //

    ERESOURCE TableLock;                 

    //
    //  PrefixEntry for the Null string
    //

    PRX_PREFIX_ENTRY TableEntryForNull;  

    BOOLEAN CaseInsensitiveMatch;

    //
    //  we may act differently for this....esp for debug!
    //

    BOOLEAN IsNetNameTable;              
    ULONG TableSize;

#if DBG
    ULONG Lookups;
    ULONG FailedLookups;
    ULONG Considers;
    ULONG Compares;
#endif
    
    LIST_ENTRY HashBuckets[RX_PREFIX_TABLE_DEFAULT_LENGTH];

} RX_PREFIX_TABLE, *PRX_PREFIX_TABLE;


#if 0

#define RxAcquirePrefixTableLockShared(PrefixTable,Wait) \
        RxpAcquirePrefixTableLockShared((PrefixTable),(Wait),TRUE, __FILE__,__LINE__ )

#define RxAcquirePrefixTableLockExclusive(PrefixTable,Wait) \
        RxpAcquirePrefixTableLockExclusive((PrefixTable),(Wait),TRUE, __FILE__,__LINE__ )

#define RxReleasePrefixTableLock(PrefixTable)  \
        RxpReleasePrefixTableLock((PrefixTable),TRUE, __FILE__,__LINE__ )
        
extern 
BOOLEAN
RxpAcquirePrefixTableLockShared (
   PRX_PREFIX_TABLE pTable,
   BOOLEAN Wait,
   BOOLEAN ProcessBufferingStateChangeRequests,
   PSZ FileName,
   ULONG LineNumber );

extern 
BOOLEAN
RxpAcquirePrefixTableLockExclusive (
   PRX_PREFIX_TABLE pTable,
   BOOLEAN Wait,
   BOOLEAN ProcessBufferingStateChangeRequests,
   PSZ FileName,
   ULONG LineNumber 
   );

extern 
VOID
RxpReleasePrefixTableLock (
   PRX_PREFIX_TABLE pTable,
   BOOLEAN ProcessBufferingStateChangeRequests,
   PSZ FileName,
   ULONG LineNumber 
   );

#else

#define RxAcquirePrefixTableLockShared(TABLE,WAIT) ExAcquireResourceSharedLite( &(TABLE)->TableLock, (WAIT) )
#define RxAcquirePrefixTableLockExclusive(TABLE,WAIT) ExAcquireResourceExclusiveLite( &(TABLE)->TableLock, (WAIT) )
#define RxReleasePrefixTableLock(TABLE)  ExReleaseResourceLite( &(TABLE)->TableLock )


#endif

extern 
VOID
RxExclusivePrefixTableLockToShared (
    PRX_PREFIX_TABLE Table
    );

#define RxIsPrefixTableLockExclusive(TABLE) ExIsResourceAcquiredExclusiveLite(&(TABLE)->TableLock)
#define RxIsPrefixTableLockAcquired(TABLE) ( ExIsResourceAcquiredSharedLite(&(TABLE)->TableLock) || \
                                              ExIsResourceAcquiredExclusiveLite(&(TABLE)->TableLock) )



#endif   // _RXPREFIX_

#elif (NTDDI_VERSION >= NTDDI_WS03)

/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    prefix.h

Abstract:

    This module defines the data structures that enable the RDBSS to use the prefix package
    to catalog its server and netroot names. For the moment, file/directory names use the same stuff.

Author:
Revision History:

--*/

#ifndef _RXPREFIX_
#define _RXPREFIX_

// this stuff is implemented in prefix.c

/*
   The current implementation uses a table that has as components:

     1) a prefix table
     2) a queue
     3) a version
     4) a lock

   You use the lock in the normal way: shared to lookup; eclusive to change. the version changes
   eith each change. The reason that we have the queue is that the prefix table package allows
   caller to be enumerating at a time..... the Q/version approach allows multiple guys at a time.
   The Q could be used as a faster lookup for filenames but the prefix table is definitely the
   right thing for netroots.

*/

typedef struct _RX_CONNECTION_ID {
    union {
        ULONG SessionID;
        LUID  Luid;
    };
} RX_CONNECTION_ID, *PRX_CONNECTION_ID;

ULONG
RxTableComputeHashValue (
    IN  PUNICODE_STRING Name
    );

PVOID
RxPrefixTableLookupName (
    IN PRX_PREFIX_TABLE ThisTable,
    IN PUNICODE_STRING CanonicalName,
    OUT PUNICODE_STRING RemainingName,
    IN PRX_CONNECTION_ID ConnectionId
    );

PRX_PREFIX_ENTRY
RxPrefixTableInsertName (
    IN OUT PRX_PREFIX_TABLE ThisTable,
    IN OUT PRX_PREFIX_ENTRY ThisEntry,
    IN PVOID Container,
    IN PULONG ContainerRefCount,
    IN USHORT CaseInsensitiveLength,
    IN PRX_CONNECTION_ID ConnectionId
    );

VOID
RxRemovePrefixTableEntry (
    IN OUT PRX_PREFIX_TABLE ThisTable,
    IN OUT PRX_PREFIX_ENTRY Entry
    );

VOID
RxDereferenceEntryContainer (
    IN OUT PRX_PREFIX_ENTRY Entry,
    IN  PRX_PREFIX_TABLE PrefixTable
    );

BOOLEAN
RxIsNameTableEmpty (
    IN PRX_PREFIX_TABLE ThisTable
    );

VOID
RxInitializePrefixTable (
    IN OUT PRX_PREFIX_TABLE ThisTable,
    IN ULONG TableSize OPTIONAL, 
    IN BOOLEAN CaseInsensitiveMatch
    );

VOID
RxFinalizePrefixTable (
    IN OUT PRX_PREFIX_TABLE ThisTable
    );

//
//  Rx form of a table entry.
//

typedef struct _RX_PREFIX_ENTRY {

    //
    //  Normal Header for Refcounted Structure
    //

    NODE_TYPE_CODE NodeTypeCode;                 
    NODE_BYTE_SIZE NodeByteSize;

    //
    //  the initial part of the name that is always case insensitive
    //

    USHORT CaseInsensitiveLength;                
    USHORT Spare1;

    ULONG SavedHashValue;
    LIST_ENTRY HashLinks;

    //
    //  queue of the set members
    //

    LIST_ENTRY MemberQLinks;                   

    //
    //  Name of the entry
    //

    UNICODE_STRING Prefix;                       

    //
    //  Pointer to the reference count of the container
    //

    PULONG ContainerRefCount;            

    //
    //  don't know the parent type...nor do all callers!
    //  thus, i need this backptr.
    //

    PVOID ContainingRecord;             

    //
    //  some space that alternate table routines can use
    //
                                                 
    PVOID Context;                      

    //
    //  Used for controlled multiplexing
    //

    RX_CONNECTION_ID ConnectionId;               

} RX_PREFIX_ENTRY, *PRX_PREFIX_ENTRY;

//
//  Rx form of name table. wraps in a lock and a queue.  Originally, this implementation used the prefix tables
//  in Rtl which don't allow an empty string entry. so, we special case this.
//

#define RX_PREFIX_TABLE_DEFAULT_LENGTH 32

typedef
PVOID
(*PRX_TABLE_LOOKUPNAME) (
    IN PRX_PREFIX_TABLE ThisTable,
    IN PUNICODE_STRING CanonicalName,
    OUT PUNICODE_STRING RemainingName
    );

typedef
PRX_PREFIX_ENTRY
(*PRX_TABLE_INSERTENTRY) (
    IN OUT PRX_PREFIX_TABLE ThisTable,
    IN OUT PRX_PREFIX_ENTRY ThisEntry
    );

typedef
VOID
(*PRX_TABLE_REMOVEENTRY) (
    IN OUT PRX_PREFIX_TABLE ThisTable,
    IN OUT PRX_PREFIX_ENTRY Entry
    );

typedef struct _RX_PREFIX_TABLE {

    //
    //  Normal Header
    //

    NODE_TYPE_CODE NodeTypeCode;         
    NODE_BYTE_SIZE NodeByteSize;

    //
    //  version stamp changes on each insertion/removal
    //

    ULONG Version;                       

    //
    //  queue of the inserted names
    //

    LIST_ENTRY MemberQueue;              

    //
    //  Resource used to control table access
    //

    ERESOURCE TableLock;                 

    //
    //  PrefixEntry for the Null string
    //

    PRX_PREFIX_ENTRY TableEntryForNull;  

    BOOLEAN CaseInsensitiveMatch;

    //
    //  we may act differently for this....esp for debug!
    //

    BOOLEAN IsNetNameTable;              
    ULONG TableSize;

#if DBG
    ULONG Lookups;
    ULONG FailedLookups;
    ULONG Considers;
    ULONG Compares;
#endif
    
    LIST_ENTRY HashBuckets[RX_PREFIX_TABLE_DEFAULT_LENGTH];

} RX_PREFIX_TABLE, *PRX_PREFIX_TABLE;


#if 0

#define RxAcquirePrefixTableLockShared(PrefixTable,Wait) \
        RxpAcquirePrefixTableLockShared((PrefixTable),(Wait),TRUE, __FILE__,__LINE__ )

#define RxAcquirePrefixTableLockExclusive(PrefixTable,Wait) \
        RxpAcquirePrefixTableLockExclusive((PrefixTable),(Wait),TRUE, __FILE__,__LINE__ )

#define RxReleasePrefixTableLock(PrefixTable)  \
        RxpReleasePrefixTableLock((PrefixTable),TRUE, __FILE__,__LINE__ )
        
extern 
BOOLEAN
RxpAcquirePrefixTableLockShared (
   PRX_PREFIX_TABLE pTable,
   BOOLEAN Wait,
   BOOLEAN ProcessBufferingStateChangeRequests,
   PSZ FileName,
   ULONG LineNumber );

extern 
BOOLEAN
RxpAcquirePrefixTableLockExclusive (
   PRX_PREFIX_TABLE pTable,
   BOOLEAN Wait,
   BOOLEAN ProcessBufferingStateChangeRequests,
   PSZ FileName,
   ULONG LineNumber 
   );

extern 
VOID
RxpReleasePrefixTableLock (
   PRX_PREFIX_TABLE pTable,
   BOOLEAN ProcessBufferingStateChangeRequests,
   PSZ FileName,
   ULONG LineNumber 
   );

#else

#define RxAcquirePrefixTableLockShared(TABLE,WAIT) ExAcquireResourceSharedLite( &(TABLE)->TableLock, (WAIT) )
#define RxAcquirePrefixTableLockExclusive(TABLE,WAIT) ExAcquireResourceExclusiveLite( &(TABLE)->TableLock, (WAIT) )
#define RxReleasePrefixTableLock(TABLE)  ExReleaseResourceLite( &(TABLE)->TableLock )


#endif

extern 
VOID
RxExclusivePrefixTableLockToShared (
    PRX_PREFIX_TABLE Table
    );

#define RxIsPrefixTableLockExclusive(TABLE) ExIsResourceAcquiredExclusiveLite(&(TABLE)->TableLock)
#define RxIsPrefixTableLockAcquired(TABLE) ( ExIsResourceAcquiredSharedLite(&(TABLE)->TableLock) || \
                                              ExIsResourceAcquiredExclusiveLite(&(TABLE)->TableLock) )



#endif   // _RXPREFIX_


#elif (NTDDI_VERSION >= NTDDI_WINXP)

/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    prefix.h

Abstract:

    This module defines the data structures that enable the RDBSS to use the prefix package
    to catalog its server and netroot names. For the moment, file/directory names use the same stuff.

Author:
Revision History:

--*/

#ifndef _RXPREFIX_
#define _RXPREFIX_

// this stuff is implemented in prefix.c

/*
   The current implementation uses a table that has as components:

     1) a prefix table
     2) a queue
     3) a version
     4) a lock

   You use the lock in the normal way: shared to lookup; eclusive to change. the version changes
   eith each change. The reason that we have the queue is that the prefix table package allows
   caller to be enumerating at a time..... the Q/version approach allows multiple guys at a time.
   The Q could be used as a faster lookup for filenames but the prefix table is definitely the
   right thing for netroots.

*/

typedef struct _RX_CONNECTION_ID {
    union {
        ULONG SessionID;
        LUID  Luid;
    };
} RX_CONNECTION_ID, *PRX_CONNECTION_ID;

ULONG
RxTableComputeHashValue (
    IN  PUNICODE_STRING  Name
    );

PVOID
RxPrefixTableLookupName(
    IN  PRX_PREFIX_TABLE ThisTable,
    IN  PUNICODE_STRING  CanonicalName,
    OUT PUNICODE_STRING  RemainingName,
    IN  PRX_CONNECTION_ID ConnectionId
    );

PRX_PREFIX_ENTRY
RxPrefixTableInsertName (
    IN OUT PRX_PREFIX_TABLE ThisTable,
    IN OUT PRX_PREFIX_ENTRY ThisEntry,
    IN     PVOID            Container,
    IN     PULONG           ContainerRefCount,
    IN     USHORT           CaseInsensitiveLength,
    IN     PRX_CONNECTION_ID ConnectionId
    );

VOID
RxRemovePrefixTableEntry(
    IN OUT PRX_PREFIX_TABLE ThisTable,
    IN OUT PRX_PREFIX_ENTRY Entry
    );

VOID
RxDereferenceEntryContainer(
    IN OUT PRX_PREFIX_ENTRY Entry,
    IN  PRX_PREFIX_TABLE PrefixTable
    );

BOOLEAN
RxIsNameTableEmpty(
    IN PRX_PREFIX_TABLE ThisTable);

#if 0
#define RX_PREFIXTABLELOCK_ARGS ,__FILE__,__LINE__
#define RX_PREFIXTABLELOCK_PARAMS ,PSZ FileName,ULONG LineNumber
#else
#define RX_PREFIXTABLELOCK_ARGS
#define RX_PREFIXTABLELOCK_PARAMS
#endif

#define RxAcquirePrefixTableLockShared(pPrefixTable,Wait) \
        RxpAcquirePrefixTableLockShared((pPrefixTable),(Wait),TRUE RX_PREFIXTABLELOCK_ARGS)

#define RxAcquirePrefixTableLockExclusive(pPrefixTable,Wait) \
        RxpAcquirePrefixTableLockExclusive((pPrefixTable),(Wait),TRUE RX_PREFIXTABLELOCK_ARGS)

#define RxReleasePrefixTableLock(pPrefixTable)  \
        RxpReleasePrefixTableLock((pPrefixTable),TRUE RX_PREFIXTABLELOCK_ARGS)

extern BOOLEAN
RxpAcquirePrefixTableLockShared(
   PRX_PREFIX_TABLE pTable,
   BOOLEAN Wait,
   BOOLEAN ProcessBufferingStateChangeRequests RX_PREFIXTABLELOCK_PARAMS);

extern BOOLEAN
RxpAcquirePrefixTableLockExclusive(
   PRX_PREFIX_TABLE pTable,
   BOOLEAN Wait,
   BOOLEAN ProcessBufferingStateChangeRequests RX_PREFIXTABLELOCK_PARAMS);

extern VOID
RxExclusivePrefixTableLockToShared(PRX_PREFIX_TABLE pTable);

extern VOID
RxpReleasePrefixTableLock(
   PRX_PREFIX_TABLE pTable,
   BOOLEAN ProcessBufferingStateChangeRequests RX_PREFIXTABLELOCK_PARAMS);

#define RxIsPrefixTableLockExclusive(PTABLE) ExIsResourceAcquiredExclusiveLite(&(PTABLE)->TableLock)
#define RxIsPrefixTableLockAcquired(PTABLE) ( ExIsResourceAcquiredSharedLite(&(PTABLE)->TableLock) || \
                                              ExIsResourceAcquiredExclusiveLite(&(PTABLE)->TableLock) )

VOID
RxInitializePrefixTable(
    IN OUT PRX_PREFIX_TABLE ThisTable,
    IN     ULONG            TableSize OPTIONAL, //0=>use default
    IN     BOOLEAN          CaseInsensitiveMatch
    );

VOID
RxFinalizePrefixTable(
    IN OUT PRX_PREFIX_TABLE ThisTable
    );

//
// Rx form of a table entry.
typedef struct _RX_PREFIX_ENTRY {

    NODE_TYPE_CODE NodeTypeCode;                 // Normal Header for Refcounted Structure
    NODE_BYTE_SIZE NodeByteSize;

    USHORT CaseInsensitiveLength;                //the initial part of the name that is always case insensitive
    USHORT Spare1;

    //UNICODE_PREFIX_TABLE_ENTRY TableEntry;       // Actual table linkage
    ULONG SavedHashValue;
    LIST_ENTRY HashLinks;

    LIST_ENTRY   MemberQLinks;                   // queue of the set members

    UNICODE_STRING Prefix;                       // Name of the entry

    PULONG         ContainerRefCount;            // Pointer to the reference count of the container
    PVOID          ContainingRecord;             // don't know the parent type...nor do all callers!
                                                 // thus, i need this backptr.
    PVOID          Context;                      // some space that alternate table routines can use

    RX_CONNECTION_ID ConnectionId;               // Used for controlled multiplexing

} RX_PREFIX_ENTRY, *PRX_PREFIX_ENTRY;

//
// Rx form of name table. wraps in a lock and a queue.  Originally, this implementation used the prefix tables
// in Rtl which don't allow an empty string entry. so, we special case this.

#define RX_PREFIX_TABLE_DEFAULT_LENGTH 32

typedef
PVOID
(*PRX_TABLE_LOOKUPNAME) (
    IN  PRX_PREFIX_TABLE ThisTable,
    IN  PUNICODE_STRING  CanonicalName,
    OUT PUNICODE_STRING  RemainingName
    );

typedef
PRX_PREFIX_ENTRY
(*PRX_TABLE_INSERTENTRY) (
    IN OUT PRX_PREFIX_TABLE ThisTable,
    IN OUT PRX_PREFIX_ENTRY ThisEntry
    );

typedef
VOID
(*PRX_TABLE_REMOVEENTRY) (
    IN OUT PRX_PREFIX_TABLE ThisTable,
    IN OUT PRX_PREFIX_ENTRY Entry
    );

typedef struct _RX_PREFIX_TABLE {

    NODE_TYPE_CODE NodeTypeCode;         // Normal Header
    NODE_BYTE_SIZE NodeByteSize;

    ULONG Version;                       // version stamp changes on each insertion/removal

    LIST_ENTRY MemberQueue;              // queue of the inserted names

    ERESOURCE TableLock;                 // Resource used to control table access

    PRX_PREFIX_ENTRY TableEntryForNull;  // PrefixEntry for the Null string

    BOOLEAN CaseInsensitiveMatch;
    BOOLEAN IsNetNameTable;              //we may act differently for this....esp for debug!
    ULONG TableSize;
#if DBG
    ULONG Lookups;
    ULONG FailedLookups;
    ULONG Considers;
    ULONG Compares;
#endif
    LIST_ENTRY HashBuckets[RX_PREFIX_TABLE_DEFAULT_LENGTH];

} RX_PREFIX_TABLE, *PRX_PREFIX_TABLE;


#endif   // _RXPREFIX_


#elif (NTDDI_VERSION >= NTDDI_WIN2K)

/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    prefix.h

Abstract:

    This module defines the data structures that enable the RDBSS to use the prefix package
    to catalog its server and netroot names. For the moment, file/directory names use the same stuff.

Author:
Revision History:

--*/

#ifndef _RXPREFIX_
#define _RXPREFIX_

// this stuff is implemented in prefix.c

/*
   The current implementation uses a table that has as components:

     1) a prefix table
     2) a queue
     3) a version
     4) a lock

   You use the lock in the normal way: shared to lookup; eclusive to change. the version changes
   eith each change. The reason that we have the queue is that the prefix table package allows
   caller to be enumerating at a time..... the Q/version approach allows multiple guys at a time.
   The Q could be used as a faster lookup for filenames but the prefix table is definitely the
   right thing for netroots.

*/

ULONG
RxTableComputeHashValue (
    IN  PUNICODE_STRING  Name
    );

PVOID
RxPrefixTableLookupName(
    IN  PRX_PREFIX_TABLE ThisTable,
    IN  PUNICODE_STRING  CanonicalName,
    OUT PUNICODE_STRING  RemainingName
    );

PRX_PREFIX_ENTRY
RxPrefixTableInsertName (
    IN OUT PRX_PREFIX_TABLE ThisTable,
    IN OUT PRX_PREFIX_ENTRY ThisEntry,
    IN     PVOID            Container,
    IN     PULONG           ContainerRefCount,
    IN     USHORT           CaseInsensitiveLength
    );

VOID
RxRemovePrefixTableEntry(
    IN OUT PRX_PREFIX_TABLE ThisTable,
    IN OUT PRX_PREFIX_ENTRY Entry
    );

VOID
RxDereferenceEntryContainer(
    IN OUT PRX_PREFIX_ENTRY Entry,
    IN  PRX_PREFIX_TABLE PrefixTable
    );

BOOLEAN
RxIsNameTableEmpty(
    IN PRX_PREFIX_TABLE ThisTable);

#if DBG
#define RX_PREFIXTABLELOCK_ARGS ,__FILE__,__LINE__
#define RX_PREFIXTABLELOCK_PARAMS ,PSZ FileName,ULONG LineNumber
#else
#define RX_PREFIXTABLELOCK_ARGS
#define RX_PREFIXTABLELOCK_PARAMS
#endif

#define RxAcquirePrefixTableLockShared(pPrefixTable,Wait) \
        RxpAcquirePrefixTableLockShared((pPrefixTable),(Wait),TRUE RX_PREFIXTABLELOCK_ARGS)

#define RxAcquirePrefixTableLockExclusive(pPrefixTable,Wait) \
        RxpAcquirePrefixTableLockExclusive((pPrefixTable),(Wait),TRUE RX_PREFIXTABLELOCK_ARGS)

#define RxReleasePrefixTableLock(pPrefixTable)  \
        RxpReleasePrefixTableLock((pPrefixTable),TRUE RX_PREFIXTABLELOCK_ARGS)

extern BOOLEAN
RxpAcquirePrefixTableLockShared(
   PRX_PREFIX_TABLE pTable,
   BOOLEAN Wait,
   BOOLEAN ProcessBufferingStateChangeRequests RX_PREFIXTABLELOCK_PARAMS);

extern BOOLEAN
RxpAcquirePrefixTableLockExclusive(
   PRX_PREFIX_TABLE pTable,
   BOOLEAN Wait,
   BOOLEAN ProcessBufferingStateChangeRequests RX_PREFIXTABLELOCK_PARAMS);

extern VOID
RxExclusivePrefixTableLockToShared(PRX_PREFIX_TABLE pTable);

extern VOID
RxpReleasePrefixTableLock(
   PRX_PREFIX_TABLE pTable,
   BOOLEAN ProcessBufferingStateChangeRequests RX_PREFIXTABLELOCK_PARAMS);

#define RxIsPrefixTableLockExclusive(PTABLE) ExIsResourceAcquiredExclusive(&(PTABLE)->TableLock)
#define RxIsPrefixTableLockAcquired(PTABLE) ( ExIsResourceAcquiredShared(&(PTABLE)->TableLock) || \
                                              ExIsResourceAcquiredExclusive(&(PTABLE)->TableLock) )

VOID
RxInitializePrefixTable(
    IN OUT PRX_PREFIX_TABLE ThisTable,
    IN     ULONG            TableSize OPTIONAL, //0=>use default
    IN     BOOLEAN          CaseInsensitiveMatch
    );

VOID
RxFinalizePrefixTable(
    IN OUT PRX_PREFIX_TABLE ThisTable
    );

//
// Rx form of a table entry.
typedef struct _RX_PREFIX_ENTRY {

    NODE_TYPE_CODE NodeTypeCode;                 // Normal Header for Refcounted Structure
    NODE_BYTE_SIZE NodeByteSize;

    USHORT CaseInsensitiveLength;                //the initial part of the name that is always case insensitive
    USHORT Spare1;

    //UNICODE_PREFIX_TABLE_ENTRY TableEntry;       // Actual table linkage
    ULONG SavedHashValue;
    LIST_ENTRY HashLinks;

    LIST_ENTRY   MemberQLinks;                   // queue of the set members

    UNICODE_STRING Prefix;                       // Name of the entry

    PULONG         ContainerRefCount;            // Pointer to the reference count of the container
    PVOID          ContainingRecord;             // don't know the parent type...nor do all callers!
                                                 // thus, i need this backptr.
    PVOID          Context;                      // some space that alternate table routines can use

} RX_PREFIX_ENTRY, *PRX_PREFIX_ENTRY;

//
// Rx form of name table. wraps in a lock and a queue.  Originally, this implementation used the prefix tables
// in Rtl which don't allow an empty string entry. so, we special case this.

#define RX_PREFIX_TABLE_DEFAULT_LENGTH 32

typedef
PVOID
(*PRX_TABLE_LOOKUPNAME) (
    IN  PRX_PREFIX_TABLE ThisTable,
    IN  PUNICODE_STRING  CanonicalName,
    OUT PUNICODE_STRING  RemainingName
    );

typedef
PRX_PREFIX_ENTRY
(*PRX_TABLE_INSERTENTRY) (
    IN OUT PRX_PREFIX_TABLE ThisTable,
    IN OUT PRX_PREFIX_ENTRY ThisEntry
    );

typedef
VOID
(*PRX_TABLE_REMOVEENTRY) (
    IN OUT PRX_PREFIX_TABLE ThisTable,
    IN OUT PRX_PREFIX_ENTRY Entry
    );

typedef struct _RX_PREFIX_TABLE {

    NODE_TYPE_CODE NodeTypeCode;         // Normal Header
    NODE_BYTE_SIZE NodeByteSize;

    ULONG Version;                       // version stamp changes on each insertion/removal

    LIST_ENTRY MemberQueue;              // queue of the inserted names

    ERESOURCE TableLock;                 // Resource used to control table access

    PRX_PREFIX_ENTRY TableEntryForNull;  // PrefixEntry for the Null string

    BOOLEAN CaseInsensitiveMatch;
    BOOLEAN IsNetNameTable;              //we may act differently for this....esp for debug!
    ULONG TableSize;
#if DBG
    ULONG Lookups;
    ULONG FailedLookups;
    ULONG Considers;
    ULONG Compares;
#endif
    LIST_ENTRY HashBuckets[RX_PREFIX_TABLE_DEFAULT_LENGTH];

} RX_PREFIX_TABLE, *PRX_PREFIX_TABLE;


#endif   // _RXPREFIX_


#else /* NTDDI_VERSION */

#error This file cannot be included for this NTDDI_VERSION.

#endif /* NTDDI_VERSION */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\rdbss.h ===
#if !defined(NTDDI_VERSION)

#error NTDDI_VERSION must be defined to include this file.

#elif (NTDDI_VERSION >= NTDDI_VISTA)

#error This file cannot be included for this NTDDI_VERSION.

#elif (NTDDI_VERSION >= NTDDI_WS03)

/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    rdbss.h

Abstract:

    This module defines the RDBSS specific data structures

Author:
Revision History:

Notes:

    All the data structures that are exposed to the mini redirector writers need to be
    consolidated in this module.

--*/

#ifndef _RDBSS_H_
#define _RDBSS_H_

//
//  In the previous redirector implementation the file system statistics and the network
//  protocol statistics were combined into one data structure ( and correctly so ) since
//  the old redirector supported only one protocol. However this does not apply to the
//  new redirector (RDR2) since there are more than one mini redirectors and the two
//  need to be distingushed. The RDBSS_STATISTICS structure provides the file system
//  level statistics while the protocol level statistics definition is under the control of
//  the mini redirector implementers.
//
//  The staistics can be obtained by issuing the FSCTL_RDBSS_GET_STATISTICS. If no mini
//  redirector name is provided the RDBSS_STATISTICS are returned and if a mini
//  redirctor name is provided the statistics of the appropriate mini redirector are
//  returned ( the call is passed through to the appropriate mini redirector ).
//

typedef struct _RDBSS_STATISTICS {
   
    LARGE_INTEGER StatisticsStartTime;

    LARGE_INTEGER PagingReadBytesRequested;
    LARGE_INTEGER NonPagingReadBytesRequested;
    LARGE_INTEGER CacheReadBytesRequested;
    LARGE_INTEGER NetworkReadBytesRequested;
    
    LARGE_INTEGER PagingWriteBytesRequested;
    LARGE_INTEGER NonPagingWriteBytesRequested;
    LARGE_INTEGER CacheWriteBytesRequested;
    LARGE_INTEGER NetworkWriteBytesRequested;
    
    ULONG InitiallyFailedOperations;
    ULONG FailedCompletionOperations;
    
    ULONG ReadOperations;
    ULONG RandomReadOperations;
    ULONG WriteOperations;
    ULONG RandomWriteOperations;
    
    ULONG NumberOfSrvCalls;
    ULONG NumberOfSrvOpens;
    ULONG NumberOfNetRoots;
    ULONG NumberOfVirtualNetRoots;
} RDBSS_STATISTICS, *PRDBSS_STATISTICS;

//
//  This call is provided for the benefit of mini redirector implementers. Each mini
//  redirector writer is free to choose the appropriate division of labour between
//  the RDBSS and the corresponding mini redirector in maintaining the statistics.
//

NTSTATUS
RdbssGetStatistics (
    PRDBSS_STATISTICS RdbssStatistics
    );

#endif // _RDBSS_H_






#elif (NTDDI_VERSION >= NTDDI_WINXP)

/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    rdbss.h

Abstract:

    This module defines the RDBSS specific data structures

Author:
Revision History:

Notes:

    All the data structures that are exposed to the mini redirector writers need to be
    consolidated in this module.

--*/

#ifndef _RDBSS_H_
#define _RDBSS_H_

//
// In the previous redirector implementation the file system statistics and the network
// protocol statistics were combined into one data structure ( and correctly so ) since
// the old redirector supported only one protocol. However this does not apply to the
// new redirector (RDR2) since there are more than one mini redirectors and the two
// need to be distingushed. The RDBSS_STATISTICS structure provides the file system
// level statistics while the protocol level statistics definition is under the control of
// the mini redirector implementers.
//
// The staistics can be obtained by issuing the FSCTL_RDBSS_GET_STATISTICS. If no mini
// redirector name is provided the RDBSS_STATISTICS are returned and if a mini
// redirctor name is provided the statistics of the appropriate mini redirector are
// returned ( the call is passed through to the appropriate mini redirector ).
//

typedef struct _RDBSS_STATISTICS {
   LARGE_INTEGER   StatisticsStartTime;

   LARGE_INTEGER   PagingReadBytesRequested;
   LARGE_INTEGER   NonPagingReadBytesRequested;
   LARGE_INTEGER   CacheReadBytesRequested;
   LARGE_INTEGER   NetworkReadBytesRequested;

   LARGE_INTEGER   PagingWriteBytesRequested;
   LARGE_INTEGER   NonPagingWriteBytesRequested;
   LARGE_INTEGER   CacheWriteBytesRequested;
   LARGE_INTEGER   NetworkWriteBytesRequested;

   ULONG           InitiallyFailedOperations;
   ULONG           FailedCompletionOperations;

   ULONG           ReadOperations;
   ULONG           RandomReadOperations;
   ULONG           WriteOperations;
   ULONG           RandomWriteOperations;

   ULONG           NumberOfSrvCalls;
   ULONG           NumberOfSrvOpens;
   ULONG           NumberOfNetRoots;
   ULONG           NumberOfVirtualNetRoots;
} RDBSS_STATISTICS, *PRDBSS_STATISTICS;

// This call is provided for the benefit of mini redirector implementers. Each mini
// redirector writer is free to choose the appropriate division of labour between
// the RDBSS and the corresponding mini redirector in maintaining the statistics.

extern NTSTATUS
RdbssGetStatistics(PRDBSS_STATISTICS pRdbssStatistics);

#endif // _RDBSS_H_






#elif (NTDDI_VERSION >= NTDDI_WIN2K)

/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    rdbss.h

Abstract:

    This module defines the RDBSS specific data structures

Author:
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\ptpusd.h ===
/****************************************************************************
*
*  (C) COPYRIGHT 2000, MICROSOFT CORP.
*
*  FILE:        ptpusd.h
*
*  VERSION:     1.0
*
*  DATE:        12/12/2000
*
*  AUTHOR:      Dave Parsons
*
*  DESCRIPTION:
*    Structures and constants needed to issue vendor-specific Picture
*    Transfer Protocol (PIMA 15740 - digital still camera command
*    protocol) commands through the WIA PTP driver.
*
*****************************************************************************/

#if (NTDDI_VERSION >= NTDDI_WINXP)

//
// Pass this value in the dwEscapeCode argument of IWiaItemExtras::Escape
// to execute a PTP vendor command
//
const DWORD ESCAPE_PTP_CLEAR_STALLS   = 0x0200; 
const DWORD ESCAPE_PTP_VENDOR_COMMAND = 0x0100;
const DWORD ESCAPE_PTP_ADD_OBJ_CMD    = 0x0010;
const DWORD ESCAPE_PTP_REM_OBJ_CMD    = 0x0020;
const DWORD ESCAPE_PTP_ADD_OBJ_RESP   = 0x0040;
const DWORD ESCAPE_PTP_REM_OBJ_RESP   = 0x0080;
const DWORD ESCAPE_PTP_ADDREM_PARM1   = 0x0000;
const DWORD ESCAPE_PTP_ADDREM_PARM2   = 0x0001;
const DWORD ESCAPE_PTP_ADDREM_PARM3   = 0x0002;
const DWORD ESCAPE_PTP_ADDREM_PARM4   = 0x0003;
const DWORD ESCAPE_PTP_ADDREM_PARM5   = 0x0004;

//
// PTP command request
//
const DWORD PTP_MAX_PARAMS = 5;

#pragma pack(push, Old, 1)

typedef struct _PTP_VENDOR_DATA_IN
{
    WORD    OpCode;                 // Opcode
    DWORD   SessionId;              // Session id
    DWORD   TransactionId;          // Transaction id
    DWORD   Params[PTP_MAX_PARAMS]; // Parameters to the command
    DWORD   NumParams;              // Number of parameters passed in
    DWORD   NextPhase;              // Indicates whether to read data,
    BYTE    VendorWriteData[1];     // Optional first byte of data to
                                    // write to the device

} PTP_VENDOR_DATA_IN, *PPTP_VENDOR_DATA_IN;

//
// PTP response block
//
typedef struct _PTP_VENDOR_DATA_OUT
{
    WORD    ResponseCode;           // Response code
    DWORD   SessionId;              // Session id
    DWORD   TransactionId;          // Transaction id
    DWORD   Params[PTP_MAX_PARAMS]; // Parameters of the response
    BYTE    VendorReadData[1];      // Optional first byte of data to
                                    // read from the device

} PTP_VENDOR_DATA_OUT, *PPTP_VENDOR_DATA_OUT;

#pragma pack(pop, Old)

//
// Handy structure size constants
//
const DWORD SIZEOF_REQUIRED_VENDOR_DATA_IN = sizeof(PTP_VENDOR_DATA_IN) - 1;
const DWORD SIZEOF_REQUIRED_VENDOR_DATA_OUT = sizeof(PTP_VENDOR_DATA_OUT) - 1;

//
// NextPhase constants
//
const DWORD PTP_NEXTPHASE_READ_DATA = 3;
const DWORD PTP_NEXTPHASE_WRITE_DATA = 4;
const DWORD PTP_NEXTPHASE_NO_DATA = 5;

#endif // (NTDDI_VERSION >= NTDDI_WINXP)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\portcls.h ===
/*****************************************************************************
 * portcls.h - WDM Streaming port class driver
 *****************************************************************************
 * Copyright (c) Microsoft Corporation. All rights reserved.
 */

#ifndef _PORTCLS_H_
#define _PORTCLS_H_

#ifdef __cplusplus
// WDM.H does not play well with C++.
extern "C"
{
#include <wdm.h>
}
#else
#include <wdm.h>
#endif

#ifndef IRP_MN_FILTER_RESOURCE_REQUIREMENTS
#define IRP_MN_FILTER_RESOURCE_REQUIREMENTS 0x0D
#endif

#include <windef.h>
#define NOBITMAP
#include <mmreg.h>
#undef NOBITMAP
#include <ks.h>
#include <ksmedia.h>
#include <punknown.h>

#if (NTDDI_VERSION >= NTDDI_WINXP)
#include <drmk.h>
#endif

#if defined(PC_NO_IMPORTS)
#define PORTCLASSAPI EXTERN_C
#else
#define PORTCLASSAPI EXTERN_C __declspec(dllimport)
#endif

#define _100NS_UNITS_PER_SECOND 10000000L
#define PORT_CLASS_DEVICE_EXTENSION_SIZE (64*sizeof(ULONG_PTR))

#if (NTDDI_VERSION >= NTDDI_WINXP)
//
//  N.B.: If you are having problems building your driver,
//        #define PC_OLD_NAMES in your sources file.
//        This flag is no longer turned on by default.
//
//#ifndef PC_NEW_NAMES
//#define PC_OLD_NAMES
//#endif
#elif (NTDDI_VERSION >= NTDDI_WIN2K)
#ifndef PC_NEW_NAMES
#define PC_OLD_NAMES
#endif
#endif

#define IID_IAdapterPowerManagment IID_IAdapterPowerManagement
#define PADAPTERPOWERMANAGMENT PADAPTERPOWERMANAGEMENT


/*****************************************************************************
 * Interface identifiers.
 */

DEFINE_GUID(IID_IMiniport,
0xb4c90a24L, 0x5791, 0x11d0, 0x86, 0xf9, 0x00, 0xa0, 0xc9, 0x11, 0xb5, 0x44);
DEFINE_GUID(IID_IPort,
0xb4c90a25L, 0x5791, 0x11d0, 0x86, 0xf9, 0x00, 0xa0, 0xc9, 0x11, 0xb5, 0x44);
DEFINE_GUID(IID_IResourceList,
0x22C6AC60L, 0x851B, 0x11D0, 0x9A, 0x7F, 0x00, 0xAA, 0x00, 0x38, 0xAC, 0xFE);

#if (NTDDI_VERSION >= NTDDI_WINXP)
DEFINE_GUID(IID_IMusicTechnology,
0x80396C3CL, 0xCBCB, 0x409B, 0x9F, 0x65, 0x4F, 0x1E, 0x74, 0x67, 0xCD, 0xAF);
#endif

DEFINE_GUID(IID_IDmaChannel,
0x22C6AC61L, 0x851B, 0x11D0, 0x9A, 0x7F, 0x00, 0xAA, 0x00, 0x38, 0xAC, 0xFE);

//
// Take out IDmaChannelSlave for compilations.
//
#if (NTDDI_VERSION < NTDDI_VISTA)
DEFINE_GUID(IID_IDmaChannelSlave,
0x22C6AC62L, 0x851B, 0x11D0, 0x9A, 0x7F, 0x00, 0xAA, 0x00, 0x38, 0xAC, 0xFE);
#endif

DEFINE_GUID(IID_IInterruptSync,
0x22C6AC63L, 0x851B, 0x11D0, 0x9A, 0x7F, 0x00, 0xAA, 0x00, 0x38, 0xAC, 0xFE);
DEFINE_GUID(IID_IServiceSink,
0x22C6AC64L, 0x851B, 0x11D0, 0x9A, 0x7F, 0x00, 0xAA, 0x00, 0x38, 0xAC, 0xFE);
DEFINE_GUID(IID_IServiceGroup,
0x22C6AC65L, 0x851B, 0x11D0, 0x9A, 0x7F, 0x00, 0xAA, 0x00, 0x38, 0xAC, 0xFE);
DEFINE_GUID(IID_IRegistryKey,
0xE8DA4302l, 0xF304, 0x11D0, 0x95, 0x8B, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3);
DEFINE_GUID(IID_IPortMidi,
0xb4c90a40L, 0x5791, 0x11d0, 0x86, 0xf9, 0x00, 0xa0, 0xc9, 0x11, 0xb5, 0x44);
DEFINE_GUID(IID_IMiniportMidi,
0xb4c90a41L, 0x5791, 0x11d0, 0x86, 0xf9, 0x00, 0xa0, 0xc9, 0x11, 0xb5, 0x44);
DEFINE_GUID(IID_IMiniportMidiStream,
0xb4c90a42L, 0x5791, 0x11d0, 0x86, 0xf9, 0x00, 0xa0, 0xc9, 0x11, 0xb5, 0x44);
DEFINE_GUID(IID_IPortTopology,
0xb4c90a30L, 0x5791, 0x11d0, 0x86, 0xf9, 0x00, 0xa0, 0xc9, 0x11, 0xb5, 0x44);
DEFINE_GUID(IID_IMiniportTopology,
0xb4c90a31L, 0x5791, 0x11d0, 0x86, 0xf9, 0x00, 0xa0, 0xc9, 0x11, 0xb5, 0x44);
DEFINE_GUID(IID_IPortWaveCyclic,
0xb4c90a26L, 0x5791, 0x11d0, 0x86, 0xf9, 0x00, 0xa0, 0xc9, 0x11, 0xb5, 0x44);
DEFINE_GUID(IID_IMiniportWaveCyclic,
0xb4c90a27L, 0x5791, 0x11d0, 0x86, 0xf9, 0x00, 0xa0, 0xc9, 0x11, 0xb5, 0x44);
DEFINE_GUID(IID_IMiniportWaveCyclicStream,
0xb4c90a28L, 0x5791, 0x11d0, 0x86, 0xf9, 0x00, 0xa0, 0xc9, 0x11, 0xb5, 0x44);
DEFINE_GUID(IID_IPortWavePci,
0xb4c90a50L, 0x5791, 0x11d0, 0x86, 0xf9, 0x00, 0xa0, 0xc9, 0x11, 0xb5, 0x44);
DEFINE_GUID(IID_IPortWavePciStream,
0xb4c90a51L, 0x5791, 0x11d0, 0x86, 0xf9, 0x00, 0xa0, 0xc9, 0x11, 0xb5, 0x44);
DEFINE_GUID(IID_IMiniportWavePci,
0xb4c90a52L, 0x5791, 0x11d0, 0x86, 0xf9, 0x00, 0xa0, 0xc9, 0x11, 0xb5, 0x44);
DEFINE_GUID(IID_IMiniportWavePciStream,
0xb4c90a53L, 0x5791, 0x11d0, 0x86, 0xf9, 0x00, 0xa0, 0xc9, 0x11, 0xb5, 0x44);

#if (NTDDI_VERSION >= NTDDI_VISTA)
DEFINE_GUID(IID_IPortWaveRT,
0x339ff909, 0x68a9, 0x4310, 0xb0, 0x9b, 0x27, 0x4e, 0x96, 0xee, 0x4c, 0xbd);
DEFINE_GUID(IID_IPortWaveRTStream,
0x1809ce5a, 0x64bc, 0x4e62, 0xbd, 0x7d, 0x95, 0xbc, 0xe4, 0x3d, 0xe3, 0x93);
DEFINE_GUID(IID_IMiniportWaveRT,
0xf9fc4d6, 0x6061, 0x4f3c, 0xb1, 0xfc, 0x7, 0x5e, 0x35, 0xf7, 0x96, 0xa);
DEFINE_GUID(IID_IMiniportWaveRTStream,
0xac9ab, 0xfaab, 0x4f3d, 0x94, 0x55, 0x6f, 0xf8, 0x30, 0x6a, 0x74, 0xa0);
DEFINE_GUID(IID_IMiniportWaveRTStreamNotification,
0x23759128, 0x96f1, 0x423b, 0xab, 0x4d, 0x81, 0x63, 0x5b, 0xcf, 0x8c, 0xa1);
#endif

DEFINE_GUID(IID_IAdapterPowerManagement,
0x793417D0L, 0x35FE, 0x11D1, 0xAD, 0x08, 0x00, 0xA0, 0xC9, 0x0A, 0xB1, 0xB0);
DEFINE_GUID(IID_IPowerNotify,
0x3DD648B8L, 0x969F, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3);
DEFINE_GUID(IID_IWaveCyclicClock,
0xdec1ec78L, 0x419a, 0x11d1, 0xad, 0x09, 0x00, 0xc0, 0x4f, 0xb9, 0x1b, 0xc4);
DEFINE_GUID(IID_IWavePciClock,
0xd5d7a256L, 0x5d10, 0x11d1, 0xad, 0xae, 0x00, 0xc0, 0x4f, 0xb9, 0x1b, 0xc4);
DEFINE_GUID(IID_IPortEvents,
0xA80F29C4L, 0x5498, 0x11D2, 0x95, 0xD9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3);

#if (NTDDI_VERSION >= NTDDI_WINXP)
DEFINE_GUID(IID_IDrmPort,
0x286D3DF8L, 0xCA22, 0x4E2E, 0xB9, 0xBC, 0x20, 0xB4, 0xF0, 0xE2, 0x01, 0xCE);
DEFINE_GUID(IID_IDrmPort2,
0x1ACCE59CL, 0x7311, 0x4B6B, 0x9F, 0xBA, 0xCC, 0x3B, 0xA5, 0x9A, 0xCD, 0xCE);
DEFINE_GUID(IID_IPortClsVersion,
0x7D89A7BBL, 0x869B, 0x4567, 0x8D, 0xBE, 0x1E, 0x16, 0x8C, 0xC8, 0x53, 0xDE);
DEFINE_GUID(IID_IDmaOperations,
0xe5372d4cL, 0x0ecb, 0x4df8, 0xa5, 0x00, 0xa6, 0x5c, 0x86, 0x78, 0xbb, 0xe4);
DEFINE_GUID(IID_IPinCount,
0x5dadb7dcL, 0xa2cb, 0x4540, 0xa4, 0xa8, 0x42, 0x5e, 0xe4, 0xae, 0x90, 0x51);
DEFINE_GUID(IID_IPreFetchOffset,
0x7000f480L, 0xed44, 0x4e8b, 0xb3, 0x8a, 0x41, 0x2f, 0x8d, 0x7a, 0x50, 0x4d);
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2003)
DEFINE_GUID(IID_IUnregisterSubdevice,
0x16738177L, 0xe199, 0x41f9, 0x9a, 0x87, 0xab, 0xb2, 0xa5, 0x43, 0x2f, 0x21);
DEFINE_GUID(IID_IUnregisterPhysicalConnection,
0x6c38e231L, 0x2a0d, 0x428d, 0x81, 0xf8, 0x07, 0xcc, 0x42, 0x8b, 0xb9, 0xa4);
#endif


/*****************************************************************************
 * Class identifiers.
 */

DEFINE_GUID(CLSID_PortMidi,
0xb4c90a43L, 0x5791, 0x11d0, 0x86, 0xf9, 0x00, 0xa0, 0xc9, 0x11, 0xb5, 0x44);
DEFINE_GUID(CLSID_PortTopology,
0xb4c90a32L, 0x5791, 0x11d0, 0x86, 0xf9, 0x00, 0xa0, 0xc9, 0x11, 0xb5, 0x44);
DEFINE_GUID(CLSID_PortWaveCyclic,
0xb4c90a2aL, 0x5791, 0x11d0, 0x86, 0xf9, 0x00, 0xa0, 0xc9, 0x11, 0xb5, 0x44);
DEFINE_GUID(CLSID_PortWavePci,
0xb4c90a54L, 0x5791, 0x11d0, 0x86, 0xf9, 0x00, 0xa0, 0xc9, 0x11, 0xb5, 0x44);

#if (NTDDI_VERSION >= NTDDI_VISTA)
DEFINE_GUID(CLSID_PortWaveRT,
0xcc9be57a, 0xeb9e, 0x42b4, 0x94, 0xfc, 0xc, 0xad, 0x3d, 0xbc, 0xe7, 0xfa);
#endif

DEFINE_GUID(CLSID_MiniportDriverFmSynth,
0xb4c90ae0L, 0x5791, 0x11d0, 0x86, 0xf9, 0x00, 0xa0, 0xc9, 0x11, 0xb5, 0x44);
DEFINE_GUID(CLSID_MiniportDriverUart,
0xb4c90ae1L, 0x5791, 0x11d0, 0x86, 0xf9, 0x00, 0xa0, 0xc9, 0x11, 0xb5, 0x44);
DEFINE_GUID(CLSID_MiniportDriverFmSynthWithVol,
0xe5a3c139L, 0xf0f2, 0x11d1, 0x81, 0xaf, 0x00, 0x60, 0x08, 0x33, 0x16, 0xc1);


/*****************************************************************************
 * Interfaces
 */

#if !defined(DEFINE_ABSTRACT_UNKNOWN)

#define DEFINE_ABSTRACT_UNKNOWN()                               \
    STDMETHOD_(NTSTATUS, QueryInterface)(THIS_                  \
        REFIID InterfaceId,                                     \
        PVOID* Interface                                        \
        ) PURE;                                                 \
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;                        \
    STDMETHOD_(ULONG,Release)(THIS) PURE;

#endif //!defined(DEFINE_ABSTRACT_UNKNOWN)

#if !defined(DEFINE_ABSTRACT_PORT)

#ifdef PC_OLD_NAMES

#define DEFINE_ABSTRACT_PORT()                                      \
    STDMETHOD_(NTSTATUS,Init)                                       \
    (   THIS_                                                       \
        IN      PVOID           DeviceObject,                       \
        IN      PVOID           Irp,                                \
        IN      PUNKNOWN        UnknownMiniport,                    \
        IN      PUNKNOWN        UnknownAdapter      OPTIONAL,       \
        IN      PRESOURCELIST   ResourceList                        \
    )   PURE;                                                       \
    STDMETHOD_(NTSTATUS,GetDeviceProperty)                          \
    (   THIS_                                                       \
        IN      DEVICE_REGISTRY_PROPERTY    DeviceProperty,         \
        IN      ULONG                       BufferLength,           \
        OUT     PVOID                       PropertyBuffer,         \
        OUT     PULONG                      ResultLength            \
    )   PURE;                                                       \
    STDMETHOD_(NTSTATUS,NewRegistryKey)                             \
    (   THIS_                                                       \
        OUT     PREGISTRYKEY *      OutRegistryKey,                 \
        IN      PUNKNOWN            OuterUnknown        OPTIONAL,   \
        IN      ULONG               RegistryKeyType,                \
        IN      ACCESS_MASK         DesiredAccess,                  \
        IN      POBJECT_ATTRIBUTES  ObjectAttributes    OPTIONAL,   \
        IN      ULONG               CreateOptions       OPTIONAL,   \
        OUT     PULONG              Disposition         OPTIONAL    \
    )   PURE;

#else   //  !PC_OLD_NAMES

#define DEFINE_ABSTRACT_PORT()                                      \
    STDMETHOD_(NTSTATUS,Init)                                       \
    (   THIS_                                                       \
        IN      PDEVICE_OBJECT  DeviceObject,                       \
        IN      PIRP            Irp,                                \
        IN      PUNKNOWN        UnknownMiniport,                    \
        IN      PUNKNOWN        UnknownAdapter      OPTIONAL,       \
        IN      PRESOURCELIST   ResourceList                        \
    )   PURE;                                                       \
    STDMETHOD_(NTSTATUS,GetDeviceProperty)                          \
    (   THIS_                                                       \
        IN      DEVICE_REGISTRY_PROPERTY    DeviceProperty,         \
        IN      ULONG                       BufferLength,           \
        OUT     PVOID                       PropertyBuffer,         \
        OUT     PULONG                      ResultLength            \
    )   PURE;                                                       \
    STDMETHOD_(NTSTATUS,NewRegistryKey)                             \
    (   THIS_                                                       \
        OUT     PREGISTRYKEY *      OutRegistryKey,                 \
        IN      PUNKNOWN            OuterUnknown        OPTIONAL,   \
        IN      ULONG               RegistryKeyType,                \
        IN      ACCESS_MASK         DesiredAccess,                  \
        IN      POBJECT_ATTRIBUTES  ObjectAttributes    OPTIONAL,   \
        IN      ULONG               CreateOptions       OPTIONAL,   \
        OUT     PULONG              Disposition         OPTIONAL    \
    )   PURE;

#endif //   !PC_OLD_NAMES

#endif //!defined(DEFINE_ABSTRACT_PORT)


#if !defined(DEFINE_ABSTRACT_MINIPORT)

#define DEFINE_ABSTRACT_MINIPORT()                              \
    STDMETHOD_(NTSTATUS,GetDescription)                         \
    (   THIS_                                                   \
        OUT     PPCFILTER_DESCRIPTOR *  Description             \
    )   PURE;                                                   \
    STDMETHOD_(NTSTATUS,DataRangeIntersection)                  \
    (   THIS_                                                   \
        IN      ULONG           PinId,                          \
        IN      PKSDATARANGE    DataRange,                      \
        IN      PKSDATARANGE    MatchingDataRange,              \
        IN      ULONG           OutputBufferLength,             \
        OUT     PVOID           ResultantFormat     OPTIONAL,   \
        OUT     PULONG          ResultantFormatLength           \
    )   PURE;

#endif //!defined(DEFINE_ABSTRACT_MINIPORT)

#if !defined(DEFINE_ABSTRACT_DMACHANNEL)

#define DEFINE_ABSTRACT_DMACHANNEL()                            \
    STDMETHOD_(NTSTATUS,AllocateBuffer)                         \
    (   THIS_                                                   \
        IN      ULONG               BufferSize,                 \
        IN      PPHYSICAL_ADDRESS   PhysicalAddressConstraint   OPTIONAL \
    )   PURE;                                                   \
    STDMETHOD_(void,FreeBuffer)                                 \
    (   THIS                                                    \
    )   PURE;                                                   \
    STDMETHOD_(ULONG,TransferCount)                             \
    (   THIS                                                    \
    )   PURE;                                                   \
    STDMETHOD_(ULONG,MaximumBufferSize)                         \
    (   THIS                                                    \
    )   PURE;                                                   \
    STDMETHOD_(ULONG,AllocatedBufferSize)                       \
    (   THIS                                                    \
    )   PURE;                                                   \
    STDMETHOD_(ULONG,BufferSize)                                \
    (   THIS                                                    \
    )   PURE;                                                   \
    STDMETHOD_(void,SetBufferSize)                              \
    (   THIS_                                                   \
        IN      ULONG   BufferSize                              \
    )   PURE;                                                   \
    STDMETHOD_(PVOID,SystemAddress)                             \
    (   THIS                                                    \
    )   PURE;                                                   \
    STDMETHOD_(PHYSICAL_ADDRESS,PhysicalAddress)                \
    (   THIS                                                    \
    )   PURE;                                                   \
    STDMETHOD_(PADAPTER_OBJECT,GetAdapterObject)                \
    (   THIS                                                    \
    )   PURE;                                                   \
    STDMETHOD_(void,CopyTo)                                     \
    (   THIS_                                                   \
        IN      PVOID   Destination,                            \
        IN      PVOID   Source,                                 \
        IN      ULONG   ByteCount                               \
    )   PURE;                                                   \
    STDMETHOD_(void,CopyFrom)                                   \
    (   THIS_                                                   \
        IN      PVOID   Destination,                            \
        IN      PVOID   Source,                                 \
        IN      ULONG   ByteCount                               \
    )   PURE;

#endif //!defined(DEFINE_ABSTRACT_DMACHANNEL)

//
// Take out definitions of IDmaChannelSlave.
//
#if (NTDDI_VERSION < NTDDI_VISTA)
#if !defined(DEFINE_ABSTRACT_DMACHANNELSLAVE)

#define DEFINE_ABSTRACT_DMACHANNELSLAVE()                       \
    STDMETHOD_(NTSTATUS,Start)                                  \
    (   THIS_                                                   \
        IN      ULONG               MapSize,                    \
        IN      BOOLEAN             WriteToDevice               \
    )   PURE;                                                   \
    STDMETHOD_(NTSTATUS,Stop)                                   \
    (   THIS                                                    \
    )   PURE;                                                   \
    STDMETHOD_(ULONG,ReadCounter)                               \
    (   THIS                                                    \
    )   PURE;                                                   \
    STDMETHOD_(NTSTATUS,WaitForTC)                              \
    (   THIS_                                                   \
        ULONG Timeout                                           \
    )   PURE;

#endif //!defined(DEFINE_ABSTRACT_DMACHANNELSLAVE)
#endif

#if !defined(DEFINE_ABSTRACT_DRMPORT)

#define DEFINE_ABSTRACT_DRMPORT()                              \
    STDMETHOD_(NTSTATUS,CreateContentMixed)                    \
    (   THIS_                                                  \
        IN  PULONG      paContentId,                           \
        IN  ULONG       cContentId,                            \
        OUT PULONG      pMixedContentId                        \
    )   PURE;                                                  \
    STDMETHOD_(NTSTATUS,DestroyContent)                        \
    (   THIS_                                                  \
        IN ULONG        ContentId                              \
    )   PURE;                                                  \
    STDMETHOD_(NTSTATUS,ForwardContentToFileObject)            \
    (   THIS_                                                  \
        IN ULONG        ContentId,                             \
        IN PFILE_OBJECT FileObject                             \
    )   PURE;                                                  \
    STDMETHOD_(NTSTATUS,ForwardContentToInterface)             \
    (   THIS_                                                  \
        IN ULONG        ContentId,                             \
        IN PUNKNOWN     pUnknown,                              \
        IN ULONG        NumMethods                             \
    )   PURE;                                                  \
    STDMETHOD_(NTSTATUS,GetContentRights)                      \
    (   THIS_                                                  \
        IN  ULONG       ContentId,                             \
        OUT PDRMRIGHTS  DrmRights                              \
    )   PURE;

#endif //!defined(DEFINE_ABSTRACT_DRMPORT)

#if !defined(DEFINE_ABSTRACT_MINIPORTWAVERTSTREAM)

#define DEFINE_ABSTRACT_MINIPORTWAVERTSTREAM()                 \
    STDMETHOD_(NTSTATUS,SetFormat)                             \
    (   THIS_                                                  \
        IN      PKSDATAFORMAT   DataFormat                     \
    )   PURE;                                                  \
    STDMETHOD_(NTSTATUS,SetState)                              \
    (   THIS_                                                  \
        IN      KSSTATE         State                          \
    )   PURE;                                                  \
    STDMETHOD_(NTSTATUS,GetPosition)                           \
    (   THIS_                                                  \
        OUT     PKSAUDIO_POSITION   Position                   \
    )   PURE;                                                  \
    STDMETHOD_(NTSTATUS,AllocateAudioBuffer)                   \
    (   THIS_                                                  \
        IN  ULONG                   RequestedSize,             \
        OUT PMDL                    *AudioBufferMdl,           \
        OUT ULONG                   *ActualSize,               \
        OUT ULONG                   *OffsetFromFirstPage,      \
        OUT MEMORY_CACHING_TYPE     *CacheType                 \
    ) PURE;                                                    \
    STDMETHOD_(VOID,FreeAudioBuffer)                           \
    (   THIS_                                                  \
        IN  PMDL                    AudioBufferMdl,            \
        IN  ULONG                   BufferSize                 \
    ) PURE;                                                    \
    STDMETHOD_(VOID,GetHWLatency)                              \
    (   THIS_                                                  \
        OUT KSRTAUDIO_HWLATENCY     *hwLatency                 \
    ) PURE;                                                    \
    STDMETHOD_(NTSTATUS,GetPositionRegister)                   \
    (   THIS_                                                  \
        OUT KSRTAUDIO_HWREGISTER    *Register                  \
    ) PURE;                                                    \
    STDMETHOD_(NTSTATUS,GetClockRegister)                      \
    (   THIS_                                                  \
        OUT KSRTAUDIO_HWREGISTER    *Register                  \
    ) PURE;

#endif //!defined(DEFINE_ABSTRACT_MINIPORTWAVERTSTREAM)

/*****************************************************************************
 * IResourceList
 *****************************************************************************
 * List of resources.
 */
DECLARE_INTERFACE_(IResourceList,IUnknown)
{
    DEFINE_ABSTRACT_UNKNOWN()   //  For IUnknown

    STDMETHOD_(ULONG,NumberOfEntries)
    (   THIS
    )   PURE;

    STDMETHOD_(ULONG,NumberOfEntriesOfType)
    (   THIS_
        IN      CM_RESOURCE_TYPE    Type
    )   PURE;

    STDMETHOD_(PCM_PARTIAL_RESOURCE_DESCRIPTOR,FindTranslatedEntry)
    (   THIS_
        IN      CM_RESOURCE_TYPE    Type,
        IN      ULONG               Index
    )   PURE;

    STDMETHOD_(PCM_PARTIAL_RESOURCE_DESCRIPTOR,FindUntranslatedEntry)
    (   THIS_
        IN      CM_RESOURCE_TYPE    Type,
        IN      ULONG               Index
    )   PURE;

    STDMETHOD_(NTSTATUS,AddEntry)
    (   THIS_
        IN      PCM_PARTIAL_RESOURCE_DESCRIPTOR Translated,
        IN      PCM_PARTIAL_RESOURCE_DESCRIPTOR Untranslated
    )   PURE;

    STDMETHOD_(NTSTATUS,AddEntryFromParent)
    (   THIS_
        IN      struct IResourceList *  Parent,
        IN      CM_RESOURCE_TYPE        Type,
        IN      ULONG                   Index
    )   PURE;

    STDMETHOD_(PCM_RESOURCE_LIST,TranslatedList)
    (   THIS
    )   PURE;

    STDMETHOD_(PCM_RESOURCE_LIST,UntranslatedList)
    (   THIS
    )   PURE;
};

typedef IResourceList *PRESOURCELIST;

#ifdef PC_IMPLEMENTATION
#define IMP_IResourceList\
    STDMETHODIMP_(ULONG)NumberOfEntries\
    (   void\
    );\
    STDMETHODIMP_(ULONG) NumberOfEntriesOfType\
    (   IN      CM_RESOURCE_TYPE    Type\
    );\
    STDMETHODIMP_(PCM_PARTIAL_RESOURCE_DESCRIPTOR) FindTranslatedEntry\
    (   IN      CM_RESOURCE_TYPE    Type,\
        IN      ULONG               Index\
    );\
    STDMETHODIMP_(PCM_PARTIAL_RESOURCE_DESCRIPTOR) FindUntranslatedEntry\
    (   IN      CM_RESOURCE_TYPE    Type,\
        IN      ULONG               Index\
    );\
    STDMETHODIMP_(NTSTATUS) AddEntry\
    (   IN      PCM_PARTIAL_RESOURCE_DESCRIPTOR Translated,\
        IN      PCM_PARTIAL_RESOURCE_DESCRIPTOR Untranslated\
    );\
    STDMETHODIMP_(NTSTATUS) AddEntryFromParent\
    (   IN      struct IResourceList *  Parent,\
        IN      CM_RESOURCE_TYPE        Type,\
        IN      ULONG                   Index\
    );\
    STDMETHODIMP_(PCM_RESOURCE_LIST) TranslatedList\
    (   void\
    );\
    STDMETHODIMP_(PCM_RESOURCE_LIST) UntranslatedList\
    (   void\
    )
#endif


#define NumberOfPorts()         NumberOfEntriesOfType(CmResourceTypePort)
#define FindTranslatedPort(n)   FindTranslatedEntry(CmResourceTypePort,(n))
#define FindUntranslatedPort(n) FindUntranslatedEntry(CmResourceTypePort,(n))
#define AddPortFromParent(p,n)  AddEntryFromParent((p),CmResourceTypePort,(n))

#define NumberOfInterrupts()         NumberOfEntriesOfType(CmResourceTypeInterrupt)
#define FindTranslatedInterrupt(n)   FindTranslatedEntry(CmResourceTypeInterrupt,(n))
#define FindUntranslatedInterrupt(n) FindUntranslatedEntry(CmResourceTypeInterrupt,(n))
#define AddInterruptFromParent(p,n)  AddEntryFromParent((p),CmResourceTypeInterrupt,(n))

#define NumberOfMemories()        NumberOfEntriesOfType(CmResourceTypeMemory)
#define FindTranslatedMemory(n)   FindTranslatedEntry(CmResourceTypeMemory,(n))
#define FindUntranslatedMemory(n) FindUntranslatedEntry(CmResourceTypeMemory,(n))
#define AddMemoryFromParent(p,n)  AddEntryFromParent((p),CmResourceTypeMemory,(n))

#define NumberOfDmas()         NumberOfEntriesOfType(CmResourceTypeDma)
#define FindTranslatedDma(n)   FindTranslatedEntry(CmResourceTypeDma,(n))
#define FindUntranslatedDma(n) FindUntranslatedEntry(CmResourceTypeDma,(n))
#define AddDmaFromParent(p,n)  AddEntryFromParent((p),CmResourceTypeDma,(n))

#define NumberOfDeviceSpecifics()         NumberOfEntriesOfType(CmResourceTypeDeviceSpecific)
#define FindTranslatedDeviceSpecific(n)   FindTranslatedEntry(CmResourceTypeDeviceSpecific,(n))
#define FindUntranslatedDeviceSpecific(n) FindUntranslatedEntry(CmResourceTypeDeviceSpecific,(n))
#define AddDeviceSpecificFromParent(p,n)  AddEntryFromParent((p),CmResourceTypeDeviceSpecific,(n))

#define NumberOfBusNumbers()         NumberOfEntriesOfType(CmResourceTypeBusNumber)
#define FindTranslatedBusNumber(n)   FindTranslatedEntry(CmResourceTypeBusNumber,(n))
#define FindUntranslatedBusNumber(n) FindUntranslatedEntry(CmResourceTypeBusNumber,(n))
#define AddBusNumberFromParent(p,n)  AddEntryFromParent((p),CmResourceTypeBusNumber,(n))

#define NumberOfDevicePrivates()         NumberOfEntriesOfType(CmResourceTypeDevicePrivate)
#define FindTranslatedDevicePrivate(n)   FindTranslatedEntry(CmResourceTypeDevicePrivate,(n))
#define FindUntranslatedDevicePrivate(n) FindUntranslatedEntry(CmResourceTypeDevicePrivate,(n))
#define AddDevicePrivateFromParent(p,n)  AddEntryFromParent((p),CmResourceTypeDevicePrivate,(n))

#define NumberOfAssignedResources()         NumberOfEntriesOfType(CmResourceTypeAssignedResource)
#define FindTranslatedAssignedResource(n)   FindTranslatedEntry(CmResourceTypeAssignedResource,(n))
#define FindUntranslatedAssignedResource(n) FindUntranslatedEntry(CmResourceTypeAssignedResource,(n))
#define AddAssignedResourceFromParent(p,n)  AddEntryFromParent((p),CmResourceTypeAssignedResource,(n))

#define NumberOfSubAllocateFroms()         NumberOfEntriesOfType(CmResourceTypeSubAllocateFrom)
#define FindTranslatedSubAllocateFrom(n)   FindTranslatedEntry(CmResourceTypeSubAllocateFrom,(n))
#define FindUntranslatedSubAllocateFrom(n) FindUntranslatedEntry(CmResourceTypeSubAllocateFrom,(n))
#define AddSubAllocateFromFromParent(p,n)  AddEntryFromParent((p),CmResourceTypeSubAllocateFrom,(n))

/*****************************************************************************
 * IDmaChannel
 *****************************************************************************
 * Interface for DMA channel.
 */
DECLARE_INTERFACE_(IDmaChannel,IUnknown)
{
    DEFINE_ABSTRACT_UNKNOWN()       //  For IUnknown

    DEFINE_ABSTRACT_DMACHANNEL()    //  For IDmaChannel
};

typedef IDmaChannel *PDMACHANNEL;

#ifdef PC_IMPLEMENTATION
#define IMP_IDmaChannel\
    STDMETHODIMP_(NTSTATUS) AllocateBuffer\
    (   IN      ULONG               BufferSize,\
        IN      PPHYSICAL_ADDRESS   PhysicalAddressConstraint   OPTIONAL\
    );\
    STDMETHODIMP_(void) FreeBuffer\
    (   void\
    );\
    STDMETHODIMP_(ULONG) TransferCount\
    (   void\
    );\
    STDMETHODIMP_(ULONG) MaximumBufferSize\
    (   void\
    );\
    STDMETHODIMP_(ULONG) AllocatedBufferSize\
    (   void\
    );\
    STDMETHODIMP_(ULONG) BufferSize\
    (   void\
    );\
    STDMETHODIMP_(void) SetBufferSize\
    (   IN      ULONG   BufferSize\
    );\
    STDMETHODIMP_(PVOID) SystemAddress\
    (   void\
    );\
    STDMETHODIMP_(PHYSICAL_ADDRESS) PhysicalAddress\
    (   void\
    );\
    STDMETHODIMP_(PADAPTER_OBJECT) GetAdapterObject\
    (   void\
    );\
    STDMETHODIMP_(void) CopyTo\
    (   IN      PVOID   Destination,\
        IN      PVOID   Source,\
        IN      ULONG   ByteCount\
    );\
    STDMETHODIMP_(void) CopyFrom\
    (   IN      PVOID   Destination,\
        IN      PVOID   Source,\
        IN      ULONG   ByteCount\
    )
#endif

//
// For Longhorn we don't support DMA channel slave functions, but we need
// to define PDMACHANNELSLAVE so that we can compile NewSlaveDmaChannel
// which we need for forward compatibility.
//
#if (NTDDI_VERSION < NTDDI_VISTA)
/*****************************************************************************
 * IDmaChannelSlave
 *****************************************************************************
 * Interface for slave DMA channel.
 */
DECLARE_INTERFACE_(IDmaChannelSlave,IDmaChannel)
{
    DEFINE_ABSTRACT_UNKNOWN()           //  For IUnknown

    DEFINE_ABSTRACT_DMACHANNEL()        //  For IDmaChannel

    DEFINE_ABSTRACT_DMACHANNELSLAVE()   //  For IDmaChannelSlave
};

typedef IDmaChannelSlave *PDMACHANNELSLAVE;

#ifdef PC_IMPLEMENTATION
#define IMP_IDmaChannelSlave\
    IMP_IDmaChannel;\
    STDMETHODIMP_(NTSTATUS) Start\
    (   IN      ULONG               MapSize,\
        IN      BOOLEAN             WriteToDevice\
    );\
    STDMETHODIMP_(NTSTATUS) Stop\
    (   void\
    );\
    STDMETHODIMP_(ULONG) ReadCounter\
    (   void\
    );\
    STDMETHODIMP_(NTSTATUS) WaitForTC\
    (   ULONG Timeout\
    )
#endif
#else   // NTDDI_VERSION < NTDDI_VISTA
//
// This is a dummy definition for PDMACHANNELSLAVE.
//
typedef PVOID PDMACHANNELSLAVE;
#endif  // NTDDI_VERSION < NTDDI_VISTA

/*****************************************************************************
 * INTERRUPTSYNCMODE
 *****************************************************************************
 * Interrupt sync mode of operation.
 */
typedef enum
{
    InterruptSyncModeNormal = 1,    // One pass, stop when successful.
    InterruptSyncModeAll,           // One pass regardless of success.
    InterruptSyncModeRepeat         // Repeat until all return unsuccessful.
} INTERRUPTSYNCMODE;

/*****************************************************************************
 * PINTERRUPTSYNCROUTINE
 *****************************************************************************
 * Pointer to an interrupt synchronization routine.  Both interrupt service
 * routines and routines that are synchronized with ISRs use this type.
 */
typedef NTSTATUS
(*PINTERRUPTSYNCROUTINE)
(
    IN      struct IInterruptSync * InterruptSync,
    IN      PVOID                   DynamicContext
);

/*****************************************************************************
 * IInterruptSync
 *****************************************************************************
 * Interface for objects providing access synchronization with interrupts.
 */
DECLARE_INTERFACE_(IInterruptSync,IUnknown)
{
    DEFINE_ABSTRACT_UNKNOWN()   //  For IUnknown

    STDMETHOD_(NTSTATUS,CallSynchronizedRoutine)
    (   THIS_
        IN      PINTERRUPTSYNCROUTINE   Routine,
        IN      PVOID                   DynamicContext
    )   PURE;
    STDMETHOD_(PKINTERRUPT,GetKInterrupt)
    (   THIS
    )   PURE;
    STDMETHOD_(NTSTATUS,Connect)
    (   THIS
    )   PURE;
    STDMETHOD_(void,Disconnect)
    (   THIS
    )   PURE;
    STDMETHOD_(NTSTATUS,RegisterServiceRoutine)
    (   THIS_
        IN      PINTERRUPTSYNCROUTINE   Routine,
        IN      PVOID                   DynamicContext,
        IN      BOOLEAN                 First
    )   PURE;
};

typedef IInterruptSync *PINTERRUPTSYNC;

#ifdef PC_IMPLEMENTATION
#define IMP_IInterruptSync\
    STDMETHODIMP_(NTSTATUS) CallSynchronizedRoutine\
    (   IN      PINTERRUPTSYNCROUTINE   Routine,\
        IN      PVOID                   DynamicContext\
    );\
    STDMETHODIMP_(PKINTERRUPT) GetKInterrupt\
    (   void\
    );\
    STDMETHODIMP_(NTSTATUS) Connect\
    (   void\
    );\
    STDMETHODIMP_(void) Disconnect\
    (   void\
    );\
    STDMETHODIMP_(NTSTATUS) RegisterServiceRoutine\
    (   IN      PINTERRUPTSYNCROUTINE   Routine,\
        IN      PVOID                   DynamicContext,\
        IN      BOOLEAN                 First\
    )
#endif

/*****************************************************************************
 * IServiceSink
 *****************************************************************************
 * Interface for notification sinks for service groups.
 */
DECLARE_INTERFACE_(IServiceSink,IUnknown)
{
    DEFINE_ABSTRACT_UNKNOWN()   //  For IUnknown

    //  For IServiceSink
    STDMETHOD_(void,RequestService)
    (   THIS
    )   PURE;
};

typedef IServiceSink *PSERVICESINK;

#ifdef PC_IMPLEMENTATION
#define IMP_IServiceSink\
    STDMETHODIMP_(void) RequestService\
    (   void\
    )
#endif

/*****************************************************************************
 * IServiceGroup
 *****************************************************************************
 * Interface for objects representing a group that is serviced collectively.
 */
DECLARE_INTERFACE_(IServiceGroup,IServiceSink)
{
    DEFINE_ABSTRACT_UNKNOWN()   //  For IUnknown

    //  For IServiceSink
    STDMETHOD_(void,RequestService)
    (   THIS
    )   PURE;

    //  For IServiceGroup
    STDMETHOD_(NTSTATUS,AddMember)
    (   THIS_
        IN      PSERVICESINK    pServiceSink
    )   PURE;

    STDMETHOD_(void,RemoveMember)
    (   THIS_
        IN      PSERVICESINK    pServiceSink
    )   PURE;

    STDMETHOD_(void,SupportDelayedService)
    (   THIS
    )   PURE;

    STDMETHOD_(void,RequestDelayedService)
    (   THIS_
        IN      ULONGLONG   ullDelay
    )   PURE;

    STDMETHOD_(void,CancelDelayedService)
    (   THIS
    )   PURE;
};

typedef IServiceGroup *PSERVICEGROUP;

#ifdef PC_IMPLEMENTATION
#define IMP_IServiceGroup\
    IMP_IServiceSink;\
    STDMETHODIMP_(NTSTATUS) AddMember\
    (   IN  PSERVICESINK    pServiceSink\
    );\
    STDMETHODIMP_(void) RemoveMember\
    (   IN  PSERVICESINK    pServiceSink\
    );\
    STDMETHODIMP_(void) SupportDelayedService\
    (   void\
    );\
    STDMETHODIMP_(void) RequestDelayedService\
    (   IN  ULONGLONG   ullDelay\
    );\
    STDMETHODIMP_(void) CancelDelayedService\
    (   void\
    )
#endif

/*****************************************************************************
 * IRegistryKey
 *****************************************************************************
 * Interface for objects providing access to a registry key.
 */
DECLARE_INTERFACE_(IRegistryKey,IUnknown)
{
    DEFINE_ABSTRACT_UNKNOWN()   //  For IUnknown

    STDMETHOD_(NTSTATUS,QueryKey)
    (   THIS_
        IN      KEY_INFORMATION_CLASS   KeyInformationClass,
        OUT     PVOID                   KeyInformation,
        IN      ULONG                   Length,
        OUT     PULONG                  ResultLength
    )   PURE;

    STDMETHOD_(NTSTATUS,EnumerateKey)
    (   THIS_
        IN      ULONG                   Index,
        IN      KEY_INFORMATION_CLASS   KeyInformationClass,
        OUT     PVOID                   KeyInformation,
        IN      ULONG                   Length,
        OUT     PULONG                  ResultLength
    )   PURE;

    STDMETHOD_(NTSTATUS,QueryValueKey)
    (   THIS_
        IN      PUNICODE_STRING             ValueName,
        IN      KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass,
        OUT     PVOID                       KeyValueInformation,
        IN      ULONG                       Length,
        OUT     PULONG                      ResultLength
    )   PURE;

    STDMETHOD_(NTSTATUS,EnumerateValueKey)
    (   THIS_
        IN      ULONG                       Index,
        IN      KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass,
        OUT     PVOID                       KeyValueInformation,
        IN      ULONG                       Length,
        OUT     PULONG                      ResultLength
    )   PURE;

    STDMETHOD_(NTSTATUS,SetValueKey)
    (   THIS_
        IN      PUNICODE_STRING     ValueName OPTIONAL,
        IN      ULONG               Type,
        IN      PVOID               Data,
        IN      ULONG               DataSize
    )   PURE;

    STDMETHOD_(NTSTATUS,QueryRegistryValues)
    (   THIS_
        IN      PRTL_QUERY_REGISTRY_TABLE   QueryTable,
        IN      PVOID                       Context OPTIONAL
    )   PURE;

    STDMETHOD_(NTSTATUS,NewSubKey)
    (   THIS_
        OUT     IRegistryKey **     RegistrySubKey,
        IN      PUNKNOWN            OuterUnknown,
        IN      ACCESS_MASK         DesiredAccess,
        IN      PUNICODE_STRING     SubKeyName,
        IN      ULONG               CreateOptions,
        OUT     PULONG              Disposition     OPTIONAL
    )   PURE;

    STDMETHOD_(NTSTATUS,DeleteKey)
    (   THIS
    )   PURE;
};

typedef IRegistryKey *PREGISTRYKEY;

#ifdef PC_IMPLEMENTATION
#define IMP_IRegistryKey\
    STDMETHODIMP_(NTSTATUS) QueryKey\
    (   IN      KEY_INFORMATION_CLASS   KeyInformationClass,\
        OUT     PVOID                   KeyInformation,\
        IN      ULONG                   Length,\
        OUT     PULONG                  ResultLength\
    );\
    STDMETHODIMP_(NTSTATUS) EnumerateKey\
    (   IN      ULONG                   Index,\
        IN      KEY_INFORMATION_CLASS   KeyInformationClass,\
        OUT     PVOID                   KeyInformation,\
        IN      ULONG                   Length,\
        OUT     PULONG                  ResultLength\
    );\
    STDMETHODIMP_(NTSTATUS) QueryValueKey\
    (   IN      PUNICODE_STRING             ValueName,\
        IN      KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass,\
        OUT     PVOID                       KeyValueInformation,\
        IN      ULONG                       Length,\
        OUT     PULONG                      ResultLength\
    );\
    STDMETHODIMP_(NTSTATUS) EnumerateValueKey\
    (   IN      ULONG                       Index,\
        IN      KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass,\
        OUT     PVOID                       KeyValueInformation,\
        IN      ULONG                       Length,\
        OUT     PULONG                      ResultLength\
    );\
    STDMETHODIMP_(NTSTATUS) SetValueKey\
    (   IN      PUNICODE_STRING     ValueName OPTIONAL,\
        IN      ULONG               Type,\
        IN      PVOID               Data,\
        IN      ULONG               DataSize\
    );\
    STDMETHODIMP_(NTSTATUS) QueryRegistryValues\
    (   IN      PRTL_QUERY_REGISTRY_TABLE   QueryTable,\
        IN      PVOID                       Context OPTIONAL\
    );\
    STDMETHODIMP_(NTSTATUS) NewSubKey\
    (   OUT     IRegistryKey **     RegistrySubKey,\
        IN      PUNKNOWN            OuterUnknown,\
        IN      ACCESS_MASK         DesiredAccess,\
        IN      PUNICODE_STRING     SubKeyName,\
        IN      ULONG               CreateOptions,\
        OUT     PULONG              Disposition     OPTIONAL\
    );\
    STDMETHODIMP_(NTSTATUS) DeleteKey\
    (   void\
    )
#endif

#if (NTDDI_VERSION >= NTDDI_WINXP)
/*****************************************************************************
 * IMusicTechnology
 *****************************************************************************
 * Interface for setting MusicTechnology.
 */
DECLARE_INTERFACE_(IMusicTechnology,IUnknown)
{
    DEFINE_ABSTRACT_UNKNOWN()   //  For IUnknown

    //  For IMusicTechnology
    STDMETHOD_(NTSTATUS,SetTechnology)
    (   THIS_
        IN      const GUID *    Technology
    )   PURE;
};

typedef IMusicTechnology *PMUSICTECHNOLOGY;

#define IMP_IMusicTechnology\
    STDMETHODIMP_(NTSTATUS) SetTechnology\
    (   IN      const GUID *    Technology\
    )
#endif

typedef struct _PCPROPERTY_REQUEST PCPROPERTY_REQUEST, *PPCPROPERTY_REQUEST;
typedef struct _PCMETHOD_REQUEST PCMETHOD_REQUEST, *PPCMETHOD_REQUEST;
typedef struct _PCEVENT_REQUEST PCEVENT_REQUEST, *PPCEVENT_REQUEST;

/*****************************************************************************
 * PCPFNPROPERTY_HANDLER
 *****************************************************************************
 * Property handler function prototype.
 *
 * All property accesses and support queries for a given property on a given
 * filter, pin or node are routed to a single handler.  The parameter contains
 * complete information regarding the request.  The handler may return
 * STATUS_PENDING, in which case it must eventually call
 * PcCompletePendingPropertyRequest() to complete the request.
 */
typedef
NTSTATUS
(*PCPFNPROPERTY_HANDLER)
(
    IN      PPCPROPERTY_REQUEST PropertyRequest
);

/*****************************************************************************
 * PCPFNMETHOD_HANDLER
 *****************************************************************************
 * Method handler function prototype.
 *
 * All method calls and support queries for a given method on a given filter,
 * pin or node are routed to a single handler.  The parameter contains
 * complete information regarding the request.  The handler may return
 * STATUS_PENDING, in which case it must eventually call
 * PcCompletePendingMethodRequest() to complete the request.
 */
typedef
NTSTATUS
(*PCPFNMETHOD_HANDLER)
(
    IN      PPCMETHOD_REQUEST   MethodRequest
);

/*****************************************************************************
 * PCPFNEVENT_HANDLER
 *****************************************************************************
 * Event handler function prototype.
 *
 * All event add and remove requests and all event support queries for a
 * given event on a given filter, pin or node are routed to a single handler.
 * The parameter contains complete information regarding the request.  The
 * handler may return STATUS_PENDING, in which case it must eventually call
 * PcCompletePendingEventRequest() to complete the request.
 */
typedef
NTSTATUS
(*PCPFNEVENT_HANDLER)
(
    IN      PPCEVENT_REQUEST    EventRequest
);

/*****************************************************************************
 * PCPROPERTY_ITEM
 *****************************************************************************
 * Property table entry.
 *
 * A property item describes a property supported by a given filter, pin or
 * node.  The flags indicate what operations regarding the property are
 * supported and specify selected options with respect to the port's handling
 * of property requests.
 */
typedef struct
{
    const GUID *            Set;
    ULONG                   Id;
    ULONG                   Flags;
#define PCPROPERTY_ITEM_FLAG_GET            KSPROPERTY_TYPE_GET
#define PCPROPERTY_ITEM_FLAG_SET            KSPROPERTY_TYPE_SET
#define PCPROPERTY_ITEM_FLAG_BASICSUPPORT   KSPROPERTY_TYPE_BASICSUPPORT
//not supported #define PCPROPERTY_ITEM_FLAG_RELATIONS      KSPROPERTY_TYPE_RELATIONS
#define PCPROPERTY_ITEM_FLAG_SERIALIZERAW   KSPROPERTY_TYPE_SERIALIZERAW
#define PCPROPERTY_ITEM_FLAG_UNSERIALIZERAW KSPROPERTY_TYPE_UNSERIALIZERAW
#define PCPROPERTY_ITEM_FLAG_SERIALIZESIZE  KSPROPERTY_TYPE_SERIALIZESIZE
#define PCPROPERTY_ITEM_FLAG_SERIALIZE\
        (PCPROPERTY_ITEM_FLAG_SERIALIZERAW\
        |PCPROPERTY_ITEM_FLAG_UNSERIALIZERAW\
        |PCPROPERTY_ITEM_FLAG_SERIALIZESIZE\
        )
#define PCPROPERTY_ITEM_FLAG_DEFAULTVALUES  KSPROPERTY_TYPE_DEFAULTVALUES
    PCPFNPROPERTY_HANDLER   Handler;
}
PCPROPERTY_ITEM, *PPCPROPERTY_ITEM;

/*****************************************************************************
 * PCMETHOD_ITEM
 *****************************************************************************
 * Method table entry.
 *
 * A method item describes a method supported by a given filter, pin or node.
 * The flags indicate what operations regarding the method are supported and
 * specify selected options with respect to the port's handling of method
 * requests.
 */
typedef struct
{
    const GUID *            Set;
    ULONG                   Id;
    ULONG                   Flags;
#define PCMETHOD_ITEM_FLAG_NONE         KSMETHOD_TYPE_NONE
#define PCMETHOD_ITEM_FLAG_READ         KSMETHOD_TYPE_READ
#define PCMETHOD_ITEM_FLAG_WRITE        KSMETHOD_TYPE_WRITE
#define PCMETHOD_ITEM_FLAG_MODIFY       KSMETHOD_TYPE_MODIFY
#define PCMETHOD_ITEM_FLAG_SOURCE       KSMETHOD_TYPE_SOURCE
#define PCMETHOD_ITEM_FLAG_BASICSUPPORT KSMETHOD_TYPE_BASICSUPPORT
    PCPFNMETHOD_HANDLER     Handler;
}
PCMETHOD_ITEM, *PPCMETHOD_ITEM;

/*****************************************************************************
 * PCEVENT_ITEM
 *****************************************************************************
 * Event table entry.
 *
 * An event item describes an event supported by a given filter, pin or node.
 * The flags indicate what operations regarding the event are supported and
 * specify selected options with respect to the port's handling of event
 * requests.
 */
typedef struct
{
    const GUID *            Set;
    ULONG                   Id;
    ULONG                   Flags;
#define PCEVENT_ITEM_FLAG_ENABLE        KSEVENT_TYPE_ENABLE
#define PCEVENT_ITEM_FLAG_ONESHOT       KSEVENT_TYPE_ONESHOT
#define PCEVENT_ITEM_FLAG_BASICSUPPORT  KSEVENT_TYPE_BASICSUPPORT
    PCPFNEVENT_HANDLER      Handler;
}
PCEVENT_ITEM, *PPCEVENT_ITEM;

/*****************************************************************************
 * PCPROPERTY_REQUEST
 *****************************************************************************
 * Property request submitted to a property handler.
 *
 * This is the form that a property request takes.  Although the major target
 * is generic, in the case of miniports, it will be a pointer to the miniport
 * object.  Likewise, the minor target is the stream or voice if the request
 * is specific to a stream or voice.  Otherwise, the minor target is NULL.
 * If the request is targeted at a node, the Node parameter will specify which
 * one, otherwise it will be ULONG(-1).  If the target is a node, the minor
 * target may be specified to indicate the stream or voice with which the
 * targeted node instance is associated.
 */
typedef struct _PCPROPERTY_REQUEST
{
    PUNKNOWN                MajorTarget;
    PUNKNOWN                MinorTarget;
    ULONG                   Node;
    const PCPROPERTY_ITEM * PropertyItem;
    ULONG                   Verb;
    ULONG                   InstanceSize;
    PVOID                   Instance;
    ULONG                   ValueSize;
    PVOID                   Value;
    PIRP                    Irp;
}
PCPROPERTY_REQUEST, *PPCPROPERTY_REQUEST;

/*****************************************************************************
 * PCMETHOD_REQUEST
 *****************************************************************************
 * Method request submitted to a property handler.
 *
 * Comments in the description of PCPROPERTY_REQUEST regarding the target
 * fields apply to this structure as well.
 */
typedef struct _PCMETHOD_REQUEST
{
    PUNKNOWN                MajorTarget;
    PUNKNOWN                MinorTarget;
    ULONG                   Node;
    const PCMETHOD_ITEM *   MethodItem;
    ULONG                   Verb;
    // TODO
}
PCMETHOD_REQUEST, *PPCMETHOD_REQUEST;

/*****************************************************************************
 * PCEVENT_REQUEST
 *****************************************************************************
 * Event request submitted to a property handler.
 *
 * Comments in the description of PCPROPERTY_REQUEST regarding the target
 * fields apply to this structure as well.
 */
typedef struct _PCEVENT_REQUEST
{
    PUNKNOWN                MajorTarget;
    PUNKNOWN                MinorTarget;
    ULONG                   Node;
    const PCEVENT_ITEM *    EventItem;
    PKSEVENT_ENTRY          EventEntry;
    ULONG                   Verb;
    PIRP                    Irp;
}
PCEVENT_REQUEST, *PPCEVENT_REQUEST;

#define PCEVENT_VERB_NONE          0
#define PCEVENT_VERB_ADD           1
#define PCEVENT_VERB_REMOVE        2
#define PCEVENT_VERB_SUPPORT       4

/*****************************************************************************
 * PCAUTOMATION_TABLE
 *****************************************************************************
 * Master table of properties, methods and events.
 *
 * Any of the item pointers may be NULL, in which case, corresponding counts
 * must be zero.  For item tables that are not zero length, the item size must
 * not be smaller than the size of the item structure defined by port class.
 * The item size may be larger, in which case the port class item structure is
 * assumed to be followed by private data.  Item sizes must be a multiple of
 * 8.
 */
typedef struct
{
    ULONG                               PropertyItemSize;
    ULONG                               PropertyCount;
    const PCPROPERTY_ITEM * Properties;
        ULONG                           MethodItemSize;
        ULONG                           MethodCount;
        const PCMETHOD_ITEM *   Methods;
        ULONG                           EventItemSize;
        ULONG                           EventCount;
        const PCEVENT_ITEM *    Events;
    ULONG                   Reserved;
}
PCAUTOMATION_TABLE, *PPCAUTOMATION_TABLE;

#define DEFINE_PCAUTOMATION_TABLE_PROP(AutomationTable,PropertyTable)\
const PCAUTOMATION_TABLE AutomationTable =\
{\
    sizeof(PropertyTable[0]),\
    SIZEOF_ARRAY(PropertyTable),\
    (const PCPROPERTY_ITEM *) PropertyTable,\
    0,0,NULL,\
    0,0,NULL,\
    0\
}

#define DEFINE_PCAUTOMATION_TABLE_PROP_EVENT(AutomationTable,PropertyTable,EventTable)\
const PCAUTOMATION_TABLE AutomationTable =\
{\
    sizeof(PropertyTable[0]),\
    SIZEOF_ARRAY(PropertyTable),\
    (const PCPROPERTY_ITEM *) PropertyTable,\
    0,0,NULL,\
    sizeof(EventTable[0]),\
    SIZEOF_ARRAY(EventTable),\
    (const PCEVENT_ITEM *) EventTable,\
    0\
}

/*****************************************************************************
 * PCPIN_DESCRIPTOR for IMiniport::GetDescription()
 *****************************************************************************
 * Description of a pin on the filter implemented by the miniport.
 *
 * MaxGlobalInstanceCount and MaxFilterInstanceCount may be zero to indicate
 * that the pin may not be instantiated, ULONG(-1) to indicate the pin may be
 * allocated any number of times, or any other value to indicate a specific
 * number of times the pin may be allocated.  MinFilterInstanceCount may not
 * be ULONG(-1) because it specifies a definite lower bound on the number of
 * instances of a pin that must exist in order for a filter to function.
 *
 * The KS pin descriptor may have zero interfaces and zero mediums.  The list
 * of interfaces is ignored in all cases.  The medium list will default to
 * a list containing only the standard medium (device I/O).
 *
 * The automation table pointer may be NULL indicating that no automation is
 * supported.
 */
typedef struct
{
    ULONG                       MaxGlobalInstanceCount;
    ULONG                       MaxFilterInstanceCount;
    ULONG                       MinFilterInstanceCount;
    const PCAUTOMATION_TABLE *  AutomationTable;
    KSPIN_DESCRIPTOR            KsPinDescriptor;
}
PCPIN_DESCRIPTOR, *PPCPIN_DESCRIPTOR;

/*****************************************************************************
 * PCNODE_DESCRIPTOR for IMiniport::GetDescription()
 *****************************************************************************
 * Description of a node in the filter implemented by the miniport.
 *
 * The automation table pointer may be NULL indicating that no automation is
 * supported.  The name GUID pointer may be NULL indicating that the type GUID
 * should be used to determine the node name.
 */
typedef struct
{
    ULONG                       Flags;
        const PCAUTOMATION_TABLE *  AutomationTable;
        const GUID *                Type;
        const GUID *                Name;
}
PCNODE_DESCRIPTOR, *PPCNODE_DESCRIPTOR;

/*****************************************************************************
 * PCCONNECTION_DESCRIPTOR for IMiniport::GetDescription()
 *****************************************************************************
 * Description of a node connection in the topology of the filter implemented
 * by the miniport.
 */
typedef KSTOPOLOGY_CONNECTION
PCCONNECTION_DESCRIPTOR, *PPCCONNECTION_DESCRIPTOR;

/*****************************************************************************
 * PCFILTER_DESCRIPTOR for IMiniport::GetDescription()
 *****************************************************************************
 * Description of the of the filter implemented by a miniport, including
 * pins, nodes, connections and properties.
 *
 * The version number should be zero.
 */
typedef struct
{
    ULONG                           Version;
        const PCAUTOMATION_TABLE *      AutomationTable;
    ULONG                           PinSize;
    ULONG                           PinCount;
    const PCPIN_DESCRIPTOR *        Pins;
    ULONG                           NodeSize;
    ULONG                           NodeCount;
    const PCNODE_DESCRIPTOR *       Nodes;
    ULONG                           ConnectionCount;
    const PCCONNECTION_DESCRIPTOR * Connections;
    ULONG                           CategoryCount;
    const GUID *                    Categories;
}
PCFILTER_DESCRIPTOR, *PPCFILTER_DESCRIPTOR;

/*****************************************************************************
 * PCFILTER_NODE for IMiniport::GetTopology()
 *****************************************************************************
 * The placeholder for the FromNode or ToNode fields in connections which
 * describe connections to the filter's pins.
 */
#define PCFILTER_NODE KSFILTER_NODE

/*****************************************************************************
 * IMiniport
 *****************************************************************************
 * Interface common to all miniports.
 */
DECLARE_INTERFACE_(IMiniport,IUnknown)
{
    DEFINE_ABSTRACT_UNKNOWN()   //  For IUnknown

    DEFINE_ABSTRACT_MINIPORT()  //  For IMiniport
};

typedef IMiniport *PMINIPORT;

#define IMP_IMiniport\
    STDMETHODIMP_(NTSTATUS) GetDescription\
    (   OUT     PPCFILTER_DESCRIPTOR *  Description\
    );\
    STDMETHODIMP_(NTSTATUS) DataRangeIntersection\
    (   IN      ULONG           PinId,\
        IN      PKSDATARANGE    DataRange,\
        IN      PKSDATARANGE    MatchingDataRange,\
        IN      ULONG           OutputBufferLength,\
        OUT     PVOID           ResultantFormat     OPTIONAL,\
        OUT     PULONG          ResultantFormatLength\
    )

/*****************************************************************************
 * IPort
 *****************************************************************************
 * Interface common to all port lower edges.
 */
DECLARE_INTERFACE_(IPort,IUnknown)
{
    DEFINE_ABSTRACT_UNKNOWN()   //  For IUnknown

    DEFINE_ABSTRACT_PORT()      //  For IPort
};

typedef IPort *PPORT;

#ifdef PC_IMPLEMENTATION
#define IMP_IPort\
    STDMETHODIMP_(NTSTATUS) Init\
    (   IN      PDEVICE_OBJECT  DeviceObject,\
        IN      PIRP            Irp,\
        IN      PUNKNOWN        UnknownMiniport,\
        IN      PUNKNOWN        UnknownAdapter      OPTIONAL,\
        IN      PRESOURCELIST   ResourceList\
    );\
    STDMETHODIMP_(NTSTATUS) GetDeviceProperty\
    (   IN      DEVICE_REGISTRY_PROPERTY    DeviceProperty,\
        IN      ULONG                       BufferLength,\
        OUT     PVOID                       PropertyBuffer,\
        OUT     PULONG                      ResultLength\
    );\
    STDMETHODIMP_(NTSTATUS) NewRegistryKey\
    (   OUT     PREGISTRYKEY *      OutRegistryKey,\
        IN      PUNKNOWN            OuterUnknown        OPTIONAL,\
        IN      ULONG               RegistryKeyType,\
        IN      ACCESS_MASK         DesiredAccess,\
        IN      POBJECT_ATTRIBUTES  ObjectAttributes    OPTIONAL,\
        IN      ULONG               CreateOptions       OPTIONAL,\
        OUT     PULONG              Disposition         OPTIONAL\
    )
#endif

/*****************************************************************************
 * IPortMidi
 *****************************************************************************
 * Interface for MIDI port lower edge.
 */
DECLARE_INTERFACE_(IPortMidi,IPort)
{
    DEFINE_ABSTRACT_UNKNOWN()   //  For IUnknown

    DEFINE_ABSTRACT_PORT()      //  For IPort

    //  For IPortMidi
    STDMETHOD_(void,Notify)
    (   THIS_
        IN      PSERVICEGROUP   ServiceGroup    OPTIONAL
    )   PURE;

    STDMETHOD_(void,RegisterServiceGroup)
    (   THIS_
        IN      PSERVICEGROUP   ServiceGroup
    )   PURE;
};

typedef IPortMidi *PPORTMIDI;

#ifdef PC_IMPLEMENTATION
#define IMP_IPortMidi\
    IMP_IPort;\
    STDMETHODIMP_(void) Notify\
    (   IN      PSERVICEGROUP   ServiceGroup    OPTIONAL\
    );\
    STDMETHODIMP_(void) RegisterServiceGroup\
    (   IN      PSERVICEGROUP   ServiceGroup\
    )
#endif

/*****************************************************************************
 * IMiniportMidiStream
 *****************************************************************************
 * Interface for MIDI miniport streams.
 */
DECLARE_INTERFACE_(IMiniportMidiStream,IUnknown)
{
    DEFINE_ABSTRACT_UNKNOWN()   //  For IUnknown

    STDMETHOD_(NTSTATUS,SetFormat)
    (   THIS_
        IN      PKSDATAFORMAT   DataFormat
    )   PURE;

    STDMETHOD_(NTSTATUS,SetState)
    (   THIS_
        IN      KSSTATE     State
    )   PURE;

    STDMETHOD_(NTSTATUS,Read)
    (   THIS_
        IN      PVOID       BufferAddress,
        IN      ULONG       BufferLength,
        OUT     PULONG      BytesRead
    )   PURE;

    STDMETHOD_(NTSTATUS,Write)
    (   THIS_
        IN      PVOID       BufferAddress,
        IN      ULONG       BytesToWrite,
        OUT     PULONG      BytesWritten
    )   PURE;
};

typedef IMiniportMidiStream *PMINIPORTMIDISTREAM;

#define IMP_IMiniportMidiStream\
    STDMETHODIMP_(NTSTATUS) SetFormat\
    (   IN      PKSDATAFORMAT   DataFormat\
    );\
    STDMETHODIMP_(NTSTATUS) SetState\
    (   IN      KSSTATE     State\
    );\
    STDMETHODIMP_(NTSTATUS) Read\
    (   IN      PVOID       BufferAddress,\
        IN      ULONG       BufferLength,\
        OUT     PULONG      BytesRead\
    );\
    STDMETHODIMP_(NTSTATUS) Write\
    (   IN      PVOID       BufferAddress,\
        IN      ULONG       BytesToWrite,\
        OUT     PULONG      BytesWritten\
    )

/*****************************************************************************
 * IMiniportMidi
 *****************************************************************************
 * Interface for MIDI miniports.
 */
DECLARE_INTERFACE_(IMiniportMidi,IMiniport)
{
    DEFINE_ABSTRACT_UNKNOWN()   //  For IUnknown

    DEFINE_ABSTRACT_MINIPORT()  //  For IMiniport

    //  For IMiniportMidi
    STDMETHOD_(NTSTATUS,Init)
    (   THIS_
        IN      PUNKNOWN        UnknownAdapter,
        IN      PRESOURCELIST   ResourceList,
        IN      PPORTMIDI       Port,
        OUT     PSERVICEGROUP * ServiceGroup
    )   PURE;

    STDMETHOD_(void,Service)
    (   THIS
    )   PURE;

    STDMETHOD_(NTSTATUS,NewStream)
    (   THIS_
        OUT     PMINIPORTMIDISTREAM *   Stream,
        IN      PUNKNOWN                OuterUnknown    OPTIONAL,
        IN      POOL_TYPE               PoolType,
        IN      ULONG                   Pin,
        IN      BOOLEAN                 Capture,
        IN      PKSDATAFORMAT           DataFormat,
        OUT     PSERVICEGROUP *         ServiceGroup
    )   PURE;
};

typedef IMiniportMidi *PMINIPORTMIDI;

#define IMP_IMiniportMidi\
    IMP_IMiniport;\
    STDMETHODIMP_(NTSTATUS) Init\
    (   IN      PUNKNOWN        UnknownAdapter,\
        IN      PRESOURCELIST   ResourceList,\
        IN      PPORTMIDI       Port,\
        OUT     PSERVICEGROUP * ServiceGroup\
    );\
    STDMETHODIMP_(void) Service\
    (   void\
    );\
    STDMETHODIMP_(NTSTATUS) NewStream\
    (   OUT     PMINIPORTMIDISTREAM *   Stream,\
        IN      PUNKNOWN                OuterUnknown    OPTIONAL,\
        IN      POOL_TYPE               PoolType,\
        IN      ULONG                   Pin,\
        IN      BOOLEAN                 Capture,\
        IN      PKSDATAFORMAT           DataFormat,\
        OUT     PSERVICEGROUP *         ServiceGroup\
    )

/*****************************************************************************
 * IPortDMus
 *****************************************************************************
 * See DMusicKS.h
 */

/*****************************************************************************
 * IMXF
 *****************************************************************************
 * See DMusicKS.h
 */

/*****************************************************************************
 * IAllocatorMXF
 *****************************************************************************
 * See DMusicKS.h
 */

/*****************************************************************************
 * IMiniportDMus
 *****************************************************************************
 * See DMusicKS.h
 */


/*****************************************************************************
 * IPortTopology
 *****************************************************************************
 * Interface for topology port lower edge.
 */
DECLARE_INTERFACE_(IPortTopology,IPort)
{
    DEFINE_ABSTRACT_UNKNOWN()   //  For IUnknown

    DEFINE_ABSTRACT_PORT()      //  For IPort
};

typedef IPortTopology *PPORTTOPOLOGY;

#ifdef PC_IMPLEMENTATION
#define IMP_IPortTopology IMP_IPort
#endif

/*****************************************************************************
 * IMiniportTopology
 *****************************************************************************
 * Interface for topology miniports.
 */
DECLARE_INTERFACE_(IMiniportTopology,IMiniport)
{
    DEFINE_ABSTRACT_UNKNOWN()   //  For IUnknown

    DEFINE_ABSTRACT_MINIPORT()  //  For IMiniport

    //  For IMiniportTopology
    STDMETHOD_(NTSTATUS,Init)
    (   THIS_
        IN      PUNKNOWN                UnknownAdapter,
        IN      PRESOURCELIST           ResourceList,
        IN      PPORTTOPOLOGY           Port
    )   PURE;
};

typedef IMiniportTopology *PMINIPORTTOPOLOGY;

#define IMP_IMiniportTopology\
    IMP_IMiniport;\
    STDMETHODIMP_(NTSTATUS) Init\
    (   IN      PUNKNOWN        UnknownAdapter,\
        IN      PRESOURCELIST   ResourceList,\
        IN      PPORTTOPOLOGY   Port\
    )

/*****************************************************************************
 * IPortWaveCyclic
 *****************************************************************************
 * Interface for cyclic wave port lower edge.
 */
DECLARE_INTERFACE_(IPortWaveCyclic,IPort)
{
    DEFINE_ABSTRACT_UNKNOWN()   //  For IUnknown

    DEFINE_ABSTRACT_PORT()      //  For IPort

    //  For IPortWaveCyclic
    STDMETHOD_(void,Notify)
    (   THIS_
        IN      PSERVICEGROUP   ServiceGroup
    )   PURE;

    STDMETHOD_(NTSTATUS,NewSlaveDmaChannel)
    (   THIS_
        OUT     PDMACHANNELSLAVE *  DmaChannel,
        IN      PUNKNOWN            OuterUnknown,
        IN      PRESOURCELIST       ResourceList,
        IN      ULONG               DmaIndex,
        IN      ULONG               MaximumLength,
        IN      BOOLEAN             DemandMode,
        IN      DMA_SPEED           DmaSpeed
    )   PURE;

    STDMETHOD_(NTSTATUS,NewMasterDmaChannel)
    (   THIS_
        OUT     PDMACHANNEL *   DmaChannel,
        IN      PUNKNOWN        OuterUnknown,
        IN      PRESOURCELIST   ResourceList    OPTIONAL,
        IN      ULONG           MaximumLength,
        IN      BOOLEAN         Dma32BitAddresses,
        IN      BOOLEAN         Dma64BitAddresses,
        IN      DMA_WIDTH       DmaWidth,
        IN      DMA_SPEED       DmaSpeed
    )   PURE;
};

typedef IPortWaveCyclic *PPORTWAVECYCLIC;

#ifdef PC_IMPLEMENTATION
#define IMP_IPortWaveCyclic\
    IMP_IPort;\
    STDMETHODIMP_(void) Notify\
    (   IN      PSERVICEGROUP   ServiceGroup\
    );\
    STDMETHODIMP_(NTSTATUS) NewSlaveDmaChannel\
    (   OUT     PDMACHANNELSLAVE *  DmaChannel,\
        IN      PUNKNOWN            OuterUnknown,\
        IN      PRESOURCELIST       ResourceList,\
        IN      ULONG               DmaIndex,\
        IN      ULONG               MaximumLength,\
        IN      BOOLEAN             DemandMode,\
        IN      DMA_SPEED           DmaSpeed\
    );\
    STDMETHODIMP_(NTSTATUS) NewMasterDmaChannel\
    (   OUT     PDMACHANNEL *   DmaChannel,\
        IN      PUNKNOWN        OuterUnknown,\
        IN      PRESOURCELIST   ResourceList    OPTIONAL,\
        IN      ULONG           MaximumLength,\
        IN      BOOLEAN         Dma32BitAddresses,\
        IN      BOOLEAN         Dma64BitAddresses,\
        IN      DMA_WIDTH       DmaWidth,\
        IN      DMA_SPEED       DmaSpeed\
    )
#endif

/*****************************************************************************
 * IMiniportWaveCyclicStream
 *****************************************************************************
 * Interface for cyclic wave miniport streams.
 */
DECLARE_INTERFACE_(IMiniportWaveCyclicStream,IUnknown)
{
    DEFINE_ABSTRACT_UNKNOWN()   //  For IUnknown

    STDMETHOD_(NTSTATUS,SetFormat)
    (   THIS_
        IN      PKSDATAFORMAT   DataFormat
    )   PURE;

    STDMETHOD_(ULONG,SetNotificationFreq)
    (   THIS_
        IN      ULONG           Interval,
        OUT     PULONG          FrameSize
    )   PURE;

    STDMETHOD_(NTSTATUS,SetState)
    (   THIS_
        IN      KSSTATE         State
    )   PURE;

    STDMETHOD_(NTSTATUS,GetPosition)
    (   THIS_
        OUT     PULONG          Position
    )   PURE;

    STDMETHOD_(NTSTATUS,NormalizePhysicalPosition)
    (   THIS_
        IN OUT  PLONGLONG       PhysicalPosition
    )   PURE;

    STDMETHOD_(void,Silence)
    (   THIS_
        IN      PVOID           Buffer,
        IN      ULONG           ByteCount
    )   PURE;
};

typedef IMiniportWaveCyclicStream *PMINIPORTWAVECYCLICSTREAM;

#define IMP_IMiniportWaveCyclicStream\
    STDMETHODIMP_(NTSTATUS) SetFormat\
    (   IN      PKSDATAFORMAT   DataFormat\
    );\
    STDMETHODIMP_(ULONG) SetNotificationFreq\
    (   IN      ULONG           Interval,\
        OUT     PULONG          FrameSize\
    );\
    STDMETHODIMP_(NTSTATUS) SetState\
    (   IN      KSSTATE         State\
    );\
    STDMETHODIMP_(NTSTATUS) GetPosition\
    (   OUT     PULONG          Position\
    );\
    STDMETHODIMP_(NTSTATUS) NormalizePhysicalPosition\
    (   IN OUT PLONGLONG        PhysicalPosition\
    );\
    STDMETHODIMP_(void) Silence\
    (   IN      PVOID           Buffer,\
        IN      ULONG           ByteCount\
    )

/*****************************************************************************
 * IMiniportWaveCyclic
 *****************************************************************************
 * Interface for cyclic wave miniports.
 */
DECLARE_INTERFACE_(IMiniportWaveCyclic,IMiniport)
{
    DEFINE_ABSTRACT_UNKNOWN()   //  For IUnknown

    DEFINE_ABSTRACT_MINIPORT()  //  For IMiniport

    //  For IMiniportWaveCyclic
    STDMETHOD_(NTSTATUS,Init)
    (   THIS_
        IN      PUNKNOWN        UnknownAdapter,
        IN      PRESOURCELIST   ResourceList,
        IN      PPORTWAVECYCLIC Port
    )   PURE;

    STDMETHOD_(NTSTATUS,NewStream)
    (   THIS_
        OUT     PMINIPORTWAVECYCLICSTREAM * Stream,
        IN      PUNKNOWN                    OuterUnknown    OPTIONAL,
        IN      POOL_TYPE                   PoolType,
        IN      ULONG                       Pin,
        IN      BOOLEAN                     Capture,
        IN      PKSDATAFORMAT               DataFormat,
        OUT     PDMACHANNEL *               DmaChannel,
        OUT     PSERVICEGROUP *             ServiceGroup
    )   PURE;
};

typedef IMiniportWaveCyclic *PMINIPORTWAVECYCLIC;

#define IMP_IMiniportWaveCyclic\
    IMP_IMiniport;\
    STDMETHODIMP_(NTSTATUS) Init\
    (   IN      PUNKNOWN        UnknownAdapter,\
        IN      PRESOURCELIST   ResourceList,\
        IN      PPORTWAVECYCLIC Port\
    );\
    STDMETHODIMP_(NTSTATUS) NewStream\
    (   OUT     PMINIPORTWAVECYCLICSTREAM * Stream,\
        IN      PUNKNOWN                    OuterUnknown    OPTIONAL,\
        IN      POOL_TYPE                   PoolType,\
        IN      ULONG                       Pin,\
        IN      BOOLEAN                     Capture,\
        IN      PKSDATAFORMAT               DataFormat,\
        OUT     PDMACHANNEL *               DmaChannel,\
        OUT     PSERVICEGROUP *             ServiceGroup\
    )

/*****************************************************************************
 * IPortWavePci
 *****************************************************************************
 * Interface for PCI wave port lower edge.
 */
DECLARE_INTERFACE_(IPortWavePci,IPort)
{
    DEFINE_ABSTRACT_UNKNOWN()   //  For IUnknown

    DEFINE_ABSTRACT_PORT()      //  For IPort

    //  For IPortWavePci
    STDMETHOD_(void,Notify)
    (   THIS_
        IN      PSERVICEGROUP       ServiceGroup
    )   PURE;

    STDMETHOD_(NTSTATUS,NewMasterDmaChannel)
    (   THIS_
        OUT     PDMACHANNEL *       OutDmaChannel,
        IN      PUNKNOWN            OuterUnknown    OPTIONAL,
        IN      POOL_TYPE           PoolType,
        IN      PRESOURCELIST       ResourceList    OPTIONAL,
        IN      BOOLEAN             ScatterGather,
        IN      BOOLEAN             Dma32BitAddresses,
        IN      BOOLEAN             Dma64BitAddresses,
        IN      BOOLEAN             IgnoreCount,
        IN      DMA_WIDTH           DmaWidth,
        IN      DMA_SPEED           DmaSpeed,
        IN      ULONG               MaximumLength,
        IN      ULONG               DmaPort
    )   PURE;
};

typedef IPortWavePci *PPORTWAVEPCI;

#ifdef PC_IMPLEMENTATION
#define IMP_IPortWavePci\
    IMP_IPort;\
    STDMETHODIMP_(void) Notify\
    (   IN      PSERVICEGROUP       ServiceGroup\
    );\
    STDMETHODIMP_(NTSTATUS) NewMasterDmaChannel\
    (   OUT     PDMACHANNEL *       OutDmaChannel,\
        IN      PUNKNOWN            OuterUnknown    OPTIONAL,\
        IN      POOL_TYPE           PoolType,\
        IN      PRESOURCELIST       ResourceList    OPTIONAL,\
        IN      BOOLEAN             ScatterGather,\
        IN      BOOLEAN             Dma32BitAddresses,\
        IN      BOOLEAN             Dma64BitAddresses,\
        IN      BOOLEAN             IgnoreCount,\
        IN      DMA_WIDTH           DmaWidth,\
        IN      DMA_SPEED           DmaSpeed,\
        IN      ULONG               MaximumLength,\
        IN      ULONG               DmaPort\
    )
#endif

/*****************************************************************************
 * IPortWavePciStream
 *****************************************************************************
 * Interface for PCI wave port pin lower edge.
 */
DECLARE_INTERFACE_(IPortWavePciStream,IUnknown)
{
    DEFINE_ABSTRACT_UNKNOWN()   //  For IUnknown

    STDMETHOD_(NTSTATUS,GetMapping)
    (   THIS_
        IN      PVOID               Tag,
        OUT     PPHYSICAL_ADDRESS   PhysicalAddress,
        OUT     PVOID *             VirtualAddress,
        OUT     PULONG              ByteCount,
        OUT     PULONG              Flags
    )   PURE;

    STDMETHOD_(NTSTATUS,ReleaseMapping)
    (   THIS_
        IN      PVOID               Tag
    )   PURE;

    STDMETHOD_(NTSTATUS,TerminatePacket)
    (   THIS
    )   PURE;
};

typedef IPortWavePciStream *PPORTWAVEPCISTREAM;

#ifdef PC_IMPLEMENTATION
#define IMP_IPortWavePciStream\
    STDMETHODIMP_(NTSTATUS) GetMapping\
    (   IN      PVOID               Tag,\
        OUT     PPHYSICAL_ADDRESS   PhysicalAddress,\
        OUT     PVOID *             VirtualAddress,\
        OUT     PULONG              ByteCount,\
        OUT     PULONG              Flags\
    );\
    STDMETHODIMP_(NTSTATUS) ReleaseMapping\
    (   IN      PVOID               Tag\
    );\
    STDMETHODIMP_(NTSTATUS) TerminatePacket\
    (   void\
    )
#endif

/*****************************************************************************
 * IMiniportWavePciStream
 *****************************************************************************
 * Interface for PCI wave miniport streams.
 */
DECLARE_INTERFACE_(IMiniportWavePciStream,IUnknown)
{
    DEFINE_ABSTRACT_UNKNOWN()   //  For IUnknown

    STDMETHOD_(NTSTATUS,SetFormat)
    (   THIS_
        IN      PKSDATAFORMAT   DataFormat
    )   PURE;

    STDMETHOD_(NTSTATUS,SetState)
    (   THIS_
        IN      KSSTATE         State
    )   PURE;

    STDMETHOD_(NTSTATUS,GetPosition)
    (   THIS_
        OUT     PULONGLONG      Position
    )   PURE;

    STDMETHOD_(NTSTATUS,NormalizePhysicalPosition)
    (
        THIS_
        IN OUT PLONGLONG        PhysicalPosition
    )   PURE;

    STDMETHOD_(NTSTATUS,GetAllocatorFraming)
    (
        THIS_
        OUT PKSALLOCATOR_FRAMING AllocatorFraming
    ) PURE;

    STDMETHOD_(NTSTATUS,RevokeMappings)
    (   THIS_
        IN      PVOID           FirstTag,
        IN      PVOID           LastTag,
        OUT     PULONG          MappingsRevoked
    )   PURE;

    STDMETHOD_(void,MappingAvailable)
    (   THIS
    )   PURE;

    STDMETHOD_(void,Service)
    (   THIS
    )   PURE;
};

typedef IMiniportWavePciStream *PMINIPORTWAVEPCISTREAM;

#define IMP_IMiniportWavePciStream\
    STDMETHODIMP_(NTSTATUS) SetFormat\
    (   IN      PKSDATAFORMAT   DataFormat\
    );\
    STDMETHODIMP_(NTSTATUS) SetState\
    (   IN      KSSTATE         State\
    );\
    STDMETHODIMP_(NTSTATUS) GetPosition\
    (   OUT     PULONGLONG      Position\
    );\
    STDMETHODIMP_(NTSTATUS) NormalizePhysicalPosition\
    (   IN OUT PLONGLONG        PhysicalPosition\
    );\
    STDMETHODIMP_(NTSTATUS) GetAllocatorFraming\
    (   OUT PKSALLOCATOR_FRAMING AllocatorFraming\
    );\
    STDMETHODIMP_(NTSTATUS) RevokeMappings\
    (   IN      PVOID           FirstTag,\
        IN      PVOID           LastTag,\
        OUT     PULONG          MappingsRevoked\
    );\
    STDMETHODIMP_(void) MappingAvailable\
    (   void\
    );\
    STDMETHODIMP_(void) Service\
    (   void\
    )

/*****************************************************************************
 * IMiniportWavePci
 *****************************************************************************
 * Interface for PCI wave miniports.
 */
DECLARE_INTERFACE_(IMiniportWavePci,IMiniport)
{
    DEFINE_ABSTRACT_UNKNOWN()   //  For IUnknown

    DEFINE_ABSTRACT_MINIPORT()  //  For IMiniport

    //  For IMiniportWavePci
    STDMETHOD_(NTSTATUS,Init)
    (   THIS_
        IN      PUNKNOWN            UnknownAdapter,
        IN      PRESOURCELIST       ResourceList,
        IN      PPORTWAVEPCI        Port,
        OUT     PSERVICEGROUP *     ServiceGroup
    )   PURE;

    STDMETHOD_(NTSTATUS,NewStream)
    (   THIS_
        OUT     PMINIPORTWAVEPCISTREAM *    Stream,
        IN      PUNKNOWN                    OuterUnknown    OPTIONAL,
        IN      POOL_TYPE                   PoolType,
        IN      PPORTWAVEPCISTREAM          PortStream,
        IN      ULONG                       Pin,
        IN      BOOLEAN                     Capture,
        IN      PKSDATAFORMAT               DataFormat,
        OUT     PDMACHANNEL *               DmaChannel,
        OUT     PSERVICEGROUP *             ServiceGroup
    )   PURE;

    STDMETHOD_(void,Service)
    (   THIS
    )   PURE;
};

typedef IMiniportWavePci *PMINIPORTWAVEPCI;

#define IMP_IMiniportWavePci\
    IMP_IMiniport;\
    STDMETHODIMP_(NTSTATUS) Init\
    (   IN      PUNKNOWN            UnknownAdapter,\
        IN      PRESOURCELIST       ResourceList,\
        IN      PPORTWAVEPCI        Port,\
        OUT     PSERVICEGROUP *     ServiceGroup\
    );\
    STDMETHODIMP_(NTSTATUS) NewStream\
    (   OUT     PMINIPORTWAVEPCISTREAM *    Stream,\
        IN      PUNKNOWN                    OuterUnknown    OPTIONAL,\
        IN      POOL_TYPE                   PoolType,\
        IN      PPORTWAVEPCISTREAM          PortStream,\
        IN      ULONG                       Pin,\
        IN      BOOLEAN                     Capture,\
        IN      PKSDATAFORMAT               DataFormat,\
        OUT     PDMACHANNEL *               DmaChannel,\
        OUT     PSERVICEGROUP *             ServiceGroup\
    );\
    STDMETHODIMP_(void) Service\
    (   void\
    )

#if (NTDDI_VERSION >= NTDDI_VISTA)
/*****************************************************************************
 * IPortWaveRT
 *****************************************************************************
 * Interface for WaveRT port lower edge.
 */
DECLARE_INTERFACE_(IPortWaveRT,IPort)
{
    DEFINE_ABSTRACT_UNKNOWN()   //  For IUnknown

    DEFINE_ABSTRACT_PORT()      //  For IPort
};

typedef IPortWaveRT *PPORTWAVERT;

#ifdef PC_IMPLEMENTATION
#define IMP_IPortWaveRT\
    IMP_IPort
#endif

/*****************************************************************************
 * IPortWaveRTStream
 *****************************************************************************
 * Interface for WaveRT stream port lower edge.
 */
DECLARE_INTERFACE_(IPortWaveRTStream,IUnknown)
{
    DEFINE_ABSTRACT_UNKNOWN()   //  For IUnknown

    STDMETHOD_(PMDL, AllocatePagesForMdl)
    (   THIS_
        IN      PHYSICAL_ADDRESS    HighAddress,
        IN      SIZE_T              TotalBytes
    )   PURE;

    STDMETHOD_(PMDL, AllocateContiguousPagesForMdl)
    (   THIS_
        IN      PHYSICAL_ADDRESS    LowAddress,
        IN      PHYSICAL_ADDRESS    HighAddress,
        IN      SIZE_T              TotalBytes
    )   PURE;

    STDMETHOD_(PVOID, MapAllocatedPages)
    (   THIS_
        IN      PMDL                    MemoryDescriptorList,
        IN      MEMORY_CACHING_TYPE     CacheType
    )   PURE;

    STDMETHOD_(VOID, UnmapAllocatedPages)
    (   THIS_
        IN      PVOID   BaseAddress,
        IN      PMDL    MemoryDescriptorList
    )   PURE;

    STDMETHOD_(VOID, FreePagesFromMdl)
    (   THIS_
        IN      PMDL    MemoryDescriptorList
    )   PURE;

    STDMETHOD_(ULONG, GetPhysicalPagesCount)
    (   THIS_
        IN      PMDL    MemoryDescriptorList
    )   PURE;

    STDMETHOD_(PHYSICAL_ADDRESS, GetPhysicalPageAddress)
    (   THIS_
        IN      PMDL    MemoryDescriptorList,
        IN      ULONG   Index
    )   PURE;
};

typedef IPortWaveRTStream *PPORTWAVERTSTREAM;

#ifdef PC_IMPLEMENTATION
#define IMP_IPortWaveRTStream\
    STDMETHODIMP_(PMDL) AllocatePagesForMdl\
    (\
        IN      PHYSICAL_ADDRESS    HighAddress,\
        IN      SIZE_T              TotalBytes\
    );\
    STDMETHODIMP_(PMDL) AllocateContiguousPagesForMdl\
    (\
        IN      PHYSICAL_ADDRESS    LowAddress,\
        IN      PHYSICAL_ADDRESS    HighAddress,\
        IN      SIZE_T              TotalBytes\
    );\
    STDMETHODIMP_(PVOID) MapAllocatedPages\
    (\
        IN      PMDL                    MemoryDescriptorList,\
        IN      MEMORY_CACHING_TYPE     CacheType\
    );\
    STDMETHODIMP_(VOID) UnmapAllocatedPages\
    (\
        IN      PVOID   BaseAddress,\
        IN      PMDL    MemoryDescriptorList\
    );\
    STDMETHODIMP_(VOID) FreePagesFromMdl\
    (\
        IN      PMDL    MemoryDescriptorList\
    );\
    STDMETHODIMP_(ULONG) GetPhysicalPagesCount\
    (\
        IN      PMDL    MemoryDescriptorList\
    );\
    STDMETHODIMP_(PHYSICAL_ADDRESS) GetPhysicalPageAddress\
    (\
        IN      PMDL    MemoryDescriptorList,\
        IN      ULONG   Index\
    )
#endif

/*****************************************************************************
 * IMiniportWaveRTStream
 *****************************************************************************
 * Interface for WaveRT miniport stream.
 */
DECLARE_INTERFACE_(IMiniportWaveRTStream,IUnknown)
{
    DEFINE_ABSTRACT_UNKNOWN()   //  For IUnknown
    DEFINE_ABSTRACT_MINIPORTWAVERTSTREAM()   //  For IMiniportWaveRTStream
};

typedef IMiniportWaveRTStream *PMINIPORTWAVERTSTREAM;

#define IMP_IMiniportWaveRTStream\
    STDMETHODIMP_(NTSTATUS) SetFormat\
    (   IN      PKSDATAFORMAT   DataFormat\
    );\
    STDMETHODIMP_(NTSTATUS) SetState\
    (   IN      KSSTATE         State\
    );\
    STDMETHODIMP_(NTSTATUS) GetPosition\
    (   OUT     PKSAUDIO_POSITION   Position\
    );\
    STDMETHODIMP_(NTSTATUS) AllocateAudioBuffer\
    (\
        IN      ULONG                   RequestedSize,\
        OUT     PMDL                    *AudioBufferMdl,\
        OUT     ULONG                   *ActualSize,\
        OUT     ULONG                   *OffsetFromFirstPage,\
        OUT     MEMORY_CACHING_TYPE     *CacheType\
    );\
    STDMETHODIMP_(VOID) FreeAudioBuffer\
    (\
        IN  PMDL                    AudioBufferMdl,\
        IN  ULONG                   BufferSize\
    );\
    STDMETHODIMP_(VOID) GetHWLatency\
    (\
        OUT KSRTAUDIO_HWLATENCY     *hwLatency\
    );\
    STDMETHODIMP_(NTSTATUS) GetPositionRegister\
    (\
        OUT KSRTAUDIO_HWREGISTER    *Register\
    );\
    STDMETHODIMP_(NTSTATUS) GetClockRegister\
    (\
        OUT KSRTAUDIO_HWREGISTER    *Register\
    )


/*****************************************************************************
 * IMiniportWaveRTStreamNotification
 *****************************************************************************
 * Interface for WaveRT miniport stream buffer notification extensions.
 */
DECLARE_INTERFACE_(IMiniportWaveRTStreamNotification,IMiniportWaveRTStream)
{
    DEFINE_ABSTRACT_UNKNOWN()   //  For IUnknown

    DEFINE_ABSTRACT_MINIPORTWAVERTSTREAM()  //  For IMiniportWaveRTStream

    STDMETHOD_(NTSTATUS,AllocateBufferWithNotification)
    (   THIS_
        IN      ULONG                   NotificationCount,
        IN      ULONG                   RequestedSize,
        OUT     PMDL                    *AudioBufferMdl,
        OUT     ULONG                   *ActualSize,
        OUT     ULONG                   *OffsetFromFirstPage,
        OUT     MEMORY_CACHING_TYPE     *CacheType
    )   PURE;

    STDMETHOD_(VOID,FreeBufferWithNotification)
    (   THIS_
        IN      PMDL            AudioBufferMdl,
        IN      ULONG           BufferSize
    )   PURE;

    STDMETHOD_(NTSTATUS,RegisterNotificationEvent)
    (   THIS_
        IN      PKEVENT         NotificationEvent
    )   PURE;

    STDMETHOD_(NTSTATUS,UnregisterNotificationEvent)
    (   THIS_
        IN      PKEVENT         NotificationEvent
    )   PURE;
};

typedef IMiniportWaveRTStreamNotification *PMINIPORTWAVERTSTREAMNOTIFICATION;

#define IMP_IMiniportWaveRTStreamNotification\
    STDMETHODIMP_(NTSTATUS) AllocateBufferWithNotification\
    (\
        IN      ULONG                   NotificationCount,\
        IN      ULONG                   RequestedSize,\
        OUT     PMDL                    *AudioBufferMdl,\
        OUT     ULONG                   *ActualSize,\
        OUT     ULONG                   *OffsetFromFirstPage,\
        OUT     MEMORY_CACHING_TYPE     *CacheType\
    );\
    STDMETHODIMP_(VOID) FreeBufferWithNotification\
    (\
        IN      PMDL                    AudioBufferMdl,\
        IN      ULONG                   BufferSize\
    );\
    STDMETHODIMP_(NTSTATUS) RegisterNotificationEvent\
    (\
        IN      PKEVENT                 NotificationEvent\
    );\
    STDMETHODIMP_(NTSTATUS) UnregisterNotificationEvent\
    (\
        IN      PKEVENT                 NotificationEvent\
    )

/*****************************************************************************
 * IMiniportWaveRT
 *****************************************************************************
 * Interface for WaveRT miniports.
 */
DECLARE_INTERFACE_(IMiniportWaveRT,IMiniport)
{
    DEFINE_ABSTRACT_UNKNOWN()   //  For IUnknown

    DEFINE_ABSTRACT_MINIPORT()  //  For IMiniport

    //  For IMiniportWaveRT
    STDMETHOD_(NTSTATUS,Init)
    (   THIS_
        IN      PUNKNOWN            UnknownAdapter,
        IN      PRESOURCELIST       ResourceList,
        IN      PPORTWAVERT             Port
    )   PURE;

    STDMETHOD_(NTSTATUS,NewStream)
    (   THIS_
        OUT     PMINIPORTWAVERTSTREAM *         Stream,
        IN      PPORTWAVERTSTREAM               PortStream,
        IN      ULONG                       Pin,
        IN      BOOLEAN                     Capture,
        IN      PKSDATAFORMAT               DataFormat
    )   PURE;

    STDMETHOD_(NTSTATUS,GetDeviceDescription)
    (   THIS_
        OUT     PDEVICE_DESCRIPTION     DeviceDescription
    )   PURE;
};

typedef IMiniportWaveRT *PMINIPORTWAVERT;

#define IMP_IMiniportWaveRT\
    IMP_IMiniport;\
    STDMETHODIMP_(NTSTATUS) Init\
    (   IN      PUNKNOWN            UnknownAdapter,\
        IN      PRESOURCELIST       ResourceList,\
        IN      PPORTWAVERT             Port\
    );\
    STDMETHODIMP_(NTSTATUS) NewStream\
    (   OUT     PMINIPORTWAVERTSTREAM *         Stream,\
        IN      PPORTWAVERTSTREAM               PortStream,\
        IN      ULONG                       Pin,\
        IN      BOOLEAN                     Capture,\
        IN      PKSDATAFORMAT               DataFormat\
    );\
    STDMETHODIMP_(NTSTATUS) GetDeviceDescription\
    (   OUT     PDEVICE_DESCRIPTION     DeviceDescription\
    )
#endif

/*****************************************************************************
 * IAdapterPowerManagement
 *****************************************************************************
 * An interface that adapters should implement and
 * register if they want power management messages.
 * Register this interface with PortCls via the
 * PcRegisterAdapterPowerManagement() call.
 *
 * NOTE: If you want to fill in the caps struct
 * for your device, register the interface
 * with PortCls in or before your AddDevice()
 * function. The OS queries devices before
 * StartDevice() gets called.
 */
DECLARE_INTERFACE_(IAdapterPowerManagement,IUnknown)
{
    DEFINE_ABSTRACT_UNKNOWN()   //  For IUnknown

    // Called by PortCls to tell the device
    // to change to the new power state.
    //
    STDMETHOD_(void,PowerChangeState)
    (   THIS_
        IN      POWER_STATE     NewState
    )   PURE;

    // Called by PortCls to ask whether the device
    // can change to the requested power state.
    //
    STDMETHOD_(NTSTATUS,QueryPowerChangeState)
    (   THIS_
        IN      POWER_STATE     NewStateQuery
    )   PURE;

    // Called by PortCls to get the power management
    // capabilities of the device. See ACPI documentation
    // for data about the DEVICE_CAPABILITIES struct.
    //
    STDMETHOD_(NTSTATUS,QueryDeviceCapabilities)
    (   THIS_
        IN      PDEVICE_CAPABILITIES    PowerDeviceCaps
    )   PURE;
};

typedef IAdapterPowerManagement *PADAPTERPOWERMANAGEMENT;

#define IMP_IAdapterPowerManagement\
    STDMETHODIMP_(void) PowerChangeState\
    (   IN      POWER_STATE     NewState\
    );\
    STDMETHODIMP_(NTSTATUS) QueryPowerChangeState\
    (   IN      POWER_STATE     NewStateQuery\
    );\
    STDMETHODIMP_(NTSTATUS) QueryDeviceCapabilities\
    (   IN      PDEVICE_CAPABILITIES    PowerDeviceCaps\
    )

/*****************************************************************************
 * IPowerNotify
 *****************************************************************************
 * An OPTIONAL interface for miniports and pins to implement to
 * enable them to get device power state change notifications.
 */
DECLARE_INTERFACE_(IPowerNotify,IUnknown)
{
    DEFINE_ABSTRACT_UNKNOWN()   //  For IUnknown

    // Called by the port to notify registered miniports
    // and pins of device power state changes, so that
    // appropriate context save/restore can take place.
    //
    STDMETHOD_(void,PowerChangeNotify)
    (   THIS_
        IN      POWER_STATE     PowerState
    )   PURE;
};

typedef IPowerNotify *PPOWERNOTIFY;

#define IMP_IPowerNotify\
    STDMETHODIMP_(void) PowerChangeNotify\
    (   IN  POWER_STATE     PowerState\
    )

#if (NTDDI_VERSION >= NTDDI_WINXP)
/*****************************************************************************
 * IPinCount
 *****************************************************************************
 * An OPTIONAL interface for miniports to implement to
 * enable them to get pin count queries, for dynamic pin counts.
 */
DECLARE_INTERFACE_(IPinCount,IUnknown)
{
    DEFINE_ABSTRACT_UNKNOWN()   //  For IUnknown

    // Called by the port to notify registered miniports
    // of pin count queries, so that appropriate pin
    // count manipulation can take place.
    //
    STDMETHOD_(void,PinCount)
    (   THIS_
        IN      ULONG   PinId,
        IN  OUT PULONG  FilterNecessary,
        IN  OUT PULONG  FilterCurrent,
        IN  OUT PULONG  FilterPossible,
        IN  OUT PULONG  GlobalCurrent,
        IN  OUT PULONG  GlobalPossible
    )   PURE;
};

typedef IPinCount *PPINCOUNT;

#define IMP_IPinCount                       \
    STDMETHODIMP_(void) PinCount            \
    (   IN      ULONG   PinId,              \
        IN  OUT PULONG  FilterNecessary,    \
        IN  OUT PULONG  FilterCurrent,      \
        IN  OUT PULONG  FilterPossible,     \
        IN  OUT PULONG  GlobalCurrent,      \
        IN  OUT PULONG  GlobalPossible      \
    )
#endif

/*****************************************************************************
 * IPortEvents
 *****************************************************************************
 * An interface implemented by ports to provide
 * notification event helpers to miniports.
 */
DECLARE_INTERFACE_(IPortEvents,IUnknown)
{
    DEFINE_ABSTRACT_UNKNOWN()   //  For IUnknown

    STDMETHOD_(void,AddEventToEventList)
    (   THIS_
        IN  PKSEVENT_ENTRY      EventEntry
    )   PURE;
    STDMETHOD_(void,GenerateEventList)
    (   THIS_
        IN  GUID*   Set     OPTIONAL,
        IN  ULONG   EventId,
        IN  BOOL    PinEvent,
        IN  ULONG   PinId,
        IN  BOOL    NodeEvent,
        IN  ULONG   NodeId
    )   PURE;
};

typedef IPortEvents *PPORTEVENTS;

#define IMP_IPortEvents\
    STDMETHODIMP_(void) AddEventToEventList\
    (   IN  PKSEVENT_ENTRY  EventEntry\
    );\
    STDMETHODIMP_(void) GenerateEventList\
    (   IN  GUID*   Set     OPTIONAL,\
        IN  ULONG   EventId,\
        IN  BOOL    PinEvent,\
        IN  ULONG   PinId,\
        IN  BOOL    NodeEvent,\
        IN  ULONG   NodeId\
    )

#if (NTDDI_VERSION >= NTDDI_WINXP)
/*****************************************************************************
 * IDrmPort
 *****************************************************************************
 * An optional interface implemented by ports
 * to provide DRM functionality to miniports.
 */
DECLARE_INTERFACE_(IDrmPort,IUnknown)
{
    DEFINE_ABSTRACT_UNKNOWN()   //  For IUnknown

    DEFINE_ABSTRACT_DRMPORT()   //  For IDrmPort
};

typedef IDrmPort *PDRMPORT;

#define IMP_IDrmPort\
    STDMETHODIMP_(NTSTATUS) CreateContentMixed          \
    (   IN  PULONG      paContentId,                    \
        IN  ULONG       cContentId,                     \
        OUT PULONG      pMixedContentId                 \
    );                                                  \
    STDMETHODIMP_(NTSTATUS) DestroyContent              \
    (   IN ULONG        ContentId                       \
    );                                                  \
    STDMETHODIMP_(NTSTATUS) ForwardContentToFileObject  \
    (   IN ULONG        ContentId,                      \
        IN PFILE_OBJECT FileObject                      \
    );                                                  \
    STDMETHODIMP_(NTSTATUS) ForwardContentToInterface   \
    (   IN ULONG        ContentId,                      \
        IN PUNKNOWN     pUnknown,                       \
        IN ULONG        NumMethods                      \
    );                                                  \
    STDMETHODIMP_(NTSTATUS) GetContentRights            \
    (   IN  ULONG       ContentId,                      \
        OUT PDRMRIGHTS  DrmRights                       \
    )

/*****************************************************************************
 * IDrmPort2
 *****************************************************************************
 * An optional interface implemented by ports
 * to provide DRM functionality to miniports.
 * This is identical to IDrmPort with the
 * addition of two new routines.
 */
DECLARE_INTERFACE_(IDrmPort2,IDrmPort)
{
    DEFINE_ABSTRACT_UNKNOWN()   //  For IUnknown

    DEFINE_ABSTRACT_DRMPORT()   //  For IDrmPort

    STDMETHOD_(NTSTATUS,AddContentHandlers)
    (   THIS_
        IN ULONG        ContentId,
        IN PVOID      * paHandlers,
        IN ULONG        NumHandlers
    )   PURE;
    STDMETHOD_(NTSTATUS,ForwardContentToDeviceObject)
    (   THIS_
        IN ULONG          ContentId,
        IN PVOID          Reserved,
        IN PCDRMFORWARD   DrmForward
    )   PURE;
};

typedef IDrmPort2 *PDRMPORT2;

#define IMP_IDrmPort2                                    \
    IMP_IDrmPort;                                        \
    STDMETHODIMP_(NTSTATUS) AddContentHandlers           \
    (   IN ULONG        ContentId,                       \
        IN PVOID      * paHandlers,                      \
        IN ULONG        NumHandlers                      \
    );                                                   \
    STDMETHODIMP_(NTSTATUS) ForwardContentToDeviceObject \
    (   IN ULONG          ContentId,                     \
        IN PVOID          Reserved,                      \
        IN PCDRMFORWARD   DrmForward                     \
    )

/*****************************************************************************
 * IPortClsVersion
 *****************************************************************************
 * What version of PortCls is this?
 */
DECLARE_INTERFACE_(IPortClsVersion,IUnknown)
{
    STDMETHOD_(DWORD,GetVersion)
    (   THIS
    )   PURE;
};

typedef IPortClsVersion *PPORTCLSVERSION;

// DO NOT ASSUME THAT EACH SUCCESSIVE ENUM IMPLIES A FEATURE SUPERSET!
// Example: Win2K has more audio features than Win98SE_QFE2.
//
enum
{
    kVersionInvalid = -1,

    kVersionWin98,        // IPortClsVersion is unsupported
    kVersionWin98SE,      // IPortClsVersion is unsupported
    kVersionWin2K,        // IPortClsVersion is unsupported

    kVersionWin98SE_QFE2, // IPortClsVersion is unsupported
                          // QFE Package 269601 (contains 242937 and 247565)

    kVersionWin2K_SP2,    // IPortClsVersion is supported

    kVersionWinME,        // IPortClsVersion is unsupported

    kVersionWin98SE_QFE3, // IPortClsVersion is supported
                          // QFE Package (not yet released, as of 6/15/2001)

    kVersionWinME_QFE1,   // IPortClsVersion is supported
                          // QFE Package (not yet released, as of 6/15/2001)

    kVersionWinXP,        // IPortClsVersion is supported
    kVersionWinXPSP1,     // IPortClsVersion is supported

    kVersionWinServer2003,// IPortClsVersion is supported

    kVersionWin2K_UAAQFE, // IPortClsVersion is supported
    kVersionWinXP_UAAQFE, // IPortClsVersion is supported
    kVersionWinServer2003_UAAQFE, // IPortClsVersion is supported

    kVersionWindowsLonghorn  // IPortClsVersion is supported

    // Additional enum values will be added here, in
    // *roughly* chronological (not feature set) order.
};

/*****************************************************************************
 * IDmaOperations
 *****************************************************************************
 * An interface implemented by the DMA object to provide operations on the
 * "DMA adapter" like HalAllocateCommonBuffer.
 */
DECLARE_INTERFACE_(IDmaOperations,IUnknown)
{
    DEFINE_ABSTRACT_UNKNOWN()   //  For IUnknown

    STDMETHOD_(PVOID,AllocateCommonBuffer)
    (   THIS_
        IN  ULONG               Length,
        OUT PPHYSICAL_ADDRESS   physAddr,
        IN  BOOLEAN             bCacheEnabled
    )   PURE;
};

typedef IDmaOperations *PDMAOPERATIONS;

#define IMP_IDmaOperations\
    STDMETHODIMP_(PVOID) AllocateCommonBuffer\
    (\
        IN  ULONG               Length,\
        OUT PPHYSICAL_ADDRESS   physAddr,\
        IN  BOOLEAN             bCacheEnabled\
    )

/*****************************************************************************
 * IPreFetchOffset
 *****************************************************************************
 * An interface implemented by the pin to implement prefetch characteristics
 * of bus master hardware - to specify the hardware queue size, determining
 * the pad between play cursor and write cursor.
 */
DECLARE_INTERFACE_(IPreFetchOffset,IUnknown)
{
    DEFINE_ABSTRACT_UNKNOWN()   //  For IUnknown

    STDMETHOD_(VOID,SetPreFetchOffset)
    (   THIS_
        IN  ULONG   PreFetchOffset
    )   PURE;
};

typedef IPreFetchOffset *PPREFETCHOFFSET;

#define IMP_IPreFetchOffset\
    STDMETHODIMP_(VOID) SetPreFetchOffset\
    (\
        IN  ULONG   PreFetchOffset\
    )
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2003)
/*****************************************************************************
 * IUnregisterSubdevice
 *****************************************************************************
 * An interface implemented by the port to implement a method to remove the
 * registered subdevice.
 */
DECLARE_INTERFACE_(IUnregisterSubdevice,IUnknown)
{
    DEFINE_ABSTRACT_UNKNOWN()   //  For IUnknown

    STDMETHOD_(NTSTATUS,UnregisterSubdevice)
    (   THIS_
        IN  PDEVICE_OBJECT  DeviceObject,
        IN  PUNKNOWN        Unknown
    )   PURE;
};

typedef IUnregisterSubdevice *PUNREGISTERSUBDEVICE;

#define IMP_IUnregisterSubdevice\
    STDMETHODIMP_(NTSTATUS) UnregisterSubdevice\
    (\
        IN  PDEVICE_OBJECT  DeviceObject,\
        IN  PUNKNOWN        Unknown\
    )

/*****************************************************************************
 * IUnregisterPhysicalConnection
 *****************************************************************************
 * An interface implemented by the port to implement a method to remove the
 * registered physical connections.
 */
DECLARE_INTERFACE_(IUnregisterPhysicalConnection,IUnknown)
{
    DEFINE_ABSTRACT_UNKNOWN()   //  For IUnknown

    STDMETHOD_(NTSTATUS,UnregisterPhysicalConnection)
    (   THIS_
        IN  PDEVICE_OBJECT  DeviceObject,
        IN  PUNKNOWN        FromUnknown,
        IN  ULONG           FromPin,
        IN  PUNKNOWN        ToUnknown,
        IN  ULONG           ToPin
    )   PURE;

    STDMETHOD_(NTSTATUS,UnregisterPhysicalConnectionToExternal)
    (   THIS_
        IN  PDEVICE_OBJECT  DeviceObject,
        IN  PUNKNOWN        FromUnknown,
        IN  ULONG           FromPin,
        IN  PUNICODE_STRING ToString,
        IN  ULONG           ToPin
    )   PURE;

    STDMETHOD_(NTSTATUS,UnregisterPhysicalConnectionFromExternal)
    (   THIS_
        IN  PDEVICE_OBJECT  DeviceObject,
        IN  PUNICODE_STRING FromString,
        IN  ULONG           FromPin,
        IN  PUNKNOWN        ToUnknown,
        IN  ULONG           ToPin
    )   PURE;
};

typedef IUnregisterPhysicalConnection *PUNREGISTERPHYSICALCONNECTION;

#define IMP_IUnregisterPhysicalConnection\
    STDMETHODIMP_(NTSTATUS) UnregisterPhysicalConnection\
    (\
        IN  PDEVICE_OBJECT  DeviceObject,\
        IN  PUNKNOWN        FromUnknown,\
        IN  ULONG           FromPin,\
        IN  PUNKNOWN        ToUnknown,\
        IN  ULONG           ToPin\
    );\
    STDMETHODIMP_(NTSTATUS) UnregisterPhysicalConnectionToExternal\
    (\
        IN  PDEVICE_OBJECT  DeviceObject,\
        IN  PUNKNOWN        FromUnknown,\
        IN  ULONG           FromPin,\
        IN  PUNICODE_STRING ToString,\
        IN  ULONG           ToPin\
    );\
    STDMETHODIMP_(NTSTATUS) UnregisterPhysicalConnectionFromExternal\
    (\
        IN  PDEVICE_OBJECT  DeviceObject,\
        IN  PUNICODE_STRING FromString,\
        IN  ULONG           FromPin,\
        IN  PUNKNOWN        ToUnknown,\
        IN  ULONG           ToPin\
    )
#endif

/*****************************************************************************
 * Functions.
 */

/*****************************************************************************
 * PCPFNSTARTDEVICE
 *****************************************************************************
 * Type for start device callback.
 */
typedef
NTSTATUS
(*PCPFNSTARTDEVICE)
(
#ifdef PC_OLD_NAMES
    IN      PVOID           DeviceObject,
    IN      PVOID           Irp,
#else
    IN      PDEVICE_OBJECT  DeviceObject,
    IN      PIRP            Irp,
#endif
    IN      PRESOURCELIST   ResourceList
);

#if (NTDDI_VERSION < NTDDI_WINXP)
/*****************************************************************************
 * PCPFNIRPHANDLER
 *****************************************************************************
 * Type for IRP handlers.
 */
typedef
NTSTATUS
(*PCPFNIRPHANDLER)
(
    IN      PDEVICE_OBJECT  DeviceObject,
    IN      PIRP            Irp,
    OUT     PULONG          Action
#define IRP_HANDLER_ACTION_DEFAULT 0
#define IRP_HANDLER_ACTION_FINISH  1
#define IRP_HANDLER_ACTION_FORWARD 2
);
#endif

/*****************************************************************************
 * PcInitializeAdapterDriver()
 *****************************************************************************
 * Initializes an adapter driver.
 */
PORTCLASSAPI
NTSTATUS
NTAPI
PcInitializeAdapterDriver
(
    IN      PDRIVER_OBJECT      DriverObject,
    IN      PUNICODE_STRING     RegistryPathName,
    IN      PDRIVER_ADD_DEVICE  AddDevice
);

/*****************************************************************************
 * PcDispatchIrp()
 *****************************************************************************
 * Dispatch an IRP.
 */
PORTCLASSAPI
NTSTATUS
NTAPI
PcDispatchIrp
(
    IN      PDEVICE_OBJECT  pDeviceObject,
    IN      PIRP            pIrp
);

/*****************************************************************************
 * PcAddAdapterDevice()
 *****************************************************************************
 * Adds an adapter device.  DeviceExtensionSize may be zero for default size.
 */
PORTCLASSAPI
NTSTATUS
NTAPI
PcAddAdapterDevice
(
    IN      PDRIVER_OBJECT      DriverObject,
    IN      PDEVICE_OBJECT      PhysicalDeviceObject,
    IN      PCPFNSTARTDEVICE    StartDevice,
    IN      ULONG               MaxObjects,
    IN      ULONG               DeviceExtensionSize
);

/*****************************************************************************
 * PcCompleteIrp()
 *****************************************************************************
 * Complete an IRP unless status is STATUS_PENDING.
 */
PORTCLASSAPI
NTSTATUS
NTAPI
PcCompleteIrp
(
    IN      PDEVICE_OBJECT  pDeviceObject,
    IN      PIRP            pIrp,
    IN      NTSTATUS        ntStatus
);

/*****************************************************************************
 * PcForwardIrpSynchronous()
 *****************************************************************************
 * Forward a PnP IRP to the PDO.  The IRP is not completed at this level,
 * this function does not return until the lower driver has completed the IRP,
 * and DecrementPendingIrpCount() is not called.
 */
PORTCLASSAPI
NTSTATUS
NTAPI
PcForwardIrpSynchronous
(
    IN      PDEVICE_OBJECT  DeviceObject,
    IN      PIRP            Irp
);

/*****************************************************************************
 * PcRegisterSubdevice()
 *****************************************************************************
 * Registers a subdevice.
 */
PORTCLASSAPI
NTSTATUS
NTAPI
PcRegisterSubdevice
(
    __in      PDEVICE_OBJECT  DeviceObject,
    __in      PWSTR           Name,
    __in      PUNKNOWN        Unknown
);

/*****************************************************************************
 * PcRegisterPhysicalConnection()
 *****************************************************************************
 * Registers a physical connection between subdevices.
 */
PORTCLASSAPI
NTSTATUS
NTAPI
PcRegisterPhysicalConnection
(
    IN      PDEVICE_OBJECT  DeviceObject,
    IN      PUNKNOWN        FromUnknown,
    IN      ULONG           FromPin,
    IN      PUNKNOWN        ToUnknown,
    IN      ULONG           ToPin
);

/*****************************************************************************
 * PcRegisterPhysicalConnectionToExternal()
 *****************************************************************************
 * Registers a physical connection from a subdevice to an external device.
 */
PORTCLASSAPI
NTSTATUS
NTAPI
PcRegisterPhysicalConnectionToExternal
(
    IN      PDEVICE_OBJECT  DeviceObject,
    IN      PUNKNOWN        FromUnknown,
    IN      ULONG           FromPin,
    IN      PUNICODE_STRING ToString,
    IN      ULONG           ToPin
);

/*****************************************************************************
 * PcRegisterPhysicalConnectionFromExternal()
 *****************************************************************************
 * Registers a physical connection to a subdevice from an external device.
 */
PORTCLASSAPI
NTSTATUS
NTAPI
PcRegisterPhysicalConnectionFromExternal
(
    IN      PDEVICE_OBJECT  DeviceObject,
    IN      PUNICODE_STRING FromString,
    IN      ULONG           FromPin,
    IN      PUNKNOWN        ToUnknown,
    IN      ULONG           ToPin
);

/*****************************************************************************
 * PcNewPort()
 *****************************************************************************
 * Creates an instance of a port driver.
 */
PORTCLASSAPI
NTSTATUS
NTAPI
PcNewPort
(
    OUT     PPORT *     OutPort,
    IN      REFCLSID    ClassID
);

/*****************************************************************************
 * PcNewMiniport()
 *****************************************************************************
 * Creates an instance of a system-supplied miniport driver.
 */
PORTCLASSAPI
NTSTATUS
NTAPI
PcNewMiniport
(
    OUT     PMINIPORT * OutMiniPort,
    IN      REFCLSID    ClassID
);

#if (NTDDI_VERSION >= NTDDI_WINXP)
/*****************************************************************************
 * PcNewDmaChannel()
 *****************************************************************************
 * Creates a DMA channel.
 */
PORTCLASSAPI
NTSTATUS
NTAPI
PcNewDmaChannel
(
    OUT     PDMACHANNEL *       OutDmaChannel,
    IN      PUNKNOWN            OuterUnknown        OPTIONAL,
    IN      POOL_TYPE           PoolType,
    IN      PDEVICE_DESCRIPTION DeviceDescription,
    IN      PDEVICE_OBJECT      DeviceObject
);
#endif

/*****************************************************************************
 * PcCompletePendingPropertyRequest()
 *****************************************************************************
 * Completes a pending property request.
 */
PORTCLASSAPI
NTSTATUS
NTAPI
PcCompletePendingPropertyRequest
(
    IN      PPCPROPERTY_REQUEST PropertyRequest,
    IN      NTSTATUS            NtStatus
);

/*****************************************************************************
 * PcGetTimeInterval
 *****************************************************************************
 * Gets the system time interval
 */
PORTCLASSAPI
ULONGLONG
NTAPI
PcGetTimeInterval
(
    IN  ULONGLONG   Since
);

#define GTI_SECONDS(t)      (ULONGLONG(t)*10000000)
#define GTI_MILLISECONDS(t) (ULONGLONG(t)*10000)
#define GTI_MICROSECONDS(t) (ULONGLONG(t)*10)

/*****************************************************************************
 * PcNewResourceList()
 *****************************************************************************
 * Creates and initializes a resource list.
 */
PORTCLASSAPI
NTSTATUS
NTAPI
PcNewResourceList
(
    OUT     PRESOURCELIST *     OutResourceList,
    IN      PUNKNOWN            OuterUnknown            OPTIONAL,
    IN      POOL_TYPE           PoolType,
    IN      PCM_RESOURCE_LIST   TranslatedResources,
    IN      PCM_RESOURCE_LIST   UntranslatedResources
);

/*****************************************************************************
 * PcNewResourceSublist()
 *****************************************************************************
 * Creates and initializes an empty resource list derived from another
 * resource list.
 */
PORTCLASSAPI
NTSTATUS
NTAPI
PcNewResourceSublist
(
    OUT     PRESOURCELIST *     OutResourceList,
    IN      PUNKNOWN            OuterUnknown            OPTIONAL,
    IN      POOL_TYPE           PoolType,
    IN      PRESOURCELIST       ParentList,
    IN      ULONG               MaximumEntries
);

/*****************************************************************************
 * PcNewInterruptSync()
 *****************************************************************************
 * Creates and initializes an interrupt-level synchronization object.
 */
PORTCLASSAPI
NTSTATUS
NTAPI
PcNewInterruptSync
(
    OUT     PINTERRUPTSYNC *        OutInterruptSync,
    IN      PUNKNOWN                OuterUnknown            OPTIONAL,
    IN      PRESOURCELIST           ResourceList,
    IN      ULONG                   ResourceIndex,
    IN      INTERRUPTSYNCMODE       Mode
);

/*****************************************************************************
 * PcNewServiceGroup()
 *****************************************************************************
 * Creates and initializes a service group object.
 */
PORTCLASSAPI
NTSTATUS
NTAPI
PcNewServiceGroup
(
    OUT     PSERVICEGROUP *     OutServiceGroup,
    IN      PUNKNOWN            OuterUnknown            OPTIONAL
);

/*****************************************************************************
 * PcNewRegistryKey()
 *****************************************************************************
 * Creates and initializes a registry key object.
 */
PORTCLASSAPI
NTSTATUS
NTAPI
PcNewRegistryKey
(
    OUT     PREGISTRYKEY *      OutRegistryKey,
    IN      PUNKNOWN            OuterUnknown        OPTIONAL,
    IN      ULONG               RegistryKeyType,
    IN      ACCESS_MASK         DesiredAccess,
    IN      PVOID               DeviceObject        OPTIONAL,
    IN      PVOID               SubDevice           OPTIONAL,
    IN      POBJECT_ATTRIBUTES  ObjectAttributes    OPTIONAL,
    IN      ULONG               CreateOptions       OPTIONAL,
    OUT     PULONG              Disposition         OPTIONAL
);

/*****************************************************************************
 * RegistryKeyType for NewRegistryKey()
 *****************************************************************************
 * Enumeration of key types.
 */
enum
{
    GeneralRegistryKey,     // ObjectAttributes and CreateOptions are req'd.
    DeviceRegistryKey,      // Device Object is required
    DriverRegistryKey,      // Device Object is required
    HwProfileRegistryKey,   // Device Object is required
    DeviceInterfaceRegistryKey  // Device Object and SubDevice are required
};

/*****************************************************************************
 * PcGetDeviceProperty()
 *****************************************************************************
 * This returns the requested device property from the registry.
 */
PORTCLASSAPI
NTSTATUS
NTAPI
PcGetDeviceProperty
(
    IN      PVOID                       DeviceObject,
    IN      DEVICE_REGISTRY_PROPERTY    DeviceProperty,
    IN      ULONG                       BufferLength,
    OUT     PVOID                       PropertyBuffer,
    OUT     PULONG                      ResultLength
);

/*****************************************************************************
 * PcRegisterAdapterPowerManagement()
 *****************************************************************************
 * Register the adapter's power management interface with PortCls.
 */
PORTCLASSAPI
NTSTATUS
NTAPI
PcRegisterAdapterPowerManagement
(
    IN      PUNKNOWN    Unknown,
    IN      PVOID       pvContext1
);

/*****************************************************************************
 * PcRequestNewPowerState()
 *****************************************************************************
 * This routine is used to request a new power state for the device.  It is
 * normally not needed by adapter drivers but is exported in order to
 * support unusual circumstances.
 */
PORTCLASSAPI
NTSTATUS
NTAPI
PcRequestNewPowerState
(
    IN      PDEVICE_OBJECT      pDeviceObject,
    IN      DEVICE_POWER_STATE  RequestedNewState
);

/*****************************************************************************
 * PcRegisterIoTimeout()
 *****************************************************************************
 * This routine registers a driver-supplied callback associated with a given
 * device object (see IoInitializeTimer in the DDK).  This callback that will
 * be called approximately once per second while the device is active (see
 * IoStartTimer, and IoStopTimer in the DDK - these are called upon device
 * START and STOP).
 *
 * This routine must be called at PASSIVE_LEVEL.
 * pTimerRoutine can and will be called at DISPATCH_LEVEL; it must be non-paged.
 *
 */
PORTCLASSAPI
NTSTATUS
NTAPI
PcRegisterIoTimeout
(
    IN      PDEVICE_OBJECT      pDeviceObject,
    IN      PIO_TIMER_ROUTINE   pTimerRoutine,
    IN      PVOID               pContext
);

/*****************************************************************************
 * PcUnregisterIoTimeout()
 *****************************************************************************
 * This routine unregisters a driver-supplied callback associated with a given
 * device object.  This callback must have been previously registered with
 * PcRegisterIoTimeout (with the same device object, timer routine and context).
 *
 * This routine must be called at PASSIVE_LEVEL.
 * pTimerRoutine can and will be called at DISPATCH_LEVEL; it must be non-paged.
 *
 */
PORTCLASSAPI
NTSTATUS
NTAPI
PcUnregisterIoTimeout
(
    IN      PDEVICE_OBJECT      pDeviceObject,
    IN      PIO_TIMER_ROUTINE   pTimerRoutine,
    IN      PVOID               pContext
);


#if (NTDDI_VERSION >= NTDDI_WINXP)
/*****************************************************************************
 * Pc DRM functions
 *****************************************************************************
 * These functions link directly to the kernel-mode Digital Rights Management
 * module.  They all must be called at PASSIVE_LEVEL.
 */
PORTCLASSAPI
NTSTATUS
NTAPI
PcAddContentHandlers
(
    IN      ULONG           ContentId,
    IN      PVOID         * paHandlers,
    IN      ULONG           NumHandlers
);

PORTCLASSAPI
NTSTATUS
NTAPI
PcCreateContentMixed
(
    IN      PULONG          paContentId,
    IN      ULONG           cContentId,
    OUT     PULONG          pMixedContentId
);

PORTCLASSAPI
NTSTATUS
NTAPI
PcDestroyContent
(
    IN      ULONG           ContentId
);

PORTCLASSAPI
NTSTATUS
NTAPI
PcForwardContentToDeviceObject
(
    IN      ULONG           ContentId,
    IN      PVOID           Reserved,
    IN      PCDRMFORWARD    DrmForward
);

PORTCLASSAPI
NTSTATUS
NTAPI
PcForwardContentToFileObject
(
    IN      ULONG           ContentId,
    IN      PFILE_OBJECT    FileObject
);

PORTCLASSAPI
NTSTATUS
NTAPI
PcForwardContentToInterface
(
    IN      ULONG           ContentId,
    IN      PUNKNOWN        pUnknown,
    IN      ULONG           NumMethods
);

PORTCLASSAPI
NTSTATUS
NTAPI
PcGetContentRights
(
    IN      ULONG           ContentId,
    OUT     PDRMRIGHTS      DrmRights
);
#endif

#ifdef PC_OLD_NAMES

#define InitializeAdapterDriver(c1,c2,a)        \
    PcInitializeAdapterDriver(PDRIVER_OBJECT(c1),PUNICODE_STRING(c2),PDRIVER_ADD_DEVICE(a))
#define AddAdapterDevice(c1,c2,s,m)             \
    PcAddAdapterDevice(PDRIVER_OBJECT(c1),PDEVICE_OBJECT(c2),s,m,0)
#define RegisterSubdevice(c1,c2,n,u)            \
    PcRegisterSubdevice(PDEVICE_OBJECT(c1),n,u)
#define RegisterPhysicalConnection(c1,c2,fs,fp,ts,tp) \
    PcRegisterPhysicalConnection(PDEVICE_OBJECT(c1),fs,fp,ts,tp)
#define RegisterPhysicalConnectionToExternal(c1,c2,fs,fp,ts,tp) \
    PcRegisterPhysicalConnectionToExternal(PDEVICE_OBJECT(c1),fs,fp,ts,tp)
#define RegisterPhysicalConnectionFromExternal(c1,c2,fs,fp,ts,tp) \
    PcRegisterPhysicalConnectionFromExternal(PDEVICE_OBJECT(c1),fs,fp,ts,tp)

#define NewPort                                 PcNewPort
#define NewMiniport                             PcNewMiniport
#define CompletePendingPropertyRequest          PcCompletePendingPropertyRequest

#if (NTDDI_VERSION < NTDDI_WINXP)
#define NewIrpStreamVirtual                     PcNewIrpStreamVirtual
#define NewIrpStreamPhysical                    PcNewIrpStreamPhysical
#endif

#define NewResourceList                         PcNewResourceList
#define NewResourceSublist                      PcNewResourceSublist
#define NewDmaChannel                           PcNewDmaChannel
#define NewServiceGroup                         PcNewServiceGroup
#define GetTimeInterval                         PcGetTimeInterval

#define WIN95COMPAT_ReadPortUChar(Port)         READ_PORT_UCHAR(Port)
#define WIN95COMPAT_WritePortUChar(Port,Value)  WRITE_PORT_UCHAR(Port,Value)
#define WIN95COMPAT_ReadPortUShort(Port)        READ_PORT_USHORT(Port)
#define WIN95COMPAT_WritePortUShort(Port,Value) WRITE_PORT_USHORT(Port,Value)

#endif  //PC_OLD_NAMES



#endif //_PORTCLS_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\punknown.h ===
/*****************************************************************************
 * punknown.h - IUnknown definitions
 *****************************************************************************
 * Copyright (c) Microsoft Corporation. All rights reserved.
 */

#ifndef _UNKNOWN_H_
#define _UNKNOWN_H_

#ifdef __cplusplus
extern "C" {
#include <wdm.h>
}
#else
#include <wdm.h>
#endif

#include <windef.h>
#define COM_NO_WINDOWS_H
#include <basetyps.h>
#ifdef PUT_GUIDS_HERE
#include <initguid.h>
#endif


DEFINE_GUID(IID_IUnknown,
0x00000000, 0x0000, 0x0000, 0x00, 0x00, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x46);

/*****************************************************************************
 * IUnknown
 *****************************************************************************
 * Base interface for otherwise unknown objects.
 */
#undef INTERFACE
#define INTERFACE IUnknown
DECLARE_INTERFACE(IUnknown)
{
    STDMETHOD_(NTSTATUS,QueryInterface)
    (   THIS_
        IN      REFIID,
        OUT     PVOID *
    )   PURE;

    STDMETHOD_(ULONG,AddRef)
    (   THIS
    )   PURE;

    STDMETHOD_(ULONG,Release)
    (   THIS
    )   PURE;
};
#undef INTERFACE

typedef IUnknown *PUNKNOWN;

/*****************************************************************************
 * PFNCREATEINSTANCE
 *****************************************************************************
 * Type for object create function.
 */
typedef
HRESULT
(*PFNCREATEINSTANCE)
(
    OUT PUNKNOWN *  Unknown,
    IN  REFCLSID    ClassId,
    IN  PUNKNOWN    OuterUnknown,
    IN  POOL_TYPE   PoolType
);





#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\rx.h ===
#if !defined(NTDDI_VERSION)

#error NTDDI_VERSION must be defined to include this file.

#elif (NTDDI_VERSION >= NTDDI_VISTA)

/*++ BUILD Version: 0009    // Increment this if a change has global effects
Copyright (c) 1987-1993  Microsoft Corporation

Module Name:

    rx.h

Abstract:

    This module is the overall h-file-wrapper for RDBSS.

Revision History:
Notes:


--*/

#ifndef _RX_H_
#define _RX_H_

#include "rxovride.h"   //  common compile environment
#include "ntifs.h"      //  NT file system driver include file.

#ifdef RX_PRIVATE_BUILD

//
//  no one should be using these
//

#ifdef IoGetTopLevelIrp
#error  IoGetTopLevelIrp is deffed
#else
#define IoGetTopLevelIrp() IoxxxxxxGetTopLevelIrp()
#endif
#ifdef IoSetTopLevelIrp
#error  IoSetTopLevelIrp is deffed
#else
#define IoSetTopLevelIrp(irp) IoxxxxxxSetTopLevelIrp(irp)
#endif
#endif //  ifdef RX_PRIVATE_BUILD


//
//  These macros sugarcoat flag manipulation just a bit
//

#ifndef BooleanFlagOn
#define BooleanFlagOn(Flags,SingleFlag) ((BOOLEAN)((((Flags) & (SingleFlag)) != 0)))
#endif

#ifndef SetFlag
#define SetFlag(Flags,SetOfFlags) { \
    (Flags) |= (SetOfFlags);        \
}
#endif

#ifndef FlagOn

//
//  This macro returns TRUE if a flag in a set of flags is on and FALSE
//  otherwise
//

#define FlagOn(Flags,SingleFlag)        ((Flags) & (SingleFlag))
#endif

#ifndef ClearFlag
#define ClearFlag(Flags,SetOfFlags) { \
    (Flags) &= ~(SetOfFlags);         \
}
#endif

#define Add2Ptr(P,I) ((PVOID)((PUCHAR)(P) + (I)))

//
//  define INLINE to be the appropriate keyword for ANSI C
//

#define INLINE __inline

#include "rxtypes.h"

#ifndef MINIRDR__NAME
#include "rxpooltg.h"   //  RX pool tag macros
#endif

#include "ntrxdef.h"
#include "rxce.h"       //  RxCe functions
#include "rxcehdlr.h"   //  RxCe event handler specifications
#include "fcbtable.h"   //  FCB table data structures
#include "midatlax.h"   //  mid atlas structures
#include "mrxfcb.h"
#include "namcache.h"   //  structs and func defs for name cache routines
#include "rxworkq.h"
#include "rxprocs.h"
#include "rxexcept.h"

#ifndef MINIRDR__NAME
#include "rxdata.h"
#include "buffring.h"
#endif

#define MAKE_RESOURCE_OWNER(X) (((ERESOURCE_THREAD)(X)) | 0x3)
#define RESOURCE_OWNER_SET(X) (((X) & 0x3) == 0x3)

#endif // #ifdef _RX_H_

#elif (NTDDI_VERSION >= NTDDI_WS03)

/*++ BUILD Version: 0009    // Increment this if a change has global effects
Copyright (c) 1987-1993  Microsoft Corporation

Module Name:

    rx.h

Abstract:

    This module is the overall h-file-wrapper for RDBSS.

Revision History:
Notes:


--*/

#ifndef _RX_H_
#define _RX_H_

#include "rxovride.h"   //  common compile environment
#include "ntifs.h"      //  NT file system driver include file.

#ifdef RX_PRIVATE_BUILD

//
//  no one should be using these
//

#ifdef IoGetTopLevelIrp
#error  IoGetTopLevelIrp is deffed
#else
#define IoGetTopLevelIrp() IoxxxxxxGetTopLevelIrp()
#endif
#ifdef IoSetTopLevelIrp
#error  IoSetTopLevelIrp is deffed
#else
#define IoSetTopLevelIrp(irp) IoxxxxxxSetTopLevelIrp(irp)
#endif
#endif //  ifdef RX_PRIVATE_BUILD


//
//  These macros sugarcoat flag manipulation just a bit
//

#ifndef BooleanFlagOn
#define BooleanFlagOn(Flags,SingleFlag) ((BOOLEAN)((((Flags) & (SingleFlag)) != 0)))
#endif

#ifndef SetFlag
#define SetFlag(Flags,SetOfFlags) { \
    (Flags) |= (SetOfFlags);        \
}
#endif

#ifndef FlagOn

//
//  This macro returns TRUE if a flag in a set of flags is on and FALSE
//  otherwise
//

#define FlagOn(Flags,SingleFlag)        ((Flags) & (SingleFlag))
#endif

#ifndef ClearFlag
#define ClearFlag(Flags,SetOfFlags) { \
    (Flags) &= ~(SetOfFlags);         \
}
#endif

#define Add2Ptr(P,I) ((PVOID)((PUCHAR)(P) + (I)))

//
//  define INLINE to be the appropriate keyword for ANSI C
//

#define INLINE __inline

#include "rxtypes.h"

#ifndef MINIRDR__NAME
#include "rxpooltg.h"   //  RX pool tag macros
#endif

#include "ntrxdef.h"
#include "rxce.h"       //  RxCe functions
#include "rxcehdlr.h"   //  RxCe event handler specifications
#include "fcbtable.h"   //  FCB table data structures
#include "midatlax.h"   //  mid atlas structures
#include "mrxfcb.h"
#include "namcache.h"   //  structs and func defs for name cache routines
#include "rxworkq.h"
#include "rxprocs.h"
#include "rxexcept.h"

#ifndef MINIRDR__NAME
#include "rxdata.h"
#include "buffring.h"
#endif

#define MAKE_RESOURCE_OWNER(X) (((ERESOURCE_THREAD)(X)) | 0x3)
#define RESOURCE_OWNER_SET(X) (((X) & 0x3) == 0x3)

#endif // #ifdef _RX_H_


#elif (NTDDI_VERSION >= NTDDI_WINXP)

/*++ BUILD Version: 0009    // Increment this if a change has global effects
Copyright (c) 1987-1993  Microsoft Corporation

Module Name:

    rx.h

Abstract:

    This module is the overall h-file-wrapper for RDBSS.

Revision History:
Notes:


--*/

#ifndef _RX_H_
#define _RX_H_

#include "rxovride.h"   // common compile environment
#include "ntifs.h"      // NT file system driver include file.

#ifdef RX_PRIVATE_BUILD
//no one should be using these
#ifdef IoGetTopLevelIrp
#error  IoGetTopLevelIrp is deffed
#else
#define IoGetTopLevelIrp() IoxxxxxxGetTopLevelIrp()
#endif
#ifdef IoSetTopLevelIrp
#error  IoSetTopLevelIrp is deffed
#else
#define IoSetTopLevelIrp(irp) IoxxxxxxSetTopLevelIrp(irp)
#endif
#endif //ifdef RX_PRIVATE_BUILD


//
//  These macros sugarcoat flag manipulation just a bit
//

#ifndef BooleanFlagOn
#define BooleanFlagOn(Flags,SingleFlag) ((BOOLEAN)((((Flags) & (SingleFlag)) != 0)))
#endif

#ifndef SetFlag
#define SetFlag(Flags,SetOfFlags) { \
    (Flags) |= (SetOfFlags);        \
}
#endif

#ifndef FlagOn
//
//  This macro returns TRUE if a flag in a set of flags is on and FALSE
//  otherwise
//

#define FlagOn(Flags,SingleFlag)        ((Flags) & (SingleFlag))
#endif

#ifndef ClearFlag
#define ClearFlag(Flags,SetOfFlags) { \
    (Flags) &= ~(SetOfFlags);         \
}
#endif

// define INLINE to be the appropriate keyword for ANSI C
#define INLINE __inline

#include "rxtypes.h"

#ifndef MINIRDR__NAME
#include "rxpooltg.h"   // RX pool tag macros
#endif

#include "ntrxdef.h"
#include "rxce.h"       // RxCe functions
#include "rxcehdlr.h"   // RxCe event handler specifications
#include "fcbtable.h"   // FCB table data structures
#include "midatlax.h"   // mid atlas structures
#include "mrxfcb.h"
#include "namcache.h"   // structs and func defs for name cache routines
#include "rxworkq.h"
#include "rxprocs.h"
#include "rxexcept.h"

#ifndef MINIRDR__NAME
#include "rxdata.h"
#include "rxcommon.h"
#include "buffring.h"
#endif

//
// MAKE_RESOURCE_OWNER OR's a pointer with 0x3 as required by the
// Executive in order to use ExSetResourceOwnerPointer.
//
#define MAKE_RESOURCE_OWNER(X) (((ERESOURCE_THREAD)(X)) | 0x3)
#define RESOURCE_OWNER_SET(X) (((X) & 0x3) == 0x3)

#endif // #ifdef _RX_H_


#elif (NTDDI_VERSION >= NTDDI_WIN2K)

/*--
Copyright (c) 1987-1993  Microsoft Corporation

Module Name:

    rx.h

Abstract:

    This module is the overall h-file-wrapper for RDBSS.

--*/

#ifndef _RX_H_
#define _RX_H_

#include "rxovride.h"   // common compile environment
#include "ntifs.h"      // NT file system driver include file.

#ifdef RX_PRIVATE_BUILD
//no one should be using these
#ifdef IoGetTopLevelIrp
#error  IoGetTopLevelIrp is deffed
#else
#define IoGetTopLevelIrp() IoxxxxxxGetTopLevelIrp()
#endif
#ifdef IoSetTopLevelIrp
#error  IoSetTopLevelIrp is deffed
#else
#define IoSetTopLevelIrp(irp) IoxxxxxxSetTopLevelIrp(irp)
#endif
#endif //ifdef RX_PRIVATE_BUILD


//
//  These macros sugarcoat flag manipulation just a bit
//

#define BooleanFlagOn(Flags,SingleFlag) ((BOOLEAN)((((Flags) & (SingleFlag)) != 0)))

#define SetFlag(Flags,SetOfFlags) { \
    (Flags) |= (SetOfFlags);        \
}

#ifndef FlagOn
//
//  This macro returns TRUE if a flag in a set of flags is on and FALSE
//  otherwise
//

#define FlagOn(Flags,SingleFlag)        ((Flags) & (SingleFlag))
#endif

#define ClearFlag(Flags,SetOfFlags) { \
    (Flags) &= ~(SetOfFlags);         \
}

// define INLINE to be the appropriate keyword for ANSI C
#define INLINE __inline

#include "rxtypes.h"

#ifndef MINIRDR__NAME
#include "rxpooltg.h"   // RX pool tag macros
#endif

#include "ntrxdef.h"
#include "rxce.h"       // RxCe functions
#include "rxcehdlr.h"   // RxCe event handler specifications
#include "fcbtable.h"   // FCB table data structures
#include "midatlax.h"   // mid atlas structures
#include "mrxfcb.h"
#include "namcache.h"   // structs and func defs for name cache routines
#include "rxworkq.h"
#include "rxprocs.h"
#include "rxexcept.h"

#ifndef MINIRDR__NAME
#include "rxdata.h"
#include "rxcommon.h"
#include "buffring.h"
#endif

#endif // #ifdef _RX_H_


#else /* NTDDI_VERSION */

#error This file cannot be included for this NTDDI_VERSION.

#endif /* NTDDI_VERSION */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\richedit.h ===
/*
 *	RICHEDIT.H
 *	
 *	Purpose:
 *		RICHEDIT v2.0/3.0/4.0 public definitions
 *		functionality available for v2.0 and 3.0 that is not in the original
 *		Windows 95 release.
 *	
 *	Copyright (c) Microsoft Corporation. All rights reserved.
 */

#ifndef _RICHEDIT_
#define	_RICHEDIT_
#pragma once

#ifdef _WIN32
#include <pshpack4.h>
#elif !defined(RC_INVOKED)
#pragma pack(4)
#endif

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

// To mimic older RichEdit behavior, set _RICHEDIT_VER to appropriate value
//		Version 1.0		0x0100	
//		Version 2.0		0x0200	
//		Version 2.1		0x0210	
#ifndef _RICHEDIT_VER
#define _RICHEDIT_VER	0x0300
#endif

#define cchTextLimitDefault 32767

#define MSFTEDIT_CLASS		L"RICHEDIT50W"
// NOTE:  MSFTEDIT.DLL only registers MSFTEDIT_CLASS.  If an application wants
// to use the following Richedit classes, it needs to load the riched20.dll.
// Otherwise, CreateWindow with RICHEDIT_CLASS would fail.
// This also applies to any dialog that uses RICHEDIT_CLASS, 

// RichEdit 2.0 Window Class 
// On Windows CE, avoid possible conflicts on Win95
#define CERICHEDIT_CLASSA	"RichEditCEA"
#define CERICHEDIT_CLASSW	L"RichEditCEW"

#define RICHEDIT_CLASSA		"RichEdit20A"
#define RICHEDIT_CLASS10A	"RICHEDIT"			// Richedit 1.0

#ifndef MACPORT
#define RICHEDIT_CLASSW		L"RichEdit20W"
#else	//----------------------MACPORT 
#define RICHEDIT_CLASSW		TEXT("RichEdit20W")	// MACPORT change 
#endif // MACPORT  

#if (_RICHEDIT_VER >= 0x0200 )
#ifdef UNICODE
#define RICHEDIT_CLASS		RICHEDIT_CLASSW
#else
#define RICHEDIT_CLASS		RICHEDIT_CLASSA
#endif // UNICODE 
#else
#define RICHEDIT_CLASS		RICHEDIT_CLASS10A
#endif // _RICHEDIT_VER >= 0x0200 

// RichEdit messages 

#ifndef WM_CONTEXTMENU
#define WM_CONTEXTMENU			0x007B
#endif

#ifndef WM_UNICHAR
#define WM_UNICHAR				0x0109
#endif

#ifndef WM_PRINTCLIENT
#define WM_PRINTCLIENT			0x0318
#endif

#ifndef EM_GETLIMITTEXT
#define EM_GETLIMITTEXT			(WM_USER + 37)
#endif

#ifndef EM_POSFROMCHAR	
#define EM_POSFROMCHAR			(WM_USER + 38)
#define EM_CHARFROMPOS			(WM_USER + 39)
#endif

#ifndef EM_SCROLLCARET
#define EM_SCROLLCARET			(WM_USER + 49)
#endif
#define EM_CANPASTE				(WM_USER + 50)
#define EM_DISPLAYBAND			(WM_USER + 51)
#define EM_EXGETSEL				(WM_USER + 52)
#define EM_EXLIMITTEXT			(WM_USER + 53)
#define EM_EXLINEFROMCHAR		(WM_USER + 54)
#define EM_EXSETSEL				(WM_USER + 55)
#define EM_FINDTEXT				(WM_USER + 56)
#define EM_FORMATRANGE			(WM_USER + 57)
#define EM_GETCHARFORMAT		(WM_USER + 58)
#define EM_GETEVENTMASK			(WM_USER + 59)
#define EM_GETOLEINTERFACE		(WM_USER + 60)
#define EM_GETPARAFORMAT		(WM_USER + 61)
#define EM_GETSELTEXT			(WM_USER + 62)
#define EM_HIDESELECTION		(WM_USER + 63)
#define EM_PASTESPECIAL			(WM_USER + 64)
#define EM_REQUESTRESIZE		(WM_USER + 65)
#define EM_SELECTIONTYPE		(WM_USER + 66)
#define EM_SETBKGNDCOLOR		(WM_USER + 67)
#define EM_SETCHARFORMAT		(WM_USER + 68)
#define EM_SETEVENTMASK			(WM_USER + 69)
#define EM_SETOLECALLBACK		(WM_USER + 70)
#define EM_SETPARAFORMAT		(WM_USER + 71)
#define EM_SETTARGETDEVICE		(WM_USER + 72)
#define EM_STREAMIN				(WM_USER + 73)
#define EM_STREAMOUT			(WM_USER + 74)
#define EM_GETTEXTRANGE			(WM_USER + 75)
#define EM_FINDWORDBREAK		(WM_USER + 76)
#define EM_SETOPTIONS			(WM_USER + 77)
#define EM_GETOPTIONS			(WM_USER + 78)
#define EM_FINDTEXTEX			(WM_USER + 79)
#ifdef _WIN32
#define EM_GETWORDBREAKPROCEX	(WM_USER + 80)
#define EM_SETWORDBREAKPROCEX	(WM_USER + 81)
#endif

// RichEdit 2.0 messages 
#define	EM_SETUNDOLIMIT			(WM_USER + 82)
#define EM_REDO					(WM_USER + 84)
#define EM_CANREDO				(WM_USER + 85)
#define EM_GETUNDONAME			(WM_USER + 86)
#define EM_GETREDONAME			(WM_USER + 87)
#define EM_STOPGROUPTYPING		(WM_USER + 88)

#define EM_SETTEXTMODE			(WM_USER + 89)
#define EM_GETTEXTMODE			(WM_USER + 90)

// enum for use with EM_GET/SETTEXTMODE 
typedef enum tagTextMode
{
	TM_PLAINTEXT			= 1,
	TM_RICHTEXT				= 2,	// Default behavior 
	TM_SINGLELEVELUNDO		= 4,
	TM_MULTILEVELUNDO		= 8,	// Default behavior 
	TM_SINGLECODEPAGE		= 16,
	TM_MULTICODEPAGE		= 32	// Default behavior 
} TEXTMODE;

#define EM_AUTOURLDETECT		(WM_USER + 91)
#define EM_GETAUTOURLDETECT		(WM_USER + 92)
#define EM_SETPALETTE			(WM_USER + 93)
#define EM_GETTEXTEX			(WM_USER + 94)
#define EM_GETTEXTLENGTHEX		(WM_USER + 95)
#define EM_SHOWSCROLLBAR		(WM_USER + 96)
#define EM_SETTEXTEX			(WM_USER + 97)

// East Asia specific messages 
#define EM_SETPUNCTUATION		(WM_USER + 100)
#define EM_GETPUNCTUATION		(WM_USER + 101)
#define EM_SETWORDWRAPMODE		(WM_USER + 102)
#define EM_GETWORDWRAPMODE		(WM_USER + 103)
#define EM_SETIMECOLOR			(WM_USER + 104)
#define EM_GETIMECOLOR			(WM_USER + 105)
#define EM_SETIMEOPTIONS		(WM_USER + 106)
#define EM_GETIMEOPTIONS		(WM_USER + 107)
#define EM_CONVPOSITION 		(WM_USER + 108)

#define EM_SETLANGOPTIONS		(WM_USER + 120)
#define EM_GETLANGOPTIONS		(WM_USER + 121)
#define EM_GETIMECOMPMODE		(WM_USER + 122)

#define EM_FINDTEXTW			(WM_USER + 123)
#define EM_FINDTEXTEXW			(WM_USER + 124)

// RE3.0 FE messages 
#define EM_RECONVERSION			(WM_USER + 125)
#define EM_SETIMEMODEBIAS		(WM_USER + 126)	
#define EM_GETIMEMODEBIAS		(WM_USER + 127)

// BiDi specific messages 
#define EM_SETBIDIOPTIONS		(WM_USER + 200)
#define EM_GETBIDIOPTIONS		(WM_USER + 201)

#define EM_SETTYPOGRAPHYOPTIONS	(WM_USER + 202)
#define EM_GETTYPOGRAPHYOPTIONS	(WM_USER + 203)

// Extended edit style specific messages 
#define EM_SETEDITSTYLE			(WM_USER + 204)
#define EM_GETEDITSTYLE			(WM_USER + 205)

// Extended edit style masks 
#define	SES_EMULATESYSEDIT		1
#define SES_BEEPONMAXTEXT		2
#define	SES_EXTENDBACKCOLOR		4
#define SES_MAPCPS			8	// (obsolete)
#define SES_EMULATE10			16	// (obsolete)
#define	SES_USECRLF			32	// (obsolete)
#define SES_NOXLTSYMBOLRANGE		32
#define SES_USEAIMM			64
#define SES_NOIME			128

#define SES_ALLOWBEEPS			256
#define SES_UPPERCASE			512
#define	SES_LOWERCASE			1024
#define SES_NOINPUTSEQUENCECHK	2048
#define SES_BIDI				4096
#define SES_SCROLLONKILLFOCUS	8192
#define	SES_XLTCRCRLFTOCR		16384
#define SES_DRAFTMODE			32768

#define	SES_USECTF				0x0010000
#define SES_HIDEGRIDLINES		0x0020000
#define SES_USEATFONT			0x0040000
#define SES_CUSTOMLOOK			0x0080000
#define SES_LBSCROLLNOTIFY		0x0100000
#define SES_CTFALLOWEMBED		0x0200000
#define SES_CTFALLOWSMARTTAG	0x0400000
#define SES_CTFALLOWPROOFING	0x0800000

// Options for EM_SETLANGOPTIONS and EM_GETLANGOPTIONS 
#define IMF_AUTOKEYBOARD		0x0001
#define IMF_AUTOFONT			0x0002
#define IMF_IMECANCELCOMPLETE	0x0004	// High completes comp string when aborting, low cancels
#define IMF_IMEALWAYSSENDNOTIFY 0x0008
#define IMF_AUTOFONTSIZEADJUST	0x0010
#define IMF_UIFONTS				0x0020
#define IMF_DUALFONT			0x0080

// Values for EM_GETIMECOMPMODE 
#define ICM_NOTOPEN				0x0000
#define ICM_LEVEL3				0x0001
#define ICM_LEVEL2				0x0002
#define ICM_LEVEL2_5			0x0003
#define ICM_LEVEL2_SUI			0x0004
#define ICM_CTF					0x0005

// Options for EM_SETTYPOGRAPHYOPTIONS 
#define	TO_ADVANCEDTYPOGRAPHY	1
#define	TO_SIMPLELINEBREAK		2
#define TO_DISABLECUSTOMTEXTOUT	4
#define TO_ADVANCEDLAYOUT		8

// Pegasus outline mode messages (RE 3.0) 

// Outline mode message
#define EM_OUTLINE              (WM_USER + 220)
// Message for getting and restoring scroll pos
#define EM_GETSCROLLPOS         (WM_USER + 221)
#define EM_SETSCROLLPOS         (WM_USER + 222)
// Change fontsize in current selection by wParam
#define EM_SETFONTSIZE          (WM_USER + 223)
#define EM_GETZOOM				(WM_USER + 224)
#define EM_SETZOOM				(WM_USER + 225)
#define EM_GETVIEWKIND			(WM_USER + 226)
#define EM_SETVIEWKIND			(WM_USER + 227)

// RichEdit 4.0 messages
#define EM_GETPAGE				(WM_USER + 228)
#define EM_SETPAGE				(WM_USER + 229)
#define EM_GETHYPHENATEINFO		(WM_USER + 230)
#define EM_SETHYPHENATEINFO		(WM_USER + 231)
#define EM_GETPAGEROTATE		(WM_USER + 235)
#define EM_SETPAGEROTATE		(WM_USER + 236)
#define EM_GETCTFMODEBIAS		(WM_USER + 237)
#define EM_SETCTFMODEBIAS		(WM_USER + 238)
#define EM_GETCTFOPENSTATUS		(WM_USER + 240)
#define EM_SETCTFOPENSTATUS		(WM_USER + 241)
#define EM_GETIMECOMPTEXT		(WM_USER + 242)
#define EM_ISIME				(WM_USER + 243)
#define EM_GETIMEPROPERTY		(WM_USER + 244)

// These messages control what rich edit does when it comes accross
// OLE objects during RTF stream in.  Normally rich edit queries the client
// application only after OleLoad has been called.  With these messages it is possible to
// set the rich edit control to a mode where it will query the client application before
// OleLoad is called
#define EM_GETQUERYRTFOBJ		(WM_USER + 269)
#define EM_SETQUERYRTFOBJ		(WM_USER + 270)

// EM_SETPAGEROTATE wparam values
#define EPR_0					0		// Text flows left to right and top to bottom
#define EPR_270					1		// Text flows top to bottom and right to left
#define EPR_180					2		// Text flows right to left and bottom to top
#define	EPR_90					3		// Text flows bottom to top and left to right

// EM_SETCTFMODEBIAS wparam values
#define CTFMODEBIAS_DEFAULT					0x0000
#define CTFMODEBIAS_FILENAME				0x0001
#define CTFMODEBIAS_NAME					0x0002
#define CTFMODEBIAS_READING					0x0003
#define CTFMODEBIAS_DATETIME				0x0004
#define CTFMODEBIAS_CONVERSATION			0x0005
#define CTFMODEBIAS_NUMERIC					0x0006
#define CTFMODEBIAS_HIRAGANA				0x0007
#define CTFMODEBIAS_KATAKANA				0x0008
#define CTFMODEBIAS_HANGUL					0x0009
#define CTFMODEBIAS_HALFWIDTHKATAKANA		0x000A
#define CTFMODEBIAS_FULLWIDTHALPHANUMERIC	0x000B
#define CTFMODEBIAS_HALFWIDTHALPHANUMERIC	0x000C

// EM_SETIMEMODEBIAS lparam values
#define IMF_SMODE_PLAURALCLAUSE	0x0001
#define IMF_SMODE_NONE			0x0002

// EM_GETIMECOMPTEXT wparam structure
typedef struct _imecomptext {
	LONG	cb;			// count of bytes in the output buffer.
	DWORD	flags;		// value specifying the composition string type.
						//	Currently only support ICT_RESULTREADSTR
} IMECOMPTEXT;
#define ICT_RESULTREADSTR		1

// Outline mode wparam values
#define EMO_EXIT                0       // Enter normal mode,  lparam ignored
#define EMO_ENTER               1       // Enter outline mode, lparam ignored
#define EMO_PROMOTE             2       // LOWORD(lparam) == 0 ==>
                                        //  promote  to body-text
                                        // LOWORD(lparam) != 0 ==>
                                        //  promote/demote current selection
                                        //  by indicated number of levels
#define EMO_EXPAND              3       // HIWORD(lparam) = EMO_EXPANDSELECTION
                                        //  -> expands selection to level
                                        //  indicated in LOWORD(lparam)
                                        //  LOWORD(lparam) = -1/+1 corresponds
                                        //  to collapse/expand button presses
                                        //  in winword (other values are
                                        //  equivalent to having pressed these
                                        //  buttons more than once)
                                        //  HIWORD(lparam) = EMO_EXPANDDOCUMENT
                                        //  -> expands whole document to
                                        //  indicated level
#define EMO_MOVESELECTION       4       // LOWORD(lparam) != 0 -> move current
                                        //  selection up/down by indicated amount
#define EMO_GETVIEWMODE			5		// Returns VM_NORMAL or VM_OUTLINE

// EMO_EXPAND options
#define EMO_EXPANDSELECTION     0
#define EMO_EXPANDDOCUMENT      1

#define VM_NORMAL				4		// Agrees with RTF \viewkindN
#define VM_OUTLINE				2
#define VM_PAGE					9		// Screen page view (not print layout)

// New notifications 
#define EN_MSGFILTER			0x0700
#define EN_REQUESTRESIZE		0x0701
#define EN_SELCHANGE			0x0702
#define EN_DROPFILES			0x0703
#define EN_PROTECTED			0x0704
#define EN_CORRECTTEXT			0x0705			// PenWin specific 
#define EN_STOPNOUNDO			0x0706
#define EN_IMECHANGE			0x0707			// East Asia specific 
#define EN_SAVECLIPBOARD		0x0708
#define EN_OLEOPFAILED			0x0709
#define EN_OBJECTPOSITIONS		0x070a
#define EN_LINK					0x070b
#define EN_DRAGDROPDONE			0x070c
#define EN_PARAGRAPHEXPANDED	0x070d
#define EN_PAGECHANGE			0x070e
#define EN_LOWFIRTF				0x070f
#define EN_ALIGNLTR				0x0710			// BiDi specific notification
#define EN_ALIGNRTL				0x0711			// BiDi specific notification

// Event notification masks 
#define ENM_NONE				0x00000000
#define ENM_CHANGE				0x00000001
#define ENM_UPDATE				0x00000002
#define ENM_SCROLL				0x00000004
#define ENM_SCROLLEVENTS		0x00000008
#define ENM_DRAGDROPDONE		0x00000010
#define ENM_PARAGRAPHEXPANDED	0x00000020
#define ENM_PAGECHANGE			0x00000040
#define ENM_KEYEVENTS			0x00010000
#define ENM_MOUSEEVENTS			0x00020000
#define ENM_REQUESTRESIZE		0x00040000
#define ENM_SELCHANGE			0x00080000
#define ENM_DROPFILES			0x00100000
#define ENM_PROTECTED			0x00200000
#define ENM_CORRECTTEXT			0x00400000		// PenWin specific 
#define ENM_IMECHANGE			0x00800000		// Used by RE1.0 compatibility
#define ENM_LANGCHANGE			0x01000000
#define ENM_OBJECTPOSITIONS		0x02000000
#define ENM_LINK				0x04000000
#define ENM_LOWFIRTF			0x08000000


// New edit control styles 
#define ES_SAVESEL				0x00008000
#define ES_SUNKEN				0x00004000
#define ES_DISABLENOSCROLL		0x00002000
// Same as WS_MAXIMIZE, but that doesn't make sense so we re-use the value 
#define ES_SELECTIONBAR			0x01000000
// Same as ES_UPPERCASE, but re-used to completely disable OLE drag'n'drop 
#define ES_NOOLEDRAGDROP		0x00000008

// New edit control extended style 
#if (_WIN32_WINNT > 0x0400) || (WINVER > 0x0400)
#define ES_EX_NOCALLOLEINIT		0x00000000		// Not supported in RE 2.0/3.0 
#else
#ifdef	_WIN32
#define ES_EX_NOCALLOLEINIT		0x01000000
#endif	
#endif

// These flags are used in FE Windows 
#define ES_VERTICAL				0x00400000		// Not supported in RE 2.0/3.0 
#define	ES_NOIME				0x00080000
#define ES_SELFIME				0x00040000

// Edit control options 
#define ECO_AUTOWORDSELECTION	0x00000001
#define ECO_AUTOVSCROLL			0x00000040
#define ECO_AUTOHSCROLL			0x00000080
#define ECO_NOHIDESEL			0x00000100
#define ECO_READONLY			0x00000800
#define ECO_WANTRETURN			0x00001000
#define ECO_SAVESEL				0x00008000
#define ECO_SELECTIONBAR		0x01000000
#define ECO_VERTICAL			0x00400000		// FE specific 


// ECO operations 
#define ECOOP_SET				0x0001
#define ECOOP_OR				0x0002
#define ECOOP_AND				0x0003
#define ECOOP_XOR				0x0004

// New word break function actions 
#define WB_CLASSIFY			3
#define WB_MOVEWORDLEFT		4
#define WB_MOVEWORDRIGHT	5
#define WB_LEFTBREAK		6
#define WB_RIGHTBREAK		7

// East Asia specific flags 
#define WB_MOVEWORDPREV		4
#define WB_MOVEWORDNEXT		5
#define WB_PREVBREAK		6
#define WB_NEXTBREAK		7

#define PC_FOLLOWING		1
#define	PC_LEADING			2
#define	PC_OVERFLOW			3
#define	PC_DELIMITER		4
#define WBF_WORDWRAP		0x010
#define WBF_WORDBREAK		0x020
#define	WBF_OVERFLOW		0x040	
#define WBF_LEVEL1			0x080
#define	WBF_LEVEL2			0x100
#define	WBF_CUSTOM			0x200

// East Asia specific flags 
#define IMF_FORCENONE           0x0001
#define IMF_FORCEENABLE         0x0002
#define IMF_FORCEDISABLE        0x0004
#define IMF_CLOSESTATUSWINDOW   0x0008
#define IMF_VERTICAL            0x0020
#define IMF_FORCEACTIVE         0x0040
#define IMF_FORCEINACTIVE       0x0080
#define IMF_FORCEREMEMBER       0x0100
#define IMF_MULTIPLEEDIT        0x0400

// Word break flags (used with WB_CLASSIFY) 
#define WBF_CLASS			((BYTE) 0x0F)
#define WBF_ISWHITE			((BYTE) 0x10)
#define WBF_BREAKLINE		((BYTE) 0x20)
#define WBF_BREAKAFTER		((BYTE) 0x40)


// Data types 

#ifdef _WIN32
// Extended edit word break proc (character set aware) 
typedef LONG (*EDITWORDBREAKPROCEX)(char *pchText, LONG cchText, BYTE bCharSet, INT action);
#endif

// All character format measurements are in twips 
typedef struct _charformat
{
	UINT		cbSize;
	DWORD		dwMask;
	DWORD		dwEffects;
	LONG		yHeight;
	LONG		yOffset;
	COLORREF	crTextColor;
	BYTE		bCharSet;
	BYTE		bPitchAndFamily;
	char		szFaceName[LF_FACESIZE];
} CHARFORMATA;

typedef struct _charformatw
{
	UINT		cbSize;
	DWORD		dwMask;
	DWORD		dwEffects;
	LONG		yHeight;
	LONG		yOffset;
	COLORREF	crTextColor;
	BYTE		bCharSet;
	BYTE		bPitchAndFamily;
	WCHAR		szFaceName[LF_FACESIZE];
} CHARFORMATW;

#if (_RICHEDIT_VER >= 0x0200)
#ifdef UNICODE
#define CHARFORMAT CHARFORMATW
#else
#define CHARFORMAT CHARFORMATA
#endif // UNICODE 
#else
#define CHARFORMAT CHARFORMATA
#endif // _RICHEDIT_VER >= 0x0200 

// CHARFORMAT2 structure 

#ifdef __cplusplus

struct CHARFORMAT2W : _charformatw
{
	WORD		wWeight;			// Font weight (LOGFONT value)
	SHORT		sSpacing;			// Amount to space between letters
	COLORREF	crBackColor;		// Background color
	LCID		lcid;				// Locale ID
	DWORD		dwReserved;			// Reserved. Must be 0
	SHORT		sStyle;				// Style handle
	WORD		wKerning;			// Twip size above which to kern char pair
	BYTE		bUnderlineType;		// Underline type
	BYTE		bAnimation;			// Animated text like marching ants
	BYTE		bRevAuthor;			// Revision author index
};

struct CHARFORMAT2A : _charformat
{
	WORD		wWeight;			// Font weight (LOGFONT value)
	SHORT		sSpacing;			// Amount to space between letters
	COLORREF	crBackColor;		// Background color
	LCID		lcid;				// Locale ID
	DWORD		dwReserved;			// Reserved. Must be 0
	SHORT		sStyle;				// Style handle
	WORD		wKerning;			// Twip size above which to kern char pair
	BYTE		bUnderlineType;		// Underline type
	BYTE		bAnimation;			// Animated text like marching ants
	BYTE		bRevAuthor;			// Revision author index
};

#else	// regular C-style  

typedef struct _charformat2w
{
	UINT		cbSize;
	DWORD		dwMask;
	DWORD		dwEffects;
	LONG		yHeight;
	LONG		yOffset;			// > 0 for superscript, < 0 for subscript 
	COLORREF	crTextColor;
	BYTE		bCharSet;
	BYTE		bPitchAndFamily;
	WCHAR		szFaceName[LF_FACESIZE];
	WORD		wWeight;			// Font weight (LOGFONT value)		
	SHORT		sSpacing;			// Amount to space between letters	
	COLORREF	crBackColor;		// Background color					
	LCID		lcid;				// Locale ID						
	DWORD		dwReserved;			// Reserved. Must be 0				
	SHORT		sStyle;				// Style handle						
	WORD		wKerning;			// Twip size above which to kern char pair
	BYTE		bUnderlineType;		// Underline type					
	BYTE		bAnimation;			// Animated text like marching ants	
	BYTE		bRevAuthor;			// Revision author index			
	BYTE		bReserved1;
} CHARFORMAT2W;

typedef struct _charformat2a
{
	UINT		cbSize;
	DWORD		dwMask;
	DWORD		dwEffects;
	LONG		yHeight;
	LONG		yOffset;			// > 0 for superscript, < 0 for subscript 
	COLORREF	crTextColor;
	BYTE		bCharSet;
	BYTE		bPitchAndFamily;
	char		szFaceName[LF_FACESIZE];
	WORD		wWeight;			// Font weight (LOGFONT value)		
	SHORT		sSpacing;			// Amount to space between letters	
	COLORREF	crBackColor;		// Background color					
	LCID		lcid;				// Locale ID						
	DWORD		dwReserved;			// Reserved. Must be 0				
	SHORT		sStyle;				// Style handle						
	WORD		wKerning;			// Twip size above which to kern char pair
	BYTE		bUnderlineType;		// Underline type					
	BYTE		bAnimation;			// Animated text like marching ants	
	BYTE		bRevAuthor;			// Revision author index			
} CHARFORMAT2A;

#endif // C++ 

#ifdef UNICODE
#define CHARFORMAT2	CHARFORMAT2W
#else
#define CHARFORMAT2 CHARFORMAT2A
#endif

#define CHARFORMATDELTA		(sizeof(CHARFORMAT2) - sizeof(CHARFORMAT))


// CFM_COLOR mirrors CFE_AUTOCOLOR, a little hack to easily deal with autocolor

// CHARFORMAT masks 
#define CFM_BOLD		0x00000001
#define CFM_ITALIC		0x00000002
#define CFM_UNDERLINE	0x00000004
#define CFM_STRIKEOUT	0x00000008
#define CFM_PROTECTED	0x00000010
#define CFM_LINK		0x00000020			// Exchange hyperlink extension 
#define CFM_SIZE		0x80000000
#define CFM_COLOR		0x40000000
#define CFM_FACE		0x20000000
#define CFM_OFFSET		0x10000000
#define CFM_CHARSET		0x08000000

// CHARFORMAT effects 
#define CFE_BOLD		0x0001
#define CFE_ITALIC		0x0002
#define CFE_UNDERLINE	0x0004
#define CFE_STRIKEOUT	0x0008
#define CFE_PROTECTED	0x0010
#define CFE_LINK		0x0020
#define CFE_AUTOCOLOR	0x40000000			// NOTE: this corresponds to 
											// CFM_COLOR, which controls it 
// Masks and effects defined for CHARFORMAT2 -- an (*) indicates
// that the data is stored by RichEdit 2.0/3.0, but not displayed
#define CFM_SMALLCAPS		0x0040			// (*)	
#define	CFM_ALLCAPS			0x0080			// Displayed by 3.0	
#define	CFM_HIDDEN			0x0100			// Hidden by 3.0 
#define	CFM_OUTLINE			0x0200			// (*)	
#define	CFM_SHADOW			0x0400			// (*)	
#define	CFM_EMBOSS			0x0800			// (*)	
#define	CFM_IMPRINT			0x1000			// (*)	
#define CFM_DISABLED		0x2000
#define	CFM_REVISED			0x4000

#define CFM_BACKCOLOR		0x04000000
#define CFM_LCID			0x02000000
#define	CFM_UNDERLINETYPE	0x00800000		// Many displayed by 3.0 
#define	CFM_WEIGHT			0x00400000
#define CFM_SPACING			0x00200000		// Displayed by 3.0	
#define CFM_KERNING			0x00100000		// (*)	
#define CFM_STYLE			0x00080000		// (*)	
#define CFM_ANIMATION		0x00040000		// (*)	
#define CFM_REVAUTHOR		0x00008000

#define CFE_SUBSCRIPT		0x00010000		// Superscript and subscript are 
#define CFE_SUPERSCRIPT		0x00020000		//  mutually exclusive			 

#define CFM_SUBSCRIPT		(CFE_SUBSCRIPT | CFE_SUPERSCRIPT)
#define CFM_SUPERSCRIPT		CFM_SUBSCRIPT

// CHARFORMAT "ALL" masks
#define CFM_EFFECTS (CFM_BOLD | CFM_ITALIC | CFM_UNDERLINE | CFM_COLOR | \
					 CFM_STRIKEOUT | CFE_PROTECTED | CFM_LINK)
#define CFM_ALL (CFM_EFFECTS | CFM_SIZE | CFM_FACE | CFM_OFFSET | CFM_CHARSET)

#define	CFM_EFFECTS2 (CFM_EFFECTS | CFM_DISABLED | CFM_SMALLCAPS | CFM_ALLCAPS \
					| CFM_HIDDEN  | CFM_OUTLINE | CFM_SHADOW | CFM_EMBOSS \
					| CFM_IMPRINT | CFM_DISABLED | CFM_REVISED \
					| CFM_SUBSCRIPT | CFM_SUPERSCRIPT | CFM_BACKCOLOR)

#define CFM_ALL2	 (CFM_ALL | CFM_EFFECTS2 | CFM_BACKCOLOR | CFM_LCID \
					| CFM_UNDERLINETYPE | CFM_WEIGHT | CFM_REVAUTHOR \
					| CFM_SPACING | CFM_KERNING | CFM_STYLE | CFM_ANIMATION)

#define	CFE_SMALLCAPS		CFM_SMALLCAPS
#define	CFE_ALLCAPS			CFM_ALLCAPS
#define	CFE_HIDDEN			CFM_HIDDEN
#define	CFE_OUTLINE			CFM_OUTLINE
#define	CFE_SHADOW			CFM_SHADOW
#define	CFE_EMBOSS			CFM_EMBOSS
#define	CFE_IMPRINT			CFM_IMPRINT
#define	CFE_DISABLED		CFM_DISABLED
#define	CFE_REVISED			CFM_REVISED

// CFE_AUTOCOLOR and CFE_AUTOBACKCOLOR correspond to CFM_COLOR and
// CFM_BACKCOLOR, respectively, which control them
#define CFE_AUTOBACKCOLOR	CFM_BACKCOLOR

// Underline types. RE 1.0 displays only CFU_UNDERLINE
#define CFU_CF1UNDERLINE	0xFF	// Map charformat's bit underline to CF2
#define CFU_INVERT			0xFE	// For IME composition fake a selection
#define CFU_UNDERLINETHICKLONGDASH		18	// (*) display as dash
#define CFU_UNDERLINETHICKDOTTED		17	// (*) display as dot
#define CFU_UNDERLINETHICKDASHDOTDOT	16	// (*) display as dash dot dot
#define CFU_UNDERLINETHICKDASHDOT		15	// (*) display as dash dot
#define CFU_UNDERLINETHICKDASH			14	// (*) display as dash
#define CFU_UNDERLINELONGDASH			13	// (*) display as dash
#define CFU_UNDERLINEHEAVYWAVE			12	// (*) display as wave
#define CFU_UNDERLINEDOUBLEWAVE			11	// (*) display as wave
#define CFU_UNDERLINEHAIRLINE			10	// (*) display as single	
#define CFU_UNDERLINETHICK				9
#define CFU_UNDERLINEWAVE				8
#define	CFU_UNDERLINEDASHDOTDOT			7
#define	CFU_UNDERLINEDASHDOT			6
#define	CFU_UNDERLINEDASH				5
#define	CFU_UNDERLINEDOTTED				4
#define	CFU_UNDERLINEDOUBLE				3	// (*) display as single
#define CFU_UNDERLINEWORD				2	// (*) display as single	
#define CFU_UNDERLINE					1
#define CFU_UNDERLINENONE				0

#define yHeightCharPtsMost 1638

// EM_SETCHARFORMAT wParam masks 
#define SCF_SELECTION		0x0001
#define SCF_WORD			0x0002
#define SCF_DEFAULT			0x0000	// Set default charformat or paraformat
#define SCF_ALL				0x0004	// Not valid with SCF_SELECTION or SCF_WORD
#define SCF_USEUIRULES		0x0008	// Modifier for SCF_SELECTION; says that
									//  format came from a toolbar, etc., and
									//  hence UI formatting rules should be
									//  used instead of literal formatting
#define SCF_ASSOCIATEFONT	0x0010	// Associate fontname with bCharSet (one
									//  possible for each of Western, ME, FE,
									//  Thai)
#define SCF_NOKBUPDATE		0x0020	// Do not update KB layput for this change
									//  even if autokeyboard is on
#define SCF_ASSOCIATEFONT2	0x0040	// Associate plane-2 (surrogate) font

typedef struct _charrange
{
	LONG	cpMin;
	LONG	cpMax;
} CHARRANGE;

typedef struct _textrange
{
	CHARRANGE chrg;
	LPSTR lpstrText;	// Allocated by caller, zero terminated by RichEdit 
} TEXTRANGEA;

typedef struct _textrangew
{
	CHARRANGE chrg;
	LPWSTR lpstrText;	// Allocated by caller, zero terminated by RichEdit 
} TEXTRANGEW;

#if (_RICHEDIT_VER >= 0x0200)
#ifdef UNICODE
#define TEXTRANGE 	TEXTRANGEW
#else
#define TEXTRANGE	TEXTRANGEA
#endif // UNICODE 
#else
#define TEXTRANGE	TEXTRANGEA
#endif // _RICHEDIT_VER >= 0x0200 

typedef DWORD (CALLBACK *EDITSTREAMCALLBACK)(DWORD_PTR dwCookie, LPBYTE pbBuff, LONG cb, LONG *pcb);

typedef struct _editstream
{
	DWORD_PTR dwCookie;		// User value passed to callback as first parameter 
	DWORD	  dwError;		// Last error 
	EDITSTREAMCALLBACK pfnCallback;
} EDITSTREAM;

// Stream formats. Flags are all in low word, since high word
// gives possible codepage choice. 
#define SF_TEXT			0x0001
#define SF_RTF			0x0002
#define SF_RTFNOOBJS	0x0003		// Write only 
#define SF_TEXTIZED		0x0004		// Write only 

#define SF_UNICODE		0x0010		// Unicode file (UCS2 little endian) 
#define SF_USECODEPAGE	0x0020		// CodePage given by high word 
#define SF_NCRFORNONASCII 0x40		// Output /uN for nonASCII 
#define	SFF_WRITEXTRAPAR  0x80		// Output \par at end

// Flag telling stream operations to operate on selection only 
// EM_STREAMIN  replaces current selection 
// EM_STREAMOUT streams out current selection 
#define SFF_SELECTION	0x8000

// Flag telling stream operations to ignore some FE control words 
// having to do with FE word breaking and horiz vs vertical text. 
// Not used in RichEdit 2.0 and later	
#define SFF_PLAINRTF	0x4000

// Flag telling file stream output (SFF_SELECTION flag not set) to persist 
// \viewscaleN control word. 
#define SFF_PERSISTVIEWSCALE 0x2000

// Flag telling file stream input with SFF_SELECTION flag not set not to 
// close the document 
#define SFF_KEEPDOCINFO	0x1000

// Flag telling stream operations to output in Pocket Word format 
#define SFF_PWD			0x0800

// 3-bit field specifying the value of N - 1 to use for \rtfN or \pwdN 
#define SF_RTFVAL		0x0700

typedef struct _findtext
{
	CHARRANGE chrg;
	LPCSTR lpstrText;
} FINDTEXTA;

typedef struct _findtextw
{
	CHARRANGE chrg;
	LPCWSTR lpstrText;
} FINDTEXTW;

#if (_RICHEDIT_VER >= 0x0200)
#ifdef UNICODE
#define FINDTEXT	FINDTEXTW
#else
#define FINDTEXT	FINDTEXTA
#endif	// UNICODE 
#else
#define FINDTEXT	FINDTEXTA
#endif // _RICHEDIT_VER >= 0x0200 

typedef struct _findtextexa
{
	CHARRANGE chrg;
	LPCSTR	  lpstrText;
	CHARRANGE chrgText;
} FINDTEXTEXA;

typedef struct _findtextexw
{
	CHARRANGE chrg;
	LPCWSTR	  lpstrText;
	CHARRANGE chrgText;
} FINDTEXTEXW;

#if (_RICHEDIT_VER >= 0x0200)
#ifdef UNICODE
#define FINDTEXTEX	FINDTEXTEXW
#else
#define FINDTEXTEX	FINDTEXTEXA
#endif // UNICODE 
#else
#define FINDTEXTEX	FINDTEXTEXA
#endif // _RICHEDIT_VER >= 0x0200 


typedef struct _formatrange
{
	HDC hdc;
	HDC hdcTarget;
	RECT rc;
	RECT rcPage;
	CHARRANGE chrg;
} FORMATRANGE;

// All paragraph measurements are in twips 

#define MAX_TAB_STOPS 32
#define lDefaultTab 720
#define MAX_TABLE_CELLS 63

typedef struct _paraformat
{
	UINT	cbSize;
	DWORD	dwMask;
	WORD	wNumbering;
	WORD	wEffects;
	LONG	dxStartIndent;
	LONG	dxRightIndent;
	LONG	dxOffset;
	WORD	wAlignment;
	SHORT	cTabCount;
	LONG	rgxTabs[MAX_TAB_STOPS];
} PARAFORMAT;

#ifdef __cplusplus
struct PARAFORMAT2 : _paraformat
{
	LONG	dySpaceBefore;			// Vertical spacing before para
	LONG	dySpaceAfter;			// Vertical spacing after para
	LONG	dyLineSpacing;			// Line spacing depending on Rule
	SHORT	sStyle;					// Style handle
	BYTE	bLineSpacingRule;		// Rule for line spacing (see tom.doc)
	BYTE	bOutlineLevel;			// Outline level
	WORD	wShadingWeight;			// Shading in hundredths of a per cent
	WORD	wShadingStyle;			// Nibble 0: style, 1: cfpat, 2: cbpat
	WORD	wNumberingStart;		// Starting value for numbering
	WORD	wNumberingStyle;		// Alignment, roman/arabic, (), ), ., etc.
	WORD	wNumberingTab;			// Space bet FirstIndent & 1st-line text
	WORD	wBorderSpace;			// Border-text spaces (nbl/bdr in pts)
	WORD	wBorderWidth;			// Pen widths (nbl/bdr in half pts)
	WORD	wBorders;				// Border styles (nibble/border)
};

#else	// Regular C-style	

typedef struct _paraformat2
{
	UINT	cbSize;
	DWORD	dwMask;
	WORD	wNumbering;
	WORD	wReserved;
	LONG	dxStartIndent;
	LONG	dxRightIndent;
	LONG	dxOffset;
	WORD	wAlignment;
	SHORT	cTabCount;
	LONG	rgxTabs[MAX_TAB_STOPS];
 	LONG	dySpaceBefore;			// Vertical spacing before para			
	LONG	dySpaceAfter;			// Vertical spacing after para			
	LONG	dyLineSpacing;			// Line spacing depending on Rule		
	SHORT	sStyle;					// Style handle							
	BYTE	bLineSpacingRule;		// Rule for line spacing (see tom.doc)	
	BYTE	bOutlineLevel;			// Outline Level						
	WORD	wShadingWeight;			// Shading in hundredths of a per cent	
	WORD	wShadingStyle;			// Byte 0: style, nib 2: cfpat, 3: cbpat
	WORD	wNumberingStart;		// Starting value for numbering				
	WORD	wNumberingStyle;		// Alignment, Roman/Arabic, (), ), ., etc.
	WORD	wNumberingTab;			// Space bet 1st indent and 1st-line text
	WORD	wBorderSpace;			// Border-text spaces (nbl/bdr in pts)	
	WORD	wBorderWidth;			// Pen widths (nbl/bdr in half twips)	
	WORD	wBorders;				// Border styles (nibble/border)		
} PARAFORMAT2;

#endif // C++	


// PARAFORMAT mask values 
#define PFM_STARTINDENT			0x00000001
#define PFM_RIGHTINDENT			0x00000002
#define PFM_OFFSET				0x00000004
#define PFM_ALIGNMENT			0x00000008
#define PFM_TABSTOPS			0x00000010
#define PFM_NUMBERING			0x00000020
#define PFM_OFFSETINDENT		0x80000000

// PARAFORMAT 2.0 masks and effects 
#define PFM_SPACEBEFORE			0x00000040
#define PFM_SPACEAFTER			0x00000080
#define PFM_LINESPACING			0x00000100
#define	PFM_STYLE				0x00000400
#define PFM_BORDER				0x00000800	// (*)	
#define PFM_SHADING				0x00001000	// (*)	
#define PFM_NUMBERINGSTYLE		0x00002000	// RE 3.0	
#define PFM_NUMBERINGTAB		0x00004000	// RE 3.0	
#define PFM_NUMBERINGSTART		0x00008000	// RE 3.0	

#define PFM_RTLPARA				0x00010000
#define PFM_KEEP				0x00020000	// (*)	
#define PFM_KEEPNEXT			0x00040000	// (*)	
#define PFM_PAGEBREAKBEFORE		0x00080000	// (*)	
#define PFM_NOLINENUMBER		0x00100000	// (*)	
#define PFM_NOWIDOWCONTROL		0x00200000	// (*)	
#define PFM_DONOTHYPHEN			0x00400000	// (*)	
#define PFM_SIDEBYSIDE			0x00800000	// (*)	
#define PFM_TABLE				0x40000000	// RE 3.0 
#define PFM_TEXTWRAPPINGBREAK	0x20000000	// RE 3.0 
#define PFM_TABLEROWDELIMITER	0x10000000	// RE 4.0 

// The following three properties are read only
#define PFM_COLLAPSED			0x01000000	// RE 3.0 
#define PFM_OUTLINELEVEL		0x02000000	// RE 3.0 
#define PFM_BOX					0x04000000	// RE 3.0 
#define PFM_RESERVED2			0x08000000	// RE 4.0 


// PARAFORMAT "ALL" masks
#define	PFM_ALL (PFM_STARTINDENT | PFM_RIGHTINDENT | PFM_OFFSET	| \
				 PFM_ALIGNMENT   | PFM_TABSTOPS    | PFM_NUMBERING | \
				 PFM_OFFSETINDENT| PFM_RTLPARA)

// Note: PARAFORMAT has no effects (BiDi RichEdit 1.0 does have PFE_RTLPARA)
#define PFM_EFFECTS (PFM_RTLPARA | PFM_KEEP | PFM_KEEPNEXT | PFM_TABLE \
					| PFM_PAGEBREAKBEFORE | PFM_NOLINENUMBER  \
					| PFM_NOWIDOWCONTROL | PFM_DONOTHYPHEN | PFM_SIDEBYSIDE \
					| PFM_TABLE | PFM_TABLEROWDELIMITER)

#define PFM_ALL2	(PFM_ALL | PFM_EFFECTS | PFM_SPACEBEFORE | PFM_SPACEAFTER \
					| PFM_LINESPACING | PFM_STYLE | PFM_SHADING | PFM_BORDER \
					| PFM_NUMBERINGTAB | PFM_NUMBERINGSTART | PFM_NUMBERINGSTYLE)

#define PFE_RTLPARA				(PFM_RTLPARA		 >> 16)
#define PFE_KEEP				(PFM_KEEP			 >> 16)	// (*)	
#define PFE_KEEPNEXT			(PFM_KEEPNEXT		 >> 16)	// (*)	
#define PFE_PAGEBREAKBEFORE		(PFM_PAGEBREAKBEFORE >> 16)	// (*)	
#define PFE_NOLINENUMBER		(PFM_NOLINENUMBER	 >> 16)	// (*)	
#define PFE_NOWIDOWCONTROL		(PFM_NOWIDOWCONTROL	 >> 16)	// (*)	
#define PFE_DONOTHYPHEN			(PFM_DONOTHYPHEN 	 >> 16)	// (*)	
#define PFE_SIDEBYSIDE			(PFM_SIDEBYSIDE		 >> 16)	// (*)	
#define PFE_TEXTWRAPPINGBREAK	(PFM_TEXTWRAPPINGBREAK>>16) // (*)	

// The following four effects are read only
#define PFE_COLLAPSED			(PFM_COLLAPSED		 >> 16)	// (+)	
#define PFE_BOX					(PFM_BOX			 >> 16)	// (+)	
#define PFE_TABLE				(PFM_TABLE			 >> 16)	// Inside table row. RE 3.0 
#define PFE_TABLEROWDELIMITER	(PFM_TABLEROWDELIMITER>>16)	// Table row start. RE 4.0 

// PARAFORMAT numbering options 
#define PFN_BULLET		1		// tomListBullet

// PARAFORMAT2 wNumbering options 
#define PFN_ARABIC		2		// tomListNumberAsArabic:   0, 1, 2,	...
#define PFN_LCLETTER	3		// tomListNumberAsLCLetter: a, b, c,	...
#define	PFN_UCLETTER	4		// tomListNumberAsUCLetter: A, B, C,	...
#define	PFN_LCROMAN		5		// tomListNumberAsLCRoman:  i, ii, iii,	...
#define	PFN_UCROMAN		6		// tomListNumberAsUCRoman:  I, II, III,	...

// PARAFORMAT2 wNumberingStyle options 
#define PFNS_PAREN		0x000	// default, e.g.,				  1)	
#define	PFNS_PARENS		0x100	// tomListParentheses/256, e.g., (1)	
#define PFNS_PERIOD		0x200	// tomListPeriod/256, e.g.,		  1.	
#define PFNS_PLAIN		0x300	// tomListPlain/256, e.g.,		  1		
#define PFNS_NONUMBER	0x400	// Used for continuation w/o number

#define PFNS_NEWNUMBER	0x8000	// Start new number with wNumberingStart		
								// (can be combined with other PFNS_xxx)
// PARAFORMAT alignment options 
#define PFA_LEFT			 1
#define PFA_RIGHT			 2
#define PFA_CENTER			 3

// PARAFORMAT2 alignment options 
#define	PFA_JUSTIFY			 4	// New paragraph-alignment option 2.0 (*) 
#define PFA_FULL_INTERWORD	 4	// These are supported in 3.0 with advanced
#define PFA_FULL_INTERLETTER 5	//  typography enabled
#define PFA_FULL_SCALED		 6
#define	PFA_FULL_GLYPHS		 7
#define	PFA_SNAP_GRID		 8


// Notification structures 
#ifndef WM_NOTIFY
#define WM_NOTIFY		0x004E

typedef struct _nmhdr
{
	HWND	hwndFrom;
	UINT	idFrom;
	UINT	code;
} NMHDR;
#endif  // !WM_NOTIFY 

typedef struct _msgfilter
{
	NMHDR	nmhdr;
	UINT	msg;
	WPARAM	wParam;
	LPARAM	lParam;
} MSGFILTER;

typedef struct _reqresize
{
	NMHDR nmhdr;
	RECT rc;
} REQRESIZE;

typedef struct _selchange
{
	NMHDR nmhdr;
	CHARRANGE chrg;
	WORD seltyp;
} SELCHANGE;


#define SEL_EMPTY		0x0000
#define SEL_TEXT		0x0001
#define SEL_OBJECT		0x0002
#define SEL_MULTICHAR	0x0004
#define SEL_MULTIOBJECT	0x0008

// Used with IRichEditOleCallback::GetContextMenu, this flag will be
// passed as a "selection type".  It indicates that a context menu for
// a right-mouse drag drop should be generated.  The IOleObject parameter
// will really be the IDataObject for the drop
#define GCM_RIGHTMOUSEDROP  0x8000

typedef struct _endropfiles
{
	NMHDR nmhdr;
	HANDLE hDrop;
	LONG cp;
	BOOL fProtected;
} ENDROPFILES;

typedef struct _enprotected
{
	NMHDR nmhdr;
	UINT msg;
	WPARAM wParam;
	LPARAM lParam;
	CHARRANGE chrg;
} ENPROTECTED;

typedef struct _ensaveclipboard
{
	NMHDR nmhdr;
	LONG cObjectCount;
    LONG cch;
} ENSAVECLIPBOARD;

#ifndef MACPORT
typedef struct _enoleopfailed
{
	NMHDR nmhdr;
	LONG iob;
	LONG lOper;
	HRESULT hr;
} ENOLEOPFAILED;
#endif

#define	OLEOP_DOVERB	1

typedef struct _objectpositions
{
    NMHDR nmhdr;
    LONG cObjectCount;
    LONG *pcpPositions;
} OBJECTPOSITIONS;

typedef struct _enlink
{
    NMHDR nmhdr;
    UINT msg;
    WPARAM wParam;
    LPARAM lParam;
    CHARRANGE chrg;
} ENLINK;

typedef struct _enlowfirtf
{
    NMHDR nmhdr;
	char *szControl;
} ENLOWFIRTF;

// PenWin specific 
typedef struct _encorrecttext
{
	NMHDR nmhdr;
	CHARRANGE chrg;
	WORD seltyp;
} ENCORRECTTEXT;

// East Asia specific 
typedef struct _punctuation
{
	UINT	iSize;
	LPSTR	szPunctuation;
} PUNCTUATION;

// East Asia specific 
typedef struct _compcolor
{
	COLORREF crText;
	COLORREF crBackground;
	DWORD dwEffects;
}COMPCOLOR;


// Clipboard formats - use as parameter to RegisterClipboardFormat() 
#define CF_RTF 			TEXT("Rich Text Format")
#define CF_RTFNOOBJS 	TEXT("Rich Text Format Without Objects")
#define CF_RETEXTOBJ 	TEXT("RichEdit Text and Objects")

// Paste Special 
typedef struct _repastespecial
{
	DWORD		dwAspect;
	DWORD_PTR	dwParam;
} REPASTESPECIAL;

//	UndoName info 
typedef enum _undonameid
{
    UID_UNKNOWN     = 0,
	UID_TYPING		= 1,
	UID_DELETE 		= 2,
	UID_DRAGDROP	= 3,
	UID_CUT			= 4,
	UID_PASTE		= 5,
	UID_AUTOCORRECT = 6
} UNDONAMEID;

// Flags for the SETEXTEX data structure 
#define ST_DEFAULT		0
#define ST_KEEPUNDO		1
#define ST_SELECTION	2
#define ST_NEWCHARS 	4

// EM_SETTEXTEX info; this struct is passed in the wparam of the message 
typedef struct _settextex
{
	DWORD	flags;			// Flags (see the ST_XXX defines)			
	UINT	codepage;		// Code page for translation (CP_ACP for sys default,
						    //  1200 for Unicode, -1 for control default)	
} SETTEXTEX;

// Flags for the GETEXTEX data structure 
#define GT_DEFAULT		0
#define GT_USECRLF		1
#define GT_SELECTION	2
#define GT_RAWTEXT		4
#define GT_NOHIDDENTEXT	8

// EM_GETTEXTEX info; this struct is passed in the wparam of the message 
typedef struct _gettextex
{
	DWORD	cb;				// Count of bytes in the string				
	DWORD	flags;			// Flags (see the GT_XXX defines			
	UINT	codepage;		// Code page for translation (CP_ACP for sys default,
						    //  1200 for Unicode, -1 for control default)	
	LPCSTR	lpDefaultChar;	// Replacement for unmappable chars			
	LPBOOL	lpUsedDefChar;	// Pointer to flag set when def char used	
} GETTEXTEX;

// Flags for the GETTEXTLENGTHEX data structure							
#define GTL_DEFAULT		0	// Do default (return # of chars)		
#define GTL_USECRLF		1	// Compute answer using CRLFs for paragraphs
#define GTL_PRECISE		2	// Compute a precise answer					
#define GTL_CLOSE		4	// Fast computation of a "close" answer		
#define GTL_NUMCHARS	8	// Return number of characters			
#define GTL_NUMBYTES	16	// Return number of _bytes_				

// EM_GETTEXTLENGTHEX info; this struct is passed in the wparam of the msg 
typedef struct _gettextlengthex
{
	DWORD	flags;			// Flags (see GTL_XXX defines)				
	UINT	codepage;		// Code page for translation (CP_ACP for default,
							//  1200 for Unicode)							
} GETTEXTLENGTHEX;
	
// BiDi specific features 
typedef struct _bidioptions
{
	UINT	cbSize;
	WORD	wMask;
	WORD	wEffects; 
} BIDIOPTIONS;

// BIDIOPTIONS masks 
#if (_RICHEDIT_VER == 0x0100)
#define BOM_DEFPARADIR			0x0001	// Default paragraph direction (implies alignment) (obsolete) 
#define BOM_PLAINTEXT			0x0002	// Use plain text layout (obsolete) 
#endif // _RICHEDIT_VER == 0x0100 
#define BOM_NEUTRALOVERRIDE		0x0004	// Override neutral layout (obsolete) 
#define BOM_CONTEXTREADING		0x0008	// Context reading order 
#define BOM_CONTEXTALIGNMENT	0x0010	// Context alignment 
#define BOM_LEGACYBIDICLASS		0x0040	// Legacy Bidi classification 

// BIDIOPTIONS effects 
#if (_RICHEDIT_VER == 0x0100)
#define BOE_RTLDIR				0x0001	// Default paragraph direction (implies alignment) (obsolete) 
#define BOE_PLAINTEXT			0x0002	// Use plain text layout (obsolete) 
#endif // _RICHEDIT_VER == 0x0100 
#define BOE_NEUTRALOVERRIDE		0x0004	// Override neutral layout (obsolete) 
#define BOE_CONTEXTREADING		0x0008	// Context reading order 
#define BOE_CONTEXTALIGNMENT	0x0010	// Context alignment 
#define BOE_LEGACYBIDICLASS		0x0040	// Legacy Bidi classification 

// Additional EM_FINDTEXT[EX] flags 
#define FR_MATCHDIAC                    0x20000000
#define FR_MATCHKASHIDA                 0x40000000
#define FR_MATCHALEFHAMZA               0x80000000
	
// UNICODE embedding character 
#ifndef WCH_EMBEDDING
#define WCH_EMBEDDING (WCHAR)0xFFFC
#endif // WCH_EMBEDDING 
		
// khyph - Kind of hyphenation
typedef enum tagKHYPH
{
	khyphNil,				// No Hyphenation
	khyphNormal,			// Normal Hyphenation
	khyphAddBefore,			// Add letter before hyphen
	khyphChangeBefore,		// Change letter before hyphen
	khyphDeleteBefore,		// Delete letter before hyphen
	khyphChangeAfter,		// Change letter after hyphen
	khyphDelAndChange		// Delete letter before hyphen and change
							//  letter preceding hyphen
} KHYPH;

typedef struct hyphresult
{
	KHYPH khyph;			// Kind of hyphenation
	long  ichHyph;			// Character which was hyphenated
	WCHAR chHyph;			// Depending on hyphenation type, character added, changed, etc.
} HYPHRESULT;

void WINAPI HyphenateProc(WCHAR *pszWord, LANGID langid, long ichExceed, HYPHRESULT *phyphresult);
typedef struct tagHyphenateInfo
{
	SHORT cbSize;			// Size of HYPHENATEINFO structure
	SHORT dxHyphenateZone;	// If a space character is closer to the margin
							//  than this value, don't hyphenate (in TWIPs)
	void (WINAPI* pfnHyphenate)(WCHAR*, LANGID, long, HYPHRESULT*);
} HYPHENATEINFO;

#ifdef _WIN32
#include <poppack.h>
#elif !defined(RC_INVOKED)
#pragma pack()
#endif

#ifdef __cplusplus
}
#endif  // __cplusplus 

#endif // !_RICHEDIT_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\rxassert.h ===
#if !defined(NTDDI_VERSION)

#error NTDDI_VERSION must be defined to include this file.

#elif (NTDDI_VERSION >= NTDDI_VISTA)

#error This file cannot be included for this NTDDI_VERSION.

#elif (NTDDI_VERSION >= NTDDI_WS03)

/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    RxAssert.h

Abstract:

    This module declares the prototypes and global data used by the special RDBSS assert facilties.

Author:
Revision History:


Notes:


--*/

#ifndef _RDBSSASSERT_INCLUDED_
#define _RDBSSASSERT_INCLUDED_

VOID RxDbgBreakPoint(ULONG LineNumber);

//only do this is my routine is the one of interest.......

#ifdef RDBSS_ASSERTS

#if 0
#if !DBG

//here, ntifs will have already defined the asserts away..........
//   so, we just put them back.....this code is duplicated from ntifs.h


#undef ASSERT
#define ASSERT( exp ) \
    if (!(exp)) \
        RxDbgBreakPoint(__LINE__)

#undef ASSERTMSG
#define ASSERTMSG( msg, exp ) \
    if (!(exp)) \
        RxDbgBreakPoint(__LINE__)

#endif //!DBG
#endif

//this will make asserts go to our routine

#define RtlAssert RxAssert
VOID
RxAssert(
    IN PVOID FailedAssertion,
    IN PVOID FileName,
    IN ULONG LineNumber,
    IN PCHAR Message OPTIONAL
    );

#endif //ifdef RDBSS_ASSERTS


#endif // _RDBSSASSERT_INCLUDED_



#elif (NTDDI_VERSION >= NTDDI_WINXP)

/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    RxAssert.h

Abstract:

    This module declares the prototypes and global data used by the special RDBSS assert facilties.

Author:
Revision History:


Notes:


--*/

#ifndef _RDBSSASSERT_INCLUDED_
#define _RDBSSASSERT_INCLUDED_

VOID RxDbgBreakPoint(ULONG LineNumber);

//only do this is my routine is the one of interest.......

#ifdef RDBSS_ASSERTS

#if 0
#if !DBG

//here, ntifs will have already defined the asserts away..........
//   so, we just put them back.....this code is duplicated from ntifs.h


#undef ASSERT
#define ASSERT( exp ) \
    if (!(exp)) \
        RxDbgBreakPoint(__LINE__)

#undef ASSERTMSG
#define ASSERTMSG( msg, exp ) \
    if (!(exp)) \
        RxDbgBreakPoint(__LINE__)

#endif //!DBG
#endif

//this will make asserts go to our routine

#define RtlAssert RxAssert
VOID
RxAssert(
    IN PVOID FailedAssertion,
    IN PVOID FileName,
    IN ULONG LineNumber,
    IN PCHAR Message OPTIONAL
    );

#endif //ifdef RDBSS_ASSERTS


#endif // _RDBSSASSERT_INCLUDED_



#elif (NTDDI_VERSION >= NTDDI_WIN2K)

    /*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    RxAssert.h

Abstract:

    This module declares the prototypes and global data used by the special RDBSS assert facilties.

Author:
Revision History:


Notes:


--*/

#ifndef _RDBSSASSERT_INCLUDED_
#define _RDBSSASSERT_INCLUDED_

VOID RxDbgBreakPoint(ULONG LineNumber);

//only do this is my routine is the one of interest.......

#ifdef RDBSS_ASSERTS

#if 0
#if !DBG

//here, ntifs will have already defined the asserts away..........
//   so, we just put them back.....this code is duplicated from ntifs.h


#undef ASSERT
#define ASSERT( exp ) \
    if (!(exp)) \
        RxDbgBreakPoint(__LINE__)

#undef ASSERTMSG
#define ASSERTMSG( msg, exp ) \
    if (!(exp)) \
        RxDbgBreakPoint(__LINE__)

#endif //!DBG
#endif

//this will make asserts go to our routine

#define RtlAssert RxAssert
VOID
RxAssert(
    IN PVOID FailedAssertion,
    IN PVOID FileName,
    IN ULONG LineNumber,
    IN PCHAR Message OPTIONAL
    );

#endif //ifdef RDBSS_ASSERTS


#endif // _RDBSSASSERT_INCLUDED_



#else /* NTDDI_VERSION */

#error This file cannot be included for this NTDDI_VERSION.

#endif /* NTDDI_VERSION */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\rxce.h ===
#if !defined(NTDDI_VERSION)

#error NTDDI_VERSION must be defined to include this file.

#elif (NTDDI_VERSION >= NTDDI_VISTA)

/*++ BUILD Version: 0009    // Increment this if a change has global effects
Copyright (c) 1987-1993  Microsoft Corporation

Module Name:

    rxce.h

Abstract:

    This is the include file that defines all constants and types for
    accessing the redirector file system connection engine.

Revision History:
Notes:

    The Connection engine is designed to map and emulate the TDI specs. as closely
    as possible. This implies that on NT we will have a very efficient mechanism
    which fully exploits the underlying TDI implementation.

    There are four important data structures that are created/manipulated by the
    various functions associated with the connection engine. Thesr are
    RXCE_TRANSPORT,RXCE_ADDRESS,RXCE_CONNECTION and RXCE_VC.

    The mini redirector writers can embed these data structures in the corresponding
    definitions and invoke the two routines provided for each type to build and
    tear down the connection engine portions. These routines do not allocate/free
    the memory associated with these instances. This provides a flexible mechanism
    for the mini redirector writers to manage instances.

--*/

#ifndef _RXCE_H_
#define _RXCE_H_

#include <nodetype.h>
#include <rxcehdlr.h>    // TDI related definitions.
#include <rxworkq.h>
//
// The connection engine deals with three kinds of entities, transports, transport
// addresses and transport connections. The transports are bindings to the various
// transport service providers on any system. The transport addresses are the
// local connection end points. The connections are transport connections between
// endpoints.  Each connection encapsulates a  number of virtual circuits
// ( typically 1 ).
//

// All the four node types are tagged with  the following signature which is used
// extensively in validating them

typedef struct _RXCE_SIGNATURE_ {
    union {
        struct {
            USHORT  Type;
            CSHORT  Size;
        };

        ULONG   Signature;
    };
} RXCE_SIGNATURE, *PRXCE_SIGNATURE;

//
// RXCE_TRANSPORT encapsulates all the parameters w.r.t. a TRANSPORT
// as regards the connection engine.
//

#ifdef __cplusplus
typedef struct _RXCE_TRANSPORT_ : public RXCE_SIGNATURE {
#else // !__cplusplus
typedef struct _RXCE_TRANSPORT_ {
    RXCE_SIGNATURE;
#endif // __cplusplus

    UNICODE_STRING                Name;

    PDEVICE_OBJECT                pDeviceObject;             // Device object for transport
    HANDLE                        ControlChannel;            // Control Channel
    PFILE_OBJECT                  pControlChannelFileObject; // File object for the control channel

    PRXCE_TRANSPORT_PROVIDER_INFO pProviderInfo;             // Transport Provider Information.

    LONG                          ConnectionCount;           // Number of connections on xport.
    LONG                          VirtualCircuitCount;       // no. of connections
    ULONG                         QualityOfService;          // quality of service provided.
} RXCE_TRANSPORT;

#define RXCE_TRANSPORT_SIGNATURE ((sizeof(RXCE_TRANSPORT) << 16) | RDBSS_NTC_RXCE_TRANSPORT)

#define RxCeIsTransportValid(pTransport)    \
        ((pTransport)->Signature == RXCE_TRANSPORT_SIGNATURE)

extern NTSTATUS
NTAPI
RxCeBuildTransport(
    IN PRXCE_TRANSPORT pRxCeTransport,
    IN PUNICODE_STRING pTransportName,
    IN ULONG           QualityOfService);

extern NTSTATUS
NTAPI
RxCeTearDownTransport(
    IN PRXCE_TRANSPORT pTransport);

extern NTSTATUS
RxCeQueryAdapterStatus(
    PRXCE_TRANSPORT         pTransport,
    struct _ADAPTER_STATUS *pAdapterStatus);

extern NTSTATUS
RxCeQueryTransportInformation(
    PRXCE_TRANSPORT             pTransport,
    PRXCE_TRANSPORT_INFORMATION pTransportInformation);

//
// RXCE_ADDRESS encapsulates all the parameters w.r.t. a local transport address
// as regards the connection engine.
//

#ifdef __cplusplus
typedef struct _RXCE_ADDRESS_ : public RXCE_SIGNATURE {
#else // !__cplusplus
typedef struct _RXCE_ADDRESS_ {
    RXCE_SIGNATURE;
#endif // __cplusplus

    PRXCE_TRANSPORT             pTransport;          // the transport handle
    PTRANSPORT_ADDRESS          pTransportAddress;   // the transport address
    PVOID					    pContext;            // the context used in event dispatch
    PRXCE_ADDRESS_EVENT_HANDLER pHandler;            // the address event handler
    PMDL                        pReceiveMdl;         // the MDL for handling Receives Supplied by client
    HANDLE                      hAddress;            // handle to the address object
    PFILE_OBJECT                pFileObject;         // the file object for the address
    LONG                        ConnectionCount;     // no. of connections
    LONG                        VirtualCircuitCount; // no. of vcs
} RXCE_ADDRESS;

#define RXCE_ADDRESS_SIGNATURE ((sizeof(RXCE_ADDRESS) << 16) | RDBSS_NTC_RXCE_ADDRESS)

#define RxCeIsAddressValid(pAddress)    \
        ((pAddress)->Signature == RXCE_ADDRESS_SIGNATURE)

extern NTSTATUS
NTAPI
RxCeBuildAddress(
    IN OUT PRXCE_ADDRESS            pAddress,
    IN  PRXCE_TRANSPORT             pTransport,
    IN  PTRANSPORT_ADDRESS          pTransportAddress,
    IN  PRXCE_ADDRESS_EVENT_HANDLER pHandler,
    IN  PVOID                       pEventContext);

extern NTSTATUS
NTAPI
RxCeTearDownAddress(
    IN PRXCE_ADDRESS pAddress);

//
// RxCe Connection Establishment methods ....
//
//
// RXCE_CONNECTION encapsulates all the information w.r.t. a connection
// as regards the connection engine.
//

#ifdef __cplusplus
typedef struct _RXCE_CONNECTION_ : public RXCE_SIGNATURE {
#else // !__cplusplus
typedef struct _RXCE_CONNECTION_ {
    RXCE_SIGNATURE;
#endif // __cplusplus

    PRXCE_ADDRESS                   pAddress;            // the local address for this connection
    ULONG                           VirtualCircuitCount; // the number of virtual circuits associated with the connection
    PVOID			                pContext;            // the context used in event dispatch
    PRXCE_CONNECTION_EVENT_HANDLER  pHandler;            // the event handler for the connection
    PRXCE_CONNECTION_INFORMATION    pConnectionInformation; // the remote address ...
} RXCE_CONNECTION;

#define RXCE_CONNECTION_SIGNATURE ((sizeof(RXCE_CONNECTION) << 16) | RDBSS_NTC_RXCE_CONNECTION)

#define RxCeIsConnectionValid(pConnection)    \
        ((pConnection)->Signature == RXCE_CONNECTION_SIGNATURE)

//
// The following enumerated type defines the various choices presented for
// selecting the transport over which a connection should be established
//

typedef enum _RXCE_CONNECTION_CREATE_OPTIONS_ {
    RxCeSelectFirstSuccessfulTransport,
    RxCeSelectBestSuccessfulTransport,
    RxCeSelectAllSuccessfulTransports
} RXCE_CONNECTION_CREATE_OPTIONS,
  *PRXCE_CONNECTION_CREATE_OPTIONS;

typedef struct _RXCE_CONNECTION_COMPLETION_CONTEXT_ {
    NTSTATUS            Status;
    ULONG               AddressIndex;
    PRXCE_CONNECTION    pConnection;
    PRXCE_VC            pVc;
    RX_WORK_QUEUE_ITEM  WorkQueueItem;
    
    // This is used to pass the UNICODE DNS name returned back from TDI
    PRXCE_CONNECTION_INFORMATION pConnectionInformation;
} RXCE_CONNECTION_COMPLETION_CONTEXT,
  *PRXCE_CONNECTION_COMPLETION_CONTEXT;

typedef
NTSTATUS
(*PRXCE_CONNECTION_COMPLETION_ROUTINE)(
    PRXCE_CONNECTION_COMPLETION_CONTEXT pCompletionContext);

extern NTSTATUS
NTAPI
RxCeBuildConnection(
    IN  PRXCE_ADDRESS                           pLocalAddress,
    IN  PRXCE_CONNECTION_INFORMATION            pConnectionInformation,
    IN  PRXCE_CONNECTION_EVENT_HANDLER          pHandler,
    IN  PVOID                                   pEventContext,
    IN OUT PRXCE_CONNECTION                     pConnection,
    IN OUT PRXCE_VC                             pVc);

extern NTSTATUS
NTAPI
RxCeBuildConnectionOverMultipleTransports(
    IN OUT PRDBSS_DEVICE_OBJECT         pMiniRedirectorDeviceObject,
    IN  RXCE_CONNECTION_CREATE_OPTIONS  CreateOption,
    IN  ULONG                           NumberOfAddresses,
    IN  PRXCE_ADDRESS                   *pLocalAddressPointers,
    IN  PUNICODE_STRING                 pServerName,
    IN  PRXCE_CONNECTION_INFORMATION    pConnectionInformation,
    IN  PRXCE_CONNECTION_EVENT_HANDLER  pHandler,
    IN  PVOID                           pEventContext,
    IN  PRXCE_CONNECTION_COMPLETION_ROUTINE     pCompletionRoutine,
    IN OUT PRXCE_CONNECTION_COMPLETION_CONTEXT  pCompletionContext);

extern NTSTATUS
NTAPI
RxCeTearDownConnection(
    IN PRXCE_CONNECTION pConnection);


extern NTSTATUS
NTAPI
RxCeCancelConnectRequest(
    IN  PRXCE_ADDRESS                pLocalAddress,
    IN  PUNICODE_STRING              pServerName,
    IN  PRXCE_CONNECTION_INFORMATION pConnectionInformation);


//
// RXCE_VC encapsulates all the information w.r.t a virtual circuit (VC)
// connection to a particular server as regards the connection engine.
//
// Typically one VC is associated with a connection. However, there are instances in
// which more than one VC can be associated with a connection. In order to efficiently
// handle the common case well and at the same time provide an extensible mechanism we
// define a collection data structure ( a list ) which subsumes the allocation for
// one virtual circuit. It is also imperative that we restrict the knowledge of
// how this collection is organized to as few methods as possible in order to
// enable optimization/restructuring of this data structure at a later time.
//

#define RXCE_VC_ACTIVE       ((LONG)0xaa)
#define RXCE_VC_DISCONNECTED ((LONG)0xdd)
#define RXCE_VC_TEARDOWN     ((LONG)0xbb)

#ifdef __cplusplus
typedef struct _RXCE_VC_ : public RXCE_SIGNATURE {
#else // !__cplusplus
typedef struct _RXCE_VC_ {
    RXCE_SIGNATURE;
#endif // __cplusplus

    PRXCE_CONNECTION         pConnection;         // the referenced connection instance
    HANDLE                   hEndpoint;           // local endpoint for the connection
    PFILE_OBJECT             pEndpointFileObject; // the end point file object.
    __volatile LONG                     State;               // status of the Vc.
    CONNECTION_CONTEXT       ConnectionId;        // local endpoint for the connection.
    PMDL                     pReceiveMdl;         // the MDl for handling receives.
    PKEVENT                  pCleanUpEvent;       // sychronize event for clean up transports
} RXCE_VC;

#define RXCE_VC_SIGNATURE ((sizeof(RXCE_VC) << 16) | RDBSS_NTC_RXCE_VC)

#define RxCeIsVcValid(pVc)    \
        ((pVc)->Signature == RXCE_VC_SIGNATURE)

extern NTSTATUS
NTAPI
RxCeBuildVC(
    IN OUT PRXCE_VC         pVc,
    IN     PRXCE_CONNECTION Connection);

extern NTSTATUS
NTAPI
RxCeTearDownVC(
    IN PRXCE_VC  pVc);

extern NTSTATUS
NTAPI
RxCeInitiateVCDisconnect(
    IN PRXCE_VC  pVc);

extern NTSTATUS
NTAPI
RxCeQueryInformation(
    IN PRXCE_VC                          pVc,
    IN RXCE_CONNECTION_INFORMATION_CLASS InformationClass,
    OUT PVOID                            pInformation,
    IN ULONG                             Length);

//
// RxCe Data transmission methods
//

//
// Send options
//
// The following flags are equivalent to the TDI flags. In addition
// there are RXCE specific flags which are defined from the other end of
// a dword.
//

#define RXCE_SEND_EXPEDITED            TDI_SEND_EXPEDITED
#define RXCE_SEND_NO_RESPONSE_EXPECTED TDI_SEND_NO_RESPONSE_EXPECTED
#define RXCE_SEND_NON_BLOCKING         TDI_SEND_NON_BLOCKING

//
// The ASYNCHRONOUS and SYNCHRONOUS option available RxCeSend and RxCeSendDatagram
// distinguish between two situations. In the asynchronous case control returns to
// the caller once the request has been successfully submitted to the underlying
// transport. The results for any given request are communicated back using the
// SendCompletion  callback routine. The pCompletionContext parameter in RxCeSend and
// RxCeSendDatagram is passed back in the callback routine to assist the caller in
// disambiguating the requests.
//
// In the synchronous case the request is submitted to the underlying transport and the
// control does not return to the caller till the request completes.
//
// Note that in the synchrnous case the pCompletionContext parameter is ignored and the
// status that is returned correpsonds to the completion status of the operations.
//
// The benefit of ASYNCHRONOUS and SYNCHRONOUS options depends on the underlying
// transport. In a Virtual Circuit environment a SYNCHRONOUS option implies that the
// control does not return till the data reaches the server. On the other hand
// for datagram oriented transports there is very little difference between the two.
//

#define RXCE_FLAGS_MASK (0xff000000)

#define RXCE_SEND_SYNCHRONOUS (0x10000000)

// The following bit signifies if an RX_MEM_DESC(MDL) is to be sent in its entirety
// or only portions of it need to be sent.

#define RXCE_SEND_PARTIAL     (0x20000000)

extern NTSTATUS
NTAPI
RxCeSend(
    IN PRXCE_VC          pVc,
    IN ULONG             SendOptions,
    IN PMDL              pMdl,
    IN ULONG             SendLength,
    IN PVOID             pCompletionContext);

extern NTSTATUS
NTAPI
RxCeSendDatagram(
    IN PRXCE_ADDRESS                hAddress,
    IN PRXCE_CONNECTION_INFORMATION pConnectionInformation,
    IN ULONG                        SendOptions,
    IN PMDL                         pMdl,
    IN ULONG                        SendLength,
    IN PVOID                        pCompletionContext);

extern PIRP 
RxCeAllocateIrpWithMDL(
    IN CCHAR   StackSize,
    IN BOOLEAN ChargeQuota,
    IN PMDL    Buffer);

extern VOID 
RxCeFreeIrp(PIRP pIrp);


#endif  // _RXCE_H_

#elif (NTDDI_VERSION >= NTDDI_WS03)

/*++ BUILD Version: 0009    // Increment this if a change has global effects
Copyright (c) 1987-1993  Microsoft Corporation

Module Name:

    rxce.h

Abstract:

    This is the include file that defines all constants and types for
    accessing the redirector file system connection engine.

Revision History:
Notes:

    The Connection engine is designed to map and emulate the TDI specs. as closely
    as possible. This implies that on NT we will have a very efficient mechanism
    which fully exploits the underlying TDI implementation.

    There are four important data structures that are created/manipulated by the
    various functions associated with the connection engine. Thesr are
    RXCE_TRANSPORT,RXCE_ADDRESS,RXCE_CONNECTION and RXCE_VC.

    The mini redirector writers can embed these data structures in the corresponding
    definitions and invoke the two routines provided for each type to build and
    tear down the connection engine portions. These routines do not allocate/free
    the memory associated with these instances. This provides a flexible mechanism
    for the mini redirector writers to manage instances.

--*/

#ifndef _RXCE_H_
#define _RXCE_H_

#include <nodetype.h>
#include <rxcehdlr.h>    // TDI related definitions.
#include <rxworkq.h>
//
// The connection engine deals with three kinds of entities, transports, transport
// addresses and transport connections. The transports are bindings to the various
// transport service providers on any system. The transport addresses are the
// local connection end points. The connections are transport connections between
// endpoints.  Each connection encapsulates a  number of virtual circuits
// ( typically 1 ).
//

// All the four node types are tagged with  the following signature which is used
// extensively in validating them

typedef struct _RXCE_SIGNATURE_ {
    union {
        struct {
            USHORT  Type;
            CSHORT  Size;
        };

        ULONG   Signature;
    };
} RXCE_SIGNATURE, *PRXCE_SIGNATURE;

//
// RXCE_TRANSPORT encapsulates all the parameters w.r.t. a TRANSPORT
// as regards the connection engine.
//

#ifdef __cplusplus
typedef struct _RXCE_TRANSPORT_ : public RXCE_SIGNATURE {
#else // !__cplusplus
typedef struct _RXCE_TRANSPORT_ {
    RXCE_SIGNATURE;
#endif // __cplusplus

    UNICODE_STRING                Name;

    PDEVICE_OBJECT                pDeviceObject;             // Device object for transport
    HANDLE                        ControlChannel;            // Control Channel
    PFILE_OBJECT                  pControlChannelFileObject; // File object for the control channel

    PRXCE_TRANSPORT_PROVIDER_INFO pProviderInfo;             // Transport Provider Information.

    LONG                          ConnectionCount;           // Number of connections on xport.
    LONG                          VirtualCircuitCount;       // no. of connections
    ULONG                         QualityOfService;          // quality of service provided.
} RXCE_TRANSPORT;

#define RXCE_TRANSPORT_SIGNATURE ((sizeof(RXCE_TRANSPORT) << 16) | RDBSS_NTC_RXCE_TRANSPORT)

#define RxCeIsTransportValid(pTransport)    \
        ((pTransport)->Signature == RXCE_TRANSPORT_SIGNATURE)

extern NTSTATUS
NTAPI
RxCeBuildTransport(
    IN PRXCE_TRANSPORT pRxCeTransport,
    IN PUNICODE_STRING pTransportName,
    IN ULONG           QualityOfService);

extern NTSTATUS
NTAPI
RxCeTearDownTransport(
    IN PRXCE_TRANSPORT pTransport);

extern NTSTATUS
RxCeQueryAdapterStatus(
    PRXCE_TRANSPORT         pTransport,
    struct _ADAPTER_STATUS *pAdapterStatus);

extern NTSTATUS
RxCeQueryTransportInformation(
    PRXCE_TRANSPORT             pTransport,
    PRXCE_TRANSPORT_INFORMATION pTransportInformation);

//
// RXCE_ADDRESS encapsulates all the parameters w.r.t. a local transport address
// as regards the connection engine.
//

#ifdef __cplusplus
typedef struct _RXCE_ADDRESS_ : public RXCE_SIGNATURE {
#else // !__cplusplus
typedef struct _RXCE_ADDRESS_ {
    RXCE_SIGNATURE;
#endif // __cplusplus

    PRXCE_TRANSPORT             pTransport;          // the transport handle
    PTRANSPORT_ADDRESS          pTransportAddress;   // the transport address
    PVOID					    pContext;            // the context used in event dispatch
    PRXCE_ADDRESS_EVENT_HANDLER pHandler;            // the address event handler
    PMDL                        pReceiveMdl;         // the MDL for handling Receives Supplied by client
    HANDLE                      hAddress;            // handle to the address object
    PFILE_OBJECT                pFileObject;         // the file object for the address
    LONG                        ConnectionCount;     // no. of connections
    LONG                        VirtualCircuitCount; // no. of vcs
} RXCE_ADDRESS;

#define RXCE_ADDRESS_SIGNATURE ((sizeof(RXCE_ADDRESS) << 16) | RDBSS_NTC_RXCE_ADDRESS)

#define RxCeIsAddressValid(pAddress)    \
        ((pAddress)->Signature == RXCE_ADDRESS_SIGNATURE)

extern NTSTATUS
NTAPI
RxCeBuildAddress(
    IN OUT PRXCE_ADDRESS            pAddress,
    IN  PRXCE_TRANSPORT             pTransport,
    IN  PTRANSPORT_ADDRESS          pTransportAddress,
    IN  PRXCE_ADDRESS_EVENT_HANDLER pHandler,
    IN  PVOID                       pEventContext);

extern NTSTATUS
NTAPI
RxCeTearDownAddress(
    IN PRXCE_ADDRESS pAddress);

//
// RxCe Connection Establishment methods ....
//
//
// RXCE_CONNECTION encapsulates all the information w.r.t. a connection
// as regards the connection engine.
//

#ifdef __cplusplus
typedef struct _RXCE_CONNECTION_ : public RXCE_SIGNATURE {
#else // !__cplusplus
typedef struct _RXCE_CONNECTION_ {
    RXCE_SIGNATURE;
#endif // __cplusplus

    PRXCE_ADDRESS                   pAddress;            // the local address for this connection
    ULONG                           VirtualCircuitCount; // the number of virtual circuits associated with the connection
    PVOID			                pContext;            // the context used in event dispatch
    PRXCE_CONNECTION_EVENT_HANDLER  pHandler;            // the event handler for the connection
    PRXCE_CONNECTION_INFORMATION    pConnectionInformation; // the remote address ...
} RXCE_CONNECTION;

#define RXCE_CONNECTION_SIGNATURE ((sizeof(RXCE_CONNECTION) << 16) | RDBSS_NTC_RXCE_CONNECTION)

#define RxCeIsConnectionValid(pConnection)    \
        ((pConnection)->Signature == RXCE_CONNECTION_SIGNATURE)

//
// The following enumerated type defines the various choices presented for
// selecting the transport over which a connection should be established
//

typedef enum _RXCE_CONNECTION_CREATE_OPTIONS_ {
    RxCeSelectFirstSuccessfulTransport,
    RxCeSelectBestSuccessfulTransport,
    RxCeSelectAllSuccessfulTransports
} RXCE_CONNECTION_CREATE_OPTIONS,
  *PRXCE_CONNECTION_CREATE_OPTIONS;

typedef struct _RXCE_CONNECTION_COMPLETION_CONTEXT_ {
    NTSTATUS            Status;
    ULONG               AddressIndex;
    PRXCE_CONNECTION    pConnection;
    PRXCE_VC            pVc;
    RX_WORK_QUEUE_ITEM  WorkQueueItem;
    
    // This is used to pass the UNICODE DNS name returned back from TDI
    PRXCE_CONNECTION_INFORMATION pConnectionInformation;
} RXCE_CONNECTION_COMPLETION_CONTEXT,
  *PRXCE_CONNECTION_COMPLETION_CONTEXT;

typedef
NTSTATUS
(*PRXCE_CONNECTION_COMPLETION_ROUTINE)(
    PRXCE_CONNECTION_COMPLETION_CONTEXT pCompletionContext);

extern NTSTATUS
NTAPI
RxCeBuildConnection(
    IN  PRXCE_ADDRESS                           pLocalAddress,
    IN  PRXCE_CONNECTION_INFORMATION            pConnectionInformation,
    IN  PRXCE_CONNECTION_EVENT_HANDLER          pHandler,
    IN  PVOID                                   pEventContext,
    IN OUT PRXCE_CONNECTION                     pConnection,
    IN OUT PRXCE_VC                             pVc);

extern NTSTATUS
NTAPI
RxCeBuildConnectionOverMultipleTransports(
    IN OUT PRDBSS_DEVICE_OBJECT         pMiniRedirectorDeviceObject,
    IN  RXCE_CONNECTION_CREATE_OPTIONS  CreateOption,
    IN  ULONG                           NumberOfAddresses,
    IN  PRXCE_ADDRESS                   *pLocalAddressPointers,
    IN  PUNICODE_STRING                 pServerName,
    IN  PRXCE_CONNECTION_INFORMATION    pConnectionInformation,
    IN  PRXCE_CONNECTION_EVENT_HANDLER  pHandler,
    IN  PVOID                           pEventContext,
    IN  PRXCE_CONNECTION_COMPLETION_ROUTINE     pCompletionRoutine,
    IN OUT PRXCE_CONNECTION_COMPLETION_CONTEXT  pCompletionContext);

extern NTSTATUS
NTAPI
RxCeTearDownConnection(
    IN PRXCE_CONNECTION pConnection);


extern NTSTATUS
NTAPI
RxCeCancelConnectRequest(
    IN  PRXCE_ADDRESS                pLocalAddress,
    IN  PUNICODE_STRING              pServerName,
    IN  PRXCE_CONNECTION_INFORMATION pConnectionInformation);


//
// RXCE_VC encapsulates all the information w.r.t a virtual circuit (VC)
// connection to a particular server as regards the connection engine.
//
// Typically one VC is associated with a connection. However, there are instances in
// which more than one VC can be associated with a connection. In order to efficiently
// handle the common case well and at the same time provide an extensible mechanism we
// define a collection data structure ( a list ) which subsumes the allocation for
// one virtual circuit. It is also imperative that we restrict the knowledge of
// how this collection is organized to as few methods as possible in order to
// enable optimization/restructuring of this data structure at a later time.
//

#define RXCE_VC_ACTIVE       ((LONG)0xaa)
#define RXCE_VC_DISCONNECTED ((LONG)0xdd)
#define RXCE_VC_TEARDOWN     ((LONG)0xbb)

#ifdef __cplusplus
typedef struct _RXCE_VC_ : public RXCE_SIGNATURE {
#else // !__cplusplus
typedef struct _RXCE_VC_ {
    RXCE_SIGNATURE;
#endif // __cplusplus

    PRXCE_CONNECTION         pConnection;         // the referenced connection instance
    HANDLE                   hEndpoint;           // local endpoint for the connection
    PFILE_OBJECT             pEndpointFileObject; // the end point file object.
    LONG                     State;               // status of the Vc.
    CONNECTION_CONTEXT       ConnectionId;        // local endpoint for the connection.
    PMDL                     pReceiveMdl;         // the MDl for handling receives.
    PKEVENT                  pCleanUpEvent;       // sychronize event for clean up transports
} RXCE_VC;

#define RXCE_VC_SIGNATURE ((sizeof(RXCE_VC) << 16) | RDBSS_NTC_RXCE_VC)

#define RxCeIsVcValid(pVc)    \
        ((pVc)->Signature == RXCE_VC_SIGNATURE)

extern NTSTATUS
NTAPI
RxCeBuildVC(
    IN OUT PRXCE_VC         pVc,
    IN     PRXCE_CONNECTION Connection);

extern NTSTATUS
NTAPI
RxCeTearDownVC(
    IN PRXCE_VC  pVc);

extern NTSTATUS
NTAPI
RxCeInitiateVCDisconnect(
    IN PRXCE_VC  pVc);

extern NTSTATUS
NTAPI
RxCeQueryInformation(
    IN PRXCE_VC                          pVc,
    IN RXCE_CONNECTION_INFORMATION_CLASS InformationClass,
    OUT PVOID                            pInformation,
    IN ULONG                             Length);

//
// RxCe Data transmission methods
//

//
// Send options
//
// The following flags are equivalent to the TDI flags. In addition
// there are RXCE specific flags which are defined from the other end of
// a dword.
//

#define RXCE_SEND_EXPEDITED            TDI_SEND_EXPEDITED
#define RXCE_SEND_NO_RESPONSE_EXPECTED TDI_SEND_NO_RESPONSE_EXPECTED
#define RXCE_SEND_NON_BLOCKING         TDI_SEND_NON_BLOCKING

//
// The ASYNCHRONOUS and SYNCHRONOUS option available RxCeSend and RxCeSendDatagram
// distinguish between two situations. In the asynchronous case control returns to
// the caller once the request has been successfully submitted to the underlying
// transport. The results for any given request are communicated back using the
// SendCompletion  callback routine. The pCompletionContext parameter in RxCeSend and
// RxCeSendDatagram is passed back in the callback routine to assist the caller in
// disambiguating the requests.
//
// In the synchronous case the request is submitted to the underlying transport and the
// control does not return to the caller till the request completes.
//
// Note that in the synchrnous case the pCompletionContext parameter is ignored and the
// status that is returned correpsonds to the completion status of the operations.
//
// The benefit of ASYNCHRONOUS and SYNCHRONOUS options depends on the underlying
// transport. In a Virtual Circuit environment a SYNCHRONOUS option implies that the
// control does not return till the data reaches the server. On the other hand
// for datagram oriented transports there is very little difference between the two.
//

#define RXCE_FLAGS_MASK (0xff000000)

#define RXCE_SEND_SYNCHRONOUS (0x10000000)

// The following bit signifies if an RX_MEM_DESC(MDL) is to be sent in its entirety
// or only portions of it need to be sent.

#define RXCE_SEND_PARTIAL     (0x20000000)

extern NTSTATUS
NTAPI
RxCeSend(
    IN PRXCE_VC          pVc,
    IN ULONG             SendOptions,
    IN PMDL              pMdl,
    IN ULONG             SendLength,
    IN PVOID             pCompletionContext);

extern NTSTATUS
NTAPI
RxCeSendDatagram(
    IN PRXCE_ADDRESS                hAddress,
    IN PRXCE_CONNECTION_INFORMATION pConnectionInformation,
    IN ULONG                        SendOptions,
    IN PMDL                         pMdl,
    IN ULONG                        SendLength,
    IN PVOID                        pCompletionContext);

extern PIRP 
RxCeAllocateIrpWithMDL(
    IN CCHAR   StackSize,
    IN BOOLEAN ChargeQuota,
    IN PMDL    Buffer);

extern VOID 
RxCeFreeIrp(PIRP pIrp);


#endif  // _RXCE_H_


#elif (NTDDI_VERSION >= NTDDI_WINXP)

/*++ BUILD Version: 0009    // Increment this if a change has global effects
Copyright (c) 1987-1993  Microsoft Corporation

Module Name:

    rxce.h

Abstract:

    This is the include file that defines all constants and types for
    accessing the redirector file system connection engine.

Revision History:
Notes:

    The Connection engine is designed to map and emulate the TDI specs. as closely
    as possible. This implies that on NT we will have a very efficient mechanism
    which fully exploits the underlying TDI implementation.

    There are four important data structures that are created/manipulated by the
    various functions associated with the connection engine. Thesr are
    RXCE_TRANSPORT,RXCE_ADDRESS,RXCE_CONNECTION and RXCE_VC.

    The mini redirector writers can embed these data structures in the corresponding
    definitions and invoke the two routines provided for each type to build and
    tear down the connection engine portions. These routines do not allocate/free
    the memory associated with these instances. This provides a flexible mechanism
    for the mini redirector writers to manage instances.

--*/

#ifndef _RXCE_H_
#define _RXCE_H_

#include <nodetype.h>
#include <rxcehdlr.h>    // TDI related definitions.
#include <rxworkq.h>
//
// The connection engine deals with three kinds of entities, transports, transport
// addresses and transport connections. The transports are bindings to the various
// transport service providers on any system. The transport addresses are the
// local connection end points. The connections are transport connections between
// endpoints.  Each connection encapsulates a  number of virtual circuits
// ( typically 1 ).
//

// All the four node types are tagged with  the following signature which is used
// extensively in validating them

typedef struct _RXCE_SIGNATURE_ {
    union {
        struct {
            USHORT  Type;
            CSHORT  Size;
        };

        ULONG   Signature;
    };
} RXCE_SIGNATURE, *PRXCE_SIGNATURE;

//
// RXCE_TRANSPORT encapsulates all the parameters w.r.t. a TRANSPORT
// as regards the connection engine.
//

#ifdef __cplusplus
typedef struct _RXCE_TRANSPORT_ : public RXCE_SIGNATURE {
#else // !__cplusplus
typedef struct _RXCE_TRANSPORT_ {
    RXCE_SIGNATURE;
#endif // __cplusplus

    UNICODE_STRING                Name;

    PDEVICE_OBJECT                pDeviceObject;             // Device object for transport
    HANDLE                        ControlChannel;            // Control Channel
    PFILE_OBJECT                  pControlChannelFileObject; // File object for the control channel

    PRXCE_TRANSPORT_PROVIDER_INFO pProviderInfo;             // Transport Provider Information.

    LONG                          ConnectionCount;           // Number of connections on xport.
    LONG                          VirtualCircuitCount;       // no. of connections
    ULONG                         QualityOfService;          // quality of service provided.
} RXCE_TRANSPORT;

#define RXCE_TRANSPORT_SIGNATURE ((sizeof(RXCE_TRANSPORT) << 16) | RDBSS_NTC_RXCE_TRANSPORT)

#define RxCeIsTransportValid(pTransport)    \
        ((pTransport)->Signature == RXCE_TRANSPORT_SIGNATURE)

extern NTSTATUS
NTAPI
RxCeBuildTransport(
    IN PRXCE_TRANSPORT pRxCeTransport,
    IN PUNICODE_STRING pTransportName,
    IN ULONG           QualityOfService);

extern NTSTATUS
NTAPI
RxCeTearDownTransport(
    IN PRXCE_TRANSPORT pTransport);

extern NTSTATUS
RxCeQueryAdapterStatus(
    PRXCE_TRANSPORT         pTransport,
    struct _ADAPTER_STATUS *pAdapterStatus);

extern NTSTATUS
RxCeQueryTransportInformation(
    PRXCE_TRANSPORT             pTransport,
    PRXCE_TRANSPORT_INFORMATION pTransportInformation);

//
// RXCE_ADDRESS encapsulates all the parameters w.r.t. a local transport address
// as regards the connection engine.
//

#ifdef __cplusplus
typedef struct _RXCE_ADDRESS_ : public RXCE_SIGNATURE {
#else // !__cplusplus
typedef struct _RXCE_ADDRESS_ {
    RXCE_SIGNATURE;
#endif // __cplusplus

    PRXCE_TRANSPORT             pTransport;          // the transport handle
    PTRANSPORT_ADDRESS          pTransportAddress;   // the transport address
    PVOID					    pContext;            // the context used in event dispatch
    PRXCE_ADDRESS_EVENT_HANDLER pHandler;            // the address event handler
    PMDL                        pReceiveMdl;         // the MDL for handling Receives Supplied by client
    HANDLE                      hAddress;            // handle to the address object
    PFILE_OBJECT                pFileObject;         // the file object for the address
    LONG                        ConnectionCount;     // no. of connections
    LONG                        VirtualCircuitCount; // no. of vcs
} RXCE_ADDRESS;

#define RXCE_ADDRESS_SIGNATURE ((sizeof(RXCE_ADDRESS) << 16) | RDBSS_NTC_RXCE_ADDRESS)

#define RxCeIsAddressValid(pAddress)    \
        ((pAddress)->Signature == RXCE_ADDRESS_SIGNATURE)

extern NTSTATUS
NTAPI
RxCeBuildAddress(
    IN OUT PRXCE_ADDRESS            pAddress,
    IN  PRXCE_TRANSPORT             pTransport,
    IN  PTRANSPORT_ADDRESS          pTransportAddress,
    IN  PRXCE_ADDRESS_EVENT_HANDLER pHandler,
    IN  PVOID                       pEventContext);

extern NTSTATUS
NTAPI
RxCeTearDownAddress(
    IN PRXCE_ADDRESS pAddress);

//
// RxCe Connection Establishment methods ....
//
//
// RXCE_CONNECTION encapsulates all the information w.r.t. a connection
// as regards the connection engine.
//

#ifdef __cplusplus
typedef struct _RXCE_CONNECTION_ : public RXCE_SIGNATURE {
#else // !__cplusplus
typedef struct _RXCE_CONNECTION_ {
    RXCE_SIGNATURE;
#endif // __cplusplus

    PRXCE_ADDRESS                   pAddress;            // the local address for this connection
    ULONG                           VirtualCircuitCount; // the number of virtual circuits associated with the connection
    PVOID			                pContext;            // the context used in event dispatch
    PRXCE_CONNECTION_EVENT_HANDLER  pHandler;            // the event handler for the connection
    PRXCE_CONNECTION_INFORMATION    pConnectionInformation; // the remote address ...
} RXCE_CONNECTION;

#define RXCE_CONNECTION_SIGNATURE ((sizeof(RXCE_CONNECTION) << 16) | RDBSS_NTC_RXCE_CONNECTION)

#define RxCeIsConnectionValid(pConnection)    \
        ((pConnection)->Signature == RXCE_CONNECTION_SIGNATURE)

//
// The following enumerated type defines the various choices presented for
// selecting the transport over which a connection should be established
//

typedef enum _RXCE_CONNECTION_CREATE_OPTIONS_ {
    RxCeSelectFirstSuccessfulTransport,
    RxCeSelectBestSuccessfulTransport,
    RxCeSelectAllSuccessfulTransports
} RXCE_CONNECTION_CREATE_OPTIONS,
  *PRXCE_CONNECTION_CREATE_OPTIONS;

typedef struct _RXCE_CONNECTION_COMPLETION_CONTEXT_ {
    NTSTATUS            Status;
    ULONG               AddressIndex;
    PRXCE_CONNECTION    pConnection;
    PRXCE_VC            pVc;
    RX_WORK_QUEUE_ITEM  WorkQueueItem;
    
    // This is used to pass the UNICODE DNS name returned back from TDI
    PRXCE_CONNECTION_INFORMATION pConnectionInformation;
} RXCE_CONNECTION_COMPLETION_CONTEXT,
  *PRXCE_CONNECTION_COMPLETION_CONTEXT;

typedef
NTSTATUS
(*PRXCE_CONNECTION_COMPLETION_ROUTINE)(
    PRXCE_CONNECTION_COMPLETION_CONTEXT pCompletionContext);

extern NTSTATUS
NTAPI
RxCeBuildConnection(
    IN  PRXCE_ADDRESS                           pLocalAddress,
    IN  PRXCE_CONNECTION_INFORMATION            pConnectionInformation,
    IN  PRXCE_CONNECTION_EVENT_HANDLER          pHandler,
    IN  PVOID                                   pEventContext,
    IN OUT PRXCE_CONNECTION                     pConnection,
    IN OUT PRXCE_VC                             pVc);

extern NTSTATUS
NTAPI
RxCeBuildConnectionOverMultipleTransports(
    IN OUT PRDBSS_DEVICE_OBJECT         pMiniRedirectorDeviceObject,
    IN  RXCE_CONNECTION_CREATE_OPTIONS  CreateOption,
    IN  ULONG                           NumberOfAddresses,
    IN  PRXCE_ADDRESS                   *pLocalAddressPointers,
    IN  PUNICODE_STRING                 pServerName,
    IN  PRXCE_CONNECTION_INFORMATION    pConnectionInformation,
    IN  PRXCE_CONNECTION_EVENT_HANDLER  pHandler,
    IN  PVOID                           pEventContext,
    IN  PRXCE_CONNECTION_COMPLETION_ROUTINE     pCompletionRoutine,
    IN OUT PRXCE_CONNECTION_COMPLETION_CONTEXT  pCompletionContext);

extern NTSTATUS
NTAPI
RxCeTearDownConnection(
    IN PRXCE_CONNECTION pConnection);


extern NTSTATUS
NTAPI
RxCeCancelConnectRequest(
    IN  PRXCE_ADDRESS                pLocalAddress,
    IN  PUNICODE_STRING              pServerName,
    IN  PRXCE_CONNECTION_INFORMATION pConnectionInformation);


//
// RXCE_VC encapsulates all the information w.r.t a virtual circuit (VC)
// connection to a particular server as regards the connection engine.
//
// Typically one VC is associated with a connection. However, there are instances in
// which more than one VC can be associated with a connection. In order to efficiently
// handle the common case well and at the same time provide an extensible mechanism we
// define a collection data structure ( a list ) which subsumes the allocation for
// one virtual circuit. It is also imperative that we restrict the knowledge of
// how this collection is organized to as few methods as possible in order to
// enable optimization/restructuring of this data structure at a later time.
//

#define RXCE_VC_ACTIVE       ((LONG)0xaa)
#define RXCE_VC_DISCONNECTED ((LONG)0xdd)
#define RXCE_VC_TEARDOWN     ((LONG)0xbb)

#ifdef __cplusplus
typedef struct _RXCE_VC_ : public RXCE_SIGNATURE {
#else // !__cplusplus
typedef struct _RXCE_VC_ {
    RXCE_SIGNATURE;
#endif // __cplusplus

    PRXCE_CONNECTION         pConnection;         // the referenced connection instance
    HANDLE                   hEndpoint;           // local endpoint for the connection
    PFILE_OBJECT             pEndpointFileObject; // the end point file object.
    LONG                     State;               // status of the Vc.
    CONNECTION_CONTEXT       ConnectionId;        // local endpoint for the connection.
    PMDL                     pReceiveMdl;         // the MDl for handling receives.
    PKEVENT                  pCleanUpEvent;       // sychronize event for clean up transports
} RXCE_VC;

#define RXCE_VC_SIGNATURE ((sizeof(RXCE_VC) << 16) | RDBSS_NTC_RXCE_VC)

#define RxCeIsVcValid(pVc)    \
        ((pVc)->Signature == RXCE_VC_SIGNATURE)

extern NTSTATUS
NTAPI
RxCeBuildVC(
    IN OUT PRXCE_VC         pVc,
    IN     PRXCE_CONNECTION Connection);

extern NTSTATUS
NTAPI
RxCeTearDownVC(
    IN PRXCE_VC  pVc);

extern NTSTATUS
NTAPI
RxCeInitiateVCDisconnect(
    IN PRXCE_VC  pVc);

extern NTSTATUS
NTAPI
RxCeQueryInformation(
    IN PRXCE_VC                          pVc,
    IN RXCE_CONNECTION_INFORMATION_CLASS InformationClass,
    OUT PVOID                            pInformation,
    IN ULONG                             Length);

//
// RxCe Data transmission methods
//

//
// Send options
//
// The following flags are equivalent to the TDI flags. In addition
// there are RXCE specific flags which are defined from the other end of
// a dword.
//

#define RXCE_SEND_EXPEDITED            TDI_SEND_EXPEDITED
#define RXCE_SEND_NO_RESPONSE_EXPECTED TDI_SEND_NO_RESPONSE_EXPECTED
#define RXCE_SEND_NON_BLOCKING         TDI_SEND_NON_BLOCKING

//
// The ASYNCHRONOUS and SYNCHRONOUS option available RxCeSend and RxCeSendDatagram
// distinguish between two situations. In the asynchronous case control returns to
// the caller once the request has been successfully submitted to the underlying
// transport. The results for any given request are communicated back using the
// SendCompletion  callback routine. The pCompletionContext parameter in RxCeSend and
// RxCeSendDatagram is passed back in the callback routine to assist the caller in
// disambiguating the requests.
//
// In the synchronous case the request is submitted to the underlying transport and the
// control does not return to the caller till the request completes.
//
// Note that in the synchrnous case the pCompletionContext parameter is ignored and the
// status that is returned correpsonds to the completion status of the operations.
//
// The benefit of ASYNCHRONOUS and SYNCHRONOUS options depends on the underlying
// transport. In a Virtual Circuit environment a SYNCHRONOUS option implies that the
// control does not return till the data reaches the server. On the other hand
// for datagram oriented transports there is very little difference between the two.
//

#define RXCE_FLAGS_MASK (0xff000000)

#define RXCE_SEND_SYNCHRONOUS (0x10000000)

// The following bit signifies if an RX_MEM_DESC(MDL) is to be sent in its entirety
// or only portions of it need to be sent.

#define RXCE_SEND_PARTIAL     (0x20000000)
#define RXCE_INVOKE_SEND_SUBMITTED_HANDLER (0x40000000)

extern NTSTATUS
NTAPI
RxCeSend(
    IN PRXCE_VC          pVc,
    IN ULONG             SendOptions,
    IN PMDL              pMdl,
    IN ULONG             SendLength,
    IN PVOID             pCompletionContext);

extern NTSTATUS
NTAPI
RxCeSendDatagram(
    IN PRXCE_ADDRESS                hAddress,
    IN PRXCE_CONNECTION_INFORMATION pConnectionInformation,
    IN ULONG                        SendOptions,
    IN PMDL                         pMdl,
    IN ULONG                        SendLength,
    IN PVOID                        pCompletionContext);

extern PIRP 
RxCeAllocateIrpWithMDL(
    IN CCHAR   StackSize,
    IN BOOLEAN ChargeQuota,
    IN PMDL    Buffer);

extern VOID 
RxCeFreeIrp(PIRP pIrp);


#endif  // _RXCE_H_


#elif (NTDDI_VERSION >= NTDDI_WIN2K)

/*++ BUILD Version: 0009    // Increment this if a change has global effects
Copyright (c) 1987-1993  Microsoft Corporation

Module Name:

    rxce.h

Abstract:

    This is the include file that defines all constants and types for
    accessing the redirector file system connection engine.

Revision History:
Notes:

    The Connection engine is designed to map and emulate the TDI specs. as closely
    as possible. This implies that on NT we will have a very efficient mechanism
    which fully exploits the underlying TDI implementation.

    There are four important data structures that are created/manipulated by the
    various functions associated with the connection engine. Thesr are
    RXCE_TRANSPORT,RXCE_ADDRESS,RXCE_CONNECTION and RXCE_VC.

    The mini redirector writers can embed these data structures in the corresponding
    definitions and invoke the two routines provided for each type to build and
    tear down the connection engine portions. These routines do not allocate/free
    the memory associated with these instances. This provides a flexible mechanism
    for the mini redirector writers to manage instances.

--*/

#ifndef _RXCE_H_
#define _RXCE_H_

#include <nodetype.h>
#include <rxcehdlr.h>    // TDI related definitions.
#include <rxworkq.h>
//
// The connection engine deals with three kinds of entities, transports, transport
// addresses and transport connections. The transports are bindings to the various
// transport service providers on any system. The transport addresses are the
// local connection end points. The connections are transport connections between
// endpoints.  Each connection encapsulates a  number of virtual circuits
// ( typically 1 ).
//

// All the four node types are tagged with  the following signature which is used
// extensively in validating them

typedef struct _RXCE_SIGNATURE_ {
    union {
        struct {
            USHORT  Type;
            CSHORT  Size;
        };

        ULONG   Signature;
    };
} RXCE_SIGNATURE, *PRXCE_SIGNATURE;

//
// RXCE_TRANSPORT encapsulates all the parameters w.r.t. a TRANSPORT
// as regards the connection engine.
//

typedef struct _RXCE_TRANSPORT_ {
    RXCE_SIGNATURE;

    UNICODE_STRING                Name;

    PDEVICE_OBJECT                pDeviceObject;             // Device object for transport
    HANDLE                        ControlChannel;            // Control Channel
    PFILE_OBJECT                  pControlChannelFileObject; // File object for the control channel

    PRXCE_TRANSPORT_PROVIDER_INFO pProviderInfo;             // Transport Provider Information.

    LONG                          ConnectionCount;           // Number of connections on xport.
    LONG                          VirtualCircuitCount;       // no. of connections
    ULONG                         QualityOfService;          // quality of service provided.
} RXCE_TRANSPORT;

#define RXCE_TRANSPORT_SIGNATURE ((sizeof(RXCE_TRANSPORT) << 16) | RDBSS_NTC_RXCE_TRANSPORT)

#define RxCeIsTransportValid(pTransport)    \
        ((pTransport)->Signature == RXCE_TRANSPORT_SIGNATURE)

extern NTSTATUS
NTAPI
RxCeBuildTransport(
    IN PRXCE_TRANSPORT pRxCeTransport,
    IN PUNICODE_STRING pTransportName,
    IN ULONG           QualityOfService);

extern NTSTATUS
NTAPI
RxCeTearDownTransport(
    IN PRXCE_TRANSPORT pTransport);

extern NTSTATUS
RxCeQueryAdapterStatus(
    PRXCE_TRANSPORT         pTransport,
    struct _ADAPTER_STATUS *pAdapterStatus);

extern NTSTATUS
RxCeQueryTransportInformation(
    PRXCE_TRANSPORT             pTransport,
    PRXCE_TRANSPORT_INFORMATION pTransportInformation);

//
// RXCE_ADDRESS encapsulates all the parameters w.r.t. a local transport address
// as regards the connection engine.
//

typedef struct _RXCE_ADDRESS_ {
    RXCE_SIGNATURE;

    PRXCE_TRANSPORT             pTransport;          // the transport handle
    PTRANSPORT_ADDRESS          pTransportAddress;   // the transport address
    PVOID					    pContext;            // the context used in event dispatch
    PRXCE_ADDRESS_EVENT_HANDLER pHandler;            // the address event handler
    PMDL                        pReceiveMdl;         // the MDL for handling Receives Supplied by client
    HANDLE                      hAddress;            // handle to the address object
    PFILE_OBJECT                pFileObject;         // the file object for the address
    LONG                        ConnectionCount;     // no. of connections
    LONG                        VirtualCircuitCount; // no. of vcs
} RXCE_ADDRESS;

#define RXCE_ADDRESS_SIGNATURE ((sizeof(RXCE_ADDRESS) << 16) | RDBSS_NTC_RXCE_ADDRESS)

#define RxCeIsAddressValid(pAddress)    \
        ((pAddress)->Signature == RXCE_ADDRESS_SIGNATURE)

extern NTSTATUS
NTAPI
RxCeBuildAddress(
    IN OUT PRXCE_ADDRESS            pAddress,
    IN  PRXCE_TRANSPORT             pTransport,
    IN  PTRANSPORT_ADDRESS          pTransportAddress,
    IN  PRXCE_ADDRESS_EVENT_HANDLER pHandler,
    IN  PVOID                       pEventContext);

extern NTSTATUS
NTAPI
RxCeTearDownAddress(
    IN PRXCE_ADDRESS pAddress);

//
// RxCe Connection Establishment methods ....
//
//
// RXCE_CONNECTION encapsulates all the information w.r.t. a connection
// as regards the connection engine.
//

typedef struct _RXCE_CONNECTION_ {
    RXCE_SIGNATURE;

    PRXCE_ADDRESS                   pAddress;            // the local address for this connection
    ULONG                           VirtualCircuitCount; // the number of virtual circuits associated with the connection
    PVOID			                pContext;            // the context used in event dispatch
    PRXCE_CONNECTION_EVENT_HANDLER  pHandler;            // the event handler for the connection
    PRXCE_CONNECTION_INFORMATION    pConnectionInformation; // the remote address ...
} RXCE_CONNECTION;

#define RXCE_CONNECTION_SIGNATURE ((sizeof(RXCE_CONNECTION) << 16) | RDBSS_NTC_RXCE_CONNECTION)

#define RxCeIsConnectionValid(pConnection)    \
        ((pConnection)->Signature == RXCE_CONNECTION_SIGNATURE)

//
// The following enumerated type defines the various choices presented for
// selecting the transport over which a connection should be established
//

typedef enum _RXCE_CONNECTION_CREATE_OPTIONS_ {
    RxCeSelectFirstSuccessfulTransport,
    RxCeSelectBestSuccessfulTransport,
    RxCeSelectAllSuccessfulTransports
} RXCE_CONNECTION_CREATE_OPTIONS,
  *PRXCE_CONNECTION_CREATE_OPTIONS;

typedef struct _RXCE_CONNECTION_COMPLETION_CONTEXT_ {
    NTSTATUS            Status;
    ULONG               AddressIndex;
    PRXCE_CONNECTION    pConnection;
    PRXCE_VC            pVc;
    RX_WORK_QUEUE_ITEM  WorkQueueItem;
} RXCE_CONNECTION_COMPLETION_CONTEXT,
  *PRXCE_CONNECTION_COMPLETION_CONTEXT;

typedef
NTSTATUS
(*PRXCE_CONNECTION_COMPLETION_ROUTINE)(
    PRXCE_CONNECTION_COMPLETION_CONTEXT pCompletionContext);

extern NTSTATUS
NTAPI
RxCeBuildConnection(
    IN  PRXCE_ADDRESS                           pLocalAddress,
    IN  PRXCE_CONNECTION_INFORMATION            pConnectionInformation,
    IN  PRXCE_CONNECTION_EVENT_HANDLER          pHandler,
    IN  PVOID                                   pEventContext,
    IN OUT PRXCE_CONNECTION                     pConnection,
    IN OUT PRXCE_VC                             pVc);

extern NTSTATUS
NTAPI
RxCeBuildConnectionOverMultipleTransports(
    IN OUT PRDBSS_DEVICE_OBJECT         pMiniRedirectorDeviceObject,
    IN  RXCE_CONNECTION_CREATE_OPTIONS  CreateOption,
    IN  ULONG                           NumberOfAddresses,
    IN  PRXCE_ADDRESS                   *pLocalAddressPointers,
    IN  PUNICODE_STRING                 pServerName,
    IN  PRXCE_CONNECTION_INFORMATION    pConnectionInformation,
    IN  PRXCE_CONNECTION_EVENT_HANDLER  pHandler,
    IN  PVOID                           pEventContext,
    IN  PRXCE_CONNECTION_COMPLETION_ROUTINE     pCompletionRoutine,
    IN OUT PRXCE_CONNECTION_COMPLETION_CONTEXT  pCompletionContext);

extern NTSTATUS
NTAPI
RxCeTearDownConnection(
    IN PRXCE_CONNECTION pConnection);


extern NTSTATUS
NTAPI
RxCeCancelConnectRequest(
    IN  PRXCE_ADDRESS                pLocalAddress,
    IN  PUNICODE_STRING              pServerName,
    IN  PRXCE_CONNECTION_INFORMATION pConnectionInformation);


//
// RXCE_VC encapsulates all the information w.r.t a virtual circuit (VC)
// connection to a particular server as regards the connection engine.
//
// Typically one VC is associated with a connection. However, there are instances in
// which more than one VC can be associated with a connection. In order to efficiently
// handle the common case well and at the same time provide an extensible mechanism we
// define a collection data structure ( a list ) which subsumes the allocation for
// one virtual circuit. It is also imperative that we restrict the knowledge of
// how this collection is organized to as few methods as possible in order to
// enable optimization/restructuring of this data structure at a later time.
//

#define RXCE_VC_ACTIVE       ((LONG)0xaa)
#define RXCE_VC_DISCONNECTED ((LONG)0xdd)
#define RXCE_VC_TEARDOWN     ((LONG)0xbb)

typedef struct _RXCE_VC_ {
    RXCE_SIGNATURE;

    PRXCE_CONNECTION         pConnection;         // the referenced connection instance
    HANDLE                   hEndpoint;           // local endpoint for the connection
    PFILE_OBJECT             pEndpointFileObject; // the end point file object.
    LONG                     State;               // status of the Vc.
    CONNECTION_CONTEXT       ConnectionId;        // local endpoint for the connection.
    PMDL                     pReceiveMdl;         // the MDl for handling receives.
    PKEVENT                  pCleanUpEvent;       // sychronize event for clean up transports
} RXCE_VC;

#define RXCE_VC_SIGNATURE ((sizeof(RXCE_VC) << 16) | RDBSS_NTC_RXCE_VC)

#define RxCeIsVcValid(pVc)    \
        ((pVc)->Signature == RXCE_VC_SIGNATURE)

extern NTSTATUS
NTAPI
RxCeBuildVC(
    IN OUT PRXCE_VC         pVc,
    IN     PRXCE_CONNECTION Connection);

extern NTSTATUS
NTAPI
RxCeTearDownVC(
    IN PRXCE_VC  pVc);

extern NTSTATUS
NTAPI
RxCeInitiateVCDisconnect(
    IN PRXCE_VC  pVc);

extern NTSTATUS
NTAPI
RxCeQueryInformation(
    IN PRXCE_VC                          pVc,
    IN RXCE_CONNECTION_INFORMATION_CLASS InformationClass,
    OUT PVOID                            pInformation,
    IN ULONG                             Length);

//
// RxCe Data transmission methods
//

//
// Send options
//
// The following flags are equivalent to the TDI flags. In addition
// there are RXCE specific flags which are defined from the other end of
// a dword.
//

#define RXCE_SEND_EXPEDITED            TDI_SEND_EXPEDITED
#define RXCE_SEND_NO_RESPONSE_EXPECTED TDI_SEND_NO_RESPONSE_EXPECTED
#define RXCE_SEND_NON_BLOCKING         TDI_SEND_NON_BLOCKING

//
// The ASYNCHRONOUS and SYNCHRONOUS option available RxCeSend and RxCeSendDatagram
// distinguish between two situations. In the asynchronous case control returns to
// the caller once the request has been successfully submitted to the underlying
// transport. The results for any given request are communicated back using the
// SendCompletion  callback routine. The pCompletionContext parameter in RxCeSend and
// RxCeSendDatagram is passed back in the callback routine to assist the caller in
// disambiguating the requests.
//
// In the synchronous case the request is submitted to the underlying transport and the
// control does not return to the caller till the request completes.
//
// Note that in the synchrnous case the pCompletionContext parameter is ignored and the
// status that is returned correpsonds to the completion status of the operations.
//
// The benefit of ASYNCHRONOUS and SYNCHRONOUS options depends on the underlying
// transport. In a Virtual Circuit environment a SYNCHRONOUS option implies that the
// control does not return till the data reaches the server. On the other hand
// for datagram oriented transports there is very little difference between the two.
//

#define RXCE_FLAGS_MASK (0xff000000)

#define RXCE_SEND_SYNCHRONOUS (0x10000000)

// The following bit signifies if an RX_MEM_DESC(MDL) is to be sent in its entirety
// or only portions of it need to be sent.

#define RXCE_SEND_PARTIAL     (0x20000000)
#define RXCE_INVOKE_SEND_SUBMITTED_HANDLER (0x40000000)

extern NTSTATUS
NTAPI
RxCeSend(
    IN PRXCE_VC          pVc,
    IN ULONG             SendOptions,
    IN PMDL              pMdl,
    IN ULONG             SendLength,
    IN PVOID             pCompletionContext);

extern NTSTATUS
NTAPI
RxCeSendDatagram(
    IN PRXCE_ADDRESS                hAddress,
    IN PRXCE_CONNECTION_INFORMATION pConnectionInformation,
    IN ULONG                        SendOptions,
    IN PMDL                         pMdl,
    IN ULONG                        SendLength,
    IN PVOID                        pCompletionContext);

#endif  // _RXCE_H_




#else /* NTDDI_VERSION */

#error This file cannot be included for this NTDDI_VERSION.

#endif /* NTDDI_VERSION */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\rxcommon.h ===
#if !defined(NTDDI_VERSION)

#error NTDDI_VERSION must be defined to include this file.

#elif (NTDDI_VERSION >= NTDDI_VISTA)

#error This file cannot be included for this NTDDI_VERSION.

#elif (NTDDI_VERSION >= NTDDI_WS03)

#error This file cannot be included for this NTDDI_VERSION.

#elif (NTDDI_VERSION >= NTDDI_WINXP)

/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    RxCommon.h

Abstract:

    This module prototypes the upper level common routines.

Author:
Revision History:

--*/

#ifndef _COMMON_STUFF_DEFINED_
#define _COMMON_STUFF_DEFINED_

NTSTATUS
RxCommonDevFCBCleanup ( RXCOMMON_SIGNATURE );      //  implemented in DevFCB.c

NTSTATUS
RxCommonDevFCBClose ( RXCOMMON_SIGNATURE );        //  implemented in DevFCB.c

NTSTATUS
RxCommonDevFCBIoCtl ( RXCOMMON_SIGNATURE );        //  implemented in DevFCB.c

NTSTATUS
RxCommonDevFCBFsCtl ( RXCOMMON_SIGNATURE );        //  implemented in DevFCB.c


NTSTATUS
RxCommonCleanup ( RXCOMMON_SIGNATURE );            //  implemented in Cleanup.c

NTSTATUS
RxCommonClose ( RXCOMMON_SIGNATURE );              //  implemented in Close.c

NTSTATUS
RxCommonCreate ( RXCOMMON_SIGNATURE );             //  implemented in Create.c

NTSTATUS
RxCommonDirectoryControl ( RXCOMMON_SIGNATURE );   //  implemented in DirCtrl.c

NTSTATUS
RxCommonDeviceControl ( RXCOMMON_SIGNATURE );      //  implemented in DevCtrl.c

NTSTATUS
RxCommonQueryEa ( RXCOMMON_SIGNATURE );            //  implemented in Ea.c

NTSTATUS
RxCommonSetEa ( RXCOMMON_SIGNATURE );              //  implemented in Ea.c

NTSTATUS
RxCommonQueryQuotaInformation ( RXCOMMON_SIGNATURE );            //  implemented in Ea.c

NTSTATUS
RxCommonSetQuotaInformation ( RXCOMMON_SIGNATURE );              //  implemented in Ea.c

NTSTATUS
RxCommonQueryInformation ( RXCOMMON_SIGNATURE );   //  implemented in FileInfo.c

NTSTATUS
RxCommonSetInformation ( RXCOMMON_SIGNATURE );     //  implemented in FileInfo.c

NTSTATUS
RxCommonFlushBuffers ( RXCOMMON_SIGNATURE );       //  implemented in Flush.c

NTSTATUS
RxCommonFileSystemControl ( RXCOMMON_SIGNATURE );  //  implemented in FsCtrl.c

NTSTATUS
RxCommonLockControl ( RXCOMMON_SIGNATURE );        //  implemented in LockCtrl.c

NTSTATUS
RxCommonShutdown ( RXCOMMON_SIGNATURE );           //  implemented in Shutdown.c

NTSTATUS
RxCommonRead ( RXCOMMON_SIGNATURE );               //  implemented in Read.c

NTSTATUS
RxCommonQueryVolumeInfo ( RXCOMMON_SIGNATURE );    //  implemented in VolInfo.c

NTSTATUS
RxCommonSetVolumeInfo ( RXCOMMON_SIGNATURE );      //  implemented in VolInfo.c

NTSTATUS
RxCommonWrite ( RXCOMMON_SIGNATURE );              //  implemented in Write.c

//FsRtl lock package callbacks referenced in fcbstruc.c

NTSTATUS
RxLockOperationCompletion (
    IN PVOID Context,
    IN PIRP Irp
    );

VOID
RxUnlockOperation (
    IN PVOID Context,
    IN PFILE_LOCK_INFO LockInfo
    );


// some read routines that need headers
VOID
RxStackOverflowRead (
    IN PVOID Context,
    IN PKEVENT Event
    );

NTSTATUS
RxPostStackOverflowRead (
    IN PRX_CONTEXT RxContext
    );

// the cancel routine
VOID
RxCancelRoutine(
      PDEVICE_OBJECT    pDeviceObject,
      PIRP              pIrp);

#endif // _COMMON_STUFF_DEFINED_


#elif (NTDDI_VERSION >= NTDDI_WIN2K)

/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    RxCommon.h

Abstract:

    This module prototypes the upper level common routines.

Author:
Revision History:

--*/

#ifndef _COMMON_STUFF_DEFINED_
#define _COMMON_STUFF_DEFINED_

NTSTATUS
RxCommonDevFCBCleanup ( RXCOMMON_SIGNATURE );      //  implemented in DevFCB.c

NTSTATUS
RxCommonDevFCBClose ( RXCOMMON_SIGNATURE );        //  implemented in DevFCB.c

NTSTATUS
RxCommonDevFCBIoCtl ( RXCOMMON_SIGNATURE );        //  implemented in DevFCB.c

NTSTATUS
RxCommonDevFCBFsCtl ( RXCOMMON_SIGNATURE );        //  implemented in DevFCB.c


NTSTATUS
RxCommonCleanup ( RXCOMMON_SIGNATURE );            //  implemented in Cleanup.c

NTSTATUS
RxCommonClose ( RXCOMMON_SIGNATURE );              //  implemented in Close.c

NTSTATUS
RxCommonCreate ( RXCOMMON_SIGNATURE );             //  implemented in Create.c

NTSTATUS
RxCommonDirectoryControl ( RXCOMMON_SIGNATURE );   //  implemented in DirCtrl.c

NTSTATUS
RxCommonDeviceControl ( RXCOMMON_SIGNATURE );      //  implemented in DevCtrl.c

NTSTATUS
RxCommonQueryEa ( RXCOMMON_SIGNATURE );            //  implemented in Ea.c

NTSTATUS
RxCommonSetEa ( RXCOMMON_SIGNATURE );              //  implemented in Ea.c

NTSTATUS
RxCommonQueryQuotaInformation ( RXCOMMON_SIGNATURE );            //  implemented in Ea.c

NTSTATUS
RxCommonSetQuotaInformation ( RXCOMMON_SIGNATURE );              //  implemented in Ea.c

NTSTATUS
RxCommonQueryInformation ( RXCOMMON_SIGNATURE );   //  implemented in FileInfo.c

NTSTATUS
RxCommonSetInformation ( RXCOMMON_SIGNATURE );     //  implemented in FileInfo.c

NTSTATUS
RxCommonFlushBuffers ( RXCOMMON_SIGNATURE );       //  implemented in Flush.c

NTSTATUS
RxCommonFileSystemControl ( RXCOMMON_SIGNATURE );  //  implemented in FsCtrl.c

NTSTATUS
RxCommonLockControl ( RXCOMMON_SIGNATURE );        //  implemented in LockCtrl.c

NTSTATUS
RxCommonShutdown ( RXCOMMON_SIGNATURE );           //  implemented in Shutdown.c

NTSTATUS
RxCommonRead ( RXCOMMON_SIGNATURE );               //  implemented in Read.c

NTSTATUS
RxCommonQueryVolumeInfo ( RXCOMMON_SIGNATURE );    //  implemented in VolInfo.c

NTSTATUS
RxCommonSetVolumeInfo ( RXCOMMON_SIGNATURE );      //  implemented in VolInfo.c

NTSTATUS
RxCommonWrite ( RXCOMMON_SIGNATURE );              //  implemented in Write.c

//FsRtl lock package callbacks referenced in fcbstruc.c

NTSTATUS
RxLockOperationCompletion (
    IN PVOID Context,
    IN PIRP Irp
    );

VOID
RxUnlockOperation (
    IN PVOID Context,
    IN PFILE_LOCK_INFO LockInfo
    );


// some read routines that need headers
VOID
RxStackOverflowRead (
    IN PVOID Context,
    IN PKEVENT Event
    );

NTSTATUS
RxPostStackOverflowRead (
    IN PRX_CONTEXT RxContext
    );

// the cancel routine
VOID
RxCancelRoutine(
      PDEVICE_OBJECT    pDeviceObject,
      PIRP              pIrp);

#endif // _COMMON_STUFF_DEFINED_


#else /* NTDDI_VERSION */

#error This file cannot be included for this NTDDI_VERSION.

#endif /* NTDDI_VERSION */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\rxdata.h ===
#if !defined(NTDDI_VERSION)

#error NTDDI_VERSION must be defined to include this file.

#elif (NTDDI_VERSION >= NTDDI_VISTA)

/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    RxData.h

Abstract:

    This module declares the global data used by the RDBSS file system.

Author:
Revision History:

--*/

#ifndef _RDBSSDATA_
#define _RDBSSDATA_

//

#ifndef MONOLITHIC_MINIRDR
extern PIO_WORKITEM RxIoWorkItem;
#endif

extern RX_DISPATCHER RxDispatcher;
extern RX_WORK_QUEUE_DISPATCHER RxDispatcherWorkQueues;

//this constants are  the same as the versions in ntexapi.h
//   but drivers are not supposed to import that!

#define  RX_PROCESSOR_ARCHITECTURE_INTEL 0
#define  RX_PROCESSOR_ARCHITECTURE_MIPS  1
#define  RX_PROCESSOR_ARCHITECTURE_ALPHA 2
#define  RX_PROCESSOR_ARCHITECTURE_PPC   3
#define  RX_PROCESSOR_ARCHITECTURE_UNKNOWN 0xffff

// RX_CONTEXT serialization

extern KMUTEX RxSerializationMutex;

#define RxAcquireSerializationMutex()                                       \
        KeWaitForSingleObject(&RxSerializationMutex,Executive,KernelMode,FALSE,NULL)

#define RxReleaseSerializationMutex()                  \
        KeReleaseMutex(&RxSerializationMutex,FALSE)

//
//  The global fsd data record, and  global large integer constants
//

extern ULONG    RxElapsedSecondsSinceStart;
extern NTSTATUS RxStubStatus;

extern PRDBSS_DEVICE_OBJECT RxFileSystemDeviceObject;

extern LARGE_INTEGER RxLargeZero;
extern LARGE_INTEGER RxMaxLarge;
extern LARGE_INTEGER Rx30Milliseconds;
extern LARGE_INTEGER RxOneSecond;
extern LARGE_INTEGER RxOneDay;
extern LARGE_INTEGER RxJanOne1980;
extern LARGE_INTEGER RxDecThirtyOne1979;

//
//  The status actually returned by the FsdDispatchStub.....usually not implemented
//

extern NTSTATUS RxStubStatus;

//
//  The FCB for opens that refer to the device object directly or
//       for file objects that reference nonFcbs (like treecons)
//

extern FCB RxDeviceFCB;


#if 0
//
//  Define maximum number of parallel Reads or Writes that will be generated
//  per one request.
//

#define RDBSS_MAX_IO_RUNS_ON_STACK        ((ULONG) 5)

//
//  Define the maximum number of delayed closes.
//

#define RDBSS_MAX_DELAYED_CLOSES          ((ULONG)16)

extern ULONG RxMaxDelayedCloseCount;

#endif //0

#if DBG

//
//  The following variables are used to keep track of the total amount
//  of requests processed by the file system, and the number of requests
//  that end up being processed by the Fsp thread.  The first variable
//  is incremented whenever an Irp context is created (which is always
//  at the start of an Fsd entry point) and the second is incremented
//  by read request.
//

extern ULONG RxFsdEntryCount;
//extern ULONG RxFspEntryCount;
//extern ULONG RxIoCallDriverCount;
//extern ULONG RxTotalTicks[];
extern ULONG RxIrpCodeCount[];


#endif


// The list of active RxContexts being processed by the RDBSS

extern LIST_ENTRY RxSrvCalldownList;
extern LIST_ENTRY RxActiveContexts;
__volatile extern LONG RxNumberOfActiveFcbs;


extern UNICODE_STRING s_PipeShareName;
extern UNICODE_STRING s_MailSlotShareName;
extern UNICODE_STRING s_MailSlotServerPrefix;
extern UNICODE_STRING s_IpcShareName;

extern UNICODE_STRING  s_PrimaryDomainName;

//
//  To allow NFS to run RDBSS on W2K, we now look up the kenel routine
//  FsRtlTeardownPerStreamContexts dynamically at run time.
//  This is the global variable that contains the function pointer or NULL
//  if the routine could not be found (as on W2K.
//

extern VOID (*RxTeardownPerStreamContexts)(IN PFSRTL_ADVANCED_FCB_HEADER AdvancedHeader);

#endif // _RDBSSDATA_


#elif (NTDDI_VERSION >= NTDDI_WS03)

/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    RxData.h

Abstract:

    This module declares the global data used by the RDBSS file system.

Author:

    Joe Linn     [JoeLinn]    1-aug-1994

Revision History:

--*/

#ifndef _RDBSSDATA_
#define _RDBSSDATA_

//

#ifndef MONOLITHIC_MINIRDR
extern PIO_WORKITEM RxIoWorkItem;
#endif

extern RX_DISPATCHER RxDispatcher;
extern RX_WORK_QUEUE_DISPATCHER RxDispatcherWorkQueues;

//this constants are  the same as the versions in ntexapi.h
//   but drivers are not supposed to import that!

#define  RX_PROCESSOR_ARCHITECTURE_INTEL 0
#define  RX_PROCESSOR_ARCHITECTURE_MIPS  1
#define  RX_PROCESSOR_ARCHITECTURE_ALPHA 2
#define  RX_PROCESSOR_ARCHITECTURE_PPC   3
#define  RX_PROCESSOR_ARCHITECTURE_UNKNOWN 0xffff

// RX_CONTEXT serialization

extern KMUTEX RxSerializationMutex;

#define RxAcquireSerializationMutex()                                       \
        KeWaitForSingleObject(&RxSerializationMutex,Executive,KernelMode,FALSE,NULL)

#define RxReleaseSerializationMutex()                  \
        KeReleaseMutex(&RxSerializationMutex,FALSE)

//
//  The global fsd data record, and  global large integer constants
//

extern ULONG    RxElapsedSecondsSinceStart;
extern NTSTATUS RxStubStatus;

extern PRDBSS_DEVICE_OBJECT RxFileSystemDeviceObject;

extern LARGE_INTEGER RxLargeZero;
extern LARGE_INTEGER RxMaxLarge;
extern LARGE_INTEGER Rx30Milliseconds;
extern LARGE_INTEGER RxOneSecond;
extern LARGE_INTEGER RxOneDay;
extern LARGE_INTEGER RxJanOne1980;
extern LARGE_INTEGER RxDecThirtyOne1979;

//
//  The status actually returned by the FsdDispatchStub.....usually not implemented
//

extern NTSTATUS RxStubStatus;

//
//  The FCB for opens that refer to the device object directly or
//       for file objects that reference nonFcbs (like treecons)
//

extern FCB RxDeviceFCB;


#if 0
//
//  Define maximum number of parallel Reads or Writes that will be generated
//  per one request.
//

#define RDBSS_MAX_IO_RUNS_ON_STACK        ((ULONG) 5)

//
//  Define the maximum number of delayed closes.
//

#define RDBSS_MAX_DELAYED_CLOSES          ((ULONG)16)

extern ULONG RxMaxDelayedCloseCount;

#endif //0

#if DBG

//
//  The following variables are used to keep track of the total amount
//  of requests processed by the file system, and the number of requests
//  that end up being processed by the Fsp thread.  The first variable
//  is incremented whenever an Irp context is created (which is always
//  at the start of an Fsd entry point) and the second is incremented
//  by read request.
//

extern ULONG RxFsdEntryCount;
//extern ULONG RxFspEntryCount;
//extern ULONG RxIoCallDriverCount;
//extern ULONG RxTotalTicks[];
extern ULONG RxIrpCodeCount[];


#endif


// The list of active RxContexts being processed by the RDBSS

extern LIST_ENTRY RxSrvCalldownList;
extern LIST_ENTRY RxActiveContexts;
extern LONG RxNumberOfActiveFcbs;


extern UNICODE_STRING s_PipeShareName;
extern UNICODE_STRING s_MailSlotShareName;
extern UNICODE_STRING s_MailSlotServerPrefix;
extern UNICODE_STRING s_IpcShareName;

extern UNICODE_STRING  s_PrimaryDomainName;

//
//  To allow NFS to run RDBSS on W2K, we now look up the kenel routine
//  FsRtlTeardownPerStreamContexts dynamically at run time.
//  This is the global variable that contains the function pointer or NULL
//  if the routine could not be found (as on W2K.
//

extern VOID (*RxTeardownPerStreamContexts)(IN PFSRTL_ADVANCED_FCB_HEADER AdvancedHeader);

#endif // _RDBSSDATA_



#elif (NTDDI_VERSION >= NTDDI_WINXP)

/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    RxData.h

Abstract:

    This module declares the global data used by the RDBSS file system.

Author:

    Joe Linn     [JoeLinn]    1-aug-1994

Revision History:

--*/

#ifndef _RDBSSDATA_
#define _RDBSSDATA_

//

extern RX_DISPATCHER RxDispatcher;
extern RX_WORK_QUEUE_DISPATCHER RxDispatcherWorkQueues;

//this constants are  the same as the versions in ntexapi.h
//   but drivers are not supposed to import that!

#define  RX_PROCESSOR_ARCHITECTURE_INTEL 0
#define  RX_PROCESSOR_ARCHITECTURE_MIPS  1
#define  RX_PROCESSOR_ARCHITECTURE_ALPHA 2
#define  RX_PROCESSOR_ARCHITECTURE_PPC   3
#define  RX_PROCESSOR_ARCHITECTURE_UNKNOWN 0xffff

// RX_CONTEXT serialization

extern KMUTEX RxSerializationMutex;

#define RxAcquireSerializationMutex()                                       \
        KeWaitForSingleObject(&RxSerializationMutex,Executive,KernelMode,FALSE,NULL)

#define RxReleaseSerializationMutex()                  \
        KeReleaseMutex(&RxSerializationMutex,FALSE)

//
//  The global fsd data record, and  global large integer constants
//

extern ULONG    RxElapsedSecondsSinceStart;
extern NTSTATUS RxStubStatus;

extern PRDBSS_DEVICE_OBJECT RxFileSystemDeviceObject;

extern LARGE_INTEGER RxLargeZero;
extern LARGE_INTEGER RxMaxLarge;
extern LARGE_INTEGER Rx30Milliseconds;
extern LARGE_INTEGER RxOneSecond;
extern LARGE_INTEGER RxOneDay;
extern LARGE_INTEGER RxJanOne1980;
extern LARGE_INTEGER RxDecThirtyOne1979;

//
//  The status actually returned by the FsdDispatchStub.....usually not implemented
//

extern NTSTATUS RxStubStatus;

//
//  The FCB for opens that refer to the device object directly or
//       for file objects that reference nonFcbs (like treecons)
//

extern FCB RxDeviceFCB;


#if 0
//
//  Define maximum number of parallel Reads or Writes that will be generated
//  per one request.
//

#define RDBSS_MAX_IO_RUNS_ON_STACK        ((ULONG) 5)

//
//  Define the maximum number of delayed closes.
//

#define RDBSS_MAX_DELAYED_CLOSES          ((ULONG)16)

extern ULONG RxMaxDelayedCloseCount;

#endif //0

#if DBG

//
//  The following variables are used to keep track of the total amount
//  of requests processed by the file system, and the number of requests
//  that end up being processed by the Fsp thread.  The first variable
//  is incremented whenever an Irp context is created (which is always
//  at the start of an Fsd entry point) and the second is incremented
//  by read request.
//

extern ULONG RxFsdEntryCount;
//extern ULONG RxFspEntryCount;
//extern ULONG RxIoCallDriverCount;
//extern ULONG RxTotalTicks[];
extern ULONG RxIrpCodeCount[];


#endif


// The list of active RxContexts being processed by the RDBSS

extern LIST_ENTRY RxSrvCalldownList;
extern LIST_ENTRY RxActiveContexts;
extern LONG RxNumberOfActiveFcbs;


extern UNICODE_STRING s_PipeShareName;
extern UNICODE_STRING s_MailSlotShareName;
extern UNICODE_STRING s_MailSlotServerPrefix;
extern UNICODE_STRING s_IpcShareName;

extern UNICODE_STRING  s_PrimaryDomainName;


#endif // _RDBSSDATA_



#elif (NTDDI_VERSION >= NTDDI_WIN2K)

/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    RxData.h

Abstract:

    This module declares the global data used by the RDBSS file system.

Author:

    Joe Linn     [JoeLinn]    1-aug-1994

Revision History:

--*/

#ifndef _RDBSSDATA_
#define _RDBSSDATA_

//

extern RX_DISPATCHER RxDispatcher;

//this constants are  the same as the versions in ntexapi.h
//   but drivers are not supposed to import that!

#define  RX_PROCESSOR_ARCHITECTURE_INTEL 0
#define  RX_PROCESSOR_ARCHITECTURE_MIPS  1
#define  RX_PROCESSOR_ARCHITECTURE_ALPHA 2
#define  RX_PROCESSOR_ARCHITECTURE_PPC   3
#define  RX_PROCESSOR_ARCHITECTURE_UNKNOWN 0xffff

// RX_CONTEXT serialization

extern KMUTEX RxSerializationMutex;

#define RxAcquireSerializationMutex()                                       \
        KeWaitForSingleObject(&RxSerializationMutex,Executive,KernelMode,FALSE,NULL)

#define RxReleaseSerializationMutex()                  \
        KeReleaseMutex(&RxSerializationMutex,FALSE)

//
//  The global fsd data record, and  global large integer constants
//

extern ULONG    RxElapsedSecondsSinceStart;
extern NTSTATUS RxStubStatus;

extern PRDBSS_DEVICE_OBJECT RxFileSystemDeviceObject;

extern LARGE_INTEGER RxLargeZero;
extern LARGE_INTEGER RxMaxLarge;
extern LARGE_INTEGER Rx30Milliseconds;
extern LARGE_INTEGER RxOneSecond;
extern LARGE_INTEGER RxOneDay;
extern LARGE_INTEGER RxJanOne1980;
extern LARGE_INTEGER RxDecThirtyOne1979;

//
//  The status actually returned by the FsdDispatchStub.....usually not implemented
//

extern NTSTATUS RxStubStatus;

//
//  The FCB for opens that refer to the device object directly or
//       for file objects that reference nonFcbs (like treecons)
//

extern FCB RxDeviceFCB;


#if 0
//
//  Define maximum number of parallel Reads or Writes that will be generated
//  per one request.
//

#define RDBSS_MAX_IO_RUNS_ON_STACK        ((ULONG) 5)

//
//  Define the maximum number of delayed closes.
//

#define RDBSS_MAX_DELAYED_CLOSES          ((ULONG)16)

extern ULONG RxMaxDelayedCloseCount;

#endif //0

#if DBG

//
//  The following variables are used to keep track of the total amount
//  of requests processed by the file system, and the number of requests
//  that end up being processed by the Fsp thread.  The first variable
//  is incremented whenever an Irp context is created (which is always
//  at the start of an Fsd entry point) and the second is incremented
//  by read request.
//

extern ULONG RxFsdEntryCount;
//extern ULONG RxFspEntryCount;
//extern ULONG RxIoCallDriverCount;
//extern ULONG RxTotalTicks[];
extern ULONG RxIrpCodeCount[];


#endif


// The list of active RxContexts being processed by the RDBSS

extern LIST_ENTRY RxSrvCalldownList;
extern LIST_ENTRY RxActiveContexts;
extern LONG RxNumberOfActiveFcbs;


extern UNICODE_STRING s_PipeShareName;
extern UNICODE_STRING s_MailSlotShareName;
extern UNICODE_STRING s_MailSlotServerPrefix;
extern UNICODE_STRING s_IpcShareName;

extern UNICODE_STRING  s_PrimaryDomainName;


#endif // _RDBSSDATA_



#else /* NTDDI_VERSION */

#error This file cannot be included for this NTDDI_VERSION.

#endif /* NTDDI_VERSION */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\rxdebug.h ===
#if !defined(NTDDI_VERSION)

#error NTDDI_VERSION must be defined to include this file.

#elif (NTDDI_VERSION >= NTDDI_VISTA)

#error This file cannot be included for this NTDDI_VERSION.

#elif (NTDDI_VERSION >= NTDDI_WS03)

/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    rxdebug.h

Abstract:

    This module contains the definition of auxilary data structures used in
    debugging. Each of the data structures is conditionalized by its own
    #ifdef tag.

Author:
--*/

#ifndef _RXDEBUG_H_
#define _RXDEBUG_H_

extern VOID
RxInitializeDebugSupport();

extern VOID
RxTearDownDebugSupport();


#ifdef RX_WJ_DBG_SUPPORT

#define MAX_JOURNAL_BITMAP_SIZE (8 * 1024)


typedef struct _FCB_WRITE_JOURNAL_ {
    LIST_ENTRY      JournalsList;

    PFCB            pFcb;
    PWCHAR pName;

    LONG  WritesInitiated;
    LONG  LowIoWritesInitiated;
    LONG  LowIoWritesCompleted;

    PBYTE pWriteInitiationBitmap;
    PBYTE pLowIoWriteInitiationBitmap;
    PBYTE pLowIoWriteCompletionBitmap;

    BYTE WriteInitiationBitmap[MAX_JOURNAL_BITMAP_SIZE];
    BYTE LowIoWriteInitiationBitmap[MAX_JOURNAL_BITMAP_SIZE];
    BYTE LowIoWriteCompletionBitmap[MAX_JOURNAL_BITMAP_SIZE];

    WCHAR           Path[MAX_PATH] ;

} FCB_WRITE_JOURNAL, *PFCB_WRITE_JOURNAL;

// forward declarations

VOID
RxdInitializeWriteJournalSupport();

VOID
RxdTearDownWriteJournalSupport();

VOID
RxdInitializeFcbWriteJournalDebugSupport(
    PFCB    pFcb);

VOID
RxdTearDownFcbWriteJournalDebugSupport(
    PFCB    pFcb);

VOID
RxdUpdateJournalOnWriteInitiation(
    IN OUT PFCB          pFcb,
    IN     LARGE_INTEGER Offset,
    IN     ULONG         Length);

VOID
RxdUpdateJournalOnLowIoWriteInitiation(
    IN  OUT PFCB            pFcb,
    IN      LARGE_INTEGER   Offset,
    IN      ULONG           Length);

VOID
RxdUpdateJournalOnLowIoWriteCompletion(
    IN  OUT PFCB            pFcb,
    IN      LARGE_INTEGER   Offset,
    IN      ULONG           Length);


#endif // RX_WJ_DBG_SUPPORT

#endif // _RXDEBUG_H_


#elif (NTDDI_VERSION >= NTDDI_WINXP)

/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    rxdebug.h

Abstract:

    This module contains the definition of auxilary data structures used in
    debugging. Each of the data structures is conditionalized by its own
    #ifdef tag.

Author:
--*/

#ifndef _RXDEBUG_H_
#define _RXDEBUG_H_

extern VOID
RxInitializeDebugSupport();

extern VOID
RxTearDownDebugSupport();


#ifdef RX_WJ_DBG_SUPPORT

#define MAX_JOURNAL_BITMAP_SIZE (8 * 1024)


typedef struct _FCB_WRITE_JOURNAL_ {
    LIST_ENTRY      JournalsList;

    PFCB            pFcb;
    PWCHAR pName;

    LONG  WritesInitiated;
    LONG  LowIoWritesInitiated;
    LONG  LowIoWritesCompleted;

    PBYTE pWriteInitiationBitmap;
    PBYTE pLowIoWriteInitiationBitmap;
    PBYTE pLowIoWriteCompletionBitmap;

    BYTE WriteInitiationBitmap[MAX_JOURNAL_BITMAP_SIZE];
    BYTE LowIoWriteInitiationBitmap[MAX_JOURNAL_BITMAP_SIZE];
    BYTE LowIoWriteCompletionBitmap[MAX_JOURNAL_BITMAP_SIZE];

    WCHAR           Path[MAX_PATH] ;

} FCB_WRITE_JOURNAL, *PFCB_WRITE_JOURNAL;

// forward declarations

VOID
RxdInitializeWriteJournalSupport();

VOID
RxdTearDownWriteJournalSupport();

VOID
RxdInitializeFcbWriteJournalDebugSupport(
    PFCB    pFcb);

VOID
RxdTearDownFcbWriteJournalDebugSupport(
    PFCB    pFcb);

VOID
RxdUpdateJournalOnWriteInitiation(
    IN OUT PFCB          pFcb,
    IN     LARGE_INTEGER Offset,
    IN     ULONG         Length);

VOID
RxdUpdateJournalOnLowIoWriteInitiation(
    IN  OUT PFCB            pFcb,
    IN      LARGE_INTEGER   Offset,
    IN      ULONG           Length);

VOID
RxdUpdateJournalOnLowIoWriteCompletion(
    IN  OUT PFCB            pFcb,
    IN      LARGE_INTEGER   Offset,
    IN      ULONG           Length);


#endif // RX_WJ_DBG_SUPPORT

#endif // _RXDEBUG_H_


#elif (NTDDI_VERSION >= NTDDI_WIN2K)

/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    rxdebug.h

Abstract:

    This module contains the definition of auxilary data structures used in
    debugging. Each of the data structures is conditionalized by its own
    #ifdef tag.

Author:
--*/

#ifndef _RXDEBUG_H_
#define _RXDEBUG_H_

extern VOID
RxInitializeDebugSupport();

extern VOID
RxTearDownDebugSupport();


#ifdef RX_WJ_DBG_SUPPORT

#define MAX_JOURNAL_BITMAP_SIZE (8 * 1024)


typedef struct _FCB_WRITE_JOURNAL_ {
    LIST_ENTRY      JournalsList;

    PFCB            pFcb;
    PWCHAR pName;

    LONG  WritesInitiated;
    LONG  LowIoWritesInitiated;
    LONG  LowIoWritesCompleted;

    PBYTE pWriteInitiationBitmap;
    PBYTE pLowIoWriteInitiationBitmap;
    PBYTE pLowIoWriteCompletionBitmap;

    BYTE WriteInitiationBitmap[MAX_JOURNAL_BITMAP_SIZE];
    BYTE LowIoWriteInitiationBitmap[MAX_JOURNAL_BITMAP_SIZE];
    BYTE LowIoWriteCompletionBitmap[MAX_JOURNAL_BITMAP_SIZE];

    WCHAR           Path[MAX_PATH] ;

} FCB_WRITE_JOURNAL, *PFCB_WRITE_JOURNAL;

// forward declarations

VOID
RxdInitializeWriteJournalSupport();

VOID
RxdTearDownWriteJournalSupport();

VOID
RxdInitializeFcbWriteJournalDebugSupport(
    PFCB    pFcb);

VOID
RxdTearDownFcbWriteJournalDebugSupport(
    PFCB    pFcb);

VOID
RxdUpdateJournalOnWriteInitiation(
    IN OUT PFCB          pFcb,
    IN     LARGE_INTEGER Offset,
    IN     ULONG         Length);

VOID
RxdUpdateJournalOnLowIoWriteInitiation(
    IN  OUT PFCB            pFcb,
    IN      LARGE_INTEGER   Offset,
    IN      ULONG           Length);

VOID
RxdUpdateJournalOnLowIoWriteCompletion(
    IN  OUT PFCB            pFcb,
    IN      LARGE_INTEGER   Offset,
    IN      ULONG           Length);


#endif // RX_WJ_DBG_SUPPORT

#endif // _RXDEBUG_H_


#else /* NTDDI_VERSION */

#error This file cannot be included for this NTDDI_VERSION.

#endif /* NTDDI_VERSION */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\rxcehdlr.h ===
#if !defined(NTDDI_VERSION)

#error NTDDI_VERSION must be defined to include this file.

#elif (NTDDI_VERSION >= NTDDI_VISTA)

/*++ BUILD Version: 0009    // Increment this if a change has global effects
Copyright (c) 1987-1993  Microsoft Corporation

Module Name:

    rxcehdlr.h

Abstract:

    This is the include file that defines all constants and types for
    accessing the redirector file system connection engine.

Revision History:
Notes:

    The Connection engine is designed to map and emulate the TDI specs. as closely
    as possible. This implies that on NT we will have a very efficient mechanism
    which fully exploits the underlying TDI implementation.

    All the necessary types can be redefined in terms of the types defined in
    \nt\private\inc\tdi.h in the case of NT. For Win95 we will provide the
    appropriate definitions.

--*/

#ifndef _RXCEHDLR_H_
#define _RXCEHDLR_H_

#include "tdi.h"

typedef TDI_PROVIDER_INFO RXCE_TRANSPORT_PROVIDER_INFO;
typedef RXCE_TRANSPORT_PROVIDER_INFO* PRXCE_TRANSPORT_PROVIDER_INFO;

typedef TDI_CONNECTION_INFORMATION RXCE_CONNECTION_INFORMATION;
typedef RXCE_CONNECTION_INFORMATION* PRXCE_CONNECTION_INFORMATION;

typedef TDI_CONNECTION_INFORMATION RXCE_CONNECTION_INFORMATION;
typedef RXCE_CONNECTION_INFORMATION* PRXCE_CONNECTION_INFORMATION;

typedef TDI_CONNECTION_INFO RXCE_CONNECTION_INFO;
typedef RXCE_CONNECTION_INFO* PRXCE_CONNECTION_INFO;

#ifdef __cplusplus
typedef struct _RXCE_TRANSPORT_INFORMATION_ : public RXCE_TRANSPORT_PROVIDER_INFO {
#else // !__cplusplus
typedef struct _RXCE_TRANSPORT_INFORMATION_ {
   RXCE_TRANSPORT_PROVIDER_INFO;
#endif // __cplusplus

   ULONG  ConnectionCount;
   ULONG  QualityOfService;
} RXCE_TRANSPORT_INFORMATION, *PRXCE_TRANSPORT_INFORMATION;

typedef enum _RXCE_CONNECTION_INFORMATION_CLASS_ {
    RxCeTransportProviderInformation = 1,
    RxCeConnectionInformation,
    RxCeConnectionEndpointInformation,
    RxCeRemoteAddressInformation
} RXCE_CONNECTION_INFORMATION_CLASS,
  *PRXCE_CONNECTION_INFORMATION_CLASS;

typedef struct _RXCE_VC_         *PRXCE_VC;
typedef struct _RXCE_CONNECTION_ *PRXCE_CONNECTION;
typedef struct _RXCE_ADDRESS_    *PRXCE_ADDRESS;
typedef struct _RXCE_TRANSPORT_  *PRXCE_TRANSPORT;

//
// Disconnection indication prototype. This is invoked when a connection is
// being disconnected for a reason other than the user requesting it.
//

typedef
NTSTATUS
(*PRXCE_IND_DISCONNECT)(
    IN PVOID            pRxCeEventContext,
    IN PRXCE_VC         pVc,
    IN int              DisconnectDataLength,
    IN PVOID            DisconnectData,
    IN int              DisconnectInformationLength,
    IN PVOID            DisconnectInformation,
    IN ULONG            DisconnectFlags
    );

//
// A protocol error has occurred when this indication happens. This indication
// occurs only for errors of the worst type; the address this indication is
// delivered to is no longer usable for protocol-related operations, and
// should not be used for operations henceforth. All connections associated
// it are invalid.
//

typedef
NTSTATUS
(*PRXCE_IND_ENDPOINT_ERROR)(
    IN PVOID    pRxCeEventContext,    // the event context.
    IN NTSTATUS Status                // status code indicating error type.
    );


typedef
NTSTATUS
(*PRXCE_IND_CONNECTION_ERROR)(
    IN PVOID       pRxCeEventContext,    // the event context.
    PRXCE_VC       pVc,                  // the associated VC handle
    IN NTSTATUS    Status                // status code indicating error type.
    );

//
// RXCE_IND_RECEIVE indication handler definition.  This client routine is
// called by the transport provider when a connection-oriented TSDU is received
// that should be presented to the client.
//
// A Receive event handler can return one of three distinguished error codes to
// initiate a different course of action in the connection engine.
//
// STATUS_SUCCESS -- Data was copied directly from the TSDU. The amout of data that
// was taken is indicated in the parameter BytesTaken.
//
// STATUS_MORE_PROCESSING_REQUIRED -- The client has returned a buffer into which the
// data should be copied. This is typically the case when BytesAvailable is greater than
// BytesIndicated. In such cases the RxCe will copy the remaining data into the buffer
// that is specified. Note that when this status code is returned from the client it is
// conceivable that the client can demand more data than is available to be copied into
// the buffer. In such cases the subsequent indications till this criterion is met is not
// passed back to the user till the copy is completed. On completion of this copy the
// RxCe notifies the client by invoking the RxCeDataReadyEventHandler.
//
// STATUS_DATA_NOT_ACCEPTED - The client has refused the data.
//

typedef
NTSTATUS
(*PRXCE_IND_RECEIVE)(
    IN PVOID pRxCeEventContext,       // the context provided during registration
    IN PRXCE_VC    pVc,           // the associated VC handle
    IN ULONG ReceiveFlags,            // the receive flags
    IN ULONG BytesIndicated,          // the number of received bytes indicated
    IN ULONG BytesAvailable,          // the total number of bytes available
    OUT ULONG *BytesTaken,            // return indication of the bytes consumed
    IN PVOID Tsdu,                    // pointer describing this TSDU, typically a lump of bytes
    OUT PMDL *pDataBufferPointer,     // the buffer for copying the bytes not indicated.
    OUT PULONG  pDataBufferSize       // amount of data to copy
    );


//
// RXCE_IND_RECEIVE_DATAGRAM indication handler definition.  This client routine
// is called by the transport provider when a connectionless TSDU is received
// that should be presented to the client.
//
// A Receive event handler can return one of three distinguished error codes to
// initiate a different course of action in the connection engine.
//
// STATUS_SUCCESS -- Data was copied directly from the TSDU. The amout of data that
// was taken is indicated in the parameter BytesTaken.
//
// STATUS_MORE_PROCESSING_REQUIRED -- The client has returned a buffer into which the
// data should be copied. This is typically the case when BytesAvailable is greater than
// BytesIndicated. In such cases the RxCe will copy the remaining data into the buffer
// that is specified. Note that when this status code is returned from the client it is
// conceivable that the client can demand more data than is available to be copied into
// the buffer. In such cases the subsequent indications till this criterion is met is not
// passed back to the user till the copy is completed. On completion of this copy the
// RxCe notifies the client by invoking the RxCeDataReadyEventHandler.
//
// STATUS_DATA_NOT_ACCEPTED - The client has refused the data.
//
//

typedef
NTSTATUS
(*PRXCE_IND_RECEIVE_DATAGRAM)(
    IN PVOID   pRxCeEventContext,      // the event context
    IN int     SourceAddressLength,    // length of the originator of the datagram
    IN PVOID   SourceAddress,          // string describing the originator of the datagram
    IN int     OptionsLength,          // options for the receive
    IN PVOID   Options,                //
    IN ULONG   ReceiveDatagramFlags,   //
    IN ULONG   BytesIndicated,         // number of bytes this indication
    IN ULONG   BytesAvailable,         // number of bytes in complete Tsdu
    OUT ULONG  *BytesTaken,            // number of bytes used
    IN PVOID   Tsdu,                   // pointer describing this TSDU, typically a lump of bytes
    OUT PMDL *pDataBufferPointer,      // the buffer in which data is to be copied.
    OUT PULONG  pDataBufferSize        // amount of data to copy
    );

//
// This indication is delivered if expedited data is received on the connection.
// This will only occur in providers that support expedited data.
//
// A Receive event handler can return one of three distinguished error codes to
// initiate a different course of action in the connection engine.
//
// STATUS_SUCCESS -- Data was copied directly from the TSDU. The amout of data that
// was taken is indicated in the parameter BytesTaken.
//
// STATUS_MORE_PROCESSING_REQUIRED -- The client has returned a buffer into which the
// data should be copied. This is typically the case when BytesAvailable is greater than
// BytesIndicated. In such cases the RxCe will copy the remaining data into the buffer
// that is specified. Note that when this status code is returned from the client it is
// conceivable that the client can demand more data than is available to be copied into
// the buffer. In such cases the subsequent indications till this criterion is met is not
// passed back to the user till the copy is completed. On completion of this copy the
// RxCe notifies the client by invoking the RxCeDataReadyEventHandler.
//
// STATUS_DATA_NOT_ACCEPTED - The client has refused the data.
//

typedef
NTSTATUS
(*PRXCE_IND_RECEIVE_EXPEDITED)(
    IN PVOID pRxCeEventContext,     // the context provided during registration
    IN PRXCE_VC     pVc,        // the associated VC handle
    IN ULONG ReceiveFlags,          //
    IN ULONG BytesIndicated,        // number of bytes in this indication
    IN ULONG BytesAvailable,        // number of bytes in complete Tsdu
    OUT ULONG *BytesTaken,          // number of bytes used by indication routine
    IN PVOID Tsdu,                  // pointer describing this TSDU, typically a lump of bytes
    OUT PMDL *pDataBufferPointer,   // the buffer in which data is to be copied.
    OUT PULONG  pDataBufferSize     // amount of data to copy
    );

//
// This indication is delivered if there is room for a send in the buffer of
// a buffering protocol.
//

typedef
NTSTATUS
(*PRXCE_IND_SEND_POSSIBLE)(
    IN PVOID pRxCeEventContext,
    IN PRXCE_VC pVc,
    IN ULONG BytesAvailable);

//
// RxCeDataReadyEventHandler -- This is invoked when the desired data is available
// for client consumption. This always follows a receive indication in which the
// client returns a buffer for copying the remaining data
//

typedef
NTSTATUS
(*PRXCE_IND_DATA_READY)(
   IN PVOID         pEventContext,
   IN PMDL  pBuffer,
   IN ULONG         CopiedDataSize,
   IN NTSTATUS      CopyDataStatus);


//
// RxCeSendCompleteEventHandler -- This is invoked when the send has been successfully completed
// The buffer and the length sent are passed in as parameters
//

typedef
NTSTATUS
(*PRXCE_IND_SEND_COMPLETE)(
   IN PVOID       pEventContext,
   IN PVOID       pCompletionContext,
   IN NTSTATUS    Status);


typedef
NTSTATUS
(*PRXCE_IND_CONNECTION_SEND_COMPLETE)(
   IN PVOID          pEventContext,
   IN PRXCE_VC       pVc,
   IN PVOID          pCompletionContext,
   IN NTSTATUS       Status);

//
// RxCeSendSubmittedEventHandler -- This is invoked when the send has been successfully 
// submitted to the transport.
//

typedef
NTSTATUS
(*PRXCE_IND_CONNECTION_SEND_SUBMITTED)(
   IN PVOID       pEventContext,
   IN PRXCE_VC    pVc,
   IN PVOID       pCompletionContext,
   IN NTSTATUS    Status);

//
// Event Handler Dispatch Vector definitions ....
//

typedef struct _RXCE_ADDRESS_EVENT_HANDLER_ {
   PRXCE_IND_ENDPOINT_ERROR   RxCeErrorEventHandler;
   PRXCE_IND_RECEIVE_DATAGRAM RxCeReceiveDatagramEventHandler;
   PRXCE_IND_DATA_READY       RxCeDataReadyEventHandler;
   PRXCE_IND_SEND_POSSIBLE    RxCeSendPossibleEventHandler;
   PRXCE_IND_SEND_COMPLETE    RxCeSendCompleteEventHandler;
} RXCE_ADDRESS_EVENT_HANDLER, *PRXCE_ADDRESS_EVENT_HANDLER;

typedef struct _RXCE_CONNECTION_EVENT_HANDLER_ {
   PRXCE_IND_DISCONNECT                   RxCeDisconnectEventHandler;
   PRXCE_IND_CONNECTION_ERROR             RxCeErrorEventHandler;
   PRXCE_IND_RECEIVE                      RxCeReceiveEventHandler;
   PRXCE_IND_RECEIVE_DATAGRAM             RxCeReceiveDatagramEventHandler;
   PRXCE_IND_RECEIVE_EXPEDITED            RxCeReceiveExpeditedEventHandler;
   PRXCE_IND_SEND_POSSIBLE                RxCeSendPossibleEventHandler;
   PRXCE_IND_DATA_READY                   RxCeDataReadyEventHandler;
   PRXCE_IND_CONNECTION_SEND_COMPLETE     RxCeSendCompleteEventHandler;
   PRXCE_IND_CONNECTION_SEND_SUBMITTED    RxCeSendSubmittedEventHandler;
} RXCE_CONNECTION_EVENT_HANDLER, *PRXCE_CONNECTION_EVENT_HANDLER;

#endif // _RXCEHDLR_H_

#elif (NTDDI_VERSION >= NTDDI_WS03)

/*++ BUILD Version: 0009    // Increment this if a change has global effects
Copyright (c) 1987-1993  Microsoft Corporation

Module Name:

    rxcehdlr.h

Abstract:

    This is the include file that defines all constants and types for
    accessing the redirector file system connection engine.

Revision History:
Notes:

    The Connection engine is designed to map and emulate the TDI specs. as closely
    as possible. This implies that on NT we will have a very efficient mechanism
    which fully exploits the underlying TDI implementation.

    All the necessary types can be redefined in terms of the types defined in
    \nt\private\inc\tdi.h in the case of NT. For Win95 we will provide the
    appropriate definitions.

--*/

#ifndef _RXCEHDLR_H_
#define _RXCEHDLR_H_

#include "tdi.h"

typedef TDI_PROVIDER_INFO RXCE_TRANSPORT_PROVIDER_INFO;
typedef RXCE_TRANSPORT_PROVIDER_INFO* PRXCE_TRANSPORT_PROVIDER_INFO;

typedef TDI_CONNECTION_INFORMATION RXCE_CONNECTION_INFORMATION;
typedef RXCE_CONNECTION_INFORMATION* PRXCE_CONNECTION_INFORMATION;

typedef TDI_CONNECTION_INFORMATION RXCE_CONNECTION_INFORMATION;
typedef RXCE_CONNECTION_INFORMATION* PRXCE_CONNECTION_INFORMATION;

typedef TDI_CONNECTION_INFO RXCE_CONNECTION_INFO;
typedef RXCE_CONNECTION_INFO* PRXCE_CONNECTION_INFO;

#ifdef __cplusplus
typedef struct _RXCE_TRANSPORT_INFORMATION_ : public RXCE_TRANSPORT_PROVIDER_INFO {
#else // !__cplusplus
typedef struct _RXCE_TRANSPORT_INFORMATION_ {
   RXCE_TRANSPORT_PROVIDER_INFO;
#endif // __cplusplus

   ULONG  ConnectionCount;
   ULONG  QualityOfService;
} RXCE_TRANSPORT_INFORMATION, *PRXCE_TRANSPORT_INFORMATION;

typedef enum _RXCE_CONNECTION_INFORMATION_CLASS_ {
    RxCeTransportProviderInformation = 1,
    RxCeConnectionInformation,
    RxCeConnectionEndpointInformation,
    RxCeRemoteAddressInformation
} RXCE_CONNECTION_INFORMATION_CLASS,
  *PRXCE_CONNECTION_INFORMATION_CLASS;

typedef struct _RXCE_VC_         *PRXCE_VC;
typedef struct _RXCE_CONNECTION_ *PRXCE_CONNECTION;
typedef struct _RXCE_ADDRESS_    *PRXCE_ADDRESS;
typedef struct _RXCE_TRANSPORT_  *PRXCE_TRANSPORT;

//
// Disconnection indication prototype. This is invoked when a connection is
// being disconnected for a reason other than the user requesting it.
//

typedef
NTSTATUS
(*PRXCE_IND_DISCONNECT)(
    IN PVOID            pRxCeEventContext,
    IN PRXCE_VC         pVc,
    IN int              DisconnectDataLength,
    IN PVOID            DisconnectData,
    IN int              DisconnectInformationLength,
    IN PVOID            DisconnectInformation,
    IN ULONG            DisconnectFlags
    );

//
// A protocol error has occurred when this indication happens. This indication
// occurs only for errors of the worst type; the address this indication is
// delivered to is no longer usable for protocol-related operations, and
// should not be used for operations henceforth. All connections associated
// it are invalid.
//

typedef
NTSTATUS
(*PRXCE_IND_ENDPOINT_ERROR)(
    IN PVOID    pRxCeEventContext,    // the event context.
    IN NTSTATUS Status                // status code indicating error type.
    );


typedef
NTSTATUS
(*PRXCE_IND_CONNECTION_ERROR)(
    IN PVOID       pRxCeEventContext,    // the event context.
    PRXCE_VC       pVc,                  // the associated VC handle
    IN NTSTATUS    Status                // status code indicating error type.
    );

//
// RXCE_IND_RECEIVE indication handler definition.  This client routine is
// called by the transport provider when a connection-oriented TSDU is received
// that should be presented to the client.
//
// A Receive event handler can return one of three distinguished error codes to
// initiate a different course of action in the connection engine.
//
// STATUS_SUCCESS -- Data was copied directly from the TSDU. The amout of data that
// was taken is indicated in the parameter BytesTaken.
//
// STATUS_MORE_PROCESSING_REQUIRED -- The client has returned a buffer into which the
// data should be copied. This is typically the case when BytesAvailable is greater than
// BytesIndicated. In such cases the RxCe will copy the remaining data into the buffer
// that is specified. Note that when this status code is returned from the client it is
// conceivable that the client can demand more data than is available to be copied into
// the buffer. In such cases the subsequent indications till this criterion is met is not
// passed back to the user till the copy is completed. On completion of this copy the
// RxCe notifies the client by invoking the RxCeDataReadyEventHandler.
//
// STATUS_DATA_NOT_ACCEPTED - The client has refused the data.
//

typedef
NTSTATUS
(*PRXCE_IND_RECEIVE)(
    IN PVOID pRxCeEventContext,       // the context provided during registration
    IN PRXCE_VC    pVc,           // the associated VC handle
    IN ULONG ReceiveFlags,            // the receive flags
    IN ULONG BytesIndicated,          // the number of received bytes indicated
    IN ULONG BytesAvailable,          // the total number of bytes available
    OUT ULONG *BytesTaken,            // return indication of the bytes consumed
    IN PVOID Tsdu,                    // pointer describing this TSDU, typically a lump of bytes
    OUT PMDL *pDataBufferPointer,     // the buffer for copying the bytes not indicated.
    OUT PULONG  pDataBufferSize       // amount of data to copy
    );


//
// RXCE_IND_RECEIVE_DATAGRAM indication handler definition.  This client routine
// is called by the transport provider when a connectionless TSDU is received
// that should be presented to the client.
//
// A Receive event handler can return one of three distinguished error codes to
// initiate a different course of action in the connection engine.
//
// STATUS_SUCCESS -- Data was copied directly from the TSDU. The amout of data that
// was taken is indicated in the parameter BytesTaken.
//
// STATUS_MORE_PROCESSING_REQUIRED -- The client has returned a buffer into which the
// data should be copied. This is typically the case when BytesAvailable is greater than
// BytesIndicated. In such cases the RxCe will copy the remaining data into the buffer
// that is specified. Note that when this status code is returned from the client it is
// conceivable that the client can demand more data than is available to be copied into
// the buffer. In such cases the subsequent indications till this criterion is met is not
// passed back to the user till the copy is completed. On completion of this copy the
// RxCe notifies the client by invoking the RxCeDataReadyEventHandler.
//
// STATUS_DATA_NOT_ACCEPTED - The client has refused the data.
//
//

typedef
NTSTATUS
(*PRXCE_IND_RECEIVE_DATAGRAM)(
    IN PVOID   pRxCeEventContext,      // the event context
    IN int     SourceAddressLength,    // length of the originator of the datagram
    IN PVOID   SourceAddress,          // string describing the originator of the datagram
    IN int     OptionsLength,          // options for the receive
    IN PVOID   Options,                //
    IN ULONG   ReceiveDatagramFlags,   //
    IN ULONG   BytesIndicated,         // number of bytes this indication
    IN ULONG   BytesAvailable,         // number of bytes in complete Tsdu
    OUT ULONG  *BytesTaken,            // number of bytes used
    IN PVOID   Tsdu,                   // pointer describing this TSDU, typically a lump of bytes
    OUT PMDL *pDataBufferPointer,      // the buffer in which data is to be copied.
    OUT PULONG  pDataBufferSize        // amount of data to copy
    );

//
// This indication is delivered if expedited data is received on the connection.
// This will only occur in providers that support expedited data.
//
// A Receive event handler can return one of three distinguished error codes to
// initiate a different course of action in the connection engine.
//
// STATUS_SUCCESS -- Data was copied directly from the TSDU. The amout of data that
// was taken is indicated in the parameter BytesTaken.
//
// STATUS_MORE_PROCESSING_REQUIRED -- The client has returned a buffer into which the
// data should be copied. This is typically the case when BytesAvailable is greater than
// BytesIndicated. In such cases the RxCe will copy the remaining data into the buffer
// that is specified. Note that when this status code is returned from the client it is
// conceivable that the client can demand more data than is available to be copied into
// the buffer. In such cases the subsequent indications till this criterion is met is not
// passed back to the user till the copy is completed. On completion of this copy the
// RxCe notifies the client by invoking the RxCeDataReadyEventHandler.
//
// STATUS_DATA_NOT_ACCEPTED - The client has refused the data.
//

typedef
NTSTATUS
(*PRXCE_IND_RECEIVE_EXPEDITED)(
    IN PVOID pRxCeEventContext,     // the context provided during registration
    IN PRXCE_VC     pVc,        // the associated VC handle
    IN ULONG ReceiveFlags,          //
    IN ULONG BytesIndicated,        // number of bytes in this indication
    IN ULONG BytesAvailable,        // number of bytes in complete Tsdu
    OUT ULONG *BytesTaken,          // number of bytes used by indication routine
    IN PVOID Tsdu,                  // pointer describing this TSDU, typically a lump of bytes
    OUT PMDL *pDataBufferPointer,   // the buffer in which data is to be copied.
    OUT PULONG  pDataBufferSize     // amount of data to copy
    );

//
// This indication is delivered if there is room for a send in the buffer of
// a buffering protocol.
//

typedef
NTSTATUS
(*PRXCE_IND_SEND_POSSIBLE)(
    IN PVOID pRxCeEventContext,
    IN PRXCE_VC pVc,
    IN ULONG BytesAvailable);

//
// RxCeDataReadyEventHandler -- This is invoked when the desired data is available
// for client consumption. This always follows a receive indication in which the
// client returns a buffer for copying the remaining data
//

typedef
NTSTATUS
(*PRXCE_IND_DATA_READY)(
   IN PVOID         pEventContext,
   IN PMDL  pBuffer,
   IN ULONG         CopiedDataSize,
   IN NTSTATUS      CopyDataStatus);


//
// RxCeSendCompleteEventHandler -- This is invoked when the send has been successfully completed
// The buffer and the length sent are passed in as parameters
//

typedef
NTSTATUS
(*PRXCE_IND_SEND_COMPLETE)(
   IN PVOID       pEventContext,
   IN PVOID       pCompletionContext,
   IN NTSTATUS    Status);


typedef
NTSTATUS
(*PRXCE_IND_CONNECTION_SEND_COMPLETE)(
   IN PVOID          pEventContext,
   IN PRXCE_VC       pVc,
   IN PVOID          pCompletionContext,
   IN NTSTATUS       Status);

//
// RxCeSendSubmittedEventHandler -- This is invoked when the send has been successfully 
// submitted to the transport.
//

typedef
NTSTATUS
(*PRXCE_IND_CONNECTION_SEND_SUBMITTED)(
   IN PVOID       pEventContext,
   IN PRXCE_VC    pVc,
   IN PVOID       pCompletionContext,
   IN NTSTATUS    Status);

//
// Event Handler Dispatch Vector definitions ....
//

typedef struct _RXCE_ADDRESS_EVENT_HANDLER_ {
   PRXCE_IND_ENDPOINT_ERROR   RxCeErrorEventHandler;
   PRXCE_IND_RECEIVE_DATAGRAM RxCeReceiveDatagramEventHandler;
   PRXCE_IND_DATA_READY       RxCeDataReadyEventHandler;
   PRXCE_IND_SEND_POSSIBLE    RxCeSendPossibleEventHandler;
   PRXCE_IND_SEND_COMPLETE    RxCeSendCompleteEventHandler;
} RXCE_ADDRESS_EVENT_HANDLER, *PRXCE_ADDRESS_EVENT_HANDLER;

typedef struct _RXCE_CONNECTION_EVENT_HANDLER_ {
   PRXCE_IND_DISCONNECT                   RxCeDisconnectEventHandler;
   PRXCE_IND_CONNECTION_ERROR             RxCeErrorEventHandler;
   PRXCE_IND_RECEIVE                      RxCeReceiveEventHandler;
   PRXCE_IND_RECEIVE_DATAGRAM             RxCeReceiveDatagramEventHandler;
   PRXCE_IND_RECEIVE_EXPEDITED            RxCeReceiveExpeditedEventHandler;
   PRXCE_IND_SEND_POSSIBLE                RxCeSendPossibleEventHandler;
   PRXCE_IND_DATA_READY                   RxCeDataReadyEventHandler;
   PRXCE_IND_CONNECTION_SEND_COMPLETE     RxCeSendCompleteEventHandler;
   PRXCE_IND_CONNECTION_SEND_SUBMITTED    RxCeSendSubmittedEventHandler;
} RXCE_CONNECTION_EVENT_HANDLER, *PRXCE_CONNECTION_EVENT_HANDLER;

#endif // _RXCEHDLR_H_


#elif (NTDDI_VERSION >= NTDDI_WINXP)

/*++ BUILD Version: 0009    // Increment this if a change has global effects
Copyright (c) 1987-1993  Microsoft Corporation

Module Name:

    rxcehdlr.h

Abstract:

    This is the include file that defines all constants and types for
    accessing the redirector file system connection engine.

Revision History:
Notes:

    The Connection engine is designed to map and emulate the TDI specs. as closely
    as possible. This implies that on NT we will have a very efficient mechanism
    which fully exploits the underlying TDI implementation.

    All the necessary types can be redefined in terms of the types defined in
    \nt\private\inc\tdi.h in the case of NT. For Win95 we will provide the
    appropriate definitions.

--*/

#ifndef _RXCEHDLR_H_
#define _RXCEHDLR_H_

#include "tdi.h"

typedef TDI_PROVIDER_INFO RXCE_TRANSPORT_PROVIDER_INFO;
typedef RXCE_TRANSPORT_PROVIDER_INFO* PRXCE_TRANSPORT_PROVIDER_INFO;

typedef TDI_CONNECTION_INFORMATION RXCE_CONNECTION_INFORMATION;
typedef RXCE_CONNECTION_INFORMATION* PRXCE_CONNECTION_INFORMATION;

typedef TDI_CONNECTION_INFORMATION RXCE_CONNECTION_INFORMATION;
typedef RXCE_CONNECTION_INFORMATION* PRXCE_CONNECTION_INFORMATION;

typedef TDI_CONNECTION_INFO RXCE_CONNECTION_INFO;
typedef RXCE_CONNECTION_INFO* PRXCE_CONNECTION_INFO;

#ifdef __cplusplus
typedef struct _RXCE_TRANSPORT_INFORMATION_ : public RXCE_TRANSPORT_PROVIDER_INFO {
#else // !__cplusplus
typedef struct _RXCE_TRANSPORT_INFORMATION_ {
   RXCE_TRANSPORT_PROVIDER_INFO;
#endif // __cplusplus

   ULONG  ConnectionCount;
   ULONG  QualityOfService;
} RXCE_TRANSPORT_INFORMATION, *PRXCE_TRANSPORT_INFORMATION;

typedef enum _RXCE_CONNECTION_INFORMATION_CLASS_ {
    RxCeTransportProviderInformation = 1,
    RxCeConnectionInformation,
    RxCeConnectionEndpointInformation,
    RxCeRemoteAddressInformation
} RXCE_CONNECTION_INFORMATION_CLASS,
  *PRXCE_CONNECTION_INFORMATION_CLASS;

typedef struct _RXCE_VC_         *PRXCE_VC;
typedef struct _RXCE_CONNECTION_ *PRXCE_CONNECTION;
typedef struct _RXCE_ADDRESS_    *PRXCE_ADDRESS;
typedef struct _RXCE_TRANSPORT_  *PRXCE_TRANSPORT;

//
// Disconnection indication prototype. This is invoked when a connection is
// being disconnected for a reason other than the user requesting it.
//

typedef
NTSTATUS
(*PRXCE_IND_DISCONNECT)(
    IN PVOID            pRxCeEventContext,
    IN PRXCE_VC         pVc,
    IN int              DisconnectDataLength,
    IN PVOID            DisconnectData,
    IN int              DisconnectInformationLength,
    IN PVOID            DisconnectInformation,
    IN ULONG            DisconnectFlags
    );

//
// A protocol error has occurred when this indication happens. This indication
// occurs only for errors of the worst type; the address this indication is
// delivered to is no longer usable for protocol-related operations, and
// should not be used for operations henceforth. All connections associated
// it are invalid.
//

typedef
NTSTATUS
(*PRXCE_IND_ENDPOINT_ERROR)(
    IN PVOID    pRxCeEventContext,    // the event context.
    IN NTSTATUS Status                // status code indicating error type.
    );


typedef
NTSTATUS
(*PRXCE_IND_CONNECTION_ERROR)(
    IN PVOID       pRxCeEventContext,    // the event context.
    PRXCE_VC       pVc,                  // the associated VC handle
    IN NTSTATUS    Status                // status code indicating error type.
    );

//
// RXCE_IND_RECEIVE indication handler definition.  This client routine is
// called by the transport provider when a connection-oriented TSDU is received
// that should be presented to the client.
//
// A Receive event handler can return one of three distinguished error codes to
// initiate a different course of action in the connection engine.
//
// STATUS_SUCCESS -- Data was copied directly from the TSDU. The amout of data that
// was taken is indicated in the parameter BytesTaken.
//
// STATUS_MORE_PROCESSING_REQUIRED -- The client has returned a buffer into which the
// data should be copied. This is typically the case when BytesAvailable is greater than
// BytesIndicated. In such cases the RxCe will copy the remaining data into the buffer
// that is specified. Note that when this status code is returned from the client it is
// conceivable that the client can demand more data than is available to be copied into
// the buffer. In such cases the subsequent indications till this criterion is met is not
// passed back to the user till the copy is completed. On completion of this copy the
// RxCe notifies the client by invoking the RxCeDataReadyEventHandler.
//
// STATUS_DATA_NOT_ACCEPTED - The client has refused the data.
//

typedef
NTSTATUS
(*PRXCE_IND_RECEIVE)(
    IN PVOID pRxCeEventContext,       // the context provided during registration
    IN PRXCE_VC    pVc,           // the associated VC handle
    IN ULONG ReceiveFlags,            // the receive flags
    IN ULONG BytesIndicated,          // the number of received bytes indicated
    IN ULONG BytesAvailable,          // the total number of bytes available
    OUT ULONG *BytesTaken,            // return indication of the bytes consumed
    IN PVOID Tsdu,                    // pointer describing this TSDU, typically a lump of bytes
    OUT PMDL *pDataBufferPointer,     // the buffer for copying the bytes not indicated.
    OUT PULONG  pDataBufferSize       // amount of data to copy
    );


//
// RXCE_IND_RECEIVE_DATAGRAM indication handler definition.  This client routine
// is called by the transport provider when a connectionless TSDU is received
// that should be presented to the client.
//
// A Receive event handler can return one of three distinguished error codes to
// initiate a different course of action in the connection engine.
//
// STATUS_SUCCESS -- Data was copied directly from the TSDU. The amout of data that
// was taken is indicated in the parameter BytesTaken.
//
// STATUS_MORE_PROCESSING_REQUIRED -- The client has returned a buffer into which the
// data should be copied. This is typically the case when BytesAvailable is greater than
// BytesIndicated. In such cases the RxCe will copy the remaining data into the buffer
// that is specified. Note that when this status code is returned from the client it is
// conceivable that the client can demand more data than is available to be copied into
// the buffer. In such cases the subsequent indications till this criterion is met is not
// passed back to the user till the copy is completed. On completion of this copy the
// RxCe notifies the client by invoking the RxCeDataReadyEventHandler.
//
// STATUS_DATA_NOT_ACCEPTED - The client has refused the data.
//
//

typedef
NTSTATUS
(*PRXCE_IND_RECEIVE_DATAGRAM)(
    IN PVOID   pRxCeEventContext,      // the event context
    IN int     SourceAddressLength,    // length of the originator of the datagram
    IN PVOID   SourceAddress,          // string describing the originator of the datagram
    IN int     OptionsLength,          // options for the receive
    IN PVOID   Options,                //
    IN ULONG   ReceiveDatagramFlags,   //
    IN ULONG   BytesIndicated,         // number of bytes this indication
    IN ULONG   BytesAvailable,         // number of bytes in complete Tsdu
    OUT ULONG  *BytesTaken,            // number of bytes used
    IN PVOID   Tsdu,                   // pointer describing this TSDU, typically a lump of bytes
    OUT PMDL *pDataBufferPointer,      // the buffer in which data is to be copied.
    OUT PULONG  pDataBufferSize        // amount of data to copy
    );

//
// This indication is delivered if expedited data is received on the connection.
// This will only occur in providers that support expedited data.
//
// A Receive event handler can return one of three distinguished error codes to
// initiate a different course of action in the connection engine.
//
// STATUS_SUCCESS -- Data was copied directly from the TSDU. The amout of data that
// was taken is indicated in the parameter BytesTaken.
//
// STATUS_MORE_PROCESSING_REQUIRED -- The client has returned a buffer into which the
// data should be copied. This is typically the case when BytesAvailable is greater than
// BytesIndicated. In such cases the RxCe will copy the remaining data into the buffer
// that is specified. Note that when this status code is returned from the client it is
// conceivable that the client can demand more data than is available to be copied into
// the buffer. In such cases the subsequent indications till this criterion is met is not
// passed back to the user till the copy is completed. On completion of this copy the
// RxCe notifies the client by invoking the RxCeDataReadyEventHandler.
//
// STATUS_DATA_NOT_ACCEPTED - The client has refused the data.
//

typedef
NTSTATUS
(*PRXCE_IND_RECEIVE_EXPEDITED)(
    IN PVOID pRxCeEventContext,     // the context provided during registration
    IN PRXCE_VC     pVc,        // the associated VC handle
    IN ULONG ReceiveFlags,          //
    IN ULONG BytesIndicated,        // number of bytes in this indication
    IN ULONG BytesAvailable,        // number of bytes in complete Tsdu
    OUT ULONG *BytesTaken,          // number of bytes used by indication routine
    IN PVOID Tsdu,                  // pointer describing this TSDU, typically a lump of bytes
    OUT PMDL *pDataBufferPointer,   // the buffer in which data is to be copied.
    OUT PULONG  pDataBufferSize     // amount of data to copy
    );

//
// This indication is delivered if there is room for a send in the buffer of
// a buffering protocol.
//

typedef
NTSTATUS
(*PRXCE_IND_SEND_POSSIBLE)(
    IN PVOID pRxCeEventContext,
    IN PRXCE_VC pVc,
    IN ULONG BytesAvailable);

//
// RxCeDataReadyEventHandler -- This is invoked when the desired data is available
// for client consumption. This always follows a receive indication in which the
// client returns a buffer for copying the remaining data
//

typedef
NTSTATUS
(*PRXCE_IND_DATA_READY)(
   IN PVOID         pEventContext,
   IN PMDL  pBuffer,
   IN ULONG         CopiedDataSize,
   IN NTSTATUS      CopyDataStatus);


//
// RxCeSendCompleteEventHandler -- This is invoked when the send has been successfully completed
// The buffer and the length sent are passed in as parameters
//

typedef
NTSTATUS
(*PRXCE_IND_SEND_COMPLETE)(
   IN PVOID       pEventContext,
   IN PVOID       pCompletionContext,
   IN NTSTATUS    Status);


typedef
NTSTATUS
(*PRXCE_IND_CONNECTION_SEND_COMPLETE)(
   IN PVOID          pEventContext,
   IN PRXCE_VC       pVc,
   IN PVOID          pCompletionContext,
   IN NTSTATUS       Status);

typedef
NTSTATUS
(*PRXCE_IND_CONNECTION_SEND_SUBMITTED)(
   IN PVOID          pEventContext,
   IN PRXCE_VC       pVc,
   IN PVOID          pCompletionContext,
   IN NTSTATUS       Status);

//
// Event Handler Dispatch Vector definitions ....
//

typedef struct _RXCE_ADDRESS_EVENT_HANDLER_ {
   PRXCE_IND_ENDPOINT_ERROR   RxCeErrorEventHandler;
   PRXCE_IND_RECEIVE_DATAGRAM RxCeReceiveDatagramEventHandler;
   PRXCE_IND_DATA_READY       RxCeDataReadyEventHandler;
   PRXCE_IND_SEND_POSSIBLE    RxCeSendPossibleEventHandler;
   PRXCE_IND_SEND_COMPLETE    RxCeSendCompleteEventHandler;
} RXCE_ADDRESS_EVENT_HANDLER, *PRXCE_ADDRESS_EVENT_HANDLER;

typedef struct _RXCE_CONNECTION_EVENT_HANDLER_ {
   PRXCE_IND_DISCONNECT                   RxCeDisconnectEventHandler;
   PRXCE_IND_CONNECTION_ERROR             RxCeErrorEventHandler;
   PRXCE_IND_RECEIVE                      RxCeReceiveEventHandler;
   PRXCE_IND_RECEIVE_DATAGRAM             RxCeReceiveDatagramEventHandler;
   PRXCE_IND_RECEIVE_EXPEDITED            RxCeReceiveExpeditedEventHandler;
   PRXCE_IND_SEND_POSSIBLE                RxCeSendPossibleEventHandler;
   PRXCE_IND_DATA_READY                   RxCeDataReadyEventHandler;
   PRXCE_IND_CONNECTION_SEND_SUBMITTED    RxCeSendSubmittedEventHandler;
   PRXCE_IND_CONNECTION_SEND_COMPLETE     RxCeSendCompleteEventHandler;
} RXCE_CONNECTION_EVENT_HANDLER, *PRXCE_CONNECTION_EVENT_HANDLER;

#endif // _RXCEHDLR_H_


#elif (NTDDI_VERSION >= NTDDI_WIN2K)

/*++ BUILD Version: 0009    // Increment this if a change has global effects
Copyright (c) 1987-1993  Microsoft Corporation

Module Name:

    rxcehdlr.h

Abstract:

    This is the include file that defines all constants and types for
    accessing the redirector file system connection engine.

Revision History:
Notes:

    The Connection engine is designed to map and emulate the TDI specs. as closely
    as possible. This implies that on NT we will have a very efficient mechanism
    which fully exploits the underlying TDI implementation.

    All the necessary types can be redefined in terms of the types defined in
    \nt\private\inc\tdi.h in the case of NT. For Win95 we will provide the
    appropriate definitions.

--*/

#ifndef _RXCEHDLR_H_
#define _RXCEHDLR_H_

#include "tdi.h"

typedef TDI_PROVIDER_INFO RXCE_TRANSPORT_PROVIDER_INFO;
typedef RXCE_TRANSPORT_PROVIDER_INFO* PRXCE_TRANSPORT_PROVIDER_INFO;

typedef TDI_CONNECTION_INFORMATION RXCE_CONNECTION_INFORMATION;
typedef RXCE_CONNECTION_INFORMATION* PRXCE_CONNECTION_INFORMATION;

typedef TDI_CONNECTION_INFORMATION RXCE_CONNECTION_INFORMATION;
typedef RXCE_CONNECTION_INFORMATION* PRXCE_CONNECTION_INFORMATION;

typedef TDI_CONNECTION_INFO RXCE_CONNECTION_INFO;
typedef RXCE_CONNECTION_INFO* PRXCE_CONNECTION_INFO;

typedef struct _RXCE_TRANSPORT_INFORMATION_ {
   RXCE_TRANSPORT_PROVIDER_INFO;

   ULONG  ConnectionCount;
   ULONG  QualityOfService;
} RXCE_TRANSPORT_INFORMATION, *PRXCE_TRANSPORT_INFORMATION;

typedef enum _RXCE_CONNECTION_INFORMATION_CLASS_ {
    RxCeTransportProviderInformation = 1,
    RxCeConnectionInformation,
    RxCeConnectionEndpointInformation,
    RxCeRemoteAddressInformation
} RXCE_CONNECTION_INFORMATION_CLASS,
  *PRXCE_CONNECTION_INFORMATION_CLASS;

typedef struct _RXCE_VC_         *PRXCE_VC;
typedef struct _RXCE_CONNECTION_ *PRXCE_CONNECTION;
typedef struct _RXCE_ADDRESS_    *PRXCE_ADDRESS;
typedef struct _RXCE_TRANSPORT_  *PRXCE_TRANSPORT;

//
// Disconnection indication prototype. This is invoked when a connection is
// being disconnected for a reason other than the user requesting it.
//

typedef
NTSTATUS
(*PRXCE_IND_DISCONNECT)(
    IN PVOID            pRxCeEventContext,
    IN PRXCE_VC         pVc,
    IN int              DisconnectDataLength,
    IN PVOID            DisconnectData,
    IN int              DisconnectInformationLength,
    IN PVOID            DisconnectInformation,
    IN ULONG            DisconnectFlags
    );

//
// A protocol error has occurred when this indication happens. This indication
// occurs only for errors of the worst type; the address this indication is
// delivered to is no longer usable for protocol-related operations, and
// should not be used for operations henceforth. All connections associated
// it are invalid.
//

typedef
NTSTATUS
(*PRXCE_IND_ENDPOINT_ERROR)(
    IN PVOID    pRxCeEventContext,    // the event context.
    IN NTSTATUS Status                // status code indicating error type.
    );


typedef
NTSTATUS
(*PRXCE_IND_CONNECTION_ERROR)(
    IN PVOID       pRxCeEventContext,    // the event context.
    PRXCE_VC       pVc,                  // the associated VC handle
    IN NTSTATUS    Status                // status code indicating error type.
    );

//
// RXCE_IND_RECEIVE indication handler definition.  This client routine is
// called by the transport provider when a connection-oriented TSDU is received
// that should be presented to the client.
//
// A Receive event handler can return one of three distinguished error codes to
// initiate a different course of action in the connection engine.
//
// STATUS_SUCCESS -- Data was copied directly from the TSDU. The amout of data that
// was taken is indicated in the parameter BytesTaken.
//
// STATUS_MORE_PROCESSING_REQUIRED -- The client has returned a buffer into which the
// data should be copied. This is typically the case when BytesAvailable is greater than
// BytesIndicated. In such cases the RxCe will copy the remaining data into the buffer
// that is specified. Note that when this status code is returned from the client it is
// conceivable that the client can demand more data than is available to be copied into
// the buffer. In such cases the subsequent indications till this criterion is met is not
// passed back to the user till the copy is completed. On completion of this copy the
// RxCe notifies the client by invoking the RxCeDataReadyEventHandler.
//
// STATUS_DATA_NOT_ACCEPTED - The client has refused the data.
//

typedef
NTSTATUS
(*PRXCE_IND_RECEIVE)(
    IN PVOID pRxCeEventContext,       // the context provided during registration
    IN PRXCE_VC    pVc,           // the associated VC handle
    IN ULONG ReceiveFlags,            // the receive flags
    IN ULONG BytesIndicated,          // the number of received bytes indicated
    IN ULONG BytesAvailable,          // the total number of bytes available
    OUT ULONG *BytesTaken,            // return indication of the bytes consumed
    IN PVOID Tsdu,                    // pointer describing this TSDU, typically a lump of bytes
    OUT PMDL *pDataBufferPointer,     // the buffer for copying the bytes not indicated.
    OUT PULONG  pDataBufferSize       // amount of data to copy
    );


//
// RXCE_IND_RECEIVE_DATAGRAM indication handler definition.  This client routine
// is called by the transport provider when a connectionless TSDU is received
// that should be presented to the client.
//
// A Receive event handler can return one of three distinguished error codes to
// initiate a different course of action in the connection engine.
//
// STATUS_SUCCESS -- Data was copied directly from the TSDU. The amout of data that
// was taken is indicated in the parameter BytesTaken.
//
// STATUS_MORE_PROCESSING_REQUIRED -- The client has returned a buffer into which the
// data should be copied. This is typically the case when BytesAvailable is greater than
// BytesIndicated. In such cases the RxCe will copy the remaining data into the buffer
// that is specified. Note that when this status code is returned from the client it is
// conceivable that the client can demand more data than is available to be copied into
// the buffer. In such cases the subsequent indications till this criterion is met is not
// passed back to the user till the copy is completed. On completion of this copy the
// RxCe notifies the client by invoking the RxCeDataReadyEventHandler.
//
// STATUS_DATA_NOT_ACCEPTED - The client has refused the data.
//
//

typedef
NTSTATUS
(*PRXCE_IND_RECEIVE_DATAGRAM)(
    IN PVOID   pRxCeEventContext,      // the event context
    IN int     SourceAddressLength,    // length of the originator of the datagram
    IN PVOID   SourceAddress,          // string describing the originator of the datagram
    IN int     OptionsLength,          // options for the receive
    IN PVOID   Options,                //
    IN ULONG   ReceiveDatagramFlags,   //
    IN ULONG   BytesIndicated,         // number of bytes this indication
    IN ULONG   BytesAvailable,         // number of bytes in complete Tsdu
    OUT ULONG  *BytesTaken,            // number of bytes used
    IN PVOID   Tsdu,                   // pointer describing this TSDU, typically a lump of bytes
    OUT PMDL *pDataBufferPointer,      // the buffer in which data is to be copied.
    OUT PULONG  pDataBufferSize        // amount of data to copy
    );

//
// This indication is delivered if expedited data is received on the connection.
// This will only occur in providers that support expedited data.
//
// A Receive event handler can return one of three distinguished error codes to
// initiate a different course of action in the connection engine.
//
// STATUS_SUCCESS -- Data was copied directly from the TSDU. The amout of data that
// was taken is indicated in the parameter BytesTaken.
//
// STATUS_MORE_PROCESSING_REQUIRED -- The client has returned a buffer into which the
// data should be copied. This is typically the case when BytesAvailable is greater than
// BytesIndicated. In such cases the RxCe will copy the remaining data into the buffer
// that is specified. Note that when this status code is returned from the client it is
// conceivable that the client can demand more data than is available to be copied into
// the buffer. In such cases the subsequent indications till this criterion is met is not
// passed back to the user till the copy is completed. On completion of this copy the
// RxCe notifies the client by invoking the RxCeDataReadyEventHandler.
//
// STATUS_DATA_NOT_ACCEPTED - The client has refused the data.
//

typedef
NTSTATUS
(*PRXCE_IND_RECEIVE_EXPEDITED)(
    IN PVOID pRxCeEventContext,     // the context provided during registration
    IN PRXCE_VC     pVc,        // the associated VC handle
    IN ULONG ReceiveFlags,          //
    IN ULONG BytesIndicated,        // number of bytes in this indication
    IN ULONG BytesAvailable,        // number of bytes in complete Tsdu
    OUT ULONG *BytesTaken,          // number of bytes used by indication routine
    IN PVOID Tsdu,                  // pointer describing this TSDU, typically a lump of bytes
    OUT PMDL *pDataBufferPointer,   // the buffer in which data is to be copied.
    OUT PULONG  pDataBufferSize     // amount of data to copy
    );

//
// This indication is delivered if there is room for a send in the buffer of
// a buffering protocol.
//

typedef
NTSTATUS
(*PRXCE_IND_SEND_POSSIBLE)(
    IN PVOID pRxCeEventContext,
    IN PRXCE_VC pVc,
    IN ULONG BytesAvailable);

//
// RxCeDataReadyEventHandler -- This is invoked when the desired data is available
// for client consumption. This always follows a receive indication in which the
// client returns a buffer for copying the remaining data
//

typedef
NTSTATUS
(*PRXCE_IND_DATA_READY)(
   IN PVOID         pEventContext,
   IN PMDL  pBuffer,
   IN ULONG         CopiedDataSize,
   IN NTSTATUS      CopyDataStatus);


//
// RxCeSendCompleteEventHandler -- This is invoked when the send has been successfully completed
// The buffer and the length sent are passed in as parameters
//

typedef
NTSTATUS
(*PRXCE_IND_SEND_COMPLETE)(
   IN PVOID       pEventContext,
   IN PVOID       pCompletionContext,
   IN NTSTATUS    Status);


typedef
NTSTATUS
(*PRXCE_IND_CONNECTION_SEND_COMPLETE)(
   IN PVOID          pEventContext,
   IN PRXCE_VC       pVc,
   IN PVOID          pCompletionContext,
   IN NTSTATUS       Status);

typedef
NTSTATUS
(*PRXCE_IND_CONNECTION_SEND_SUBMITTED)(
   IN PVOID          pEventContext,
   IN PRXCE_VC       pVc,
   IN PVOID          pCompletionContext,
   IN NTSTATUS       Status);

//
// Event Handler Dispatch Vector definitions ....
//

typedef struct _RXCE_ADDRESS_EVENT_HANDLER_ {
   PRXCE_IND_ENDPOINT_ERROR   RxCeErrorEventHandler;
   PRXCE_IND_RECEIVE_DATAGRAM RxCeReceiveDatagramEventHandler;
   PRXCE_IND_DATA_READY       RxCeDataReadyEventHandler;
   PRXCE_IND_SEND_POSSIBLE    RxCeSendPossibleEventHandler;
   PRXCE_IND_SEND_COMPLETE    RxCeSendCompleteEventHandler;
} RXCE_ADDRESS_EVENT_HANDLER, *PRXCE_ADDRESS_EVENT_HANDLER;

typedef struct _RXCE_CONNECTION_EVENT_HANDLER_ {
   PRXCE_IND_DISCONNECT                   RxCeDisconnectEventHandler;
   PRXCE_IND_CONNECTION_ERROR             RxCeErrorEventHandler;
   PRXCE_IND_RECEIVE                      RxCeReceiveEventHandler;
   PRXCE_IND_RECEIVE_DATAGRAM             RxCeReceiveDatagramEventHandler;
   PRXCE_IND_RECEIVE_EXPEDITED            RxCeReceiveExpeditedEventHandler;
   PRXCE_IND_SEND_POSSIBLE                RxCeSendPossibleEventHandler;
   PRXCE_IND_DATA_READY                   RxCeDataReadyEventHandler;
   PRXCE_IND_CONNECTION_SEND_SUBMITTED    RxCeSendSubmittedEventHandler;
   PRXCE_IND_CONNECTION_SEND_COMPLETE     RxCeSendCompleteEventHandler;
} RXCE_CONNECTION_EVENT_HANDLER, *PRXCE_CONNECTION_EVENT_HANDLER;

#endif // _RXCEHDLR_H_


#else /* NTDDI_VERSION */

#error This file cannot be included for this NTDDI_VERSION.

#endif /* NTDDI_VERSION */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\rxcontx.h ===
#if !defined(NTDDI_VERSION)

#error NTDDI_VERSION must be defined to include this file.

#elif (NTDDI_VERSION >= NTDDI_VISTA)

/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    RxContx.h

Abstract:

    This module defines RxContext data structure. This structure is used to
    describe an Irp whil it is being processed and contains state information
    that allows global resources to be released as the irp is completed.

Author:
Notes:

    The RX_CONTEXT is a data structure to which additional information provided
    by the various mini redirectors need to be attached. This can be done in one
    of the following three ways

      1) Allow for context pointers to be defined as part of the RX_CONTEXT which
      the mini redirectors can use to squirrel away their information. This
      implies that every time an RX_CONTEXT is allocated/destroyed the mini
      redirector has to perform an associated allocation/destruction.

      Since RX_CONTEXT's are created/destroyed in great numbers, this is not an
      acceptable solution.

      2) The second approach consists of over allocating RX_CONTEXT's by a
      prespecified amount for each mini redirector which is then reserved for
      use by the mini redirector. Such an approach avoids the additional
      allocation/destruction but complicates the RX_CONTEXT management code in
      the wrapper.

      3) The third approach ( the one that is implemented ) consists of allocating
      a prespecfied area which is the same for all mini redirectors as part of
      each RX_CONTEXT. This is an unformatted area on top of which any desired
      structure can be imposed by the various mini redirectors. Such an approach
      overcomes the disadvantages associated with (1) and (2).

      All mini redirector writers must try and define the associated mini redirector
      contexts to fit into this area. Those mini redirectors who violate this
      rule will incur a significant performance penalty.

--*/

#ifndef _RX_CONTEXT_STRUCT_DEFINED_
#define _RX_CONTEXT_STRUCT_DEFINED_
#ifndef RDBSS_TRACKER
#error tracker must be defined right now
#endif

#define RX_TOPLEVELIRP_CONTEXT_SIGNATURE ('LTxR')
typedef struct _RX_TOPLEVELIRP_CONTEXT {
    union {
#ifndef __cplusplus
        LIST_ENTRY;
#endif //  __cplusplus
        LIST_ENTRY ListEntry;
    };
    ULONG Signature;
    PRDBSS_DEVICE_OBJECT RxDeviceObject;
    PRX_CONTEXT RxContext;
    PIRP Irp;
    ULONG Flags;
    PVOID Previous;
    PETHREAD Thread;
} RX_TOPLEVELIRP_CONTEXT, *PRX_TOPLEVELIRP_CONTEXT;

BOOLEAN
RxTryToBecomeTheTopLevelIrp (
    IN OUT PRX_TOPLEVELIRP_CONTEXT TopLevelContext,
    IN PIRP Irp,
    IN PRDBSS_DEVICE_OBJECT RxDeviceObject,
    IN BOOLEAN ForceTopLevel
    );

VOID
__RxInitializeTopLevelIrpContext (
    IN OUT  PRX_TOPLEVELIRP_CONTEXT TopLevelContext,
    IN PIRP Irp,
    IN PRDBSS_DEVICE_OBJECT RxDeviceObject,
    IN ULONG Flags
    );
#define RxInitializeTopLevelIrpContext(a,b,c) {__RxInitializeTopLevelIrpContext(a,b,c,0);}

PIRP
RxGetTopIrpIfRdbssIrp (
    VOID
    );

PRDBSS_DEVICE_OBJECT
RxGetTopDeviceObjectIfRdbssIrp (
    VOID
    );

VOID
RxUnwindTopLevelIrp (
    IN OUT PRX_TOPLEVELIRP_CONTEXT TopLevelContext
    );

BOOLEAN
RxIsThisTheTopLevelIrp (
    IN PIRP Irp
    );

#ifdef RDBSS_TRACKER
typedef struct _RX_FCBTRACKER_CALLINFO {
    ULONG AcquireRelease;
    USHORT SavedTrackerValue;
    USHORT LineNumber;
    PSZ   FileName;
    ULONG Flags;
} RX_FCBTRACKER_CALLINFO, *PRX_FCBTRACKER_CALLINFO;
#define RDBSS_TRACKER_HISTORY_SIZE 32
#endif

#define MRX_CONTEXT_FIELD_COUNT    4
#define MRX_CONTEXT_SIZE   (sizeof(PVOID) * MRX_CONTEXT_FIELD_COUNT)

//
//  Define rxdriver dispatch routine type....almost all of the important routine
//  will have this type.
//

typedef
NTSTATUS
(NTAPI *PRX_DISPATCH) (
    IN PRX_CONTEXT RxContext,
    IN PIRP Irp
    );

//
//  predeclare dfs types
//

typedef struct _DFS_NAME_CONTEXT_ *PDFS_NAME_CONTEXT;

typedef struct _NT_CREATE_PARAMETERS {
    ACCESS_MASK DesiredAccess;
    LARGE_INTEGER AllocationSize;
    ULONG FileAttributes;
    ULONG ShareAccess;
    ULONG Disposition;
    ULONG CreateOptions;
    PIO_SECURITY_CONTEXT SecurityContext;
    SECURITY_IMPERSONATION_LEVEL ImpersonationLevel;
    PVOID DfsContext;
    PDFS_NAME_CONTEXT DfsNameContext;
} NT_CREATE_PARAMETERS, *PNT_CREATE_PARAMETERS;

typedef struct _RX_CONTEXT {
    
    //
    //  the node type, size and reference count, aka standard header
    // 

    NODE_TYPE_CODE NodeTypeCode;
    NODE_BYTE_SIZE NodeByteSize;
    __volatile ULONG ReferenceCount;

    //
    //  the list entry to wire the context to the list of active contexts
    //

    LIST_ENTRY ContextListEntry;

    //
    //  Major and minor function of the IRP associated with the context
    //

    UCHAR MajorFunction;
    UCHAR MinorFunction;

    //
    //  this is similar to the same field in Irps; it
    //  allows callback routines for async operations
    //  to know whether to do asynchronous work or not
    //

    BOOLEAN PendingReturned;

    //
    //  indicates if the associated request is to be posted to a RDBSS worker thread.
    //

    BOOLEAN PostRequest;

    //
    //  Originating Device (required for workque algorithms)
    //  not currently used but could be used for local minis
    //

    PDEVICE_OBJECT RealDevice;

    //
    //  ptr to the originating Irp
    //

    PIRP CurrentIrp;

    //
    //  ptr to the IRP stack location
    //

    PIO_STACK_LOCATION CurrentIrpSp;

    //
    //  ptr to the FCB and FOBX, derived from the context pointers in the
    //  file object associated with the IRP
    //

    PMRX_FCB pFcb;
    PMRX_FOBX pFobx;
    PMRX_SRV_OPEN pRelevantSrvOpen;
    PNON_PAGED_FCB NonPagedFcb;

    //
    //  device object calldown (not irpsp.....)
    //

    PRDBSS_DEVICE_OBJECT RxDeviceObject;

    //
    //  The original thread in which the request was initiated and the last
    //  thread in which some processing associated with the context was done
    //

    PETHREAD OriginalThread;
    PETHREAD LastExecutionThread;

    __volatile PVOID LockManagerContext;

    //
    //  One word of the context is given to rdbss for dbg information
    //

    PVOID RdbssDbgExtension;

    RX_SCAVENGER_ENTRY ScavengerEntry;

    //
    //  global serial number for this operation
    //

    ULONG SerialNumber;

    //
    //  used by minirdrs to see if multiple calls are part
    //  of the same larger operation and (therefore) more cacheable
    //

    ULONG FobxSerialNumber;

    ULONG Flags;

    BOOLEAN FcbResourceAcquired;
    BOOLEAN FcbPagingIoResourceAcquired;
    UCHAR MustSucceedDescriptorNumber;

    //
    //  mostly you want the individual components...sometimes it's nice as a pair
    //  used to record the status when you can't just return it; e.g., when
    //  RXSTATUS is not an appropriate return type or if the consumer of the
    //  status didn't call directly (lowiocompletions). minirdrs will not need
    //  to set the information directly
    //

    union {
        struct {
            union {
                NTSTATUS StoredStatus;
                PVOID StoredStatusAlignment;
            };
            ULONG_PTR InformationToReturn;
        };
        IO_STATUS_BLOCK IoStatusBlock;
    };

    //
    //  the context fields provided for use by the mini redirectors
    //  this is defined as a union to force longlong alignment
    //

    union {
        ULONGLONG ForceLonglongAligmentDummyField;
        PVOID MRxContext[MRX_CONTEXT_FIELD_COUNT];
    };

    //
    //  The following field is included to fix the problem related to write only
    //  opens. This introduces a new field for the mini redirector to squirrel
    //  some state. This is redundant and should be removed after Windows 2000.
    //  Having a unique field reduces the impact of the change that we are making
    //  to the specific code path. It will be ideal to use one of the MRXContext
    //  fields defined above
    //

    PVOID WriteOnlyOpenRetryContext;

    //
    //  the cancellation routine to be invoked, set by the mini redirector
    //

    PMRX_CALLDOWN MRxCancelRoutine;

    //
    //  private dispatch, if any. used in fspdisp
    //

    PRX_DISPATCH ResumeRoutine;

    //
    //  for posting to worker threads
    //  the minirdr can use this for posting within the minirdr
    //  a potential problem can arise if the minirdr relies on this both
    //  for queueing async stuff and for queueing cancel stuff
    //

    //
    //  The OverflowListEntry is used for queueing items to the overflow queue.
    //  This is seperate now to allow us to distinguish between an item in the overflow
    //  queue and one in the active work queue (for cancellation logic)
    //

    RX_WORK_QUEUE_ITEM WorkQueueItem;
    LIST_ENTRY OverflowListEntry;

    //
    //  this event is used for synchronous operations
    //  that have to i/f with an underlying async service. it can be used
    //  by the minirdr with the following provisions:
    //      1) on entering the minirdr through lowio, it is set to the
    //         nonsignaled state (but a wise user will reset it before using
    //         it....particularly if it's used multiple times.
    //      2) if you are returning STATUS_PENDING on a sync operation, you must
    //         return with it set to the nonsignaled state; that is, either
    //         you don't use it or you reset it in this case
    //

    KEVENT SyncEvent;

    //
    //  this is a list head of operations that are to be released on completion
    //

    LIST_ENTRY BlockedOperations;

    //
    //  this is the mutex that controls serialization of the blocked operations
    //

    PFAST_MUTEX BlockedOpsMutex;

    //
    //  these links are used to serialize pipe operations on a
    //  per-file-object basis AND FOR LOTS OF OTHER STUFF
    //

    LIST_ENTRY RxContextSerializationQLinks;

    union {
        struct {
            union {
                FS_INFORMATION_CLASS FsInformationClass;
                FILE_INFORMATION_CLASS FileInformationClass;
            };
            PVOID Buffer;
            union {
                LONG Length;
                LONG LengthRemaining;
            };
            BOOLEAN ReplaceIfExists;
            BOOLEAN AdvanceOnly;
        } Info;

        struct {
            UNICODE_STRING SuppliedPathName;
            NET_ROOT_TYPE NetRootType;
            PIO_SECURITY_CONTEXT pSecurityContext;
        } PrefixClaim;
    };

    //
    //  THIS UNION MUST BE LAST....AT SOME POINT, WE MAY START ALLOCATING
    //  SMALLER PER OPERATION!
    //

    union{
        struct {
            NT_CREATE_PARAMETERS NtCreateParameters; //  a copy of the createparameters
            ULONG ReturnedCreateInformation;
            PWCH CanonicalNameBuffer;  // if the canonical name is larger than available buffer
            PRX_PREFIX_ENTRY NetNamePrefixEntry;   // the entry returned by the lookup....for dereferencing

            PMRX_SRV_CALL pSrvCall;              // Server Call being used
            PMRX_NET_ROOT pNetRoot;              // Net Root being used
            PMRX_V_NET_ROOT pVNetRoot;             // Virtual Net Root
            //PMRX_SRV_OPEN        pSrvOpen;              // Server Open

            PVOID EaBuffer;
            ULONG EaLength;

            ULONG SdLength;

            ULONG PipeType;
            ULONG PipeReadMode;
            ULONG PipeCompletionMode;

            USHORT Flags;
            NET_ROOT_TYPE Type;                 // Type of Net Root(Pipe/File/Mailslot..)
            UCHAR         RdrFlags;             // Flags for use by the RDR while processing the request.

            BOOLEAN FcbAcquired;
            BOOLEAN TryForScavengingOnSharingViolation;
            BOOLEAN ScavengingAlreadyTried;

            BOOLEAN ThisIsATreeConnectOpen;
            BOOLEAN TreeConnectOpenDeferred;
            UNICODE_STRING TransportName;
            UNICODE_STRING UserName;
            UNICODE_STRING Password;
            UNICODE_STRING UserDomainName;
        } Create;
        struct {
            ULONG FileIndex;
            BOOLEAN RestartScan;
            BOOLEAN ReturnSingleEntry;
            BOOLEAN IndexSpecified;
            BOOLEAN InitialQuery;
        } QueryDirectory;
        struct {
            PMRX_V_NET_ROOT pVNetRoot;
        } NotifyChangeDirectory;
        struct {
            PUCHAR UserEaList;
            ULONG UserEaListLength;
            ULONG UserEaIndex;
            BOOLEAN RestartScan;
            BOOLEAN ReturnSingleEntry;
            BOOLEAN IndexSpecified;
        } QueryEa;
        struct {
            SECURITY_INFORMATION SecurityInformation;
            ULONG Length;
        } QuerySecurity;
        struct {
            SECURITY_INFORMATION SecurityInformation;
            PSECURITY_DESCRIPTOR SecurityDescriptor;
        } SetSecurity;
        struct {
            ULONG Length;
            PSID StartSid;
            PFILE_GET_QUOTA_INFORMATION SidList;
            ULONG SidListLength;
            BOOLEAN RestartScan;
            BOOLEAN ReturnSingleEntry;
            BOOLEAN IndexSpecified;
        } QueryQuota;
        struct {
            ULONG Length;

        } SetQuota;
        struct {
            PV_NET_ROOT VNetRoot;
            PSRV_CALL SrvCall;
            PNET_ROOT NetRoot;
        } DosVolumeFunction;
        struct {
            ULONG FlagsForLowIo;
            LOWIO_CONTEXT LowIoContext;        //  the LOWIO parameters
        }; //  no name here....
        LUID FsdUid;
    } ;

    //
    //  CODE.IMPROVEMENT remove this to wrapperdbgprivates
    //

    PWCH AlsoCanonicalNameBuffer;  //  if the canonical name is larger than available buffer
    PUNICODE_STRING LoudCompletionString;

#ifdef RDBSS_TRACKER
    __volatile LONG AcquireReleaseFcbTrackerX;
    __volatile ULONG TrackerHistoryPointer;
    RX_FCBTRACKER_CALLINFO TrackerHistory[RDBSS_TRACKER_HISTORY_SIZE];
#endif

#if DBG
    ULONG ShadowCritOwner;
#endif

} RX_CONTEXT, *PRX_CONTEXT;

typedef enum {
    RX_CONTEXT_FLAG_FROM_POOL =                     0x00000001,
    RX_CONTEXT_FLAG_WAIT =                          0x00000002,
    RX_CONTEXT_FLAG_WRITE_THROUGH =                 0x00000004,
    RX_CONTEXT_FLAG_FLOPPY =                        0x00000008,
    RX_CONTEXT_FLAG_RECURSIVE_CALL =                0x00000010,
    RX_CONTEXT_FLAG_THIS_DEVICE_TOP_LEVEL =         0x00000020,
    RX_CONTEXT_FLAG_DEFERRED_WRITE =                0x00000040,
    RX_CONTEXT_FLAG_VERIFY_READ =                   0x00000080,
    RX_CONTEXT_FLAG_STACK_IO_CONTEZT =              0x00000100,
    RX_CONTEXT_FLAG_IN_FSP =                        0x00000200,
    RX_CONTEXT_FLAG_CREATE_MAILSLOT =               0x00000400,
    RX_CONTEXT_FLAG_MAILSLOT_REPARSE =              0x00000800,
    RX_CONTEXT_FLAG_ASYNC_OPERATION =               0x00001000,
    RX_CONTEXT_FLAG_NO_COMPLETE_FROM_FSP =          0x00002000,
    RX_CONTEXT_FLAG_POST_ON_STABLE_CONDITION =      0x00004000,
    RX_CONTEXT_FLAG_FSP_DELAYED_OVERFLOW_QUEUE =    0x00008000,
    RX_CONTEXT_FLAG_FSP_CRITICAL_OVERFLOW_QUEUE =   0x00010000,
    RX_CONTEXT_FLAG_MINIRDR_INVOKED =               0x00020000,
    RX_CONTEXT_FLAG_WAITING_FOR_RESOURCE =          0x00040000,
    RX_CONTEXT_FLAG_CANCELLED =                     0x00080000,
    RX_CONTEXT_FLAG_SYNC_EVENT_WAITERS =            0x00100000,
    RX_CONTEXT_FLAG_NO_PREPOSTING_NEEDED =          0x00200000,
    RX_CONTEXT_FLAG_BYPASS_VALIDOP_CHECK =          0x00400000,
    RX_CONTEXT_FLAG_BLOCKED_PIPE_RESUME =           0x00800000,
    RX_CONTEXT_FLAG_IN_SERIALIZATION_QUEUE =        0x01000000,
    RX_CONTEXT_FLAG_NO_EXCEPTION_BREAKPOINT =       0x02000000,
    RX_CONTEXT_FLAG_NEEDRECONNECT =                 0x04000000,
    RX_CONTEXT_FLAG_MUST_SUCCEED =                  0x08000000,
    RX_CONTEXT_FLAG_MUST_SUCCEED_NONBLOCKING =      0x10000000,
    RX_CONTEXT_FLAG_MUST_SUCCEED_ALLOCATED =        0x20000000,
    RX_CONTEXT_FLAG_MINIRDR_INITIATED =             0x80000000,   
} RX_CONTEXT_FLAGS;

#define RX_CONTEXT_PRESERVED_FLAGS (RX_CONTEXT_FLAG_FROM_POOL | \
                                    RX_CONTEXT_FLAG_MUST_SUCCEED_ALLOCATED | \
                                    RX_CONTEXT_FLAG_IN_FSP)

#define RX_CONTEXT_INITIALIZATION_FLAGS (RX_CONTEXT_FLAG_WAIT | \
                                         RX_CONTEXT_FLAG_MUST_SUCCEED | \
                                         RX_CONTEXT_FLAG_MUST_SUCCEED_NONBLOCKING)

typedef enum {
    RX_CONTEXT_CREATE_FLAG_UNC_NAME =                       0x1,
    RX_CONTEXT_CREATE_FLAG_STRIPPED_TRAILING_BACKSLASH =    0x2,
    RX_CONTEXT_CREATE_FLAG_ADDEDBACKSLASH =                 0x4,
    RX_CONTEXT_CREATE_FLAG_REPARSE =                        0x8,
    RX_CONTEXT_CREATE_FLAG_SPECIAL_PATH =                   0x10,
} RX_CONTEXT_CREATE_FLAGS;

typedef enum {
    RXCONTEXT_FLAG4LOWIO_PIPE_OPERATION =                   0x1,
    RXCONTEXT_FLAG4LOWIO_PIPE_SYNC_OPERATION =              0x2,
    RXCONTEXT_FLAG4LOWIO_READAHEAD =                        0x4,
    RXCONTEXT_FLAG4LOWIO_THIS_READ_ENLARGED =               0x8,
    RXCONTEXT_FLAG4LOWIO_THIS_IO_BUFFERED =                 0x10,
    RXCONTEXT_FLAG4LOWIO_LOCK_FCB_RESOURCE_HELD =           0x20,
    RXCONTEXT_FLAG4LOWIO_LOCK_WAS_QUEUED_IN_LOCKMANAGER =   0x40,
    RXCONTEXT_FLAG4LOWIO_THIS_IO_FAST =                     0x80,
    RXCONTEXT_FLAG4LOWIO_LOCK_OPERATION_COMPLETED =         0x100,
    RXCONTEXT_FLAG4LOWIO_LOCK_BUFFERED_ON_ENTRY   =         0x200

#ifdef __cplusplus
} RX_CONTEXT_LOWIO_FLAGS;
#else // !__cplusplus
} RX_CONTEXT_CREATE_FLAGS;
#endif // __cplusplus

//
//  Macros used to control whether the wrapper breakpoints on an exception
//

#if DBG
#define RxSaveAndSetExceptionNoBreakpointFlag( RXCONTEXT,OLDFLAG ) { \
    OLDFLAG = FlagOn( RxContext->Flags, RX_CONTEXT_FLAG_NO_EXCEPTION_BREAKPOINT );\
    SetFlag( RxContext->Flags, RX_CONTEXT_FLAG_NO_EXCEPTION_BREAKPOINT );      \
}
#define RxRestoreExceptionNoBreakpointFlag( RXCONTEXT,OLDFLAG ) { \
    ClearFlag( RxContext->Flags, RX_CONTEXT_FLAG_NO_EXCEPTION_BREAKPOINT );    \
    SetFlag( RxContext->Flags, OLDFLAG );                              \
}
#else
#define RxSaveAndSetExceptionNoBreakpointFlag(RXCONTEXT,OLDFLAG)
#define RxRestoreExceptionNoBreakpointFlag(RXCONTEXT,OLDFLAG)
#endif

//
//  a macro used to ensure that a context hasn't been freed during a wait
//

#if DBG
VOID
__RxItsTheSameContext(
    __in PRX_CONTEXT RxContext,
    __in ULONG CapturedRxContextSerialNumber,
    __in ULONG Line,
    __in PCSTR File
    );
#define RxItsTheSameContext() {__RxItsTheSameContext(RxContext,CapturedRxContextSerialNumber,__LINE__,__FILE__);}
#else
#define RxItsTheSameContext() {NOTHING;}
#endif

extern NPAGED_LOOKASIDE_LIST RxContextLookasideList;

//
//  Macros used in the RDBSS to wrap mini rdr calldowns
//

#define MINIRDR_CALL_THROUGH(STATUS,DISPATCH,FUNC,ARGLIST)                 \
   {                                                                       \
    ASSERT(DISPATCH);                                                      \
    ASSERT( NodeType(DISPATCH) == RDBSS_NTC_MINIRDR_DISPATCH );            \
    if (DISPATCH->FUNC == NULL) {                                          \
        STATUS = STATUS_NOT_IMPLEMENTED;                                   \
    } else {                                                               \
        RxDbgTrace(0, Dbg, ("MiniRdr Calldown - %s\n",#FUNC));             \
        STATUS = DISPATCH->FUNC ARGLIST;                                   \
    }                                                                      \
   }

#define MINIRDR_CALL(STATUS,CONTEXT,DISPATCH,FUNC,ARGLIST)                 \
   {                                                                       \
    ASSERT(DISPATCH);                                                      \
    ASSERT( NodeType(DISPATCH) == RDBSS_NTC_MINIRDR_DISPATCH );            \
    if ( DISPATCH->FUNC == NULL) {                                         \
       STATUS = STATUS_NOT_IMPLEMENTED;                                    \
    } else {                                                               \
       if (!BooleanFlagOn((CONTEXT)->Flags,RX_CONTEXT_FLAG_CANCELLED)) {   \
          RxDbgTrace(0, Dbg, ("MiniRdr Calldown - %s\n",#FUNC));           \
          RtlZeroMemory(&((CONTEXT)->MRxContext[0]),                       \
                        sizeof((CONTEXT)->MRxContext));                    \
          STATUS = DISPATCH->FUNC ARGLIST;                                 \
       } else {                                                            \
          STATUS = STATUS_CANCELLED;                                       \
       }                                                                   \
    }                                                                      \
   }


//              
//  VOID
//  RxWaitSync (
//      IN PRX_CONTEXT RxContext
//      )
//              

#define  RxWaitSync( RxContext )                                                 \
         RxDbgTrace(+1, Dbg, ("RxWaitSync, RxContext = %08lx\n", (RxContext)));  \
         (RxContext)->Flags |= RX_CONTEXT_FLAG_SYNC_EVENT_WAITERS;               \
         KeWaitForSingleObject( &(RxContext)->SyncEvent,                         \
                               Executive, KernelMode, FALSE, NULL );             \
         RxDbgTrace(-1, Dbg, ("RxWaitSync -> VOID\n", 0 ))

//             
//  VOID
//  RxSignalSynchronousWaiter (
//      IN PRX_CONTEXT RxContext
//  ) 
//             

#define RxSignalSynchronousWaiter( RxContext )                     \
        (RxContext)->Flags &= ~RX_CONTEXT_FLAG_SYNC_EVENT_WAITERS; \
        KeSetEvent( &(RxContext)->SyncEvent, 0, FALSE )


#define RxInsertContextInSerializationQueue( SerializationQueue, RxContext ) \
        (RxContext)->Flags |= RX_CONTEXT_FLAG_IN_SERIALIZATION_QUEUE;       \
        InsertTailList( SerializationQueue, &((RxContext)->RxContextSerializationQLinks ))

INLINE 
PRX_CONTEXT
RxRemoveFirstContextFromSerializationQueue (
    PLIST_ENTRY SerializationQueue
    )
{
   if (IsListEmpty( SerializationQueue )) {
      return NULL;
   } else {
      PRX_CONTEXT Context = (PRX_CONTEXT)(CONTAINING_RECORD( SerializationQueue->Flink,
                                            RX_CONTEXT,
                                            RxContextSerializationQLinks ));

      RemoveEntryList( SerializationQueue->Flink );

      Context->RxContextSerializationQLinks.Flink = NULL;
      Context->RxContextSerializationQLinks.Blink = NULL;
      return Context;
   }
}

//
//  The following macros provide a mechanism for doing an en masse transfer
//  from one list onto another. This provides a powerful paradigm for dealing
//  with DPC level processing of lists.
//

#define RxTransferList( Destination, Source )                  \
         if (IsListEmpty( (Source) )) {                        \
            InitializeListHead( (Destination) );               \
         } else {                                              \
            *(Destination) = *(Source);                        \
            (Destination)->Flink->Blink = (Destination);       \
            (Destination)->Blink->Flink = (Destination);       \
            InitializeListHead( (Source) );                    \
         }

#define RxTransferListWithMutex( Destination, Source, Mutex )  \
    {                                                          \
        ExAcquireFastMutex( Mutex );                           \
        RxTransferList( Destination, Source );                 \
        ExReleaseFastMutex( Mutex );                           \
    }


VOID 
RxInitializeRxContexter (
    VOID
    );

VOID 
RxUninitializeRxContexter (
    VOID
    );

NTSTATUS
RxCancelNotifyChangeDirectoryRequestsForVNetRoot (
   PV_NET_ROOT VNetRoot,
   BOOLEAN ForceFilesClosed
   );

VOID
RxCancelNotifyChangeDirectoryRequestsForFobx (
   PFOBX Fobx
   );

NTSTATUS
NTAPI
RxSetMinirdrCancelRoutine (
    IN OUT PRX_CONTEXT RxContext,
    IN PMRX_CALLDOWN MRxCancelRoutine
    );

VOID
NTAPI
RxInitializeContext (
    IN PIRP Irp,
    IN PRDBSS_DEVICE_OBJECT RxDeviceObject,
    IN ULONG InitialContextFlags,
    IN OUT PRX_CONTEXT RxContext
    );

PRX_CONTEXT
NTAPI
RxCreateRxContext (
    IN PIRP Irp,
    IN PRDBSS_DEVICE_OBJECT RxDeviceObject,
    IN ULONG InitialContextFlags
    );

VOID
NTAPI
RxPrepareContextForReuse (
   IN OUT PRX_CONTEXT RxContext
   );

VOID
NTAPI
RxDereferenceAndDeleteRxContext_Real (
    IN PRX_CONTEXT RxContext
    );

VOID
NTAPI
RxReinitializeContext (
   IN OUT PRX_CONTEXT RxContext
   );

#if DBG
#define RxDereferenceAndDeleteRxContext(RXCONTEXT) {   \
    RxDereferenceAndDeleteRxContext_Real((RXCONTEXT)); \
    (RXCONTEXT) = NULL;                    \
}
#else
#define RxDereferenceAndDeleteRxContext(RXCONTEXT) {   \
    RxDereferenceAndDeleteRxContext_Real((RXCONTEXT)); \
}
#endif //

extern FAST_MUTEX RxContextPerFileSerializationMutex;

NTSTATUS
NTAPI
__RxSynchronizeBlockingOperations (
    IN OUT PRX_CONTEXT RxContext,
    IN PFCB Fcb,
    IN OUT PLIST_ENTRY BlockingIoQ,
    IN BOOLEAN DropFcbLock
    );
#define RxSynchronizeBlockingOperationsAndDropFcbLock(RXCONTEXT,FCB,IOQUEUE) \
              __RxSynchronizeBlockingOperations(RXCONTEXT,FCB,IOQUEUE,TRUE)
#define RxSynchronizeBlockingOperations(RXCONTEXT,FCB,IOQUEUE) \
              __RxSynchronizeBlockingOperations(RXCONTEXT,FCB,IOQUEUE,FALSE)

VOID
NTAPI
RxResumeBlockedOperations_Serially (
    IN OUT PRX_CONTEXT RxContext,
    IN OUT PLIST_ENTRY BlockingIoQ
    );

VOID
RxResumeBlockedOperations_ALL (
    IN OUT PRX_CONTEXT RxContext
    );


VOID
RxCancelBlockingOperation (
    IN OUT PRX_CONTEXT RxContext,
    IN PIRP Irp
    );

VOID
RxRemoveOperationFromBlockingQueue (
    IN OUT PRX_CONTEXT RxContext
    );

#endif // _RX_CONTEXT_STRUCT_DEFINED_


#elif (NTDDI_VERSION >= NTDDI_WS03)

/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    RxContx.h

Abstract:

    This module defines RxContext data structure. This structure is used to
    describe an Irp whil it is being processed and contains state information
    that allows global resources to be released as the irp is completed.

Author:
Notes:

    The RX_CONTEXT is a data structure to which additional information provided
    by the various mini redirectors need to be attached. This can be done in one
    of the following three ways

      1) Allow for context pointers to be defined as part of the RX_CONTEXT which
      the mini redirectors can use to squirrel away their information. This
      implies that every time an RX_CONTEXT is allocated/destroyed the mini
      redirector has to perform an associated allocation/destruction.

      Since RX_CONTEXT's are created/destroyed in great numbers, this is not an
      acceptable solution.

      2) The second approach consists of over allocating RX_CONTEXT's by a
      prespecified amount for each mini redirector which is then reserved for
      use by the mini redirector. Such an approach avoids the additional
      allocation/destruction but complicates the RX_CONTEXT management code in
      the wrapper.

      3) The third approach ( the one that is implemented ) consists of allocating
      a prespecfied area which is the same for all mini redirectors as part of
      each RX_CONTEXT. This is an unformatted area on top of which any desired
      structure can be imposed by the various mini redirectors. Such an approach
      overcomes the disadvantages associated with (1) and (2).

      All mini redirector writers must try and define the associated mini redirector
      contexts to fit into this area. Those mini redirectors who violate this
      rule will incur a significant performance penalty.

--*/

#ifndef _RX_CONTEXT_STRUCT_DEFINED_
#define _RX_CONTEXT_STRUCT_DEFINED_
#ifndef RDBSS_TRACKER
#error tracker must be defined right now
#endif

#define RX_TOPLEVELIRP_CONTEXT_SIGNATURE ('LTxR')
typedef struct _RX_TOPLEVELIRP_CONTEXT {
    union {
#ifndef __cplusplus
        LIST_ENTRY;
#endif //  __cplusplus
        LIST_ENTRY ListEntry;
    };
    ULONG Signature;
    PRDBSS_DEVICE_OBJECT RxDeviceObject;
    PRX_CONTEXT RxContext;
    PIRP Irp;
    ULONG Flags;
    PVOID Previous;
    PETHREAD Thread;
} RX_TOPLEVELIRP_CONTEXT, *PRX_TOPLEVELIRP_CONTEXT;

BOOLEAN
RxTryToBecomeTheTopLevelIrp (
    IN OUT PRX_TOPLEVELIRP_CONTEXT TopLevelContext,
    IN PIRP Irp,
    IN PRDBSS_DEVICE_OBJECT RxDeviceObject,
    IN BOOLEAN ForceTopLevel
    );

VOID
__RxInitializeTopLevelIrpContext (
    IN OUT  PRX_TOPLEVELIRP_CONTEXT TopLevelContext,
    IN PIRP Irp,
    IN PRDBSS_DEVICE_OBJECT RxDeviceObject,
    IN ULONG Flags
    );
#define RxInitializeTopLevelIrpContext(a,b,c) {__RxInitializeTopLevelIrpContext(a,b,c,0);}

PIRP
RxGetTopIrpIfRdbssIrp (
    VOID
    );

PRDBSS_DEVICE_OBJECT
RxGetTopDeviceObjectIfRdbssIrp (
    VOID
    );

VOID
RxUnwindTopLevelIrp (
    IN OUT PRX_TOPLEVELIRP_CONTEXT TopLevelContext
    );

BOOLEAN
RxIsThisTheTopLevelIrp (
    IN PIRP Irp
    );

#ifdef RDBSS_TRACKER
typedef struct _RX_FCBTRACKER_CALLINFO {
    ULONG AcquireRelease;
    USHORT SavedTrackerValue;
    USHORT LineNumber;
    PSZ   FileName;
    ULONG Flags;
} RX_FCBTRACKER_CALLINFO, *PRX_FCBTRACKER_CALLINFO;
#define RDBSS_TRACKER_HISTORY_SIZE 32
#endif

#define MRX_CONTEXT_FIELD_COUNT    4
#define MRX_CONTEXT_SIZE   (sizeof(PVOID) * MRX_CONTEXT_FIELD_COUNT)

//
//  Define rxdriver dispatch routine type....almost all of the important routine
//  will have this type.
//

typedef
NTSTATUS
(NTAPI *PRX_DISPATCH) (
    IN PRX_CONTEXT RxContext,
    IN PIRP Irp
    );

//
//  predeclare dfs types
//

typedef struct _DFS_NAME_CONTEXT_ *PDFS_NAME_CONTEXT;

typedef struct _NT_CREATE_PARAMETERS {
    ACCESS_MASK DesiredAccess;
    LARGE_INTEGER AllocationSize;
    ULONG FileAttributes;
    ULONG ShareAccess;
    ULONG Disposition;
    ULONG CreateOptions;
    PIO_SECURITY_CONTEXT SecurityContext;
    SECURITY_IMPERSONATION_LEVEL ImpersonationLevel;
    PVOID DfsContext;
    PDFS_NAME_CONTEXT DfsNameContext;
} NT_CREATE_PARAMETERS, *PNT_CREATE_PARAMETERS;

typedef struct _RX_CONTEXT {
    
    //
    //  the node type, size and reference count, aka standard header
    // 

    NODE_TYPE_CODE NodeTypeCode;
    NODE_BYTE_SIZE NodeByteSize;
    ULONG ReferenceCount;

    //
    //  the list entry to wire the context to the list of active contexts
    //

    LIST_ENTRY ContextListEntry;

    //
    //  Major and minor function of the IRP associated with the context
    //

    UCHAR MajorFunction;
    UCHAR MinorFunction;

    //
    //  this is similar to the same field in Irps; it
    //  allows callback routines for async operations
    //  to know whether to do asynchronous work or not
    //

    BOOLEAN PendingReturned;

    //
    //  indicates if the associated request is to be posted to a RDBSS worker thread.
    //

    BOOLEAN PostRequest;

    //
    //  Originating Device (required for workque algorithms)
    //  not currently used but could be used for local minis
    //

    PDEVICE_OBJECT RealDevice;

    //
    //  ptr to the originating Irp
    //

    PIRP CurrentIrp;

    //
    //  ptr to the IRP stack location
    //

    PIO_STACK_LOCATION CurrentIrpSp;

    //
    //  ptr to the FCB and FOBX, derived from the context pointers in the
    //  file object associated with the IRP
    //

    PMRX_FCB pFcb;
    PMRX_FOBX pFobx;
    PMRX_SRV_OPEN pRelevantSrvOpen;
    PNON_PAGED_FCB NonPagedFcb;

    //
    //  device object calldown (not irpsp.....)
    //

    PRDBSS_DEVICE_OBJECT RxDeviceObject;

    //
    //  The original thread in which the request was initiated and the last
    //  thread in which some processing associated with the context was done
    //

    PETHREAD OriginalThread;
    PETHREAD LastExecutionThread;

    PVOID LockManagerContext;

    //
    //  One word of the context is given to rdbss for dbg information
    //

    PVOID RdbssDbgExtension;

    RX_SCAVENGER_ENTRY ScavengerEntry;

    //
    //  global serial number for this operation
    //

    ULONG SerialNumber;

    //
    //  used by minirdrs to see if multiple calls are part
    //  of the same larger operation and (therefore) more cacheable
    //

    ULONG FobxSerialNumber;

    ULONG Flags;

    BOOLEAN FcbResourceAcquired;
    BOOLEAN FcbPagingIoResourceAcquired;
    UCHAR MustSucceedDescriptorNumber;

    //
    //  mostly you want the individual components...sometimes it's nice as a pair
    //  used to record the status when you can't just return it; e.g., when
    //  RXSTATUS is not an appropriate return type or if the consumer of the
    //  status didn't call directly (lowiocompletions). minirdrs will not need
    //  to set the information directly
    //

    union {
        struct {
            union {
                NTSTATUS StoredStatus;
                PVOID StoredStatusAlignment;
            };
            ULONG_PTR InformationToReturn;
        };
        IO_STATUS_BLOCK IoStatusBlock;
    };

    //
    //  the context fields provided for use by the mini redirectors
    //  this is defined as a union to force longlong alignment
    //

    union {
        ULONGLONG ForceLonglongAligmentDummyField;
        PVOID MRxContext[MRX_CONTEXT_FIELD_COUNT];
    };

    //
    //  The following field is included to fix the problem related to write only
    //  opens. This introduces a new field for the mini redirector to squirrel
    //  some state. This is redundant and should be removed after Windows 2000.
    //  Having a unique field reduces the impact of the change that we are making
    //  to the specific code path. It will be ideal to use one of the MRXContext
    //  fields defined above
    //

    PVOID WriteOnlyOpenRetryContext;

    //
    //  the cancellation routine to be invoked, set by the mini redirector
    //

    PMRX_CALLDOWN MRxCancelRoutine;

    //
    //  private dispatch, if any. used in fspdisp
    //

    PRX_DISPATCH ResumeRoutine;

    //
    //  for posting to worker threads
    //  the minirdr can use this for posting within the minirdr
    //  a potential problem can arise if the minirdr relies on this both
    //  for queueing async stuff and for queueing cancel stuff
    //

    //
    //  The OverflowListEntry is used for queueing items to the overflow queue.
    //  This is seperate now to allow us to distinguish between an item in the overflow
    //  queue and one in the active work queue (for cancellation logic)
    //

    RX_WORK_QUEUE_ITEM WorkQueueItem;
    LIST_ENTRY OverflowListEntry;

    //
    //  this event is used for synchronous operations
    //  that have to i/f with an underlying async service. it can be used
    //  by the minirdr with the following provisions:
    //      1) on entering the minirdr through lowio, it is set to the
    //         nonsignaled state (but a wise user will reset it before using
    //         it....particularly if it's used multiple times.
    //      2) if you are returning STATUS_PENDING on a sync operation, you must
    //         return with it set to the nonsignaled state; that is, either
    //         you don't use it or you reset it in this case
    //

    KEVENT SyncEvent;

    //
    //  this is a list head of operations that are to be released on completion
    //

    LIST_ENTRY BlockedOperations;

    //
    //  this is the mutex that controls serialization of the blocked operations
    //

    PFAST_MUTEX BlockedOpsMutex;

    //
    //  these links are used to serialize pipe operations on a
    //  per-file-object basis AND FOR LOTS OF OTHER STUFF
    //

    LIST_ENTRY RxContextSerializationQLinks;

    union {
        struct {
            union {
                FS_INFORMATION_CLASS FsInformationClass;
                FILE_INFORMATION_CLASS FileInformationClass;
            };
            PVOID Buffer;
            union {
                LONG Length;
                LONG LengthRemaining;
            };
            BOOLEAN ReplaceIfExists;
            BOOLEAN AdvanceOnly;
        } Info;

        struct {
            UNICODE_STRING SuppliedPathName;
            NET_ROOT_TYPE NetRootType;
            PIO_SECURITY_CONTEXT pSecurityContext;
        } PrefixClaim;
    };

    //
    //  THIS UNION MUST BE LAST....AT SOME POINT, WE MAY START ALLOCATING
    //  SMALLER PER OPERATION!
    //

    union{
        struct {
            NT_CREATE_PARAMETERS NtCreateParameters; //  a copy of the createparameters
            ULONG ReturnedCreateInformation;
            PWCH CanonicalNameBuffer;  // if the canonical name is larger than available buffer
            PRX_PREFIX_ENTRY NetNamePrefixEntry;   // the entry returned by the lookup....for dereferencing

            PMRX_SRV_CALL pSrvCall;              // Server Call being used
            PMRX_NET_ROOT pNetRoot;              // Net Root being used
            PMRX_V_NET_ROOT pVNetRoot;             // Virtual Net Root
            //PMRX_SRV_OPEN        pSrvOpen;              // Server Open

            PVOID EaBuffer;
            ULONG EaLength;

            ULONG SdLength;

            ULONG PipeType;
            ULONG PipeReadMode;
            ULONG PipeCompletionMode;

            USHORT Flags;
            NET_ROOT_TYPE Type;                 // Type of Net Root(Pipe/File/Mailslot..)
            UCHAR         RdrFlags;             // Flags for use by the RDR while processing the request.

            BOOLEAN FcbAcquired;
            BOOLEAN TryForScavengingOnSharingViolation;
            BOOLEAN ScavengingAlreadyTried;

            BOOLEAN ThisIsATreeConnectOpen;
            BOOLEAN TreeConnectOpenDeferred;
            UNICODE_STRING TransportName;
            UNICODE_STRING UserName;
            UNICODE_STRING Password;
            UNICODE_STRING UserDomainName;
        } Create;
        struct {
            ULONG FileIndex;
            BOOLEAN RestartScan;
            BOOLEAN ReturnSingleEntry;
            BOOLEAN IndexSpecified;
            BOOLEAN InitialQuery;
        } QueryDirectory;
        struct {
            PMRX_V_NET_ROOT pVNetRoot;
        } NotifyChangeDirectory;
        struct {
            PUCHAR UserEaList;
            ULONG UserEaListLength;
            ULONG UserEaIndex;
            BOOLEAN RestartScan;
            BOOLEAN ReturnSingleEntry;
            BOOLEAN IndexSpecified;
        } QueryEa;
        struct {
            SECURITY_INFORMATION SecurityInformation;
            ULONG Length;
        } QuerySecurity;
        struct {
            SECURITY_INFORMATION SecurityInformation;
            PSECURITY_DESCRIPTOR SecurityDescriptor;
        } SetSecurity;
        struct {
            ULONG Length;
            PSID StartSid;
            PFILE_GET_QUOTA_INFORMATION SidList;
            ULONG SidListLength;
            BOOLEAN RestartScan;
            BOOLEAN ReturnSingleEntry;
            BOOLEAN IndexSpecified;
        } QueryQuota;
        struct {
            ULONG Length;

        } SetQuota;
        struct {
            PV_NET_ROOT VNetRoot;
            PSRV_CALL SrvCall;
            PNET_ROOT NetRoot;
        } DosVolumeFunction;
        struct {
            ULONG FlagsForLowIo;
            LOWIO_CONTEXT LowIoContext;        //  the LOWIO parameters
        }; //  no name here....
        LUID FsdUid;
    } ;

    //
    //  CODE.IMPROVEMENT remove this to wrapperdbgprivates
    //

    PWCH AlsoCanonicalNameBuffer;  //  if the canonical name is larger than available buffer
    PUNICODE_STRING LoudCompletionString;

#ifdef RDBSS_TRACKER
    LONG AcquireReleaseFcbTrackerX;
    ULONG TrackerHistoryPointer;
    RX_FCBTRACKER_CALLINFO TrackerHistory[RDBSS_TRACKER_HISTORY_SIZE];
#endif

#if DBG
    ULONG ShadowCritOwner;
#endif

} RX_CONTEXT, *PRX_CONTEXT;

typedef enum {
    RX_CONTEXT_FLAG_FROM_POOL =                     0x00000001,
    RX_CONTEXT_FLAG_WAIT =                          0x00000002,
    RX_CONTEXT_FLAG_WRITE_THROUGH =                 0x00000004,
    RX_CONTEXT_FLAG_FLOPPY =                        0x00000008,
    RX_CONTEXT_FLAG_RECURSIVE_CALL =                0x00000010,
    RX_CONTEXT_FLAG_THIS_DEVICE_TOP_LEVEL =         0x00000020,
    RX_CONTEXT_FLAG_DEFERRED_WRITE =                0x00000040,
    RX_CONTEXT_FLAG_VERIFY_READ =                   0x00000080,
    RX_CONTEXT_FLAG_STACK_IO_CONTEZT =              0x00000100,
    RX_CONTEXT_FLAG_IN_FSP =                        0x00000200,
    RX_CONTEXT_FLAG_CREATE_MAILSLOT =               0x00000400,
    RX_CONTEXT_FLAG_MAILSLOT_REPARSE =              0x00000800,
    RX_CONTEXT_FLAG_ASYNC_OPERATION =               0x00001000,
    RX_CONTEXT_FLAG_NO_COMPLETE_FROM_FSP =          0x00002000,
    RX_CONTEXT_FLAG_POST_ON_STABLE_CONDITION =      0x00004000,
    RX_CONTEXT_FLAG_FSP_DELAYED_OVERFLOW_QUEUE =    0x00008000,
    RX_CONTEXT_FLAG_FSP_CRITICAL_OVERFLOW_QUEUE =   0x00010000,
    RX_CONTEXT_FLAG_MINIRDR_INVOKED =               0x00020000,
    RX_CONTEXT_FLAG_WAITING_FOR_RESOURCE =          0x00040000,
    RX_CONTEXT_FLAG_CANCELLED =                     0x00080000,
    RX_CONTEXT_FLAG_SYNC_EVENT_WAITERS =            0x00100000,
    RX_CONTEXT_FLAG_NO_PREPOSTING_NEEDED =          0x00200000,
    RX_CONTEXT_FLAG_BYPASS_VALIDOP_CHECK =          0x00400000,
    RX_CONTEXT_FLAG_BLOCKED_PIPE_RESUME =           0x00800000,
    RX_CONTEXT_FLAG_IN_SERIALIZATION_QUEUE =        0x01000000,
    RX_CONTEXT_FLAG_NO_EXCEPTION_BREAKPOINT =       0x02000000,
    RX_CONTEXT_FLAG_NEEDRECONNECT =                 0x04000000,
    RX_CONTEXT_FLAG_MUST_SUCCEED =                  0x08000000,
    RX_CONTEXT_FLAG_MUST_SUCCEED_NONBLOCKING =      0x10000000,
    RX_CONTEXT_FLAG_MUST_SUCCEED_ALLOCATED =        0x20000000,
    RX_CONTEXT_FLAG_MINIRDR_INITIATED =             0x80000000,   
} RX_CONTEXT_FLAGS;

#define RX_CONTEXT_PRESERVED_FLAGS (RX_CONTEXT_FLAG_FROM_POOL | \
                                    RX_CONTEXT_FLAG_MUST_SUCCEED_ALLOCATED | \
                                    RX_CONTEXT_FLAG_IN_FSP)

#define RX_CONTEXT_INITIALIZATION_FLAGS (RX_CONTEXT_FLAG_WAIT | \
                                         RX_CONTEXT_FLAG_MUST_SUCCEED | \
                                         RX_CONTEXT_FLAG_MUST_SUCCEED_NONBLOCKING)

typedef enum {
    RX_CONTEXT_CREATE_FLAG_UNC_NAME =                       0x1,
    RX_CONTEXT_CREATE_FLAG_STRIPPED_TRAILING_BACKSLASH =    0x2,
    RX_CONTEXT_CREATE_FLAG_ADDEDBACKSLASH =                 0x4,
    RX_CONTEXT_CREATE_FLAG_REPARSE =                        0x8,
    RX_CONTEXT_CREATE_FLAG_SPECIAL_PATH =                   0x10,
} RX_CONTEXT_CREATE_FLAGS;

typedef enum {
    RXCONTEXT_FLAG4LOWIO_PIPE_OPERATION =                   0x1,
    RXCONTEXT_FLAG4LOWIO_PIPE_SYNC_OPERATION =              0x2,
    RXCONTEXT_FLAG4LOWIO_READAHEAD =                        0x4,
    RXCONTEXT_FLAG4LOWIO_THIS_READ_ENLARGED =               0x8,
    RXCONTEXT_FLAG4LOWIO_THIS_IO_BUFFERED =                 0x10,
    RXCONTEXT_FLAG4LOWIO_LOCK_FCB_RESOURCE_HELD =           0x20,
    RXCONTEXT_FLAG4LOWIO_LOCK_WAS_QUEUED_IN_LOCKMANAGER =   0x40,
    RXCONTEXT_FLAG4LOWIO_THIS_IO_FAST =                     0x80,
    RXCONTEXT_FLAG4LOWIO_LOCK_OPERATION_COMPLETED =         0x100,
    RXCONTEXT_FLAG4LOWIO_LOCK_BUFFERED_ON_ENTRY   =         0x200

#ifdef __cplusplus
} RX_CONTEXT_LOWIO_FLAGS;
#else // !__cplusplus
} RX_CONTEXT_CREATE_FLAGS;
#endif // __cplusplus

//
//  Macros used to control whether the wrapper breakpoints on an exception
//

#if DBG
#define RxSaveAndSetExceptionNoBreakpointFlag( RXCONTEXT,OLDFLAG ) { \
    OLDFLAG = FlagOn( RxContext->Flags, RX_CONTEXT_FLAG_NO_EXCEPTION_BREAKPOINT );\
    SetFlag( RxContext->Flags, RX_CONTEXT_FLAG_NO_EXCEPTION_BREAKPOINT );      \
}
#define RxRestoreExceptionNoBreakpointFlag( RXCONTEXT,OLDFLAG ) { \
    ClearFlag( RxContext->Flags, RX_CONTEXT_FLAG_NO_EXCEPTION_BREAKPOINT );    \
    SetFlag( RxContext->Flags, OLDFLAG );                              \
}
#else
#define RxSaveAndSetExceptionNoBreakpointFlag(RXCONTEXT,OLDFLAG)
#define RxRestoreExceptionNoBreakpointFlag(RXCONTEXT,OLDFLAG)
#endif

//
//  a macro used to ensure that a context hasn't been freed during a wait
//

#if DBG
VOID
__RxItsTheSameContext(
    PRX_CONTEXT RxContext,
    ULONG CapturedRxContextSerialNumber,
    ULONG Line,
    PSZ File
    );
#define RxItsTheSameContext() {__RxItsTheSameContext(RxContext,CapturedRxContextSerialNumber,__LINE__,__FILE__);}
#else
#define RxItsTheSameContext() {NOTHING;}
#endif

extern NPAGED_LOOKASIDE_LIST RxContextLookasideList;

//
//  Macros used in the RDBSS to wrap mini rdr calldowns
//

#define MINIRDR_CALL_THROUGH(STATUS,DISPATCH,FUNC,ARGLIST)                 \
   {                                                                       \
    ASSERT(DISPATCH);                                                      \
    ASSERT( NodeType(DISPATCH) == RDBSS_NTC_MINIRDR_DISPATCH );            \
    if (DISPATCH->FUNC == NULL) {                                          \
        STATUS = STATUS_NOT_IMPLEMENTED;                                   \
    } else {                                                               \
        RxDbgTrace(0, Dbg, ("MiniRdr Calldown - %s\n",#FUNC));             \
        STATUS = DISPATCH->FUNC ARGLIST;                                   \
    }                                                                      \
   }

#define MINIRDR_CALL(STATUS,CONTEXT,DISPATCH,FUNC,ARGLIST)                 \
   {                                                                       \
    ASSERT(DISPATCH);                                                      \
    ASSERT( NodeType(DISPATCH) == RDBSS_NTC_MINIRDR_DISPATCH );            \
    if ( DISPATCH->FUNC == NULL) {                                         \
       STATUS = STATUS_NOT_IMPLEMENTED;                                    \
    } else {                                                               \
       if (!BooleanFlagOn((CONTEXT)->Flags,RX_CONTEXT_FLAG_CANCELLED)) {   \
          RxDbgTrace(0, Dbg, ("MiniRdr Calldown - %s\n",#FUNC));           \
          RtlZeroMemory(&((CONTEXT)->MRxContext[0]),                       \
                        sizeof((CONTEXT)->MRxContext));                    \
          STATUS = DISPATCH->FUNC ARGLIST;                                 \
       } else {                                                            \
          STATUS = STATUS_CANCELLED;                                       \
       }                                                                   \
    }                                                                      \
   }


//              
//  VOID
//  RxWaitSync (
//      IN PRX_CONTEXT RxContext
//      )
//              

#define  RxWaitSync( RxContext )                                                 \
         RxDbgTrace(+1, Dbg, ("RxWaitSync, RxContext = %08lx\n", (RxContext)));  \
         (RxContext)->Flags |= RX_CONTEXT_FLAG_SYNC_EVENT_WAITERS;               \
         KeWaitForSingleObject( &(RxContext)->SyncEvent,                         \
                               Executive, KernelMode, FALSE, NULL );             \
         RxDbgTrace(-1, Dbg, ("RxWaitSync -> VOID\n", 0 ))

//             
//  VOID
//  RxSignalSynchronousWaiter (
//      IN PRX_CONTEXT RxContext
//  ) 
//             

#define RxSignalSynchronousWaiter( RxContext )                     \
        (RxContext)->Flags &= ~RX_CONTEXT_FLAG_SYNC_EVENT_WAITERS; \
        KeSetEvent( &(RxContext)->SyncEvent, 0, FALSE )


#define RxInsertContextInSerializationQueue( SerializationQueue, RxContext ) \
        (RxContext)->Flags |= RX_CONTEXT_FLAG_IN_SERIALIZATION_QUEUE;       \
        InsertTailList( SerializationQueue, &((RxContext)->RxContextSerializationQLinks ))

INLINE 
PRX_CONTEXT
RxRemoveFirstContextFromSerializationQueue (
    PLIST_ENTRY SerializationQueue
    )
{
   if (IsListEmpty( SerializationQueue )) {
      return NULL;
   } else {
      PRX_CONTEXT Context = (PRX_CONTEXT)(CONTAINING_RECORD( SerializationQueue->Flink,
                                            RX_CONTEXT,
                                            RxContextSerializationQLinks ));

      RemoveEntryList( SerializationQueue->Flink );

      Context->RxContextSerializationQLinks.Flink = NULL;
      Context->RxContextSerializationQLinks.Blink = NULL;
      return Context;
   }
}

//
//  The following macros provide a mechanism for doing an en masse transfer
//  from one list onto another. This provides a powerful paradigm for dealing
//  with DPC level processing of lists.
//

#define RxTransferList( Destination, Source )                  \
         if (IsListEmpty( (Source) )) {                        \
            InitializeListHead( (Destination) );               \
         } else {                                              \
            *(Destination) = *(Source);                        \
            (Destination)->Flink->Blink = (Destination);       \
            (Destination)->Blink->Flink = (Destination);       \
            InitializeListHead( (Source) );                    \
         }

#define RxTransferListWithMutex( Destination, Source, Mutex )  \
    {                                                          \
        ExAcquireFastMutex( Mutex );                           \
        RxTransferList( Destination, Source );                 \
        ExReleaseFastMutex( Mutex );                           \
    }


VOID 
RxInitializeRxContexter (
    VOID
    );

VOID 
RxUninitializeRxContexter (
    VOID
    );

NTSTATUS
RxCancelNotifyChangeDirectoryRequestsForVNetRoot (
   PV_NET_ROOT VNetRoot,
   BOOLEAN ForceFilesClosed
   );

VOID
RxCancelNotifyChangeDirectoryRequestsForFobx (
   PFOBX Fobx
   );

NTSTATUS
NTAPI
RxSetMinirdrCancelRoutine (
    IN OUT PRX_CONTEXT RxContext,
    IN PMRX_CALLDOWN MRxCancelRoutine
    );

VOID
NTAPI
RxInitializeContext (
    IN PIRP Irp,
    IN PRDBSS_DEVICE_OBJECT RxDeviceObject,
    IN ULONG InitialContextFlags,
    IN OUT PRX_CONTEXT RxContext
    );

PRX_CONTEXT
NTAPI
RxCreateRxContext (
    IN PIRP Irp,
    IN PRDBSS_DEVICE_OBJECT RxDeviceObject,
    IN ULONG InitialContextFlags
    );

VOID
NTAPI
RxPrepareContextForReuse (
   IN OUT PRX_CONTEXT RxContext
   );

VOID
NTAPI
RxDereferenceAndDeleteRxContext_Real (
    IN PRX_CONTEXT RxContext
    );

VOID
NTAPI
RxReinitializeContext (
   IN OUT PRX_CONTEXT RxContext
   );

#if DBG
#define RxDereferenceAndDeleteRxContext(RXCONTEXT) {   \
    RxDereferenceAndDeleteRxContext_Real((RXCONTEXT)); \
    (RXCONTEXT) = NULL;                    \
}
#else
#define RxDereferenceAndDeleteRxContext(RXCONTEXT) {   \
    RxDereferenceAndDeleteRxContext_Real((RXCONTEXT)); \
}
#endif //

extern FAST_MUTEX RxContextPerFileSerializationMutex;

NTSTATUS
NTAPI
__RxSynchronizeBlockingOperations (
    IN OUT PRX_CONTEXT RxContext,
    IN PFCB Fcb,
    IN OUT PLIST_ENTRY BlockingIoQ,
    IN BOOLEAN DropFcbLock
    );
#define RxSynchronizeBlockingOperationsAndDropFcbLock(RXCONTEXT,FCB,IOQUEUE) \
              __RxSynchronizeBlockingOperations(RXCONTEXT,FCB,IOQUEUE,TRUE)
#define RxSynchronizeBlockingOperations(RXCONTEXT,FCB,IOQUEUE) \
              __RxSynchronizeBlockingOperations(RXCONTEXT,FCB,IOQUEUE,FALSE)

VOID
NTAPI
RxResumeBlockedOperations_Serially (
    IN OUT PRX_CONTEXT RxContext,
    IN OUT PLIST_ENTRY BlockingIoQ
    );

VOID
RxResumeBlockedOperations_ALL (
    IN OUT PRX_CONTEXT RxContext
    );


VOID
RxCancelBlockingOperation (
    IN OUT PRX_CONTEXT RxContext,
    IN PIRP Irp
    );

VOID
RxRemoveOperationFromBlockingQueue (
    IN OUT PRX_CONTEXT RxContext
    );

#endif // _RX_CONTEXT_STRUCT_DEFINED_



#elif (NTDDI_VERSION >= NTDDI_WINXP)

/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    RxContx.h

Abstract:

    This module defines RxContext data structure. This structure is used to
    describe an Irp whil it is being processed and contains state information
    that allows global resources to be released as the irp is completed.

Author:
Notes:

    The RX_CONTEXT is a data structure to which additional information provided
    by the various mini redirectors need to be attached. This can be done in one
    of the following three ways

      1) Allow for context pointers to be defined as part of the RX_CONTEXT which
      the mini redirectors can use to squirrel away their information. This
      implies that every time an RX_CONTEXT is allocated/destroyed the mini
      redirector has to perform an associated allocation/destruction.

      Since RX_CONTEXT's are created/destroyed in great numbers, this is not an
      acceptable solution.

      2) The second approach consists of over allocating RX_CONTEXT's by a
      prespecified amount for each mini redirector which is then reserved for
      use by the mini redirector. Such an approach avoids the additional
      allocation/destruction but complicates the RX_CONTEXT management code in
      the wrapper.

      3) The third approach ( the one that is implemented ) consists of allocating
      a prespecfied area which is the same for all mini redirectors as part of
      each RX_CONTEXT. This is an unformatted area on top of which any desired
      structure can be imposed by the various mini redirectors. Such an approach
      overcomes the disadvantages associated with (1) and (2).

      All mini redirector writers must try and define the associated mini redirector
      contexts to fit into this area. Those mini redirectors who violate this
      rule will incur a significant performance penalty.

--*/

#ifndef _RX_CONTEXT_STRUCT_DEFINED_
#define _RX_CONTEXT_STRUCT_DEFINED_
#ifndef RDBSS_TRACKER
#error tracker must be defined right now
#endif

#define RX_TOPLEVELIRP_CONTEXT_SIGNATURE ('LTxR')
typedef struct _RX_TOPLEVELIRP_CONTEXT {
    union {
#ifndef __cplusplus
        LIST_ENTRY;
#endif // __cplusplus
        LIST_ENTRY ListEntry;
    };
    ULONG Signature;
    PRDBSS_DEVICE_OBJECT RxDeviceObject;
    PRX_CONTEXT RxContext;
    PIRP Irp;
    ULONG Flags;
    PVOID Previous;
    PETHREAD Thread;
} RX_TOPLEVELIRP_CONTEXT, *PRX_TOPLEVELIRP_CONTEXT;

BOOLEAN
RxTryToBecomeTheTopLevelIrp (
    IN OUT  PRX_TOPLEVELIRP_CONTEXT TopLevelContext,
    IN      PIRP Irp,
    IN      PRDBSS_DEVICE_OBJECT RxDeviceObject,
    IN      BOOLEAN ForceTopLevel
    );

VOID
__RxInitializeTopLevelIrpContext (
    IN OUT  PRX_TOPLEVELIRP_CONTEXT TopLevelContext,
    IN      PIRP Irp,
    IN      PRDBSS_DEVICE_OBJECT RxDeviceObject,
    IN      ULONG Flags
    );
#define RxInitializeTopLevelIrpContext(a,b,c) {__RxInitializeTopLevelIrpContext(a,b,c,0);}

PIRP
RxGetTopIrpIfRdbssIrp (
    void
    );

PRDBSS_DEVICE_OBJECT
RxGetTopDeviceObjectIfRdbssIrp (
    void
    );

VOID
RxUnwindTopLevelIrp (
    IN OUT  PRX_TOPLEVELIRP_CONTEXT TopLevelContext
    );

BOOLEAN
RxIsThisTheTopLevelIrp (
    IN      PIRP Irp
    );


#ifdef RDBSS_TRACKER
typedef struct _RX_FCBTRACKER_CALLINFO {
    ULONG AcquireRelease;
    USHORT SavedTrackerValue;
    USHORT LineNumber;
    PSZ   FileName;
    ULONG Flags;
} RX_FCBTRACKER_CALLINFO, *PRX_FCBTRACKER_CALLINFO;
#define RDBSS_TRACKER_HISTORY_SIZE 32
#endif

#define MRX_CONTEXT_FIELD_COUNT    4
#define MRX_CONTEXT_SIZE   (sizeof(PVOID) * MRX_CONTEXT_FIELD_COUNT)

// Define rxdriver dispatch routine type....almost all of the important routine
// will have this type.

typedef
NTSTATUS
(NTAPI *PRX_DISPATCH) ( RXCOMMON_SIGNATURE );

typedef struct _NT_CREATE_PARAMETERS {
    ACCESS_MASK                  DesiredAccess;
    LARGE_INTEGER                AllocationSize;
    ULONG                        FileAttributes;
    ULONG                        ShareAccess;
    ULONG                        Disposition;
    ULONG                        CreateOptions;
    PIO_SECURITY_CONTEXT         SecurityContext;
    SECURITY_IMPERSONATION_LEVEL ImpersonationLevel;
    PVOID                        DfsContext;
    PVOID                        DfsNameContext;
} NT_CREATE_PARAMETERS, *PNT_CREATE_PARAMETERS;

typedef struct _RX_CONTEXT {
    // the node type, size and reference count, aka standard header

    NODE_TYPE_CODE     NodeTypeCode;
    NODE_BYTE_SIZE     NodeByteSize;
    ULONG              ReferenceCount;

    // the list entry to wire the context to the list of active contexts

    LIST_ENTRY         ContextListEntry;

    // Major and minor function of the IRP associated with the context

    UCHAR              MajorFunction;
    UCHAR              MinorFunction;

    // this is similar to the same field in Irps; it
    // allows callback routines for async operations
    // to know whether to do asynchronous work or not

    BOOLEAN            PendingReturned;

    // indicates if the associated request is to be posted to a RDBSS worker thread.

    BOOLEAN            PostRequest;

    // Originating Device (required for workque algorithms)
    // not currently used but could be used for local minis

    PDEVICE_OBJECT     RealDevice;

    //  ptr to the originating Irp
    PIRP               CurrentIrp;

    // ptr to the IRP stack location
    PIO_STACK_LOCATION CurrentIrpSp;

    // ptr to the FCB and FOBX, derived from the context pointers in the
    // file object associated with the IRP

    PMRX_FCB           pFcb;
    PMRX_FOBX          pFobx;
    PMRX_SRV_OPEN      pRelevantSrvOpen;
    PNON_PAGED_FCB     NonPagedFcb;

    //  device object calldown (not irpsp.....)

    PRDBSS_DEVICE_OBJECT RxDeviceObject;

    // The original thread in which the request was initiated and the last
    // thread in which some processing associated with the context was done

    PETHREAD           OriginalThread;
    PETHREAD           LastExecutionThread;

    PVOID              LockManagerContext;

    // One word of the context is given to rdbss for dbg information

    PVOID              RdbssDbgExtension;

    RX_SCAVENGER_ENTRY ScavengerEntry;

    // global serial number for this operation

    ULONG              SerialNumber;

    // used by minirdrs to see if multiple calls are part
    // of the same larger operation and (therefore) more cacheable

    ULONG              FobxSerialNumber;

    ULONG              Flags;

    BOOLEAN            FcbResourceAcquired;
    BOOLEAN            FcbPagingIoResourceAcquired;
    UCHAR              MustSucceedDescriptorNumber;

    // mostly you want the individual components...sometimes it's nice as a pair
    // used to record the status when you can't just return it; e.g., when
    // RXSTATUS is not an appropriate return type or if the consumer of the
    // status didn't call directly (lowiocompletions). minirdrs will not need
    // to set the information directly

    union {
        struct {
            union {
                NTSTATUS StoredStatus;
                PVOID    StoredStatusAlignment;
            };
            ULONG_PTR    InformationToReturn;
        };
        IO_STATUS_BLOCK IoStatusBlock;
    };

    // the context fields provided for use by the mini redirectors
    // this is defined as a union to force longlong alignment

    union {
        ULONGLONG          ForceLonglongAligmentDummyField;
        PVOID              MRxContext[MRX_CONTEXT_FIELD_COUNT];
    };

    // The following field is included to fix the problem related to write only
    // opens. This introduces a new field for the mini redirector to squirrel
    // some state. This is redundant and should be removed after Windows 2000.
    // Having a unique field reduces the impact of the change that we are making
    // to the specific code path. It will be ideal to use one of the MRXContext
    // fields defined above

    PVOID WriteOnlyOpenRetryContext;

    // the cancellation routine to be invoked, set by the mini redirector

    PMRX_CALLDOWN      MRxCancelRoutine;

    // private dispatch, if any. used in fspdisp

    PRX_DISPATCH       ResumeRoutine;

    // for posting to worker threads
    // the minirdr can use this for posting within the minirdr
    // a potential problem can arise if the minirdr relies on this both
    // for queueing async stuff and for queueing cancel stuff

    // The OverflowListEntry is used for queueing items to the overflow queue.
    // This is seperate now to allow us to distinguish between an item in the overflow
    // queue and one in the active work queue (for cancellation logic)

    RX_WORK_QUEUE_ITEM WorkQueueItem;
    LIST_ENTRY OverflowListEntry;

    // this event is used for synchronous operations
    // that have to i/f with an underlying async service. it can be used
    // by the minirdr with the following provisions:
    //      1) on entering the minirdr through lowio, it is set to the
    //         nonsignaled state (but a wise user will reset it before using
    //         it....particularly if it's used multiple times.
    //      2) if you are returning STATUS_PENDING on a sync operation, you must
    //         return with it set to the nonsignaled state; that is, either
    //         you don't use it or you reset it in this case

    KEVENT             SyncEvent;

    //this is a list head of operations that are to be released on completion

    LIST_ENTRY         BlockedOperations;

    //this is the mutex that controls serialization of the blocked operations

    PFAST_MUTEX        BlockedOpsMutex;

    // these links are used to serialize pipe operations on a
    //per-file-object basis AND FOR LOTS OF OTHER STUFF

    LIST_ENTRY         RxContextSerializationQLinks;

    union {
        struct {
            union {
                FS_INFORMATION_CLASS FsInformationClass;
                FILE_INFORMATION_CLASS FileInformationClass;
            };
            PVOID   Buffer;
            union {
                LONG   Length;
                LONG   LengthRemaining;
            };
            BOOLEAN ReplaceIfExists;
            BOOLEAN AdvanceOnly;
        } Info;

        struct {
            UNICODE_STRING       SuppliedPathName;
            NET_ROOT_TYPE        NetRootType;
            PIO_SECURITY_CONTEXT pSecurityContext;
        } PrefixClaim;
    };

    // THIS UNION MUST BE LAST....AT SOME POINT, WE MAY START ALLOCATING
    // SMALLER PER OPERATION!

    union{
        struct {
            NT_CREATE_PARAMETERS NtCreateParameters; // a copy of the createparameters
            ULONG                ReturnedCreateInformation;
            PWCH                 CanonicalNameBuffer;  // if the canonical name is larger than available buffer
            PRX_PREFIX_ENTRY     NetNamePrefixEntry;   // the entry returned by the lookup....for dereferencing

            PMRX_SRV_CALL        pSrvCall;              // Server Call being used
            PMRX_NET_ROOT        pNetRoot;              // Net Root being used
            PMRX_V_NET_ROOT      pVNetRoot;             // Virtual Net Root
            //PMRX_SRV_OPEN        pSrvOpen;              // Server Open

            PVOID                EaBuffer;
            ULONG                EaLength;

            ULONG                SdLength;

            ULONG                PipeType;
            ULONG                PipeReadMode;
            ULONG                PipeCompletionMode;

            USHORT               Flags;
            NET_ROOT_TYPE        Type;                  // Type of Net Root(Pipe/File/Mailslot..)
            UCHAR                RdrFlags;              // Flags for use by the RDR while processing the request.

            BOOLEAN              FcbAcquired;
            BOOLEAN              TryForScavengingOnSharingViolation;
            BOOLEAN              ScavengingAlreadyTried;

            BOOLEAN              ThisIsATreeConnectOpen;
            BOOLEAN              TreeConnectOpenDeferred;
            UNICODE_STRING       TransportName;
            UNICODE_STRING       UserName;
            UNICODE_STRING       Password;
            UNICODE_STRING       UserDomainName;
        } Create;
        struct {
            ULONG   FileIndex;
            BOOLEAN RestartScan;
            BOOLEAN ReturnSingleEntry;
            BOOLEAN IndexSpecified;
            BOOLEAN InitialQuery;
        } QueryDirectory;
        struct {
            PMRX_V_NET_ROOT pVNetRoot;
        } NotifyChangeDirectory;
        struct {
            PUCHAR  UserEaList;
            ULONG   UserEaListLength;
            ULONG   UserEaIndex;
            BOOLEAN RestartScan;
            BOOLEAN ReturnSingleEntry;
            BOOLEAN IndexSpecified;
        } QueryEa;
        struct {
            SECURITY_INFORMATION SecurityInformation;
            ULONG Length;
        } QuerySecurity;
        struct {
            SECURITY_INFORMATION SecurityInformation;
            PSECURITY_DESCRIPTOR SecurityDescriptor;
        } SetSecurity;
        struct {
            ULONG   Length;
            PSID    StartSid;
            PFILE_GET_QUOTA_INFORMATION SidList;
            ULONG   SidListLength;
            BOOLEAN RestartScan;
            BOOLEAN ReturnSingleEntry;
            BOOLEAN IndexSpecified;
        } QueryQuota;
        struct {
            ULONG   Length;

        } SetQuota;
        struct {
            PV_NET_ROOT VNetRoot;
            PSRV_CALL   SrvCall;
            PNET_ROOT   NetRoot;
        } DosVolumeFunction;
        struct {
            ULONG         FlagsForLowIo;
            LOWIO_CONTEXT LowIoContext;        // the LOWIO parameters
        }; //no name here....
        LUID          FsdUid;
    } ;
//CODE.IMPROVEMENT remove this to wrapperdbgprivates
    PWCH                 AlsoCanonicalNameBuffer;  // if the canonical name is larger than available buffer
    PUNICODE_STRING      LoudCompletionString;
#ifdef RDBSS_TRACKER
    LONG               AcquireReleaseFcbTrackerX;
    ULONG              TrackerHistoryPointer;
#endif
#ifdef RDBSS_TRACKER
    RX_FCBTRACKER_CALLINFO TrackerHistory[RDBSS_TRACKER_HISTORY_SIZE];
#endif

    ULONG   dwShadowCritOwner;

} RX_CONTEXT;

#define RX_DEFINE_RXC_FLAG(a,c) RX_DEFINE_FLAG(RX_CONTEXT_FLAG_##a,c,0xffffffff)

typedef enum {
    RX_DEFINE_RXC_FLAG(FROM_POOL, 0)
    RX_DEFINE_RXC_FLAG(WAIT, 1)
    RX_DEFINE_RXC_FLAG(WRITE_THROUGH, 2)
    RX_DEFINE_RXC_FLAG(FLOPPY, 3)
    RX_DEFINE_RXC_FLAG(RECURSIVE_CALL, 4)
    RX_DEFINE_RXC_FLAG(THIS_DEVICE_TOP_LEVEL, 5)
    RX_DEFINE_RXC_FLAG(DEFERRED_WRITE, 6)
    RX_DEFINE_RXC_FLAG(VERIFY_READ, 7)
    RX_DEFINE_RXC_FLAG(STACK_IO_CONTEZT, 8)
    RX_DEFINE_RXC_FLAG(IN_FSP, 9)
    RX_DEFINE_RXC_FLAG(CREATE_MAILSLOT, 10)
    RX_DEFINE_RXC_FLAG(MAILSLOT_REPARSE, 11)
    RX_DEFINE_RXC_FLAG(ASYNC_OPERATION, 12)
    RX_DEFINE_RXC_FLAG(NO_COMPLETE_FROM_FSP, 13)
    RX_DEFINE_RXC_FLAG(POST_ON_STABLE_CONDITION, 14)
    RX_DEFINE_RXC_FLAG(FSP_DELAYED_OVERFLOW_QUEUE, 15)
    RX_DEFINE_RXC_FLAG(FSP_CRITICAL_OVERFLOW_QUEUE, 16)
    RX_DEFINE_RXC_FLAG(MINIRDR_INVOKED, 17)
    RX_DEFINE_RXC_FLAG(WAITING_FOR_RESOURCE, 18)
    RX_DEFINE_RXC_FLAG(CANCELLED, 19)
    RX_DEFINE_RXC_FLAG(SYNC_EVENT_WAITERS, 20)
    RX_DEFINE_RXC_FLAG(NO_PREPOSTING_NEEDED, 21)
    RX_DEFINE_RXC_FLAG(BYPASS_VALIDOP_CHECK, 22)
    RX_DEFINE_RXC_FLAG(BLOCKED_PIPE_RESUME, 23)
    RX_DEFINE_RXC_FLAG(IN_SERIALIZATION_QUEUE, 24)
    RX_DEFINE_RXC_FLAG(NO_EXCEPTION_BREAKPOINT, 25)
    RX_DEFINE_RXC_FLAG(NEEDRECONNECT, 26)
    RX_DEFINE_RXC_FLAG(MUST_SUCCEED, 27)
    RX_DEFINE_RXC_FLAG(MUST_SUCCEED_NONBLOCKING, 28)
    RX_DEFINE_RXC_FLAG(MUST_SUCCEED_ALLOCATED, 29)
    RX_DEFINE_RXC_FLAG(MINIRDR_INITIATED, 31)
} RX_CONTEXT_FLAGS;

#define RX_CONTEXT_PRESERVED_FLAGS (RX_CONTEXT_FLAG_FROM_POOL | \
                                    RX_CONTEXT_FLAG_MUST_SUCCEED_ALLOCATED | \
                                    RX_CONTEXT_FLAG_IN_FSP)

#define RX_CONTEXT_INITIALIZATION_FLAGS (RX_CONTEXT_FLAG_WAIT | \
                                         RX_CONTEXT_FLAG_MUST_SUCCEED | \
                                         RX_CONTEXT_FLAG_MUST_SUCCEED_NONBLOCKING)

#define RX_DEFINE_RXC_CREATE_FLAG(a,c) RX_DEFINE_FLAG(RX_CONTEXT_CREATE_FLAG_##a,c,0xffff)

typedef enum {
    RX_DEFINE_RXC_CREATE_FLAG(UNC_NAME, 0)
    RX_DEFINE_RXC_CREATE_FLAG(STRIPPED_TRAILING_BACKSLASH, 1)
    RX_DEFINE_RXC_CREATE_FLAG(ADDEDBACKSLASH, 2)
    RX_DEFINE_RXC_CREATE_FLAG(REPARSE,3)
    RX_DEFINE_RXC_CREATE_FLAG(SPECIAL_PATH, 4)
} RX_CONTEXT_CREATE_FLAGS;

#define RX_DEFINE_RXC_LOWIO_FLAG(a,c) RX_DEFINE_FLAG(RXCONTEXT_FLAG4LOWIO_##a,c,0xffffffff)

typedef enum {
    RX_DEFINE_RXC_LOWIO_FLAG(PIPE_OPERATION, 0)
    RX_DEFINE_RXC_LOWIO_FLAG(PIPE_SYNC_OPERATION, 1)
    RX_DEFINE_RXC_LOWIO_FLAG(READAHEAD, 2)
    RX_DEFINE_RXC_LOWIO_FLAG(THIS_READ_ENLARGED, 3)
    RX_DEFINE_RXC_LOWIO_FLAG(THIS_IO_BUFFERED, 4)
    RX_DEFINE_RXC_LOWIO_FLAG(LOCK_FCB_RESOURCE_HELD, 5)
    RX_DEFINE_RXC_LOWIO_FLAG(LOCK_WAS_QUEUED_IN_LOCKMANAGER, 6)
    RX_DEFINE_RXC_LOWIO_FLAG(LOCK_BUFFERED_ON_ENTRY, 7)
#ifdef __cplusplus
} RX_CONTEXT_LOWIO_FLAGS;
#else // !__cplusplus
} RX_CONTEXT_CREATE_FLAGS;
#endif // __cplusplus

// Macros used to control whether the wrapper breakpoints on an exception
#if DBG
#define RxSaveAndSetExceptionNoBreakpointFlag(RXCONTEXT,_yyy){ \
    _yyy = RxContext->Flags & RX_CONTEXT_FLAG_NO_EXCEPTION_BREAKPOINT;   \
    RxContext->Flags |= RX_CONTEXT_FLAG_NO_EXCEPTION_BREAKPOINT;        \
}
#define RxRestoreExceptionNoBreakpointFlag(RXCONTEXT,_yyy){ \
    RxContext->Flags &= ~RX_CONTEXT_FLAG_NO_EXCEPTION_BREAKPOINT;        \
    RxContext->Flags |= _yyy;                              \
}
#else
#define RxSaveAndSetExceptionNoBreakpointFlag(_xxx,_yyy)
#define RxRestoreExceptionNoBreakpointFlag(_xxx,_yyy)
#endif

// a macro used to ensure that a context hasn't been freed during a wait
#if DBG
VOID
__RxItsTheSameContext(
    PRX_CONTEXT RxContext,
    ULONG CapturedRxContextSerialNumber,
    ULONG Line,
    PSZ File
    );
#define RxItsTheSameContext() {__RxItsTheSameContext(RxContext,CapturedRxContextSerialNumber,__LINE__,__FILE__);}
#else
#define RxItsTheSameContext() {NOTHING;}
#endif

extern NPAGED_LOOKASIDE_LIST RxContextLookasideList;

// Macros used in the RDBSS to wrap mini rdr calldowns

#define MINIRDR_CALL_THROUGH(STATUS,DISPATCH,FUNC,ARGLIST)                 \
   {                                                                       \
    ASSERT(DISPATCH);                                                      \
    ASSERT( NodeType(DISPATCH) == RDBSS_NTC_MINIRDR_DISPATCH );            \
    if (DISPATCH->FUNC == NULL) {                                          \
        STATUS = STATUS_NOT_IMPLEMENTED;                                   \
    } else {                                                               \
        RxDbgTrace(0, Dbg, ("MiniRdr Calldown - %s\n",#FUNC));             \
        STATUS = DISPATCH->FUNC ARGLIST;                                   \
    }                                                                      \
   }

#define MINIRDR_CALL(STATUS,CONTEXT,DISPATCH,FUNC,ARGLIST)                 \
   {                                                                       \
    ASSERT(DISPATCH);                                                      \
    ASSERT( NodeType(DISPATCH) == RDBSS_NTC_MINIRDR_DISPATCH );            \
    if ( DISPATCH->FUNC == NULL) {                                         \
       STATUS = STATUS_NOT_IMPLEMENTED;                                    \
    } else {                                                               \
       if (!BooleanFlagOn((CONTEXT)->Flags,RX_CONTEXT_FLAG_CANCELLED)) {   \
          RxDbgTrace(0, Dbg, ("MiniRdr Calldown - %s\n",#FUNC));           \
          RtlZeroMemory(&((CONTEXT)->MRxContext[0]),                       \
                        sizeof((CONTEXT)->MRxContext));                    \
          STATUS = DISPATCH->FUNC ARGLIST;                                 \
       } else {                                                            \
          STATUS = STATUS_CANCELLED;                                       \
       }                                                                   \
    }                                                                      \
   }


//VOID
//RxWaitSync (
//    IN PRX_CONTEXT RxContext
//    )

#define  RxWaitSync(RxContext)                                                   \
         RxDbgTrace(+1, Dbg, ("RxWaitSync, RxContext = %08lx\n", (RxContext)));  \
         (RxContext)->Flags |= RX_CONTEXT_FLAG_SYNC_EVENT_WAITERS;               \
         KeWaitForSingleObject( &(RxContext)->SyncEvent,                         \
                               Executive, KernelMode, FALSE, NULL );             \
         RxDbgTrace(-1, Dbg, ("RxWaitSync -> VOID\n", 0 ))

//VOID
//RxSignalSynchronousWaiter (
//    IN PRX_CONTEXT RxContext
//    )

#define RxSignalSynchronousWaiter(RxContext)                       \
        (RxContext)->Flags &= ~RX_CONTEXT_FLAG_SYNC_EVENT_WAITERS; \
        KeSetEvent( &(RxContext)->SyncEvent, 0, FALSE )


#define RxInsertContextInSerializationQueue(pSerializationQueue,RxContext) \
        (RxContext)->Flags |= RX_CONTEXT_FLAG_IN_SERIALIZATION_QUEUE;      \
        InsertTailList(pSerializationQueue,&((RxContext)->RxContextSerializationQLinks))

INLINE PRX_CONTEXT
RxRemoveFirstContextFromSerializationQueue(PLIST_ENTRY pSerializationQueue)
{
   if (IsListEmpty(pSerializationQueue)) {
      return NULL;
   } else {
      PRX_CONTEXT pContext = (PRX_CONTEXT)(CONTAINING_RECORD(pSerializationQueue->Flink,
                                             RX_CONTEXT,
                                             RxContextSerializationQLinks));

      RemoveEntryList(pSerializationQueue->Flink);

      pContext->RxContextSerializationQLinks.Flink = NULL;
      pContext->RxContextSerializationQLinks.Blink = NULL;
      return pContext;
   }
}

// The following macros provide a mechanism for doing an en masse transfer
// from one list onto another. This provides a powerful paradigm for dealing
// with DPC level processing of lists.

#define RxTransferList(pDestination,pSource)                   \
         if (IsListEmpty((pSource))) {                         \
            InitializeListHead((pDestination));              \
         } else {                                              \
            *(pDestination) = *(pSource);                      \
            (pDestination)->Flink->Blink = (pDestination);     \
            (pDestination)->Blink->Flink = (pDestination);     \
            InitializeListHead((pSource));                   \
         }

#define RxTransferListWithMutex(pDestination,pSource,pMutex) \
    {                                                   \
        ExAcquireFastMutex(pMutex);                     \
        RxTransferList(pDestination,pSource);           \
        ExReleaseFastMutex(pMutex);                     \
    }


VOID RxInitializeRxContexter(void);
VOID RxUninitializeRxContexter(void);

NTSTATUS
RxCancelNotifyChangeDirectoryRequestsForVNetRoot(
   PV_NET_ROOT pVNetRoot,
   BOOLEAN  ForceFilesClosed
   );

VOID
RxCancelNotifyChangeDirectoryRequestsForFobx(
   PFOBX pFobx);

NTSTATUS
NTAPI
RxSetMinirdrCancelRoutine(
    IN OUT PRX_CONTEXT   RxContext,
    IN     PMRX_CALLDOWN MRxCancelRoutine);

VOID
NTAPI
RxInitializeContext(
    IN PIRP            Irp,
    IN PRDBSS_DEVICE_OBJECT RxDeviceObject,
    IN ULONG           InitialContextFlags,
    IN OUT PRX_CONTEXT RxContext);

PRX_CONTEXT
NTAPI
RxCreateRxContext (
    IN PIRP Irp,
    IN PRDBSS_DEVICE_OBJECT RxDeviceObject,
    IN ULONG InitialContextFlags
    );

VOID
NTAPI
RxPrepareContextForReuse(
   IN OUT PRX_CONTEXT RxContext);

VOID
NTAPI
RxDereferenceAndDeleteRxContext_Real (
    IN PRX_CONTEXT RxContext
    );

VOID
NTAPI
RxReinitializeContext(
   IN OUT PRX_CONTEXT RxContext);

#if DBG
#define RxDereferenceAndDeleteRxContext(RXCONTEXT) {   \
    RxDereferenceAndDeleteRxContext_Real((RXCONTEXT)); \
    (RXCONTEXT) = NULL;                    \
}
#else
#define RxDereferenceAndDeleteRxContext(RXCONTEXT) {   \
    RxDereferenceAndDeleteRxContext_Real((RXCONTEXT)); \
}
#endif //

extern FAST_MUTEX RxContextPerFileSerializationMutex;

NTSTATUS
NTAPI
__RxSynchronizeBlockingOperationsMaybeDroppingFcbLock(
    IN OUT PRX_CONTEXT RxContext,
    IN OUT PLIST_ENTRY BlockingIoQ,
    IN     BOOLEAN     DropFcbLock
    );
#define RxSynchronizeBlockingOperationsAndDropFcbLock(__x,__y) \
              __RxSynchronizeBlockingOperationsMaybeDroppingFcbLock(__x,__y,TRUE)
#define RxSynchronizeBlockingOperations(__x,__y) \
              __RxSynchronizeBlockingOperationsMaybeDroppingFcbLock(__x,__y,FALSE)

VOID
NTAPI
RxResumeBlockedOperations_Serially(
    IN OUT PRX_CONTEXT RxContext,
    IN OUT PLIST_ENTRY BlockingIoQ
    );

VOID
RxResumeBlockedOperations_ALL(
    IN OUT PRX_CONTEXT RxContext
    );


VOID
RxCancelBlockingOperation(
    IN OUT PRX_CONTEXT RxContext);

VOID
RxRemoveOperationFromBlockingQueue(
    IN OUT PRX_CONTEXT RxContext);


#endif // _RX_CONTEXT_STRUCT_DEFINED_



#elif (NTDDI_VERSION >= NTDDI_WIN2K)

/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    RxContx.h

Abstract:

    This module defines RxContext data structure. This structure is used to
    describe an Irp whil it is being processed and contains state information
    that allows global resources to be released as the irp is completed.

Author:
Notes:

    The RX_CONTEXT is a data structure to which additional information provided
    by the various mini redirectors need to be attached. This can be done in one
    of the following three ways

      1) Allow for context pointers to be defined as part of the RX_CONTEXT which
      the mini redirectors can use to squirrel away their information. This
      implies that every time an RX_CONTEXT is allocated/destroyed the mini
      redirector has to perform an associated allocation/destruction.

      Since RX_CONTEXT's are created/destroyed in great numbers, this is not an
      acceptable solution.

      2) The second approach consists of over allocating RX_CONTEXT's by a
      prespecified amount for each mini redirector which is then reserved for
      use by the mini redirector. Such an approach avoids the additional
      allocation/destruction but complicates the RX_CONTEXT management code in
      the wrapper.

      3) The third approach ( the one that is implemented ) consists of allocating
      a prespecfied area which is the same for all mini redirectors as part of
      each RX_CONTEXT. This is an unformatted area on top of which any desired
      structure can be imposed by the various mini redirectors. Such an approach
      overcomes the disadvantages associated with (1) and (2).

      All mini redirector writers must try and define the associated mini redirector
      contexts to fit into this area. Those mini redirectors who violate this
      rule will incur a significant performance penalty.

--*/

#ifndef _RX_CONTEXT_STRUCT_DEFINED_
#define _RX_CONTEXT_STRUCT_DEFINED_
#ifndef RDBSS_TRACKER
#error tracker must be defined right now
#endif

#define RX_TOPLEVELIRP_CONTEXT_SIGNATURE ('LTxR')
typedef struct _RX_TOPLEVELIRP_CONTEXT {
    union {
        LIST_ENTRY;
        LIST_ENTRY ListEntry;
    };
    ULONG Signature;
    PRDBSS_DEVICE_OBJECT RxDeviceObject;
    PRX_CONTEXT RxContext;
    PIRP Irp;
    ULONG Flags;
    PVOID Previous;
    PETHREAD Thread;
} RX_TOPLEVELIRP_CONTEXT, *PRX_TOPLEVELIRP_CONTEXT;

BOOLEAN
RxTryToBecomeTheTopLevelIrp (
    IN OUT  PRX_TOPLEVELIRP_CONTEXT TopLevelContext,
    IN      PIRP Irp,
    IN      PRDBSS_DEVICE_OBJECT RxDeviceObject,
    IN      BOOLEAN ForceTopLevel
    );

VOID
__RxInitializeTopLevelIrpContext (
    IN OUT  PRX_TOPLEVELIRP_CONTEXT TopLevelContext,
    IN      PIRP Irp,
    IN      PRDBSS_DEVICE_OBJECT RxDeviceObject,
    IN      ULONG Flags
    );
#define RxInitializeTopLevelIrpContext(a,b,c) {__RxInitializeTopLevelIrpContext(a,b,c,0);}

PIRP
RxGetTopIrpIfRdbssIrp (
    void
    );

PRDBSS_DEVICE_OBJECT
RxGetTopDeviceObjectIfRdbssIrp (
    void
    );

VOID
RxUnwindTopLevelIrp (
    IN OUT  PRX_TOPLEVELIRP_CONTEXT TopLevelContext
    );

BOOLEAN
RxIsThisTheTopLevelIrp (
    IN      PIRP Irp
    );


#ifdef RDBSS_TRACKER
typedef struct _RX_FCBTRACKER_CALLINFO {
    ULONG AcquireRelease;
    USHORT SavedTrackerValue;
    USHORT LineNumber;
    PSZ   FileName;
    ULONG Flags;
} RX_FCBTRACKER_CALLINFO, *PRX_FCBTRACKER_CALLINFO;
#define RDBSS_TRACKER_HISTORY_SIZE 32
#endif

#define MRX_CONTEXT_FIELD_COUNT    4
#define MRX_CONTEXT_SIZE   (sizeof(PVOID) * MRX_CONTEXT_FIELD_COUNT)

// Define rxdriver dispatch routine type....almost all of the important routine
// will have this type.

typedef
NTSTATUS
(NTAPI *PRX_DISPATCH) ( RXCOMMON_SIGNATURE );

typedef struct _NT_CREATE_PARAMETERS {
    ACCESS_MASK                  DesiredAccess;
    LARGE_INTEGER                AllocationSize;
    ULONG                        FileAttributes;
    ULONG                        ShareAccess;
    ULONG                        Disposition;
    ULONG                        CreateOptions;
    PIO_SECURITY_CONTEXT         SecurityContext;
    SECURITY_IMPERSONATION_LEVEL ImpersonationLevel;
    PVOID                        DfsContext;
    PVOID                        DfsNameContext;
} NT_CREATE_PARAMETERS, *PNT_CREATE_PARAMETERS;

typedef struct _RX_CONTEXT {
    // the node type, size and reference count, aka standard header

    NODE_TYPE_CODE     NodeTypeCode;
    NODE_BYTE_SIZE     NodeByteSize;
    ULONG              ReferenceCount;

    // the list entry to wire the context to the list of active contexts

    LIST_ENTRY         ContextListEntry;

    // Major and minor function of the IRP associated with the context

    UCHAR              MajorFunction;
    UCHAR              MinorFunction;

    // this is similar to the same field in Irps; it
    // allows callback routines for async operations
    // to know whether to do asynchronous work or not

    BOOLEAN            PendingReturned;

    // indicates if the associated request is to be posted to a RDBSS worker thread.

    BOOLEAN            PostRequest;

    // Originating Device (required for workque algorithms)
    // not currently used but could be used for local minis

    PDEVICE_OBJECT     RealDevice;

    //  ptr to the originating Irp
    PIRP               CurrentIrp;

    // ptr to the IRP stack location
    PIO_STACK_LOCATION CurrentIrpSp;

    // ptr to the FCB and FOBX, derived from the context pointers in the
    // file object associated with the IRP

    PMRX_FCB           pFcb;
    PMRX_FOBX          pFobx;
    PMRX_SRV_OPEN      pRelevantSrvOpen;
    PNON_PAGED_FCB     NonPagedFcb;

    //  device object calldown (not irpsp.....)

    PRDBSS_DEVICE_OBJECT RxDeviceObject;

    // The original thread in which the request was initiated and the last
    // thread in which some processing associated with the context was done

    PETHREAD           OriginalThread;
    PETHREAD           LastExecutionThread;

    PVOID              LockManagerContext;

    // One word of the context is given to rdbss for dbg information

    PVOID              RdbssDbgExtension;

    RX_SCAVENGER_ENTRY ScavengerEntry;

    // global serial number for this operation

    ULONG              SerialNumber;

    // used by minirdrs to see if multiple calls are part
    // of the same larger operation and (therefore) more cacheable

    ULONG              FobxSerialNumber;

    ULONG              Flags;

    BOOLEAN            FcbResourceAcquired;
    BOOLEAN            FcbPagingIoResourceAcquired;
    UCHAR              MustSucceedDescriptorNumber;

    // mostly you want the individual components...sometimes it's nice as a pair
    // used to record the status when you can't just return it; e.g., when
    // RXSTATUS is not an appropriate return type or if the consumer of the
    // status didn't call directly (lowiocompletions). minirdrs will not need
    // to set the information directly

    union {
        struct {
            union {
                NTSTATUS StoredStatus;
                PVOID    StoredStatusAlignment;
            };
            ULONG_PTR    InformationToReturn;
        };
        IO_STATUS_BLOCK IoStatusBlock;
    };

    // the context fields provided for use by the mini redirectors
    // this is defined as a union to force longlong alignment

    union {
        ULONGLONG          ForceLonglongAligmentDummyField;
        PVOID              MRxContext[MRX_CONTEXT_FIELD_COUNT];
    };

    // The following field is included to fix the problem related to write only
    // opens. This introduces a new field for the mini redirector to squirrel
    // some state. This is redundant and should be removed after Windows 2000.
    // Having a unique field reduces the impact of the change that we are making
    // to the specific code path. It will be ideal to use one of the MRXContext
    // fields defined above

    PVOID WriteOnlyOpenRetryContext;

    // the cancellation routine to be invoked, set by the mini redirector

    PMRX_CALLDOWN      MRxCancelRoutine;

    // private dispatch, if any. used in fspdisp

    PRX_DISPATCH       ResumeRoutine;

    // for posting to worker threads
    // the minirdr can use this for posting within the minirdr
    // a potential problem can arise if the minirdr relies on this both
    // for queueing async stuff and for queueing cancel stuff

    RX_WORK_QUEUE_ITEM WorkQueueItem;

    // this event is used for synchronous operations
    // that have to i/f with an underlying async service. it can be used
    // by the minirdr with the following provisions:
    //      1) on entering the minirdr through lowio, it is set to the
    //         nonsignaled state (but a wise user will reset it before using
    //         it....particularly if it's used multiple times.
    //      2) if you are returning STATUS_PENDING on a sync operation, you must
    //         return with it set to the nonsignaled state; that is, either
    //         you don't use it or you reset it in this case

    KEVENT             SyncEvent;

    //this is a list head of operations that are to be released on completion

    LIST_ENTRY         BlockedOperations;

    //this is the mutex that controls serialization of the blocked operations

    PFAST_MUTEX        BlockedOpsMutex;

    // these links are used to serialize pipe operations on a
    //per-file-object basis AND FOR LOTS OF OTHER STUFF

    LIST_ENTRY         RxContextSerializationQLinks;

    union {
        struct {
            union {
                FS_INFORMATION_CLASS FsInformationClass;
                FILE_INFORMATION_CLASS FileInformationClass;
            };
            PVOID   Buffer;
            union {
                LONG   Length;
                LONG   LengthRemaining;
            };
            BOOLEAN ReplaceIfExists;
            BOOLEAN AdvanceOnly;
        } Info;

        struct {
            UNICODE_STRING       SuppliedPathName;
            NET_ROOT_TYPE        NetRootType;
            PIO_SECURITY_CONTEXT pSecurityContext;
        } PrefixClaim;
    };

    // THIS UNION MUST BE LAST....AT SOME POINT, WE MAY START ALLOCATING
    // SMALLER PER OPERATION!

    union{
        struct {
            NT_CREATE_PARAMETERS NtCreateParameters; // a copy of the createparameters
            ULONG                ReturnedCreateInformation;
            PWCH                 CanonicalNameBuffer;  // if the canonical name is larger than available buffer
            PRX_PREFIX_ENTRY     NetNamePrefixEntry;   // the entry returned by the lookup....for dereferencing

            PMRX_SRV_CALL        pSrvCall;              // Server Call being used
            PMRX_NET_ROOT        pNetRoot;              // Net Root being used
            PMRX_V_NET_ROOT      pVNetRoot;             // Virtual Net Root
            //PMRX_SRV_OPEN        pSrvOpen;              // Server Open

            PVOID                EaBuffer;
            ULONG                EaLength;

            ULONG                SdLength;

            ULONG                PipeType;
            ULONG                PipeReadMode;
            ULONG                PipeCompletionMode;

            USHORT               Flags;
            NET_ROOT_TYPE        Type;                 // Type of Net Root(Pipe/File/Mailslot..)

            BOOLEAN              FcbAcquired;
            BOOLEAN              TryForScavengingOnSharingViolation;
            BOOLEAN              ScavengingAlreadyTried;

            BOOLEAN              ThisIsATreeConnectOpen;
            BOOLEAN              TreeConnectOpenDeferred;
            UNICODE_STRING       TransportName;
            UNICODE_STRING       UserName;
            UNICODE_STRING       Password;
            UNICODE_STRING       UserDomainName;
        } Create;
        struct {
            ULONG   FileIndex;
            BOOLEAN RestartScan;
            BOOLEAN ReturnSingleEntry;
            BOOLEAN IndexSpecified;
            BOOLEAN InitialQuery;
        } QueryDirectory;
        struct {
            PMRX_V_NET_ROOT pVNetRoot;
        } NotifyChangeDirectory;
        struct {
            PUCHAR  UserEaList;
            ULONG   UserEaListLength;
            ULONG   UserEaIndex;
            BOOLEAN RestartScan;
            BOOLEAN ReturnSingleEntry;
            BOOLEAN IndexSpecified;
        } QueryEa;
        struct {
            SECURITY_INFORMATION SecurityInformation;
            ULONG Length;
        } QuerySecurity;
        struct {
            SECURITY_INFORMATION SecurityInformation;
            PSECURITY_DESCRIPTOR SecurityDescriptor;
        } SetSecurity;
        struct {
            ULONG   Length;
            PSID    StartSid;
            PFILE_GET_QUOTA_INFORMATION SidList;
            ULONG   SidListLength;
            BOOLEAN RestartScan;
            BOOLEAN ReturnSingleEntry;
            BOOLEAN IndexSpecified;
        } QueryQuota;
        struct {
            ULONG   Length;

        } SetQuota;
        struct {
            PV_NET_ROOT VNetRoot;
            PSRV_CALL   SrvCall;
            PNET_ROOT   NetRoot;
        } DosVolumeFunction;
        struct {
            ULONG         FlagsForLowIo;
            LOWIO_CONTEXT LowIoContext;        // the LOWIO parameters
        }; //no name here....
        LUID          FsdUid;
    } ;
//CODE.IMPROVEMENT remove this to wrapperdbgprivates
    PWCH                 AlsoCanonicalNameBuffer;  // if the canonical name is larger than available buffer
    PUNICODE_STRING      LoudCompletionString;
#ifdef RDBSS_TRACKER
    LONG               AcquireReleaseFcbTrackerX;
    ULONG              TrackerHistoryPointer;
#endif
#ifdef RDBSS_TRACKER
    RX_FCBTRACKER_CALLINFO TrackerHistory[RDBSS_TRACKER_HISTORY_SIZE];
#endif

    ULONG   dwShadowCritOwner;

} RX_CONTEXT;

#define RX_DEFINE_RXC_FLAG(a,c) RX_DEFINE_FLAG(RX_CONTEXT_FLAG_##a,c,0xffffffff)

typedef enum {
    RX_DEFINE_RXC_FLAG(FROM_POOL, 0)
    RX_DEFINE_RXC_FLAG(WAIT, 1)
    RX_DEFINE_RXC_FLAG(WRITE_THROUGH, 2)
    RX_DEFINE_RXC_FLAG(FLOPPY, 3)
    RX_DEFINE_RXC_FLAG(RECURSIVE_CALL, 4)
    RX_DEFINE_RXC_FLAG(THIS_DEVICE_TOP_LEVEL, 5)
    RX_DEFINE_RXC_FLAG(DEFERRED_WRITE, 6)
    RX_DEFINE_RXC_FLAG(VERIFY_READ, 7)
    RX_DEFINE_RXC_FLAG(STACK_IO_CONTEZT, 8)
    RX_DEFINE_RXC_FLAG(IN_FSP, 9)
    RX_DEFINE_RXC_FLAG(CREATE_MAILSLOT, 10)
    RX_DEFINE_RXC_FLAG(MAILSLOT_REPARSE, 11)
    RX_DEFINE_RXC_FLAG(ASYNC_OPERATION, 12)
    RX_DEFINE_RXC_FLAG(NO_COMPLETE_FROM_FSP, 13)
    RX_DEFINE_RXC_FLAG(POST_ON_STABLE_CONDITION, 14)
    RX_DEFINE_RXC_FLAG(FSP_DELAYED_OVERFLOW_QUEUE, 15)
    RX_DEFINE_RXC_FLAG(FSP_CRITICAL_OVERFLOW_QUEUE, 16)
    RX_DEFINE_RXC_FLAG(MINIRDR_INVOKED, 17)
    RX_DEFINE_RXC_FLAG(WAITING_FOR_RESOURCE, 18)
    RX_DEFINE_RXC_FLAG(CANCELLED, 19)
    RX_DEFINE_RXC_FLAG(SYNC_EVENT_WAITERS, 20)
    RX_DEFINE_RXC_FLAG(NO_PREPOSTING_NEEDED, 21)
    RX_DEFINE_RXC_FLAG(BYPASS_VALIDOP_CHECK, 22)
    RX_DEFINE_RXC_FLAG(BLOCKED_PIPE_RESUME, 23)
    RX_DEFINE_RXC_FLAG(IN_SERIALIZATION_QUEUE, 24)
    RX_DEFINE_RXC_FLAG(NO_EXCEPTION_BREAKPOINT, 25)
    RX_DEFINE_RXC_FLAG(NEEDRECONNECT, 26)
    RX_DEFINE_RXC_FLAG(MUST_SUCCEED, 27)
    RX_DEFINE_RXC_FLAG(MUST_SUCCEED_NONBLOCKING, 28)
    RX_DEFINE_RXC_FLAG(MUST_SUCCEED_ALLOCATED, 29)
    RX_DEFINE_RXC_FLAG(MINIRDR_INITIATED, 31)
} RX_CONTEXT_FLAGS;

#define RX_CONTEXT_PRESERVED_FLAGS (RX_CONTEXT_FLAG_FROM_POOL | \
                                    RX_CONTEXT_FLAG_MUST_SUCCEED_ALLOCATED | \
                                    RX_CONTEXT_FLAG_IN_FSP)

#define RX_CONTEXT_INITIALIZATION_FLAGS (RX_CONTEXT_FLAG_WAIT | \
                                         RX_CONTEXT_FLAG_MUST_SUCCEED | \
                                         RX_CONTEXT_FLAG_MUST_SUCCEED_NONBLOCKING)

#define RX_DEFINE_RXC_CREATE_FLAG(a,c) RX_DEFINE_FLAG(RX_CONTEXT_CREATE_FLAG_##a,c,0xffff)

typedef enum {
    RX_DEFINE_RXC_CREATE_FLAG(UNC_NAME, 0)
    RX_DEFINE_RXC_CREATE_FLAG(STRIPPED_TRAILING_BACKSLASH, 1)
    RX_DEFINE_RXC_CREATE_FLAG(ADDEDBACKSLASH, 2)
    RX_DEFINE_RXC_CREATE_FLAG(REPARSE,3)
} RX_CONTEXT_CREATE_FLAGS;

#define RX_DEFINE_RXC_LOWIO_FLAG(a,c) RX_DEFINE_FLAG(RXCONTEXT_FLAG4LOWIO_##a,c,0xffffffff)

typedef enum {
    RX_DEFINE_RXC_LOWIO_FLAG(PIPE_OPERATION, 0)
    RX_DEFINE_RXC_LOWIO_FLAG(PIPE_SYNC_OPERATION, 1)
    RX_DEFINE_RXC_LOWIO_FLAG(READAHEAD, 2)
    RX_DEFINE_RXC_LOWIO_FLAG(THIS_READ_ENLARGED, 3)
    RX_DEFINE_RXC_LOWIO_FLAG(THIS_IO_BUFFERED, 4)
    RX_DEFINE_RXC_LOWIO_FLAG(LOCK_FCB_RESOURCE_HELD, 5)
    RX_DEFINE_RXC_LOWIO_FLAG(LOCK_WAS_QUEUED_IN_LOCKMANAGER, 6)
} RX_CONTEXT_CREATE_FLAGS;

// Macros used to control whether the wrapper breakpoints on an exception
#if DBG
#define RxSaveAndSetExceptionNoBreakpointFlag(RXCONTEXT,_yyy){ \
    _yyy = RxContext->Flags & RX_CONTEXT_FLAG_NO_EXCEPTION_BREAKPOINT;   \
    RxContext->Flags |= RX_CONTEXT_FLAG_NO_EXCEPTION_BREAKPOINT;        \
}
#define RxRestoreExceptionNoBreakpointFlag(RXCONTEXT,_yyy){ \
    RxContext->Flags &= ~RX_CONTEXT_FLAG_NO_EXCEPTION_BREAKPOINT;        \
    RxContext->Flags |= _yyy;                              \
}
#else
#define RxSaveAndSetExceptionNoBreakpointFlag(_xxx,_yyy)
#define RxRestoreExceptionNoBreakpointFlag(_xxx,_yyy)
#endif

// a macro used to ensure that a context hasn't been freed during a wait
#if DBG
VOID
__RxItsTheSameContext(
    PRX_CONTEXT RxContext,
    ULONG CapturedRxContextSerialNumber,
    ULONG Line,
    PSZ File
    );
#define RxItsTheSameContext() {__RxItsTheSameContext(RxContext,CapturedRxContextSerialNumber,__LINE__,__FILE__);}
#else
#define RxItsTheSameContext() {NOTHING;}
#endif

extern NPAGED_LOOKASIDE_LIST RxContextLookasideList;

// Macros used in the RDBSS to wrap mini rdr calldowns

#define MINIRDR_CALL_THROUGH(STATUS,DISPATCH,FUNC,ARGLIST)                 \
   {                                                                       \
    ASSERT(DISPATCH);                                                      \
    ASSERT( NodeType(DISPATCH) == RDBSS_NTC_MINIRDR_DISPATCH );            \
    ASSERT(DISPATCH->FUNC);                                                \
    RxDbgTrace(0, Dbg, ("MiniRdr Calldown - %s\n",#FUNC));                 \
    STATUS = DISPATCH->FUNC ARGLIST;                                       \
   }

#define MINIRDR_CALL(STATUS,CONTEXT,DISPATCH,FUNC,ARGLIST)                 \
   {                                                                       \
    ASSERT(DISPATCH);                                                      \
    ASSERT( NodeType(DISPATCH) == RDBSS_NTC_MINIRDR_DISPATCH );            \
    if ( DISPATCH->FUNC == NULL) {                                         \
       STATUS = STATUS_NOT_IMPLEMENTED;                                    \
    } else {                                                               \
       if (!BooleanFlagOn((CONTEXT)->Flags,RX_CONTEXT_FLAG_CANCELLED)) {   \
          RxDbgTrace(0, Dbg, ("MiniRdr Calldown - %s\n",#FUNC));           \
          RtlZeroMemory(&((CONTEXT)->MRxContext[0]),                       \
                        sizeof((CONTEXT)->MRxContext));                    \
          STATUS = DISPATCH->FUNC ARGLIST;                                 \
       } else {                                                            \
          STATUS = STATUS_CANCELLED;                                       \
       }                                                                   \
    }                                                                      \
   }


//VOID
//RxWaitSync (
//    IN PRX_CONTEXT RxContext
//    )

#define  RxWaitSync(RxContext)                                                   \
         RxDbgTrace(+1, Dbg, ("RxWaitSync, RxContext = %08lx\n", (RxContext)));  \
         (RxContext)->Flags |= RX_CONTEXT_FLAG_SYNC_EVENT_WAITERS;               \
         KeWaitForSingleObject( &(RxContext)->SyncEvent,                         \
                               Executive, KernelMode, FALSE, NULL );             \
         RxDbgTrace(-1, Dbg, ("RxWaitSync -> VOID\n", 0 ))

//VOID
//RxSignalSynchronousWaiter (
//    IN PRX_CONTEXT RxContext
//    )

#define RxSignalSynchronousWaiter(RxContext)                       \
        (RxContext)->Flags &= ~RX_CONTEXT_FLAG_SYNC_EVENT_WAITERS; \
        KeSetEvent( &(RxContext)->SyncEvent, 0, FALSE )


#define RxInsertContextInSerializationQueue(pSerializationQueue,RxContext) \
        (RxContext)->Flags |= RX_CONTEXT_FLAG_IN_SERIALIZATION_QUEUE;      \
        InsertTailList(pSerializationQueue,&((RxContext)->RxContextSerializationQLinks))

INLINE PRX_CONTEXT
RxRemoveFirstContextFromSerializationQueue(PLIST_ENTRY pSerializationQueue)
{
   if (IsListEmpty(pSerializationQueue)) {
      return NULL;
   } else {
      PRX_CONTEXT pContext = (PRX_CONTEXT)(CONTAINING_RECORD(pSerializationQueue->Flink,
                                             RX_CONTEXT,
                                             RxContextSerializationQLinks));

      RemoveEntryList(pSerializationQueue->Flink);

      pContext->RxContextSerializationQLinks.Flink = NULL;
      pContext->RxContextSerializationQLinks.Blink = NULL;
      return pContext;
   }
}

// The following macros provide a mechanism for doing an en masse transfer
// from one list onto another. This provides a powerful paradigm for dealing
// with DPC level processing of lists.

#define RxTransferList(pDestination,pSource)                   \
         if (IsListEmpty((pSource))) {                         \
            InitializeListHead((pDestination));              \
         } else {                                              \
            *(pDestination) = *(pSource);                      \
            (pDestination)->Flink->Blink = (pDestination);     \
            (pDestination)->Blink->Flink = (pDestination);     \
            InitializeListHead((pSource));                   \
         }

#define RxTransferListWithMutex(pDestination,pSource,pMutex) \
    {                                                   \
        ExAcquireFastMutex(pMutex);                     \
        RxTransferList(pDestination,pSource);           \
        ExReleaseFastMutex(pMutex);                     \
    }


VOID RxInitializeRxContexter(void);
VOID RxUninitializeRxContexter(void);

VOID
RxCancelNotifyChangeDirectoryRequestsForVNetRoot(
   PV_NET_ROOT pVNetRoot);

VOID
RxCancelNotifyChangeDirectoryRequestsForFobx(
   PFOBX pFobx);

NTSTATUS
NTAPI
RxSetMinirdrCancelRoutine(
    IN OUT PRX_CONTEXT   RxContext,
    IN     PMRX_CALLDOWN MRxCancelRoutine);

VOID
NTAPI
RxInitializeContext(
    IN PIRP            Irp,
    IN PRDBSS_DEVICE_OBJECT RxDeviceObject,
    IN ULONG           InitialContextFlags,
    IN OUT PRX_CONTEXT RxContext);

PRX_CONTEXT
NTAPI
RxCreateRxContext (
    IN PIRP Irp,
    IN PRDBSS_DEVICE_OBJECT RxDeviceObject,
    IN ULONG InitialContextFlags
    );

VOID
NTAPI
RxPrepareContextForReuse(
   IN OUT PRX_CONTEXT RxContext);

VOID
NTAPI
RxDereferenceAndDeleteRxContext_Real (
    IN PRX_CONTEXT RxContext
    );

VOID
NTAPI
RxReinitializeContext(
   IN OUT PRX_CONTEXT RxContext);

#if DBG
#define RxDereferenceAndDeleteRxContext(RXCONTEXT) {   \
    RxDereferenceAndDeleteRxContext_Real((RXCONTEXT)); \
    (RXCONTEXT) = NULL;                    \
}
#else
#define RxDereferenceAndDeleteRxContext(RXCONTEXT) {   \
    RxDereferenceAndDeleteRxContext_Real((RXCONTEXT)); \
}
#endif //

extern FAST_MUTEX RxContextPerFileSerializationMutex;

NTSTATUS
NTAPI
__RxSynchronizeBlockingOperationsMaybeDroppingFcbLock(
    IN OUT PRX_CONTEXT RxContext,
    IN OUT PLIST_ENTRY BlockingIoQ,
    IN     BOOLEAN     DropFcbLock
    );
#define RxSynchronizeBlockingOperationsAndDropFcbLock(__x,__y) \
              __RxSynchronizeBlockingOperationsMaybeDroppingFcbLock(__x,__y,TRUE)
#define RxSynchronizeBlockingOperations(__x,__y) \
              __RxSynchronizeBlockingOperationsMaybeDroppingFcbLock(__x,__y,FALSE)

VOID
NTAPI
RxResumeBlockedOperations_Serially(
    IN OUT PRX_CONTEXT RxContext,
    IN OUT PLIST_ENTRY BlockingIoQ
    );

VOID
RxResumeBlockedOperations_ALL(
    IN OUT PRX_CONTEXT RxContext
    );


VOID
RxCancelBlockingOperation(
    IN OUT PRX_CONTEXT RxContext);

VOID
RxRemoveOperationFromBlockingQueue(
    IN OUT PRX_CONTEXT RxContext);


#endif // _RX_CONTEXT_STRUCT_DEFINED_


#else /* NTDDI_VERSION */

#error This file cannot be included for this NTDDI_VERSION.

#endif /* NTDDI_VERSION */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\rxovride.h ===
#if !defined(NTDDI_VERSION)

#error NTDDI_VERSION must be defined to include this file.

#elif (NTDDI_VERSION >= NTDDI_VISTA)

/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    rxovride.h

Abstract:

    This file has two purposes. First, things that are absolutely global are included here; a macro
    NO_RXOVRIDE_GLOBAL maybe defined to get only the second behaviour.

    Second, this file is used as a shortterm expedient to ensure that the logging version of the wrapper,
    smbmini and rdr2kd is built irrespective of the build environment. indeed, all of the debugging issues
    can be enabled disabled from here instead of juggling all of the sources files. to override what it says
    in this file...define RX_BUILD_FREE_ANYWAY.

Author:
Revision History:

Notes:



--*/
#ifndef NO_RXOVRIDE_GLOBAL

// define pointer types for all of the important structures..........
#include <struchdr.h>        // RDBSS related definitions

#endif //ifndef NO_RXOVRIDE_GLOBAL


//control the debugging state of the built components
#define RDBSS_TRACKER 1

#if !DBG
#define RX_ORIGINAL_DBG 0
#else
#define RX_ORIGINAL_DBG 1
#endif

#if 0
#ifndef RDBSSTRACE
#define RDBSSTRACE 1
#endif //ifndef RDBSSTRACE
#endif

#ifndef RX_POOL_WRAPPER
#define RX_POOL_WRAPPER 1
#endif //ifndef RX_POOL_WRAPPER

#ifndef RDBSS_ASSERTS
#define RDBSS_ASSERTS 1
#endif //ifndef RDBSS_ASSERTS

#if DBG

#ifndef RDBSSLOG
#define RDBSSLOG 1
#endif //ifndef RDBSSLOG

#else // DBG

#if PRERELEASE
#ifndef RDBSSLOG
#define RDBSSLOG 1
#endif //ifndef RDBSSLOG
#endif  // if PRERELEASE

#endif  // if DBG

#elif (NTDDI_VERSION >= NTDDI_WS03)

/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    rxovride.h

Abstract:

    This file has two purposes. First, things that are absolutely global are included here; a macro
    NO_RXOVRIDE_GLOBAL maybe defined to get only the second behaviour.

    Second, this file is used as a shortterm expedient to ensure that the logging version of the wrapper,
    smbmini and rdr2kd is built irrespective of the build environment. indeed, all of the debugging issues
    can be enabled disabled from here instead of juggling all of the sources files. to override what it says
    in this file...define RX_BUILD_FREE_ANYWAY.

Author:
Revision History:

Notes:



--*/
#ifndef NO_RXOVRIDE_GLOBAL

// define pointer types for all of the important structures..........
#include <struchdr.h>        // RDBSS related definitions

#endif //ifndef NO_RXOVRIDE_GLOBAL


//control the debugging state of the built components
#define RDBSS_TRACKER 1

#if !DBG
#define RX_ORIGINAL_DBG 0
#else
#define RX_ORIGINAL_DBG 1
#endif

#if 0
#ifndef RDBSSTRACE
#define RDBSSTRACE 1
#endif //ifndef RDBSSTRACE
#endif

#ifndef RX_POOL_WRAPPER
#define RX_POOL_WRAPPER 1
#endif //ifndef RX_POOL_WRAPPER

#ifndef RDBSS_ASSERTS
#define RDBSS_ASSERTS 1
#endif //ifndef RDBSS_ASSERTS

#if DBG

#ifndef RDBSSLOG
#define RDBSSLOG 1
#endif //ifndef RDBSSLOG

#else // DBG

#if PRERELEASE
#ifndef RDBSSLOG
#define RDBSSLOG 1
#endif //ifndef RDBSSLOG
#endif  // if PRERELEASE

#endif  // if DBG


#elif (NTDDI_VERSION >= NTDDI_WINXP)

/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    rxovride.h

Abstract:

    This file has two purposes. First, things that are absolutely global are included here; a macro
    NO_RXOVRIDE_GLOBAL maybe defined to get only the second behaviour.

    Second, this file is used as a shortterm expedient to ensure that the logging version of the wrapper,
    smbmini and rdr2kd is built irrespective of the build environment. indeed, all of the debugging issues
    can be enabled disabled from here instead of juggling all of the sources files. to override what it says
    in this file...define RX_BUILD_FREE_ANYWAY.

Author:
Revision History:

Notes:



--*/
#ifndef NO_RXOVRIDE_GLOBAL

// define pointer types for all of the important structures..........
#include <struchdr.h>        // RDBSS related definitions

#endif //ifndef NO_RXOVRIDE_GLOBAL


//control the debugging state of the built components
#define RDBSS_TRACKER 1

#if !DBG
#define RX_ORIGINAL_DBG 0
#else
#define RX_ORIGINAL_DBG 1
#endif

#if 0
#ifndef RDBSSTRACE
#define RDBSSTRACE 1
#endif //ifndef RDBSSTRACE
#endif

#ifndef RX_POOL_WRAPPER
#define RX_POOL_WRAPPER 1
#endif //ifndef RX_POOL_WRAPPER

#ifndef RDBSS_ASSERTS
#define RDBSS_ASSERTS 1
#endif //ifndef RDBSS_ASSERTS

#if DBG

#ifndef RDBSSLOG
#define RDBSSLOG 1
#endif //ifndef RDBSSLOG

#else // DBG

#if PRERELEASE
#ifndef RDBSSLOG
#define RDBSSLOG 1
#endif //ifndef RDBSSLOG
#endif  // if PRERELEASE

#endif  // if DBG


#elif (NTDDI_VERSION >= NTDDI_WIN2K)

/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    rxovride.h

Abstract:

    This file has two purposes. First, things that are absolutely global are included here; a macro
    NO_RXOVRIDE_GLOBAL maybe defined to get only the second behaviour.

    Second, this file is used as a shortterm expedient to ensure that the logging version of the wrapper,
    smbmini and rdr2kd is built irrespective of the build environment. indeed, all of the debugging issues
    can be enabled disabled from here instead of juggling all of the sources files. to override what it says
    in this file...define RX_BUILD_FREE_ANYWAY.

Author:
Revision History:

Notes:



--*/
#ifndef NO_RXOVRIDE_GLOBAL

// define pointer types for all of the important structures..........
#include <struchdr.h>        // RDBSS related definitions

#endif //ifndef NO_RXOVRIDE_GLOBAL


//control the debugging state of the built components
#define RDBSS_TRACKER 1

#if !DBG
#define RX_ORIGINAL_DBG 0
#else
#define RX_ORIGINAL_DBG 1
#endif

#if 0
#ifndef RDBSSTRACE
#define RDBSSTRACE 1
#endif //ifndef RDBSSTRACE
#endif

#ifndef RX_POOL_WRAPPER
#define RX_POOL_WRAPPER 1
#endif //ifndef RX_POOL_WRAPPER

#ifndef RDBSS_ASSERTS
#define RDBSS_ASSERTS 1
#endif //ifndef RDBSS_ASSERTS

#if DBG
#ifndef RDBSSLOG
#define RDBSSLOG 1
#endif //ifndef RDBSSLOG
#endif


#else /* NTDDI_VERSION */

#error This file cannot be included for this NTDDI_VERSION.

#endif /* NTDDI_VERSION */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\rxexcept.h ===
#if !defined(NTDDI_VERSION)

#error NTDDI_VERSION must be defined to include this file.

#elif (NTDDI_VERSION >= NTDDI_VISTA)

/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    Except.h

Abstract:

    This module prototypes the macros and routines used for exception handling.

Author:
Revision History:

--*/

#ifndef _EXCEPTION_STUFF_DEFINED_
#define _EXCEPTION_STUFF_DEFINED_


//
//  The following two macro are used by the Fsd/Fsp exception handlers to
//  process an exception.  The first macro is the exception filter used in the
//  Fsd/Fsp to decide if an exception should be handled at this level.
//  The second macro decides if the exception is to be finished off by
//  completing the IRP, and cleaning up the Irp Context, or if we should
//  bugcheck.  Exception values such as RxStatus(FILE_INVALID) (raised by
//  VerfySup.c) cause us to complete the Irp and cleanup, while exceptions
//  such as accvio cause us to bugcheck.
//
//  The basic structure for fsd/fsp exception handling is as follows:
//
//  RxFsdXxx(...)
//  {
//      try {
//
//          ...
//
//      } except(RxExceptionFilter( RxContext, GetExceptionCode() )) {
//
//          Status = RxProcessException( RxContext, GetExceptionCode() );
//      }
//
//      Return Status;
//  }
//
//  To explicitly raise an exception that we expect, such as
//  RxStatus(FILE_INVALID), use the below macro RxRaiseStatus().  To raise a
//  status from an unknown origin (such as CcFlushCache()), use the macro
//  RxNormalizeAndRaiseStatus.  This will raise the status if it is expected,
//  or raise RxStatus(UNEXPECTED_IO_ERROR) if it is not.
//
//  Note that when using these two macros, the original status is placed in
//  RxContext->ExceptionStatus, signaling RxExceptionFilter and
//  RxProcessException that the status we actually raise is by definition
//  expected.
//

LONG
RxExceptionFilter (
    IN PRX_CONTEXT RxContext,
    IN PEXCEPTION_POINTERS ExceptionPointer
    );

NTSTATUS
RxProcessException (
    IN PRX_CONTEXT RxContext,
    IN NTSTATUS ExceptionCode
    );

#define CATCH_EXPECTED_EXCEPTIONS   (FsRtlIsNtstatusExpected(GetExceptionCode()) ?   \
                      EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH )


//
//  VOID
//  RxRaiseStatus (
//      IN PRIP_CONTEXT RxContext,
//      IN NT_STATUS Status
//  );
//
//

#define RxRaiseStatus(RXCONTEXT,STATUS) {   \
    ASSERT((RXCONTEXT)!=NULL);              \
    if (RxContext!=NULL) {(RXCONTEXT)->StoredStatus = (STATUS);   }          \
    ExRaiseStatus( (STATUS) );              \
}

//
//  VOID
//  RxNormalAndRaiseStatus (
//      IN PRIP_CONTEXT RxContext,
//      IN NT_STATUS Status
//  );
//

#define RxNormalizeAndRaiseStatus(RXCONTEXT,STATUS) {                         \
    ASSERT((RXCONTEXT)!=NULL);              \
    if (RxContext!=NULL) {(RXCONTEXT)->StoredStatus = (STATUS);   }          \
    if ((STATUS) == (STATUS_VERIFY_REQUIRED)) { ExRaiseStatus((STATUS)); }        \
    ExRaiseStatus(FsRtlNormalizeNtstatus((STATUS),(STATUS_UNEXPECTED_IO_ERROR))); \
}


//
//  The following macros are used to establish the semantics needed
//  to do a return from within a try-finally clause.  As a rule every
//  try clause must end with a label call try_exit.  For example,
//
//      try {
//              :
//              :
//
//      try_exit: NOTHING;
//      } finally {
//
//              :
//              :
//      }
//
//  Every return statement executed inside of a try clause should use the
//  try_return macro.  If the compiler fully supports the try-finally construct
//  then the macro should be
//
//      #define try_return(S)  { return(S); }
//
//  If the compiler does not support the try-finally construct then the macro
//  should be
//
//      #define try_return(S)  { S; goto try_exit; }
//

#define try_return(S) { S; goto try_exit; }



#endif // _EXCEPTION_STUFF_DEFINED_

#elif (NTDDI_VERSION >= NTDDI_WS03)

/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    Except.h

Abstract:

    This module prototypes the macros and routines used for exception handling.

Author:
Revision History:

--*/

#ifndef _EXCEPTION_STUFF_DEFINED_
#define _EXCEPTION_STUFF_DEFINED_


//
//  The following two macro are used by the Fsd/Fsp exception handlers to
//  process an exception.  The first macro is the exception filter used in the
//  Fsd/Fsp to decide if an exception should be handled at this level.
//  The second macro decides if the exception is to be finished off by
//  completing the IRP, and cleaning up the Irp Context, or if we should
//  bugcheck.  Exception values such as RxStatus(FILE_INVALID) (raised by
//  VerfySup.c) cause us to complete the Irp and cleanup, while exceptions
//  such as accvio cause us to bugcheck.
//
//  The basic structure for fsd/fsp exception handling is as follows:
//
//  RxFsdXxx(...)
//  {
//      try {
//
//          ...
//
//      } except(RxExceptionFilter( RxContext, GetExceptionCode() )) {
//
//          Status = RxProcessException( RxContext, GetExceptionCode() );
//      }
//
//      Return Status;
//  }
//
//  To explicitly raise an exception that we expect, such as
//  RxStatus(FILE_INVALID), use the below macro RxRaiseStatus().  To raise a
//  status from an unknown origin (such as CcFlushCache()), use the macro
//  RxNormalizeAndRaiseStatus.  This will raise the status if it is expected,
//  or raise RxStatus(UNEXPECTED_IO_ERROR) if it is not.
//
//  Note that when using these two macros, the original status is placed in
//  RxContext->ExceptionStatus, signaling RxExceptionFilter and
//  RxProcessException that the status we actually raise is by definition
//  expected.
//

LONG
RxExceptionFilter (
    IN PRX_CONTEXT RxContext,
    IN PEXCEPTION_POINTERS ExceptionPointer
    );

NTSTATUS
RxProcessException (
    IN PRX_CONTEXT RxContext,
    IN NTSTATUS ExceptionCode
    );

#define CATCH_EXPECTED_EXCEPTIONS   (FsRtlIsNtstatusExpected(GetExceptionCode()) ?   \
                      EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH )


//
//  VOID
//  RxRaiseStatus (
//      IN PRIP_CONTEXT RxContext,
//      IN NT_STATUS Status
//  );
//
//

#define RxRaiseStatus(RXCONTEXT,STATUS) {   \
    ASSERT((RXCONTEXT)!=NULL);              \
    if (RxContext!=NULL) {(RXCONTEXT)->StoredStatus = (STATUS);   }          \
    ExRaiseStatus( (STATUS) );              \
}

//
//  VOID
//  RxNormalAndRaiseStatus (
//      IN PRIP_CONTEXT RxContext,
//      IN NT_STATUS Status
//  );
//

#define RxNormalizeAndRaiseStatus(RXCONTEXT,STATUS) {                         \
    ASSERT((RXCONTEXT)!=NULL);              \
    if (RxContext!=NULL) {(RXCONTEXT)->StoredStatus = (STATUS);   }          \
    if ((STATUS) == (STATUS_VERIFY_REQUIRED)) { ExRaiseStatus((STATUS)); }        \
    ExRaiseStatus(FsRtlNormalizeNtstatus((STATUS),(STATUS_UNEXPECTED_IO_ERROR))); \
}


//
//  The following macros are used to establish the semantics needed
//  to do a return from within a try-finally clause.  As a rule every
//  try clause must end with a label call try_exit.  For example,
//
//      try {
//              :
//              :
//
//      try_exit: NOTHING;
//      } finally {
//
//              :
//              :
//      }
//
//  Every return statement executed inside of a try clause should use the
//  try_return macro.  If the compiler fully supports the try-finally construct
//  then the macro should be
//
//      #define try_return(S)  { return(S); }
//
//  If the compiler does not support the try-finally construct then the macro
//  should be
//
//      #define try_return(S)  { S; goto try_exit; }
//

#define try_return(S) { S; goto try_exit; }



#endif // _EXCEPTION_STUFF_DEFINED_


#elif (NTDDI_VERSION >= NTDDI_WINXP)

/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    Except.h

Abstract:

    This module prototypes the macros and routines used for exception handling.

Author:
Revision History:

--*/

#ifndef _EXCEPTION_STUFF_DEFINED_
#define _EXCEPTION_STUFF_DEFINED_


//
//  The following two macro are used by the Fsd/Fsp exception handlers to
//  process an exception.  The first macro is the exception filter used in the
//  Fsd/Fsp to decide if an exception should be handled at this level.
//  The second macro decides if the exception is to be finished off by
//  completing the IRP, and cleaning up the Irp Context, or if we should
//  bugcheck.  Exception values such as RxStatus(FILE_INVALID) (raised by
//  VerfySup.c) cause us to complete the Irp and cleanup, while exceptions
//  such as accvio cause us to bugcheck.
//
//  The basic structure for fsd/fsp exception handling is as follows:
//
//  RxFsdXxx(...)
//  {
//      try {
//
//          ...
//
//      } except(RxExceptionFilter( RxContext, GetExceptionCode() )) {
//
//          Status = RxProcessException( RxContext, GetExceptionCode() );
//      }
//
//      Return Status;
//  }
//
//  To explicitly raise an exception that we expect, such as
//  RxStatus(FILE_INVALID), use the below macro RxRaiseStatus().  To raise a
//  status from an unknown origin (such as CcFlushCache()), use the macro
//  RxNormalizeAndRaiseStatus.  This will raise the status if it is expected,
//  or raise RxStatus(UNEXPECTED_IO_ERROR) if it is not.
//
//  Note that when using these two macros, the original status is placed in
//  RxContext->ExceptionStatus, signaling RxExceptionFilter and
//  RxProcessException that the status we actually raise is by definition
//  expected.
//

LONG
RxExceptionFilter (
    IN PRX_CONTEXT RxContext,
    IN PEXCEPTION_POINTERS ExceptionPointer
    );

NTSTATUS
RxProcessException (
    IN PRX_CONTEXT RxContext,
    IN NTSTATUS ExceptionCode
    );

#define CATCH_EXPECTED_EXCEPTIONS   (FsRtlIsNtstatusExpected(GetExceptionCode()) ?   \
                      EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH )


//
//  VOID
//  RxRaiseStatus (
//      IN PRIP_CONTEXT RxContext,
//      IN NT_STATUS Status
//  );
//
//

#define RxRaiseStatus(RXCONTEXT,STATUS) {   \
    ASSERT((RXCONTEXT)!=NULL);              \
    if (RxContext!=NULL) {(RXCONTEXT)->StoredStatus = (STATUS);   }          \
    ExRaiseStatus( (STATUS) );              \
}

//
//  VOID
//  RxNormalAndRaiseStatus (
//      IN PRIP_CONTEXT RxContext,
//      IN NT_STATUS Status
//  );
//

#define RxNormalizeAndRaiseStatus(RXCONTEXT,STATUS) {                         \
    ASSERT((RXCONTEXT)!=NULL);              \
    if (RxContext!=NULL) {(RXCONTEXT)->StoredStatus = (STATUS);   }          \
    if ((STATUS) == (STATUS_VERIFY_REQUIRED)) { ExRaiseStatus((STATUS)); }        \
    ExRaiseStatus(FsRtlNormalizeNtstatus((STATUS),(STATUS_UNEXPECTED_IO_ERROR))); \
}


//
//  The following macros are used to establish the semantics needed
//  to do a return from within a try-finally clause.  As a rule every
//  try clause must end with a label call try_exit.  For example,
//
//      try {
//              :
//              :
//
//      try_exit: NOTHING;
//      } finally {
//
//              :
//              :
//      }
//
//  Every return statement executed inside of a try clause should use the
//  try_return macro.  If the compiler fully supports the try-finally construct
//  then the macro should be
//
//      #define try_return(S)  { return(S); }
//
//  If the compiler does not support the try-finally construct then the macro
//  should be
//
//      #define try_return(S)  { S; goto try_exit; }
//

#define try_return(S) { S; goto try_exit; }



#endif // _EXCEPTION_STUFF_DEFINED_


#elif (NTDDI_VERSION >= NTDDI_WIN2K)

/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    Except.h

Abstract:

    This module prototypes the macros and routines used for exception handling.

Author:
Revision History:

--*/

#ifndef _EXCEPTION_STUFF_DEFINED_
#define _EXCEPTION_STUFF_DEFINED_


//
//  The following two macro are used by the Fsd/Fsp exception handlers to
//  process an exception.  The first macro is the exception filter used in the
//  Fsd/Fsp to decide if an exception should be handled at this level.
//  The second macro decides if the exception is to be finished off by
//  completing the IRP, and cleaning up the Irp Context, or if we should
//  bugcheck.  Exception values such as RxStatus(FILE_INVALID) (raised by
//  VerfySup.c) cause us to complete the Irp and cleanup, while exceptions
//  such as accvio cause us to bugcheck.
//
//  The basic structure for fsd/fsp exception handling is as follows:
//
//  RxFsdXxx(...)
//  {
//      try {
//
//          ...
//
//      } except(RxExceptionFilter( RxContext, GetExceptionCode() )) {
//
//          Status = RxProcessException( RxContext, GetExceptionCode() );
//      }
//
//      Return Status;
//  }
//
//  To explicitly raise an exception that we expect, such as
//  RxStatus(FILE_INVALID), use the below macro RxRaiseStatus().  To raise a
//  status from an unknown origin (such as CcFlushCache()), use the macro
//  RxNormalizeAndRaiseStatus.  This will raise the status if it is expected,
//  or raise RxStatus(UNEXPECTED_IO_ERROR) if it is not.
//
//  Note that when using these two macros, the original status is placed in
//  RxContext->ExceptionStatus, signaling RxExceptionFilter and
//  RxProcessException that the status we actually raise is by definition
//  expected.
//

LONG
RxExceptionFilter (
    IN PRX_CONTEXT RxContext,
    IN PEXCEPTION_POINTERS ExceptionPointer
    );

NTSTATUS
RxProcessException (
    IN PRX_CONTEXT RxContext,
    IN NTSTATUS ExceptionCode
    );

#define CATCH_EXPECTED_EXCEPTIONS   (FsRtlIsNtstatusExpected(GetExceptionCode()) ?   \
                      EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH )


//
//  VOID
//  RxRaiseStatus (
//      IN PRIP_CONTEXT RxContext,
//      IN NT_STATUS Status
//  );
//
//

#define RxRaiseStatus(RXCONTEXT,STATUS) {   \
    ASSERT((RXCONTEXT)!=NULL);              \
    if (RxContext!=NULL) {(RXCONTEXT)->StoredStatus = (STATUS);   }          \
    ExRaiseStatus( (STATUS) );              \
}

//
//  VOID
//  RxNormalAndRaiseStatus (
//      IN PRIP_CONTEXT RxContext,
//      IN NT_STATUS Status
//  );
//

#define RxNormalizeAndRaiseStatus(RXCONTEXT,STATUS) {                         \
    ASSERT((RXCONTEXT)!=NULL);              \
    if (RxContext!=NULL) {(RXCONTEXT)->StoredStatus = (STATUS);   }          \
    if ((STATUS) == (STATUS_VERIFY_REQUIRED)) { ExRaiseStatus((STATUS)); }        \
    ExRaiseStatus(FsRtlNormalizeNtstatus((STATUS),(STATUS_UNEXPECTED_IO_ERROR))); \
}


//
//  The following macros are used to establish the semantics needed
//  to do a return from within a try-finally clause.  As a rule every
//  try clause must end with a label call try_exit.  For example,
//
//      try {
//              :
//              :
//
//      try_exit: NOTHING;
//      } finally {
//
//              :
//              :
//      }
//
//  Every return statement executed inside of a try clause should use the
//  try_return macro.  If the compiler fully supports the try-finally construct
//  then the macro should be
//
//      #define try_return(S)  { return(S); }
//
//  If the compiler does not support the try-finally construct then the macro
//  should be
//
//      #define try_return(S)  { S; goto try_exit; }
//

#define try_return(S) { S; goto try_exit; }



#endif // _EXCEPTION_STUFF_DEFINED_


#else /* NTDDI_VERSION */

#error This file cannot be included for this NTDDI_VERSION.

#endif /* NTDDI_VERSION */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\rxlog.h ===
#if !defined(NTDDI_VERSION)

#error NTDDI_VERSION must be defined to include this file.

#elif (NTDDI_VERSION >= NTDDI_VISTA)

/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    RxLog.h

Abstract:

    This module declares the prototypes and global data used by the RDBSS debug logging facilities.

Author:
Notes:

    The log records are stored in a circular buffer. Each record is bounded on either side by
    a record descriptor. This record descriptor is four bytes long.

--*/

#ifndef _RDBSSLOG_INCLUDED_
#define _RDBSSLOG_INCLUDED_


typedef enum {
   RX_LOG_UNINITIALIZED,
   RX_LOG_ENABLED,
   RX_LOG_DISABLED,
   RX_LOG_ERROR
} RX_LOGGING_STATE;

typedef struct RX_LOG_ENTRY_HEADER {
    PCHAR Buffer;
} RX_LOG_ENTRY_HEADER, *PRX_LOG_ENTRY_HEADER;


typedef struct RX_LOG {
   RX_SPIN_LOCK         SpinLock;
   RX_LOGGING_STATE     State;
   PRX_LOG_ENTRY_HEADER CurrentEntry;
   PRX_LOG_ENTRY_HEADER BaseEntry;
   PRX_LOG_ENTRY_HEADER EntryLimit;
   ULONG                LogBufferSizeInEntries;
   ULONG                NumberOfEntriesIgnored;
   ULONG                NumberOfLogWriteAttempts;
   ULONG                NumberOfLogWraps;
} RX_LOG, *PRX_LOG;


//the logging facilities are always present. what RDBSSLOG does is to enable generation
//of the calls! on checked builds, you even get the calls unless NO_RDBSSLOG is set.

//extern
//VOID
//RxLogInterlockedAddUlong(
//    PULONG Result,
//    PULONG Counter,
//    ULONG Addend);

extern 
VOID
RxDebugControlCommand (
    __in PSTR ControlString
    );

extern
NTSTATUS
RxInitializeLog(void);

extern
VOID
RxUninitializeLog(void);

extern
VOID
_RxPrintLog(IN ULONG EntriesToPrint OPTIONAL);

extern
VOID
_RxPauseLog(void);

extern
VOID
_RxResumeLog (void);

extern
VOID
_RxLog(PCSTR format, ...);


#define MAX_RX_LOG_ENTRY_SIZE  (48)

#define RDBSSLOG_ASYNC_NAME_PREFIX "[nowait]"
#define RXCONTX_OPERATION_NAME(MajorFunction,Wait) \
    (RxContxOperationNames[(MajorFunction)]+((Wait)?(sizeof(RDBSSLOG_ASYNC_NAME_PREFIX)-1):0))
extern PUCHAR RxContxOperationNames[];

#ifdef RDBSSLOG

                             //
// The arguments to RxLog must be enclosed with an additional pair of parenthesis to enable
// transalation into a null call when logging should be turned off.
// e.g. RxLog(("%s %d", FILE, LINE))
#if DBG
#define RxLog(Args)   _RxLog##Args
#define RxLogRetail(Args)   _RxLog##Args
#else
#define RxLogRetail(Args)   _RxLog##Args
#define RxLog(Args) {NOTHING;}
#endif

#define RxPauseLog()  _RxPauseLog()
#define RxResumeLog() _RxResumeLog()

#else //if notdef  RDBSSLOG

#define RxLog(Args)   {NOTHING;}
#define RxLogRetail(Args) {NOTHING;}
#define RxPauseLog()  {NOTHING;}
#define RxResumeLog() {NOTHING;}

#endif

#if DBG
#define RxDbgPrint(Args) DbgPrint##Args
#else
#define RxDbgPrint(Args) NOTHING
#endif

extern LIST_ENTRY RxIrpsList;
extern KSPIN_LOCK RxIrpsListSpinLock;

typedef struct _RX_IRP_LIST_ITEM {
    LIST_ENTRY  IrpsList;
    PIRP        pIrp;
    PMDL        CopyDataBuffer;
    ULONG       Completed;
} RX_IRP_LIST_ITEM, *PRX_IRP_LIST_ITEM;

#endif // _RDBSSLOG_INCLUDED_

#elif (NTDDI_VERSION >= NTDDI_WS03)

/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    RxLog.h

Abstract:

    This module declares the prototypes and global data used by the RDBSS debug logging facilities.

Author:
Notes:

    The log records are stored in a circular buffer. Each record is bounded on either side by
    a record descriptor. This record descriptor is four bytes long.

--*/

#ifndef _RDBSSLOG_INCLUDED_
#define _RDBSSLOG_INCLUDED_


typedef enum {
   RX_LOG_UNINITIALIZED,
   RX_LOG_ENABLED,
   RX_LOG_DISABLED,
   RX_LOG_ERROR
} RX_LOGGING_STATE;

typedef struct RX_LOG_ENTRY_HEADER {
    PCHAR Buffer;
} RX_LOG_ENTRY_HEADER, *PRX_LOG_ENTRY_HEADER;


typedef struct RX_LOG {
   RX_SPIN_LOCK         SpinLock;
   RX_LOGGING_STATE     State;
   PRX_LOG_ENTRY_HEADER CurrentEntry;
   PRX_LOG_ENTRY_HEADER BaseEntry;
   PRX_LOG_ENTRY_HEADER EntryLimit;
   ULONG                LogBufferSizeInEntries;
   ULONG                NumberOfEntriesIgnored;
   ULONG                NumberOfLogWriteAttempts;
   ULONG                NumberOfLogWraps;
} RX_LOG, *PRX_LOG;


//the logging facilities are always present. what RDBSSLOG does is to enable generation
//of the calls! on checked builds, you even get the calls unless NO_RDBSSLOG is set.

//extern
//VOID
//RxLogInterlockedAddUlong(
//    PULONG Result,
//    PULONG Counter,
//    ULONG Addend);

extern
VOID
RxDebugControlCommand (
    IN char *ControlString
    );

extern
NTSTATUS
RxInitializeLog(void);

extern
VOID
RxUninitializeLog(void);

extern
VOID
_RxPrintLog(IN ULONG EntriesToPrint OPTIONAL);

extern
VOID
_RxPauseLog(void);

extern
VOID
_RxResumeLog (void);

extern
VOID
_RxLog(char *format, ...);


#define MAX_RX_LOG_ENTRY_SIZE  (48)

#define RDBSSLOG_ASYNC_NAME_PREFIX "[nowait]"
#define RXCONTX_OPERATION_NAME(MajorFunction,Wait) \
    (RxContxOperationNames[(MajorFunction)]+((Wait)?(sizeof(RDBSSLOG_ASYNC_NAME_PREFIX)-1):0))
extern PUCHAR RxContxOperationNames[];

#ifdef RDBSSLOG

                             //
// The arguments to RxLog must be enclosed with an additional pair of parenthesis to enable
// transalation into a null call when logging should be turned off.
// e.g. RxLog(("%s %d", FILE, LINE))
#if DBG
#define RxLog(Args)   _RxLog##Args
#define RxLogRetail(Args)   _RxLog##Args
#else
#define RxLogRetail(Args)   _RxLog##Args
#define RxLog(Args) {NOTHING;}
#endif

#define RxPauseLog()  _RxPauseLog()
#define RxResumeLog() _RxResumeLog()

#else //if notdef  RDBSSLOG

#define RxLog(Args)   {NOTHING;}
#define RxLogRetail(Args) {NOTHING;}
#define RxPauseLog()  {NOTHING;}
#define RxResumeLog() {NOTHING;}

#endif

#if DBG
#define RxDbgPrint(Args) DbgPrint##Args
#else
#define RxDbgPrint(Args) NOTHING
#endif

extern LIST_ENTRY RxIrpsList;
extern KSPIN_LOCK RxIrpsListSpinLock;

typedef struct _RX_IRP_LIST_ITEM {
    LIST_ENTRY  IrpsList;
    PIRP        pIrp;
    PMDL        CopyDataBuffer;
    ULONG       Completed;
} RX_IRP_LIST_ITEM, *PRX_IRP_LIST_ITEM;

#endif // _RDBSSLOG_INCLUDED_


#elif (NTDDI_VERSION >= NTDDI_WINXP)

/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    RxLog.h

Abstract:

    This module declares the prototypes and global data used by the RDBSS debug logging facilities.

Author:
Notes:

    The log records are stored in a circular buffer. Each record is bounded on either side by
    a record descriptor. This record descriptor is four bytes long.

--*/

#ifndef _RDBSSLOG_INCLUDED_
#define _RDBSSLOG_INCLUDED_


typedef enum {
   RX_LOG_UNINITIALIZED,
   RX_LOG_ENABLED,
   RX_LOG_DISABLED,
   RX_LOG_ERROR
} RX_LOGGING_STATE;

typedef struct RX_LOG_ENTRY_HEADER {
    PCHAR Buffer;
} RX_LOG_ENTRY_HEADER, *PRX_LOG_ENTRY_HEADER;


typedef struct RX_LOG {
   RX_SPIN_LOCK         SpinLock;
   RX_LOGGING_STATE     State;
   PRX_LOG_ENTRY_HEADER CurrentEntry;
   PRX_LOG_ENTRY_HEADER BaseEntry;
   PRX_LOG_ENTRY_HEADER EntryLimit;
   ULONG                LogBufferSizeInEntries;
   ULONG                NumberOfEntriesIgnored;
   ULONG                NumberOfLogWriteAttempts;
   ULONG                NumberOfLogWraps;
} RX_LOG, *PRX_LOG;


//the logging facilities are always present. what RDBSSLOG does is to enable generation
//of the calls! on checked builds, you even get the calls unless NO_RDBSSLOG is set.

//extern
//VOID
//RxLogInterlockedAddUlong(
//    PULONG Result,
//    PULONG Counter,
//    ULONG Addend);

extern
VOID
RxDebugControlCommand (
    IN char *ControlString
    );

extern
NTSTATUS
RxInitializeLog(void);

extern
VOID
RxUninitializeLog(void);

extern
VOID
_RxPrintLog(IN ULONG EntriesToPrint OPTIONAL);

extern
VOID
_RxPauseLog(void);

extern
VOID
_RxResumeLog (void);

extern
VOID
_RxLog(char *format, ...);


#define MAX_RX_LOG_ENTRY_SIZE  (48)

#define RDBSSLOG_ASYNC_NAME_PREFIX "[nowait]"
#define RXCONTX_OPERATION_NAME(MajorFunction,Wait) \
    (RxContxOperationNames[(MajorFunction)]+((Wait)?(sizeof(RDBSSLOG_ASYNC_NAME_PREFIX)-1):0))
extern PUCHAR RxContxOperationNames[];

#ifdef RDBSSLOG

                             //
// The arguments to RxLog must be enclosed with an additional pair of parenthesis to enable
// transalation into a null call when logging should be turned off.
// e.g. RxLog(("%s %d", FILE, LINE))
#if DBG
#define RxLog(Args)   _RxLog##Args
#define RxLogRetail(Args)   _RxLog##Args
#else
#define RxLogRetail(Args)   _RxLog##Args
#define RxLog(Args) {NOTHING;}
#endif

#define RxPauseLog()  _RxPauseLog()
#define RxResumeLog() _RxResumeLog()

#else //if notdef  RDBSSLOG

#define RxLog(Args)   {NOTHING;}
#define RxLogRetail(Args) {NOTHING;}
#define RxPauseLog()  {NOTHING;}
#define RxResumeLog() {NOTHING;}

#endif


#if DBG
#define RxDbgPrint(Args) DbgPrint##Args
#else
#define RxDbgPrint(Args) NOTHING
#endif

LIST_ENTRY RxIrpsList;
KSPIN_LOCK RxIrpsListSpinLock;

typedef struct _RX_IRP_LIST_ITEM {
    LIST_ENTRY  IrpsList;
    PIRP        pIrp;
    PMDL        CopyDataBuffer;
    ULONG       Completed;
} RX_IRP_LIST_ITEM, *PRX_IRP_LIST_ITEM;

#endif // _RDBSSLOG_INCLUDED_



#elif (NTDDI_VERSION >= NTDDI_WIN2K)

/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    RxLog.h

Abstract:

    This module declares the prototypes and global data used by the RDBSS debug logging facilities.

Author:
Notes:

    The log records are stored in a circular buffer. Each record is bounded on either side by
    a record descriptor. This record descriptor is four bytes long.

--*/

#ifndef _RDBSSLOG_INCLUDED_
#define _RDBSSLOG_INCLUDED_


typedef enum {
   RX_LOG_UNINITIALIZED,
   RX_LOG_ENABLED,
   RX_LOG_DISABLED,
   RX_LOG_ERROR
} RX_LOGGING_STATE;

typedef struct RX_LOG_ENTRY_HEADER {
    PCHAR Buffer;
} RX_LOG_ENTRY_HEADER, *PRX_LOG_ENTRY_HEADER;


typedef struct RX_LOG {
   RX_SPIN_LOCK         SpinLock;
   RX_LOGGING_STATE     State;
   PRX_LOG_ENTRY_HEADER CurrentEntry;
   PRX_LOG_ENTRY_HEADER BaseEntry;
   PRX_LOG_ENTRY_HEADER EntryLimit;
   ULONG                LogBufferSizeInEntries;
   ULONG                NumberOfEntriesIgnored;
   ULONG                NumberOfLogWriteAttempts;
   ULONG                NumberOfLogWraps;
} RX_LOG, *PRX_LOG;


//the logging facilities are always present. what RDBSSLOG does is to enable generation
//of the calls! on checked builds, you even get the calls unless NO_RDBSSLOG is set.

//extern
//VOID
//RxLogInterlockedAddUlong(
//    PULONG Result,
//    PULONG Counter,
//    ULONG Addend);

extern
VOID
RxDebugControlCommand (
    IN char *ControlString
    );

extern
NTSTATUS
RxInitializeLog(void);

extern
VOID
RxUninitializeLog(void);

extern
VOID
_RxPrintLog(IN ULONG EntriesToPrint OPTIONAL);

extern
VOID
_RxPauseLog(void);

extern
VOID
_RxResumeLog (void);

extern
VOID
_RxLog(char *format, ...);


#define MAX_RX_LOG_ENTRY_SIZE  (48)

#define RDBSSLOG_ASYNC_NAME_PREFIX "[nowait]"
#define RXCONTX_OPERATION_NAME(MajorFunction,Wait) \
    (RxContxOperationNames[(MajorFunction)]+((Wait)?(sizeof(RDBSSLOG_ASYNC_NAME_PREFIX)-1):0))
extern PUCHAR RxContxOperationNames[];

#ifdef RDBSSLOG

                             //
// The arguments to RxLog must be enclosed with an additional pair of parenthesis to enable
// transalation into a null call when logging should be turned off.
// e.g. RxLog(("%s %d", FILE, LINE))

#define RxLog(Args)   _RxLog##Args
#define RxPauseLog()  _RxPauseLog()
#define RxResumeLog() _RxResumeLog()

#else //if notdef  RDBSSLOG

#define RxLog(Args)   {NOTHING;}
#define RxPauseLog()  {NOTHING;}
#define RxResumeLog() {NOTHING;}
#endif

#endif // _RDBSSLOG_INCLUDED_

#if DBG
#define RxDbgPrint(Args) DbgPrint##Args
#else
#define RxDbgPrint(Args) NOTHING
#endif
LIST_ENTRY RxIrpsList;
KSPIN_LOCK RxIrpsListSpinLock;

typedef struct _RX_IRP_LIST_ITEM {
    LIST_ENTRY  IrpsList;
    PIRP        pIrp;
    PMDL        CopyDataBuffer;
    ULONG       Completed;
} RX_IRP_LIST_ITEM, *PRX_IRP_LIST_ITEM;


#else /* NTDDI_VERSION */

#error This file cannot be included for this NTDDI_VERSION.

#endif /* NTDDI_VERSION */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\rxpooltg.h ===
#if !defined(NTDDI_VERSION)

#error NTDDI_VERSION must be defined to include this file.

#elif (NTDDI_VERSION >= NTDDI_VISTA)

#error This file cannot be included for this NTDDI_VERSION.

#elif (NTDDI_VERSION >= NTDDI_WS03)

/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    rxpooltg.h

Abstract:

    The global pool tag definitions for RDBSS

Author:
Revision History:

   This file contains all the pool tag definitions related to the SMB mini redirector.
   The mechanism is intended to balance the number of pool tags to be used with the
   total number of tags available in the system.

   By specifying special flags the total number of tags consumed by the mini redirector
   can be controlled.

--*/

#ifndef _RXPOOLTG_H_
#define _RXPOOLTG_H_


#define RX_SRVCALL_POOLTAG      ('cSxR')
#define RX_NETROOT_POOLTAG      ('rNxR')
#define RX_V_NETROOT_POOLTAG    ('nVxR')
#define RX_FCB_POOLTAG          ('cFxR')
#define RX_SRVOPEN_POOLTAG      ('oSxR')
#define RX_FOBX_POOLTAG         ('xFxR')
#define RX_NONPAGEDFCB_POOLTAG  ('fNxR')
#define RX_WORKQ_POOLTAG        ('qWxR')
#define RX_BUFFERING_MANAGER_POOLTAG ('mBxR')
#define RX_MISC_POOLTAG         ('sMxR')
#define RX_IRPC_POOLTAG         ('rIxR')
#define RX_MRX_POOLTAG          ('xMxR')
#define RX_NAME_CACHE_POOLTAG   ('cNxR')
#define RX_BUFFERED_LOCK_POOLTAG ('kLxR')

#define RXCE_TRANSPORT_POOLTAG  ('tCxR')
#define RXCE_ADDRESS_POOLTAG    ('aCxR')
#define RXCE_CONNECTION_POOLTAG ('cCxR')
#define RXCE_VC_POOLTAG         ('vCxR')
#define RXCE_TDI_POOLTAG        ('dCxR')

extern ULONG RxExplodePoolTags;

#define RX_DEFINE_POOLTAG(ExplodedPoolTag,DefaultPoolTag)  \
        ((RxExplodePoolTags == 0) ? (DefaultPoolTag) : (ExplodedPoolTag))

#define RX_SRVCALL_PARAMS_POOLTAG   RX_DEFINE_POOLTAG('pSxR',RX_SRVCALL_POOLTAG)
#define RX_V_NETROOT_PARAMS_POOLTAG RX_DEFINE_POOLTAG('pVxR',RX_V_NETROOT_POOLTAG)
#define RX_TIMER_POOLTAG          RX_DEFINE_POOLTAG('mTxR',RX_MISC_POOLTAG)
#define RX_DIRCTL_POOLTAG         RX_DEFINE_POOLTAG('cDxR',RX_MISC_POOLTAG)

#define RXCE_MISC_POOLTAG         RX_DEFINE_POOLTAG('xCxR',RX_MISC_POOLTAG)
#define RXCE_MIDATLAS_POOLTAG     RX_DEFINE_POOLTAG('aMxR',RX_MISC_POOLTAG)

#endif _RXPOOLTG_H_


#elif (NTDDI_VERSION >= NTDDI_WINXP)

/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    rxpooltg.h

Abstract:

    The global pool tag definitions for RDBSS

Author:
Revision History:

   This file contains all the pool tag definitions related to the SMB mini redirector.
   The mechanism is intended to balance the number of pool tags to be used with the
   total number of tags available in the system.

   By specifying special flags the total number of tags consumed by the mini redirector
   can be controlled.

--*/

#ifndef _RXPOOLTG_H_
#define _RXPOOLTG_H_


#define RX_SRVCALL_POOLTAG      ('cSxR')
#define RX_NETROOT_POOLTAG      ('rNxR')
#define RX_V_NETROOT_POOLTAG    ('nVxR')
#define RX_FCB_POOLTAG          ('cFxR')
#define RX_SRVOPEN_POOLTAG      ('oSxR')
#define RX_FOBX_POOLTAG         ('xFxR')
#define RX_NONPAGEDFCB_POOLTAG  ('fNxR')
#define RX_WORKQ_POOLTAG        ('qWxR')
#define RX_BUFFERING_MANAGER_POOLTAG ('mBxR')
#define RX_MISC_POOLTAG         ('sMxR')
#define RX_IRPC_POOLTAG         ('rIxR')
#define RX_MRX_POOLTAG          ('xMxR')
#define RX_NAME_CACHE_POOLTAG   ('cNxR')
#define RX_BUFFERED_LOCK_POOLTAG ('kLxR')

#define RXCE_TRANSPORT_POOLTAG  ('tCxR')
#define RXCE_ADDRESS_POOLTAG    ('aCxR')
#define RXCE_CONNECTION_POOLTAG ('cCxR')
#define RXCE_VC_POOLTAG         ('vCxR')
#define RXCE_TDI_POOLTAG        ('dCxR')

extern ULONG RxExplodePoolTags;

#define RX_DEFINE_POOLTAG(ExplodedPoolTag,DefaultPoolTag)  \
        ((RxExplodePoolTags == 0) ? (DefaultPoolTag) : (ExplodedPoolTag))

#define RX_SRVCALL_PARAMS_POOLTAG   RX_DEFINE_POOLTAG('pSxR',RX_SRVCALL_POOLTAG)
#define RX_V_NETROOT_PARAMS_POOLTAG RX_DEFINE_POOLTAG('pVxR',RX_V_NETROOT_POOLTAG)
#define RX_TIMER_POOLTAG          RX_DEFINE_POOLTAG('mTxR',RX_MISC_POOLTAG)
#define RX_DIRCTL_POOLTAG         RX_DEFINE_POOLTAG('cDxR',RX_MISC_POOLTAG)

#define RXCE_MISC_POOLTAG         RX_DEFINE_POOLTAG('xCxR',RX_MISC_POOLTAG)
#define RXCE_MIDATLAS_POOLTAG     RX_DEFINE_POOLTAG('aMxR',RX_MISC_POOLTAG)

#endif _RXPOOLTG_H_


#elif (NTDDI_VERSION >= NTDDI_WIN2K)

/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    rxpooltg.h

Abstract:

    The global pool tag definitions for RDBSS

Author:
Revision History:

   This file contains all the pool tag definitions related to the SMB mini redirector.
   The mechanism is intended to balance the number of pool tags to be used with the
   total number of tags available in the system.

   By specifying special flags the total number of tags consumed by the mini redirector
   can be controlled.

--*/

#ifndef _RXPOOLTG_H_
#define _RXPOOLTG_H_


#define RX_SRVCALL_POOLTAG      ('cSxR')
#define RX_NETROOT_POOLTAG      ('rNxR')
#define RX_V_NETROOT_POOLTAG    ('nVxR')
#define RX_FCB_POOLTAG          ('cFxR')
#define RX_SRVOPEN_POOLTAG      ('oSxR')
#define RX_FOBX_POOLTAG         ('xFxR')
#define RX_NONPAGEDFCB_POOLTAG  ('fNxR')
#define RX_WORKQ_POOLTAG        ('qWxR')
#define RX_BUFFERING_MANAGER_POOLTAG ('mBxR')
#define RX_MISC_POOLTAG         ('sMxR')
#define RX_IRPC_POOLTAG         ('rIxR')
#define RX_MRX_POOLTAG          ('xMxR')
#define RX_NAME_CACHE_POOLTAG   ('cNxR')

#define RXCE_TRANSPORT_POOLTAG  ('tCxR')
#define RXCE_ADDRESS_POOLTAG    ('aCxR')
#define RXCE_CONNECTION_POOLTAG ('cCxR')
#define RXCE_VC_POOLTAG         ('vCxR')
#define RXCE_TDI_POOLTAG        ('dCxR')

extern ULONG RxExplodePoolTags;

#define RX_DEFINE_POOLTAG(ExplodedPoolTag,DefaultPoolTag)  \
        ((RxExplodePoolTags == 0) ? (DefaultPoolTag) : (ExplodedPoolTag))

#define RX_SRVCALL_PARAMS_POOLTAG   RX_DEFINE_POOLTAG('pSxR',RX_SRVCALL_POOLTAG)
#define RX_V_NETROOT_PARAMS_POOLTAG RX_DEFINE_POOLTAG('pVxR',RX_V_NETROOT_POOLTAG)
#define RX_TIMER_POOLTAG          RX_DEFINE_POOLTAG('mTxR',RX_MISC_POOLTAG)
#define RX_DIRCTL_POOLTAG         RX_DEFINE_POOLTAG('cDxR',RX_MISC_POOLTAG)

#define RXCE_MISC_POOLTAG         RX_DEFINE_POOLTAG('xCxR',RX_MISC_POOLTAG)
#define RXCE_MIDATLAS_POOLTAG     RX_DEFINE_POOLTAG('aMxR',RX_MISC_POOLTAG)

#endif _RXPOOLTG_H_


#else /* NTDDI_VERSION */

#error This file cannot be included for this NTDDI_VERSION.

#endif /* NTDDI_VERSION */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\rxtrace.h ===
#if !defined(NTDDI_VERSION)

#error NTDDI_VERSION must be defined to include this file.

#elif (NTDDI_VERSION >= NTDDI_VISTA)

/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    rxtrace.h

Abstract:

    This module defines the macros which provide debugging support ( tracing ).

Author:
Revision History:

--*/

#ifndef _RDBSSTRACE_INCLUDED_
#define _RDBSSTRACE_INCLUDED_

#if !DBG
#undef RDBSSTRACE
#endif // !DBG

typedef struct _DEBUG_TRACE_CONTROLPOINT{
    ULONG ControlPointNumber;
    PSZ Name;
} DEBUG_TRACE_CONTROLPOINT, *PDEBUG_TRACE_CONTROLPOINT;

typedef struct {
    LONG PrintLevel;
    ULONG BreakMask;
    PSZ   Name;
} RX_DEBUG_TRACE_CONTROL, *PRX_DEBUG_TRACE_CONTROL;


#ifdef RDBSSTRACE

//define so that &RX_DEBUG_TRACE_CONTROL is NULL
typedef struct {
    RX_DEBUG_TRACE_CONTROL Junk;
} rxrxrx_AlwaysHelper;


#define RX_DEBUG_TRACE_ALWAYS  (((rxrxrx_AlwaysHelper*)0)->Junk)

// The following macros provide fine grained control for selectively enabling
// and disabling tracing.

#define RXDT_Extern(__x) extern DEBUG_TRACE_CONTROLPOINT RX_DEBUG_TRACE_##__x
#define RXDT_DeclareCategory(__x) extern DEBUG_TRACE_CONTROLPOINT RX_DEBUG_TRACE_##__x
#define RXDT_DefineCategory(__x)  DEBUG_TRACE_CONTROLPOINT RX_DEBUG_TRACE_##__x = {0,#__x}

RXDT_Extern(ERROR);
RXDT_Extern(HOOKS);
RXDT_Extern(CATCH_EXCEPTIONS);
RXDT_Extern(UNWIND);
RXDT_Extern(CLEANUP);
RXDT_Extern(CLOSE);
RXDT_Extern(CREATE);
RXDT_Extern(DIRCTRL);
RXDT_Extern(EA);
RXDT_Extern(FILEINFO);
RXDT_Extern(FSCTRL);
RXDT_Extern(LOCKCTRL);
RXDT_Extern(READ);
RXDT_Extern(VOLINFO);
RXDT_Extern(WRITE);
RXDT_Extern(FLUSH);
RXDT_Extern(DEVCTRL);
RXDT_Extern(SHUTDOWN);
RXDT_Extern(PREFIX);
RXDT_Extern(DEVFCB);
RXDT_Extern(ACCHKSUP);
RXDT_Extern(ALLOCSUP);
RXDT_Extern(DIRSUP);
RXDT_Extern(FILOBSUP);
RXDT_Extern(NAMESUP);
RXDT_Extern(VERFYSUP);
RXDT_Extern(CACHESUP);
RXDT_Extern(SPLAYSUP);
RXDT_Extern(DEVIOSUP);
RXDT_Extern(FCBSTRUCTS);
RXDT_Extern(STRUCSUP);
RXDT_Extern(FSP_DISPATCHER);
RXDT_Extern(FSP_DUMP);
RXDT_Extern(RXCONTX);
RXDT_Extern(DISPATCH);
RXDT_Extern(NTFASTIO);
RXDT_Extern(LOWIO);
RXDT_Extern(MINIRDR);
RXDT_Extern(DISCCODE);  //for the browser interface stuff
RXDT_Extern(BROWSER);
RXDT_Extern(CONNECT);
RXDT_Extern(NTTIMER);
RXDT_Extern(SCAVTHRD);
RXDT_Extern(SCAVENGER);
RXDT_Extern(SHAREACCESS);
RXDT_Extern(NAMECACHE);

//connection engines categories

RXDT_Extern(RXCEBINDING);
RXDT_Extern(RXCEDBIMPLEMENTATION);
RXDT_Extern(RXCEMANAGEMENT);
RXDT_Extern(RXCEXMIT);
RXDT_Extern(RXCEPOOL);
RXDT_Extern(RXCETDI);

#else //RDBSSTRACE

#define RXDT_Extern(__x)
#define RXDT_DeclareCategory(__x)
#define RXDT_DefineCategory(__x)

#endif //RDBSSTRACE

#ifdef RDBSSTRACE
extern BOOLEAN RxGlobalTraceSuppress, RxNextGlobalTraceSuppress;
extern ULONG RxGlobalTraceIrpCount;
VOID RxInitializeDebugTrace(void);
#define RxDbgTraceDoit(___x) ___x

#ifndef MINIRDR__NAME
extern LONG RxDebugTraceIndent;
#else
#define RxDebugTraceIndent (*(*___MINIRDR_IMPORTS_NAME).pRxDebugTraceIndent)
#endif

#else

#define RxInitializeDebugTrace()
#define RxDbgTraceDoit(___x)

#endif //RDBSSTRACE



#if DBG

#define RxDT_INDENT_EXCESS 16 //this is the offset for excess-n for the indent
#define RxDT_INDENT_SHIFT 20
#define RxDT_INDENT_MASK  0x3f
#define RxDT_LEVEL_MASK ((1<<RxDT_INDENT_SHIFT)-1)
#define RxDT_SUPPRESS_PRINT  0x80000000
#define RxDT_OVERRIDE_RETURN 0x40000000


// The implementation details of the tracing feature.

VOID
RxDebugTraceActual (
    IN ULONG NewMask,
    IN PCH Format,
    ...
    );

BOOLEAN
RxDbgTraceActualNew (
    IN ULONG NewMask,
    IN OUT PDEBUG_TRACE_CONTROLPOINT ControlPoint
    );

PRX_DEBUG_TRACE_CONTROL
RxDbgTraceFindControlPointActual(
    IN OUT PDEBUG_TRACE_CONTROLPOINT ControlPoint
    );

VOID
RxInitializeDebugTraceControlPoint(
    PSZ Name,
    PDEBUG_TRACE_CONTROLPOINT ControlPoint
    );

extern PCHAR RxIrpCodeToName[];

#endif  //DBG

#ifdef RDBSSTRACE
BOOLEAN
RxDbgTraceDisableGlobally(void);

VOID
RxDbgTraceEnableGlobally(BOOLEAN flag);

VOID
RxDebugTraceDebugCommand(
    PSZ name,
    ULONG level,
    ULONG pointcount
    );

VOID
RxDebugTraceZeroAllPrintLevels(
    void
    );

extern ULONG rdbsstracemarker;

#define RxDTMASK(INDENT,WRITELEVEL) \
         ( (((INDENT)+RxDT_INDENT_EXCESS)<<RxDT_INDENT_SHIFT) + ((WRITELEVEL)&RxDT_LEVEL_MASK))

#define RxDTPrefixRx(___x) RX_##___x

#define RxDbgTraceLV__norx_reverseaction(INDENT,CONTROLPOINT,LEVEL,Z) \
        {BOOLEAN PrintIt = RxDbgTraceActualNew((RxDT_SUPPRESS_PRINT | RxDT_OVERRIDE_RETURN | RxDTMASK((INDENT),(LEVEL))),\
                                               (CONTROLPOINT)); \
         if (!PrintIt) Z;                    \
        }

#define RxDbgTraceLV__norx(INDENT,CONTROLPOINT,LEVEL,Z) \
        {BOOLEAN PrintIt = RxDbgTraceActualNew( RxDTMASK((INDENT),(LEVEL)),(CONTROLPOINT)); \
         if (PrintIt) DbgPrint Z;                    \
        }

#define RxDbgTraceLVUnIndent__norx(INDENT,CONTROLPOINT,LEVEL) \
        {BOOLEAN PrintIt = RxDbgTraceActualNew((RxDT_SUPPRESS_PRINT | RxDTMASK((INDENT),(LEVEL))),(CONTROLPOINT)); \
        }

#define RxDbgTraceLV__(INDENT,CONTROLPOINT,LEVEL,Z) \
        RxDbgTraceLV__norx(INDENT,(&RxDTPrefixRx##CONTROLPOINT),LEVEL,Z)

#define RxDbgTraceLVUnIndent__(INDENT,CONTROLPOINT,LEVEL) \
        RxDbgTraceLVUnIndent__norx(INDENT,(&RxDTPrefixRx##CONTROLPOINT),LEVEL)

#define RxDbgTrace(INDENT,CONTROLPOINT,Z) \
             RxDbgTraceLV__(INDENT,CONTROLPOINT,1,Z) \

#define RxDbgTraceLV(INDENT,CONTROLPOINT,LEVEL,Z) \
             RxDbgTraceLV__(INDENT,CONTROLPOINT,LEVEL,Z) \

#define RxDbgTraceUnIndent(INDENT,CONTROLPOINT) \
             RxDbgTraceLVUnIndent__(INDENT,CONTROLPOINT,1)

// do not define this for nonrdbsstrace; so to catch references not ifdef'd
#define RxDbgTraceFindControlPoint(CONTROLPOINT) (RxDbgTraceFindControlPointActual(&RxDTPrefixRx##CONTROLPOINT))


#define DebugBreakPoint(CONTROLPOINT,MASKBIT) {           \
    if (((MASKBIT) == 0)                                     \
         || (RxDbgTraceFindControlPoint(CONTROLPOINT)->BreakMask & (1<<((MASKBIT)-1)) )) { \
        DbgBreakPoint();                                     \
    }                                                        \
}

#define DebugUnwind(X) {                                                      \
    if (AbnormalTermination()) {                                              \
        RxDbgTrace(0, (DEBUG_TRACE_UNWIND), ( #X ", Abnormal termination.\n", 0)); \
    }                                                                         \
}

#ifdef RX_PERFPORMANCE_TIMER
extern LONG RxPerformanceTimerLevel;

#define TimerStart(LEVEL) {                     \
    LARGE_INTEGER TStart, TEnd;                 \
    LARGE_INTEGER TElapsed;                     \
    TStart = KeQueryPerformanceCounter( NULL ); \

#define TimerStop(LEVEL,s)                                    \
    TEnd = KeQueryPerformanceCounter( NULL );                 \
    TElapsed.QuadPart = TEnd.QuadPart - TStart.QuadPart;      \
    RxTotalTicks[RxLogOf(LEVEL)] += TElapsed.LowPart;       \
    if (FlagOn( RxPerformanceTimerLevel, (LEVEL))) {         \
        DbgPrint("Time of %s %ld\n", (s), TElapsed.LowPart ); \
    }                                                         \
}
#endif //RX_PERFPORMANCE_TIMER

#else  // RDBSSTRACE

#define RxDbgTraceLV__norx_reverseaction(INDENT,CONTROLPOINT,LEVEL,Z)      {NOTHING;}
#define RxDbgTraceLV(INDENT,CONTROLPOINTNUM,LEVEL,Z)     {NOTHING;}
#define RxDbgTraceLVUnIndent(INDENT,CONTROLPOINTNUM,LEVEL)     {NOTHING;}
#define RxDbgTrace(INDENT,CONTROLPOINTNUM,Z)     {NOTHING;}
#define RxDbgTraceUnIndent(INDENT,CONTROLPOINTNUM)     {NOTHING;}
#define DebugBreakPoint(CONTROLPOINTNUM,MASKBIT) {NOTHING;}
#define DebugUnwind(X)                   {NOTHING;}
#define RxDbgTraceDisableGlobally() FALSE
#define RxDbgTraceEnableGlobally(f) {NOTHING;}

#ifdef RX_PERFPORMANCE_TIMER
#define TimerStart(LEVEL)
#define TimerStop(LEVEL,s)
#endif

#endif // RDBSSTRACE


#endif // _RDBSSTRACE_INCLUDED_


#elif (NTDDI_VERSION >= NTDDI_WS03)

/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    rxtrace.h

Abstract:

    This module defines the macros which provide debugging support ( tracing ).

Author:
Revision History:

--*/

#ifndef _RDBSSTRACE_INCLUDED_
#define _RDBSSTRACE_INCLUDED_

#if !DBG
#undef RDBSSTRACE
#endif // !DBG

typedef struct _DEBUG_TRACE_CONTROLPOINT{
    ULONG ControlPointNumber;
    PSZ Name;
} DEBUG_TRACE_CONTROLPOINT, *PDEBUG_TRACE_CONTROLPOINT;

typedef struct {
    LONG PrintLevel;
    ULONG BreakMask;
    PSZ   Name;
} RX_DEBUG_TRACE_CONTROL, *PRX_DEBUG_TRACE_CONTROL;


#ifdef RDBSSTRACE

//define so that &RX_DEBUG_TRACE_CONTROL is NULL
typedef struct {
    RX_DEBUG_TRACE_CONTROL Junk;
} rxrxrx_AlwaysHelper;


#define RX_DEBUG_TRACE_ALWAYS  (((rxrxrx_AlwaysHelper*)0)->Junk)

// The following macros provide fine grained control for selectively enabling
// and disabling tracing.

#define RXDT_Extern(__x) extern DEBUG_TRACE_CONTROLPOINT RX_DEBUG_TRACE_##__x
#define RXDT_DeclareCategory(__x) extern DEBUG_TRACE_CONTROLPOINT RX_DEBUG_TRACE_##__x
#define RXDT_DefineCategory(__x)  DEBUG_TRACE_CONTROLPOINT RX_DEBUG_TRACE_##__x = {0,#__x}

RXDT_Extern(ERROR);
RXDT_Extern(HOOKS);
RXDT_Extern(CATCH_EXCEPTIONS);
RXDT_Extern(UNWIND);
RXDT_Extern(CLEANUP);
RXDT_Extern(CLOSE);
RXDT_Extern(CREATE);
RXDT_Extern(DIRCTRL);
RXDT_Extern(EA);
RXDT_Extern(FILEINFO);
RXDT_Extern(FSCTRL);
RXDT_Extern(LOCKCTRL);
RXDT_Extern(READ);
RXDT_Extern(VOLINFO);
RXDT_Extern(WRITE);
RXDT_Extern(FLUSH);
RXDT_Extern(DEVCTRL);
RXDT_Extern(SHUTDOWN);
RXDT_Extern(PREFIX);
RXDT_Extern(DEVFCB);
RXDT_Extern(ACCHKSUP);
RXDT_Extern(ALLOCSUP);
RXDT_Extern(DIRSUP);
RXDT_Extern(FILOBSUP);
RXDT_Extern(NAMESUP);
RXDT_Extern(VERFYSUP);
RXDT_Extern(CACHESUP);
RXDT_Extern(SPLAYSUP);
RXDT_Extern(DEVIOSUP);
RXDT_Extern(FCBSTRUCTS);
RXDT_Extern(STRUCSUP);
RXDT_Extern(FSP_DISPATCHER);
RXDT_Extern(FSP_DUMP);
RXDT_Extern(RXCONTX);
RXDT_Extern(DISPATCH);
RXDT_Extern(NTFASTIO);
RXDT_Extern(LOWIO);
RXDT_Extern(MINIRDR);
RXDT_Extern(DISCCODE);  //for the browser interface stuff
RXDT_Extern(BROWSER);
RXDT_Extern(CONNECT);
RXDT_Extern(NTTIMER);
RXDT_Extern(SCAVTHRD);
RXDT_Extern(SCAVENGER);
RXDT_Extern(SHAREACCESS);
RXDT_Extern(NAMECACHE);

//connection engines categories

RXDT_Extern(RXCEBINDING);
RXDT_Extern(RXCEDBIMPLEMENTATION);
RXDT_Extern(RXCEMANAGEMENT);
RXDT_Extern(RXCEXMIT);
RXDT_Extern(RXCEPOOL);
RXDT_Extern(RXCETDI);

#else //RDBSSTRACE

#define RXDT_Extern(__x)
#define RXDT_DeclareCategory(__x)
#define RXDT_DefineCategory(__x)

#endif //RDBSSTRACE

#ifdef RDBSSTRACE
extern BOOLEAN RxGlobalTraceSuppress, RxNextGlobalTraceSuppress;
extern ULONG RxGlobalTraceIrpCount;
VOID RxInitializeDebugTrace(void);
#define RxDbgTraceDoit(___x) ___x

#ifndef MINIRDR__NAME
extern LONG RxDebugTraceIndent;
#else
#define RxDebugTraceIndent (*(*___MINIRDR_IMPORTS_NAME).pRxDebugTraceIndent)
#endif

#else

#define RxInitializeDebugTrace()
#define RxDbgTraceDoit(___x)

#endif //RDBSSTRACE



#if DBG

#define RxDT_INDENT_EXCESS 16 //this is the offset for excess-n for the indent
#define RxDT_INDENT_SHIFT 20
#define RxDT_INDENT_MASK  0x3f
#define RxDT_LEVEL_MASK ((1<<RxDT_INDENT_SHIFT)-1)
#define RxDT_SUPPRESS_PRINT  0x80000000
#define RxDT_OVERRIDE_RETURN 0x40000000


// The implementation details of the tracing feature.

VOID
RxDebugTraceActual (
    IN ULONG NewMask,
    IN PCH Format,
    ...
    );

BOOLEAN
RxDbgTraceActualNew (
    IN ULONG NewMask,
    IN OUT PDEBUG_TRACE_CONTROLPOINT ControlPoint
    );

PRX_DEBUG_TRACE_CONTROL
RxDbgTraceFindControlPointActual(
    IN OUT PDEBUG_TRACE_CONTROLPOINT ControlPoint
    );

VOID
RxInitializeDebugTraceControlPoint(
    PSZ Name,
    PDEBUG_TRACE_CONTROLPOINT ControlPoint
    );

extern PCHAR RxIrpCodeToName[];

#endif  //DBG

#ifdef RDBSSTRACE
BOOLEAN
RxDbgTraceDisableGlobally(void);

VOID
RxDbgTraceEnableGlobally(BOOLEAN flag);

VOID
RxDebugTraceDebugCommand(
    PSZ name,
    ULONG level,
    ULONG pointcount
    );

VOID
RxDebugTraceZeroAllPrintLevels(
    void
    );

extern ULONG rdbsstracemarker;

#define RxDTMASK(INDENT,WRITELEVEL) \
         ( (((INDENT)+RxDT_INDENT_EXCESS)<<RxDT_INDENT_SHIFT) + ((WRITELEVEL)&RxDT_LEVEL_MASK))

#define RxDTPrefixRx(___x) RX_##___x

#define RxDbgTraceLV__norx_reverseaction(INDENT,CONTROLPOINT,LEVEL,Z) \
        {BOOLEAN PrintIt = RxDbgTraceActualNew((RxDT_SUPPRESS_PRINT | RxDT_OVERRIDE_RETURN | RxDTMASK((INDENT),(LEVEL))),\
                                               (CONTROLPOINT)); \
         if (!PrintIt) Z;                    \
        }

#define RxDbgTraceLV__norx(INDENT,CONTROLPOINT,LEVEL,Z) \
        {BOOLEAN PrintIt = RxDbgTraceActualNew( RxDTMASK((INDENT),(LEVEL)),(CONTROLPOINT)); \
         if (PrintIt) DbgPrint Z;                    \
        }

#define RxDbgTraceLVUnIndent__norx(INDENT,CONTROLPOINT,LEVEL) \
        {BOOLEAN PrintIt = RxDbgTraceActualNew((RxDT_SUPPRESS_PRINT | RxDTMASK((INDENT),(LEVEL))),(CONTROLPOINT)); \
        }

#define RxDbgTraceLV__(INDENT,CONTROLPOINT,LEVEL,Z) \
        RxDbgTraceLV__norx(INDENT,(&RxDTPrefixRx##CONTROLPOINT),LEVEL,Z)

#define RxDbgTraceLVUnIndent__(INDENT,CONTROLPOINT,LEVEL) \
        RxDbgTraceLVUnIndent__norx(INDENT,(&RxDTPrefixRx##CONTROLPOINT),LEVEL)

#define RxDbgTrace(INDENT,CONTROLPOINT,Z) \
             RxDbgTraceLV__(INDENT,CONTROLPOINT,1,Z) \

#define RxDbgTraceLV(INDENT,CONTROLPOINT,LEVEL,Z) \
             RxDbgTraceLV__(INDENT,CONTROLPOINT,LEVEL,Z) \

#define RxDbgTraceUnIndent(INDENT,CONTROLPOINT) \
             RxDbgTraceLVUnIndent__(INDENT,CONTROLPOINT,1)

// do not define this for nonrdbsstrace; so to catch references not ifdef'd
#define RxDbgTraceFindControlPoint(CONTROLPOINT) (RxDbgTraceFindControlPointActual(&RxDTPrefixRx##CONTROLPOINT))


#define DebugBreakPoint(CONTROLPOINT,MASKBIT) {           \
    if (((MASKBIT) == 0)                                     \
         || (RxDbgTraceFindControlPoint(CONTROLPOINT)->BreakMask & (1<<((MASKBIT)-1)) )) { \
        DbgBreakPoint();                                     \
    }                                                        \
}

#define DebugUnwind(X) {                                                      \
    if (AbnormalTermination()) {                                              \
        RxDbgTrace(0, (DEBUG_TRACE_UNWIND), ( #X ", Abnormal termination.\n", 0)); \
    }                                                                         \
}

#ifdef RX_PERFPORMANCE_TIMER
extern LONG RxPerformanceTimerLevel;

#define TimerStart(LEVEL) {                     \
    LARGE_INTEGER TStart, TEnd;                 \
    LARGE_INTEGER TElapsed;                     \
    TStart = KeQueryPerformanceCounter( NULL ); \

#define TimerStop(LEVEL,s)                                    \
    TEnd = KeQueryPerformanceCounter( NULL );                 \
    TElapsed.QuadPart = TEnd.QuadPart - TStart.QuadPart;      \
    RxTotalTicks[RxLogOf(LEVEL)] += TElapsed.LowPart;       \
    if (FlagOn( RxPerformanceTimerLevel, (LEVEL))) {         \
        DbgPrint("Time of %s %ld\n", (s), TElapsed.LowPart ); \
    }                                                         \
}
#endif //RX_PERFPORMANCE_TIMER

#else  // RDBSSTRACE

#define RxDbgTraceLV__norx_reverseaction(INDENT,CONTROLPOINT,LEVEL,Z)      {NOTHING;}
#define RxDbgTraceLV(INDENT,CONTROLPOINTNUM,LEVEL,Z)     {NOTHING;}
#define RxDbgTraceLVUnIndent(INDENT,CONTROLPOINTNUM,LEVEL)     {NOTHING;}
#define RxDbgTrace(INDENT,CONTROLPOINTNUM,Z)     {NOTHING;}
#define RxDbgTraceUnIndent(INDENT,CONTROLPOINTNUM)     {NOTHING;}
#define DebugBreakPoint(CONTROLPOINTNUM,MASKBIT) {NOTHING;}
#define DebugUnwind(X)                   {NOTHING;}
#define RxDbgTraceDisableGlobally() FALSE
#define RxDbgTraceEnableGlobally(f) {NOTHING;}

#ifdef RX_PERFPORMANCE_TIMER
#define TimerStart(LEVEL)
#define TimerStop(LEVEL,s)
#endif

#endif // RDBSSTRACE


#endif // _RDBSSTRACE_INCLUDED_



#elif (NTDDI_VERSION >= NTDDI_WINXP)

/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    rxtrace.h

Abstract:

    This module defines the macros which provide debugging support ( tracing ).

Author:
Revision History:

--*/

#ifndef _RDBSSTRACE_INCLUDED_
#define _RDBSSTRACE_INCLUDED_

#if !DBG
#undef RDBSSTRACE
#endif // !DBG

typedef struct _DEBUG_TRACE_CONTROLPOINT{
    ULONG ControlPointNumber;
    PSZ Name;
} DEBUG_TRACE_CONTROLPOINT, *PDEBUG_TRACE_CONTROLPOINT;

typedef struct {
    LONG PrintLevel;
    ULONG BreakMask;
    PSZ   Name;
} RX_DEBUG_TRACE_CONTROL, *PRX_DEBUG_TRACE_CONTROL;


#ifdef RDBSSTRACE

//define so that &RX_DEBUG_TRACE_CONTROL is NULL
typedef struct {
    RX_DEBUG_TRACE_CONTROL Junk;
} rxrxrx_AlwaysHelper;


#define RX_DEBUG_TRACE_ALWAYS  (((rxrxrx_AlwaysHelper*)0)->Junk)

// The following macros provide fine grained control for selectively enabling
// and disabling tracing.

#define RXDT_Extern(__x) extern DEBUG_TRACE_CONTROLPOINT RX_DEBUG_TRACE_##__x
#define RXDT_DeclareCategory(__x) extern DEBUG_TRACE_CONTROLPOINT RX_DEBUG_TRACE_##__x
#define RXDT_DefineCategory(__x)  DEBUG_TRACE_CONTROLPOINT RX_DEBUG_TRACE_##__x = {0,#__x}

RXDT_Extern(ERROR);
RXDT_Extern(HOOKS);
RXDT_Extern(CATCH_EXCEPTIONS);
RXDT_Extern(UNWIND);
RXDT_Extern(CLEANUP);
RXDT_Extern(CLOSE);
RXDT_Extern(CREATE);
RXDT_Extern(DIRCTRL);
RXDT_Extern(EA);
RXDT_Extern(FILEINFO);
RXDT_Extern(FSCTRL);
RXDT_Extern(LOCKCTRL);
RXDT_Extern(READ);
RXDT_Extern(VOLINFO);
RXDT_Extern(WRITE);
RXDT_Extern(FLUSH);
RXDT_Extern(DEVCTRL);
RXDT_Extern(SHUTDOWN);
RXDT_Extern(PREFIX);
RXDT_Extern(DEVFCB);
RXDT_Extern(ACCHKSUP);
RXDT_Extern(ALLOCSUP);
RXDT_Extern(DIRSUP);
RXDT_Extern(FILOBSUP);
RXDT_Extern(NAMESUP);
RXDT_Extern(VERFYSUP);
RXDT_Extern(CACHESUP);
RXDT_Extern(SPLAYSUP);
RXDT_Extern(DEVIOSUP);
RXDT_Extern(FCBSTRUCTS);
RXDT_Extern(STRUCSUP);
RXDT_Extern(FSP_DISPATCHER);
RXDT_Extern(FSP_DUMP);
RXDT_Extern(RXCONTX);
RXDT_Extern(DISPATCH);
RXDT_Extern(NTFASTIO);
RXDT_Extern(LOWIO);
RXDT_Extern(MINIRDR);
RXDT_Extern(DISCCODE);  //for the browser interface stuff
RXDT_Extern(BROWSER);
RXDT_Extern(CONNECT);
RXDT_Extern(NTTIMER);
RXDT_Extern(SCAVTHRD);
RXDT_Extern(SCAVENGER);
RXDT_Extern(SHAREACCESS);
RXDT_Extern(NAMECACHE);

//connection engines categories

RXDT_Extern(RXCEBINDING);
RXDT_Extern(RXCEDBIMPLEMENTATION);
RXDT_Extern(RXCEMANAGEMENT);
RXDT_Extern(RXCEXMIT);
RXDT_Extern(RXCEPOOL);
RXDT_Extern(RXCETDI);

#else //RDBSSTRACE

#define RXDT_Extern(__x)
#define RXDT_DeclareCategory(__x)
#define RXDT_DefineCategory(__x)

#endif //RDBSSTRACE

#ifdef RDBSSTRACE
extern BOOLEAN RxGlobalTraceSuppress, RxNextGlobalTraceSuppress;
extern ULONG RxGlobalTraceIrpCount;
VOID RxInitializeDebugTrace(void);
#define RxDbgTraceDoit(___x) ___x

#ifndef MINIRDR__NAME
extern LONG RxDebugTraceIndent;
#else
#define RxDebugTraceIndent (*(*___MINIRDR_IMPORTS_NAME).pRxDebugTraceIndent)
#endif

#else

#define RxInitializeDebugTrace()
#define RxDbgTraceDoit(___x)

#endif //RDBSSTRACE



#if DBG

#define RxDT_INDENT_EXCESS 16 //this is the offset for excess-n for the indent
#define RxDT_INDENT_SHIFT 20
#define RxDT_INDENT_MASK  0x3f
#define RxDT_LEVEL_MASK ((1<<RxDT_INDENT_SHIFT)-1)
#define RxDT_SUPPRESS_PRINT  0x80000000
#define RxDT_OVERRIDE_RETURN 0x40000000


// The implementation details of the tracing feature.

VOID
RxDebugTraceActual (
    IN ULONG NewMask,
    IN PCH Format,
    ...
    );

BOOLEAN
RxDbgTraceActualNew (
    IN ULONG NewMask,
    IN OUT PDEBUG_TRACE_CONTROLPOINT ControlPoint
    );

PRX_DEBUG_TRACE_CONTROL
RxDbgTraceFindControlPointActual(
    IN OUT PDEBUG_TRACE_CONTROLPOINT ControlPoint
    );

VOID
RxInitializeDebugTraceControlPoint(
    PSZ Name,
    PDEBUG_TRACE_CONTROLPOINT ControlPoint
    );

extern PCHAR RxIrpCodeToName[];

#endif  //DBG

#ifdef RDBSSTRACE
BOOLEAN
RxDbgTraceDisableGlobally(void);

VOID
RxDbgTraceEnableGlobally(BOOLEAN flag);

VOID
RxDebugTraceDebugCommand(
    PSZ name,
    ULONG level,
    ULONG pointcount
    );

VOID
RxDebugTraceZeroAllPrintLevels(
    void
    );

extern ULONG rdbsstracemarker;

#define RxDTMASK(INDENT,WRITELEVEL) \
         ( (((INDENT)+RxDT_INDENT_EXCESS)<<RxDT_INDENT_SHIFT) + ((WRITELEVEL)&RxDT_LEVEL_MASK))

#define RxDTPrefixRx(___x) RX_##___x

#define RxDbgTraceLV__norx_reverseaction(INDENT,CONTROLPOINT,LEVEL,Z) \
        {BOOLEAN PrintIt = RxDbgTraceActualNew((RxDT_SUPPRESS_PRINT | RxDT_OVERRIDE_RETURN | RxDTMASK((INDENT),(LEVEL))),\
                                               (CONTROLPOINT)); \
         if (!PrintIt) Z;                    \
        }

#define RxDbgTraceLV__norx(INDENT,CONTROLPOINT,LEVEL,Z) \
        {BOOLEAN PrintIt = RxDbgTraceActualNew( RxDTMASK((INDENT),(LEVEL)),(CONTROLPOINT)); \
         if (PrintIt) DbgPrint Z;                    \
        }

#define RxDbgTraceLVUnIndent__norx(INDENT,CONTROLPOINT,LEVEL) \
        {BOOLEAN PrintIt = RxDbgTraceActualNew((RxDT_SUPPRESS_PRINT | RxDTMASK((INDENT),(LEVEL))),(CONTROLPOINT)); \
        }

#define RxDbgTraceLV__(INDENT,CONTROLPOINT,LEVEL,Z) \
        RxDbgTraceLV__norx(INDENT,(&RxDTPrefixRx##CONTROLPOINT),LEVEL,Z)

#define RxDbgTraceLVUnIndent__(INDENT,CONTROLPOINT,LEVEL) \
        RxDbgTraceLVUnIndent__norx(INDENT,(&RxDTPrefixRx##CONTROLPOINT),LEVEL)

#define RxDbgTrace(INDENT,CONTROLPOINT,Z) \
             RxDbgTraceLV__(INDENT,CONTROLPOINT,1,Z) \

#define RxDbgTraceLV(INDENT,CONTROLPOINT,LEVEL,Z) \
             RxDbgTraceLV__(INDENT,CONTROLPOINT,LEVEL,Z) \

#define RxDbgTraceUnIndent(INDENT,CONTROLPOINT) \
             RxDbgTraceLVUnIndent__(INDENT,CONTROLPOINT,1)

// do not define this for nonrdbsstrace; so to catch references not ifdef'd
#define RxDbgTraceFindControlPoint(CONTROLPOINT) (RxDbgTraceFindControlPointActual(&RxDTPrefixRx##CONTROLPOINT))


#define DebugBreakPoint(CONTROLPOINT,MASKBIT) {           \
    if (((MASKBIT) == 0)                                     \
         || (RxDbgTraceFindControlPoint(CONTROLPOINT)->BreakMask & (1<<((MASKBIT)-1)) )) { \
        DbgBreakPoint();                                     \
    }                                                        \
}

#define DebugUnwind(X) {                                                      \
    if (AbnormalTermination()) {                                              \
        RxDbgTrace(0, (DEBUG_TRACE_UNWIND), ( #X ", Abnormal termination.\n", 0)); \
    }                                                                         \
}

#ifdef RX_PERFPORMANCE_TIMER
extern LONG RxPerformanceTimerLevel;

#define TimerStart(LEVEL) {                     \
    LARGE_INTEGER TStart, TEnd;                 \
    LARGE_INTEGER TElapsed;                     \
    TStart = KeQueryPerformanceCounter( NULL ); \

#define TimerStop(LEVEL,s)                                    \
    TEnd = KeQueryPerformanceCounter( NULL );                 \
    TElapsed.QuadPart = TEnd.QuadPart - TStart.QuadPart;      \
    RxTotalTicks[RxLogOf(LEVEL)] += TElapsed.LowPart;       \
    if (FlagOn( RxPerformanceTimerLevel, (LEVEL))) {         \
        DbgPrint("Time of %s %ld\n", (s), TElapsed.LowPart ); \
    }                                                         \
}
#endif //RX_PERFPORMANCE_TIMER

#else  // RDBSSTRACE

#define RxDbgTraceLV__norx_reverseaction(INDENT,CONTROLPOINT,LEVEL,Z)      {NOTHING;}
#define RxDbgTraceLV(INDENT,CONTROLPOINTNUM,LEVEL,Z)     {NOTHING;}
#define RxDbgTraceLVUnIndent(INDENT,CONTROLPOINTNUM,LEVEL)     {NOTHING;}
#define RxDbgTrace(INDENT,CONTROLPOINTNUM,Z)     {NOTHING;}
#define RxDbgTraceUnIndent(INDENT,CONTROLPOINTNUM)     {NOTHING;}
#define DebugBreakPoint(CONTROLPOINTNUM,MASKBIT) {NOTHING;}
#define DebugUnwind(X)                   {NOTHING;}
#define RxDbgTraceDisableGlobally() FALSE
#define RxDbgTraceEnableGlobally(f) {NOTHING;}

#ifdef RX_PERFPORMANCE_TIMER
#define TimerStart(LEVEL)
#define TimerStop(LEVEL,s)
#endif

#endif // RDBSSTRACE


#endif // _RDBSSTRACE_INCLUDED_



#elif (NTDDI_VERSION >= NTDDI_WIN2K)

/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    rxtrace.h

Abstract:

    This module defines the macros which provide debugging support ( tracing ).

Author:
Revision History:

--*/

#ifndef _RDBSSTRACE_INCLUDED_
#define _RDBSSTRACE_INCLUDED_

#if !DBG
#undef RDBSSTRACE
#endif // !DBG

typedef struct _DEBUG_TRACE_CONTROLPOINT{
    ULONG ControlPointNumber;
    PSZ Name;
} DEBUG_TRACE_CONTROLPOINT, *PDEBUG_TRACE_CONTROLPOINT;

typedef struct {
    LONG PrintLevel;
    ULONG BreakMask;
    PSZ   Name;
} RX_DEBUG_TRACE_CONTROL, *PRX_DEBUG_TRACE_CONTROL;


#ifdef RDBSSTRACE

//define so that &RX_DEBUG_TRACE_CONTROL is NULL
typedef struct {
    RX_DEBUG_TRACE_CONTROL Junk;
} rxrxrx_AlwaysHelper;


#define RX_DEBUG_TRACE_ALWAYS  (((rxrxrx_AlwaysHelper*)0)->Junk)

// The following macros provide fine grained control for selectively enabling
// and disabling tracing.

#define RXDT_Extern(__x) extern DEBUG_TRACE_CONTROLPOINT RX_DEBUG_TRACE_##__x
#define RXDT_DeclareCategory(__x) extern DEBUG_TRACE_CONTROLPOINT RX_DEBUG_TRACE_##__x
#define RXDT_DefineCategory(__x)  DEBUG_TRACE_CONTROLPOINT RX_DEBUG_TRACE_##__x = {0,#__x}

RXDT_Extern(ERROR);
RXDT_Extern(HOOKS);
RXDT_Extern(CATCH_EXCEPTIONS);
RXDT_Extern(UNWIND);
RXDT_Extern(CLEANUP);
RXDT_Extern(CLOSE);
RXDT_Extern(CREATE);
RXDT_Extern(DIRCTRL);
RXDT_Extern(EA);
RXDT_Extern(FILEINFO);
RXDT_Extern(FSCTRL);
RXDT_Extern(LOCKCTRL);
RXDT_Extern(READ);
RXDT_Extern(VOLINFO);
RXDT_Extern(WRITE);
RXDT_Extern(FLUSH);
RXDT_Extern(DEVCTRL);
RXDT_Extern(SHUTDOWN);
RXDT_Extern(PREFIX);
RXDT_Extern(DEVFCB);
RXDT_Extern(ACCHKSUP);
RXDT_Extern(ALLOCSUP);
RXDT_Extern(DIRSUP);
RXDT_Extern(FILOBSUP);
RXDT_Extern(NAMESUP);
RXDT_Extern(VERFYSUP);
RXDT_Extern(CACHESUP);
RXDT_Extern(SPLAYSUP);
RXDT_Extern(DEVIOSUP);
RXDT_Extern(FCBSTRUCTS);
RXDT_Extern(STRUCSUP);
RXDT_Extern(FSP_DISPATCHER);
RXDT_Extern(FSP_DUMP);
RXDT_Extern(RXCONTX);
RXDT_Extern(DISPATCH);
RXDT_Extern(NTFASTIO);
RXDT_Extern(LOWIO);
RXDT_Extern(MINIRDR);
RXDT_Extern(DISCCODE);  //for the browser interface stuff
RXDT_Extern(BROWSER);
RXDT_Extern(CONNECT);
RXDT_Extern(NTTIMER);
RXDT_Extern(SCAVTHRD);
RXDT_Extern(SCAVENGER);
RXDT_Extern(SHAREACCESS);
RXDT_Extern(NAMECACHE);

//connection engines categories

RXDT_Extern(RXCEBINDING);
RXDT_Extern(RXCEDBIMPLEMENTATION);
RXDT_Extern(RXCEMANAGEMENT);
RXDT_Extern(RXCEXMIT);
RXDT_Extern(RXCEPOOL);
RXDT_Extern(RXCETDI);

#else //RDBSSTRACE

#define RXDT_Extern(__x)
#define RXDT_DeclareCategory(__x)
#define RXDT_DefineCategory(__x)

#endif //RDBSSTRACE

#ifdef RDBSSTRACE
extern BOOLEAN RxGlobalTraceSuppress, RxNextGlobalTraceSuppress;
extern ULONG RxGlobalTraceIrpCount;
VOID RxInitializeDebugTrace(void);
#define RxDbgTraceDoit(___x) ___x

#ifndef MINIRDR__NAME
extern LONG RxDebugTraceIndent;
#else
#define RxDebugTraceIndent (*(*___MINIRDR_IMPORTS_NAME).pRxDebugTraceIndent)
#endif

#else

#define RxInitializeDebugTrace()
#define RxDbgTraceDoit(___x)

#endif //RDBSSTRACE



#if DBG

#define RxDT_INDENT_EXCESS 16 //this is the offset for excess-n for the indent
#define RxDT_INDENT_SHIFT 20
#define RxDT_INDENT_MASK  0x3f
#define RxDT_LEVEL_MASK ((1<<RxDT_INDENT_SHIFT)-1)
#define RxDT_SUPPRESS_PRINT  0x80000000
#define RxDT_OVERRIDE_RETURN 0x40000000


// The implementation details of the tracing feature.

VOID
RxDebugTraceActual (
    IN ULONG NewMask,
    IN PCH Format,
    ...
    );

BOOLEAN
RxDbgTraceActualNew (
    IN ULONG NewMask,
    IN OUT PDEBUG_TRACE_CONTROLPOINT ControlPoint
    );

PRX_DEBUG_TRACE_CONTROL
RxDbgTraceFindControlPointActual(
    IN OUT PDEBUG_TRACE_CONTROLPOINT ControlPoint
    );

VOID
RxInitializeDebugTraceControlPoint(
    PSZ Name,
    PDEBUG_TRACE_CONTROLPOINT ControlPoint
    );

extern PCHAR RxIrpCodeToName[];

#endif  //DBG

#ifdef RDBSSTRACE
BOOLEAN
RxDbgTraceDisableGlobally(void);

VOID
RxDbgTraceEnableGlobally(BOOLEAN flag);

VOID
RxDebugTraceDebugCommand(
    PSZ name,
    ULONG level,
    ULONG pointcount
    );

VOID
RxDebugTraceZeroAllPrintLevels(
    void
    );

extern ULONG rdbsstracemarker;

#define RxDTMASK(INDENT,WRITELEVEL) \
         ( (((INDENT)+RxDT_INDENT_EXCESS)<<RxDT_INDENT_SHIFT) + ((WRITELEVEL)&RxDT_LEVEL_MASK))

#define RxDTPrefixRx(___x) RX_##___x

#define RxDbgTraceLV__norx_reverseaction(INDENT,CONTROLPOINT,LEVEL,Z) \
        {BOOLEAN PrintIt = RxDbgTraceActualNew((RxDT_SUPPRESS_PRINT | RxDT_OVERRIDE_RETURN | RxDTMASK((INDENT),(LEVEL))),\
                                               (CONTROLPOINT)); \
         if (!PrintIt) Z;                    \
        }

#define RxDbgTraceLV__norx(INDENT,CONTROLPOINT,LEVEL,Z) \
        {BOOLEAN PrintIt = RxDbgTraceActualNew( RxDTMASK((INDENT),(LEVEL)),(CONTROLPOINT)); \
         if (PrintIt) DbgPrint Z;                    \
        }

#define RxDbgTraceLVUnIndent__norx(INDENT,CONTROLPOINT,LEVEL) \
        {BOOLEAN PrintIt = RxDbgTraceActualNew((RxDT_SUPPRESS_PRINT | RxDTMASK((INDENT),(LEVEL))),(CONTROLPOINT)); \
        }

#define RxDbgTraceLV__(INDENT,CONTROLPOINT,LEVEL,Z) \
        RxDbgTraceLV__norx(INDENT,(&RxDTPrefixRx##CONTROLPOINT),LEVEL,Z)

#define RxDbgTraceLVUnIndent__(INDENT,CONTROLPOINT,LEVEL) \
        RxDbgTraceLVUnIndent__norx(INDENT,(&RxDTPrefixRx##CONTROLPOINT),LEVEL)

#define RxDbgTrace(INDENT,CONTROLPOINT,Z) \
             RxDbgTraceLV__(INDENT,CONTROLPOINT,1,Z) \

#define RxDbgTraceLV(INDENT,CONTROLPOINT,LEVEL,Z) \
             RxDbgTraceLV__(INDENT,CONTROLPOINT,LEVEL,Z) \

#define RxDbgTraceUnIndent(INDENT,CONTROLPOINT) \
             RxDbgTraceLVUnIndent__(INDENT,CONTROLPOINT,1)

// do not define this for nonrdbsstrace; so to catch references not ifdef'd
#define RxDbgTraceFindControlPoint(CONTROLPOINT) (RxDbgTraceFindControlPointActual(&RxDTPrefixRx##CONTROLPOINT))


#define DebugBreakPoint(CONTROLPOINT,MASKBIT) {           \
    if (((MASKBIT) == 0)                                     \
         || (RxDbgTraceFindControlPoint(CONTROLPOINT)->BreakMask & (1<<((MASKBIT)-1)) )) { \
        DbgBreakPoint();                                     \
    }                                                        \
}

#define DebugUnwind(X) {                                                      \
    if (AbnormalTermination()) {                                              \
        RxDbgTrace(0, (DEBUG_TRACE_UNWIND), ( #X ", Abnormal termination.\n", 0)); \
    }                                                                         \
}

#ifdef RX_PERFPORMANCE_TIMER
extern LONG RxPerformanceTimerLevel;

#define TimerStart(LEVEL) {                     \
    LARGE_INTEGER TStart, TEnd;                 \
    LARGE_INTEGER TElapsed;                     \
    TStart = KeQueryPerformanceCounter( NULL ); \

#define TimerStop(LEVEL,s)                                    \
    TEnd = KeQueryPerformanceCounter( NULL );                 \
    TElapsed.QuadPart = TEnd.QuadPart - TStart.QuadPart;      \
    RxTotalTicks[RxLogOf(LEVEL)] += TElapsed.LowPart;       \
    if (FlagOn( RxPerformanceTimerLevel, (LEVEL))) {         \
        DbgPrint("Time of %s %ld\n", (s), TElapsed.LowPart ); \
    }                                                         \
}
#endif //RX_PERFPORMANCE_TIMER

#else  // RDBSSTRACE

#define RxDbgTraceLV__norx_reverseaction(INDENT,CONTROLPOINT,LEVEL,Z)      {NOTHING;}
#define RxDbgTraceLV(INDENT,CONTROLPOINTNUM,LEVEL,Z)     {NOTHING;}
#define RxDbgTraceLVUnIndent(INDENT,CONTROLPOINTNUM,LEVEL)     {NOTHING;}
#define RxDbgTrace(INDENT,CONTROLPOINTNUM,Z)     {NOTHING;}
#define RxDbgTraceUnIndent(INDENT,CONTROLPOINTNUM)     {NOTHING;}
#define DebugBreakPoint(CONTROLPOINTNUM,MASKBIT) {NOTHING;}
#define DebugUnwind(X)                   {NOTHING;}
#define RxDbgTraceDisableGlobally() FALSE
#define RxDbgTraceEnableGlobally(f) {NOTHING;}

#ifdef RX_PERFPORMANCE_TIMER
#define TimerStart(LEVEL)
#define TimerStop(LEVEL,s)
#endif

#endif // RDBSSTRACE


#endif // _RDBSSTRACE_INCLUDED_



#else /* NTDDI_VERSION */

#error This file cannot be included for this NTDDI_VERSION.

#endif /* NTDDI_VERSION */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\rxtimer.h ===
#if !defined(NTDDI_VERSION)

#error NTDDI_VERSION must be defined to include this file.

#elif (NTDDI_VERSION >= NTDDI_VISTA)

/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    RxTimer.h

Abstract:

    This module defines the prototypes and structures for the timer on the rdbss architecture.
    What is provided is a 55ms timer...that is, if you register a routine then you get a call
    every 55ms. On NT, you're at DPC level.

    Also contained here are the routines for posting to a thread from DPC level.


Author:
--*/

#ifndef _RXTIMER_H_
#define _RXTIMER_H_

//
// The RX_WORK_ITEM encapsulates the context for posting to a worker thread as well as
// a timer routine to be triggered after a specific interval.
//

typedef struct _RX_WORK_ITEM_ {
    RX_WORK_QUEUE_ITEM       WorkQueueItem;
    ULONG                    LastTick;
    ULONG                    Options;
} RX_WORK_ITEM, *PRX_WORK_ITEM;

extern NTSTATUS
NTAPI
RxPostOneShotTimerRequest(
    IN PRDBSS_DEVICE_OBJECT     pDeviceObject,
    IN PRX_WORK_ITEM            pWorkItem,
    IN PRX_WORKERTHREAD_ROUTINE Routine,
    IN PVOID                    pContext,
    IN LARGE_INTEGER            TimeInterval);

extern NTSTATUS
NTAPI
RxPostRecurrentTimerRequest(
    IN PRDBSS_DEVICE_OBJECT     pDeviceObject,
    IN PRX_WORKERTHREAD_ROUTINE Routine,
    IN PVOID                    pContext,
    IN LARGE_INTEGER            TimeInterval);


extern NTSTATUS
NTAPI
RxCancelTimerRequest(
    IN PRDBSS_DEVICE_OBJECT     pDeviceObject,
    IN PRX_WORKERTHREAD_ROUTINE Routine,
    IN PVOID                    pContext
    );


//
// Routines for initializing and tearing down the timer service in RDBSS
//

extern NTSTATUS
NTAPI
RxInitializeRxTimer();

extern VOID
NTAPI
RxTearDownRxTimer(void);

#endif // _RXTIMER_STUFF_DEFINED_

#elif (NTDDI_VERSION >= NTDDI_WS03)

/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    RxTimer.h

Abstract:

    This module defines the prototypes and structures for the timer on the rdbss architecture.
    What is provided is a 55ms timer...that is, if you register a routine then you get a call
    every 55ms. On NT, you're at DPC level.

    Also contained here are the routines for posting to a thread from DPC level.


Author:
--*/

#ifndef _RXTIMER_H_
#define _RXTIMER_H_

//
// The RX_WORK_ITEM encapsulates the context for posting to a worker thread as well as
// a timer routine to be triggered after a specific interval.
//

typedef struct _RX_WORK_ITEM_ {
    RX_WORK_QUEUE_ITEM       WorkQueueItem;
    ULONG                    LastTick;
    ULONG                    Options;
} RX_WORK_ITEM, *PRX_WORK_ITEM;

extern NTSTATUS
NTAPI
RxPostOneShotTimerRequest(
    IN PRDBSS_DEVICE_OBJECT     pDeviceObject,
    IN PRX_WORK_ITEM            pWorkItem,
    IN PRX_WORKERTHREAD_ROUTINE Routine,
    IN PVOID                    pContext,
    IN LARGE_INTEGER            TimeInterval);

extern NTSTATUS
NTAPI
RxPostRecurrentTimerRequest(
    IN PRDBSS_DEVICE_OBJECT     pDeviceObject,
    IN PRX_WORKERTHREAD_ROUTINE Routine,
    IN PVOID                    pContext,
    IN LARGE_INTEGER            TimeInterval);


extern NTSTATUS
NTAPI
RxCancelTimerRequest(
    IN PRDBSS_DEVICE_OBJECT     pDeviceObject,
    IN PRX_WORKERTHREAD_ROUTINE Routine,
    IN PVOID                    pContext
    );


//
// Routines for initializing and tearing down the timer service in RDBSS
//

extern NTSTATUS
NTAPI
RxInitializeRxTimer();

extern VOID
NTAPI
RxTearDownRxTimer(void);

#endif // _RXTIMER_STUFF_DEFINED_


#elif (NTDDI_VERSION >= NTDDI_WINXP)

/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    RxTimer.h

Abstract:

    This module defines the prototypes and structures for the timer on the rdbss architecture.
    What is provided is a 55ms timer...that is, if you register a routine then you get a call
    every 55ms. On NT, you're at DPC level.

    Also contained here are the routines for posting to a thread from DPC level.


Author:
--*/

#ifndef _RXTIMER_H_
#define _RXTIMER_H_

//
// The RX_WORK_ITEM encapsulates the context for posting to a worker thread as well as
// a timer routine to be triggered after a specific interval.
//

typedef struct _RX_WORK_ITEM_ {
    RX_WORK_QUEUE_ITEM       WorkQueueItem;
    ULONG                    LastTick;
    ULONG                    Options;
} RX_WORK_ITEM, *PRX_WORK_ITEM;

extern NTSTATUS
NTAPI
RxPostOneShotTimerRequest(
    IN PRDBSS_DEVICE_OBJECT     pDeviceObject,
    IN PRX_WORK_ITEM            pWorkItem,
    IN PRX_WORKERTHREAD_ROUTINE Routine,
    IN PVOID                    pContext,
    IN LARGE_INTEGER            TimeInterval);

extern NTSTATUS
NTAPI
RxPostRecurrentTimerRequest(
    IN PRDBSS_DEVICE_OBJECT     pDeviceObject,
    IN PRX_WORKERTHREAD_ROUTINE Routine,
    IN PVOID                    pContext,
    IN LARGE_INTEGER            TimeInterval);


extern NTSTATUS
NTAPI
RxCancelTimerRequest(
    IN PRDBSS_DEVICE_OBJECT     pDeviceObject,
    IN PRX_WORKERTHREAD_ROUTINE Routine,
    IN PVOID                    pContext
    );


//
// Routines for initializing and tearing down the timer service in RDBSS
//

extern NTSTATUS
NTAPI
RxInitializeRxTimer();

extern VOID
NTAPI
RxTearDownRxTimer(void);

#endif // _RXTIMER_STUFF_DEFINED_


#elif (NTDDI_VERSION >= NTDDI_WIN2K)

/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    RxTimer.h

Abstract:

    This module defines the prototypes and structures for the timer on the rdbss architecture.
    What is provided is a 55ms timer...that is, if you register a routine then you get a call
    every 55ms. On NT, you're at DPC level.

    Also contained here are the routines for posting to a thread from DPC level.


Author:
--*/

#ifndef _RXTIMER_H_
#define _RXTIMER_H_

//
// The RX_WORK_ITEM encapsulates the context for posting to a worker thread as well as
// a timer routine to be triggered after a specific interval.
//

typedef struct _RX_WORK_ITEM_ {
    RX_WORK_QUEUE_ITEM       WorkQueueItem;
    ULONG                    LastTick;
    ULONG                    Options;
} RX_WORK_ITEM, *PRX_WORK_ITEM;

extern NTSTATUS
NTAPI
RxPostOneShotTimerRequest(
    IN PRDBSS_DEVICE_OBJECT     pDeviceObject,
    IN PRX_WORK_ITEM            pWorkItem,
    IN PRX_WORKERTHREAD_ROUTINE Routine,
    IN PVOID                    pContext,
    IN LARGE_INTEGER            TimeInterval);

extern NTSTATUS
NTAPI
RxPostRecurrentTimerRequest(
    IN PRDBSS_DEVICE_OBJECT     pDeviceObject,
    IN PRX_WORKERTHREAD_ROUTINE Routine,
    IN PVOID                    pContext,
    IN LARGE_INTEGER            TimeInterval);


extern NTSTATUS
NTAPI
RxCancelTimerRequest(
    IN PRDBSS_DEVICE_OBJECT     pDeviceObject,
    IN PRX_WORKERTHREAD_ROUTINE Routine,
    IN PVOID                    pContext
    );


//
// Routines for initializing and tearing down the timer service in RDBSS
//

extern NTSTATUS
NTAPI
RxInitializeRxTimer();

extern VOID
NTAPI
RxTearDownRxTimer(void);

#endif // _RXTIMER_STUFF_DEFINED_


#else /* NTDDI_VERSION */

#error This file cannot be included for this NTDDI_VERSION.

#endif /* NTDDI_VERSION */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\rxtypes.h ===
#if !defined(NTDDI_VERSION)

#error NTDDI_VERSION must be defined to include this file.

#elif (NTDDI_VERSION >= NTDDI_VISTA)

#ifndef _RXTYPES_INCL
#define _RXTYPES_INCL

#include "nodetype.h"

typedef PVOID RX_HANDLE, *PRX_HANDLE;
typedef KSPIN_LOCK  RX_SPIN_LOCK;
typedef PKSPIN_LOCK PRX_SPIN_LOCK;


// String definitions
// The RX_STRING type corresponds to a UNICODE_STRING and all the Rtl functions that are
// available to manipulate Unicode strings can be used to manipulate the strings
//

typedef struct _BINDING_HANDLE {
    RX_HANDLE pTdiEmulationContext;  // Win9X net structure
    RX_HANDLE pTransportInformation; // tdi transport information.
} RX_BINDING_HANDLE, *PRX_BINDING_HANDLE;

typedef UNICODE_STRING UNICODE_STRING;
typedef UNICODE_STRING*     PUNICODE_STRING;


// This structure is transient.  Most fields in this structure allow us to
// move through the bind/addname part of activating a net.  Runtime info
// for the rxce and long term context is kept elsewhere.

typedef struct _RX_BINDING_CONTEXT {
    PUNICODE_STRING         pTransportName;       // Transport Name (unicode string).
    ULONG              QualityOfService;     // Requested QOS.
    // Common fields.
    PRX_BINDING_HANDLE pBindHandle;          // Handle to transport bind info.
    } RX_BINDING_CONTEXT, *PRX_BINDING_CONTEXT;
#endif      // _RXTYPES_INCL


#elif (NTDDI_VERSION >= NTDDI_WS03)

#ifndef _RXTYPES_INCL
#define _RXTYPES_INCL

#include "nodetype.h"

typedef PVOID RX_HANDLE, *PRX_HANDLE;
typedef KSPIN_LOCK  RX_SPIN_LOCK;
typedef PKSPIN_LOCK PRX_SPIN_LOCK;


// String definitions
// The RX_STRING type corresponds to a UNICODE_STRING and all the Rtl functions that are
// available to manipulate Unicode strings can be used to manipulate the strings
//

typedef struct _BINDING_HANDLE {
    RX_HANDLE pTdiEmulationContext;  // Win9X net structure
    RX_HANDLE pTransportInformation; // tdi transport information.
} RX_BINDING_HANDLE, *PRX_BINDING_HANDLE;

typedef UNICODE_STRING UNICODE_STRING;
typedef UNICODE_STRING*     PUNICODE_STRING;


// This structure is transient.  Most fields in this structure allow us to
// move through the bind/addname part of activating a net.  Runtime info
// for the rxce and long term context is kept elsewhere.

typedef struct _RX_BINDING_CONTEXT {
    PUNICODE_STRING         pTransportName;       // Transport Name (unicode string).
    ULONG              QualityOfService;     // Requested QOS.
    // Common fields.
    PRX_BINDING_HANDLE pBindHandle;          // Handle to transport bind info.
    } RX_BINDING_CONTEXT, *PRX_BINDING_CONTEXT;
#endif      // _RXTYPES_INCL



#elif (NTDDI_VERSION >= NTDDI_WINXP)

#ifndef _RXTYPES_INCL
#define _RXTYPES_INCL

#include "nodetype.h"

typedef PVOID RX_HANDLE, *PRX_HANDLE;
typedef KSPIN_LOCK  RX_SPIN_LOCK;
typedef PKSPIN_LOCK PRX_SPIN_LOCK;


// String definitions
// The RX_STRING type corresponds to a UNICODE_STRING and all the Rtl functions that are
// available to manipulate Unicode strings can be used to manipulate the strings
//

typedef struct _BINDING_HANDLE {
    RX_HANDLE pTdiEmulationContext;  // Win9X net structure
    RX_HANDLE pTransportInformation; // tdi transport information.
} RX_BINDING_HANDLE, *PRX_BINDING_HANDLE;

typedef UNICODE_STRING UNICODE_STRING;
typedef UNICODE_STRING*     PUNICODE_STRING;


// This structure is transient.  Most fields in this structure allow us to
// move through the bind/addname part of activating a net.  Runtime info
// for the rxce and long term context is kept elsewhere.

typedef struct _RX_BINDING_CONTEXT {
    PUNICODE_STRING         pTransportName;       // Transport Name (unicode string).
    ULONG              QualityOfService;     // Requested QOS.
    // Common fields.
    PRX_BINDING_HANDLE pBindHandle;          // Handle to transport bind info.
    } RX_BINDING_CONTEXT, *PRX_BINDING_CONTEXT;
#endif      // _RXTYPES_INCL



#elif (NTDDI_VERSION >= NTDDI_WIN2K)

#ifndef _RXTYPES_INCL
#define _RXTYPES_INCL

#include "nodetype.h"

typedef PVOID RX_HANDLE, *PRX_HANDLE;
typedef KSPIN_LOCK  RX_SPIN_LOCK;
typedef PKSPIN_LOCK PRX_SPIN_LOCK;


// String definitions
// The RX_STRING type corresponds to a UNICODE_STRING and all the Rtl functions that are
// available to manipulate Unicode strings can be used to manipulate the strings
//

typedef struct _BINDING_HANDLE {
    RX_HANDLE pTdiEmulationContext;  // Win9X net structure
    RX_HANDLE pTransportInformation; // tdi transport information.
} RX_BINDING_HANDLE, *PRX_BINDING_HANDLE;

typedef UNICODE_STRING UNICODE_STRING;
typedef UNICODE_STRING*     PUNICODE_STRING;


// This structure is transient.  Most fields in this structure allow us to
// move through the bind/addname part of activating a net.  Runtime info
// for the rxce and long term context is kept elsewhere.

typedef struct _RX_BINDING_CONTEXT {
    PUNICODE_STRING         pTransportName;       // Transport Name (unicode string).
    ULONG              QualityOfService;     // Requested QOS.
    // Common fields.
    PRX_BINDING_HANDLE pBindHandle;          // Handle to transport bind info.
    } RX_BINDING_CONTEXT, *PRX_BINDING_CONTEXT;
#endif      // _RXTYPES_INCL



#else /* NTDDI_VERSION */

#error This file cannot be included for this NTDDI_VERSION.

#endif /* NTDDI_VERSION */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\rxworkq.h ===
#if !defined(NTDDI_VERSION)

#error NTDDI_VERSION must be defined to include this file.

#elif (NTDDI_VERSION >= NTDDI_VISTA)

/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    rxworkq.h

Abstract:

    This module defines the data structures required to implement the dispatching
    mechanism in RDBSS for use by RDBSS as well as all the mini redirectors.

Author:
--*/

#ifndef _RXWORKQ_H_
#define _RXWORKQ_H_

//
// The worker thread routine prototype definition.
//

typedef
VOID
(NTAPI *PRX_WORKERTHREAD_ROUTINE) (
    IN PVOID Context
    );

//
// The RDBSS needs to keep track of the work items on a per device object basis.
// This enables the race conditions associated with loading/unloading as well as
// a mechanism for preventing a single mini redirector from unfairly hogging all
// the resources.
//

#ifdef __cplusplus
typedef struct _RX_WORK_QUEUE_ITEM_ : public WORK_QUEUE_ITEM {
        // the work queue item as defined in NTOS
#else // !__cplusplus
typedef struct _RX_WORK_QUEUE_ITEM_ {
   WORK_QUEUE_ITEM;     // the work queue item as defined in NTOS
#endif // __cplusplus

   PRDBSS_DEVICE_OBJECT pDeviceObject;
} RX_WORK_QUEUE_ITEM, *PRX_WORK_QUEUE_ITEM;

//
// There are certain scenarios in which dispatching of work items is inevitable.
// In such instance the WORK_QUEUE_ITEM is allocated as part of another data
// structure to avoid frequent allocation/freeing. In other scenarios where
// dispatching is rare it pays to avoid the allocation of the memory till it
// is rquired. The RDBSS work queue implementations provide for both these
// scenarios in the form of dispatching and posting work queue requests. In
// the case of dispatching no memory for the WORK_QUEUE_ITEM need be allocated
// by the caller while for posting the memory for WORK_QUEUE_ITEM needs to be
// allocated by the caller.
//

typedef struct _RX_WORK_DISPATCH_ITEM_ {
   RX_WORK_QUEUE_ITEM       WorkQueueItem;
   PRX_WORKERTHREAD_ROUTINE DispatchRoutine;
   PVOID                    DispatchRoutineParameter;
} RX_WORK_DISPATCH_ITEM, *PRX_WORK_DISPATCH_ITEM;

//
// The work queues typically come up in a active state and continue till either
// a non recoverable situation is encountered ( lack of system resources ) when
// it transitions to the Inactive state. When a rundown is initiated it transitions
// to the rundown in progress state.
//

typedef enum _RX_WORK_QUEUE_STATE_ {
   RxWorkQueueActive,
   RxWorkQueueInactive,
   RxWorkQueueRundownInProgress
} RX_WORK_QUEUE_STATE, *PRX_WORK_QUEUE_STATE;

//
// The rundown of work queues is not complete when the threads have been spun down.
// The termination of the threads needs to be ensured before the data structures
// can be torn down. The work queue implementation follows a protocol in which
// each of the threads being spundown stashes a reference to the thread object
// in the rundown context. The rundown issuing thread ( which does not belong to
// the work queue ) waits for the completion of all the threads spundown before
// tearing down the data structures.
//

typedef struct _RX_WORK_QUEUE_RUNDOWN_CONTEXT_ {
   KEVENT      RundownCompletionEvent;
   LONG        NumberOfThreadsSpunDown;
   PETHREAD    *ThreadPointers;
} RX_WORK_QUEUE_RUNDOWN_CONTEXT, *PRX_WORK_QUEUE_RUNDOWN_CONTEXT;

//
// The work queue implementation is built around a KQUEUE implementation. The
// additional support involves the regulation of number of threads that are
// actively waiting for the work items. Each work queue data structure is
// allocated in nonpaged pool and has its own synchronization mechanism ( spinlock).
//
// In addition to the bookkeeing information, i.e., state, type etc. it also includes
// statistics that are gathered over the lifetime of the queue. This will
// provide valuable information in tuning a work queue instance. The number of items
// that have been processed , the number of items that have to be processed and
// the cumulative queue length is recorded. The cumulative queue length is the
// intersiting metric, it is the sum of the number of items awaiting to be processed
// each time an additional work item was queued. The cumulative queue length
// divided by the sum of the total number of items processed and the anumber of
// items to be processed gives an indication of the average length of the
// queue. A value much greater than one signifies that the  minimum number of
// worker threads associated with the work queue can be increased. A value much
// less than one signifies that the maximum number of work threads associated
// with the queue can be decreased.
//

typedef struct _RX_WORK_QUEUE_ {
   USHORT  State;
   BOOLEAN SpinUpRequestPending;
   UCHAR   Type;

   KSPIN_LOCK SpinLock;

   PRX_WORK_QUEUE_RUNDOWN_CONTEXT pRundownContext;

   __volatile LONG    NumberOfWorkItemsDispatched;
   __volatile LONG    NumberOfWorkItemsToBeDispatched;
   LONG    CumulativeQueueLength;

   LONG    NumberOfSpinUpRequests;
   LONG    MaximumNumberOfWorkerThreads;
   LONG    MinimumNumberOfWorkerThreads;
   __volatile LONG    NumberOfActiveWorkerThreads;
   __volatile LONG    NumberOfIdleWorkerThreads;
   LONG    NumberOfFailedSpinUpRequests;
   __volatile LONG    WorkQueueItemForSpinUpWorkerThreadInUse;

   RX_WORK_QUEUE_ITEM WorkQueueItemForTearDownWorkQueue;
   RX_WORK_QUEUE_ITEM WorkQueueItemForSpinUpWorkerThread;
   RX_WORK_QUEUE_ITEM WorkQueueItemForSpinDownWorkerThread;

   KQUEUE  Queue;

   // The next field is for debugging purposes and will be removed from the
   // FREE build.
   PETHREAD *ThreadPointers;

} RX_WORK_QUEUE, *PRX_WORK_QUEUE;

//
// The dispatching mechanism in RDBSS provides for multiple levels of work queues
// on a per processor basis. There are three levels of work queues currently
// supported, Critical,Delayed and HyperCritical. The distinction between Critical
// and delayed is one of priority where as HyperCritical iss different from the
// other two in that the routines should not block, i.e., wait for any resource.
// This requirement cannot be enforced hence the effectiveness of the dispatching
// mechanism relies on the implicit cooperation of the clients.
//

typedef struct _RX_WORK_QUEUE_DISPATCHER_ {
   RX_WORK_QUEUE     WorkQueue[MaximumWorkQueue];
} RX_WORK_QUEUE_DISPATCHER, *PRX_WORK_QUEUE_DISPATCHER;

//
// The dispatcher typically come up in a active state and continue till either
// a non recoverable situation is encountered ( lack of system resources ) when
// it transitions to the Inactive state. When a rundown is initiated it transitions
// to the rundown in progress state.
//

typedef enum _RX_DISPATCHER_STATE_ {
   RxDispatcherActive,
   RxDispatcherInactive
} RX_DISPATCHER_STATE, *PRX_DISPATCHER_STATE;


//
// The RDBSS dispatching mechanism on any machine is an array of the dispatchers
// associated with each processor. When a work queue item is queued a best effort
// is made to contain the work emanating from a processor onto the same processor.
// This ensures that processor affinities setup by the NT dispatcher are not
// destroyed by the RDBSS dispatching mechanism as this could lead to excessive
// sloshing. When the work needs to be moved there are two metrics that will be
// useful in making the decision, teh amount of delay that will be experienced
// by the work item in the current queue and the effort involved in moving the
// work item to the other queue. It is very easy to quantify the former but very
// difficult to quantify the later.
//

typedef struct _RX_DISPATCHER_ {
   LONG                       NumberOfProcessors;
   PEPROCESS                  OwnerProcess;
   PRX_WORK_QUEUE_DISPATCHER  pWorkQueueDispatcher;

   RX_DISPATCHER_STATE        State;

   LIST_ENTRY                 SpinUpRequests;
   KSPIN_LOCK                 SpinUpRequestsLock;
   KEVENT                     SpinUpRequestsEvent;
   KEVENT                     SpinUpRequestsTearDownEvent;
} RX_DISPATCHER, *PRX_DISPATCHER;

//
// The function prototypes used for dispatching/posting work queue items
//

extern NTSTATUS
NTAPI
RxPostToWorkerThread (
    IN PRDBSS_DEVICE_OBJECT     pMRxDeviceObject,
    IN WORK_QUEUE_TYPE          WorkQueueType,
    IN PRX_WORK_QUEUE_ITEM      pWorkQueueItem,
    IN PRX_WORKERTHREAD_ROUTINE Routine,
    IN PVOID                    pContext
    );

extern NTSTATUS
NTAPI
RxDispatchToWorkerThread(
    IN  PRDBSS_DEVICE_OBJECT     pMRxDeviceObject,
    IN  WORK_QUEUE_TYPE          WorkQueueType,
    IN  PRX_WORKERTHREAD_ROUTINE Routine,
    IN  PVOID                    pContext);

extern BOOLEAN           //should only be called from raised IRQL
NTAPI
RxIsWorkItemQueued(
    IN OUT PWORK_QUEUE_ITEM WorkItem
    );

//
// The routines for initializing/tearing down the dispatching mechanism
//

extern NTSTATUS
RxInitializeDispatcher();

extern NTSTATUS
RxTearDownDispatcher();

extern NTSTATUS
RxInitializeMRxDispatcher(
     IN OUT PRDBSS_DEVICE_OBJECT pMRxDeviceObject);

extern NTSTATUS
RxSpinDownMRxDispatcher(
     IN OUT PRDBSS_DEVICE_OBJECT pMRxDeviceObject);

#endif  _RXWORKQ_H_

#elif (NTDDI_VERSION >= NTDDI_WS03)

/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    rxworkq.h

Abstract:

    This module defines the data structures required to implement the dispatching
    mechanism in RDBSS for use by RDBSS as well as all the mini redirectors.

Author:
--*/

#ifndef _RXWORKQ_H_
#define _RXWORKQ_H_

//
// The worker thread routine prototype definition.
//

typedef
VOID
(NTAPI *PRX_WORKERTHREAD_ROUTINE) (
    IN PVOID Context
    );

//
// The RDBSS needs to keep track of the work items on a per device object basis.
// This enables the race conditions associated with loading/unloading as well as
// a mechanism for preventing a single mini redirector from unfairly hogging all
// the resources.
//

#ifdef __cplusplus
typedef struct _RX_WORK_QUEUE_ITEM_ : public WORK_QUEUE_ITEM {
        // the work queue item as defined in NTOS
#else // !__cplusplus
typedef struct _RX_WORK_QUEUE_ITEM_ {
   WORK_QUEUE_ITEM;     // the work queue item as defined in NTOS
#endif // __cplusplus

   PRDBSS_DEVICE_OBJECT pDeviceObject;
} RX_WORK_QUEUE_ITEM, *PRX_WORK_QUEUE_ITEM;

//
// There are certain scenarios in which dispatching of work items is inevitable.
// In such instance the WORK_QUEUE_ITEM is allocated as part of another data
// structure to avoid frequent allocation/freeing. In other scenarios where
// dispatching is rare it pays to avoid the allocation of the memory till it
// is rquired. The RDBSS work queue implementations provide for both these
// scenarios in the form of dispatching and posting work queue requests. In
// the case of dispatching no memory for the WORK_QUEUE_ITEM need be allocated
// by the caller while for posting the memory for WORK_QUEUE_ITEM needs to be
// allocated by the caller.
//

typedef struct _RX_WORK_DISPATCH_ITEM_ {
   RX_WORK_QUEUE_ITEM       WorkQueueItem;
   PRX_WORKERTHREAD_ROUTINE DispatchRoutine;
   PVOID                    DispatchRoutineParameter;
} RX_WORK_DISPATCH_ITEM, *PRX_WORK_DISPATCH_ITEM;

//
// The work queues typically come up in a active state and continue till either
// a non recoverable situation is encountered ( lack of system resources ) when
// it transitions to the Inactive state. When a rundown is initiated it transitions
// to the rundown in progress state.
//

typedef enum _RX_WORK_QUEUE_STATE_ {
   RxWorkQueueActive,
   RxWorkQueueInactive,
   RxWorkQueueRundownInProgress
} RX_WORK_QUEUE_STATE, *PRX_WORK_QUEUE_STATE;

//
// The rundown of work queues is not complete when the threads have been spun down.
// The termination of the threads needs to be ensured before the data structures
// can be torn down. The work queue implementation follows a protocol in which
// each of the threads being spundown stashes a reference to the thread object
// in the rundown context. The rundown issuing thread ( which does not belong to
// the work queue ) waits for the completion of all the threads spundown before
// tearing down the data structures.
//

typedef struct _RX_WORK_QUEUE_RUNDOWN_CONTEXT_ {
   KEVENT      RundownCompletionEvent;
   LONG        NumberOfThreadsSpunDown;
   PETHREAD    *ThreadPointers;
} RX_WORK_QUEUE_RUNDOWN_CONTEXT, *PRX_WORK_QUEUE_RUNDOWN_CONTEXT;

//
// The work queue implementation is built around a KQUEUE implementation. The
// additional support involves the regulation of number of threads that are
// actively waiting for the work items. Each work queue data structure is
// allocated in nonpaged pool and has its own synchronization mechanism ( spinlock).
//
// In addition to the bookkeeing information, i.e., state, type etc. it also includes
// statistics that are gathered over the lifetime of the queue. This will
// provide valuable information in tuning a work queue instance. The number of items
// that have been processed , the number of items that have to be processed and
// the cumulative queue length is recorded. The cumulative queue length is the
// intersiting metric, it is the sum of the number of items awaiting to be processed
// each time an additional work item was queued. The cumulative queue length
// divided by the sum of the total number of items processed and the anumber of
// items to be processed gives an indication of the average length of the
// queue. A value much greater than one signifies that the  minimum number of
// worker threads associated with the work queue can be increased. A value much
// less than one signifies that the maximum number of work threads associated
// with the queue can be decreased.
//

typedef struct _RX_WORK_QUEUE_ {
   USHORT  State;
   BOOLEAN SpinUpRequestPending;
   UCHAR   Type;

   KSPIN_LOCK SpinLock;

   PRX_WORK_QUEUE_RUNDOWN_CONTEXT pRundownContext;

   LONG    NumberOfWorkItemsDispatched;
   LONG    NumberOfWorkItemsToBeDispatched;
   LONG    CumulativeQueueLength;

   LONG    NumberOfSpinUpRequests;
   LONG    MaximumNumberOfWorkerThreads;
   LONG    MinimumNumberOfWorkerThreads;
   LONG    NumberOfActiveWorkerThreads;
   LONG    NumberOfIdleWorkerThreads;
   LONG    NumberOfFailedSpinUpRequests;
   LONG    WorkQueueItemForSpinUpWorkerThreadInUse;

   RX_WORK_QUEUE_ITEM WorkQueueItemForTearDownWorkQueue;
   RX_WORK_QUEUE_ITEM WorkQueueItemForSpinUpWorkerThread;
   RX_WORK_QUEUE_ITEM WorkQueueItemForSpinDownWorkerThread;

   KQUEUE  Queue;

   // The next field is for debugging purposes and will be removed from the
   // FREE build.
   PETHREAD *ThreadPointers;

} RX_WORK_QUEUE, *PRX_WORK_QUEUE;

//
// The dispatching mechanism in RDBSS provides for multiple levels of work queues
// on a per processor basis. There are three levels of work queues currently
// supported, Critical,Delayed and HyperCritical. The distinction between Critical
// and delayed is one of priority where as HyperCritical iss different from the
// other two in that the routines should not block, i.e., wait for any resource.
// This requirement cannot be enforced hence the effectiveness of the dispatching
// mechanism relies on the implicit cooperation of the clients.
//

typedef struct _RX_WORK_QUEUE_DISPATCHER_ {
   RX_WORK_QUEUE     WorkQueue[MaximumWorkQueue];
} RX_WORK_QUEUE_DISPATCHER, *PRX_WORK_QUEUE_DISPATCHER;

//
// The dispatcher typically come up in a active state and continue till either
// a non recoverable situation is encountered ( lack of system resources ) when
// it transitions to the Inactive state. When a rundown is initiated it transitions
// to the rundown in progress state.
//

typedef enum _RX_DISPATCHER_STATE_ {
   RxDispatcherActive,
   RxDispatcherInactive
} RX_DISPATCHER_STATE, *PRX_DISPATCHER_STATE;


//
// The RDBSS dispatching mechanism on any machine is an array of the dispatchers
// associated with each processor. When a work queue item is queued a best effort
// is made to contain the work emanating from a processor onto the same processor.
// This ensures that processor affinities setup by the NT dispatcher are not
// destroyed by the RDBSS dispatching mechanism as this could lead to excessive
// sloshing. When the work needs to be moved there are two metrics that will be
// useful in making the decision, teh amount of delay that will be experienced
// by the work item in the current queue and the effort involved in moving the
// work item to the other queue. It is very easy to quantify the former but very
// difficult to quantify the later.
//

typedef struct _RX_DISPATCHER_ {
   LONG                       NumberOfProcessors;
   PEPROCESS                  OwnerProcess;
   PRX_WORK_QUEUE_DISPATCHER  pWorkQueueDispatcher;

   RX_DISPATCHER_STATE        State;

   LIST_ENTRY                 SpinUpRequests;
   KSPIN_LOCK                 SpinUpRequestsLock;
   KEVENT                     SpinUpRequestsEvent;
   KEVENT                     SpinUpRequestsTearDownEvent;
} RX_DISPATCHER, *PRX_DISPATCHER;

//
// The function prototypes used for dispatching/posting work queue items
//

extern NTSTATUS
NTAPI
RxPostToWorkerThread (
    IN PRDBSS_DEVICE_OBJECT     pMRxDeviceObject,
    IN WORK_QUEUE_TYPE          WorkQueueType,
    IN PRX_WORK_QUEUE_ITEM      pWorkQueueItem,
    IN PRX_WORKERTHREAD_ROUTINE Routine,
    IN PVOID                    pContext
    );

extern NTSTATUS
NTAPI
RxDispatchToWorkerThread(
    IN  PRDBSS_DEVICE_OBJECT     pMRxDeviceObject,
    IN  WORK_QUEUE_TYPE          WorkQueueType,
    IN  PRX_WORKERTHREAD_ROUTINE Routine,
    IN  PVOID                    pContext);

extern BOOLEAN           //should only be called from raised IRQL
NTAPI
RxIsWorkItemQueued(
    IN OUT PWORK_QUEUE_ITEM WorkItem
    );

//
// The routines for initializing/tearing down the dispatching mechanism
//

extern NTSTATUS
RxInitializeDispatcher();

extern NTSTATUS
RxTearDownDispatcher();

extern NTSTATUS
RxInitializeMRxDispatcher(
     IN OUT PRDBSS_DEVICE_OBJECT pMRxDeviceObject);

extern NTSTATUS
RxSpinDownMRxDispatcher(
     IN OUT PRDBSS_DEVICE_OBJECT pMRxDeviceObject);

#endif  _RXWORKQ_H_


#elif (NTDDI_VERSION >= NTDDI_WINXP)

/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    rxworkq.h

Abstract:

    This module defines the data structures required to implement the dispatching
    mechanism in RDBSS for use by RDBSS as well as all the mini redirectors.

Author:
--*/

#ifndef _RXWORKQ_H_
#define _RXWORKQ_H_

//
// The worker thread routine prototype definition.
//

typedef
VOID
(NTAPI *PRX_WORKERTHREAD_ROUTINE) (
    IN PVOID Context
    );

//
// The RDBSS needs to keep track of the work items on a per device object basis.
// This enables the race conditions associated with loading/unloading as well as
// a mechanism for preventing a single mini redirector from unfairly hogging all
// the resources.
//

#ifdef __cplusplus
typedef struct _RX_WORK_QUEUE_ITEM_ : public WORK_QUEUE_ITEM {
        // the work queue item as defined in NTOS
#else // !__cplusplus
typedef struct _RX_WORK_QUEUE_ITEM_ {
   WORK_QUEUE_ITEM;     // the work queue item as defined in NTOS
#endif // __cplusplus

   PRDBSS_DEVICE_OBJECT pDeviceObject;
} RX_WORK_QUEUE_ITEM, *PRX_WORK_QUEUE_ITEM;

//
// There are certain scenarios in which dispatching of work items is inevitable.
// In such instance the WORK_QUEUE_ITEM is allocated as part of another data
// structure to avoid frequent allocation/freeing. In other scenarios where
// dispatching is rare it pays to avoid the allocation of the memory till it
// is rquired. The RDBSS work queue implementations provide for both these
// scenarios in the form of dispatching and posting work queue requests. In
// the case of dispatching no memory for the WORK_QUEUE_ITEM need be allocated
// by the caller while for posting the memory for WORK_QUEUE_ITEM needs to be
// allocated by the caller.
//

typedef struct _RX_WORK_DISPATCH_ITEM_ {
   RX_WORK_QUEUE_ITEM       WorkQueueItem;
   PRX_WORKERTHREAD_ROUTINE DispatchRoutine;
   PVOID                    DispatchRoutineParameter;
} RX_WORK_DISPATCH_ITEM, *PRX_WORK_DISPATCH_ITEM;

//
// The work queues typically come up in a active state and continue till either
// a non recoverable situation is encountered ( lack of system resources ) when
// it transitions to the Inactive state. When a rundown is initiated it transitions
// to the rundown in progress state.
//

typedef enum _RX_WORK_QUEUE_STATE_ {
   RxWorkQueueActive,
   RxWorkQueueInactive,
   RxWorkQueueRundownInProgress
} RX_WORK_QUEUE_STATE, *PRX_WORK_QUEUE_STATE;

//
// The rundown of work queues is not complete when the threads have been spun down.
// The termination of the threads needs to be ensured before the data structures
// can be torn down. The work queue implementation follows a protocol in which
// each of the threads being spundown stashes a reference to the thread object
// in the rundown context. The rundown issuing thread ( which does not belong to
// the work queue ) waits for the completion of all the threads spundown before
// tearing down the data structures.
//

typedef struct _RX_WORK_QUEUE_RUNDOWN_CONTEXT_ {
   KEVENT      RundownCompletionEvent;
   LONG        NumberOfThreadsSpunDown;
   PETHREAD    *ThreadPointers;
} RX_WORK_QUEUE_RUNDOWN_CONTEXT, *PRX_WORK_QUEUE_RUNDOWN_CONTEXT;

//
// The work queue implementation is built around a KQUEUE implementation. The
// additional support involves the regulation of number of threads that are
// actively waiting for the work items. Each work queue data structure is
// allocated in nonpaged pool and has its own synchronization mechanism ( spinlock).
//
// In addition to the bookkeeing information, i.e., state, type etc. it also includes
// statistics that are gathered over the lifetime of the queue. This will
// provide valuable information in tuning a work queue instance. The number of items
// that have been processed , the number of items that have to be processed and
// the cumulative queue length is recorded. The cumulative queue length is the
// intersiting metric, it is the sum of the number of items awaiting to be processed
// each time an additional work item was queued. The cumulative queue length
// divided by the sum of the total number of items processed and the anumber of
// items to be processed gives an indication of the average length of the
// queue. A value much greater than one signifies that the  minimum number of
// worker threads associated with the work queue can be increased. A value much
// less than one signifies that the maximum number of work threads associated
// with the queue can be decreased.
//

typedef struct _RX_WORK_QUEUE_ {
   USHORT  State;
   BOOLEAN SpinUpRequestPending;
   UCHAR   Type;

   KSPIN_LOCK SpinLock;

   PRX_WORK_QUEUE_RUNDOWN_CONTEXT pRundownContext;

   LONG    NumberOfWorkItemsDispatched;
   LONG    NumberOfWorkItemsToBeDispatched;
   LONG    CumulativeQueueLength;

   LONG    NumberOfSpinUpRequests;
   LONG    MaximumNumberOfWorkerThreads;
   LONG    MinimumNumberOfWorkerThreads;
   LONG    NumberOfActiveWorkerThreads;
   LONG    NumberOfIdleWorkerThreads;
   LONG    NumberOfFailedSpinUpRequests;
   LONG    WorkQueueItemForSpinUpWorkerThreadInUse;

   RX_WORK_QUEUE_ITEM WorkQueueItemForTearDownWorkQueue;
   RX_WORK_QUEUE_ITEM WorkQueueItemForSpinUpWorkerThread;
   RX_WORK_QUEUE_ITEM WorkQueueItemForSpinDownWorkerThread;

   KQUEUE  Queue;

   // The next field is for debugging purposes and will be removed from the
   // FREE build.
   PETHREAD *ThreadPointers;

} RX_WORK_QUEUE, *PRX_WORK_QUEUE;

//
// The dispatching mechanism in RDBSS provides for multiple levels of work queues
// on a per processor basis. There are three levels of work queues currently
// supported, Critical,Delayed and HyperCritical. The distinction between Critical
// and delayed is one of priority where as HyperCritical iss different from the
// other two in that the routines should not block, i.e., wait for any resource.
// This requirement cannot be enforced hence the effectiveness of the dispatching
// mechanism relies on the implicit cooperation of the clients.
//

typedef struct _RX_WORK_QUEUE_DISPATCHER_ {
   RX_WORK_QUEUE     WorkQueue[MaximumWorkQueue];
} RX_WORK_QUEUE_DISPATCHER, *PRX_WORK_QUEUE_DISPATCHER;

//
// The dispatcher typically come up in a active state and continue till either
// a non recoverable situation is encountered ( lack of system resources ) when
// it transitions to the Inactive state. When a rundown is initiated it transitions
// to the rundown in progress state.
//

typedef enum _RX_DISPATCHER_STATE_ {
   RxDispatcherActive,
   RxDispatcherInactive
} RX_DISPATCHER_STATE, *PRX_DISPATCHER_STATE;


//
// The RDBSS dispatching mechanism on any machine is an array of the dispatchers
// associated with each processor. When a work queue item is queued a best effort
// is made to contain the work emanating from a processor onto the same processor.
// This ensures that processor affinities setup by the NT dispatcher are not
// destroyed by the RDBSS dispatching mechanism as this could lead to excessive
// sloshing. When the work needs to be moved there are two metrics that will be
// useful in making the decision, teh amount of delay that will be experienced
// by the work item in the current queue and the effort involved in moving the
// work item to the other queue. It is very easy to quantify the former but very
// difficult to quantify the later.
//

typedef struct _RX_DISPATCHER_ {
   LONG                       NumberOfProcessors;
   PEPROCESS                  OwnerProcess;
   PRX_WORK_QUEUE_DISPATCHER  pWorkQueueDispatcher;

   RX_DISPATCHER_STATE        State;

   LIST_ENTRY                 SpinUpRequests;
   KSPIN_LOCK                 SpinUpRequestsLock;
   KEVENT                     SpinUpRequestsEvent;
   KEVENT                     SpinUpRequestsTearDownEvent;
} RX_DISPATCHER, *PRX_DISPATCHER;

//
// The function prototypes used for dispatching/posting work queue items
//

extern NTSTATUS
NTAPI
RxPostToWorkerThread (
    IN PRDBSS_DEVICE_OBJECT     pMRxDeviceObject,
    IN WORK_QUEUE_TYPE          WorkQueueType,
    IN PRX_WORK_QUEUE_ITEM      pWorkQueueItem,
    IN PRX_WORKERTHREAD_ROUTINE Routine,
    IN PVOID                    pContext
    );

extern NTSTATUS
NTAPI
RxDispatchToWorkerThread(
    IN  PRDBSS_DEVICE_OBJECT     pMRxDeviceObject,
    IN  WORK_QUEUE_TYPE          WorkQueueType,
    IN  PRX_WORKERTHREAD_ROUTINE Routine,
    IN  PVOID                    pContext);

extern BOOLEAN           //should only be called from raised IRQL
NTAPI
RxIsWorkItemQueued(
    IN OUT PWORK_QUEUE_ITEM WorkItem
    );

//
// The routines for initializing/tearing down the dispatching mechanism
//

extern NTSTATUS
RxInitializeDispatcher();

extern NTSTATUS
RxTearDownDispatcher();

extern NTSTATUS
RxInitializeMRxDispatcher(
     IN OUT PRDBSS_DEVICE_OBJECT pMRxDeviceObject);

extern NTSTATUS
RxSpinDownMRxDispatcher(
     IN OUT PRDBSS_DEVICE_OBJECT pMRxDeviceObject);

#endif  _RXWORKQ_H_


#elif (NTDDI_VERSION >= NTDDI_WIN2K)

/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    rxworkq.h

Abstract:

    This module defines the data structures required to implement the dispatching
    mechanism in RDBSS for use by RDBSS as well as all the mini redirectors.

Author:
--*/

#ifndef _RXWORKQ_H_
#define _RXWORKQ_H_

//
// The worker thread routine prototype definition.
//

typedef
VOID
(NTAPI *PRX_WORKERTHREAD_ROUTINE) (
    IN PVOID Context
    );

//
// The RDBSS needs to keep track of the work items on a per device object basis.
// This enables the race conditions associated with loading/unloading as well as
// a mechanism for preventing a single mini redirector from unfairly hogging all
// the resources.
//

typedef struct _RX_WORK_QUEUE_ITEM_ {
   WORK_QUEUE_ITEM;     // the work queue item as defined in NTOS

   PRDBSS_DEVICE_OBJECT pDeviceObject;
} RX_WORK_QUEUE_ITEM, *PRX_WORK_QUEUE_ITEM;

//
// There are certain scenarios in which dispatching of work items is inevitable.
// In such instance the WORK_QUEUE_ITEM is allocated as part of another data
// structure to avoid frequent allocation/freeing. In other scenarios where
// dispatching is rare it pays to avoid the allocation of the memory till it
// is rquired. The RDBSS work queue implementations provide for both these
// scenarios in the form of dispatching and posting work queue requests. In
// the case of dispatching no memory for the WORK_QUEUE_ITEM need be allocated
// by the caller while for posting the memory for WORK_QUEUE_ITEM needs to be
// allocated by the caller.
//

typedef struct _RX_WORK_DISPATCH_ITEM_ {
   RX_WORK_QUEUE_ITEM       WorkQueueItem;
   PRX_WORKERTHREAD_ROUTINE DispatchRoutine;
   PVOID                    DispatchRoutineParameter;
} RX_WORK_DISPATCH_ITEM, *PRX_WORK_DISPATCH_ITEM;

//
// The work queues typically come up in a active state and continue till either
// a non recoverable situation is encountered ( lack of system resources ) when
// it transitions to the Inactive state. When a rundown is initiated it transitions
// to the rundown in progress state.
//

typedef enum _RX_WORK_QUEUE_STATE_ {
   RxWorkQueueActive,
   RxWorkQueueInactive,
   RxWorkQueueRundownInProgress
} RX_WORK_QUEUE_STATE, *PRX_WORK_QUEUE_STATE;

//
// The rundown of work queues is not complete when the threads have been spun down.
// The termination of the threads needs to be ensured before the data structures
// can be torn down. The work queue implementation follows a protocol in which
// each of the threads being spundown stashes a reference to the thread object
// in the rundown context. The rundown issuing thread ( which does not belong to
// the work queue ) waits for the completion of all the threads spundown before
// tearing down the data structures.
//

typedef struct _RX_WORK_QUEUE_RUNDOWN_CONTEXT_ {
   KEVENT      RundownCompletionEvent;
   LONG        NumberOfThreadsSpunDown;
   PETHREAD    *ThreadPointers;
} RX_WORK_QUEUE_RUNDOWN_CONTEXT, *PRX_WORK_QUEUE_RUNDOWN_CONTEXT;

//
// The work queue implementation is built around a KQUEUE implementation. The
// additional support involves the regulation of number of threads that are
// actively waiting for the work items. Each work queue data structure is
// allocated in nonpaged pool and has its own synchronization mechanism ( spinlock).
//
// In addition to the bookkeeing information, i.e., state, type etc. it also includes
// statistics that are gathered over the lifetime of the queue. This will
// provide valuable information in tuning a work queue instance. The number of items
// that have been processed , the number of items that have to be processed and
// the cumulative queue length is recorded. The cumulative queue length is the
// intersiting metric, it is the sum of the number of items awaiting to be processed
// each time an additional work item was queued. The cumulative queue length
// divided by the sum of the total number of items processed and the anumber of
// items to be processed gives an indication of the average length of the
// queue. A value much greater than one signifies that the  minimum number of
// worker threads associated with the work queue can be increased. A value much
// less than one signifies that the maximum number of work threads associated
// with the queue can be decreased.
//

typedef struct _RX_WORK_QUEUE_ {
   USHORT  State;
   BOOLEAN SpinUpRequestPending;
   UCHAR   Type;

   KSPIN_LOCK SpinLock;

   PRX_WORK_QUEUE_RUNDOWN_CONTEXT pRundownContext;

   LONG    NumberOfWorkItemsDispatched;
   LONG    NumberOfWorkItemsToBeDispatched;
   LONG    CumulativeQueueLength;

   LONG    NumberOfSpinUpRequests;
   LONG    MaximumNumberOfWorkerThreads;
   LONG    MinimumNumberOfWorkerThreads;
   LONG    NumberOfActiveWorkerThreads;
   LONG    NumberOfIdleWorkerThreads;
   LONG    NumberOfFailedSpinUpRequests;

   RX_WORK_QUEUE_ITEM WorkQueueItem;

   KQUEUE  Queue;

   // The next field is for debugging purposes and will be removed from the
   // FREE build.
   PETHREAD *ThreadPointers;

} RX_WORK_QUEUE, *PRX_WORK_QUEUE;

//
// The dispatching mechanism in RDBSS provides for multiple levels of work queues
// on a per processor basis. There are three levels of work queues currently
// supported, Critical,Delayed and HyperCritical. The distinction between Critical
// and delayed is one of priority where as HyperCritical iss different from the
// other two in that the routines should not block, i.e., wait for any resource.
// This requirement cannot be enforced hence the effectiveness of the dispatching
// mechanism relies on the implicit cooperation of the clients.
//

typedef struct _RX_WORK_QUEUE_DISPATCHER_ {
   RX_WORK_QUEUE     WorkQueue[MaximumWorkQueue];
} RX_WORK_QUEUE_DISPATCHER, *PRX_WORK_QUEUE_DISPATCHER;

//
// The dispatcher typically come up in a active state and continue till either
// a non recoverable situation is encountered ( lack of system resources ) when
// it transitions to the Inactive state. When a rundown is initiated it transitions
// to the rundown in progress state.
//

typedef enum _RX_DISPATCHER_STATE_ {
   RxDispatcherActive,
   RxDispatcherInactive
} RX_DISPATCHER_STATE, *PRX_DISPATCHER_STATE;


//
// The RDBSS dispatching mechanism on any machine is an array of the dispatchers
// associated with each processor. When a work queue item is queued a best effort
// is made to contain the work emanating from a processor onto the same processor.
// This ensures that processor affinities setup by the NT dispatcher are not
// destroyed by the RDBSS dispatching mechanism as this could lead to excessive
// sloshing. When the work needs to be moved there are two metrics that will be
// useful in making the decision, teh amount of delay that will be experienced
// by the work item in the current queue and the effort involved in moving the
// work item to the other queue. It is very easy to quantify the former but very
// difficult to quantify the later.
//

typedef struct _RX_DISPATCHER_ {
   LONG                       NumberOfProcessors;
   PEPROCESS                  OwnerProcess;
   PRX_WORK_QUEUE_DISPATCHER  pWorkQueueDispatcher;

   RX_DISPATCHER_STATE        State;

   LIST_ENTRY                 SpinUpRequests;
   KSPIN_LOCK                 SpinUpRequestsLock;
   KEVENT                     SpinUpRequestsEvent;
   KEVENT                     SpinUpRequestsTearDownEvent;
} RX_DISPATCHER, *PRX_DISPATCHER;

//
// The function prototypes used for dispatching/posting work queue items
//

extern NTSTATUS
NTAPI
RxPostToWorkerThread (
    IN PRDBSS_DEVICE_OBJECT     pMRxDeviceObject,
    IN WORK_QUEUE_TYPE          WorkQueueType,
    IN PRX_WORK_QUEUE_ITEM      pWorkQueueItem,
    IN PRX_WORKERTHREAD_ROUTINE Routine,
    IN PVOID                    pContext
    );

extern NTSTATUS
NTAPI
RxDispatchToWorkerThread(
    IN  PRDBSS_DEVICE_OBJECT     pMRxDeviceObject,
    IN  WORK_QUEUE_TYPE          WorkQueueType,
    IN  PRX_WORKERTHREAD_ROUTINE Routine,
    IN  PVOID                    pContext);

extern BOOLEAN           //should only be called from raised IRQL
NTAPI
RxIsWorkItemQueued(
    IN OUT PWORK_QUEUE_ITEM WorkItem
    );

//
// The routines for initializing/tearing down the dispatching mechanism
//

extern NTSTATUS
RxInitializeDispatcher();

extern NTSTATUS
RxTearDownDispatcher();

extern NTSTATUS
RxInitializeMRxDispatcher(
     IN OUT PRDBSS_DEVICE_OBJECT pMRxDeviceObject);

extern NTSTATUS
RxSpinDownMRxDispatcher(
     IN OUT PRDBSS_DEVICE_OBJECT pMRxDeviceObject);

#endif  _RXWORKQ_H_


#else /* NTDDI_VERSION */

#error This file cannot be included for this NTDDI_VERSION.

#endif /* NTDDI_VERSION */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\rxprocs.h ===
#if !defined(NTDDI_VERSION)

#error NTDDI_VERSION must be defined to include this file.

#elif (NTDDI_VERSION >= NTDDI_VISTA)


/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    RxProcs.h

Abstract:

    This module defines all of the globally used procedures in the RDBSS
    file system.

Author:
Revision History:

--*/

#ifndef _RDBSSPROCS_
#define _RDBSSPROCS_

#include "rx.h"
#include "backpack.h"
#include "RxTypes.h"
#include "RxLog.h"
#include "RxTrace.h"
#include "RxTimer.h"
#include "RxStruc.h"

extern PVOID RxNull;

//
//  The following macro is for all people who compile with the DBG switch
//  set, not just rdbss dbg users
//

#if DBG

#define DbgDoit(X)         {X;}
#define DebugDoit(X)       {X;}
#define DEBUG_ONLY_DECL(X) X

#else

#define DbgDoit(X)        {NOTHING;}
#define DebugDoit(X)      {NOTHING;}
#define DEBUG_ONLY_DECL(X)

#endif // DBG


//
//  utilities
//


//
//  Routines for writing error log entries.
//

/*++

    RxLogFailure, RxLogFailureWithBuffer can be used to record an event in
    the log. The RxLogFailure, RxLogFailureWithBuffer captures the line
    number alongwith the supplied information and writes it to the log. This
    is useful in debugging. RxLogFailureDirect, RxLogBufferDirect do not
    capture the line number

    RxlogEvent is useful for writing events into the log.

--*/
#define RxLogFailure( _DeviceObject, _OriginatorId, _EventId, _Status ) \
            RxLogEventDirect( _DeviceObject, _OriginatorId, _EventId, _Status, __LINE__ )

#define RxLogFailureWithBuffer( _DeviceObject, _OriginatorId, _EventId, _Status, _Buffer, _Length ) \
            RxLogEventWithBufferDirect( _DeviceObject, _OriginatorId, _EventId, _Status, _Buffer, _Length, __LINE__ )

#define RxLogEvent( _DeviceObject, _OriginatorId, _EventId, _Status) \
            RxLogEventDirect(_DeviceObject, _OriginatorId, _EventId, _Status, __LINE__)

VOID
RxLogEventDirect (
    IN PRDBSS_DEVICE_OBJECT DeviceObject,
    IN PUNICODE_STRING OriginatorId,
    IN ULONG EventId,
    IN NTSTATUS Status,
    IN ULONG Line
    );

VOID
RxLogEventWithBufferDirect (
    IN PVOID DeviceOrDriverObject,
    IN PUNICODE_STRING OriginatorId,
    IN ULONG EventId,
    IN NTSTATUS Status,
    IN PVOID DataBuffer,
    IN USHORT DataBufferLength,
    IN ULONG LineNumber
    );

VOID
RxLogEventWithAnnotation (
    IN PRDBSS_DEVICE_OBJECT DeviceObject,
    IN ULONG EventId,
    IN NTSTATUS Status,
    IN PVOID DataBuffer,
    IN USHORT DataBufferLength,
    IN PUNICODE_STRING Annotation,
    IN ULONG AnnotationCount
    );

BOOLEAN
RxCcLogError (
    IN PDEVICE_OBJECT DeviceObject,
    IN PUNICODE_STRING FileName,
    IN NTSTATUS Error,
    IN NTSTATUS DeviceError,
    IN UCHAR IrpMajorCode,
    IN PVOID Context
    );

//
//  in create.c
//

NTSTATUS
RxPrefixClaim (
    IN PRX_CONTEXT RxContext
    );

VOID
RxpPrepareCreateContextForReuse (
    PRX_CONTEXT RxContext
    );

//
//  in devfcb.c
//

LUID
RxGetUid (
    IN PSECURITY_SUBJECT_CONTEXT SubjectSecurityContext
    );

ULONG
RxGetSessionId (
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
RxFindOrCreateConnections (
    IN PRX_CONTEXT RxContext,
    IN PIRP Irp,
    IN PUNICODE_STRING CanonicalName,
    IN NET_ROOT_TYPE NetRootType,
    IN BOOLEAN TreeConnect,
    OUT PUNICODE_STRING LocalNetRootName,
    OUT PUNICODE_STRING FilePathName,
    IN OUT PLOCK_HOLDING_STATE LockHoldingState,
    IN PRX_CONNECTION_ID RxConnectionId
    );

NTSTATUS
RxFindOrCreateVNetRoot (
    PRX_CONTEXT RxContext,
    PUNICODE_STRING CanonicalName,
    NET_ROOT_TYPE NetRootType,
    PV_NET_ROOT *VirtualNetRootPointer,
    PLOCK_HOLDING_STATE *LockHoldingState
    );

//
//  in fileinfo.c
//

typedef enum _RX_NAME_CONJURING_METHODS {
    VNetRoot_As_Prefix,
    VNetRoot_As_UNC_Name,
    VNetRoot_As_DriveLetter
} RX_NAME_CONJURING_METHODS;


VOID
RxConjureOriginalName (
    __inout PFCB Fcb,
    __inout PFOBX Fobx,
    __out PULONG ActualNameLength,
    __out_bcount( *LengthRemaining) PWCHAR OriginalName,
    __inout PLONG LengthRemaining,
    __in RX_NAME_CONJURING_METHODS NameConjuringMethod
    );

//
//  A function that returns finished denotes if it was able to complete the
//  operation (TRUE) or could not complete the operation (FALSE) because the
//  wait value stored in the irp context was false and we would have had
//  to block for a resource or I/O
//

//
//   Buffer control routines for data caching, implemented in CacheSup.c
//

BOOLEAN
RxZeroData (
    IN PRX_CONTEXT RxContext,
    IN PVCB Vcb,
    IN PFILE_OBJECT FileObject,
    IN ULONG StartingZero,
    IN ULONG ByteCount
    );

NTSTATUS
RxCompleteMdl (
    IN PRX_CONTEXT RxContext,
    IN PIRP Irp
    );


VOID
RxSyncUninitializeCacheMap (
    IN PRX_CONTEXT RxContext,
    IN PFILE_OBJECT FileObject
    );

VOID
RxLockUserBuffer (
    IN PRX_CONTEXT RxContext,
    IN PIRP Irp,
    IN LOCK_OPERATION Operation,
    IN ULONG BufferLength
    );

PVOID
RxMapSystemBuffer (
    IN PRX_CONTEXT RxContext,
    IN PIRP Irp
    );

PVOID
RxMapUserBuffer (
    IN PRX_CONTEXT RxContext,
    IN PIRP Irp
    );

#define RxUpcaseEaName(RXCONTEXT,NAME,UPCASEDNAME) \
    RtlUpperString( UPCASEDNAME, NAME )


#ifdef RDBSS_TRACKER
#define RX_FCBTRACKER_PARAMS ,ULONG LineNumber,PSZ FileName,ULONG SerialNumber
#else
#define RX_FCBTRACKER_PARAMS
#endif

#define FCB_MODE_EXCLUSIVE (1)
#define FCB_MODE_SHARED    (2)
#define FCB_MODE_SHARED_WAIT_FOR_EXCLUSIVE (3)
#define FCB_MODE_SHARED_STARVE_EXCLUSIVE (4)

#define CHANGE_BUFFERING_STATE_CONTEXT      ((PRX_CONTEXT)IntToPtr(0xffffffff))
#define CHANGE_BUFFERING_STATE_CONTEXT_WAIT ((PRX_CONTEXT)IntToPtr(0xfffffffe))

//
//  NOTE: even though the following routine pass a serial number, this parameter is not used
//

NTSTATUS
__RxAcquireFcb(
    __inout PFCB Fcb,
    __inout_opt PRX_CONTEXT RxContext OPTIONAL, 
    __in ULONG Mode
     
#ifdef RDBSS_TRACKER
    ,
    __in ULONG LineNumber,
    __in PCSTR FileName,
    __in ULONG SerialNumber
#endif
    
    );


#ifdef  RDBSS_TRACKER
#define RxAcquireExclusiveFcb(RXCONTEXT,FCB) \
        __RxAcquireFcb((FCB),(RXCONTEXT),FCB_MODE_EXCLUSIVE,__LINE__,__FILE__,0)
#else
#define RxAcquireExclusiveFcb(RXCONTEXT,FCB) \
        __RxAcquireFcb((FCB),(RXCONTEXT),FCB_MODE_EXCLUSIVE)
#endif

#define RX_GET_MRX_FCB(FCB) ((PMRX_FCB)((FCB)))

#ifdef  RDBSS_TRACKER
#define RxAcquireSharedFcb(RXCONTEXT,FCB) \
        __RxAcquireFcb((FCB),(RXCONTEXT),FCB_MODE_SHARED,__LINE__,__FILE__,0)
#else
#define RxAcquireSharedFcb(RXCONTEXT,FCB) \
        __RxAcquireFcb((FCB),(RXCONTEXT),FCB_MODE_SHARED)
#endif

#ifdef  RDBSS_TRACKER
#define RxAcquireSharedFcbWaitForEx(RXCONTEXT,FCB) \
        __RxAcquireFcb((FCB),(RXCONTEXT),FCB_MODE_SHARED_WAIT_FOR_EXCLUSIVE,__LINE__,__FILE__,0)
#else
#define RxAcquireSharedFcbWaitForEx(RXCONTEXT,FCB) \
        __RxAcquireFcb((FCB),(RXCONTEXT),FCB_MODE_SHARED_WAIT_FOR_EXCLUSIVE)
#endif

#ifdef  RDBSS_TRACKER
#define RxAcquireSharedFcbStarveEx(RXCONTEXT,FCB) \
        __RxAcquireFcb((FCB),(RXCONTEXT),FCB_MODE_SHARED_STARVE_EXCLUSIVE,__LINE__,__FILE__,0)
#else
#define RxAcquireSharedFcbStarveEx(RXCONTEXT,FCB) \
        __RxAcquireFcb((FCB),(RXCONTEXT),FCB_MODE_SHARED_STARVE_EXCLUSIVE)
#endif

VOID
__RxReleaseFcb(
    __inout_opt PRX_CONTEXT RxContext,
    __inout PMRX_FCB MrxFcb
    
#ifdef RDBSS_TRACKER
    ,
    __in ULONG LineNumber,
    __in PCSTR FileName,
    __in ULONG SerialNumber
#endif

    );

#ifdef  RDBSS_TRACKER
#define RxReleaseFcb(RXCONTEXT,FCB) \
        __RxReleaseFcb((RXCONTEXT),RX_GET_MRX_FCB(FCB),__LINE__,__FILE__,0)
#else
#define RxReleaseFcb(RXCONTEXT,FCB) \
        __RxReleaseFcb((RXCONTEXT),RX_GET_MRX_FCB(FCB))
#endif


VOID
__RxReleaseFcbForThread(
    __inout_opt PRX_CONTEXT      RxContext,
    __inout PMRX_FCB MrxFcb,
    __in ERESOURCE_THREAD ResourceThreadId
    
#ifdef RDBSS_TRACKER
    ,
    __in ULONG LineNumber,
    __in PCSTR FileName,
    __in ULONG SerialNumber
#endif

    );

#ifdef  RDBSS_TRACKER
#define RxReleaseFcbForThread(RXCONTEXT,FCB,THREAD) \
        __RxReleaseFcbForThread((RXCONTEXT),RX_GET_MRX_FCB(FCB),(THREAD),__LINE__,__FILE__,0)
#else
#define RxReleaseFcbForThread(RXCONTEXT,FCB,THREAD) \
        __RxReleaseFcbForThread((RXCONTEXT),RX_GET_MRX_FCB(FCB),(THREAD))
#endif


#ifdef RDBSS_TRACKER
VOID RxTrackerUpdateHistory (
    __inout_opt PRX_CONTEXT RxContext,
    __inout PMRX_FCB MrxFcb,
    __in ULONG Operation,
    __in ULONG LineNumber,
    __in PCSTR FileName,
    __in ULONG SerialNumber
    );
#else
#define RxTrackerUpdateHistory(xRXCONTEXT,xFCB,xOPERATION,xLINENUM,xFILENAME,xSERIALNUMBER) {NOTHING;}
#endif

VOID 
RxTrackPagingIoResource (
    __inout PVOID Instance,
    __in ULONG Type,
    __in ULONG Line,
    __in PCSTR File
    );

//
//  this definition is old......i don't like the format
//

#define RxFcbAcquiredShared( RXCONTEXT, FCB ) (                      \
    ExIsResourceAcquiredSharedLite( (FCB)->Header.Resource ) \
)

#define RxIsFcbAcquiredShared( FCB ) (                      \
    ExIsResourceAcquiredSharedLite( (FCB)->Header.Resource ) \
)

#define RxIsFcbAcquiredExclusive( FCB ) (                      \
    ExIsResourceAcquiredExclusiveLite( (FCB)->Header.Resource ) \
)

#define RxIsFcbAcquired( FCB) (                      \
    ExIsResourceAcquiredSharedLite( (FCB)->Header.Resource ) | \
    ExIsResourceAcquiredExclusiveLite( (FCB)->Header.Resource ) \
)

#define RxAcquirePagingIoResource( RXCONTEXT, FCB )                       \
    ExAcquireResourceExclusiveLite( (FCB)->Header.PagingIoResource, TRUE );  \
    if (RXCONTEXT) { \
        ((PRX_CONTEXT)RXCONTEXT)->FcbPagingIoResourceAcquired = TRUE;   \
    } \
    RxTrackPagingIoResource( FCB, 1, __LINE__, __FILE__ ) \

#define RxAcquirePagingIoResourceShared( RXCONTEXT, FCB, FLAG ) \
    ExAcquireResourceSharedLite( (FCB)->Header.PagingIoResource, FLAG ); \
    if (AcquiredFile) {                                          \
        if (RXCONTEXT) {                                     \
            ((PRX_CONTEXT)RXCONTEXT)->FcbPagingIoResourceAcquired = TRUE;   \
        }                                                    \
        RxTrackPagingIoResource( FCB, 2, __LINE__, __FILE__ );    \
    }

#define RxReleasePagingIoResource( RXCONTEXT, FCB )                      \
     RxTrackPagingIoResource( FCB, 3, __LINE__, __FILE__ ); \
    if (RXCONTEXT) { \
        ((PRX_CONTEXT)RXCONTEXT)->FcbPagingIoResourceAcquired = FALSE;   \
    } \
    ExReleaseResourceLite( (FCB)->Header.PagingIoResource )

#define RxReleasePagingIoResourceForThread( RXCONTEXT, FCB, THREAD )    \
    RxTrackPagingIoResource( FCB, 3, __LINE__, __FILE__ ); \
    if (RXCONTEXT) { \
        ((PRX_CONTEXT)RXCONTEXT)->FcbPagingIoResourceAcquired = FALSE;   \
    } \
    ExReleaseResourceForThreadLite( (FCB)->Header.PagingIoResource, (THREAD) )


//  The following are cache manager call backs

BOOLEAN
RxAcquireFcbForLazyWrite (
    IN PVOID Null,
    IN BOOLEAN Wait
    );

VOID
RxReleaseFcbFromLazyWrite (
    IN PVOID Null
    );

BOOLEAN
RxAcquireFcbForReadAhead (
    IN PVOID Null,
    IN BOOLEAN Wait
    );

VOID
RxReleaseFcbFromReadAhead (
    IN PVOID Null
    );

BOOLEAN
RxNoOpAcquire (
    IN PVOID Fcb,
    IN BOOLEAN Wait
    );

VOID
RxNoOpRelease (
    IN PVOID Fcb
    );

NTSTATUS
RxAcquireForCcFlush (
    IN PFILE_OBJECT FileObject,
    IN PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
RxReleaseForCcFlush (
    IN PFILE_OBJECT FileObject,
    IN PDEVICE_OBJECT DeviceObject
    );

//
//  VOID
//  RxConvertToSharedFcb (
//      IN PRX_CONTEXT RxContext,
//      IN PFCB Fcb
//      );
//

#define RxConvertToSharedFcb(RXCONTEXT,FCB) {                        \
    ExConvertExclusiveToSharedLite( RX_GET_MRX_FCB(FCB)->Header.Resource ); \
    }

VOID
RxVerifyOperationIsLegal (
    IN PRX_CONTEXT RxContext
    );

//
//  Work queue routines for posting and retrieving an Irp, implemented in
//  workque.c
//

VOID
RxPrePostIrp (
    IN PVOID Context,
    IN PIRP Irp
    );

VOID
RxAddToWorkque (
    IN PRX_CONTEXT RxContext,
    IN PIRP Irp
    );

NTSTATUS
RxFsdPostRequest (
    IN PRX_CONTEXT RxContext
    );

#define RxFsdPostRequestWithResume(RXCONTEXT,RESUMEROUTINE) \
        (((RXCONTEXT)->ResumeRoutine = (RESUMEROUTINE)),   \
        RxFsdPostRequest( (RXCONTEXT) ) \
        )

VOID
RxInitializeMRxCalldownContext (
    PMRX_CALLDOWN_CONTEXT Context,
    PRDBSS_DEVICE_OBJECT MRxDeviceObject,
    PMRX_CALLDOWN_ROUTINE Routine,
    PVOID Parameter
    );

NTSTATUS
RxCalldownMiniRedirectors (
    LONG NumberOfMiniRdrs,
    PMRX_CALLDOWN_CONTEXT CalldownContext,
    BOOLEAN PostCalldowns
    );

//
//  This macro takes a ulong and returns its rounded up word value
//

#define WordAlign(Val) (                    \
    ALIGN_UP( Val, WORD )                   \
    )

//
//  This macro takes a pointer and returns a ULONG_PTR representation of
//  its rounded up word value
//

#define WordAlignPtr(Ptr) (                 \
    ALIGN_UP_POINTER( Ptr, WORD )           \
    )

//
//  This macro takes a ulong and returns its rounded up longword value
//

#define LongAlign(Val) (                    \
    ALIGN_UP( Val, LONG )                   \
    )

//
//  This macro takes a pointer and returns a ULONG_PTR representation of
//  its rounded up word value
//

#define LongAlignPtr(Ptr) (                 \
    ALIGN_UP_POINTER( Ptr, LONG )           \
    )

//
//  This macro takes a ulong and returns its rounded up quadword
//  value
//

#define QuadAlign(Val) (                    \
    ALIGN_UP( Val, ULONGLONG )              \
    )

//
//  This macro takes a pointer and returns a ULONG_PTR representation of
//  its rounded up quadword value
//

#define QuadAlignPtr(Ptr) (                 \
    ALIGN_UP_POINTER( Ptr, ULONGLONG )      \
    )

//
//  This macro takes a pointer and returns whether it's quadword-aligned
//

#define IsPtrQuadAligned(Ptr) (           \
    QuadAlignPtr(Ptr) == (PVOID)(Ptr)     \
    )

//
//  The following types and macros are used to help unpack the packed and
//  misaligned fields found in the Bios parameter block
//

typedef union _UCHAR1 {
    UCHAR  Uchar[1];
    UCHAR  ForceAlignment;
} UCHAR1, *PUCHAR1;

typedef union _UCHAR2 {
    UCHAR  Uchar[2];
    USHORT ForceAlignment;
} UCHAR2, *PUCHAR2;

typedef union _UCHAR4 {
    UCHAR  Uchar[4];
    ULONG  ForceAlignment;
} UCHAR4, *PUCHAR4;

//
//  This macro copies an unaligned src byte to an aligned dst byte
//

#define CopyUchar1(Dst,Src) {                                \
    *((UCHAR1 *)(Dst)) = *((UNALIGNED UCHAR1 *)(Src)); \
    }

//
//  This macro copies an unaligned src word to an aligned dst word
//

#define CopyUchar2(Dst,Src) {                                \
    *((UCHAR2 *)(Dst)) = *((UNALIGNED UCHAR2 *)(Src)); \
    }

//
//  This macro copies an unaligned src longword to an aligned dsr longword
//

#define CopyUchar4(Dst,Src) {                                \
    *((UCHAR4 *)(Dst)) = *((UNALIGNED UCHAR4 *)(Src)); \
    }

#define CopyU4char(Dst,Src) {                                \
    *((UNALIGNED UCHAR4 *)(Dst)) = *((UCHAR4 *)(Src)); \
    }

//
//  the wrapper doesn't yet implement notify and oplock. rather than remove the code
//  we define the calls in such a way as to Noop the effects so that we'll have a head
//  start on putting it back later...
// 


/* this is a macro definition we'll reenable when we implement oplocks and notifies
//
//  VOID
//  RxNotifyReportChange (
//      IN PRX_CONTEXT RxContext,
//      IN PVCB Vcb,
//      IN PFCB Fcb,
//      IN ULONG Filter,
//      IN ULONG Action
//      );
//

#define RxNotifyReportChange(I,V,F,FL,A) {                             \
    if ((F)->FullFileName.Buffer == NULL) {                             \
        RxSetFullFileNameInFcb((I),(F));                               \
    }                                                                   \
    FsRtlNotifyFullReportChange( (V)->NotifySync,                       \
                                 &(V)->DirNotifyList,                   \
                                 (PSTRING)&(F)->FullFileName,           \
                                 (USHORT) ((F)->FullFileName.Length -   \
                                           (F)->FinalNameLength),       \
                                 (PSTRING)NULL,                         \
                                 (PSTRING)NULL,                         \
                                 (ULONG)FL,                             \
                                 (ULONG)A,                              \
                                 (PVOID)NULL );                         \
}
*/
#define RxNotifyReportChange(I,V,F,FL,A) \
    RxDbgTrace(0, Dbg, ("RxNotifyReportChange PRETENDING Fcb %08lx %wZ Filter/Action = %08lx/%08lx\n", \
                 (F),&((F)->FcbTableEntry.Path),(FL),(A)))

#if 0
#define FsRtlNotifyFullChangeDirectory(A1,A2,A3,A4,A5,A6,A7,A8,A9,A10) \
    RxDbgTrace(0, Dbg, ("FsRtlNotifyFullReportChange PRETENDING ............\n",0))
#endif

#define FsRtlCheckOplock(A1,A2,A3,A4,A5)  \
        (STATUS_SUCCESS)

#define FsRtlOplockIsFastIoPossible(__a) (TRUE)

//
//  The following procedure is used by the FSP and FSD routines to complete
//  an IRP.
//
//  Note that this macro allows either the Irp or the RxContext to be
//  null, however the only legal order to do this in is:
//
//      RxCompleteRequest_OLD( NULL, Irp, Status );  // completes Irp & preserves context
//      ...
//      RxCompleteRequest_OLD( RxContext, NULL, DontCare ); // deallocates context
//
//  This would typically be done in order to pass a "naked" RxContext off to
//  the Fsp for post processing, such as read ahead.
//
//  The new way is to pass just the RxContext..........
//

VOID
RxCompleteRequest_Real (
    IN PRX_CONTEXT RxContext,
    IN PIRP Irp,
    IN NTSTATUS Status
    );

#if DBG
#define RxCompleteRequest_OLD(RXCONTEXT,IRP,STATUS) { \
    RxCompleteRequest_Real( RXCONTEXT, IRP, STATUS); \
    (IRP) = NULL;                                   \
    (RXCONTEXT) = NULL;                            \
}
#else
#define RxCompleteRequest_OLD(RXCONTEXT,IRP,STATUS ) { \
    RxCompleteRequest_Real( RXCONTEXT, IRP, STATUS ); \
}
#endif

NTSTATUS
RxCompleteRequest(
      PRX_CONTEXT pContext,
      NTSTATUS    Status);

#define RxCompleteAsynchronousRequest(RXCONTEXT,STATUS)  \
        RxCompleteRequest(RXCONTEXT,STATUS)

#define RxCompleteContextAndReturn(STATUS) {       \
             NTSTATUS __sss = (STATUS);             \
             RxCompleteRequest(RxContext,__sss); \
             return(__sss);}
#define RxCompleteContext(STATUS) {       \
             NTSTATUS __sss = (STATUS);             \
             RxCompleteRequest(RxContext,__sss);} \

//
//  The Following routine makes a popup
//

VOID
RxPopUpFileCorrupt (
    IN PRX_CONTEXT RxContext,
    IN PFCB Fcb
    );

NTSTATUS
RxConstructSrvCall (
    IN PRX_CONTEXT RxContext,
    IN PIRP Irp,
    IN PSRV_CALL SrvCall,
    OUT PLOCK_HOLDING_STATE LockHoldingState
    );

NTSTATUS
RxSetSrvCallDomainName (
    IN PMRX_SRV_CALL SrvCall,
    IN PUNICODE_STRING DomainName
    );

NTSTATUS           
RxConstructNetRoot (
    IN PRX_CONTEXT RxContext,
    IN PSRV_CALL SrvCall,
    IN PNET_ROOT NetRoot,
    IN PV_NET_ROOT VirtualNetRoot,
    OUT PLOCK_HOLDING_STATE LockHoldingState
    );

NTSTATUS
RxConstructVirtualNetRoot (
    IN PRX_CONTEXT RxContext,
    IN PIRP Irp,
    IN PUNICODE_STRING CanonicalName,
    IN NET_ROOT_TYPE NetRootType,
    IN BOOLEAN TreeConnect,
    OUT PV_NET_ROOT *VirtualNetRootPointer,
    OUT PLOCK_HOLDING_STATE LockHoldingState,
    OUT PRX_CONNECTION_ID  RxConnectionId
    );

NTSTATUS
RxFindOrConstructVirtualNetRoot (
    IN PRX_CONTEXT RxContext,
    IN PIRP Irp,
    IN PUNICODE_STRING CanonicalName,
    IN NET_ROOT_TYPE NetRootType,
    IN PUNICODE_STRING RemainingName
    );

NTSTATUS
RxLowIoFsCtlShell (
    IN PRX_CONTEXT RxContext,
    IN PIRP Irp,
    IN PFCB Fcb,
    IN PFOBX Fobx
    );

NTSTATUS
RxLowIoFsCtlShellCompletion (
    IN PRX_CONTEXT RxContext
    );


NTSTATUS
RxLowIoLockControlShell (
    IN PRX_CONTEXT RxContext,
    IN PIRP Irp,
    IN PFCB Fcb
    );

NTSTATUS
RxShadowLowIo (
    IN PRX_CONTEXT RxContext,
    IN PIRP Irp,
    IN PFCB Fcb
    );

NTSTATUS
RxShadowFastLowIo (
    IN PRX_CONTEXT RxContext,
    IN PIRP Irp
    );

NTSTATUS
RxChangeBufferingState (
    PSRV_OPEN SrvOpen,
    PVOID Context,
    BOOLEAN ComputeNewState
    );

VOID
RxAssociateSrvOpenKey (
    PMRX_SRV_OPEN MRxSrvOpen,
    PVOID SrvOpenKey
    );

VOID
RxIndicateChangeOfBufferingState (
    PMRX_SRV_CALL SrvCall,
    PVOID SrvOpenKey,
    PVOID Context
    );

VOID
RxIndicateChangeOfBufferingStateForSrvOpen (
    PMRX_SRV_CALL SrvCall,
    PMRX_SRV_OPEN SrvOpen,
    PVOID SrvOpenKey,
    PVOID Context
    );

NTSTATUS
RxPrepareToReparseSymbolicLink (
    PRX_CONTEXT RxContext,
    BOOLEAN SymbolicLinkEmbeddedInOldPath,
    PUNICODE_STRING NewPath,
    BOOLEAN NewPathIsAbsolute,
    PBOOLEAN ReparseRequired
    );

BOOLEAN
RxLockEnumerator (
    IN OUT PMRX_SRV_OPEN SrvOpen,
    IN OUT PVOID *ContinuationHandle,
    OUT PLARGE_INTEGER FileOffset,
    OUT PLARGE_INTEGER LockRange,
    OUT PBOOLEAN IsLockExclusive
    );

//
// Routines for transitioning data structures to stable states.
//

VOID
RxReference (
    IN OUT PVOID Instance
    );

VOID
RxDereference (
    IN OUT PVOID Instance,
    IN LOCK_HOLDING_STATE LockHoldingState
    );

VOID
RxWaitForStableCondition (
    IN PRX_BLOCK_CONDITION Condition,
    IN OUT PLIST_ENTRY TransitionWaitList,
    IN OUT PRX_CONTEXT RxContext,
    OUT NTSTATUS *AsyncStatus OPTIONAL
    );

VOID
RxUpdateCondition (
    IN RX_BLOCK_CONDITION NewConditionValue,
    OUT PRX_BLOCK_CONDITION Condition,
    IN OUT PLIST_ENTRY TransitionWaitList
    );

VOID
RxFinalizeNetTable (
    IN PRDBSS_DEVICE_OBJECT RxDeviceObject,
    IN BOOLEAN ForceFinalization
    );

#define RxForceNetTableFinalization(RxDeviceObject) RxFinalizeNetTable( RxDeviceObject, TRUE )

NTSTATUS
RxCloseAssociatedSrvOpen (
    IN PRX_CONTEXT RxContext OPTIONAL,
    IN PFOBX Fobx
    );

NTSTATUS
RxFinalizeConnection (
    IN OUT PNET_ROOT NetRoot,
    IN OUT PV_NET_ROOT VNetRoot OPTIONAL,
    IN LOGICAL ForceFilesClosed
    );

//
//  routines for manipulating the user's view and the server's view of SHARE_ACCESS.
//  the user's view is supported by routines exported by Io...the wrappers just allow
//  us to get a msg. the server's view is supported by routines that are essential just
//  copies of the Io routines EXCEPT that the Io routines work directly on fileobjects and
//  as such cannot be used directly. the routines mentioned are implemented in create.c
//

#if DBG
VOID
RxDumpWantedAccess (
    PSZ where1,
    PSZ where2,
    PSZ wherelogtag,
    IN ACCESS_MASK DesiredAccess,
    IN ULONG DesiredShareAccess
    );

VOID
RxDumpCurrentAccess (
    PSZ where1,
    PSZ where2,
    PSZ wherelogtag,
    PSHARE_ACCESS ShareAccess
    );

#else
#define RxDumpWantedAccess(w1,w2,wlt,DA,DSA) {NOTHING;}
#define RxDumpCurrentAccess(w1,w2,wlt,SA)  {NOTHING;}
#endif

NTSTATUS
RxCheckShareAccessPerSrvOpens (
    IN PFCB Fcb,
    IN ACCESS_MASK DesiredAccess,
    IN ULONG DesiredShareAccess
    );


VOID
RxUpdateShareAccessPerSrvOpens (
    IN PSRV_OPEN SrvOpen
    );

VOID
RxRemoveShareAccessPerSrvOpens (
    IN OUT PSRV_OPEN SrvOpen
    );

VOID
RxRemoveShareAccessPerSrvOpens (
    IN OUT PSRV_OPEN SrvOpen
    );


#if DBG
NTSTATUS
RxCheckShareAccess (
    IN ACCESS_MASK DesiredAccess,
    IN ULONG DesiredShareAccess,
    IN OUT PFILE_OBJECT FileObject,
    IN OUT PSHARE_ACCESS ShareAccess,
    IN BOOLEAN Update,
    IN PSZ where,
    IN PSZ wherelogtag
    );

VOID
RxRemoveShareAccess (
    IN PFILE_OBJECT FileObject,
    IN OUT PSHARE_ACCESS ShareAccess,
    IN PSZ where,
    IN PSZ wherelogtag
    );

VOID
RxSetShareAccess (
    IN ACCESS_MASK DesiredAccess,
    IN ULONG DesiredShareAccess,
    IN OUT PFILE_OBJECT FileObject,
    OUT PSHARE_ACCESS ShareAccess,
    IN PSZ where,
    IN PSZ wherelogtag
    );

VOID
RxUpdateShareAccess (
    IN PFILE_OBJECT FileObject,
    IN OUT PSHARE_ACCESS ShareAccess,
    IN PSZ where,
    IN PSZ wherelogtag
    );
#else
#define RxCheckShareAccess(a1,a2,a3,a4,a5,a6,a7) \
    IoCheckShareAccess(a1,a2,a3,a4,a5)

#define RxRemoveShareAccess(a1,a2,a3,a4) \
    IoRemoveShareAccess(a1,a2)

#define RxSetShareAccess(a1,a2,a3,a4,a5,a6) \
    IoSetShareAccess(a1,a2,a3,a4)

#define RxUpdateShareAccess(a1,a2,a3,a4) \
    IoUpdateShareAccess(a1,a2)
#endif

//
//  LoadUnload
//

NTSTATUS
RxDriverEntry (
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

VOID
RxUnload (
    IN PDRIVER_OBJECT DriverObject
    );

//
//  minirdr support
//

VOID
RxInitializeMinirdrDispatchTable (
    IN PDRIVER_OBJECT DriverObject
    );

ULONG
RxGetNetworkProviderPriority(
    PUNICODE_STRING DeviceName
    );

VOID
RxExtractServerName(
    IN PUNICODE_STRING FilePathName,
    OUT PUNICODE_STRING SrvCallName,
    OUT PUNICODE_STRING RestOfName
    );

VOID
RxCreateNetRootCallBack (
    IN PMRX_CREATENETROOT_CONTEXT CreateNetRootContext
    );

NTSTATUS
DuplicateTransportAddress (
    PTRANSPORT_ADDRESS *Copy,
    PTRANSPORT_ADDRESS Original,
    POOL_TYPE PoolType);

NTSTATUS
RxCepInitializeVC (
    PRXCE_VC Vc,
    PRXCE_CONNECTION Connection
    );

NTSTATUS
DuplicateConnectionInformation (
    PRXCE_CONNECTION_INFORMATION *Copy,
    PRXCE_CONNECTION_INFORMATION Original,
    POOL_TYPE PoolType
    );

NTSTATUS
RxCepInitializeConnection (
    IN OUT PRXCE_CONNECTION Connection,
    IN PRXCE_ADDRESS Address,
    IN PRXCE_CONNECTION_INFORMATION ConnectionInformation,
    IN PRXCE_CONNECTION_EVENT_HANDLER Handler,
    IN PVOID EventContext
    );

typedef struct _RX_CALLOUT_PARAMETERS_BLOCK_ * PRX_CALLOUT_PARAMETERS_BLOCK;
typedef struct _RX_CREATE_CONNECTION_CALLOUT_CONTEXT_ *PRX_CREATE_CONNECTION_CALLOUT_CONTEXT;

NTSTATUS
RxCeInitiateConnectRequest (
    IN PRX_CALLOUT_PARAMETERS_BLOCK ParameterBlock
    );

VOID
RxCeCleanupConnectCallOutContext (
    PRX_CREATE_CONNECTION_CALLOUT_CONTEXT CreateConnectionContext
    );

PVOID
RxAllocateObject (
    NODE_TYPE_CODE NodeType,
    PMINIRDR_DISPATCH MRxDispatch,
    ULONG NameLength
    );

VOID
RxFreeObject (
    PVOID pObject
    );

NTSTATUS
RxInitializeSrvCallParameters (
    IN PRX_CONTEXT RxContext,
    IN OUT PSRV_CALL SrvCall
    );

VOID
RxAddVirtualNetRootToNetRoot (
    PNET_ROOT NetRoot,
    PV_NET_ROOT VNetRoot
    );

VOID
RxRemoveVirtualNetRootFromNetRoot (
    PNET_ROOT NetRoot,
    PV_NET_ROOT VNetRoot
    );

VOID
RxOrphanFcbsFromThisVNetRoot (
    IN PV_NET_ROOT ThisVNetRoot
    );

PVOID
RxAllocateFcbObject (
    PRDBSS_DEVICE_OBJECT RxDeviceObject,
    NODE_TYPE_CODE NodeType,
    POOL_TYPE PoolType,
    ULONG NameSize,
    PVOID AlreadyAllocatedObject
    );

VOID
RxFreeFcbObject (
    PVOID Object
    );

VOID
RxPurgeFcb (
    IN  PFCB Fcb
    );

BOOLEAN
RxFinalizeNetFcb (
    OUT PFCB ThisFcb,
    IN BOOLEAN RecursiveFinalize,
    IN BOOLEAN ForceFinalize,
    IN LONG ReferenceCount
    );

BOOLEAN
RxIsThisACscAgentOpen (
    IN PRX_CONTEXT RxContext
    );

VOID
RxCheckFcbStructuresForAlignment (
    VOID
    );

VOID
RxpPrepareCreateContextForReuse (
    PRX_CONTEXT RxContext
    );

NTSTATUS
RxLowIoSubmitRETRY (
    IN PRX_CONTEXT RxContext,
    IN PIRP Irp
    );

NTSTATUS
RxLowIoCompletionTail (
    IN PRX_CONTEXT RxContext
    );

VOID
RxRecurrentTimerWorkItemDispatcher (
    IN PVOID Context
    );

NTSTATUS
RxInitializeWorkQueueDispatcher (
   PRX_WORK_QUEUE_DISPATCHER Dispatcher
   );

VOID
RxInitializeWorkQueue (
   PRX_WORK_QUEUE WorkQueue,
   WORK_QUEUE_TYPE WorkQueueType,
   ULONG MaximumNumberOfWorkerThreads,
   ULONG MinimumNumberOfWorkerThreads
   );

VOID
RxTearDownWorkQueueDispatcher (
   PRX_WORK_QUEUE_DISPATCHER Dispatcher
   );

VOID
RxTearDownWorkQueue (
   PRX_WORK_QUEUE WorkQueue
   );

NTSTATUS
RxSpinUpWorkerThread (
   PRX_WORK_QUEUE WorkQueue,
   PRX_WORKERTHREAD_ROUTINE Routine,
   PVOID Parameter
   );

VOID
RxSpinUpWorkerThreads (
   PRX_WORK_QUEUE WorkQueue
   );

VOID
RxSpinUpRequestsDispatcher (
    PRX_DISPATCHER Dispatcher
    );

VOID
RxpSpinUpWorkerThreads (
    PRX_WORK_QUEUE WorkQueue
    );

VOID
RxpWorkerThreadDispatcher (
   IN PRX_WORK_QUEUE WorkQueue,
   IN PLARGE_INTEGER WaitInterval
   );

VOID
RxBootstrapWorkerThreadDispatcher (
   IN PRX_WORK_QUEUE WorkQueue
   );

VOID
RxWorkerThreadDispatcher (
   IN PRX_WORK_QUEUE WorkQueue
   );

VOID
RxWorkItemDispatcher (
   PVOID Context
   );

BOOLEAN
RxIsPrefixTableEmpty (
    IN PRX_PREFIX_TABLE ThisTable
    );

PRX_PREFIX_ENTRY
RxTableLookupName_ExactLengthMatch (
    IN PRX_PREFIX_TABLE ThisTable,
    IN PUNICODE_STRING  Name,
    IN ULONG HashValue,
    IN PRX_CONNECTION_ID OPTIONAL RxConnectionId
    );

PVOID
RxTableLookupName (
    IN PRX_PREFIX_TABLE ThisTable,
    IN PUNICODE_STRING Name,
    OUT PUNICODE_STRING RemainingName,
    IN PRX_CONNECTION_ID OPTIONAL RxConnectionId
    );

VOID
RxAcquireFileForNtCreateSection (
    IN PFILE_OBJECT FileObject
    );

VOID
RxReleaseFileForNtCreateSection (
    IN PFILE_OBJECT FileObject
    );

NTSTATUS
RxPrepareRequestForHandling (
    PCHANGE_BUFFERING_STATE_REQUEST Request
    );

VOID
RxPrepareRequestForReuse (
    PCHANGE_BUFFERING_STATE_REQUEST Request
    );

VOID
RxpDiscardChangeBufferingStateRequests (
    IN OUT PLIST_ENTRY DiscardedRequests
    );

VOID
RxGatherRequestsForSrvOpen (
    IN OUT PSRV_CALL SrvCall,
    IN PSRV_OPEN SrvOpen,
    IN OUT PLIST_ENTRY RequestsListHead
    );

NTSTATUS
RxpLookupSrvOpenForRequestLite (
    IN PSRV_CALL SrvCall,
    IN OUT PCHANGE_BUFFERING_STATE_REQUEST Request
    );

BOOLEAN
RxContextCheckToFailThisAttempt (
    IN PIRP Irp,
    IN OUT PULONG InitialContextFlags
    );

ULONG
RxAssignMustSucceedContext (
    IN PIRP Irp,
    IN ULONG InitialContextFlags
    );

PRX_CONTEXT
RxAllocateMustSucceedContext (
    PIRP Irp,
    IN PRDBSS_DEVICE_OBJECT RxDeviceObject,
    IN ULONG InitialContextFlags,
    OUT PUCHAR MustSucceedDescriptorNumber
    );

VOID
RxFreeMustSucceedContext (
    PRX_CONTEXT RxContext
    );

PRX_LOG_ENTRY_HEADER
RxGetNextLogEntry (
    VOID
    );

VOID
RxPrintLog (
    IN ULONG EntriesToPrint OPTIONAL
    );

VOID
RxProcessChangeBufferingStateRequestsForSrvOpen (
    PSRV_OPEN SrvOpen
    );

NTSTATUS
RxPurgeFobxFromCache (
    PFOBX FobxToBePurged
    );

BOOLEAN
RxPurgeFobx (
   PFOBX pFobx
   );

VOID
RxPurgeAllFobxs (
    PRDBSS_DEVICE_OBJECT RxDeviceObject
    );

VOID
RxUndoScavengerFinalizationMarking (
    PVOID Instance
    );

VOID
RxScavengeAllFobxs (
    PRDBSS_DEVICE_OBJECT RxDeviceObject
    );

ULONG
RxTableComputePathHashValue (
    IN PUNICODE_STRING Name
    );

VOID
RxExtractServerName (
    IN PUNICODE_STRING FilePathName,
    OUT PUNICODE_STRING SrvCallName,
    OUT PUNICODE_STRING RestOfName
    );

VOID
RxCreateNetRootCallBack (
    IN PMRX_CREATENETROOT_CONTEXT CreateNetRootContext
    );

VOID
RxSpinDownOutstandingAsynchronousRequests (
    IN PRDBSS_DEVICE_OBJECT RxDeviceObject
    );

NTSTATUS
RxRegisterAsynchronousRequest (
    IN PRDBSS_DEVICE_OBJECT RxDeviceObject
    );

VOID
RxDeregisterAsynchronousRequest (
    IN PRDBSS_DEVICE_OBJECT RxDeviceObject
    );

BOOLEAN
RxCancelOperationInOverflowQueue (
    IN PRX_CONTEXT RxContext
    );

VOID
RxOrphanSrvOpens (
    IN PV_NET_ROOT ThisVNetRoot
    );

VOID
RxOrphanThisFcb (
    PFCB Fcb
    );

VOID
RxOrphanSrvOpensForThisFcb (
    IN PFCB Fcb,
    IN PV_NET_ROOT ThisVNetRoot,
    IN BOOLEAN OrphanAll
    );

VOID
RxForceFinalizeAllVNetRoots (
    PNET_ROOT NetRoot
    );

#define RxEqualConnectionId( P1, P2 ) RtlEqualMemory( P1, P2, sizeof( RX_CONNECTION_ID ) )


//
//  FsRtl lock package callbacks referenced in fcbstruc.c
//

NTSTATUS
RxLockOperationCompletion (
    IN PVOID Context,
    IN PIRP Irp
    );

VOID
RxUnlockOperation (
    IN PVOID Context,
    IN PFILE_LOCK_INFO LockInfo
    );

//
//  some read routines that need headers
//

VOID
RxStackOverflowRead (
    IN PVOID Context,
    IN PKEVENT Event
    );

NTSTATUS
RxPostStackOverflowRead (
    IN PRX_CONTEXT RxContext,
    IN PFCB Fcb
    );

//
//  the cancel routine
//

VOID
RxCancelRoutine (
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    );


INLINE
TYPE_OF_OPEN
RxDecodeFileObject ( 
    IN PFILE_OBJECT FileObject,
    OUT PFCB *Fcb,
    OUT PFOBX *Fobx
    ) {

    if (FileObject) {
        *Fcb = (PFCB)FileObject->FsContext;
        *Fobx = (PFOBX)FileObject->FsContext2;

        return NodeType( *Fcb );
    } else {

        *Fcb = NULL;
        *Fobx = NULL;
        return RDBSS_NTC_STORAGE_TYPE_UNKNOWN;
    }
}


#endif // _RDBSSPROCS_




#elif (NTDDI_VERSION >= NTDDI_WS03)


/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    RxProcs.h

Abstract:

    This module defines all of the globally used procedures in the RDBSS
    file system.

Author:
Revision History:

--*/

#ifndef _RDBSSPROCS_
#define _RDBSSPROCS_

#include "rx.h"
#include "backpack.h"
#include "RxTypes.h"
#include "RxLog.h"
#include "RxTrace.h"
#include "RxTimer.h"
#include "RxStruc.h"

extern PVOID RxNull;

//
//  The following macro is for all people who compile with the DBG switch
//  set, not just rdbss dbg users
//

#if DBG

#define DbgDoit(X)         {X;}
#define DebugDoit(X)       {X;}
#define DEBUG_ONLY_DECL(X) X

#else

#define DbgDoit(X)        {NOTHING;}
#define DebugDoit(X)      {NOTHING;}
#define DEBUG_ONLY_DECL(X)

#endif // DBG


//
//  utilities
//


//
//  Routines for writing error log entries.
//

/*++

    RxLogFailure, RxLogFailureWithBuffer can be used to record an event in
    the log. The RxLogFailure, RxLogFailureWithBuffer captures the line
    number alongwith the supplied information and writes it to the log. This
    is useful in debugging. RxLogFailureDirect, RxLogBufferDirect do not
    capture the line number

    RxlogEvent is useful for writing events into the log.

--*/
#define RxLogFailure( _DeviceObject, _OriginatorId, _EventId, _Status ) \
            RxLogEventDirect( _DeviceObject, _OriginatorId, _EventId, _Status, __LINE__ )

#define RxLogFailureWithBuffer( _DeviceObject, _OriginatorId, _EventId, _Status, _Buffer, _Length ) \
            RxLogEventWithBufferDirect( _DeviceObject, _OriginatorId, _EventId, _Status, _Buffer, _Length, __LINE__ )

#define RxLogEvent( _DeviceObject, _OriginatorId, _EventId, _Status) \
            RxLogEventDirect(_DeviceObject, _OriginatorId, _EventId, _Status, __LINE__)

VOID
RxLogEventDirect (
    IN PRDBSS_DEVICE_OBJECT DeviceObject,
    IN PUNICODE_STRING OriginatorId,
    IN ULONG EventId,
    IN NTSTATUS Status,
    IN ULONG Line
    );

VOID
RxLogEventWithBufferDirect (
    IN PVOID DeviceOrDriverObject,
    IN PUNICODE_STRING OriginatorId,
    IN ULONG EventId,
    IN NTSTATUS Status,
    IN PVOID DataBuffer,
    IN USHORT DataBufferLength,
    IN ULONG LineNumber
    );

VOID
RxLogEventWithAnnotation (
    IN PRDBSS_DEVICE_OBJECT DeviceObject,
    IN ULONG EventId,
    IN NTSTATUS Status,
    IN PVOID DataBuffer,
    IN USHORT DataBufferLength,
    IN PUNICODE_STRING Annotation,
    IN ULONG AnnotationCount
    );

BOOLEAN
RxCcLogError (
    IN PDEVICE_OBJECT DeviceObject,
    IN PUNICODE_STRING FileName,
    IN NTSTATUS Error,
    IN NTSTATUS DeviceError,
    IN UCHAR IrpMajorCode,
    IN PVOID Context
    );

//
//  in create.c
//

NTSTATUS
RxPrefixClaim (
    IN PRX_CONTEXT RxContext
    );

VOID
RxpPrepareCreateContextForReuse (
    PRX_CONTEXT RxContext
    );

//
//  in devfcb.c
//

LUID
RxGetUid (
    IN PSECURITY_SUBJECT_CONTEXT SubjectSecurityContext
    );

ULONG
RxGetSessionId (
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
RxFindOrCreateConnections (
    IN PRX_CONTEXT RxContext,
    IN PIRP Irp,
    IN PUNICODE_STRING CanonicalName,
    IN NET_ROOT_TYPE NetRootType,
    IN BOOLEAN TreeConnect,
    OUT PUNICODE_STRING LocalNetRootName,
    OUT PUNICODE_STRING FilePathName,
    IN OUT PLOCK_HOLDING_STATE LockHoldingState,
    IN PRX_CONNECTION_ID RxConnectionId
    );

NTSTATUS
RxFindOrCreateVNetRoot (
    PRX_CONTEXT RxContext,
    PUNICODE_STRING CanonicalName,
    NET_ROOT_TYPE NetRootType,
    PV_NET_ROOT *VirtualNetRootPointer,
    PLOCK_HOLDING_STATE *LockHoldingState
    );

//
//  in fileinfo.c
//

typedef enum _RX_NAME_CONJURING_METHODS {
    VNetRoot_As_Prefix,
    VNetRoot_As_UNC_Name,
    VNetRoot_As_DriveLetter
} RX_NAME_CONJURING_METHODS;

VOID
RxConjureOriginalName (
    IN PFCB Fcb,
    IN PFOBX Fobx,
    OUT PLONG ActualNameLength,
    PWCHAR OriginalName,
    IN OUT PLONG LengthRemaining,
    IN RX_NAME_CONJURING_METHODS NameConjuringMethod
    );

//
//  A function that returns finished denotes if it was able to complete the
//  operation (TRUE) or could not complete the operation (FALSE) because the
//  wait value stored in the irp context was false and we would have had
//  to block for a resource or I/O
//

//
//   Buffer control routines for data caching, implemented in CacheSup.c
//

BOOLEAN
RxZeroData (
    IN PRX_CONTEXT RxContext,
    IN PVCB Vcb,
    IN PFILE_OBJECT FileObject,
    IN ULONG StartingZero,
    IN ULONG ByteCount
    );

NTSTATUS
RxCompleteMdl (
    IN PRX_CONTEXT RxContext,
    IN PIRP Irp
    );


VOID
RxSyncUninitializeCacheMap (
    IN PRX_CONTEXT RxContext,
    IN PFILE_OBJECT FileObject
    );

VOID
RxLockUserBuffer (
    IN PRX_CONTEXT RxContext,
    IN PIRP Irp,
    IN LOCK_OPERATION Operation,
    IN ULONG BufferLength
    );

PVOID
RxMapSystemBuffer (
    IN PRX_CONTEXT RxContext,
    IN PIRP Irp
    );

PVOID
RxMapUserBuffer (
    IN PRX_CONTEXT RxContext,
    IN PIRP Irp
    );

#define RxUpcaseEaName(RXCONTEXT,NAME,UPCASEDNAME) \
    RtlUpperString( UPCASEDNAME, NAME )


#ifdef RDBSS_TRACKER
#define RX_FCBTRACKER_PARAMS ,ULONG LineNumber,PSZ FileName,ULONG SerialNumber
#else
#define RX_FCBTRACKER_PARAMS
#endif

#define FCB_MODE_EXCLUSIVE (1)
#define FCB_MODE_SHARED    (2)
#define FCB_MODE_SHARED_WAIT_FOR_EXCLUSIVE (3)
#define FCB_MODE_SHARED_STARVE_EXCLUSIVE (4)

#define CHANGE_BUFFERING_STATE_CONTEXT      ((PRX_CONTEXT)IntToPtr(0xffffffff))
#define CHANGE_BUFFERING_STATE_CONTEXT_WAIT ((PRX_CONTEXT)IntToPtr(0xfffffffe))

//
//  NOTE: even though the following routine pass a serial number, this parameter is not used
//

#ifdef RDBSS_TRACKER

NTSTATUS
__RxAcquireFcb(
     IN OUT PFCB Fcb,
     IN OUT PRX_CONTEXT RxContext,
     IN ULONG Mode,
     ULONG LineNumber,
     PSZ FileName,
     ULONG SerialNumber
     );

#else

NTSTATUS
__RxAcquireFcb(
     IN OUT PFCB Fcb,
     IN OUT PRX_CONTEXT RxContext,
     IN ULONG Mode
     );

#endif

#ifdef  RDBSS_TRACKER
#define RxAcquireExclusiveFcb(RXCONTEXT,FCB) \
        __RxAcquireFcb((FCB),(RXCONTEXT),FCB_MODE_EXCLUSIVE,__LINE__,__FILE__,0)
#else
#define RxAcquireExclusiveFcb(RXCONTEXT,FCB) \
        __RxAcquireFcb((FCB),(RXCONTEXT),FCB_MODE_EXCLUSIVE)
#endif

#define RX_GET_MRX_FCB(FCB) ((PMRX_FCB)((FCB)))

#ifdef  RDBSS_TRACKER
#define RxAcquireSharedFcb(RXCONTEXT,FCB) \
        __RxAcquireFcb((FCB),(RXCONTEXT),FCB_MODE_SHARED,__LINE__,__FILE__,0)
#else
#define RxAcquireSharedFcb(RXCONTEXT,FCB) \
        __RxAcquireFcb((FCB),(RXCONTEXT),FCB_MODE_SHARED)
#endif

#ifdef  RDBSS_TRACKER
#define RxAcquireSharedFcbWaitForEx(RXCONTEXT,FCB) \
        __RxAcquireFcb((FCB),(RXCONTEXT),FCB_MODE_SHARED_WAIT_FOR_EXCLUSIVE,__LINE__,__FILE__,0)
#else
#define RxAcquireSharedFcbWaitForEx(RXCONTEXT,FCB) \
        __RxAcquireFcb((FCB),(RXCONTEXT),FCB_MODE_SHARED_WAIT_FOR_EXCLUSIVE)
#endif

#ifdef  RDBSS_TRACKER
#define RxAcquireSharedFcbStarveEx(RXCONTEXT,FCB) \
        __RxAcquireFcb((FCB),(RXCONTEXT),FCB_MODE_SHARED_STARVE_EXCLUSIVE,__LINE__,__FILE__,0)
#else
#define RxAcquireSharedFcbStarveEx(RXCONTEXT,FCB) \
        __RxAcquireFcb((FCB),(RXCONTEXT),FCB_MODE_SHARED_STARVE_EXCLUSIVE)
#endif


#ifdef RDBSS_TRACKER

VOID
__RxReleaseFcb(
    IN PRX_CONTEXT RxContext,
    IN PMRX_FCB Fcb,
    ULONG LineNumber,
    PSZ FileName,
    ULONG SerialNumber
    );

#else

VOID
__RxReleaseFcb(
    IN PRX_CONTEXT pRxContext,
    IN PMRX_FCB    pFcb
    );

#endif

#ifdef  RDBSS_TRACKER
#define RxReleaseFcb(RXCONTEXT,FCB) \
        __RxReleaseFcb((RXCONTEXT),RX_GET_MRX_FCB(FCB),__LINE__,__FILE__,0)
#else
#define RxReleaseFcb(RXCONTEXT,FCB) \
        __RxReleaseFcb((RXCONTEXT),RX_GET_MRX_FCB(FCB))
#endif


#ifdef RDBSS_TRACKER

VOID
__RxReleaseFcbForThread(
    IN PRX_CONTEXT RxContext,
    IN PMRX_FCB Fcb,
    IN ERESOURCE_THREAD ResourceThreadId,
    ULONG LineNumber,
    PSZ FileName,
    ULONG SerialNumber
    ); 
#else

VOID
__RxReleaseFcbForThread(
    IN PRX_CONTEXT RxContext,
    IN PMRX_FCB Fcb,
    IN ERESOURCE_THREAD ResourceThreadId
    ); 

#endif

#ifdef  RDBSS_TRACKER
#define RxReleaseFcbForThread(RXCONTEXT,FCB,THREAD) \
        __RxReleaseFcbForThread((RXCONTEXT),RX_GET_MRX_FCB(FCB),(THREAD),__LINE__,__FILE__,0)
#else
#define RxReleaseFcbForThread(RXCONTEXT,FCB,THREAD) \
        __RxReleaseFcbForThread((RXCONTEXT),RX_GET_MRX_FCB(FCB),(THREAD))
#endif

#ifdef RDBSS_TRACKER
VOID RxTrackerUpdateHistory(
    PRX_CONTEXT pRxContext,
    PMRX_FCB pFcb,
    ULONG Operation,
    ULONG LineNumber,
    PSZ FileName,
    ULONG SerialNumber
    );
#else
#define RxTrackerUpdateHistory(xRXCONTEXT,xFCB,xOPERATION,xLINENUM,xFILENAME,xSERIALNUMBER) {NOTHING;}
#endif

VOID RxTrackPagingIoResource(
    PVOID Instance,
    ULONG Type,
    ULONG Line,
    PCHAR File
    );

//
//  this definition is old......i don't like the format
//

#define RxFcbAcquiredShared( RXCONTEXT, FCB ) (                      \
    ExIsResourceAcquiredSharedLite( (FCB)->Header.Resource ) \
)

#define RxIsFcbAcquiredShared( FCB ) (                      \
    ExIsResourceAcquiredSharedLite( (FCB)->Header.Resource ) \
)

#define RxIsFcbAcquiredExclusive( FCB ) (                      \
    ExIsResourceAcquiredExclusiveLite( (FCB)->Header.Resource ) \
)

#define RxIsFcbAcquired( FCB) (                      \
    ExIsResourceAcquiredSharedLite( (FCB)->Header.Resource ) | \
    ExIsResourceAcquiredExclusiveLite( (FCB)->Header.Resource ) \
)

#define RxAcquirePagingIoResource( RXCONTEXT, FCB )                       \
    ExAcquireResourceExclusiveLite( (FCB)->Header.PagingIoResource, TRUE );  \
    if (RXCONTEXT) { \
        ((PRX_CONTEXT)RXCONTEXT)->FcbPagingIoResourceAcquired = TRUE;   \
    } \
    RxTrackPagingIoResource( FCB, 1, __LINE__, __FILE__ ) \

#define RxAcquirePagingIoResourceShared( RXCONTEXT, FCB, FLAG ) \
    ExAcquireResourceSharedLite( (FCB)->Header.PagingIoResource, FLAG ); \
    if (AcquiredFile) {                                          \
        if (RXCONTEXT) {                                     \
            ((PRX_CONTEXT)RXCONTEXT)->FcbPagingIoResourceAcquired = TRUE;   \
        }                                                    \
        RxTrackPagingIoResource( FCB, 2, __LINE__, __FILE__ );    \
    }

#define RxReleasePagingIoResource( RXCONTEXT, FCB )                      \
     RxTrackPagingIoResource( FCB, 3, __LINE__, __FILE__ ); \
    if (RXCONTEXT) { \
        ((PRX_CONTEXT)RXCONTEXT)->FcbPagingIoResourceAcquired = FALSE;   \
    } \
    ExReleaseResourceLite( (FCB)->Header.PagingIoResource )

#define RxReleasePagingIoResourceForThread( RXCONTEXT, FCB, THREAD )    \
    RxTrackPagingIoResource( FCB, 3, __LINE__, __FILE__ ); \
    if (RXCONTEXT) { \
        ((PRX_CONTEXT)RXCONTEXT)->FcbPagingIoResourceAcquired = FALSE;   \
    } \
    ExReleaseResourceForThreadLite( (FCB)->Header.PagingIoResource, (THREAD) )


//  The following are cache manager call backs

BOOLEAN
RxAcquireFcbForLazyWrite (
    IN PVOID Null,
    IN BOOLEAN Wait
    );

VOID
RxReleaseFcbFromLazyWrite (
    IN PVOID Null
    );

BOOLEAN
RxAcquireFcbForReadAhead (
    IN PVOID Null,
    IN BOOLEAN Wait
    );

VOID
RxReleaseFcbFromReadAhead (
    IN PVOID Null
    );

BOOLEAN
RxNoOpAcquire (
    IN PVOID Fcb,
    IN BOOLEAN Wait
    );

VOID
RxNoOpRelease (
    IN PVOID Fcb
    );

NTSTATUS
RxAcquireForCcFlush (
    IN PFILE_OBJECT FileObject,
    IN PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
RxReleaseForCcFlush (
    IN PFILE_OBJECT FileObject,
    IN PDEVICE_OBJECT DeviceObject
    );

//
//  VOID
//  RxConvertToSharedFcb (
//      IN PRX_CONTEXT RxContext,
//      IN PFCB Fcb
//      );
//

#define RxConvertToSharedFcb(RXCONTEXT,FCB) {                        \
    ExConvertExclusiveToSharedLite( RX_GET_MRX_FCB(FCB)->Header.Resource ); \
    }

VOID
RxVerifyOperationIsLegal (
    IN PRX_CONTEXT RxContext
    );

//
//  Work queue routines for posting and retrieving an Irp, implemented in
//  workque.c
//

VOID
RxPrePostIrp (
    IN PVOID Context,
    IN PIRP Irp
    );

VOID
RxAddToWorkque (
    IN PRX_CONTEXT RxContext,
    IN PIRP Irp
    );

NTSTATUS
RxFsdPostRequest (
    IN PRX_CONTEXT RxContext
    );

#define RxFsdPostRequestWithResume(RXCONTEXT,RESUMEROUTINE) \
        (((RXCONTEXT)->ResumeRoutine = (RESUMEROUTINE)),   \
        RxFsdPostRequest( (RXCONTEXT) ) \
        )

VOID
RxInitializeMRxCalldownContext (
    PMRX_CALLDOWN_CONTEXT Context,
    PRDBSS_DEVICE_OBJECT MRxDeviceObject,
    PMRX_CALLDOWN_ROUTINE Routine,
    PVOID Parameter
    );

NTSTATUS
RxCalldownMiniRedirectors (
    LONG NumberOfMiniRdrs,
    PMRX_CALLDOWN_CONTEXT CalldownContext,
    BOOLEAN PostCalldowns
    );

//
//  This macro takes a ulong and returns its rounded up word value
//

#define WordAlign(Val) (                    \
    ALIGN_UP( Val, WORD )                   \
    )

//
//  This macro takes a pointer and returns a ULONG_PTR representation of
//  its rounded up word value
//

#define WordAlignPtr(Ptr) (                 \
    ALIGN_UP_POINTER( Ptr, WORD )           \
    )

//
//  This macro takes a ulong and returns its rounded up longword value
//

#define LongAlign(Val) (                    \
    ALIGN_UP( Val, LONG )                   \
    )

//
//  This macro takes a pointer and returns a ULONG_PTR representation of
//  its rounded up word value
//

#define LongAlignPtr(Ptr) (                 \
    ALIGN_UP_POINTER( Ptr, LONG )           \
    )

//
//  This macro takes a ulong and returns its rounded up quadword
//  value
//

#define QuadAlign(Val) (                    \
    ALIGN_UP( Val, ULONGLONG )              \
    )

//
//  This macro takes a pointer and returns a ULONG_PTR representation of
//  its rounded up quadword value
//

#define QuadAlignPtr(Ptr) (                 \
    ALIGN_UP_POINTER( Ptr, ULONGLONG )      \
    )

//
//  This macro takes a pointer and returns whether it's quadword-aligned
//

#define IsPtrQuadAligned(Ptr) (           \
    QuadAlignPtr(Ptr) == (PVOID)(Ptr)     \
    )

//
//  The following types and macros are used to help unpack the packed and
//  misaligned fields found in the Bios parameter block
//

typedef union _UCHAR1 {
    UCHAR  Uchar[1];
    UCHAR  ForceAlignment;
} UCHAR1, *PUCHAR1;

typedef union _UCHAR2 {
    UCHAR  Uchar[2];
    USHORT ForceAlignment;
} UCHAR2, *PUCHAR2;

typedef union _UCHAR4 {
    UCHAR  Uchar[4];
    ULONG  ForceAlignment;
} UCHAR4, *PUCHAR4;

//
//  This macro copies an unaligned src byte to an aligned dst byte
//

#define CopyUchar1(Dst,Src) {                                \
    *((UCHAR1 *)(Dst)) = *((UNALIGNED UCHAR1 *)(Src)); \
    }

//
//  This macro copies an unaligned src word to an aligned dst word
//

#define CopyUchar2(Dst,Src) {                                \
    *((UCHAR2 *)(Dst)) = *((UNALIGNED UCHAR2 *)(Src)); \
    }

//
//  This macro copies an unaligned src longword to an aligned dsr longword
//

#define CopyUchar4(Dst,Src) {                                \
    *((UCHAR4 *)(Dst)) = *((UNALIGNED UCHAR4 *)(Src)); \
    }

#define CopyU4char(Dst,Src) {                                \
    *((UNALIGNED UCHAR4 *)(Dst)) = *((UCHAR4 *)(Src)); \
    }

//
//  the wrapper doesn't yet implement notify and oplock. rather than remove the code
//  we define the calls in such a way as to Noop the effects so that we'll have a head
//  start on putting it back later...
// 


/* this is a macro definition we'll reenable when we implement oplocks and notifies
//
//  VOID
//  RxNotifyReportChange (
//      IN PRX_CONTEXT RxContext,
//      IN PVCB Vcb,
//      IN PFCB Fcb,
//      IN ULONG Filter,
//      IN ULONG Action
//      );
//

#define RxNotifyReportChange(I,V,F,FL,A) {                             \
    if ((F)->FullFileName.Buffer == NULL) {                             \
        RxSetFullFileNameInFcb((I),(F));                               \
    }                                                                   \
    FsRtlNotifyFullReportChange( (V)->NotifySync,                       \
                                 &(V)->DirNotifyList,                   \
                                 (PSTRING)&(F)->FullFileName,           \
                                 (USHORT) ((F)->FullFileName.Length -   \
                                           (F)->FinalNameLength),       \
                                 (PSTRING)NULL,                         \
                                 (PSTRING)NULL,                         \
                                 (ULONG)FL,                             \
                                 (ULONG)A,                              \
                                 (PVOID)NULL );                         \
}
*/
#define RxNotifyReportChange(I,V,F,FL,A) \
    RxDbgTrace(0, Dbg, ("RxNotifyReportChange PRETENDING Fcb %08lx %wZ Filter/Action = %08lx/%08lx\n", \
                 (F),&((F)->FcbTableEntry.Path),(FL),(A)))

#if 0
#define FsRtlNotifyFullChangeDirectory(A1,A2,A3,A4,A5,A6,A7,A8,A9,A10) \
    RxDbgTrace(0, Dbg, ("FsRtlNotifyFullReportChange PRETENDING ............\n",0))
#endif

#define FsRtlCheckOplock(A1,A2,A3,A4,A5)  \
        (STATUS_SUCCESS)

#define FsRtlOplockIsFastIoPossible(__a) (TRUE)

//
//  The following procedure is used by the FSP and FSD routines to complete
//  an IRP.
//
//  Note that this macro allows either the Irp or the RxContext to be
//  null, however the only legal order to do this in is:
//
//      RxCompleteRequest_OLD( NULL, Irp, Status );  // completes Irp & preserves context
//      ...
//      RxCompleteRequest_OLD( RxContext, NULL, DontCare ); // deallocates context
//
//  This would typically be done in order to pass a "naked" RxContext off to
//  the Fsp for post processing, such as read ahead.
//
//  The new way is to pass just the RxContext..........
//

VOID
RxCompleteRequest_Real (
    IN PRX_CONTEXT RxContext,
    IN PIRP Irp,
    IN NTSTATUS Status
    );

#if DBG
#define RxCompleteRequest_OLD(RXCONTEXT,IRP,STATUS) { \
    RxCompleteRequest_Real( RXCONTEXT, IRP, STATUS); \
    (IRP) = NULL;                                   \
    (RXCONTEXT) = NULL;                            \
}
#else
#define RxCompleteRequest_OLD(RXCONTEXT,IRP,STATUS ) { \
    RxCompleteRequest_Real( RXCONTEXT, IRP, STATUS ); \
}
#endif

NTSTATUS
RxCompleteRequest(
      PRX_CONTEXT pContext,
      NTSTATUS    Status);

#define RxCompleteAsynchronousRequest(RXCONTEXT,STATUS)  \
        RxCompleteRequest(RXCONTEXT,STATUS)

#define RxCompleteContextAndReturn(STATUS) {       \
             NTSTATUS __sss = (STATUS);             \
             RxCompleteRequest(RxContext,__sss); \
             return(__sss);}
#define RxCompleteContext(STATUS) {       \
             NTSTATUS __sss = (STATUS);             \
             RxCompleteRequest(RxContext,__sss);} \

//
//  The Following routine makes a popup
//

VOID
RxPopUpFileCorrupt (
    IN PRX_CONTEXT RxContext,
    IN PFCB Fcb
    );

NTSTATUS
RxConstructSrvCall (
    IN PRX_CONTEXT RxContext,
    IN PIRP Irp,
    IN PSRV_CALL SrvCall,
    OUT PLOCK_HOLDING_STATE LockHoldingState
    );

NTSTATUS
RxSetSrvCallDomainName (
    IN PMRX_SRV_CALL SrvCall,
    IN PUNICODE_STRING DomainName
    );

NTSTATUS           
RxConstructNetRoot (
    IN PRX_CONTEXT RxContext,
    IN PSRV_CALL SrvCall,
    IN PNET_ROOT NetRoot,
    IN PV_NET_ROOT VirtualNetRoot,
    OUT PLOCK_HOLDING_STATE LockHoldingState
    );

NTSTATUS
RxConstructVirtualNetRoot (
    IN PRX_CONTEXT RxContext,
    IN PIRP Irp,
    IN PUNICODE_STRING CanonicalName,
    IN NET_ROOT_TYPE NetRootType,
    IN BOOLEAN TreeConnect,
    OUT PV_NET_ROOT *VirtualNetRootPointer,
    OUT PLOCK_HOLDING_STATE LockHoldingState,
    OUT PRX_CONNECTION_ID  RxConnectionId
    );

NTSTATUS
RxFindOrConstructVirtualNetRoot (
    IN PRX_CONTEXT RxContext,
    IN PIRP Irp,
    IN PUNICODE_STRING CanonicalName,
    IN NET_ROOT_TYPE NetRootType,
    IN PUNICODE_STRING RemainingName
    );

NTSTATUS
RxLowIoFsCtlShell (
    IN PRX_CONTEXT RxContext,
    IN PIRP Irp,
    IN PFCB Fcb,
    IN PFOBX Fobx
    );

NTSTATUS
RxLowIoFsCtlShellCompletion (
    IN PRX_CONTEXT RxContext
    );


NTSTATUS
RxLowIoLockControlShell (
    IN PRX_CONTEXT RxContext,
    IN PIRP Irp,
    IN PFCB Fcb
    );

NTSTATUS
RxShadowLowIo (
    IN PRX_CONTEXT RxContext,
    IN PIRP Irp,
    IN PFCB Fcb
    );

NTSTATUS
RxShadowFastLowIo (
    IN PRX_CONTEXT RxContext,
    IN PIRP Irp
    );

NTSTATUS
RxChangeBufferingState (
    PSRV_OPEN SrvOpen,
    PVOID Context,
    BOOLEAN ComputeNewState
    );

VOID
RxAssociateSrvOpenKey (
    PMRX_SRV_OPEN MRxSrvOpen,
    PVOID SrvOpenKey
    );

VOID
RxIndicateChangeOfBufferingState (
    PMRX_SRV_CALL SrvCall,
    PVOID SrvOpenKey,
    PVOID Context
    );

VOID
RxIndicateChangeOfBufferingStateForSrvOpen (
    PMRX_SRV_CALL SrvCall,
    PMRX_SRV_OPEN SrvOpen,
    PVOID SrvOpenKey,
    PVOID Context
    );

NTSTATUS
RxPrepareToReparseSymbolicLink (
    PRX_CONTEXT RxContext,
    BOOLEAN SymbolicLinkEmbeddedInOldPath,
    PUNICODE_STRING NewPath,
    BOOLEAN NewPathIsAbsolute,
    PBOOLEAN ReparseRequired
    );

BOOLEAN
RxLockEnumerator (
    IN OUT PMRX_SRV_OPEN SrvOpen,
    IN OUT PVOID *ContinuationHandle,
    OUT PLARGE_INTEGER FileOffset,
    OUT PLARGE_INTEGER LockRange,
    OUT PBOOLEAN IsLockExclusive
    );

//
// Routines for transitioning data structures to stable states.
//

VOID
RxReference (
    IN OUT PVOID Instance
    );

VOID
RxDereference (
    IN OUT PVOID Instance,
    IN LOCK_HOLDING_STATE LockHoldingState
    );

VOID
RxWaitForStableCondition (
    IN PRX_BLOCK_CONDITION Condition,
    IN OUT PLIST_ENTRY TransitionWaitList,
    IN OUT PRX_CONTEXT RxContext,
    OUT NTSTATUS *AsyncStatus OPTIONAL
    );

VOID
RxUpdateCondition (
    IN RX_BLOCK_CONDITION NewConditionValue,
    OUT PRX_BLOCK_CONDITION Condition,
    IN OUT PLIST_ENTRY TransitionWaitList
    );

VOID
RxFinalizeNetTable (
    IN PRDBSS_DEVICE_OBJECT RxDeviceObject,
    IN BOOLEAN ForceFinalization
    );

#define RxForceNetTableFinalization(RxDeviceObject) RxFinalizeNetTable( RxDeviceObject, TRUE )

NTSTATUS
RxCloseAssociatedSrvOpen (
    IN PRX_CONTEXT RxContext OPTIONAL,
    IN PFOBX Fobx
    );

NTSTATUS
RxFinalizeConnection (
    IN OUT PNET_ROOT NetRoot,
    IN OUT PV_NET_ROOT VNetRoot OPTIONAL,
    IN LOGICAL ForceFilesClosed
    );

//
//  routines for manipulating the user's view and the server's view of SHARE_ACCESS.
//  the user's view is supported by routines exported by Io...the wrappers just allow
//  us to get a msg. the server's view is supported by routines that are essential just
//  copies of the Io routines EXCEPT that the Io routines work directly on fileobjects and
//  as such cannot be used directly. the routines mentioned are implemented in create.c
//

#if DBG
VOID
RxDumpWantedAccess (
    PSZ where1,
    PSZ where2,
    PSZ wherelogtag,
    IN ACCESS_MASK DesiredAccess,
    IN ULONG DesiredShareAccess
    );

VOID
RxDumpCurrentAccess (
    PSZ where1,
    PSZ where2,
    PSZ wherelogtag,
    PSHARE_ACCESS ShareAccess
    );

#else
#define RxDumpWantedAccess(w1,w2,wlt,DA,DSA) {NOTHING;}
#define RxDumpCurrentAccess(w1,w2,wlt,SA)  {NOTHING;}
#endif

NTSTATUS
RxCheckShareAccessPerSrvOpens (
    IN PFCB Fcb,
    IN ACCESS_MASK DesiredAccess,
    IN ULONG DesiredShareAccess
    );


VOID
RxUpdateShareAccessPerSrvOpens (
    IN PSRV_OPEN SrvOpen
    );

VOID
RxRemoveShareAccessPerSrvOpens (
    IN OUT PSRV_OPEN SrvOpen
    );

VOID
RxRemoveShareAccessPerSrvOpens (
    IN OUT PSRV_OPEN SrvOpen
    );


#if DBG
NTSTATUS
RxCheckShareAccess (
    IN ACCESS_MASK DesiredAccess,
    IN ULONG DesiredShareAccess,
    IN OUT PFILE_OBJECT FileObject,
    IN OUT PSHARE_ACCESS ShareAccess,
    IN BOOLEAN Update,
    IN PSZ where,
    IN PSZ wherelogtag
    );

VOID
RxRemoveShareAccess (
    IN PFILE_OBJECT FileObject,
    IN OUT PSHARE_ACCESS ShareAccess,
    IN PSZ where,
    IN PSZ wherelogtag
    );

VOID
RxSetShareAccess (
    IN ACCESS_MASK DesiredAccess,
    IN ULONG DesiredShareAccess,
    IN OUT PFILE_OBJECT FileObject,
    OUT PSHARE_ACCESS ShareAccess,
    IN PSZ where,
    IN PSZ wherelogtag
    );

VOID
RxUpdateShareAccess (
    IN PFILE_OBJECT FileObject,
    IN OUT PSHARE_ACCESS ShareAccess,
    IN PSZ where,
    IN PSZ wherelogtag
    );
#else
#define RxCheckShareAccess(a1,a2,a3,a4,a5,a6,a7) \
    IoCheckShareAccess(a1,a2,a3,a4,a5)

#define RxRemoveShareAccess(a1,a2,a3,a4) \
    IoRemoveShareAccess(a1,a2)

#define RxSetShareAccess(a1,a2,a3,a4,a5,a6) \
    IoSetShareAccess(a1,a2,a3,a4)

#define RxUpdateShareAccess(a1,a2,a3,a4) \
    IoUpdateShareAccess(a1,a2)
#endif

//
//  LoadUnload
//

NTSTATUS
RxDriverEntry (
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

VOID
RxUnload (
    IN PDRIVER_OBJECT DriverObject
    );

//
//  minirdr support
//

VOID
RxInitializeMinirdrDispatchTable (
    IN PDRIVER_OBJECT DriverObject
    );

ULONG
RxGetNetworkProviderPriority(
    PUNICODE_STRING DeviceName
    );

VOID
RxExtractServerName(
    IN PUNICODE_STRING FilePathName,
    OUT PUNICODE_STRING SrvCallName,
    OUT PUNICODE_STRING RestOfName
    );

VOID
RxCreateNetRootCallBack (
    IN PMRX_CREATENETROOT_CONTEXT CreateNetRootContext
    );

NTSTATUS
DuplicateTransportAddress (
    PTRANSPORT_ADDRESS *Copy,
    PTRANSPORT_ADDRESS Original,
    POOL_TYPE PoolType);

NTSTATUS
RxCepInitializeVC (
    PRXCE_VC Vc,
    PRXCE_CONNECTION Connection
    );

NTSTATUS
DuplicateConnectionInformation (
    PRXCE_CONNECTION_INFORMATION *Copy,
    PRXCE_CONNECTION_INFORMATION Original,
    POOL_TYPE PoolType
    );

NTSTATUS
RxCepInitializeConnection (
    IN OUT PRXCE_CONNECTION Connection,
    IN PRXCE_ADDRESS Address,
    IN PRXCE_CONNECTION_INFORMATION ConnectionInformation,
    IN PRXCE_CONNECTION_EVENT_HANDLER Handler,
    IN PVOID EventContext
    );

typedef struct _RX_CALLOUT_PARAMETERS_BLOCK_ * PRX_CALLOUT_PARAMETERS_BLOCK;
typedef struct _RX_CREATE_CONNECTION_CALLOUT_CONTEXT_ *PRX_CREATE_CONNECTION_CALLOUT_CONTEXT;

NTSTATUS
RxCeInitiateConnectRequest (
    IN PRX_CALLOUT_PARAMETERS_BLOCK ParameterBlock
    );

VOID
RxCeCleanupConnectCallOutContext (
    PRX_CREATE_CONNECTION_CALLOUT_CONTEXT CreateConnectionContext
    );

PVOID
RxAllocateObject (
    NODE_TYPE_CODE NodeType,
    PMINIRDR_DISPATCH MRxDispatch,
    ULONG NameLength
    );

VOID
RxFreeObject (
    PVOID pObject
    );

NTSTATUS
RxInitializeSrvCallParameters (
    IN PRX_CONTEXT RxContext,
    IN OUT PSRV_CALL SrvCall
    );

VOID
RxAddVirtualNetRootToNetRoot (
    PNET_ROOT NetRoot,
    PV_NET_ROOT VNetRoot
    );

VOID
RxRemoveVirtualNetRootFromNetRoot (
    PNET_ROOT NetRoot,
    PV_NET_ROOT VNetRoot
    );

VOID
RxOrphanFcbsFromThisVNetRoot (
    IN PV_NET_ROOT ThisVNetRoot
    );

PVOID
RxAllocateFcbObject (
    PRDBSS_DEVICE_OBJECT RxDeviceObject,
    NODE_TYPE_CODE NodeType,
    POOL_TYPE PoolType,
    ULONG NameSize,
    PVOID AlreadyAllocatedObject
    );

VOID
RxFreeFcbObject (
    PVOID Object
    );

VOID
RxPurgeFcb (
    IN  PFCB Fcb
    );

BOOLEAN
RxFinalizeNetFcb (
    OUT PFCB ThisFcb,
    IN BOOLEAN RecursiveFinalize,
    IN BOOLEAN ForceFinalize,
    IN LONG ReferenceCount
    );

BOOLEAN
RxIsThisACscAgentOpen (
    IN PRX_CONTEXT RxContext
    );

VOID
RxCheckFcbStructuresForAlignment (
    VOID
    );

VOID
RxpPrepareCreateContextForReuse (
    PRX_CONTEXT RxContext
    );

NTSTATUS
RxLowIoSubmitRETRY (
    IN PRX_CONTEXT RxContext,
    IN PIRP Irp
    );

NTSTATUS
RxLowIoCompletionTail (
    IN PRX_CONTEXT RxContext
    );

VOID
RxRecurrentTimerWorkItemDispatcher (
    IN PVOID Context
    );

NTSTATUS
RxInitializeWorkQueueDispatcher (
   PRX_WORK_QUEUE_DISPATCHER Dispatcher
   );

VOID
RxInitializeWorkQueue (
   PRX_WORK_QUEUE WorkQueue,
   WORK_QUEUE_TYPE WorkQueueType,
   ULONG MaximumNumberOfWorkerThreads,
   ULONG MinimumNumberOfWorkerThreads
   );

VOID
RxTearDownWorkQueueDispatcher (
   PRX_WORK_QUEUE_DISPATCHER Dispatcher
   );

VOID
RxTearDownWorkQueue (
   PRX_WORK_QUEUE WorkQueue
   );

NTSTATUS
RxSpinUpWorkerThread (
   PRX_WORK_QUEUE WorkQueue,
   PRX_WORKERTHREAD_ROUTINE Routine,
   PVOID Parameter
   );

VOID
RxSpinUpWorkerThreads (
   PRX_WORK_QUEUE WorkQueue
   );

VOID
RxSpinUpRequestsDispatcher (
    PRX_DISPATCHER Dispatcher
    );

VOID
RxpSpinUpWorkerThreads (
    PRX_WORK_QUEUE WorkQueue
    );

VOID
RxpWorkerThreadDispatcher (
   IN PRX_WORK_QUEUE WorkQueue,
   IN PLARGE_INTEGER WaitInterval
   );

VOID
RxBootstrapWorkerThreadDispatcher (
   IN PRX_WORK_QUEUE WorkQueue
   );

VOID
RxWorkerThreadDispatcher (
   IN PRX_WORK_QUEUE WorkQueue
   );

VOID
RxWorkItemDispatcher (
   PVOID Context
   );

BOOLEAN
RxIsPrefixTableEmpty (
    IN PRX_PREFIX_TABLE ThisTable
    );

PRX_PREFIX_ENTRY
RxTableLookupName_ExactLengthMatch (
    IN PRX_PREFIX_TABLE ThisTable,
    IN PUNICODE_STRING  Name,
    IN ULONG HashValue,
    IN PRX_CONNECTION_ID OPTIONAL RxConnectionId
    );

PVOID
RxTableLookupName (
    IN PRX_PREFIX_TABLE ThisTable,
    IN PUNICODE_STRING Name,
    OUT PUNICODE_STRING RemainingName,
    IN PRX_CONNECTION_ID OPTIONAL RxConnectionId
    );

VOID
RxAcquireFileForNtCreateSection (
    IN PFILE_OBJECT FileObject
    );

VOID
RxReleaseFileForNtCreateSection (
    IN PFILE_OBJECT FileObject
    );

NTSTATUS
RxPrepareRequestForHandling (
    PCHANGE_BUFFERING_STATE_REQUEST Request
    );

VOID
RxPrepareRequestForReuse (
    PCHANGE_BUFFERING_STATE_REQUEST Request
    );

VOID
RxpDiscardChangeBufferingStateRequests (
    IN OUT PLIST_ENTRY DiscardedRequests
    );

VOID
RxGatherRequestsForSrvOpen (
    IN OUT PSRV_CALL SrvCall,
    IN PSRV_OPEN SrvOpen,
    IN OUT PLIST_ENTRY RequestsListHead
    );

NTSTATUS
RxpLookupSrvOpenForRequestLite (
    IN PSRV_CALL SrvCall,
    IN OUT PCHANGE_BUFFERING_STATE_REQUEST Request
    );

BOOLEAN
RxContextCheckToFailThisAttempt (
    IN PIRP Irp,
    IN OUT PULONG InitialContextFlags
    );

ULONG
RxAssignMustSucceedContext (
    IN PIRP Irp,
    IN ULONG InitialContextFlags
    );

PRX_CONTEXT
RxAllocateMustSucceedContext (
    PIRP Irp,
    IN PRDBSS_DEVICE_OBJECT RxDeviceObject,
    IN ULONG InitialContextFlags,
    OUT PUCHAR MustSucceedDescriptorNumber
    );

VOID
RxFreeMustSucceedContext (
    PRX_CONTEXT RxContext
    );

PRX_LOG_ENTRY_HEADER
RxGetNextLogEntry (
    VOID
    );

VOID
RxPrintLog (
    IN ULONG EntriesToPrint OPTIONAL
    );

VOID
RxProcessChangeBufferingStateRequestsForSrvOpen (
    PSRV_OPEN SrvOpen
    );

NTSTATUS
RxPurgeFobxFromCache (
    PFOBX FobxToBePurged
    );

BOOLEAN
RxPurgeFobx (
   PFOBX pFobx
   );

VOID
RxPurgeAllFobxs (
    PRDBSS_DEVICE_OBJECT RxDeviceObject
    );

VOID
RxUndoScavengerFinalizationMarking (
    PVOID Instance
    );

VOID
RxScavengeAllFobxs (
    PRDBSS_DEVICE_OBJECT RxDeviceObject
    );

ULONG
RxTableComputePathHashValue (
    IN PUNICODE_STRING Name
    );

VOID
RxExtractServerName (
    IN PUNICODE_STRING FilePathName,
    OUT PUNICODE_STRING SrvCallName,
    OUT PUNICODE_STRING RestOfName
    );

VOID
RxCreateNetRootCallBack (
    IN PMRX_CREATENETROOT_CONTEXT CreateNetRootContext
    );

VOID
RxSpinDownOutstandingAsynchronousRequests (
    IN PRDBSS_DEVICE_OBJECT RxDeviceObject
    );

NTSTATUS
RxRegisterAsynchronousRequest (
    IN PRDBSS_DEVICE_OBJECT RxDeviceObject
    );

VOID
RxDeregisterAsynchronousRequest (
    IN PRDBSS_DEVICE_OBJECT RxDeviceObject
    );

BOOLEAN
RxCancelOperationInOverflowQueue (
    IN PRX_CONTEXT RxContext
    );

VOID
RxOrphanSrvOpens (
    IN PV_NET_ROOT ThisVNetRoot
    );

VOID
RxOrphanThisFcb (
    PFCB Fcb
    );

VOID
RxOrphanSrvOpensForThisFcb (
    IN PFCB Fcb,
    IN PV_NET_ROOT ThisVNetRoot,
    IN BOOLEAN OrphanAll
    );

VOID
RxForceFinalizeAllVNetRoots (
    PNET_ROOT NetRoot
    );

#define RxEqualConnectionId( P1, P2 ) RtlEqualMemory( P1, P2, sizeof( RX_CONNECTION_ID ) )


//
//  FsRtl lock package callbacks referenced in fcbstruc.c
//

NTSTATUS
RxLockOperationCompletion (
    IN PVOID Context,
    IN PIRP Irp
    );

VOID
RxUnlockOperation (
    IN PVOID Context,
    IN PFILE_LOCK_INFO LockInfo
    );

//
//  some read routines that need headers
//

VOID
RxStackOverflowRead (
    IN PVOID Context,
    IN PKEVENT Event
    );

NTSTATUS
RxPostStackOverflowRead (
    IN PRX_CONTEXT RxContext,
    IN PFCB Fcb
    );

//
//  the cancel routine
//

VOID
RxCancelRoutine (
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    );


INLINE
TYPE_OF_OPEN
RxDecodeFileObject ( 
    IN PFILE_OBJECT FileObject,
    OUT PFCB *Fcb,
    OUT PFOBX *Fobx
    ) {

    if (FileObject) {
        *Fcb = (PFCB)FileObject->FsContext;
        *Fobx = (PFOBX)FileObject->FsContext2;

        return NodeType( *Fcb );
    } else {

        *Fcb = NULL;
        *Fobx = NULL;
        return RDBSS_NTC_STORAGE_TYPE_UNKNOWN;
    }
}


#endif // _RDBSSPROCS_





#elif (NTDDI_VERSION >= NTDDI_WINXP)


/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    RxProcs.h

Abstract:

    This module defines all of the globally used procedures in the RDBSS
    file system.

Author:
Revision History:

--*/

#ifndef _RDBSSPROCS_
#define _RDBSSPROCS_

#include "rx.h"
#include "backpack.h"
#include "RxTypes.h"
#include "RxAssert.h"
#include "RxLog.h"
#include "RxTrace.h"
#include "RxTimer.h"
#include "RxStruc.h"

extern PVOID RxNull;

//
//  The following macro is for all people who compile with the DBG switch
//  set, not just rdbss dbg users
//

#if DBG

#define DbgDoit(X)         {X;}
#define DebugDoit(X)       {X;}
#define DEBUG_ONLY_DECL(X) X

#else

#define DbgDoit(X)        {NOTHING;}
#define DebugDoit(X)      {NOTHING;}
#define DEBUG_ONLY_DECL(X)

#endif // DBG


//
// utilities


//
// Routines for writing error log entries.
//

/*++

    RxLogFailure, RxLogFailureWithBuffer can be used to record an event in
    the log. The RxLogFailure, RxLogFailureWithBuffer captures the line
    number alongwith the supplied information and writes it to the log. This
    is useful in debugging. RxLogFailureDirect, RxLogBufferDirect do not
    capture the line number

    RxlogEvent is useful for writing events into the log.

--*/
#define RxLogFailure( _DeviceObject, _OriginatorId, _EventId, _Status ) \
            RxLogEventDirect( _DeviceObject, _OriginatorId, _EventId, _Status, __LINE__ )

#define RxLogFailureWithBuffer( _DeviceObject, _OriginatorId, _EventId, _Status, _Buffer, _Length ) \
            RxLogEventWithBufferDirect( _DeviceObject, _OriginatorId, _EventId, _Status, _Buffer, _Length, __LINE__ )

#define RxLogEvent( _DeviceObject, _OriginatorId, _EventId, _Status) \
            RxLogEventDirect(_DeviceObject, _OriginatorId, _EventId, _Status, __LINE__)

VOID
RxLogEventDirect (
    IN PRDBSS_DEVICE_OBJECT DeviceObject,
    IN PUNICODE_STRING      OriginatorId,
    IN ULONG                EventId,
    IN NTSTATUS             Status,
    IN ULONG                Line);

VOID
RxLogEventWithBufferDirect(
    IN PVOID            DeviceOrDriverObject,
    IN PUNICODE_STRING  OriginatorId,
    IN ULONG            EventId,
    IN NTSTATUS         Status,
    IN PVOID            DataBuffer,
    IN USHORT           DataBufferLength,
    IN ULONG            LineNumber);

VOID
RxLogEventWithAnnotation (
    IN PRDBSS_DEVICE_OBJECT DeviceObject,
    IN ULONG                EventId,
    IN NTSTATUS             Status,
    IN PVOID                DataBuffer,
    IN USHORT               DataBufferLength,
    IN PUNICODE_STRING      Annotation,
    IN ULONG                AnnotationCount);

BOOLEAN
RxCcLogError(
    IN PDEVICE_OBJECT DeviceObject,
    IN PUNICODE_STRING FileName,
    IN NTSTATUS Error,
    IN NTSTATUS DeviceError,
    IN UCHAR IrpMajorCode,
    IN PVOID Context
    );



//in create.c
NTSTATUS
RxPrefixClaim (
    IN PRX_CONTEXT RxContext
    );

VOID
RxpPrepareCreateContextForReuse(
    PRX_CONTEXT RxContext);

//in devfcb.c
LUID
RxGetUid (
    IN PSECURITY_SUBJECT_CONTEXT SubjectSecurityContext
    );

ULONG
RxGetSessionId (
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
RxFindOrCreateConnections (
    IN  PRX_CONTEXT            RxContext,
    IN  PUNICODE_STRING        CanonicalName,
    IN  NET_ROOT_TYPE          NetRootType,
    OUT PUNICODE_STRING        LocalNetRootName,
    OUT PUNICODE_STRING        FilePathName,
    IN OUT LOCK_HOLDING_STATE  *pLockHoldingState,
    IN  PRX_CONNECTION_ID      RxConnectionId
    );

NTSTATUS
RxFindOrCreateVNetRoot(
    PRX_CONTEXT        RxContext,
    PUNICODE_STRING    CanonicalName,
    NET_ROOT_TYPE      NetRootType,
    PV_NET_ROOT        *pVirtualNetRootPointer,
    LOCK_HOLDING_STATE *pLockHoldingState);

//in fileinfo.c
typedef enum _RX_NAME_CONJURING_METHODS {
    VNetRoot_As_Prefix,
    VNetRoot_As_UNC_Name,
    VNetRoot_As_DriveLetter
} RX_NAME_CONJURING_METHODS;

VOID
RxConjureOriginalName (
    IN PFCB   Fcb,
    IN PFOBX  Fobx,
    OUT PLONG pActualNameLength,
    PWCHAR OriginalName,
    IN OUT PLONG pLengthRemaining,
    IN RX_NAME_CONJURING_METHODS NameConjuringMethod
    );

//in cleanup.c
VOID
RxAdjustFileTimesAndSize ( RXCOMMON_SIGNATURE );

//
//  A function that returns finished denotes if it was able to complete the
//  operation (TRUE) or could not complete the operation (FALSE) because the
//  wait value stored in the irp context was false and we would have had
//  to block for a resource or I/O
//

typedef BOOLEAN FINISHED;

//
//   Buffer control routines for data caching, implemented in CacheSup.c
//

FINISHED
RxZeroData (
    IN PRX_CONTEXT RxContext,
    IN PVCB Vcb,
    IN PFILE_OBJECT FileObject,
    IN ULONG StartingZero,
    IN ULONG ByteCount
    );

NTSTATUS
RxCompleteMdl (
    IN PRX_CONTEXT RxContext
    );


VOID
RxSyncUninitializeCacheMap (
    IN PRX_CONTEXT RxContext,
    IN PFILE_OBJECT FileObject
    );

VOID
RxLockUserBuffer (
    IN PRX_CONTEXT RxContext,
    IN LOCK_OPERATION Operation,
    IN ULONG BufferLength
    );

PVOID
RxMapSystemBuffer (
    IN PRX_CONTEXT RxContext
    );

PVOID
RxNewMapUserBuffer (
    IN PRX_CONTEXT RxContext
    );

#define RxUpcaseEaName( RXCONTEXT, NAME, UPCASEDNAME ) \
    RtlUpperString( UPCASEDNAME, NAME )


//#define RxDissectName(RXCONTEXT,INPUT_STRING,FIRST_PART,REMAINING_PART) { \
//    FsRtlDissectDbcs( (INPUT_STRING),                                       \
//                      (FIRST_PART),                                         \
//                      (REMAINING_PART) );                                   \
//}
//
//
//#define RxDoesNameContainWildCards(RXCONTEXT,NAME) ( \
//    FsRtlDoesDbcsContainWildCards( &(NAME) )           \
//)
//
//
//#define RxAreNamesEqual(RXCONTEXT,NAMEA,NAMEB) (                         \
//    ((ULONG)(NAMEA).Length == (ULONG)(NAMEB).Length) &&                    \
//    (RtlCompareMemory( &(NAMEA).Buffer[0],                                 \
//                       &(NAMEB).Buffer[0],                                 \
//                       (NAMEA).Length ) == (NAMEA).Length )                \
//)
//
//
//#define RxIsNameValid(RXCONTEXT,NAME,CAN_CONTAIN_WILD_CARDS,PATH_NAME_OK,LEADING_BACKSLAH_OK) ( \
//    FsRtlIsFatDbcsLegal((NAME),                   \
//                        (CAN_CONTAIN_WILD_CARDS), \
//                        (PATH_NAME_OK),           \
//                        (LEADING_BACKSLAH_OK))    \
//)


//even though it passes a serial number, this parameter is not used
#ifdef RDBSS_TRACKER
#define RX_FCBTRACKER_PARAMS ,ULONG LineNumber,PSZ FileName,ULONG SerialNumber
#else
#define RX_FCBTRACKER_PARAMS
#endif

#define FCB_MODE_EXCLUSIVE (1)
#define FCB_MODE_SHARED    (2)
#define FCB_MODE_SHARED_WAIT_FOR_EXCLUSIVE (3)
#define FCB_MODE_SHARED_STARVE_EXCLUSIVE (4)

#define CHANGE_BUFFERING_STATE_CONTEXT      ((PRX_CONTEXT)IntToPtr(0xffffffff))
#define CHANGE_BUFFERING_STATE_CONTEXT_WAIT ((PRX_CONTEXT)IntToPtr(0xfffffffe))

NTSTATUS
__RxAcquireFcb(
     IN OUT PMRX_FCB     pFcb,
     IN OUT PRX_CONTEXT  pRxContext,
     IN     ULONG        Mode
     RX_FCBTRACKER_PARAMS
     );

#ifdef  RDBSS_TRACKER
#define RxAcquireExclusiveFcb(RXCONTEXT,FCB) \
        __RxAcquireFcb(RX_GET_MRX_FCB(FCB),(RXCONTEXT),FCB_MODE_EXCLUSIVE,__LINE__,__FILE__,0)
#else
#define RxAcquireExclusiveFcb(RXCONTEXT,FCB) \
        __RxAcquireFcb(RX_GET_MRX_FCB(FCB),(RXCONTEXT),FCB_MODE_EXCLUSIVE)
#endif

#define RX_GET_MRX_FCB(FCB) ((PMRX_FCB)((FCB)))

#ifdef  RDBSS_TRACKER
#define RxAcquireSharedFcb(RXCONTEXT,FCB) \
        __RxAcquireFcb(RX_GET_MRX_FCB(FCB),(RXCONTEXT),FCB_MODE_SHARED,__LINE__,__FILE__,0)
#else
#define RxAcquireSharedFcb(RXCONTEXT,FCB) \
        __RxAcquireFcb(RX_GET_MRX_FCB(FCB),(RXCONTEXT),FCB_MODE_SHARED)
#endif

#ifdef  RDBSS_TRACKER
#define RxAcquireSharedFcbWaitForEx(RXCONTEXT,FCB) \
        __RxAcquireFcb(RX_GET_MRX_FCB(FCB),(RXCONTEXT),FCB_MODE_SHARED_WAIT_FOR_EXCLUSIVE,__LINE__,__FILE__,0)
#else
#define RxAcquireSharedFcbWaitForEx(RXCONTEXT,FCB) \
        __RxAcquireFcb(RX_GET_MRX_FCB(FCB),(RXCONTEXT),FCB_MODE_SHARED_WAIT_FOR_EXCLUSIVE)
#endif

#ifdef  RDBSS_TRACKER
#define RxAcquireSharedFcbStarveEx(RXCONTEXT,FCB) \
        __RxAcquireFcb(RX_GET_MRX_FCB(FCB),(RXCONTEXT),FCB_MODE_SHARED_STARVE_EXCLUSIVE,__LINE__,__FILE__,0)
#else
#define RxAcquireSharedFcbStarveEx(RXCONTEXT,FCB) \
        __RxAcquireFcb(RX_GET_MRX_FCB(FCB),(RXCONTEXT),FCB_MODE_SHARED_STARVE_EXCLUSIVE)
#endif


VOID
__RxReleaseFcb(
    IN PRX_CONTEXT pRxContext,
    IN PMRX_FCB    pFcb
    RX_FCBTRACKER_PARAMS
    );

#ifdef  RDBSS_TRACKER
#define RxReleaseFcb(RXCONTEXT,FCB) \
        __RxReleaseFcb((RXCONTEXT),RX_GET_MRX_FCB(FCB),__LINE__,__FILE__,0)
#else
#define RxReleaseFcb(RXCONTEXT,FCB) \
        __RxReleaseFcb((RXCONTEXT),RX_GET_MRX_FCB(FCB))
#endif

VOID
__RxReleaseFcbForThread(
    IN PRX_CONTEXT      pRxContext,
    IN PMRX_FCB         pFcb,
    IN ERESOURCE_THREAD ResourceThreadId
    RX_FCBTRACKER_PARAMS
    );

#ifdef  RDBSS_TRACKER
#define RxReleaseFcbForThread(RXCONTEXT,FCB,THREAD) \
        __RxReleaseFcbForThread((RXCONTEXT),RX_GET_MRX_FCB(FCB),(THREAD),__LINE__,__FILE__,0)
#else
#define RxReleaseFcbForThread(RXCONTEXT,FCB,THREAD) \
        __RxReleaseFcbForThread((RXCONTEXT),RX_GET_MRX_FCB(FCB),(THREAD))
#endif

#ifdef RDBSS_TRACKER
VOID RxTrackerUpdateHistory(
    PRX_CONTEXT pRxContext,
    PMRX_FCB pFcb,
    ULONG Operation
    RX_FCBTRACKER_PARAMS
    );
#else
#define RxTrackerUpdateHistory(xRXCONTEXT,xFCB,xOPERATION,xLINENUM,xFILENAME,xSERIALNUMBER) {NOTHING;}
#endif

VOID RxTrackPagingIoResource(
    PVOID       pInstance,
    ULONG       Type,
    ULONG       Line,
    PCHAR       File);

//this definition is old......i don't like the format
#define RxFcbAcquiredShared(RXCONTEXT,FCB) (                      \
    ExIsResourceAcquiredSharedLite(RX_GET_MRX_FCB(FCB)->Header.Resource) \
)

#define RxIsFcbAcquiredShared(FCB) (                      \
    ExIsResourceAcquiredSharedLite(RX_GET_MRX_FCB(FCB)->Header.Resource) \
)

#define RxIsFcbAcquiredExclusive(FCB) (                      \
    ExIsResourceAcquiredExclusiveLite(RX_GET_MRX_FCB(FCB)->Header.Resource) \
)

#define RxIsFcbAcquired(FCB) (                      \
    ExIsResourceAcquiredSharedLite(RX_GET_MRX_FCB(FCB)->Header.Resource) | \
    ExIsResourceAcquiredExclusiveLite(RX_GET_MRX_FCB(FCB)->Header.Resource) \
)

#define RxAcquirePagingIoResource(FCB,RxContext)                       \
    ExAcquireResourceExclusiveLite(RX_GET_MRX_FCB(FCB)->Header.PagingIoResource,TRUE);  \
    if (RxContext) { \
        ((PRX_CONTEXT)RxContext)->FcbPagingIoResourceAcquired = TRUE;   \
    } \
    RxTrackPagingIoResource(FCB,1,__LINE__,__FILE__) \

#define RxAcquirePagingIoResourceShared(FCB,FLAG,RxContext) \
    ExAcquireResourceSharedLite(RX_GET_MRX_FCB(FCB)->Header.PagingIoResource,FLAG); \
    if (AcquiredFile) {                                          \
        if (RxContext) {                                     \
            ((PRX_CONTEXT)RxContext)->FcbPagingIoResourceAcquired = TRUE;   \
        }                                                    \
        RxTrackPagingIoResource(FCB,2,__LINE__,__FILE__);    \
    }

#define RxReleasePagingIoResource(FCB,RxContext)                       \
    RxTrackPagingIoResource(FCB,3,__LINE__,__FILE__); \
    if (RxContext) { \
        ((PRX_CONTEXT)RxContext)->FcbPagingIoResourceAcquired = FALSE;   \
    } \
    ExReleaseResourceLite(RX_GET_MRX_FCB(FCB)->Header.PagingIoResource)

#define RxReleasePagingIoResourceForThread(FCB,THREAD,RxContext)    \
    RxTrackPagingIoResource(FCB,3,__LINE__,__FILE__); \
    if (RxContext) { \
        ((PRX_CONTEXT)RxContext)->FcbPagingIoResourceAcquired = FALSE;   \
    } \
    ExReleaseResourceForThreadLite(RX_GET_MRX_FCB(FCB)->Header.PagingIoResource,(THREAD))


//  The following are cache manager call backs

BOOLEAN
RxAcquireFcbForLazyWrite (
    IN PVOID Null,
    IN BOOLEAN Wait
    );

VOID
RxReleaseFcbFromLazyWrite (
    IN PVOID Null
    );

BOOLEAN
RxAcquireFcbForReadAhead (
    IN PVOID Null,
    IN BOOLEAN Wait
    );

VOID
RxReleaseFcbFromReadAhead (
    IN PVOID Null
    );

BOOLEAN
RxNoOpAcquire (
    IN PVOID Fcb,
    IN BOOLEAN Wait
    );

VOID
RxNoOpRelease (
    IN PVOID Fcb
    );

NTSTATUS
RxAcquireForCcFlush (
    IN PFILE_OBJECT FileObject,
    IN PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
RxReleaseForCcFlush (
    IN PFILE_OBJECT FileObject,
    IN PDEVICE_OBJECT DeviceObject
    );

//
//  VOID
//  RxConvertToSharedFcb (
//      IN PRX_CONTEXT RxContext,
//      IN PFCB Fcb
//      );
//

#define RxConvertToSharedFcb(RXCONTEXT,FCB) {                        \
    ExConvertExclusiveToSharedLite( RX_GET_MRX_FCB(FCB)->Header.Resource ); \
    }

VOID
RxVerifyOperationIsLegal (
    IN PRX_CONTEXT RxContext
    );

//
//  Work queue routines for posting and retrieving an Irp, implemented in
//  workque.c
//

VOID
RxOplockComplete (
    IN PVOID Context,
    IN PIRP Irp
    );

VOID
RxPrePostIrp (
    IN PVOID Context,
    IN PIRP Irp
    );

VOID
RxAddToWorkque (
    IN PRX_CONTEXT RxContext,
    IN PIRP Irp
    );

NTSTATUS
RxFsdPostRequest (
    IN PRX_CONTEXT RxContext
    );

#define RxFsdPostRequestWithResume(RXCONTEXT,RESUMEROUTINE) \
        (((RXCONTEXT)->ResumeRoutine=(RESUMEROUTINE)),   \
         RxFsdPostRequest((RXCONTEXT)) \
        )

VOID
RxInitializeMRxCalldownContext(
    PMRX_CALLDOWN_CONTEXT pContext,
    PRDBSS_DEVICE_OBJECT  pMRxDeviceObject,
    PMRX_CALLDOWN_ROUTINE pRoutine,
    PVOID                 pParameter);

NTSTATUS
RxCalldownMiniRedirectors(
    LONG                  NumberOfMiniRdrs,
    PMRX_CALLDOWN_CONTEXT pCalldownContext,
    BOOLEAN               PostCalldowns);

//
//  This macro takes a ulong and returns its rounded up word value
//

#define WordAlign(Val) (                    \
    ALIGN_UP( Val, WORD )                   \
    )

//
//  This macro takes a pointer and returns a ULONG_PTR representation of
//  its rounded up word value
//

#define WordAlignPtr(Ptr) (                 \
    ALIGN_UP_POINTER( Ptr, WORD )           \
    )

//
//  This macro takes a ulong and returns its rounded up longword value
//

#define LongAlign(Val) (                    \
    ALIGN_UP( Val, LONG )                   \
    )

//
//  This macro takes a pointer and returns a ULONG_PTR representation of
//  its rounded up word value
//

#define LongAlignPtr(Ptr) (                 \
    ALIGN_UP_POINTER( Ptr, LONG )           \
    )

//
//  This macro takes a ulong and returns its rounded up quadword
//  value
//

#define QuadAlign(Val) (                    \
    ALIGN_UP( Val, ULONGLONG )              \
    )

//
//  This macro takes a pointer and returns a ULONG_PTR representation of
//  its rounded up quadword value
//

#define QuadAlignPtr(Ptr) (                 \
    ALIGN_UP_POINTER( Ptr, ULONGLONG )      \
    )

//
//  This macro takes a pointer and returns whether it's quadword-aligned
//

#define IsPtrQuadAligned(Ptr) (           \
    QuadAlignPtr(Ptr) == (PVOID)(Ptr)     \
    )

//
//  The following types and macros are used to help unpack the packed and
//  misaligned fields found in the Bios parameter block
//

typedef union _UCHAR1 {
    UCHAR  Uchar[1];
    UCHAR  ForceAlignment;
} UCHAR1, *PUCHAR1;

typedef union _UCHAR2 {
    UCHAR  Uchar[2];
    USHORT ForceAlignment;
} UCHAR2, *PUCHAR2;

typedef union _UCHAR4 {
    UCHAR  Uchar[4];
    ULONG  ForceAlignment;
} UCHAR4, *PUCHAR4;

//
//  This macro copies an unaligned src byte to an aligned dst byte
//

#define CopyUchar1(Dst,Src) {                                \
    *((UCHAR1 *)(Dst)) = *((UNALIGNED UCHAR1 *)(Src)); \
    }

//
//  This macro copies an unaligned src word to an aligned dst word
//

#define CopyUchar2(Dst,Src) {                                \
    *((UCHAR2 *)(Dst)) = *((UNALIGNED UCHAR2 *)(Src)); \
    }

//
//  This macro copies an unaligned src longword to an aligned dsr longword
//

#define CopyUchar4(Dst,Src) {                                \
    *((UCHAR4 *)(Dst)) = *((UNALIGNED UCHAR4 *)(Src)); \
    }

#define CopyU4char(Dst,Src) {                                \
    *((UNALIGNED UCHAR4 *)(Dst)) = *((UCHAR4 *)(Src)); \
    }

//
//
// the wrapper doesn't yet implement notify and oplock. rather than remove the code
// we define the calls in such a way as to Noop the effects so that we'll have a head
// start on putting it back later...


/* this is a macro definition we'll reenable when we implement oplocks and notifies
//
//  VOID
//  RxNotifyReportChange (
//      IN PRX_CONTEXT RxContext,
//      IN PVCB Vcb,
//      IN PFCB Fcb,
//      IN ULONG Filter,
//      IN ULONG Action
//      );
//

#define RxNotifyReportChange(I,V,F,FL,A) {                             \
    if ((F)->FullFileName.Buffer == NULL) {                             \
        RxSetFullFileNameInFcb((I),(F));                               \
    }                                                                   \
    FsRtlNotifyFullReportChange( (V)->NotifySync,                       \
                                 &(V)->DirNotifyList,                   \
                                 (PSTRING)&(F)->FullFileName,           \
                                 (USHORT) ((F)->FullFileName.Length -   \
                                           (F)->FinalNameLength),       \
                                 (PSTRING)NULL,                         \
                                 (PSTRING)NULL,                         \
                                 (ULONG)FL,                             \
                                 (ULONG)A,                              \
                                 (PVOID)NULL );                         \
}
*/
#define RxNotifyReportChange(I,V,F,FL,A) \
    RxDbgTrace(0, Dbg, ("RxNotifyReportChange PRETENDING Fcb %08lx %wZ Filter/Action = %08lx/%08lx\n", \
                 (F),&((F)->FcbTableEntry.Path),(FL),(A)))

#if 0
#define FsRtlNotifyFullChangeDirectory(A1,A2,A3,A4,A5,A6,A7,A8,A9,A10) \
    RxDbgTrace(0, Dbg, ("FsRtlNotifyFullReportChange PRETENDING ............\n",0))
#endif

#define FsRtlCheckOplock(A1,A2,A3,A4,A5)  \
        (STATUS_SUCCESS)

#define FsRtlOplockIsFastIoPossible(__a) (TRUE)
//
//  The following procedure is used by the FSP and FSD routines to complete
//  an IRP.
//
//  Note that this macro allows either the Irp or the RxContext to be
//  null, however the only legal order to do this in is:
//
//      RxCompleteRequest_OLD( NULL, Irp, Status );  // completes Irp & preserves context
//      ...
//      RxCompleteRequest_OLD( RxContext, NULL, DontCare ); // deallocates context
//
//  This would typically be done in order to pass a "naked" RxContext off to
//  the Fsp for post processing, such as read ahead.
//
//  The new way is to pass just the RxContext..........

VOID
RxCompleteRequest_Real (
    IN PRX_CONTEXT RxContext,
    IN PIRP Irp,
    IN NTSTATUS Status
    );

#if DBG
#define RxCompleteRequest_OLD(RXCONTEXT,IRP,STATUS) { \
    RxCompleteRequest_Real(RXCONTEXT,IRP,STATUS); \
    (IRP) = NULL;                                   \
    (RXCONTEXT) = NULL;                            \
}
#else
#define RxCompleteRequest_OLD(RXCONTEXT,IRP,STATUS) { \
    RxCompleteRequest_Real(RXCONTEXT,IRP,STATUS); \
}
#endif

NTSTATUS
RxCompleteRequest(
      PRX_CONTEXT pContext,
      NTSTATUS    Status);

#define RxCompleteAsynchronousRequest(RXCONTEXT,STATUS)  \
        RxCompleteRequest(RXCONTEXT,STATUS)

#define RxCompleteContextAndReturn(STATUS) {       \
             NTSTATUS __sss = (STATUS);             \
             RxCompleteRequest(RxContext,__sss); \
             return(__sss);}
#define RxCompleteContext(STATUS) {       \
             NTSTATUS __sss = (STATUS);             \
             RxCompleteRequest(RxContext,__sss);} \

//
//  The Following routine makes a popup
//

VOID
RxPopUpFileCorrupt (
    IN PRX_CONTEXT RxContext,
    IN PFCB Fcb
    );

NTSTATUS
RxConstructSrvCall(
    PRX_CONTEXT       pRxContext,
    PSRV_CALL          pSrvCall,
    LOCK_HOLDING_STATE *pLockHoldingState);

NTSTATUS
RxSetSrvCallDomainName(
    PMRX_SRV_CALL    pSrvCall,
    PUNICODE_STRING  pDomainName);

NTSTATUS
RxConstructNetRoot(
    PRX_CONTEXT                 pRxContext,
    PSRV_CALL                   pSrvCall,
    PNET_ROOT                   pNetRoot,
    PV_NET_ROOT                 pVirtualNetRoot,
    LOCK_HOLDING_STATE          *pLockHoldingState);

NTSTATUS
RxConstructVirtualNetRoot(
    PRX_CONTEXT        RxContext,
    PUNICODE_STRING    CanonicalName,
    NET_ROOT_TYPE      NetRootType,
    PV_NET_ROOT        *pVirtualNetRootPointer,
    LOCK_HOLDING_STATE *pLockHoldingState,
    PRX_CONNECTION_ID  RxConnectionId);

NTSTATUS
RxFindOrConstructVirtualNetRoot(
    PRX_CONTEXT        RxContext,
    PUNICODE_STRING    CanonicalName,
    NET_ROOT_TYPE      NetRootType,
    PUNICODE_STRING    RemainingName);

NTSTATUS
RxLowIoFsCtlShell (
    IN PRX_CONTEXT RxContext
    );

NTSTATUS
RxLowIoFsCtlShellCompletion (
    IN PRX_CONTEXT RxContext
    );


NTSTATUS
RxLowIoLockControlShell (
    IN PRX_CONTEXT RxContext
    );

NTSTATUS
RxChangeBufferingState(
    PSRV_OPEN              SrvOpen,
    PVOID                  Context,
    BOOLEAN                ComputeNewState
    );

VOID
RxAssociateSrvOpenKey(
    PMRX_SRV_OPEN pMRxSrvOpen,
    PVOID         SrvOpenKey);

VOID
RxIndicateChangeOfBufferingState(
    PMRX_SRV_CALL pSrvCall,
    PVOID         SrvOpenKey,
    PVOID         pContext);

VOID
RxIndicateChangeOfBufferingStateForSrvOpen(
    PMRX_SRV_CALL pSrvCall,
    PMRX_SRV_OPEN pSrvOpen,
    PVOID         SrvOpenKey,
    PVOID         pContext);


NTSTATUS
RxPrepareToReparseSymbolicLink(
    PRX_CONTEXT     RxContext,
    BOOLEAN         SymbolicLinkEmbeddedInOldPath,
    PUNICODE_STRING pNewPath,
    BOOLEAN         NewPathIsAbsolute,
    BOOLEAN         *pReparseRequired);

BOOLEAN
RxLockEnumerator (
    IN OUT struct _MRX_SRV_OPEN_ * SrvOpen,
    IN OUT PVOID *ContinuationHandle,
       OUT PLARGE_INTEGER FileOffset,
       OUT PLARGE_INTEGER LockRange,
       OUT PBOOLEAN IsLockExclusive
    );

//
// Routines for transitioning data structures to stable states.
//

VOID
RxReference(
    IN OUT PVOID pInstance);

VOID
RxDereference(
    IN OUT PVOID              pInstance,
    IN     LOCK_HOLDING_STATE LockHoldingState);

VOID
RxWaitForStableCondition(
    IN     PRX_BLOCK_CONDITION pCondition,
    IN OUT PLIST_ENTRY         pTransitionWaitList,
    IN OUT PRX_CONTEXT         RxContext,
    OUT    NTSTATUS            *AsyncStatus OPTIONAL);

VOID
RxUpdateCondition(
    IN     RX_BLOCK_CONDITION NewConditionValue,
       OUT RX_BLOCK_CONDITION *pCondition,
    IN OUT PLIST_ENTRY        pTransitionWaitList);

VOID
RxFinalizeNetTable(
    PRDBSS_DEVICE_OBJECT RxDeviceObject,
    BOOLEAN fForceFinalization);

#define RxForceNetTableFinalization(RxDeviceObject) \
            RxFinalizeNetTable(RxDeviceObject,TRUE)

NTSTATUS
RxCloseAssociatedSrvOpen(
    PFOBX       pFobx,
    PRX_CONTEXT RxContext);

NTSTATUS
RxFinalizeConnection(
    IN OUT PNET_ROOT NetRoot,
    IN OUT PV_NET_ROOT VNetRoot OPTIONAL,
    IN BOOLEAN ForceFilesClosed
    );


// routines for manipulating the user's view and the server's view of SHARE_ACCESS.
// the user's view is supported by routines exported by Io...the wrappers just allow
// us to get a msg. the server's view is supported by routines that are essential just
// copies of the Io routines EXCEPT that the Io routines work directly on fileobjects and
// as such cannot be used directly. the routines mentioned are implemented in create.c

#if DBG
VOID
RxDumpWantedAccess(
    PSZ where1,
    PSZ where2,
    PSZ wherelogtag,
    IN ACCESS_MASK DesiredAccess,
    IN ULONG DesiredShareAccess
   );

VOID
RxDumpCurrentAccess(
    PSZ where1,
    PSZ where2,
    PSZ wherelogtag,
    PSHARE_ACCESS ShareAccess
    );
#else
#define RxDumpWantedAccess(w1,w2,wlt,DA,DSA) {NOTHING;}
#define RxDumpCurrentAccess(w1,w2,wlt,SA)  {NOTHING;}
#endif

NTSTATUS
RxCheckShareAccessPerSrvOpens(
    IN PFCB Fcb,
    IN ACCESS_MASK DesiredAccess,
    IN ULONG DesiredShareAccess
    );


VOID
RxUpdateShareAccessPerSrvOpens(
    IN PSRV_OPEN SrvOpen
    );

VOID
RxRemoveShareAccessPerSrvOpens(
    IN OUT PSRV_OPEN SrvOpen
    );

VOID
RxRemoveShareAccessPerSrvOpens(
    IN OUT PSRV_OPEN SrvOpen
    );


#if DBG
NTSTATUS
RxCheckShareAccess(
    IN ACCESS_MASK DesiredAccess,
    IN ULONG DesiredShareAccess,
    IN OUT PFILE_OBJECT FileObject,
    IN OUT PSHARE_ACCESS ShareAccess,
    IN BOOLEAN Update,
    IN PSZ where,
    IN PSZ wherelogtag
    );

VOID
RxRemoveShareAccess(
    IN PFILE_OBJECT FileObject,
    IN OUT PSHARE_ACCESS ShareAccess,
    IN PSZ where,
    IN PSZ wherelogtag
    );

VOID
RxSetShareAccess(
    IN ACCESS_MASK DesiredAccess,
    IN ULONG DesiredShareAccess,
    IN OUT PFILE_OBJECT FileObject,
    OUT PSHARE_ACCESS ShareAccess,
    IN PSZ where,
    IN PSZ wherelogtag
    );

VOID
RxUpdateShareAccess(
    IN PFILE_OBJECT FileObject,
    IN OUT PSHARE_ACCESS ShareAccess,
    IN PSZ where,
    IN PSZ wherelogtag
    );
#else
#define RxCheckShareAccess(a1,a2,a3,a4,a5,a6,a7) \
    IoCheckShareAccess(a1,a2,a3,a4,a5)

#define RxRemoveShareAccess(a1,a2,a3,a4) \
    IoRemoveShareAccess(a1,a2)

#define RxSetShareAccess(a1,a2,a3,a4,a5,a6) \
    IoSetShareAccess(a1,a2,a3,a4)

#define RxUpdateShareAccess(a1,a2,a3,a4) \
    IoUpdateShareAccess(a1,a2)
#endif

//LoadUnload

NTSTATUS
RxDriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

VOID
RxUnload(
    IN PDRIVER_OBJECT DriverObject
    );

//minirdr support

VOID
RxInitializeMinirdrDispatchTable(
    IN PDRIVER_OBJECT DriverObject
    );

ULONG
RxGetNetworkProviderPriority(
    PUNICODE_STRING DeviceName
    );

VOID
RxExtractServerName(
    IN PUNICODE_STRING FilePathName,
    OUT PUNICODE_STRING SrvCallName,
    OUT PUNICODE_STRING RestOfName
    );

VOID
RxCreateNetRootCallBack (
    IN PMRX_CREATENETROOT_CONTEXT pCreateNetRootContext
    );

NTSTATUS
DuplicateTransportAddress(
    PTRANSPORT_ADDRESS *pCopy,
    PTRANSPORT_ADDRESS pOriginal,
    POOL_TYPE          PoolType);

NTSTATUS
RxCepInitializeVC(
    PRXCE_VC         pVc,
    PRXCE_CONNECTION pConnection);

NTSTATUS
DuplicateConnectionInformation(
    PRXCE_CONNECTION_INFORMATION *pCopy,
    PRXCE_CONNECTION_INFORMATION pOriginal,
    POOL_TYPE                    PoolType);

NTSTATUS
RxCepInitializeConnection(
    IN OUT PRXCE_CONNECTION             pConnection,
    IN     PRXCE_ADDRESS                pAddress,
    IN     PRXCE_CONNECTION_INFORMATION pConnectionInformation,
    IN  PRXCE_CONNECTION_EVENT_HANDLER  pHandler,
    IN  PVOID                           pEventContext);

NTSTATUS
RxCeInitiateConnectRequest(
    struct _RX_CALLOUT_PARAMETERS_BLOCK_ *pParameterBlock);

VOID
RxCeCleanupConnectCallOutContext(
    struct _RX_CREATE_CONNECTION_CALLOUT_CONTEXT_ *pCreateConnectionContext);

PVOID
RxAllocateObject(
    NODE_TYPE_CODE    NodeType,
    PMINIRDR_DISPATCH pMRxDispatch,
    ULONG             NameLength);

VOID
RxFreeObject(PVOID pObject);

NTSTATUS
RxInitializeSrvCallParameters(
    PRX_CONTEXT RxContext,
    PSRV_CALL   SrvCall);

VOID
RxAddVirtualNetRootToNetRoot(
    PNET_ROOT   pNetRoot,
    PV_NET_ROOT pVNetRoot);

VOID
RxRemoveVirtualNetRootFromNetRoot(
    PNET_ROOT   pNetRoot,
    PV_NET_ROOT pVNetRoot);

VOID
RxOrphanFcbsFromThisVNetRoot (
    IN PV_NET_ROOT ThisVNetRoot
    );

PVOID
RxAllocateFcbObject(
    PRDBSS_DEVICE_OBJECT RxDeviceObject,
    NODE_TYPE_CODE    NodeType,
    POOL_TYPE         PoolType,
    ULONG             NameSize,
    PVOID             pAlreadyAllocatedObject);

VOID
RxFreeFcbObject(PVOID pObject);

VOID
RxPurgeFcb(
    IN  PFCB pFcb);

BOOLEAN
RxFinalizeNetFcb (
    OUT PFCB ThisFcb,
    IN  BOOLEAN   RecursiveFinalize,
    IN  BOOLEAN   ForceFinalize,
    IN  LONG      ReferenceCount
    );

VOID
RxCheckFcbStructuresForAlignment(void);

VOID
RxpPrepareCreateContextForReuse(
    PRX_CONTEXT RxContext);

NTSTATUS
RxLowIoSubmitRETRY (
    IN PRX_CONTEXT RxContext
    );

NTSTATUS
RxLowIoCompletionTail (
    IN PRX_CONTEXT RxContext
    );

VOID
RxRecurrentTimerWorkItemDispatcher (
    IN PVOID Context
    );

NTSTATUS
RxInitializeWorkQueueDispatcher(
   PRX_WORK_QUEUE_DISPATCHER pDispatcher);

VOID
RxInitializeWorkQueue(
   PRX_WORK_QUEUE  pWorkQueue,
   WORK_QUEUE_TYPE WorkQueueType,
   ULONG           MaximumNumberOfWorkerThreads,
   ULONG           MinimumNumberOfWorkerThreads);

VOID
RxTearDownWorkQueueDispatcher(
   PRX_WORK_QUEUE_DISPATCHER pDispatcher);

VOID
RxTearDownWorkQueue(
   PRX_WORK_QUEUE pWorkQueue);

NTSTATUS
RxSpinUpWorkerThread(
   PRX_WORK_QUEUE           pWorkQueue,
   PRX_WORKERTHREAD_ROUTINE Routine,
   PVOID                    Parameter);

VOID
RxSpinUpWorkerThreads(
   PRX_WORK_QUEUE pWorkQueue);

VOID
RxSpinUpRequestsDispatcher(
    PRX_DISPATCHER pDispatcher);

VOID
RxpSpinUpWorkerThreads(
    PRX_WORK_QUEUE pWorkQueue);

VOID
RxpWorkerThreadDispatcher(
   IN PRX_WORK_QUEUE pWorkQueue,
   IN PLARGE_INTEGER pWaitInterval);

VOID
RxBootstrapWorkerThreadDispatcher(
   IN PRX_WORK_QUEUE pWorkQueue);

VOID
RxWorkerThreadDispatcher(
   IN PRX_WORK_QUEUE pWorkQueue);

VOID
RxWorkItemDispatcher(
   PVOID    pContext);

BOOLEAN
RxIsPrefixTableEmpty(
    IN PRX_PREFIX_TABLE   ThisTable);

PRX_PREFIX_ENTRY
RxTableLookupName_ExactLengthMatch (
    IN  PRX_PREFIX_TABLE ThisTable,
    IN  PUNICODE_STRING  Name,
    IN  ULONG            HashValue,
    IN  PRX_CONNECTION_ID OPTIONAL RxConnectionId
    );

PVOID
RxTableLookupName (
    IN  PRX_PREFIX_TABLE ThisTable,
    IN  PUNICODE_STRING  Name,
    OUT PUNICODE_STRING  RemainingName,
    IN  PRX_CONNECTION_ID OPTIONAL RxConnectionId
    );

VOID
RxAcquireFileForNtCreateSection (
    IN PFILE_OBJECT FileObject
    );

VOID
RxReleaseFileForNtCreateSection (
    IN PFILE_OBJECT FileObject
    );

NTSTATUS
RxPrepareRequestForHandling(
    PCHANGE_BUFFERING_STATE_REQUEST pRequest);

VOID
RxPrepareRequestForReuse(
    PCHANGE_BUFFERING_STATE_REQUEST pRequest);

VOID
RxpDiscardChangeBufferingStateRequests(
    IN OUT PLIST_ENTRY pDiscardedRequests);

VOID
RxGatherRequestsForSrvOpen(
    IN OUT PSRV_CALL     pSrvCall,
    IN     PSRV_OPEN     pSrvOpen,
    IN OUT PLIST_ENTRY   pRequestsListHead);

NTSTATUS
RxpLookupSrvOpenForRequestLite(
    IN     PSRV_CALL                       pSrvCall,
    IN OUT PCHANGE_BUFFERING_STATE_REQUEST pRequest);

BOOLEAN
RxContextCheckToFailThisAttempt(
    IN PIRP Irp,
    IN OUT ULONG* InitialContextFlags
    );

ULONG
RxAssignMustSucceedContext(
    IN PIRP Irp,
    IN ULONG InitialContextFlags
    );

PRX_CONTEXT
RxAllocateMustSucceedContext(
    PIRP                    Irp,
    IN PRDBSS_DEVICE_OBJECT RxDeviceObject,
    IN ULONG                InitialContextFlags,
    OUT PUCHAR              MustSucceedDescriptorNumber
    );

VOID
RxFreeMustSucceedContext(
    PRX_CONTEXT RxContext
    );

PRX_LOG_ENTRY_HEADER
RxGetNextLogEntry(void);

VOID
RxPrintLog (
    IN ULONG EntriesToPrint OPTIONAL
    );

VOID
RxProcessChangeBufferingStateRequestsForSrvOpen(
      PSRV_OPEN pSrvOpen);

NTSTATUS
RxPurgeFobxFromCache(
    PFOBX   pFobxToBePurged);

BOOLEAN
RxPurgeFobx(
   PFOBX pFobx);

VOID
RxPurgeAllFobxs(
    PRDBSS_DEVICE_OBJECT RxDeviceObject);

VOID
RxUndoScavengerFinalizationMarking(
    PVOID pInstance);

VOID
RxScavengeAllFobxs(
    PRDBSS_DEVICE_OBJECT RxDeviceObject);

ULONG
RxTableComputePathHashValue (
    IN  PUNICODE_STRING  Name
    );

VOID
RxExtractServerName(
    IN PUNICODE_STRING FilePathName,
    OUT PUNICODE_STRING SrvCallName,
    OUT PUNICODE_STRING RestOfName
    );

VOID
RxCreateNetRootCallBack (
    IN PMRX_CREATENETROOT_CONTEXT pCreateNetRootContext
    );

VOID
RxSpinDownOutstandingAsynchronousRequests(
    PRDBSS_DEVICE_OBJECT RxDeviceObject);

NTSTATUS
RxRegisterAsynchronousRequest(
    PRDBSS_DEVICE_OBJECT RxDeviceObject);

VOID
RxDeregisterAsynchronousRequest(
    PRDBSS_DEVICE_OBJECT RxDeviceObject);


BOOLEAN
RxCancelOperationInOverflowQueue(
    PRX_CONTEXT RxContext);

VOID
RxOrphanSrvOpens(
    IN  PV_NET_ROOT ThisVNetRoot
    );


VOID
RxOrphanThisFcb(
    PFCB    pFcb
    );

VOID
RxOrphanSrvOpensForThisFcb(
    PFCB            pFcb,
    IN PV_NET_ROOT  ThisVNetRoot,
    BOOLEAN         fOrphanAll
    );

VOID
RxForceFinalizeAllVNetRoots(
    PNET_ROOT   pNetRoot
    );

#define RxEqualConnectionId( P1, P2 ) RtlEqualMemory( P1, P2, sizeof(RX_CONNECTION_ID) )

#endif // _RDBSSPROCS_





#elif (NTDDI_VERSION >= NTDDI_WIN2K)


/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    RxProcs.h

Abstract:

    This module defines all of the globally used procedures in the RDBSS
    file system.

Author:
Revision History:

--*/

#ifndef _RDBSSPROCS_
#define _RDBSSPROCS_

#include "rx.h"
#include "backpack.h"
#include "RxTypes.h"
#include "RxAssert.h"
#include "RxLog.h"
#include "RxTrace.h"
#include "RxTimer.h"
#include "RxStruc.h"

extern PVOID RxNull;

//
//  The following macro is for all people who compile with the DBG switch
//  set, not just rdbss dbg users
//

#if DBG

#define DbgDoit(X)         {X;}
#define DebugDoit(X)       {X;}
#define DEBUG_ONLY_DECL(X) X

#else

#define DbgDoit(X)        {NOTHING;}
#define DebugDoit(X)      {NOTHING;}
#define DEBUG_ONLY_DECL(X)

#endif // DBG


//
// utilities


//
// Routines for writing error log entries.
//

/*++

    RxLogFailure, RxLogFailureWithBuffer can be used to record an event in
    the log. The RxLogFailure, RxLogFailureWithBuffer captures the line
    number alongwith the supplied information and writes it to the log. This
    is useful in debugging. RxLogFailureDirect, RxLogBufferDirect do not
    capture the line number

    RxlogEvent is useful for writing events into the log.

--*/
#define RxLogFailure( _DeviceObject, _OriginatorId, _EventId, _Status ) \
            RxLogEventDirect( _DeviceObject, _OriginatorId, _EventId, _Status, __LINE__ )

#define RxLogFailureWithBuffer( _DeviceObject, _OriginatorId, _EventId, _Status, _Buffer, _Length ) \
            RxLogEventWithBufferDirect( _DeviceObject, _OriginatorId, _EventId, _Status, _Buffer, _Length, __LINE__ )

#define RxLogEvent( _DeviceObject, _OriginatorId, _EventId, _Status) \
            RxLogEventDirect(_DeviceObject, _OriginatorId, _EventId, _Status, __LINE__)

VOID
RxLogEventDirect (
    IN PRDBSS_DEVICE_OBJECT DeviceObject,
    IN PUNICODE_STRING      OriginatorId,
    IN ULONG                EventId,
    IN NTSTATUS             Status,
    IN ULONG                Line);

VOID
RxLogEventWithBufferDirect(
    IN PVOID            DeviceOrDriverObject,
    IN PUNICODE_STRING  OriginatorId,
    IN ULONG            EventId,
    IN NTSTATUS         Status,
    IN PVOID            DataBuffer,
    IN USHORT           DataBufferLength,
    IN ULONG            LineNumber);

VOID
RxLogEventWithAnnotation (
    IN PRDBSS_DEVICE_OBJECT DeviceObject,
    IN ULONG                EventId,
    IN NTSTATUS             Status,
    IN PVOID                DataBuffer,
    IN USHORT               DataBufferLength,
    IN PUNICODE_STRING      Annotation,
    IN ULONG                AnnotationCount);


//in create.c
NTSTATUS
RxPrefixClaim (
    IN PRX_CONTEXT RxContext
    );

VOID
RxpPrepareCreateContextForReuse(
    PRX_CONTEXT RxContext);

//in devfcb.c
LUID
RxGetUid (
    IN PSECURITY_SUBJECT_CONTEXT SubjectSecurityContext
    );

ULONG
RxGetSessionId (
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
RxFindOrCreateConnections (
    IN  PRX_CONTEXT            RxContext,
    IN  PUNICODE_STRING        CanonicalName,
    IN  NET_ROOT_TYPE          NetRootType,
    OUT PUNICODE_STRING        LocalNetRootName,
    OUT PUNICODE_STRING        FilePathName,
    IN OUT LOCK_HOLDING_STATE  *pLockHoldingState
    );

NTSTATUS
RxFindOrCreateVNetRoot(
    PRX_CONTEXT        RxContext,
    PUNICODE_STRING    CanonicalName,
    NET_ROOT_TYPE      NetRootType,
    PV_NET_ROOT        *pVirtualNetRootPointer,
    LOCK_HOLDING_STATE *pLockHoldingState);

//in fileinfo.c
typedef enum _RX_NAME_CONJURING_METHODS {
    VNetRoot_As_Prefix,
    VNetRoot_As_UNC_Name,
    VNetRoot_As_DriveLetter
} RX_NAME_CONJURING_METHODS;

VOID
RxConjureOriginalName (
    IN PFCB   Fcb,
    IN PFOBX  Fobx,
    OUT PLONG pActualNameLength,
    PWCHAR OriginalName,
    IN OUT PLONG pLengthRemaining,
    IN RX_NAME_CONJURING_METHODS NameConjuringMethod
    );

//in cleanup.c
VOID
RxAdjustFileTimesAndSize ( RXCOMMON_SIGNATURE );

//
//  A function that returns finished denotes if it was able to complete the
//  operation (TRUE) or could not complete the operation (FALSE) because the
//  wait value stored in the irp context was false and we would have had
//  to block for a resource or I/O
//

typedef BOOLEAN FINISHED;

//
//   Buffer control routines for data caching, implemented in CacheSup.c
//

FINISHED
RxZeroData (
    IN PRX_CONTEXT RxContext,
    IN PVCB Vcb,
    IN PFILE_OBJECT FileObject,
    IN ULONG StartingZero,
    IN ULONG ByteCount
    );

NTSTATUS
RxCompleteMdl (
    IN PRX_CONTEXT RxContext
    );


VOID
RxSyncUninitializeCacheMap (
    IN PRX_CONTEXT RxContext,
    IN PFILE_OBJECT FileObject
    );

VOID
RxLockUserBuffer (
    IN PRX_CONTEXT RxContext,
    IN LOCK_OPERATION Operation,
    IN ULONG BufferLength
    );

PVOID
RxMapSystemBuffer (
    IN PRX_CONTEXT RxContext
    );

PVOID
RxNewMapUserBuffer (
    IN PRX_CONTEXT RxContext
    );

#define RxUpcaseEaName( RXCONTEXT, NAME, UPCASEDNAME ) \
    RtlUpperString( UPCASEDNAME, NAME )


//#define RxDissectName(RXCONTEXT,INPUT_STRING,FIRST_PART,REMAINING_PART) { \
//    FsRtlDissectDbcs( (INPUT_STRING),                                       \
//                      (FIRST_PART),                                         \
//                      (REMAINING_PART) );                                   \
//}
//
//
//#define RxDoesNameContainWildCards(RXCONTEXT,NAME) ( \
//    FsRtlDoesDbcsContainWildCards( &(NAME) )           \
//)
//
//
//#define RxAreNamesEqual(RXCONTEXT,NAMEA,NAMEB) (                         \
//    ((ULONG)(NAMEA).Length == (ULONG)(NAMEB).Length) &&                    \
//    (RtlCompareMemory( &(NAMEA).Buffer[0],                                 \
//                       &(NAMEB).Buffer[0],                                 \
//                       (NAMEA).Length ) == (NAMEA).Length )                \
//)
//
//
//#define RxIsNameValid(RXCONTEXT,NAME,CAN_CONTAIN_WILD_CARDS,PATH_NAME_OK,LEADING_BACKSLAH_OK) ( \
//    FsRtlIsFatDbcsLegal((NAME),                   \
//                        (CAN_CONTAIN_WILD_CARDS), \
//                        (PATH_NAME_OK),           \
//                        (LEADING_BACKSLAH_OK))    \
//)


//even though it passes a serial number, this parameter is not used
#ifdef RDBSS_TRACKER
#define RX_FCBTRACKER_PARAMS ,ULONG LineNumber,PSZ FileName,ULONG SerialNumber
#else
#define RX_FCBTRACKER_PARAMS
#endif

#define FCB_MODE_EXCLUSIVE (1)
#define FCB_MODE_SHARED    (2)
#define FCB_MODE_SHARED_WAIT_FOR_EXCLUSIVE (3)
#define FCB_MODE_SHARED_STARVE_EXCLUSIVE (4)

#define CHANGE_BUFFERING_STATE_CONTEXT      ((PRX_CONTEXT)IntToPtr(0xffffffff))
#define CHANGE_BUFFERING_STATE_CONTEXT_WAIT ((PRX_CONTEXT)IntToPtr(0xfffffffe))

NTSTATUS
__RxAcquireFcb(
     IN OUT PMRX_FCB     pFcb,
     IN OUT PRX_CONTEXT  pRxContext,
     IN     ULONG        Mode
     RX_FCBTRACKER_PARAMS
     );

#ifdef  RDBSS_TRACKER
#define RxAcquireExclusiveFcb(RXCONTEXT,FCB) \
        __RxAcquireFcb(RX_GET_MRX_FCB(FCB),(RXCONTEXT),FCB_MODE_EXCLUSIVE,__LINE__,__FILE__,0)
#else
#define RxAcquireExclusiveFcb(RXCONTEXT,FCB) \
        __RxAcquireFcb(RX_GET_MRX_FCB(FCB),(RXCONTEXT),FCB_MODE_EXCLUSIVE)
#endif

#define RX_GET_MRX_FCB(FCB) ((PMRX_FCB)((FCB)))

#ifdef  RDBSS_TRACKER
#define RxAcquireSharedFcb(RXCONTEXT,FCB) \
        __RxAcquireFcb(RX_GET_MRX_FCB(FCB),(RXCONTEXT),FCB_MODE_SHARED,__LINE__,__FILE__,0)
#else
#define RxAcquireSharedFcb(RXCONTEXT,FCB) \
        __RxAcquireFcb(RX_GET_MRX_FCB(FCB),(RXCONTEXT),FCB_MODE_SHARED)
#endif

#ifdef  RDBSS_TRACKER
#define RxAcquireSharedFcbWaitForEx(RXCONTEXT,FCB) \
        __RxAcquireFcb(RX_GET_MRX_FCB(FCB),(RXCONTEXT),FCB_MODE_SHARED_WAIT_FOR_EXCLUSIVE,__LINE__,__FILE__,0)
#else
#define RxAcquireSharedFcbWaitForEx(RXCONTEXT,FCB) \
        __RxAcquireFcb(RX_GET_MRX_FCB(FCB),(RXCONTEXT),FCB_MODE_SHARED_WAIT_FOR_EXCLUSIVE)
#endif

#ifdef  RDBSS_TRACKER
#define RxAcquireSharedFcbStarveEx(RXCONTEXT,FCB) \
        __RxAcquireFcb(RX_GET_MRX_FCB(FCB),(RXCONTEXT),FCB_MODE_SHARED_STARVE_EXCLUSIVE,__LINE__,__FILE__,0)
#else
#define RxAcquireSharedFcbStarveEx(RXCONTEXT,FCB) \
        __RxAcquireFcb(RX_GET_MRX_FCB(FCB),(RXCONTEXT),FCB_MODE_SHARED_STARVE_EXCLUSIVE)
#endif


VOID
__RxReleaseFcb(
    IN PRX_CONTEXT pRxContext,
    IN PMRX_FCB    pFcb
    RX_FCBTRACKER_PARAMS
    );

#ifdef  RDBSS_TRACKER
#define RxReleaseFcb(RXCONTEXT,FCB) \
        __RxReleaseFcb((RXCONTEXT),RX_GET_MRX_FCB(FCB),__LINE__,__FILE__,0)
#else
#define RxReleaseFcb(RXCONTEXT,FCB) \
        __RxReleaseFcb((RXCONTEXT),RX_GET_MRX_FCB(FCB))
#endif

VOID
__RxReleaseFcbForThread(
    IN PRX_CONTEXT      pRxContext,
    IN PMRX_FCB         pFcb,
    IN ERESOURCE_THREAD ResourceThreadId
    RX_FCBTRACKER_PARAMS
    );

#ifdef  RDBSS_TRACKER
#define RxReleaseFcbForThread(RXCONTEXT,FCB,THREAD) \
        __RxReleaseFcbForThread((RXCONTEXT),RX_GET_MRX_FCB(FCB),(THREAD),__LINE__,__FILE__,0)
#else
#define RxReleaseFcbForThread(RXCONTEXT,FCB,THREAD) \
        __RxReleaseFcbForThread((RXCONTEXT),RX_GET_MRX_FCB(FCB),(THREAD))
#endif

#ifdef RDBSS_TRACKER
VOID RxTrackerUpdateHistory(
    PRX_CONTEXT pRxContext,
    PMRX_FCB pFcb,
    ULONG Operation
    RX_FCBTRACKER_PARAMS
    );
#else
#define RxTrackerUpdateHistory(xRXCONTEXT,xFCB,xOPERATION,xLINENUM,xFILENAME,xSERIALNUMBER) {NOTHING;}
#endif

//this definition is old......i don't like the format
#define RxFcbAcquiredShared(RXCONTEXT,FCB) (                      \
    ExIsResourceAcquiredShared(RX_GET_MRX_FCB(FCB)->Header.Resource) \
)

#define RxIsFcbAcquiredShared(FCB) (                      \
    ExIsResourceAcquiredShared(RX_GET_MRX_FCB(FCB)->Header.Resource) \
)

#define RxIsFcbAcquiredExclusive(FCB) (                      \
    ExIsResourceAcquiredExclusive(RX_GET_MRX_FCB(FCB)->Header.Resource) \
)

#define RxIsFcbAcquired(FCB) (                      \
    ExIsResourceAcquiredShared(RX_GET_MRX_FCB(FCB)->Header.Resource) | \
    ExIsResourceAcquiredExclusive(RX_GET_MRX_FCB(FCB)->Header.Resource) \
)

#define RxAcquirePagingIoResource(FCB,RxContext)                       \
    ExAcquireResourceExclusive(RX_GET_MRX_FCB(FCB)->Header.PagingIoResource,TRUE);  \
    if (RxContext) { \
        ((PRX_CONTEXT)RxContext)->FcbPagingIoResourceAcquired = TRUE;   \
    }

#define RxAcquirePagingIoResourceShared(FCB,FLAG,RxContext, pStatus) \
    {                                                        \
    BOOLEAN _AcquiredFile;                                   \
    BOOLEAN *_pAcquiredFile;                                 \
    _pAcquiredFile = pStatus;                                \
    if ( _pAcquiredFile == NULL ) _pAcquiredFile = &_AcquiredFile;         \
                                                             \
    *_pAcquiredFile = ExAcquireResourceShared(RX_GET_MRX_FCB(FCB)->Header.PagingIoResource,FLAG);  \
    if (*_pAcquiredFile) {                                          \
        if (RxContext) {                                     \
            ((PRX_CONTEXT)RxContext)->FcbPagingIoResourceAcquired = TRUE;   \
        }                                                    \
    }                                                        \
    }

#define RxReleasePagingIoResource(FCB,RxContext)                       \
    if (RxContext) { \
        ((PRX_CONTEXT)RxContext)->FcbPagingIoResourceAcquired = FALSE;   \
    } \
    ExReleaseResource(RX_GET_MRX_FCB(FCB)->Header.PagingIoResource)

#define RxReleasePagingIoResourceForThread(FCB,THREAD,RxContext)    \
    if (RxContext) { \
        ((PRX_CONTEXT)RxContext)->FcbPagingIoResourceAcquired = FALSE;   \
    } \
    ExReleaseResourceForThread(RX_GET_MRX_FCB(FCB)->Header.PagingIoResource,(THREAD))


//  The following are cache manager call backs

BOOLEAN
RxAcquireFcbForLazyWrite (
    IN PVOID Null,
    IN BOOLEAN Wait
    );

VOID
RxReleaseFcbFromLazyWrite (
    IN PVOID Null
    );

BOOLEAN
RxAcquireFcbForReadAhead (
    IN PVOID Null,
    IN BOOLEAN Wait
    );

VOID
RxReleaseFcbFromReadAhead (
    IN PVOID Null
    );

BOOLEAN
RxNoOpAcquire (
    IN PVOID Fcb,
    IN BOOLEAN Wait
    );

VOID
RxNoOpRelease (
    IN PVOID Fcb
    );

NTSTATUS
RxAcquireForCcFlush (
    IN PFILE_OBJECT FileObject,
    IN PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
RxReleaseForCcFlush (
    IN PFILE_OBJECT FileObject,
    IN PDEVICE_OBJECT DeviceObject
    );

//
//  VOID
//  RxConvertToSharedFcb (
//      IN PRX_CONTEXT RxContext,
//      IN PFCB Fcb
//      );
//

#define RxConvertToSharedFcb(RXCONTEXT,FCB) {                        \
    ExConvertExclusiveToShared( RX_GET_MRX_FCB(FCB)->Header.Resource ); \
    }

VOID
RxVerifyOperationIsLegal (
    IN PRX_CONTEXT RxContext
    );

//
//  Work queue routines for posting and retrieving an Irp, implemented in
//  workque.c
//

VOID
RxOplockComplete (
    IN PVOID Context,
    IN PIRP Irp
    );

VOID
RxPrePostIrp (
    IN PVOID Context,
    IN PIRP Irp
    );

VOID
RxAddToWorkque (
    IN PRX_CONTEXT RxContext,
    IN PIRP Irp
    );

NTSTATUS
RxFsdPostRequest (
    IN PRX_CONTEXT RxContext
    );

#define RxFsdPostRequestWithResume(RXCONTEXT,RESUMEROUTINE) \
        (((RXCONTEXT)->ResumeRoutine=(RESUMEROUTINE)),   \
         RxFsdPostRequest((RXCONTEXT)) \
        )

VOID
RxInitializeMRxCalldownContext(
    PMRX_CALLDOWN_CONTEXT pContext,
    PRDBSS_DEVICE_OBJECT  pMRxDeviceObject,
    PMRX_CALLDOWN_ROUTINE pRoutine,
    PVOID                 pParameter);

NTSTATUS
RxCalldownMiniRedirectors(
    LONG                  NumberOfMiniRdrs,
    PMRX_CALLDOWN_CONTEXT pCalldownContext,
    BOOLEAN               PostCalldowns);

//
//  This macro takes a ulong and returns its rounded up word value
//

#define WordAlign(Val) (                    \
    ALIGN_UP( Val, WORD )                   \
    )

//
//  This macro takes a pointer and returns a ULONG_PTR representation of
//  its rounded up word value
//

#define WordAlignPtr(Ptr) (                 \
    ALIGN_UP_POINTER( Ptr, WORD )           \
    )

//
//  This macro takes a ulong and returns its rounded up longword value
//

#define LongAlign(Val) (                    \
    ALIGN_UP( Val, LONG )                   \
    )

//
//  This macro takes a pointer and returns a ULONG_PTR representation of
//  its rounded up word value
//

#define LongAlignPtr(Ptr) (                 \
    ALIGN_UP_POINTER( Ptr, LONG )           \
    )

//
//  This macro takes a ulong and returns its rounded up quadword
//  value
//

#define QuadAlign(Val) (                    \
    ALIGN_UP( Val, ULONGLONG )              \
    )

//
//  This macro takes a pointer and returns a ULONG_PTR representation of
//  its rounded up quadword value
//

#define QuadAlignPtr(Ptr) (                 \
    ALIGN_UP_POINTER( Ptr, ULONGLONG )      \
    )

//
//  This macro takes a pointer and returns whether it's quadword-aligned
//

#define IsPtrQuadAligned(Ptr) (           \
    QuadAlignPtr(Ptr) == (PVOID)(Ptr)     \
    )

//
//  The following types and macros are used to help unpack the packed and
//  misaligned fields found in the Bios parameter block
//

typedef union _UCHAR1 {
    UCHAR  Uchar[1];
    UCHAR  ForceAlignment;
} UCHAR1, *PUCHAR1;

typedef union _UCHAR2 {
    UCHAR  Uchar[2];
    USHORT ForceAlignment;
} UCHAR2, *PUCHAR2;

typedef union _UCHAR4 {
    UCHAR  Uchar[4];
    ULONG  ForceAlignment;
} UCHAR4, *PUCHAR4;

//
//  This macro copies an unaligned src byte to an aligned dst byte
//

#define CopyUchar1(Dst,Src) {                                \
    *((UCHAR1 *)(Dst)) = *((UNALIGNED UCHAR1 *)(Src)); \
    }

//
//  This macro copies an unaligned src word to an aligned dst word
//

#define CopyUchar2(Dst,Src) {                                \
    *((UCHAR2 *)(Dst)) = *((UNALIGNED UCHAR2 *)(Src)); \
    }

//
//  This macro copies an unaligned src longword to an aligned dsr longword
//

#define CopyUchar4(Dst,Src) {                                \
    *((UCHAR4 *)(Dst)) = *((UNALIGNED UCHAR4 *)(Src)); \
    }

#define CopyU4char(Dst,Src) {                                \
    *((UNALIGNED UCHAR4 *)(Dst)) = *((UCHAR4 *)(Src)); \
    }

//
//
// the wrapper doesn't yet implement notify and oplock. rather than remove the code
// we define the calls in such a way as to Noop the effects so that we'll have a head
// start on putting it back later...


/* this is a macro definition we'll reenable when we implement oplocks and notifies
//
//  VOID
//  RxNotifyReportChange (
//      IN PRX_CONTEXT RxContext,
//      IN PVCB Vcb,
//      IN PFCB Fcb,
//      IN ULONG Filter,
//      IN ULONG Action
//      );
//

#define RxNotifyReportChange(I,V,F,FL,A) {                             \
    if ((F)->FullFileName.Buffer == NULL) {                             \
        RxSetFullFileNameInFcb((I),(F));                               \
    }                                                                   \
    FsRtlNotifyFullReportChange( (V)->NotifySync,                       \
                                 &(V)->DirNotifyList,                   \
                                 (PSTRING)&(F)->FullFileName,           \
                                 (USHORT) ((F)->FullFileName.Length -   \
                                           (F)->FinalNameLength),       \
                                 (PSTRING)NULL,                         \
                                 (PSTRING)NULL,                         \
                                 (ULONG)FL,                             \
                                 (ULONG)A,                              \
                                 (PVOID)NULL );                         \
}
*/
#define RxNotifyReportChange(I,V,F,FL,A) \
    RxDbgTrace(0, Dbg, ("RxNotifyReportChange PRETENDING Fcb %08lx %wZ Filter/Action = %08lx/%08lx\n", \
                 (F),&((F)->FcbTableEntry.Path),(FL),(A)))

#if 0
#define FsRtlNotifyFullChangeDirectory(A1,A2,A3,A4,A5,A6,A7,A8,A9,A10) \
    RxDbgTrace(0, Dbg, ("FsRtlNotifyFullReportChange PRETENDING ............\n",0))
#endif

#define FsRtlCheckOplock(A1,A2,A3,A4,A5)  \
        (STATUS_SUCCESS)

#define FsRtlOplockIsFastIoPossible(__a) (TRUE)
//
//  The following procedure is used by the FSP and FSD routines to complete
//  an IRP.
//
//  Note that this macro allows either the Irp or the RxContext to be
//  null, however the only legal order to do this in is:
//
//      RxCompleteRequest_OLD( NULL, Irp, Status );  // completes Irp & preserves context
//      ...
//      RxCompleteRequest_OLD( RxContext, NULL, DontCare ); // deallocates context
//
//  This would typically be done in order to pass a "naked" RxContext off to
//  the Fsp for post processing, such as read ahead.
//
//  The new way is to pass just the RxContext..........

VOID
RxCompleteRequest_Real (
    IN PRX_CONTEXT RxContext,
    IN PIRP Irp,
    IN NTSTATUS Status
    );

#if DBG
#define RxCompleteRequest_OLD(RXCONTEXT,IRP,STATUS) { \
    RxCompleteRequest_Real(RXCONTEXT,IRP,STATUS); \
    (IRP) = NULL;                                   \
    (RXCONTEXT) = NULL;                            \
}
#else
#define RxCompleteRequest_OLD(RXCONTEXT,IRP,STATUS) { \
    RxCompleteRequest_Real(RXCONTEXT,IRP,STATUS); \
}
#endif

NTSTATUS
RxCompleteRequest(
      PRX_CONTEXT pContext,
      NTSTATUS    Status);

#define RxCompleteAsynchronousRequest(RXCONTEXT,STATUS)  \
        RxCompleteRequest(RXCONTEXT,STATUS)

#define RxCompleteContextAndReturn(STATUS) {       \
             NTSTATUS __sss = (STATUS);             \
             RxCompleteRequest(RxContext,__sss); \
             return(__sss);}
#define RxCompleteContext(STATUS) {       \
             NTSTATUS __sss = (STATUS);             \
             RxCompleteRequest(RxContext,__sss);} \

//
//  The Following routine makes a popup
//

VOID
RxPopUpFileCorrupt (
    IN PRX_CONTEXT RxContext,
    IN PFCB Fcb
    );

NTSTATUS
RxConstructSrvCall(
    PRX_CONTEXT       pRxContext,
    PSRV_CALL          pSrvCall,
    LOCK_HOLDING_STATE *pLockHoldingState);

NTSTATUS
RxSetSrvCallDomainName(
    PMRX_SRV_CALL    pSrvCall,
    PUNICODE_STRING  pDomainName);

NTSTATUS
RxConstructNetRoot(
    PRX_CONTEXT                 pRxContext,
    PSRV_CALL                   pSrvCall,
    PNET_ROOT                   pNetRoot,
    PV_NET_ROOT                 pVirtualNetRoot,
    LOCK_HOLDING_STATE          *pLockHoldingState);

NTSTATUS
RxConstructVirtualNetRoot(
    PRX_CONTEXT        RxContext,
    PUNICODE_STRING    CanonicalName,
    NET_ROOT_TYPE      NetRootType,
    PV_NET_ROOT        *pVirtualNetRootPointer,
    LOCK_HOLDING_STATE *pLockHoldingState);

NTSTATUS
RxFindOrConstructVirtualNetRoot(
    PRX_CONTEXT        RxContext,
    PUNICODE_STRING    CanonicalName,
    NET_ROOT_TYPE      NetRootType,
    PUNICODE_STRING    RemainingName);

NTSTATUS
RxLowIoFsCtlShell (
    IN PRX_CONTEXT RxContext
    );

NTSTATUS
RxLowIoFsCtlShellCompletion (
    IN PRX_CONTEXT RxContext
    );


NTSTATUS
RxLowIoLockControlShell (
    IN PRX_CONTEXT RxContext
    );

NTSTATUS
RxChangeBufferingState(
    PSRV_OPEN              SrvOpen,
    PVOID                  Context,
    BOOLEAN                ComputeNewState
    );

VOID
RxAssociateSrvOpenKey(
    PMRX_SRV_OPEN pMRxSrvOpen,
    PVOID         SrvOpenKey);

VOID
RxIndicateChangeOfBufferingState(
    PMRX_SRV_CALL pSrvCall,
    PVOID         SrvOpenKey,
    PVOID         pContext);

VOID
RxIndicateChangeOfBufferingStateForSrvOpen(
    PMRX_SRV_CALL pSrvCall,
    PMRX_SRV_OPEN pSrvOpen,
    PVOID         SrvOpenKey,
    PVOID         pContext);


NTSTATUS
RxPrepareToReparseSymbolicLink(
    PRX_CONTEXT     RxContext,
    BOOLEAN         SymbolicLinkEmbeddedInOldPath,
    PUNICODE_STRING pNewPath,
    BOOLEAN         NewPathIsAbsolute,
    BOOLEAN         *pReparseRequired);

BOOLEAN
RxLockEnumerator (
    IN OUT struct _MRX_SRV_OPEN_ * SrvOpen,
    IN OUT PVOID *ContinuationHandle,
       OUT PLARGE_INTEGER FileOffset,
       OUT PLARGE_INTEGER LockRange,
       OUT PBOOLEAN IsLockExclusive
    );

//
// Routines for transitioning data structures to stable states.
//

VOID
RxReference(
    IN OUT PVOID pInstance);

VOID
RxDereference(
    IN OUT PVOID              pInstance,
    IN     LOCK_HOLDING_STATE LockHoldingState);

VOID
RxWaitForStableCondition(
    IN     PRX_BLOCK_CONDITION pCondition,
    IN OUT PLIST_ENTRY         pTransitionWaitList,
    IN OUT PRX_CONTEXT         RxContext,
    OUT    NTSTATUS            *AsyncStatus OPTIONAL);

VOID
RxUpdateCondition(
    IN     RX_BLOCK_CONDITION NewConditionValue,
       OUT RX_BLOCK_CONDITION *pCondition,
    IN OUT PLIST_ENTRY        pTransitionWaitList);

VOID
RxFinalizeNetTable(
    PRDBSS_DEVICE_OBJECT RxDeviceObject,
    BOOLEAN fForceFinalization);

#define RxForceNetTableFinalization(RxDeviceObject) \
            RxFinalizeNetTable(RxDeviceObject,TRUE)

NTSTATUS
RxCloseAssociatedSrvOpen(
    PFOBX       pFobx,
    PRX_CONTEXT RxContext);

NTSTATUS
RxFinalizeConnection(
    IN OUT PNET_ROOT NetRoot,
    IN OUT PV_NET_ROOT VNetRoot OPTIONAL,
    IN BOOLEAN ForceFilesClosed
    );


// routines for manipulating the user's view and the server's view of SHARE_ACCESS.
// the user's view is supported by routines exported by Io...the wrappers just allow
// us to get a msg. the server's view is supported by routines that are essential just
// copies of the Io routines EXCEPT that the Io routines work directly on fileobjects and
// as such cannot be used directly. the routines mentioned are implemented in create.c

#if DBG
VOID
RxDumpWantedAccess(
    PSZ where1,
    PSZ where2,
    PSZ wherelogtag,
    IN ACCESS_MASK DesiredAccess,
    IN ULONG DesiredShareAccess
   );

VOID
RxDumpCurrentAccess(
    PSZ where1,
    PSZ where2,
    PSZ wherelogtag,
    PSHARE_ACCESS ShareAccess
    );
#else
#define RxDumpWantedAccess(w1,w2,wlt,DA,DSA) {NOTHING;}
#define RxDumpCurrentAccess(w1,w2,wlt,SA)  {NOTHING;}
#endif

NTSTATUS
RxCheckShareAccessPerSrvOpens(
    IN PFCB Fcb,
    IN ACCESS_MASK DesiredAccess,
    IN ULONG DesiredShareAccess
    );


VOID
RxUpdateShareAccessPerSrvOpens(
    IN PSRV_OPEN SrvOpen
    );

VOID
RxRemoveShareAccessPerSrvOpens(
    IN OUT PSRV_OPEN SrvOpen
    );

VOID
RxRemoveShareAccessPerSrvOpens(
    IN OUT PSRV_OPEN SrvOpen
    );


#if DBG
NTSTATUS
RxCheckShareAccess(
    IN ACCESS_MASK DesiredAccess,
    IN ULONG DesiredShareAccess,
    IN OUT PFILE_OBJECT FileObject,
    IN OUT PSHARE_ACCESS ShareAccess,
    IN BOOLEAN Update,
    IN PSZ where,
    IN PSZ wherelogtag
    );

VOID
RxRemoveShareAccess(
    IN PFILE_OBJECT FileObject,
    IN OUT PSHARE_ACCESS ShareAccess,
    IN PSZ where,
    IN PSZ wherelogtag
    );

VOID
RxSetShareAccess(
    IN ACCESS_MASK DesiredAccess,
    IN ULONG DesiredShareAccess,
    IN OUT PFILE_OBJECT FileObject,
    OUT PSHARE_ACCESS ShareAccess,
    IN PSZ where,
    IN PSZ wherelogtag
    );

VOID
RxUpdateShareAccess(
    IN PFILE_OBJECT FileObject,
    IN OUT PSHARE_ACCESS ShareAccess,
    IN PSZ where,
    IN PSZ wherelogtag
    );
#else
#define RxCheckShareAccess(a1,a2,a3,a4,a5,a6,a7) \
    IoCheckShareAccess(a1,a2,a3,a4,a5)

#define RxRemoveShareAccess(a1,a2,a3,a4) \
    IoRemoveShareAccess(a1,a2)

#define RxSetShareAccess(a1,a2,a3,a4,a5,a6) \
    IoSetShareAccess(a1,a2,a3,a4)

#define RxUpdateShareAccess(a1,a2,a3,a4) \
    IoUpdateShareAccess(a1,a2)
#endif

//LoadUnload

NTSTATUS
RxDriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

VOID
RxUnload(
    IN PDRIVER_OBJECT DriverObject
    );

//minirdr support

VOID
RxInitializeMinirdrDispatchTable(
    IN PDRIVER_OBJECT DriverObject
    );

ULONG
RxGetNetworkProviderPriority(
    PUNICODE_STRING DeviceName
    );

VOID
RxExtractServerName(
    IN PUNICODE_STRING FilePathName,
    OUT PUNICODE_STRING SrvCallName,
    OUT PUNICODE_STRING RestOfName
    );

VOID
RxCreateNetRootCallBack (
    IN PMRX_CREATENETROOT_CONTEXT pCreateNetRootContext
    );

NTSTATUS
DuplicateTransportAddress(
    PTRANSPORT_ADDRESS *pCopy,
    PTRANSPORT_ADDRESS pOriginal,
    POOL_TYPE          PoolType);

NTSTATUS
RxCepInitializeVC(
    PRXCE_VC         pVc,
    PRXCE_CONNECTION pConnection);

NTSTATUS
DuplicateConnectionInformation(
    PRXCE_CONNECTION_INFORMATION *pCopy,
    PRXCE_CONNECTION_INFORMATION pOriginal,
    POOL_TYPE                    PoolType);

NTSTATUS
RxCepInitializeConnection(
    IN OUT PRXCE_CONNECTION             pConnection,
    IN     PRXCE_ADDRESS                pAddress,
    IN     PRXCE_CONNECTION_INFORMATION pConnectionInformation,
    IN  PRXCE_CONNECTION_EVENT_HANDLER  pHandler,
    IN  PVOID                           pEventContext);

NTSTATUS
RxCeInitiateConnectRequest(
    struct _RX_CALLOUT_PARAMETERS_BLOCK_ *pParameterBlock);

VOID
RxCeCleanupConnectCallOutContext(
    struct _RX_CREATE_CONNECTION_CALLOUT_CONTEXT_ *pCreateConnectionContext);

PVOID
RxAllocateObject(
    NODE_TYPE_CODE    NodeType,
    PMINIRDR_DISPATCH pMRxDispatch,
    ULONG             NameLength);

VOID
RxFreeObject(PVOID pObject);

NTSTATUS
RxInitializeSrvCallParameters(
    PRX_CONTEXT RxContext,
    PSRV_CALL   SrvCall);

VOID
RxAddVirtualNetRootToNetRoot(
    PNET_ROOT   pNetRoot,
    PV_NET_ROOT pVNetRoot);

VOID
RxRemoveVirtualNetRootFromNetRoot(
    PNET_ROOT   pNetRoot,
    PV_NET_ROOT pVNetRoot);

VOID
RxOrphanFcbsFromThisVNetRoot (
    IN PV_NET_ROOT ThisVNetRoot
    );

PVOID
RxAllocateFcbObject(
    PRDBSS_DEVICE_OBJECT RxDeviceObject,
    NODE_TYPE_CODE    NodeType,
    POOL_TYPE         PoolType,
    ULONG             NameSize,
    PVOID             pAlreadyAllocatedObject);

VOID
RxFreeFcbObject(PVOID pObject);

VOID
RxPurgeFcb(
    IN  PFCB pFcb);

BOOLEAN
RxFinalizeNetFcb (
    OUT PFCB ThisFcb,
    IN  BOOLEAN   RecursiveFinalize,
    IN  BOOLEAN   ForceFinalize,
    IN  LONG      ReferenceCount
    );

VOID
RxCheckFcbStructuresForAlignment(void);

VOID
RxpPrepareCreateContextForReuse(
    PRX_CONTEXT RxContext);

NTSTATUS
RxLowIoSubmitRETRY (
    IN PRX_CONTEXT RxContext
    );

NTSTATUS
RxLowIoCompletionTail (
    IN PRX_CONTEXT RxContext
    );

VOID
RxRecurrentTimerWorkItemDispatcher (
    IN PVOID Context
    );

NTSTATUS
RxInitializeWorkQueueDispatcher(
   PRX_WORK_QUEUE_DISPATCHER pDispatcher);

VOID
RxInitializeWorkQueue(
   PRX_WORK_QUEUE  pWorkQueue,
   WORK_QUEUE_TYPE WorkQueueType,
   ULONG           MaximumNumberOfWorkerThreads,
   ULONG           MinimumNumberOfWorkerThreads);

VOID
RxTearDownWorkQueueDispatcher(
   PRX_WORK_QUEUE_DISPATCHER pDispatcher);

VOID
RxTearDownWorkQueue(
   PRX_WORK_QUEUE pWorkQueue);

NTSTATUS
RxSpinUpWorkerThread(
   PRX_WORK_QUEUE           pWorkQueue,
   PRX_WORKERTHREAD_ROUTINE Routine,
   PVOID                    Parameter);

VOID
RxSpinUpWorkerThreads(
   PRX_WORK_QUEUE pWorkQueue);

VOID
RxSpinUpRequestsDispatcher(
    PRX_DISPATCHER pDispatcher);

VOID
RxpSpinUpWorkerThreads(
    PRX_WORK_QUEUE pWorkQueue);

VOID
RxpWorkerThreadDispatcher(
   IN PRX_WORK_QUEUE pWorkQueue,
   IN PLARGE_INTEGER pWaitInterval);

VOID
RxBootstrapWorkerThreadDispatcher(
   IN PRX_WORK_QUEUE pWorkQueue);

VOID
RxWorkerThreadDispatcher(
   IN PRX_WORK_QUEUE pWorkQueue);

VOID
RxWorkItemDispatcher(
   PVOID    pContext);

BOOLEAN
RxIsPrefixTableEmpty(
    IN PRX_PREFIX_TABLE   ThisTable);

PRX_PREFIX_ENTRY
RxTableLookupName_ExactLengthMatch (
    IN  PRX_PREFIX_TABLE ThisTable,
    IN  PUNICODE_STRING  Name,
    IN  ULONG            HashValue
    );

PVOID
RxTableLookupName (
    IN  PRX_PREFIX_TABLE ThisTable,
    IN  PUNICODE_STRING  Name,
    OUT PUNICODE_STRING  RemainingName
    );

VOID
RxAcquireFileForNtCreateSection (
    IN PFILE_OBJECT FileObject
    );

VOID
RxReleaseFileForNtCreateSection (
    IN PFILE_OBJECT FileObject
    );

NTSTATUS
RxPrepareRequestForHandling(
    PCHANGE_BUFFERING_STATE_REQUEST pRequest);

VOID
RxPrepareRequestForReuse(
    PCHANGE_BUFFERING_STATE_REQUEST pRequest);

VOID
RxpDiscardChangeBufferingStateRequests(
    IN OUT PLIST_ENTRY pDiscardedRequests);

VOID
RxGatherRequestsForSrvOpen(
    IN OUT PSRV_CALL     pSrvCall,
    IN     PSRV_OPEN     pSrvOpen,
    IN OUT PLIST_ENTRY   pRequestsListHead);

NTSTATUS
RxpLookupSrvOpenForRequestLite(
    IN     PSRV_CALL                       pSrvCall,
    IN OUT PCHANGE_BUFFERING_STATE_REQUEST pRequest);

BOOLEAN
RxContextCheckToFailThisAttempt(
    IN PIRP Irp,
    IN OUT ULONG* InitialContextFlags
    );

ULONG
RxAssignMustSucceedContext(
    IN PIRP Irp,
    IN ULONG InitialContextFlags
    );

PRX_CONTEXT
RxAllocateMustSucceedContext(
    PIRP                    Irp,
    IN PRDBSS_DEVICE_OBJECT RxDeviceObject,
    IN ULONG                InitialContextFlags,
    OUT PUCHAR              MustSucceedDescriptorNumber
    );

VOID
RxFreeMustSucceedContext(
    PRX_CONTEXT RxContext
    );

PRX_LOG_ENTRY_HEADER
RxGetNextLogEntry(void);

VOID
RxPrintLog (
    IN ULONG EntriesToPrint OPTIONAL
    );

VOID
RxProcessChangeBufferingStateRequestsForSrvOpen(
      PSRV_OPEN pSrvOpen);

NTSTATUS
RxPurgeFobxFromCache(
    PFOBX   pFobxToBePurged);

BOOLEAN
RxPurgeFobx(
   PFOBX pFobx);

VOID
RxPurgeAllFobxs(
    PRDBSS_DEVICE_OBJECT RxDeviceObject);

VOID
RxUndoScavengerFinalizationMarking(
    PVOID pInstance);

VOID
RxScavengeAllFobxs(
    PRDBSS_DEVICE_OBJECT RxDeviceObject);

ULONG
RxTableComputePathHashValue (
    IN  PUNICODE_STRING  Name
    );

VOID
RxExtractServerName(
    IN PUNICODE_STRING FilePathName,
    OUT PUNICODE_STRING SrvCallName,
    OUT PUNICODE_STRING RestOfName
    );

VOID
RxCreateNetRootCallBack (
    IN PMRX_CREATENETROOT_CONTEXT pCreateNetRootContext
    );

VOID
RxSpinDownOutstandingAsynchronousRequests(
    PRDBSS_DEVICE_OBJECT RxDeviceObject);

NTSTATUS
RxRegisterAsynchronousRequest(
    PRDBSS_DEVICE_OBJECT RxDeviceObject);

VOID
RxDeregisterAsynchronousRequest(
    PRDBSS_DEVICE_OBJECT RxDeviceObject);


BOOLEAN
RxCancelOperationInOverflowQueue(
    PRX_CONTEXT RxContext);

VOID
RxOrphanSrvOpens(
    IN  PV_NET_ROOT ThisVNetRoot
    );


VOID
RxOrphanThisFcb(
    PFCB    pFcb
    );

VOID
RxOrphanSrvOpensForThisFcb(
    PFCB            pFcb,
    IN PV_NET_ROOT  ThisVNetRoot,
    BOOLEAN         fOrphanAll
    );

VOID
RxForceFinalizeAllVNetRoots(
    PNET_ROOT   pNetRoot
    );

#endif // _RDBSSPROCS_





#else /* NTDDI_VERSION */

#error This file cannot be included for this NTDDI_VERSION.

#endif /* NTDDI_VERSION */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\rxstruc.h ===
#if !defined(NTDDI_VERSION)

#error NTDDI_VERSION must be defined to include this file.

#elif (NTDDI_VERSION >= NTDDI_VISTA)

/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    RxStruc.h

Abstract:

    This module defines the data structures that make up the major internal
    part of the Rx file system.

Author:
--*/

#ifndef _RDBSSSTRUC_
#define _RDBSSSTRUC_

#include "prefix.h"
#include "lowio.h"
#include "scavengr.h"      //  scavenger related definitions.
#include "RxContx.h"
#include "mrx.h"
#include "Fcb.h"

//
//  define our byte offsets to be the full 64 bits
//

typedef LONGLONG RXVBO;

#if 0

//
//  Define who many freed structures we are willing to keep around
//

#define FREE_FOBX_SIZE                   (8)
#define FREE_FCB_SIZE                    (8)
#define FREE_NON_PAGED_FCB_SIZE          (8)

#define FREE_128_BYTE_SIZE               (16)
#define FREE_256_BYTE_SIZE               (16)
#define FREE_512_BYTE_SIZE               (16)

#endif //  0


//
//  We will use both a common and private dispatch tables on a per FCB basis to (a) get
//  some encapsulation and (b) [less important] go a little faster. The driver table then gets
//  optimized for the most common case. Right now we just use the common dispatch...later and
//  Eventually, all the FCBs will have pointers to optimized dispatch tables.
//

//
//  used to synchronize access to  rxcontxs and structures
//

extern RX_SPIN_LOCK RxStrucSupSpinLock;

typedef struct _RDBSS_EXPORTS {
    PRX_SPIN_LOCK pRxStrucSupSpinLock;
    PLONG pRxDebugTraceIndent;
} RDBSS_EXPORTS, *PRDBSS_EXPORTS;

extern RDBSS_EXPORTS RxExports;

//
//  this type is used with table locks to track whether or not the lock
//  should be released
//

typedef enum _LOCK_HOLDING_STATE {
    LHS_LockNotHeld,
    LHS_SharedLockHeld,
    LHS_ExclusiveLockHeld
} LOCK_HOLDING_STATE, *PLOCK_HOLDING_STATE;

//
//  The RDBSS_DATA record is the top record in the Rx file system in-memory
//  data structure.  This structure must be allocated from non-paged pool.
//

typedef struct _RDBSS_DATA {

    //
    //  The type and size of this record (must be RDBSS_NTC_DATA_HEADER)
    //

    NODE_TYPE_CODE NodeTypeCode;
    NODE_BYTE_SIZE NodeByteSize;

    //
    //  The Driver object we were initialized with
    //

    PDRIVER_OBJECT DriverObject;

    //
    //  Mini Rdr registration related fields
    //

    __volatile LONG NumberOfMinirdrsStarted;

    FAST_MUTEX MinirdrRegistrationMutex;
    LIST_ENTRY RegisteredMiniRdrs;          //protected by the mutex
    LONG NumberOfMinirdrsRegistered;  //protected by the mutex

    //
    //  A pointer to our EPROCESS struct, which is a required input to the
    //  Cache Management subsystem.
    //

    PEPROCESS OurProcess;

    //
    //  Cache manager call back structures, which must be passed on each call
    //  to CcInitializeCacheMap.
    //

    CACHE_MANAGER_CALLBACKS CacheManagerCallbacks;

    //
    //  To control access to the global Rx data record
    //

    ERESOURCE Resource;

} RDBSS_DATA;
typedef RDBSS_DATA *PRDBSS_DATA;

extern RDBSS_DATA RxData;

PEPROCESS
RxGetRDBSSProcess (
    VOID
    );

//
//  Note: A Strategy needs to be in place to deal with requests for stopping the
//  RDBSS when requests are active.
//

typedef enum _RX_RDBSS_STATE_ {
   RDBSS_STARTABLE = 0,  
   RDBSS_STARTED,
   RDBSS_STOP_IN_PROGRESS

   //
   //  this state deleted with cause! RDBSS_STOPPED
   //

} RX_RDBSS_STATE, *PRX_RDBSS_STATE;

typedef struct _RDBSS_STARTSTOP_CONTEXT_ {
   
    RX_RDBSS_STATE State;
    ULONG Version;
    PRX_CONTEXT pStopContext;

} RDBSS_STARTSTOP_CONTEXT, *PRDBSS_STARTSTOP_CONTEXT;

typedef struct _MRX_CALLDOWN_COMPLETION_CONTEXT_ {
   
    LONG WaitCount;
    KEVENT Event;

} MRX_CALLDOWN_COMPLETION_CONTEXT, *PMRX_CALLDOWN_COMPLETION_CONTEXT;

typedef
NTSTATUS
(NTAPI *PMRX_CALLDOWN_ROUTINE) (
    IN OUT PVOID CalldownParameter
    );


typedef struct _MRX_CALLDOWN_CONTEXT_ {
    
    RX_WORK_QUEUE_ITEM WorkQueueItem;
    PRDBSS_DEVICE_OBJECT pMRxDeviceObject;
    PMRX_CALLDOWN_COMPLETION_CONTEXT pCompletionContext;
    PMRX_CALLDOWN_ROUTINE pRoutine;
    NTSTATUS CompletionStatus;
    PVOID pParameter;

} MRX_CALLDOWN_CONTEXT, *PMRX_CALLDOWN_CONTEXT;

typedef struct _RX_DISPATCHER_CONTEXT_ {
   
    __volatile LONG NumberOfWorkerThreads;
    __volatile PKEVENT pTearDownEvent;

} RX_DISPATCHER_CONTEXT, *PRX_DISPATCHER_CONTEXT;

#define RxSetRdbssState(RxDeviceObject,NewState)                \
        {                                                       \
           KIRQL SavedIrql;                                     \
           KeAcquireSpinLock( &RxStrucSupSpinLock,&SavedIrql );   \
           RxDeviceObject->StartStopContext.State = (NewState); \
           KeReleaseSpinLock( &RxStrucSupSpinLock, SavedIrql );    \
        }

#define RxGetRdbssState(RxDeviceObject)         \
        (RxDeviceObject)->StartStopContext.State

BOOLEAN
RxIsOperationCompatibleWithRdbssState (
    PIRP Irp
    );

//
//  The RDBSS Device Object is an I/O system device object with additions for
//  the various structures needed by each minirdr: the dispatch, export-to-minirdr
//  structure, MUP call characteristics, list of active operations, etc.
//

typedef struct _RDBSS_DEVICE_OBJECT {

    union {
        DEVICE_OBJECT DeviceObject;
#ifndef __cplusplus
        DEVICE_OBJECT;
#endif //  __cplusplus
    };

    ULONG RegistrationControls;

    //
    //  stuff that the minirdr needs to know
    //

    PRDBSS_EXPORTS RdbssExports;      

    //
    //  set to NULL if monolithic
    //

    PDEVICE_OBJECT RDBSSDeviceObject; 

    //
    //  the mini rdr dispatch vector
    //

    PMINIRDR_DISPATCH Dispatch; 
    UNICODE_STRING DeviceName;

    ULONG NetworkProviderPriority;

    HANDLE MupHandle;

    BOOLEAN RegisterUncProvider;
    BOOLEAN RegisterMailSlotProvider;
    BOOLEAN RegisteredAsFileSystem;
    BOOLEAN Unused;

    LIST_ENTRY MiniRdrListLinks;

    __volatile ULONG NumberOfActiveFcbs;
    __volatile ULONG NumberOfActiveContexts;

    struct {
        
        LARGE_INTEGER PagingReadBytesRequested;
        LARGE_INTEGER NonPagingReadBytesRequested;
        LARGE_INTEGER CacheReadBytesRequested;
        LARGE_INTEGER FastReadBytesRequested;
        LARGE_INTEGER NetworkReadBytesRequested;
        __volatile ULONG ReadOperations;
        ULONG FastReadOperations;
        __volatile ULONG RandomReadOperations;

        LARGE_INTEGER PagingWriteBytesRequested;
        LARGE_INTEGER NonPagingWriteBytesRequested;
        LARGE_INTEGER CacheWriteBytesRequested;
        LARGE_INTEGER FastWriteBytesRequested;
        LARGE_INTEGER NetworkWriteBytesRequested;
        __volatile ULONG WriteOperations;
        ULONG FastWriteOperations;
        __volatile ULONG RandomWriteOperations;
    };

    //
    //  The following field tells how many requests for this volume have
    //  either been enqueued to ExWorker threads or are currently being
    //  serviced by ExWorker threads.  If the number goes above
    //  a certain threshold, put the request on the overflow queue to be
    //  executed later.
    //

    __deref_volatile LONG PostedRequestCount[MaximumWorkQueue];

    //
    //  The following field indicates the number of IRP's waiting
    //  to be serviced in the overflow queue.
    //

    LONG OverflowQueueCount[MaximumWorkQueue];

    //
    //  The following field contains the queue header of the overflow queue.
    //  The Overflow queue is a list of IRP's linked via the IRP's ListEntry
    //  field.
    //

    LIST_ENTRY OverflowQueue[MaximumWorkQueue];

    //
    //  The following spinlock protects access to all the above fields.
    //

    RX_SPIN_LOCK OverflowQueueSpinLock;

    //
    //  The following fields are required for synchronization with async.
    //  requests issued by the RDBSS on behalf of this mini redirector on
    //  on shutdown.
    //

    LONG AsynchronousRequestsPending;

    PKEVENT pAsynchronousRequestsCompletionEvent;

    RDBSS_STARTSTOP_CONTEXT StartStopContext;

    RX_DISPATCHER_CONTEXT DispatcherContext;

    //
    //  some guys may want to share
    //

    PRX_PREFIX_TABLE pRxNetNameTable; 
    RX_PREFIX_TABLE RxNetNameTableInDeviceObject;


    //
    //  for sharing
    //

    PRDBSS_SCAVENGER pRdbssScavenger; 
    RDBSS_SCAVENGER RdbssScavengerInDeviceObject;

} RDBSS_DEVICE_OBJECT, *PRDBSS_DEVICE_OBJECT;

INLINE 
VOID
NTAPI
RxUnregisterMinirdr (
    IN PRDBSS_DEVICE_OBJECT RxDeviceObject
    )
{
    PDEVICE_OBJECT RDBSSDeviceObject;

    RDBSSDeviceObject = RxDeviceObject->RDBSSDeviceObject;

    RxpUnregisterMinirdr( RxDeviceObject );

    if (RDBSSDeviceObject != NULL) {
        ObDereferenceObject( RDBSSDeviceObject );
    }
}

extern FAST_MUTEX RxMinirdrRegistrationMutex;
extern LIST_ENTRY RxRegisteredMiniRdrs;
extern ULONG RxNumberOfMinirdrs;

#endif // _RDBSSSTRUC_

#elif (NTDDI_VERSION >= NTDDI_WS03)

/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    RxStruc.h

Abstract:

    This module defines the data structures that make up the major internal
    part of the Rx file system.

Author:
--*/

#ifndef _RDBSSSTRUC_
#define _RDBSSSTRUC_

#include "prefix.h"
#include "lowio.h"
#include "scavengr.h"      //  scavenger related definitions.
#include "RxContx.h"
#include "mrx.h"
#include "Fcb.h"

//
//  define our byte offsets to be the full 64 bits
//

typedef LONGLONG RXVBO;

#if 0

//
//  Define who many freed structures we are willing to keep around
//

#define FREE_FOBX_SIZE                   (8)
#define FREE_FCB_SIZE                    (8)
#define FREE_NON_PAGED_FCB_SIZE          (8)

#define FREE_128_BYTE_SIZE               (16)
#define FREE_256_BYTE_SIZE               (16)
#define FREE_512_BYTE_SIZE               (16)

#endif //  0


//
//  We will use both a common and private dispatch tables on a per FCB basis to (a) get
//  some encapsulation and (b) [less important] go a little faster. The driver table then gets
//  optimized for the most common case. Right now we just use the common dispatch...later and
//  Eventually, all the FCBs will have pointers to optimized dispatch tables.
//

//
//  used to synchronize access to  rxcontxs and structures
//

extern RX_SPIN_LOCK RxStrucSupSpinLock;

typedef struct _RDBSS_EXPORTS {
    PRX_SPIN_LOCK pRxStrucSupSpinLock;
    PLONG pRxDebugTraceIndent;
} RDBSS_EXPORTS, *PRDBSS_EXPORTS;

extern RDBSS_EXPORTS RxExports;

//
//  this type is used with table locks to track whether or not the lock
//  should be released
//

typedef enum _LOCK_HOLDING_STATE {
    LHS_LockNotHeld,
    LHS_SharedLockHeld,
    LHS_ExclusiveLockHeld
} LOCK_HOLDING_STATE, *PLOCK_HOLDING_STATE;

//
//  The RDBSS_DATA record is the top record in the Rx file system in-memory
//  data structure.  This structure must be allocated from non-paged pool.
//

typedef struct _RDBSS_DATA {

    //
    //  The type and size of this record (must be RDBSS_NTC_DATA_HEADER)
    //

    NODE_TYPE_CODE NodeTypeCode;
    NODE_BYTE_SIZE NodeByteSize;

    //
    //  The Driver object we were initialized with
    //

    PDRIVER_OBJECT DriverObject;

    //
    //  Mini Rdr registration related fields
    //

    LONG NumberOfMinirdrsStarted;

    FAST_MUTEX MinirdrRegistrationMutex;
    LIST_ENTRY RegisteredMiniRdrs;          //protected by the mutex
    LONG NumberOfMinirdrsRegistered;  //protected by the mutex

    //
    //  A pointer to our EPROCESS struct, which is a required input to the
    //  Cache Management subsystem.
    //

    PEPROCESS OurProcess;

    //
    //  Cache manager call back structures, which must be passed on each call
    //  to CcInitializeCacheMap.
    //

    CACHE_MANAGER_CALLBACKS CacheManagerCallbacks;

    //
    //  To control access to the global Rx data record
    //

    ERESOURCE Resource;

} RDBSS_DATA;
typedef RDBSS_DATA *PRDBSS_DATA;

extern RDBSS_DATA RxData;

PEPROCESS
RxGetRDBSSProcess (
    VOID
    );

//
//  Note: A Strategy needs to be in place to deal with requests for stopping the
//  RDBSS when requests are active.
//

typedef enum _RX_RDBSS_STATE_ {
   RDBSS_STARTABLE = 0,  
   RDBSS_STARTED,
   RDBSS_STOP_IN_PROGRESS

   //
   //  this state deleted with cause! RDBSS_STOPPED
   //

} RX_RDBSS_STATE, *PRX_RDBSS_STATE;

typedef struct _RDBSS_STARTSTOP_CONTEXT_ {
   
    RX_RDBSS_STATE State;
    ULONG Version;
    PRX_CONTEXT pStopContext;

} RDBSS_STARTSTOP_CONTEXT, *PRDBSS_STARTSTOP_CONTEXT;

typedef struct _MRX_CALLDOWN_COMPLETION_CONTEXT_ {
   
    LONG WaitCount;
    KEVENT Event;

} MRX_CALLDOWN_COMPLETION_CONTEXT, *PMRX_CALLDOWN_COMPLETION_CONTEXT;

typedef
NTSTATUS
(NTAPI *PMRX_CALLDOWN_ROUTINE) (
    IN OUT PVOID CalldownParameter
    );


typedef struct _MRX_CALLDOWN_CONTEXT_ {
    
    RX_WORK_QUEUE_ITEM WorkQueueItem;
    PRDBSS_DEVICE_OBJECT pMRxDeviceObject;
    PMRX_CALLDOWN_COMPLETION_CONTEXT pCompletionContext;
    PMRX_CALLDOWN_ROUTINE pRoutine;
    NTSTATUS CompletionStatus;
    PVOID pParameter;

} MRX_CALLDOWN_CONTEXT, *PMRX_CALLDOWN_CONTEXT;

typedef struct _RX_DISPATCHER_CONTEXT_ {
   
    LONG NumberOfWorkerThreads;
    PKEVENT pTearDownEvent;

} RX_DISPATCHER_CONTEXT, *PRX_DISPATCHER_CONTEXT;

#define RxSetRdbssState(RxDeviceObject,NewState)                \
        {                                                       \
           KIRQL SavedIrql;                                     \
           KeAcquireSpinLock( &RxStrucSupSpinLock,&SavedIrql );   \
           RxDeviceObject->StartStopContext.State = (NewState); \
           KeReleaseSpinLock( &RxStrucSupSpinLock, SavedIrql );    \
        }

#define RxGetRdbssState(RxDeviceObject)         \
        (RxDeviceObject)->StartStopContext.State

BOOLEAN
RxIsOperationCompatibleWithRdbssState (
    PIRP Irp
    );

//
//  The RDBSS Device Object is an I/O system device object with additions for
//  the various structures needed by each minirdr: the dispatch, export-to-minirdr
//  structure, MUP call characteristics, list of active operations, etc.
//

typedef struct _RDBSS_DEVICE_OBJECT {

    union {
        DEVICE_OBJECT DeviceObject;
#ifndef __cplusplus
        DEVICE_OBJECT;
#endif //  __cplusplus
    };

    ULONG RegistrationControls;

    //
    //  stuff that the minirdr needs to know
    //

    PRDBSS_EXPORTS RdbssExports;      

    //
    //  set to NULL if monolithic
    //

    PDEVICE_OBJECT RDBSSDeviceObject; 

    //
    //  the mini rdr dispatch vector
    //

    PMINIRDR_DISPATCH Dispatch; 
    UNICODE_STRING DeviceName;

    ULONG NetworkProviderPriority;

    HANDLE MupHandle;

    BOOLEAN RegisterUncProvider;
    BOOLEAN RegisterMailSlotProvider;
    BOOLEAN RegisteredAsFileSystem;
    BOOLEAN Unused;

    LIST_ENTRY MiniRdrListLinks;

    ULONG NumberOfActiveFcbs;
    ULONG NumberOfActiveContexts;

    struct {
        
        LARGE_INTEGER PagingReadBytesRequested;
        LARGE_INTEGER NonPagingReadBytesRequested;
        LARGE_INTEGER CacheReadBytesRequested;
        LARGE_INTEGER FastReadBytesRequested;
        LARGE_INTEGER NetworkReadBytesRequested;
        ULONG ReadOperations;
        ULONG FastReadOperations;
        ULONG RandomReadOperations;

        LARGE_INTEGER PagingWriteBytesRequested;
        LARGE_INTEGER NonPagingWriteBytesRequested;
        LARGE_INTEGER CacheWriteBytesRequested;
        LARGE_INTEGER FastWriteBytesRequested;
        LARGE_INTEGER NetworkWriteBytesRequested;
        ULONG WriteOperations;
        ULONG FastWriteOperations;
        ULONG RandomWriteOperations;
    };

    //
    //  The following field tells how many requests for this volume have
    //  either been enqueued to ExWorker threads or are currently being
    //  serviced by ExWorker threads.  If the number goes above
    //  a certain threshold, put the request on the overflow queue to be
    //  executed later.
    //

    LONG PostedRequestCount[MaximumWorkQueue];

    //
    //  The following field indicates the number of IRP's waiting
    //  to be serviced in the overflow queue.
    //

    LONG OverflowQueueCount[MaximumWorkQueue];

    //
    //  The following field contains the queue header of the overflow queue.
    //  The Overflow queue is a list of IRP's linked via the IRP's ListEntry
    //  field.
    //

    LIST_ENTRY OverflowQueue[MaximumWorkQueue];

    //
    //  The following spinlock protects access to all the above fields.
    //

    RX_SPIN_LOCK OverflowQueueSpinLock;

    //
    //  The following fields are required for synchronization with async.
    //  requests issued by the RDBSS on behalf of this mini redirector on
    //  on shutdown.
    //

    LONG AsynchronousRequestsPending;

    PKEVENT pAsynchronousRequestsCompletionEvent;

    RDBSS_STARTSTOP_CONTEXT StartStopContext;

    RX_DISPATCHER_CONTEXT DispatcherContext;

    //
    //  some guys may want to share
    //

    PRX_PREFIX_TABLE pRxNetNameTable; 
    RX_PREFIX_TABLE RxNetNameTableInDeviceObject;


    //
    //  for sharing
    //

    PRDBSS_SCAVENGER pRdbssScavenger; 
    RDBSS_SCAVENGER RdbssScavengerInDeviceObject;

} RDBSS_DEVICE_OBJECT, *PRDBSS_DEVICE_OBJECT;

INLINE 
VOID
NTAPI
RxUnregisterMinirdr (
    IN PRDBSS_DEVICE_OBJECT RxDeviceObject
    )
{
    PDEVICE_OBJECT RDBSSDeviceObject;

    RDBSSDeviceObject = RxDeviceObject->RDBSSDeviceObject;

    RxpUnregisterMinirdr( RxDeviceObject );

    if (RDBSSDeviceObject != NULL) {
        ObDereferenceObject( RDBSSDeviceObject );
    }
}

extern FAST_MUTEX RxMinirdrRegistrationMutex;
extern LIST_ENTRY RxRegisteredMiniRdrs;
extern ULONG RxNumberOfMinirdrs;

#endif // _RDBSSSTRUC_


#elif (NTDDI_VERSION >= NTDDI_WINXP)

/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    RxStruc.h

Abstract:

    This module defines the data structures that make up the major internal
    part of the Rx file system.

Author:
--*/

#ifndef _RDBSSSTRUC_
#define _RDBSSSTRUC_

#include "prefix.h"
#include "lowio.h"
#include "scavengr.h"      // scavenger related definitions.
#include "RxContx.h"
#include "mrx.h"
#include "Fcb.h"

//define our byte offsets to be the full 64 bits
typedef LONGLONG RXVBO;

#if 0
//
//  Define who many freed structures we are willing to keep around
//

#define FREE_FOBX_SIZE                   (8)
#define FREE_FCB_SIZE                    (8)
#define FREE_NON_PAGED_FCB_SIZE          (8)

#define FREE_128_BYTE_SIZE               (16)
#define FREE_256_BYTE_SIZE               (16)
#define FREE_512_BYTE_SIZE               (16)
#endif //0


//
//  We will use both a common and private dispatch tables on a per FCB basis to (a) get
//  some encapsulation and (b) [less important] go a little faster. The driver table then gets
//  optimized for the most common case. Right now we just use the common dispatch...later and
//  Eventually, all the FCBs will have pointers to optimized dispatch tables.
//

//  used to synchronize access to  rxcontxs and structures

extern RX_SPIN_LOCK RxStrucSupSpinLock;


typedef struct _RDBSS_EXPORTS {
    RX_SPIN_LOCK             *pRxStrucSupSpinLock;
    PLONG                    pRxDebugTraceIndent;
} RDBSS_EXPORTS, *PRDBSS_EXPORTS;

extern RDBSS_EXPORTS RxExports;

// this type is used with table locks to track whether or not the lock
// should be released

typedef enum _LOCK_HOLDING_STATE {
    LHS_LockNotHeld,
    LHS_SharedLockHeld,
    LHS_ExclusiveLockHeld
} LOCK_HOLDING_STATE;

//
//  The RDBSS_DATA record is the top record in the Rx file system in-memory
//  data structure.  This structure must be allocated from non-paged pool.
//

typedef struct _RDBSS_DATA {

    //
    //  The type and size of this record (must be RDBSS_NTC_DATA_HEADER)
    //

    NODE_TYPE_CODE NodeTypeCode;
    NODE_BYTE_SIZE NodeByteSize;

    //  The Driver object we were initialized with

    PDRIVER_OBJECT DriverObject;

    //
    // Mini Rdr registration related fields
    //

    LONG      NumberOfMinirdrsStarted;

    FAST_MUTEX MinirdrRegistrationMutex;
    LIST_ENTRY RegisteredMiniRdrs;          //protected by the mutex
    LONG       NumberOfMinirdrsRegistered;  //protected by the mutex

    //
    //  A pointer to our EPROCESS struct, which is a required input to the
    //  Cache Management subsystem.
    //

    PEPROCESS OurProcess;

#if 0
    //
    //  This is the ExWorkerItem that does both kinds of deferred closes.
    //

    RX_WORK_QUEUE_ITEM RxCloseItem;
#endif //0

    //
    //  Cache manager call back structures, which must be passed on each call
    //  to CcInitializeCacheMap.
    //

    CACHE_MANAGER_CALLBACKS CacheManagerCallbacks;
    CACHE_MANAGER_CALLBACKS CacheManagerNoOpCallbacks;

    //  To control access to the global Rx data record

    ERESOURCE Resource;

} RDBSS_DATA;
typedef RDBSS_DATA *PRDBSS_DATA;

extern RDBSS_DATA RxData;

extern PEPROCESS
RxGetRDBSSProcess();

//
// Note: A Strategy needs to be in place to deal with requests for stopping the
// RDBSS when requests are active.
//

typedef enum _RX_RDBSS_STATE_ {
   RDBSS_STARTABLE = 0,  //RDBSS_START_IN_PROGRESS,
   RDBSS_STARTED,
   RDBSS_STOP_IN_PROGRESS
   //this state deleted with cause! RDBSS_STOPPED
} RX_RDBSS_STATE, *PRX_RDBSS_STATE;

typedef struct _RDBSS_STARTSTOP_CONTEXT_ {
   RX_RDBSS_STATE State;
   ULONG          Version;
   PRX_CONTEXT    pStopContext;
} RDBSS_STARTSTOP_CONTEXT, *PRDBSS_STARTSTOP_CONTEXT;

typedef struct _MRX_CALLDOWN_COMPLETION_CONTEXT_ {
   LONG     WaitCount;
   KEVENT   Event;
} MRX_CALLDOWN_COMPLETION_CONTEXT,
  *PMRX_CALLDOWN_COMPLETION_CONTEXT;

typedef
NTSTATUS
(NTAPI *PMRX_CALLDOWN_ROUTINE) (
    IN OUT PVOID pCalldownParameter);


typedef struct _MRX_CALLDOWN_CONTEXT_ {
   RX_WORK_QUEUE_ITEM               WorkQueueItem;
   PRDBSS_DEVICE_OBJECT             pMRxDeviceObject;
   PMRX_CALLDOWN_COMPLETION_CONTEXT pCompletionContext;
   PMRX_CALLDOWN_ROUTINE            pRoutine;
   NTSTATUS                         CompletionStatus;
   PVOID                            pParameter;
} MRX_CALLDOWN_CONTEXT, *PMRX_CALLDOWN_CONTEXT;

typedef struct _RX_DISPATCHER_CONTEXT_ {
   LONG     NumberOfWorkerThreads;
   PKEVENT  pTearDownEvent;
} RX_DISPATCHER_CONTEXT, *PRX_DISPATCHER_CONTEXT;

#define RxSetRdbssState(RxDeviceObject,NewState)                \
        {                                                       \
           KIRQL SavedIrql;                                     \
           KeAcquireSpinLock(&RxStrucSupSpinLock,&SavedIrql);   \
           RxDeviceObject->StartStopContext.State = (NewState); \
           KeReleaseSpinLock(&RxStrucSupSpinLock,SavedIrql);    \
        }

#define RxGetRdbssState(RxDeviceObject)         \
        (RxDeviceObject)->StartStopContext.State

extern BOOLEAN
RxIsOperationCompatibleWithRdbssState(PIRP pIrp);

//
//  The RDBSS Device Object is an I/O system device object with additions for
//  the various structures needed by each minirdr: the dispatch, export-to-minirdr
//  structure, MUP call characteristics, list of active operations, etc.
//

typedef struct _RDBSS_DEVICE_OBJECT {

    union {
        DEVICE_OBJECT DeviceObject;
#ifndef __cplusplus
        DEVICE_OBJECT;
#endif // __cplusplus
    };

    ULONG RegistrationControls;
    PRDBSS_EXPORTS    RdbssExports;      //stuff that the minirdr needs to know
    PDEVICE_OBJECT    RDBSSDeviceObject; // set to NULL if monolithic
    PMINIRDR_DISPATCH Dispatch; // the mini rdr dispatch vector
    UNICODE_STRING    DeviceName;

    ULONG             NetworkProviderPriority;

    HANDLE            MupHandle;

    BOOLEAN           RegisterUncProvider;
    BOOLEAN           RegisterMailSlotProvider;
    BOOLEAN           RegisteredAsFileSystem;
    BOOLEAN           Unused;

    LIST_ENTRY        MiniRdrListLinks;

    ULONG             NumberOfActiveFcbs;
    ULONG             NumberOfActiveContexts;

    struct {
        LARGE_INTEGER   PagingReadBytesRequested;
        LARGE_INTEGER   NonPagingReadBytesRequested;
        LARGE_INTEGER   CacheReadBytesRequested;
        LARGE_INTEGER   FastReadBytesRequested;
        LARGE_INTEGER   NetworkReadBytesRequested;
        ULONG           ReadOperations;
        ULONG           FastReadOperations;
        ULONG           RandomReadOperations;

        LARGE_INTEGER   PagingWriteBytesRequested;
        LARGE_INTEGER   NonPagingWriteBytesRequested;
        LARGE_INTEGER   CacheWriteBytesRequested;
        LARGE_INTEGER   FastWriteBytesRequested;
        LARGE_INTEGER   NetworkWriteBytesRequested;
        ULONG           WriteOperations;
        ULONG           FastWriteOperations;
        ULONG           RandomWriteOperations;
    };

    //
    //  The following field tells how many requests for this volume have
    //  either been enqueued to ExWorker threads or are currently being
    //  serviced by ExWorker threads.  If the number goes above
    //  a certain threshold, put the request on the overflow queue to be
    //  executed later.
    //

    LONG PostedRequestCount[MaximumWorkQueue];

    //
    //  The following field indicates the number of IRP's waiting
    //  to be serviced in the overflow queue.
    //

    LONG OverflowQueueCount[MaximumWorkQueue];

    //
    //  The following field contains the queue header of the overflow queue.
    //  The Overflow queue is a list of IRP's linked via the IRP's ListEntry
    //  field.
    //

    LIST_ENTRY OverflowQueue[MaximumWorkQueue];

    //
    //  The following spinlock protects access to all the above fields.
    //

    RX_SPIN_LOCK OverflowQueueSpinLock;

    //
    // The following fields are required for synchronization with async.
    // requests issued by the RDBSS on behalf of this mini redirector on
    // on shutdown.
    //

    LONG    AsynchronousRequestsPending;

    PKEVENT pAsynchronousRequestsCompletionEvent;

    RDBSS_STARTSTOP_CONTEXT StartStopContext;

    RX_DISPATCHER_CONTEXT   DispatcherContext;

    struct _RX_PREFIX_TABLE  *pRxNetNameTable; //some guys may want to share
    struct _RX_PREFIX_TABLE  RxNetNameTableInDeviceObject;

    PRDBSS_SCAVENGER pRdbssScavenger; //for sharing
    RDBSS_SCAVENGER RdbssScavengerInDeviceObject;

} RDBSS_DEVICE_OBJECT;

typedef RDBSS_DEVICE_OBJECT *PRDBSS_DEVICE_OBJECT;

INLINE VOID
NTAPI
RxUnregisterMinirdr(
    IN PRDBSS_DEVICE_OBJECT RxDeviceObject
)
{
    PDEVICE_OBJECT RDBSSDeviceObject;

    RDBSSDeviceObject = RxDeviceObject->RDBSSDeviceObject;

    RxpUnregisterMinirdr(RxDeviceObject);

    if (RDBSSDeviceObject != NULL) {
        ObDereferenceObject(RDBSSDeviceObject);
    }
}

extern FAST_MUTEX RxMinirdrRegistrationMutex;
extern LIST_ENTRY RxRegisteredMiniRdrs;
extern ULONG RxNumberOfMinirdrs;

#endif // _RDBSSSTRUC_


#elif (NTDDI_VERSION >= NTDDI_WIN2K)

/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    RxStruc.h

Abstract:

    This module defines the data structures that make up the major internal
    part of the Rx file system.

Author:
--*/

#ifndef _RDBSSSTRUC_
#define _RDBSSSTRUC_

#include "prefix.h"
#include "lowio.h"
#include "scavengr.h"      // scavenger related definitions.
#include "RxContx.h"
#include "mrx.h"
#include "Fcb.h"

//define our byte offsets to be the full 64 bits
typedef LONGLONG RXVBO;

#if 0
//
//  Define who many freed structures we are willing to keep around
//

#define FREE_FOBX_SIZE                   (8)
#define FREE_FCB_SIZE                    (8)
#define FREE_NON_PAGED_FCB_SIZE          (8)

#define FREE_128_BYTE_SIZE               (16)
#define FREE_256_BYTE_SIZE               (16)
#define FREE_512_BYTE_SIZE               (16)
#endif //0


//
//  We will use both a common and private dispatch tables on a per FCB basis to (a) get
//  some encapsulation and (b) [less important] go a little faster. The driver table then gets
//  optimized for the most common case. Right now we just use the common dispatch...later and
//  Eventually, all the FCBs will have pointers to optimized dispatch tables.
//

//  used to synchronize access to  rxcontxs and structures

extern RX_SPIN_LOCK RxStrucSupSpinLock;


typedef struct _RDBSS_EXPORTS {
    RX_SPIN_LOCK             *pRxStrucSupSpinLock;
    PLONG                    pRxDebugTraceIndent;
} RDBSS_EXPORTS, *PRDBSS_EXPORTS;

extern RDBSS_EXPORTS RxExports;

// this type is used with table locks to track whether or not the lock
// should be released

typedef enum _LOCK_HOLDING_STATE {
    LHS_LockNotHeld,
    LHS_SharedLockHeld,
    LHS_ExclusiveLockHeld
} LOCK_HOLDING_STATE;

//
//  The RDBSS_DATA record is the top record in the Rx file system in-memory
//  data structure.  This structure must be allocated from non-paged pool.
//

typedef struct _RDBSS_DATA {

    //
    //  The type and size of this record (must be RDBSS_NTC_DATA_HEADER)
    //

    NODE_TYPE_CODE NodeTypeCode;
    NODE_BYTE_SIZE NodeByteSize;

    //  The Driver object we were initialized with

    PDRIVER_OBJECT DriverObject;

    //
    // Mini Rdr registration related fields
    //

    LONG      NumberOfMinirdrsStarted;

    FAST_MUTEX MinirdrRegistrationMutex;
    LIST_ENTRY RegisteredMiniRdrs;          //protected by the mutex
    LONG       NumberOfMinirdrsRegistered;  //protected by the mutex

    //
    //  A pointer to our EPROCESS struct, which is a required input to the
    //  Cache Management subsystem.
    //

    PEPROCESS OurProcess;

#if 0
    //
    //  This is the ExWorkerItem that does both kinds of deferred closes.
    //

    RX_WORK_QUEUE_ITEM RxCloseItem;
#endif //0

    //
    //  Cache manager call back structures, which must be passed on each call
    //  to CcInitializeCacheMap.
    //

    CACHE_MANAGER_CALLBACKS CacheManagerCallbacks;
    CACHE_MANAGER_CALLBACKS CacheManagerNoOpCallbacks;

    //  To control access to the global Rx data record

    ERESOURCE Resource;

} RDBSS_DATA;
typedef RDBSS_DATA *PRDBSS_DATA;

extern RDBSS_DATA RxData;

extern PEPROCESS
RxGetRDBSSProcess();

//
// Note: A Strategy needs to be in place to deal with requests for stopping the
// RDBSS when requests are active.
//

typedef enum _RX_RDBSS_STATE_ {
   RDBSS_STARTABLE = 0,  //RDBSS_START_IN_PROGRESS,
   RDBSS_STARTED,
   RDBSS_STOP_IN_PROGRESS
   //this state deleted with cause! RDBSS_STOPPED
} RX_RDBSS_STATE, *PRX_RDBSS_STATE;

typedef struct _RDBSS_STARTSTOP_CONTEXT_ {
   RX_RDBSS_STATE State;
   ULONG          Version;
   PRX_CONTEXT    pStopContext;
} RDBSS_STARTSTOP_CONTEXT, *PRDBSS_STARTSTOP_CONTEXT;

typedef struct _MRX_CALLDOWN_COMPLETION_CONTEXT_ {
   LONG     WaitCount;
   KEVENT   Event;
} MRX_CALLDOWN_COMPLETION_CONTEXT,
  *PMRX_CALLDOWN_COMPLETION_CONTEXT;

typedef
NTSTATUS
(NTAPI *PMRX_CALLDOWN_ROUTINE) (
    IN OUT PVOID pCalldownParameter);


typedef struct _MRX_CALLDOWN_CONTEXT_ {
   RX_WORK_QUEUE_ITEM               WorkQueueItem;
   PRDBSS_DEVICE_OBJECT             pMRxDeviceObject;
   PMRX_CALLDOWN_COMPLETION_CONTEXT pCompletionContext;
   PMRX_CALLDOWN_ROUTINE            pRoutine;
   NTSTATUS                         CompletionStatus;
   PVOID                            pParameter;
} MRX_CALLDOWN_CONTEXT, *PMRX_CALLDOWN_CONTEXT;

typedef struct _RX_DISPATCHER_CONTEXT_ {
   LONG     NumberOfWorkerThreads;
   PKEVENT  pTearDownEvent;
} RX_DISPATCHER_CONTEXT, *PRX_DISPATCHER_CONTEXT;

#define RxSetRdbssState(RxDeviceObject,NewState)                \
        {                                                       \
           KIRQL SavedIrql;                                     \
           KeAcquireSpinLock(&RxStrucSupSpinLock,&SavedIrql);   \
           RxDeviceObject->StartStopContext.State = (NewState); \
           KeReleaseSpinLock(&RxStrucSupSpinLock,SavedIrql);    \
        }

#define RxGetRdbssState(RxDeviceObject)         \
        (RxDeviceObject)->StartStopContext.State

extern BOOLEAN
RxIsOperationCompatibleWithRdbssState(PIRP pIrp);

//
//  The RDBSS Device Object is an I/O system device object with additions for
//  the various structures needed by each minirdr: the dispatch, export-to-minirdr
//  structure, MUP call characteristics, list of active operations, etc.
//

typedef struct _RDBSS_DEVICE_OBJECT {

    union {
        DEVICE_OBJECT DeviceObject;
        DEVICE_OBJECT;
    };

    ULONG RegistrationControls;
    PRDBSS_EXPORTS    RdbssExports;      //stuff that the minirdr needs to know
    PDEVICE_OBJECT    RDBSSDeviceObject; // set to NULL if monolithic
    PMINIRDR_DISPATCH Dispatch; // the mini rdr dispatch vector
    UNICODE_STRING    DeviceName;

    ULONG             NetworkProviderPriority;

    HANDLE            MupHandle;

    BOOLEAN           RegisterUncProvider;
    BOOLEAN           RegisterMailSlotProvider;
    BOOLEAN           RegisteredAsFileSystem;
    BOOLEAN           Unused;

    LIST_ENTRY        MiniRdrListLinks;

    ULONG             NumberOfActiveFcbs;
    ULONG             NumberOfActiveContexts;

    struct {
        LARGE_INTEGER   PagingReadBytesRequested;
        LARGE_INTEGER   NonPagingReadBytesRequested;
        LARGE_INTEGER   CacheReadBytesRequested;
        LARGE_INTEGER   FastReadBytesRequested;
        LARGE_INTEGER   NetworkReadBytesRequested;
        ULONG           ReadOperations;
        ULONG           FastReadOperations;
        ULONG           RandomReadOperations;

        LARGE_INTEGER   PagingWriteBytesRequested;
        LARGE_INTEGER   NonPagingWriteBytesRequested;
        LARGE_INTEGER   CacheWriteBytesRequested;
        LARGE_INTEGER   FastWriteBytesRequested;
        LARGE_INTEGER   NetworkWriteBytesRequested;
        ULONG           WriteOperations;
        ULONG           FastWriteOperations;
        ULONG           RandomWriteOperations;
    };

    //
    //  The following field tells how many requests for this volume have
    //  either been enqueued to ExWorker threads or are currently being
    //  serviced by ExWorker threads.  If the number goes above
    //  a certain threshold, put the request on the overflow queue to be
    //  executed later.
    //

    LONG PostedRequestCount[MaximumWorkQueue];

    //
    //  The following field indicates the number of IRP's waiting
    //  to be serviced in the overflow queue.
    //

    LONG OverflowQueueCount[MaximumWorkQueue];

    //
    //  The following field contains the queue header of the overflow queue.
    //  The Overflow queue is a list of IRP's linked via the IRP's ListEntry
    //  field.
    //

    LIST_ENTRY OverflowQueue[MaximumWorkQueue];

    //
    //  The following spinlock protects access to all the above fields.
    //

    RX_SPIN_LOCK OverflowQueueSpinLock;

    //
    // The following fields are required for synchronization with async.
    // requests issued by the RDBSS on behalf of this mini redirector on
    // on shutdown.
    //

    LONG    AsynchronousRequestsPending;

    PKEVENT pAsynchronousRequestsCompletionEvent;

    RDBSS_STARTSTOP_CONTEXT StartStopContext;

    RX_DISPATCHER_CONTEXT   DispatcherContext;

    struct _RX_PREFIX_TABLE  *pRxNetNameTable; //some guys may want to share
    struct _RX_PREFIX_TABLE  RxNetNameTableInDeviceObject;

    PRDBSS_SCAVENGER pRdbssScavenger; //for sharing
    RDBSS_SCAVENGER RdbssScavengerInDeviceObject;

} RDBSS_DEVICE_OBJECT;

typedef RDBSS_DEVICE_OBJECT *PRDBSS_DEVICE_OBJECT;

INLINE VOID
NTAPI
RxUnregisterMinirdr(
    IN PRDBSS_DEVICE_OBJECT RxDeviceObject
)
{
    PDEVICE_OBJECT RDBSSDeviceObject;

    RDBSSDeviceObject = RxDeviceObject->RDBSSDeviceObject;

    RxpUnregisterMinirdr(RxDeviceObject);

    if (RDBSSDeviceObject != NULL) {
        ObDereferenceObject(RDBSSDeviceObject);
    }
}

extern FAST_MUTEX RxMinirdrRegistrationMutex;
extern LIST_ENTRY RxRegisteredMiniRdrs;
extern ULONG RxNumberOfMinirdrs;

#endif // _RDBSSSTRUC_


#else /* NTDDI_VERSION */

#error This file cannot be included for this NTDDI_VERSION.

#endif /* NTDDI_VERSION */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\scavengr.h ===
#if !defined(NTDDI_VERSION)

#error NTDDI_VERSION must be defined to include this file.

#elif (NTDDI_VERSION >= NTDDI_VISTA)

/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    scavengr.h

Abstract:

    This module defines data structures related to scavenging in the RDBSS

Author:
Revision History:


Notes:

    The dormant file limit must be made configurable on a per server basis

--*/

#ifndef _SCAVENGR_H_
#define _SCAVENGR_H_

//                                               
//  currently, only a single scavengermutex is across all scavenging operations
//  for all underlying deviceobjects
//

extern KMUTEX       RxScavengerMutex;

//
// by default the scavenger will run once every 10 seconds
//
#define RX_SCAVENGER_FINALIZATION_TIME_INTERVAL (10 * 1000 * 1000 * 10)

//
// scavenger must run at least once every 2 minutes
//
#define RX_MAX_SCAVENGER_TIME_INTERVAL           120


//
//  An instance of this data structure is embedded as part of those data structures
//  that are scavenged, i.e., FCB, RX_CONTEXT, etc.
//

#define RX_SCAVENGER_ENTRY_TYPE_MARKER   (0x0001)
#define RX_SCAVENGER_ENTRY_TYPE_FCB      (0x0002)

#define RX_SCAVENGER_OP_PURGE            (0x0001)
#define RX_SCAVENGER_OP_CLOSE            (0x0002)

#define RX_SCAVENGER_INITIATED_OPERATION     (0x0001)

typedef enum _RX_SCAVENGER_ENTRY_STATE {
    RX_SCAVENGING_INACTIVE,
    RX_SCAVENGING_PENDING,
    RX_SCAVENGING_IN_PROGRESS,
    RX_SCAVENGING_AWAITING_RESPONSE
} RX_SCAVENGER_ENTRY_STATE, *PRX_SCAVENGER_ENTRY_STATE;

typedef struct _RX_SCAVENGER_ENTRY {

    //
    // List of related items to be scavenged
    //
    
    LIST_ENTRY  List;
    
    UCHAR        Type;
    UCHAR        Operation;
    UCHAR        State;
    UCHAR        Flags;
    
    struct _RX_SCAVENGER_ENTRY *pContinuationEntry;

} RX_SCAVENGER_ENTRY, *PRX_SCAVENGER_ENTRY;


#define RxInitializeScavengerEntry(ScavengerEntry)      \
        (ScavengerEntry)->State  = 0;                   \
        (ScavengerEntry)->Flags  = 0;                   \
        (ScavengerEntry)->Type   = 0;                   \
        (ScavengerEntry)->Operation = 0;                \
        InitializeListHead(&(ScavengerEntry)->List);  \
        (ScavengerEntry)->pContinuationEntry = NULL

#define RX_SCAVENGER_MUTEX_ACQUIRED (1)

typedef enum _RDBSS_SCAVENGER_STATE {
    RDBSS_SCAVENGER_INACTIVE,
    RDBSS_SCAVENGER_DORMANT,
    RDBSS_SCAVENGER_ACTIVE,
    RDBSS_SCAVENGER_SUSPENDED
} RDBSS_SCAVENGER_STATE, *PRDBSS_SCAVENGER_STATE;

typedef struct _RDBSS_SCAVENGER {
    
    RDBSS_SCAVENGER_STATE State;
    
    LONG MaximumNumberOfDormantFiles;
    __volatile LONG NumberOfDormantFiles;
    
    LARGE_INTEGER TimeLimit; 

    ULONG SrvCallsToBeFinalized;
    ULONG NetRootsToBeFinalized;
    ULONG VNetRootsToBeFinalized;
    ULONG FcbsToBeFinalized;
    ULONG SrvOpensToBeFinalized;
    ULONG FobxsToBeFinalized;
    
    LIST_ENTRY SrvCallFinalizationList;
    LIST_ENTRY NetRootFinalizationList;
    LIST_ENTRY VNetRootFinalizationList;
    LIST_ENTRY FcbFinalizationList;
    LIST_ENTRY SrvOpenFinalizationList;
    LIST_ENTRY FobxFinalizationList;
    
    LIST_ENTRY ClosePendingFobxsList;
    
    RX_WORK_ITEM WorkItem;
    KEVENT SyncEvent;
    KEVENT ScavengeEvent;
    
    PETHREAD CurrentScavengerThread;
    PNET_ROOT CurrentNetRootForClosePendingProcessing;
    PFCB CurrentFcbForClosePendingProcessing;
    KEVENT ClosePendingProcessingSyncEvent;

} RDBSS_SCAVENGER, *PRDBSS_SCAVENGER;

#define RxInitializeRdbssScavenger(Scavenger, ScavengerTimeLimit)          \
    (Scavenger)->State = RDBSS_SCAVENGER_INACTIVE;                         \
    (Scavenger)->SrvCallsToBeFinalized = 0;                                \
    (Scavenger)->NetRootsToBeFinalized = 0;                                \
    (Scavenger)->VNetRootsToBeFinalized = 0;                               \
    (Scavenger)->FcbsToBeFinalized = 0;                                    \
    (Scavenger)->SrvOpensToBeFinalized = 0;                                \
    (Scavenger)->FobxsToBeFinalized = 0;                                   \
    (Scavenger)->NumberOfDormantFiles = 0;                                 \
    (Scavenger)->MaximumNumberOfDormantFiles = 50;                         \
    (Scavenger)->CurrentFcbForClosePendingProcessing = NULL;               \
    (Scavenger)->CurrentNetRootForClosePendingProcessing = NULL;           \
    if( (ScavengerTimeLimit).QuadPart == 0 ) {                                        \
          (Scavenger)->TimeLimit.QuadPart = RX_SCAVENGER_FINALIZATION_TIME_INTERVAL;  \
    } else {                                                                          \
          (Scavenger)->TimeLimit.QuadPart = (ScavengerTimeLimit).QuadPart;            \
    }                                                                                 \
    KeInitializeEvent(&((Scavenger)->SyncEvent),NotificationEvent,FALSE);  \
    KeInitializeEvent(&((Scavenger)->ScavengeEvent),SynchronizationEvent,TRUE); \
    KeInitializeEvent(&((Scavenger)->ClosePendingProcessingSyncEvent),NotificationEvent,FALSE);  \
    InitializeListHead(&(Scavenger)->SrvCallFinalizationList);           \
    InitializeListHead(&(Scavenger)->NetRootFinalizationList);           \
    InitializeListHead(&(Scavenger)->VNetRootFinalizationList);          \
    InitializeListHead(&(Scavenger)->SrvOpenFinalizationList);           \
    InitializeListHead(&(Scavenger)->FcbFinalizationList);               \
    InitializeListHead(&(Scavenger)->FobxFinalizationList);              \
    InitializeListHead(&(Scavenger)->ClosePendingFobxsList)


#define RxAcquireScavengerMutex()   \
        KeWaitForSingleObject( &RxScavengerMutex, Executive, KernelMode, FALSE, NULL )

#define RxReleaseScavengerMutex()   \
        KeReleaseMutex( &RxScavengerMutex, FALSE )

NTSTATUS
RxMarkFcbForScavengingAtCleanup (
    PFCB Fcb
    );

NTSTATUS
RxMarkFcbForScavengingAtClose (
    PFCB 
    Fcb
    );

VOID
RxUpdateScavengerOnCloseCompletion (
    PFCB 
    Fcb
    );

VOID
RxMarkFobxOnCleanup (
    PFOBX pFobx, 
    PBOOLEAN NeedPurge
    );

VOID
RxMarkFobxOnClose (
    PFOBX Fobx
    );

NTSTATUS
RxPurgeRelatedFobxs (
    PNET_ROOT NetRoot,
    PRX_CONTEXT RxContext,
    BOOLEAN AttemptFinalization,
    PFCB PurgingFcb
    );

#define DONT_ATTEMPT_FINALIZE_ON_PURGE FALSE
#define ATTEMPT_FINALIZE_ON_PURGE TRUE

//
//  the purge_sync context is used to synchronize contexts that are attempting to purge...
//  notatbly creates and dirctrls. these are planted in various structures because various minirdrs
//  require different granularity of purge operations
//

    
typedef struct _PURGE_SYNCHRONIZATION_CONTEXT {

    //
    //  the list of purge requests active for this netroot.
    //

    LIST_ENTRY   ContextsAwaitingPurgeCompletion; 
    BOOLEAN      PurgeInProgress;
} PURGE_SYNCHRONIZATION_CONTEXT, *PPURGE_SYNCHRONIZATION_CONTEXT;

VOID
RxInitializePurgeSyncronizationContext (
    PPURGE_SYNCHRONIZATION_CONTEXT PurgeSyncronizationContext
    );

NTSTATUS
RxScavengeRelatedFcbs (
    PRX_CONTEXT RxContext
    );

BOOLEAN
RxScavengeRelatedFobxs (
    PFCB Fcb
    );

VOID
RxScavengeFobxsForNetRoot (
    PNET_ROOT NetRoot,
    PFCB             PurgingFcb,
    BOOLEAN          SynchronizeWithScavenger
    );

VOID
RxpMarkInstanceForScavengedFinalization (
   PVOID Instance
   );

VOID
RxpUndoScavengerFinalizationMarking (
   PVOID Instance
   );

VOID
RxTerminateScavenging (
   PRX_CONTEXT RxContext
   );

BOOLEAN
RxScavengeVNetRoots (
    PRDBSS_DEVICE_OBJECT RxDeviceObject
    );

VOID
RxSynchronizeWithScavenger (
    IN PRX_CONTEXT RxContext,
    IN PFCB Fcb
    );

#endif // _SCAVENGR_H_


#elif (NTDDI_VERSION >= NTDDI_WS03)

/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    scavengr.h

Abstract:

    This module defines data structures related to scavenging in the RDBSS

Author:
Revision History:


Notes:

    The dormant file limit must be made configurable on a per server basis

--*/

#ifndef _SCAVENGR_H_
#define _SCAVENGR_H_

//                                               
//  currently, only a single scavengermutex is across all scavenging operations
//  for all underlying deviceobjects
//

extern KMUTEX       RxScavengerMutex;

//
// by default the scavenger will run once every 10 seconds
//
#define RX_SCAVENGER_FINALIZATION_TIME_INTERVAL (10 * 1000 * 1000 * 10)

//
// scavenger must run at least once every 2 minutes
//
#define RX_MAX_SCAVENGER_TIME_INTERVAL           120


//
//  An instance of this data structure is embedded as part of those data structures
//  that are scavenged, i.e., FCB, RX_CONTEXT, etc.
//

#define RX_SCAVENGER_ENTRY_TYPE_MARKER   (0x0001)
#define RX_SCAVENGER_ENTRY_TYPE_FCB      (0x0002)

#define RX_SCAVENGER_OP_PURGE            (0x0001)
#define RX_SCAVENGER_OP_CLOSE            (0x0002)

#define RX_SCAVENGER_INITIATED_OPERATION     (0x0001)

typedef enum _RX_SCAVENGER_ENTRY_STATE {
    RX_SCAVENGING_INACTIVE,
    RX_SCAVENGING_PENDING,
    RX_SCAVENGING_IN_PROGRESS,
    RX_SCAVENGING_AWAITING_RESPONSE
} RX_SCAVENGER_ENTRY_STATE, *PRX_SCAVENGER_ENTRY_STATE;

typedef struct _RX_SCAVENGER_ENTRY {

    //
    // List of related items to be scavenged
    //
    
    LIST_ENTRY  List;
    
    UCHAR        Type;
    UCHAR        Operation;
    UCHAR        State;
    UCHAR        Flags;
    
    struct _RX_SCAVENGER_ENTRY *pContinuationEntry;

} RX_SCAVENGER_ENTRY, *PRX_SCAVENGER_ENTRY;


#define RxInitializeScavengerEntry(ScavengerEntry)      \
        (ScavengerEntry)->State  = 0;                   \
        (ScavengerEntry)->Flags  = 0;                   \
        (ScavengerEntry)->Type   = 0;                   \
        (ScavengerEntry)->Operation = 0;                \
        InitializeListHead(&(ScavengerEntry)->List);  \
        (ScavengerEntry)->pContinuationEntry = NULL

#define RX_SCAVENGER_MUTEX_ACQUIRED (1)

typedef enum _RDBSS_SCAVENGER_STATE {
    RDBSS_SCAVENGER_INACTIVE,
    RDBSS_SCAVENGER_DORMANT,
    RDBSS_SCAVENGER_ACTIVE,
    RDBSS_SCAVENGER_SUSPENDED
} RDBSS_SCAVENGER_STATE, *PRDBSS_SCAVENGER_STATE;

typedef struct _RDBSS_SCAVENGER {
    
    RDBSS_SCAVENGER_STATE State;
    
    LONG MaximumNumberOfDormantFiles;
    LONG NumberOfDormantFiles;
    
    LARGE_INTEGER TimeLimit; 

    ULONG SrvCallsToBeFinalized;
    ULONG NetRootsToBeFinalized;
    ULONG VNetRootsToBeFinalized;
    ULONG FcbsToBeFinalized;
    ULONG SrvOpensToBeFinalized;
    ULONG FobxsToBeFinalized;
    
    LIST_ENTRY SrvCallFinalizationList;
    LIST_ENTRY NetRootFinalizationList;
    LIST_ENTRY VNetRootFinalizationList;
    LIST_ENTRY FcbFinalizationList;
    LIST_ENTRY SrvOpenFinalizationList;
    LIST_ENTRY FobxFinalizationList;
    
    LIST_ENTRY ClosePendingFobxsList;
    
    RX_WORK_ITEM WorkItem;
    KEVENT SyncEvent;
    KEVENT ScavengeEvent;
    
    PETHREAD CurrentScavengerThread;
    PNET_ROOT CurrentNetRootForClosePendingProcessing;
    PFCB CurrentFcbForClosePendingProcessing;
    KEVENT ClosePendingProcessingSyncEvent;

} RDBSS_SCAVENGER, *PRDBSS_SCAVENGER;

#define RxInitializeRdbssScavenger(Scavenger, ScavengerTimeLimit)          \
    (Scavenger)->State = RDBSS_SCAVENGER_INACTIVE;                         \
    (Scavenger)->SrvCallsToBeFinalized = 0;                                \
    (Scavenger)->NetRootsToBeFinalized = 0;                                \
    (Scavenger)->VNetRootsToBeFinalized = 0;                               \
    (Scavenger)->FcbsToBeFinalized = 0;                                    \
    (Scavenger)->SrvOpensToBeFinalized = 0;                                \
    (Scavenger)->FobxsToBeFinalized = 0;                                   \
    (Scavenger)->NumberOfDormantFiles = 0;                                 \
    (Scavenger)->MaximumNumberOfDormantFiles = 50;                         \
    (Scavenger)->CurrentFcbForClosePendingProcessing = NULL;               \
    (Scavenger)->CurrentNetRootForClosePendingProcessing = NULL;           \
    if( (ScavengerTimeLimit).QuadPart == 0 ) {                                        \
          (Scavenger)->TimeLimit.QuadPart = RX_SCAVENGER_FINALIZATION_TIME_INTERVAL;  \
    } else {                                                                          \
          (Scavenger)->TimeLimit.QuadPart = (ScavengerTimeLimit).QuadPart;            \
    }                                                                                 \
    KeInitializeEvent(&((Scavenger)->SyncEvent),NotificationEvent,FALSE);  \
    KeInitializeEvent(&((Scavenger)->ScavengeEvent),SynchronizationEvent,TRUE); \
    KeInitializeEvent(&((Scavenger)->ClosePendingProcessingSyncEvent),NotificationEvent,FALSE);  \
    InitializeListHead(&(Scavenger)->SrvCallFinalizationList);           \
    InitializeListHead(&(Scavenger)->NetRootFinalizationList);           \
    InitializeListHead(&(Scavenger)->VNetRootFinalizationList);          \
    InitializeListHead(&(Scavenger)->SrvOpenFinalizationList);           \
    InitializeListHead(&(Scavenger)->FcbFinalizationList);               \
    InitializeListHead(&(Scavenger)->FobxFinalizationList);              \
    InitializeListHead(&(Scavenger)->ClosePendingFobxsList)


#define RxAcquireScavengerMutex()   \
        KeWaitForSingleObject( &RxScavengerMutex, Executive, KernelMode, FALSE, NULL )

#define RxReleaseScavengerMutex()   \
        KeReleaseMutex( &RxScavengerMutex, FALSE )

NTSTATUS
RxMarkFcbForScavengingAtCleanup (
    PFCB Fcb
    );

NTSTATUS
RxMarkFcbForScavengingAtClose (
    PFCB 
    Fcb
    );

VOID
RxUpdateScavengerOnCloseCompletion (
    PFCB 
    Fcb
    );

VOID
RxMarkFobxOnCleanup (
    PFOBX pFobx, 
    PBOOLEAN NeedPurge
    );

VOID
RxMarkFobxOnClose (
    PFOBX Fobx
    );

NTSTATUS
RxPurgeRelatedFobxs (
    PNET_ROOT NetRoot,
    PRX_CONTEXT RxContext,
    BOOLEAN AttemptFinalization,
    PFCB PurgingFcb
    );

#define DONT_ATTEMPT_FINALIZE_ON_PURGE FALSE
#define ATTEMPT_FINALIZE_ON_PURGE TRUE

//
//  the purge_sync context is used to synchronize contexts that are attempting to purge...
//  notatbly creates and dirctrls. these are planted in various structures because various minirdrs
//  require different granularity of purge operations
//

    
typedef struct _PURGE_SYNCHRONIZATION_CONTEXT {

    //
    //  the list of purge requests active for this netroot.
    //

    LIST_ENTRY   ContextsAwaitingPurgeCompletion; 
    BOOLEAN      PurgeInProgress;
} PURGE_SYNCHRONIZATION_CONTEXT, *PPURGE_SYNCHRONIZATION_CONTEXT;

VOID
RxInitializePurgeSyncronizationContext (
    PPURGE_SYNCHRONIZATION_CONTEXT PurgeSyncronizationContext
    );

NTSTATUS
RxScavengeRelatedFcbs (
    PRX_CONTEXT RxContext
    );

BOOLEAN
RxScavengeRelatedFobxs (
    PFCB Fcb
    );

VOID
RxScavengeFobxsForNetRoot (
    PNET_ROOT NetRoot,
    PFCB             PurgingFcb,
    BOOLEAN          SynchronizeWithScavenger
    );

VOID
RxpMarkInstanceForScavengedFinalization (
   PVOID Instance
   );

VOID
RxpUndoScavengerFinalizationMarking (
   PVOID Instance
   );

VOID
RxTerminateScavenging (
   PRX_CONTEXT RxContext
   );

BOOLEAN
RxScavengeVNetRoots (
    PRDBSS_DEVICE_OBJECT RxDeviceObject
    );

VOID
RxSynchronizeWithScavenger (
    IN PRX_CONTEXT RxContext,
    IN PFCB Fcb
    );

#endif // _SCAVENGR_H_



#elif (NTDDI_VERSION >= NTDDI_WINXP)

/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    scavengr.h

Abstract:

    This module defines data structures related to scavenging in the RDBSS

Author:
Revision History:


Notes:

    The dormant file limit must be made configurable on a per server basis

--*/

#ifndef _SCAVENGR_H_
#define _SCAVENGR_H_

// currently, only a single scavengermutex is across all scavenging operations
// for all underlying deviceobjects
extern KMUTEX       RxScavengerMutex;

#define RX_SCAVENGER_FINALIZATION_TIME_INTERVAL (10 * 1000 * 1000 * 10)

// An instance of this data structure is embedded as part of those data structures
// that are scavenged, i.e., FCB, RX_CONTEXT, etc.

#define RX_SCAVENGER_ENTRY_TYPE_MARKER   (0x0001)
#define RX_SCAVENGER_ENTRY_TYPE_FCB      (0x0002)

#define RX_SCAVENGER_OP_PURGE            (0x0001)
#define RX_SCAVENGER_OP_CLOSE            (0x0002)

#define RX_SCAVENGER_INITIATED_OPERATION     (0x0001)

typedef enum _RX_SCAVENGER_ENTRY_STATE {
   RX_SCAVENGING_INACTIVE,
   RX_SCAVENGING_PENDING,
   RX_SCAVENGING_IN_PROGRESS,
   RX_SCAVENGING_AWAITING_RESPONSE
} RX_SCAVENGER_ENTRY_STATE, *PRX_SCAVENGER_ENTRY_STATE;

typedef struct _RX_SCAVENGER_ENTRY {
   // List of related items to be scavenged
   LIST_ENTRY  List;

   UCHAR        Type;
   UCHAR        Operation;
   UCHAR        State;
   UCHAR        Flags;

   struct _RX_SCAVENGER_ENTRY *pContinuationEntry;
} RX_SCAVENGER_ENTRY, *PRX_SCAVENGER_ENTRY;


#define RxInitializeScavengerEntry(pScavengerEntry)      \
        (pScavengerEntry)->State  = 0;                   \
        (pScavengerEntry)->Flags  = 0;                   \
        (pScavengerEntry)->Type   = 0;                   \
        (pScavengerEntry)->Operation = 0;                \
        InitializeListHead(&(pScavengerEntry)->List);  \
        (pScavengerEntry)->pContinuationEntry = NULL

#define RX_SCAVENGER_MUTEX_ACQUIRED (1)

typedef enum _RDBSS_SCAVENGER_STATE {
   RDBSS_SCAVENGER_INACTIVE,
   RDBSS_SCAVENGER_DORMANT,
   RDBSS_SCAVENGER_ACTIVE,
   RDBSS_SCAVENGER_SUSPENDED
} RDBSS_SCAVENGER_STATE, *PRDBSS_SCAVENGER_STATE;

typedef struct _RDBSS_SCAVENGER {
   RDBSS_SCAVENGER_STATE State;

   LONG                 MaximumNumberOfDormantFiles;
   LONG                 NumberOfDormantFiles;

   LARGE_INTEGER        TimeLimit; 


   ULONG                 SrvCallsToBeFinalized;
   ULONG                 NetRootsToBeFinalized;
   ULONG                 VNetRootsToBeFinalized;
   ULONG                 FcbsToBeFinalized;
   ULONG                 SrvOpensToBeFinalized;
   ULONG                 FobxsToBeFinalized;

   LIST_ENTRY            SrvCallFinalizationList;
   LIST_ENTRY            NetRootFinalizationList;
   LIST_ENTRY            VNetRootFinalizationList;
   LIST_ENTRY            FcbFinalizationList;
   LIST_ENTRY            SrvOpenFinalizationList;
   LIST_ENTRY            FobxFinalizationList;

   LIST_ENTRY            ClosePendingFobxsList;

   RX_WORK_ITEM          WorkItem;
   KEVENT                SyncEvent;
   KEVENT                ScavengeEvent;

   PETHREAD              CurrentScavengerThread;
   PNET_ROOT             CurrentNetRootForClosePendingProcessing;
   PFCB                  CurrentFcbForClosePendingProcessing;
   KEVENT                ClosePendingProcessingSyncEvent;
} RDBSS_SCAVENGER, *PRDBSS_SCAVENGER;

#if 0
//this is not used anywhere
typedef struct _RX_FCB_SCAVENGER_ {
   ULONG               State;
   ULONG               OperationsCompleted;
   PRX_SCAVENGER_ENTRY pLastActiveMarkerEntry;
   LIST_ENTRY          OperationsPendingList;
   LIST_ENTRY          OperationsInProgressList;
   LIST_ENTRY          OperationsAwaitingResponseList;
} RX_FCB_SCAVENGER, *PRX_FCB_SCAVENGER;

#define RxInitializeFcbScavenger(pFcbScavenger)                              \
    (pFcbScavenger)->pLastActiveMarkerEntry = NULL;                          \
    (pFcbScavenger)->OperationsCompleted    = 0;                             \
    (pFcbScavenger)->State                  = 0;                             \
    InitializeListHead(&(pFcbScavenger)->OperationsPendingList);           \
    InitializeListHead(&(pFcbScavenger)->OperationsInProgressList);        \
    InitializeListHead(&(pFcbScavenger)->OperationsAwaitingResponseList)
#endif

#define RxInitializeRdbssScavenger(pScavenger, ScavengerTimeLimit)          \
    (pScavenger)->State = RDBSS_SCAVENGER_INACTIVE;                         \
    (pScavenger)->SrvCallsToBeFinalized = 0;                                \
    (pScavenger)->NetRootsToBeFinalized = 0;                                \
    (pScavenger)->VNetRootsToBeFinalized = 0;                               \
    (pScavenger)->FcbsToBeFinalized = 0;                                    \
    (pScavenger)->SrvOpensToBeFinalized = 0;                                \
    (pScavenger)->FobxsToBeFinalized = 0;                                   \
    (pScavenger)->NumberOfDormantFiles = 0;                                 \
    (pScavenger)->MaximumNumberOfDormantFiles = 50;                         \
    (pScavenger)->CurrentFcbForClosePendingProcessing = NULL;               \
    (pScavenger)->CurrentNetRootForClosePendingProcessing = NULL;           \
    if( (ScavengerTimeLimit).QuadPart == 0 ) {                                        \
          (pScavenger)->TimeLimit.QuadPart = RX_SCAVENGER_FINALIZATION_TIME_INTERVAL; \
    } else {                                                                          \
          (pScavenger)->TimeLimit.QuadPart = (ScavengerTimeLimit).QuadPart;           \
    }                                                                                 \
    KeInitializeEvent(&((pScavenger)->SyncEvent),NotificationEvent,FALSE);  \
    KeInitializeEvent(&((pScavenger)->ClosePendingProcessingSyncEvent),NotificationEvent,FALSE);  \
    KeInitializeEvent(&((pScavenger)->ScavengeEvent),SynchronizationEvent,TRUE); \
    InitializeListHead(&(pScavenger)->SrvCallFinalizationList);           \
    InitializeListHead(&(pScavenger)->NetRootFinalizationList);           \
    InitializeListHead(&(pScavenger)->VNetRootFinalizationList);          \
    InitializeListHead(&(pScavenger)->SrvOpenFinalizationList);           \
    InitializeListHead(&(pScavenger)->FcbFinalizationList);               \
    InitializeListHead(&(pScavenger)->FobxFinalizationList);              \
    InitializeListHead(&(pScavenger)->ClosePendingFobxsList)


#define RxAcquireScavengerMutex()   \
        KeWaitForSingleObject(&RxScavengerMutex,Executive,KernelMode,FALSE,NULL)

#define RxReleaseScavengerMutex()   \
        KeReleaseMutex(&RxScavengerMutex,FALSE)

extern NTSTATUS
RxMarkFcbForScavengingAtCleanup(PFCB pFcb);

extern NTSTATUS
RxMarkFcbForScavengingAtClose(PFCB pFcb);

extern VOID
RxUpdateScavengerOnCloseCompletion(PFCB pFcb);

extern VOID
RxMarkFobxOnCleanup(PFOBX pFobx, BOOLEAN *pNeedPurge);

extern VOID
RxMarkFobxOnClose(PFOBX pFobx);

extern NTSTATUS
RxPurgeRelatedFobxs(PNET_ROOT pNetRoot,PRX_CONTEXT pRxContext,BOOLEAN AttemptFinalization,PFCB PurgingFcb);
#define DONT_ATTEMPT_FINALIZE_ON_PURGE FALSE
#define ATTEMPT_FINALIZE_ON_PURGE TRUE
//
// the purge_sync context is used to synchronize contexts that are attempting to purge...
// notatbly creates and dirctrls. these are planted in various structures because various minirdrs
// require different granularity of purge operations

typedef struct _PURGE_SYNCHRONIZATION_CONTEXT {
    LIST_ENTRY   ContextsAwaitingPurgeCompletion; // the list of purge requests active for this netroot.
    BOOLEAN      PurgeInProgress;
} PURGE_SYNCHRONIZATION_CONTEXT, *PPURGE_SYNCHRONIZATION_CONTEXT;

VOID
RxInitializePurgeSyncronizationContext (
    PPURGE_SYNCHRONIZATION_CONTEXT PurgeSyncronizationContext
    );


extern NTSTATUS
RxScavengeRelatedFcbs(PRX_CONTEXT pRxContext);

extern BOOLEAN
RxScavengeRelatedFobxs(PFCB pFcb);

extern VOID
RxScavengeFobxsForNetRoot(
    struct _NET_ROOT *pNetRoot,
    PFCB             PurgingFcb,
    BOOLEAN          SynchronizeWithScavenger);

extern VOID
RxpMarkInstanceForScavengedFinalization(
   PVOID pInstance);

extern VOID
RxpUndoScavengerFinalizationMarking(
   PVOID pInstance);

extern VOID
RxTerminateScavenging(
   PRX_CONTEXT pRxContext);

extern BOOLEAN
RxScavengeVNetRoots(
    PRDBSS_DEVICE_OBJECT RxDeviceObject);

extern VOID
RxSynchronizeWithScavenger(
    PRX_CONTEXT RxContext);

#endif // _SCAVENGR_H_



#elif (NTDDI_VERSION >= NTDDI_WIN2K)

/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    scavengr.h

Abstract:

    This module defines data structures related to scavenging in the RDBSS

Author:
Revision History:


Notes:

    The dormant file limit must be made configurable on a per server basis

--*/

#ifndef _SCAVENGR_H_
#define _SCAVENGR_H_

// currently, only a single scavengermutex is across all scavenging operations
// for all underlying deviceobjects
extern KMUTEX       RxScavengerMutex;

// An instance of this data structure is embedded as part of those data structures
// that are scavenged, i.e., FCB, RX_CONTEXT, etc.

#define RX_SCAVENGER_ENTRY_TYPE_MARKER   (0x0001)
#define RX_SCAVENGER_ENTRY_TYPE_FCB      (0x0002)

#define RX_SCAVENGER_OP_PURGE            (0x0001)
#define RX_SCAVENGER_OP_CLOSE            (0x0002)

#define RX_SCAVENGER_INITIATED_OPERATION     (0x0001)

typedef enum _RX_SCAVENGER_ENTRY_STATE {
   RX_SCAVENGING_INACTIVE,
   RX_SCAVENGING_PENDING,
   RX_SCAVENGING_IN_PROGRESS,
   RX_SCAVENGING_AWAITING_RESPONSE
} RX_SCAVENGER_ENTRY_STATE, *PRX_SCAVENGER_ENTRY_STATE;

typedef struct _RX_SCAVENGER_ENTRY {
   // List of related items to be scavenged
   LIST_ENTRY  List;

   UCHAR        Type;
   UCHAR        Operation;
   UCHAR        State;
   UCHAR        Flags;

   struct _RX_SCAVENGER_ENTRY *pContinuationEntry;
} RX_SCAVENGER_ENTRY, *PRX_SCAVENGER_ENTRY;


#define RxInitializeScavengerEntry(pScavengerEntry)      \
        (pScavengerEntry)->State  = 0;                   \
        (pScavengerEntry)->Flags  = 0;                   \
        (pScavengerEntry)->Type   = 0;                   \
        (pScavengerEntry)->Operation = 0;                \
        InitializeListHead(&(pScavengerEntry)->List);  \
        (pScavengerEntry)->pContinuationEntry = NULL

#define RX_SCAVENGER_MUTEX_ACQUIRED (1)

typedef enum _RDBSS_SCAVENGER_STATE {
   RDBSS_SCAVENGER_INACTIVE,
   RDBSS_SCAVENGER_DORMANT,
   RDBSS_SCAVENGER_ACTIVE,
   RDBSS_SCAVENGER_SUSPENDED
} RDBSS_SCAVENGER_STATE, *PRDBSS_SCAVENGER_STATE;

typedef struct _RDBSS_SCAVENGER {
   RDBSS_SCAVENGER_STATE State;

   LONG                 MaximumNumberOfDormantFiles;
   LONG                 NumberOfDormantFiles;

   ULONG                 SrvCallsToBeFinalized;
   ULONG                 NetRootsToBeFinalized;
   ULONG                 VNetRootsToBeFinalized;
   ULONG                 FcbsToBeFinalized;
   ULONG                 SrvOpensToBeFinalized;
   ULONG                 FobxsToBeFinalized;

   LIST_ENTRY            SrvCallFinalizationList;
   LIST_ENTRY            NetRootFinalizationList;
   LIST_ENTRY            VNetRootFinalizationList;
   LIST_ENTRY            FcbFinalizationList;
   LIST_ENTRY            SrvOpenFinalizationList;
   LIST_ENTRY            FobxFinalizationList;

   LIST_ENTRY            ClosePendingFobxsList;

   RX_WORK_ITEM          WorkItem;
   KEVENT                SyncEvent;

   PETHREAD              CurrentScavengerThread;
   PNET_ROOT             CurrentNetRootForClosePendingProcessing;
   PFCB                  CurrentFcbForClosePendingProcessing;
   KEVENT                ClosePendingProcessingSyncEvent;
} RDBSS_SCAVENGER, *PRDBSS_SCAVENGER;

#if 0
//this is not used anywhere
typedef struct _RX_FCB_SCAVENGER_ {
   ULONG               State;
   ULONG               OperationsCompleted;
   PRX_SCAVENGER_ENTRY pLastActiveMarkerEntry;
   LIST_ENTRY          OperationsPendingList;
   LIST_ENTRY          OperationsInProgressList;
   LIST_ENTRY          OperationsAwaitingResponseList;
} RX_FCB_SCAVENGER, *PRX_FCB_SCAVENGER;

#define RxInitializeFcbScavenger(pFcbScavenger)                              \
    (pFcbScavenger)->pLastActiveMarkerEntry = NULL;                          \
    (pFcbScavenger)->OperationsCompleted    = 0;                             \
    (pFcbScavenger)->State                  = 0;                             \
    InitializeListHead(&(pFcbScavenger)->OperationsPendingList);           \
    InitializeListHead(&(pFcbScavenger)->OperationsInProgressList);        \
    InitializeListHead(&(pFcbScavenger)->OperationsAwaitingResponseList)
#endif

#define RxInitializeRdbssScavenger(pScavenger)                              \
    (pScavenger)->State = RDBSS_SCAVENGER_INACTIVE;                         \
    (pScavenger)->SrvCallsToBeFinalized = 0;                                \
    (pScavenger)->NetRootsToBeFinalized = 0;                                \
    (pScavenger)->VNetRootsToBeFinalized = 0;                               \
    (pScavenger)->FcbsToBeFinalized = 0;                                    \
    (pScavenger)->SrvOpensToBeFinalized = 0;                                \
    (pScavenger)->FobxsToBeFinalized = 0;                                   \
    (pScavenger)->NumberOfDormantFiles = 0;                                 \
    (pScavenger)->MaximumNumberOfDormantFiles = 50;                         \
    (pScavenger)->CurrentFcbForClosePendingProcessing = NULL;               \
    (pScavenger)->CurrentNetRootForClosePendingProcessing = NULL;           \
    KeInitializeEvent(&((pScavenger)->SyncEvent),NotificationEvent,FALSE);  \
    KeInitializeEvent(&((pScavenger)->ClosePendingProcessingSyncEvent),NotificationEvent,FALSE);  \
    InitializeListHead(&(pScavenger)->SrvCallFinalizationList);           \
    InitializeListHead(&(pScavenger)->NetRootFinalizationList);           \
    InitializeListHead(&(pScavenger)->VNetRootFinalizationList);          \
    InitializeListHead(&(pScavenger)->SrvOpenFinalizationList);           \
    InitializeListHead(&(pScavenger)->FcbFinalizationList);               \
    InitializeListHead(&(pScavenger)->FobxFinalizationList);              \
    InitializeListHead(&(pScavenger)->ClosePendingFobxsList)


#define RxAcquireScavengerMutex()   \
        KeWaitForSingleObject(&RxScavengerMutex,Executive,KernelMode,FALSE,NULL)

#define RxReleaseScavengerMutex()   \
        KeReleaseMutex(&RxScavengerMutex,FALSE)

extern NTSTATUS
RxMarkFcbForScavengingAtCleanup(PFCB pFcb);

extern NTSTATUS
RxMarkFcbForScavengingAtClose(PFCB pFcb);

extern VOID
RxUpdateScavengerOnCloseCompletion(PFCB pFcb);

extern VOID
RxMarkFobxOnCleanup(PFOBX pFobx, BOOLEAN *pNeedPurge);

extern VOID
RxMarkFobxOnClose(PFOBX pFobx);

extern NTSTATUS
RxPurgeRelatedFobxs(PNET_ROOT pNetRoot,PRX_CONTEXT pRxContext,BOOLEAN AttemptFinalization);
#define DONT_ATTEMPT_FINALIZE_ON_PURGE FALSE
#define ATTEMPT_FINALIZE_ON_PURGE TRUE
//
// the purge_sync context is used to synchronize contexts that are attempting to purge...
// notatbly creates and dirctrls. these are planted in various structures because various minirdrs
// require different granularity of purge operations

typedef struct _PURGE_SYNCHRONIZATION_CONTEXT {
    LIST_ENTRY   ContextsAwaitingPurgeCompletion; // the list of purge requests active for this netroot.
    BOOLEAN      PurgeInProgress;
} PURGE_SYNCHRONIZATION_CONTEXT, *PPURGE_SYNCHRONIZATION_CONTEXT;

VOID
RxInitializePurgeSyncronizationContext (
    PPURGE_SYNCHRONIZATION_CONTEXT PurgeSyncronizationContext
    );


extern NTSTATUS
RxScavengeRelatedFcbs(PRX_CONTEXT pRxContext);

extern BOOLEAN
RxScavengeRelatedFobxs(PFCB pFcb);

extern VOID
RxScavengeFobxsForNetRoot(
    struct _NET_ROOT *pNetRoot);

extern VOID
RxpMarkInstanceForScavengedFinalization(
   PVOID pInstance);

extern VOID
RxpUndoScavengerFinalizationMarking(
   PVOID pInstance);

extern VOID
RxTerminateScavenging(
   PRX_CONTEXT pRxContext);

extern BOOLEAN
RxScavengeVNetRoots(
    PRDBSS_DEVICE_OBJECT RxDeviceObject);

extern VOID
RxSynchronizeWithScavenger(
    PRX_CONTEXT RxContext);

#endif // _SCAVENGR_H_



#else /* NTDDI_VERSION */

#error This file cannot be included for this NTDDI_VERSION.

#endif /* NTDDI_VERSION */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\scarderr.h ===
/*
 scarderr.mc

   Error message codes from the Smart Card Resource Manager
   These messages must be reconciled with winerror.w
   They exist here to provide error messages on pre-Win2K systems.

*/
#ifndef SCARD_S_SUCCESS
//
// =============================
// Facility SCARD Error Messages
// =============================
//
#define SCARD_S_SUCCESS NO_ERROR
//
//  Values are 32 bit values laid out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-+-----------------------+-------------------------------+
//  |Sev|C|R|     Facility          |               Code            |
//  +---+-+-+-----------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      R - is a reserved bit
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//
//
// Define the facility codes
//
#define FACILITY_SYSTEM                  0x0
#define FACILITY_SCARD                   0x10


//
// Define the severity codes
//
#define STATUS_SEVERITY_WARNING          0x2
#define STATUS_SEVERITY_INFORMATIONAL    0x1
#define STATUS_SEVERITY_ERROR            0x3


//
// MessageId: SCARD_F_INTERNAL_ERROR
//
// MessageText:
//
// An internal consistency check failed.
//
#define SCARD_F_INTERNAL_ERROR           ((DWORD)0x80100001L)

//
// MessageId: SCARD_E_CANCELLED
//
// MessageText:
//
// The action was cancelled by an SCardCancel request.
//
#define SCARD_E_CANCELLED                ((DWORD)0x80100002L)

//
// MessageId: SCARD_E_INVALID_HANDLE
//
// MessageText:
//
// The supplied handle was invalid.
//
#define SCARD_E_INVALID_HANDLE           ((DWORD)0x80100003L)

//
// MessageId: SCARD_E_INVALID_PARAMETER
//
// MessageText:
//
// One or more of the supplied parameters could not be properly interpreted.
//
#define SCARD_E_INVALID_PARAMETER        ((DWORD)0x80100004L)

//
// MessageId: SCARD_E_INVALID_TARGET
//
// MessageText:
//
// Registry startup information is missing or invalid.
//
#define SCARD_E_INVALID_TARGET           ((DWORD)0x80100005L)

//
// MessageId: SCARD_E_NO_MEMORY
//
// MessageText:
//
// Not enough memory available to complete this command.
//
#define SCARD_E_NO_MEMORY                ((DWORD)0x80100006L)

//
// MessageId: SCARD_F_WAITED_TOO_LONG
//
// MessageText:
//
// An internal consistency timer has expired.
//
#define SCARD_F_WAITED_TOO_LONG          ((DWORD)0x80100007L)

//
// MessageId: SCARD_E_INSUFFICIENT_BUFFER
//
// MessageText:
//
// The data buffer to receive returned data is too small for the returned data.
//
#define SCARD_E_INSUFFICIENT_BUFFER      ((DWORD)0x80100008L)

//
// MessageId: SCARD_E_UNKNOWN_READER
//
// MessageText:
//
// The specified reader name is not recognized.
//
#define SCARD_E_UNKNOWN_READER           ((DWORD)0x80100009L)

//
// MessageId: SCARD_E_TIMEOUT
//
// MessageText:
//
// The user-specified timeout value has expired.
//
#define SCARD_E_TIMEOUT                  ((DWORD)0x8010000AL)

//
// MessageId: SCARD_E_SHARING_VIOLATION
//
// MessageText:
//
// The smart card cannot be accessed because of other connections outstanding.
//
#define SCARD_E_SHARING_VIOLATION        ((DWORD)0x8010000BL)

//
// MessageId: SCARD_E_NO_SMARTCARD
//
// MessageText:
//
// The operation requires a Smart Card, but no Smart Card is currently in the device.
//
#define SCARD_E_NO_SMARTCARD             ((DWORD)0x8010000CL)

//
// MessageId: SCARD_E_UNKNOWN_CARD
//
// MessageText:
//
// The specified smart card name is not recognized.
//
#define SCARD_E_UNKNOWN_CARD             ((DWORD)0x8010000DL)

//
// MessageId: SCARD_E_CANT_DISPOSE
//
// MessageText:
//
// The system could not dispose of the media in the requested manner.
//
#define SCARD_E_CANT_DISPOSE             ((DWORD)0x8010000EL)

//
// MessageId: SCARD_E_PROTO_MISMATCH
//
// MessageText:
//
// The requested protocols are incompatible with the protocol currently in use with the smart card.
//
#define SCARD_E_PROTO_MISMATCH           ((DWORD)0x8010000FL)

//
// MessageId: SCARD_E_NOT_READY
//
// MessageText:
//
// The reader or smart card is not ready to accept commands.
//
#define SCARD_E_NOT_READY                ((DWORD)0x80100010L)

//
// MessageId: SCARD_E_INVALID_VALUE
//
// MessageText:
//
// One or more of the supplied parameters values could not be properly interpreted.
//
#define SCARD_E_INVALID_VALUE            ((DWORD)0x80100011L)

//
// MessageId: SCARD_E_SYSTEM_CANCELLED
//
// MessageText:
//
// The action was cancelled by the system, presumably to log off or shut down.
//
#define SCARD_E_SYSTEM_CANCELLED         ((DWORD)0x80100012L)

//
// MessageId: SCARD_F_COMM_ERROR
//
// MessageText:
//
// An internal communications error has been detected.
//
#define SCARD_F_COMM_ERROR               ((DWORD)0x80100013L)

//
// MessageId: SCARD_F_UNKNOWN_ERROR
//
// MessageText:
//
// An internal error has been detected, but the source is unknown.
//
#define SCARD_F_UNKNOWN_ERROR            ((DWORD)0x80100014L)

//
// MessageId: SCARD_E_INVALID_ATR
//
// MessageText:
//
// An ATR obtained from the registry is not a valid ATR string.
//
#define SCARD_E_INVALID_ATR              ((DWORD)0x80100015L)

//
// MessageId: SCARD_E_NOT_TRANSACTED
//
// MessageText:
//
// An attempt was made to end a non-existent transaction.
//
#define SCARD_E_NOT_TRANSACTED           ((DWORD)0x80100016L)

//
// MessageId: SCARD_E_READER_UNAVAILABLE
//
// MessageText:
//
// The specified reader is not currently available for use.
//
#define SCARD_E_READER_UNAVAILABLE       ((DWORD)0x80100017L)

//
// MessageId: SCARD_P_SHUTDOWN
//
// MessageText:
//
// The operation has been aborted to allow the server application to exit.
//
#define SCARD_P_SHUTDOWN                 ((DWORD)0x80100018L)

//
// MessageId: SCARD_E_PCI_TOO_SMALL
//
// MessageText:
//
// The PCI Receive buffer was too small.
//
#define SCARD_E_PCI_TOO_SMALL            ((DWORD)0x80100019L)

//
// MessageId: SCARD_E_READER_UNSUPPORTED
//
// MessageText:
//
// The reader driver does not meet minimal requirements for support.
//
#define SCARD_E_READER_UNSUPPORTED       ((DWORD)0x8010001AL)

//
// MessageId: SCARD_E_DUPLICATE_READER
//
// MessageText:
//
// The reader driver did not produce a unique reader name.
//
#define SCARD_E_DUPLICATE_READER         ((DWORD)0x8010001BL)

//
// MessageId: SCARD_E_CARD_UNSUPPORTED
//
// MessageText:
//
// The smart card does not meet minimal requirements for support.
//
#define SCARD_E_CARD_UNSUPPORTED         ((DWORD)0x8010001CL)

//
// MessageId: SCARD_E_NO_SERVICE
//
// MessageText:
//
// The Smart card resource manager is not running.
//
#define SCARD_E_NO_SERVICE               ((DWORD)0x8010001DL)

//
// MessageId: SCARD_E_SERVICE_STOPPED
//
// MessageText:
//
// The Smart card resource manager has shut down.
//
#define SCARD_E_SERVICE_STOPPED          ((DWORD)0x8010001EL)

//
// MessageId: SCARD_E_UNEXPECTED
//
// MessageText:
//
// An unexpected card error has occurred.
//
#define SCARD_E_UNEXPECTED               ((DWORD)0x8010001FL)

//
// MessageId: SCARD_E_ICC_INSTALLATION
//
// MessageText:
//
// No Primary Provider can be found for the smart card.
//
#define SCARD_E_ICC_INSTALLATION         ((DWORD)0x80100020L)

//
// MessageId: SCARD_E_ICC_CREATEORDER
//
// MessageText:
//
// The requested order of object creation is not supported.
//
#define SCARD_E_ICC_CREATEORDER          ((DWORD)0x80100021L)

//
// MessageId: SCARD_E_UNSUPPORTED_FEATURE
//
// MessageText:
//
// This smart card does not support the requested feature.
//
#define SCARD_E_UNSUPPORTED_FEATURE      ((DWORD)0x80100022L)

//
// MessageId: SCARD_E_DIR_NOT_FOUND
//
// MessageText:
//
// The identified directory does not exist in the smart card.
//
#define SCARD_E_DIR_NOT_FOUND            ((DWORD)0x80100023L)

//
// MessageId: SCARD_E_FILE_NOT_FOUND
//
// MessageText:
//
// The identified file does not exist in the smart card.
//
#define SCARD_E_FILE_NOT_FOUND           ((DWORD)0x80100024L)

//
// MessageId: SCARD_E_NO_DIR
//
// MessageText:
//
// The supplied path does not represent a smart card directory.
//
#define SCARD_E_NO_DIR                   ((DWORD)0x80100025L)

//
// MessageId: SCARD_E_NO_FILE
//
// MessageText:
//
// The supplied path does not represent a smart card file.
//
#define SCARD_E_NO_FILE                  ((DWORD)0x80100026L)

//
// MessageId: SCARD_E_NO_ACCESS
//
// MessageText:
//
// Access is denied to this file.
//
#define SCARD_E_NO_ACCESS                ((DWORD)0x80100027L)

//
// MessageId: SCARD_E_WRITE_TOO_MANY
//
// MessageText:
//
// The smartcard does not have enough memory to store the information.
//
#define SCARD_E_WRITE_TOO_MANY           ((DWORD)0x80100028L)

//
// MessageId: SCARD_E_BAD_SEEK
//
// MessageText:
//
// There was an error trying to set the smart card file object pointer.
//
#define SCARD_E_BAD_SEEK                 ((DWORD)0x80100029L)

//
// MessageId: SCARD_E_INVALID_CHV
//
// MessageText:
//
// The supplied PIN is incorrect.
//
#define SCARD_E_INVALID_CHV              ((DWORD)0x8010002AL)

//
// MessageId: SCARD_E_UNKNOWN_RES_MNG
//
// MessageText:
//
// An unrecognized error code was returned from a layered component.
//
#define SCARD_E_UNKNOWN_RES_MNG          ((DWORD)0x8010002BL)

//
// MessageId: SCARD_E_NO_SUCH_CERTIFICATE
//
// MessageText:
//
// The requested certificate does not exist.
//
#define SCARD_E_NO_SUCH_CERTIFICATE      ((DWORD)0x8010002CL)

//
// MessageId: SCARD_E_CERTIFICATE_UNAVAILABLE
//
// MessageText:
//
// The requested certificate could not be obtained.
//
#define SCARD_E_CERTIFICATE_UNAVAILABLE  ((DWORD)0x8010002DL)

//
// MessageId: SCARD_E_NO_READERS_AVAILABLE
//
// MessageText:
//
// Cannot find a smart card reader.
//
#define SCARD_E_NO_READERS_AVAILABLE     ((DWORD)0x8010002EL)

//
// MessageId: SCARD_E_COMM_DATA_LOST
//
// MessageText:
//
// A communications error with the smart card has been detected.  Retry the operation.
//
#define SCARD_E_COMM_DATA_LOST           ((DWORD)0x8010002FL)

//
// MessageId: SCARD_E_NO_KEY_CONTAINER
//
// MessageText:
//
// The requested key container does not exist on the smart card.
//
#define SCARD_E_NO_KEY_CONTAINER         ((DWORD)0x80100030L)

//
// MessageId: SCARD_E_SERVER_TOO_BUSY
//
// MessageText:
//
// The Smart card resource manager is too busy to complete this operation.
//
#define SCARD_E_SERVER_TOO_BUSY          ((DWORD)0x80100031L)

//
// MessageId: SCARD_E_PIN_CACHE_EXPIRED
//
// MessageText:
//
// The smart card PIN cache has expired.
//
#define SCARD_E_PIN_CACHE_EXPIRED        ((DWORD)0x80100032L)

//
// MessageId: SCARD_E_NO_PIN_CACHE
//
// MessageText:
//
// The smart card PIN cannot be cached.
//
#define SCARD_E_NO_PIN_CACHE             ((DWORD)0x80100033L)

//
// MessageId: SCARD_E_READ_ONLY_CARD
//
// MessageText:
//
// The smart card is read only and cannot be written to.
//
#define SCARD_E_READ_ONLY_CARD           ((DWORD)0x80100034L)

//
// These are warning codes.
//
//
// MessageId: SCARD_W_UNSUPPORTED_CARD
//
// MessageText:
//
// The reader cannot communicate with the smart card, due to ATR configuration conflicts.
//
#define SCARD_W_UNSUPPORTED_CARD         ((DWORD)0x80100065L)

//
// MessageId: SCARD_W_UNRESPONSIVE_CARD
//
// MessageText:
//
// The smart card is not responding to a reset.
//
#define SCARD_W_UNRESPONSIVE_CARD        ((DWORD)0x80100066L)

//
// MessageId: SCARD_W_UNPOWERED_CARD
//
// MessageText:
//
// Power has been removed from the smart card, so that further communication is not possible.
//
#define SCARD_W_UNPOWERED_CARD           ((DWORD)0x80100067L)

//
// MessageId: SCARD_W_RESET_CARD
//
// MessageText:
//
// The smart card has been reset, so any shared state information is invalid.
//
#define SCARD_W_RESET_CARD               ((DWORD)0x80100068L)

//
// MessageId: SCARD_W_REMOVED_CARD
//
// MessageText:
//
// The smart card has been removed, so that further communication is not possible.
//
#define SCARD_W_REMOVED_CARD             ((DWORD)0x80100069L)

//
// MessageId: SCARD_W_SECURITY_VIOLATION
//
// MessageText:
//
// Access was denied because of a security violation.
//
#define SCARD_W_SECURITY_VIOLATION       ((DWORD)0x8010006AL)

//
// MessageId: SCARD_W_WRONG_CHV
//
// MessageText:
//
// The card cannot be accessed because the wrong PIN was presented.
//
#define SCARD_W_WRONG_CHV                ((DWORD)0x8010006BL)

//
// MessageId: SCARD_W_CHV_BLOCKED
//
// MessageText:
//
// The card cannot be accessed because the maximum number of PIN entry attempts has been reached.
//
#define SCARD_W_CHV_BLOCKED              ((DWORD)0x8010006CL)

//
// MessageId: SCARD_W_EOF
//
// MessageText:
//
// The end of the smart card file has been reached.
//
#define SCARD_W_EOF                      ((DWORD)0x8010006DL)

//
// MessageId: SCARD_W_CANCELLED_BY_USER
//
// MessageText:
//
// The action was cancelled by the user.
//
#define SCARD_W_CANCELLED_BY_USER        ((DWORD)0x8010006EL)

//
// MessageId: SCARD_W_CARD_NOT_AUTHENTICATED
//
// MessageText:
//
// No PIN was presented to the smart card.
//
#define SCARD_W_CARD_NOT_AUTHENTICATED   ((DWORD)0x8010006FL)

//
// MessageId: SCARD_W_CACHE_ITEM_NOT_FOUND
//
// MessageText:
//
// The requested item could not be found in the cache.
//
#define SCARD_W_CACHE_ITEM_NOT_FOUND     ((DWORD)0x80100070L)

//
// MessageId: SCARD_W_CACHE_ITEM_STALE
//
// MessageText:
//
// The requested cache item is too old and was deleted from the cache.
//
#define SCARD_W_CACHE_ITEM_STALE         ((DWORD)0x80100071L)

//
// MessageId: SCARD_W_CACHE_ITEM_TOO_BIG
//
// MessageText:
//
// The new cache item exceeds the maximum per-item size defined for the cache.
//
#define SCARD_W_CACHE_ITEM_TOO_BIG       ((DWORD)0x80100072L)

#endif // SCARD_S_SUCCESS
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\scsiscan.h ===
/****************************************************************************
*
*  (C) COPYRIGHT 1996-2000, MICROSOFT CORP.
*
*  FILE:        scsiscan.h
*
*  VERSION:     1.0
*
*  DATE:        2/11/1997
*
*  DESCRIPTION:
*    IOCTL definitions for the SCSI scanner device driver.
*
*****************************************************************************/

//
// Turns off []
//
#pragma warning(disable : 4200)

#ifndef _SCSISCAN_H_
#define _SCSISCAN_H_

// SCSISCAN_CMD.SrbFlags

#define SRB_FLAGS_DISABLE_SYNCH_TRANSFER    0x00000008
#define SRB_FLAGS_DISABLE_AUTOSENSE         0x00000020
#define SRB_FLAGS_DATA_IN                   0x00000040
#define SRB_FLAGS_DATA_OUT                  0x00000080
#define SRB_FLAGS_NO_DATA_TRANSFER          0x00000000

// SCSISCAN_CMD.SrbStatus definitions

#define SRB_STATUS_PENDING                  0x00
#define SRB_STATUS_SUCCESS                  0x01
#define SRB_STATUS_ABORTED                  0x02
#define SRB_STATUS_ABORT_FAILED             0x03
#define SRB_STATUS_ERROR                    0x04
#define SRB_STATUS_BUSY                     0x05
#define SRB_STATUS_INVALID_REQUEST          0x06
#define SRB_STATUS_INVALID_PATH_ID          0x07
#define SRB_STATUS_NO_DEVICE                0x08
#define SRB_STATUS_TIMEOUT                  0x09
#define SRB_STATUS_SELECTION_TIMEOUT        0x0A
#define SRB_STATUS_COMMAND_TIMEOUT          0x0B
#define SRB_STATUS_MESSAGE_REJECTED         0x0D
#define SRB_STATUS_BUS_RESET                0x0E
#define SRB_STATUS_PARITY_ERROR             0x0F
#define SRB_STATUS_REQUEST_SENSE_FAILED     0x10
#define SRB_STATUS_NO_HBA                   0x11
#define SRB_STATUS_DATA_OVERRUN             0x12
#define SRB_STATUS_UNEXPECTED_BUS_FREE      0x13
#define SRB_STATUS_PHASE_SEQUENCE_FAILURE   0x14
#define SRB_STATUS_BAD_SRB_BLOCK_LENGTH     0x15
#define SRB_STATUS_REQUEST_FLUSHED          0x16
#define SRB_STATUS_INVALID_LUN              0x20
#define SRB_STATUS_INVALID_TARGET_ID        0x21
#define SRB_STATUS_BAD_FUNCTION             0x22
#define SRB_STATUS_ERROR_RECOVERY           0x23

#define SRB_STATUS_QUEUE_FROZEN             0x40
#define SRB_STATUS_AUTOSENSE_VALID          0x80

#define SRB_STATUS(Status) (Status & ~(SRB_STATUS_AUTOSENSE_VALID | SRB_STATUS_QUEUE_FROZEN))

typedef struct _SCSISCAN_CMD {
	ULONG   Reserved1;	
	ULONG   Size;
	ULONG   SrbFlags;				
	UCHAR   CdbLength;
	UCHAR   SenseLength;
	UCHAR	Reserved2;
	UCHAR	Reserved3;
	ULONG   TransferLength;
	UCHAR	Cdb[16];	
	PUCHAR  pSrbStatus;
	PUCHAR	pSenseBuffer;
} SCSISCAN_CMD, *PSCSISCAN_CMD;
	
// Temporarily set to 128. Should be determined by other definition.
#define MAX_STRING 128

typedef struct _SCSISCAN_INFO{
	ULONG   Size;
	ULONG   Flags;
    UCHAR   PortNumber;
    UCHAR   PathId;
    UCHAR   TargetId;
    UCHAR   Lun;
    UCHAR   AdapterName[MAX_STRING];
	ULONG   Reserved;
} SCSISCAN_INFO, *PSCSISCAN_INFO;

#define SCSISCAN_RESERVED         0x000
#define SCSISCAN_CMD_CODE         0x004
#define SCSISCAN_LOCKDEVICE       0x005
#define SCSISCAN_UNLOCKDEVICE     0x006
#define SCSISCAN_SET_TIMEOUT      0x007
#define SCSISCAN_GET_INFO         0x008

//---------------------------------------------------------------------------
// IOCTL definitions.
// Use these definitions when calling DeviceIoControl
//---------------------------------------------------------------------------
#define IOCTL_SCSISCAN_CMD		     CTL_CODE(FILE_DEVICE_SCANNER, SCSISCAN_CMD_CODE,	    METHOD_OUT_DIRECT, FILE_ANY_ACCESS)
#define IOCTL_SCSISCAN_LOCKDEVICE    CTL_CODE(FILE_DEVICE_SCANNER, SCSISCAN_LOCKDEVICE,		METHOD_OUT_DIRECT, FILE_ANY_ACCESS)
#define IOCTL_SCSISCAN_UNLOCKDEVICE  CTL_CODE(FILE_DEVICE_SCANNER, SCSISCAN_UNLOCKDEVICE,	METHOD_OUT_DIRECT, FILE_ANY_ACCESS)
#define IOCTL_SCSISCAN_SET_TIMEOUT   CTL_CODE(FILE_DEVICE_SCANNER, SCSISCAN_SET_TIMEOUT,	METHOD_BUFFERED,   FILE_ANY_ACCESS)
#define IOCTL_SCSISCAN_GET_INFO      CTL_CODE(FILE_DEVICE_SCANNER, SCSISCAN_GET_INFO   ,	METHOD_OUT_DIRECT, FILE_ANY_ACCESS)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\scsi.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    scsi.h

Abstract:

    These are the structures and defines that are used in the
    SCSI port and class drivers.

Authors:

Revision History:

--*/
#ifndef _NTSCSI_
#define _NTSCSI_

#ifndef _NTSCSI_USER_MODE_
    #include "srb.h"
#endif // !defined _NTSCSI_USER_MODE_


#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning(disable:4200) // array[0] is not a warning for this file
#pragma warning(disable:4201) // nonstandard extension used : nameless struct/union

#pragma pack(push, _scsi_)
// begin_ntminitape

// begin_storport

//
// Command Descriptor Block. Passed by SCSI controller chip over the SCSI bus
//

#pragma pack(push, cdb, 1)
typedef union _CDB {

    //
    // Generic 6-Byte CDB
    //

    struct _CDB6GENERIC {
       UCHAR  OperationCode;
       UCHAR  Immediate : 1;
       UCHAR  CommandUniqueBits : 4;
       UCHAR  LogicalUnitNumber : 3;
       UCHAR  CommandUniqueBytes[3];
       UCHAR  Link : 1;
       UCHAR  Flag : 1;
       UCHAR  Reserved : 4;
       UCHAR  VendorUnique : 2;
    } CDB6GENERIC;

    //
    // Standard 6-byte CDB
    //

    struct _CDB6READWRITE {
        UCHAR OperationCode;    // 0x08, 0x0A - SCSIOP_READ, SCSIOP_WRITE
        UCHAR LogicalBlockMsb1 : 5;
        UCHAR LogicalUnitNumber : 3;
        UCHAR LogicalBlockMsb0;
        UCHAR LogicalBlockLsb;
        UCHAR TransferBlocks;
        UCHAR Control;
    } CDB6READWRITE;

    //
    // SCSI-1 Inquiry CDB
    //

    struct _CDB6INQUIRY {
        UCHAR OperationCode;    // 0x12 - SCSIOP_INQUIRY
        UCHAR Reserved1 : 5;
        UCHAR LogicalUnitNumber : 3;
        UCHAR PageCode;
        UCHAR IReserved;
        UCHAR AllocationLength;
        UCHAR Control;
    } CDB6INQUIRY;

    //
    // SCSI-3 Inquiry CDB
    //

    struct _CDB6INQUIRY3 {
        UCHAR OperationCode;    // 0x12 - SCSIOP_INQUIRY
        UCHAR EnableVitalProductData : 1;
        UCHAR CommandSupportData : 1;
        UCHAR Reserved1 : 6;
        UCHAR PageCode;
        UCHAR Reserved2;
        UCHAR AllocationLength;
        UCHAR Control;
    } CDB6INQUIRY3;

    struct _CDB6VERIFY {
        UCHAR OperationCode;    // 0x13 - SCSIOP_VERIFY
        UCHAR Fixed : 1;
        UCHAR ByteCompare : 1;
        UCHAR Immediate : 1;
        UCHAR Reserved : 2;
        UCHAR LogicalUnitNumber : 3;
        UCHAR VerificationLength[3];
        UCHAR Control;
    } CDB6VERIFY;

    //
    // SCSI Format CDB
    //

    struct _CDB6FORMAT {
        UCHAR OperationCode;    // 0x04 - SCSIOP_FORMAT_UNIT
        UCHAR FormatControl : 5;
        UCHAR LogicalUnitNumber : 3;
        UCHAR FReserved1;
        UCHAR InterleaveMsb;
        UCHAR InterleaveLsb;
        UCHAR FReserved2;
    } CDB6FORMAT;

    //
    // Standard 10-byte CDB

    struct _CDB10 {
        UCHAR OperationCode;
        UCHAR RelativeAddress : 1;
        UCHAR Reserved1 : 2;
        UCHAR ForceUnitAccess : 1;
        UCHAR DisablePageOut : 1;
        UCHAR LogicalUnitNumber : 3;
        UCHAR LogicalBlockByte0;
        UCHAR LogicalBlockByte1;
        UCHAR LogicalBlockByte2;
        UCHAR LogicalBlockByte3;
        UCHAR Reserved2;
        UCHAR TransferBlocksMsb;
        UCHAR TransferBlocksLsb;
        UCHAR Control;
    } CDB10;

    //
    // Standard 12-byte CDB
    //

    struct _CDB12 {
        UCHAR OperationCode;
        UCHAR RelativeAddress : 1;
        UCHAR Reserved1 : 2;
        UCHAR ForceUnitAccess : 1;
        UCHAR DisablePageOut : 1;
        UCHAR LogicalUnitNumber : 3;
        UCHAR LogicalBlock[4];
        UCHAR TransferLength[4];
        UCHAR Reserved2;
        UCHAR Control;
    } CDB12;



    //
    // Standard 16-byte CDB
    //

    struct _CDB16 {
        UCHAR OperationCode;
        UCHAR Reserved1        : 3;
        UCHAR ForceUnitAccess  : 1;
        UCHAR DisablePageOut   : 1;
        UCHAR Protection       : 3;
        UCHAR LogicalBlock[8];
        UCHAR TransferLength[4];
        UCHAR Reserved2;
        UCHAR Control;
    } CDB16;


    //
    // CD Rom Audio CDBs
    //

    struct _PAUSE_RESUME {
        UCHAR OperationCode;    // 0x4B - SCSIOP_PAUSE_RESUME
        UCHAR Reserved1 : 5;
        UCHAR LogicalUnitNumber : 3;
        UCHAR Reserved2[6];
        UCHAR Action;
        UCHAR Control;
    } PAUSE_RESUME;

    //
    // Read Table of Contents
    //

    struct _READ_TOC {
        UCHAR OperationCode;    // 0x43 - SCSIOP_READ_TOC
        UCHAR Reserved0 : 1;
        UCHAR Msf : 1;
        UCHAR Reserved1 : 3;
        UCHAR LogicalUnitNumber : 3;
        UCHAR Format2 : 4;
        UCHAR Reserved2 : 4;
        UCHAR Reserved3[3];
        UCHAR StartingTrack;
        UCHAR AllocationLength[2];
        UCHAR Control : 6;
        UCHAR Format : 2;
    } READ_TOC;

    struct _READ_DISK_INFORMATION {
        UCHAR OperationCode;    // 0x51 - SCSIOP_READ_DISC_INFORMATION
        UCHAR Reserved1 : 5;
        UCHAR Lun : 3;
        UCHAR Reserved2[5];
        UCHAR AllocationLength[2];
        UCHAR Control;
    } READ_DISK_INFORMATION, READ_DISC_INFORMATION;

    struct _READ_TRACK_INFORMATION {
        UCHAR OperationCode;    // 0x52 - SCSIOP_READ_TRACK_INFORMATION
        UCHAR Track : 2;
        UCHAR Reserved4 : 3;
        UCHAR Lun : 3;
        UCHAR BlockAddress[4];  // or Track Number
        UCHAR Reserved3;
        UCHAR AllocationLength[2];
        UCHAR Control;
    } READ_TRACK_INFORMATION;

    struct _RESERVE_TRACK_RZONE {
        UCHAR OperationCode;    // 0x53 - SCSIOP_RESERVE_TRACK_RZONE
        UCHAR Reserved1[4];
        UCHAR ReservationSize[4];
        UCHAR Control;
    } RESERVE_TRACK_RZONE;

    struct _SEND_OPC_INFORMATION {
        UCHAR OperationCode;    // 0x54 - SCSIOP_SEND_OPC_INFORMATION
        UCHAR DoOpc    : 1;     // perform OPC
        UCHAR Reserved : 7;
        UCHAR Reserved1[5];
        UCHAR ParameterListLength[2];
        UCHAR Reserved2;
    } SEND_OPC_INFORMATION;

    struct _REPAIR_TRACK {
        UCHAR OperationCode;    // 0x58 - SCSIOP_REPAIR_TRACK
        UCHAR Immediate : 1;
        UCHAR Reserved1 : 7;
        UCHAR Reserved2[2];
        UCHAR TrackNumber[2];
        UCHAR Reserved3[3];
        UCHAR Control;
    } REPAIR_TRACK;

    struct _CLOSE_TRACK {
        UCHAR OperationCode;    // 0x5B - SCSIOP_CLOSE_TRACK_SESSION
        UCHAR Immediate : 1;
        UCHAR Reserved1 : 7;
        UCHAR Track     : 1;
        UCHAR Session   : 1;
        UCHAR Reserved2 : 6;
        UCHAR Reserved3;
        UCHAR TrackNumber[2];
        UCHAR Reserved4[3];
        UCHAR Control;
    } CLOSE_TRACK;

    struct _READ_BUFFER_CAPACITY {
        UCHAR OperationCode;    // 0x5C - SCSIOP_READ_BUFFER_CAPACITY
        UCHAR BlockInfo : 1;
        UCHAR Reserved1 : 7;
        UCHAR Reserved2[5];
        UCHAR AllocationLength[2];
        UCHAR Control;
    } READ_BUFFER_CAPACITY;

    struct _SEND_CUE_SHEET {
        UCHAR OperationCode;    // 0x5D - SCSIOP_SEND_CUE_SHEET
        UCHAR Reserved[5];
        UCHAR CueSheetSize[3];
        UCHAR Control;
    } SEND_CUE_SHEET;

    struct _READ_HEADER {
        UCHAR OperationCode;    // 0x44 - SCSIOP_READ_HEADER
        UCHAR Reserved1 : 1;
        UCHAR Msf : 1;
        UCHAR Reserved2 : 3;
        UCHAR Lun : 3;
        UCHAR LogicalBlockAddress[4];
        UCHAR Reserved3;
        UCHAR AllocationLength[2];
        UCHAR Control;
    } READ_HEADER;

    struct _PLAY_AUDIO {
        UCHAR OperationCode;    // 0x45 - SCSIOP_PLAY_AUDIO
        UCHAR Reserved1 : 5;
        UCHAR LogicalUnitNumber : 3;
        UCHAR StartingBlockAddress[4];
        UCHAR Reserved2;
        UCHAR PlayLength[2];
        UCHAR Control;
    } PLAY_AUDIO;

    struct _PLAY_AUDIO_MSF {
        UCHAR OperationCode;    // 0x47 - SCSIOP_PLAY_AUDIO_MSF
        UCHAR Reserved1 : 5;
        UCHAR LogicalUnitNumber : 3;
        UCHAR Reserved2;
        UCHAR StartingM;
        UCHAR StartingS;
        UCHAR StartingF;
        UCHAR EndingM;
        UCHAR EndingS;
        UCHAR EndingF;
        UCHAR Control;
    } PLAY_AUDIO_MSF;

    struct _BLANK_MEDIA {
        UCHAR OperationCode;    // 0xA1 - SCSIOP_BLANK
        UCHAR BlankType : 3;
        UCHAR Reserved1 : 1;
        UCHAR Immediate : 1;
        UCHAR Reserved2 : 3;
        UCHAR AddressOrTrack[4];
        UCHAR Reserved3[5];
        UCHAR Control;
    } BLANK_MEDIA;

    struct _PLAY_CD {
        UCHAR OperationCode;    // 0xBC - SCSIOP_PLAY_CD
        UCHAR Reserved1 : 1;
        UCHAR CMSF : 1;         // LBA = 0, MSF = 1
        UCHAR ExpectedSectorType : 3;
        UCHAR Lun : 3;

        union {
            struct _LBA {
                UCHAR StartingBlockAddress[4];
                UCHAR PlayLength[4];
            } LBA;

            struct _MSF {
                UCHAR Reserved1;
                UCHAR StartingM;
                UCHAR StartingS;
                UCHAR StartingF;
                UCHAR EndingM;
                UCHAR EndingS;
                UCHAR EndingF;
                UCHAR Reserved2;
            } MSF;
        };

        UCHAR Audio : 1;
        UCHAR Composite : 1;
        UCHAR Port1 : 1;
        UCHAR Port2 : 1;
        UCHAR Reserved2 : 3;
        UCHAR Speed : 1;
        UCHAR Control;
    } PLAY_CD;

    struct _SCAN_CD {
        UCHAR OperationCode;    // 0xBA - SCSIOP_SCAN_CD
        UCHAR RelativeAddress : 1;
        UCHAR Reserved1 : 3;
        UCHAR Direct : 1;
        UCHAR Lun : 3;
        UCHAR StartingAddress[4];
        UCHAR Reserved2[3];
        UCHAR Reserved3 : 6;
        UCHAR Type : 2;
        UCHAR Reserved4;
        UCHAR Control;
    } SCAN_CD;

    struct _STOP_PLAY_SCAN {
        UCHAR OperationCode;    // 0x4E - SCSIOP_STOP_PLAY_SCAN
        UCHAR Reserved1 : 5;
        UCHAR Lun : 3;
        UCHAR Reserved2[7];
        UCHAR Control;
    } STOP_PLAY_SCAN;


    //
    // Read SubChannel Data
    //

    struct _SUBCHANNEL {
        UCHAR OperationCode;    // 0x42 - SCSIOP_READ_SUB_CHANNEL
        UCHAR Reserved0 : 1;
        UCHAR Msf : 1;
        UCHAR Reserved1 : 3;
        UCHAR LogicalUnitNumber : 3;
        UCHAR Reserved2 : 6;
        UCHAR SubQ : 1;
        UCHAR Reserved3 : 1;
        UCHAR Format;
        UCHAR Reserved4[2];
        UCHAR TrackNumber;
        UCHAR AllocationLength[2];
        UCHAR Control;
    } SUBCHANNEL;

    //
    // Read CD. Used by Atapi for raw sector reads.
    //

    struct _READ_CD {
        UCHAR OperationCode;    // 0xBE - SCSIOP_READ_CD
        UCHAR RelativeAddress : 1;
        UCHAR Reserved0 : 1;
        UCHAR ExpectedSectorType : 3;
        UCHAR Lun : 3;
        UCHAR StartingLBA[4];
        UCHAR TransferBlocks[3];
        UCHAR Reserved2 : 1;
        UCHAR ErrorFlags : 2;
        UCHAR IncludeEDC : 1;
        UCHAR IncludeUserData : 1;
        UCHAR HeaderCode : 2;
        UCHAR IncludeSyncData : 1;
        UCHAR SubChannelSelection : 3;
        UCHAR Reserved3 : 5;
        UCHAR Control;
    } READ_CD;

    struct _READ_CD_MSF {
        UCHAR OperationCode;    // 0xB9 - SCSIOP_READ_CD_MSF
        UCHAR RelativeAddress : 1;
        UCHAR Reserved1 : 1;
        UCHAR ExpectedSectorType : 3;
        UCHAR Lun : 3;
        UCHAR Reserved2;
        UCHAR StartingM;
        UCHAR StartingS;
        UCHAR StartingF;
        UCHAR EndingM;
        UCHAR EndingS;
        UCHAR EndingF;
        UCHAR Reserved4 : 1;
        UCHAR ErrorFlags : 2;
        UCHAR IncludeEDC : 1;
        UCHAR IncludeUserData : 1;
        UCHAR HeaderCode : 2;
        UCHAR IncludeSyncData : 1;
        UCHAR SubChannelSelection : 3;
        UCHAR Reserved5 : 5;
        UCHAR Control;
    } READ_CD_MSF;

    //
    // Plextor Read CD-DA
    //

    struct _PLXTR_READ_CDDA {
        UCHAR OperationCode;    // Unknown -- vendor-unique?
        UCHAR Reserved0 : 5;
        UCHAR LogicalUnitNumber :3;
        UCHAR LogicalBlockByte0;
        UCHAR LogicalBlockByte1;
        UCHAR LogicalBlockByte2;
        UCHAR LogicalBlockByte3;
        UCHAR TransferBlockByte0;
        UCHAR TransferBlockByte1;
        UCHAR TransferBlockByte2;
        UCHAR TransferBlockByte3;
        UCHAR SubCode;
        UCHAR Control;
    } PLXTR_READ_CDDA;

    //
    // NEC Read CD-DA
    //

    struct _NEC_READ_CDDA {
        UCHAR OperationCode;    // Unknown -- vendor-unique?
        UCHAR Reserved0;
        UCHAR LogicalBlockByte0;
        UCHAR LogicalBlockByte1;
        UCHAR LogicalBlockByte2;
        UCHAR LogicalBlockByte3;
        UCHAR Reserved1;
        UCHAR TransferBlockByte0;
        UCHAR TransferBlockByte1;
        UCHAR Control;
    } NEC_READ_CDDA;

    //
    // Mode sense
    //

    struct _MODE_SENSE {
        UCHAR OperationCode;    // 0x1A - SCSIOP_MODE_SENSE
        UCHAR Reserved1 : 3;
        UCHAR Dbd : 1;
        UCHAR Reserved2 : 1;
        UCHAR LogicalUnitNumber : 3;
        UCHAR PageCode : 6;
        UCHAR Pc : 2;
        UCHAR Reserved3;
        UCHAR AllocationLength;
        UCHAR Control;
    } MODE_SENSE;

    struct _MODE_SENSE10 {
        UCHAR OperationCode;    // 0x5A - SCSIOP_MODE_SENSE10
        UCHAR Reserved1 : 3;
        UCHAR Dbd : 1;
        UCHAR Reserved2 : 1;
        UCHAR LogicalUnitNumber : 3;
        UCHAR PageCode : 6;
        UCHAR Pc : 2;
        UCHAR Reserved3[4];
        UCHAR AllocationLength[2];
        UCHAR Control;
    } MODE_SENSE10;

    //
    // Mode select
    //

    struct _MODE_SELECT {
        UCHAR OperationCode;    // 0x15 - SCSIOP_MODE_SELECT
        UCHAR SPBit : 1;
        UCHAR Reserved1 : 3;
        UCHAR PFBit : 1;
        UCHAR LogicalUnitNumber : 3;
        UCHAR Reserved2[2];
        UCHAR ParameterListLength;
        UCHAR Control;
    } MODE_SELECT;

    struct _MODE_SELECT10 {
        UCHAR OperationCode;    // 0x55 - SCSIOP_MODE_SELECT10
        UCHAR SPBit : 1;
        UCHAR Reserved1 : 3;
        UCHAR PFBit : 1;
        UCHAR LogicalUnitNumber : 3;
        UCHAR Reserved2[5];
        UCHAR ParameterListLength[2];
        UCHAR Control;
    } MODE_SELECT10;

    struct _LOCATE {
        UCHAR OperationCode;    // 0x2B - SCSIOP_LOCATE
        UCHAR Immediate : 1;
        UCHAR CPBit : 1;
        UCHAR BTBit : 1;
        UCHAR Reserved1 : 2;
        UCHAR LogicalUnitNumber : 3;
        UCHAR Reserved3;
        UCHAR LogicalBlockAddress[4];
        UCHAR Reserved4;
        UCHAR Partition;
        UCHAR Control;
    } LOCATE;

    struct _LOGSENSE {
        UCHAR OperationCode;    // 0x4D - SCSIOP_LOG_SENSE
        UCHAR SPBit : 1;
        UCHAR PPCBit : 1;
        UCHAR Reserved1 : 3;
        UCHAR LogicalUnitNumber : 3;
        UCHAR PageCode : 6;
        UCHAR PCBit : 2;
        UCHAR Reserved2;
        UCHAR Reserved3;
        UCHAR ParameterPointer[2];
        UCHAR AllocationLength[2];
        UCHAR Control;
    } LOGSENSE;

    struct _LOGSELECT {
        UCHAR OperationCode;    // 0x4C - SCSIOP_LOG_SELECT
        UCHAR SPBit : 1;
        UCHAR PCRBit : 1;
        UCHAR Reserved1 : 3;
        UCHAR LogicalUnitNumber : 3;
        UCHAR Reserved : 6;
        UCHAR PCBit : 2;
        UCHAR Reserved2[4];
        UCHAR ParameterListLength[2];
        UCHAR Control;
    } LOGSELECT;

    struct _PRINT {
        UCHAR OperationCode;    // 0x0A - SCSIOP_PRINT
        UCHAR Reserved : 5;
        UCHAR LogicalUnitNumber : 3;
        UCHAR TransferLength[3];
        UCHAR Control;
    } PRINT;

    struct _SEEK {
        UCHAR OperationCode;    // 0x2B - SCSIOP_SEEK
        UCHAR Reserved1 : 5;
        UCHAR LogicalUnitNumber : 3;
        UCHAR LogicalBlockAddress[4];
        UCHAR Reserved2[3];
        UCHAR Control;
    } SEEK;

    struct _ERASE {
        UCHAR OperationCode;    // 0x19 - SCSIOP_ERASE
        UCHAR Long : 1;
        UCHAR Immediate : 1;
        UCHAR Reserved1 : 3;
        UCHAR LogicalUnitNumber : 3;
        UCHAR Reserved2[3];
        UCHAR Control;
    } ERASE;

    struct _START_STOP {
        UCHAR OperationCode;    // 0x1B - SCSIOP_START_STOP_UNIT
        UCHAR Immediate: 1;
        UCHAR Reserved1 : 4;
        UCHAR LogicalUnitNumber : 3;
        UCHAR Reserved2[2];
        UCHAR Start : 1;
        UCHAR LoadEject : 1;
        UCHAR Reserved3 : 6;
        UCHAR Control;
    } START_STOP;

    struct _MEDIA_REMOVAL {
        UCHAR OperationCode;    // 0x1E - SCSIOP_MEDIUM_REMOVAL
        UCHAR Reserved1 : 5;
        UCHAR LogicalUnitNumber : 3;
        UCHAR Reserved2[2];

        UCHAR Prevent : 1;
        UCHAR Persistant : 1;
        UCHAR Reserved3 : 6;

        UCHAR Control;
    } MEDIA_REMOVAL;

    //
    // Tape CDBs
    //

    struct _SEEK_BLOCK {
        UCHAR OperationCode;    // 0x0C - SCSIOP_SEEK_BLOCK
        UCHAR Immediate : 1;
        UCHAR Reserved1 : 7;
        UCHAR BlockAddress[3];
        UCHAR Link : 1;
        UCHAR Flag : 1;
        UCHAR Reserved2 : 4;
        UCHAR VendorUnique : 2;
    } SEEK_BLOCK;

    struct _REQUEST_BLOCK_ADDRESS {
        UCHAR OperationCode;    // 0x02 - SCSIOP_REQUEST_BLOCK_ADDR
        UCHAR Reserved1[3];
        UCHAR AllocationLength;
        UCHAR Link : 1;
        UCHAR Flag : 1;
        UCHAR Reserved2 : 4;
        UCHAR VendorUnique : 2;
    } REQUEST_BLOCK_ADDRESS;

    struct _PARTITION {
        UCHAR OperationCode;    // 0x0D - SCSIOP_PARTITION
        UCHAR Immediate : 1;
        UCHAR Sel: 1;
        UCHAR PartitionSelect : 6;
        UCHAR Reserved1[3];
        UCHAR Control;
    } PARTITION;

    struct _WRITE_TAPE_MARKS {
        UCHAR OperationCode;    // Unknown -- vendor-unique?
        UCHAR Immediate : 1;
        UCHAR WriteSetMarks: 1;
        UCHAR Reserved : 3;
        UCHAR LogicalUnitNumber : 3;
        UCHAR TransferLength[3];
        UCHAR Control;
    } WRITE_TAPE_MARKS;

    struct _SPACE_TAPE_MARKS {
        UCHAR OperationCode;    // Unknown -- vendor-unique?
        UCHAR Code : 3;
        UCHAR Reserved : 2;
        UCHAR LogicalUnitNumber : 3;
        UCHAR NumMarksMSB ;
        UCHAR NumMarks;
        UCHAR NumMarksLSB;
        union {
            UCHAR value;
            struct {
                UCHAR Link : 1;
                UCHAR Flag : 1;
                UCHAR Reserved : 4;
                UCHAR VendorUnique : 2;
            } Fields;
        } Byte6;
    } SPACE_TAPE_MARKS;

    //
    // Read tape position
    //

    struct _READ_POSITION {
        UCHAR Operation;        // 0x43 - SCSIOP_READ_POSITION
        UCHAR BlockType:1;
        UCHAR Reserved1:4;
        UCHAR Lun:3;
        UCHAR Reserved2[7];
        UCHAR Control;
    } READ_POSITION;

    //
    // ReadWrite for Tape
    //

    struct _CDB6READWRITETAPE {
        UCHAR OperationCode;    // Unknown -- vendor-unique?
        UCHAR VendorSpecific : 5;
        UCHAR Reserved : 3;
        UCHAR TransferLenMSB;
        UCHAR TransferLen;
        UCHAR TransferLenLSB;
        UCHAR Link : 1;
        UCHAR Flag : 1;
        UCHAR Reserved1 : 4;
        UCHAR VendorUnique : 2;
    } CDB6READWRITETAPE;

    //
    // Medium changer CDB's
    //

    struct _INIT_ELEMENT_STATUS {
        UCHAR OperationCode;    // 0x07 - SCSIOP_INIT_ELEMENT_STATUS
        UCHAR Reserved1 : 5;
        UCHAR LogicalUnitNubmer : 3;
        UCHAR Reserved2[3];
        UCHAR Reserved3 : 7;
        UCHAR NoBarCode : 1;
    } INIT_ELEMENT_STATUS;

    struct _INITIALIZE_ELEMENT_RANGE {
        UCHAR OperationCode;    // 0xE7 - SCSIOP_INIT_ELEMENT_RANGE
        UCHAR Range : 1;
        UCHAR Reserved1 : 4;
        UCHAR LogicalUnitNubmer : 3;
        UCHAR FirstElementAddress[2];
        UCHAR Reserved2[2];
        UCHAR NumberOfElements[2];
        UCHAR Reserved3;
        UCHAR Reserved4 : 7;
        UCHAR NoBarCode : 1;
    } INITIALIZE_ELEMENT_RANGE;

    struct _POSITION_TO_ELEMENT {
        UCHAR OperationCode;    // 0x2B - SCSIOP_POSITION_TO_ELEMENT
        UCHAR Reserved1 : 5;
        UCHAR LogicalUnitNumber : 3;
        UCHAR TransportElementAddress[2];
        UCHAR DestinationElementAddress[2];
        UCHAR Reserved2[2];
        UCHAR Flip : 1;
        UCHAR Reserved3 : 7;
        UCHAR Control;
    } POSITION_TO_ELEMENT;

    struct _MOVE_MEDIUM {
        UCHAR OperationCode;    // 0xA5 - SCSIOP_MOVE_MEDIUM
        UCHAR Reserved1 : 5;
        UCHAR LogicalUnitNumber : 3;
        UCHAR TransportElementAddress[2];
        UCHAR SourceElementAddress[2];
        UCHAR DestinationElementAddress[2];
        UCHAR Reserved2[2];
        UCHAR Flip : 1;
        UCHAR Reserved3 : 7;
        UCHAR Control;
    } MOVE_MEDIUM;

    struct _EXCHANGE_MEDIUM {
        UCHAR OperationCode;    // 0xA6 - SCSIOP_EXCHANGE_MEDIUM
        UCHAR Reserved1 : 5;
        UCHAR LogicalUnitNumber : 3;
        UCHAR TransportElementAddress[2];
        UCHAR SourceElementAddress[2];
        UCHAR Destination1ElementAddress[2];
        UCHAR Destination2ElementAddress[2];
        UCHAR Flip1 : 1;
        UCHAR Flip2 : 1;
        UCHAR Reserved3 : 6;
        UCHAR Control;
    } EXCHANGE_MEDIUM;

    struct _READ_ELEMENT_STATUS {
        UCHAR OperationCode;    // 0xB8 - SCSIOP_READ_ELEMENT_STATUS
        UCHAR ElementType : 4;
        UCHAR VolTag : 1;
        UCHAR LogicalUnitNumber : 3;
        UCHAR StartingElementAddress[2];
        UCHAR NumberOfElements[2];
        UCHAR Reserved1;
        UCHAR AllocationLength[3];
        UCHAR Reserved2;
        UCHAR Control;
    } READ_ELEMENT_STATUS;

    struct _SEND_VOLUME_TAG {
        UCHAR OperationCode;    // 0xB6 - SCSIOP_SEND_VOLUME_TAG
        UCHAR ElementType : 4;
        UCHAR Reserved1 : 1;
        UCHAR LogicalUnitNumber : 3;
        UCHAR StartingElementAddress[2];
        UCHAR Reserved2;
        UCHAR ActionCode : 5;
        UCHAR Reserved3 : 3;
        UCHAR Reserved4[2];
        UCHAR ParameterListLength[2];
        UCHAR Reserved5;
        UCHAR Control;
    } SEND_VOLUME_TAG;

    struct _REQUEST_VOLUME_ELEMENT_ADDRESS {
        UCHAR OperationCode;    // Unknown -- vendor-unique?
        UCHAR ElementType : 4;
        UCHAR VolTag : 1;
        UCHAR LogicalUnitNumber : 3;
        UCHAR StartingElementAddress[2];
        UCHAR NumberElements[2];
        UCHAR Reserved1;
        UCHAR AllocationLength[3];
        UCHAR Reserved2;
        UCHAR Control;
    } REQUEST_VOLUME_ELEMENT_ADDRESS;

    //
    // Atapi 2.5 Changer 12-byte CDBs
    //

    struct _LOAD_UNLOAD {
        UCHAR OperationCode;    // 0xA6 - SCSIOP_LOAD_UNLOAD_SLOT
        UCHAR Immediate : 1;
        UCHAR Reserved1 : 4;
        UCHAR Lun : 3;
        UCHAR Reserved2[2];
        UCHAR Start : 1;
        UCHAR LoadEject : 1;
        UCHAR Reserved3: 6;
        UCHAR Reserved4[3];
        UCHAR Slot;
        UCHAR Reserved5[3];
    } LOAD_UNLOAD;

    struct _MECH_STATUS {
        UCHAR OperationCode;    // 0xBD - SCSIOP_MECHANISM_STATUS
        UCHAR Reserved : 5;
        UCHAR Lun : 3;
        UCHAR Reserved1[6];
        UCHAR AllocationLength[2];
        UCHAR Reserved2[1];
        UCHAR Control;
    } MECH_STATUS;

    //
    // C/DVD 0.9 CDBs
    //

    struct _SYNCHRONIZE_CACHE10 {

        UCHAR OperationCode;    // 0x35 - SCSIOP_SYNCHRONIZE_CACHE

        UCHAR RelAddr : 1;
        UCHAR Immediate : 1;
        UCHAR Reserved : 3;
        UCHAR Lun : 3;

        UCHAR LogicalBlockAddress[4];   // Unused - set to zero
        UCHAR Reserved2;
        UCHAR BlockCount[2];            // Unused - set to zero
        UCHAR Control;
    } SYNCHRONIZE_CACHE10;

    struct _GET_EVENT_STATUS_NOTIFICATION {
        UCHAR OperationCode;    // 0x4A - SCSIOP_GET_EVENT_STATUS_NOTIFICATION

        UCHAR Immediate : 1;
        UCHAR Reserved : 4;
        UCHAR Lun : 3;

        UCHAR Reserved2[2];
        UCHAR NotificationClassRequest;
        UCHAR Reserved3[2];
        UCHAR EventListLength[2];

        UCHAR Control;
    } GET_EVENT_STATUS_NOTIFICATION;

    struct _GET_PERFORMANCE {
        UCHAR OperationCode;    // 0xAC - SCSIOP_GET_PERFORMANCE
        UCHAR Except    : 2;
        UCHAR Write     : 1;
        UCHAR Tolerance : 2;
        UCHAR Reserved0 : 3;
        UCHAR StartingLBA[4];
        UCHAR Reserved1[2];
        UCHAR MaximumNumberOfDescriptors[2];
        UCHAR Type;
        UCHAR Control;
    } GET_PERFORMANCE;

    struct _READ_DVD_STRUCTURE {
        UCHAR OperationCode;    // 0xAD - SCSIOP_READ_DVD_STRUCTURE
        UCHAR Reserved1 : 5;
        UCHAR Lun : 3;
        UCHAR RMDBlockNumber[4];
        UCHAR LayerNumber;
        UCHAR Format;
        UCHAR AllocationLength[2];
        UCHAR Reserved3 : 6;
        UCHAR AGID : 2;
        UCHAR Control;
    } READ_DVD_STRUCTURE;

    struct _SET_STREAMING {
        UCHAR OperationCode;    // 0xB6 - SCSIOP_SET_STREAMING
        UCHAR Reserved[8];
        UCHAR ParameterListLength[2];
        UCHAR Control;
    } SET_STREAMING;

    struct _SEND_DVD_STRUCTURE {
        UCHAR OperationCode;    // 0xBF - SCSIOP_SEND_DVD_STRUCTURE
        UCHAR Reserved1 : 5;
        UCHAR Lun : 3;
        UCHAR Reserved2[5];
        UCHAR Format;
        UCHAR ParameterListLength[2];
        UCHAR Reserved3;
        UCHAR Control;
    } SEND_DVD_STRUCTURE;

    struct _SEND_KEY {
        UCHAR OperationCode;    // 0xA3 - SCSIOP_SEND_KEY
        UCHAR Reserved1 : 5;
        UCHAR Lun : 3;
        UCHAR Reserved2[6];
        UCHAR ParameterListLength[2];
        UCHAR KeyFormat : 6;
        UCHAR AGID : 2;
        UCHAR Control;
    } SEND_KEY;

    struct _REPORT_KEY {
        UCHAR OperationCode;    // 0xA4 - SCSIOP_REPORT_KEY
        UCHAR Reserved1 : 5;
        UCHAR Lun : 3;
        UCHAR LogicalBlockAddress[4];   // for title key
        UCHAR Reserved2[2];
        UCHAR AllocationLength[2];
        UCHAR KeyFormat : 6;
        UCHAR AGID : 2;
        UCHAR Control;
    } REPORT_KEY;

    struct _SET_READ_AHEAD {
        UCHAR OperationCode;    // 0xA7 - SCSIOP_SET_READ_AHEAD
        UCHAR Reserved1 : 5;
        UCHAR Lun : 3;
        UCHAR TriggerLBA[4];
        UCHAR ReadAheadLBA[4];
        UCHAR Reserved2;
        UCHAR Control;
    } SET_READ_AHEAD;

    struct _READ_FORMATTED_CAPACITIES {
        UCHAR OperationCode;    // 0x23 - SCSIOP_READ_FORMATTED_CAPACITY
        UCHAR Reserved1 : 5;
        UCHAR Lun : 3;
        UCHAR Reserved2[5];
        UCHAR AllocationLength[2];
        UCHAR Control;
    } READ_FORMATTED_CAPACITIES;

    //
    // SCSI-3
    //

    struct _REPORT_LUNS {
        UCHAR OperationCode;    // 0xA0 - SCSIOP_REPORT_LUNS
        UCHAR Reserved1[5];
        UCHAR AllocationLength[4];
        UCHAR Reserved2[1];
        UCHAR Control;
    } REPORT_LUNS;

    struct _PERSISTENT_RESERVE_IN {
        UCHAR OperationCode;    // 0x5E - SCSIOP_PERSISTENT_RESERVE_IN
        UCHAR ServiceAction : 5;
        UCHAR Reserved1 : 3;
        UCHAR Reserved2[5];
        UCHAR AllocationLength[2];
        UCHAR Control;
    } PERSISTENT_RESERVE_IN;

    struct _PERSISTENT_RESERVE_OUT {
        UCHAR OperationCode;    // 0x5F - SCSIOP_PERSISTENT_RESERVE_OUT
        UCHAR ServiceAction : 5;
        UCHAR Reserved1 : 3;
        UCHAR Type : 4;
        UCHAR Scope : 4;
        UCHAR Reserved2[4];
        UCHAR ParameterListLength[2]; // 0x18
        UCHAR Control;
    } PERSISTENT_RESERVE_OUT;

    //
    // MMC / SFF-8090 commands
    //

    struct _GET_CONFIGURATION {
        UCHAR OperationCode;       // 0x46 - SCSIOP_GET_CONFIGURATION
        UCHAR RequestType : 2;     // SCSI_GET_CONFIGURATION_REQUEST_TYPE_*
        UCHAR Reserved1   : 6;     // includes obsolete LUN field
        UCHAR StartingFeature[2];
        UCHAR Reserved2[3];
        UCHAR AllocationLength[2];
        UCHAR Control;
    } GET_CONFIGURATION;

    struct _SET_CD_SPEED {
        UCHAR OperationCode;       // 0xB8 - SCSIOP_SET_CD_SPEED
        union {
            UCHAR Reserved1;
            struct {
                UCHAR RotationControl : 2;
                UCHAR Reserved3       : 6;
            };
        };
        UCHAR ReadSpeed[2];        // 1x == (75 * 2352)
        UCHAR WriteSpeed[2];       // 1x == (75 * 2352)
        UCHAR Reserved2[5];
        UCHAR Control;
    } SET_CD_SPEED;

    struct _READ12 {
        UCHAR OperationCode;      // 0xA8 - SCSIOP_READ12
        UCHAR RelativeAddress   : 1;
        UCHAR Reserved1         : 2;
        UCHAR ForceUnitAccess   : 1;
        UCHAR DisablePageOut    : 1;
        UCHAR LogicalUnitNumber : 3;
        UCHAR LogicalBlock[4];
        UCHAR TransferLength[4];
        UCHAR Reserved2 : 7;
        UCHAR Streaming : 1;
        UCHAR Control;
    } READ12;

    struct _WRITE12 {
        UCHAR OperationCode;      // 0xAA - SCSIOP_WRITE12
        UCHAR RelativeAddress   : 1;
        UCHAR Reserved1         : 1;
        UCHAR EBP               : 1;
        UCHAR ForceUnitAccess   : 1;
        UCHAR DisablePageOut    : 1;
        UCHAR LogicalUnitNumber : 3;
        UCHAR LogicalBlock[4];
        UCHAR TransferLength[4];
        UCHAR Reserved2 : 7;
        UCHAR Streaming : 1;
        UCHAR Control;
    } WRITE12;

    //
    // 16-byte CDBs
    //

    struct _READ16 {
        UCHAR OperationCode;      // 0x88 - SCSIOP_READ16
        UCHAR Reserved1         : 3;
        UCHAR ForceUnitAccess   : 1;
        UCHAR DisablePageOut    : 1;
        UCHAR ReadProtect       : 3;
        UCHAR LogicalBlock[8];
        UCHAR TransferLength[4];
        UCHAR Reserved2         : 7;
        UCHAR Streaming         : 1;
        UCHAR Control;
    } READ16;

    struct _WRITE16 {
        UCHAR OperationCode;      // 0x8A - SCSIOP_WRITE16
        UCHAR Reserved1         : 3;
        UCHAR ForceUnitAccess   : 1;
        UCHAR DisablePageOut    : 1;
        UCHAR WriteProtect      : 3;
        UCHAR LogicalBlock[8];
        UCHAR TransferLength[4];
        UCHAR Reserved2         : 7;
        UCHAR Streaming         : 1;
        UCHAR Control;
    } WRITE16;

    struct _VERIFY16 {
        UCHAR OperationCode;      // 0x8F - SCSIOP_VERIFY16
        UCHAR Reserved1         : 1;
        UCHAR ByteCheck         : 1;
        UCHAR BlockVerify       : 1;
        UCHAR Reserved2         : 1;
        UCHAR DisablePageOut    : 1;
        UCHAR VerifyProtect     : 3;
        UCHAR LogicalBlock[8];
        UCHAR VerificationLength[4];
        UCHAR Reserved3         : 7;
        UCHAR Streaming         : 1;
        UCHAR Control;
    } VERIFY16;

    struct _SYNCHRONIZE_CACHE16 {
        UCHAR OperationCode;      // 0x91 - SCSIOP_SYNCHRONIZE_CACHE16
        UCHAR Reserved1         : 1;
        UCHAR Immediate         : 1;
        UCHAR Reserved2         : 6;
        UCHAR LogicalBlock[8];
        UCHAR BlockCount[4];
        UCHAR Reserved3;
        UCHAR Control;
    } SYNCHRONIZE_CACHE16;

    struct _READ_CAPACITY16 {
        UCHAR OperationCode;      // 0x9E - SCSIOP_READ_CAPACITY16
        UCHAR ServiceAction     : 5;
        UCHAR Reserved1         : 3;
        UCHAR LogicalBlock[8];
        UCHAR BlockCount[4];
        UCHAR PMI               : 1;
        UCHAR Reserved2         : 7;
        UCHAR Control;
    } READ_CAPACITY16;

    ULONG AsUlong[4];
    UCHAR AsByte[16];

} CDB, *PCDB;
#pragma pack(pop, cdb)

////////////////////////////////////////////////////////////////////////////////
//
// GET_EVENT_STATUS_NOTIFICATION
//


#define NOTIFICATION_OPERATIONAL_CHANGE_CLASS_MASK  0x02
#define NOTIFICATION_POWER_MANAGEMENT_CLASS_MASK    0x04
#define NOTIFICATION_EXTERNAL_REQUEST_CLASS_MASK    0x08
#define NOTIFICATION_MEDIA_STATUS_CLASS_MASK        0x10
#define NOTIFICATION_MULTI_HOST_CLASS_MASK          0x20
#define NOTIFICATION_DEVICE_BUSY_CLASS_MASK         0x40


#define NOTIFICATION_NO_CLASS_EVENTS                  0x0
#define NOTIFICATION_OPERATIONAL_CHANGE_CLASS_EVENTS  0x1
#define NOTIFICATION_POWER_MANAGEMENT_CLASS_EVENTS    0x2
#define NOTIFICATION_EXTERNAL_REQUEST_CLASS_EVENTS    0x3
#define NOTIFICATION_MEDIA_STATUS_CLASS_EVENTS        0x4
#define NOTIFICATION_MULTI_HOST_CLASS_EVENTS          0x5
#define NOTIFICATION_DEVICE_BUSY_CLASS_EVENTS         0x6

#pragma pack(push, not_header, 1)
typedef struct _NOTIFICATION_EVENT_STATUS_HEADER {
    UCHAR EventDataLength[2];

    UCHAR NotificationClass : 3;
    UCHAR Reserved : 4;
    UCHAR NEA : 1;

    UCHAR SupportedEventClasses;
#if !defined(__midl)
    UCHAR ClassEventData[0];
#endif
} NOTIFICATION_EVENT_STATUS_HEADER, *PNOTIFICATION_EVENT_STATUS_HEADER;
#pragma pack(pop, not_header)

#define NOTIFICATION_OPERATIONAL_EVENT_NO_CHANGE         0x0
#define NOTIFICATION_OPERATIONAL_EVENT_CHANGE_REQUESTED  0x1
#define NOTIFICATION_OPERATIONAL_EVENT_CHANGE_OCCURRED   0x2

#define NOTIFICATION_OPERATIONAL_STATUS_AVAILABLE        0x0
#define NOTIFICATION_OPERATIONAL_STATUS_TEMPORARY_BUSY   0x1
#define NOTIFICATION_OPERATIONAL_STATUS_EXTENDED_BUSY    0x2

#define NOTIFICATION_OPERATIONAL_OPCODE_NONE             0x0
#define NOTIFICATION_OPERATIONAL_OPCODE_FEATURE_CHANGE   0x1
#define NOTIFICATION_OPERATIONAL_OPCODE_FEATURE_ADDED    0x2
#define NOTIFICATION_OPERATIONAL_OPCODE_UNIT_RESET       0x3
#define NOTIFICATION_OPERATIONAL_OPCODE_FIRMWARE_CHANGED 0x4
#define NOTIFICATION_OPERATIONAL_OPCODE_INQUIRY_CHANGED  0x5

//
// Class event data may be one (or none) of the following:
//

#pragma pack(push, not_op, 1)
typedef struct _NOTIFICATION_OPERATIONAL_STATUS { // event class == 0x1
    UCHAR OperationalEvent : 4;
    UCHAR Reserved1 : 4;
    UCHAR OperationalStatus : 4;
    UCHAR Reserved2 : 3;
    UCHAR PersistentPrevented : 1;
    UCHAR Operation[2];
} NOTIFICATION_OPERATIONAL_STATUS, *PNOTIFICATION_OPERATIONAL_STATUS;
#pragma pack(pop, not_op)


#define NOTIFICATION_POWER_EVENT_NO_CHANGE          0x0
#define NOTIFICATION_POWER_EVENT_CHANGE_SUCCEEDED   0x1
#define NOTIFICATION_POWER_EVENT_CHANGE_FAILED      0x2

#define NOTIFICATION_POWER_STATUS_ACTIVE            0x1
#define NOTIFICATION_POWER_STATUS_IDLE              0x2
#define NOTIFICATION_POWER_STATUS_STANDBY           0x3
#define NOTIFICATION_POWER_STATUS_SLEEP             0x4

#pragma pack(push, not_power, 1)
typedef struct _NOTIFICATION_POWER_STATUS { // event class == 0x2
    UCHAR PowerEvent : 4;
    UCHAR Reserved : 4;
    UCHAR PowerStatus;
    UCHAR Reserved2[2];
} NOTIFICATION_POWER_STATUS, *PNOTIFICATION_POWER_STATUS;
#pragma pack(pop, not_power)

#define NOTIFICATION_MEDIA_EVENT_NO_EVENT           0x0
#define NOTIFICATION_EXTERNAL_EVENT_NO_CHANGE       0x0
#define NOTIFICATION_EXTERNAL_EVENT_BUTTON_DOWN     0x1
#define NOTIFICATION_EXTERNAL_EVENT_BUTTON_UP       0x2
#define NOTIFICATION_EXTERNAL_EVENT_EXTERNAL        0x3 // respond with GET_CONFIGURATION?

#define NOTIFICATION_EXTERNAL_STATUS_READY          0x0
#define NOTIFICATION_EXTERNAL_STATUS_PREVENT        0x1

#define NOTIFICATION_EXTERNAL_REQUEST_NONE          0x0000
#define NOTIFICATION_EXTERNAL_REQUEST_QUEUE_OVERRUN 0x0001
#define NOTIFICATION_EXTERNAL_REQUEST_PLAY          0x0101
#define NOTIFICATION_EXTERNAL_REQUEST_REWIND_BACK   0x0102
#define NOTIFICATION_EXTERNAL_REQUEST_FAST_FORWARD  0x0103
#define NOTIFICATION_EXTERNAL_REQUEST_PAUSE         0x0104
#define NOTIFICATION_EXTERNAL_REQUEST_STOP          0x0106
#define NOTIFICATION_EXTERNAL_REQUEST_ASCII_LOW     0x0200
#define NOTIFICATION_EXTERNAL_REQUEST_ASCII_HIGH    0x02ff

#pragma pack(push, not_extern, 1)
typedef struct _NOTIFICATION_EXTERNAL_STATUS { // event class == 0x3
    UCHAR ExternalEvent : 4;
    UCHAR Reserved1 : 4;
    UCHAR ExternalStatus : 4;
    UCHAR Reserved2 : 3;
    UCHAR PersistentPrevented : 1;
    UCHAR Request[2];
} NOTIFICATION_EXTERNAL_STATUS, *PNOTIFICATION_EXTERNAL_STATUS;
#pragma pack(pop, not_extern)

#define NOTIFICATION_MEDIA_EVENT_NO_CHANGE          0x0
#define NOTIFICATION_MEDIA_EVENT_EJECT_REQUEST      0x1
#define NOTIFICATION_MEDIA_EVENT_NEW_MEDIA          0x2
#define NOTIFICATION_MEDIA_EVENT_MEDIA_REMOVAL      0x3
#define NOTIFICATION_MEDIA_EVENT_MEDIA_CHANGE       0x4

#pragma pack(push, not_media, 1)
typedef struct _NOTIFICATION_MEDIA_STATUS { // event class == 0x4
    UCHAR MediaEvent : 4;
    UCHAR Reserved : 4;

    union {
        UCHAR PowerStatus; // OBSOLETE -- was improperly named in NT5 headers
        UCHAR MediaStatus; // Use this for currently reserved fields
        struct {
            UCHAR DoorTrayOpen : 1;
            UCHAR MediaPresent : 1;
            UCHAR ReservedX    : 6; // do not reference this directly!
        };
    };
    UCHAR StartSlot;
    UCHAR EndSlot;
} NOTIFICATION_MEDIA_STATUS, *PNOTIFICATION_MEDIA_STATUS;
#pragma pack(pop, not_media)

#define NOTIFICATION_BUSY_EVENT_NO_EVENT               0x0
#define NOTIFICATION_MULTI_HOST_EVENT_NO_CHANGE        0x0
#define NOTIFICATION_MULTI_HOST_EVENT_CONTROL_REQUEST  0x1
#define NOTIFICATION_MULTI_HOST_EVENT_CONTROL_GRANT    0x2
#define NOTIFICATION_MULTI_HOST_EVENT_CONTROL_RELEASE  0x3

#define NOTIFICATION_MULTI_HOST_STATUS_READY           0x0
#define NOTIFICATION_MULTI_HOST_STATUS_PREVENT         0x1

#define NOTIFICATION_MULTI_HOST_PRIORITY_NO_REQUESTS   0x0
#define NOTIFICATION_MULTI_HOST_PRIORITY_LOW           0x1
#define NOTIFICATION_MULTI_HOST_PRIORITY_MEDIUM        0x2
#define NOTIFICATION_MULTI_HOST_PRIORITY_HIGH          0x3

#pragma pack(push, not_multi, 1)
typedef struct _NOTIFICATION_MULTI_HOST_STATUS { // event class == 0x5
    UCHAR MultiHostEvent : 4;
    UCHAR Reserved1 : 4;
    UCHAR MultiHostStatus : 4;
    UCHAR Reserved2 : 3;
    UCHAR PersistentPrevented : 1;
    UCHAR Priority[2];
} NOTIFICATION_MULTI_HOST_STATUS, *PNOTIFICATION_MULTI_HOST_STATUS;
#pragma pack(pop, not_multi)

#define NOTIFICATION_BUSY_EVENT_NO_EVENT            0x0
#define NOTIFICATION_BUSY_EVENT_NO_CHANGE           0x0
#define NOTIFICATION_BUSY_EVENT_BUSY                0x1

#define NOTIFICATION_BUSY_STATUS_NO_EVENT           0x0
#define NOTIFICATION_BUSY_STATUS_POWER              0x1
#define NOTIFICATION_BUSY_STATUS_IMMEDIATE          0x2
#define NOTIFICATION_BUSY_STATUS_DEFERRED           0x3

#pragma pack(push, not_busy, 1)
typedef struct _NOTIFICATION_BUSY_STATUS { // event class == 0x6
    UCHAR DeviceBusyEvent : 4;
    UCHAR Reserved : 4;

    UCHAR DeviceBusyStatus;
    UCHAR Time[2];
} NOTIFICATION_BUSY_STATUS, *PNOTIFICATION_BUSY_STATUS;
#pragma pack(pop, not_busy)

////////////////////////////////////////////////////////////////////////////////

//
// Read DVD Structure Definitions and Constants
//

#define DVD_FORMAT_LEAD_IN          0x00
#define DVD_FORMAT_COPYRIGHT        0x01
#define DVD_FORMAT_DISK_KEY         0x02
#define DVD_FORMAT_BCA              0x03
#define DVD_FORMAT_MANUFACTURING    0x04

#pragma pack(push, dvd_struct_header, 1)
typedef struct _READ_DVD_STRUCTURES_HEADER {
    UCHAR Length[2];
    UCHAR Reserved[2];

#if !defined(__midl)
    UCHAR Data[0];
#endif
} READ_DVD_STRUCTURES_HEADER, *PREAD_DVD_STRUCTURES_HEADER;
#pragma pack(pop, dvd_struct_header)

//
// DiskKey, BCA & Manufacturer information will provide byte arrays as their
// data.
//

//
// CDVD 0.9 Send & Report Key Definitions and Structures
//

#define DVD_REPORT_AGID            0x00
#define DVD_CHALLENGE_KEY          0x01
#define DVD_KEY_1                  0x02
#define DVD_KEY_2                  0x03
#define DVD_TITLE_KEY              0x04
#define DVD_REPORT_ASF             0x05
#define DVD_INVALIDATE_AGID        0x3F

#pragma pack(push, dvdstuff, 1)
typedef struct _CDVD_KEY_HEADER {
    UCHAR DataLength[2];
    UCHAR Reserved[2];
#if !defined(__midl)
    UCHAR Data[0];
#endif
} CDVD_KEY_HEADER, *PCDVD_KEY_HEADER;

typedef struct _CDVD_REPORT_AGID_DATA {
    UCHAR Reserved1[3];
    UCHAR Reserved2 : 6;
    UCHAR AGID : 2;
} CDVD_REPORT_AGID_DATA, *PCDVD_REPORT_AGID_DATA;

typedef struct _CDVD_CHALLENGE_KEY_DATA {
    UCHAR ChallengeKeyValue[10];
    UCHAR Reserved[2];
} CDVD_CHALLENGE_KEY_DATA, *PCDVD_CHALLENGE_KEY_DATA;

typedef struct _CDVD_KEY_DATA {
    UCHAR Key[5];
    UCHAR Reserved[3];
} CDVD_KEY_DATA, *PCDVD_KEY_DATA;

typedef struct _CDVD_REPORT_ASF_DATA {
    UCHAR Reserved1[3];
    UCHAR Success : 1;
    UCHAR Reserved2 : 7;
} CDVD_REPORT_ASF_DATA, *PCDVD_REPORT_ASF_DATA;

typedef struct _CDVD_TITLE_KEY_HEADER {
    UCHAR DataLength[2];
    UCHAR Reserved1[1];
    UCHAR Reserved2 : 3;
    UCHAR CGMS : 2;
    UCHAR CP_SEC : 1;
    UCHAR CPM : 1;
    UCHAR Zero : 1;
    CDVD_KEY_DATA TitleKey;
} CDVD_TITLE_KEY_HEADER, *PCDVD_TITLE_KEY_HEADER;
#pragma pack(pop, dvdstuff)

//
// Read Formatted Capacity Data - returned in Big Endian Format
//


#pragma pack(push, formatted_capacity, 1)
typedef struct _FORMATTED_CAPACITY_DESCRIPTOR {
    UCHAR NumberOfBlocks[4];
    UCHAR Maximum : 1;
    UCHAR Valid : 1;
    UCHAR BlockLength[3];
} FORMATTED_CAPACITY_DESCRIPTOR, *PFORMATTED_CAPACITY_DESCRIPTOR;

typedef struct _FORMATTED_CAPACITY_LIST {
    UCHAR Reserved[3];
    UCHAR CapacityListLength;
#if !defined(__midl)
    FORMATTED_CAPACITY_DESCRIPTOR Descriptors[0];
#endif
} FORMATTED_CAPACITY_LIST, *PFORMATTED_CAPACITY_LIST;
#pragma pack(pop, formatted_capacity)

//
//      BLANK command blanking type codes
//

#define BLANK_FULL              0x0
#define BLANK_MINIMAL           0x1
#define BLANK_TRACK             0x2
#define BLANK_UNRESERVE_TRACK   0x3
#define BLANK_TAIL              0x4
#define BLANK_UNCLOSE_SESSION   0x5
#define BLANK_SESSION           0x6

//
// PLAY_CD definitions and constants
//

#define CD_EXPECTED_SECTOR_ANY          0x0
#define CD_EXPECTED_SECTOR_CDDA         0x1
#define CD_EXPECTED_SECTOR_MODE1        0x2
#define CD_EXPECTED_SECTOR_MODE2        0x3
#define CD_EXPECTED_SECTOR_MODE2_FORM1  0x4
#define CD_EXPECTED_SECTOR_MODE2_FORM2  0x5

//
// Read Disk Information Definitions and Capabilities
//

#define DISK_STATUS_EMPTY       0x00
#define DISK_STATUS_INCOMPLETE  0x01
#define DISK_STATUS_COMPLETE    0x02

#define LAST_SESSION_EMPTY              0x00
#define LAST_SESSION_INCOMPLETE         0x01
#define LAST_SESSION_RESERVED_DAMAGED   0x02
#define LAST_SESSION_COMPLETE           0x03

#define DISK_TYPE_CDDA          0x00
#define DISK_TYPE_CDI           0x10
#define DISK_TYPE_XA            0x20
#define DISK_TYPE_UNDEFINED     0xFF

//
//  Values for MrwStatus field.
//

#define DISC_BGFORMAT_STATE_NONE        0x0
#define DISC_BGFORMAT_STATE_INCOMPLETE  0x1
#define DISC_BGFORMAT_STATE_RUNNING     0x2
#define DISC_BGFORMAT_STATE_COMPLETE    0x3


#pragma pack(push, discinfo, 1)
typedef struct _OPC_TABLE_ENTRY {
    UCHAR Speed[2];
    UCHAR OPCValue[6];
} OPC_TABLE_ENTRY, *POPC_TABLE_ENTRY;

typedef struct _DISC_INFORMATION {

    UCHAR Length[2];
    UCHAR DiscStatus        : 2;
    UCHAR LastSessionStatus : 2;
    UCHAR Erasable          : 1;
    UCHAR Reserved1         : 3;
    UCHAR FirstTrackNumber;

    UCHAR NumberOfSessionsLsb;
    UCHAR LastSessionFirstTrackLsb;
    UCHAR LastSessionLastTrackLsb;
    UCHAR MrwStatus   : 2;
    UCHAR MrwDirtyBit : 1;
    UCHAR Reserved2   : 2;
    UCHAR URU         : 1;
    UCHAR DBC_V       : 1;
    UCHAR DID_V       : 1;

    UCHAR DiscType;
    UCHAR NumberOfSessionsMsb;
    UCHAR LastSessionFirstTrackMsb;
    UCHAR LastSessionLastTrackMsb;

    UCHAR DiskIdentification[4];
    UCHAR LastSessionLeadIn[4];     // HMSF
    UCHAR LastPossibleLeadOutStartTime[4]; // HMSF
    UCHAR DiskBarCode[8];

    UCHAR Reserved4;
    UCHAR NumberOPCEntries;
    OPC_TABLE_ENTRY OPCTable[ 1 ]; // can be many of these here....

} DISC_INFORMATION, *PDISC_INFORMATION;

// TODO: Deprecate DISK_INFORMATION
//#if PRAGMA_DEPRECATED_DDK
//#pragma deprecated(_DISK_INFORMATION)  // Use DISC_INFORMATION, note size change
//#pragma deprecated( DISK_INFORMATION)  // Use DISC_INFORMATION, note size change
//#pragma deprecated(PDISK_INFORMATION)  // Use DISC_INFORMATION, note size change
//#endif

typedef struct _DISK_INFORMATION {
    UCHAR Length[2];

    UCHAR DiskStatus : 2;
    UCHAR LastSessionStatus : 2;
    UCHAR Erasable : 1;
    UCHAR Reserved1 : 3;

    UCHAR FirstTrackNumber;
    UCHAR NumberOfSessions;
    UCHAR LastSessionFirstTrack;
    UCHAR LastSessionLastTrack;

    UCHAR Reserved2 : 5;
    UCHAR GEN : 1;
    UCHAR DBC_V : 1;
    UCHAR DID_V : 1;

    UCHAR DiskType;
    UCHAR Reserved3[3];

    UCHAR DiskIdentification[4];
    UCHAR LastSessionLeadIn[4];     // MSF
    UCHAR LastPossibleStartTime[4]; // MSF
    UCHAR DiskBarCode[8];

    UCHAR Reserved4;
    UCHAR NumberOPCEntries;
#if !defined(__midl)
    OPC_TABLE_ENTRY OPCTable[0];
#endif
} DISK_INFORMATION, *PDISK_INFORMATION;
#pragma pack(pop, discinfo)


//
// Read Header definitions and structures
//
#pragma pack(push, cdheader, 1)
typedef struct _DATA_BLOCK_HEADER {
    UCHAR DataMode;
    UCHAR Reserved[4];
    union {
        UCHAR LogicalBlockAddress[4];
        struct {
            UCHAR Reserved;
            UCHAR M;
            UCHAR S;
            UCHAR F;
        } MSF;
    };
} DATA_BLOCK_HEADER, *PDATA_BLOCK_HEADER;
#pragma pack(pop, cdheader)


#define DATA_BLOCK_MODE0    0x0
#define DATA_BLOCK_MODE1    0x1
#define DATA_BLOCK_MODE2    0x2

//
// Read TOC Format Codes
//

#define READ_TOC_FORMAT_TOC         0x00
#define READ_TOC_FORMAT_SESSION     0x01
#define READ_TOC_FORMAT_FULL_TOC    0x02
#define READ_TOC_FORMAT_PMA         0x03
#define READ_TOC_FORMAT_ATIP        0x04

// TODO: Deprecate TRACK_INFORMATION structure, use TRACK_INFORMATION2 instead
#pragma pack(push, track_info, 1)
typedef struct _TRACK_INFORMATION {
    UCHAR Length[2];
    UCHAR TrackNumber;
    UCHAR SessionNumber;
    UCHAR Reserved1;
    UCHAR TrackMode : 4;
    UCHAR Copy      : 1;
    UCHAR Damage    : 1;
    UCHAR Reserved2 : 2;
    UCHAR DataMode : 4;
    UCHAR FP       : 1;
    UCHAR Packet   : 1;
    UCHAR Blank    : 1;
    UCHAR RT       : 1;
    UCHAR NWA_V     : 1;
    UCHAR Reserved3 : 7;
    UCHAR TrackStartAddress[4];
    UCHAR NextWritableAddress[4];
    UCHAR FreeBlocks[4];
    UCHAR FixedPacketSize[4];
} TRACK_INFORMATION, *PTRACK_INFORMATION;

// Second Revision Modifies:
// * Longer names for some fields
// * LSB to track/session number fields
// * LRA_V bit
// Second Revision Adds:
// * TrackSize
// * LastRecordedAddress
// * MSB to track/session
// * Two reserved bytes
// Total structure size increased by 12 (0x0C) bytes
typedef struct _TRACK_INFORMATION2 {

    UCHAR Length[2];
    UCHAR TrackNumberLsb;
    UCHAR SessionNumberLsb;

    UCHAR Reserved4;
    UCHAR TrackMode : 4;
    UCHAR Copy      : 1;
    UCHAR Damage    : 1;
    UCHAR Reserved5 : 2;
    UCHAR DataMode      : 4;
    UCHAR FixedPacket   : 1;
    UCHAR Packet        : 1;
    UCHAR Blank         : 1;
    UCHAR ReservedTrack : 1;
    UCHAR NWA_V     : 1;
    UCHAR LRA_V     : 1;
    UCHAR Reserved6 : 6;

    UCHAR TrackStartAddress[4];
    UCHAR NextWritableAddress[4];
    UCHAR FreeBlocks[4];
    UCHAR FixedPacketSize[4]; // blocking factor
    UCHAR TrackSize[4];
    UCHAR LastRecordedAddress[4];

    UCHAR TrackNumberMsb;
    UCHAR SessionNumberMsb;
    UCHAR Reserved7[2];

} TRACK_INFORMATION2, *PTRACK_INFORMATION2;

// Third Revision Adds
// * ReadCompatibilityLBA
// Total structure size increased by 4 bytes
typedef struct _TRACK_INFORMATION3 {

    UCHAR Length[2];
    UCHAR TrackNumberLsb;
    UCHAR SessionNumberLsb;

    UCHAR Reserved4;
    UCHAR TrackMode : 4;
    UCHAR Copy      : 1;
    UCHAR Damage    : 1;
    UCHAR Reserved5 : 2;
    UCHAR DataMode      : 4;
    UCHAR FixedPacket   : 1;
    UCHAR Packet        : 1;
    UCHAR Blank         : 1;
    UCHAR ReservedTrack : 1;
    UCHAR NWA_V     : 1;
    UCHAR LRA_V     : 1;
    UCHAR Reserved6 : 6;

    UCHAR TrackStartAddress[4];
    UCHAR NextWritableAddress[4];
    UCHAR FreeBlocks[4];
    UCHAR FixedPacketSize[4]; // blocking factor
    UCHAR TrackSize[4];
    UCHAR LastRecordedAddress[4];

    UCHAR TrackNumberMsb;
    UCHAR SessionNumberMsb;
    UCHAR Reserved7[2];
    UCHAR ReadCompatibilityLba[4];

} TRACK_INFORMATION3, *PTRACK_INFORMATION3;

#pragma pack(pop, track_info)

#pragma pack(push, perf_descriptor, 1)
typedef struct _PERFORMANCE_DESCRIPTOR {

    UCHAR RandomAccess         : 1;
    UCHAR Exact                : 1;
    UCHAR RestoreDefaults      : 1;
    UCHAR WriteRotationControl : 2;
    UCHAR Reserved1            : 3;

    UCHAR Reserved[3];
    UCHAR StartLba[4];
    UCHAR EndLba[4];
    UCHAR ReadSize[4];
    UCHAR ReadTime[4];
    UCHAR WriteSize[4];
    UCHAR WriteTime[4];

} PERFORMANCE_DESCRIPTOR, *PPERFORMANCE_DESCRIPTOR;
#pragma pack(pop, perf_descriptor)

//
// Command Descriptor Block constants.
//

#define CDB6GENERIC_LENGTH                   6
#define CDB10GENERIC_LENGTH                  10
#define CDB12GENERIC_LENGTH                  12

#define SETBITON                             1
#define SETBITOFF                            0

//
// Mode Sense/Select page constants.
//

#define MODE_PAGE_VENDOR_SPECIFIC       0x00
#define MODE_PAGE_ERROR_RECOVERY        0x01
#define MODE_PAGE_DISCONNECT            0x02
#define MODE_PAGE_FORMAT_DEVICE         0x03 // disk
#define MODE_PAGE_MRW                   0x03 // cdrom
#define MODE_PAGE_RIGID_GEOMETRY        0x04
#define MODE_PAGE_FLEXIBILE             0x05 // disk
#define MODE_PAGE_WRITE_PARAMETERS      0x05 // cdrom
#define MODE_PAGE_VERIFY_ERROR          0x07
#define MODE_PAGE_CACHING               0x08
#define MODE_PAGE_PERIPHERAL            0x09
#define MODE_PAGE_CONTROL               0x0A
#define MODE_PAGE_MEDIUM_TYPES          0x0B
#define MODE_PAGE_NOTCH_PARTITION       0x0C
#define MODE_PAGE_CD_AUDIO_CONTROL      0x0E
#define MODE_PAGE_DATA_COMPRESS         0x0F
#define MODE_PAGE_DEVICE_CONFIG         0x10
#define MODE_PAGE_XOR_CONTROL           0x10 // disk
#define MODE_PAGE_MEDIUM_PARTITION      0x11
#define MODE_PAGE_ENCLOSURE_SERVICES_MANAGEMENT 0x14
#define MODE_PAGE_EXTENDED              0x15
#define MODE_PAGE_EXTENDED_DEVICE_SPECIFIC 0x16
#define MODE_PAGE_CDVD_FEATURE_SET      0x18
#define MODE_PAGE_PROTOCOL_SPECIFIC_LUN 0x18
#define MODE_PAGE_PROTOCOL_SPECIFIC_PORT 0x19
#define MODE_PAGE_POWER_CONDITION       0x1A
#define MODE_PAGE_LUN_MAPPING           0x1B
#define MODE_PAGE_FAULT_REPORTING       0x1C
#define MODE_PAGE_CDVD_INACTIVITY       0x1D // cdrom
#define MODE_PAGE_ELEMENT_ADDRESS       0x1D
#define MODE_PAGE_TRANSPORT_GEOMETRY    0x1E
#define MODE_PAGE_DEVICE_CAPABILITIES   0x1F
#define MODE_PAGE_CAPABILITIES          0x2A // cdrom

#define MODE_SENSE_RETURN_ALL           0x3f

#define MODE_SENSE_CURRENT_VALUES       0x00
#define MODE_SENSE_CHANGEABLE_VALUES    0x40
#define MODE_SENSE_DEFAULT_VAULES       0x80
#define MODE_SENSE_SAVED_VALUES         0xc0


//
// SCSI CDB operation codes
//

// 6-byte commands:
#define SCSIOP_TEST_UNIT_READY          0x00
#define SCSIOP_REZERO_UNIT              0x01
#define SCSIOP_REWIND                   0x01
#define SCSIOP_REQUEST_BLOCK_ADDR       0x02
#define SCSIOP_REQUEST_SENSE            0x03
#define SCSIOP_FORMAT_UNIT              0x04
#define SCSIOP_READ_BLOCK_LIMITS        0x05
#define SCSIOP_REASSIGN_BLOCKS          0x07
#define SCSIOP_INIT_ELEMENT_STATUS      0x07
#define SCSIOP_READ6                    0x08
#define SCSIOP_RECEIVE                  0x08
#define SCSIOP_WRITE6                   0x0A
#define SCSIOP_PRINT                    0x0A
#define SCSIOP_SEND                     0x0A
#define SCSIOP_SEEK6                    0x0B
#define SCSIOP_TRACK_SELECT             0x0B
#define SCSIOP_SLEW_PRINT               0x0B
#define SCSIOP_SET_CAPACITY             0x0B // tape
#define SCSIOP_SEEK_BLOCK               0x0C
#define SCSIOP_PARTITION                0x0D
#define SCSIOP_READ_REVERSE             0x0F
#define SCSIOP_WRITE_FILEMARKS          0x10
#define SCSIOP_FLUSH_BUFFER             0x10
#define SCSIOP_SPACE                    0x11
#define SCSIOP_INQUIRY                  0x12
#define SCSIOP_VERIFY6                  0x13
#define SCSIOP_RECOVER_BUF_DATA         0x14
#define SCSIOP_MODE_SELECT              0x15
#define SCSIOP_RESERVE_UNIT             0x16
#define SCSIOP_RELEASE_UNIT             0x17
#define SCSIOP_COPY                     0x18
#define SCSIOP_ERASE                    0x19
#define SCSIOP_MODE_SENSE               0x1A
#define SCSIOP_START_STOP_UNIT          0x1B
#define SCSIOP_STOP_PRINT               0x1B
#define SCSIOP_LOAD_UNLOAD              0x1B
#define SCSIOP_RECEIVE_DIAGNOSTIC       0x1C
#define SCSIOP_SEND_DIAGNOSTIC          0x1D
#define SCSIOP_MEDIUM_REMOVAL           0x1E

// 10-byte commands
#define SCSIOP_READ_FORMATTED_CAPACITY  0x23
#define SCSIOP_READ_CAPACITY            0x25
#define SCSIOP_READ                     0x28
#define SCSIOP_WRITE                    0x2A
#define SCSIOP_SEEK                     0x2B
#define SCSIOP_LOCATE                   0x2B
#define SCSIOP_POSITION_TO_ELEMENT      0x2B
#define SCSIOP_WRITE_VERIFY             0x2E
#define SCSIOP_VERIFY                   0x2F
#define SCSIOP_SEARCH_DATA_HIGH         0x30
#define SCSIOP_SEARCH_DATA_EQUAL        0x31
#define SCSIOP_SEARCH_DATA_LOW          0x32
#define SCSIOP_SET_LIMITS               0x33
#define SCSIOP_READ_POSITION            0x34
#define SCSIOP_SYNCHRONIZE_CACHE        0x35
#define SCSIOP_COMPARE                  0x39
#define SCSIOP_COPY_COMPARE             0x3A
#define SCSIOP_WRITE_DATA_BUFF          0x3B
#define SCSIOP_READ_DATA_BUFF           0x3C
#define SCSIOP_WRITE_LONG               0x3F
#define SCSIOP_CHANGE_DEFINITION        0x40
#define SCSIOP_WRITE_SAME               0x41
#define SCSIOP_READ_SUB_CHANNEL         0x42
#define SCSIOP_READ_TOC                 0x43
#define SCSIOP_READ_HEADER              0x44
#define SCSIOP_REPORT_DENSITY_SUPPORT   0x44 // tape
#define SCSIOP_PLAY_AUDIO               0x45
#define SCSIOP_GET_CONFIGURATION        0x46
#define SCSIOP_PLAY_AUDIO_MSF           0x47
#define SCSIOP_PLAY_TRACK_INDEX         0x48
#define SCSIOP_PLAY_TRACK_RELATIVE      0x49
#define SCSIOP_GET_EVENT_STATUS         0x4A
#define SCSIOP_PAUSE_RESUME             0x4B
#define SCSIOP_LOG_SELECT               0x4C
#define SCSIOP_LOG_SENSE                0x4D
#define SCSIOP_STOP_PLAY_SCAN           0x4E
#define SCSIOP_XDWRITE                  0x50
#define SCSIOP_XPWRITE                  0x51
#define SCSIOP_READ_DISK_INFORMATION    0x51
#define SCSIOP_READ_DISC_INFORMATION    0x51 // proper use of disc over disk
#define SCSIOP_READ_TRACK_INFORMATION   0x52
#define SCSIOP_XDWRITE_READ             0x53
#define SCSIOP_RESERVE_TRACK_RZONE      0x53
#define SCSIOP_SEND_OPC_INFORMATION     0x54 // optimum power calibration
#define SCSIOP_MODE_SELECT10            0x55
#define SCSIOP_RESERVE_UNIT10           0x56
#define SCSIOP_RESERVE_ELEMENT          0x56
#define SCSIOP_RELEASE_UNIT10           0x57
#define SCSIOP_RELEASE_ELEMENT          0x57
#define SCSIOP_REPAIR_TRACK             0x58
#define SCSIOP_MODE_SENSE10             0x5A
#define SCSIOP_CLOSE_TRACK_SESSION      0x5B
#define SCSIOP_READ_BUFFER_CAPACITY     0x5C
#define SCSIOP_SEND_CUE_SHEET           0x5D
#define SCSIOP_PERSISTENT_RESERVE_IN    0x5E
#define SCSIOP_PERSISTENT_RESERVE_OUT   0x5F

// 12-byte commands
#define SCSIOP_REPORT_LUNS              0xA0
#define SCSIOP_BLANK                    0xA1
#define SCSIOP_ATA_PASSTHROUGH12        0xA1
#define SCSIOP_SEND_EVENT               0xA2
#define SCSIOP_SEND_KEY                 0xA3
#define SCSIOP_MAINTENANCE_IN           0xA3
#define SCSIOP_REPORT_KEY               0xA4
#define SCSIOP_MAINTENANCE_OUT          0xA4
#define SCSIOP_MOVE_MEDIUM              0xA5
#define SCSIOP_LOAD_UNLOAD_SLOT         0xA6
#define SCSIOP_EXCHANGE_MEDIUM          0xA6
#define SCSIOP_SET_READ_AHEAD           0xA7
#define SCSIOP_MOVE_MEDIUM_ATTACHED     0xA7
#define SCSIOP_READ12                   0xA8
#define SCSIOP_GET_MESSAGE              0xA8
#define SCSIOP_SERVICE_ACTION_OUT12     0xA9
#define SCSIOP_WRITE12                  0xAA
#define SCSIOP_SEND_MESSAGE             0xAB
#define SCSIOP_SERVICE_ACTION_IN12      0xAB
#define SCSIOP_GET_PERFORMANCE          0xAC
#define SCSIOP_READ_DVD_STRUCTURE       0xAD
#define SCSIOP_WRITE_VERIFY12           0xAE
#define SCSIOP_VERIFY12                 0xAF
#define SCSIOP_SEARCH_DATA_HIGH12       0xB0
#define SCSIOP_SEARCH_DATA_EQUAL12      0xB1
#define SCSIOP_SEARCH_DATA_LOW12        0xB2
#define SCSIOP_SET_LIMITS12             0xB3
#define SCSIOP_READ_ELEMENT_STATUS_ATTACHED 0xB4
#define SCSIOP_REQUEST_VOL_ELEMENT      0xB5
#define SCSIOP_SEND_VOLUME_TAG          0xB6
#define SCSIOP_SET_STREAMING            0xB6 // C/DVD
#define SCSIOP_READ_DEFECT_DATA         0xB7
#define SCSIOP_READ_ELEMENT_STATUS      0xB8
#define SCSIOP_READ_CD_MSF              0xB9
#define SCSIOP_SCAN_CD                  0xBA
#define SCSIOP_REDUNDANCY_GROUP_IN      0xBA
#define SCSIOP_SET_CD_SPEED             0xBB
#define SCSIOP_REDUNDANCY_GROUP_OUT     0xBB
#define SCSIOP_PLAY_CD                  0xBC
#define SCSIOP_SPARE_IN                 0xBC
#define SCSIOP_MECHANISM_STATUS         0xBD
#define SCSIOP_SPARE_OUT                0xBD
#define SCSIOP_READ_CD                  0xBE
#define SCSIOP_VOLUME_SET_IN            0xBE
#define SCSIOP_SEND_DVD_STRUCTURE       0xBF
#define SCSIOP_VOLUME_SET_OUT           0xBF
#define SCSIOP_INIT_ELEMENT_RANGE       0xE7

// 16-byte commands
#define SCSIOP_XDWRITE_EXTENDED16       0x80 // disk
#define SCSIOP_WRITE_FILEMARKS16        0x80 // tape
#define SCSIOP_REBUILD16                0x81 // disk
#define SCSIOP_READ_REVERSE16           0x81 // tape
#define SCSIOP_REGENERATE16             0x82 // disk
#define SCSIOP_EXTENDED_COPY            0x83
#define SCSIOP_RECEIVE_COPY_RESULTS     0x84
#define SCSIOP_ATA_PASSTHROUGH16        0x85
#define SCSIOP_ACCESS_CONTROL_IN        0x86
#define SCSIOP_ACCESS_CONTROL_OUT       0x87
#define SCSIOP_READ16                   0x88
#define SCSIOP_WRITE16                  0x8A
#define SCSIOP_READ_ATTRIBUTES          0x8C
#define SCSIOP_WRITE_ATTRIBUTES         0x8D
#define SCSIOP_WRITE_VERIFY16           0x8E
#define SCSIOP_VERIFY16                 0x8F
#define SCSIOP_PREFETCH16               0x90
#define SCSIOP_SYNCHRONIZE_CACHE16      0x91
#define SCSIOP_SPACE16                  0x91 // tape
#define SCSIOP_LOCK_UNLOCK_CACHE16      0x92
#define SCSIOP_LOCATE16                 0x92 // tape
#define SCSIOP_WRITE_SAME16             0x93
#define SCSIOP_ERASE16                  0x93 // tape
#define SCSIOP_READ_CAPACITY16          0x9E
#define SCSIOP_SERVICE_ACTION_IN16      0x9E
#define SCSIOP_SERVICE_ACTION_OUT16     0x9F


//
// If the IMMED bit is 1, status is returned as soon
// as the operation is initiated. If the IMMED bit
// is 0, status is not returned until the operation
// is completed.
//

#define CDB_RETURN_ON_COMPLETION   0
#define CDB_RETURN_IMMEDIATE       1

// end_ntminitape

//
// CDB Force media access used in extended read and write commands.
//

#define CDB_FORCE_MEDIA_ACCESS 0x08

//
// Denon CD ROM operation codes
//

#define SCSIOP_DENON_EJECT_DISC    0xE6
#define SCSIOP_DENON_STOP_AUDIO    0xE7
#define SCSIOP_DENON_PLAY_AUDIO    0xE8
#define SCSIOP_DENON_READ_TOC      0xE9
#define SCSIOP_DENON_READ_SUBCODE  0xEB

//
// SCSI Bus Messages
//

#define SCSIMESS_ABORT                0x06
#define SCSIMESS_ABORT_WITH_TAG       0x0D
#define SCSIMESS_BUS_DEVICE_RESET     0X0C
#define SCSIMESS_CLEAR_QUEUE          0X0E
#define SCSIMESS_COMMAND_COMPLETE     0X00
#define SCSIMESS_DISCONNECT           0X04
#define SCSIMESS_EXTENDED_MESSAGE     0X01
#define SCSIMESS_IDENTIFY             0X80
#define SCSIMESS_IDENTIFY_WITH_DISCON 0XC0
#define SCSIMESS_IGNORE_WIDE_RESIDUE  0X23
#define SCSIMESS_INITIATE_RECOVERY    0X0F
#define SCSIMESS_INIT_DETECTED_ERROR  0X05
#define SCSIMESS_LINK_CMD_COMP        0X0A
#define SCSIMESS_LINK_CMD_COMP_W_FLAG 0X0B
#define SCSIMESS_MESS_PARITY_ERROR    0X09
#define SCSIMESS_MESSAGE_REJECT       0X07
#define SCSIMESS_NO_OPERATION         0X08
#define SCSIMESS_HEAD_OF_QUEUE_TAG    0X21
#define SCSIMESS_ORDERED_QUEUE_TAG    0X22
#define SCSIMESS_SIMPLE_QUEUE_TAG     0X20
#define SCSIMESS_RELEASE_RECOVERY     0X10
#define SCSIMESS_RESTORE_POINTERS     0X03
#define SCSIMESS_SAVE_DATA_POINTER    0X02
#define SCSIMESS_TERMINATE_IO_PROCESS 0X11

//
// SCSI Extended Message operation codes
//

#define SCSIMESS_MODIFY_DATA_POINTER  0X00
#define SCSIMESS_SYNCHRONOUS_DATA_REQ 0X01
#define SCSIMESS_WIDE_DATA_REQUEST    0X03

//
// SCSI Extended Message Lengths
//

#define SCSIMESS_MODIFY_DATA_LENGTH   5
#define SCSIMESS_SYNCH_DATA_LENGTH    3
#define SCSIMESS_WIDE_DATA_LENGTH     2

//
// SCSI extended message structure
//

#pragma pack(push, scsi_mess, 1)
typedef struct _SCSI_EXTENDED_MESSAGE {
    UCHAR InitialMessageCode;
    UCHAR MessageLength;
    UCHAR MessageType;
    union _EXTENDED_ARGUMENTS {

        struct {
            UCHAR Modifier[4];
        } Modify;

        struct {
            UCHAR TransferPeriod;
            UCHAR ReqAckOffset;
        } Synchronous;

        struct{
            UCHAR Width;
        } Wide;
    }ExtendedArguments;
}SCSI_EXTENDED_MESSAGE, *PSCSI_EXTENDED_MESSAGE;
#pragma pack(pop, scsi_mess)

//
// SCSI bus status codes.
//

#define SCSISTAT_GOOD                  0x00
#define SCSISTAT_CHECK_CONDITION       0x02
#define SCSISTAT_CONDITION_MET         0x04
#define SCSISTAT_BUSY                  0x08
#define SCSISTAT_INTERMEDIATE          0x10
#define SCSISTAT_INTERMEDIATE_COND_MET 0x14
#define SCSISTAT_RESERVATION_CONFLICT  0x18
#define SCSISTAT_COMMAND_TERMINATED    0x22
#define SCSISTAT_QUEUE_FULL            0x28

//
// Enable Vital Product Data Flag (EVPD)
// used with INQUIRY command.
//

#define CDB_INQUIRY_EVPD           0x01

//
// Defines for format CDB
//

#define LUN0_FORMAT_SAVING_DEFECT_LIST 0
#define USE_DEFAULTMSB  0
#define USE_DEFAULTLSB  0

#define START_UNIT_CODE 0x01
#define STOP_UNIT_CODE  0x00

// begin_ntminitape

//
// Inquiry buffer structure. This is the data returned from the target
// after it receives an inquiry.
//
// This structure may be extended by the number of bytes specified
// in the field AdditionalLength. The defined size constant only
// includes fields through ProductRevisionLevel.
//
// The NT SCSI drivers are only interested in the first 36 bytes of data.
//

#define INQUIRYDATABUFFERSIZE 36

#if (NTDDI_VERSION < NTDDI_WINXP)
typedef struct _INQUIRYDATA {
    UCHAR DeviceType : 5;
    UCHAR DeviceTypeQualifier : 3;
    UCHAR DeviceTypeModifier : 7;
    UCHAR RemovableMedia : 1;
    UCHAR Versions;
    UCHAR ResponseDataFormat : 4;
    UCHAR HiSupport : 1;
    UCHAR NormACA : 1;
    UCHAR ReservedBit : 1;
    UCHAR AERC : 1;
    UCHAR AdditionalLength;
    UCHAR Reserved[2];
    UCHAR SoftReset : 1;
    UCHAR CommandQueue : 1;
    UCHAR Reserved2 : 1;
    UCHAR LinkedCommands : 1;
    UCHAR Synchronous : 1;
    UCHAR Wide16Bit : 1;
    UCHAR Wide32Bit : 1;
    UCHAR RelativeAddressing : 1;
    UCHAR VendorId[8];
    UCHAR ProductId[16];
    UCHAR ProductRevisionLevel[4];
    UCHAR VendorSpecific[20];
    UCHAR Reserved3[40];
} INQUIRYDATA, *PINQUIRYDATA;
#else
#pragma pack(push, inquiry, 1)
typedef struct _INQUIRYDATA {
    UCHAR DeviceType : 5;
    UCHAR DeviceTypeQualifier : 3;
    UCHAR DeviceTypeModifier : 7;
    UCHAR RemovableMedia : 1;
    union {
        UCHAR Versions;
        struct {
            UCHAR ANSIVersion : 3;
            UCHAR ECMAVersion : 3;
            UCHAR ISOVersion : 2;
        };
    };
    UCHAR ResponseDataFormat : 4;
    UCHAR HiSupport : 1;
    UCHAR NormACA : 1;
    UCHAR TerminateTask : 1;
    UCHAR AERC : 1;
    UCHAR AdditionalLength;
    UCHAR Reserved;
    UCHAR Addr16 : 1;               // defined only for SIP devices.
    UCHAR Addr32 : 1;               // defined only for SIP devices.
    UCHAR AckReqQ: 1;               // defined only for SIP devices.
    UCHAR MediumChanger : 1;
    UCHAR MultiPort : 1;
    UCHAR ReservedBit2 : 1;
    UCHAR EnclosureServices : 1;
    UCHAR ReservedBit3 : 1;
    UCHAR SoftReset : 1;
    UCHAR CommandQueue : 1;
    UCHAR TransferDisable : 1;      // defined only for SIP devices.
    UCHAR LinkedCommands : 1;
    UCHAR Synchronous : 1;          // defined only for SIP devices.
    UCHAR Wide16Bit : 1;            // defined only for SIP devices.
    UCHAR Wide32Bit : 1;            // defined only for SIP devices.
    UCHAR RelativeAddressing : 1;
    UCHAR VendorId[8];
    UCHAR ProductId[16];
    UCHAR ProductRevisionLevel[4];
    UCHAR VendorSpecific[20];
    UCHAR Reserved3[40];
} INQUIRYDATA, *PINQUIRYDATA;
#pragma pack(pop, inquiry)
#endif

//
// Inquiry defines. Used to interpret data returned from target as result
// of inquiry command.
//
// DeviceType field
//

#define DIRECT_ACCESS_DEVICE            0x00    // disks
#define SEQUENTIAL_ACCESS_DEVICE        0x01    // tapes
#define PRINTER_DEVICE                  0x02    // printers
#define PROCESSOR_DEVICE                0x03    // scanners, printers, etc
#define WRITE_ONCE_READ_MULTIPLE_DEVICE 0x04    // worms
#define READ_ONLY_DIRECT_ACCESS_DEVICE  0x05    // cdroms
#define SCANNER_DEVICE                  0x06    // scanners
#define OPTICAL_DEVICE                  0x07    // optical disks
#define MEDIUM_CHANGER                  0x08    // jukebox
#define COMMUNICATION_DEVICE            0x09    // network
// 0xA and 0xB are obsolete
#define ARRAY_CONTROLLER_DEVICE         0x0C
#define SCSI_ENCLOSURE_DEVICE           0x0D
#define REDUCED_BLOCK_DEVICE            0x0E    // e.g., 1394 disk
#define OPTICAL_CARD_READER_WRITER_DEVICE 0x0F
#define BRIDGE_CONTROLLER_DEVICE        0x10
#define OBJECT_BASED_STORAGE_DEVICE     0x11    // OSD
#define LOGICAL_UNIT_NOT_PRESENT_DEVICE 0x7F

#define DEVICE_QUALIFIER_ACTIVE         0x00
#define DEVICE_QUALIFIER_NOT_ACTIVE     0x01
#define DEVICE_QUALIFIER_NOT_SUPPORTED  0x03

//
// DeviceTypeQualifier field
//

#define DEVICE_CONNECTED 0x00

//
// Vital Product Data Pages
//

//
// Unit Serial Number Page (page code 0x80)
//
// Provides a product serial number for the target or the logical unit.
//
#pragma pack(push, vpd_media_sn, 1)
typedef struct _VPD_MEDIA_SERIAL_NUMBER_PAGE {
    UCHAR DeviceType : 5;
    UCHAR DeviceTypeQualifier : 3;
    UCHAR PageCode;
    UCHAR Reserved;
    UCHAR PageLength;
#if !defined(__midl)
    UCHAR SerialNumber[0];
#endif
} VPD_MEDIA_SERIAL_NUMBER_PAGE, *PVPD_MEDIA_SERIAL_NUMBER_PAGE;
#pragma pack(pop, vpd_media_sn)

#pragma pack(push, vpd_sn, 1)
typedef struct _VPD_SERIAL_NUMBER_PAGE {
    UCHAR DeviceType : 5;
    UCHAR DeviceTypeQualifier : 3;
    UCHAR PageCode;
    UCHAR Reserved;
    UCHAR PageLength;
#if !defined(__midl)
    UCHAR SerialNumber[0];
#endif
} VPD_SERIAL_NUMBER_PAGE, *PVPD_SERIAL_NUMBER_PAGE;
#pragma pack(pop, vpd_sn)

//
// Device Identification Page (page code 0x83)
// Provides the means to retrieve zero or more identification descriptors
// applying to the logical unit.
//

#pragma pack(push, vpd_stuff, 1)
typedef enum _VPD_CODE_SET {
    VpdCodeSetReserved = 0,
    VpdCodeSetBinary = 1,
    VpdCodeSetAscii = 2,
    VpdCodeSetUTF8 = 3
} VPD_CODE_SET, *PVPD_CODE_SET;

typedef enum _VPD_ASSOCIATION {
    VpdAssocDevice = 0,
    VpdAssocPort = 1,
    VpdAssocTarget = 2,
    VpdAssocReserved1 = 3,
    VpdAssocReserved2 = 4       // bogus, only two bits
} VPD_ASSOCIATION, *PVPD_ASSOCIATION;

typedef enum _VPD_IDENTIFIER_TYPE {
    VpdIdentifierTypeVendorSpecific = 0,
    VpdIdentifierTypeVendorId = 1,
    VpdIdentifierTypeEUI64 = 2,
    VpdIdentifierTypeFCPHName = 3,
    VpdIdentifierTypePortRelative = 4,
    VpdIdentifierTypeTargetPortGroup = 5,
    VpdIdentifierTypeLogicalUnitGroup = 6,
    VpdIdentifierTypeMD5LogicalUnitId = 7,
    VpdIdentifierTypeSCSINameString = 8
} VPD_IDENTIFIER_TYPE, *PVPD_IDENTIFIER_TYPE;

typedef struct _VPD_IDENTIFICATION_DESCRIPTOR {
    UCHAR CodeSet : 4;          // VPD_CODE_SET
    UCHAR Reserved : 4;
    UCHAR IdentifierType : 4;   // VPD_IDENTIFIER_TYPE
    UCHAR Association : 2;
    UCHAR Reserved2 : 2;
    UCHAR Reserved3;
    UCHAR IdentifierLength;
#if !defined(__midl)
    UCHAR Identifier[0];
#endif
} VPD_IDENTIFICATION_DESCRIPTOR, *PVPD_IDENTIFICATION_DESCRIPTOR;

typedef struct _VPD_IDENTIFICATION_PAGE {
    UCHAR DeviceType : 5;
    UCHAR DeviceTypeQualifier : 3;
    UCHAR PageCode;
    UCHAR Reserved;
    UCHAR PageLength;


    //
    // The following field is actually a variable length array of identification
    // descriptors.  Unfortunately there's no C notation for an array of
    // variable length structures so we're forced to just pretend.
    //

#if !defined(__midl)
    // VPD_IDENTIFICATION_DESCRIPTOR Descriptors[0];
    UCHAR Descriptors[0];
#endif
} VPD_IDENTIFICATION_PAGE, *PVPD_IDENTIFICATION_PAGE;

//
// Supported Vital Product Data Pages Page (page code 0x00)
// Contains a list of the vital product data page cods supported by the target
// or logical unit.
//

typedef struct _VPD_SUPPORTED_PAGES_PAGE {
    UCHAR DeviceType : 5;
    UCHAR DeviceTypeQualifier : 3;
    UCHAR PageCode;
    UCHAR Reserved;
    UCHAR PageLength;
#if !defined(__midl)
    UCHAR SupportedPageList[0];
#endif
} VPD_SUPPORTED_PAGES_PAGE, *PVPD_SUPPORTED_PAGES_PAGE;
#pragma pack(pop, vpd_stuff)


#define VPD_MAX_BUFFER_SIZE         0xff

#define VPD_SUPPORTED_PAGES         0x00
#define VPD_SERIAL_NUMBER           0x80
#define VPD_DEVICE_IDENTIFIERS      0x83
#define VPD_MEDIA_SERIAL_NUMBER     0x84
#define VPD_SOFTWARE_INTERFACE_IDENTIFIERS 0x84
#define VPD_NETWORK_MANAGEMENT_ADDRESSES 0x85
#define VPD_EXTENDED_INQUIRY_DATA   0x86
#define VPD_MODE_PAGE_POLICY        0x87
#define VPD_SCSI_PORTS              0x88


//
// Persistent Reservation Definitions.
//

//
// PERSISTENT_RESERVE_* definitions
//

#define RESERVATION_ACTION_READ_KEYS                    0x00
#define RESERVATION_ACTION_READ_RESERVATIONS            0x01

#define RESERVATION_ACTION_REGISTER                     0x00
#define RESERVATION_ACTION_RESERVE                      0x01
#define RESERVATION_ACTION_RELEASE                      0x02
#define RESERVATION_ACTION_CLEAR                        0x03
#define RESERVATION_ACTION_PREEMPT                      0x04
#define RESERVATION_ACTION_PREEMPT_ABORT                0x05
#define RESERVATION_ACTION_REGISTER_IGNORE_EXISTING     0x06

#define RESERVATION_SCOPE_LU                            0x00
#define RESERVATION_SCOPE_ELEMENT                       0x02

#define RESERVATION_TYPE_WRITE_EXCLUSIVE                0x01
#define RESERVATION_TYPE_EXCLUSIVE                      0x03
#define RESERVATION_TYPE_WRITE_EXCLUSIVE_REGISTRANTS    0x05
#define RESERVATION_TYPE_EXCLUSIVE_REGISTRANTS          0x06

//
// Structures for reserve in command.
//

#pragma pack(push, reserve_in_stuff, 1)
typedef struct {
    UCHAR Generation[4];
    UCHAR AdditionalLength[4];
#if !defined(__midl)
    UCHAR ReservationKeyList[0][8];
#endif
} PRI_REGISTRATION_LIST, *PPRI_REGISTRATION_LIST;

typedef struct {
    UCHAR ReservationKey[8];
    UCHAR ScopeSpecificAddress[4];
    UCHAR Reserved;
    UCHAR Type : 4;
    UCHAR Scope : 4;
    UCHAR Obsolete[2];
} PRI_RESERVATION_DESCRIPTOR, *PPRI_RESERVATION_DESCRIPTOR;

typedef struct {
    UCHAR Generation[4];
    UCHAR AdditionalLength[4];
#if !defined(__midl)
    PRI_RESERVATION_DESCRIPTOR Reservations[0];
#endif
} PRI_RESERVATION_LIST, *PPRI_RESERVATION_LIST;
#pragma pack(pop, reserve_in_stuff)

//
// Structures for reserve out command.
//

#pragma pack(push, reserve_out_stuff, 1)
typedef struct {
    UCHAR ReservationKey[8];
    UCHAR ServiceActionReservationKey[8];
    UCHAR ScopeSpecificAddress[4];
    UCHAR ActivatePersistThroughPowerLoss : 1;
    UCHAR Reserved1 : 7;
    UCHAR Reserved2;
    UCHAR Obsolete[2];
} PRO_PARAMETER_LIST, *PPRO_PARAMETER_LIST;
#pragma pack(pop, reserve_out_stuff)


//
// Sense Data Format
//

#pragma pack(push, sensedata, 1)
typedef struct _SENSE_DATA {
    UCHAR ErrorCode:7;
    UCHAR Valid:1;
    UCHAR SegmentNumber;
    UCHAR SenseKey:4;
    UCHAR Reserved:1;
    UCHAR IncorrectLength:1;
    UCHAR EndOfMedia:1;
    UCHAR FileMark:1;
    UCHAR Information[4];
    UCHAR AdditionalSenseLength;
    UCHAR CommandSpecificInformation[4];
    UCHAR AdditionalSenseCode;
    UCHAR AdditionalSenseCodeQualifier;
    UCHAR FieldReplaceableUnitCode;
    UCHAR SenseKeySpecific[3];
} SENSE_DATA, *PSENSE_DATA;
#pragma pack(pop, sensedata)

//
// Default request sense buffer size
//

#define SENSE_BUFFER_SIZE 18

//
// Maximum request sense buffer size
//

#define MAX_SENSE_BUFFER_SIZE 255

//
// Maximum number of additional sense bytes.
//

#define MAX_ADDITIONAL_SENSE_BYTES (MAX_SENSE_BUFFER_SIZE - SENSE_BUFFER_SIZE)

//
// Sense codes
//

#define SCSI_SENSE_NO_SENSE         0x00
#define SCSI_SENSE_RECOVERED_ERROR  0x01
#define SCSI_SENSE_NOT_READY        0x02
#define SCSI_SENSE_MEDIUM_ERROR     0x03
#define SCSI_SENSE_HARDWARE_ERROR   0x04
#define SCSI_SENSE_ILLEGAL_REQUEST  0x05
#define SCSI_SENSE_UNIT_ATTENTION   0x06
#define SCSI_SENSE_DATA_PROTECT     0x07
#define SCSI_SENSE_BLANK_CHECK      0x08
#define SCSI_SENSE_UNIQUE           0x09
#define SCSI_SENSE_COPY_ABORTED     0x0A
#define SCSI_SENSE_ABORTED_COMMAND  0x0B
#define SCSI_SENSE_EQUAL            0x0C
#define SCSI_SENSE_VOL_OVERFLOW     0x0D
#define SCSI_SENSE_MISCOMPARE       0x0E
#define SCSI_SENSE_RESERVED         0x0F

//
// Additional tape bit
//

#define SCSI_ILLEGAL_LENGTH         0x20
#define SCSI_EOM                    0x40
#define SCSI_FILE_MARK              0x80

//
// Additional Sense codes
//

#define SCSI_ADSENSE_NO_SENSE                              0x00
#define SCSI_ADSENSE_NO_SEEK_COMPLETE                      0x02
#define SCSI_ADSENSE_LUN_NOT_READY                         0x04
#define SCSI_ADSENSE_LUN_COMMUNICATION                     0x08
#define SCSI_ADSENSE_WRITE_ERROR                           0x0C
#define SCSI_ADSENSE_TRACK_ERROR                           0x14
#define SCSI_ADSENSE_SEEK_ERROR                            0x15
#define SCSI_ADSENSE_REC_DATA_NOECC                        0x17
#define SCSI_ADSENSE_REC_DATA_ECC                          0x18
#define SCSI_ADSENSE_PARAMETER_LIST_LENGTH                 0x1A
#define SCSI_ADSENSE_ILLEGAL_COMMAND                       0x20
#define SCSI_ADSENSE_ILLEGAL_BLOCK                         0x21
#define SCSI_ADSENSE_INVALID_CDB                           0x24
#define SCSI_ADSENSE_INVALID_LUN                           0x25
#define SCSI_ADSENSE_INVALID_FIELD_PARAMETER_LIST          0x26
#define SCSI_ADSENSE_WRITE_PROTECT                         0x27
#define SCSI_ADSENSE_MEDIUM_CHANGED                        0x28
#define SCSI_ADSENSE_BUS_RESET                             0x29
#define SCSI_ADSENSE_PARAMETERS_CHANGED                    0x2A
#define SCSI_ADSENSE_INSUFFICIENT_TIME_FOR_OPERATION       0x2E
#define SCSI_ADSENSE_INVALID_MEDIA                         0x30
#define SCSI_ADSENSE_NO_MEDIA_IN_DEVICE                    0x3a
#define SCSI_ADSENSE_POSITION_ERROR                        0x3b
#define SCSI_ADSENSE_OPERATING_CONDITIONS_CHANGED          0x3f
#define SCSI_ADSENSE_OPERATOR_REQUEST                      0x5a // see below
#define SCSI_ADSENSE_FAILURE_PREDICTION_THRESHOLD_EXCEEDED 0x5d
#define SCSI_ADSENSE_ILLEGAL_MODE_FOR_THIS_TRACK           0x64
#define SCSI_ADSENSE_COPY_PROTECTION_FAILURE               0x6f
#define SCSI_ADSENSE_POWER_CALIBRATION_ERROR               0x73
#define SCSI_ADSENSE_VENDOR_UNIQUE                         0x80 // and higher
#define SCSI_ADSENSE_MUSIC_AREA                            0xA0
#define SCSI_ADSENSE_DATA_AREA                             0xA1
#define SCSI_ADSENSE_VOLUME_OVERFLOW                       0xA7

// for legacy apps:
#define SCSI_ADWRITE_PROTECT                        SCSI_ADSENSE_WRITE_PROTECT
#define SCSI_FAILURE_PREDICTION_THRESHOLD_EXCEEDED  SCSI_ADSENSE_FAILURE_PREDICTION_THRESHOLD_EXCEEDED


//
// SCSI_ADSENSE_LUN_NOT_READY (0x04) qualifiers
//

#define SCSI_SENSEQ_CAUSE_NOT_REPORTABLE         0x00
#define SCSI_SENSEQ_BECOMING_READY               0x01
#define SCSI_SENSEQ_INIT_COMMAND_REQUIRED        0x02
#define SCSI_SENSEQ_MANUAL_INTERVENTION_REQUIRED 0x03
#define SCSI_SENSEQ_FORMAT_IN_PROGRESS           0x04
#define SCSI_SENSEQ_REBUILD_IN_PROGRESS          0x05
#define SCSI_SENSEQ_RECALCULATION_IN_PROGRESS    0x06
#define SCSI_SENSEQ_OPERATION_IN_PROGRESS        0x07
#define SCSI_SENSEQ_LONG_WRITE_IN_PROGRESS       0x08

//
// SCSI_ADSENSE_LUN_COMMUNICATION (0x08) qualifiers
//

#define SCSI_SENSEQ_COMM_FAILURE                 0x00
#define SCSI_SENSEQ_COMM_TIMEOUT                 0x01
#define SCSI_SENSEQ_COMM_PARITY_ERROR            0x02
#define SCSI_SESNEQ_COMM_CRC_ERROR               0x03
#define SCSI_SENSEQ_UNREACHABLE_TARGET           0x04

//
// SCSI_ADSENSE_WRITE_ERROR (0x0C) qualifiers
//
#define SCSI_SENSEQ_LOSS_OF_STREAMING            0x09
#define SCSI_SENSEQ_PADDING_BLOCKS_ADDED         0x0A


//
// SCSI_ADSENSE_NO_SENSE (0x00) qualifiers
//

#define SCSI_SENSEQ_FILEMARK_DETECTED 0x01
#define SCSI_SENSEQ_END_OF_MEDIA_DETECTED 0x02
#define SCSI_SENSEQ_SETMARK_DETECTED 0x03
#define SCSI_SENSEQ_BEGINNING_OF_MEDIA_DETECTED 0x04

//
// SCSI_ADSENSE_ILLEGAL_BLOCK (0x21) qualifiers
//

#define SCSI_SENSEQ_ILLEGAL_ELEMENT_ADDR 0x01

//
// SCSI_ADSENSE_POSITION_ERROR (0x3b) qualifiers
//

#define SCSI_SENSEQ_DESTINATION_FULL 0x0d
#define SCSI_SENSEQ_SOURCE_EMPTY     0x0e

//
// SCSI_ADSENSE_INVALID_MEDIA (0x30) qualifiers
//

#define SCSI_SENSEQ_INCOMPATIBLE_MEDIA_INSTALLED 0x00
#define SCSI_SENSEQ_UNKNOWN_FORMAT 0x01
#define SCSI_SENSEQ_INCOMPATIBLE_FORMAT 0x02
#define SCSI_SENSEQ_CLEANING_CARTRIDGE_INSTALLED 0x03


//
// SCSI_ADSENSE_OPERATING_CONDITIONS_CHANGED (0x3f) qualifiers
//

#define SCSI_SENSEQ_TARGET_OPERATING_CONDITIONS_CHANGED 0x00
#define SCSI_SENSEQ_MICROCODE_CHANGED                   0x01
#define SCSI_SENSEQ_OPERATING_DEFINITION_CHANGED        0x02
#define SCSI_SENSEQ_INQUIRY_DATA_CHANGED                0x03
#define SCSI_SENSEQ_COMPONENT_DEVICE_ATTACHED           0x04
#define SCSI_SENSEQ_DEVICE_IDENTIFIER_CHANGED           0x05
#define SCSI_SENSEQ_REDUNDANCY_GROUP_MODIFIED           0x06
#define SCSI_SENSEQ_REDUNDANCY_GROUP_DELETED            0x07
#define SCSI_SENSEQ_SPARE_MODIFIED                      0x08
#define SCSI_SENSEQ_SPARE_DELETED                       0x09
#define SCSI_SENSEQ_VOLUME_SET_MODIFIED                 0x0A
#define SCSI_SENSEQ_VOLUME_SET_DELETED                  0x0B
#define SCSI_SENSEQ_VOLUME_SET_DEASSIGNED               0x0C
#define SCSI_SENSEQ_VOLUME_SET_REASSIGNED               0x0D
#define SCSI_SENSEQ_REPORTED_LUNS_DATA_CHANGED          0x0E
#define SCSI_SENSEQ_ECHO_BUFFER_OVERWRITTEN             0x0F
#define SCSI_SENSEQ_MEDIUM_LOADABLE                     0x10
#define SCSI_SENSEQ_MEDIUM_AUXILIARY_MEMORY_ACCESSIBLE  0x11


//
// SCSI_ADSENSE_OPERATOR_REQUEST (0x5a) qualifiers
//

#define SCSI_SENSEQ_STATE_CHANGE_INPUT     0x00 // generic request
#define SCSI_SENSEQ_MEDIUM_REMOVAL         0x01
#define SCSI_SENSEQ_WRITE_PROTECT_ENABLE   0x02
#define SCSI_SENSEQ_WRITE_PROTECT_DISABLE  0x03

//
// SCSI_ADSENSE_COPY_PROTECTION_FAILURE (0x6f) qualifiers
//
#define SCSI_SENSEQ_AUTHENTICATION_FAILURE                          0x00
#define SCSI_SENSEQ_KEY_NOT_PRESENT                                 0x01
#define SCSI_SENSEQ_KEY_NOT_ESTABLISHED                             0x02
#define SCSI_SENSEQ_READ_OF_SCRAMBLED_SECTOR_WITHOUT_AUTHENTICATION 0x03
#define SCSI_SENSEQ_MEDIA_CODE_MISMATCHED_TO_LOGICAL_UNIT           0x04
#define SCSI_SENSEQ_LOGICAL_UNIT_RESET_COUNT_ERROR                  0x05

//
// SCSI_ADSENSE_POWER_CALIBRATION_ERROR (0x73) qualifiers
//

#define SCSI_SENSEQ_POWER_CALIBRATION_AREA_ALMOST_FULL 0x01
#define SCSI_SENSEQ_POWER_CALIBRATION_AREA_FULL        0x02
#define SCSI_SENSEQ_POWER_CALIBRATION_AREA_ERROR       0x03
#define SCSI_SENSEQ_PMA_RMA_UPDATE_FAILURE             0x04
#define SCSI_SENSEQ_PMA_RMA_IS_FULL                    0x05
#define SCSI_SENSEQ_PMA_RMA_ALMOST_FULL                0x06


// end_ntminitape

//
// SCSI IO Device Control Codes
//

#define FILE_DEVICE_SCSI 0x0000001b

#define IOCTL_SCSI_EXECUTE_IN   ((FILE_DEVICE_SCSI << 16) + 0x0011)
#define IOCTL_SCSI_EXECUTE_OUT  ((FILE_DEVICE_SCSI << 16) + 0x0012)
#define IOCTL_SCSI_EXECUTE_NONE ((FILE_DEVICE_SCSI << 16) + 0x0013)

//
// SMART support in atapi
//

#define IOCTL_SCSI_MINIPORT_SMART_VERSION           ((FILE_DEVICE_SCSI << 16) + 0x0500)
#define IOCTL_SCSI_MINIPORT_IDENTIFY                ((FILE_DEVICE_SCSI << 16) + 0x0501)
#define IOCTL_SCSI_MINIPORT_READ_SMART_ATTRIBS      ((FILE_DEVICE_SCSI << 16) + 0x0502)
#define IOCTL_SCSI_MINIPORT_READ_SMART_THRESHOLDS   ((FILE_DEVICE_SCSI << 16) + 0x0503)
#define IOCTL_SCSI_MINIPORT_ENABLE_SMART            ((FILE_DEVICE_SCSI << 16) + 0x0504)
#define IOCTL_SCSI_MINIPORT_DISABLE_SMART           ((FILE_DEVICE_SCSI << 16) + 0x0505)
#define IOCTL_SCSI_MINIPORT_RETURN_STATUS           ((FILE_DEVICE_SCSI << 16) + 0x0506)
#define IOCTL_SCSI_MINIPORT_ENABLE_DISABLE_AUTOSAVE ((FILE_DEVICE_SCSI << 16) + 0x0507)
#define IOCTL_SCSI_MINIPORT_SAVE_ATTRIBUTE_VALUES   ((FILE_DEVICE_SCSI << 16) + 0x0508)
#define IOCTL_SCSI_MINIPORT_EXECUTE_OFFLINE_DIAGS   ((FILE_DEVICE_SCSI << 16) + 0x0509)
#define IOCTL_SCSI_MINIPORT_ENABLE_DISABLE_AUTO_OFFLINE ((FILE_DEVICE_SCSI << 16) + 0x050a)
#define IOCTL_SCSI_MINIPORT_READ_SMART_LOG          ((FILE_DEVICE_SCSI << 16) + 0x050b)
#define IOCTL_SCSI_MINIPORT_WRITE_SMART_LOG         ((FILE_DEVICE_SCSI << 16) + 0x050c)

//
// CLUSTER support
// deliberately skipped some values to allow for expansion above.
//
#define IOCTL_SCSI_MINIPORT_NOT_QUORUM_CAPABLE     ((FILE_DEVICE_SCSI << 16) + 0x0520)
#define IOCTL_SCSI_MINIPORT_NOT_CLUSTER_CAPABLE    ((FILE_DEVICE_SCSI << 16) + 0x0521)


// begin_ntminitape

//
// Read Capacity Data - returned in Big Endian format
//

#pragma pack(push, read_capacity, 1)
typedef struct _READ_CAPACITY_DATA {
    ULONG LogicalBlockAddress;
    ULONG BytesPerBlock;
} READ_CAPACITY_DATA, *PREAD_CAPACITY_DATA;
#pragma pack(pop, read_capacity)


#pragma pack(push, read_capacity_ex, 1)
typedef struct _READ_CAPACITY_DATA_EX {
    LARGE_INTEGER LogicalBlockAddress;
    ULONG BytesPerBlock;
} READ_CAPACITY_DATA_EX, *PREAD_CAPACITY_DATA_EX;
#pragma pack(pop, read_capacity_ex)


//
// Read Block Limits Data - returned in Big Endian format
// This structure returns the maximum and minimum block
// size for a TAPE device.
//

#pragma pack(push, read_block_limits, 1)
typedef struct _READ_BLOCK_LIMITS {
    UCHAR Reserved;
    UCHAR BlockMaximumSize[3];
    UCHAR BlockMinimumSize[2];
} READ_BLOCK_LIMITS_DATA, *PREAD_BLOCK_LIMITS_DATA;
#pragma pack(pop, read_block_limits)

#pragma pack(push, read_buffer_capacity, 1)
typedef struct _READ_BUFFER_CAPACITY_DATA {
    UCHAR DataLength[2];
    UCHAR Reserved1;
    UCHAR BlockDataReturned : 1;
    UCHAR Reserved4         : 7;
    UCHAR TotalBufferSize[4];
    UCHAR AvailableBufferSize[4];
} READ_BUFFER_CAPACITY_DATA, *PREAD_BUFFER_CAPACITY_DATA;
#pragma pack(pop, read_buffer_capacity)

//
// Mode data structures.
//

//
// Define Mode parameter header.
//

#pragma pack(push, mode_params, 1)
typedef struct _MODE_PARAMETER_HEADER {
    UCHAR ModeDataLength;
    UCHAR MediumType;
    UCHAR DeviceSpecificParameter;
    UCHAR BlockDescriptorLength;
}MODE_PARAMETER_HEADER, *PMODE_PARAMETER_HEADER;

typedef struct _MODE_PARAMETER_HEADER10 {
    UCHAR ModeDataLength[2];
    UCHAR MediumType;
    UCHAR DeviceSpecificParameter;
    UCHAR Reserved[2];
    UCHAR BlockDescriptorLength[2];
}MODE_PARAMETER_HEADER10, *PMODE_PARAMETER_HEADER10;
#pragma pack(pop, mode_params)

#define MODE_FD_SINGLE_SIDE     0x01
#define MODE_FD_DOUBLE_SIDE     0x02
#define MODE_FD_MAXIMUM_TYPE    0x1E
#define MODE_DSP_FUA_SUPPORTED  0x10
#define MODE_DSP_WRITE_PROTECT  0x80

//
// Define the mode parameter block.
//

#pragma pack(push, mode_params_block, 1)
typedef struct _MODE_PARAMETER_BLOCK {
    UCHAR DensityCode;
    UCHAR NumberOfBlocks[3];
    UCHAR Reserved;
    UCHAR BlockLength[3];
}MODE_PARAMETER_BLOCK, *PMODE_PARAMETER_BLOCK;
#pragma pack(pop, mode_params_block)

//
// Define Disconnect-Reconnect page.
//


#pragma pack(push, mode_page_disconnect, 1)
typedef struct _MODE_DISCONNECT_PAGE {
    UCHAR PageCode : 6;
    UCHAR Reserved : 1;
    UCHAR PageSavable : 1;
    UCHAR PageLength;
    UCHAR BufferFullRatio;
    UCHAR BufferEmptyRatio;
    UCHAR BusInactivityLimit[2];
    UCHAR BusDisconnectTime[2];
    UCHAR BusConnectTime[2];
    UCHAR MaximumBurstSize[2];
    UCHAR DataTransferDisconnect : 2;
    UCHAR Reserved2[3];
}MODE_DISCONNECT_PAGE, *PMODE_DISCONNECT_PAGE;
#pragma pack(pop, mode_page_disconnect)

//
// Define mode caching page.
//

#pragma pack(push, mode_page_caching, 1)
typedef struct _MODE_CACHING_PAGE {
    UCHAR PageCode : 6;
    UCHAR Reserved : 1;
    UCHAR PageSavable : 1;
    UCHAR PageLength;
    UCHAR ReadDisableCache : 1;
    UCHAR MultiplicationFactor : 1;
    UCHAR WriteCacheEnable : 1;
    UCHAR Reserved2 : 5;
    UCHAR WriteRetensionPriority : 4;
    UCHAR ReadRetensionPriority : 4;
    UCHAR DisablePrefetchTransfer[2];
    UCHAR MinimumPrefetch[2];
    UCHAR MaximumPrefetch[2];
    UCHAR MaximumPrefetchCeiling[2];
}MODE_CACHING_PAGE, *PMODE_CACHING_PAGE;
#pragma pack(pop, mode_page_caching)

//
// Define write parameters cdrom page
//
#pragma pack(push, mode_page_wp2, 1)
typedef struct _MODE_CDROM_WRITE_PARAMETERS_PAGE2 {
    UCHAR PageCode : 6;             // 0x05
    UCHAR Reserved : 1;
    UCHAR PageSavable : 1;
    UCHAR PageLength;               // 0x32 ??
    UCHAR WriteType                 : 4;
    UCHAR TestWrite                 : 1;
    UCHAR LinkSizeValid             : 1;
    UCHAR BufferUnderrunFreeEnabled : 1;
    UCHAR Reserved2                 : 1;
    UCHAR TrackMode                 : 4;
    UCHAR Copy                      : 1;
    UCHAR FixedPacket               : 1;
    UCHAR MultiSession              : 2;
    UCHAR DataBlockType             : 4;
    UCHAR Reserved3                 : 4;
    UCHAR LinkSize;
    UCHAR Reserved4;
    UCHAR HostApplicationCode       : 6;
    UCHAR Reserved5                 : 2;
    UCHAR SessionFormat;
    UCHAR Reserved6;
    UCHAR PacketSize[4];
    UCHAR AudioPauseLength[2];
    UCHAR MediaCatalogNumber[16];
    UCHAR ISRC[16];
    UCHAR SubHeaderData[4];
} MODE_CDROM_WRITE_PARAMETERS_PAGE2, *PMODE_CDROM_WRITE_PARAMETERS_PAGE2;
#pragma pack(pop, mode_page_wp2)

#ifndef DEPRECATE_DDK_FUNCTIONS
// this structure is being retired due to missing fields and overly
// complex data definitions for the MCN and ISRC.
#pragma pack(push, mode_page_wp, 1)
typedef struct _MODE_CDROM_WRITE_PARAMETERS_PAGE {
    UCHAR PageLength;               // 0x32 ??
    UCHAR WriteType                 : 4;
    UCHAR TestWrite                 : 1;
    UCHAR LinkSizeValid             : 1;
    UCHAR BufferUnderrunFreeEnabled : 1;
    UCHAR Reserved2                 : 1;
    UCHAR TrackMode                 : 4;
    UCHAR Copy                      : 1;
    UCHAR FixedPacket               : 1;
    UCHAR MultiSession              : 2;
    UCHAR DataBlockType             : 4;
    UCHAR Reserved3                 : 4;
    UCHAR LinkSize;
    UCHAR Reserved4;
    UCHAR HostApplicationCode       : 6;
    UCHAR Reserved5                 : 2;
    UCHAR SessionFormat;
    UCHAR Reserved6;
    UCHAR PacketSize[4];
    UCHAR AudioPauseLength[2];
    UCHAR Reserved7                 : 7;
    UCHAR MediaCatalogNumberValid   : 1;
    UCHAR MediaCatalogNumber[13];
    UCHAR MediaCatalogNumberZero;
    UCHAR MediaCatalogNumberAFrame;
    UCHAR Reserved8                 : 7;
    UCHAR ISRCValid                 : 1;
    UCHAR ISRCCountry[2];
    UCHAR ISRCOwner[3];
    UCHAR ISRCRecordingYear[2];
    UCHAR ISRCSerialNumber[5];
    UCHAR ISRCZero;
    UCHAR ISRCAFrame;
    UCHAR ISRCReserved;
    UCHAR SubHeaderData[4];
} MODE_CDROM_WRITE_PARAMETERS_PAGE, *PMODE_CDROM_WRITE_PARAMETERS_PAGE;
#pragma pack(pop, mode_page_wp)
#endif //ifndef DEPRECATE_DDK_FUNCTIONS

//
// Define the MRW mode page for CDROM device types
//
#pragma pack(push, mode_page_mrw, 1)
typedef struct _MODE_MRW_PAGE {
    UCHAR PageCode : 6; // 0x03
    UCHAR Reserved : 1;
    UCHAR PageSavable : 1;
    UCHAR PageLength;   //0x06
    UCHAR Reserved1;
    UCHAR LbaSpace  : 1;
    UCHAR Reserved2 : 7;
    UCHAR Reserved3[4];
} MODE_MRW_PAGE, *PMODE_MRW_PAGE;
#pragma pack(pop, mode_page_mrw)

//
// Define mode flexible disk page.
//

#pragma pack(push, mode_page_flex, 1)
typedef struct _MODE_FLEXIBLE_DISK_PAGE {
    UCHAR PageCode : 6;
    UCHAR Reserved : 1;
    UCHAR PageSavable : 1;
    UCHAR PageLength;
    UCHAR TransferRate[2];
    UCHAR NumberOfHeads;
    UCHAR SectorsPerTrack;
    UCHAR BytesPerSector[2];
    UCHAR NumberOfCylinders[2];
    UCHAR StartWritePrecom[2];
    UCHAR StartReducedCurrent[2];
    UCHAR StepRate[2];
    UCHAR StepPluseWidth;
    UCHAR HeadSettleDelay[2];
    UCHAR MotorOnDelay;
    UCHAR MotorOffDelay;
    UCHAR Reserved2 : 5;
    UCHAR MotorOnAsserted : 1;
    UCHAR StartSectorNumber : 1;
    UCHAR TrueReadySignal : 1;
    UCHAR StepPlusePerCyclynder : 4;
    UCHAR Reserved3 : 4;
    UCHAR WriteCompenstation;
    UCHAR HeadLoadDelay;
    UCHAR HeadUnloadDelay;
    UCHAR Pin2Usage : 4;
    UCHAR Pin34Usage : 4;
    UCHAR Pin1Usage : 4;
    UCHAR Pin4Usage : 4;
    UCHAR MediumRotationRate[2];
    UCHAR Reserved4[2];
} MODE_FLEXIBLE_DISK_PAGE, *PMODE_FLEXIBLE_DISK_PAGE;
#pragma pack(pop, mode_page_flex)

//
// Define mode format page.
//

#pragma pack(push, mode_page_format, 1)
typedef struct _MODE_FORMAT_PAGE {
    UCHAR PageCode : 6;
    UCHAR Reserved : 1;
    UCHAR PageSavable : 1;
    UCHAR PageLength;
    UCHAR TracksPerZone[2];
    UCHAR AlternateSectorsPerZone[2];
    UCHAR AlternateTracksPerZone[2];
    UCHAR AlternateTracksPerLogicalUnit[2];
    UCHAR SectorsPerTrack[2];
    UCHAR BytesPerPhysicalSector[2];
    UCHAR Interleave[2];
    UCHAR TrackSkewFactor[2];
    UCHAR CylinderSkewFactor[2];
    UCHAR Reserved2 : 4;
    UCHAR SurfaceFirst : 1;
    UCHAR RemovableMedia : 1;
    UCHAR HardSectorFormating : 1;
    UCHAR SoftSectorFormating : 1;
    UCHAR Reserved3[3];
} MODE_FORMAT_PAGE, *PMODE_FORMAT_PAGE;
#pragma pack(pop, mode_page_format)

//
// Define rigid disk driver geometry page.
//

#pragma pack(push, mode_page_geometry, 1)
typedef struct _MODE_RIGID_GEOMETRY_PAGE {
    UCHAR PageCode : 6;
    UCHAR Reserved : 1;
    UCHAR PageSavable : 1;
    UCHAR PageLength;
    UCHAR NumberOfCylinders[3];
    UCHAR NumberOfHeads;
    UCHAR StartWritePrecom[3];
    UCHAR StartReducedCurrent[3];
    UCHAR DriveStepRate[2];
    UCHAR LandZoneCyclinder[3];
    UCHAR RotationalPositionLock : 2;
    UCHAR Reserved2 : 6;
    UCHAR RotationOffset;
    UCHAR Reserved3;
    UCHAR RoataionRate[2];
    UCHAR Reserved4[2];
}MODE_RIGID_GEOMETRY_PAGE, *PMODE_RIGID_GEOMETRY_PAGE;
#pragma pack(pop, mode_page_geometry)

//
// Define read write recovery page
//

#pragma pack(push, mode_page_rw_recovery, 1)
typedef struct _MODE_READ_WRITE_RECOVERY_PAGE {

    UCHAR PageCode : 6;
    UCHAR Reserved1 : 1;
    UCHAR PSBit : 1;
    UCHAR PageLength;
    UCHAR DCRBit : 1;
    UCHAR DTEBit : 1;
    UCHAR PERBit : 1;
    UCHAR EERBit : 1;
    UCHAR RCBit : 1;
    UCHAR TBBit : 1;
    UCHAR ARRE : 1;
    UCHAR AWRE : 1;
    UCHAR ReadRetryCount;
    UCHAR Reserved4[4];
    UCHAR WriteRetryCount;
    UCHAR Reserved5[3];

} MODE_READ_WRITE_RECOVERY_PAGE, *PMODE_READ_WRITE_RECOVERY_PAGE;
#pragma pack(pop, mode_page_rw_recovery)

//
// Define read recovery page - cdrom
//

#pragma pack(push, mode_page_r_recovery, 1)
typedef struct _MODE_READ_RECOVERY_PAGE {

    UCHAR PageCode : 6;
    UCHAR Reserved1 : 1;
    UCHAR PSBit : 1;
    UCHAR PageLength;
    UCHAR DCRBit : 1;
    UCHAR DTEBit : 1;
    UCHAR PERBit : 1;
    UCHAR Reserved2 : 1;
    UCHAR RCBit : 1;
    UCHAR TBBit : 1;
    UCHAR Reserved3 : 2;
    UCHAR ReadRetryCount;
    UCHAR Reserved4[4];

} MODE_READ_RECOVERY_PAGE, *PMODE_READ_RECOVERY_PAGE;
#pragma pack(pop, mode_page_r_recovery)


//
// Define Informational Exception Control Page. Used for failure prediction
//

#pragma pack(push, mode_page_xcpt, 1)
typedef struct _MODE_INFO_EXCEPTIONS
{
    UCHAR PageCode : 6;
    UCHAR Reserved1 : 1;
    UCHAR PSBit : 1;

    UCHAR PageLength;

    union
    {
        UCHAR Flags;
        struct
        {
            UCHAR LogErr : 1;
            UCHAR Reserved2 : 1;
            UCHAR Test : 1;
            UCHAR Dexcpt : 1;
            UCHAR Reserved3 : 3;
            UCHAR Perf : 1;
        };
    };

    UCHAR ReportMethod : 4;
    UCHAR Reserved4 : 4;

    UCHAR IntervalTimer[4];
    UCHAR ReportCount[4];

} MODE_INFO_EXCEPTIONS, *PMODE_INFO_EXCEPTIONS;
#pragma pack(pop, mode_page_xcpt)

//
// Begin C/DVD 0.9 definitions
//

//
// Power Condition Mode Page Format
//

#pragma pack(push, mode_page_power, 1)
typedef struct _POWER_CONDITION_PAGE {
    UCHAR PageCode : 6;         // 0x1A
    UCHAR Reserved : 1;
    UCHAR PSBit : 1;
    UCHAR PageLength;           // 0x0A
    UCHAR Reserved2;

    UCHAR Standby : 1;
    UCHAR Idle : 1;
    UCHAR Reserved3 : 6;

    UCHAR IdleTimer[4];
    UCHAR StandbyTimer[4];
} POWER_CONDITION_PAGE, *PPOWER_CONDITION_PAGE;
#pragma pack(pop, mode_page_power)

//
// CD-Audio Control Mode Page Format
//

#pragma pack(push, mode_page_cdaudio, 1)
typedef struct _CDDA_OUTPUT_PORT {
    UCHAR ChannelSelection : 4;
    UCHAR Reserved : 4;
    UCHAR Volume;
} CDDA_OUTPUT_PORT, *PCDDA_OUTPUT_PORT;

typedef struct _CDAUDIO_CONTROL_PAGE {
    UCHAR PageCode : 6;     // 0x0E
    UCHAR Reserved : 1;
    UCHAR PSBit : 1;

    UCHAR PageLength;       // 0x0E

    UCHAR Reserved2 : 1;
    UCHAR StopOnTrackCrossing : 1;         // Default 0
    UCHAR Immediate : 1;    // Always 1
    UCHAR Reserved3 : 5;

    UCHAR Reserved4[3];
    UCHAR Obsolete[2];

    CDDA_OUTPUT_PORT CDDAOutputPorts[4];

} CDAUDIO_CONTROL_PAGE, *PCDAUDIO_CONTROL_PAGE;
#pragma pack(pop, mode_page_cdaudio)

#define CDDA_CHANNEL_MUTED      0x0
#define CDDA_CHANNEL_ZERO       0x1
#define CDDA_CHANNEL_ONE        0x2
#define CDDA_CHANNEL_TWO        0x4
#define CDDA_CHANNEL_THREE      0x8

//
// C/DVD Feature Set Support & Version Page
//

#pragma pack(push, mode_page_features, 1)
typedef struct _CDVD_FEATURE_SET_PAGE {
    UCHAR PageCode : 6;     // 0x18
    UCHAR Reserved : 1;
    UCHAR PSBit : 1;

    UCHAR PageLength;       // 0x16

    UCHAR CDAudio[2];
    UCHAR EmbeddedChanger[2];
    UCHAR PacketSMART[2];
    UCHAR PersistantPrevent[2];
    UCHAR EventStatusNotification[2];
    UCHAR DigitalOutput[2];
    UCHAR CDSequentialRecordable[2];
    UCHAR DVDSequentialRecordable[2];
    UCHAR RandomRecordable[2];
    UCHAR KeyExchange[2];
    UCHAR Reserved2[2];
} CDVD_FEATURE_SET_PAGE, *PCDVD_FEATURE_SET_PAGE;
#pragma pack(pop, mode_page_features)

//
// CDVD Inactivity Time-out Page Format
//

#pragma pack(push, mode_page_timeout, 1)
typedef struct _CDVD_INACTIVITY_TIMEOUT_PAGE {
    UCHAR PageCode : 6;     // 0x1D
    UCHAR Reserved : 1;
    UCHAR PSBit : 1;

    UCHAR PageLength;       // 0x08
    UCHAR Reserved2[2];

    UCHAR SWPP : 1;
    UCHAR DISP : 1;
    UCHAR Reserved3 : 6;

    UCHAR Reserved4;
    UCHAR GroupOneMinimumTimeout[2];
    UCHAR GroupTwoMinimumTimeout[2];
} CDVD_INACTIVITY_TIMEOUT_PAGE, *PCDVD_INACTIVITY_TIMEOUT_PAGE;
#pragma pack(pop, mode_page_timeout)

//
// CDVD Capabilities & Mechanism Status Page
//

#define CDVD_LMT_CADDY              0
#define CDVD_LMT_TRAY               1
#define CDVD_LMT_POPUP              2
#define CDVD_LMT_RESERVED1          3
#define CDVD_LMT_CHANGER_INDIVIDUAL 4
#define CDVD_LMT_CHANGER_CARTRIDGE  5
#define CDVD_LMT_RESERVED2          6
#define CDVD_LMT_RESERVED3          7


#pragma pack(push, mode_page_capabilities, 1)
typedef struct _CDVD_CAPABILITIES_PAGE {
    UCHAR PageCode : 6;     // 0x2A
    UCHAR Reserved : 1;
    UCHAR PSBit : 1;                        // offset 0

    UCHAR PageLength;       // >= 0x18      // offset 1

    UCHAR CDRRead : 1;
    UCHAR CDERead : 1;
    UCHAR Method2 : 1;
    UCHAR DVDROMRead : 1;
    UCHAR DVDRRead : 1;
    UCHAR DVDRAMRead : 1;
    UCHAR Reserved2 : 2;                    // offset 2

    UCHAR CDRWrite : 1;
    UCHAR CDEWrite : 1;
    UCHAR TestWrite : 1;
    UCHAR Reserved3 : 1;
    UCHAR DVDRWrite : 1;
    UCHAR DVDRAMWrite : 1;
    UCHAR Reserved4 : 2;                    // offset 3

    UCHAR AudioPlay : 1;
    UCHAR Composite : 1;
    UCHAR DigitalPortOne : 1;
    UCHAR DigitalPortTwo : 1;
    UCHAR Mode2Form1 : 1;
    UCHAR Mode2Form2 : 1;
    UCHAR MultiSession : 1;
    UCHAR BufferUnderrunFree : 1;                    // offset 4

    UCHAR CDDA : 1;
    UCHAR CDDAAccurate : 1;
    UCHAR RWSupported : 1;
    UCHAR RWDeinterleaved : 1;
    UCHAR C2Pointers : 1;
    UCHAR ISRC : 1;
    UCHAR UPC : 1;
    UCHAR ReadBarCodeCapable : 1;           // offset 5

    UCHAR Lock : 1;
    UCHAR LockState : 1;
    UCHAR PreventJumper : 1;
    UCHAR Eject : 1;
    UCHAR Reserved6 : 1;
    UCHAR LoadingMechanismType : 3;         // offset 6

    UCHAR SeparateVolume : 1;
    UCHAR SeperateChannelMute : 1;
    UCHAR SupportsDiskPresent : 1;
    UCHAR SWSlotSelection : 1;
    UCHAR SideChangeCapable : 1;
    UCHAR RWInLeadInReadable : 1;
    UCHAR Reserved7 : 2;                    // offset 7

    union {
        UCHAR ReadSpeedMaximum[2];
        UCHAR ObsoleteReserved[2];          // offset 8
    };

    UCHAR NumberVolumeLevels[2];            // offset 10
    UCHAR BufferSize[2];                    // offset 12

    union {
        UCHAR ReadSpeedCurrent[2];
        UCHAR ObsoleteReserved2[2];         // offset 14
    };
    UCHAR ObsoleteReserved3;                // offset 16

    UCHAR Reserved8 : 1;
    UCHAR BCK : 1;
    UCHAR RCK : 1;
    UCHAR LSBF : 1;
    UCHAR Length : 2;
    UCHAR Reserved9 : 2;                    // offset 17

    union {
        UCHAR WriteSpeedMaximum[2];
        UCHAR ObsoleteReserved4[2];         // offset 18
    };
    union {
        UCHAR WriteSpeedCurrent[2];
        UCHAR ObsoleteReserved11[2];        // offset 20
    };

    //
    // NOTE: This mode page is two bytes too small in the release
    //       version of the Windows2000 DDK.  it also incorrectly
    //       put the CopyManagementRevision at offset 20 instead
    //       of offset 22, so fix that with a nameless union (for
    //       backwards-compatibility with those who "fixed" it on
    //       their own by looking at Reserved10[]).
    //

    union {
        UCHAR CopyManagementRevision[2];    // offset 22
        UCHAR Reserved10[2];
    };
    //UCHAR Reserved12[2];                    // offset 24

} CDVD_CAPABILITIES_PAGE, *PCDVD_CAPABILITIES_PAGE;
#pragma pack(pop, mode_page_capabilities)

#pragma pack(push, lun_list, 1)
typedef struct _LUN_LIST {
    UCHAR LunListLength[4]; // sizeof LunSize * 8
    UCHAR Reserved[4];
#if !defined(__midl)
    UCHAR Lun[0][8];        // 4 level of addressing.  2 bytes each.
#endif
} LUN_LIST, *PLUN_LIST;
#pragma pack(pop, lun_list)


#define LOADING_MECHANISM_CADDY                 0x00
#define LOADING_MECHANISM_TRAY                  0x01
#define LOADING_MECHANISM_POPUP                 0x02
#define LOADING_MECHANISM_INDIVIDUAL_CHANGER    0x04
#define LOADING_MECHANISM_CARTRIDGE_CHANGER     0x05

//
// end C/DVD 0.9 mode page definitions

//
// Mode parameter list block descriptor -
// set the block length for reading/writing
//
//

#define MODE_BLOCK_DESC_LENGTH               8
#define MODE_HEADER_LENGTH                   4
#define MODE_HEADER_LENGTH10                 8

#pragma pack(push, mode_parm_rw, 1)
typedef struct _MODE_PARM_READ_WRITE {

   MODE_PARAMETER_HEADER  ParameterListHeader;  // List Header Format
   MODE_PARAMETER_BLOCK   ParameterListBlock;   // List Block Descriptor

} MODE_PARM_READ_WRITE_DATA, *PMODE_PARM_READ_WRITE_DATA;
#pragma pack(pop, mode_parm_rw)

// end_ntminitape

//
// CDROM audio control (0x0E)
//

#define CDB_AUDIO_PAUSE 0
#define CDB_AUDIO_RESUME 1

#define CDB_DEVICE_START 0x11
#define CDB_DEVICE_STOP 0x10

#define CDB_EJECT_MEDIA 0x10
#define CDB_LOAD_MEDIA 0x01

#define CDB_SUBCHANNEL_HEADER      0x00
#define CDB_SUBCHANNEL_BLOCK       0x01

#define CDROM_AUDIO_CONTROL_PAGE   0x0E
#define MODE_SELECT_IMMEDIATE      0x04
#define MODE_SELECT_PFBIT          0x10

#define CDB_USE_MSF                0x01

#pragma pack(push, audio_output, 1)
typedef struct _PORT_OUTPUT {
    UCHAR ChannelSelection;
    UCHAR Volume;
} PORT_OUTPUT, *PPORT_OUTPUT;

typedef struct _AUDIO_OUTPUT {
    UCHAR CodePage;
    UCHAR ParameterLength;
    UCHAR Immediate;
    UCHAR Reserved[2];
    UCHAR LbaFormat;
    UCHAR LogicalBlocksPerSecond[2];
    PORT_OUTPUT PortOutput[4];
} AUDIO_OUTPUT, *PAUDIO_OUTPUT;
#pragma pack(pop, audio_output)

//
// Multisession CDROM
//

#define GET_LAST_SESSION 0x01
#define GET_SESSION_DATA 0x02;

//
// Atapi 2.5 changer
//

#pragma pack(push, chgr_stuff, 1)
typedef struct _MECHANICAL_STATUS_INFORMATION_HEADER {
    UCHAR CurrentSlot : 5;
    UCHAR ChangerState : 2;
    UCHAR Fault : 1;
    UCHAR Reserved : 5;
    UCHAR MechanismState : 3;
    UCHAR CurrentLogicalBlockAddress[3];
    UCHAR NumberAvailableSlots;
    UCHAR SlotTableLength[2];
} MECHANICAL_STATUS_INFORMATION_HEADER, *PMECHANICAL_STATUS_INFORMATION_HEADER;

typedef struct _SLOT_TABLE_INFORMATION {
    UCHAR DiscChanged : 1;
    UCHAR Reserved : 6;
    UCHAR DiscPresent : 1;
    UCHAR Reserved2[3];
} SLOT_TABLE_INFORMATION, *PSLOT_TABLE_INFORMATION;

typedef struct _MECHANICAL_STATUS {
    MECHANICAL_STATUS_INFORMATION_HEADER MechanicalStatusHeader;
    SLOT_TABLE_INFORMATION SlotTableInfo[1];
} MECHANICAL_STATUS, *PMECHANICAL_STATUS;
#pragma pack(pop, chgr_stuff)


// begin_ntminitape

//
// Tape definitions
//

#pragma pack(push, tape_position, 1)
typedef struct _TAPE_POSITION_DATA {
    UCHAR Reserved1:2;
    UCHAR BlockPositionUnsupported:1;
    UCHAR Reserved2:3;
    UCHAR EndOfPartition:1;
    UCHAR BeginningOfPartition:1;
    UCHAR PartitionNumber;
    USHORT Reserved3;
    UCHAR FirstBlock[4];
    UCHAR LastBlock[4];
    UCHAR Reserved4;
    UCHAR NumberOfBlocks[3];
    UCHAR NumberOfBytes[4];
} TAPE_POSITION_DATA, *PTAPE_POSITION_DATA;
#pragma pack(pop, tape_position)

//
// This structure is used to convert little endian
// ULONGs to SCSI CDB big endians values.
//

#pragma pack(push, byte_stuff, 1)
typedef union _EIGHT_BYTE {

    struct {
        UCHAR Byte0;
        UCHAR Byte1;
        UCHAR Byte2;
        UCHAR Byte3;
        UCHAR Byte4;
        UCHAR Byte5;
        UCHAR Byte6;
        UCHAR Byte7;
    };

    ULONGLONG AsULongLong;
} EIGHT_BYTE, *PEIGHT_BYTE;

typedef union _FOUR_BYTE {

    struct {
        UCHAR Byte0;
        UCHAR Byte1;
        UCHAR Byte2;
        UCHAR Byte3;
    };

    ULONG AsULong;
} FOUR_BYTE, *PFOUR_BYTE;

typedef union _TWO_BYTE {

    struct {
        UCHAR Byte0;
        UCHAR Byte1;
    };

    USHORT AsUShort;
} TWO_BYTE, *PTWO_BYTE;
#pragma pack(pop, byte_stuff)

//
// Byte reversing macro for converting
// between big- and little-endian formats
//

#define REVERSE_BYTES_QUAD(Destination, Source) {           \
    PEIGHT_BYTE d = (PEIGHT_BYTE)(Destination);             \
    PEIGHT_BYTE s = (PEIGHT_BYTE)(Source);                  \
    d->Byte7 = s->Byte0;                                    \
    d->Byte6 = s->Byte1;                                    \
    d->Byte5 = s->Byte2;                                    \
    d->Byte4 = s->Byte3;                                    \
    d->Byte3 = s->Byte4;                                    \
    d->Byte2 = s->Byte5;                                    \
    d->Byte1 = s->Byte6;                                    \
    d->Byte0 = s->Byte7;                                    \
}

#define REVERSE_BYTES(Destination, Source) {                \
    PFOUR_BYTE d = (PFOUR_BYTE)(Destination);               \
    PFOUR_BYTE s = (PFOUR_BYTE)(Source);                    \
    d->Byte3 = s->Byte0;                                    \
    d->Byte2 = s->Byte1;                                    \
    d->Byte1 = s->Byte2;                                    \
    d->Byte0 = s->Byte3;                                    \
}

#define REVERSE_BYTES_SHORT(Destination, Source) {          \
    PTWO_BYTE d = (PTWO_BYTE)(Destination);                 \
    PTWO_BYTE s = (PTWO_BYTE)(Source);                      \
    d->Byte1 = s->Byte0;                                    \
    d->Byte0 = s->Byte1;                                    \
}

//
// Byte reversing macro for converting
// USHORTS from big to little endian in place
//

#define REVERSE_SHORT(Short) {          \
    UCHAR tmp;                          \
    PTWO_BYTE w = (PTWO_BYTE)(Short);   \
    tmp = w->Byte0;                     \
    w->Byte0 = w->Byte1;                \
    w->Byte1 = tmp;                     \
    }

//
// Byte reversing macro for convering
// ULONGS between big & little endian in place
//

#define REVERSE_LONG(Long) {            \
    UCHAR tmp;                          \
    PFOUR_BYTE l = (PFOUR_BYTE)(Long);  \
    tmp = l->Byte3;                     \
    l->Byte3 = l->Byte0;                \
    l->Byte0 = tmp;                     \
    tmp = l->Byte2;                     \
    l->Byte2 = l->Byte1;                \
    l->Byte1 = tmp;                     \
    }

//
// This macro has the effect of Bit = log2(Data)
//

#define WHICH_BIT(Data, Bit) {                      \
    UCHAR tmp;                                      \
    for (tmp = 0; tmp < 32; tmp++) {                \
        if (((Data) >> tmp) == 1) {                 \
            break;                                  \
        }                                           \
    }                                               \
    ASSERT(tmp != 32);                              \
    (Bit) = tmp;                                    \
}

// end_storport

// end_ntminitape

#pragma pack(pop, _scsi_) // restore original packing level

#if _MSC_VER >= 1200
#pragma warning(pop) // un-sets any local warning changes
#else
#pragma warning(default:4200) // array[0] is not a warning for this file
#pragma warning(default:4201) // nonstandard extension used : nameless struct/union
#endif


#endif // !defined _NTSCSI_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\sdv_driverspecs.h ===
#ifndef SDV
// general purpose save 
//-----------------------
#define	__sdv_save_request(r)
// general purpose retrieve 
//-----------------------
#define	__sdv_retrieve_request(r)
#else
// general purpose save 
//-----------------------
//#define	__sdv_save sdv_save
//void sdv_save(void *r){;}
// general purpose retrieve macros
//-----------------------
//#define	__sdv_retrieve sdv_retrieve
//void sdv_retrieve(void *r){;}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\sdpnode.h ===
#ifndef __SDPNODE_H__
#define __SDPNODE_H__

#if (NTDDI_VERSION >= NTDDI_VISTA)

#ifdef __cplusplus
extern "C" {
#endif


                             typedef UCHAR SDP_BOOLEAN;

typedef struct ISdpNodeContainer ISdpNodeContainer;

typedef struct _SDP_NODE_HEADER {
    LIST_ENTRY Link;
    USHORT Type;
    USHORT SpecificType;
} SDP_NODE_HEADER, *PSDP_NODE_HEADER;

typedef union _SDP_NODE_DATA {
    // the nil type contains no data, so no storage is necessary

    // 16 byte integers
    //
    // ISSUE is there a better way to represent a 16 byte int???
    //
    SDP_LARGE_INTEGER_16 int128;
    SDP_ULARGE_INTEGER_16 uint128;

    // UUID
    GUID uuid128;
    ULONG uuid32;
    USHORT uuid16;

    // 8 byte integers
    LONGLONG int64;
    ULONGLONG uint64;

    // 4 byte integers
    LONG int32;
    ULONG uint32;

    // 2 byte integers
    SHORT int16;
    USHORT uint16;

    // 1 bytes integers
    CHAR int8;
    UCHAR uint8;

    // Boolean
    SDP_BOOLEAN boolean;

    // string
    PCHAR string;

    // URL
    PCHAR url;

    // Sequence
	SDP_NODE_HEADER sequence;

    // Alt list
    SDP_NODE_HEADER alternative;

    ISdpNodeContainer *container;

    struct {
        PUCHAR stream;
        ULONG streamLength;
    };

} SDP_NODE_DATA, *PSDP_NODE_DATA;

typedef struct _SDP_NODE {
	SDP_NODE_HEADER  hdr;

    ULONG DataSize;

	SDP_NODE_DATA u;

	PVOID Reserved;
} SDP_NODE, *PSDP_NODE;

typedef struct _SDP_TREE_ROOT_NODE {
    SDP_NODE RootNode;
} SDP_TREE_ROOT_NODE, *PSDP_TREE_ROOT_NODE;





#ifdef __cplusplus
}
#endif

#endif // (NTDDI_VERSION >= NTDDI_VISTA)

#endif // __SDPNODE_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\sdplib.h ===
#ifndef __SDPLIB_H__
#define __SDPLIB_H__

#ifdef __cplusplus
extern "C" {
#endif

#include "sdpnode.h"

#ifndef NTSTATUS
typedef LONG NTSTATUS;
#endif

#ifdef _NTDDK_
#define SDPLIB_KERNEL
#endif

#ifdef SDPLIB_KERNEL
PSDP_TREE_ROOT_NODE
SdpCreateNodeTree(
    ULONG tag
    );

PSDP_NODE
SdpCreateNodeNil(
    ULONG tag
    );

PSDP_NODE
SdpCreateNodeUInt128(
    PSDP_ULARGE_INTEGER_16 puli16Val,
    ULONG tag
    );

PSDP_NODE
SdpCreateNodeUInt64(
    ULONGLONG ullVal,
    ULONG tag
    );

PSDP_NODE
SdpCreateNodeUInt32(
    ULONG ulVal,
    ULONG tag
    );

PSDP_NODE
SdpCreateNodeUInt16(
    USHORT usVal,
    ULONG tag
    );

PSDP_NODE
SdpCreateNodeUInt8(
    UCHAR ucVal,
    ULONG tag
    );

PSDP_NODE
SdpCreateNodeInt128(
    PSDP_LARGE_INTEGER_16 uil16Val,
    ULONG tag
    );

PSDP_NODE
SdpCreateNodeInt64(
    LONGLONG llVal,
    ULONG tag
    );

PSDP_NODE
SdpCreateNodeInt32(
    LONG lVal,
    ULONG tag
    );

PSDP_NODE
SdpCreateNodeInt16(
    SHORT sVal,
    ULONG tag
    );

PSDP_NODE
SdpCreateNodeInt8(
    CHAR cVal,
    ULONG tag
    );

PSDP_NODE
SdpCreateNodeUUID128(
    const GUID *uuid,
    ULONG tag
    );

PSDP_NODE
SdpCreateNodeUUID32(
    ULONG uuidVal4,
    ULONG tag
    );

PSDP_NODE
SdpCreateNodeUUID16(
    USHORT uuidVal2,
    ULONG tag
    );

PSDP_NODE
SdpCreateNodeBoolean(
    SDP_BOOLEAN  bVal,
    ULONG tag
    );

PSDP_NODE
SdpCreateNodeSequence(
    ULONG tag
    );

PSDP_NODE
SdpCreateNodeAlternative(
    ULONG tag
    );

PSDP_NODE
SdpCreateNodeUrl(
    __in_bcount(UrlLength) PCHAR url,
    __in_bound ULONG urlLength,
    ULONG tag
    );

NTSTATUS
SdpAddAttributeToTree(
    PSDP_TREE_ROOT_NODE Tree,
    USHORT AttribId,
    PSDP_NODE AttribValue,
    ULONG tag
    );

PSDP_NODE
SdpCreateNodeString(
    __in_bcount(StringLength) PCHAR string, 
    __in_bound ULONG stringLength, 
    ULONG tag
    );

#else //SDPLIB_KERNEL

PSDP_TREE_ROOT_NODE
SdpCreateNodeTree();

PSDP_NODE
SdpCreateNodeNil();

PSDP_NODE
SdpCreateNodeUInt128(
    PSDP_ULARGE_INTEGER_16 puli16Val
    );

PSDP_NODE
SdpCreateNodeUInt64(
    ULONGLONG ullVal
    );

PSDP_NODE
SdpCreateNodeUInt32(
    ULONG ulVal
    );

PSDP_NODE
SdpCreateNodeUInt16(
    USHORT usVal
    );

PSDP_NODE
SdpCreateNodeUInt8(
    UCHAR ucVal
    );

PSDP_NODE
SdpCreateNodeInt128(
    PSDP_LARGE_INTEGER_16 uil16Val
    );

PSDP_NODE
SdpCreateNodeInt64(
    LONGLONG llVal
    );

PSDP_NODE
SdpCreateNodeInt32(
    LONG lVal
    );

PSDP_NODE
SdpCreateNodeInt16(
    SHORT sVal
    );

PSDP_NODE
SdpCreateNodeInt8(
    CHAR cVal
    );

PSDP_NODE
SdpCreateNodeUUID128(
    const GUID *uuid
    );

PSDP_NODE
SdpCreateNodeUUID32(
    ULONG uuidVal4
    );

PSDP_NODE
SdpCreateNodeUUID16(
    USHORT uuidVal2
    );

PSDP_NODE
SdpCreateNodeBoolean(
    SDP_BOOLEAN  bVal
    );

PSDP_NODE
SdpCreateNodeSequence();

PSDP_NODE
SdpCreateNodeAlternative();

PSDP_NODE
SdpCreateNodeUrl(
    __in_bcount(UrlLength) PCHAR url,
    __in_bound ULONG urlLength
    );

NTSTATUS
SdpAddAttributeToTree(
    PSDP_TREE_ROOT_NODE Tree,
    USHORT AttribId,
    PSDP_NODE AttribValue
    );

PSDP_NODE
SdpCreateNodeString(
    __in_bcount(StringLength) PCHAR string, 
    __in_bound ULONG stringLength
    );

#endif //SDPLIB_KERNEL

NTSTATUS
SdpFreeTree(
    PSDP_TREE_ROOT_NODE Tree
    );
    
#define   SdpCreateNodeUUID SdpCreateNodeUUID128

NTSTATUS
SdpAppendNodeToContainerNode(
    PSDP_NODE Parent,
    PSDP_NODE Node
    );

NTSTATUS
SdpFindAttributeInTree(
    PSDP_TREE_ROOT_NODE Tree,
    USHORT AttribId,
    PSDP_NODE *Attribute
    );

#ifdef __cplusplus
};
#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\scsiwmi.h ===
/*++ BUILD Version: 0000    // Increment this if a change has global effects

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    scsiwmi.h

Abstract:

    This module contains the internal structure definitions and APIs used by
    the SCSI WMILIB helper functions


Revision History:


--*/

#ifndef _SCSIWMI_
#define _SCSIWMI_

#if defined (_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

//
// This is a per-request context buffer that is needed for every wmi srb.
// The request context must remain valid throughout the entire processing
// of the srb, at least until ScsiPortWmiPostProcess returns with the
// final srb return status and buffer size. If the srb can
// pend then memory for this buffer should be allocated from the SRB
// extension. If not then the memory can be allocated from a stack frame that
// does not go out of scope.
//
typedef struct
{
    PVOID UserContext;  // Available for miniport use
		
    ULONG BufferSize;   // Reserved for SCSIWMI use
    PUCHAR Buffer;      // Reserved for SCSIWMI use
    UCHAR MinorFunction;// Reserved for SCSIWMI use
	
    UCHAR ReturnStatus; // Available to miniport after ScsiPortWmiPostProcess
    ULONG ReturnSize;   // Available to miniport after ScsiPortWmiPostProcess
	
} SCSIWMI_REQUEST_CONTEXT, *PSCSIWMI_REQUEST_CONTEXT;


#define ScsiPortWmiGetReturnStatus(RequestContext) ((RequestContext)->ReturnStatus)
#define ScsiPortWmiGetReturnSize(RequestContext) ((RequestContext)->ReturnSize)

//
// This defines a guid to be registered with WMI.
//
typedef struct
{
    LPCGUID Guid;            // Guid representing data block
    ULONG InstanceCount;     // Count of Instances of Datablock. If
	                         // this count is 0xffffffff then the guid
	                         // is assumed to be dynamic instance names
    ULONG Flags;             // Additional flags (see WMIREGINFO in wmistr.h)
} SCSIWMIGUIDREGINFO, *PSCSIWMIGUIDREGINFO;

//
// If this is set then the guid is registered as having dynamic
// instance names.
//
#define WMIREG_FLAG_CALL_BY_NAME 0x40000000

typedef
UCHAR
(*PSCSIWMI_QUERY_REGINFO) (
    IN PVOID DeviceContext,
    IN PSCSIWMI_REQUEST_CONTEXT RequestContext,
    OUT PWCHAR *MofResourceName
    );
/*++

Routine Description:

    This routine is a callback into the miniport to retrieve information about
    the guids being registered.

    This callback is synchronous and may not be pended. Also
	ScsiPortWmiPostProcess should not be called from within this callback.

Arguments:

    DeviceContext is a caller specified context value originally passed to
        ScsiPortWmiDispatchFunction.

    RequestContext is a context associated with the srb being processed.

    MofResourceName returns with a pointer to a WCHAR string with name of
        the MOF resource attached to the miniport binary image file. If
        the driver does not have a mof resource attached then this can
        be returned as NULL.

Return Value:

    TRUE if request is pending else FALSE

--*/

typedef
BOOLEAN
(*PSCSIWMI_QUERY_DATABLOCK) (
    IN PVOID Context,
    IN PSCSIWMI_REQUEST_CONTEXT DispatchContext,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG InstanceCount,
    IN OUT PULONG InstanceLengthArray,
    IN ULONG BufferAvail,
    OUT PUCHAR Buffer
    );
/*++

Routine Description:

    This routine is a callback into the miniport to query for the contents of
    one or more instances of a data block. This callback may be called with
    an output buffer that is too small to return all of the data queried.
    In this case the callback is responsible to report the correct output
	buffer size needed.

    If the request can be completed immediately without pending,
	ScsiPortWmiPostProcess should be called from within this callback and
    FALSE returned.
		
    If the request cannot be completed within this callback then TRUE should
    be returned. Once the pending operations are finished the miniport should
    call ScsiPortWmiPostProcess and then complete the srb.

Arguments:

    DeviceContext is a caller specified context value originally passed to
        ScsiPortWmiDispatchFunction.

    RequestContext is a context associated with the srb being processed.

    GuidIndex is the index into the list of guids provided when the
        miniport registered

    InstanceIndex is the index that denotes first instance of the data block
        is being queried.

    InstanceCount is the number of instances expected to be returned for
        the data block.

    InstanceLengthArray is a pointer to an array of ULONG that returns the
        lengths of each instance of the data block. This may be NULL when
        there is not enough space in the output buffer to fufill the request.
        In this case the miniport should call ScsiPortWmiPostProcess with
        a status of SRB_STATUS_DATA_OVERRUN and the size of the output buffer
        needed to fufill the request.

    BufferAvail on entry has the maximum size available to write the data
        blocks in the output buffer. If the output buffer is not large enough
        to return all of the data blocks then the miniport should call
        ScsiPortWmiPostProcess with a status of SRB_STATUS_DATA_OVERRUN
        and the size of the output buffer needed to fufill the request.

    Buffer on return is filled with the returned data blocks. Note that each
        instance of the data block must be aligned on a 8 byte boundry. This
        may be NULL when there is not enough space in the output buffer to
        fufill the request. In this case the miniport should call
        ScsiPortWmiPostProcess with a status of SRB_STATUS_DATA_OVERRUN and
        the size of the output buffer needed to fufill the request.


Return Value:

    TRUE if request is pending else FALSE

--*/

typedef
BOOLEAN
(*PSCSIWMI_SET_DATABLOCK) (
    IN PVOID DeviceContext,
    IN PSCSIWMI_REQUEST_CONTEXT RequestContext,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG BufferSize,
    IN PUCHAR Buffer
    );
/*++

Routine Description:

    This routine is a callback into the miniport to set the contents of an
    entire instance of a data block.

    If the request can be completed immediately without pending,
	ScsiPortWmiPostProcess should be called from within this callback and
    FALSE returned.
		
    If the request cannot be completed within this callback then TRUE should
    be returned. Once the pending operations are finished the miniport should
    call ScsiPortWmiPostProcess and then complete the srb.

Arguments:

    DeviceContext is a caller specified context value originally passed to
        ScsiPortWmiDispatchFunction.

    RequestContext is a context associated with the srb being processed.

    GuidIndex is the index into the list of guids provided when the
        miniport registered

    InstanceIndex is the index that denotes which instance of the data block
        is being set.

    BufferSize has the size of the data block passed

    Buffer has the new values for the data block


Return Value:

    TRUE if request is pending else FALSE

--*/

typedef
BOOLEAN
(*PSCSIWMI_SET_DATAITEM) (
    IN PVOID DeviceContext,
    IN PSCSIWMI_REQUEST_CONTEXT RequestContext,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG DataItemId,
    IN ULONG BufferSize,
    IN PUCHAR Buffer
    );
/*++

Routine Description:

    This routine is a callback into the miniport to set a single data item
    in a single instance of a data block.

    If the request can be completed immediately without pending,
	ScsiPortWmiPostProcess should be called from within this callback and
    FALSE returned.
		
    If the request cannot be completed within this callback then TRUE should
    be returned. Once the pending operations are finished the miniport should
    call ScsiPortWmiPostProcess and then complete the srb.

Arguments:

    DeviceContext is a caller specified context value originally passed to
        ScsiPortWmiDispatchFunction.

    RequestContext is a context associated with the srb being processed.

    GuidIndex is the index into the list of guids provided when the
        miniport registered

    InstanceIndex is the index that denotes which instance of the data block
        is being set.

    DataItemId has the id of the data item being set

    BufferSize has the size of the data item passed

    Buffer has the new values for the data item


Return Value:

    TRUE if request is pending else FALSE

--*/

typedef
BOOLEAN
(*PSCSIWMI_EXECUTE_METHOD) (
    IN PVOID DeviceContext,
    IN PSCSIWMI_REQUEST_CONTEXT RequestContext,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG MethodId,
    IN ULONG InBufferSize,
    IN ULONG OutBufferSize,
    IN OUT PUCHAR Buffer
    );
/*++

Routine Description:

    This routine is a callback into the miniport to execute a method.

    If the request can be completed immediately without pending,
	ScsiPortWmiPostProcess should be called from within this callback and
    FALSE returned.
		
    If the request cannot be completed within this callback then TRUE should
    be returned. Once the pending operations are finished the miniport should
    call ScsiPortWmiPostProcess and then complete the srb.

Arguments:

    Context is a caller specified context value originally passed to
        ScsiPortWmiDispatchFunction.

    RequestContext is a context associated with the srb being processed.

    GuidIndex is the index into the list of guids provided when the
        miniport registered

    InstanceIndex is the index that denotes which instance of the data block
        is being called.

    MethodId has the id of the method being called

    InBufferSize has the size of the data block passed in as the input to
        the method.

    OutBufferSize on entry has the maximum size available to write the
        returned data block. If the output buffer is not large enough
        to return all of the data blocks then the miniport should call
        ScsiPortWmiPostProcess with a status of SRB_STATUS_DATA_OVERRUN
        and the size of the output buffer needed to fufill the request.
        It is important to check that there is sufficient room in the
        output buffer before performing any operations that may have
        side effects.

    Buffer on entry has the input data block and on return has the output
        output data block.


Return Value:

    TRUE if request is pending else FALSE

--*/

typedef enum
{
    ScsiWmiEventControl,       // Enable or disable an event
    ScsiWmiDataBlockControl    // Enable or disable data block collection
} SCSIWMI_ENABLE_DISABLE_CONTROL;

typedef
BOOLEAN
(*PSCSIWMI_FUNCTION_CONTROL) (
    IN PVOID DeviceContext,
    IN PSCSIWMI_REQUEST_CONTEXT RequestContext,
    IN ULONG GuidIndex,
    IN SCSIWMI_ENABLE_DISABLE_CONTROL Function,
    IN BOOLEAN Enable
    );
/*++

Routine Description:

    This routine is a callback into the miniport to enabled or disable event
    generation or data block collection. Since WMI manages reference counting
    for each of the data blocks or events, a miniport should only expect a
	single enable followed by a single disable. Data blocks will only
    receive collection enable/disable if they were registered as requiring
    it, that is include the WMIREG_FLAG_EXPENSIVE flag.

    If the request can be completed immediately without pending,
	ScsiPortWmiPostProcess should be called from within this callback and
    FALSE returned.
		
    If the request cannot be completed within this callback then TRUE should
    be returned. Once the pending operations are finished the miniport should
    call ScsiPortWmiPostProcess and then complete the srb.

Arguments:

    DeviceContext is a caller specified context value originally passed to
        ScsiPortWmiDispatchFunction.

    RequestContext is a context associated with the srb being processed.

    Function specifies which functionality is being enabled or disabled

    Enable is TRUE then the function is being enabled else disabled

Return Value:

    TRUE if request is pending else FALSE

--*/

//
// This structure supplies context information for SCSIWMILIB to process the
// WMI srbs.
//
typedef struct _SCSIWMILIB_CONTEXT
{
    //
    // WMI data block guid registration info
    ULONG GuidCount;
    PSCSIWMIGUIDREGINFO GuidList;

    //
    // WMI functionality callbacks
    PSCSIWMI_QUERY_REGINFO       QueryWmiRegInfo;
    PSCSIWMI_QUERY_DATABLOCK     QueryWmiDataBlock;
    PSCSIWMI_SET_DATABLOCK       SetWmiDataBlock;
    PSCSIWMI_SET_DATAITEM        SetWmiDataItem;
    PSCSIWMI_EXECUTE_METHOD      ExecuteWmiMethod;
    PSCSIWMI_FUNCTION_CONTROL    WmiFunctionControl;
} SCSI_WMILIB_CONTEXT, *PSCSI_WMILIB_CONTEXT;

VOID
ScsiPortWmiPostProcess(
    IN PSCSIWMI_REQUEST_CONTEXT RequestContext,
    IN UCHAR SrbStatus,
    IN ULONG BufferUsed
    );
/*++

Routine Description:


    This routine will do the work of post-processing a WMI srb.

Arguments:

    RequestContext is a context associated with the srb being processed. After
        this api returns the ReturnStatus and ReturnSize fields are updated.

    SrbStatus has the return status code for the srb. If a query or method
        callback was passed an output buffer that was not large enough
        then SrbStatus should be SRB_STATUS_DATA_OVERRUN and BufferUsed
        should be the number of bytes needed in the output buffer.

    BufferUsed has the number of bytes required by the miniport to return the
       data requested in the WMI srb. If SRB_STATUS_DATA_OVERRUN was passed
       in SrbStatus then BufferUsed has the number of needed in the output
       buffer. If SRB_STATUS_SUCCESS is passed in SrbStatus then BufferUsed
       has the actual number of bytes used in the output buffer.

Return Value:


--*/

BOOLEAN
ScsiPortWmiDispatchFunction(
    IN PSCSI_WMILIB_CONTEXT WmiLibInfo,
    IN UCHAR MinorFunction,
    IN PVOID DeviceContext,
    IN PSCSIWMI_REQUEST_CONTEXT RequestContext,
    IN PVOID DataPath,
    IN ULONG BufferSize,
    IN PVOID Buffer
    );
/*++

Routine Description:

    Dispatch helper routine for WMI srb requests. Based on the Minor
    function passed the WMI request is processed and this routine
    invokes the appropriate callback in the WMILIB structure.

Arguments:

    WmiLibInfo has the SCSI WMILIB information control block associated
        with the adapter or logical unit

    DeviceContext is miniport defined context value passed on to the callbacks
        invoked by this api.

    RequestContext is a pointer to a context structure that maintains
        information about this WMI srb. This request context must remain
        valid throughout the entire processing of the srb, at least until
        ScsiPortWmiPostProcess returns with the final srb return status and
        buffer size. If the srb can pend then memory for this buffer should
        be allocated from the SRB extension. If not then the memory can be
        allocated from a stack frame that does not go out of scope, perhaps
        that of the caller to this api.

    DataPath is value passed in wmi request

    BufferSize is value passed in wmi request

    Buffer is value passed in wmi request

Return Value:

    TRUE if request is pending else FALSE

--*/

#define ScsiPortWmiFireAdapterEvent(    \
    HwDeviceExtension,                  \
    Guid,                               \
    InstanceIndex,                      \
    EventDataSize,                      \
    EventData                           \
    )                                   \
        ScsiPortWmiFireLogicalUnitEvent(\
    HwDeviceExtension,                  \
    0xff,                               \
    0,                                  \
    0,                                  \
    Guid,                               \
    InstanceIndex,                      \
    EventDataSize,                      \
    EventData)
/*++

Routine Description:

    This routine will fire a WMI event associated with an adapter using
    the data buffer passed. This routine may be called at or below DPC level.

Arguments:

    HwDeviceExtension is the adapter device extension

    Guid is pointer to the GUID that represents the event

    InstanceIndex is the index of the instance of the event

    EventDataSize is the number of bytes of data that is being fired with
       with the event. This size specifies the size of the event data only
       and does NOT include the 0x40 bytes of preceeding padding.

    EventData is the data that is fired with the events. There must be exactly
        0x40 bytes of padding preceeding the event data.

Return Value:

--*/

VOID
ScsiPortWmiFireLogicalUnitEvent(
    IN PVOID HwDeviceExtension,
    IN UCHAR PathId,
    IN UCHAR TargetId,
    IN UCHAR Lun,
    IN LPGUID Guid,
    IN ULONG InstanceIndex,
    IN ULONG EventDataSize,
    IN PVOID EventData
    );
/*++

Routine Description:

    This routine will fire a WMI event using the data buffer passed. This
    routine may be called at or below DPC level

Arguments:

    HwDeviceExtension is the adapter device extension

    PathId identifies the SCSI bus if a logical unit is firing the event
        or is 0xff if the adapter is firing the event.

    TargetId identifies the target controller or device on the bus

    Lun identifies the logical unit number of the target device

    Guid is pointer to the GUID that represents the event

    InstanceIndex is the index of the instance of the event

    EventDataSize is the number of bytes of data that is being fired with
       with the event. This size specifies the size of the event data only
       and does NOT include the 0x40 bytes of preceeding padding.

    EventData is the data that is fired with the events. There must be exactly
        0x40 bytes of padding preceeding the event data.

Return Value:

--*/

#if (NTDDI_VERSION >= NTDDI_WS03)
//
// This macro determines if the WMI request is a QueryAllData request
// or a different request
//
#define ScsiPortWmiIsQueryAllData(RequestContext) \
    ( (RequestContext)->MinorFunction == WMI_GET_ALL_DATA )												

PWCHAR ScsiPortWmiGetInstanceName(
    IN PSCSIWMI_REQUEST_CONTEXT RequestContext
    );
/*++

Routine Description:

    This routine will return a pointer to the instance name that was
    used to pass the request. If the request type is one that does not
    use an instance name then NULL is retuened. The instance name is a
    counted string.

Arguments:

    RequestContext is a pointer to a context structure that maintains
        information about this WMI srb. This request context must remain
        valid throughout the entire processing of the srb, at least until
        ScsiPortWmiPostProcess returns with the final srb return status and
        buffer size. If the srb can pend then memory for this buffer should
        be allocated from the SRB extension. If not then the memory can be
        allocated from a stack frame that does not go out of scope, perhaps
        that of the caller to this api.

Return Value:

    Pointer to instance name or NULL if no instance name is available

--*/


BOOLEAN ScsiPortWmiSetInstanceCount(
    IN PSCSIWMI_REQUEST_CONTEXT RequestContext,
    IN ULONG InstanceCount,
    OUT PULONG BufferAvail,
    OUT PULONG SizeNeeded
    );
/*++

Routine Description:

    This routine will update the wnode to indicate the number of
    instances that will be returned by the driver. Note that the values
    for BufferAvail may change after this call. This routine
    may only be called for a WNODE_ALL_DATA. This routine must be
    called before calling ScsiPortWmiSetInstanceName or
    ScsiPortWmiSetData

Arguments:

    RequestContext is a pointer to a context structure that maintains
        information about this WMI srb. This request context must remain
        valid throughout the entire processing of the srb, at least until
        ScsiPortWmiPostProcess returns with the final srb return status and
        buffer size. If the srb can pend then memory for this buffer should
        be allocated from the SRB extension. If not then the memory can be
        allocated from a stack frame that does not go out of scope, perhaps
        that of the caller to this api.

    InstanceCount is the number of instances to be returned by the
        driver.

    *BufferAvail returns with the number of bytes available for
        instance names and data in the buffer. This may be 0 if there
        is not enough room for all instances.

    *SizeNeeded returns with the number of bytes that are needed so far
        to build the output wnode

Return Value:

    TRUE if successful else FALSE. If FALSE wnode is not a
    WNODE_ALL_DATA or does not have dynamic instance names.

--*/

PWCHAR ScsiPortWmiSetInstanceName(
    IN PSCSIWMI_REQUEST_CONTEXT RequestContext,
    IN ULONG InstanceIndex,
    IN ULONG InstanceNameLength,
    OUT PULONG BufferAvail,
    IN OUT PULONG SizeNeeded
    );
/*++

Routine Description:

    This routine will update the wnode header to include the position where an
    instance name is to be written. Note that the values
    for BufferAvail may change after this call. This routine
    may only be called for a WNODE_ALL_DATA.

Arguments:

    RequestContext is a pointer to a context structure that maintains
        information about this WMI srb. This request context must remain
        valid throughout the entire processing of the srb, at least until
        ScsiPortWmiPostProcess returns with the final srb return status and
        buffer size. If the srb can pend then memory for this buffer should
        be allocated from the SRB extension. If not then the memory can be
        allocated from a stack frame that does not go out of scope, perhaps
        that of the caller to this api.

    InstanceIndex is the index to the instance name being filled in

    InstanceNameLength is the number of bytes (including count) needed
       to write the instance name.

    *BufferAvail returns with the number of bytes available for
        instance names and data in the buffer. This may be 0 if there
        is not enough room for the instance name.

    *SizeNeeded on entry has the number of bytes needed so far to build
        the WNODE and on return has the number of bytes needed to build
        the wnode after including the instance name

Return Value:

    pointer to where the instance name should be filled in. If NULL
    then the wnode is not a WNODE_ALL_DATA or does not have dynamic
    instance names

--*/

PVOID ScsiPortWmiSetData(
    IN PSCSIWMI_REQUEST_CONTEXT RequestContext,
    IN ULONG InstanceIndex,
    IN ULONG DataLength,
    OUT PULONG BufferAvail,
    IN OUT PULONG SizeNeeded
    );
/*++

Routine Description:

    This routine will update the wnode to indicate the position of the
    data for an instance that will be returned by the driver. Note that
    the values for BufferAvail may change after this call. This routine
    may only be called for a WNODE_ALL_DATA.

Arguments:

    RequestContext is a pointer to a context structure that maintains
        information about this WMI srb. This request context must remain
        valid throughout the entire processing of the srb, at least until
        ScsiPortWmiPostProcess returns with the final srb return status and
        buffer size. If the srb can pend then memory for this buffer should
        be allocated from the SRB extension. If not then the memory can be
        allocated from a stack frame that does not go out of scope, perhaps
        that of the caller to this api.

    InstanceIndex is the index to the instance name being filled in

    DataLength is the number of bytes  needed to write the data.

    *BufferAvail returns with the number of bytes available for
        instance names and data in the buffer. This may be 0 if there
        is not enough room for the data.

    *SizeNeeded on entry has the number of bytes needed so far to build
        the WNODE and on return has the number of bytes needed to build
        the wnode after including the data

Return Value:

    pointer to where the data should be filled in. If NULL
    then the wnode is not a WNODE_ALL_DATA or does not have dynamic
    instance names

--*/
#endif


#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\sddef.h ===
/*++

Copyright (c) 2003  Microsoft Corporation

Module Name:

    sddef.h

Abstract:

    This is the include file that defines the basic types used
    in the SD (Secure Digital) driver stack interface. These types
    are used in conjuction with header files NTDDSD.H or SFFDISK.H.

--*/

#ifndef _SDDEFH_
#define _SDDEFH_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif


//
// SD device commands codes either refer to the standard command
// set (0-63), or to the "App Cmd" set, which have the same value range,
// but are preceded by the app_cmd escape (55).
//

typedef UCHAR SD_COMMAND_CODE;

typedef enum {
    SDCC_STANDARD = 0,
    SDCC_APP_CMD
} SD_COMMAND_CLASS;
//
// SDTD_READ indicates data transfer from the SD device to the host
// SDTD_WRITE indicates data transfer from the SD host to the device
//

typedef enum {
    SDTD_UNSPECIFIED = 0,
    SDTD_READ,
    SDTD_WRITE
} SD_TRANSFER_DIRECTION;


//
// Transfer type refers to the style of data transfer of the SD data
// lines. Note that a command may have a response, but still not use
// the data lines (no_data).
//

typedef enum {
    SDTT_UNSPECIFIED = 0,
    SDTT_CMD_ONLY,
    SDTT_SINGLE_BLOCK,
    SDTT_MULTI_BLOCK,
    SDTT_MULTI_BLOCK_NO_CMD12
} SD_TRANSFER_TYPE;


//
// SD transfer responses are defined in the SD spec. A given command
// will only exhibit one of these responses. But because the interface
// allows function drivers to issue undefined commands, the transfer
// response may also need to be specified.
//

typedef enum {
    SDRT_UNSPECIFIED = 0,
    SDRT_NONE,
    SDRT_1,
    SDRT_1B,
    SDRT_2,
    SDRT_3,
    SDRT_4,
    SDRT_5,
    SDRT_5B,
    SDRT_6
} SD_RESPONSE_TYPE;

//
// Response structures are mapped into the response data field in the
// request packet
//

typedef struct _SDRESP_TYPE3 {
    ULONG Reserved1:4;
    ULONG VoltageProfile:20;
    ULONG Reserved2:7;
    ULONG PowerState:1;
} SDRESP_TYPE3, *PSDRESP_TYPE3;

//
// OCR Register structure for Physical Specification Version 2.00 or higher
//
typedef struct _OCR_REGISTER_V2 {
    ULONG Reserved1:7;
    ULONG VoltageProfile1:1;
    ULONG Reserved2:7;    
    ULONG VoltageProfile2:9;
    ULONG Reserved3:6;
    ULONG CardCapacityStatus:1;
    ULONG PowerState:1;
} OCR_REGISTER_V2, *POCR_REGISTER_V2;

//
// This structure defines a specific SD device command. Function drivers
// must build this structure to pass as a parameter to the DeviceCommand request.
//
//    Cmd               - SD device code
//    CmdClass          - specifies whether the command is a standard or APP command
//    TransferDirection - direction of data on SD data lines
//    TransferType      - 3 types of commands: CmdOnly, SingleBlock or MultiBlock
//    ResponseType      - SD response type
//
// For example, a driver can issue single byte (direct) I/O reads
// to an SDIO function by first defining the following structure:
//
//      const SDCMD_DESCRIPTOR ReadIoDirectDesc =
//          {SDCMD_IO_RW_DIRECT, SDTD_STANDARD, SDTD_READ, SDTT_CMD_ONLY, SDRT_5};
//
// Then, before the call to SdbusSubmitRequest(), copy this structure
// and the argument of the command to the request packet:
//
//      sdrp->RequestFunction = SDRF_DEVICE_COMMAND;
//      sdrp->Parameters.DeviceCommand.CmdDesc = ReadIoDirectDesc;
//      sdrp->Parameters.DeviceCommand.Argument = argument;
//      status = SdBusSubmitRequest(interfaceContext, sdrp);
//
//

typedef struct _SDCMD_DESCRIPTOR {

    SD_COMMAND_CODE  Cmd;
    SD_COMMAND_CLASS CmdClass;

    SD_TRANSFER_DIRECTION TransferDirection;
    SD_TRANSFER_TYPE      TransferType;
    SD_RESPONSE_TYPE      ResponseType;

} SDCMD_DESCRIPTOR, *PSDCMD_DESCRIPTOR;


//
// Class-neutral SD device definitions
//
// Note that the SDIO arguments may be validated by the bus driver. For
// example, the bus driver will reject attempts to write into the function
// space of a different function on an SD combo card.
//

typedef struct _SD_RW_DIRECT_ARGUMENT {

    union {
        struct {
            ULONG Data:8;
            ULONG Reserved1:1;
            ULONG Address:17;
            ULONG Reserved2:1;
            ULONG ReadAfterWrite:1;
            ULONG Function:3;
            ULONG WriteToDevice:1;
        } bits;

        ULONG AsULONG;
    } u;

} SD_RW_DIRECT_ARGUMENT, *PSD_RW_DIRECT_ARGUMENT;

typedef struct _SD_RW_EXTENDED_ARGUMENT {

    union {
        struct {
            ULONG Count:9;
            ULONG Address:17;
            ULONG OpCode:1;
            ULONG BlockMode:1;
            ULONG Function:3;
            ULONG WriteToDevice:1;
        } bits;

        ULONG AsULONG;
    } u;

} SD_RW_EXTENDED_ARGUMENT, *PSD_RW_EXTENDED_ARGUMENT;


//
// Class-neutral SD codes
//
// provided here are SD command codes that are not class specific.
// Typically other codes are defined in the class driver for the
// respective device class.
//

#define SDCMD_IO_RW_DIRECT              52
#define SDCMD_IO_RW_EXTENDED            53


#ifdef __cplusplus
}
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\sffprtcl.h ===
/*++

Copyright (c) 1991 - 1993 Microsoft Corporation

Module Name:

    sffprtcl.h

Abstract:

    Definition for Small Form Factor disk (SFFDISK) protocol layer interface


Notes:


--*/

#ifndef _SFFPRTCL_H_
#define _SFFPRTCL_H_


DEFINE_GUID(GUID_SFF_PROTOCOL_INTERFACE_STANDARD,  0xc7ec8da0L, 0xdbe3, 0x43fd, 0xa9, 0xeb, 0x7e, 0x4c, 0x70, 0x7c, 0x35, 0xac);

#define SFF_PROTOCOL_INTERFACE_VERSION 0x0102

//
// Property types used in SFFPROT_Get/Set_Property
//

typedef enum {
    SFFP_PROP_MEDIA_CAPACITY,
    SFFP_PROP_PARTITION_SIZE,
    SFFP_PROP_WRITE_PROTECTED,
    SFFP_PROP_MEDIA_STATE,
    SFFP_PROP_MEDIA_CHANGECOUNT,
    SFFP_PROP_MEDIA_ID,
    SFFP_PROP_PROTOCOL_GUID,
    SFFP_PROP_VERIFY_STATE,
    SFFP_PROP_PARTITION_START_OFFSET
} SFFPROT_PROPERTY;

//
// Media states defined for SFFP_PROP_MEDIA_STATE
//

typedef enum {
    SFFMS_NO_MEDIA = 0,
    SFFMS_MEDIA_PRESENT
} SFFPROT_MEDIA_STATE;

//
// Media states defined for SFFP_PROP_MEDIA_STATE
//

typedef enum {
    SFFVS_VERIFY_REQUIRED = 0,            // the bus interface layer has noticed the media changed
    SFFVS_VERIFY_ACKNOWLEDGED             // the file system has started the verify
} SFFPROT_VERIFY_STATE;

//
// types used in DeviceControl
//

typedef enum {
    SFFDC_DEVICE_COMMAND,
    SFFDC_DEVICE_PASSWORD
} SFFPROT_DCTYPE;

//
// Prototypes for the get/set property calls
//

typedef
NTSTATUS
(*PSFFPROT_GET_PROPERTY)(
    IN PVOID Context,
    IN SFFPROT_PROPERTY Property,
    IN ULONG BufferLength,
    OUT PVOID PropertyBuffer,
    OUT PULONG ResultLength
    );

typedef
NTSTATUS
(*PSFFPROT_SET_PROPERTY)(
    IN PVOID Context,
    IN SFFPROT_PROPERTY Property,
    IN ULONG BufferLength,
    IN PVOID PropertyBuffer
    );

typedef
NTSTATUS
(*PSFFPROT_DEVICE_CONTROL)(
    IN PVOID Context,
    IN SFFPROT_DCTYPE Type,
    IN PVOID Buffer,
    IN ULONG Length,
    OUT PULONG LengthReturned
    );

typedef
NTSTATUS
(*PSFFPROT_READ)(
    IN PVOID Context,
    IN PMDL Mdl,
    IN ULONGLONG Offset,
    IN ULONG Length,
    OUT PULONG LengthReturned
    );

typedef
NTSTATUS
(*PSFFPROT_WRITE)(
    IN PVOID Context,
    IN PMDL Mdl,
    IN ULONGLONG Offset,
    IN ULONG Length,
    OUT PULONG LengthReturned
    );

//
// This typedef defines the interface structure to be returned by
// the pnp QUERY_INTERFACE call.
//


typedef struct _SFF_PROTOCOL_INTERFACE_STANDARD {
   USHORT Size;
   USHORT Version;
   PINTERFACE_REFERENCE    InterfaceReference;
   PINTERFACE_DEREFERENCE  InterfaceDereference;
   PVOID                   Context;
   PSFFPROT_GET_PROPERTY   GetProperty;
   PSFFPROT_SET_PROPERTY   SetProperty;
   PSFFPROT_READ           Read;
   PSFFPROT_WRITE          Write;
   PSFFPROT_DEVICE_CONTROL DeviceControl;
} SFF_PROTOCOL_INTERFACE_STANDARD, *PSFF_PROTOCOL_INTERFACE_STANDARD;


#endif  // _SFFPRTCL_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\smbus.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    smbus.h

Abstract:

    SMBus Class Driver Header File

Author:

    Ken Reneris

Environment:

Notes:


Revision History:

--*/

#pragma once

#if (NTDDI_VERSION >= NTDDI_WINXP)
#if (NTDDI_VERSION < NTDDI_WIN6)

//
// SMB Request packet
//

#define SMB_MAX_DATA_SIZE   32

typedef struct {
    UCHAR       Status;             // Completion status
    UCHAR       Protocol;
    UCHAR       Address;
    UCHAR       Command;
    UCHAR       BlockLength;
    UCHAR       Data[SMB_MAX_DATA_SIZE];
} SMB_REQUEST, *PSMB_REQUEST;

//
// Protocol values
//

#define SMB_WRITE_QUICK                 0x00    // Issue quick command data bit = 0
#define SMB_READ_QUICK                  0x01    // Issue quick command data bit = 1
#define SMB_SEND_BYTE                   0x02
#define SMB_RECEIVE_BYTE                0x03
#define SMB_WRITE_BYTE                  0x04
#define SMB_READ_BYTE                   0x05
#define SMB_WRITE_WORD                  0x06
#define SMB_READ_WORD                   0x07
#define SMB_WRITE_BLOCK                 0x08
#define SMB_READ_BLOCK                  0x09
#define SMB_PROCESS_CALL                0x0A
#define SMB_BLOCK_PROCESS_CALL          0x0B
#define SMB_MAXIMUM_PROTOCOL            0x0B

//
// SMB Bus Status codes
//

#define SMB_STATUS_OK                   0x00
#define SMB_UNKNOWN_FAILURE             0x07
#define SMB_ADDRESS_NOT_ACKNOWLEDGED    0x10
#define SMB_DEVICE_ERROR                0x11
#define SMB_COMMAND_ACCESS_DENIED       0x12
#define SMB_UNKNOWN_ERROR               0x13
#define SMB_DEVICE_ACCESS_DENIED        0x17
#define SMB_TIMEOUT                     0x18
#define SMB_UNSUPPORTED_PROTOCOL        0x19
#define SMB_BUS_BUSY                    0x1A

//
// Alarm register/deregister requests
//

typedef
VOID
(*SMB_ALARM_NOTIFY) (
    PVOID       Context,
    UCHAR       Address,
    USHORT      Data
    );

// input buffer is SMB_REGISTER_ALARM.  output buffer is PVOID handle for registration.
// PVOID is passed in via DEREGISTER request to free registration

typedef struct {
    UCHAR               MinAddress;     // Min address for notifications
    UCHAR               MaxAddress;     // Max address for notifications
    SMB_ALARM_NOTIFY    NotifyFunction;
    PVOID               NotifyContext;
} SMB_REGISTER_ALARM, *PSMB_REGISTER_ALARM;

//
// Internal ioctls to SMB class driver
//

#define SMB_BUS_REQUEST             CTL_CODE(FILE_DEVICE_UNKNOWN, 0, METHOD_NEITHER, FILE_ANY_ACCESS)
#define SMB_REGISTER_ALARM_NOTIFY   CTL_CODE(FILE_DEVICE_UNKNOWN, 1, METHOD_NEITHER, FILE_ANY_ACCESS)
#define SMB_DEREGISTER_ALARM_NOTIFY CTL_CODE(FILE_DEVICE_UNKNOWN, 2, METHOD_NEITHER, FILE_ANY_ACCESS)

//
// Shared SMB Class / Miniport driver structure
//

typedef
NTSTATUS
(*SMB_RESET_DEVICE)(
    IN struct _SMB_CLASS    *SmbClass,
    IN PVOID                SmbMiniport
    );

typedef
VOID
(*SMB_START_IO)(
    IN struct _SMB_CLASS    *SmbClass,
    IN PVOID                SmbMiniport
    );

typedef
NTSTATUS
(*SMB_STOP_DEVICE)(
    IN struct _SMB_CLASS    *SmbClass,
    IN PVOID                SmbMiniport
    );



typedef struct _SMB_CLASS {
    USHORT              MajorVersion;
    USHORT              MinorVersion;

    PVOID               Miniport;           // Miniport extension data

    PDEVICE_OBJECT      DeviceObject;       // Device object for this miniport
    PDEVICE_OBJECT      PDO;                // PDO for this miniport
    PDEVICE_OBJECT      LowerDeviceObject;

    //
    // Current IO
    //

    PIRP                CurrentIrp;         // current request
    PSMB_REQUEST        CurrentSmb;         // pointer to SMB_REQUEST in the CurrentIrp

    //
    // Miniport functions
    //

    SMB_RESET_DEVICE    ResetDevice;        // Initialize/Reset, start device
    SMB_START_IO        StartIo;            // Perform IO
    SMB_STOP_DEVICE     StopDevice;         // Stop device

} SMB_CLASS, *PSMB_CLASS;

#define SMB_CLASS_MAJOR_VERSION     0x0001
#define SMB_CLASS_MINOR_VERSION     0x0000

//
// Class driver initializtion functions
//

#if !defined(SMBCLASS)
    #define SMBCLASSAPI DECLSPEC_IMPORT
#else
    #define SMBCLASSAPI
#endif


typedef
NTSTATUS
(*PSMB_INITIALIZE_MINIPORT) (
    IN PSMB_CLASS SmbClass,
    IN PVOID MiniportExtension,
    IN PVOID MiniportContext
    );

NTSTATUS
SMBCLASSAPI
SmbClassInitializeDevice (
    IN ULONG MajorVersion,
    IN ULONG MinorVersion,
    IN PDRIVER_OBJECT DriverObject
    );

NTSTATUS
SMBCLASSAPI
SmbClassCreateFdo (
    IN PDRIVER_OBJECT           DriverObject,
    IN PDEVICE_OBJECT           PDO,
    IN ULONG                    MiniportExtensionSize,
    IN PSMB_INITIALIZE_MINIPORT MiniportInitialize,
    IN PVOID                    MiniportContext,
    OUT PDEVICE_OBJECT          *FDO
    );

//
// Class driver interface functions for use by the miniport
//

VOID
SMBCLASSAPI
SmbClassCompleteRequest (
    IN PSMB_CLASS   SmbClass
    );


VOID
SMBCLASSAPI
SmbClassAlarm (
    IN PSMB_CLASS   SmbClass,
    IN UCHAR        Address,
    IN USHORT       Data
    );


VOID
SMBCLASSAPI
SmbClassLockDevice (
    IN PSMB_CLASS   SmbClass
    );

VOID
SMBCLASSAPI
SmbClassUnlockDevice (
    IN PSMB_CLASS   SmbClass
    );

#endif // (NTDDI_VERSION < NTDDI_WIN6)
#endif // (NTDDI_VERSION >= NTDDI_WINXP)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\softehciif.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0499 */
/* Compiler settings for softehciif.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__


#ifndef __softehciif_h__
#define __softehciif_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __ISoftEHCI_FWD_DEFINED__
#define __ISoftEHCI_FWD_DEFINED__
typedef interface ISoftEHCI ISoftEHCI;
#endif 	/* __ISoftEHCI_FWD_DEFINED__ */


#ifndef __SoftEHCI_FWD_DEFINED__
#define __SoftEHCI_FWD_DEFINED__

#ifdef __cplusplus
typedef class SoftEHCI SoftEHCI;
#else
typedef struct SoftEHCI SoftEHCI;
#endif /* __cplusplus */

#endif 	/* __SoftEHCI_FWD_DEFINED__ */


#ifndef __ISoftEHCICtrlr_FWD_DEFINED__
#define __ISoftEHCICtrlr_FWD_DEFINED__
typedef interface ISoftEHCICtrlr ISoftEHCICtrlr;
#endif 	/* __ISoftEHCICtrlr_FWD_DEFINED__ */


#ifndef __SoftEHCICtrlr_FWD_DEFINED__
#define __SoftEHCICtrlr_FWD_DEFINED__

#ifdef __cplusplus
typedef class SoftEHCICtrlr SoftEHCICtrlr;
#else
typedef struct SoftEHCICtrlr SoftEHCICtrlr;
#endif /* __cplusplus */

#endif 	/* __SoftEHCICtrlr_FWD_DEFINED__ */


#ifndef __ISoftEHCIRootHubPorts_FWD_DEFINED__
#define __ISoftEHCIRootHubPorts_FWD_DEFINED__
typedef interface ISoftEHCIRootHubPorts ISoftEHCIRootHubPorts;
#endif 	/* __ISoftEHCIRootHubPorts_FWD_DEFINED__ */


#ifndef __SoftEHCIRootHubPorts_FWD_DEFINED__
#define __SoftEHCIRootHubPorts_FWD_DEFINED__

#ifdef __cplusplus
typedef class SoftEHCIRootHubPorts SoftEHCIRootHubPorts;
#else
typedef struct SoftEHCIRootHubPorts SoftEHCIRootHubPorts;
#endif /* __cplusplus */

#endif 	/* __SoftEHCIRootHubPorts_FWD_DEFINED__ */


#ifndef __ISoftEHCIRootHubPort_FWD_DEFINED__
#define __ISoftEHCIRootHubPort_FWD_DEFINED__
typedef interface ISoftEHCIRootHubPort ISoftEHCIRootHubPort;
#endif 	/* __ISoftEHCIRootHubPort_FWD_DEFINED__ */


#ifndef __SoftEHCIRootHubPort_FWD_DEFINED__
#define __SoftEHCIRootHubPort_FWD_DEFINED__

#ifdef __cplusplus
typedef class SoftEHCIRootHubPort SoftEHCIRootHubPort;
#else
typedef struct SoftEHCIRootHubPort SoftEHCIRootHubPort;
#endif /* __cplusplus */

#endif 	/* __SoftEHCIRootHubPort_FWD_DEFINED__ */


#ifdef __cplusplus
extern "C"{
#endif 



#ifndef __SoftEHCI_LIBRARY_DEFINED__
#define __SoftEHCI_LIBRARY_DEFINED__

/* library SoftEHCI */
/* [helpstringcontext][helpcontext][helpstring][version][lcid][uuid] */ 



typedef /* [helpstringcontext][helpcontext][helpstring][uuid] */  DECLSPEC_UUID("01647E9C-2B10-4620-BE92-758093F3C31A") 
enum EHCIRootHubIndicator
    {	EHCIRootHubOff	= 0,
	EHCIRootHubAmber	= 1,
	EHCIRootHubGreen	= 2,
	EHCIRootHubUndefined	= 3
    } 	EHCIRootHubIndicator;


EXTERN_C const IID LIBID_SoftEHCI;

#ifndef __ISoftEHCI_INTERFACE_DEFINED__
#define __ISoftEHCI_INTERFACE_DEFINED__

/* interface ISoftEHCI */
/* [object][helpstring][hidden][nonextensible][oleautomation][dual][uuid] */ 


EXTERN_C const IID IID_ISoftEHCI;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("E99BC1D0-088B-4bd2-AE94-6DA3F2861FA2")
    ISoftEHCI : public IDispatch
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct ISoftEHCIVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISoftEHCI * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISoftEHCI * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISoftEHCI * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ISoftEHCI * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ISoftEHCI * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ISoftEHCI * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ISoftEHCI * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        END_INTERFACE
    } ISoftEHCIVtbl;

    interface ISoftEHCI
    {
        CONST_VTBL struct ISoftEHCIVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISoftEHCI_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ISoftEHCI_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ISoftEHCI_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ISoftEHCI_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ISoftEHCI_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ISoftEHCI_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ISoftEHCI_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ISoftEHCI_INTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_SoftEHCI;

#ifdef __cplusplus

class DECLSPEC_UUID("3676BB7A-1618-4bfc-855C-63C92FD54ACD")
SoftEHCI;
#endif

#ifndef __ISoftEHCICtrlr_INTERFACE_DEFINED__
#define __ISoftEHCICtrlr_INTERFACE_DEFINED__

/* interface ISoftEHCICtrlr */
/* [helpstringcontext][helpcontext][helpstring][object][hidden][nonextensible][oleautomation][dual][uuid] */ 


EXTERN_C const IID IID_ISoftEHCICtrlr;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("16017C34-A2BA-480B-8DE8-CD08756AD1F8")
    ISoftEHCICtrlr : public IDispatch
    {
    public:
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_Ports( 
            /* [retval][out] */ __RPC__deref_out_opt SoftEHCIRootHubPorts	**ppPorts) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISoftEHCICtrlrVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISoftEHCICtrlr * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISoftEHCICtrlr * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISoftEHCICtrlr * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ISoftEHCICtrlr * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ISoftEHCICtrlr * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ISoftEHCICtrlr * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ISoftEHCICtrlr * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_Ports )( 
            ISoftEHCICtrlr * This,
            /* [retval][out] */ __RPC__deref_out_opt SoftEHCIRootHubPorts	**ppPorts);
        
        END_INTERFACE
    } ISoftEHCICtrlrVtbl;

    interface ISoftEHCICtrlr
    {
        CONST_VTBL struct ISoftEHCICtrlrVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISoftEHCICtrlr_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ISoftEHCICtrlr_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ISoftEHCICtrlr_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ISoftEHCICtrlr_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ISoftEHCICtrlr_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ISoftEHCICtrlr_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ISoftEHCICtrlr_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ISoftEHCICtrlr_get_Ports(This,ppPorts)	\
    ( (This)->lpVtbl -> get_Ports(This,ppPorts) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ISoftEHCICtrlr_INTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_SoftEHCICtrlr;

#ifdef __cplusplus

class DECLSPEC_UUID("C2B7819E-632F-4ADD-A450-62E6F324DC70")
SoftEHCICtrlr;
#endif

#ifndef __ISoftEHCIRootHubPorts_INTERFACE_DEFINED__
#define __ISoftEHCIRootHubPorts_INTERFACE_DEFINED__

/* interface ISoftEHCIRootHubPorts */
/* [helpstringcontext][helpcontext][helpstring][object][hidden][nonextensible][oleautomation][dual][uuid] */ 


EXTERN_C const IID IID_ISoftEHCIRootHubPorts;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8202B252-20C9-47A1-9448-B8621D985CA1")
    ISoftEHCIRootHubPorts : public IDispatch
    {
    public:
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_Count( 
            /* [retval][out] */ __RPC__out long *plCount) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_Item( 
            /* [in] */ VARIANT Index,
            /* [retval][out] */ __RPC__deref_out_opt SoftEHCIRootHubPort	**ppSoftEHCIRootHubPort) = 0;
        
        virtual /* [hidden][propget][id] */ HRESULT __stdcall get__NewEnum( 
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **ppunkEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISoftEHCIRootHubPortsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISoftEHCIRootHubPorts * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISoftEHCIRootHubPorts * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISoftEHCIRootHubPorts * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ISoftEHCIRootHubPorts * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ISoftEHCIRootHubPorts * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ISoftEHCIRootHubPorts * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ISoftEHCIRootHubPorts * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_Count )( 
            ISoftEHCIRootHubPorts * This,
            /* [retval][out] */ __RPC__out long *plCount);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_Item )( 
            ISoftEHCIRootHubPorts * This,
            /* [in] */ VARIANT Index,
            /* [retval][out] */ __RPC__deref_out_opt SoftEHCIRootHubPort	**ppSoftEHCIRootHubPort);
        
        /* [hidden][propget][id] */ HRESULT ( __stdcall *get__NewEnum )( 
            ISoftEHCIRootHubPorts * This,
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **ppunkEnum);
        
        END_INTERFACE
    } ISoftEHCIRootHubPortsVtbl;

    interface ISoftEHCIRootHubPorts
    {
        CONST_VTBL struct ISoftEHCIRootHubPortsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISoftEHCIRootHubPorts_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ISoftEHCIRootHubPorts_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ISoftEHCIRootHubPorts_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ISoftEHCIRootHubPorts_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ISoftEHCIRootHubPorts_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ISoftEHCIRootHubPorts_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ISoftEHCIRootHubPorts_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ISoftEHCIRootHubPorts_get_Count(This,plCount)	\
    ( (This)->lpVtbl -> get_Count(This,plCount) ) 

#define ISoftEHCIRootHubPorts_get_Item(This,Index,ppSoftEHCIRootHubPort)	\
    ( (This)->lpVtbl -> get_Item(This,Index,ppSoftEHCIRootHubPort) ) 

#define ISoftEHCIRootHubPorts_get__NewEnum(This,ppunkEnum)	\
    ( (This)->lpVtbl -> get__NewEnum(This,ppunkEnum) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ISoftEHCIRootHubPorts_INTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_SoftEHCIRootHubPorts;

#ifdef __cplusplus

class DECLSPEC_UUID("00DC66FB-A2E1-4BF9-9E6C-C3A1A60130EC")
SoftEHCIRootHubPorts;
#endif

#ifndef __ISoftEHCIRootHubPort_INTERFACE_DEFINED__
#define __ISoftEHCIRootHubPort_INTERFACE_DEFINED__

/* interface ISoftEHCIRootHubPort */
/* [helpstringcontext][helpcontext][helpstring][object][hidden][nonextensible][oleautomation][dual][uuid] */ 


EXTERN_C const IID IID_ISoftEHCIRootHubPort;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9A80EBED-8173-4417-9830-405EF2F0167A")
    ISoftEHCIRootHubPort : public IDispatch
    {
    public:
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_WakeOnOverCurrentEnable( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pfvarWake) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_WakeOnDisconnectEnable( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pfvarWake) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_WakeOnConnectEnable( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pfvarWake) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_TestCtrl( 
            /* [retval][out] */ __RPC__out BYTE *pbTestCtrl) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_Indicator( 
            /* [retval][out] */ __RPC__out EHCIRootHubIndicator *pIndicator) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_Owner( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pfvarOwner) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_Power( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pfvarPower) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT __stdcall put_Power( 
            /* [in] */ VARIANT_BOOL fvarPower) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_LineStatus( 
            /* [retval][out] */ __RPC__out BYTE *pbLineStatus) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT __stdcall put_LineStatus( 
            /* [in] */ BYTE bLineStatus) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_Reset( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pfvarReset) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_Suspend( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pfvarSuspend) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT __stdcall put_Suspend( 
            /* [in] */ VARIANT_BOOL fvarSuspend) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_ForcePortResume( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pfvarForcePortResume) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT __stdcall put_ForcePortResume( 
            /* [in] */ VARIANT_BOOL fvarForcePortResume) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_OverCurrentChange( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pfvarOverCurrentChange) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT __stdcall put_OverCurrentChange( 
            /* [in] */ VARIANT_BOOL fvarOverCurrentChange) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_OverCurrent( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pfvarOverCurrent) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT __stdcall put_OverCurrent( 
            /* [in] */ VARIANT_BOOL fvarOverCurrent) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_EnableChange( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pfvarEnableChange) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT __stdcall put_EnableChange( 
            /* [in] */ VARIANT_BOOL fvarEnableChange) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_Enabled( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pfvarEnabled) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT __stdcall put_Enabled( 
            /* [in] */ VARIANT_BOOL fvarEnabled) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_ConnectStatusChange( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pfvarConnectStatusChange) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT __stdcall put_ConnectStatusChange( 
            /* [in] */ VARIANT_BOOL fvarConnectStatusChange) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_CurrentConnectStatus( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pfvarStatus) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_Status( 
            /* [retval][out] */ __RPC__out long *plStatus) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_Device( 
            /* [retval][out] */ __RPC__deref_out_opt /* external definition not present */ DSFDevice **ppDSFDevice) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][id] */ HRESULT __stdcall HotPlug( 
            /* [in] */ __RPC__in /* external definition not present */ DSFDevice *pDSFDevice) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][id] */ HRESULT __stdcall Unplug( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISoftEHCIRootHubPortVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISoftEHCIRootHubPort * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISoftEHCIRootHubPort * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISoftEHCIRootHubPort * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ISoftEHCIRootHubPort * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ISoftEHCIRootHubPort * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ISoftEHCIRootHubPort * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ISoftEHCIRootHubPort * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_WakeOnOverCurrentEnable )( 
            ISoftEHCIRootHubPort * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pfvarWake);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_WakeOnDisconnectEnable )( 
            ISoftEHCIRootHubPort * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pfvarWake);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_WakeOnConnectEnable )( 
            ISoftEHCIRootHubPort * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pfvarWake);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_TestCtrl )( 
            ISoftEHCIRootHubPort * This,
            /* [retval][out] */ __RPC__out BYTE *pbTestCtrl);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_Indicator )( 
            ISoftEHCIRootHubPort * This,
            /* [retval][out] */ __RPC__out EHCIRootHubIndicator *pIndicator);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_Owner )( 
            ISoftEHCIRootHubPort * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pfvarOwner);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_Power )( 
            ISoftEHCIRootHubPort * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pfvarPower);
        
        /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT ( __stdcall *put_Power )( 
            ISoftEHCIRootHubPort * This,
            /* [in] */ VARIANT_BOOL fvarPower);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_LineStatus )( 
            ISoftEHCIRootHubPort * This,
            /* [retval][out] */ __RPC__out BYTE *pbLineStatus);
        
        /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT ( __stdcall *put_LineStatus )( 
            ISoftEHCIRootHubPort * This,
            /* [in] */ BYTE bLineStatus);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_Reset )( 
            ISoftEHCIRootHubPort * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pfvarReset);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_Suspend )( 
            ISoftEHCIRootHubPort * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pfvarSuspend);
        
        /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT ( __stdcall *put_Suspend )( 
            ISoftEHCIRootHubPort * This,
            /* [in] */ VARIANT_BOOL fvarSuspend);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_ForcePortResume )( 
            ISoftEHCIRootHubPort * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pfvarForcePortResume);
        
        /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT ( __stdcall *put_ForcePortResume )( 
            ISoftEHCIRootHubPort * This,
            /* [in] */ VARIANT_BOOL fvarForcePortResume);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_OverCurrentChange )( 
            ISoftEHCIRootHubPort * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pfvarOverCurrentChange);
        
        /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT ( __stdcall *put_OverCurrentChange )( 
            ISoftEHCIRootHubPort * This,
            /* [in] */ VARIANT_BOOL fvarOverCurrentChange);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_OverCurrent )( 
            ISoftEHCIRootHubPort * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pfvarOverCurrent);
        
        /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT ( __stdcall *put_OverCurrent )( 
            ISoftEHCIRootHubPort * This,
            /* [in] */ VARIANT_BOOL fvarOverCurrent);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_EnableChange )( 
            ISoftEHCIRootHubPort * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pfvarEnableChange);
        
        /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT ( __stdcall *put_EnableChange )( 
            ISoftEHCIRootHubPort * This,
            /* [in] */ VARIANT_BOOL fvarEnableChange);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_Enabled )( 
            ISoftEHCIRootHubPort * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pfvarEnabled);
        
        /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT ( __stdcall *put_Enabled )( 
            ISoftEHCIRootHubPort * This,
            /* [in] */ VARIANT_BOOL fvarEnabled);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_ConnectStatusChange )( 
            ISoftEHCIRootHubPort * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pfvarConnectStatusChange);
        
        /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT ( __stdcall *put_ConnectStatusChange )( 
            ISoftEHCIRootHubPort * This,
            /* [in] */ VARIANT_BOOL fvarConnectStatusChange);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_CurrentConnectStatus )( 
            ISoftEHCIRootHubPort * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pfvarStatus);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_Status )( 
            ISoftEHCIRootHubPort * This,
            /* [retval][out] */ __RPC__out long *plStatus);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_Device )( 
            ISoftEHCIRootHubPort * This,
            /* [retval][out] */ __RPC__deref_out_opt /* external definition not present */ DSFDevice **ppDSFDevice);
        
        /* [helpstringcontext][helpcontext][helpstring][id] */ HRESULT ( __stdcall *HotPlug )( 
            ISoftEHCIRootHubPort * This,
            /* [in] */ __RPC__in /* external definition not present */ DSFDevice *pDSFDevice);
        
        /* [helpstringcontext][helpcontext][helpstring][id] */ HRESULT ( __stdcall *Unplug )( 
            ISoftEHCIRootHubPort * This);
        
        END_INTERFACE
    } ISoftEHCIRootHubPortVtbl;

    interface ISoftEHCIRootHubPort
    {
        CONST_VTBL struct ISoftEHCIRootHubPortVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISoftEHCIRootHubPort_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ISoftEHCIRootHubPort_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ISoftEHCIRootHubPort_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ISoftEHCIRootHubPort_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ISoftEHCIRootHubPort_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ISoftEHCIRootHubPort_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ISoftEHCIRootHubPort_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ISoftEHCIRootHubPort_get_WakeOnOverCurrentEnable(This,pfvarWake)	\
    ( (This)->lpVtbl -> get_WakeOnOverCurrentEnable(This,pfvarWake) ) 

#define ISoftEHCIRootHubPort_get_WakeOnDisconnectEnable(This,pfvarWake)	\
    ( (This)->lpVtbl -> get_WakeOnDisconnectEnable(This,pfvarWake) ) 

#define ISoftEHCIRootHubPort_get_WakeOnConnectEnable(This,pfvarWake)	\
    ( (This)->lpVtbl -> get_WakeOnConnectEnable(This,pfvarWake) ) 

#define ISoftEHCIRootHubPort_get_TestCtrl(This,pbTestCtrl)	\
    ( (This)->lpVtbl -> get_TestCtrl(This,pbTestCtrl) ) 

#define ISoftEHCIRootHubPort_get_Indicator(This,pIndicator)	\
    ( (This)->lpVtbl -> get_Indicator(This,pIndicator) ) 

#define ISoftEHCIRootHubPort_get_Owner(This,pfvarOwner)	\
    ( (This)->lpVtbl -> get_Owner(This,pfvarOwner) ) 

#define ISoftEHCIRootHubPort_get_Power(This,pfvarPower)	\
    ( (This)->lpVtbl -> get_Power(This,pfvarPower) ) 

#define ISoftEHCIRootHubPort_put_Power(This,fvarPower)	\
    ( (This)->lpVtbl -> put_Power(This,fvarPower) ) 

#define ISoftEHCIRootHubPort_get_LineStatus(This,pbLineStatus)	\
    ( (This)->lpVtbl -> get_LineStatus(This,pbLineStatus) ) 

#define ISoftEHCIRootHubPort_put_LineStatus(This,bLineStatus)	\
    ( (This)->lpVtbl -> put_LineStatus(This,bLineStatus) ) 

#define ISoftEHCIRootHubPort_get_Reset(This,pfvarReset)	\
    ( (This)->lpVtbl -> get_Reset(This,pfvarReset) ) 

#define ISoftEHCIRootHubPort_get_Suspend(This,pfvarSuspend)	\
    ( (This)->lpVtbl -> get_Suspend(This,pfvarSuspend) ) 

#define ISoftEHCIRootHubPort_put_Suspend(This,fvarSuspend)	\
    ( (This)->lpVtbl -> put_Suspend(This,fvarSuspend) ) 

#define ISoftEHCIRootHubPort_get_ForcePortResume(This,pfvarForcePortResume)	\
    ( (This)->lpVtbl -> get_ForcePortResume(This,pfvarForcePortResume) ) 

#define ISoftEHCIRootHubPort_put_ForcePortResume(This,fvarForcePortResume)	\
    ( (This)->lpVtbl -> put_ForcePortResume(This,fvarForcePortResume) ) 

#define ISoftEHCIRootHubPort_get_OverCurrentChange(This,pfvarOverCurrentChange)	\
    ( (This)->lpVtbl -> get_OverCurrentChange(This,pfvarOverCurrentChange) ) 

#define ISoftEHCIRootHubPort_put_OverCurrentChange(This,fvarOverCurrentChange)	\
    ( (This)->lpVtbl -> put_OverCurrentChange(This,fvarOverCurrentChange) ) 

#define ISoftEHCIRootHubPort_get_OverCurrent(This,pfvarOverCurrent)	\
    ( (This)->lpVtbl -> get_OverCurrent(This,pfvarOverCurrent) ) 

#define ISoftEHCIRootHubPort_put_OverCurrent(This,fvarOverCurrent)	\
    ( (This)->lpVtbl -> put_OverCurrent(This,fvarOverCurrent) ) 

#define ISoftEHCIRootHubPort_get_EnableChange(This,pfvarEnableChange)	\
    ( (This)->lpVtbl -> get_EnableChange(This,pfvarEnableChange) ) 

#define ISoftEHCIRootHubPort_put_EnableChange(This,fvarEnableChange)	\
    ( (This)->lpVtbl -> put_EnableChange(This,fvarEnableChange) ) 

#define ISoftEHCIRootHubPort_get_Enabled(This,pfvarEnabled)	\
    ( (This)->lpVtbl -> get_Enabled(This,pfvarEnabled) ) 

#define ISoftEHCIRootHubPort_put_Enabled(This,fvarEnabled)	\
    ( (This)->lpVtbl -> put_Enabled(This,fvarEnabled) ) 

#define ISoftEHCIRootHubPort_get_ConnectStatusChange(This,pfvarConnectStatusChange)	\
    ( (This)->lpVtbl -> get_ConnectStatusChange(This,pfvarConnectStatusChange) ) 

#define ISoftEHCIRootHubPort_put_ConnectStatusChange(This,fvarConnectStatusChange)	\
    ( (This)->lpVtbl -> put_ConnectStatusChange(This,fvarConnectStatusChange) ) 

#define ISoftEHCIRootHubPort_get_CurrentConnectStatus(This,pfvarStatus)	\
    ( (This)->lpVtbl -> get_CurrentConnectStatus(This,pfvarStatus) ) 

#define ISoftEHCIRootHubPort_get_Status(This,plStatus)	\
    ( (This)->lpVtbl -> get_Status(This,plStatus) ) 

#define ISoftEHCIRootHubPort_get_Device(This,ppDSFDevice)	\
    ( (This)->lpVtbl -> get_Device(This,ppDSFDevice) ) 

#define ISoftEHCIRootHubPort_HotPlug(This,pDSFDevice)	\
    ( (This)->lpVtbl -> HotPlug(This,pDSFDevice) ) 

#define ISoftEHCIRootHubPort_Unplug(This)	\
    ( (This)->lpVtbl -> Unplug(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ISoftEHCIRootHubPort_INTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_SoftEHCIRootHubPort;

#ifdef __cplusplus

class DECLSPEC_UUID("6FD5902A-DC5A-4AB4-B9B0-B44D70930C9B")
SoftEHCIRootHubPort;
#endif
#endif /* __SoftEHCI_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\sffdisk.h ===
/*++

Copyright (c) 1993-2003  Microsoft Corporation

Module Name:

    sffdisk.h

Abstract:

    This header file defines constants and types for accessing functionality
    specific to SFF (Small Form Factor) storage devices.


--*/

#ifndef _SFFDISK_H_
#define _SFFDISK_H_

#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning(disable:4200) // array[0] is not a warning for this file


//
// IOCTL codes.
//

#define IOCTL_SFFDISK_QUERY_DEVICE_PROTOCOL \
            CTL_CODE( FILE_DEVICE_DISK, 0x7a0, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_SFFDISK_DEVICE_COMMAND \
            CTL_CODE( FILE_DEVICE_DISK, 0x7a1, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_SFFDISK_DEVICE_PASSWORD \
            CTL_CODE( FILE_DEVICE_DISK, 0x7a2, METHOD_BUFFERED, FILE_WRITE_ACCESS)

//
// Protocol GUIDs that are returned in SFFDISK_QUERY_DEVICE_PROTOCOL_DATA structure
//
#define GUID_SFF_PROTOCOL_SD   { 0xAD7536A8, 0xD055, 0x4c40, { 0xAA, 0x4D, 0x96, 0x31, 0x2D, 0xDB, 0x6B, 0x38 } }

#define GUID_SFF_PROTOCOL_MMC  { 0x77274D3F, 0x2365, 0x4491, { 0xA0, 0x30, 0x8B, 0xB4, 0x4A, 0xE6, 0x00, 0x97 } }

//
// Structures
//


//
// Structure used in IOCTL_SFFDISK_QUERY_DEVICE_PROTOCOL
//

typedef struct _SFFDISK_QUERY_DEVICE_PROTOCOL_DATA {
    //
    // size of this structure in bytes to be filled in by the caller
    //
    USHORT Size;
    USHORT Reserved;

    //
    // This GUID is returned by the protocol which uniquely identifies it.
    //

    GUID ProtocolGUID;

} SFFDISK_QUERY_DEVICE_PROTOCOL_DATA, *PSFFDISK_QUERY_DEVICE_PROTOCOL_DATA;


//
// Structure used in IOCTL_SFFDISK_DEVICE_COMMAND
// The layout of the buffer passed to this IOCTL is as follows:
//
//        +-----------------------------+
//        | header (this structure)     |
//        +-----------------------------+
//        | protocol arguments          |
//        +-----------------------------+
//        | device data buffer          |
//        +-----------------------------+
//
// The actual layout of the protocol arguments depends on the protocol of
// the target device. So as an example, if the target device an SD (Secure Digital)
// storage device, then the protocol arguments would consist of an SDCMD_DESCRIPTOR,
// which is defined in SDDEF.H. The SD argument for the command should be stored
// in the "Information" field of this structure. In that case, ProtocolArgumentSize
// would be sizeof(SDCMD_DESCRIPTOR).
//
// The three size fields in the structure (HeaderSize, ProtocolArgumentSize,
// DeviceDataBufferSize) each hold the length in bytes of each respective area as
// described by the diagram above. Thus, the entire length of the buffer must be
// at least as large as the sum of these three fields.
//


typedef enum {
    SFFDISK_DC_GET_VERSION = 0,
    SFFDISK_DC_LOCK_CHANNEL,
    SFFDISK_DC_UNLOCK_CHANNEL,
    SFFDISK_DC_DEVICE_COMMAND,
} SFFDISK_DCMD;


typedef struct _SFFDISK_DEVICE_COMMAND_DATA {

    //
    // size of this structure in bytes to be filled in by the caller.
    // This size does not include any data concatenated at the end.
    //
    USHORT HeaderSize;

    USHORT Reserved;

    //
    // command defines the type of operation
    //

    SFFDISK_DCMD Command;

    //
    // ProtocolArgumentSize is the length in bytes of the device command
    // arguments specific to the protocol of the device. This data is appended
    // to the structure after the field member "Data".
    //
    USHORT ProtocolArgumentSize;

    //
    // DeviceDataBufferSize defines the length of data being sent to, or received
    // from the device.
    //

    ULONG DeviceDataBufferSize;

    //
    // Information is a parameter or return value for the operation
    //

    ULONG_PTR Information;

    //
    // Beginning of data.
    //

    UCHAR Data[0];

} SFFDISK_DEVICE_COMMAND_DATA, *PSFFDISK_DEVICE_COMMAND_DATA;




//
// Structure used in IOCTL_SFFDISK_DEVICE_PASSWORD
//

typedef enum {
    SFFDISK_DP_IS_SUPPORTED = 0,
    SFFDISK_DP_SET_PASSWORD,
    SFFDISK_DP_LOCK_DEVICE,
    SFFDISK_DP_UNLOCK_DEVICE,
    SFFDISK_DP_RESET_DEVICE_ALL_DATA
} SFFDISK_DPCMD;

typedef struct _SFFDISK_DEVICE_PASSWORD_DATA {
    //
    // size of this structure in bytes to be filled in by the caller
    //
    USHORT Size;
    USHORT Reserved;

    //
    // command defines the type of operation
    //

    SFFDISK_DPCMD Command;

    //
    // Information is a parameter or return value for the operation
    //

    ULONG_PTR Information;

    //
    // Password length and data supplied depend on the operation
    //

    UCHAR PasswordLength;
    UCHAR NewPasswordLength;
    UCHAR Data[0];

} SFFDISK_DEVICE_PASSWORD_DATA, *PSFFDISK_DEVICE_PASSWORD_DATA;



#if _MSC_VER >= 1200
#pragma warning(pop)          // un-sets any local warning changes
#endif
#pragma warning(default:4200) // array[0] is not a warning for this file


#endif // _SFFDISK_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\softhidusbif.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0499 */
/* Compiler settings for softhidusbkif.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__


#ifndef __softhidusbkif_h__
#define __softhidusbkif_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __ISoftHIDProtocolXlator_FWD_DEFINED__
#define __ISoftHIDProtocolXlator_FWD_DEFINED__
typedef interface ISoftHIDProtocolXlator ISoftHIDProtocolXlator;
#endif 	/* __ISoftHIDProtocolXlator_FWD_DEFINED__ */


#ifndef __ISoftHidUsbDevice_FWD_DEFINED__
#define __ISoftHidUsbDevice_FWD_DEFINED__
typedef interface ISoftHidUsbDevice ISoftHidUsbDevice;
#endif 	/* __ISoftHidUsbDevice_FWD_DEFINED__ */


#ifndef __ISoftUSBHidDescriptor_FWD_DEFINED__
#define __ISoftUSBHidDescriptor_FWD_DEFINED__
typedef interface ISoftUSBHidDescriptor ISoftUSBHidDescriptor;
#endif 	/* __ISoftUSBHidDescriptor_FWD_DEFINED__ */


#ifndef __ISoftUSBPhysicalDescriptorSet0_FWD_DEFINED__
#define __ISoftUSBPhysicalDescriptorSet0_FWD_DEFINED__
typedef interface ISoftUSBPhysicalDescriptorSet0 ISoftUSBPhysicalDescriptorSet0;
#endif 	/* __ISoftUSBPhysicalDescriptorSet0_FWD_DEFINED__ */


#ifndef __ISoftUSBPhysicalDescriptorSet_FWD_DEFINED__
#define __ISoftUSBPhysicalDescriptorSet_FWD_DEFINED__
typedef interface ISoftUSBPhysicalDescriptorSet ISoftUSBPhysicalDescriptorSet;
#endif 	/* __ISoftUSBPhysicalDescriptorSet_FWD_DEFINED__ */


#ifndef __ISoftUSBPhysicalDescriptorItem_FWD_DEFINED__
#define __ISoftUSBPhysicalDescriptorItem_FWD_DEFINED__
typedef interface ISoftUSBPhysicalDescriptorItem ISoftUSBPhysicalDescriptorItem;
#endif 	/* __ISoftUSBPhysicalDescriptorItem_FWD_DEFINED__ */


#ifndef __ISoftUSBPhysicalDescriptor_FWD_DEFINED__
#define __ISoftUSBPhysicalDescriptor_FWD_DEFINED__
typedef interface ISoftUSBPhysicalDescriptor ISoftUSBPhysicalDescriptor;
#endif 	/* __ISoftUSBPhysicalDescriptor_FWD_DEFINED__ */


#ifndef __ISoftUSBPhysicalDescriptorSetList_FWD_DEFINED__
#define __ISoftUSBPhysicalDescriptorSetList_FWD_DEFINED__
typedef interface ISoftUSBPhysicalDescriptorSetList ISoftUSBPhysicalDescriptorSetList;
#endif 	/* __ISoftUSBPhysicalDescriptorSetList_FWD_DEFINED__ */


#ifndef __ISoftUSBPhysicalDescriptorItemList_FWD_DEFINED__
#define __ISoftUSBPhysicalDescriptorItemList_FWD_DEFINED__
typedef interface ISoftUSBPhysicalDescriptorItemList ISoftUSBPhysicalDescriptorItemList;
#endif 	/* __ISoftUSBPhysicalDescriptorItemList_FWD_DEFINED__ */


#ifndef __ISoftUSBHidFaultInjection_FWD_DEFINED__
#define __ISoftUSBHidFaultInjection_FWD_DEFINED__
typedef interface ISoftUSBHidFaultInjection ISoftUSBHidFaultInjection;
#endif 	/* __ISoftUSBHidFaultInjection_FWD_DEFINED__ */


#ifndef __SoftHIDProtocolXlator_FWD_DEFINED__
#define __SoftHIDProtocolXlator_FWD_DEFINED__

#ifdef __cplusplus
typedef class SoftHIDProtocolXlator SoftHIDProtocolXlator;
#else
typedef struct SoftHIDProtocolXlator SoftHIDProtocolXlator;
#endif /* __cplusplus */

#endif 	/* __SoftHIDProtocolXlator_FWD_DEFINED__ */


#ifndef __SoftHidUsbDevice_FWD_DEFINED__
#define __SoftHidUsbDevice_FWD_DEFINED__

#ifdef __cplusplus
typedef class SoftHidUsbDevice SoftHidUsbDevice;
#else
typedef struct SoftHidUsbDevice SoftHidUsbDevice;
#endif /* __cplusplus */

#endif 	/* __SoftHidUsbDevice_FWD_DEFINED__ */


#ifndef __SoftUSBHidDescriptor_FWD_DEFINED__
#define __SoftUSBHidDescriptor_FWD_DEFINED__

#ifdef __cplusplus
typedef class SoftUSBHidDescriptor SoftUSBHidDescriptor;
#else
typedef struct SoftUSBHidDescriptor SoftUSBHidDescriptor;
#endif /* __cplusplus */

#endif 	/* __SoftUSBHidDescriptor_FWD_DEFINED__ */


#ifndef __SoftUSBPhysicalDescriptor_FWD_DEFINED__
#define __SoftUSBPhysicalDescriptor_FWD_DEFINED__

#ifdef __cplusplus
typedef class SoftUSBPhysicalDescriptor SoftUSBPhysicalDescriptor;
#else
typedef struct SoftUSBPhysicalDescriptor SoftUSBPhysicalDescriptor;
#endif /* __cplusplus */

#endif 	/* __SoftUSBPhysicalDescriptor_FWD_DEFINED__ */


#ifndef __SoftUSBPhysicalDescriptorSet0_FWD_DEFINED__
#define __SoftUSBPhysicalDescriptorSet0_FWD_DEFINED__

#ifdef __cplusplus
typedef class SoftUSBPhysicalDescriptorSet0 SoftUSBPhysicalDescriptorSet0;
#else
typedef struct SoftUSBPhysicalDescriptorSet0 SoftUSBPhysicalDescriptorSet0;
#endif /* __cplusplus */

#endif 	/* __SoftUSBPhysicalDescriptorSet0_FWD_DEFINED__ */


#ifndef __SoftUSBPhysicalDescriptorSet_FWD_DEFINED__
#define __SoftUSBPhysicalDescriptorSet_FWD_DEFINED__

#ifdef __cplusplus
typedef class SoftUSBPhysicalDescriptorSet SoftUSBPhysicalDescriptorSet;
#else
typedef struct SoftUSBPhysicalDescriptorSet SoftUSBPhysicalDescriptorSet;
#endif /* __cplusplus */

#endif 	/* __SoftUSBPhysicalDescriptorSet_FWD_DEFINED__ */


#ifndef __SoftUSBPhysicalDescriptorItem_FWD_DEFINED__
#define __SoftUSBPhysicalDescriptorItem_FWD_DEFINED__

#ifdef __cplusplus
typedef class SoftUSBPhysicalDescriptorItem SoftUSBPhysicalDescriptorItem;
#else
typedef struct SoftUSBPhysicalDescriptorItem SoftUSBPhysicalDescriptorItem;
#endif /* __cplusplus */

#endif 	/* __SoftUSBPhysicalDescriptorItem_FWD_DEFINED__ */


#ifndef __SoftUSBPhysicalDescriptorSetList_FWD_DEFINED__
#define __SoftUSBPhysicalDescriptorSetList_FWD_DEFINED__

#ifdef __cplusplus
typedef class SoftUSBPhysicalDescriptorSetList SoftUSBPhysicalDescriptorSetList;
#else
typedef struct SoftUSBPhysicalDescriptorSetList SoftUSBPhysicalDescriptorSetList;
#endif /* __cplusplus */

#endif 	/* __SoftUSBPhysicalDescriptorSetList_FWD_DEFINED__ */


#ifndef __SoftUSBPhysicalDescriptorItemList_FWD_DEFINED__
#define __SoftUSBPhysicalDescriptorItemList_FWD_DEFINED__

#ifdef __cplusplus
typedef class SoftUSBPhysicalDescriptorItemList SoftUSBPhysicalDescriptorItemList;
#else
typedef struct SoftUSBPhysicalDescriptorItemList SoftUSBPhysicalDescriptorItemList;
#endif /* __cplusplus */

#endif 	/* __SoftUSBPhysicalDescriptorItemList_FWD_DEFINED__ */


#ifndef __SoftUSBHidFaultInjection_FWD_DEFINED__
#define __SoftUSBHidFaultInjection_FWD_DEFINED__

#ifdef __cplusplus
typedef class SoftUSBHidFaultInjection SoftUSBHidFaultInjection;
#else
typedef struct SoftUSBHidFaultInjection SoftUSBHidFaultInjection;
#endif /* __cplusplus */

#endif 	/* __SoftUSBHidFaultInjection_FWD_DEFINED__ */


#ifdef __cplusplus
extern "C"{
#endif 



#ifndef __SOFTHIDUSBK_LIBRARY_DEFINED__
#define __SOFTHIDUSBK_LIBRARY_DEFINED__

/* library SOFTHIDUSBK */
/* [helpstringcontext][helpcontext][helpstring][helpstringdll][helpfile][version][lcid][uuid] */ 





















typedef /* [helpstringcontext][helpcontext][helpstring][uuid] */  DECLSPEC_UUID("1E4B562C-9C5D-4506-8FFA-F87CC84CF588") 
enum HID_DEVICETYPE
    {	DEVICE_TYPE_NONE	= 0,
	DEVICE_TYPE_KEYBOARD	= 1,
	DEVICE_TYPE_MOUSE	= 2
    } 	HID_DEVICETYPE;

typedef /* [helpstringcontext][helpcontext][helpstring][uuid] */  DECLSPEC_UUID("4486D19F-E669-4C26-8F30-30584B071AF1") 
enum HID_PHYSICAL_BIAS
    {	BIAS_NA	= 0,
	RIGHT_HAND	= 1,
	LEFT_HAND	= 2,
	BOTH_HANDS	= 3,
	EITHER_HAND	= 4
    } 	HID_PHYSICAL_BIAS;

typedef /* [helpstringcontext][helpcontext][helpstring][uuid] */  DECLSPEC_UUID("5B428086-ACA1-4051-A41A-F4768BDFF6D6") 
enum HID_PHYSICAL_DESIGNATOR
    {	NONE	= 0,
	HAND	= 0x1,
	EYEBALL	= 0x2,
	EYEBROW	= 0x3,
	EYELID	= 0x4,
	EAR	= 0x5,
	NOSE	= 0x6,
	MOUTH	= 0x7,
	UPPER_LIP	= 0x8,
	LOWER_LIP	= 0x9,
	JAW	= 0xa,
	NECK	= 0xb,
	UPPER_ARM	= 0xc,
	ELBOW	= 0xd,
	FOREARM	= 0xe,
	WRIST	= 0xf,
	PALM	= 0x10,
	THUMB	= 0x11,
	INDEX_FINGER	= 0x12,
	MIDDLE_FINGER	= 0x13,
	RING_FINGER	= 0x14,
	LITTLE_FINGER	= 0x15,
	HEAD	= 0x16,
	SHOULDER	= 0x17,
	HIP	= 0x18,
	WAIST	= 0x19,
	THIGH	= 0x1a,
	KNEE	= 0x1b,
	CALF	= 0x1c,
	ANKLE	= 0x1d,
	FOOT	= 0x1e,
	HEEL	= 0x1f,
	BALL_OF_FOOT	= 0x20,
	BIG_TOE	= 0x21,
	SECOND_TOE	= 0x22,
	THIRD_TOE	= 0x23,
	FOURTH_TOE	= 0x24,
	LITTLE_TOE	= 0x25,
	BROW	= 0x26,
	CHEEK	= 0x27
    } 	HID_PHYSICAL_DESIGNATOR;

typedef /* [helpstringcontext][helpcontext][helpstring][uuid] */  DECLSPEC_UUID("4531738B-4AAC-48E2-9B8E-F97A98AA2967") 
enum HID_PHYSICAL_QUALIFIER
    {	QUALIFIER_NA	= 0,
	RIGHT	= 1,
	LEFT	= 2,
	BOTH	= 3,
	EITHER	= 4,
	CENTER	= 5
    } 	HID_PHYSICAL_QUALIFIER;


EXTERN_C const IID LIBID_SOFTHIDUSBK;

#ifndef __ISoftHIDProtocolXlator_INTERFACE_DEFINED__
#define __ISoftHIDProtocolXlator_INTERFACE_DEFINED__

/* interface ISoftHIDProtocolXlator */
/* [helpstringcontext][helpcontext][helpstring][object][hidden][nonextensible][oleautomation][dual][uuid] */ 


EXTERN_C const IID IID_ISoftHIDProtocolXlator;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("78C6932B-1B53-469F-9DE3-38114BE3B41E")
    ISoftHIDProtocolXlator : public IDispatch
    {
    public:
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_DeviceType( 
            /* [retval][out] */ __RPC__out HID_DEVICETYPE *pDevType) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT __stdcall put_DeviceType( 
            /* [in] */ HID_DEVICETYPE DevType) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_DSFDevice( 
            /* [retval][out] */ __RPC__deref_out_opt /* external definition not present */ IDSFDevice **ppiDSFDevice) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_HIDDescriptor( 
            /* [retval][out] */ __RPC__deref_out_opt ISoftUSBHidDescriptor **ppSoftUSBHIDDescriptor) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT __stdcall put_HIDDescriptor( 
            /* [in] */ __RPC__in_opt ISoftUSBHidDescriptor *pSoftUSBHIDDescriptor) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propputref][id] */ HRESULT __stdcall putref_HIDDescriptor( 
            /* [in] */ __RPC__in_opt ISoftUSBHidDescriptor *pSoftUSBHIDDescriptor) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][id] */ HRESULT __stdcall WriteReportDescriptor( 
            /* [in] */ __RPC__in SAFEARRAY * psaReportDescriptor) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][id] */ HRESULT __stdcall ReadOutputReport( 
            /* [retval][out] */ __RPC__deref_out_opt SAFEARRAY * *ppsaOutputReport) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][id] */ HRESULT __stdcall WriteInputReport( 
            /* [in] */ __RPC__in SAFEARRAY * psaInputReport) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][id] */ HRESULT __stdcall WriteFeatureReport( 
            /* [in] */ __RPC__in SAFEARRAY * psaFeatureReport) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISoftHIDProtocolXlatorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISoftHIDProtocolXlator * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISoftHIDProtocolXlator * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISoftHIDProtocolXlator * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ISoftHIDProtocolXlator * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ISoftHIDProtocolXlator * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ISoftHIDProtocolXlator * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ISoftHIDProtocolXlator * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_DeviceType )( 
            ISoftHIDProtocolXlator * This,
            /* [retval][out] */ __RPC__out HID_DEVICETYPE *pDevType);
        
        /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT ( __stdcall *put_DeviceType )( 
            ISoftHIDProtocolXlator * This,
            /* [in] */ HID_DEVICETYPE DevType);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_DSFDevice )( 
            ISoftHIDProtocolXlator * This,
            /* [retval][out] */ __RPC__deref_out_opt /* external definition not present */ IDSFDevice **ppiDSFDevice);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_HIDDescriptor )( 
            ISoftHIDProtocolXlator * This,
            /* [retval][out] */ __RPC__deref_out_opt ISoftUSBHidDescriptor **ppSoftUSBHIDDescriptor);
        
        /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT ( __stdcall *put_HIDDescriptor )( 
            ISoftHIDProtocolXlator * This,
            /* [in] */ __RPC__in_opt ISoftUSBHidDescriptor *pSoftUSBHIDDescriptor);
        
        /* [helpstringcontext][helpcontext][helpstring][propputref][id] */ HRESULT ( __stdcall *putref_HIDDescriptor )( 
            ISoftHIDProtocolXlator * This,
            /* [in] */ __RPC__in_opt ISoftUSBHidDescriptor *pSoftUSBHIDDescriptor);
        
        /* [helpstringcontext][helpcontext][helpstring][id] */ HRESULT ( __stdcall *WriteReportDescriptor )( 
            ISoftHIDProtocolXlator * This,
            /* [in] */ __RPC__in SAFEARRAY * psaReportDescriptor);
        
        /* [helpstringcontext][helpcontext][helpstring][id] */ HRESULT ( __stdcall *ReadOutputReport )( 
            ISoftHIDProtocolXlator * This,
            /* [retval][out] */ __RPC__deref_out_opt SAFEARRAY * *ppsaOutputReport);
        
        /* [helpstringcontext][helpcontext][helpstring][id] */ HRESULT ( __stdcall *WriteInputReport )( 
            ISoftHIDProtocolXlator * This,
            /* [in] */ __RPC__in SAFEARRAY * psaInputReport);
        
        /* [helpstringcontext][helpcontext][helpstring][id] */ HRESULT ( __stdcall *WriteFeatureReport )( 
            ISoftHIDProtocolXlator * This,
            /* [in] */ __RPC__in SAFEARRAY * psaFeatureReport);
        
        END_INTERFACE
    } ISoftHIDProtocolXlatorVtbl;

    interface ISoftHIDProtocolXlator
    {
        CONST_VTBL struct ISoftHIDProtocolXlatorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISoftHIDProtocolXlator_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ISoftHIDProtocolXlator_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ISoftHIDProtocolXlator_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ISoftHIDProtocolXlator_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ISoftHIDProtocolXlator_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ISoftHIDProtocolXlator_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ISoftHIDProtocolXlator_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ISoftHIDProtocolXlator_get_DeviceType(This,pDevType)	\
    ( (This)->lpVtbl -> get_DeviceType(This,pDevType) ) 

#define ISoftHIDProtocolXlator_put_DeviceType(This,DevType)	\
    ( (This)->lpVtbl -> put_DeviceType(This,DevType) ) 

#define ISoftHIDProtocolXlator_get_DSFDevice(This,ppiDSFDevice)	\
    ( (This)->lpVtbl -> get_DSFDevice(This,ppiDSFDevice) ) 

#define ISoftHIDProtocolXlator_get_HIDDescriptor(This,ppSoftUSBHIDDescriptor)	\
    ( (This)->lpVtbl -> get_HIDDescriptor(This,ppSoftUSBHIDDescriptor) ) 

#define ISoftHIDProtocolXlator_put_HIDDescriptor(This,pSoftUSBHIDDescriptor)	\
    ( (This)->lpVtbl -> put_HIDDescriptor(This,pSoftUSBHIDDescriptor) ) 

#define ISoftHIDProtocolXlator_putref_HIDDescriptor(This,pSoftUSBHIDDescriptor)	\
    ( (This)->lpVtbl -> putref_HIDDescriptor(This,pSoftUSBHIDDescriptor) ) 

#define ISoftHIDProtocolXlator_WriteReportDescriptor(This,psaReportDescriptor)	\
    ( (This)->lpVtbl -> WriteReportDescriptor(This,psaReportDescriptor) ) 

#define ISoftHIDProtocolXlator_ReadOutputReport(This,ppsaOutputReport)	\
    ( (This)->lpVtbl -> ReadOutputReport(This,ppsaOutputReport) ) 

#define ISoftHIDProtocolXlator_WriteInputReport(This,psaInputReport)	\
    ( (This)->lpVtbl -> WriteInputReport(This,psaInputReport) ) 

#define ISoftHIDProtocolXlator_WriteFeatureReport(This,psaFeatureReport)	\
    ( (This)->lpVtbl -> WriteFeatureReport(This,psaFeatureReport) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ISoftHIDProtocolXlator_INTERFACE_DEFINED__ */


#ifndef __ISoftHidUsbDevice_INTERFACE_DEFINED__
#define __ISoftHidUsbDevice_INTERFACE_DEFINED__

/* interface ISoftHidUsbDevice */
/* [helpstringcontext][helpcontext][helpstring][object][hidden][nonextensible][oleautomation][dual][uuid] */ 


EXTERN_C const IID IID_ISoftHidUsbDevice;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("45332C25-A9E0-457B-AA5D-897A36B92ACB")
    ISoftHidUsbDevice : public IDispatch
    {
    public:
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_PhysicalDescriptor( 
            /* [retval][out] */ __RPC__deref_out_opt ISoftUSBPhysicalDescriptor **ppSoftUSBPhyDescriptor) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT __stdcall put_PhysicalDescriptor( 
            /* [in] */ __RPC__in_opt ISoftUSBPhysicalDescriptor *pSoftUSBPhyDescriptor) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propputref][id] */ HRESULT __stdcall putref_PhysicalDescriptor( 
            /* [in] */ __RPC__in_opt ISoftUSBPhysicalDescriptor *pSoftUSBPhyDescriptor) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_ReportDescriptor( 
            /* [retval][out] */ __RPC__deref_out_opt SAFEARRAY * *ppsaSoftUSBReportDescriptor) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT __stdcall put_ReportDescriptor( 
            /* [in] */ __RPC__in SAFEARRAY * psaSoftUSBReportDescriptor) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][id] */ HRESULT __stdcall QueueInputReport( 
            /* [in] */ ULONG cbData,
            /* [in] */ __RPC__in BYTE *pbData) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][id] */ HRESULT __stdcall DequeueOutputReport( 
            /* [out] */ __RPC__out ULONG *pcbData,
            /* [out] */ __RPC__deref_out_opt BYTE **ppbData) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][id] */ HRESULT __stdcall QueueFeatureReport( 
            /* [in] */ ULONG cbData,
            /* [in] */ __RPC__in BYTE *pbData) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISoftHidUsbDeviceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISoftHidUsbDevice * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISoftHidUsbDevice * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISoftHidUsbDevice * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ISoftHidUsbDevice * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ISoftHidUsbDevice * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ISoftHidUsbDevice * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ISoftHidUsbDevice * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_PhysicalDescriptor )( 
            ISoftHidUsbDevice * This,
            /* [retval][out] */ __RPC__deref_out_opt ISoftUSBPhysicalDescriptor **ppSoftUSBPhyDescriptor);
        
        /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT ( __stdcall *put_PhysicalDescriptor )( 
            ISoftHidUsbDevice * This,
            /* [in] */ __RPC__in_opt ISoftUSBPhysicalDescriptor *pSoftUSBPhyDescriptor);
        
        /* [helpstringcontext][helpcontext][helpstring][propputref][id] */ HRESULT ( __stdcall *putref_PhysicalDescriptor )( 
            ISoftHidUsbDevice * This,
            /* [in] */ __RPC__in_opt ISoftUSBPhysicalDescriptor *pSoftUSBPhyDescriptor);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_ReportDescriptor )( 
            ISoftHidUsbDevice * This,
            /* [retval][out] */ __RPC__deref_out_opt SAFEARRAY * *ppsaSoftUSBReportDescriptor);
        
        /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT ( __stdcall *put_ReportDescriptor )( 
            ISoftHidUsbDevice * This,
            /* [in] */ __RPC__in SAFEARRAY * psaSoftUSBReportDescriptor);
        
        /* [helpstringcontext][helpcontext][helpstring][id] */ HRESULT ( __stdcall *QueueInputReport )( 
            ISoftHidUsbDevice * This,
            /* [in] */ ULONG cbData,
            /* [in] */ __RPC__in BYTE *pbData);
        
        /* [helpstringcontext][helpcontext][helpstring][id] */ HRESULT ( __stdcall *DequeueOutputReport )( 
            ISoftHidUsbDevice * This,
            /* [out] */ __RPC__out ULONG *pcbData,
            /* [out] */ __RPC__deref_out_opt BYTE **ppbData);
        
        /* [helpstringcontext][helpcontext][helpstring][id] */ HRESULT ( __stdcall *QueueFeatureReport )( 
            ISoftHidUsbDevice * This,
            /* [in] */ ULONG cbData,
            /* [in] */ __RPC__in BYTE *pbData);
        
        END_INTERFACE
    } ISoftHidUsbDeviceVtbl;

    interface ISoftHidUsbDevice
    {
        CONST_VTBL struct ISoftHidUsbDeviceVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISoftHidUsbDevice_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ISoftHidUsbDevice_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ISoftHidUsbDevice_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ISoftHidUsbDevice_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ISoftHidUsbDevice_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ISoftHidUsbDevice_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ISoftHidUsbDevice_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ISoftHidUsbDevice_get_PhysicalDescriptor(This,ppSoftUSBPhyDescriptor)	\
    ( (This)->lpVtbl -> get_PhysicalDescriptor(This,ppSoftUSBPhyDescriptor) ) 

#define ISoftHidUsbDevice_put_PhysicalDescriptor(This,pSoftUSBPhyDescriptor)	\
    ( (This)->lpVtbl -> put_PhysicalDescriptor(This,pSoftUSBPhyDescriptor) ) 

#define ISoftHidUsbDevice_putref_PhysicalDescriptor(This,pSoftUSBPhyDescriptor)	\
    ( (This)->lpVtbl -> putref_PhysicalDescriptor(This,pSoftUSBPhyDescriptor) ) 

#define ISoftHidUsbDevice_get_ReportDescriptor(This,ppsaSoftUSBReportDescriptor)	\
    ( (This)->lpVtbl -> get_ReportDescriptor(This,ppsaSoftUSBReportDescriptor) ) 

#define ISoftHidUsbDevice_put_ReportDescriptor(This,psaSoftUSBReportDescriptor)	\
    ( (This)->lpVtbl -> put_ReportDescriptor(This,psaSoftUSBReportDescriptor) ) 

#define ISoftHidUsbDevice_QueueInputReport(This,cbData,pbData)	\
    ( (This)->lpVtbl -> QueueInputReport(This,cbData,pbData) ) 

#define ISoftHidUsbDevice_DequeueOutputReport(This,pcbData,ppbData)	\
    ( (This)->lpVtbl -> DequeueOutputReport(This,pcbData,ppbData) ) 

#define ISoftHidUsbDevice_QueueFeatureReport(This,cbData,pbData)	\
    ( (This)->lpVtbl -> QueueFeatureReport(This,cbData,pbData) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ISoftHidUsbDevice_INTERFACE_DEFINED__ */


#ifndef __ISoftUSBHidDescriptor_INTERFACE_DEFINED__
#define __ISoftUSBHidDescriptor_INTERFACE_DEFINED__

/* interface ISoftUSBHidDescriptor */
/* [helpstringcontext][helpcontext][helpstring][object][hidden][nonextensible][oleautomation][dual][uuid] */ 


EXTERN_C const IID IID_ISoftUSBHidDescriptor;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("7E4BAE25-09D9-4DB8-8CEC-6D089D87F5EE")
    ISoftUSBHidDescriptor : public IDispatch
    {
    public:
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_Length( 
            /* [retval][out] */ __RPC__out BYTE *pbyLength) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_DescriptorType( 
            /* [retval][out] */ __RPC__out BYTE *pbyDescriptorType) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_HID( 
            /* [retval][out] */ __RPC__out SHORT *psHID) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT __stdcall put_HID( 
            /* [in] */ SHORT sHID) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_CountryCode( 
            /* [retval][out] */ __RPC__out BYTE *pbyCountryCode) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT __stdcall put_CountryCode( 
            /* [in] */ BYTE byCountryCode) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_NumDescriptors( 
            /* [retval][out] */ __RPC__out BYTE *pbyNumDescriptors) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT __stdcall put_NumDescriptors( 
            /* [in] */ BYTE byNumDescriptors) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_ClassDescriptorType( 
            /* [in] */ BYTE byIndex,
            /* [retval][out] */ __RPC__out BYTE *pbyClassDescriptorType) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT __stdcall put_ClassDescriptorType( 
            /* [in] */ BYTE byIndex,
            /* [in] */ BYTE byClassDescriptorType) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_DescriptorLength( 
            /* [in] */ BYTE byIndex,
            /* [retval][out] */ __RPC__out SHORT *psDescriptorLength) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT __stdcall put_DescriptorLength( 
            /* [in] */ BYTE byIndex,
            /* [in] */ SHORT sDescriptorLength) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISoftUSBHidDescriptorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISoftUSBHidDescriptor * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISoftUSBHidDescriptor * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISoftUSBHidDescriptor * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ISoftUSBHidDescriptor * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ISoftUSBHidDescriptor * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ISoftUSBHidDescriptor * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ISoftUSBHidDescriptor * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_Length )( 
            ISoftUSBHidDescriptor * This,
            /* [retval][out] */ __RPC__out BYTE *pbyLength);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_DescriptorType )( 
            ISoftUSBHidDescriptor * This,
            /* [retval][out] */ __RPC__out BYTE *pbyDescriptorType);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_HID )( 
            ISoftUSBHidDescriptor * This,
            /* [retval][out] */ __RPC__out SHORT *psHID);
        
        /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT ( __stdcall *put_HID )( 
            ISoftUSBHidDescriptor * This,
            /* [in] */ SHORT sHID);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_CountryCode )( 
            ISoftUSBHidDescriptor * This,
            /* [retval][out] */ __RPC__out BYTE *pbyCountryCode);
        
        /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT ( __stdcall *put_CountryCode )( 
            ISoftUSBHidDescriptor * This,
            /* [in] */ BYTE byCountryCode);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_NumDescriptors )( 
            ISoftUSBHidDescriptor * This,
            /* [retval][out] */ __RPC__out BYTE *pbyNumDescriptors);
        
        /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT ( __stdcall *put_NumDescriptors )( 
            ISoftUSBHidDescriptor * This,
            /* [in] */ BYTE byNumDescriptors);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_ClassDescriptorType )( 
            ISoftUSBHidDescriptor * This,
            /* [in] */ BYTE byIndex,
            /* [retval][out] */ __RPC__out BYTE *pbyClassDescriptorType);
        
        /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT ( __stdcall *put_ClassDescriptorType )( 
            ISoftUSBHidDescriptor * This,
            /* [in] */ BYTE byIndex,
            /* [in] */ BYTE byClassDescriptorType);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_DescriptorLength )( 
            ISoftUSBHidDescriptor * This,
            /* [in] */ BYTE byIndex,
            /* [retval][out] */ __RPC__out SHORT *psDescriptorLength);
        
        /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT ( __stdcall *put_DescriptorLength )( 
            ISoftUSBHidDescriptor * This,
            /* [in] */ BYTE byIndex,
            /* [in] */ SHORT sDescriptorLength);
        
        END_INTERFACE
    } ISoftUSBHidDescriptorVtbl;

    interface ISoftUSBHidDescriptor
    {
        CONST_VTBL struct ISoftUSBHidDescriptorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISoftUSBHidDescriptor_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ISoftUSBHidDescriptor_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ISoftUSBHidDescriptor_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ISoftUSBHidDescriptor_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ISoftUSBHidDescriptor_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ISoftUSBHidDescriptor_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ISoftUSBHidDescriptor_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ISoftUSBHidDescriptor_get_Length(This,pbyLength)	\
    ( (This)->lpVtbl -> get_Length(This,pbyLength) ) 

#define ISoftUSBHidDescriptor_get_DescriptorType(This,pbyDescriptorType)	\
    ( (This)->lpVtbl -> get_DescriptorType(This,pbyDescriptorType) ) 

#define ISoftUSBHidDescriptor_get_HID(This,psHID)	\
    ( (This)->lpVtbl -> get_HID(This,psHID) ) 

#define ISoftUSBHidDescriptor_put_HID(This,sHID)	\
    ( (This)->lpVtbl -> put_HID(This,sHID) ) 

#define ISoftUSBHidDescriptor_get_CountryCode(This,pbyCountryCode)	\
    ( (This)->lpVtbl -> get_CountryCode(This,pbyCountryCode) ) 

#define ISoftUSBHidDescriptor_put_CountryCode(This,byCountryCode)	\
    ( (This)->lpVtbl -> put_CountryCode(This,byCountryCode) ) 

#define ISoftUSBHidDescriptor_get_NumDescriptors(This,pbyNumDescriptors)	\
    ( (This)->lpVtbl -> get_NumDescriptors(This,pbyNumDescriptors) ) 

#define ISoftUSBHidDescriptor_put_NumDescriptors(This,byNumDescriptors)	\
    ( (This)->lpVtbl -> put_NumDescriptors(This,byNumDescriptors) ) 

#define ISoftUSBHidDescriptor_get_ClassDescriptorType(This,byIndex,pbyClassDescriptorType)	\
    ( (This)->lpVtbl -> get_ClassDescriptorType(This,byIndex,pbyClassDescriptorType) ) 

#define ISoftUSBHidDescriptor_put_ClassDescriptorType(This,byIndex,byClassDescriptorType)	\
    ( (This)->lpVtbl -> put_ClassDescriptorType(This,byIndex,byClassDescriptorType) ) 

#define ISoftUSBHidDescriptor_get_DescriptorLength(This,byIndex,psDescriptorLength)	\
    ( (This)->lpVtbl -> get_DescriptorLength(This,byIndex,psDescriptorLength) ) 

#define ISoftUSBHidDescriptor_put_DescriptorLength(This,byIndex,sDescriptorLength)	\
    ( (This)->lpVtbl -> put_DescriptorLength(This,byIndex,sDescriptorLength) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ISoftUSBHidDescriptor_INTERFACE_DEFINED__ */


#ifndef __ISoftUSBPhysicalDescriptorSet0_INTERFACE_DEFINED__
#define __ISoftUSBPhysicalDescriptorSet0_INTERFACE_DEFINED__

/* interface ISoftUSBPhysicalDescriptorSet0 */
/* [helpstringcontext][helpcontext][helpstring][object][hidden][nonextensible][oleautomation][dual][uuid] */ 


EXTERN_C const IID IID_ISoftUSBPhysicalDescriptorSet0;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("F9573761-15AA-46D1-9FE0-16254E001F4C")
    ISoftUSBPhysicalDescriptorSet0 : public IDispatch
    {
    public:
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_Number( 
            /* [retval][out] */ __RPC__out BYTE *pNumber) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT __stdcall put_Number( 
            /* [in] */ BYTE Number) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_Length( 
            /* [retval][out] */ __RPC__out BYTE *pLength) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT __stdcall put_Length( 
            /* [in] */ BYTE Length) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISoftUSBPhysicalDescriptorSet0Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISoftUSBPhysicalDescriptorSet0 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISoftUSBPhysicalDescriptorSet0 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISoftUSBPhysicalDescriptorSet0 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ISoftUSBPhysicalDescriptorSet0 * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ISoftUSBPhysicalDescriptorSet0 * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ISoftUSBPhysicalDescriptorSet0 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ISoftUSBPhysicalDescriptorSet0 * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_Number )( 
            ISoftUSBPhysicalDescriptorSet0 * This,
            /* [retval][out] */ __RPC__out BYTE *pNumber);
        
        /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT ( __stdcall *put_Number )( 
            ISoftUSBPhysicalDescriptorSet0 * This,
            /* [in] */ BYTE Number);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_Length )( 
            ISoftUSBPhysicalDescriptorSet0 * This,
            /* [retval][out] */ __RPC__out BYTE *pLength);
        
        /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT ( __stdcall *put_Length )( 
            ISoftUSBPhysicalDescriptorSet0 * This,
            /* [in] */ BYTE Length);
        
        END_INTERFACE
    } ISoftUSBPhysicalDescriptorSet0Vtbl;

    interface ISoftUSBPhysicalDescriptorSet0
    {
        CONST_VTBL struct ISoftUSBPhysicalDescriptorSet0Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISoftUSBPhysicalDescriptorSet0_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ISoftUSBPhysicalDescriptorSet0_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ISoftUSBPhysicalDescriptorSet0_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ISoftUSBPhysicalDescriptorSet0_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ISoftUSBPhysicalDescriptorSet0_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ISoftUSBPhysicalDescriptorSet0_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ISoftUSBPhysicalDescriptorSet0_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ISoftUSBPhysicalDescriptorSet0_get_Number(This,pNumber)	\
    ( (This)->lpVtbl -> get_Number(This,pNumber) ) 

#define ISoftUSBPhysicalDescriptorSet0_put_Number(This,Number)	\
    ( (This)->lpVtbl -> put_Number(This,Number) ) 

#define ISoftUSBPhysicalDescriptorSet0_get_Length(This,pLength)	\
    ( (This)->lpVtbl -> get_Length(This,pLength) ) 

#define ISoftUSBPhysicalDescriptorSet0_put_Length(This,Length)	\
    ( (This)->lpVtbl -> put_Length(This,Length) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ISoftUSBPhysicalDescriptorSet0_INTERFACE_DEFINED__ */


#ifndef __ISoftUSBPhysicalDescriptorSet_INTERFACE_DEFINED__
#define __ISoftUSBPhysicalDescriptorSet_INTERFACE_DEFINED__

/* interface ISoftUSBPhysicalDescriptorSet */
/* [helpstringcontext][helpcontext][helpstring][object][hidden][nonextensible][oleautomation][dual][uuid] */ 


EXTERN_C const IID IID_ISoftUSBPhysicalDescriptorSet;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1FB119F2-5613-4D6E-AE93-87584F8C4401")
    ISoftUSBPhysicalDescriptorSet : public IDispatch
    {
    public:
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_Bias( 
            /* [retval][out] */ __RPC__out HID_PHYSICAL_BIAS *pBias) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT __stdcall put_Bias( 
            /* [in] */ HID_PHYSICAL_BIAS Bias) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_Preference( 
            /* [retval][out] */ __RPC__out BYTE *pPreference) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT __stdcall put_Preference( 
            /* [in] */ BYTE Preference) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_Items( 
            /* [retval][out] */ __RPC__deref_out_opt ISoftUSBPhysicalDescriptorItemList **ppItems) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISoftUSBPhysicalDescriptorSetVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISoftUSBPhysicalDescriptorSet * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISoftUSBPhysicalDescriptorSet * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISoftUSBPhysicalDescriptorSet * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ISoftUSBPhysicalDescriptorSet * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ISoftUSBPhysicalDescriptorSet * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ISoftUSBPhysicalDescriptorSet * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ISoftUSBPhysicalDescriptorSet * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_Bias )( 
            ISoftUSBPhysicalDescriptorSet * This,
            /* [retval][out] */ __RPC__out HID_PHYSICAL_BIAS *pBias);
        
        /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT ( __stdcall *put_Bias )( 
            ISoftUSBPhysicalDescriptorSet * This,
            /* [in] */ HID_PHYSICAL_BIAS Bias);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_Preference )( 
            ISoftUSBPhysicalDescriptorSet * This,
            /* [retval][out] */ __RPC__out BYTE *pPreference);
        
        /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT ( __stdcall *put_Preference )( 
            ISoftUSBPhysicalDescriptorSet * This,
            /* [in] */ BYTE Preference);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_Items )( 
            ISoftUSBPhysicalDescriptorSet * This,
            /* [retval][out] */ __RPC__deref_out_opt ISoftUSBPhysicalDescriptorItemList **ppItems);
        
        END_INTERFACE
    } ISoftUSBPhysicalDescriptorSetVtbl;

    interface ISoftUSBPhysicalDescriptorSet
    {
        CONST_VTBL struct ISoftUSBPhysicalDescriptorSetVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISoftUSBPhysicalDescriptorSet_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ISoftUSBPhysicalDescriptorSet_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ISoftUSBPhysicalDescriptorSet_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ISoftUSBPhysicalDescriptorSet_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ISoftUSBPhysicalDescriptorSet_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ISoftUSBPhysicalDescriptorSet_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ISoftUSBPhysicalDescriptorSet_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ISoftUSBPhysicalDescriptorSet_get_Bias(This,pBias)	\
    ( (This)->lpVtbl -> get_Bias(This,pBias) ) 

#define ISoftUSBPhysicalDescriptorSet_put_Bias(This,Bias)	\
    ( (This)->lpVtbl -> put_Bias(This,Bias) ) 

#define ISoftUSBPhysicalDescriptorSet_get_Preference(This,pPreference)	\
    ( (This)->lpVtbl -> get_Preference(This,pPreference) ) 

#define ISoftUSBPhysicalDescriptorSet_put_Preference(This,Preference)	\
    ( (This)->lpVtbl -> put_Preference(This,Preference) ) 

#define ISoftUSBPhysicalDescriptorSet_get_Items(This,ppItems)	\
    ( (This)->lpVtbl -> get_Items(This,ppItems) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ISoftUSBPhysicalDescriptorSet_INTERFACE_DEFINED__ */


#ifndef __ISoftUSBPhysicalDescriptorItem_INTERFACE_DEFINED__
#define __ISoftUSBPhysicalDescriptorItem_INTERFACE_DEFINED__

/* interface ISoftUSBPhysicalDescriptorItem */
/* [helpstringcontext][helpcontext][helpstring][object][hidden][nonextensible][oleautomation][dual][uuid] */ 


EXTERN_C const IID IID_ISoftUSBPhysicalDescriptorItem;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("904F9501-5208-409E-9F6C-67416876964A")
    ISoftUSBPhysicalDescriptorItem : public IDispatch
    {
    public:
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_Designator( 
            /* [retval][out] */ __RPC__out HID_PHYSICAL_DESIGNATOR *pDesignator) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT __stdcall put_Designator( 
            /* [in] */ HID_PHYSICAL_DESIGNATOR Designator) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_Flags( 
            /* [retval][out] */ __RPC__out BYTE *pFlags) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT __stdcall put_Flags( 
            /* [in] */ BYTE Flags) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_Qualifier( 
            /* [retval][out] */ __RPC__out HID_PHYSICAL_QUALIFIER *pQualifier) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT __stdcall put_Qualifier( 
            /* [in] */ HID_PHYSICAL_QUALIFIER Qualifier) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_Effort( 
            /* [retval][out] */ __RPC__out BYTE *pEffort) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT __stdcall put_Effort( 
            /* [in] */ BYTE Effort) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISoftUSBPhysicalDescriptorItemVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISoftUSBPhysicalDescriptorItem * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISoftUSBPhysicalDescriptorItem * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISoftUSBPhysicalDescriptorItem * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ISoftUSBPhysicalDescriptorItem * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ISoftUSBPhysicalDescriptorItem * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ISoftUSBPhysicalDescriptorItem * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ISoftUSBPhysicalDescriptorItem * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_Designator )( 
            ISoftUSBPhysicalDescriptorItem * This,
            /* [retval][out] */ __RPC__out HID_PHYSICAL_DESIGNATOR *pDesignator);
        
        /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT ( __stdcall *put_Designator )( 
            ISoftUSBPhysicalDescriptorItem * This,
            /* [in] */ HID_PHYSICAL_DESIGNATOR Designator);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_Flags )( 
            ISoftUSBPhysicalDescriptorItem * This,
            /* [retval][out] */ __RPC__out BYTE *pFlags);
        
        /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT ( __stdcall *put_Flags )( 
            ISoftUSBPhysicalDescriptorItem * This,
            /* [in] */ BYTE Flags);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_Qualifier )( 
            ISoftUSBPhysicalDescriptorItem * This,
            /* [retval][out] */ __RPC__out HID_PHYSICAL_QUALIFIER *pQualifier);
        
        /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT ( __stdcall *put_Qualifier )( 
            ISoftUSBPhysicalDescriptorItem * This,
            /* [in] */ HID_PHYSICAL_QUALIFIER Qualifier);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_Effort )( 
            ISoftUSBPhysicalDescriptorItem * This,
            /* [retval][out] */ __RPC__out BYTE *pEffort);
        
        /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT ( __stdcall *put_Effort )( 
            ISoftUSBPhysicalDescriptorItem * This,
            /* [in] */ BYTE Effort);
        
        END_INTERFACE
    } ISoftUSBPhysicalDescriptorItemVtbl;

    interface ISoftUSBPhysicalDescriptorItem
    {
        CONST_VTBL struct ISoftUSBPhysicalDescriptorItemVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISoftUSBPhysicalDescriptorItem_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ISoftUSBPhysicalDescriptorItem_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ISoftUSBPhysicalDescriptorItem_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ISoftUSBPhysicalDescriptorItem_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ISoftUSBPhysicalDescriptorItem_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ISoftUSBPhysicalDescriptorItem_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ISoftUSBPhysicalDescriptorItem_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ISoftUSBPhysicalDescriptorItem_get_Designator(This,pDesignator)	\
    ( (This)->lpVtbl -> get_Designator(This,pDesignator) ) 

#define ISoftUSBPhysicalDescriptorItem_put_Designator(This,Designator)	\
    ( (This)->lpVtbl -> put_Designator(This,Designator) ) 

#define ISoftUSBPhysicalDescriptorItem_get_Flags(This,pFlags)	\
    ( (This)->lpVtbl -> get_Flags(This,pFlags) ) 

#define ISoftUSBPhysicalDescriptorItem_put_Flags(This,Flags)	\
    ( (This)->lpVtbl -> put_Flags(This,Flags) ) 

#define ISoftUSBPhysicalDescriptorItem_get_Qualifier(This,pQualifier)	\
    ( (This)->lpVtbl -> get_Qualifier(This,pQualifier) ) 

#define ISoftUSBPhysicalDescriptorItem_put_Qualifier(This,Qualifier)	\
    ( (This)->lpVtbl -> put_Qualifier(This,Qualifier) ) 

#define ISoftUSBPhysicalDescriptorItem_get_Effort(This,pEffort)	\
    ( (This)->lpVtbl -> get_Effort(This,pEffort) ) 

#define ISoftUSBPhysicalDescriptorItem_put_Effort(This,Effort)	\
    ( (This)->lpVtbl -> put_Effort(This,Effort) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ISoftUSBPhysicalDescriptorItem_INTERFACE_DEFINED__ */


#ifndef __ISoftUSBPhysicalDescriptor_INTERFACE_DEFINED__
#define __ISoftUSBPhysicalDescriptor_INTERFACE_DEFINED__

/* interface ISoftUSBPhysicalDescriptor */
/* [helpstringcontext][helpcontext][helpstring][object][hidden][nonextensible][oleautomation][dual][uuid] */ 


EXTERN_C const IID IID_ISoftUSBPhysicalDescriptor;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0C192F43-ACC3-4CF7-A823-B14FCFF082A1")
    ISoftUSBPhysicalDescriptor : public IDispatch
    {
    public:
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_Set0( 
            /* [retval][out] */ __RPC__deref_out_opt ISoftUSBPhysicalDescriptorSet0 **ppSet0) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT __stdcall put_Set0( 
            /* [in] */ __RPC__in_opt ISoftUSBPhysicalDescriptorSet0 *pSet0) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propputref][id] */ HRESULT __stdcall putref_Set0( 
            /* [in] */ __RPC__in_opt ISoftUSBPhysicalDescriptorSet0 *pSet0) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_Sets( 
            /* [retval][out] */ __RPC__deref_out_opt ISoftUSBPhysicalDescriptorSetList **ppSets) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISoftUSBPhysicalDescriptorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISoftUSBPhysicalDescriptor * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISoftUSBPhysicalDescriptor * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISoftUSBPhysicalDescriptor * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ISoftUSBPhysicalDescriptor * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ISoftUSBPhysicalDescriptor * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ISoftUSBPhysicalDescriptor * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ISoftUSBPhysicalDescriptor * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_Set0 )( 
            ISoftUSBPhysicalDescriptor * This,
            /* [retval][out] */ __RPC__deref_out_opt ISoftUSBPhysicalDescriptorSet0 **ppSet0);
        
        /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT ( __stdcall *put_Set0 )( 
            ISoftUSBPhysicalDescriptor * This,
            /* [in] */ __RPC__in_opt ISoftUSBPhysicalDescriptorSet0 *pSet0);
        
        /* [helpstringcontext][helpcontext][helpstring][propputref][id] */ HRESULT ( __stdcall *putref_Set0 )( 
            ISoftUSBPhysicalDescriptor * This,
            /* [in] */ __RPC__in_opt ISoftUSBPhysicalDescriptorSet0 *pSet0);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_Sets )( 
            ISoftUSBPhysicalDescriptor * This,
            /* [retval][out] */ __RPC__deref_out_opt ISoftUSBPhysicalDescriptorSetList **ppSets);
        
        END_INTERFACE
    } ISoftUSBPhysicalDescriptorVtbl;

    interface ISoftUSBPhysicalDescriptor
    {
        CONST_VTBL struct ISoftUSBPhysicalDescriptorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISoftUSBPhysicalDescriptor_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ISoftUSBPhysicalDescriptor_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ISoftUSBPhysicalDescriptor_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ISoftUSBPhysicalDescriptor_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ISoftUSBPhysicalDescriptor_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ISoftUSBPhysicalDescriptor_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ISoftUSBPhysicalDescriptor_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ISoftUSBPhysicalDescriptor_get_Set0(This,ppSet0)	\
    ( (This)->lpVtbl -> get_Set0(This,ppSet0) ) 

#define ISoftUSBPhysicalDescriptor_put_Set0(This,pSet0)	\
    ( (This)->lpVtbl -> put_Set0(This,pSet0) ) 

#define ISoftUSBPhysicalDescriptor_putref_Set0(This,pSet0)	\
    ( (This)->lpVtbl -> putref_Set0(This,pSet0) ) 

#define ISoftUSBPhysicalDescriptor_get_Sets(This,ppSets)	\
    ( (This)->lpVtbl -> get_Sets(This,ppSets) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ISoftUSBPhysicalDescriptor_INTERFACE_DEFINED__ */


#ifndef __ISoftUSBPhysicalDescriptorSetList_INTERFACE_DEFINED__
#define __ISoftUSBPhysicalDescriptorSetList_INTERFACE_DEFINED__

/* interface ISoftUSBPhysicalDescriptorSetList */
/* [helpstringcontext][helpcontext][helpstring][object][hidden][nonextensible][oleautomation][dual][uuid] */ 


EXTERN_C const IID IID_ISoftUSBPhysicalDescriptorSetList;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4CC5D8E4-49F4-4C34-ADA7-B81B4BC5C4D6")
    ISoftUSBPhysicalDescriptorSetList : public IDispatch
    {
    public:
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_Count( 
            /* [retval][out] */ __RPC__out long *plCount) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_Item( 
            /* [in] */ VARIANT Index,
            /* [retval][out] */ __RPC__deref_out_opt ISoftUSBPhysicalDescriptorSet **ppSet) = 0;
        
        virtual /* [hidden][propget][id] */ HRESULT __stdcall get__NewEnum( 
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **ppunkEnum) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][id] */ HRESULT __stdcall Add( 
            /* [in] */ __RPC__in_opt ISoftUSBPhysicalDescriptorSet *pSet,
            /* [optional][in] */ VARIANT Index) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][id] */ HRESULT __stdcall Remove( 
            /* [in] */ VARIANT Index) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][id] */ HRESULT __stdcall Clear( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISoftUSBPhysicalDescriptorSetListVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISoftUSBPhysicalDescriptorSetList * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISoftUSBPhysicalDescriptorSetList * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISoftUSBPhysicalDescriptorSetList * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ISoftUSBPhysicalDescriptorSetList * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ISoftUSBPhysicalDescriptorSetList * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ISoftUSBPhysicalDescriptorSetList * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ISoftUSBPhysicalDescriptorSetList * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_Count )( 
            ISoftUSBPhysicalDescriptorSetList * This,
            /* [retval][out] */ __RPC__out long *plCount);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_Item )( 
            ISoftUSBPhysicalDescriptorSetList * This,
            /* [in] */ VARIANT Index,
            /* [retval][out] */ __RPC__deref_out_opt ISoftUSBPhysicalDescriptorSet **ppSet);
        
        /* [hidden][propget][id] */ HRESULT ( __stdcall *get__NewEnum )( 
            ISoftUSBPhysicalDescriptorSetList * This,
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **ppunkEnum);
        
        /* [helpstringcontext][helpcontext][helpstring][id] */ HRESULT ( __stdcall *Add )( 
            ISoftUSBPhysicalDescriptorSetList * This,
            /* [in] */ __RPC__in_opt ISoftUSBPhysicalDescriptorSet *pSet,
            /* [optional][in] */ VARIANT Index);
        
        /* [helpstringcontext][helpcontext][helpstring][id] */ HRESULT ( __stdcall *Remove )( 
            ISoftUSBPhysicalDescriptorSetList * This,
            /* [in] */ VARIANT Index);
        
        /* [helpstringcontext][helpcontext][helpstring][id] */ HRESULT ( __stdcall *Clear )( 
            ISoftUSBPhysicalDescriptorSetList * This);
        
        END_INTERFACE
    } ISoftUSBPhysicalDescriptorSetListVtbl;

    interface ISoftUSBPhysicalDescriptorSetList
    {
        CONST_VTBL struct ISoftUSBPhysicalDescriptorSetListVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISoftUSBPhysicalDescriptorSetList_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ISoftUSBPhysicalDescriptorSetList_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ISoftUSBPhysicalDescriptorSetList_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ISoftUSBPhysicalDescriptorSetList_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ISoftUSBPhysicalDescriptorSetList_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ISoftUSBPhysicalDescriptorSetList_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ISoftUSBPhysicalDescriptorSetList_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ISoftUSBPhysicalDescriptorSetList_get_Count(This,plCount)	\
    ( (This)->lpVtbl -> get_Count(This,plCount) ) 

#define ISoftUSBPhysicalDescriptorSetList_get_Item(This,Index,ppSet)	\
    ( (This)->lpVtbl -> get_Item(This,Index,ppSet) ) 

#define ISoftUSBPhysicalDescriptorSetList_get__NewEnum(This,ppunkEnum)	\
    ( (This)->lpVtbl -> get__NewEnum(This,ppunkEnum) ) 

#define ISoftUSBPhysicalDescriptorSetList_Add(This,pSet,Index)	\
    ( (This)->lpVtbl -> Add(This,pSet,Index) ) 

#define ISoftUSBPhysicalDescriptorSetList_Remove(This,Index)	\
    ( (This)->lpVtbl -> Remove(This,Index) ) 

#define ISoftUSBPhysicalDescriptorSetList_Clear(This)	\
    ( (This)->lpVtbl -> Clear(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ISoftUSBPhysicalDescriptorSetList_INTERFACE_DEFINED__ */


#ifndef __ISoftUSBPhysicalDescriptorItemList_INTERFACE_DEFINED__
#define __ISoftUSBPhysicalDescriptorItemList_INTERFACE_DEFINED__

/* interface ISoftUSBPhysicalDescriptorItemList */
/* [helpstringcontext][helpcontext][helpstring][object][hidden][nonextensible][oleautomation][dual][uuid] */ 


EXTERN_C const IID IID_ISoftUSBPhysicalDescriptorItemList;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("24939051-5A21-432B-BF7C-D05037C116A4")
    ISoftUSBPhysicalDescriptorItemList : public IDispatch
    {
    public:
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_Count( 
            /* [retval][out] */ __RPC__out long *plCount) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_Item( 
            /* [in] */ VARIANT Index,
            /* [retval][out] */ __RPC__deref_out_opt ISoftUSBPhysicalDescriptorItem **ppItem) = 0;
        
        virtual /* [hidden][propget][id] */ HRESULT __stdcall get__NewEnum( 
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **ppunkEnum) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][id] */ HRESULT __stdcall Add( 
            /* [in] */ __RPC__in_opt ISoftUSBPhysicalDescriptorItem *pItem,
            /* [optional][in] */ VARIANT Index) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][id] */ HRESULT __stdcall Remove( 
            /* [in] */ VARIANT Index) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][id] */ HRESULT __stdcall Clear( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISoftUSBPhysicalDescriptorItemListVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISoftUSBPhysicalDescriptorItemList * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISoftUSBPhysicalDescriptorItemList * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISoftUSBPhysicalDescriptorItemList * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ISoftUSBPhysicalDescriptorItemList * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ISoftUSBPhysicalDescriptorItemList * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ISoftUSBPhysicalDescriptorItemList * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ISoftUSBPhysicalDescriptorItemList * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_Count )( 
            ISoftUSBPhysicalDescriptorItemList * This,
            /* [retval][out] */ __RPC__out long *plCount);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_Item )( 
            ISoftUSBPhysicalDescriptorItemList * This,
            /* [in] */ VARIANT Index,
            /* [retval][out] */ __RPC__deref_out_opt ISoftUSBPhysicalDescriptorItem **ppItem);
        
        /* [hidden][propget][id] */ HRESULT ( __stdcall *get__NewEnum )( 
            ISoftUSBPhysicalDescriptorItemList * This,
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **ppunkEnum);
        
        /* [helpstringcontext][helpcontext][helpstring][id] */ HRESULT ( __stdcall *Add )( 
            ISoftUSBPhysicalDescriptorItemList * This,
            /* [in] */ __RPC__in_opt ISoftUSBPhysicalDescriptorItem *pItem,
            /* [optional][in] */ VARIANT Index);
        
        /* [helpstringcontext][helpcontext][helpstring][id] */ HRESULT ( __stdcall *Remove )( 
            ISoftUSBPhysicalDescriptorItemList * This,
            /* [in] */ VARIANT Index);
        
        /* [helpstringcontext][helpcontext][helpstring][id] */ HRESULT ( __stdcall *Clear )( 
            ISoftUSBPhysicalDescriptorItemList * This);
        
        END_INTERFACE
    } ISoftUSBPhysicalDescriptorItemListVtbl;

    interface ISoftUSBPhysicalDescriptorItemList
    {
        CONST_VTBL struct ISoftUSBPhysicalDescriptorItemListVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISoftUSBPhysicalDescriptorItemList_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ISoftUSBPhysicalDescriptorItemList_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ISoftUSBPhysicalDescriptorItemList_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ISoftUSBPhysicalDescriptorItemList_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ISoftUSBPhysicalDescriptorItemList_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ISoftUSBPhysicalDescriptorItemList_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ISoftUSBPhysicalDescriptorItemList_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ISoftUSBPhysicalDescriptorItemList_get_Count(This,plCount)	\
    ( (This)->lpVtbl -> get_Count(This,plCount) ) 

#define ISoftUSBPhysicalDescriptorItemList_get_Item(This,Index,ppItem)	\
    ( (This)->lpVtbl -> get_Item(This,Index,ppItem) ) 

#define ISoftUSBPhysicalDescriptorItemList_get__NewEnum(This,ppunkEnum)	\
    ( (This)->lpVtbl -> get__NewEnum(This,ppunkEnum) ) 

#define ISoftUSBPhysicalDescriptorItemList_Add(This,pItem,Index)	\
    ( (This)->lpVtbl -> Add(This,pItem,Index) ) 

#define ISoftUSBPhysicalDescriptorItemList_Remove(This,Index)	\
    ( (This)->lpVtbl -> Remove(This,Index) ) 

#define ISoftUSBPhysicalDescriptorItemList_Clear(This)	\
    ( (This)->lpVtbl -> Clear(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ISoftUSBPhysicalDescriptorItemList_INTERFACE_DEFINED__ */


#ifndef __ISoftUSBHidFaultInjection_INTERFACE_DEFINED__
#define __ISoftUSBHidFaultInjection_INTERFACE_DEFINED__

/* interface ISoftUSBHidFaultInjection */
/* [object][helpstringcontext][helpcontext][helpstring][hidden][nonextensible][oleautomation][dual][uuid] */ 


EXTERN_C const IID IID_ISoftUSBHidFaultInjection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("36D2CC56-B545-4F13-BAEF-425F87E5BB37")
    ISoftUSBHidFaultInjection : public IDispatch
    {
    public:
        virtual /* [helpstringcontext][helpcontext][helpstring] */ HRESULT __stdcall StartFaultInjection( void) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring] */ HRESULT __stdcall StopFaultInjection( void) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring] */ HRESULT __stdcall FaultNextNRequests( 
            /* [in] */ BYTE bRequests,
            /* [in] */ ULONG nTimesToFail) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring] */ HRESULT __stdcall FaultNextNIOPackets( 
            /* [in] */ BYTE bEpNumber,
            /* [in] */ BYTE bFlag,
            /* [in] */ ULONG nTimesToFail) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring] */ HRESULT __stdcall ChangeNextNIOPackets( 
            /* [in] */ BYTE bEpNumber,
            /* [in] */ BYTE bFlags,
            /* [in] */ SHORT wOffset,
            /* [in] */ __RPC__in BYTE *pBuffer,
            /* [in] */ SHORT wSize,
            /* [in] */ BYTE bMask,
            /* [in] */ ULONG nTimesToFail) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISoftUSBHidFaultInjectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISoftUSBHidFaultInjection * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISoftUSBHidFaultInjection * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISoftUSBHidFaultInjection * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ISoftUSBHidFaultInjection * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ISoftUSBHidFaultInjection * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ISoftUSBHidFaultInjection * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ISoftUSBHidFaultInjection * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstringcontext][helpcontext][helpstring] */ HRESULT ( __stdcall *StartFaultInjection )( 
            ISoftUSBHidFaultInjection * This);
        
        /* [helpstringcontext][helpcontext][helpstring] */ HRESULT ( __stdcall *StopFaultInjection )( 
            ISoftUSBHidFaultInjection * This);
        
        /* [helpstringcontext][helpcontext][helpstring] */ HRESULT ( __stdcall *FaultNextNRequests )( 
            ISoftUSBHidFaultInjection * This,
            /* [in] */ BYTE bRequests,
            /* [in] */ ULONG nTimesToFail);
        
        /* [helpstringcontext][helpcontext][helpstring] */ HRESULT ( __stdcall *FaultNextNIOPackets )( 
            ISoftUSBHidFaultInjection * This,
            /* [in] */ BYTE bEpNumber,
            /* [in] */ BYTE bFlag,
            /* [in] */ ULONG nTimesToFail);
        
        /* [helpstringcontext][helpcontext][helpstring] */ HRESULT ( __stdcall *ChangeNextNIOPackets )( 
            ISoftUSBHidFaultInjection * This,
            /* [in] */ BYTE bEpNumber,
            /* [in] */ BYTE bFlags,
            /* [in] */ SHORT wOffset,
            /* [in] */ __RPC__in BYTE *pBuffer,
            /* [in] */ SHORT wSize,
            /* [in] */ BYTE bMask,
            /* [in] */ ULONG nTimesToFail);
        
        END_INTERFACE
    } ISoftUSBHidFaultInjectionVtbl;

    interface ISoftUSBHidFaultInjection
    {
        CONST_VTBL struct ISoftUSBHidFaultInjectionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISoftUSBHidFaultInjection_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ISoftUSBHidFaultInjection_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ISoftUSBHidFaultInjection_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ISoftUSBHidFaultInjection_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ISoftUSBHidFaultInjection_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ISoftUSBHidFaultInjection_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ISoftUSBHidFaultInjection_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ISoftUSBHidFaultInjection_StartFaultInjection(This)	\
    ( (This)->lpVtbl -> StartFaultInjection(This) ) 

#define ISoftUSBHidFaultInjection_StopFaultInjection(This)	\
    ( (This)->lpVtbl -> StopFaultInjection(This) ) 

#define ISoftUSBHidFaultInjection_FaultNextNRequests(This,bRequests,nTimesToFail)	\
    ( (This)->lpVtbl -> FaultNextNRequests(This,bRequests,nTimesToFail) ) 

#define ISoftUSBHidFaultInjection_FaultNextNIOPackets(This,bEpNumber,bFlag,nTimesToFail)	\
    ( (This)->lpVtbl -> FaultNextNIOPackets(This,bEpNumber,bFlag,nTimesToFail) ) 

#define ISoftUSBHidFaultInjection_ChangeNextNIOPackets(This,bEpNumber,bFlags,wOffset,pBuffer,wSize,bMask,nTimesToFail)	\
    ( (This)->lpVtbl -> ChangeNextNIOPackets(This,bEpNumber,bFlags,wOffset,pBuffer,wSize,bMask,nTimesToFail) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ISoftUSBHidFaultInjection_INTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_SoftHIDProtocolXlator;

#ifdef __cplusplus

class DECLSPEC_UUID("887C935C-84F7-4252-BFE3-33CBC16F3D47")
SoftHIDProtocolXlator;
#endif

EXTERN_C const CLSID CLSID_SoftHidUsbDevice;

#ifdef __cplusplus

class DECLSPEC_UUID("56545816-6EFE-45D0-BA2E-AC4426878CD5")
SoftHidUsbDevice;
#endif

EXTERN_C const CLSID CLSID_SoftUSBHidDescriptor;

#ifdef __cplusplus

class DECLSPEC_UUID("3FB17F94-282C-4091-BCAA-EAA0AC104946")
SoftUSBHidDescriptor;
#endif

EXTERN_C const CLSID CLSID_SoftUSBPhysicalDescriptor;

#ifdef __cplusplus

class DECLSPEC_UUID("D5DF9D05-B55C-45EC-BDC2-A9CC318CBBAB")
SoftUSBPhysicalDescriptor;
#endif

EXTERN_C const CLSID CLSID_SoftUSBPhysicalDescriptorSet0;

#ifdef __cplusplus

class DECLSPEC_UUID("921F4757-CD5A-4935-BB3E-616ABFE18BEA")
SoftUSBPhysicalDescriptorSet0;
#endif

EXTERN_C const CLSID CLSID_SoftUSBPhysicalDescriptorSet;

#ifdef __cplusplus

class DECLSPEC_UUID("EF7BF7AD-83D0-4160-9C07-39AD92A08A8D")
SoftUSBPhysicalDescriptorSet;
#endif

EXTERN_C const CLSID CLSID_SoftUSBPhysicalDescriptorItem;

#ifdef __cplusplus

class DECLSPEC_UUID("18217BCD-1DC8-4737-A0A3-95EC3432DBFE")
SoftUSBPhysicalDescriptorItem;
#endif

EXTERN_C const CLSID CLSID_SoftUSBPhysicalDescriptorSetList;

#ifdef __cplusplus

class DECLSPEC_UUID("E280E977-BD59-48A0-9B91-10D312157393")
SoftUSBPhysicalDescriptorSetList;
#endif

EXTERN_C const CLSID CLSID_SoftUSBPhysicalDescriptorItemList;

#ifdef __cplusplus

class DECLSPEC_UUID("8F779698-A4E3-47FE-8542-C312FE1F748A")
SoftUSBPhysicalDescriptorItemList;
#endif

EXTERN_C const CLSID CLSID_SoftUSBHidFaultInjection;

#ifdef __cplusplus

class DECLSPEC_UUID("D775D2E8-F328-43F4-B680-80DF4AE0CB6A")
SoftUSBHidFaultInjection;
#endif
#endif /* __SOFTHIDUSBK_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\srb.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    srb.h

Abstract:

    This file defines the interface between SCSI mini-port drivers and the
    SCSI port driver.  It is also used by SCSI class drivers to talk to the
    SCSI port driver.

Revision History:

--*/

#ifndef _NTSRB_
#define _NTSRB_

#if DBG
#define DebugPrint(x) ScsiDebugPrint x
#else
#define DebugPrint(x)
#endif

// begin_storport

//
// Define SCSI maximum configuration parameters.
//

#define SCSI_MAXIMUM_LOGICAL_UNITS 8
#define SCSI_MAXIMUM_TARGETS_PER_BUS 128
#define SCSI_MAXIMUM_LUNS_PER_TARGET 255
#define SCSI_MAXIMUM_BUSES 8
#define SCSI_MINIMUM_PHYSICAL_BREAKS  16
#define SCSI_MAXIMUM_PHYSICAL_BREAKS 255

#define SCSI_COMBINE_BUS_TARGET( Bus, Target ) ( \
    ((((UCHAR) (Target)) & ~(0x20 - 1)) << 8) |        \
    (((UCHAR) (Bus)) << 5) |                     \
    (((UCHAR) (Target)) & (0x20 - 1)))

#define SCSI_DECODE_BUS_TARGET( Value, Bus, Target ) ( \
    Bus = (UCHAR) ((Value) >> 5),                     \
    Target = (UCHAR) ((((Value) >> 8) & ~(0x20 - 1)) | ((Value) & (0x20 - 1))))

//
// This constant is for backward compatibility.
// This use to be the maximum number of targets supported.
//

#define SCSI_MAXIMUM_TARGETS 8

//end_storport

typedef PHYSICAL_ADDRESS SCSI_PHYSICAL_ADDRESS, *PSCSI_PHYSICAL_ADDRESS;

typedef struct _ACCESS_RANGE {
    SCSI_PHYSICAL_ADDRESS RangeStart;
    ULONG RangeLength;
    BOOLEAN RangeInMemory;
}ACCESS_RANGE, *PACCESS_RANGE;

//
// Configuration information structure.  Contains the information necessary
// to initialize the adapter. NOTE: This structure's must be a multiple of
// quadwords.
//

typedef struct _PORT_CONFIGURATION_INFORMATION {

    //
    // Length of port configuation information strucuture.
    //

    ULONG Length;

    //
    // IO bus number (0 for machines that have only 1 IO bus
    //

    ULONG SystemIoBusNumber;

    //
    // EISA, MCA or ISA
    //

    INTERFACE_TYPE  AdapterInterfaceType;

    //
    // Interrupt request level for device
    //

    ULONG BusInterruptLevel;

    //
    // Bus interrupt vector used with hardware buses which use as vector as
    // well as level, such as internal buses.
    //

    ULONG BusInterruptVector;

    //
    // Interrupt mode (level-sensitive or edge-triggered)
    //

    KINTERRUPT_MODE InterruptMode;

    //
    // Maximum number of bytes that can be transferred in a single SRB
    //

    ULONG MaximumTransferLength;

    //
    // Number of contiguous blocks of physical memory
    //

    ULONG NumberOfPhysicalBreaks;

    //
    // DMA channel for devices using system DMA
    //

    ULONG DmaChannel;
    ULONG DmaPort;
    DMA_WIDTH DmaWidth;
    DMA_SPEED DmaSpeed;

    //
    // Alignment masked required by the adapter for data transfers.
    //

    ULONG AlignmentMask;

    //
    // Number of access range elements which have been allocated.
    //

    ULONG NumberOfAccessRanges;

    //
    // Pointer to array of access range elements.
    //

    ACCESS_RANGE (*AccessRanges)[];

    //
    // Reserved field.
    //

    PVOID Reserved;

    //
    // Number of SCSI buses attached to the adapter.
    //

    UCHAR NumberOfBuses;

    //
    // SCSI bus ID for adapter
    //

    UCHAR InitiatorBusId[8];

    //
    // Indicates that the adapter does scatter/gather
    //

    BOOLEAN ScatterGather;

    //
    // Indicates that the adapter is a bus master
    //

    BOOLEAN Master;

    //
    // Host caches data or state.
    //

    BOOLEAN CachesData;

    //
    // Host adapter scans down for bios devices.
    //

    BOOLEAN AdapterScansDown;

    //
    // Primary at disk address (0x1F0) claimed.
    //

    BOOLEAN AtdiskPrimaryClaimed;

    //
    // Secondary at disk address (0x170) claimed.
    //

    BOOLEAN AtdiskSecondaryClaimed;

    //
    // The master uses 32-bit DMA addresses.
    //

    BOOLEAN Dma32BitAddresses;

    //
    // Use Demand Mode DMA rather than Single Request.
    //

    BOOLEAN DemandMode;

    //
    // Data buffers must be mapped into virtual address space.
    //

    BOOLEAN MapBuffers;

    //
    // The driver will need to tranlate virtual to physical addresses.
    //

    BOOLEAN NeedPhysicalAddresses;

    //
    // Supports tagged queuing
    //

    BOOLEAN TaggedQueuing;

    //
    // Supports auto request sense.
    //

    BOOLEAN AutoRequestSense;

    //
    // Supports multiple requests per logical unit.
    //

    BOOLEAN MultipleRequestPerLu;

    //
    // Support receive event function.
    //

    BOOLEAN ReceiveEvent;

    //
    // Indicates the real-mode driver has initialized the card.
    //

    BOOLEAN RealModeInitialized;

    //
    // Indicate that the miniport will not touch the data buffers directly.
    //

    BOOLEAN BufferAccessScsiPortControlled;

    //
    // Indicator for wide scsi.
    //

    UCHAR   MaximumNumberOfTargets;

    //
    // Ensure quadword alignment.
    //

    UCHAR   ReservedUchars[2];

    //
    // Adapter slot number
    //

    ULONG SlotNumber;

    //
    // Interrupt information for a second IRQ.
    //

    ULONG BusInterruptLevel2;
    ULONG BusInterruptVector2;
    KINTERRUPT_MODE InterruptMode2;

    //
    // DMA information for a second channel.
    //

    ULONG DmaChannel2;
    ULONG DmaPort2;
    DMA_WIDTH DmaWidth2;
    DMA_SPEED DmaSpeed2;

    //
    // Fields added to allow for the miniport
    // to update these sizes based on requirements
    // for large transfers ( > 64K);
    //

    ULONG DeviceExtensionSize;
    ULONG SpecificLuExtensionSize;
    ULONG SrbExtensionSize;

    //
    // Used to determine whether the system and/or the miniport support
    // 64-bit physical addresses.  See SCSI_DMA64_* flags below.
    //

    UCHAR  Dma64BitAddresses;        /* New */

    //
    // Indicates that the miniport can accept a SRB_FUNCTION_RESET_DEVICE
    // to clear all requests to a particular LUN.
    //

    BOOLEAN ResetTargetSupported;       /* New */

    //
    // Indicates that the miniport can support more than 8 logical units per
    // target (maximum LUN number is one less than this field).
    //

    UCHAR MaximumNumberOfLogicalUnits;  /* New */

    //
    // Supports WMI?
    //

    BOOLEAN WmiDataProvider;

} PORT_CONFIGURATION_INFORMATION, *PPORT_CONFIGURATION_INFORMATION;

//
// Version control for ConfigInfo structure.
//

#define CONFIG_INFO_VERSION_2 sizeof(PORT_CONFIGURATION_INFORMATION)


//
// Flags for controlling 64-bit DMA use (PORT_CONFIGURATION_INFORMATION field
// Dma64BitAddresses)
//

//
// Set by scsiport on entering HwFindAdapter if the system can support 64-bit
// physical addresses.  The miniport can use this information before calling
// ScsiPortGetUncachedExtension to modify the DeviceExtensionSize,
// SpecificLuExtensionSize & SrbExtensionSize fields to account for the extra
// size of the scatter gather list.
//

#define SCSI_DMA64_SYSTEM_SUPPORTED     0x80

//
// Set by the miniport before calling ScsiPortGetUncachedExtension to indicate
// that scsiport should provide it with 64-bit physical addresses.  If the
// system does not support 64-bit PA's then this bit will be ignored.
//

#define SCSI_DMA64_MINIPORT_SUPPORTED   0x01

#if (NTDDI_VERSION > NTDDI_WS03SP1)
//
// Set by the miniport before calling ScsiPortGetUncachedExtension to indicate
// that scsiport should provide it with 64-bit physical addresses.
// In addition to I/O requests being handled with > 4GB physical addresses,
// the uncached extension, SenseInof and Srb Extension may all lie above 4GB.
// If the system does not support 64-bit PA's then this bit will be ignored.
//

#define SCSI_DMA64_MINIPORT_FULL64BIT_SUPPORTED 0x02
#endif


//
// Command type (and parameter) definition(s) for AdapterControl requests.
//

typedef enum _SCSI_ADAPTER_CONTROL_TYPE {
    ScsiQuerySupportedControlTypes = 0,
    ScsiStopAdapter,
    ScsiRestartAdapter,
    ScsiSetBootConfig,
    ScsiSetRunningConfig,
    ScsiAdapterControlMax,
    MakeAdapterControlTypeSizeOfUlong = 0xffffffff
} SCSI_ADAPTER_CONTROL_TYPE, *PSCSI_ADAPTER_CONTROL_TYPE;

//
// Adapter control status values
//

typedef enum _SCSI_ADAPTER_CONTROL_STATUS {
    ScsiAdapterControlSuccess = 0,
    ScsiAdapterControlUnsuccessful
} SCSI_ADAPTER_CONTROL_STATUS, *PSCSI_ADAPTER_CONTROL_STATUS;

//
// Parameters for Adapter Control Functions:
//

//
// ScsiQuerySupportedControlTypes:
//

#pragma warning(disable:4200)
typedef struct _SCSI_SUPPORTED_CONTROL_TYPE_LIST {

    //
    // Specifies the number of entries in the adapter control type list.
    //

    IN ULONG MaxControlType;

    //
    // The miniport will set TRUE for each control type it supports.
    // The number of entries in this array is defined by MaxAdapterControlType
    // - the miniport must not attempt to set any AC types beyond the maximum
    // value specified.
    //

    OUT BOOLEAN SupportedTypeList[0];

} SCSI_SUPPORTED_CONTROL_TYPE_LIST, *PSCSI_SUPPORTED_CONTROL_TYPE_LIST;
#pragma warning(default:4200)

// begin_storport

//
// Uninitialized flag value.
//

#define SP_UNINITIALIZED_VALUE ((ULONG) ~0)
#define SP_UNTAGGED ((UCHAR) ~0)

//
// Set asynchronous events.
//

#define SRBEV_BUS_RESET               0x0001
#define SRBEV_SCSI_ASYNC_NOTIFICATION 0x0002

// begin_ntminitape

#define MAXIMUM_CDB_SIZE 12

//
// SCSI I/O Request Block
//

typedef struct _SCSI_REQUEST_BLOCK {
    USHORT Length;                  // offset 0
    UCHAR Function;                 // offset 2
    UCHAR SrbStatus;                // offset 3
    UCHAR ScsiStatus;               // offset 4
    UCHAR PathId;                   // offset 5
    UCHAR TargetId;                 // offset 6
    UCHAR Lun;                      // offset 7
    UCHAR QueueTag;                 // offset 8
    UCHAR QueueAction;              // offset 9
    UCHAR CdbLength;                // offset a
    UCHAR SenseInfoBufferLength;    // offset b
    ULONG SrbFlags;                 // offset c
    ULONG DataTransferLength;       // offset 10
    ULONG TimeOutValue;             // offset 14
    __field_bcount(DataTransferLength) \
    PVOID DataBuffer;               // offset 18
    PVOID SenseInfoBuffer;          // offset 1c
    struct _SCSI_REQUEST_BLOCK *NextSrb; // offset 20
    PVOID OriginalRequest;          // offset 24
    PVOID SrbExtension;             // offset 28
    union {
        ULONG InternalStatus;       // offset 2c
        ULONG QueueSortKey;         // offset 2c
        ULONG LinkTimeoutValue;     // offset 2c
    };

#if defined(_WIN64)

    //
    // Force PVOID alignment of Cdb
    //

    ULONG Reserved;

#endif

    UCHAR Cdb[16];                  // offset 30
} SCSI_REQUEST_BLOCK, *PSCSI_REQUEST_BLOCK;

#define SCSI_REQUEST_BLOCK_SIZE sizeof(SCSI_REQUEST_BLOCK)

//
// SCSI I/O Request Block for WMI Requests
//

typedef struct _SCSI_WMI_REQUEST_BLOCK {
    USHORT Length;
    UCHAR Function;        // SRB_FUNCTION_WMI
    UCHAR SrbStatus;
    UCHAR WMISubFunction;
    UCHAR PathId;          // If SRB_WMI_FLAGS_ADAPTER_REQUEST is set in
    UCHAR TargetId;        // WMIFlags then PathId, TargetId and Lun are
    UCHAR Lun;             // reserved fields.
    UCHAR Reserved1;
    UCHAR WMIFlags;
    UCHAR Reserved2[2];
    ULONG SrbFlags;
    ULONG DataTransferLength;
    ULONG TimeOutValue;
    PVOID DataBuffer;
    PVOID DataPath;
    PVOID Reserved3;
    PVOID OriginalRequest;
    PVOID SrbExtension;
    ULONG Reserved4;

#if (NTDDI_VERSION >= NTDDI_WS03SP1)
#if defined(_WIN64)

    //
    // Force PVOID alignment of Cdb
    //

    ULONG Reserved6;

#endif
#endif

    UCHAR Reserved5[16];
} SCSI_WMI_REQUEST_BLOCK, *PSCSI_WMI_REQUEST_BLOCK;

typedef enum _STOR_DEVICE_POWER_STATE {
    StorPowerDeviceUnspecified = 0,
    StorPowerDeviceD0,
    StorPowerDeviceD1,
    StorPowerDeviceD2,
    StorPowerDeviceD3,
    StorPowerDeviceMaximum
} STOR_DEVICE_POWER_STATE, *PSTOR_DEVICE_POWER_STATE;

typedef enum {
    StorPowerActionNone = 0,
    StorPowerActionReserved,
    StorPowerActionSleep,
    StorPowerActionHibernate,
    StorPowerActionShutdown,
    StorPowerActionShutdownReset,
    StorPowerActionShutdownOff,
    StorPowerActionWarmEject
} STOR_POWER_ACTION, *PSTOR_POWER_ACTION;

typedef struct _SCSI_POWER_REQUEST_BLOCK {
    USHORT Length;                  // offset 0
    UCHAR Function;                 // offset 2
    UCHAR SrbStatus;                // offset 3
    UCHAR SrbPowerFlags;            // offset 4
    UCHAR PathId;                   // offset 5
    UCHAR TargetId;                 // offset 6
    UCHAR Lun;                      // offset 7
    STOR_DEVICE_POWER_STATE DevicePowerState; // offset 8
    ULONG SrbFlags;                 // offset c
    ULONG DataTransferLength;       // offset 10
    ULONG TimeOutValue;             // offset 14
    PVOID DataBuffer;               // offset 18
    PVOID SenseInfoBuffer;          // offset 1c
    struct _SCSI_REQUEST_BLOCK *NextSrb; // offset 20
    PVOID OriginalRequest;          // offset 24
    PVOID SrbExtension;             // offset 28
    STOR_POWER_ACTION PowerAction;       // offset 2c

#if defined(_WIN64)

    //
    // Force PVOID alignment of Cdb
    //

    ULONG Reserved;

#endif

    UCHAR Reserved5[16];              // offset 30
} SCSI_POWER_REQUEST_BLOCK, *PSCSI_POWER_REQUEST_BLOCK;

//
// PNP minor function codes.
//
typedef enum {
    StorStartDevice = 0x0,
    StorRemoveDevice = 0x2,
    StorStopDevice  = 0x4,
    StorQueryCapabilities = 0x9,
    StorFilterResourceRequirements = 0xB
} STOR_PNP_ACTION, *PSTOR_PNP_ACTION;

typedef struct _STOR_DEVICE_CAPABILITIES {
    USHORT Version;
    ULONG  DeviceD1:1;
    ULONG  DeviceD2:1;
    ULONG  LockSupported:1;
    ULONG  EjectSupported:1;
    ULONG  Removable:1;
    ULONG  DockDevice:1;
    ULONG  UniqueID:1;
    ULONG  SilentInstall:1;
    ULONG  SurpriseRemovalOK:1;
    ULONG  NoDisplayInUI:1;

} STOR_DEVICE_CAPABILITIES, *PSTOR_DEVICE_CAPABILITIES;

typedef struct _SCSI_PNP_REQUEST_BLOCK {
    USHORT Length;                  // offset 0
    UCHAR Function;                 // offset 2
    UCHAR SrbStatus;                // offset 3
    UCHAR PnPSubFunction;           // offset 4
    UCHAR PathId;                   // offset 5
    UCHAR TargetId;                 // offset 6
    UCHAR Lun;                      // offset 7
    STOR_PNP_ACTION PnPAction;       // offset 8
    ULONG SrbFlags;                 // offset c
    ULONG DataTransferLength;       // offset 10
    ULONG TimeOutValue;             // offset 14
    PVOID DataBuffer;               // offset 18
    PVOID SenseInfoBuffer;          // offset 1c
    struct _SCSI_REQUEST_BLOCK *NextSrb; // offset 20
    PVOID OriginalRequest;          // offset 24
    PVOID SrbExtension;             // offset 28
    ULONG SrbPnPFlags;              // offset 2c

#if defined(_WIN64)

    //
    // Force PVOID alignment of Cdb
    //

    ULONG Reserved;

#endif
        UCHAR Reserved4[16];            // offset 30
} SCSI_PNP_REQUEST_BLOCK, *PSCSI_PNP_REQUEST_BLOCK;


//
// SRB Functions
//

#define SRB_FUNCTION_EXECUTE_SCSI           0x00
#define SRB_FUNCTION_CLAIM_DEVICE           0x01
#define SRB_FUNCTION_IO_CONTROL             0x02
#define SRB_FUNCTION_RECEIVE_EVENT          0x03
#define SRB_FUNCTION_RELEASE_QUEUE          0x04
#define SRB_FUNCTION_ATTACH_DEVICE          0x05
#define SRB_FUNCTION_RELEASE_DEVICE         0x06
#define SRB_FUNCTION_SHUTDOWN               0x07
#define SRB_FUNCTION_FLUSH                  0x08
#define SRB_FUNCTION_ABORT_COMMAND          0x10
#define SRB_FUNCTION_RELEASE_RECOVERY       0x11
#define SRB_FUNCTION_RESET_BUS              0x12
#define SRB_FUNCTION_RESET_DEVICE           0x13
#define SRB_FUNCTION_TERMINATE_IO           0x14
#define SRB_FUNCTION_FLUSH_QUEUE            0x15
#define SRB_FUNCTION_REMOVE_DEVICE          0x16
#define SRB_FUNCTION_WMI                    0x17
#define SRB_FUNCTION_LOCK_QUEUE             0x18
#define SRB_FUNCTION_UNLOCK_QUEUE           0x19
#define SRB_FUNCTION_RESET_LOGICAL_UNIT     0x20
#define SRB_FUNCTION_SET_LINK_TIMEOUT       0x21
#define SRB_FUNCTION_LINK_TIMEOUT_OCCURRED  0x22
#define SRB_FUNCTION_LINK_TIMEOUT_COMPLETE  0x23
#define SRB_FUNCTION_POWER                  0x24
#define SRB_FUNCTION_PNP                    0x25
#define SRB_FUNCTION_DUMP_POINTERS          0x26
//
// SRB Status
//

#define SRB_STATUS_PENDING                  0x00
#define SRB_STATUS_SUCCESS                  0x01
#define SRB_STATUS_ABORTED                  0x02
#define SRB_STATUS_ABORT_FAILED             0x03
#define SRB_STATUS_ERROR                    0x04
#define SRB_STATUS_BUSY                     0x05
#define SRB_STATUS_INVALID_REQUEST          0x06
#define SRB_STATUS_INVALID_PATH_ID          0x07
#define SRB_STATUS_NO_DEVICE                0x08
#define SRB_STATUS_TIMEOUT                  0x09
#define SRB_STATUS_SELECTION_TIMEOUT        0x0A
#define SRB_STATUS_COMMAND_TIMEOUT          0x0B
#define SRB_STATUS_MESSAGE_REJECTED         0x0D
#define SRB_STATUS_BUS_RESET                0x0E
#define SRB_STATUS_PARITY_ERROR             0x0F
#define SRB_STATUS_REQUEST_SENSE_FAILED     0x10
#define SRB_STATUS_NO_HBA                   0x11
#define SRB_STATUS_DATA_OVERRUN             0x12
#define SRB_STATUS_UNEXPECTED_BUS_FREE      0x13
#define SRB_STATUS_PHASE_SEQUENCE_FAILURE   0x14
#define SRB_STATUS_BAD_SRB_BLOCK_LENGTH     0x15
#define SRB_STATUS_REQUEST_FLUSHED          0x16
#define SRB_STATUS_INVALID_LUN              0x20
#define SRB_STATUS_INVALID_TARGET_ID        0x21
#define SRB_STATUS_BAD_FUNCTION             0x22
#define SRB_STATUS_ERROR_RECOVERY           0x23
#define SRB_STATUS_NOT_POWERED              0x24
#define SRB_STATUS_LINK_DOWN                0x25

//
// This value is used by the port driver to indicate that a non-scsi-related
// error occured.  Miniports must never return this status.
//

#define SRB_STATUS_INTERNAL_ERROR           0x30

//
// Srb status values 0x38 through 0x3f are reserved for internal port driver
// use.
//



//
// SRB Status Masks
//

#define SRB_STATUS_QUEUE_FROZEN             0x40
#define SRB_STATUS_AUTOSENSE_VALID          0x80

#define SRB_STATUS(Status) (Status & ~(SRB_STATUS_AUTOSENSE_VALID | SRB_STATUS_QUEUE_FROZEN))

//
// SRB Flag Bits
//

#define SRB_FLAGS_QUEUE_ACTION_ENABLE       0x00000002
#define SRB_FLAGS_DISABLE_DISCONNECT        0x00000004
#define SRB_FLAGS_DISABLE_SYNCH_TRANSFER    0x00000008

#define SRB_FLAGS_BYPASS_FROZEN_QUEUE       0x00000010
#define SRB_FLAGS_DISABLE_AUTOSENSE         0x00000020
#define SRB_FLAGS_DATA_IN                   0x00000040
#define SRB_FLAGS_DATA_OUT                  0x00000080
#define SRB_FLAGS_NO_DATA_TRANSFER          0x00000000
#define SRB_FLAGS_UNSPECIFIED_DIRECTION      (SRB_FLAGS_DATA_IN | SRB_FLAGS_DATA_OUT)

#define SRB_FLAGS_NO_QUEUE_FREEZE           0x00000100
#define SRB_FLAGS_ADAPTER_CACHE_ENABLE      0x00000200
#define SRB_FLAGS_FREE_SENSE_BUFFER         0x00000400

#define SRB_FLAGS_IS_ACTIVE                 0x00010000
#define SRB_FLAGS_ALLOCATED_FROM_ZONE       0x00020000
#define SRB_FLAGS_SGLIST_FROM_POOL          0x00040000
#define SRB_FLAGS_BYPASS_LOCKED_QUEUE       0x00080000

#define SRB_FLAGS_NO_KEEP_AWAKE             0x00100000
#define SRB_FLAGS_PORT_DRIVER_ALLOCSENSE    0x00200000

#define SRB_FLAGS_PORT_DRIVER_SENSEHASPORT  0x00400000
#define SRB_FLAGS_DONT_START_NEXT_PACKET    0x00800000

#define SRB_FLAGS_PORT_DRIVER_RESERVED      0x0F000000
#define SRB_FLAGS_CLASS_DRIVER_RESERVED     0xF0000000

#if DBG==1
//
// A signature used to validate the scsi port number
// at the end of a sense buffer.
//
#define SCSI_PORT_SIGNATURE                 0x54524f50
#endif

//
// Queue Action
//

#define SRB_SIMPLE_TAG_REQUEST              0x20
#define SRB_HEAD_OF_QUEUE_TAG_REQUEST       0x21
#define SRB_ORDERED_QUEUE_TAG_REQUEST       0x22

#define SRB_WMI_FLAGS_ADAPTER_REQUEST       0x01
#define SRB_POWER_FLAGS_ADAPTER_REQUEST     0x01
#define SRB_PNP_FLAGS_ADAPTER_REQUEST     0x01

// end_ntminitape

// end_storport

//
// SCSI Adapter Dependent Routines
//

typedef
BOOLEAN
(*PHW_INITIALIZE) (
    IN PVOID DeviceExtension
    );

typedef
BOOLEAN
(*PHW_STARTIO) (
    IN PVOID DeviceExtension,
    IN PSCSI_REQUEST_BLOCK Srb
    );

typedef
BOOLEAN
(*PHW_INTERRUPT) (
    IN PVOID DeviceExtension
    );

typedef
VOID
(*PHW_TIMER) (
    IN PVOID DeviceExtension
    );

typedef
VOID
(*PHW_DMA_STARTED) (
    IN PVOID DeviceExtension
    );

typedef
ULONG
(*PHW_FIND_ADAPTER) (
    IN PVOID DeviceExtension,
    IN PVOID HwContext,
    IN PVOID BusInformation,
    IN PCHAR ArgumentString,
    IN OUT PPORT_CONFIGURATION_INFORMATION ConfigInfo,
    OUT PBOOLEAN Again
    );

typedef
BOOLEAN
(*PHW_RESET_BUS) (
    IN PVOID DeviceExtension,
    IN ULONG PathId
    );

typedef
BOOLEAN
(*PHW_ADAPTER_STATE) (
    IN PVOID DeviceExtension,
    IN PVOID Context,
    IN BOOLEAN SaveState
    );

typedef
SCSI_ADAPTER_CONTROL_STATUS
(*PHW_ADAPTER_CONTROL) (
    IN PVOID DeviceExtension,
    IN SCSI_ADAPTER_CONTROL_TYPE ControlType,
    IN PVOID Parameters
    );

//
// Port driver error codes
//

#define SP_BUS_PARITY_ERROR         0x0001
#define SP_UNEXPECTED_DISCONNECT    0x0002
#define SP_INVALID_RESELECTION      0x0003
#define SP_BUS_TIME_OUT             0x0004
#define SP_PROTOCOL_ERROR           0x0005
#define SP_INTERNAL_ADAPTER_ERROR   0x0006
#define SP_REQUEST_TIMEOUT          0x0007
#define SP_IRQ_NOT_RESPONDING       0x0008
#define SP_BAD_FW_WARNING           0x0009
#define SP_BAD_FW_ERROR             0x000a
#define SP_LOST_WMI_MINIPORT_REQUEST 0x000b

//
// Port driver version flags
//
#define SP_VER_TRACE_SUPPORT        0x0010

//
// Return values for SCSI_HW_FIND_ADAPTER.
//

#define SP_RETURN_NOT_FOUND     0
#define SP_RETURN_FOUND         1
#define SP_RETURN_ERROR         2
#define SP_RETURN_BAD_CONFIG    3

//
// Notification Event Types
//

typedef enum _SCSI_NOTIFICATION_TYPE {
    RequestComplete,
    NextRequest,
    NextLuRequest,
    ResetDetected,
    CallDisableInterrupts,
    CallEnableInterrupts,
    RequestTimerCall,
    BusChangeDetected,     /* New */
    WMIEvent,
    WMIReregister,
    LinkUp,
    LinkDown,
    QueryTickCount,
    BufferOverrunDetected,
    TraceNotification      /* New */
} SCSI_NOTIFICATION_TYPE, *PSCSI_NOTIFICATION_TYPE;

//
// Structure passed between miniport initialization
// and SCSI port initialization
//

typedef struct _HW_INITIALIZATION_DATA {

    ULONG HwInitializationDataSize;

    //
    // Adapter interface type:
    //
    // Internal
    // Isa
    // Eisa
    // MicroChannel
    // TurboChannel
    // PCIBus
    // VMEBus
    // NuBus
    // PCMCIABus
    // CBus
    // MPIBus
    // MPSABus
    //

    INTERFACE_TYPE  AdapterInterfaceType;

    //
    // Miniport driver routines
    //

    PHW_INITIALIZE HwInitialize;

    PHW_STARTIO HwStartIo;

    PHW_INTERRUPT HwInterrupt;

    PHW_FIND_ADAPTER HwFindAdapter;

    PHW_RESET_BUS HwResetBus;

    PHW_DMA_STARTED HwDmaStarted;

    PHW_ADAPTER_STATE HwAdapterState;

    //
    // Miniport driver resources
    //

    ULONG DeviceExtensionSize;

    ULONG SpecificLuExtensionSize;

    ULONG SrbExtensionSize;

    ULONG NumberOfAccessRanges;

    PVOID Reserved;

    //
    // Data buffers must be mapped into virtual address space.
    //

    BOOLEAN MapBuffers;

    //
    // The driver will need to tranlate virtual to physical addresses.
    //

    BOOLEAN NeedPhysicalAddresses;

    //
    // Supports tagged queuing
    //

    BOOLEAN TaggedQueuing;

    //
    // Supports auto request sense.
    //

    BOOLEAN AutoRequestSense;

    //
    // Supports multiple requests per logical unit.
    //

    BOOLEAN MultipleRequestPerLu;

    //
    // Support receive event function.
    //

    BOOLEAN ReceiveEvent;

    //
    // Vendor identification length
    //

    USHORT VendorIdLength;

    //
    // Vendor identification
    //

    PVOID VendorId;

    //
    // Pad for alignment and future use.
    //

    union {

        USHORT ReservedUshort;

        //
        // Flags to indicate supported features
        //
        USHORT PortVersionFlags;
    };

    //
    // Device identification length
    //

    USHORT DeviceIdLength;

    //
    // Device identification
    //

    PVOID DeviceId;

    //
    // Stop adapter routine.
    //

    PHW_ADAPTER_CONTROL HwAdapterControl;

} HW_INITIALIZATION_DATA, *PHW_INITIALIZATION_DATA;

// begin_ntminitape

#ifndef _NTDDK_
#define SCSIPORT_API DECLSPEC_IMPORT
#else
#define SCSIPORT_API
#endif

// end_ntminitape

//
// Port driver routines called by miniport driver
//

SCSIPORT_API
ULONG
ScsiPortInitialize(
    IN PVOID Argument1,
    IN PVOID Argument2,
    IN struct _HW_INITIALIZATION_DATA *HwInitializationData,
    IN PVOID HwContext
    );

SCSIPORT_API
VOID
ScsiPortFreeDeviceBase(
    IN PVOID HwDeviceExtension,
    IN PVOID MappedAddress
    );

SCSIPORT_API
ULONG
ScsiPortGetBusData(
    IN PVOID DeviceExtension,
    IN ULONG BusDataType,
    IN ULONG SystemIoBusNumber,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Length
    );

SCSIPORT_API
ULONG
ScsiPortSetBusDataByOffset(
    IN PVOID DeviceExtension,
    IN ULONG BusDataType,
    IN ULONG SystemIoBusNumber,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    );

SCSIPORT_API
PVOID
ScsiPortGetDeviceBase(
    IN PVOID HwDeviceExtension,
    IN INTERFACE_TYPE BusType,
    IN ULONG SystemIoBusNumber,
    IN SCSI_PHYSICAL_ADDRESS IoAddress,
    IN ULONG NumberOfBytes,
    IN BOOLEAN InIoSpace
    );

SCSIPORT_API
PVOID
ScsiPortGetLogicalUnit(
    IN PVOID HwDeviceExtension,
    IN UCHAR PathId,
    IN UCHAR TargetId,
    IN UCHAR Lun
    );

SCSIPORT_API
PSCSI_REQUEST_BLOCK
ScsiPortGetSrb(
    IN PVOID DeviceExtension,
    IN UCHAR PathId,
    IN UCHAR TargetId,
    IN UCHAR Lun,
    IN LONG QueueTag
    );

SCSIPORT_API
SCSI_PHYSICAL_ADDRESS
ScsiPortGetPhysicalAddress(
    IN PVOID HwDeviceExtension,
    IN PSCSI_REQUEST_BLOCK Srb,
    IN PVOID VirtualAddress,
    OUT ULONG *Length
    );

SCSIPORT_API
PVOID
ScsiPortGetVirtualAddress(
    IN PVOID HwDeviceExtension,
    IN SCSI_PHYSICAL_ADDRESS PhysicalAddress
    );

SCSIPORT_API
PVOID
ScsiPortGetUncachedExtension(
    IN PVOID HwDeviceExtension,
    IN PPORT_CONFIGURATION_INFORMATION ConfigInfo,
    IN ULONG NumberOfBytes
    );

SCSIPORT_API
VOID
ScsiPortFlushDma(
    IN PVOID DeviceExtension
    );

SCSIPORT_API
VOID
ScsiPortIoMapTransfer(
    IN PVOID HwDeviceExtension,
    IN PSCSI_REQUEST_BLOCK Srb,
    IN PVOID LogicalAddress,
    IN ULONG Length
    );

SCSIPORT_API
VOID
ScsiPortNotification(
    IN SCSI_NOTIFICATION_TYPE NotificationType,
    IN PVOID HwDeviceExtension,
    ...
    );

SCSIPORT_API
VOID
ScsiPortLogError(
    IN PVOID HwDeviceExtension,
    IN PSCSI_REQUEST_BLOCK Srb OPTIONAL,
    IN UCHAR PathId,
    IN UCHAR TargetId,
    IN UCHAR Lun,
    IN ULONG ErrorCode,
    IN ULONG UniqueId
    );

SCSIPORT_API
VOID
ScsiPortCompleteRequest(
    IN PVOID HwDeviceExtension,
    IN UCHAR PathId,
    IN UCHAR TargetId,
    IN UCHAR Lun,
    IN UCHAR SrbStatus
    );

SCSIPORT_API
VOID
ScsiPortStallExecution(
    IN ULONG Delay
    );

#if defined(_M_AMD64)

#define ScsiPortReadPortUchar READ_PORT_UCHAR
#define ScsiPortReadPortUshort READ_PORT_USHORT
#define ScsiPortReadPortUlong READ_PORT_ULONG

#define ScsiPortReadPortBufferUchar READ_PORT_BUFFER_UCHAR
#define ScsiPortReadPortBufferUshort READ_PORT_BUFFER_USHORT
#define ScsiPortReadPortBufferUlong READ_PORT_BUFFER_ULONG

#define ScsiPortReadRegisterUchar READ_REGISTER_UCHAR
#define ScsiPortReadRegisterUshort READ_REGISTER_USHORT
#define ScsiPortReadRegisterUlong READ_REGISTER_ULONG

#define ScsiPortReadRegisterBufferUchar READ_REGISTER_BUFFER_UCHAR
#define ScsiPortReadRegisterBufferUshort READ_REGISTER_BUFFER_USHORT
#define ScsiPortReadRegisterBufferUlong READ_REGISTER_BUFFER_ULONG

#define ScsiPortWritePortUchar WRITE_PORT_UCHAR
#define ScsiPortWritePortUshort WRITE_PORT_USHORT
#define ScsiPortWritePortUlong WRITE_PORT_ULONG

#define ScsiPortWritePortBufferUchar WRITE_PORT_BUFFER_UCHAR
#define ScsiPortWritePortBufferUshort WRITE_PORT_BUFFER_USHORT
#define ScsiPortWritePortBufferUlong WRITE_PORT_BUFFER_ULONG

#define ScsiPortWriteRegisterUchar WRITE_REGISTER_UCHAR
#define ScsiPortWriteRegisterUshort WRITE_REGISTER_USHORT
#define ScsiPortWriteRegisterUlong WRITE_REGISTER_ULONG

#define ScsiPortWriteRegisterBufferUchar WRITE_REGISTER_BUFFER_UCHAR
#define ScsiPortWriteRegisterBufferUshort WRITE_REGISTER_BUFFER_USHORT
#define ScsiPortWriteRegisterBufferUlong WRITE_REGISTER_BUFFER_ULONG

#define ScsiPortMoveMemory memmove

#else

SCSIPORT_API
UCHAR
ScsiPortReadPortUchar(
    IN PUCHAR Port
    );

SCSIPORT_API
USHORT
ScsiPortReadPortUshort(
    IN PUSHORT Port
    );

SCSIPORT_API
ULONG
ScsiPortReadPortUlong(
    IN PULONG Port
    );

SCSIPORT_API
VOID
ScsiPortReadPortBufferUchar(
    IN PUCHAR Port,
    IN PUCHAR Buffer,
    IN ULONG  Count
    );

SCSIPORT_API
VOID
ScsiPortReadPortBufferUshort(
    IN PUSHORT Port,
    IN PUSHORT Buffer,
    IN ULONG Count
    );

SCSIPORT_API
VOID
ScsiPortReadPortBufferUlong(
    IN PULONG Port,
    IN PULONG Buffer,
    IN ULONG Count
    );

SCSIPORT_API
UCHAR
ScsiPortReadRegisterUchar(
    IN PUCHAR Register
    );

SCSIPORT_API
USHORT
ScsiPortReadRegisterUshort(
    IN PUSHORT Register
    );

SCSIPORT_API
ULONG
ScsiPortReadRegisterUlong(
    IN PULONG Register
    );

SCSIPORT_API
VOID
ScsiPortReadRegisterBufferUchar(
    IN PUCHAR Register,
    IN PUCHAR Buffer,
    IN ULONG  Count
    );

SCSIPORT_API
VOID
ScsiPortReadRegisterBufferUshort(
    IN PUSHORT Register,
    IN PUSHORT Buffer,
    IN ULONG Count
    );

SCSIPORT_API
VOID
ScsiPortReadRegisterBufferUlong(
    IN PULONG Register,
    IN PULONG Buffer,
    IN ULONG Count
    );

SCSIPORT_API
VOID
ScsiPortWritePortUchar(
    IN PUCHAR Port,
    IN UCHAR Value
    );

SCSIPORT_API
VOID
ScsiPortWritePortUshort(
    IN PUSHORT Port,
    IN USHORT Value
    );

SCSIPORT_API
VOID
ScsiPortWritePortUlong(
    IN PULONG Port,
    IN ULONG Value
    );

SCSIPORT_API
VOID
ScsiPortWritePortBufferUchar(
    IN PUCHAR Port,
    IN PUCHAR Buffer,
    IN ULONG  Count
    );

SCSIPORT_API
VOID
ScsiPortWritePortBufferUshort(
    IN PUSHORT Port,
    IN PUSHORT Buffer,
    IN ULONG Count
    );

SCSIPORT_API
VOID
ScsiPortWritePortBufferUlong(
    IN PULONG Port,
    IN PULONG Buffer,
    IN ULONG Count
    );

SCSIPORT_API
VOID
ScsiPortWriteRegisterUchar(
    IN PUCHAR Register,
    IN UCHAR Value
    );

SCSIPORT_API
VOID
ScsiPortWriteRegisterUshort(
    IN PUSHORT Register,
    IN USHORT Value
    );

SCSIPORT_API
VOID
ScsiPortWriteRegisterUlong(
    IN PULONG Register,
    IN ULONG Value
    );

SCSIPORT_API
VOID
ScsiPortWriteRegisterBufferUchar(
    IN PUCHAR Register,
    IN PUCHAR Buffer,
    IN ULONG  Count
    );

SCSIPORT_API
VOID
ScsiPortWriteRegisterBufferUshort(
    IN PUSHORT Register,
    IN PUSHORT Buffer,
    IN ULONG Count
    );

SCSIPORT_API
VOID
ScsiPortWriteRegisterBufferUlong(
    IN PULONG Register,
    IN PULONG Buffer,
    IN ULONG Count
    );

SCSIPORT_API
VOID
ScsiPortMoveMemory(
    IN PVOID WriteBuffer,
    IN PVOID ReadBuffer,
    IN ULONG Length
    );

#endif

SCSIPORT_API
SCSI_PHYSICAL_ADDRESS
ScsiPortConvertUlongToPhysicalAddress(
    ULONG_PTR UlongAddress
    );

SCSIPORT_API
ULONG
ScsiPortConvertPhysicalAddressToUlong(
    SCSI_PHYSICAL_ADDRESS Address
    );

SCSIPORT_API
VOID
ScsiPortQuerySystemTime(
    OUT PLARGE_INTEGER CurrentTime
    );

#define ScsiPortConvertPhysicalAddressToUlong(Address) ((Address).LowPart)

//
// Sundown Note:
// For now, ScsiPortConvertPhysicalAddressToULongPtr() exists only as a macro.
//

#define ScsiPortConvertPhysicalAddressToULongPtr(Address) ((ULONG_PTR)((Address).QuadPart))

SCSIPORT_API
BOOLEAN
ScsiPortValidateRange(
    IN PVOID HwDeviceExtension,
    IN INTERFACE_TYPE BusType,
    IN ULONG SystemIoBusNumber,
    IN SCSI_PHYSICAL_ADDRESS IoAddress,
    IN ULONG NumberOfBytes,
    IN BOOLEAN InIoSpace
    );

// begin_ntminitape

SCSIPORT_API
VOID
ScsiDebugPrint(
    ULONG DebugPrintLevel,
    PCCHAR DebugMessage,
    ...
    );

// end_ntminitape

#endif //
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\softusbif.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0499 */
/* Compiler settings for softusbif.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__


#ifndef __softusbif_h__
#define __softusbif_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __ISoftUSBConfigurations_FWD_DEFINED__
#define __ISoftUSBConfigurations_FWD_DEFINED__
typedef interface ISoftUSBConfigurations ISoftUSBConfigurations;
#endif 	/* __ISoftUSBConfigurations_FWD_DEFINED__ */


#ifndef __ISoftUSBConfiguration_FWD_DEFINED__
#define __ISoftUSBConfiguration_FWD_DEFINED__
typedef interface ISoftUSBConfiguration ISoftUSBConfiguration;
#endif 	/* __ISoftUSBConfiguration_FWD_DEFINED__ */


#ifndef __ISoftUSBInterface_FWD_DEFINED__
#define __ISoftUSBInterface_FWD_DEFINED__
typedef interface ISoftUSBInterface ISoftUSBInterface;
#endif 	/* __ISoftUSBInterface_FWD_DEFINED__ */


#ifndef __ISoftUSBEndpoint_FWD_DEFINED__
#define __ISoftUSBEndpoint_FWD_DEFINED__
typedef interface ISoftUSBEndpoint ISoftUSBEndpoint;
#endif 	/* __ISoftUSBEndpoint_FWD_DEFINED__ */


#ifndef __ISoftUSBDeviceQualifier_FWD_DEFINED__
#define __ISoftUSBDeviceQualifier_FWD_DEFINED__
typedef interface ISoftUSBDeviceQualifier ISoftUSBDeviceQualifier;
#endif 	/* __ISoftUSBDeviceQualifier_FWD_DEFINED__ */


#ifndef __ISoftUSBEndpointEvents_FWD_DEFINED__
#define __ISoftUSBEndpointEvents_FWD_DEFINED__
typedef interface ISoftUSBEndpointEvents ISoftUSBEndpointEvents;
#endif 	/* __ISoftUSBEndpointEvents_FWD_DEFINED__ */


#ifndef __ISoftUSBStrings_FWD_DEFINED__
#define __ISoftUSBStrings_FWD_DEFINED__
typedef interface ISoftUSBStrings ISoftUSBStrings;
#endif 	/* __ISoftUSBStrings_FWD_DEFINED__ */


#ifndef __ISoftUSBInterfaces_FWD_DEFINED__
#define __ISoftUSBInterfaces_FWD_DEFINED__
typedef interface ISoftUSBInterfaces ISoftUSBInterfaces;
#endif 	/* __ISoftUSBInterfaces_FWD_DEFINED__ */


#ifndef __ISoftUSBEndpoints_FWD_DEFINED__
#define __ISoftUSBEndpoints_FWD_DEFINED__
typedef interface ISoftUSBEndpoints ISoftUSBEndpoints;
#endif 	/* __ISoftUSBEndpoints_FWD_DEFINED__ */


#ifndef __ISoftUSBHub_FWD_DEFINED__
#define __ISoftUSBHub_FWD_DEFINED__
typedef interface ISoftUSBHub ISoftUSBHub;
#endif 	/* __ISoftUSBHub_FWD_DEFINED__ */


#ifndef __ISoftUSBHubPorts_FWD_DEFINED__
#define __ISoftUSBHubPorts_FWD_DEFINED__
typedef interface ISoftUSBHubPorts ISoftUSBHubPorts;
#endif 	/* __ISoftUSBHubPorts_FWD_DEFINED__ */


#ifndef __ISoftUSBHubPort_FWD_DEFINED__
#define __ISoftUSBHubPort_FWD_DEFINED__
typedef interface ISoftUSBHubPort ISoftUSBHubPort;
#endif 	/* __ISoftUSBHubPort_FWD_DEFINED__ */


#ifndef __ISoftUSBDevice_FWD_DEFINED__
#define __ISoftUSBDevice_FWD_DEFINED__
typedef interface ISoftUSBDevice ISoftUSBDevice;
#endif 	/* __ISoftUSBDevice_FWD_DEFINED__ */


#ifndef __SoftUSBDevice_FWD_DEFINED__
#define __SoftUSBDevice_FWD_DEFINED__

#ifdef __cplusplus
typedef class SoftUSBDevice SoftUSBDevice;
#else
typedef struct SoftUSBDevice SoftUSBDevice;
#endif /* __cplusplus */

#endif 	/* __SoftUSBDevice_FWD_DEFINED__ */


#ifndef __SoftUSBDeviceQualifier_FWD_DEFINED__
#define __SoftUSBDeviceQualifier_FWD_DEFINED__

#ifdef __cplusplus
typedef class SoftUSBDeviceQualifier SoftUSBDeviceQualifier;
#else
typedef struct SoftUSBDeviceQualifier SoftUSBDeviceQualifier;
#endif /* __cplusplus */

#endif 	/* __SoftUSBDeviceQualifier_FWD_DEFINED__ */


#ifndef __SoftUSBConfiguration_FWD_DEFINED__
#define __SoftUSBConfiguration_FWD_DEFINED__

#ifdef __cplusplus
typedef class SoftUSBConfiguration SoftUSBConfiguration;
#else
typedef struct SoftUSBConfiguration SoftUSBConfiguration;
#endif /* __cplusplus */

#endif 	/* __SoftUSBConfiguration_FWD_DEFINED__ */


#ifndef __SoftUSBInterface_FWD_DEFINED__
#define __SoftUSBInterface_FWD_DEFINED__

#ifdef __cplusplus
typedef class SoftUSBInterface SoftUSBInterface;
#else
typedef struct SoftUSBInterface SoftUSBInterface;
#endif /* __cplusplus */

#endif 	/* __SoftUSBInterface_FWD_DEFINED__ */


#ifndef __SoftUSBEndpoint_FWD_DEFINED__
#define __SoftUSBEndpoint_FWD_DEFINED__

#ifdef __cplusplus
typedef class SoftUSBEndpoint SoftUSBEndpoint;
#else
typedef struct SoftUSBEndpoint SoftUSBEndpoint;
#endif /* __cplusplus */

#endif 	/* __SoftUSBEndpoint_FWD_DEFINED__ */


#ifndef __SoftUSBConfigurations_FWD_DEFINED__
#define __SoftUSBConfigurations_FWD_DEFINED__

#ifdef __cplusplus
typedef class SoftUSBConfigurations SoftUSBConfigurations;
#else
typedef struct SoftUSBConfigurations SoftUSBConfigurations;
#endif /* __cplusplus */

#endif 	/* __SoftUSBConfigurations_FWD_DEFINED__ */


#ifndef __SoftUSBInterfaces_FWD_DEFINED__
#define __SoftUSBInterfaces_FWD_DEFINED__

#ifdef __cplusplus
typedef class SoftUSBInterfaces SoftUSBInterfaces;
#else
typedef struct SoftUSBInterfaces SoftUSBInterfaces;
#endif /* __cplusplus */

#endif 	/* __SoftUSBInterfaces_FWD_DEFINED__ */


#ifndef __SoftUSBEndpoints_FWD_DEFINED__
#define __SoftUSBEndpoints_FWD_DEFINED__

#ifdef __cplusplus
typedef class SoftUSBEndpoints SoftUSBEndpoints;
#else
typedef struct SoftUSBEndpoints SoftUSBEndpoints;
#endif /* __cplusplus */

#endif 	/* __SoftUSBEndpoints_FWD_DEFINED__ */


#ifndef __SoftUSBStrings_FWD_DEFINED__
#define __SoftUSBStrings_FWD_DEFINED__

#ifdef __cplusplus
typedef class SoftUSBStrings SoftUSBStrings;
#else
typedef struct SoftUSBStrings SoftUSBStrings;
#endif /* __cplusplus */

#endif 	/* __SoftUSBStrings_FWD_DEFINED__ */


#ifndef __ISoftUSBString_FWD_DEFINED__
#define __ISoftUSBString_FWD_DEFINED__
typedef interface ISoftUSBString ISoftUSBString;
#endif 	/* __ISoftUSBString_FWD_DEFINED__ */


#ifndef __SoftUSBString_FWD_DEFINED__
#define __SoftUSBString_FWD_DEFINED__

#ifdef __cplusplus
typedef class SoftUSBString SoftUSBString;
#else
typedef struct SoftUSBString SoftUSBString;
#endif /* __cplusplus */

#endif 	/* __SoftUSBString_FWD_DEFINED__ */


#ifndef __SoftUSBHub_FWD_DEFINED__
#define __SoftUSBHub_FWD_DEFINED__

#ifdef __cplusplus
typedef class SoftUSBHub SoftUSBHub;
#else
typedef struct SoftUSBHub SoftUSBHub;
#endif /* __cplusplus */

#endif 	/* __SoftUSBHub_FWD_DEFINED__ */


#ifndef __SoftUSBHubPorts_FWD_DEFINED__
#define __SoftUSBHubPorts_FWD_DEFINED__

#ifdef __cplusplus
typedef class SoftUSBHubPorts SoftUSBHubPorts;
#else
typedef struct SoftUSBHubPorts SoftUSBHubPorts;
#endif /* __cplusplus */

#endif 	/* __SoftUSBHubPorts_FWD_DEFINED__ */


#ifndef __SoftUSBHubPort_FWD_DEFINED__
#define __SoftUSBHubPort_FWD_DEFINED__

#ifdef __cplusplus
typedef class SoftUSBHubPort SoftUSBHubPort;
#else
typedef struct SoftUSBHubPort SoftUSBHubPort;
#endif /* __cplusplus */

#endif 	/* __SoftUSBHubPort_FWD_DEFINED__ */


#ifdef __cplusplus
extern "C"{
#endif 



#ifndef __SOFTUSB_LIBRARY_DEFINED__
#define __SOFTUSB_LIBRARY_DEFINED__

/* library SOFTUSB */
/* [helpstringcontext][helpcontext][helpstring][helpstringdll][helpfile][version][lcid][uuid] */ 
















#if defined (MIDL_PASS)
typedef struct LIST_ENTRY
    {
    struct LIST_ENTRY *Flink;
    struct LIST_ENTRY *Blink;
    } 	LIST_ENTRY;

#endif
typedef /* [helpstringcontext][helpcontext][helpstring][uuid] */  DECLSPEC_UUID("A0E64F57-5D2D-4EE2-A257-227A575ACC60") struct SOFTUSB_OUT_TRANSFER
    {
    BYTE bStatus;
    BYTE DataToggle;
    ULONG cbData;
    ULARGE_INTEGER uliQueuedTime;
    LIST_ENTRY NextTransfer;
    BYTE Data[ 1 ];
    } 	SOFTUSB_OUT_TRANSFER;

typedef /* [helpstringcontext][helpcontext][helpstring][uuid] */  DECLSPEC_UUID("17C3648C-CE1B-41EE-86CE-C681264A8336") 
enum RequestMatchOpts
    {	MatchExactLength	= 0,
	MatchAnyLength	= 1
    } 	RequestMatchOpts;

typedef /* [helpstringcontext][helpcontext][helpstring][uuid] */  DECLSPEC_UUID("550F7244-399C-4155-ADF0-2CCD83BB00F0") 
enum SoftUSBHubPowerSwitchingMode
    {	GangedPowerSwitching	= 0,
	IndividualPowerSwitching	= 1,
	NoPowerSwitching	= 2
    } 	SoftUSBHubPowerSwitchingMode;

typedef /* [helpstringcontext][helpcontext][helpstring][uuid] */  DECLSPEC_UUID("5BEA0626-9743-4517-8283-ECFAD924F4DB") 
enum SoftUSBHubOverCurrentProtectionMode
    {	GlobalOverCurrentProtection	= 0,
	IndividualOverCurrentProtection	= 1,
	NoOverCurrentProtection	= 2
    } 	SoftUSBHubOverCurrentProtectionMode;

typedef /* [helpstringcontext][helpcontext][helpstring][uuid] */  DECLSPEC_UUID("2A3C8E65-6335-4920-AFEA-DF6ED9B02760") 
enum SoftUSBHubSpeed
    {	SoftUSBHubSpeedLow	= 0,
	SoftUSBHubSpeedFull	= 1,
	SoftUSBHubSpeedHigh	= 2,
	SoftUSBHubNotConnected	= 3
    } 	SoftUSBHubSpeed;

typedef /* [helpstringcontext][helpcontext][helpstring][uuid] */  DECLSPEC_UUID("07B2373A-6942-491E-9BF7-CACF68A454F5") 
enum SoftUSBHubIndicator
    {	SoftUSBHubOff	= 0,
	SoftUSBHubAmber	= 1,
	SoftUSBHubGreen	= 2,
	SoftUSBHubBlinkingOffGreen	= 3,
	SoftUSBHubBlinkingOffAmber	= 4,
	SoftUSBHubBlinkingGreenAmber	= 5
    } 	SoftUSBHubIndicator;

typedef /* [helpstringcontext][helpcontext][helpstring][uuid] */  DECLSPEC_UUID("2A3A45AE-3650-4922-8502-BA5960186974") 
enum SoftUSBDeviceState
    {	SoftUSBDeviceStateDetached	= 0,
	SoftUSBDeviceStateAttached	= 1,
	SoftUSBDeviceStatePowered	= 2,
	SoftUSBDeviceStateDefault	= 3,
	SoftWUSBDeviceStateUnconnected	= 4,
	SoftWUSBDeviceStateUnauthenticated	= 5,
	SoftUSBDeviceStateAddress	= 6,
	SoftUSBDeviceStateConfigured	= 7,
	SoftUSBDeviceStateSuspended	= 8
    } 	SoftUSBDeviceState;

#define	SOFTUSB_FOREVER	( ( ULONG  )-1 )

#define	SOFTUSB_ALL	( ( ULONG  )-1 )

#define	SOFTUSBENDPOINT_OBJECTFLAGS	( 100 )

#define	SOFTUSBENDPOINT_DONOTTRACETRANSFERS	( 0 )

#define	SOFTUSBENDPOINT_TRACETRANSFERINPUT	( 0x1 )

#define	SOFTUSBENDPOINT_TRACETRANSFEROUPUT	( 0x2 )

#define	SOFTUSBENDPOINT_TRACETRANSFERINPUTANDOUPUT	( 0x3 )

#define	SOFTUSBENDPOINT_TRACEOUTLISTOVERFLOW	( 0x20 )


EXTERN_C const IID LIBID_SOFTUSB;

#ifndef __ISoftUSBConfigurations_INTERFACE_DEFINED__
#define __ISoftUSBConfigurations_INTERFACE_DEFINED__

/* interface ISoftUSBConfigurations */
/* [helpstringcontext][helpcontext][helpstring][object][hidden][nonextensible][oleautomation][dual][uuid] */ 


EXTERN_C const IID IID_ISoftUSBConfigurations;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("15482CE8-BA91-4CEC-9D42-62C8390C3EAC")
    ISoftUSBConfigurations : public IDispatch
    {
    public:
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_Count( 
            /* [retval][out] */ __RPC__out long *plCount) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_Item( 
            /* [in] */ VARIANT Index,
            /* [retval][out] */ __RPC__deref_out_opt SoftUSBConfiguration	**ppSOFTUSBConfig) = 0;
        
        virtual /* [hidden][propget][id] */ HRESULT __stdcall get__NewEnum( 
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **ppunkEnum) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][id] */ HRESULT __stdcall Add( 
            /* [in] */ __RPC__in SoftUSBConfiguration	*ppSOFTUSBConfig,
            /* [optional][in] */ VARIANT Index) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][id] */ HRESULT __stdcall Remove( 
            /* [in] */ VARIANT Index) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][id] */ HRESULT __stdcall Clear( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISoftUSBConfigurationsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISoftUSBConfigurations * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISoftUSBConfigurations * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISoftUSBConfigurations * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ISoftUSBConfigurations * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ISoftUSBConfigurations * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ISoftUSBConfigurations * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ISoftUSBConfigurations * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_Count )( 
            ISoftUSBConfigurations * This,
            /* [retval][out] */ __RPC__out long *plCount);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_Item )( 
            ISoftUSBConfigurations * This,
            /* [in] */ VARIANT Index,
            /* [retval][out] */ __RPC__deref_out_opt SoftUSBConfiguration	**ppSOFTUSBConfig);
        
        /* [hidden][propget][id] */ HRESULT ( __stdcall *get__NewEnum )( 
            ISoftUSBConfigurations * This,
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **ppunkEnum);
        
        /* [helpstringcontext][helpcontext][helpstring][id] */ HRESULT ( __stdcall *Add )( 
            ISoftUSBConfigurations * This,
            /* [in] */ __RPC__in SoftUSBConfiguration	*ppSOFTUSBConfig,
            /* [optional][in] */ VARIANT Index);
        
        /* [helpstringcontext][helpcontext][helpstring][id] */ HRESULT ( __stdcall *Remove )( 
            ISoftUSBConfigurations * This,
            /* [in] */ VARIANT Index);
        
        /* [helpstringcontext][helpcontext][helpstring][id] */ HRESULT ( __stdcall *Clear )( 
            ISoftUSBConfigurations * This);
        
        END_INTERFACE
    } ISoftUSBConfigurationsVtbl;

    interface ISoftUSBConfigurations
    {
        CONST_VTBL struct ISoftUSBConfigurationsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISoftUSBConfigurations_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ISoftUSBConfigurations_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ISoftUSBConfigurations_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ISoftUSBConfigurations_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ISoftUSBConfigurations_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ISoftUSBConfigurations_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ISoftUSBConfigurations_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ISoftUSBConfigurations_get_Count(This,plCount)	\
    ( (This)->lpVtbl -> get_Count(This,plCount) ) 

#define ISoftUSBConfigurations_get_Item(This,Index,ppSOFTUSBConfig)	\
    ( (This)->lpVtbl -> get_Item(This,Index,ppSOFTUSBConfig) ) 

#define ISoftUSBConfigurations_get__NewEnum(This,ppunkEnum)	\
    ( (This)->lpVtbl -> get__NewEnum(This,ppunkEnum) ) 

#define ISoftUSBConfigurations_Add(This,ppSOFTUSBConfig,Index)	\
    ( (This)->lpVtbl -> Add(This,ppSOFTUSBConfig,Index) ) 

#define ISoftUSBConfigurations_Remove(This,Index)	\
    ( (This)->lpVtbl -> Remove(This,Index) ) 

#define ISoftUSBConfigurations_Clear(This)	\
    ( (This)->lpVtbl -> Clear(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ISoftUSBConfigurations_INTERFACE_DEFINED__ */


#ifndef __ISoftUSBConfiguration_INTERFACE_DEFINED__
#define __ISoftUSBConfiguration_INTERFACE_DEFINED__

/* interface ISoftUSBConfiguration */
/* [helpstringcontext][helpcontext][helpstring][object][hidden][nonextensible][oleautomation][dual][uuid] */ 


EXTERN_C const IID IID_ISoftUSBConfiguration;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2043f5a3-28de-4618-a5a6-519cefe62d96")
    ISoftUSBConfiguration : public IDispatch
    {
    public:
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_Length( 
            /* [retval][out] */ __RPC__out BYTE *pbLength) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT __stdcall put_Length( 
            /* [in] */ BYTE bLength) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_DescriptorType( 
            /* [retval][out] */ __RPC__out BYTE *pbDescriptorType) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT __stdcall put_DescriptorType( 
            /* [in] */ BYTE bDescriptorType) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_TotalLength( 
            /* [retval][out] */ __RPC__out SHORT *psTotalLength) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_NumInterfaces( 
            /* [retval][out] */ __RPC__out BYTE *pbNumInterfaces) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_ConfigurationValue( 
            /* [retval][out] */ __RPC__out BYTE *pbConfigValue) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT __stdcall put_ConfigurationValue( 
            /* [in] */ BYTE bConfigValue) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_Configuration( 
            /* [retval][out] */ __RPC__out BYTE *pbConfig) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT __stdcall put_Configuration( 
            /* [in] */ BYTE bConfig) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_Attributes( 
            /* [retval][out] */ __RPC__out BYTE *pbAttributes) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT __stdcall put_Attributes( 
            /* [in] */ BYTE bAttributes) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_MaxPower( 
            /* [retval][out] */ __RPC__out BYTE *pbMaxPower) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT __stdcall put_MaxPower( 
            /* [in] */ BYTE bMaxPower) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_Interfaces( 
            /* [retval][out] */ __RPC__deref_out_opt ISoftUSBInterfaces **ppiInterfaces) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_AlternateForInterface( 
            /* [in] */ BYTE bInterface,
            /* [retval][out] */ __RPC__deref_out_opt ISoftUSBInterface **ppiInterface) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_DeviceSpecificDescriptor( 
            /* [retval][out] */ __RPC__deref_out_opt SAFEARRAY * *ppsaDevSpecData) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT __stdcall put_DeviceSpecificDescriptor( 
            /* [in] */ __RPC__in SAFEARRAY * psaDevSpecData) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_Context( 
            /* [retval][out] */ __RPC__deref_out_opt /* external definition not present */ DSFPropertyBag **ppContext) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISoftUSBConfigurationVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISoftUSBConfiguration * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISoftUSBConfiguration * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISoftUSBConfiguration * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ISoftUSBConfiguration * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ISoftUSBConfiguration * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ISoftUSBConfiguration * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ISoftUSBConfiguration * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_Length )( 
            ISoftUSBConfiguration * This,
            /* [retval][out] */ __RPC__out BYTE *pbLength);
        
        /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT ( __stdcall *put_Length )( 
            ISoftUSBConfiguration * This,
            /* [in] */ BYTE bLength);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_DescriptorType )( 
            ISoftUSBConfiguration * This,
            /* [retval][out] */ __RPC__out BYTE *pbDescriptorType);
        
        /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT ( __stdcall *put_DescriptorType )( 
            ISoftUSBConfiguration * This,
            /* [in] */ BYTE bDescriptorType);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_TotalLength )( 
            ISoftUSBConfiguration * This,
            /* [retval][out] */ __RPC__out SHORT *psTotalLength);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_NumInterfaces )( 
            ISoftUSBConfiguration * This,
            /* [retval][out] */ __RPC__out BYTE *pbNumInterfaces);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_ConfigurationValue )( 
            ISoftUSBConfiguration * This,
            /* [retval][out] */ __RPC__out BYTE *pbConfigValue);
        
        /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT ( __stdcall *put_ConfigurationValue )( 
            ISoftUSBConfiguration * This,
            /* [in] */ BYTE bConfigValue);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_Configuration )( 
            ISoftUSBConfiguration * This,
            /* [retval][out] */ __RPC__out BYTE *pbConfig);
        
        /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT ( __stdcall *put_Configuration )( 
            ISoftUSBConfiguration * This,
            /* [in] */ BYTE bConfig);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_Attributes )( 
            ISoftUSBConfiguration * This,
            /* [retval][out] */ __RPC__out BYTE *pbAttributes);
        
        /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT ( __stdcall *put_Attributes )( 
            ISoftUSBConfiguration * This,
            /* [in] */ BYTE bAttributes);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_MaxPower )( 
            ISoftUSBConfiguration * This,
            /* [retval][out] */ __RPC__out BYTE *pbMaxPower);
        
        /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT ( __stdcall *put_MaxPower )( 
            ISoftUSBConfiguration * This,
            /* [in] */ BYTE bMaxPower);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_Interfaces )( 
            ISoftUSBConfiguration * This,
            /* [retval][out] */ __RPC__deref_out_opt ISoftUSBInterfaces **ppiInterfaces);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_AlternateForInterface )( 
            ISoftUSBConfiguration * This,
            /* [in] */ BYTE bInterface,
            /* [retval][out] */ __RPC__deref_out_opt ISoftUSBInterface **ppiInterface);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_DeviceSpecificDescriptor )( 
            ISoftUSBConfiguration * This,
            /* [retval][out] */ __RPC__deref_out_opt SAFEARRAY * *ppsaDevSpecData);
        
        /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT ( __stdcall *put_DeviceSpecificDescriptor )( 
            ISoftUSBConfiguration * This,
            /* [in] */ __RPC__in SAFEARRAY * psaDevSpecData);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_Context )( 
            ISoftUSBConfiguration * This,
            /* [retval][out] */ __RPC__deref_out_opt /* external definition not present */ DSFPropertyBag **ppContext);
        
        END_INTERFACE
    } ISoftUSBConfigurationVtbl;

    interface ISoftUSBConfiguration
    {
        CONST_VTBL struct ISoftUSBConfigurationVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISoftUSBConfiguration_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ISoftUSBConfiguration_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ISoftUSBConfiguration_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ISoftUSBConfiguration_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ISoftUSBConfiguration_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ISoftUSBConfiguration_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ISoftUSBConfiguration_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ISoftUSBConfiguration_get_Length(This,pbLength)	\
    ( (This)->lpVtbl -> get_Length(This,pbLength) ) 

#define ISoftUSBConfiguration_put_Length(This,bLength)	\
    ( (This)->lpVtbl -> put_Length(This,bLength) ) 

#define ISoftUSBConfiguration_get_DescriptorType(This,pbDescriptorType)	\
    ( (This)->lpVtbl -> get_DescriptorType(This,pbDescriptorType) ) 

#define ISoftUSBConfiguration_put_DescriptorType(This,bDescriptorType)	\
    ( (This)->lpVtbl -> put_DescriptorType(This,bDescriptorType) ) 

#define ISoftUSBConfiguration_get_TotalLength(This,psTotalLength)	\
    ( (This)->lpVtbl -> get_TotalLength(This,psTotalLength) ) 

#define ISoftUSBConfiguration_get_NumInterfaces(This,pbNumInterfaces)	\
    ( (This)->lpVtbl -> get_NumInterfaces(This,pbNumInterfaces) ) 

#define ISoftUSBConfiguration_get_ConfigurationValue(This,pbConfigValue)	\
    ( (This)->lpVtbl -> get_ConfigurationValue(This,pbConfigValue) ) 

#define ISoftUSBConfiguration_put_ConfigurationValue(This,bConfigValue)	\
    ( (This)->lpVtbl -> put_ConfigurationValue(This,bConfigValue) ) 

#define ISoftUSBConfiguration_get_Configuration(This,pbConfig)	\
    ( (This)->lpVtbl -> get_Configuration(This,pbConfig) ) 

#define ISoftUSBConfiguration_put_Configuration(This,bConfig)	\
    ( (This)->lpVtbl -> put_Configuration(This,bConfig) ) 

#define ISoftUSBConfiguration_get_Attributes(This,pbAttributes)	\
    ( (This)->lpVtbl -> get_Attributes(This,pbAttributes) ) 

#define ISoftUSBConfiguration_put_Attributes(This,bAttributes)	\
    ( (This)->lpVtbl -> put_Attributes(This,bAttributes) ) 

#define ISoftUSBConfiguration_get_MaxPower(This,pbMaxPower)	\
    ( (This)->lpVtbl -> get_MaxPower(This,pbMaxPower) ) 

#define ISoftUSBConfiguration_put_MaxPower(This,bMaxPower)	\
    ( (This)->lpVtbl -> put_MaxPower(This,bMaxPower) ) 

#define ISoftUSBConfiguration_get_Interfaces(This,ppiInterfaces)	\
    ( (This)->lpVtbl -> get_Interfaces(This,ppiInterfaces) ) 

#define ISoftUSBConfiguration_get_AlternateForInterface(This,bInterface,ppiInterface)	\
    ( (This)->lpVtbl -> get_AlternateForInterface(This,bInterface,ppiInterface) ) 

#define ISoftUSBConfiguration_get_DeviceSpecificDescriptor(This,ppsaDevSpecData)	\
    ( (This)->lpVtbl -> get_DeviceSpecificDescriptor(This,ppsaDevSpecData) ) 

#define ISoftUSBConfiguration_put_DeviceSpecificDescriptor(This,psaDevSpecData)	\
    ( (This)->lpVtbl -> put_DeviceSpecificDescriptor(This,psaDevSpecData) ) 

#define ISoftUSBConfiguration_get_Context(This,ppContext)	\
    ( (This)->lpVtbl -> get_Context(This,ppContext) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ISoftUSBConfiguration_INTERFACE_DEFINED__ */


#ifndef __ISoftUSBInterface_INTERFACE_DEFINED__
#define __ISoftUSBInterface_INTERFACE_DEFINED__

/* interface ISoftUSBInterface */
/* [helpstringcontext][helpcontext][helpstring][object][hidden][nonextensible][oleautomation][dual][uuid] */ 


EXTERN_C const IID IID_ISoftUSBInterface;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("62bb9c16-8608-4f32-8f8a-ace032f38628")
    ISoftUSBInterface : public IDispatch
    {
    public:
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_Length( 
            /* [retval][out] */ __RPC__out BYTE *pbLength) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT __stdcall put_Length( 
            /* [in] */ BYTE bLength) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_DescriptorType( 
            /* [retval][out] */ __RPC__out BYTE *pbDescriptorType) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT __stdcall put_DescriptorType( 
            /* [in] */ BYTE bDescriptorType) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_InterfaceNumber( 
            /* [retval][out] */ __RPC__out BYTE *pbInterfaceNumber) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT __stdcall put_InterfaceNumber( 
            /* [in] */ BYTE bInterfaceNumber) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_AlternateSetting( 
            /* [retval][out] */ __RPC__out BYTE *pbAlternateSetting) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT __stdcall put_AlternateSetting( 
            /* [in] */ BYTE bAlternateSetting) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_NumEndpoints( 
            /* [retval][out] */ __RPC__out BYTE *pbNumEndpoints) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_InterfaceClass( 
            /* [retval][out] */ __RPC__out BYTE *pbClass) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT __stdcall put_InterfaceClass( 
            /* [in] */ BYTE bClass) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_InterfaceSubClass( 
            /* [retval][out] */ __RPC__out BYTE *pbSubClass) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT __stdcall put_InterfaceSubClass( 
            /* [in] */ BYTE bSubClass) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_InterfaceProtocol( 
            /* [retval][out] */ __RPC__out BYTE *pbProtocol) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT __stdcall put_InterfaceProtocol( 
            /* [in] */ BYTE bProtocol) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_Interface( 
            /* [retval][out] */ __RPC__out BYTE *pbInterface) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT __stdcall put_Interface( 
            /* [in] */ BYTE bInterface) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_Endpoints( 
            /* [retval][out] */ __RPC__deref_out_opt ISoftUSBEndpoints **ppiEndPoints) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_DeviceSpecificDescriptor( 
            /* [retval][out] */ __RPC__deref_out_opt SAFEARRAY * *ppsaDevSpecData) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT __stdcall put_DeviceSpecificDescriptor( 
            /* [in] */ __RPC__in SAFEARRAY * psaDevSpecData) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_Context( 
            /* [retval][out] */ __RPC__deref_out_opt /* external definition not present */ DSFPropertyBag **ppContext) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISoftUSBInterfaceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISoftUSBInterface * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISoftUSBInterface * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISoftUSBInterface * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ISoftUSBInterface * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ISoftUSBInterface * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ISoftUSBInterface * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ISoftUSBInterface * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_Length )( 
            ISoftUSBInterface * This,
            /* [retval][out] */ __RPC__out BYTE *pbLength);
        
        /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT ( __stdcall *put_Length )( 
            ISoftUSBInterface * This,
            /* [in] */ BYTE bLength);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_DescriptorType )( 
            ISoftUSBInterface * This,
            /* [retval][out] */ __RPC__out BYTE *pbDescriptorType);
        
        /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT ( __stdcall *put_DescriptorType )( 
            ISoftUSBInterface * This,
            /* [in] */ BYTE bDescriptorType);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_InterfaceNumber )( 
            ISoftUSBInterface * This,
            /* [retval][out] */ __RPC__out BYTE *pbInterfaceNumber);
        
        /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT ( __stdcall *put_InterfaceNumber )( 
            ISoftUSBInterface * This,
            /* [in] */ BYTE bInterfaceNumber);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_AlternateSetting )( 
            ISoftUSBInterface * This,
            /* [retval][out] */ __RPC__out BYTE *pbAlternateSetting);
        
        /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT ( __stdcall *put_AlternateSetting )( 
            ISoftUSBInterface * This,
            /* [in] */ BYTE bAlternateSetting);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_NumEndpoints )( 
            ISoftUSBInterface * This,
            /* [retval][out] */ __RPC__out BYTE *pbNumEndpoints);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_InterfaceClass )( 
            ISoftUSBInterface * This,
            /* [retval][out] */ __RPC__out BYTE *pbClass);
        
        /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT ( __stdcall *put_InterfaceClass )( 
            ISoftUSBInterface * This,
            /* [in] */ BYTE bClass);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_InterfaceSubClass )( 
            ISoftUSBInterface * This,
            /* [retval][out] */ __RPC__out BYTE *pbSubClass);
        
        /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT ( __stdcall *put_InterfaceSubClass )( 
            ISoftUSBInterface * This,
            /* [in] */ BYTE bSubClass);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_InterfaceProtocol )( 
            ISoftUSBInterface * This,
            /* [retval][out] */ __RPC__out BYTE *pbProtocol);
        
        /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT ( __stdcall *put_InterfaceProtocol )( 
            ISoftUSBInterface * This,
            /* [in] */ BYTE bProtocol);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_Interface )( 
            ISoftUSBInterface * This,
            /* [retval][out] */ __RPC__out BYTE *pbInterface);
        
        /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT ( __stdcall *put_Interface )( 
            ISoftUSBInterface * This,
            /* [in] */ BYTE bInterface);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_Endpoints )( 
            ISoftUSBInterface * This,
            /* [retval][out] */ __RPC__deref_out_opt ISoftUSBEndpoints **ppiEndPoints);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_DeviceSpecificDescriptor )( 
            ISoftUSBInterface * This,
            /* [retval][out] */ __RPC__deref_out_opt SAFEARRAY * *ppsaDevSpecData);
        
        /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT ( __stdcall *put_DeviceSpecificDescriptor )( 
            ISoftUSBInterface * This,
            /* [in] */ __RPC__in SAFEARRAY * psaDevSpecData);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_Context )( 
            ISoftUSBInterface * This,
            /* [retval][out] */ __RPC__deref_out_opt /* external definition not present */ DSFPropertyBag **ppContext);
        
        END_INTERFACE
    } ISoftUSBInterfaceVtbl;

    interface ISoftUSBInterface
    {
        CONST_VTBL struct ISoftUSBInterfaceVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISoftUSBInterface_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ISoftUSBInterface_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ISoftUSBInterface_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ISoftUSBInterface_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ISoftUSBInterface_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ISoftUSBInterface_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ISoftUSBInterface_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ISoftUSBInterface_get_Length(This,pbLength)	\
    ( (This)->lpVtbl -> get_Length(This,pbLength) ) 

#define ISoftUSBInterface_put_Length(This,bLength)	\
    ( (This)->lpVtbl -> put_Length(This,bLength) ) 

#define ISoftUSBInterface_get_DescriptorType(This,pbDescriptorType)	\
    ( (This)->lpVtbl -> get_DescriptorType(This,pbDescriptorType) ) 

#define ISoftUSBInterface_put_DescriptorType(This,bDescriptorType)	\
    ( (This)->lpVtbl -> put_DescriptorType(This,bDescriptorType) ) 

#define ISoftUSBInterface_get_InterfaceNumber(This,pbInterfaceNumber)	\
    ( (This)->lpVtbl -> get_InterfaceNumber(This,pbInterfaceNumber) ) 

#define ISoftUSBInterface_put_InterfaceNumber(This,bInterfaceNumber)	\
    ( (This)->lpVtbl -> put_InterfaceNumber(This,bInterfaceNumber) ) 

#define ISoftUSBInterface_get_AlternateSetting(This,pbAlternateSetting)	\
    ( (This)->lpVtbl -> get_AlternateSetting(This,pbAlternateSetting) ) 

#define ISoftUSBInterface_put_AlternateSetting(This,bAlternateSetting)	\
    ( (This)->lpVtbl -> put_AlternateSetting(This,bAlternateSetting) ) 

#define ISoftUSBInterface_get_NumEndpoints(This,pbNumEndpoints)	\
    ( (This)->lpVtbl -> get_NumEndpoints(This,pbNumEndpoints) ) 

#define ISoftUSBInterface_get_InterfaceClass(This,pbClass)	\
    ( (This)->lpVtbl -> get_InterfaceClass(This,pbClass) ) 

#define ISoftUSBInterface_put_InterfaceClass(This,bClass)	\
    ( (This)->lpVtbl -> put_InterfaceClass(This,bClass) ) 

#define ISoftUSBInterface_get_InterfaceSubClass(This,pbSubClass)	\
    ( (This)->lpVtbl -> get_InterfaceSubClass(This,pbSubClass) ) 

#define ISoftUSBInterface_put_InterfaceSubClass(This,bSubClass)	\
    ( (This)->lpVtbl -> put_InterfaceSubClass(This,bSubClass) ) 

#define ISoftUSBInterface_get_InterfaceProtocol(This,pbProtocol)	\
    ( (This)->lpVtbl -> get_InterfaceProtocol(This,pbProtocol) ) 

#define ISoftUSBInterface_put_InterfaceProtocol(This,bProtocol)	\
    ( (This)->lpVtbl -> put_InterfaceProtocol(This,bProtocol) ) 

#define ISoftUSBInterface_get_Interface(This,pbInterface)	\
    ( (This)->lpVtbl -> get_Interface(This,pbInterface) ) 

#define ISoftUSBInterface_put_Interface(This,bInterface)	\
    ( (This)->lpVtbl -> put_Interface(This,bInterface) ) 

#define ISoftUSBInterface_get_Endpoints(This,ppiEndPoints)	\
    ( (This)->lpVtbl -> get_Endpoints(This,ppiEndPoints) ) 

#define ISoftUSBInterface_get_DeviceSpecificDescriptor(This,ppsaDevSpecData)	\
    ( (This)->lpVtbl -> get_DeviceSpecificDescriptor(This,ppsaDevSpecData) ) 

#define ISoftUSBInterface_put_DeviceSpecificDescriptor(This,psaDevSpecData)	\
    ( (This)->lpVtbl -> put_DeviceSpecificDescriptor(This,psaDevSpecData) ) 

#define ISoftUSBInterface_get_Context(This,ppContext)	\
    ( (This)->lpVtbl -> get_Context(This,ppContext) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ISoftUSBInterface_INTERFACE_DEFINED__ */


#ifndef __ISoftUSBEndpoint_INTERFACE_DEFINED__
#define __ISoftUSBEndpoint_INTERFACE_DEFINED__

/* interface ISoftUSBEndpoint */
/* [helpstringcontext][helpcontext][helpstring][object][hidden][dual][nonextensible][uuid] */ 


EXTERN_C const IID IID_ISoftUSBEndpoint;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("fd6ea833-81cb-4065-a219-8528bdcdc2e6")
    ISoftUSBEndpoint : public IDispatch
    {
    public:
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_Length( 
            /* [retval][out] */ __RPC__out BYTE *pbLength) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT __stdcall put_Length( 
            /* [in] */ BYTE bLength) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_DescriptorType( 
            /* [retval][out] */ __RPC__out BYTE *pbDescriptorType) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT __stdcall put_DescriptorType( 
            /* [in] */ BYTE bDescriptorType) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_EndpointAddress( 
            /* [retval][out] */ __RPC__out BYTE *pbAddress) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT __stdcall put_EndpointAddress( 
            /* [in] */ BYTE bAddress) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_Attributes( 
            /* [retval][out] */ __RPC__out BYTE *pbAttributes) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT __stdcall put_Attributes( 
            /* [in] */ BYTE bAttributes) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_MaxPacketSize( 
            /* [retval][out] */ __RPC__out SHORT *psMaxPacket) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT __stdcall put_MaxPacketSize( 
            /* [in] */ SHORT sMaxPacketSize) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_Interval( 
            /* [retval][out] */ __RPC__out BYTE *pbInterval) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT __stdcall put_Interval( 
            /* [in] */ BYTE bInterval) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_Halted( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pHalted) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT __stdcall put_Halted( 
            /* [in] */ VARIANT_BOOL Halted) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_MarshalEvents( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pMarshalEvents) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT __stdcall put_MarshalEvents( 
            /* [in] */ VARIANT_BOOL MarshalEvents) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_OutQueueSize( 
            /* [retval][out] */ __RPC__out long *plOutQueueSize) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT __stdcall put_OutQueueSize( 
            /* [in] */ long lOutQueueSize) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_LoopbackEndpoint( 
            /* [retval][out] */ __RPC__deref_out_opt ISoftUSBEndpoint **ppiSoftUSBEndpoint) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT __stdcall put_LoopbackEndpoint( 
            /* [in] */ __RPC__in_opt ISoftUSBEndpoint *piSoftUSBEndpoint) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propputref][id] */ HRESULT __stdcall putref_LoopbackEndpoint( 
            /* [in] */ __RPC__in_opt ISoftUSBEndpoint *piSoftUSBEndpoint) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_HandleStdDeviceRequests( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pHandleStdRequests) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT __stdcall put_HandleStdDeviceRequests( 
            /* [in] */ VARIANT_BOOL HandleStdRequests) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_DeviceSpecificDescriptor( 
            /* [retval][out] */ __RPC__deref_out_opt SAFEARRAY * *ppsaDevSpecData) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT __stdcall put_DeviceSpecificDescriptor( 
            /* [in] */ __RPC__in SAFEARRAY * psaDevSpecData) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_Context( 
            /* [retval][out] */ __RPC__deref_out_opt /* external definition not present */ DSFPropertyBag **ppContext) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring] */ HRESULT __stdcall QueueINData( 
            /* [in] */ __RPC__in BYTE *pbDataBuffer,
            /* [in] */ ULONG cbDataBuffer,
            /* [in] */ BYTE bStatus,
            /* [in] */ ULONG ulTimeToLive) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][id] */ HRESULT __stdcall DrainOUTQueue( 
            /* [in] */ ULONG cMaxTransfers,
            /* [out] */ __RPC__out ULONG *pcTransfersRemaining,
            /* [out] */ __RPC__deref_out_opt SOFTUSB_OUT_TRANSFER **ppTransfers) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][id] */ void __stdcall FreeOUTQueue( 
            /* [in] */ __RPC__in void *pTransfers) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][id] */ HRESULT __stdcall QueueDeviceRequestResponse( 
            /* [in] */ __RPC__in USBSETUPREQUEST *pRequest,
            /* [in] */ RequestMatchOpts MatchOpt,
            /* [in] */ __RPC__in BYTE *pbResponseData,
            /* [in] */ ULONG cbResponseData,
            /* [in] */ BYTE FinalRequestStatus,
            /* [in] */ ULONG ulTimeToLive) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][id] */ HRESULT __stdcall PurgeINQueue( void) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][id] */ HRESULT __stdcall PurgeOUTQueue( void) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][id] */ HRESULT __stdcall PurgeOUTQueueOlderThan( 
            /* [in] */ ULONG ulOlderThan) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISoftUSBEndpointVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISoftUSBEndpoint * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISoftUSBEndpoint * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISoftUSBEndpoint * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ISoftUSBEndpoint * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ISoftUSBEndpoint * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ISoftUSBEndpoint * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ISoftUSBEndpoint * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_Length )( 
            ISoftUSBEndpoint * This,
            /* [retval][out] */ __RPC__out BYTE *pbLength);
        
        /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT ( __stdcall *put_Length )( 
            ISoftUSBEndpoint * This,
            /* [in] */ BYTE bLength);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_DescriptorType )( 
            ISoftUSBEndpoint * This,
            /* [retval][out] */ __RPC__out BYTE *pbDescriptorType);
        
        /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT ( __stdcall *put_DescriptorType )( 
            ISoftUSBEndpoint * This,
            /* [in] */ BYTE bDescriptorType);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_EndpointAddress )( 
            ISoftUSBEndpoint * This,
            /* [retval][out] */ __RPC__out BYTE *pbAddress);
        
        /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT ( __stdcall *put_EndpointAddress )( 
            ISoftUSBEndpoint * This,
            /* [in] */ BYTE bAddress);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_Attributes )( 
            ISoftUSBEndpoint * This,
            /* [retval][out] */ __RPC__out BYTE *pbAttributes);
        
        /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT ( __stdcall *put_Attributes )( 
            ISoftUSBEndpoint * This,
            /* [in] */ BYTE bAttributes);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_MaxPacketSize )( 
            ISoftUSBEndpoint * This,
            /* [retval][out] */ __RPC__out SHORT *psMaxPacket);
        
        /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT ( __stdcall *put_MaxPacketSize )( 
            ISoftUSBEndpoint * This,
            /* [in] */ SHORT sMaxPacketSize);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_Interval )( 
            ISoftUSBEndpoint * This,
            /* [retval][out] */ __RPC__out BYTE *pbInterval);
        
        /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT ( __stdcall *put_Interval )( 
            ISoftUSBEndpoint * This,
            /* [in] */ BYTE bInterval);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_Halted )( 
            ISoftUSBEndpoint * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pHalted);
        
        /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT ( __stdcall *put_Halted )( 
            ISoftUSBEndpoint * This,
            /* [in] */ VARIANT_BOOL Halted);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_MarshalEvents )( 
            ISoftUSBEndpoint * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pMarshalEvents);
        
        /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT ( __stdcall *put_MarshalEvents )( 
            ISoftUSBEndpoint * This,
            /* [in] */ VARIANT_BOOL MarshalEvents);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_OutQueueSize )( 
            ISoftUSBEndpoint * This,
            /* [retval][out] */ __RPC__out long *plOutQueueSize);
        
        /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT ( __stdcall *put_OutQueueSize )( 
            ISoftUSBEndpoint * This,
            /* [in] */ long lOutQueueSize);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_LoopbackEndpoint )( 
            ISoftUSBEndpoint * This,
            /* [retval][out] */ __RPC__deref_out_opt ISoftUSBEndpoint **ppiSoftUSBEndpoint);
        
        /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT ( __stdcall *put_LoopbackEndpoint )( 
            ISoftUSBEndpoint * This,
            /* [in] */ __RPC__in_opt ISoftUSBEndpoint *piSoftUSBEndpoint);
        
        /* [helpstringcontext][helpcontext][helpstring][propputref][id] */ HRESULT ( __stdcall *putref_LoopbackEndpoint )( 
            ISoftUSBEndpoint * This,
            /* [in] */ __RPC__in_opt ISoftUSBEndpoint *piSoftUSBEndpoint);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_HandleStdDeviceRequests )( 
            ISoftUSBEndpoint * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pHandleStdRequests);
        
        /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT ( __stdcall *put_HandleStdDeviceRequests )( 
            ISoftUSBEndpoint * This,
            /* [in] */ VARIANT_BOOL HandleStdRequests);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_DeviceSpecificDescriptor )( 
            ISoftUSBEndpoint * This,
            /* [retval][out] */ __RPC__deref_out_opt SAFEARRAY * *ppsaDevSpecData);
        
        /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT ( __stdcall *put_DeviceSpecificDescriptor )( 
            ISoftUSBEndpoint * This,
            /* [in] */ __RPC__in SAFEARRAY * psaDevSpecData);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_Context )( 
            ISoftUSBEndpoint * This,
            /* [retval][out] */ __RPC__deref_out_opt /* external definition not present */ DSFPropertyBag **ppContext);
        
        /* [helpstringcontext][helpcontext][helpstring] */ HRESULT ( __stdcall *QueueINData )( 
            ISoftUSBEndpoint * This,
            /* [in] */ __RPC__in BYTE *pbDataBuffer,
            /* [in] */ ULONG cbDataBuffer,
            /* [in] */ BYTE bStatus,
            /* [in] */ ULONG ulTimeToLive);
        
        /* [helpstringcontext][helpcontext][helpstring][id] */ HRESULT ( __stdcall *DrainOUTQueue )( 
            ISoftUSBEndpoint * This,
            /* [in] */ ULONG cMaxTransfers,
            /* [out] */ __RPC__out ULONG *pcTransfersRemaining,
            /* [out] */ __RPC__deref_out_opt SOFTUSB_OUT_TRANSFER **ppTransfers);
        
        /* [helpstringcontext][helpcontext][helpstring][id] */ void ( __stdcall *FreeOUTQueue )( 
            ISoftUSBEndpoint * This,
            /* [in] */ __RPC__in void *pTransfers);
        
        /* [helpstringcontext][helpcontext][helpstring][id] */ HRESULT ( __stdcall *QueueDeviceRequestResponse )( 
            ISoftUSBEndpoint * This,
            /* [in] */ __RPC__in USBSETUPREQUEST *pRequest,
            /* [in] */ RequestMatchOpts MatchOpt,
            /* [in] */ __RPC__in BYTE *pbResponseData,
            /* [in] */ ULONG cbResponseData,
            /* [in] */ BYTE FinalRequestStatus,
            /* [in] */ ULONG ulTimeToLive);
        
        /* [helpstringcontext][helpcontext][helpstring][id] */ HRESULT ( __stdcall *PurgeINQueue )( 
            ISoftUSBEndpoint * This);
        
        /* [helpstringcontext][helpcontext][helpstring][id] */ HRESULT ( __stdcall *PurgeOUTQueue )( 
            ISoftUSBEndpoint * This);
        
        /* [helpstringcontext][helpcontext][helpstring][id] */ HRESULT ( __stdcall *PurgeOUTQueueOlderThan )( 
            ISoftUSBEndpoint * This,
            /* [in] */ ULONG ulOlderThan);
        
        END_INTERFACE
    } ISoftUSBEndpointVtbl;

    interface ISoftUSBEndpoint
    {
        CONST_VTBL struct ISoftUSBEndpointVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISoftUSBEndpoint_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ISoftUSBEndpoint_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ISoftUSBEndpoint_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ISoftUSBEndpoint_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ISoftUSBEndpoint_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ISoftUSBEndpoint_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ISoftUSBEndpoint_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ISoftUSBEndpoint_get_Length(This,pbLength)	\
    ( (This)->lpVtbl -> get_Length(This,pbLength) ) 

#define ISoftUSBEndpoint_put_Length(This,bLength)	\
    ( (This)->lpVtbl -> put_Length(This,bLength) ) 

#define ISoftUSBEndpoint_get_DescriptorType(This,pbDescriptorType)	\
    ( (This)->lpVtbl -> get_DescriptorType(This,pbDescriptorType) ) 

#define ISoftUSBEndpoint_put_DescriptorType(This,bDescriptorType)	\
    ( (This)->lpVtbl -> put_DescriptorType(This,bDescriptorType) ) 

#define ISoftUSBEndpoint_get_EndpointAddress(This,pbAddress)	\
    ( (This)->lpVtbl -> get_EndpointAddress(This,pbAddress) ) 

#define ISoftUSBEndpoint_put_EndpointAddress(This,bAddress)	\
    ( (This)->lpVtbl -> put_EndpointAddress(This,bAddress) ) 

#define ISoftUSBEndpoint_get_Attributes(This,pbAttributes)	\
    ( (This)->lpVtbl -> get_Attributes(This,pbAttributes) ) 

#define ISoftUSBEndpoint_put_Attributes(This,bAttributes)	\
    ( (This)->lpVtbl -> put_Attributes(This,bAttributes) ) 

#define ISoftUSBEndpoint_get_MaxPacketSize(This,psMaxPacket)	\
    ( (This)->lpVtbl -> get_MaxPacketSize(This,psMaxPacket) ) 

#define ISoftUSBEndpoint_put_MaxPacketSize(This,sMaxPacketSize)	\
    ( (This)->lpVtbl -> put_MaxPacketSize(This,sMaxPacketSize) ) 

#define ISoftUSBEndpoint_get_Interval(This,pbInterval)	\
    ( (This)->lpVtbl -> get_Interval(This,pbInterval) ) 

#define ISoftUSBEndpoint_put_Interval(This,bInterval)	\
    ( (This)->lpVtbl -> put_Interval(This,bInterval) ) 

#define ISoftUSBEndpoint_get_Halted(This,pHalted)	\
    ( (This)->lpVtbl -> get_Halted(This,pHalted) ) 

#define ISoftUSBEndpoint_put_Halted(This,Halted)	\
    ( (This)->lpVtbl -> put_Halted(This,Halted) ) 

#define ISoftUSBEndpoint_get_MarshalEvents(This,pMarshalEvents)	\
    ( (This)->lpVtbl -> get_MarshalEvents(This,pMarshalEvents) ) 

#define ISoftUSBEndpoint_put_MarshalEvents(This,MarshalEvents)	\
    ( (This)->lpVtbl -> put_MarshalEvents(This,MarshalEvents) ) 

#define ISoftUSBEndpoint_get_OutQueueSize(This,plOutQueueSize)	\
    ( (This)->lpVtbl -> get_OutQueueSize(This,plOutQueueSize) ) 

#define ISoftUSBEndpoint_put_OutQueueSize(This,lOutQueueSize)	\
    ( (This)->lpVtbl -> put_OutQueueSize(This,lOutQueueSize) ) 

#define ISoftUSBEndpoint_get_LoopbackEndpoint(This,ppiSoftUSBEndpoint)	\
    ( (This)->lpVtbl -> get_LoopbackEndpoint(This,ppiSoftUSBEndpoint) ) 

#define ISoftUSBEndpoint_put_LoopbackEndpoint(This,piSoftUSBEndpoint)	\
    ( (This)->lpVtbl -> put_LoopbackEndpoint(This,piSoftUSBEndpoint) ) 

#define ISoftUSBEndpoint_putref_LoopbackEndpoint(This,piSoftUSBEndpoint)	\
    ( (This)->lpVtbl -> putref_LoopbackEndpoint(This,piSoftUSBEndpoint) ) 

#define ISoftUSBEndpoint_get_HandleStdDeviceRequests(This,pHandleStdRequests)	\
    ( (This)->lpVtbl -> get_HandleStdDeviceRequests(This,pHandleStdRequests) ) 

#define ISoftUSBEndpoint_put_HandleStdDeviceRequests(This,HandleStdRequests)	\
    ( (This)->lpVtbl -> put_HandleStdDeviceRequests(This,HandleStdRequests) ) 

#define ISoftUSBEndpoint_get_DeviceSpecificDescriptor(This,ppsaDevSpecData)	\
    ( (This)->lpVtbl -> get_DeviceSpecificDescriptor(This,ppsaDevSpecData) ) 

#define ISoftUSBEndpoint_put_DeviceSpecificDescriptor(This,psaDevSpecData)	\
    ( (This)->lpVtbl -> put_DeviceSpecificDescriptor(This,psaDevSpecData) ) 

#define ISoftUSBEndpoint_get_Context(This,ppContext)	\
    ( (This)->lpVtbl -> get_Context(This,ppContext) ) 

#define ISoftUSBEndpoint_QueueINData(This,pbDataBuffer,cbDataBuffer,bStatus,ulTimeToLive)	\
    ( (This)->lpVtbl -> QueueINData(This,pbDataBuffer,cbDataBuffer,bStatus,ulTimeToLive) ) 

#define ISoftUSBEndpoint_DrainOUTQueue(This,cMaxTransfers,pcTransfersRemaining,ppTransfers)	\
    ( (This)->lpVtbl -> DrainOUTQueue(This,cMaxTransfers,pcTransfersRemaining,ppTransfers) ) 

#define ISoftUSBEndpoint_FreeOUTQueue(This,pTransfers)	\
    ( (This)->lpVtbl -> FreeOUTQueue(This,pTransfers) ) 

#define ISoftUSBEndpoint_QueueDeviceRequestResponse(This,pRequest,MatchOpt,pbResponseData,cbResponseData,FinalRequestStatus,ulTimeToLive)	\
    ( (This)->lpVtbl -> QueueDeviceRequestResponse(This,pRequest,MatchOpt,pbResponseData,cbResponseData,FinalRequestStatus,ulTimeToLive) ) 

#define ISoftUSBEndpoint_PurgeINQueue(This)	\
    ( (This)->lpVtbl -> PurgeINQueue(This) ) 

#define ISoftUSBEndpoint_PurgeOUTQueue(This)	\
    ( (This)->lpVtbl -> PurgeOUTQueue(This) ) 

#define ISoftUSBEndpoint_PurgeOUTQueueOlderThan(This,ulOlderThan)	\
    ( (This)->lpVtbl -> PurgeOUTQueueOlderThan(This,ulOlderThan) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ISoftUSBEndpoint_INTERFACE_DEFINED__ */


#ifndef __ISoftUSBDeviceQualifier_INTERFACE_DEFINED__
#define __ISoftUSBDeviceQualifier_INTERFACE_DEFINED__

/* interface ISoftUSBDeviceQualifier */
/* [helpstringcontext][helpcontext][helpstring][object][hidden][nonextensible][oleautomation][dual][uuid] */ 


EXTERN_C const IID IID_ISoftUSBDeviceQualifier;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("a445e2cb-401f-4ac7-850f-579185d65140")
    ISoftUSBDeviceQualifier : public IDispatch
    {
    public:
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_Length( 
            /* [retval][out] */ __RPC__out BYTE *pbLength) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT __stdcall put_Length( 
            /* [in] */ BYTE bLength) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_DescriptorType( 
            /* [retval][out] */ __RPC__out BYTE *pbDescriptorType) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT __stdcall put_DescriptorType( 
            /* [in] */ BYTE bDescriptorType) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_USB( 
            /* [retval][out] */ __RPC__out SHORT *psUSB) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT __stdcall put_USB( 
            /* [in] */ SHORT sUSB) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_DeviceClass( 
            /* [retval][out] */ __RPC__out BYTE *pbDeviceClass) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT __stdcall put_DeviceClass( 
            /* [in] */ BYTE bDeviceClass) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_DeviceSubClass( 
            /* [retval][out] */ __RPC__out BYTE *pbDeviceSubClass) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT __stdcall put_DeviceSubClass( 
            /* [in] */ BYTE bDeviceSubClass) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_DeviceProtocol( 
            /* [retval][out] */ __RPC__out BYTE *pbProtocol) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT __stdcall put_DeviceProtocol( 
            /* [in] */ BYTE bProtocol) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_MaxPacketSize0( 
            /* [retval][out] */ __RPC__out BYTE *pbMaxPacket) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT __stdcall put_MaxPacketSize0( 
            /* [in] */ BYTE bMaxPacket) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_NumConfigurations( 
            /* [retval][out] */ __RPC__out BYTE *pbNumConfigs) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT __stdcall put_NumConfigurations( 
            /* [in] */ BYTE bNumConfigs) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_Reserved( 
            /* [retval][out] */ __RPC__out BYTE *pbReserved) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT __stdcall put_Reserved( 
            /* [in] */ BYTE bReserved) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISoftUSBDeviceQualifierVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISoftUSBDeviceQualifier * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISoftUSBDeviceQualifier * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISoftUSBDeviceQualifier * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ISoftUSBDeviceQualifier * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ISoftUSBDeviceQualifier * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ISoftUSBDeviceQualifier * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ISoftUSBDeviceQualifier * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_Length )( 
            ISoftUSBDeviceQualifier * This,
            /* [retval][out] */ __RPC__out BYTE *pbLength);
        
        /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT ( __stdcall *put_Length )( 
            ISoftUSBDeviceQualifier * This,
            /* [in] */ BYTE bLength);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_DescriptorType )( 
            ISoftUSBDeviceQualifier * This,
            /* [retval][out] */ __RPC__out BYTE *pbDescriptorType);
        
        /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT ( __stdcall *put_DescriptorType )( 
            ISoftUSBDeviceQualifier * This,
            /* [in] */ BYTE bDescriptorType);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_USB )( 
            ISoftUSBDeviceQualifier * This,
            /* [retval][out] */ __RPC__out SHORT *psUSB);
        
        /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT ( __stdcall *put_USB )( 
            ISoftUSBDeviceQualifier * This,
            /* [in] */ SHORT sUSB);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_DeviceClass )( 
            ISoftUSBDeviceQualifier * This,
            /* [retval][out] */ __RPC__out BYTE *pbDeviceClass);
        
        /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT ( __stdcall *put_DeviceClass )( 
            ISoftUSBDeviceQualifier * This,
            /* [in] */ BYTE bDeviceClass);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_DeviceSubClass )( 
            ISoftUSBDeviceQualifier * This,
            /* [retval][out] */ __RPC__out BYTE *pbDeviceSubClass);
        
        /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT ( __stdcall *put_DeviceSubClass )( 
            ISoftUSBDeviceQualifier * This,
            /* [in] */ BYTE bDeviceSubClass);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_DeviceProtocol )( 
            ISoftUSBDeviceQualifier * This,
            /* [retval][out] */ __RPC__out BYTE *pbProtocol);
        
        /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT ( __stdcall *put_DeviceProtocol )( 
            ISoftUSBDeviceQualifier * This,
            /* [in] */ BYTE bProtocol);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_MaxPacketSize0 )( 
            ISoftUSBDeviceQualifier * This,
            /* [retval][out] */ __RPC__out BYTE *pbMaxPacket);
        
        /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT ( __stdcall *put_MaxPacketSize0 )( 
            ISoftUSBDeviceQualifier * This,
            /* [in] */ BYTE bMaxPacket);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_NumConfigurations )( 
            ISoftUSBDeviceQualifier * This,
            /* [retval][out] */ __RPC__out BYTE *pbNumConfigs);
        
        /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT ( __stdcall *put_NumConfigurations )( 
            ISoftUSBDeviceQualifier * This,
            /* [in] */ BYTE bNumConfigs);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_Reserved )( 
            ISoftUSBDeviceQualifier * This,
            /* [retval][out] */ __RPC__out BYTE *pbReserved);
        
        /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT ( __stdcall *put_Reserved )( 
            ISoftUSBDeviceQualifier * This,
            /* [in] */ BYTE bReserved);
        
        END_INTERFACE
    } ISoftUSBDeviceQualifierVtbl;

    interface ISoftUSBDeviceQualifier
    {
        CONST_VTBL struct ISoftUSBDeviceQualifierVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISoftUSBDeviceQualifier_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ISoftUSBDeviceQualifier_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ISoftUSBDeviceQualifier_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ISoftUSBDeviceQualifier_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ISoftUSBDeviceQualifier_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ISoftUSBDeviceQualifier_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ISoftUSBDeviceQualifier_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ISoftUSBDeviceQualifier_get_Length(This,pbLength)	\
    ( (This)->lpVtbl -> get_Length(This,pbLength) ) 

#define ISoftUSBDeviceQualifier_put_Length(This,bLength)	\
    ( (This)->lpVtbl -> put_Length(This,bLength) ) 

#define ISoftUSBDeviceQualifier_get_DescriptorType(This,pbDescriptorType)	\
    ( (This)->lpVtbl -> get_DescriptorType(This,pbDescriptorType) ) 

#define ISoftUSBDeviceQualifier_put_DescriptorType(This,bDescriptorType)	\
    ( (This)->lpVtbl -> put_DescriptorType(This,bDescriptorType) ) 

#define ISoftUSBDeviceQualifier_get_USB(This,psUSB)	\
    ( (This)->lpVtbl -> get_USB(This,psUSB) ) 

#define ISoftUSBDeviceQualifier_put_USB(This,sUSB)	\
    ( (This)->lpVtbl -> put_USB(This,sUSB) ) 

#define ISoftUSBDeviceQualifier_get_DeviceClass(This,pbDeviceClass)	\
    ( (This)->lpVtbl -> get_DeviceClass(This,pbDeviceClass) ) 

#define ISoftUSBDeviceQualifier_put_DeviceClass(This,bDeviceClass)	\
    ( (This)->lpVtbl -> put_DeviceClass(This,bDeviceClass) ) 

#define ISoftUSBDeviceQualifier_get_DeviceSubClass(This,pbDeviceSubClass)	\
    ( (This)->lpVtbl -> get_DeviceSubClass(This,pbDeviceSubClass) ) 

#define ISoftUSBDeviceQualifier_put_DeviceSubClass(This,bDeviceSubClass)	\
    ( (This)->lpVtbl -> put_DeviceSubClass(This,bDeviceSubClass) ) 

#define ISoftUSBDeviceQualifier_get_DeviceProtocol(This,pbProtocol)	\
    ( (This)->lpVtbl -> get_DeviceProtocol(This,pbProtocol) ) 

#define ISoftUSBDeviceQualifier_put_DeviceProtocol(This,bProtocol)	\
    ( (This)->lpVtbl -> put_DeviceProtocol(This,bProtocol) ) 

#define ISoftUSBDeviceQualifier_get_MaxPacketSize0(This,pbMaxPacket)	\
    ( (This)->lpVtbl -> get_MaxPacketSize0(This,pbMaxPacket) ) 

#define ISoftUSBDeviceQualifier_put_MaxPacketSize0(This,bMaxPacket)	\
    ( (This)->lpVtbl -> put_MaxPacketSize0(This,bMaxPacket) ) 

#define ISoftUSBDeviceQualifier_get_NumConfigurations(This,pbNumConfigs)	\
    ( (This)->lpVtbl -> get_NumConfigurations(This,pbNumConfigs) ) 

#define ISoftUSBDeviceQualifier_put_NumConfigurations(This,bNumConfigs)	\
    ( (This)->lpVtbl -> put_NumConfigurations(This,bNumConfigs) ) 

#define ISoftUSBDeviceQualifier_get_Reserved(This,pbReserved)	\
    ( (This)->lpVtbl -> get_Reserved(This,pbReserved) ) 

#define ISoftUSBDeviceQualifier_put_Reserved(This,bReserved)	\
    ( (This)->lpVtbl -> put_Reserved(This,bReserved) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ISoftUSBDeviceQualifier_INTERFACE_DEFINED__ */


#ifndef __ISoftUSBEndpointEvents_INTERFACE_DEFINED__
#define __ISoftUSBEndpointEvents_INTERFACE_DEFINED__

/* interface ISoftUSBEndpointEvents */
/* [helpstringcontext][helpcontext][helpstring][object][nonextensible][uuid] */ 


EXTERN_C const IID IID_ISoftUSBEndpointEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("E6000897-6A14-4C06-A950-D069B8667091")
    ISoftUSBEndpointEvents : public IUnknown
    {
    public:
        virtual /* [helpstringcontext][helpcontext][helpstring][id] */ HRESULT __stdcall OnSetupTransfer( 
            /* [in] */ BYTE DataToggle,
            /* [in] */ __RPC__in BYTE *pbDataBuffer,
            /* [in] */ ULONG cbDataBuffer,
            /* [out] */ __RPC__out BYTE *pbStatus) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][id] */ HRESULT __stdcall OnWriteTransfer( 
            /* [in] */ BYTE DataToggle,
            /* [in] */ __RPC__in BYTE *pbDataBuffer,
            /* [in] */ ULONG cbDataBuffer,
            /* [out] */ __RPC__out BYTE *pbStatus) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][id] */ HRESULT __stdcall OnReadTransfer( 
            /* [in] */ BYTE DataToggle,
            /* [out] */ __RPC__out BYTE *pbDataBuffer,
            /* [in] */ ULONG cbDataBuffer,
            /* [out] */ __RPC__out ULONG *cbDataWritten,
            /* [out] */ __RPC__out BYTE *pbStatus) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][id] */ HRESULT __stdcall OnDeviceRequest( 
            /* [in] */ __RPC__in USBSETUPREQUEST *pSetupRequest,
            /* [out] */ __RPC__out ULONG *RequestHandle,
            /* [in] */ __RPC__in BYTE *pbRequestData,
            /* [in] */ ULONG cbRequestData,
            /* [out] */ __RPC__deref_out_opt BYTE **ppbResponseData,
            /* [out] */ __RPC__out ULONG *pcbResponseData,
            /* [out] */ __RPC__out BYTE *pbSetupStatus) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][id] */ HRESULT __stdcall OnDeviceRequestComplete( 
            /* [in] */ ULONG RequestHandle,
            /* [out] */ __RPC__out BYTE *pbFinalRequestStatus) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISoftUSBEndpointEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISoftUSBEndpointEvents * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISoftUSBEndpointEvents * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISoftUSBEndpointEvents * This);
        
        /* [helpstringcontext][helpcontext][helpstring][id] */ HRESULT ( __stdcall *OnSetupTransfer )( 
            ISoftUSBEndpointEvents * This,
            /* [in] */ BYTE DataToggle,
            /* [in] */ __RPC__in BYTE *pbDataBuffer,
            /* [in] */ ULONG cbDataBuffer,
            /* [out] */ __RPC__out BYTE *pbStatus);
        
        /* [helpstringcontext][helpcontext][helpstring][id] */ HRESULT ( __stdcall *OnWriteTransfer )( 
            ISoftUSBEndpointEvents * This,
            /* [in] */ BYTE DataToggle,
            /* [in] */ __RPC__in BYTE *pbDataBuffer,
            /* [in] */ ULONG cbDataBuffer,
            /* [out] */ __RPC__out BYTE *pbStatus);
        
        /* [helpstringcontext][helpcontext][helpstring][id] */ HRESULT ( __stdcall *OnReadTransfer )( 
            ISoftUSBEndpointEvents * This,
            /* [in] */ BYTE DataToggle,
            /* [out] */ __RPC__out BYTE *pbDataBuffer,
            /* [in] */ ULONG cbDataBuffer,
            /* [out] */ __RPC__out ULONG *cbDataWritten,
            /* [out] */ __RPC__out BYTE *pbStatus);
        
        /* [helpstringcontext][helpcontext][helpstring][id] */ HRESULT ( __stdcall *OnDeviceRequest )( 
            ISoftUSBEndpointEvents * This,
            /* [in] */ __RPC__in USBSETUPREQUEST *pSetupRequest,
            /* [out] */ __RPC__out ULONG *RequestHandle,
            /* [in] */ __RPC__in BYTE *pbRequestData,
            /* [in] */ ULONG cbRequestData,
            /* [out] */ __RPC__deref_out_opt BYTE **ppbResponseData,
            /* [out] */ __RPC__out ULONG *pcbResponseData,
            /* [out] */ __RPC__out BYTE *pbSetupStatus);
        
        /* [helpstringcontext][helpcontext][helpstring][id] */ HRESULT ( __stdcall *OnDeviceRequestComplete )( 
            ISoftUSBEndpointEvents * This,
            /* [in] */ ULONG RequestHandle,
            /* [out] */ __RPC__out BYTE *pbFinalRequestStatus);
        
        END_INTERFACE
    } ISoftUSBEndpointEventsVtbl;

    interface ISoftUSBEndpointEvents
    {
        CONST_VTBL struct ISoftUSBEndpointEventsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISoftUSBEndpointEvents_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ISoftUSBEndpointEvents_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ISoftUSBEndpointEvents_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ISoftUSBEndpointEvents_OnSetupTransfer(This,DataToggle,pbDataBuffer,cbDataBuffer,pbStatus)	\
    ( (This)->lpVtbl -> OnSetupTransfer(This,DataToggle,pbDataBuffer,cbDataBuffer,pbStatus) ) 

#define ISoftUSBEndpointEvents_OnWriteTransfer(This,DataToggle,pbDataBuffer,cbDataBuffer,pbStatus)	\
    ( (This)->lpVtbl -> OnWriteTransfer(This,DataToggle,pbDataBuffer,cbDataBuffer,pbStatus) ) 

#define ISoftUSBEndpointEvents_OnReadTransfer(This,DataToggle,pbDataBuffer,cbDataBuffer,cbDataWritten,pbStatus)	\
    ( (This)->lpVtbl -> OnReadTransfer(This,DataToggle,pbDataBuffer,cbDataBuffer,cbDataWritten,pbStatus) ) 

#define ISoftUSBEndpointEvents_OnDeviceRequest(This,pSetupRequest,RequestHandle,pbRequestData,cbRequestData,ppbResponseData,pcbResponseData,pbSetupStatus)	\
    ( (This)->lpVtbl -> OnDeviceRequest(This,pSetupRequest,RequestHandle,pbRequestData,cbRequestData,ppbResponseData,pcbResponseData,pbSetupStatus) ) 

#define ISoftUSBEndpointEvents_OnDeviceRequestComplete(This,RequestHandle,pbFinalRequestStatus)	\
    ( (This)->lpVtbl -> OnDeviceRequestComplete(This,RequestHandle,pbFinalRequestStatus) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ISoftUSBEndpointEvents_INTERFACE_DEFINED__ */


#ifndef __ISoftUSBStrings_INTERFACE_DEFINED__
#define __ISoftUSBStrings_INTERFACE_DEFINED__

/* interface ISoftUSBStrings */
/* [helpstringcontext][helpcontext][helpstring][object][hidden][nonextensible][oleautomation][dual][uuid] */ 


EXTERN_C const IID IID_ISoftUSBStrings;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("B8714568-8ED3-4FE9-ADED-82EAA467956A")
    ISoftUSBStrings : public IDispatch
    {
    public:
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_Count( 
            /* [retval][out] */ __RPC__out long *plCount) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_Item( 
            /* [in] */ VARIANT Index,
            /* [retval][out] */ __RPC__deref_out_opt SoftUSBString	**ppSOFTUSBString) = 0;
        
        virtual /* [hidden][propget][id] */ HRESULT __stdcall get__NewEnum( 
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **ppunkEnum) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][id] */ HRESULT __stdcall Add( 
            /* [in] */ __RPC__in SoftUSBString	*pSOFTUSBString,
            /* [optional][in] */ VARIANT Index) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][id] */ HRESULT __stdcall Remove( 
            /* [in] */ VARIANT Index) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][id] */ HRESULT __stdcall Clear( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISoftUSBStringsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISoftUSBStrings * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISoftUSBStrings * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISoftUSBStrings * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ISoftUSBStrings * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ISoftUSBStrings * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ISoftUSBStrings * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ISoftUSBStrings * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_Count )( 
            ISoftUSBStrings * This,
            /* [retval][out] */ __RPC__out long *plCount);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_Item )( 
            ISoftUSBStrings * This,
            /* [in] */ VARIANT Index,
            /* [retval][out] */ __RPC__deref_out_opt SoftUSBString	**ppSOFTUSBString);
        
        /* [hidden][propget][id] */ HRESULT ( __stdcall *get__NewEnum )( 
            ISoftUSBStrings * This,
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **ppunkEnum);
        
        /* [helpstringcontext][helpcontext][helpstring][id] */ HRESULT ( __stdcall *Add )( 
            ISoftUSBStrings * This,
            /* [in] */ __RPC__in SoftUSBString	*pSOFTUSBString,
            /* [optional][in] */ VARIANT Index);
        
        /* [helpstringcontext][helpcontext][helpstring][id] */ HRESULT ( __stdcall *Remove )( 
            ISoftUSBStrings * This,
            /* [in] */ VARIANT Index);
        
        /* [helpstringcontext][helpcontext][helpstring][id] */ HRESULT ( __stdcall *Clear )( 
            ISoftUSBStrings * This);
        
        END_INTERFACE
    } ISoftUSBStringsVtbl;

    interface ISoftUSBStrings
    {
        CONST_VTBL struct ISoftUSBStringsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISoftUSBStrings_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ISoftUSBStrings_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ISoftUSBStrings_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ISoftUSBStrings_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ISoftUSBStrings_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ISoftUSBStrings_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ISoftUSBStrings_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ISoftUSBStrings_get_Count(This,plCount)	\
    ( (This)->lpVtbl -> get_Count(This,plCount) ) 

#define ISoftUSBStrings_get_Item(This,Index,ppSOFTUSBString)	\
    ( (This)->lpVtbl -> get_Item(This,Index,ppSOFTUSBString) ) 

#define ISoftUSBStrings_get__NewEnum(This,ppunkEnum)	\
    ( (This)->lpVtbl -> get__NewEnum(This,ppunkEnum) ) 

#define ISoftUSBStrings_Add(This,pSOFTUSBString,Index)	\
    ( (This)->lpVtbl -> Add(This,pSOFTUSBString,Index) ) 

#define ISoftUSBStrings_Remove(This,Index)	\
    ( (This)->lpVtbl -> Remove(This,Index) ) 

#define ISoftUSBStrings_Clear(This)	\
    ( (This)->lpVtbl -> Clear(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ISoftUSBStrings_INTERFACE_DEFINED__ */


#ifndef __ISoftUSBInterfaces_INTERFACE_DEFINED__
#define __ISoftUSBInterfaces_INTERFACE_DEFINED__

/* interface ISoftUSBInterfaces */
/* [helpstringcontext][helpcontext][helpstring][object][hidden][nonextensible][oleautomation][dual][uuid] */ 


EXTERN_C const IID IID_ISoftUSBInterfaces;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("450274FA-92A8-4FB1-A447-2CD3A45465A8")
    ISoftUSBInterfaces : public IDispatch
    {
    public:
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_Count( 
            /* [retval][out] */ __RPC__out long *plCount) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_Item( 
            /* [in] */ VARIANT Index,
            /* [retval][out] */ __RPC__deref_out_opt SoftUSBInterface	**ppSOFTUSBInterface) = 0;
        
        virtual /* [hidden][propget][id] */ HRESULT __stdcall get__NewEnum( 
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **ppunkEnum) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][id] */ HRESULT __stdcall Add( 
            /* [in] */ __RPC__in SoftUSBInterface	*ppSOFTUSBInterface,
            /* [optional][in] */ VARIANT Index) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][id] */ HRESULT __stdcall Remove( 
            /* [in] */ VARIANT Index) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][id] */ HRESULT __stdcall Clear( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISoftUSBInterfacesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISoftUSBInterfaces * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISoftUSBInterfaces * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISoftUSBInterfaces * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ISoftUSBInterfaces * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ISoftUSBInterfaces * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ISoftUSBInterfaces * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ISoftUSBInterfaces * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_Count )( 
            ISoftUSBInterfaces * This,
            /* [retval][out] */ __RPC__out long *plCount);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_Item )( 
            ISoftUSBInterfaces * This,
            /* [in] */ VARIANT Index,
            /* [retval][out] */ __RPC__deref_out_opt SoftUSBInterface	**ppSOFTUSBInterface);
        
        /* [hidden][propget][id] */ HRESULT ( __stdcall *get__NewEnum )( 
            ISoftUSBInterfaces * This,
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **ppunkEnum);
        
        /* [helpstringcontext][helpcontext][helpstring][id] */ HRESULT ( __stdcall *Add )( 
            ISoftUSBInterfaces * This,
            /* [in] */ __RPC__in SoftUSBInterface	*ppSOFTUSBInterface,
            /* [optional][in] */ VARIANT Index);
        
        /* [helpstringcontext][helpcontext][helpstring][id] */ HRESULT ( __stdcall *Remove )( 
            ISoftUSBInterfaces * This,
            /* [in] */ VARIANT Index);
        
        /* [helpstringcontext][helpcontext][helpstring][id] */ HRESULT ( __stdcall *Clear )( 
            ISoftUSBInterfaces * This);
        
        END_INTERFACE
    } ISoftUSBInterfacesVtbl;

    interface ISoftUSBInterfaces
    {
        CONST_VTBL struct ISoftUSBInterfacesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISoftUSBInterfaces_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ISoftUSBInterfaces_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ISoftUSBInterfaces_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ISoftUSBInterfaces_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ISoftUSBInterfaces_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ISoftUSBInterfaces_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ISoftUSBInterfaces_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ISoftUSBInterfaces_get_Count(This,plCount)	\
    ( (This)->lpVtbl -> get_Count(This,plCount) ) 

#define ISoftUSBInterfaces_get_Item(This,Index,ppSOFTUSBInterface)	\
    ( (This)->lpVtbl -> get_Item(This,Index,ppSOFTUSBInterface) ) 

#define ISoftUSBInterfaces_get__NewEnum(This,ppunkEnum)	\
    ( (This)->lpVtbl -> get__NewEnum(This,ppunkEnum) ) 

#define ISoftUSBInterfaces_Add(This,ppSOFTUSBInterface,Index)	\
    ( (This)->lpVtbl -> Add(This,ppSOFTUSBInterface,Index) ) 

#define ISoftUSBInterfaces_Remove(This,Index)	\
    ( (This)->lpVtbl -> Remove(This,Index) ) 

#define ISoftUSBInterfaces_Clear(This)	\
    ( (This)->lpVtbl -> Clear(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ISoftUSBInterfaces_INTERFACE_DEFINED__ */


#ifndef __ISoftUSBEndpoints_INTERFACE_DEFINED__
#define __ISoftUSBEndpoints_INTERFACE_DEFINED__

/* interface ISoftUSBEndpoints */
/* [helpstringcontext][helpcontext][helpstring][object][hidden][nonextensible][oleautomation][dual][uuid] */ 


EXTERN_C const IID IID_ISoftUSBEndpoints;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("797C784C-C45E-4DDD-9F21-5CBE273FA778")
    ISoftUSBEndpoints : public IDispatch
    {
    public:
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_Count( 
            /* [retval][out] */ __RPC__out long *plCount) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_Item( 
            /* [in] */ VARIANT Index,
            /* [retval][out] */ __RPC__deref_out_opt SoftUSBEndpoint	**ppSOFTUSBEndpoint) = 0;
        
        virtual /* [hidden][propget][id] */ HRESULT __stdcall get__NewEnum( 
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **ppunkEnum) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][id] */ HRESULT __stdcall Add( 
            /* [in] */ __RPC__in SoftUSBEndpoint	*ppSOFTUSBEndpoint,
            /* [optional][in] */ VARIANT Index) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][id] */ HRESULT __stdcall Remove( 
            /* [in] */ VARIANT Index) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][id] */ HRESULT __stdcall Clear( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISoftUSBEndpointsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISoftUSBEndpoints * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISoftUSBEndpoints * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISoftUSBEndpoints * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ISoftUSBEndpoints * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ISoftUSBEndpoints * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ISoftUSBEndpoints * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ISoftUSBEndpoints * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_Count )( 
            ISoftUSBEndpoints * This,
            /* [retval][out] */ __RPC__out long *plCount);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_Item )( 
            ISoftUSBEndpoints * This,
            /* [in] */ VARIANT Index,
            /* [retval][out] */ __RPC__deref_out_opt SoftUSBEndpoint	**ppSOFTUSBEndpoint);
        
        /* [hidden][propget][id] */ HRESULT ( __stdcall *get__NewEnum )( 
            ISoftUSBEndpoints * This,
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **ppunkEnum);
        
        /* [helpstringcontext][helpcontext][helpstring][id] */ HRESULT ( __stdcall *Add )( 
            ISoftUSBEndpoints * This,
            /* [in] */ __RPC__in SoftUSBEndpoint	*ppSOFTUSBEndpoint,
            /* [optional][in] */ VARIANT Index);
        
        /* [helpstringcontext][helpcontext][helpstring][id] */ HRESULT ( __stdcall *Remove )( 
            ISoftUSBEndpoints * This,
            /* [in] */ VARIANT Index);
        
        /* [helpstringcontext][helpcontext][helpstring][id] */ HRESULT ( __stdcall *Clear )( 
            ISoftUSBEndpoints * This);
        
        END_INTERFACE
    } ISoftUSBEndpointsVtbl;

    interface ISoftUSBEndpoints
    {
        CONST_VTBL struct ISoftUSBEndpointsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISoftUSBEndpoints_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ISoftUSBEndpoints_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ISoftUSBEndpoints_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ISoftUSBEndpoints_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ISoftUSBEndpoints_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ISoftUSBEndpoints_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ISoftUSBEndpoints_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ISoftUSBEndpoints_get_Count(This,plCount)	\
    ( (This)->lpVtbl -> get_Count(This,plCount) ) 

#define ISoftUSBEndpoints_get_Item(This,Index,ppSOFTUSBEndpoint)	\
    ( (This)->lpVtbl -> get_Item(This,Index,ppSOFTUSBEndpoint) ) 

#define ISoftUSBEndpoints_get__NewEnum(This,ppunkEnum)	\
    ( (This)->lpVtbl -> get__NewEnum(This,ppunkEnum) ) 

#define ISoftUSBEndpoints_Add(This,ppSOFTUSBEndpoint,Index)	\
    ( (This)->lpVtbl -> Add(This,ppSOFTUSBEndpoint,Index) ) 

#define ISoftUSBEndpoints_Remove(This,Index)	\
    ( (This)->lpVtbl -> Remove(This,Index) ) 

#define ISoftUSBEndpoints_Clear(This)	\
    ( (This)->lpVtbl -> Clear(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ISoftUSBEndpoints_INTERFACE_DEFINED__ */


#ifndef __ISoftUSBHub_INTERFACE_DEFINED__
#define __ISoftUSBHub_INTERFACE_DEFINED__

/* interface ISoftUSBHub */
/* [object][helpstringcontext][helpcontext][helpstring][hidden][nonextensible][oleautomation][dual][uuid] */ 


EXTERN_C const IID IID_ISoftUSBHub;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0442b742-2bd3-4b07-99d8-65b6395bcdb0")
    ISoftUSBHub : public IDispatch
    {
    public:
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_NbrPorts( 
            /* [retval][out] */ __RPC__out BYTE *pbPorts) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT __stdcall put_NbrPorts( 
            /* [in] */ BYTE bPorts) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_LogicalPowerSwitchingMode( 
            /* [retval][out] */ __RPC__out SoftUSBHubPowerSwitchingMode *pMode) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT __stdcall put_LogicalPowerSwitchingMode( 
            /* [in] */ SoftUSBHubPowerSwitchingMode Mode) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_CompoundDevice( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pfvarCompound) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT __stdcall put_CompoundDevice( 
            /* [in] */ VARIANT_BOOL fvarCompound) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_OverCurrentProtectMode( 
            /* [retval][out] */ __RPC__out SoftUSBHubOverCurrentProtectionMode *pMode) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT __stdcall put_OverCurrentProtectMode( 
            /* [in] */ SoftUSBHubOverCurrentProtectionMode Mode) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_TTThinkTime( 
            /* [retval][out] */ __RPC__out BYTE *pbThinkTime) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT __stdcall put_TTThinkTime( 
            /* [in] */ BYTE bThinkTime) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_PortIndicatorsSupported( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pfvarSupported) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT __stdcall put_PortIndicatorsSupported( 
            /* [in] */ VARIANT_BOOL fvarSupported) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_PwrOn2PwrGood( 
            /* [retval][out] */ __RPC__out BYTE *pbTime2PwrGood) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT __stdcall put_PwrOn2PwrGood( 
            /* [in] */ BYTE bTime2PwrGood) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_ContrCurrent( 
            /* [retval][out] */ __RPC__out BYTE *pbContrCurrent) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT __stdcall put_ContrCurrent( 
            /* [in] */ BYTE bContrCurrent) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_LocalPowerSourceChange( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pfvarChange) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT __stdcall put_LocalPowerSourceChange( 
            /* [in] */ VARIANT_BOOL fvarChange) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_OverCurrent( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pfvarOverCurrent) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT __stdcall put_OverCurrent( 
            /* [in] */ VARIANT_BOOL fvarOverCurrent) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_OverCurrentChange( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pfvarOverCurrentChange) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT __stdcall put_OverCurrentChange( 
            /* [in] */ VARIANT_BOOL fvarOverCurrentChange) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_Status( 
            /* [retval][out] */ __RPC__out long *plStatus) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_RootHubPortNumber( 
            /* [retval][out] */ __RPC__out BYTE *pbPort) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_SoftUSBDevice( 
            /* [retval][out] */ __RPC__deref_out_opt SoftUSBDevice	**ppSoftUSBDevice) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_Ports( 
            /* [retval][out] */ __RPC__deref_out_opt SoftUSBHubPorts	**ppPorts) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][id] */ HRESULT __stdcall Destroy( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISoftUSBHubVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISoftUSBHub * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISoftUSBHub * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISoftUSBHub * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ISoftUSBHub * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ISoftUSBHub * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ISoftUSBHub * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ISoftUSBHub * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_NbrPorts )( 
            ISoftUSBHub * This,
            /* [retval][out] */ __RPC__out BYTE *pbPorts);
        
        /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT ( __stdcall *put_NbrPorts )( 
            ISoftUSBHub * This,
            /* [in] */ BYTE bPorts);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_LogicalPowerSwitchingMode )( 
            ISoftUSBHub * This,
            /* [retval][out] */ __RPC__out SoftUSBHubPowerSwitchingMode *pMode);
        
        /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT ( __stdcall *put_LogicalPowerSwitchingMode )( 
            ISoftUSBHub * This,
            /* [in] */ SoftUSBHubPowerSwitchingMode Mode);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_CompoundDevice )( 
            ISoftUSBHub * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pfvarCompound);
        
        /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT ( __stdcall *put_CompoundDevice )( 
            ISoftUSBHub * This,
            /* [in] */ VARIANT_BOOL fvarCompound);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_OverCurrentProtectMode )( 
            ISoftUSBHub * This,
            /* [retval][out] */ __RPC__out SoftUSBHubOverCurrentProtectionMode *pMode);
        
        /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT ( __stdcall *put_OverCurrentProtectMode )( 
            ISoftUSBHub * This,
            /* [in] */ SoftUSBHubOverCurrentProtectionMode Mode);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_TTThinkTime )( 
            ISoftUSBHub * This,
            /* [retval][out] */ __RPC__out BYTE *pbThinkTime);
        
        /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT ( __stdcall *put_TTThinkTime )( 
            ISoftUSBHub * This,
            /* [in] */ BYTE bThinkTime);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_PortIndicatorsSupported )( 
            ISoftUSBHub * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pfvarSupported);
        
        /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT ( __stdcall *put_PortIndicatorsSupported )( 
            ISoftUSBHub * This,
            /* [in] */ VARIANT_BOOL fvarSupported);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_PwrOn2PwrGood )( 
            ISoftUSBHub * This,
            /* [retval][out] */ __RPC__out BYTE *pbTime2PwrGood);
        
        /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT ( __stdcall *put_PwrOn2PwrGood )( 
            ISoftUSBHub * This,
            /* [in] */ BYTE bTime2PwrGood);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_ContrCurrent )( 
            ISoftUSBHub * This,
            /* [retval][out] */ __RPC__out BYTE *pbContrCurrent);
        
        /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT ( __stdcall *put_ContrCurrent )( 
            ISoftUSBHub * This,
            /* [in] */ BYTE bContrCurrent);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_LocalPowerSourceChange )( 
            ISoftUSBHub * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pfvarChange);
        
        /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT ( __stdcall *put_LocalPowerSourceChange )( 
            ISoftUSBHub * This,
            /* [in] */ VARIANT_BOOL fvarChange);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_OverCurrent )( 
            ISoftUSBHub * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pfvarOverCurrent);
        
        /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT ( __stdcall *put_OverCurrent )( 
            ISoftUSBHub * This,
            /* [in] */ VARIANT_BOOL fvarOverCurrent);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_OverCurrentChange )( 
            ISoftUSBHub * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pfvarOverCurrentChange);
        
        /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT ( __stdcall *put_OverCurrentChange )( 
            ISoftUSBHub * This,
            /* [in] */ VARIANT_BOOL fvarOverCurrentChange);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_Status )( 
            ISoftUSBHub * This,
            /* [retval][out] */ __RPC__out long *plStatus);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_RootHubPortNumber )( 
            ISoftUSBHub * This,
            /* [retval][out] */ __RPC__out BYTE *pbPort);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_SoftUSBDevice )( 
            ISoftUSBHub * This,
            /* [retval][out] */ __RPC__deref_out_opt SoftUSBDevice	**ppSoftUSBDevice);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_Ports )( 
            ISoftUSBHub * This,
            /* [retval][out] */ __RPC__deref_out_opt SoftUSBHubPorts	**ppPorts);
        
        /* [helpstringcontext][helpcontext][helpstring][id] */ HRESULT ( __stdcall *Destroy )( 
            ISoftUSBHub * This);
        
        END_INTERFACE
    } ISoftUSBHubVtbl;

    interface ISoftUSBHub
    {
        CONST_VTBL struct ISoftUSBHubVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISoftUSBHub_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ISoftUSBHub_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ISoftUSBHub_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ISoftUSBHub_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ISoftUSBHub_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ISoftUSBHub_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ISoftUSBHub_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ISoftUSBHub_get_NbrPorts(This,pbPorts)	\
    ( (This)->lpVtbl -> get_NbrPorts(This,pbPorts) ) 

#define ISoftUSBHub_put_NbrPorts(This,bPorts)	\
    ( (This)->lpVtbl -> put_NbrPorts(This,bPorts) ) 

#define ISoftUSBHub_get_LogicalPowerSwitchingMode(This,pMode)	\
    ( (This)->lpVtbl -> get_LogicalPowerSwitchingMode(This,pMode) ) 

#define ISoftUSBHub_put_LogicalPowerSwitchingMode(This,Mode)	\
    ( (This)->lpVtbl -> put_LogicalPowerSwitchingMode(This,Mode) ) 

#define ISoftUSBHub_get_CompoundDevice(This,pfvarCompound)	\
    ( (This)->lpVtbl -> get_CompoundDevice(This,pfvarCompound) ) 

#define ISoftUSBHub_put_CompoundDevice(This,fvarCompound)	\
    ( (This)->lpVtbl -> put_CompoundDevice(This,fvarCompound) ) 

#define ISoftUSBHub_get_OverCurrentProtectMode(This,pMode)	\
    ( (This)->lpVtbl -> get_OverCurrentProtectMode(This,pMode) ) 

#define ISoftUSBHub_put_OverCurrentProtectMode(This,Mode)	\
    ( (This)->lpVtbl -> put_OverCurrentProtectMode(This,Mode) ) 

#define ISoftUSBHub_get_TTThinkTime(This,pbThinkTime)	\
    ( (This)->lpVtbl -> get_TTThinkTime(This,pbThinkTime) ) 

#define ISoftUSBHub_put_TTThinkTime(This,bThinkTime)	\
    ( (This)->lpVtbl -> put_TTThinkTime(This,bThinkTime) ) 

#define ISoftUSBHub_get_PortIndicatorsSupported(This,pfvarSupported)	\
    ( (This)->lpVtbl -> get_PortIndicatorsSupported(This,pfvarSupported) ) 

#define ISoftUSBHub_put_PortIndicatorsSupported(This,fvarSupported)	\
    ( (This)->lpVtbl -> put_PortIndicatorsSupported(This,fvarSupported) ) 

#define ISoftUSBHub_get_PwrOn2PwrGood(This,pbTime2PwrGood)	\
    ( (This)->lpVtbl -> get_PwrOn2PwrGood(This,pbTime2PwrGood) ) 

#define ISoftUSBHub_put_PwrOn2PwrGood(This,bTime2PwrGood)	\
    ( (This)->lpVtbl -> put_PwrOn2PwrGood(This,bTime2PwrGood) ) 

#define ISoftUSBHub_get_ContrCurrent(This,pbContrCurrent)	\
    ( (This)->lpVtbl -> get_ContrCurrent(This,pbContrCurrent) ) 

#define ISoftUSBHub_put_ContrCurrent(This,bContrCurrent)	\
    ( (This)->lpVtbl -> put_ContrCurrent(This,bContrCurrent) ) 

#define ISoftUSBHub_get_LocalPowerSourceChange(This,pfvarChange)	\
    ( (This)->lpVtbl -> get_LocalPowerSourceChange(This,pfvarChange) ) 

#define ISoftUSBHub_put_LocalPowerSourceChange(This,fvarChange)	\
    ( (This)->lpVtbl -> put_LocalPowerSourceChange(This,fvarChange) ) 

#define ISoftUSBHub_get_OverCurrent(This,pfvarOverCurrent)	\
    ( (This)->lpVtbl -> get_OverCurrent(This,pfvarOverCurrent) ) 

#define ISoftUSBHub_put_OverCurrent(This,fvarOverCurrent)	\
    ( (This)->lpVtbl -> put_OverCurrent(This,fvarOverCurrent) ) 

#define ISoftUSBHub_get_OverCurrentChange(This,pfvarOverCurrentChange)	\
    ( (This)->lpVtbl -> get_OverCurrentChange(This,pfvarOverCurrentChange) ) 

#define ISoftUSBHub_put_OverCurrentChange(This,fvarOverCurrentChange)	\
    ( (This)->lpVtbl -> put_OverCurrentChange(This,fvarOverCurrentChange) ) 

#define ISoftUSBHub_get_Status(This,plStatus)	\
    ( (This)->lpVtbl -> get_Status(This,plStatus) ) 

#define ISoftUSBHub_get_RootHubPortNumber(This,pbPort)	\
    ( (This)->lpVtbl -> get_RootHubPortNumber(This,pbPort) ) 

#define ISoftUSBHub_get_SoftUSBDevice(This,ppSoftUSBDevice)	\
    ( (This)->lpVtbl -> get_SoftUSBDevice(This,ppSoftUSBDevice) ) 

#define ISoftUSBHub_get_Ports(This,ppPorts)	\
    ( (This)->lpVtbl -> get_Ports(This,ppPorts) ) 

#define ISoftUSBHub_Destroy(This)	\
    ( (This)->lpVtbl -> Destroy(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ISoftUSBHub_INTERFACE_DEFINED__ */


#ifndef __ISoftUSBHubPorts_INTERFACE_DEFINED__
#define __ISoftUSBHubPorts_INTERFACE_DEFINED__

/* interface ISoftUSBHubPorts */
/* [helpstringcontext][helpcontext][helpstring][object][hidden][nonextensible][oleautomation][dual][uuid] */ 


EXTERN_C const IID IID_ISoftUSBHubPorts;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("DBC9054B-5F42-459C-96EE-182073F8BD3E")
    ISoftUSBHubPorts : public IDispatch
    {
    public:
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_Count( 
            /* [retval][out] */ __RPC__out long *plCount) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_Item( 
            /* [in] */ VARIANT Index,
            /* [retval][out] */ __RPC__deref_out_opt SoftUSBHubPort	**ppSoftUSBHubPort) = 0;
        
        virtual /* [hidden][propget][id] */ HRESULT __stdcall get__NewEnum( 
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **ppunkEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISoftUSBHubPortsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISoftUSBHubPorts * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISoftUSBHubPorts * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISoftUSBHubPorts * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ISoftUSBHubPorts * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ISoftUSBHubPorts * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ISoftUSBHubPorts * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ISoftUSBHubPorts * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_Count )( 
            ISoftUSBHubPorts * This,
            /* [retval][out] */ __RPC__out long *plCount);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_Item )( 
            ISoftUSBHubPorts * This,
            /* [in] */ VARIANT Index,
            /* [retval][out] */ __RPC__deref_out_opt SoftUSBHubPort	**ppSoftUSBHubPort);
        
        /* [hidden][propget][id] */ HRESULT ( __stdcall *get__NewEnum )( 
            ISoftUSBHubPorts * This,
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **ppunkEnum);
        
        END_INTERFACE
    } ISoftUSBHubPortsVtbl;

    interface ISoftUSBHubPorts
    {
        CONST_VTBL struct ISoftUSBHubPortsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISoftUSBHubPorts_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ISoftUSBHubPorts_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ISoftUSBHubPorts_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ISoftUSBHubPorts_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ISoftUSBHubPorts_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ISoftUSBHubPorts_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ISoftUSBHubPorts_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ISoftUSBHubPorts_get_Count(This,plCount)	\
    ( (This)->lpVtbl -> get_Count(This,plCount) ) 

#define ISoftUSBHubPorts_get_Item(This,Index,ppSoftUSBHubPort)	\
    ( (This)->lpVtbl -> get_Item(This,Index,ppSoftUSBHubPort) ) 

#define ISoftUSBHubPorts_get__NewEnum(This,ppunkEnum)	\
    ( (This)->lpVtbl -> get__NewEnum(This,ppunkEnum) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ISoftUSBHubPorts_INTERFACE_DEFINED__ */


#ifndef __ISoftUSBHubPort_INTERFACE_DEFINED__
#define __ISoftUSBHubPort_INTERFACE_DEFINED__

/* interface ISoftUSBHubPort */
/* [helpstringcontext][helpcontext][helpstring][object][hidden][nonextensible][oleautomation][dual][uuid] */ 


EXTERN_C const IID IID_ISoftUSBHubPort;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("11AE2FF8-4F47-4A14-85CA-0D13AC9F4A5A")
    ISoftUSBHubPort : public IDispatch
    {
    public:
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_DeviceRemovable( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pfvarRemovable) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT __stdcall put_DeviceRemovable( 
            /* [in] */ VARIANT_BOOL fvarRemovable) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_PwrCtrl( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pfvarPwrCtrl) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT __stdcall put_PwrCtrl( 
            /* [in] */ VARIANT_BOOL fvarPwrCtrl) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_CurrentConnectStatus( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pfvarStatus) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_Enabled( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pfvarEnabled) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT __stdcall put_Enabled( 
            /* [in] */ VARIANT_BOOL fvarEnabled) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_Suspend( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pfvarSuspend) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT __stdcall put_Suspend( 
            /* [in] */ VARIANT_BOOL fvarSuspend) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_OverCurrent( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pfvarOverCurrent) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT __stdcall put_OverCurrent( 
            /* [in] */ VARIANT_BOOL fvarOverCurrent) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_Reset( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pfvarReset) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_Power( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pfvarPower) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_AttachedDeviceSpeed( 
            /* [retval][out] */ __RPC__out SoftUSBHubSpeed *pSpeed) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_TestMode( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pfvarTestMode) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_IndicatorControl( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pfvarIndicatorControl) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_Indicator( 
            /* [retval][out] */ __RPC__out SoftUSBHubIndicator *pIndicator) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_ConnectStatusChange( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pfvarConnectStatusChange) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT __stdcall put_ConnectStatusChange( 
            /* [in] */ VARIANT_BOOL fvarConnectStatusChange) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_EnableChange( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pfvarEnableChange) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT __stdcall put_EnableChange( 
            /* [in] */ VARIANT_BOOL fvarEnableChange) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_SuspendChange( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pfvarSuspendChange) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT __stdcall put_SuspendChange( 
            /* [in] */ VARIANT_BOOL fvarSuspendChange) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_OverCurrentChange( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pfvarOverCurrentChange) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT __stdcall put_OverCurrentChange( 
            /* [in] */ VARIANT_BOOL fvarOverCurrentChange) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_ResetChange( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pfvarResetChange) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT __stdcall put_ResetChange( 
            /* [in] */ VARIANT_BOOL fvarResetChange) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_Status( 
            /* [retval][out] */ __RPC__out long *plStatus) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_Device( 
            /* [retval][out] */ __RPC__deref_out_opt /* external definition not present */ DSFDevice **ppDSFDevice) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][id] */ HRESULT __stdcall HotPlug( 
            /* [in] */ __RPC__in /* external definition not present */ DSFDevice *pDSFDevice) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][id] */ HRESULT __stdcall Unplug( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISoftUSBHubPortVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISoftUSBHubPort * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISoftUSBHubPort * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISoftUSBHubPort * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ISoftUSBHubPort * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ISoftUSBHubPort * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ISoftUSBHubPort * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ISoftUSBHubPort * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_DeviceRemovable )( 
            ISoftUSBHubPort * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pfvarRemovable);
        
        /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT ( __stdcall *put_DeviceRemovable )( 
            ISoftUSBHubPort * This,
            /* [in] */ VARIANT_BOOL fvarRemovable);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_PwrCtrl )( 
            ISoftUSBHubPort * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pfvarPwrCtrl);
        
        /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT ( __stdcall *put_PwrCtrl )( 
            ISoftUSBHubPort * This,
            /* [in] */ VARIANT_BOOL fvarPwrCtrl);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_CurrentConnectStatus )( 
            ISoftUSBHubPort * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pfvarStatus);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_Enabled )( 
            ISoftUSBHubPort * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pfvarEnabled);
        
        /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT ( __stdcall *put_Enabled )( 
            ISoftUSBHubPort * This,
            /* [in] */ VARIANT_BOOL fvarEnabled);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_Suspend )( 
            ISoftUSBHubPort * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pfvarSuspend);
        
        /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT ( __stdcall *put_Suspend )( 
            ISoftUSBHubPort * This,
            /* [in] */ VARIANT_BOOL fvarSuspend);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_OverCurrent )( 
            ISoftUSBHubPort * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pfvarOverCurrent);
        
        /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT ( __stdcall *put_OverCurrent )( 
            ISoftUSBHubPort * This,
            /* [in] */ VARIANT_BOOL fvarOverCurrent);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_Reset )( 
            ISoftUSBHubPort * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pfvarReset);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_Power )( 
            ISoftUSBHubPort * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pfvarPower);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_AttachedDeviceSpeed )( 
            ISoftUSBHubPort * This,
            /* [retval][out] */ __RPC__out SoftUSBHubSpeed *pSpeed);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_TestMode )( 
            ISoftUSBHubPort * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pfvarTestMode);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_IndicatorControl )( 
            ISoftUSBHubPort * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pfvarIndicatorControl);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_Indicator )( 
            ISoftUSBHubPort * This,
            /* [retval][out] */ __RPC__out SoftUSBHubIndicator *pIndicator);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_ConnectStatusChange )( 
            ISoftUSBHubPort * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pfvarConnectStatusChange);
        
        /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT ( __stdcall *put_ConnectStatusChange )( 
            ISoftUSBHubPort * This,
            /* [in] */ VARIANT_BOOL fvarConnectStatusChange);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_EnableChange )( 
            ISoftUSBHubPort * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pfvarEnableChange);
        
        /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT ( __stdcall *put_EnableChange )( 
            ISoftUSBHubPort * This,
            /* [in] */ VARIANT_BOOL fvarEnableChange);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_SuspendChange )( 
            ISoftUSBHubPort * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pfvarSuspendChange);
        
        /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT ( __stdcall *put_SuspendChange )( 
            ISoftUSBHubPort * This,
            /* [in] */ VARIANT_BOOL fvarSuspendChange);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_OverCurrentChange )( 
            ISoftUSBHubPort * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pfvarOverCurrentChange);
        
        /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT ( __stdcall *put_OverCurrentChange )( 
            ISoftUSBHubPort * This,
            /* [in] */ VARIANT_BOOL fvarOverCurrentChange);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_ResetChange )( 
            ISoftUSBHubPort * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pfvarResetChange);
        
        /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT ( __stdcall *put_ResetChange )( 
            ISoftUSBHubPort * This,
            /* [in] */ VARIANT_BOOL fvarResetChange);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_Status )( 
            ISoftUSBHubPort * This,
            /* [retval][out] */ __RPC__out long *plStatus);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_Device )( 
            ISoftUSBHubPort * This,
            /* [retval][out] */ __RPC__deref_out_opt /* external definition not present */ DSFDevice **ppDSFDevice);
        
        /* [helpstringcontext][helpcontext][helpstring][id] */ HRESULT ( __stdcall *HotPlug )( 
            ISoftUSBHubPort * This,
            /* [in] */ __RPC__in /* external definition not present */ DSFDevice *pDSFDevice);
        
        /* [helpstringcontext][helpcontext][helpstring][id] */ HRESULT ( __stdcall *Unplug )( 
            ISoftUSBHubPort * This);
        
        END_INTERFACE
    } ISoftUSBHubPortVtbl;

    interface ISoftUSBHubPort
    {
        CONST_VTBL struct ISoftUSBHubPortVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISoftUSBHubPort_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ISoftUSBHubPort_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ISoftUSBHubPort_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ISoftUSBHubPort_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ISoftUSBHubPort_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ISoftUSBHubPort_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ISoftUSBHubPort_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ISoftUSBHubPort_get_DeviceRemovable(This,pfvarRemovable)	\
    ( (This)->lpVtbl -> get_DeviceRemovable(This,pfvarRemovable) ) 

#define ISoftUSBHubPort_put_DeviceRemovable(This,fvarRemovable)	\
    ( (This)->lpVtbl -> put_DeviceRemovable(This,fvarRemovable) ) 

#define ISoftUSBHubPort_get_PwrCtrl(This,pfvarPwrCtrl)	\
    ( (This)->lpVtbl -> get_PwrCtrl(This,pfvarPwrCtrl) ) 

#define ISoftUSBHubPort_put_PwrCtrl(This,fvarPwrCtrl)	\
    ( (This)->lpVtbl -> put_PwrCtrl(This,fvarPwrCtrl) ) 

#define ISoftUSBHubPort_get_CurrentConnectStatus(This,pfvarStatus)	\
    ( (This)->lpVtbl -> get_CurrentConnectStatus(This,pfvarStatus) ) 

#define ISoftUSBHubPort_get_Enabled(This,pfvarEnabled)	\
    ( (This)->lpVtbl -> get_Enabled(This,pfvarEnabled) ) 

#define ISoftUSBHubPort_put_Enabled(This,fvarEnabled)	\
    ( (This)->lpVtbl -> put_Enabled(This,fvarEnabled) ) 

#define ISoftUSBHubPort_get_Suspend(This,pfvarSuspend)	\
    ( (This)->lpVtbl -> get_Suspend(This,pfvarSuspend) ) 

#define ISoftUSBHubPort_put_Suspend(This,fvarSuspend)	\
    ( (This)->lpVtbl -> put_Suspend(This,fvarSuspend) ) 

#define ISoftUSBHubPort_get_OverCurrent(This,pfvarOverCurrent)	\
    ( (This)->lpVtbl -> get_OverCurrent(This,pfvarOverCurrent) ) 

#define ISoftUSBHubPort_put_OverCurrent(This,fvarOverCurrent)	\
    ( (This)->lpVtbl -> put_OverCurrent(This,fvarOverCurrent) ) 

#define ISoftUSBHubPort_get_Reset(This,pfvarReset)	\
    ( (This)->lpVtbl -> get_Reset(This,pfvarReset) ) 

#define ISoftUSBHubPort_get_Power(This,pfvarPower)	\
    ( (This)->lpVtbl -> get_Power(This,pfvarPower) ) 

#define ISoftUSBHubPort_get_AttachedDeviceSpeed(This,pSpeed)	\
    ( (This)->lpVtbl -> get_AttachedDeviceSpeed(This,pSpeed) ) 

#define ISoftUSBHubPort_get_TestMode(This,pfvarTestMode)	\
    ( (This)->lpVtbl -> get_TestMode(This,pfvarTestMode) ) 

#define ISoftUSBHubPort_get_IndicatorControl(This,pfvarIndicatorControl)	\
    ( (This)->lpVtbl -> get_IndicatorControl(This,pfvarIndicatorControl) ) 

#define ISoftUSBHubPort_get_Indicator(This,pIndicator)	\
    ( (This)->lpVtbl -> get_Indicator(This,pIndicator) ) 

#define ISoftUSBHubPort_get_ConnectStatusChange(This,pfvarConnectStatusChange)	\
    ( (This)->lpVtbl -> get_ConnectStatusChange(This,pfvarConnectStatusChange) ) 

#define ISoftUSBHubPort_put_ConnectStatusChange(This,fvarConnectStatusChange)	\
    ( (This)->lpVtbl -> put_ConnectStatusChange(This,fvarConnectStatusChange) ) 

#define ISoftUSBHubPort_get_EnableChange(This,pfvarEnableChange)	\
    ( (This)->lpVtbl -> get_EnableChange(This,pfvarEnableChange) ) 

#define ISoftUSBHubPort_put_EnableChange(This,fvarEnableChange)	\
    ( (This)->lpVtbl -> put_EnableChange(This,fvarEnableChange) ) 

#define ISoftUSBHubPort_get_SuspendChange(This,pfvarSuspendChange)	\
    ( (This)->lpVtbl -> get_SuspendChange(This,pfvarSuspendChange) ) 

#define ISoftUSBHubPort_put_SuspendChange(This,fvarSuspendChange)	\
    ( (This)->lpVtbl -> put_SuspendChange(This,fvarSuspendChange) ) 

#define ISoftUSBHubPort_get_OverCurrentChange(This,pfvarOverCurrentChange)	\
    ( (This)->lpVtbl -> get_OverCurrentChange(This,pfvarOverCurrentChange) ) 

#define ISoftUSBHubPort_put_OverCurrentChange(This,fvarOverCurrentChange)	\
    ( (This)->lpVtbl -> put_OverCurrentChange(This,fvarOverCurrentChange) ) 

#define ISoftUSBHubPort_get_ResetChange(This,pfvarResetChange)	\
    ( (This)->lpVtbl -> get_ResetChange(This,pfvarResetChange) ) 

#define ISoftUSBHubPort_put_ResetChange(This,fvarResetChange)	\
    ( (This)->lpVtbl -> put_ResetChange(This,fvarResetChange) ) 

#define ISoftUSBHubPort_get_Status(This,plStatus)	\
    ( (This)->lpVtbl -> get_Status(This,plStatus) ) 

#define ISoftUSBHubPort_get_Device(This,ppDSFDevice)	\
    ( (This)->lpVtbl -> get_Device(This,ppDSFDevice) ) 

#define ISoftUSBHubPort_HotPlug(This,pDSFDevice)	\
    ( (This)->lpVtbl -> HotPlug(This,pDSFDevice) ) 

#define ISoftUSBHubPort_Unplug(This)	\
    ( (This)->lpVtbl -> Unplug(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ISoftUSBHubPort_INTERFACE_DEFINED__ */


#ifndef __ISoftUSBDevice_INTERFACE_DEFINED__
#define __ISoftUSBDevice_INTERFACE_DEFINED__

/* interface ISoftUSBDevice */
/* [helpstringcontext][helpcontext][helpstring][object][hidden][nonextensible][oleautomation][dual][uuid] */ 


EXTERN_C const IID IID_ISoftUSBDevice;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9ac61697-81ae-459a-8629-bf5d5a838519")
    ISoftUSBDevice : public IDispatch
    {
    public:
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_Endpoint0( 
            /* [retval][out] */ __RPC__deref_out_opt ISoftUSBEndpoint **ppiEndpoint0) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_Length( 
            /* [retval][out] */ __RPC__out BYTE *pbLength) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT __stdcall put_Length( 
            /* [in] */ BYTE bLength) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_DescriptorType( 
            /* [retval][out] */ __RPC__out BYTE *pbDescriptorType) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT __stdcall put_DescriptorType( 
            /* [in] */ BYTE bDescriptorType) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_USB( 
            /* [retval][out] */ __RPC__out SHORT *psUSB) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT __stdcall put_USB( 
            /* [in] */ SHORT sUSB) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_DeviceClass( 
            /* [retval][out] */ __RPC__out BYTE *pbDeviceClass) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT __stdcall put_DeviceClass( 
            /* [in] */ BYTE bDeviceClass) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_DeviceSubClass( 
            /* [retval][out] */ __RPC__out BYTE *pbDeviceSubClass) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT __stdcall put_DeviceSubClass( 
            /* [in] */ BYTE bDeviceSubClass) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_DeviceProtocol( 
            /* [retval][out] */ __RPC__out BYTE *pbProtocol) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT __stdcall put_DeviceProtocol( 
            /* [in] */ BYTE bProtocol) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_MaxPacketSize0( 
            /* [retval][out] */ __RPC__out BYTE *pbMaxPacket) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT __stdcall put_MaxPacketSize0( 
            /* [in] */ BYTE bMaxPacket) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_Vendor( 
            /* [retval][out] */ __RPC__out SHORT *psVendor) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT __stdcall put_Vendor( 
            /* [in] */ SHORT sVendor) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_Product( 
            /* [retval][out] */ __RPC__out SHORT *psProduct) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT __stdcall put_Product( 
            /* [in] */ SHORT sProduct) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_Device( 
            /* [retval][out] */ __RPC__out SHORT *psDeviceNumber) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT __stdcall put_Device( 
            /* [in] */ SHORT sDeviceNumber) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_Manufacturer( 
            /* [retval][out] */ __RPC__out BYTE *pbManufacturer) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT __stdcall put_Manufacturer( 
            /* [in] */ BYTE bManufacturer) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_ProductDesc( 
            /* [retval][out] */ __RPC__out BYTE *pbProductDesc) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT __stdcall put_ProductDesc( 
            /* [in] */ BYTE bProductDesc) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_SerialNumber( 
            /* [retval][out] */ __RPC__out BYTE *pbSerialNumber) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT __stdcall put_SerialNumber( 
            /* [in] */ BYTE bSerialNumber) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_NumConfigurations( 
            /* [retval][out] */ __RPC__out BYTE *pbNumConfigs) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_DeviceQualifier( 
            /* [retval][out] */ __RPC__deref_out_opt ISoftUSBDeviceQualifier **ppiDeviceQualifier) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT __stdcall put_DeviceQualifier( 
            /* [in] */ __RPC__in_opt ISoftUSBDeviceQualifier *piDeviceQualifier) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propputref][id] */ HRESULT __stdcall putref_DeviceQualifier( 
            /* [in] */ __RPC__in_opt ISoftUSBDeviceQualifier *piDeviceQualifier) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_Configurations( 
            /* [retval][out] */ __RPC__deref_out_opt ISoftUSBConfigurations **ppiConfigurations) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_USB1xConfigurations( 
            /* [retval][out] */ __RPC__deref_out_opt ISoftUSBConfigurations **ppiUSB1xConfigurations) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT __stdcall put_RemoteWakeup( 
            /* [in] */ VARIANT_BOOL RemoteWakeup) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_RemoteWakeup( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pRemoteWakeup) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_Address( 
            /* [retval][out] */ __RPC__out BYTE *pbAddress) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_HasExternalPower( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pfvarPowered) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT __stdcall put_HasExternalPower( 
            /* [in] */ VARIANT_BOOL fvarPowered) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_OperatingSpeed( 
            /* [retval][out] */ __RPC__out SoftUSBHubSpeed *pSpeed) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_Configuration( 
            /* [retval][out] */ __RPC__out BYTE *pbConfig) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_Strings( 
            /* [retval][out] */ __RPC__deref_out_opt ISoftUSBStrings **ppiStrings) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_DSFDevice( 
            /* [retval][out] */ __RPC__deref_out_opt /* external definition not present */ DSFDevice **ppDSFDevice) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_Context( 
            /* [retval][out] */ __RPC__deref_out_opt /* external definition not present */ DSFPropertyBag **ppContext) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_State( 
            /* [retval][out] */ __RPC__out SoftUSBDeviceState *pState) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][id] */ HRESULT __stdcall Resume( void) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][id] */ HRESULT __stdcall Destroy( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISoftUSBDeviceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISoftUSBDevice * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISoftUSBDevice * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISoftUSBDevice * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ISoftUSBDevice * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ISoftUSBDevice * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ISoftUSBDevice * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ISoftUSBDevice * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_Endpoint0 )( 
            ISoftUSBDevice * This,
            /* [retval][out] */ __RPC__deref_out_opt ISoftUSBEndpoint **ppiEndpoint0);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_Length )( 
            ISoftUSBDevice * This,
            /* [retval][out] */ __RPC__out BYTE *pbLength);
        
        /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT ( __stdcall *put_Length )( 
            ISoftUSBDevice * This,
            /* [in] */ BYTE bLength);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_DescriptorType )( 
            ISoftUSBDevice * This,
            /* [retval][out] */ __RPC__out BYTE *pbDescriptorType);
        
        /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT ( __stdcall *put_DescriptorType )( 
            ISoftUSBDevice * This,
            /* [in] */ BYTE bDescriptorType);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_USB )( 
            ISoftUSBDevice * This,
            /* [retval][out] */ __RPC__out SHORT *psUSB);
        
        /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT ( __stdcall *put_USB )( 
            ISoftUSBDevice * This,
            /* [in] */ SHORT sUSB);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_DeviceClass )( 
            ISoftUSBDevice * This,
            /* [retval][out] */ __RPC__out BYTE *pbDeviceClass);
        
        /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT ( __stdcall *put_DeviceClass )( 
            ISoftUSBDevice * This,
            /* [in] */ BYTE bDeviceClass);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_DeviceSubClass )( 
            ISoftUSBDevice * This,
            /* [retval][out] */ __RPC__out BYTE *pbDeviceSubClass);
        
        /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT ( __stdcall *put_DeviceSubClass )( 
            ISoftUSBDevice * This,
            /* [in] */ BYTE bDeviceSubClass);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_DeviceProtocol )( 
            ISoftUSBDevice * This,
            /* [retval][out] */ __RPC__out BYTE *pbProtocol);
        
        /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT ( __stdcall *put_DeviceProtocol )( 
            ISoftUSBDevice * This,
            /* [in] */ BYTE bProtocol);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_MaxPacketSize0 )( 
            ISoftUSBDevice * This,
            /* [retval][out] */ __RPC__out BYTE *pbMaxPacket);
        
        /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT ( __stdcall *put_MaxPacketSize0 )( 
            ISoftUSBDevice * This,
            /* [in] */ BYTE bMaxPacket);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_Vendor )( 
            ISoftUSBDevice * This,
            /* [retval][out] */ __RPC__out SHORT *psVendor);
        
        /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT ( __stdcall *put_Vendor )( 
            ISoftUSBDevice * This,
            /* [in] */ SHORT sVendor);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_Product )( 
            ISoftUSBDevice * This,
            /* [retval][out] */ __RPC__out SHORT *psProduct);
        
        /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT ( __stdcall *put_Product )( 
            ISoftUSBDevice * This,
            /* [in] */ SHORT sProduct);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_Device )( 
            ISoftUSBDevice * This,
            /* [retval][out] */ __RPC__out SHORT *psDeviceNumber);
        
        /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT ( __stdcall *put_Device )( 
            ISoftUSBDevice * This,
            /* [in] */ SHORT sDeviceNumber);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_Manufacturer )( 
            ISoftUSBDevice * This,
            /* [retval][out] */ __RPC__out BYTE *pbManufacturer);
        
        /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT ( __stdcall *put_Manufacturer )( 
            ISoftUSBDevice * This,
            /* [in] */ BYTE bManufacturer);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_ProductDesc )( 
            ISoftUSBDevice * This,
            /* [retval][out] */ __RPC__out BYTE *pbProductDesc);
        
        /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT ( __stdcall *put_ProductDesc )( 
            ISoftUSBDevice * This,
            /* [in] */ BYTE bProductDesc);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_SerialNumber )( 
            ISoftUSBDevice * This,
            /* [retval][out] */ __RPC__out BYTE *pbSerialNumber);
        
        /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT ( __stdcall *put_SerialNumber )( 
            ISoftUSBDevice * This,
            /* [in] */ BYTE bSerialNumber);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_NumConfigurations )( 
            ISoftUSBDevice * This,
            /* [retval][out] */ __RPC__out BYTE *pbNumConfigs);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_DeviceQualifier )( 
            ISoftUSBDevice * This,
            /* [retval][out] */ __RPC__deref_out_opt ISoftUSBDeviceQualifier **ppiDeviceQualifier);
        
        /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT ( __stdcall *put_DeviceQualifier )( 
            ISoftUSBDevice * This,
            /* [in] */ __RPC__in_opt ISoftUSBDeviceQualifier *piDeviceQualifier);
        
        /* [helpstringcontext][helpcontext][helpstring][propputref][id] */ HRESULT ( __stdcall *putref_DeviceQualifier )( 
            ISoftUSBDevice * This,
            /* [in] */ __RPC__in_opt ISoftUSBDeviceQualifier *piDeviceQualifier);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_Configurations )( 
            ISoftUSBDevice * This,
            /* [retval][out] */ __RPC__deref_out_opt ISoftUSBConfigurations **ppiConfigurations);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_USB1xConfigurations )( 
            ISoftUSBDevice * This,
            /* [retval][out] */ __RPC__deref_out_opt ISoftUSBConfigurations **ppiUSB1xConfigurations);
        
        /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT ( __stdcall *put_RemoteWakeup )( 
            ISoftUSBDevice * This,
            /* [in] */ VARIANT_BOOL RemoteWakeup);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_RemoteWakeup )( 
            ISoftUSBDevice * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pRemoteWakeup);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_Address )( 
            ISoftUSBDevice * This,
            /* [retval][out] */ __RPC__out BYTE *pbAddress);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_HasExternalPower )( 
            ISoftUSBDevice * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pfvarPowered);
        
        /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT ( __stdcall *put_HasExternalPower )( 
            ISoftUSBDevice * This,
            /* [in] */ VARIANT_BOOL fvarPowered);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_OperatingSpeed )( 
            ISoftUSBDevice * This,
            /* [retval][out] */ __RPC__out SoftUSBHubSpeed *pSpeed);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_Configuration )( 
            ISoftUSBDevice * This,
            /* [retval][out] */ __RPC__out BYTE *pbConfig);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_Strings )( 
            ISoftUSBDevice * This,
            /* [retval][out] */ __RPC__deref_out_opt ISoftUSBStrings **ppiStrings);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_DSFDevice )( 
            ISoftUSBDevice * This,
            /* [retval][out] */ __RPC__deref_out_opt /* external definition not present */ DSFDevice **ppDSFDevice);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_Context )( 
            ISoftUSBDevice * This,
            /* [retval][out] */ __RPC__deref_out_opt /* external definition not present */ DSFPropertyBag **ppContext);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_State )( 
            ISoftUSBDevice * This,
            /* [retval][out] */ __RPC__out SoftUSBDeviceState *pState);
        
        /* [helpstringcontext][helpcontext][helpstring][id] */ HRESULT ( __stdcall *Resume )( 
            ISoftUSBDevice * This);
        
        /* [helpstringcontext][helpcontext][helpstring][id] */ HRESULT ( __stdcall *Destroy )( 
            ISoftUSBDevice * This);
        
        END_INTERFACE
    } ISoftUSBDeviceVtbl;

    interface ISoftUSBDevice
    {
        CONST_VTBL struct ISoftUSBDeviceVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISoftUSBDevice_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ISoftUSBDevice_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ISoftUSBDevice_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ISoftUSBDevice_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ISoftUSBDevice_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ISoftUSBDevice_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ISoftUSBDevice_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ISoftUSBDevice_get_Endpoint0(This,ppiEndpoint0)	\
    ( (This)->lpVtbl -> get_Endpoint0(This,ppiEndpoint0) ) 

#define ISoftUSBDevice_get_Length(This,pbLength)	\
    ( (This)->lpVtbl -> get_Length(This,pbLength) ) 

#define ISoftUSBDevice_put_Length(This,bLength)	\
    ( (This)->lpVtbl -> put_Length(This,bLength) ) 

#define ISoftUSBDevice_get_DescriptorType(This,pbDescriptorType)	\
    ( (This)->lpVtbl -> get_DescriptorType(This,pbDescriptorType) ) 

#define ISoftUSBDevice_put_DescriptorType(This,bDescriptorType)	\
    ( (This)->lpVtbl -> put_DescriptorType(This,bDescriptorType) ) 

#define ISoftUSBDevice_get_USB(This,psUSB)	\
    ( (This)->lpVtbl -> get_USB(This,psUSB) ) 

#define ISoftUSBDevice_put_USB(This,sUSB)	\
    ( (This)->lpVtbl -> put_USB(This,sUSB) ) 

#define ISoftUSBDevice_get_DeviceClass(This,pbDeviceClass)	\
    ( (This)->lpVtbl -> get_DeviceClass(This,pbDeviceClass) ) 

#define ISoftUSBDevice_put_DeviceClass(This,bDeviceClass)	\
    ( (This)->lpVtbl -> put_DeviceClass(This,bDeviceClass) ) 

#define ISoftUSBDevice_get_DeviceSubClass(This,pbDeviceSubClass)	\
    ( (This)->lpVtbl -> get_DeviceSubClass(This,pbDeviceSubClass) ) 

#define ISoftUSBDevice_put_DeviceSubClass(This,bDeviceSubClass)	\
    ( (This)->lpVtbl -> put_DeviceSubClass(This,bDeviceSubClass) ) 

#define ISoftUSBDevice_get_DeviceProtocol(This,pbProtocol)	\
    ( (This)->lpVtbl -> get_DeviceProtocol(This,pbProtocol) ) 

#define ISoftUSBDevice_put_DeviceProtocol(This,bProtocol)	\
    ( (This)->lpVtbl -> put_DeviceProtocol(This,bProtocol) ) 

#define ISoftUSBDevice_get_MaxPacketSize0(This,pbMaxPacket)	\
    ( (This)->lpVtbl -> get_MaxPacketSize0(This,pbMaxPacket) ) 

#define ISoftUSBDevice_put_MaxPacketSize0(This,bMaxPacket)	\
    ( (This)->lpVtbl -> put_MaxPacketSize0(This,bMaxPacket) ) 

#define ISoftUSBDevice_get_Vendor(This,psVendor)	\
    ( (This)->lpVtbl -> get_Vendor(This,psVendor) ) 

#define ISoftUSBDevice_put_Vendor(This,sVendor)	\
    ( (This)->lpVtbl -> put_Vendor(This,sVendor) ) 

#define ISoftUSBDevice_get_Product(This,psProduct)	\
    ( (This)->lpVtbl -> get_Product(This,psProduct) ) 

#define ISoftUSBDevice_put_Product(This,sProduct)	\
    ( (This)->lpVtbl -> put_Product(This,sProduct) ) 

#define ISoftUSBDevice_get_Device(This,psDeviceNumber)	\
    ( (This)->lpVtbl -> get_Device(This,psDeviceNumber) ) 

#define ISoftUSBDevice_put_Device(This,sDeviceNumber)	\
    ( (This)->lpVtbl -> put_Device(This,sDeviceNumber) ) 

#define ISoftUSBDevice_get_Manufacturer(This,pbManufacturer)	\
    ( (This)->lpVtbl -> get_Manufacturer(This,pbManufacturer) ) 

#define ISoftUSBDevice_put_Manufacturer(This,bManufacturer)	\
    ( (This)->lpVtbl -> put_Manufacturer(This,bManufacturer) ) 

#define ISoftUSBDevice_get_ProductDesc(This,pbProductDesc)	\
    ( (This)->lpVtbl -> get_ProductDesc(This,pbProductDesc) ) 

#define ISoftUSBDevice_put_ProductDesc(This,bProductDesc)	\
    ( (This)->lpVtbl -> put_ProductDesc(This,bProductDesc) ) 

#define ISoftUSBDevice_get_SerialNumber(This,pbSerialNumber)	\
    ( (This)->lpVtbl -> get_SerialNumber(This,pbSerialNumber) ) 

#define ISoftUSBDevice_put_SerialNumber(This,bSerialNumber)	\
    ( (This)->lpVtbl -> put_SerialNumber(This,bSerialNumber) ) 

#define ISoftUSBDevice_get_NumConfigurations(This,pbNumConfigs)	\
    ( (This)->lpVtbl -> get_NumConfigurations(This,pbNumConfigs) ) 

#define ISoftUSBDevice_get_DeviceQualifier(This,ppiDeviceQualifier)	\
    ( (This)->lpVtbl -> get_DeviceQualifier(This,ppiDeviceQualifier) ) 

#define ISoftUSBDevice_put_DeviceQualifier(This,piDeviceQualifier)	\
    ( (This)->lpVtbl -> put_DeviceQualifier(This,piDeviceQualifier) ) 

#define ISoftUSBDevice_putref_DeviceQualifier(This,piDeviceQualifier)	\
    ( (This)->lpVtbl -> putref_DeviceQualifier(This,piDeviceQualifier) ) 

#define ISoftUSBDevice_get_Configurations(This,ppiConfigurations)	\
    ( (This)->lpVtbl -> get_Configurations(This,ppiConfigurations) ) 

#define ISoftUSBDevice_get_USB1xConfigurations(This,ppiUSB1xConfigurations)	\
    ( (This)->lpVtbl -> get_USB1xConfigurations(This,ppiUSB1xConfigurations) ) 

#define ISoftUSBDevice_put_RemoteWakeup(This,RemoteWakeup)	\
    ( (This)->lpVtbl -> put_RemoteWakeup(This,RemoteWakeup) ) 

#define ISoftUSBDevice_get_RemoteWakeup(This,pRemoteWakeup)	\
    ( (This)->lpVtbl -> get_RemoteWakeup(This,pRemoteWakeup) ) 

#define ISoftUSBDevice_get_Address(This,pbAddress)	\
    ( (This)->lpVtbl -> get_Address(This,pbAddress) ) 

#define ISoftUSBDevice_get_HasExternalPower(This,pfvarPowered)	\
    ( (This)->lpVtbl -> get_HasExternalPower(This,pfvarPowered) ) 

#define ISoftUSBDevice_put_HasExternalPower(This,fvarPowered)	\
    ( (This)->lpVtbl -> put_HasExternalPower(This,fvarPowered) ) 

#define ISoftUSBDevice_get_OperatingSpeed(This,pSpeed)	\
    ( (This)->lpVtbl -> get_OperatingSpeed(This,pSpeed) ) 

#define ISoftUSBDevice_get_Configuration(This,pbConfig)	\
    ( (This)->lpVtbl -> get_Configuration(This,pbConfig) ) 

#define ISoftUSBDevice_get_Strings(This,ppiStrings)	\
    ( (This)->lpVtbl -> get_Strings(This,ppiStrings) ) 

#define ISoftUSBDevice_get_DSFDevice(This,ppDSFDevice)	\
    ( (This)->lpVtbl -> get_DSFDevice(This,ppDSFDevice) ) 

#define ISoftUSBDevice_get_Context(This,ppContext)	\
    ( (This)->lpVtbl -> get_Context(This,ppContext) ) 

#define ISoftUSBDevice_get_State(This,pState)	\
    ( (This)->lpVtbl -> get_State(This,pState) ) 

#define ISoftUSBDevice_Resume(This)	\
    ( (This)->lpVtbl -> Resume(This) ) 

#define ISoftUSBDevice_Destroy(This)	\
    ( (This)->lpVtbl -> Destroy(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ISoftUSBDevice_INTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_SoftUSBDevice;

#ifdef __cplusplus

class DECLSPEC_UUID("23f4a589-a546-4ed4-b18b-fa427cde2ac5")
SoftUSBDevice;
#endif

EXTERN_C const CLSID CLSID_SoftUSBDeviceQualifier;

#ifdef __cplusplus

class DECLSPEC_UUID("97353e3a-cb00-4242-aaa7-b5efae55aab0")
SoftUSBDeviceQualifier;
#endif

EXTERN_C const CLSID CLSID_SoftUSBConfiguration;

#ifdef __cplusplus

class DECLSPEC_UUID("92cf5e08-ac7b-4100-8ef8-4f2487fc8b90")
SoftUSBConfiguration;
#endif

EXTERN_C const CLSID CLSID_SoftUSBInterface;

#ifdef __cplusplus

class DECLSPEC_UUID("e9b15f26-b117-4f4c-9489-26cf8041bf4d")
SoftUSBInterface;
#endif

EXTERN_C const CLSID CLSID_SoftUSBEndpoint;

#ifdef __cplusplus

class DECLSPEC_UUID("56D58287-C835-48A4-86A9-A0CBF8A8384A")
SoftUSBEndpoint;
#endif

EXTERN_C const CLSID CLSID_SoftUSBConfigurations;

#ifdef __cplusplus

class DECLSPEC_UUID("89D25542-A41B-49E1-9B80-2D3D28656541")
SoftUSBConfigurations;
#endif

EXTERN_C const CLSID CLSID_SoftUSBInterfaces;

#ifdef __cplusplus

class DECLSPEC_UUID("8BACAC01-DD39-4D96-88DC-25411C409E86")
SoftUSBInterfaces;
#endif

EXTERN_C const CLSID CLSID_SoftUSBEndpoints;

#ifdef __cplusplus

class DECLSPEC_UUID("5B538872-325E-48E6-8F83-EA5F1273A38E")
SoftUSBEndpoints;
#endif

EXTERN_C const CLSID CLSID_SoftUSBStrings;

#ifdef __cplusplus

class DECLSPEC_UUID("BA8EDA13-3019-4F40-8AEB-83051C28F313")
SoftUSBStrings;
#endif

#ifndef __ISoftUSBString_INTERFACE_DEFINED__
#define __ISoftUSBString_INTERFACE_DEFINED__

/* interface ISoftUSBString */
/* [object][helpstringcontext][helpcontext][helpstring][hidden][nonextensible][oleautomation][dual][uuid] */ 


EXTERN_C const IID IID_ISoftUSBString;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3D6CC2C8-7EF0-40DD-9999-3071A7D3E6E0")
    ISoftUSBString : public IDispatch
    {
    public:
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_Value( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrString) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT __stdcall put_Value( 
            /* [in] */ __RPC__in BSTR bstrString) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_Length( 
            /* [retval][out] */ __RPC__out BYTE *pbLength) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT __stdcall put_Length( 
            /* [in] */ BYTE bLength) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT __stdcall get_DescriptorType( 
            /* [retval][out] */ __RPC__out BYTE *pbDescriptorType) = 0;
        
        virtual /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT __stdcall put_DescriptorType( 
            /* [in] */ BYTE bDescriptorType) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISoftUSBStringVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISoftUSBString * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISoftUSBString * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISoftUSBString * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ISoftUSBString * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ISoftUSBString * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ISoftUSBString * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ISoftUSBString * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_Value )( 
            ISoftUSBString * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrString);
        
        /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT ( __stdcall *put_Value )( 
            ISoftUSBString * This,
            /* [in] */ __RPC__in BSTR bstrString);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_Length )( 
            ISoftUSBString * This,
            /* [retval][out] */ __RPC__out BYTE *pbLength);
        
        /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT ( __stdcall *put_Length )( 
            ISoftUSBString * This,
            /* [in] */ BYTE bLength);
        
        /* [helpstringcontext][helpcontext][helpstring][propget][id] */ HRESULT ( __stdcall *get_DescriptorType )( 
            ISoftUSBString * This,
            /* [retval][out] */ __RPC__out BYTE *pbDescriptorType);
        
        /* [helpstringcontext][helpcontext][helpstring][propput][id] */ HRESULT ( __stdcall *put_DescriptorType )( 
            ISoftUSBString * This,
            /* [in] */ BYTE bDescriptorType);
        
        END_INTERFACE
    } ISoftUSBStringVtbl;

    interface ISoftUSBString
    {
        CONST_VTBL struct ISoftUSBStringVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISoftUSBString_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ISoftUSBString_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ISoftUSBString_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ISoftUSBString_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ISoftUSBString_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ISoftUSBString_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ISoftUSBString_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ISoftUSBString_get_Value(This,pbstrString)	\
    ( (This)->lpVtbl -> get_Value(This,pbstrString) ) 

#define ISoftUSBString_put_Value(This,bstrString)	\
    ( (This)->lpVtbl -> put_Value(This,bstrString) ) 

#define ISoftUSBString_get_Length(This,pbLength)	\
    ( (This)->lpVtbl -> get_Length(This,pbLength) ) 

#define ISoftUSBString_put_Length(This,bLength)	\
    ( (This)->lpVtbl -> put_Length(This,bLength) ) 

#define ISoftUSBString_get_DescriptorType(This,pbDescriptorType)	\
    ( (This)->lpVtbl -> get_DescriptorType(This,pbDescriptorType) ) 

#define ISoftUSBString_put_DescriptorType(This,bDescriptorType)	\
    ( (This)->lpVtbl -> put_DescriptorType(This,bDescriptorType) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ISoftUSBString_INTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_SoftUSBString;

#ifdef __cplusplus

class DECLSPEC_UUID("4D45AEA4-6FBE-4D81-B600-7511648520C7")
SoftUSBString;
#endif

EXTERN_C const CLSID CLSID_SoftUSBHub;

#ifdef __cplusplus

class DECLSPEC_UUID("4195454B-4ACE-44CD-B4B9-30CEE8D8951B")
SoftUSBHub;
#endif

EXTERN_C const CLSID CLSID_SoftUSBHubPorts;

#ifdef __cplusplus

class DECLSPEC_UUID("364C8DB9-665B-428A-840B-1D0CE777F05F")
SoftUSBHubPorts;
#endif

EXTERN_C const CLSID CLSID_SoftUSBHubPort;

#ifdef __cplusplus

class DECLSPEC_UUID("736CD631-7F9D-4625-B693-F278E119FAD8")
SoftUSBHubPort;
#endif
#endif /* __SOFTUSB_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\stdcall.inc ===
;****************************Public Macro************************************
;
;   ComposeInst Inst,p1,p2,p3,p4,p5,p6,p7,p8,p9
;
;       This macro simply concatenates all arguments into one string.
;
;
;****************************************************************************

ComposeInst macro   Inst,p1,p2,p3,p4,p5,p6,p7,p8,p9
        &Inst   &p1&p2&p3&p4&p5&p6&p7&p8&p9
endm

;****************************Public Macro************************************
;
;   CountArg    cCount,ArgList
;
;       This macro count the number of arguments in the ArgList and returns
;       the value in cCount.
;
;   History:
;       Thu 15-Aug-1991 16:21:14    -by-    Viroon Touranachun [viroont]
;           Created
;
;****************************************************************************

CountArg    macro   cCount,ArgList

        cCount = 0

        irp arg,<ArgList>
            cCount = cCount+1
        endm
endm

;****************************Public Macro************************************
;
;   RevPush     ArgList,cCount
;
;       This macro pushes the arguments in ArgList in the reverse order
;       and returns the number of arguments in cCount.
;
;   History:
;       Thu 15-Aug-1991 16:21:14    -by-    Viroon Touranachun [viroont]
;           Created
;
;****************************************************************************

RevPush macro   ArgList,cCount
        Local   index,x

        CountArg cCount,<ArgList>

        index  = cCount
        rept    cCount
            x = 0
            irp arg,<ArgList>
                x = x+1
                ife index-x
                    push    arg
                    exitm
                endif
            endm
            index = index-1
        endm
endm

;****************************Public Macro************************************
;
;   The following sections contain calling-convention related macros for:
;
;   PUBLICP     Func,N
;       to define a public label
;
;   EXTRNP      Func,N
;       to define a external near label
;
;   LABELP      Func,N
;       to label an address as a routine entry point
;
;   cProc       Func,N,ArgList
;       to declare a routine header
;
;   ProcName    Name,Func,N
;       to rename a function Func to Name. Using it in conjunction with
;       normal function declaration (with the new name) will solve an error
;       caused by a long parameter list routine that exhausts page width.
;
;   cRet        Func
;       to return from Func routines (declared with cProc or ProcName.)
;
;   endProc     Func
;       to declare the end of routine (declared with cProc or ProcName.)
;
;   endMod      Func
;       to declare the end of module with an entry point at Func (declared
;       with cProc or ProcName.)
;
;   cCall       Func,ArgList
;       to call to a routine--Func--with the arguments pushed on the stack
;
;   ptrCall     Func,ArgList
;       to call through a pointer with the arguments pushed on the stack
;
;   MovAddr     dest,Func,n
;       to move the address of the routine--Func--into dest.
;
;   Note that for the standard calling convention all the function names,
;   Func, are automatically converted to Func@N where N is the number of
;   bytes in the argument list.
;
;   History:
;       Thu 15-Aug-1991 16:21:14    -by-    Viroon Touranachun [viroont]
;           Created
;
;****************************************************************************

IFNDEF  DOS_PLATFORM
IFNDEF  STD_CALL

;****************************************************************************
;
;   This section is used exclusively for C calling convention.
;
;****************************************************************************

PUBLICP macro   Func,N

        public      &Func
endm

EXTRNP  macro   Func,N

        extrn       &Func:NEAR
endm

LABELP  macro   Func,N

        &Func       LABEL   NEAR
endm

ProcName macro  Name,Func,N

        &Name        EQU     <&Func>
endm

cProc   macro   Func,N,ArgList

        ProcName xxx&Func,Func,N

        xxx&Func proc &ArgList
endm

cRet    macro   Func

        ret
endm

endProc macro   Func

        xxx&Func   endp
endm

endMod  macro   Func

end     xxx&Func

endm

ptrCall macro   Func,ArgList
        Local   Bytes

        RevPush <ArgList>,Bytes
        Bytes = Bytes*4

        call    &Func

        if      Bytes GT 0
            add     esp,Bytes
        endif
endm

cCall   macro   Func,ArgList
        Local   Bytes

        RevPush <ArgList>,Bytes
        Bytes = Bytes*4

        call    &Func

        if      Bytes GT 0
            add     esp,Bytes
        endif

endm

MovAddr macro   dest,addr,n

        mov     dest,offset FLAT:&addr
endm

ENDIF   ; STD_CALL

ELSE

IFNDEF  STD_CALL

;****************************************************************************
;
;   This section is used exclusively for Pascal calling convention.
;
;****************************************************************************

PUBLICP macro   Func,N

        public      &Func
endm

EXTRNP  macro   Func,N

        extrn       &Func:NEAR
endm

LABELP  macro   Func,N

        &Func       LABEL   NEAR
endm

ProcName macro  Name,Func,N

        &Name        EQU     <&Func>
endm

cProc   macro   Func,N,ArgList

        ProcName xxx&Func,Func,N

        xxx&Func proc &ArgList
endm

cRet    macro   Func

        ret
endm

endProc macro   Func

        xxx&Func   endp
endm

endMod  macro   Func

end     xxx&Func

endm

cCall   macro   Func,ArgList
        irp arg,<ArgList>
            push    arg
        endm

        call    &Func
endm

MovAddr macro   dest,addr,n

        mov     dest,offset FLAT:&addr
endm

ENDIF   : ~STD_CALL
ENDIF   ; DOS_PLATFORM

IFDEF STD_CALL
;****************************************************************************
;
;   This section is used exclusively for the standard calling convention.
;
;****************************************************************************

PUBLICP macro   Func,N

        ifb    <N>
            public      &Func&@0
        else
            public      &Func&@&N
        endif
endm

EXTRNP  macro   Func,N

        ifb    <N>
            extrn       &Func&@0:NEAR
        else
            extrn       &Func&@&N:NEAR
        endif
endm

LABELP  macro   Func,N

        ifb    <N>
            &Func&@0    LABEL   NEAR
        else
            &Func&@&N   LABEL   NEAR
        endif
endm

ProcName macro  Name,Func,N

        ifb <N>
            cByte&Func   EQU     0
            &Name        EQU     <&Func&@0>
        else
            cByte&Func   EQU     N
            &Name        EQU     <&Func&@&N>
        endif
endm

cProc   macro   Func,N,ArgList

        ProcName xxx&Func,Func,N

        xxx&Func proc &ArgList
endm

cRet    macro   Func

        ret     cByte&Func

endm


endProc macro   Func

        xxx&Func   endp

endm

endMod  macro   Func

end     xxx&Func

endm

ptrCall macro   Func,ArgList
        Local   Bytes

        RevPush <ArgList>,Bytes
        call    &Func
endm

cCall   macro   Func,ArgList
        Local   Bytes

        RevPush <ArgList>,Bytes
        Bytes = Bytes*4

        ComposeInst <call>,&Func,<@>,%(Bytes)
endm

MovAddr macro   dest,addr,n

        ComposeInst <mov >,dest,<,offset FLAT:>,addr,<@>,n
endm

ENDIF   ;STD_CALL

=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\stdunk.h ===
/*****************************************************************************
 * stdunk.h - standard IUnknown implementaton definitions
 *****************************************************************************
 * Copyright (c) Microsoft Corporation. All rights reserved.
 */

#ifndef _STDUNK_H_
#define _STDUNK_H_

#include "punknown.h"




#if (NTDDI_VERSION >= NTDDI_WIN2K)
/*****************************************************************************
 * Interfaces
 */

/*****************************************************************************
 * INonDelegatingUnknown
 *****************************************************************************
 * Non-delegating unknown interface.
 */
DECLARE_INTERFACE(INonDelegatingUnknown)
{
    STDMETHOD_(NTSTATUS,NonDelegatingQueryInterface)
    (   THIS_
        IN      REFIID,
        OUT     PVOID *
    )   PURE;

    STDMETHOD_(ULONG,NonDelegatingAddRef)
    (   THIS
    )   PURE;

    STDMETHOD_(ULONG,NonDelegatingRelease)
    (   THIS
    )   PURE;
};

typedef INonDelegatingUnknown *PNONDELEGATINGUNKNOWN;





/*****************************************************************************
 * Classes
 */

/*****************************************************************************
 * CUnknown
 *****************************************************************************
 * Base INonDelegatingUnknown implementation.
 */
class CUnknown : public INonDelegatingUnknown
{
private:

    LONG            m_lRefCount;        // Reference count.
    PUNKNOWN        m_pUnknownOuter;    // Outer IUnknown.

public:

    /*************************************************************************
         * CUnknown methods.
     */
    CUnknown(PUNKNOWN pUnknownOuter);
        virtual ~CUnknown(void);
    PUNKNOWN GetOuterUnknown(void)
    {
        return m_pUnknownOuter;
    }

    /*************************************************************************
         * INonDelegatingUnknown methods.
     */
        STDMETHODIMP_(ULONG) NonDelegatingAddRef
    (   void
    );
        STDMETHODIMP_(ULONG) NonDelegatingRelease
    (   void
    );
    STDMETHODIMP_(NTSTATUS) NonDelegatingQueryInterface
        (
                REFIID          rIID,
                PVOID *     ppVoid
        );
};





/*****************************************************************************
 * Macros
 */

/*****************************************************************************
 * DECLARE_STD_UNKNOWN
 *****************************************************************************
 * Various declarations for standard objects based on CUnknown.
 */
#define DECLARE_STD_UNKNOWN()                                   \
    STDMETHODIMP_(NTSTATUS) NonDelegatingQueryInterface                 \
        (                                                           \
                REFIID          iid,                                        \
                PVOID *     ppvObject                                   \
        );                                                          \
    STDMETHODIMP_(NTSTATUS) QueryInterface(REFIID riid, void **ppv)        \
    {                                                           \
        return GetOuterUnknown()->QueryInterface(riid,ppv);     \
    };                                                          \
    STDMETHODIMP_(ULONG) AddRef()                               \
    {                                                           \
        return GetOuterUnknown()->AddRef();                     \
    };                                                          \
    STDMETHODIMP_(ULONG) Release()                              \
    {                                                           \
        return GetOuterUnknown()->Release();                    \
    };

#define DEFINE_STD_CONSTRUCTOR(Class)                           \
    Class(PUNKNOWN pUnknownOuter)                               \
    :   CUnknown(pUnknownOuter)                                 \
    {                                                           \
    }

#define QICAST(Type)                                            \
    PVOID((Type)(this))

#define QICASTUNKNOWN(Type)                                     \
    PVOID(PUNKNOWN((Type)(this)))

#define STD_CREATE_BODY_WITH_TAG_(Class,ppUnknown,pUnknownOuter,poolType,tag,base)   \
    NTSTATUS ntStatus;                                                  \
    Class *p = new(poolType,tag) Class(pUnknownOuter);                  \
    if (p)                                                              \
    {                                                                   \
        *ppUnknown = PUNKNOWN((base)(p));                               \
        (*ppUnknown)->AddRef();                                         \
        ntStatus = STATUS_SUCCESS;                                      \
    }                                                                   \
    else                                                                \
    {                                                                   \
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;                       \
    }                                                                   \
    return ntStatus

#define STD_CREATE_BODY_WITH_TAG(Class,ppUnknown,pUnknownOuter,poolType,tag) \
    STD_CREATE_BODY_WITH_TAG_(Class,ppUnknown,pUnknownOuter,poolType,tag,PUNKNOWN)

#define STD_CREATE_BODY_(Class,ppUnknown,pUnknownOuter,poolType,base) \
    STD_CREATE_BODY_WITH_TAG_(Class,ppUnknown,pUnknownOuter,poolType,'rCcP',base)

#define STD_CREATE_BODY(Class,ppUnknown,pUnknownOuter,poolType) \
    STD_CREATE_BODY_(Class,ppUnknown,pUnknownOuter,poolType,PUNKNOWN)






/*****************************************************************************
 * Functions
 */
#ifndef PC_KDEXT    // this is not needed for the KD extensions.
#ifndef _NEW_DELETE_OPERATORS_
#define _NEW_DELETE_OPERATORS_

/*****************************************************************************
 * ::new()
 *****************************************************************************
 * New function for creating objects with a specified allocation tag.
 */
inline PVOID operator new
(
    size_t          iSize,
    POOL_TYPE       poolType
)
{
    PVOID result = ExAllocatePoolWithTag(poolType,iSize,'wNcP');

    if (result)
    {
        RtlZeroMemory(result,iSize);
    }

    return result;
}

/*****************************************************************************
 * ::new()
 *****************************************************************************
 * New function for creating objects with a specified allocation tag.
 */
inline PVOID operator new
(
    size_t          iSize,
    POOL_TYPE       poolType,
    ULONG           tag
)
{
    PVOID result = ExAllocatePoolWithTag(poolType,iSize,tag);

    if (result)
    {
        RtlZeroMemory(result,iSize);
    }

    return result;
}

/*****************************************************************************
 * ::delete()
 *****************************************************************************
 * Delete function.
 */
inline void __cdecl operator delete
(
    PVOID pVoid
)
{
    if (pVoid)
    {
        ExFreePool(pVoid);
    }
}

/*****************************************************************************
 * ::delete()
 *****************************************************************************
 * Delete function.
 */
inline void __cdecl operator delete
(
    PVOID pVoid,
    ULONG tag
)
{
    if (pVoid)
    {
        ExFreePoolWithTag(pVoid,tag);
    }
}

#endif //!_NEW_DELETE_OPERATORS_

#endif  // PC_KDEXT


#endif  // NTDDI
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\stiusd.h ===
/*++

Copyright (c) 1986-1997  Microsoft Corporation

Module Name:

    stiusd.h

Abstract:

    Definitions file for creating STI User-mode Still-image Drivers ( USD).

Author:


Revision History:


--*/

#ifndef _STIUSD_
#define _STIUSD_

// Include COM definitions
#define COM_NO_WINDOWS_H

//
#pragma intrinsic(memcmp,memset)

//
// Include COM definitions
//
#ifndef _NO_COM
#include <objbase.h>
#endif

#include <stireg.h>
#include <stierr.h>

#ifdef __cplusplus
extern "C" {
#endif

/*
 * Class IID's
 */


/*
 * Interface IID's
 */
#if defined( _WIN32 ) && !defined( _NO_COM)

// {0C9BB460-51AC-11D0-90EA-00AA0060F86C}
DEFINE_GUID(IID_IStiUSD, 0x0C9BB460L, 0x51AC, 0x11D0, 0x90, 0xEA, 0x00, 0xAA, 0x00, 0x60, 0xF8, 0x6C);

// {128A9860-52DC-11D0-9EDF-444553540000}
DEFINE_GUID(IID_IStiDeviceControl, 0x128A9860L, 0x52DC, 0x11D0, 0x9E, 0xDF, 0x44, 0x45, 0x53, 0x54, 0x00, 0x00);

#endif

/*
 * Data structures
 */

typedef struct _STI_USD_CAPS {

    DWORD   dwVersion;          // STI version used to build this USD

    DWORD   dwGenericCaps;

} STI_USD_CAPS,*PSTI_USD_CAPS;


//
// Claims to support device notifications asyncronously ( without polling)
//
#define STI_USD_GENCAP_NATIVE_PUSHSUPPORT STI_GENCAP_NOTIFICATIONS

//
// Asks to open device automatically ( not implemented now)
//
// #define STI_USD_GENCAP_OPEN_DEVICE_FOR_ME 0x00000002

typedef DWORD   USD_CONTROL_CODE;

/*
 * Generic constants and definitions
 */

//
// Internally used flags for open device mode.

// USD receives this  bit only when associated device instance is created by monitor process
//
#define STI_DEVICE_CREATE_FOR_MONITOR   0x01000000


#ifdef __cplusplus

struct IStiUSD;
struct IStiDeviceControl;

#endif

typedef struct IStiUSD             *PSTIUSD;
typedef struct IStiDeviceControl   *PSTIDEVICECONTROL;


/*
 * IStiDeviceControl interface
 *
 * Instance of object supporting this interface is passed to USD at the moment
 * of device object initialization.
 */
#undef INTERFACE
#define INTERFACE IStiDeviceControl
DECLARE_INTERFACE_(IStiDeviceControl, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef) (THIS) PURE;
    STDMETHOD_(ULONG, Release) (THIS) PURE;

    /*** IStiDeviceControl methods ***/
    STDMETHOD(Initialize) (THIS_ DWORD dwDeviceType,DWORD dwMode,LPCWSTR pwszPortName,DWORD dwFlags )PURE;
    STDMETHOD(RawReadData)(THIS_ LPVOID lpBuffer,LPDWORD lpdwNumberOfBytes,LPOVERLAPPED lpOverlapped) PURE;
    STDMETHOD(RawWriteData)(THIS_ LPVOID lpBuffer,DWORD nNumberOfBytes,LPOVERLAPPED lpOverlapped) PURE;
    STDMETHOD(RawReadCommand)(THIS_ LPVOID lpBuffer,LPDWORD lpdwNumberOfBytes,LPOVERLAPPED lpOverlapped) PURE;
    STDMETHOD(RawWriteCommand)(THIS_ LPVOID lpBuffer,DWORD nNumberOfBytes,LPOVERLAPPED lpOverlapped) PURE;
    STDMETHOD(RawDeviceControl)(THIS_ USD_CONTROL_CODE EscapeFunction,LPVOID  lpInData,DWORD   cbInDataSize,LPVOID pOutData,DWORD dwOutDataSize,LPDWORD pdwActualData) PURE ;
    STDMETHOD(GetLastError)(THIS_ LPDWORD     lpdwLastError) PURE;
    STDMETHOD(GetMyDevicePortName)(THIS_ __out_ecount(cwDevicePathSize) LPWSTR lpszDevicePath, DWORD cwDevicePathSize ) PURE;
    STDMETHOD(GetMyDeviceHandle)(THIS_ LPHANDLE lph) PURE;
    STDMETHOD(GetMyDeviceOpenMode)(THIS_ LPDWORD pdwOpenMode ) PURE;
    STDMETHOD(WriteToErrorLog)(THIS_ DWORD dwMessageType,LPCWSTR pszMessage,DWORD dwErrorCode) PURE;
} ;

#if !defined(__cplusplus) || defined(CINTERFACE)

#define IStiDeviceControl_QueryInterface(p,a,b)    (p)->lpVtbl->QueryInterface(p,a,b)
#define IStiDeviceControl_AddRef(p)                (p)->lpVtbl->AddRef(p)
#define IStiDeviceControl_Release(p)               (p)->lpVtbl->Release(p)
#define IStiDeviceControl_Initialize(p,a,b,c,d)    (p)->lpVtbl->Initialize(p,a,b,c,d)

#define IStiDeviceControl_RawReadData(p,a,b,c)     (p)->lpVtbl->RawReadData(p,a,b,c)
#define IStiDeviceControl_RawWriteData(p,a,b,c)    (p)->lpVtbl->RawWriteData(p,a,b,c)
#define IStiDeviceControl_RawReadCommand(p,a,b,c)  (p)->lpVtbl->RawReadCommand(p,a,b,c)
#define IStiDeviceControl_RawWriteCommand(p,a,b,c) (p)->lpVtbl->RawWriteCommand(p,a,b,c)
#define IStiDeviceControl_RawDeviceControl(p,a,b,c,d,e,f)   (p)->lpVtbl->RawDeviceControl(p,a,b,c,d,e,f)
#define IStiDeviceControl_GetLastError(p,a)        (p)->lpVtbl->GetLastError(p,a)
#define IStiDeviceControl_GetMyDevicePortName(p,a,b) (p)->lpVtbl->GetMyDevicePortName(p,a,b)
#define IStiDeviceControl_GetMyDeviceHandle(p,a)    (p)->lpVtbl->GetMyDeviceHandle(p,a)
#define IStiDeviceControl_GetMyDeviceOpenMode(p,a)  (p)->lpVtbl->GetMyDeviceOpenMode(p,a)
#define IStiDeviceControl_WriteToErrorLog(p,a,b,c)  (p)->lpVtbl->WriteToErrorLog(p,a,b,c)

#endif

/*
 * IStiUSD interface
 */
#undef INTERFACE
#define INTERFACE IStiUSD
DECLARE_INTERFACE_(IStiUSD, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef) (THIS) PURE;
    STDMETHOD_(ULONG, Release) (THIS) PURE;

    /*** IStiUSD methods ***/
    STDMETHOD(Initialize) (THIS_ PSTIDEVICECONTROL pHelDcb,DWORD dwStiVersion,HKEY hParametersKey) PURE;
    STDMETHOD(GetCapabilities) (THIS_ PSTI_USD_CAPS pDevCaps) PURE;
    STDMETHOD(GetStatus) (THIS_ PSTI_DEVICE_STATUS pDevStatus) PURE;
    STDMETHOD(DeviceReset)(THIS ) PURE;
    STDMETHOD(Diagnostic)(THIS_ LPSTI_DIAG pBuffer) PURE;
    STDMETHOD(Escape)(THIS_ STI_RAW_CONTROL_CODE    EscapeFunction,LPVOID  lpInData,DWORD   cbInDataSize,LPVOID pOutData,DWORD dwOutDataSize,LPDWORD pdwActualData) PURE ;
    STDMETHOD(GetLastError) (THIS_ LPDWORD pdwLastDeviceError) PURE;
    STDMETHOD(LockDevice) (THIS ) PURE;
    STDMETHOD(UnLockDevice) (THIS ) PURE;
    STDMETHOD(RawReadData)(THIS_ LPVOID lpBuffer,LPDWORD lpdwNumberOfBytes,LPOVERLAPPED lpOverlapped) PURE;
    STDMETHOD(RawWriteData)(THIS_ LPVOID lpBuffer,DWORD nNumberOfBytes,LPOVERLAPPED lpOverlapped) PURE;
    STDMETHOD(RawReadCommand)(THIS_ LPVOID lpBuffer,LPDWORD lpdwNumberOfBytes,LPOVERLAPPED lpOverlapped) PURE;
    STDMETHOD(RawWriteCommand)(THIS_ LPVOID lpBuffer,DWORD nNumberOfBytes,LPOVERLAPPED lpOverlapped) PURE;
    STDMETHOD(SetNotificationHandle)(THIS_ HANDLE hEvent) PURE;
    STDMETHOD(GetNotificationData)(THIS_ LPSTINOTIFY   lpNotify) PURE;
    STDMETHOD(GetLastErrorInfo) (THIS_ STI_ERROR_INFO *pLastErrorInfo) PURE;
} ;

#if !defined(__cplusplus) || defined(CINTERFACE)

#define IStiUSD_QueryInterface(p,a,b)    (p)->lpVtbl->QueryInterface(p,a,b)
#define IStiUSD_AddRef(p)                (p)->lpVtbl->AddRef(p)
#define IStiUSD_Release(p)               (p)->lpVtbl->Release(p)
#define IStiUSD_Initialize(p,a,b,c)      (p)->lpVtbl->Initialize(p,a,b,c)
#define IStiUSD_GetCapabilities(p,a)     (p)->lpVtbl->GetCapabilities(p,a)
#define IStiUSD_GetStatus(p,a)           (p)->lpVtbl->GetStatus(p,a)
#define IStiUSD_DeviceReset(p)           (p)->lpVtbl->DeviceReset(p)
#define IStiUSD_Diagnostic(p,a)          (p)->lpVtbl->Diagnostic(p,a)
#define IStiUSD_Escape(p,a,b,c,d,e,f)    (p)->lpVtbl->Escape(p,a,b,c,d,e,f)
#define IStiUSD_GetLastError(p,a)        (p)->lpVtbl->GetLastError(p,a)
#define IStiUSD_LockDevice(p)            (p)->lpVtbl->LockDevice(p)
#define IStiUSD_UnLockDevice(p)          (p)->lpVtbl->UnLockDevice(p)
#define IStiUSD_RawReadData(p,a,b,c)     (p)->lpVtbl->RawReadData(p,a,b,c)
#define IStiUSD_RawWriteData(p,a,b,c)    (p)->lpVtbl->RawWriteData(p,a,b,c)
#define IStiUSD_RawReadCommand(p,a,b,c)  (p)->lpVtbl->RawReadCommand(p,a,b,c)
#define IStiUSD_RawWriteCommand(p,a,b,c) (p)->lpVtbl->RawWriteCommand(p,a,b,c)
#define IStiUSD_SetNotificationHandle(p,a) (p)->lpVtbl->SetNotificationHandle(p,a)
#define IStiUSD_GetNotificationData(p,a) (p)->lpVtbl->GetNotificationData(p,a)
#define IStiUSD_GetLastErrorInfo(p,a)    (p)->lpVtbl->GetLastErrorInfo(p,a)

#endif

#ifdef __cplusplus
};
#endif

#endif // _STIUSD_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\storport.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    storport.h

Abstract:

    These are the structures and defines that are included by STORPORT miniport
    drivers.

Authors:

Revision History:

--*/

#ifdef _NTSCSI_
#error "STORPORT.H must be included instead of SCSI.H"
#endif

#ifdef _NTSRB_
#error "STORPORT.H must be included instead of SRB.H"
#endif

#ifndef _NTSTORPORT_
#define _NTSTORPORT_

#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning(disable:4200) // array[0] is not a warning for this file
#pragma warning(disable:4201) // nonstandard extension used : nameless struct/union

#if DBG
#define DebugPrint(x) StorPortDebugPrint x
#else
#define DebugPrint(x)
#endif


//
// Define SCSI maximum configuration parameters.
//

#define SCSI_MAXIMUM_LOGICAL_UNITS 8
#define SCSI_MAXIMUM_TARGETS_PER_BUS 128
#define SCSI_MAXIMUM_LUNS_PER_TARGET 255
#define SCSI_MAXIMUM_BUSES 8
#define SCSI_MINIMUM_PHYSICAL_BREAKS  16
#define SCSI_MAXIMUM_PHYSICAL_BREAKS 255

#define SCSI_COMBINE_BUS_TARGET( Bus, Target ) ( \
    ((((UCHAR) (Target)) & ~(0x20 - 1)) << 8) |        \
    (((UCHAR) (Bus)) << 5) |                     \
    (((UCHAR) (Target)) & (0x20 - 1)))

#define SCSI_DECODE_BUS_TARGET( Value, Bus, Target ) ( \
    Bus = (UCHAR) ((Value) >> 5),                     \
    Target = (UCHAR) ((((Value) >> 8) & ~(0x20 - 1)) | ((Value) & (0x20 - 1))))

//
// This constant is for backward compatibility.
// This use to be the maximum number of targets supported.
//

#define SCSI_MAXIMUM_TARGETS 8


//
// Uninitialized flag value.
//

#define SP_UNINITIALIZED_VALUE ((ULONG) ~0)
#define SP_UNTAGGED ((UCHAR) ~0)

//
// Set asynchronous events.
//

#define SRBEV_BUS_RESET               0x0001
#define SRBEV_SCSI_ASYNC_NOTIFICATION 0x0002

// begin_ntminitape

#define MAXIMUM_CDB_SIZE 12

//
// SCSI I/O Request Block
//

typedef struct _SCSI_REQUEST_BLOCK {
    USHORT Length;                  // offset 0
    UCHAR Function;                 // offset 2
    UCHAR SrbStatus;                // offset 3
    UCHAR ScsiStatus;               // offset 4
    UCHAR PathId;                   // offset 5
    UCHAR TargetId;                 // offset 6
    UCHAR Lun;                      // offset 7
    UCHAR QueueTag;                 // offset 8
    UCHAR QueueAction;              // offset 9
    UCHAR CdbLength;                // offset a
    UCHAR SenseInfoBufferLength;    // offset b
    ULONG SrbFlags;                 // offset c
    ULONG DataTransferLength;       // offset 10
    ULONG TimeOutValue;             // offset 14
    __field_bcount(DataTransferLength) \
    PVOID DataBuffer;               // offset 18
    PVOID SenseInfoBuffer;          // offset 1c
    struct _SCSI_REQUEST_BLOCK *NextSrb; // offset 20
    PVOID OriginalRequest;          // offset 24
    PVOID SrbExtension;             // offset 28
    union {
        ULONG InternalStatus;       // offset 2c
        ULONG QueueSortKey;         // offset 2c
        ULONG LinkTimeoutValue;     // offset 2c
    };

#if defined(_WIN64)

    //
    // Force PVOID alignment of Cdb
    //

    ULONG Reserved;

#endif

    UCHAR Cdb[16];                  // offset 30
} SCSI_REQUEST_BLOCK, *PSCSI_REQUEST_BLOCK;

#define SCSI_REQUEST_BLOCK_SIZE sizeof(SCSI_REQUEST_BLOCK)

//
// SCSI I/O Request Block for WMI Requests
//

typedef struct _SCSI_WMI_REQUEST_BLOCK {
    USHORT Length;
    UCHAR Function;        // SRB_FUNCTION_WMI
    UCHAR SrbStatus;
    UCHAR WMISubFunction;
    UCHAR PathId;          // If SRB_WMI_FLAGS_ADAPTER_REQUEST is set in
    UCHAR TargetId;        // WMIFlags then PathId, TargetId and Lun are
    UCHAR Lun;             // reserved fields.
    UCHAR Reserved1;
    UCHAR WMIFlags;
    UCHAR Reserved2[2];
    ULONG SrbFlags;
    ULONG DataTransferLength;
    ULONG TimeOutValue;
    PVOID DataBuffer;
    PVOID DataPath;
    PVOID Reserved3;
    PVOID OriginalRequest;
    PVOID SrbExtension;
    ULONG Reserved4;

#if (NTDDI_VERSION >= NTDDI_WS03SP1)
#if defined(_WIN64)

    //
    // Force PVOID alignment of Cdb
    //

    ULONG Reserved6;

#endif
#endif

    UCHAR Reserved5[16];
} SCSI_WMI_REQUEST_BLOCK, *PSCSI_WMI_REQUEST_BLOCK;

typedef enum _STOR_DEVICE_POWER_STATE {
    StorPowerDeviceUnspecified = 0,
    StorPowerDeviceD0,
    StorPowerDeviceD1,
    StorPowerDeviceD2,
    StorPowerDeviceD3,
    StorPowerDeviceMaximum
} STOR_DEVICE_POWER_STATE, *PSTOR_DEVICE_POWER_STATE;

typedef enum {
    StorPowerActionNone = 0,
    StorPowerActionReserved,
    StorPowerActionSleep,
    StorPowerActionHibernate,
    StorPowerActionShutdown,
    StorPowerActionShutdownReset,
    StorPowerActionShutdownOff,
    StorPowerActionWarmEject
} STOR_POWER_ACTION, *PSTOR_POWER_ACTION;

typedef struct _SCSI_POWER_REQUEST_BLOCK {
    USHORT Length;                  // offset 0
    UCHAR Function;                 // offset 2
    UCHAR SrbStatus;                // offset 3
    UCHAR SrbPowerFlags;            // offset 4
    UCHAR PathId;                   // offset 5
    UCHAR TargetId;                 // offset 6
    UCHAR Lun;                      // offset 7
    STOR_DEVICE_POWER_STATE DevicePowerState; // offset 8
    ULONG SrbFlags;                 // offset c
    ULONG DataTransferLength;       // offset 10
    ULONG TimeOutValue;             // offset 14
    PVOID DataBuffer;               // offset 18
    PVOID SenseInfoBuffer;          // offset 1c
    struct _SCSI_REQUEST_BLOCK *NextSrb; // offset 20
    PVOID OriginalRequest;          // offset 24
    PVOID SrbExtension;             // offset 28
    STOR_POWER_ACTION PowerAction;       // offset 2c

#if defined(_WIN64)

    //
    // Force PVOID alignment of Cdb
    //

    ULONG Reserved;

#endif

    UCHAR Reserved5[16];              // offset 30
} SCSI_POWER_REQUEST_BLOCK, *PSCSI_POWER_REQUEST_BLOCK;

//
// PNP minor function codes.
//
typedef enum {
    StorStartDevice = 0x0,
    StorRemoveDevice = 0x2,
    StorStopDevice  = 0x4,
    StorQueryCapabilities = 0x9,
    StorFilterResourceRequirements = 0xB
} STOR_PNP_ACTION, *PSTOR_PNP_ACTION;

typedef struct _STOR_DEVICE_CAPABILITIES {
    USHORT Version;
    ULONG  DeviceD1:1;
    ULONG  DeviceD2:1;
    ULONG  LockSupported:1;
    ULONG  EjectSupported:1;
    ULONG  Removable:1;
    ULONG  DockDevice:1;
    ULONG  UniqueID:1;
    ULONG  SilentInstall:1;
    ULONG  SurpriseRemovalOK:1;
    ULONG  NoDisplayInUI:1;

} STOR_DEVICE_CAPABILITIES, *PSTOR_DEVICE_CAPABILITIES;

typedef struct _SCSI_PNP_REQUEST_BLOCK {
    USHORT Length;                  // offset 0
    UCHAR Function;                 // offset 2
    UCHAR SrbStatus;                // offset 3
    UCHAR PnPSubFunction;           // offset 4
    UCHAR PathId;                   // offset 5
    UCHAR TargetId;                 // offset 6
    UCHAR Lun;                      // offset 7
    STOR_PNP_ACTION PnPAction;       // offset 8
    ULONG SrbFlags;                 // offset c
    ULONG DataTransferLength;       // offset 10
    ULONG TimeOutValue;             // offset 14
    PVOID DataBuffer;               // offset 18
    PVOID SenseInfoBuffer;          // offset 1c
    struct _SCSI_REQUEST_BLOCK *NextSrb; // offset 20
    PVOID OriginalRequest;          // offset 24
    PVOID SrbExtension;             // offset 28
    ULONG SrbPnPFlags;              // offset 2c

#if defined(_WIN64)

    //
    // Force PVOID alignment of Cdb
    //

    ULONG Reserved;

#endif
        UCHAR Reserved4[16];            // offset 30
} SCSI_PNP_REQUEST_BLOCK, *PSCSI_PNP_REQUEST_BLOCK;


//
// SRB Functions
//

#define SRB_FUNCTION_EXECUTE_SCSI           0x00
#define SRB_FUNCTION_CLAIM_DEVICE           0x01
#define SRB_FUNCTION_IO_CONTROL             0x02
#define SRB_FUNCTION_RECEIVE_EVENT          0x03
#define SRB_FUNCTION_RELEASE_QUEUE          0x04
#define SRB_FUNCTION_ATTACH_DEVICE          0x05
#define SRB_FUNCTION_RELEASE_DEVICE         0x06
#define SRB_FUNCTION_SHUTDOWN               0x07
#define SRB_FUNCTION_FLUSH                  0x08
#define SRB_FUNCTION_ABORT_COMMAND          0x10
#define SRB_FUNCTION_RELEASE_RECOVERY       0x11
#define SRB_FUNCTION_RESET_BUS              0x12
#define SRB_FUNCTION_RESET_DEVICE           0x13
#define SRB_FUNCTION_TERMINATE_IO           0x14
#define SRB_FUNCTION_FLUSH_QUEUE            0x15
#define SRB_FUNCTION_REMOVE_DEVICE          0x16
#define SRB_FUNCTION_WMI                    0x17
#define SRB_FUNCTION_LOCK_QUEUE             0x18
#define SRB_FUNCTION_UNLOCK_QUEUE           0x19
#define SRB_FUNCTION_RESET_LOGICAL_UNIT     0x20
#define SRB_FUNCTION_SET_LINK_TIMEOUT       0x21
#define SRB_FUNCTION_LINK_TIMEOUT_OCCURRED  0x22
#define SRB_FUNCTION_LINK_TIMEOUT_COMPLETE  0x23
#define SRB_FUNCTION_POWER                  0x24
#define SRB_FUNCTION_PNP                    0x25
#define SRB_FUNCTION_DUMP_POINTERS          0x26
//
// SRB Status
//

#define SRB_STATUS_PENDING                  0x00
#define SRB_STATUS_SUCCESS                  0x01
#define SRB_STATUS_ABORTED                  0x02
#define SRB_STATUS_ABORT_FAILED             0x03
#define SRB_STATUS_ERROR                    0x04
#define SRB_STATUS_BUSY                     0x05
#define SRB_STATUS_INVALID_REQUEST          0x06
#define SRB_STATUS_INVALID_PATH_ID          0x07
#define SRB_STATUS_NO_DEVICE                0x08
#define SRB_STATUS_TIMEOUT                  0x09
#define SRB_STATUS_SELECTION_TIMEOUT        0x0A
#define SRB_STATUS_COMMAND_TIMEOUT          0x0B
#define SRB_STATUS_MESSAGE_REJECTED         0x0D
#define SRB_STATUS_BUS_RESET                0x0E
#define SRB_STATUS_PARITY_ERROR             0x0F
#define SRB_STATUS_REQUEST_SENSE_FAILED     0x10
#define SRB_STATUS_NO_HBA                   0x11
#define SRB_STATUS_DATA_OVERRUN             0x12
#define SRB_STATUS_UNEXPECTED_BUS_FREE      0x13
#define SRB_STATUS_PHASE_SEQUENCE_FAILURE   0x14
#define SRB_STATUS_BAD_SRB_BLOCK_LENGTH     0x15
#define SRB_STATUS_REQUEST_FLUSHED          0x16
#define SRB_STATUS_INVALID_LUN              0x20
#define SRB_STATUS_INVALID_TARGET_ID        0x21
#define SRB_STATUS_BAD_FUNCTION             0x22
#define SRB_STATUS_ERROR_RECOVERY           0x23
#define SRB_STATUS_NOT_POWERED              0x24
#define SRB_STATUS_LINK_DOWN                0x25

//
// This value is used by the port driver to indicate that a non-scsi-related
// error occured.  Miniports must never return this status.
//

#define SRB_STATUS_INTERNAL_ERROR           0x30

//
// Srb status values 0x38 through 0x3f are reserved for internal port driver
// use.
//



//
// SRB Status Masks
//

#define SRB_STATUS_QUEUE_FROZEN             0x40
#define SRB_STATUS_AUTOSENSE_VALID          0x80

#define SRB_STATUS(Status) (Status & ~(SRB_STATUS_AUTOSENSE_VALID | SRB_STATUS_QUEUE_FROZEN))

//
// SRB Flag Bits
//

#define SRB_FLAGS_QUEUE_ACTION_ENABLE       0x00000002
#define SRB_FLAGS_DISABLE_DISCONNECT        0x00000004
#define SRB_FLAGS_DISABLE_SYNCH_TRANSFER    0x00000008

#define SRB_FLAGS_BYPASS_FROZEN_QUEUE       0x00000010
#define SRB_FLAGS_DISABLE_AUTOSENSE         0x00000020
#define SRB_FLAGS_DATA_IN                   0x00000040
#define SRB_FLAGS_DATA_OUT                  0x00000080
#define SRB_FLAGS_NO_DATA_TRANSFER          0x00000000
#define SRB_FLAGS_UNSPECIFIED_DIRECTION      (SRB_FLAGS_DATA_IN | SRB_FLAGS_DATA_OUT)

#define SRB_FLAGS_NO_QUEUE_FREEZE           0x00000100
#define SRB_FLAGS_ADAPTER_CACHE_ENABLE      0x00000200
#define SRB_FLAGS_FREE_SENSE_BUFFER         0x00000400

#define SRB_FLAGS_IS_ACTIVE                 0x00010000
#define SRB_FLAGS_ALLOCATED_FROM_ZONE       0x00020000
#define SRB_FLAGS_SGLIST_FROM_POOL          0x00040000
#define SRB_FLAGS_BYPASS_LOCKED_QUEUE       0x00080000

#define SRB_FLAGS_NO_KEEP_AWAKE             0x00100000
#define SRB_FLAGS_PORT_DRIVER_ALLOCSENSE    0x00200000

#define SRB_FLAGS_PORT_DRIVER_SENSEHASPORT  0x00400000
#define SRB_FLAGS_DONT_START_NEXT_PACKET    0x00800000

#define SRB_FLAGS_PORT_DRIVER_RESERVED      0x0F000000
#define SRB_FLAGS_CLASS_DRIVER_RESERVED     0xF0000000

#if DBG==1
//
// A signature used to validate the scsi port number
// at the end of a sense buffer.
//
#define SCSI_PORT_SIGNATURE                 0x54524f50
#endif

//
// Queue Action
//

#define SRB_SIMPLE_TAG_REQUEST              0x20
#define SRB_HEAD_OF_QUEUE_TAG_REQUEST       0x21
#define SRB_ORDERED_QUEUE_TAG_REQUEST       0x22

#define SRB_WMI_FLAGS_ADAPTER_REQUEST       0x01
#define SRB_POWER_FLAGS_ADAPTER_REQUEST     0x01
#define SRB_PNP_FLAGS_ADAPTER_REQUEST     0x01

// end_ntminitape


//
// Command Descriptor Block. Passed by SCSI controller chip over the SCSI bus
//

#pragma pack(push, cdb, 1)
typedef union _CDB {

    //
    // Generic 6-Byte CDB
    //

    struct _CDB6GENERIC {
       UCHAR  OperationCode;
       UCHAR  Immediate : 1;
       UCHAR  CommandUniqueBits : 4;
       UCHAR  LogicalUnitNumber : 3;
       UCHAR  CommandUniqueBytes[3];
       UCHAR  Link : 1;
       UCHAR  Flag : 1;
       UCHAR  Reserved : 4;
       UCHAR  VendorUnique : 2;
    } CDB6GENERIC;

    //
    // Standard 6-byte CDB
    //

    struct _CDB6READWRITE {
        UCHAR OperationCode;    // 0x08, 0x0A - SCSIOP_READ, SCSIOP_WRITE
        UCHAR LogicalBlockMsb1 : 5;
        UCHAR LogicalUnitNumber : 3;
        UCHAR LogicalBlockMsb0;
        UCHAR LogicalBlockLsb;
        UCHAR TransferBlocks;
        UCHAR Control;
    } CDB6READWRITE;

    //
    // SCSI-1 Inquiry CDB
    //

    struct _CDB6INQUIRY {
        UCHAR OperationCode;    // 0x12 - SCSIOP_INQUIRY
        UCHAR Reserved1 : 5;
        UCHAR LogicalUnitNumber : 3;
        UCHAR PageCode;
        UCHAR IReserved;
        UCHAR AllocationLength;
        UCHAR Control;
    } CDB6INQUIRY;

    //
    // SCSI-3 Inquiry CDB
    //

    struct _CDB6INQUIRY3 {
        UCHAR OperationCode;    // 0x12 - SCSIOP_INQUIRY
        UCHAR EnableVitalProductData : 1;
        UCHAR CommandSupportData : 1;
        UCHAR Reserved1 : 6;
        UCHAR PageCode;
        UCHAR Reserved2;
        UCHAR AllocationLength;
        UCHAR Control;
    } CDB6INQUIRY3;

    struct _CDB6VERIFY {
        UCHAR OperationCode;    // 0x13 - SCSIOP_VERIFY
        UCHAR Fixed : 1;
        UCHAR ByteCompare : 1;
        UCHAR Immediate : 1;
        UCHAR Reserved : 2;
        UCHAR LogicalUnitNumber : 3;
        UCHAR VerificationLength[3];
        UCHAR Control;
    } CDB6VERIFY;

    //
    // SCSI Format CDB
    //

    struct _CDB6FORMAT {
        UCHAR OperationCode;    // 0x04 - SCSIOP_FORMAT_UNIT
        UCHAR FormatControl : 5;
        UCHAR LogicalUnitNumber : 3;
        UCHAR FReserved1;
        UCHAR InterleaveMsb;
        UCHAR InterleaveLsb;
        UCHAR FReserved2;
    } CDB6FORMAT;

    //
    // Standard 10-byte CDB

    struct _CDB10 {
        UCHAR OperationCode;
        UCHAR RelativeAddress : 1;
        UCHAR Reserved1 : 2;
        UCHAR ForceUnitAccess : 1;
        UCHAR DisablePageOut : 1;
        UCHAR LogicalUnitNumber : 3;
        UCHAR LogicalBlockByte0;
        UCHAR LogicalBlockByte1;
        UCHAR LogicalBlockByte2;
        UCHAR LogicalBlockByte3;
        UCHAR Reserved2;
        UCHAR TransferBlocksMsb;
        UCHAR TransferBlocksLsb;
        UCHAR Control;
    } CDB10;

    //
    // Standard 12-byte CDB
    //

    struct _CDB12 {
        UCHAR OperationCode;
        UCHAR RelativeAddress : 1;
        UCHAR Reserved1 : 2;
        UCHAR ForceUnitAccess : 1;
        UCHAR DisablePageOut : 1;
        UCHAR LogicalUnitNumber : 3;
        UCHAR LogicalBlock[4];
        UCHAR TransferLength[4];
        UCHAR Reserved2;
        UCHAR Control;
    } CDB12;



    //
    // Standard 16-byte CDB
    //

    struct _CDB16 {
        UCHAR OperationCode;
        UCHAR Reserved1        : 3;
        UCHAR ForceUnitAccess  : 1;
        UCHAR DisablePageOut   : 1;
        UCHAR Protection       : 3;
        UCHAR LogicalBlock[8];
        UCHAR TransferLength[4];
        UCHAR Reserved2;
        UCHAR Control;
    } CDB16;


    //
    // CD Rom Audio CDBs
    //

    struct _PAUSE_RESUME {
        UCHAR OperationCode;    // 0x4B - SCSIOP_PAUSE_RESUME
        UCHAR Reserved1 : 5;
        UCHAR LogicalUnitNumber : 3;
        UCHAR Reserved2[6];
        UCHAR Action;
        UCHAR Control;
    } PAUSE_RESUME;

    //
    // Read Table of Contents
    //

    struct _READ_TOC {
        UCHAR OperationCode;    // 0x43 - SCSIOP_READ_TOC
        UCHAR Reserved0 : 1;
        UCHAR Msf : 1;
        UCHAR Reserved1 : 3;
        UCHAR LogicalUnitNumber : 3;
        UCHAR Format2 : 4;
        UCHAR Reserved2 : 4;
        UCHAR Reserved3[3];
        UCHAR StartingTrack;
        UCHAR AllocationLength[2];
        UCHAR Control : 6;
        UCHAR Format : 2;
    } READ_TOC;

    struct _READ_DISK_INFORMATION {
        UCHAR OperationCode;    // 0x51 - SCSIOP_READ_DISC_INFORMATION
        UCHAR Reserved1 : 5;
        UCHAR Lun : 3;
        UCHAR Reserved2[5];
        UCHAR AllocationLength[2];
        UCHAR Control;
    } READ_DISK_INFORMATION, READ_DISC_INFORMATION;

    struct _READ_TRACK_INFORMATION {
        UCHAR OperationCode;    // 0x52 - SCSIOP_READ_TRACK_INFORMATION
        UCHAR Track : 2;
        UCHAR Reserved4 : 3;
        UCHAR Lun : 3;
        UCHAR BlockAddress[4];  // or Track Number
        UCHAR Reserved3;
        UCHAR AllocationLength[2];
        UCHAR Control;
    } READ_TRACK_INFORMATION;

    struct _RESERVE_TRACK_RZONE {
        UCHAR OperationCode;    // 0x53 - SCSIOP_RESERVE_TRACK_RZONE
        UCHAR Reserved1[4];
        UCHAR ReservationSize[4];
        UCHAR Control;
    } RESERVE_TRACK_RZONE;

    struct _SEND_OPC_INFORMATION {
        UCHAR OperationCode;    // 0x54 - SCSIOP_SEND_OPC_INFORMATION
        UCHAR DoOpc    : 1;     // perform OPC
        UCHAR Reserved : 7;
        UCHAR Reserved1[5];
        UCHAR ParameterListLength[2];
        UCHAR Reserved2;
    } SEND_OPC_INFORMATION;

    struct _REPAIR_TRACK {
        UCHAR OperationCode;    // 0x58 - SCSIOP_REPAIR_TRACK
        UCHAR Immediate : 1;
        UCHAR Reserved1 : 7;
        UCHAR Reserved2[2];
        UCHAR TrackNumber[2];
        UCHAR Reserved3[3];
        UCHAR Control;
    } REPAIR_TRACK;

    struct _CLOSE_TRACK {
        UCHAR OperationCode;    // 0x5B - SCSIOP_CLOSE_TRACK_SESSION
        UCHAR Immediate : 1;
        UCHAR Reserved1 : 7;
        UCHAR Track     : 1;
        UCHAR Session   : 1;
        UCHAR Reserved2 : 6;
        UCHAR Reserved3;
        UCHAR TrackNumber[2];
        UCHAR Reserved4[3];
        UCHAR Control;
    } CLOSE_TRACK;

    struct _READ_BUFFER_CAPACITY {
        UCHAR OperationCode;    // 0x5C - SCSIOP_READ_BUFFER_CAPACITY
        UCHAR BlockInfo : 1;
        UCHAR Reserved1 : 7;
        UCHAR Reserved2[5];
        UCHAR AllocationLength[2];
        UCHAR Control;
    } READ_BUFFER_CAPACITY;

    struct _SEND_CUE_SHEET {
        UCHAR OperationCode;    // 0x5D - SCSIOP_SEND_CUE_SHEET
        UCHAR Reserved[5];
        UCHAR CueSheetSize[3];
        UCHAR Control;
    } SEND_CUE_SHEET;

    struct _READ_HEADER {
        UCHAR OperationCode;    // 0x44 - SCSIOP_READ_HEADER
        UCHAR Reserved1 : 1;
        UCHAR Msf : 1;
        UCHAR Reserved2 : 3;
        UCHAR Lun : 3;
        UCHAR LogicalBlockAddress[4];
        UCHAR Reserved3;
        UCHAR AllocationLength[2];
        UCHAR Control;
    } READ_HEADER;

    struct _PLAY_AUDIO {
        UCHAR OperationCode;    // 0x45 - SCSIOP_PLAY_AUDIO
        UCHAR Reserved1 : 5;
        UCHAR LogicalUnitNumber : 3;
        UCHAR StartingBlockAddress[4];
        UCHAR Reserved2;
        UCHAR PlayLength[2];
        UCHAR Control;
    } PLAY_AUDIO;

    struct _PLAY_AUDIO_MSF {
        UCHAR OperationCode;    // 0x47 - SCSIOP_PLAY_AUDIO_MSF
        UCHAR Reserved1 : 5;
        UCHAR LogicalUnitNumber : 3;
        UCHAR Reserved2;
        UCHAR StartingM;
        UCHAR StartingS;
        UCHAR StartingF;
        UCHAR EndingM;
        UCHAR EndingS;
        UCHAR EndingF;
        UCHAR Control;
    } PLAY_AUDIO_MSF;

    struct _BLANK_MEDIA {
        UCHAR OperationCode;    // 0xA1 - SCSIOP_BLANK
        UCHAR BlankType : 3;
        UCHAR Reserved1 : 1;
        UCHAR Immediate : 1;
        UCHAR Reserved2 : 3;
        UCHAR AddressOrTrack[4];
        UCHAR Reserved3[5];
        UCHAR Control;
    } BLANK_MEDIA;

    struct _PLAY_CD {
        UCHAR OperationCode;    // 0xBC - SCSIOP_PLAY_CD
        UCHAR Reserved1 : 1;
        UCHAR CMSF : 1;         // LBA = 0, MSF = 1
        UCHAR ExpectedSectorType : 3;
        UCHAR Lun : 3;

        union {
            struct _LBA {
                UCHAR StartingBlockAddress[4];
                UCHAR PlayLength[4];
            } LBA;

            struct _MSF {
                UCHAR Reserved1;
                UCHAR StartingM;
                UCHAR StartingS;
                UCHAR StartingF;
                UCHAR EndingM;
                UCHAR EndingS;
                UCHAR EndingF;
                UCHAR Reserved2;
            } MSF;
        };

        UCHAR Audio : 1;
        UCHAR Composite : 1;
        UCHAR Port1 : 1;
        UCHAR Port2 : 1;
        UCHAR Reserved2 : 3;
        UCHAR Speed : 1;
        UCHAR Control;
    } PLAY_CD;

    struct _SCAN_CD {
        UCHAR OperationCode;    // 0xBA - SCSIOP_SCAN_CD
        UCHAR RelativeAddress : 1;
        UCHAR Reserved1 : 3;
        UCHAR Direct : 1;
        UCHAR Lun : 3;
        UCHAR StartingAddress[4];
        UCHAR Reserved2[3];
        UCHAR Reserved3 : 6;
        UCHAR Type : 2;
        UCHAR Reserved4;
        UCHAR Control;
    } SCAN_CD;

    struct _STOP_PLAY_SCAN {
        UCHAR OperationCode;    // 0x4E - SCSIOP_STOP_PLAY_SCAN
        UCHAR Reserved1 : 5;
        UCHAR Lun : 3;
        UCHAR Reserved2[7];
        UCHAR Control;
    } STOP_PLAY_SCAN;


    //
    // Read SubChannel Data
    //

    struct _SUBCHANNEL {
        UCHAR OperationCode;    // 0x42 - SCSIOP_READ_SUB_CHANNEL
        UCHAR Reserved0 : 1;
        UCHAR Msf : 1;
        UCHAR Reserved1 : 3;
        UCHAR LogicalUnitNumber : 3;
        UCHAR Reserved2 : 6;
        UCHAR SubQ : 1;
        UCHAR Reserved3 : 1;
        UCHAR Format;
        UCHAR Reserved4[2];
        UCHAR TrackNumber;
        UCHAR AllocationLength[2];
        UCHAR Control;
    } SUBCHANNEL;

    //
    // Read CD. Used by Atapi for raw sector reads.
    //

    struct _READ_CD {
        UCHAR OperationCode;    // 0xBE - SCSIOP_READ_CD
        UCHAR RelativeAddress : 1;
        UCHAR Reserved0 : 1;
        UCHAR ExpectedSectorType : 3;
        UCHAR Lun : 3;
        UCHAR StartingLBA[4];
        UCHAR TransferBlocks[3];
        UCHAR Reserved2 : 1;
        UCHAR ErrorFlags : 2;
        UCHAR IncludeEDC : 1;
        UCHAR IncludeUserData : 1;
        UCHAR HeaderCode : 2;
        UCHAR IncludeSyncData : 1;
        UCHAR SubChannelSelection : 3;
        UCHAR Reserved3 : 5;
        UCHAR Control;
    } READ_CD;

    struct _READ_CD_MSF {
        UCHAR OperationCode;    // 0xB9 - SCSIOP_READ_CD_MSF
        UCHAR RelativeAddress : 1;
        UCHAR Reserved1 : 1;
        UCHAR ExpectedSectorType : 3;
        UCHAR Lun : 3;
        UCHAR Reserved2;
        UCHAR StartingM;
        UCHAR StartingS;
        UCHAR StartingF;
        UCHAR EndingM;
        UCHAR EndingS;
        UCHAR EndingF;
        UCHAR Reserved4 : 1;
        UCHAR ErrorFlags : 2;
        UCHAR IncludeEDC : 1;
        UCHAR IncludeUserData : 1;
        UCHAR HeaderCode : 2;
        UCHAR IncludeSyncData : 1;
        UCHAR SubChannelSelection : 3;
        UCHAR Reserved5 : 5;
        UCHAR Control;
    } READ_CD_MSF;

    //
    // Plextor Read CD-DA
    //

    struct _PLXTR_READ_CDDA {
        UCHAR OperationCode;    // Unknown -- vendor-unique?
        UCHAR Reserved0 : 5;
        UCHAR LogicalUnitNumber :3;
        UCHAR LogicalBlockByte0;
        UCHAR LogicalBlockByte1;
        UCHAR LogicalBlockByte2;
        UCHAR LogicalBlockByte3;
        UCHAR TransferBlockByte0;
        UCHAR TransferBlockByte1;
        UCHAR TransferBlockByte2;
        UCHAR TransferBlockByte3;
        UCHAR SubCode;
        UCHAR Control;
    } PLXTR_READ_CDDA;

    //
    // NEC Read CD-DA
    //

    struct _NEC_READ_CDDA {
        UCHAR OperationCode;    // Unknown -- vendor-unique?
        UCHAR Reserved0;
        UCHAR LogicalBlockByte0;
        UCHAR LogicalBlockByte1;
        UCHAR LogicalBlockByte2;
        UCHAR LogicalBlockByte3;
        UCHAR Reserved1;
        UCHAR TransferBlockByte0;
        UCHAR TransferBlockByte1;
        UCHAR Control;
    } NEC_READ_CDDA;

    //
    // Mode sense
    //

    struct _MODE_SENSE {
        UCHAR OperationCode;    // 0x1A - SCSIOP_MODE_SENSE
        UCHAR Reserved1 : 3;
        UCHAR Dbd : 1;
        UCHAR Reserved2 : 1;
        UCHAR LogicalUnitNumber : 3;
        UCHAR PageCode : 6;
        UCHAR Pc : 2;
        UCHAR Reserved3;
        UCHAR AllocationLength;
        UCHAR Control;
    } MODE_SENSE;

    struct _MODE_SENSE10 {
        UCHAR OperationCode;    // 0x5A - SCSIOP_MODE_SENSE10
        UCHAR Reserved1 : 3;
        UCHAR Dbd : 1;
        UCHAR Reserved2 : 1;
        UCHAR LogicalUnitNumber : 3;
        UCHAR PageCode : 6;
        UCHAR Pc : 2;
        UCHAR Reserved3[4];
        UCHAR AllocationLength[2];
        UCHAR Control;
    } MODE_SENSE10;

    //
    // Mode select
    //

    struct _MODE_SELECT {
        UCHAR OperationCode;    // 0x15 - SCSIOP_MODE_SELECT
        UCHAR SPBit : 1;
        UCHAR Reserved1 : 3;
        UCHAR PFBit : 1;
        UCHAR LogicalUnitNumber : 3;
        UCHAR Reserved2[2];
        UCHAR ParameterListLength;
        UCHAR Control;
    } MODE_SELECT;

    struct _MODE_SELECT10 {
        UCHAR OperationCode;    // 0x55 - SCSIOP_MODE_SELECT10
        UCHAR SPBit : 1;
        UCHAR Reserved1 : 3;
        UCHAR PFBit : 1;
        UCHAR LogicalUnitNumber : 3;
        UCHAR Reserved2[5];
        UCHAR ParameterListLength[2];
        UCHAR Control;
    } MODE_SELECT10;

    struct _LOCATE {
        UCHAR OperationCode;    // 0x2B - SCSIOP_LOCATE
        UCHAR Immediate : 1;
        UCHAR CPBit : 1;
        UCHAR BTBit : 1;
        UCHAR Reserved1 : 2;
        UCHAR LogicalUnitNumber : 3;
        UCHAR Reserved3;
        UCHAR LogicalBlockAddress[4];
        UCHAR Reserved4;
        UCHAR Partition;
        UCHAR Control;
    } LOCATE;

    struct _LOGSENSE {
        UCHAR OperationCode;    // 0x4D - SCSIOP_LOG_SENSE
        UCHAR SPBit : 1;
        UCHAR PPCBit : 1;
        UCHAR Reserved1 : 3;
        UCHAR LogicalUnitNumber : 3;
        UCHAR PageCode : 6;
        UCHAR PCBit : 2;
        UCHAR Reserved2;
        UCHAR Reserved3;
        UCHAR ParameterPointer[2];
        UCHAR AllocationLength[2];
        UCHAR Control;
    } LOGSENSE;

    struct _LOGSELECT {
        UCHAR OperationCode;    // 0x4C - SCSIOP_LOG_SELECT
        UCHAR SPBit : 1;
        UCHAR PCRBit : 1;
        UCHAR Reserved1 : 3;
        UCHAR LogicalUnitNumber : 3;
        UCHAR Reserved : 6;
        UCHAR PCBit : 2;
        UCHAR Reserved2[4];
        UCHAR ParameterListLength[2];
        UCHAR Control;
    } LOGSELECT;

    struct _PRINT {
        UCHAR OperationCode;    // 0x0A - SCSIOP_PRINT
        UCHAR Reserved : 5;
        UCHAR LogicalUnitNumber : 3;
        UCHAR TransferLength[3];
        UCHAR Control;
    } PRINT;

    struct _SEEK {
        UCHAR OperationCode;    // 0x2B - SCSIOP_SEEK
        UCHAR Reserved1 : 5;
        UCHAR LogicalUnitNumber : 3;
        UCHAR LogicalBlockAddress[4];
        UCHAR Reserved2[3];
        UCHAR Control;
    } SEEK;

    struct _ERASE {
        UCHAR OperationCode;    // 0x19 - SCSIOP_ERASE
        UCHAR Long : 1;
        UCHAR Immediate : 1;
        UCHAR Reserved1 : 3;
        UCHAR LogicalUnitNumber : 3;
        UCHAR Reserved2[3];
        UCHAR Control;
    } ERASE;

    struct _START_STOP {
        UCHAR OperationCode;    // 0x1B - SCSIOP_START_STOP_UNIT
        UCHAR Immediate: 1;
        UCHAR Reserved1 : 4;
        UCHAR LogicalUnitNumber : 3;
        UCHAR Reserved2[2];
        UCHAR Start : 1;
        UCHAR LoadEject : 1;
        UCHAR Reserved3 : 6;
        UCHAR Control;
    } START_STOP;

    struct _MEDIA_REMOVAL {
        UCHAR OperationCode;    // 0x1E - SCSIOP_MEDIUM_REMOVAL
        UCHAR Reserved1 : 5;
        UCHAR LogicalUnitNumber : 3;
        UCHAR Reserved2[2];

        UCHAR Prevent : 1;
        UCHAR Persistant : 1;
        UCHAR Reserved3 : 6;

        UCHAR Control;
    } MEDIA_REMOVAL;

    //
    // Tape CDBs
    //

    struct _SEEK_BLOCK {
        UCHAR OperationCode;    // 0x0C - SCSIOP_SEEK_BLOCK
        UCHAR Immediate : 1;
        UCHAR Reserved1 : 7;
        UCHAR BlockAddress[3];
        UCHAR Link : 1;
        UCHAR Flag : 1;
        UCHAR Reserved2 : 4;
        UCHAR VendorUnique : 2;
    } SEEK_BLOCK;

    struct _REQUEST_BLOCK_ADDRESS {
        UCHAR OperationCode;    // 0x02 - SCSIOP_REQUEST_BLOCK_ADDR
        UCHAR Reserved1[3];
        UCHAR AllocationLength;
        UCHAR Link : 1;
        UCHAR Flag : 1;
        UCHAR Reserved2 : 4;
        UCHAR VendorUnique : 2;
    } REQUEST_BLOCK_ADDRESS;

    struct _PARTITION {
        UCHAR OperationCode;    // 0x0D - SCSIOP_PARTITION
        UCHAR Immediate : 1;
        UCHAR Sel: 1;
        UCHAR PartitionSelect : 6;
        UCHAR Reserved1[3];
        UCHAR Control;
    } PARTITION;

    struct _WRITE_TAPE_MARKS {
        UCHAR OperationCode;    // Unknown -- vendor-unique?
        UCHAR Immediate : 1;
        UCHAR WriteSetMarks: 1;
        UCHAR Reserved : 3;
        UCHAR LogicalUnitNumber : 3;
        UCHAR TransferLength[3];
        UCHAR Control;
    } WRITE_TAPE_MARKS;

    struct _SPACE_TAPE_MARKS {
        UCHAR OperationCode;    // Unknown -- vendor-unique?
        UCHAR Code : 3;
        UCHAR Reserved : 2;
        UCHAR LogicalUnitNumber : 3;
        UCHAR NumMarksMSB ;
        UCHAR NumMarks;
        UCHAR NumMarksLSB;
        union {
            UCHAR value;
            struct {
                UCHAR Link : 1;
                UCHAR Flag : 1;
                UCHAR Reserved : 4;
                UCHAR VendorUnique : 2;
            } Fields;
        } Byte6;
    } SPACE_TAPE_MARKS;

    //
    // Read tape position
    //

    struct _READ_POSITION {
        UCHAR Operation;        // 0x43 - SCSIOP_READ_POSITION
        UCHAR BlockType:1;
        UCHAR Reserved1:4;
        UCHAR Lun:3;
        UCHAR Reserved2[7];
        UCHAR Control;
    } READ_POSITION;

    //
    // ReadWrite for Tape
    //

    struct _CDB6READWRITETAPE {
        UCHAR OperationCode;    // Unknown -- vendor-unique?
        UCHAR VendorSpecific : 5;
        UCHAR Reserved : 3;
        UCHAR TransferLenMSB;
        UCHAR TransferLen;
        UCHAR TransferLenLSB;
        UCHAR Link : 1;
        UCHAR Flag : 1;
        UCHAR Reserved1 : 4;
        UCHAR VendorUnique : 2;
    } CDB6READWRITETAPE;

    //
    // Medium changer CDB's
    //

    struct _INIT_ELEMENT_STATUS {
        UCHAR OperationCode;    // 0x07 - SCSIOP_INIT_ELEMENT_STATUS
        UCHAR Reserved1 : 5;
        UCHAR LogicalUnitNubmer : 3;
        UCHAR Reserved2[3];
        UCHAR Reserved3 : 7;
        UCHAR NoBarCode : 1;
    } INIT_ELEMENT_STATUS;

    struct _INITIALIZE_ELEMENT_RANGE {
        UCHAR OperationCode;    // 0xE7 - SCSIOP_INIT_ELEMENT_RANGE
        UCHAR Range : 1;
        UCHAR Reserved1 : 4;
        UCHAR LogicalUnitNubmer : 3;
        UCHAR FirstElementAddress[2];
        UCHAR Reserved2[2];
        UCHAR NumberOfElements[2];
        UCHAR Reserved3;
        UCHAR Reserved4 : 7;
        UCHAR NoBarCode : 1;
    } INITIALIZE_ELEMENT_RANGE;

    struct _POSITION_TO_ELEMENT {
        UCHAR OperationCode;    // 0x2B - SCSIOP_POSITION_TO_ELEMENT
        UCHAR Reserved1 : 5;
        UCHAR LogicalUnitNumber : 3;
        UCHAR TransportElementAddress[2];
        UCHAR DestinationElementAddress[2];
        UCHAR Reserved2[2];
        UCHAR Flip : 1;
        UCHAR Reserved3 : 7;
        UCHAR Control;
    } POSITION_TO_ELEMENT;

    struct _MOVE_MEDIUM {
        UCHAR OperationCode;    // 0xA5 - SCSIOP_MOVE_MEDIUM
        UCHAR Reserved1 : 5;
        UCHAR LogicalUnitNumber : 3;
        UCHAR TransportElementAddress[2];
        UCHAR SourceElementAddress[2];
        UCHAR DestinationElementAddress[2];
        UCHAR Reserved2[2];
        UCHAR Flip : 1;
        UCHAR Reserved3 : 7;
        UCHAR Control;
    } MOVE_MEDIUM;

    struct _EXCHANGE_MEDIUM {
        UCHAR OperationCode;    // 0xA6 - SCSIOP_EXCHANGE_MEDIUM
        UCHAR Reserved1 : 5;
        UCHAR LogicalUnitNumber : 3;
        UCHAR TransportElementAddress[2];
        UCHAR SourceElementAddress[2];
        UCHAR Destination1ElementAddress[2];
        UCHAR Destination2ElementAddress[2];
        UCHAR Flip1 : 1;
        UCHAR Flip2 : 1;
        UCHAR Reserved3 : 6;
        UCHAR Control;
    } EXCHANGE_MEDIUM;

    struct _READ_ELEMENT_STATUS {
        UCHAR OperationCode;    // 0xB8 - SCSIOP_READ_ELEMENT_STATUS
        UCHAR ElementType : 4;
        UCHAR VolTag : 1;
        UCHAR LogicalUnitNumber : 3;
        UCHAR StartingElementAddress[2];
        UCHAR NumberOfElements[2];
        UCHAR Reserved1;
        UCHAR AllocationLength[3];
        UCHAR Reserved2;
        UCHAR Control;
    } READ_ELEMENT_STATUS;

    struct _SEND_VOLUME_TAG {
        UCHAR OperationCode;    // 0xB6 - SCSIOP_SEND_VOLUME_TAG
        UCHAR ElementType : 4;
        UCHAR Reserved1 : 1;
        UCHAR LogicalUnitNumber : 3;
        UCHAR StartingElementAddress[2];
        UCHAR Reserved2;
        UCHAR ActionCode : 5;
        UCHAR Reserved3 : 3;
        UCHAR Reserved4[2];
        UCHAR ParameterListLength[2];
        UCHAR Reserved5;
        UCHAR Control;
    } SEND_VOLUME_TAG;

    struct _REQUEST_VOLUME_ELEMENT_ADDRESS {
        UCHAR OperationCode;    // Unknown -- vendor-unique?
        UCHAR ElementType : 4;
        UCHAR VolTag : 1;
        UCHAR LogicalUnitNumber : 3;
        UCHAR StartingElementAddress[2];
        UCHAR NumberElements[2];
        UCHAR Reserved1;
        UCHAR AllocationLength[3];
        UCHAR Reserved2;
        UCHAR Control;
    } REQUEST_VOLUME_ELEMENT_ADDRESS;

    //
    // Atapi 2.5 Changer 12-byte CDBs
    //

    struct _LOAD_UNLOAD {
        UCHAR OperationCode;    // 0xA6 - SCSIOP_LOAD_UNLOAD_SLOT
        UCHAR Immediate : 1;
        UCHAR Reserved1 : 4;
        UCHAR Lun : 3;
        UCHAR Reserved2[2];
        UCHAR Start : 1;
        UCHAR LoadEject : 1;
        UCHAR Reserved3: 6;
        UCHAR Reserved4[3];
        UCHAR Slot;
        UCHAR Reserved5[3];
    } LOAD_UNLOAD;

    struct _MECH_STATUS {
        UCHAR OperationCode;    // 0xBD - SCSIOP_MECHANISM_STATUS
        UCHAR Reserved : 5;
        UCHAR Lun : 3;
        UCHAR Reserved1[6];
        UCHAR AllocationLength[2];
        UCHAR Reserved2[1];
        UCHAR Control;
    } MECH_STATUS;

    //
    // C/DVD 0.9 CDBs
    //

    struct _SYNCHRONIZE_CACHE10 {

        UCHAR OperationCode;    // 0x35 - SCSIOP_SYNCHRONIZE_CACHE

        UCHAR RelAddr : 1;
        UCHAR Immediate : 1;
        UCHAR Reserved : 3;
        UCHAR Lun : 3;

        UCHAR LogicalBlockAddress[4];   // Unused - set to zero
        UCHAR Reserved2;
        UCHAR BlockCount[2];            // Unused - set to zero
        UCHAR Control;
    } SYNCHRONIZE_CACHE10;

    struct _GET_EVENT_STATUS_NOTIFICATION {
        UCHAR OperationCode;    // 0x4A - SCSIOP_GET_EVENT_STATUS_NOTIFICATION

        UCHAR Immediate : 1;
        UCHAR Reserved : 4;
        UCHAR Lun : 3;

        UCHAR Reserved2[2];
        UCHAR NotificationClassRequest;
        UCHAR Reserved3[2];
        UCHAR EventListLength[2];

        UCHAR Control;
    } GET_EVENT_STATUS_NOTIFICATION;

    struct _GET_PERFORMANCE {
        UCHAR OperationCode;    // 0xAC - SCSIOP_GET_PERFORMANCE
        UCHAR Except    : 2;
        UCHAR Write     : 1;
        UCHAR Tolerance : 2;
        UCHAR Reserved0 : 3;
        UCHAR StartingLBA[4];
        UCHAR Reserved1[2];
        UCHAR MaximumNumberOfDescriptors[2];
        UCHAR Type;
        UCHAR Control;
    } GET_PERFORMANCE;

    struct _READ_DVD_STRUCTURE {
        UCHAR OperationCode;    // 0xAD - SCSIOP_READ_DVD_STRUCTURE
        UCHAR Reserved1 : 5;
        UCHAR Lun : 3;
        UCHAR RMDBlockNumber[4];
        UCHAR LayerNumber;
        UCHAR Format;
        UCHAR AllocationLength[2];
        UCHAR Reserved3 : 6;
        UCHAR AGID : 2;
        UCHAR Control;
    } READ_DVD_STRUCTURE;

    struct _SET_STREAMING {
        UCHAR OperationCode;    // 0xB6 - SCSIOP_SET_STREAMING
        UCHAR Reserved[8];
        UCHAR ParameterListLength[2];
        UCHAR Control;
    } SET_STREAMING;

    struct _SEND_DVD_STRUCTURE {
        UCHAR OperationCode;    // 0xBF - SCSIOP_SEND_DVD_STRUCTURE
        UCHAR Reserved1 : 5;
        UCHAR Lun : 3;
        UCHAR Reserved2[5];
        UCHAR Format;
        UCHAR ParameterListLength[2];
        UCHAR Reserved3;
        UCHAR Control;
    } SEND_DVD_STRUCTURE;

    struct _SEND_KEY {
        UCHAR OperationCode;    // 0xA3 - SCSIOP_SEND_KEY
        UCHAR Reserved1 : 5;
        UCHAR Lun : 3;
        UCHAR Reserved2[6];
        UCHAR ParameterListLength[2];
        UCHAR KeyFormat : 6;
        UCHAR AGID : 2;
        UCHAR Control;
    } SEND_KEY;

    struct _REPORT_KEY {
        UCHAR OperationCode;    // 0xA4 - SCSIOP_REPORT_KEY
        UCHAR Reserved1 : 5;
        UCHAR Lun : 3;
        UCHAR LogicalBlockAddress[4];   // for title key
        UCHAR Reserved2[2];
        UCHAR AllocationLength[2];
        UCHAR KeyFormat : 6;
        UCHAR AGID : 2;
        UCHAR Control;
    } REPORT_KEY;

    struct _SET_READ_AHEAD {
        UCHAR OperationCode;    // 0xA7 - SCSIOP_SET_READ_AHEAD
        UCHAR Reserved1 : 5;
        UCHAR Lun : 3;
        UCHAR TriggerLBA[4];
        UCHAR ReadAheadLBA[4];
        UCHAR Reserved2;
        UCHAR Control;
    } SET_READ_AHEAD;

    struct _READ_FORMATTED_CAPACITIES {
        UCHAR OperationCode;    // 0x23 - SCSIOP_READ_FORMATTED_CAPACITY
        UCHAR Reserved1 : 5;
        UCHAR Lun : 3;
        UCHAR Reserved2[5];
        UCHAR AllocationLength[2];
        UCHAR Control;
    } READ_FORMATTED_CAPACITIES;

    //
    // SCSI-3
    //

    struct _REPORT_LUNS {
        UCHAR OperationCode;    // 0xA0 - SCSIOP_REPORT_LUNS
        UCHAR Reserved1[5];
        UCHAR AllocationLength[4];
        UCHAR Reserved2[1];
        UCHAR Control;
    } REPORT_LUNS;

    struct _PERSISTENT_RESERVE_IN {
        UCHAR OperationCode;    // 0x5E - SCSIOP_PERSISTENT_RESERVE_IN
        UCHAR ServiceAction : 5;
        UCHAR Reserved1 : 3;
        UCHAR Reserved2[5];
        UCHAR AllocationLength[2];
        UCHAR Control;
    } PERSISTENT_RESERVE_IN;

    struct _PERSISTENT_RESERVE_OUT {
        UCHAR OperationCode;    // 0x5F - SCSIOP_PERSISTENT_RESERVE_OUT
        UCHAR ServiceAction : 5;
        UCHAR Reserved1 : 3;
        UCHAR Type : 4;
        UCHAR Scope : 4;
        UCHAR Reserved2[4];
        UCHAR ParameterListLength[2]; // 0x18
        UCHAR Control;
    } PERSISTENT_RESERVE_OUT;

    //
    // MMC / SFF-8090 commands
    //

    struct _GET_CONFIGURATION {
        UCHAR OperationCode;       // 0x46 - SCSIOP_GET_CONFIGURATION
        UCHAR RequestType : 2;     // SCSI_GET_CONFIGURATION_REQUEST_TYPE_*
        UCHAR Reserved1   : 6;     // includes obsolete LUN field
        UCHAR StartingFeature[2];
        UCHAR Reserved2[3];
        UCHAR AllocationLength[2];
        UCHAR Control;
    } GET_CONFIGURATION;

    struct _SET_CD_SPEED {
        UCHAR OperationCode;       // 0xB8 - SCSIOP_SET_CD_SPEED
        union {
            UCHAR Reserved1;
            struct {
                UCHAR RotationControl : 2;
                UCHAR Reserved3       : 6;
            };
        };
        UCHAR ReadSpeed[2];        // 1x == (75 * 2352)
        UCHAR WriteSpeed[2];       // 1x == (75 * 2352)
        UCHAR Reserved2[5];
        UCHAR Control;
    } SET_CD_SPEED;

    struct _READ12 {
        UCHAR OperationCode;      // 0xA8 - SCSIOP_READ12
        UCHAR RelativeAddress   : 1;
        UCHAR Reserved1         : 2;
        UCHAR ForceUnitAccess   : 1;
        UCHAR DisablePageOut    : 1;
        UCHAR LogicalUnitNumber : 3;
        UCHAR LogicalBlock[4];
        UCHAR TransferLength[4];
        UCHAR Reserved2 : 7;
        UCHAR Streaming : 1;
        UCHAR Control;
    } READ12;

    struct _WRITE12 {
        UCHAR OperationCode;      // 0xAA - SCSIOP_WRITE12
        UCHAR RelativeAddress   : 1;
        UCHAR Reserved1         : 1;
        UCHAR EBP               : 1;
        UCHAR ForceUnitAccess   : 1;
        UCHAR DisablePageOut    : 1;
        UCHAR LogicalUnitNumber : 3;
        UCHAR LogicalBlock[4];
        UCHAR TransferLength[4];
        UCHAR Reserved2 : 7;
        UCHAR Streaming : 1;
        UCHAR Control;
    } WRITE12;

    //
    // 16-byte CDBs
    //

    struct _READ16 {
        UCHAR OperationCode;      // 0x88 - SCSIOP_READ16
        UCHAR Reserved1         : 3;
        UCHAR ForceUnitAccess   : 1;
        UCHAR DisablePageOut    : 1;
        UCHAR ReadProtect       : 3;
        UCHAR LogicalBlock[8];
        UCHAR TransferLength[4];
        UCHAR Reserved2         : 7;
        UCHAR Streaming         : 1;
        UCHAR Control;
    } READ16;

    struct _WRITE16 {
        UCHAR OperationCode;      // 0x8A - SCSIOP_WRITE16
        UCHAR Reserved1         : 3;
        UCHAR ForceUnitAccess   : 1;
        UCHAR DisablePageOut    : 1;
        UCHAR WriteProtect      : 3;
        UCHAR LogicalBlock[8];
        UCHAR TransferLength[4];
        UCHAR Reserved2         : 7;
        UCHAR Streaming         : 1;
        UCHAR Control;
    } WRITE16;

    struct _VERIFY16 {
        UCHAR OperationCode;      // 0x8F - SCSIOP_VERIFY16
        UCHAR Reserved1         : 1;
        UCHAR ByteCheck         : 1;
        UCHAR BlockVerify       : 1;
        UCHAR Reserved2         : 1;
        UCHAR DisablePageOut    : 1;
        UCHAR VerifyProtect     : 3;
        UCHAR LogicalBlock[8];
        UCHAR VerificationLength[4];
        UCHAR Reserved3         : 7;
        UCHAR Streaming         : 1;
        UCHAR Control;
    } VERIFY16;

    struct _SYNCHRONIZE_CACHE16 {
        UCHAR OperationCode;      // 0x91 - SCSIOP_SYNCHRONIZE_CACHE16
        UCHAR Reserved1         : 1;
        UCHAR Immediate         : 1;
        UCHAR Reserved2         : 6;
        UCHAR LogicalBlock[8];
        UCHAR BlockCount[4];
        UCHAR Reserved3;
        UCHAR Control;
    } SYNCHRONIZE_CACHE16;

    struct _READ_CAPACITY16 {
        UCHAR OperationCode;      // 0x9E - SCSIOP_READ_CAPACITY16
        UCHAR ServiceAction     : 5;
        UCHAR Reserved1         : 3;
        UCHAR LogicalBlock[8];
        UCHAR BlockCount[4];
        UCHAR PMI               : 1;
        UCHAR Reserved2         : 7;
        UCHAR Control;
    } READ_CAPACITY16;

    ULONG AsUlong[4];
    UCHAR AsByte[16];

} CDB, *PCDB;
#pragma pack(pop, cdb)

////////////////////////////////////////////////////////////////////////////////
//
// GET_EVENT_STATUS_NOTIFICATION
//


#define NOTIFICATION_OPERATIONAL_CHANGE_CLASS_MASK  0x02
#define NOTIFICATION_POWER_MANAGEMENT_CLASS_MASK    0x04
#define NOTIFICATION_EXTERNAL_REQUEST_CLASS_MASK    0x08
#define NOTIFICATION_MEDIA_STATUS_CLASS_MASK        0x10
#define NOTIFICATION_MULTI_HOST_CLASS_MASK          0x20
#define NOTIFICATION_DEVICE_BUSY_CLASS_MASK         0x40


#define NOTIFICATION_NO_CLASS_EVENTS                  0x0
#define NOTIFICATION_OPERATIONAL_CHANGE_CLASS_EVENTS  0x1
#define NOTIFICATION_POWER_MANAGEMENT_CLASS_EVENTS    0x2
#define NOTIFICATION_EXTERNAL_REQUEST_CLASS_EVENTS    0x3
#define NOTIFICATION_MEDIA_STATUS_CLASS_EVENTS        0x4
#define NOTIFICATION_MULTI_HOST_CLASS_EVENTS          0x5
#define NOTIFICATION_DEVICE_BUSY_CLASS_EVENTS         0x6

#pragma pack(push, not_header, 1)
typedef struct _NOTIFICATION_EVENT_STATUS_HEADER {
    UCHAR EventDataLength[2];

    UCHAR NotificationClass : 3;
    UCHAR Reserved : 4;
    UCHAR NEA : 1;

    UCHAR SupportedEventClasses;
#if !defined(__midl)
    UCHAR ClassEventData[0];
#endif
} NOTIFICATION_EVENT_STATUS_HEADER, *PNOTIFICATION_EVENT_STATUS_HEADER;
#pragma pack(pop, not_header)

#define NOTIFICATION_OPERATIONAL_EVENT_NO_CHANGE         0x0
#define NOTIFICATION_OPERATIONAL_EVENT_CHANGE_REQUESTED  0x1
#define NOTIFICATION_OPERATIONAL_EVENT_CHANGE_OCCURRED   0x2

#define NOTIFICATION_OPERATIONAL_STATUS_AVAILABLE        0x0
#define NOTIFICATION_OPERATIONAL_STATUS_TEMPORARY_BUSY   0x1
#define NOTIFICATION_OPERATIONAL_STATUS_EXTENDED_BUSY    0x2

#define NOTIFICATION_OPERATIONAL_OPCODE_NONE             0x0
#define NOTIFICATION_OPERATIONAL_OPCODE_FEATURE_CHANGE   0x1
#define NOTIFICATION_OPERATIONAL_OPCODE_FEATURE_ADDED    0x2
#define NOTIFICATION_OPERATIONAL_OPCODE_UNIT_RESET       0x3
#define NOTIFICATION_OPERATIONAL_OPCODE_FIRMWARE_CHANGED 0x4
#define NOTIFICATION_OPERATIONAL_OPCODE_INQUIRY_CHANGED  0x5

//
// Class event data may be one (or none) of the following:
//

#pragma pack(push, not_op, 1)
typedef struct _NOTIFICATION_OPERATIONAL_STATUS { // event class == 0x1
    UCHAR OperationalEvent : 4;
    UCHAR Reserved1 : 4;
    UCHAR OperationalStatus : 4;
    UCHAR Reserved2 : 3;
    UCHAR PersistentPrevented : 1;
    UCHAR Operation[2];
} NOTIFICATION_OPERATIONAL_STATUS, *PNOTIFICATION_OPERATIONAL_STATUS;
#pragma pack(pop, not_op)


#define NOTIFICATION_POWER_EVENT_NO_CHANGE          0x0
#define NOTIFICATION_POWER_EVENT_CHANGE_SUCCEEDED   0x1
#define NOTIFICATION_POWER_EVENT_CHANGE_FAILED      0x2

#define NOTIFICATION_POWER_STATUS_ACTIVE            0x1
#define NOTIFICATION_POWER_STATUS_IDLE              0x2
#define NOTIFICATION_POWER_STATUS_STANDBY           0x3
#define NOTIFICATION_POWER_STATUS_SLEEP             0x4

#pragma pack(push, not_power, 1)
typedef struct _NOTIFICATION_POWER_STATUS { // event class == 0x2
    UCHAR PowerEvent : 4;
    UCHAR Reserved : 4;
    UCHAR PowerStatus;
    UCHAR Reserved2[2];
} NOTIFICATION_POWER_STATUS, *PNOTIFICATION_POWER_STATUS;
#pragma pack(pop, not_power)

#define NOTIFICATION_MEDIA_EVENT_NO_EVENT           0x0
#define NOTIFICATION_EXTERNAL_EVENT_NO_CHANGE       0x0
#define NOTIFICATION_EXTERNAL_EVENT_BUTTON_DOWN     0x1
#define NOTIFICATION_EXTERNAL_EVENT_BUTTON_UP       0x2
#define NOTIFICATION_EXTERNAL_EVENT_EXTERNAL        0x3 // respond with GET_CONFIGURATION?

#define NOTIFICATION_EXTERNAL_STATUS_READY          0x0
#define NOTIFICATION_EXTERNAL_STATUS_PREVENT        0x1

#define NOTIFICATION_EXTERNAL_REQUEST_NONE          0x0000
#define NOTIFICATION_EXTERNAL_REQUEST_QUEUE_OVERRUN 0x0001
#define NOTIFICATION_EXTERNAL_REQUEST_PLAY          0x0101
#define NOTIFICATION_EXTERNAL_REQUEST_REWIND_BACK   0x0102
#define NOTIFICATION_EXTERNAL_REQUEST_FAST_FORWARD  0x0103
#define NOTIFICATION_EXTERNAL_REQUEST_PAUSE         0x0104
#define NOTIFICATION_EXTERNAL_REQUEST_STOP          0x0106
#define NOTIFICATION_EXTERNAL_REQUEST_ASCII_LOW     0x0200
#define NOTIFICATION_EXTERNAL_REQUEST_ASCII_HIGH    0x02ff

#pragma pack(push, not_extern, 1)
typedef struct _NOTIFICATION_EXTERNAL_STATUS { // event class == 0x3
    UCHAR ExternalEvent : 4;
    UCHAR Reserved1 : 4;
    UCHAR ExternalStatus : 4;
    UCHAR Reserved2 : 3;
    UCHAR PersistentPrevented : 1;
    UCHAR Request[2];
} NOTIFICATION_EXTERNAL_STATUS, *PNOTIFICATION_EXTERNAL_STATUS;
#pragma pack(pop, not_extern)

#define NOTIFICATION_MEDIA_EVENT_NO_CHANGE          0x0
#define NOTIFICATION_MEDIA_EVENT_EJECT_REQUEST      0x1
#define NOTIFICATION_MEDIA_EVENT_NEW_MEDIA          0x2
#define NOTIFICATION_MEDIA_EVENT_MEDIA_REMOVAL      0x3
#define NOTIFICATION_MEDIA_EVENT_MEDIA_CHANGE       0x4

#pragma pack(push, not_media, 1)
typedef struct _NOTIFICATION_MEDIA_STATUS { // event class == 0x4
    UCHAR MediaEvent : 4;
    UCHAR Reserved : 4;

    union {
        UCHAR PowerStatus; // OBSOLETE -- was improperly named in NT5 headers
        UCHAR MediaStatus; // Use this for currently reserved fields
        struct {
            UCHAR DoorTrayOpen : 1;
            UCHAR MediaPresent : 1;
            UCHAR ReservedX    : 6; // do not reference this directly!
        };
    };
    UCHAR StartSlot;
    UCHAR EndSlot;
} NOTIFICATION_MEDIA_STATUS, *PNOTIFICATION_MEDIA_STATUS;
#pragma pack(pop, not_media)

#define NOTIFICATION_BUSY_EVENT_NO_EVENT               0x0
#define NOTIFICATION_MULTI_HOST_EVENT_NO_CHANGE        0x0
#define NOTIFICATION_MULTI_HOST_EVENT_CONTROL_REQUEST  0x1
#define NOTIFICATION_MULTI_HOST_EVENT_CONTROL_GRANT    0x2
#define NOTIFICATION_MULTI_HOST_EVENT_CONTROL_RELEASE  0x3

#define NOTIFICATION_MULTI_HOST_STATUS_READY           0x0
#define NOTIFICATION_MULTI_HOST_STATUS_PREVENT         0x1

#define NOTIFICATION_MULTI_HOST_PRIORITY_NO_REQUESTS   0x0
#define NOTIFICATION_MULTI_HOST_PRIORITY_LOW           0x1
#define NOTIFICATION_MULTI_HOST_PRIORITY_MEDIUM        0x2
#define NOTIFICATION_MULTI_HOST_PRIORITY_HIGH          0x3

#pragma pack(push, not_multi, 1)
typedef struct _NOTIFICATION_MULTI_HOST_STATUS { // event class == 0x5
    UCHAR MultiHostEvent : 4;
    UCHAR Reserved1 : 4;
    UCHAR MultiHostStatus : 4;
    UCHAR Reserved2 : 3;
    UCHAR PersistentPrevented : 1;
    UCHAR Priority[2];
} NOTIFICATION_MULTI_HOST_STATUS, *PNOTIFICATION_MULTI_HOST_STATUS;
#pragma pack(pop, not_multi)

#define NOTIFICATION_BUSY_EVENT_NO_EVENT            0x0
#define NOTIFICATION_BUSY_EVENT_NO_CHANGE           0x0
#define NOTIFICATION_BUSY_EVENT_BUSY                0x1

#define NOTIFICATION_BUSY_STATUS_NO_EVENT           0x0
#define NOTIFICATION_BUSY_STATUS_POWER              0x1
#define NOTIFICATION_BUSY_STATUS_IMMEDIATE          0x2
#define NOTIFICATION_BUSY_STATUS_DEFERRED           0x3

#pragma pack(push, not_busy, 1)
typedef struct _NOTIFICATION_BUSY_STATUS { // event class == 0x6
    UCHAR DeviceBusyEvent : 4;
    UCHAR Reserved : 4;

    UCHAR DeviceBusyStatus;
    UCHAR Time[2];
} NOTIFICATION_BUSY_STATUS, *PNOTIFICATION_BUSY_STATUS;
#pragma pack(pop, not_busy)

////////////////////////////////////////////////////////////////////////////////

//
// Read DVD Structure Definitions and Constants
//

#define DVD_FORMAT_LEAD_IN          0x00
#define DVD_FORMAT_COPYRIGHT        0x01
#define DVD_FORMAT_DISK_KEY         0x02
#define DVD_FORMAT_BCA              0x03
#define DVD_FORMAT_MANUFACTURING    0x04

#pragma pack(push, dvd_struct_header, 1)
typedef struct _READ_DVD_STRUCTURES_HEADER {
    UCHAR Length[2];
    UCHAR Reserved[2];

#if !defined(__midl)
    UCHAR Data[0];
#endif
} READ_DVD_STRUCTURES_HEADER, *PREAD_DVD_STRUCTURES_HEADER;
#pragma pack(pop, dvd_struct_header)

//
// DiskKey, BCA & Manufacturer information will provide byte arrays as their
// data.
//

//
// CDVD 0.9 Send & Report Key Definitions and Structures
//

#define DVD_REPORT_AGID            0x00
#define DVD_CHALLENGE_KEY          0x01
#define DVD_KEY_1                  0x02
#define DVD_KEY_2                  0x03
#define DVD_TITLE_KEY              0x04
#define DVD_REPORT_ASF             0x05
#define DVD_INVALIDATE_AGID        0x3F

#pragma pack(push, dvdstuff, 1)
typedef struct _CDVD_KEY_HEADER {
    UCHAR DataLength[2];
    UCHAR Reserved[2];
#if !defined(__midl)
    UCHAR Data[0];
#endif
} CDVD_KEY_HEADER, *PCDVD_KEY_HEADER;

typedef struct _CDVD_REPORT_AGID_DATA {
    UCHAR Reserved1[3];
    UCHAR Reserved2 : 6;
    UCHAR AGID : 2;
} CDVD_REPORT_AGID_DATA, *PCDVD_REPORT_AGID_DATA;

typedef struct _CDVD_CHALLENGE_KEY_DATA {
    UCHAR ChallengeKeyValue[10];
    UCHAR Reserved[2];
} CDVD_CHALLENGE_KEY_DATA, *PCDVD_CHALLENGE_KEY_DATA;

typedef struct _CDVD_KEY_DATA {
    UCHAR Key[5];
    UCHAR Reserved[3];
} CDVD_KEY_DATA, *PCDVD_KEY_DATA;

typedef struct _CDVD_REPORT_ASF_DATA {
    UCHAR Reserved1[3];
    UCHAR Success : 1;
    UCHAR Reserved2 : 7;
} CDVD_REPORT_ASF_DATA, *PCDVD_REPORT_ASF_DATA;

typedef struct _CDVD_TITLE_KEY_HEADER {
    UCHAR DataLength[2];
    UCHAR Reserved1[1];
    UCHAR Reserved2 : 3;
    UCHAR CGMS : 2;
    UCHAR CP_SEC : 1;
    UCHAR CPM : 1;
    UCHAR Zero : 1;
    CDVD_KEY_DATA TitleKey;
} CDVD_TITLE_KEY_HEADER, *PCDVD_TITLE_KEY_HEADER;
#pragma pack(pop, dvdstuff)

//
// Read Formatted Capacity Data - returned in Big Endian Format
//


#pragma pack(push, formatted_capacity, 1)
typedef struct _FORMATTED_CAPACITY_DESCRIPTOR {
    UCHAR NumberOfBlocks[4];
    UCHAR Maximum : 1;
    UCHAR Valid : 1;
    UCHAR BlockLength[3];
} FORMATTED_CAPACITY_DESCRIPTOR, *PFORMATTED_CAPACITY_DESCRIPTOR;

typedef struct _FORMATTED_CAPACITY_LIST {
    UCHAR Reserved[3];
    UCHAR CapacityListLength;
#if !defined(__midl)
    FORMATTED_CAPACITY_DESCRIPTOR Descriptors[0];
#endif
} FORMATTED_CAPACITY_LIST, *PFORMATTED_CAPACITY_LIST;
#pragma pack(pop, formatted_capacity)

//
//      BLANK command blanking type codes
//

#define BLANK_FULL              0x0
#define BLANK_MINIMAL           0x1
#define BLANK_TRACK             0x2
#define BLANK_UNRESERVE_TRACK   0x3
#define BLANK_TAIL              0x4
#define BLANK_UNCLOSE_SESSION   0x5
#define BLANK_SESSION           0x6

//
// PLAY_CD definitions and constants
//

#define CD_EXPECTED_SECTOR_ANY          0x0
#define CD_EXPECTED_SECTOR_CDDA         0x1
#define CD_EXPECTED_SECTOR_MODE1        0x2
#define CD_EXPECTED_SECTOR_MODE2        0x3
#define CD_EXPECTED_SECTOR_MODE2_FORM1  0x4
#define CD_EXPECTED_SECTOR_MODE2_FORM2  0x5

//
// Read Disk Information Definitions and Capabilities
//

#define DISK_STATUS_EMPTY       0x00
#define DISK_STATUS_INCOMPLETE  0x01
#define DISK_STATUS_COMPLETE    0x02

#define LAST_SESSION_EMPTY              0x00
#define LAST_SESSION_INCOMPLETE         0x01
#define LAST_SESSION_RESERVED_DAMAGED   0x02
#define LAST_SESSION_COMPLETE           0x03

#define DISK_TYPE_CDDA          0x00
#define DISK_TYPE_CDI           0x10
#define DISK_TYPE_XA            0x20
#define DISK_TYPE_UNDEFINED     0xFF

//
//  Values for MrwStatus field.
//

#define DISC_BGFORMAT_STATE_NONE        0x0
#define DISC_BGFORMAT_STATE_INCOMPLETE  0x1
#define DISC_BGFORMAT_STATE_RUNNING     0x2
#define DISC_BGFORMAT_STATE_COMPLETE    0x3


#pragma pack(push, discinfo, 1)
typedef struct _OPC_TABLE_ENTRY {
    UCHAR Speed[2];
    UCHAR OPCValue[6];
} OPC_TABLE_ENTRY, *POPC_TABLE_ENTRY;

typedef struct _DISC_INFORMATION {

    UCHAR Length[2];
    UCHAR DiscStatus        : 2;
    UCHAR LastSessionStatus : 2;
    UCHAR Erasable          : 1;
    UCHAR Reserved1         : 3;
    UCHAR FirstTrackNumber;

    UCHAR NumberOfSessionsLsb;
    UCHAR LastSessionFirstTrackLsb;
    UCHAR LastSessionLastTrackLsb;
    UCHAR MrwStatus   : 2;
    UCHAR MrwDirtyBit : 1;
    UCHAR Reserved2   : 2;
    UCHAR URU         : 1;
    UCHAR DBC_V       : 1;
    UCHAR DID_V       : 1;

    UCHAR DiscType;
    UCHAR NumberOfSessionsMsb;
    UCHAR LastSessionFirstTrackMsb;
    UCHAR LastSessionLastTrackMsb;

    UCHAR DiskIdentification[4];
    UCHAR LastSessionLeadIn[4];     // HMSF
    UCHAR LastPossibleLeadOutStartTime[4]; // HMSF
    UCHAR DiskBarCode[8];

    UCHAR Reserved4;
    UCHAR NumberOPCEntries;
    OPC_TABLE_ENTRY OPCTable[ 1 ]; // can be many of these here....

} DISC_INFORMATION, *PDISC_INFORMATION;

// TODO: Deprecate DISK_INFORMATION
//#if PRAGMA_DEPRECATED_DDK
//#pragma deprecated(_DISK_INFORMATION)  // Use DISC_INFORMATION, note size change
//#pragma deprecated( DISK_INFORMATION)  // Use DISC_INFORMATION, note size change
//#pragma deprecated(PDISK_INFORMATION)  // Use DISC_INFORMATION, note size change
//#endif

typedef struct _DISK_INFORMATION {
    UCHAR Length[2];

    UCHAR DiskStatus : 2;
    UCHAR LastSessionStatus : 2;
    UCHAR Erasable : 1;
    UCHAR Reserved1 : 3;

    UCHAR FirstTrackNumber;
    UCHAR NumberOfSessions;
    UCHAR LastSessionFirstTrack;
    UCHAR LastSessionLastTrack;

    UCHAR Reserved2 : 5;
    UCHAR GEN : 1;
    UCHAR DBC_V : 1;
    UCHAR DID_V : 1;

    UCHAR DiskType;
    UCHAR Reserved3[3];

    UCHAR DiskIdentification[4];
    UCHAR LastSessionLeadIn[4];     // MSF
    UCHAR LastPossibleStartTime[4]; // MSF
    UCHAR DiskBarCode[8];

    UCHAR Reserved4;
    UCHAR NumberOPCEntries;
#if !defined(__midl)
    OPC_TABLE_ENTRY OPCTable[0];
#endif
} DISK_INFORMATION, *PDISK_INFORMATION;
#pragma pack(pop, discinfo)


//
// Read Header definitions and structures
//
#pragma pack(push, cdheader, 1)
typedef struct _DATA_BLOCK_HEADER {
    UCHAR DataMode;
    UCHAR Reserved[4];
    union {
        UCHAR LogicalBlockAddress[4];
        struct {
            UCHAR Reserved;
            UCHAR M;
            UCHAR S;
            UCHAR F;
        } MSF;
    };
} DATA_BLOCK_HEADER, *PDATA_BLOCK_HEADER;
#pragma pack(pop, cdheader)


#define DATA_BLOCK_MODE0    0x0
#define DATA_BLOCK_MODE1    0x1
#define DATA_BLOCK_MODE2    0x2

//
// Read TOC Format Codes
//

#define READ_TOC_FORMAT_TOC         0x00
#define READ_TOC_FORMAT_SESSION     0x01
#define READ_TOC_FORMAT_FULL_TOC    0x02
#define READ_TOC_FORMAT_PMA         0x03
#define READ_TOC_FORMAT_ATIP        0x04

// TODO: Deprecate TRACK_INFORMATION structure, use TRACK_INFORMATION2 instead
#pragma pack(push, track_info, 1)
typedef struct _TRACK_INFORMATION {
    UCHAR Length[2];
    UCHAR TrackNumber;
    UCHAR SessionNumber;
    UCHAR Reserved1;
    UCHAR TrackMode : 4;
    UCHAR Copy      : 1;
    UCHAR Damage    : 1;
    UCHAR Reserved2 : 2;
    UCHAR DataMode : 4;
    UCHAR FP       : 1;
    UCHAR Packet   : 1;
    UCHAR Blank    : 1;
    UCHAR RT       : 1;
    UCHAR NWA_V     : 1;
    UCHAR Reserved3 : 7;
    UCHAR TrackStartAddress[4];
    UCHAR NextWritableAddress[4];
    UCHAR FreeBlocks[4];
    UCHAR FixedPacketSize[4];
} TRACK_INFORMATION, *PTRACK_INFORMATION;

// Second Revision Modifies:
// * Longer names for some fields
// * LSB to track/session number fields
// * LRA_V bit
// Second Revision Adds:
// * TrackSize
// * LastRecordedAddress
// * MSB to track/session
// * Two reserved bytes
// Total structure size increased by 12 (0x0C) bytes
typedef struct _TRACK_INFORMATION2 {

    UCHAR Length[2];
    UCHAR TrackNumberLsb;
    UCHAR SessionNumberLsb;

    UCHAR Reserved4;
    UCHAR TrackMode : 4;
    UCHAR Copy      : 1;
    UCHAR Damage    : 1;
    UCHAR Reserved5 : 2;
    UCHAR DataMode      : 4;
    UCHAR FixedPacket   : 1;
    UCHAR Packet        : 1;
    UCHAR Blank         : 1;
    UCHAR ReservedTrack : 1;
    UCHAR NWA_V     : 1;
    UCHAR LRA_V     : 1;
    UCHAR Reserved6 : 6;

    UCHAR TrackStartAddress[4];
    UCHAR NextWritableAddress[4];
    UCHAR FreeBlocks[4];
    UCHAR FixedPacketSize[4]; // blocking factor
    UCHAR TrackSize[4];
    UCHAR LastRecordedAddress[4];

    UCHAR TrackNumberMsb;
    UCHAR SessionNumberMsb;
    UCHAR Reserved7[2];

} TRACK_INFORMATION2, *PTRACK_INFORMATION2;

// Third Revision Adds
// * ReadCompatibilityLBA
// Total structure size increased by 4 bytes
typedef struct _TRACK_INFORMATION3 {

    UCHAR Length[2];
    UCHAR TrackNumberLsb;
    UCHAR SessionNumberLsb;

    UCHAR Reserved4;
    UCHAR TrackMode : 4;
    UCHAR Copy      : 1;
    UCHAR Damage    : 1;
    UCHAR Reserved5 : 2;
    UCHAR DataMode      : 4;
    UCHAR FixedPacket   : 1;
    UCHAR Packet        : 1;
    UCHAR Blank         : 1;
    UCHAR ReservedTrack : 1;
    UCHAR NWA_V     : 1;
    UCHAR LRA_V     : 1;
    UCHAR Reserved6 : 6;

    UCHAR TrackStartAddress[4];
    UCHAR NextWritableAddress[4];
    UCHAR FreeBlocks[4];
    UCHAR FixedPacketSize[4]; // blocking factor
    UCHAR TrackSize[4];
    UCHAR LastRecordedAddress[4];

    UCHAR TrackNumberMsb;
    UCHAR SessionNumberMsb;
    UCHAR Reserved7[2];
    UCHAR ReadCompatibilityLba[4];

} TRACK_INFORMATION3, *PTRACK_INFORMATION3;

#pragma pack(pop, track_info)

#pragma pack(push, perf_descriptor, 1)
typedef struct _PERFORMANCE_DESCRIPTOR {

    UCHAR RandomAccess         : 1;
    UCHAR Exact                : 1;
    UCHAR RestoreDefaults      : 1;
    UCHAR WriteRotationControl : 2;
    UCHAR Reserved1            : 3;

    UCHAR Reserved[3];
    UCHAR StartLba[4];
    UCHAR EndLba[4];
    UCHAR ReadSize[4];
    UCHAR ReadTime[4];
    UCHAR WriteSize[4];
    UCHAR WriteTime[4];

} PERFORMANCE_DESCRIPTOR, *PPERFORMANCE_DESCRIPTOR;
#pragma pack(pop, perf_descriptor)

//
// Command Descriptor Block constants.
//

#define CDB6GENERIC_LENGTH                   6
#define CDB10GENERIC_LENGTH                  10
#define CDB12GENERIC_LENGTH                  12

#define SETBITON                             1
#define SETBITOFF                            0

//
// Mode Sense/Select page constants.
//

#define MODE_PAGE_VENDOR_SPECIFIC       0x00
#define MODE_PAGE_ERROR_RECOVERY        0x01
#define MODE_PAGE_DISCONNECT            0x02
#define MODE_PAGE_FORMAT_DEVICE         0x03 // disk
#define MODE_PAGE_MRW                   0x03 // cdrom
#define MODE_PAGE_RIGID_GEOMETRY        0x04
#define MODE_PAGE_FLEXIBILE             0x05 // disk
#define MODE_PAGE_WRITE_PARAMETERS      0x05 // cdrom
#define MODE_PAGE_VERIFY_ERROR          0x07
#define MODE_PAGE_CACHING               0x08
#define MODE_PAGE_PERIPHERAL            0x09
#define MODE_PAGE_CONTROL               0x0A
#define MODE_PAGE_MEDIUM_TYPES          0x0B
#define MODE_PAGE_NOTCH_PARTITION       0x0C
#define MODE_PAGE_CD_AUDIO_CONTROL      0x0E
#define MODE_PAGE_DATA_COMPRESS         0x0F
#define MODE_PAGE_DEVICE_CONFIG         0x10
#define MODE_PAGE_XOR_CONTROL           0x10 // disk
#define MODE_PAGE_MEDIUM_PARTITION      0x11
#define MODE_PAGE_ENCLOSURE_SERVICES_MANAGEMENT 0x14
#define MODE_PAGE_EXTENDED              0x15
#define MODE_PAGE_EXTENDED_DEVICE_SPECIFIC 0x16
#define MODE_PAGE_CDVD_FEATURE_SET      0x18
#define MODE_PAGE_PROTOCOL_SPECIFIC_LUN 0x18
#define MODE_PAGE_PROTOCOL_SPECIFIC_PORT 0x19
#define MODE_PAGE_POWER_CONDITION       0x1A
#define MODE_PAGE_LUN_MAPPING           0x1B
#define MODE_PAGE_FAULT_REPORTING       0x1C
#define MODE_PAGE_CDVD_INACTIVITY       0x1D // cdrom
#define MODE_PAGE_ELEMENT_ADDRESS       0x1D
#define MODE_PAGE_TRANSPORT_GEOMETRY    0x1E
#define MODE_PAGE_DEVICE_CAPABILITIES   0x1F
#define MODE_PAGE_CAPABILITIES          0x2A // cdrom

#define MODE_SENSE_RETURN_ALL           0x3f

#define MODE_SENSE_CURRENT_VALUES       0x00
#define MODE_SENSE_CHANGEABLE_VALUES    0x40
#define MODE_SENSE_DEFAULT_VAULES       0x80
#define MODE_SENSE_SAVED_VALUES         0xc0


//
// SCSI CDB operation codes
//

// 6-byte commands:
#define SCSIOP_TEST_UNIT_READY          0x00
#define SCSIOP_REZERO_UNIT              0x01
#define SCSIOP_REWIND                   0x01
#define SCSIOP_REQUEST_BLOCK_ADDR       0x02
#define SCSIOP_REQUEST_SENSE            0x03
#define SCSIOP_FORMAT_UNIT              0x04
#define SCSIOP_READ_BLOCK_LIMITS        0x05
#define SCSIOP_REASSIGN_BLOCKS          0x07
#define SCSIOP_INIT_ELEMENT_STATUS      0x07
#define SCSIOP_READ6                    0x08
#define SCSIOP_RECEIVE                  0x08
#define SCSIOP_WRITE6                   0x0A
#define SCSIOP_PRINT                    0x0A
#define SCSIOP_SEND                     0x0A
#define SCSIOP_SEEK6                    0x0B
#define SCSIOP_TRACK_SELECT             0x0B
#define SCSIOP_SLEW_PRINT               0x0B
#define SCSIOP_SET_CAPACITY             0x0B // tape
#define SCSIOP_SEEK_BLOCK               0x0C
#define SCSIOP_PARTITION                0x0D
#define SCSIOP_READ_REVERSE             0x0F
#define SCSIOP_WRITE_FILEMARKS          0x10
#define SCSIOP_FLUSH_BUFFER             0x10
#define SCSIOP_SPACE                    0x11
#define SCSIOP_INQUIRY                  0x12
#define SCSIOP_VERIFY6                  0x13
#define SCSIOP_RECOVER_BUF_DATA         0x14
#define SCSIOP_MODE_SELECT              0x15
#define SCSIOP_RESERVE_UNIT             0x16
#define SCSIOP_RELEASE_UNIT             0x17
#define SCSIOP_COPY                     0x18
#define SCSIOP_ERASE                    0x19
#define SCSIOP_MODE_SENSE               0x1A
#define SCSIOP_START_STOP_UNIT          0x1B
#define SCSIOP_STOP_PRINT               0x1B
#define SCSIOP_LOAD_UNLOAD              0x1B
#define SCSIOP_RECEIVE_DIAGNOSTIC       0x1C
#define SCSIOP_SEND_DIAGNOSTIC          0x1D
#define SCSIOP_MEDIUM_REMOVAL           0x1E

// 10-byte commands
#define SCSIOP_READ_FORMATTED_CAPACITY  0x23
#define SCSIOP_READ_CAPACITY            0x25
#define SCSIOP_READ                     0x28
#define SCSIOP_WRITE                    0x2A
#define SCSIOP_SEEK                     0x2B
#define SCSIOP_LOCATE                   0x2B
#define SCSIOP_POSITION_TO_ELEMENT      0x2B
#define SCSIOP_WRITE_VERIFY             0x2E
#define SCSIOP_VERIFY                   0x2F
#define SCSIOP_SEARCH_DATA_HIGH         0x30
#define SCSIOP_SEARCH_DATA_EQUAL        0x31
#define SCSIOP_SEARCH_DATA_LOW          0x32
#define SCSIOP_SET_LIMITS               0x33
#define SCSIOP_READ_POSITION            0x34
#define SCSIOP_SYNCHRONIZE_CACHE        0x35
#define SCSIOP_COMPARE                  0x39
#define SCSIOP_COPY_COMPARE             0x3A
#define SCSIOP_WRITE_DATA_BUFF          0x3B
#define SCSIOP_READ_DATA_BUFF           0x3C
#define SCSIOP_WRITE_LONG               0x3F
#define SCSIOP_CHANGE_DEFINITION        0x40
#define SCSIOP_WRITE_SAME               0x41
#define SCSIOP_READ_SUB_CHANNEL         0x42
#define SCSIOP_READ_TOC                 0x43
#define SCSIOP_READ_HEADER              0x44
#define SCSIOP_REPORT_DENSITY_SUPPORT   0x44 // tape
#define SCSIOP_PLAY_AUDIO               0x45
#define SCSIOP_GET_CONFIGURATION        0x46
#define SCSIOP_PLAY_AUDIO_MSF           0x47
#define SCSIOP_PLAY_TRACK_INDEX         0x48
#define SCSIOP_PLAY_TRACK_RELATIVE      0x49
#define SCSIOP_GET_EVENT_STATUS         0x4A
#define SCSIOP_PAUSE_RESUME             0x4B
#define SCSIOP_LOG_SELECT               0x4C
#define SCSIOP_LOG_SENSE                0x4D
#define SCSIOP_STOP_PLAY_SCAN           0x4E
#define SCSIOP_XDWRITE                  0x50
#define SCSIOP_XPWRITE                  0x51
#define SCSIOP_READ_DISK_INFORMATION    0x51
#define SCSIOP_READ_DISC_INFORMATION    0x51 // proper use of disc over disk
#define SCSIOP_READ_TRACK_INFORMATION   0x52
#define SCSIOP_XDWRITE_READ             0x53
#define SCSIOP_RESERVE_TRACK_RZONE      0x53
#define SCSIOP_SEND_OPC_INFORMATION     0x54 // optimum power calibration
#define SCSIOP_MODE_SELECT10            0x55
#define SCSIOP_RESERVE_UNIT10           0x56
#define SCSIOP_RESERVE_ELEMENT          0x56
#define SCSIOP_RELEASE_UNIT10           0x57
#define SCSIOP_RELEASE_ELEMENT          0x57
#define SCSIOP_REPAIR_TRACK             0x58
#define SCSIOP_MODE_SENSE10             0x5A
#define SCSIOP_CLOSE_TRACK_SESSION      0x5B
#define SCSIOP_READ_BUFFER_CAPACITY     0x5C
#define SCSIOP_SEND_CUE_SHEET           0x5D
#define SCSIOP_PERSISTENT_RESERVE_IN    0x5E
#define SCSIOP_PERSISTENT_RESERVE_OUT   0x5F

// 12-byte commands
#define SCSIOP_REPORT_LUNS              0xA0
#define SCSIOP_BLANK                    0xA1
#define SCSIOP_ATA_PASSTHROUGH12        0xA1
#define SCSIOP_SEND_EVENT               0xA2
#define SCSIOP_SEND_KEY                 0xA3
#define SCSIOP_MAINTENANCE_IN           0xA3
#define SCSIOP_REPORT_KEY               0xA4
#define SCSIOP_MAINTENANCE_OUT          0xA4
#define SCSIOP_MOVE_MEDIUM              0xA5
#define SCSIOP_LOAD_UNLOAD_SLOT         0xA6
#define SCSIOP_EXCHANGE_MEDIUM          0xA6
#define SCSIOP_SET_READ_AHEAD           0xA7
#define SCSIOP_MOVE_MEDIUM_ATTACHED     0xA7
#define SCSIOP_READ12                   0xA8
#define SCSIOP_GET_MESSAGE              0xA8
#define SCSIOP_SERVICE_ACTION_OUT12     0xA9
#define SCSIOP_WRITE12                  0xAA
#define SCSIOP_SEND_MESSAGE             0xAB
#define SCSIOP_SERVICE_ACTION_IN12      0xAB
#define SCSIOP_GET_PERFORMANCE          0xAC
#define SCSIOP_READ_DVD_STRUCTURE       0xAD
#define SCSIOP_WRITE_VERIFY12           0xAE
#define SCSIOP_VERIFY12                 0xAF
#define SCSIOP_SEARCH_DATA_HIGH12       0xB0
#define SCSIOP_SEARCH_DATA_EQUAL12      0xB1
#define SCSIOP_SEARCH_DATA_LOW12        0xB2
#define SCSIOP_SET_LIMITS12             0xB3
#define SCSIOP_READ_ELEMENT_STATUS_ATTACHED 0xB4
#define SCSIOP_REQUEST_VOL_ELEMENT      0xB5
#define SCSIOP_SEND_VOLUME_TAG          0xB6
#define SCSIOP_SET_STREAMING            0xB6 // C/DVD
#define SCSIOP_READ_DEFECT_DATA         0xB7
#define SCSIOP_READ_ELEMENT_STATUS      0xB8
#define SCSIOP_READ_CD_MSF              0xB9
#define SCSIOP_SCAN_CD                  0xBA
#define SCSIOP_REDUNDANCY_GROUP_IN      0xBA
#define SCSIOP_SET_CD_SPEED             0xBB
#define SCSIOP_REDUNDANCY_GROUP_OUT     0xBB
#define SCSIOP_PLAY_CD                  0xBC
#define SCSIOP_SPARE_IN                 0xBC
#define SCSIOP_MECHANISM_STATUS         0xBD
#define SCSIOP_SPARE_OUT                0xBD
#define SCSIOP_READ_CD                  0xBE
#define SCSIOP_VOLUME_SET_IN            0xBE
#define SCSIOP_SEND_DVD_STRUCTURE       0xBF
#define SCSIOP_VOLUME_SET_OUT           0xBF
#define SCSIOP_INIT_ELEMENT_RANGE       0xE7

// 16-byte commands
#define SCSIOP_XDWRITE_EXTENDED16       0x80 // disk
#define SCSIOP_WRITE_FILEMARKS16        0x80 // tape
#define SCSIOP_REBUILD16                0x81 // disk
#define SCSIOP_READ_REVERSE16           0x81 // tape
#define SCSIOP_REGENERATE16             0x82 // disk
#define SCSIOP_EXTENDED_COPY            0x83
#define SCSIOP_RECEIVE_COPY_RESULTS     0x84
#define SCSIOP_ATA_PASSTHROUGH16        0x85
#define SCSIOP_ACCESS_CONTROL_IN        0x86
#define SCSIOP_ACCESS_CONTROL_OUT       0x87
#define SCSIOP_READ16                   0x88
#define SCSIOP_WRITE16                  0x8A
#define SCSIOP_READ_ATTRIBUTES          0x8C
#define SCSIOP_WRITE_ATTRIBUTES         0x8D
#define SCSIOP_WRITE_VERIFY16           0x8E
#define SCSIOP_VERIFY16                 0x8F
#define SCSIOP_PREFETCH16               0x90
#define SCSIOP_SYNCHRONIZE_CACHE16      0x91
#define SCSIOP_SPACE16                  0x91 // tape
#define SCSIOP_LOCK_UNLOCK_CACHE16      0x92
#define SCSIOP_LOCATE16                 0x92 // tape
#define SCSIOP_WRITE_SAME16             0x93
#define SCSIOP_ERASE16                  0x93 // tape
#define SCSIOP_READ_CAPACITY16          0x9E
#define SCSIOP_SERVICE_ACTION_IN16      0x9E
#define SCSIOP_SERVICE_ACTION_OUT16     0x9F


//
// If the IMMED bit is 1, status is returned as soon
// as the operation is initiated. If the IMMED bit
// is 0, status is not returned until the operation
// is completed.
//

#define CDB_RETURN_ON_COMPLETION   0
#define CDB_RETURN_IMMEDIATE       1

// end_ntminitape

//
// CDB Force media access used in extended read and write commands.
//

#define CDB_FORCE_MEDIA_ACCESS 0x08

//
// Denon CD ROM operation codes
//

#define SCSIOP_DENON_EJECT_DISC    0xE6
#define SCSIOP_DENON_STOP_AUDIO    0xE7
#define SCSIOP_DENON_PLAY_AUDIO    0xE8
#define SCSIOP_DENON_READ_TOC      0xE9
#define SCSIOP_DENON_READ_SUBCODE  0xEB

//
// SCSI Bus Messages
//

#define SCSIMESS_ABORT                0x06
#define SCSIMESS_ABORT_WITH_TAG       0x0D
#define SCSIMESS_BUS_DEVICE_RESET     0X0C
#define SCSIMESS_CLEAR_QUEUE          0X0E
#define SCSIMESS_COMMAND_COMPLETE     0X00
#define SCSIMESS_DISCONNECT           0X04
#define SCSIMESS_EXTENDED_MESSAGE     0X01
#define SCSIMESS_IDENTIFY             0X80
#define SCSIMESS_IDENTIFY_WITH_DISCON 0XC0
#define SCSIMESS_IGNORE_WIDE_RESIDUE  0X23
#define SCSIMESS_INITIATE_RECOVERY    0X0F
#define SCSIMESS_INIT_DETECTED_ERROR  0X05
#define SCSIMESS_LINK_CMD_COMP        0X0A
#define SCSIMESS_LINK_CMD_COMP_W_FLAG 0X0B
#define SCSIMESS_MESS_PARITY_ERROR    0X09
#define SCSIMESS_MESSAGE_REJECT       0X07
#define SCSIMESS_NO_OPERATION         0X08
#define SCSIMESS_HEAD_OF_QUEUE_TAG    0X21
#define SCSIMESS_ORDERED_QUEUE_TAG    0X22
#define SCSIMESS_SIMPLE_QUEUE_TAG     0X20
#define SCSIMESS_RELEASE_RECOVERY     0X10
#define SCSIMESS_RESTORE_POINTERS     0X03
#define SCSIMESS_SAVE_DATA_POINTER    0X02
#define SCSIMESS_TERMINATE_IO_PROCESS 0X11

//
// SCSI Extended Message operation codes
//

#define SCSIMESS_MODIFY_DATA_POINTER  0X00
#define SCSIMESS_SYNCHRONOUS_DATA_REQ 0X01
#define SCSIMESS_WIDE_DATA_REQUEST    0X03

//
// SCSI Extended Message Lengths
//

#define SCSIMESS_MODIFY_DATA_LENGTH   5
#define SCSIMESS_SYNCH_DATA_LENGTH    3
#define SCSIMESS_WIDE_DATA_LENGTH     2

//
// SCSI extended message structure
//

#pragma pack(push, scsi_mess, 1)
typedef struct _SCSI_EXTENDED_MESSAGE {
    UCHAR InitialMessageCode;
    UCHAR MessageLength;
    UCHAR MessageType;
    union _EXTENDED_ARGUMENTS {

        struct {
            UCHAR Modifier[4];
        } Modify;

        struct {
            UCHAR TransferPeriod;
            UCHAR ReqAckOffset;
        } Synchronous;

        struct{
            UCHAR Width;
        } Wide;
    }ExtendedArguments;
}SCSI_EXTENDED_MESSAGE, *PSCSI_EXTENDED_MESSAGE;
#pragma pack(pop, scsi_mess)

//
// SCSI bus status codes.
//

#define SCSISTAT_GOOD                  0x00
#define SCSISTAT_CHECK_CONDITION       0x02
#define SCSISTAT_CONDITION_MET         0x04
#define SCSISTAT_BUSY                  0x08
#define SCSISTAT_INTERMEDIATE          0x10
#define SCSISTAT_INTERMEDIATE_COND_MET 0x14
#define SCSISTAT_RESERVATION_CONFLICT  0x18
#define SCSISTAT_COMMAND_TERMINATED    0x22
#define SCSISTAT_QUEUE_FULL            0x28

//
// Enable Vital Product Data Flag (EVPD)
// used with INQUIRY command.
//

#define CDB_INQUIRY_EVPD           0x01

//
// Defines for format CDB
//

#define LUN0_FORMAT_SAVING_DEFECT_LIST 0
#define USE_DEFAULTMSB  0
#define USE_DEFAULTLSB  0

#define START_UNIT_CODE 0x01
#define STOP_UNIT_CODE  0x00

// begin_ntminitape

//
// Inquiry buffer structure. This is the data returned from the target
// after it receives an inquiry.
//
// This structure may be extended by the number of bytes specified
// in the field AdditionalLength. The defined size constant only
// includes fields through ProductRevisionLevel.
//
// The NT SCSI drivers are only interested in the first 36 bytes of data.
//

#define INQUIRYDATABUFFERSIZE 36

#if (NTDDI_VERSION < NTDDI_WINXP)
typedef struct _INQUIRYDATA {
    UCHAR DeviceType : 5;
    UCHAR DeviceTypeQualifier : 3;
    UCHAR DeviceTypeModifier : 7;
    UCHAR RemovableMedia : 1;
    UCHAR Versions;
    UCHAR ResponseDataFormat : 4;
    UCHAR HiSupport : 1;
    UCHAR NormACA : 1;
    UCHAR ReservedBit : 1;
    UCHAR AERC : 1;
    UCHAR AdditionalLength;
    UCHAR Reserved[2];
    UCHAR SoftReset : 1;
    UCHAR CommandQueue : 1;
    UCHAR Reserved2 : 1;
    UCHAR LinkedCommands : 1;
    UCHAR Synchronous : 1;
    UCHAR Wide16Bit : 1;
    UCHAR Wide32Bit : 1;
    UCHAR RelativeAddressing : 1;
    UCHAR VendorId[8];
    UCHAR ProductId[16];
    UCHAR ProductRevisionLevel[4];
    UCHAR VendorSpecific[20];
    UCHAR Reserved3[40];
} INQUIRYDATA, *PINQUIRYDATA;
#else
#pragma pack(push, inquiry, 1)
typedef struct _INQUIRYDATA {
    UCHAR DeviceType : 5;
    UCHAR DeviceTypeQualifier : 3;
    UCHAR DeviceTypeModifier : 7;
    UCHAR RemovableMedia : 1;
    union {
        UCHAR Versions;
        struct {
            UCHAR ANSIVersion : 3;
            UCHAR ECMAVersion : 3;
            UCHAR ISOVersion : 2;
        };
    };
    UCHAR ResponseDataFormat : 4;
    UCHAR HiSupport : 1;
    UCHAR NormACA : 1;
    UCHAR TerminateTask : 1;
    UCHAR AERC : 1;
    UCHAR AdditionalLength;
    UCHAR Reserved;
    UCHAR Addr16 : 1;               // defined only for SIP devices.
    UCHAR Addr32 : 1;               // defined only for SIP devices.
    UCHAR AckReqQ: 1;               // defined only for SIP devices.
    UCHAR MediumChanger : 1;
    UCHAR MultiPort : 1;
    UCHAR ReservedBit2 : 1;
    UCHAR EnclosureServices : 1;
    UCHAR ReservedBit3 : 1;
    UCHAR SoftReset : 1;
    UCHAR CommandQueue : 1;
    UCHAR TransferDisable : 1;      // defined only for SIP devices.
    UCHAR LinkedCommands : 1;
    UCHAR Synchronous : 1;          // defined only for SIP devices.
    UCHAR Wide16Bit : 1;            // defined only for SIP devices.
    UCHAR Wide32Bit : 1;            // defined only for SIP devices.
    UCHAR RelativeAddressing : 1;
    UCHAR VendorId[8];
    UCHAR ProductId[16];
    UCHAR ProductRevisionLevel[4];
    UCHAR VendorSpecific[20];
    UCHAR Reserved3[40];
} INQUIRYDATA, *PINQUIRYDATA;
#pragma pack(pop, inquiry)
#endif

//
// Inquiry defines. Used to interpret data returned from target as result
// of inquiry command.
//
// DeviceType field
//

#define DIRECT_ACCESS_DEVICE            0x00    // disks
#define SEQUENTIAL_ACCESS_DEVICE        0x01    // tapes
#define PRINTER_DEVICE                  0x02    // printers
#define PROCESSOR_DEVICE                0x03    // scanners, printers, etc
#define WRITE_ONCE_READ_MULTIPLE_DEVICE 0x04    // worms
#define READ_ONLY_DIRECT_ACCESS_DEVICE  0x05    // cdroms
#define SCANNER_DEVICE                  0x06    // scanners
#define OPTICAL_DEVICE                  0x07    // optical disks
#define MEDIUM_CHANGER                  0x08    // jukebox
#define COMMUNICATION_DEVICE            0x09    // network
// 0xA and 0xB are obsolete
#define ARRAY_CONTROLLER_DEVICE         0x0C
#define SCSI_ENCLOSURE_DEVICE           0x0D
#define REDUCED_BLOCK_DEVICE            0x0E    // e.g., 1394 disk
#define OPTICAL_CARD_READER_WRITER_DEVICE 0x0F
#define BRIDGE_CONTROLLER_DEVICE        0x10
#define OBJECT_BASED_STORAGE_DEVICE     0x11    // OSD
#define LOGICAL_UNIT_NOT_PRESENT_DEVICE 0x7F

#define DEVICE_QUALIFIER_ACTIVE         0x00
#define DEVICE_QUALIFIER_NOT_ACTIVE     0x01
#define DEVICE_QUALIFIER_NOT_SUPPORTED  0x03

//
// DeviceTypeQualifier field
//

#define DEVICE_CONNECTED 0x00

//
// Vital Product Data Pages
//

//
// Unit Serial Number Page (page code 0x80)
//
// Provides a product serial number for the target or the logical unit.
//
#pragma pack(push, vpd_media_sn, 1)
typedef struct _VPD_MEDIA_SERIAL_NUMBER_PAGE {
    UCHAR DeviceType : 5;
    UCHAR DeviceTypeQualifier : 3;
    UCHAR PageCode;
    UCHAR Reserved;
    UCHAR PageLength;
#if !defined(__midl)
    UCHAR SerialNumber[0];
#endif
} VPD_MEDIA_SERIAL_NUMBER_PAGE, *PVPD_MEDIA_SERIAL_NUMBER_PAGE;
#pragma pack(pop, vpd_media_sn)

#pragma pack(push, vpd_sn, 1)
typedef struct _VPD_SERIAL_NUMBER_PAGE {
    UCHAR DeviceType : 5;
    UCHAR DeviceTypeQualifier : 3;
    UCHAR PageCode;
    UCHAR Reserved;
    UCHAR PageLength;
#if !defined(__midl)
    UCHAR SerialNumber[0];
#endif
} VPD_SERIAL_NUMBER_PAGE, *PVPD_SERIAL_NUMBER_PAGE;
#pragma pack(pop, vpd_sn)

//
// Device Identification Page (page code 0x83)
// Provides the means to retrieve zero or more identification descriptors
// applying to the logical unit.
//

#pragma pack(push, vpd_stuff, 1)
typedef enum _VPD_CODE_SET {
    VpdCodeSetReserved = 0,
    VpdCodeSetBinary = 1,
    VpdCodeSetAscii = 2,
    VpdCodeSetUTF8 = 3
} VPD_CODE_SET, *PVPD_CODE_SET;

typedef enum _VPD_ASSOCIATION {
    VpdAssocDevice = 0,
    VpdAssocPort = 1,
    VpdAssocTarget = 2,
    VpdAssocReserved1 = 3,
    VpdAssocReserved2 = 4       // bogus, only two bits
} VPD_ASSOCIATION, *PVPD_ASSOCIATION;

typedef enum _VPD_IDENTIFIER_TYPE {
    VpdIdentifierTypeVendorSpecific = 0,
    VpdIdentifierTypeVendorId = 1,
    VpdIdentifierTypeEUI64 = 2,
    VpdIdentifierTypeFCPHName = 3,
    VpdIdentifierTypePortRelative = 4,
    VpdIdentifierTypeTargetPortGroup = 5,
    VpdIdentifierTypeLogicalUnitGroup = 6,
    VpdIdentifierTypeMD5LogicalUnitId = 7,
    VpdIdentifierTypeSCSINameString = 8
} VPD_IDENTIFIER_TYPE, *PVPD_IDENTIFIER_TYPE;

typedef struct _VPD_IDENTIFICATION_DESCRIPTOR {
    UCHAR CodeSet : 4;          // VPD_CODE_SET
    UCHAR Reserved : 4;
    UCHAR IdentifierType : 4;   // VPD_IDENTIFIER_TYPE
    UCHAR Association : 2;
    UCHAR Reserved2 : 2;
    UCHAR Reserved3;
    UCHAR IdentifierLength;
#if !defined(__midl)
    UCHAR Identifier[0];
#endif
} VPD_IDENTIFICATION_DESCRIPTOR, *PVPD_IDENTIFICATION_DESCRIPTOR;

typedef struct _VPD_IDENTIFICATION_PAGE {
    UCHAR DeviceType : 5;
    UCHAR DeviceTypeQualifier : 3;
    UCHAR PageCode;
    UCHAR Reserved;
    UCHAR PageLength;


    //
    // The following field is actually a variable length array of identification
    // descriptors.  Unfortunately there's no C notation for an array of
    // variable length structures so we're forced to just pretend.
    //

#if !defined(__midl)
    // VPD_IDENTIFICATION_DESCRIPTOR Descriptors[0];
    UCHAR Descriptors[0];
#endif
} VPD_IDENTIFICATION_PAGE, *PVPD_IDENTIFICATION_PAGE;

//
// Supported Vital Product Data Pages Page (page code 0x00)
// Contains a list of the vital product data page cods supported by the target
// or logical unit.
//

typedef struct _VPD_SUPPORTED_PAGES_PAGE {
    UCHAR DeviceType : 5;
    UCHAR DeviceTypeQualifier : 3;
    UCHAR PageCode;
    UCHAR Reserved;
    UCHAR PageLength;
#if !defined(__midl)
    UCHAR SupportedPageList[0];
#endif
} VPD_SUPPORTED_PAGES_PAGE, *PVPD_SUPPORTED_PAGES_PAGE;
#pragma pack(pop, vpd_stuff)


#define VPD_MAX_BUFFER_SIZE         0xff

#define VPD_SUPPORTED_PAGES         0x00
#define VPD_SERIAL_NUMBER           0x80
#define VPD_DEVICE_IDENTIFIERS      0x83
#define VPD_MEDIA_SERIAL_NUMBER     0x84
#define VPD_SOFTWARE_INTERFACE_IDENTIFIERS 0x84
#define VPD_NETWORK_MANAGEMENT_ADDRESSES 0x85
#define VPD_EXTENDED_INQUIRY_DATA   0x86
#define VPD_MODE_PAGE_POLICY        0x87
#define VPD_SCSI_PORTS              0x88


//
// Persistent Reservation Definitions.
//

//
// PERSISTENT_RESERVE_* definitions
//

#define RESERVATION_ACTION_READ_KEYS                    0x00
#define RESERVATION_ACTION_READ_RESERVATIONS            0x01

#define RESERVATION_ACTION_REGISTER                     0x00
#define RESERVATION_ACTION_RESERVE                      0x01
#define RESERVATION_ACTION_RELEASE                      0x02
#define RESERVATION_ACTION_CLEAR                        0x03
#define RESERVATION_ACTION_PREEMPT                      0x04
#define RESERVATION_ACTION_PREEMPT_ABORT                0x05
#define RESERVATION_ACTION_REGISTER_IGNORE_EXISTING     0x06

#define RESERVATION_SCOPE_LU                            0x00
#define RESERVATION_SCOPE_ELEMENT                       0x02

#define RESERVATION_TYPE_WRITE_EXCLUSIVE                0x01
#define RESERVATION_TYPE_EXCLUSIVE                      0x03
#define RESERVATION_TYPE_WRITE_EXCLUSIVE_REGISTRANTS    0x05
#define RESERVATION_TYPE_EXCLUSIVE_REGISTRANTS          0x06

//
// Structures for reserve in command.
//

#pragma pack(push, reserve_in_stuff, 1)
typedef struct {
    UCHAR Generation[4];
    UCHAR AdditionalLength[4];
#if !defined(__midl)
    UCHAR ReservationKeyList[0][8];
#endif
} PRI_REGISTRATION_LIST, *PPRI_REGISTRATION_LIST;

typedef struct {
    UCHAR ReservationKey[8];
    UCHAR ScopeSpecificAddress[4];
    UCHAR Reserved;
    UCHAR Type : 4;
    UCHAR Scope : 4;
    UCHAR Obsolete[2];
} PRI_RESERVATION_DESCRIPTOR, *PPRI_RESERVATION_DESCRIPTOR;

typedef struct {
    UCHAR Generation[4];
    UCHAR AdditionalLength[4];
#if !defined(__midl)
    PRI_RESERVATION_DESCRIPTOR Reservations[0];
#endif
} PRI_RESERVATION_LIST, *PPRI_RESERVATION_LIST;
#pragma pack(pop, reserve_in_stuff)

//
// Structures for reserve out command.
//

#pragma pack(push, reserve_out_stuff, 1)
typedef struct {
    UCHAR ReservationKey[8];
    UCHAR ServiceActionReservationKey[8];
    UCHAR ScopeSpecificAddress[4];
    UCHAR ActivatePersistThroughPowerLoss : 1;
    UCHAR Reserved1 : 7;
    UCHAR Reserved2;
    UCHAR Obsolete[2];
} PRO_PARAMETER_LIST, *PPRO_PARAMETER_LIST;
#pragma pack(pop, reserve_out_stuff)


//
// Sense Data Format
//

#pragma pack(push, sensedata, 1)
typedef struct _SENSE_DATA {
    UCHAR ErrorCode:7;
    UCHAR Valid:1;
    UCHAR SegmentNumber;
    UCHAR SenseKey:4;
    UCHAR Reserved:1;
    UCHAR IncorrectLength:1;
    UCHAR EndOfMedia:1;
    UCHAR FileMark:1;
    UCHAR Information[4];
    UCHAR AdditionalSenseLength;
    UCHAR CommandSpecificInformation[4];
    UCHAR AdditionalSenseCode;
    UCHAR AdditionalSenseCodeQualifier;
    UCHAR FieldReplaceableUnitCode;
    UCHAR SenseKeySpecific[3];
} SENSE_DATA, *PSENSE_DATA;
#pragma pack(pop, sensedata)

//
// Default request sense buffer size
//

#define SENSE_BUFFER_SIZE 18

//
// Maximum request sense buffer size
//

#define MAX_SENSE_BUFFER_SIZE 255

//
// Maximum number of additional sense bytes.
//

#define MAX_ADDITIONAL_SENSE_BYTES (MAX_SENSE_BUFFER_SIZE - SENSE_BUFFER_SIZE)

//
// Sense codes
//

#define SCSI_SENSE_NO_SENSE         0x00
#define SCSI_SENSE_RECOVERED_ERROR  0x01
#define SCSI_SENSE_NOT_READY        0x02
#define SCSI_SENSE_MEDIUM_ERROR     0x03
#define SCSI_SENSE_HARDWARE_ERROR   0x04
#define SCSI_SENSE_ILLEGAL_REQUEST  0x05
#define SCSI_SENSE_UNIT_ATTENTION   0x06
#define SCSI_SENSE_DATA_PROTECT     0x07
#define SCSI_SENSE_BLANK_CHECK      0x08
#define SCSI_SENSE_UNIQUE           0x09
#define SCSI_SENSE_COPY_ABORTED     0x0A
#define SCSI_SENSE_ABORTED_COMMAND  0x0B
#define SCSI_SENSE_EQUAL            0x0C
#define SCSI_SENSE_VOL_OVERFLOW     0x0D
#define SCSI_SENSE_MISCOMPARE       0x0E
#define SCSI_SENSE_RESERVED         0x0F

//
// Additional tape bit
//

#define SCSI_ILLEGAL_LENGTH         0x20
#define SCSI_EOM                    0x40
#define SCSI_FILE_MARK              0x80

//
// Additional Sense codes
//

#define SCSI_ADSENSE_NO_SENSE                              0x00
#define SCSI_ADSENSE_NO_SEEK_COMPLETE                      0x02
#define SCSI_ADSENSE_LUN_NOT_READY                         0x04
#define SCSI_ADSENSE_LUN_COMMUNICATION                     0x08
#define SCSI_ADSENSE_WRITE_ERROR                           0x0C
#define SCSI_ADSENSE_TRACK_ERROR                           0x14
#define SCSI_ADSENSE_SEEK_ERROR                            0x15
#define SCSI_ADSENSE_REC_DATA_NOECC                        0x17
#define SCSI_ADSENSE_REC_DATA_ECC                          0x18
#define SCSI_ADSENSE_PARAMETER_LIST_LENGTH                 0x1A
#define SCSI_ADSENSE_ILLEGAL_COMMAND                       0x20
#define SCSI_ADSENSE_ILLEGAL_BLOCK                         0x21
#define SCSI_ADSENSE_INVALID_CDB                           0x24
#define SCSI_ADSENSE_INVALID_LUN                           0x25
#define SCSI_ADSENSE_INVALID_FIELD_PARAMETER_LIST          0x26
#define SCSI_ADSENSE_WRITE_PROTECT                         0x27
#define SCSI_ADSENSE_MEDIUM_CHANGED                        0x28
#define SCSI_ADSENSE_BUS_RESET                             0x29
#define SCSI_ADSENSE_PARAMETERS_CHANGED                    0x2A
#define SCSI_ADSENSE_INSUFFICIENT_TIME_FOR_OPERATION       0x2E
#define SCSI_ADSENSE_INVALID_MEDIA                         0x30
#define SCSI_ADSENSE_NO_MEDIA_IN_DEVICE                    0x3a
#define SCSI_ADSENSE_POSITION_ERROR                        0x3b
#define SCSI_ADSENSE_OPERATING_CONDITIONS_CHANGED          0x3f
#define SCSI_ADSENSE_OPERATOR_REQUEST                      0x5a // see below
#define SCSI_ADSENSE_FAILURE_PREDICTION_THRESHOLD_EXCEEDED 0x5d
#define SCSI_ADSENSE_ILLEGAL_MODE_FOR_THIS_TRACK           0x64
#define SCSI_ADSENSE_COPY_PROTECTION_FAILURE               0x6f
#define SCSI_ADSENSE_POWER_CALIBRATION_ERROR               0x73
#define SCSI_ADSENSE_VENDOR_UNIQUE                         0x80 // and higher
#define SCSI_ADSENSE_MUSIC_AREA                            0xA0
#define SCSI_ADSENSE_DATA_AREA                             0xA1
#define SCSI_ADSENSE_VOLUME_OVERFLOW                       0xA7

// for legacy apps:
#define SCSI_ADWRITE_PROTECT                        SCSI_ADSENSE_WRITE_PROTECT
#define SCSI_FAILURE_PREDICTION_THRESHOLD_EXCEEDED  SCSI_ADSENSE_FAILURE_PREDICTION_THRESHOLD_EXCEEDED


//
// SCSI_ADSENSE_LUN_NOT_READY (0x04) qualifiers
//

#define SCSI_SENSEQ_CAUSE_NOT_REPORTABLE         0x00
#define SCSI_SENSEQ_BECOMING_READY               0x01
#define SCSI_SENSEQ_INIT_COMMAND_REQUIRED        0x02
#define SCSI_SENSEQ_MANUAL_INTERVENTION_REQUIRED 0x03
#define SCSI_SENSEQ_FORMAT_IN_PROGRESS           0x04
#define SCSI_SENSEQ_REBUILD_IN_PROGRESS          0x05
#define SCSI_SENSEQ_RECALCULATION_IN_PROGRESS    0x06
#define SCSI_SENSEQ_OPERATION_IN_PROGRESS        0x07
#define SCSI_SENSEQ_LONG_WRITE_IN_PROGRESS       0x08

//
// SCSI_ADSENSE_LUN_COMMUNICATION (0x08) qualifiers
//

#define SCSI_SENSEQ_COMM_FAILURE                 0x00
#define SCSI_SENSEQ_COMM_TIMEOUT                 0x01
#define SCSI_SENSEQ_COMM_PARITY_ERROR            0x02
#define SCSI_SESNEQ_COMM_CRC_ERROR               0x03
#define SCSI_SENSEQ_UNREACHABLE_TARGET           0x04

//
// SCSI_ADSENSE_WRITE_ERROR (0x0C) qualifiers
//
#define SCSI_SENSEQ_LOSS_OF_STREAMING            0x09
#define SCSI_SENSEQ_PADDING_BLOCKS_ADDED         0x0A


//
// SCSI_ADSENSE_NO_SENSE (0x00) qualifiers
//

#define SCSI_SENSEQ_FILEMARK_DETECTED 0x01
#define SCSI_SENSEQ_END_OF_MEDIA_DETECTED 0x02
#define SCSI_SENSEQ_SETMARK_DETECTED 0x03
#define SCSI_SENSEQ_BEGINNING_OF_MEDIA_DETECTED 0x04

//
// SCSI_ADSENSE_ILLEGAL_BLOCK (0x21) qualifiers
//

#define SCSI_SENSEQ_ILLEGAL_ELEMENT_ADDR 0x01

//
// SCSI_ADSENSE_POSITION_ERROR (0x3b) qualifiers
//

#define SCSI_SENSEQ_DESTINATION_FULL 0x0d
#define SCSI_SENSEQ_SOURCE_EMPTY     0x0e

//
// SCSI_ADSENSE_INVALID_MEDIA (0x30) qualifiers
//

#define SCSI_SENSEQ_INCOMPATIBLE_MEDIA_INSTALLED 0x00
#define SCSI_SENSEQ_UNKNOWN_FORMAT 0x01
#define SCSI_SENSEQ_INCOMPATIBLE_FORMAT 0x02
#define SCSI_SENSEQ_CLEANING_CARTRIDGE_INSTALLED 0x03


//
// SCSI_ADSENSE_OPERATING_CONDITIONS_CHANGED (0x3f) qualifiers
//

#define SCSI_SENSEQ_TARGET_OPERATING_CONDITIONS_CHANGED 0x00
#define SCSI_SENSEQ_MICROCODE_CHANGED                   0x01
#define SCSI_SENSEQ_OPERATING_DEFINITION_CHANGED        0x02
#define SCSI_SENSEQ_INQUIRY_DATA_CHANGED                0x03
#define SCSI_SENSEQ_COMPONENT_DEVICE_ATTACHED           0x04
#define SCSI_SENSEQ_DEVICE_IDENTIFIER_CHANGED           0x05
#define SCSI_SENSEQ_REDUNDANCY_GROUP_MODIFIED           0x06
#define SCSI_SENSEQ_REDUNDANCY_GROUP_DELETED            0x07
#define SCSI_SENSEQ_SPARE_MODIFIED                      0x08
#define SCSI_SENSEQ_SPARE_DELETED                       0x09
#define SCSI_SENSEQ_VOLUME_SET_MODIFIED                 0x0A
#define SCSI_SENSEQ_VOLUME_SET_DELETED                  0x0B
#define SCSI_SENSEQ_VOLUME_SET_DEASSIGNED               0x0C
#define SCSI_SENSEQ_VOLUME_SET_REASSIGNED               0x0D
#define SCSI_SENSEQ_REPORTED_LUNS_DATA_CHANGED          0x0E
#define SCSI_SENSEQ_ECHO_BUFFER_OVERWRITTEN             0x0F
#define SCSI_SENSEQ_MEDIUM_LOADABLE                     0x10
#define SCSI_SENSEQ_MEDIUM_AUXILIARY_MEMORY_ACCESSIBLE  0x11


//
// SCSI_ADSENSE_OPERATOR_REQUEST (0x5a) qualifiers
//

#define SCSI_SENSEQ_STATE_CHANGE_INPUT     0x00 // generic request
#define SCSI_SENSEQ_MEDIUM_REMOVAL         0x01
#define SCSI_SENSEQ_WRITE_PROTECT_ENABLE   0x02
#define SCSI_SENSEQ_WRITE_PROTECT_DISABLE  0x03

//
// SCSI_ADSENSE_COPY_PROTECTION_FAILURE (0x6f) qualifiers
//
#define SCSI_SENSEQ_AUTHENTICATION_FAILURE                          0x00
#define SCSI_SENSEQ_KEY_NOT_PRESENT                                 0x01
#define SCSI_SENSEQ_KEY_NOT_ESTABLISHED                             0x02
#define SCSI_SENSEQ_READ_OF_SCRAMBLED_SECTOR_WITHOUT_AUTHENTICATION 0x03
#define SCSI_SENSEQ_MEDIA_CODE_MISMATCHED_TO_LOGICAL_UNIT           0x04
#define SCSI_SENSEQ_LOGICAL_UNIT_RESET_COUNT_ERROR                  0x05

//
// SCSI_ADSENSE_POWER_CALIBRATION_ERROR (0x73) qualifiers
//

#define SCSI_SENSEQ_POWER_CALIBRATION_AREA_ALMOST_FULL 0x01
#define SCSI_SENSEQ_POWER_CALIBRATION_AREA_FULL        0x02
#define SCSI_SENSEQ_POWER_CALIBRATION_AREA_ERROR       0x03
#define SCSI_SENSEQ_PMA_RMA_UPDATE_FAILURE             0x04
#define SCSI_SENSEQ_PMA_RMA_IS_FULL                    0x05
#define SCSI_SENSEQ_PMA_RMA_ALMOST_FULL                0x06


// end_ntminitape

//
// SCSI IO Device Control Codes
//

#define FILE_DEVICE_SCSI 0x0000001b

#define IOCTL_SCSI_EXECUTE_IN   ((FILE_DEVICE_SCSI << 16) + 0x0011)
#define IOCTL_SCSI_EXECUTE_OUT  ((FILE_DEVICE_SCSI << 16) + 0x0012)
#define IOCTL_SCSI_EXECUTE_NONE ((FILE_DEVICE_SCSI << 16) + 0x0013)

//
// SMART support in atapi
//

#define IOCTL_SCSI_MINIPORT_SMART_VERSION           ((FILE_DEVICE_SCSI << 16) + 0x0500)
#define IOCTL_SCSI_MINIPORT_IDENTIFY                ((FILE_DEVICE_SCSI << 16) + 0x0501)
#define IOCTL_SCSI_MINIPORT_READ_SMART_ATTRIBS      ((FILE_DEVICE_SCSI << 16) + 0x0502)
#define IOCTL_SCSI_MINIPORT_READ_SMART_THRESHOLDS   ((FILE_DEVICE_SCSI << 16) + 0x0503)
#define IOCTL_SCSI_MINIPORT_ENABLE_SMART            ((FILE_DEVICE_SCSI << 16) + 0x0504)
#define IOCTL_SCSI_MINIPORT_DISABLE_SMART           ((FILE_DEVICE_SCSI << 16) + 0x0505)
#define IOCTL_SCSI_MINIPORT_RETURN_STATUS           ((FILE_DEVICE_SCSI << 16) + 0x0506)
#define IOCTL_SCSI_MINIPORT_ENABLE_DISABLE_AUTOSAVE ((FILE_DEVICE_SCSI << 16) + 0x0507)
#define IOCTL_SCSI_MINIPORT_SAVE_ATTRIBUTE_VALUES   ((FILE_DEVICE_SCSI << 16) + 0x0508)
#define IOCTL_SCSI_MINIPORT_EXECUTE_OFFLINE_DIAGS   ((FILE_DEVICE_SCSI << 16) + 0x0509)
#define IOCTL_SCSI_MINIPORT_ENABLE_DISABLE_AUTO_OFFLINE ((FILE_DEVICE_SCSI << 16) + 0x050a)
#define IOCTL_SCSI_MINIPORT_READ_SMART_LOG          ((FILE_DEVICE_SCSI << 16) + 0x050b)
#define IOCTL_SCSI_MINIPORT_WRITE_SMART_LOG         ((FILE_DEVICE_SCSI << 16) + 0x050c)

//
// CLUSTER support
// deliberately skipped some values to allow for expansion above.
//
#define IOCTL_SCSI_MINIPORT_NOT_QUORUM_CAPABLE     ((FILE_DEVICE_SCSI << 16) + 0x0520)
#define IOCTL_SCSI_MINIPORT_NOT_CLUSTER_CAPABLE    ((FILE_DEVICE_SCSI << 16) + 0x0521)


// begin_ntminitape

//
// Read Capacity Data - returned in Big Endian format
//

#pragma pack(push, read_capacity, 1)
typedef struct _READ_CAPACITY_DATA {
    ULONG LogicalBlockAddress;
    ULONG BytesPerBlock;
} READ_CAPACITY_DATA, *PREAD_CAPACITY_DATA;
#pragma pack(pop, read_capacity)


#pragma pack(push, read_capacity_ex, 1)
typedef struct _READ_CAPACITY_DATA_EX {
    LARGE_INTEGER LogicalBlockAddress;
    ULONG BytesPerBlock;
} READ_CAPACITY_DATA_EX, *PREAD_CAPACITY_DATA_EX;
#pragma pack(pop, read_capacity_ex)


//
// Read Block Limits Data - returned in Big Endian format
// This structure returns the maximum and minimum block
// size for a TAPE device.
//

#pragma pack(push, read_block_limits, 1)
typedef struct _READ_BLOCK_LIMITS {
    UCHAR Reserved;
    UCHAR BlockMaximumSize[3];
    UCHAR BlockMinimumSize[2];
} READ_BLOCK_LIMITS_DATA, *PREAD_BLOCK_LIMITS_DATA;
#pragma pack(pop, read_block_limits)

#pragma pack(push, read_buffer_capacity, 1)
typedef struct _READ_BUFFER_CAPACITY_DATA {
    UCHAR DataLength[2];
    UCHAR Reserved1;
    UCHAR BlockDataReturned : 1;
    UCHAR Reserved4         : 7;
    UCHAR TotalBufferSize[4];
    UCHAR AvailableBufferSize[4];
} READ_BUFFER_CAPACITY_DATA, *PREAD_BUFFER_CAPACITY_DATA;
#pragma pack(pop, read_buffer_capacity)

//
// Mode data structures.
//

//
// Define Mode parameter header.
//

#pragma pack(push, mode_params, 1)
typedef struct _MODE_PARAMETER_HEADER {
    UCHAR ModeDataLength;
    UCHAR MediumType;
    UCHAR DeviceSpecificParameter;
    UCHAR BlockDescriptorLength;
}MODE_PARAMETER_HEADER, *PMODE_PARAMETER_HEADER;

typedef struct _MODE_PARAMETER_HEADER10 {
    UCHAR ModeDataLength[2];
    UCHAR MediumType;
    UCHAR DeviceSpecificParameter;
    UCHAR Reserved[2];
    UCHAR BlockDescriptorLength[2];
}MODE_PARAMETER_HEADER10, *PMODE_PARAMETER_HEADER10;
#pragma pack(pop, mode_params)

#define MODE_FD_SINGLE_SIDE     0x01
#define MODE_FD_DOUBLE_SIDE     0x02
#define MODE_FD_MAXIMUM_TYPE    0x1E
#define MODE_DSP_FUA_SUPPORTED  0x10
#define MODE_DSP_WRITE_PROTECT  0x80

//
// Define the mode parameter block.
//

#pragma pack(push, mode_params_block, 1)
typedef struct _MODE_PARAMETER_BLOCK {
    UCHAR DensityCode;
    UCHAR NumberOfBlocks[3];
    UCHAR Reserved;
    UCHAR BlockLength[3];
}MODE_PARAMETER_BLOCK, *PMODE_PARAMETER_BLOCK;
#pragma pack(pop, mode_params_block)

//
// Define Disconnect-Reconnect page.
//


#pragma pack(push, mode_page_disconnect, 1)
typedef struct _MODE_DISCONNECT_PAGE {
    UCHAR PageCode : 6;
    UCHAR Reserved : 1;
    UCHAR PageSavable : 1;
    UCHAR PageLength;
    UCHAR BufferFullRatio;
    UCHAR BufferEmptyRatio;
    UCHAR BusInactivityLimit[2];
    UCHAR BusDisconnectTime[2];
    UCHAR BusConnectTime[2];
    UCHAR MaximumBurstSize[2];
    UCHAR DataTransferDisconnect : 2;
    UCHAR Reserved2[3];
}MODE_DISCONNECT_PAGE, *PMODE_DISCONNECT_PAGE;
#pragma pack(pop, mode_page_disconnect)

//
// Define mode caching page.
//

#pragma pack(push, mode_page_caching, 1)
typedef struct _MODE_CACHING_PAGE {
    UCHAR PageCode : 6;
    UCHAR Reserved : 1;
    UCHAR PageSavable : 1;
    UCHAR PageLength;
    UCHAR ReadDisableCache : 1;
    UCHAR MultiplicationFactor : 1;
    UCHAR WriteCacheEnable : 1;
    UCHAR Reserved2 : 5;
    UCHAR WriteRetensionPriority : 4;
    UCHAR ReadRetensionPriority : 4;
    UCHAR DisablePrefetchTransfer[2];
    UCHAR MinimumPrefetch[2];
    UCHAR MaximumPrefetch[2];
    UCHAR MaximumPrefetchCeiling[2];
}MODE_CACHING_PAGE, *PMODE_CACHING_PAGE;
#pragma pack(pop, mode_page_caching)

//
// Define write parameters cdrom page
//
#pragma pack(push, mode_page_wp2, 1)
typedef struct _MODE_CDROM_WRITE_PARAMETERS_PAGE2 {
    UCHAR PageCode : 6;             // 0x05
    UCHAR Reserved : 1;
    UCHAR PageSavable : 1;
    UCHAR PageLength;               // 0x32 ??
    UCHAR WriteType                 : 4;
    UCHAR TestWrite                 : 1;
    UCHAR LinkSizeValid             : 1;
    UCHAR BufferUnderrunFreeEnabled : 1;
    UCHAR Reserved2                 : 1;
    UCHAR TrackMode                 : 4;
    UCHAR Copy                      : 1;
    UCHAR FixedPacket               : 1;
    UCHAR MultiSession              : 2;
    UCHAR DataBlockType             : 4;
    UCHAR Reserved3                 : 4;
    UCHAR LinkSize;
    UCHAR Reserved4;
    UCHAR HostApplicationCode       : 6;
    UCHAR Reserved5                 : 2;
    UCHAR SessionFormat;
    UCHAR Reserved6;
    UCHAR PacketSize[4];
    UCHAR AudioPauseLength[2];
    UCHAR MediaCatalogNumber[16];
    UCHAR ISRC[16];
    UCHAR SubHeaderData[4];
} MODE_CDROM_WRITE_PARAMETERS_PAGE2, *PMODE_CDROM_WRITE_PARAMETERS_PAGE2;
#pragma pack(pop, mode_page_wp2)

#ifndef DEPRECATE_DDK_FUNCTIONS
// this structure is being retired due to missing fields and overly
// complex data definitions for the MCN and ISRC.
#pragma pack(push, mode_page_wp, 1)
typedef struct _MODE_CDROM_WRITE_PARAMETERS_PAGE {
    UCHAR PageLength;               // 0x32 ??
    UCHAR WriteType                 : 4;
    UCHAR TestWrite                 : 1;
    UCHAR LinkSizeValid             : 1;
    UCHAR BufferUnderrunFreeEnabled : 1;
    UCHAR Reserved2                 : 1;
    UCHAR TrackMode                 : 4;
    UCHAR Copy                      : 1;
    UCHAR FixedPacket               : 1;
    UCHAR MultiSession              : 2;
    UCHAR DataBlockType             : 4;
    UCHAR Reserved3                 : 4;
    UCHAR LinkSize;
    UCHAR Reserved4;
    UCHAR HostApplicationCode       : 6;
    UCHAR Reserved5                 : 2;
    UCHAR SessionFormat;
    UCHAR Reserved6;
    UCHAR PacketSize[4];
    UCHAR AudioPauseLength[2];
    UCHAR Reserved7                 : 7;
    UCHAR MediaCatalogNumberValid   : 1;
    UCHAR MediaCatalogNumber[13];
    UCHAR MediaCatalogNumberZero;
    UCHAR MediaCatalogNumberAFrame;
    UCHAR Reserved8                 : 7;
    UCHAR ISRCValid                 : 1;
    UCHAR ISRCCountry[2];
    UCHAR ISRCOwner[3];
    UCHAR ISRCRecordingYear[2];
    UCHAR ISRCSerialNumber[5];
    UCHAR ISRCZero;
    UCHAR ISRCAFrame;
    UCHAR ISRCReserved;
    UCHAR SubHeaderData[4];
} MODE_CDROM_WRITE_PARAMETERS_PAGE, *PMODE_CDROM_WRITE_PARAMETERS_PAGE;
#pragma pack(pop, mode_page_wp)
#endif //ifndef DEPRECATE_DDK_FUNCTIONS

//
// Define the MRW mode page for CDROM device types
//
#pragma pack(push, mode_page_mrw, 1)
typedef struct _MODE_MRW_PAGE {
    UCHAR PageCode : 6; // 0x03
    UCHAR Reserved : 1;
    UCHAR PageSavable : 1;
    UCHAR PageLength;   //0x06
    UCHAR Reserved1;
    UCHAR LbaSpace  : 1;
    UCHAR Reserved2 : 7;
    UCHAR Reserved3[4];
} MODE_MRW_PAGE, *PMODE_MRW_PAGE;
#pragma pack(pop, mode_page_mrw)

//
// Define mode flexible disk page.
//

#pragma pack(push, mode_page_flex, 1)
typedef struct _MODE_FLEXIBLE_DISK_PAGE {
    UCHAR PageCode : 6;
    UCHAR Reserved : 1;
    UCHAR PageSavable : 1;
    UCHAR PageLength;
    UCHAR TransferRate[2];
    UCHAR NumberOfHeads;
    UCHAR SectorsPerTrack;
    UCHAR BytesPerSector[2];
    UCHAR NumberOfCylinders[2];
    UCHAR StartWritePrecom[2];
    UCHAR StartReducedCurrent[2];
    UCHAR StepRate[2];
    UCHAR StepPluseWidth;
    UCHAR HeadSettleDelay[2];
    UCHAR MotorOnDelay;
    UCHAR MotorOffDelay;
    UCHAR Reserved2 : 5;
    UCHAR MotorOnAsserted : 1;
    UCHAR StartSectorNumber : 1;
    UCHAR TrueReadySignal : 1;
    UCHAR StepPlusePerCyclynder : 4;
    UCHAR Reserved3 : 4;
    UCHAR WriteCompenstation;
    UCHAR HeadLoadDelay;
    UCHAR HeadUnloadDelay;
    UCHAR Pin2Usage : 4;
    UCHAR Pin34Usage : 4;
    UCHAR Pin1Usage : 4;
    UCHAR Pin4Usage : 4;
    UCHAR MediumRotationRate[2];
    UCHAR Reserved4[2];
} MODE_FLEXIBLE_DISK_PAGE, *PMODE_FLEXIBLE_DISK_PAGE;
#pragma pack(pop, mode_page_flex)

//
// Define mode format page.
//

#pragma pack(push, mode_page_format, 1)
typedef struct _MODE_FORMAT_PAGE {
    UCHAR PageCode : 6;
    UCHAR Reserved : 1;
    UCHAR PageSavable : 1;
    UCHAR PageLength;
    UCHAR TracksPerZone[2];
    UCHAR AlternateSectorsPerZone[2];
    UCHAR AlternateTracksPerZone[2];
    UCHAR AlternateTracksPerLogicalUnit[2];
    UCHAR SectorsPerTrack[2];
    UCHAR BytesPerPhysicalSector[2];
    UCHAR Interleave[2];
    UCHAR TrackSkewFactor[2];
    UCHAR CylinderSkewFactor[2];
    UCHAR Reserved2 : 4;
    UCHAR SurfaceFirst : 1;
    UCHAR RemovableMedia : 1;
    UCHAR HardSectorFormating : 1;
    UCHAR SoftSectorFormating : 1;
    UCHAR Reserved3[3];
} MODE_FORMAT_PAGE, *PMODE_FORMAT_PAGE;
#pragma pack(pop, mode_page_format)

//
// Define rigid disk driver geometry page.
//

#pragma pack(push, mode_page_geometry, 1)
typedef struct _MODE_RIGID_GEOMETRY_PAGE {
    UCHAR PageCode : 6;
    UCHAR Reserved : 1;
    UCHAR PageSavable : 1;
    UCHAR PageLength;
    UCHAR NumberOfCylinders[3];
    UCHAR NumberOfHeads;
    UCHAR StartWritePrecom[3];
    UCHAR StartReducedCurrent[3];
    UCHAR DriveStepRate[2];
    UCHAR LandZoneCyclinder[3];
    UCHAR RotationalPositionLock : 2;
    UCHAR Reserved2 : 6;
    UCHAR RotationOffset;
    UCHAR Reserved3;
    UCHAR RoataionRate[2];
    UCHAR Reserved4[2];
}MODE_RIGID_GEOMETRY_PAGE, *PMODE_RIGID_GEOMETRY_PAGE;
#pragma pack(pop, mode_page_geometry)

//
// Define read write recovery page
//

#pragma pack(push, mode_page_rw_recovery, 1)
typedef struct _MODE_READ_WRITE_RECOVERY_PAGE {

    UCHAR PageCode : 6;
    UCHAR Reserved1 : 1;
    UCHAR PSBit : 1;
    UCHAR PageLength;
    UCHAR DCRBit : 1;
    UCHAR DTEBit : 1;
    UCHAR PERBit : 1;
    UCHAR EERBit : 1;
    UCHAR RCBit : 1;
    UCHAR TBBit : 1;
    UCHAR ARRE : 1;
    UCHAR AWRE : 1;
    UCHAR ReadRetryCount;
    UCHAR Reserved4[4];
    UCHAR WriteRetryCount;
    UCHAR Reserved5[3];

} MODE_READ_WRITE_RECOVERY_PAGE, *PMODE_READ_WRITE_RECOVERY_PAGE;
#pragma pack(pop, mode_page_rw_recovery)

//
// Define read recovery page - cdrom
//

#pragma pack(push, mode_page_r_recovery, 1)
typedef struct _MODE_READ_RECOVERY_PAGE {

    UCHAR PageCode : 6;
    UCHAR Reserved1 : 1;
    UCHAR PSBit : 1;
    UCHAR PageLength;
    UCHAR DCRBit : 1;
    UCHAR DTEBit : 1;
    UCHAR PERBit : 1;
    UCHAR Reserved2 : 1;
    UCHAR RCBit : 1;
    UCHAR TBBit : 1;
    UCHAR Reserved3 : 2;
    UCHAR ReadRetryCount;
    UCHAR Reserved4[4];

} MODE_READ_RECOVERY_PAGE, *PMODE_READ_RECOVERY_PAGE;
#pragma pack(pop, mode_page_r_recovery)


//
// Define Informational Exception Control Page. Used for failure prediction
//

#pragma pack(push, mode_page_xcpt, 1)
typedef struct _MODE_INFO_EXCEPTIONS
{
    UCHAR PageCode : 6;
    UCHAR Reserved1 : 1;
    UCHAR PSBit : 1;

    UCHAR PageLength;

    union
    {
        UCHAR Flags;
        struct
        {
            UCHAR LogErr : 1;
            UCHAR Reserved2 : 1;
            UCHAR Test : 1;
            UCHAR Dexcpt : 1;
            UCHAR Reserved3 : 3;
            UCHAR Perf : 1;
        };
    };

    UCHAR ReportMethod : 4;
    UCHAR Reserved4 : 4;

    UCHAR IntervalTimer[4];
    UCHAR ReportCount[4];

} MODE_INFO_EXCEPTIONS, *PMODE_INFO_EXCEPTIONS;
#pragma pack(pop, mode_page_xcpt)

//
// Begin C/DVD 0.9 definitions
//

//
// Power Condition Mode Page Format
//

#pragma pack(push, mode_page_power, 1)
typedef struct _POWER_CONDITION_PAGE {
    UCHAR PageCode : 6;         // 0x1A
    UCHAR Reserved : 1;
    UCHAR PSBit : 1;
    UCHAR PageLength;           // 0x0A
    UCHAR Reserved2;

    UCHAR Standby : 1;
    UCHAR Idle : 1;
    UCHAR Reserved3 : 6;

    UCHAR IdleTimer[4];
    UCHAR StandbyTimer[4];
} POWER_CONDITION_PAGE, *PPOWER_CONDITION_PAGE;
#pragma pack(pop, mode_page_power)

//
// CD-Audio Control Mode Page Format
//

#pragma pack(push, mode_page_cdaudio, 1)
typedef struct _CDDA_OUTPUT_PORT {
    UCHAR ChannelSelection : 4;
    UCHAR Reserved : 4;
    UCHAR Volume;
} CDDA_OUTPUT_PORT, *PCDDA_OUTPUT_PORT;

typedef struct _CDAUDIO_CONTROL_PAGE {
    UCHAR PageCode : 6;     // 0x0E
    UCHAR Reserved : 1;
    UCHAR PSBit : 1;

    UCHAR PageLength;       // 0x0E

    UCHAR Reserved2 : 1;
    UCHAR StopOnTrackCrossing : 1;         // Default 0
    UCHAR Immediate : 1;    // Always 1
    UCHAR Reserved3 : 5;

    UCHAR Reserved4[3];
    UCHAR Obsolete[2];

    CDDA_OUTPUT_PORT CDDAOutputPorts[4];

} CDAUDIO_CONTROL_PAGE, *PCDAUDIO_CONTROL_PAGE;
#pragma pack(pop, mode_page_cdaudio)

#define CDDA_CHANNEL_MUTED      0x0
#define CDDA_CHANNEL_ZERO       0x1
#define CDDA_CHANNEL_ONE        0x2
#define CDDA_CHANNEL_TWO        0x4
#define CDDA_CHANNEL_THREE      0x8

//
// C/DVD Feature Set Support & Version Page
//

#pragma pack(push, mode_page_features, 1)
typedef struct _CDVD_FEATURE_SET_PAGE {
    UCHAR PageCode : 6;     // 0x18
    UCHAR Reserved : 1;
    UCHAR PSBit : 1;

    UCHAR PageLength;       // 0x16

    UCHAR CDAudio[2];
    UCHAR EmbeddedChanger[2];
    UCHAR PacketSMART[2];
    UCHAR PersistantPrevent[2];
    UCHAR EventStatusNotification[2];
    UCHAR DigitalOutput[2];
    UCHAR CDSequentialRecordable[2];
    UCHAR DVDSequentialRecordable[2];
    UCHAR RandomRecordable[2];
    UCHAR KeyExchange[2];
    UCHAR Reserved2[2];
} CDVD_FEATURE_SET_PAGE, *PCDVD_FEATURE_SET_PAGE;
#pragma pack(pop, mode_page_features)

//
// CDVD Inactivity Time-out Page Format
//

#pragma pack(push, mode_page_timeout, 1)
typedef struct _CDVD_INACTIVITY_TIMEOUT_PAGE {
    UCHAR PageCode : 6;     // 0x1D
    UCHAR Reserved : 1;
    UCHAR PSBit : 1;

    UCHAR PageLength;       // 0x08
    UCHAR Reserved2[2];

    UCHAR SWPP : 1;
    UCHAR DISP : 1;
    UCHAR Reserved3 : 6;

    UCHAR Reserved4;
    UCHAR GroupOneMinimumTimeout[2];
    UCHAR GroupTwoMinimumTimeout[2];
} CDVD_INACTIVITY_TIMEOUT_PAGE, *PCDVD_INACTIVITY_TIMEOUT_PAGE;
#pragma pack(pop, mode_page_timeout)

//
// CDVD Capabilities & Mechanism Status Page
//

#define CDVD_LMT_CADDY              0
#define CDVD_LMT_TRAY               1
#define CDVD_LMT_POPUP              2
#define CDVD_LMT_RESERVED1          3
#define CDVD_LMT_CHANGER_INDIVIDUAL 4
#define CDVD_LMT_CHANGER_CARTRIDGE  5
#define CDVD_LMT_RESERVED2          6
#define CDVD_LMT_RESERVED3          7


#pragma pack(push, mode_page_capabilities, 1)
typedef struct _CDVD_CAPABILITIES_PAGE {
    UCHAR PageCode : 6;     // 0x2A
    UCHAR Reserved : 1;
    UCHAR PSBit : 1;                        // offset 0

    UCHAR PageLength;       // >= 0x18      // offset 1

    UCHAR CDRRead : 1;
    UCHAR CDERead : 1;
    UCHAR Method2 : 1;
    UCHAR DVDROMRead : 1;
    UCHAR DVDRRead : 1;
    UCHAR DVDRAMRead : 1;
    UCHAR Reserved2 : 2;                    // offset 2

    UCHAR CDRWrite : 1;
    UCHAR CDEWrite : 1;
    UCHAR TestWrite : 1;
    UCHAR Reserved3 : 1;
    UCHAR DVDRWrite : 1;
    UCHAR DVDRAMWrite : 1;
    UCHAR Reserved4 : 2;                    // offset 3

    UCHAR AudioPlay : 1;
    UCHAR Composite : 1;
    UCHAR DigitalPortOne : 1;
    UCHAR DigitalPortTwo : 1;
    UCHAR Mode2Form1 : 1;
    UCHAR Mode2Form2 : 1;
    UCHAR MultiSession : 1;
    UCHAR BufferUnderrunFree : 1;                    // offset 4

    UCHAR CDDA : 1;
    UCHAR CDDAAccurate : 1;
    UCHAR RWSupported : 1;
    UCHAR RWDeinterleaved : 1;
    UCHAR C2Pointers : 1;
    UCHAR ISRC : 1;
    UCHAR UPC : 1;
    UCHAR ReadBarCodeCapable : 1;           // offset 5

    UCHAR Lock : 1;
    UCHAR LockState : 1;
    UCHAR PreventJumper : 1;
    UCHAR Eject : 1;
    UCHAR Reserved6 : 1;
    UCHAR LoadingMechanismType : 3;         // offset 6

    UCHAR SeparateVolume : 1;
    UCHAR SeperateChannelMute : 1;
    UCHAR SupportsDiskPresent : 1;
    UCHAR SWSlotSelection : 1;
    UCHAR SideChangeCapable : 1;
    UCHAR RWInLeadInReadable : 1;
    UCHAR Reserved7 : 2;                    // offset 7

    union {
        UCHAR ReadSpeedMaximum[2];
        UCHAR ObsoleteReserved[2];          // offset 8
    };

    UCHAR NumberVolumeLevels[2];            // offset 10
    UCHAR BufferSize[2];                    // offset 12

    union {
        UCHAR ReadSpeedCurrent[2];
        UCHAR ObsoleteReserved2[2];         // offset 14
    };
    UCHAR ObsoleteReserved3;                // offset 16

    UCHAR Reserved8 : 1;
    UCHAR BCK : 1;
    UCHAR RCK : 1;
    UCHAR LSBF : 1;
    UCHAR Length : 2;
    UCHAR Reserved9 : 2;                    // offset 17

    union {
        UCHAR WriteSpeedMaximum[2];
        UCHAR ObsoleteReserved4[2];         // offset 18
    };
    union {
        UCHAR WriteSpeedCurrent[2];
        UCHAR ObsoleteReserved11[2];        // offset 20
    };

    //
    // NOTE: This mode page is two bytes too small in the release
    //       version of the Windows2000 DDK.  it also incorrectly
    //       put the CopyManagementRevision at offset 20 instead
    //       of offset 22, so fix that with a nameless union (for
    //       backwards-compatibility with those who "fixed" it on
    //       their own by looking at Reserved10[]).
    //

    union {
        UCHAR CopyManagementRevision[2];    // offset 22
        UCHAR Reserved10[2];
    };
    //UCHAR Reserved12[2];                    // offset 24

} CDVD_CAPABILITIES_PAGE, *PCDVD_CAPABILITIES_PAGE;
#pragma pack(pop, mode_page_capabilities)

#pragma pack(push, lun_list, 1)
typedef struct _LUN_LIST {
    UCHAR LunListLength[4]; // sizeof LunSize * 8
    UCHAR Reserved[4];
#if !defined(__midl)
    UCHAR Lun[0][8];        // 4 level of addressing.  2 bytes each.
#endif
} LUN_LIST, *PLUN_LIST;
#pragma pack(pop, lun_list)


#define LOADING_MECHANISM_CADDY                 0x00
#define LOADING_MECHANISM_TRAY                  0x01
#define LOADING_MECHANISM_POPUP                 0x02
#define LOADING_MECHANISM_INDIVIDUAL_CHANGER    0x04
#define LOADING_MECHANISM_CARTRIDGE_CHANGER     0x05

//
// end C/DVD 0.9 mode page definitions

//
// Mode parameter list block descriptor -
// set the block length for reading/writing
//
//

#define MODE_BLOCK_DESC_LENGTH               8
#define MODE_HEADER_LENGTH                   4
#define MODE_HEADER_LENGTH10                 8

#pragma pack(push, mode_parm_rw, 1)
typedef struct _MODE_PARM_READ_WRITE {

   MODE_PARAMETER_HEADER  ParameterListHeader;  // List Header Format
   MODE_PARAMETER_BLOCK   ParameterListBlock;   // List Block Descriptor

} MODE_PARM_READ_WRITE_DATA, *PMODE_PARM_READ_WRITE_DATA;
#pragma pack(pop, mode_parm_rw)

// end_ntminitape

//
// CDROM audio control (0x0E)
//

#define CDB_AUDIO_PAUSE 0
#define CDB_AUDIO_RESUME 1

#define CDB_DEVICE_START 0x11
#define CDB_DEVICE_STOP 0x10

#define CDB_EJECT_MEDIA 0x10
#define CDB_LOAD_MEDIA 0x01

#define CDB_SUBCHANNEL_HEADER      0x00
#define CDB_SUBCHANNEL_BLOCK       0x01

#define CDROM_AUDIO_CONTROL_PAGE   0x0E
#define MODE_SELECT_IMMEDIATE      0x04
#define MODE_SELECT_PFBIT          0x10

#define CDB_USE_MSF                0x01

#pragma pack(push, audio_output, 1)
typedef struct _PORT_OUTPUT {
    UCHAR ChannelSelection;
    UCHAR Volume;
} PORT_OUTPUT, *PPORT_OUTPUT;

typedef struct _AUDIO_OUTPUT {
    UCHAR CodePage;
    UCHAR ParameterLength;
    UCHAR Immediate;
    UCHAR Reserved[2];
    UCHAR LbaFormat;
    UCHAR LogicalBlocksPerSecond[2];
    PORT_OUTPUT PortOutput[4];
} AUDIO_OUTPUT, *PAUDIO_OUTPUT;
#pragma pack(pop, audio_output)

//
// Multisession CDROM
//

#define GET_LAST_SESSION 0x01
#define GET_SESSION_DATA 0x02;

//
// Atapi 2.5 changer
//

#pragma pack(push, chgr_stuff, 1)
typedef struct _MECHANICAL_STATUS_INFORMATION_HEADER {
    UCHAR CurrentSlot : 5;
    UCHAR ChangerState : 2;
    UCHAR Fault : 1;
    UCHAR Reserved : 5;
    UCHAR MechanismState : 3;
    UCHAR CurrentLogicalBlockAddress[3];
    UCHAR NumberAvailableSlots;
    UCHAR SlotTableLength[2];
} MECHANICAL_STATUS_INFORMATION_HEADER, *PMECHANICAL_STATUS_INFORMATION_HEADER;

typedef struct _SLOT_TABLE_INFORMATION {
    UCHAR DiscChanged : 1;
    UCHAR Reserved : 6;
    UCHAR DiscPresent : 1;
    UCHAR Reserved2[3];
} SLOT_TABLE_INFORMATION, *PSLOT_TABLE_INFORMATION;

typedef struct _MECHANICAL_STATUS {
    MECHANICAL_STATUS_INFORMATION_HEADER MechanicalStatusHeader;
    SLOT_TABLE_INFORMATION SlotTableInfo[1];
} MECHANICAL_STATUS, *PMECHANICAL_STATUS;
#pragma pack(pop, chgr_stuff)


// begin_ntminitape

//
// Tape definitions
//

#pragma pack(push, tape_position, 1)
typedef struct _TAPE_POSITION_DATA {
    UCHAR Reserved1:2;
    UCHAR BlockPositionUnsupported:1;
    UCHAR Reserved2:3;
    UCHAR EndOfPartition:1;
    UCHAR BeginningOfPartition:1;
    UCHAR PartitionNumber;
    USHORT Reserved3;
    UCHAR FirstBlock[4];
    UCHAR LastBlock[4];
    UCHAR Reserved4;
    UCHAR NumberOfBlocks[3];
    UCHAR NumberOfBytes[4];
} TAPE_POSITION_DATA, *PTAPE_POSITION_DATA;
#pragma pack(pop, tape_position)

//
// This structure is used to convert little endian
// ULONGs to SCSI CDB big endians values.
//

#pragma pack(push, byte_stuff, 1)
typedef union _EIGHT_BYTE {

    struct {
        UCHAR Byte0;
        UCHAR Byte1;
        UCHAR Byte2;
        UCHAR Byte3;
        UCHAR Byte4;
        UCHAR Byte5;
        UCHAR Byte6;
        UCHAR Byte7;
    };

    ULONGLONG AsULongLong;
} EIGHT_BYTE, *PEIGHT_BYTE;

typedef union _FOUR_BYTE {

    struct {
        UCHAR Byte0;
        UCHAR Byte1;
        UCHAR Byte2;
        UCHAR Byte3;
    };

    ULONG AsULong;
} FOUR_BYTE, *PFOUR_BYTE;

typedef union _TWO_BYTE {

    struct {
        UCHAR Byte0;
        UCHAR Byte1;
    };

    USHORT AsUShort;
} TWO_BYTE, *PTWO_BYTE;
#pragma pack(pop, byte_stuff)

//
// Byte reversing macro for converting
// between big- and little-endian formats
//

#define REVERSE_BYTES_QUAD(Destination, Source) {           \
    PEIGHT_BYTE d = (PEIGHT_BYTE)(Destination);             \
    PEIGHT_BYTE s = (PEIGHT_BYTE)(Source);                  \
    d->Byte7 = s->Byte0;                                    \
    d->Byte6 = s->Byte1;                                    \
    d->Byte5 = s->Byte2;                                    \
    d->Byte4 = s->Byte3;                                    \
    d->Byte3 = s->Byte4;                                    \
    d->Byte2 = s->Byte5;                                    \
    d->Byte1 = s->Byte6;                                    \
    d->Byte0 = s->Byte7;                                    \
}

#define REVERSE_BYTES(Destination, Source) {                \
    PFOUR_BYTE d = (PFOUR_BYTE)(Destination);               \
    PFOUR_BYTE s = (PFOUR_BYTE)(Source);                    \
    d->Byte3 = s->Byte0;                                    \
    d->Byte2 = s->Byte1;                                    \
    d->Byte1 = s->Byte2;                                    \
    d->Byte0 = s->Byte3;                                    \
}

#define REVERSE_BYTES_SHORT(Destination, Source) {          \
    PTWO_BYTE d = (PTWO_BYTE)(Destination);                 \
    PTWO_BYTE s = (PTWO_BYTE)(Source);                      \
    d->Byte1 = s->Byte0;                                    \
    d->Byte0 = s->Byte1;                                    \
}

//
// Byte reversing macro for converting
// USHORTS from big to little endian in place
//

#define REVERSE_SHORT(Short) {          \
    UCHAR tmp;                          \
    PTWO_BYTE w = (PTWO_BYTE)(Short);   \
    tmp = w->Byte0;                     \
    w->Byte0 = w->Byte1;                \
    w->Byte1 = tmp;                     \
    }

//
// Byte reversing macro for convering
// ULONGS between big & little endian in place
//

#define REVERSE_LONG(Long) {            \
    UCHAR tmp;                          \
    PFOUR_BYTE l = (PFOUR_BYTE)(Long);  \
    tmp = l->Byte3;                     \
    l->Byte3 = l->Byte0;                \
    l->Byte0 = tmp;                     \
    tmp = l->Byte2;                     \
    l->Byte2 = l->Byte1;                \
    l->Byte1 = tmp;                     \
    }

//
// This macro has the effect of Bit = log2(Data)
//

#define WHICH_BIT(Data, Bit) {                      \
    UCHAR tmp;                                      \
    for (tmp = 0; tmp < 32; tmp++) {                \
        if (((Data) >> tmp) == 1) {                 \
            break;                                  \
        }                                           \
    }                                               \
    ASSERT(tmp != 32);                              \
    (Bit) = tmp;                                    \
}


//
// For backwards compatability, use SCSIPORT definitions.
//

typedef PHYSICAL_ADDRESS STOR_PHYSICAL_ADDRESS, *PSTOR_PHYSICAL_ADDRESS;

typedef struct _ACCESS_RANGE {
    STOR_PHYSICAL_ADDRESS RangeStart;
    ULONG RangeLength;
    BOOLEAN RangeInMemory;
} ACCESS_RANGE, *PACCESS_RANGE;

//
// _MEMORY_REGION represents a region of physical contiguous memory.
// Generally, this is used for DMA common buffer regions.
//

typedef struct _MEMORY_REGION {

    //
    // Beginning virtual address of the region.
    //

    PUCHAR VirtualBase;

    //
    // Beginning physical address of the region.
    //

    PHYSICAL_ADDRESS PhysicalBase;

    //
    // Length of the region
    //
    //

    ULONG Length;

} MEMORY_REGION, *PMEMORY_REGION;


typedef enum _STOR_SYNCHRONIZATION_MODEL {
    StorSynchronizeHalfDuplex,
    StorSynchronizeFullDuplex
} STOR_SYNCHRONIZATION_MODEL;

typedef enum _INTERRUPT_SYNCHRONIZATION_MODE {
    InterruptSupportNone,
    InterruptSynchronizeAll,
    InterruptSynchronizePerMessage
} INTERRUPT_SYNCHRONIZATION_MODE;

typedef
BOOLEAN
(*PHW_MESSAGE_SIGNALED_INTERRUPT_ROUTINE) (
    IN PVOID HwDeviceExtension,
    IN ULONG MessageId
    );

//
// Message signalled interrupts support.
//

typedef struct _MESSAGE_INTERRUPT_INFORMATION {
    ULONG MessageId;
    ULONG MessageData;
    STOR_PHYSICAL_ADDRESS MessageAddress;
    ULONG InterruptVector;
    ULONG InterruptLevel;
    KINTERRUPT_MODE InterruptMode;
} MESSAGE_INTERRUPT_INFORMATION, *PMESSAGE_INTERRUPT_INFORMATION;


BOOLEAN
StorPortGetMessageInterruptInformation(
    IN PVOID HwDeviceExtension,
    IN ULONG MessageId,
    OUT PMESSAGE_INTERRUPT_INFORMATION InterruptInfo
    );
#define STOR_MAP_NO_BUFFERS             (0)
#define STOR_MAP_ALL_BUFFERS            (1)
#define STOR_MAP_NON_READ_WRITE_BUFFERS (2)

// ExtendedFlags1 flags

#define EXTENDED_FLAG_POWER 0x00000001
//
// Configuration information structure.  Contains the information necessary
// to initialize the adapter. NOTE: This structure must be a multiple of
// quadwords.
//

typedef struct _PORT_CONFIGURATION_INFORMATION {

    //
    // Length of port configuation information strucuture.
    //

    ULONG Length;

    //
    // IO bus number (0 for machines that have only 1 IO bus
    //

    ULONG SystemIoBusNumber;

    //
    // EISA, MCA or ISA
    //

    INTERFACE_TYPE  AdapterInterfaceType;

    //
    // Interrupt request level for device
    //

    ULONG BusInterruptLevel;

    //
    // Bus interrupt vector used with hardware buses which use as vector as
    // well as level, such as internal buses.
    //

    ULONG BusInterruptVector;

    //
    // Interrupt mode (level-sensitive or edge-triggered)
    //

    KINTERRUPT_MODE InterruptMode;

    //
    // Maximum number of bytes that can be transferred in a single SRB
    //

    ULONG MaximumTransferLength;

    //
    // Number of contiguous blocks of physical memory
    //

    ULONG NumberOfPhysicalBreaks;

    //
    // DMA channel for devices using system DMA
    //

    ULONG DmaChannel;
    ULONG DmaPort;
    DMA_WIDTH DmaWidth;
    DMA_SPEED DmaSpeed;

    //
    // Alignment masked required by the adapter for data transfers.
    //

    ULONG AlignmentMask;

    //
    // Number of access range elements which have been allocated.
    //

    ULONG NumberOfAccessRanges;

    //
    // Pointer to array of access range elements.
    //

    ACCESS_RANGE (*AccessRanges)[];

    //
    // Reserved field.
    //

    PVOID Reserved;

    //
    // Number of SCSI buses attached to the adapter.
    //

    UCHAR NumberOfBuses;

    //
    // SCSI bus ID for adapter
    //

    CCHAR InitiatorBusId[8];

    //
    // Indicates that the adapter does scatter/gather
    //

    BOOLEAN ScatterGather;

    //
    // Indicates that the adapter is a bus master
    //

    BOOLEAN Master;

    //
    // Host caches data or state.
    //

    BOOLEAN CachesData;

    //
    // Host adapter scans down for bios devices.
    //

    BOOLEAN AdapterScansDown;

    //
    // Primary at disk address (0x1F0) claimed.
    //

    BOOLEAN AtdiskPrimaryClaimed;

    //
    // Secondary at disk address (0x170) claimed.
    //

    BOOLEAN AtdiskSecondaryClaimed;

    //
    // The master uses 32-bit DMA addresses.
    //

    BOOLEAN Dma32BitAddresses;

    //
    // Use Demand Mode DMA rather than Single Request.
    //

    BOOLEAN DemandMode;

    //
    // Data buffers must be mapped into virtual address space.
    //

    UCHAR MapBuffers;

    //
    // The driver will need to tranlate virtual to physical addresses.
    //

    BOOLEAN NeedPhysicalAddresses;

    //
    // Supports tagged queuing
    //

    BOOLEAN TaggedQueuing;

    //
    // Supports auto request sense.
    //

    BOOLEAN AutoRequestSense;

    //
    // Supports multiple requests per logical unit.
    //

    BOOLEAN MultipleRequestPerLu;

    //
    // Support receive event function.
    //

    BOOLEAN ReceiveEvent;

    //
    // Indicates the real-mode driver has initialized the card.
    //

    BOOLEAN RealModeInitialized;

    //
    // Indicate that the miniport will not touch the data buffers directly.
    //

    BOOLEAN BufferAccessScsiPortControlled;

    //
    // Indicator for wide scsi.
    //

    UCHAR   MaximumNumberOfTargets;

    //
    // Ensure quadword alignment.
    //

    UCHAR   ReservedUchars[2];

    //
    // Adapter slot number
    //

    ULONG SlotNumber;

    //
    // Interrupt information for a second IRQ.
    //

    ULONG BusInterruptLevel2;
    ULONG BusInterruptVector2;
    KINTERRUPT_MODE InterruptMode2;

    //
    // DMA information for a second channel.
    //

    ULONG DmaChannel2;
    ULONG DmaPort2;
    DMA_WIDTH DmaWidth2;
    DMA_SPEED DmaSpeed2;

    //
    // Fields added to allow for the miniport
    // to update these sizes based on requirements
    // for large transfers ( > 64K);
    //

    ULONG DeviceExtensionSize;
    ULONG SpecificLuExtensionSize;
    ULONG SrbExtensionSize;

    //
    // Used to determine whether the system and/or the miniport support
    // 64-bit physical addresses.  See SCSI_DMA64_* flags below.
    //

    UCHAR  Dma64BitAddresses;        /* New */

    //
    // Indicates that the miniport can accept a SRB_FUNCTION_RESET_DEVICE
    // to clear all requests to a particular LUN.
    //

    BOOLEAN ResetTargetSupported;       /* New */

    //
    // Indicates that the miniport can support more than 8 logical units per
    // target (maximum LUN number is one less than this field).
    //

    UCHAR MaximumNumberOfLogicalUnits;  /* New */

    //
    // Supports WMI?
    //

    BOOLEAN WmiDataProvider;

    //
    // STORPORT synchronization model, either half or full duplex
    // depending on whether the driver supports async-with-interrupt
    // model or not.
    //

    STOR_SYNCHRONIZATION_MODEL SynchronizationModel;    // STORPORT New

    PHW_MESSAGE_SIGNALED_INTERRUPT_ROUTINE HwMSInterruptRoutine;

    INTERRUPT_SYNCHRONIZATION_MODE InterruptSynchronizationMode;

    MEMORY_REGION DumpRegion;

    ULONG         RequestedDumpBufferSize;

    BOOLEAN       VirtualDevice;

    ULONG         ExtendedFlags1;

    ULONG         MaxNumberOfIO;


} PORT_CONFIGURATION_INFORMATION, *PPORT_CONFIGURATION_INFORMATION;


//
// Scatter/gather lists
//

typedef struct _STOR_SCATTER_GATHER_ELEMENT {
    STOR_PHYSICAL_ADDRESS PhysicalAddress;
    ULONG Length;
    ULONG_PTR Reserved;
} STOR_SCATTER_GATHER_ELEMENT, *PSTOR_SCATTER_GATHER_ELEMENT;

typedef struct _STOR_SCATTER_GATHER_LIST {
    ULONG NumberOfElements;
    ULONG_PTR Reserved;
    STOR_SCATTER_GATHER_ELEMENT List[];
} STOR_SCATTER_GATHER_LIST, *PSTOR_SCATTER_GATHER_LIST;


typedef enum _GETSGSTATUS{
    SG_ALLOCATED = 0,
    SG_BUFFER_TOO_SMALL
} GETSGSTATUS, *PGETSGSTATUS;

//
// Version control for ConfigInfo structure.
//

#define CONFIG_INFO_VERSION_2 sizeof(PORT_CONFIGURATION_INFORMATION)


//
// Flags for controlling 64-bit DMA use (PORT_CONFIGURATION_INFORMATION field
// Dma64BitAddresses)
//

//
// Set by scsiport on entering HwFindAdapter if the system can support 64-bit
// physical addresses.  The miniport can use this information before calling
// ScsiPortGetUncachedExtension to modify the DeviceExtensionSize,
// SpecificLuExtensionSize & SrbExtensionSize fields to account for the extra
// size of the scatter gather list.
//

#define SCSI_DMA64_SYSTEM_SUPPORTED     0x80

//
// Set by the miniport before returning from HwFindAdapter to tell the port
// driver that we support 64-bit physical addresses on I/O transfers. The
// port driver will still allocate Uncached Extension, SenseInfo and Srb
// Extension below 4GB, but I/O transfers will not be remapped.
//


#define SCSI_DMA64_MINIPORT_SUPPORTED   0x01

#if (NTDDI_VERSION >= NTDDI_WS03SP1)
//
// Set by the miniport before returning from HwFindAdpater to tell the port
// driver that we support full 64-bit addressing. This means I/O requests
// may be handled with > 4GB physical addresses, and uncached extension,
// SenseInof and Srb Extension may all lie above 4GB.
//

#define SCSI_DMA64_MINIPORT_FULL64BIT_SUPPORTED 0x02
#endif

//
// Command type (and parameter) definition(s) for AdapterControl requests.
//

typedef enum _SCSI_ADAPTER_CONTROL_TYPE {
    ScsiQuerySupportedControlTypes = 0,
    ScsiStopAdapter,
    ScsiRestartAdapter,
    ScsiSetBootConfig,
    ScsiSetRunningConfig,
    ScsiAdapterControlMax,
    MakeAdapterControlTypeSizeOfUlong = 0xffffffff
} SCSI_ADAPTER_CONTROL_TYPE, *PSCSI_ADAPTER_CONTROL_TYPE;

//
// Adapter control status values
//

typedef enum _SCSI_ADAPTER_CONTROL_STATUS {
    ScsiAdapterControlSuccess = 0,
    ScsiAdapterControlUnsuccessful
} SCSI_ADAPTER_CONTROL_STATUS, *PSCSI_ADAPTER_CONTROL_STATUS;

//
// Parameters for Adapter Control Functions:
//

//
// ScsiQuerySupportedControlTypes:
//

typedef struct _SCSI_SUPPORTED_CONTROL_TYPE_LIST {

    //
    // Specifies the number of entries in the adapter control type list.
    //

    IN ULONG MaxControlType;

    //
    // The miniport will set TRUE for each control type it supports.
    // The number of entries in this array is defined by MaxAdapterControlType
    // - the miniport must not attempt to set any AC types beyond the maximum
    // value specified.
    //

    OUT BOOLEAN SupportedTypeList[0];

} SCSI_SUPPORTED_CONTROL_TYPE_LIST, *PSCSI_SUPPORTED_CONTROL_TYPE_LIST;

//
// DPC Data Structure
//

typedef struct _DPC_BUFFER {
    CSHORT Type;
    UCHAR Number;
    UCHAR Importance;
    struct {
        PVOID F;
        PVOID B;
    };
    PVOID DeferredRoutine;
    PVOID DeferredContext;
    PVOID SystemArgument1;
    PVOID SystemArgument2;
    PVOID DpcData;
} DPC_BUFFER;

#define STOR_DPC_BUFFER_SIZE (sizeof (DPC_BUFFER))

typedef struct _STOR_DPC {
    DPC_BUFFER Dpc;
    ULONG_PTR Lock;
} STOR_DPC, *PSTOR_DPC;

typedef enum _STOR_SPINLOCK {
    DpcLock = 1,
    StartIoLock,
    InterruptLock
} STOR_SPINLOCK;

typedef struct _STOR_LOCK_HANDLE {
    STOR_SPINLOCK Lock;
    struct {
        struct {
            PVOID Next;
            PVOID Lock;
        } LockQueue;
        KIRQL OldIrql;
    } Context;
} STOR_LOCK_HANDLE, *PSTOR_LOCK_HANDLE;

#define STOR_PERF_DPC_REDIRECTION 0x00000001
#define STOR_PERF_CONCURRENT_CHANNELS 0x00000002
#define STOR_PERF_INTERRUPT_MESSAGE_RANGES 0x00000004

#define STOR_PERF_VERSION 0x00000002

typedef struct _PERF_CONFIGURATION_DATA {
    ULONG Version;
    ULONG Size;
    ULONG Flags;
    ULONG ConcurrentChannels;
    ULONG FirstRedirectionMessageNumber, LastRedirectionMessageNumber;
} PERF_CONFIGURATION_DATA, *PPERF_CONFIGURATION_DATA;

typedef struct _STARTIO_PERFORMANCE_PARAMETERS {
    ULONG Version;
    ULONG Size;
    ULONG MessageNumber;
    ULONG ChannelNumber;
} STARTIO_PERFORMANCE_PARAMETERS, *PSTARTIO_PERFORMANCE_PARAMETERS;

//
// SCSI Adapter Dependent Routines
//

typedef
BOOLEAN
(*PHW_INITIALIZE) (
    IN PVOID DeviceExtension
    );

typedef
BOOLEAN
(*PHW_BUILDIO) (
    IN PVOID DeviceExtension,
    IN PSCSI_REQUEST_BLOCK Srb
    );

typedef
BOOLEAN
(*PHW_STARTIO) (
    IN PVOID DeviceExtension,
    IN PSCSI_REQUEST_BLOCK Srb
    );

typedef
BOOLEAN
(*PHW_INTERRUPT) (
    IN PVOID DeviceExtension
    );

typedef
VOID
(*PHW_TIMER) (
    IN PVOID DeviceExtension
    );

typedef
VOID
(*PHW_DMA_STARTED) (
    IN PVOID DeviceExtension
    );

typedef
ULONG
(*PHW_FIND_ADAPTER) (
    IN PVOID DeviceExtension,
    IN PVOID HwContext,
    IN PVOID BusInformation,
    IN PCHAR ArgumentString,
    IN OUT PPORT_CONFIGURATION_INFORMATION ConfigInfo,
    OUT PBOOLEAN Again
    );

typedef
BOOLEAN
(*PHW_RESET_BUS) (
    IN PVOID DeviceExtension,
    IN ULONG PathId
    );

typedef
BOOLEAN
(*PHW_ADAPTER_STATE) (
    IN PVOID DeviceExtension,
    IN PVOID Context,
    IN BOOLEAN SaveState
    );

typedef
SCSI_ADAPTER_CONTROL_STATUS
(*PHW_ADAPTER_CONTROL) (
    IN PVOID DeviceExtension,
    IN SCSI_ADAPTER_CONTROL_TYPE ControlType,
    IN PVOID Parameters
    );

typedef
BOOLEAN
(*PHW_PASSIVE_INITIALIZE_ROUTINE)(
    IN PVOID DeviceExtension
    );

typedef
VOID
(*PHW_DPC_ROUTINE)(
    IN PSTOR_DPC Dpc,
    IN PVOID HwDeviceExtension,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

typedef
BOOLEAN
(*PStorPortGetMessageInterruptInformation)(
    IN PVOID HwDeviceExtension,
    IN ULONG MessageId,
    OUT PMESSAGE_INTERRUPT_INFORMATION InterruptInfo
    );
typedef
VOID
(*PStorPortPutScatterGatherList) (
    IN PVOID HwDeviceExtension,
    IN PSTOR_SCATTER_GATHER_LIST ScatterGatherList,
    IN BOOLEAN  WriteToDevice
    );
typedef
VOID
  (*PpostScaterGatherExecute)(
    IN PVOID  *DeviceObject,
    IN PVOID  *Irp,
    IN PSTOR_SCATTER_GATHER_LIST  ScatterGather,
    IN PVOID  Context
    );

typedef
GETSGSTATUS
(*PStorPortBuildScatterGatherList) (
    IN PVOID  HwDeviceExtension,
    IN PVOID  Mdl,
    IN PVOID  CurrentVa,
    IN ULONG  Length,
    IN PpostScaterGatherExecute ExecutionRoutine,
    IN PVOID  Context,
    IN BOOLEAN  WriteToDevice,
    IN PVOID  ScatterGatherBuffer,
    IN ULONG  ScatterGatherBufferLength
    );
typedef
VOID
(*PStorPortFreePool)(
    IN PVOID  PMemory,
    IN PVOID HwDeviceExtension,
    IN IN PVOID PMdl
    );
typedef
PVOID
(*PStorPortAllocatePool)(
    IN ULONG NumberOfBytes,
    IN ULONG Tag,
    IN PVOID HwDeviceExtension,
    IN OUT PVOID *PMdl
    );

typedef
PVOID
(*PStorPortGetSystemAddress)(
    IN PSCSI_REQUEST_BLOCK Srb
    );

typedef
ULONG
(*PStorPortAcquireMSISpinLock)(
    IN PVOID HwDeviceExtension,
    IN ULONG MessageID
    );
typedef
VOID
(*PStorPortReleaseMSISpinLock)(
    IN PVOID HwDeviceExtension,
    IN ULONG MessageID,
    IN ULONG OldIrql
    );

typedef
VOID
(*PStorPortCompleteServiceIrp)(
    IN PVOID HwDeviceExtension,
    IN PVOID  Irp
    );
typedef
PVOID
(*PStorPortGetOriginalMdl)(
    PSCSI_REQUEST_BLOCK Srb
    );

typedef struct _STORPORT_EXTENDED_FUNCTIONS {

    ULONG Version;

    // Port extended services
    PStorPortGetMessageInterruptInformation GetMessageInterruptInformation;
    PStorPortPutScatterGatherList           PutScatterGatherList;
    PStorPortBuildScatterGatherList         BuildScatterGatherList;
    PStorPortFreePool                       FreePool;
    PStorPortAllocatePool                   AllocatePool;
    PStorPortGetSystemAddress               GetSystemAddress;
    PStorPortAcquireMSISpinLock             AcquireMSISpinLock;
    PStorPortReleaseMSISpinLock             ReleaseMSISpinLock;
    PStorPortCompleteServiceIrp             CompleteServiceIrp;
    PStorPortGetOriginalMdl                 GetOriginalMdl;
} STORPORT_EXTENDED_FUNCTIONS, *PSTORPORT_EXTENDED_FUNCTIONS;


typedef enum _STORPORT_FUNCTION_CODE {
    ExtFunctionAllocatePool,
    ExtFunctionFreePool,
    ExtFunctionAllocateMdl,
    ExtFunctionFreeMdl,
    ExtFunctionBuildMdlForNonPagedPool,
    ExtFunctionGetSystemAddress,
    ExtFunctionGetOriginalMdl,
    ExtFunctionCompleteServiceIrp,
    ExtFunctionGetDeviceObjects,
    ExtFunctionBuildScatterGatherList,
    ExtFunctionPutScatterGatherList,
    ExtFunctionAcquireMSISpinLock,
    ExtFunctionReleaseMSISpinLock,
    ExtFunctionGetMessageInterruptInformation,
    ExtFunctionInitializePerformanceOptimizations,
    ExtFunctionGetStartIoPerformanceParameters
} STORPORT_FUNCTION_CODE, *PSTORPORT_FUNCTION_CODE;


//
// Storage port driver status codes
// This is the storage equivalent of NTSTATUS
//

#define STOR_STATUS_SUCCESS                     (0x00000000L)
#define STOR_STATUS_UNSUCCESSFUL                (0xC1000001L)
#define STOR_STATUS_NOT_IMPLEMENTED             (0xC1000002L)
#define STOR_STATUS_INSUFFICIENT_RESOURCES      (0xC1000003L)
#define STOR_STATUS_BUFFER_TOO_SMALL            (0xC1000004L)
#define STOR_STATUS_ACCESS_DENIED               (0xC1000005L)
#define STOR_STATUS_INVALID_PARAMETER           (0xC1000006L)
#define STOR_STATUS_INVALID_DEVICE_REQUEST      (0xC1000007L)
#define STOR_STATUS_INVALID_IRQL                (0xC1000008L)
#define STOR_STATUS_INVALID_DEVICE_STATE        (0xC1000009L)

//
// Port driver error codes
//

#define SP_BUS_PARITY_ERROR         0x0001
#define SP_UNEXPECTED_DISCONNECT    0x0002
#define SP_INVALID_RESELECTION      0x0003
#define SP_BUS_TIME_OUT             0x0004
#define SP_PROTOCOL_ERROR           0x0005
#define SP_INTERNAL_ADAPTER_ERROR   0x0006
#define SP_REQUEST_TIMEOUT          0x0007
#define SP_IRQ_NOT_RESPONDING       0x0008
#define SP_BAD_FW_WARNING           0x0009
#define SP_BAD_FW_ERROR             0x000a
#define SP_LOST_WMI_MINIPORT_REQUEST 0x000b

//
// Port driver version flags
//
#define SP_VER_TRACE_SUPPORT        0x0010

//
// Return values for SCSI_HW_FIND_ADAPTER.
//

#define SP_RETURN_NOT_FOUND     0
#define SP_RETURN_FOUND         1
#define SP_RETURN_ERROR         2
#define SP_RETURN_BAD_CONFIG    3

//
// Notification Event Types
//

typedef enum _SCSI_NOTIFICATION_TYPE {
    RequestComplete,
    NextRequest,
    NextLuRequest,
    ResetDetected,
    _obsolete1,             // STORPORT: CallDisableInterrupts has been removed
    _obsolete2,             // STORPORT: CallEnableInterrupts has been removed
    RequestTimerCall,
    BusChangeDetected,
    WMIEvent,
    WMIReregister,
    LinkUp,
    LinkDown,
    QueryTickCount,
    BufferOverrunDetected,
    TraceNotification,
    GetExtendedFunctionTable,

    EnablePassiveInitialization = 0x1000,
    InitializeDpc,
    IssueDpc,
    AcquireSpinLock,
    ReleaseSpinLock

} SCSI_NOTIFICATION_TYPE, *PSCSI_NOTIFICATION_TYPE;

//
// Structure passed between miniport initialization
// and SCSI port initialization
//

typedef struct _HW_INITIALIZATION_DATA {

    ULONG HwInitializationDataSize;

    //
    // Adapter interface type:
    //
    // Internal
    // Isa
    // Eisa
    // MicroChannel
    // TurboChannel
    // PCIBus
    // VMEBus
    // NuBus
    // PCMCIABus
    // CBus
    // MPIBus
    // MPSABus
    //

    INTERFACE_TYPE  AdapterInterfaceType;

    //
    // Miniport driver routines
    //

    PHW_INITIALIZE HwInitialize;

    PHW_STARTIO HwStartIo;

    PHW_INTERRUPT HwInterrupt;

    PHW_FIND_ADAPTER HwFindAdapter;

    PHW_RESET_BUS HwResetBus;

    PHW_DMA_STARTED HwDmaStarted;

    PHW_ADAPTER_STATE HwAdapterState;

    //
    // Miniport driver resources
    //

    ULONG DeviceExtensionSize;

    ULONG SpecificLuExtensionSize;

    ULONG SrbExtensionSize;

    ULONG NumberOfAccessRanges;

    PVOID Reserved;

    //
    // Data buffers must be mapped into virtual address space.
    //

    UCHAR MapBuffers;

    //
    // The driver will need to tranlate virtual to physical addresses.
    //

    BOOLEAN NeedPhysicalAddresses;

    //
    // Supports tagged queuing
    //

    BOOLEAN TaggedQueuing;

    //
    // Supports auto request sense.
    //

    BOOLEAN AutoRequestSense;

    //
    // Supports multiple requests per logical unit.
    //

    BOOLEAN MultipleRequestPerLu;

    //
    // Support receive event function.
    //

    BOOLEAN ReceiveEvent;

    //
    // Vendor identification length
    //

    USHORT VendorIdLength;

    //
    // Vendor identification
    //

    PVOID VendorId;

    //
    // Pad for alignment and future use.
    //

    union {

        USHORT ReservedUshort;

        //
        // Flags to indicate supported features
        //
        USHORT PortVersionFlags;
    };

    //
    // Device identification length
    //

    USHORT DeviceIdLength;

    //
    // Device identification
    //

    PVOID DeviceId;

    //
    // Stop adapter routine.
    //

    PHW_ADAPTER_CONTROL HwAdapterControl;

    //
    // Initialize to the Build IO routine if one is supported, otherwise
    // should be NULL.
    //

    PHW_BUILDIO HwBuildIo;                      // STORPORT New

} HW_INITIALIZATION_DATA, *PHW_INITIALIZATION_DATA;


// Virtual driver HW_INIT_DATA
typedef
VOID
(*PHW_FREE_ADAPTER_RESOURCES) (
    IN PVOID DeviceExtension
    );

typedef
VOID
(*PHW_PROCESS_SERVICE_REQUEST) (
    IN PVOID DeviceExtension,
    IN PVOID Irp
    );

typedef
VOID
(*PHW_COMPLETE_SERVICE_IRP) (
    IN PVOID DeviceExtension
    );

typedef
VOID
(*PHW_INITIALIZE_TRACING) (
    IN PVOID Arg1,
    IN PVOID Arg2
    );

typedef
VOID
(*PHW_CLEANUP_TRACING) (
    IN PVOID  Arg1
    );
typedef
ULONG
(*PVIRTUAL_HW_FIND_ADAPTER) (
    IN PVOID DeviceExtension,
    IN PVOID HwContext,
    IN PVOID BusInformation,
    IN PVOID LowerDevice,
    IN PCHAR ArgumentString,
    IN OUT PPORT_CONFIGURATION_INFORMATION ConfigInfo,
    OUT PBOOLEAN Again
    );

typedef struct _VIRTUAL_HW_INITIALIZATION_DATA {

    ULONG HwInitializationDataSize;

    //
    // Adapter interface type:
    //
    // Internal
    // Isa
    // Eisa
    // MicroChannel
    // TurboChannel
    // PCIBus
    // VMEBus
    // NuBus
    // PCMCIABus
    // CBus
    // MPIBus
    // MPSABus
    //

    INTERFACE_TYPE  AdapterInterfaceType;

    //
    // Miniport driver routines
    //

    PHW_INITIALIZE HwInitialize;

    PHW_STARTIO HwStartIo;

    PHW_INTERRUPT HwInterrupt;

    PVIRTUAL_HW_FIND_ADAPTER HwFindAdapter;

    PHW_RESET_BUS HwResetBus;

    PHW_DMA_STARTED HwDmaStarted;

    PHW_ADAPTER_STATE HwAdapterState;

    //
    // Miniport driver resources
    //

    ULONG DeviceExtensionSize;

    ULONG SpecificLuExtensionSize;

    ULONG SrbExtensionSize;

    ULONG NumberOfAccessRanges;

    PVOID Reserved;

    //
    // Data buffers must be mapped into virtual address space.
    //

    UCHAR MapBuffers;

    //
    // The driver will need to tranlate virtual to physical addresses.
    //

    BOOLEAN NeedPhysicalAddresses;

    //
    // Supports tagged queuing
    //

    BOOLEAN TaggedQueuing;

    //
    // Supports auto request sense.
    //

    BOOLEAN AutoRequestSense;

    //
    // Supports multiple requests per logical unit.
    //

    BOOLEAN MultipleRequestPerLu;

    //
    // Support receive event function.
    //

    BOOLEAN ReceiveEvent;

    //
    // Vendor identification length
    //

    USHORT VendorIdLength;

    //
    // Vendor identification
    //

    PVOID VendorId;

    //
    // Pad for alignment and future use.
    //

    union {

        USHORT ReservedUshort;

        //
        // Flags to indicate supported features
        //
        USHORT PortVersionFlags;
    };

    //
    // Device identification length
    //

    USHORT DeviceIdLength;

    //
    // Device identification
    //

    PVOID DeviceId;

    //
    // Stop adapter routine.
    //

    PHW_ADAPTER_CONTROL HwAdapterControl;

    //
    // Initialize to the Build IO routine if one is supported, otherwise
    // should be NULL.
    //

    PHW_BUILDIO HwBuildIo;                      // STORPORT New

    PHW_FREE_ADAPTER_RESOURCES HwFreeAdapterResources;

    PHW_PROCESS_SERVICE_REQUEST HwProcessServiceRequest;

    PHW_COMPLETE_SERVICE_IRP HwCompleteServiceIrp;

    //
    // Functions for enabling tracing in miniport
    //
    PHW_INITIALIZE_TRACING HwInitializeTracing;
    PHW_CLEANUP_TRACING    HwCleanupTracing;



} VIRTUAL_HW_INITIALIZATION_DATA, *PVIRTUAL_HW_INITIALIZATION_DATA;

#define DUMP_MINIPORT_VERSION_1         0x0100
#define DUMP_MINIPORT_NAME_LENGTH       15

typedef struct _MINIPORT_MAPPINGS {

    //
    // Structure version
    //
    USHORT Version;
 
    // Pointer to iBF Table
    //
    PVOID IBFTable;

    //
    // Pointer to Nic0 memory map.
    //
    PVOID Nic0Map;
    
    //
    // Pointer to Nic1 memory map.
    //
    PVOID Nic1Map;
} MINIPORT_MAPPINGS, *PMINIPORT_MAPPINGS;




typedef struct _MINIPORT_DUMP_POINTERS {

    //
    // Structure version
    //
    USHORT Version;

    //
    // Structure size
    //
    USHORT Size;

    //
    // Dump miniport name
    //
    WCHAR DriverName[DUMP_MINIPORT_NAME_LENGTH];

    //
    // Pointer to the DMA adapter object
    //

    struct _ADAPTER_OBJECT *AdapterObject;

    //
    // Register base
    //
    PVOID MappedRegisterBase;

    //
    // Common buffer size, must be <= 64KB
    //
    ULONG CommonBufferSize;

    //
    // Pointer which is passed to dump driver through port configuration.
    //
    PVOID MiniportPrivateDumpData;

    //
    // The following members are part of the
    // PORT_CONFIGURATION_INFORMATION structure
    //

    ULONG SystemIoBusNumber;

    INTERFACE_TYPE AdapterInterfaceType;

    ULONG MaximumTransferLength;

    ULONG NumberOfPhysicalBreaks;

    ULONG AlignmentMask;

    ULONG NumberOfAccessRanges;

    ACCESS_RANGE (*AccessRanges)[];

    UCHAR NumberOfBuses;

    BOOLEAN  Master;

    BOOLEAN MapBuffers;

    UCHAR MaximumNumberOfTargets;

} MINIPORT_DUMP_POINTERS, *PMINIPORT_DUMP_POINTERS;



typedef
BOOLEAN
(*PSTOR_SYNCHRONIZED_ACCESS)(
    IN PVOID HwDeviceExtension,
    IN PVOID Context
    );


#ifndef _NTDDK_
#define STORPORT_API DECLSPEC_IMPORT
#else
#define STORPORT_API
#endif

//
// Port driver routines called by miniport driver
//

STORPORT_API
ULONG
StorPortInitialize(
    IN PVOID Argument1,
    IN PVOID Argument2,
    IN struct _HW_INITIALIZATION_DATA *HwInitializationData,
    IN PVOID HwContext
    );

STORPORT_API
VOID
StorPortFreeDeviceBase(
    IN PVOID HwDeviceExtension,
    IN PVOID MappedAddress
    );

STORPORT_API
ULONG
StorPortGetBusData(
    IN PVOID DeviceExtension,
    IN ULONG BusDataType,
    IN ULONG SystemIoBusNumber,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Length
    );

STORPORT_API
ULONG
StorPortSetBusDataByOffset(
    IN PVOID DeviceExtension,
    IN ULONG BusDataType,
    IN ULONG SystemIoBusNumber,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    );

STORPORT_API
PVOID
StorPortGetDeviceBase(
    IN PVOID HwDeviceExtension,
    IN INTERFACE_TYPE BusType,
    IN ULONG SystemIoBusNumber,
    IN STOR_PHYSICAL_ADDRESS IoAddress,
    IN ULONG NumberOfBytes,
    IN BOOLEAN InIoSpace
    );

STORPORT_API
PVOID
StorPortGetLogicalUnit(
    IN PVOID HwDeviceExtension,
    IN UCHAR PathId,
    IN UCHAR TargetId,
    IN UCHAR Lun
    );

STORPORT_API
PSTOR_SCATTER_GATHER_LIST
StorPortGetScatterGatherList(
    IN PVOID HwDeviceExtension,
    IN PSCSI_REQUEST_BLOCK Srb
    );

STORPORT_API
STOR_PHYSICAL_ADDRESS
StorPortGetPhysicalAddress(
    IN PVOID HwDeviceExtension,
    IN PSCSI_REQUEST_BLOCK Srb,
    IN PVOID VirtualAddress,
    OUT ULONG *Length
    );

STORPORT_API
PVOID
StorPortGetVirtualAddress(
    IN PVOID HwDeviceExtension,
    IN STOR_PHYSICAL_ADDRESS PhysicalAddress
    );

STORPORT_API
PVOID
StorPortGetUncachedExtension(
    IN PVOID HwDeviceExtension,
    IN PPORT_CONFIGURATION_INFORMATION ConfigInfo,
    IN ULONG NumberOfBytes
    );

STORPORT_API
BOOLEAN
StorPortPauseDevice(
    IN PVOID HwDeviceExtension,
    IN UCHAR PathId,
    IN UCHAR TargetId,
    IN UCHAR Lun,
    IN ULONG Timeout
    );

STORPORT_API
BOOLEAN
StorPortResumeDevice(
    IN PVOID HwDeviceExtension,
    IN UCHAR PathId,
    IN UCHAR TargetId,
    IN UCHAR Lun
    );

STORPORT_API
BOOLEAN
StorPortPause(
    IN PVOID HwDeviceExtension,
    IN ULONG Timeout
    );

STORPORT_API
BOOLEAN
StorPortResume(
    IN PVOID HwDeviceExtension
    );

STORPORT_API
BOOLEAN
StorPortDeviceBusy(
    IN PVOID HwDeviceExtension,
    IN UCHAR PathId,
    IN UCHAR TargetId,
    IN UCHAR Lun,
    IN ULONG RequestsToComplete
    );

STORPORT_API
BOOLEAN
StorPortDeviceReady(
    IN PVOID HwDeviceExtension,
    IN UCHAR PathId,
    IN UCHAR TargetId,
    IN UCHAR Lun
    );

STORPORT_API
BOOLEAN
StorPortBusy(
    IN PVOID HwDeviceExtension,
    IN ULONG RequestsToComplete
    );

STORPORT_API
BOOLEAN
StorPortReady(
    IN PVOID HwDeviceExtension
    );

STORPORT_API
BOOLEAN
StorPortSetDeviceQueueDepth(
    IN PVOID HwDeviceExtension,
    IN UCHAR PathId,
    IN UCHAR TargetId,
    IN UCHAR Lun,
    IN ULONG Depth
    );

STORPORT_API
VOID
StorPortNotification(
    IN SCSI_NOTIFICATION_TYPE NotificationType,
    IN PVOID HwDeviceExtension,
    ...
    );

STORPORT_API
VOID
StorPortLogError(
    IN PVOID HwDeviceExtension,
    IN PSCSI_REQUEST_BLOCK Srb OPTIONAL,
    IN UCHAR PathId,
    IN UCHAR TargetId,
    IN UCHAR Lun,
    IN ULONG ErrorCode,
    IN ULONG UniqueId
    );

STORPORT_API
VOID
StorPortCompleteRequest(
    IN PVOID HwDeviceExtension,
    IN UCHAR PathId,
    IN UCHAR TargetId,
    IN UCHAR Lun,
    IN UCHAR SrbStatus
    );

STORPORT_API
VOID
StorPortStallExecution(
    IN ULONG Delay
    );

STORPORT_API
BOOLEAN
StorPortSynchronizeAccess(
    IN PVOID HwDeviceExtension,
    IN PSTOR_SYNCHRONIZED_ACCESS SynchronizedAccessRoutine,
    IN PVOID Context
    );

#if defined(_M_AMD64)

#define StorPortReadPortUchar(h, p) READ_PORT_UCHAR(p)
#define StorPortReadPortUshort(h, p) READ_PORT_USHORT(p)
#define StorPortReadPortUlong(h, p) READ_PORT_ULONG(p)

#define StorPortReadPortBufferUchar(h, p, b, c) READ_PORT_BUFFER_UCHAR(p, b, c)
#define StorPortReadPortBufferUshort(h, p, b, c) READ_PORT_BUFFER_USHORT(p, b, c)
#define StorPortReadPortBufferUlong(h, p, b, c) READ_PORT_BUFFER_ULONG(p, b, c)

#define StorPortReadRegisterUchar(h, r) READ_REGISTER_UCHAR(r)
#define StorPortReadRegisterUshort(h, r) READ_REGISTER_USHORT(r)
#define StorPortReadRegisterUlong(h, r) READ_REGISTER_ULONG(r)

#define StorPortReadRegisterBufferUchar(h, r, b, c) READ_REGISTER_BUFFER_UCHAR(r, b, c)
#define StorPortReadRegisterBufferUshort(h, r, b, c) READ_REGISTER_BUFFER_USHORT(r, b, c)
#define StorPortReadRegisterBufferUlong(h, r, b, c) READ_REGISTER_BUFFER_ULONG(r, b, c)

#define StorPortWritePortUchar(h, p, v) WRITE_PORT_UCHAR(p, v)
#define StorPortWritePortUshort(h, p, v) WRITE_PORT_USHORT(p, v)
#define StorPortWritePortUlong(h, p, v) WRITE_PORT_ULONG(p, v)

#define StorPortWritePortBufferUchar(h, p, b, c) WRITE_PORT_BUFFER_UCHAR(p, b, c)
#define StorPortWritePortBufferUshort(h, p, b, c) WRITE_PORT_BUFFER_USHORT(p, b, c)
#define StorPortWritePortBufferUlong(h, p, b, c) WRITE_PORT_BUFFER_ULONG(p, b, c)

#define StorPortWriteRegisterUchar(h, r, v) WRITE_REGISTER_UCHAR(r, v)
#define StorPortWriteRegisterUshort(h, r, v) WRITE_REGISTER_USHORT(r, v)
#define StorPortWriteRegisterUlong(h, r, v) WRITE_REGISTER_ULONG(r, v)

#define StorPortWriteRegisterBufferUchar(h, r, b, c) WRITE_REGISTER_BUFFER_UCHAR(r, b, c)
#define StorPortWriteRegisterBufferUshort(h, r, b, c) WRITE_REGISTER_BUFFER_USHORT(r, b, c)
#define StorPortWriteRegisterBufferUlong(h, r, b, c) WRITE_REGISTER_BUFFER_ULONG(r, b, c)

#define StorPortMoveMemory memmove

#else

STORPORT_API
UCHAR
StorPortReadPortUchar(
    IN PVOID HwDeviceExtension,
    IN PUCHAR Port
    );

STORPORT_API
USHORT
StorPortReadPortUshort(
    IN PVOID HwDeviceExtension,
    IN PUSHORT Port
    );

STORPORT_API
ULONG
StorPortReadPortUlong(
    IN PVOID HwDeviceExtension,
    IN PULONG Port
    );

STORPORT_API
VOID
StorPortReadPortBufferUchar(
    IN PVOID HwDeviceExtension,
    IN PUCHAR Port,
    IN PUCHAR Buffer,
    IN ULONG  Count
    );

STORPORT_API
VOID
StorPortReadPortBufferUshort(
    IN PVOID HwDeviceExtension,
    IN PUSHORT Port,
    IN PUSHORT Buffer,
    IN ULONG Count
    );

STORPORT_API
VOID
StorPortReadPortBufferUlong(
    IN PVOID HwDeviceExtension,
    IN PULONG Port,
    IN PULONG Buffer,
    IN ULONG Count
    );

STORPORT_API
UCHAR
StorPortReadRegisterUchar(
    IN PVOID HwDeviceExtension,
    IN PUCHAR Register
    );

STORPORT_API
USHORT
StorPortReadRegisterUshort(
    IN PVOID HwDeviceExtension,
    IN PUSHORT Register
    );

STORPORT_API
ULONG
StorPortReadRegisterUlong(
    IN PVOID HwDeviceExtension,
    IN PULONG Register
    );

STORPORT_API
VOID
StorPortReadRegisterBufferUchar(
    IN PVOID HwDeviceExtension,
    IN PUCHAR Register,
    IN PUCHAR Buffer,
    IN ULONG  Count
    );

STORPORT_API
VOID
StorPortReadRegisterBufferUshort(
    IN PVOID HwDeviceExtension,
    IN PUSHORT Register,
    IN PUSHORT Buffer,
    IN ULONG Count
    );

STORPORT_API
VOID
StorPortReadRegisterBufferUlong(
    IN PVOID HwDeviceExtension,
    IN PULONG Register,
    IN PULONG Buffer,
    IN ULONG Count
    );

STORPORT_API
VOID
StorPortWritePortUchar(
    IN PVOID HwDeviceExtension,
    IN PUCHAR Port,
    IN UCHAR Value
    );

STORPORT_API
VOID
StorPortWritePortUshort(
    IN PVOID HwDeviceExtension,
    IN PUSHORT Port,
    IN USHORT Value
    );

STORPORT_API
VOID
StorPortWritePortUlong(
    IN PVOID HwDeviceExtension,
    IN PULONG Port,
    IN ULONG Value
    );

STORPORT_API
VOID
StorPortWritePortBufferUchar(
    IN PVOID HwDeviceExtension,
    IN PUCHAR Port,
    IN PUCHAR Buffer,
    IN ULONG  Count
    );

STORPORT_API
VOID
StorPortWritePortBufferUshort(
    IN PVOID HwDeviceExtension,
    IN PUSHORT Port,
    IN PUSHORT Buffer,
    IN ULONG Count
    );

STORPORT_API
VOID
StorPortWritePortBufferUlong(
    IN PVOID HwDeviceExtension,
    IN PULONG Port,
    IN PULONG Buffer,
    IN ULONG Count
    );

STORPORT_API
VOID
StorPortWriteRegisterUchar(
    IN PVOID HwDeviceExtension,
    IN PUCHAR Register,
    IN UCHAR Value
    );

STORPORT_API
VOID
StorPortWriteRegisterUshort(
    IN PVOID HwDeviceExtension,
    IN PUSHORT Register,
    IN USHORT Value
    );

STORPORT_API
VOID
StorPortWriteRegisterUlong(
    IN PVOID HwDeviceExtension,
    IN PULONG Register,
    IN ULONG Value
    );

STORPORT_API
VOID
StorPortWriteRegisterBufferUchar(
    IN PVOID HwDeviceExtension,
    IN PUCHAR Register,
    IN PUCHAR Buffer,
    IN ULONG  Count
    );

STORPORT_API
VOID
StorPortWriteRegisterBufferUshort(
    IN PVOID HwDeviceExtension,
    IN PUSHORT Register,
    IN PUSHORT Buffer,
    IN ULONG Count
    );

STORPORT_API
VOID
StorPortWriteRegisterBufferUlong(
    IN PVOID HwDeviceExtension,
    IN PULONG Register,
    IN PULONG Buffer,
    IN ULONG Count
    );

STORPORT_API
VOID
StorPortMoveMemory(
    IN PVOID WriteBuffer,
    IN PVOID ReadBuffer,
    IN ULONG Length
    );


#endif

#if (NTDDI_VERSION >= NTDDI_WS03SP1)
#pragma intrinsic (memcpy)

#define StorPortCopyMemory(Destination,Source,Length) memcpy((Destination),(Source),(Length))
#endif

STORPORT_API
STOR_PHYSICAL_ADDRESS
StorPortConvertUlongToPhysicalAddress(
    ULONG_PTR UlongAddress
    );

STORPORT_API
ULONG
StorPortConvertPhysicalAddressToUlong(
    STOR_PHYSICAL_ADDRESS Address
    );

STORPORT_API
VOID
StorPortQuerySystemTime(
    OUT PLARGE_INTEGER CurrentTime
    );

#define StorPortConvertPhysicalAddressToUlong(Address) ((Address).LowPart)
#define StorPortConvertPhysicalAddressToULong64(Address) ((Address).QuadPart)

#define MINIPORT_REG_SZ     1
#define MINIPORT_REG_BINARY 3
#define MINIPORT_REG_DWORD  4

STORPORT_API
PUCHAR
StorPortAllocateRegistryBuffer(
    IN PVOID HwDeviceExtension,
    IN PULONG Length
    );


STORPORT_API
VOID
StorPortFreeRegistryBuffer(
    IN PVOID HwDeviceExtension,
    IN PUCHAR Buffer
    );

BOOLEAN
StorPortRegistryRead(
    IN PVOID HwDeviceExtension,
    IN PUCHAR ValueName,
    IN ULONG Global,
    IN ULONG Type,
    IN PUCHAR Buffer,
    IN PULONG BufferLength
    );

STORPORT_API
BOOLEAN
StorPortRegistryWrite(
    IN PVOID HwDeviceExtension,
    IN PUCHAR ValueName,
    IN ULONG Global,
    IN ULONG Type,
    IN PUCHAR Buffer,
    IN ULONG BufferLength
    );

STORPORT_API
BOOLEAN
StorPortValidateRange(
    IN PVOID HwDeviceExtension,
    IN INTERFACE_TYPE BusType,
    IN ULONG SystemIoBusNumber,
    IN STOR_PHYSICAL_ADDRESS IoAddress,
    IN ULONG NumberOfBytes,
    IN BOOLEAN InIoSpace
    );

STORPORT_API
VOID
StorPortDebugPrint(
    ULONG DebugPrintLevel,
    PCCHAR DebugMessage,
    ...
    );

BOOLEAN
FORCEINLINE
StorPortEnablePassiveInitialization(
    IN PVOID DeviceExtension,
    IN PHW_PASSIVE_INITIALIZE_ROUTINE HwPassiveInitializeRoutine
    )
{
    LONG Succ;

    Succ = FALSE;
    StorPortNotification (EnablePassiveInitialization,
                          DeviceExtension,
                          HwPassiveInitializeRoutine,
                          &Succ);

    return (BOOLEAN)Succ;
}

VOID
FORCEINLINE
StorPortInitializeDpc(
    IN PVOID DeviceExtension,
    OUT PSTOR_DPC Dpc,
    IN PHW_DPC_ROUTINE HwDpcRoutine
    )
{
    StorPortNotification (InitializeDpc,
                          DeviceExtension,
                          Dpc,
                          HwDpcRoutine);
}

BOOLEAN
FORCEINLINE
StorPortIssueDpc(
    IN PVOID DeviceExtension,
    IN PSTOR_DPC Dpc,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )
{
    LONG Succ;

    Succ = FALSE;
    StorPortNotification (IssueDpc,
                          DeviceExtension,
                          Dpc,
                          SystemArgument1,
                          SystemArgument2,
                          &Succ);
    return (BOOLEAN)Succ;
}


VOID
FORCEINLINE
StorPortAcquireSpinLock(
    IN PVOID DeviceExtension,
    IN STOR_SPINLOCK SpinLock,
    IN PVOID LockContext,
    IN PSTOR_LOCK_HANDLE LockHandle
    )
{
    StorPortNotification (AcquireSpinLock,
                          DeviceExtension,
                          SpinLock,
                          LockContext,
                          LockHandle);
}

VOID
FORCEINLINE
StorPortReleaseSpinLock(
    IN PVOID DeviceExtension,
    PSTOR_LOCK_HANDLE LockHandle
    )
{
    StorPortNotification (ReleaseSpinLock,
                          DeviceExtension,
                          LockHandle);
}

STORPORT_API
ULONG
StorPortExtendedFunction(
    IN STORPORT_FUNCTION_CODE FunctionCode,
    IN PVOID HwDeviceExtension,
    ...
    );

ULONG
FORCEINLINE
StorPortAllocatePool(
    IN PVOID HwDeviceExtension,
    IN ULONG NumberOfBytes,
    IN ULONG Tag,
    OUT PVOID *BufferPointer
    )
{
    return StorPortExtendedFunction(ExtFunctionAllocatePool,
                                    HwDeviceExtension,
                                    NumberOfBytes,
                                    Tag,
                                    BufferPointer);
}

ULONG
FORCEINLINE
StorPortFreePool(
    IN PVOID HwDeviceExtension,
    IN PVOID BufferPointer
    )
{
    return StorPortExtendedFunction(ExtFunctionFreePool,
                                    HwDeviceExtension,
                                    BufferPointer);
}

ULONG
FORCEINLINE
StorPortAllocateMdl(
    IN PVOID HwDeviceExtension,
    IN PVOID BufferPointer,
    IN ULONG NumberOfBytes,
    OUT PVOID *Mdl
    )
{
    return StorPortExtendedFunction(ExtFunctionAllocateMdl,
                                    HwDeviceExtension,
                                    BufferPointer,
                                    NumberOfBytes,
                                    Mdl);
}

ULONG
FORCEINLINE
StorPortFreeMdl(
    IN PVOID HwDeviceExtension,
    IN PVOID Mdl
    )
{
    return StorPortExtendedFunction(ExtFunctionFreeMdl,
                                    HwDeviceExtension,
                                    Mdl);
}

ULONG
FORCEINLINE
StorPortBuildMdlForNonPagedPool(
    IN PVOID HwDeviceExtension,
    IN OUT PVOID Mdl
    )
{
    return StorPortExtendedFunction(ExtFunctionBuildMdlForNonPagedPool,
                                    HwDeviceExtension,
                                    Mdl);
}

ULONG
FORCEINLINE
StorPortGetSystemAddress(
    IN PVOID HwDeviceExtension,
    IN PSCSI_REQUEST_BLOCK Srb,
    OUT PVOID *SystemAddress
    )
{
    return StorPortExtendedFunction(ExtFunctionGetSystemAddress,
                                    HwDeviceExtension,
                                    Srb,
                                    SystemAddress);
}

ULONG
FORCEINLINE
StorPortGetOriginalMdl(
    IN PVOID HwDeviceExtension,
    IN PSCSI_REQUEST_BLOCK Srb,
    OUT PVOID *Mdl
    )
{
    return StorPortExtendedFunction(ExtFunctionGetOriginalMdl,
                                    HwDeviceExtension,
                                    Srb,
                                    Mdl);
}

ULONG
FORCEINLINE
StorPortCompleteServiceIrp(
    IN PVOID HwDeviceExtension,
    IN PVOID Irp
    )
{
    return StorPortExtendedFunction(ExtFunctionCompleteServiceIrp,
                                    HwDeviceExtension,
                                    Irp);
}

ULONG
FORCEINLINE
StorPortGetDeviceObjects(
    IN PVOID HwDeviceExtension,
    OUT PVOID *AdapterDeviceObject,
    OUT PVOID *PhysicalDeviceObject,
    OUT PVOID *LowerDeviceObject
    )
{
    return StorPortExtendedFunction(ExtFunctionGetDeviceObjects,
                                    HwDeviceExtension,
                                    AdapterDeviceObject,
                                    PhysicalDeviceObject,
                                    LowerDeviceObject);
}

ULONG
FORCEINLINE
StorPortBuildScatterGatherList(
    IN PVOID HwDeviceExtension,
    IN PVOID Mdl,
    IN PVOID CurrentVa,
    IN ULONG Length,
    IN PpostScaterGatherExecute ExecutionRoutine,
    IN PVOID Context,
    IN BOOLEAN WriteToDevice,
    IN PVOID ScatterGatherBuffer,
    IN ULONG ScatterGatherBufferLength
    )
{
    return StorPortExtendedFunction(ExtFunctionBuildScatterGatherList,
                                    HwDeviceExtension,
                                    Mdl,
                                    CurrentVa,
                                    Length,
                                    ExecutionRoutine,
                                    Context,
                                    WriteToDevice,
                                    ScatterGatherBuffer,
                                    ScatterGatherBufferLength);
}

ULONG
FORCEINLINE
StorPortPutScatterGatherList(
    IN PVOID HwDeviceExtension,
    IN PSTOR_SCATTER_GATHER_LIST ScatterGatherList,
    IN BOOLEAN WriteToDevice
    )
{
    return StorPortExtendedFunction(ExtFunctionPutScatterGatherList,
                                    HwDeviceExtension,
                                    ScatterGatherList,
                                    WriteToDevice);
}

ULONG
FORCEINLINE
StorPortAcquireMSISpinLock(
    IN PVOID HwDeviceExtension,
    IN ULONG MessageId,
    IN PULONG OldIrql
    )
{
    return StorPortExtendedFunction(ExtFunctionAcquireMSISpinLock,
                                    HwDeviceExtension,
                                    MessageId,
                                    OldIrql);
}

ULONG
FORCEINLINE
StorPortReleaseMSISpinLock(
    IN PVOID HwDeviceExtension,
    IN ULONG MessageId,
    IN ULONG OldIrql
    )
{
    return StorPortExtendedFunction(ExtFunctionReleaseMSISpinLock,
                                    HwDeviceExtension,
                                    MessageId,
                                    OldIrql);
}

ULONG
FORCEINLINE
StorPortGetMSIInfo(
    IN PVOID HwDeviceExtension,
    IN ULONG MessageId,
    OUT PMESSAGE_INTERRUPT_INFORMATION InterruptInfo
    )
{
    return StorPortExtendedFunction(ExtFunctionGetMessageInterruptInformation,
                                    HwDeviceExtension,
                                    MessageId,
                                    InterruptInfo);
}

ULONG
FORCEINLINE
StorPortInitializePerfOpts(
    IN PVOID HwDeviceExtension,
    IN BOOLEAN Query,
    IN OUT PPERF_CONFIGURATION_DATA PerfConfigData
    )
{
    return StorPortExtendedFunction(ExtFunctionInitializePerformanceOptimizations,
                                    HwDeviceExtension,
                                    Query,
                                    PerfConfigData);
}

ULONG
FORCEINLINE
StorPortGetStartIoPerfParams(
    IN PVOID HwDeviceExtension,
    IN PSCSI_REQUEST_BLOCK Srb,
    IN OUT PSTARTIO_PERFORMANCE_PARAMETERS StartIoPerfParams
    )
{
    return StorPortExtendedFunction(ExtFunctionGetStartIoPerformanceParameters,
                                    HwDeviceExtension,
                                    Srb,
                                    StartIoPerfParams);
}


//
// Include SCSIPORT definitions for backwards compatability.
//

#if defined (STOR_USE_SCSI_ALIASES)

#define ScsiPortInitialize StorPortInitialize
#define ScsiPortFreeDeviceBase StorPortFreeDeviceBase
#define ScsiPortGetBusData StorPortGetBusData
#define ScsiPortSetBusDataByOffset StorPortSetBusDataByOffset
#define ScsiPortGetDeviceBase StorPortGetDeviceBase
#define ScsiPortGetLogicalUnit StorPortGetLogicalUnit
#define ScsiPortGetSrb StorPortGetSrb
#define ScsiPortGetPhysicalAddress StorPortGetPhysicalAddress
#define ScsiPortGetVirtualAddress StorPortGetVirtualAddress
#define ScsiPortGetUncachedExtension StorPortGetUncachedExtension
#define ScsiPortFlushDma StorPortFlushDma
#define ScsiPortIoMapTransfer StorPortIoMapTransfer
#define ScsiPortNotification StorPortNotification
#define ScsiPortLogError StorPortLogError
#define ScsiPortCompleteRequest StorPortCompleteRequest
#define ScsiPortMoveMemory StorPortMoveMemory
#define ScsiPortReadPortUchar(Port) StorPortReadPortUchar(NULL, Port)
#define ScsiPortReadPortUshort(Port) StorPortReadPortUshort(NULL, Port)
#define ScsiPortReadPortUlong(Port) StorPortReadPortUlong(NULL, Port)
#define ScsiPortReadPortBufferUchar(Port, Buffer, Count) StorPortReadPortBufferUchar(NULL, Port, Buffer, Count)
#define ScsiPortReadPortBufferUshort(Port, Buffer, Count) StorPortReadPortBufferUshort(NULL, Port, Buffer, Count)
#define ScsiPortReadPortBufferUlong(Port, Buffer, Count) StorPortReadPortBufferUlong(NULL, Port, Buffer, Count)
#define ScsiPortReadRegisterUchar(Register) StorPortReadRegisterUchar(NULL, Register)
#define ScsiPortReadRegisterUshort(Register) StorPortReadRegisterUshort(NULL, Register)
#define ScsiPortReadRegisterUlong(Register) StorPortReadRegisterUlong(NULL, Register)
#define ScsiPortReadRegisterBufferUchar(Register, Buffer, Count) StorPortReadRegisterBufferUchar(NULL, Register, Buffer, Count)
#define ScsiPortReadRegisterBufferUshort(Register, Buffer, Count) StorPortReadRegisterBufferUshort(NULL, Register, Buffer, Count)
#define ScsiPortReadRegisterBufferUlong(Register, Buffer, Count) StorPortReadRegisterBufferUlong(NULL, Register, Buffer, Count)
#define ScsiPortStallExecution StorPortStallExecution
#define ScsiPortWritePortUchar(Port, Value) StorPortWritePortUchar(NULL, Port, Value)
#define ScsiPortWritePortUshort(Port, Value) StorPortWritePortUshort(NULL, Port, Value)
#define ScsiPortWritePortUlong(Port, Value) StorPortWritePortUlong(NULL, Port, Value)
#define ScsiPortWritePortBufferUchar(Port, Buffer, Count) StorPortWritePortBufferUchar(NULL, Port, Buffer, Count)
#define ScsiPortWritePortBufferUshort(Port, Buffer, Count) StorPortWritePortBufferUshort(NULL, Port, Buffer, Count)
#define ScsiPortWritePortBufferUlong(Port, Buffer, Count) StorPortWritePortBufferUlong(NULL, Port, Buffer, Count)
#define ScsiPortWriteRegisterUchar(Register, Value) StorPortWriteRegisterUchar(NULL, Register, Value)
#define ScsiPortWriteRegisterUshort(Register, Value) StorPortWriteRegisterUshort(NULL, Register, Value)
#define ScsiPortWriteRegisterUlong(Register, Value) StorPortWriteRegisterUlong(NULL, Register, Value)
#define ScsiPortWriteRegisterBufferUchar(Register, Buffer, Count) StorPortWriteRegisterBufferUchar(NULL, Register, Buffer, Count)
#define ScsiPortWriteRegisterBufferUshort(Register, Buffer, Count) StorPortWriteRegisterBufferUshort(NULL, Register, Buffer, Count)
#define ScsiPortWriteRegisterBufferUlong(Register, Buffer, Count) StorPortWriteRegisterBufferUlong(NULL, Register, Buffer, Count)
#define ScsiPortConvertUlongToPhysicalAddress StorPortConvertUlongToPhysicalAddress
#define ScsiPortConvertPhysicalAddressToUlong StorPortConvertPhysicalAddressToUlong
#define ScsiPortQuerySystemTime StorPortQuerySystemTime
#define ScsiPortValidateRange StorPortValidateRange
#define ScsiDebugPrint StorPortDebugPrint

typedef PHYSICAL_ADDRESS SCSI_PHYSICAL_ADDRESS, *PSCSI_PHYSICAL_ADDRESS;

#endif // STOR_USE_SCSI_ALIASES


#if _MSC_VER >= 1200
#pragma warning(pop) // un-sets any local warning changes
#else
#pragma warning(default:4200) // array[0] is not a warning for this file
#pragma warning(default:4201) // nonstandard extension used : nameless struct/union
#endif

#endif // !defined _NTSTORPORT_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\storswtr.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

    THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
    KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
    IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
    PURPOSE.

Module Name:

    storswtr.h

Abstract:

    Software Traceing for Storage Drivers

Environment:

    Kernel mode


--*/

#ifndef _stortrce_h_
#define _stortrce_h_

#include <stdarg.h>

//
// Ensure error level constants are defined correctly
//
#ifdef TRACE_LEVEL_FATAL
#undef TRACE_LEVEL_FATAL
#endif

#ifdef TRACE_LEVEL_ERROR
#undef TRACE_LEVEL_ERROR
#endif

#ifdef TRACE_LEVEL_WARNING
#undef TRACE_LEVEL_WARNING
#endif

#ifdef TRACE_LEVEL_INFORMATION
#undef TRACE_LEVEL_INFORMATION
#endif

#ifdef TRACE_LEVEL_VERBOSE
#undef TRACE_LEVEL_VERBOSE
#endif

//
// Error level codes
//
#define TRACE_LEVEL_FATAL           1
#define TRACE_LEVEL_ERROR           2
#define TRACE_LEVEL_WARNING         3
#define TRACE_LEVEL_INFORMATION     4
#define TRACE_LEVEL_VERBOSE         5

//
// DEBUG_USE_KDPRINT: if defined, uses KdPrint instead of WMI tracing
//
#ifndef DEBUG_USE_KDPRINT

//
// Defines standard flag bits for all storage drivers
//
#define WPP_NORMAL_FLAGS    WPP_DEFINE_BIT(TRACE_FLAG_GENERAL)  \
                            WPP_DEFINE_BIT(TRACE_FLAG_PNP)      \
                            WPP_DEFINE_BIT(TRACE_FLAG_POWER)    \
                            WPP_DEFINE_BIT(TRACE_FLAG_RW)       \
                            WPP_DEFINE_BIT(TRACE_FLAG_IOCTL)    \
                            WPP_DEFINE_BIT(TRACE_FLAG_QUEUE)    \
                            WPP_DEFINE_BIT(TRACE_FLAG_WMI)      \
                            WPP_DEFINE_BIT(TRACE_FLAG_TIMER)    \
                            WPP_DEFINE_BIT(TRACE_FLAG_INIT)     \
                            WPP_DEFINE_BIT(TRACE_FLAG_LOCK)     \
                            WPP_DEFINE_BIT(TRACE_FLAG_DEBUG1)   \
                            WPP_DEFINE_BIT(TRACE_FLAG_DEBUG2)   \
                            WPP_DEFINE_BIT(TRACE_FLAG_MCN)      \
                            WPP_DEFINE_BIT(TRACE_FLAG_ISR)      \
                            WPP_DEFINE_BIT(TRACE_FLAG_ENUM)

//
// Allows source file to specify only the GUID to enable WMI tracing
//
#define WPP_CONTROL_GUIDS_NORMAL_FLAGS(_GUID)   \
    WPP_DEFINE_CONTROL_GUID(wppCtlGuid, _GUID, WPP_NORMAL_FLAGS)

//
// Overrides of default functions to allow us to specify both flags and error levels with error messages
//
#define WPP_LEVEL_FLAGS_ENABLED(lvl, flags) (WPP_LEVEL_ENABLED(flags) && WPP_CONTROL(WPP_BIT_ ## flags).Level >= lvl)
#define WPP_LEVEL_FLAGS_LOGGER(lvl,flags)   WPP_LEVEL_LOGGER(flags)

//
// Used in the source to selectively include the '.tmh' file as well as define the GUID
//
#define DEBUG_USE_WPP

//
// Use KdPrint instead of WMI tracing
//
#else

//
// Used in the source file to ensure the '.tmh' file is not included
//
#ifdef DEBUG_USE_WPP
#undef DEBUG_USE_WPP
#endif

//
// Ensure both WPP_INIT_TRACING and WPP_CLEANUP are not defined, and replace with NOOPS
// These macros are only used when performing WMI tracing, which we are not
//
#ifdef WPP_INIT_TRACING
#undef WPP_INIT_TRACING
#endif

#ifdef WPP_CLEANUP
#undef WPP_CLEANUP
#endif

#define WPP_INIT_TRACING(_DRIVER, _REGISTRY)
#define WPP_CLEANUP(_DRIVER)

//
// Initialize debug flags enumeration as it is not declared
//
typedef enum _DEBUG_FLAGS {
    TRACE_FLAG_GENERAL = 0,
    TRACE_FLAG_PNP,
    TRACE_FLAG_POWER,
    TRACE_FLAG_RW,
    TRACE_FLAG_IOCTL,
    TRACE_FLAG_QUEUE,
    TRACE_FLAG_WMI,
    TRACE_FLAG_TIMER,
    TRACE_FLAG_INIT,
    TRACE_FLAG_LOCK,
    TRACE_FLAG_DEBUG1,
    TRACE_FLAG_DEBUG2,
    TRACE_FLAG_MCN,
    TRACE_FLAG_ISR,
    TRACE_FLAG_ENUM
} DEBUG_FLAGS, *PDEBUG_FLAGS;

//
// Redirect WMI tracing calls to the DbgPrint function.  We are forced to drop the flags argument as
// DbgPrintEx does not use it.  We only want one function definition when linked togethor, so
// we must define
//


#if DBG

#define TracePrint(x)   StorDebugPrint x

#if DEBUG_MAIN_SOURCE

void StorDebugPrint(int DebugPrintLevel, DEBUG_FLAGS DebugPrintFlags, PCCHAR DebugMessage, ...) {
    va_list ap;
    va_start(ap, DebugMessage);

    vDbgPrintEx(DEBUG_COMP_ID, DebugPrintLevel, DebugMessage, ap);

    va_end(ap);
}

#else

void StorDebugPrint(int DebugPrintLevel, DEBUG_FLAGS DebugPrintFlags, PCCHAR DebugMessage, ...);

#endif  // DEBUG_MAIN_SOURCE

#else

#define TracePrint(x)

#endif  // DBG

#endif  // DEBUG_USE_KDPRINT

#endif  // _stortrce_h_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\stortrce.h ===
/*++

Copyright (c) 2004  Microsoft Corporation

Module Name:

    stortrce.w

Abstract:

    These are the structures and definitions used for tracing
    in storage miniports.

Authors:

Revision History:

--*/

#include <stdarg.h>

#ifndef _NTSTORTRCE_
#define _NTSTORTRCE_

#define INLINE  __inline

//
// Determine the right PortNotification call for the miniport
//
#ifndef _PortTraceNotification

//
// Storport miniport
//
#ifdef _NTSTORPORT_
#define _PortTraceNotification StorPortNotification
#endif

//
// Scsi miniport
//
#ifdef _NTSRB_
#undef _PortTraceNotification
#define _PortTraceNotification   ScsiPortNotification
#endif

//
// Ata miniport
//
#ifdef _NTIRB_
#undef _PortTraceNotification
#define _PortTraceNotification   AtaPortTraceNotification
#endif

#ifndef _PortTraceNotification
#error "PortNotification not defined. Include scsi.h or storport.h or irb.h"
#endif

#endif   //#ifndef _PortTraceNotification

#ifndef StorMoveMemory

#ifdef _NTSTORPORT_
#define StorMoveMemory  StorPortMoveMemory
#endif

#ifdef _NTSRB_
#undef StorMoveMemory
#define StorMoveMemory   ScsiPortMoveMemory
#endif

#ifdef _NTIRB_
#undef StorMoveMemory
#define StorMoveMemory   AtaPortMoveMemory
#endif

#ifndef StorMoveMemory
#error "StorMoveMemory not defined. Include scsi.h or storport.h or irb.h"
#endif

#endif //#ifndef StorMoveMemory

typedef PVOID STORAGE_TRACE_CONTEXT;

//
// Prototype for the cleanup routine
//
typedef 
VOID
(*STOR_CLEANUP_TRACING) (
        PVOID Arg1
        );

//
// This structure is used to initializing the storage tracing library.
//
typedef struct _STORAGE_TRACE_INIT_INFO {
    //
    // The size, in bytes, of this structure.
    //
    ULONG Size;

    //
    // The number of diagnostic contexts the caller wants pre-allocated for
    // diagnostic events. By pre-allocating contexts, the caller will be
    // able to generate diagnostic events at any IRQL.
    //
    ULONG NumDiagEventRecords;

    //
    // The size, in bytes, of the user-defined data space to be allocated in
    // each pre-allocated diagnostic context.
    //
    ULONG DiagEventRecordUserDataSize;

    //
    // The number of error log records the caller wants pre-allocated.
    //
    ULONG NumErrorLogRecords;

    //
    // The trace GUID of the caller uniquely identifies the component as a
    // diagnostic event source.
    //
    GUID TraceGuid;

    //
    // Callback to cleanup tracing
    //
    STOR_CLEANUP_TRACING TraceCleanupRoutine;

    //
    // A pointer to the caller's driver object.
    //
    PVOID DriverObject;

    //
    // OUT : TraceContext to be used for error/diag support
    //
    PVOID TraceContext;

} STORAGE_TRACE_INIT_INFO, *PSTORAGE_TRACE_INIT_INFO;


//
// This structure is used to hold the user data that is attached to a
// diagnostic event.
//
typedef struct _STORAGE_DIAG_EVENT_RECORD {

    //
    // The size, in bytes of this structure. This value includes the
    // size of the information.
    //
    ULONG Size;

    //
    // Reserved.
    //
    ULONG Reserved;

    //
    // Additional information to be sent with the diagnostic event.
    //
    UCHAR Info[1];
} STORAGE_DIAG_EVENT_RECORD, *PSTORAGE_DIAG_EVENT_RECORD;


//
// This structure holds information about a diagnostic trace event.
//
typedef struct _STORAGE_TRACE_DPS_INFO {
    //
    // The event ID uniquely identifies a diagnostic event. Applications
    // can use the value to identify certain and take specific actions
    // accordingly.
    //
    GUID EventId;

    //
    // The flags field is used to control how the tracing library sends a
    // diagnostic trace event.
    //
    ULONG Flags;

    //
    // The status of the attempt to log the diagnostic event is recorded in
    // the status field.
    //
    ULONG Status;

    //
    // This field specifies the number of TRACE_CONTEXT records the caller is
    // supplying in the Contexts array.
    //
    ULONG NumContexts;

    //
    // An array of TRACE_CONTEXT structures. To be sent with the diagnostic
    // event.
    //
    PVOID Contexts;

    //
    // Specifies the size of the user data area.
    //
    ULONG UserDataSize;
    
} STORAGE_TRACE_DPS_INFO, *PSTORAGE_TRACE_DPS_INFO;

//
// This structure holds the error log from the miniport
//
typedef struct _STORAGE_ERRORLOG_PACKET {
    UCHAR         MajorFunctionCode;
    UCHAR         RetryCount;
    USHORT        DumpDataSize;
    USHORT        NumberOfStrings;
    USHORT        StringOffset;
    USHORT        EventCategory;
    ULONG         ErrorCode;
    ULONG         UniqueErrorValue;
    ULONG         FinalStatus;
    ULONG         SequenceNumber;
    ULONG         IoControlCode;
    LARGE_INTEGER DeviceOffset;
    ULONG         DumpData[1];
} STORAGE_ERRORLOG_PACKET, *PSTORAGE_ERRORLOG_PACKET;

//
// Tracing related notification types
//
typedef enum _STORAGE_TRACE_NOTIFY_TYPE {
    //
    // Initialization and cleanup
    //
    InitTracing = 1000,                 // 0x3E8 (1000)
    CleanupTracing,                     // 0x3E9 (1001)

    //
    // WPP support
    //
    TraceMessage = 2000,                // 0x7D0 (2000)
    InitGlobalLogger,                   // 0x7D1 (2001)
    WMIRegistrationControl,             // 0x7E2 (2002)
    WmiQueryTraceInfo,                  // 0x7E3 (2003)
    InitUnicodeString,                  // 0x7E4 (2004) 
    TraceDebugPrint,                    // 0x7E5 (2005)
        
    //
    // WDI support
    //
    AllocDiagEvent = 3000,              // 0xBB8 (3000)
    FreeDiagEvent,                      // 0xBB9 (3001)
    LogDiagEvent,                       // 0xBBA (3002)

    //
    // Error log support
    //
    WriteErrorLogRecord = 4000,         // 0xFA0 (4000)
    AllocErrorLog,
    FreeErrorLog

} STORAGE_TRACE_NOTIFY_TYPE, *PSTORAGE_TRACE_NOTIFY_TYPE;


//
// StorDebugPrint
//

typedef struct _STOR_DEBUGPRINT_ARGS {
    PCHAR                      Message;
    va_list                    ArgList;
} STOR_DEBUGPRINT_ARGS, *PSTOR_DEBUGPRINT_ARGS;

//
// StorInitTracing
//

typedef struct _STOR_INIT_TRACING_ARGS {
    PVOID   InitInfo;
    ULONG   Result;
} STOR_INIT_TRACING_ARGS, *PSTOR_INIT_TRACING_ARGS;


//
// StorCleanupTracing
//

typedef struct _STOR_CLEANUP_TRACING_ARGS {
    PVOID                      TraceContext;
} STOR_CLEANUP_TRACING_ARGS, *PSTOR_CLEANUP_TRACING_ARGS;

//
// WriteErrorLogEntry
//

typedef struct _STOR_WRITE_EL_RECORD_ARGS {
    PVOID                      TraceContext;
    PVOID                      ErrorLogPacket;
} STOR_WRITE_EL_RECORD_ARGS, *PSTOR_WRITE_EL_RECORD_ARGS;

//
// AllocateErrorLogEntry
//

typedef struct _STOR_ALLOC_EL_RECORD_ARGS {
    PVOID                      TraceContext;
    ULONG                      Size;
    PSTORAGE_ERRORLOG_PACKET   Result;
} STOR_ALLOC_EL_RECORD_ARGS, *PSTOR_ALLOC_EL_RECORD_ARGS;

//
// FreeErrorLogEntry
//

typedef struct _STOR_FREE_EL_RECORD_ARGS {
    PVOID                      TraceContext;
    PSTORAGE_ERRORLOG_PACKET   ErrorLogPacket;
} STOR_FREE_EL_RECORD_ARGS, *PSTOR_FREE_EL_RECORD_ARGS;


//
// TraceDriverLogEvent
//

typedef struct _STOR_LOG_DIAG_EVENT_ARGS {
    PVOID                      TraceContext;
    PVOID                      ContextEvent;
    ULONG                      result;
} STOR_LOG_DIAG_EVENT_ARGS, *PSTOR_LOG_DIAG_EVENT_ARGS;


//
// TraceDriverAllocEvent
//

typedef struct _STOR_ALLOC_DIAG_EVENT_ARGS {
    PVOID                      TraceContext;
    ULONG                      UserDataSize;
    BOOLEAN                    Allocate;
    PVOID                      result;    
} STOR_ALLOC_DIAG_EVENT_ARGS, *PSTOR_ALLOC_DIAG_EVENT_ARGS;


//
// TraceDriverFreeEvent
//

typedef struct _STOR_FREE_DIAG_EVENT_ARGS {
    PVOID                      TraceContext;
    PVOID                      EventRecord;
} STOR_FREE_DIAG_EVENT_ARGS, *PSTOR_FREE_DIAG_EVENT_ARGS;


//
// WmiTraceMessage
//

typedef struct _STOR_WMI_TRACE_MESSAGE_ARGS {
    ULONG64                    TraceHandle;
    ULONG                      MessageFlags;
    LPGUID                     MessageGuid;
    USHORT                     MessageNumber;
    va_list                    Args;
    ULONG                      result;
} STOR_WMI_TRACE_MESSAGE_ARGS, *PSTOR_WMI_TRACE_MESSAGE_ARGS;

//
// RtlInitUnicodeString
//

typedef struct _STOR_INIT_UNICODE_STRING_ARGS {
    PVOID                      DestinationString;
    PCWSTR                     SourceString;
} STOR_INIT_UNICODE_STRING_ARGS, *PSTOR_INIT_UNICODE_STRING_ARGS;


//
// IoWMIRegistrationControl
//

typedef struct _STOR_WMI_REGCONTROL_ARGS {
    PVOID                      DeviceObject;
    ULONG                      Action;
    ULONG                      result;
} STOR_WMI_REGCONTROL_ARGS, *PSTOR_WMI_REGCONTROL_ARGS;


//
// IoWMIRegistrationControl
//

typedef struct _STOR_WMI_QUERYTRACEINFO_ARGS {
    ULONG                      TraceInformationClass;
    PVOID                      TraceInformation;
    ULONG                      TraceInformationLength;
    PULONG                     RequiredLength;
    PVOID                      Buffer;
    ULONG                      result;
} STOR_WMI_QUERYTRACEINFO_ARGS, *PSTOR_WMI_QUERYTRACEINFO_ARGS;


//
// WppInitGlobalLogger
//

typedef struct _STOR_INITGLOBALLOGGER_ARGS {
    LPCGUID                     ControlGuid;
    PVOID                       Logger;
    PVOID                       Flags;
    PVOID                       Level;
} STOR_INITGLOBALLOGGER_ARGS, *PSTOR_INITGLOBALLOGGER_ARGS;

//
// memset
//
#define StorMemSet(dst, val, count) \
{ \
    ULONG _i = count; \
    while (_i) { \
        *((char *)dst+_i-1) = (char)val; \
        _i--; \
    } \
} 

//
// StorInitTracing
//

ULONG
__inline
StorInitTracing(
    IN PVOID  InitInfo
    )
{
    STOR_INIT_TRACING_ARGS args = {InitInfo, 0xC00000BB};
    _PortTraceNotification(TraceNotification, NULL, InitTracing, &args);

    return args.Result;
}

//
// StorCleanupTracing
//

VOID
__inline
StorCleanupTracing(
    IN PVOID TraceContext
    )
{
    STOR_CLEANUP_TRACING_ARGS args = {TraceContext};
    _PortTraceNotification(TraceNotification, NULL, CleanupTracing, &args);
}

//
// TraceDriverLogEvent
//

ULONG
__inline
StorTraceDiagLogEvent(
    IN PVOID                 DeviceExtension,
    IN STORAGE_TRACE_CONTEXT TraceContext,
    IN PVOID                 Event
    )
{
    STOR_LOG_DIAG_EVENT_ARGS args = {TraceContext, Event};
    _PortTraceNotification(TraceNotification, DeviceExtension, LogDiagEvent, &args);
    return args.result;
}

//
// TraceDriverAllocEvent
//

PVOID
__inline
StorTraceDiagAllocEvent(
    IN PVOID                 DeviceExtension,
    IN STORAGE_TRACE_CONTEXT TraceContext,
    IN ULONG                 DataSize,
    IN BOOLEAN               Allocate
    )
{
    STOR_ALLOC_DIAG_EVENT_ARGS args = {TraceContext, DataSize, Allocate};
    _PortTraceNotification(TraceNotification, DeviceExtension, AllocDiagEvent, &args);

    return args.result;
}

//
// TraceDriverFreeEvent
//

VOID
__inline
StorTraceDiagFreeEvent(
    IN PVOID                 DeviceExtension,
    IN STORAGE_TRACE_CONTEXT TraceContext,
    IN PVOID                 Event
    )
{
    STOR_FREE_DIAG_EVENT_ARGS args = {TraceContext, Event};
    _PortTraceNotification(TraceNotification, DeviceExtension, FreeDiagEvent, &args);
}

//
// WriteErrorLogEntry
//

VOID
__inline
StorTraceErrorWriteRecord(
    PVOID  DeviceExtension,
    PVOID  Arg1,
    PVOID  Arg2
    )
{
    STOR_WRITE_EL_RECORD_ARGS args = {Arg1, Arg2};
    _PortTraceNotification(TraceNotification, DeviceExtension, WriteErrorLogRecord, &args);
}

//
// AllocateErrorLogEntry
//

PSTORAGE_ERRORLOG_PACKET
__inline
StorTraceErrorAllocRecord(
    IN PVOID                        DeviceExtension,
    IN STORAGE_TRACE_CONTEXT        TraceContext,
    IN ULONG                        Size
    )
{
    STOR_ALLOC_EL_RECORD_ARGS args = {TraceContext, Size};
    _PortTraceNotification(TraceNotification, DeviceExtension, AllocErrorLog, &args);
    return args.Result;
}

//
// FreeErrorLogEntry
//

VOID
__inline
StorTraceErrorFreeRecord(
    IN PVOID                    DeviceExtension,
    IN STORAGE_TRACE_CONTEXT    TraceContext,
    IN PSTORAGE_ERRORLOG_PACKET ErrorLogPacket
    )
{
    STOR_FREE_EL_RECORD_ARGS args = {TraceContext, ErrorLogPacket};
    _PortTraceNotification(TraceNotification, DeviceExtension, FreeErrorLog, &args);
}

//
// WmiTraceMessage
//

ULONG
__inline
StorWmiTraceMessage(
    IN ULONG64 Arg1,
    IN ULONG   Arg2,
    IN LPGUID  Arg3,
    IN USHORT  Arg4,
    ... 
    )
{
    STOR_WMI_TRACE_MESSAGE_ARGS args = {Arg1, Arg2, Arg3, Arg4, };
    va_list ap;
    va_start(ap, Arg4);
    args.Args = ap;

    _PortTraceNotification(TraceNotification, NULL, TraceMessage, &args);
    return args.result;
}

//
// RtlInitUnicodeString
//

VOID
__inline
StorRtlInitUnicodeString(
    IN OUT PVOID Arg1,
    IN PCWSTR    Arg2
    )
{
    STOR_INIT_UNICODE_STRING_ARGS args = {Arg1, Arg2};
    _PortTraceNotification(TraceNotification, NULL, InitUnicodeString, &args);
}

//
// WppInitGlobalLogger
//

VOID
__inline
StorWppInitGlobalLogger(
    LPCGUID Arg1,
    PVOID Arg2,
    PVOID Arg3,
    PVOID Arg4
    )
{
    STOR_INITGLOBALLOGGER_ARGS args = {Arg1, Arg2, Arg3, Arg4};
    _PortTraceNotification(TraceNotification, NULL, InitGlobalLogger, &args);
}

//
// IoWMIRegistrationControl
//

ULONG
__inline
StorIoWMIRegistrationControl(
    IN PVOID Arg1,
    IN ULONG Arg2
    )
{
    STOR_WMI_REGCONTROL_ARGS args = {Arg1, Arg2};
    _PortTraceNotification(TraceNotification, NULL, WMIRegistrationControl, &args);
    return args.result;
}

//
// WmiQueryTraceInformation
//

ULONG
__inline
StorWmiQueryTraceInformation(
    IN  ULONG  Arg1,
    OUT PVOID  Arg2,
    IN  ULONG  Arg3,
    OUT PULONG Arg4,
    IN  PVOID  Arg5
    )
{
    STOR_WMI_QUERYTRACEINFO_ARGS args = {Arg1, Arg2, Arg3, Arg4, Arg5};
    _PortTraceNotification(TraceNotification, NULL, WmiQueryTraceInfo, &args);
    return args.result;
}


/*
//
// DebugPrint
//

VOID
__inline
StorDebugPrint(
    PCHAR   Arg1,
    va_list Arg2
    )
{
    STOR_DEBUGPRINT_ARGS args = {Arg1, Arg2};
    _PortTraceNotification(TraceNotification, NULL, TraceDebugPrint, &args);
}


#ifdef DO_DBGPRINT
#define WPP_DEBUG(A) StorDebugPrint A
#endif
*/

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\strmini.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    STRMINI.H

Abstract:

    This file defines streaming minidriver structures and class/minidriver
    interfaces.

Author:

    Bill Parry

Environment:

   Kernel mode only

Revision History:

--*/

#ifndef _STREAM_H
#define _STREAM_H

#include <wdm.h>
#include <windef.h>
#include <stdio.h>
#include "ks.h"

#define STREAMAPI __stdcall

typedef unsigned __int64 STREAM_SYSTEM_TIME,
               *PSTREAM_SYSTEM_TIME;
typedef unsigned __int64 STREAM_TIMESTAMP,
               *PSTREAM_TIMESTAMP;
#define STREAM_SYSTEM_TIME_MASK   ((STREAM_SYSTEM_TIME)0x00000001FFFFFFFF)
//
// debug print level values
//

typedef enum {                  // Use the given level to indicate:
    DebugLevelFatal = 0,        // * imminent nonrecoverable system failure
    DebugLevelError,            // * serious error, though recoverable
    DebugLevelWarning,          // * warnings of unusual occurances
    DebugLevelInfo,             // * status and other information - normal
    // though
    // perhaps unusual events. System MUST remain
    // responsive.
    DebugLevelTrace,            // * trace information - normal events
    // system need not ramain responsive
    DebugLevelVerbose,          // * verbose trace information
    // system need not remain responsive
    DebugLevelMaximum
}               STREAM_DEBUG_LEVEL;

#define DebugLevelAlways    DebugLevelFatal

#if DBG

//
// macro for printing debug information
//
#define DebugPrint(x) StreamClassDebugPrint x

//
// macro for doing INT 3 (or non-x86 equivalent)
//

#if WIN95_BUILD

#define DEBUG_BREAKPOINT() _asm int 3;

#else

#define DEBUG_BREAKPOINT() DbgBreakPoint()

#endif

//
// macro for asserting (stops if not = TRUE)
//

#define DEBUG_ASSERT(exp) \
            if ( !(exp) ) { \
                StreamClassDebugAssert( __FILE__, __LINE__, #exp, exp); \
            }

#else

#define DebugPrint(x)
#define DEBUG_BREAKPOINT()
#define DEBUG_ASSERT(exp)

#endif

//
// Uninitialized flag value.
//

#define MP_UNINITIALIZED_VALUE ((ULONG) ~0)

//
// define physical address formats
//

typedef PHYSICAL_ADDRESS STREAM_PHYSICAL_ADDRESS,
               *PSTREAM_PHYSICAL_ADDRESS;


//
// functions for the time context structure below
//

typedef enum {

    TIME_GET_STREAM_TIME,
    TIME_READ_ONBOARD_CLOCK,
    TIME_SET_ONBOARD_CLOCK
}               TIME_FUNCTION;

//
// define the time context structure
//

typedef struct _HW_TIME_CONTEXT {

    struct _HW_DEVICE_EXTENSION *HwDeviceExtension;
    struct _HW_STREAM_OBJECT *HwStreamObject;
    TIME_FUNCTION   Function;
    ULONGLONG       Time;
    ULONGLONG       SystemTime;
}               HW_TIME_CONTEXT, *PHW_TIME_CONTEXT;

//
// define the event descriptor for enabling/disabling events.
//

typedef struct _HW_EVENT_DESCRIPTOR {
    BOOLEAN       Enable;  // TRUE means this is an enable, FALSE means disable
    PKSEVENT_ENTRY EventEntry;  // event structure
    PKSEVENTDATA EventData;  // data representing this event
    union {
    struct _HW_STREAM_OBJECT * StreamObject; // stream object for the event
    struct _HW_DEVICE_EXTENSION *DeviceExtension;
    };
    ULONG EnableEventSetIndex; // gives the index of the event set for ENABLE
                               // field has no meaning for DISABLE

#if (NTDDI_VERSION >= NTDDI_WINXP)
    PVOID HwInstanceExtension;
    ULONG Reserved;
#else
    ULONG Reserved[2];    // Reserved for future use
#endif

} HW_EVENT_DESCRIPTOR, *PHW_EVENT_DESCRIPTOR;

//
// function prototypes for stream object functions
//

typedef         VOID
                (STREAMAPI * PHW_RECEIVE_STREAM_DATA_SRB) ( // HwReceiveDataPacket
                                             IN struct _HW_STREAM_REQUEST_BLOCK * SRB
);

typedef         VOID
                (STREAMAPI * PHW_RECEIVE_STREAM_CONTROL_SRB) (  // HwReceiveControlPacket
                                             IN struct _HW_STREAM_REQUEST_BLOCK  * SRB
);

typedef         NTSTATUS
                (STREAMAPI * PHW_EVENT_ROUTINE) ( // HwEventRoutine
                                             IN PHW_EVENT_DESCRIPTOR EventDescriptor
);

typedef         VOID
                (STREAMAPI * PHW_CLOCK_FUNCTION) ( // HwClockFunction
                                             IN PHW_TIME_CONTEXT HwTimeContext
);

//
// define the clock object
//

typedef struct _HW_CLOCK_OBJECT {

    //
    // pointer to the minidriver's clock function
    //

    PHW_CLOCK_FUNCTION HwClockFunction;

    //
    // support flags as defined below
    //

    ULONG    ClockSupportFlags;

    ULONG Reserved[2];    // Reserved for future use
} HW_CLOCK_OBJECT, *PHW_CLOCK_OBJECT;

//
// clock object support flags defined as follows
//

//
// indicates that the minidriver's clock for this stream is tunable
// via TIME_SET_ONBOARD_CLOCK
//

#define CLOCK_SUPPORT_CAN_SET_ONBOARD_CLOCK 0x00000001

//
// indicates that the minidriver's clock for this stream is raw readable
// via TIME_READ_ONBOARD_CLOCK
//

#define CLOCK_SUPPORT_CAN_READ_ONBOARD_CLOCK 0x00000002

//
// indicates that the minidriver can return the current stream time for this
// stream via TIME_GET_STREAM_TIME
//

#define CLOCK_SUPPORT_CAN_RETURN_STREAM_TIME 0x00000004

//
// stream object definition
//

typedef struct _HW_STREAM_OBJECT {
    ULONG           SizeOfThisPacket; // size of this structure
    ULONG           StreamNumber;   // number of this stream
    PVOID           HwStreamExtension;  // minidriver's stream extension
    PHW_RECEIVE_STREAM_DATA_SRB ReceiveDataPacket;  // receive data packet routine
    PHW_RECEIVE_STREAM_CONTROL_SRB ReceiveControlPacket;   // receive control packet routine
    HW_CLOCK_OBJECT HwClockObject;    // clock object to be filled in by
                                      // minidriver
    BOOLEAN         Dma;        // device uses busmaster DMA
    // for this stream
    BOOLEAN         Pio;        // device uses PIO for this
    PVOID           HwDeviceExtension;  // minidriver's device ext.

    ULONG    StreamHeaderMediaSpecific;  // Size of media specific per
                                         // stream header expansion. 
    ULONG    StreamHeaderWorkspace; // Size of per-stream header workspace.
    BOOLEAN Allocator;  // Set to TRUE if allocator is needed for this stream.    

    //
    // the following routine receives ENABLE and DISABLE notification of
    // KS synchronization events for this stream.
    //

    PHW_EVENT_ROUTINE HwEventRoutine;

    ULONG Reserved[2];    // Reserved for future use

} HW_STREAM_OBJECT, *PHW_STREAM_OBJECT;

//
// the following structures are used to report which stream types and properties
// are supported by the minidriver.  the HW_STREAM_HEADER structure is followed
// in memory by one or more HW_STREAM_INFORMATION structures.  See the
// HW_STREAM_DESCRIPTOR structure below.
//

typedef struct _HW_STREAM_HEADER {

    //
    // indicates the number of HW_STREAM_INFORMATION structures follow this
    // structure.
    //

    ULONG           NumberOfStreams;

    //
    // size of the HW_STREAM_INFORMATION structure below (filled in by the
    // minidriver)
    //

    ULONG SizeOfHwStreamInformation;

    //
    // indicates the number of property sets supported by the device itself.
    //

    ULONG           NumDevPropArrayEntries;

    //
    // pointer to the array of device property sets.
    //

    PKSPROPERTY_SET DevicePropertiesArray;
    
    //
    // indicates the number of event sets supported by the device itself.
    //

    ULONG           NumDevEventArrayEntries;

    //
    // pointer to the array of device property sets.
    //

    PKSEVENT_SET DeviceEventsArray;

    //
    // pointer to the topology structure
    //

    PKSTOPOLOGY Topology;

    //
    // event routine for processing device events, if any.
    //

    PHW_EVENT_ROUTINE DeviceEventRoutine;
    
#if (NTDDI_VERSION >= NTDDI_WINXP)
    LONG            NumDevMethodArrayEntries;
    PKSMETHOD_SET   DeviceMethodsArray;
#else
    ULONG Reserved[2];    // Reserved for future use
#endif

}               HW_STREAM_HEADER, *PHW_STREAM_HEADER;

//
// the HW_STREAM_INFORMATION structure(s) indicate what streams are supported
//

typedef struct _HW_STREAM_INFORMATION {

    //
    // number of possible instances of this stream that can be opened at once
    //

    ULONG           NumberOfPossibleInstances;

    //
    // Indicates the direction of data flow of this stream
    //

    KSPIN_DATAFLOW  DataFlow;

    //
    // Indicates whether the data is "seen" by the host processor.  If the
    // data is not visible to the processor (such as an NTSC output port)
    // this boolean is set to false.
    //

    BOOLEAN         DataAccessible;

    //
    // Number of formats supported by this stream.  Indicates the number of
    // elements pointed to by StreamFormatsArray below.
    //

    ULONG           NumberOfFormatArrayEntries;

    //
    // pointer to an array of elements indicating what types of data are
    // supported with this stream.
    //

    PKSDATAFORMAT*  StreamFormatsArray;

    //
    // reserved for future use.
    //

    PVOID           ClassReserved[4];

    //
    // number of property sets supported by this stream
    //

    ULONG           NumStreamPropArrayEntries;

    //
    // pointer to an array of property set descriptors for this stream
    //

    PKSPROPERTY_SET StreamPropertiesArray;

    //
    // number of event sets supported by this stream
    //

    ULONG           NumStreamEventArrayEntries;

    //
    // pointer to an array of event set descriptors for this stream
    //

    PKSEVENT_SET StreamEventsArray;

    //
    // pointer to guid representing catagory of stream.  (optional)
    //

    GUID*                   Category;
    
    //
    // pointer to guid representing name of stream.  (optional)
    //

    GUID*                   Name;

    //
    // count of media supported (optional)
    //

    ULONG                   MediumsCount;

    //
    // pointer to array of media (optional)
    //

    const KSPIN_MEDIUM*     Mediums;

    //
    // indicates that this stream is a bridge stream (COMMUNICATIONS BRIDGE)
    // this field should be set to FALSE by most minidrivers.
    //

    BOOLEAN         BridgeStream;
    ULONG Reserved[2];    // Reserved for future use

}               HW_STREAM_INFORMATION, *PHW_STREAM_INFORMATION;


typedef struct _HW_STREAM_DESCRIPTOR {

    //
    // header as defined above
    //

    HW_STREAM_HEADER StreamHeader;

    //
    // one or more of the following, as indicated by NumberOfStreams in the
    // header.
    //

    HW_STREAM_INFORMATION StreamInfo;

}               HW_STREAM_DESCRIPTOR, *PHW_STREAM_DESCRIPTOR;

//
// STREAM Time Reference structure
//

typedef struct _STREAM_TIME_REFERENCE {
    STREAM_TIMESTAMP CurrentOnboardClockValue;  // current value of adapter
    // clock
    LARGE_INTEGER   OnboardClockFrequency;  // frequency of adapter clock
    LARGE_INTEGER   CurrentSystemTime;  // KeQueryPeformanceCounter time
    ULONG Reserved[2];    // Reserved for future use
}               STREAM_TIME_REFERENCE, *PSTREAM_TIME_REFERENCE;

//
// data intersection structure.   this structure is point to by the
// Srb->CommandData.IntersectInfo field of the SRB on an 
// SRB_GET_DATA_INTERSECTION operation.  
//

typedef struct _STREAM_DATA_INTERSECT_INFO {

    //
    // stream number to check
    //

    ULONG StreamNumber;

    //
    // pointer to the input data range to verify.
    //

    PKSDATARANGE DataRange;

    //
    // pointer to buffer which receives the format block if successful
    //

    PVOID   DataFormatBuffer;

    //
    // size of the above buffer.  set to sizeof(ULONG) if the caller just
    // wants to know what size is needed.
    //

    ULONG  SizeOfDataFormatBuffer;

}               STREAM_DATA_INTERSECT_INFO, *PSTREAM_DATA_INTERSECT_INFO;

//
// stream property descriptor structure.  this descriptor is referenced in
// Srb->CommandData.PropertyInfo field of the SRB on an SRB_GET or
// SRB_SET_PROPERTY operation.
//

typedef struct _STREAM_PROPERTY_DESCRIPTOR {

    //
    // pointer to the property GUID and ID
    //

    PKSPROPERTY     Property;

    //
    // zero-based ID of the property, which is an index into the array of
    // property sets filled in by the minidriver.
    //

    ULONG           PropertySetID;

    //
    // pointer to the information about the property (or the space to return
    // the information) passed in by the client
    //

    PVOID           PropertyInfo;

    //
    // size of the client's input buffer
    //

    ULONG           PropertyInputSize;

    //
    // size of the client's output buffer
    //

    ULONG           PropertyOutputSize;
}               STREAM_PROPERTY_DESCRIPTOR, *PSTREAM_PROPERTY_DESCRIPTOR;


#if (NTDDI_VERSION >= NTDDI_WINXP)

typedef struct _STREAM_METHOD_DESCRIPTOR {
    ULONG 		MethodSetID;
    PKSMETHOD		Method;
    PVOID		MethodInfo;
    LONG		MethodInputSize;
    LONG		MethodOutputSize;
} STREAM_METHOD_DESCRIPTOR, *PSTREAM_METHOD_DESCRIPTOR;

#endif

//
// STREAM I/O Request Block (SRB) structures and functions
//

#define STREAM_REQUEST_BLOCK_SIZE sizeof(STREAM_REQUEST_BLOCK)

//
// SRB command codes
//

typedef enum _SRB_COMMAND {

    //
    // stream specific codes follow
    //

    SRB_READ_DATA,              // read data from hardware
    SRB_WRITE_DATA,             // write data to the hardware
    SRB_GET_STREAM_STATE,       // get the state of the stream
    SRB_SET_STREAM_STATE,       // set the state of the stream
    SRB_SET_STREAM_PROPERTY,    // set a property of the stream
    SRB_GET_STREAM_PROPERTY,    // get a property value for the stream
    SRB_OPEN_MASTER_CLOCK,      // indicates that the master clock is on this
    // stream
    SRB_INDICATE_MASTER_CLOCK,  // supplies the handle to the master clock
    SRB_UNKNOWN_STREAM_COMMAND, // IRP function is unknown to class driver
    SRB_SET_STREAM_RATE,        // set the rate at which the stream should run
    SRB_PROPOSE_DATA_FORMAT,    // propose a new format, DOES NOT CHANGE IT!
    SRB_CLOSE_MASTER_CLOCK,     // indicates that the master clock is closed
    SRB_PROPOSE_STREAM_RATE,    // propose a new rate, DOES NOT CHANGE IT!
    SRB_SET_DATA_FORMAT,        // sets a new data format
    SRB_GET_DATA_FORMAT,        // returns the current data format
    SRB_BEGIN_FLUSH,            // beginning flush state
    SRB_END_FLUSH,              // ending flush state

    //
    // device/instance specific codes follow
    //

    SRB_GET_STREAM_INFO = 0x100,// get the stream information structure
    SRB_OPEN_STREAM,            // open the specified stream
    SRB_CLOSE_STREAM,           // close the specified stream
    SRB_OPEN_DEVICE_INSTANCE,   // open an instance of the device
    SRB_CLOSE_DEVICE_INSTANCE,  // close an instance of the device
    SRB_GET_DEVICE_PROPERTY,    // get a property of the device
    SRB_SET_DEVICE_PROPERTY,    // set a property for the device
    SRB_INITIALIZE_DEVICE,      // initialize the device
    SRB_CHANGE_POWER_STATE,     // change power state 
    SRB_UNINITIALIZE_DEVICE,    // uninitialize the device
    SRB_UNKNOWN_DEVICE_COMMAND, // IRP function is unknown to class driver
    SRB_PAGING_OUT_DRIVER,      // indicates that the driver is to be paged out
                                // only sent if enabled in registry.  board ints
                                // should be disabled & STATUS_SUCCESS returned.
    SRB_GET_DATA_INTERSECTION,  // returns stream data intersection
    SRB_INITIALIZATION_COMPLETE,// indicates init sequence has completed
    SRB_SURPRISE_REMOVAL        // indicates surprise removal of HW has occurred

#if (NTDDI_VERSION >= NTDDI_WINXP)

    , SRB_DEVICE_METHOD
    , SRB_STREAM_METHOD

#if ( (NTDDI_VERSION >= NTDDI_WINXPSP2) && (NTDDI_VERSION < NTDDI_WS03) ) || (NTDDI_VERSION >= NTDDI_WS03SP1)

    , SRB_NOTIFY_IDLE_STATE       // called on first open and last close

#endif

#endif

}               SRB_COMMAND;

//
// definition for scatter/gather
//

typedef struct {
    PHYSICAL_ADDRESS    PhysicalAddress;
    ULONG               Length;
} KSSCATTER_GATHER, *PKSSCATTER_GATHER;


typedef struct _HW_STREAM_REQUEST_BLOCK {
    ULONG           SizeOfThisPacket;   // sizeof STREAM_REQUEST_BLOCK
    // (version check)
    SRB_COMMAND     Command;    // SRB command, see SRB_COMMAND enumeration
    NTSTATUS        Status;     // SRB completion status
    PHW_STREAM_OBJECT StreamObject;
    // minidriver's stream object for this request
    PVOID           HwDeviceExtension;  // minidriver's device ext.
    PVOID           SRBExtension;   // per-request workspace for the
    // minidriver

    //
    // the following union passes in the information needed for the various
    // SRB
    // functions.
    //

    union _CommandData {

        //
        // pointer to the data descriptor for SRB_READ or SRB_WRITE_DATA
        //

        PKSSTREAM_HEADER DataBufferArray;

        //
        // pointer to the stream descriptor for SRB_GET_STREAM_INFO
        //

        PHW_STREAM_DESCRIPTOR StreamBuffer;

        //
        // pointer to the state for SRB_GET or SRB_SET_DEVICE_STATE
        //

        KSSTATE         StreamState;

        //
        // pointer to the time structure for SRB_GET and
        // SRB_SET_ONBOARD_CLOCK
        //

        PSTREAM_TIME_REFERENCE TimeReference;

        //
        // pointer to the property descriptor for SRB_GET and
        // SRB_SET_PROPERTY
        //

        PSTREAM_PROPERTY_DESCRIPTOR PropertyInfo;

        //
        // pointer to the requested format for SRB_OPEN_STREAM and 
        // SRB_PROPOSE_DATA_FORMAT
        //

        PKSDATAFORMAT   OpenFormat;

        //
        // pointer to the PORT_CONFIGURATION_INFORMATION struct for
        // SRB_INITIALIZE_DEVICE
        //

        struct _PORT_CONFIGURATION_INFORMATION *ConfigInfo;

        //
        // handle to the master clock.
        //

        HANDLE          MasterClockHandle;

        //
        // power state
        //

        DEVICE_POWER_STATE DeviceState;

        //
        // data intersection info
        //

        PSTREAM_DATA_INTERSECT_INFO IntersectInfo;

#if (NTDDI_VERSION >= NTDDI_WINXP)

        PVOID	MethodInfo;

        //
        // Filter type index for OPEN_DEVICE_INSTANCE
        //
        LONG	FilterTypeIndex;

#if ( (NTDDI_VERSION >= NTDDI_WINXPSP2) && (NTDDI_VERSION < NTDDI_WS03) ) || (NTDDI_VERSION >= NTDDI_WS03SP1)

        //
        // Indicates whether an SRB_NOTIFY_IDLE_STATE is calling to inform
        // that the device is idle -- no more handles to the device are 
        // open (TRUE) -- or to inform that the device is no longer idle --
        // a handle to the device has been opened (FALSE).
        //
        BOOLEAN Idle;

#endif

#endif

    }               CommandData;// union for command data

    //
    // field for indicating the number of KSSTREM_HEADER elements pointed to
    // by the DataBufferArray field above.
    //

    ULONG NumberOfBuffers;

    //
    // the following fields are used to time the request.   The class driver
    // will set both of these fields to a nonzero value when the request
    // is received by the minidriver, and then begin counting down the
    // TimeoutCounter field until it reaches zero.   When it reaches zero,
    // the minidriver's timeout handler will be called.   If the minidriver
    // queues a request for a long time, it should set the TimeoutCounter to
    // zero to turn off the timer, and once the request is dequeued should
    // set the TimeoutCounter field to the value in TimeoutOriginal.
    //

    ULONG           TimeoutCounter; // timer countdown value in seconds
    ULONG           TimeoutOriginal;    // original timeout value in seconds
    struct _HW_STREAM_REQUEST_BLOCK *NextSRB;
    // link field available to minidriver for queuing
    PIRP            Irp;        // pointer to original IRP, usually not
    // needed.
    ULONG           Flags;      // flags defined below.

    //
    // To indicate the filter instance extension
    //
    PVOID       HwInstanceExtension;

    // pointer to the instance extension
    //
    // the following union is used to indicate to the minidriver the amount
    // of data to transfer, and used by the minidriver to report the amount
    // of data it was actually able to transfer.
    //

    union {
        ULONG           NumberOfBytesToTransfer;
        ULONG           ActualBytesTransferred;
    };

    PKSSCATTER_GATHER ScatterGatherBuffer; // buffer pointing to array
                                           // of s/g elements
    ULONG           NumberOfPhysicalPages; // # of physical pages in request

    ULONG           NumberOfScatterGatherElements;
                                         // # of physical elements pointed  
                                         // to by ScatterGatherBuffer  

    ULONG Reserved[1];    // Reserved for future use

}               HW_STREAM_REQUEST_BLOCK, *PHW_STREAM_REQUEST_BLOCK;

//
// flags definitions for CRB
//

//
// this flag indicates that the request is either an SRB_READ_DATA or
// SRB_WRITE_DATA request, as opposed to a non-data request.
//

#define SRB_HW_FLAGS_DATA_TRANSFER  0x00000001

//
// this flag indicates that the request is for a stream, as opposed to being
// for the device.
//

#define SRB_HW_FLAGS_STREAM_REQUEST 0x00000002

//
// Structure defining the buffer types for StreamClassGetPhysicalAddress.
//

typedef enum {
    PerRequestExtension,        // indicates the phys address of the SRB
    // extension
    DmaBuffer,                  // indicates the phys address of the DMA
    // buffer
    SRBDataBuffer               // indicates the phys address of a data
    // buffer
}               STREAM_BUFFER_TYPE;

//
// Structure for I/O and Memory address ranges
//

typedef struct _ACCESS_RANGE {
    STREAM_PHYSICAL_ADDRESS RangeStart; // start of the range
    ULONG           RangeLength;// length of the range
    BOOLEAN         RangeInMemory;  // FALSE if a port address
    ULONG           Reserved;   //
}               ACCESS_RANGE, *PACCESS_RANGE;


//
// Configuration information structure.  Contains the information necessary
// to initialize the adapter.
//

typedef struct _PORT_CONFIGURATION_INFORMATION {
    ULONG           SizeOfThisPacket;   // Size of this structure, used as
    // version check
    PVOID           HwDeviceExtension;  // minidriver's device extension

    //
    // the below field supplies a pointer to the device's functional
    // device object, which is created by stream class.  
    // Most minidrivers will not need to use this.  
    //

    PDEVICE_OBJECT  ClassDeviceObject;  // class driver's FDO

    //
    // the below field supplies a pointer to the device's "attached" physical
    // device object, which is returned from IoAttachDeviceToDeviceStack.  
    // Most minidrivers will not need to use this.  
    // This PDO must be used for calls to IoCallDriver.  See the note below 
    // for the RealPhysicalDeviceObject, and also see WDM documentation.
    //

    PDEVICE_OBJECT  PhysicalDeviceObject;   // attached physical device object

    ULONG           SystemIoBusNumber;  // IO bus number (0 for machines that
    // have
    // only 1 IO bus)

    INTERFACE_TYPE  AdapterInterfaceType;   // Adapter interface type
    // supported by HBA:
    // Internal
    // Isa
    // Eisa
    // MicroChannel
    // TurboChannel
    // PCIBus
    // VMEBus
    // NuBus
    // PCMCIABus
    // CBus
    // MPIBus
    // MPSABus

    ULONG           BusInterruptLevel;  // interrupt level
    ULONG           BusInterruptVector; // interrupt vector
    KINTERRUPT_MODE InterruptMode;  // interrupt mode (latched, level)

    ULONG           DmaChannel; // DMA channel

    //
    // Specifies the number of AccessRanges elements in the array,
    // described next. The OS-specific class driver always sets this
    // member to the value passed in the HW_INITIALIZATION_DATA
    // structure when the minidriver driver called CodecXXXInitialize.
    //

    ULONG           NumberOfAccessRanges;   // Number of access ranges
    // allocated

    //
    // Points to the first element of an array of ACCESS_RANGE-type elements.
    // The given NumberOfAccessRanges determines how many elements must be
    // configured with bus-relative range values. The AccessRanges
    // pointer must be NULL if NumberOfAccessRanges is zero.
    //

    PACCESS_RANGE   AccessRanges;   // Pointer to array of access range
    // elements

    //
    // the following field is filled in by the minidriver to indicate the
    // size of the buffer needed to build the HW_STREAM_DESCRIPTOR structure
    // and all of its substructures.
    //

    ULONG           StreamDescriptorSize;   // size of the stream descriptor

    PIRP            Irp;        // IRP for PNP start function, normally
    // not used by the minidriver.
    
    //
    // the following field indicates the interrupt object for the adapter
    // if nonzero.   This field is normally not used by the minidriver.
    //

    PKINTERRUPT  InterruptObject;

    //
    // the following field indicates the DMA adapter object for the adapter
    // if nonzero.   This field is normally not used by the minidriver.
    //

    PADAPTER_OBJECT  DmaAdapterObject;

    //
    // the below field supplies a pointer to the device's "real" physical
    // device object, which is supplied on the AddDevice call.  Most 
    // minidrivers will not need to use this.  
    // This PDO must be used for registry access, etc.  See the note above 
    // for the PhysicalDeviceObject, and also see WDM documentation.
    //

    PDEVICE_OBJECT  RealPhysicalDeviceObject;   // real physical device object

    ULONG Reserved[1];    // Reserved for future use

}               PORT_CONFIGURATION_INFORMATION, *PPORT_CONFIGURATION_INFORMATION;

//
// Function prototypes for minidriver routines called by the class driver
//


typedef         VOID
                (STREAMAPI * PHW_RECEIVE_DEVICE_SRB) (  // HwReceivePacket
 // routine
                                             IN PHW_STREAM_REQUEST_BLOCK SRB
);

typedef         VOID
                (STREAMAPI * PHW_CANCEL_SRB) (  // HwCancelPacket routine
                                             IN PHW_STREAM_REQUEST_BLOCK SRB
);

typedef         VOID
                (STREAMAPI * PHW_REQUEST_TIMEOUT_HANDLER) ( // HwRequestTimeoutHandle
                                                            //
 // r routine
                                             IN PHW_STREAM_REQUEST_BLOCK SRB
);

typedef         BOOLEAN
                (STREAMAPI * PHW_INTERRUPT) (   // HwInterrupt routine
                                                    IN PVOID DeviceExtension
);

typedef         VOID
                (STREAMAPI * PHW_TIMER_ROUTINE) (   // timer callback routine
                                             IN PVOID Context
);

typedef         VOID
                (STREAMAPI * PHW_PRIORITY_ROUTINE) (    // change priority
 // callback routine
                                             IN PVOID Context
);

typedef         VOID
                (STREAMAPI * PHW_QUERY_CLOCK_ROUTINE) ( // query clock
 // callback routine
                                             IN PHW_TIME_CONTEXT TimeContext
);


typedef         BOOLEAN
                (STREAMAPI * PHW_RESET_ADAPTER) (   // HwResetAdapter routine
                                                    IN PVOID DeviceExtension
);


//
// Minidriver stream notification types passed in to StreamClassStreamNotification
// follow.
//

typedef enum _STREAM_MINIDRIVER_STREAM_NOTIFICATION_TYPE {

    //
    // indicates that the minidriver is ready for the next stream data
    // request
    //

    ReadyForNextStreamDataRequest,

    //
    // indicates that the minidriver is ready for the next stream control
    // request
    //

    ReadyForNextStreamControlRequest,

    //
    // indicates that the hardware is starved for data
    //

    HardwareStarved,

    //
    // indicates that the specified STREAM SRB has completed
    //

    StreamRequestComplete,
    SignalMultipleStreamEvents,
    SignalStreamEvent,
    DeleteStreamEvent,
    StreamNotificationMaximum
}               STREAM_MINIDRIVER_STREAM_NOTIFICATION_TYPE, *PSTREAM_MINIDRIVER_STREAM_NOTIFICATION_TYPE;

//
// Minidriver device notification types passed in to StreamClassDeviceNotification
// follow.
//

// notes for SignalMultipleDeviceEvents and SignalMultipleDeviceInstanceEvents:
//
// SignalMultipleDeviceEvents: should only be used by single instance legacy drivers
// SignalMultipleDeviceInstanceEvents: this should be used by multiple instance drivers
// These types are used by StreamClassDeviceNotification().
//
// When SignalMultipleDeviceEvents is used the function should be called
// as StreamClassDeviceNotification( SignalMultipleDeviceEvents,
//                                   pHwDeviceExtension, 
//                                   pEventGUID,
//                                   EventItem);
//
// When SignalMultipleDeviceInstanceEvents is used the function should be passed in
// as StreamClassDeviceNotification( SignalMultipleDeviceInstanceEvents,
//                                   pHwDeviceExtension, 
//                                   pHwInstanceExtesnion, 
//                                   pEventGUID,
//                                   EventItem);
//
typedef enum _STREAM_MINIDRIVER_DEVICE_NOTIFICATION_TYPE {

    //
    // indicates that the minidriver is ready for the next device request
    //

    ReadyForNextDeviceRequest,

    //
    // indicates that the specified DEVICE SRB has completed
    //

    DeviceRequestComplete,
    SignalMultipleDeviceEvents,
    SignalDeviceEvent,
    DeleteDeviceEvent,
#if (NTDDI_VERSION >= NTDDI_WINXP)
    SignalMultipleDeviceInstanceEvents,
#endif
    DeviceNotificationMaximum
} STREAM_MINIDRIVER_DEVICE_NOTIFICATION_TYPE, *PSTREAM_MINIDRIVER_DEVICE_NOTIFICATION_TYPE;

//
// Structure passed between minidriver initialization
// and STREAM class initialization
//

typedef struct _HW_INITIALIZATION_DATA {
#if (NTDDI_VERSION >= NTDDI_WINXP)
    union {
    
        //
        // This first 4 bytes was used as a field for the size of this structure.
        // We split this field into 2 ushorts to contain the size of this packet
        // and a version number which stream class driver uses to recognize that
        // the last two fields, NumNameExtensions and NameExtensionArray are valid
        // information instead of uninitialized ramdom values. We hereby designate
        // the StreamClassVersion to be 0x0200.
        //
        #define STREAM_CLASS_VERSION_20 0x0200
        ULONG           HwInitializationDataSize;   // Size of this structure,
        struct {
            USHORT      SizeOfThisPacket;           // Size of this packet.
            USHORT      StreamClassVersion;         // Must be 0x0200
        };
    };
#else
    ULONG           HwInitializationDataSize;   // Size of this structure,
    // used as version check.   
#endif

    //
    // minidriver routines follow
    //

    PHW_INTERRUPT   HwInterrupt;// minidriver's interrupt routine
    PHW_RECEIVE_DEVICE_SRB HwReceivePacket;
    // minidriver's request routine
    PHW_CANCEL_SRB  HwCancelPacket;
    // minidriver's cancel routine

    PHW_REQUEST_TIMEOUT_HANDLER HwRequestTimeoutHandler;
    // minidriver's timeout handler routine

    //
    // minidriver resources follow
    //

    ULONG           DeviceExtensionSize;    // size in bytes of the
    // minidrivers
    // per-adapter device extension data
    ULONG           PerRequestExtensionSize;    // size of per-request
    // workspace
    ULONG           PerStreamExtensionSize; // size of per-stream workspace
    ULONG           FilterInstanceExtensionSize;    // size of the filter
    // instance extension

    BOOLEAN         BusMasterDMA;   // Adapter uses bus master DMA for
    // one or more streams
    BOOLEAN         Dma24BitAddresses;  // TRUE indicates 24 bit DMA only
                                        // (ISA)
    ULONG           BufferAlignment;    // buffer alignment mask

    //
    // the following BOOLEAN should be set to FALSE unless the minidriver
    // can deal with multiprocessor reentrancy issues!
    //

    BOOLEAN         TurnOffSynchronization;

    //
    // size of DMA buffer needed by minidriver.   The minidriver may obtain
    // its DMA buffer by calling StreamClassGetDmaBuffer while or after
    // SRB_INITIALIZE_DEVICE is received.
    //

    ULONG           DmaBufferSize;

#if (NTDDI_VERSION >= NTDDI_WINXP)
    //
    // A version 20 mini driver must specify the following two fields.
    // It specifies a name for each type. The names will be used to create
    // symbolic links for clients to open them.
    // The names can be any wide char strings that the driver chooses. At 
    // OPEN_DEVICE_INSTANCE, a filter type index and the filter instance extension
    // are specified. Consequent Srbs will contain the filter extension for the
    // target filter instance. NameExtensionArray is a pointer to a constant array
    // of pointers which point to constant wide char strings.
    //
    ULONG			NumNameExtensions;
    PWCHAR			*NameExtensionArray;
#else
    ULONG Reserved[2];    // Reserved for future use
#endif

} HW_INITIALIZATION_DATA, *PHW_INITIALIZATION_DATA;

//
// Execution Priorities passed in to the StreamClassChangePriority function
//

typedef enum _STREAM_PRIORITY {
    High,                       // highest priority, IRQL equal to the
    // adapter's ISR
    Dispatch,                   // medium priority, IRQL equal to DISPATCH
    // level
    Low,                        // lowest priority, IRQL equal to PASSIVE or
    // APC level
    LowToHigh                   // go from low priority to high priority
}               STREAM_PRIORITY, *PSTREAM_PRIORITY;


//
// the following are prototypes for services provided by the class driver
//

VOID            STREAMAPI
                StreamClassScheduleTimer(
                                 IN OPTIONAL PHW_STREAM_OBJECT StreamObject,
                                                 IN PVOID HwDeviceExtension,
                                              IN ULONG NumberOfMicroseconds,
                                          IN PHW_TIMER_ROUTINE TimerRoutine,
                                                         IN PVOID Context
);

VOID            STREAMAPI
                StreamClassCallAtNewPriority(
                                 IN OPTIONAL PHW_STREAM_OBJECT StreamObject,
                                                 IN PVOID HwDeviceExtension,
                                                IN STREAM_PRIORITY Priority,
                                    IN PHW_PRIORITY_ROUTINE PriorityRoutine,
                                                             IN PVOID Context
);

VOID            __cdecl
                StreamClassStreamNotification(
                                                              IN STREAM_MINIDRIVER_STREAM_NOTIFICATION_TYPE NotificationType,
                                          IN PHW_STREAM_OBJECT StreamObject,
                                              ...
);

VOID            __cdecl
                StreamClassDeviceNotification(
                                                              IN STREAM_MINIDRIVER_DEVICE_NOTIFICATION_TYPE NotificationType,
                                                 IN PVOID HwDeviceExtension,
                                              ...
);

STREAM_PHYSICAL_ADDRESS STREAMAPI
                StreamClassGetPhysicalAddress(
                                                 IN PVOID HwDeviceExtension,
                                 IN PHW_STREAM_REQUEST_BLOCK HwSRB OPTIONAL,
                                                    IN PVOID VirtualAddress,
                                                 IN STREAM_BUFFER_TYPE Type,
                                                          OUT ULONG * Length
);


PVOID           STREAMAPI
                StreamClassGetDmaBuffer(
                                                  IN PVOID HwDeviceExtension
);


VOID            __cdecl
                StreamClassDebugPrint(
                                          STREAM_DEBUG_LEVEL DebugPrintLevel,
                                                         PCCHAR DebugMessage,
                                      ...
);

VOID            STREAMAPI
                StreamClassDebugAssert(
                                                       __in IN PCHAR File,
                                                       __in IN ULONG Line,
                                                       __in IN PCHAR AssertText,
                                                       __in IN ULONG AssertValue
);

NTSTATUS        STREAMAPI
                StreamClassRegisterAdapter(
                                                         IN PVOID Argument1,
                                                         IN PVOID Argument2,
                             IN PHW_INITIALIZATION_DATA HwInitializationData
);

#define StreamClassRegisterMinidriver StreamClassRegisterAdapter

VOID
StreamClassAbortOutstandingRequests(
                                    IN PVOID HwDeviceExtension,
                                    IN PHW_STREAM_OBJECT HwStreamObject,
                                    IN NTSTATUS Status
);

VOID
StreamClassQueryMasterClock(
                            IN PHW_STREAM_OBJECT HwStreamObject,
                            IN HANDLE MasterClockHandle,
                            IN TIME_FUNCTION TimeFunction,
                            IN PHW_QUERY_CLOCK_ROUTINE ClockCallbackRoutine
);

//
// The 1st parameter was PVOID HwDeviceExtension. It MUST be HwInstanceExtension
// for multi-instance and multi-filter types ( version 20 ) drivers. Legacy
// single instance drivers can continue to specify HwDeviceExtensionin as the
// 1st parameter. It can also specify HwInstanceExtension.
//
PKSEVENT_ENTRY
StreamClassGetNextEvent(
                        IN PVOID HwInstanceExtension_OR_HwDeviceExtension,
                        IN OPTIONAL PHW_STREAM_OBJECT HwStreamObject,
                        IN OPTIONAL GUID * EventGuid,
                        IN OPTIONAL ULONG EventItem,
                        IN OPTIONAL PKSEVENT_ENTRY CurrentEvent
);

NTSTATUS  
StreamClassRegisterFilterWithNoKSPins( 
    IN PDEVICE_OBJECT   DeviceObject,
    IN const GUID     * InterfaceClassGUID,
    IN ULONG            PinCount,
    IN BOOL           * PinDirection,
    IN KSPIN_MEDIUM   * MediumList,
    IN OPTIONAL GUID  * CategoryList
);

BOOLEAN STREAMAPI
StreamClassReadWriteConfig( 
    __in PVOID HwDeviceExtension,
    __in BOOLEAN Read,
    __inout_bcount(Length) PVOID Buffer,
    __in ULONG Offset,
    __in ULONG Length
);


VOID STREAMAPI
StreamClassQueryMasterClockSync(
                                IN HANDLE MasterClockHandle,
                                IN OUT PHW_TIME_CONTEXT TimeContext
);

VOID STREAMAPI
StreamClassCompleteRequestAndMarkQueueReady(
                                    IN PHW_STREAM_REQUEST_BLOCK Srb
);

#if (NTDDI_VERSION >= NTDDI_VISTA)
DECLSPEC_DEPRECATED_DDK
#endif
VOID STREAMAPI
StreamClassReenumerateStreams(
                              IN PVOID HwDeviceExtension,
                              IN ULONG StreamDescriptorSize
);

#if (NTDDI_VERSION >= NTDDI_WINXP)

//
// A version 2.0 stream class mini driver must use this function
// in stead of StreamClassReenumerateStreams()
//

#if (NTDDI_VERSION >= NTDDI_VISTA)
DECLSPEC_DEPRECATED_DDK
#endif
VOID STREAMAPI
StreamClassFilterReenumerateStreams(
    IN PVOID HwInstanceExtension,
    IN ULONG StreamDescriptorSize
);

#endif

#endif //_STREAM_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\storduid.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    storduid.h

Abstract:

    This is the include file that defines all common constants and types
    for accessing storage device unique identification.

Revision History:

--*/

#ifndef __STORDUID_H__
#define __STORDUID_H__


//
// Storage device unique identification.
//

typedef enum _DUID_MATCH_STATUS {
    DuidExactMatch = 0,
    DuidSubIdMatch,
    DuidNoMatch,
    DuidErrorGeneral = 100,
    DuidErrorMissingDuid,
    DuidErrorVersionMismatch,
    DuidErrorInvalidDuid,
    DuidErrorInvalidDeviceIdDescSize,
    DuidErrorInvalidDeviceDescSize,
    DuidErrorInvalidLayoutSigSize,
    DuidErrorInvalidLayoutSigVersion,
    DuidErrorMaximum
} DUID_MATCH_STATUS;


//
// Use a version number to help identify the DUID.
// Future versions may not be compatible, and the compare
// routine may need to know the version to accurately
// compare DUIDS.
//

#define DUID_VERSION_1              1

#define DUID_HARDWARE_IDS_ONLY      0
#define DUID_INCLUDE_SOFTWARE_IDS   1

#define DUID_MATCH_ERROR( _duid_status )        ( ( _duid_status ) >= DuidErrorGeneral ? TRUE : FALSE )
#define DUID_MATCH_SUCCESS( _duid_status )      ( ( _duid_status ) <  DuidErrorGeneral ? TRUE : FALSE )

typedef struct _STORAGE_DEVICE_UNIQUE_IDENTIFIER {

    //
    // DUID version.
    //

    ULONG Version;

    //
    // Total size of the identifier header including the space
    // for all ids.
    //

    ULONG Size;

    //
    // Byte offset to the STORAGE_DEVICE_ID_DESCRIPTOR.
    //

    ULONG StorageDeviceIdOffset;

    //
    // Byte offset to the STORAGE_DEVICE_DESCRIPTOR.
    //

    ULONG StorageDeviceOffset;

    //
    // Byte offset to the STORAGE_DEVICE_LAYOUT_SIGNATURE.
    //
    // Only included if the first byte of the input STORAGE_PROPERTY_QUERY
    // AdditionalParameters is equal to DUID_INCLUDE_SOFTWARE_IDS.
    //

    ULONG DriveLayoutSignatureOffset;

} STORAGE_DEVICE_UNIQUE_IDENTIFIER, *PSTORAGE_DEVICE_UNIQUE_IDENTIFIER;


typedef struct _STORAGE_DEVICE_LAYOUT_SIGNATURE {

    //
    // DUID version.
    //

    ULONG Version;

    //
    // Total size of this structure.
    //

    ULONG Size;

    //
    // Flag indicating whether signature is MBR or GPT format.
    //

    BOOLEAN Mbr;

    union {
        ULONG MbrSignature;
        GUID GptDiskId;
    } DeviceSpecific;

} STORAGE_DEVICE_LAYOUT_SIGNATURE, *PSTORAGE_DEVICE_LAYOUT_SIGNATURE;

__inline
DUID_MATCH_STATUS
CompareStorageDuids(
    PSTORAGE_DEVICE_UNIQUE_IDENTIFIER Duid1,
    PSTORAGE_DEVICE_UNIQUE_IDENTIFIER Duid2
    );

__inline
DUID_MATCH_STATUS
CompareStorageDuids(
    PSTORAGE_DEVICE_UNIQUE_IDENTIFIER Duid1,
    PSTORAGE_DEVICE_UNIQUE_IDENTIFIER Duid2
    )
{
    //
    // Initial parameter checking.
    //

    if ( !Duid1 || !Duid2 ) {

        return DuidErrorMissingDuid;
    }

    if ( Duid1->Size < sizeof(STORAGE_DEVICE_UNIQUE_IDENTIFIER) ||
         Duid2->Size < sizeof(STORAGE_DEVICE_UNIQUE_IDENTIFIER) ) {

        return DuidErrorGeneral;
    }

    if ( Duid1->Version != DUID_VERSION_1 ||
         Duid2->Version != DUID_VERSION_1 ) {

        return DuidErrorVersionMismatch;
    }

    //
    // Something besides the header must exist.
    //

    if ( Duid1->StorageDeviceIdOffset == 0 &&
         Duid1->StorageDeviceOffset == 0 &&
         Duid1->DriveLayoutSignatureOffset == 0 ) {

        return DuidErrorInvalidDuid;
    }

    if ( Duid2->StorageDeviceIdOffset == 0 &&
         Duid2->StorageDeviceOffset == 0 &&
         Duid2->DriveLayoutSignatureOffset == 0 ) {

        return DuidErrorInvalidDuid;
    }

    //
    // If both DUIDs are the same size and match exactly, we are done.
    //

    if ( Duid1->Size == Duid2->Size ) {

        if ( memcmp( Duid1, Duid2, Duid1->Size ) == 0 ) {

            return DuidExactMatch;
        }
    }

    //
    // Check STORAGE_DEVICE_ID_DESCRIPTOR
    //

    if ( Duid1->StorageDeviceIdOffset && Duid2->StorageDeviceIdOffset ) {

        PSTORAGE_DEVICE_ID_DESCRIPTOR idDesc1;
        PSTORAGE_DEVICE_ID_DESCRIPTOR idDesc2;

        PSTORAGE_IDENTIFIER ident1;
        PSTORAGE_IDENTIFIER ident2;

        ULONG idx1;
        ULONG idx2;

        idDesc1 = (PSTORAGE_DEVICE_ID_DESCRIPTOR)((PUCHAR)Duid1 + Duid1->StorageDeviceIdOffset);
        idDesc2 = (PSTORAGE_DEVICE_ID_DESCRIPTOR)((PUCHAR)Duid2 + Duid2->StorageDeviceIdOffset);

        //
        // Insure reasonable size.
        //

        if ( idDesc1->Size < sizeof(STORAGE_DEVICE_ID_DESCRIPTOR) ||
             idDesc2->Size < sizeof(STORAGE_DEVICE_ID_DESCRIPTOR) ) {

            return DuidErrorInvalidDeviceIdDescSize;
        }

        //
        // If substructures are the same, check for a match.
        //

        if ( idDesc1->Size == idDesc2->Size ) {

            if ( memcmp( idDesc1, idDesc2, idDesc1->Size ) == 0 ) {

                return DuidSubIdMatch;
            }
        }

        //
        // Walk through the identifiers and find unique values that match.
        // For each unique ID in Duid1, check if it exists in Duid2.  If so,
        // these are likely the same device.
        //
        // This search is not optimized.
        //

        //
        // Loop through identifiers in Duid1.
        //

        ident1 = (PSTORAGE_IDENTIFIER)(idDesc1->Identifiers);

        for ( idx1 = 0; idx1 < idDesc1->NumberOfIdentifiers; idx1++ ) {

            //
            // Find identifier in Duid1 that is unique.
            //

            if ( ( ident1->Type == StorageIdTypeScsiNameString  ||
                   ident1->Type == StorageIdTypeFCPHName        ||
                   ident1->Type == StorageIdTypeEUI64           ||
                   ident1->Type == StorageIdTypeVendorId            ) &&
                 ( ident1->Association == StorageIdAssocPort        ) &&
                 ( ident1->CodeSet == StorageIdCodeSetUtf8      ||
                   ident1->CodeSet == StorageIdCodeSetAscii     ||
                   ident1->CodeSet == StorageIdCodeSetBinary        ) ) {

                //
                // Found a unique ID in Duid1.  Look for the same identifier in
                // Duid2.
                //

                ident2 = (PSTORAGE_IDENTIFIER)(idDesc2->Identifiers);

                for ( idx2 = 0; idx2 < idDesc2->NumberOfIdentifiers; idx2++ ) {

                    if ( ident1->Type           == ident2->Type &&
                         ident1->Association    == ident2->Association &&
                         ident1->CodeSet        == ident2->CodeSet &&
                         ident1->IdentifierSize == ident2->IdentifierSize &&
                         ( memcmp( ident1->Identifier,
                                   ident2->Identifier,
                                   ident1->IdentifierSize ) == 0 ) ) {

                        return DuidSubIdMatch;
                    }

                    ident2 = (PSTORAGE_IDENTIFIER)((PUCHAR)ident2 + ident2->NextOffset);
                }
            }

            ident1 = (PSTORAGE_IDENTIFIER)((PUCHAR)ident1 + ident1->NextOffset);
        }

    }

    //
    // Check STORAGE_DEVICE_DESCRIPTOR
    //

    if ( Duid1->StorageDeviceOffset && Duid2->StorageDeviceOffset ) {

        PSTORAGE_DEVICE_DESCRIPTOR desc1;
        PSTORAGE_DEVICE_DESCRIPTOR desc2;

        desc1 = (PSTORAGE_DEVICE_DESCRIPTOR)((PUCHAR)Duid1 + Duid1->StorageDeviceOffset);
        desc2 = (PSTORAGE_DEVICE_DESCRIPTOR)((PUCHAR)Duid2 + Duid2->StorageDeviceOffset);

        //
        // Insure reasonable size.
        //

        if ( desc1->Size < sizeof(STORAGE_DEVICE_DESCRIPTOR) ||
             desc2->Size < sizeof(STORAGE_DEVICE_DESCRIPTOR) ) {

            return DuidErrorInvalidDeviceDescSize;
        }

        //
        // If substructures are the same, check for a match.
        //

        if ( desc1->Size == desc2->Size ) {

            if ( memcmp( desc1, desc2, desc1->Size ) == 0 ) {

                return DuidSubIdMatch;
            }
        }

        //
        // Have to have SerialNumber.  If SerialNumbers match, then
        // VendorId and ProductId must match (if they exist).
        //

        if ( desc1->SerialNumberOffset &&
             desc2->SerialNumberOffset ) {

            const char * string1;
            const char * string2;

            //
            // All strings are supposed to be NULL terminated.
            //

            string1 = (const char *)((PUCHAR)desc1 + desc1->SerialNumberOffset);
            string2 = (const char *)((PUCHAR)desc2 + desc2->SerialNumberOffset);

            if ( strcmp( string1, string2 ) == 0 ) {

                if ( desc1->VendorIdOffset &&
                     desc2->VendorIdOffset ) {

                    string1 = (const char *)((PUCHAR)desc1 + desc1->VendorIdOffset);
                    string2 = (const char *)((PUCHAR)desc2 + desc2->VendorIdOffset);

                    if ( strcmp( string1, string2 ) != 0 ) {

                        return DuidNoMatch;
                    }
                }

                if ( desc1->ProductIdOffset &&
                     desc2->ProductIdOffset ) {

                    string1 = (const char *)((PUCHAR)desc1 + desc1->ProductIdOffset);
                    string2 = (const char *)((PUCHAR)desc2 + desc2->ProductIdOffset);

                    if ( strcmp( string1, string2 ) != 0 ) {

                        return DuidNoMatch;
                    }
                }

                return DuidSubIdMatch;
            }
        }
    }

    //
    // Check STORAGE_DEVICE_LAYOUT_SIGNATURE
    //

    if ( Duid1->DriveLayoutSignatureOffset && Duid2->DriveLayoutSignatureOffset ) {

        PSTORAGE_DEVICE_LAYOUT_SIGNATURE sig1;
        PSTORAGE_DEVICE_LAYOUT_SIGNATURE sig2;

        sig1 = (PSTORAGE_DEVICE_LAYOUT_SIGNATURE)((PUCHAR)Duid1 + Duid1->DriveLayoutSignatureOffset);
        sig2 = (PSTORAGE_DEVICE_LAYOUT_SIGNATURE)((PUCHAR)Duid2 + Duid2->DriveLayoutSignatureOffset);

        if ( sig1->Version != DUID_VERSION_1 &&
             sig2->Version != DUID_VERSION_1 ) {

            return DuidErrorInvalidLayoutSigVersion;
        }

        if ( sig1->Size < sizeof(STORAGE_DEVICE_LAYOUT_SIGNATURE) ||
             sig2->Size < sizeof(STORAGE_DEVICE_LAYOUT_SIGNATURE) ) {

            return DuidErrorInvalidLayoutSigSize;
        }

        if ( memcmp( sig1, sig2, sizeof(STORAGE_DEVICE_LAYOUT_SIGNATURE) ) == 0 ) {

            return DuidSubIdMatch;
        }
    }

    //
    // If we get here, we found no unique IDs that match.
    //

    return DuidNoMatch;
}


#endif // __STORDUID_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\struchdr.h ===
#if !defined(NTDDI_VERSION)

#error NTDDI_VERSION must be defined to include this file.

#elif (NTDDI_VERSION >= NTDDI_VISTA)

/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    StrucHdr.h

Abstract:

    This module predefines the structures for important data structures so that we can always talk about them....
    even though they're not defined yet.

Author:
Revision History:

--*/

#ifndef _RDBSSSTRUCHDR_
#define _RDBSSSTRUCHDR_

#define IMPORTANT_STRUCTURE(x) struct _##x; typedef struct _##x *P##x

typedef struct _NODE_TYPE_CODE_AND_SIZE *PNODE_TYPE_CODE_AND_SIZE;

typedef struct _RX_PREFIX_ENTRY *PRX_PREFIX_ENTRY;
typedef struct _RX_PREFIX_TABLE *PRX_PREFIX_TABLE;

typedef struct _RX_FSD_DISPATCH_VECTOR *PRX_FSD_DISPATCH_VECTOR;
typedef struct _RDBSS_DATA *PRDBSS_DATA;
typedef struct _RDBSS_EXPORTS *PRDBSS_EXPORTS;
typedef struct _VCB *PVCB;
typedef struct _RDBSS_DEVICE_OBJECT *PRDBSS_DEVICE_OBJECT;

typedef struct _FILE_NAME_NODE *PFILE_NAME_NODE;
typedef struct _REPINNED_BCBS *PREPINNED_BCBS;
typedef struct _RDBSS_IO_CONTEXT *PRDBSS_IO_CONTEXT;
typedef struct _IO_RUNS *PIO_RUNS;
typedef struct _DELETE_CONTEXT *PDELETE_CONTEXT;
typedef struct _CLOSE_CONTEXT *PCLOSE_CONTEXT;
typedef struct _CLEAN_AND_DIRTY_VOLUME_PACKET *PCLEAN_AND_DIRTY_VOLUME_PACKET;

typedef struct _SRV_CALL *PSRV_CALL;
typedef struct _NET_ROOT *PNET_ROOT;
typedef struct _V_NET_ROOT *PV_NET_ROOT;
typedef struct _NON_PAGED_FCB *PNON_PAGED_FCB;
typedef struct _FCB *PFCB;
typedef struct _SRV_OPEN *PSRV_OPEN;
typedef struct _FOBX *PFOBX;
typedef struct _RX_CONTEXT *PRX_CONTEXT;
typedef struct _LOWIO_CONTEXT *PLOWIO_CONTEXT;

typedef struct _EA_RANGE *PEA_RANGE;

typedef struct _MINIRDR_DISPATCH *PMINIRDR_DISPATCH;
typedef struct _RDBSS_EXPORTS *PRDBSS_EXPORTS;
typedef struct _MRX_SRVCALL_CALLBACK_CONTEXT *PMRX_SRVCALL_CALLBACK_CONTEXT;
typedef struct _MRX_SRVCALLDOWN_STRUCTURE *PMRX_SRVCALLDOWN_STRUCTURE;
typedef struct _MRX_CREATENETROOT_CONTEXT *PMRX_CREATENETROOT_CONTEXT;

#endif // _RDBSSSTRUCHDR_

#elif (NTDDI_VERSION >= NTDDI_WS03)

/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    StrucHdr.h

Abstract:

    This module predefines the structures for important data structures so that we can always talk about them....
    even though they're not defined yet.

Author:
Revision History:

--*/

#ifndef _RDBSSSTRUCHDR_
#define _RDBSSSTRUCHDR_

#define IMPORTANT_STRUCTURE(x) struct _##x; typedef struct _##x *P##x

typedef struct _NODE_TYPE_CODE_AND_SIZE *PNODE_TYPE_CODE_AND_SIZE;

typedef struct _RX_PREFIX_ENTRY *PRX_PREFIX_ENTRY;
typedef struct _RX_PREFIX_TABLE *PRX_PREFIX_TABLE;

typedef struct _RX_FSD_DISPATCH_VECTOR *PRX_FSD_DISPATCH_VECTOR;
typedef struct _RDBSS_DATA *PRDBSS_DATA;
typedef struct _RDBSS_EXPORTS *PRDBSS_EXPORTS;
typedef struct _VCB *PVCB;
typedef struct _RDBSS_DEVICE_OBJECT *PRDBSS_DEVICE_OBJECT;

typedef struct _FILE_NAME_NODE *PFILE_NAME_NODE;
typedef struct _REPINNED_BCBS *PREPINNED_BCBS;
typedef struct _RDBSS_IO_CONTEXT *PRDBSS_IO_CONTEXT;
typedef struct _IO_RUNS *PIO_RUNS;
typedef struct _DELETE_CONTEXT *PDELETE_CONTEXT;
typedef struct _CLOSE_CONTEXT *PCLOSE_CONTEXT;
typedef struct _CLEAN_AND_DIRTY_VOLUME_PACKET *PCLEAN_AND_DIRTY_VOLUME_PACKET;

typedef struct _SRV_CALL *PSRV_CALL;
typedef struct _NET_ROOT *PNET_ROOT;
typedef struct _V_NET_ROOT *PV_NET_ROOT;
typedef struct _NON_PAGED_FCB *PNON_PAGED_FCB;
typedef struct _FCB *PFCB;
typedef struct _SRV_OPEN *PSRV_OPEN;
typedef struct _FOBX *PFOBX;
typedef struct _RX_CONTEXT *PRX_CONTEXT;
typedef struct _LOWIO_CONTEXT *PLOWIO_CONTEXT;

typedef struct _EA_RANGE *PEA_RANGE;

typedef struct _MINIRDR_DISPATCH *PMINIRDR_DISPATCH;
typedef struct _RDBSS_EXPORTS *PRDBSS_EXPORTS;
typedef struct _MRX_SRVCALL_CALLBACK_CONTEXT *PMRX_SRVCALL_CALLBACK_CONTEXT;
typedef struct _MRX_SRVCALLDOWN_STRUCTURE *PMRX_SRVCALLDOWN_STRUCTURE;
typedef struct _MRX_CREATENETROOT_CONTEXT *PMRX_CREATENETROOT_CONTEXT;

#endif // _RDBSSSTRUCHDR_


#elif (NTDDI_VERSION >= NTDDI_WINXP)

/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    StrucHdr.h

Abstract:

    This module predefines the strucs for important data structures so that we can always talk about 'em....
    even tho they're not defined yet.

Author:
Revision History:

--*/

#ifndef _RDBSSSTRUCHDR_
#define _RDBSSSTRUCHDR_

#define IMPORTANT_STRUCTURE(x) struct _##x; typedef struct _##x *P##x

IMPORTANT_STRUCTURE(NODE_TYPE_CODE_AND_SIZE);

IMPORTANT_STRUCTURE(RX_PREFIX_ENTRY);
IMPORTANT_STRUCTURE(RX_PREFIX_TABLE);

IMPORTANT_STRUCTURE(RX_FSD_DISPATCH_VECTOR);
IMPORTANT_STRUCTURE(RDBSS_DATA);
IMPORTANT_STRUCTURE(RDBSS_EXPORTS);
IMPORTANT_STRUCTURE(VCB);
IMPORTANT_STRUCTURE(RDBSS_DEVICE_OBJECT);
IMPORTANT_STRUCTURE(DSCB);

IMPORTANT_STRUCTURE(FILE_NAME_NODE);
IMPORTANT_STRUCTURE(REPINNED_BCBS);
IMPORTANT_STRUCTURE(RDBSS_IO_CONTEXT);
IMPORTANT_STRUCTURE(IO_RUNS);
IMPORTANT_STRUCTURE(DELETE_CONTEXT);
IMPORTANT_STRUCTURE(FLOPPY_FLUSH_CONTEXT);
IMPORTANT_STRUCTURE(CLOSE_CONTEXT);
IMPORTANT_STRUCTURE(CLEAN_AND_DIRTY_VOLUME_PACKET);


IMPORTANT_STRUCTURE(SRV_CALL);
IMPORTANT_STRUCTURE(NET_ROOT);
IMPORTANT_STRUCTURE(V_NET_ROOT);
IMPORTANT_STRUCTURE(NON_PAGED_FCB);
IMPORTANT_STRUCTURE(FCB);
IMPORTANT_STRUCTURE(SRV_OPEN);
IMPORTANT_STRUCTURE(FOBX);
IMPORTANT_STRUCTURE(RX_CONTEXT);
IMPORTANT_STRUCTURE(LOWIO_CONTEXT);

IMPORTANT_STRUCTURE(EA_RANGE);

IMPORTANT_STRUCTURE(MINIRDR_DISPATCH);
IMPORTANT_STRUCTURE(RDBSS_EXPORTS);
IMPORTANT_STRUCTURE(MRX_SRVCALL_CALLBACK_CONTEXT);
IMPORTANT_STRUCTURE(MRX_SRVCALLDOWN_STRUCTURE);
IMPORTANT_STRUCTURE(MRX_CREATENETROOT_CONTEXT);


#endif // _RDBSSSTRUCHDR_


#elif (NTDDI_VERSION >= NTDDI_WIN2K)

/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    StrucHdr.h

Abstract:

    This module predefines the strucs for important data structures so that we can always talk about 'em....
    even tho they're not defined yet.

Author:
Revision History:

--*/

#ifndef _RDBSSSTRUCHDR_
#define _RDBSSSTRUCHDR_

#define IMPORTANT_STRUCTURE(x) struct _##x; typedef struct _##x *P##x

IMPORTANT_STRUCTURE(NODE_TYPE_CODE_AND_SIZE);

IMPORTANT_STRUCTURE(RX_PREFIX_ENTRY);
IMPORTANT_STRUCTURE(RX_PREFIX_TABLE);

IMPORTANT_STRUCTURE(RX_FSD_DISPATCH_VECTOR);
IMPORTANT_STRUCTURE(RDBSS_DATA);
IMPORTANT_STRUCTURE(RDBSS_EXPORTS);
IMPORTANT_STRUCTURE(VCB);
IMPORTANT_STRUCTURE(RDBSS_DEVICE_OBJECT);
IMPORTANT_STRUCTURE(DSCB);

IMPORTANT_STRUCTURE(FILE_NAME_NODE);
IMPORTANT_STRUCTURE(REPINNED_BCBS);
IMPORTANT_STRUCTURE(RDBSS_IO_CONTEXT);
IMPORTANT_STRUCTURE(IO_RUNS);
IMPORTANT_STRUCTURE(DELETE_CONTEXT);
IMPORTANT_STRUCTURE(FLOPPY_FLUSH_CONTEXT);
IMPORTANT_STRUCTURE(CLOSE_CONTEXT);
IMPORTANT_STRUCTURE(CLEAN_AND_DIRTY_VOLUME_PACKET);


IMPORTANT_STRUCTURE(SRV_CALL);
IMPORTANT_STRUCTURE(NET_ROOT);
IMPORTANT_STRUCTURE(V_NET_ROOT);
IMPORTANT_STRUCTURE(NON_PAGED_FCB);
IMPORTANT_STRUCTURE(FCB);
IMPORTANT_STRUCTURE(SRV_OPEN);
IMPORTANT_STRUCTURE(FOBX);
IMPORTANT_STRUCTURE(RX_CONTEXT);
IMPORTANT_STRUCTURE(LOWIO_CONTEXT);

IMPORTANT_STRUCTURE(EA_RANGE);

IMPORTANT_STRUCTURE(MINIRDR_DISPATCH);
IMPORTANT_STRUCTURE(RDBSS_EXPORTS);
IMPORTANT_STRUCTURE(MRX_SRVCALL_CALLBACK_CONTEXT);
IMPORTANT_STRUCTURE(MRX_SRVCALLDOWN_STRUCTURE);
IMPORTANT_STRUCTURE(MRX_CREATENETROOT_CONTEXT);


#endif // _RDBSSSTRUCHDR_


#else /* NTDDI_VERSION */

#error This file cannot be included for this NTDDI_VERSION.

#endif /* NTDDI_VERSION */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\upssvc.h ===
/*++

Copyright (c) 2000 Microsoft Corporation. All rights reserved.

Module Name:

    upssvc.h

Abstract:

    This file defines the interface to the serial UPS service in 
    Windows 2000.  Please see the UPS documentation in the DDK
    for more information.


--*/

#ifndef _INC_UPS_DRIVER_H_
#define _INC_UPS_DRIVER_H_

#if ((NTDDI_VERSION >= NTDDI_WINXP) && (NTDDI_VERSION < NTDDI_VISTA))

//
// values that represent the state of the
// UPS system - these values are used in the
// UPSGetState and UPSWaitForStateChange functions
//
#define UPS_ONLINE 1
#define UPS_ONBATTERY 2
#define UPS_LOWBATTERY 4
#define UPS_NOCOMM 8
#define UPS_CRITICAL 16


//
// possible error codes returned from UPSInit
//
#define UPS_INITUNKNOWNERROR    0
#define UPS_INITOK              1
#define UPS_INITNOSUCHDRIVER    2
#define UPS_INITBADINTERFACE    3
#define UPS_INITREGISTRYERROR   4
#define UPS_INITCOMMOPENERROR   5
#define UPS_INITCOMMSETUPERROR  6


/**
* UPSInit
*
* Description:
*   
*   The UPSInit function must be called before any
*   other function in this file
*
* Parameters:
*   None
*
* Returns:
*   UPS_INITOK: Initalization was successful
*   UPS_INITNOSUCHDRIVER:   The configured driver DLL can't be opened    
*   UPS_INITBADINTERFACE:   The configured driver DLL doesn't support 
*                           the UPS driver interface
*   UPS_INITREGISTRYERROR:  The 'Options' registry value is corrupt
*   UPS_INITCOMMOPENERROR:  The comm port could not be opened
*   UPS_INITCOMMSETUPERROR: The comm port could not be configured
*   UPS_INITUNKNOWNERROR:   Undefined error has occurred
*   
*/
DWORD UPSInit(void);


/**
* UPSStop
*
* Description:
*   After a call to UPSStop, only the UPSInit
*   function is valid.  This call will unload the
*   UPS driver interface and stop monitoring of the
*   UPS system
*
* Parameters:
*   None
*
* Returns:
*   None
*   
*/
void UPSStop(void);


/**
* UPSWaitForStateChange
*
* Description:
*   Blocks until the state of the UPS differs
*   from the value passed in via aCurrentState or 
*   anInterval milliseconds has expired.  If
*   anInterval has a value of INFINITE this 
*   function will never timeout
*
* Parameters:
*   aState: defines the state to wait for a change from,
*           possible values:
*           UPS_ONLINE 
*           UPS_ONBATTERY
*           UPS_LOWBATTERY
*           UPS_NOCOMM
*
*   anInterval: timeout in milliseconds, or INFINITE for
*               no timeout interval
*
* Returns:
*   None
*   
*/
void UPSWaitForStateChange(DWORD aCurrentState, DWORD anInterval);


/**
* UPSGetState
*
* Description:
*   returns the current state of the UPS
*
* Parameters:
*   None
*
* Returns: 
*   possible values:
*           UPS_ONLINE 
*           UPS_ONBATTERY
*           UPS_LOWBATTERY
*           UPS_NOCOMM
*   
*/
DWORD UPSGetState(void);


/**
* UPSCancelWait
*
* Description:
*   interrupts pending calls to UPSWaitForStateChange
*   without regard to timout or state change
*
* Parameters:
*   None
*
* Returns:
*   None
*   
*/
void UPSCancelWait(void);


/**
* UPSTurnOff
*
* Description:
*   Attempts to turn off the outlets on the UPS
*   after the specified delay.  This call must
*   return immediately.  Any work, such as a timer,
*   must be performed on a another thread.
*
* Parameters:
*   aTurnOffDelay: the minimum amount of time to wait before
*                  turning off the outlets on the UPS
*
* Returns:
*   None
*   
*/
void UPSTurnOff(DWORD aTurnOffDelay);

#endif // ((NTDDI_VERSION >= NTDDI_WINXP) && (NTDDI_VERSION < NTDDI_VISTA))

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\swenum.h ===
/*++

    Copyright (c) 1997 Microsoft Corporation

Module Name:

    swenum.h

Abstract:
    Public header file and bus interface definition for the
    software device enumerator.

--*/

#if !defined( _SWENUM_ )

#define _SWENUM_

// Io controls

#define IOCTL_SWENUM_INSTALL_INTERFACE  CTL_CODE(FILE_DEVICE_BUS_EXTENDER, 0x000, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_SWENUM_REMOVE_INTERFACE   CTL_CODE(FILE_DEVICE_BUS_EXTENDER, 0x001, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_SWENUM_GET_BUS_ID         CTL_CODE(FILE_DEVICE_BUS_EXTENDER, 0x002, METHOD_NEITHER, FILE_READ_ACCESS)

//
// Io control related structures
//

typedef struct _SWENUM_INSTALL_INTERFACE {
    GUID    DeviceId;
    GUID    InterfaceId;
    WCHAR  ReferenceString[1];
    
} SWENUM_INSTALL_INTERFACE, *PSWENUM_INSTALL_INTERFACE;

#if defined( _KS_ )

#define STATIC_BUSID_SoftwareDeviceEnumerator STATIC_KSMEDIUMSETID_Standard
#define BUSID_SoftwareDeviceEnumerator KSMEDIUMSETID_Standard

#else // !_KS_

#define STATIC_BUSID_SoftwareDeviceEnumerator \
    0x4747B320L, 0x62CE, 0x11CF, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00
#if defined(__cplusplus) && _MSC_VER >= 1100
struct __declspec(uuid("4747B320-62CE-11CF-A5D6-28DB04C10000")) BUSID_SoftwareDeviceEnumerator;
#define BUSID_SoftwareDeviceEnumerator __uuidof(struct BUSID_SoftwareDeviceEnumerator)
#else
DEFINE_GUIDEX(BUSID_SoftwareDeviceEnumerator);
#endif // !(defined(__cplusplus) && _MSC_VER >= 1100)

#endif // !_KS_

#if defined( _NTDDK_ )

typedef 
VOID 
(*PFNREFERENCEDEVICEOBJECT)( 
    IN PVOID Context
    );
    
typedef 
VOID 
(*PFNDEREFERENCEDEVICEOBJECT)( 
    IN PVOID Context
    );
    
typedef
NTSTATUS
(*PFNQUERYREFERENCESTRING)( 
    IN PVOID Context,
    IN OUT PWCHAR *String
    );

#define BUS_INTERFACE_SWENUM_VERSION    0x100
    
typedef struct _BUS_INTERFACE_SWENUM {
    //
    // Standard interface header
    //
    
    INTERFACE                   Interface;
    
    //
    // SWENUM bus interfaces
    //
    
    PFNREFERENCEDEVICEOBJECT    ReferenceDeviceObject;
    PFNDEREFERENCEDEVICEOBJECT  DereferenceDeviceObject;
    PFNQUERYREFERENCESTRING     QueryReferenceString;
    
} BUS_INTERFACE_SWENUM, *PBUS_INTERFACE_SWENUM;

#if defined(__cplusplus)
extern "C" {
#endif // defined(__cplusplus)

#if defined( _KS_ )

KSDDKAPI
NTSTATUS
NTAPI
KsQuerySoftwareBusInterface(
    IN PDEVICE_OBJECT PnpDeviceObject,
    OUT PBUS_INTERFACE_SWENUM BusInterface
    );

KSDDKAPI
NTSTATUS
NTAPI
KsReferenceSoftwareBusObject(
    IN KSDEVICE_HEADER  Header
    );

KSDDKAPI
VOID
NTAPI
KsDereferenceSoftwareBusObject(
    IN KSDEVICE_HEADER  Header
    );

KSDDKAPI
NTSTATUS
NTAPI
KsCreateBusEnumObject(
    IN PWCHAR BusIdentifier,
    IN PDEVICE_OBJECT BusDeviceObject,
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    IN PDEVICE_OBJECT PnpDeviceObject OPTIONAL,
    IN REFGUID InterfaceGuid OPTIONAL,
    IN PWCHAR ServiceRelativePath OPTIONAL
    );
    
KSDDKAPI
NTSTATUS
NTAPI
KsGetBusEnumIdentifier(
    IN PIRP Irp
    );

KSDDKAPI
NTSTATUS
NTAPI
KsGetBusEnumPnpDeviceObject(
    IN PDEVICE_OBJECT DeviceObject,
    IN PDEVICE_OBJECT *PnpDeviceObject
    );
    
KSDDKAPI
NTSTATUS
NTAPI
KsInstallBusEnumInterface(
    PIRP Irp
    );
    
KSDDKAPI
NTSTATUS
NTAPI
KsIsBusEnumChildDevice(
    IN PDEVICE_OBJECT DeviceObject,
    OUT PBOOLEAN ChildDevice
    );
    
KSDDKAPI
NTSTATUS
NTAPI
KsRemoveBusEnumInterface(
    IN PIRP Irp
    );
    
KSDDKAPI
NTSTATUS
NTAPI
KsServiceBusEnumPnpRequest(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );
    
KSDDKAPI
NTSTATUS
NTAPI
KsServiceBusEnumCreateRequest(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );
    
KSDDKAPI
NTSTATUS
NTAPI
KsGetBusEnumParentFDOFromChildPDO(
    IN PDEVICE_OBJECT DeviceObject,
    OUT PDEVICE_OBJECT *FunctionalDeviceObject
    );

#endif // _KS_

#if defined(__cplusplus)
}
#endif // defined(__cplusplus)

#endif // _NTDDK_

#endif // !_SWENUM_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\ddk\inc\tdikrnl.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    tdikrnl.h

Abstract:

    This header file contains interface definitions for NT transport
    providers running in kernel mode.  This interface is documented in the
    NT Transport Driver Interface (TDI) Specification, Version 2.

Revision History:

--*/

#ifndef _TDI_KRNL_
#define _TDI_KRNL_

#pragma once

#include <tdi.h>   // get the user mode includes
#include <netpnp.h>

#pragma warning(push)
#pragma warning(disable:4201) // nameless struct/union

//
// In this TDI, a kernel mode client calls TDI using IoCallDriver with the
// current Irp stack pointer set to 16 bytes of pointers to other structures.
// each of the supported NtDeviceIoControlFile analogs has a somehat different
// structure, laid out below.
//
// The IrpSP information passed by kernel mode clients looks like:
//

typedef struct _TDI_REQUEST_KERNEL {
    ULONG_PTR RequestFlags;
    PTDI_CONNECTION_INFORMATION RequestConnectionInformation;
    PTDI_CONNECTION_INFORMATION ReturnConnectionInformation;
    PVOID RequestSpecific;
} TDI_REQUEST_KERNEL, *PTDI_REQUEST_KERNEL;

//
// defined request codes for the kernel clients. We make these the same
// as the IOCTL codes mostly for convenience; either can be used with
// the same results.
//

#define TDI_ASSOCIATE_ADDRESS    (0x01)
#define TDI_DISASSOCIATE_ADDRESS (0x02)
#define TDI_CONNECT              (0x03)
#define TDI_LISTEN               (0x04)
#define TDI_ACCEPT               (0x05)
#define TDI_DISCONNECT           (0x06)
#define TDI_SEND                 (0x07)
#define TDI_RECEIVE              (0x08)
#define TDI_SEND_DATAGRAM        (0x09)
#define TDI_RECEIVE_DATAGRAM     (0x0A)
#define TDI_SET_EVENT_HANDLER    (0x0B)
#define TDI_QUERY_INFORMATION    (0x0C)
#define TDI_SET_INFORMATION      (0x0D)
#define TDI_ACTION               (0x0E)

#define TDI_DIRECT_SEND          (0x27)
#define TDI_DIRECT_SEND_DATAGRAM (0x29)
#define TDI_DIRECT_ACCEPT        (0x2A)

//
// TdiOpenAddress (Not Used)
// TdiCloseAddress (Not Used)
// TdiOpenConnection (Not Used)
// TdiCloseConnection (Not Used)
//

//
// some useful constants for comparison when determining the file type;
// not required.
//

#define TDI_TRANSPORT_ADDRESS_FILE  1
#define TDI_CONNECTION_FILE 2
#define TDI_CONTROL_CHANNEL_FILE 3

//
// Internal TDI IOCTLS
//

#define IOCTL_TDI_QUERY_DIRECT_SEND_HANDLER     _TDI_CONTROL_CODE( 0x80, METHOD_NEITHER )
#define IOCTL_TDI_QUERY_DIRECT_SENDDG_HANDLER   _TDI_CONTROL_CODE( 0x81, METHOD_NEITHER )

//
// TdiAssociateAddress
//

typedef struct _TDI_REQUEST_KERNEL_ASSOCIATE {
    HANDLE AddressHandle;
} TDI_REQUEST_KERNEL_ASSOCIATE, *PTDI_REQUEST_KERNEL_ASSOCIATE;

//
// TdiDisassociateAddress -- None supplied
//

typedef TDI_REQUEST_KERNEL TDI_REQUEST_KERNEL_DISASSOCIATE,
    *PTDI_REQUEST_KERNEL_DISASSOCIATE;

//
// TdiConnect uses the structure given above (TDI_REQUEST_KERNEL); it's
// defined again below for convenience
//

typedef TDI_REQUEST_KERNEL TDI_REQUEST_KERNEL_CONNECT,
    *PTDI_REQUEST_KERNEL_CONNECT;

//
// TdiDisconnect uses the structure given above (TDI_REQUEST_KERNEL); it's
// defined again below for convenience
//

typedef TDI_REQUEST_KERNEL TDI_REQUEST_KERNEL_DISCONNECT,
    *PTDI_REQUEST_KERNEL_DISCONNECT;

//
// TdiListen uses the structure given above (TDI_REQUEST_KERNEL); it's
// defined again below for convenience
//

typedef TDI_REQUEST_KERNEL TDI_REQUEST_KERNEL_LISTEN,
    *PTDI_REQUEST_KERNEL_LISTEN;

//
// TdiAccept
//

typedef struct _TDI_REQUEST_KERNEL_ACCEPT {
    PTDI_CONNECTION_INFORMATION RequestConnectionInformation;
    PTDI_CONNECTION_INFORMATION ReturnConnectionInformation;
} TDI_REQUEST_KERNEL_ACCEPT, *PTDI_REQUEST_KERNEL_ACCEPT;

//
// TdiSend
//

typedef struct _TDI_REQUEST_KERNEL_SEND {
    ULONG SendLength;
    ULONG SendFlags;
} TDI_REQUEST_KERNEL_SEND, *PTDI_REQUEST_KERNEL_SEND;

//
// TdiReceive
//

typedef struct _TDI_REQUEST_KERNEL_RECEIVE {
    ULONG ReceiveLength;
    ULONG ReceiveFlags;
} TDI_REQUEST_KERNEL_RECEIVE, *PTDI_REQUEST_KERNEL_RECEIVE;

//
// TdiSendDatagram
//

typedef struct _TDI_REQUEST_KERNEL_SENDDG {
    ULONG SendLength;
    __field_bcount(SendLength) PTDI_CONNECTION_INFORMATION SendDatagramInformation;
} TDI_REQUEST_KERNEL_SENDDG, *PTDI_REQUEST_KERNEL_SENDDG;

//
// TdiReceiveDatagram
//

typedef struct _TDI_REQUEST_KERNEL_RECEIVEDG {
    ULONG ReceiveLength;
    PTDI_CONNECTION_INFORMATION ReceiveDatagramInformation;
    PTDI_CONNECTION_INFORMATION ReturnDatagramInformation;
    ULONG ReceiveFlags;
} TDI_REQUEST_KERNEL_RECEIVEDG, *PTDI_REQUEST_KERNEL_RECEIVEDG;

//
// TdiSetEventHandler
//

typedef struct _TDI_REQUEST_KERNEL_SET_EVENT {
    LONG EventType;
    PVOID EventHandler;
    PVOID EventContext;
} TDI_REQUEST_KERNEL_SET_EVENT, *PTDI_REQUEST_KERNEL_SET_EVENT;

//
// TdiQueryInformation
//

typedef struct _TDI_REQUEST_KERNEL_QUERY_INFO {
    LONG QueryType;
    PTDI_CONNECTION_INFORMATION RequestConnectionInformation;
} TDI_REQUEST_KERNEL_QUERY_INFORMATION, *PTDI_REQUEST_KERNEL_QUERY_INFORMATION;

//
// TdiSetInformation
//

typedef struct _TDI_REQUEST_KERNEL_SET_INFO {
    LONG SetType;
    PTDI_CONNECTION_INFORMATION RequestConnectionInformation;
} TDI_REQUEST_KERNEL_SET_INFORMATION, *PTDI_REQUEST_KERNEL_SET_INFORMATION;

//
// Event types that are known
//

#define TDI_EVENT_CONNECT           ((USHORT)0) // TDI_IND_CONNECT event handler.
#define TDI_EVENT_DISCONNECT        ((USHORT)1) // TDI_IND_DISCONNECT event handler.
#define TDI_EVENT_ERROR             ((USHORT)2) // TDI_IND_ERROR event handler.
#define TDI_EVENT_RECEIVE           ((USHORT)3) // TDI_IND_RECEIVE event handler.
#define TDI_EVENT_RECEIVE_DATAGRAM  ((USHORT)4) // TDI_IND_RECEIVE_DATAGRAM event handler.
#define TDI_EVENT_RECEIVE_EXPEDITED ((USHORT)5) // TDI_IND_RECEIVE_EXPEDITED event handler.
#define TDI_EVENT_SEND_POSSIBLE     ((USHORT)6) // TDI_IND_SEND_POSSIBLE event handler
#define TDI_EVENT_CHAINED_RECEIVE   ((USHORT)7) // TDI_IND_CHAINED_RECEIVE event handler.
#define TDI_EVENT_CHAINED_RECEIVE_DATAGRAM  ((USHORT)8) // TDI_IND_CHAINED_RECEIVE_DATAGRAM event handler.
#define TDI_EVENT_CHAINED_RECEIVE_EXPEDITED ((USHORT)9) // TDI_IND_CHAINED_RECEIVE_EXPEDITED event handler.
#define TDI_EVENT_ERROR_EX      ((USHORT)10) // TDI_IND_UNREACH_ERROR event handler.


//
// indicate connection event prototype. This is invoked when a request for
// connection has been received by the provider and the user wishes to either
// accept or reject that request.
//

typedef
NTSTATUS
(*PTDI_IND_CONNECT)(
    IN PVOID TdiEventContext,
    IN LONG RemoteAddressLength,
    IN PVOID RemoteAddress,
    IN LONG UserDataLength,
    IN PVOID UserData,
    IN LONG OptionsLength,
    IN PVOID Options,
    OUT CONNECTION_CONTEXT *ConnectionContext,
    OUT PIRP *AcceptIrp
    );

NTSTATUS
TdiDefaultConnectHandler (
    IN PVOID TdiEventContext,
    IN LONG RemoteAddressLength,
    IN PVOID RemoteAddress,
    IN LONG UserDataLength,
    IN PVOID UserData,
    IN LONG OptionsLength,
    IN PVOID Options,
    OUT CONNECTION_CONTEXT *ConnectionContext,
    OUT PIRP *AcceptIrp
    );

//
// Disconnection indication prototype. This is invoked when a connection is
// being disconnected for a reason other than the user requesting it. Note that
// this is a change from TDI V1, which indicated only when the remote caused
// a disconnection. Any non-directed disconnection will cause this indication.
//

typedef
NTSTATUS
(*PTDI_IND_DISCONNECT)(
    IN PVOID TdiEventContext,
    IN CONNECTION_CONTEXT ConnectionContext,
    IN LONG DisconnectDataLength,
    IN PVOID DisconnectData,
    IN LONG DisconnectInformationLength,
    IN PVOID DisconnectInformation,
    IN ULONG DisconnectFlags
    );

NTSTATUS
TdiDefaultDisconnectHandler (
    IN PVOID TdiEventContext,
    IN CONNECTION_CONTEXT ConnectionContext,
    IN LONG DisconnectDataLength,
    IN PVOID DisconnectData,
    IN LONG DisconnectInformationLength,
    IN PVOID DisconnectInformation,
    IN ULONG DisconnectFlags
    );

//
// A protocol error has occurred when this indication happens. This indication
// occurs only for errors of the worst type; the address this indication is
// delivered to is no longer usable for protocol-related operations, and
// should not be used for operations henceforth. All connections associated
// it are invalid.
// For NetBIOS-type providers, this indication is also delivered when a name
// in conflict or duplicate name occurs.
//

typedef
NTSTATUS
(*PTDI_IND_ERROR)(
    IN PVOID TdiEventContext,           // the endpoint's file object.
    IN NTSTATUS Status                // status code indicating error type.
    );



typedef
NTSTATUS
(*PTDI_IND_ERROR_EX)(
    IN PVOID TdiEventContext,           // the endpoint's file object.
    IN NTSTATUS Status,                // status code indicating error type.
    IN PVOID Buffer
    );


NTSTATUS
TdiDefaultErrorHandler (
    IN PVOID TdiEventContext,           // the endpoint's file object.
    IN NTSTATUS Status                // status code indicating error type.
    );

//
// TDI_IND_RECEIVE indication handler definition.  This client routine is
// called by the transport provider when a connection-oriented TSDU is received
// that should be presented to the client.
//

typedef
NTSTATUS
(*PTDI_IND_RECEIVE)(
    IN PVOID TdiEventContext,
    IN CONNECTION_CONTEXT ConnectionContext,
    IN ULONG ReceiveFlags,
    IN ULONG BytesIndicated,
    IN ULONG BytesAvailable,
    OUT ULONG *BytesTaken,
    IN PVOID Tsdu,                      // pointer describing this TSDU, typically a lump of bytes
    OUT PIRP *IoRequestPacket            // TdiReceive IRP if MORE_PROCESSING_REQUIRED.
    );

NTSTATUS
TdiDefaultReceiveHandler (
    IN PVOID TdiEventContext,
    IN CONNECTION_CONTEXT ConnectionContext,
    IN ULONG ReceiveFlags,
    IN ULONG BytesIndicated,
    IN ULONG BytesAvailable,
    OUT ULONG *BytesTaken,
    IN PVOID Tsdu,                      // pointer describing this TSDU, typically a lump of bytes
    OUT PIRP *IoRequestPacket            // TdiReceive IRP if MORE_PROCESSING_REQUIRED.
    );

//
// TDI_IND_RECEIVE_DATAGRAM indication handler definition.  This client routine
// is called by the transport provider when a connectionless TSDU is received
// that should be presented to the client.
//

typedef
NTSTATUS
(*PTDI_IND_RECEIVE_DATAGRAM)(
    IN PVOID TdiEventContext,       // the event context
    IN LONG SourceAddressLength,    // length of the originator of the datagram
    IN PVOID SourceAddress,         // string describing the originator of the datagram
    IN LONG OptionsLength,          // options for the receive
    IN PVOID Options,               //
    IN ULONG ReceiveDatagramFlags,  //
    IN ULONG BytesIndicated,        // number of bytes this indication
    IN ULONG BytesAvailable,        // number of bytes in complete Tsdu
    OUT ULONG *BytesTaken,          // number of bytes used
    IN PVOID Tsdu,                  // pointer describing this TSDU, typically a lump of bytes
    OUT PIRP *IoRequestPacket        // TdiReceive IRP if MORE_PROCESSING_REQUIRED.
    );

NTSTATUS
TdiDefaultRcvDatagramHandler (
    IN PVOID TdiEventContext,       // the event context
    IN LONG SourceAddressLength,    // length of the originator of the datagram
    IN PVOID SourceAddress,         // string describing the originator of the datagram
    IN LONG OptionsLength,          // options for the receive
    IN PVOID Options,               //
    IN ULONG ReceiveDatagramFlags,  //
    IN ULONG BytesIndicated,        // number of bytes this indication
    IN ULONG BytesAvailable,        // number of bytes in complete Tsdu
    OUT ULONG *BytesTaken,          // number of bytes used
    IN PVOID Tsdu,                  // pointer describing this TSDU, typically a lump of bytes
    OUT PIRP *IoRequestPacket        // TdiReceive IRP if MORE_PROCESSING_REQUIRED.
    );

//
// This indication is delivered if expedited data is received on the connection.
// This will only occur in providers that support expedited data.
//

typedef
NTSTATUS
(*PTDI_IND_RECEIVE_EXPEDITED)(
    IN PVOID TdiEventContext,
    IN CONNECTION_CONTEXT ConnectionContext,
    IN ULONG ReceiveFlags,          //
    IN ULONG BytesIndicated,        // number of bytes in this indication
    IN ULONG BytesAvailable,        // number of bytes in complete Tsdu
    OUT ULONG *BytesTaken,          // number of bytes used by indication routine
    IN PVOID Tsdu,                  // pointer describing this TSDU, typically a lump of bytes
    OUT PIRP *IoRequestPacket        // TdiReceive IRP if MORE_PROCESSING_REQUIRED.
    );

NTSTATUS
TdiDefaultRcvExpeditedHandler (
    IN PVOID TdiEventContext,
    IN CONNECTION_CONTEXT ConnectionContext,
    IN ULONG ReceiveFlags,          //
    IN ULONG BytesIndicated,        // number of bytes in this indication
    IN ULONG BytesAvailable,        // number of bytes in complete Tsdu
    OUT ULONG *BytesTaken,          // number of bytes used by indication routine
    IN PVOID Tsdu,                  // pointer describing this TSDU, typically a lump of bytes
    OUT PIRP *IoRequestPacket        // TdiReceive IRP if MORE_PROCESSING_REQUIRED.
    );

//
// TDI_IND_CHAINED_RECEIVE indication handler definition.  This client routine
// is called by the transport provider when a connection-oriented TSDU is
// received that should be presented to the client. The TSDU is stored in an
// MDL chain. The client may take ownership of the TSDU and return it at a
// later time.
//

typedef
NTSTATUS
(*PTDI_IND_CHAINED_RECEIVE)(
    IN PVOID TdiEventContext,
    IN CONNECTION_CONTEXT ConnectionContext,
    IN ULONG ReceiveFlags,
    IN ULONG ReceiveLength,        // length of client data in TSDU
    IN ULONG StartingOffset,       // offset of start of client data in TSDU
    IN PMDL  Tsdu,                 // TSDU data chain
    IN PVOID TsduDescriptor        // for call to TdiReturnChainedReceives
    );

NTSTATUS
TdiDefaultChainedReceiveHandler (
    IN PVOID TdiEventContext,
    IN CONNECTION_CONTEXT ConnectionContext,
    IN ULONG ReceiveFlags,
    IN ULONG ReceiveLength,        // length of client data in TSDU
    IN ULONG StartingOffset,       // offset of start of client data in TSDU
    IN PMDL  Tsdu,                 // TSDU data chain
    IN PVOID TsduDescriptor        // for call to TdiReturnChainedReceives
    );

//
// TDI_IND_CHAINED_RECEIVE_DATAGRAM indication handler definition.  This client
// routine is called by the transport provider when a connectionless TSDU is
// received that should be presented to the client. The TSDU is stored in an
// MDL chain. The client may take ownership of the TSDU and return it at a
// later time.
//

typedef
NTSTATUS
(*PTDI_IND_CHAINED_RECEIVE_DATAGRAM)(
    IN PVOID TdiEventContext,       // the event context
    IN LONG SourceAddressLength,    // length of the originator of the datagram
    IN PVOID SourceAddress,         // string describing the originator of the datagram
    IN LONG OptionsLength,          // options for the receive
    IN PVOID Options,               //
    IN ULONG ReceiveDatagramFlags,  //
    IN ULONG ReceiveDatagramLength, // length of client data in TSDU
    IN ULONG StartingOffset,        // offset of start of client data in TSDU
    IN PMDL  Tsdu,                  // TSDU data chain
    IN PVOID TsduDescriptor         // for call to TdiReturnChainedReceives
    );

NTSTATUS
TdiDefaultChainedRcvDatagramHandler (
    IN PVOID TdiEventContext,       // the event context
    IN LONG SourceAddressLength,    // length of the originator of the datagram
    IN PVOID SourceAddress,         // string describing the originator of the datagram
    IN LONG OptionsLength,          // options for the receive
    IN PVOID Options,               //
    IN ULONG ReceiveDatagramFlags,  //
    IN ULONG ReceiveDatagramLength, // length of client data in TSDU
    IN ULONG StartingOffset,        // offset of start of client data in TSDU
    IN PMDL  Tsdu,                  // TSDU data chain
    IN PVOID TsduDescriptor         // for call to TdiReturnChainedReceives
    );

//
// This indication is delivered if expedited data is received on the connection.
// This will only occur in providers that support expedited data. The TSDU is
// stored in an MDL chain. The client may take ownership of the TSDU and
// return it at a later time.
//

typedef
NTSTATUS
(*PTDI_IND_CHAINED_RECEIVE_EXPEDITED)(
    IN PVOID TdiEventContext,
    IN CONNECTION_CONTEXT ConnectionContext,
    IN ULONG ReceiveFlags,
    IN ULONG ReceiveLength,      // length of client data in TSDU
    IN ULONG StartingOffset,     // offset of start of client data in TSDU
    IN PMDL  Tsdu,               // TSDU data chain
    IN PVOID TsduDescriptor      // for call to TdiReturnChainedReceives
    );

NTSTATUS
TdiDefaultChainedRcvExpeditedHandler (
    IN PVOID TdiEventContext,
    IN CONNECTION_CONTEXT ConnectionContext,
    IN ULONG ReceiveFlags,
    IN ULONG ReceiveLength,      // length of client data in TSDU
    IN ULONG StartingOffset,     // offset of start of client data in TSDU
    IN PMDL  Tsdu,               // TSDU data chain
    IN PVOID TsduDescriptor      // for call to TdiReturnChainedReceives
    );

//
// This indication is delivered if there is room for a send in the buffer of
// a buffering protocol.
//

typedef
NTSTATUS
(*PTDI_IND_SEND_POSSIBLE)(
    IN PVOID TdiEventContext,
    IN PVOID ConnectionContext,
    IN ULONG BytesAvailable);

NTSTATUS
TdiDefaultSendPossibleHandler (
    IN PVOID TdiEventContext,
    IN PVOID ConnectionContext,
    IN ULONG BytesAvailable);

//
// defined MACROS to allow the kernel mode client to easily build an IRP for
// any function.
//

#define TdiBuildAssociateAddress(Irp, DevObj, FileObj, CompRoutine, Contxt, AddrHandle)                           \
    {                                                                        \
        PTDI_REQUEST_KERNEL_ASSOCIATE p;                                     \
        PIO_STACK_LOCATION _IRPSP;                                           \
        if ( CompRoutine != NULL) {                                          \
            IoSetCompletionRoutine( Irp, CompRoutine, Contxt, TRUE, TRUE, TRUE);\
        } else {                                                             \
            IoSetCompletionRoutine( Irp, NULL, NULL, FALSE, FALSE, FALSE);   \
        }                                                                    \
        _IRPSP = IoGetNextIrpStackLocation (Irp);                            \
        _IRPSP->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;              \
        _IRPSP->MinorFunction = TDI_ASSOCIATE_ADDRESS;                       \
        _IRPSP->DeviceObject = DevObj;                                       \
        _IRPSP->FileObject = FileObj;                                        \
        p = (PTDI_REQUEST_KERNEL_ASSOCIATE)&_IRPSP->Parameters;              \
        p->AddressHandle = (HANDLE)(AddrHandle);                             \
    }

#define TdiBuildDisassociateAddress(Irp, DevObj, FileObj, CompRoutine, Contxt)                                    \
    {                                                                        \
        PTDI_REQUEST_KERNEL_DISASSOCIATE p;                                  \
        PIO_STACK_LOCATION _IRPSP;                                           \
        if ( CompRoutine != NULL) {                                          \
            IoSetCompletionRoutine( Irp, CompRoutine, Contxt, TRUE, TRUE, TRUE);\
        } else {                                                             \
            IoSetCompletionRoutine( Irp, NULL, NULL, FALSE, FALSE, FALSE);   \
        }                                                                    \
        _IRPSP = IoGetNextIrpStackLocation (Irp);                            \
        _IRPSP->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;              \
        _IRPSP->MinorFunction = TDI_DISASSOCIATE_ADDRESS;                    \
        _IRPSP->DeviceObject = DevObj;                                       \
        _IRPSP->FileObject = FileObj;                                        \
        p = (PTDI_REQUEST_KERNEL_DISASSOCIATE)&_IRPSP->Parameters;           \
    }

#define TdiBuildConnect(Irp, DevObj, FileObj, CompRoutine, Contxt, Time, RequestConnectionInfo, ReturnConnectionInfo)\
    {                                                                        \
        PTDI_REQUEST_KERNEL p;                                               \
        PIO_STACK_LOCATION _IRPSP;                                           \
        if ( CompRoutine != NULL) {                                          \
            IoSetCompletionRoutine( Irp, CompRoutine, Contxt, TRUE, TRUE, TRUE);\
        } else {                                                             \
            IoSetCompletionRoutine( Irp, NULL, NULL, FALSE, FALSE, FALSE);   \
        }                                                                    \
        _IRPSP = IoGetNextIrpStackLocation (Irp);                            \
        _IRPSP->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;              \
        _IRPSP->MinorFunction = TDI_CONNECT;                                 \
        _IRPSP->DeviceObject = DevObj;                                       \
        _IRPSP->FileObject = FileObj;                                        \
        p = (PTDI_REQUEST_KERNEL)&_IRPSP->Parameters;                        \
        p->RequestConnectionInformation = RequestConnectionInfo;             \
        p->ReturnConnectionInformation = ReturnConnectionInfo;               \
        p->RequestSpecific = (PVOID)Time;                                    \
    }

#define TdiBuildListen(Irp, DevObj, FileObj, CompRoutine, Contxt, Flags, RequestConnectionInfo, ReturnConnectionInfo)\
    {                                                                        \
        PTDI_REQUEST_KERNEL p;                                               \
        PIO_STACK_LOCATION _IRPSP;                                           \
        if ( CompRoutine != NULL) {                                          \
            IoSetCompletionRoutine( Irp, CompRoutine, Contxt, TRUE, TRUE, TRUE);\
        } else {                                                             \
            IoSetCompletionRoutine( Irp, NULL, NULL, FALSE, FALSE, FALSE);   \
        }                                                                    \
        _IRPSP = IoGetNextIrpStackLocation (Irp);                            \
        _IRPSP->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;              \
        _IRPSP->MinorFunction = TDI_LISTEN;                                  \
        _IRPSP->DeviceObject = DevObj;                                       \
        _IRPSP->FileObject = FileObj;                                        \
        p = (PTDI_REQUEST_KERNEL)&_IRPSP->Parameters;                        \
        p->RequestFlags = Flags;                                             \
        p->RequestConnectionInformation = RequestConnectionInfo;             \
        p->ReturnConnectionInformation = ReturnConnectionInfo;               \
    }

#define TdiBuildAccept(Irp, DevObj, FileObj, CompRoutine, Contxt, RequestConnectionInfo, ReturnConnectionInfo)\
    {                                                                        \
        PTDI_REQUEST_KERNEL_ACCEPT p;                                        \
        PIO_STACK_LOCATION _IRPSP;                                           \
        if ( CompRoutine != NULL) {                                          \
            IoSetCompletionRoutine( Irp, CompRoutine, Contxt, TRUE, TRUE, TRUE);\
        } else {                                                             \
            IoSetCompletionRoutine( Irp, NULL, NULL, FALSE, FALSE, FALSE);   \
        }                                                                    \
        _IRPSP = IoGetNextIrpStackLocation (Irp);                            \
        _IRPSP->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;              \
        _IRPSP->MinorFunction = TDI_ACCEPT;                                  \
        _IRPSP->DeviceObject = DevObj;                                       \
        _IRPSP->FileObject = FileObj;                                        \
        p = (PTDI_REQUEST_KERNEL_ACCEPT)&_IRPSP->Parameters;                 \
        p->RequestConnectionInformation = RequestConnectionInfo;             \
        p->ReturnConnectionInformation = ReturnConnectionInfo;               \
    }

#if (NTDDI_VERSION < NTDDI_WINXP)
#define TdiBuildDirectAccept(Irp, DevObj, FileObj, CompRoutine, Contxt, RequestConnectionInfo, ReturnConnectionInfo)\
    {                                                                        \
        PTDI_REQUEST_KERNEL_ACCEPT p;                                        \
        PIO_STACK_LOCATION _IRPSP;                                           \
        if ( CompRoutine != NULL) {                                          \
            IoSetCompletionRoutine( Irp, CompRoutine, Contxt, TRUE, TRUE, TRUE);\
        } else {                                                             \
            IoSetCompletionRoutine( Irp, NULL, NULL, FALSE, FALSE, FALSE);   \
        }                                                                    \
        _IRPSP = IoGetNextIrpStackLocation (Irp);                            \
        _IRPSP->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;              \
        _IRPSP->MinorFunction = TDI_DIRECT_ACCEPT;                           \
        _IRPSP->DeviceObject = DevObj;                                       \
        _IRPSP->FileObject = FileObj;                                        \
        p = (PTDI_REQUEST_KERNEL_ACCEPT)&_IRPSP->Parameters;                 \
        p->RequestConnectionInformation = RequestConnectionInfo;             \
        p->ReturnConnectionInformation = ReturnConnectionInfo;               \
    }
#endif    

#define TdiBuildDisconnect(Irp, DevObj, FileObj, CompRoutine, Contxt, Time, Flags, RequestConnectionInfo, ReturnConnectionInfo)\
    {                                                                        \
        PTDI_REQUEST_KERNEL p;                                               \
        PIO_STACK_LOCATION _IRPSP;                                           \
        if ( CompRoutine != NULL) {                                          \
            IoSetCompletionRoutine( Irp, CompRoutine, Contxt, TRUE, TRUE, TRUE);\
        } else {                                                             \
            IoSetCompletionRoutine( Irp, NULL, NULL, FALSE, FALSE, FALSE);   \
        }                                                                    \
        _IRPSP = IoGetNextIrpStackLocation (Irp);                            \
        _IRPSP->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;              \
        _IRPSP->MinorFunction = TDI_DISCONNECT;                              \
        _IRPSP->DeviceObject = DevObj;                                       \
        _IRPSP->FileObject = FileObj;                                        \
        p = (PTDI_REQUEST_KERNEL)&_IRPSP->Parameters;                        \
        p->RequestFlags = Flags;                                             \
        p->RequestConnectionInformation = RequestConnectionInfo;             \
        p->ReturnConnectionInformation = ReturnConnectionInfo;               \
        p->RequestSpecific = (PVOID)Time;                                    \
    }

#define TdiBuildReceive(Irp, DevObj, FileObj, CompRoutine, Contxt, MdlAddr, InFlags, ReceiveLen)\
    {                                                                        \
        PTDI_REQUEST_KERNEL_RECEIVE p;                                       \
        PIO_STACK_LOCATION _IRPSP;                                           \
        if ( CompRoutine != NULL) {                                          \
            IoSetCompletionRoutine( Irp, CompRoutine, Contxt, TRUE, TRUE, TRUE);\
        } else {                                                             \
            IoSetCompletionRoutine( Irp, NULL, NULL, FALSE, FALSE, FALSE);   \
        }                                                                    \
        _IRPSP = IoGetNextIrpStackLocation (Irp);                            \
        _IRPSP->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;              \
        _IRPSP->MinorFunction = TDI_RECEIVE;                                 \
        _IRPSP->DeviceObject = DevObj;                                       \
        _IRPSP->FileObject = FileObj;             