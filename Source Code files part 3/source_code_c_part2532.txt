 middle.
	if (m_spCmds != NULL)
		m_spCmds->RemoveAll();
}

CMD CDynamicBuildEngine::BatchCmdLines(BOOL fBatch /* = TRUE */)
{
	if (m_bUserCanceled)
	{
		InformUserCancel();
		return CMD_Canceled;
	}

	CMD cmd = CMD_Complete;

	if (m_fBatchCmdLines != fBatch)
	{
		m_fBatchCmdLines = fBatch;	// set-it

		if (!fBatch)	// turning off batching?
			cmd = FlushCmdLines();
	}

	return cmd;
}

STDMETHODIMP CDynamicBuildEngine::ExecuteCommandLines(IVCCommandLineList* pCmds, BSTR bstrDir, VARIANT_BOOL fCheckForComSpec, 
	VARIANT_BOOL fIgnoreErrors, IVCBuildErrorContext* pEC, CMD* pCmdRet)
{
	CHECK_POINTER_NULL(pCmdRet);
	CStringW strDir = bstrDir;
	if (m_bUserCanceled)
	{
		*pCmdRet = CMD_Canceled;
		InformUserCancel();
	}
	else
		*pCmdRet = ExecuteCmdLines(pCmds, strDir, (fCheckForComSpec == VARIANT_TRUE), (fIgnoreErrors == VARIANT_TRUE), pEC);
	switch (*pCmdRet)
	{
	case CMD_Complete:
		return S_OK;
	case CMD_Canceled:
		return S_FALSE;
	default:
		return CVCProjectEngine::DoSetErrorInfo(VCPROJ_E_BUILD_FAILED, IDS_ERR_BUILD_FAILED);
	}
}

CMD CDynamicBuildEngine::ExecuteCmdLines(IVCCommandLineList* pCmds, CStringW& rstrDir, BOOL fCheckForComSpec, 
	BOOL fIgnoreErrors, IVCBuildErrorContext* pEC)
{
	CMD cmd = CMD_Complete;
	CDirW dir;
	dir.CreateFromKnown(rstrDir);

	if (m_fBatchCmdLines)	// batching?
	{
		BOOL fRememberContext = FALSE;

		// need to flush current if context changed?
		long cCmds;
		pCmds->get_Count(&cCmds);
		if (cCmds > 0)
		{
			if (dir != m_dirLast || fCheckForComSpec != m_fLastCheckForComSpec ||
				fIgnoreErrors != m_fLastIgnoreErrors || pEC != m_pECLast)
			{
				cmd = FlushCmdLines();		// flush our currently batched commands
				fRememberContext = TRUE;	// remember this new context
			}
		}
		else
			fRememberContext = TRUE;	// initialise the context

		// remember the last context?
		if (fRememberContext)
		{
			m_dirLast = dir;
			m_fLastCheckForComSpec = fCheckForComSpec;
			m_fLastIgnoreErrors = fIgnoreErrors;
			m_pECLast = pEC;
		}

		// perform batch
		m_spCmds->AddList(pCmds, FALSE);

		// done
	}
	else
	{
		// perform build commands
		cmd = ExecuteCmdLinesI(pCmds, dir, fCheckForComSpec, fIgnoreErrors, pEC);
	}

	// Make sure cmd is set to a valid value.
	VSASSERT(cmd == CMD_Canceled || cmd == CMD_Complete || cmd == CMD_Error, "ExecuteCmdLines setting cmd to invalid value");

	return cmd;
}

CMD CDynamicBuildEngine::ExecuteCmdLinesI(IVCCommandLineList* pCmds, CDirW& dir, BOOL fCheckForComSpec, BOOL fIgnoreErrors,
	IVCBuildErrorContext* pEC)
{
	// perform the command
	int ret = m_Spawner.DoSpawn(pCmds, dir, this, m_pCfgRecord, fCheckForComSpec, fIgnoreErrors, pEC);

	// The return value we've got now is  actually an int error code returned 
	// by NTSPAWN.  Translate it to one of our CMD_ values.
	if (ret != 0) 
	{
		if (CMD_Canceled == (UINT)ret)
			return CMD_Canceled;
		else
			return CMD_Error;
	}

	return CMD_Complete;
}

STDMETHODIMP CDynamicBuildEngine::InitializeForBuild()
{
	// logging defaults
	m_pLogFile = NULL;
	m_cReuseLogFile = 0;
	m_bFirstUsage = TRUE;
	m_logCurrentSection = eLogNoSection;

	m_actualErrs = 0;
	m_warns = 0;
	m_bDoIdleAndPump = FALSE;
	m_bUserCanceled = FALSE;
	m_bUserInformedAboutCancel = FALSE;
	m_pCfgRecord = NULL;

	// batching is off by default
	m_fBatchCmdLines = FALSE;
	return S_OK;
}

STDMETHODIMP CDynamicBuildEngine::get_LogFile( BSTR *bstrLogFile )
{
	CComBSTR bstrRet( m_strLogFile );
	*bstrLogFile = bstrRet.Detach();
	return S_OK;
}

STDMETHODIMP CDynamicBuildEngine::AddMissingEnvironmentVariable(BSTR bstrMissingVar)
{
	CStringW strMissingVar = bstrMissingVar;
	if (strMissingVar.IsEmpty())
		return S_FALSE;

	CStringW strMissingVarNoCase = strMissingVar;
	strMissingVarNoCase.MakeLower();
	void* pDummy;
	if (m_mapMissingEnvVarsNoCase.Lookup(strMissingVarNoCase, pDummy))
		return S_OK;
	
	// add a warning count for each unique missing env var
	m_warns++;

	m_mapMissingEnvVars.SetAt(strMissingVar, NULL);
	m_mapMissingEnvVarsNoCase.SetAt(strMissingVarNoCase, NULL);
	return S_OK;
}

STDMETHODIMP CDynamicBuildEngine::ClearPendingEnvironmentVariableWarnings()
{
	CComPtr<IVCBuildErrorContext> spEC;
	get_ErrorContext(&spEC);

	if (spEC)
	{
		VCPOSITION pos = m_mapMissingEnvVars.GetStartPosition();
		if (pos)
		{
			CStringW strVar, strVar2;
			void *dummy;
			strVar.LoadString(IDS_MISSING_ENV_VAR_PRJ0018);
			while (pos)
			{
				m_mapMissingEnvVars.GetNextAssoc(pos, strVar2, dummy);
				strVar2 = L"\n$(" + strVar2 + L")";
				strVar += strVar2;
			}

			// dump the missing environment variables to the output window and task list
			CVCProjectEngine::AddProjectWarning(spEC, strVar, L"PRJ0018", m_pCfgRecord);
		}
	}

	m_mapMissingEnvVars.RemoveAll();
	m_mapMissingEnvVarsNoCase.RemoveAll();
	m_mapOutputDirs.RemoveAll();
	return S_OK;
}

STDMETHODIMP CDynamicBuildEngine::AddToOutputDirectoryList(BSTR bstrDir)
{
	CStringW strDir = bstrDir;
	if (strDir.IsEmpty())
		return E_UNEXPECTED;

	void *pDummy = NULL;
	if (m_mapOutputDirs.Lookup(strDir, pDummy))
		return S_FALSE;		// already present

	m_mapOutputDirs.SetAt(strDir, pDummy);
	return S_OK;
}

#define MAX_CMD_LEN 2
// REVIEW: #define MAX_CMD_LEN 127

BOOL CDynamicBuildEngine::FormCmdLine(CStringW& strToolExeName, CStringW& strCmdLine, IVCBuildErrorContext* pEC, 
	BOOL fRspFileOk, BOOL fLogCommand)
{
	// is this line too long?
	if (strCmdLine.GetLength() + strToolExeName.GetLength() + 2 > MAX_CMD_LEN - 1)
	{
		CPathW pathRsp;
		if (!fRspFileOk)
			return FALSE;

		// need to pull /nologo out and stick it *outside* the response file.  This is 'cause MIDL is stupid and puts
		// out its banner *before* reading the response file and then won't live with us also specifying /nologo inside
		// the response file as well as on the command line.  Ugh.
		int nLoc = strCmdLine.Find(L"/nologo");
		if (nLoc >= 0)
		{
			CStringW strLeft = strCmdLine.Left(nLoc);
			int nLen = strCmdLine.GetLength();
			CStringW strRight = strCmdLine.Right(nLen-nLoc-7);
			strLeft.TrimRight();
			strRight.TrimLeft();
			if (strLeft.IsEmpty())
				strCmdLine = strRight;
			else if (strRight.IsEmpty())
				strCmdLine = strLeft;
			else
			{
				strCmdLine = strLeft + L" ";
				strCmdLine += strRight;
			}
		}
		if (!TmpMaker.CreateTempFileFromString(strCmdLine, pathRsp, this, pEC, m_pCfgRecord)) 
			return FALSE;

		// quote response file path if necessary
		CStringW strRspPath = pathRsp;
		if (pathRsp.ContainsSpecialCharacters())
			strRspPath = L'\"' + strRspPath + L'\"';

		// use response file
		strCmdLine = (strToolExeName + L" @") + strRspPath;
		if (nLoc >= 0)
			strCmdLine += L" /nologo";
	}
	else
	{
		// don't use response file

		// replace '\r\n\t' with spaces
		int cchLen = strCmdLine.GetLength();
		wchar_t * pch = (wchar_t *)(const wchar_t *)strCmdLine;
		for (int ich = 0; ich < cchLen;)
		{
			wchar_t ch = pch[ich];
			if (ch == L'\r' || ch == L'\n' || ch == L'\t')
				pch[ich] = L' ';

			ich += lstrlenW(pch + ich);
		}

		strCmdLine = (strToolExeName + L' ') + strCmdLine;
	}

	if (fLogCommand)
	{
		CStringW strCommand;
		strCommand.Format(IDS_CREATING_COMMANDLINE, strCmdLine);
		LogTrace(eLogCommand, (const wchar_t *)strCommand);
	}

	return TRUE;	// success
}

BOOL CDynamicBuildEngine::FormBatchFile(CStringW& strCmdLine, IVCBuildErrorContext* pEC)
{
	// start out by stripping any /r characters as Win9X doesn't like these
	CStringW strLine = strCmdLine;
	strCmdLine.Empty();
	int nLen = strLine.GetLength();
	for (int idx = 0; idx < nLen; idx++)
	{
		if (strLine[idx] != L'\r')
			strCmdLine += strLine[idx];
	}

	CPathW pathRsp;
	if (!TmpMaker.CreateTempFileFromString(strCmdLine, pathRsp, this, pEC, m_pCfgRecord, FILE_BATCH))
		return FALSE;

	// use response file
	strCmdLine = pathRsp;

	// quote path if necessary
	if (pathRsp.ContainsSpecialCharacters())
		strCmdLine = L'\"' + strCmdLine + L'\"';

	CStringW strCommand;
	strCommand.Format(IDS_CREATING_COMMANDLINE, strCmdLine); 
	LogTrace(eLogCommand, strCommand);

	return TRUE;	// success
}

BOOL CDynamicBuildEngine::FormTempFile(CStringW& strCmdLine, CStringW& strCommentLine)
{
	CPathW pathRsp;
	if (!TmpMaker.CreateTempFileFromString(strCmdLine, pathRsp, this, m_spBuildErrorContext, m_pCfgRecord, FILE_TEMP))
		return FALSE;

	// use response file
	strCmdLine = pathRsp;

	// quote path if necessary
	if (pathRsp.ContainsSpecialCharacters())
		strCmdLine = L'\"' + strCmdLine + L'\"';

	CStringW strCommand;
	if (strCommentLine.IsEmpty())
		strCommand.Format(IDS_CREATING_COMMANDLINE, strCmdLine); 
	else
	{
		if (strCommentLine.Find(L"%s") >= 0)
			strCommand.Format(strCommentLine, strCmdLine);
		else
		{
			strCommand = strCommentLine;
			strCommand += strCmdLine;
		}
		if (strCommand[strCommand.GetLength()-1] != L'\n')
			strCommand += L"\n";
	}
	LogTrace(eLogCommand, strCommand);

	return TRUE;	// success
}

BOOL CDynamicBuildEngine::FormXMLCommand(CStringW& strCmdLine, CStringW& strExe, CStringW& strExtraArgs)
{
	CPathW pathRsp;
	if (!TmpMaker.CreateTempFileFromString(strCmdLine, pathRsp, this, m_spBuildErrorContext, m_pCfgRecord, FILE_XML))
		return FALSE;

	// use response file
	CStringW strRsp = pathRsp;

	// quote path if necessary
	if (pathRsp.ContainsSpecialCharacters())
		strRsp = L'\"' + strRsp + L'\"';

	strCmdLine = strExe + L" ";
	if (!strExtraArgs.IsEmpty())
		strCmdLine += strExtraArgs + L" ";
	strCmdLine += strRsp;
	
	CStringW strCommand;
	strCommand.Format(IDS_CREATING_COMMANDLINE, strCmdLine); 
	LogTrace(eLogCommand, strCommand);

	return TRUE;	// success
}


STDMETHODIMP CDynamicBuildEngine::HasBuildState(void* pcrBuild, IVCBuildErrorContext* pEC, VARIANT_BOOL* pbUpToDate)
{
	CHECK_POINTER_NULL(pbUpToDate);
	*pbUpToDate = VARIANT_TRUE;

	CBldCfgRecord* pcrCheck = (CBldCfgRecord*)pcrBuild;
	// get our build dependency graph for this config.
	CBldFileDepGraph* pdepgraph = g_StaticBuildEngine.GetDepGraph(pcrCheck);
	RETURN_ON_NULL(pdepgraph);

	// use a different action marker than the last time we did a build
	CBldAction::m_wActionMarker++;

	// equivalent to 'CEnvironmentVariableList' of yore
	VCConfiguration* pConfig = pcrCheck->GetVCConfiguration();

    CComPtr<IDispatch>			spDisp;
	pConfig->get_Platform(&spDisp);
   	CComQIPtr<VCPlatform>	spPlatform = spDisp;
	CEnvironmentKeeper envMangler(spPlatform);

	// retrieve our actions
	CBldActionListHolder lstActions;
	UINT aor = AOR_Recurse | AOR_ChkOpts | AOR_PreChk | AOR_ChkInp;
	CVCPtrList lstFrh;
#ifdef	DIANEME_DEP_CHECK_DIAGNOSTICS
	ATLTRACE("Starting post-build RetrieveBuildActions for build #%d\n", s_nCurrentBuild);
#endif	// DIANEME_DEP_CHECK_DIAGNOSTICS
	CMD cmdRetRA = pdepgraph->RetrieveBuildActions(pcrCheck, lstActions.m_pActions, lstFrh, pEC, this, NULL, DS_OutOfDate, aor, 
		TRUE /* not clean */);
#ifdef	DIANEME_DEP_CHECK_DIAGNOSTICS
	ATLTRACE("Finishing post-build RetrieveBuildActions for build #%d\n", s_nCurrentBuild);
#endif	// DIANEME_DEP_CHECK_DIAGNOSTICS
	if (cmdRetRA != CMD_Complete)
	{
		// cannot retrieve actions because of error or user cancel
		lstActions.m_pActions->Clear();
		*pbUpToDate = VARIANT_FALSE;
	}
	else
		*pbUpToDate = lstActions.m_pActions->NotEmpty() ? VARIANT_FALSE : VARIANT_TRUE;

	return S_OK;
}


STDMETHODIMP CDynamicBuildEngine::DoBuild(void* pcrBuild, BOOL bIsProjectBuild, IVCBuildErrorContext* pEC, 
	void* frhStart, bldAttributes aob, bldActionTypes type, BOOL fRecurse, IVCBuildAction* pAction, BuildResults* pbrResults)
{
	CHECK_POINTER_NULL(pbrResults);
	*pbrResults = DoBuild((CBldCfgRecord*)pcrBuild, bIsProjectBuild, pEC, (BldFileRegHandle)frhStart, aob, type, fRecurse, pAction);

	switch (*pbrResults)
	{
	case BuildComplete:
	case NoBuild:
		return S_OK;
	case BuildCanceled:
		return S_FALSE;
//	case BuildError:
	default:
		return CVCProjectEngine::DoSetErrorInfo(VCPROJ_E_BUILD_FAILED, IDS_ERR_BUILD_FAILED);
	}
}

BuildResults CDynamicBuildEngine::DoBuild(CBldCfgRecord* pcrBuild, BOOL bIsProjectBuild, IVCBuildErrorContext* pEC,
	BldFileRegHandle frhStart /* = (BldFileRegHandle)NULL*/, bldAttributes aob /* = AOB_Default */,
	bldActionTypes type /* = TOB_Build */, BOOL fRecurse /* = TRUE */, IVCBuildAction* pEventAction /* = NULL */)
{
	if (m_bUserCanceled)
	{
		InformUserCancel();
		return BuildCanceled;
	}

	m_pCfgRecord = pcrBuild;	// cache this off in case of error handling later

	// get our build dependency graph and registry for this config.
	CBldFileDepGraph * pdepgraph = g_StaticBuildEngine.GetDepGraph(pcrBuild);

	// these are the pleasant formatting strings for the HTML page
	CStringW strPreHeader;
    strPreHeader.LoadString(IDS_HTML_PRE_HEADER);
	CStringW strPostHeader;
    strPostHeader.LoadString(IDS_HTML_POST_HEADER);

	// equivalent to 'CEnvironmentVariableList' of yore
	VCConfiguration* pConfig = pcrBuild->GetVCConfiguration();

    CComPtr<IDispatch>			spDisp;
	pConfig->get_Platform(&spDisp);
   	CComQIPtr<VCPlatform>	spPlatform = spDisp;

	CEnvironmentKeeper envMangler(spPlatform);

	// what dependencies do we want to build?
	UINT stateFilter = DS_OutOfDate | DS_ForcedOutOfDate;

	/// if we're re-building or forcing a build then build 'everything'
	if (type == TOB_Clean || type == TOB_ReBuild || (aob & AOB_Forced))
		stateFilter |= (DS_Current | DS_DepMissing);

	// return value of the build
	// default is 'complete', assuming finish build passes without 'cancel' or 'error'
 	BuildResults bldResults = BuildComplete;
	CMD cmdRet = CMD_Complete;

	// start the passes
	pdepgraph->StartPasses();

//
// perform the build pass
//
	// let the build log know what the environment space looks like
	CStringW strEnvTemp;
	strEnvTemp.LoadString(IDS_HTML_ENVIRONMENT);
	CStringW strEnvLines = strPreHeader + strEnvTemp + strPostHeader;
	LogTrace((eLogSectionTypes)(eLogEnvironment|eLogStartSection), strEnvLines);
	SetCurrentLogSection(eLogEnvironment);	// this forces the line we just added above to be BEFORE anything else we've been saving up for the section
		
	/* Block */ {
		wchar_t *pcStart = (wchar_t*)GetEnvironmentStringsW();
		wchar_t * pc = pcStart;
		while (*pc != 0) 
		{
			if (*pc && *pc != L'=')
			{
				CStringW strTemp = pc;
				strEnvTemp = L"    " + strTemp;
				strEnvTemp += L"\n";
				LogTrace(eLogEnvironment, strEnvTemp);
			}
			pc += wcslen( pc );
			pc++;	// gets past the NULL?
		}
		FreeEnvironmentStringsW(pcStart);
	}

	// Actions attempted in TOB_Stage.
	CBldActionListHolder lstStagedActions;

	CStringW strCommandLinesTemp;
	strCommandLinesTemp.LoadString(IDS_HTML_COMMANDLINE);
	CStringW strCommandLines = strPreHeader + strCommandLinesTemp + strPostHeader;
	    
	LogTrace((eLogSectionTypes)(eLogCommand|eLogStartSection), strCommandLines);
	SetCurrentLogSection(eLogCommand);	// this forces the line we just added above to be BEFORE anything else we've been saving up for the section

	if (type == TOB_Clean || type == TOB_ReBuild)
		DoWildCardCleanup(pConfig, type, pEC);	// wildcard cleanup if we're here; do before any other build action retrieval

	if (m_bUserCanceled)
	{
		InformUserCancel();
		return BuildCanceled;
	}

	// state filter should get everything on a rebuild all.
	// so there is no need to lookup file changes or Deps.

	//
	// retrieve our actions (prepend with our retry actions)
	//
	CBldActionListHolder lstActions;
	UINT aor = fRecurse ? AOR_Recurse : AOR_None;

	// check option changes and input changes on first pass
	aor |= (AOR_ChkOpts | AOR_ChkInp);

	CVCPtrList lstFrh;
	UINT cNonDeferred = 0;
	
//	StartCAP();
	CMD cmdRetRA = CMD_Complete;
	if (IsBuildEvent(type))	// single element build event build
	{
		if (pEventAction != NULL)
			lstActions.m_pActions->Add(pEventAction);
		cmdRetRA = CMD_Complete;
	}
	else if (type == TOB_Link)
	{
		if (pEventAction != NULL)
			lstActions.m_pActions->Add(pEventAction);
		cmdRetRA = CMD_Complete;
	}
	else	// normal build
	{
#ifdef	DIANEME_DEP_CHECK_DIAGNOSTICS
		s_nCurrentBuild++;
		ATLTRACE("Just before RetrieveBuildActions for build #%d\n", s_nCurrentBuild);
#endif	// DIANEME_DEP_CHECK_DIAGNOSTICS
		cmdRetRA = pdepgraph->RetrieveBuildActions(pcrBuild, lstActions.m_pActions, lstFrh, pEC, this, frhStart, stateFilter, aor, 
			type != TOB_Clean);
#ifdef	DIANEME_DEP_CHECK_DIAGNOSTICS
		ATLTRACE("Just after RetrieveBuildActions for build #%d\n", s_nCurrentBuild);
#endif	// DIANEME_DEP_CHECK_DIAGNOSTICS
	}
//	SuspendCAP();

	if (m_bUserCanceled)
	{
		cmdRet = CMD_Canceled;
		InformUserCancel();
		goto EndBuildPass;
	}

	ConfigurationTypes cfgType;
	pConfig->get_ConfigurationType( &cfgType );
	if (((cmdRetRA != CMD_Complete) || !lstActions.m_pActions->NotEmpty()) && cfgType != typeGeneric && cfgType != typeUnknown )
	{
		// cannot retrieve actions because of error, lack of things to to do or user cancel
		if (cmdRetRA == CMD_Complete)
			bldResults = NoBuild;
		else
			bldResults = ConvertFromCMDToBuildResults(cmdRetRA);
		goto EndBuildPass;
	}

	UINT iCodePage = GetCodePage(); // We are going to build: Init the Console codepage
	
	// time to start hunting for any build events
	// don't care about them if we're here on a build of an individual item
	if (fRecurse && !IsBuildEvent(type) && bIsProjectBuild)
	{
		VCConfiguration* pProjCfg = pcrBuild->GetVCConfiguration();
		CComQIPtr<IVCBuildableItem> spBuildableItem = pProjCfg;
		CComPtr<IVCBuildActionList> spBuildActions;
		if (spBuildableItem && SUCCEEDED(spBuildableItem->get_ActionList(&spBuildActions)) && spBuildActions)
		{
			AddBuildEventTool(spBuildActions, szPreBuildEventToolShortName, lstActions);
			AddBuildEventTool(spBuildActions, szPostBuildEventToolShortName, lstActions);

			CComPtr<IVCBuildAction> spLinkAction;
			if (lstActions.m_pActions->FindByName(szLinkerToolShortName, &spLinkAction) == S_OK ||
				lstActions.m_pActions->FindByName(szLibrarianToolShortName, &spLinkAction) == S_OK)
			{
				AddBuildEventTool(spBuildActions, szPreLinkEventToolShortName, lstActions);
				AddBuildEventTool(spBuildActions, szDeployToolShortName, lstActions);
				AddBuildEventTool(spBuildActions, szXboxImageToolShortName, lstActions);
			}
			// Run Xbox deploy tool whenever Xbox image tool is run
			CComPtr<IVCBuildAction> spXboxImageAction;
			if (lstActions.m_pActions->FindByName(szXboxImageToolShortName, &spXboxImageAction) == S_OK)
			{
				AddBuildEventTool(spBuildActions, szXboxDeployToolShortName, lstActions);
			}
		}
	}

	if( cfgType == typeGeneric || cfgType == typeUnknown )
	{
		VCConfiguration* pProjCfg = pcrBuild->GetVCConfiguration();
		CComQIPtr<IVCBuildableItem> spBuildableItem = pProjCfg;
		CComPtr<IVCBuildActionList> spBuildActions;
		if (spBuildableItem && SUCCEEDED(spBuildableItem->get_ActionList(&spBuildActions)) && spBuildActions)
		{
			AddNMakeTool( spBuildActions, lstActions);
		}

		if (!lstActions.m_pActions->NotEmpty())
		{
			bldResults = NoBuild;
			goto EndBuildPass;
		}
	}

	if (m_bUserCanceled)
	{
		cmdRet = CMD_Canceled;
		InformUserCancel();
		goto EndBuildPass;
	}
	//
	// post-process our actions
	//
	{
		// post-process stage 1.

		// put all actions in their positional buckets
		#define MAX_TOOL_BUCKET BUCKET_MAXIMUM + 1
		CVCPtrList bucket[MAX_TOOL_BUCKET];
		VCPOSITION pos = lstActions.m_pActions->GetStart();
		while (pos != (VCPOSITION)NULL)
		{
			CBldAction* pAction = lstActions.m_pActions->Next(pos);
			CBldToolWrapper* pToolWrapper = pAction->BuildToolWrapper();
			if (pToolWrapper)
			{
				int nOrder = pToolWrapper->GetOrder();
				if (nOrder == BUCKET_CUSTOMBUILD) 
				{
					if (pAction->IsProject())	// config level, not file level
						bucket[BUCKET_POSTBUILD].AddTail(pAction);
					else
						bucket[BUCKET_CUSTOMBUILD].AddTail(pAction);
				}
				else
					bucket[nOrder].AddTail(pAction);
			}
		}

		// now clear the original list and join all the separate lists together.
		lstActions.m_pActions->Clear(FALSE);
		for (int i = (MAX_TOOL_BUCKET-1); i >= 0; i--)
			lstActions.m_pActions->AddToEnd(&(bucket[i]), FALSE);
	}
	
	//
	// perform the actions for each of our stages
	//

	// if we're logging performance stats
	DWORD endTime;
	VARIANT_BOOL bLog;
   	bLog = VARIANT_FALSE;
	g_pProjectEngine->get_PerformanceLogging( &bLog );
	if( bLog == VARIANT_TRUE )
	{
		// end time
		endTime = GetTickCount();
		fprintf( stdout, "Project Build end: %d\n", endTime );
	}
	// batch?
	// don't batch the defered ones
	if (cNonDeferred != 0)
	{
		CMD cmd = BatchCmdLines();
		VSASSERT(cmd == CMD_Complete || cmd == CMD_Canceled, "Failure during BatchCmdLines!");
		if (cmd == CMD_Canceled)
		{
			cmdRet = CMD_Canceled;
			goto EndBuildPass;
		}
	}

	{
		CBldActionListHolder lstToolActions;
		VCPOSITION pos = lstActions.m_pActions->GetStart();
		while (pos != (VCPOSITION)NULL)
		{
			// collect together our actions for the same tool
			CBldToolWrapper* pToolWrapper = (CBldToolWrapper *)NULL;
			while (pos != (VCPOSITION)NULL)
			{
				VCPOSITION posOld = pos;
				CBldAction* pAction = lstActions.m_pActions->Next(pos);

				// o can we do this action now if errors encountered?
				if (cmdRet == CMD_Error && !pAction->BuildToolWrapper()->PerformIfAble())
					// no, so ignore
					continue;

				if (pToolWrapper == (CBldToolWrapper *)NULL || pAction->BuildToolWrapper() == pToolWrapper)
				{
					if (pToolWrapper == (CBldToolWrapper *)NULL)
					{
						// init. our state
						lstToolActions.m_pActions->Clear();
						pToolWrapper = pAction->BuildToolWrapper();
					}

					// add this to the tool's list of actions
					lstToolActions.m_pActions->AddToEnd(pAction);
				}
				else
				{
					// backtrack and breakout
					pos = posOld;
					break;
				}
			}

			// any tool to perform for this stage?
			if (pToolWrapper == (CBldToolWrapper *)NULL)
				continue;

			// perform the stage of this build
			actReturnStatus actRet;
			if (m_bUserCanceled)
			{
				actRet = ACT_Canceled;
				InformUserCancel();
			}
			else
				actRet = pToolWrapper->PerformBuildActions(type, lstToolActions.m_pActions, aob, pEC, this);

			// Add lstToolActions to lstStagedActions.
			if (type != TOB_Clean)
				lstStagedActions.m_pActions->AddToEnd(lstToolActions.m_pActions);

			switch (actRet)
			{
				case ACT_Canceled:
					cmdRet = CMD_Canceled;
					// cancel whole build
					goto EndBuildPass;
					break;

				case ACT_Error:
					cmdRet = CMD_Error;
					// continue with the build passes in case any tools
					// can still 'Perform If Able' regardless of errors
					break;

				case ACT_Complete:
					// cmdRet = CMD_Complete;	// Don't set if already had an error
					break;

				default:
					VSASSERT(FALSE, "DoBuild returing invalid cmdRet value");
					break;
			}
		}
	}

	// flush batch?
	{
		CStringW strOutputWindowTemp;
		strOutputWindowTemp.LoadString(IDS_HTML_OUTPUTWINDOW);
		CStringW strOutputWindow = strPreHeader + strOutputWindowTemp + strPostHeader;

		LogTrace((eLogSectionTypes)(eLogOutput|eLogStartSection), strOutputWindow);
		SetCurrentLogSection(eLogOutput);
	}

	if (cmdRet == CMD_Complete)
		cmdRet = BatchCmdLines(FALSE);
	else
		ClearCmdLines();	// clear any still batched but not flushed cmd lines now

	if (cmdRet == CMD_Canceled)
		goto EndBuildPass;	// cancel whole build

//
// End the build passes
//
EndBuildPass:

	if (cmdRet != CMD_Complete)	// if this is CMD_Complete, bldResults should be either BuildComplete or NoBuild, set appropriately above
		bldResults = ConvertFromCMDToBuildResults(cmdRet);

	m_bUserCanceled = FALSE;				// clear out this flag if it was ever set
	m_bUserInformedAboutCancel = FALSE;		// clear out this flag if it was ever set

	// Flush anything we haven't written yet into the log file
	FlushLogSection(eLogAll);
	SetCurrentLogSection(eLogOutput);

	// Update dependencies
	if (lstStagedActions.m_pActions->NotEmpty())
	{
		// Update files.
		CBldFileRegFile::UpdateTimeStampTick();		// this makes it so we don't look up the time stamp on something multiple times
		VCPOSITION posCurrentAction = lstStagedActions.m_pActions->GetStart();
		CBldAction* pFirstAction = (CBldAction*)lstStagedActions.m_pActions->Next(posCurrentAction);
		CComPtr<VCConfiguration> spProjCfg;
		pFirstAction->get_ProjectConfiguration(&spProjCfg);
		CComQIPtr<IVCConfigurationImpl> spProjCfgImpl = spProjCfg;
		VSASSERT(spProjCfgImpl != NULL, "No configuration found to go with an action!");
		CStringW strIdb;
		if (spProjCfgImpl != NULL)
		{
			CComBSTR bstrIdb;
			HRESULT hr = spProjCfgImpl->get_MrePath(&bstrIdb);
			VSASSERT(SUCCEEDED(hr), "Failed on spProjCfgImpl->get_MrePath call!");
			strIdb = bstrIdb;
		}

		// Minimal rebuild dependency interface.
		CBldMreDependenciesContainer mreDepend(strIdb);

		// Update dependencies.
		// Set up a new cache for this target			
//		ResumeCAP();
		m_ScannerCache.BeginCache();

		posCurrentAction = lstStagedActions.m_pActions->GetStart();

		while (NULL != posCurrentAction)
		{
			CBldAction* pCurrentAction = (CBldAction*)lstStagedActions.m_pActions->Next(posCurrentAction);

			VSASSERT(NULL != pCurrentAction, "NULL pointer value in staged actions action list");

			pCurrentAction->UpdateDepInfo(pEC);
		}

		m_ScannerCache.EndCache();
//		StopCAP();
	}

	// clear any still batched but not flushed cmd lines now
	ClearCmdLines();

	// nuke any temporary files created as a part of this build
	NukeTempFiles(pEC);

	// let go of any pretense of knowing about the cfg record anymore
	m_pCfgRecord = NULL;

	// env is restored in EnvDaemon destructor

	return bldResults;
}

BuildResults CDynamicBuildEngine::ConvertFromCMDToBuildResults(CMD cmd)
{
	switch(cmd)
	{
	case CMD_Canceled:
		return BuildCanceled;
	case CMD_Complete:
		return BuildComplete;
	// case CMD_Error:
	default:
		return BuildError;
	}
}

// wildcard cleanup if we're here; do before any other build action retrieval
HRESULT CDynamicBuildEngine::DoWildCardCleanup(VCConfiguration* pConfig, bldActionTypes type, IVCBuildErrorContext* pEC)
{
	CHECK_READ_POINTER_NULL(pConfig);

	CComQIPtr<IVCPropertyContainer> spPropContainer = pConfig;
	RETURN_ON_NULL2(spPropContainer, S_FALSE);	// no config stuff, we're toast

	CComBSTR bstrDelExt;
	pConfig->get_DeleteExtensionsOnClean(&bstrDelExt);
	HRESULT hr = spPropContainer->Evaluate(bstrDelExt, &bstrDelExt);
	RETURN_ON_FAIL(hr);
	if (bstrDelExt.Length() == 0)	// no wild cards, so go away
		return S_FALSE;
	CStringW strDelExt = bstrDelExt;
	strDelExt.TrimLeft();
	strDelExt.TrimRight();
	if (strDelExt.IsEmpty())	// no wild cards, so go away
		return S_FALSE;

	// pick up the absolute path to the intermediate directory
	CComBSTR bstrProjDir;
	spPropContainer->GetStrProperty(VCPROJID_ProjectDirectory, &bstrProjDir);
	CStringW strProjDir = bstrProjDir;
	strProjDir.TrimLeft();
	if (strProjDir.IsEmpty())
		return CVCProjectEngine::DoSetErrorInfo(VCPROJ_E_INTERNAL_ERR, IDS_ERR_INTERNAL_ERROR);

	CDirW dirProj;
	if (!dirProj.CreateFromKnown(strProjDir))
		return CVCProjectEngine::DoSetErrorInfo(VCPROJ_E_INTERNAL_ERR, IDS_ERR_INTERNAL_ERROR);

	CComBSTR bstrIntDir;
	pConfig->get_IntermediateDirectory(&bstrIntDir);
	CStringW strIntDir = bstrIntDir;
	CPathW pathIntDir;
	if (!pathIntDir.CreateFromDirAndFilename(dirProj, strIntDir))
		return CVCProjectEngine::DoSetErrorInfo(VCPROJ_E_INTERNAL_ERR, IDS_ERR_INTERNAL_ERROR);
	CDirW dirIntDir;
	if (!dirIntDir.CreateFromPath(pathIntDir, TRUE))
		return CVCProjectEngine::DoSetErrorInfo(VCPROJ_E_INTERNAL_ERR, IDS_ERR_INTERNAL_ERROR);

	// now cycle through the wild card sets within the intermediate directory
	int nNextIdx = 0;
	int nMaxIdx = strDelExt.GetLength();
	CStringW strSemi = L";";
	while (nNextIdx >= 0)
	{
		CStringW strWild;
		nNextIdx = g_StaticBuildEngine.GetNextItem(strDelExt, nNextIdx, nMaxIdx, strSemi, strWild);
		strWild.TrimLeft();
		if (strWild.IsEmpty())
			continue;
		CPathW pathWild;
		if (!pathWild.CreateFromDirAndFilename(dirIntDir, strWild))
			continue;
		WIN32_FIND_DATAW findWildData;
		HANDLE hFindWild = ::FindFirstFileW((LPCOLESTR)pathWild, &findWildData);
		if (hFindWild == INVALID_HANDLE_VALUE)
			continue;	// problem with FindFirstFileW

		DeleteOneFile(findWildData, strWild, dirIntDir, pEC, pConfig);	// delete the first file in the list

		WIN32_FIND_DATAW findWild;
		while (::FindNextFileW(hFindWild, &findWild))
			DeleteOneFile(findWild, strWild, dirIntDir, pEC, pConfig);
		::FindClose(hFindWild);

		if (m_bUserCanceled)
		{
			InformUserCancel();
			break;
		}
	}

	return S_OK;
}

void CDynamicBuildEngine::DeleteOneFile(WIN32_FIND_DATAW& findWild, CStringW& strWild, CDirW& dirIntDir, IVCBuildErrorContext* pEC,
	VCConfiguration* pConfig)
{
	if (findWild.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
		return;	// not deleting sub-directories

	CStringW strFile = findWild.cFileName;
	if (_wcsicmp(strFile, L"BuildLog.htm") == 0 && _wcsicmp(strWild, strFile) != 0)	// leave the build log there unless explicitly removing it...
		return;

	CPathW pathFile;
	if (!pathFile.CreateFromDirAndFilename(dirIntDir, strFile))
		return;
	BldFileRegHandle frh = CBldFileRegFile::GetFileHandle(pathFile, TRUE);
	if (frh == NULL)
		return;

	g_StaticBuildEngine.DeleteFile(frh, pEC, pConfig, NULL);	// don't care about return code...
	frh->ReleaseFRHRef();
}

void CDynamicBuildEngine::AddBuildEventTool(IVCBuildActionList* pBuildActions, LPOLESTR szBuildEventToolShortName, 
	CBldActionListHolder& lstActions)
{
	CComPtr<IVCBuildAction> spEventAction;
	if (pBuildActions->FindByName(szBuildEventToolShortName, &spEventAction) == S_OK)
	{
		CComPtr<IVCToolImpl> spToolImpl;
		if (SUCCEEDED(spEventAction->get_VCToolImpl(&spToolImpl)) && spToolImpl != NULL)
		{
			CComQIPtr<IVCBuildEventToolInternal> spEventTool = spToolImpl;
			if (spEventTool != NULL)
			{
				VARIANT_BOOL bExcluded = VARIANT_FALSE;
				if (FAILED(spEventTool->get_ExcludedFromBuildInternal(&bExcluded)) || bExcluded == VARIANT_FALSE)
				{
					CComBSTR bstrCommand;
					if (spEventTool->get_CommandLineInternal(&bstrCommand) == S_OK && bstrCommand.Length() > 0)
					{
						CBldAction* pAction = NULL;
						spEventAction->get_ThisPointer((void **)&pAction);
						lstActions.m_pActions->AddToEnd(pAction);
					}
				}
			}
		}
	}
}

void CDynamicBuildEngine::AddNMakeTool(IVCBuildActionList* pBuildActions, CBldActionListHolder& lstActions)
{
	CComPtr<IVCBuildAction> spEventAction;
	if (pBuildActions->FindByName(szNMakeToolShortName, &spEventAction) == S_OK)
	{
		CComPtr<IVCToolImpl> spToolImpl;
		if (SUCCEEDED(spEventAction->get_VCToolImpl(&spToolImpl)) && spToolImpl != NULL)
		{
			CBldAction* pAction = NULL;
			spEventAction->get_ThisPointer((void **)&pAction);
			lstActions.m_pActions->Add(pAction);
		}
	}
}

STDMETHODIMP CDynamicBuildEngine::get_ScannerCache(void** ppScannerCache)
{
	CHECK_POINTER_NULL(ppScannerCache);
	*ppScannerCache = (void *)&m_ScannerCache;
	return S_OK;
}
STDMETHODIMP CDynamicBuildEngine::get_ReuseLogFile(VARIANT_BOOL* pbReuse)
{
	CHECK_POINTER_NULL(pbReuse);
	if (m_bReuseLogFile)
		*pbReuse = VARIANT_TRUE;
	else
		*pbReuse = VARIANT_FALSE;
	return S_OK;
}

STDMETHODIMP CDynamicBuildEngine::put_ReuseLogFile(VARIANT_BOOL bReuse)
{
	if (bReuse == VARIANT_TRUE)
		m_cReuseLogFile++;
	else if (m_cReuseLogFile > 0)
		m_cReuseLogFile--;
	if (m_cReuseLogFile == 0)	// all usages are the first one if we're not doing reuse...
		m_bFirstUsage = TRUE;
	return S_OK;
}

HRESULT CDynamicBuildEngine::CreateInstance(IVCBuildEngine** ppEngine)
{
	CHECK_POINTER_NULL(ppEngine);
	*ppEngine = NULL;

	CComObject<CDynamicBuildEngine> *pObj;
	HRESULT hr = CComObject<CDynamicBuildEngine>::CreateInstance(&pObj);
	if (SUCCEEDED(hr))
	{
		CDynamicBuildEngine *pVar = pObj;
		pVar->AddRef();
		*ppEngine = pVar;
	}
	return hr;
}

STDMETHODIMP CDynamicBuildEngine::get_BuildThread(IVCBuildThread** ppThread)
{
	CHECK_POINTER_NULL(ppThread);
	return CVCBuildThread::CreateInstance(ppThread);
}

STDMETHODIMP CDynamicBuildEngine::get_ErrorContext(IVCBuildErrorContext** ppErrContext)
{
	CHECK_POINTER_NULL(ppErrContext);
	*ppErrContext = NULL;
	if (m_spBuildErrorContext)
		return m_spBuildErrorContext.CopyTo(ppErrContext);
	return S_OK;
}

STDMETHODIMP CDynamicBuildEngine::put_ErrorContext(IVCBuildErrorContext* pErrContext)
{
	m_spBuildErrorContext = pErrContext;
	return S_OK;
}

STDMETHODIMP CDynamicBuildEngine::get_DoIdleAndPump(BOOL* pbDoIdleAndPump)
{ 
	CHECK_POINTER_NULL(pbDoIdleAndPump);
	*pbDoIdleAndPump = m_bDoIdleAndPump; 
	return S_OK;
}

STDMETHODIMP CDynamicBuildEngine::put_DoIdleAndPump(BOOL bIdleAndPump)
{ 
	m_bDoIdleAndPump = bIdleAndPump; 
	return S_OK;
}
	
STDMETHODIMP CDynamicBuildEngine::get_SpawnerActive(VARIANT_BOOL* pbSpawnerActive)
{
	CHECK_POINTER_NULL(pbSpawnerActive);
	*pbSpawnerActive = m_Spawner.SpawnActive() ? VARIANT_TRUE : VARIANT_FALSE;
	return S_OK;
}

STDMETHODIMP CDynamicBuildEngine::get_CanSpawnBuild(VARIANT_BOOL* pbCanSpawn)
{
	CHECK_POINTER_NULL(pbCanSpawn);
	*pbCanSpawn = m_Spawner.CanSpawn() ? VARIANT_TRUE : VARIANT_FALSE;
	return S_OK;
}

STDMETHODIMP CDynamicBuildEngine::InitializeSpawner(BOOL bHidden)
{
	return m_Spawner.InitSpawn(bHidden);
}

STDMETHODIMP CDynamicBuildEngine::TerminateSpawner()
{
	m_Spawner.TermSpawn();
	return S_OK;
}

STDMETHODIMP CDynamicBuildEngine::SpawnBuild(IVCCommandLineList* pCmds, LPCOLESTR szDir, BOOL fCheckForComspec, BOOL fIgnoreErrors, 
	IVCBuildErrorContext* pEC, BOOL fAsyncSpawn, long* nRetVal)
{
	CHECK_POINTER_NULL(nRetVal);
	CDirW dirStart;
	if (!dirStart.CreateFromKnown(szDir))
		return CVCProjectEngine::DoSetErrorInfo(VCPROJ_E_INTERNAL_ERR, IDS_ERR_INTERNAL_ERROR);

	if (m_bUserCanceled)
	{
		*nRetVal = -2;
		InformUserCancel();
	}
	else
		*nRetVal = m_Spawner.DoSpawn(pCmds, dirStart, this, NULL, fCheckForComspec, fIgnoreErrors, pEC, fAsyncSpawn);
	return S_OK;
}

STDMETHODIMP CDynamicBuildEngine::get_UserStoppedBuild(VARIANT_BOOL *pVal)
{
	CHECK_POINTER_NULL(pVal);
	*pVal = m_Spawner.UserStoppedBuild() ? VARIANT_TRUE : VARIANT_FALSE;
	return S_OK;
}

STDMETHODIMP CDynamicBuildEngine::get_HaveLogging(VARIANT_BOOL *pVal)
{
	CHECK_POINTER_NULL(pVal);
	*pVal = HaveLogging() ? VARIANT_TRUE : VARIANT_FALSE;
	return S_OK;
}

STDMETHODIMP CDynamicBuildEngine::LogTrace(int fFlags, BSTR bstrMessage)
{
	if (!HaveLogging())
		return S_OK;	// nothing to do if not logging

	CStringW strMessage = bstrMessage;
	LogTrace((eLogSectionTypes)fFlags, strMessage);
	return S_OK;
}

STDMETHODIMP CDynamicBuildEngine::get_CurrentLogSection(eLogSectionTypes* peSection)
{
	CHECK_POINTER_NULL(peSection);
	*peSection = GetCurrentLogSection();
	return S_OK;
}

STDMETHODIMP CDynamicBuildEngine::put_CurrentLogSection(eLogSectionTypes eSection)
{
	SetCurrentLogSection(eSection);
	return S_OK;
}

STDMETHODIMP CDynamicBuildEngine::FormCommandLine(BSTR bstrToolExeName, BSTR bstrCmdLineIn, IVCBuildErrorContext* pEC,
	BOOL fRspFileOK, BOOL fLogCommand, BSTR* pbstrCmdLineOut)
{
	CHECK_POINTER_NULL(pbstrCmdLineOut);
	*pbstrCmdLineOut = NULL;

	CStringW strToolExeName = bstrToolExeName;
	CStringW strCmdLine = bstrCmdLineIn;
	BOOL fOK = FormCmdLine(strToolExeName, strCmdLine, pEC, fRspFileOK, fLogCommand);
	*pbstrCmdLineOut = strCmdLine.AllocSysString();

	if (fOK)
		return S_OK;

	return CVCProjectEngine::DoSetErrorInfo(VCPROJ_E_INTERNAL_ERR, IDS_ERR_INTERNAL_ERROR);
}

STDMETHODIMP CDynamicBuildEngine::FormBatchFile(BSTR bstrCmdLineIn, IVCBuildErrorContext* pEC, BSTR* pbstrCmdLineOut)
{
	CHECK_POINTER_NULL(pbstrCmdLineOut);
	*pbstrCmdLineOut = NULL;

	CStringW strCmdLine = bstrCmdLineIn;
	BOOL fOK = FormBatchFile(strCmdLine, pEC);
	*pbstrCmdLineOut = strCmdLine.AllocSysString();

	if (fOK)
		return S_OK;

	return CVCProjectEngine::DoSetErrorInfo(VCPROJ_E_INTERNAL_ERR, IDS_ERR_INTERNAL_ERROR);
}

STDMETHODIMP CDynamicBuildEngine::FormTempFile(BSTR bstrCmdLineIn, BSTR bstrComment, BSTR* pbstrCmdLineOut)
{
	CHECK_POINTER_NULL(pbstrCmdLineOut);
	*pbstrCmdLineOut = NULL;

	CStringW strCmdLine = bstrCmdLineIn;
	CStringW strComment = bstrComment;
	BOOL fOK = FormTempFile(strCmdLine, strComment);
	*pbstrCmdLineOut = strCmdLine.AllocSysString();

	if (fOK)
		return S_OK;

	return CVCProjectEngine::DoSetErrorInfo(VCPROJ_E_INTERNAL_ERR, IDS_ERR_INTERNAL_ERROR);
}

STDMETHODIMP CDynamicBuildEngine::FormXMLCommand(BSTR bstrCmdLineIn, BSTR bstrExe, BSTR bstrExtraArgs, BSTR* pbstrCmdLineOut)
{
	CHECK_POINTER_NULL(pbstrCmdLineOut);
	*pbstrCmdLineOut = NULL;

	CStringW strCmdLine = bstrCmdLineIn;
	CStringW strExe = bstrExe;
	CStringW strExtraArgs = bstrExtraArgs;
	BOOL fOK = FormXMLCommand(strCmdLine, strExe, strExtraArgs);
	*pbstrCmdLineOut = strCmdLine.AllocSysString();

	if (fOK)
		return S_OK;

	return CVCProjectEngine::DoSetErrorInfo(VCPROJ_E_INTERNAL_ERR, IDS_ERR_INTERNAL_ERROR);
}

STDMETHODIMP CDynamicBuildEngine::GetDeploymentDependencies(void* pcrBuild, IVCBuildStringCollection** ppDeployStrings)
{
	CHECK_POINTER_NULL(ppDeployStrings);
	RETURN_ON_NULL(pcrBuild);

	GetDeploymentDependencies((CBldCfgRecord*)pcrBuild, ppDeployStrings);
	return S_OK;
}

void CDynamicBuildEngine::GetDeploymentDependencies(CBldCfgRecord* pcrBuild, IVCBuildStringCollection** ppDeployStrings)
{
	m_pCfgRecord = pcrBuild;	// cache this off in case of error handling later

	// get our build dependency graph and registry for this config.
	CBldFileDepGraph * pdepgraph = g_StaticBuildEngine.GetDepGraph(pcrBuild);
	if (pdepgraph == NULL)
		return;

	// equivalent to 'CEnvironmentVariableList' of yore
	VCConfiguration* pConfig = pcrBuild->GetVCConfiguration();

    CComPtr<IDispatch>			spDisp;
	pConfig->get_Platform(&spDisp);
   	CComQIPtr<VCPlatform>	spPlatform = spDisp;

	CEnvironmentKeeper envMangler(spPlatform);

	// start the passes
	pdepgraph->StartPasses();

	pdepgraph->RetrieveDeploymentDependencies(pcrBuild, ppDeployStrings);

	// let go of any pretense of knowing about the cfg record anymore
	m_pCfgRecord = NULL;

	// env is restored in EnvDaemon destructor
}

UINT CDynamicBuildEngine::GetCodePage(BOOL bWantConsoleCP /* = TRUE */)
{
	if (s_iConsoleCodePage == 0)
	{
		BOOL bFoundVCSpawn = FALSE;
		CStringW strPath;
		CStringW strVCSpawnPath;
		DWORD dwLen;

		// first, try the system PATH
		dwLen = SearchPathW(NULL, L"vcspawn.exe", NULL, 0, NULL, NULL);
		if (dwLen)
		{
			SearchPathW(NULL, L"vcspawn.exe", NULL, dwLen, strVCSpawnPath.GetBuffer(dwLen+1), NULL);
			strVCSpawnPath.ReleaseBuffer();
			bFoundVCSpawn = TRUE;
		}

		if (!bFoundVCSpawn)	// hmmm.  Try Common7/Tools
		{
			UtilGetCommon7Folder(strVCSpawnPath);
			strVCSpawnPath += L"Tools\\vcspawn.exe";
			CPathW pathSpawn;
			if (pathSpawn.Create(strVCSpawnPath) && pathSpawn.ExistsOnDisk())
				bFoundVCSpawn = TRUE;
		}

		if (!bFoundVCSpawn)	// last ditch effort: try the first platform we can find
		{
			if (g_pProjectEngine)
			{
				CComPtr<IDispatch> spDispPlatforms;
				g_pProjectEngine->get_Platforms(&spDispPlatforms);
				CComQIPtr<IVCCollection> spPlatforms = spDispPlatforms;
				if (spPlatforms)
				{
					CComPtr<IDispatch> spDispPlatform;
					spPlatforms->Item(CComVariant((LONG)1), &spDispPlatform);
					CComQIPtr<VCPlatform> spPlatform = spDispPlatform;
					if (spPlatform)
					{
						CComBSTR bstrPath1, bstrPath2;
						spPlatform->get_ExecutableDirectories(&bstrPath1);
						spPlatform->Evaluate(bstrPath1, &bstrPath2);
						strPath = bstrPath2;
						if (!strPath.IsEmpty())
						{
							dwLen = SearchPathW(strPath, L"vcspawn.exe", NULL, 0, NULL, NULL);
							if (dwLen)
							{
								SearchPathW(strPath, L"vcspawn.exe", NULL, dwLen, strVCSpawnPath.GetBuffer(dwLen+1), NULL);
								strVCSpawnPath.ReleaseBuffer();
								bFoundVCSpawn = TRUE;
							}
						}
					}
				}
			}
		}

		if (!bFoundVCSpawn)		// still no luck.  pray
			strVCSpawnPath = L"vcspawn.exe";

		// Create the spawn string with the vcspawn prepended
		CStringW strSpawn;
		strSpawn.Format(L"\"%s\" -c", strVCSpawnPath);
	
		// check to see if we're allowed to run vcspawn
		
		BOOL fCreateSuccess;	// create process succeeded?
		if( !CanCreateProcess( L"vcspawn.exe" ) )
		{
			fCreateSuccess = FALSE;
		}
		else
		{
			PROCESS_INFORMATION     procInfo;
			STARTUPINFOW            startInfo;
			memset((void *)&procInfo, 0, sizeof(PROCESS_INFORMATION));
			memset((void *)&startInfo, 0, sizeof(STARTUPINFOW));
			startInfo.dwFlags = STARTF_USESHOWWINDOW;
			startInfo.wShowWindow = SW_HIDE;
			CDirW dir;
			dir.CreateFromCurrent();
			CStringW strDir = dir;
			fCreateSuccess = CreateProcessW(NULL, strSpawn.GetBuffer(strSpawn.GetLength()), NULL, NULL, TRUE,
				CREATE_NEW_CONSOLE, NULL, strDir, &startInfo, &procInfo);
			strSpawn.ReleaseBuffer();
	
			DWORD dwError = GetLastError();
			// GetLastError() returns ERROR_ACCESS_DENIED on NT German when path contains extended chars!
			if (!fCreateSuccess && (dwError == ERROR_FILE_NOT_FOUND || dwError == ERROR_ACCESS_DENIED))
			{
				// Unable to run vcspawn with explicit path, try without...
				strSpawn = L"vcspawn.exe -c";
				fCreateSuccess = CreateProcessW(NULL, strSpawn.GetBuffer(strSpawn.GetLength()), NULL, NULL, TRUE,
					CREATE_NEW_CONSOLE, NULL, strDir, &startInfo, &procInfo);
				strSpawn.ReleaseBuffer();
			}
			if (procInfo.hThread)
				CloseHandle ( procInfo.hThread );
			if( fCreateSuccess )
			{
				WaitForSingleObject ( procInfo.hProcess, INFINITE );
				DWORD dwExit = 0;
				GetExitCodeProcess ( procInfo.hProcess, &dwExit);
				s_iConsoleCodePage = dwExit;
			}
			else
			{
			    // Yikes !
			    // GetThe current system codepage I guess.
			}
			if (procInfo.hProcess)
				CloseHandle ( procInfo.hProcess );
		}
		s_iANSICodePage = CXMLFile::DetermineDefaultCodePage();
		if (s_iConsoleCodePage <= 0)
			s_iConsoleCodePage = s_iANSICodePage;
	}
	if (bWantConsoleCP)
		return s_iConsoleCodePage;
	else
		return s_iANSICodePage;
}

/////////////////////////////////////////////////////////////////////////////
// IENCBuildSpawner Methods

STDMETHODIMP CDynamicBuildEngine::StartSpawn(LPCOLESTR szCurrentDir, LPCOLESTR szCmdLine, 
	IVCBuildErrorContext *pIVCBuildErrorContext, IENCBuildSpawnerCallback *pCallback, BOOL fUseConsoleCP)
{
	BOOL fOK = m_encBldThread.Init(szCmdLine, szCurrentDir, pIVCBuildErrorContext, this, pCallback, fUseConsoleCP);

	if (fOK)
	{
		InitializeForBuild();
		fOK = m_encBldThread.FStart();
	}

	HRESULT hr = (fOK ? S_OK : E_FAIL);
	return hr;
}


STDMETHODIMP CDynamicBuildEngine::StopSpawn()
{
	return StopBuild();
}


STDMETHODIMP CDynamicBuildEngine::IsSysHeader(LPCOLESTR bstrFileName)
{
    CStringW szFileName(bstrFileName);

	if( g_SysInclReg.IsSysInclude(szFileName) )
        return S_OK;
    else
        return CVCProjectEngine::DoSetErrorInfo2(VCPROJ_E_NOT_FOUND, IDS_ERR_NOT_SYS_HEADER, bstrFileName, FALSE);
}

void CDynamicBuildEngine::InformUserCancel()
{
	if (m_bUserInformedAboutCancel)
		return;

	m_bUserInformedAboutCancel = TRUE;
	CComBSTR bstrErr;
	bstrErr.LoadString(IDS_TERMINATE_USER_REQ);
	m_spBuildErrorContext->AddInfo(bstrErr);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\vcpb\cltool.h ===
// CLCompilerTool.h: Definition of the CCLCompilerTool class
//
//////////////////////////////////////////////////////////////////////

#pragma once

#include "vctool.h"
#include "CLToolBase.h"
#include "CmdLines.h"

// classes in this header
class CVCCLCompilerTool;
class CCLCompilerToolOptionHandler;

class CCLCompilerToolOptionHandler : public COptionHandlerBase
{
public:
	CCLCompilerToolOptionHandler() : m_bNotifiedNoOptimize(FALSE) {}
	DECLARE_OPTION_TABLE();

public:
	// default value handlers
	// string props
	virtual void GetDefaultValue( long id, BSTR *bstrVal, IVCPropertyContainer *pPropCnt = NULL );
	// integer props
	virtual void GetDefaultValue( long id, long *iVal, IVCPropertyContainer *pPropCnt = NULL );
	// boolean props
	virtual void GetDefaultValue( long id, VARIANT_BOOL *bVal, IVCPropertyContainer *pPropCnt = NULL );

public:
	BOOL GetPCHName(IVCPropertyContainer* pPropContainer, BSTR* pbstrPCH, BOOL bCheckForExistence = TRUE);
	BOOL GetPCHHeaderName(IVCPropertyContainer* pPropContainer, long nID, CComBSTR& rbstrPCH, 
		BOOL bCheckForExistence = TRUE);
	CompileAsOptions GetDefaultCompileAs(IVCPropertyContainer* pPropContainer, BOOL bCheckExplicit = TRUE);
	void InitializeFlags();

protected:
	virtual BOOL SetEvenIfDefault(VARIANT *pVarDefault, long idOption);
	virtual void EvaluateSpecialEnumAtIndex(int nVal, LPCOLESTR szOption, long idOption, 
		IVCPropertyContainer* pPropContainer, BOOL bIncludeSlash, CStringW& rstrSwitch);
	virtual BOOL SynthesizeOptionIfNeeded(IVCPropertyContainer* pPropContainer, long idOption);
	virtual BOOL SynthesizeOption(IVCPropertyContainer* pPropContainer, long idOption, CComVariant& rvar);
	virtual void FormatScriptItem(const wchar_t* szOptionName, long idOption, long idOptionPage, CStringW& rstrOption);
	virtual BOOL OverrideOptionSet(IVCPropertyContainer* pPropContainer, long idOption);

private:
	BOOL m_bNotifiedNoOptimize;
};

/////////////////////////////////////////////////////////////////////////////
// CVCCLCompilerTool

class CVCCLCompilerTool : 
	public IDispatchImpl<VCCLCompilerTool, &IID_VCCLCompilerTool, &LIBID_VCProjectEngineLibrary, PublicProjBuildTypeLibNumber,0, CVsTypeInfoHolder>, 
	public CComObjectRoot,
	public CVCToolImpl
{
public:
	CVCCLCompilerTool() 
	{
		m_nLowKey = VCCLCOMPILERTOOL_MIN_DISPID;
		m_nHighKey = VCCLCOMPILERTOOL_MAX_DISPID;
		m_nDirtyKey = VCCLID_CmdLineOptionsDirty;
		m_nDirtyOutputsKey = VCCLID_OutputsDirty;
	}
	static HRESULT CreateInstance(IVCPropertyContainer* pPropContainer, IVCToolImpl** ppTool);

BEGIN_COM_MAP(CVCCLCompilerTool)
	COM_INTERFACE_ENTRY(VCCLCompilerTool)
	COM_INTERFACE_ENTRY(IVCToolImpl)
 	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE(CVCCLCompilerTool) 

// VCCLCompilerTool
public:
	// General
	STDMETHOD(get_AdditionalOptions)(BSTR* pbstrAdditionalOptions);	// anything we don't know what to do with, given verbatim, in same order as entered, parent contributions first, goes after all other options
	STDMETHOD(put_AdditionalOptions)(BSTR bstrAdditionalOptions);
	STDMETHOD(get_ToolName)(BSTR* pbstrToolName);	// friendly name of tool, e.g., "C/C++ Compiler Tool"
	STDMETHOD(get_AdditionalIncludeDirectories)(BSTR* pbstrIncludePath);	// (/I![path]) directory to add to include path, may have multiple
	STDMETHOD(put_AdditionalIncludeDirectories)(BSTR bstrIncludePath);
	STDMETHOD(get_AdditionalUsingDirectories)(BSTR* pbstrIncludePath);	// (/AI![path]) directory to add to LIBPATH path, may have multiple
	STDMETHOD(put_AdditionalUsingDirectories)(BSTR bstrIncludePath);
	STDMETHOD(get_DebugInformationFormat)(debugOption* poptSetting);	// see debugOption enum (/Z7, Zd, /ZI, /Zi)
	STDMETHOD(put_DebugInformationFormat)(debugOption optSetting);
	STDMETHOD(get_CompileAsManaged)(compileAsManagedOptions* poptSetting);	// (/clr[:noAssembly])
	STDMETHOD(put_CompileAsManaged)(compileAsManagedOptions optSetting);
	STDMETHOD(get_SuppressStartupBanner)(VARIANT_BOOL* pbNoLogo);	// (/nologo, /nologo-) enable/disable suppression of copyright message
	STDMETHOD(put_SuppressStartupBanner)(VARIANT_BOOL bNoLogo);
	STDMETHOD(get_WarningLevel)(warningLevelOption* poptSetting);	// see warningLevelOption enum (/W0 - /W4)
	STDMETHOD(put_WarningLevel)(warningLevelOption optSetting);
	STDMETHOD(get_Detect64BitPortabilityProblems)(VARIANT_BOOL* pbDetect64BitPortabilityProblems);	// (/Wp64) detect 64 bit portability problems
	STDMETHOD(put_Detect64BitPortabilityProblems)(VARIANT_BOOL bDetect64BitPortabilityProblems);
	STDMETHOD(get_WarnAsError)(VARIANT_BOOL* pbWarnAsError);	// (/WX, /WX-) treat warnings as errors
	STDMETHOD(put_WarnAsError)(VARIANT_BOOL bWarnAsError);
	// Optimization
	STDMETHOD(get_Optimization)(optimizeOption* poptSetting);	// see enum above (/O1, /O2, /Od, /Ox)
	STDMETHOD(put_Optimization)(optimizeOption optSetting);
	STDMETHOD(get_GlobalOptimizations)(VARIANT_BOOL* pbGlobalOpt);	// (/Og, /Og-) enable/disable global optimizations incompatible with all RTC options, GZ, ZI, EEf
	STDMETHOD(put_GlobalOptimizations)(VARIANT_BOOL bGlobalOpt);
	STDMETHOD(get_InlineFunctionExpansion)(inlineExpansionOption* poptSetting);	// see enum above (/Ob0, /Ob1, /Ob2)
	STDMETHOD(put_InlineFunctionExpansion)(inlineExpansionOption optSetting);
	STDMETHOD(get_EnableIntrinsicFunctions)(VARIANT_BOOL* pbEnableIntrinsic);	// (/Oi, /Oi-) enable/disable intrinsic functions works best with /Og
	STDMETHOD(put_EnableIntrinsicFunctions)(VARIANT_BOOL bEnableIntrinsic);
	STDMETHOD(get_ImproveFloatingPointConsistency)(VARIANT_BOOL* pbImproveFloat);	// (/Op, /Op-) (don't) improve floating-point consistency
	STDMETHOD(put_ImproveFloatingPointConsistency)(VARIANT_BOOL bImproveFloat);
	STDMETHOD(get_FavorSizeOrSpeed)(favorSizeOrSpeedOption* poptSetting);	// (/Os, Ot) favor size/speed works best with /Og
	STDMETHOD(put_FavorSizeOrSpeed)(favorSizeOrSpeedOption optSetting);
	STDMETHOD(get_OmitFramePointers)(VARIANT_BOOL* poptSetting);	// (/Oy, Oy-) enable/disable frame pointer omission
	STDMETHOD(put_OmitFramePointers)(VARIANT_BOOL optSetting);
	STDMETHOD(get_EnableFiberSafeOptimizations)(VARIANT_BOOL* pbFiberSafeTLS);	// (/GT) generate fiber-safe TLS accesses
	STDMETHOD(put_EnableFiberSafeOptimizations)(VARIANT_BOOL bFiberSafeTLS);
	STDMETHOD(get_WholeProgramOptimization)(VARIANT_BOOL* pbWholeProgOp);	// (/GL) Perform whole program optimization during the link phase
	STDMETHOD(put_WholeProgramOptimization)(VARIANT_BOOL bWholeProgOp);
	STDMETHOD(get_OptimizeForProcessor)(ProcessorOptimizeOption* poptSetting);
	STDMETHOD(put_OptimizeForProcessor)(ProcessorOptimizeOption optSetting);
	STDMETHOD(get_OptimizeForWindowsApplication)(VARIANT_BOOL* poptSetting);
	STDMETHOD(put_OptimizeForWindowsApplication)(VARIANT_BOOL optSetting);
	// Preprocessor
	STDMETHOD(get_PreprocessorDefinitions)(BSTR* pbstrDefines);		// (/D[name]) defines, can have multiple
	STDMETHOD(put_PreprocessorDefinitions)(BSTR bstrDefines);
	STDMETHOD(get_IgnoreStandardIncludePath)(VARIANT_BOOL* pbIgnoreInclPath);	// (/X) ignore standard include path
	STDMETHOD(put_IgnoreStandardIncludePath)(VARIANT_BOOL bIgnoreInclPath);
	STDMETHOD(get_GeneratePreprocessedFile)(preprocessOption* poptSetting);	// see enum above (/P, /EP /P)
	STDMETHOD(put_GeneratePreprocessedFile)(preprocessOption optSetting);
	STDMETHOD(get_KeepComments)(VARIANT_BOOL* pbKeepComments);	// (/C) don't strip comments, requires one of /E, /EP, /P switches
	STDMETHOD(put_KeepComments)(VARIANT_BOOL bKeepComments);
	// Code Generation; /MP, /MPlowpri deliberately left out (since we require /FD or /Gm to be thrown)
	STDMETHOD(get_StringPooling)(VARIANT_BOOL* pbPool);	// (/GF) enable read-only string pooling
	STDMETHOD(put_StringPooling)(VARIANT_BOOL bPool);
	STDMETHOD(get_MinimalRebuild)(VARIANT_BOOL* pbMinimalRebuild);	// (/Gm, /Gm-) enable/disable minimal rebuild, /Gm requires /ZI or /Zi
	STDMETHOD(put_MinimalRebuild)(VARIANT_BOOL bMinimalRebuild);
	STDMETHOD(get_ExceptionHandling)(VARIANT_BOOL* poptSetting);	// /EHsc
	STDMETHOD(put_ExceptionHandling)(VARIANT_BOOL optSetting);
	STDMETHOD(get_SmallerTypeCheck)(VARIANT_BOOL* pbSmallerType);
	STDMETHOD(put_SmallerTypeCheck)(VARIANT_BOOL bSmallerType);
	STDMETHOD(get_BasicRuntimeChecks)(basicRuntimeCheckOption* poptSetting);
	STDMETHOD(put_BasicRuntimeChecks)(basicRuntimeCheckOption optSetting);
	STDMETHOD(get_RuntimeLibrary)(runtimeLibraryOption* poptSetting);
	STDMETHOD(put_RuntimeLibrary)(runtimeLibraryOption optSetting);
	STDMETHOD(get_StructMemberAlignment)(structMemberAlignOption* poptSetting);
	STDMETHOD(put_StructMemberAlignment)(structMemberAlignOption optSetting);
	STDMETHOD(get_BufferSecurityCheck)(VARIANT_BOOL* bSecure);	// (/GS) enable buffer overrun checks; buffer security from hackers
	STDMETHOD(put_BufferSecurityCheck)(VARIANT_BOOL bSecure);
	STDMETHOD(get_EnableFunctionLevelLinking)(VARIANT_BOOL* pbPackage);	// (/Gy) enable function level linking (no explicit off)
	STDMETHOD(put_EnableFunctionLevelLinking)(VARIANT_BOOL bPackage);
	// Language
	STDMETHOD(get_DisableLanguageExtensions)(VARIANT_BOOL* pbDisableExtensions);	// (/Za, /Ze) disable/enable language extensions (/Ze default)
	STDMETHOD(put_DisableLanguageExtensions)(VARIANT_BOOL bDisableExtensions);
	STDMETHOD(get_DefaultCharIsUnsigned)(VARIANT_BOOL* pbIsUnsigned);	// (/J) default char type is unsigned
	STDMETHOD(put_DefaultCharIsUnsigned)(VARIANT_BOOL bIsUnsigned);
	STDMETHOD(get_TreatWChar_tAsBuiltInType)(VARIANT_BOOL* pbBuiltInType);
	STDMETHOD(put_TreatWChar_tAsBuiltInType)(VARIANT_BOOL bBuiltInType);
	STDMETHOD(get_ForceConformanceInForLoopScope)(VARIANT_BOOL* pbConform);	// (/Zc:forScope) check for conformance of vars for 'for' scope
	STDMETHOD(put_ForceConformanceInForLoopScope)(VARIANT_BOOL bConform);
	STDMETHOD(get_RuntimeTypeInfo)(VARIANT_BOOL* pbRTTI);	// (/GR) enable/disable C++ RTTI
	STDMETHOD(put_RuntimeTypeInfo)(VARIANT_BOOL bRTTI);
	// Precompiled Headers
	STDMETHOD(get_UsePrecompiledHeader)(pchOption* poptSetting);	// see enum above (/Yc, /YX, /Yu)
	STDMETHOD(put_UsePrecompiledHeader)(pchOption optSetting);
	STDMETHOD(get_PrecompiledHeaderThrough)(BSTR* pbstrFile);	// optional argument to UsePrecompiledHeader property specifying file to use to generate/use PCH
	STDMETHOD(put_PrecompiledHeaderThrough)(BSTR bstrFile);
	STDMETHOD(get_PrecompiledHeaderFile)(BSTR* pbstrPCH);	// (/Fp[name]) name the precompiled header file, can be directory location or leave off .pch extension
	STDMETHOD(put_PrecompiledHeaderFile)(BSTR bstrPCH);
	// Output Files
	STDMETHOD(get_ExpandAttributedSource)(VARIANT_BOOL* pbExpandAttributedSource);	// (/Fx) listing with attributed code expanded into source file
	STDMETHOD(put_ExpandAttributedSource)(VARIANT_BOOL bExpandAttributedSource);
	STDMETHOD(get_AssemblerOutput)(asmListingOption* poptSetting);	// see enum above (/FA, /FAc, /FAs, /FAcs)
	STDMETHOD(put_AssemblerOutput)(asmListingOption optSetting);
	STDMETHOD(get_AssemblerListingLocation)(BSTR* pbstrName);	// (/Fa[name]) specify directory and/or name for listing file from AssemblerOutput property
	STDMETHOD(put_AssemblerListingLocation)(BSTR bstrName);
	STDMETHOD(get_ObjectFile)(BSTR* pbstrName);	// (/Fo[name]) name obj file
	STDMETHOD(put_ObjectFile)(BSTR bstrName);
	STDMETHOD(get_ProgramDataBaseFileName)(BSTR* pbstrName);	// (/Fd[file]) name PDB file.  can be directory name
	STDMETHOD(put_ProgramDataBaseFileName)(BSTR bstrName);
	// Browse info helpers
	STDMETHOD(get_BrowseInformation)(browseInfoOption* poptSetting);	// see enum above, (/FR[name], /Fr[name])
	STDMETHOD(put_BrowseInformation)(browseInfoOption optSetting);
	STDMETHOD(get_BrowseInformationFile)(BSTR* pbstrFile);		// optional name to go with BrowseInformation property
	STDMETHOD(put_BrowseInformationFile)(BSTR bstrFile);
	// Advanced
	STDMETHOD(get_CallingConvention)(callingConventionOption* poptSetting);
	STDMETHOD(put_CallingConvention)(callingConventionOption optSetting);
	STDMETHOD(get_CompileAs)(CompileAsOptions* pcompileAs);	// see enum above (/TC, /TP)
	STDMETHOD(put_CompileAs)(CompileAsOptions compileAs);
	STDMETHOD(get_DisableSpecificWarnings)(BSTR* pbstrDisableSpecificWarnings);	// (/wd<num>) disable specific warnings; multi-prop
	STDMETHOD(put_DisableSpecificWarnings)(BSTR bstrDisableSpecificWarnings);
	STDMETHOD(get_ForcedIncludeFiles)(BSTR* pbstrName);	// (/FI![name]) name forced include file, can have multiple
	STDMETHOD(put_ForcedIncludeFiles)(BSTR bstrName);
	STDMETHOD(get_ForcedUsingFiles)(BSTR* pbstrName);	// (/FU![name]) name forced #using file, can have multiple
	STDMETHOD(put_ForcedUsingFiles)(BSTR bstrName);
	STDMETHOD(get_ShowIncludes)(VARIANT_BOOL* pbShowInc);	// (/showIncludes)
	STDMETHOD(put_ShowIncludes)(VARIANT_BOOL bShowInc);
	STDMETHOD(get_UndefinePreprocessorDefinitions)(BSTR* pbstrUndefines);	// (/U[name]) undefine predefined macro, can have multiple
	STDMETHOD(put_UndefinePreprocessorDefinitions)(BSTR bstrUndefines);
	STDMETHOD(get_UndefineAllPreprocessorDefinitions)(VARIANT_BOOL* pbPredefinedMacros);	// (/u) undefine all predefined macros 
	STDMETHOD(put_UndefineAllPreprocessorDefinitions)(VARIANT_BOOL bPredefinedMacros);
	// Automation properties
	STDMETHOD(get_ToolPath)(BSTR *pVal);
	STDMETHOD(get_PropertyOption)(BSTR bstrProp, long dispidProp, BSTR *pVal);
	STDMETHOD(get_FullIncludePath)(BSTR* fullIncludePath);	// include path, including all inherited values, plus platform includes
	STDMETHOD(get_VCProjectEngine)(IDispatch** projEngine)	{ return DoGetVCProjectEngine(projEngine); }
	STDMETHOD(get_CompileOnly)(VARIANT_BOOL* pbCompileOnly);	// (/c)	compile only, no link
	STDMETHOD(put_CompileOnly)(VARIANT_BOOL bCompileOnly);

// IVCToolImpl
public:
	STDMETHOD(get_DefaultExtensions)(BSTR* pVal);
	STDMETHOD(put_DefaultExtensions)(BSTR newVal);
	STDMETHOD(GetAdditionalOptionsInternal)(IUnknown* pItem, VARIANT_BOOL bForBuild, VARIANT_BOOL bSkipLocal, BSTR* pbstrAdditionalOptions);
	STDMETHOD(GetBuildDescription)(IVCBuildAction* pAction, BSTR* pbstrBuildDescription);
	STDMETHOD(GetAdditionalIncludeDirectoriesInternal)(IVCPropertyContainer* pPropContainer, BSTR* pbstrIncDirs);
	STDMETHOD(get_IncludePathID)(long* pnIncludeID);
	STDMETHOD(get_ToolPathInternal)(BSTR* pbstrToolPath);
	STDMETHOD(get_Bucket)(long *pVal);
	STDMETHOD(GenerateOutput)(long type, IVCBuildActionList* plstActions, IVCBuildErrorContext* pEC);
	STDMETHOD(AffectsOutput)(long nPropID, VARIANT_BOOL* pbAffectsOutput);
	STDMETHOD(get_ToolShortName)(BSTR* pbstrToolName);
	STDMETHOD(get_ToolNameInternal)(BSTR* pbstrToolName) { return get_ToolName(pbstrToolName); }
	STDMETHOD(MatchName)(BSTR bstrName, VARIANT_BOOL bFullOnly, VARIANT_BOOL* pbMatches);
	STDMETHOD(CreateToolObject)(IVCPropertyContainer* pPropContainer, IVCToolImpl** ppToolObject);
	STDMETHOD(PrePerformBuildActions)(bldActionTypes type, IVCBuildActionList* pActions, bldAttributes aob, IVCBuildErrorContext* pEC, actReturnStatus* pActReturn);
	STDMETHOD(HasDependencies)(IVCBuildAction* pAction, VARIANT_BOOL* pbHasDependencies);
	STDMETHOD(GetDependencies)(IVCBuildAction* pAction, IVCBuildStringCollection** ppStrings, VARIANT_BOOL* bUpToDate);
	STDMETHOD(CanScanForDependencies)(VARIANT_BOOL* pbIsScannable);
	STDMETHOD(GetCommandLinesForBuild)(IVCBuildActionList* pActions, bldAttributes attrib, IVCBuildEngine* pBldEngine, IVCBuildErrorContext* pErrorContext, IVCCommandLineList** ppCmds);
	STDMETHOD(HasVirtualLocalStorage)(IVCPropertyContainer* pPropContainer, VARIANT_BOOL* pbHasVirtualLocalStorage);
	STDMETHOD(CreatePageObject)(IUnknown **, CLSID*, IVCPropertyContainer *, IVCSettingsPage * );
	STDMETHOD(HasPrimaryOutputFromTool)(IUnknown* pItem, VARIANT_BOOL bSchmoozeOnly, VARIANT_BOOL* pbHasPrimaryOutput);	// returns TRUE only if tool generates a primary output (ex: linker)
	STDMETHOD(SetPrimaryOutputForTool)(IUnknown* pItem, BSTR bstrFile);		// sets the primary output for a tool
	STDMETHOD(GetPrimaryOutputIDFromTool)(IUnknown* pItem, VARIANT_BOOL bSchmoozeOnly, long* pnOutputID);	// return a value only if tool generates a primary output (ex: linker)
	STDMETHOD(GetDefaultOutputFileFormat)(IUnknown* pItem, BSTR* pbstrOutMacro);	// macro to use for generating default output file if the original default isn't unique
	STDMETHOD(GetDeploymentDependencies)(IVCBuildAction* pAction, IVCBuildStringCollection** ppDeployDepStrings);

	STDMETHOD(get_ToolDisplayIndex)(long* pIndex)
	{
		CHECK_POINTER_NULL(pIndex);
		*pIndex = TOOL_DISPLAY_INDEX_CPP;
		return S_OK;
	}

	virtual long GetPageCount()	{ return 10; }
	virtual GUID* GetPageIDs();

// helpers
public:
	virtual COptionHandlerBase* GetOptionHandler() { return &s_optHandler; }
	virtual HRESULT GetPrimaryOutputFromTool(IUnknown* pItem, VARIANT_BOOL bSchmoozeOnly, CPathW& rPath);	// return a value only if tool generates a primary output (ex: linker)
	static void MakePdbAsFile(IVCPropertyContainer* pPropContainer, CComBSTR& bstrPdb);
	static void ClearResolvedPdbName(IVCPropertyContainer* pPropContainer);
	static void RefreshResolvedPdbName(IVCPropertyContainer* pPropContainer, BOOL bForce = FALSE);
	static HRESULT GetResolvedPdbName(IVCPropertyContainer* pPropContainer, BSTR* pbstrName);

protected:
	virtual BOOL UsesResponseFiles() { return TRUE; }
	CBldCmdSet* GetCommandLineMatch(CVCPtrList& cmdSet, CStringW& rstrCmd);
	virtual LPCOLESTR GetToolFriendlyName();
	void InitToolName();
	virtual long GetToolID() { return IDS_Cl; }

private:
	static BOOL CheckPathAgainstDir(IVCPropertyContainer* pPropContainer, long id, CStringW& strPdb, CComBSTR& bstrPdb);

protected:
	static GUID s_pPages[10];
	static BOOL s_bPagesInit;
	static CComBSTR s_bstrBuildDescription;
	static CComBSTR s_bstrToolName;
	static CComBSTR s_bstrExtensions;

public:
	static CCLCompilerToolOptionHandler s_optHandler;
};

// These macros are used to define enum ranges for tool switches.  If you add an enum property to the tool option
// table, please add a matching macro for it to this list.  Use of macros for range definitions helps in keeping
// maintenance of enum range checks as low as possible.
#define OptimizeMax			4
#define CodeGenMax			2
#define InlineMax			2
#define OptProcMax			2
#define PreprocessMax		2
#define EHMax				4
#define RTCheckMax			3
#define StringPoolMax		2
#define MemPtrMax			4
#define DLLStyleMax			2
#define UsePCHMax			3
#define AsmListMax			4
#define DebugInfoMax		4
#define BrowseMax			2
#define CompileAsMax		2
#define CLWarnMax			4
#define CallConvMax			2
#define CLStructAlignMax	5
#define RTLibMax			5
#define ComRTMax            2
#define BasicRTCheckMax		3
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\vcpb\cltool.cpp ===
// CLTool.cpp : Implementation of CVCCLCompilerBaseTool
#include "stdafx.h"
#include "CLTool.h"
#include "FileRegistry.h"
#include "BldHelpers.h"
#include "BldActions.h"
#include "BuildEngine.h"
#include "scanner.h"
#include "MRDependencies.h"
#include "vsappid.h"

// constants
const wchar_t* const wszCLDefaultExtensions = L"*.cpp;*.cxx;*.cc;*.c";	// remember to update vcpb.rgs if you change this...
const wchar_t* const wszCLDefaultPCHUsingName = L"StdAfx.h";
const wchar_t* const wszCLDefaultPCHFileName = L"$(IntDir)/$(TargetName).pch";

const optimizeOption lOptimization = optimizeCustom;
const inlineExpansionOption lInlineFunctionExpansion = expandDisable;
const favorSizeOrSpeedOption lFavorSizeOrSpeed = favorNone;
const ProcessorOptimizeOption lOptimizeForProcessor = procOptimizeBlended;
const preprocessOption lPreprocess = preprocessNo;
const pchOption lUsePrecompiledHeader = pchNone;
const asmListingOption lAssemblerOutput = asmListingNone;
const debugOption lDebugInformation = debugDisabled;
const browseInfoOption lBrowseInformation = brInfoNone;
const CompileAsOptions lCompileAs = compileAsCPlusPlus;
const warningLevelOption lWarnLevel = warningLevel_1;
const basicRuntimeCheckOption lBasicRuntimeChecks = runtimeBasicCheckNone;
const callingConventionOption lCallingConvention = callConventionCDecl;
const structMemberAlignOption lStructMemberAlignment = alignNotSet;
const runtimeLibraryOption lRuntimeLibrary = rtSingleThreaded;
const compileAsManagedOptions lManagedExtensions = managedNotSet;

// static initializers
CCLCompilerToolOptionHandler CVCCLCompilerTool::s_optHandler;
CComBSTR CVCCLCompilerTool::s_bstrBuildDescription = L"";
CComBSTR CVCCLCompilerTool::s_bstrToolName = L"";
CComBSTR CVCCLCompilerTool::s_bstrExtensions = L"";


////////////////////////////////////////////////////////////////////////////////
// Option Table for base C/C++ compiler switches

// NOTE: we're using macros for enum value ranges to help in keeping enum range checks as low maintenance as possible.
// If you add an enum to this table, make sure you use macros to define the upper and lower bounds and use CHECK_BOUNDS
// on the get/put methods associated with that property (both object model and property page).
// WARNING: if you change ANYTHING about a multi-prop here (including add/remove), be sure to update how the property
// is obtained on both the tool and page objects.
BEGIN_OPTION_TABLE(CCLCompilerToolOptionHandler, L"VCCLCompilerTool", IDS_Cl, TRUE /* pre & post */, TRUE /* case sensitive */)
	// Optimization
	OPT_ENUM(Optimization,			L"Od|O1|O2|Ox|", StdEnumMin, OptimizeMax, L"Optimization",	IDS_ClOptimization,	VCCLID)
	OPT_BOOL(GlobalOptimizations,	L"|Og",	/* Og- */			L"GlobalOptimizations",			IDS_ClOptimization,	VCCLID)
	OPT_ENUM(InlineFunctionExpansion, L"|Ob1|Ob2",	/* Ob0 */ StdEnumMin, InlineMax, L"InlineFunctionExpansion", IDS_ClOptimization, VCCLID)
	OPT_BOOL(EnableIntrinsicFunctions, L"|Oi",	/* Oi- */		L"EnableIntrinsicFunctions",	IDS_ClOptimization, VCCLID)
	OPT_BOOL(ImproveFloatingPointConsistency, L"|Op", /* Op- */	L"ImproveFloatingPointConsistency",	IDS_ClOptimization, VCCLID)
	OPT_ENUM(FavorSizeOrSpeed,	L"|Ot|Os",	StdEnumMin,	CodeGenMax,	L"FavorSizeOrSpeed",	IDS_ClOptimization, VCCLID)
	OPT_BOOL(OmitFramePointers,		L"|Oy",	/* Oy- */			L"OmitFramePointers",		IDS_ClOptimization, VCCLID)
	OPT_BOOL(EnableFiberSafeOptimizations, L"|GT",				L"EnableFiberSafeOptimizations", IDS_ClOptimization, VCCLID)
	OPT_BOOL(WholeProgramOptimization, L"|GL",					L"WholeProgramOptimization",	SPECIAL_HYPERLINK, VCCLID)
	OPT_ENUM(OptimizeForProcessor,	L"|G5|G6", /* GB */ StdEnumMin,	OptProcMax,	L"OptimizeForProcessor", IDS_ClOptimization, VCCLID)
	OPT_BOOL(OptimizeForWindowsApplication,	L"|GA",				L"OptimizeForWindowsApplication", IDS_ClOptimization, VCCLID)
	// Preprocessor
	OPT_BSTR(AdditionalIncludeDirectories,	L"I %s",			L"AdditionalIncludeDirectories", multipleNoCase, IDS_ClGeneral, VCCLID)
	OPT_BSTR(AdditionalUsingDirectories,	L"AI %s",			L"AdditionalUsingDirectories", multipleNoCase, IDS_ClGeneral, VCCLID)
	OPT_BSTR(PreprocessorDefinitions, L"D %s",					L"PreprocessorDefinitions",		multiple, IDS_ClPreprocessor, VCCLID)
	OPT_BOOL(IgnoreStandardIncludePath,L"|X",					L"IgnoreStandardIncludePath",			IDS_ClPreprocessor, VCCLID)	
	OPT_ENUM(GeneratePreprocessedFile, L"|P|EP /P",		StdEnumMin, PreprocessMax,	L"GeneratePreprocessedFile",		IDS_ClPreprocessor, VCCLID)
	OPT_BOOL(KeepComments,			L"|C",						L"KeepComments",				IDS_ClPreprocessor, VCCLID)
	// Code Generation; /MP, /MPlowpri deliberately left out (since we require /FD or /Gm to be thrown)
	OPT_BOOL(StringPooling,			L"|GF",						L"StringPooling",			IDS_ClCodeGeneration, VCCLID)
	OPT_BOOL(MinimalRebuild,		L"FD|Gm",					L"MinimalRebuild",			IDS_ClCodeGeneration, VCCLID)
	OPT_BOOL(ExceptionHandling,		L"|EHsc",					L"ExceptionHandling",		IDS_ClCodeGeneration, VCCLID)
	OPT_ENUM(BasicRuntimeChecks,	L"|RTCs|RTCu|RTC1",	StdEnumMin, BasicRTCheckMax, L"BasicRuntimeChecks", IDS_ClCodeGeneration, VCCLID)
	OPT_BOOL(SmallerTypeCheck,		L"|RTCc",					L"SmallerTypeCheck",		IDS_ClCodeGeneration, VCCLID)
	OPT_ENUM(RuntimeLibrary,		L"MT|MTd|MD|MDd|ML|MLd",	StdEnumMin,	RTLibMax,	L"RuntimeLibrary", IDS_ClCodeGeneration, VCCLID)
	OPT_ENUM(StructMemberAlignment,	L"|Zp1|Zp2|Zp4|Zp8|Zp16",	StdEnumMin,	CLStructAlignMax,	L"StructMemberAlignment", IDS_ClCodeGeneration, VCCLID)
	OPT_BOOL(BufferSecurityCheck,	L"|GS",						L"BufferSecurityCheck",		IDS_ClCodeGeneration, VCCLID)
	OPT_BOOL(EnableFunctionLevelLinking, L"|Gy",				L"EnableFunctionLevelLinking", IDS_ClCodeGeneration, VCCLID)	
	// Language
	OPT_BOOL(DisableLanguageExtensions,	L"|Za",	/* Ze */			L"DisableLanguageExtensions", IDS_ClLanguage, VCCLID)
	OPT_BOOL(DefaultCharIsUnsigned,	L"|J",						L"DefaultCharIsUnsigned",	IDS_ClLanguage, VCCLID)
	OPT_BOOL(TreatWChar_tAsBuiltInType,	L"|Zc:wchar_t",			L"TreatWChar_tAsBuiltInType", IDS_ClLanguage, VCCLID)
	OPT_BOOL(ForceConformanceInForLoopScope, L"|Zc:forScope",	L"ForceConformanceInForLoopScope", IDS_ClLanguage, VCCLID)
	OPT_BOOL(RuntimeTypeInfo,		L"|GR",	/* GR- */			L"RuntimeTypeInfo",			IDS_ClLanguage, VCCLID)
	// Precompiled Headers
	OPT_ENUM_SET_COND(UsePrecompiledHeader,	L"|Yc|YX|Yu",	StdEnumMin,	UsePCHMax, 1,	L"UsePrecompiledHeader", PrecompiledHeaderThrough, IDS_ClPrecompiledHeaders, VCCLID)
	OPT_BSTR_COND(PrecompiledHeaderThrough,	L"%s",				L"PrecompiledHeaderThrough",	UsePrecompiledHeader, single, IDS_ClPrecompiledHeaders, VCCLID)
	OPT_BSTR(PrecompiledHeaderFile,	L"Fp%s",					L"PrecompiledHeaderFile", single, IDS_ClPrecompiledHeaders, VCCLID)
	// Output Files
	OPT_BOOL(ExpandAttributedSource, L"|Fx",					L"ExpandAttributedSource",			IDS_ClOutputFiles, VCCLID)
	OPT_ENUM_SET_COND(AssemblerOutput,	L"|FA|FAcs|FAc|FAs", StdEnumMin, AsmListMax, 1, L"AssemblerOutput", AssemblerListingLocation, IDS_ClOutputFiles, VCCLID)
	OPT_BSTR_COND(AssemblerListingLocation, L" /Fa%s",			L"AssemblerListingLocation", AssemblerOutput, single, IDS_ClOutputFiles, VCCLID)
	OPT_BSTR(ObjectFile,			L"Fo%s",					L"ObjectFile",			single, IDS_ClOutputFiles, VCCLID)
	OPT_BSTR(ProgramDataBaseFileName, L"Fd%s",					L"ProgramDataBaseFileName", single, IDS_ClOutputFiles, VCCLID)
	// Browse info helpers
	OPT_ENUM_SET_COND(BrowseInformation, L"|FR|Fr",	StdEnumMin,	BrowseMax, 1,	L"BrowseInformation", BrowseInformationFile, IDS_ClBrowseInfo, VCCLID)
	OPT_BSTR_COND(BrowseInformationFile, L"%s",					L"BrowseInformationFile", BrowseInformation, single, IDS_ClBrowseInfo, VCCLID)
	// General
	OPT_ENUM(WarningLevel,			L"W0|W1|W2|W3|W4",		 StdEnumMin, CLWarnMax, L"WarningLevel",	IDS_ClGeneral, VCCLID)
	OPT_BOOL(WarnAsError,			L"|WX",	/* WX-	*/			L"WarnAsError",						IDS_ClGeneral, VCCLID)
	OPT_BOOL(SuppressStartupBanner, L"|nologo", /* nologo- */	L"SuppressStartupBanner",		IDS_ClGeneral, VCCLID)
	OPT_BOOL(CompileOnly,			L"c|c",						L"CompileOnly",						NO_HYPERLINK, VCCLID)
	OPT_BOOL(Detect64BitPortabilityProblems, L"|Wp64",			L"Detect64BitPortabilityProblems",	IDS_ClGeneral, VCCLID)
	OPT_ENUM(DebugInformationFormat,L"|Z7|Zd|Zi|ZI",	StdEnumMin,	DebugInfoMax,	L"DebugInformationFormat", IDS_ClGeneral, VCCLID)
	OPT_ENUM(CompileAsManaged,		L"|clr:noAssembly|clr",		StdEnumMin, ComRTMax,	L"CompileAsManaged",	IDS_ClGeneral, VCCLID)	
	// Advanced
	OPT_ENUM(CallingConvention,		L"Gd|Gr|Gz",				StdEnumMin,	CallConvMax,	L"CallingConvention",	IDS_ClAdvanced, VCCLID)
	OPT_ENUM_SPECIAL(CompileAs,		L"|TC|TP|Tc|Tp",			StdEnumMin,	CompileAsMax,	L"CompileAs",			IDS_ClAdvanced, VCCLID)
	OPT_BSTR_NOQUOTE(DisableSpecificWarnings,	L"wd%s",		L"DisableSpecificWarnings", multiple,				IDS_ClAdvanced, VCCLID)
	OPT_BSTR(ForcedIncludeFiles,	L"FI %s",					L"ForcedIncludeFiles",		multipleNoCase,			IDS_ClAdvanced, VCCLID)
	OPT_BSTR(ForcedUsingFiles,		L"FU %s",					L"ForcedUsingFiles",		multipleNoCase,			IDS_ClAdvanced, VCCLID)
	OPT_BOOL(ShowIncludes,			L"|showIncludes",			L"ShowIncludes",									IDS_ClAdvanced, VCCLID)
	OPT_BSTR(UndefinePreprocessorDefinitions, L"U %s",			L"UndefinePreprocessorDefinitions",	multiple,		IDS_ClAdvanced, VCCLID)
	OPT_BOOL(UndefineAllPreprocessorDefinitions, L"|u",			L"UndefineAllPreprocessorDefinitions",				IDS_ClAdvanced, VCCLID)
END_OPTION_TABLE()

void CCLCompilerToolOptionHandler::EvaluateSpecialEnumAtIndex(int nVal, LPCOLESTR szOption, long idOption, 
	IVCPropertyContainer* pPropContainer, BOOL bIncludeSlash, CStringW& rstrSwitch) 
{ 
	if (idOption == VCCLID_CompileAs)
	{
		// we will need to do some fancy footwork to determine whether we need the full line or
		// individual file versions of this switch (first position is the same, add two to get
		// to the appropriate file level switch)
	}
	EvaluateEnumAtIndex(nVal, szOption, bIncludeSlash, rstrSwitch); 
}

BOOL CCLCompilerToolOptionHandler::OverrideOptionSet(IVCPropertyContainer* pPropContainer, long idOption)
{
	RETURN_ON_NULL2(g_pProjectEngine, FALSE);

	switch (idOption)
	{
	case VCCLID_Optimization:
	case VCCLID_GlobalOptimizations:
	case VCCLID_InlineFunctionExpansion:
	case VCCLID_EnableIntrinsicFunctions:
	case VCCLID_ImproveFloatingPointConsistency:
	case VCCLID_FavorSizeOrSpeed:
	case VCCLID_OmitFramePointers:
	case VCCLID_WholeProgramOptimization:
		{
			long SKU;
			static_cast<CVCProjectEngine*>(g_pProjectEngine)->GetSKU( &SKU );
			switch( SKU )
			{
				case VSASKUEdition_Book:
				case VSASKUEdition_Standard:
					break;
				default:
					return FALSE;
					break;
			}
			break;
		}
	default:
		return FALSE;
	}

	if (m_bNotifiedNoOptimize)	// if we already told 'em, don't bother trying to tell 'em again
		return TRUE;
	m_bNotifiedNoOptimize = TRUE;

	VARIANT_BOOL bHaveLogging = VARIANT_FALSE;
	g_pProjectEngine->get_BuildLogging(&bHaveLogging);
	if (bHaveLogging == VARIANT_FALSE)
		return TRUE;

	// this whole rigamarole is to try to put a message in the build log about this
	CComQIPtr<IVCBuildableItem> spBldableItem = pPropContainer;
	RETURN_ON_NULL2(spBldableItem, TRUE);

	CComPtr<IVCBuildEngine> spBuildEngine;
	spBldableItem->get_ExistingBuildEngine(&spBuildEngine);
	RETURN_ON_NULL2(spBuildEngine, TRUE);

	CComBSTR bstrInfo;
	bstrInfo.LoadString(IDS_NO_CL_OPTIMIZE);
	spBuildEngine->LogTrace(eLogCommand, bstrInfo);

	return TRUE;
}

void CCLCompilerToolOptionHandler::InitializeFlags()
{
	m_bNotifiedNoOptimize = FALSE;
}

BOOL CCLCompilerToolOptionHandler::SetEvenIfDefault(VARIANT *pvarDefault, long idOption)
{
	CComVariant varDefault;
	BOOL bRet = FALSE;

	switch (idOption)
	{
	case VCCLID_CompileOnly:
	case VCCLID_SuppressStartupBanner:
		varDefault.vt = VT_BOOL;
		varDefault = VARIANT_TRUE;
		bRet = TRUE;
		break;
	case VCCLID_MinimalRebuild:
		varDefault.vt = VT_BOOL;
		varDefault = VARIANT_FALSE;
		bRet = TRUE;
		break;
	}
	varDefault.Detach(pvarDefault);
	return bRet;
}

BOOL CCLCompilerToolOptionHandler::SynthesizeOptionIfNeeded(IVCPropertyContainer* pPropContainer, long idOption)
{
	VSASSERT(pPropContainer != NULL, "Cannot synthesize a tool option without a property container");
	RETURN_ON_NULL2(pPropContainer, FALSE);	// can't synthesize if we don't have a property container...

	switch (idOption)
	{
	case VCCLID_ObjectFile:
	case VCCLID_ProgramDataBaseFileName:	// also tells where to put .idb file
	case VCCLID_CompileAs:
		return TRUE;
	case VCCLID_PrecompiledHeaderFile:
	case VCCLID_PrecompiledHeaderThrough:
		{
			long nPCHType = pchNone;
			HRESULT hr = pPropContainer->GetIntProperty(VCCLID_UsePrecompiledHeader, &nPCHType);
			if (hr != S_OK)
				return FALSE;
			return ((pchOption)nPCHType != pchNone);
		}
	case VCCLID_BufferSecurityCheck:
		{
			long dbgInfo;
			HRESULT hr = pPropContainer->GetIntProperty(VCCLID_DebugInformationFormat, &dbgInfo);
			if (hr != S_OK)
				return FALSE;
			return  (dbgInfo != (long)debugEditAndContinue);
		}
	case VCCLID_BrowseInformationFile:
		{
			browseInfoOption browseInfo;
			HRESULT hr = pPropContainer->GetIntProperty(VCCLID_BrowseInformation, (long *)&browseInfo);
			return (hr == S_OK && browseInfo != brInfoNone);
		}
	case VCCLID_AssemblerListingLocation:
		{
			asmListingOption asmOption;
			HRESULT hr = pPropContainer->GetIntProperty(VCCLID_AssemblerOutput, (long *)&asmOption);
			return (hr == S_OK && asmOption != asmListingNone);
		}
	default:
		return FALSE;
	}
}

BOOL CCLCompilerToolOptionHandler::SynthesizeOption(IVCPropertyContainer* pPropContainer, long idOption, 
	CComVariant& rvar)
{
	switch (idOption)
	{
	case VCCLID_ObjectFile:
	case VCCLID_ProgramDataBaseFileName:
		{
			rvar.Clear();
			VSASSERT(pPropContainer != NULL, "Cannot create an option value without a property container");
			CComBSTR bstrVal;
			GetDefaultValue( idOption, &bstrVal, pPropContainer );
			return SetBstrInVariant(pPropContainer, bstrVal, rvar);
		}
	case VCCLID_PrecompiledHeaderFile:
		{
			CComBSTR bstrPCH;
			if (GetPCHName(pPropContainer, &bstrPCH, FALSE))
				return SetBstrInVariant(pPropContainer, bstrPCH, rvar);
			return FALSE;
		}
	case VCCLID_PrecompiledHeaderThrough:
		{
			CComBSTR bstrPCH;
			if (GetPCHHeaderName(pPropContainer, VCCLID_PrecompiledHeaderThrough, bstrPCH))
				return SetBstrInVariant(pPropContainer, bstrPCH, rvar);
			return FALSE;
		}
	case VCCLID_BrowseInformationFile:
		{
			browseInfoOption browseInfo;
			CComBSTR bstrBrowseInfoFile;
			if (pPropContainer->GetIntProperty(VCCLID_BrowseInformation, (long *)&browseInfo) == S_OK && browseInfo != brInfoNone )
				{
					GetDefaultValue( VCCLID_BrowseInformationFile, &bstrBrowseInfoFile, pPropContainer );
					return SetBstrInVariant(pPropContainer, bstrBrowseInfoFile, rvar);
				}
			return FALSE;
		}
	case VCCLID_BufferSecurityCheck:
		{
			long dbgInfo;
			HRESULT hr = pPropContainer->GetIntProperty(VCCLID_DebugInformationFormat, &dbgInfo);
			if (hr == S_OK && dbgInfo == (long)debugEditAndContinue)
				return FALSE;
			rvar.vt = VT_BOOL;
			rvar.boolVal = VARIANT_TRUE;
			return TRUE;
		}
	case VCCLID_AssemblerListingLocation:
		{
			asmListingOption asmOption;
			CComBSTR bstrAsmLocation;
			if (pPropContainer->GetIntProperty(VCCLID_AssemblerOutput, (long *)&asmOption) == S_OK 
				&& asmOption != asmListingNone )
				{
					GetDefaultValue( VCCLID_AssemblerListingLocation, &bstrAsmLocation, pPropContainer );
					return SetBstrInVariant(pPropContainer, bstrAsmLocation, rvar);
				}
			return FALSE;
		}
	case VCCLID_CompileAs:
		{
			CompileAsOptions compileAs = GetDefaultCompileAs(pPropContainer, FALSE);
			rvar.lVal = (long)compileAs;
			rvar.vt = VT_I4;
			return TRUE;
		}
	default:
		VSASSERT(FALSE, "Case statement mismatch between SynthesizeOptionIfNeeded and SynthesizeOption");	// shouldn't be here!!
		return FALSE;
	}
}


CompileAsOptions CCLCompilerToolOptionHandler::GetDefaultCompileAs(IVCPropertyContainer* pPropContainer, BOOL bCheckExplicit /* = TRUE */)
{
	RETURN_ON_NULL2(pPropContainer, compileAsDefault);

	CComVariant var;
	if (bCheckExplicit && pPropContainer->GetProp(VCCLID_CompileAs, &var) == S_OK && var.vt != VT_EMPTY)
		return (CompileAsOptions)var.lVal;

	CComPtr<IVCPropertyContainer> spActualContainer;
	CVCProjectEngine::ResolvePropertyContainer(pPropContainer, &spActualContainer);
	RETURN_ON_NULL2(spActualContainer, compileAsDefault);

	CComQIPtr<VCConfiguration> spProjCfg = spActualContainer;
	if (spProjCfg)
		return compileAsCPlusPlus;

	CComQIPtr<VCFileConfiguration> spFileCfg = spActualContainer;
	RETURN_ON_NULL2(spFileCfg, compileAsCPlusPlus);

	CComPtr<IDispatch> spDispFile;
	spFileCfg->get_File(&spDispFile);
	CComQIPtr<VCFile> spFile = spDispFile;
	RETURN_ON_NULL2(spFile, compileAsCPlusPlus);

	CComBSTR bstrName;
	spFile->get_Name(&bstrName);
	CStringW strName = bstrName;
	if (strName.GetLength() > 2)
	{
		CStringW strEnd = strName.Right(2);
		strEnd.MakeLower();
		if (strEnd == L".c")
			return compileAsC;
	}

	return compileAsCPlusPlus;
}

static const wchar_t* szScriptItemCL = L"\r\n<a title=\"%s | %s\" onclick=\"onHelp('VC.Project.VCConfiguration.WholeProgramOptimization')\" href=\"settingspage.htm\">%s</a>";

void CCLCompilerToolOptionHandler::FormatScriptItem(const wchar_t* szOptionName, long idOption, long idOptionPage, CStringW& rstrOption)
{
	if (idOption != SPECIAL_HYPERLINK)
	{
		COptionHandlerBase::FormatScriptItem(szOptionName, idOption, idOptionPage, rstrOption);
		return;
	}

	VSASSERT(idOption == VCCLID_WholeProgramOptimization, "Hey, only doing special handling for VCCLID_WholeProgramOptimization for CL!");

	CStringW strProp;
	strProp.LoadString(VCCFGID_WholeProgramOptimization);
	long nColon = strProp.Find(L": ");
	if (nColon)
		strProp = strProp.Left(nColon-1);
	strProp.TrimLeft();
	strProp.TrimRight();

	CStringW strGen;
	strGen.LoadString(IDS_GeneralConfigSettings);
	CStringW strTmp;
	strTmp.Format(szScriptItemCL, strGen, strProp, rstrOption);
	rstrOption = strTmp;
}

BOOL CCLCompilerToolOptionHandler::GetPCHName(IVCPropertyContainer* pPropContainer, BSTR* pbstrPCH,
	BOOL bCheckForExistence /* = TRUE */)
{
	VSASSERT(pPropContainer != NULL, "Cannot create PCHName without property container");
	if (bCheckForExistence)
	{
		CComBSTR bstrPCH;
		if (pPropContainer->GetEvaluatedStrProperty(VCCLID_PrecompiledHeaderFile, pbstrPCH) == S_OK)
			return TRUE;
	}

	GetDefaultValue( VCCLID_PrecompiledHeaderFile, pbstrPCH, pPropContainer );
	HRESULT hr = pPropContainer->Evaluate(*pbstrPCH, pbstrPCH);

	return (SUCCEEDED(hr));
}

BOOL CCLCompilerToolOptionHandler::GetPCHHeaderName(IVCPropertyContainer* pPropContainer, long nID,
	CComBSTR& rbstrPCH, BOOL bCheckForExistence /* = TRUE */)
{
	VSASSERT(pPropContainer != NULL, "Cannot get PCHHeaderName without property container");

	if (bCheckForExistence)
	{
		if (pPropContainer->GetEvaluatedStrProperty(nID, &rbstrPCH) == S_OK)
			return TRUE;
	}

	rbstrPCH = L"stdafx.h";
	return TRUE;
}

// default value handlers
// string props
void CCLCompilerToolOptionHandler::GetDefaultValue( long id, BSTR *pVal, IVCPropertyContainer *pPropContainer )
{
	switch( id )
	{
	case VCCLID_PrecompiledHeaderThrough:
	{
		pchOption usePCH = pchNone;
		if (pPropContainer != NULL && pPropContainer->GetIntProperty(VCCLID_UsePrecompiledHeader, (long *)&usePCH) == S_OK && usePCH != pchNone)
			*pVal = SysAllocString( wszCLDefaultPCHUsingName );
		else
			GetDefaultString( pVal );
		break;
	}
	case VCCLID_PrecompiledHeaderFile:
	{
		pchOption usePCH = pchNone;
		if (pPropContainer != NULL && pPropContainer->GetIntProperty(VCCLID_UsePrecompiledHeader, (long *)&usePCH) == S_OK && usePCH != pchNone)	
			*pVal = SysAllocString( wszCLDefaultPCHFileName );
		else
			GetDefaultString( pVal );
		break;
	}
	case VCCLID_AssemblerListingLocation:
	{
		if (pPropContainer)
		{
			asmListingOption asmOption;
			HRESULT hr = pPropContainer->GetIntProperty(VCCLID_AssemblerOutput, (long *)&asmOption);
			if (hr == S_OK && asmOption != asmListingNone)
				*pVal = SysAllocString( L"$(IntDir)/" );
		}
		else 
			GetDefaultString( pVal );
		break;
	}
	case VCCLID_ObjectFile:
	{
		if (pPropContainer == NULL)
			GetDefaultString( pVal );
		else
			*pVal = SysAllocString( L"$(IntDir)/" );
		break;
	}
	case VCCLID_ProgramDataBaseFileName:
	{
		if (pPropContainer == NULL)
			GetDefaultString( pVal );

		else
		{
			CComBSTR bstrDefault = L"$(IntDir)/";
			bstrDefault += CBldAction::s_bstrDefVCFile;
			bstrDefault += L".pdb";
			*pVal = bstrDefault.Detach();
		}
		break;;
	}
	case VCCLID_BrowseInformationFile:
	{
		browseInfoOption brInfo;
		if (pPropContainer == NULL || pPropContainer->GetIntProperty(VCCLID_BrowseInformation, (long *)&brInfo) != S_OK || brInfo == brInfoNone)
			GetDefaultString( pVal );
		else
			*pVal = SysAllocString( L"$(IntDir)/" );
		break;
	}
// 	case VCCLID_AdditionalOptions:
// 	case VCCLID_AdditionalIncludeDirectories:
// 	case VCCLID_AdditionalUsingDirectories:
// 	case VCCLID_PreprocessorDefinitions:
// 	case VCCLID_UndefinePreprocessorDefinitions:
// 	case VCCLID_ForcedIncludeFiles:
// 	case VCCLID_ForcedUsingFiles:
// 	case VCCLID_DisableSpecificWarnings:
	default:
 		GetDefaultString( pVal );
		break;
	}
}

// integer props
void CCLCompilerToolOptionHandler::GetDefaultValue( long id, long *pVal, IVCPropertyContainer *pPropCnt )
{
	switch( id )
	{
	case VCCLID_Optimization:
		*pVal = lOptimization;
		break;
	case VCCLID_InlineFunctionExpansion:
		*pVal = lInlineFunctionExpansion;
		break;
	case VCCLID_FavorSizeOrSpeed:
		*pVal = lFavorSizeOrSpeed;
		break;
	case VCCLID_GeneratePreprocessedFile:
		*pVal = lPreprocess;
		break;
	case VCCLID_UsePrecompiledHeader:
		*pVal = lUsePrecompiledHeader;
		break;
	case VCCLID_AssemblerOutput:
		*pVal = lAssemblerOutput;
		break;
	case VCCLID_DebugInformationFormat:
		*pVal = lDebugInformation;
		break;
	case VCCLID_BrowseInformation:
		*pVal = lBrowseInformation;
		break;
	case VCCLID_CompileAs:
		*pVal = (long)GetDefaultCompileAs(pPropCnt);
		break;
	case VCCLID_WarningLevel:
		*pVal = lWarnLevel;
		break;
	case VCCLID_BasicRuntimeChecks:
		*pVal = lBasicRuntimeChecks;
		break;
	case VCCLID_CompileAsManaged:
		*pVal = lManagedExtensions;
		break;
	case VCCLID_OptimizeForProcessor:
		*pVal = lOptimizeForProcessor;
		break;
	case VCCLID_CallingConvention:
		*pVal = lCallingConvention;
		break;
	case VCCLID_StructMemberAlignment:
		*pVal = lStructMemberAlignment;
		break;
	case VCCLID_RuntimeLibrary:
		*pVal = lRuntimeLibrary;
		break;

	default:
		*pVal = 0;
		break;
	}
}

// boolean props
void CCLCompilerToolOptionHandler::GetDefaultValue( long id, VARIANT_BOOL *pVal, IVCPropertyContainer *pPropCnt )
{
	switch( id )
	{
	case VCCLID_MinimalRebuild:
	case VCCLID_SuppressStartupBanner:
		GetValueTrue( pVal );
		break;
 	case VCCLID_BufferSecurityCheck:
		{
			if (pPropCnt == NULL)
			{
				GetValueTrue(pVal);
			}
			else
			{
				long dbgInfo;
				HRESULT hr = pPropCnt->GetIntProperty(VCCLID_DebugInformationFormat, &dbgInfo);
				if (hr == S_OK && dbgInfo == (long)debugEditAndContinue)
					GetValueFalse(pVal);
				else
					GetValueTrue(pVal);
			}
			break;
		}
// 	case VCCLID_GlobalOptimizations:
// 	case VCCLID_EnableIntrinsicFunctions:
// 	case VCCLID_ImproveFloatingPointConsistency:
// 	case VCCLID_OmitFramePointers:
// 	case VCCLID_EnableFiberSafeOptimizations:
// 	case VCCLID_WholeProgramOptimization:
// 	case VCCLID_UndefineAllPreprocessorDefinitions:
// 	case VCCLID_IgnoreStandardIncludePath:
// 	case VCCLID_KeepComments:
// 	case VCCLID_ShowIncludes:
// 	case VCCLID_SmallerTypeCheck:
// 	case VCCLID_RuntimeTypeInfo:
// 	case VCCLID_DisableLanguageExtensions:
// 	case VCCLID_DefaultCharIsUnsigned:
// 	case VCCLID_TreatWChar_tAsBuiltInType:
// 	case VCCLID_ForceConformanceInForLoopScope:
// 	case VCCLID_EnableFunctionLevelLinking:
// 	case VCCLID_UsePrecompiledHeader:
// 	case VCCLID_ExpandAttributedSource:
// 	case VCCLID_WarnAsError:
// 	case VCCLID_CompileOnly:
// 	case VCCLID_Detect64BitPortabilityProblems:
//	case VCCLID_ExceptionHandling:
//	case VCCLID_StringPooling:
//	case VCCLID_OptimizeForWindowsApplication:
	default:
		GetValueFalse( pVal );
		break;
	}
}

// Settings pages
GUID CVCCLCompilerTool::s_pPages[10];
BOOL CVCCLCompilerTool::s_bPagesInit = FALSE;

GUID* CVCCLCompilerTool::GetPageIDs()
{ 
	if (s_bPagesInit == FALSE)
	{
		s_pPages[0] = __uuidof(ClGeneral);
		s_pPages[1] = __uuidof(ClOptimization);
		s_pPages[2] = __uuidof(ClPreprocessor);
		s_pPages[3] = __uuidof(ClCodeGeneration);
		s_pPages[4] = __uuidof(ClLanguage);
		s_pPages[5] = __uuidof(ClPrecompiledHeaders);
		s_pPages[6] = __uuidof(ClOutputFiles);
		s_pPages[7] = __uuidof(ClBrowseInfo);
		s_pPages[8] = __uuidof(ClAdvanced);
		s_pPages[9] = __uuidof(ClAdditionalOptions);
		s_bPagesInit = TRUE;
	}
	return s_pPages; 
}

LPCOLESTR CVCCLCompilerTool::GetToolFriendlyName()
{
	InitToolName();
	return s_bstrToolName;
}

void CVCCLCompilerTool::InitToolName()
{
	if (s_bstrToolName.Length() == 0)
	{
		if (!s_bstrToolName.LoadString(IDS_CL_TOOLNAME))
			s_bstrToolName = szCLCompilerToolType;
	}
}

HRESULT CVCCLCompilerTool::CreateInstance(IVCPropertyContainer* pPropContainer, IVCToolImpl** ppCLTool)
{
	CHECK_POINTER_NULL(ppCLTool);
	*ppCLTool = NULL;

	CComObject<CVCCLCompilerTool> *pObj;
	HRESULT hr = CComObject<CVCCLCompilerTool>::CreateInstance(&pObj);
	if (SUCCEEDED(hr))
	{
		if( pPropContainer )
			pObj->Initialize(pPropContainer);
		CVCCLCompilerTool *pVar = pObj;
		pVar->AddRef();
		*ppCLTool = pVar;
	}
	return hr;
}

STDMETHODIMP CVCCLCompilerTool::PrePerformBuildActions(bldActionTypes type, IVCBuildActionList* pActions, 
	bldAttributes aob, IVCBuildErrorContext* pEC, actReturnStatus* pActReturn)
{
	CHECK_POINTER_NULL(pActReturn);
	*pActReturn = ACT_Complete;

	RETURN_ON_NULL2(pActions, S_OK);	// no actions, nothing to do

	// what stage is this?
	// need to rebuild?

	HRESULT hr = S_OK;
	if (type == TOB_Build)
	{
		// delete the .obj file if we think we should have a .pdb and we don't
		hr = pActions->Reset(NULL);
		if (FAILED(hr))
		{
			VSASSERT(FALSE, "Failed doing Reset on action list!?!");
			return E_UNEXPECTED;
		}
		hr = S_OK;
		while (hr == S_OK && (*pActReturn == ACT_Complete) /* failure */)
		{
			CComPtr<IVCBuildAction> spAction;
			hr = pActions->Next(&spAction, NULL);
			BREAK_ON_DONE(hr);
			VALID_CONTINUE_ON_NULL(spAction);
			CBldFileRegSet* pfrs = NULL;
			HRESULT hr2 = spAction->GetOutput(pEC, (void **)&pfrs);
			CONTINUE_ON_FAIL(hr2);
			VALID_CONTINUE_ON_NULL(pfrs);
			CBldFileRegistry* pActionRegistry = NULL;
			hr2 = spAction->get_Registry((void **)&pActionRegistry);
			CONTINUE_ON_FAIL(hr2);
			CONTINUE_ON_NULL(pActionRegistry);

			BldFileRegHandle frh;
			pfrs->InitFrhEnum();
			CComBSTR bstrProjectDirectory;
			CComPtr<IVCBuildableItem> spItem;
			BOOL bFoundProjectDirectory = FALSE;
			while ((frh = pfrs->NextFrh()) != (BldFileRegHandle)NULL)
			{
				const CPathW* pPath = pActionRegistry->GetRegEntry(frh)->GetFilePath();
				if (_wcsicmp(pPath->GetExtension(), L".pdb") == 0)
				{
					if (!pPath->ExistsOnDisk())
					{
						hr2 = spAction->get_Item(&spItem);
						VSASSERT(SUCCEEDED(hr2), "Every action has an item!");
						if (!bFoundProjectDirectory)
						{
							bFoundProjectDirectory = TRUE;
							CComQIPtr<IVCPropertyContainer> spPropContainer = spItem;
							VSASSERT(spPropContainer != NULL, "Trying to get information out of non-property container");
							bstrProjectDirectory.Empty();
							if (spPropContainer != NULL)
								spPropContainer->GetStrProperty(VCPROJID_ProjectDirectory, &bstrProjectDirectory);	// should never have macros in it
						}

						// GetItemOutputFile will write over frh.
						frh->ReleaseFRHRef();
						if (GetItemOutputFile(spAction, spItem, VCCFGID_IntermediateDirectory, frh, L".obj", 
							bstrProjectDirectory, TRUE))
						{
							if (!g_StaticBuildEngine.DeleteFile(frh, pEC, NULL, pActions) && !(aob & AOB_IgnoreErrors))
								*pActReturn = ACT_Error;	// failure
						}
					}
					if (NULL != frh)
						frh->ReleaseFRHRef();
					break;	// done!
				}
				if (NULL != frh)
					frh->ReleaseFRHRef();
			}
		}
	}

	return S_OK;
}

STDMETHODIMP CVCCLCompilerTool::GenerateOutput(long type, IVCBuildActionList* plstActions, IVCBuildErrorContext* pEC)
{
	if (plstActions == NULL)
		return CVCProjectEngine::DoSetErrorInfo(VCPROJ_E_INTERNAL_ERR, IDS_ERR_INTERNAL_ERROR);
	plstActions->Reset(NULL);

	BOOL bFirst = TRUE;
	CDirW dirProject;
	CComBSTR bstrIntermediateDirectory;
	while (TRUE)
	{
		CComPtr<IVCBuildAction> spAction;
		HRESULT hr = plstActions->Next(&spAction, NULL);
		BREAK_ON_DONE(hr);

 		CComPtr<IVCPropertyContainer> spPropContainer;
		spAction->get_PropertyContainer(&spPropContainer);
		VSASSERT(spPropContainer != NULL, "Action does not have a property container associated with it.  Bad initialization.");
		if (spPropContainer == NULL)
			return CVCProjectEngine::DoSetErrorInfo(VCPROJ_E_INTERNAL_ERR, IDS_ERR_INTERNAL_ERROR);

		if (IsExcludedFromBuild(spPropContainer))
			continue;	// nothing to do for things excluded from build...

		if (bFirst)
		{
			bFirst = FALSE;
			CComBSTR bstrProjectDirectory;
			hr = spPropContainer->GetStrProperty(VCPROJID_ProjectDirectory, &bstrProjectDirectory);	// should never have macros in it
			VSASSERT(hr == S_OK, "How did we manage to not get a project directory?!?");
			RETURN_ON_FAIL(hr);
			CStringW strProjDir = bstrProjectDirectory;
			if (!dirProject.CreateFromKnown(strProjDir))
			{
				VSASSERT(FALSE, "Invalid project directory!");
				return CVCProjectEngine::DoSetErrorInfo(VCPROJ_E_INTERNAL_ERR, IDS_ERR_INTERNAL_ERROR);
			}
			hr = spPropContainer->GetEvaluatedStrProperty(VCCFGID_IntermediateDirectory, &bstrIntermediateDirectory);
			if (FAILED(hr) || bstrIntermediateDirectory.Length() == 0)
				spPropContainer->GetEvaluatedStrProperty(VCCFGID_OutputDirectory, &bstrIntermediateDirectory);
		}

		// object files
		CComBSTR bstrObjFile;
		hr = spPropContainer->GetStrProperty(VCCLID_ObjectFile, &bstrObjFile);
		HRESULT hrT = S_OK;
		if (hr == S_OK)
		{
			spPropContainer->Evaluate(bstrObjFile, &bstrObjFile);
			hrT = spAction->AddOutputFromFileName(bstrObjFile, pEC, L".obj", (wchar_t *)(const wchar_t*)dirProject, 
				VARIANT_TRUE, VCCLID_ObjectFile, this);
		}
		else
			hrT = spAction->AddOutputInSubDirectory(bstrIntermediateDirectory, pEC, L".obj", 
				(wchar_t *)(const wchar_t*)dirProject, NULL, -1, VARIANT_TRUE, VCCFGID_IntermediateDirectory, this);
		if (hrT != S_OK)
			return hrT;

		// source browser files
		CComBSTR bstrSbrFile;
		hr = spPropContainer->GetStrProperty(VCCLID_BrowseInformationFile, &bstrSbrFile);
		if (hr == S_OK)
		{
			long nBrowseInfo;
			hr = spPropContainer->GetIntProperty(VCCLID_BrowseInformation, &nBrowseInfo);
			if (hr == S_OK && (browseInfoOption)nBrowseInfo != brInfoNone)
			{
				spPropContainer->Evaluate(bstrSbrFile, &bstrSbrFile);
				hrT = spAction->AddOutputFromFileName(bstrSbrFile, pEC, L".sbr", (wchar_t *)(const wchar_t*)dirProject, 
					VARIANT_TRUE, VCCLID_BrowseInformationFile, this);
			}
			else
				hrT = S_OK;
		}
		else
			hrT = spAction->AddOutputInSubDirectory(bstrIntermediateDirectory, pEC, L".sbr", 
				(wchar_t *)(const wchar_t *)dirProject, NULL, VCCLID_BrowseInformation, VARIANT_TRUE, VCCFGID_IntermediateDirectory,
				this);
		if (hrT != S_OK)
			return hrT;
				
		VARIANT_BOOL bExpand = VARIANT_FALSE;
		
		if (spPropContainer->GetBoolProperty(VCCLID_ExpandAttributedSource, &bExpand) == S_OK && bExpand == VARIANT_TRUE)
		{
		   // .mrg.cpp and .mrg.h files -
			// only add to outputs if optioned on for this item
			// Not sure where compiler generates the mrg files, so remove
			// from both workspace directory and output directory
			// BruceMa 12-07-98
			HRESULT hrT = spAction->AddOutputFromDirectory((wchar_t *)(const wchar_t*)dirProject, pEC, 
				VCCLID_ExpandAttributedSource, L"mrg.cpp", -1, this);
			if (hrT != S_OK)
			{
				VSASSERT(FALSE, "Failed to add output for *.mrg.cpp");
				return hrT;
			}
			hrT = spAction->AddOutputFromDirectory((wchar_t *)(const wchar_t*)dirProject, pEC, VCCLID_ExpandAttributedSource, 
				L"mrg.h", -1, this);
			if (hrT != S_OK)
			{
				VSASSERT(FALSE, "Failed to add output for *.mrg.h");
				return hrT;
			}
			hrT = spAction->AddOutputInSubDirectory(bstrIntermediateDirectory, pEC, L".mrg.cpp", 
				(wchar_t *)(const wchar_t*)dirProject, NULL, -1, VARIANT_FALSE, VCCFGID_IntermediateDirectory, this);
			if (hrT != S_OK)
			{
				VSASSERT(FALSE, "Failed to add output for *.mrg.cpp");
				return hrT;
			}
			hrT = spAction->AddOutputInSubDirectory(bstrIntermediateDirectory, pEC, L".mrg.h", 
				(wchar_t *)(const wchar_t*)dirProject, NULL, -1, VARIANT_FALSE, VCCFGID_IntermediateDirectory, this);
			if (hrT != S_OK)
			{
				VSASSERT(FALSE, "Failed to add output for *.mrg.h");
				return hrT;
			}
		}

        // .i files - only add to outputs if optioned on for this item
		long lProp = 0;
		if (spPropContainer->GetIntProperty(VCCLID_GeneratePreprocessedFile, &lProp) == S_OK)
		{
			if (preprocessNo != (preprocessOption)lProp)
			{
				HRESULT hrT = spAction->AddOutputFromDirectory((wchar_t *)(const wchar_t*)dirProject, pEC, -1, L".i", -1, 
					this);
				if (hrT != S_OK)
				{
					VSASSERT(FALSE, "Failed to add output for preprocess file");
					return hrT;
				}
			}
		}
				
		// pdb files (both .pdb and .idb)
		CComBSTR bstrPdb;
		GetResolvedPdbName(spPropContainer, &bstrPdb);
		lProp = 0;
		if (spPropContainer->GetIntProperty(VCCLID_DebugInformationFormat, &lProp) == S_OK)
		{
			if ((debugOption)lProp == debugEditAndContinue)
			{
				spAction->AddOutputInSubDirectory(L"", pEC, L".pdb", (wchar_t *)(const wchar_t*)dirProject, bstrPdb, 
					-1 /* no enable id */, VARIANT_FALSE /* 2ndary output */, -1, this);
				// don't care about return value here for 2ndary output
			}
		}
		
		// Add idb for /Gm and/or /FD.
		spAction->AddOutputInSubDirectory(L"", pEC, L".idb", (wchar_t *)(const wchar_t*)dirProject, bstrPdb, 
			-1 /* no enable id */, FALSE /* 2ndary output */, -1, this);
		// don't care about return value here for 2ndary output

		// check to see if this file produces or uses a PCH file....
		// get the location of of the /Fp setting
		CPathW pathPch;

		// clear the .pch file dep. from the source deps...
		CBldFileRegSet * pfrs = NULL;
		spAction->get_SourceDependencies((void **)&pfrs);
		VSASSERT(pfrs != NULL, "No source dependencies for CL action");
		BldFileRegHandle frh;

		CBldFileRegistry* pRegistry = NULL;
		spAction->get_Registry((void **)&pRegistry);
		VSASSERT(pRegistry != NULL, "No registry associated with action");

		if (pfrs != NULL && pRegistry != NULL)
		{
			pfrs->InitFrhEnum();
			while ((frh = pfrs->NextFrh()) != (BldFileRegHandle)NULL)
			{
				const CPathW* pPath = pRegistry->GetRegEntry(frh)->GetFilePath();
				if (_wcsicmp(pPath->GetExtension(), L".pch") == 0)
				{
					// remove the .pch as a source dep.
					if (spAction->RemoveSourceDependencyForFrh((void *)frh, pEC) != S_OK)
						VSASSERT(FALSE, "Failed to remove a source dependency for an action");
					frh->ReleaseFRHRef();
					break;	// done!
				}
				frh->ReleaseFRHRef();
			}
		}

		CStringW strPch;
		CComBSTR bstrPch;
		if (s_optHandler.GetPCHName(spPropContainer, &bstrPch))
		{
			strPch = bstrPch;
			if (strPch.IsEmpty())
				continue;	// no pch name....
		}
		else
			continue;	// no PCH


		// add a possible .pch file dep.
		long lPchUse = 0;
		if (spPropContainer->GetIntProperty(VCCLID_UsePrecompiledHeader, &lPchUse) == S_OK)
		{
			if ((pchOption)lPchUse == pchCreateUsingSpecific || (pchOption)lPchUse == pchGenerateAuto)
			{
				if (pathPch.CreateFromDirAndFilename(dirProject, strPch))
				{
					pathPch.GetActualCase(TRUE);
					spAction->AddOutputFromPath((wchar_t *)(const wchar_t *)pathPch, pEC,
						(pchOption)lPchUse == pchCreateUsingSpecific ? VARIANT_TRUE : VARIANT_FALSE, // only a primary output for /Yc
						VARIANT_TRUE, VCCLID_PrecompiledHeaderFile, this);
				}
			}
			else if ((pchOption)lPchUse == pchUseUsingSpecific)
			{
				// add the .pch as a source dep.
				if (pathPch.CreateFromDirAndFilename(dirProject, strPch))
				{
					pathPch.GetActualCase(TRUE);
					CStringW strPath = pathPch;
					CComBSTR bstrPath = strPath;
					if (spAction->AddSourceDependencyFromString(bstrPath, pEC) != S_OK)
						VSASSERT(FALSE, "Failed to add dependency for stdafx.h file");
				}
			}
		}
	}

	return S_OK; // success
}

HRESULT CVCCLCompilerTool::GetPrimaryOutputFromTool(IUnknown* pItem, VARIANT_BOOL bSchmoozeOnly, CPathW& rPath)
{ 
	if (bSchmoozeOnly)
		return S_FALSE;	// not primary project output generator

	CComQIPtr<IVCPropertyContainer> spPropContainer = pItem;
	CComQIPtr<IVCBuildableItem> spBldableItem = pItem;
	if (spPropContainer == NULL || spBldableItem == NULL)
		return S_FALSE;

	CComBSTR bstrProjectDirectory;
	HRESULT hr = spPropContainer->GetStrProperty(VCPROJID_ProjectDirectory, &bstrProjectDirectory);	// should never have macros in it
	VSASSERT(hr == S_OK, "How did we manage to not get a project directory?!?");
	RETURN_ON_FAIL(hr);
	CStringW strProjDir = bstrProjectDirectory;
	CDirW dirProject;
	if (!dirProject.CreateFromKnown(strProjDir))
	{
		VSASSERT(FALSE, "Invalid project directory!");
		return CVCProjectEngine::DoSetErrorInfo(VCPROJ_E_INTERNAL_ERR, IDS_ERR_INTERNAL_ERROR);
	}

	BOOL bIsDir = TRUE;
	CComBSTR bstrObjFile;
	CStringW strInt;
	hr = spPropContainer->GetStrProperty(VCCLID_ObjectFile, &bstrObjFile);
	if (hr == S_OK)
	{
		spPropContainer->Evaluate(bstrObjFile, &bstrObjFile);
		CStringW strObjFile = bstrObjFile;
		int nObjLen = strObjFile.GetLength();
		if (nObjLen == 0)
			hr = S_FALSE;
		else if (strObjFile[nObjLen-1] == L'/' || strObjFile[nObjLen-1] == L'\\')
			strObjFile = strObjFile.Left(nObjLen-1);
		else
			bIsDir = FALSE;
		strInt = strObjFile;
	}
	if (hr != S_OK)		// NOT 'else' due to ability to change hr above...
	{
		CComBSTR bstrIntermediateDirectory;
		hr = spPropContainer->GetEvaluatedStrProperty(VCCFGID_IntermediateDirectory, &bstrIntermediateDirectory);
		if (FAILED(hr) || bstrIntermediateDirectory.Length() == 0)
			spPropContainer->GetEvaluatedStrProperty(VCCFGID_OutputDirectory, &bstrIntermediateDirectory);

		strInt = bstrIntermediateDirectory;
		int nlen = strInt.GetLength();
		if (nlen > 0 && (strInt[nlen-1] == L'/' || strInt[nlen-1] == L'\\'))
			strInt = strInt.Left(nlen-1);
	}

	if (bIsDir)
	{
		CPathW pathIntDir;
		if (!pathIntDir.CreateFromDirAndFilename(dirProject, strInt))
			return S_FALSE;

		CDirW dirIntDir;
		if (!dirIntDir.CreateFromPath(pathIntDir, TRUE))
			return S_FALSE;

		CComBSTR bstrItemName;
		if (FAILED(spBldableItem->get_ItemFileName(&bstrItemName)))
			return S_FALSE;

		if (!rPath.CreateFromDirAndFilename(dirIntDir, bstrItemName))
			return S_FALSE;
	}
	else if (!rPath.CreateFromDirAndFilename(dirProject, strInt))
		return S_FALSE;

	rPath.ChangeExtension(L".obj");
	return S_OK;
}

STDMETHODIMP CVCCLCompilerTool::HasPrimaryOutputFromTool(IUnknown* pItem, VARIANT_BOOL bSchmoozeOnly, VARIANT_BOOL* pbHasPrimaryOutput)
{ 
	CHECK_POINTER_NULL(pbHasPrimaryOutput);
	if (bSchmoozeOnly)
		*pbHasPrimaryOutput = VARIANT_FALSE;	// not primary project output generator
	else
		*pbHasPrimaryOutput = VARIANT_TRUE;	// looking for primary *file* output, so yes, we create one

	return S_OK;
}

STDMETHODIMP CVCCLCompilerTool::GetPrimaryOutputIDFromTool(IUnknown* pItem, VARIANT_BOOL bSchmoozeOnly, long* pnOutputID)
{
	CHECK_POINTER_NULL(pnOutputID);
	*pnOutputID = -1;

	if (bSchmoozeOnly)
		return S_FALSE;

	*pnOutputID = VCCLID_ObjectFile;
	return S_OK;
}

STDMETHODIMP CVCCLCompilerTool::SetPrimaryOutputForTool(IUnknown* pItem, BSTR bstrFile)
{	// sets the primary output for a tool
	CComQIPtr<IVCPropertyContainer> spPropContainer = pItem;
	RETURN_ON_NULL2(spPropContainer, S_FALSE);		// nothing we can do

	CStringW strFileCheck = bstrFile;
	strFileCheck.TrimLeft();
	strFileCheck.TrimRight();
	if (strFileCheck.IsEmpty())
		return S_FALSE;

	// assuming OK to dirty since we shouldn't be here unless we got called by a wizard that already checked
	return spPropContainer->SetStrProperty(VCCLID_ObjectFile, bstrFile);
}

STDMETHODIMP CVCCLCompilerTool::GetDefaultOutputFileFormat(IUnknown* pItem, BSTR* pbstrOutMacro)
{	// macro to use for generating default output file if the original default isn't unique
	CHECK_POINTER_NULL(pbstrOutMacro);
	CComBSTR bstrOutFormat = L"$(IntDir)/$(InputName)%d.obj";
	*pbstrOutMacro = bstrOutFormat.Detach();

	return S_OK;
}

void CVCCLCompilerTool::MakePdbAsFile(IVCPropertyContainer* pPropContainer, CComBSTR& bstrPdb)
{
	if (FAILED(pPropContainer->Evaluate(bstrPdb, &bstrPdb)))
		return;

	CStringW strPdb = bstrPdb;
	strPdb.TrimRight();
	int nLen = strPdb.GetLength();

	if (nLen == 0)
	{
		bstrPdb = strPdb;
		return;
	}

	if (strPdb.GetAt(nLen-1) == L'/' || strPdb.GetAt(nLen-1) == L'\\')
	{	// definitely just a directory
		strPdb += CBldAction::s_szDefVCFile;
		bstrPdb = strPdb;
		return;
	}

	if (strPdb.GetAt(nLen-4) == L'.')
		return;	// already have an extension there

	if (wcsncmp(strPdb, L"./", 2) == 0 || wcsncmp(strPdb, L".\\", 2) == 0)	// strip any leading ./
	{
		strPdb = strPdb.Right(nLen-2);
		nLen -= 2;
	}

	// cheat and see if we're in the intermediate or output directory
	if (CheckPathAgainstDir(pPropContainer, VCCFGID_IntermediateDirectory, strPdb, bstrPdb))
		return;

	if (CheckPathAgainstDir(pPropContainer, VCCFGID_OutputDirectory, strPdb, bstrPdb))
		return;

	// if we get here, just gotta assume it's a file...
}

BOOL CVCCLCompilerTool::CheckPathAgainstDir(IVCPropertyContainer* pPropContainer, long id, CStringW& strPdb, 
	CComBSTR& bstrPdb)
{
	CComBSTR bstrDir;
	pPropContainer->GetEvaluatedStrProperty(id, &bstrDir);
	CStringW strDir = bstrDir;
	int nDirLen = strDir.GetLength();
	if (nDirLen == 0)	// nothing there, nothing we can do
		return FALSE;

	if (strDir.GetAt(nDirLen-1) == L'/' || strDir.GetAt(nDirLen-1) == L'\\')
	{
		strDir = strDir.Left(nDirLen-1);	// strip any trailing slash
		nDirLen -= 1;
	}

	if (wcsncmp(strDir, L"./", 2) == 0 || wcsncmp(strDir, L".\\", 2) == 0)
	{
		strDir = strDir.Right(nDirLen-2);
		nDirLen -= 2;
	}

	if (wcsicmp(strDir, strPdb) == 0)	// same thing
	{
		strPdb += L"/";
		strPdb += CBldAction::s_szDefVCFile;
		bstrPdb = strPdb;
		return TRUE;
	}

	return FALSE;
}

STDMETHODIMP CVCCLCompilerTool::AffectsOutput(long nPropID, VARIANT_BOOL* pbAffectsOutput)
{
	CHECK_POINTER_NULL(pbAffectsOutput);
	*pbAffectsOutput = VARIANT_FALSE;

	switch (nPropID)
	{
	case VCCLID_BrowseInformation:	// enables *.sbr
	case VCCLID_BrowseInformationFile:
	case VCCLID_UsePrecompiledHeader:	// enable *.pch
	case VCCLID_PrecompiledHeaderThrough:
	case VCCLID_PrecompiledHeaderFile:
	case VCCLID_ObjectFile:
	case VCCLID_ProgramDataBaseFileName:
	case VCCLID_DebugInformationFormat:	// enables *.pdb
	case VCCLID_OutputsDirty:	// just a recheck on getting the output regenerated
	case VCFCFGID_ExcludedFromBuild:	// .obj included/excluded from build
		*pbAffectsOutput = VARIANT_TRUE;
		break;
	default:
		*pbAffectsOutput = VARIANT_FALSE;
		break;
	}

	return S_OK;
}

CBldCmdSet* CVCCLCompilerTool::GetCommandLineMatch(CVCPtrList& cmdSet, CStringW& rstrCmd)
{
	VCPOSITION pos = cmdSet.GetHeadPosition();
	while (pos != NULL)
	{
		CBldCmdSet* pSet = (CBldCmdSet *)cmdSet.GetNext(pos);
		if (rstrCmd == pSet->m_strCommandLine)
			return pSet;
	}

	return NULL;
}

/* static */
void CVCCLCompilerTool::RefreshResolvedPdbName(IVCPropertyContainer* pPropContainer, BOOL bForce /* = FALSE */)
{
	CComVariant var;
	if (!bForce && pPropContainer->GetProp(VCCLID_ResolvedPdbName, &var) == S_OK)
		return;

	CComBSTR bstrPdb;
	if (pPropContainer->GetStrProperty(VCCLID_ProgramDataBaseFileName, &bstrPdb) == S_OK)
		MakePdbAsFile(pPropContainer, bstrPdb);
	else
	{
		s_optHandler.GetDefaultValue( VCCLID_ProgramDataBaseFileName, &bstrPdb, pPropContainer );
		pPropContainer->Evaluate(bstrPdb, &bstrPdb);
	}
	CComBSTR bstrProjDir;
	if (pPropContainer->GetStrProperty(VCPROJID_ProjectDirectory, &bstrProjDir) != S_OK)
		return;
	CDirW dirProj;
	if (!dirProj.CreateFromKnown(bstrProjDir))
		return;
	CPathW pathPdb;
	if (!pathPdb.CreateFromDirAndFilename(dirProj, bstrPdb))
		return;
	CStringW strExt = pathPdb.GetExtension();
	if (strExt.IsEmpty())
		pathPdb.ChangeExtension(L".pdb");
	CStringW strPdb = pathPdb;
	bstrPdb = strPdb;

	// want this set at the PROJECT config level, not the FILE config level
	CComQIPtr<IVCFileConfigurationImpl> spFileCfgImpl = pPropContainer;
	if (spFileCfgImpl != NULL)
	{
		CComPtr<IDispatch> spDispProjCfg;
		if (SUCCEEDED(spFileCfgImpl->get_Configuration(&spDispProjCfg)))
		{
			CComQIPtr<IVCPropertyContainer> spParentContainer = spDispProjCfg;
			if (spParentContainer)
				spParentContainer->SetStrProperty(VCCLID_ResolvedPdbName, bstrPdb);
		}
	}
	else
		pPropContainer->SetStrProperty(VCCLID_ResolvedPdbName, bstrPdb);
}

/* static */
void CVCCLCompilerTool::ClearResolvedPdbName(IVCPropertyContainer* pPropContainer)
{
	pPropContainer->Clear(VCCLID_ResolvedPdbName);
}

/* static */
HRESULT CVCCLCompilerTool::GetResolvedPdbName(IVCPropertyContainer* pPropContainer, BSTR* pbstrName)
{
	*pbstrName = NULL;
	RefreshResolvedPdbName(pPropContainer);
	return pPropContainer->GetStrProperty(VCCLID_ResolvedPdbName, pbstrName);
}

STDMETHODIMP CVCCLCompilerTool::GetCommandLinesForBuild(IVCBuildActionList* pActions, bldAttributes attrib, 
	IVCBuildEngine* pBuildEngine, IVCBuildErrorContext* pEC, IVCCommandLineList** ppCmds)
{
	CHECK_POINTER_NULL(ppCmds);
	*ppCmds = NULL;

	RETURN_ON_NULL2(pActions, S_FALSE);

	// generate C/C++ command-line set
	BOOL bHaveBaseCmdLine = FALSE;
	CVCPtrList cmdSet;

	HRESULT hr = S_OK;
	pActions->Reset(NULL);
	s_optHandler.InitializeFlags();
	while (hr == S_OK)
	{
		CComPtr<IVCBuildAction> spAction;
		hr = pActions->Next(&spAction, NULL);
		BREAK_ON_DONE(hr);
		ASSERT_AND_CONTINUE_ON_NULL(spAction);

		CComPtr<IVCBuildableItem> spBuildableItem;
		HRESULT hr1 = spAction->get_Item(&spBuildableItem);
		ASSERT_AND_CONTINUE_ON_FAIL_OR_NULL(hr1, spBuildableItem);

		CComQIPtr<IVCPropertyContainer> spPropContainer = spBuildableItem;
		VSASSERT(spPropContainer != NULL, "Action has no property container associated with it.  Bad initialization.");
		if (spPropContainer == NULL)
			continue;

		VARIANT_BOOL bHaveLocalStorage = VARIANT_TRUE;
		CBldCmdSet* pSet = NULL;
		CompileAsOptions compileAs = s_optHandler.GetDefaultCompileAs(spPropContainer, TRUE /* check explicit */);
		BOOL bLocalStorage = (SUCCEEDED(spPropContainer->HasLocalStorage(VARIANT_FALSE /*not for save*/, &bHaveLocalStorage)) 
			&& bHaveLocalStorage == VARIANT_TRUE);
		if (!bLocalStorage)
		{
			if (bHaveBaseCmdLine)
			{
				pSet = (CBldCmdSet *)cmdSet.GetHead();
				VSASSERT(pSet != NULL, "Failed to get any values of out command set");
				if (pSet == NULL)
					bLocalStorage = TRUE;	// need to generate this after all
				else if (pSet->m_compileAs != compileAs)
					bLocalStorage = TRUE;	// not the same as what we're calling our default, so need to generate after all
			}
			else
			{
				bHaveBaseCmdLine = TRUE;
				pSet = new CBldCmdSet;
				RETURN_ON_NULL2(pSet, E_OUTOFMEMORY);
				hr = GetCommandLineOptions(spBuildableItem, spAction, VARIANT_TRUE /* include additional options */, 
					VARIANT_FALSE /* !for display */, cmdLineForBuild, pSet->m_strCommandLine);
				pchOption usePCH = pchNone;
				if (spPropContainer->GetIntProperty(VCCLID_UsePrecompiledHeader, (long *)&usePCH) == S_OK 
					&& usePCH == pchCreateUsingSpecific)
					pSet->m_bMakeFirst = TRUE;
				pSet->m_compileAs = compileAs;
				cmdSet.AddHead(pSet);
			}
		}

		if (bLocalStorage)
		{
			CStringW strCommandLine;
			hr = GetCommandLineOptions(spBuildableItem, spAction, VARIANT_TRUE /* include additional options */, 
				VARIANT_FALSE /* !for display */, cmdLineForBuild, strCommandLine);
			if (SUCCEEDED(hr))
			{
				pSet = GetCommandLineMatch(cmdSet, strCommandLine);
				if (pSet == NULL)
				{
					pSet = new CBldCmdSet;
					RETURN_ON_NULL2(pSet, E_OUTOFMEMORY);
					pSet->m_strCommandLine = strCommandLine;
					pchOption usePCH = pchNone;
					if (spPropContainer->GetIntProperty(VCCLID_UsePrecompiledHeader, (long *)&usePCH) == S_OK 
						&& usePCH == pchCreateUsingSpecific)
						pSet->m_bMakeFirst = TRUE;
					pSet->m_compileAs = compileAs;
					cmdSet.AddTail(pSet);
				}
			}
		}
		if (SUCCEEDED(hr) && pSet != NULL)
		{
			CComBSTR bstrFile;
			spAction->GetRelativePathsToInputs(FALSE, TRUE, pEC, &bstrFile);
			CStringW strFile = bstrFile;
			pSet->m_strFilesList.AddTail(strFile);
		}
		VSASSERT(SUCCEEDED(hr), "Failed to pick up command line options");

	}

	if (FAILED(hr) && cmdSet.IsEmpty())
		return hr;

	else if (cmdSet.IsEmpty())
		return S_FALSE;

	else if (SUCCEEDED(hr))
	{
		CComBSTR bstrDescription;
		GetBuildDescription(NULL, &bstrDescription);

		CComBSTR bstrToolExe;
		hr = get_ToolPathInternal(&bstrToolExe);	// safe since we don't change the tool path on a per file cfg basis...
		VSASSERT(SUCCEEDED(hr), "Tool doesn't have a path.  Deep trouble.");

		hr = CVCCommandLineList::CreateInstance(ppCmds);
		VSASSERT(SUCCEEDED(hr), "Failed to create a command set;  out of memory?");
		if (SUCCEEDED(hr) && *ppCmds != NULL)
		{
			(*ppCmds)->put_UseConsoleCodePageForSpawner(VARIANT_TRUE /* want console CP */);
			CComPtr<IVCBuildAction> spAction;
			pActions->get_LastAction(&spAction);
			while (!cmdSet.IsEmpty() && SUCCEEDED(hr))
			{
				CBldCmdSet* pSet = (CBldCmdSet *)cmdSet.RemoveHead();
				while (!pSet->m_strFilesList.IsEmpty())
					s_optHandler.AdvanceCommandLine(pSet->m_strCommandLine, pSet->m_strFilesList.RemoveHead(), L"\n");
	
				CComPtr<IVCCommandLine> spCmdLine;
				hr = CVCCommandLine::CreateInstance(&spCmdLine);
				ASSERT_AND_CONTINUE_ON_FAIL_OR_NULL(hr, spCmdLine);

				CComBSTR bstrCmdLineIn = pSet->m_strCommandLine;
				CComBSTR bstrCmdLineOut;
				if (pBuildEngine != NULL)
					hr = pBuildEngine->FormCommandLine(bstrToolExe, bstrCmdLineIn, pEC, TRUE, TRUE, &bstrCmdLineOut);
				if (FAILED(hr) || pBuildEngine == NULL)
				{
					VSASSERT(SUCCEEDED(hr), "Failed to form command line");
					hr = S_OK;
					bstrCmdLineOut = bstrCmdLineIn;
				}
				spCmdLine->put_CommandLineContents(bstrCmdLineOut);
				spCmdLine->put_Description(bstrDescription);
				spCmdLine->put_NumberOfProcessors(1);

				(*ppCmds)->Add(spCmdLine, pSet->m_bMakeFirst);
				delete pSet;
			}
		}

		while (!cmdSet.IsEmpty())
		{
			CBldCmdSet* pSet = (CBldCmdSet *)cmdSet.RemoveHead();
			delete pSet;
		}
	}

	RETURN_ON_FAIL(hr);

	return S_OK;
}

STDMETHODIMP CVCCLCompilerTool::HasDependencies(IVCBuildAction* pBldAction, VARIANT_BOOL* pbHasDependencies)
{
	CHECK_POINTER_NULL(pbHasDependencies);
	*pbHasDependencies = VARIANT_TRUE;	// we've got this set up so that the user *cannot* turn dependencies off...
	return S_OK;
}

STDMETHODIMP CVCCLCompilerTool::GetDependencies(IVCBuildAction* pBldAction, IVCBuildStringCollection** ppStrings, 
	VARIANT_BOOL* bUpToDate)
{
	RETURN_ON_NULL2(pBldAction, E_UNEXPECTED);

	CHECK_POINTER_NULL(ppStrings);
	*ppStrings = NULL;

	CComPtr<IVCBuildableItem> spItem;
	pBldAction->get_Item(&spItem);
#ifdef _DEBUG
	CComQIPtr<VCFileConfiguration> spFileCfg = spItem;
	VSASSERT(spFileCfg != NULL, "File config without IVCFileConfigurationImpl?");
#endif	// _DEBUG
	RETURN_ON_NULL2(spItem, E_UNEXPECTED);

	BldFileRegHandle frh = NULL;
	spItem->get_FileRegHandle((void **)&frh);
	VSASSERT(frh != NULL, "*All* items CL operates on are files.  All files better have reg handles.");
	VSASSERT(frh->IsNodeType(CBldFileRegNotifyRx::nodetypeRegFile), "Reg handle is not for file.  Bad object fed to CL.");
	CBldFileRegFile* frf = (CBldFileRegFile*)g_FileRegistry.GetRegEntry(frh);

	// Get filename of source file.
	const CPathW* pPath = frf->GetFilePath();

	CComBSTR bstrIdb;
	CComPtr<VCConfiguration> spProjCfg;
	spItem->get_ProjectConfiguration(&spProjCfg);
	CComQIPtr<IVCConfigurationImpl> spProjCfgImpl = spProjCfg;
	if (spProjCfgImpl != NULL)
		spProjCfgImpl->get_MrePath(&bstrIdb);

	BOOL bHasDepend = FALSE;

	// Minimal rebuild dependency interface.
	IBldMreDependencies* pMreDepend = IBldMreDependencies::GetMreDependenciesIFace(bstrIdb);
	if (NULL != pMreDepend)
	{
		//
		// Does this file use the pch?
		//
		VARIANT_BOOL bUsePch = VARIANT_FALSE;
		CComQIPtr<IVCPropertyContainer> spPropContainer = spItem;
		if (spPropContainer != NULL)
		{
			pchOption usePCH = pchNone;
			if (spPropContainer->GetIntProperty(VCCLID_UsePrecompiledHeader, (long *)&usePCH) == S_OK && usePCH == pchUseUsingSpecific)
				bUsePch = VARIANT_TRUE;	
		}

//		SuspendCAP();
		CStringW strPath;
		pPath->GetFullPath(strPath);

		CVCBuildStringCollection* pStringColl;
		HRESULT hr1 = CVCBuildStringCollection::CreateInstance(ppStrings, &pStringColl);
		if (SUCCEEDED(hr1))
			bHasDepend = pMreDepend->GetDependencies(strPath, pStringColl, bUsePch == VARIANT_TRUE);

//		ResumeCAP();
		pMreDepend->Release();
	}

	// Are dependencies up-to-date?
	if (NULL != bUpToDate)
	{
		*bUpToDate = FALSE;
	}
	return bHasDepend ? S_OK : S_FALSE;
}

STDMETHODIMP CVCCLCompilerTool::CanScanForDependencies(VARIANT_BOOL* pbIsScannable)
{
	return COptionHandlerBase::GetValueTrue(pbIsScannable);
}

STDMETHODIMP CVCCLCompilerTool::GetDeploymentDependencies(IVCBuildAction* pAction, IVCBuildStringCollection** ppDeployDepStrings)
{
	RETURN_ON_NULL2(pAction, S_FALSE);

	CComPtr<IVCBuildableItem> spItem;
	pAction->get_Item(&spItem);
#ifdef _DEBUG
	CComQIPtr<VCFileConfiguration> spFileCfg = spItem;
	VSASSERT(spFileCfg != NULL, "File config without IVCFileConfigurationImpl?");
#endif	// _DEBUG
	RETURN_ON_NULL2(spItem, E_UNEXPECTED);

	BldFileRegHandle frh = NULL;
	spItem->get_FileRegHandle((void **)&frh);
	VSASSERT(frh != NULL, "*All* items CL operates on are files.  All files better have reg handles.");
	VSASSERT(frh->IsNodeType(CBldFileRegNotifyRx::nodetypeRegFile), "Reg handle is not for file.  Bad object fed to CL.");
	CBldFileRegFile* frf = (CBldFileRegFile*)g_FileRegistry.GetRegEntry(frh);

	// Get filename of source file.
	const CPathW* pPath = frf->GetFilePath();

	// Minimal rebuild dependency interface.
	CComBSTR bstrIdb;
	CComPtr<VCConfiguration> spProjCfg;
	spItem->get_ProjectConfiguration(&spProjCfg);
	CComQIPtr<IVCConfigurationImpl> spProjCfgImpl = spProjCfg;
	if (spProjCfgImpl != NULL)
		spProjCfgImpl->get_MrePath(&bstrIdb);

	IBldMreDependencies* pMreDepend = IBldMreDependencies::GetMreDependenciesIFace(bstrIdb);

	CComPtr<IVCBuildStringCollection> spStrings;
	CVCBuildStringCollection* pStringColl = NULL;
	if (NULL != pMreDepend)
	{
		CStringW strPath;
		pPath->GetFullPath(strPath);

		HRESULT hr1 = S_OK;
		if (pStringColl == NULL)
			hr1 = CVCBuildStringCollection::CreateInstance(&spStrings, &pStringColl);
		if (SUCCEEDED(hr1))
			pMreDepend->GetDeploymentDependencies(strPath, pStringColl);

		pMreDepend->Release();
	}

	if (pStringColl && pStringColl->m_strStrings.GetSize() > 0)	// we actually had something to worry about
	{
		if (*ppDeployDepStrings == NULL)
			*ppDeployDepStrings = spStrings.Detach();
		else
		{
			INT_PTR cDeps = pStringColl->m_strStrings.GetSize();
			for (INT_PTR idx = 0; idx < cDeps; idx++)
			{
				CStringW strDep = pStringColl->m_strStrings.GetAt(idx);
				if (strDep.IsEmpty())
					continue;
				CComBSTR bstrDep = strDep;
				(*ppDeployDepStrings)->Add(bstrDep);
			}
		}
	}

	return S_OK;
}

STDMETHODIMP CVCCLCompilerTool::CreatePageObject(IUnknown **ppUnk, CLSID*pCLSID, IVCPropertyContainer *pPropCntr, IVCSettingsPage *pPage )
{
	// Get the list of pages
	if( CLSID_ClGeneral == *pCLSID )
	{
		CPageObjectImpl<CVCCLCompilerGeneralPage,VCCLCOMPILERTOOL_MIN_DISPID,VCCLCOMPILERTOOL_MAX_DISPID >::CreateInstance(ppUnk, pPropCntr, pPage);
	}
	else if( CLSID_ClOptimization == *pCLSID )
	{
		CPageObjectImpl< CVCCLCompilerOptimizationPage,VCCLCOMPILERTOOL_MIN_DISPID,VCCLCOMPILERTOOL_MAX_DISPID >::CreateInstance(ppUnk, pPropCntr, pPage);
	}
	else if( CLSID_ClPreprocessor == *pCLSID )
	{
		CPageObjectImpl< CVCCLCompilerPreProcessorPage,VCCLCOMPILERTOOL_MIN_DISPID,VCCLCOMPILERTOOL_MAX_DISPID >::CreateInstance(ppUnk, pPropCntr, pPage);
	}
	else if( CLSID_ClAdvanced == *pCLSID )
	{
		CPageObjectImpl< CVCCLCompilerAdvancedPage,VCCLCOMPILERTOOL_MIN_DISPID,VCCLCOMPILERTOOL_MAX_DISPID >::CreateInstance(ppUnk, pPropCntr, pPage);
	}
	else if( CLSID_ClCodeGeneration == *pCLSID )
	{
		CPageObjectImpl< CVCCLCompilerCodeGenPage,VCCLCOMPILERTOOL_MIN_DISPID,VCCLCOMPILERTOOL_MAX_DISPID >::CreateInstance(ppUnk, pPropCntr, pPage);
	}
	else if( CLSID_ClLanguage == *pCLSID )
	{
		CPageObjectImpl< CVCCLCompilerLanguagePage,VCCLCOMPILERTOOL_MIN_DISPID,VCCLCOMPILERTOOL_MAX_DISPID >::CreateInstance(ppUnk, pPropCntr, pPage);
	}
	else if( CLSID_ClPrecompiledHeaders == *pCLSID )
	{
		CPageObjectImpl< CVCCLCompilerPCHPage,VCCLCOMPILERTOOL_MIN_DISPID,VCCLCOMPILERTOOL_MAX_DISPID >::CreateInstance(ppUnk, pPropCntr, pPage);
	}
	else if( CLSID_ClOutputFiles == *pCLSID )
	{
		CPageObjectImpl< CVCCLCompilerOutputPage,VCCLCOMPILERTOOL_MIN_DISPID,VCCLCOMPILERTOOL_MAX_DISPID >::CreateInstance(ppUnk, pPropCntr, pPage);
	}
	else if( CLSID_ClBrowseInfo == *pCLSID )
	{
		CPageObjectImpl< CVCCLCompilerBrowsePage,VCCLCOMPILERTOOL_MIN_DISPID,VCCLCOMPILERTOOL_MAX_DISPID >::CreateInstance(ppUnk, pPropCntr, pPage);
	}
	else
	{
		return S_FALSE;
	}
		
	return S_OK;
}

// general
STDMETHODIMP CVCCLCompilerTool::get_AdditionalOptions(BSTR* pbstrAdditionalOptions)
{	// anything we don't know what to do with, given verbatim, in same order as entered, parent contributions first, goes after all other options
	return ToolGetStrProperty(VCCLID_AdditionalOptions, pbstrAdditionalOptions);
}

STDMETHODIMP CVCCLCompilerTool::put_AdditionalOptions(BSTR bstrAdditionalOptions)
{
	CHECK_ZOMBIE( m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE );
	return m_spPropertyContainer->SetStrProperty(VCCLID_AdditionalOptions, bstrAdditionalOptions);
}

STDMETHODIMP CVCCLCompilerTool::get_ToolName(BSTR* pbstrToolName)
{	// friendly name of tool, e.g., "C/C++ Compiler Tool"
	CHECK_POINTER_VALID(pbstrToolName);
	InitToolName();
	s_bstrToolName.CopyTo(pbstrToolName);
	return S_OK;
}

STDMETHODIMP CVCCLCompilerTool::get_WarningLevel(warningLevelOption* poptSetting)
{	// see enum above (/W0 - /W4)
	return ToolGetIntProperty(VCCLID_WarningLevel, (long *)poptSetting);
}

STDMETHODIMP CVCCLCompilerTool::put_WarningLevel(warningLevelOption optSetting)
{
	CHECK_ZOMBIE( m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE );
	CHECK_BOUNDS(StdEnumMin, CLWarnMax, optSetting);
	return m_spPropertyContainer->SetIntProperty(VCCLID_WarningLevel, optSetting);
}

STDMETHODIMP CVCCLCompilerTool::get_WarnAsError(VARIANT_BOOL* pbWarnAsError)
{	// (/WX, /WX-) treat warnings as errors
	return ToolGetBoolProperty(VCCLID_WarnAsError, pbWarnAsError);
}

STDMETHODIMP CVCCLCompilerTool::put_WarnAsError(VARIANT_BOOL bWarnAsError)
{
	CHECK_ZOMBIE( m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE );
	CHECK_VARIANTBOOL( bWarnAsError );
	return m_spPropertyContainer->SetBoolProperty(VCCLID_WarnAsError, bWarnAsError);
}

STDMETHODIMP CVCCLCompilerTool::get_SuppressStartupBanner(VARIANT_BOOL* pbNoLogo)
{	// (/nologo, /nologo-) enable/disable suppression of copyright message
	return ToolGetBoolProperty(VCCLID_SuppressStartupBanner,pbNoLogo );
}

STDMETHODIMP CVCCLCompilerTool::put_SuppressStartupBanner(VARIANT_BOOL bNoLogo)
{
	CHECK_ZOMBIE( m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE );
	CHECK_VARIANTBOOL( bNoLogo );
	return m_spPropertyContainer->SetBoolProperty(VCCLID_SuppressStartupBanner, bNoLogo);
}

STDMETHODIMP CVCCLCompilerTool::get_Detect64BitPortabilityProblems(VARIANT_BOOL* pbDetect64BitPortabilityProblems)
{	// (/Wp64) detect 64 bit portability problems
	return ToolGetBoolProperty(VCCLID_Detect64BitPortabilityProblems, pbDetect64BitPortabilityProblems);
}

STDMETHODIMP CVCCLCompilerTool::put_Detect64BitPortabilityProblems(VARIANT_BOOL bDetect64BitPortabilityProblems)
{
	CHECK_ZOMBIE( m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE );
	CHECK_VARIANTBOOL( bDetect64BitPortabilityProblems );
	return m_spPropertyContainer->SetBoolProperty(VCCLID_Detect64BitPortabilityProblems, bDetect64BitPortabilityProblems);
}

STDMETHODIMP CVCCLCompilerTool::get_DebugInformationFormat(debugOption* poptSetting)
{	// see enum above (/Z7, Zd, /ZI, /Zi)
	return ToolGetIntProperty(VCCLID_DebugInformationFormat, (long *)poptSetting);
}

STDMETHODIMP CVCCLCompilerTool::put_DebugInformationFormat(debugOption optSetting)
{
	CHECK_ZOMBIE( m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE );
	CHECK_BOUNDS(StdEnumMin, DebugInfoMax, optSetting);
	return m_spPropertyContainer->SetIntProperty(VCCLID_DebugInformationFormat, optSetting);
}

STDMETHODIMP CVCCLCompilerTool::get_CompileAsManaged(compileAsManagedOptions* poptSetting)
{ 
	return ToolGetIntProperty(VCCLID_CompileAsManaged, (long *)poptSetting);
}

STDMETHODIMP CVCCLCompilerTool::put_CompileAsManaged(compileAsManagedOptions optSetting)
{
	CHECK_ZOMBIE( m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE );
	CHECK_BOUNDS(StdEnumMin, ComRTMax, optSetting);
	return m_spPropertyContainer->SetIntProperty(VCCLID_CompileAsManaged, optSetting);
}

STDMETHODIMP CVCCLCompilerTool::get_AdditionalIncludeDirectories(BSTR* pbstrIncludePath)
{	// (/I![path]) directory to add to include path, may have multiple
	return ToolGetStrProperty(VCCLID_AdditionalIncludeDirectories, pbstrIncludePath, true /* local only */);
}

STDMETHODIMP CVCCLCompilerTool::put_AdditionalIncludeDirectories(BSTR bstrIncludePath)
{
	CHECK_ZOMBIE( m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE );
	return m_spPropertyContainer->SetStrProperty(VCCLID_AdditionalIncludeDirectories, bstrIncludePath);
}

STDMETHODIMP CVCCLCompilerTool::get_AdditionalUsingDirectories(BSTR* pbstrIncludePath)
{	// (/AI![path]) directory to add to LIBPATH path, may have multiple
	return ToolGetStrProperty(VCCLID_AdditionalUsingDirectories, pbstrIncludePath, true /* local only */);
}

STDMETHODIMP CVCCLCompilerTool::put_AdditionalUsingDirectories(BSTR bstrIncludePath)
{
	CHECK_ZOMBIE( m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE );
	return m_spPropertyContainer->SetStrProperty(VCCLID_AdditionalUsingDirectories, bstrIncludePath);
}

// Optimization
STDMETHODIMP CVCCLCompilerTool::get_Optimization(optimizeOption* poptSetting)
{	// see enum above (/O1, /O2, /Od, /Ox)
	return ToolGetIntProperty(VCCLID_Optimization, (long*)poptSetting);
}

STDMETHODIMP CVCCLCompilerTool::put_Optimization(optimizeOption optSetting)
{
	CHECK_ZOMBIE( m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE );
	CHECK_BOUNDS(StdEnumMin, OptimizeMax, optSetting);
	return m_spPropertyContainer->SetIntProperty(VCCLID_Optimization, optSetting);
}

STDMETHODIMP CVCCLCompilerTool::get_GlobalOptimizations(VARIANT_BOOL* pbGlobalOpt)
{ 	// (/Og, /Og-) enable/disable global optimizations incompatible with all RTC options, GZ, ZI, EEf
	return ToolGetBoolProperty(VCCLID_GlobalOptimizations, pbGlobalOpt);
}

STDMETHODIMP CVCCLCompilerTool::put_GlobalOptimizations(VARIANT_BOOL bGlobalOpt)
{
	CHECK_ZOMBIE( m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE );
	CHECK_VARIANTBOOL( bGlobalOpt );
	return m_spPropertyContainer->SetBoolProperty(VCCLID_GlobalOptimizations, bGlobalOpt);
}

STDMETHODIMP CVCCLCompilerTool::get_InlineFunctionExpansion(inlineExpansionOption* poptSetting)
{	// see enum above (/Ob0, /Ob1, /Ob2)
	return ToolGetIntProperty(VCCLID_InlineFunctionExpansion, (long *)poptSetting);
}

STDMETHODIMP CVCCLCompilerTool::put_InlineFunctionExpansion(inlineExpansionOption optSetting)
{
	CHECK_ZOMBIE( m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE );
	CHECK_BOUNDS(StdEnumMin, InlineMax, optSetting);
	return m_spPropertyContainer->SetIntProperty(VCCLID_InlineFunctionExpansion, optSetting);
}

STDMETHODIMP CVCCLCompilerTool::get_EnableIntrinsicFunctions(VARIANT_BOOL* pbEnableIntrinsic)
{	// (/Oi, /Oi-) enable/disable intrinsic functions works best with /Og
	return ToolGetBoolProperty(VCCLID_EnableIntrinsicFunctions, pbEnableIntrinsic);
}

STDMETHODIMP CVCCLCompilerTool::put_EnableIntrinsicFunctions(VARIANT_BOOL bEnableIntrinsic)
{
	CHECK_ZOMBIE( m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE );
	CHECK_VARIANTBOOL( bEnableIntrinsic );
	return m_spPropertyContainer->SetBoolProperty(VCCLID_EnableIntrinsicFunctions, bEnableIntrinsic);
}

STDMETHODIMP CVCCLCompilerTool::get_ImproveFloatingPointConsistency(VARIANT_BOOL* pbImproveFloat)
{	// (/Op, /Op-) (don't) improve floating-point consistency
	return ToolGetBoolProperty(VCCLID_ImproveFloatingPointConsistency, pbImproveFloat);
}

STDMETHODIMP CVCCLCompilerTool::put_ImproveFloatingPointConsistency(VARIANT_BOOL bImproveFloat)
{
	CHECK_ZOMBIE( m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE );
	CHECK_VARIANTBOOL( bImproveFloat );
	return m_spPropertyContainer->SetBoolProperty(VCCLID_ImproveFloatingPointConsistency, bImproveFloat);
}

STDMETHODIMP CVCCLCompilerTool::get_FavorSizeOrSpeed(favorSizeOrSpeedOption* poptSetting)
{	// (/Os, Ot) favor size/speed works best with /Og
	return ToolGetIntProperty(VCCLID_FavorSizeOrSpeed, (long *)poptSetting);
}

STDMETHODIMP CVCCLCompilerTool::put_FavorSizeOrSpeed(favorSizeOrSpeedOption optSetting)
{
	CHECK_ZOMBIE( m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE );
	CHECK_BOUNDS(StdEnumMin, CodeGenMax, optSetting);
	return m_spPropertyContainer->SetIntProperty(VCCLID_FavorSizeOrSpeed, optSetting);
}

STDMETHODIMP CVCCLCompilerTool::get_OmitFramePointers(VARIANT_BOOL* poptSetting)
{	// (/Oy, Oy-) enable/disable frame pointer omission
	return ToolGetBoolProperty(VCCLID_OmitFramePointers, poptSetting);
}

STDMETHODIMP CVCCLCompilerTool::put_OmitFramePointers(VARIANT_BOOL optSetting)
{
	CHECK_ZOMBIE( m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE );
	CHECK_VARIANTBOOL( optSetting );
	return m_spPropertyContainer->SetBoolProperty(VCCLID_OmitFramePointers, optSetting);
}

STDMETHODIMP CVCCLCompilerTool::get_EnableFiberSafeOptimizations(VARIANT_BOOL* pbFiberSafeTLS)
{	// (/GT) generate fiber-safe TLS accesses
	return ToolGetBoolProperty(VCCLID_EnableFiberSafeOptimizations, pbFiberSafeTLS);
}

STDMETHODIMP CVCCLCompilerTool::put_EnableFiberSafeOptimizations(VARIANT_BOOL bFiberSafeTLS)
{
	CHECK_ZOMBIE( m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE );
	CHECK_VARIANTBOOL( bFiberSafeTLS );
	return m_spPropertyContainer->SetBoolProperty(VCCLID_EnableFiberSafeOptimizations, bFiberSafeTLS);
}

STDMETHODIMP CVCCLCompilerTool::get_WholeProgramOptimization(VARIANT_BOOL* pbWholeProgOp)
{	// (/GL) Perform whole program optimization during the link phase
	return ToolGetBoolProperty(VCCLID_WholeProgramOptimization, pbWholeProgOp);
}

STDMETHODIMP CVCCLCompilerTool::put_WholeProgramOptimization(VARIANT_BOOL bWholeProgOp)
{
	CHECK_ZOMBIE( m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE );
	CHECK_VARIANTBOOL( bWholeProgOp );
	return m_spPropertyContainer->SetBoolProperty(VCCLID_WholeProgramOptimization, bWholeProgOp);
}

STDMETHODIMP CVCCLCompilerTool::get_OptimizeForProcessor(ProcessorOptimizeOption* poptSetting)
{ 
	return ToolGetIntProperty(VCCLID_OptimizeForProcessor, (long *)poptSetting);
}

STDMETHODIMP CVCCLCompilerTool::put_OptimizeForProcessor(ProcessorOptimizeOption optSetting)
{
	CHECK_ZOMBIE( m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE );
	CHECK_BOUNDS(StdEnumMin, OptProcMax, optSetting);
	return m_spPropertyContainer->SetIntProperty(VCCLID_OptimizeForProcessor, optSetting);
}

STDMETHODIMP CVCCLCompilerTool::get_OptimizeForWindowsApplication(VARIANT_BOOL* poptSetting)
{ 
	return ToolGetBoolProperty(VCCLID_OptimizeForWindowsApplication, poptSetting);
}

STDMETHODIMP CVCCLCompilerTool::put_OptimizeForWindowsApplication(VARIANT_BOOL optSetting)
{
	CHECK_ZOMBIE( m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE );
	CHECK_VARIANTBOOL( optSetting );
	return m_spPropertyContainer->SetBoolProperty(VCCLID_OptimizeForWindowsApplication, optSetting);
}

// Preprocessor
STDMETHODIMP CVCCLCompilerTool::get_PreprocessorDefinitions(BSTR* pbstrDefines)
{		// (/D[name]) defines, can have multiple
	return ToolGetStrProperty(VCCLID_PreprocessorDefinitions, pbstrDefines, true /* local only */);
}

STDMETHODIMP CVCCLCompilerTool::put_PreprocessorDefinitions(BSTR bstrDefines)
{
	CHECK_ZOMBIE( m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE );
	return m_spPropertyContainer->SetStrProperty(VCCLID_PreprocessorDefinitions, bstrDefines);
}

STDMETHODIMP CVCCLCompilerTool::get_IgnoreStandardIncludePath(VARIANT_BOOL* pbIgnoreInclPath)
{	// (/X) ignore standard include path
	return ToolGetBoolProperty(VCCLID_IgnoreStandardIncludePath, pbIgnoreInclPath);
}

STDMETHODIMP CVCCLCompilerTool::put_IgnoreStandardIncludePath(VARIANT_BOOL bIgnoreInclPath)
{
	CHECK_ZOMBIE( m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE );
	CHECK_VARIANTBOOL( bIgnoreInclPath );
	return m_spPropertyContainer->SetBoolProperty(VCCLID_IgnoreStandardIncludePath, bIgnoreInclPath);
}

STDMETHODIMP CVCCLCompilerTool::get_GeneratePreprocessedFile(preprocessOption* poptSetting)
{	// see enum above (/P, /EP /P)
	return ToolGetIntProperty(VCCLID_GeneratePreprocessedFile, (long *)poptSetting);
}

STDMETHODIMP CVCCLCompilerTool::put_GeneratePreprocessedFile(preprocessOption optSetting)
{
	CHECK_ZOMBIE( m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE );
	CHECK_BOUNDS(StdEnumMin, PreprocessMax, optSetting);
	return m_spPropertyContainer->SetIntProperty(VCCLID_GeneratePreprocessedFile, optSetting);
}

STDMETHODIMP CVCCLCompilerTool::get_KeepComments(VARIANT_BOOL* pbKeepComments)
{	// (/C) don't strip comments, requires one of /E, /EP, /P switches
	return ToolGetBoolProperty(VCCLID_KeepComments, pbKeepComments);
}

STDMETHODIMP CVCCLCompilerTool::put_KeepComments(VARIANT_BOOL bKeepComments)
{
	CHECK_ZOMBIE( m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE );
	CHECK_VARIANTBOOL( bKeepComments );
	return m_spPropertyContainer->SetBoolProperty(VCCLID_KeepComments, bKeepComments);
}

// Code Generation; /MP, /MPlowpri deliberately left out (since we require /FD or /Gm to be thrown)
STDMETHODIMP CVCCLCompilerTool::get_StringPooling(VARIANT_BOOL* pbPool)
{	// (/GF) enable read-only string pooling
	return ToolGetBoolProperty(VCCLID_StringPooling, pbPool);
}

STDMETHODIMP CVCCLCompilerTool::put_StringPooling(VARIANT_BOOL bPool)
{
	CHECK_ZOMBIE( m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE );
	CHECK_VARIANTBOOL( bPool );
	return m_spPropertyContainer->SetBoolProperty(VCCLID_StringPooling, bPool);
}

STDMETHODIMP CVCCLCompilerTool::get_MinimalRebuild(VARIANT_BOOL* pbMinimalRebuild)
{	// (/Gm, /Gm-) enable/disable minimal rebuild, /Gm requires /ZI or /Zi
	return ToolGetBoolProperty(VCCLID_MinimalRebuild, pbMinimalRebuild);
}

STDMETHODIMP CVCCLCompilerTool::put_MinimalRebuild(VARIANT_BOOL bMinimalRebuild)
{
	CHECK_ZOMBIE( m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE );
	CHECK_VARIANTBOOL( bMinimalRebuild );
	return m_spPropertyContainer->SetBoolProperty(VCCLID_MinimalRebuild, bMinimalRebuild);
}

STDMETHODIMP CVCCLCompilerTool::get_ExceptionHandling(VARIANT_BOOL* pbExcept)
{	// /EHsc
	return ToolGetBoolProperty(VCCLID_ExceptionHandling, pbExcept);
}

STDMETHODIMP CVCCLCompilerTool::put_ExceptionHandling(VARIANT_BOOL bExcept)
{
	CHECK_ZOMBIE( m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE );
	CHECK_VARIANTBOOL( bExcept );
	return m_spPropertyContainer->SetBoolProperty(VCCLID_ExceptionHandling, bExcept);
}


STDMETHODIMP CVCCLCompilerTool::get_BasicRuntimeChecks(basicRuntimeCheckOption* poptSetting)
{ 
	return ToolGetIntProperty(VCCLID_BasicRuntimeChecks, (long *)poptSetting);
}

STDMETHODIMP CVCCLCompilerTool::put_BasicRuntimeChecks(basicRuntimeCheckOption optSetting)
{
	CHECK_ZOMBIE( m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE );
	CHECK_BOUNDS(StdEnumMin, BasicRTCheckMax, optSetting);
	return m_spPropertyContainer->SetIntProperty(VCCLID_BasicRuntimeChecks, optSetting);
}

STDMETHODIMP CVCCLCompilerTool::get_SmallerTypeCheck(VARIANT_BOOL* pbSmallerType)
{ 
	return ToolGetBoolProperty(VCCLID_SmallerTypeCheck, pbSmallerType);
}

STDMETHODIMP CVCCLCompilerTool::put_SmallerTypeCheck(VARIANT_BOOL bSmallerType)
{
	CHECK_ZOMBIE( m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE );
	CHECK_VARIANTBOOL( bSmallerType );
	return m_spPropertyContainer->SetBoolProperty(VCCLID_SmallerTypeCheck, bSmallerType);
}

STDMETHODIMP CVCCLCompilerTool::get_RuntimeLibrary(runtimeLibraryOption* poptSetting)
{ 
	return ToolGetIntProperty(VCCLID_RuntimeLibrary, (long *)poptSetting);
}

STDMETHODIMP CVCCLCompilerTool::put_RuntimeLibrary(runtimeLibraryOption optSetting)
{
	CHECK_ZOMBIE( m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE );
	CHECK_BOUNDS(StdEnumMin, RTLibMax, optSetting);
	return m_spPropertyContainer->SetIntProperty(VCCLID_RuntimeLibrary, optSetting);
}

STDMETHODIMP CVCCLCompilerTool::get_BufferSecurityCheck(VARIANT_BOOL* pbSecure)
{	// (/GS) enable buffer overrun checks; buffer security from hackers
	return ToolGetBoolProperty(VCCLID_BufferSecurityCheck, pbSecure);
}

STDMETHODIMP CVCCLCompilerTool::put_BufferSecurityCheck(VARIANT_BOOL bSecure)
{
	CHECK_ZOMBIE( m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE );
	CHECK_VARIANTBOOL( bSecure );
	return m_spPropertyContainer->SetBoolProperty(VCCLID_BufferSecurityCheck, bSecure);
}

STDMETHODIMP CVCCLCompilerTool::get_StructMemberAlignment(structMemberAlignOption* poptSetting)
{ 
	return ToolGetIntProperty(VCCLID_StructMemberAlignment, (long *)poptSetting);
}

STDMETHODIMP CVCCLCompilerTool::put_StructMemberAlignment(structMemberAlignOption optSetting)
{
	CHECK_ZOMBIE( m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE );
	CHECK_BOUNDS(StdEnumMin, CLStructAlignMax, optSetting);
	return m_spPropertyContainer->SetIntProperty(VCCLID_StructMemberAlignment, optSetting);
}

STDMETHODIMP CVCCLCompilerTool::get_EnableFunctionLevelLinking(VARIANT_BOOL* pbPackage)
{	// (/Gy) enable function level linking (no explicit off)
	return ToolGetBoolProperty(VCCLID_EnableFunctionLevelLinking, pbPackage);
}

STDMETHODIMP CVCCLCompilerTool::put_EnableFunctionLevelLinking(VARIANT_BOOL bPackage)
{
	CHECK_ZOMBIE( m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE );
	CHECK_VARIANTBOOL( bPackage );
	return m_spPropertyContainer->SetBoolProperty(VCCLID_EnableFunctionLevelLinking, bPackage);
}

// Language
STDMETHODIMP CVCCLCompilerTool::get_DisableLanguageExtensions(VARIANT_BOOL* pbDisableExtensions)
{	// (/Za, /Ze) disable/enable language extensions (/Ze default)
	return ToolGetBoolProperty(VCCLID_DisableLanguageExtensions, pbDisableExtensions);
}

STDMETHODIMP CVCCLCompilerTool::put_DisableLanguageExtensions(VARIANT_BOOL bDisableExtensions)
{
	CHECK_ZOMBIE( m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE );
	CHECK_VARIANTBOOL( bDisableExtensions );
	return m_spPropertyContainer->SetBoolProperty(VCCLID_DisableLanguageExtensions, bDisableExtensions);
}

STDMETHODIMP CVCCLCompilerTool::get_DefaultCharIsUnsigned(VARIANT_BOOL* pbIsUnsigned)
{	// (/J) default char type is unsigned
	return ToolGetBoolProperty(VCCLID_DefaultCharIsUnsigned, pbIsUnsigned);
}

STDMETHODIMP CVCCLCompilerTool::put_DefaultCharIsUnsigned(VARIANT_BOOL bIsUnsigned)
{
	CHECK_ZOMBIE( m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE );
	CHECK_VARIANTBOOL( bIsUnsigned );
	return m_spPropertyContainer->SetBoolProperty(VCCLID_DefaultCharIsUnsigned, bIsUnsigned);
}

STDMETHODIMP CVCCLCompilerTool::get_TreatWChar_tAsBuiltInType(VARIANT_BOOL* pbBuiltInType)
{	// (/Zc:wchar_t) treat wchar_t as built-in type
	return ToolGetBoolProperty(VCCLID_TreatWChar_tAsBuiltInType, pbBuiltInType);
}

STDMETHODIMP CVCCLCompilerTool::put_TreatWChar_tAsBuiltInType(VARIANT_BOOL bBuiltInType)
{
	CHECK_ZOMBIE( m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE );
	CHECK_VARIANTBOOL( bBuiltInType );
	return m_spPropertyContainer->SetBoolProperty(VCCLID_TreatWChar_tAsBuiltInType, bBuiltInType);
}

STDMETHODIMP CVCCLCompilerTool::get_ForceConformanceInForLoopScope(VARIANT_BOOL* pbConform)
{	// (/Zc:forScope) check for conformance of vars for 'for' scope
	return ToolGetBoolProperty(VCCLID_ForceConformanceInForLoopScope, pbConform);
}

STDMETHODIMP CVCCLCompilerTool::put_ForceConformanceInForLoopScope(VARIANT_BOOL bConform)
{
	CHECK_ZOMBIE( m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE );
	CHECK_VARIANTBOOL( bConform );
	return m_spPropertyContainer->SetBoolProperty(VCCLID_ForceConformanceInForLoopScope, bConform);
}

STDMETHODIMP CVCCLCompilerTool::get_RuntimeTypeInfo(VARIANT_BOOL* pbRTTI)
{	// (/GR, /GR-) enable/disable C++ RTTI
	return ToolGetBoolProperty(VCCLID_RuntimeTypeInfo, pbRTTI);
}

STDMETHODIMP CVCCLCompilerTool::put_RuntimeTypeInfo(VARIANT_BOOL bRTTI)
{
	CHECK_ZOMBIE( m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE );
	CHECK_VARIANTBOOL( bRTTI );
	return m_spPropertyContainer->SetBoolProperty(VCCLID_RuntimeTypeInfo, bRTTI);
}

// Precompiled Headers
STDMETHODIMP CVCCLCompilerTool::get_UsePrecompiledHeader(pchOption* poptSetting)
{	// see enum above (/Yc, /YX, /Yu)
	return ToolGetIntProperty(VCCLID_UsePrecompiledHeader, (long *)poptSetting);
}

STDMETHODIMP CVCCLCompilerTool::put_UsePrecompiledHeader(pchOption optSetting)
{
	CHECK_ZOMBIE( m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE );
	CHECK_BOUNDS(StdEnumMin, UsePCHMax, optSetting);
	return m_spPropertyContainer->SetIntProperty(VCCLID_UsePrecompiledHeader, optSetting);
}

STDMETHODIMP CVCCLCompilerTool::get_PrecompiledHeaderThrough(BSTR* pbstrFile)
{	// optional argument to UsePrecompiledHeader property specifying file to use to generate/use PCH
	return ToolGetStrProperty(VCCLID_PrecompiledHeaderThrough, pbstrFile);
}

STDMETHODIMP CVCCLCompilerTool::put_PrecompiledHeaderThrough(BSTR bstrFile)
{
	CHECK_ZOMBIE( m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE );
	return m_spPropertyContainer->SetStrProperty(VCCLID_PrecompiledHeaderThrough, bstrFile);
}

STDMETHODIMP CVCCLCompilerTool::get_PrecompiledHeaderFile(BSTR* pbstrPCH)
{	// (/Fp[name]) name the precompiled header file, can be directory location or leave off .pch extension
	return ToolGetStrProperty(VCCLID_PrecompiledHeaderFile, pbstrPCH);
}

STDMETHODIMP CVCCLCompilerTool::put_PrecompiledHeaderFile(BSTR bstrPCH)
{
	CHECK_ZOMBIE( m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE );
	return m_spPropertyContainer->SetStrProperty(VCCLID_PrecompiledHeaderFile, bstrPCH);
}

// Output Files
STDMETHODIMP CVCCLCompilerTool::get_ExpandAttributedSource(VARIANT_BOOL* pbExpandAttributedSource)
{ 	// (/Fx) listing with attributed code expanded into source file
	return ToolGetBoolProperty(VCCLID_ExpandAttributedSource, pbExpandAttributedSource);
}

STDMETHODIMP CVCCLCompilerTool::put_ExpandAttributedSource(VARIANT_BOOL bExpandAttributedSource)
{
	CHECK_ZOMBIE( m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE );
	CHECK_VARIANTBOOL( bExpandAttributedSource );
	return m_spPropertyContainer->SetBoolProperty(VCCLID_ExpandAttributedSource, bExpandAttributedSource);
}

STDMETHODIMP CVCCLCompilerTool::get_AssemblerOutput(asmListingOption* poptSetting)
{	// see enum above (/FA, /FAc, /FAs, /FAcs)
	return ToolGetIntProperty(VCCLID_AssemblerOutput, (long *)poptSetting);
}

STDMETHODIMP CVCCLCompilerTool::put_AssemblerOutput(asmListingOption optSetting)
{
	CHECK_ZOMBIE( m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE );
	CHECK_BOUNDS(StdEnumMin, AsmListMax, optSetting);
	return m_spPropertyContainer->SetIntProperty(VCCLID_AssemblerOutput, optSetting);
}

STDMETHODIMP CVCCLCompilerTool::get_AssemblerListingLocation(BSTR* pbstrName)
{	// (/Fa[name]) specify directory and/or name for listing file from AssemblerOutput property
	return ToolGetStrProperty(VCCLID_AssemblerListingLocation, pbstrName);
}

STDMETHODIMP CVCCLCompilerTool::put_AssemblerListingLocation(BSTR bstrName)
{
	CHECK_ZOMBIE( m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE );
	return m_spPropertyContainer->SetStrProperty(VCCLID_AssemblerListingLocation, bstrName);
}

STDMETHODIMP CVCCLCompilerTool::get_ObjectFile(BSTR* pbstrName)
{	// (/Fo[name]) name obj file
	return ToolGetStrProperty(VCCLID_ObjectFile, pbstrName);
}

STDMETHODIMP CVCCLCompilerTool::put_ObjectFile(BSTR bstrName)
{
	CHECK_ZOMBIE( m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE );
	return m_spPropertyContainer->SetStrProperty(VCCLID_ObjectFile, bstrName);
}

STDMETHODIMP CVCCLCompilerTool::get_ProgramDataBaseFileName(BSTR* pbstrName)
{	// (/Fd[file]) name PDB file.  can be directory name
	return ToolGetStrProperty(VCCLID_ProgramDataBaseFileName, pbstrName);
}

STDMETHODIMP CVCCLCompilerTool::put_ProgramDataBaseFileName(BSTR bstrName)
{
	CHECK_ZOMBIE( m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE );
	return m_spPropertyContainer->SetStrProperty(VCCLID_ProgramDataBaseFileName, bstrName);
}

// Browse info helpers
STDMETHODIMP CVCCLCompilerTool::get_BrowseInformation(browseInfoOption* poptSetting)
{	// see enum above, (/FR[name], /Fr[name])
	return ToolGetIntProperty(VCCLID_BrowseInformation, (long *)poptSetting);
}

STDMETHODIMP CVCCLCompilerTool::put_BrowseInformation(browseInfoOption optSetting)
{
	CHECK_ZOMBIE( m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE );
	CHECK_BOUNDS(StdEnumMin, BrowseMax, optSetting);
	return m_spPropertyContainer->SetIntProperty(VCCLID_BrowseInformation, optSetting);
}

STDMETHODIMP CVCCLCompilerTool::get_BrowseInformationFile(BSTR* pbstrFile)
{		// optional name to go with BrowseInformation property
	return ToolGetStrProperty(VCCLID_BrowseInformationFile, pbstrFile);
}

STDMETHODIMP CVCCLCompilerTool::put_BrowseInformationFile(BSTR bstrFile)
{
	CHECK_ZOMBIE( m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE );
	return m_spPropertyContainer->SetStrProperty(VCCLID_BrowseInformationFile, bstrFile);
}

// Hidden
STDMETHODIMP CVCCLCompilerTool::get_CompileOnly(VARIANT_BOOL* pbCompileOnly)
{	// (/c)	compile only, no link
	return ToolGetBoolProperty(VCCLID_CompileOnly, pbCompileOnly);
}

STDMETHODIMP CVCCLCompilerTool::put_CompileOnly(VARIANT_BOOL bCompileOnly)
{
	CHECK_ZOMBIE( m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE );
	CHECK_VARIANTBOOL( bCompileOnly );
	return m_spPropertyContainer->SetBoolProperty(VCCLID_CompileOnly, bCompileOnly);
}

// Advanced
STDMETHODIMP CVCCLCompilerTool::get_CallingConvention(callingConventionOption* poptSetting)
{ 
	return ToolGetIntProperty(VCCLID_CallingConvention, (long *)poptSetting);
}

STDMETHODIMP CVCCLCompilerTool::put_CallingConvention(callingConventionOption optSetting)
{
	CHECK_ZOMBIE( m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE );
	CHECK_BOUNDS(StdEnumMin, CallConvMax, optSetting);
	return m_spPropertyContainer->SetIntProperty(VCCLID_CallingConvention, optSetting);
}

STDMETHODIMP CVCCLCompilerTool::get_CompileAs(CompileAsOptions* pcompileAs)
{	// see enum above (/TC, /TP)
	return ToolGetIntProperty(VCCLID_CompileAs, (long *)pcompileAs);
}

STDMETHODIMP CVCCLCompilerTool::put_CompileAs(CompileAsOptions compileAs)
{
	CHECK_ZOMBIE( m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE );
	CHECK_BOUNDS(StdEnumMin, CompileAsMax, compileAs);
	return m_spPropertyContainer->SetIntProperty(VCCLID_CompileAs, compileAs);
}

STDMETHODIMP CVCCLCompilerTool::get_DisableSpecificWarnings(BSTR* pbstrDisableSpecificWarnings)
{	// (/wd<num>) disable specific warnings; multi-prop
	return ToolGetStrProperty(VCCLID_DisableSpecificWarnings, pbstrDisableSpecificWarnings, true /* local only */);
}

STDMETHODIMP CVCCLCompilerTool::put_DisableSpecificWarnings(BSTR bstrDisableSpecificWarnings)
{
	CHECK_ZOMBIE( m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE );
	return m_spPropertyContainer->SetStrProperty(VCCLID_DisableSpecificWarnings, bstrDisableSpecificWarnings);
}

STDMETHODIMP CVCCLCompilerTool::get_ForcedIncludeFiles(BSTR* pbstrName)
{	// (/FI![name]) name forced include file, can have multiple
	return ToolGetStrProperty(VCCLID_ForcedIncludeFiles, pbstrName, true /* local only */);
}

STDMETHODIMP CVCCLCompilerTool::put_ForcedIncludeFiles(BSTR bstrName)
{
	CHECK_ZOMBIE( m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE );
	return m_spPropertyContainer->SetStrProperty(VCCLID_ForcedIncludeFiles, bstrName);
}

STDMETHODIMP CVCCLCompilerTool::get_ForcedUsingFiles(BSTR* pbstrName)
{	// (/FU![name]) name forced #using file, can have multiple
	return ToolGetStrProperty(VCCLID_ForcedUsingFiles, pbstrName, true /* local only */);
}

STDMETHODIMP CVCCLCompilerTool::put_ForcedUsingFiles(BSTR bstrName)
{
	CHECK_ZOMBIE( m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE );
	return m_spPropertyContainer->SetStrProperty(VCCLID_ForcedUsingFiles, bstrName);
}

STDMETHODIMP CVCCLCompilerTool::get_ShowIncludes(VARIANT_BOOL* pbShowInc)
{	// (/showIncludes)
	return ToolGetBoolProperty(VCCLID_ShowIncludes, pbShowInc);
}

STDMETHODIMP CVCCLCompilerTool::put_ShowIncludes(VARIANT_BOOL bShowInc)
{
	CHECK_ZOMBIE( m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE );
	CHECK_VARIANTBOOL( bShowInc );
	return m_spPropertyContainer->SetBoolProperty(VCCLID_ShowIncludes, bShowInc);
}

STDMETHODIMP CVCCLCompilerTool::get_UndefinePreprocessorDefinitions(BSTR* pbstrUndefines)
{	// (/U[name]) undefine predefined macro, can have multiple
	return ToolGetStrProperty(VCCLID_UndefinePreprocessorDefinitions, pbstrUndefines, true /* local only */);
}

STDMETHODIMP CVCCLCompilerTool::put_UndefinePreprocessorDefinitions(BSTR bstrUndefines)	
{
	CHECK_ZOMBIE( m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE );
	return m_spPropertyContainer->SetStrProperty(VCCLID_UndefinePreprocessorDefinitions, bstrUndefines);
}

STDMETHODIMP CVCCLCompilerTool::get_UndefineAllPreprocessorDefinitions(VARIANT_BOOL* pbPredefinedMacros)
{	// (/u) undefine all predefined macros 
	return ToolGetBoolProperty(VCCLID_UndefineAllPreprocessorDefinitions, pbPredefinedMacros);
}

STDMETHODIMP CVCCLCompilerTool::put_UndefineAllPreprocessorDefinitions(VARIANT_BOOL bPredefinedMacros)
{
	CHECK_ZOMBIE( m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE );
	CHECK_VARIANTBOOL( bPredefinedMacros );
	return m_spPropertyContainer->SetBoolProperty(VCCLID_UndefineAllPreprocessorDefinitions, bPredefinedMacros);
}

// Automation properties
STDMETHODIMP CVCCLCompilerTool::get_ToolPath(BSTR *pVal)
{
	CHECK_ZOMBIE( m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE );
	CComBSTR bstrPath( szCLCompilerToolPath );
	*pVal = bstrPath.Detach();
	return S_OK;
}

STDMETHODIMP CVCCLCompilerTool::get_PropertyOption(BSTR bstrProp, long dispidProp, BSTR *pVal)
{ 
	return DoGetPropertyOption(bstrProp, dispidProp, pVal);
}

STDMETHODIMP CVCCLCompilerTool::get_FullIncludePath(BSTR* fullIncludePath)
{	// include path, including all inherited values, plus platform includes
	return get_FullIncludePathInternal(fullIncludePath);
}

// IVCToolImpl
STDMETHODIMP CVCCLCompilerTool::get_DefaultExtensions(BSTR* pVal)
{
	return DoGetDefaultExtensions(s_bstrExtensions, wszCLDefaultExtensions, pVal);
}

STDMETHODIMP CVCCLCompilerTool::put_DefaultExtensions(BSTR newVal)
{
	s_bstrExtensions = newVal;
	return S_OK;
}

STDMETHODIMP CVCCLCompilerTool::GetAdditionalOptionsInternal(IUnknown* pItem, VARIANT_BOOL bForBuild, VARIANT_BOOL bSkipLocal, 
	BSTR* pbstrAdditionalOptions)
{ 
	return GetProcessedAdditionalOptions(pItem, VCCLID_AdditionalOptions, bForBuild, bSkipLocal, pbstrAdditionalOptions);
}

STDMETHODIMP CVCCLCompilerTool::GetBuildDescription(IVCBuildAction* pAction, BSTR* pbstrBuildDescription)
{
	if (s_bstrBuildDescription.Length() == 0)
		s_bstrBuildDescription.LoadString(IDS_DESC_COMPILING);
	return s_bstrBuildDescription.CopyTo(pbstrBuildDescription);
}

STDMETHODIMP CVCCLCompilerTool::GetAdditionalIncludeDirectoriesInternal(IVCPropertyContainer* pPropContainer, BSTR* pbstrIncDirs)
{
	CHECK_POINTER_NULL(pbstrIncDirs);
	RETURN_INVALID_ON_NULL(pPropContainer);
	*pbstrIncDirs = NULL;
	CComBSTR bstrTmp;
	HRESULT hr = pPropContainer->GetMultiProp(VCCLID_AdditionalIncludeDirectories, L";", VARIANT_FALSE, &bstrTmp);
	if (SUCCEEDED(hr))
		pPropContainer->Evaluate(bstrTmp, pbstrIncDirs);
	else
		*pbstrIncDirs = bstrTmp.Detach();
	return hr;
}

STDMETHODIMP CVCCLCompilerTool::get_IncludePathID(long* pnIncludeID)
{
	CHECK_POINTER_NULL(pnIncludeID);
	*pnIncludeID = VCCLID_AdditionalIncludeDirectories;
	return S_OK;
}

STDMETHODIMP CVCCLCompilerTool::get_ToolPathInternal(BSTR* pbstrToolPath)
{ 
	return get_ToolPath(pbstrToolPath);
}

STDMETHODIMP CVCCLCompilerTool::get_Bucket(long *pVal)
{
	CHECK_POINTER_NULL(pVal);
	*pVal = BUCKET_CPP;
	return S_OK;
}

STDMETHODIMP CVCCLCompilerTool::get_ToolShortName(BSTR* pbstrToolName)
{
	CComBSTR bstrName( szCLCompilerToolShortName );
	*pbstrToolName = bstrName.Detach();
	return S_OK;
}

STDMETHODIMP CVCCLCompilerTool::MatchName(BSTR bstrName, VARIANT_BOOL bFullOnly, VARIANT_BOOL* pbMatches)
{
	return DoMatchName(bstrName, szCLCompilerToolType, szCLCompilerToolShortName, pbMatches);
}

STDMETHODIMP CVCCLCompilerTool::CreateToolObject(IVCPropertyContainer* pPropContainer, IVCToolImpl** ppToolObject)
{ 
	return CreateInstance(pPropContainer, ppToolObject); 
}

STDMETHODIMP CVCCLCompilerTool::HasVirtualLocalStorage(IVCPropertyContainer* pPropContainer, VARIANT_BOOL* pbHasVirtualLocalStorage)
{
	HRESULT hr = CVCToolImpl::HasVirtualLocalStorage(pPropContainer, pbHasVirtualLocalStorage);
	RETURN_ON_FAIL(hr);		// parent took care of evaluating parameters

	static const long nPropList[] =
	{
		VCCLID_AssemblerListingLocation,
		VCCLID_ObjectFile,
		VCCLID_BrowseInformationFile,
		0
	};

	// some compiler options take a parameter that could, with the proper macro, make what appears to be an inherited
	// value need to be evaluated on a per file basis.
	for (int idx = 0; *pbHasVirtualLocalStorage == VARIANT_FALSE && nPropList[idx] != 0; idx++)
	{
		CComBSTR bstrVal;
		if (pPropContainer->GetStrProperty(nPropList[idx], &bstrVal) != S_OK)
			continue;

		CStringW strVal = bstrVal;
		strVal.MakeLower();
		*pbHasVirtualLocalStorage = ((strVal.Find(L"$(input") >= 0) && ((strVal.Find(L"$(inputname)") >= 0) || (strVal.Find(L"$(inputext)") >= 0) ||
			(strVal.Find(L"$(inputpath)") >= 0)));
	}

	// need to set up a separate command line for those things that have /TC or /TP thrown on them
	if (*pbHasVirtualLocalStorage == VARIANT_FALSE)
	{
		CComQIPtr<VCFileConfiguration> spFileCfg = pPropContainer;
		if (spFileCfg)
		{
			CComVariant var;
			*pbHasVirtualLocalStorage = (pPropContainer->GetLocalProp(VCCLID_CompileAs, &var) == S_OK && var.vt != VT_EMPTY && 
				(CompileAsOptions)var.lVal != compileAsDefault);
		}
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////////////////
// Settings pages
/////////////////////////////////////////////////////////////////////////////////////////

// Optimization
STDMETHODIMP CVCCLCompilerOptimizationPage::get_Optimization(optimizeOption* poptSetting)
{	// see enum above (/O1, /O2, /Od, /Ox)
	return ToolGetIntProperty(VCCLID_Optimization, &(CVCCLCompilerTool::s_optHandler), (long*)poptSetting);
}

STDMETHODIMP CVCCLCompilerOptimizationPage::put_Optimization(optimizeOption optSetting)
{
	CHECK_BOUNDS(INHERIT_PROP_VALUE, OptimizeMax, optSetting);
	return SetIntProperty(VCCLID_Optimization, optSetting);
}

STDMETHODIMP CVCCLCompilerOptimizationPage::get_GlobalOptimizations(enumGlobalOptimizationsBOOL* pbGlobalOpt)
{ 	// (/Og, /Og-) enable/disable global optimizations incompatible with all RTC options, GZ, ZI, EEf
	return GetEnumBoolProperty2(VCCLID_GlobalOptimizations, (long *)pbGlobalOpt);
}

STDMETHODIMP CVCCLCompilerOptimizationPage::put_GlobalOptimizations(enumGlobalOptimizationsBOOL bGlobalOpt)
{
	return SetBoolProperty(VCCLID_GlobalOptimizations, bGlobalOpt);
}

STDMETHODIMP CVCCLCompilerOptimizationPage::get_InlineFunctionExpansion(inlineExpansionOption* poptSetting)
{	// see enum above (/Ob0, /Ob1, /Ob2)
	return ToolGetIntProperty(VCCLID_InlineFunctionExpansion, &(CVCCLCompilerTool::s_optHandler), (long *)poptSetting);
}

STDMETHODIMP CVCCLCompilerOptimizationPage::put_InlineFunctionExpansion(inlineExpansionOption optSetting)
{
	CHECK_BOUNDS(INHERIT_PROP_VALUE, InlineMax, optSetting);
	return SetIntProperty(VCCLID_InlineFunctionExpansion, optSetting);
}

STDMETHODIMP CVCCLCompilerOptimizationPage::get_EnableIntrinsicFunctions(enumEnableIntrinsicFunctionsBOOL* pbEnableIntrinsic)
{	// (/Oi, /Oi-) enable/disable intrinsic functions works best with /Og
	return GetEnumBoolProperty2(VCCLID_EnableIntrinsicFunctions, (long *)pbEnableIntrinsic);
}

STDMETHODIMP CVCCLCompilerOptimizationPage::put_EnableIntrinsicFunctions(enumEnableIntrinsicFunctionsBOOL bEnableIntrinsic)
{
	return SetBoolProperty(VCCLID_EnableIntrinsicFunctions, bEnableIntrinsic);
}

STDMETHODIMP CVCCLCompilerOptimizationPage::get_ImproveFloatingPointConsistency(enumImproveFloatingPointConsistencyBOOL* pbImproveFloat)
{	// (/Op, /Op-) (don't) improve floating-point consistency
	return GetEnumBoolProperty2(VCCLID_ImproveFloatingPointConsistency, (long *)pbImproveFloat);
}

STDMETHODIMP CVCCLCompilerOptimizationPage::put_ImproveFloatingPointConsistency(enumImproveFloatingPointConsistencyBOOL bImproveFloat)
{
	return SetBoolProperty(VCCLID_ImproveFloatingPointConsistency, bImproveFloat);
}

STDMETHODIMP CVCCLCompilerOptimizationPage::get_FavorSizeOrSpeed(favorSizeOrSpeedOption* poptSetting)
{	// (/Os, Ot) favor size/speed works best with /Og
	return ToolGetIntProperty(VCCLID_FavorSizeOrSpeed, &(CVCCLCompilerTool::s_optHandler), (long *)poptSetting);
}

STDMETHODIMP CVCCLCompilerOptimizationPage::put_FavorSizeOrSpeed(favorSizeOrSpeedOption optSetting)
{
	CHECK_BOUNDS(INHERIT_PROP_VALUE, CodeGenMax, optSetting);
	return SetIntProperty(VCCLID_FavorSizeOrSpeed, optSetting);
}

STDMETHODIMP CVCCLCompilerOptimizationPage::get_OmitFramePointers(enumOmitFramePointersBOOL* poptSetting)
{	// (/Oy, Oy-) enable/disable frame pointer omission
	return GetEnumBoolProperty2(VCCLID_OmitFramePointers, (long *)poptSetting); 
}

STDMETHODIMP CVCCLCompilerOptimizationPage::put_OmitFramePointers(enumOmitFramePointersBOOL optSetting)
{
	return SetBoolProperty(VCCLID_OmitFramePointers, optSetting);
}

STDMETHODIMP CVCCLCompilerOptimizationPage::get_EnableFiberSafeOptimizations(enumEnableFiberSafeOptimizationsBOOL* pbFiberSafeTLS)
{	// (/GT) generate fiber-safe TLS accesses
	return GetEnumBoolProperty2(VCCLID_EnableFiberSafeOptimizations, (long *)pbFiberSafeTLS); 
}

STDMETHODIMP CVCCLCompilerOptimizationPage::put_EnableFiberSafeOptimizations(enumEnableFiberSafeOptimizationsBOOL bFiberSafeTLS)
{
	return SetBoolProperty(VCCLID_EnableFiberSafeOptimizations, bFiberSafeTLS);
}

// Optimization -- X86-specific
STDMETHODIMP CVCCLCompilerOptimizationPage::get_OptimizeForProcessor(ProcessorOptimizeOption* poptSetting)
{ 
	return ToolGetIntProperty(VCCLID_OptimizeForProcessor, &(CVCCLCompilerTool::s_optHandler), (long *)poptSetting);
}

STDMETHODIMP CVCCLCompilerOptimizationPage::put_OptimizeForProcessor(ProcessorOptimizeOption optSetting)
{
	CHECK_BOUNDS(INHERIT_PROP_VALUE, OptProcMax, optSetting);
	return SetIntProperty(VCCLID_OptimizeForProcessor, optSetting);
}

STDMETHODIMP CVCCLCompilerOptimizationPage::get_OptimizeForWindowsApplication(enumOptimizeForWindowsApplicationBOOL* poptSetting)
{ 
	return GetEnumBoolProperty2(VCCLID_OptimizeForWindowsApplication, (long *)poptSetting);
}

STDMETHODIMP CVCCLCompilerOptimizationPage::put_OptimizeForWindowsApplication(enumOptimizeForWindowsApplicationBOOL optSetting)
{
	return SetBoolProperty(VCCLID_OptimizeForWindowsApplication, optSetting);
}

STDMETHODIMP CVCCLCompilerOptimizationPage::IsPropertyReadOnly( DISPID dispid, BOOL *fReadOnly)
{
	CHECK_POINTER_NULL(fReadOnly);
	*fReadOnly = VARIANT_FALSE;
	switch (dispid)
	{
	case VCCLID_Optimization:
	case VCCLID_GlobalOptimizations:
	case VCCLID_InlineFunctionExpansion:
	case VCCLID_EnableIntrinsicFunctions:
	case VCCLID_ImproveFloatingPointConsistency:
	case VCCLID_FavorSizeOrSpeed:
	case VCCLID_OmitFramePointers:
	case VCCLID_WholeProgramOptimization:
		{
			long SKU;
			static_cast<CVCProjectEngine*>(g_pProjectEngine)->GetSKU( &SKU );
			switch( SKU )
			{
				case VSASKUEdition_Book:
				case VSASKUEdition_Standard:
					*fReadOnly = VARIANT_TRUE;
					break;
				default:
					*fReadOnly = VARIANT_FALSE;
					break;
			}
			break;
		}
	default:
		*fReadOnly = VARIANT_FALSE;
	}

	return S_OK;
};


// Preprocessor
STDMETHODIMP CVCCLCompilerPreProcessorPage::get_PreprocessorDefinitions(BSTR* pbstrDefines)
{		// (/D[name]) defines, can have multiple
	return ToolGetStrProperty(VCCLID_PreprocessorDefinitions, &(CVCCLCompilerTool::s_optHandler), pbstrDefines, true /* local only */);
}

STDMETHODIMP CVCCLCompilerPreProcessorPage::put_PreprocessorDefinitions(BSTR bstrDefines)
{
	return SetStrProperty(VCCLID_PreprocessorDefinitions, bstrDefines);
}

STDMETHODIMP CVCCLCompilerPreProcessorPage::get_IgnoreStandardIncludePath(enumIgnoreStandardIncludePathBOOL* pbIgnoreInclPath)
{	// (/X) ignore standard include path
	return GetEnumBoolProperty2(VCCLID_IgnoreStandardIncludePath, (long *)pbIgnoreInclPath); 
}

STDMETHODIMP CVCCLCompilerPreProcessorPage::put_IgnoreStandardIncludePath(enumIgnoreStandardIncludePathBOOL bIgnoreInclPath)
{
	return SetBoolProperty(VCCLID_IgnoreStandardIncludePath, bIgnoreInclPath);
}

// Preprocessor Diagnostics
STDMETHODIMP CVCCLCompilerPreProcessorPage::get_GeneratePreprocessedFile(preprocessOption* poptSetting)
{	// see enum above (/E, /EP, /P, /EP /P)
	return ToolGetIntProperty(VCCLID_GeneratePreprocessedFile, &(CVCCLCompilerTool::s_optHandler), (long *)poptSetting);
}

STDMETHODIMP CVCCLCompilerPreProcessorPage::put_GeneratePreprocessedFile(preprocessOption optSetting)
{
	CHECK_BOUNDS(INHERIT_PROP_VALUE, PreprocessMax, optSetting);
	return SetIntProperty(VCCLID_GeneratePreprocessedFile, optSetting);
}

STDMETHODIMP CVCCLCompilerPreProcessorPage::get_KeepComments(enumKeepCommentsBOOL* pbKeepComments)
{	// (/C) don't strip comments, requires one of /E, /EP, /P switches
	return GetEnumBoolProperty2(VCCLID_KeepComments, (long *)pbKeepComments); 
}

STDMETHODIMP CVCCLCompilerPreProcessorPage::put_KeepComments(enumKeepCommentsBOOL bKeepComments)
{
	return SetBoolProperty(VCCLID_KeepComments, bKeepComments);
}

// Code Generation; /MP, /MPlowpri deliberately left out (since we require /FD or /Gm to be thrown)
STDMETHODIMP CVCCLCompilerCodeGenPage::get_StringPooling(enumStringPoolingBOOL* pbPool)
{	// (/GF) enable read-only string pooling
	return GetEnumBoolProperty2(VCCLID_StringPooling, (long *)pbPool, &(CVCCLCompilerTool::s_optHandler)); 
}

STDMETHODIMP CVCCLCompilerCodeGenPage::put_StringPooling(enumStringPoolingBOOL bPool)
{
	return SetBoolProperty(VCCLID_StringPooling, bPool);
}

STDMETHODIMP CVCCLCompilerCodeGenPage::get_MinimalRebuild(enumMinimalRebuildBOOL* pbMinimalRebuild)
{	// (/Gm, /Gm-) enable/disable minimal rebuild, /Gm requires /ZI or /Zi
	return GetEnumBoolProperty2(VCCLID_MinimalRebuild, (long *)pbMinimalRebuild); 
}

STDMETHODIMP CVCCLCompilerCodeGenPage::put_MinimalRebuild(enumMinimalRebuildBOOL bMinimalRebuild)
{
	return SetBoolProperty(VCCLID_MinimalRebuild, bMinimalRebuild);
}

STDMETHODIMP CVCCLCompilerCodeGenPage::get_ExceptionHandling(enumExceptionHandlingBOOL* poptSetting)
{	// /EHsc
	return GetEnumBoolProperty2(VCCLID_ExceptionHandling, (long *)poptSetting); 
}

STDMETHODIMP CVCCLCompilerCodeGenPage::put_ExceptionHandling(enumExceptionHandlingBOOL optSetting)
{
	return SetBoolProperty(VCCLID_ExceptionHandling, optSetting);
}

STDMETHODIMP CVCCLCompilerCodeGenPage::get_BasicRuntimeChecks(basicRuntimeCheckOption* poptSetting)
{ 
	return GetIntProperty(VCCLID_BasicRuntimeChecks, (long *)poptSetting); 
}

STDMETHODIMP CVCCLCompilerCodeGenPage::put_BasicRuntimeChecks(basicRuntimeCheckOption optSetting)
{
	return SetIntProperty(VCCLID_BasicRuntimeChecks, optSetting);
}

STDMETHODIMP CVCCLCompilerCodeGenPage::get_SmallerTypeCheck(enumSmallerTypeCheckBOOL* pbSmallerType)
{ 
	return GetEnumBoolProperty2(VCCLID_SmallerTypeCheck, (long *)pbSmallerType);
}

STDMETHODIMP CVCCLCompilerCodeGenPage::put_SmallerTypeCheck(enumSmallerTypeCheckBOOL bSmallerType)
{
	return SetBoolProperty(VCCLID_SmallerTypeCheck, bSmallerType);
}

STDMETHODIMP CVCCLCompilerCodeGenPage::get_RuntimeLibrary(runtimeLibraryOption* poptSetting)
{ 
	return ToolGetIntProperty(VCCLID_RuntimeLibrary, &(CVCCLCompilerTool::s_optHandler), (long *)poptSetting);
}

STDMETHODIMP CVCCLCompilerCodeGenPage::put_RuntimeLibrary(runtimeLibraryOption optSetting)
{
	CHECK_BOUNDS(INHERIT_PROP_VALUE, RTLibMax, optSetting);
	return SetIntProperty(VCCLID_RuntimeLibrary, optSetting);
}

STDMETHODIMP CVCCLCompilerCodeGenPage::get_StructMemberAlignment(structMemberAlignOption* poptSetting)
{ 
	return ToolGetIntProperty(VCCLID_StructMemberAlignment, &(CVCCLCompilerTool::s_optHandler), (long *)poptSetting);
}

STDMETHODIMP CVCCLCompilerCodeGenPage::put_StructMemberAlignment(structMemberAlignOption optSetting)
{
	CHECK_BOUNDS(INHERIT_PROP_VALUE, CLStructAlignMax, optSetting);
	return SetIntProperty(VCCLID_StructMemberAlignment, optSetting);
}

STDMETHODIMP CVCCLCompilerCodeGenPage::get_BufferSecurityCheck(enumBufferSecurityCheckBOOL* pbSecure)
{	// (/GS) enable buffer overrun checks; buffer security from hackers
	return GetEnumBoolProperty2(VCCLID_BufferSecurityCheck, (long *)pbSecure); 
}

STDMETHODIMP CVCCLCompilerCodeGenPage::put_BufferSecurityCheck(enumBufferSecurityCheckBOOL bSecure)
{
	return SetBoolProperty(VCCLID_BufferSecurityCheck, bSecure);
}

STDMETHODIMP CVCCLCompilerCodeGenPage::get_EnableFunctionLevelLinking(enumEnableFunctionLevelLinkingBOOL* pbPackage)
{	// (/Gy) enable function level linking (no explicit off)
	return GetEnumBoolProperty2(VCCLID_EnableFunctionLevelLinking, (long *)pbPackage); 
}

STDMETHODIMP CVCCLCompilerCodeGenPage::put_EnableFunctionLevelLinking(enumEnableFunctionLevelLinkingBOOL bPackage)
{
	return SetBoolProperty(VCCLID_EnableFunctionLevelLinking, bPackage);
}

void CVCCLCompilerCodeGenPage::GetBaseDefault(long id, CComVariant& varValue)
{
	if (id == VCCLID_BufferSecurityCheck)
	{
		VARIANT_BOOL bVal;
		CVCCLCompilerTool::s_optHandler.GetDefaultValue( id, &bVal, m_pContainer );
		varValue = bVal;
	}
	else
		CBase::GetBaseDefault(id, varValue);
}

// Language
STDMETHODIMP CVCCLCompilerLanguagePage::get_DisableLanguageExtensions(enumDisableLanguageExtensionsBOOL* pbDisableExtensions)
{	// (/Za, /Ze) disable/enable language extensions (/Ze default)
	return GetEnumBoolProperty2(VCCLID_DisableLanguageExtensions, (long *)pbDisableExtensions);
}

STDMETHODIMP CVCCLCompilerLanguagePage::put_DisableLanguageExtensions(enumDisableLanguageExtensionsBOOL bDisableExtensions)
{
	return SetBoolProperty(VCCLID_DisableLanguageExtensions, bDisableExtensions);
}

STDMETHODIMP CVCCLCompilerLanguagePage::get_DefaultCharIsUnsigned(enumDefaultCharIsUnsignedBOOL* pbIsUnsigned)
{	// (/J) default char type is unsigned
	return GetEnumBoolProperty2(VCCLID_DefaultCharIsUnsigned, (long *)pbIsUnsigned);
}

STDMETHODIMP CVCCLCompilerLanguagePage::put_DefaultCharIsUnsigned(enumDefaultCharIsUnsignedBOOL bIsUnsigned)
{
	return SetBoolProperty(VCCLID_DefaultCharIsUnsigned, bIsUnsigned);
}

STDMETHODIMP CVCCLCompilerLanguagePage::get_TreatWChar_tAsBuiltInType(enumTreatWChar_tAsBuiltInTypeBOOL* pbBuiltInType)
{	// (/Zc:wchar_t) treat wchar_t as built-in type
	return GetEnumBoolProperty2(VCCLID_TreatWChar_tAsBuiltInType, (long *)pbBuiltInType);
}

STDMETHODIMP CVCCLCompilerLanguagePage::put_TreatWChar_tAsBuiltInType(enumTreatWChar_tAsBuiltInTypeBOOL bBuiltInType)
{
	return SetBoolProperty(VCCLID_TreatWChar_tAsBuiltInType, bBuiltInType);
}

STDMETHODIMP CVCCLCompilerLanguagePage::get_ForceConformanceInForLoopScope(enumForceConformanceInForLoopScopeBOOL* pbConform)
{	// (/Zc:forScope) check for conformance of vars for 'for' scope
	return GetEnumBoolProperty2(VCCLID_ForceConformanceInForLoopScope, (long *)pbConform);
}

STDMETHODIMP CVCCLCompilerLanguagePage::put_ForceConformanceInForLoopScope(enumForceConformanceInForLoopScopeBOOL bConform)
{
	return SetBoolProperty(VCCLID_ForceConformanceInForLoopScope, bConform);
}

STDMETHODIMP CVCCLCompilerLanguagePage::get_RuntimeTypeInfo(enumRTTIBOOL* pbRTTI)
{	// (/GR, /GR-) enable/disable C++ RTTI
	return GetEnumBoolProperty2(VCCLID_RuntimeTypeInfo, (long *)pbRTTI); 
}

STDMETHODIMP CVCCLCompilerLanguagePage::put_RuntimeTypeInfo(enumRTTIBOOL bRTTI)
{
	return SetBoolProperty(VCCLID_RuntimeTypeInfo, bRTTI);
}

// Precompiled Headers
STDMETHODIMP CVCCLCompilerPCHPage::get_UsePrecompiledHeader(pchOption* poptSetting)
{	// see enum above (/Yc, /YX, /Yu)
	return ToolGetIntProperty(VCCLID_UsePrecompiledHeader, &(CVCCLCompilerTool::s_optHandler), (long *)poptSetting);
}

STDMETHODIMP CVCCLCompilerPCHPage::put_UsePrecompiledHeader(pchOption optSetting)
{
	CHECK_BOUNDS(INHERIT_PROP_VALUE, UsePCHMax, optSetting);
	return SetIntProperty(VCCLID_UsePrecompiledHeader, optSetting);
}

STDMETHODIMP CVCCLCompilerPCHPage::get_PrecompiledHeaderThrough(BSTR* pbstrFile)
{	// optional argument to UsePrecompiledHeader property specifying file to use to generate/use PCH
	return ToolGetStrProperty(VCCLID_PrecompiledHeaderThrough, &(CVCCLCompilerTool::s_optHandler), pbstrFile);
}

STDMETHODIMP CVCCLCompilerPCHPage::put_PrecompiledHeaderThrough(BSTR bstrFile)
{
	return SetStrProperty(VCCLID_PrecompiledHeaderThrough, bstrFile);
}

STDMETHODIMP CVCCLCompilerPCHPage::get_PrecompiledHeaderFile(BSTR* pbstrPCH)
{	// (/Fp[name]) name the precompiled header file, can be directory location or leave off .pch extension
	return ToolGetStrProperty(VCCLID_PrecompiledHeaderFile, &(CVCCLCompilerTool::s_optHandler), pbstrPCH);
}

STDMETHODIMP CVCCLCompilerPCHPage::put_PrecompiledHeaderFile(BSTR bstrPCH)
{
	return SetStrProperty(VCCLID_PrecompiledHeaderFile, bstrPCH);
}

void CVCCLCompilerPCHPage::GetBaseDefault(long id, CComVariant& varValue)
{
	CComBSTR bstrVal;
	switch (id)
	{
	case VCCLID_PrecompiledHeaderThrough:
	case VCCLID_PrecompiledHeaderFile:
		CVCCLCompilerTool::s_optHandler.GetDefaultValue( id, &bstrVal, m_pContainer );
		break;
	default:
		CBase::GetBaseDefault(id, varValue);
		return;
	}

	varValue = bstrVal;
}

// Output Files
STDMETHODIMP CVCCLCompilerOutputPage::get_ExpandAttributedSource(enumExpandAttributedSourceBOOL* pbExpandAttributedSource)
{ 	// (/Fx) listing with attributed code expanded into source file
	return GetEnumBoolProperty2(VCCLID_ExpandAttributedSource, (long *)pbExpandAttributedSource);
}

STDMETHODIMP CVCCLCompilerOutputPage::put_ExpandAttributedSource(enumExpandAttributedSourceBOOL bExpandAttributedSource)
{
	return SetBoolProperty(VCCLID_ExpandAttributedSource, bExpandAttributedSource);
}

STDMETHODIMP CVCCLCompilerOutputPage::get_AssemblerOutput(asmListingOption* poptSetting)
{	// see enum above (/FA, /FAc, /FAs, /FAcs)
	return ToolGetIntProperty(VCCLID_AssemblerOutput, &(CVCCLCompilerTool::s_optHandler), (long *)poptSetting);
}

STDMETHODIMP CVCCLCompilerOutputPage::put_AssemblerOutput(asmListingOption optSetting)
{
	CHECK_BOUNDS(INHERIT_PROP_VALUE, AsmListMax, optSetting);
	return SetIntProperty(VCCLID_AssemblerOutput, optSetting);
}

STDMETHODIMP CVCCLCompilerOutputPage::get_AssemblerListingLocation(BSTR* pbstrName)
{	// (/Fa[name]) specify directory and/or name for listing file from AssemblerOutput property
	return ToolGetStrProperty(VCCLID_AssemblerListingLocation, &(CVCCLCompilerTool::s_optHandler), pbstrName);
}

STDMETHODIMP CVCCLCompilerOutputPage::put_AssemblerListingLocation(BSTR bstrName)
{
	return SetStrProperty(VCCLID_AssemblerListingLocation, bstrName);
}

STDMETHODIMP CVCCLCompilerOutputPage::get_ObjectFile(BSTR* pbstrName)
{	// (/Fo[name]) name obj file
	return ToolGetStrProperty(VCCLID_ObjectFile, &(CVCCLCompilerTool::s_optHandler), pbstrName);
}

STDMETHODIMP CVCCLCompilerOutputPage::put_ObjectFile(BSTR bstrName)
{
	return SetStrProperty(VCCLID_ObjectFile, bstrName);
}

STDMETHODIMP CVCCLCompilerOutputPage::get_ProgramDataBaseFileName(BSTR* pbstrName)
{	// (/Fd[file]) name PDB file.  can be directory name
	return ToolGetStrProperty(VCCLID_ProgramDataBaseFileName, &(CVCCLCompilerTool::s_optHandler), pbstrName);
}

STDMETHODIMP CVCCLCompilerOutputPage::put_ProgramDataBaseFileName(BSTR bstrName)
{
	CStringW strName = bstrName;
	strName.TrimLeft();
	if (strName.IsEmpty())	// don't want user setting this to blank or NULL
		return S_FALSE;
	else
		return SetStrProperty(VCCLID_ProgramDataBaseFileName, bstrName);
}

void CVCCLCompilerOutputPage::GetBaseDefault(long id, CComVariant& varValue)
{
	CComBSTR bstrVal;
	switch (id)
	{
	case VCCLID_AssemblerListingLocation:
	case VCCLID_ObjectFile:
	case VCCLID_ProgramDataBaseFileName:
		CVCCLCompilerTool::s_optHandler.GetDefaultValue( id, &bstrVal, m_pContainer );
		break;
	default:
		CBase::GetBaseDefault(id, varValue);
		return;
	}

	varValue = bstrVal;
}

// Browse info helpers
STDMETHODIMP CVCCLCompilerBrowsePage::get_BrowseInformation(browseInfoOption* poptSetting)
{	// see enum above, (/FR[name], /Fr[name])
	return ToolGetIntProperty(VCCLID_BrowseInformation, &(CVCCLCompilerTool::s_optHandler), (long *)poptSetting);
}

STDMETHODIMP CVCCLCompilerBrowsePage::put_BrowseInformation(browseInfoOption optSetting)
{
	CHECK_BOUNDS(INHERIT_PROP_VALUE, BrowseMax, optSetting);
	return SetIntProperty(VCCLID_BrowseInformation, optSetting);
}

STDMETHODIMP CVCCLCompilerBrowsePage::get_BrowseInformationFile(BSTR* pbstrFile)
{		// optional name to go with BrowseInformation property
	return ToolGetStrProperty(VCCLID_BrowseInformationFile, &(CVCCLCompilerTool::s_optHandler), pbstrFile);
}

STDMETHODIMP CVCCLCompilerBrowsePage::put_BrowseInformationFile(BSTR bstrFile)
{
	return SetStrProperty(VCCLID_BrowseInformationFile, bstrFile);
}

void CVCCLCompilerBrowsePage::GetBaseDefault(long id, CComVariant& varValue)
{
	if (id == VCCLID_BrowseInformationFile)
	{
		CComBSTR bstrVal;
		CVCCLCompilerTool::s_optHandler.GetDefaultValue( VCCLID_BrowseInformationFile, &bstrVal, m_pContainer );
		varValue = bstrVal;
	}
	else
		CBase::GetBaseDefault(id, varValue);
}

// Miscellaneous
STDMETHODIMP CVCCLCompilerGeneralPage::get_WarningLevel(warningLevelOption* poptSetting)
{	// see enum above (/W0 - /W4)
	return ToolGetIntProperty(VCCLID_WarningLevel, &(CVCCLCompilerTool::s_optHandler), (long *)poptSetting);
}

STDMETHODIMP CVCCLCompilerGeneralPage::put_WarningLevel(warningLevelOption optSetting)
{
	CHECK_BOUNDS(INHERIT_PROP_VALUE, CLWarnMax, optSetting);
	return SetIntProperty(VCCLID_WarningLevel, optSetting);
}

STDMETHODIMP CVCCLCompilerGeneralPage::get_WarnAsError(enumWarnAsErrorBOOL* pbWarnAsError)
{	// (/WX, /WX-) treat warnings as errors
	return GetEnumBoolProperty2(VCCLID_WarnAsError, (long *)pbWarnAsError);
}

STDMETHODIMP CVCCLCompilerGeneralPage::put_WarnAsError(enumWarnAsErrorBOOL bWarnAsError)
{
	return SetBoolProperty(VCCLID_WarnAsError, bWarnAsError);
}

STDMETHODIMP CVCCLCompilerGeneralPage::get_SuppressStartupBanner(enumSuppressStartupBannerBOOL* pbNoLogo)
{	// (/nologo, /nologo-) enable/disable suppression of copyright message
	return GetEnumBoolProperty2(VCCLID_SuppressStartupBanner, (long *)pbNoLogo);
}

STDMETHODIMP CVCCLCompilerGeneralPage::put_SuppressStartupBanner(enumSuppressStartupBannerBOOL bNoLogo)
{
	return SetBoolProperty(VCCLID_SuppressStartupBanner, bNoLogo);
}

STDMETHODIMP CVCCLCompilerGeneralPage::get_Detect64BitPortabilityProblems(enumDetect64BitPortabilityProblemsBOOL* pbDetect64BitPortabilityProblems)
{	// (/Wp64) detect 64 bit portability problems
	return GetEnumBoolProperty2(VCCLID_Detect64BitPortabilityProblems, (long *)pbDetect64BitPortabilityProblems);
}

STDMETHODIMP CVCCLCompilerGeneralPage::put_Detect64BitPortabilityProblems(enumDetect64BitPortabilityProblemsBOOL bDetect64BitPortabilityProblems)
{
	return SetBoolProperty(VCCLID_Detect64BitPortabilityProblems, bDetect64BitPortabilityProblems);
}

// Miscellaneous - X86 Specific Functionality
STDMETHODIMP CVCCLCompilerGeneralPage::get_CompileAsManaged(compileAsManagedOptions* poptSetting)
{ 
	return GetIntProperty(VCCLID_CompileAsManaged, (long *)poptSetting);
}

STDMETHODIMP CVCCLCompilerGeneralPage::put_CompileAsManaged(compileAsManagedOptions optSetting)
{
	CHECK_BOUNDS(INHERIT_PROP_VALUE, ComRTMax, optSetting);
	return SetIntProperty(VCCLID_CompileAsManaged, optSetting);
}

STDMETHODIMP CVCCLCompilerGeneralPage::get_DebugInformationFormat(debugOption* poptSetting)
{	// see enum above (/Z7, Zd, /ZI, /Zi)
	return ToolGetIntProperty(VCCLID_DebugInformationFormat, &(CVCCLCompilerTool::s_optHandler), (long *)poptSetting);
}

STDMETHODIMP CVCCLCompilerGeneralPage::put_DebugInformationFormat(debugOption optSetting)
{
	return SetIntProperty(VCCLID_DebugInformationFormat, optSetting);
}

STDMETHODIMP CVCCLCompilerGeneralPage::get_AdditionalIncludeDirectories(BSTR* pbstrIncludePath)
{	// (/I![path]) directory to add to include path, may have multiple
	return ToolGetStrProperty(VCCLID_AdditionalIncludeDirectories, &(CVCCLCompilerTool::s_optHandler), pbstrIncludePath, true /* local only */);
}

STDMETHODIMP CVCCLCompilerGeneralPage::put_AdditionalIncludeDirectories(BSTR bstrIncludePath)
{
	return SetStrProperty(VCCLID_AdditionalIncludeDirectories, bstrIncludePath);
}

STDMETHODIMP CVCCLCompilerGeneralPage::get_AdditionalUsingDirectories(BSTR* pbstrIncludePath)
{	// (/AI![path]) directory to add to LIBPATH path, may have multiple
	return ToolGetStrProperty(VCCLID_AdditionalUsingDirectories, &(CVCCLCompilerTool::s_optHandler), pbstrIncludePath, true /* local only */);
}

STDMETHODIMP CVCCLCompilerGeneralPage::put_AdditionalUsingDirectories(BSTR bstrIncludePath)
{
	return SetStrProperty(VCCLID_AdditionalUsingDirectories, bstrIncludePath);
}

void CVCCLCompilerGeneralPage::GetBaseDefault(long id, CComVariant& varValue)
{
	if (id == VCCLID_SuppressStartupBanner)
	{
		VARIANT_BOOL bVal;
		CVCCLCompilerTool::s_optHandler.GetDefaultValue( id, &bVal );
		varValue = bVal;
	}
	else
		CBase::GetBaseDefault(id, varValue);
}

// Advanced
STDMETHODIMP CVCCLCompilerAdvancedPage::get_CallingConvention(callingConventionOption* poptSetting)
{ 
	return ToolGetIntProperty(VCCLID_CallingConvention, &(CVCCLCompilerTool::s_optHandler), (long *)poptSetting);
}

STDMETHODIMP CVCCLCompilerAdvancedPage::put_CallingConvention(callingConventionOption optSetting)
{
	CHECK_BOUNDS(INHERIT_PROP_VALUE, CallConvMax, optSetting);
	return SetIntProperty(VCCLID_CallingConvention, optSetting);
}

STDMETHODIMP CVCCLCompilerAdvancedPage::get_CompileAs(CompileAsOptions* pcompileAs)
{	// see enum above (/TC, /TP)
	return ToolGetIntProperty(VCCLID_CompileAs, &(CVCCLCompilerTool::s_optHandler), (long *)pcompileAs);
}

STDMETHODIMP CVCCLCompilerAdvancedPage::put_CompileAs(CompileAsOptions compileAs)
{
	CHECK_BOUNDS(INHERIT_PROP_VALUE, CompileAsMax, compileAs);
	return SetIntProperty(VCCLID_CompileAs, compileAs);
}

STDMETHODIMP CVCCLCompilerAdvancedPage::get_DisableSpecificWarnings(BSTR* pbstrDisableSpecificWarnings)
{	// (/wd<num>) disable specific warnings; multi-prop
	return ToolGetStrProperty(VCCLID_DisableSpecificWarnings, &(CVCCLCompilerTool::s_optHandler), pbstrDisableSpecificWarnings, true /* local only */);
}

STDMETHODIMP CVCCLCompilerAdvancedPage::put_DisableSpecificWarnings(BSTR bstrDisableSpecificWarnings)
{
	return SetStrProperty(VCCLID_DisableSpecificWarnings, bstrDisableSpecificWarnings);
}

STDMETHODIMP CVCCLCompilerAdvancedPage::get_ForcedIncludeFiles(BSTR* pbstrName)
{	// (/FI![name]) name forced include file, can have multiple
	return ToolGetStrProperty(VCCLID_ForcedIncludeFiles, &(CVCCLCompilerTool::s_optHandler), pbstrName, true /* local only */);
}

STDMETHODIMP CVCCLCompilerAdvancedPage::put_ForcedIncludeFiles(BSTR bstrName)
{
	return SetStrProperty(VCCLID_ForcedIncludeFiles, bstrName);
}

STDMETHODIMP CVCCLCompilerAdvancedPage::get_ForcedUsingFiles(BSTR* pbstrName)
{	// (/FU![name]) name forced #using file, can have multiple
	return ToolGetStrProperty(VCCLID_ForcedUsingFiles, &(CVCCLCompilerTool::s_optHandler), pbstrName, true /* local only */);
}

STDMETHODIMP CVCCLCompilerAdvancedPage::put_ForcedUsingFiles(BSTR bstrName)
{
	return SetStrProperty(VCCLID_ForcedUsingFiles, bstrName);
}

STDMETHODIMP CVCCLCompilerAdvancedPage::get_ShowIncludes(enumShowIncludesBOOL* pbShowInc)
{	// (/showIncludes)
	return GetEnumBoolProperty2(VCCLID_ShowIncludes, (long *)pbShowInc); 
}

STDMETHODIMP CVCCLCompilerAdvancedPage::put_ShowIncludes(enumShowIncludesBOOL bShowInc)
{
	return SetBoolProperty(VCCLID_ShowIncludes, bShowInc);
}

STDMETHODIMP CVCCLCompilerAdvancedPage::get_UndefinePreprocessorDefinitions(BSTR* pbstrUndefines)
{	// (/U[name]) undefine predefined macro, can have multiple
	return ToolGetStrProperty(VCCLID_UndefinePreprocessorDefinitions, &(CVCCLCompilerTool::s_optHandler), pbstrUndefines, true /* local only */);
}

STDMETHODIMP CVCCLCompilerAdvancedPage::put_UndefinePreprocessorDefinitions(BSTR bstrUndefines)	
{
	return SetStrProperty(VCCLID_UndefinePreprocessorDefinitions, bstrUndefines);
}

STDMETHODIMP CVCCLCompilerAdvancedPage::get_UndefineAllPreprocessorDefinitions(enumUndefineAllPreprocessorDefinitionsBOOL* pbPredefinedMacros)
{	// (/u) undefine all predefined macros 
	return GetEnumBoolProperty2(VCCLID_UndefineAllPreprocessorDefinitions, (long *)pbPredefinedMacros);
}

STDMETHODIMP CVCCLCompilerAdvancedPage::put_UndefineAllPreprocessorDefinitions(enumUndefineAllPreprocessorDefinitionsBOOL bPredefinedMacros)
{
	return SetBoolProperty(VCCLID_UndefineAllPreprocessorDefinitions, bPredefinedMacros);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\vcpb\buildlogging.cpp ===
#include "stdafx.h"
#pragma hdrstop
#include <locale.h>
#include <vccolls.h>
#include "BuildLogging.h"
#include "msgboxes2.h"
#include "util2.h"
#include "vcprojectengine.h"
#include "FileRegistry.h"
#include "bldhelpers.h"
#include "buildengine.h"
#include "xmlfile.h"

///////////////////////////////////////////////////////////////////////////////
// Log helpers:

CBldLogEnabler::CBldLogEnabler(VCConfiguration *pProjCfg, IVCBuildEngine* pBuildEngine)
{ 
	m_spBuildEngineImpl = pBuildEngine;
	if (m_spBuildEngineImpl)
		m_spBuildEngineImpl->OpenProjectConfigurationLog(pProjCfg); 
}

CBldLogEnabler::~CBldLogEnabler()
{ 
	if (m_spBuildEngineImpl)
		m_spBuildEngineImpl->CloseProjectConfigurationLog();
}

BOOL CDynamicBuildEngine::HaveLogging()
{
	return (m_pLogFile != NULL);
}

STDMETHODIMP CDynamicBuildEngine::OpenProjectConfigurationLog(VCConfiguration *pProjCfg)
{
	if (m_pLogFile != NULL) return S_OK;	// Already open
	if (CVCProjectEngine::s_bBuildLogging == VARIANT_FALSE)
		return S_FALSE;

	if (m_strLogFile.IsEmpty())
	{
		VSASSERT(pProjCfg != NULL, "Trying to open a log file without a config to go with it");
		RETURN_ON_NULL2(pProjCfg, S_FALSE);

		HRESULT hr = S_OK;
		CComQIPtr<IVCPropertyContainer> spPropContainer = pProjCfg;
		VSASSERT(spPropContainer != NULL, "Config is not a property container!?!");
		CComBSTR bstrProjDir;
		if (spPropContainer)
		{
			hr = spPropContainer->GetStrProperty(VCPROJID_ProjectDirectory, &bstrProjDir);	// should never have macros in it
			VSASSERT(SUCCEEDED(hr), "Project directory property always available!");
		}
		CStringW strProjDir = bstrProjDir;
		CDirW dirProj;
		dirProj.CreateFromKnown(strProjDir);

		CComBSTR bstrIntDir;
		if (spPropContainer)
		{
			hr = spPropContainer->GetEvaluatedStrProperty(VCCFGID_IntermediateDirectory, &bstrIntDir);
			if (hr != S_OK || bstrIntDir.Length() == 0)
			{
				hr = spPropContainer->GetEvaluatedStrProperty(VCCFGID_OutputDirectory, &bstrIntDir);
				if (hr != S_OK || bstrIntDir.Length() == 0)
				{
					bstrIntDir = bstrProjDir;
					hr = S_OK;
				}
			}
			VSASSERT(hr == S_OK && bstrIntDir.Length() > 0, "At least one of Intermediate, Output, or Project directory properties always available!");
		}
		CStringW strIntDir = bstrIntDir;

		CStringW strTmp;
		strTmp.Format(L"%s\\BuildLog.htm", strIntDir);

		CPathW FilePath;
		FilePath.CreateFromDirAndRelative(dirProj, strTmp);
		FilePath.GetFullPath(m_strLogFile);
		if (m_spBuildErrorContext)
		{
		    	// REVIEW(KiP): this is a weird test. do we need this ?
			CStringA strLogFileA = m_strLogFile;
			CStringW strLogFileW = strLogFileA;
			if (strLogFileW != m_strLogFile)
			{
				CStringW strMsg;
				strMsg.Format(IDS_ERR_UNICODE_PATH_PRJ0024, strLogFileW);
				CVCProjectEngine::AddProjectError(m_spBuildErrorContext, strMsg, L"PRJ0024", spPropContainer);
			}
		}

		// create the directory if it doesn't exist...
		// otherwise we definately won't be able to open the log file
		CDirW dirInt;
		dirInt.CreateFromPath( FilePath );
		if( !dirInt.ExistsOnDisk() )
			dirInt.CreateOnDisk();
	}
	if ((m_pLogFile = fopenW(m_strLogFile, m_bFirstUsage ? L"w+t" : L"a+")) == NULL)
	{
		// ATLTRACE("Opening project log file %s failed\n", (const wchar_t *) m_strLogFile);
		return E_FAIL;
	}
	else
	{
		if (m_bFirstUsage)
		{
			CStringW strTrueHeader = L"<html>\n<head>\n";
			CComBSTR bstrEncoding;
			CXMLFile::DetermineDefaultFileEncoding(bstrEncoding);
			CStringW strEncoding = bstrEncoding;
			CStringW strMidHeader;
			strMidHeader.Format(IDS_HTML_HEADER_MARKER, strEncoding);
			strTrueHeader += strMidHeader;
			strTrueHeader += L"</head>\n<body>\n<pre>\n";

			LogTrace((eLogSectionTypes)(eLogHeader|eLogStartSection), strTrueHeader);
			if (m_cReuseLogFile > 0)
				m_bFirstUsage = FALSE;
		}

		SetCurrentLogSection(eLogHeader);

		CStringW strTopText;
		strTopText.LoadString(IDS_HTML_HEADER);
		CStringW strPreTop;
		strPreTop.LoadString(IDS_HTML_PRE_TOP);
		CStringW strPostTop;
		strPostTop.LoadString(IDS_HTML_POST_TOP);
	
		CStringW strHeader = strPreTop + strTopText + strPostTop;
		
		// LogTrace(L"<h1>BuildLog</h1>\n");
		LogTrace(eLogHeader, strHeader);
	}

	return S_OK;
}

STDMETHODIMP CDynamicBuildEngine::CloseProjectConfigurationLog()
{
	if (!m_pLogFile) return S_OK;

	if (m_cReuseLogFile == 0)
	{
		SetCurrentLogSection(eLogFooter);
		CStringW strPreFooter;
		strPreFooter.LoadString(IDS_HTML_PRE_FOOTER);
		CStringW strPostFooter;
		strPostFooter.LoadString(IDS_HTML_POST_FOOTER);

		CStringW strFooter = strPreFooter + strPostFooter;

		LogTrace(eLogFooter, strFooter);
		m_bFirstUsage = TRUE;
		m_cReuseLogFile = 0;
		m_strLogFile.Empty();
	}
	FlushLogSection(eLogAll);

	fclose (m_pLogFile);
	m_pLogFile = NULL;
	return S_OK;
}

CVCStringWList* CDynamicBuildEngine::FindLogBuffer(eLogSectionTypes logSection, BOOL bAdvanceOne /* = FALSE */, 
	eLogSectionTypes* pNewLogSection /* = NULL */)
{
	logSection = (eLogSectionTypes)(logSection & eLogAll);	// mask off any modifiers

	if (bAdvanceOne)
	{
		if (logSection == eLogAll || logSection == eLogNoSection)
			logSection = eLogHeader;
		else if (logSection == eLogHeader)
			logSection = eLogEnvironment;
		else if (logSection == eLogEnvironment)
			logSection = eLogCommand;
		else if (logSection == eLogCommand)
			logSection = eLogOutput;
		else if (logSection == eLogOutput)
			logSection = eLogResults;
		else if (logSection == eLogResults)
			logSection = eLogFooter;
		else if (logSection == eLogFooter)
			logSection = eLogNoSection;

		if (pNewLogSection)
			*pNewLogSection = logSection;
	}
	else if (logSection == eLogAll)
		logSection = m_logCurrentSection;

	switch (logSection)
	{
	case eLogHeader:
		return &m_logHeaderLines;
	case eLogEnvironment:
		return &m_logEnvironmentLines;
	case eLogCommand:
		return &m_logCommandLines;
	case eLogOutput:
		return &m_logOutputLines;
	case eLogResults:
		return &m_logResultsLines;
	case eLogFooter:
		return &m_logFooterLines;
	default:
		return NULL;
	}
}

#define DBG_BUFSIZE 2048
#define MAX_DBG_BUFSIZE (512*DBG_BUFSIZE)	// 1 meg worth.

void CDECL CDynamicBuildEngine::LogTrace(eLogSectionTypes logSection, LPCOLESTR szBuffer)
{
	if (CVCProjectEngine::s_bBuildLogging == VARIANT_FALSE)
		return;

	if (!m_pLogFile)
		return;   	

	CVCStringWList* pLogList = FindLogBuffer(logSection);	// not figuring out the right section == write immediately
	if (pLogList == NULL || (logSection & m_logCurrentSection))
	{
		CStringA strBufferA = szBuffer;		// yes, ANSI -- 'cause we're writing an ANSI log file
		if (fputs(strBufferA, m_pLogFile) == EOF)
			CloseProjectConfigurationLog();
	}
	else
	{
		if (logSection & eLogStartSection)
			pLogList->AddHead(szBuffer);
		else
			pLogList->AddTail(szBuffer);
	}
}

void CDynamicBuildEngine::FlushSingleLogSection(CVCStringWList* pLogList)
{
	if (pLogList == NULL)
		return;

	while (m_pLogFile && !pLogList->IsEmpty())
	{
		CStringA strLine = pLogList->RemoveHead();	// yes, ANSI -- 'cause we're writing an ANSI log file
		if (fputs(strLine, m_pLogFile) == EOF)
			CloseProjectConfigurationLog();
	}
}

void CDynamicBuildEngine::FlushLogSection(eLogSectionTypes logSection)
{
	if (CVCProjectEngine::s_bBuildLogging == VARIANT_FALSE)
		return;
	if( !m_pLogFile)
		return;

	CVCStringWList* pLogList = NULL;
	if ((logSection & eLogAll) != eLogAll)	// flush a single section
	{
		pLogList = FindLogBuffer(logSection);
		FlushSingleLogSection(pLogList);
	}
	else	// go through all of them
	{
		eLogSectionTypes tmpLogSection = eLogNoSection;
		while (m_pLogFile)
		{
			pLogList = FindLogBuffer(tmpLogSection, TRUE, &tmpLogSection);
			if (pLogList == NULL)
				break;

			FlushSingleLogSection(pLogList);
		}
	}
}

void CDynamicBuildEngine::SetCurrentLogSection(eLogSectionTypes logSection)
{
	FlushLogSection(eLogAll);
	m_logCurrentSection = logSection;
}

eLogSectionTypes CDynamicBuildEngine::GetCurrentLogSection()
{
	return m_logCurrentSection;
}

///////////////////////////////////////////////////////////////////////////////////////////////////
// CBldCommandLineEC

int CBldCommandLineEC::s_cnt = 0;

HRESULT CBldCommandLineEC::CreateInstance(IVCBuildErrorContext** ppContext, CBldCommandLineEC** ppContextObj,
	IVCBuildEngine* pBuildEngine)
{
	if (ppContext)
		*ppContext = NULL;
	if (ppContextObj)
		*ppContextObj = NULL;

	IVCBuildErrorContext *pVar;
	CComObject<CBldCommandLineEC> *pObj;
	HRESULT hr = CComObject<CBldCommandLineEC>::CreateInstance(&pObj);
	if (SUCCEEDED(hr))
	{
		pVar = (IVCBuildErrorContext*)pObj;
		pVar->AddRef();
		if (ppContext)
			*ppContext = pVar;
		if (ppContextObj)
			*ppContextObj = pObj;
		pObj->m_spBuildEngine = pBuildEngine;
	}
	return hr;
}

STDMETHODIMP CBldCommandLineEC::AddError(BSTR bstrMessage, BSTR bstrHelpKeyword, BSTR bstrFile, long nLine, BSTR bstrFullMsg )
{
	m_nErrors++;
	if (m_bShowOutput == VARIANT_FALSE)
		return S_OK;

	// Format the Message
	CStringW strFullMessage = bstrMessage;
	if( strFullMessage.IsEmpty() )
	{
		if( nLine )
			strFullMessage.Format(L"%s(%d) : error %s : %s\n",bstrFile, nLine, bstrHelpKeyword, bstrMessage);
		else
			strFullMessage.Format(L"%s : error %s : %s\n",bstrFile, bstrHelpKeyword, bstrMessage);
	}
	else
	{
		strFullMessage += L"\n";
	}

	CVCProjectEngine::DoWriteLog(strFullMessage, FALSE);
	return S_OK;
}

STDMETHODIMP CBldCommandLineEC::AddWarning(BSTR bstrMessage, BSTR bstrHelpKeyword, BSTR bstrFile, long nLine, BSTR bstrFullMsg )
{
	m_nWarnings++;
	if (m_bShowOutput == VARIANT_FALSE)
		return S_OK;

	// Format the Message
	CStringW strFullMessage = bstrFullMsg;
	if( strFullMessage.IsEmpty() )
	{
		if( nLine )
			strFullMessage.Format(L"%s(%d) : warning %s : %s\n",bstrFile, nLine, bstrHelpKeyword, bstrMessage);
		else
			strFullMessage.Format(L"%s : warning %s : %s\n",bstrFile, bstrHelpKeyword, bstrMessage);
	}
	else
	{
		strFullMessage += L"\n";
	}
	
	CVCProjectEngine::DoWriteLog(strFullMessage, FALSE);
	return S_OK;
}

STDMETHODIMP CBldCommandLineEC::AddInfo(BSTR bstrMessage)
{
	if (m_bShowOutput == VARIANT_FALSE)
		return S_OK;

	CStringW strChar;
	if( bstrMessage && bstrMessage[0] )
	{
//		strChar.Format(L"%d>%s", m_nContext,bstrMessage);
		strChar.Format(L"%s", bstrMessage);
	}
	else
	{
//		strChar.Format(L"%d>\n", m_nContext);
		strChar.Format(L"\n");
	}
	CVCProjectEngine::DoWriteLog(strChar, VARIANT_FALSE);
	return S_OK;
}

STDMETHODIMP CBldCommandLineEC::AddLine(BSTR bstrMessage)
{
	if (m_bShowOutput == VARIANT_FALSE)
		return S_OK;

	CStringW strChar;
	if( bstrMessage && bstrMessage[0] )
	{
//		strChar.Format(L"%d>%s", m_nContext,bstrMessage);
		strChar.Format(L"%s", bstrMessage);
	}
	else
	{
//		strChar.Format(L"%d>\n", m_nContext);
		strChar.Format(L"\n");
	}
	CVCProjectEngine::DoWriteLog(strChar, VARIANT_FALSE);
	return S_OK;
}

STDMETHODIMP CBldCommandLineEC::WriteLog(BSTR bstrMessage)
{
	if (m_bShowOutput == VARIANT_FALSE)
		return S_OK;

	CStringW strChar;
	if( bstrMessage && bstrMessage[0] )
	{
//		strChar.Format(L"%d>%s", m_nContext, bstrMessage);
		strChar.Format(L"%s",  bstrMessage);
	}
	else
	{
//		strChar.Format(L"%d>\n", m_nContext);
		strChar.Format(L"\n");
	}
	CVCProjectEngine::DoWriteLog(strChar, VARIANT_TRUE);
	return S_OK;
}

STDMETHODIMP CBldCommandLineEC::ClearWindow()
{
	m_nWarnings = 0;
	m_nErrors = 0;
	return S_OK;
}

STDMETHODIMP CBldCommandLineEC::get_BaseDirectory(BSTR* pbstrBaseDir)
{
	return m_bstrDir.CopyTo(pbstrBaseDir);
}

STDMETHODIMP CBldCommandLineEC::put_BaseDirectory(BSTR bstrBaseDir)
{
	m_bstrDir = bstrBaseDir;
	return S_OK;
}

STDMETHODIMP CBldCommandLineEC::get_ProjectName(BSTR* pbstrName)
{
	return m_bstrName.CopyTo(pbstrName);
}

STDMETHODIMP CBldCommandLineEC::put_ProjectName(BSTR bstrName)
{
	m_bstrName = bstrName;
	return S_OK;
}

STDMETHODIMP CBldCommandLineEC::get_Warnings( long *pnWrn )
{
	CHECK_POINTER_NULL(pnWrn);
	*pnWrn = m_nWarnings;
	return S_OK;
}

STDMETHODIMP CBldCommandLineEC::get_Errors( long *pnErr )
{
	CHECK_POINTER_NULL(pnErr);
	*pnErr = m_nErrors;
	return S_OK;
}

STDMETHODIMP CBldCommandLineEC::get_AssociatedBuildEngine(IDispatch** ppBldEngine)
{
	CHECK_POINTER_NULL(ppBldEngine);
	CComQIPtr<IDispatch> spDispBldEngine = m_spBuildEngine;
	*ppBldEngine = spDispBldEngine.Detach();
	return S_OK;
}

STDMETHODIMP CBldCommandLineEC::put_AssociatedBuildEngine(IDispatch* pBldEngine)
{
	m_spBuildEngine = pBldEngine;
	return S_OK;
}

STDMETHODIMP CBldCommandLineEC::get_ShowOutput(VARIANT_BOOL* pbShow)
{
	CHECK_POINTER_NULL(pbShow);
	*pbShow = m_bShowOutput;
	return S_OK;
}

STDMETHODIMP CBldCommandLineEC::put_ShowOutput(VARIANT_BOOL bShow)
{
	m_bShowOutput = bShow;
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\vcpb\cltoolbase.h ===
// CLTool.h : Declaration of the CCLTool

#pragma once

#include "vctool.h"
#include "settingspage.h"

template<class T, class IFace>
class ATL_NO_VTABLE CVCCLCompilerBasePage :
	public IDispatchImpl<IFace, &(__uuidof(IFace)), &LIBID_VCProjectEnginePrivateLibrary, PrivateProjBuildTypeLibNumber, 0, CVsTypeInfoHolder>,
	public CPageObjectImpl<T,VCCLCOMPILERTOOL_MIN_DISPID,VCCLCOMPILERTOOL_MAX_DISPID>,
	public CComObjectRoot
{
public:

BEGIN_COM_MAP(T)
	COM_INTERFACE_ENTRY(IPerPropertyBrowsing)
	COM_INTERFACE_ENTRY(IVsPerPropertyBrowsing)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IFace)
	COM_INTERFACE_ENTRY(IVCPropertyContainer)
	COM_INTERFACE_ENTRY(IProvidePropertyBuilder)
END_COM_MAP()

	// IDispatch override
	STDMETHOD(Invoke)( DISPID dispid, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS *pdispParams, VARIANT *pvarResult, EXCEPINFO *pexcepInfo, UINT *puArgErr )
	{
		IDispatchImpl<IFace, &(__uuidof(IFace)), &LIBID_VCProjectEnginePrivateLibrary, PrivateProjBuildTypeLibNumber,0, CVsTypeInfoHolder>::Invoke( dispid, riid, lcid, wFlags, pdispParams, pvarResult, pexcepInfo, puArgErr );
		return S_OK;
	}
};
	
class ATL_NO_VTABLE CVCCLCompilerOptimizationPage :
	public CVCCLCompilerBasePage<CVCCLCompilerOptimizationPage, IVCCLCompilerOptimizationPage>
{
// IVCCLCompilerOptimizationPage
public:
	STDMETHOD(get_Optimization)(optimizeOption* poptSetting);	// see enum above (/O1, /O2, /Od, /Ox)
	STDMETHOD(put_Optimization)(optimizeOption optSetting);
	STDMETHOD(get_GlobalOptimizations)(enumGlobalOptimizationsBOOL* pbGlobalOpt);	// (/Og, /Og-) enable/disable global optimizations; incompatible with all RTC options, GZ, ZI, EEf
	STDMETHOD(put_GlobalOptimizations)(enumGlobalOptimizationsBOOL bGlobalOpt);
	STDMETHOD(get_InlineFunctionExpansion)(inlineExpansionOption* poptSetting);	// see enum above (/Ob0, /Ob1, /Ob2)
	STDMETHOD(put_InlineFunctionExpansion)(inlineExpansionOption optSetting);
	STDMETHOD(get_EnableIntrinsicFunctions)(enumEnableIntrinsicFunctionsBOOL* pbEnableIntrinsic);	// (/Oi, /Oi-) enable/disable intrinsic functions; works best with /Og
	STDMETHOD(put_EnableIntrinsicFunctions)(enumEnableIntrinsicFunctionsBOOL bEnableIntrinsic);
	STDMETHOD(get_ImproveFloatingPointConsistency)(enumImproveFloatingPointConsistencyBOOL* pbImproveFloat);	// (/Op, /Op-) (don't) improve floating-point consistency
	STDMETHOD(put_ImproveFloatingPointConsistency)(enumImproveFloatingPointConsistencyBOOL bImproveFloat);
	STDMETHOD(get_FavorSizeOrSpeed)(favorSizeOrSpeedOption* poptSetting);	// (/Os, Ot) favor size/speed; works best with /Og
	STDMETHOD(put_FavorSizeOrSpeed)(favorSizeOrSpeedOption optSetting);
	STDMETHOD(get_OmitFramePointers)(enumOmitFramePointersBOOL* poptSetting);	// (/Oy, Oy-) enable/disable frame pointer omission
	STDMETHOD(put_OmitFramePointers)(enumOmitFramePointersBOOL optSetting);
	STDMETHOD(get_EnableFiberSafeOptimizations)(enumEnableFiberSafeOptimizationsBOOL* pbFiberSafeTLS);	// (/GT) generate fiber-safe TLS accesses
	STDMETHOD(put_EnableFiberSafeOptimizations)(enumEnableFiberSafeOptimizationsBOOL bFiberSafeTLS);
	STDMETHOD(get_OptimizeForProcessor)(ProcessorOptimizeOption* poptSetting);	// see ProcessorOptimizeOption enum (/G5, /G6, /GB)
	STDMETHOD(put_OptimizeForProcessor)(ProcessorOptimizeOption optSetting);
	STDMETHOD(get_OptimizeForWindowsApplication)(enumOptimizeForWindowsApplicationBOOL* poptSetting); // (/GA) optimize for Windows app
	STDMETHOD(put_OptimizeForWindowsApplication)(enumOptimizeForWindowsApplicationBOOL optSetting);

// IVsPerPropertyBrowsing
public:
	STDMETHOD(IsPropertyReadOnly)( DISPID dispid, BOOL *fReadOnly);
};

class ATL_NO_VTABLE CVCCLCompilerPreProcessorPage :
	public CVCCLCompilerBasePage<CVCCLCompilerPreProcessorPage, IVCCLCompilerPreProcessorPage>
{
// IVCCLCompilerPreProcessorPage
public:
	STDMETHOD(get_PreprocessorDefinitions)(BSTR* pbstrDefines);		// (/D[name]) defines, can have multiple
	STDMETHOD(put_PreprocessorDefinitions)(BSTR bstrDefines);
	STDMETHOD(get_IgnoreStandardIncludePath)(enumIgnoreStandardIncludePathBOOL* pbIgnoreInclPath);	// (/X) ignore standard include path
	STDMETHOD(put_IgnoreStandardIncludePath)(enumIgnoreStandardIncludePathBOOL bIgnoreInclPath);
	STDMETHOD(get_GeneratePreprocessedFile)(preprocessOption* poptSetting);	// see preprocessOption enum (/P, /EP /P)
	STDMETHOD(put_GeneratePreprocessedFile)(preprocessOption optSetting);
	STDMETHOD(get_KeepComments)(enumKeepCommentsBOOL* pbkeepComments);	// (/C) don't strip comments, requires one of /E, /EP, /P switches
	STDMETHOD(put_KeepComments)(enumKeepCommentsBOOL bkeepComments);
};

class ATL_NO_VTABLE CVCCLCompilerAdvancedPage :
	public CVCCLCompilerBasePage<CVCCLCompilerAdvancedPage, IVCCLCompilerAdvancedPage>
{
// IVCCLCompilerAdvancedPage
public:
	STDMETHOD(get_CallingConvention)(callingConventionOption* poptSetting);	// see callingConventionOption enum (/Gd, /Gr, /Gz)
	STDMETHOD(put_CallingConvention)(callingConventionOption optSetting);
	STDMETHOD(get_CompileAs)(CompileAsOptions* pcompileAs);	// see enum above (/TC, /TP)
	STDMETHOD(put_CompileAs)(CompileAsOptions compileAs);
	STDMETHOD(get_DisableSpecificWarnings)(BSTR* pbstrDisableSpecificWarnings);	// (/wd<num>) disable specific warnings; multi-prop
	STDMETHOD(put_DisableSpecificWarnings)(BSTR bstrDisableSpecificWarnings);
	STDMETHOD(get_ForcedIncludeFiles)(BSTR* pbstrName);	// (/FI![name]) name forced include file, can have multiple
	STDMETHOD(put_ForcedIncludeFiles)(BSTR bstrName);
	STDMETHOD(get_ForcedUsingFiles)(BSTR* pbstrName);	// (/FU![name]) name forced #using file, can have multiple
	STDMETHOD(put_ForcedUsingFiles)(BSTR bstrName);
	STDMETHOD(get_ShowIncludes)(enumShowIncludesBOOL* pbShowInc);	// (/showIncludes)
	STDMETHOD(put_ShowIncludes)(enumShowIncludesBOOL bShowInc);
	STDMETHOD(get_UndefinePreprocessorDefinitions)(BSTR* pbstrUndefines);	// (/U[name]) undefine predefined macro, can have multiple
	STDMETHOD(put_UndefinePreprocessorDefinitions)(BSTR bstrUndefines);	
	STDMETHOD(get_UndefineAllPreprocessorDefinitions)(enumUndefineAllPreprocessorDefinitionsBOOL* pbPredefinedMacros);	// (/u) undefine all predefined macros 
	STDMETHOD(put_UndefineAllPreprocessorDefinitions)(enumUndefineAllPreprocessorDefinitionsBOOL bPredefinedMacros);
};

class ATL_NO_VTABLE CVCCLCompilerCodeGenPage :
	public CVCCLCompilerBasePage<CVCCLCompilerCodeGenPage, IVCCLCompilerCodeGenPage>
{
// IVCCLCompilerCodeGenPage
public:
	STDMETHOD(get_StringPooling)(enumStringPoolingBOOL* pbPool);	// (/GF) enable read-only string pooling
	STDMETHOD(put_StringPooling)(enumStringPoolingBOOL bPool);
	STDMETHOD(get_MinimalRebuild)(enumMinimalRebuildBOOL* pbMinimalRebuild);	// (/Gm, /FD) enable minimal rebuild vs. generate dependencies, /Gm requires /ZI or /Zi
	STDMETHOD(put_MinimalRebuild)(enumMinimalRebuildBOOL bMinimalRebuild);
	STDMETHOD(get_ExceptionHandling)(enumExceptionHandlingBOOL* poptSetting);	// /EHsc
	STDMETHOD(put_ExceptionHandling)(enumExceptionHandlingBOOL optSetting);
	STDMETHOD(get_BasicRuntimeChecks)(basicRuntimeCheckOption* poptSetting);	// /RTCs, /RTCu, /RTC1
	STDMETHOD(put_BasicRuntimeChecks)(basicRuntimeCheckOption optSetting);
	STDMETHOD(get_SmallerTypeCheck)(enumSmallerTypeCheckBOOL* pbSmallerType);	// (/RTCc) convert to smaller types check, incompatible with Og, O1, O2, Ox
	STDMETHOD(put_SmallerTypeCheck)(enumSmallerTypeCheckBOOL bSmallerType);
	STDMETHOD(get_RuntimeLibrary)(runtimeLibraryOption* poptSetting);	// see runtimeLibraryOption enum (/MD, /MDd, /ML, /MLd, /MT, /MTd)
	STDMETHOD(put_RuntimeLibrary)(runtimeLibraryOption optSetting);
	STDMETHOD(get_StructMemberAlignment)(structMemberAlignOption* poptSetting);	// see structMemberAlignOption enum (/Zp[num])
	STDMETHOD(put_StructMemberAlignment)(structMemberAlignOption optSetting);
	STDMETHOD(get_BufferSecurityCheck)(enumBufferSecurityCheckBOOL* bSecure);	// (/GS) enable buffer overrun checks; buffer security from hackers
	STDMETHOD(put_BufferSecurityCheck)(enumBufferSecurityCheckBOOL bSecure);
	STDMETHOD(get_EnableFunctionLevelLinking)(enumEnableFunctionLevelLinkingBOOL* pbPackage);	// (/Gy) enable function level linking (no explicit off)
	STDMETHOD(put_EnableFunctionLevelLinking)(enumEnableFunctionLevelLinkingBOOL bPackage);

// helpers
public:
	virtual void GetBaseDefault(long id, CComVariant& varValue);
};


class ATL_NO_VTABLE CVCCLCompilerLanguagePage :
	public CVCCLCompilerBasePage<CVCCLCompilerLanguagePage, IVCCLCompilerLanguagePage>
{
// IVCCLCompilerLanguagePage
public:
	STDMETHOD(get_DisableLanguageExtensions)(enumDisableLanguageExtensionsBOOL* pbDisableExtensions);	// (/Za, /Ze) disable/enable language extensions (/Ze default)
	STDMETHOD(put_DisableLanguageExtensions)(enumDisableLanguageExtensionsBOOL bDisableExtensions);
	STDMETHOD(get_DefaultCharIsUnsigned)(enumDefaultCharIsUnsignedBOOL* pbIsUnsigned);	// (/J) default char type is unsigned
	STDMETHOD(put_DefaultCharIsUnsigned)(enumDefaultCharIsUnsignedBOOL bIsUnsigned);
	STDMETHOD(get_TreatWChar_tAsBuiltInType)(enumTreatWChar_tAsBuiltInTypeBOOL* pbBuiltInType);
	STDMETHOD(put_TreatWChar_tAsBuiltInType)(enumTreatWChar_tAsBuiltInTypeBOOL bBuiltInType);
	STDMETHOD(get_ForceConformanceInForLoopScope)(enumForceConformanceInForLoopScopeBOOL* pbConform);	// (/Zc:forScope) check for conformance of vars for 'for' scope
	STDMETHOD(put_ForceConformanceInForLoopScope)(enumForceConformanceInForLoopScopeBOOL bConform);
	STDMETHOD(get_RuntimeTypeInfo)(enumRTTIBOOL* pbRTTI);	// (/GR, /GR-) enable/disable C++ RTTI
	STDMETHOD(put_RuntimeTypeInfo)(enumRTTIBOOL bRTTI);
};

class ATL_NO_VTABLE CVCCLCompilerPCHPage :
	public CVCCLCompilerBasePage<CVCCLCompilerPCHPage, IVCCLCompilerPCHPage>
{
// IVCCLCompilerPCHPage
public:
	STDMETHOD(get_UsePrecompiledHeader)(pchOption* poptSetting);	// see enum above (/Yc, /YX, /Yu)
	STDMETHOD(put_UsePrecompiledHeader)(pchOption optSetting);
	STDMETHOD(get_PrecompiledHeaderThrough)(BSTR* pbstrFile);	// optional argument to UsePrecompiledHeader property specifying file to use to generate/use PCH
	STDMETHOD(put_PrecompiledHeaderThrough)(BSTR bstrFile);
	STDMETHOD(get_PrecompiledHeaderFile)(BSTR* pbstrPCH);	// (/Fp[name]) name the precompiled header file, can be directory location or leave off .pch extension
	STDMETHOD(put_PrecompiledHeaderFile)(BSTR bstrPCH);

// helpers
public:
	virtual void GetBaseDefault(long id, CComVariant& varValue);
};

class ATL_NO_VTABLE CVCCLCompilerOutputPage :
	public CVCCLCompilerBasePage<CVCCLCompilerOutputPage, IVCCLCompilerOutputPage>
{
// IVCCLCompilerOutputPage
public:
	STDMETHOD(get_ExpandAttributedSource)(enumExpandAttributedSourceBOOL* pbExpandAttributedSource);	// (/Fx) expand attributed code into source file listing
	STDMETHOD(put_ExpandAttributedSource)(enumExpandAttributedSourceBOOL pExpandAttributedSource);
	STDMETHOD(get_AssemblerOutput)(asmListingOption* poptSetting);	// see enum above (/FA, /FAc, /FAs, /FAcs)
	STDMETHOD(put_AssemblerOutput)(asmListingOption optSetting);
	STDMETHOD(get_AssemblerListingLocation)(BSTR* pbstrName);	// (/Fa[name]) specify directory and/or name for listing file from AssemblerOutput property
	STDMETHOD(put_AssemblerListingLocation)(BSTR bstrName);
	STDMETHOD(get_ObjectFile)(BSTR* pbstrName);	// (/Fo[name]) name obj file
	STDMETHOD(put_ObjectFile)(BSTR bstrName);
	STDMETHOD(get_ProgramDataBaseFileName)(BSTR* pbstrName);	// (/Fd[file]) name PDB file.  can be directory name
	STDMETHOD(put_ProgramDataBaseFileName)(BSTR bstrName);

// helpers
public:
	virtual void GetBaseDefault(long id, CComVariant& varValue);
};

class ATL_NO_VTABLE CVCCLCompilerBrowsePage :
	public CVCCLCompilerBasePage<CVCCLCompilerBrowsePage, IVCCLCompilerBrowsePage>
{
// IVCCLCompilerBrowsePage
public:
	STDMETHOD(get_BrowseInformation)(browseInfoOption* poptSetting);	// see enum above, (/FR[name], /Fr[name])
	STDMETHOD(put_BrowseInformation)(browseInfoOption optSetting);
	STDMETHOD(get_BrowseInformationFile)(BSTR* pbstrFile);		// optional name to go with BrowseInformation property
	STDMETHOD(put_BrowseInformationFile)(BSTR bstrFile);

// helpers
public:
	virtual void GetBaseDefault(long id, CComVariant& varValue);
};

class ATL_NO_VTABLE CVCCLCompilerGeneralPage :
	public CVCCLCompilerBasePage<CVCCLCompilerGeneralPage, IVCCLCompilerGeneralPage>
{
// IVCCLCompilerGeneralPage
public:
	STDMETHOD(get_AdditionalIncludeDirectories)(BSTR* pbstrIncludePath);	// (/I![path]) directory to add to include path, may have multiple
	STDMETHOD(put_AdditionalIncludeDirectories)(BSTR bstrIncludePath);
	STDMETHOD(get_AdditionalUsingDirectories)(BSTR* pbstrIncludePath);	// (/AI![path]) directory to add to LIBPATH path, may have multiple
	STDMETHOD(put_AdditionalUsingDirectories)(BSTR bstrIncludePath);
	STDMETHOD(get_DebugInformationFormat)(debugOption* poptSetting);	// see debugOption enum (/Z7, Zd, /ZI, /Zi)
	STDMETHOD(put_DebugInformationFormat)(debugOption optSetting);
	STDMETHOD(get_CompileAsManaged)(compileAsManagedOptions* poptSetting);	// (/clr[:noAssembly])
	STDMETHOD(put_CompileAsManaged)(compileAsManagedOptions optSetting);
	STDMETHOD(get_SuppressStartupBanner)(enumSuppressStartupBannerBOOL* pbNoLogo);	// (/nologo, /nologo-) enable/disable suppression of copyright message
	STDMETHOD(put_SuppressStartupBanner)(enumSuppressStartupBannerBOOL bNoLogo);
	STDMETHOD(get_WarningLevel)(warningLevelOption* poptSetting);	// see warningLevelOption enum (/W0 - /W4)
	STDMETHOD(put_WarningLevel)(warningLevelOption optSetting);
	STDMETHOD(get_Detect64BitPortabilityProblems)(enumDetect64BitPortabilityProblemsBOOL* pbDetect64BitPortabilityProblems);	// (/Wp64) detect 64 bit portability problems
	STDMETHOD(put_Detect64BitPortabilityProblems)(enumDetect64BitPortabilityProblemsBOOL bDetect64BitPortabilityProblems);
	STDMETHOD(get_WarnAsError)(enumWarnAsErrorBOOL* pbWarnAsError);	// (/WX, /WX-) treat warnings as errors
	STDMETHOD(put_WarnAsError)(enumWarnAsErrorBOOL bWarnAsError);

// helpers
public:
	virtual void GetBaseDefault(long id, CComVariant& varValue);
	virtual BOOL UseDirectoryPickerDialog(long id) 
		{ return (id == VCCLID_AdditionalIncludeDirectories || id == VCCLID_AdditionalUsingDirectories); }
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\vcpb\cmdlines.cpp ===
#include "stdafx.h"
#include "CmdLines.h"

/////////////////////////////////////////////////////////////////////////////
//

HRESULT CVCCommandLineList::CreateInstance(IVCCommandLineList** ppCmdLineList)
{
	CHECK_POINTER_NULL(ppCmdLineList);
	*ppCmdLineList = NULL;

	CComObject<CVCCommandLineList> *pObj;
	HRESULT hr = CComObject<CVCCommandLineList>::CreateInstance(&pObj);
	if (SUCCEEDED(hr))
	{
		CVCCommandLineList *pVar = pObj;
		pVar->AddRef();
		*ppCmdLineList = pVar;
	}
	return hr;
}

STDMETHODIMP CVCCommandLineList::Next(IVCCommandLine **ppCmdLine)
{
	CHECK_POINTER_NULL(ppCmdLine);
	RETURN_ON_NULL2(m_posEnumerator, S_FALSE);

	IVCCommandLine* pCmd = (IVCCommandLine*)m_commands.GetNext(m_posEnumerator);
	if (pCmd)
		pCmd->AddRef();
	*ppCmdLine = pCmd;
	return S_OK;
}

STDMETHODIMP CVCCommandLineList::get_Count(long *pVal)
{
	CHECK_POINTER_NULL(pVal);
	*pVal = (long) m_commands.GetCount();
	return S_OK;
}

STDMETHODIMP CVCCommandLineList::Reset()
{
	m_posEnumerator = m_commands.GetHeadPosition();
	return S_OK;
}

STDMETHODIMP CVCCommandLineList::Add(IVCCommandLine *pCmdLine, BOOL bAddFront)
{
	RETURN_ON_NULL2(pCmdLine, S_OK);	// nothing there, nothing to add

	pCmdLine->AddRef();
	if (bAddFront)
		m_commands.AddHead(pCmdLine);
	else
		m_commands.AddTail(pCmdLine);

	return S_OK;
}

STDMETHODIMP CVCCommandLineList::RemoveAll()
{
	m_posEnumerator = m_commands.GetHeadPosition();
	while (m_posEnumerator != NULL)
	{
		IVCCommandLine* pCmd = (IVCCommandLine*)m_commands.GetNext(m_posEnumerator);
		pCmd->Release();
	}
	m_commands.RemoveAll();
	return S_OK;
}

STDMETHODIMP CVCCommandLineList::AddList(IVCCommandLineList* pCmdLineList, BOOL bAddFront)
{
	RETURN_ON_NULL2(pCmdLineList, S_OK);

	pCmdLineList->Reset();
	HRESULT hr = S_OK;
	while (hr == S_OK)
	{
		CComPtr<IVCCommandLine> spCmd;
		hr = pCmdLineList->Next(&spCmd);
		if (FAILED(hr) || hr == S_FALSE)
			break;
		if (spCmd == NULL)
			continue;
		if (bAddFront)
			m_commands.AddHead(spCmd);
		else
			m_commands.AddTail(spCmd);
		spCmd.Detach();
	}

	return S_OK;
}

STDMETHODIMP CVCCommandLineList::get_UseConsoleCodePageForSpawner(VARIANT_BOOL* pbConsoleCP)
{
	CHECK_POINTER_NULL(pbConsoleCP);
	*pbConsoleCP = m_bUseConsoleCodePageForSpawner;
	return S_OK;
}

STDMETHODIMP CVCCommandLineList::put_UseConsoleCodePageForSpawner(VARIANT_BOOL bConsoleCP)
{
	m_bUseConsoleCodePageForSpawner = bConsoleCP;
	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//

HRESULT CVCCommandLine::CreateInstance(IVCCommandLine** ppCmdLine)
{
	CHECK_POINTER_NULL(ppCmdLine);
	*ppCmdLine = NULL;

	CComObject<CVCCommandLine> *pObj;
	HRESULT hr = CComObject<CVCCommandLine>::CreateInstance(&pObj);
	if (SUCCEEDED(hr))
	{
		CVCCommandLine *pVar = pObj;
		pVar->AddRef();
		*ppCmdLine = pVar;
	}
	return hr;
}

STDMETHODIMP CVCCommandLine::get_Description(BSTR *pVal)
{
	CHECK_POINTER_NULL(pVal);
	m_bstrDescription.CopyTo(pVal);
	return S_OK;
}

STDMETHODIMP CVCCommandLine::put_Description(BSTR newVal)
{
	m_bstrDescription = newVal;
	return S_OK;
}

STDMETHODIMP CVCCommandLine::get_CommandLineContents(BSTR *pVal)
{
	CHECK_POINTER_NULL(pVal);
	m_bstrCommandLineContents.CopyTo(pVal);
	return S_OK;
}

STDMETHODIMP CVCCommandLine::put_CommandLineContents(BSTR newVal)
{
	m_bstrCommandLineContents = newVal;
	return S_OK;
}

STDMETHODIMP CVCCommandLine::get_NumberOfProcessors(long* pnProcessors)
{
	CHECK_POINTER_NULL(pnProcessors);
	*pnProcessors = m_nProcessors;
	return S_OK;
}

STDMETHODIMP CVCCommandLine::put_NumberOfProcessors(long nProcessors)
{
	m_nProcessors = nProcessors;
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\vcpb\Collection.cpp ===
// Collection.cpp : Implementation of CYupApp and DLL registration.

#include "stdafx.h"
#include "Collection.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\vcpb\comlist.h ===
// CComDynamicListTyped
// Implements an ordered list of CComPtr's
#ifndef _COMLIST_H_
#define _COMLIST_H_

// change IUnknown's to CComPtr's, or do the addref/release....
const long _DEFAULT_DYNLIST_LENGTH = 2;

template <class StoredType>
class CComDynamicListTyped
{
public:
	CComDynamicListTyped()
	: m_bAnItemHasBeenRemoved(false), m_nSize(0), m_ppUnk(NULL)
	{
	}

	~CComDynamicListTyped()
	{
		Clear();
	}
	long Add(StoredType* pUnk);
	long AddHead(StoredType* pUnk);
	long AddTail(StoredType* pUnk);
	BOOL RemoveCookie(INT_PTR dwCookie, bool bRelease = true);
	BOOL RemoveAtIndex(long nItem);
	BOOL Remove(StoredType* pUnk);
	void RemoveAll();
	long Find(StoredType* pUnk);
	static long WINAPI GetCookie(StoredType** pp)
	{
		return (long)*pp;
	}
	static StoredType* WINAPI GetUnknown(long dwCookie)
	{
		return (StoredType*)dwCookie;
	}
	StoredType* GetAt(long nIndex)
	{
		if (nIndex < 0 || nIndex >= m_nSize || m_ppUnk == NULL)
			return NULL;

		return m_ppUnk[nIndex];
	}
	long GetSize() const
	{
		return m_nSize;
	}
	long GetUpperBound()
	{
		if (m_nSize == 0 || m_ppUnk == NULL)
			return 0;
		
		long cItems = m_nSize;
		for (long idx = m_nSize-1; idx >= 0 ;idx--)
		{
			StoredType* pItem = m_ppUnk[idx];
			if (!pItem)
				cItems--;
		}
		return cItems;
	}
	long GetCount()
	{
		if (m_nSize == 0 || m_ppUnk == NULL)
			return 0;

		long cItems = 0;
		for (long idx = 0; idx < m_nSize; idx++)
		{
			StoredType* pItem = m_ppUnk[idx];
			if (pItem)
				cItems++;
		}
		return cItems;
	}

	void Concatenate(CComDynamicListTyped *pList)
	{
		if (pList == NULL || pList->m_nSize == 0)
			return;

		for (long idx = 0; idx < pList->GetSize(); idx++)
		{
			StoredType* pItem = pList->GetAt(idx);
			if (pItem)
				Add(pItem);
		}
	}

	void Clear()
	{
		RemoveAll();
		if (m_nSize > 0)
			free(m_ppUnk);
		m_nSize = 0;
		m_bAnItemHasBeenRemoved = false;
	}

	StoredType** GetArray()
	{
		return m_ppUnk;
	}

	bool HasAnItemBeenRemoved(void)
	{
		return m_bAnItemHasBeenRemoved;
	}

protected:
	BOOL AddFront(StoredType* pUnk);
	BOOL AddBack(StoredType* pUnk);

protected:
	StoredType** m_ppUnk;
	long m_nSize;
	bool m_bAnItemHasBeenRemoved;
};

template <class StoredType>
inline void CComDynamicListTyped<StoredType>::RemoveAll()
{
	if (m_nSize == 0 || m_ppUnk == NULL)
		return;

	for (long idx = 0; idx < m_nSize; idx++)
	{
		StoredType* pItem = m_ppUnk[idx];
		if (pItem)
		{
			pItem->Release();
			m_ppUnk[idx] = NULL;
		}
	}

	m_nSize = 0;
	m_bAnItemHasBeenRemoved = false;
}

template <class StoredType>
inline long CComDynamicListTyped<StoredType>::Add(StoredType* pUnk)
{ // WARNING: HAS EARLY RETURNS
	VSASSERT(pUnk, "Trying to add a NULL pointer to pointer list.  Bad program, bad program.");
	if (pUnk == NULL)
		return -1;

	long lItem = Find(pUnk);
	if (lItem >= 0) // Don't add if it is already there!
		return lItem; // WARNING: EARLY RETURN (not from IRS)

	StoredType** pp;
	if (m_nSize == 0) // no connections
	{
		//create array
		pp = (StoredType**)malloc(sizeof(StoredType*)*_DEFAULT_DYNLIST_LENGTH);
		if (pp == NULL)
			return -1;
		memset(pp, 0, sizeof(StoredType*)*_DEFAULT_DYNLIST_LENGTH);
		m_ppUnk = pp;
		m_nSize = _DEFAULT_DYNLIST_LENGTH;
	}

	if (m_ppUnk == NULL)
		return -1;			// something must be very, very wrong to hit this...

	for (long idx = 0; idx < m_nSize; idx++)
	{
		StoredType* pItem = m_ppUnk[idx];
		if (pItem == NULL)
		{
			m_ppUnk[idx] = pUnk;
			pUnk->AddRef();
			return idx;  // WARNING: EARLY RETURN (not from IRS)
		}
	}

	long nAlloc = m_nSize*2;
	long nSizeT = m_nSize;
	pp = (StoredType**)realloc(m_ppUnk, sizeof(StoredType*)*nAlloc);
	if (pp == NULL)
		return -1;  // WARNING: EARLY RETURN (not from IRS)
	m_ppUnk = pp;
	memset(&m_ppUnk[m_nSize], 0, sizeof(StoredType*)*m_nSize);
	m_ppUnk[nSizeT] = pUnk;
	pUnk->AddRef();
	m_nSize = nAlloc;
	return (long)nSizeT; // WARNING: HAS EARLY RETURNS
}

template <class StoredType>
inline long CComDynamicListTyped<StoredType>::AddHead(StoredType* pUnk)
{ // WARNING: HAS EARLY RETURNS
	VSASSERT(pUnk, "Trying to add a NULL pointer to pointer list.  Bad program, bad program.");
	if (pUnk == NULL)
		return -1;

	long lItem = Find(pUnk);
	if (lItem >= 0) // Don't add if it is already there!
		return lItem; // WARNING: EARLY RETURN (not from IRS)

	StoredType** pp = NULL;
	if (m_nSize == 0) // no connections
	{
		//create array
		pp = (StoredType**)malloc(sizeof(StoredType*)*_DEFAULT_DYNLIST_LENGTH);
		if (pp == NULL)
			return -1;
		memset(pp, 0, sizeof(StoredType*)*_DEFAULT_DYNLIST_LENGTH);
		m_ppUnk = pp;
		m_nSize = _DEFAULT_DYNLIST_LENGTH;
	}
	if (m_ppUnk == NULL)	// something very, very wrong if this is true...
		return -1;

	// only allowed to add to front of list
	if (m_ppUnk[0] == NULL)
	{
		m_ppUnk[0] = pUnk;
		pUnk->AddRef();
		return (long)0;  // WARNING: EARLY RETURN (not from IRS)
	}

	if (AddFront(pUnk))
		return (long)0;  // WARNING: EARLY RETURN (not from IRS)

	// no empty spot, so need to realloc
	long nAlloc = m_nSize*2;
	long nSizeT = m_nSize;
	pp = (StoredType**)realloc(m_ppUnk, sizeof(StoredType*)*nAlloc);
	if (pp == NULL)
		return -1;  // WARNING: EARLY RETURN (not from IRS)
	m_ppUnk = pp;
	memset(&m_ppUnk[m_nSize], 0, sizeof(StoredType*)*m_nSize);
	m_nSize = nAlloc;

	AddFront(pUnk);	// should be room now
	return 0; // WARNING: HAS EARLY RETURNS
}


template <class StoredType>
inline BOOL CComDynamicListTyped<StoredType>::AddFront(StoredType* pUnk)
{	// is there a blank spot we can compress everything up by?
	if (m_ppUnk == NULL)
		return FALSE;		// something is very, very wrong...

	long idxHole;
	for (idxHole = 0; idxHole < m_nSize && m_ppUnk[idxHole] != NULL; idxHole++)
	{}	// just finding that hole

	if (idxHole < m_nSize && m_ppUnk[idxHole] == NULL)
	{
		for (long idx2 = idxHole-1; idx2 >= 0; idx2--)
		{
			// move everything up one
			m_ppUnk[idx2+1] = m_ppUnk[idx2];
			m_ppUnk[idx2] = NULL;
		}
		m_ppUnk[0] = pUnk;
		pUnk->AddRef();
		return TRUE;  // WARNING: EARLY RETURN (not from IRS)
	}

	return FALSE;
}

template <class StoredType>
inline long CComDynamicListTyped<StoredType>::AddTail(StoredType* pUnk)
{ // WARNING: HAS EARLY RETURNS
	VSASSERT(pUnk, "Trying to add a NULL pointer to pointer list.  Bad program, bad program.");

	long lItem;
	
	lItem = Find(pUnk);
	if (lItem >= 0) // Don't add if it is already there!
	{
		return lItem; // WARNING: EARLY RETURN (not from IRS)
	}

	StoredType** pp = NULL;
	if (m_nSize == 0) // no connections
	{
		//create array
		pp = (StoredType**)malloc(sizeof(StoredType*)*_DEFAULT_DYNLIST_LENGTH);
		if (pp == NULL)
			return -1;
		memset(pp, 0, sizeof(StoredType*)*_DEFAULT_DYNLIST_LENGTH);
		m_ppUnk = pp;
	
		m_nSize = _DEFAULT_DYNLIST_LENGTH;
	}

	if (m_ppUnk == NULL)
		return -1;		// something is very, very wrong...

	// only allowed to add to back of list
	long idx = (m_nSize == 0) ? 0 : m_nSize-1;
	if (m_ppUnk[idx] == NULL)
	{
		m_ppUnk[idx] = pUnk;
		pUnk->AddRef();
		return idx;  // WARNING: EARLY RETURN (not from IRS)
	}

	if (AddBack(pUnk))
		return Find(pUnk);  // WARNING: EARLY RETURN (not from IRS)

	// no empty spot, so need to realloc
	long nAlloc = m_nSize*2;
	long nSizeT = m_nSize;
	pp = (StoredType**)realloc(m_ppUnk, sizeof(StoredType*)*nAlloc);
	if (pp == NULL)
		return -1;  // WARNING: EARLY RETURN (not from IRS)
	m_ppUnk = pp;
	memset(&m_ppUnk[m_nSize], 0, sizeof(StoredType*)*m_nSize);
	m_ppUnk[nSizeT] = pUnk;
	pUnk->AddRef();
	m_nSize = nAlloc;
	return (long)nSizeT; // WARNING: HAS EARLY RETURNS
}


template <class StoredType>
inline BOOL CComDynamicListTyped<StoredType>::AddBack(StoredType* pUnk)
{	// is there a blank spot we can compress everything down by?
	if (m_ppUnk == NULL)
		return FALSE;	// something is very, very wrong...

	long idxHole;
	for (idxHole = m_nSize-1; idxHole >= 0 && m_ppUnk[idxHole] != NULL; idxHole--)
	{}		// just looking for that hole
	if (idxHole >= 0 && m_ppUnk[idxHole] == NULL)
	{
		for (long idx2 = idxHole+1; idx2 < m_nSize; idx2++)
		{
			// move everything down one
			m_ppUnk[idx2-1] = m_ppUnk[idx2];
			m_ppUnk[idx2] = NULL;
		}
		m_ppUnk[m_nSize-1] = pUnk;
		pUnk->AddRef();
		return TRUE;  // WARNING: EARLY RETURN (not from IRS)
	}

	return FALSE;
}

template <class StoredType>
inline BOOL CComDynamicListTyped<StoredType>::RemoveCookie(INT_PTR dwCookie, bool bRelease /* = true */)
{
	if (dwCookie == NULL || m_nSize == 0 || m_ppUnk == NULL)
		return FALSE;

	for (long idx = 0; idx < m_nSize; idx++)
	{
		StoredType* pItem = m_ppUnk[idx];
		if ((INT_PTR)pItem == dwCookie)
		{
			if (bRelease)
				pUnk->Release();
			m_ppUnk[idx] = NULL;
			return TRUE;
		}
	}
	return FALSE;
}

template <class StoredType>
inline BOOL CComDynamicListTyped<StoredType>::RemoveAtIndex(long nIndex)
{
	if (nIndex < 0 || nIndex >= m_nSize || m_nSize == 0 || m_ppUnk == NULL)
		return FALSE;

	StoredType *pUnk = m_ppUnk[nIndex];
	if (pUnk)
	{
		pUnk->Release();
		m_ppUnk[nIndex] = NULL;
		m_bAnItemHasBeenRemoved = true;
		return TRUE;
	}

	return FALSE;
}

template <class StoredType>
inline BOOL CComDynamicListTyped<StoredType>::Remove(StoredType* pUnk)
{
	if (pUnk == NULL || m_nSize == 0 || m_ppUnk == NULL)
		return FALSE;
	for (long idx = 0; idx < m_nSize; idx++)
	{
		StoredType* pItem = m_ppUnk[idx];
		if (pItem == pUnk)
		{
			pItem->Release();
			m_ppUnk[idx] = NULL;
			m_bAnItemHasBeenRemoved = true;
			return TRUE;
		}
	}
	return FALSE;
}

template <class StoredType>
inline long CComDynamicListTyped<StoredType>::Find(StoredType* pUnk)
{
	if (pUnk == NULL || m_nSize == 0 || m_ppUnk == NULL)
		return -1;

	for (long idx = 0; idx < m_nSize; idx++)
	{
		StoredType* pItem = m_ppUnk[idx];
		if (pItem == pUnk)
			return idx;
	}

	return -1;
}

class CComDynamicList : public CComDynamicListTyped<IUnknown>
{
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\vcpb\cmdlines.h ===
#pragma once

#include "vccolls.h"

// classes in this header
class CVCCommandLineList;
class CVCCommandLine;
class CBldCmdSet;

/////////////////////////////////////////////////////////////////////////////
// CVCCommandLineList

class CVCCommandLineList : 
	public IDispatchImpl<IVCCommandLineList, &IID_IVCCommandLineList, &LIBID_VCProjectEnginePrivateLibrary, PrivateProjBuildTypeLibNumber,0, CVsTypeInfoHolder>, 
	public CComObjectRoot
{
public:
	static HRESULT CreateInstance(IVCCommandLineList** ppCmdLineList);
	CVCCommandLineList() : m_posEnumerator(NULL), m_bUseConsoleCodePageForSpawner(VARIANT_FALSE) {}
	~CVCCommandLineList()
	{
		RemoveAll();
	}

BEGIN_COM_MAP(CVCCommandLineList)
	COM_INTERFACE_ENTRY(IVCCommandLineList)
 	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()
DECLARE_NOT_AGGREGATABLE(CVCCommandLineList) 

// IVCCommandLineList
public:
	STDMETHOD(Add)(IVCCommandLine* pCmdLine, BOOL bAddFront);
	STDMETHOD(Reset)();
	STDMETHOD(get_Count)(long *pVal);
	STDMETHOD(Next)(IVCCommandLine** ppCmdLine);
	STDMETHOD(AddList)(IVCCommandLineList* pCmdLineList, BOOL bAddFront);
	STDMETHOD(RemoveAll)();
	STDMETHOD(get_UseConsoleCodePageForSpawner)(VARIANT_BOOL* pbConsoleCP);
	STDMETHOD(put_UseConsoleCodePageForSpawner)(VARIANT_BOOL bConsoleCP);

// IVCCommandLineList
protected:
	CVCPtrList m_commands;
	VCPOSITION m_posEnumerator;
	VARIANT_BOOL m_bUseConsoleCodePageForSpawner;
};

/////////////////////////////////////////////////////////////////////////////
// CVCCommandLine

class CVCCommandLine : 
	public IDispatchImpl<IVCCommandLine, &IID_IVCCommandLine, &LIBID_VCProjectEnginePrivateLibrary, PrivateProjBuildTypeLibNumber,0, CVsTypeInfoHolder>, 
	public CComObjectRoot
{
public:
	static HRESULT CreateInstance(IVCCommandLine** ppCmdLine);
	CVCCommandLine() : m_nProcessors(1) {}
BEGIN_COM_MAP(CVCCommandLine)
	COM_INTERFACE_ENTRY(IVCCommandLine)
 	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()
DECLARE_NOT_AGGREGATABLE(CVCCommandLine) 

// IVCCommandLine
public:
	STDMETHOD(get_CommandLineContents)(BSTR *pVal);
	STDMETHOD(put_CommandLineContents)(BSTR newVal);
	STDMETHOD(get_Description)(BSTR *pVal);
	STDMETHOD(put_Description)(BSTR newVal);
	STDMETHOD(get_NumberOfProcessors)(long* pnProcessors);
	STDMETHOD(put_NumberOfProcessors)(long nProcessors);

// IVCCommandLine
protected:
	CComBSTR m_bstrCommandLineContents;
	CComBSTR m_bstrDescription;
	long m_nProcessors;
};

class CBldCmdSet
{
public:
	CBldCmdSet() : m_bMakeFirst(FALSE), m_compileAs(compileAsCPlusPlus) {}

	CStringW m_strCommandLine;
	CVCStringWList m_strFilesList;
	BOOL m_bMakeFirst;
	CompileAsOptions m_compileAs;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\vcpb\Configuration.cpp ===
// Configuration.cpp : Implementation of CYupApp and DLL registration.

#include "stdafx.h"
#include "Configuration.h"
#include "buildengine.h"
#include "msgboxes2.h"
#include "collection.h"
#include "debugsettings.h"
#include "ProjWriter.h"
#include "vctool.h"
#include <atltime.h>
#include "register.h"
#include "linktool.h"
#include "cltool.h"

extern "C" const __declspec(selectany) GUID IID_ICategorizeProperties = { 0x4d07fc10, 0xf931, 0x11ce, { 0xb0, 0x1, 0x0, 0xaa, 0x0, 0x68, 0x84, 0xe5} };

CTestableSection CConfiguration::g_sectionBuildEngine;

/////////////////////////////////////////////////////////////////////////////
//
HRESULT CConfiguration::CreateInstance(VCConfiguration **ppVCConfiguration, LPCOLESTR szConfigName, VCPlatform *pPlatform, VCProject *pProject)
{
	HRESULT hr;
	CConfiguration *pVar;
	CComObject<CConfiguration> *pObj;
	hr = CComObject<CConfiguration>::CreateInstance(&pObj);
	if (SUCCEEDED(hr))
	{
		pVar = pObj;
		pVar->AddRef();
		*ppVCConfiguration = pVar;
		hr = pVar->Initialize(szConfigName, pPlatform, pProject);
	}
	return hr;
}


HRESULT CConfiguration::Initialize(LPCOLESTR szConfigName, VCPlatform *pPlatform, VCProject *pProject)
{
	m_bstrName = szConfigName;
	m_pPlatform = pPlatform;
	m_pProject = pProject;
	// form the full name (config name|platform name)
	CComBSTR bstrPlatformName;
	m_pPlatform->get_Name( &bstrPlatformName );
	m_bstrFullName = m_bstrName;
	m_bstrFullName.Append(L"|");
	m_bstrFullName.Append( bstrPlatformName );

	HRESULT hr = CDebugSettings::CreateInstance(&m_pDebug, this);
	RETURN_ON_FAIL(hr);

	DoSetATLCRTStyle(VARIANT_FALSE, false /* no dirty */);
	DoSetUseOfMFC(useMfcStdWin, false /* no dirty */);

	ConfigurationTypes configType;
	SGetConfigurationType(&configType);
	return DoSetConfigurationType(configType, TRUE);	// this will also initialize the tools
}

CConfiguration::CConfiguration()
{
	m_bIsValidConfiguration = VARIANT_TRUE;	// DIANEME_TODO: determine when this isn't true
	m_bIsBuildable = VARIANT_TRUE;	// DIANEME_TODO: determine when this isn't true
	m_bInitExtensionList = FALSE;
}

CConfiguration::~CConfiguration()
{
	ClearToolExtensionList();
}

HRESULT CConfiguration::SetDirty(VARIANT_BOOL bDirty)
{
	CComQIPtr<IVCProjectImpl> pProjImpl = m_pProject;
	if (pProjImpl)
		return pProjImpl->put_IsDirty(bDirty);

	return CVCProjectEngine::DoSetErrorInfo(VCPROJ_E_ZOMBIE, IDS_ERR_CFG_ZOMBIE);
}

HRESULT CConfiguration::DoSetIntProperty(long idProp, BOOL bCheckSpecial, long nValue, long nOverride /* = -1 */)
{
	if (bCheckSpecial)
	{
		HRESULT hr = S_OK;
		if (idProp == VCCFGID_ConfigurationType)
		{
			ConfigurationTypes configType = typeUnknown;
			hr = GetLocalIntProperty(VCCFGID_ConfigurationType, (long *)&configType);
			if (hr == S_OK && configType == nValue)	// nothing to do
				return S_OK;
			return DoSetConfigurationType((ConfigurationTypes)nValue);
		}
	}

	return CStyleSheetBase::DoSetIntProperty(idProp, bCheckSpecial, nValue, nOverride);
}

HRESULT CConfiguration::DoSetBoolProperty(long idProp, BOOL bCheckSpecial, VARIANT_BOOL bValue, long nOverrideID /* = -1 */)
{
	if (bCheckSpecial)
	{
		if (idProp == VCCFGID_AnyToolDirty)
		{
			HRESULT hr = CStyleSheetBase::DoSetBoolProperty(VCCFGID_AnyToolDirty, FALSE, bValue, nOverrideID);
			RETURN_ON_FAIL(hr);
			if (m_spBuildEngine != NULL)
				return CStyleSheetBase::DoSetBoolProperty(VCCFGID_DirtyDuringBuild, FALSE, bValue, nOverrideID);
			else
				return hr;
		}
	}

	return CStyleSheetBase::DoSetBoolProperty(idProp, bCheckSpecial, bValue, nOverrideID);
}

STDMETHODIMP CConfiguration::GenerateToolWrapperList()
{
	HRESULT hr = DoGenerateToolWrapperList();
	if (hr == S_OK && PROJECT_IS_LOADED())
		AssignActions(VARIANT_FALSE);

	return hr;
}

STDMETHODIMP CConfiguration::get_ConfigurationName(BSTR * pVal)
{
	CHECK_POINTER_VALID(pVal);
	return m_bstrName.CopyTo(pVal);
}

STDMETHODIMP CConfiguration::put_ConfigurationName(BSTR bstrVal)
{
	CHECK_OK_TO_DIRTY(VCCFGID_ConfigurationName);
	m_bstrName = bstrVal;
	return S_OK;
}

STDMETHODIMP CConfiguration::get_Name(BSTR * pVal)
{
	CHECK_POINTER_VALID( pVal );
	return m_bstrFullName.CopyTo(pVal);
}

STDMETHODIMP CConfiguration::SaveObject(IStream *xml, IVCPropertyContainer *pPropCnt, long nIndent)
{
	HRESULT hr;

	// Name
	CComBSTR bstrName;
	get_Name( &bstrName );
	NodeAttribute( xml, L"Name", bstrName );

	// Output Dir
	CComVariant varOutputDirectory;
	if( GetLocalProp( VCCFGID_OutputDirectory, &varOutputDirectory ) == S_OK && varOutputDirectory.vt == VT_BSTR)
	{
		CComBSTR bstrOutputDirectory = varOutputDirectory.bstrVal;
		if (bstrOutputDirectory.Length() > 0 )
			NodeAttribute( xml, L"OutputDirectory", bstrOutputDirectory );
	}

	// Intermediate Dir
	CComVariant varIntermediateDirectory;
	if( GetLocalProp( VCCFGID_IntermediateDirectory, &varIntermediateDirectory ) == S_OK && varIntermediateDirectory.vt == VT_BSTR)
	{
		CComBSTR bstrIntermediateDirectory = varIntermediateDirectory.bstrVal;
		if (bstrIntermediateDirectory.Length() > 0 )
			NodeAttribute( xml, L"IntermediateDirectory", bstrIntermediateDirectory );
	}

	// Config type
	OLECHAR szEnumVal[10] = {0};
	CComVariant varConfigType;
	hr = GetLocalProp( VCCFGID_ConfigurationType, &varConfigType );
	VSASSERT(hr == S_OK && (varConfigType.vt == VT_I2 || varConfigType.vt == VT_I4), "ConfigurationType property should never be default!");
	if (varConfigType.vt != VT_I2 && varConfigType.vt != VT_I4)
	{
		varConfigType.lVal = 0;
		varConfigType.vt = VT_I4;
	}
	NodeAttribute( xml, L"ConfigurationType", CComBSTR( _itow( varConfigType.lVal, szEnumVal, 10 ) ) );

	// Applied styles
	CComVariant varStyleSheets;
	if( GetLocalProp( VCCFGID_AppliedStyleSheets, &varStyleSheets ) == S_OK && varStyleSheets.vt == VT_BSTR)
	{
		CComBSTR bstrStyleSheets = varStyleSheets.bstrVal;
		if (bstrStyleSheets.Length() > 0 )
			NodeAttribute( xml, L"AppliedStyleSheets", bstrStyleSheets );
	}

	// Use of MFC
	CComVariant varUseMfc;
	if (GetLocalProp(VCCFGID_UseOfMFC, &varUseMfc) == S_OK && (varUseMfc.vt == VT_I2 || varUseMfc.vt == VT_I4))
		NodeAttribute( xml, L"UseOfMFC", CComBSTR( _itow( varUseMfc.lVal, szEnumVal, 10 ) ) );

	// Use of ATL
	CComVariant varUseATL;
	if (GetLocalProp(VCCFGID_UseOfATL, &varUseATL) == S_OK && (varUseATL.vt == VT_I2 || varUseATL.vt == VT_I4))
		NodeAttribute( xml, L"UseOfATL", CComBSTR( _itow( varUseATL.lVal, szEnumVal, 10 ) ) );

	// How ATL uses CRT
	CComVariant varCRT;
	if (GetLocalProp(VCCFGID_ATLMinimizesCRunTimeLibraryUsage, &varCRT) == S_OK && (varCRT.vt == VT_BOOL || varCRT.vt == VT_I2))
		NodeAttribute( xml, L"ATLMinimizesCRunTimeLibraryUsage", varCRT.boolVal == VARIANT_TRUE ? L"TRUE" : L"FALSE" );

	// character set
	CComVariant varSet;
	if (GetLocalProp(VCCFGID_CharacterSet, &varSet) == S_OK && (varSet.vt == VT_I2 || varSet.vt == VT_I4))
		NodeAttribute( xml, L"CharacterSet", CComBSTR( _itow( varSet.lVal, szEnumVal, 10 ) ) );

	// Managed Extensions
	CComVariant varManaged;
	if (GetLocalProp(VCCFGID_ManagedExtensions, &varManaged) == S_OK && (varManaged.vt == VT_BOOL || varManaged.vt == VT_I2))
		NodeAttribute( xml, L"ManagedExtensions", varManaged.boolVal == VARIANT_TRUE ? L"TRUE" : L"FALSE" );
		
	// Wildcard extension list of things to delete in the intermediate directory on rebuild/clean
	CComVariant varDelExt;
	if (GetLocalProp(VCCFGID_DeleteExtensionsOnClean, &varDelExt) == S_OK && varDelExt.vt == VT_BSTR)
		NodeAttribute(xml, L"DeleteExtensionsOnClean", varDelExt.bstrVal);

	// perform whole program optimization on build; more or less requires optimization turned on to be effective
	CComVariant varOptimize;
	if (GetLocalProp(VCCFGID_WholeProgramOptimization, &varOptimize) == S_OK && (varOptimize.vt == VT_BOOL || varOptimize.vt == VT_I2))
		NodeAttribute(xml, L"WholeProgramOptimization", varOptimize.boolVal == VARIANT_TRUE ? L"TRUE" : L"FALSE");

	// end node header, start on children
	EndNodeHeader( xml, true );

	// tools
	long lcItems;
	long index;
	lcItems = m_rgTools.GetSize();
	for( index = 0; index < lcItems; index++ )
	{
		CComPtr<IVCToolImpl> pToolImpl;
 		CComBSTR bstrToolName;
		
		pToolImpl = m_rgTools.GetAt( index );
		if( pToolImpl )
		{
			hr = pToolImpl->get_ToolShortName( &bstrToolName );
			VSASSERT(SUCCEEDED(hr), "Tool missing its short name");
			hr = pToolImpl->SaveObject( xml, static_cast<IVCPropertyContainer *>(this), GetIndent() );
		}
	}

	return S_OK;
}

STDMETHODIMP CConfiguration::ReadFromStream(IStream *pStream)
{
	CHECK_READ_POINTER_NULL(pStream);

	while (true)
	{
		//Read in the settings header
		CComBSTR bstrName;
		HRESULT hr = bstrName.ReadFromStream(pStream);
		RETURN_ON_FAIL(hr);

		if (bstrName == L"EndConfigProperties")
			break;

		//Check to see if this is the debug settings
		if (bstrName == L"DebugSettings")
			hr = HandleReadingDebugSettings(pStream);

		else if (bstrName == L"GeneralConfigSettings")
			hr = HandleReadingGeneralConfigSettings(pStream);

		//TODO: Read in additional objects here

		else	// maybe a tool
			hr = HandleReadingToolSettings(pStream, bstrName);

		RETURN_ON_FAIL(hr);
	}
	
	return S_OK;
}

HRESULT CConfiguration::HandleReadingDebugSettings(IStream* pStream)
{
	//Get the debug settings impl
	CComQIPtr<IVCDebugSettingsImpl> pDbgSettings = m_pDebug;
	CHECK_ZOMBIE(pDbgSettings, IDS_ERR_CFG_ZOMBIE);

	//Load settings
	HRESULT hr = pDbgSettings->ReadFromStream(pStream);
	RETURN_ON_FAIL(hr);

	return S_OK;
}

HRESULT CConfiguration::HandleReadingToolSettings(IStream* pStream, CComBSTR& bstrName)
{
	HRESULT hr = S_OK;
	long cItems = m_rgTools.GetSize();
	long lItem;
	for (lItem = 0; lItem < cItems; lItem++)
	{
		CComPtr<IVCToolImpl> spToolImpl = m_rgTools.GetAt(lItem);
		if (spToolImpl == NULL)
			continue;

		VARIANT_BOOL bMatch = VARIANT_FALSE;
		spToolImpl->MatchName(bstrName, VARIANT_FALSE /* any match*/, &bMatch);
		if (bMatch)
		{
			hr = spToolImpl->ReadFromStream(pStream, static_cast<IVCPropertyContainer *>(this));
			break;
		}
	}

	if (lItem == cItems)	// no match!
	{
		CStringW strName = bstrName;
		long nLen = strName.GetLength();
		if (nLen >= 4)
		{
			strName = strName.Right(4);
			strName.MakeLower();
			if (strName == L"tool")		// it's a tool.  we just don't know it, so skip over it
			{
				while (true)
				{
					//Read in type
					VARTYPE	type;
					ULONG iByteCount;
					HRESULT hr = pStream->Read(&type, sizeof(VARTYPE), &iByteCount);
					RETURN_ON_FAIL(hr);

					//End of list marker
					if (type == VT_EMPTY) 
						break;
				}
				return S_OK;
			}
		}
		return E_UNEXPECTED;
	}

	return S_OK;
}

HRESULT CConfiguration::HandleReadingGeneralConfigSettings(IStream* pStream)
{
	while (true)
	{
		//Read in type
		VARTYPE	type;
		ULONG iByteCount;
		HRESULT hr = pStream->Read(&type, sizeof(VARTYPE), &iByteCount);
		RETURN_ON_FAIL(hr);

		//End of list marker
		if (type == VT_EMPTY) 
			break;

		//Read in dispid
		DISPID dispid;
		hr = pStream->Read(&dispid, sizeof(DISPID), &iByteCount);
		RETURN_ON_FAIL(hr);

		if (type == VT_BOOL && dispid == VCCFGID_BuildBrowserInformation)
		{
			VARIANT_BOOL bBsc;
			hr = pStream->Read(&bBsc, sizeof(VARIANT_BOOL), &iByteCount);
			RETURN_ON_FAIL(hr);
			put_BuildBrowserInformation(bBsc);
		}
		else
			return E_UNEXPECTED;	// only expecting the single property
	}

	return S_OK;
}

STDMETHODIMP CConfiguration::WriteToStream(IStream *pStream)
{
	CHECK_READ_POINTER_NULL(pStream);

	//Get and write name as header
	CComBSTR bstrName;
	HRESULT hr = get_Name(&bstrName);
	RETURN_ON_FAIL(hr);
	hr = bstrName.WriteToStream(pStream);
	RETURN_ON_FAIL(hr);

	bstrName.Empty();

	//Write out the debug settings header
	bstrName = L"DebugSettings";
	hr = bstrName.WriteToStream(pStream);
	RETURN_ON_FAIL(hr);

	//Get debug settings impl interface
	CComQIPtr<IVCDebugSettingsImpl> pDbgSettings = m_pDebug;
	RETURN_ON_FAIL_OR_NULL2(hr, pDbgSettings, E_NOINTERFACE);

	//Save to stream
	hr = pDbgSettings->WriteToStream(pStream);
	RETURN_ON_FAIL(hr);

	// Write out the user-specific general config settings
	bstrName = L"GeneralConfigSettings";
	hr = bstrName.WriteToStream(pStream);
	RETURN_ON_FAIL(hr);

	// Build browser info
	CComVariant varBrowser;
	hr = GetLocalProp(VCCFGID_BuildBrowserInformation, &varBrowser);
	if (hr == S_OK && (varBrowser.vt == VT_I2 || varBrowser.vt == VT_BOOL))
	{
		VARIANT_BOOL bBrowser = varBrowser.boolVal;
		hr = WritePropertyToStream(pStream, bBrowser, VCCFGID_BuildBrowserInformation);
		RETURN_ON_FAIL(hr);
	}

	//Write "end of property list" marker
	VARTYPE type = VT_EMPTY;
	ULONG	iByteCount;
	hr = pStream->Write(&type, sizeof(VARTYPE), &iByteCount);
	RETURN_ON_FAIL(hr);

	// tools
	long lcItems = m_rgTools.GetSize();
	for (long index = 0; index < lcItems; index++)
	{
		CComPtr<IVCToolImpl> pToolImpl = m_rgTools.GetAt(index);
		if (!pToolImpl)
			continue;

		hr = pToolImpl->WriteToStream(pStream, static_cast<IVCPropertyContainer *>(this));
		RETURN_ON_FAIL(hr);
	}

	//TODO: Write out additional objects here

	bstrName = L"EndConfigProperties";
	hr = bstrName.WriteToStream(pStream);
	RETURN_ON_FAIL(hr);

	return S_OK;
}

STDMETHODIMP CConfiguration::SetDefaultToolForFile(IDispatch *pDispFileConfiguration)
{
	CComPtr<IDispatch> pDisp;

	CComQIPtr<IVCFileConfigurationImpl> pFileCfgImpl = pDispFileConfiguration;
	if (pFileCfgImpl == NULL)
	{
		VSASSERT(pFileCfgImpl, "Hmmm. The file config is bad somehow...");
		return E_UNEXPECTED;
	}

	CComQIPtr<VCFileConfiguration> pFileCfg = pDispFileConfiguration;
	VSASSERT(pFileCfg, "Could not possibly be one of *our* file configurations!");
	if(pFileCfg)
		pFileCfg->get_File(&pDisp);
	CComQIPtr<VCFile> pFile = pDisp;
	pDisp = NULL;

	VSASSERT(pFile, "Hmmm.  The file is bad, how'd that happen?");
	RETURN_ON_NULL2(pFile, E_UNEXPECTED);

	CComBSTR bstrExt;
	pFile->get_Extension( &bstrExt );
	if( bstrExt.Length() > 0 )
	{
		bstrExt.ToLower();
		InitToolExtensionList();
		IVCToolImpl* pTool = NULL;		// yes, I want a non-smart pointer here...
		// the extension list stores only the letter extension, NOT the "."
		if( bstrExt.Length() != 0 && m_ExtensionMap.Lookup( &bstrExt[1], (void*&)pTool ) && pTool )
			return pFileCfgImpl->SetDefaultTool( pTool, TRUE );
	}
	
	IVCToolImpl* pTool = NULL;		// yes, I want a non-smart pointer here...
	// Hmmm.  No specific tool, so use custom
	if (m_ExtensionMap.Lookup(L"bat", (void *&)pTool) && pTool != NULL)	// this will get us the custom build tool
		return pFileCfgImpl->SetDefaultTool(pTool, TRUE);

	return CVCProjectEngine::DoSetErrorInfo(VCPROJ_E_NO_TOOL, IDS_ERR_NO_DEF_TOOL);
}

void CConfiguration::ClearToolExtensionList()
{
	m_ExtensionMap.RemoveAll();
	m_bInitExtensionList = FALSE;
}

void CConfiguration::InitToolExtensionList(BOOL bReInit /* = FALSE */)
{
	if (bReInit && m_bInitExtensionList)
		ClearToolExtensionList();
	else if (m_bInitExtensionList)
		return;

	m_bInitExtensionList = TRUE;

	HRESULT hr = S_OK;
	long lcItems = m_rgTools.GetSize();
	for (long index = 0; index < lcItems; index++)
	{
		CComPtr<IVCToolImpl> pToolImpl;
		pToolImpl = m_rgTools.GetAt(index);
		if (pToolImpl == NULL)
			continue;

		VARIANT_BOOL bIsTargetTool = VARIANT_FALSE;
		hr = pToolImpl->IsTargetTool(NULL, &bIsTargetTool);
		VSASSERT(SUCCEEDED(hr), "Should *always* be able to tell whether or not a tool is a target tool!");
		if (bIsTargetTool == VARIANT_TRUE)	// don't attach a target tool to a file!!
		{
			// hmmm.  Custom build tool masquerades by default as target tool, but shouldn't be excluded here
			CComQIPtr<VCCustomBuildTool> spCustomTool = pToolImpl;
			if (spCustomTool == NULL)
				continue;
		}

		InitToolExtensionListForOneTool(pToolImpl);
	}
}

void CConfiguration::InitToolExtensionListForOneTool(IVCToolImpl* pToolImpl)
{
	CComBSTR bstrExt;
	HRESULT hr = pToolImpl->get_DefaultExtensions(&bstrExt);
	if (FAILED(hr))
		return;

	CStringW strExtensions = bstrExt;
	CStringW strExt;
	int extStart = 0;
	int extEnd = 0;
	int nLen = strExtensions.GetLength();
	if (nLen == 0)
	{
		VSASSERT(FALSE, "All tools must have an extension list!");
		return;
	}
	strExtensions.MakeLower();

	// while we're not at the end of the extension list string
	while( extStart < nLen )
	{
		// get the next extension in the filter list
		extEnd = strExtensions.Find( L';', extStart );
		// if it wasn't found there is an error
		if( extEnd == -1 )
			extEnd = nLen;

		// set up an extension to tool map
		IVCToolImpl* pNoSmartToolImpl = pToolImpl;	// want the actual pointer, not the overload of a CComPtr
		strExt = strExtensions.Mid( extStart, extEnd - extStart );
		strExt.TrimLeft();
		strExt.TrimRight();
		if (wcsncmp(strExt, L"*.", 2) == 0)
			strExt = strExt.Right(strExt.GetLength()-2);
		m_ExtensionMap.SetAt( strExt, (void *)pNoSmartToolImpl );
		extStart = extEnd + 1;
	}
}

STDMETHODIMP CConfiguration::MatchName(BSTR bstrNameToMatch, VARIANT_BOOL bFullOnly, VARIANT_BOOL *pbMatched)
{
	CHECK_POINTER_VALID(pbMatched);
	CComBSTR bstrName;

	get_Name(&bstrName);
	*pbMatched = VARIANT_FALSE;
	CHECK_READ_POINTER_VALID(bstrNameToMatch);
	RETURN_ON_NULL2(bstrName, E_UNEXPECTED);

	if ( _wcsicmp(bstrName,bstrNameToMatch) == 0)
	{
		*pbMatched = VARIANT_TRUE;
	}
	else if (!bFullOnly)	// try matching without the platform
	{
		CStringW strName = bstrName;
		int nPos = strName.Find(L"|");
		if (nPos > 0)
			strName = strName.Left(nPos);
		if (_wcsicmp(strName,bstrNameToMatch) == 0)
			*pbMatched = VARIANT_TRUE;
	}
	return S_OK;
}

STDMETHODIMP CConfiguration::put_Name(BSTR pVal)
{
	CHECK_OK_TO_DIRTY(VCCFGID_Name);

	//Find '|'
	CComBSTR bstrVal = pVal;

	const wchar_t *pStr = wcsrchr(pVal,L'|');
	int index = -1;
	if( pStr )
	{
		index = (int)(pStr - pVal);
	}

	if (index >= 0)
	{
		//Copy only the portion we need
		BSTR bstrTemp;
		bstrTemp = SysAllocStringLen(pVal, index);
		m_bstrName = bstrTemp;
		SysFreeString(bstrTemp);
		CStringW strName = m_bstrName;
		strName.TrimRight();
		if (m_bstrName.Length() != strName.GetLength())
			m_bstrName = strName;
		// set the full name
		m_bstrFullName = pVal;
	}
	else	//No '|'
	{
		m_bstrName = pVal;
		// set the full name
		m_bstrFullName = m_bstrName;
		m_bstrFullName.Append(L"|");
		CComBSTR bstrPlatformName;
		m_pPlatform->get_Name( &bstrPlatformName );
		m_bstrFullName.Append( bstrPlatformName );
	}
	return S_OK;
}

STDMETHODIMP CConfiguration::get_Platform(IDispatch * * ppVal)
{
	return DoGetPlatform(ppVal);
}

STDMETHODIMP CConfiguration::get_PrimaryOutput(BSTR * pVal)
{
	CHECK_POINTER_VALID(pVal);
	*pVal = NULL;

	long lcItems = m_rgTools.GetSize();
	for (long index = 0; index < lcItems; index++)
	{
		CComPtr<IVCToolImpl> spToolImpl = m_rgTools.GetAt(index);
		if (spToolImpl == NULL)
			continue;

		VARIANT_BOOL bHasPrimaryOutput = VARIANT_FALSE;
		IVCPropertyContainer* pContainer = this;
		if (SUCCEEDED(spToolImpl->HasPrimaryOutputFromTool(pContainer, VARIANT_TRUE, &bHasPrimaryOutput)) && bHasPrimaryOutput == VARIANT_TRUE)
			return spToolImpl->GetPrimaryOutputFromTool(pContainer, VARIANT_TRUE, pVal);
	}
	return S_FALSE;
}

STDMETHODIMP CConfiguration::GetPrimaryOutputFileID(IVCToolImpl** ppTool, long* pnOutputID)
{
	if (ppTool)
		*ppTool = NULL;
	CHECK_POINTER_NULL(pnOutputID);
	*pnOutputID = -1;

	long lcItems = m_rgTools.GetSize();
	for (long index = 0; index < lcItems; index++)
	{
		CComPtr<IVCToolImpl> spToolImpl = m_rgTools.GetAt(index);
		if (spToolImpl == NULL)
			continue;

		VARIANT_BOOL bHasPrimaryOutput = VARIANT_FALSE;
		IVCPropertyContainer* pContainer = this;
		if (SUCCEEDED(spToolImpl->HasPrimaryOutputFromTool(pContainer, VARIANT_TRUE, &bHasPrimaryOutput)) && bHasPrimaryOutput == VARIANT_TRUE)
		{
			HRESULT hr = spToolImpl->GetPrimaryOutputIDFromTool(pContainer, VARIANT_TRUE, pnOutputID);
			if (ppTool && SUCCEEDED(hr))
				*ppTool = spToolImpl.Detach();
			return hr;
		}
	}
	return S_FALSE;
}

STDMETHODIMP CConfiguration::get_ImportLibrary(BSTR * pVal)
{
	CHECK_POINTER_VALID(pVal);
	*pVal = NULL;

	long lcItems = m_rgTools.GetSize();
	for (long index = 0; index < lcItems; index++)
	{
		CComPtr<IVCToolImpl> spToolImpl = m_rgTools.GetAt(index);
		if (spToolImpl == NULL)
			continue;

		IVCPropertyContainer* pContainer = this;
		if (spToolImpl->GetImportLibraryFromTool(pContainer, pVal) == S_OK)
			return S_OK;
	}
	return S_FALSE;
}

STDMETHODIMP CConfiguration::get_ProgramDatabase(BSTR* pbstrPDB)
{
	CHECK_POINTER_VALID(pbstrPDB);
	*pbstrPDB = NULL;

	long lcItems = m_rgTools.GetSize();
	for (long index = 0; index < lcItems; index++)
	{
		CComPtr<IVCToolImpl> spToolImpl = m_rgTools.GetAt(index);
		if (spToolImpl == NULL)
			continue;

		IVCPropertyContainer* pContainer = this;
		if (spToolImpl->GetProgramDatabaseFromTool(pContainer, VARIANT_TRUE, pbstrPDB) == S_OK)
			return S_OK;
	}
	return S_FALSE;
}

STDMETHODIMP CConfiguration::get_ErrorContext(IVCBuildErrorContext** ppEC)
{
	CHECK_POINTER_NULL(ppEC);
	m_spBuildErrorContext.CopyTo(ppEC);
	return (m_spBuildErrorContext ? S_OK : S_FALSE);
}

STDMETHODIMP CConfiguration::get_OutputDirectory(BSTR * pVal)
{
	CComBSTR bstrOutputDirectory;
	DoGetStrProperty(VCCFGID_OutputDirectory, FALSE, &bstrOutputDirectory);
	if (bstrOutputDirectory.Length() == 0)
	{
		bstrOutputDirectory = m_bstrName;
		put_OutputDirectory(bstrOutputDirectory);
	}
	return bstrOutputDirectory.CopyTo(pVal);
}

STDMETHODIMP CConfiguration::put_OutputDirectory(BSTR newVal)
{
	return SetStrProperty(VCCFGID_OutputDirectory, newVal);
}

STDMETHODIMP CConfiguration::get_IntermediateDirectory(BSTR * pVal)
{
	CComBSTR bstrIntermediateDirectory;
	DoGetStrProperty(VCCFGID_IntermediateDirectory, FALSE, &bstrIntermediateDirectory);
	if (bstrIntermediateDirectory.Length() == 0)
	{
		bstrIntermediateDirectory = m_bstrName;
		put_IntermediateDirectory(bstrIntermediateDirectory);
	}
	return bstrIntermediateDirectory.CopyTo(pVal);
}

STDMETHODIMP CConfiguration::put_IntermediateDirectory(BSTR newVal)
{
	return SetStrProperty(VCCFGID_IntermediateDirectory, newVal);
}

STDMETHODIMP CConfiguration::Delete()
{
	CHECK_OK_TO_DIRTY(0);

	return E_NOTIMPL;
}

STDMETHODIMP CConfiguration::Build()
{
	return DoBuild(TOB_Build);
}

STDMETHODIMP CConfiguration::Rebuild()
{
	return DoBuild(TOB_ReBuild);
}

STDMETHODIMP CConfiguration::Clean()
{
	return DoBuild(TOB_Clean);
}

HRESULT CConfiguration::DoBuild(bldActionTypes bldType)
{
	CComPtr<IVCGenericConfiguration> spGenCfg;
	HRESULT hr = S_OK;
	if (CVCProjectEngine::s_pBuildPackage != NULL)
	{
		hr = CVCProjectEngine::s_pBuildPackage->GetUIConfigurationForVCConfiguration(this, &spGenCfg);
		RETURN_ON_FAIL(hr);
	}

	if (m_spBuildEngine != NULL)
		return S_FALSE;

	if (spGenCfg != NULL)
		return spGenCfg->StartAutomationBuild(bldType);

	// hmmmm.  must mean we don't have any access to the shell. gotta do everything ourselves, then.
	CBldDummyGenCfg* pDummyGenCfg = NULL;
	hr = CBldDummyGenCfg::CreateInstance(&pDummyGenCfg, this);
	VSASSERT(SUCCEEDED(hr) && pDummyGenCfg != NULL, "No dummy gencfg.  Probably out of memory condition");
	RETURN_ON_FAIL(hr);
	CHECK_ZOMBIE(pDummyGenCfg, IDS_ERR_CFG_ZOMBIE);

	// yes, there's a loose ref count here.  it will take care of itself when the build finishes
	return pDummyGenCfg->DoStartBuild(bldType, 0, NULL);
}

STDMETHODIMP CConfiguration::get_Tools(IDispatch **ppVal)
{
	return DoGetTools(ppVal);
}

STDMETHODIMP CConfiguration::get_FileTools(IVCCollection **ppVal)
{
	return DoGetFileTools(ppVal);
}

STDMETHODIMP CConfiguration::get_DebugSettings(IDispatch * * pVal)
{
	CHECK_POINTER_VALID(pVal);
	
	if (m_pDebug)	
		m_pDebug.QueryInterface(pVal);
	else 
		*pVal = NULL;
	return S_OK;
}

STDMETHODIMP CConfiguration::get_UpToDate(VARIANT_BOOL* pbUpToDate)
{
	CHECK_POINTER_VALID(pbUpToDate);
	*pbUpToDate = VARIANT_TRUE;

	if (m_spBuildEngine || m_spBuildErrorContext)	// already something going
		return E_FAIL;

	CComQIPtr<IVCProjectEngineImpl> spProjEngineImpl = g_pProjectEngine;
	RETURN_ON_NULL2(spProjEngineImpl, E_UNEXPECTED);

	CComPtr<IDispatch> spDispBuildEngine;
	HRESULT hr = spProjEngineImpl->get_BuildEngine(&spDispBuildEngine);
	RETURN_ON_FAIL(hr);
	CComQIPtr<IVCBuildEngine> spBuildEngine = spDispBuildEngine;
	CComQIPtr<IVCBuildEngineImpl> spBuildEngineImpl = spDispBuildEngine;
	if (spBuildEngine == NULL || spBuildEngineImpl == NULL)
		return E_UNEXPECTED;

	CComPtr<IVCBuildErrorContext> spEC;
	hr = CBldCommandLineEC::CreateInstance(&spEC, NULL, spBuildEngine);
	RETURN_ON_FAIL_OR_NULL(hr, spEC);
	spEC->put_AssociatedBuildEngine(spDispBuildEngine);

	{	// scope the crit section
		CritSectionT cs(g_sectionBuildEngine);
		if (m_spBuildEngine || m_spBuildErrorContext)	// already something going
		{
			spEC->put_AssociatedBuildEngine(NULL);
			return E_FAIL;
		}
		m_spBuildEngine = spBuildEngine;
		m_spBuildErrorContext = spEC;
	}

	CBldCfgRecord* pCfgRecord = NULL;
	DoInitializeDepGraph(&pCfgRecord);
	CHECK_ZOMBIE(pCfgRecord, IDS_ERR_CFG_ZOMBIE);

	RefreshCommandLineOptionsAndOutputs(NULL);	// just in case a dirty command line changes something...
	hr = spBuildEngineImpl->HasBuildState((void *)pCfgRecord, spEC, pbUpToDate);
	ClearDirtyCommandLineOptionsFlag();
	
	{	// scope the crit section
		CritSectionT cs(g_sectionBuildEngine);
		m_spBuildEngine.Release();
		m_spBuildErrorContext.Release();
	}

	return S_OK;
}

STDMETHODIMP CConfiguration::get_Dependencies(IVCBuildStringCollection** ppDependencies)
{
	CHECK_POINTER_NULL(ppDependencies);
	*ppDependencies = NULL;

	RETURN_ON_NULL2(m_spActionList, S_FALSE);

	DoInitializeDepGraph(NULL);

	return m_spActionList->get_ProjectConfigurationDependencies(ppDependencies);
}

STDMETHODIMP CConfiguration::get_BuildOutputs(IVCBuildStringCollection** ppBuildOutputs)
{
	CHECK_POINTER_NULL(ppBuildOutputs);
	*ppBuildOutputs = NULL;

	RETURN_ON_NULL2(m_spActionList, S_FALSE);

	DoInitializeDepGraph(NULL);

	return m_spActionList->get_ProjectConfigurationBuildOutputs(ppBuildOutputs);
}

STDMETHODIMP CConfiguration::get_ProjectDependencies(IVCBuildOutputItems** ppProjDependencies)
{
	CHECK_POINTER_NULL(ppProjDependencies);
	*ppProjDependencies = NULL;

	RETURN_ON_NULL2(CVCProjectEngine::s_pBuildPackage, S_OK);

	return CVCProjectEngine::s_pBuildPackage->GetConfigurationDependencies(this, ppProjDependencies);
}

STDMETHODIMP CConfiguration::get_ProjectDependenciesAsStrings(IVCBuildStringCollection** ppProjDepStrings)
{
	CHECK_POINTER_NULL(ppProjDepStrings);
	*ppProjDepStrings = NULL;

	CComPtr<IVCBuildOutputItems> spProjDeps;
	HRESULT hr = get_ProjectDependencies(&spProjDeps);
	RETURN_ON_FAIL(hr);
	if (hr == S_FALSE || spProjDeps == NULL)
		return S_FALSE;

	hr = CVCBuildStringCollection::CreateInstance(ppProjDepStrings);
	RETURN_ON_FAIL_OR_NULL2(hr, *ppProjDepStrings, E_OUTOFMEMORY);

	spProjDeps->Reset();
	while (TRUE)
	{
		CComPtr<IVCBuildOutputItem> spItem;
		hr = spProjDeps->Next(&spItem);
		if (hr != S_OK)
			break;
		if (spItem == NULL)
			continue;

		CComBSTR bstrDep;
		hr = spItem->get_FullPathName(&bstrDep);
		if (FAILED(hr))
			continue;

		CStringW strDep = bstrDep;
		int nDot = strDep.ReverseFind(L'.');
		if (nDot < 0)	// don't care about it if it doesn't have an extension at all
			continue;

		CStringW strExt = strDep.Right(strDep.GetLength()-nDot);
		if (strExt.GetLength() == 4 && _wcsicmp(strExt, L".lib") != 0)
			continue;	// only care about .lib deps

		(*ppProjDepStrings)->Add(bstrDep);
	}

	return S_OK;
}

STDMETHODIMP CConfiguration::get_HasProjectDependencies(VARIANT_BOOL* pbHasDeps)
{
	CHECK_POINTER_NULL(pbHasDeps);
	*pbHasDeps = VARIANT_FALSE;

	RETURN_ON_NULL2(CVCProjectEngine::s_pBuildPackage, S_OK);	// nothing more we can do

	return CVCProjectEngine::s_pBuildPackage->HasConfigurationDependencies(this, pbHasDeps);
}

STDMETHODIMP CConfiguration::get_KnownDeploymentDependencies(IVCBuildStringCollection** ppDeployDepStrings)
{
	CHECK_POINTER_NULL(ppDeployDepStrings);
	*ppDeployDepStrings = NULL;

	CBldCfgRecord* pCfgRecord = NULL;
	DoInitializeDepGraph(&pCfgRecord);		// make sure this gets initialized properly so we have actions set up...

	CComPtr<IVCBuildEngine> spBuildEngine;
	HRESULT hr = CDynamicBuildEngine::CreateInstance(&spBuildEngine);
	CComQIPtr<IVCBuildEngineImpl> spBuildEngineImpl = spBuildEngine;
	RETURN_ON_FAIL_OR_NULL(hr, spBuildEngineImpl);

	spBuildEngineImpl->GetDeploymentDependencies((void *)pCfgRecord, ppDeployDepStrings);
	if (*ppDeployDepStrings)
		(*ppDeployDepStrings)->RemoveDuplicates(VARIANT_TRUE /* paths */, VARIANT_FALSE /* not case sensitive */);

	return S_OK;
}

STDMETHODIMP CConfiguration::get_DeployableOutputsCount(long* pnOutputs)
{	// number of deployable outputs
	CHECK_POINTER_NULL(pnOutputs);
	*pnOutputs = 0;

	long lcItems = m_rgTools.GetSize();
	IVCPropertyContainer* pPropContainer = this;
	for (long index = 0; index < lcItems; index++)
	{
		CComPtr<IVCToolImpl> pToolImpl;
		pToolImpl = m_rgTools.GetAt(index);
		if (pToolImpl == NULL)
			continue;

		long cToolOutputs;
		HRESULT hr = pToolImpl->GetDeployableOutputsCount(pPropContainer, &cToolOutputs);
		if (SUCCEEDED(hr) && cToolOutputs)
			*pnOutputs += cToolOutputs;
	}

	return S_OK;
}

STDMETHODIMP CConfiguration::get_DeployableOutputs(IVCBuildStringCollection** ppDeployableOutputs)
{	// the deployable outputs
	CHECK_POINTER_NULL(ppDeployableOutputs);
	*ppDeployableOutputs = NULL;

	IVCPropertyContainer* pPropContainer = this;
	long lcItems = m_rgTools.GetSize();
	for (long index = 0; index < lcItems; index++)
	{
		CComPtr<IVCToolImpl> pToolImpl;
		pToolImpl = m_rgTools.GetAt(index);
		if (pToolImpl == NULL)
			continue;

		CComPtr<IVCBuildStringCollection> spOutputs;
		HRESULT hr = pToolImpl->GetDeployableOutputs(pPropContainer, &spOutputs);
		if (SUCCEEDED(hr) && spOutputs)
		{
			if (*ppDeployableOutputs == NULL)
				*ppDeployableOutputs = spOutputs.Detach();
			else
			{
				spOutputs->Reset();
				while (TRUE)
				{
					CComBSTR bstrOutput;
					hr = spOutputs->Next(&bstrOutput);
					if (hr != S_OK)
						break;
					if (bstrOutput.Length() > 0)
						(*ppDeployableOutputs)->Add(bstrOutput);
				}
			}
		}
	}

	return S_OK;
}

STDMETHODIMP CConfiguration::SupportsBuildType(bldActionTypes buildType, VARIANT_BOOL* pbSupports, VARIANT_BOOL* pbAvailable)
{
	CHECK_POINTER_NULL(pbSupports);
	CHECK_POINTER_NULL(pbAvailable);
	*pbSupports = VARIANT_TRUE;
	*pbAvailable = VARIANT_FALSE;

	toolSetType listStyle;
	DoGetToolSetType(listStyle);

	if (buildType == TOB_Link)
	{
		if (listStyle == toolSetLinker || listStyle == toolSetLibrarian)
			*pbAvailable = VARIANT_TRUE;
		else
			*pbSupports = VARIANT_FALSE;
		if (*pbSupports == VARIANT_FALSE)
		{
			*pbAvailable = VARIANT_FALSE;
			return S_OK;
		}
		return S_OK;
	}

	if (buildType == TOB_Deploy)
	{
		*pbSupports = (listStyle == toolSetLinker);
		VARIANT_BOOL bExcluded = VARIANT_TRUE;
		if (GetBoolProperty(VCDPLYID_ExcludedFromBuild, &bExcluded) != S_OK)
			bExcluded = VARIANT_TRUE;
		*pbAvailable = (*pbSupports && !bExcluded) ? VARIANT_TRUE : VARIANT_FALSE;
		return S_OK;
	}

	if (buildType == TOB_XboxImage)
	{
		*pbSupports = (listStyle == toolSetLinker);
		*pbAvailable = *pbSupports ? VARIANT_TRUE : VARIANT_FALSE;
		return S_OK;
	}

	if (buildType == TOB_XboxDeploy)
	{
		*pbSupports = (listStyle == toolSetLinker);
		VARIANT_BOOL bExcluded = VARIANT_TRUE;
		if (GetBoolProperty(XBOXDPLYID_ExcludedFromBuild, &bExcluded) != S_OK)
			bExcluded = VARIANT_FALSE; // Default is not excluded
		*pbAvailable = (*pbSupports && !bExcluded) ? VARIANT_TRUE : VARIANT_FALSE;
		return S_OK;
	}

	if (IsBuildEvent(buildType))
	{
		switch (buildType)
		{
		case TOB_PreBuildEvent:
		case TOB_PostBuildEvent:
			*pbSupports = (listStyle != toolSetMakefile);
			break;
		default:
			VSASSERT(FALSE, "Hey, unsupported build event type!");
			// fall through
		case TOB_PreLinkEvent:
			*pbSupports = (listStyle == toolSetLinker || listStyle == toolSetLibrarian);
			break;
		}
		if (*pbSupports == VARIANT_FALSE)
		{
			*pbAvailable = VARIANT_FALSE;
			return S_OK;
		}
		long nIDCmd = PREBLDID_CommandLine;
		long nExcludeID = PREBLDID_ExcludedFromBuild;
		if (buildType == TOB_PreLinkEvent)
		{
			nIDCmd = PRELINKID_CommandLine;
			nExcludeID = PRELINKID_ExcludedFromBuild;
		}
		else if (buildType == TOB_PostBuildEvent)
		{
			nIDCmd = POSTBLDID_CommandLine;
			nExcludeID = POSTBLDID_ExcludedFromBuild;
		}
		VARIANT_BOOL bExcluded = VARIANT_FALSE;
		if (GetBoolProperty(nExcludeID, &bExcluded) != S_OK)
			bExcluded = VARIANT_FALSE;
		if (bExcluded == VARIANT_FALSE)
		{
			CComBSTR bstrCmd;
			*pbAvailable = (GetStrProperty(nIDCmd, &bstrCmd) == S_OK && bstrCmd.Length() > 0) ? VARIANT_TRUE : VARIANT_FALSE;
		}
		return S_OK;
	}

	if (buildType == TOB_Compile)
		*pbSupports = VARIANT_FALSE;
	else
		*pbAvailable = VARIANT_TRUE;
		
	return S_OK;
}

STDMETHODIMP CConfiguration::DirtyOutputs(long nProjID)
{	// dirty outputs based on the passed-in project ID
	DirtyActionOutputsAndCommandLineOptions(nProjID, nProjID, GetOverrideID(nProjID));
	return S_OK;
}

STDMETHODIMP CConfiguration::get_Project(IDispatch * * pVal)
{
	CHECK_POINTER_VALID(pVal);
	*pVal = NULL;
	CHECK_ZOMBIE(m_pProject, IDS_ERR_PROJ_ZOMBIE);
	return m_pProject.QueryInterface(pVal);
}

STDMETHODIMP CConfiguration::put_Project(IDispatch * pVal)
{
	m_pProject = pVal;
	return S_OK;
}

STDMETHODIMP CConfiguration::get_IsValidConfiguration(VARIANT_BOOL* pbIsValidConfiguration)
{
	CHECK_POINTER_NULL(pbIsValidConfiguration);
	*pbIsValidConfiguration = m_bIsValidConfiguration;
	return S_OK;
}


STDMETHODIMP CConfiguration::get_IsBuildable(VARIANT_BOOL* pbIsBuildable)
{
	CHECK_POINTER_NULL(pbIsBuildable);
	*pbIsBuildable = m_bIsBuildable;
	return S_OK;
}

STDMETHODIMP CConfiguration::get_CanStartBuild(VARIANT_BOOL* pbCanBuild)
{
	CHECK_POINTER_NULL(pbCanBuild);
	*pbCanBuild = (m_spBuildEngine == NULL);	// we've got a build in progress if we have a build engine...
	return S_OK;
}

STDMETHODIMP CConfiguration::get_MrePath(BSTR* pbstrMrePath)
{
	CHECK_POINTER_NULL(pbstrMrePath);
	*pbstrMrePath = NULL;

	// Get filename of minimal rebuild file(vc70.idb).
	CComBSTR bstrPdb;
	CVCCLCompilerTool::GetResolvedPdbName(this, &bstrPdb);
	CStringW strIdb = bstrPdb;
	if (strIdb.GetLength() > 3 && wcsnicmp(strIdb.Right(4), L".pdb", 4) == 0)
	{
		int nLen = strIdb.GetLength();
		strIdb.SetAt(nLen-3, L'i');	// replace the 'p' with an 'i' in '.pdb'
		bstrPdb = strIdb;
	}

	*pbstrMrePath = bstrPdb.Detach();
	return S_OK;
}

STDMETHODIMP CConfiguration::get_BaseToolList(void** ppPtrList)
{
	CHECK_POINTER_NULL(ppPtrList);
	*ppPtrList = (void *)(&m_toolWrapperList);
	return S_OK;
}

STDMETHODIMP CConfiguration::AssignActions(VARIANT_BOOL bOnLoad)
{
	CBldCfgRecord* pcr = g_StaticBuildEngine.GetCfgRecord(m_pProject, reinterpret_cast<IDispatch *>(this));
	CBldAction::AssignActions(pcr, NULL);
	return S_OK;
}

STDMETHODIMP CConfiguration::UnAssignActions(VARIANT_BOOL bOnClose)
{
	CComQIPtr<VCProject> pVCProject = m_pProject;
	CBldCfgRecord* pcr = g_StaticBuildEngine.GetCfgRecord(pVCProject, reinterpret_cast<IDispatch *>(this));
	CBldAction::UnAssignActions(pcr, NULL);
	if (bOnClose == VARIANT_TRUE)
		g_StaticBuildEngine.RemoveCfgRecord(m_pProject, reinterpret_cast<IDispatch *>(this));

	return S_OK;
}

HRESULT CConfiguration::DoClearToolWrapperList()
{
	if (PROJECT_IS_LOADED() && !m_toolWrapperList.IsEmpty())
		UnAssignActions(VARIANT_FALSE);

	return CStyleSheetBase::DoClearToolWrapperList();
}

STDMETHODIMP CConfiguration::ClearToolWrapperList()
{
	return DoClearToolWrapperList();
}

STDMETHODIMP CConfiguration::Close()
{
	if (!g_bInProjClose)
		DoClearToolWrapperList();	// need this done BEFORE we release the actions...

	m_pProject.Release();
	CComQIPtr<IVCDebugSettingsImpl> spDebugImpl = m_pDebug;
	if (spDebugImpl)
		spDebugImpl->Close();
	m_pDebug.Release();
	m_spActionList.Release();
	m_rgFileCfgs.RemoveAll();	// NOTE: this list here is not what needs closing...

	return FinishClose();
}

void CConfiguration::DoGetToolSetType(toolSetType& listStyle)
{
	ConfigurationTypes configType;
	HRESULT hr = GetIntProperty(VCCFGID_ConfigurationType, (long *)&configType);
	VSASSERT(hr == S_OK, "ConfigurationType should never be default!");
	listStyle = DetermineBaseType(configType);
}

STDMETHODIMP CConfiguration::get_ConfigurationType(ConfigurationTypes* pconfigType)
{
	CHECK_POINTER_VALID(pconfigType);
	return GetIntProperty(VCCFGID_ConfigurationType, (long *)pconfigType);
}

STDMETHODIMP CConfiguration::put_ConfigurationType(ConfigurationTypes configType)
{
	return SetIntProperty(VCCFGID_ConfigurationType, configType);
}

HRESULT CConfiguration::DoSetConfigurationType(ConfigurationTypes configType, BOOL bForceUpdate /* = FALSE */)
{
	// check validity
	switch (configType)
	{
	case typeUnknown:
	case typeApplication:
	case typeDynamicLibrary:
	case typeStaticLibrary:
	case typeGeneric:
		break;	// everything OK
	default:
		RETURN_INVALID();
	}

	toolSetType nOldBaseType = toolSetAll;
	if (!bForceUpdate)
	{
		ConfigurationTypes oldConfigType;
		HRESULT hr = DoGetIntProperty(VCCFGID_ConfigurationType, TRUE, (long *)&oldConfigType);
		nOldBaseType = DetermineBaseType(oldConfigType);
		VSASSERT(hr == S_OK, "ConfigurationType property should always be non-default!");
	}
	toolSetType nNewBaseType = DetermineBaseType(configType);

	HRESULT hr = DoSetIntProperty(VCCFGID_ConfigurationType, FALSE, configType);
	RETURN_ON_FAIL(hr);

	BOOL bResetTools = FALSE;
	if (bForceUpdate || nOldBaseType != nNewBaseType)
	{
		InitializeTools();
		ClearToolExtensionList();
		bResetTools = PROJECT_IS_LOADED();
	}

	CComBSTR bstrIntrinsicStyles;
	DoGetStrProperty(VCCFGID_IntrinsicAppliedStyleSheets, FALSE, &bstrIntrinsicStyles);
	if (configType == typeDynamicLibrary)
		hr = AddStyle(this, bstrIntrinsicStyles, WINDLL_STYLE);
	else
		hr = RemoveStyle(this, bstrIntrinsicStyles, WINDLL_STYLE);
	if (hr == S_OK)
		DoSetStrProperty(VCCFGID_IntrinsicAppliedStyleSheets, FALSE, bstrIntrinsicStyles);

	if (!bResetTools)
		return S_OK;

	// un-set the tool on files for makefile projects
	CComPtr<IEnumVARIANT> spEnum;
	if ((nNewBaseType == toolSetMakefile) && SUCCEEDED(GetFileListEnumerator(&spEnum)))
	{
		while (TRUE)
		{
			CComPtr<VCFileConfiguration> spFileCfg;
			hr = GetNextFileConfig(spEnum, &spFileCfg);
			if (hr != S_OK)
				break;
			CComQIPtr<IVCFileConfigurationImpl> spFileCfgImpl = spFileCfg;
			if (spFileCfgImpl == NULL)
				continue;

			spFileCfgImpl->SetDefaultTool( NULL, FALSE );	// don't want an unassign/assign action pair on put_Tool...
		}
	}

	if (bResetTools && PROJECT_IS_LOADED())
		AssignActions(VARIANT_FALSE);		// UnAssign was called (indirectly) by InitializeTools

	return S_OK;
}

HRESULT CConfiguration::VerifyFileTools()
{
	if (!(PROJECT_IS_LOADED()))
		return S_OK;

	CComPtr<IEnumVARIANT> spFiles;
	HRESULT hr = CBldAction::GetFileCollection(this, &spFiles);
	RETURN_SPECIFIC_ON_FAIL_OR_NULL(hr, spFiles, S_FALSE);

	while (TRUE)
	{
		CComVariant var;
		hr = spFiles->Next(1, &var, NULL);
		BREAK_ON_DONE(hr);
		CComPtr<VCFileConfiguration> spFileCfg;
		if (!CBldAction::GetFileCfgForProjCfg(var, this, &spFileCfg))
			continue;
		CComQIPtr<IVCFileConfigurationImpl> spFileCfgImpl = spFileCfg;
		if (!spFileCfgImpl)
			continue;
		spFileCfgImpl->VerifyToolValid();
	}

	return S_OK;
}

STDMETHODIMP CConfiguration::get_AppliedStyleSheets(BSTR* pbstrStyles)
{
	HRESULT hr = GetStrProperty(VCCFGID_AppliedStyleSheets, pbstrStyles);
	if (hr == S_FALSE)
		GetDefaultValue(VCCFGID_AppliedStyleSheets, pbstrStyles, this);
	return hr;
}

STDMETHODIMP CConfiguration::put_AppliedStyleSheets(BSTR bstrStyles)
{
	return DoSetAppliedStyleSheets(bstrStyles, TRUE);
}

STDMETHODIMP CConfiguration::get_BuildBrowserInformation(VARIANT_BOOL* pbBsc)
{	// build .bsc file
	CHECK_POINTER_VALID(pbBsc);
	return GetBoolProperty(VCCFGID_BuildBrowserInformation, pbBsc);
}

STDMETHODIMP CConfiguration::put_BuildBrowserInformation(VARIANT_BOOL bBsc)
{
	return SetBoolProperty(VCCFGID_BuildBrowserInformation, bBsc);
}

STDMETHODIMP CConfiguration::get_UseOfMFC(useOfMfc* useMfc)
{	// how are we using MFC?
	CHECK_POINTER_VALID(useMfc);
	return GetIntProperty(VCCFGID_UseOfMFC, (long *)useMfc);
}

STDMETHODIMP CConfiguration::put_UseOfMFC(useOfMfc useMfc)
{
	return SetIntProperty(VCCFGID_UseOfMFC, useMfc);
}

STDMETHODIMP CConfiguration::get_UseOfATL(useOfATL* useATL)
{	// how are we using ATL?
	CHECK_POINTER_VALID(useATL);
	return GetIntProperty(VCCFGID_UseOfATL, (long *)useATL);
}

STDMETHODIMP CConfiguration::put_UseOfATL(useOfATL useATL)
{
	return SetIntProperty(VCCFGID_UseOfATL, useATL);
}

STDMETHODIMP CConfiguration::get_ATLMinimizesCRunTimeLibraryUsage(VARIANT_BOOL* pbCRT)
{	// is this an ATL min dependency?
	CHECK_POINTER_VALID(pbCRT);
	return GetBoolProperty(VCCFGID_ATLMinimizesCRunTimeLibraryUsage, pbCRT);
}

STDMETHODIMP CConfiguration::put_ATLMinimizesCRunTimeLibraryUsage(VARIANT_BOOL bCRT)
{
	return SetBoolProperty(VCCFGID_ATLMinimizesCRunTimeLibraryUsage, bCRT);
}

STDMETHODIMP CConfiguration::get_CharacterSet(charSet* pset)
{	// what type of character set are we using?
	CHECK_POINTER_VALID(pset);
	return GetIntProperty(VCCFGID_CharacterSet, (long *)pset);
}

STDMETHODIMP CConfiguration::put_CharacterSet(charSet set)
{
	return SetIntProperty(VCCFGID_CharacterSet, set);
}

STDMETHODIMP CConfiguration::get_ManagedExtensions(VARIANT_BOOL* bManaged)
{	// is this a managed extensions project?
	CHECK_POINTER_VALID(bManaged);
	return GetBoolProperty(VCCFGID_ManagedExtensions, bManaged);
}

STDMETHODIMP CConfiguration::put_ManagedExtensions(VARIANT_BOOL bManaged)
{
	return SetBoolProperty(VCCFGID_ManagedExtensions, bManaged);
}

STDMETHODIMP CConfiguration::get_DeleteExtensionsOnClean(BSTR* pbstrExt)
{	// wildcard extension list to delete on clean/rebuild from within the intermediate directory
	HRESULT hr = GetStrProperty(VCCFGID_DeleteExtensionsOnClean, pbstrExt);
	if (hr == S_FALSE)
		GetDefaultValue(VCCFGID_DeleteExtensionsOnClean, pbstrExt, this);
	return hr;
}

STDMETHODIMP CConfiguration::put_DeleteExtensionsOnClean(BSTR bstrExt)
{
	return SetStrProperty(VCCFGID_DeleteExtensionsOnClean, bstrExt);
}

STDMETHODIMP CConfiguration::get_WholeProgramOptimization(VARIANT_BOOL* pbOptimized)
{  // perform whole program optimization on build; more or less requires optimization turned on to be effective
	return GetBoolProperty(VCCFGID_WholeProgramOptimization, pbOptimized);
}

STDMETHODIMP CConfiguration::put_WholeProgramOptimization(VARIANT_BOOL bOptimize)
{
	return SetBoolProperty(VCCFGID_WholeProgramOptimization, bOptimize);
}

STDMETHODIMP CConfiguration::get_RegisterOutput(VARIANT_BOOL* pbRegister)
{	// register the primary output of the build
	CHECK_POINTER_VALID(pbRegister);
	*pbRegister = VARIANT_FALSE;

	ConfigurationTypes configType = typeApplication;
	get_ConfigurationType(&configType);
	if (configType != typeDynamicLibrary)
		return S_FALSE;

	HRESULT hr = GetBoolProperty(VCLINKID_RegisterOutput, pbRegister);
	if (hr == S_FALSE)
		CVCLinkerTool::s_optHandler.GetDefaultValue( VCLINKID_RegisterOutput, pbRegister );
	return hr;
}

STDMETHODIMP CConfiguration::CopyTo(IDispatch *pDispDestCfg)
{
	CHECK_ZOMBIE(m_pProject, IDS_ERR_CFG_ZOMBIE);
	CHECK_READ_POINTER_VALID(pDispDestCfg);

	HRESULT hr;

	CComQIPtr<VCConfiguration> pDestCfg = pDispDestCfg;
	CHECK_READ_POINTER_NULL(pDestCfg);

	// clone
	CComQIPtr<IVCPropertyContainer> pPropCnt = (VCConfiguration*)this;
	RETURN_ON_NULL2(pPropCnt, E_NOINTERFACE);
	CComQIPtr<IVCConfigurationImpl> pDestCfgImpl = pDestCfg;
	RETURN_ON_NULL2(pDestCfgImpl, E_NOINTERFACE);
	pDestCfgImpl->Clone( pPropCnt );
	// clone file configs
	// get the file collection
	CComPtr<IDispatch> pDisp;
	m_pProject->get_Files( &pDisp );
	CComQIPtr<IVCCollection> pColl = pDisp;
	RETURN_ON_NULL(pColl);
	long num_files;
	CComVariant varIdx;
	// for each file
	hr = pColl->get_Count( &num_files );
	for( long i = 1; i <= num_files; i++ )
	{
		varIdx = i;
		CComPtr<IDispatch> pDispItem;
		hr = pColl->Item( varIdx, &pDispItem );
		if( FAILED( hr ) )
			continue;
		// get the file impl
		CComQIPtr<IVCFileImpl> pFileImpl = pDispItem;
		if( !pFileImpl )
			continue;
		// get the file config
		CComPtr<VCFileConfiguration> pFileCfg;
		hr = pFileImpl->GetFileConfigurationForProjectConfiguration( (VCConfiguration*)this, &pFileCfg );
		if( !pFileCfg )
			continue;
		// get the file config impl
		CComQIPtr<IVCFileConfigurationImpl> pFileCfgImpl = pFileCfg;
		if( !pFileCfgImpl )
			continue;
		// get the prop container for the file cfg
		CComQIPtr<IVCPropertyContainer> pFilePropCnt = pFileCfg;
		// get the cfg that we added to the file
		CComPtr<VCFileConfiguration> pNewFileCfg;
		hr = pFileImpl->GetFileConfigurationForProjectConfiguration( pDestCfg, &pNewFileCfg );
		CComQIPtr<IVCFileConfigurationImpl> pNewFileCfgImpl = pNewFileCfg;
		if( !pNewFileCfgImpl )
			continue;
		// clone it
		hr = pNewFileCfgImpl->Clone( pFilePropCnt );
	}
	return hr;
}

STDMETHODIMP CConfiguration::TopLevelBuild(bldActionTypes buildType, ULONG cFiles, VCFile* pFiles[], 
	IVCBuildEngine* pBuildEngine, IVCBuildErrorContext* pEC, BOOL bRecurse, BOOL fDoIdleAndPump, BOOL fCleanupEngine,
	BOOL bProvideBanner, long* warnings, long* errors, BOOL* bCancelled)
{
#ifdef PROF_BUILD_OVERHEAD
	StartCAPAll();
#endif

	if (pEC == NULL || pBuildEngine == NULL)
	{
		VSASSERT(FALSE, "No error context passed to TopLevelBuild!");
		RETURN_INVALID();
	}

	{	// scope the crit section
		CritSectionT cs(g_sectionBuildEngine);
		if (m_spBuildEngine || m_spBuildErrorContext)	// already something going
			return E_FAIL;
		m_spBuildEngine = pBuildEngine;
		m_spBuildErrorContext = pEC;
	}
	
	CHECK_POINTER_NULL(warnings);
	CHECK_POINTER_NULL(errors);
	CHECK_POINTER_NULL(bCancelled);

	BuildResults br = BuildComplete;
	BOOL bQuery = FALSE;
	BuildType bt;
	CStringW str;
	m_spBuildEngine = pBuildEngine;
	CComQIPtr<IVCBuildEngineImpl> spBuildEngineImpl = m_spBuildEngine;
	if (spBuildEngineImpl)
		spBuildEngineImpl->put_DoIdleAndPump(fDoIdleAndPump);

	DWORD startTime;

	// if we're doing performance logging
	// NOTE: matching build end is in buildengine.cpp, CDynamicBuildEngine::DoBuild()
	VARIANT_BOOL bLog = VARIANT_FALSE;
	g_pProjectEngine->get_PerformanceLogging( &bLog );
	if( bLog == VARIANT_TRUE )
	{
		// start time
		startTime = GetTickCount();
		fprintf( stdout, "Project Build start: %d\n", startTime );
	}

	FILETIME cTime;
	::GetSystemTimeAsFileTime(&cTime);
	CFileTime fileStartTime(cTime);
	
	long errs = 0, actualErrs = 0, warns = 0;

	CComBSTR bstrName;
	HRESULT hr = get_Name(&bstrName);
	VSASSERT(SUCCEEDED(hr), "Should always be able to obtain configuration's name!");
	CStringW strCfgName = bstrName;
	VSASSERT(!strCfgName.IsEmpty(), "Configurations *must* have names.  Zombie condition?");
	if (strCfgName.IsEmpty())
	{
#ifdef PROF_BUILD_OVERHEAD
		StopCAPAll();
#endif
		VSASSERT(FALSE, "Config name is empty in TopLevelBuild!");
		CleanUpEngine(fCleanupEngine);
		RETURN_INVALID();
	}
	int nBar = strCfgName.Find(L"|");
	if (nBar >= 0)
	{
		CStringW strNameLeft = strCfgName.Left(nBar);
		int nLen = strCfgName.GetLength();
		CStringW strNameRight = strCfgName.Right(nLen-nBar-1);
		strCfgName = strNameLeft;
		if (!strNameLeft.IsEmpty() && !strNameRight.IsEmpty())
			strCfgName += L" ";
		strCfgName += strNameRight;
	}

	VARIANT_BOOL bCanSpawn = VARIANT_TRUE;
	pBuildEngine->get_CanSpawnBuild(&bCanSpawn);
	if (bCanSpawn != VARIANT_TRUE)
	{
#ifdef PROF_BUILD_OVERHEAD
		StopCAPAll();
#endif
		VSASSERT(FALSE, "Cannot spawn spawner in TopLevelBuild!");
		CleanUpEngine(fCleanupEngine);
		return E_UNEXPECTED;
	}

	VSASSERT(m_pProject != NULL, "m_pProject only NULL if bad config initialization or config is zombie.");

	CStringW strProjectName;
	if (m_pProject)
	{
		CComBSTR bstrProjName;
		hr = m_pProject->get_Name(&bstrProjName);
		VSASSERT(SUCCEEDED(hr), "Should always be able to figure out project's name!");
		strProjectName = bstrProjName;
	}

	// No properties can change from here on out.  We can do this before a save 
	// because we know we won't be doing a save as, so the project filename and
	// and directory won't be changing

	// What type of build are we attempting to do, compile, build, or batch build?	
	if (cFiles > 0)
	{
		bt = Compile;
	}
	else if (buildType == TOB_Link)
		bt = Link;
	else if (IsBuildEvent(buildType))
		bt = BuildEvent;
	else
		bt = BatchBuild;

	// Initialize the spawner and output window:
#ifdef _DEBUG
	VARIANT_BOOL bSpawnerActive = VARIANT_FALSE;
	m_spBuildEngine->get_SpawnerActive(&bSpawnerActive);
	VSASSERT(bSpawnerActive == VARIANT_FALSE, "How did we get a build started when another one was in progress?");
#endif	// _DEBUG

	hr = spBuildEngineImpl->InitializeSpawner(FALSE);
	if (FAILED(hr))
	{
#ifdef PROF_BUILD_OVERHEAD
		StopCAPAll();
#endif
		VSASSERT(FALSE, "Failed to init spawner in TopLevelBuild");
		CleanUpEngine(fCleanupEngine);
		return E_UNEXPECTED;
	}
	else if (hr == S_FALSE)
	{
#ifdef PROF_BUILD_OVERHEAD
		StopCAPAll();
#endif
		*bCancelled = TRUE;
		CleanUpEngine(TRUE);	// we're not going to be back if the user cancelled...
		return S_FALSE;
	}

	if (bProvideBanner && pEC)
	{
		CStringW strTmp;
		strTmp.Format(IDS_BUILD_TARGETNAME, strProjectName, strCfgName);
		CComBSTR bstrTmp = strTmp;
		pEC->AddLine(bstrTmp);
	}

	CBldLogEnabler *pLog = NULL;
	if (buildType != TOB_Clean)
	{
		pLog = new CBldLogEnabler(this, m_spBuildEngine);
		if (CVCProjectEngine::s_bBuildLogging == VARIANT_TRUE)
		{
			VARIANT_BOOL bHaveLogging = VARIANT_FALSE;
			m_spBuildEngine->get_HaveLogging(&bHaveLogging);
			if (bHaveLogging == VARIANT_FALSE)
			{
				CComBSTR bstrWarn;
				bstrWarn.LoadString(IDS_WARN_NOBUILDLOG_PRJ0009);
				CVCProjectEngine::AddProjectWarning(pEC, bstrWarn, L"PRJ0009", this);
			}
		}
	}
	
	do   // this loops once and uses continue like a goto end
	{
		BOOL bIsClean = (buildType == TOB_Clean);
		DoPreparedBuild(cFiles, pFiles, buildType, bIsClean, pEC, bt, bRecurse, &br);

		pEC->get_Errors(&errs);
		pEC->get_Warnings(&warns);

		// Reconsile any differences between if we got errors, and the return code from the build.
		// REVIEW: the whole counting of errors scheme should be reworked so we don't have to do this.
		if( errs )
		{
			actualErrs = errs;
			if( br != BuildError )
			{
				// We had errors, make sure we return an error code.
				br = BuildError;
			}
		}
		else
		{
			// We had no errors but we have an error code, so report 1.
			if( br == BuildError )
				actualErrs = 1;
		}

		// BLOCK: Buzz the user...
		if (buildType != TOB_Clean)
		{
			UINT nBeepType = 0;
			UINT idsBeep = IDS_SOUND_BUILD_COMPLETE;

			// only beep on compile file, which the shell doesn't handle
			// beeping for
			if (buildType == TOB_Compile)
			{
				switch (br)
				{
				case BuildCanceled:
					break;

				case BuildError:
				case BuildComplete:
					if (actualErrs != 0)
					{
						idsBeep = IDS_SOUND_BUILD_ERROR;
						nBeepType = MB_ICONEXCLAMATION;
					}
					else if (warns != 0)
					{
						idsBeep = IDS_SOUND_BUILD_WARNING;
						nBeepType = MB_ICONQUESTION;
					}
					else
					{
						idsBeep = IDS_SOUND_BUILD_COMPLETE;
						nBeepType = MB_ICONASTERISK;
					}
					break;

				case NoBuild:
					idsBeep = IDS_SOUND_BUILD_UPTODATE;
					nBeepType = MB_ICONASTERISK;
					break;
				}
				if (nBeepType != 0)
					MessageBeep(nBeepType);
			}

			m_spBuildEngine->ClearPendingEnvironmentVariableWarnings();

			if (br == NoBuild) 
			{
				::VCMsgTextW(str, IDS_BUILD_UPTODATE, (const wchar_t *) strProjectName);
				CComBSTR bstr = str;
				pEC->AddLine(bstr);
			}
			else
			{
				pEC->AddLine(L"");
				// we already put out a message if the build was cancelled...
				if (br != BuildCanceled)
				{
					pEC->AddLine(L"");

					m_spBuildEngine->put_CurrentLogSection(eLogResults);

					CStringW strPreHeader;
					strPreHeader.LoadString(IDS_HTML_PRE_HEADER);
					CStringW strHeader;
					strHeader.LoadString(IDS_RESULTS);
					CStringW strPostHeader;
					strPostHeader.LoadString(IDS_HTML_POST_HEADER);

					CStringW strResults = strPreHeader + strHeader + strPostHeader;

					CComBSTR bstrResults = strResults;
					m_spBuildEngine->LogTrace(eLogResults, bstrResults);
				}
			}
		}
	} while(0);


	::GetSystemTimeAsFileTime(&cTime);
	CFileTime fileEndTime(cTime);

	VARIANT_BOOL bTime = VARIANT_FALSE;
	g_pProjectEngine->get_BuildTiming(&bTime);

	if ( (bTime == VARIANT_TRUE) && (buildType != TOB_Clean))
	{
		CFileTimeSpan fileElapsedTime = fileEndTime - fileStartTime;
		LONGLONG llElapsedTime = fileElapsedTime.GetTimeSpan();
		int nMinutes = (int)(llElapsedTime / 600000000);
		int nSeconds = (int)((llElapsedTime % 600000000) / 10000000);

 		CStringW strElapsedTime;
 		strElapsedTime.Format(IDS_BUILD_TIME, nMinutes, nSeconds);
		CComBSTR bstrElapsedTime = strElapsedTime;
		pEC->AddLine(bstrElapsedTime);

		// if we're doing performance logging also, log to stdout also
		VARIANT_BOOL bLog = VARIANT_FALSE;
		g_pProjectEngine->get_PerformanceLogging( &bLog );
		if( bLog == VARIANT_TRUE )
		{
			CStringA strBuildTime;	// yes, ANSI -- being used to write to stdout
			strBuildTime.LoadString(IDS_LOG_BUILD_TIME);
			fprintf( stdout, strBuildTime, nMinutes, nSeconds);
		}
	}

	if ((buildType != TOB_Clean) && (br != NoBuild))
	{
		// dump "build log saved at..." message to error context
		VARIANT_BOOL bLogging = VARIANT_FALSE;
		if (SUCCEEDED(g_pProjectEngine->get_BuildLogging(&bLogging)) && bLogging)
		{
			CComQIPtr<IVCBuildEngineImpl> pBldEngineImpl = m_spBuildEngine;
			if( pBldEngineImpl )
			{
				CComBSTR bstrLogFile;
				pBldEngineImpl->get_LogFile( &bstrLogFile );
				CStringW strFile = bstrLogFile;
				CStringW strMsg;
				strMsg.Format(IDS_BLDLOG_SAVED, strFile);
				CComBSTR bstrLogMsg = strMsg;
				pEC->AddLine( bstrLogMsg );
			}
		}

		::VCMsgTextW(str, IDS_BUILD_COMPLETE, (const wchar_t *) strProjectName, actualErrs, warns);
		CComBSTR bstr = str;
		pEC->AddLine(bstr);

		if (bProvideBanner)
		{
			CStringW strTmp;
			if (actualErrs)
				strTmp.LoadString(IDS_BUILD_FAILED);
			else
				strTmp.LoadString(IDS_BUILD_SUCCEEDED);
			CStringW strTmp2;
			strTmp2.LoadString(IDS_DONE);
			strTmp2 += strTmp;
			bstr = strTmp2;
			pEC->AddLine(bstr);
		}
	}

#ifdef PROF_BUILD_OVERHEAD
	StopCAPAll();
#endif

	// set out params
	*errors = actualErrs;
	*warnings = warns;

	spBuildEngineImpl->TerminateSpawner();
	*bCancelled = (br == BuildCanceled ? TRUE : FALSE);

	CleanUpEngine(fCleanupEngine || *bCancelled);
	delete pLog;

	if (br == BuildComplete || br == NoBuild) 
		return S_OK;
	
	return CVCProjectEngine::DoSetErrorInfo(VCPROJ_E_BUILD_FAILED, IDS_ERR_BUILD_FAILED);
}

void CConfiguration::CleanUpEngine(BOOL fCleanupEngine)
{
	if (!fCleanupEngine)
		return;

	CritSectionT cs(g_sectionBuildEngine);
	m_spBuildEngine.Release();
	m_spBuildErrorContext.Release();
}

HRESULT CConfiguration::DoPreparedBuild(ULONG cFiles, VCFile* pFiles[], bldActionTypes buildType, 
	BOOL bContinueAfterErrors, IVCBuildErrorContext* pEC, BuildType bt, BOOL bRecurse, BuildResults* pbrResults)
{
	CHECK_POINTER_NULL(pbrResults);
	*pbrResults = NoBuild;

	BOOL bDoOnce = (cFiles == 0);

	if (bRecurse && m_spBuildEngine)
		m_spBuildEngine->put_ReuseLogFile(VARIANT_TRUE);

	CComBSTR bstrProjCfgName;
	HRESULT hr = get_Name(&bstrProjCfgName);
	VSASSERT(SUCCEEDED(hr), "Should always be able to figure out configuration's name!");
	CStringW strProjCfgName = bstrProjCfgName;
	VSASSERT(!strProjCfgName.IsEmpty(), "valid configs *all* have names.  Config must be zombie.");

	CStringW strProjectName;
	if (m_pProject != NULL)
	{
		CComBSTR bstrProjName;
		hr = m_pProject->get_Name(&bstrProjName);
		VSASSERT(SUCCEEDED(hr), "Should always be able to figure out project's name!");
		strProjectName = bstrProjName;
	}

	BldFileRegHandle frhStart;
	bldAttributes aob;

	// Spawner should be active:
#ifdef _DEBUG
	VARIANT_BOOL bActive = VARIANT_FALSE;
	m_spBuildEngine->get_SpawnerActive(&bActive);
	VSASSERT(bActive == VARIANT_TRUE, "How did we get a build started when one was already in progress?");
#endif	// _DEBUG

	if (buildType != TOB_Clean)
	{
		CStringW str;
		m_spBuildEngine->LogTrace(eLogHeader, L"<h3>");
		::VCMsgTextW(str, IDS_BUILD_TARGETNAME, (const wchar_t *) strProjectName, (const wchar_t *) strProjCfgName);
		CComBSTR bstr = str;
		m_spBuildEngine->LogTrace(eLogHeader, bstr);
		m_spBuildEngine->LogTrace(eLogHeader, L"</h3>\n");
	}
	else
	{
		CStringW str;
		::VCMsgTextW(str, IDS_DESC_CLEANING, (const wchar_t *) strProjectName, (const wchar_t *) strProjCfgName);
		str += L"\n";
		CComBSTR bstr = str;
		pEC->AddLine(bstr);
	}

	aob = (bContinueAfterErrors) ? (bldAttributes)(AOB_Default | AOB_IgnoreErrors) : AOB_Default;

	if ((bt == Compile) || (bt == BuildEvent) || (bt == Link))
	{
		UINT aobTmp = (UINT)aob;
		aobTmp |= AOB_Forced;
		aob = (bldAttributes)aobTmp;
	}

	CComPtr<IDispatch> spDispProject;
	hr = get_Project(&spDispProject);
	VSASSERT(SUCCEEDED(hr), "If no project, we must be zombie and we shouldn't be doing a build if we're zombie...");

	CBldCfgRecord* pCfgRecord = NULL;
	CComQIPtr<IVCBuildEngineImpl> spBuildEngineImpl = m_spBuildEngine;
	if (spBuildEngineImpl == NULL)
	{
		VSASSERT(FALSE, "Bad build engine pointer in CConfiguration::DoPreparedBuild!");
		*pbrResults = BuildError;
		goto EndBuild;
	}

	DoInitializeDepGraph(&pCfgRecord);
	if (pCfgRecord == NULL)
	{
		// Assert was fired in DoInitializeDepGraph
		*pbrResults = BuildError;
		goto EndBuild;
	}

	if (cFiles != 0 && pFiles == NULL)
	{
		VSASSERT(FALSE, "Cannot specify build files without providing the files to build");
		*pbrResults = BuildError;
		goto EndBuild;
	}

	for (ULONG idx = 0; (idx < cFiles || bDoOnce) && (*pbrResults == BuildComplete || *pbrResults == NoBuild); idx++)
	{
		bDoOnce = FALSE;	// done it now
		CComPtr<VCFileConfiguration> spFileCfg;
		if (cFiles > 0 && pFiles != NULL)
		{
			CComQIPtr<IVCFileImpl> spFileImpl = pFiles[idx];
			if (spFileImpl != NULL)
				spFileImpl->GetFileConfigurationForProjectConfiguration(this, &spFileCfg);
			VSASSERT(spFileCfg != NULL, "File was not initialized properly with all the project configs");
			if (spFileCfg == NULL)
				continue;
		}

		CBldConfigurationHolder cfgHolder(pCfgRecord, spFileCfg, this);
		BOOL bFileRecurse = TRUE;
		frhStart = (BldFileRegHandle)NULL;
		CComPtr<IVCBuildAction> spAction;
		if (!cfgHolder.IsProject() || (bt == Link))
		{
			// FUTURE: short term fix .. build an output
			CComPtr<IVCBuildActionList> spActions;
			cfgHolder.GetActionList(&spActions);
			long cActions = 0;
			BOOL bOK = (spActions != NULL) && SUCCEEDED(spActions->get_Count(&cActions));
			VSASSERT(bOK, "Should always be able to pick up the actions list during a build!");
			if (cActions == 0)
			{
				*pbrResults = BuildError;
				goto EndBuild;
			}

			if (bt == Link)
			{
				toolSetType listStyle;
				DoGetToolSetType(listStyle);
				if (listStyle == toolSetLibrarian)
					spActions->FindByName(szLibrarianToolShortName, &spAction);
				else
					spActions->FindByName(szLinkerToolShortName, &spAction);
			}
			else
				spActions->get_LastAction(&spAction);

			if (spAction == NULL)
			{
				*pbrResults = NoBuild;
				goto EndBuild;
			}

			if (idx == 0)	// only need to do this once per build...
				RefreshCommandLineOptionsAndOutputs(pEC);

			CBldFileRegSet* pfrsOutput = NULL;
			hr = spAction->GetOutput(pEC, (void **)&pfrsOutput);
			VSASSERT(SUCCEEDED(hr), "Should always be able to get the outputs, even if they're empty");
			if (bt != BuildEvent && pfrsOutput->IsEmpty())
			{
				*pbrResults = NoBuild;
				goto EndBuild;
			}
			else if (!pfrsOutput->IsEmpty())
			{
				pfrsOutput->InitFrhEnum();
				frhStart = pfrsOutput->NextFrh();
				// Not sure where this should be released.  Here to be safe.
				if (NULL != frhStart)
					frhStart->ReleaseFRHRef();
			}

			bFileRecurse = FALSE;
		}
		else if (bt == BuildEvent)
		{
			CComBSTR bstrEventTool;
			switch (buildType)
			{
			case TOB_PreBuildEvent:
				bstrEventTool = szPreBuildEventToolShortName;
				break;
			case TOB_PreLinkEvent:
				bstrEventTool = szPreLinkEventToolShortName;
				break;
			case TOB_PostBuildEvent:
				bstrEventTool = szPostBuildEventToolShortName;
				break;
			case TOB_Deploy:
				bstrEventTool = szDeployToolShortName;
				break;
			case TOB_XboxImage:
				bstrEventTool = szXboxImageToolShortName;
				break;
			case TOB_XboxDeploy:
				bstrEventTool = szXboxDeployToolShortName;
				break;
			default:
				VSASSERT(FALSE, "Unknown event type in DoPreparedBuild!)");
				*pbrResults = BuildError;
				goto EndBuild;
			}

			CComPtr<IVCBuildActionList> spActions;
			cfgHolder.GetActionList(&spActions);
			long cActions = 0;
			BOOL bOK = (spActions != NULL) && SUCCEEDED(spActions->get_Count(&cActions));
			VSASSERT(bOK, "Should always be able to pick up the actions list during a build!");
			if (cActions == 0)
			{
				*pbrResults = BuildError;
				goto EndBuild;
			}

			spActions->FindByName(bstrEventTool, &spAction);
		}

		if (idx == 0 && frhStart == NULL)	// only need to do this once per build...
			RefreshCommandLineOptionsAndOutputs(pEC);

		spBuildEngineImpl->DoBuild((void *)pCfgRecord, cfgHolder.IsProject(), pEC, (void *)frhStart, aob, buildType, 
			bFileRecurse, spAction, pbrResults);

		if (idx == 0)	// only need to do this once per build...
			ClearDirtyCommandLineOptionsFlag();
	}

EndBuild:
	if (bRecurse && m_spBuildEngine)
		m_spBuildEngine->put_ReuseLogFile(VARIANT_FALSE);

	if (pEC && cFiles > 0)	// error context should know whether there were errors or not
		pEC->ActivateTaskList(VARIANT_FALSE);

	if (*pbrResults == BuildError)
		return CVCProjectEngine::DoSetErrorInfo(VCPROJ_E_BUILD_FAILED, IDS_ERR_BUILD_FAILED);
	
	return S_OK;
}

void CConfiguration::DoInitializeDepGraph(CBldCfgRecord** ppCfgRecord)
{
	CComPtr<IDispatch> spDispProject;
	HRESULT hr = get_Project(&spDispProject);
	VSASSERT(SUCCEEDED(hr), "Should always be able to get the project");

	CBldCfgRecord* pCfgRecord = g_StaticBuildEngine.GetCfgRecord(spDispProject, this);
	VSASSERT(pCfgRecord != NULL, "*All* configs have CfgRecords.  Probably have an out of memory situation.");
	if (pCfgRecord == NULL)
	{
		if (ppCfgRecord != NULL)
			*ppCfgRecord = NULL;
		return;	// can't do anything more
	}

	InitializeDepGraph(pCfgRecord);
	if (ppCfgRecord != NULL)
		*ppCfgRecord = pCfgRecord;
}

void CConfiguration::InitializeDepGraph(CBldCfgRecord* pCfgRecord)
{
	VSASSERT(pCfgRecord != NULL, "*All* configs have CfgRecords.  Probably have an out of memory situation.");
	if (pCfgRecord == NULL)
		return;

	CBldFileDepGraph *pDepGraph = g_StaticBuildEngine.GetDepGraph(pCfgRecord);
	if (pDepGraph == NULL)
		return;

	if (pDepGraph->IsInitialized())
		return;

	VCProject* pProject = pCfgRecord->GetVCProject();	// not ref-counted
	VSASSERT(pProject != NULL, "CfgRecord not initialized properly");
	if (pProject == NULL)
		return;

	VCConfiguration* pProjCfg = pCfgRecord->GetVCConfiguration();	// not ref-counted
	CComQIPtr<IVCBuildableItem> spBuildableItem = pProjCfg;
	VSASSERT(pProjCfg != NULL, "CfgRecord not initialized properly");
	VSASSERT(spBuildableItem != NULL, "How did we get a project cfg that was not a buildable item?");
	if (spBuildableItem == NULL)
		return;

	CComPtr<IVCBuildActionList> spCfgActions;
	HRESULT hr = spBuildableItem->get_ActionList(&spCfgActions);
	VSASSERT(SUCCEEDED(hr), "Should always be able to get the action list");
	if (spCfgActions == NULL)
	{
		VSASSERT(FALSE, "*All* buildable items have action lists.  Out of memory situation?");
		return;
	}
	InitActions(spCfgActions);

	// get the list of buildable files in the configuration
	CComPtr<IEnumVARIANT> spFiles;
	hr = CBldAction::GetFileCollection(pProjCfg, &spFiles);
	VOID_RETURN_ON_FAIL_OR_NULL(spFiles, hr);
	CVCPtrList lstFileCfgs;
	VCFileConfiguration* pFileCfg;
	while (TRUE)
	{
		CComVariant var;
		hr = spFiles->Next(1, &var, NULL);
		BREAK_ON_DONE(hr);
		if (!CBldAction::GetFileCfgForProjCfg(var, pProjCfg, &pFileCfg))
			continue;
		lstFileCfgs.AddTail(pFileCfg);
	}

	// Initialize everything...
	VCPOSITION pos = NULL;
	for (pos = lstFileCfgs.GetHeadPosition(); pos != NULL;)
	{
		VCFileConfiguration* pFileCfg = (VCFileConfiguration *)lstFileCfgs.GetNext(pos);
		CComPtr<IVCBuildActionList> spFileCfgActions;
		if (!CBldAction::GetFileCfgActions(pFileCfg, &spFileCfgActions))
			continue;

		InitActions(spFileCfgActions);
	}

	// Late bind everything...
	for (pos = lstFileCfgs.GetHeadPosition(); pos != NULL;)
	{
		VCFileConfiguration* pFileCfg = (VCFileConfiguration *)lstFileCfgs.GetNext(pos);
		CComPtr<IVCBuildActionList> spFileCfgActions;
		if (!CBldAction::GetFileCfgActions(pFileCfg, &spFileCfgActions))
			continue;

		LateBindActions(spFileCfgActions);
	}

	// Release everything...
	for (pos = lstFileCfgs.GetHeadPosition(); pos != NULL;)
	{
		VCFileConfiguration* pFileCfg = (VCFileConfiguration *)lstFileCfgs.GetNext(pos);
		pFileCfg->Release();
	}
	lstFileCfgs.RemoveAll();
	
	LateBindActions(spCfgActions);

	pDepGraph->SetGraphMode(Graph_Stable);
	pDepGraph->SetGraphInitialized();
}

void CConfiguration::InitActions(IVCBuildActionList* pBldActions)
{
	pBldActions->Reset(NULL);
	while (TRUE)
	{
		CComPtr<IVCBuildAction> spAction;
		HRESULT hr = pBldActions->Next(&spAction, NULL);
		BREAK_ON_DONE(hr);
		spAction->InitSets();
	}
}

void CConfiguration::LateBindActions(IVCBuildActionList* pBldActions)
{
	pBldActions->Reset(NULL);
	while (TRUE)
	{
		CComPtr<IVCBuildAction> spAction;
		HRESULT hr = pBldActions->Next(&spAction, NULL);
		BREAK_ON_DONE(hr);
		spAction->LateBind(m_spBuildErrorContext);
	}
}

STDMETHODIMP CConfiguration::get_ItemFileName(BSTR *pVal)
{
	if (m_pProject == NULL)
	{
		VSASSERT(FALSE, "Configuration either not initialized properly or is zombie.");
		return CVCProjectEngine::DoSetErrorInfo(VCPROJ_E_ZOMBIE, IDS_ERR_CFG_ZOMBIE);
	}

	return m_pProject->get_Name(pVal);
}

STDMETHODIMP CConfiguration::get_ItemFullPath(BSTR* pbstrFullPath)
{
	if (m_pProject == NULL)
	{
		VSASSERT(FALSE, "Configuration either not initialized properly or is zombie.");
		return CVCProjectEngine::DoSetErrorInfo(VCPROJ_E_ZOMBIE, IDS_ERR_CFG_ZOMBIE);
	}

	return m_pProject->get_ProjectFile(pbstrFullPath);
}

STDMETHODIMP CConfiguration::get_ActionList(IVCBuildActionList** ppActionList)
{
	CHECK_POINTER_NULL(ppActionList);

	if (m_spActionList == NULL)
	{
		HRESULT hr = CBldActionList::CreateInstance(&m_spActionList);
		RETURN_ON_FAIL(hr);
	}

	m_spActionList.CopyTo(ppActionList);
	return S_OK;
}

STDMETHODIMP CConfiguration::get_FileRegHandle(void** pfrh)
{
	CComQIPtr<IVCBuildableItem> spBuildableItem = m_pProject;
	if (spBuildableItem == NULL)
	{
		VSASSERT(FALSE, "Configuration either not initialized properly or is zombie.");
		return CVCProjectEngine::DoSetErrorInfo(VCPROJ_E_ZOMBIE, IDS_ERR_CFG_ZOMBIE);
	}

	return spBuildableItem->get_FileRegHandle(pfrh);
}

STDMETHODIMP CConfiguration::get_ContentList(IEnumVARIANT** ppContents)
{
	CComQIPtr<IVCBuildableItem> spBuildableProj = m_pProject;
	CHECK_ZOMBIE(spBuildableProj, IDS_ERR_CFG_ZOMBIE);

	CComPtr<IEnumVARIANT> spFileList;
	HRESULT hr = spBuildableProj->get_ContentList(&spFileList);
	RETURN_ON_FAIL_OR_NULL2(hr, spFileList, E_OUTOFMEMORY);

	m_rgFileCfgs.Clear();	// empty out anything we might have had before
	spFileList->Reset();
	while (TRUE)
	{
		CComVariant var;
		hr = spFileList->Next(1, &var, NULL);
		if (hr != S_OK)
			break;
		else if (var.vt != VT_DISPATCH && var.vt != VT_UNKNOWN)
			continue;
		IDispatch* pDispFile = var.pdispVal;
		CComQIPtr<IVCFileImpl> spFileImpl = pDispFile;
		if (spFileImpl == NULL)
			continue;
		CComPtr<VCFileConfiguration> spFileCfg;
		hr = spFileImpl->GetFileConfigurationForProjectConfiguration(reinterpret_cast<VCConfiguration *>(this), &spFileCfg);
		if (FAILED(hr) || spFileCfg == NULL)
			continue;

		m_rgFileCfgs.Add(spFileCfg);
	}

	CComPtr<IVCCollection> spCollection;
	hr = CCollection<VCFileConfiguration>::CreateInstance(&spCollection, &m_rgFileCfgs);
	RETURN_ON_FAIL_OR_NULL2(hr, spCollection, E_OUTOFMEMORY);

	return spCollection->_NewEnum(reinterpret_cast<IUnknown **>(ppContents));
}

STDMETHODIMP CConfiguration::get_Registry(void** ppFileRegistry)
{
	CComQIPtr<IVCBuildableItem> spBuildableProject = m_pProject;
	RETURN_ON_NULL2(spBuildableProject, E_NOINTERFACE);

	return spBuildableProject->get_Registry(ppFileRegistry);
}

STDMETHODIMP CConfiguration::get_ProjectConfiguration(VCConfiguration** ppProjCfg)
{
	CHECK_POINTER_NULL(ppProjCfg);

	*ppProjCfg = this;
	(*ppProjCfg)->AddRef();
	return S_OK;
}

STDMETHODIMP CConfiguration::get_ProjectInternal(VCProject** ppProject)
{
	CHECK_POINTER_NULL(ppProject);
	*ppProject = NULL;

	CComPtr<IDispatch> spDispProject;
	HRESULT hr = get_Project(&spDispProject);
	RETURN_ON_FAIL(hr);
	CComQIPtr<VCProject> spProject = spDispProject;
	return spProject.CopyTo(ppProject);
}

STDMETHODIMP CConfiguration::get_ExistingBuildEngine(IVCBuildEngine** ppEngine)
{
	CHECK_POINTER_NULL(ppEngine);
	return m_spBuildEngine.CopyTo(ppEngine);
}

STDMETHODIMP CConfiguration::get_PersistPath(BSTR* pbstrPersistPath)
{
	CHECK_POINTER_NULL(pbstrPersistPath);

	CComPtr<IDispatch> spDispProject;
	HRESULT hr = get_Project(&spDispProject);
	CComQIPtr<IVCBuildableItem> spBldableProj = spDispProject;
	RETURN_ON_FAIL(hr);
	CHECK_ZOMBIE(spBldableProj, IDS_ERR_CFG_ZOMBIE);

	return spBldableProj->get_PersistPath(pbstrPersistPath);
}

STDMETHODIMP CConfiguration::RefreshActionOutputs(long nPropID, IVCBuildErrorContext* pEC)
{
	HRESULT hr = S_OK;
	if (m_spActionList != NULL)
	{
		hr = m_spActionList->RefreshOutputs(nPropID, pEC);
		RETURN_ON_FAIL(hr);
		if (hr == S_FALSE)
			return S_OK;
	}

	CComPtr<IEnumVARIANT> spEnum;
	if (SUCCEEDED(GetFileListEnumerator(&spEnum)))
	{
		while (TRUE)
		{
			CComPtr<IVCBuildableItem> spBldableFileCfg;
			hr = GetNextFileConfig(spEnum, &spBldableFileCfg);
			if (hr != S_OK)
				break;
			else if (spBldableFileCfg == NULL)
				continue;

			spBldableFileCfg->RefreshActionOutputs(nPropID, pEC);
		}
	}

	return S_OK;
}

HRESULT CConfiguration::StartCommandLineOptionChange(IVCBuildErrorContext* pEC)
{
	HRESULT hr = S_OK;
	if (m_spActionList)
		hr = m_spActionList->HandlePossibleCommandLineOptionsChange(pEC);

	return hr;
}

STDMETHODIMP CConfiguration::HandlePossibleCommandLineOptionsChange(IVCBuildErrorContext* pEC)
{
	HRESULT hr = StartCommandLineOptionChange(pEC);
	RETURN_ON_FAIL(hr);

	CComPtr<IEnumVARIANT> spEnum;
	if (SUCCEEDED(GetFileListEnumerator(&spEnum)))
	{
		while (TRUE)
		{
			CComPtr<IVCBuildableItem> spBldableFileCfg;
			hr = GetNextFileConfig(spEnum, &spBldableFileCfg);
			if (hr != S_OK)
				break;
			else if (spBldableFileCfg == NULL)
				continue;

			spBldableFileCfg->HandlePossibleCommandLineOptionsChange(pEC);
		}
	}

	return S_OK;
}

HRESULT CConfiguration::DirtyActionOutputsAndCommandLineOptions(long nLowPropID, long nHighPropID, long nOverride)
{
	if (nOverride >= 0)		// overrides are there only for things that affect the outputs...
	{
		SetBoolProperty(nOverride, VARIANT_TRUE);
		SetBoolProperty(VCCFGID_AnyOutputDirty, VARIANT_TRUE);
	}

	VSASSERT(nLowPropID >= 0 && nHighPropID >= nLowPropID, "Invalid PropID range!");
	if (nLowPropID < 0 || nHighPropID < nLowPropID)
		return E_UNEXPECTED;

	HRESULT hrFinal = S_FALSE;
	long lcItems = m_rgTools.GetSize();
	for (long index = 0; index < lcItems; index++)
	{
		CComPtr<IVCToolImpl> pToolImpl;
		pToolImpl = m_rgTools.GetAt(index);
		if (pToolImpl)
		{
			HRESULT hr = pToolImpl->DirtyCommandLineOptions(nLowPropID, nHighPropID, VARIANT_TRUE);
			if (hr == S_OK)
			{
				SetBoolProperty(VCCFGID_AnyToolDirty, VARIANT_TRUE);
				if (nOverride < 0)	// we didn't already set the AnyOutputDirty flag above
				{
					VARIANT_BOOL bOutputDirty;
					if (GetBoolProperty(VCCFGID_AnyOutputDirty, &bOutputDirty) != S_OK)
					{
						if (pToolImpl->OutputsAreDirty(this, &bOutputDirty) == S_OK)
							SetBoolProperty(VCCFGID_AnyOutputDirty, VARIANT_TRUE);
					}
				}
				hrFinal = S_OK;
			}
		}
	}

	return hrFinal;
}

STDMETHODIMP CConfiguration::DirtyProp(long id)
{
	return FinishSetPropOrClear(id, GetOverrideID(id));
}

HRESULT CConfiguration::FinishSetPropOrClear(long id, long nOverride)
{
	if (PROJECT_IS_LOADED() && 
		(IsRealProp(id) || id == VCLINKID_DependentInputs || id == VCLIBID_DependentInputs || id == VCBSCID_RunBSCMakeTool))
	{
		bool bDirty = true;
		VARIANT_BOOL bFlag;
		if (id == VCLINKID_DependentInputs)
			bDirty = (DoGetBoolProperty(VCLINKID_LinkerCommandLineGenerated, FALSE, &bFlag) == S_OK);
		else if (id == VCLIBID_DependentInputs)
			bDirty = (DoGetBoolProperty(VCLIBID_LibCommandLineGenerated, FALSE, &bFlag) == S_OK);
		if (bDirty)
			DirtyActionOutputsAndCommandLineOptions(id, id, nOverride);
	}

	return S_OK;
}

HRESULT CConfiguration::DoGetStrProperty(long idProp, BOOL bSpecialPropsOnly, BSTR* pbstrValue)
{
	CHECK_POINTER_NULL(pbstrValue);
	*pbstrValue = NULL;

	HRESULT hr = S_FALSE;

	if (bSpecialPropsOnly)
	{
		if (idProp == VCCFGID_IntermediateDirectory)
			return get_IntermediateDirectory(pbstrValue);
		else if (idProp == VCCFGID_OutputDirectory)
			return get_OutputDirectory(pbstrValue);
	}

	switch (idProp)
	{
	case VCCFGID_ConfigurationName:
		return get_ConfigurationName(pbstrValue);
		break;
	case VCCFGID_PrimaryOutput:
		return get_PrimaryOutput(pbstrValue);
		break;
	case VCCFGID_ImportLibrary:
		return get_ImportLibrary(pbstrValue);
		break;
	case VCPROJID_ProjectDirectory:
		CHECK_ZOMBIE(m_pProject, IDS_ERR_CFG_ZOMBIE);
		return m_pProject->get_ProjectDirectory(pbstrValue);
		break;
	case VCPROJID_ProjectFile:
		CHECK_ZOMBIE(m_pProject, IDS_ERR_CFG_ZOMBIE);
		return m_pProject->get_ProjectFile(pbstrValue);
		break;
	case VCPROJID_Name:
		CHECK_ZOMBIE(m_pProject, IDS_ERR_CFG_ZOMBIE);
		return m_pProject->get_Name(pbstrValue);
		break;
	case VCPLATID_IncludeDirectories:
		CHECK_ZOMBIE(m_pPlatform, IDS_ERR_CFG_ZOMBIE);
		return m_pPlatform->get_IncludeDirectories(pbstrValue);
		break;
	case VCPLATID_ReferenceDirectories:
		CHECK_ZOMBIE(m_pPlatform, IDS_ERR_CFG_ZOMBIE);
		return m_pPlatform->get_ReferenceDirectories(pbstrValue);
		break;
	case VCPLATID_LibraryDirectories:
		CHECK_ZOMBIE(m_pPlatform, IDS_ERR_CFG_ZOMBIE);
		return m_pPlatform->get_LibraryDirectories(pbstrValue);
		break;
	case VCPLATID_Name:
		CHECK_ZOMBIE(m_pPlatform, IDS_ERR_CFG_ZOMBIE);
		return m_pPlatform->get_Name(pbstrValue);
		break;
	default:
		if (!bSpecialPropsOnly)
			return CStyleSheetBase::DoGetStrProperty(idProp, FALSE, pbstrValue);
	}

	return hr;
}

HRESULT CConfiguration::DoGetBoolProperty(long idProp, BOOL bCheckSpecial, VARIANT_BOOL* pbValue)
{
	if (idProp == VCCFGID_RegisterOutput)
	{
		ConfigurationTypes configType = typeApplication;
		get_ConfigurationType(&configType);
		if (configType == typeDynamicLibrary)
			return DoGetBoolProperty(VCLINKID_RegisterOutput, bCheckSpecial, pbValue);
		else
			return COptionHandlerBase::GetValueFalse(pbValue);
	}

	return CPropertyContainerImpl::DoGetBoolProperty(idProp, bCheckSpecial, pbValue);
}

STDMETHODIMP CConfiguration::ClearDirtyCommandLineOptionsFlag()
{
	VARIANT_BOOL bDirtyDuringBuild = VARIANT_FALSE;
	if (GetBoolProperty(VCCFGID_DirtyDuringBuild, &bDirtyDuringBuild) == S_OK)
	{	// if we dirtied during the build, let the build options be refreshed again next time
		Clear(VCCFGID_DirtyDuringBuild);

		// clear out the C/C++ compiler PDB file name now that we're finished with it
		CVCCLCompilerTool::ClearResolvedPdbName(this);

		return S_OK;
	}
	Clear(VCCFGID_AllOutputsDirty);
	Clear(VCCFGID_PrimaryOutputDirty);
	Clear(VCCFGID_AnyOutputDirty);
	Clear(VCCFGID_AnyToolDirty);

	HRESULT hrFinal = S_FALSE;
	long lcItems = m_rgTools.GetSize();
	for (long index = 0; index < lcItems; index++)
	{
		CComPtr<IVCToolImpl> pToolImpl;
		pToolImpl = m_rgTools.GetAt(index);
		if (pToolImpl)
		{
			HRESULT hr = pToolImpl->DirtyCommandLineOptions(-1, -1, VARIANT_FALSE);
			if (hr == S_OK)
				hrFinal = S_OK;
		}
	}

	// clear out the C/C++ compiler PDB file name now that we're finished with it
	CVCCLCompilerTool::ClearResolvedPdbName(this);

	return hrFinal;
}

HRESULT CConfiguration::RefreshCommandLineOptionsAndOutputs(IVCBuildErrorContext* pEC)
{
	// set up the C/C++ compiler PDB file name up front
	CVCCLCompilerTool::RefreshResolvedPdbName(this, TRUE);

	VARIANT_BOOL bRefreshOutputs = VARIANT_FALSE;
	long nOutputID = -1;
	BOOL bDoRefresh = TRUE;
	BOOL bDoFileRefresh = FALSE;
	if (GetBoolProperty(VCCFGID_AllOutputsDirty, &bRefreshOutputs) == S_OK)
		nOutputID = 0;
	else if (GetBoolProperty(VCCFGID_PrimaryOutputDirty, &bRefreshOutputs) == S_OK)
		nOutputID = VCCFGID_PrimaryOutputDirty;
	else if (GetBoolProperty(VCBSCID_OutputsDirty, &bRefreshOutputs) == S_OK)
		nOutputID = VCBSCID_OutputsDirty;
	else if (GetBoolProperty(VCCUSTID_OutputsDirty, &bRefreshOutputs) == S_OK)
		nOutputID = VCCUSTID_OutputsDirty;
	else
		bDoRefresh = FALSE;

	bDoFileRefresh = bDoRefresh;
	if (GetBoolProperty(VCCFGID_AnyOutputDirty, &bRefreshOutputs) == S_OK)
		bDoFileRefresh = TRUE;

	VARIANT_BOOL bToolDirty = VARIANT_FALSE;
	BOOL bDoToolStuff = (GetBoolProperty(VCCFGID_AnyToolDirty, &bToolDirty) == S_OK);

	if (!bDoRefresh && !bDoFileRefresh && !bDoToolStuff)
		return S_FALSE;

	HRESULT hr = S_FALSE;
	if (m_spActionList != NULL)
	{
		if (bDoRefresh && m_spActionList != NULL)
		{
			hr = m_spActionList->RefreshOutputs(nOutputID, m_spBuildErrorContext);
			RETURN_ON_FAIL(hr);
		}
		if (bDoToolStuff)
		{
			hr = StartCommandLineOptionChange(pEC);
			RETURN_ON_FAIL(hr);
		}
	}

	CComPtr<IEnumVARIANT> spEnum;
	if (FAILED(GetFileListEnumerator(&spEnum)))
		return S_FALSE;

	while (TRUE)
	{
		CComPtr<IVCBuildableItem> spBldableFileCfg;
		hr = GetNextFileConfig(spEnum, &spBldableFileCfg);
		if (hr != S_OK)
			break;
		else if (spBldableFileCfg == NULL)
			continue;

		if (bDoRefresh)
			spBldableFileCfg->RefreshActionOutputs(nOutputID, m_spBuildErrorContext);

		if (bDoFileRefresh && nOutputID != 0)	// only some files need something refreshed...
		{
			CComQIPtr<VCFileConfiguration> spFileCfg = spBldableFileCfg;
			CComQIPtr<IVCPropertyContainer> spPropContainer = spFileCfg;
			if (spFileCfg && spPropContainer)
			{
				CComPtr<IDispatch> spTool;
				spFileCfg->get_Tool(&spTool);
				CComQIPtr<IVCToolImpl> spToolImpl = spTool;
				if (spToolImpl)
				{
					VARIANT_BOOL bOutputDirty;
					if (spToolImpl->OutputsAreDirty(spPropContainer, &bOutputDirty) == S_OK)
						spBldableFileCfg->RefreshActionOutputs(0, m_spBuildErrorContext);
				}
			}
		}
		if (bDoToolStuff)
			spBldableFileCfg->HandlePossibleCommandLineOptionsChange(pEC);
	}

	return S_OK;
}

// WARNING: Clone must only be called on a brand new config!!
STDMETHODIMP CConfiguration::Clone( IVCPropertyContainer *pSource )
{
	// check arg
	CHECK_READ_POINTER_NULL(pSource);

	ConfigurationTypes newConfigType = typeApplication;
	pSource->GetIntProperty(VCCFGID_ConfigurationType, (long *)&newConfigType);
	DoSetConfigurationType(newConfigType);

	{	// pretend we're in project load for the moment
		// this keeps us from firing all kinds of prop changed until we're ready
		CInLoadProject loadProj;
		CConfiguration* pIn = (CConfiguration*)pSource;

		// get the start of the map
		VCPOSITION iter = pIn->m_PropMap.GetStartPosition();
		// iterate over each item in the map
		while( iter )
		{
			long key;
			CComVariant value;

			pIn->m_PropMap.GetNextAssoc( iter, key, value );

			switch (key)
			{
			case VCCFGID_IntrinsicAppliedStyleSheets:	// let these get set properly elsewhere
			case VCCFGID_ConfigurationType:				// already set
				break;
		
			default:
				// copy this element
				DoSetProp(key, TRUE, value);	// allow side effects to happen...
			}
		}
	}

	return S_OK;
}

HRESULT CConfiguration::GetFileListEnumerator(IEnumVARIANT** ppFileList)
{
	CHECK_POINTER_NULL(ppFileList);
	CHECK_ZOMBIE(m_pProject, IDS_ERR_CFG_ZOMBIE);

	CComPtr<IDispatch> spDispFiles;
	HRESULT hr = m_pProject->get_Files(&spDispFiles);
	RETURN_ON_FAIL(hr);

	CComQIPtr<IVCCollection> spFiles = spDispFiles;
	if (spFiles != NULL)
	{
		CComPtr<IEnumVARIANT> spEnum;
		if (SUCCEEDED(spFiles->_NewEnum(reinterpret_cast<IUnknown **>(ppFileList))) && *ppFileList != NULL)
		{
			(*ppFileList)->Reset();
			return S_OK;
		}
	}

	return CVCProjectEngine::DoSetErrorInfo(VCPROJ_E_ZOMBIE, IDS_ERR_CFG_ZOMBIE);
}

HRESULT CConfiguration::GetNextFileConfig(IEnumVARIANT* pEnum, VCFileConfiguration** ppFileCfg)
{
	VSASSERT(pEnum != NULL, "Bad input parameter!");
	CHECK_POINTER_NULL(ppFileCfg);
	CHECK_READ_POINTER_NULL(pEnum);
	*ppFileCfg = NULL;

	CComVariant var;
	HRESULT hr = pEnum->Next(1, &var, NULL);
	if (hr != S_OK)
		return hr;
	if (var.vt != VT_DISPATCH && var.vt != VT_UNKNOWN)
		return hr;
	IDispatch* pDispFile = var.pdispVal;
	CComQIPtr<IVCFileImpl> spFileImpl = pDispFile;
	RETURN_ON_NULL2(spFileImpl, hr);
	return spFileImpl->GetFileConfigurationForProjectConfiguration(this, ppFileCfg);
}

HRESULT CConfiguration::GetNextFileConfig(IEnumVARIANT* pEnum, IVCBuildableItem** ppBldableFileCfg)
{
	CHECK_POINTER_NULL(ppBldableFileCfg);
	*ppBldableFileCfg = NULL;

	CComPtr<VCFileConfiguration> spFileCfg;
	HRESULT hr = GetNextFileConfig(pEnum, &spFileCfg);
	CComQIPtr<IVCBuildableItem> spBldableFileCfg = spFileCfg;
	spBldableFileCfg.CopyTo(ppBldableFileCfg);
	return hr;
}

STDMETHODIMP CConfiguration::AddTool(LPCOLESTR szName, IDispatch** ppTool)
{
	// DIANEME_TODO: need to handle add of tool AFTER project is loaded...
	HRESULT hr = DoAddTool(szName, ppTool);
	CComQIPtr<IVCToolImpl> spVCTool = *ppTool;
	RETURN_ON_FAIL_OR_NULL(hr, spVCTool);
	InitToolExtensionListForOneTool(spVCTool);
	return hr;
}

/* static */ 
HRESULT CConfiguration::SGetConfigurationType(ConfigurationTypes* pconfigType)
{
	CHECK_POINTER_NULL(pconfigType);
	*pconfigType = typeApplication;	// call it application unless told otherwise...
	return S_FALSE;		// all defaults should return S_FALSE
}

HRESULT CBldDummyGenCfg::CreateInstance(CBldDummyGenCfg** ppGenCfg, VCConfiguration *pCfg)
{
	CComObject<CBldDummyGenCfg> *pGenCfgObj = NULL;  // created with 0 ref count
	HRESULT hr = CComObject<CBldDummyGenCfg>::CreateInstance(&pGenCfgObj);
	if (SUCCEEDED(hr))
	{
		pGenCfgObj->Initialize(pCfg);
		IVCGenericConfiguration* pVCCfg = pGenCfgObj;
		VSASSERT(pVCCfg != NULL, "Must be out of memory situation.");
		if (pVCCfg)
			pVCCfg->AddRef();
		*ppGenCfg = pGenCfgObj;
	}
	return hr;

}

void CBldDummyGenCfg::Initialize(VCConfiguration *pCfg)
{
	m_spConfig = pCfg;
}

STDMETHODIMP CBldDummyGenCfg::InformBuildEnd(BOOL fOK)
{
	m_spBuildThread->ExitThread();
	m_spBuildThread.Release();
	m_spBuildEngine.Release();
	Release();	// release us, too

	return S_OK;	// return code not checked
}

STDMETHODIMP CBldDummyGenCfg::InformBuildBegin()
{
	// DIANEME_TODO: CBldDummyGenCfg::InformBuildBegin -- do something
	return S_OK;	// return code not checked
}

STDMETHODIMP CBldDummyGenCfg::StartAutomationBuild(bldActionTypes bldType)
{
	VSASSERT(FALSE, "Automation builds are for the UI version of GenCfg, not command line version.");	// shouldn't be here!!
	return E_NOTIMPL;
}

STDMETHODIMP CBldDummyGenCfg::StartFileBuild(ULONG celtFiles, VCFile* pFiles[])
{
	VSASSERT(FALSE, "Automation builds are for the UI version of GenCfg, not command line version.");	// shouldn't be here!!
	return E_NOTIMPL;
}

STDMETHODIMP CBldDummyGenCfg::SupportsBuildType(bldActionTypes buildType, VARIANT_BOOL* pbSupports, VARIANT_BOOL* pbAvailable)
{
	CHECK_POINTER_NULL(pbSupports);
	CHECK_POINTER_NULL(pbAvailable);
	*pbSupports = VARIANT_FALSE;
	*pbAvailable = VARIANT_FALSE;

	CComQIPtr<IVCConfigurationImpl> spCfgImpl = m_spConfig;
	CHECK_ZOMBIE(spCfgImpl, IDS_ERR_CFG_ZOMBIE);

	return spCfgImpl->SupportsBuildType(buildType, pbSupports, pbAvailable);
}

STDMETHODIMP CBldDummyGenCfg::get_NoBuildIsInProgress(BOOL* pbNoneInProgress)
{
	HRESULT hr = (m_spBuildEngine == NULL) ? S_OK : E_FAIL;
	if (pbNoneInProgress && !IsBadWritePtr(pbNoneInProgress, sizeof(pbNoneInProgress)))
		*pbNoneInProgress = SUCCEEDED(hr);

	return hr;
}

HRESULT CBldDummyGenCfg::DoStartBuild(bldActionTypes bldType, VCFile* pFiles[] /* = NULL */, ULONG celtFiles /* = 0 */)
{
	CHECK_ZOMBIE(m_spConfig, IDS_ERR_CFG_ZOMBIE);

	VARIANT_BOOL bBuildable = VARIANT_FALSE;
	VARIANT_BOOL bValid = VARIANT_FALSE;
	CComQIPtr <IVCConfigurationImpl> pConfigImpl;
	pConfigImpl = m_spConfig;

	if (FAILED(pConfigImpl->get_IsBuildable(&bBuildable)) || (bBuildable == VARIANT_FALSE))
		 return CVCProjectEngine::DoSetErrorInfo(VCPROJ_E_NOT_BUILDABLE, IDS_ERR_PROJ_NOT_BUILDABLE);
	else if (FAILED(pConfigImpl->get_IsValidConfiguration(&bValid)) || (bValid == VARIANT_FALSE))
		 return CVCProjectEngine::DoSetErrorInfo(VCPROJ_E_NOT_BUILDABLE, IDS_ERR_PROJ_NOT_BUILDABLE);

	if (FAILED(CDynamicBuildEngine::CreateInstance(&m_spBuildEngine)) || m_spBuildEngine == NULL)
	{
		VSASSERT(FALSE, "No build engine == out of memory");
		return E_OUTOFMEMORY;
	}
	CComQIPtr<IVCBuildEngineImpl> spBuildEngineImpl = m_spBuildEngine;
	VSASSERT(spBuildEngineImpl != NULL, "How did we create a build engine without the IVCBuildEngineImpl interface?!?");
	RETURN_ON_NULL2(spBuildEngineImpl, E_UNEXPECTED);

	HRESULT hr = S_OK;
	if (m_spBuildThread == NULL)
	{
		hr = spBuildEngineImpl->get_BuildThread(&m_spBuildThread);
		RETURN_ON_FAIL_OR_NULL2(hr, m_spBuildThread, E_OUTOFMEMORY);
	}

	CComPtr<IVCBuildErrorContext> spErrorContext;
	hr = CBldCommandLineEC::CreateInstance(&spErrorContext, NULL, m_spBuildEngine);
	VSASSERT(SUCCEEDED(hr), "out of memory?");

	hr = m_spBuildThread->InitializeForBuild(this, m_spConfig, celtFiles, pFiles, bldType, (pFiles == NULL), 
		TRUE /* provide banner */, m_spBuildEngine, spErrorContext);

	if (SUCCEEDED(hr))
		hr = m_spBuildThread->StartThread();
	
	return hr;
}
        

//---------------------------------------------------------------------------
// interface: ISpecifyPropertyPages
//---------------------------------------------------------------------------
STDMETHODIMP CConfiguration::GetPages(/* [out] */ CAUUID *pPages)
{
	CHECK_POINTER_NULL(pPages);

#ifdef AARDVARK
	bool bCPP = false;
	bool bRC = false;
	bool bIDL = false;
	bool bCSharp = false;
	bool bVB = false;
	bool bSDL = false;
	// get the list of files in the config
	CComPtr<IDispatch> pDispColl;
	m_pProject->get_Files( &pDispColl );
	CComQIPtr<IVCCollection> pColl = pDispColl;
	long numFiles = 0;
	pColl->get_Count( &numFiles );
	for( long i = 1; i <= numFiles; i++ )
	{
		CComPtr<IDispatch> pDisp;
		pColl->Item( CComVariant( i ), &pDisp );
		CComQIPtr<VCFile> pFile = pDisp;
		CComBSTR bstrExt;
		pFile->get_Extension( &bstrExt );
		// cpp,cxx,c
		if( !bCPP )
			if( _wcsicmp( bstrExt, L".cpp" ) == 0 || _wcsicmp( bstrExt, L".cxx" ) == 0 || _wcsicmp( bstrExt, L".c" ) == 0 )
				bCPP = true;
		// rc
		if( !bRC )
			if( _wcsicmp( bstrExt, L".rc" ) == 0 )
				bRC = true;
		// idl
		if( !bIDL )
			if( _wcsicmp( bstrExt, L".idl" ) == 0 )
				bIDL = true;
		// cs
		if( !bCSharp )
			if( _wcsicmp( bstrExt, L".cs" ) == 0 )
				bCSharp = true;
		// vb
		if( !bVB )
			if( _wcsicmp( bstrExt, L".vb" ) == 0 )
				bVB = true;
		// sdl,wsdl
		if( !bSDL )
			if( _wcsicmp( bstrExt, L".sdl" ) == 0 || _wcsicmp( bstrExt, L".wsdl" ) == 0 )
				bSDL = true;
	}
	//
#endif // AARDVARK
	
	// Get the list of pages
	long lPageCnt = 0;
	CAUUID aPageSet[1024] = {0};
	unsigned long lTools = 0;

	BOOL bUtility = FALSE;

	ConfigurationTypes configType;
	HRESULT hr = get_ConfigurationType(&configType);
	if( (hr == S_OK) && configType == typeGeneric )
		bUtility = TRUE;

	long lcItems = m_rgTools.GetSize();
	for (long index = 0; index < lcItems; index++)
	{
		CComPtr<IVCToolImpl> spToolImpl = m_rgTools.GetAt(index);
		if (spToolImpl == NULL)
			continue;

		long tool_index;

		spToolImpl->get_ToolDisplayIndex( &tool_index );
		if( bUtility  && tool_index == TOOL_DISPLAY_INDEX_CUSTBLD )
			continue;

#ifdef AARDVARK
		if( tool_index == TOOL_DISPLAY_INDEX_CPP && !bCPP )
			continue;
		if( tool_index == TOOL_DISPLAY_INDEX_BSC && !bCPP )
			continue;
		if( tool_index == TOOL_DISPLAY_INDEX_LINK && !bCPP )
			continue;
		if( tool_index == TOOL_DISPLAY_INDEX_LIB && !bCPP )
			continue;
		if( tool_index == TOOL_DISPLAY_INDEX_RC && !bRC )
			continue;
		if( tool_index == TOOL_DISPLAY_INDEX_MIDL && !bIDL )
			continue;
		if( tool_index == TOOL_DISPLAY_INDEX_WEB && !bSDL )
			continue;
		if( tool_index == TOOL_DISPLAY_INDEX_CSHARP && !bCSharp )
			continue;
		if( tool_index == TOOL_DISPLAY_INDEX_VB && !bVB )
			continue;
#endif // AARDVARKk

		HRESULT hr = spToolImpl->GetPages(&(aPageSet[tool_index]));

		if( SUCCEEDED(hr) && aPageSet[tool_index].cElems )
		{
			lPageCnt += aPageSet[tool_index].cElems;
			lTools++;
			if( lTools > 1024 )
				break;
		}
	}

	// number of tool pages plus number of 'extra' pages
	pPages->cElems = lPageCnt + 2;
	if( lPageCnt == 0 )
	{
		pPages->pElems = (GUID*) NULL;
		return S_OK;
	}

	// number of tool pages plus number of 'extra' pages
	pPages->pElems = (GUID*) CoTaskMemAlloc(sizeof(CLSID)*(lPageCnt+2));
	RETURN_ON_NULL2(pPages->pElems, E_OUTOFMEMORY);
		
	// add the general->configuration page
	pPages->pElems[0] = __uuidof(GeneralConfigSettingsPage);

	// add the debugger
	pPages->pElems[1] = __uuidof(DebugSettingsPage);

	// Merge the page lists
	unsigned long lPages = 2;
	// for each possible tool
	for( unsigned long i = 0; i < 1024; i++ )
	{
		// for each page this tool has
		for( unsigned long j = 0; j < aPageSet[i].cElems; j++ )
		{
			pPages->pElems[lPages] = aPageSet[i].pElems[j];
			lPages++;
		}
	}

	return S_OK;
}

STDMETHODIMP CConfiguration::CreatePageObject(IUnknown **ppUnk, CLSID*pCLSID, IVCPropertyContainer *pPropCntr, IVCSettingsPage *pPage )
{
	if( __uuidof(GeneralConfigSettingsPage) == *pCLSID )
	{
		// TODO: Choose nmake page or normal page here.
		return S_OK;
	}
	else if( CLSID_DebugSettingsPage == *pCLSID )
	{
		CPageObjectImpl< CDebugSettingsPage, VCDEBUG_MIN_DISPID, VCDEBUG_MAX_DISPID >::CreateInstance(ppUnk, pPropCntr, pPage);
		return S_OK;
	}
	else
	{
		// not a local one, try the tools.
		long lcItems = m_rgTools.GetSize();
		for (long index = 0; index < lcItems; index++)
		{
			CComPtr<IVCToolImpl> spToolImpl = m_rgTools.GetAt(index);
			if (spToolImpl == NULL)
				continue;
	
			HRESULT hr = spToolImpl->CreatePageObject(ppUnk, pCLSID, pPropCntr, pPage );
			if( hr == S_OK )
				return S_OK;
		}
		return E_FAIL;
	}
}

STDMETHODIMP CConfiguration::CreatesUniqueOutputName(IUnknown* pItem, VARIANT_BOOL* pbUnique)	// will this item have a unique output name?
{
	CHECK_READ_POINTER_NULL(pItem);
	CHECK_POINTER_NULL(pbUnique);
	*pbUnique = VARIANT_TRUE;

	RETURN_ON_NULL2(m_pProject, S_OK);		// cannot do any checking if no project...

	CComQIPtr<IVCFileConfigurationImpl> spNewFileCfgImpl = pItem;
	RETURN_ON_NULL2(spNewFileCfgImpl, S_OK);

	CComBSTR bstrOutputFile;
	if (spNewFileCfgImpl->get_OutputFile(&bstrOutputFile) != S_OK || bstrOutputFile.Length() == 0)
		return S_OK;
	CStringW strOutputFile = bstrOutputFile;

	// actually GOT an output file, so have to check through all the other file configs to see if it matches anything else
	CComPtr<IDispatch> spDispFiles;
	if (m_pProject->get_Files(&spDispFiles) != S_OK)
		return S_OK;
	CComQIPtr<IVCCollection> spFiles = spDispFiles;

	CComPtr<IEnumVARIANT> spEnum;
	spFiles->_NewEnum(reinterpret_cast<IUnknown **>(&spEnum));
	RETURN_ON_NULL2(spEnum, S_OK);

	spEnum->Reset();
	while (TRUE)
	{
		CComVariant var;
		HRESULT hr = spEnum->Next(1, &var, NULL);
		if (hr != S_OK)
			break;
		if (var.vt != VT_DISPATCH && var.vt != VT_UNKNOWN)
			continue;

		// get the file impl
		CComQIPtr<IVCFileImpl> spFileImpl = var.pdispVal;
		if (spFileImpl == NULL)
			continue;

		// get the file config
		CComPtr<VCFileConfiguration> spFileCfg;
		hr = spFileImpl->GetFileConfigurationForProjectConfiguration((VCConfiguration*)this, &spFileCfg);
		if (spFileCfg == NULL)
			continue;
		// get the file config impl
		CComQIPtr<IVCFileConfigurationImpl> spFileCfgImpl = spFileCfg;
		if (spFileCfgImpl == NULL)
			continue;

		if (spFileCfgImpl == spNewFileCfgImpl)
			continue;	// skip the current element

		CComBSTR bstrOut;
		hr = spFileCfgImpl->get_OutputFile(&bstrOut);
		if (hr != S_OK)
			continue;

		CStringW strOut = bstrOut;
		if (strOutputFile == strOut)
		{
			*pbUnique = VARIANT_FALSE;
			return S_FALSE;
		}
	}

	return S_OK;	// no match
}


#ifndef _SHIP
HRESULT CConfiguration::ForceDirty()
{
	CComQIPtr<IVCProjectImpl> spProjectImpl = m_pProject;
	if (spProjectImpl)
		return spProjectImpl->put_IsConverted(VARIANT_TRUE);

	return CVCProjectEngine::DoSetErrorInfo(VCPROJ_E_ZOMBIE, IDS_ERR_CFG_ZOMBIE);
}
#endif	// _SHIP

STDMETHODIMP CVCProjConfigSettingsPage::Commit()
{
	// we need to change the CRT switch based on the combination of Use of MFC and ATL Minimize CRT Usage
	CComVariant varNewUseMFC;
	BOOL bChangedUseOfMFC = (GetLocalProp(VCCFGID_UseOfMFC, &varNewUseMFC) == S_OK);
	CComVariant varNewATLNoCRT;
	BOOL bChangedATLNoCRT = (GetLocalProp(VCCFGID_ATLMinimizesCRunTimeLibraryUsage, &varNewATLNoCRT) == S_OK);
	if (!bChangedUseOfMFC && !bChangedATLNoCRT)	// neither of these changed
		return CVCConfigSettingsPageBase<CVCProjConfigSettingsPage, IVCProjectConfigurationSettings>::Commit();

	// figure out Use of MFC (old, new, current)
	CComVariant varOldUseMFC;
	useOfMfc oldUseOfMFC = useMfcStdWin;
	useOfMfc currentUseOfMFC = useMfcStdWin;
	if (GetParentProp(VCCFGID_UseOfMFC, VARIANT_TRUE /* allow inherit */, &varOldUseMFC) == S_OK)
		oldUseOfMFC = (useOfMfc)varOldUseMFC.lVal;
	if (bChangedUseOfMFC)
		currentUseOfMFC = (useOfMfc)varNewUseMFC.lVal;
	else
		currentUseOfMFC = oldUseOfMFC;

	// figure out ATL Minimize CRT Usage (old, new, current)
	CComVariant varOldATLNoCRT;
	VARIANT_BOOL bOldATLNoCRT = VARIANT_FALSE;
	if (GetParentProp(VCCFGID_ATLMinimizesCRunTimeLibraryUsage, VARIANT_TRUE /* allow inherit */, &varOldATLNoCRT) == S_OK)
		bOldATLNoCRT = varOldATLNoCRT.boolVal;
	VARIANT_BOOL bCurrentATLNoCRT;
	if (bChangedATLNoCRT)
		bCurrentATLNoCRT = varNewATLNoCRT.boolVal;
	else
		bCurrentATLNoCRT = bOldATLNoCRT;

	HRESULT hr = S_OK;
	// Use of MFC takes precedence on how the RuntimeLibrary switch is set
	if (currentUseOfMFC == (long)useMfcStatic || currentUseOfMFC == (long)useMfcDynamic)
	{
		if (bChangedUseOfMFC && (useOfMfc)varNewUseMFC.lVal != oldUseOfMFC)
		{
			CComVariant varRunTimeLib;
			runtimeLibraryOption rtOldOption = rtSingleThreaded;
			if (GetProp(VCCLID_RuntimeLibrary, &varRunTimeLib) == S_OK)
				rtOldOption = (runtimeLibraryOption)varRunTimeLib.lVal;
	
			BOOL bIsDebug = (rtOldOption == rtMultiThreadedDebug || rtOldOption == rtMultiThreadedDebugDLL 
				|| rtOldOption == rtSingleThreadedDebug);

			runtimeLibraryOption rtNewOption;
			if ((useOfMfc)varNewUseMFC.lVal == useMfcStatic)
				rtNewOption = bIsDebug ? rtMultiThreadedDebug : rtMultiThreaded;

			else	// useMfcDynamic
				rtNewOption = bIsDebug ? rtMultiThreadedDebugDLL : rtMultiThreadedDLL;

			if (rtOldOption != rtNewOption)
			{
				CComVariant var = rtNewOption;
				SetProp(VCCLID_RuntimeLibrary, var);
				hr = CommitSingleProp(VCCLID_RuntimeLibrary);
				RETURN_ON_FAIL(hr);
			}
		}
	}

	else if (bCurrentATLNoCRT == VARIANT_TRUE)
	{
		if (bChangedATLNoCRT && varNewATLNoCRT.boolVal == VARIANT_TRUE && bOldATLNoCRT != VARIANT_TRUE)
		{
			CComVariant varRunTimeLib;
			runtimeLibraryOption rtOldOption = rtSingleThreaded;
			if (GetProp(VCCLID_RuntimeLibrary, &varRunTimeLib) == S_OK)
				rtOldOption = (runtimeLibraryOption)varRunTimeLib.lVal;
	
			BOOL bIsDebug = (rtOldOption == rtMultiThreadedDebug || rtOldOption == rtMultiThreadedDebugDLL 
				|| rtOldOption == rtSingleThreadedDebug);

			runtimeLibraryOption rtNewOption = bIsDebug ? rtMultiThreadedDebug : rtMultiThreaded;
			if (rtOldOption != rtNewOption)
			{
				CComVariant var = rtNewOption;
				SetProp(VCCLID_RuntimeLibrary, var);
				hr = CommitSingleProp(VCCLID_RuntimeLibrary);
				RETURN_ON_FAIL(hr);
			}
		}
	}

	return CVCConfigSettingsPageBase<CVCProjConfigSettingsPage, IVCProjectConfigurationSettings>::Commit();
}

void CVCProjConfigSettingsPage::GetBaseDefault(long id, CComVariant& varValue)
{
	if (id == VCCFGID_DeleteExtensionsOnClean)
	{
		CComBSTR bstrVal;
		CConfiguration::GetDefaultValue(VCCFGID_DeleteExtensionsOnClean, &bstrVal, this);
		varValue = bstrVal; 
	}
	else
		CBase::GetBaseDefault(id, varValue);
}

STDMETHODIMP CVCProjConfigSettingsPage::get_IntermediateDirectory(BSTR *pVal)
{
	HRESULT hr = GetStrProperty(VCCFGID_IntermediateDirectory, pVal);
	if (hr == S_FALSE)
		COptionHandlerBase::GetDefaultString(pVal);
	return hr;
}

STDMETHODIMP CVCProjConfigSettingsPage::put_IntermediateDirectory(BSTR newVal)
{
	return SetStrProperty(VCCFGID_IntermediateDirectory, newVal);
}

STDMETHODIMP CVCProjConfigSettingsPage::get_OutputDirectory(BSTR *pVal)
{
	HRESULT hr = GetStrProperty(VCCFGID_OutputDirectory, pVal);
	if (hr == S_FALSE)
		COptionHandlerBase::GetDefaultString(pVal);
	return hr;
}

STDMETHODIMP CVCProjConfigSettingsPage::put_OutputDirectory(BSTR newVal)
{
	return SetStrProperty(VCCFGID_OutputDirectory, newVal);
}

STDMETHODIMP CVCProjConfigSettingsPage::get_ConfigurationType(ConfigurationTypes* pconfigType)
{
	HRESULT hr = GetIntProperty(VCCFGID_ConfigurationType, (long *)pconfigType);
	if (hr == S_FALSE)
		CConfiguration::SGetConfigurationType(pconfigType);
	return hr;
}

STDMETHODIMP CVCProjConfigSettingsPage::put_ConfigurationType(ConfigurationTypes configType)
{
	return SetIntProperty(VCCFGID_ConfigurationType, configType);
}

STDMETHODIMP CVCProjConfigSettingsPage::get_BuildBrowserInformation(VARIANT_BOOL* pbBsc)	// build .bsc file
{
	HRESULT hr = GetBoolProperty(VCCFGID_BuildBrowserInformation, pbBsc);
	if (hr == S_FALSE)
		CConfiguration::GetDefaultValue(VCCFGID_BuildBrowserInformation, pbBsc, this);
	return hr;
}

STDMETHODIMP CVCProjConfigSettingsPage::put_BuildBrowserInformation(VARIANT_BOOL bBsc)
{
	return SetBoolProperty(VCCFGID_BuildBrowserInformation, bBsc);
}

STDMETHODIMP CVCProjConfigSettingsPage::get_UseOfMFC(useOfMfc* puseMfc)	// use of MFC
{
	HRESULT hr = GetIntProperty(VCCFGID_UseOfMFC, (long *)puseMfc);
	if (hr == S_FALSE)
		CConfiguration::GetDefaultValue(VCCFGID_UseOfMFC, (long *)puseMfc, this);
	return hr;
}

STDMETHODIMP CVCProjConfigSettingsPage::put_UseOfMFC(useOfMfc useMfc)
{
	return SetIntProperty(VCCFGID_UseOfMFC, useMfc);
}

STDMETHODIMP CVCProjConfigSettingsPage::get_UseOfATL(useOfATL* puseATL)
{	// how are we using ATL?
	CHECK_POINTER_VALID(puseATL);
	HRESULT hr = GetIntProperty(VCCFGID_UseOfATL, (long *)puseATL);
	if (hr == S_FALSE)
		CConfiguration::GetDefaultValue(VCCFGID_UseOfATL, (long *)puseATL, this);
	return hr;
}

STDMETHODIMP CVCProjConfigSettingsPage::put_UseOfATL(useOfATL useATL)
{
	return SetIntProperty(VCCFGID_UseOfATL, useATL);
}

STDMETHODIMP CVCProjConfigSettingsPage::get_ATLMinimizesCRunTimeLibraryUsage(VARIANT_BOOL* pbCRT)
{	// is this an ATL min dependency?
	CHECK_POINTER_VALID(pbCRT);
	HRESULT hr = GetBoolProperty(VCCFGID_ATLMinimizesCRunTimeLibraryUsage, pbCRT);
	if (hr == S_FALSE)
		CConfiguration::GetDefaultValue(VCCFGID_ATLMinimizesCRunTimeLibraryUsage, pbCRT, this);
	return hr;
}

STDMETHODIMP CVCProjConfigSettingsPage::put_ATLMinimizesCRunTimeLibraryUsage(VARIANT_BOOL bCRT)
{
	return SetBoolProperty(VCCFGID_ATLMinimizesCRunTimeLibraryUsage, bCRT);
}

STDMETHODIMP CVCProjConfigSettingsPage::get_CharacterSet(charSet* pset)
{	// what type of character set are we using?
	CHECK_POINTER_VALID(pset);
	HRESULT hr = GetIntProperty(VCCFGID_CharacterSet, (long *)pset);
	if (hr == S_FALSE)
		CConfiguration::GetDefaultValue(VCCFGID_CharacterSet, (long *)pset, this);
	return hr;
}

STDMETHODIMP CVCProjConfigSettingsPage::put_CharacterSet(charSet set)
{
	return SetIntProperty(VCCFGID_CharacterSet, set);
}

STDMETHODIMP CVCProjConfigSettingsPage::get_ManagedExtensions(VARIANT_BOOL* pbManaged)	// is this a managed extensions project?
{
	HRESULT hr = GetBoolProperty(VCCFGID_ManagedExtensions, pbManaged);
	if (hr == S_FALSE)
		CConfiguration::GetDefaultValue(VCCFGID_ManagedExtensions, pbManaged, this);
	return hr;
}

STDMETHODIMP CVCProjConfigSettingsPage::put_ManagedExtensions(VARIANT_BOOL bManaged)
{
	return SetBoolProperty(VCCFGID_ManagedExtensions, bManaged);
}

STDMETHODIMP CVCProjConfigSettingsPage::get_DeleteExtensionsOnClean(BSTR* pbstrExt)
{	// wildcard extension list to delete on clean/rebuild from within the intermediate directory
	HRESULT hr = GetStrProperty(VCCFGID_DeleteExtensionsOnClean, pbstrExt);
	if (hr == S_FALSE)
		CConfiguration::GetDefaultValue(VCCFGID_DeleteExtensionsOnClean, pbstrExt, this);
	return hr;
}

STDMETHODIMP CVCProjConfigSettingsPage::put_DeleteExtensionsOnClean(BSTR bstrExt)
{
	return SetStrProperty(VCCFGID_DeleteExtensionsOnClean, bstrExt);
}

STDMETHODIMP CVCProjConfigSettingsPage::get_WholeProgramOptimization(VARIANT_BOOL* pbOptimized)
{	// perform whole program optimization on build more or less requires optimization turned on to be effective
	return GetBoolProperty(VCCFGID_WholeProgramOptimization, pbOptimized);
}

STDMETHODIMP CVCProjConfigSettingsPage::put_WholeProgramOptimization(VARIANT_BOOL bOptimize)
{
	return SetBoolProperty(VCCFGID_WholeProgramOptimization, bOptimize);
}

STDMETHODIMP CVCProjConfigSettingsPage::MapPropertyToCategory( DISPID dispid, PROPCAT* ppropcat)
{
	switch( dispid )
	{
		case VCCFGID_OutputDirectory:
		case VCCFGID_IntermediateDirectory:
		case VCCFGID_DeleteExtensionsOnClean:
			*ppropcat = IDS_GENERALCAT;
			break;
		case VCCFGID_ConfigurationType:
		case VCCFGID_BuildBrowserInformation:
		case VCCFGID_UseOfMFC:
		case VCCFGID_UseOfATL:
		case VCCFGID_ATLMinimizesCRunTimeLibraryUsage:
		case VCCFGID_CharacterSet:
		case VCCFGID_ManagedExtensions:
		case VCCFGID_WholeProgramOptimization:
			*ppropcat = IDS_PROJDEFAULTSCAT;
			break;
		default:
			*ppropcat = 0;
			break;
	}
	return S_OK;
}

STDMETHODIMP CVCProjConfigSettingsPage::GetCategoryName( PROPCAT propcat, LCID lcid, BSTR* pbstrName)
{
	CComBSTR bstrCat;
	bstrCat.LoadString(propcat);
	return bstrCat.CopyTo(pbstrName);
}

STDMETHODIMP CVCGeneralMakefileSettingsPage::get_ConfigurationType(ConfigurationTypes* pconfigType)
{
	HRESULT hr = GetIntProperty(VCCFGID_ConfigurationType, (long *)pconfigType);
	if (hr == S_FALSE)
		CConfiguration::SGetConfigurationType(pconfigType);
	return hr;
}

STDMETHODIMP CVCGeneralMakefileSettingsPage::put_ConfigurationType(ConfigurationTypes configType)
{
	return SetIntProperty(VCCFGID_ConfigurationType, configType);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\vcpb\Collection.h ===
// Collection.h: Definition of the CCollection class
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_COLLECTION_H__A54AAE9C_30C2_11D3_87BF_A04A4CC10000__INCLUDED_)
#define AFX_COLLECTION_H__A54AAE9C_30C2_11D3_87BF_A04A4CC10000__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "comlist.h"
#include "VCProjectEngine.h"


/////////////////////////////////////////////////////////////////////////////
// CCollection
template <class CollType>
class CCollection : 
	public IDispatchImpl<IVCCollection, &__uuidof(IVCCollection), &LIBID_VCProjectEngineLibrary, PublicProjBuildTypeLibNumber,0, CVsTypeInfoHolder>, 
	public IEnumVARIANT,
	public CComObjectRoot
{
public:
	typedef CComDynamicListTyped< CollType> CDynList;

	static HRESULT CreateInstance(IVCCollection **ppCollection, CDynList *prgDisp, IVCCollectionProvider* pCollectionProvider = NULL, 
		DWORD dwCookie = 0)
	{
		HRESULT hr;
		CCollection *pVar;
		CComObject< CCollection<CollType> > *pObj;
		hr = CComObject< CCollection<CollType> >::CreateInstance(&pObj);
		if (SUCCEEDED(hr))
		{
			pVar = pObj;
			pVar->AddRef();
			*ppCollection = pVar;
			hr = pVar->Initialize(prgDisp, pCollectionProvider, dwCookie);
		}
		return hr;
	}
	STDMETHOD(Initialize)(CDynList *prgDisp, IVCCollectionProvider* pCollectionProvider, DWORD dwCookie);
	CCollection() 
	{
	}
	~CCollection()
	{
	}

BEGIN_COM_MAP(CCollection<CollType>)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IVCCollection)
	COM_INTERFACE_ENTRY(IEnumVARIANT)
END_COM_MAP()
//DECLARE_NOT_AGGREGATABLE(CCollection) 

DECLARE_NO_REGISTRY()

// IVCCollection
public:
	STDMETHOD(get_Count)(/*[out, retval]*/ long *pVal);
	STDMETHOD(_NewEnum)(/*[out, retval]*/ IUnknown* *pVal);
	STDMETHOD(Item)(VARIANT Index, /*[out]*/ IDispatch **pItem);
	STDMETHOD(get_VCProjectEngine)(/*[out, retval*/ IDispatch** ppProjectEngine);

// IEnumVARIANT
public:
	STDMETHOD(Next)( ULONG celt, VARIANT *rgVar, ULONG *pCeltFetched);
	STDMETHOD(Skip)(/* [in] */ ULONG celt);
	STDMETHOD(Reset)( void);
	STDMETHOD(Clone)(/* [out] */ IEnumVARIANT __RPC_FAR *__RPC_FAR *ppEnum);

// data
protected:
	CDynList *m_ppDisp;
	int	m_lIndexCurr;
	CComPtr<IVCCollectionProvider> m_pCollectionProvider;
	DWORD m_dwCookie;
};

template <class CollType>
STDMETHODIMP CCollection<CollType>::Initialize(CDynList *prgDisp, IVCCollectionProvider* pCollectionProvider, DWORD dwCookie)
{
	m_ppDisp = prgDisp;
	m_lIndexCurr = 0;
	m_pCollectionProvider = pCollectionProvider;
	m_dwCookie = dwCookie;
	return S_OK;
}

template <class CollType>
STDMETHODIMP CCollection<CollType>::Item(VARIANT Index, IDispatch **ppDispItem)
{
	CHECK_ZOMBIE(m_ppDisp, IDS_ERR_COLLECTION_ZOMBIE);
	if (m_pCollectionProvider)
		m_pCollectionProvider->UpdateItemsCollection(m_dwCookie);

	CComVariant varIndex;
	varIndex= Index;
	
	CHECK_POINTER_VALID(ppDispItem);
	*ppDispItem = NULL;

	if ((varIndex.vt == (VT_VARIANT | VT_BYREF)) && varIndex.pvarVal)
	{
		varIndex = *varIndex.pvarVal;
	}
	if( varIndex.vt == VT_I4 || varIndex.vt == VT_I2 )
	{
		CollType *pItem = NULL;
		varIndex.ChangeType(VT_I4);

		if (m_ppDisp->HasAnItemBeenRemoved())
		{
			long nIndexTarget = varIndex.lVal;
			long nIndexT = 0, nIndexItem = 0;
			long nMaxSize = m_ppDisp->GetSize();
			if (nIndexItem < m_ppDisp->GetSize())
			{
				do
				{
					pItem = m_ppDisp->GetAt(nIndexItem);
					if (pItem)
						nIndexT++;
					nIndexItem++;
				}
				while (nIndexItem < nMaxSize && nIndexT != nIndexTarget);
			}

			if (pItem && nIndexT == nIndexTarget)
			{
				pItem->QueryInterface(_uuidof(IDispatch), (void**)ppDispItem);
				return S_OK;
			}
			else
			{
				*ppDispItem = NULL;
				return S_FALSE;
			}
		}
		else
		{
			if (varIndex.lVal < 1)
			{
				RETURN_INVALID();
			}
			else if (varIndex.lVal <= m_ppDisp->GetSize())
				pItem = m_ppDisp->GetAt(varIndex.lVal - 1);
			else
				pItem = NULL;

			if (pItem)
			{
				pItem->QueryInterface(_uuidof(IDispatch), (void**)ppDispItem);
				return S_OK;
			}
			else
			{
				*ppDispItem = NULL;
				return S_FALSE;
			}
		}
	}
	if( varIndex.vt == VT_BSTR )
	{
		CComQIPtr<CollType> pItem;
		CComBSTR bstrName;
		long nIndex;
		long lcItems;
		VARIANT_BOOL bMatch;
		lcItems = m_ppDisp->GetSize();
		for(nIndex = 0; nIndex < lcItems; nIndex++ )
		{
			pItem = m_ppDisp->GetAt(nIndex);
			if (pItem)
			{
				pItem->MatchName(varIndex.bstrVal, VARIANT_FALSE /* any match*/, &bMatch);
				if (bMatch)
				{
					pItem.QueryInterface(ppDispItem);
					return S_OK;
				}
			}
		}
	}
	if (varIndex.vt == VT_DISPATCH || varIndex.vt == VT_UNKNOWN)
	{
		CComQIPtr<CollType> pInItem = varIndex.pdispVal;
		long lcItems = m_ppDisp->GetSize();
		for (long nIndex = 0; nIndex < lcItems; nIndex++)
		{
			CComQIPtr<CollType> pThisItem = m_ppDisp->GetAt(nIndex);
			if (pThisItem == NULL)
				continue;

			if (pThisItem == pInItem)
			{
				pThisItem.QueryInterface(ppDispItem);
				return S_OK;
			}
		}
	}
	return S_OK;
}

template <class CollType>
STDMETHODIMP CCollection<CollType>::_NewEnum(IUnknown **ppenum)
{
	return QueryInterface(__uuidof(IEnumVARIANT), (LPVOID *)ppenum);
}

template <class CollType>
STDMETHODIMP CCollection<CollType>::get_Count(long *pVal)
{
	CHECK_POINTER_VALID(pVal);

	if (m_pCollectionProvider)
		m_pCollectionProvider->UpdateItemsCollection(m_dwCookie);

	*pVal =  m_ppDisp->GetCount();
	return S_OK;
}

template <class CollType>
STDMETHODIMP CCollection<CollType>::get_VCProjectEngine(IDispatch** ppProjectEngine)
{
	CHECK_POINTER_VALID(ppProjectEngine);
	VSASSERT(g_pProjectEngine != NULL, "Project Engine not initialized!!!");

	CComQIPtr<IDispatch> spDispEngine = g_pProjectEngine;
	return spDispEngine.CopyTo(ppProjectEngine);
}	

template <class CollType>
STDMETHODIMP CCollection<CollType>::Next( 
        /* [in] */ ULONG celt,
        /* [length_is][size_is][out] */ VARIANT *rgVar,
        /* [out] */ ULONG *pceltFetched)
{
	if (m_pCollectionProvider)
		m_pCollectionProvider->UpdateItemsCollection(m_dwCookie);

	HRESULT hr = S_OK;
	if (pceltFetched != NULL)
		*pceltFetched = 0;
	if (celt == 0)
		RETURN_INVALID();
	CHECK_POINTER_VALID(rgVar);
	if (celt != 1)
		CHECK_POINTER_VALID(pceltFetched);
	CHECK_ZOMBIE(m_ppDisp, IDS_ERR_COLLECTION_ZOMBIE);
	ULONG lMax = m_ppDisp->GetCount();
	ULONG nRem = (ULONG)(lMax - m_lIndexCurr);
	if (lMax < (ULONG)m_lIndexCurr)
	{
		nRem = 0;
		hr = S_FALSE;
	}
	else if (nRem < celt)
		hr = S_FALSE;
	ULONG nMin = min(celt, nRem);
	ULONG idx = 0;
	CollType *pItem = NULL;

	if (m_ppDisp->HasAnItemBeenRemoved())
	{
		while (nMin > 0)
		{
			int nIndexT = 0, nIndexItem = 0;
			// go through the list again for the correct index (just in case a delete/add happened)
			if (nIndexItem < m_ppDisp->GetSize())
			{
				do
				{
					pItem = (CollType*)m_ppDisp->GetAt(nIndexItem);
					if (pItem)
					{
						nIndexT++;
					}
					nIndexItem++;
				}
				while (nIndexItem < m_ppDisp->GetSize()  && nIndexT != m_lIndexCurr + 1);
			}
			if (pItem && nIndexT == m_lIndexCurr + 1) // plus one is because we come out of the loop after incrementing
			{
				CComPtr<IUnknown> pUnk;
				pItem->QueryInterface(_uuidof(IUnknown),(void**)&pUnk);
				if( pUnk )
				{
					CComVariant varRes;
					varRes = pUnk;
					hr = varRes.Detach(&rgVar[idx]);
					m_lIndexCurr++;
					idx++;
					if (pceltFetched != NULL)
						(*pceltFetched)++;
				}
			}
			nMin--;
		}
	}
	else
	{
		while (nMin--)
		{
			pItem = m_ppDisp->GetAt(m_lIndexCurr);
			CComPtr<IUnknown> pUnk;
			if (pItem)
				pItem->QueryInterface(_uuidof(IUnknown),(void**)&pUnk);

			if (pUnk)
			{
				CComVariant vItem(pUnk);
				vItem.Detach(&rgVar[idx++]);
				m_lIndexCurr++;
			}
		}

		if (pceltFetched)
		{
			*pceltFetched = idx;
		}
	}

	return hr;
}
        
template <class CollType>
STDMETHODIMP CCollection<CollType>::Skip(/* [in] */ ULONG celt)
{
	if (m_pCollectionProvider)
		m_pCollectionProvider->UpdateItemsCollection(m_dwCookie);

	HRESULT hr = S_OK;
	m_lIndexCurr += celt;
	return hr;
}

        
template <class CollType>
STDMETHODIMP CCollection<CollType>::Reset( void)
{
	HRESULT hr = S_OK;
	m_lIndexCurr = 0;
	return hr;
}

        
template <class CollType>
STDMETHODIMP CCollection<CollType>::Clone(/* [out] */ IEnumVARIANT  **ppEnum)
{
	HRESULT hr = S_OK;
	CComPtr<IVCCollection> pCollection;

	hr = CreateInstance(&pCollection, m_ppDisp, m_pCollectionProvider, m_dwCookie);
	if (SUCCEEDED(hr) && pCollection)
	{
		hr = pCollection->_NewEnum(reinterpret_cast<IUnknown**>(ppEnum));
	}
	return hr;
}


#endif // !defined(AFX_COLLECTION_H__A54AAE9C_30C2_11D3_87BF_A04A4CC10000__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\vcpb\Configuration.h ===
// Configuration.h: Definition of the CConfiguration class
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_CONFIGURATION_H__A54AAE82_30C2_11D3_87BF_A04A4CC10000__INCLUDED_)
#define AFX_CONFIGURATION_H__A54AAE82_30C2_11D3_87BF_A04A4CC10000__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "configrecords.h"
#include "settingspage.h"
#include "StyleSheet.h"

// Warning C4584 : 'C' : base-class 'A' is already a base-class of 'B'
//
//  A     
//   \
//    B   A
//     \ /
//      C
// 

#pragma warning ( disable : 4584 )

/////////////////////////////////////////////////////////////////////////////
// CConfiguration

class CConfiguration : 
	public IDispatchImpl<VCConfiguration, &__uuidof(VCConfiguration), &LIBID_VCProjectEngineLibrary, PublicProjBuildTypeLibNumber,0, CVsTypeInfoHolder>, 
	public IVCConfigurationImpl,
	public IVCBuildableItem,
	public CComObjectRoot,
	public CStyleSheetBase
{
public:
	CConfiguration();
	~CConfiguration();

	static HRESULT CreateInstance(VCConfiguration **ppConfiguration, LPCOLESTR szConfigName, VCPlatform *pPlatform, VCProject *pProject);
	HRESULT Initialize(LPCOLESTR szConfigName, VCPlatform *pPlatform, VCProject *pProject);

BEGIN_COM_MAP(CConfiguration)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(VCConfiguration)
	COM_INTERFACE_ENTRY(IVCConfigurationImpl)
	COM_INTERFACE_ENTRY(IVCPropertyContainer)
	COM_INTERFACE_ENTRY(IVCBuildableItem)
	COM_INTERFACE_ENTRY(ISpecifyPropertyPages)
END_COM_MAP()
//DECLARE_NOT_AGGREGATABLE(CConfiguration) 
// Remove the comment from the line above if you don't want your object to 
// support aggregation. 

DECLARE_NO_REGISTRY()

	// VCConfiguration
public:
	STDMETHOD(get_Name)(BSTR * pVal);
	STDMETHOD(put_Name)(BSTR pVal);
	STDMETHOD(get_Platform)(IDispatch * * pVal);
	STDMETHOD(get_OutputDirectory)(BSTR * pVal);
	STDMETHOD(put_OutputDirectory)(BSTR pVal);
	STDMETHOD(get_IntermediateDirectory)(BSTR * pVal);
	STDMETHOD(put_IntermediateDirectory)(BSTR pVal);
	STDMETHOD(get_DeleteExtensionsOnClean)(BSTR* pbstrExt);	// wildcard extension list to delete on clean/rebuild from within the intermediate directory
	STDMETHOD(put_DeleteExtensionsOnClean)(BSTR bstrExt);
	STDMETHOD(Delete)();
	STDMETHOD(Build)();
	STDMETHOD(Rebuild)();
	STDMETHOD(Clean)();
	STDMETHOD(get_DebugSettings)(IDispatch * * pVal);
	STDMETHOD(get_PrimaryOutput)(BSTR * pVal);
	STDMETHOD(get_ImportLibrary)(BSTR* pVal);
	STDMETHOD(get_ProgramDatabase)(BSTR* pbstrPDB);
	STDMETHOD(get_Project)(IDispatch * * pVal);
	STDMETHOD(MatchName)(BSTR bstrNameToMatch, VARIANT_BOOL bFullOnly, VARIANT_BOOL *pbMatched);
	STDMETHOD(get_Tools)(/*[out, retval]*/ IDispatch * *pVal);
	STDMETHOD(get_ConfigurationName)(BSTR * pVal);
	STDMETHOD(put_ConfigurationName)(BSTR pVal);
	STDMETHOD(get_FileTools)(/*[out, retval]*/ IVCCollection * *pVal);
	STDMETHOD(get_UpToDate)(VARIANT_BOOL* pbUpToDate);
	STDMETHOD(get_ConfigurationType)(ConfigurationTypes* pconfigType);
	STDMETHOD(put_ConfigurationType)(ConfigurationTypes configType);
	STDMETHOD(CopyTo)(IDispatch *pDestCfg);
	STDMETHOD(get_AppliedStyleSheets)(BSTR* pbstrStyles);
	STDMETHOD(put_AppliedStyleSheets)(BSTR bstrStyles);
	STDMETHOD(get_BuildBrowserInformation)(VARIANT_BOOL* pbBsc);	// build .bsc file
	STDMETHOD(put_BuildBrowserInformation)(VARIANT_BOOL bBsc);
	STDMETHOD(get_UseOfMFC)(useOfMfc* useMfc);	// how are we using MFC?
	STDMETHOD(put_UseOfMFC)(useOfMfc useMfc);
	STDMETHOD(get_UseOfATL)(useOfATL* useATL);	// how are we using ATL?
	STDMETHOD(put_UseOfATL)(useOfATL useATL);
	STDMETHOD(get_ATLMinimizesCRunTimeLibraryUsage)(VARIANT_BOOL* pbUseCRT);	// does the user want to link with the static or dynamic CRT?
	STDMETHOD(put_ATLMinimizesCRunTimeLibraryUsage)(VARIANT_BOOL bUseCRT);
	STDMETHOD(get_CharacterSet)(charSet* poptSetting);	// character set to use: Unicode, MBCS, default
	STDMETHOD(put_CharacterSet)(charSet optSetting);
	STDMETHOD(get_ManagedExtensions)(VARIANT_BOOL* bManaged);	// is this a managed C++ extensions project?
	STDMETHOD(put_ManagedExtensions)(VARIANT_BOOL bManaged);
	STDMETHOD(get_RegisterOutput)(VARIANT_BOOL* pbRegister);	// register the primary output of the build
	STDMETHOD(get_WholeProgramOptimization)(VARIANT_BOOL* pbOptimized);	// perform whole program optimization on build; more or less requires optimization turned on to be effective
	STDMETHOD(put_WholeProgramOptimization)(VARIANT_BOOL bOptimize);
	STDMETHOD(Evaluate)(BSTR bstrIn, BSTR* pbstrOut) { return CStyleSheetBase::Evaluate(bstrIn, pbstrOut); }
	STDMETHOD(get_StyleSheets)(IDispatch** styles) { return CStyleSheetBase::DoGetStyleSheets(styles); }
	STDMETHOD(get_VCProjectEngine)(IDispatch** projEngine)	{ return DoGetVCProjectEngine(projEngine); }

// VCConfiguration helpers
protected:
	HRESULT DoSetConfigurationType(ConfigurationTypes configType, BOOL bForceUpdate = FALSE);

// IVCConfigurationImpl
public:
	STDMETHOD(SetDefaultToolForFile)(IDispatch *pDispFileConfiguration);
	STDMETHOD(get_IsValidConfiguration)(VARIANT_BOOL* pbIsValidConfiguration);
	STDMETHOD(get_IsBuildable)(VARIANT_BOOL* pbIsBuildable);
	STDMETHOD(get_CanStartBuild)(VARIANT_BOOL* pbCanStartBuild);
	STDMETHOD(get_BaseToolList)(void** ppPtrList);
	STDMETHOD(GenerateToolWrapperList)();
	STDMETHOD(ClearToolWrapperList)();
	STDMETHOD(Close)();
	STDMETHOD(put_Project)(IDispatch * pVal);
	STDMETHOD(SaveObject)(IStream *xml, IVCPropertyContainer *pPropCnt, long nIndent);
	STDMETHOD(WriteToStream)(IStream *pStream);
	STDMETHOD(ReadFromStream)(IStream *pStream);
	STDMETHOD(TopLevelBuild)(bldActionTypes buildType, ULONG cFiles, VCFile* pFiles[], IVCBuildEngine* pBuildEngine,
		IVCBuildErrorContext* pEC, BOOL bRecurse, BOOL fDoIdleAndPump, BOOL fCleanupEngine, BOOL bProvideBanner, long* warnings, 
		long* errors, BOOL* bCancelled);
	STDMETHOD(get_MrePath)(BSTR* pbstrMrePath);
	STDMETHOD(get_Dependencies)(IVCBuildStringCollection** ppDependencies);
	STDMETHOD(get_BuildOutputs)(IVCBuildStringCollection** ppOutputs);
	STDMETHOD(get_ProjectDependencies)(IVCBuildOutputItems** ppProjDependencies);
	STDMETHOD(get_ProjectDependenciesAsStrings)(IVCBuildStringCollection** ppProjDependencies);
	STDMETHOD(get_HasProjectDependencies)(VARIANT_BOOL* pbHasDeps);
	STDMETHOD(get_KnownDeploymentDependencies)(IVCBuildStringCollection** ppDeployDependencies);
	// WARNING: Clone must only be called on a brand new config!!
	STDMETHOD(Clone)(IVCPropertyContainer *pSource );
	STDMETHOD(SupportsBuildType)(bldActionTypes buildType, VARIANT_BOOL* pbSupports, VARIANT_BOOL* pbAvailable);
	STDMETHOD(CreatePageObject)(IUnknown **, CLSID*, IVCPropertyContainer *pSource, IVCSettingsPage * );
	STDMETHOD(CreatesUniqueOutputName)(IUnknown* pItem, VARIANT_BOOL* pbUnique);	// will this item have a unique output name?
	STDMETHOD(GetPrimaryOutputFileID)(IVCToolImpl** ppTool, long* pnOutputID);
	STDMETHOD(get_ErrorContext)(IVCBuildErrorContext** ppEC);
	STDMETHOD(AddTool)(LPCOLESTR szToolName, IDispatch** ppTool);	// adds a new tool to the config
	STDMETHOD(get_DeployableOutputsCount)(long* pnOutputs);	// number of deployable outputs
	STDMETHOD(get_DeployableOutputs)(IVCBuildStringCollection** ppDeployableOutputs);	// the deployable outputs
	STDMETHOD(DirtyOutputs)(long nProjID);	// dirty outputs based on the passed-in project ID

// IVCPropertyContainer; most methods are in a base class
public:
	STDMETHOD(DirtyProp)(long id);

// IVCBuildableItem
public:
	STDMETHOD(get_ItemFileName)(BSTR *pVal);
	STDMETHOD(get_ItemFullPath)(BSTR* pbstrFullPath);
	STDMETHOD(get_ActionList)(IVCBuildActionList** ppActions);
	STDMETHOD(get_FileRegHandle)(void** pfrh);
	STDMETHOD(AssignActions)(VARIANT_BOOL bOnLoad);
	STDMETHOD(UnAssignActions)(VARIANT_BOOL bOnClose);
	STDMETHOD(get_ContentList)(IEnumVARIANT** ppContentList);
	STDMETHOD(get_Registry)(void** ppFileRegistry);
	STDMETHOD(get_ProjectConfiguration)(VCConfiguration** ppProjCfg);
	STDMETHOD(get_ProjectInternal)(VCProject** ppProject);
	STDMETHOD(get_ExistingBuildEngine)(IVCBuildEngine** ppBuildEngine);
	STDMETHOD(get_PersistPath)(BSTR* pbstrPersistPath);
	STDMETHOD(RefreshActionOutputs)(long nPropID, IVCBuildErrorContext* pEC);
	STDMETHOD(HandlePossibleCommandLineOptionsChange)(IVCBuildErrorContext* pEC);
	STDMETHOD(ClearDirtyCommandLineOptionsFlag)();

// ISpecifyPropertyPages
public:
    STDMETHOD(GetPages)( /* [out] */ CAUUID *pPages );
       
// IVCConfigurationImpl helpers
	HRESULT DoPreparedBuild(ULONG cFiles, VCFile* pFiles[], bldActionTypes buildType, BOOL bContinueAfterErrors, 
		IVCBuildErrorContext* pEC, BuildType bt, BOOL bRecurse, BuildResults* pResults);
	void InitializeDepGraph(CBldCfgRecord* pCfgRecord);
	void DoInitializeDepGraph(CBldCfgRecord** ppCfgRecord);
	void InitActions(IVCBuildActionList* pBldActions);
	void LateBindActions(IVCBuildActionList* pBldActions);
	HRESULT DoBuild(bldActionTypes bldType);
	virtual HRESULT DoClearToolWrapperList();

	// IVCPropertyContainer helpers
	virtual HRESULT DoGetStrProperty(long idProp, BOOL bSpecialPropsOnly, BSTR* pbstrValue);
	virtual HRESULT DoGetBoolProperty(long idProp, BOOL bCheckSpecial, VARIANT_BOOL* pbValue);
	virtual HRESULT DoSetIntProperty(long idProp, BOOL bCheckSpecialProps, long nValue, long nOverrideID = -1);
	virtual HRESULT DoSetBoolProperty(long id, BOOL bCheckSpecialProps, VARIANT_BOOL bValue, long nOverrideID = -1);
	virtual HRESULT FinishSetPropOrClear(long id, long nOverride);

	// IVCBuildableItem helpers
	HRESULT GetNextFileConfig(IEnumVARIANT* pEnum, VCFileConfiguration** ppFileCfg);
	HRESULT GetNextFileConfig(IEnumVARIANT* pEnum, IVCBuildableItem** ppBldableFileCfg);
	HRESULT StartCommandLineOptionChange(IVCBuildErrorContext* pEC);
	HRESULT RefreshCommandLineOptionsAndOutputs(IVCBuildErrorContext* pEC);
	HRESULT DirtyActionOutputsAndCommandLineOptions(long nLowPropID, long nHighPropID, long nOverride);

// LOCAL METHODS
public:
	HRESULT SetDirty(VARIANT_BOOL bDirty);
	static HRESULT SGetConfigurationType(ConfigurationTypes* pconfigType);

protected:
	HRESULT GetFileListEnumerator(IEnumVARIANT** ppFileList);
	virtual void DoGetToolSetType(toolSetType& listStyle);
	virtual HRESULT VerifyFileTools();
	void ClearToolExtensionList();
	void InitToolExtensionList(BOOL bReInit = FALSE);
	void InitToolExtensionListForOneTool(IVCToolImpl* pToolImpl);
	void CleanUpEngine(BOOL fCleanupEngine);
	HRESULT HandleReadingDebugSettings(IStream* pStream);
	HRESULT HandleReadingToolSettings(IStream* pStream, CComBSTR& bstrName);
	HRESULT HandleReadingGeneralConfigSettings(IStream* pStream);
#ifndef _SHIP
	HRESULT ForceDirty();
#endif	// _SHIP

//DATA
protected:
	// ordered like this for packing, not because it makes logical sense
	CComQIPtr<VCProject>		m_pProject;
	CComPtr<VCDebugSettings>	m_pDebug;
	CComPtr<IVCBuildActionList> m_spActionList;
	CComDynamicListTyped<VCFileConfiguration> m_rgFileCfgs;		// collection of file cfgs for this project; temporary use only
	CComPtr<IVCBuildEngine>		m_spBuildEngine;
	CComPtr<IVCBuildErrorContext> m_spBuildErrorContext;
	CVCMapStringWToPtr			m_ExtensionMap;
	CComBSTR					m_bstrFullName;
	static CTestableSection		g_sectionBuildEngine;

	VARIANT_BOOL				m_bIsValidConfiguration;
	VARIANT_BOOL				m_bIsBuildable;
	BOOL						m_bInitExtensionList;
	BOOL						m_fDoIdleAndPump;
};

/////////////////////////////////////////////////////////////////////////////
// CVConfigSettingsPageBase
template<class T, class I>
class CVCConfigSettingsPageBase :
	public IDispatchImpl<I, &__uuidof(I), &LIBID_VCProjectEnginePrivateLibrary, PrivateProjBuildTypeLibNumber,0, CVsTypeInfoHolder>,
	public CPageObjectImpl<T, VCCONFIGURATION_MIN_DISPID, VCCONFIGURATION_MAX_DISPID>,
	public CComObjectRoot
{
public:
	// IDispatch override
	STDMETHOD(Invoke)( DISPID dispid, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS *pdispParams, VARIANT *pvarResult, EXCEPINFO *pexcepInfo, UINT *puArgErr )
	{
		IDispatchImpl<I, &__uuidof(I), &LIBID_VCProjectEnginePrivateLibrary, PrivateProjBuildTypeLibNumber,0, CVsTypeInfoHolder>::Invoke( dispid, riid, lcid, wFlags, pdispParams, pvarResult, pexcepInfo, puArgErr );
		return S_OK;
	}

// IVCPropertyContainer
public:
	STDMETHOD(HasDefaultValue)( DISPID dispid, BOOL *pfDefault)
	{
		CHECK_POINTER_NULL(pfDefault);
		*pfDefault = TRUE;
		return S_OK;
	}
	STDMETHOD(Commit)()
	{
		CComVariant varNewConfigType;
		if (GetLocalProp(VCCFGID_ConfigurationType, &varNewConfigType) == S_OK)
		{
			CComVariant varOldConfigType;
			if (GetParentProp(VCCFGID_ConfigurationType, VARIANT_TRUE /* allow inherit */, &varOldConfigType) != S_OK)
				varOldConfigType = typeApplication;
			if (varNewConfigType != varOldConfigType)	// fastest check is to see if they're the same...
			{
				toolSetType oldToolSet = CStyleSheetBase::DetermineBaseType((ConfigurationTypes)varOldConfigType.lVal);
				toolSetType newToolSet = CStyleSheetBase::DetermineBaseType((ConfigurationTypes)varNewConfigType.lVal);
				if (oldToolSet != newToolSet)
					CVCProjectEngine::DoUpdateAfterApply();
			}
		}

		return CPageObjectImpl<T, VCCONFIGURATION_MIN_DISPID, VCCONFIGURATION_MAX_DISPID>::Commit();
	}
};

/////////////////////////////////////////////////////////////////////////////
// CVCGeneralConfigSettingsObject

class ATL_NO_VTABLE CVCProjConfigSettingsPage :
	public CVCConfigSettingsPageBase<CVCProjConfigSettingsPage, IVCProjectConfigurationSettings>,
	public ICategorizeProperties
{
public:

BEGIN_COM_MAP(CVCProjConfigSettingsPage)
	COM_INTERFACE_ENTRY(IPerPropertyBrowsing)
	COM_INTERFACE_ENTRY(IVsPerPropertyBrowsing)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IVCProjectConfigurationSettings)
	COM_INTERFACE_ENTRY(IVCPropertyContainer)
	COM_INTERFACE_ENTRY_IID(IID_ICategorizeProperties, ICategorizeProperties)
END_COM_MAP()


// IVCProjectConfigurationSettings
public:
	STDMETHOD(get_OutputDirectory)(BSTR *pVal);
	STDMETHOD(put_OutputDirectory)(BSTR newVal);
	STDMETHOD(get_IntermediateDirectory)(BSTR *pVal);
	STDMETHOD(put_IntermediateDirectory)(BSTR newVal);
	STDMETHOD(get_DeleteExtensionsOnClean)(BSTR* pbstrExt);	// wildcard extension list to delete on clean/rebuild from within the intermediate directory
	STDMETHOD(put_DeleteExtensionsOnClean)(BSTR bstrExt);
	STDMETHOD(get_ConfigurationType)(ConfigurationTypes* pconfigType);		// configuration type: application, DLL, etc.
	STDMETHOD(put_ConfigurationType)(ConfigurationTypes configType);
	STDMETHOD(get_BuildBrowserInformation)(VARIANT_BOOL* pbBsc);	// build .bsc file
	STDMETHOD(put_BuildBrowserInformation)(VARIANT_BOOL bBsc);
	STDMETHOD(get_UseOfMFC)(useOfMfc* useMfc);	// how are we using MFC?
	STDMETHOD(put_UseOfMFC)(useOfMfc useMfc);
	STDMETHOD(get_UseOfATL)(useOfATL* useATL);	// how are we using ATL?
	STDMETHOD(put_UseOfATL)(useOfATL useATL);
	STDMETHOD(get_ATLMinimizesCRunTimeLibraryUsage)(VARIANT_BOOL* pbUseCRT);	// does the user want to link with the static or dynamic CRT?
	STDMETHOD(put_ATLMinimizesCRunTimeLibraryUsage)(VARIANT_BOOL bUseCRT);
	STDMETHOD(get_CharacterSet)(charSet* poptSetting);	// character set to use: Unicode, MBCS, default
	STDMETHOD(put_CharacterSet)(charSet optSetting);
	STDMETHOD(get_ManagedExtensions)(VARIANT_BOOL* bManaged);	// is this a managed C++ extensions project?
	STDMETHOD(put_ManagedExtensions)(VARIANT_BOOL bManaged);
	STDMETHOD(get_WholeProgramOptimization)(VARIANT_BOOL* pbOptimized);	// perform whole program optimization on build; more or less requires optimization turned on to be effective
	STDMETHOD(put_WholeProgramOptimization)(VARIANT_BOOL bOptimize);

// ICategorizeProperties
public:
	STDMETHOD(MapPropertyToCategory)( DISPID dispid, PROPCAT* ppropcat);
	STDMETHOD(GetCategoryName)( PROPCAT propcat, LCID lcid, BSTR* pbstrName);

// IVCPropertyContainer
public:
	STDMETHOD(Commit)();
	virtual void GetBaseDefault(long id, CComVariant& varValue);

// helpers
protected:
	virtual BOOL SupportsMultiLine(long id) { return (id == VCCFGID_DeleteExtensionsOnClean); }
};

class ATL_NO_VTABLE CVCGeneralMakefileSettingsPage :
	public CVCConfigSettingsPageBase<CVCGeneralMakefileSettingsPage, IVCGeneralMakefileSettings>
{
public:

BEGIN_COM_MAP(CVCGeneralMakefileSettingsPage)
	COM_INTERFACE_ENTRY(IPerPropertyBrowsing)
	COM_INTERFACE_ENTRY(IVsPerPropertyBrowsing)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IVCGeneralMakefileSettings)
	COM_INTERFACE_ENTRY(IVCPropertyContainer)
END_COM_MAP()

// IVCProjectConfigurationSettings
public:
	STDMETHOD(get_ConfigurationType)(ConfigurationTypes* pconfigType);		// configuration type: application, DLL, etc.
	STDMETHOD(put_ConfigurationType)(ConfigurationTypes configType);
};


class CGeneralConfigSettingsPage :
	public CSettingsPageBase<CGeneralConfigSettingsPage, &CLSID_GeneralConfigSettingsPage, IDS_GeneralConfigSettings, 0>
{
public:
	CGeneralConfigSettingsPage() {}
// IVSPropertyPage
    STDMETHOD(get_CategoryTitle)( UINT iLevel, BSTR *pbstrCategory )
	{ return S_FALSE; }

protected:
	virtual void DoCreatePageObject(UINT i, IDispatch* pDisp, IVCPropertyContainer* pLiveContainer, IVCSettingsPage* pPage)
	{
		ConfigurationTypes configType = typeUnknown;
		pLiveContainer->GetIntProperty(VCCFGID_ConfigurationType, (long*)&configType);
		if( configType != typeUnknown )
		{
			CPageObjectImpl<CVCProjConfigSettingsPage,VCCONFIGURATION_MIN_DISPID,VCCONFIGURATION_MAX_DISPID>::CreateInstance(&m_ppUnkArray[i], pLiveContainer, pPage);
		}
		else
		{
			CPageObjectImpl<CVCGeneralMakefileSettingsPage,VCCONFIGURATION_MIN_DISPID,VCCONFIGURATION_MAX_DISPID>::CreateInstance(&m_ppUnkArray[i], pLiveContainer, pPage);
		}
	}
};


/////////////////////////////////////////////////////////////////////////////
// CBldDummyGenCfg

class CBldDummyGenCfg : 
	public CComObjectRoot,
	public IVCGenericConfiguration
{
public:
	CBldDummyGenCfg() {}
	~CBldDummyGenCfg() {}
	void Initialize(VCConfiguration *pCfg);
	static HRESULT CreateInstance(CBldDummyGenCfg** ppDummyCfg, VCConfiguration* pCfg);

BEGIN_COM_MAP(CBldDummyGenCfg)
	COM_INTERFACE_ENTRY(IVCGenericConfiguration)
END_COM_MAP()
DECLARE_NOT_AGGREGATABLE(CBldDummyGenCfg) 

// IVCGenericConfiguration
public:
	STDMETHOD(InformBuildBegin)();
	STDMETHOD(InformBuildEnd)(BOOL fOK);
	STDMETHOD(StartAutomationBuild)(bldActionTypes bldType);
	STDMETHOD(StartFileBuild)(ULONG celt, VCFile* pFile[]);
	STDMETHOD(SupportsBuildType)(bldActionTypes buildType, VARIANT_BOOL* pbSupports, VARIANT_BOOL* pbAvailable);
	STDMETHOD(get_NoBuildIsInProgress)(BOOL* pbNoneInProgress);	// no build currently in progress

// CBldDummyGenCfg
public:
	HRESULT DoStartBuild(bldActionTypes bldType, VCFile* pFile[] = NULL, ULONG celtFiles = 0);

// variables
protected:	
	CComPtr<VCConfiguration> m_spConfig;		// the 'real' configuration to build
	CComPtr<IVCBuildThread> m_spBuildThread;	// thread for building
	CComPtr<IVCBuildEngine> m_spBuildEngine;
};

#endif // !defined(AFX_CONFIGURATION_H__A54AAE82_30C2_11D3_87BF_A04A4CC10000__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\vcpb\configrecords.h ===
#pragma once

#include <vccolls.h>
#include "FileRegistry.h"

// classes in this header
class CBldRecord;
	class CBldSolutionRecord;
	class CBldProjectRecord;
	class CBldCfgRecord;
class CBldConfigurationHolder;
class CBldConfigCacheEnabler;

class CBldRecord
{
public:
	CBldRecord(CBldRecord* pParentRecord, IDispatch* pChild);
	virtual ~CBldRecord();

	enum bldRecordType 
	{ 
		bldRecordUnknown, 
		bldRecordSolution, 
		bldRecordProject, 
		bldRecordCfg 
	};
	virtual bldRecordType GetRecordType() { return bldRecordUnknown; }
	virtual CVCMapPtrToPtr* GetPtrRecordMap() { return &m_pChildPtrRecordMap; }
	virtual CBldRecord* GetChildRecord(IDispatch* pChild, BOOL bCreateIfNeeded = TRUE);
	virtual CBldRecord* AddChildRecord(IDispatch* pChild);
	virtual void RemoveChildRecord(IDispatch* pChild);
	virtual IDispatch* GetCurrentObject() { return m_pCurrentObject; }	// warning: not ref-counted
	virtual CBldRecord* GetParentRecord() { return m_pParentRecord; }
	void Close();

protected:
	virtual CBldRecord* CreateChildRecord(IDispatch* pChild) { VSASSERT(FALSE, "CreateChildRecord must be overridden"); return NULL; }

protected:
	CVCMapPtrToPtr m_pChildPtrRecordMap;
	IDispatch* m_pCurrentObject;
	CBldRecord* m_pParentRecord;
};

class CBldSolutionRecord : public CBldRecord
{
public:
	CBldSolutionRecord() : CBldRecord(NULL, NULL) {}
	virtual ~CBldSolutionRecord() {}
	virtual bldRecordType GetRecordType() { return bldRecordSolution; }
	CBldProjectRecord* GetProjectRecord(IDispatch* pProject, BOOL bCreateIfNeeded = TRUE);
	CBldCfgRecord* GetCfgRecord(IDispatch* pProject, IDispatch* pCfg, BOOL bCreateIfNeeded = TRUE);
	void RemoveProjectRecord(IDispatch* pProject);
	void RemoveCfgRecord(IDispatch* pProject, IDispatch* pCfg);

protected:
	virtual CBldRecord* CreateChildRecord(IDispatch* pChild);
};

class CBldProjectRecord : public CBldRecord
{
public:
	CBldProjectRecord(CBldRecord* pSolutionRecord, IDispatch* pProject);
	virtual ~CBldProjectRecord() {}
	virtual bldRecordType GetRecordType() { return bldRecordProject; }
	CBldSolutionRecord* GetSolutionRecord();
	CBldCfgRecord* GetCfgRecord(IDispatch* pCfg, BOOL bCreateIfNeeded = TRUE);
	void RemoveCfgRecord(IDispatch* pCfg);

	VCProject* GetVCProject() { return m_pVCProject; }	// warning: not ref-counted

protected:
	virtual CBldRecord* CreateChildRecord(IDispatch* pChild);

protected:
	CComQIPtr<VCProject> m_pVCProject;
};

class CBldCfgRecord : public CBldRecord
{
public:
	CBldCfgRecord(CBldRecord* pProjectRecord, IDispatch* pConfig);
	virtual ~CBldCfgRecord() {}
	virtual bldRecordType GetRecordType() { return bldRecordCfg; }
	CBldSolutionRecord* GetSolutionRecord();
	CBldProjectRecord* GetProjectRecord();
	VCProject* GetVCProject();	// warning: not ref-counted

	VCConfiguration* GetVCConfiguration() { return m_pVCConfiguration; }		// warning: not ref-counted
	CVCPtrList* GetBaseToolList();

	// To turn caching on and off for all config record.  Begin cache
	// only if you know that nobody is setting any properties anywhere
	// (e.g. during build):
	static void	BeginConfigCache();
	static void EndConfigCache();

protected:
	CComQIPtr<VCConfiguration> m_pVCConfiguration;

private:
	static DWORD s_nSignature;
	static int s_nCongfigCacheCount;
};

class CBldConfigurationHolder
{
public:
	CBldConfigurationHolder(CBldCfgRecord* pcr, VCFileConfiguration* pFileCfg, VCConfiguration* pProjCfg);
	BldFileRegHandle GetFileRegHandle();
	void GetActionList(IVCBuildActionList** ppActions, BOOL bFileLevel = TRUE);
	VCFileConfiguration* GetFileCfg() { return m_pFileCfg; }
	VCConfiguration* GetProjCfg() { return m_pProjCfg; }
	CVCPtrList* GetToolList() { return m_pcr->GetBaseToolList(); }
	BOOL IsProject() { return m_bIsProject; }
	CBldCfgRecord* GetPCR() { return m_pcr; }

protected:
	CBldCfgRecord* m_pcr;
	VCFileConfiguration* m_pFileCfg;
	VCConfiguration* m_pProjCfg;
	BOOL m_bIsProject;
};

// Helper object for config caching.  Garentees it will be reanbled
// when object goes out of scope:
class CBldConfigCacheEnabler
{
	BOOL	m_bDidEnable;
public:
	CBldConfigCacheEnabler()  
	{
		m_bDidEnable = TRUE;
		CBldCfgRecord::BeginConfigCache();
	};
	~CBldConfigCacheEnabler() 
	{
		if (m_bDidEnable)
			CBldCfgRecord::EndConfigCache();
	};
	void EndCacheNow()
	{
		if (m_bDidEnable) 
		{
			CBldCfgRecord::EndConfigCache();
			m_bDidEnable = FALSE;
		}
	};
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\vcpb\configrecords.cpp ===
#include "stdafx.h"
#include "ConfigRecords.h"
#include "BuildEngine.h"

CBldRecord::CBldRecord(CBldRecord* pParentRecord, IDispatch* pCurrent)
{
	m_pParentRecord = pParentRecord;
	if (pCurrent)
		m_pCurrentObject = pCurrent;
}

CBldRecord::~CBldRecord()
{
	Close();
}

void CBldRecord::Close()
{
	VCPOSITION pos = m_pChildPtrRecordMap.GetStartPosition();
	while (pos != NULL)
	{
		CBldRecord* pChildRecord;
		IDispatch* pChildObject;
		m_pChildPtrRecordMap.GetNextAssoc(pos, (void *&)pChildObject, (void *&)pChildRecord);
		delete pChildRecord;
	}
	m_pChildPtrRecordMap.RemoveAll();
}

CBldRecord* CBldRecord::GetChildRecord(IDispatch* pChild, BOOL bCreateIfNeeded /* = TRUE */)
{
	CBldRecord* pChildRecord = NULL;
	if (m_pChildPtrRecordMap.Lookup((void *)pChild, (void*&)pChildRecord) && pChildRecord)
		return pChildRecord;

	if (!bCreateIfNeeded)
		return NULL;

	return AddChildRecord(pChild);
}

CBldRecord* CBldRecord::AddChildRecord(IDispatch* pChild)
{
	VSASSERT(pChild != NULL, "Do not add NULL child record to BldRecord.  Bad programmer, bad programmer.");
	RETURN_ON_NULL2(pChild, NULL);

	CBldRecord* pChildRecord = NULL;

	VSASSERT(!m_pChildPtrRecordMap.Lookup((void *)pChild, (void*&)pChildRecord), "Do not try to add same child record to BldRecord twice.");

	pChildRecord = CreateChildRecord(pChild);
	if (pChildRecord == NULL)
	{
		VSASSERT(FALSE, "Failed to create child record for BldRecord");
		return NULL;
	}

	m_pChildPtrRecordMap.SetAt((void *)pChild, (void *&)pChildRecord);

	return pChildRecord;
}

void CBldRecord::RemoveChildRecord(IDispatch* pChild)
{
	VSASSERT(pChild, "Must specify child to remove.  NULL not valid.");
	if (pChild == NULL)
		return;

	CBldRecord* pChildRecord = NULL;
	if (!m_pChildPtrRecordMap.Lookup((void *)pChild, (void *&)pChildRecord) || !pChildRecord)
		return;		// nothing to do

	delete pChildRecord;
	m_pChildPtrRecordMap.RemoveKey(pChild);
}

CBldProjectRecord* CBldSolutionRecord::GetProjectRecord(IDispatch* pProject, BOOL bCreateIfNeeded /* = TRUE */) 
{ 
	return (CBldProjectRecord*)GetChildRecord(pProject, bCreateIfNeeded); 
}

CBldCfgRecord* CBldSolutionRecord::GetCfgRecord(IDispatch* pProject, IDispatch* pCfg, BOOL bCreateIfNeeded /* = TRUE */)
{
	CBldProjectRecord* pProjectRecord = GetProjectRecord(pProject, bCreateIfNeeded);
	RETURN_ON_NULL2(pProjectRecord, NULL);

	return (CBldCfgRecord*)(pProjectRecord->GetChildRecord(pCfg, bCreateIfNeeded)); 
}

CBldRecord* CBldSolutionRecord::CreateChildRecord(IDispatch* pChild)
{
	return new CBldProjectRecord(this, pChild);
}

void CBldSolutionRecord::RemoveProjectRecord(IDispatch* pProject)
{
	RemoveChildRecord(pProject);
}
void CBldSolutionRecord::RemoveCfgRecord(IDispatch* pProject, IDispatch* pCfg)
{
	CBldProjectRecord* pProjectRecord = GetProjectRecord(pProject, FALSE);
	if (pProjectRecord == NULL)
		return;

	pProjectRecord->RemoveCfgRecord(pCfg);
}

CBldProjectRecord::CBldProjectRecord(CBldRecord* pSolutionRecord, IDispatch* pProject) 
	: CBldRecord(pSolutionRecord, pProject)
{
	VSASSERT(pSolutionRecord && pProject, "Cannot create a ProjectRecord without valid solution and project info");
	m_pVCProject = pProject;
}

CBldRecord* CBldProjectRecord::CreateChildRecord(IDispatch* pChild)
{
	return new CBldCfgRecord(this, pChild);
}

CBldSolutionRecord* CBldProjectRecord::GetSolutionRecord()
{ 
	return (CBldSolutionRecord*)GetParentRecord();
}

CBldCfgRecord* CBldProjectRecord::GetCfgRecord(IDispatch* pCfg, BOOL bCreateIfNeeded /* = TRUE */)
{ 
	return (CBldCfgRecord*)(GetChildRecord(pCfg, bCreateIfNeeded)); 
}

void CBldProjectRecord::RemoveCfgRecord(IDispatch* pCfg)
{
	RemoveChildRecord(pCfg);
}

DWORD CBldCfgRecord::s_nSignature = 0;
int CBldCfgRecord::s_nCongfigCacheCount = 0;

CBldCfgRecord::CBldCfgRecord(CBldRecord* pProjectRecord, IDispatch* pCfg)
	: CBldRecord(pProjectRecord, pCfg)
{
	VSASSERT(pProjectRecord && pCfg, "Cannot create a CfgRecord without a valid ProjectRecord and config");
	m_pVCConfiguration = pCfg;
}

CBldSolutionRecord* CBldCfgRecord::GetSolutionRecord()
{ 
	return ((CBldProjectRecord*)GetParentRecord())->GetSolutionRecord();
}

CBldProjectRecord* CBldCfgRecord::GetProjectRecord()
{ 
	return (CBldProjectRecord*)GetParentRecord(); 
}

CVCPtrList* CBldCfgRecord::GetBaseToolList()
{
	CComQIPtr<IVCConfigurationImpl> spProjCfgImpl = m_pVCConfiguration;
	CVCPtrList* pPtrList = NULL;
	if ((spProjCfgImpl == NULL) || FAILED(spProjCfgImpl->get_BaseToolList((void **)&pPtrList)))
	{
		VSASSERT(FALSE, "Failed to get base tool list in CfgRecord.  Deep trouble.");
		pPtrList = NULL;
	}
	return pPtrList;
}

VCProject* CBldCfgRecord::GetVCProject()	// warning: not ref-counted
{
	CBldProjectRecord* pProjRecord = GetProjectRecord();
	VSASSERT(pProjRecord != NULL, "Managed to create a CfgRecord without a valid ProjectRecord.  Bad program, bad program.");
	RETURN_ON_NULL2(pProjRecord, NULL);

	return pProjRecord->GetVCProject();
}

void CBldCfgRecord::BeginConfigCache()
{
	if (s_nCongfigCacheCount == 0) s_nSignature++;
	s_nCongfigCacheCount++;

}
void CBldCfgRecord::EndConfigCache()
{
	s_nCongfigCacheCount--;
}
	  
CBldConfigurationHolder::CBldConfigurationHolder(CBldCfgRecord* pcr, VCFileConfiguration* pFileCfg, 
	VCConfiguration* pProjCfg)
{
	m_pcr = pcr;
	m_pFileCfg = pFileCfg;
	m_pProjCfg = pProjCfg;
	m_bIsProject = (m_pFileCfg == NULL);
}

BldFileRegHandle CBldConfigurationHolder::GetFileRegHandle()
{
	BldFileRegHandle frh;

	CComQIPtr<IVCBuildableItem> spBuildableItem;
	if (m_pFileCfg == NULL)
		spBuildableItem = m_pProjCfg;
	else
		spBuildableItem = m_pFileCfg;
	VSASSERT(spBuildableItem != NULL, "Managed to create a ConfigurationHolder without a valid item to attach it to.");
	RETURN_ON_NULL2(spBuildableItem, NULL);

	spBuildableItem->get_FileRegHandle((void **)&frh);
	return frh;
}

void CBldConfigurationHolder::GetActionList(IVCBuildActionList** ppActions, BOOL bFileLevel /* = FALSE */)
{
	CComQIPtr<IVCBuildableItem> spBuildableItem;
	if (m_pFileCfg == NULL)
		spBuildableItem = m_pProjCfg;
	else
		spBuildableItem = m_pFileCfg;
	VSASSERT(spBuildableItem != NULL, "Managed to create a ConfigurationHolder without a valid item to attach it to.");
	if (spBuildableItem == NULL)
		return;

	*ppActions = NULL;
	spBuildableItem->get_ActionList(ppActions);
	VSASSERT(*ppActions != NULL, "No action list associated with the ConfigurationHolder's item.  Bad initialization of the action.");
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\vcpb\custombuildtool.cpp ===
// CustomBuildTool.cpp : Implementation of CVCCustomBuildTool and CVCCustomBuildToolShadow

#include "stdafx.h"
#include "CustomBuildTool.h"
#include "FileRegistry.h"
#include "BldHelpers.h"
#include "BldActions.h"
#include "ProjWriter.h"

#include "DTE.h"
#include "ProjBld2.h"


// constants
const wchar_t* const wszCustomBldDefaultExtensions = L"*.bat";	// remember to update vcpb.rgs if you change this...

// init statics
GUID CVCCustomBuildTool::s_pPages[1];
BOOL CVCCustomBuildTool::s_bPagesInit = FALSE;
CComBSTR CVCCustomBuildTool::s_bstrDescription = L"";
CComBSTR CVCCustomBuildTool::s_bstrToolName = L"";
CComBSTR CVCCustomBuildTool::s_bstrExtensions = L"";

#define PLACEHOLDER_OUTPUT L"somethingthatwillneverexist.junk"

//////////////////////////////////////////////////////////////////////////////
// implementation of CVCCustomBuildTool; behavior specific to custom build rules with storage

LPCOLESTR CVCCustomBuildTool::GetToolFriendlyName()
{
	InitToolName();
	return s_bstrToolName;
}

void CVCCustomBuildTool::InitToolName()
{
	if (s_bstrToolName.Length() == 0)
	{
		if (!s_bstrToolName.LoadString(IDS_CUSTOM_TOOLNAME))
			s_bstrToolName = szCustomBuildToolType;
	}
}

HRESULT CVCCustomBuildTool::CreateInstance(IVCPropertyContainer* pPropContainer, IVCToolImpl** ppTool)
{
	CHECK_POINTER_NULL(ppTool);
	*ppTool = NULL;

	CComObject<CVCCustomBuildTool> *pObj;
	HRESULT hr = CComObject<CVCCustomBuildTool>::CreateInstance(&pObj);
	if (SUCCEEDED(hr))
	{
		if( pPropContainer )
			pObj->Initialize(pPropContainer);
		CVCCustomBuildTool *pVar = pObj;
		pVar->AddRef();
		*ppTool = pVar;
	}
	return hr;
}

void CVCCustomBuildTool::Initialize(IVCPropertyContainer* pPropContainer)
{
	CVCToolImpl::Initialize(pPropContainer);
	CComQIPtr<VCFileConfiguration> spFileCfg = pPropContainer;
	if (spFileCfg == NULL)
		m_nOffset = 0;	// we're on the project configuration
	else
		m_nOffset = VCCUSTID_FileLevelOffset;	// we're on a file configuration

	m_nLowKey = VCCUSTID_CommandLine + m_nOffset;
	m_nHighKey = VCCUSTID_AdditionalDependencies + m_nOffset;
	m_nDirtyKey = VCCUSTID_CmdLineOptionsDirty + m_nOffset;
	m_nDirtyOutputsKey = VCCUSTID_OutputsDirty + m_nOffset;
}

STDMETHODIMP CVCCustomBuildTool::get_ToolName(BSTR* pbstrToolName)	// friendly name of tool, e.g., "C/C++ Compiler Tool"
{
	CHECK_POINTER_VALID(pbstrToolName);
	InitToolName();
	s_bstrToolName.CopyTo(pbstrToolName);
	return S_OK;
}

STDMETHODIMP CVCCustomBuildTool::get_CommandLine(BSTR *pbstrCommandLine)
{
	CHECK_ZOMBIE( m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE );
	CHECK_POINTER_VALID( pbstrCommandLine );

	HRESULT hr = m_spPropertyContainer->GetStrProperty(VCCUSTID_CommandLine + m_nOffset, pbstrCommandLine);
	if (hr == S_FALSE)
		COptionHandlerBase::GetDefaultString( pbstrCommandLine );
	return hr;
}

STDMETHODIMP CVCCustomBuildTool::put_CommandLine(BSTR bstrCommandLine)
{
	CHECK_ZOMBIE( m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE );

	// grab each line and strip leading/trailing whitespace from it
	CStringW strCommandLine = bstrCommandLine;
	CStringW strLine, strNewCommandLine;
	int length = strCommandLine.GetLength();
	int left = 0;
	int right;
	while( true )
	{
		// find the next newline
		right = strCommandLine.Find( L'\n', left );
		// if we couldn't find one
		if( right == -1 )
		{
			// if we're at the end of the cmd line, we're done	
			if( left >= length )
				break;
			// otherwise this is the last line
			else
				right = length;
		}

		// grab this portion (logical line) of the cmd line
		strLine = strCommandLine.Mid( left, right - left );
		// trim the leading/trailing whitespace
		strLine.TrimLeft();
		strLine.TrimRight();
		// append it to the new command line
		strNewCommandLine += strLine;
		strNewCommandLine += L"\r\n";
		// move along to the next logical line
		left = right + 1;
	}
	if( strNewCommandLine.IsEmpty() )
		strNewCommandLine = strCommandLine;
	
	return m_spPropertyContainer->SetStrProperty(VCCUSTID_CommandLine + m_nOffset, CComBSTR( strNewCommandLine ) );
}

STDMETHODIMP CVCCustomBuildTool::get_Description(BSTR *pbstrDescription)
{
	CHECK_ZOMBIE( m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE );
	CHECK_POINTER_VALID( pbstrDescription );

	HRESULT hr = m_spPropertyContainer->GetStrProperty(VCCUSTID_Description + m_nOffset, pbstrDescription);
	if (hr == S_FALSE)
 		SGetDescription(pbstrDescription);
	return hr;
}

STDMETHODIMP CVCCustomBuildTool::put_Description(BSTR bstrDescription)
{
	CHECK_ZOMBIE( m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE );
	return m_spPropertyContainer->SetStrProperty(VCCUSTID_Description + m_nOffset, bstrDescription);
}

STDMETHODIMP CVCCustomBuildTool::get_Outputs(BSTR *pbstrOutputs)
{
	CHECK_ZOMBIE( m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE );
	CHECK_POINTER_VALID( pbstrOutputs );

	HRESULT hr = m_spPropertyContainer->GetStrProperty(VCCUSTID_Outputs + m_nOffset, pbstrOutputs);
	if (hr == S_FALSE)
		COptionHandlerBase::GetDefaultString( pbstrOutputs );
	return hr;
}

STDMETHODIMP CVCCustomBuildTool::put_Outputs(BSTR bstrOutputs)
{
	CHECK_ZOMBIE( m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE );
	return m_spPropertyContainer->SetStrProperty(VCCUSTID_Outputs + m_nOffset, bstrOutputs);
}

STDMETHODIMP CVCCustomBuildTool::get_AdditionalDependencies(BSTR *pbstrAdditionalDependencies)
{
	CHECK_ZOMBIE( m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE );
	CHECK_POINTER_VALID( pbstrAdditionalDependencies );

	HRESULT hr = m_spPropertyContainer->GetStrProperty(VCCUSTID_AdditionalDependencies + m_nOffset, pbstrAdditionalDependencies);
	if (hr == S_FALSE)
		COptionHandlerBase::GetDefaultString( pbstrAdditionalDependencies );
	return hr;
}

STDMETHODIMP CVCCustomBuildTool::put_AdditionalDependencies(BSTR bstrAdditionalDependencies)
{
	CHECK_ZOMBIE( m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE );
	return m_spPropertyContainer->SetStrProperty(VCCUSTID_AdditionalDependencies + m_nOffset, bstrAdditionalDependencies);
}

// Automation properties
STDMETHODIMP CVCCustomBuildTool::get_ToolPath(BSTR *pbstrToolPath)
{
	*pbstrToolPath = SysAllocString( szCustomBuildToolPath );
	return S_OK;
}


// IVCToolImpl
STDMETHODIMP CVCCustomBuildTool::get_DefaultExtensions(BSTR* pVal)
{
	return DoGetDefaultExtensions(s_bstrExtensions, wszCustomBldDefaultExtensions, pVal);
}

STDMETHODIMP CVCCustomBuildTool::put_DefaultExtensions(BSTR newVal)
{
	s_bstrExtensions = newVal;
	return S_OK;
}

STDMETHODIMP CVCCustomBuildTool::GetAdditionalOptionsInternal(IUnknown* pItem, VARIANT_BOOL bForBuild, VARIANT_BOOL bSkipLocal, 
	BSTR* pbstrOptions)
{ 
	return E_NOTIMPL;	// don't have any; but don't want assert
}

STDMETHODIMP CVCCustomBuildTool::GetBuildDescription(IVCBuildAction* pAction, BSTR* pbstrBuildDescription)
{
	CHECK_POINTER_NULL( pbstrBuildDescription );

	if (pAction == NULL)
		return SGetDescription( pbstrBuildDescription );

	CComPtr<IVCPropertyContainer> spPropContainer;
	pAction->get_PropertyContainer(&spPropContainer);
	if (spPropContainer == NULL)
		return SGetDescription( pbstrBuildDescription );

	CComQIPtr<VCFileConfiguration> spFileCfg = spPropContainer;
	int nOffset = 0;
	if (spFileCfg)
		nOffset = VCCUSTID_FileLevelOffset;	// we're on a file configuration

	CComBSTR bstrDesc;
	HRESULT hr = spPropContainer->GetStrProperty(VCCUSTID_Description + nOffset, &bstrDesc);
	if (hr == S_FALSE)
		SGetDescription( &bstrDesc );
	RETURN_ON_FAIL(hr);

	HRESULT hr2 = spPropContainer->Evaluate(bstrDesc, pbstrBuildDescription);
	RETURN_ON_FAIL(hr2);
	return hr;
}

STDMETHODIMP CVCCustomBuildTool::get_ToolPathInternal(BSTR* pbstrToolPath)
{ 
	return get_ToolPath(pbstrToolPath);
}

STDMETHODIMP CVCCustomBuildTool::get_Bucket(long *pVal)
{
	CHECK_POINTER_NULL(pVal);
	*pVal = BUCKET_CUSTOMBUILD;
	return S_OK;
}

STDMETHODIMP CVCCustomBuildTool::IsTargetTool(IVCBuildAction* pAction, VARIANT_BOOL* pbIsTargetTool)
{
	CHECK_POINTER_NULL(pbIsTargetTool);
	*pbIsTargetTool = VARIANT_TRUE;	// by default, this is a target tool

	if (pAction != NULL)
	{
		CComPtr<IVCBuildableItem> spItem;
		if (SUCCEEDED(pAction->get_Item(&spItem)) && spItem != NULL)
		{
			CComQIPtr<VCFileConfiguration> spFileCfg = spItem;
			if (spFileCfg!= NULL)	// operating on a file
				*pbIsTargetTool = VARIANT_FALSE;
		}
	}	

	return S_OK;
}

STDMETHODIMP CVCCustomBuildTool::CreateToolObject(IVCPropertyContainer* pPropContainer, IVCToolImpl** ppToolObject)
{ 
	return CreateInstance(pPropContainer, ppToolObject); 
}

STDMETHODIMP CVCCustomBuildTool::get_ToolShortName(BSTR* pbstrToolName)
{
	*pbstrToolName = SysAllocString( szCustomBuildToolShortName );
	return S_OK;
}

STDMETHODIMP CVCCustomBuildTool::MatchName(BSTR bstrName, VARIANT_BOOL bFullOnly, VARIANT_BOOL* pbMatches)
{
	return DoMatchName(bstrName, szCustomBuildToolType, szCustomBuildToolShortName, pbMatches);
}

STDMETHODIMP CVCCustomBuildTool::get_IsComspecTool(VARIANT_BOOL* pbIsComspecTool)
{
	return COptionHandlerBase::GetValueTrue(pbIsComspecTool);
}

STDMETHODIMP CVCCustomBuildTool::get_ToolDisplayIndex(long* pIndex)
{
	CHECK_POINTER_NULL(pIndex);
	*pIndex = TOOL_DISPLAY_INDEX_CUSTBLD;
	return S_OK;
}

STDMETHODIMP CVCCustomBuildTool::GenerateOutput(long type, IVCBuildActionList* pActions, IVCBuildErrorContext* pEC)
{
	RETURN_ON_NULL2(pActions, S_FALSE);

	pActions->Reset(NULL);
	while (TRUE)
	{
		CComPtr<IVCBuildAction> spAction;
		HRESULT hr = pActions->Next(&spAction, NULL);
		BREAK_ON_DONE(hr);
		if (spAction == NULL)
			continue;

		CComPtr<IVCPropertyContainer> spPropContainer;
		spAction->get_PropertyContainer(&spPropContainer);
		VSASSERT(spPropContainer != NULL, "No property container associated with action.  Bad action initialization.");
		if (spPropContainer == NULL)
			continue;

		if (IsExcludedFromBuild(spPropContainer))
			continue;	// nothing to do for things excluded from build...

		int nOffset = 0;
		CComQIPtr<VCFileConfiguration> spFileCfg = spPropContainer;
		if (spFileCfg != NULL)
			nOffset = VCCUSTID_FileLevelOffset;

		CComBSTR bstrCommand;
		if (spPropContainer->GetEvaluatedStrProperty(VCCUSTID_CommandLine+nOffset, &bstrCommand) != S_OK)
		{
			spAction->ClearSourceDependencies(pEC);
			continue;	// no command, then outputs mean nothing
		}
		CStringW strCommand = bstrCommand;
		strCommand.TrimLeft();
		strCommand.TrimRight();
		if (strCommand.IsEmpty())
		{
			spAction->ClearSourceDependencies(pEC);
			continue;	// no command, then outputs mean nothing
		}

		CComBSTR bstrOutput;
		spPropContainer->GetStrProperty(VCCUSTID_Outputs+nOffset, &bstrOutput);

		CStringW strOutput = bstrOutput;
		strOutput.TrimLeft();
		strOutput.TrimRight();
		if (strOutput.IsEmpty())
			strOutput = PLACEHOLDER_OUTPUT;

		CBldFileRegistry* pRegistry = NULL;
		spAction->get_Registry((void **)&pRegistry);

		// get the project directory
		CComBSTR bstrProjectDir;
		spPropContainer->GetStrProperty(VCPROJID_ProjectDirectory, &bstrProjectDir);	// should never have macros in it
		CStringW strProjectDir = bstrProjectDir;
		int nLen = strProjectDir.GetLength();
		if (nLen > 0 && (strProjectDir[nLen-1] == L'\\' || strProjectDir[nLen-1] == L'/'))
			strProjectDir = strProjectDir.Left(nLen-1);

		// generate our output in the context of the project directory
		CDirW dirProj;
		dirProj.CreateFromKnown(strProjectDir);

		// process each of our output specs.
		CBldOptionList lstOutSpec(L';', FALSE, TRUE);
		lstOutSpec.SetString((const wchar_t *)strOutput);
		VCPOSITION pos = lstOutSpec.GetHeadPosition();

		while (pos != (VCPOSITION)NULL)
		{
			const wchar_t* pchOutSpec = lstOutSpec.GetNext(pos);

			// form the output
			CComBSTR bstrOut1 = pchOutSpec;
			CComBSTR bstrOut2;
			spPropContainer->Evaluate(bstrOut1, &bstrOut2);
			CStringW strOutputFile = bstrOut2;

			// create our path given this output string
			CPathW pathOutput;		// path of our output based on this spec.
			if (pathOutput.CreateFromDirAndFilename(dirProj, strOutputFile))
			{
				pathOutput.GetActualCase(TRUE);
				// only filter if not target-level custom build tool
				VARIANT_BOOL bFilter = (nOffset == VCCUSTID_FileLevelOffset) ? VARIANT_TRUE : VARIANT_FALSE;
				if (spAction->AddOutputFromPath((wchar_t *)(const wchar_t *)pathOutput, pEC, VARIANT_TRUE, bFilter, 
					VCCUSTID_Outputs, this) != S_OK)
				{
					VSASSERT(FALSE, "Failed to generate output dependencies for custom build tool");
					AddCustomBuildError(pEC, IDS_ERR_CUST_OUTPUT_FILE_INVALID_PRJ0031, L"PRJ0031", 
						IDS_ERR_CUST_OUTPUT_PROJ_INVALID_PRJ0032, L"PRJ0032", pchOutSpec, strOutputFile, spPropContainer);
					return E_FAIL;
				}
			}
			else
			{
					AddCustomBuildError(pEC, IDS_ERR_CUST_OUTPUT_FILE_INVALID_PRJ0031, L"PRJ0031", 
						IDS_ERR_CUST_OUTPUT_PROJ_INVALID_PRJ0032, L"PRJ0032", pchOutSpec, strOutputFile, spPropContainer);
					return E_FAIL;
			}
		}

		//
		// Add source deps.
		//
		spAction->ClearSourceDependencies(pEC);
		CComBSTR bstrInputs;
		if (spPropContainer->GetStrProperty(VCCUSTID_AdditionalDependencies+nOffset, &bstrInputs) == S_OK)
		{
			CStringW strInputs = bstrInputs;
			CBldOptionList lstInSpec(L';', FALSE, TRUE);
			lstInSpec.SetString((const wchar_t *)strInputs);
			VCPOSITION pos = lstInSpec.GetHeadPosition();

			while (pos != (VCPOSITION)NULL)
			{
				const wchar_t* pchInSpec = lstInSpec.GetNext(pos);

				// form the input
				CComBSTR bstrIn1 = pchInSpec;
				CComBSTR bstrIn2;
				spPropContainer->Evaluate(bstrIn1, &bstrIn2);
				CStringW strInputFile = bstrIn2;

				BldFileRegHandle frh = (BldFileRegHandle)NULL;
				CPathW cpFile;
				if (cpFile.CreateFromDirAndFilename(dirProj, strInputFile))
					frh = CBldFileRegFile::GetFileHandle(cpFile, TRUE);

				if (frh != NULL)
				{
					if (wcsstr(pchInSpec, L"..\\"))
					{
						CBldFileRegFile *pFile = (CBldFileRegFile*)g_FileRegistry.GetRegEntry(frh);
						pFile->SetOrgName(pchInSpec);
						pFile->SetFileNameRelativeToProj();
					}
					BOOL bForceRelativePath = ((pchInSpec[0] == L'.') && (pchInSpec[1] == L'.'));
					if (bForceRelativePath && frh)
						g_FileRegistry.GetRegEntry(frh)->SetRelative(TRUE);

					spAction->AddSourceDependencyFromFrh((void *)frh, pEC);
					frh->ReleaseFRHRef();
				}
				else
					{
							AddCustomBuildError(pEC, IDS_ERR_CUST_INPUT_FILE_INVALID_PRJ0033, L"PRJ0033", 
								IDS_ERR_CUST_INPUT_PROJ_INVALID_PRJ0034, L"PRJ0034", pchInSpec, strInputFile, spPropContainer);
							return E_FAIL;
					}
			}
		}
		// lastly, make sure we get the source dep of the thing we're associated with...
		if (spFileCfg != NULL)
		{
			CComPtr<IDispatch> spDispFile;
			HRESULT hr2 = spFileCfg->get_File(&spDispFile);
			VSASSERT(SUCCEEDED(hr2) && spDispFile != NULL, "No file on file config?  File config probably zombie.");
			if (SUCCEEDED(hr) && spDispFile != NULL)
			{
				CComQIPtr<IVCBuildableItem> spBldableFile = spDispFile;
				VSASSERT(spBldableFile != NULL, "File objects must support IVCBuildableItem interface");
				if (spBldableFile != NULL)
				{
					BldFileRegHandle frh = NULL;
					hr2 = spBldableFile->get_FileRegHandle((void **)&frh);
					VSASSERT(SUCCEEDED(hr2) && frh != NULL, "All files have reg handles.  NULL reg handle means file not added to registry when it was added to the project.");
					if (frh != NULL)
						spAction->AddSourceDependencyFromFrh((void *)frh, pEC);
				}
			}
		}
		else	// project config level
		{
			CComQIPtr<VCConfiguration> spProjCfg = spPropContainer;
			VSASSERT(spProjCfg != NULL, "Custom build step can only be applied to file or project config.  Must be trying to apply it to something else.");
			if (spProjCfg != NULL)
			{
				CComBSTR bstrPrimaryOutput;
				HRESULT hr2 = spProjCfg->get_PrimaryOutput(&bstrPrimaryOutput);
				VSASSERT(SUCCEEDED(hr2) && bstrPrimaryOutput.Length() != 0, "Project config *must* have a primary output.");
				if (SUCCEEDED(hr2))
				{
					hr2 = spAction->AddSourceDependencyFromString(bstrPrimaryOutput, pEC);
					VSASSERT(SUCCEEDED(hr2), "Failed to add source dependency for project config custom build step");
				}
				else
				{
					long nToolID = -1, nErrPropID = -1;
					CComQIPtr<IVCConfigurationImpl> spProjCfgImpl = spProjCfg;
					if (spProjCfgImpl)
					{
						CComPtr<IVCToolImpl> spTool;
						spProjCfgImpl->GetPrimaryOutputFileID(&spTool, &nErrPropID);
						if (nErrPropID > 0)
							InformUserAboutBadFileName(pEC, spPropContainer, nErrPropID, bstrPrimaryOutput);
					}
				}
			}
		}
	}

	return S_OK; // success
}

void CVCCustomBuildTool::AddCustomBuildError(IVCBuildErrorContext* pEC, long idErrFile, BSTR bstrErrNumFile, long idErrProj, 
	BSTR bstrErrNumProj, const wchar_t* szWithMacros, const wchar_t* szNoMacros, IVCPropertyContainer* pPropContainer)
{
	if (pEC == NULL || pPropContainer == NULL)
		return;

	CComQIPtr<VCFileConfiguration> spFileCfg = pPropContainer;
	CStringW strErr;
	if (spFileCfg)
	{
		CComBSTR bstrFileName;
		pPropContainer->GetStrProperty(VCFILEID_Name, &bstrFileName);
		CStringW strFileName = bstrFileName;
		strErr.Format(idErrFile, strFileName, szWithMacros, szNoMacros);
		CVCProjectEngine::AddProjectError(pEC, strErr, bstrErrNumFile, pPropContainer);
	}
	else
	{
		strErr.Format(idErrProj, szWithMacros, szNoMacros);
		CVCProjectEngine::AddProjectError(pEC, strErr, bstrErrNumProj, pPropContainer);
	}
}

STDMETHODIMP CVCCustomBuildTool::GetCommandLineEx(IVCBuildAction* pAction, IVCBuildableItem* pBuildableItem, 
	IVCBuildEngine* pBuildEngine, IVCBuildErrorContext* pEC, BSTR *pVal)
{
	CHECK_POINTER_NULL(pVal);
	*pVal = NULL;

	CComQIPtr<IVCPropertyContainer> spPropContainer = pBuildableItem;
	CHECK_ZOMBIE(spPropContainer, IDS_ERR_TOOL_ZOMBIE);

	CComQIPtr<VCFileConfiguration> spFileCfg = spPropContainer;
	int nOffset = 0;
	if (spFileCfg != NULL)
		nOffset = VCCUSTID_FileLevelOffset;

	HRESULT hr = S_OK;
	CComBSTR bstrCommandLineEnd, bstrOutput;
	if (spPropContainer->GetStrProperty(VCCUSTID_Outputs+nOffset, &bstrOutput) != S_OK || bstrOutput.Length() == 0)
	{
		bstrCommandLineEnd.LoadString(IDS_WARN_NO_CUST_OUTPUT_PRJ0029);
		if (nOffset)	// File level.  Groan.
		{
			CComBSTR bstrFile;
			spPropContainer->GetStrProperty(VCFILEID_Name, &bstrFile);
			bstrFile += L" : ";
			bstrFile = L"echo " + bstrFile;
			bstrFile += bstrCommandLineEnd;
			bstrCommandLineEnd = bstrFile;
		}
		else	// project level
			bstrCommandLineEnd = L"echo Project : " + bstrCommandLineEnd;
	}
	else
	{
		hr = spPropContainer->GetEvaluatedStrProperty(VCCUSTID_CommandLine+nOffset, &bstrCommandLineEnd);
		RETURN_ON_FAIL(hr);
	}

	CComBSTR bstrCmdLine;
	BuildCommandLineBatchFile(pAction, bstrCommandLineEnd, bstrCmdLine);
	
	if (hr != S_OK)
	{
		bstrCmdLine.CopyTo(pVal);
		return S_FALSE;
	}

	if (pBuildEngine == NULL)
		return bstrCmdLine.CopyTo(pVal);

	return pBuildEngine->FormBatchFile(bstrCmdLine, pEC, pVal);
}

STDMETHODIMP CVCCustomBuildTool::SaveObject(IStream *xml, IVCPropertyContainer *pPropContainer, long nIndent)
{
	VSASSERT(pPropContainer, "Property container required when saving tool properties");
	RETURN_INVALID_ON_NULL(pPropContainer);
	
	int nOffset = 0;
	CComQIPtr<VCFileConfiguration> spFileCfg = pPropContainer;
	if (spFileCfg != NULL)
	{
		nOffset = VCCUSTID_FileLevelOffset;
	}

	StartNodeHeader( xml, L"Tool", false );

	// Name
	CComBSTR bstrToolShortName;
	get_ToolShortName(&bstrToolShortName);
	if (bstrToolShortName.Length() > 0)
	{
		NodeAttribute( xml, L"Name", bstrToolShortName ); 					
	}
	AddSaveLine( xml, pPropContainer, L"Description", VCCUSTID_Description+nOffset );
	AddSaveLine( xml, pPropContainer, L"CommandLine", VCCUSTID_CommandLine+nOffset );
	AddSaveLine( xml, pPropContainer, L"AdditionalDependencies", VCCUSTID_AdditionalDependencies+nOffset );
	AddSaveLine( xml, pPropContainer, L"Outputs", VCCUSTID_Outputs+nOffset );

	// end of node header
	EndNodeHeader( xml, false );
	// end of node
	EndNode( xml, L"Tool", false );

	return S_OK;
}

void CVCCustomBuildTool::AddSaveLine(IStream *xml, IVCPropertyContainer* pPropContainer, LPOLESTR bszPropertyName, long nPropertyID )
{
	CComBSTR bstrProp;
	if (pPropContainer->GetStrProperty(nPropertyID, &bstrProp) != S_OK)
		return;

	// TODO: special multiline handling??
	NodeAttributeWithSpecialChars( xml, bszPropertyName, bstrProp );
}

///////////////////////////////////////////////////////////////////////////////
// Affects our output?
STDMETHODIMP CVCCustomBuildTool::AffectsOutput(long nPropID, VARIANT_BOOL* pbAffectsOutput)
{
	CHECK_POINTER_NULL(pbAffectsOutput);
	*pbAffectsOutput = VARIANT_FALSE;

	// change our outputs?
	if (m_nOffset)	// file cfg
	{
		switch(nPropID)
		{
		case VCFCSTID_Outputs:
		case VCFCSTID_OutputsDirty:
		case VCFCSTID_CommandLine:
		case VCFCFGID_ExcludedFromBuild:
			*pbAffectsOutput = VARIANT_TRUE;
		}
	}
	else
	{
		switch (nPropID)
		{
		case VCCUSTID_Outputs:
		case VCCUSTID_OutputsDirty:
		case VCCUSTID_CommandLine:
			*pbAffectsOutput = VARIANT_TRUE;
		}
	}

	return S_OK;
}

STDMETHODIMP CVCCustomBuildTool::CreatePageObject(IUnknown **ppUnk, CLSID*pCLSID, IVCPropertyContainer *pPropCntr, IVCSettingsPage *pPage )
{
	// Get the list of pages
	if( CLSID_VCCustomGeneral == *pCLSID )
	{
		CPageObjectImpl< CVCCustomBuildPage, VCCUSTOMBUILDTOOL_MIN_DISPID, VCCUSTOMBUILDTOOL_MAX_DISPID >::CreateInstance(ppUnk, pPropCntr, pPage);
	}
	else
	{
		return S_FALSE;
	}
		
	return S_OK;
}

GUID* CVCCustomBuildTool::GetPageIDs()
{ 
	if (s_bPagesInit == FALSE)
	{
		s_pPages[0] = __uuidof(VCCustomGeneral);
		s_bPagesInit = TRUE;
	}
	return s_pPages; 
}

HRESULT CVCCustomBuildTool::SGetDescription( BSTR * pVal )
{
	if (s_bstrDescription.Length() == 0)
		s_bstrDescription.LoadString(IDS_CUSTOMBUILD_DESC);
	return s_bstrDescription.CopyTo(pVal);
}

HRESULT CVCCustomBuildTool::GetCommandLineOptions(IUnknown* pItem, IVCBuildAction* pAction, VARIANT_BOOL bIncludeAdditional, 
	VARIANT_BOOL bForDisplay, commandLineOptionStyle fStyle, CStringW& rstrCmdLine)
{
	CComQIPtr<IVCPropertyContainer> spPropContainer = pItem;
	RETURN_ON_NULL2(spPropContainer, E_NOINTERFACE);

	if (bForDisplay)	// don't do display
		return S_FALSE;

	CComQIPtr<VCFileConfiguration> spFileCfg = spPropContainer;
	CComBSTR bstrCommandLine;
	long nOffset = spFileCfg ? VCCUSTID_FileLevelOffset : 0;
	HRESULT hr = spPropContainer->GetStrProperty(VCCUSTID_CommandLine + nOffset, &bstrCommandLine);
	rstrCmdLine = bstrCommandLine;
	return hr;
}

BOOL CVCCustomBuildTool::GetProcessedOutputString(IVCPropertyContainer* pPropContainer, CStringW& strOutputs)
{
	CComQIPtr<VCConfiguration> spProjCfg = pPropContainer;
	RETURN_ON_NULL2(spProjCfg, FALSE);

	CComBSTR bstrOutput;
	HRESULT hr = pPropContainer->GetEvaluatedStrProperty(VCCUSTID_Outputs, &bstrOutput);
	if (hr != S_OK || bstrOutput.Length() == 0)
		return FALSE;

	CComBSTR bstrCmd;
	hr = pPropContainer->GetStrProperty(VCCUSTID_CommandLine, &bstrCmd);
	if (hr != S_OK || bstrCmd.Length() == 0)
		return FALSE;

	// so, we've got both outputs and a command line, so count how many elements we've got on the list
	strOutputs = bstrOutput;
	strOutputs.TrimLeft();
	strOutputs.TrimRight();
	return(!strOutputs.IsEmpty());
}

STDMETHODIMP CVCCustomBuildTool::GetDeployableOutputsCount(IVCPropertyContainer* pPropContainer, long* pnOutputs)
{	// number of deployable outputs
	CHECK_POINTER_NULL(pnOutputs);
	*pnOutputs = 0;

	CStringW strOutputs;
	if (!GetProcessedOutputString(pPropContainer, strOutputs))
		return S_OK;

	CBldOptionList lstOutSpec(L';', FALSE, TRUE);
	lstOutSpec.SetString((const wchar_t *)strOutputs);
	VCPOSITION pos = lstOutSpec.GetHeadPosition();

	// get the project directory
	CComBSTR bstrProjectDir;
	pPropContainer->GetStrProperty(VCPROJID_ProjectDirectory, &bstrProjectDir);	// should never have macros in it
	CStringW strProjectDir = bstrProjectDir;

	// generate our output in the context of the project directory
	CCurDirW dirCur(strProjectDir);

	while (pos != (VCPOSITION)NULL)
	{
		const wchar_t* pchOutSpec = lstOutSpec.GetNext(pos);
		CPathW pathOutput;		// path of our output based on this spec.
		if (pathOutput.Create(pchOutSpec))
			*pnOutputs += 1;
	}

	return S_OK;
}

STDMETHODIMP CVCCustomBuildTool::GetDeployableOutputs(IVCPropertyContainer* pPropContainer, IVCBuildStringCollection** ppDeployableOutputs)
{	// the deployable outputs
	CHECK_POINTER_NULL(ppDeployableOutputs);
	*ppDeployableOutputs = NULL;

	CStringW strOutputs;
	if (!GetProcessedOutputString(pPropContainer, strOutputs))
		return S_OK;

	CBldOptionList lstOutSpec(L';', FALSE, TRUE);
	lstOutSpec.SetString((const wchar_t *)strOutputs);
	VCPOSITION pos = lstOutSpec.GetHeadPosition();

	// get the project directory
	CComBSTR bstrProjectDir;
	pPropContainer->GetStrProperty(VCPROJID_ProjectDirectory, &bstrProjectDir);	// should never have macros in it
	CStringW strProjectDir = bstrProjectDir;

	// generate our output in the context of the project directory
	CCurDirW dirCur(strProjectDir);

	while (pos != (VCPOSITION)NULL)
	{
		const wchar_t* pchOutSpec = lstOutSpec.GetNext(pos);
		CPathW pathOutput;		// path of our output based on this spec.
		if (pathOutput.Create(pchOutSpec))
		{
			if (*ppDeployableOutputs == NULL)
			{
				HRESULT hr = CVCBuildStringCollection::CreateInstance(ppDeployableOutputs);
				RETURN_ON_FAIL_OR_NULL2(hr, *ppDeployableOutputs, E_OUTOFMEMORY);
			}
			CComBSTR bstrOutputFile = (const wchar_t*)pathOutput;
			(*ppDeployableOutputs)->Add(bstrOutputFile);
		}
	}

	return S_OK;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Settings UI page
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void CVCCustomBuildPage::ResetParentIfNeeded()
{
	CComQIPtr<IVCStagedPropertyContainer> spStagedContainer = m_pContainer;
	CComQIPtr<IVCPropertyContainer> spLiveContainer;
	if (spStagedContainer)
		spStagedContainer->get_Parent(&spLiveContainer);
	if (spLiveContainer == NULL)
		spLiveContainer = m_pContainer;
	CComQIPtr<VCFileConfiguration> spFileCfg = spLiveContainer;
	if (spFileCfg == NULL)
		m_nOffset = 0;	// we're on the project configuration
	else
		m_nOffset = VCCUSTID_FileLevelOffset;	// we're on a file configuration
}

STDMETHODIMP CVCCustomBuildPage::get_CommandLine(BSTR *pVal)
{
	HRESULT hr = S_OK;
	CStringW str;
	if(GetTruncatedStringForProperty(VCCUSTID_CommandLine+m_nOffset, str))
	{
		*pVal = str.AllocSysString();
		return S_OK;
	}
	else
	{
		hr = GetStrProperty(VCCUSTID_CommandLine+m_nOffset, pVal);
		if (hr == S_FALSE)
			COptionHandlerBase::GetDefaultString( pVal );
	}
	return hr;
}

STDMETHODIMP CVCCustomBuildPage::put_CommandLine(BSTR newVal)
{
	HRESULT hr = SetStrProperty(VCCUSTID_CommandLine+m_nOffset, newVal);
	RefreshPropGrid();
	return hr;
}

STDMETHODIMP CVCCustomBuildPage::get_Description(BSTR *pVal)
{
	HRESULT hr = GetStrProperty(VCCUSTID_Description+m_nOffset, pVal);
	if (hr == S_FALSE)
		CVCCustomBuildTool::SGetDescription( pVal );
	return hr;
}

STDMETHODIMP CVCCustomBuildPage::put_Description(BSTR newVal)
{
	return SetStrProperty(VCCUSTID_Description+m_nOffset, newVal);
}

STDMETHODIMP CVCCustomBuildPage::get_AdditionalDependencies(BSTR *pVal)
{
	HRESULT hr = GetStrProperty(VCCUSTID_AdditionalDependencies+m_nOffset, pVal);
	if (hr == S_FALSE)
		COptionHandlerBase::GetDefaultString( pVal );
	return hr;
}

STDMETHODIMP CVCCustomBuildPage::put_AdditionalDependencies(BSTR newVal)
{
	return SetStrProperty(VCCUSTID_AdditionalDependencies+m_nOffset, newVal);
}

STDMETHODIMP CVCCustomBuildPage::get_Outputs(BSTR *pVal)
{
	HRESULT hr = GetStrProperty(VCCUSTID_Outputs+m_nOffset, pVal);
	if (hr == S_FALSE)
		COptionHandlerBase::GetDefaultString( pVal );
	return hr;
}

STDMETHODIMP CVCCustomBuildPage::put_Outputs(BSTR newVal)
{
	return SetStrProperty(VCCUSTID_Outputs+m_nOffset, newVal);
}


void CVCCustomBuildPage::GetBaseDefault(long id, CComVariant& varValue)
{
	if (id == VCCUSTID_Description || id == (VCCUSTID_Description + m_nOffset))
	{
		CComBSTR bstrVal;
		CVCCustomBuildTool::SGetDescription( &bstrVal );
		varValue = bstrVal;
	}
	else
		CBase::GetBaseDefault(id, varValue);
}

long CVCCustomBuildPage::KludgeLocID(long id)
{
	// kludge: if this property is a file level custom build prop, we need to get to the "real" custom build prop 
	// that is in the typelib
	if( id >= VCFILECUSTOMBUILDTOOL_MIN_DISPID && id <= VCFILECUSTOMBUILDTOOL_MAX_DISPID )
		return id - VCCUSTID_FileLevelOffset;
	else
		return id;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\vcpb\custombuildtool.h ===
// CustomBuildTool.h: Definition of the CVCCustomBuildTool class
//
//////////////////////////////////////////////////////////////////////

#pragma once

#include "vctool.h"
#include "settingspage.h"
#include "vshelp.h"

// classes in this header
class CVCCustomBuildTool;

/////////////////////////////////////////////////////////////////////////////
// CVCCustomBuildTool

class ATL_NO_VTABLE CVCCustomBuildTool : 
	public IDispatchImpl<VCCustomBuildTool, &IID_VCCustomBuildTool, &LIBID_VCProjectEngineLibrary, PublicProjBuildTypeLibNumber,0, CVsTypeInfoHolder>, 
	public CVCToolImpl,
	public CComObjectRoot
{
public:
	CVCCustomBuildTool() {}
	static HRESULT CreateInstance(IVCPropertyContainer* pPropContainer, IVCToolImpl** ppTool);

BEGIN_COM_MAP(CVCCustomBuildTool)
 	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IVCToolImpl)
	COM_INTERFACE_ENTRY(VCCustomBuildTool)
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE(CVCCustomBuildTool) 

protected:
	virtual void Initialize(IVCPropertyContainer* pPropContainer);

// VCCustomBuildTool
public:
	// General
	STDMETHOD(get_ToolName)(BSTR* pbstrToolName);	// friendly name of tool, e.g., "C/C++ Compiler Tool"
	STDMETHOD(get_CommandLine)(BSTR *pbstrCommandLine);
	STDMETHOD(put_CommandLine)(BSTR bstrCommandLine);
	STDMETHOD(get_Description)(BSTR *pbstrDescription);
	STDMETHOD(put_Description)(BSTR bstrDescription);
	STDMETHOD(get_Outputs)(BSTR *pbstrOutputs);
	STDMETHOD(put_Outputs)(BSTR bstrOutputs);
	STDMETHOD(get_AdditionalDependencies)(BSTR *pbstrAdditionalDependencies);
	STDMETHOD(put_AdditionalDependencies)(BSTR bstrAdditionalDependencies);
	// Automation properties
	STDMETHOD(get_ToolPath)(BSTR *pbstrToolPath);
	STDMETHOD(get_VCProjectEngine)(IDispatch** projEngine)	{ return DoGetVCProjectEngine(projEngine); }

// IVCToolImpl
public:
	STDMETHOD(get_DefaultExtensions)(BSTR* pVal);
	STDMETHOD(put_DefaultExtensions)(BSTR newVal);
	STDMETHOD(GetAdditionalOptionsInternal)(IUnknown* pItem, VARIANT_BOOL bForBuild, VARIANT_BOOL bSkipLocal, BSTR* pbstrOptions);
	STDMETHOD(GetBuildDescription)(IVCBuildAction* pAction, BSTR* pbstrBuildDescription);
	STDMETHOD(get_ToolPathInternal)(BSTR* pbstrToolPath);
	STDMETHOD(get_Bucket)(long *pVal);
	STDMETHOD(GetCommandLineEx)(IVCBuildAction*,IVCBuildableItem* pBuildableItem, IVCBuildEngine* pBuildEngine, 
		IVCBuildErrorContext* pEC, BSTR* bstrCmd);
	STDMETHOD(IsTargetTool)(IVCBuildAction* pAction, VARIANT_BOOL* pbTargetTool);
	STDMETHOD(GenerateOutput)(long type, IVCBuildActionList* plstActions, IVCBuildErrorContext* pEC);
	STDMETHOD(CreateToolObject)(IVCPropertyContainer* pPropContainer, IVCToolImpl** ppToolObject);
	STDMETHOD(get_ToolShortName)(BSTR* pbstrToolName);
	STDMETHOD(get_ToolNameInternal)(BSTR* pbstrToolName) { return get_ToolName(pbstrToolName); }
	STDMETHOD(MatchName)(BSTR bstrName, VARIANT_BOOL bFullOnly, VARIANT_BOOL* pbMatches);
	STDMETHOD(get_IsComspecTool)(VARIANT_BOOL* pbIsComspecTool);
	STDMETHOD(SaveObject)(IStream *xml, IVCPropertyContainer *pPropCnt, long nIndent);
	STDMETHOD(get_ToolDisplayIndex)(long* pIndex);
	STDMETHOD(AffectsOutput)(long nPropID, VARIANT_BOOL* pbAffectsOutput);
	STDMETHOD(CreatePageObject)(IUnknown **, CLSID*, IVCPropertyContainer *, IVCSettingsPage * );
	STDMETHOD(GetDeployableOutputsCount)(IVCPropertyContainer* pPropContainer, long* pnOutputs);	// number of deployable outputs
	STDMETHOD(GetDeployableOutputs)(IVCPropertyContainer* pPropContainer, IVCBuildStringCollection** ppDeployableOutputs);	// the deployable outputs

	virtual long GetPageCount()	{ return 1; }
	virtual GUID* GetPageIDs();

protected:
	int m_nOffset;	// what's the offset from the proj cfg level IDs?
	static GUID s_pPages[1];
	static BOOL s_bPagesInit;
	static CComBSTR s_bstrDescription;
	static CComBSTR s_bstrToolName;
	static CComBSTR s_bstrExtensions;

protected:
	void AddSaveLine(IStream *xml, IVCPropertyContainer* pPropContainer, LPOLESTR bszPropertyName, long nPropertyID );
	virtual LPCOLESTR GetToolFriendlyName();
	void InitToolName();
	virtual long GetToolID() { return IDS_CustomBuild; }
	virtual HRESULT GetCommandLineOptions(IUnknown* pItem, IVCBuildAction* pAction, VARIANT_BOOL bIncludeAdditional, 
		VARIANT_BOOL bForDisplay, commandLineOptionStyle fStyle, CStringW& rstrCmdLine);
	BOOL GetProcessedOutputString(IVCPropertyContainer* pPropContainer, CStringW& strOutputs);
	void AddCustomBuildError(IVCBuildErrorContext* pEC, long idErrFile, BSTR bstrErrNumFile, long idErrProj, BSTR bstrErrNumProj,
		const wchar_t* szWithMacros, const wchar_t* szNoMacros, IVCPropertyContainer* pPropContainer);

public:
	static HRESULT SGetDescription( BSTR * pVal );
};


class ATL_NO_VTABLE CVCCustomBuildPage :
	public IDispatchImpl<IVCCustomBuildPage, &IID_IVCCustomBuildPage, &LIBID_VCProjectEnginePrivateLibrary, PrivateProjBuildTypeLibNumber,0, CVsTypeInfoHolder>,
	public CPageObjectImpl<CVCCustomBuildPage,VCCUSTOMBUILDTOOL_MIN_DISPID,VCCUSTOMBUILDTOOL_MAX_DISPID>,
	public CComObjectRoot
{
public:

BEGIN_COM_MAP(CVCCustomBuildPage)
	COM_INTERFACE_ENTRY(IPerPropertyBrowsing)
	COM_INTERFACE_ENTRY(IVsPerPropertyBrowsing)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IVCCustomBuildPage)
	COM_INTERFACE_ENTRY(IVCPropertyContainer)
	COM_INTERFACE_ENTRY(IProvidePropertyBuilder)
	COM_INTERFACE_ENTRY(IVCPropertyPageObject)
END_COM_MAP()

// IVCCustomBuildPage
public:
	STDMETHOD(get_CommandLine)(BSTR *pVal);
	STDMETHOD(put_CommandLine)(BSTR newVal);
	STDMETHOD(get_Description)(BSTR *pVal);
	STDMETHOD(put_Description)(BSTR newVal);
	STDMETHOD(get_Outputs)(BSTR *pVal);
	STDMETHOD(put_Outputs)(BSTR newVal);
	STDMETHOD(get_AdditionalDependencies)(BSTR *pVal);
	STDMETHOD(put_AdditionalDependencies)(BSTR newVal);

// helper functions
public:
	virtual void ResetParentIfNeeded();
	virtual void GetBaseDefault(long id, CComVariant& varValue);
	virtual BOOL UseCommandsDialog(long id) { return (id == VCCUSTID_CommandLine || id == (VCCUSTID_CommandLine + m_nOffset)); }
	virtual BOOL SupportsMultiLine(long id) { return (id == VCCUSTID_Outputs || id == (VCCUSTID_Outputs + m_nOffset)); }
	virtual long KludgeLocID(long id);

protected:
	int m_nOffset;	// what's the offset from the proj cfg level IDs?
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\vcpb\DebugSettings.h ===
// DebugSettings.h: Definition of the CDebugSettings class
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_DEBUGSETTINGS_H__A54AAE89_30C2_11D3_87BF_A04A4CC10000__INCLUDED_)
#define AFX_DEBUGSETTINGS_H__A54AAE89_30C2_11D3_87BF_A04A4CC10000__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "vcprojectengine.h"		// g_pProjectEngine;
#include "vccoll.h"
#include "settingspage.h"
#include "PropContainer.h"
#include "toolhrt.h"

/////////////////////////////////////////////////////////////////////////////
// CDebugSettings

class CDebugSettingsBase :
	public CPropertyContainerImpl
{
public:
	CDebugSettingsBase() {}

protected:
	// helper for deep base class CProjectEvaluator
	virtual BOOL GetMacroValue(UINT idMacro, CStringW& strMacroValue, IVCPropertyContainer* pPropContainer);
	BOOL GetExeProjectTargetPath(CPathW& rProjDirPath, CStringW& rstrProjDirPath);
	virtual BOOL CallBaseGetMacroValue(IVCPropertyContainer* pPropContainer) { return FALSE; }
};

class CDebugSettings : 
	public CDebugSettingsBase,
	public IDispatchImpl<VCDebugSettings, &IID_VCDebugSettings, &LIBID_VCProjectEngineLibrary, PublicProjBuildTypeLibNumber,0, CVsTypeInfoHolder>, 
	public IVCDebugSettingsImpl,
	public CComObjectRoot,
	public CComCoClass<CDebugSettings,&CLSID__VCDebugSettings>
{
public:
	CDebugSettings();
	static HRESULT CreateInstance(VCDebugSettings** ppDebugSettings, VCConfiguration* pConfig);

	static HRESULT GetRegSvrCommand( CStringW &strCommand );
	static HRESULT GetTestContainerCommand( CStringW& strCommand );
	static HRESULT GetBrowserCommand( CStringW* pstrCommandLine, CStringW* pstrArgs );

protected:
	HRESULT Initialize(VCConfiguration* pConfig);
	static BOOL GetTestContainerName(CStringW& strTestContainer);
	static void InitializeTestContainer();

public:
BEGIN_COM_MAP(CDebugSettings)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(VCDebugSettings)
	COM_INTERFACE_ENTRY(IVCDebugSettingsImpl)
	COM_INTERFACE_ENTRY(IVCPropertyContainer)
END_COM_MAP()
//DECLARE_NOT_AGGREGATABLE(CDebugSettings) 
// Remove the comment from the line above if you don't want your object to 
// support aggregation. 

DECLARE_NO_REGISTRY()

// VCDebugSettings
// NOTE: when you add properties to this interface, do *not* add member variables for them.
// This is a property container class and, as such, the storage for all variables is in
// m_PropMap (which is in CPropertyContainerImpl).  Failure to store your variables there 
// means that you won't get the behavior you expect in the property page associated with these 
// properties.  (Do what you want with the Impl form of the interface, though, as there is never 
// property container storage for variables needed there.  If, however, you *do* decide to store
// Impl variables in the property container, be sure to add IDs in prjids.h so that nobody will
// collide with your choice of IDs.)
public:
	STDMETHOD(get_Command)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_Command)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_WorkingDirectory)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_WorkingDirectory)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_CommandArguments)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_CommandArguments)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_Attach)(/*[out, retval]*/ VARIANT_BOOL *pVal);
	STDMETHOD(put_Attach)(/*[in]*/ VARIANT_BOOL newVal);
	STDMETHOD(get_Remote)(/*[out, retval]*/ RemoteDebuggerType *pVal);
	STDMETHOD(put_Remote)(/*[in]*/ RemoteDebuggerType newVal);
	STDMETHOD(get_RemoteMachine)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_RemoteMachine)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_DebuggerType)(/*[out, retval]*/ TypeOfDebugger *pVal);
	STDMETHOD(put_DebuggerType)(/*[in]*/ TypeOfDebugger newVal);
	STDMETHOD(get_RemoteCommand)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_RemoteCommand)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_HttpUrl)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_HttpUrl)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_PDBPath)(/*out, retval*/ BSTR* pbstrVal);
	STDMETHOD(put_PDBPath)(/* in */ BSTR bstrNewVal);
	STDMETHOD(get_SQLDebugging)(/*[out, retval]*/ VARIANT_BOOL *pVal);
	STDMETHOD(put_SQLDebugging)(/*[in]*/ VARIANT_BOOL newVal);

// IVCDebugSettingsImpl
public:
	STDMETHOD(WriteToStream)(/*[in]*/ IStream *pStream);
	STDMETHOD(ReadFromStream)(/*[in]*/ IStream *pStream);
	STDMETHOD(Close)();
	STDMETHOD(CanGetDebugTargetInfo)(/*[out]*/ VARIANT_BOOL* pbCanGet);
	STDMETHOD(GetDebugTargetInfo)(/*[in]*/ VSDBGLAUNCHFLAGS grfLaunch, 
			/*[in,out]*/ VsDebugTargetInfo *pDebugTargetInfo,
			/*[in,out]*/ DWORD *pdwCount);

// IVCPropertyContainer; most methods in base class
public:
	STDMETHOD(GetMultiProp)(long id, LPCOLESTR szSeparator, VARIANT_BOOL bSkipLocal, BSTR *varValue);
	STDMETHOD(GetStagedPropertyContainer)(VARIANT_BOOL bCreateIfNecessary, IVCStagedPropertyContainer** ppPropContainer);

// IVCPropertyContainer helpers
protected:
	virtual HRESULT DoGetProp(long id, BOOL bCheckSpecialProps, VARIANT *pVarValue);
	virtual HRESULT DoGetStrProperty(long idProp, BOOL bCheckSpecial, BSTR* pbstrValue);
	HRESULT DoGetCommand(CComBSTR& bstrCommand, BOOL bEvaluate);
	virtual BOOL CheckCanDirty() { return FALSE; }
	virtual BOOL CallBaseGetMacroValue(IVCPropertyContainer* pPropContainer) { return(pPropContainer != this && m_spProjCfg); }

// default ISpecifyPropertyPages method in base class
       
private:
	HRESULT GetHttpDebugTargetInfo(VSDBGLAUNCHFLAGS grfLaunch, 
			/*[in,out]*/ VsDebugTargetInfo *pDebugTargetInfo,
			/*[in,out]*/ DWORD *pdwCount);

    void GetEngineForDebuggerType(TypeOfDebugger type, const IMAGE_INFO*, CLSID* pClsid);
	void DoEvaluate(IVCPropertyContainer* pPropContainer, CComBSTR& bstrProp);
	void DoGetEvaluatedStrProperty(IVCPropertyContainer* pPropContainer, long idProp, BSTR* pbstrProp);

	BOOL m_bWorkingDirInit;
	CComPtr<VCConfiguration> m_spProjCfg;

	static BOOL s_bTestContainerInit;
	static CStringW s_strTestContainer;
};

// NOTE: please update the rgDebugCommands[] array in ..\ui_dll\src\exefordbg.h if you update this list
const WORD rgDebugCommands[] = {
	VCDSID_Command_IExplore,
	VCDSID_Command_ATLTest,
	VCDSID_Command_RegSvr,
	VCDSID_Command_Browse,
};	

/////////////////////////////////////////////////////////////////////////////
// CDebugSettingsPage
class ATL_NO_VTABLE CDebugSettingsPage :
	public IDispatchImpl<VCDebugSettings, &IID_VCDebugSettings, &LIBID_VCProjectEngineLibrary, PublicProjBuildTypeLibNumber,0, CVsTypeInfoHolder>,
	public CPageObjectImpl<CDebugSettingsPage, VCDEBUG_MIN_DISPID, VCDEBUG_MAX_DISPID>,
	public ICategorizeProperties,
	public CComObjectRoot
{
public:
BEGIN_COM_MAP(CDebugSettingsPage)
	COM_INTERFACE_ENTRY(IPerPropertyBrowsing)
	COM_INTERFACE_ENTRY(IVsPerPropertyBrowsing)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(VCDebugSettings)
	COM_INTERFACE_ENTRY(IVCPropertyContainer)
	COM_INTERFACE_ENTRY(IProvidePropertyBuilder)
	COM_INTERFACE_ENTRY_IID(IID_ICategorizeProperties, ICategorizeProperties)
END_COM_MAP()

	// IDispatch override
	STDMETHOD(Invoke)( DISPID dispid, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS *pdispParams, VARIANT *pvarResult, EXCEPINFO *pexcepInfo, UINT *puArgErr )
	{
		IDispatchImpl<VCDebugSettings, &IID_VCDebugSettings, &LIBID_VCProjectEngineLibrary, PublicProjBuildTypeLibNumber,0, CVsTypeInfoHolder>::Invoke( dispid, riid, lcid, wFlags, pdispParams, pvarResult, pexcepInfo, puArgErr );
		return S_OK;
	}


// VCDebugSettings
public:
	STDMETHOD(get_Command)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_Command)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_WorkingDirectory)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_WorkingDirectory)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_CommandArguments)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_CommandArguments)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_Attach)(/*[out, retval]*/ VARIANT_BOOL *pVal);
	STDMETHOD(put_Attach)(/*[in]*/ VARIANT_BOOL newVal);
	STDMETHOD(get_Remote)(/*[out, retval]*/ RemoteDebuggerType *pVal);
	STDMETHOD(put_Remote)(/*[in]*/ RemoteDebuggerType newVal);
	STDMETHOD(get_RemoteMachine)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_RemoteMachine)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_DebuggerType)(/*[out, retval]*/ TypeOfDebugger *pVal);
	STDMETHOD(put_DebuggerType)(/*[in]*/ TypeOfDebugger newVal);
	STDMETHOD(get_RemoteCommand)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_RemoteCommand)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_HttpUrl)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_HttpUrl)(/*[in]*/ BSTR newVal);
    STDMETHOD(get_PDBPath)(/*out, retval*/ BSTR* pbstrVal);
    STDMETHOD(put_PDBPath)(/* in */ BSTR bstrNewVal);
	STDMETHOD(get_SQLDebugging)(/*[out, retval]*/ VARIANT_BOOL *pVal);
	STDMETHOD(put_SQLDebugging)(/*[in]*/ VARIANT_BOOL newVal);

// IPerPropertyBrowsing (overides)
public:
	STDMETHOD(GetPredefinedValue)( DISPID dispID, DWORD dwCookie, VARIANT* pVarOut );
	STDMETHOD(GetPredefinedStrings)( DISPID dispID, CALPOLESTR *pCaStringsOut, CADWORD *pCaCookiesOut );

// IVSPerPropertyBrowsing (overides)
	STDMETHOD(HideProperty)( DISPID dispid, BOOL *pfHide);

// ICategorizeProperties
public:
	STDMETHOD(MapPropertyToCategory)( DISPID dispid, PROPCAT* ppropcat);
	STDMETHOD(GetCategoryName)( PROPCAT propcat, LCID lcid, BSTR* pbstrName);

// IPropertyContainer
public:
	STDMETHOD(HasDefaultValue)( DISPID dispid, BOOL *pfDefault)
	{
		CHECK_POINTER_NULL(pfDefault);
		*pfDefault = TRUE;
		return S_OK;
	}

// helper functions
public:
	virtual void ResetParentIfNeeded();
	virtual void GetBaseDefault(long id, CComVariant& varValue);
	virtual BOOL IsDir(long id)
	{
		if( id == VCDSID_WorkingDirectory )
			return TRUE;
		return FALSE;
	}

	static HRESULT BrowseForCommand( CStringW* pstrCommand, HWND hwndOwner = NULL );
	HRESULT SGetCommand(BSTR* pVal);
protected:
	virtual BOOL UseSinglePropDirectoryPickerDialog(long id) { return (id == VCDSID_PDBPath); }
};

class CDbgSettingsPage :
	public CSettingsPageBase<CDbgSettingsPage, &CLSID_DebugSettingsPage, IDS_DebugSettings, 0>
{
protected:
	virtual void DoCreatePageObject(UINT i, IDispatch* pDisp, IVCPropertyContainer* pLiveContainer, IVCSettingsPage* pPage)
	{
		CPageObjectImpl< CDebugSettingsPage, VCDEBUG_MIN_DISPID, VCDEBUG_MAX_DISPID >::CreateInstance(&m_ppUnkArray[i], pLiveContainer, pPage);
	}
};


class CVCStagedExeConfigPropertyContainer : 
	public IVCStagedPropertyContainer, 
	public CDebugSettingsBase,
	public CComObjectRoot
{
public:
	CVCStagedExeConfigPropertyContainer() : m_pos(NULL), m_cStaged(0) {}
	~CVCStagedExeConfigPropertyContainer() {}

	static HRESULT CreateInstance(IVCPropertyContainer* pParentPropContainer, IVCStagedPropertyContainer **ppStagedPropertyContainer);
	HRESULT Initialize(IVCPropertyContainer* pParentPropContainer);

BEGIN_COM_MAP(CVCStagedExeConfigPropertyContainer)
	COM_INTERFACE_ENTRY(IVCStagedPropertyContainer)
	COM_INTERFACE_ENTRY(IVCPropertyContainer)
END_COM_MAP()
DECLARE_NO_REGISTRY()

// IVCPropertyContainer overrides
public:
	STDMETHOD(GetMultiProp)(long id, LPCOLESTR szSeparator, VARIANT_BOOL bSkipLocal, BSTR *varValue);
	STDMETHOD(GetMultiPropSeparator)(long id, BSTR* pbstrPreferred, BSTR* pbstrAll);
	STDMETHOD(Commit)();

// CPropertyContainerImpl overrides
	HRESULT DoGetParentProp(long id, VARIANT_BOOL bAllowInherit, BOOL bCheckSpecialProps, VARIANT *pVarValue);

// IVCStagedPropertyContainer
public:
	STDMETHOD(get_Parent)(IVCPropertyContainer** ppParent);
	STDMETHOD(ClearPropertyRange)(long nMinID, long nMaxID);
	STDMETHOD(GetGrandParentProp)(long id, VARIANT* pvarValue);		// skip to parent of our non-staged parent
	STDMETHOD(Close)();
	STDMETHOD(CommitPropertyRange)(long nMinID, long nMaxID);
	STDMETHOD(Reset)(void);
	STDMETHOD(NextElement)(long* pKey, VARIANT* pVal);
	STDMETHOD(HoldStagedContainer)();			// number of calls to Hold/Release StagedContainer need to match
	STDMETHOD(ReleaseStagedContainer)();		// number of calls to Hold/Release StagedContainer need to match
	STDMETHOD(HasDefaultValue)(DISPID dispid, BOOL *pfDefault);

// helpers
protected:
	HRESULT DoCommitPropertyRange(long nMinID, long nMaxID, bool bIgnoreRange);
	virtual BOOL CheckCanDirty() { return FALSE; }

protected:
	CComPtr<IVCPropertyContainer> m_spParentPropContainer;

	VCPOSITION m_pos;
	int m_cStaged;
};

#endif // !defined(AFX_DEBUGSETTINGS_H__A54AAE89_30C2_11D3_87BF_A04A4CC10000__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\vcpb\DebugSettings.cpp ===
// DebugSettings.cpp : Implementation of 

#include "stdafx.h"
#include "DebugSettings.h"
#include "msdbg.h"
#include "path2.h"
#include "register.h"
#include "regscan.h"
#include "vsappid.h"
#include "util2.h"

#define VCDSID_Version	0
GUID guidNull = { 0x00000000, 0x0000, 0x0000, { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } };

// The following macro just makes it easy to check preconditions on functions.	It asserts
// the expression given, and returns with the supplied error code if the expression is false.
#define DEBUGSETTINGS_PRECONDITION(x, err, str) { if (str){VSASSERT((x), (str));} if (!(x)) { return (err); } }

BOOL		CDebugSettings::s_bTestContainerInit = FALSE;
CStringW	CDebugSettings::s_strTestContainer = L"";

int GetLengthDoubleNULLString(LPOLESTR pStr)
{
	LPOLESTR  pStart = pStr;
	LPOLESTR  pIter = pStr;

	INT_PTR n = wcslen(pIter);
	if( n==0 )
		return 2;

	while( n )
	{
		pIter = pIter + n + 1; // advance it past the NULL
		n = wcslen(pIter);
	}
	// pIter now points to the final NULL.
	return (int)(pIter - pStart); 
}


CDebugSettings::CDebugSettings()
{
	//
	// Initialize the defaults.
	//

	SetBoolProperty(VCDSID_Attach, VARIANT_FALSE);
	SetIntProperty(VCDSID_DebuggerType, DbgAuto);
	SetIntProperty(VCDSID_Remote, DbgLocal);

	m_bWorkingDirInit = FALSE;
}

/////////////////////////////////////////////////////////////////////////////
//


HRESULT CDebugSettings::CreateInstance(VCDebugSettings** ppDebugSettings, VCConfiguration* pConfig)
{
	CHECK_POINTER_NULL(ppDebugSettings);

	CDebugSettings *pVar;
	CComObject<CDebugSettings> *pObj;
	HRESULT hr = CComObject<CDebugSettings>::CreateInstance(&pObj);
	if (SUCCEEDED(hr))
	{
		pVar = pObj;
		pVar->AddRef();
		*ppDebugSettings = pVar;
		hr = pVar->Initialize(pConfig);
	}

	return hr;
}

HRESULT CDebugSettings::Initialize(VCConfiguration* pConfig)
{
	m_spProjCfg = pConfig;
	CComQIPtr<IVCPropertyContainer> spPropContainer = pConfig;
	if (spPropContainer)
		m_rgParents.AddHead(spPropContainer);
	return S_OK;
}

//
// Return a browser command w/ %s for the URL to open.	For example:
//
//	c:\W3C\Arena.exe -startpage "%s"
//
// NOTE: please update similar code in ..\ui_dll\src\exefordbg.h appropriately if you modify this function

/* static */ HRESULT CDebugSettings::GetBrowserCommand( CStringW* pstrCommand, CStringW* pstrArgs )
{
	CRegistryScanner regKey;
	CStringW strBrowser;
	CStringW strCommandLine;

	if (!regKey.Open (HKEY_CLASSES_ROOT, L"http\\shell\\open\\command"))
	{
		return E_FAIL;
	}

	if (!regKey.QueryStringValue (NULL, strBrowser))
	{
		return E_FAIL;
	}

	if (strBrowser.IsEmpty())
	{
		return E_FAIL;
	}

	{
		// From here there are two possible formats for the registry entry:
		// Netscape uses c:\progra~1\...\Netscape.exe -h "%1"
		// while IE uses "C:\Program Files\...\IEXPLORE.EXE" -nohome
		// The bstrExe that we return must be the executable alone without quotes, 
		// and we cannot pass args except through the bstrArg parameter.
		int iMarker = strBrowser.Find (L"%1");
		if (iMarker != -1)
		{
			// Netscape-style entry -- make a %s
			strCommandLine = strBrowser;
			((LPWSTR)(LPCWSTR)strCommandLine)[ iMarker + 1 ] = L's';
		}
		else
		{
			// IE-style entry
			strCommandLine = strBrowser + L" %s";
		}
	}

	//
	// Spit into EXE paths and args
	//

	int iSplit;
	if (strCommandLine[0] == L'\"')
	{
		// Quoted exe
		iSplit = strCommandLine.Find (L'\"', 1);
		VSASSERT (iSplit != -1, "Quote not found");
		VSASSERT (iSplit > 0, "Empty EXE Path");

		*pstrCommand = strCommandLine.Mid (1, iSplit - 1);
		if (pstrArgs)
		{
			*pstrArgs = strCommandLine.Mid (iSplit + 1);
		}
	}

	else
	{
		iSplit = strCommandLine.Find (L' ');
		VSASSERT (iSplit != -1, "Space not found");
		VSASSERT (iSplit > 0, "Empty EXE Path");

		*pstrCommand = strCommandLine.Left (iSplit);
		if (pstrArgs)
		{
			*pstrArgs = strCommandLine.Mid (iSplit);
		}
	}

	return S_OK;
}

// NOTE: please update similar code in ..\ui_dll\src\exefordbg.h appropriately if you modify this function
/* static */ HRESULT CDebugSettings::GetTestContainerCommand( CStringW& strCommand )
{
	GetTestContainerName(strCommand);
	return S_OK;
}	

// NOTE: please update similar code in ..\ui_dll\src\exefordbg.h appropriately if you modify this function
/* static */ BOOL CDebugSettings::GetTestContainerName(CStringW& strTestContainer)
{
	InitializeTestContainer();
	strTestContainer = s_strTestContainer;
	return !strTestContainer.IsEmpty();
}

// NOTE: please update similar code in ..\ui_dll\src\exefordbg.h appropriately if you modify this function
/* static */ void CDebugSettings::InitializeTestContainer()
{
	if (s_bTestContainerInit)
		return;

	s_bTestContainerInit = TRUE;
	//
	// Search order:
	//  1) Common7\Tools
	//	2) vc7 directory
	//	3) devenv.exe directory
	//	4) Use SearchPath()


	// Try Common7\Tools
	///////////////////////////////////
	UtilGetCommon7Folder(s_strTestContainer);
	s_strTestContainer += L"Tools\\tstcon32.exe";
	CPathW pathExe1;
	if (pathExe1.Create(s_strTestContainer) && pathExe1.ExistsOnDisk())
		return;

	// Try vc7\bin
	///////////////////////////////////

	UtilGetVCInstallFolder(s_strTestContainer);
	s_strTestContainer += L"bin\\tstcon32.exe";
	CPathW pathExe2;
	if (pathExe2.Create(s_strTestContainer) && pathExe2.ExistsOnDisk())
		return;

	//
	// Try devenv.exe directory
	//
	UtilGetDevenvFolder(s_strTestContainer);
	s_strTestContainer += L"tstcon32.exe";

	CPathW pathExe3;
	if (pathExe3.Create(s_strTestContainer) && pathExe3.ExistsOnDisk())
		return;

	//
	// Try the path
	//
	wchar_t *psz, szPath[_MAX_PATH + 1];
	DWORD dw = SearchPathW(NULL, L"tstcon32.exe", NULL, _MAX_PATH, szPath, &psz);
	if ( 0 < dw && _MAX_PATH > dw )
		s_strTestContainer = szPath;
	else
		s_strTestContainer.Empty();
}


// NOTE: please update similar code in ..\ui_dll\src\exefordbg.h appropriately if you modify this function
/* static */ HRESULT CDebugSettings::GetRegSvrCommand( CStringW &strCommand )
{
	wchar_t *pszFile = NULL;

	strCommand.ReleaseBuffer(SearchPathW(
		NULL,
		L"regsvr32.exe",
		NULL,
		_MAX_PATH + 1,
		strCommand.GetBuffer( _MAX_PATH + 1 ),
		&pszFile
		));


	return strCommand.IsEmpty() ? E_FAIL : S_OK;
}


HRESULT CDebugSettings::GetHttpDebugTargetInfo(VSDBGLAUNCHFLAGS grfLaunch, /*[in,out]*/ VsDebugTargetInfo *pDebugTargetInfo,
											   /*[in,out]*/ DWORD *pdwCount)
{
	// Test our preconditions...
	DEBUGSETTINGS_PRECONDITION(pDebugTargetInfo != NULL, E_INVALIDARG, 
							   "CDebugSettings::GetHttpDebugTargetInfo() - pDebugTargetInfo cannot be NULL.");
	DEBUGSETTINGS_PRECONDITION(pdwCount != NULL && (*pdwCount == 1 || *pdwCount == 2), E_INVALIDARG,
							   "CDebugSettings::GetHttpDebugTargetInfo() - CDebugSettings::GetHttpDebugTargetInfo() - pdwCount is invalid.");

	if (!(grfLaunch & DBGLAUNCH_NoDebug))
	{
		DEBUGSETTINGS_PRECONDITION(*pdwCount == 2, E_INVALIDARG, "CDebugSettings::GetHttpDebugTargetInfo() - If we're debug-launching a URL we need to fill in 2 VsDebugTargetInfo's.");
	}

	// If we got this far, we're ready to continue...
	HRESULT hr = S_OK;

	// Get the URL to launch the browser with
	CComBSTR sbstrHttpUrl;
	hr = get_HttpUrl(&sbstrHttpUrl);

	// Get the browser command and arguments.
	CStringW strBrowserCmd, strArgFmt;
	if (SUCCEEDED(hr))
	{
		hr = GetBrowserCommand(&strBrowserCmd, &strArgFmt);
	}

	if (SUCCEEDED(hr))
	{														
		// We'll have 2 targets if doing a debug launch, only 1 if this is a NoDebug launch.
		*pdwCount = (grfLaunch & DBGLAUNCH_NoDebug)? 1: 2;	

		// Create the browser launch target info.  For a 2 target launch, the second
		// target specifies the browser launch.
		VsDebugTargetInfo* pInfo = pDebugTargetInfo + (*pdwCount - 1);
		memset(pInfo, 0, sizeof(VsDebugTargetInfo));
		pInfo->cbSize = sizeof(VsDebugTargetInfo);

		// Format the actual arguments for the browser.
		CStringW strArgLine;
		strArgLine.Format(strArgFmt, sbstrHttpUrl);

		// Fill in the VsDebugTargetInfo struct for launching the browser
		pInfo->cbSize = sizeof(VsDebugTargetInfo);
		pInfo->bstrExe = strBrowserCmd.AllocSysString();
		pInfo->bstrArg = strArgLine.AllocSysString();
		pInfo->dlo = DLO_CreateProcess;
		pInfo->grfLaunch = grfLaunch | DBGLAUNCH_StopDebuggingOnEnd;
		pInfo->pClsidList = (CLSID*)CoTaskMemAlloc( sizeof(CLSID) );
		if (pInfo->pClsidList==NULL)
			return E_OUTOFMEMORY;
		pInfo->pClsidList[0] = guidScriptEng;
		pInfo->dwClsidCount = 1;

		hr = (pInfo->bstrExe == NULL || pInfo->bstrArg == NULL)? E_OUTOFMEMORY: S_OK;

		// If we need to fill in two launch targets, then fill in the
		// first target, which happens to be the LaunchByWebServer target.
		if (SUCCEEDED(hr) && *pdwCount == 2)
		{
			memset(pDebugTargetInfo, 0, sizeof(VsDebugTargetInfo));
			pDebugTargetInfo->cbSize = sizeof(VsDebugTargetInfo);

			// TODO: get the remote machine name from somewhere...but where?
			// Should we split the URL to get the server name out of it?
			pDebugTargetInfo->bstrRemoteMachine = NULL;
			pDebugTargetInfo->dlo = DLO_LaunchByWebServer;
			pDebugTargetInfo->grfLaunch = grfLaunch | DBGLAUNCH_WaitForAttachComplete | DBGLAUNCH_DetachOnStop;
			pDebugTargetInfo->bstrExe = SysAllocString(sbstrHttpUrl);

			TypeOfDebugger debuggerType = DbgAuto;
			GetIntProperty(VCDSID_DebuggerType, (long *)&debuggerType);
			CLSID clsid;
			GetEngineForDebuggerType(debuggerType, NULL, &clsid);

			VARIANT_BOOL bSQL = VARIANT_FALSE;
			get_SQLDebugging(&bSQL);
			if( bSQL == VARIANT_TRUE )
			{
				pDebugTargetInfo->pClsidList = (CLSID*)CoTaskMemAlloc( 2*sizeof(CLSID) );
				pDebugTargetInfo->pClsidList[1] = guidSQLEng;
				pDebugTargetInfo->dwClsidCount = 2;
			}
			else
			{
				pDebugTargetInfo->pClsidList = (CLSID*)CoTaskMemAlloc( sizeof(CLSID) );
				pDebugTargetInfo->dwClsidCount = 1;
			}
			pDebugTargetInfo->pClsidList[0] = clsid;
			hr = (pDebugTargetInfo->bstrExe == NULL)? E_OUTOFMEMORY: S_OK;
		}

	}
	return hr;
}

STDMETHODIMP CDebugSettings::CanGetDebugTargetInfo(VARIANT_BOOL* pbCanGet)
{
	if (pbCanGet != NULL)
		*pbCanGet = VARIANT_TRUE;

	CComBSTR bstrHttpUrl;
	GetEvaluatedStrProperty(VCDSID_HttpUrl, &bstrHttpUrl);
	if (bstrHttpUrl.Length() > 0)
		return S_OK;

	CComBSTR bstrDebuggee;
	DoGetCommand( bstrDebuggee, TRUE );
	if (bstrDebuggee.Length() > 0)
		return S_OK;

	if (pbCanGet != NULL)
		*pbCanGet = VARIANT_FALSE;
	return E_FAIL;
}

void CDebugSettings::DoEvaluate(IVCPropertyContainer* pPropContainer, CComBSTR& bstrProp)
{
	CComBSTR bstrPropIn = bstrProp.Detach();
	if (pPropContainer)
		pPropContainer->Evaluate(bstrPropIn, &bstrProp);
	else
		Evaluate(bstrPropIn, &bstrProp);
}

void CDebugSettings::DoGetEvaluatedStrProperty(IVCPropertyContainer* pPropContainer, long idProp, BSTR* pbstrProp)
{
	if (pPropContainer == NULL)	// exe project
	{
		GetEvaluatedStrProperty(idProp, pbstrProp);
		return;
	}

	HRESULT hr = pPropContainer->GetEvaluatedStrProperty(idProp, pbstrProp);

	if (hr == S_OK)	// we're done.  get outta here
		return;

	// hmmm.  Property must be in the debugger's property container, then
	CComBSTR bstrTmp;
	GetStrProperty(idProp, &bstrTmp);
	pPropContainer->Evaluate(bstrTmp, pbstrProp);
}

STDMETHODIMP CDebugSettings::GetDebugTargetInfo(/*[in]*/ VSDBGLAUNCHFLAGS grfLaunch, 
	/*[in,out]*/ VsDebugTargetInfo *pDebugTargetInfo, /*[in, out]*/ DWORD *pdwCount )
{
	CComBSTR bstrArgs;
	CComBSTR bstrDebuggee;
	CComBSTR bstrDir;
	CComBSTR bstrMachine;
	CComBSTR bstrOptionString;
	CComPtr<IDebugPort2> pPort;
	bool bDoSpawn = false;
	bool bRemote = false;
	USES_CONVERSION;
	
	CComQIPtr<IVCPropertyContainer> spPropContainer = m_spProjCfg;

	// Now, build up the DebugTargetInfo structure (defined in vsshell.idl)
	memset(pDebugTargetInfo, 0, sizeof(VsDebugTargetInfo));
	pDebugTargetInfo->cbSize = sizeof(VsDebugTargetInfo);

	CComBSTR bstrHttpUrl;
	GetStrProperty(VCDSID_HttpUrl, &bstrHttpUrl);
	DoEvaluate(spPropContainer, bstrHttpUrl);
	if (bstrHttpUrl.Length() > 0)
		return GetHttpDebugTargetInfo(grfLaunch, pDebugTargetInfo, pdwCount);

	DoGetCommand( bstrDebuggee, TRUE );
	if (bstrDebuggee.Length() == 0)
		return E_FAIL;


	// Only launch the one process by default
	*pdwCount = 1;

	// Assume local first so get usual things
	pDebugTargetInfo->bstrMdmRegisteredName = NULL;
	pDebugTargetInfo->dlo = DLO_Custom;

	// figure out the working dir
	CComBSTR bstrProjDir;
	if (spPropContainer != NULL)
		spPropContainer->GetStrProperty(VCPROJID_ProjectDirectory, &bstrProjDir );

	RemoteDebuggerType remoteType = DbgLocal;
	GetIntProperty(VCDSID_Remote, (long *)&remoteType);

	VARIANT_BOOL bAttach = VARIANT_FALSE;
	get_Attach(&bAttach);

	get_WorkingDirectory( &bstrDir );
	if( bstrDir.Length() == 0 )
	{
		if (remoteType == DbgLocal)		// VS7Bug: 156499 Only set the directory if we're debugging locally.
			bstrDir = bstrProjDir;
	}
	else	// need to see if it is a relative path and handle accordingly
	{
		DoEvaluate(spPropContainer, bstrDir);
		CDirW dirProj;
		if (dirProj.CreateFromKnown(bstrProjDir))
		{
			CPathW pathWorking;
			if (pathWorking.CreateFromDirAndFilename(dirProj, bstrDir))
			{
				CStringW strPathWorking;
				pathWorking.GetFullPath(strPathWorking);
				bstrDir = strPathWorking;
			}
		}
	}
	if (pDebugTargetInfo->bstrCurDir)
		::SysFreeString(pDebugTargetInfo->bstrCurDir);
	if (bstrDir.Length() > 0)
		bstrDir.CopyTo(&(pDebugTargetInfo->bstrCurDir));

	// figure out the fullpath to the local exe to debug
	// if( (remoteType == DbgLocal) && (bAttach == VARIANT_FALSE) )
	if( remoteType == DbgLocal )
	{
		CDirW dir;
		CPathW path;
		dir.CreateFromStringEx( bstrProjDir, FALSE );
		path.CreateFromDirAndFilename(dir, bstrDebuggee);
		if( path.ExistsOnDisk() )
		{
			// its in a location relative to the project.
			bstrDebuggee = path;
		}
		else
		{
			dir.CreateFromStringEx( bstrDir, FALSE );
			path.CreateFromDirAndFilename(dir, bstrDebuggee);
			if( path.ExistsOnDisk() )
			{
				// its in a location relative to the working dir.
				bstrDebuggee = path;
			}
			else
			{
				// We are running out of options here. Maybe its on the path ?
				wchar_t szPathToDebug[ _MAX_PATH+10 ];
				LPOLESTR pJunk = NULL;

				CComBSTR bstrPath;
				HRESULT hr = VCGetEnvironmentVariableW(L"PATH", &bstrPath);
				BOOL b = SearchPathW( bstrPath, bstrDebuggee, NULL, _MAX_PATH+10, szPathToDebug, &pJunk);
				if( b )
				{
					bstrDebuggee = szPathToDebug;
				}
				else
				{
					// still couldn't find it !! 
					// We are probably going to error out eventually then.
				}
			}
		}
	}


	// now get the rest of the stuff
	get_CommandArguments( &bstrArgs );
	DoEvaluate(spPropContainer, bstrArgs);
	pDebugTargetInfo->bstrArg = bstrArgs.Detach();
	pDebugTargetInfo->grfLaunch = grfLaunch;

	IMAGE_INFO ImageInfo;
	ImageInfo.Size = sizeof(ImageInfo);
	BOOL bGotImageInfo = FALSE;
	bGotImageInfo = bstrDebuggee && GetImageInfo( W2A(bstrDebuggee), &ImageInfo );

	// select Engine based on debugger type
	TypeOfDebugger debuggerType = DbgAuto;
	GetIntProperty(VCDSID_DebuggerType, (long *)&debuggerType);

	CLSID clsid;
	GetEngineForDebuggerType(debuggerType, &ImageInfo, &clsid);

	// select remote & options as required
	switch (remoteType)
	{
	case DbgLocal:
		{
			pDebugTargetInfo->bstrRemoteMachine = NULL;
			bDoSpawn = (grfLaunch & DBGLAUNCH_NoDebug) ? true : false;				// Use VCSpawn if local and not debugging
			if( bDoSpawn )
			{
				LPOLESTR pStr = GetEnvironmentStringsW();
				int len = GetLengthDoubleNULLString(pStr);
				pDebugTargetInfo->bstrEnv = SysAllocStringLen( pStr, len );
				FreeEnvironmentStringsW(pStr);
			}
		}
		break;
	case DbgRemote:
		{
			pDebugTargetInfo->clsidPortSupplier = guidLocalPortSupplier;
			DoGetEvaluatedStrProperty(spPropContainer, VCDSID_RemoteMachine, &pDebugTargetInfo->bstrRemoteMachine);
			DoGetEvaluatedStrProperty(spPropContainer, VCDSID_RemoteCommand, &bstrDebuggee);
			bRemote = true;
		}
		break;
	case DbgRemoteTCPIP:
		{
			// TCPIP only works for native-only
			if (clsid!=guidNativeOnlyEng)
				return E_INVALIDARG;

			// need to build a native port, on the local machine, whose name is the remote machine
			pDebugTargetInfo->bstrRemoteMachine = NULL;
			pDebugTargetInfo->clsidPortSupplier = guidNativePortSupplier;
			DoGetEvaluatedStrProperty(spPropContainer, VCDSID_RemoteMachine, &pDebugTargetInfo->bstrPortName);
			DoGetEvaluatedStrProperty(spPropContainer, VCDSID_RemoteCommand, &bstrDebuggee);
			bRemote = true;
		}
		break;
	default:
		return E_POINTER;
	}

	bstrDebuggee.CopyTo(&pDebugTargetInfo->bstrExe);
	pDebugTargetInfo->clsidCustom = clsid;

	if (bAttach != VARIANT_FALSE )
	{
		pDebugTargetInfo->dlo = DLO_AlreadyRunning;
	}

	if (bDoSpawn &&
		bGotImageInfo &&
		(ImageInfo.ImageType==IMAGE_TYPE_WIN32) &&
		(ImageInfo.u.Win32.Subsystem==IMAGE_SUBSYSTEM_WINDOWS_CUI)
	   )
	{
		// First, if it's a console app we run the app with 'vcspawn -p -t' so
		// the user gets a 'Press any key to continue' when it's done.
		//
		// BUG BUG We should not be doing this when user is redirecting
		// stdout
		//

		CComPtr< IDispatch > spDispPlatform;
		CComBSTR bstrWPath;
		CStringW strPath;
		if (m_spProjCfg && m_spProjCfg->get_Platform(&spDispPlatform)==S_OK)
		{
			CComQIPtr<VCPlatform> spPlatform = spDispPlatform;
			if (spPlatform)
			{
				spPlatform->get_ExecutableDirectories(&bstrWPath);
				if (bstrWPath)
				{
					CComBSTR bstrTmp = bstrWPath.Detach();
					spPlatform->Evaluate(bstrTmp, &bstrWPath);
					strPath = bstrWPath;
				}
			}
		}

		wchar_t szPathToSpawn[ _MAX_PATH+10 ];
		LPOLESTR pJunk = NULL;

		// Find the exe on the path if no setting set
		BOOL bFoundVCSpawn = (strPath.GetLength() && SearchPathW( strPath, L"vcspawn.exe", NULL, _MAX_PATH+10, szPathToSpawn, 
			&pJunk));
		if (!bFoundVCSpawn)
			bFoundVCSpawn = (SearchPathW( NULL, L"vcspawn.exe", NULL, _MAX_PATH+10, szPathToSpawn, &pJunk) > 0);
		if (!bFoundVCSpawn)
		{
			CStringW strMsvcPath;
			UtilGetCommon7Folder(strMsvcPath);
			strMsvcPath += L"Tools\\vcspawn.exe";
			CPathW pathSpawn;
			if (pathSpawn.Create(strMsvcPath) && pathSpawn.ExistsOnDisk())
			{
				bFoundVCSpawn = TRUE;
				wcscpy(szPathToSpawn, strMsvcPath);
			}
		}

		if (bFoundVCSpawn)
		{
			CComBSTR strNewExe;
			CComBSTR strNewArgs;

			// Build a new szArgs that looks like this:
			// "vcspawn -t -p d:\Path\MyDebuggee arg1 arg2..."
			strNewArgs = L"-t -p \"";
			strNewArgs += pDebugTargetInfo->bstrExe;
			strNewArgs += "\" ";
			strNewArgs += pDebugTargetInfo->bstrArg;

			SysFreeString(pDebugTargetInfo->bstrExe);
			strNewExe = szPathToSpawn;
			pDebugTargetInfo->bstrExe = strNewExe.Detach();

			SysFreeString(pDebugTargetInfo->bstrArg);
			pDebugTargetInfo->bstrArg = strNewArgs.Detach();
		}
	}

	if (bRemote)
	{
		// need to tell Engine where local path is
		CComBSTR bstrLocalPath;
		get_Command(&bstrLocalPath );
		DoEvaluate(spPropContainer, bstrLocalPath);

		INT_PTR nLen = bstrLocalPath.Length();
		bstrOptionString.Append(L";LOCALPATH=\"");
		if (nLen)
			bstrOptionString.Append(bstrLocalPath);
		bstrOptionString.Append(L"\"");

		// need to figure out the pdb search path which is directory of local exe
		// if it has a directory path, plus pdbpath if specified
		CComBSTR bstrPDBPath;
		get_PDBPath(&bstrPDBPath);
		DoEvaluate(spPropContainer, bstrPDBPath);

		const wchar_t *pStr = nLen ? wcsrchr(bstrLocalPath,L'\\') : NULL;
		long iSlash = -1;
		if( pStr )
		{
			iSlash = (int)(pStr - bstrLocalPath);
		}


		if (iSlash>=0 || bstrPDBPath.Length()>0 )
		{
			// we have a search path
			bstrOptionString += L";PDBSEARCHPATH=\"";

			if(iSlash>=0)
			{
				// append directory of local exe
				CStringW strPath = bstrLocalPath;
				strPath = strPath.Left(iSlash);
				bstrOptionString += strPath;
			}
			
			if (bstrPDBPath.Length() > 0)
			{
				// append pdb path
				if (iSlash>=0)
				{
					bstrOptionString.Append(";");
				}
				bstrOptionString.Append(bstrPDBPath);
			}
			// complete quote
			bstrOptionString +=	 L"\"";
		}
	} else {
		CComBSTR bstrPDBPath;
		get_PDBPath(&bstrPDBPath);
		DoEvaluate(spPropContainer, bstrPDBPath);
		if (bstrPDBPath.Length() > 0)
		{
			bstrOptionString += L";PDBSEARCHPATH=\"";
			bstrOptionString += bstrPDBPath;
			bstrOptionString +=	 L"\"";
		}
	}

	VARIANT_BOOL bSQL = VARIANT_FALSE;
	get_SQLDebugging(&bSQL);
	if( bSQL == VARIANT_TRUE )
	{
		pDebugTargetInfo->pClsidList = (CLSID*)CoTaskMemAlloc( 2*sizeof(CLSID) );
		RETURN_ON_NULL2(pDebugTargetInfo->pClsidList, E_OUTOFMEMORY);
		pDebugTargetInfo->pClsidList[1] = guidSQLEng;
		pDebugTargetInfo->dwClsidCount = 2;
	}
	else
	{
		pDebugTargetInfo->pClsidList = (CLSID*)CoTaskMemAlloc( sizeof(CLSID) );
		RETURN_ON_NULL2(pDebugTargetInfo->pClsidList, E_OUTOFMEMORY);
		pDebugTargetInfo->dwClsidCount = 1;
	}
	
	if (clsid == guidNativeOnlyEng )
		pDebugTargetInfo->pClsidList[0] = guidNativeOnlyEng;
	else if (clsid == guidCOMPlusNativeEng)
		pDebugTargetInfo->pClsidList[0] = guidCOMPlusNativeEng;
	else
		pDebugTargetInfo->pClsidList[0] = guidNull;

	if (bstrOptionString!=NULL)
	{
		pDebugTargetInfo->bstrOptions = bstrOptionString.Detach();
	}

	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CDebugSettings

STDMETHODIMP CDebugSettings::get_Command(BSTR *pVal)
{
	CHECK_POINTER_VALID(pVal);
	CComBSTR bstrCommand;
	DoGetCommand(bstrCommand, FALSE);
	*pVal = bstrCommand.Detach();
	return S_OK;
}

HRESULT CDebugSettings::DoGetCommand(CComBSTR& bstrCommand, BOOL bEvaluate)
{
	DoGetStrProperty(VCDSID_Command, FALSE, &bstrCommand);
	
	long remoteType = DbgLocal;
	GetIntProperty(VCDSID_Remote, (long *)&remoteType);

	// If we are going to remote debug, then the command is 
	// the remote command
	if (bstrCommand.Length() == 0 && remoteType != DbgLocal)
	{
		CComBSTR bstrRemoteCommand;
		GetStrProperty(VCDSID_RemoteCommand, &bstrRemoteCommand);
		bstrCommand = bstrRemoteCommand;
	}
	else if (bstrCommand.Length() == 0 && m_spProjCfg != NULL)
	{
		ConfigurationTypes cfgType;
		m_spProjCfg->get_ConfigurationType(&cfgType);
		if( cfgType == typeApplication || cfgType == typeUnknown )
			bstrCommand = L"$(TargetPath)";
	}

	if (bEvaluate)
	{
		CComQIPtr<IVCPropertyContainer> spPropContainer = m_spProjCfg;
		if (spPropContainer)
			return spPropContainer->Evaluate(bstrCommand, &bstrCommand);
		else
			return Evaluate(bstrCommand, &bstrCommand);
	}

	return S_OK;
}

STDMETHODIMP CDebugSettings::put_Command(BSTR newVal)
{
	SetStrProperty(VCDSID_Command, newVal);
	if (m_spProjCfg == NULL)	// need to kludge saving off the 'project' file info...
	{
		CComBSTR bstrJunk;
		if (GetStrProperty(VCDSID_BaseCommand, &bstrJunk) == S_FALSE)	// not yet set
			SetStrProperty(VCDSID_BaseCommand, newVal);
	}
	return S_OK;
}

STDMETHODIMP CDebugSettings::get_WorkingDirectory(BSTR *pVal)
{
	CHECK_POINTER_VALID( pVal );
	GetStrProperty(VCDSID_WorkingDirectory, pVal);
	return S_OK;
}

STDMETHODIMP CDebugSettings::put_WorkingDirectory(BSTR newVal)
{
	SetStrProperty(VCDSID_WorkingDirectory, newVal);
	m_bWorkingDirInit = TRUE;
	return S_OK;
}

STDMETHODIMP CDebugSettings::get_CommandArguments(BSTR *pVal)
{
	CHECK_POINTER_VALID( pVal );
	GetStrProperty(VCDSID_CommandArguments, pVal);
	return S_OK;
}

STDMETHODIMP CDebugSettings::put_CommandArguments(BSTR newVal)
{
	SetStrProperty(VCDSID_CommandArguments, newVal);
	return S_OK;
}

STDMETHODIMP CDebugSettings::get_Attach(VARIANT_BOOL *pVal)
{
	CHECK_POINTER_VALID(pVal);
	GetBoolProperty(VCDSID_Attach, pVal);
	return S_OK;
}

STDMETHODIMP CDebugSettings::put_Attach(VARIANT_BOOL newVal)
{
	SetBoolProperty(VCDSID_Attach, newVal);
	return S_OK;
}

STDMETHODIMP CDebugSettings::get_SQLDebugging(VARIANT_BOOL *pVal)
{
	CHECK_POINTER_VALID(pVal);
	GetBoolProperty(VCDSID_SQLDebugging, pVal);
	return S_OK;
}

STDMETHODIMP CDebugSettings::put_SQLDebugging(VARIANT_BOOL newVal)
{
	SetBoolProperty(VCDSID_SQLDebugging, newVal);
	return S_OK;
}

STDMETHODIMP CDebugSettings::get_Remote(RemoteDebuggerType *pVal)
{
	CHECK_POINTER_VALID( pVal );
	GetIntProperty(VCDSID_Remote, (long *)pVal);
	return S_OK;
}

STDMETHODIMP CDebugSettings::put_Remote(RemoteDebuggerType newVal)
{
	SetIntProperty(VCDSID_Remote, newVal);
	return S_OK;
}

STDMETHODIMP CDebugSettings::get_RemoteMachine(BSTR *pVal)
{
	CHECK_POINTER_VALID( pVal );
	GetStrProperty(VCDSID_RemoteMachine, pVal);
	return S_OK;
}

STDMETHODIMP CDebugSettings::put_RemoteMachine(BSTR newVal)
{
	SetStrProperty(VCDSID_RemoteMachine, newVal);
	return S_OK;
}

STDMETHODIMP CDebugSettings::get_RemoteCommand(BSTR *pVal)
{
	CHECK_POINTER_VALID( pVal );
	GetStrProperty(VCDSID_RemoteCommand, pVal);
	return S_OK;
}

STDMETHODIMP CDebugSettings::put_RemoteCommand(BSTR newVal)
{
	SetStrProperty(VCDSID_RemoteCommand, newVal);
	return S_OK;
}

STDMETHODIMP CDebugSettings::get_HttpUrl(BSTR *pVal)
{
	CHECK_POINTER_VALID( pVal );
	GetStrProperty(VCDSID_HttpUrl, pVal);
	return S_OK;
}

STDMETHODIMP CDebugSettings::put_HttpUrl(BSTR newVal)
{
	SetStrProperty(VCDSID_HttpUrl, newVal);
	return S_OK;
}

STDMETHODIMP CDebugSettings::get_PDBPath(BSTR *pbstrVal)
{
	CHECK_POINTER_VALID( pbstrVal );
	GetStrProperty(VCDSID_PDBPath, pbstrVal);
	return S_OK;
}

STDMETHODIMP CDebugSettings::put_PDBPath(BSTR bstrNewVal)
{
	SetStrProperty(VCDSID_PDBPath, bstrNewVal);
	return S_OK;
}

STDMETHODIMP CDebugSettings::get_DebuggerType(TypeOfDebugger *pVal)
{
	CHECK_POINTER_VALID( pVal );
	GetIntProperty(VCDSID_DebuggerType, (long *)pVal);
	return S_OK;
}

STDMETHODIMP CDebugSettings::put_DebuggerType(TypeOfDebugger newVal)
{
	SetIntProperty(VCDSID_DebuggerType, newVal);
	return S_OK;
}

STDMETHODIMP CDebugSettings::Close()
{
	m_spProjCfg.Release();
	FinishClose();
	return S_OK;
}

STDMETHODIMP CDebugSettings::WriteToStream(IStream *pStream)
{
	HRESULT		hr;
	// Write out version field first
	long lVersion = 0x00010000;
	hr = WritePropertyToStream(pStream, lVersion, VCDSID_Version );
	RETURN_ON_FAIL(hr);

	//Write out all properties
	CComBSTR bstrCommand;
	GetStrProperty(VCDSID_Command, &bstrCommand);
	hr = WritePropertyToStream(pStream, bstrCommand, VCDSID_Command);
	RETURN_ON_FAIL(hr);

	CComBSTR bstrWorkingDir;
	GetStrProperty(VCDSID_WorkingDirectory, &bstrWorkingDir);
	hr = WritePropertyToStream(pStream, bstrWorkingDir, VCDSID_WorkingDirectory); 
	RETURN_ON_FAIL(hr);

	CComBSTR bstrCommandArgs;
	GetStrProperty(VCDSID_CommandArguments, &bstrCommandArgs);
	hr = WritePropertyToStream(pStream, bstrCommandArgs, VCDSID_CommandArguments); 
	RETURN_ON_FAIL(hr);

	VARIANT_BOOL bAttach = VARIANT_FALSE;
	GetBoolProperty(VCDSID_Attach, &bAttach);
	hr = WritePropertyToStream(pStream, bAttach, VCDSID_Attach); 
	RETURN_ON_FAIL(hr);

	long debuggerType = DbgAuto;
	GetIntProperty(VCDSID_DebuggerType, &debuggerType);
	hr = WritePropertyToStream(pStream, debuggerType, VCDSID_DebuggerType); 
	RETURN_ON_FAIL(hr);

	long remoteType = DbgLocal;
	GetIntProperty(VCDSID_Remote, (long *)&remoteType);
	hr = WritePropertyToStream(pStream, remoteType, VCDSID_Remote);
	RETURN_ON_FAIL(hr);

	CComBSTR bstrRemoteCommand;
	GetStrProperty(VCDSID_RemoteCommand, &bstrRemoteCommand);
	hr = WritePropertyToStream(pStream, bstrRemoteCommand, VCDSID_RemoteCommand);
	RETURN_ON_FAIL(hr);

	CComBSTR bstrRemoteMachine;
	GetStrProperty(VCDSID_RemoteMachine, &bstrRemoteMachine);
	hr = WritePropertyToStream(pStream, bstrRemoteMachine, VCDSID_RemoteMachine);
	RETURN_ON_FAIL(hr);

	CComBSTR bstrHttpUrl;
	GetStrProperty(VCDSID_HttpUrl, &bstrHttpUrl);
	hr = WritePropertyToStream(pStream, bstrHttpUrl, VCDSID_HttpUrl);
	RETURN_ON_FAIL(hr);

	CComBSTR bstrPDBPath;
	GetStrProperty(VCDSID_PDBPath, &bstrPDBPath);
	hr = WritePropertyToStream(pStream, bstrPDBPath, VCDSID_PDBPath);
	RETURN_ON_FAIL(hr);
	
	VARIANT_BOOL bSQL = VARIANT_FALSE;
	GetBoolProperty(VCDSID_SQLDebugging, &bSQL);
	hr = WritePropertyToStream(pStream, bSQL, VCDSID_SQLDebugging);
	RETURN_ON_FAIL(hr);

	//Write "end of property list" marker
	VARTYPE type = VT_EMPTY;
	ULONG	iByteCount;
	hr = pStream->Write(&type, sizeof(VARTYPE), &iByteCount);
	RETURN_ON_FAIL(hr);

	return S_OK;
}

STDMETHODIMP CDebugSettings::ReadFromStream(IStream *pStream)
{
	VARTYPE		type;
	ULONG		iByteCount;
	DISPID		dispid;
	HRESULT		hr;
	long		lVersion;

	while (true)
	{
		//Read in type
		hr = pStream->Read(&type, sizeof(VARTYPE), &iByteCount);
		RETURN_ON_FAIL(hr);

		//End of list marker
		if (type == VT_EMPTY) break;

		//Read in dispid
		hr = pStream->Read(&dispid, sizeof(DISPID), &iByteCount);
		RETURN_ON_FAIL(hr);

		switch (type)	//Switch the property types
		{
			case VT_BOOL:
				switch (dispid)
				{
					case VCDSID_Attach:
					{
						VARIANT_BOOL bAttach = VARIANT_FALSE;
						hr = pStream->Read(&bAttach, sizeof(VARIANT_BOOL), &iByteCount);
						SetBoolProperty(VCDSID_Attach, bAttach);
					}
						break;
					case VCDSID_SQLDebugging:
					{
						VARIANT_BOOL bSQL = VARIANT_FALSE;
						hr = pStream->Read(&bSQL, sizeof(VARIANT_BOOL), &iByteCount);
						SetBoolProperty(VCDSID_SQLDebugging, bSQL);
					}
						break;

					default:
						return E_UNEXPECTED;
				}
				RETURN_ON_FAIL(hr);
				break;
	
			case VT_I4:
				switch (dispid)
				{
					case VCDSID_Version:
						hr = pStream->Read(&lVersion, sizeof(DWORD), &iByteCount);
						if (lVersion!=0x00010000)
						{
							OutputDebugStringW(L"VCDebugSettings:wrong version, settings discarded\n");
							return S_OK;						// if version not understood, abort rest of props entirely
						}
						break;

					case VCDSID_DebuggerType:
						{
							TypeOfDebugger debuggerType = DbgAuto;
							hr = pStream->Read(&debuggerType, sizeof(debuggerType), &iByteCount );
							SetIntProperty(VCDSID_DebuggerType, debuggerType);
						}
						break;

					case VCDSID_Remote:
						{
							RemoteDebuggerType remoteType = DbgLocal;
							hr = pStream->Read(&remoteType, sizeof(remoteType), &iByteCount );
							SetIntProperty(VCDSID_Remote, remoteType);
						}
						break;

					default:
						return E_UNEXPECTED;
				}
				RETURN_ON_FAIL(hr);
				break;
	
			case VT_BSTR:
				switch (dispid)
				{
					case VCDSID_Command:
						{
							CComBSTR bstrCommand;
							hr = bstrCommand.ReadFromStream(pStream);
							SetStrProperty(VCDSID_Command, bstrCommand);
						}
						break;

					case VCDSID_WorkingDirectory:
						{
							CComBSTR bstrWorkingDir;
							hr = bstrWorkingDir.ReadFromStream(pStream);
							SetStrProperty(VCDSID_WorkingDirectory, bstrWorkingDir);
						}
						break;

					case VCDSID_CommandArguments:
						{
							CComBSTR bstrCommandArgs;
							hr = bstrCommandArgs.ReadFromStream(pStream);
							SetStrProperty(VCDSID_CommandArguments, bstrCommandArgs);
						}
						break;

					case VCDSID_RemoteCommand:
						{
							CComBSTR bstrRemoteCommand;
							hr = bstrRemoteCommand.ReadFromStream(pStream);
							SetStrProperty(VCDSID_RemoteCommand, bstrRemoteCommand);
						}
						break;

					case VCDSID_RemoteMachine:
						{
							CComBSTR bstrRemoteMachine;
							hr = bstrRemoteMachine.ReadFromStream(pStream);
							SetStrProperty(VCDSID_RemoteMachine, bstrRemoteMachine);
						}
						break;

					case VCDSID_HttpUrl:
						{
							CComBSTR bstrHttpUrl;
							hr = bstrHttpUrl.ReadFromStream(pStream);
							SetStrProperty(VCDSID_HttpUrl, bstrHttpUrl);
						}
						break;

					case VCDSID_PDBPath:
						{
							CComBSTR bstrPDBPath;
							hr = bstrPDBPath.ReadFromStream(pStream);
							SetStrProperty(VCDSID_PDBPath, bstrPDBPath);
						}
						break;
					
					default:
						return E_UNEXPECTED;
				}
				RETURN_ON_FAIL(hr);
				break;

			default:
				return E_UNEXPECTED;
		}
	}
	return S_OK;
}

HRESULT CDebugSettings::DoGetProp(long id, BOOL bCheckSpecial, VARIANT* pVarValue)
{
	if (bCheckSpecial && id == VCDSID_Command)	// we can figure this one out if not there already
	{
		CHECK_POINTER_NULL(pVarValue);
		CComBSTR bstrCommand;
		DoGetCommand(bstrCommand, FALSE);

		CComVariant varVal;
		varVal = bstrCommand;
		varVal.Detach(pVarValue);
		return S_OK;
	}

	return CPropertyContainerImpl::DoGetProp(id, bCheckSpecial, pVarValue);
}

STDMETHODIMP CDebugSettings::GetMultiProp(long id, LPCOLESTR szSeparator, VARIANT_BOOL bSkipLocal, BSTR *pbstrValue)
{
	CHECK_POINTER_NULL(pbstrValue);

	// all properties are single props to the debugger
	return GetStrProperty(id, pbstrValue);
}

HRESULT CDebugSettings::DoGetStrProperty(long idProp, BOOL bCheckSpecial, BSTR* pbstrValue)
{
	if (idProp == VCDSID_Command && bCheckSpecial)	// we can figure this one out if not there already
	{
		CHECK_POINTER_NULL(pbstrValue);
		CComBSTR bstrCmd;
		DoGetCommand(bstrCmd, FALSE);
		*pbstrValue = bstrCmd.Detach();
		return S_OK;
	}

	return CPropertyContainerImpl::DoGetStrProperty(idProp, bCheckSpecial, pbstrValue);
}

STDMETHODIMP CDebugSettings::GetStagedPropertyContainer(VARIANT_BOOL bCreateIfNecessary, IVCStagedPropertyContainer** ppPropContainer)
{
	if (m_spProjCfg)
		return CPropertyContainerImpl::GetStagedPropertyContainer(bCreateIfNecessary, ppPropContainer);

	CHECK_POINTER_NULL(ppPropContainer);

	if (!m_spStagedContainer)
	{
		if (bCreateIfNecessary)
		{
			HRESULT hr = CVCStagedExeConfigPropertyContainer::CreateInstance(this, &m_spStagedContainer);
			RETURN_ON_FAIL(hr);
		}
		else
		{
			*ppPropContainer = NULL;
			return S_OK;
		}
	}

	return m_spStagedContainer.CopyTo(ppPropContainer);
}

// get the value of a macro
BOOL CDebugSettingsBase::GetMacroValue(UINT idMacro, CStringW& strMacroValue, IVCPropertyContainer* pPropContainer)
{
	if (CallBaseGetMacroValue(pPropContainer))
		return CProjectEvaluator::GetMacroValue(idMacro, strMacroValue, pPropContainer);

	CStringW strTemp;
	CPathW path;

	// empty macro-value
	strMacroValue.Empty();

	HRESULT hr = S_OK;

	switch (idMacro)
	{
		// output directory
		case IDMACRO_OUTDIR:
			strMacroValue = L'.';
			break;

		case IDMACRO_ENVDIR:
		case IDMACRO_SOLNDIR:
		case IDMACRO_SOLNPATH:
		case IDMACRO_SOLNBASE:
		case IDMACRO_SOLNFILE:
		case IDMACRO_SOLNEXT:
		case IDMACRO_INHERIT:
		case IDMACRO_NOINHERIT:
			return CProjectEvaluator::GetMacroValue(idMacro, strMacroValue, pPropContainer);
			break;

		case IDMACRO_PROJDIR:	// project directory
		case IDMACRO_TARGDIR:	// target directory
		case IDMACRO_INPTDIR:	// input can only be the project/target
		{
			if (GetExeProjectTargetPath(path, strMacroValue))
			{
				CDirW dir;
				if (dir.CreateFromPath(path))
					strMacroValue = (const wchar_t*)dir;
			}
			break;
		}

		case IDMACRO_PROJPATH:	// full path of project
		case IDMACRO_TARGPATH:	// full path of target
		case IDMACRO_INPTPATH:	// input can only be the project/target
		{
			CComBSTR bstrProjFile;
			if (SUCCEEDED(GetEvaluatedStrProperty(VCDSID_BaseCommand, &bstrProjFile)))
				strMacroValue = bstrProjFile;
			break;
		}

		case IDMACRO_PROJBASE:	// project file basename
		case IDMACRO_TARGBASE:	// target file basename
		case IDMACRO_INPTBASE:	// input can only be the project/target
		{
			if (GetExeProjectTargetPath(path, strMacroValue))
			{
				path.GetBaseNameString(strTemp);
				if (!strTemp.IsEmpty())
					strMacroValue = strTemp;
			}
			break;
		}

		case IDMACRO_PROJFILE:	// file name of project
		case IDMACRO_TARGFILE:	// file name of target
		case IDMACRO_INPTFILE:	// input can only be the project/target
		{
			if (GetExeProjectTargetPath(path, strMacroValue))
			{
				strTemp = path.GetFileName();
				if (!strTemp.IsEmpty())
					strMacroValue = strTemp;
			}
			break;
		}

		case IDMACRO_PROJEXT:	// file extension of project
		case IDMACRO_TARGEXT:	// file extension of target
		case IDMACRO_INPTEXT:	// input can only be the project/target
		{
			if (GetExeProjectTargetPath(path, strMacroValue))
			{
				strTemp = path.GetExtension();
				if (!strTemp.IsEmpty())
					strMacroValue = strTemp;
			}
			break;
		}

		// didn't deal with this
//		case IDMACRO_PLATNAME:
//		case IDMACRO_INTDIR:
//		case IDMACRO_CFGNAME:
		default:
			return FALSE;	// invalid
	}

	return TRUE;	// ok
}

BOOL CDebugSettingsBase::GetExeProjectTargetPath(CPathW& rProjPath, CStringW& rstrProjPath)
{
	CComBSTR bstrProjPath;
	HRESULT hr = GetEvaluatedStrProperty(VCDSID_BaseCommand, &bstrProjPath);
	VSASSERT(SUCCEEDED(hr), "Should always be able to get base command for an exe project!");
	rstrProjPath = bstrProjPath;
	if (rstrProjPath.IsEmpty())
		return FALSE;

	if (rProjPath.CreateFromKnown(rstrProjPath))
		return TRUE;

	VSASSERT(FALSE, "Failed to create project directory path");
	return FALSE;
}

///////////////////////////////////////////////////////////////////////////////
// CDebugSettings::GetEngineForDebuggerType
// 
// Description: Returns the CLSID for a debug engine that best matches the 
//		debugger type supplied.
//
void CDebugSettings::GetEngineForDebuggerType(TypeOfDebugger debuggerType, const IMAGE_INFO* pImageInfo, CLSID* pClsid)
{
	VSASSERT(pClsid != NULL, __FUNCTION__ "() - pClsid can't be null");
	if (pClsid == NULL)
		return;

	switch (debuggerType)
	{
		case DbgNativeOnly:
			*pClsid = guidNativeOnlyEng;
			break;

		case DbgManagedOnly:
			*pClsid = guidCOMPlusOnlyEng;
			break;

		case DbgMixed:
			*pClsid = guidCOMPlusNativeEng;
			break;

		case DbgAuto:
		{
			*pClsid = guidNativeOnlyEng;	// Assume we'll wind up with hard-mode native debugging.

			// DbgAuto means look at the project type and see if it is managed or not
			// If it contains managed, then use Mixed, else look at the .exe
			CComPtr<IDispatch> pDispTools;
			CComQIPtr<IVCCollection> pCollTools;
			CComPtr<IDispatch> pDispCompiler;

			if (m_spProjCfg && (m_spProjCfg->get_Tools(&pDispTools) == S_OK))
			{
				pCollTools = pDispTools;

				if (pCollTools)
				{
					HRESULT hr = pCollTools->Item(CComVariant("C/C++ Compiler Tool"), &pDispCompiler);
					if ((hr == S_OK) && pDispCompiler)
					{
						CComQIPtr<VCCLCompilerTool> pCompiler = pDispCompiler;
						compileAsManagedOptions managedExt;

						if (pCompiler)
						{
							hr = pCompiler->get_CompileAsManaged( &managedExt );		// S_FALSE is a common return
							if (SUCCEEDED(hr))
							{
								// REVIEW: how should this be handled when there is just managed meta-data (/clr or /clr:noAssembly)?
								if (managedExt == managedAssembly)
									*pClsid = guidCOMPlusNativeEng;
							}
						}
					}
				}
			}
			else // Project type doesn't specify managed, so check the exe's image.
			{
				if (pImageInfo)
				{
					switch(pImageInfo->ImageType)
					{
						case IMAGE_TYPE_WIN32:
							if (pImageInfo->u.Win32.ManagedCode)
							{
								*pClsid = guidCOMPlusOnlyEng;
							}
							break;
			
						case IMAGE_TYPE_WIN64:
						case IMAGE_TYPE_CRASHDUMP:
							break;
					}
				}
			}
		}
		break;
	}
}


void CDebugSettingsPage::ResetParentIfNeeded()
{
	CComQIPtr<IVCStagedPropertyContainer> spStagedContainer = m_pContainer;
	CComPtr<IVCPropertyContainer> spLiveContainer;
	if (spStagedContainer)
		spStagedContainer->get_Parent(&spLiveContainer);
	if (spLiveContainer == NULL)
		spLiveContainer = m_pContainer;
	CComQIPtr<VCConfiguration> spProjCfg = spLiveContainer;
	if (spProjCfg)
	{
		if (spStagedContainer)
			spStagedContainer->ReleaseStagedContainer();

		// this is not an exe project so find the debug settings object to go with this.
		CComPtr<IDispatch> spDispDbgSettings;
		spProjCfg->get_DebugSettings(&spDispDbgSettings);
		CComQIPtr<VCDebugSettings> spDbgSettings = spDispDbgSettings;
		VSASSERT(spDbgSettings != NULL, "Config probably not initialized correctly.");

		spStagedContainer.Release();
		spLiveContainer = spDbgSettings;
		if (spLiveContainer)
		{
			spLiveContainer->GetStagedPropertyContainer(VARIANT_TRUE, &spStagedContainer);
			CComQIPtr<IVCPropertyContainer> spContainer = spStagedContainer;
			if (spContainer)
			{
				spLiveContainer = spContainer;
				spStagedContainer = spContainer;
				if (spStagedContainer)
					spStagedContainer->HoldStagedContainer();
			}
		}

		m_pContainer = spLiveContainer;
	}
}

void CDebugSettingsPage::GetBaseDefault(long id, CComVariant& varValue)
{
	if (id == VCDSID_Command)
	{
		CComBSTR bstrVal;
		SGetCommand(&bstrVal);
		varValue = bstrVal;
	}
	else
		CBase::GetBaseDefault(id, varValue);
}

HRESULT CDebugSettingsPage::SGetCommand(BSTR* pVal)
{
	CComQIPtr<IVCStagedPropertyContainer> spStagedContainer = m_pContainer;
	CComQIPtr<IVCPropertyContainer> spParent;
	if (spStagedContainer)
		spStagedContainer->get_Parent(&spParent);
	if (spParent == NULL)
		spParent = m_pContainer;
	CComQIPtr<VCDebugSettings> spDbgSettings = spParent;
	if (spDbgSettings)
		return spDbgSettings->get_Command(pVal);

	return S_FALSE;
}

STDMETHODIMP CDebugSettingsPage::get_Command(BSTR *pVal)
{
	HRESULT hr = GetStrProperty(VCDSID_Command, pVal);
	if (hr != S_FALSE)
		return hr;

	CComBSTR bstrVal = *pVal;
	if (bstrVal.Length() == 0)
		hr = SGetCommand(pVal);

	return hr;
}

/*static */
HRESULT CDebugSettingsPage::BrowseForCommand( CStringW* pstrCommand, HWND hwndOwner /* = NULL */ )
{
	VSOPENFILENAMEW openFileName = {0};
	CStringW strFilter( MAKEINTRESOURCE( IDS_EXEFilter ));
	CStringW strTitle( MAKEINTRESOURCE( IDS_DebugProgram ));

	strFilter.Replace( L';', 0 );
	strFilter += L'\0';

	openFileName.lStructSize = sizeof (VSOPENFILENAMEW);
	openFileName.hwndOwner = hwndOwner;
	openFileName.pwzDlgTitle = strTitle;
	openFileName.pwzFileName = pstrCommand->GetBuffer( _MAX_PATH );
	openFileName.nMaxFileName = _MAX_PATH;
	openFileName.pwzInitialDir = NULL;
	openFileName.pwzFilter = strFilter;	 
	openFileName.nFilterIndex = 0;
	openFileName.nFileOffset = 0;
	openFileName.nFileExtension = 0;
	openFileName.dwHelpTopic = 0;
	openFileName.dwFlags = 0;

	return static_cast<CVCProjectEngine*>(g_pProjectEngine)->GetOpenFileNameViaDlg( &openFileName );
}


/*
	The UI shows Command as being a dropdrown.	When and item from the 
	dropdown is selected, the "predifined value" we provided is passed 
	in here, converted to a string.	 When the user types into the edit 
	box, what she types is passed
*/
STDMETHODIMP CDebugSettingsPage::put_Command(BSTR newVal)
{

	HRESULT hr = S_OK;

	int id = _wtoi(newVal);
	
	CStringW strCommand;

	{
		CComBSTR bstr;
		GetStrProperty (VCDSID_Command, &bstr);

		strCommand = bstr;
	}

	// NOTE: please update ..\ui_dll\src\exefordbg.h,OnSelectExeForDbg if you update this 
	// switch statement in any way
	switch (id)
	{
	case VCDSID_Command_IExplore:
		//
		// User selected default browser, go find it
		//
		if (FAILED(hr = CDebugSettings::GetBrowserCommand( &strCommand, NULL )))
		{
			VSFAIL ("Couldn't find a browser!");
		}
		break;

	case VCDSID_Command_ATLTest:
		hr = CDebugSettings::GetTestContainerCommand( strCommand );
		break;
		
	case VCDSID_Command_RegSvr:
		hr = CDebugSettings::GetRegSvrCommand( strCommand );
		break;
		
	case VCDSID_Command_Browse:
		hr = BrowseForCommand( &strCommand );
		if (hr != S_OK)
		{
			return hr;
		}
		break;
		
	default:
		//
		// User must have typed something in - use it as-is.
		//
		strCommand = newVal;
		hr = S_OK;
		break;
	}
	
	if (hr != S_OK)
	{
		return hr;
	}

	else
	{
		return SetStrProperty(VCDSID_Command, CComBSTR( strCommand ));
	}
}

STDMETHODIMP CDebugSettingsPage::get_WorkingDirectory(BSTR *pVal)
{
	return GetStrProperty(VCDSID_WorkingDirectory, pVal);
}

STDMETHODIMP CDebugSettingsPage::put_WorkingDirectory(BSTR newVal)
{
	CStringW strNewVal = newVal;
	strNewVal.TrimLeft();
	strNewVal.TrimRight();
	return SetStrProperty(VCDSID_WorkingDirectory, CComBSTR(newVal));
}

STDMETHODIMP CDebugSettingsPage::get_CommandArguments(BSTR *pVal)
{
	return GetStrProperty(VCDSID_CommandArguments, pVal);
}

STDMETHODIMP CDebugSettingsPage::put_CommandArguments(BSTR newVal)
{
	return SetStrProperty(VCDSID_CommandArguments, newVal);
}

STDMETHODIMP CDebugSettingsPage::get_Attach(VARIANT_BOOL *pVal)
{
	return GetBoolProperty(VCDSID_Attach, pVal);
}

STDMETHODIMP CDebugSettingsPage::put_Attach(VARIANT_BOOL newVal)
{
	CHECK_VARIANTBOOL(newVal);
	return SetBoolProperty(VCDSID_Attach, newVal);
}

STDMETHODIMP CDebugSettingsPage::get_SQLDebugging(VARIANT_BOOL *pVal)
{
	return GetBoolProperty(VCDSID_SQLDebugging, pVal);
}

STDMETHODIMP CDebugSettingsPage::put_SQLDebugging(VARIANT_BOOL newVal)
{
	CHECK_VARIANTBOOL(newVal);
	return SetBoolProperty(VCDSID_SQLDebugging, newVal);
}


STDMETHODIMP CDebugSettingsPage::get_Remote(RemoteDebuggerType *pVal)
{
	return GetIntProperty(VCDSID_Remote, (long *)pVal);
}

STDMETHODIMP CDebugSettingsPage::put_Remote(RemoteDebuggerType newVal)
{
	if (newVal != DbgLocal)
	{
		if (newVal == DbgRemoteTCPIP)
		{
			SetIntProperty(VCDSID_DebuggerType, DbgNativeOnly);
		}

		// Put the current machine name as the remote if none
		// is currently specified.
		CComBSTR bstrMachineName;
		GetStrProperty(VCDSID_RemoteMachine, &bstrMachineName);

		if (bstrMachineName == NULL || bstrMachineName[0] == L'\0')
		{
			DWORD dwBufLen = MAX_COMPUTERNAME_LENGTH + 1;
			wchar_t szComputerName[MAX_COMPUTERNAME_LENGTH + 1];
			GetComputerNameW(szComputerName, &dwBufLen);

			CComBSTR bstrComputerName = szComputerName;
			SetStrProperty(VCDSID_RemoteMachine, bstrComputerName);
		}
	}

	m_pPage->Refresh();
	return SetIntProperty(VCDSID_Remote, newVal);
}

STDMETHODIMP CDebugSettingsPage::get_RemoteMachine(BSTR *pVal)
{
	return GetStrProperty(VCDSID_RemoteMachine, pVal);
}

STDMETHODIMP CDebugSettingsPage::put_RemoteMachine(BSTR newVal)
{
	CStringW strNewVal = newVal;
	strNewVal.TrimLeft();
	strNewVal.TrimRight();
	return SetStrProperty(VCDSID_RemoteMachine, CComBSTR(newVal));
}

STDMETHODIMP CDebugSettingsPage::get_DebuggerType(TypeOfDebugger *pVal)
{
	return GetIntProperty(VCDSID_DebuggerType, (long *)pVal);
}

STDMETHODIMP CDebugSettingsPage::put_DebuggerType(TypeOfDebugger newVal)
{
	if (newVal != DbgNativeOnly)
	{
		//
		// Force remote type to not be TCP/IP
		//

		RemoteDebuggerType type;
		if (S_OK == GetIntProperty(VCDSID_Remote, (long *)&type) && type == DbgRemoteTCPIP)
		{
			SetIntProperty(VCDSID_Remote, DbgRemote);
		}
	}
	return SetIntProperty(VCDSID_DebuggerType, newVal);
}

STDMETHODIMP CDebugSettingsPage::get_RemoteCommand(BSTR *pVal)
{
	return GetStrProperty(VCDSID_RemoteCommand, pVal);
}

STDMETHODIMP CDebugSettingsPage::put_RemoteCommand(BSTR newVal)
{
	CStringW strNewVal = newVal;
	strNewVal.TrimLeft();
	strNewVal.TrimRight();
	return SetStrProperty(VCDSID_RemoteCommand, CComBSTR(newVal));
}

STDMETHODIMP CDebugSettingsPage::get_HttpUrl(BSTR *pVal)
{
	return GetStrProperty(VCDSID_HttpUrl, pVal);
}

STDMETHODIMP CDebugSettingsPage::put_HttpUrl(BSTR newVal)
{
	CStringW strNewVal = newVal;
	strNewVal.TrimLeft();
	strNewVal.TrimRight();
	return SetStrProperty(VCDSID_HttpUrl, CComBSTR(strNewVal));
}

STDMETHODIMP CDebugSettingsPage::get_PDBPath(BSTR* pbstrVal)
{
	return GetStrProperty(VCDSID_PDBPath, pbstrVal);
}

STDMETHODIMP CDebugSettingsPage::put_PDBPath(BSTR bstrNewVal)
{
	CStringW strNewVal = bstrNewVal;
	strNewVal.TrimLeft();
	strNewVal.TrimRight();
	return SetStrProperty(VCDSID_PDBPath, CComBSTR(strNewVal));
}

//
// A typesafe CoTaskMemAlloc wrapper
//
template <typename T>
T*
TTaskMemeAlloc(UINT_PTR cItems)
{
	return static_cast <T*> (CoTaskMemAlloc ( (ULONG) cItems * sizeof (T)));
}

#define ELEM_COUNT(x) (sizeof((x))/sizeof((*x)))

/*
	The "predefined strings" are what is shown to the user in a dropdown

	We supply the caller with a mapping of strings (to display) and cookies.  

	Cookie values can be anything unique, and we use the resource IDs of 
	the strings (which we get out of rgDebugCommands).
*/
STDMETHODIMP CDebugSettingsPage::GetPredefinedStrings( DISPID dispID, CALPOLESTR *pCaStringsOut, CADWORD *pCaCookiesOut )
{
	switch (dispID)
	{
	default:
		return CBase::GetPredefinedStrings( dispID, pCaStringsOut, pCaCookiesOut);
		
	case VCDSID_Command:
#ifdef DEBUG
		{
			HRESULT hr;
			CComVariant var;
			hr = CComDispatchDriver::GetProperty( this, dispID, &var );
			VSASSERT (hr == S_OK, "");
			VSASSERT (var.vt == VT_BSTR, "");
		}
#endif
		
		int iItem;
		const int cItems = ELEM_COUNT(rgDebugCommands);
		
		pCaStringsOut->cElems = cItems;
		pCaCookiesOut->cElems = cItems;

		pCaStringsOut->pElems = TTaskMemeAlloc<LPOLESTR> (cItems);
		RETURN_ON_NULL2(pCaStringsOut->pElems, E_OUTOFMEMORY);
			
		pCaCookiesOut->pElems = TTaskMemeAlloc<DWORD> (cItems);
		RETURN_ON_NULL2(pCaCookiesOut->pElems, E_OUTOFMEMORY);
		
		for (iItem = 0; iItem < cItems; iItem++)
		{
			pCaCookiesOut->pElems[iItem] = rgDebugCommands[iItem];
			
			CStringW str (MAKEINTRESOURCE (rgDebugCommands[iItem]));
			VSASSERT (str.GetLength(), "");
			
			pCaStringsOut->pElems[iItem] = TTaskMemeAlloc<OLECHAR>( str.GetLength() + 1 );
			wcscpy( pCaStringsOut->pElems[iItem], str );
		}
		break;
	}
	
	return S_OK;
}

/*
	Here we provide yet another mapping, this time between cookies (which 
	were supplied above) and some variants.	 Whatever you put in the 
	variant will be passed to your put_ function.  The two most obvious 
	options in any implementation are 1) the cookie and 2) the string you 
	passed in last time.

	We return the cookie in the variant.

	I'd say this is very silly.
*/
STDMETHODIMP CDebugSettingsPage::GetPredefinedValue( DISPID dispID, DWORD dwCookie, VARIANT* pVarOut )
{
	switch (dispID)
	{
	default:
		return CBase::GetPredefinedValue (dispID, dwCookie, pVarOut);
	case VCDSID_Command:
		CComVariant( dwCookie ).Detach( pVarOut );
		break;
	}
	return S_OK;
}

STDMETHODIMP CDebugSettingsPage::HideProperty( DISPID dispid, BOOL *pfHide)
{
	CHECK_POINTER_NULL(pfHide);
	if( dispid == VCDSID_SQLDebugging )
	{
		long SKU;
		static_cast<CVCProjectEngine*>(g_pProjectEngine)->GetSKU( &SKU );
		switch( SKU )
		{
			case VSASKUEdition_Book:
			case VSASKUEdition_Standard:
				*pfHide = TRUE;
				break;
			default:
				*pfHide = FALSE;
				break;
		}
	}
	else
		*pfHide = FALSE;
	return S_OK;
};


STDMETHODIMP CDebugSettingsPage::MapPropertyToCategory( DISPID dispid, PROPCAT* ppropcat)
{

	switch( dispid )
	{
		case VCDSID_Command:
		case VCDSID_CommandArguments:
		case VCDSID_WorkingDirectory:
		case VCDSID_Attach:
		case VCDSID_PDBPath:
			*ppropcat = IDS_ACTION;
			break;
		case VCDSID_Remote:
		case VCDSID_RemoteCommand:
		case VCDSID_RemoteMachine:
		case VCDSID_HttpUrl:
			*ppropcat = IDS_REMOTESETTINGS;
			break;
		case VCDSID_DebuggerType:
		case VCDSID_SQLDebugging:
		case VCDSID_BaseCommand:
		default:
			*ppropcat = IDS_DEBUGGERS;
			break;
	}
	return S_OK;
}

STDMETHODIMP CDebugSettingsPage::GetCategoryName( PROPCAT propcat, LCID lcid, BSTR* pbstrName)
{
	CComBSTR bstrCat;
	bstrCat.LoadString(propcat);
	return bstrCat.CopyTo(pbstrName);
}


HRESULT CVCStagedExeConfigPropertyContainer::CreateInstance(IVCPropertyContainer* pParentPropContainer, 
	IVCStagedPropertyContainer **ppStagedPropertyContainer)
{
	CVCStagedExeConfigPropertyContainer *pVar;
	CComObject<CVCStagedExeConfigPropertyContainer> *pObj;
	HRESULT hr = CComObject<CVCStagedExeConfigPropertyContainer>::CreateInstance(&pObj);
	if (SUCCEEDED(hr))
	{
		pVar = pObj;
		pVar->AddRef();
		*ppStagedPropertyContainer = pVar;
		hr = pVar->Initialize(pParentPropContainer);
	}
	return hr;
}

HRESULT CVCStagedExeConfigPropertyContainer::Initialize(IVCPropertyContainer* pParentPropContainer)
{
	m_spParentPropContainer = pParentPropContainer;
	return (m_spParentPropContainer ? S_OK : E_UNEXPECTED);
}

HRESULT CVCStagedExeConfigPropertyContainer::DoGetParentProp(long id, VARIANT_BOOL bAllowInherit, BOOL bCheckSpecialProps, VARIANT* pVarValue)
{
	CHECK_POINTER_NULL(pVarValue);
	RETURN_ON_NULL2(m_spParentPropContainer, S_FALSE);

	if (bAllowInherit)
	{
		if (m_spParentPropContainer->GetProp(id, pVarValue) == S_OK )
			return S_OK;
	}
	else
	{
		if (m_spParentPropContainer->GetLocalProp(id, pVarValue) == S_OK )
			return S_OK;
	}

	// We didn't find it
	return S_FALSE;  
}

STDMETHODIMP CVCStagedExeConfigPropertyContainer::GetMultiProp(long id, LPCOLESTR szSeparator, VARIANT_BOOL bSkipLocal, BSTR *pbstrValue)
{
	CHECK_POINTER_NULL(pbstrValue);
	*pbstrValue = NULL;

	CComBSTR bstrVal;
	
	if (!bSkipLocal)
	{
		// look in here.
		CComVariant var;
		BOOL b;
		b = m_PropMap.Lookup(id, var);
		if( b )
		{
			bstrVal = var.bstrVal;
			*pbstrValue = bstrVal.Detach();
			return S_OK;
		}
		else if (m_spParentPropContainer)
		{
			HRESULT hr = m_spParentPropContainer->GetLocalProp(id, &var);
			if (hr == S_OK)
			{
				bstrVal = var.bstrVal;
				*pbstrValue = bstrVal.Detach();
				return S_OK;
			}
		}
	}
	
	// And check your parents
	if (m_spParentPropContainer && 
		m_spParentPropContainer->GetStrProperty(id, &bstrVal) == S_OK)
	{
		*pbstrValue = bstrVal.Detach();
		return S_OK;
	}

	return S_FALSE;
}

STDMETHODIMP CVCStagedExeConfigPropertyContainer::GetMultiPropSeparator(long id, BSTR* pbstrPreferred, BSTR* pbstrAll)
{
	if (m_spParentPropContainer)
		return m_spParentPropContainer->GetMultiPropSeparator(id, pbstrPreferred, pbstrAll);

	// no parent?  make an educated guess
	CHECK_POINTER_NULL(pbstrPreferred);
	CHECK_POINTER_NULL(pbstrAll);
	CComBSTR bstrPreferred = L";";
	CComBSTR bstrAll = L";,";
	*pbstrPreferred = bstrPreferred.Detach();
	*pbstrAll = bstrAll.Detach();
	return S_OK;
}

STDMETHODIMP CVCStagedExeConfigPropertyContainer::ClearPropertyRange(long nMinID, long nMaxID)
{
	VCPOSITION pos = m_PropMap.GetStartPosition();
	while (pos)
	{
		long key;
		CComVariant varVal;
		m_PropMap.GetNextAssoc(pos, key, varVal);
		if (key >= nMinID && key <= nMaxID)
			m_PropMap.RemoveKey(key);
	}

	return S_OK;
}

STDMETHODIMP CVCStagedExeConfigPropertyContainer::get_Parent(IVCPropertyContainer** ppParent)
{
	CHECK_POINTER_NULL(ppParent);
	return m_spParentPropContainer.CopyTo(ppParent);
}

STDMETHODIMP CVCStagedExeConfigPropertyContainer::GetGrandParentProp(long id, VARIANT *pvarValue)		// skip to parent of our non-staged parent
{
	CHECK_ZOMBIE(m_spParentPropContainer, IDS_ERR_CFG_ZOMBIE);
	return m_spParentPropContainer->GetParentProp(id, VARIANT_TRUE /* allow inherit */, pvarValue);
}

STDMETHODIMP CVCStagedExeConfigPropertyContainer::Close()
{
	m_spParentPropContainer.Release();
	return S_OK;
}

STDMETHODIMP CVCStagedExeConfigPropertyContainer::CommitPropertyRange(long nMinID, long nMaxID)
{
	return DoCommitPropertyRange(nMinID, nMaxID, false);
}

STDMETHODIMP CVCStagedExeConfigPropertyContainer::Commit()
{
	return DoCommitPropertyRange(0, 0, true);
}

HRESULT CVCStagedExeConfigPropertyContainer::DoCommitPropertyRange(long nMinID, long nMaxID, bool bIgnoreRange)
{
	CHECK_ZOMBIE(m_spParentPropContainer, IDS_ERR_CFG_ZOMBIE);

	VCPOSITION iter = m_PropMap.GetStartPosition();
	// iterate over each item in the map
	HRESULT hr = S_OK;
	while( iter && SUCCEEDED(hr))
	{
		long key;
		CComVariant varVal;
		m_PropMap.GetNextAssoc(iter, key, varVal);

		if (!bIgnoreRange && (key < nMinID || key > nMaxID))
			continue;

		BOOL bSetProp = TRUE;
		if ((varVal.vt == VT_I4 && varVal.intVal == INHERIT_PROP_VALUE) || 
			(varVal.vt == VT_I2 && varVal.iVal == INHERIT_PROP_VALUE) || 
			(varVal.vt == VT_BSTR && wcscmp( L"-2", varVal.bstrVal ) == 0))
			bSetProp = FALSE;
		else if (varVal.vt == VT_BSTR && SysStringLen( varVal.bstrVal ) == 0 )
		{
			VARIANT_BOOL bIsMulti = VARIANT_FALSE;
			if (m_spParentPropContainer->IsMultiProp(key, &bIsMulti) != S_OK || bIsMulti == VARIANT_TRUE)
				bSetProp = FALSE;
		}
		if (bSetProp)
			hr = m_spParentPropContainer->SetProp(key, varVal);
		else
			hr = m_spParentPropContainer->Clear(key);
		RETURN_ON_FAIL(hr);
		m_PropMap.RemoveKey(key);
	}

	return S_OK;
}

STDMETHODIMP CVCStagedExeConfigPropertyContainer::NextElement(long* pKey, VARIANT* pVal)
{
	CHECK_POINTER_NULL(pKey);
	*pKey = 0;
	CHECK_POINTER_NULL(pVal);
	RETURN_ON_NULL2(pVal, E_POINTER);
	pVal->vt = VT_EMPTY;

	RETURN_ON_NULL2(m_pos, S_FALSE);

	long id;
	CComVariant var;
	m_PropMap.GetNextAssoc(m_pos, id, var);
	*pKey = id;
	var.Detach(pVal);

	return S_OK;
}

STDMETHODIMP CVCStagedExeConfigPropertyContainer::Reset(void)
{
	m_pos = m_PropMap.GetStartPosition();
	return S_OK;
}

STDMETHODIMP CVCStagedExeConfigPropertyContainer::HasDefaultValue(DISPID dispid, BOOL *pfDefault)
{
	CHECK_POINTER_NULL(pfDefault);
	*pfDefault = FALSE;
	
	// Check if its here and not clear
	CComVariant varVal;
	if( m_PropMap.Lookup(dispid, varVal) )
	{
		if( (varVal.vt == VT_I4 && varVal.intVal == INHERIT_PROP_VALUE) || (varVal.vt == VT_I2 && varVal.iVal == INHERIT_PROP_VALUE) || (varVal.vt == VT_BSTR && wcscmp( L"-2", varVal.bstrVal ) == 0) )
			*pfDefault = TRUE;
		return S_OK;
	}

	// OK so is it in the parent ?
	if (!m_spParentPropContainer || m_spParentPropContainer->GetLocalProp( dispid, NULL ) != S_OK)
		*pfDefault = TRUE;

	return S_OK;
}

STDMETHODIMP CVCStagedExeConfigPropertyContainer::HoldStagedContainer()			// number of calls to Hold/Release StagedContainer need to match
{
	m_cStaged++;
	return S_OK;
}

STDMETHODIMP CVCStagedExeConfigPropertyContainer::ReleaseStagedContainer()		// number of calls to Hold/Release StagedContainer need to match
{
	if (m_cStaged > 0)
		m_cStaged--;
	if (m_cStaged == 0 && m_spParentPropContainer)
		m_spParentPropContainer->ReleaseStagedPropertyContainer();

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\vcpb\dependencygraph.cpp ===
//
// CGrNode, CGraph, CDepGraph
//
// Graph node, dependency graph node, graph and dependency graph classes
//
// [matthewt]
//

#include "stdafx.h"				// our standard AFX include
#pragma hdrstop
#include "BuildEngine.h"
#include "DependencyGraph.h"	// our local header
#include <vccolls.h>
#include "msgboxes2.h"
#include "MRDependencies.h"

#pragma warning(disable:4244) // int to short conversion OK in this file ONLY !

//////////////////////////////////
// CGrNode - generic graph node	//
//////////////////////////////////


// granularity of allocations
#define C_ALLOC_PARENT	2
#define C_ALLOC_CHILD	12
#define C_ALLOC_ROOT	12
#define C_ALLOC_EDGES	C_ALLOC_CHILD

#ifdef _KIPDEBUG
	int CGrNode::nCount = 0;
#endif

// constructor+destructor
CGrNode::CGrNode(CGraph* pgraph, NID nid, USHORT cChildren /* = 0 */, USHORT iDepth /* = 0 */)
{
	// this graph node's identifier
	m_nid = nid;

	// this graph node's depth
#ifdef DEPGRAPH_VIEW
	m_iDepth = iDepth;
#endif // DEPGRAPH_VIEW

	// initialise
	m_rgChildren = m_rgParents = (CGrNode**)NULL;
	m_allocChildren = m_allocParents = 0;
	m_rgEdges = (EID *)NULL;

	// layout related
#ifdef DEPGRAPH_VIEW
	m_pgrnAlias = m_pgrnPrev = 	m_pgrnNext = (CGrNode *)NULL;
	m_iParent = 0;
	m_cReversed = 0;
	m_cost = 0xffff;
	m_iPos = 0;
	m_fFake = FALSE;
	m_fWorking = FALSE;
	m_fRecursive = FALSE;
#endif // DEPGRAPH_VIEW

	m_cParents = 0;
	m_cChildren = cChildren;
	m_fVisited = FALSE;

#ifdef DEPGRAPH_VIEW
	m_pgraph = pgraph;
#endif

	m_GrNfyRx = NULL;

	// pre-allocate some children?
	if (m_cChildren)
	{
		m_allocChildren += m_cChildren;

		m_rgChildren = new CGrNode *[m_allocChildren];
		m_rgEdges = new EID[m_allocChildren];
	}

#ifdef _KIPDEBUG
	nCount++;
#endif
}

CGrNode::~CGrNode()
{
	// inform that we are being deleted
	InformGrNfyRx(GrEvt_Destroy);
	 
	// delete our storage
	if (m_rgParents)	delete []m_rgParents;
	if (m_rgChildren)	delete []m_rgChildren;
	if (m_rgEdges)		delete []m_rgEdges;
}

// add or remove graph node event receivers
void CGrNode::AddGrNfyRx(CGrNfyRx* pgrnfyrx)
{	
	VSASSERT(m_GrNfyRx == NULL, "Can only call AddGrNfyRx once!");
	m_GrNfyRx = pgrnfyrx;
}

void CGrNode::RemoveGrNfyRx(CGrNfyRx* pgrnfyrx)
{
#ifdef _DEBUG
	if (m_GrNfyRx != NULL)
		VSASSERT(m_GrNfyRx == pgrnfyrx, "Trying to remove wrong GrNfyRx!");
#endif
	m_GrNfyRx = NULL;
}

void CGrNode::InformGrNfyRx(UINT grevt, void* pvhint)
{
	if (m_GrNfyRx == NULL)
		return;
	m_GrNfyRx->OnGrNfy(grevt, this, pvhint);
}

// add a new child to this node
void CGrNode::AddChild(CGrNode* pgrn, EID eid /* = (EID)0 */)
{
	if (pgrn == NULL)
		return;

	// allocate our new array of children?
	BOOL fRealloc = m_cChildren >= m_allocChildren;

	CGrNode** rgChildren = m_rgChildren; 
	EID* rgEdges = m_rgEdges;
	
	// re-alloc?
	if (fRealloc)
	{
		m_allocChildren += C_ALLOC_CHILD;
		rgChildren = new CGrNode *[m_allocChildren];
		rgEdges = new EID[m_allocChildren];
		if (rgChildren == NULL || rgEdges == NULL)
			return;

		// move current children
		if (m_cChildren)
		{
			memcpy(rgChildren, m_rgChildren, m_cChildren * sizeof(CGrNode *));
			memcpy(rgEdges, m_rgEdges, m_cChildren * sizeof(EID));
		}
	}
	 
	// insert child + edge into child + edge list
	rgChildren[m_cChildren] = pgrn;
	rgEdges[m_cChildren] = eid;

	// remember our new array?
	if (fRealloc)
	{

		if (m_rgChildren) 
			delete []m_rgChildren;
		if (m_rgEdges) 
			delete []m_rgEdges;

		m_rgChildren = rgChildren;
		m_rgEdges = rgEdges;
	}

	// increment our child count
	m_cChildren++;

	// inform
	InformGrNfyRx(GrEvt_AddChild, (void *)pgrn->Nid()); 
//	InformGrNfyRx(GrEvt_AddEdge, (void *)eid); 

	//
	// add ourselves as a parent of this node
	//

	// allocate our new array of parents for it?
	fRealloc = pgrn->m_cParents >= pgrn->m_allocParents;
 	CGrNode** rgParents = pgrn->m_rgParents;
	
	if (fRealloc)
	{
		pgrn->m_allocParents += C_ALLOC_PARENT;
		rgParents = new CGrNode *[pgrn->m_allocParents];

		// move current parents
		if(pgrn->m_cParents)
			memcpy(rgParents, pgrn->m_rgParents, pgrn->m_cParents * sizeof(CGrNode *));
	}

	// insert ourselves as a parent
	rgParents[pgrn->m_cParents] = this;

	// remember our new array?
	if (fRealloc)
	{
		if (pgrn->m_rgParents) delete []pgrn->m_rgParents;
		pgrn->m_rgParents = rgParents;
	}

	// increment their parent count
	pgrn->m_cParents++;

	// inform
	pgrn->InformGrNfyRx(GrEvt_AddParent, (void *)this->Nid());
}

// remove a child (referenced by index)
void CGrNode::DelChild(USHORT iChild)
{
	// ensure within our bounds
	VSASSERT(m_cChildren > 0 && iChild < m_cChildren, "Trying to delete out of bounds child!");

	// remember the child before removal
	CGrNode* pgrn = m_rgChildren[iChild];
	EID eid = m_rgEdges[iChild];

	// remove this child
	while (iChild + 1 < m_cChildren)
	{
		m_rgChildren[iChild] = m_rgChildren[iChild+1];
		m_rgEdges[iChild] = m_rgEdges[iChild+1];
		iChild++;
	}

	// decrement our child count
	m_cChildren--;

	// inform
	InformGrNfyRx(GrEvt_DelChild, (void *)pgrn->Nid());
//	InformGrNfyRx(GrEvt_DelEdge, (void *)eid); 

	// remove ourselves as a parent?
	if (pgrn->m_cParents)
	{
		BOOL fFound = FALSE;
		USHORT iParent = 0;
		while (iParent < pgrn->m_cParents)
		{
			// if found then remove parent
			if (fFound)
				pgrn->m_rgParents[iParent - 1] = pgrn->m_rgParents[iParent];

			// if ~found then search for parent
			else
				fFound = (pgrn->m_rgParents[iParent] == this);

			iParent++;
		}

		// make sure we found the parent
		VSASSERT(fFound, "Failed to find the node's parent!");

		// decrement their parent count
		pgrn->m_cParents--;

		// inform
		pgrn->InformGrNfyRx(GrEvt_DelParent, (void *)this);
	}
}

//////////////////////////////////
// CGrNode - generic graph node	//
//////////////////////////////////

CDepGrNode::CDepGrNode(CBldFileDepGraph* pgraph, CBldFileRegistry* pregistry, BldFileRegHandle frh)
	: CGrNode(pgraph, (NID)frh)
{
	// store the file registry
	m_pregistry = pregistry;

	// initialise
	m_state = DS_Unknown;
	m_fIgnoreDepcy = pgraph->m_mode != Graph_Stable; 

	if (!m_fIgnoreDepcy)
		(void) m_frsDepcy.CalcAttributes();

	// add ourselves as a Rx of file change events
	// of both the dependent and dependency
	m_pregistry->GetRegEntry(Frh())->AddNotifyRx(this, FALSE);

	if (!m_fIgnoreDepcy)
		m_frsDepcy.AddNotifyRx(this, FALSE);

	// dependency list at last build attempt is not dirty
	m_fDirtyDepLst = FALSE;

	// add a reference to this registry entry
	Frh()->AddFRHRef();

#ifdef _DEBUG_BLD
	wchar_t * pchDep;
	CBldFileRegEntry * preg = m_pregistry->GetRegEntry(Frh());

	if (preg->IsNodeType(CBldFileRegNotifyRx::nodetypeRegSet))
		pchDep = L"set";
	else
		pchDep = (wchar_t *)(const wchar_t *)*preg->GetFilePath();
#endif // _DEBUG_BLD
}

CDepGrNode::~CDepGrNode()
{
	// inform that we are being deleted
	InformGrNfyRx(GrEvt_Destroy);

#ifdef _DEBUG_BLD
	wchar_t * pchDep;
	CBldFileRegEntry* preg = m_pregistry->GetRegEntry(Frh());

	if (preg->IsNodeType(CBldFileRegNotifyRx::nodetypeRegSet))
		pchDep = L"set";
	else
		pchDep = (wchar_t *)(const wchar_t *)*preg->GetFilePath();
 #endif // _DEBUG_BLD

	// remove ourselves as a Rx of file change events of both the dependent and dependency
	m_pregistry->GetRegEntry(Frh())->RemoveNotifyRx(this);
	
	if (!m_fIgnoreDepcy)
		m_frsDepcy.RemoveNotifyRx(this);

	// assert that we don't have any dependencies
	VSASSERT(m_frsDepcy.IsEmpty(), "We shouldn't have dependencies at this point!");

	// remove a reference to this registry entry
	Frh()->ReleaseFRHRef();
}

// graph mode changed
void CDepGrNode::OnGraphMode(UINT newmode)
{
	// what would be our new state?
	BOOL fIgnoreDepcy = newmode != Graph_Stable; 

	// changed?
	if (m_fIgnoreDepcy != (USHORT)fIgnoreDepcy)
	{
		// remove ourselves as a dependency
		m_frsDepcy.RemoveNotifyRx(this);

		// empty our dependency set
		m_frsDepcy.EmptyContent();

		if (!fIgnoreDepcy)
		{
			// turn-off incr. calc. of attributes
			(void) m_frsDepcy.CalcAttributes(FALSE);

			// add new dependencies to our set
			for (USHORT iChild = CChildren(); iChild > 0; iChild--)
			{
				CDepGrNode* pgrnDep = (CDepGrNode *)Child(iChild - 1);
				m_frsDepcy.AddRegHandle(pgrnDep->Frh(), NULL);
			}

			// turn back on incr. calc. of attributes
			(void) m_frsDepcy.CalcAttributes();

			// update our dependency state
			FigureDepState();

			// add ourselves as a dependency now
			m_frsDepcy.AddNotifyRx(this, TRUE);
		}

		// dependency list at last build attempt is dirty   
		m_fDirtyDepLst = TRUE;

		m_fIgnoreDepcy = (USHORT)fIgnoreDepcy;
	}
}

// Rx for file change events
void CDepGrNode::OnNotify(BldFileRegHandle hndFileReg, IVCBuildErrorContext* pEC, UINT idChange, void* pHint)
{
	// which type of file change event?
	switch (idChange)
	{
		// newest timestamp changes?
		case P_NewTStamp:

		// existence of dependencies?
		case P_ExistsOnDisk:

			// update our dependency state...
			FigureDepState();
			break;

		// File set changed.
		case FRI_ADD:
		case FRI_DESTROY:
			FigureDepState();
			break;

		default:
			break;
	}
}

// Rx for changes in dep. connections
void CDepGrNode::InformGrNfyRx(UINT grevt, void* pvhint)
{
	// which type of dep. connection event?
	switch (grevt)
	{
		// changing what is dependent on us?
		case DepGrEvt_AddDpnt:
		case DepGrEvt_DelDpnt:
			break;

		// changing what we depend on?
		case DepGrEvt_AddDpcy:
		case DepGrEvt_DelDpcy:
			
			// do we want to do this now?
			if (!m_fIgnoreDepcy)
			{
				if (grevt == DepGrEvt_AddDpcy)
					m_frsDepcy.AddRegHandle((BldFileRegHandle)pvhint, NULL);
				else
					m_frsDepcy.RemoveRegHandle((BldFileRegHandle)pvhint);

				// dependency list at last build attempt is dirty   
				m_fDirtyDepLst = TRUE;
			}
			break;

		default:
			break;
	}

	// send out the event (use the base-class to do this)
	CGrNode::InformGrNfyRx(grevt, pvhint);
}

// figure the dependency state
// and sent out an inform if it has changed
void CDepGrNode::FigureDepState()
{
	// cache old state
	UINT oldstate = (UINT)m_state;

	// new state 
	UINT newstate = DS_Unknown;

	// ignore if no dependencies
	if (!m_frsDepcy.IsEmpty())
	{
		BOOL bVal;

		// one of our deps. missing?
		if (m_frsDepcy.GetIntProp(P_ExistsOnDisk, bVal, FALSE) && !bVal)				
			newstate |= DS_DepMissing;

		// If we are forced out of date then ignore current/out of date stuff
		if ((m_state & DS_ForcedOutOfDate) == 0)
		{
			// compare deps. most recent timestamp to our timstamp
		 	CBldFileRegEntry* pentry = m_pregistry->GetRegEntry(Frh());
			if (pentry && pentry->GetIntProp(P_ExistsOnDisk, bVal, FALSE) && bVal)
			{
				FILETIME ftimeDep, ftimeOur;
				if (m_frsDepcy.GetTimeProp(P_NewTStamp, ftimeDep, FALSE) &&
					m_pregistry->GetRegEntry(Frh())->GetTimeProp(P_NewTStamp, ftimeOur, TRUE))
				{
					if (CBldFileRegistry::MyCompareFileTime(&ftimeDep, &ftimeOur) <= 0)
						newstate |= DS_Current;
					else
					{
						newstate |= DS_OutOfDate;
#ifdef DIANEME_DEP_CHECK_DIAGNOSTICS
						ATLTRACE("\tForcing dep node 0x%x out of date due inability to get timestamp\n", this);
#endif	// DIANEME_DEP_CHECK_DIAGNOSTICS
					}
				}
			}
			else
			{
				newstate |= DS_OutOfDate;
#ifdef DIANEME_DEP_CHECK_DIAGNOSTICS
						ATLTRACE("\tForcing dep node 0x%x out of date due to missing dep\n", this);
#endif	// DIANEME_DEP_CHECK_DIAGNOSTICS
			}
		}
	}

#ifdef _DEBUG	// this test moved above
	// If we are forced out of date then ignore current/out of date stuff
	if (m_state & DS_ForcedOutOfDate)
		VSASSERT((newstate & (DS_Current | DS_OutOfDate)) == 0, "Bad state!");
#endif

	// Actually alter our state now
	m_state &= ~(DS_Current | DS_OutOfDate | DS_DepMissing);
	m_state |= newstate;

	// changed?
	if (m_state != oldstate)
		OnDepStateChanged((UINT)m_state);
}

void CDepGrNode::OnDepStateChanged(UINT state)
{
    VSASSERT((m_state & (DS_Current | DS_OutOfDate)) != (DS_Current | DS_OutOfDate), "Bad state!");
    VSASSERT((m_state & (DS_Current | DS_ForcedOutOfDate)) != (DS_Current | DS_ForcedOutOfDate), "Bad state!");
#ifdef DIANEME_DEP_CHECK_DIAGNOSTICS
	ATLTRACE("\tChanging depstate for dep node 0x%x, depstate = %d\n",this, state);
#endif	// DIANEME_DEP_CHECK_DIAGNOSTICS

    // If we are out of date then propagate changes to parents
    if (m_state & (DS_OutOfDate | DS_ForcedOutOfDate))
    {
        // Propagate changes to next layer down!!
        for (USHORT iParent = CParents(); iParent > 0; iParent--)
        {
            CDepGrNode* pgrnParent = (CDepGrNode *)Parent(iParent-1);
#ifdef DIANEME_DEP_CHECK_DIAGNOSTICS
	ATLTRACE("\tForcing parent 0x%x of dep node 0x%x out of date\n", pgrnParent, this);
#endif	// DIANEME_DEP_CHECK_DIAGNOSTICS

            UINT depstate = pgrnParent->Depstate();

            // if not out of date, then force out of date
            if ((depstate & (DS_OutOfDate | DS_ForcedOutOfDate)) == 0)
                pgrnParent->SetDepstate((depstate & ~DS_Current) | DS_ForcedOutOfDate); 
        }
    }
}

///////////////////////////////////////
// CGraph - generic graph 'protocol' //
///////////////////////////////////////

CGraph::CGraph() :
	m_mapNodes(991)	// increase default hash table size to allow large graphs.
{
	// initialise
	m_rgRoots = (CGrNode**)NULL;
	m_allocRoots = 0;

	m_cRoots = 0;
	m_mode = Graph_Stable;
}

CGraph::~CGraph()
{
	// delete our roots (we shouldn't have any)
	VSASSERT(!m_cRoots, "All of our roots should be gone before CGraph destructor is called!");

	// delete our storage
	int cRoots = m_cRoots; // bug fix
	while (cRoots > 0)
		delete m_rgRoots[--cRoots];

	VSASSERT(m_cRoots == 0, "m_cRoots decremented inside d'tor!");
	if (m_rgRoots)	
		delete []m_rgRoots;
}

// CNidGraphDoc implementation
USHORT CGraph::CRootsInitWalk()
{
	m_iRoot = 0;
	return CRoots();
}

BOOL CGraph::FNextRoot(NID& nid)
{
	int n = CRoots();
	if( m_iRoot >= n )
		return FALSE;

	for( ;m_iRoot<n;m_iRoot++){
		CDepGrNode *pNode = (CDepGrNode*)Root(m_iRoot);
		CBldFileRegFile* pentry =(CBldFileRegFile*) pNode->Reg()->GetRegEntry(pNode->Frh());
		const CPathW* pFile = pentry->GetFilePath();
		CStringW strExt = pFile->GetExtension();
		// display it relative to current directory
		if(
		 	strExt == L".lib" ||
		 	strExt == L".ilk" ||
			strExt == L".idb" ||
			strExt == L".exp" ||
			strExt == L".pdb"
		  )
			continue;
		nid = (NID)pNode;
		m_iRoot++;
		return TRUE;
	}
	return FALSE;
}

USHORT CGraph::CChildrenInitWalk(NID nidNode)
{
	m_iChild = 0;
	m_pgrnChild = (CGrNode *)nidNode;

	return m_pgrnChild->CChildren();
}

BOOL CGraph::FNextNid(NID & nid, ET & et)
{
	if (m_iChild >= m_pgrnChild->CChildren())
		return FALSE;

	nid = (NID)m_pgrnChild->Child(m_iChild);
	et = m_pgrnChild->Edge(m_iChild++);
	return TRUE;

}

// insert and remove graph nodes
void CGraph::InsertNode(CGrNode* pgrn)
{
#ifdef _DEBUG
	void * pvDummy;
	VSASSERT(!m_mapNodes.Lookup((void *)pgrn->Nid(), pvDummy), "Found the node we're trying to insert already in the map!");
#endif

	// make sure we are informed of changes
	pgrn->AddGrNfyRx(this);

	// is this a root?
	if (pgrn->CParents() == 0)
		AddRoot(pgrn);
 	 
	// remember this
	m_mapNodes.SetAt((void *)pgrn->Nid(), pgrn);
}

void CGraph::RemoveNode(CGrNode* pgrn)
{
#ifdef _DEBUG
	void * pvDummy;
	VSASSERT(m_mapNodes.Lookup((void *)pgrn->Nid(), pvDummy), "Trying to remove a node that isn't there!");
#endif

	// is this a root?
	if (pgrn->CParents() == 0)
		DelRoot(pgrn);

	// make sure we are no longer informed
	pgrn->RemoveGrNfyRx(this);

	// don't remember this
	m_mapNodes.RemoveKey((void *)pgrn->Nid());
}

void CGraph::AddRoot(CGrNode* pgrn)
{
	VSASSERT(pgrn->CParents() == 0, "Root already has parents!");

	// allocate our new array of children?
	BOOL fRealloc = m_cRoots >= m_allocRoots;
	CGrNode** rgRoots = m_rgRoots;

	// re-alloc?
	if (fRealloc)
	{
		m_allocRoots += C_ALLOC_ROOT;

		rgRoots = new CGrNode *[m_allocRoots];

		// move our current roots
		if(m_cRoots)
			memcpy(rgRoots, m_rgRoots, m_cRoots * sizeof(CGrNode *));
	}

	// insert this root
	rgRoots[m_cRoots] = pgrn;

	// remember our new array?
	if (fRealloc)
	{
		if (m_rgRoots) 
			delete []m_rgRoots;
		m_rgRoots = rgRoots;
	} 

	// increment our root count
	m_cRoots++;
}

void CGraph::DelRoot(CGrNode* pgrn)
{
	BOOL fFound = FALSE;
	int iRoot = 0;
	while (iRoot < m_cRoots)
	{
		// if found then remove parent
		if (fFound)
			m_rgRoots[iRoot - 1] = m_rgRoots[iRoot];

		// if ~found then search for parent
		else
			fFound = (m_rgRoots[iRoot] == pgrn);

		iRoot++;
	}

	// make sure we found the root
	VSASSERT(fFound, "Failed to find the root!");

	// decrement the root count
	m_cRoots--;
}

// although originally writen to recursively clear flags, this routine was only
// used to clear the entire dep graph. It should only be used that way.
void CGraph::ClearVisited(void)
{
	void* p;
	void* pVal;
	CGrNode* pgrn;

	// iterate over all nodes in this graph. flipping the visited bit to false.
	VCPOSITION pos = m_mapNodes.GetStartPosition();
	while (pos != (VCPOSITION)NULL) 
	{
		m_mapNodes.GetNextAssoc(pos, p, pVal);
		pgrn = (CGrNode *)pVal;
		pgrn->m_fVisited = FALSE;
	}
}

// Rx for graph node change events
void CGraph::OnGrNfy(UINT grevt, CGrNode* pgrn, void* pvhint)
{
	switch (grevt)
	{
		case GrEvt_AddParent:
			// no longer a root? 
			if (pgrn->CParents() == 1)
				DelRoot(pgrn);
			break;

		case GrEvt_DelParent:
			// become a root?
			if (pgrn->CParents() == 0)
				AddRoot(pgrn);
 			break;

		case GrEvt_AddChild:
		case GrEvt_DelChild:
			break;

		case GrEvt_Destroy:
			RemoveNode(pgrn);
			break;

		default:
			break;
	}
}

// set graph mode
UINT CGraph::SetGraphMode(UINT mode)
{
	UINT oldmode = m_mode;
	m_mode = mode;

	// loop through and tell them of this change
	VCPOSITION pos = m_mapNodes.GetStartPosition();
	while (pos != (VCPOSITION)NULL)
	{
		void* key; 
		CGrNode* pgrn;
		m_mapNodes.GetNextAssoc(pos, key, (void * &)pgrn); 
		pgrn->OnGraphMode(m_mode);
	}

	return oldmode;	// return old mode
}

#if 0
BOOL CGraph::PerformOperationI(GraphOpFn pfn, DWORD& dw, UINT order, CGrNode* pgrn)
{
 	// visited
	pgrn->m_fVisited = TRUE;

	VSASSERT(pfn, "Bad input parameter");
	VSASSERT(pgrn != (CGrNode *)NULL, "Bad input parameter");

	BOOL fLookChildren = TRUE;	// enumerate kids?

	// perform a pre-op.?
	if (order == PrePerform)
		if (!(*pfn)(pgrn, dw, fLookChildren))
			return FALSE;	// failed to perform op.

	// enumerate kids
	if (fLookChildren)
	{
		for (USHORT iChild = 0; iChild < pgrn->CChildren(); iChild++)
		{
			CGrNode* pgrnChild = pgrn->Child(iChild);
			if (!pgrnChild->m_fVisited)
				if (!PerformOperationI(pfn, dw, order, pgrnChild))
					return FALSE;	// failed to perform op. for child
		}
	}

	// perform a post-op.
	if (order == PostPerform)
		if (!(*pfn)(pgrn, dw, fLookChildren))
			return FALSE;	// failed to perform op.

	return TRUE;	// ok
}
#endif

#if 0
BOOL CGraph::PerformOperation(GraphOpFn pfn, DWORD& dw, UINT order /* = PrePerform */, NID nid /* = nidNil */)
{
	VSASSERT(pfn, "Bad input parameter");

	// for each of these nodes construct a list of actions, don't visit nodes twice
    // which may happen given multiple starts
	ClearVisited();

	if (nid == nidNil)
	{
		// perform operation for roots
		for (USHORT iRoot = 0; iRoot < m_cRoots; iRoot++)
			if (!PerformOperationI(pfn, dw, order, m_rgRoots[iRoot]))
				return FALSE;	// failed to perform op. for root
	} 
	else
	{
		// perform op. for select node
		CGrNode* pgrn;
		if (!LookupNode(nid, pgrn) || !PerformOperationI(pfn, dw, order, pgrn))
			return FALSE;	// failed to find node or perform op.
	}

	return TRUE;	// ok
}
#endif

///////////////////////////////////////////
// Default graph ops
///////////////////////////////////////////

///////////////////////////////////////////
// CBldFileDepGraph - file dependency graph //
///////////////////////////////////////////

CBldFileDepGraph::CBldFileDepGraph(CBldFileRegistry* pregistry)
{
	// assign our registry
	m_pregistry = pregistry;

	// don't show dep. sets by default
	m_fShowDepSets = FALSE;
	m_bInitialized = FALSE;
}

CBldFileDepGraph::~CBldFileDepGraph()
{
}

BOOL CBldFileDepGraph::ModifyDep(BldFileRegHandle frhDep, CBldAction* pAction, UINT dep, BOOL fAdd,
	IVCBuildErrorContext* pEC, BOOL fWithAction /* = TRUE */)
{
	// what kind of dep.?
	switch (dep)
	{
		case DEP_Input:
		case DEP_Source:
		{
			// add this input or source dep. to each of the outputs
			int i = 0;
			BldFileRegHandle frhOut;
			CBldFileRegSet* pfrsOutput = pAction->GetOutput(pEC);
			CVCWordArray* paryOutputAttrib = pAction->GetOutputAttrib();

			pfrsOutput->InitFrhEnum();
			while ((frhOut = pfrsOutput->NextFrh()) != (BldFileRegHandle)NULL)
			{
				BOOL fWithAction = !!paryOutputAttrib->GetAt(i++);
				CBldAction* pEdgeAction = fWithAction ? pAction : (CBldAction *)NULL;

				if (fAdd)
				{
					if (!AddDepEdgeI(frhDep, frhOut, pEdgeAction))
					{
						frhOut->ReleaseFRHRef();
						return FALSE;
					}
				}
				else
				{
					if (!RemoveDepEdgeI(frhDep, frhOut, pEdgeAction, TRUE /* propagate */))
					{
						frhOut->ReleaseFRHRef();
						return FALSE;
					}
				}
				frhOut->ReleaseFRHRef();
			}
		
			break;
		}

		case DEP_Output:
		{
			// remove scanned/source/missing dependencies (en masse) to this output
			// this means all non-target tools, any 'custom' tools, plus the single target tool generating the primary output
			if (!fAdd && HandleDependencyInfo(pAction))
			{
				CBldFileRegSet* pfrsScanned = pAction->GetScannedDep();

				if (!RemoveDepEdgeI((BldFileRegHandle)pfrsScanned, frhDep, (CBldAction *)NULL, TRUE /* propagate */))
					return FALSE;

				// this set doesn't need to calc attributes!
				// OLYMPUS 13658: However we do need to calc attributes if this set is
				// used by some other action, i.e it has some parents after removing the edge above.
				// So we can only switch off calc of attributes when the set has 0 parents.
                CDepGrNode* pgrnDepcy;
				if (FindDep(pfrsScanned, pgrnDepcy) && pgrnDepcy->CParents() == 0)
					pfrsScanned->CalcAttributes(FALSE);

				CBldFileRegSet* pfrsSource = pAction->GetSourceDep();

				if (!RemoveDepEdgeI((BldFileRegHandle)pfrsSource, frhDep))
					return FALSE;

                // Remove source deps originally added as missing/scanned deps. 
				BldFileRegHandle frhSrcDep;
				pfrsSource->InitFrhEnum();
				while ((frhSrcDep = pfrsSource->NextFrh()) != (BldFileRegHandle)NULL)
				{
					if (pAction->GetScannedDep()->RegHandleExists(frhSrcDep))
					{
						if (!RemoveDepEdgeI(frhSrcDep, frhDep))
						{
							frhSrcDep->ReleaseFRHRef();
							return FALSE;
						}
					}

					frhSrcDep->ReleaseFRHRef();
				}
 			}

			// 
			// add each of the inputs to this output
			BldFileRegHandle frhIn;
			CBldFileRegSet* pfrsInput = pAction->GetInput(pEC);

			CBldAction* pEdgeAction = fWithAction ? pAction : (CBldAction *)NULL;
	
			pfrsInput->InitFrhEnum();

			// remove out input->output dep. first
			if (!fAdd)
			{
				while ((frhIn = pfrsInput->NextFrh()) != (BldFileRegHandle)NULL)
				{
					if (!RemoveDepEdgeI(frhIn, frhDep, pEdgeAction, TRUE /* propagate */))
					{
						frhIn->ReleaseFRHRef();
						return FALSE;
					}
					frhIn->ReleaseFRHRef();
				}
			}

			// can we find this output in a dep. set?
			CDepGrNode* pgrnDep;

			// find action for the dependents
			CVCPtrArray aryDeps;
			if (FindDep(frhDep, pgrnDep, &aryDeps, TRUE))
			{
				int i = aryDeps.GetSize();
				while (i > 0)
				{
					pgrnDep = (CDepGrNode *)aryDeps.GetAt(--i);
					if (pgrnDep->CParents())
					{
						// action is the 1st edge of our 1st parent
						pgrnDep = (CDepGrNode *)pgrnDep->Parent(0);

						CBldAction* pActionDep = (CBldAction *)pgrnDep->Edge(0);

						if (pActionDep != (CBldAction *)NULL)
						{
							// make this a source dep.
							if (fAdd)
							{
								if (!pActionDep->AddSourceDep(frhDep, pEC))
									return FALSE;
							}
							// can we find this output in the source dep. set?
							// remove as a source dep. if it originated from the
							// scanned or missing dep. otherwise leave it, we
							// didn't add it as a source dep. originally!
							else if( pActionDep->GetSourceDep()->RegHandleExists(frhDep) &&
								pActionDep->GetScannedDep()->RegHandleExists(frhDep))
							{
								if (!pActionDep->RemoveSourceDep(frhDep, pEC))
									return FALSE;
							}
						}
					}
				}
			}

			// add our input->output dep. last
	 		if (fAdd)
			{
				while ((frhIn = pfrsInput->NextFrh()) != (BldFileRegHandle)NULL)
				{
					if (!AddDepEdgeI(frhIn, frhDep, pEdgeAction))
					{
						frhIn->ReleaseFRHRef();
						return FALSE;
					}
					frhIn->ReleaseFRHRef();
				}
			}

			// add scanned/missing dependencies (en masse) to this output
			// (*only* for non-target tools, ie. ones that scan!)
			if (fAdd && HandleDependencyInfo(pAction))
			{
				CBldFileRegSet* pfrsScanned = pAction->GetScannedDep();

				if (!AddDepEdgeI((BldFileRegHandle)pfrsScanned, frhDep))
					return FALSE;

				// make sure we this set calc's attributes!
				(void)pfrsScanned->CalcAttributes();

				CBldFileRegSet* pfrsSource = pAction->GetSourceDep();

				if (!AddDepEdgeI((BldFileRegHandle)pfrsSource, frhDep))
					return FALSE;

                // Add scanned/missing deps that are really source deps
				BldFileRegHandle frhSrcDep;
				pfrsSource->InitFrhEnum();
				while ((frhSrcDep = pfrsSource->NextFrh()) != (BldFileRegHandle)NULL)
				{
					if (pAction->GetScannedDep()->RegHandleExists(frhSrcDep))
					{
						if (!AddDepEdgeI(frhSrcDep, frhDep))
						{
							frhSrcDep->ReleaseFRHRef();
							return FALSE;
						}
					}
					frhSrcDep->ReleaseFRHRef();
				}
			}

			break;
		}

		case DEP_Scanned:
			break;	// no nothing

		default:
			break;	// no nothing
	}

	return TRUE;	// done 
}

// add a dependency relationship
// o 'frhDpcy' is the file(s) we are dependent on
// o 'frhDpnt is the dependent file(s)
// o 'pActionSlob' is the action that should be performed to
//    make the dependent 'current' wrt the dependency
BOOL CBldFileDepGraph::AddDepEdgeI(BldFileRegHandle frhDpcy, BldFileRegHandle frhDpnt, 
	CBldAction * pAction /* = (CBldAction *)NULL*/)
{
	// ignore the joining the same files (this is a no-op)
	if (frhDpcy == frhDpnt)
		return TRUE;	// pretend that we've done it

	// get a node for the dependency and one for the dependent, else create one....
	CDepGrNode *pgrnDepcy, *pgrnDepnt;
	if (!FindDep(frhDpcy, pgrnDepcy))
	{
		// create and place in graph
		pgrnDepcy = new CDepGrNode(this, m_pregistry, frhDpcy);
		RETURN_ON_NULL2(pgrnDepcy, FALSE);
		InsertNode(pgrnDepcy);
#ifdef DIANEME_DEP_CHECK_DIAGNOSTICS
		{
			if (frhDpcy && frhDpcy->IsNodeType(CBldFileRegNotifyRx::nodetypeRegFile))
			{
				const CPathW* pPath = ((CBldFileRegFile*)frhDpcy)->GetFilePath();
				CStringA strName;
				if (pPath)
					strName = pPath->GetFullPath();
				ATLTRACE("\tCreating dep node 0x%x for file %s\n", pgrnDepcy, strName);
			}
			else
				ATLTRACE("\tCreating dep node 0x%x for reg handle 0x%x\n", pgrnDepcy, frhDpcy);
		}
#endif	// DIANEME_DEP_CHECK_DIAGNOSTICS

		// add to our list of sets?
		CBldFileRegEntry* preg = m_pregistry->GetRegEntry(frhDpcy);
		if (preg && preg->IsNodeType(CBldFileRegNotifyRx::nodetypeRegSet))
		{
			VSASSERT(m_lstDepSets.Find(preg) == (VCPOSITION)NULL, "Dependency set already there!");
			m_lstDepSets.AddTail(preg);
		}
	}

	if (!FindDep(frhDpnt, pgrnDepnt))
	{
		// create and place in graph
		pgrnDepnt = new CDepGrNode(this, m_pregistry, frhDpnt);
		RETURN_ON_NULL2(pgrnDepnt, FALSE);
		InsertNode(pgrnDepnt);
#ifdef DIANEME_DEP_CHECK_DIAGNOSTICS
		{
			if (frhDpnt && frhDpnt->IsNodeType(CBldFileRegNotifyRx::nodetypeRegFile))
			{
				const CPathW* pPath = ((CBldFileRegFile*)frhDpnt)->GetFilePath();
				CStringA strName;
				if (pPath)
					strName = pPath->GetFullPath();
				ATLTRACE("\tCreating dep node 0x%x for file %s\n", pgrnDepnt, strName);
			}
			else
				ATLTRACE("\tCreating dep node 0x%x for reg handle 0x%x\n", pgrnDepnt, frhDpnt);
		}
#endif	// DIANEME_DEP_CHECK_DIAGNOSTICS

		// add to our list of sets?
		CBldFileRegEntry* preg = m_pregistry->GetRegEntry(frhDpnt);
		if (preg && preg->IsNodeType(CBldFileRegNotifyRx::nodetypeRegSet))
		{
			VSASSERT(m_lstDepSets.Find(preg) == (VCPOSITION)NULL, "Dependency set already there!");
			m_lstDepSets.AddTail(preg);
		}
	}

	// connect dependency (child) <- dependant (parent) with the action (if one exists) as the edge

	// make sure we haven't already done this
	for (USHORT iChild = pgrnDepnt->CChildren(); iChild > 0; iChild--)
	{
		if (pgrnDepcy == pgrnDepnt->Child(iChild-1))
			return TRUE;	// already performed addition
	}

	pgrnDepnt->AddChild(pgrnDepcy, (EID)pAction);
#ifdef DIANEME_DEP_CHECK_DIAGNOSTICS
	ATLTRACE("\t\tDep node 0x%x is a child of dep node 0x%x\n", pgrnDepcy, pgrnDepnt);
#endif	// DIANEME_DEP_CHECK_DIAGNOSTICS

    // Now need to propagate dep state to new node!!!
    if (pgrnDepcy->Depstate() & (DS_OutOfDate | DS_ForcedOutOfDate))
    {
        UINT depstate = pgrnDepnt->Depstate();
        if ((depstate & DS_ForcedOutOfDate) == 0)
            pgrnDepnt->SetDepstate((depstate & ~DS_Current) | DS_ForcedOutOfDate);
    }
    
	return TRUE;	// success
}

// remove a dependency relationship
BOOL CBldFileDepGraph::RemoveDepEdgeI(BldFileRegHandle frhDpcy, BldFileRegHandle frhDpnt,
	CBldAction * pAction /* = (CBldAction *)NULL*/, BOOL fAllDepnts /* = FALSE */)
{
	// get a node for the dependency and one for the dependent, and delete them
	// (automatic removal and disconnection from graph...)
	CDepGrNode *pgrnDepcy, *pgrnDepnt;
	if (!FindDep(frhDpcy, pgrnDepcy) || !FindDep(frhDpnt, pgrnDepnt))
		return TRUE;	// already removed....

		// ignore the joining the same files (this is a no-op)
	if (frhDpcy == frhDpnt)
	{
		// We may need to remove this node if this is joining the same files and the node
		// has no other children (but maybe some parents)
		if (pgrnDepnt->CChildren() == 0)
		{
			// Remove any parents
			for (USHORT iParent = pgrnDepcy->CParents(); iParent > 0; iParent--)
			{
				pgrnDepnt = (CDepGrNode *)pgrnDepcy->Parent(iParent - 1);
 				RemoveDepEdgeI(frhDpcy, pgrnDepnt->Frh());
 			}
		}

		return TRUE;	// pretend that we've done it
	}

	// disconnect dependency
	for (USHORT iChild = pgrnDepnt->CChildren(); iChild > 0; iChild--)
	{
		// search for this
		if (pgrnDepcy == pgrnDepnt->Child(iChild - 1))
		{
			// delete child
			pgrnDepnt->DelChild(iChild - 1);
			break;
		}
	}

	// delete dependency if no longer connected
	if (pgrnDepcy->CParents() == 0 && pgrnDepcy->CChildren() == 0)
	{
		// remove from our list of sets
		CBldFileRegEntry* preg = m_pregistry->GetRegEntry(frhDpcy);
		if (preg->IsNodeType(CBldFileRegNotifyRx::nodetypeRegSet))
		{
			VCPOSITION pos = m_lstDepSets.Find(preg);
			VSASSERT(pos != (VCPOSITION)NULL, "Dependency set not there!");
			m_lstDepSets.RemoveAt(pos);
		}

		delete pgrnDepcy;
	}

	// Remove if we don't have any parents or children OR if fAllDepnts is TRUE, remove from any 
	// parents we have that don't have an action that uses us and we don't have any children.
	if (fAllDepnts && pgrnDepnt->CParents() != 0 && pgrnDepnt->CChildren() == 0)
	{
		// For each parent, find the reference for pgrnDepnt, and check if the
		// associated edge is NULL.
		for (USHORT iParent = pgrnDepnt->CParents(); iParent > 0; iParent--)
		{
			CDepGrNode* pgrnParent = (CDepGrNode *)pgrnDepnt->Parent(iParent - 1);

			// Loop though children of our parent to find ourselves.
			CBldAction* pParentAction = NULL;
			for (USHORT iChild = pgrnParent->CChildren(); iChild > 0; iChild--)
			{
				if ((CDepGrNode *)pgrnParent->Child(iChild - 1) == pgrnDepnt )
				{
					pParentAction = (CBldAction*)pgrnParent->Edge(iChild - 1);
					break;
				}
			}
			if (NULL != pParentAction)
				continue;

			if (!RemoveDepEdgeI(frhDpnt, pgrnParent->Frh()))
				return FALSE;
		}
	}
	else
	{
	 	if (pgrnDepnt->CParents() == 0 && pgrnDepnt->CChildren() == 0)
		{
			// remove from our list of sets
			CBldFileRegEntry* preg = m_pregistry->GetRegEntry(frhDpnt);
			if (preg->IsNodeType(CBldFileRegNotifyRx::nodetypeRegSet))
			{
				VCPOSITION pos = m_lstDepSets.Find(preg);
				VSASSERT(pos != (VCPOSITION)NULL, "Dependency set not there!");
				m_lstDepSets.RemoveAt(pos);
			}

			delete pgrnDepnt;
		}
	}

	return TRUE;	// success
}

BOOL CBldFileDepGraph::FindDep(BldFileRegHandle frhDep, CDepGrNode*& pgrn, CVCPtrArray* parygrn,
	BOOL fSearchSets /* = FALSE */)
{
	BOOL fFound = FALSE;

	// can we find it as a 'single' node?
	if (LookupNode((NID)frhDep, (CGrNode*&)pgrn))
		return !fSearchSets;	// found... return whether found in a set

	// search our sets?
	if (fSearchSets)
	{
		VCPOSITION pos = m_lstDepSets.GetHeadPosition();
		while (pos != (VCPOSITION)NULL)
		{
			CBldFileRegSet * pfrsSet = (CBldFileRegSet *)m_lstDepSets.GetNext(pos);
			if (pfrsSet->RegHandleExists(frhDep) && FindDep((BldFileRegHandle)pfrsSet, pgrn, parygrn))
			{
				fFound = TRUE;

				// found one, make a note and .. carry on searching?
				if (parygrn == (CVCPtrArray *)NULL)
					break;	// no!

				parygrn->Add(pgrn);
			}
		}
	}

	return fFound;	// not found
}

void CBldFileDepGraph::StartPasses()
{
	// use a different action marker than the last time we did the passes
	CBldAction::m_wActionMarker++;

	// clear our 'cannot build' list
	m_lstCannotBuild.RemoveAll();
}

// what actions 'contribute' to the dependent?
// o 'plstActions' is a list of actions
// o 'frhStart' is the dependent to start from
// return CMD_ value
UINT CBldFileDepGraph::RetrieveOutputActions(CBldActionList* plstActions, IVCBuildErrorContext* pEC, BldFileRegHandle frhStart)
{
	VSASSERT(frhStart != (BldFileRegHandle)NULL, "Starting frh cannot be NULL!");

	// look for this in our graph
	CDepGrNode* pgrn;
	if (!FindDep(frhStart, pgrn))
		return CMD_Error;

	// remove existing ones
	plstActions->Clear();

	for (USHORT iChild = pgrn->CChildren(); iChild > 0; iChild--)
	{
		CBldAction * pAction = (CBldAction *)pgrn->Edge(iChild-1);
		if (pAction != (CBldAction *)NULL)
			plstActions->AddToEnd(pAction);
	}

	return CMD_Complete;
}

// what actions are performed on the dependencies with a state in 'stateFilter' (default is 'not current')?
// o 'frhStart' is the dependent to start from (default is 'do all out of date')
CMD CBldFileDepGraph::RetrieveBuildActions(CBldCfgRecord* pcrBuild, CBldActionList* plstActions, CVCPtrList& lstFrh,
 	IVCBuildErrorContext* pEC, CDynamicBuildEngine* pBldEngine, BldFileRegHandle frhStart /* = (BldFileRegHandle)NULL*/,
	UINT stateFilter /* = DS_OutOfDate */, UINT aor /* = AOR_Default */, BOOL bCheckTimeStamps /* = TRUE */)
{	
    // for each of these nodes construct a list of actions, don't visit nodes twice
    // which may happen given multiple starts
    ClearVisited();
	CBldFileRegFile::UpdateTimeStampTick();		// this makes it so we don't look up the time stamp on something multiple times

	CMD cmdRet = CMD_Complete;

	VSASSERT(pcrBuild != NULL, "CfgRecord is required parameter for determining build info");
	CStringW strIdb;
	if (pcrBuild != NULL)
	{
		VCConfiguration* pProjCfg = pcrBuild->GetVCConfiguration();
		CComQIPtr<IVCConfigurationImpl> spProjCfgImpl = pProjCfg;
		VSASSERT(spProjCfgImpl != NULL, "CfgRecord improperly initialized");
		CComBSTR bstrIdb;
		if (spProjCfgImpl != NULL)
			spProjCfgImpl->get_MrePath(&bstrIdb);
		strIdb = bstrIdb;
	}

	// Minimal rebuild dependency interface.
	CBldMreDependenciesContainer mreDepend(strIdb);

	// nodes to start from?
	CVCPtrList lstStartNodes;
	if (frhStart == (BldFileRegHandle)NULL)
	{
		// any roots?
		USHORT iRoot = CRoots();
		if (iRoot == 0)
			return CMD_Complete;

		for (; iRoot > 0; iRoot--)
		{
			cmdRet = EnumerateBuildActionsI(plstActions, lstFrh, pEC, pBldEngine, (CDepGrNode *)Root(iRoot-1), stateFilter, aor,
				bCheckTimeStamps);
			if (cmdRet != CMD_Complete)
				goto ExitRetrieve;
		}
	}
	else
	{
		// find this node?
		CDepGrNode* pgrnDep;
		if (!FindDep(frhStart, pgrnDep))
		{
			// couldn't find the start node
			cmdRet = CMD_Error;
			goto ExitRetrieve;
		}

		cmdRet = EnumerateBuildActionsI(plstActions, lstFrh, pEC, pBldEngine, pgrnDep, stateFilter, aor, bCheckTimeStamps);
		if (cmdRet != CMD_Complete)
			goto ExitRetrieve;
	}

ExitRetrieve:
	// return command code
	return cmdRet;
}

BOOL CBldFileDepGraph::HandleDependencyInfo(CBldAction* pAction)
{
	return (!pAction->BuildToolWrapper()->IsTargetTool(pAction) || pAction->BuildToolWrapper()->HasPrimaryOutput() 
		|| pAction->BuildToolWrapper()->CustomToolType());
}

BOOL g_bBatchBuildInProgress;
CMD CBldFileDepGraph::EnumerateBuildActionsI(CBldActionList* plstActions, CVCPtrList& lstFrh, IVCBuildErrorContext* pEC, 
	CDynamicBuildEngine* pBldEngine, CDepGrNode* pgrn, UINT stateFilter, UINT& aor, BOOL bCheckTimeStamps)
{
	// make sure we have up-to-date timestamps prior to getting the dependency state
	if (!pgrn->m_fVisited && bCheckTimeStamps && m_pregistry)
	{
		BldFileRegHandle frh = m_pregistry->GetRegEntry(pgrn->Frh());
		if (frh)
			frh->UpdateAttributes();
	}

	if (pBldEngine && pBldEngine->m_bUserCanceled)
	{
		pBldEngine->InformUserCancel();
		return CMD_Canceled;
	}

	// visited
	pgrn->m_fVisited = TRUE;

	ULONG cChildren = pgrn->CChildren();
	if (cChildren == 0)
		return CMD_Complete;

	int cVisited = 0;

	// See if dependencies need to be updated.
    CBldAction* pAction = NULL;
	// the action associated with this node may not be in the first child, but it is always either first or third...
	for (ULONG idx = 0; idx < cChildren && idx < 3; idx++)	
	{
		if (pgrn->Edge(idx) != (EID)NULL)
		{
			pAction = (CBldAction *)pgrn->Edge(idx);
			break;
		}
	}

	if (NULL != pAction)
	{
		if (!pAction->IsDepInfoInitialized())
			pAction->UpdateDepInfo(pEC);
	}

	for (USHORT iChild = cChildren; iChild > 0; iChild--)
	{
		CDepGrNode* pgrnChild = (CDepGrNode *)pgrn->Child(iChild-1);

		// enumerate actions of our child?
		// o recursive and child not visited (depth first, post-order)
		if ((aor & AOR_Recurse) && !pgrnChild->m_fVisited)
		{
			CMD cmdRet = EnumerateBuildActionsI(plstActions, lstFrh, pEC, pBldEngine, pgrnChild, stateFilter, aor, bCheckTimeStamps);
			if (cmdRet != CMD_Complete)
				return cmdRet;

			cVisited++;
		}
	}


	// our dependency state check
	// o dependent state is a subset of our filter?
	UINT depState = pgrn->Depstate();

	if ((depState & DS_ForcedOutOfDate) != 0)
	{
		if ((stateFilter & DS_ForcedOutOfDate) != 0)
		{
			// REVIEW(kperry) just because we want find out what to build, we shouldn't
			//				  set it back in date !
			pgrn->SetDepstate(depState & ~DS_ForcedOutOfDate);
			pgrn->FigureDepState();
			depState = pgrn->Depstate() | DS_ForcedOutOfDate;
		}
		else if (pAction != NULL)
		{
			UINT oldState = depState;
			pgrn->SetDepstate(depState & ~DS_ForcedOutOfDate);
			pgrn->FigureDepState();
			depState = ((oldState & stateFilter) == 0) ? pgrn->Depstate() : oldState;
			pgrn->SetDepstate(oldState); // restore old state
		}
	}

	// do we have an action we might want to add?
	if (pAction == (CBldAction *)NULL)
		return CMD_Complete;
 
	BOOL fAddAction = ((depState & stateFilter) != 0);

	// have we already retrieved this?
	if (pAction->m_wMark == CBldAction::m_wActionMarker)
	{
		// be aggressive here, mark our parents as likely to be out of date
		if (fAddAction)
		{
			AddEnumeratedActionFile(pgrn, lstFrh);
#ifdef DIANEME_DEP_CHECK_DIAGNOSTICS
			ATLTRACE("\tAdding action for dep node 0x%x with dep state %d and filter %d\n", pgrn, depState, stateFilter);
#endif	// DIANEME_DEP_CHECK_DIAGNOSTICS
		}
		return CMD_Complete;
	}

#ifdef DIANEME_DEP_CHECK_DIAGNOSTICS
	if (fAddAction)
		ATLTRACE("\t(1) Will be adding action for dep node 0x%x, depstate = %d, filter = %d\n", pgrn, depState, stateFilter);
#endif	// DIANEME_DEP_CHECK_DIAGNOSTICS

	// not adding actions?
	// explain why?
	if (!fAddAction)
	{
		// dependency missing....and no actions that may generate them!
		if (pgrn->Depstate() & DS_DepMissing)
		{
			BOOL fIgnDepMissing = (pgrn->Depstate() & ~stateFilter) == DS_DepMissing;	// ignore missing dependency?

			for (USHORT iChild = pgrn->CChildren(); iChild > 0; iChild--)
			{
				CBldAction* pEdge = (CBldAction *)pgrn->Edge(iChild-1);
				if (pEdge != (CBldAction *)NULL)
				{
					CDepGrNode* pgrnChild = (CDepGrNode *)pgrn->Child(iChild-1);
					CBldFileRegEntry* pregChild = m_pregistry->GetRegEntry(pgrnChild->Frh());

					// not exist and an action?
					if (!pregChild->ExistsOnDisk(FALSE))
					{
						// don't ignore this missing dependency
						fIgnDepMissing = FALSE;
						break;
					}
				}
			}

			// ignore missing dependency in the case that we are *only* missing dependencies 
			// for non-action relationships, eg. scanned deps.
			fAddAction = fIgnDepMissing;
		}
	}

#ifdef DIANEME_DEP_CHECK_DIAGNOSTICS
	if (fAddAction)
		ATLTRACE("\t(2) Will be adding action for dep node 0x%x, depstate = %d, filter = %d\n", pgrn, depState, stateFilter);
#endif	// DIANEME_DEP_CHECK_DIAGNOSTICS

	// refresh the command-line options
	
	// anything changed?
	BOOL fOptsChnged;
	BOOL fRefreshOk = pAction->RefreshCommandOptions(fOptsChnged, (aor & AOR_PreChk) != 0);
	BOOL bHaveMissingDeps = pAction->HaveMissingDeps();

	// o check for options changes and have they possibly changed?
	if ((aor & AOR_ChkOpts) && ((fRefreshOk && fOptsChnged) || bHaveMissingDeps))
	{
		if (!fAddAction)
		{
			// no longer bothering to prompt; we'll *always* rebuild if dirty
			fAddAction = TRUE;
#ifdef DIANEME_DEP_CHECK_DIAGNOSTICS
			ATLTRACE("\tAdding action for dep node 0x%x due to option change %d or missing deps %d\n", 
				pgrn, fOptsChnged, bHaveMissingDeps);
#endif	// DIANEME_DEP_CHECK_DIAGNOSTICS

			// Delete the outputs to this action so that we will rebuild this if something goes wrong, 
			// as the change in build settings is lost after the first attempted build
			// Please note that only the *first* output is being deleted below.  This is enough
			// to get the action to rerun next time we build, but doesn't get rid of *all* dirty outputs.
			if (!bHaveMissingDeps && !pAction->BuildToolWrapper()->IsTargetTool(pAction) && !(aor & AOR_PreChk))
			{
				CBldFileRegSet* pOutput = pAction->GetOutput(pEC);
				CBldFileRegEntry* frh = (CBldFileRegEntry *)pOutput->GetFirstFrh();
				if (frh != NULL)
				{
					frh->DeleteFromDisk();
					frh->ReleaseFRHRef();
#ifdef DIANEME_DEP_CHECK_DIAGNOSTICS
					ATLTRACE("\tDeleting output for dep node 0x%x\n", pgrn);
#endif	// DIANEME_DEP_CHECK_DIAGNOSTICS
				}
			}
		}

		// if the action we just marked out of date happens to have more than one output (such as if it was
		// a MIDL action or a custom build rule with multiple outputs), then we need to figure out what the
		// other parents of the out-of-date child are also out-of-date.
		for (USHORT iChild = pgrn->CChildren(); iChild > 0; iChild--)
		{
			CBldAction* pTmpAction = NULL;
			CDepGrNode* pgrnChild = (CDepGrNode *)pgrn->Child(iChild-1);

			// check the other parents of the children
			for (USHORT iParent = pgrnChild->CParents(); iParent > 0; iParent--)
			{
				CDepGrNode* pgrnParent = (CDepGrNode *)pgrnChild->Parent(iParent-1);
				if (pgrnParent == pgrn)	// don't recheck the original parent
					continue;

				for (ULONG idx = 0; idx < pgrnParent->CChildren(); idx++)	// the action associated with this node may not be in the first child..,
				{
					if (pgrnParent->Edge(idx) != (EID)NULL)
					{
						if (pAction == (CBldAction *)pgrnParent->Edge(idx))
						{
#ifdef DIANEME_DEP_CHECK_DIAGNOSTICS
							ATLTRACE("\tAdding action for dep node 0x%x due to out-of-date child 0x%x\n", 
									pgrnParent, pgrn);
#endif	// DIANEME_DEP_CHECK_DIAGNOSTICS
							AddEnumeratedActionFile(pgrnParent, lstFrh);
							break;
						}
					}
				}
			}
		}
	}

	// add the action now?
	if (fAddAction)
	{
		// make sure we don't attempt to retrieve it again
		pAction->m_wMark = CBldAction::m_wActionMarker;
		AddEnumeratedActionFile(pgrn, lstFrh);
#ifdef DIANEME_DEP_CHECK_DIAGNOSTICS
		ATLTRACE("\tAdding action for dep node 0x%x, depstate = %d, filter = %d\n", pgrn, pgrn->Depstate(), stateFilter);
#endif	// DIANEME_DEP_CHECK_DIAGNOSTICS
	}

	// not adding actions, yet attempted to build all we can?
	// explain why?
	if ((!(aor & AOR_Recurse) || (cVisited && !plstActions->NotEmpty())) && (aor & AOR_Verbose))
	{
		// dependency missing....and no actions that may generate them!
		if (pgrn->Depstate() & DS_DepMissing)
		{
			CStringW strMsg;	// message buffer
			for (USHORT iChild = pgrn->CChildren(); iChild > 0; iChild--)
			{
				CDepGrNode* pgrnChild = (CDepGrNode *)pgrn->Child(iChild-1);
				CBldFileRegEntry* pregChild = m_pregistry->GetRegEntry(pgrnChild->Frh());

				// exist?
				if (pregChild->ExistsOnDisk(FALSE))
					continue;
				// special -- Custom Build Events. These are not on disk
				if(pregChild->IsNodeType(CBldFileRegNotifyRx::nodetypeRegFile) && ((CBldFileRegFile*)pregChild)->m_bFileNotOnDisk)
					continue;

				// loop through deps. and warn about deps. that are missing
				if (pregChild->IsNodeType(CBldFileRegNotifyRx::nodetypeRegSet))
				{
					// report source deps. (headers) that are missing
					BldFileRegHandle frh;
					((CBldFileRegSet *)pregChild)->InitFrhEnum();
					while ((frh = ((CBldFileRegSet *)pregChild)->NextFrh()) != (BldFileRegHandle)NULL)
					{
						CBldFileRegFile* pregFile = (CBldFileRegFile *)m_pregistry->GetRegEntry(frh);
						if (!pregFile->ExistsOnDisk(FALSE))
						{
							// REVIEW:: this is O(n^3) but only called if build is going to fail anyway
							// Should change to a map.
							if (!m_lstCannotBuild.Find(pregFile))
							{
								::VCMsgTextW(strMsg, IDS_CANNOT_BUILD_DEP_PRJ0010, (const wchar_t *)*pregFile->GetFilePath());
								CVCProjectEngine::AddProjectError(pEC, strMsg, L"PRJ0010", pBldEngine->GetAssociatedCfgRecord());
								m_lstCannotBuild.AddTail(pregFile);
							}
						}
						frh->ReleaseFRHRef();
					}
				}
				else if (pgrnChild->CChildren() == 0)
				{
					// report file that we don't know how to or failed to build
					if (!m_lstCannotBuild.Find(pregChild))
					{
						::VCMsgTextW(strMsg, IDS_CANNOT_BUILD_DEP_PRJ0010, (const wchar_t *)*pregChild->GetFilePath());
						CVCProjectEngine::AddProjectError(pEC, strMsg, L"PRJ0010", pBldEngine->GetAssociatedCfgRecord());
						m_lstCannotBuild.AddTail(pregChild);
					}
				}
			}
		}
	}

	// construct our list of dependencies for when we were last attempted to be built?
	if (pgrn->m_fDirtyDepLst)
		pgrn->m_fDirtyDepLst = FALSE;	// dependencies at last build are now clean

	// transfer the actions to the 'master' list versions
	if (fAddAction)
		plstActions->AddToEnd(pAction);
		
	return CMD_Complete;	// ok
}

void CBldFileDepGraph::AddEnumeratedActionFile(CDepGrNode* pgrn, CVCPtrList& lstFrh)
{
	// add the file that caused the action
	lstFrh.AddTail(pgrn->Frh());

	// be aggressive here, mark our parents as likely to be out of date
	for (USHORT iParent = pgrn->CParents(); iParent > 0; iParent--)
	{
		CDepGrNode* pgrnParent = (CDepGrNode *)pgrn->Parent(iParent-1);
		
		UINT depState = pgrnParent->Depstate();

		// if current, then force out of date
		if ((depState & DS_OutOfDate) == 0 || (depState & DS_ForcedOutOfDate) == 0)
			pgrnParent->SetDepstate((depState & ~DS_Current) | DS_ForcedOutOfDate);
	}
}

CMD CBldFileDepGraph::RetrieveDeploymentDependencies(CBldCfgRecord* pcrBuild, IVCBuildStringCollection** ppDeployStrings)
{	
    // for each of these nodes construct a list of actions, don't visit nodes twice
    // which may happen given multiple starts
    ClearVisited();
	CBldFileRegFile::UpdateTimeStampTick();		// this makes it so we don't look up the time stamp on something multiple times

	CMD cmdRet = CMD_Complete;

	VSASSERT(pcrBuild != NULL, "CfgRecord is required parameter for determining build info");
	CStringW strIdb;
	if (pcrBuild != NULL)
	{
		VCConfiguration* pProjCfg = pcrBuild->GetVCConfiguration();
		CComQIPtr<IVCConfigurationImpl> spProjCfgImpl = pProjCfg;
		VSASSERT(spProjCfgImpl != NULL, "CfgRecord improperly initialized");
		CComBSTR bstrIdb;
		if (spProjCfgImpl != NULL)
			spProjCfgImpl->get_MrePath(&bstrIdb);
		strIdb = bstrIdb;
	}

	// Minimal rebuild dependency interface.
	CBldMreDependenciesContainer mreDepend(strIdb);

	// any roots?
	USHORT iRoot = CRoots();
	if (iRoot == 0)
		return CMD_Complete;

	for (; iRoot > 0; iRoot--)
	{
		cmdRet = EnumerateDeploymentDependenciesI((CDepGrNode *)Root(iRoot-1), ppDeployStrings);
		if (cmdRet != CMD_Complete)
			return cmdRet;
	}

	return cmdRet;
}

CMD CBldFileDepGraph::EnumerateDeploymentDependenciesI(CDepGrNode* pgrn, IVCBuildStringCollection** ppDeployStrings)
{	
	// visited
	pgrn->m_fVisited = TRUE;

	ULONG cChildren = pgrn->CChildren();
	if (cChildren == 0)
		return CMD_Complete;

	int cVisited = 0;

	// See if dependencies need to be updated.
    CBldAction* pAction = NULL;
	// the action associated with this node may not be in the first child, but it is always either first or third...
	for (ULONG idx = 0; idx < cChildren && idx < 3; idx++)	
	{
		if (pgrn->Edge(idx) != (EID)NULL)
		{
			pAction = (CBldAction *)pgrn->Edge(idx);
			break;
		}
	}

	if (NULL != pAction)
	{
		if (!pAction->IsDepInfoInitialized())
			pAction->UpdateDepInfo(NULL);
	}

	for (USHORT iChild = cChildren; iChild > 0; iChild--)
	{
		CDepGrNode* pgrnChild = (CDepGrNode *)pgrn->Child(iChild-1);

		// enumerate actions of our child?
		// o recursive and child not visited (depth first, post-order)
		if (!pgrnChild->m_fVisited)
		{
			CMD cmdRet = EnumerateDeploymentDependenciesI(pgrnChild, ppDeployStrings);
			if (cmdRet != CMD_Complete)
				return cmdRet;

			cVisited++;
		}
	}

	RETURN_ON_NULL2(pAction, CMD_Complete);

	// have we already retrieved this?
	if (pAction->m_wMark != CBldAction::m_wActionMarker)
	{
		pAction->GetDeploymentDependencies(ppDeployStrings);
		pAction->m_wMark = CBldAction::m_wActionMarker;
	}
	
	return CMD_Complete;	// ok
}

// CNidGraphDoc implementation
USHORT CBldFileDepGraph::CChildrenInitWalk(NID nidNode)
{
	m_iChild = 0;
	m_pgrnChild = (CGrNode *)nidNode;

	// don't count dependency sets
	int iChild = 0, cChild = 0;
	for (; iChild < m_pgrnChild->CChildren(); iChild++)	
	{
		CDepGrNode* pgrn = (CDepGrNode *)m_pgrnChild->Child(iChild);
		CBldFileRegEntry* preg = g_FileRegistry.GetRegEntry(pgrn->Frh());
		if (!m_fShowDepSets && preg->IsNodeType(CBldFileRegNotifyRx::nodetypeRegSet))
			continue;

		cChild++;
	}

	return cChild;
}

BOOL CBldFileDepGraph::FNextNid(NID & nid, ET & et)
{
NextNidChild:

	if (m_iChild >= m_pgrnChild->CChildren())
		return FALSE;

	CDepGrNode* pgrn = (CDepGrNode *)m_pgrnChild->Child(m_iChild);
	CBldFileRegEntry* preg = g_FileRegistry.GetRegEntry(pgrn->Frh());
	if (!m_fShowDepSets && preg->IsNodeType(CBldFileRegNotifyRx::nodetypeRegSet))
	{
		m_iChild++;
		goto NextNidChild;
	}

	nid = (NID)m_pgrnChild->Child(m_iChild);
	et = m_pgrnChild->Edge(m_iChild++);
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\vcpb\DeployTool.h ===
// DeployTool.h: Definition of the CVCWebDeploymentTool class
//
//////////////////////////////////////////////////////////////////////

#pragma once

#include "vctool.h"
#include "settingspage.h"

// classes in this header
class CVCWebDeploymentTool;
class CDeployToolOptionHandler;
class CVCWebDeploymentGeneralPage;

class CDeployToolOptionHandler : public COptionHandlerBase
{
public:
	DECLARE_OPTION_TABLE()

public:
	// default value handlers
	// string props
	virtual void GetDefaultValue( long id, BSTR *pVal, IVCPropertyContainer *pPropCnt = NULL );
	// integer props
	virtual void GetDefaultValue( long id, long *pVal, IVCPropertyContainer *pPropCnt = NULL );
	// boolean props
	virtual void GetDefaultValue( long id, VARIANT_BOOL *pVal, IVCPropertyContainer *pPropCnt = NULL );
};

/////////////////////////////////////////////////////////////////////////////
// CVCWebDeploymentTool

class ATL_NO_VTABLE CVCWebDeploymentTool : 
	public IDispatchImpl<VCWebDeploymentTool, &IID_VCWebDeploymentTool, &LIBID_VCProjectEngineLibrary, PublicProjBuildTypeLibNumber,0, CVsTypeInfoHolder>, 
	public IVCBuildEventToolInternal,
	public CComObjectRoot,
	public CVCToolImpl
{
public:
	CVCWebDeploymentTool() 
	{
		m_nLowKey = VCDPLYTOOL_MIN_DISPID;
		m_nHighKey = VCDPLYTOOL_MAX_DISPID;
		m_nDirtyKey = VCDPLYID_CmdLineOptionsDirty;
	}
	static HRESULT CreateInstance(IVCPropertyContainer* pPropContainer, IVCToolImpl** ppTool);

BEGIN_COM_MAP(CVCWebDeploymentTool)
	COM_INTERFACE_ENTRY(IVCToolImpl)
 	COM_INTERFACE_ENTRY(VCWebDeploymentTool)
	COM_INTERFACE_ENTRY(IVCBuildEventToolInternal)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE(CVCWebDeploymentTool) 

// VCWebDeploymentTool
public:
	// general
	STDMETHOD(get_ExcludedFromBuild)(VARIANT_BOOL* disableDeploy);	// exclude from build? default: yes
	STDMETHOD(put_ExcludedFromBuild)(VARIANT_BOOL disableDeploy);
	STDMETHOD(get_RelativePath)(BSTR* dir);	// relative path to deploy to
	STDMETHOD(put_RelativePath)(BSTR dir);
	STDMETHOD(get_AdditionalFiles)(BSTR* files);	// additional files to deploy
	STDMETHOD(put_AdditionalFiles)(BSTR files);
	// Server Side Actions
	STDMETHOD(get_UnloadBeforeCopy)(VARIANT_BOOL* unloadFirst);	// unload DLL before copying it?
	STDMETHOD(put_UnloadBeforeCopy)(VARIANT_BOOL unloadFirst);
	STDMETHOD(get_RegisterOutput)(VARIANT_BOOL* regDLL);	// register the DLL once it is deployed?
	STDMETHOD(put_RegisterOutput)(VARIANT_BOOL regDLL);
	// Web Application
	STDMETHOD(get_VirtualDirectoryName)(BSTR* virtRoot);	// virtual root for deployment
	STDMETHOD(put_VirtualDirectoryName)(BSTR virtRoot);
	STDMETHOD(get_ApplicationMappings)(BSTR* mapping);	// application mappings
	STDMETHOD(put_ApplicationMappings)(BSTR mapping);
	STDMETHOD(get_ApplicationProtection)(eAppProtectionOption* option);	// protection level for the app
	STDMETHOD(put_ApplicationProtection)(eAppProtectionOption option);

 	STDMETHOD(get_ToolName)(BSTR* pbstrToolName);	// friendly name of tool, e.g., "C/C++ Compiler Tool"
	STDMETHOD(get_VCProjectEngine)(IDispatch** projEngine)	{ return DoGetVCProjectEngine(projEngine); }

	// Automation properties
	STDMETHOD(get_ToolPath)(BSTR *pVal);
	STDMETHOD(get_PropertyOption)(BSTR bstrProp, long dispidProp, BSTR *pVal);

// IVCBuildEventToolInternal
public:
	STDMETHOD(get_CommandLineInternal)(BSTR *pVal);
	STDMETHOD(put_CommandLineInternal)(BSTR newVal);
	STDMETHOD(get_DescriptionInternal)(BSTR *pVal);
	STDMETHOD(put_DescriptionInternal)(BSTR newVal);
	STDMETHOD(get_ExcludedFromBuildInternal)(VARIANT_BOOL* pbExcludedFromBuild);
	STDMETHOD(put_ExcludedFromBuildInternal)(VARIANT_BOOL bExcludedFromBuild);

// IVCToolImpl
public:
	STDMETHOD(get_DefaultExtensions)(BSTR* pVal);
	STDMETHOD(put_DefaultExtensions)(BSTR newVal);
	STDMETHOD(GetAdditionalOptionsInternal)(IUnknown* pItem, VARIANT_BOOL bForBuild, VARIANT_BOOL bSkipLocal, BSTR* pbstrAdditionalOptions);
	STDMETHOD(GetBuildDescription)(IVCBuildAction* pAction, BSTR* pbstrBuildDescription);
	STDMETHOD(get_ToolPathInternal)(BSTR* pbstrToolPath);
	STDMETHOD(get_Bucket)(long *pVal);
	STDMETHOD(CreateToolObject)(IVCPropertyContainer* pPropContainer, IVCToolImpl** ppToolObject);
	STDMETHOD(GetAdditionalIncludeDirectoriesInternal)(IVCPropertyContainer* pPropContainer, BSTR* pbstrIncDirs);
	STDMETHOD(get_ToolShortName)(BSTR* pbstrToolName);
	STDMETHOD(get_ToolNameInternal)(BSTR* pbstrToolName) { return get_ToolName(pbstrToolName); }
	STDMETHOD(MatchName)(BSTR bstrName, VARIANT_BOOL bFullOnly, VARIANT_BOOL* pbMatches);
	STDMETHOD(CreatePageObject)(IUnknown **, CLSID*, IVCPropertyContainer *, IVCSettingsPage * );
	STDMETHOD(IsTargetTool)(IVCBuildAction* pAction, VARIANT_BOOL* pbTargetTool); // tool always operates on target, not on file
	STDMETHOD(get_IsFileTool)(VARIANT_BOOL* pbIsFileTool);
	STDMETHOD(GetCommandLineEx)(IVCBuildAction* pAction, IVCBuildableItem* pBuildableItem, IVCBuildEngine* pBuildEngine, 
		IVCBuildErrorContext* pEC, BSTR *pVal);

	STDMETHOD(get_ToolDisplayIndex)(long* pIndex)
	{
		CHECK_POINTER_NULL(pIndex);
		*pIndex = TOOL_DISPLAY_INDEX_DEPLOY;
		return S_OK;
	}

	virtual long GetPageCount()	{ return 1; }
	virtual GUID* GetPageIDs();

// helpers
public:
	virtual COptionHandlerBase* GetOptionHandler() { return &s_optHandler; }
	virtual LPCOLESTR GetToolFriendlyName();
	void InitToolName();
	virtual long GetToolID() { return IDS_DEPLOYTOOL; }

protected:
	HRESULT DoGetToolPath(BSTR* pbstrToolPath, IVCPropertyContainer* pPropContainer);

public:
	static CDeployToolOptionHandler s_optHandler;

protected:
	static GUID s_pPages[1];
	static BOOL s_bPagesInit;
	static CComBSTR s_bstrBuildDescription;
	static CComBSTR s_bstrToolName;
	static CComBSTR s_bstrExtensions;
};

class ATL_NO_VTABLE CVCWebDeploymentGeneralPage :
	public IDispatchImpl<IVCWebDeploymentGeneralPage, &IID_IVCWebDeploymentGeneralPage, &LIBID_VCProjectEnginePrivateLibrary, PrivateProjBuildTypeLibNumber,0, CVsTypeInfoHolder>,
	public ICategorizeProperties,
	public CPageObjectImpl<CVCWebDeploymentGeneralPage,VCDPLYTOOL_MIN_DISPID,VCDPLYTOOL_MAX_DISPID>,
	public CComObjectRoot
{
public:

BEGIN_COM_MAP(CVCWebDeploymentGeneralPage)
	COM_INTERFACE_ENTRY(IPerPropertyBrowsing)
	COM_INTERFACE_ENTRY(IVsPerPropertyBrowsing)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IVCPropertyContainer)
	COM_INTERFACE_ENTRY(IVCWebDeploymentGeneralPage)
	COM_INTERFACE_ENTRY(IProvidePropertyBuilder)
	COM_INTERFACE_ENTRY_IID(IID_ICategorizeProperties, ICategorizeProperties)
END_COM_MAP()

	// IDispatch override
	STDMETHOD(Invoke)( DISPID dispid, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS *pdispParams, VARIANT *pvarResult, EXCEPINFO *pexcepInfo, UINT *puArgErr )
	{
		IDispatchImpl<IVCWebDeploymentGeneralPage, &IID_IVCWebDeploymentGeneralPage, &LIBID_VCProjectEnginePrivateLibrary, PrivateProjBuildTypeLibNumber,0, CVsTypeInfoHolder>::Invoke( dispid, riid, lcid, wFlags, pdispParams, pvarResult, pexcepInfo, puArgErr );
		return S_OK;
	}


// ICategorizeProperties
public:
	STDMETHOD(MapPropertyToCategory)(DISPID dispid, PROPCAT* ppropcat);
	STDMETHOD(GetCategoryName)(PROPCAT propcat, LCID lcid, BSTR* pbstrName);

// IVCWebDeploymentGeneralPage
public:
	// general 
	STDMETHOD(get_ExcludedFromBuild)(VARIANT_BOOL* disableDeploy);	// exclude from build? default: yes
	STDMETHOD(put_ExcludedFromBuild)(VARIANT_BOOL disableDeploy);
	STDMETHOD(get_RelativePath)(BSTR* dir);	// relative path to deploy to
	STDMETHOD(put_RelativePath)(BSTR dir);
	STDMETHOD(get_AdditionalFiles)(BSTR* files);	// additional files to deploy
	STDMETHOD(put_AdditionalFiles)(BSTR files);
	// server side actions
	STDMETHOD(get_UnloadBeforeCopy)(VARIANT_BOOL* unloadFirst);	// unload DLL before copying it?
	STDMETHOD(put_UnloadBeforeCopy)(VARIANT_BOOL unloadFirst);
	STDMETHOD(get_RegisterOutput)(VARIANT_BOOL* regDLL);	// register the DLL once it is deployed?
	STDMETHOD(put_RegisterOutput)(VARIANT_BOOL regDLL);
	// web application
	STDMETHOD(get_VirtualDirectoryName)(BSTR* virtRoot);	// virtual root for deployment
	STDMETHOD(put_VirtualDirectoryName)(BSTR virtRoot);
	STDMETHOD(get_ApplicationMappings)(BSTR* mapping);	// application mappings
	STDMETHOD(put_ApplicationMappings)(BSTR mapping);
	STDMETHOD(get_ApplicationProtection)(eAppProtectionOption* option);	// protection level for the app
	STDMETHOD(put_ApplicationProtection)(eAppProtectionOption option);

// helpers
public:
	virtual BOOL UseMultiLineNoInheritDialog(long id) { return (id == VCDPLYID_AdditionalFiles || id == VCDPLYID_ApplicationMappings); }
};

#define DeployProtectMax 2
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\vcpb\dependencygraph.h ===
//
// CGrNode, CGraph, CBldFileDepGraph
//
// Graph node, dependency graph node, graph and dependency graph classes
//
// [matthewt]
//

#ifndef __DEPENDENCYGRAPH_H__
#define __DEPENDENCYGRAPH_H__

#pragma once

#ifdef _DEBUG
// Define DEPGRAPH_VIEW to enable graphical view of dependency graph.
#define DEPGRAPH_VIEW
#endif

#include "FileRegistry.h"	// file registry notification (CBldFileRegNotifyRx)

// needed from buildengine.h
class CDynamicBuildEngine;

//////////////////////////////////
// CGrNode - generic graph node	//
//////////////////////////////////

// node instance identifier
typedef DWORD_PTR NID;
#define nidNil ((DWORD_PTR)-1)

// edge instance identifier
typedef CBldAction* EID;
#define ET EID

// CGrNfyRx events
#define GrEvt_Destroy		0x1

// Relationship manipulation
#define GrEvt_AddChild		0x2
#define GrEvt_AddParent		0x3
#define GrEvt_DelChild		0x4
#define GrEvt_DelParent		0x5

// Edge manipulation
#define GrEvt_AddEdge		0x6
#define GrEvt_DelEdge		0x7

// mode of graph
#define Graph_Creating		0x0
#define Graph_Destroying	0x1
#define Graph_Stable		0x2

// forward decls.
class CGrNode;
class CGraph;
class CBldFileDepGraph;
class CLayout;

class CGrNfyRx
{
public:
	CGrNfyRx() {}
	virtual ~CGrNfyRx() {}

	// Rx for graph node change events
	virtual void OnGrNfy(UINT grevt, CGrNode * grn, void * pvhint) = 0;
};

//////////////////////////////////
// CGrNode - generic graph node	//
//////////////////////////////////

class CGrNode
{
friend class CGraph;
friend class CLayout;

public:
	// constructor+destructor
	CGrNode(CGraph * pgraph, NID nid, USHORT cChildren = 0, USHORT iDepth = 0);
	virtual ~CGrNode();

	// handle our own allocations
	// we'll use our own private Win32 heap
	// and place de-alloc'ed blocks into a 
	// global list

	// retrieve the properties of this graph node
	__inline NID Nid()					{ return m_nid; }
	__inline USHORT	CChildren()			{ return m_cChildren; }
	__inline CGrNode* Child(USHORT i)	{ return m_rgChildren[i]; }
	__inline EID Edge(USHORT i)			{ return m_rgEdges[i]; }
	__inline USHORT CParents()			{ return m_cParents; }
	__inline CGrNode* Parent(USHORT i)	{ return m_rgParents[i]; }

	// layout related
#ifdef DEPGRAPH_VIEW
	__inline USHORT	ICol()				{ return m_iDepth; }
	__inline USHORT	IRow()				{ return m_iPos; }
	__inline BOOL	FFake()				{ return m_fFake; }
	__inline BOOL	CReversed()			{ return m_cReversed; }
	__inline BOOL	FRecursive()		{ return m_fRecursive; }
#if DIANEME_TODO	// CGrNode::SetSize, CGrNode::GetSize
	__inline void	SetSize(CSize size)	{ m_sizeView = size; }
	__inline CSize	GetSize()			{ return m_sizeView; }
#endif	// DIANEME_TODO -- CGrNode::SetSize, CGrNode::GetSize
#endif // DEPGRAPH_VIEW

	// add or remove graph node event receivers
	void AddGrNfyRx(CGrNfyRx* pgrnfyrx);
	void RemoveGrNfyRx(CGrNfyRx* pgrnfyrx);

	// Rx for changes in node connections
	virtual void InformGrNfyRx(UINT grevt, void* pvhint = (void *)0);

	// graph mode changed
	virtual void OnGraphMode(UINT newmode) { /* do nothing */ };

	// add a new child to this node with specified edge
	void AddChild(CGrNode* pgrn, EID eid = (EID)NULL);

	// remove a child (referenced by index)
	void DelChild(USHORT iChild);

	BOOL		m_fVisited:1;		// visited?

protected:
	NID			m_nid;				// node instance identifier
	USHORT		m_cParents;			// count of parents
	USHORT		m_cChildren;		// count of children

	CGrNode**	m_rgChildren;		// array of children
	USHORT		m_allocChildren;	// size of child array alloc.
	USHORT		m_allocParents;		// size of parent array alloc.

	CGrNode**	m_rgParents;		// array of parents

	EID *		m_rgEdges;			// array of edges

	// layout related.
#ifdef DEPGRAPH_VIEW
	BOOL		m_fWorking:1;		// this node is currently being examined
	BOOL		m_fFake:1;			// artifically created node -- invalid handle
	BOOL		m_fRecursive:1;		// mark item as recursive if it is
	USHORT		m_iDepth;			// depth of this item
	USHORT		m_iPos;				// position in column
	CGrNode*	m_pgrnAlias;		// pointer to equivalent fake node
	CGrNode*	m_pgrnNext;			// pointer to next node in queue
	CGrNode*	m_pgrnPrev;			// pointer to prev node in queue
	USHORT		m_iParent;			// next parent to insert
	USHORT		m_cSiblings;		// count of siblings
	USHORT		m_cReversed;		// count of reversed edges
	USHORT		m_cost;				// cost in current position
#if DIANEME_TODO	// CGrNode::m_sizeView
	CSize		m_sizeView;			// cache info to help views out
#endif	// DIANEME_TODO	-- CGrNode::m_sizeView
#endif // DEPGRAPH_VIEW

	// Rx
	CGrNfyRx*	m_GrNfyRx;
 
private:
#ifdef DEPGRAPH_VIEW
	// our assigned graph 
	CGraph*	m_pgraph;
#endif

#ifdef _KIPDEBUG
    static int nCount;
#endif
};

/*
/////////////////////////////////////
// CViewGrNode - visual graph node //
/////////////////////////////////////

class CViewGrNode : public CGrNode
{
public:
	CViewGrNode() {};
	~CViewGrNode() {};
};
*/

////////////////////////////////////////
// CDepGrNode - dependency graph node //
////////////////////////////////////////

// state of a dependency
typedef enum DepState
{
	DS_Unknown = 0x0,			// unknown state
	DS_DepMissing = 0x1,		// dependency missing
	DS_OutOfDate = 0x2,			// dependant out of date wrt dependency
	DS_Current = 0x4,			// dependant is current wrt to dependency
	DS_ForcedOutOfDate= 0x8	// dependant is forced out of date wrt dependency
};

//
// Relationship is as follows:
//
// Dependency (child) <- Dependant (parent)
//
#define DepGrEvt_AddDpnt	GrEvt_AddParent
#define DepGrEvt_DelDpnt	GrEvt_DelParent
#define DepGrEvt_AddDpcy	GrEvt_AddChild
#define DepGrEvt_DelDpcy	GrEvt_DelChild

class CDepGrNode : public CGrNode, CBldFileRegNotifyRx
{
public:
	CDepGrNode(CBldFileDepGraph* pgraph, CBldFileRegistry* pregistry, BldFileRegHandle frh);
	virtual ~CDepGrNode();

	// state query
	__inline UINT Depstate()				{return m_state;}
	__inline void SetDepstate(UINT state)	
		{
			USHORT oldState = m_state;
			m_state = (USHORT)state;
			if( m_state != oldState )
				OnDepStateChanged(m_state);
		}
	__inline CBldFileRegistry*Reg()			{return m_pregistry;}
	__inline BldFileRegHandle Frh()			{return (BldFileRegHandle)Nid();}

	// Rx for changes in dep. connections
	virtual void InformGrNfyRx(UINT grevt, void* pvhint = (void *)0);

	// Rx for file change events
	virtual void OnNotify(BldFileRegHandle hndFileReg, IVCBuildErrorContext* pEC, UINT idChange, void* pHint);

	// figure the dependency state
	// and sent out an inform if it has changed
	void FigureDepState();

	// inform that dependency state has changed
	virtual void OnDepStateChanged(UINT state);

	// graph mode changed
	virtual void OnGraphMode(UINT newmode);

	USHORT 			m_fDirtyDepLst:1;	// the depcy list is dirty

private:
	USHORT			m_fIgnoreDepcy:1;	// ignore dependency changes?
	USHORT			m_state;			// state of this node
	CBldFileRegistry*	m_pregistry;		// our assigned registry
	CBldFileRegSet		m_frsDepcy;			// dependency file registry set; calc. attributes
};

/////////////////////////////////////////////////////////////////////////////////////
// CNidGraphDoc - protocol for applying graph structure to an underlying document //
////////////////////////////////////////////////////////////////////////////////////

class CGraphPainter;
class CNidGraphDoc
{
public:
	// constructor+destructor
	CNidGraphDoc() {}
	virtual ~CNidGraphDoc() {}

	// what is the structure of this graph?
	// the 'protocol', ie. all these methods *must* be implemented in derived class
	virtual USHORT	CRootsInitWalk() = 0;
	virtual BOOL	FNextRoot(NID &) = 0;

	virtual USHORT	CChildrenInitWalk(NID nidNode) = 0;
	virtual BOOL	FNextNid(NID &, ET &) = 0;

	// how is this graph to be drawn?
	virtual CGraphPainter* GetPainter()	{ VSASSERT(FALSE, "GetPainter requires override"); return NULL; }
	virtual USHORT	GetMaxDepth()		{ return 0; }
	virtual BOOL 	IsReversed()		{ return FALSE; }
};

////////////////////////////
// CGraph - generic graph //
////////////////////////////  

// order of performing ops. on graph
#define PrePerform	0x0
#define PostPerform	0x1

// graph operation funcation
typedef BOOL (*GraphOpFn)(CGrNode* pgrn, DWORD& dw, BOOL& fLookChildren);

class CGraph : public CGrNfyRx, public CNidGraphDoc
{
public:
	// constructor+destructor
	CGraph();
	virtual ~CGraph();

	// retrieve the properties of this graph
	__inline USHORT CRoots()			{ return m_cRoots; }
	__inline CGrNode* Root(USHORT i)	{ return m_rgRoots[i]; }

	// add and delete root nodes
	void AddRoot(CGrNode* pgrn);
	void DelRoot(CGrNode* pgrn);

	// insert and remove graph nodes
	void InsertNode(CGrNode* pgrn);
	void RemoveNode(CGrNode* pgrn);

	// clear visited
	void ClearVisited(void);

	// CNidGraphDoc implementation for generic graphs
	USHORT	CRootsInitWalk();
	BOOL	FNextRoot(NID& nid);
	USHORT	CChildrenInitWalk(NID nidNode);
	BOOL	FNextNid(NID&, ET&);

	// graph node lookup
	__inline BOOL LookupNode(NID nid, CGrNode*& pgrn)
		{ return m_mapNodes.Lookup((void *)nid, (void * &)pgrn); }

	// set graph mode
	UINT SetGraphMode(UINT mode);

	// Rx for graph node change events
	virtual void OnGrNfy(UINT grevt, CGrNode* pgrn, void* pvhint);

	// perform a graph operation 'pfn' over each node in the graph
	// passes the 'dwUser' to the operation
	// performs in the order specified by 'order'
	// starts with 'nid' or all roots if nid == nidNil
//	BOOL PerformOperation(GraphOpFn pfn, DWORD& dwUser, UINT order = PrePerform, NID nid = nidNil);

	UINT		m_mode;			// mode of the graph

protected:
//	BOOL PerformOperationI(GraphOpFn pfn, DWORD& dwUser, UINT order, CGrNode* pgrn);

	CGrNode**   m_rgRoots;		// our array pf root nodes
	USHORT		m_allocRoots;	// size of root array alloc.

	USHORT		m_cRoots;		// count of roots
	USHORT		m_iRoot;		// state of root graph walk
	USHORT		m_iChild;		// state of children graph walk
	CGrNode*	m_pgrnChild;	// current node in walk

	CVCMapPtrToPtr m_mapNodes;	// our map of the nodes
};

//////////////////////////////////////
// CBldFileDepGraph - dependency graph //
//////////////////////////////////////

// attributes of dependency graph retrieval
#define AOR_None		0x0		// none
#define AOR_Recurse		0x1		// recursively check dependencies
#define AOR_ChkOpts		0x2		// check for action option changes
#define AOR_Verbose		0x4		// verbose mode, ie. use prompts etc.
#define AOR_PreChk		0x8		// pre-check dependencies, ie. don't reset state
#define AOR_ChkInp		0x10	// check for action input changes
#define AOR_Default		(AOR_Recurse | AOR_ChkOpts | AOR_Verbose)

// type of dependency
#define DEP_Scanned		0x1
#define DEP_Source		0x2
#define DEP_Input		0x3
#define DEP_Output		0x4
#define DEP_Dependency	0x5
#define DEP_Missing		0x6
#define DEP_UserDefined	0x7		// Never scanned or modified except by user.

class CBldAction;
class CBldFileDepGraph : public CGraph
{
public:
	CBldFileDepGraph(CBldFileRegistry * pregistry);
	virtual ~CBldFileDepGraph();
	
	BOOL IsInitialized()		{ return m_bInitialized; }
	void SetGraphInitialized()	{ m_bInitialized = TRUE; }

	// Dependency graph modification
	BOOL ModifyDep(BldFileRegHandle frhDep, CBldAction* pAction, UINT dep, BOOL fAdd, IVCBuildErrorContext* pEC,
		BOOL fWithAction = TRUE);

	// find a dependency 'frhDep'
	//
	// 'pgrn' is the last found CGrNode (last in 'arggrn')
	// 'arygrn' is the accumulated list of CGrNode's that have the dep. (if NULL then find just one == 'pgrn')
	// 'fSearchSets' search in dependency sets?
	BOOL FindDep(BldFileRegHandle frhDep, CDepGrNode*& pgrn, CVCPtrArray* parygrn = (CVCPtrArray *)NULL,
		BOOL fSearchSets = FALSE);

	// Dependency graph info. retrieval
	void StartPasses();

	// what actions are performed on the dependencies with a state in 'stateFilter' (default is 'not current')?
	// o 'lstFrh' is a list of all files whose state 'match' caused the action addition
	// o 'frhStart' is the dependent to start from (default is 'do all out of date')
	// o 'aor' attributes of action retrieval (default is 'verbose, recurse and check for option changes')
	// returns CMD_ value
	CMD RetrieveBuildActions(CBldCfgRecord* pcrBuild, CBldActionList* plstActions, CVCPtrList& lstFrh, 
		IVCBuildErrorContext* pEC, CDynamicBuildEngine* pBldEngine, BldFileRegHandle frhStart = (BldFileRegHandle)NULL, 
		UINT stateFilter = DS_OutOfDate | DS_ForcedOutOfDate, UINT aor = AOR_Default, BOOL bCheckTimeStamps = TRUE);

	// what actions 'contribute' to the dependent?
	// o 'plstActions' is a list of actions
	// o 'frhStart' is the dependent to start from
	// return CMD_ value
	UINT RetrieveOutputActions(CBldActionList* plstActions, IVCBuildErrorContext* pEC, BldFileRegHandle frhStart);
	
	// what deployment dependencies do we have?
	CMD RetrieveDeploymentDependencies(CBldCfgRecord* pcrBuild, IVCBuildStringCollection** ppDeployStrings);

	// CNidGraphDoc implementation for file dependency graphs
	virtual USHORT	CChildrenInitWalk(NID nidNode);
	virtual BOOL	FNextNid(NID &, ET &);

	// should we 'count' the dependency sets as part of our graph document?
	BOOL m_fShowDepSets;

private:
	// add a dependency relationship
	// o 'frhDpcy' is the file(s) we are dependent on
	// o 'frhDpnt is the dependent file(s)
	// o 'pActionSlob' is the action that should be performed to
	//    make the dependant 'current' wrt the dependency
	BOOL AddDepEdgeI(BldFileRegHandle frhDpcy, BldFileRegHandle frhDpnt, CBldAction* pActionSlob = (CBldAction *)NULL);

	// remove a dependency relationship 
	BOOL RemoveDepEdgeI(BldFileRegHandle frhDpcy, BldFileRegHandle frhDpnt, 
		CBldAction* pActionSlob = (CBldAction *)NULL, BOOL fAllDepnts = FALSE);

	// helper for RetrieveBuildActions(); returns CMD_ value
	CMD EnumerateBuildActionsI(CBldActionList* plstActions, CVCPtrList& lstFrh, IVCBuildErrorContext* pEC,
		CDynamicBuildEngine* pBldEngine, CDepGrNode* pgrn, UINT stateFilter, UINT& aor, BOOL bCheckTimeStamps);
	void AddEnumeratedActionFile(CDepGrNode* pgrn, CVCPtrList& lstFrh);
	BOOL HandleDependencyInfo(CBldAction* pAction);
	CMD EnumerateDeploymentDependenciesI(CDepGrNode* pgrn, IVCBuildStringCollection** ppDeployStrings);

	CVCPtrList 		m_lstDepSets;			// our list of dep. sets
	CBldFileRegistry*  m_pregistry;			// our assigned registry
	CVCPtrList		m_lstCannotBuild;		// cannot build list
	BOOL 			m_bInitialized;			// have we OnInformed yet ?
};

#endif // __DEPENDENCYGRAPH_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\vcpb\encbldthrd.cpp ===
// EnCEncBldThrd.pp: implementation of the CEnCEncBldThrd class.
//
//		Supports background rebuild for Edit and Continue
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "VCProjectEngine.h"
#include "buildengine.h"
#include <fcntl.h>
#include "msgboxes2.h"
#include "profile.h"

#include "encbldthrd.h"
#include "path2.h"
#include "EnvDaemon.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CEncBldThrd::CEncBldThrd()
{
	m_hThread = NULL;
	m_dwThreadId = 0;
	m_lErrors = 0;
	m_lWarnings = 0;
	m_hResult = 0;

	m_pStreamENCBuildSpawnerCallback = NULL;
}

CEncBldThrd::~CEncBldThrd()
{
	if (m_hThread)
	{ 
		::CloseHandle(m_hThread);
	}
}


BOOL CEncBldThrd::Init(LPCOLESTR szCmdLine, LPCOLESTR szCurrentDir, IVCBuildErrorContext* pIVCBuildErrorContext,
	IVCBuildEngine* pBuildEngine, IENCBuildSpawnerCallback *pENCBuildSpawnerCallback, BOOL fUseConsoleCP)
{
	if (m_hThread || pIVCBuildErrorContext == NULL || pBuildEngine == NULL)
	{
		return FALSE; // can't have more than one thread going....
	}

	m_spBuildEngineImpl = pBuildEngine;
	if (m_spBuildEngineImpl == NULL)
		return FALSE;	// bad build engine

	m_szCurrentDir = szCurrentDir;
	m_fUseConsoleCP = fUseConsoleCP;

	CDirW dir;
	if (!dir.CreateFromString(szCurrentDir))
		return FALSE;

	m_szCmdLine = szCmdLine;

	m_lErrors = 0;
	m_lWarnings = 0;
	m_hResult = 0;

	VSASSERT(NULL == m_pStreamENCBuildSpawnerCallback, "ENCBuildSpawnerCallback already initialized before it should have been.");

	if (pENCBuildSpawnerCallback)
	{
		HRESULT hr = CoMarshalInterThreadInterfaceInStream(
			__uuidof (IENCBuildSpawnerCallback),
			(IUnknown *)pENCBuildSpawnerCallback,
			&m_pStreamENCBuildSpawnerCallback
			);

		VSASSERT(SUCCEEDED(hr), "Failed to marshal ENCBuildSpawnerCallback");
	}
	
	m_spBuildErrorContext = pIVCBuildErrorContext;
	m_spBuildEngineImpl->put_ErrorContext(pIVCBuildErrorContext);
	pIVCBuildErrorContext->put_AssociatedBuildEngine(pBuildEngine);		// make sure we're talking to the same build engine...

	CComBSTR bstrCurrentDir = szCurrentDir;
	pIVCBuildErrorContext->put_BaseDirectory(bstrCurrentDir);

	return TRUE;
}

void CEncBldThrd::Wait()
{
	if (m_hThread)
	{
		WaitForSingleObject(m_hThread, INFINITE);
	}	
}


/* static */ DWORD WINAPI CEncBldThrd::EncBuildThread(LPVOID *pvBldThrd)
{
	CEncBldThrd *pBldThrd = (CEncBldThrd *)pvBldThrd;  // this is a static function; replace use of "this" with pBldThrd.

	// By default you had an error
	pBldThrd->m_hResult	 = E_FAIL;
	pBldThrd->m_lErrors = 1;

	CoInitialize(NULL); // make sure we can do ole in this thread
	VSASSERT(pBldThrd, "Trying to start ENCBldThrd before creating it");

	// Get the callback	pointer
	CComPtr<IENCBuildSpawnerCallback> pCallback;

	if (pBldThrd->m_pStreamENCBuildSpawnerCallback)	{
	
		HRESULT	hr = CoGetInterfaceAndReleaseStream(
			pBldThrd->m_pStreamENCBuildSpawnerCallback,
			__uuidof (IENCBuildSpawnerCallback),
			(void**)&pCallback
			);

		VSASSERT (SUCCEEDED	(hr), "Failed to unmarshal ENCBuildSpawnerCallback");
		
		pBldThrd->m_pStreamENCBuildSpawnerCallback = NULL;
	}

	// The following will be deleted by CSpawner::DoSpawn
	CComPtr<IVCCommandLine> pCmdLine;
	HRESULT hr = CVCCommandLine::CreateInstance(&pCmdLine);

	VSASSERT(SUCCEEDED(hr) && pCmdLine != NULL, "Failed to create the command line for the ENC build spawner");

	hr = pBldThrd->m_spBuildEngineImpl->InitializeSpawner(FALSE);
	VSASSERT(SUCCEEDED(hr), "Failed to initialize the error context for the ENC build spawner");

	if (SUCCEEDED(hr))
	{
		// Create CCmdLine object 
		CComPtr<IVCCommandLineList> plCmds;
		hr = CVCCommandLineList::CreateInstance(&plCmds);
		VSASSERT(SUCCEEDED(hr) && plCmds != NULL, "Failed to create the command line list for the ENC build spawner");

		pCmdLine->put_CommandLineContents(pBldThrd->m_szCmdLine);
		pCmdLine->put_Description(OLESTR(""));

		plCmds->Add(pCmdLine, FALSE);
		if ( pBldThrd->m_fUseConsoleCP )
			plCmds->put_UseConsoleCodePageForSpawner( VARIANT_TRUE );
		else
			plCmds->put_UseConsoleCodePageForSpawner( VARIANT_FALSE );

		VSASSERT(g_pProjectEngine != NULL, "Project engine not initialized.  Deep trouble.");

		CComPtr<IDispatch>		 pDispPlatformList;
		CComQIPtr<IVCCollection> pPlatformList;
		CComQIPtr<VCPlatform>	 pPlatform; 

		hr = g_pProjectEngine->get_Platforms(&pDispPlatformList);
		pPlatformList = pDispPlatformList;

		if (SUCCEEDED(hr) && pPlatformList)
		{
			CComPtr<IDispatch> pDispPlatform;
			pPlatformList->Item(CComVariant(L"Win32"), &pDispPlatform);
			pPlatform = pDispPlatform;
		}

		if (pPlatform != NULL)
		{
			CEnvironmentKeeper envKeeper(pPlatform);

			long cmd = CMD_Complete;
			pBldThrd->m_spBuildEngineImpl->SpawnBuild(plCmds, pBldThrd->m_szCurrentDir, FALSE, FALSE, 
				pBldThrd->m_spBuildErrorContext, TRUE, &cmd);
			CComQIPtr<IVCBuildEngine> spBuildEngine = pBldThrd->m_spBuildEngineImpl;
			if (pBldThrd->m_spBuildErrorContext)
			{
				pBldThrd->m_spBuildErrorContext->get_Errors(&(pBldThrd->m_lErrors));
				pBldThrd->m_spBuildErrorContext->get_Warnings(&(pBldThrd->m_lWarnings));
			}

			switch (cmd) {
			case CMD_Complete:
				pBldThrd->m_hResult = NOERROR;
				break;
			case CMD_Canceled:
				pBldThrd->m_hResult = E_ABORT;
				break;
			default:
				//VSASSERT(FALSE, "compiler/linker returned errorcode");
				pBldThrd->m_hResult = S_FALSE;
				// fixup case where an error occured but the spawner couldn't figure that out.
				// REVIEW: the whole counting of errors scheme should be reworked so we don't have to do this.
				// [vs98 24842]
				if (0 == pBldThrd->m_lErrors)
					pBldThrd->m_lErrors ++;
			}

			if (cmd == CMD_Canceled) {
				CComBSTR msg;
				msg.LoadString(IDS_USERCANCELED);
				pBldThrd->m_spBuildErrorContext->AddLine(msg);
			}

			pBldThrd->m_spBuildEngineImpl->TerminateSpawner();
		}
	}
	 
	if (pBldThrd->m_spBuildErrorContext) {

		// If we had errors or warnings, activate task list
		pBldThrd->m_spBuildErrorContext->ActivateTaskList(VARIANT_FALSE);
		pBldThrd->m_spBuildErrorContext->put_AssociatedBuildEngine(NULL);
	}

	if (pBldThrd->m_spBuildEngineImpl)
		pBldThrd->m_spBuildEngineImpl->put_ErrorContext(NULL);

	pBldThrd->m_spBuildErrorContext.Release();
	pBldThrd->m_spBuildEngineImpl.Release();

	HRESULT hrFromBuild = pBldThrd->m_hResult;
	DWORD	dwErrors = (DWORD)pBldThrd->m_lErrors;
	DWORD	dwWarnings = (DWORD)pBldThrd->m_lWarnings;

	pBldThrd->m_hThread = NULL; // allow a new thread to start up....

	VSASSERT( pCallback != NULL, "Can't call back to ecbuild!!!" );

	if ( pCallback ) {
		hr = pCallback->Done( hrFromBuild, dwErrors, dwWarnings);
		VSASSERT( hr == S_OK, "error calling ecbuild call back!!!" );
	}

	CoUninitialize();
	return (S_OK);
}



BOOL CEncBldThrd::FStart()
{
	if (m_hThread != NULL)
		return FALSE; // can't have more than one thread going....
	
	VARIANT_BOOL bSpawnerActive = VARIANT_TRUE;
	CComQIPtr<IVCBuildEngine> spBuildEngine = m_spBuildEngineImpl;
	if (spBuildEngine == NULL)
		return FALSE;	// bad input parameter

	spBuildEngine->get_SpawnerActive(&bSpawnerActive);
	if (bSpawnerActive == VARIANT_TRUE)
	{
		return FALSE; // can't have more than one thread going....
	}

	return CreateThread();
}

BOOL CEncBldThrd::CreateThread()
{
	m_hThread = ::CreateThread(NULL,		// default security attributes
								0,			// default stack size
								(LPTHREAD_START_ROUTINE) &EncBuildThread,
								(LPVOID)this,
								0,			// create and execute thread
								&m_dwThreadId);

	return (m_hThread != NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\vcpb\encbldthrd.h ===
// EncBldThrd.h: interface for the CEncBldThrd class.
//
//////////////////////////////////////////////////////////////////////

#pragma once

class CEncBldThrd  
{
public:
	BOOL FStart();
	CEncBldThrd();
	virtual ~CEncBldThrd();
	BOOL Init(LPCOLESTR szCmdLine, LPCOLESTR szCurrentDir, IVCBuildErrorContext* pIVCBuildErrorContext,
		IVCBuildEngine* pBuildEngine, IENCBuildSpawnerCallback *pENCBuildSpawnerCallback, BOOL fUseConsoleCP);
	void Wait();

	DWORD GetErrorCount() 
	{ return (DWORD)m_lErrors; }

	DWORD GetWarningCount()
	{ return (DWORD)m_lWarnings; }

	HRESULT GetHResult()
	{ return m_hResult; }

protected:
	static DWORD WINAPI EncBuildThread(LPVOID *pvGenCfg );
    BOOL CreateThread();

	CComBSTR m_szCmdLine;
	CComBSTR m_szCurrentDir;
	BOOL m_fUseConsoleCP;

    HANDLE m_hThread;
	DWORD m_dwThreadId;

	long m_lErrors;
	long m_lWarnings;
	HRESULT m_hResult;

	CComPtr<IENCBuildSpawnerCallback> m_pENCBuildSpawnerCallback;
	CComQIPtr<IVCBuildEngineImpl> m_spBuildEngineImpl;
	CComPtr<IVCBuildErrorContext> m_spBuildErrorContext;
	IStream *m_pStreamENCBuildSpawnerCallback;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\vcpb\DeployTool.cpp ===
// DeployTool.cpp : Implementation of Web Deployment Tool

#include "stdafx.h"
#include "DeployTool.h"
#include "BuildEngine.h"
#include "scanner.h"
#include "ProjWriter.h"
#include "XMLFile.h"
#include "stylesheet.h"
#include "linktool.h"

// constants
const wchar_t* const wszDeployDefaultExtensions = L"";	// remember to update vcpb.rgs if you change this...

// static initializers
CDeployToolOptionHandler CVCWebDeploymentTool::s_optHandler;
CComBSTR CVCWebDeploymentTool::s_bstrBuildDescription = L"";
CComBSTR CVCWebDeploymentTool::s_bstrToolName = L"";
CComBSTR CVCWebDeploymentTool::s_bstrExtensions = L"";
GUID CVCWebDeploymentTool::s_pPages[1];
BOOL CVCWebDeploymentTool::s_bPagesInit;

////////////////////////////////////////////////////////////////////////////////
// Option Table for Web Service Utility switches

// NOTE: we're using macros for enum value ranges to help in keeping enum range checks as low maintenance as possible.
// If you add an enum to this table, make sure you use macros to define the upper and lower bounds and use CHECK_BOUNDS
// on the get/put methods associated with that property (both object model and property page).
// NOTE 2: this table is being used for persistence ONLY.  We generate our command line elsewhere since it is an XML file.
// WARNING: if you change ANYTHING about a multi-prop here (including add/remove), be sure to update how the property
// is obtained on both the tool and page objects.
BEGIN_OPTION_TABLE(CDeployToolOptionHandler, L"VCWebDeploymentTool", IDS_DEPLOYTOOL, TRUE /* pre & post */, FALSE /* case sensitive */)
	// general
	OPT_BOOL(ExcludedFromBuild,		L"F1|T1",		L"ExcludedFromBuild",		IDS_DEPLOYTOOL,	VCDPLYID)
	OPT_BSTR(RelativePath,			L"B %s",		L"RelativePath",	single,	IDS_DEPLOYTOOL,	VCDPLYID)
	OPT_BSTR(AdditionalFiles,		L"A %s",		L"AdditionalFiles",	single,	IDS_DEPLOYTOOL,	VCDPLYID)
	OPT_BOOL(UnloadBeforeCopy,		L"F2|T2",		L"UnloadBeforeCopy",	IDS_DEPLOYTOOL,	VCDPLYID)
	OPT_BOOL(RegisterOutput,		L"F3|T3",		L"RegisterOutput",			IDS_DEPLOYTOOL,	VCDPLYID)
	OPT_BSTR(VirtualDirectoryName,	L"C %s",		L"VirtualDirectoryName", single, IDS_DEPLOYTOOL, VCDPLYID)
	OPT_BSTR(ApplicationMappings,	L"E %s",		L"ApplicationMappings", single, IDS_DEPLOYTOOL, VCDPLYID)
	OPT_ENUM(ApplicationProtection,	L"0|1|2", StdEnumMin, DeployProtectMax, L"ApplicationProtection", IDS_DEPLOYTOOL, VCDPLYID)
END_OPTION_TABLE()


// default value handlers
// string props
void CDeployToolOptionHandler::GetDefaultValue( long id, BSTR *pVal, IVCPropertyContainer *pPropCnt )
{
	CComBSTR bstrDef;
	switch (id)
	{
	case VCDPLYID_VirtualDirectoryName:
		bstrDef = L"$(SolutionName)";
		*pVal = bstrDef.Detach();
		break;
	case VCDPLYID_RelativePath:
		bstrDef = L"bin";
		*pVal = bstrDef.Detach();
		break;
//	case VCDPLYID_AdditionalFiles:
//	case VCDPLYID_ApplicationMappings:
	default:
		GetDefaultString(pVal);
		break;
	}
}

// integer props
void CDeployToolOptionHandler::GetDefaultValue( long id, long *pVal, IVCPropertyContainer *pPropCnt )
{
	// VCDPLYID_ApplicationProtection
	*pVal = 0;
}

// boolean props
void CDeployToolOptionHandler::GetDefaultValue( long id, VARIANT_BOOL *pVal, IVCPropertyContainer *pPropCnt )
{
	if ( id == VCDPLYID_ExcludedFromBuild )
		GetValueTrue( pVal );
	else	// VCDPLYID_UnloadBeforeCopy, VCDPLYID_RegisterOutput
		GetValueFalse( pVal );
}


///////////////////////////////////////////////////////////////////////////////
// Web Deployment Tool
HRESULT CVCWebDeploymentTool::CreateInstance(IVCPropertyContainer* pPropContainer, IVCToolImpl** ppDeployTool)
{
	CHECK_POINTER_NULL(ppDeployTool);
	*ppDeployTool = NULL;

	CComObject<CVCWebDeploymentTool> *pObj;
	HRESULT hr = CComObject<CVCWebDeploymentTool>::CreateInstance(&pObj);
	if (SUCCEEDED(hr))
	{
		if( pPropContainer )
			pObj->Initialize(pPropContainer);
		CVCWebDeploymentTool *pVar = pObj;
		pVar->AddRef();
		*ppDeployTool = pVar;
	}
	return hr;
}

STDMETHODIMP CVCWebDeploymentTool::CreatePageObject(IUnknown **ppUnk, CLSID*pCLSID, IVCPropertyContainer *pPropCntr, IVCSettingsPage *pPage )
{
	// Get the list of pages
	if( CLSID_WebDeploymentGeneral == *pCLSID )
	{
		CPageObjectImpl< CVCWebDeploymentGeneralPage, VCDPLYTOOL_MIN_DISPID, VCDPLYTOOL_MAX_DISPID >::CreateInstance(ppUnk, pPropCntr, pPage);
	}
	else
	{
		return S_FALSE;
	}
		
	return S_OK;
}


GUID* CVCWebDeploymentTool::GetPageIDs()
{ 
	if (s_bPagesInit == FALSE)
	{
		s_pPages[0] = __uuidof(WebDeploymentGeneral);
		s_bPagesInit = TRUE;
	}
	return s_pPages; 
}


///////////////////////////////////////////////////////////////////////////////////////
// CVCWebDeploymentTool::CVCWebDeploymentTool
///////////////////////////////////////////////////////////////////////////////////////

// general 
LPCOLESTR CVCWebDeploymentTool::GetToolFriendlyName()
{
	InitToolName();
	return s_bstrToolName;
}

void CVCWebDeploymentTool::InitToolName()
{
	if (s_bstrToolName.Length() == 0)
	{
		if (!s_bstrToolName.LoadString(IDS_DEPLOY_TOOLNAME))
			s_bstrToolName = szDeployToolType;
	}
}

STDMETHODIMP CVCWebDeploymentTool::get_ToolName(BSTR* pbstrToolName)
{	// friendly name of tool, e.g., "C/C++ Compiler Tool"
	CHECK_POINTER_VALID( pbstrToolName );
	InitToolName();
	s_bstrToolName.CopyTo(pbstrToolName);
	return S_OK;
}

STDMETHODIMP CVCWebDeploymentTool::get_ExcludedFromBuild(VARIANT_BOOL* disableDeploy)
{	// exclude from build? default: yes
	return ToolGetBoolProperty(VCDPLYID_ExcludedFromBuild, disableDeploy);
}

STDMETHODIMP CVCWebDeploymentTool::put_ExcludedFromBuild(VARIANT_BOOL disableDeploy)
{
	CHECK_ZOMBIE(m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE);
	CHECK_VARIANTBOOL(disableDeploy);
	return m_spPropertyContainer->SetBoolProperty(VCDPLYID_ExcludedFromBuild, disableDeploy);
}

STDMETHODIMP CVCWebDeploymentTool::get_RelativePath(BSTR* dir)
{	// relative path to deploy to
	return ToolGetStrProperty(VCDPLYID_RelativePath, dir);
}

STDMETHODIMP CVCWebDeploymentTool::put_RelativePath(BSTR dir)
{
	CHECK_ZOMBIE(m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE);
	return m_spPropertyContainer->SetStrProperty(VCDPLYID_RelativePath, dir);
}

STDMETHODIMP CVCWebDeploymentTool::get_AdditionalFiles(BSTR* files)
{	// additional files to deploy
	return ToolGetStrProperty(VCDPLYID_AdditionalFiles, files);
}

STDMETHODIMP CVCWebDeploymentTool::put_AdditionalFiles(BSTR files)
{
	CHECK_ZOMBIE(m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE);
	return m_spPropertyContainer->SetStrProperty(VCDPLYID_AdditionalFiles, files);
}

STDMETHODIMP CVCWebDeploymentTool::get_UnloadBeforeCopy(VARIANT_BOOL* unloadFirst)
{	// unload DLL before copying it?
	return ToolGetBoolProperty(VCDPLYID_UnloadBeforeCopy, unloadFirst);
}

STDMETHODIMP CVCWebDeploymentTool::put_UnloadBeforeCopy(VARIANT_BOOL unloadFirst)
{
	CHECK_ZOMBIE(m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE);
	CHECK_VARIANTBOOL(unloadFirst);
	return m_spPropertyContainer->SetBoolProperty(VCDPLYID_UnloadBeforeCopy, unloadFirst);
}

STDMETHODIMP CVCWebDeploymentTool::get_RegisterOutput(VARIANT_BOOL* regDLL)
{	// register the DLL once it is deployed?
	return ToolGetBoolProperty(VCDPLYID_RegisterOutput, regDLL);
}

STDMETHODIMP CVCWebDeploymentTool::put_RegisterOutput(VARIANT_BOOL regDLL)
{
	CHECK_ZOMBIE(m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE);
	CHECK_VARIANTBOOL(regDLL);
	return m_spPropertyContainer->SetBoolProperty(VCDPLYID_RegisterOutput, regDLL);
}

STDMETHODIMP CVCWebDeploymentTool::get_VirtualDirectoryName(BSTR* virtRoot)
{	// virtual root for deployment
	return ToolGetStrProperty(VCDPLYID_VirtualDirectoryName, virtRoot);
}

STDMETHODIMP CVCWebDeploymentTool::put_VirtualDirectoryName(BSTR virtRoot)
{
	CHECK_ZOMBIE(m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE);
	return m_spPropertyContainer->SetStrProperty(VCDPLYID_VirtualDirectoryName, virtRoot);
}

STDMETHODIMP CVCWebDeploymentTool::get_ApplicationMappings(BSTR* mapping)
{	// application mappings
	return ToolGetStrProperty(VCDPLYID_ApplicationMappings, mapping);
}

STDMETHODIMP CVCWebDeploymentTool::put_ApplicationMappings(BSTR mapping)
{
	CHECK_ZOMBIE(m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE);
	return m_spPropertyContainer->SetStrProperty(VCDPLYID_ApplicationMappings, mapping);
}

STDMETHODIMP CVCWebDeploymentTool::get_ApplicationProtection(eAppProtectionOption* option)
{	// protection level for the app
	return ToolGetIntProperty(VCDPLYID_ApplicationProtection, (long *)option);
}

STDMETHODIMP CVCWebDeploymentTool::put_ApplicationProtection(eAppProtectionOption option)
{
	CHECK_ZOMBIE(m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE);
	CHECK_BOUNDS(StdEnumMin, DeployProtectMax, option);
	return m_spPropertyContainer->SetIntProperty(VCDPLYID_ApplicationProtection, option);
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
// CVCWebDeploymentTool::IVCToolImpl
/////////////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CVCWebDeploymentTool::get_DefaultExtensions(BSTR* pVal)
{
	return DoGetDefaultExtensions(s_bstrExtensions, wszDeployDefaultExtensions, pVal);
}

STDMETHODIMP CVCWebDeploymentTool::put_DefaultExtensions(BSTR newVal)
{
	s_bstrExtensions = newVal;
	return S_OK;
}

STDMETHODIMP CVCWebDeploymentTool::GetAdditionalOptionsInternal(IUnknown* pItem, VARIANT_BOOL bForBuild, VARIANT_BOOL bSkipLocal, 
	BSTR* pbstrAdditionalOptions)
{
	return S_FALSE;
}

STDMETHODIMP CVCWebDeploymentTool::GetBuildDescription(IVCBuildAction* pAction, BSTR* pbstrBuildDescription)
{
	if (s_bstrBuildDescription.Length() == 0)
		s_bstrBuildDescription.LoadString(IDS_DESC_DEPLOYING);
	return s_bstrBuildDescription.CopyTo(pbstrBuildDescription);
}

STDMETHODIMP CVCWebDeploymentTool::get_ToolPathInternal(BSTR* pbstrToolPath)
{ 
	return get_ToolPath(pbstrToolPath);
}

STDMETHODIMP CVCWebDeploymentTool::get_Bucket(long *pVal)
{
	CHECK_POINTER_NULL( pVal );
	*pVal = BUCKET_DEPLOY;
	return S_OK;
}

STDMETHODIMP CVCWebDeploymentTool::CreateToolObject(IVCPropertyContainer* pPropContainer, IVCToolImpl** ppToolObject)
{ 
	return CreateInstance(pPropContainer, ppToolObject); 
}

STDMETHODIMP CVCWebDeploymentTool::GetAdditionalIncludeDirectoriesInternal(IVCPropertyContainer* pPropContainer, BSTR* pbstrIncDirs)
{
	return E_NOTIMPL;
}

STDMETHODIMP CVCWebDeploymentTool::get_ToolShortName(BSTR* pbstrToolName)
{
	CHECK_POINTER_NULL(pbstrToolName);
	*pbstrToolName = SysAllocString( szDeployToolShortName );
	return S_OK;
}

STDMETHODIMP CVCWebDeploymentTool::MatchName(BSTR bstrName, VARIANT_BOOL bFullOnly, VARIANT_BOOL* pbMatches)
{
	return DoMatchName(bstrName, szDeployToolType, szDeployToolShortName, pbMatches);
}

HRESULT CVCWebDeploymentTool::DoGetToolPath(BSTR* pbstrToolPath, IVCPropertyContainer* pPropContainer)
{
	CHECK_POINTER_NULL(pbstrToolPath);
	*pbstrToolPath = SysAllocString( szDeployToolPath );
	return S_OK;
}

STDMETHODIMP CVCWebDeploymentTool::get_ToolPath(BSTR* pbstrToolPath)
{
	return DoGetToolPath(pbstrToolPath, m_spPropertyContainer);
}

STDMETHODIMP CVCWebDeploymentTool::get_PropertyOption(BSTR bstrProp, long dispidProp, BSTR *pVal)
{ 
	return E_NOTIMPL;
}

STDMETHODIMP CVCWebDeploymentTool::IsTargetTool(IVCBuildAction* pAction, VARIANT_BOOL* pbTargetTool)
{ // tool always operates on target, not on file
	return COptionHandlerBase::GetValueTrue(pbTargetTool);
}

STDMETHODIMP CVCWebDeploymentTool::get_IsFileTool(VARIANT_BOOL* pbIsFileTool)
{
	return COptionHandlerBase::GetValueFalse(pbIsFileTool);
}

STDMETHODIMP CVCWebDeploymentTool::GetCommandLineEx(IVCBuildAction* pAction, IVCBuildableItem* pBuildableItem, 
	IVCBuildEngine* pBuildEngine, IVCBuildErrorContext* pEC, BSTR *pVal)
{
	CHECK_POINTER_NULL(pVal);
	*pVal = NULL;
	CHECK_READ_POINTER_NULL(pBuildableItem);
	CHECK_READ_POINTER_NULL(pBuildEngine);

	CComQIPtr<IVCPropertyContainer> spPropContainer = pBuildableItem;
	CHECK_ZOMBIE(spPropContainer, IDS_ERR_TOOL_ZOMBIE);

	// NONE of this stuff is localizable which is why it is inline here...
	CComBSTR bstrCmdLine = L"<?xml version=\"1.0\" encoding=\"";
	CComBSTR bstrTmp, bstrTmp2;
	CXMLFile::DetermineDefaultFileEncoding(bstrTmp);
	bstrCmdLine += bstrTmp;
	bstrCmdLine += L"\"?>\n<ATLSINSTSETTINGS>\n\t<WEBHOSTNAME>localhost</WEBHOSTNAME>\n";

	// figure out the virtual root and the IIS root directory
	bstrTmp.Empty();
	CComBSTR bstrVirtDir;
	HRESULT hr = spPropContainer->GetStrProperty(VCDPLYID_VirtualDirectoryName, &bstrTmp);
	if (hr == S_FALSE)
		s_optHandler.GetDefaultValue(VCDPLYID_VirtualDirectoryName, &bstrTmp);
	hr = spPropContainer->Evaluate(bstrTmp, &bstrVirtDir);
	RETURN_ON_FAIL(hr);
	if (bstrVirtDir.Length() == 0)	// cannot have a blank virtual root...
	{
		bstrTmp.Empty();
		bstrVirtDir.Empty();
		s_optHandler.GetDefaultValue(VCDPLYID_VirtualDirectoryName, &bstrTmp);
		hr = spPropContainer->Evaluate(bstrTmp, &bstrVirtDir);
		RETURN_ON_FAIL(hr);
	}

	bstrCmdLine += L"\t<VIRTDIRNAME>";
	if (bstrVirtDir.Length())
		bstrCmdLine += bstrVirtDir;
	bstrCmdLine += L"</VIRTDIRNAME>\n";

	bstrTmp.Empty();
	hr = CVCProjectEngine::GetPathWWWRoot(bstrTmp);
//	RETURN_ON_FAIL(hr);		// Don't return on fail here.  Let VCDeploy have the chance to tell the user there 
							// is a problem with their install.
	BOOL bNotAdmin = bstrTmp.Length() && wcscmp(bstrTmp, L"!admin") == 0;
	int nLen = bstrTmp.Length();
	if (bNotAdmin)
	{}	// don't do anything
	else if (nLen <= 0)
		bstrTmp = L"";
	else if (bstrTmp[nLen-1] != L'/' && bstrTmp[nLen-1] != L'\\')
		bstrTmp += L"\\";

	bstrCmdLine += L"\t<VIRTDIRFSPATH>";
	bstrCmdLine += bstrTmp;
	if (!bNotAdmin)
		bstrCmdLine += bstrVirtDir;
	bstrCmdLine += L"</VIRTDIRFSPATH>\n";

	VARIANT_BOOL bReg = VARIANT_FALSE;
	if (spPropContainer->GetBoolProperty(VCDPLYID_RegisterOutput, &bReg) == S_OK && bReg)
		bstrCmdLine += L"\t<REGISTERISAPI>true</REGISTERISAPI>\n";

	VARIANT_BOOL bUnload = VARIANT_FALSE;
	if (spPropContainer->GetBoolProperty(VCDPLYID_UnloadBeforeCopy, &bUnload) == S_OK && bUnload)
		bstrCmdLine += L"\t<UNLOADBEFORECOPY>true</UNLOADBEFORECOPY>\n";

	long nProtect = 0;
	hr = spPropContainer->GetIntProperty(VCDPLYID_ApplicationProtection, &nProtect);
	if (hr == S_FALSE)
		s_optHandler.GetDefaultValue(VCDPLYID_ApplicationProtection, &nProtect, spPropContainer);
	if (SUCCEEDED(hr))
	{
		CStringW strTmp;
		strTmp.Format(L"\t<APPISOLATION>%d</APPISOLATION>\n", nProtect);
		bstrTmp = strTmp;
		bstrCmdLine += bstrTmp;
	}

	bstrTmp.Empty();
	bstrTmp2.Empty();
	BOOL bHaveMappings = FALSE;
	if (spPropContainer->GetStrProperty(VCDPLYID_ApplicationMappings, &bstrTmp) == S_OK && bstrTmp.Length() > 0)
	{
		hr = spPropContainer->Evaluate(bstrTmp, &bstrTmp2);
		RETURN_ON_FAIL(hr);
		CStringW strMapList = bstrTmp2;
		int nMaxIdx = strMapList.GetLength();
		int nStartMap = 0;
		while (nStartMap >= 0)
		{
			CComBSTR bstrMapping;
			nStartMap = CStyleSheetBase::GetNextStyle(strMapList, nStartMap, nMaxIdx, bstrMapping);
			if (bstrMapping.Length() > 0)
			{
				bstrCmdLine += L"\n\t<APPMAPPING fileext=\"";
				bstrCmdLine += bstrMapping;
				bstrCmdLine += L"\">\n\t\t<VERB>GET</VERB>\n\t\t<VERB>HEAD</VERB>\n\t\t<VERB>POST</VERB>\n\t\t<VERB>DEBUG</VERB>\n\t</APPMAPPING>\n";
				bHaveMappings = TRUE;
			}
		}
	}
	
	CComBSTR bstrProjDir;
	spPropContainer->GetStrProperty(VCPROJID_ProjectDirectory, &bstrProjDir);
	CStringW strProjDir = bstrProjDir;
	int nProjDirLen = strProjDir.GetLength();
	if (strProjDir.IsEmpty())
		return CVCProjectEngine::DoSetErrorInfo(VCPROJ_E_INTERNAL_ERR, IDS_ERR_INTERNAL_ERROR);

	CDirW dirProj;
	dirProj.CreateFromKnown(strProjDir);

	// now, let's get the files we're going to be transferring
	bstrCmdLine += L"\n\t<APPFILEGROUP>\n";

	CVCMapStringWToPtr mapFiles;	// this will cover any files we already know about so we don't add them twice...

	// first, let's pass through any additional files we may have been given
	bstrTmp.Empty();
	if (spPropContainer->GetStrProperty(VCDPLYID_AdditionalFiles, &bstrTmp) == S_OK && bstrTmp.Length() > 0)
	{
		bstrTmp2.Empty();
		hr = spPropContainer->Evaluate(bstrTmp, &bstrTmp2);
		RETURN_ON_FAIL(hr);

		CStringW strFileList = bstrTmp2;
		int nMaxIdx = strFileList.GetLength();
		int nStartFiles = 0;
		while (nStartFiles >= 0)
		{
			CComBSTR bstrFile;
			nStartFiles = CStyleSheetBase::GetNextStyle(strFileList, nStartFiles, nMaxIdx, bstrFile);
			CStringW strFile = bstrFile;
			if (!strFile.IsEmpty())
			{
				CPathW pathFile;
				if (!pathFile.CreateFromDirAndFilename(dirProj, strFile))
				{
					CComBSTR bstrErr;
					bstrErr.LoadString(IDS_ERR_DEPLOY_ADDL_FILE_INVALID_PRJ0036);
					CVCProjectEngine::AddProjectError(pEC, bstrErr, L"PRJ0036", spPropContainer);
					return E_FAIL;
				}
				CStringW strFileLower = pathFile.GetFullPath();
				strFileLower.MakeLower();
				void* pDummy;
				if (!mapFiles.Lookup(strFileLower, pDummy))
				{
					bstrCmdLine += L"\t\t<APPFILENAME>\n\t\t\t<SRC>";
					strFile = pathFile.GetFullPath();
					bstrTmp = strFile;
					bstrCmdLine += bstrTmp;
					bstrCmdLine += L"</SRC>\n\t\t\t<DEST>";
					if (_wcsnicmp(strProjDir, strFile, nProjDirLen) == 0)
						pathFile.GetRelativeName(dirProj, strFile);
					else
						strFile = pathFile.GetFileName();
					bstrFile = strFile;
					bstrCmdLine += bstrFile;
					bstrCmdLine += L"</DEST>\n\t\t</APPFILENAME>\n";
					mapFiles.SetAt(strFileLower, pDummy);
				}
			}
		}
	}

	// now, add any deployment content
	CComQIPtr<VCConfiguration> spProjCfg = spPropContainer;
	if (spProjCfg == NULL)
	{
		CComQIPtr<IVCFileConfigurationImpl> spFileCfgImpl = spPropContainer;
		RETURN_ON_NULL(spFileCfgImpl);
		CComPtr<IDispatch> spDispProjCfg;
		spFileCfgImpl->get_Configuration(&spDispProjCfg);
		spProjCfg = spDispProjCfg;
		RETURN_ON_NULL(spProjCfg);
	}
	CComPtr<IDispatch> spDispProj;
	spProjCfg->get_Project(&spDispProj);
	CComQIPtr<VCProject> spProj = spDispProj;
	RETURN_ON_NULL(spProj);
	CComPtr<IDispatch> spDispFileColl;
	spProj->get_Files(&spDispFileColl);
	CComQIPtr<IVCCollection> spFileColl = spDispFileColl;
	RETURN_ON_NULL(spFileColl);
	CComPtr<IEnumVARIANT> spFiles;
	spFileColl->_NewEnum(reinterpret_cast<IUnknown **>(&spFiles));
	RETURN_ON_NULL(spFiles);
	spFiles->Reset();
	while (TRUE)
	{
		CComVariant var;
		hr = spFiles->Next(1, &var, NULL);
		if (hr != S_OK)
			break;
		if (var.vt != VT_UNKNOWN && var.vt != VT_DISPATCH)
			continue;
		CComQIPtr<VCFile> spFile = var.punkVal;
		if (spFile == NULL)
			continue;
		VARIANT_BOOL bDeploy;
		if (spFile->get_DeploymentContent(&bDeploy) == S_OK && bDeploy)
		{
			CComBSTR bstrFullPath, bstrRelPath;
			spFile->get_FullPath(&bstrFullPath);
			CStringW strFullPathLower = bstrFullPath;
			strFullPathLower.MakeLower();
			void* pDummy;
			if (!mapFiles.Lookup(strFullPathLower, pDummy))
			{
				bstrCmdLine += L"\t\t<APPFILENAME>\n\t\t\t<SRC>";
				bstrCmdLine += bstrFullPath;
				bstrCmdLine += L"</SRC>\n\t\t\t<DEST>";
				if (_wcsnicmp(strProjDir, bstrFullPath, nProjDirLen) == 0)
				{
					spFile->get_RelativePath(&bstrRelPath);
					bstrTmp2.Empty();
					spPropContainer->Evaluate(bstrRelPath, &bstrTmp2);
				}
				else
					spFile->get_Name(&bstrTmp2);
				bstrCmdLine += bstrTmp2;
				bstrCmdLine += L"</DEST>\n\t\t</APPFILENAME>\n";
				mapFiles.SetAt(strFullPathLower, pDummy);
			}
		}
	}
	RETURN_ON_FAIL(hr);

	CComBSTR bstrSubDir;
	hr = spPropContainer->GetStrProperty(VCDPLYID_RelativePath, &bstrSubDir);
	RETURN_ON_FAIL(hr);
	if (hr == S_FALSE)
		s_optHandler.GetDefaultValue(VCDPLYID_RelativePath, &bstrSubDir, spPropContainer);
	CStringW strSubDir = bstrSubDir;
	nLen = strSubDir.GetLength();
	if (nLen > 0)
	{
		if (nLen == 1 && strSubDir[0] == L'.')
		{	// this is a no-op directory...
			strSubDir.Empty();
			nLen = 0;
		}
		if (nLen > 0 && strSubDir[nLen-1] != L'/' && strSubDir[nLen-1] != L'\\')
			strSubDir += L"\\";		// need a trailing slash...
	}
	if (strSubDir.IsEmpty())
		bstrSubDir.Empty();
	else
		bstrSubDir = strSubDir;

	//  add the primary output
	bstrCmdLine += L"\t\t<APPFILENAME";
	if (bHaveMappings)
		bstrCmdLine += L" type=\"extension\"";
	bstrCmdLine += L">\n\t\t\t<SRC>";
	bstrTmp = L"$(TargetPath)";
	bstrTmp2.Empty();
	hr = spPropContainer->Evaluate(bstrTmp, &bstrTmp2);
	RETURN_ON_FAIL(hr);
	bstrCmdLine += bstrTmp2;
	bstrCmdLine += L"</SRC>\n\t\t\t<DEST>";
	if (bstrSubDir)
		bstrCmdLine += bstrSubDir;
	bstrTmp = L"$(TargetFileName)";
	bstrTmp2.Empty();
	hr = spPropContainer->Evaluate(bstrTmp, &bstrTmp2);
	RETURN_ON_FAIL(hr);
	bstrCmdLine += bstrTmp2;
	bstrCmdLine += L"</DEST>\n\t\t</APPFILENAME>\n";
	// if this is a managed C++ project, then we have to copy the PDB file as well
	VARIANT_BOOL bGenDebug = VARIANT_FALSE;
	if (spPropContainer->GetBoolProperty(VCLINKID_GenerateDebugInformation, &bGenDebug) == S_OK &&
		bGenDebug)	// yep, have debug info
	{
		VARIANT_BOOL bManaged = VARIANT_FALSE;
		compileAsManagedOptions managedOption = managedNotSet;
		HRESULT hr1 = spPropContainer->GetBoolProperty(VCCFGID_ManagedExtensions, &bManaged);
		HRESULT hr2 = spPropContainer->GetIntProperty(VCCLID_CompileAsManaged, (long *)&managedOption);
		if ((hr2 == S_OK && managedOption == managedAssembly) || (hr1 == S_OK && bManaged))
		{	// yep, managed
			CComBSTR bstrPDBName;
			if (spPropContainer->GetStrProperty(VCLINKID_ProgramDatabaseFile, &bstrPDBName) == S_FALSE)
				CVCLinkerTool::s_optHandler.GetDefaultValue(VCLINKID_ProgramDatabaseFile, &bstrPDBName, spPropContainer);
			if (bstrPDBName.Length() > 0)
			{
				bstrTmp = bstrPDBName.Detach();
				hr = spPropContainer->Evaluate(bstrTmp, &bstrPDBName);
				RETURN_ON_FAIL(hr);
				CPathW pathPDB;
				if (pathPDB.CreateFromDirAndFilename(dirProj, bstrPDBName))
				{
					bstrPDBName = pathPDB.GetFullPath();
					bstrCmdLine += L"\t\t<APPFILENAME>\n\t\t\t<SRC>";
					bstrCmdLine += bstrPDBName;
					bstrCmdLine += L"</SRC>\n\t\t\t<DEST>";
					if (bstrSubDir)
						bstrCmdLine += bstrSubDir;
					bstrPDBName = pathPDB.GetFileName();
					bstrCmdLine += bstrPDBName;
					bstrCmdLine += L"</DEST>\n\t\t</APPFILENAME>\n";
				}
			}
		}
	}
/*	Take out this whole bit on deployment outputs.  This code can be removed later (long after 6/15/01)
	if we decide to keep it this way.
	// add any deployment outputs
	CComQIPtr<IVCConfigurationImpl> spProjCfgImpl = spProjCfg;
	if (spProjCfgImpl)
	{
		CComPtr<IVCBuildStringCollection> spDeployDeps;
		if (SUCCEEDED(spProjCfgImpl->get_KnownDeploymentDependencies(&spDeployDeps)) && spDeployDeps)
		{
			CStringW strKey = L"SOFTWARE\\Microsoft\\.NETFramework";
			CStringW strComDir;
			CStringW strComSDKDir;
			DWORD nType = REG_SZ;
			DWORD nSize = MAX_PATH;
			HKEY hSectionKey = NULL;
			LONG lRet = RegOpenKeyExW( HKEY_LOCAL_MACHINE, strKey, 0, KEY_READ, &hSectionKey );
			if( hSectionKey )
			{
				wchar_t szComplusDir[MAX_PATH+1] = {0};
				wchar_t szComplusSDKDir[MAX_PATH+1] = {0};
				lRet = RegQueryValueExW( hSectionKey, L"InstallRoot", NULL, &nType, (LPBYTE)szComplusDir, &nSize );
				lRet = RegQueryValueExW( hSectionKey, L"sdkInstallRoot", NULL, &nType, (LPBYTE)szComplusSDKDir, &nSize );
				strComDir = szComplusDir;
				strComSDKDir = szComplusSDKDir;
				int nLen1 = strComDir.GetLength();
				int nLen2 = strComSDKDir.GetLength();
				int nLenMin = nLen1 > nLen2 ? nLen2 : nLen1;
				if (nLenMin > 0 && _wcsnicmp(strComDir, strComSDKDir, nLenMin) == 0)
				{	// same root, so need to have to check twice lower down.
					if (nLen1 == nLenMin)
						strComSDKDir.Empty();	// this is the longer one, so toss it
					else
						strComDir.Empty();	// longer one, so toss it
				}
				RegCloseKey( hSectionKey );
			}
			while (TRUE)
			{
				CComBSTR bstrDep;
				hr = spDeployDeps->Next(&bstrDep);
				if (hr != S_OK)
					break;
				if (!bstrDep || bstrDep[0] == '\0')
					continue;
				CPathW pathDep;
				if (!pathDep.Create(bstrDep))
					continue;
				if (!strComDir.IsEmpty() && _wcsnicmp(strComDir, bstrDep, strComDir.GetLength()) == 0)
					continue;	// don't want to deal with COM+ stuff here
				if (!strComSDKDir.IsEmpty() && _wcsnicmp(strComSDKDir, bstrDep, strComSDKDir.GetLength()) == 0)
					continue;	// don't want to deal with COM+ SDK stuff here, either
				bstrCmdLine += L"\t\t<APPFILENAME>\n\t\t\t<SRC>";
				bstrCmdLine += bstrDep;
				bstrDep = pathDep.GetFileName();
				bstrCmdLine += L"</SRC>\n\t\t\t<DEST>";
				if (bstrSubDir)
					bstrCmdLine += bstrSubDir;
				bstrCmdLine += bstrDep;
				bstrCmdLine += L"</DEST>\n\t\t</APPFILENAME>\n";
			}
		}
	}
*/

	// finally, close it all off
	bstrCmdLine += L"\t</APPFILEGROUP>\n</ATLSINSTSETTINGS>\n";

	return pBuildEngine->FormXMLCommand(bstrCmdLine, szDeployToolPath, L"/nologo", pVal);
}

// IVCBuildEventToolInternal
///////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CVCWebDeploymentTool::get_CommandLineInternal(BSTR *pVal)
{
	return GetCommandLineOptions(m_spPropertyContainer, NULL, VARIANT_FALSE /* !additional */, cmdLineForRefresh, pVal);
}

STDMETHODIMP CVCWebDeploymentTool::put_CommandLineInternal(BSTR newVal)
{
	return E_NOTIMPL;
}

STDMETHODIMP CVCWebDeploymentTool::get_DescriptionInternal(BSTR *pVal)
{
	return E_NOTIMPL;
}

STDMETHODIMP CVCWebDeploymentTool::put_DescriptionInternal(BSTR newVal)
{
	return E_NOTIMPL;
}

STDMETHODIMP CVCWebDeploymentTool::get_ExcludedFromBuildInternal(VARIANT_BOOL* pbExcludedFromBuild)
{
	return get_ExcludedFromBuild(pbExcludedFromBuild);
}

STDMETHODIMP CVCWebDeploymentTool::put_ExcludedFromBuildInternal(VARIANT_BOOL bExcludedFromBuild)
{
	return E_NOTIMPL;
}

// CVCWebDeploymentGeneralPage
///////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CVCWebDeploymentGeneralPage::MapPropertyToCategory(DISPID dispid, PROPCAT* ppropcat)
{
	CHECK_POINTER_NULL(ppropcat);

	switch (dispid)
	{
	case VCDPLYID_ExcludedFromBuild:
	case VCDPLYID_AdditionalFiles:
	case VCDPLYID_RelativePath:
		*ppropcat = IDS_GENERALCAT;
		break;
	case VCDPLYID_UnloadBeforeCopy:
	case VCDPLYID_RegisterOutput:
		*ppropcat = IDS_SERVERSIDECAT;
		break;
	case VCDPLYID_VirtualDirectoryName:
	case VCDPLYID_ApplicationMappings:
	case VCDPLYID_ApplicationProtection:
		*ppropcat = IDS_WEBAPPCAT;
		break;
	default:
		*ppropcat = 0;
		break;
	}

	return S_OK;
}

STDMETHODIMP CVCWebDeploymentGeneralPage::GetCategoryName(PROPCAT propcat, LCID lcid, BSTR* pbstrName)
{
	CComBSTR bstrCat;
	bstrCat.LoadString(propcat);
	*pbstrName = bstrCat.Detach();
	return S_OK;
}

// file copy
STDMETHODIMP CVCWebDeploymentGeneralPage::get_AdditionalFiles(BSTR* files)
{	// additional files to deploy
	return GetStrProperty(VCDPLYID_AdditionalFiles, files);
}

STDMETHODIMP CVCWebDeploymentGeneralPage::put_AdditionalFiles(BSTR files)
{
	return SetStrProperty(VCDPLYID_AdditionalFiles, files);
}

STDMETHODIMP CVCWebDeploymentGeneralPage::get_RelativePath(BSTR* dir)
{	// relative path to deploy to
	return ToolGetStrProperty(VCDPLYID_RelativePath, &(CVCWebDeploymentTool::s_optHandler), dir);
}

STDMETHODIMP CVCWebDeploymentGeneralPage::put_RelativePath(BSTR dir)
{
	return SetStrProperty(VCDPLYID_RelativePath, dir);
}

// general 
STDMETHODIMP CVCWebDeploymentGeneralPage::get_ExcludedFromBuild(VARIANT_BOOL* disableDeploy)
{	// exclude from build? default: yes
	return ToolGetBoolProperty(VCDPLYID_ExcludedFromBuild, &(CVCWebDeploymentTool::s_optHandler), disableDeploy);
}

STDMETHODIMP CVCWebDeploymentGeneralPage::put_ExcludedFromBuild(VARIANT_BOOL disableDeploy)
{
	return SetBoolProperty(VCDPLYID_ExcludedFromBuild, disableDeploy);
}

// server side actions
STDMETHODIMP CVCWebDeploymentGeneralPage::get_UnloadBeforeCopy(VARIANT_BOOL* unloadFirst)
{	// unload DLL before copying it?
	return GetBoolProperty(VCDPLYID_UnloadBeforeCopy, unloadFirst);
}

STDMETHODIMP CVCWebDeploymentGeneralPage::put_UnloadBeforeCopy(VARIANT_BOOL unloadFirst)
{
	return SetBoolProperty(VCDPLYID_UnloadBeforeCopy, unloadFirst);
}

STDMETHODIMP CVCWebDeploymentGeneralPage::get_RegisterOutput(VARIANT_BOOL* regDLL)
{	// register the DLL once it is deployed?
	return GetBoolProperty(VCDPLYID_RegisterOutput, regDLL);
}

STDMETHODIMP CVCWebDeploymentGeneralPage::put_RegisterOutput(VARIANT_BOOL regDLL)
{
	return SetBoolProperty(VCDPLYID_RegisterOutput, regDLL);
}

// web application
STDMETHODIMP CVCWebDeploymentGeneralPage::get_VirtualDirectoryName(BSTR* virtRoot)
{	// virtual root for deployment
	return ToolGetStrProperty(VCDPLYID_VirtualDirectoryName, &(CVCWebDeploymentTool::s_optHandler), virtRoot);
}

STDMETHODIMP CVCWebDeploymentGeneralPage::put_VirtualDirectoryName(BSTR virtRoot)
{
	return SetStrProperty(VCDPLYID_VirtualDirectoryName, virtRoot);
}

STDMETHODIMP CVCWebDeploymentGeneralPage::get_ApplicationMappings(BSTR* mapping)
{	// application mappings
	return GetStrProperty(VCDPLYID_ApplicationMappings, mapping);
}

STDMETHODIMP CVCWebDeploymentGeneralPage::put_ApplicationMappings(BSTR mapping)
{
	return SetStrProperty(VCDPLYID_ApplicationMappings, mapping);
}

STDMETHODIMP CVCWebDeploymentGeneralPage::get_ApplicationProtection(eAppProtectionOption* option)
{	// protection level for the app
	return GetIntProperty(VCDPLYID_ApplicationProtection, (long *)option);
}

STDMETHODIMP CVCWebDeploymentGeneralPage::put_ApplicationProtection(eAppProtectionOption option)
{
	CHECK_BOUNDS(StdEnumMin, DeployProtectMax, option);
	return SetIntProperty(VCDPLYID_ApplicationProtection, option);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\vcpb\EnvDaemon.h ===
////////////////////
// EnvDaemon.h
// saves and sets up the environment before the build
// restores the original settings afterwards.

#ifndef _ENVDAEMON_H
#define _ENVDAEMON_H

class CEnvironmentKeeper
{
	CComPtr<VCPlatform> m_pPlatform;

	CComBSTR	m_bstrPath;
	CComBSTR	m_bstrInc;
	CComBSTR	m_bstrRef;
	CComBSTR	m_bstrLib;
public:
	CEnvironmentKeeper( VCPlatform* pPlatform );
	~CEnvironmentKeeper();
};

#endif //_ENVDAEMON_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\vcpb\EnvDaemon.cpp ===
////////////////////
// EnvDaemon.cpp
// saves and sets up the environment before the build
// restores the original settings afterwards.

#include "stdafx.h"
#include "envdaemon.h"
#include "vcprojectengine.h"
#include "util2.h"

CEnvironmentKeeper::CEnvironmentKeeper( VCPlatform* pPlatform ) :
	m_pPlatform( pPlatform )
{
	if( !m_pPlatform )
		return;

	// first, save the PATH, INC, and LIB environment variables
	// get the environment variables for the platform parameters
	VCGetEnvironmentVariableW(L"PATH", &m_bstrPath);
	VCGetEnvironmentVariableW(L"INCLUDE", &m_bstrInc);
	VCGetEnvironmentVariableW(L"LIBPATH", &m_bstrRef);
	VCGetEnvironmentVariableW(L"LIB", &m_bstrLib);

	// now we mangle the global environment with the platform's settings 
	// (from the tools dialog)

	HRESULT hr;
	CComQIPtr<IVCPropertyContainer> pPropCnt;

	// get the project collection
	CComPtr<IDispatch> pDispColl;
	g_pProjectEngine->get_Projects( &pDispColl );
	CComQIPtr<IVCCollection> pProjectColl = pDispColl;
	if( pProjectColl )
	{
		CComPtr<IDispatch> pDisp;
		// get the 1st project
		hr = pProjectColl->Item( CComVariant( 1 ), &pDisp );
		if( SUCCEEDED( hr ) )
		{
			CComQIPtr<VCProject> pProject = pDisp;
			if( pProject )
			{
				// get the config collection
				pDispColl = NULL;
				pProject->get_Configurations( &pDispColl );
				CComQIPtr<IVCCollection> pConfigColl = pDispColl;
				if( pConfigColl )
				{
					pDisp = NULL;
					// get the 1st config
					hr = pConfigColl->Item( CComVariant( 1 ), &pDisp );
					if( SUCCEEDED( hr ) )
					{
						CComQIPtr<VCConfiguration> pConfig = pDisp;
						if( pConfig )
							pPropCnt = pConfig;
					}
				}
			}
		}
	}
	if (pPropCnt == NULL)	// must have gotten here through attach followed by edit & continue
		pPropCnt = g_pProjectEngine;
	
	CComBSTR strExe;
	CComBSTR strInc;
	CComBSTR strRef;
	CComBSTR strLib;
	m_pPlatform->get_ExecutableDirectories( &strExe );
	m_pPlatform->get_IncludeDirectories( &strInc );
	m_pPlatform->get_ReferenceDirectories( &strRef );
	m_pPlatform->get_LibraryDirectories( &strLib );
	// if we got a config, we can expand env var macros
	if( pPropCnt )
	{
		CComBSTR bstrExpandedExe;
		pPropCnt->Evaluate( strExe, &bstrExpandedExe );
		::SetEnvironmentVariableW( L"PATH", bstrExpandedExe );

		CComBSTR bstrExpandedInc;
		pPropCnt->Evaluate( strInc, &bstrExpandedInc );
		::SetEnvironmentVariableW( L"INCLUDE", bstrExpandedInc );

		CComBSTR bstrExpandedRef;
		pPropCnt->Evaluate( strRef, &bstrExpandedRef );
		::SetEnvironmentVariableW( L"LIBPATH", bstrExpandedRef );

		CComBSTR bstrExpandedLib;
		pPropCnt->Evaluate( strLib, &bstrExpandedLib );
		::SetEnvironmentVariableW( L"LIB", bstrExpandedLib );
	}
	// otherwise we can't, and we're probably in trouble
	else
	{
		::SetEnvironmentVariableW( L"PATH", strExe );
		::SetEnvironmentVariableW( L"INCLUDE", strInc );
		::SetEnvironmentVariableW( L"LIBPATH", strRef );
		::SetEnvironmentVariableW( L"LIB", strLib );
	}
}


CEnvironmentKeeper::~CEnvironmentKeeper()
{
	if( !m_pPlatform )
		return;

	// set the environment variables with the cached values.
	::SetEnvironmentVariableW( L"PATH", m_bstrPath );
	::SetEnvironmentVariableW( L"INCLUDE", m_bstrInc );
	::SetEnvironmentVariableW( L"LIBPATH", m_bstrRef );
	::SetEnvironmentVariableW( L"LIB", m_bstrLib );

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\vcpb\File.cpp ===
// File.cpp : Implementation of 

#include "stdafx.h"
#include "File.h"
#include "collection.h"
#include "buildengine.h"
#include "fileconfiguration.h"
#include "projwriter.h"

/////////////////////////////////////////////////////////////////////////////
//
HRESULT CPEFile::CreateInstance(VCFile **ppVCFile)
{
	HRESULT hr;
	CPEFile *pVar;
	CComObject<CPEFile> *pObj;
	hr = CComObject<CPEFile>::CreateInstance(&pObj);
	if (SUCCEEDED(hr))
	{
		pVar = pObj;
		pVar->AddRef();
		*ppVCFile = pVar;
	}
	return hr;
}

CPEFile::CPEFile() :
	m_bstrRelativePath( NULL ),
	m_wszFileName( NULL ),
	m_pParent( NULL ),
	m_pProject( NULL ),
	m_frh( NULL ),
	m_pExternalCookie( NULL ),
	m_bDeploymentContent( VARIANT_FALSE )
{
}

CPEFile::~CPEFile()
{
	if (m_frh)
	{
		m_frh->ReleaseFRHRef();
		m_frh = NULL;
	}
}

STDMETHODIMP CPEFile::get_Project(IDispatch **pVal)
{
	CHECK_ZOMBIE(m_pProject, IDS_ERR_FILE_ZOMBIE);
	CHECK_POINTER_VALID(pVal);
	*pVal = NULL;

	return m_pProject.QueryInterface(pVal);
}

STDMETHODIMP CPEFile::put_Project(IDispatch *pVal)
{
	HRESULT hr = E_NOINTERFACE;	
	CComQIPtr<VCProject> pProj;

	pProj = pVal;
	if (pProj)
	{
		m_pProject = pProj;
		hr = S_OK;
	}
	return hr;
}

STDMETHODIMP CPEFile::get_Parent(IDispatch **pVal)
{
	CHECK_ZOMBIE(m_pParent, IDS_ERR_FILE_ZOMBIE);
	CHECK_POINTER_VALID(pVal);
	*pVal = NULL;

	return m_pParent.QueryInterface(pVal);
}

STDMETHODIMP CPEFile::put_Parent(IDispatch *pVal)
{
	m_pParent = pVal;
	return S_OK;
}

HRESULT CPEFile::SetDirty(VARIANT_BOOL bDirty)
{
	CComQIPtr<IVCProjectImpl> pProjImpl = m_pProject;
	CHECK_ZOMBIE(pProjImpl, IDS_ERR_FILE_ZOMBIE);

	return pProjImpl->put_IsDirty(bDirty);
}

STDMETHODIMP CPEFile::MatchName(BSTR bstrNameToMatch, VARIANT_BOOL bFullOnly, VARIANT_BOOL *pbMatched)
{
	*pbMatched = VARIANT_FALSE;
	CHECK_READ_POINTER_VALID(bstrNameToMatch);

	if (!bFullOnly)	// allowing match of just the file name itself
	{
		CComBSTR bstrFileName;
		get_Name( &bstrFileName );
		if (bstrFileName && _wcsicmp(bstrFileName, bstrNameToMatch) == 0)
		{
			*pbMatched = VARIANT_TRUE;
			return S_OK;
		}
	}

	if (m_bstrRelativePath && _wcsicmp(m_bstrRelativePath, bstrNameToMatch) == 0)
	{
		*pbMatched = VARIANT_TRUE;
	}
	else
	{
		if( m_frh == NULL )
		{
			CComBSTR bstrFullPath;
			get_FullPath( &bstrFullPath );
			RETURN_ON_NULL2(m_frh, E_UNEXPECTED);
		}
			
		CPathW pathToMatch;
		if (pathToMatch.Create(bstrNameToMatch) && _wcsicmp(m_frh->GetFilePath()->GetFullPath(), pathToMatch) == 0)
			*pbMatched = VARIANT_TRUE;
	}
	return S_OK;
}

STDMETHODIMP CPEFile::SaveObject(IStream *xml, IVCPropertyContainer *pPropCnt, long nIndent)
{
	long lcItems;
	long index;
	HRESULT hr;

	// Relative path
	NodeAttributeWithSpecialChars( xml, L"RelativePath", m_bstrRelativePath, true );

	// Deployment content, only write if true
	if( m_bDeploymentContent == VARIANT_TRUE )
		NodeAttribute( xml, L"DeploymentContent", L"TRUE" );
	
	// end the node header, start on children
	EndNodeHeader( xml, true );

	// file configs
	lcItems = m_configfiles.GetSize();
	for( index = 0; index < lcItems; index++ )
	{
		CComPtr<VCFileConfiguration> pFileCfg;
		CComBSTR bstrConfigName;
		
		pFileCfg = m_configfiles.GetAt( index );
		if( pFileCfg )
		{
			CComQIPtr<IVCFileConfigurationImpl> pFileCfgImpl = pFileCfg;
			if( pFileCfgImpl )
			{
				hr = pFileCfgImpl->SaveObject( xml, NULL, GetIndent() );
			}
		}
	}
	return S_OK;
}

STDMETHODIMP CPEFile::get_Name(BSTR *pVal)
{
	CHECK_POINTER_VALID( pVal );

	// if we have a filename, use it
	if( m_wszFileName )
	{
		*pVal = SysAllocString( m_wszFileName );
	}
	// if we don't have a name, generate one
	else
	{
		m_wszFileName = wcsrchr( m_bstrRelativePath, L'\\' );
		// if there was no separator then the name is the whole string
		if( !m_wszFileName )
			m_wszFileName = m_bstrRelativePath;
		// otherwise we need to add one to it (so it doesn't point *at* the separator)
		else
			m_wszFileName++;

		*pVal = SysAllocString( m_wszFileName );
	}
	return S_OK;
}

STDMETHODIMP CPEFile::get_FullPath(BSTR *pVal)
{
	CHECK_POINTER_VALID( pVal );

	// if we have a FileRegHandle, use it to get the full path
	if( m_frh )
	{
		*pVal = SysAllocString( m_frh->GetFilePath()->GetFullPath() );
		return S_OK;
	}

	if (m_pProject == NULL)	// we're basically zombie
	{
		*pVal = NULL;
		return CVCProjectEngine::DoSetErrorInfo(VCPROJ_E_ZOMBIE, IDS_ERR_FILE_ZOMBIE);
	}

	CComBSTR bstrEvaluatedPath;
	HRESULT hr;
	// eval 
	// get 1st file config, use prop cnt eval
	CComPtr<VCFileConfiguration> pFileCfg;
	pFileCfg = m_configfiles.GetAt( 1 );
	CComQIPtr<IVCPropertyContainer> pPropCnt = pFileCfg;
	if( !pPropCnt )
		hr = static_cast<CVCProjectEngine*>(g_pProjectEngine)->Evaluate( m_bstrRelativePath, &bstrEvaluatedPath );
	else
		hr = pPropCnt->Evaluate( m_bstrRelativePath, &bstrEvaluatedPath );
	RETURN_ON_FAIL(hr);

	// create a full path from the project directory and relative path
	CPathW path;
	CDirW dir;
	CComBSTR bstrProjDir;
	m_pProject->get_ProjectDirectory( &bstrProjDir );
	dir.CreateFromString( bstrProjDir );
	path.CreateFromDirAndFilename( dir, bstrEvaluatedPath );
	*pVal = SysAllocString( path.GetFullPath() );

	m_frh = CBldFileRegFile::GetFileHandle(*pVal, TRUE);

	return S_OK;
}

STDMETHODIMP CPEFile::get_RelativePath(BSTR *pVal)
{
	CHECK_POINTER_VALID( pVal );
	m_bstrRelativePath.CopyTo(pVal);
	return S_OK;
}

STDMETHODIMP CPEFile::put_RelativePath(BSTR newVal)
{
	CHECK_OK_TO_DIRTY(VCFILEID_RelativePath);

	HRESULT hr = S_OK;
	bool bAddFile = false;

	// if we're loading the project, or don't have a file reg handle (meaning
	// this is coming through the AddItem dlg)
	if( g_bInProjLoad )
	{
		m_bstrRelativePath = newVal;
		return S_OK;
	}
	else if( !m_frh )
		bAddFile = true;

	// else not loading
	// compare eval'd input to full path from file registry
	CComBSTR bstrEvaluatedPath;
	if (bAddFile)
		bstrEvaluatedPath = newVal;
	else
	{
		// eval the input
		// get 1st file config, use its property container
		CComPtr<VCFileConfiguration> pFileCfg;
		pFileCfg = m_configfiles.GetAt( 1 );
		CComQIPtr<IVCPropertyContainer> pPropCnt = pFileCfg;
		if( !pPropCnt )
			hr = static_cast<CVCProjectEngine*>(g_pProjectEngine)->Evaluate( newVal, &bstrEvaluatedPath );
		else
			hr = pPropCnt->Evaluate( newVal, &bstrEvaluatedPath );
		RETURN_ON_FAIL2(hr, S_OK);
	}

	// create a full path
 	CPathW path;
	CDirW dir;
	CComBSTR bstrProjDir;
	m_pProject->get_ProjectDirectory( &bstrProjDir );
	dir.CreateFromString( bstrProjDir );
	path.CreateFromDirAndFilename( dir, bstrEvaluatedPath );

	if (bAddFile)
	{
		path.GetActualCase(TRUE);
		path.SetAlwaysRelative();
		CStringW strPath;
		if (path.GetRelativeName(dir, strPath))
			m_bstrRelativePath = strPath;
		else
			m_bstrRelativePath = newVal;
	}
	else
	{
		const wchar_t *wszPath = m_frh->GetFilePath()->GetFullPath();

		// if they're the same full path, set to whatever they gave us
		if( wcsicmp( path.GetFullPath(), wszPath ) == 0 )
		{
			// first make sure all /s are converted to \s
			wchar_t *pos;
 			wchar_t *newPos = newVal;
			while( pos = wcschr( newPos, L'/' ) )
			{
				*pos = L'\\';
 				newPos = pos;
			}
			m_bstrRelativePath = newVal;
		}
	}

	// cause the name prop to be updated next time it is asked for
	m_wszFileName = NULL;

	if (bAddFile)	// no notifications needed if we're adding this for the first time...
		return S_OK;
	
	// we're not loading, notify UI
	CComQIPtr<IDispatch> pDisp = this;
	if( pDisp )
	{
		CComQIPtr<IVCProjectEngineImpl> pProjEngImpl = g_pProjectEngine;
		if( pProjEngImpl )
			pProjEngImpl->DoFireItemPropertyChange( pDisp, VCFILEID_RelativePath );
	}

	return S_OK;
}

STDMETHODIMP CPEFile::get_DeploymentContent( VARIANT_BOOL *pVal )
{
	CHECK_POINTER_VALID( pVal );
	*pVal = m_bDeploymentContent;
	return S_OK;
}

STDMETHODIMP CPEFile::put_DeploymentContent( VARIANT_BOOL newVal )
{
	CHECK_VARIANTBOOL( newVal );
	CHECK_OK_TO_DIRTY(0);
	m_bDeploymentContent = newVal;
	return S_OK;
}

STDMETHODIMP CPEFile::get_Extension(BSTR *pVal)
{
	CHECK_POINTER_VALID( pVal );
	*pVal = NULL;

	// get the path object from the file reg handle
	if (m_frh == NULL)
	{
		CComBSTR bstrPath;
		HRESULT hr = get_FullPath(&bstrPath);
		VSASSERT(SUCCEEDED(hr) && m_frh, "All files have a full path on them!");
		RETURN_ON_NULL2(m_frh, E_UNEXPECTED);
	}
	const CPathW *pPath = m_frh->GetFilePath();
	RETURN_ON_NULL2(pPath, E_UNEXPECTED);

	// get the extension
	const wchar_t* wszExt = pPath->GetExtension();
	RETURN_ON_NULL(wszExt);
	CComBSTR bstrRet( wszExt );
	*pVal = bstrRet.Detach();
	return S_OK;
}

STDMETHODIMP CPEFile::Move(IDispatch *pParent)
{
	HRESULT hr = CheckCanMove(pParent);
	RETURN_ON_FAIL(hr);
	if (hr == S_FALSE)	// signal for no-op
		return S_OK;

	CComQIPtr<IDispatch> spOldParent = m_pParent;
	CComQIPtr<IVCProjectImpl> spOldProjectImpl = m_pParent;
	CComQIPtr<IVCFilterImpl> spOldFilterImpl = m_pParent;
	CComQIPtr<IVCProjectImpl> spNewProjectImpl = pParent;
	CComQIPtr<IVCFilterImpl> spNewFilterImpl = pParent;
	VSASSERT((spOldProjectImpl != NULL || spOldFilterImpl != NULL) && (spNewProjectImpl != NULL || spNewFilterImpl != NULL), "Hey, bad parenting on move!");
	if ((spOldProjectImpl == NULL && spOldFilterImpl == NULL) || (spNewProjectImpl == NULL && spNewFilterImpl == NULL))
		return E_UNEXPECTED;

	IDispatch* pThis = static_cast<IDispatch*>(this);
	if (spOldProjectImpl)
		spOldProjectImpl->RemoveChild(pThis);
	else
		spOldFilterImpl->RemoveChild(pThis);

	// parent will be reset during AddChild
	if (spNewProjectImpl)
		spNewProjectImpl->AddChild(pThis);
	else
		spNewFilterImpl->AddChild(pThis);

	CComQIPtr<IVCProjectEngineImpl> spEngine = g_pProjectEngine;
	if (spEngine)
		spEngine->DoFireItemMoved(pThis, pParent, spOldParent);
	SetDirty(VARIANT_TRUE);

	return hr;
}

STDMETHODIMP CPEFile::CanMove(IDispatch* pParent, VARIANT_BOOL* pbCanMove)
{
	HRESULT hr = CheckCanMove(pParent);
	if (pbCanMove)	// NULL pointer is allowed here since the out param is optional
	{
		CHECK_POINTER_VALID(pbCanMove);
		*pbCanMove = SUCCEEDED(hr) ? VARIANT_TRUE : VARIANT_FALSE;
	}

	return (SUCCEEDED(hr) ? S_OK : S_FALSE);
}

HRESULT CPEFile::CheckCanMove(IDispatch* pParent)
{
	if (pParent == NULL)
		return CVCProjectEngine::DoSetErrorInfo2(VCPROJ_E_NULL_PATH, IDS_ERR_SET_NULL_PARENT, m_bstrRelativePath);

	CComQIPtr<IDispatch> spDispParent = m_pParent;	// current parent check
	if (pParent == m_pParent)
		return S_FALSE;	// no-op

	CHECK_OK_TO_DIRTY(0);

	// Verify that pParent is the project or is in the project
	CComQIPtr<VCProject> pProj = pParent;
	if (pProj)
	{
		if (pProj == m_pProject)
			return S_OK;
	}

	CComQIPtr<VCFilter> pFilter = pParent;
	if (pFilter == NULL)
		return CVCProjectEngine::DoSetErrorInfo2(VCPROJ_E_BAD_PARENT, IDS_ERR_BAD_FILE_PARENT, m_bstrRelativePath);

	CComQIPtr<VCFilter> pFilterT;
	CComPtr<VCFilter> pFilterLast;
	
	pFilterT = pFilter;
	do
	{ // loop ends with pFilterT == NULL 
		CComPtr<IDispatch> pDisp;
		pFilterT->get_Parent(&pDisp);
		pFilterLast = pFilterT;
		pFilterT = pDisp;
	} while (pFilterT);
	
	if (pFilterLast != NULL)
	{
		CComPtr<IDispatch> pDisp;
		pFilterLast->get_Parent(&pDisp);
		pProj = pDisp;
		if (pProj == m_pProject)
			return S_OK;
	}

	return CVCProjectEngine::DoSetErrorInfo(VCPROJ_E_DIFF_PROJ, IDS_ERR_MOVE_CROSS_PROJ);	// can only move within same project
}

STDMETHODIMP CPEFile::Remove()
{
	return m_pProject->RemoveFile(static_cast<IDispatch *>(this));
}

STDMETHODIMP CPEFile::AddConfiguration(VCConfiguration * pCfg)
{
	HRESULT hr = E_POINTER;
	CComQIPtr<IVCFileConfigurationImpl> pFileConfigImpl;
	CComPtr<VCFileConfiguration> pFileConfiguration;

	if (pCfg)
	{ 
		hr = CFileConfiguration::CreateInstance(&pFileConfiguration);
		pFileConfigImpl = pFileConfiguration;
		VSASSERT(SUCCEEDED(hr) && pFileConfigImpl, "must be out of memory");
		if (SUCCEEDED(hr) && pFileConfigImpl)
		{
			pFileConfigImpl->put_File(static_cast<VCFile *>(this));
			pFileConfigImpl->put_Configuration(pCfg);
			m_configfiles.Add(pFileConfiguration);
			if (PROJECT_IS_LOADED())
			{
				CComQIPtr<IVCBuildableItem> spBuildableItem = pFileConfigImpl;
				if (spBuildableItem)
					spBuildableItem->AssignActions(VARIANT_TRUE);
			}
		}
	}

	return hr;
}

STDMETHODIMP CPEFile::RemoveConfiguration( IDispatch *pItem )
{
	// find the config we're looking for
	long l, lcItems;
	lcItems = m_configfiles.GetSize();
	for (l = 0; l < lcItems; l++)
	{
		CComPtr<VCFileConfiguration> pFileCfg;
		pFileCfg = m_configfiles.GetAt(l);
		CComQIPtr<IDispatch> pDisp = pFileCfg;
		if( pDisp )
		{
			if( pDisp == pItem )
			{
				// remove it from the collection
				m_configfiles.Remove( pFileCfg );
				// close it down
				CComQIPtr<IVCFileConfigurationImpl> pFileCfgImpl = pFileCfg;
				if (pFileCfgImpl)
					pFileCfgImpl->Close(); // close down entirely; release all
			}
		}
	}
	return S_OK;
}

STDMETHODIMP CPEFile::Initialize(IDispatch * pParent)
{
	return E_NOTIMPL;
}

STDMETHODIMP CPEFile::get_FileConfigurations(IDispatch **ppVal)
{
	CHECK_POINTER_VALID( ppVal );

	CComPtr<IVCCollection> pCollection;
	HRESULT hr = CCollection<VCFileConfiguration>::CreateInstance(&pCollection, &m_configfiles);
	if (SUCCEEDED(hr))
	{
		hr = pCollection.QueryInterface(ppVal);
	}
	return hr;
}

STDMETHODIMP CPEFile::Close()
{
	if (PROJECT_IS_LOADED())
		UnAssignActions(VARIANT_TRUE);

	long l, lcItems;

	BOOL bOldInFileChangeMode = g_bInFileChangeMode;
	g_bInFileChangeMode = TRUE;
	lcItems = m_configfiles.GetSize();
	for (l = 0; l < lcItems; l++)
	{
		CComPtr<VCFileConfiguration> pFileCfg;
		pFileCfg = m_configfiles.GetAt(l);
		CComQIPtr<IVCFileConfigurationImpl> pFileCfgImpl = pFileCfg;
		if (pFileCfgImpl)
			pFileCfgImpl->Close(); // close down entirely; release all
	}
	g_bInFileChangeMode = bOldInFileChangeMode;

	m_pParent = NULL;
	m_pProject = NULL;
	m_configfiles.RemoveAll();	// collection of configs for this file

	// Let the full path to the file still be available even after we're closed.
	// This means don't release the FRH until destruction time.
	// Reason: need to be able to get the full path for shell transfer purposes.

	return S_OK;
}

STDMETHODIMP CPEFile::GetFileConfigurationForProjectConfiguration(VCConfiguration* pProjCfg, 
	VCFileConfiguration** ppFileCfg)
{
	CHECK_READ_POINTER_NULL(pProjCfg);
	CHECK_POINTER_NULL(ppFileCfg);

	long cConfigFiles = m_configfiles.GetSize();
	for (long idx = 0; idx < cConfigFiles; idx++)
	{
		CComPtr<VCFileConfiguration> pFileCfg = m_configfiles.GetAt(idx);
		CComQIPtr<IVCFileConfigurationImpl> pFileCfgImpl = pFileCfg;
		if (!pFileCfgImpl)
			continue;
		CComPtr<IDispatch> pThisDispProjCfg;
		HRESULT hr = pFileCfgImpl->get_Configuration(&pThisDispProjCfg);
		CComQIPtr<VCConfiguration> pThisProjCfg = pThisDispProjCfg;
		if (pThisProjCfg && pThisProjCfg == pProjCfg)
		{
			pFileCfg.CopyTo(ppFileCfg);
			return S_OK;
		}
	}
	return CVCProjectEngine::DoSetErrorInfo(VCPROJ_E_NOT_FOUND, IDS_ERR_FILE_CFG_NOT_FOUND);	// didn't find one
}

STDMETHODIMP CPEFile::AssignActions(VARIANT_BOOL bOnLoad)
{
	if (m_pProject != NULL)
	{
		CComQIPtr<IVCBuildableItem> spBuildableProject = m_pProject;
		if (spBuildableProject != NULL)
		{
			CBldFileRegistry* pReg = NULL;
			if (SUCCEEDED(spBuildableProject->get_Registry((void **)&pReg)) && pReg != NULL)
			{
				IVCBuildableItem *pBuildable = this;
				pReg->RestoreToProject(pBuildable, FALSE /* no contents */);
			}
		}
	}

	int iMac = m_configfiles.GetSize();
	for (int idx = 0; idx <= iMac; idx++)
	{
		CComPtr<VCFileConfiguration> pConfig = m_configfiles.GetAt(idx);
		CComQIPtr<IVCBuildableItem> spBuildableItem = pConfig;
		if (pConfig == NULL || spBuildableItem == NULL)
			continue;
		spBuildableItem->AssignActions(bOnLoad);
	}
	return S_OK;
}

STDMETHODIMP CPEFile::UnAssignActions(VARIANT_BOOL bOnClose)
{
	if (bOnClose == VARIANT_TRUE)
	{
		if (m_pProject != NULL)
		{
			CComQIPtr<IVCBuildableItem> spBuildableProject = m_pProject;
			if (spBuildableProject != NULL)
			{
				CBldFileRegistry* pReg = NULL;
				if (SUCCEEDED(spBuildableProject->get_Registry((void **)&pReg)) && pReg != NULL)
				{
					IVCBuildableItem *pBuildable = this;
					pReg->RemoveFromProject(pBuildable, FALSE /* no contents */);
				}
			}
		}
	}
	
	int iMac = m_configfiles.GetSize();
	for (int idx = 0; idx <= iMac; idx++)
	{
		CComPtr<VCFileConfiguration> pConfig = m_configfiles.GetAt(idx);
		CComQIPtr<IVCBuildableItem> spBuildableItem = pConfig;
		if (pConfig == NULL || spBuildableItem == NULL)
			continue;
		spBuildableItem->UnAssignActions(bOnClose);
	}
	return S_OK;
}

#ifdef LATER
STDMETHODIMP CPEFile::GetCfgs(
			/*[in] */ ULONG celt, IVsCfg **rgpcfg,
			/*[out]*/ ULONG *pcActual, VSCFGFLAGS *prgfFlags )
{
	// only want the count ?
	if( celt == 0 )
	{
		CHECK_POINTER_VALID(pcActual);
		*pcActual = m_configfiles.GetCount();
		return S_OK;
	}

	// want some elements ?
	CHECK_POINTER_VALID(rgpcfg);

	// don't return more than there are
	ULONG actualCfgs = m_configfiles.GetSize();
	if( celt > actualCfgs )
		celt = actualCfgs;

	ULONG i;
    for( i=0; i<(unsigned)celt; i++ )
	{
		CComQIPtr<IVsCfg> pConfig;
		pConfig = m_configfiles.GetAt((long)i);
		rgpcfg[i] = pConfig.Detach();
	}
	*pcActual = i;
	return S_OK;
}
#endif 

STDMETHODIMP CPEFile::get_ItemFileName(BSTR *pVal)
{
	CHECK_POINTER_NULL( pVal );
	return get_Name(pVal);
}

STDMETHODIMP CPEFile::get_ItemFullPath(BSTR* pbstrFullPath)
{
	CHECK_POINTER_NULL( pbstrFullPath );
	return get_FullPath(pbstrFullPath);
}

STDMETHODIMP CPEFile::get_ActionList(IVCBuildActionList** ppActionList)
{
	return E_UNEXPECTED;	// file doesn't own one of these
}

STDMETHODIMP CPEFile::get_FileRegHandle(void** pfrh)
{
	CHECK_POINTER_NULL(pfrh);

	if (m_frh == NULL)
	{
		CComBSTR bstrPath;
		HRESULT hr = get_FullPath(&bstrPath);
		VSASSERT(SUCCEEDED(hr), "All files have a full path on them!");

		// CStringW strPath = bstrPath;
		// if (!strPath.IsEmpty())
		// 	 m_frh = CBldFileRegFile::GetFileHandle(strPath, TRUE);
	}
	*pfrh = (void *)m_frh;
	return S_OK;
}

STDMETHODIMP CPEFile::get_ContentList(IEnumVARIANT** ppContents)
{
	CHECK_POINTER_NULL(ppContents);
	*ppContents = NULL;
	
	return S_FALSE;		// don't have a content list the file registry is interested in
}

STDMETHODIMP CPEFile::get_Registry(void** ppFileRegistry)
{
	CComQIPtr<IVCBuildableItem> spBuildableProject = m_pProject;
	CHECK_ZOMBIE(spBuildableProject, IDS_ERR_FILE_ZOMBIE);

	return spBuildableProject->get_Registry(ppFileRegistry);
}

STDMETHODIMP CPEFile::get_ProjectConfiguration(VCConfiguration** ppProjCfg)
{
	CHECK_POINTER_NULL(ppProjCfg);
	*ppProjCfg = NULL;
	return E_UNEXPECTED;
}

STDMETHODIMP CPEFile::get_ProjectInternal(VCProject** ppProject)
{
	CHECK_POINTER_NULL(ppProject);
	*ppProject = NULL;

	CComPtr<IDispatch> spDispProject;
	HRESULT hr = get_Project(&spDispProject);
	RETURN_ON_FAIL(hr);
	CComQIPtr<VCProject> spProject = spDispProject;
	return spProject.CopyTo(ppProject);
}

STDMETHODIMP CPEFile::get_ExistingBuildEngine(IVCBuildEngine** ppBldEngine)
{
	CHECK_POINTER_NULL(ppBldEngine);
	*ppBldEngine = NULL;
	return E_UNEXPECTED;
}

STDMETHODIMP CPEFile::get_PersistPath(BSTR* pbstrPersistPath)
{
	CHECK_POINTER_NULL( pbstrPersistPath );
	return m_bstrRelativePath.CopyTo(pbstrPersistPath);
}

STDMETHODIMP CPEFile::RefreshActionOutputs(long nPropID, IVCBuildErrorContext* pEC)
{
	return S_OK;	// meaningless to a non-config object
}

STDMETHODIMP CPEFile::HandlePossibleCommandLineOptionsChange(IVCBuildErrorContext* pEC)
{
	return S_FALSE;		// meaningless to a non-config object
}

STDMETHODIMP CPEFile::ClearDirtyCommandLineOptionsFlag()
{
	return S_FALSE;		// meaningless to a non-config object
}

STDMETHODIMP CPEFile::get_Kind(BSTR* kind)
{
	CHECK_POINTER_VALID(kind);
	CComBSTR bstrKind = L"VCFile";
	*kind = bstrKind.Detach();
	return S_OK;
}

STDMETHODIMP CPEFile::get_VCProjectEngine(IDispatch** ppProjEngine)
{
	CHECK_POINTER_VALID(ppProjEngine);
	RETURN_ON_NULL(g_pProjectEngine);
	return g_pProjectEngine->QueryInterface(IID_IDispatch, (void **)ppProjEngine);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\vcpb\File.h ===
// File.h: Definition of the CPEFile class
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_FILE_H__625C6499_2C7E_11D3_87BF_A0494CC10000__INCLUDED_)
#define AFX_FILE_H__625C6499_2C7E_11D3_87BF_A0494CC10000__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "comlist.h"
#include "FileRegistry.h"

/////////////////////////////////////////////////////////////////////////////
// CPEFile

class CPEFile : 
	public IDispatchImpl<VCFile, &IID_VCFile, &LIBID_VCProjectEngineLibrary, PublicProjBuildTypeLibNumber,0, CVsTypeInfoHolder>, 
	public IVCFileImpl,
	public IVCBuildableItem,
	public IVCExternalCookie,
	public CComObjectRoot
{
public:
	CPEFile();
	~CPEFile();
	static HRESULT CreateInstance(VCFile **ppVCFile);

BEGIN_COM_MAP(CPEFile)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(VCFile)
	COM_INTERFACE_ENTRY(IVCFileImpl)
	COM_INTERFACE_ENTRY(IVCBuildableItem)
	COM_INTERFACE_ENTRY(IVCExternalCookie)
	COM_INTERFACE_ENTRY(VCProjectItem)
END_COM_MAP()

DECLARE_NO_REGISTRY()

// VCFile
public:
	STDMETHOD(Remove)();
	STDMETHOD(get_FullPath)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(get_Name)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(get_RelativePath)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_RelativePath)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_FileConfigurations)(IDispatch **ppVal);
	STDMETHOD(get_DeploymentContent)(VARIANT_BOOL *pVal);
	STDMETHOD(put_DeploymentContent)(VARIANT_BOOL newVal);
	STDMETHOD(get_Extension)(BSTR *pVal);
	STDMETHOD(Move)(IDispatch *pParent);
	STDMETHOD(CanMove)(IDispatch *pParent, VARIANT_BOOL* pbCanMove);

// IVCFileImpl
public:
	STDMETHOD(AddConfiguration)(VCConfiguration * pCfg);
	STDMETHOD(Initialize)(IDispatch * pParent);
	STDMETHOD(Close)();
	STDMETHOD(put_Parent)(/*[in]*/ IDispatch *pVal);
	STDMETHOD(put_Project)(/*[in]*/ IDispatch *pVal);
	STDMETHOD(GetFileConfigurationForProjectConfiguration)(VCConfiguration* pProjCfg, VCFileConfiguration** ppFileCfg);
	STDMETHOD(SaveObject)(IStream *xml, IVCPropertyContainer *pPropCnt, long nIndent);
	STDMETHOD(RemoveConfiguration)( IDispatch *pItem );

// VCProjectItem
public:
	STDMETHOD(MatchName)(BSTR bstrNameToMatch, VARIANT_BOOL bFullOnly, VARIANT_BOOL *pbMatched);
	STDMETHOD(get_Project)(/*[out, retval]*/ IDispatch * *pVal);
	STDMETHOD(get_Parent)(/*[out, retval]*/ IDispatch * *pVal);
	STDMETHOD(get_ItemName)(BSTR *Val) { return get_Name(Val); }
	STDMETHOD(get_Kind)(BSTR* kind);
	STDMETHOD(get_VCProjectEngine)(IDispatch** projEngine);

// IVCBuildableItem
public:
	STDMETHOD(get_ItemFileName)(BSTR *pVal);
	STDMETHOD(get_ItemFullPath)(BSTR* pbstrFullPath);
	STDMETHOD(get_ActionList)(IVCBuildActionList** ppActions);
	STDMETHOD(get_FileRegHandle)(void** pfrh);
	STDMETHOD(AssignActions)(VARIANT_BOOL bOnLoad);
	STDMETHOD(UnAssignActions)(VARIANT_BOOL bOnClose);
	STDMETHOD(get_ContentList)(IEnumVARIANT** ppContentList);
	STDMETHOD(get_Registry)(void** pFileRegistry);
	STDMETHOD(get_ProjectConfiguration)(VCConfiguration** ppProjCfg);
	STDMETHOD(get_ProjectInternal)(VCProject** ppProject);
	STDMETHOD(get_ExistingBuildEngine)(IVCBuildEngine** ppBuildEngine);
	STDMETHOD(get_PersistPath)(BSTR* pbstrPersistPath);
	STDMETHOD(RefreshActionOutputs)(long nPropID, IVCBuildErrorContext* pEC);
	STDMETHOD(HandlePossibleCommandLineOptionsChange)(IVCBuildErrorContext* pEC);
	STDMETHOD(ClearDirtyCommandLineOptionsFlag)();

//	IVCExternalCookie
public:
	STDMETHOD(get_ExternalCookie)(void** ppVal) { *ppVal = m_pExternalCookie; return S_OK; }
	STDMETHOD(put_ExternalCookie)(void* pVal) { m_pExternalCookie = pVal; return S_OK; }

// Data
protected:
	CComBSTR m_bstrRelativePath;
	// pointer into m_bstrRelativePath, to just the file name portion
	wchar_t *m_wszFileName;
	CComPtr<IUnknown> m_pParent;
	CComPtr<VCProject> m_pProject;
	CComDynamicListTyped<VCFileConfiguration> m_configfiles;	// collection of configs for this file
	BldFileRegHandle m_frh;
	void* m_pExternalCookie;
	VARIANT_BOOL m_bDeploymentContent;

// INTERNAL METHODS
public:
	HRESULT SetDirty(VARIANT_BOOL bDirty);
	HRESULT CheckCanMove(IDispatch *pParent);
};

#endif // !defined(AFX_FILE_H__625C6499_2C7E_11D3_87BF_A0494CC10000__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\vcpb\FileConfiguration.h ===
// FileConfiguration.h: Definition of the CFileConfiguration class
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_FILECONFIGURATION_H__A54AAE8C_30C2_11D3_87BF_A04A4CC10000__INCLUDED_)
#define AFX_FILECONFIGURATION_H__A54AAE8C_30C2_11D3_87BF_A04A4CC10000__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include <vccoll.h>
#include <vcmap.h>
#include "buildengine.h"
#include "settingspage.h"
#include "ProjEvaluator.h"

/////////////////////////////////////////////////////////////////////////////
// CFileConfiguration

class CFileConfiguration : 
	public IDispatchImpl<VCFileConfiguration, &IID_VCFileConfiguration, &LIBID_VCProjectEngineLibrary, PublicProjBuildTypeLibNumber,0, CVsTypeInfoHolder>, 
	public IVCFileConfigurationImpl,
	public IVCPropertyContainer,
	public IVCBuildableItem,
	public CProjectEvaluator,
	public CComObjectRoot
{
public:
	CFileConfiguration()
	{
		m_bIgnoreDefaultTool = VARIANT_FALSE;
		m_pPropMap = NULL;
	}
	~CFileConfiguration()
	{
		if( m_pPropMap )
			delete m_pPropMap;
	}
	static HRESULT CreateInstance(VCFileConfiguration **ppFileConfiguration);

BEGIN_COM_MAP(CFileConfiguration)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(VCFileConfiguration)
	COM_INTERFACE_ENTRY(IVCFileConfigurationImpl)
	COM_INTERFACE_ENTRY(IVCPropertyContainer)
	COM_INTERFACE_ENTRY(IVCBuildableItem)
	COM_INTERFACE_ENTRY(ISpecifyPropertyPages)
END_COM_MAP()
//DECLARE_NOT_AGGREGATABLE(CFileConfiguration) 
// Remove the comment from the line above if you don't want your object to 
// support aggregation. 

DECLARE_NO_REGISTRY()

// VCFileConfiguration
public:
	STDMETHOD(get_Parent)(/*[out, retval]*/ IDispatch* *pVal);
	STDMETHOD(get_Tool)(/*[out, retval]*/ IDispatch* *pVal);
	STDMETHOD(put_Tool)(/*[in]*/ IDispatch* newVal);
	STDMETHOD(get_ExcludedFromBuild)(/*[out, retval]*/  VARIANT_BOOL* pbExcludedFromBuild);
	STDMETHOD(put_ExcludedFromBuild)(/*[in]*/ VARIANT_BOOL bExcludedFromBuild);
	STDMETHOD(get_Name)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(MatchName)(BSTR bstrNameToMatch, VARIANT_BOOL bFullOnly, VARIANT_BOOL *pbMatched);
	STDMETHOD(get_VCProjectEngine)(IDispatch** projEngine);

// IVCFileConfigurationImpl
public:
	STDMETHOD(get_File)(/*[out, retval]*/ IDispatch* *pVal);
	STDMETHOD(put_File)(/*[in]*/ IDispatch* newVal);
	STDMETHOD(get_Configuration)(/*[out, retval]*/ IDispatch* *pVal);
	STDMETHOD(put_Configuration)(/*[in]*/ IDispatch* newVal);
	STDMETHOD(get_IgnoreDefaultTool)(/*[out, retval]*/  VARIANT_BOOL* pbIgnoreDefaultTool);	// shortcut way to figure out if the user explicitly set the tool
	STDMETHOD(SaveObject)(IStream *xml, IVCPropertyContainer *pPropCnt, long nIndent);
	STDMETHOD(Close)();
	STDMETHOD(SetDefaultTool)(IVCToolImpl* pTool, BOOL bReallyIsDefault);
	// WARNING: Clone must only be called on a brand new config!!
	STDMETHOD(Clone)(IVCPropertyContainer *pSource);
	STDMETHOD(CreatePageObject)(IUnknown **, CLSID *, IVCPropertyContainer *pSource, IVCSettingsPage * );
	STDMETHOD(get_OutputFile)(BSTR* pbstrFile);	// output file name if this file gets built
	STDMETHOD(put_OutputFile)(BSTR bstrFile);
	STDMETHOD(get_DefaultOutputFileFormat)(BSTR* pbstrFormat);
	STDMETHOD(VerifyToolValid)();	// verify that the currently assigned tool works with the current config properties

// IVCPropertyContainer
public:
	STDMETHOD(ClearAll)();
	STDMETHOD(GetLocalProp)(long id, /*[out]*/ VARIANT *pvarValue);
	STDMETHOD(GetParentProp)(long id, VARIANT_BOOL bAllowInherit, VARIANT *pvarValue);
	STDMETHOD(Clear)(long id);
	STDMETHOD(GetProp)(long id, VARIANT *varValue);
	STDMETHOD(DirtyProp)(long id);
	STDMETHOD(IsMultiProp)(long id, VARIANT_BOOL* pbIsMulti);
	STDMETHOD(GetMultiProp)(long id, LPCOLESTR szSeparator, VARIANT_BOOL bSkipLocal, BSTR *varValue);
	STDMETHOD(GetMultiPropSeparator)(long id, BSTR* pbstrPreferred, BSTR* pbstrAll);
	STDMETHOD(SetProp)(long id, VARIANT varValue);
	STDMETHOD(GetStrProperty)(long idProp, BSTR* pbstrValue);
	STDMETHOD(SetStrProperty)(long idProp, BSTR bstrValue);
	STDMETHOD(GetIntProperty)(long idProp, long* pnValue);
	STDMETHOD(SetIntProperty)(long idProp, long nValue);
	STDMETHOD(GetBoolProperty)(long idProp, VARIANT_BOOL* pbValue);
	STDMETHOD(SetBoolProperty)(long idProp, VARIANT_BOOL bValue);
	STDMETHOD(GetEvaluatedStrProperty)(long idProp, BSTR* pbstrValue);
	STDMETHOD(GetEvaluatedMultiProp)(long idProp, LPCOLESTR szSeparator, VARIANT_BOOL bCollapseMultiples, 
		VARIANT_BOOL bCaseSensitive, BSTR* pbstrValue);
	STDMETHOD(Evaluate)(BSTR bstrIn, BSTR *bstrOut);
	STDMETHOD(EvaluateWithValidation)(BSTR bstrSource, long idProp, BSTR* pbstrExpanded);
	STDMETHOD(Commit)(){return E_NOTIMPL;}
	STDMETHOD(HasLocalStorage)(VARIANT_BOOL bForSave, VARIANT_BOOL* pbHasLocalStorage);
	STDMETHOD(GetStagedPropertyContainer)(VARIANT_BOOL bCreateIfNecessary, IVCStagedPropertyContainer** ppPropContainer);
	STDMETHOD(ReleaseStagedPropertyContainer)();		// intended for use ONLY by the staged property container itself

// IVCBuildableItem
public:
	STDMETHOD(get_ItemFileName)(BSTR *pVal);
	STDMETHOD(get_ItemFullPath)(BSTR* pbstrFullPath);
	STDMETHOD(get_ActionList)(IVCBuildActionList** ppActions);
	STDMETHOD(get_FileRegHandle)(void** pfrh);
	STDMETHOD(AssignActions)(VARIANT_BOOL bOnOpen);	// set up actions for being able to build
	STDMETHOD(UnAssignActions)(VARIANT_BOOL bOnClose);	// close down actions for being able to build
	STDMETHOD(get_ContentList)(IEnumVARIANT** ppContentList);
	STDMETHOD(get_Registry)(void** pFileRegistry);
	STDMETHOD(get_ProjectConfiguration)(VCConfiguration** ppProjCfg);
	STDMETHOD(get_ProjectInternal)(VCProject** ppProject);
	STDMETHOD(get_ExistingBuildEngine)(IVCBuildEngine** ppBldEngine);
	STDMETHOD(get_PersistPath)(BSTR* pbstrPersistPath);
	STDMETHOD(RefreshActionOutputs)(long nPropID, IVCBuildErrorContext* pEC);
	STDMETHOD(HandlePossibleCommandLineOptionsChange)(IVCBuildErrorContext* pEC);
	STDMETHOD(ClearDirtyCommandLineOptionsFlag)();

// ISpecifyPropertyPages
public:
	STDMETHOD(GetPages)( /* [out] */ CAUUID *pPages );

//data
protected:
	CComPtr<IVCBuildActionList> m_spActionList;
	CVCMap<long,long,CComVariant,VARIANT&> *m_pPropMap;
	CComPtr<VCConfiguration> m_pConfig;
	CComPtr<VCFile> m_pFile;
	CComPtr<IVCToolImpl> m_pTool;
	CComPtr<IVCStagedPropertyContainer> m_spStagedContainer;
	VARIANT_BOOL m_bIgnoreDefaultTool;

// LOCAL METHODS
public:
	HRESULT SetDirty(VARIANT_BOOL bDirty);
	HRESULT GetFileCfgPCR(CBldCfgRecord** ppCfgRecord);
	HRESULT DoSetTool(IVCToolImpl* pTool, BOOL bDoAssign);
	HRESULT DirtyCommandLineOptions(long nLowKey, long nHighKey);
	static HRESULT SGetExcludedFromBuild(VARIANT_BOOL* pbExcluded);

protected:
	// IVCPropertyContainer helpers
	HRESULT DoGetStrProperty(long idProp, BOOL bSpecialPropsOnly, BSTR* pbstrValue);
	HRESULT DoGetProp(long id, BOOL bCheckSpecialProps, VARIANT *pVarValue);
	void ResetRegRef(VARIANT_BOOL bReleaseRef);
	void SetToolsDirty();
	void StartSetOrClearProp(long id, BOOL& bCareAboutChange, VARIANT_BOOL& bOldVal);
	void FinishSetOrClearProp(long id, BOOL bCareAboutChange, VARIANT_BOOL bOldVal, VARIANT_BOOL bNewVal);
};

/////////////////////////////////////////////////////////////////////////////
// CVCGeneralFileConfigSettingsPage

class ATL_NO_VTABLE CVCGeneralFileConfigSettingsPage :
	public IDispatchImpl<IVCGeneralFileConfigurationSettings, &IID_IVCGeneralFileConfigurationSettings, &LIBID_VCProjectEnginePrivateLibrary, PrivateProjBuildTypeLibNumber,0, CVsTypeInfoHolder>,
	public CPageObjectImpl<CVCGeneralFileConfigSettingsPage,VCFILECONFIGURATION_MIN_DISPID,VCFILECONFIGURATION_MAX_DISPID>,
	public CComObjectRoot
{
public:

BEGIN_COM_MAP(CVCGeneralFileConfigSettingsPage)
	COM_INTERFACE_ENTRY(IPerPropertyBrowsing)
	COM_INTERFACE_ENTRY(IVsPerPropertyBrowsing)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IVCGeneralFileConfigurationSettings)
	COM_INTERFACE_ENTRY(IVCPropertyContainer)
END_COM_MAP()

// IVCGeneralFileConfigurationSettings
public:
	STDMETHOD(get_ExcludedFromBuild)(VARIANT_BOOL *pbExcluded);
	STDMETHOD(put_ExcludedFromBuild)(VARIANT_BOOL bExcluded);
	STDMETHOD(get_Tool)(int* pdwTool);
	STDMETHOD(put_Tool)(int dwTool);

// IVCPropertyContainer methods
public:
	STDMETHOD(Commit)();

// IPerPropertyBrowsing methods
public:
	STDMETHOD(GetDisplayString)(DISPID dispID, BSTR *pBstr);
	STDMETHOD(GetPredefinedStrings)(DISPID dispID, CALPOLESTR *pCaStringsOut, CADWORD *pCaCookiesOut);
	STDMETHOD(GetPredefinedValue)(DISPID dispID, DWORD dwCookie, VARIANT* pVarOut);
	STDMETHOD(HasDefaultValue)(DISPID dispid, BOOL *pfDefault);

// helper functions
public:
	virtual void ResetParentIfNeeded();

protected:
	BOOL IsDefaultTool(int nToolID);

protected:
	CComDynamicListTyped<IVCToolImpl> m_rgFileTools;	// collection of tools available for this file
	CVCStringWArray m_strToolNames;						// names to match the file tools
	int m_cTools;										// number of tools available
	int m_nCurrentTool;									// currently assigned tool
	int m_nLastTool;									// tool assigned when this page was brought up/last applied
	int m_nDefaultTool;									// ID for default tool
	CStringW m_strFileExt;								// file extension
	bool m_bAllowInherit;								// assigned tool is default tool
	bool m_bNoFileTools;								// config has no file tools
};

#endif // !defined(AFX_FILECONFIGURATION_H__A54AAE8C_30C2_11D3_87BF_A04A4CC10000__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\vcpb\fileregistry.cpp ===
#include "stdafx.h"
#include <sys\utime.h>

#include "FileRegistry.h"
#include "BuildEngine.h"
#include "VCProjectEngine.h"

CTestableSection g_sectionRegistryFull;
CTestableSection g_sectionRegistrySingle;
CTestableSection g_sectionRegistryFilter;
CTestableSection g_sectionFileDelete;

///////////////////////////////////////////////////////////////////////////////
//
//	CBldFileRegEntry

// file reg. entry local heap
static const int s_nRegSetRefCount = 1000;

// this variable helps us to only update time stamps on an as-needed basis
static DWORD g_dwUpdateTickCount = 0;

CTestableSection g_sectionDepUpdateQ;

CTestableSection CBldFileRegFile::g_sectionFileMap;

#ifdef _DEBUG

// AddFRHRef and ReleaseFRHRef are defined inline in pfilereg.h for non-debug builds.
void CBldFileRegEntry::AddFRHRef()
{
	// Prevent access to registry by other threads.
	CritSectionT cs(g_sectionRegistrySingle);
	m_nRefCount++;
}

void CBldFileRegEntry::ReleaseFRHRef()
{
	// Prevent access to registry by other threads.
	CritSectionT cs(g_sectionRegistrySingle);

	// Keep information around for CBldFileRegFile
	VSASSERT(0!=m_nRefCount, "Trying to release a reg handle too many times");
	if (0 == m_nRefCount)
		return;

	m_nRefCount--;
	
	if (m_nRefCount == 0)
		SafeDelete();
}
#endif // _DEBUG

CBldFileRegEntry::CBldFileRegEntry()
{
	m_dwNodeType = nodetypeRegEntry | nodetypeRegNotifyRx;
	
	// Initialize the basic file registry entry properties
	m_nExistsOnDisk = FALSE;

	// Initialize the non informing properties
	m_nRefCount = 0;

	m_bMatchCase = FALSE;	
	m_bWantActualCase = FALSE;	
	m_bUseIntDir = FALSE;
	m_bUseOutDir = FALSE;

	// Initialize the update atrributes and dirty bit
	m_bDirty = FALSE;
	m_bUpdateAttribs = TRUE;

	m_bFoundInPath = FALSE;     
	m_bRelativeToProjName = FALSE;     
}

CBldFileRegEntry::~CBldFileRegEntry()
{
	VSASSERT(0==m_nRefCount, "Failed to completely release a reg handle");

}

void CBldFileRegEntry::OnNotify(BldFileRegHandle hndFileReg, IVCBuildErrorContext* pEC, UINT idChange, void* pHint)
{
	VSASSERT(FALSE, "Base class method OnNotify must be overridden");
}

void CBldFileRegEntry::InformNotifyRxs(UINT idChange, IVCBuildErrorContext* pEC, void* pHint /* = NULL */)
{
	INT_PTR nMax = m_Dependants.GetSize();
	for (INT_PTR idx = 0; idx < nMax; idx++)
	{
		CBldFileRegNotifyRx * pfrerx = (CBldFileRegNotifyRx*)m_Dependants.GetAt(idx);
		if (pfrerx)
			pfrerx->OnNotify(this, pEC, idChange, pHint);
	}
}

void CBldFileRegEntry::AddNotifyRx(CBldFileRegNotifyRx* pfre, BOOL bCheckExistence)
{
	// Add a notification receiver to our dependency list
	VSASSERT(pfre != this, "Trying to add ourself to the list of dependents on us.  Bad recursion about to ensue when we do an OnNotify...");
	int idx = -1;
	if (bCheckExistence)
		idx = m_Dependants.Find(pfre);
	if (idx < 0)
		m_Dependants.AddTail(pfre);

	VSASSERT(idx < 0, "Trying to add the same dependent twice");
}

void CBldFileRegEntry::RemoveNotifyRx(CBldFileRegNotifyRx* pfre)
{
	// Remove a notification receiver from our dependency list
	m_Dependants.RemoveItem(pfre);
}

BOOL CBldFileRegEntry::SetIntProp(UINT idProp, int nVal)
{
	// set an integer property value
	VSASSERT(idProp == P_ExistsOnDisk, "Trying to set an int prop we don't have");	// We only have one bool property

	// Prevent access to registry by other threads.
	CritSectionT cs(g_sectionRegistrySingle);

	int nOldVal = m_nExistsOnDisk;

	// any change?
	if (nOldVal != nVal)
		m_nExistsOnDisk = nVal;

	return TRUE;
}

BOOL CBldFileRegEntry::GetIntProp(UINT idProp, int& nVal, BOOL bUpdate)
{
	// Get an integer property value
	if (bUpdate)
		(void)UpdateAttributes();
 	
	VSASSERT(idProp == P_ExistsOnDisk, "Trying to get info about an int prop we don't have");
	nVal = m_nExistsOnDisk;
	return TRUE;
}

BOOL CBldFileRegEntry::UpdateAttributes()
{
	m_bUpdateAttribs = FALSE;
	BOOL fRefreshed = RefreshAttributes();
	m_bUpdateAttribs = TRUE;

	return fRefreshed;
}

///////////////////////////////////////////////////////////////////////////////
//
//	CBldFileRegSet

CBldFileRegSet::CBldFileRegSet(int nHashSize)
	: CBldFileRegEntry(), m_Contents(nContentsBlockSize), m_bSkipUpdate(FALSE)
{
	m_dwNodeType = nodetypeRegEntry | nodetypeRegSet | nodetypeRegNotifyRx;

	m_pmapContents = NULL;			// no map yet
	m_nHashSizeMapContents = (USHORT)nHashSize;
	m_nExistsOnDisk = TRUE;
	m_posEnum = NULL;

	// Newest date
	m_NewTime.dwLowDateTime = m_NewTime.dwHighDateTime = 0;	// not using SetTimeProp 'cause why send out notifications about this?

	// If set is empty then it exists...
	SetIntProp(P_ExistsOnDisk, TRUE);
 
	// Initialize private cache helping members
	m_nNotExists = 0;
	m_fInitSet = FALSE;

	// Calculate contents attribute changes (off by default)
	m_fCalcAttrib = FALSE;

	m_pFileRegistry = NULL;

	// Set at s_nRegSetRefCount so it will never be deleted accidently.
	m_nRefCount = s_nRegSetRefCount;
}

CBldFileRegSet::~CBldFileRegSet()
{
	m_bUpdateAttribs = FALSE;	// don't attempt to update
 	m_fCalcAttrib = FALSE;		// don't re-calc attrib.

	VCPOSITION pos = m_Contents.GetHeadPosition();
	VCPOSITION lastPos;
	while (pos != NULL)
	{
		// WARNING: this code accessses the m_pFileRegistry member.  If the
		// current object is itself a CBldFileRegistry then this pointer is a
		// self-pointer, and we go into CBldFileRegistry methods after the
		// CBldFileRegistry destructor has been called!  This should be changed.
		lastPos = pos;
		BldFileRegHandle hndFileReg = (BldFileRegHandle)m_Contents.GetNext(pos);
		RemoveRegHandleI(hndFileReg); // calling directly to level I function to avoid n^2 lookup
	}

	if (m_pmapContents != NULL)
		delete m_pmapContents;	// one has been allocated, so we must delete it

	// Unhook from registry.
	if (NULL != m_pFileRegistry)
		SetFileRegistry(NULL);

	VSASSERT(s_nRegSetRefCount == m_nRefCount, "Ref count mismatch on the file registry");
	m_nRefCount = 0;
}

void CBldFileRegSet::InitFrhEnum()
{
	// init. the enumerator
	m_posEnum = m_Contents.GetHeadPosition();
	m_fInitSet = TRUE;
}

BldFileRegHandle CBldFileRegSet::NextFrh()
{
TryAgain:
	// exhausted?
	if (m_posEnum == (VCPOSITION)NULL)
		return (BldFileRegHandle)NULL;

	// is this a set?
	VCPOSITION posEnum = m_posEnum;
	BldFileRegHandle frh = (BldFileRegHandle)m_Contents.GetNext(posEnum);
	if (((CBldFileRegEntry *)frh)->IsNodeType(nodetypeRegSet))
	{
		// init. enumerator of this set?
		if (m_fInitSet)
		{
			// init. then remember that we have
			((CBldFileRegSet *)frh)->InitFrhEnum();
			m_fInitSet = FALSE;
		}

		// set got one?
		if ((frh = ((CBldFileRegSet *)frh)->NextFrh()) == (BldFileRegHandle)NULL)
		{
			// reset so that we init. next set
			m_fInitSet = TRUE;

			// advance...
			m_posEnum = posEnum;
			goto TryAgain;
		}
	}
	else
	{
		// advance...
		m_posEnum = posEnum;

		// The NextFrh() caller needs to ReleaseFRHRef.
		frh->AddFRHRef();
	}

	return frh;
}

BOOL CBldFileRegSet::AddRegHandle(BldFileRegHandle hndFileReg, IVCBuildErrorContext* pEC /* = NULL */,
	BOOL bAddRef /* = TRUE */, BOOL bAddFront /* = FALSE */)
{
	VSASSERT(hndFileReg, "Trying to add NULL reg handle to registry");
	VSASSERT( !hndFileReg->IsNodeType(nodetypeRegRegistry), "Not allowed to add a registry to a registry" );
	VSASSERT( !hndFileReg->IsNodeType(nodetypeRegFilter), "Not allowed to add a filter to a registry" );

	// Already exists in set....return
	if (RegHandleExists(hndFileReg))
		return TRUE;

	// Reference held by this file set.
	hndFileReg->AddFRHRef();

	// This may result in new dependency update requests, so we must not be locking
	// the lists at this time.
	VSASSERT(!g_sectionDepUpdateQ.FOwned(), "Trying to lock the lists while doing dependency updates.  Deadly embrace.");

	// Is the CBldFileRegEntry a CBldFileRegSet if so then we must
	// set up the associated file registry...
	CBldFileRegSet * pFileRegSet = NULL;
	if (m_pFileRegistry == NULL)
		pFileRegSet = (CBldFileRegSet *)(g_FileRegistry.GetRegEntry(hndFileReg));
	else
		pFileRegSet = (CBldFileRegSet *)(m_pFileRegistry->GetRegEntry(hndFileReg));

	BOOL bIsFirstMember = FALSE;
	{
		// Prevent access to registry by other threads.
		CritSectionT cs(g_sectionRegistrySingle);

		if (pFileRegSet->IsNodeType(nodetypeRegSet))
			pFileRegSet->SetFileRegistry(m_pFileRegistry);

		// Add the CBldFileRegEntry to the set
		if (bAddFront)
			m_Contents.AddHead(hndFileReg);
		else
			m_Contents.AddTail(hndFileReg);

		if (m_pmapContents == NULL && m_Contents.GetCount() >= cMapThreshold)
		{
			// We now have enough items to create a content map ... do so and fill it with
			// the items so far.
			m_pmapContents = new CVCMapPtrToWord;
			m_pmapContents->InitHashTable(m_nHashSizeMapContents);
			for (VCPOSITION pos = m_Contents.GetHeadPosition(); pos != NULL; )
			{
				m_pmapContents->SetAt(m_Contents.GetNext(pos), 0);
			}
		}
		else if (m_pmapContents != NULL)
			m_pmapContents->SetAt(hndFileReg, 0);
		else
			bIsFirstMember = m_Contents.GetCount() == 1;
	}

	// Add this set as a dependant of the item just added
	// and inform ourselves of this addition
 	hndFileReg->AddNotifyRx(this, FALSE);
	if (m_fCalcAttrib)
	{
		FILETIME Time;
		FILETIME ChangedTime;

		// we're going to calculate attribs now, don't allow recursion
		m_fCalcAttrib = FALSE;

 		// Maintain our cache value of the number of items that do not exist but are contained in us
		BOOL bExists;
		if (hndFileReg->GetIntProp(P_ExistsOnDisk, bExists))
		{
			// If this new file does not exist on disk then we should not consider the file times it 
			// has set as they don't mean anything!.
			if (bExists)
 			{
				BOOL bOldSkipUpdate = m_bSkipUpdate;
				m_bSkipUpdate = !bIsFirstMember;
				if (!hndFileReg->GetTimeProp(P_NewTStamp, ChangedTime, FALSE) || 
					!GetTimeProp(P_NewTStamp, Time, bIsFirstMember))
					MakeDirty();
				else if (ChangedTime > Time)
					SetTimeProp(P_NewTStamp, ChangedTime);
				m_bSkipUpdate = bOldSkipUpdate;
			}
			else
				m_nNotExists++; 

			BOOL bOldSkipUpdate = m_bSkipUpdate;
			m_bSkipUpdate = TRUE;
 			SetIntProp(P_ExistsOnDisk, m_nNotExists == 0);
			m_bSkipUpdate = bOldSkipUpdate;
		}
		else
			MakeDirty();

		m_fCalcAttrib = TRUE;
	}

	InformNotifyRxs(FRI_ADD, pEC, (void *)hndFileReg);
 	
	return TRUE;
}

BOOL CBldFileRegSet::RemoveRegHandle(BldFileRegHandle hndFileReg, BOOL bReleaseRef /* = TRUE */)
{
	VSASSERT(hndFileReg, "Cannot remove NULL reg handles...");

	// Remove the CBldFileRegEntry from the set
	VCPOSITION pos = m_Contents.Find(hndFileReg);
	if (pos != NULL)
		RemoveRegHandleI(hndFileReg, NULL, bReleaseRef);

	return TRUE;	// only return FALSE in error
}

void CBldFileRegSet::RemoveRegHandleI(BldFileRegHandle hndFileReg, IVCBuildErrorContext* pEC /* = NULL */, 
	BOOL bReleaseRef /* = TRUE */)
{
	// Remove us as a dependant of the item just removed
	hndFileReg->RemoveNotifyRx(this);

	{
		// Prevent access to registry by other threads.
		CritSectionT cs(g_sectionRegistryFull);

		VCPOSITION pos = m_Contents.Find(hndFileReg);
		VSASSERT(pos != (VCPOSITION)NULL, "Reg handle we're trying to remove isn't in our list.  Probably released too many times elsewhere.");
		if (pos != (VCPOSITION)NULL)
			m_Contents.RemoveAt(pos);
		else
			return; /* FALSE */
	}

	//
	// Notify dependents this handle is being destroyed.
	InformNotifyRxs(FRI_DESTROY, pEC, (void *)hndFileReg);

	{
		// Prevent access to registry by other threads.
		CritSectionT cs(g_sectionRegistryFull);

		// If the item being destroyed is still in us then remove it.
 		if (m_pmapContents != NULL)
			m_pmapContents->RemoveKey(hndFileReg);
	}

	// calculate new attrib?
	if (m_fCalcAttrib)
	{
		FILETIME Time;
		FILETIME ChangedTime;

		// we're going to calculate attribs now, 
		// don't allow recursion
		m_fCalcAttrib = FALSE;

		// Maintain our cache value of the number of items that
		// do not exist but are contained in us
		BOOL bExists;
		if (hndFileReg->GetIntProp(P_ExistsOnDisk, bExists))
		{
			if (!bExists)
			{
				if (m_nNotExists)
					m_nNotExists--;
			}
			else
			{
				// If the item being destroyed does not exist on
				// disk then it cannot influence our cached new and
				// old time stamps for the set.
				if (bExists && PROJECT_IS_LOADED())
				{	
					BOOL bOldSkipUpdate = m_bSkipUpdate;
					m_bSkipUpdate = TRUE;
					if (!hndFileReg->GetTimeProp(P_NewTStamp, ChangedTime, FALSE) || !GetTimeProp(P_NewTStamp, Time))
						MakeDirty();
					else
					{
 						// If the item going away is currently our newest time stamped item
						// then we have to find a new newest time stamped item in our set
						if (ChangedTime==Time)
		 					FindTimeAndExists(P_NewTStamp);
					}
					m_bSkipUpdate = bOldSkipUpdate;
				}
			}

			BOOL bOldSkipUpdate = m_bSkipUpdate;
			SetIntProp(P_ExistsOnDisk, m_nNotExists == 0);
			m_bSkipUpdate = bOldSkipUpdate;
		}
		else
 			MakeDirty();

		m_fCalcAttrib = TRUE;
	}

	// Release reference held by this file set.
	hndFileReg->ReleaseFRHRef();

	return; /* TRUE */
}

// This routine cannot be called during project destruction or it will assert.
void CBldFileRegSet::EmptyContent(BOOL bReleaseRef /* = TRUE */)
{
	// Prevent access to registry by other threads.
	CritSectionT cs(g_sectionRegistryFull);

	// Empty our contents
	VCPOSITION pos = m_Contents.GetHeadPosition();
	while (pos != (VCPOSITION)NULL)
	{
		BldFileRegHandle hndFileReg = (BldFileRegHandle)m_Contents.GetNext(pos);
		RemoveRegHandle(hndFileReg);
	}

	// Set the default property values for an empty set
	FILETIME NewestTime;
	
	// Newest date
	NewestTime.dwLowDateTime = 0;
	NewestTime.dwHighDateTime = 0;

	// Set is empty then it exists...
	SetIntProp(P_ExistsOnDisk, TRUE);
 
	// Set the default property values
	SetTimeProp(P_NewTStamp, NewestTime);

	//  Initialize private cache helping members
	m_nNotExists = 0;
}

BOOL CBldFileRegSet::CalcAttributes(BOOL fOn /* = TRUE */)
{
	BOOL fOldOn = m_fCalcAttrib;

	// different to old value?
	if (fOn != fOldOn)
	{
		// setting back on?
		if (!fOldOn)
			(void)RefreshAttributes();		// refresh our attributes if changed on

		m_fCalcAttrib = fOn;
	}

	return fOldOn;
}

BOOL CBldFileRegSet::DoRefresh()
{
	// updating?
	if ((!m_bUpdateAttribs) || (!PROJECT_IS_LOADED()))
		return FALSE;	// no

	// base-class refresh?
	if (CBldFileRegEntry::DoRefresh())
		return TRUE;	// yes

 	VCPOSITION pos = m_Contents.GetHeadPosition();
	while (pos != NULL)
		if (((BldFileRegHandle)m_Contents.GetNext(pos))->DoRefresh())
			return TRUE;	// yes

	return FALSE;	// no
}

BOOL CBldFileRegSet::UpdateAttributes()
{
	if (!PROJECT_IS_LOADED())
		return TRUE;

	BOOL fRefreshed = FALSE;
 	VCPOSITION pos = m_Contents.GetHeadPosition();
	while (pos != (VCPOSITION)NULL)
		if (g_FileRegistry.GetRegEntry((BldFileRegHandle)m_Contents.GetNext(pos))->UpdateAttributes())
			fRefreshed = TRUE;
					 
	return TRUE;	// ok
}

BOOL CBldFileRegSet::RefreshAttributes()
{
	// No longer dirty
	m_bDirty = FALSE;
	
	// Refreshing the attributes on a set means updating, ie. a refresh if dirty, the attributes 
	// of all referenced CBldFileRegEntry items contained, and then doing a sweep to find our 
	// accumulative attributes

	// Find the number that exist
	// Set the newest timestamp prop.
	// This function will ensure that all props. are updated for each of our contents
	FindTimeAndExists(P_NewTStamp, TRUE);

	return TRUE;	// performed refresh
}

void CBldFileRegSet::FindTimeAndExists(UINT idProp, BOOL bFindExists)
{
	BOOL fOldOn = m_fCalcAttrib;
	m_fCalcAttrib = FALSE;

	VSASSERT(idProp == P_NewTStamp, "Trying to get info about a time prop we don't have.");
	if (idProp != P_NewTStamp)	// dunno anything else
		return;

	FILETIME NewTime, CurrentTime;
 	BOOL bExistsOnDisk = FALSE;
	unsigned nNotExists = 0;

	NewTime.dwLowDateTime = NewTime.dwHighDateTime = 0;

	VCPOSITION pos = m_Contents.GetHeadPosition();
	while (pos != NULL)
	{
		BldFileRegHandle hndFileReg = (BldFileRegHandle)m_Contents.GetNext(pos);
		if (hndFileReg->GetIntProp(P_ExistsOnDisk, bExistsOnDisk))
		{
			if (bExistsOnDisk)
			{
				// is this a set?
				if (hndFileReg->IsNodeType(nodetypeRegSet))
				{
					// figure out the newest time
					if (hndFileReg->GetTimeProp(P_NewTStamp, CurrentTime, FALSE) &&
						(MyCompareFileTime(&CurrentTime, &NewTime) > 0))
						NewTime = CurrentTime;
				}
				else
				{
					if (!hndFileReg->GetTimeProp(P_NewTStamp, CurrentTime, FALSE))
						continue;

					// figure out the newest time
					if (MyCompareFileTime(&CurrentTime, &NewTime) > 0)
 						NewTime = CurrentTime;
				}
			}
			else
				nNotExists++;
		}
		else
			MakeDirty();
 	}

	m_fCalcAttrib = fOldOn;

	// set the newest time
	SetTimeProp(P_NewTStamp, NewTime);

	//
	// Update "exists" attributes.
	if (bFindExists)
	{
		m_nNotExists = (USHORT)nNotExists;
		SetIntProp(P_ExistsOnDisk, m_nNotExists == 0);
	}
}

void CBldFileRegSet::FindExists()
{
	BOOL fOldOn = m_fCalcAttrib;
	m_fCalcAttrib = FALSE;

	unsigned nNotExists = 0;

	// get the prop. for each of our contents
 	VCPOSITION pos = m_Contents.GetHeadPosition();
	while (pos != NULL)
	{
		BldFileRegHandle hndFileReg = (BldFileRegHandle) m_Contents.GetNext(pos);
	
		// This function will ensure that all props. are updated
		// for each of our contents
		BOOL bExists;
		BOOL bOK = hndFileReg->GetIntProp(P_ExistsOnDisk, bExists);
		VSASSERT(bOK, "Failed to determine whether the file exists on disk!");
		if (!bExists)
			nNotExists++;
	}

	m_fCalcAttrib = fOldOn;

	// set whether all our contents exist or not
	m_nNotExists = (USHORT)nNotExists;
	SetIntProp(P_ExistsOnDisk, m_nNotExists == 0);
}

BOOL CBldFileRegSet::Touch()
{
	BOOL bRetVal = TRUE;

	// get the prop. for each of our contents
 	VCPOSITION pos = m_Contents.GetHeadPosition();
	while (pos != NULL)
	{
		BldFileRegHandle hndFileReg = (BldFileRegHandle) m_Contents.GetNext(pos);
		bRetVal = bRetVal && hndFileReg->Touch();
	}

	return bRetVal;
}

void CBldFileRegSet::DeleteFromDisk()
{
	// get the prop. for each of our contents
 	VCPOSITION pos = m_Contents.GetHeadPosition();
	while (pos != NULL)
	{
		BldFileRegHandle hndFileReg = (BldFileRegHandle) m_Contents.GetNext(pos);
		hndFileReg->DeleteFromDisk();
	}
}

void CBldFileRegSet::OnNotify(BldFileRegHandle hndFileReg, IVCBuildErrorContext* pEC, UINT idChange, void* pHint)
{
	FILETIME Time;
	FILETIME ChangedTime;

	VSASSERT(hndFileReg, "Trying to do notifications with a NULL reg handle.  Bad business.");
	if (!PROJECT_IS_LOADED())
		return;	// can't do anything during project load/unload

	// Handle notifications about content changes here
	switch (idChange)
	{
 		case P_NewTStamp:
 		{
			// calculate new attrib?
			if (!m_fCalcAttrib)
				break;	// no

			FILETIME * pPreviousTime = (FILETIME *)pHint;
 			if (GetTimeProp(P_NewTStamp, Time, FALSE) && hndFileReg->GetTimeProp(P_NewTStamp, ChangedTime, FALSE))
			{
				// If the changed time is newer than the current newest time then set
				// the newest time to be the changed time
				// If the changed time is older than the current newest time and the
				// time that changed was the newest time then we have to search the
				// set to find the newest time
				if (MyCompareFileTime(&ChangedTime, &Time) >= 0)
					SetTimeProp(P_NewTStamp, ChangedTime);

				else if (MyCompareFileTime(pPreviousTime, &Time) == 0)
					FindTimeAndExists(P_NewTStamp);
			}
			else
				MakeDirty();
 			break;
		}

		case P_ExistsOnDisk:
		{
			// calculate new attrib?
			if (!m_fCalcAttrib)
				break;	// no

			// find whether we exist
			FindExists();
			break;
		}


 		case FRN_ALL:
		{
			MakeDirty();
			break;
		}
 	}
}

BOOL CBldFileRegSet::GetTimeProp(UINT idProp, FILETIME& ftime, BOOL bUpdate)
{
	// Get a time property value
	if (!PROJECT_IS_LOADED())
	{
		ftime.dwLowDateTime = 0xffffffff;
		ftime.dwHighDateTime = 0x7fffffff;
		return TRUE;
	}
	
	if (bUpdate && !m_bSkipUpdate)
		(void)UpdateAttributes();
 
	switch (idProp)
	{
		case P_NewTStamp:
			ftime = m_NewTime;
			break;

		default:
			return FALSE;
	}

	return TRUE;
}

BOOL CBldFileRegSet::SetTimeProp(UINT idProp, FILETIME ftime)
{
 	// Set a time property value
 	FILETIME oldtime;
 	switch (idProp)
	{
		case P_NewTStamp:
			oldtime = m_NewTime;
			m_NewTime = ftime;
			break;

		default:
			return FALSE;
	}

	// any change?
	if (oldtime.dwLowDateTime != ftime.dwLowDateTime ||
		oldtime.dwHighDateTime != ftime.dwHighDateTime
	   )
	   if (PROJECT_IS_LOADED()) // skip this during project load/unload
		{
			// notify our dependants that a time property value has changed
			InformNotifyRxs(idProp, NULL, (void *)&oldtime);
		}

	return TRUE;
}

void CBldFileRegSet::SetFileRegistry(CBldFileRegistry * pFileRegistry)
{
	// This should be a one time only operation.
//	VSASSERT( IsEmpty(), "Calling SetFileRegistry on a regset more than once." );

	if (NULL != pFileRegistry)
	{
		VCPOSITION pos = m_Contents.GetHeadPosition();
		while (NULL != pos)
		{
			BldFileRegHandle frh = (BldFileRegHandle)m_Contents.GetNext(pos);
			pFileRegistry->AddRegRef(frh);
		}

		VSASSERT(NULL == m_pFileRegistry, "Trying to SetFileRegistry more than once on same regset");
		AddNotifyRx(pFileRegistry, FALSE);
	}
	else if (NULL != m_pFileRegistry)
	{
		RemoveNotifyRx(m_pFileRegistry);

		VCPOSITION pos = m_Contents.GetHeadPosition();
		while (NULL!=pos)
		{
			BldFileRegHandle frh = (BldFileRegHandle)m_Contents.GetNext(pos);
			m_pFileRegistry->ReleaseRegRef(frh);
		}
	}
	else
	{
//		VSASSERT(FALSE, "Bad else case");
	}

	m_pFileRegistry = pFileRegistry;
}

void CBldFileRegSet::MakeContentsDirty(CBldFileRegistry* pRegistry)
{
	InitFrhEnum();
	BldFileRegHandle frh;
	while ((frh = NextFrh()) != (BldFileRegHandle)NULL)
	{
		pRegistry->GetRegEntry(frh)->MakeDirty();
		frh->ReleaseFRHRef();
	}
}

///////////////////////////////////////////////////////////////////////////////
//
//	CBldFileRegFilter

CBldFileRegFilter::CBldFileRegFilter(CStringW strFilter)
{
	m_dwNodeType = nodetypeRegEntry | nodetypeRegSet | nodetypeRegNotifyRx | nodetypeRegFilter;
	m_strFilter = strFilter;
	m_strFilterLC = strFilter;
	m_strFilter.MakeUpper();
	m_strFilterLC.MakeLower();
}

CBldFileRegFilter::~CBldFileRegFilter()
{
	m_bUpdateAttribs = FALSE;	// don't attempt to update
 	m_fCalcAttrib = FALSE;		// don't re-calc attrib.
}

BOOL CBldFileRegFilter::Filter(const wchar_t* pszText)
{
	const wchar_t* pchLastText = NULL;
	const wchar_t* pchPat = m_strFilter;
	const wchar_t* pchPatLC = m_strFilterLC;
	int ichPat = 0, ichLastStar = -1;
	int c;

	while ((*pszText != L'\0') && ((c = pchPat[ichPat]) != L'\0'))
	{
		if (c == L'*')
		{
			ichLastStar = ichPat;
			pchLastText = pszText;
		}
		else if (c == L'?')
		{
			ichPat++;
		}
		else if ((c!=*pszText) && (pchPatLC[ichPat] != *pszText))
		{
			if (ichLastStar != -1)
			{
				ichPat = ichLastStar;
				pszText = ++pchLastText;
			}
			else
				return FALSE;
		}
		else
			pszText++;

		ichPat++;
	}
	pchPat += ichPat;

	// at least one of these must be null to break out of loop
	VSASSERT((*pchPat == L'\0') || (*pszText == L'\0'), "Broke out of loop too early in CBldFileRegFilter::Filter");

	return (*pchPat == *pszText); // == L'\0'
}

BOOL CBldFileRegFilter::AddRegHandle(BldFileRegHandle hndFileReg, IVCBuildErrorContext* pEC /* = NULL */, 
	BOOL bAddRef /* = TRUE */, BOOL bAddFront /* = FALSE */)
{
	// This should never be called since the CBldFileRegistry should be 
	// managing the filter contents.
	VSASSERT(FALSE, "Filter trying to manage filter contents; file registry should be doing that.");
	return FALSE;
}

BOOL CBldFileRegFilter::RemoveRegHandle(BldFileRegHandle hndFileReg, BOOL bReleaseRef /* = TRUE */)
{
	// This should never be called since the CBldFileRegistry should be 
	// managing the filter contents.
	VSASSERT(FALSE, "Filter trying to manage filter contents; file registry should be doing that.");
	return FALSE;
}

BOOL CBldFileRegFilter::AddFilterHandle(BldFileRegHandle hndFileReg)
{
	// Only add files that match our filter
	if (!Filter(*((CBldFileRegFile*)hndFileReg)->GetFilePath()))
		return FALSE;

	return CBldFileRegSet::AddRegHandle(hndFileReg);	// Call base method.
}

BOOL CBldFileRegFilter::RemoveFilterHandle(BldFileRegHandle hndFileReg)
{
	if (Filter(*((CBldFileRegFile*)hndFileReg)->GetFilePath()))
	{
		// Prevent access to registry by other threads.
		CritSectionT cs(g_sectionRegistryFilter);

		VCPOSITION pos = m_Contents.Find(hndFileReg);
		if (NULL != pos)	// won't find it if we weren't filtering it (as in it was excluded from build...)
			return CBldFileRegSet::RemoveRegHandle(hndFileReg);	// Call base method.
	}
	return FALSE;
}

///////////////////////////////////////////////////////////////////////////////
//
//	CBldFileRegFilterSet

CBldFileRegFilterSet::CBldFileRegFilterSet()
{
	m_dwNodeType = nodetypeRegEntry | nodetypeRegSet | nodetypeRegNotifyRx | nodetypeRegFilterSet;
}

CBldFileRegFilterSet::~CBldFileRegFilterSet()
{
}

void CBldFileRegFilterSet::OnNotify(BldFileRegHandle hndFileReg, IVCBuildErrorContext* pEC, UINT idChange, void* pHint)
{
	BldFileRegHandle frh = (BldFileRegHandle)pHint;
	switch (idChange)
	{
	case FRI_ADD:
		VSASSERT(NULL != m_FilterList.Find((void*)hndFileReg), "Failed to find the frh in the filter list!");
		VSASSERT(frh->IsNodeType(nodetypeRegFile), "Can only add a file reg handle to a filter set!");
		CBldFileRegSet::AddRegHandle(frh, pEC);
		break;

	case FRI_DESTROY:
		VSASSERT(NULL != m_FilterList.Find((void*)hndFileReg), "Failed to find the frh in the filter list!");
		VSASSERT(frh->IsNodeType(nodetypeRegFile), "Can only remove a file reg handle from a filter set!");
		CBldFileRegSet::RemoveRegHandle(frh);
		break;

	default:
		CBldFileRegSet::OnNotify(hndFileReg, pEC, idChange, pHint);
		break;
	}
}

BOOL CBldFileRegFilterSet::AddFilter( CBldFileRegFilter* pFilter )
{
	VSASSERT(pFilter->IsNodeType(nodetypeRegFilter), "Only call AddFilter with filters!");
	VSASSERT(NULL == m_FilterList.Find((void*)pFilter), "Only call AddFilter once with any given filter!");

	m_FilterList.AddTail(pFilter);

	pFilter->InitFrhEnum();

	// Add pFilter contents to CBldFileRegFilterSet contents.
	BldFileRegHandle frh = NULL;
	while (NULL!=(frh=pFilter->NextFrh()))
	{
		CBldFileRegSet::AddRegHandle(frh);
		frh->ReleaseFRHRef();
	}

	// Interested in FRI_ADD and FRI_DESTROY notifications from pFilter.
	pFilter->AddNotifyRx(this, TRUE);

	return TRUE;
}

///////////////////////////////////////////////////////////////////////////////
//
//	CBldFileRegFile

CVCMapStringWToPtr*	CBldFileRegFile::s_pFileNameMap = NULL;
CBldFileRegFile::CInitMap s_InitRegFileMap(1499);
CBldFileRegFile::CInitMap::CInitMap(int nHashSize)
{
	CBldFileRegFile::s_pFileNameMap = new CVCMapStringWToPtr(128);
	CBldFileRegFile::s_pFileNameMap->InitHashTable(nHashSize);	// init our map too!
}

CBldFileRegFile::CInitMap::~CInitMap()
{
	// Prevent access to file map by other threads.
	CritSectionT cs(g_sectionFileMap);

	if (CBldFileRegFile::s_pFileNameMap)
		delete CBldFileRegFile::s_pFileNameMap;
	CBldFileRegFile::s_pFileNameMap = NULL;
}

BldFileRegHandle CBldFileRegFile::GetFileHandle(LPCOLESTR szFileName, BOOL bVerifyCase)
{
	CPathW path;
	LPCOLESTR szKey;
	
	if (bVerifyCase)
	{
		if (!path.Create(szFileName))
			return NULL;
		path.GetActualCase(TRUE);
		szKey = path;
	}
	else
		szKey = szFileName;

	BldFileRegHandle hndFileReg = NULL;
	{
		// Prevent access to file map by other threads.
		CritSectionT cs(g_sectionFileMap);
		hndFileReg = LookupFileHandleByName(szKey, FALSE);
	}

	if (NULL == hndFileReg)
	{
		if (!bVerifyCase)
		{
			if (!path.Create(szFileName))
				return NULL;
		}

		CBldFileRegFile * pregfile = new CBldFileRegFile(&path, FALSE /* already verified */);
		if (NULL != pregfile)
		{
			hndFileReg = (BldFileRegHandle)pregfile;

			VSASSERT(NULL != s_pFileNameMap, "File name map not initialized before we tried to use it.");
			if (NULL != s_pFileNameMap)
			{
				CritSectionT cs(g_sectionFileMap);
				s_pFileNameMap->SetAt(szKey, hndFileReg);
			}
			hndFileReg->AddFRHRef();
		}
	}

	return hndFileReg;
}

BldFileRegHandle CBldFileRegFile::LookupFileHandleByName(LPCOLESTR szFileName, BOOL bVerifyCase)
{
	BldFileRegHandle hndFileReg = NULL;

	// No map, no handle.
	if (NULL == s_pFileNameMap)
		return NULL;

	// Key is actual case full path name.
	LPCOLESTR szKey;
	CPathW path;
	if (bVerifyCase)
	{
		if (!path.Create(szFileName))
			return NULL;
		path.GetActualCase(TRUE);
		szKey = path;
	}
	else
	{
		szKey = szFileName;
	}


	// Prevent access to file map by other threads.
	{
		CritSectionT cs(g_sectionFileMap);
		s_pFileNameMap->Lookup(szKey, (void*&)hndFileReg);
	}

	if (NULL != hndFileReg)
		hndFileReg->AddFRHRef();

	return hndFileReg;
}


BldFileRegHandle CBldFileRegFile::LookupFileHandleByKey(LPCOLESTR szKeyName)
{
	BldFileRegHandle hndFileReg = NULL;

	// No map, no handle.
	if (NULL == s_pFileNameMap)
		return NULL;

	VSASSERT(MaxKeyLen > wcslen(szKeyName), "File name too long for us to be able to look up.");

	{
		// Prevent access to file map by other threads.
		CritSectionT cs(g_sectionFileMap);
		s_pFileNameMap->Lookup(szKeyName, (void*&) hndFileReg);
	}

	if (NULL != hndFileReg)
		hndFileReg->AddFRHRef();

	return hndFileReg;
}

void CBldFileRegFile::UpdateTimeStampTick()
{
	g_dwUpdateTickCount++;
}

void CBldFileRegFile::SafeDelete()
{
	// Prevent access to file map by other threads.
	CritSectionT cs(g_sectionFileMap);

	if (0 == m_nRefCount)
		delete this;
}

CBldFileRegFile::CBldFileRegFile
(
	const CPathW * pPath,
	BOOL bMatchCase /* = FALSE */,
	BOOL bFiltered /* = FALSE */
)
	: CBldFileRegEntry()
{
	m_dwNodeType = nodetypeRegEntry | nodetypeRegNotifyRx | nodetypeRegFile;
	m_nExistsOnDisk = TRUE;
	m_dwUpdateTick = 0;

	VSASSERT(pPath->IsInit(), "File path not initialized before creating a reg handle for it.");
	m_Path = *pPath;
	VSASSERT(0 < wcslen(m_Path.GetFullPath()), "Trying to create a reg handle for a NULL file path.  Bad programmer, bad programmer.");

	m_bWantActualCase = (bMatchCase != 0);

	// Review: avoid setting case here if possible
	m_bMatchCase = (bMatchCase == TRUE);
	if (m_bMatchCase) // use bMatchCase = -1 to defer this
		m_Path.GetActualCase(FALSE);
	m_bDirty = TRUE;
	m_bFileNotOnDisk = FALSE;
	plstFileItems = (CVCPtrList *)NULL;
	m_ich = 0;
	m_pOrgName = (wchar_t *)NULL;

	m_FileTime.dwLowDateTime = m_FileTime.dwHighDateTime = 0;
}

CBldFileRegFile::~CBldFileRegFile()
{
	// Remove from map (if map hasn't been destroyed yet during shutdown).

	// No map, no handle.
	if (NULL==s_pFileNameMap)
		return;

	// Delete our list of associated file items
	if (plstFileItems != (CVCPtrList*) NULL)
		delete plstFileItems;

	if (m_pOrgName)
		free(m_pOrgName);

	CritSectionT cs(g_sectionFileMap);
	BOOL b = s_pFileNameMap->RemoveKey(*GetFilePath());
	if( b == FALSE )
	{
		return;
	}
}

BOOL CBldFileRegFile::Touch()
{
	int fh = _wutime (m_Path.GetFullPath(), NULL);
	if (fh == -1)
		return FALSE;
	return TRUE;
}

void CBldFileRegFile::DeleteFromDisk()
{
	// This will cause the file change to be ignored. So things like the 
	// source editor will not get notified of the change.
	m_Path.DeleteFromDisk();
	return;
}

BOOL CBldFileRegFile::GetFileTime(FILETIME& ft)
{
	(void)UpdateAttributes();
	return m_nExistsOnDisk && GetTimeProp(P_NewTStamp, ft, FALSE);
}

BOOL CBldFileRegFile::GetTimeProp(UINT idProp, FILETIME& ftime, BOOL bUpdate)
{
	// Get a time property value
	if (bUpdate || (m_FileTime.dwLowDateTime == 0 && m_FileTime.dwHighDateTime == 0))
		(void)UpdateAttributes();
 
	VSASSERT(idProp == P_NewTStamp, "Only understand P_NewTStamp time prop!");
	ftime = m_FileTime;
 	return TRUE;
}

BOOL CBldFileRegFile::SetTimeProp(UINT idProp, FILETIME ftime)
{
 	if (idProp != P_NewTStamp)
 		return FALSE;

 	FILETIME oldtime = m_FileTime;
 
	// any change?
	if (oldtime.dwLowDateTime != ftime.dwLowDateTime || oldtime.dwHighDateTime != ftime.dwHighDateTime)
	{
		m_FileTime = ftime;

		if (PROJECT_IS_LOADED()) // skip this during project load/unload
		{
			// notify our dependents that a time property value has changed
			InformNotifyRxs(P_NewTStamp, NULL, (void *)&oldtime);
		}
	}

	return TRUE;
}

BOOL CBldFileRegFile::RefreshAttributes()
{
	// No longer dirty
	m_bDirty = FALSE;

	// Get the current file attributes
	if (m_dwUpdateTick == g_dwUpdateTickCount)
		return FALSE;	// nothing to do
	m_dwUpdateTick = g_dwUpdateTickCount;

	S_ATTRIB attrib;
	GetAttributes(&attrib);

	// anything to do?
	if (m_FileTime.dwLowDateTime == attrib._filetime.dwLowDateTime &&
		m_FileTime.dwHighDateTime == attrib._filetime.dwHighDateTime &&
		m_nExistsOnDisk == attrib._fExists
	   )
		return FALSE;	// nothing to do

	// Set the new file attributes
 	SetAttributes(&attrib);

	return TRUE;	// performed a refresh!
}

void CBldFileRegFile::SetAttributes(S_ATTRIB * pattrib)
{
 	// Are we being notified of changes on this file?
 	VSASSERT(pattrib->_fOk, "Bad input parameter!");

 	SetIntProp(P_ExistsOnDisk, pattrib->_fExists);
	SetTimeProp(P_NewTStamp, pattrib->_filetime);
}

BOOL WINAPI OGetFileAttributesExW( LPCOLESTR lpFileName, GET_FILEEX_INFO_LEVELS fInfoLevelId, WIN32_FILE_ATTRIBUTE_DATA *lpFileInformation )
{
	if ( ::IsUnicodeSystem() )
	{
		return GetFileAttributesExW( lpFileName, fInfoLevelId, lpFileInformation );
	}
	else
	{
		CStringA strFileName = lpFileName;	// yes, ANSI -- this only is used on Win9X systems
		return GetFileAttributesExA(strFileName, fInfoLevelId, lpFileInformation);
	}
}

void CBldFileRegFile::GetAttributes(S_ATTRIB * pattrib)
{
	if ((!m_bMatchCase) && (m_bWantActualCase))
	{
		WIN32_FIND_DATAW find;
		HANDLE hfind = ::FindFirstFileW((LPCOLESTR)m_Path, &find);

		pattrib->_fOk = TRUE;
		if (hfind != INVALID_HANDLE_VALUE)
		{
			::FindClose(hfind);

			pattrib->_filetime = find.ftLastWriteTime;
			pattrib->_fExists = TRUE;

			m_Path.SetActualCase(find.cFileName);
		}
		else
		{
			pattrib->_filetime.dwLowDateTime = pattrib->_filetime.dwHighDateTime = 0;	// none
			pattrib->_fExists = FALSE;
		}
	}
	else
	{
		WIN32_FILE_ATTRIBUTE_DATA find;

		pattrib->_fOk = TRUE;
		if (OGetFileAttributesExW( (LPCOLESTR)m_Path, GetFileExInfoStandard, &find))
		{
			pattrib->_filetime = find.ftLastWriteTime;
			pattrib->_fExists = TRUE;
		}
		else
		{
			pattrib->_filetime.dwLowDateTime = pattrib->_filetime.dwHighDateTime = 0;	// none
			pattrib->_fExists = FALSE;
		}
	}
}

void CBldFileRegFile::SetMatchCase(BOOL bMatchCase, BOOL bCaseApproved /*=FALSE*/)
{
	if (!bCaseApproved && (!m_bMatchCase && bMatchCase))
 		m_Path.GetActualCase(FALSE);

	m_bWantActualCase = bMatchCase;
	m_bMatchCase = bMatchCase;
}

BOOL CBldFileRegFile::UpdateAttributes()
{
 	return CBldFileRegEntry::UpdateAttributes();
}

/////////////////////////////////////////////////////////////////////////////
//
//	CBldFileRegistry

CBldFileRegistry::CBldFileRegistry(CBldCfgRecord* pCfgRecord, int nHashSize) : CBldFileRegSet(nHashSize)
{
	m_dwNodeType = nodetypeRegEntry | nodetypeRegSet | nodetypeRegNotifyRx | nodetypeRegRegistry;

	// Set up the file registry pointer
	m_pFileRegistry = this;

	// We must have a contents map because we use it for reference counting.
	m_pmapContents = new CVCMapPtrToWord;
	m_pmapContents->InitHashTable(nHashSize, FALSE);	// set hash size as requested
}

CBldFileRegistry::~CBldFileRegistry()
{
	VSASSERT(IsEmpty(), "File registry should be empty by d'tor time!");

	// Remove filters.
	VCPOSITION pos0 = m_FilterMap.GetStartPosition();
	while (NULL != pos0)
	{
		BldFileRegHandle frh0;
		CStringW strKey;
		m_FilterMap.GetNextAssoc(pos0, strKey, (void*&)frh0);
		if (frh0->IsNodeType(nodetypeRegFilter))
			delete frh0;
		else if (frh0->IsNodeType(nodetypeRegFilterSet))
			delete frh0;
		else
		{
			// Must be a CBldFileRegFilter or CBldFileRegSet containing filters.
			VSASSERT(FALSE, "Can only remove CBldFileRegFilter or CBldFileRegSet objects!");
		}
	}
}

BldFileRegHandle CBldFileRegistry::RegisterFile
(
	const CPathW* pPath,
	BOOL bMatchCase /* = TRUE */,
	BOOL bNoFilter /* = TRUE */
)
{
	if (!pPath->IsInit())
	{
		VSASSERT(FALSE, "Path must be initialized before file can be registered!");		// caller shouldn't allow this
		return (BldFileRegHandle)NULL;	// can't do
	}

	// Lookup file in the global file registry thing.  If it's there then, get its BldFileRegHandle.
	// Otherwise, create a new CBldFileRegFile item and get its BldFileRegHandle.
	BldFileRegHandle hndFileReg = NULL;

	hndFileReg = CBldFileRegFile::GetFileHandle(*pPath, !pPath->IsActualCase());
	if (NULL != hndFileReg)
	{
		AddRegRef(hndFileReg, bNoFilter);
		hndFileReg->SetMatchCase(bMatchCase, TRUE /* case already approved */);
		hndFileReg->ReleaseFRHRef();
	}

	return hndFileReg;
}

void CBldFileRegistry::AddRegRef(BldFileRegHandle hndFileReg, BOOL bNoFilter /* = FALSE */)
{
	VSASSERT(m_pmapContents != NULL, "Our map is NULL!");

	WORD wRefCount = 0;
	BOOL bFound = m_pmapContents->Lookup(hndFileReg, wRefCount);

	if (!bFound)
	{
		// Add to registry.
		// AddRegHandle takes care of actual ref counts on hndFileReg.
		AddRegistryHandle(hndFileReg, NULL, bNoFilter);
		wRefCount = 0;
	}

	wRefCount++;
	m_pmapContents->SetAt(hndFileReg, wRefCount);
}

void CBldFileRegistry::ReleaseRegRef(BldFileRegHandle hndFileReg, BOOL bNoFilter /* = FALSE */)
{
	VSASSERT(hndFileReg, "Cannot release NULL frh!");
	if (!hndFileReg)
		return; // just bail

	WORD wRefCount;
	VSASSERT(m_pmapContents != NULL, "Our map was not initialized!");
	VSASSERT(m_pmapContents->Lookup(hndFileReg, wRefCount), "Trying to release an frh that is already gone!");

	if (!m_pmapContents->Lookup(hndFileReg, wRefCount))
		wRefCount = 0;

	VSASSERT(0 != wRefCount, "Releasing the last refcount too early!");

	if (wRefCount != 0)
 		wRefCount--;

	// Prevent access to registry by other threads.
	CritSectionT cs(g_sectionRegistryFull);

	if (wRefCount != 0)
	{
		m_pmapContents->SetAt(hndFileReg, wRefCount);
		if (bNoFilter && hndFileReg->IsNodeType(nodetypeRegFile))
		{
			// Remove from filters.
			UnFilterFile(hndFileReg);
		}
	}
	else
	{
		m_pmapContents->RemoveKey(hndFileReg);

		// RemoveRegHandle takes care of actual ref counts on hndFileReg.
		RemoveRegistryHandle(hndFileReg);
	}
}

BldFileRegHandle CBldFileRegistry::FindBasicFilter(const CStringW* pstrBasicFilter)
{
	// Find a basic file filter
	BldFileRegHandle hndFileFilter;

	if (m_FilterMap.Lookup(*pstrBasicFilter, (void*&)hndFileFilter))
		return hndFileFilter;

	return NULL;
}

BldFileRegHandle CBldFileRegistry::RegisterFileFilter(const CStringW* pstrFilter)
{
	BldFileRegHandle hndFileReg;

	hndFileReg = LookupFileFilter(pstrFilter);

	// Are we trying to register a file filter that has already been registered?
	if (hndFileReg)
	{
		hndFileReg->AddFRHRef();
		return hndFileReg;
	}

	CVCStringWList BasicFilters;
	GetBasicFilters(pstrFilter, BasicFilters);

	if (BasicFilters.GetCount() > 1)
	{
		// Create the set
		hndFileReg = (BldFileRegHandle) new CBldFileRegFilterSet;
		hndFileReg->AddFRHRef();
 
		// Multiple file filter
		CVCPtrList NewFilters;

		BldFileRegHandle hndFileFilter;
		VCPOSITION pos = BasicFilters.GetHeadPosition();
		while (pos != NULL)
		{
			CStringW strBasicFilter = BasicFilters.GetNext(pos);
			hndFileFilter = FindBasicFilter(&strBasicFilter);
			if (hndFileFilter == NULL)
			{
				hndFileFilter = RegisterFileFilter(&strBasicFilter);
				hndFileFilter->ReleaseFRHRef();
 			}

			((CBldFileRegFilterSet*)hndFileReg)->AddFilter((CBldFileRegFilter*)hndFileFilter);
 		}
 	}
	else
	{
		// Single basic file filter
		// First we had better check to see if we actually have created a
		// file filter like this, but it is not registered.
		CStringW strKey = BasicFilters.GetHead();
		hndFileReg = FindBasicFilter(&strKey);
		if (hndFileReg == NULL)
		{
 			// Nope, we don't have one so now we create it and set an entry in our map.
			hndFileReg = (BldFileRegHandle)new CBldFileRegFilter(strKey);
			hndFileReg->AddFRHRef();
 
			// Filter all files through this file filter
			CStringW strFileKey;
			BldFileRegHandle hndFile;
			VCPOSITION pos = m_Contents.GetHeadPosition();
			while (pos != NULL)
			{
				hndFile = (BldFileRegHandle)m_Contents.GetNext(pos);
				VSASSERT(NULL != hndFile, "Found NULL frh in content list!");
				if (hndFile->IsNodeType(nodetypeRegFile))
					((CBldFileRegFilter*)hndFileReg)->AddFilterHandle(hndFile);
			}
		}
		else
		{
			VSASSERT(FALSE, "FindBasicFilter() should not succeed after LookupFileFilter() failed.");
		}
	}

	// Put an entry in our registered file filter map
	CStringW strKey = *pstrFilter;
	strKey.MakeUpper();
 	m_FilterMap.SetAt(strKey, hndFileReg);

	return hndFileReg;
}

BOOL CBldFileRegistry::RemoveFileFilter(const CStringW* pstrFilter)
{
	// We can only remove file filters that have been registered
	BldFileRegHandle hndFileReg;

	CStringW strKey = *pstrFilter;
	strKey.MakeUpper();

 	if (!m_FilterMap.Lookup(strKey, (void*&)hndFileReg))
 		return FALSE;

 	if (!hndFileReg->IsNodeType(nodetypeRegFilter))
	{
		VSASSERT(hndFileReg->IsNodeType(nodetypeRegSet), "Can only call RemoveFileFilter on filters and regsets!");
 		CBldFileRegSet* hndFileSet = (CBldFileRegSet*)hndFileReg;

		const CVCPtrList* pFilterList = &hndFileSet->m_Contents;

		VCPOSITION pos = pFilterList->GetHeadPosition();
		while (pos != NULL)
		{
			BldFileRegHandle hndFileRegFilter = (BldFileRegHandle) pFilterList->GetNext(pos);
			VCPOSITION posFilter = m_Contents.Find(hndFileRegFilter);
			if (NULL != posFilter)
			{
				hndFileSet->m_Contents.RemoveAt(posFilter);
				hndFileRegFilter->ReleaseFRHRef();
			}
		}
 	}

	m_FilterMap.RemoveKey(strKey);

	hndFileReg->ReleaseFRHRef();
	return TRUE;
}

BldFileRegHandle CBldFileRegistry::LookupFile(LPCOLESTR lpszFile, BOOL bVerifyCase)
{
	BldFileRegHandle hndFileReg = CBldFileRegFile::GetFileHandle(lpszFile, bVerifyCase);
	if (NULL != hndFileReg)
	{
		if (!RegHandleExists(hndFileReg))
		{
			hndFileReg->ReleaseFRHRef();
			hndFileReg = NULL;
		}
	}

	return hndFileReg;
}

BldFileRegHandle CBldFileRegistry::LookupFile(const CPathW* pPath, BOOL bVerifyCase)
{
	VSASSERT(pPath->IsInit(), "Path not initialized before use!");
	if (bVerifyCase)
		bVerifyCase = !pPath->IsActualCase();
	return CBldFileRegistry::LookupFile(LPCOLESTR(*pPath), bVerifyCase);
}

BldFileRegHandle CBldFileRegistry::LookupFileFilter(const CStringW* pstrFilter)
{
	// Create a list of the basic file filters
 	CVCStringWList BasicFilters;

	GetBasicFilters(pstrFilter, BasicFilters);

	// FUTURE (colint): NYI
 	// Generate permutations of the basic file filters
	CVCStringWList Permutations;

	// FUTURE (colint): For now we just add one of the permutations
	CStringW strTempPerm= *pstrFilter;
	strTempPerm.MakeUpper();
	Permutations.AddTail(strTempPerm);

	// Lookup each of the permutations
	BldFileRegHandle hndFileReg;

	VCPOSITION pos = Permutations.GetHeadPosition();
	while (pos != NULL)
	{
		CStringW strKey = Permutations.GetNext(pos);
		if (m_FilterMap.Lookup(strKey, (void*&)hndFileReg))
			return hndFileReg;
	}

 	return NULL;
}

void CBldFileRegistry::GetBasicFilters(const CStringW* pstrFilter, CVCStringWList& strList)
{  		 
	CStringW strKey = *pstrFilter;
	strKey.MakeUpper();
	strKey += L";";

	int nBreak = -1;
	do
	{
		nBreak = strKey.Find(L';');
		if (nBreak != -1)
		{
			CStringW strBasicFilter = strKey.Left(nBreak);
			strList.AddTail(strBasicFilter);
			strKey = strKey.Right(strKey.GetLength() - nBreak - 1);
		}
	} while (nBreak != -1);
}

void CBldFileRegistry::FilterFile(BldFileRegHandle hndFile)
{
	VSASSERT(hndFile->IsNodeType(nodetypeRegFile), "Can only filter files!");

	// Notify all file filters that we have in the registry at the moment.
	VCPOSITION pos = m_FilterMap.GetStartPosition();
	while (pos != NULL)
	{
		BldFileRegHandle hndFileReg;
		CStringW strFile;
		m_FilterMap.GetNextAssoc(pos, strFile, (void*&)hndFileReg);
		if (hndFileReg->IsNodeType(nodetypeRegFilter))
			((CBldFileRegFilter*)hndFileReg)->AddFilterHandle(hndFile);
	}
}

void CBldFileRegistry::UnFilterFile(BldFileRegHandle hndFile)
{
	VSASSERT(hndFile->IsNodeType(nodetypeRegFile), "Can only unfilter files!");

	// Notify all file filters that we have in the registry at the moment.
	VCPOSITION pos = m_FilterMap.GetStartPosition();
	while (pos != NULL)
	{
		BldFileRegHandle hndFileReg;
		CStringW strFile;
		m_FilterMap.GetNextAssoc(pos, strFile, (void*&)hndFileReg);
		if (hndFileReg->IsNodeType(nodetypeRegFilter))
			((CBldFileRegFilter*)hndFileReg)->RemoveFilterHandle(hndFile);
	}
}

void CBldFileRegistry::OnNotify(BldFileRegHandle hndFileReg, IVCBuildErrorContext* pEC, UINT idChange, void* pHint)
{
	VSASSERT(hndFileReg, "Bad input parameter!");
	
	switch (idChange)
	{
		// Take care of references counts.
		// (Add/Release)RegRef() will do the work.
		case FRI_ADD:
		{
			CBldFileRegSet* pregset = (CBldFileRegSet*)hndFileReg;
			VSASSERT(pregset->IsNodeType(nodetypeRegSet), "Can only add to regsets!");
			VSASSERT(!pregset->IsNodeType(nodetypeRegRegistry), "Don't use OnNotify to add to a registry!");
			VSASSERT(this == pregset->m_pFileRegistry, "Registry mismatch between what's passed in and us!");

			CBldFileRegEntry* regent = (CBldFileRegEntry*)pHint;
			AddRegRef(regent);
			break;
		}
		case FRI_DESTROY:
		{
			CBldFileRegSet* pregset = (CBldFileRegSet*)hndFileReg;
			VSASSERT(pregset->IsNodeType(nodetypeRegSet), "Can only remove from regsets!");
			VSASSERT(!pregset->IsNodeType(nodetypeRegRegistry), "Don't use OnNotify to remove from a registry!");
			VSASSERT(this == pregset->m_pFileRegistry, "Registry mismatch between what's passed in and us!");

			CBldFileRegEntry* regent = (CBldFileRegEntry*)pHint;
			ReleaseRegRef(regent);
			break;
		}
	}
}

BOOL CBldFileRegistry::DeleteFile(BldFileRegHandle hndFileReg)
{
	VSASSERT(hndFileReg, "Cannot delete NULL frh!");
	VSASSERT(hndFileReg->IsNodeType(nodetypeRegFile), "Can only call DeleteFile for files!");

	const CPathW * pPath = ((CBldFileRegFile*)hndFileReg)->GetFilePath();
 	VSASSERT(pPath != (const CPathW *)NULL, "No path for our file!");

	// Prevent access to DeleteFile by other threads.
	CritSectionT cs(g_sectionFileDelete);

	BOOL fRet = ::DeleteFileW((const wchar_t*)*pPath);

	if (fRet)
	{
		// it's gone, let's assume this and set the attributes
		S_ATTRIB attrib;
		attrib._fOk = TRUE;
		attrib._filetime.dwLowDateTime = attrib._filetime.dwHighDateTime = 0;	// none
		attrib._fExists = FALSE;

		((CBldFileRegFile*)hndFileReg)->SetAttributes(&attrib);
	}

	return fRet;
}

void CBldFileRegistry::RemoveFromProject(IVCBuildableItem* pItem, BOOL fRemoveContained)
{
	// do we have a file reghandle to remove?
	BldFileRegHandle hndFileReg = NULL;
	pItem->get_FileRegHandle((void **)&hndFileReg);
	if (hndFileReg != (BldFileRegHandle)NULL)
	{
		CBldFileRegEntry* pRegEntry = GetRegEntry(hndFileReg); 
		VSASSERT(pRegEntry, "Item not in registry.  Must have been released too early somewhere else.");
		if (this != &g_FileRegistry)
			ReleaseRegRef(pRegEntry);
	}

	// remove all our children?
	CComPtr<IEnumVARIANT> spContentList;
	if (fRemoveContained && pItem->get_ContentList(&spContentList) == S_OK && spContentList != NULL)
	{
		CBldFileRegistry* pThisRegistry = NULL;
		if (SUCCEEDED(pItem->get_Registry((void **)&pThisRegistry)) && pThisRegistry != NULL)
		{
			spContentList->Reset();
			while (TRUE)
			{
				CComVariant var;
				HRESULT hr = spContentList->Next(1, &var, NULL);
				if (hr != S_OK)
					break;
				if (var.vt != VT_DISPATCH && var.vt != VT_UNKNOWN)
					continue;
				IDispatch* pDispContained = var.pdispVal;
				CComQIPtr<IVCBuildableItem> spContained = pDispContained;
				if (spContained == NULL)
					continue;

				pThisRegistry->RemoveFromProject(spContained, fRemoveContained);
			}
		}
	}
}
	
void CBldFileRegistry::RestoreToProject(IVCBuildableItem* pItem, BOOL fRestoreContained)
{
	// do we have a file reghandle to restore?
	BldFileRegHandle hndFileReg = NULL;
	pItem->get_FileRegHandle((void **)&hndFileReg);
	if (hndFileReg != (BldFileRegHandle)NULL)
	{
#ifdef _DEBUG
		CBldFileRegEntry *pRegEntry = GetRegEntry(hndFileReg); VSASSERT(pRegEntry, "Failed to find a reg entry for our file!");
#endif
		if (this != &g_FileRegistry)
			AddRegRef(hndFileReg, TRUE);	// no filtering here...
	}

	// restore all our children?
	CComPtr<IEnumVARIANT> spContentList;
	if (fRestoreContained && pItem->get_ContentList(&spContentList) == S_OK && spContentList != NULL)
	{
		CBldFileRegistry* pThisRegistry = NULL;
		if (SUCCEEDED(pItem->get_Registry((void **)&pThisRegistry)) && pThisRegistry != NULL)
		{
			spContentList->Reset();
			while (TRUE)
			{
				CComVariant var;
				HRESULT hr = spContentList->Next(1, &var, NULL);
				if (hr != S_OK)
					break;
				if (var.vt != VT_DISPATCH && var.vt != VT_UNKNOWN)
					continue;
				IDispatch* pDispContained = var.pdispVal;
				CComQIPtr<IVCBuildableItem> spContained = pDispContained;
				if (spContained == NULL)
					continue;

				pThisRegistry->RestoreToProject(spContained, fRestoreContained);
			}
		}
	}
}

//
// New CBldFileRegistry functions.
//

BOOL CBldFileRegistry::AddRegistryHandle(BldFileRegHandle hndFileReg, IVCBuildErrorContext* pEC /* = NULL */, BOOL bNoFilter /* = FALSE */)
{
	VSASSERT(hndFileReg, "Trying to add a NULL frh!");

	// Shouldn't be adding again.
	VSASSERT(!RegHandleExists(hndFileReg), "Trying to add a reg handle more than once!");
	VSASSERT(!hndFileReg->IsNodeType(nodetypeRegRegistry), "Cannot call AddRegistryHandle with a registry!");
	VSASSERT(!hndFileReg->IsNodeType(nodetypeRegFilter), "Cannot call AddRegistryHandle with a filter!");

	// Already exists in set....return
	if (RegHandleExists(hndFileReg))
		return TRUE;

	// Reference held by this file set.
	hndFileReg->AddFRHRef();

	// This may result in new dependency update requests, so we must not be locking
	// the lists at this time.
	VSASSERT(!g_sectionDepUpdateQ.FOwned(), "List locked at a bad time!");

	// Is the CBldFileRegEntry a CBldFileRegSet if so then we must
	// set up the associated file registry...
	CBldFileRegSet* pFileRegSet = (CBldFileRegSet *)hndFileReg;

	if (pFileRegSet->IsNodeType(nodetypeRegSet))
		pFileRegSet->SetFileRegistry(this);

	{
		// Prevent access to registry by other threads.
		CritSectionT cs(g_sectionRegistryFull);

		// Add the CBldFileRegEntry to the registry.
		m_Contents.AddTail(hndFileReg);
	}

	// Add files to file map.
	if (!bNoFilter && pFileRegSet->IsNodeType(nodetypeRegFile))
	{
		// Filter file.
		FilterFile(hndFileReg);
	}

	InformNotifyRxs(FRI_ADD, pEC, (void *)hndFileReg);
 	
	return TRUE;
}

BOOL CBldFileRegistry::RemoveRegistryHandle(BldFileRegHandle hndFileReg, IVCBuildErrorContext* pEC /* = NULL */)
{
	// If the item being destroyed is still in us then remove it.
	VCPOSITION pos = m_Contents.Find(hndFileReg);
	VSASSERT(NULL != pos, "Failed to find the frh we're trying to remove!");
	if (NULL == pos)
		return FALSE;

	// Notify dependents this handle is being destroyed.
	InformNotifyRxs(FRI_DESTROY, pEC, (void *)hndFileReg);

	// Is the CBldFileRegEntry a CBldFileRegSet? If so, then we must set up the associated file registry...
	CBldFileRegSet* pFileRegSet = (CBldFileRegSet *)hndFileReg;

	if (pFileRegSet->IsNodeType(nodetypeRegSet))
		pFileRegSet->SetFileRegistry(NULL);

	{
		// Prevent access to registry by other threads.
		CritSectionT cs(g_sectionRegistryFull);
		m_Contents.RemoveAt(pos);
	}

	if (pFileRegSet->IsNodeType(nodetypeRegFile))
	{
		// Remove from filters.
		UnFilterFile(hndFileReg);
	}

	// Release reference held by this file set.
	hndFileReg->ReleaseFRHRef();

	return TRUE;
}

///////////////////////////////////////////////////////////////////////////////
//
//	Instantiate the file registry

CBldFileRegistry g_FileRegistry;

///////////////////////////////////////////////////////////////////////////////
//
//	Special collection class for dependency lists.

void CSmallPtrSet::RemoveItem(void *pItem)
{
	for (int i = 0; i < m_nSize; i++)
	{
		if (m_pData[i] == pItem)
		{
			RemoveAt(i);
			break;		// only once
		}
	}
}

int CSmallPtrSet::Find(void const * const pItem)
{
	for (int i = 0; i < m_nSize; i++)
	{
		if (m_pData[i] == pItem)
			return i;
	}

	return -1;
}

//
// Slow GetFileAttributesEx for operating systems that do not support it.
//
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\vcpb\fileregistry.h ===
#ifndef __FILEREGISTRY_H__
#define __FILEREGISTRY_H__

#pragma once

#include <vccolls.h>
#include "path2.h"

extern CTestableSection g_sectionRegistrySingle;

///////////////////////////////////
// classes in this header
///////////////////////////////////
class CBldFileRegNotifyRx;
	class CBldFileRegEntry;
		class CBldFileRegSet;
			class CBldFileRegFilter;
			class CBldFileRegFilterSet;
			class CBldFileRegistry;
		class CBldFileRegFile;

class CSmallPtrSet;

// classes needed by this header
class CBldCfgRecord;

//
// inline replacement for ::CompareFileTime (takes references instead of pointers).
//
__inline int CompareFileTimes( const struct _FILETIME& ft1, const struct _FILETIME& ft2 )
{
	if (ft1.dwHighDateTime == ft2.dwHighDateTime)
	{
		if (ft1.dwLowDateTime == ft2.dwLowDateTime)
			return 0;
		else if (ft1.dwLowDateTime > ft2.dwLowDateTime)
			return 1;
		else
			return -1;
	}
	else if (ft1.dwHighDateTime > ft2.dwHighDateTime)
		return 1;
	else
		return -1;
}

/////////////////////////////////////////////////////////////////////////////
// BldFileRegHandle definition. All access to file registry entries is done
// using a handle. Currently this handle is just a pointer to the entry
// but this may change and so EVERYONE should use handles to refer to
// file registry entries. The file registry has a function to map from
// a BldFileRegHandle to a real file registry entry.
typedef CBldFileRegEntry * BldFileRegHandle;

// Typed array of CFileRefFile pointers.
typedef CVCTypedPtrArray<CVCPtrArray, class CBldFileRegEntry *> CFRFPtrArray;

/////////////////////////////////////////////////////////////////////////////
// Queue and dequeue our file registry entry changes.

typedef struct 
{
	BldFileRegHandle	_frh;		// file registry handle
	BOOL			_fOk;		// ok?
	FILETIME		_filetime;	// last write time
	BOOL			_fExists;	// exists?
	BOOL			_fInSccOp;	// SCC op in progress at the time?
} S_ATTRIB;

/////////////////////////////////////////////////////////////////////////////
// Standard file registry notifications

#define		FRN_ALL			0x2
#define		FRI_DESTROY		0x3
#define		FRI_ADD			0x4

/////////////////////////////////////////////////////////////////////////////
// File registry property identifiers

#define		P_NewTStamp		11
#define		P_ExistsOnDisk	12

/////////////////////////////////////////////////////////////////////////////
//
//	CBldFileRegNotifyRx. This class provides support for file registry
//	notification receiving. Basically any class that is interested in
//	being able to receive notifications about changes in the file
//	registry should derive from this. NOTE: Multiple inheritance is
//	possible, for an example take a look at the CBldFileRegEntry class
//	below. 

class CBldFileRegNotifyRx
{
public:
	virtual void	OnNotify(BldFileRegHandle hndFileReg, IVCBuildErrorContext* pEC, UINT idChange, void* pHint) = 0;
		// OnNotify is a pure virtual function, this should be overridden in
		// a derived class to handle notification from the file registry
		// about any changes

	// in order to know what type of node we have, we keep track locally so we don't
	// have to use IsKindOf which takes a bloody lot of time!
	enum
	{
		nodetypeRegNotifyRx = 0x1,
		nodetypeRegEntry = 0x2,
		nodetypeRegSet = 0x4,
		nodetypeRegFilter = 0x8,
		nodetypeRegFile = 0x10,
		nodetypeRegRegistry = 0x20,
		nodetypeRegFilterSet = 0x40,
		nodetypeRegMax = 0x80
	};
	CBldFileRegNotifyRx() : m_dwNodeType(nodetypeRegNotifyRx)
	{
	}
	BOOL	IsNodeType(DWORD dw)
	{
		return (dw & m_dwNodeType) != 0;
	}
protected:
	DWORD m_dwNodeType;		// Yes, this is a tempting target to cut memory by getting rid of
							// since it logically doesn't need to be different for every object
							// from the same derived class. DON'T TOUCH IT.  Calling into a 
							// derived class at the wrong time to get this info will crash the IDE...
};

// General-purpose class for storing a "small" set of pointers.
// This is used (& tuned) for keeping track of the dependants of a CBldFileRegEntry.
// For simplicity & tune-ability, it supports only the operations which are
// actually used by the dependency handling code.
//
class CSmallPtrSet : public CVCPtrArray
{
	// Implementation detail: POSITION is a 1-based index.
public:
	CSmallPtrSet()
		{}
	~CSmallPtrSet()
		{}
	int AddTail(void* newElement)
	{
		// To prevent heap fragmentation, make the array double its size
		// whenever it needs to grow.
		if (m_nSize > 4)
		{
			m_nGrowBy = m_nSize;
		}
		return (int) (Add(newElement));
	}
	int Find(void const * const pItem);
	void RemoveItem(void *pItem);
};

/////////////////////////////////////////////////////////////////////////////
//
//	CBldFileRegEntry. This class contains all information that the build
//	system will ever need to know about a specific file. The file registry
//	contains references to items of this class.

class CBldFileRegEntry : public CBldFileRegNotifyRx
{
public:
// Constructors/Destructors
  	CBldFileRegEntry();
	virtual ~CBldFileRegEntry();

	//
	// Override SafeDelete if asynchronous access to map is possible.
	//
	virtual void SafeDelete(){ delete this; }

	// handle our own allocations
	// we'll use our own private Win32 heap
	// and place de-alloc'ed blocks into a 
	// global list

// Update property functions 
	// return TRUE if actually performed refresh (ie. props were not current)
	virtual BOOL	RefreshAttributes() = 0;

// Notification support functions
 	virtual void	OnNotify(BldFileRegHandle hndFileReg, IVCBuildErrorContext* pEC, UINT idChange, void* pHint);
 	virtual void	InformNotifyRxs(UINT idChange, IVCBuildErrorContext* pEC, void* pHint = NULL);
	void			AddNotifyRx(CBldFileRegNotifyRx* pfre, BOOL bCheckExistence);
	void			RemoveNotifyRx(CBldFileRegNotifyRx* pfre);

// Property access functions
  	virtual BOOL	GetTimeProp(UINT idProp, FILETIME& ftime, BOOL bUpdate = TRUE) { return FALSE; }
	BOOL			GetIntProp(UINT idProp, int& nVal, BOOL bUpdate = TRUE);
 	__inline BOOL 	ExistsOnDisk(BOOL bUpdate = TRUE) { if (bUpdate) (void)UpdateAttributes(); return m_nExistsOnDisk; }
	__inline BOOL	IsMatchCase() { return m_bMatchCase; }
	virtual void	SetRelative(BOOL bRelative) {}
	virtual void	SetMatchCase(BOOL bMatchCase, BOOL bCaseApproved = FALSE) { m_bMatchCase = bMatchCase; }
 	virtual const CPathW *	GetFilePath() { return NULL; }
 	virtual BOOL	GetFileTime(FILETIME& ft) { return FALSE; }

    // Bring time stamp uptodate
    virtual BOOL    Touch() { return FALSE; }

// Reference counting functions
#ifdef _DEBUG
	// Define in fileregistry.cpp instead of inline for easier debugging.
	void AddFRHRef();
	void ReleaseFRHRef();
#else
 	__inline void 	AddFRHRef() { 	CritSectionT cs(g_sectionRegistrySingle); m_nRefCount++; }
	__inline void 	ReleaseFRHRef() { 	CritSectionT cs(g_sectionRegistrySingle); m_nRefCount--; if (m_nRefCount == 0) {SafeDelete();} }
#endif
	__inline int	GetRefCount() { return m_nRefCount; }
 
// Helper function for comparing times
	__inline static long		MyCompareFileTime(FILETIME* pTime1, FILETIME* pTime2)
	{
		return CompareFileTimes(*pTime1, *pTime2);
	}
													 
// Helper function - updates the attributes if necessary
	// return TRUE if actually changed (ie. props were updated)
	virtual BOOL		UpdateAttributes();

// Should we refresh attributes? (default is only if we are dirty)
	virtual inline BOOL DoRefresh()	{ return m_bDirty && m_bUpdateAttribs; }
	__inline void MakeDirty() { if (!m_bDirty) { m_bDirty = TRUE; InformNotifyRxs(FRN_ALL, NULL); } }

// include file dep related funcitons
	__inline void SetFileFoundInIncPath() { m_bFoundInPath = TRUE;}
	__inline BOOL IsFileFoundInIncPath() { return m_bFoundInPath;}
	__inline void SetFileNameRelativeToProj() { m_bRelativeToProjName = TRUE;}
	__inline BOOL IsFileNameRelativeToProj() { return m_bRelativeToProjName;}

protected:
// Access methods for read-only properties. These methods can only be
// called from derived classes and friends
	virtual BOOL	SetTimeProp(UINT idProp, FILETIME ftime) { return FALSE; }
	// FUTURE(karlsi): this doesn't need to be virtual
	virtual BOOL	SetIntProp(UINT idProp, int nVal);

// Dependants list
	CSmallPtrSet	m_Dependants;

// Properties - NO dependency notifications occur on these props
 	unsigned	m_nRefCount;
	BOOL		m_bMatchCase:2;

// Are we currently refreshing the entry's properties. If we are we have
// to turn off the automatic update mechanism to avoid getting into
// an infinite loop
	BOOL		m_bUpdateAttribs:2;

// Do we need to refresh our attributes
	BOOL		m_bDirty:2;

// Used for include file dependency list
	BOOL		m_bFoundInPath:2;		// this file is on in -I/INCLUDE paths
	BOOL		m_bRelativeToProjName:2;// this file is on in -I/INCLUDE paths
	BOOL		m_bUseIntDir:2;
	BOOL		m_bUseOutDir:2;
	BOOL		m_bWantActualCase:2;

// Properties - Dependency notifications occur on these props
	BOOL		m_nExistsOnDisk:2;
	 	
public:
    virtual void    DeleteFromDisk() { return; }
};

/////////////////////////////////////////////////////////////////////////////
//
// CBldFileRegSet

class CBldFileRegSet : public CBldFileRegEntry
{
	friend class CBldFileRegEntry;

public:
// Constructors/Destructors
	CBldFileRegSet(int nHashSize = 37);
	virtual ~CBldFileRegSet();

// Containment (by reference) support functions
	virtual BOOL	AddRegHandle(BldFileRegHandle hndFileReg, IVCBuildErrorContext* pEC = NULL, BOOL bAddRef = TRUE, 
		BOOL bFront = FALSE);
	virtual BOOL	RemoveRegHandle(BldFileRegHandle hndFileReg, BOOL bReleaseRef = TRUE);
	
// Exist?
	BOOL			RegHandleExists(BldFileRegHandle hndFileReg) const
	{
		WORD w;
		if( m_pmapContents != NULL )
		{
			BOOL b;
			b = m_pmapContents->Lookup((void *)hndFileReg, w);
			return b;
		}
		else
		{
			BOOL b;
			b = ( m_Contents.Find((void *)hndFileReg) != NULL );
			return b;
		}
	}

// Return the contents list
	// GetContents is no longer exposed.
	__inline BOOL IsEmpty() { return m_Contents.IsEmpty(); }
	__inline int GetCount() { return (int) m_Contents.GetCount(); }
	__inline BldFileRegHandle GetFirstFrh()
	{
		BldFileRegHandle frh = NULL;
		if (!m_Contents.IsEmpty())
		{
			frh = (BldFileRegHandle)m_Contents.GetHead();
			VSASSERT (NULL!=frh, "First element of registry is NULL");
			frh->AddFRHRef();
		}
		return frh;
	}
	virtual void				EmptyContent(BOOL fReleaseRef = TRUE);
	void MakeContentsDirty(CBldFileRegistry* pRegistry);

	// Friend access needed for m_Contents.
	friend BOOL QuickNDirtyRegSetCompare(CBldFileRegSet * pregSet, CBldFileRegSet * pregSet2);
	friend class CBldFileRegistry;

	// Reluctantly added since 
	friend class CBldFileDepGraph;

// Update property functions 
	// return TRUE if actually performed refresh (ie. props were not current)
	virtual BOOL	RefreshAttributes();

// Should we refresh attributes? (ask each of our content in turn...)
	virtual BOOL	DoRefresh();

// Helper function - updates the attributes if necessary
	// return TRUE if actually changed (ie. props were updated)
	virtual BOOL	UpdateAttributes();

// Incr. update of properties?
	BOOL	CalcAttributes(BOOL fOn = TRUE);

// Notification support function
	virtual void	OnNotify(BldFileRegHandle hndFileReg, IVCBuildErrorContext* pEC, UINT idChange, void* pHint);

// Property Access functions
   	virtual BOOL	GetTimeProp(UINT idProp, FILETIME& ftime, BOOL bUpdate = TRUE);

// Touch contents of file set
    virtual BOOL    Touch();
	 
// Recursive enumerate containment and return non-sets
	void			InitFrhEnum();
	BldFileRegHandle 	NextFrh();

	// Works differently for new reference count model.
	void SetFileRegistry(CBldFileRegistry* pFileRegistry);

protected:

// Access methods for read-only properties. These methods can only be
// called from derived classes and friends
	virtual BOOL	SetTimeProp(UINT idProp, FILETIME ftime);

// Internal helper function for finding the new/old times of the files
// in this set.  Also combines functionally of FindExists().
	// This function will ensure that all props. are updated
	// for each of our contents
	void 			FindTimeAndExists(UINT idProp, BOOL bFindExists = FALSE);

// Internal helper function for finding the number of files that exist
	// This function will ensure that all props. are updated
	// for each of our contents
	void			FindExists();

public:
// Internal (no checks == faster)  internal equivalents
// RemoveRegHandleI() used by ::EmptyContent()
	virtual void RemoveRegHandleI(BldFileRegHandle hndFileReg, IVCBuildErrorContext* pEC = NULL, BOOL bReleaseRef = TRUE);

// Remove contents from disk
    virtual void    DeleteFromDisk();

// Map providing a quick lookup into our content (also used by CBldFileRegistry objects
// to maintain ref. count).  This pointer is NULL if no map is being maintained.
	CVCMapPtrToWord	*m_pmapContents;
	enum { cMapThreshold = 8 };			// no map until there are at least # items

protected:
// Properties - Dependency notifications occur on these props
	FILETIME		m_NewTime;

	enum { nContentsBlockSize = 10 };
 	CVCPtrList		m_Contents;			// Containment list
	unsigned short	m_nHashSizeMapContents;
	unsigned short	m_nNotExists;		// Numb. of contained items that do not exist on disk
	CBldFileRegistry *	m_pFileRegistry;	// The file registry associated with us.

private:
	// Used by the enumerator
	VCPOSITION m_posEnum;

public:
// Calculate attributes?
	BOOL m_bSkipUpdate;
	BOOL m_fCalcAttrib:2;

private:
	BOOL m_fInitSet:2;
};

/////////////////////////////////////////////////////////////////////////////
//
// CBldFileRegFilter

class CBldFileRegFilter : public CBldFileRegSet
{
public:
// Constructors/Destructors
	CBldFileRegFilter(CStringW strFilter);
	virtual ~CBldFileRegFilter();
 
// Containment (by reference) support functions
	virtual BOOL	AddRegHandle(BldFileRegHandle hndFileReg, IVCBuildErrorContext* pEC = NULL, BOOL bAddRef = TRUE, 
		BOOL bFront = FALSE);
	virtual BOOL	RemoveRegHandle(BldFileRegHandle hndFileReg, BOOL bReleaseRef = TRUE);

	BOOL AddFilterHandle(BldFileRegHandle hndFileReg);
	BOOL RemoveFilterHandle(BldFileRegHandle hndFileReg);

protected:
// Internal pattern matching function
	BOOL			Filter(const wchar_t* pszText);

// Properties - NO dependency notifications occur on these props
	CStringW		m_strFilter;
	CStringW		m_strFilterLC;
};

/////////////////////////////////////////////////////////////////////////////
//
// CBldFileRegFilterSet
//		This class represents a compound filter that contains the union of 2 or more
//		CBldFileRegFilter's
//

class CBldFileRegFilterSet : public CBldFileRegSet
{
public:
	CBldFileRegFilterSet();
	virtual ~CBldFileRegFilterSet();

	virtual void OnNotify(BldFileRegHandle hndFileReg, IVCBuildErrorContext* pEC, UINT idChange, void* pHint);
	BOOL AddFilter( CBldFileRegFilter* pFilter );

private:
	// Keep track of contained CBldFileRegFilter's.
	CVCPtrList m_FilterList;
};

/////////////////////////////////////////////////////////////////////////////
//
//	CBldFileRegistry. A file registry provides an indexed way to access CBldFileRegEntry items.

class CBldFileRegistry : public CBldFileRegSet
{
public:
// Constructors/Destructors
	CBldFileRegistry(CBldCfgRecord* pCfgRecord = NULL, int nHashSize = 911);
	virtual ~CBldFileRegistry();
 
// Registration functions
	BldFileRegHandle	RegisterFile(const CPathW* pPath, BOOL bMatchCase = TRUE, BOOL bNoFilter = TRUE);
	BldFileRegHandle	RegisterFileFilter(const CStringW* pstrFilter);

// Filter the file handle (only use if RegisterFile() with fNoFilter == TRUE)
	void 			FilterFile(BldFileRegHandle hndFileReg);
	void 			UnFilterFile(BldFileRegHandle hndFileReg);

// Removal functions
 	BOOL			RemoveFileFilter(const CStringW* pstrFilter);

// Reference counting functions
	void			AddRegRef(BldFileRegHandle hndFileReg, BOOL bNoFilter = FALSE);
	void			ReleaseRegRef(BldFileRegHandle hndFileReg, BOOL bNoFilter = FALSE);

// Search functions
	BldFileRegHandle	LookupFile(const CPathW* pPath, BOOL bVerifyCase = TRUE); 
	BldFileRegHandle	LookupFile(LPCOLESTR lpszFile, BOOL bVerifyCase = TRUE);
	BldFileRegHandle	LookupFileFilter(const CStringW* pstrFilter);

// Map a BldFileRegHandle to a CBldFileRegEntry pointer
	__inline CBldFileRegEntry*	GetRegEntry(BldFileRegHandle hndFileReg) { return hndFileReg; }

// Notification support function
	virtual void	OnNotify(BldFileRegHandle hndFileReg, IVCBuildErrorContext* pEC, UINT idChange, void* pHint);

	virtual BOOL	AddRegHandle(BldFileRegHandle hndFileReg, IVCBuildErrorContext* pEC = NULL, BOOL bAddRef = TRUE, 
		BOOL bFront = FALSE)
					{ VSASSERT(FALSE, "AddRegHandle is a required override!"); return FALSE; }
	virtual BOOL	RemoveRegHandle(BldFileRegHandle hndFileReg, BOOL bReleaseRef = TRUE)
					{ VSASSERT(FALSE, "RemoveRegHandle is a required override!"); return FALSE; }

// Property Access functions
	void			RemoveFromProject(IVCBuildableItem* pItem, BOOL fRemoveContained = TRUE);
	void			RestoreToProject(IVCBuildableItem* pItem, BOOL fRestoreContained = TRUE);

// Deleting file function
 	BOOL			DeleteFile(BldFileRegHandle hndFileReg);

private:
// Map to go quickly from a string to a BldFileRegHandle
	CVCMapStringWToPtr	m_FilterMap;

// Internal File filter support functions
	void 			GetBasicFilters(const CStringW* pstrFilter, CVCStringWList& strList);
	BldFileRegHandle	FindBasicFilter(const CStringW* pstrBasicFilter);

private:
	BOOL AddRegistryHandle(BldFileRegHandle hndFileReg, IVCBuildErrorContext* pEC = NULL, BOOL bNoFilter = FALSE);
	BOOL RemoveRegistryHandle(BldFileRegHandle hndFileReg, IVCBuildErrorContext* pEC = NULL);
};

/////////////////////////////////////////////////////////////////////////////
//
// CBldFileRegFile

class CBldFileRegFile : public CBldFileRegEntry
{
// Constructors/Destructors
private:
	CBldFileRegFile(const CPathW* pPath, BOOL bMatchCase = FALSE, BOOL bFiltered = TRUE);
public:
	virtual ~CBldFileRegFile();

	//
	// Override SafeDelete if asynchronous access to map is possible.
	//
	virtual void SafeDelete();

	enum { MaxKeyLen = _MAX_PATH };
	static BldFileRegHandle GetFileHandle(LPCOLESTR szFileName, BOOL bVerifyCase = TRUE);
	static BldFileRegHandle LookupFileHandleByName(LPCOLESTR szFileName, BOOL bVerifyCase = TRUE);
	static BldFileRegHandle LookupFileHandleByKey(LPCOLESTR szKeyName);
	static void UpdateTimeStampTick();
	class CInitMap {
	public:
		CInitMap(int nHashSize=17);
		~CInitMap();
	};
	friend class CInitMap;

// Retrieve and set the file attributes
	void			GetAttributes(S_ATTRIB *);
	void			SetAttributes(S_ATTRIB *);

// Property Access Functions
	const CPathW*	GetFilePath()
	{
		VSASSERT(0 < wcslen(m_Path.GetFullPath()), "File reg entry set up without file path.  Bad programmer, bad programmer.");
		return &m_Path;
	}

	__inline void SetIndexNameRelative(int ich) { m_ich = ich;}
	__inline int  GetIndexNameRelative() { return m_ich;}
	__inline void SetOrgName(const CStringW& strName) { if (m_pOrgName) {free(m_pOrgName);} m_pOrgName = _wcsdup((wchar_t *)(LPCOLESTR)strName);}
	__inline const wchar_t * GetOrgName() { return m_pOrgName;}

 	virtual BOOL	GetFileTime(FILETIME& ft);
 	virtual BOOL	GetTimeProp(UINT idProp, FILETIME& ftime, BOOL bUpdate = TRUE);
	virtual void	SetMatchCase(BOOL bMatchCase, BOOL bCaseApproved = FALSE);
	BOOL IsActualCase() { return (m_bMatchCase || (!m_bWantActualCase)); }

	inline void SetOutDirType(UINT type) { VSASSERT(type <= 2, "OutDir type out of bounds!"); m_bUseOutDir = (type==1); m_bUseIntDir = (type==2); }
	inline UINT GetOutDirType() { return m_bUseIntDir ? 2 : (m_bUseOutDir ? 1 : 0); }

    virtual BOOL    Touch();

// Update property functions 
	// return TRUE if actually performed refresh (ie. props were not current)
	virtual BOOL	RefreshAttributes();

// Helper function - updates the attributes if necessary
	// return TRUE if actually changed (ie. props were updated)
	virtual BOOL	UpdateAttributes();

// Special file type for Custom Build Events.
// This does not exist on disk
	BOOL			m_bFileNotOnDisk:2;

	CVCPtrList*		plstFileItems;		// == (CVCPtrList *)NULL if *not used* (empty)

protected:
// Access methods for read-only properties. These methods can only be
// called from derived classes and friends
	virtual BOOL	SetTimeProp(UINT idProp, FILETIME ftime);

// Properties - Dependency notifications occur on these props
	FILETIME	m_FileTime;

// Properties - NO dependency notifications occur on these props
	CPathW		m_Path;

	unsigned	m_ich;					// the include file name relative to path(just name without ..\)
	wchar_t *	m_pOrgName;				// keep the original include name if it contain ..\(relative path)

	DWORD		m_dwUpdateTick;			// helps us keep track of whether we've done an update lately or not

public:
	virtual void	DeleteFromDisk();

private:
	static CVCMapStringWToPtr* s_pFileNameMap;
	static CTestableSection g_sectionFileMap;
};

extern CBldFileRegistry	g_FileRegistry;

//
// Global comparision operators for FILETIME
//
__inline BOOL operator == (const struct _FILETIME& ft1, const struct _FILETIME& ft2)
{
	return (0 == CompareFileTimes(ft1,ft2));
}
__inline BOOL operator < (const struct _FILETIME& ft1, const struct _FILETIME& ft2)
{
	return (-1 == CompareFileTimes(ft1,ft2));
}
__inline BOOL operator > (const struct _FILETIME& ft1, const struct _FILETIME& ft2)
{
	return (1 == CompareFileTimes(ft1,ft2));
}
__inline BOOL operator <= (const struct _FILETIME& ft1, const struct _FILETIME& ft2)
{
	return (1 != CompareFileTimes(ft1,ft2));
}
__inline BOOL operator >= (const struct _FILETIME& ft1, const struct _FILETIME& ft2)
{
	return (-1 != CompareFileTimes(ft1,ft2));
}

#endif // __FILEREGISTRY_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\vcpb\globals.h ===
// Globals.h
// implementation of the object implementing the IVCGlobals interface
///////////////////////////////////////////////////////////////////////////

#pragma once

#ifndef _GLOBALS_H_
#define _GLOBALS_H_

#include "vccolls.h"

class ATL_NO_VTABLE CVCGlobals :
	public CComObjectRoot,
	public IVCGlobals
{
public:
	CVCGlobals();
	~CVCGlobals();
	static HRESULT CreateInstance( CVCGlobals** ppGlobals );

BEGIN_COM_MAP( CVCGlobals )
	COM_INTERFACE_ENTRY( IVCGlobals )
END_COM_MAP()

protected:
	void Initialize(IDispatch* pProjects);

public:
	// IVCGlobals
	STDMETHOD(GetValue)( BSTR bstrName, BSTR *pbstrValue );
	STDMETHOD(SetValue)( BSTR bstrName, BSTR bstrValue );
	STDMETHOD(GetPersistance)( BSTR bstrName, VARIANT_BOOL *pbPersists );
	STDMETHOD(SetPersistance)( BSTR bstrName, VARIANT_BOOL bPersists );
	STDMETHOD(SaveObject)( IStream *xml, IVCPropertyContainer *pPropCnt, long nIndent );
	STDMETHOD(GetCount)( ULONG *count );
	STDMETHOD(GetFirstItem)( BSTR *pbstrName, BSTR *pbstrValue );
	STDMETHOD(GetNextItem)( BSTR *pbstrName, BSTR *pbstrValue );

private:
	// map globals' names -> values
	CVCMapStringWToStringW m_GlobalsMap;
	// map of the names of the persisting globals
	// (globals that are not in the array do NOT persist)
	CVCMapStringWToPtr m_GlobalsPersistanceMap;
};

#endif // _GLOBALS_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\vcpb\FileConfiguration.cpp ===
// FileConfiguration.cpp : Implementation of 

#include "stdafx.h"
#include "FileConfiguration.h"
#include "BldActions.h"
#include "vctool.h"
#include "projwriter.h"

/////////////////////////////////////////////////////////////////////////////
//
HRESULT CFileConfiguration::CreateInstance(VCFileConfiguration **ppDispInfo)
{
	HRESULT hr;
	CFileConfiguration *pVar;
	CComObject<CFileConfiguration> *pObj;
	hr = CComObject<CFileConfiguration>::CreateInstance(&pObj);
	if (SUCCEEDED(hr))
	{
		pVar = pObj;
		pVar->AddRef();
		*ppDispInfo = pVar;
		//hr = pVar->Initialize(NULL, NULL);
	}
	return hr;
}

HRESULT CFileConfiguration::SetDirty(VARIANT_BOOL bDirty)
{
	CHECK_ZOMBIE(m_pFile, IDS_ERR_CFG_ZOMBIE);
	CComPtr<IDispatch> pDispProj;
	m_pFile->get_Project(&pDispProj);
	CComQIPtr<IVCProjectImpl> pProjImpl = pDispProj;
	CHECK_ZOMBIE(pProjImpl, IDS_ERR_CFG_ZOMBIE);

	return pProjImpl->put_IsDirty(bDirty);
}

STDMETHODIMP CFileConfiguration::MatchName(BSTR bstrNameToMatch, VARIANT_BOOL bFullOnly, VARIANT_BOOL *pbMatched)
{
	CHECK_POINTER_VALID(pbMatched);
	CComBSTR bstrName;
	*pbMatched = VARIANT_FALSE;
	VSASSERT(m_pConfig, "Hey, no config set!");
	CHECK_ZOMBIE(m_pConfig, IDS_ERR_CFG_ZOMBIE);

	m_pConfig->get_Name(&bstrName);
	if (!bstrName && !bstrNameToMatch)
		*pbMatched = VARIANT_TRUE;

	else if (!bstrName || !bstrNameToMatch)
		*pbMatched = VARIANT_FALSE;

	else if ( _wcsicmp(bstrName,bstrNameToMatch) == 0)
		*pbMatched = VARIANT_TRUE;

	else if (!bFullOnly)	// try matching without the platform
	{
		CStringW strName = bstrName;
		int nPos = strName.Find(L"|");
		if (nPos > 0)
			strName = strName.Left(nPos);
		if (_wcsicmp(strName,bstrNameToMatch) == 0)
			*pbMatched = VARIANT_TRUE;
	}

	return S_OK;
}

STDMETHODIMP CFileConfiguration::get_Name(BSTR *pVal)
{
	VSASSERT(m_pConfig, "Hey, no config set!");
	CHECK_ZOMBIE(m_pConfig, IDS_ERR_CFG_ZOMBIE);

	CComBSTR bstrName;
	m_pConfig->get_Name(&bstrName);
	bstrName.CopyTo(pVal);
	return S_OK;
}


STDMETHODIMP CFileConfiguration::SaveObject(IStream *xml, IVCPropertyContainer *pPropCnt, long nIndent)
{
	VSASSERT(m_pConfig, "Hey, no config!");
	CHECK_ZOMBIE(m_pConfig, IDS_ERR_CFG_ZOMBIE);

	if (!m_bIgnoreDefaultTool)	// if we have a non-default tool, always write things out
	{
		// if there is no local storage, then there is no point in writing the
		// file config or its child tool...
		VARIANT_BOOL bHaveLocalStorage = VARIANT_FALSE;
		HasLocalStorage( VARIANT_TRUE /* for save*/, &bHaveLocalStorage );
		if( bHaveLocalStorage == VARIANT_FALSE )
			return S_OK;
	}

	StartNodeHeader( xml, L"FileConfiguration", true );
	// Name
	CComBSTR bstrName;
	m_pConfig->get_Name(&bstrName);
	NodeAttribute( xml, L"Name", bstrName );

	// Excluded from build
	VARIANT_BOOL bExcludedFromBuild = VARIANT_FALSE;
	if (GetBoolProperty(VCFCFGID_ExcludedFromBuild, &bExcludedFromBuild) == S_OK 
		&& bExcludedFromBuild == VARIANT_TRUE)
	{
		CComBSTR bstrExcl = (bExcludedFromBuild == VARIANT_TRUE ? L"TRUE" : L"FALSE");
		NodeAttribute( xml, L"ExcludedFromBuild", bstrExcl );
	}

	// end of attributes, start children
	EndNodeHeader( xml, true );

	if (m_pTool)
	{
		m_pTool->SaveObject( xml, static_cast<IVCPropertyContainer *>(this), GetIndent() );
	}

	EndNode( xml, L"FileConfiguration", true );

	return S_OK;
}

STDMETHODIMP CFileConfiguration::Close()
{
	if (PROJECT_IS_LOADED() && !g_bInFileChangeMode)
		UnAssignActions(VARIANT_TRUE);

	if (m_spStagedContainer)
		m_spStagedContainer->Close();
	m_spStagedContainer.Release();

	m_pConfig = NULL;
	m_pFile = NULL;
	m_spActionList = NULL;
	if (m_pTool)
	{
		CComQIPtr<IVCToolImpl> spToolImpl = m_pTool;
		if (spToolImpl)
			spToolImpl->Close();
	}
	m_pTool = NULL;
	return S_OK;
}

STDMETHODIMP CFileConfiguration::get_Parent(IDispatch **pVal)
{
	m_pFile.QueryInterface(pVal);
	return S_OK;
}

STDMETHODIMP CFileConfiguration::get_Tool(IDispatch **pVal)
{
	CHECK_POINTER_VALID(pVal);
	*pVal = NULL;

	if (m_pTool == NULL)
	{
		// no tool yet set. See if we can get a default one...
		CComQIPtr<IVCConfigurationImpl> pConfigImpl = m_pConfig;
		HRESULT hr = S_OK;
		if (pConfigImpl)
			hr = pConfigImpl->SetDefaultToolForFile(static_cast<VCFileConfiguration *>(this));
		RETURN_ON_FAIL(hr);
	}

	if (m_pTool)
		m_pTool.QueryInterface(pVal);

	if (*pVal == NULL)
		return CVCProjectEngine::DoSetErrorInfo(VCPROJ_E_NO_TOOL, IDS_ERR_NO_TOOL);

	return S_OK;
}

HRESULT CFileConfiguration::DoSetTool(IVCToolImpl* pNewTool, BOOL bDoAssign)
{
	CHECK_OK_TO_DIRTY(VCFCFGID_Tool);

	HRESULT hr = S_OK;
	CComPtr<IVCToolImpl> spToolImpl;
	if (pNewTool != NULL)
	{
		if (m_pTool != NULL)
		{
			CComBSTR bstrOldToolShortName;
			hr = m_pTool->get_ToolShortName(&bstrOldToolShortName);
			VSASSERT(SUCCEEDED(hr), "All tools have short names!");
			RETURN_ON_FAIL(hr);
			CComBSTR bstrNewToolShortName;
			hr = pNewTool->get_ToolShortName(&bstrNewToolShortName);
			VSASSERT(SUCCEEDED(hr), "All tools have short names!");
			RETURN_ON_FAIL(hr);
			if (bstrOldToolShortName.Length() == bstrNewToolShortName.Length())
			{
				CStringW strOldToolShortName = bstrOldToolShortName;
				CStringW strNewToolShortName = bstrNewToolShortName;
				if (strOldToolShortName == strNewToolShortName)
					return S_OK;
			}
		}
		hr = pNewTool->CreateToolObject(this, &spToolImpl);
		RETURN_ON_FAIL(hr);
	}

	if (!g_bInProjLoad && bDoAssign && m_pTool != NULL)
		UnAssignActions(VARIANT_FALSE);

	CComQIPtr<IDispatch> spDispTool = spToolImpl;
	if (m_pTool != NULL)
	{
		m_pTool->Close();
		m_pTool.Release();
	}
	m_pTool = spDispTool;

	if (!g_bInProjLoad && bDoAssign)
		AssignActions(VARIANT_FALSE);

	if (bDoAssign)	// came in as an explicit set, so need to figure out whether this is default tool or not
	{
		CComQIPtr<VCFile> spFile = m_pFile;
		if (spFile != NULL)
		{
			CComBSTR bstrName;
			if (SUCCEEDED(spFile->get_Name(&bstrName)))
			{
				CStringW strName = bstrName;
				if (!strName.IsEmpty())
				{
					int i = strName.ReverseFind(L'.');
					if (i > 0)
					{
						strName = strName.Mid(i);
						if (m_pTool)
						{	
							VARIANT_BOOL bIsTargetTool = VARIANT_FALSE;
							hr = m_pTool->IsTargetTool(NULL, &bIsTargetTool);
							VSASSERT(SUCCEEDED(hr), "Should always be able to tell whether a tool is a target tool!");
							if (bIsTargetTool == VARIANT_FALSE)	// don't attach a target tool to a file!!
							{
								CComBSTR bstrExt;
								hr = m_pTool->get_DefaultExtensions(&bstrExt);
								if (SUCCEEDED(hr))
								{
									CStringW strExtensions = bstrExt;
									if (!strExtensions.IsEmpty() && strExtensions.Find(strName) >= 0)
										m_bIgnoreDefaultTool = VARIANT_FALSE;
								}
							}
						}
					}
				}
			}
		}
	}
	return S_OK;
}

STDMETHODIMP CFileConfiguration::SetDefaultTool(IVCToolImpl* pTool, BOOL bReallyIsDefault)
{
	m_bIgnoreDefaultTool = bReallyIsDefault ? VARIANT_FALSE : VARIANT_TRUE;
	return DoSetTool(pTool, FALSE);
}

STDMETHODIMP CFileConfiguration::put_Tool(IDispatch *newVal)
{
	CComQIPtr<IVCToolImpl> spTool = newVal;
	if (newVal != NULL && spTool == NULL)	// allowed to set the tool to NULL, but must be intentional...
		return CVCProjectEngine::DoSetErrorInfo(VCPROJ_E_NO_TOOL, IDS_ERR_INVALID_TOOL);

	CHECK_ZOMBIE(m_pConfig, IDS_ERR_CFG_ZOMBIE);

	CHECK_OK_TO_DIRTY(0);

	if (spTool != NULL)
	{
		CComPtr<IDispatch> spDispTools;
		HRESULT hr = m_pConfig->get_Tools(&spDispTools);
		VSASSERT(SUCCEEDED(hr), "All configurations have tool lists, even if they're empty!");
		CComQIPtr<IVCCollection> spToolCollection = spDispTools;
		CHECK_ZOMBIE(spToolCollection, IDS_ERR_CFG_ZOMBIE);

		CComPtr<IDispatch> spMatchTool;
		CComQIPtr<IDispatch> spDispTool2 = spTool;
		CComVariant var;
		var.vt = VT_DISPATCH;
		var.pdispVal = spDispTool2.Detach();
		hr = spToolCollection->Item(var, &spMatchTool);
		RETURN_ON_FAIL(hr);
		if (spMatchTool == NULL)
			return CVCProjectEngine::DoSetErrorInfo(VCPROJ_E_NO_TOOL, IDS_ERR_NO_MATCHING_TOOL);
	}

	m_bIgnoreDefaultTool = VARIANT_TRUE;
	HRESULT hr = DoSetTool(spTool, TRUE);
	
	// if we're not loading, notify UI
	if( !g_bInProjLoad )
	{
		CComQIPtr<IDispatch> pDisp = this;
		if( pDisp )
		{
			CComQIPtr<IVCProjectEngineImpl> pProjEngImpl = g_pProjectEngine;
			if( pProjEngImpl )
				pProjEngImpl->DoFireItemPropertyChange( pDisp, VCFCFGID_Tool );
		}
	}

	return hr;
}

STDMETHODIMP CFileConfiguration::VerifyToolValid()
{	// verify that the currently assigned tool works with the current config properties
	RETURN_ON_NULL2(m_pTool, S_OK);

	if (m_bIgnoreDefaultTool)
	{
		CComPtr<IDispatch> spDispTools;
		HRESULT hr = m_pConfig->get_Tools(&spDispTools);
		VSASSERT(SUCCEEDED(hr), "All configurations have tool lists, even if they're empty!");
		CComQIPtr<IVCCollection> spToolCollection = spDispTools;
		if (spToolCollection == NULL)
		{
			m_pTool = NULL;
			return CVCProjectEngine::DoSetErrorInfo(VCPROJ_E_ZOMBIE, IDS_ERR_CFG_ZOMBIE);
		}

		CComBSTR bstrToolName;
		hr = m_pTool->get_ToolShortName(&bstrToolName);
		CComPtr<IDispatch> spMatchTool;
		CComVariant var = bstrToolName;
		hr = spToolCollection->Item(var, &spMatchTool);
		if (FAILED(hr) || spMatchTool == NULL)	// not in the list
			m_pTool = NULL;		// must pick up a different tool instead

		return S_OK;
	}
	else
	{
		// pick up a new tool -- no data will have been lost since it belongs to this file config, anyway, so this is safe
		m_pTool = NULL;
		return S_OK;
	}
}

STDMETHODIMP CFileConfiguration::get_OutputFile(BSTR* pbstrFile)
{	// output file name if this file gets built
	CHECK_POINTER_VALID(pbstrFile);
	*pbstrFile = NULL;

	VARIANT_BOOL bOutput = VARIANT_FALSE;
	if (m_pTool && m_pTool->HasPrimaryOutputFromTool((IUnknown*)(VCFileConfiguration*)this, VARIANT_FALSE, &bOutput) == S_OK 
		&& bOutput == VARIANT_TRUE)
		return m_pTool->GetPrimaryOutputFromTool((IUnknown*)(VCFileConfiguration*)this, VARIANT_FALSE, pbstrFile);

	return S_FALSE;
}

STDMETHODIMP CFileConfiguration::put_OutputFile(BSTR bstrFile)
{
	VARIANT_BOOL bOutput = VARIANT_FALSE;
	if (m_pTool && m_pTool->HasPrimaryOutputFromTool((IUnknown*)(VCFileConfiguration*)this, VARIANT_FALSE, &bOutput) == S_OK 
		&& bOutput == VARIANT_TRUE)
		return m_pTool->SetPrimaryOutputForTool((IUnknown*)(VCFileConfiguration*)this, bstrFile);

	return S_FALSE;
}

STDMETHODIMP CFileConfiguration::get_DefaultOutputFileFormat(BSTR* pbstrFormat)
{	// macro to use for determining the more or less default output name
	CHECK_POINTER_NULL(pbstrFormat);
	*pbstrFormat = NULL;

	VARIANT_BOOL bOutput = VARIANT_FALSE;
	if (m_pTool && m_pTool->HasPrimaryOutputFromTool((IUnknown*)(VCFileConfiguration*)this, VARIANT_FALSE, &bOutput) == S_OK 
		&& bOutput == VARIANT_TRUE)
		return m_pTool->GetDefaultOutputFileFormat((IUnknown*)(VCFileConfiguration*)this, pbstrFormat);

	return S_FALSE;
}

STDMETHODIMP CFileConfiguration::get_ExcludedFromBuild(/*[out, retval]*/  VARIANT_BOOL* pbExcludedFromBuild)
{
	HRESULT hr = GetBoolProperty(VCFCFGID_ExcludedFromBuild, pbExcludedFromBuild);
	if (hr == S_FALSE)
		SGetExcludedFromBuild(pbExcludedFromBuild);

	return hr;
}

HRESULT CFileConfiguration::SGetExcludedFromBuild(VARIANT_BOOL* pbExcluded)
{
	return COptionHandlerBase::GetValueFalse(pbExcluded);
}

STDMETHODIMP CFileConfiguration::put_ExcludedFromBuild(/*[in]*/ VARIANT_BOOL bExcludedFromBuild)
{
	CHECK_VARIANTBOOL(bExcludedFromBuild);
	return SetBoolProperty(VCFCFGID_ExcludedFromBuild, bExcludedFromBuild);
}

STDMETHODIMP CFileConfiguration::get_File(/*[out, retval]*/ IDispatch* *pVal)
{
	m_pFile.QueryInterface(pVal);

	return S_OK;
}

STDMETHODIMP CFileConfiguration::put_File(/*[in]*/ IDispatch* newVal)
{
	CComQIPtr<VCFile> pFile = newVal;
	m_pFile = pFile;
	return S_OK;
}

STDMETHODIMP CFileConfiguration::get_Configuration(/*[out, retval]*/ IDispatch* *pVal)
{
	CHECK_ZOMBIE(m_pConfig, IDS_ERR_CFG_ZOMBIE);
	CHECK_POINTER_VALID(pVal);

	m_pConfig.QueryInterface(pVal);
	return S_OK;
}

STDMETHODIMP CFileConfiguration::put_Configuration(/*[in]*/ IDispatch* newVal)
{
	CComQIPtr<VCConfiguration> pConfig = newVal;
	m_pConfig = pConfig;

	return S_OK;
}

STDMETHODIMP CFileConfiguration::get_IgnoreDefaultTool(/*[out, retval]*/ VARIANT_BOOL* pbIgnoreDefaultTool)
{
	CHECK_POINTER_NULL(pbIgnoreDefaultTool);
	*pbIgnoreDefaultTool = m_bIgnoreDefaultTool;
	return S_OK;
}	// shortcut way to figure out if the user explicitly set the tool

HRESULT CFileConfiguration::GetFileCfgPCR(CBldCfgRecord** ppCfgRecord)
{
	CHECK_POINTER_NULL(ppCfgRecord);
	CHECK_ZOMBIE(m_pConfig, IDS_ERR_CFG_ZOMBIE);

	CComQIPtr<IDispatch> pConfig;
	pConfig = m_pConfig;
	CComPtr<IDispatch> pDispProject;
	HRESULT hr = m_pConfig->get_Project(&pDispProject);
	RETURN_ON_FAIL2(hr, E_UNEXPECTED);

	*ppCfgRecord = g_StaticBuildEngine.GetCfgRecord(pDispProject, pConfig);
	return S_OK;
}


STDMETHODIMP CFileConfiguration::AssignActions(VARIANT_BOOL bOnLoad)
{
	CBldCfgRecord* pCfgRecord = NULL;
	HRESULT hr = GetFileCfgPCR(&pCfgRecord);
	RETURN_ON_FAIL(hr);

	VCFileConfiguration* pFileCfg = this;
	CBldAction::AssignActions(pCfgRecord, pFileCfg);
	return S_OK;
}


STDMETHODIMP CFileConfiguration::UnAssignActions(VARIANT_BOOL bOnClose)
{
	CBldCfgRecord* pCfgRecord = NULL;
	HRESULT hr = GetFileCfgPCR(&pCfgRecord);
	RETURN_ON_FAIL(hr);

	VCFileConfiguration *pFileCfg = this;
	CBldAction::UnAssignActions(pCfgRecord, pFileCfg);
	return S_OK;
}

STDMETHODIMP CFileConfiguration::CreatePageObject(IUnknown **ppUnk, CLSID *pCLSID, IVCPropertyContainer *pPropCntr, IVCSettingsPage *pPage )
{
	CComQIPtr<IVCToolImpl> pTool;
	CComPtr<IDispatch> pDisp;
	
	if( *pCLSID ==  CLSID_GeneralFileConfigSettingsPage )
	{
		CPageObjectImpl<CVCGeneralFileConfigSettingsPage, VCFILECONFIGURATION_MIN_DISPID, VCFILECONFIGURATION_MAX_DISPID>::CreateInstance(ppUnk, pPropCntr, pPage);
		return S_OK;		// this is the makefile project case.
	}

	HRESULT hr = get_Tool( &pDisp );
	if( FAILED( hr ) ) 
		return S_OK;		// this is the makefile project case.

	// if this file has a tool
	pTool = pDisp;
	if( pTool != NULL )
	{
		hr = pTool->CreatePageObject(ppUnk, pCLSID, pPropCntr, pPage );
		return hr;		// this is the makefile project case.
	}
	return E_FAIL;		// this is the makefile project case.
}

STDMETHODIMP CFileConfiguration::GetPages(CAUUID *pPages)
{
	CHECK_POINTER_NULL(pPages);

	CComQIPtr<IVCToolImpl> pTool;
	CComPtr<IDispatch> pDisp;
	CAUUID pages;

	pPages->pElems = (GUID*)NULL;
	pPages->cElems = 0;

	HRESULT hr = get_Tool( &pDisp );
	if( FAILED( hr ) ) 
		return S_OK;		// this is the makefile project case.

	// if this file has a tool
	pTool = pDisp;
	if( pTool != NULL )
	{

		hr = pTool->GetPages( &pages );

		// if we have a tool, allocate for its pages plus the general page
		if( SUCCEEDED( hr ) && pages.cElems )
		{
			// number of tool pages plus number of 'extra' pages (1)
			pPages->cElems = pages.cElems + 1;

			pPages->pElems = (GUID*) CoTaskMemAlloc(sizeof(CLSID)*(pPages->cElems));
			RETURN_ON_NULL2(pPages->pElems, E_OUTOFMEMORY);
		}
	}
	// otherwise just allocate for the general page
	else
	{
		pPages->cElems = 1;
		pPages->pElems = (GUID*) CoTaskMemAlloc( sizeof(CLSID) );
		RETURN_ON_NULL2(pPages->pElems, E_OUTOFMEMORY);
	}

	// copy the static list so that the caller can delete it.
	unsigned long i;

	// add the general->configuration page
	pPages->pElems[0] = __uuidof(GeneralFileConfigSettingsPage);

	for( i = 1; i < pPages->cElems; i++ )
	{
		pPages->pElems[i] = pages.pElems[i-1];
	}

	return hr;
}

STDMETHODIMP CFileConfiguration::get_ItemFileName(BSTR *pVal)
{
	CComPtr<IDispatch> spDispFile;
	if (FAILED(get_File(&spDispFile)) || spDispFile == NULL)
	{
		VSASSERT(FALSE, "Can only get here if we are zombie.");
		return CVCProjectEngine::DoSetErrorInfo(VCPROJ_E_ZOMBIE, IDS_ERR_CFG_ZOMBIE);
	}
	CComQIPtr<VCFile> spFile = spDispFile;
	VSASSERT(spFile != NULL, "Parent is not a file?!?");

	return spFile->get_Name(pVal);
}

STDMETHODIMP CFileConfiguration::get_ItemFullPath(BSTR* pbstrFullPath)
{
	CComPtr<IDispatch> spDispFile;
	if (FAILED(get_File(&spDispFile)) || spDispFile == NULL)
	{
		VSASSERT(FALSE, "Can only get here if we are zombie.");
		return CVCProjectEngine::DoSetErrorInfo(VCPROJ_E_ZOMBIE, IDS_ERR_CFG_ZOMBIE);
	}
	CComQIPtr<VCFile> spFile = spDispFile;
	VSASSERT(spFile != NULL, "Parent is not a file?!?");

	return spFile->get_FullPath(pbstrFullPath);
}

STDMETHODIMP CFileConfiguration::get_ActionList(IVCBuildActionList** ppActionList)
{
	CHECK_POINTER_NULL(ppActionList);

	if (m_spActionList == NULL)
	{
		HRESULT hr = CBldActionList::CreateInstance(&m_spActionList);
		RETURN_ON_FAIL(hr);
	}

	m_spActionList.CopyTo(ppActionList);
	return S_OK;
}

STDMETHODIMP CFileConfiguration::get_FileRegHandle(void** pfrh)
{
	CHECK_POINTER_NULL(pfrh);

	CComPtr<IDispatch> spDispFile;
	if (FAILED(get_File(&spDispFile)) || spDispFile == NULL)
	{
		VSASSERT(FALSE, "Can only get here if we are zombie.");
		return CVCProjectEngine::DoSetErrorInfo(VCPROJ_E_ZOMBIE, IDS_ERR_CFG_ZOMBIE);
	}
	CComQIPtr<IVCBuildableItem> spBuildableItem = spDispFile;
	VSASSERT(spBuildableItem != NULL, "Parent must be a file.  Files must be buildable items.");

	return spBuildableItem->get_FileRegHandle(pfrh);
}

STDMETHODIMP CFileConfiguration::get_ContentList(IEnumVARIANT** ppContents)
{
	CHECK_POINTER_NULL(ppContents);
	*ppContents = NULL;
	
	return S_FALSE;		// don't have a content list the file registry is interested in
}

STDMETHODIMP CFileConfiguration::get_Registry(void** ppFileRegistry)
{
	CHECK_POINTER_NULL(ppFileRegistry);

	CComPtr<IDispatch> spDispFile;
	if (FAILED(get_File(&spDispFile)) || spDispFile == NULL)
	{
		VSASSERT(FALSE, "Can only get here if we are zombie.");
		return CVCProjectEngine::DoSetErrorInfo(VCPROJ_E_ZOMBIE, IDS_ERR_CFG_ZOMBIE);
	}

	CComQIPtr<IVCBuildableItem> spBuildableItem = spDispFile;
	VSASSERT(spBuildableItem != NULL, "Parent must be a file.  Files must be buildable items.");

	return spBuildableItem->get_Registry(ppFileRegistry);
}

STDMETHODIMP CFileConfiguration::get_ProjectConfiguration(VCConfiguration** ppProjCfg)
{
	return m_pConfig.CopyTo(ppProjCfg);
}

STDMETHODIMP CFileConfiguration::get_ProjectInternal(VCProject** ppProject)
{
	CHECK_POINTER_NULL(ppProject);
	*ppProject = NULL;
	CHECK_ZOMBIE(m_pConfig, IDS_ERR_CFG_ZOMBIE);

	CComPtr<IDispatch> spDispProject;
	HRESULT hr = m_pConfig->get_Project(&spDispProject);
	RETURN_ON_FAIL(hr);
	CComQIPtr<VCProject> spProject = spDispProject;
	return spProject.CopyTo(ppProject);
}

STDMETHODIMP CFileConfiguration::get_ExistingBuildEngine(IVCBuildEngine** ppBldEngine)
{
	CHECK_POINTER_NULL(ppBldEngine);
	*ppBldEngine = NULL;

	CComQIPtr<IVCBuildableItem> spBldableProjCfg = m_pConfig;
	CHECK_ZOMBIE(spBldableProjCfg, IDS_ERR_CFG_ZOMBIE);

	return spBldableProjCfg->get_ExistingBuildEngine(ppBldEngine);
}

STDMETHODIMP CFileConfiguration::get_PersistPath(BSTR* pbstrPersistPath)
{
	CHECK_POINTER_NULL(pbstrPersistPath);

	CComPtr<IDispatch> spDispFile;
	HRESULT hr = get_File(&spDispFile);
	CComQIPtr<IVCBuildableItem> spBldableFile = spDispFile;
	RETURN_ON_FAIL(hr);
	CHECK_ZOMBIE(spBldableFile, IDS_ERR_CFG_ZOMBIE);

	return spBldableFile->get_PersistPath(pbstrPersistPath);
}

STDMETHODIMP CFileConfiguration::RefreshActionOutputs(long nPropID, IVCBuildErrorContext* pEC)
{
	if (m_spActionList != NULL)
		m_spActionList->RefreshOutputs(nPropID, pEC);

	return S_OK;
}

STDMETHODIMP CFileConfiguration::HandlePossibleCommandLineOptionsChange(IVCBuildErrorContext* pEC)
{
	HRESULT hr = S_FALSE;
	if (m_spActionList != NULL)
		hr = m_spActionList->HandlePossibleCommandLineOptionsChange(pEC);

	return hr;
}

STDMETHODIMP CFileConfiguration::ClearDirtyCommandLineOptionsFlag()
{
	VARIANT_BOOL bDirtyDuringBuild = VARIANT_FALSE;
	if (GetBoolProperty(VCCFGID_DirtyDuringBuild, &bDirtyDuringBuild) == S_OK)
		return S_FALSE;	// if we dirtied during the build, let the build options be refreshed again next time

	HRESULT hr = S_FALSE;
	if (m_pTool)
		hr = m_pTool->DirtyCommandLineOptions(-1, -1, VARIANT_FALSE);

	return hr;
}

void CFileConfiguration::ResetRegRef(VARIANT_BOOL bReleaseRef)
{
	if (m_spActionList == NULL)
		return;		// nothing to do

	CComQIPtr<IVCBuildableItem> spFileItem = m_pFile;
	if (spFileItem == NULL)
		return;		// nothing to do

	BldFileRegHandle frh = NULL;
	spFileItem->get_FileRegHandle((void **)&frh);
	if (frh == NULL)
		return;		// nothing to do

	m_spActionList->Reset(NULL);
	while (TRUE)
	{
		CComPtr<IVCBuildAction> spAction;
		HRESULT hr = m_spActionList->Next(&spAction, NULL);
		if (hr != S_OK)
			break;
		else if (spAction == NULL)
			continue;

		CBldFileRegistry* preg = NULL;
		spAction->get_Registry((void **)&preg);
		if (preg != NULL)
		{
			if (bReleaseRef)
				preg->ReleaseRegRef(frh, TRUE /* pull out filtering */);
			else
				preg->AddRegRef(frh);
		}
	}
}

void CFileConfiguration::SetToolsDirty()
{
	VSASSERT(m_pConfig, "Hey, no config set!");
	if (m_pConfig == NULL)
		return;		// nothing to do

	CComQIPtr<IVCPropertyContainer> spParent = m_pConfig;
	if (spParent == NULL)
		return;		// nothing to do

	spParent->SetBoolProperty(VCCFGID_PrimaryOutputDirty, VARIANT_TRUE);	// force relink
	ConfigurationTypes configType;
	if (FAILED(m_pConfig->get_ConfigurationType(&configType)))
		return;		// nothing to do

	long nToolDirtyID = -1;
	long nToolDirtyOutputsID = -1;
	switch (configType)
	{
	case typeApplication:
	case typeDynamicLibrary:
		nToolDirtyID = VCLINKID_CmdLineOptionsDirty;
		nToolDirtyOutputsID = VCLINKID_OutputsDirty;
		break;
	case typeStaticLibrary:
		nToolDirtyID = VCLIBID_CmdLineOptionsDirty;
		nToolDirtyOutputsID = VCLIBID_OutputsDirty;
		break;
	}

	if (nToolDirtyID > 0)
	{
		spParent->SetBoolProperty(nToolDirtyID, VARIANT_TRUE);
		spParent->SetBoolProperty(nToolDirtyOutputsID, VARIANT_TRUE);
		spParent->SetBoolProperty(VCCFGID_AnyToolDirty, VARIANT_TRUE);
	}
}

void CFileConfiguration::StartSetOrClearProp(long id, BOOL& bCareAboutChange, VARIANT_BOOL& bOldVal)
{
	bCareAboutChange = FALSE;
	bOldVal = VARIANT_FALSE;

	if (id == VCFCFGID_ExcludedFromBuild)
	{
		if (GetBoolProperty(VCFCFGID_ExcludedFromBuild, &bOldVal) != S_OK)
			bOldVal = VARIANT_FALSE;
		bCareAboutChange = TRUE;
	}
	else if( id == VCFCSTID_CommandLine || id == VCFCSTID_Outputs )
	{
		bCareAboutChange = TRUE;
		bOldVal = VARIANT_TRUE;
	}
}

void CFileConfiguration::FinishSetOrClearProp(long id, BOOL bCareAboutChange, VARIANT_BOOL bOldVal, VARIANT_BOOL bNewVal)
{
	if (PROJECT_IS_LOADED() && IsRealProp(id))
	{
		DirtyCommandLineOptions(id, id);
		if (bCareAboutChange && bOldVal != bNewVal)
		{
			// update UI
			CComQIPtr<IDispatch> pDisp = this;
			if( pDisp )
			{
				CComQIPtr<IVCProjectEngineImpl> pProjEngImpl = g_pProjectEngine;
				if( pProjEngImpl )
					pProjEngImpl->DoFireItemPropertyChange( pDisp, id );
			}
			if (id == VCFCFGID_ExcludedFromBuild)
				ResetRegRef(bNewVal);
			SetToolsDirty();
		}
	}
}

STDMETHODIMP CFileConfiguration::SetProp(long id, VARIANT varValue)
{
	CHECK_OK_TO_DIRTY(id);

	BOOL bCareAboutChange = FALSE;
	VARIANT_BOOL bOldExcludeFromBuild = VARIANT_FALSE;
	StartSetOrClearProp(id, bCareAboutChange, bOldExcludeFromBuild);

	if( !m_pPropMap )
		m_pPropMap = new CVCMap<long,long,CComVariant,VARIANT&>;
	m_pPropMap->SetAt(id, varValue);

	VARIANT_BOOL bNewVal = VARIANT_FALSE;
	if (bCareAboutChange)
		bNewVal = varValue.boolVal;
	FinishSetOrClearProp(id, bCareAboutChange, bOldExcludeFromBuild, bNewVal);

	return S_OK;
}

HRESULT CFileConfiguration::DoGetProp(long id, BOOL bCheckSpecialProps, VARIANT *pVarValue)
{
	// check if it is a special prop that really has local storage (or belongs to a non-property container parent 
	// who does) first
	if (bCheckSpecialProps)
	{
		CComBSTR bstrProp;
		if (DoGetStrProperty(id, TRUE, &bstrProp) == S_OK)
		{
			pVarValue->bstrVal = bstrProp.Detach();
			pVarValue->vt = VT_BSTR;
			return S_OK;
		}
	}

	CComVariant varVal;

	// Check if its here first
	if( m_pPropMap && m_pPropMap->Lookup(id, varVal) )
	{
		varVal.Detach(pVarValue);
		return S_OK;
	}

	// Its not here, so check your parents
	return GetParentProp(id, VARIANT_TRUE /* allow inherit */, pVarValue);
}

STDMETHODIMP CFileConfiguration::GetProp(long id, VARIANT *pVarValue)
{
	return DoGetProp(id, TRUE, pVarValue);
}

STDMETHODIMP CFileConfiguration::GetMultiProp(long id, LPCOLESTR szSeparator, VARIANT_BOOL bSkipLocal, BSTR *pbstrValue)
{
	CHECK_POINTER_NULL(pbstrValue);
	*pbstrValue = NULL;

	HRESULT hrReturn = S_FALSE;
	CComBSTR bstrLocal;
	
	// look in here.
	CComVariant var;
	if( !bSkipLocal && m_pPropMap )
	{
		BOOL b;
		b = m_pPropMap->Lookup(id, var);
		if( b )
		{
			if (NoInheritOnMultiProp(var.bstrVal, szSeparator, pbstrValue))
				return S_OK;	// means we're not doing inheritance
			bstrLocal = var.bstrVal;
			hrReturn = S_OK;
		}
	}
	
	// And check your parents
	CComQIPtr<IVCPropertyContainer> pParent = m_pConfig;
	CComBSTR bstrParent;
	if (pParent)
	{
		HRESULT hr = pParent->GetMultiProp(id, szSeparator, VARIANT_FALSE, &bstrParent);
		if (hr == S_OK)
			hrReturn = S_OK;
		if (hr != S_OK)
			bstrParent = L"";
	}

	if (hrReturn != S_OK)	// nothing further to do here
		return hrReturn;

	return MakeMultiPropString(bstrLocal, bstrParent, szSeparator, pbstrValue);
}

STDMETHODIMP CFileConfiguration::GetEvaluatedMultiProp(long idProp, LPCOLESTR szSeparator, VARIANT_BOOL bCollapseMultiples, 
	VARIANT_BOOL bCaseSensitive, BSTR* pbstrValue)
{
	CHECK_POINTER_NULL(pbstrValue);
	*pbstrValue = NULL;

	HRESULT hr1 = GetMultiProp(idProp, szSeparator, VARIANT_FALSE, pbstrValue);
	RETURN_ON_FAIL(hr1);

    CComBSTR bstrTemp;
	HRESULT hr2 = Evaluate(*pbstrValue, &bstrTemp);
	RETURN_ON_FAIL(hr2);
    SysFreeString(*pbstrValue);
    *pbstrValue = bstrTemp.Detach();


	if (bCollapseMultiples)
	{
		HRESULT hr3 = CollapseMultiples(*pbstrValue, szSeparator, bCaseSensitive, pbstrValue);
		RETURN_ON_FAIL(hr3);
	}

	return hr1;
}

HRESULT CFileConfiguration::DoGetStrProperty(long idProp, BOOL bSpecialPropsOnly, BSTR* pbstrValue)
{
	CHECK_POINTER_NULL(pbstrValue);
	*pbstrValue = NULL;

	HRESULT hr = S_FALSE;

	switch (idProp)
	{
	case VCFILEID_Name:
		RETURN_ON_NULL2(m_pFile, S_FALSE);
		return m_pFile->get_Name(pbstrValue);
		break;
	default:
		if (!bSpecialPropsOnly)
		{
			CComVariant var;
			hr = GetProp(idProp, &var);
			if (hr == S_OK)
			{
				CComBSTR bstrVal = var.bstrVal;
				*pbstrValue = bstrVal.Detach();
			}
		}
	}

	return hr;
}

STDMETHODIMP CFileConfiguration::GetStrProperty(long idProp, BSTR* pbstrValue)
{
	return DoGetStrProperty(idProp, FALSE, pbstrValue);
}

STDMETHODIMP CFileConfiguration::SetStrProperty(long idProp, BSTR bstrValue)
{
	CComVariant var(bstrValue);
	return SetProp(idProp, var);
}

STDMETHODIMP CFileConfiguration::GetEvaluatedStrProperty(long idProp, BSTR* pbstrValue)
{
	CHECK_POINTER_NULL(pbstrValue);
	*pbstrValue = NULL;

	CComBSTR bstrIn;
	HRESULT hr1 = GetStrProperty(idProp, &bstrIn);
	if (FAILED(hr1))
	{
		if (bstrIn)
			*pbstrValue = bstrIn.Detach();
		return hr1;
	}

	HRESULT hr2 = Evaluate(bstrIn, pbstrValue);
	RETURN_ON_FAIL(hr2);

	return hr1;
}

STDMETHODIMP CFileConfiguration::GetIntProperty(long idProp, long* pnValue)
{
	CHECK_POINTER_NULL(pnValue);
	*pnValue = 0;

	CComVariant var;
	HRESULT hr = GetProp(idProp, &var);
	if (hr == S_OK)
		*pnValue = var.intVal;
	return hr;
}

STDMETHODIMP CFileConfiguration::SetIntProperty(long idProp, long nValue)
{
	CComVariant var(nValue);
	return SetProp(idProp, var);
}

STDMETHODIMP CFileConfiguration::GetBoolProperty(long idProp, VARIANT_BOOL* pbValue)
{
	CHECK_POINTER_NULL(pbValue);
	*pbValue = VARIANT_FALSE;

	CComVariant var;
	HRESULT hr = GetProp(idProp, &var);
	if (hr == S_OK)
		*pbValue = var.boolVal;
	return hr;
}

STDMETHODIMP CFileConfiguration::SetBoolProperty(long idProp, VARIANT_BOOL bValue)
{
	CComVariant var(bValue);
	return SetProp(idProp, var);
}

STDMETHODIMP CFileConfiguration::Clear(long id)
{
	if( m_pPropMap )
	{
		CHECK_OK_TO_DIRTY(id);
		BOOL bCareAboutChange = FALSE;
		VARIANT_BOOL bOldVal = VARIANT_FALSE;
		StartSetOrClearProp(id, bCareAboutChange, bOldVal);
		m_pPropMap->RemoveKey(id);
		FinishSetOrClearProp(id, bCareAboutChange, bOldVal, VARIANT_FALSE);
	}
	return S_OK;
}

STDMETHODIMP CFileConfiguration::GetLocalProp(long id, VARIANT *pvarValue)
{
	CComVariant varVal;

	// Check if its here first
	if( m_pPropMap && m_pPropMap->Lookup(id, varVal) )
	{
		if(pvarValue)
			varVal.Detach(pvarValue);
		return S_OK;
	}

	return S_FALSE;
}

STDMETHODIMP CFileConfiguration::GetParentProp(long id, VARIANT_BOOL bAllowInherit, VARIANT *pVarValue)
{
	CComQIPtr<IVCPropertyContainer> pParent = m_pConfig;
	RETURN_ON_NULL2(pParent, S_FALSE);

	CComPtr<IVCStagedPropertyContainer> spStagedParent;
	pParent->GetStagedPropertyContainer(VARIANT_FALSE, &spStagedParent);
	if (spStagedParent)
	{
		CComQIPtr<IVCPropertyContainer> spPropContainer = spStagedParent;
		if (spPropContainer)
			return spPropContainer->GetProp(id, pVarValue);
	}

	if (bAllowInherit)
	{
		if(pParent->GetProp( id, pVarValue ) == S_OK)
			return S_OK;
	}
	else
	{
		if(pParent->GetLocalProp( id, pVarValue ) == S_OK)
			return S_OK;
	}

	// We didn't find it
	return S_FALSE;  
}

STDMETHODIMP CFileConfiguration::IsMultiProp(long id, VARIANT_BOOL* pbIsMultiProp)
{
	CHECK_POINTER_NULL(pbIsMultiProp);
	*pbIsMultiProp = VARIANT_FALSE;

	if (id >= VCFILECONFIGURATION_MIN_DISPID && id <= VCFILECONFIGURATION_MAX_DISPID)
		return S_OK;	// file config's properties are not multi-props

	if (m_pTool)
		return m_pTool->IsMultiProp(id, pbIsMultiProp);

	return S_FALSE;
}

STDMETHODIMP CFileConfiguration::GetMultiPropSeparator(long id, BSTR* pbstrPreferred, BSTR* pbstrAll)
{
	CHECK_POINTER_NULL(pbstrPreferred);
	CHECK_POINTER_NULL(pbstrAll);
	*pbstrPreferred = NULL;
	*pbstrAll = NULL;

	if (id >= VCFILECONFIGURATION_MIN_DISPID && id <= VCFILECONFIGURATION_MAX_DISPID)
		return S_FALSE;	// file config's properties are not multi-props

	if (m_pTool)
		return m_pTool->GetMultiPropSeparator(id, pbstrPreferred, pbstrAll);

	return S_FALSE;
}

STDMETHODIMP CFileConfiguration::DirtyProp(long id)
{
	return S_FALSE;	// can't apply a style sheet here, so can't do a dirty like this, either
}

STDMETHODIMP CFileConfiguration::Evaluate(BSTR bstrIn, BSTR *pbstrOut)
{
	CHECK_POINTER_VALID(pbstrOut);
	return ExpandMacros(pbstrOut, bstrIn, this, FALSE);
}

STDMETHODIMP CFileConfiguration::EvaluateWithValidation(BSTR bstrSource, long idProp, BSTR* pbstrExpanded)
{
	return ExpandMacros(pbstrExpanded, bstrSource, this, FALSE, idProp);
}

STDMETHODIMP CFileConfiguration::HasLocalStorage(VARIANT_BOOL bForSave, VARIANT_BOOL* pbHasLocalStorage)
{
	CHECK_POINTER_NULL(pbHasLocalStorage);
	*pbHasLocalStorage = VARIANT_FALSE;

	if (m_pPropMap != NULL)
	{
		VCPOSITION pos = m_pPropMap->GetStartPosition();
		while (pos && *pbHasLocalStorage == VARIANT_FALSE)
		{
			long id;
			CComVariant var;
			m_pPropMap->GetNextAssoc(pos, id, var);
			if (!IsRealProp(id))
				continue;	// false hit for storage

			switch (var.vt)
			{
			case VT_I2:
			case VT_I4:
			case VT_BOOL:
				*pbHasLocalStorage = VARIANT_TRUE;
				break;
			case VT_BSTR:
				{
					CStringW strVal = var.bstrVal;
					if (!strVal.IsEmpty())
						*pbHasLocalStorage = VARIANT_TRUE;
					else
					{
						IsMultiProp(id, pbHasLocalStorage);
						*pbHasLocalStorage = !(*pbHasLocalStorage);		// don't treat blank multi-prop value as local storage
					}
					break;
				}
			}
		}

		return S_OK;
	}
	else if (bForSave == VARIANT_TRUE)
		return S_OK;

	if (m_pTool)
		return m_pTool->HasVirtualLocalStorage(this, pbHasLocalStorage);

	return S_OK;
}

HRESULT CFileConfiguration::DirtyCommandLineOptions(long nLowKey, long nHighKey)
{
	if (m_pTool)
	{
		HRESULT hr = m_pTool->DirtyCommandLineOptions(nLowKey, nHighKey, VARIANT_TRUE);
		if (hr == S_OK)
		{
			CComQIPtr<IVCPropertyContainer> pParent = m_pConfig;
			if (pParent)
			{
				pParent->SetBoolProperty(VCCFGID_AnyToolDirty, VARIANT_TRUE);
				VARIANT_BOOL bOutputDirty;
				if (m_pTool->OutputsAreDirty(this, &bOutputDirty) == S_OK)
					pParent->SetBoolProperty(VCCFGID_AnyOutputDirty, VARIANT_TRUE);
			}
		}
		return hr;
	}

	return S_FALSE;
}

STDMETHODIMP CFileConfiguration::ClearAll()
{
	if( m_pPropMap )
	{
		CHECK_OK_TO_DIRTY(0);
		if (PROJECT_IS_LOADED())	// make sure we get any appropriate command lines dirtied...
		{
			VCPOSITION pos = m_pPropMap->GetStartPosition();
			while (pos != NULL)
			{
				long id;
				CComVariant var;
				m_pPropMap->GetNextAssoc(pos, id, var);
				BOOL bCareAboutChange;
				VARIANT_BOOL bOldVal;
				StartSetOrClearProp(id, bCareAboutChange, bOldVal);
				if (bCareAboutChange)	// want change in effect more or less immediately...
					m_pPropMap->RemoveKey(id);
				FinishSetOrClearProp(id, bCareAboutChange, bOldVal, VARIANT_FALSE);
			}
		}
		m_pPropMap->RemoveAll();
		delete m_pPropMap;
		m_pPropMap = NULL;
	}
	return S_OK;
}

STDMETHODIMP CFileConfiguration::GetStagedPropertyContainer(VARIANT_BOOL bCreateIfNecessary, IVCStagedPropertyContainer** ppPropContainer)
{
	CHECK_POINTER_NULL(ppPropContainer);

	if (!m_spStagedContainer)
	{
		if (bCreateIfNecessary)
		{
			HRESULT hr = CVCStagedPropertyContainer::CreateInstance(this, &m_spStagedContainer);
			RETURN_ON_FAIL(hr);
		}
		else
		{
			*ppPropContainer = NULL;
			return S_OK;
		}
	}

	return m_spStagedContainer.CopyTo(ppPropContainer);
}

STDMETHODIMP CFileConfiguration::ReleaseStagedPropertyContainer()		// intended for use ONLY by the staged property container itself
{
	if (m_spStagedContainer)
	{
		m_spStagedContainer->Close();
		m_spStagedContainer.Release();
	}

	return S_OK;
}

// WARNING: Clone must only be called on a brand new config!!
STDMETHODIMP CFileConfiguration::Clone( IVCPropertyContainer *pSource )
{
	// check arg
	CHECK_READ_POINTER_NULL(pSource);

	CFileConfiguration* pIn = (CFileConfiguration*)pSource;

	VARIANT_BOOL bIgnoreDefaultTool = VARIANT_FALSE;
	pIn->get_IgnoreDefaultTool(&bIgnoreDefaultTool);
	if (bIgnoreDefaultTool)		// non-default tool
	{
		CComPtr<IDispatch> spTool;
		pIn->get_Tool(&spTool);
		put_Tool(spTool);
	}

	RETURN_ON_NULL2(pIn->m_pPropMap, S_OK);	// no true local storage

	// if this file cfg doesn't have local storage, create it
	if( !m_pPropMap )
		m_pPropMap = new CVCMap<long,long,CComVariant,VARIANT&>;
	
	// get the start of the map
	VCPOSITION iter = pIn->m_pPropMap->GetStartPosition();
	// iterate over each item in the map
	while( iter )
	{
		long key;
		CComVariant value;

		pIn->m_pPropMap->GetNextAssoc( iter, key, value );

		// copy this element
		m_pPropMap->SetAt( key, value );
	}

	return S_OK;
}

STDMETHODIMP CFileConfiguration::get_VCProjectEngine(IDispatch** ppProjEngine)
{
	CHECK_POINTER_VALID(ppProjEngine);
	RETURN_ON_NULL(g_pProjectEngine);
	return g_pProjectEngine->QueryInterface(IID_IDispatch, (void **)ppProjEngine);
}

STDMETHODIMP CVCGeneralFileConfigSettingsPage::get_ExcludedFromBuild(VARIANT_BOOL *pbExcluded)
{
	HRESULT hr = GetBoolProperty(VCFCFGID_ExcludedFromBuild, pbExcluded);
	if (hr == S_FALSE)
		CFileConfiguration::SGetExcludedFromBuild(pbExcluded);
	return hr;
}

STDMETHODIMP CVCGeneralFileConfigSettingsPage::put_ExcludedFromBuild(VARIANT_BOOL bExcluded)
{
	CHECK_VARIANTBOOL(bExcluded);
	return SetBoolProperty(VCFCFGID_ExcludedFromBuild, bExcluded);
}

STDMETHODIMP CVCGeneralFileConfigSettingsPage::get_Tool(int* pdwTool)
{
	CHECK_POINTER_NULL(pdwTool);
	*pdwTool = m_nCurrentTool;
	return S_OK;
}

STDMETHODIMP CVCGeneralFileConfigSettingsPage::put_Tool(int dwTool)
{
	if (dwTool < 0 || dwTool >= m_cTools)
		RETURN_INVALID();
	m_nCurrentTool = dwTool;
	if (m_pPage)
		m_pPage->Dirty();
	return S_OK;
}

STDMETHODIMP CVCGeneralFileConfigSettingsPage::Commit()
{
	if (m_nCurrentTool != m_nLastTool)
	{
		VSASSERT(!m_bNoFileTools, "Hey, how'd we get multiple tool choices when there's only one choice?");
		CComQIPtr<IVCStagedPropertyContainer> spStagedContainer = m_pContainer;
		CComQIPtr<IVCPropertyContainer> spLiveContainer;
		if (spStagedContainer)
			spStagedContainer->get_Parent(&spLiveContainer);
		if (spLiveContainer == NULL)
			spLiveContainer = m_pContainer;
		CComQIPtr<VCFileConfiguration> spFileCfg = spLiveContainer;
		CHECK_ZOMBIE(spFileCfg, IDS_ERR_CFG_ZOMBIE);

		int nToolID = m_nCurrentTool;
		if (m_bAllowInherit && nToolID == m_cTools-1)	// last tool in this case is <inherit>
			nToolID = m_nDefaultTool;
		CComQIPtr<IVCToolImpl> spToolImpl = m_rgFileTools.GetAt(nToolID);
		CComQIPtr<IDispatch> spDispTool = spToolImpl;
		HRESULT hr = spFileCfg->put_Tool(spDispTool);
		RETURN_ON_FAIL(hr);
		m_nLastTool = m_nCurrentTool;
		CVCProjectEngine::DoUpdateAfterApply();
	}
	Clear(VCFCFGID_Tool);	// this is only a temporary member of the property container...

	return CBase::Commit();
}

STDMETHODIMP CVCGeneralFileConfigSettingsPage::GetDisplayString(DISPID dispID, BSTR *pBstr)
{
	if (dispID != VCFCFGID_Tool)
		return CBase::GetDisplayString(dispID, pBstr);

	CStringW strCurrentTool = m_strToolNames.GetAt(m_nCurrentTool);
	*pBstr = strCurrentTool.AllocSysString();
	return S_OK;
}

STDMETHODIMP CVCGeneralFileConfigSettingsPage::GetPredefinedStrings(DISPID dispID, CALPOLESTR *pCaStringsOut,
	CADWORD *pCaCookiesOut)
{
	if (dispID != VCFCFGID_Tool)
		return CBase::GetPredefinedStrings(dispID, pCaStringsOut, pCaCookiesOut);

	CHECK_POINTER_NULL(pCaStringsOut);
	CHECK_POINTER_NULL(pCaCookiesOut);

	pCaCookiesOut->cElems = m_cTools;
	pCaCookiesOut->pElems = (DWORD*)CoTaskMemAlloc(m_cTools * sizeof(DWORD));
	RETURN_ON_NULL2(pCaCookiesOut->pElems, E_OUTOFMEMORY);

	pCaStringsOut->cElems = m_cTools;
	pCaStringsOut->pElems = (LPOLESTR*)CoTaskMemAlloc(m_cTools * sizeof(LPOLESTR));
	RETURN_ON_NULL2(pCaStringsOut->pElems, E_OUTOFMEMORY);

	int idx;
	for (idx = 0; idx < m_cTools; idx++)
		pCaCookiesOut->pElems[idx] = idx;

	for (idx = 0; idx < m_cTools; idx++)
	{
		CStringW strToolName = m_strToolNames.GetAt(idx);
		CComBSTR bstrToolName = strToolName;
		pCaStringsOut->pElems[idx] = (LPOLESTR)CoTaskMemAlloc((bstrToolName.Length()+1) * sizeof(OLECHAR));
		wcscpy(pCaStringsOut->pElems[idx], bstrToolName);
	}

	return S_OK;
}

STDMETHODIMP CVCGeneralFileConfigSettingsPage::GetPredefinedValue(DISPID dispID, DWORD dwCookie, VARIANT* pVarOut)
{
	if (dispID != VCFCFGID_Tool)
		return CBase::GetPredefinedValue(dispID, dwCookie, pVarOut);

	if (dwCookie < 0 || (int)dwCookie >= m_cTools)
		RETURN_INVALID();

	CHECK_POINTER_NULL(pVarOut);
	CComVariant var = dwCookie;
	var.Detach(pVarOut);
	return S_OK;
}

BOOL CVCGeneralFileConfigSettingsPage::IsDefaultTool(int nToolID)
{
	if (m_bAllowInherit && nToolID == m_cTools-1)	// last tool is inherit
		return FALSE;
	CComQIPtr<IVCToolImpl> spToolImpl = m_rgFileTools.GetAt(nToolID);
	if (spToolImpl)
	{
		CComBSTR bstrExt;
		HRESULT hr = spToolImpl->get_DefaultExtensions(&bstrExt);
		if (SUCCEEDED(hr))
		{
			CStringW strExtensions = bstrExt;
			if (!strExtensions.IsEmpty() && strExtensions.Find(m_strFileExt) >= 0)
				return TRUE;
		}
	}

	return FALSE;
}

STDMETHODIMP CVCGeneralFileConfigSettingsPage::HasDefaultValue(DISPID dispID, BOOL *pfDefault)
{
	if (dispID != VCFCFGID_Tool)
		return CBase::HasDefaultValue(dispID, pfDefault);

	CHECK_POINTER_NULL(pfDefault);
	*pfDefault = IsDefaultTool(m_nCurrentTool);
	return S_OK;
}

void CVCGeneralFileConfigSettingsPage::ResetParentIfNeeded()
{
	m_rgFileTools.RemoveAll();
	m_strToolNames.RemoveAll();
	m_nLastTool = 0;
	m_nCurrentTool = 0;
	m_cTools = 0;
	m_bNoFileTools = false;

	CComQIPtr<IVCStagedPropertyContainer> spStagedContainer = m_pContainer;
	CComQIPtr<IVCPropertyContainer> spLiveContainer;
	if (spStagedContainer)
		spStagedContainer->get_Parent(&spLiveContainer);
	if (spLiveContainer == NULL)
		spLiveContainer = m_pContainer;
	CComQIPtr<VCFileConfiguration> spFileCfg = spLiveContainer;
	if (spFileCfg == NULL)
	{
		VSASSERT(FALSE, "Hey, bad parent for a file config page!");
		return;
	}

	CComPtr<IDispatch> spDispFile;
	spFileCfg->get_Parent(&spDispFile);
	CComQIPtr<VCFile> spFile = spDispFile;
	if (spFile)
	{
		CComBSTR bstrFile;
		spFile->get_Name(&bstrFile);
		CStringW strFile = bstrFile;
		int i = strFile.ReverseFind(L'.');
		if (i > 0)
			m_strFileExt = strFile.Mid(i);
		m_strFileExt.MakeLower();
	}

	CComPtr<IDispatch> spDispTool;
	spFileCfg->get_Tool(&spDispTool);
	CComQIPtr<IVCToolImpl> spTool = spDispTool;
	CStringW strToolName;
	if (spTool != NULL)
	{
		CComBSTR bstrToolName;
		spTool->get_ToolNameInternal(&bstrToolName);
		strToolName = bstrToolName;
	}

	CComQIPtr<IVCFileConfigurationImpl> spFileCfgImpl = spFileCfg;
	if (spFileCfgImpl == NULL)
	{
		VSASSERT(FALSE, "Hey, bad parent for a file config page!");
		return;
	}

	VARIANT_BOOL bIgnoreDefaultTool = VARIANT_FALSE;
	spFileCfgImpl->get_IgnoreDefaultTool(&bIgnoreDefaultTool);
	m_bAllowInherit = (bIgnoreDefaultTool == VARIANT_TRUE);	

	CComPtr<IDispatch> spDispProjCfg;
	spFileCfgImpl->get_Configuration(&spDispProjCfg);
	CComQIPtr<VCConfiguration> spProjCfg = spDispProjCfg;
	if (spProjCfg == NULL)
	{
		VSASSERT(FALSE, "Hey, bad parent for file config page!");
		return;
	}

	CComQIPtr<IVCCollection> spFileTools;
	spProjCfg->get_FileTools(&spFileTools);
	if (spFileTools == NULL)
	{
		VSASSERT(FALSE, "Hey, no file tools!");
		return;
	}
	CComPtr<IEnumVARIANT> spEnum;
	spFileTools->_NewEnum(reinterpret_cast<IUnknown **>(&spEnum));
	if (spEnum == NULL)
	{
		VSASSERT(FALSE, "Hey, no file tools!");
		return;
	}
	spEnum->Reset();

	m_cTools = 0;
	BOOL bFoundLast = FALSE;
	while (TRUE)
	{
		CComVariant var;
		HRESULT hr = spEnum->Next(1, &var, NULL);
		if (hr != S_OK)
			break;
		if (var.vt != VT_DISPATCH && var.vt != VT_UNKNOWN)
			continue;
		IDispatch* pDispTool = var.pdispVal;
		CComQIPtr<IVCToolImpl> spToolImpl = pDispTool;
		if (spToolImpl == NULL)
			continue;
		CComBSTR bstrFileTool;
		spToolImpl->get_ToolNameInternal(&bstrFileTool);
		CStringW strFileTool = bstrFileTool;
		if (strFileTool.IsEmpty())
			continue;
		// these two stay in sync only because we aren't going to be doing any removes from the tool list...
		m_rgFileTools.Add(spToolImpl);
		m_strToolNames.Add(strFileTool);
		if (!bFoundLast)
		{
			bFoundLast = (strFileTool == strToolName);
			if (bFoundLast)
				m_nLastTool = m_cTools;
		}
		m_cTools++;
	}
	m_nCurrentTool = m_nLastTool;

	m_bNoFileTools = (m_cTools == 0);
	if (m_bNoFileTools)	// no file tools, such as for makefile or utility projects
	{
		m_cTools = 1;
		CStringW strNoTool;
		strNoTool.LoadString(IDS_NOTOOL);
		m_strToolNames.Add(strNoTool);
	}

	m_nDefaultTool = -1;
	if (m_bAllowInherit)
	{
		for (int idx = 0; idx < m_cTools; idx++)
		{
			if (IsDefaultTool(idx))
			{
				m_nDefaultTool = idx;
				break;
			}
		}
		if (m_nDefaultTool < 0)	// must be custom tool as default
		{
			for (int idx = 0; idx < m_cTools; idx++)
			{
				CComQIPtr<IVCToolImpl> spToolImpl = m_rgFileTools.GetAt(idx);
				if (spToolImpl == NULL)
					continue;
				VARIANT_BOOL bIsCustom = VARIANT_FALSE;
				spToolImpl->get_IsCustomBuildTool(&bIsCustom);
				if (bIsCustom)	// only gonna be one custom tool for files...
				{
					m_nDefaultTool = idx;
					break;
				}
			}
		}
		CStringW strInherit;
		strInherit = L"<inherit setting>";	// REVIEW: does this need to be localized?
		m_strToolNames.Add(strInherit);
		m_cTools++;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\vcpb\Filter.h ===
// Filter.h: Definition of the CFilter class
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_FILTER_H__625C649C_2C7E_11D3_87BF_A0494CC10000__INCLUDED_)
#define AFX_FILTER_H__625C649C_2C7E_11D3_87BF_A0494CC10000__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "comlist.h"
#include "collection.h"

/////////////////////////////////////////////////////////////////////////////
// CFilter

class CFilter : 
	public IDispatchImpl<VCFilter, &IID_VCFilter, &LIBID_VCProjectEngineLibrary, PublicProjBuildTypeLibNumber,0, CVsTypeInfoHolder>,
	public IVCFilterImpl,
	public IVCExternalCookie,
	public CComObjectRoot
{
public:
	CFilter() : m_pExternalCookie(NULL), m_bItemsCollectionDirty(true), m_bParseFiles(VARIANT_TRUE), m_bSCCFiles(VARIANT_TRUE)
	{
	}
	~CFilter()
	{
	}
	static HRESULT CreateInstance(VCFilter **ppFilter);

BEGIN_COM_MAP(CFilter)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(VCFilter)
	COM_INTERFACE_ENTRY(IVCFilterImpl)
	COM_INTERFACE_ENTRY(IVCExternalCookie)
	COM_INTERFACE_ENTRY(VCProjectItem)
	COM_INTERFACE_ENTRY(IVCCollectionProvider)
END_COM_MAP()
//DECLARE_NOT_AGGREGATABLE(CFilter) 
// Remove the comment from the line above if you don't want your object to 
// support aggregation. 

DECLARE_NO_REGISTRY()

// VCFilter
public:
	STDMETHOD(Remove)();
	STDMETHOD(get_Name)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_Name)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_CanonicalName)(BSTR* pbstrCanonicalName);
	STDMETHOD(get_UniqueIdentifier)(BSTR* pbstrID);
	STDMETHOD(put_UniqueIdentifier)(BSTR bstrID);
	STDMETHOD(AddFile)(BSTR bstrPath, /*[out, retval]*/ IDispatch * *ppDispFile);
	STDMETHOD(CanAddFile)(BSTR bstrFile, VARIANT_BOOL* pbCanAdd);
	STDMETHOD(AddFilter)(BSTR bstrName, /*[out, retval]*/ IDispatch **ppDispFilter);
	STDMETHOD(CanAddFilter)(BSTR bstrFilter, VARIANT_BOOL* pbCanAdd);
	STDMETHOD(get_Filter)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_Filter)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_Filters)(/*[out, retval]*/ IDispatch **pVal);
	STDMETHOD(get_Files)(/*[out, retval]*/ IDispatch **pVal);
	STDMETHOD(get_Items)(/*[out, retval]*/ IDispatch **pVal);
	STDMETHOD(RemoveFile)(/*[in]*/  IDispatch *pItem);
	STDMETHOD(RemoveFilter)(/*[in]*/  IDispatch *pItem);
	STDMETHOD(get_ParseFiles)(VARIANT_BOOL* pbParse);
	STDMETHOD(put_ParseFiles)(VARIANT_BOOL bParse);
	STDMETHOD(get_SourceControlFiles)(VARIANT_BOOL* pbSCC);
	STDMETHOD(put_SourceControlFiles)(VARIANT_BOOL bSCC);
	STDMETHOD(AddWebReference)(BSTR bstrUrl, IDispatch** ppFile);
	STDMETHOD(Move)(IDispatch *pParent);
	STDMETHOD(CanMove)(IDispatch *pParent, VARIANT_BOOL* pbCanMove);

// IVCFilterImpl
public:
	STDMETHOD(Close)();
	STDMETHOD(AddItem)(IDispatch * pDisp);
	STDMETHOD(CanAddFile2)(BSTR bstrFile);
	STDMETHOD(CanAddFilter2)(BSTR bstrFilter, VARIANT_BOOL bSetErrorInfo);
	STDMETHOD(RemoveExistingFile)(IDispatch* pDisp);
	STDMETHOD(IsMatch)(LPCOLESTR szFileName, VARIANT_BOOL *pbIsMatch);
	STDMETHOD(SaveObject)(IStream *xml, IVCPropertyContainer *pPropCnt, long nIndent);
	STDMETHOD(put_Parent)(/*[in]*/ IDispatch *pVal);
	STDMETHOD(AddChild)(IDispatch* pChild);
	STDMETHOD(RemoveChild)(IDispatch* pChild);
	STDMETHOD(RemoveContents)();

// VCProjectItem
public:
	STDMETHOD(MatchName)(BSTR bstrNameToMatch, VARIANT_BOOL bFullOnly, VARIANT_BOOL *pbMatched);
	STDMETHOD(get_Project)(IDispatch **ppProject);
	STDMETHOD(get_Parent)(/*[out, retval]*/ IDispatch * *pVal);
	STDMETHOD(get_ItemName)(BSTR *Val) { return get_Name(Val); }
	STDMETHOD(get_Kind)(BSTR* kind);
	STDMETHOD(get_VCProjectEngine)(IDispatch** projEngine);

// IVCCollectionProvider
public:
	STDMETHOD(UpdateItemsCollection)(DWORD dwCookie);

//	IVCExternalCookie
public:
	STDMETHOD(get_ExternalCookie)(void** ppVal) { *ppVal = m_pExternalCookie; return S_OK; }
	STDMETHOD(put_ExternalCookie)(void* pVal) { m_pExternalCookie = pVal; return S_OK; }

// Data
protected:
	CComPtr<IDispatch> 	m_pParent;
	CComDynamicListTyped<VCFile> m_rgFiles;	// collection of files
	CComDynamicListTyped<VCFilter> m_rgFilters;	// collection of filters
	CComDynamicListTyped<VCProjectItem> m_rgItems;	// collection of files & filters immediately in this filter
	void* m_pExternalCookie;
	CComBSTR 			m_bstrFilter;
	CComBSTR 			m_bstrName;
	CComBSTR			m_bstrUniqueIdentifier;
	bool				m_bItemsCollectionDirty;
	VARIANT_BOOL		m_bParseFiles;
	VARIANT_BOOL		m_bSCCFiles;

protected:
	HRESULT SetDirty(VARIANT_BOOL bDirty);
	HRESULT FindParentProject(IDispatch* pObject, IDispatch** ppParentProject);
	HRESULT FindExistingFile(BSTR bstrFile, IVCProjectImpl** ppProjImpl, IDispatch** ppFile, BOOL bSetErrorInfo);
	HRESULT FindExistingFilter(BSTR bstrFilter, CStringW& strCleanedUpName, IDispatch** ppDispFilter, BOOL bSetErrorInfo);
	HRESULT DoRemoveExistingFile(IDispatch* pFile, BOOL bTellProject);
	HRESULT RemoveExistingFilter(IDispatch* pDispFilter, long index);
	HRESULT DoRemoveContents(BOOL bTellParent);
	bool FindAsParent(IDispatch* pItem, IDispatch* pParent);
	void BuildItemsCollection();
	HRESULT CheckCanMove(IDispatch *pParent);
	HRESULT WrapCanDirty(UINT idCheck);
	HRESULT CheckCanAddFile(BSTR bstrFile, IVCProjectImpl** ppProjImpl, BOOL bSetErrorInfo);
	HRESULT CheckCanAddFilter(BSTR bstrFilter, CStringW& strCleanedUpName, BOOL bSetErrorInfo);
	HRESULT QueryCanRemoveFile(VCFile* pFile);
};

#endif // !defined(AFX_FILTER_H__625C649C_2C7E_11D3_87BF_A0494CC10000__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\vcpb\Filter.cpp ===
// Filter.cpp : Implementation of 

#include "stdafx.h"
#include "Filter.h"
#include "file.h"
#include "VCProjectEngine.h"
#include "BuildEngine.h"
#include "projwriter.h"
#include "project.h"

/////////////////////////////////////////////////////////////////////////////
//
HRESULT CFilter::CreateInstance(VCFilter **ppDispInfo)
{
	HRESULT hr;
	CFilter *pVar;
	CComObject<CFilter> *pObj;
	hr = CComObject<CFilter>::CreateInstance(&pObj);
	if (SUCCEEDED(hr))
	{
		pVar = pObj;
		pVar->AddRef();
		*ppDispInfo = pVar;
		//hr = pVar->Initialize(NULL, NULL);
	}
	return hr;
}


HRESULT CFilter::SetDirty(VARIANT_BOOL bDirty)
{
	CComPtr<IDispatch> pProjDisp;
	get_Project(&pProjDisp);
	CComQIPtr<IVCProjectImpl> pProjectImpl = pProjDisp;
	CHECK_ZOMBIE(pProjectImpl, IDS_ERR_FILTER_ZOMBIE);

	return pProjectImpl->put_IsDirty(bDirty);
}
STDMETHODIMP CFilter::get_Parent(IDispatch **ppVal)
{
	CHECK_POINTER_VALID( ppVal );
	m_pParent.CopyTo(ppVal);
	return S_OK;
}

STDMETHODIMP CFilter::put_Parent(IDispatch *ppVal)
{
	m_pParent =ppVal;
	return S_OK;
}

STDMETHODIMP CFilter::AddChild(IDispatch* pChild)
{
	m_bItemsCollectionDirty = true;

	CComQIPtr<VCFile> spFile = pChild;
	if (spFile != NULL)	
	{
		m_rgFiles.Add(spFile);
		CComQIPtr<IVCFileImpl> spFileImpl = spFile;
		if (spFileImpl)
			spFileImpl->put_Parent(this);
		return S_OK;
	}

	CComQIPtr<VCFilter> spFilter = pChild;
	RETURN_ON_NULL2(spFilter, E_UNEXPECTED);	// only know about files and filters for this

	m_rgFilters.AddTail(spFilter);
	CComQIPtr<IVCFilterImpl> spFilterImpl = spFilter;
	if (spFilterImpl)
		spFilterImpl->put_Parent(this);
	return S_OK;
}

STDMETHODIMP CFilter::RemoveChild(IDispatch* pChild)
{
	m_bItemsCollectionDirty = true;

	CComQIPtr<VCFile> spFile = pChild;
	if (spFile != NULL)	
	{
		m_rgFiles.Remove(spFile);
		CComQIPtr<IVCFileImpl> spFileImpl = spFile;
		if (spFileImpl)
			spFileImpl->put_Parent(NULL);
		return S_OK;
	}

	CComQIPtr<VCFilter> spFilter = pChild;
	RETURN_ON_NULL2(spFilter, E_UNEXPECTED);	// only know about files and filters for this

	m_rgFilters.Remove(spFilter);
	CComQIPtr<IVCFilterImpl> spFilterImpl = spFilter;
	if (spFilterImpl)
		spFilterImpl->put_Parent(NULL);
	return S_OK;
}

STDMETHODIMP CFilter::get_Filters(IDispatch **ppVal)
{
	CHECK_POINTER_VALID(ppVal);
		
	CComPtr<IVCCollection> pCollection;

	HRESULT hr = CCollection<VCFilter>::CreateInstance(&pCollection, &m_rgFilters);
	if (SUCCEEDED(hr))
	{
		*ppVal = pCollection.Detach();
	}
	return hr;
}

STDMETHODIMP CFilter::get_Files(IDispatch **ppVal)
{
	CHECK_POINTER_VALID(ppVal);
		
	CComPtr<IVCCollection> pCollection;

	HRESULT hr = CCollection<VCFile>::CreateInstance(&pCollection, &m_rgFiles);
	if (SUCCEEDED(hr))
	{
		*ppVal = pCollection.Detach();
	}
	return hr;
}

STDMETHODIMP CFilter::get_Filter(BSTR *pVal)
{
	CHECK_POINTER_VALID( pVal );
	return m_bstrFilter.CopyTo(pVal);
}

STDMETHODIMP CFilter::put_Filter(BSTR newVal)
{
	CHECK_OK_TO_DIRTY(0);
	m_bstrFilter = newVal;
	// USER_MODEL: Should we recalculte Filtering Now ?
	return S_OK;
}

STDMETHODIMP CFilter::get_ParseFiles(VARIANT_BOOL* pbParse)
{
	CHECK_POINTER_VALID(pbParse);
	*pbParse = m_bParseFiles;
	return S_OK;
}

STDMETHODIMP CFilter::put_ParseFiles(VARIANT_BOOL bParse)
{
	CHECK_VARIANTBOOL(bParse);
	CHECK_OK_TO_DIRTY(0);

	m_bParseFiles = bParse;
	return S_OK;
}

STDMETHODIMP CFilter::get_SourceControlFiles(VARIANT_BOOL* pbSCC)
{
	CHECK_POINTER_VALID(pbSCC);
	*pbSCC = m_bSCCFiles;
	return S_OK;
}

STDMETHODIMP CFilter::put_SourceControlFiles(VARIANT_BOOL bSCC)
{
	CHECK_VARIANTBOOL(bSCC);
	CHECK_OK_TO_DIRTY(0);

	m_bSCCFiles = bSCC;
	return S_OK;
}

STDMETHODIMP CFilter::get_Items(IDispatch **ppVal)
{
	CHECK_POINTER_VALID(ppVal);

	BuildItemsCollection();
		
	CComPtr<IVCCollection> pCollection;
	HRESULT hr = CCollection<VCProjectItem>::CreateInstance(&pCollection, &m_rgItems, this, 1);
	if (SUCCEEDED(hr))
		*ppVal = pCollection.Detach();
	return hr;
}

STDMETHODIMP CFilter::UpdateItemsCollection(DWORD dwCookie)
{
	if (dwCookie != 0)	// only care about updating one collection
		BuildItemsCollection();

	return S_OK;
}

void CFilter::BuildItemsCollection()
{
	if (!m_bItemsCollectionDirty)
		return;

	m_rgItems.RemoveAll();

	long l;
	long lcItems = m_rgFiles.GetSize();
	for (l = 0; l < lcItems; l++)
	{
		CComQIPtr<VCProjectItem> spItem = m_rgFiles.GetAt(l);
		if (spItem == NULL)
			continue;

		m_rgItems.Add(spItem);
	}

	lcItems = m_rgFilters.GetSize();
	for (l = 0; l < lcItems; l++)
	{
		CComQIPtr<VCProjectItem> spItem = m_rgFilters.GetAt(l);
		if (spItem == NULL)
			continue;

		m_rgItems.Add(spItem);
	}

	m_bItemsCollectionDirty = false;
}

STDMETHODIMP CFilter::MatchName(BSTR bstrNameToMatch, VARIANT_BOOL bFullOnly, VARIANT_BOOL *pbMatched)
{
	CHECK_POINTER_VALID(pbMatched);
	CComQIPtr<VCFilter> spFilterParent = m_pParent;
	*pbMatched = VARIANT_FALSE;
	if ((!bFullOnly || !spFilterParent) && m_bstrName && bstrNameToMatch && _wcsicmp(m_bstrName, bstrNameToMatch) == 0)
	{
		*pbMatched = VARIANT_TRUE;
		return S_OK;
	}

	// time to check for unique name since plain name didn't match

	RETURN_ON_NULL2(spFilterParent, S_OK);	// top level filter's unique name is same as its plain name, so no further work makes sense here

	CComBSTR bstrNameIn = bstrNameToMatch;
	// if the length of the name to match isn't significantly longer than the name of the filter, there's no point
	// in building up the unique filter path/name
	if (bstrNameIn.Length() <= m_bstrName.Length() + 1)
		return S_OK;

	RETURN_ON_NULL2(bstrNameToMatch, S_OK);		// not going to match if this is NULL and what we have here isn't

	CComBSTR bstrCanonicalName;
	get_CanonicalName(&bstrCanonicalName);
	if (bstrCanonicalName.Length() > 0 && _wcsicmp(bstrCanonicalName, bstrNameToMatch) == 0)
	{
		*pbMatched = VARIANT_TRUE;
		return S_OK;
	}

	if (m_bstrUniqueIdentifier.Length() > 0 && _wcsicmp(m_bstrUniqueIdentifier, bstrNameToMatch) == 0)
		*pbMatched = VARIANT_TRUE;

	return S_OK;
}

STDMETHODIMP CFilter::get_Name(BSTR *pVal)
{
	CHECK_POINTER_VALID( pVal );
	return m_bstrName.CopyTo(pVal);
}

STDMETHODIMP CFilter::put_Name(BSTR newVal)
{
	// don't update UI during project load!
	if( g_bInProjLoad )
	{
		m_bstrName = newVal;
		return S_OK;
	}

	// validate name
	// check for all whitespace or 0 length string
	CStringW strName = newVal;
	strName.TrimLeft();
	strName.TrimRight();
	if( strName.IsEmpty() )
		return S_OK;

	// check for duplicate names
	HRESULT hr = E_FAIL;
	CComQIPtr<VCProject> spProject = m_pParent;
	CComQIPtr<VCFilter> spParentFilter = m_pParent;
	CComQIPtr<IVCProjectImpl> spProjectImpl = spProject;
	CComQIPtr<IVCFilterImpl> spParentFilterImpl = spParentFilter;
	if (spProjectImpl)
		hr = spProjectImpl->CanAddFilter2(newVal, VARIANT_TRUE /* errorinfo */);
	else if (spParentFilterImpl)
		hr = spParentFilterImpl->CanAddFilter2(newVal, VARIANT_TRUE /* errorinfo */);
	RETURN_ON_FAIL(hr);

	CHECK_OK_TO_DIRTY(0);

	CComBSTR bstrOldName = m_bstrName;
	m_bstrName = newVal;

	// send an event notifying everyone in the UI business that we've changed
	// appearances
	CComQIPtr<IDispatch> spDisp = this;
	if( spDisp )
	{
		CComQIPtr<IVCProjectEngineImpl> spPrjEngImpl = g_pProjectEngine;
		if( spPrjEngImpl )
		{
			spPrjEngImpl->DoFireItemPropertyChange( spDisp, VCFLTID_Name );
			spPrjEngImpl->DoFireItemRenamed( spDisp, m_pParent, bstrOldName );
		}
	}

	return S_OK;
}

// unique name is built up of '\' delimited filter names up to the top level
STDMETHODIMP CFilter::get_CanonicalName(BSTR* pbstrName)
{
	CHECK_POINTER_VALID(pbstrName);
	CHECK_ZOMBIE(m_pParent, IDS_ERR_FILTER_ZOMBIE);

	CStringW strName = m_bstrName;
	CComQIPtr<VCFilter> pParentFilter = m_pParent;
	while( pParentFilter )
	{
		CComBSTR bstrParentName;
		HRESULT hr = pParentFilter->get_Name(&bstrParentName);
		RETURN_ON_FAIL(hr);
		strName = bstrParentName + "\\" + strName;
		CComPtr<IDispatch> pDispParent;
		hr = pParentFilter->get_Parent(&pDispParent);
		pParentFilter = pDispParent;
	};

	*pbstrName = strName.AllocSysString();
	return S_OK;
}

// unique GUID identifier for the filter
STDMETHODIMP CFilter::get_UniqueIdentifier(BSTR* pbstrID)
{
	CHECK_POINTER_VALID(pbstrID);
	m_bstrUniqueIdentifier.CopyTo(pbstrID);
	return S_OK;
}

STDMETHODIMP CFilter::put_UniqueIdentifier(BSTR bstrID)
{
	CHECK_OK_TO_DIRTY(0);
	m_bstrUniqueIdentifier = bstrID;
	return S_OK;
}

STDMETHODIMP CFilter::RemoveExistingFile(IDispatch* pItem)
{
	return DoRemoveExistingFile(pItem, FALSE);
}

STDMETHODIMP CFilter::RemoveFile(/*[in]*/  IDispatch *pItem)
{
	return DoRemoveExistingFile(pItem, TRUE);
}

HRESULT CFilter::QueryCanRemoveFile(VCFile* pFile)
{
	VSASSERT( pFile, "Hey, how did we get here with a NULL pFile?" );
	if (pFile == NULL)
		return CVCProjectEngine::DoSetErrorInfo(VCPROJ_E_INTERNAL_ERR, IDS_ERR_INTERNAL_ERROR);
	
	// warning: if you remove this ForwardTrackEvents, be sure to check CVCProjectEngine::s_pBuildPackage for NULL...
	if (!CProject::ForwardTrackEvents(NULL))	// check it once for cheap and dirty check
		return S_OK;

	if( !CProject::ForwardTrackEvents( this ) )	// check it again with the parent
		return S_OK;

	CComBSTR bstrPath;
	HRESULT hr = pFile->get_FullPath(&bstrPath);
	RETURN_ON_FAIL(hr);

	CComPtr<IDispatch> pProjDisp;
	hr = get_Project(&pProjDisp);// get the parent object so we can add the file to the flat list
	if( FAILED( hr ) )
		return hr;
	CComQIPtr<VCProject> pProject = pProjDisp;
	if( !pProject )
		return E_UNEXPECTED;

 	return CVCProjectEngine::s_pBuildPackage->AllowedToRemoveFile(pProject, bstrPath);
}

HRESULT CFilter::DoRemoveExistingFile(IDispatch* pItem, BOOL bTellProject)
{
	HRESULT hr = VCPROJ_E_NOT_FOUND;
	CComQIPtr<VCFile> pFile;
	long lcItems;
	long index;
 	lcItems = m_rgFiles.GetSize();
	for (index = 0; index <= lcItems && hr == VCPROJ_E_NOT_FOUND; index++)
	{
		pFile.Release();
		pFile = m_rgFiles.GetAt(index);
		if (pFile == NULL)
			continue;

		CComQIPtr<IDispatch> pDispFile = pFile;
		if (pDispFile && pDispFile == pItem)
		{
#ifdef _DEBUG
			CComBSTR bstrName; pFile->get_Name(&bstrName); // DEBUG
#endif
			// are we okay to delete the file?
			CHECK_OK_TO_DIRTY(0);
			hr = QueryCanRemoveFile(pFile);
			RETURN_ON_FAIL(hr);

			m_rgFiles.RemoveAtIndex(index);
			// let the project close the file...
			hr = S_OK;
		}
	}

	m_bItemsCollectionDirty = true;
	if (bTellProject && SUCCEEDED(hr))
	{
		CComPtr<IDispatch> pProjDisp;
		get_Project(&pProjDisp);
		CComQIPtr<IVCProjectImpl> pProjectImpl = pProjDisp;
		if (pProjectImpl)
			hr = pProjectImpl->RemoveExistingFile(pItem);
		else
			hr = E_UNEXPECTED;
	}

	if (hr == VCPROJ_E_NOT_FOUND)
		return CVCProjectEngine::DoSetErrorInfo(VCPROJ_E_NOT_FOUND, IDS_ERR_FILE_NOT_FOUND_FOR_REMOVE, bTellProject);

	return hr;
}

HRESULT CFilter::RemoveExistingFilter(IDispatch* pDispFilter, long index)
{
	m_rgFilters.RemoveAtIndex(index);

	// fire events
	CComQIPtr<IVCProjectEngineImpl> pEngine = g_pProjectEngine;
	RETURN_ON_NULL2(pEngine, E_UNEXPECTED);

	CComQIPtr<IDispatch> pDispParent = this;
	if( pDispParent )
		pEngine->DoFireItemRemoved(pDispFilter, pDispParent);

	m_bItemsCollectionDirty = true;
	CComQIPtr<IVCFilterImpl> pFilterImpl = pDispFilter;
	CComQIPtr<IVCFilterImpl> pFilter = pDispFilter;
	if (pFilter)
		pFilter->RemoveContents();
	if (pFilterImpl)
		pFilterImpl->Close();

	return S_OK;
}

STDMETHODIMP CFilter::RemoveFilter(/*[in]*/  IDispatch *pItem)
{
	HRESULT hr = VCPROJ_E_NOT_FOUND;
	long lcItems;
	long index;
	CComQIPtr<VCFilter> pFilter;

	lcItems = m_rgFilters.GetSize();
	for (index = 0; index <= lcItems && hr == VCPROJ_E_NOT_FOUND; index++)
	{
		pFilter = m_rgFilters.GetAt(index);
		if (pFilter == NULL)
			continue;

		CComQIPtr<IDispatch> pDispFilter = pFilter;
		if (pDispFilter && pDispFilter == pItem)
		{
			CHECK_OK_TO_DIRTY(0);
			return RemoveExistingFilter(pDispFilter, index);
		}
	}

	if (hr == VCPROJ_E_NOT_FOUND)
		return CVCProjectEngine::DoSetErrorInfo(VCPROJ_E_NOT_FOUND, IDS_ERR_FILTER_NOT_FOUND_FOR_REMOVE);

	return hr;
}

// helper function to sort files
static int FileCompare( const void* fileA, const void* fileB )
{
	CComBSTR bstrNameA, bstrNameB;
	(*(VCFile**)(fileA))->get_Name( &bstrNameA );
	(*(VCFile**)(fileB))->get_Name( &bstrNameB );
	return wcscoll( bstrNameA, bstrNameB );
}

STDMETHODIMP CFilter::SaveObject(IStream *xml, IVCPropertyContainer *pPropCnt, long nIndent)
{
	// Name
	NodeAttributeWithSpecialChars( xml, CComBSTR( L"Name" ), m_bstrName );

	// Filter
	NodeAttributeWithSpecialChars( xml, CComBSTR( L"Filter" ), m_bstrFilter, true );

	// only save the unique identifier if there actually is one
	if (m_bstrUniqueIdentifier.Length() > 0)
		NodeAttributeWithSpecialChars( xml, CComBSTR( L"UniqueIdentifier" ), m_bstrUniqueIdentifier );

	// only save the info about parsing files if the user DOESN'T want the files parsed
	if (m_bParseFiles == VARIANT_FALSE)
		NodeAttribute( xml, CComBSTR( L"ParseFiles"), L"FALSE" );
	
	// only save the info about files if the user DOESN'T want the files under SCC
	if (m_bSCCFiles == VARIANT_FALSE)
		NodeAttribute( xml, CComBSTR( L"SourceControlFiles"), L"FALSE" );
	
	// end of attributes, start children
	EndNodeHeader( xml, true );

	// files
	// sort the files alphabetically before writing
	// allocate an array of ptrs
	VCFile **rgFiles = new VCFile*[m_rgFiles.GetCount()];
	// copy the ptrs (NON-REFCOUNTED!) into the array
	long lcItems = m_rgFiles.GetSize();
	int i = 0;
	long index;
	for( index = 0; index < lcItems; index++ )
	{
		VCFile* pFile = m_rgFiles.GetAt( index );
		if( pFile )
			rgFiles[i++] = pFile;
	}
	// sort the array
	qsort( (void*)rgFiles, i, sizeof(VCFile*), FileCompare );

	CComBSTR bstrFile( L"File" );
	lcItems = i;
	for( index = 0; index < lcItems; index++ )
	{
		CComQIPtr<VCFile> pFile;
		
		pFile = rgFiles[index];
		if( pFile )
		{
			CComQIPtr<IVCFileImpl> pFileImpl = pFile;
			if ( pFileImpl )
			{
				StartNodeHeader( xml, bstrFile, true );
				pFileImpl->SaveObject( xml, NULL, GetIndent() );
				EndNode( xml, bstrFile, true );
			}
		}
	}
	delete[] rgFiles;

	// filters
	CComBSTR bstrFilter( L"Filter" );
	lcItems = m_rgFilters.GetSize();
	for( index = 0; index <= lcItems; index++ )
	{
		CComPtr<VCFilter> pFilter;
		pFilter = m_rgFilters.GetAt( index );
		if( pFilter )
		{
			CComQIPtr<IVCFilterImpl> pFilterImpl = pFilter;
			if( pFilterImpl )
			{
				StartNodeHeader( xml, bstrFilter, true );
				pFilterImpl->SaveObject( xml, NULL, GetIndent() );
				EndNode( xml, bstrFilter, true );
			}
		}
	}

	return S_OK;
}


// Returns TRUE if the filter for this filter matches the file
STDMETHODIMP CFilter::IsMatch(LPCOLESTR szFileName, VARIANT_BOOL *pbIsMatch)
{
	CStringW strItem, strFilter, strExt;
	int i;
	int extStart, extEnd;

	*pbIsMatch = VARIANT_FALSE;
	if (m_bstrFilter.Length() == 0)
		return S_OK;

	strFilter = m_bstrFilter;
	strItem = szFileName;
	i = strItem.ReverseFind(L'.');
	if( i > 0 )
	{ 
		// assume that a dot at the beginning isn't an extension
		strItem = strItem.Mid(i+1);
		strItem.MakeUpper();
		strFilter.MakeUpper();

		extStart = 0;
		extEnd = 0;
		// while we're not at the end of the extension list string
		while( extStart < strFilter.GetLength() )
		{
			// get the next extension in the filter list
			extEnd = strFilter.Find( L';', extStart );
			// if it wasn't found there is an error
			if( extEnd == -1 )
				extEnd = strFilter.GetLength();
			// does it match our file's extension?
			strExt = strFilter.Mid( extStart, extEnd - extStart );
			if( strExt == strItem )
			{
				*pbIsMatch = VARIANT_TRUE;
				return S_OK;
			}
			extStart = extEnd + 1;
		}
	}
	return S_OK;
}


STDMETHODIMP CFilter::Close()
{
	// NOTE: not closing down the file list here since all we have is a copy of what the project
	// actually owns.  If you need to close down files, do it there.

	long lcItems = m_rgFilters.GetSize();
	for (long l = 0; l < lcItems; l++)
	{
		CComPtr<VCFilter> pFilter;
		pFilter = m_rgFilters.GetAt(l);
		CComQIPtr<IVCFilterImpl> pFilterImpl = pFilter;
		if (pFilterImpl)
			pFilterImpl->Close(); // close down entirely; release all
	}

	m_pParent = NULL;
	m_rgFiles.RemoveAll();	// collection of files
	m_rgFilters.RemoveAll();	// collection of filters
	return S_OK;
}

STDMETHODIMP CFilter::AddItem(IDispatch * pDisp)
{
	HRESULT hr = E_UNEXPECTED;
	CComQIPtr<VCFile> pFile;
	CComQIPtr<IVCFileImpl> pFileImpl;

	CHECK_OK_TO_DIRTY(0);

	pFile = pDisp;
	if (pFile)
	{
		CComPtr<IDispatch> pDispParentLast;
		pFile->get_Parent(&pDispParentLast);
		pFileImpl = pFile;
		VSASSERT(pFileImpl, "*All* file objects must implement IVCFileImpl");
		if (pFileImpl)
		{
			pFileImpl->put_Parent(static_cast<IDispatch *>(this));
		}
		m_rgFiles.Add(pFile);
		m_bItemsCollectionDirty = true;
		
		if (!pDispParentLast)
		{ // this kind of implies that the DoFireItemAdded is really a DoFireNEWItemAdded
			CComQIPtr<IVCProjectEngineImpl> pEngine;
			pEngine = g_pProjectEngine;
			if (pEngine)
				pEngine->DoFireItemAdded(pDisp, (IDispatch*)this);
		}
		hr = S_OK;
	}
	else
	{
		CComQIPtr<VCFilter> pFilter;
		CComQIPtr<IVCFilterImpl> pFilterImpl;
		
		pFilter = pDisp;
		if (pFilter)
		{
			CComPtr<IDispatch> pDispParentLast;
			pFilter->get_Parent(&pDispParentLast);
			pFilterImpl = pFilter;
			VSASSERT(pFilterImpl, "*All* filter objects must implement IVCFilterImpl");
			if (pFilterImpl)
			{
				pFilterImpl->put_Parent(static_cast<IDispatch *>(this));
			}
			m_rgFilters.Add(pFilter);
			m_bItemsCollectionDirty = true;

			if (!pDispParentLast)
			{ // this kind of implies that the DoFireItemAdded is really a DoFireNEWItemAdded
				CComQIPtr<IVCProjectEngineImpl> pEngine;
				pEngine = g_pProjectEngine;
				if (pEngine)
					pEngine->DoFireItemAdded(pDisp, (IDispatch*)this);
			}
			hr = S_OK;
		}
	}
	return hr;
}

HRESULT CFilter::CheckCanAddFilter(BSTR bstrFilter, CStringW& strCleanedUpName, BOOL bSetErrorInfo)
{
	CComPtr<IDispatch> spExistingFilter;
	HRESULT hr = FindExistingFilter(bstrFilter, strCleanedUpName, &spExistingFilter, bSetErrorInfo);
	RETURN_ON_FAIL(hr);
	if (spExistingFilter)	// already exists
		return CVCProjectEngine::DoSetErrorInfo2(VCPROJ_E_FILTER_EXISTS, IDS_ERR_FILTER_EXISTS, bstrFilter, bSetErrorInfo);

	CHECK_OK_TO_DIRTY(0);

	return S_OK;
}

STDMETHODIMP CFilter::CanAddFilter(BSTR bstrFilter, VARIANT_BOOL* pbCanAdd)
{
	CHECK_POINTER_VALID(pbCanAdd);

	CStringW strCleanedUpName;
	HRESULT hr = CheckCanAddFilter(bstrFilter, strCleanedUpName, TRUE);
	*pbCanAdd = FAILED(hr) ? VARIANT_FALSE : VARIANT_TRUE;

	return SUCCEEDED(hr) ? S_OK : S_FALSE;
}

STDMETHODIMP CFilter::CanAddFilter2(BSTR bstrFilter, VARIANT_BOOL bSetErrorInfo)
{
	CStringW strCleanedUpName;
	return CheckCanAddFilter(bstrFilter, strCleanedUpName, (bSetErrorInfo == VARIANT_TRUE));
}

HRESULT CFilter::FindExistingFilter(BSTR bstrFilterName, CStringW& strCleanedUpName, IDispatch** ppDispFilter, BOOL bSetErrorInfo)
{
	*ppDispFilter = NULL;	// BETTER be safe thing to do since this is an internal function...

	// Validate: Is this a valid name ?
	strCleanedUpName = bstrFilterName;
	strCleanedUpName.TrimLeft();
	strCleanedUpName.TrimRight();
	if( strCleanedUpName.GetLength() == 0 )
		return CVCProjectEngine::DoSetErrorInfo2(E_INVALIDARG, IDS_ERR_BAD_FILTER_NAME, bstrFilterName, bSetErrorInfo);

	// Validate: Do we have one with this name already ?
	if( g_bInProjLoad == FALSE )
	{
		int cFilters = m_rgFilters.GetSize();
		int index;
		for( index = 0; index <= cFilters; index++ )
		{
			CComPtr<VCFilter> pFilterT = m_rgFilters.GetAt( index );
			if( pFilterT )
			{
				CComBSTR bstrExistingName;
				pFilterT->get_Name( &bstrExistingName );
				if( bstrExistingName && wcsicmp( bstrExistingName, strCleanedUpName ) == 0 )
				{
					pFilterT.QueryInterface( ppDispFilter );
					return S_FALSE;
				}
			}
		}
	}

	return S_OK;
}

STDMETHODIMP CFilter::AddFilter(BSTR bstrFilterName, /*[out, retval]*/ IDispatch **ppDispFilter)
{
	CHECK_POINTER_VALID(ppDispFilter)
	CStringW strName;
	HRESULT hr = CheckCanAddFilter(bstrFilterName, strName, TRUE);	// dirty happens here...
	RETURN_ON_FAIL(hr);
	CComBSTR bstrName = strName;
		
	CComPtr<VCFilter> pFilter;
	CComQIPtr<IVCFilterImpl> pFilterImpl;
	hr = CFilter::CreateInstance(&pFilter);
	pFilterImpl = pFilter;
	RETURN_SPECIFIC_ON_FAIL_OR_NULL(hr, pFilterImpl, E_NOINTERFACE);

	pFilter.QueryInterface(ppDispFilter);
	pFilterImpl->put_Parent(this);
	pFilter->put_Name(bstrName);
	m_rgFilters.Add(pFilter);
	m_bItemsCollectionDirty = true;

	CComQIPtr<IVCProjectEngineImpl> pEngine;
	pEngine = g_pProjectEngine;
	if (pEngine)
		pEngine->DoFireItemAdded(pFilter, (IDispatch*)this);

	return S_OK;
}

STDMETHODIMP CFilter::get_Project(/*[out, retval]*/ IDispatch **ppProject)
{
	CHECK_POINTER_VALID( ppProject );
	return FindParentProject(this, ppProject);
}

HRESULT CFilter::WrapCanDirty(UINT idCheck)	// just need to wrap the CHECK_OK_TO_DIRTY macro
{
	CHECK_OK_TO_DIRTY(idCheck);
	return S_OK;
}

HRESULT CFilter::CheckCanAddFile(BSTR bstrFile, IVCProjectImpl** ppProjImpl, BOOL bSetErrorInfo)
{
	CComPtr<IDispatch> spFile;

	HRESULT hr = FindExistingFile(bstrFile, ppProjImpl, &spFile, bSetErrorInfo);
	RETURN_ON_FAIL(hr);
	if (spFile)	// already there
		return CVCProjectEngine::DoSetErrorInfo2(VCPROJ_E_FILE_EXISTS, IDS_ERR_FILE_EXISTS, bstrFile, bSetErrorInfo);

	CHECK_ZOMBIE(*ppProjImpl, IDS_ERR_FILTER_ZOMBIE);

	hr = (*ppProjImpl)->FileNameValid(bstrFile, bSetErrorInfo ? VARIANT_TRUE : VARIANT_FALSE);
	if (hr != S_OK)
		return hr;

	CHECK_OK_TO_DIRTY2(VCFLTID_AddFile, bSetErrorInfo);

	CComQIPtr<VCProject> spProj = *ppProjImpl;
	return CProject::QueryCanAddFile(spProj, this, bstrFile, bSetErrorInfo);
}

STDMETHODIMP CFilter::CanAddFile(BSTR bstrFile, VARIANT_BOOL* pbCanAdd)
{
	CHECK_POINTER_VALID(pbCanAdd);

	CComPtr<IVCProjectImpl> spProjImpl;
	HRESULT hr = CheckCanAddFile(bstrFile, &spProjImpl, TRUE);
	*pbCanAdd = FAILED(hr) ? VARIANT_FALSE : VARIANT_TRUE;

	return SUCCEEDED(hr) ? S_OK : S_FALSE;
}

STDMETHODIMP CFilter::CanAddFile2(BSTR bstrFile)
{
	CComPtr<IVCProjectImpl> spProjImpl;
	return CheckCanAddFile(bstrFile, &spProjImpl, FALSE);
}

HRESULT CFilter::FindExistingFile(BSTR bstrPath, IVCProjectImpl** ppProjImpl, IDispatch** ppFile, BOOL bSetErrorInfo)
{
	*ppProjImpl = NULL;	// BETTER be valid output param...
	*ppFile = NULL;		// BETTER be valid output param...

	// check for empty string
	if( !bstrPath || *bstrPath == L'\0' )
		return CVCProjectEngine::DoSetErrorInfo2(E_INVALIDARG, IDS_ERR_BAD_FILE_NAME, bstrPath, bSetErrorInfo);

	CComPtr<IDispatch> pProjDisp;
	HRESULT hr = get_Project(&pProjDisp);// get the parent object so we can add the file to the flat list
	CComQIPtr<IVCProjectImpl> pProjImpl = pProjDisp;
	pProjImpl.CopyTo(ppProjImpl);
	CComQIPtr<VCProject> pProject = pProjDisp;
	RETURN_ON_NULL2(pProjImpl, E_UNEXPECTED);

	if( g_bInProjLoad == FALSE )		// dont validate if loading a project
	{
		CComPtr<IDispatch> pDispColl;
		pProject->get_Files(&pDispColl);
		CComQIPtr<IVCCollection> pColl = pDispColl; VSASSERT(pColl, "Either did not get a files collection or it was not of the right COM type.");
		hr = pColl->Item(CComVariant(bstrPath), ppFile);
	}

	return hr;	
}

STDMETHODIMP CFilter::AddFile(BSTR bstrPath, /*[out, retval]*/ IDispatch * *ppDispFile)
{
	CHECK_POINTER_VALID(ppDispFile);

	HRESULT hr;
	CComQIPtr<IVCProjectImpl> spProjImpl;

	if( g_bInProjLoad == FALSE )
	{
		hr = CheckCanAddFile(bstrPath, &spProjImpl, TRUE);
		RETURN_ON_FAIL(hr);
		CHECK_ZOMBIE(spProjImpl, IDS_ERR_PROJ_ZOMBIE);
	}
	// in project load, need to get an IVCProjectImpl ptr
	else
	{
		CComPtr<IDispatch> pProjDisp;
		hr = get_Project(&pProjDisp);// get the parent object so we can add the file to the flat list
		spProjImpl = pProjDisp;
		RETURN_ON_FAIL(hr);
		CHECK_ZOMBIE(spProjImpl, IDS_ERR_PROJ_ZOMBIE);
	}

	CComQIPtr<VCFile> spFile;
	hr = CPEFile::CreateInstance(&spFile);
	CComQIPtr<IDispatch> spDisp = spFile;
	VSASSERT(spFile && spDisp, "Must be out of memory.");
	RETURN_ON_FAIL(hr);
	if (spFile == NULL || spDisp == NULL)
		return E_OUTOFMEMORY;

	hr = spProjImpl->AddNewFile(spDisp, bstrPath, VARIANT_FALSE);
	VSASSERT(SUCCEEDED(hr), "Must not have done all the proper checks to make sure the file we want to add was not there already.");
	RETURN_ON_FAIL(hr);

	spDisp.CopyTo(ppDispFile);

	CComQIPtr<IVCFileImpl> spFileImpl = spFile;
	if (spFileImpl)
		spFileImpl->put_Parent(this);
	m_rgFiles.Add(spFile);
	m_bItemsCollectionDirty = true;

	// fire events
	CComQIPtr<IVCProjectEngineImpl> pEngine = g_pProjectEngine;
	if (pEngine)
	{
		pEngine->DoFireItemAdded(spDisp, static_cast<IDispatch*>(this));
		if( g_bInProjLoad == FALSE )
		{
			CComQIPtr<VCProject> spProject = spProjImpl;
			if (spProject)
				CProject::InformFileAdded(spProject, spFile, bstrPath);
		}
		return S_OK;
	}

	return DoSetErrorInfo(E_UNEXPECTED, IDS_ERR_INTERNAL_ERROR);
}

STDMETHODIMP CFilter::Move(IDispatch *pParent)
{
	HRESULT hr = CheckCanMove(pParent);
	RETURN_ON_FAIL(hr);
	if (hr == S_FALSE)	// signal for no-op
		return S_OK;

	CComPtr<IDispatch> spOldParent = m_pParent;
	CComQIPtr<IVCProjectImpl> spOldProjectImpl = m_pParent;
	CComQIPtr<IVCFilterImpl> spOldFilterImpl = m_pParent;
	CComQIPtr<IVCProjectImpl> spNewProjectImpl = pParent;
	CComQIPtr<IVCFilterImpl> spNewFilterImpl = pParent;
	VSASSERT((spOldProjectImpl != NULL || spOldFilterImpl != NULL) && (spNewProjectImpl != NULL || spNewFilterImpl != NULL), "Hey, bad parenting on move!");
	if ((spOldProjectImpl == NULL && spOldFilterImpl == NULL) || (spNewProjectImpl == NULL && spNewFilterImpl == NULL))
		return E_UNEXPECTED;

	IDispatch* pThis = static_cast<IDispatch*>(this);
	if (spOldProjectImpl)
		spOldProjectImpl->RemoveChild(pThis);
	else
		spOldFilterImpl->RemoveChild(pThis);

	// parent will be reset during AddChild
	if (spNewProjectImpl)
		spNewProjectImpl->AddChild(pThis);
	else
		spNewFilterImpl->AddChild(pThis);

	CComQIPtr<IVCProjectEngineImpl> spEngine = g_pProjectEngine;
	if (spEngine)
		spEngine->DoFireItemMoved(pThis, m_pParent, spOldParent);

	SetDirty(VARIANT_TRUE);
	return hr;
}

bool CFilter::FindAsParent(IDispatch* pItem, IDispatch* pParent)
{
	CComQIPtr<VCFilter> spFilter = pParent;
	RETURN_ON_NULL2(spFilter, false);	// only care about filters on filters

	CComQIPtr<VCFilter> spFilterLast;

	do
	{ // loop ends with spFilter == NULL 
		CComPtr<IDispatch> spDisp;
		spFilter->get_Parent(&spDisp);
		if (spDisp == pItem)
			return true;
		spFilterLast = spFilter;
		spFilter = spDisp;
	} while (spFilter);

	return false;	// obviously didn't find it
}

STDMETHODIMP CFilter::CanMove(IDispatch* pParent, VARIANT_BOOL* pbCanMove)
{
	HRESULT hr = CheckCanMove(pParent);
	if (pbCanMove)		// NULL pointer is allowed here since the out param is optional
	{
		CHECK_POINTER_VALID(pbCanMove);
		*pbCanMove = SUCCEEDED(hr) ? VARIANT_TRUE : VARIANT_FALSE;
	}

	return (SUCCEEDED(hr) ? S_OK : S_FALSE);
}

HRESULT CFilter::CheckCanMove(IDispatch* pParent)
{
	if (pParent == NULL)
		return CVCProjectEngine::DoSetErrorInfo2(VCPROJ_E_NULL_PATH, IDS_ERR_SET_NULL_PARENT, m_bstrName);

	CComQIPtr<IDispatch> spOldDispParent = m_pParent;
	if (spOldDispParent == pParent)
		return S_FALSE;	// no-op since same parent
	
	CComQIPtr<IDispatch> spDispThis = this;
	if (pParent == spDispThis)
		return S_FALSE;	// should be no-op to drop on itself

	CHECK_OK_TO_DIRTY(0);

	CComPtr<IDispatch> spMyProjParent;
	CComPtr<IDispatch> spNewProjParent;
	FindParentProject((IDispatch *)this, &spMyProjParent);
	FindParentProject(pParent, &spNewProjParent);
	if (spMyProjParent != spNewProjParent)
		return CVCProjectEngine::DoSetErrorInfo(VCPROJ_E_DIFF_PROJ, IDS_ERR_MOVE_CROSS_PROJ);	// can only move within same project

	if (FindAsParent(this, pParent))	// trying to make this filter a child of one of its children!
		return CVCProjectEngine::DoSetErrorInfo2(VCPROJ_E_BAD_PATH, IDS_ERR_PARENT_AS_CHILD, m_bstrName);

	CComQIPtr<VCProject> spProject = pParent;
	CComPtr<IDispatch> spDispFilters;
	if (spProject)
		spProject->get_Filters(&spDispFilters);
	else
	{
		CComQIPtr<VCFilter> spFilter = pParent;
		if (spFilter == NULL)
			return CVCProjectEngine::DoSetErrorInfo2(VCPROJ_E_BAD_PARENT, IDS_ERR_BAD_FILTER_PARENT, m_bstrName);
		spFilter->get_Filters(&spDispFilters);
	}

	CComQIPtr<IVCCollection> spFilterCollection = spDispFilters;
	RETURN_ON_NULL2(spFilterCollection, E_UNEXPECTED);

	CComVariant varName = m_bstrName;
	CComPtr<IDispatch> spExists;
	spFilterCollection->Item(varName, &spExists);
	if (spExists != NULL)	// cannot have two folders there with the same name
		return CVCProjectEngine::DoSetErrorInfo2(VCPROJ_E_FILTER_EXISTS, IDS_ERR_FILTER_EXISTS, m_bstrName, TRUE);

	return S_OK;
}

HRESULT CFilter::FindParentProject(IDispatch* pObject, IDispatch** ppParentProject)
{
	*ppParentProject = NULL;

	CComQIPtr<VCProject> spProject = pObject;
	if (spProject)	// top level filter
	{
		CComQIPtr<IDispatch> spDispProject = spProject;
		*ppParentProject = spDispProject.Detach();
		return S_OK;
	}

	CComPtr<VCFilter> pFilterLast;
	CComQIPtr<VCFilter> pFilterT = pObject;
	RETURN_ON_NULL2(pFilterT, E_UNEXPECTED);	// nothing we can do

	do
	{ // loop ends with pFilterT == NULL 
		CComPtr<IDispatch> pDisp;
		pFilterT->get_Parent(&pDisp);
		pFilterLast = pFilterT;
		pFilterT = pDisp;
	} while (pFilterT);
	
	if (pFilterLast != NULL)
		return pFilterLast->get_Parent(ppParentProject);

	return E_UNEXPECTED;
}

STDMETHODIMP CFilter::Remove()
{
	CHECK_OK_TO_DIRTY(0);
	return DoRemoveContents(TRUE);
}

STDMETHODIMP CFilter::RemoveContents()
{
	// CHECK_OK_TO_DIRTY should have been called long before we got here...
	return DoRemoveContents(FALSE);
}

HRESULT CFilter::DoRemoveContents(BOOL bTellParent)
{
	CComPtr<IDispatch> pProjDisp;
	HRESULT hr = get_Project(&pProjDisp);
	CComQIPtr<VCProject> pProject = pProjDisp;
	CComQIPtr<VCFilter> spFilterParent = m_pParent;
	CComQIPtr<VCProject> spProjectParent = m_pParent;

	long l;
	long lcItems = m_rgFiles.GetSize();
	for (l = 0; l < lcItems; l++)
	{
		CComPtr<VCFile> pFile;
		pFile = m_rgFiles.GetAt(l);
		if (pFile)
		{
			CComQIPtr<IDispatch> pDispFile = pFile;
			pProject->RemoveFile(pDispFile);
		}
	}

	lcItems = m_rgFilters.GetSize();
	for (l = 0; l < lcItems; l++)
	{
		CComQIPtr<IDispatch> pFilter = m_rgFilters.GetAt(l);
		if (pFilter == NULL)
			continue;
		RemoveExistingFilter(pFilter, l);
	}

	m_pParent = NULL;
	m_rgFiles.RemoveAll();	// collection of files
	m_rgFilters.RemoveAll();	// collection of filters

	if (bTellParent)
	{
		if (spFilterParent)
			spFilterParent->RemoveFilter(static_cast<IDispatch *>(this));
		else if (spProjectParent)		
			spProjectParent->RemoveFilter(static_cast<IDispatch *>(this));
		else
			VSASSERT(FALSE, "Hey, filter's parent must be a project or another filter!");
	}

	return S_OK;
}

STDMETHODIMP CFilter::AddWebReference(BSTR bstrUrl, IDispatch** ppFile)
{
	CComPtr<IDispatch> spDispProject;
	HRESULT hr = get_Project(&spDispProject);
	CComQIPtr<IVCProjectImpl> spProject = spDispProject;
	RETURN_ON_FAIL_OR_NULL(hr, spProject);

	hr = spProject->AddWSDL(bstrUrl, (VCFilter*)this, ppFile);
	return hr;
}

STDMETHODIMP CFilter::get_Kind(BSTR* kind)
{
	CHECK_POINTER_VALID(kind);
	CComBSTR bstrKind = L"VCFilter";
	*kind = bstrKind.Detach();
	return S_OK;
}

STDMETHODIMP CFilter::get_VCProjectEngine(IDispatch** ppProjEngine)
{
	CHECK_POINTER_VALID(ppProjEngine);
	RETURN_ON_NULL(g_pProjectEngine);
	return g_pProjectEngine->QueryInterface(IID_IDispatch, (void **)ppProjEngine);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\vcpb\guid.c ===
#include <initguid.h>
#include <iadmw.h>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\vcpb\globals.cpp ===
// Globals.cpp
// implementation of CVCGlobals
///////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "projwriter.h"
#include "globals.h"


// CVCGlobals
///////////////////////////////////////////////////////////////////////////

CVCGlobals::CVCGlobals()
{
}

CVCGlobals::~CVCGlobals()
{
}

HRESULT CVCGlobals::CreateInstance( CVCGlobals** ppGlobals )
{
	CComObject<CVCGlobals> *pObj = NULL;  // created with 0 ref count
	HRESULT hr = CComObject<CVCGlobals>::CreateInstance( &pObj );
	if( SUCCEEDED( hr ) )
		pObj->AddRef();
	*ppGlobals = pObj;
	return hr;
}

// IVCGlobals
STDMETHODIMP CVCGlobals::GetValue( BSTR bstrName, BSTR *pbstrValue )
{
	CStringW strValue;
	// look up name in the map
	if( !m_GlobalsMap.Lookup( bstrName, strValue ) )
		RETURN_INVALID();

	// if we found it, set the return value
	CComBSTR bstrRet( strValue );
	*pbstrValue = bstrRet.Detach();
	return S_OK;
}

STDMETHODIMP CVCGlobals::SetValue( BSTR bstrName, BSTR bstrValue )
{
	m_GlobalsMap.SetAt( bstrName, bstrValue );
	return S_OK;
}

STDMETHODIMP CVCGlobals::GetPersistance( BSTR bstrName, VARIANT_BOOL *pbPersists )
{
	// if the name is not in the persistance map, it doesn't persist
	int *junk = NULL;
	if( !m_GlobalsPersistanceMap.Lookup( bstrName, (void*&)junk ) )
		*pbPersists = VARIANT_FALSE;
	else 
		*pbPersists = VARIANT_TRUE;
	return S_OK;
}

STDMETHODIMP CVCGlobals::SetPersistance( BSTR bstrName, VARIANT_BOOL bPersists )
{
	int *junk = NULL;
	if( bPersists )
		m_GlobalsPersistanceMap.SetAt( bstrName, (void*&)junk );
	else
		m_GlobalsPersistanceMap.RemoveKey( bstrName );

	return S_OK;
}

STDMETHODIMP CVCGlobals::GetCount( ULONG *count )
{
	*count = (ULONG) m_GlobalsMap.GetCount();
	return S_OK;
}

static VCPOSITION s_pos = 0;

STDMETHODIMP CVCGlobals::GetFirstItem( BSTR *pbstrName, BSTR *pbstrValue )
{
	s_pos = m_GlobalsMap.GetStartPosition();
	if( !s_pos )
	{
		// no items
		*pbstrName = NULL;
		*pbstrValue = NULL;
		return E_FAIL;
	}
	CStringW strName, strValue;
	m_GlobalsMap.GetNextAssoc( s_pos, strName, strValue );

	CComBSTR bstrName( strName );
	CComBSTR bstrValue( strValue );
	*pbstrName = bstrName.Detach();
	*pbstrValue = bstrValue.Detach();
	return S_OK;
}

STDMETHODIMP CVCGlobals::GetNextItem( BSTR *pbstrName, BSTR *pbstrValue )
{
	if( !s_pos )
	{
		// no more items
		*pbstrName = NULL;
		*pbstrValue = NULL;
		return E_FAIL;
	}
	CStringW strName, strValue;
	m_GlobalsMap.GetNextAssoc( s_pos, strName, strValue );

	CComBSTR bstrName( strName );
	CComBSTR bstrValue( strValue );
	*pbstrName = bstrName.Detach();
	*pbstrValue = bstrValue.Detach();
	return S_OK;
}

STDMETHODIMP CVCGlobals::SaveObject( IStream *xml, IVCPropertyContainer *pPropCnt, long nIndent )
{
	// for each name in the persistance map
	VCPOSITION pos;
	pos = m_GlobalsPersistanceMap.GetStartPosition();
	while( pos )
	{
		StartNodeHeader( xml, L"Global", false );
		CStringW strName, strValue;
		int *junk = NULL;
		m_GlobalsPersistanceMap.GetNextAssoc( pos, strName, (void*&)junk );
		// get the value for the item
		m_GlobalsMap.Lookup( strName, strValue );
		// write it out
		if( strName )
		{
			NodeAttributeWithSpecialChars( xml, L"Name", CComBSTR( strName ) );
			NodeAttributeWithSpecialChars( xml, L"Value", CComBSTR( strValue ) );
		}
		EndNodeHeader( xml, false );
		EndNode( xml, L"Globals", false );
	}

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\vcpb\libtool.h ===
// LibTool.h: Definition of the CVCLibrarianTool class
//
//////////////////////////////////////////////////////////////////////

#pragma once

#include "vctool.h"
#include "LinkLibHelp.h"
#include "SettingsPage.h"

// classes in this header
class CVCLibrarianTool;
class CLibrarianToolOptionHandler;

class CLibrarianToolOptionHandler : public COptionHandlerBase
{
public:
	DECLARE_OPTION_TABLE();

public:
	// default value handlers
	// string props
	virtual void GetDefaultValue( long id, BSTR *pVal, IVCPropertyContainer *pPropCnt = NULL );
	// integer props
	virtual void GetDefaultValue( long id, long *pVal, IVCPropertyContainer *pPropCnt = NULL );
	// boolean props
	virtual void GetDefaultValue( long id, VARIANT_BOOL *pVal, IVCPropertyContainer *pPropCnt = NULL );

protected:
	virtual BOOL SetEvenIfDefault(VARIANT *pVarDefault, long idOption);
	virtual BOOL SynthesizeOptionIfNeeded(IVCPropertyContainer* pPropContainer, long idOption);
	virtual BOOL SynthesizeOption(IVCPropertyContainer* pPropContainer, long idOption, CComVariant& rvar);
public:
	BOOL CreateOutputName(IVCPropertyContainer* pPropContainer, BSTR *bstrVal, BOOL bCheckForExistence = TRUE);
};

/////////////////////////////////////////////////////////////////////////////
// CVCLibrarianTool

class ATL_NO_VTABLE CVCLibrarianTool : 
	public IDispatchImpl<VCLibrarianTool, &IID_VCLibrarianTool, &LIBID_VCProjectEngineLibrary, PublicProjBuildTypeLibNumber,0, CVsTypeInfoHolder>, 
	public CComObjectRoot,
	public CLinkerLibrarianHelper,
	public CVCToolImpl
{
public:
	CVCLibrarianTool() 
	{
		m_nLowKey = VCLIBRARIANTOOL_MIN_DISPID;
		m_nHighKey = VCLIBRARIANTOOL_MAX_DISPID;
		m_nDirtyKey = VCLIBID_CmdLineOptionsDirty;
		m_nDirtyOutputsKey = VCLIBID_OutputsDirty;
	}
	static HRESULT CreateInstance(IVCPropertyContainer* pPropContainer, IVCToolImpl** ppTool);

BEGIN_COM_MAP(CVCLibrarianTool)
 	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IVCToolImpl)
	COM_INTERFACE_ENTRY(VCLibrarianTool)
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE(CVCLibrarianTool) 

// VCLibrarianTool
public:
	// general; /EXTRACT deliberately left out
	STDMETHOD(get_ToolName)(BSTR* pbstrToolName);	// friendly name of tool, e.g., "Librarian Tool"
	STDMETHOD(get_AdditionalOptions)(BSTR* pbstrAdditionalOptions);	// anything we don't know what to do with, given verbatim, in same order as entered, parent contributions first, goes after all other options
	STDMETHOD(put_AdditionalOptions)(BSTR bstrAdditionalOptions);
	STDMETHOD(get_OutputFile)(BSTR* pbstrOut);	// (/OUT:[file]) change the output file name (default is based on 1st lib or obj name on cmd line)
	STDMETHOD(put_OutputFile)(BSTR bstrOut);
	STDMETHOD(get_AdditionalDependencies)(BSTR* pbstrDependencies);	// additional inputs to the librarian tool such as extra libraries
	STDMETHOD(put_AdditionalDependencies)(BSTR bstrDependencies);
	STDMETHOD(get_AdditionalLibraryDirectories)(BSTR* pbstrLibPath);	// (/LIBPATH:[dir]) specify path to search for libraries on, can have multiple
	STDMETHOD(put_AdditionalLibraryDirectories)(BSTR bstrLibPath);
	STDMETHOD(get_SuppressStartupBanner)(VARIANT_BOOL* pbNoLogo);	// (/NOLOGO) enable suppression of copyright message (no explicit off)
	STDMETHOD(put_SuppressStartupBanner)(VARIANT_BOOL bNoLogo);
	STDMETHOD(get_ModuleDefinitionFile)(BSTR* pbstrDefFile);	// (/DEF:file)
	STDMETHOD(put_ModuleDefinitionFile)(BSTR bstrDefFile);
	STDMETHOD(get_IgnoreAllDefaultLibraries)(VARIANT_BOOL* pbNoDefault);	// (/NODEFAULTLIB) no default libraries not in docs
	STDMETHOD(put_IgnoreAllDefaultLibraries)(VARIANT_BOOL bNoDefault);
	STDMETHOD(get_IgnoreDefaultLibraryNames)(BSTR* pbstrLib);	// (/NODEFAULTLIB:[name]) ignore particular default library can have multiple not in docs
	STDMETHOD(put_IgnoreDefaultLibraryNames)(BSTR bstrLib);
	STDMETHOD(get_ExportNamedFunctions)(BSTR* pbstrSymbols);	// (/EXPORT:[symbol]) export function, can have multiple
	STDMETHOD(put_ExportNamedFunctions)(BSTR bstrSymbols);
	STDMETHOD(get_ForceSymbolReferences)(BSTR* pbstrSymbol);	// (/INCLUDE:[symbol]) force symbol reference, can have multiple
	STDMETHOD(put_ForceSymbolReferences)(BSTR bstrSymbol);
	// Automation properties
	STDMETHOD(get_ToolPath)(BSTR *pVal);
	STDMETHOD(get_PropertyOption)(BSTR bstrProp, long dispidProp, BSTR *pVal);
	STDMETHOD(get_VCProjectEngine)(IDispatch** projEngine)	{ return DoGetVCProjectEngine(projEngine); }

// IVCToolImpl
public:
	STDMETHOD(get_DefaultExtensions)(BSTR* pVal);
	STDMETHOD(put_DefaultExtensions)(BSTR newVal);
	STDMETHOD(GetAdditionalOptionsInternal)(IUnknown* pItem, VARIANT_BOOL bForBuild, VARIANT_BOOL bSkipLocal, BSTR* pbstrAdditionalOptions);
	STDMETHOD(GetBuildDescription)(IVCBuildAction* pAction, BSTR* pbstrBuildDescription);
	STDMETHOD(GetAdditionalIncludeDirectoriesInternal)(IVCPropertyContainer* pPropContainer, BSTR* pbstrIncDirs);
	STDMETHOD(get_ToolPathInternal)(BSTR* pbstrToolPath);
	STDMETHOD(get_Bucket)(long *pVal);
	STDMETHOD(GenerateOutput)(long type, IVCBuildActionList* plstActions, IVCBuildErrorContext* pEC);
	STDMETHOD(AffectsOutput)(long nPropID, VARIANT_BOOL* pbAffectsOutput);
	STDMETHOD(IsTargetTool)(IVCBuildAction* pAction, VARIANT_BOOL* pbTargetTool); // tool always operates on target, not on file
	STDMETHOD(IsDeleteOnRebuildFile)(LPCOLESTR szFile, VARIANT_BOOL* pbDelOnRebuild);
	STDMETHOD(get_ToolShortName)(BSTR* pbstrToolName);
	STDMETHOD(MatchName)(BSTR bstrName, VARIANT_BOOL bFullOnly, VARIANT_BOOL* pbMatches);
	STDMETHOD(CreateToolObject)(IVCPropertyContainer* pPropContainer, IVCToolImpl** ppToolObject);
	STDMETHOD(HasPrimaryOutputFromTool)(IUnknown* pItem, VARIANT_BOOL bSchmoozeOnly, VARIANT_BOOL* pbHasPrimaryOutput);	// returns TRUE only if tool generates a primary output (ex: linker)
	STDMETHOD(HasDependencies)(IVCBuildAction* pAction, VARIANT_BOOL* pbHasDependencies);
	STDMETHOD(GetDependencies)(IVCBuildAction* pAction, IVCBuildStringCollection** ppStrings, VARIANT_BOOL* pbUpToDate);
	STDMETHOD(CanScanForDependencies)(VARIANT_BOOL* pbIsScannable);
	STDMETHOD(CreatePageObject)(IUnknown **, CLSID*, IVCPropertyContainer *, IVCSettingsPage * );
	STDMETHOD(GetPrimaryOutputIDFromTool)(IUnknown* pItem, VARIANT_BOOL bSchmoozeOnly, long* pnOutputID);	// return a value only if tool generates a primary output (ex: linker)

	STDMETHOD(get_ToolDisplayIndex)(long* pIndex)
	{
		CHECK_POINTER_NULL(pIndex);
		*pIndex = TOOL_DISPLAY_INDEX_LIB;
		return S_OK;
	}

// helpers
public:
	virtual COptionHandlerBase* GetOptionHandler() { return &s_optHandler; }
	virtual HRESULT GetPrimaryOutputFromTool(IUnknown* pItem, VARIANT_BOOL bSchmoozeOnly, CPathW& rpath);	// return a value only if tool generates a primary output (ex: linker)
	virtual long GetPageCount()	{ return 2; }
	virtual GUID* GetPageIDs();

protected:
	virtual BOOL UsesResponseFiles() { return TRUE; }
	virtual BOOL CreateOutputName(IVCPropertyContainer* pPropContainer, BSTR* pbstrVal);
	virtual HRESULT DoHasPrimaryOutputFromTool(IUnknown* pItem, VARIANT_BOOL bSchmoozeOnly, VARIANT_BOOL* pbHasPrimaryOutput)
	{ return HasPrimaryOutputFromTool(pItem, bSchmoozeOnly, pbHasPrimaryOutput); }
	virtual LPCOLESTR GetToolFriendlyName();
	void InitToolName();
	virtual long GetToolID() { return IDS_Lib; }
	virtual BOOL IsExtraMultiProp(long idProp) { return (idProp == VCLIBID_AdditionalDependencies); }	// only override this if you have a multi-prop not in an option table
	virtual HRESULT GetAdditionalDependenciesInternal(IVCPropertyContainer* pItem, IVCBuildAction* pAction, BOOL bForSave, 
		BSTR* pbstrDependencies);		// additional things to add to command line

public:
	static CLibrarianToolOptionHandler s_optHandler;

protected:
	static GUID s_pPages[2];
	static BOOL s_bPagesInit;
	static CComBSTR s_bstrBuildDescription;
	static CComBSTR s_bstrToolName;
	static CComBSTR s_bstrExtensions;
};


/////////////////////////////////////////////////////////////////////////////
// CVCLibrarianPage

class ATL_NO_VTABLE CVCLibrarianPage :
	public IDispatchImpl<IVCLibrarianPage, &IID_IVCLibrarianPage, &LIBID_VCProjectEnginePrivateLibrary, PrivateProjBuildTypeLibNumber,0, CVsTypeInfoHolder>,
	public CPageObjectImpl<CVCLibrarianPage,VCLIBRARIANTOOL_MIN_DISPID,VCLIBRARIANTOOL_MAX_DISPID>,
	public CComObjectRoot
{
public:
BEGIN_COM_MAP(CVCLibrarianPage)
 	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IVCLibrarianPage)
	COM_INTERFACE_ENTRY(IPerPropertyBrowsing)
	COM_INTERFACE_ENTRY(IVsPerPropertyBrowsing)
	COM_INTERFACE_ENTRY(IVCPropertyContainer)
	COM_INTERFACE_ENTRY(IProvidePropertyBuilder)
END_COM_MAP()

	// IDispatch override
	STDMETHOD(Invoke)( DISPID dispid, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS *pdispParams, VARIANT *pvarResult, EXCEPINFO *pexcepInfo, UINT *puArgErr )
	{
		IDispatchImpl<IVCLibrarianPage, &IID_IVCLibrarianPage, &LIBID_VCProjectEnginePrivateLibrary, PrivateProjBuildTypeLibNumber,0, CVsTypeInfoHolder>::Invoke( dispid, riid, lcid, wFlags, pdispParams, pvarResult, pexcepInfo, puArgErr );
		return S_OK;
	}


// IVCLibrarianPage
public:
	STDMETHOD(get_OutputFile)(BSTR* pbstrOut);	// (/OUT:[file]) change the output file name (default is based on 1st lib or obj name on cmd line)
	STDMETHOD(put_OutputFile)(BSTR bstrOut);
	STDMETHOD(get_AdditionalDependencies)(BSTR* pbstrDependencies);	// additional inputs to the librarian tool such as extra libraries
	STDMETHOD(put_AdditionalDependencies)(BSTR bstrDependencies);
	STDMETHOD(get_AdditionalLibraryDirectories)(BSTR* pbstrLibPath);	// (/LIBPATH:[dir]) specify path to search for libraries on, can have multiple
	STDMETHOD(put_AdditionalLibraryDirectories)(BSTR bstrLibPath);
	STDMETHOD(get_SuppressStartupBanner)(enumSuppressStartupBannerUpBOOL* pbNoLogo);	// (/NOLOGO) enable suppression of copyright message (no explicit off)
	STDMETHOD(put_SuppressStartupBanner)(enumSuppressStartupBannerUpBOOL bNoLogo);
	STDMETHOD(get_ModuleDefinitionFile)(BSTR* pbstrDefFile);	// (/DEF:file)
	STDMETHOD(put_ModuleDefinitionFile)(BSTR bstrDefFile);
	STDMETHOD(get_IgnoreAllDefaultLibraries)(enumIgnoreAllDefaultLibrariesBOOL* pbNoDefault);	// (/NODEFAULTLIB) no default libraries not in docs
	STDMETHOD(put_IgnoreAllDefaultLibraries)(enumIgnoreAllDefaultLibrariesBOOL bNoDefault);
	STDMETHOD(get_IgnoreDefaultLibraryNames)(BSTR* pbstrLib);	// (/NODEFAULTLIB:[name]) ignore particular default library can have multiple not in docs
	STDMETHOD(put_IgnoreDefaultLibraryNames)(BSTR bstrLib);
	STDMETHOD(get_ExportNamedFunctions)(BSTR* pbstrSymbols);	// (/EXPORT:[symbol]) export function, can have multiple
	STDMETHOD(put_ExportNamedFunctions)(BSTR bstrSymbols);
	STDMETHOD(get_ForceSymbolReferences)(BSTR* pbstrSymbol);	// (/INCLUDE:[symbol]) force symbol reference, can have multiple
	STDMETHOD(put_ForceSymbolReferences)(BSTR bstrSymbol);

// helpers
public:
	virtual void GetBaseDefault(long id, CComVariant& varValue);
	virtual BOOL UseDirectoryPickerDialog(long id) { return (id == VCLIBID_AdditionalLibraryDirectories); }
};

// These macros are used to define enum ranges for tool switches.  If you add an enum property to the tool option
// table, please add a matching macro for it to this list.  Use of macros for range definitions helps in keeping
// maintenance of enum range checks as low as possible.
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\vcpb\libtool.cpp ===
// LibTool.cpp : Implementation of Librarian Tool

#include "stdafx.h"
#include "LibTool.h"
#include "FileRegistry.h"
#include "BldHelpers.h"

// constants
const wchar_t* const wszLibDefaultExtensions = L"*.obj;*.res;*.rsc;*.lib";	// remember to update vcpb.rgs if you change this...
const wchar_t* const wszLibDefaultName = L"$(OutDir)/$(ProjectName).lib";
const wchar_t* const wszLibDelOnRebuildExtensions = L"lib;map";


// static initializers
CComBSTR CVCLibrarianTool::s_bstrBuildDescription = L"";
CComBSTR CVCLibrarianTool::s_bstrToolName = L"";
CComBSTR CVCLibrarianTool::s_bstrExtensions = L"";
CLibrarianToolOptionHandler CVCLibrarianTool::s_optHandler;
GUID CVCLibrarianTool::s_pPages[2];
BOOL CVCLibrarianTool::s_bPagesInit = FALSE;


////////////////////////////////////////////////////////////////////////////////
// Option Table for the Librarian Tool switches

// NOTE: we're using macros for enum value ranges to help in keeping enum range checks as low maintenance as possible.
// If you add an enum to this table, make sure you use macros to define the upper and lower bounds and use CHECK_BOUNDS
// on the get/put methods associated with that property (both object model and property page).
// WARNING: if you change ANYTHING about a multi-prop here (including add/remove), be sure to update how the property
// is obtained on both the tool and page objects.
BEGIN_OPTION_TABLE(CLibrarianToolOptionHandler, L"VCLibrarianTool", IDS_Lib, TRUE /* pre & post */, FALSE /* case sensitive */)
	OPT_BSTR(OutputFile,				L"OUT:%s",				L"OutputFile",			single,		IDS_LibGeneral, VCLIBID)
	OPT_BSTR(AdditionalLibraryDirectories, L"LIBPATH:%s",		L"AdditionalLibraryDirectories",	multipleNoCase,	IDS_LibGeneral, VCLIBID)
	OPT_BOOL(SuppressStartupBanner,		L"|NOLOGO",				L"SuppressStartupBanner",			IDS_LibGeneral, VCLIBID)
	OPT_BSTR(ModuleDefinitionFile,		L"DEF:%s",				L"ModuleDefinitionFile", single,	IDS_LibGeneral, VCLIBID)
	OPT_BOOL(IgnoreAllDefaultLibraries,	L"|NODEFAULTLIB",		L"IgnoreAllDefaultLibraries",		IDS_LibGeneral, VCLIBID)
	OPT_BSTR(IgnoreDefaultLibraryNames,	L"NODEFAULTLIB:%s",		L"IgnoreDefaultLibraryNames", multipleNoCase, IDS_LibGeneral, VCLIBID)
	OPT_BSTR(ExportNamedFunctions,		L"EXPORT:%s",			L"ExportNamedFunctions", multiple,	IDS_LibGeneral, VCLIBID)
	OPT_BSTR(ForceSymbolReferences,		L"INCLUDE:%s",			L"ForceSymbolReferences", multiple,	IDS_LibGeneral, VCLIBID)
END_OPTION_TABLE()

// default value handlers
// string props
void CLibrarianToolOptionHandler::GetDefaultValue( long id, BSTR *pVal, IVCPropertyContainer *pPropContainer )
{
	switch( id )
	{
	case VCLIBID_OutputFile:
	{
		if( !pPropContainer )
			GetDefaultString( pVal );
		else
			*pVal = SysAllocString( wszLibDefaultName );
		break;
	}
// 	case VCLIBID_AdditionalOptions:
// 	case VCLIBID_AdditionalDependencies:
// 	case VCLIBID_AdditionalLibraryDirectories:
// 	case VCLIBID_ForceSymbolReferences:
// 	case VCLIBID_IgnoreAllDefaultLibraries:
// 	case VCLIBID_ExportNamedFunctions:
// 	case VCLIBID_ModuleDefinitionFile:
	default:
		COptionHandlerBase::GetDefaultString( pVal );
		break;
	}
}

// integer props
void CLibrarianToolOptionHandler::GetDefaultValue( long id, long *pVal, IVCPropertyContainer *pPropCnt )
{
	*pVal = 0;
}

// boolean props
void CLibrarianToolOptionHandler::GetDefaultValue( long id, VARIANT_BOOL *pVal, IVCPropertyContainer *pPropCnt )
{
	switch( id )
	{
	case VCLIBID_SuppressStartupBanner:
		GetValueTrue( pVal );
		break;
// 	case VCLIBID_IgnoreAllDefaultLibraries:
	default:
		COptionHandlerBase::GetValueFalse( pVal );
		break;
	}
}

BOOL CLibrarianToolOptionHandler::SetEvenIfDefault(VARIANT *pvarDefault, long idOption)
{
	CComVariant varDefault;
	BOOL bRet = FALSE;

	switch (idOption)
	{
	case VCLIBID_SuppressStartupBanner:
		varDefault = VARIANT_TRUE;
		varDefault.vt = VT_BOOL;
		bRet = TRUE;
		break;
	}
	varDefault.Detach(pvarDefault);
	return bRet;
}

BOOL CLibrarianToolOptionHandler::SynthesizeOptionIfNeeded(IVCPropertyContainer* pPropContainer, long idOption)
{
	switch (idOption)
	{
	case VCLIBID_OutputFile:
		return TRUE;
	default:
		return FALSE;
	}
}

BOOL CLibrarianToolOptionHandler::SynthesizeOption(IVCPropertyContainer* pPropContainer, long idOption, 
	CComVariant& rvar)
{
	switch (idOption)
	{
	case VCLIBID_OutputFile:
		{
			CComBSTR bstrOutputFile;
			if (CreateOutputName(pPropContainer, &bstrOutputFile, FALSE))
			{
				rvar.Clear();
				rvar = bstrOutputFile;
				return TRUE;
			}
			return FALSE;
		}
	default:
		VSASSERT(FALSE, "Case statement mismatch between SynthesizeOptionIfNeeded and SynthesizeOption");	// shouldn't be here!!
		return FALSE;
	}
}

BOOL CLibrarianToolOptionHandler::CreateOutputName(IVCPropertyContainer* pPropContainer, BSTR* pbstrVal,
	BOOL bCheckForExistence /* = TRUE */)
{
	if (bCheckForExistence &&
		pPropContainer->GetEvaluatedStrProperty(VCLIBID_OutputFile, pbstrVal) == S_OK)	// found it directly set, so use it
		return TRUE;

	CVCLibrarianTool::s_optHandler.GetDefaultValue( VCLINKID_OutputFile, pbstrVal, pPropContainer );
	HRESULT hr = pPropContainer->Evaluate(*pbstrVal, pbstrVal);

	return (SUCCEEDED(hr));
}

///////////////////////////////////////////////////////////////////////////////
// Librarian Tool
HRESULT CVCLibrarianTool::CreateInstance(IVCPropertyContainer* pPropContainer, IVCToolImpl** ppLibTool)
{
	CHECK_POINTER_NULL(ppLibTool);
	*ppLibTool = NULL;

	CComObject<CVCLibrarianTool> *pObj;
	HRESULT hr = CComObject<CVCLibrarianTool>::CreateInstance(&pObj);
	if (SUCCEEDED(hr))
	{
		if( pPropContainer )
			pObj->Initialize(pPropContainer);
		CVCLibrarianTool *pVar = pObj;
		pVar->AddRef();
		*ppLibTool = pVar;
	}
	return hr;
}

STDMETHODIMP CVCLibrarianTool::IsDeleteOnRebuildFile(LPCOLESTR szFile, VARIANT_BOOL* pbDelOnRebuild)
{
	CHECK_POINTER_NULL(pbDelOnRebuild);
	BOOL fDel = BldFileNameMatchesExtension(szFile, wszLibDelOnRebuildExtensions);
	*pbDelOnRebuild = fDel ? VARIANT_TRUE : VARIANT_FALSE;
	return S_OK;
}

LPCOLESTR CVCLibrarianTool::GetToolFriendlyName()
{
	InitToolName();
	return s_bstrToolName;
}

void CVCLibrarianTool::InitToolName()
{
	if (s_bstrToolName.Length() == 0)
	{
		if (!s_bstrToolName.LoadString(IDS_LIB_TOOLNAME))
			s_bstrToolName = szLibrarianToolType;
	}
}

///////////////////////////////////////////////////////////////////////////////
// Affects our output?
STDMETHODIMP CVCLibrarianTool::AffectsOutput(long nPropID, VARIANT_BOOL* pbAffectsOutput)
{
	CHECK_POINTER_NULL(pbAffectsOutput);
	*pbAffectsOutput = VARIANT_FALSE;

	// change our outputs?
	switch (nPropID)
	{
	case VCLIBID_OutputFile:			// *.lib
	case VCLIBID_ModuleDefinitionFile:	// *.def
	case VCLIBID_AdditionalDependencies:		// extra stuff to add to link line
	case VCLIBID_OutputsDirty:			// anything we care about dirty
	case VCLIBID_DependentInputs:		// inputs we pick up from dependent projects
		*pbAffectsOutput = VARIANT_TRUE;
		break;
	default:
		*pbAffectsOutput = VARIANT_FALSE;
		break;
	}

	return S_OK;
}

STDMETHODIMP CVCLibrarianTool::CreatePageObject(IUnknown **ppUnk, CLSID*pCLSID, IVCPropertyContainer *pPropCntr, IVCSettingsPage *pPage )
{
	// Get the list of pages
	if( CLSID_LibGeneral == *pCLSID )
	{
		CPageObjectImpl< CVCLibrarianPage,VCLIBRARIANTOOL_MIN_DISPID,VCLIBRARIANTOOL_MAX_DISPID >::CreateInstance(ppUnk, pPropCntr, pPage);
	}
	else
	{
		return S_FALSE;
	}
		
	return S_OK;
}


GUID* CVCLibrarianTool::GetPageIDs()
{ 
	if (s_bPagesInit == FALSE)
	{
		s_pPages[0] = __uuidof(LibGeneral);
		s_pPages[1] = __uuidof(LibAdditionalOptions);
		s_bPagesInit = TRUE;
	}
	return s_pPages; 
}

STDMETHODIMP CVCLibrarianTool::GenerateOutput(long type, IVCBuildActionList* plstActions, IVCBuildErrorContext* pEC)
{
	return DoGenerateOutput(type, plstActions, pEC, FALSE, this);
}

HRESULT CVCLibrarianTool::GetPrimaryOutputFromTool(IUnknown* pItem, VARIANT_BOOL bSchmoozeOnly, CPathW& rpath)
{
	return DoGetPrimaryOutputFromTool(pItem, rpath, FALSE);
}

STDMETHODIMP CVCLibrarianTool::HasPrimaryOutputFromTool(IUnknown* pItem, VARIANT_BOOL bSchmoozeOnly, VARIANT_BOOL* pbHasPrimaryOutput)
{
	return COptionHandlerBase::GetValueTrue( pbHasPrimaryOutput );
}

STDMETHODIMP CVCLibrarianTool::GetPrimaryOutputIDFromTool(IUnknown* pItem, VARIANT_BOOL bSchmoozeOnly, long* pnOutputID)
{
	CHECK_POINTER_NULL(pnOutputID);
	*pnOutputID = VCLIBID_OutputFile;
	return S_OK;
}

STDMETHODIMP CVCLibrarianTool::HasDependencies(IVCBuildAction* pAction, VARIANT_BOOL* pbHasDependencies)
{
	return DoHasDependencies(pAction, FALSE, pbHasDependencies);
}

STDMETHODIMP CVCLibrarianTool::GetDependencies(IVCBuildAction* pAction, IVCBuildStringCollection** ppStrings, 
	VARIANT_BOOL* pbUpToDate)
{
	return DoGetDependencies(pAction, ppStrings, pbUpToDate, FALSE);
}

BOOL CVCLibrarianTool::CreateOutputName(IVCPropertyContainer* pPropContainer, BSTR* pbstrVal)
{
	return s_optHandler.CreateOutputName(pPropContainer, pbstrVal, FALSE);
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////
// VCLibrarianTool
//////////////////////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CVCLibrarianTool::get_ToolName(BSTR* pbstrToolName)
{	// friendly name of tool, e.g., "Librarian Tool"
	CHECK_POINTER_VALID(pbstrToolName);
	InitToolName();
	s_bstrToolName.CopyTo(pbstrToolName);
	return S_OK;
}

STDMETHODIMP CVCLibrarianTool::get_AdditionalOptions(BSTR* pbstrAdditionalOptions)
{	// anything we don't know what to do with, given verbatim, in same order as entered, parent contributions first, goes after all other options
	return ToolGetStrProperty(VCLIBID_AdditionalOptions, pbstrAdditionalOptions);
}

STDMETHODIMP CVCLibrarianTool::put_AdditionalOptions(BSTR bstrAdditionalOptions)
{
	CHECK_ZOMBIE( m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE );
	return m_spPropertyContainer->SetStrProperty(VCLIBID_AdditionalOptions, bstrAdditionalOptions);
}

STDMETHODIMP CVCLibrarianTool::get_SuppressStartupBanner(VARIANT_BOOL* pbNoLogo)
{	// (/NOLOGO) enable suppression of copyright message (no explicit off)
	return ToolGetBoolProperty(VCLIBID_SuppressStartupBanner, pbNoLogo);
}

STDMETHODIMP CVCLibrarianTool::put_SuppressStartupBanner(VARIANT_BOOL bNoLogo)
{
	CHECK_ZOMBIE( m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE );
	CHECK_VARIANTBOOL( bNoLogo );
	return m_spPropertyContainer->SetBoolProperty(VCLIBID_SuppressStartupBanner, bNoLogo);
}

STDMETHODIMP CVCLibrarianTool::get_ModuleDefinitionFile(BSTR* pbstrDefFile)
{	// (/DEF:file)
	return ToolGetStrProperty(VCLIBID_ModuleDefinitionFile, pbstrDefFile);
}

STDMETHODIMP CVCLibrarianTool::put_ModuleDefinitionFile(BSTR bstrDefFile)
{
	CHECK_ZOMBIE( m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE );
	return m_spPropertyContainer->SetStrProperty(VCLIBID_ModuleDefinitionFile, bstrDefFile);
}

STDMETHODIMP CVCLibrarianTool::get_ExportNamedFunctions(BSTR* pbstrSymbols)
{	// (/EXPORT:[symbol]) export function, can have multiple
	return ToolGetStrProperty(VCLIBID_ExportNamedFunctions, pbstrSymbols, true /* local only */);
}

STDMETHODIMP CVCLibrarianTool::put_ExportNamedFunctions(BSTR bstrSymbols)
{
	CHECK_ZOMBIE( m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE );
	return m_spPropertyContainer->SetStrProperty(VCLIBID_ExportNamedFunctions, bstrSymbols);
}

STDMETHODIMP CVCLibrarianTool::get_AdditionalLibraryDirectories(BSTR* pbstrLibPath)
{	// (/LIBPATH:[dir]) specify path to search for libraries on, can have multiple
	return ToolGetStrProperty(VCLIBID_AdditionalLibraryDirectories, pbstrLibPath, true /* local only */);
}

STDMETHODIMP CVCLibrarianTool::put_AdditionalLibraryDirectories(BSTR bstrLibPath)
{
	CHECK_ZOMBIE( m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE );
	return m_spPropertyContainer->SetStrProperty(VCLIBID_AdditionalLibraryDirectories, bstrLibPath);
}

STDMETHODIMP CVCLibrarianTool::get_IgnoreAllDefaultLibraries(VARIANT_BOOL* pbNoDefault)
{	// (/NODEFAULTLIB) no default libraries not in docs
	return ToolGetBoolProperty(VCLIBID_IgnoreAllDefaultLibraries, pbNoDefault);
}

STDMETHODIMP CVCLibrarianTool::put_IgnoreAllDefaultLibraries(VARIANT_BOOL bNoDefault)
{
	CHECK_ZOMBIE( m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE );
	CHECK_VARIANTBOOL( bNoDefault );
	return m_spPropertyContainer->SetBoolProperty(VCLIBID_IgnoreAllDefaultLibraries, bNoDefault);
}

STDMETHODIMP CVCLibrarianTool::get_IgnoreDefaultLibraryNames(BSTR* pbstrLib)
{	// (/NODEFAULTLIB:[name]) ignore particular default library can have multiple not in docs
	return ToolGetStrProperty(VCLIBID_IgnoreDefaultLibraryNames, pbstrLib, true /* local only */);
}

STDMETHODIMP CVCLibrarianTool::put_IgnoreDefaultLibraryNames(BSTR bstrLib)
{
	CHECK_ZOMBIE( m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE );
	return m_spPropertyContainer->SetStrProperty(VCLIBID_IgnoreDefaultLibraryNames, bstrLib);
}

STDMETHODIMP CVCLibrarianTool::get_OutputFile(BSTR* pbstrOut)
{	// (/OUT:[file]) change the output file name (default is based on 1st lib or obj name on cmd line)
	return ToolGetStrProperty(VCLIBID_OutputFile, pbstrOut);
}

STDMETHODIMP CVCLibrarianTool::put_OutputFile(BSTR bstrOut)
{
	CHECK_ZOMBIE( m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE );
	return m_spPropertyContainer->SetStrProperty(VCLIBID_OutputFile, bstrOut);
}

STDMETHODIMP CVCLibrarianTool::get_AdditionalDependencies(BSTR* pbstrInputs)
{	// additional inputs to the librarian tool such as extra libraries
	return ToolGetStrProperty(VCLIBID_AdditionalDependencies, pbstrInputs, true /* local only */);
}

STDMETHODIMP CVCLibrarianTool::put_AdditionalDependencies(BSTR bstrInputs)
{
	CHECK_ZOMBIE( m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE );
	return m_spPropertyContainer->SetStrProperty(VCLIBID_AdditionalDependencies, bstrInputs);
}

STDMETHODIMP CVCLibrarianTool::get_ForceSymbolReferences(BSTR* pbstrSymbol)
{	// (/INCLUDE:[symbol]) force symbol reference, can have multiple
	return ToolGetStrProperty(VCLIBID_ForceSymbolReferences, pbstrSymbol, true /* local only */);
}

STDMETHODIMP CVCLibrarianTool::put_ForceSymbolReferences(BSTR bstrSymbol)
{
	CHECK_ZOMBIE( m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE );
	return m_spPropertyContainer->SetStrProperty(VCLIBID_ForceSymbolReferences, bstrSymbol);
}

// Automation properties
STDMETHODIMP CVCLibrarianTool::get_ToolPath(BSTR *pVal)
{
	CHECK_POINTER_VALID( pVal );
	*pVal = SysAllocString( szLibrarianToolPath );
	return S_OK;
}

STDMETHODIMP CVCLibrarianTool::get_PropertyOption(BSTR bstrProp, long dispidProp, BSTR *pVal)
{ 
	return DoGetPropertyOption(bstrProp, dispidProp, pVal); 
}

// IVCToolImpl
STDMETHODIMP CVCLibrarianTool::get_DefaultExtensions(BSTR* pVal)
{
	return DoGetDefaultExtensions(s_bstrExtensions, wszLibDefaultExtensions, pVal);
}

STDMETHODIMP CVCLibrarianTool::put_DefaultExtensions(BSTR newVal)
{
	s_bstrExtensions = newVal;
	return S_OK;
}

STDMETHODIMP CVCLibrarianTool::GetAdditionalOptionsInternal(IUnknown* pItem, VARIANT_BOOL bForBuild, VARIANT_BOOL bSkipLocal, 
	BSTR* pbstrAdditionalOptions)
{ 
	return GetProcessedAdditionalOptions(pItem, VCLIBID_AdditionalOptions, bForBuild, bSkipLocal, pbstrAdditionalOptions);
}

STDMETHODIMP CVCLibrarianTool::GetBuildDescription(IVCBuildAction* pAction, BSTR* pbstrBuildDescription)
{
	if (s_bstrBuildDescription.Length() == 0)
		s_bstrBuildDescription.LoadString(IDS_DESC_LIBING);
	return s_bstrBuildDescription.CopyTo(pbstrBuildDescription);
}

STDMETHODIMP CVCLibrarianTool::GetAdditionalIncludeDirectoriesInternal(IVCPropertyContainer* pPropContainer, BSTR* pbstrIncDirs)
{
	CHECK_POINTER_NULL(pbstrIncDirs);
	CHECK_READ_POINTER_NULL(pPropContainer);
	CComBSTR bstrTmp;
	HRESULT hr = pPropContainer->GetMultiProp(VCLIBID_AdditionalLibraryDirectories, L";", VARIANT_FALSE, &bstrTmp);
	if (SUCCEEDED(hr))
		pPropContainer->Evaluate(bstrTmp, pbstrIncDirs);
	else
		*pbstrIncDirs = bstrTmp.Detach();
	return hr;
}

STDMETHODIMP CVCLibrarianTool::get_ToolPathInternal(BSTR* pbstrToolPath)
{ 
	return get_ToolPath(pbstrToolPath);
}

STDMETHODIMP CVCLibrarianTool::get_Bucket(long *pVal)
{
	CHECK_POINTER_NULL( pVal );
	*pVal = BUCKET_LIB; 
	return S_OK;
}

STDMETHODIMP CVCLibrarianTool::IsTargetTool(IVCBuildAction* pAction, VARIANT_BOOL* pbTargetTool)
{ // tool always operates on target, not on file
	return COptionHandlerBase::GetValueTrue( pbTargetTool );
}

HRESULT CVCLibrarianTool::GetAdditionalDependenciesInternal(IVCPropertyContainer* pItem, IVCBuildAction* pAction, 
	BOOL bForSave, BSTR* pbstrInputs)
{		// additional things to add to command line
	return DoGetAdditionalDependenciesInternal(pItem, pAction, bForSave, pbstrInputs, GetOptionHandler(), 
		VCLIBID_AdditionalDependencies, VCLIBID_DependentInputs);
}

STDMETHODIMP CVCLibrarianTool::get_ToolShortName(BSTR* pbstrToolName)
{
	CHECK_POINTER_NULL(pbstrToolName);
	*pbstrToolName = SysAllocString( szLibrarianToolShortName );
	return S_OK;
}

STDMETHODIMP CVCLibrarianTool::MatchName(BSTR bstrName, VARIANT_BOOL bFullOnly, VARIANT_BOOL* pbMatches)
{
	return DoMatchName(bstrName, szLibrarianToolType, szLibrarianToolShortName, pbMatches);
}

STDMETHODIMP CVCLibrarianTool::CreateToolObject(IVCPropertyContainer* pPropContainer, IVCToolImpl** ppToolObject)
{ 
	return CreateInstance(pPropContainer, ppToolObject); 
}

STDMETHODIMP CVCLibrarianTool::CanScanForDependencies(VARIANT_BOOL* pbIsScannable)
{
	return COptionHandlerBase::GetValueTrue(pbIsScannable);
}

STDMETHODIMP CVCLibrarianPage::get_SuppressStartupBanner(enumSuppressStartupBannerUpBOOL* pbNoLogo)
{	// (/NOLOGO) enable suppression of copyright message (no explicit off)
	return GetEnumBoolProperty2(VCLIBID_SuppressStartupBanner, (long *)pbNoLogo);
}

STDMETHODIMP CVCLibrarianPage::put_SuppressStartupBanner(enumSuppressStartupBannerUpBOOL bNoLogo)
{
	return SetBoolProperty(VCLIBID_SuppressStartupBanner, bNoLogo);
}

STDMETHODIMP CVCLibrarianPage::get_ModuleDefinitionFile(BSTR* pbstrDefFile)
{	// (/DEF:file)
	return ToolGetStrProperty(VCLIBID_ModuleDefinitionFile, &(CVCLibrarianTool::s_optHandler), pbstrDefFile);
}

STDMETHODIMP CVCLibrarianPage::put_ModuleDefinitionFile(BSTR bstrDefFile)
{
	return SetStrProperty(VCLIBID_ModuleDefinitionFile, bstrDefFile);
}

STDMETHODIMP CVCLibrarianPage::get_ExportNamedFunctions(BSTR* pbstrSymbols)
{	// (/EXPORT:[symbol]) export function, can have multiple
	return ToolGetStrProperty(VCLIBID_ExportNamedFunctions, &(CVCLibrarianTool::s_optHandler), pbstrSymbols, true /* local only */);
}

STDMETHODIMP CVCLibrarianPage::put_ExportNamedFunctions(BSTR bstrSymbols)
{
	return SetStrProperty(VCLIBID_ExportNamedFunctions, bstrSymbols);
}

STDMETHODIMP CVCLibrarianPage::get_AdditionalLibraryDirectories(BSTR* pbstrLibPath)
{	// (/LIBPATH:[dir]) specify path to search for libraries on, can have multiple
	return ToolGetStrProperty(VCLIBID_AdditionalLibraryDirectories, &(CVCLibrarianTool::s_optHandler), pbstrLibPath, true /* local only */);
}

STDMETHODIMP CVCLibrarianPage::put_AdditionalLibraryDirectories(BSTR bstrLibPath)
{
	return SetStrProperty(VCLIBID_AdditionalLibraryDirectories, bstrLibPath);
}

// input and output
STDMETHODIMP CVCLibrarianPage::get_IgnoreAllDefaultLibraries(enumIgnoreAllDefaultLibrariesBOOL* pbNoDefault)
{	// (/NODEFAULTLIB) no default libraries not in docs
	return GetEnumBoolProperty2(VCLIBID_IgnoreAllDefaultLibraries, (long *)pbNoDefault);
}

STDMETHODIMP CVCLibrarianPage::put_IgnoreAllDefaultLibraries(enumIgnoreAllDefaultLibrariesBOOL bNoDefault)
{
	return SetBoolProperty(VCLIBID_IgnoreAllDefaultLibraries, bNoDefault);
}

STDMETHODIMP CVCLibrarianPage::get_IgnoreDefaultLibraryNames(BSTR* pbstrLib)
{	// (/NODEFAULTLIB:[name]) ignore particular default library can have multiple not in docs
	return ToolGetStrProperty(VCLIBID_IgnoreDefaultLibraryNames, &(CVCLibrarianTool::s_optHandler), pbstrLib, true /* local only */);
}

STDMETHODIMP CVCLibrarianPage::put_IgnoreDefaultLibraryNames(BSTR bstrLib)
{
	return SetStrProperty(VCLIBID_IgnoreDefaultLibraryNames, bstrLib);
}

STDMETHODIMP CVCLibrarianPage::get_OutputFile(BSTR* pbstrOut)
{	// (/OUT:[file]) change the output file name (default is based on 1st lib or obj name on cmd line)
	return ToolGetStrProperty(VCLIBID_OutputFile, &(CVCLibrarianTool::s_optHandler), pbstrOut);
}

STDMETHODIMP CVCLibrarianPage::put_OutputFile(BSTR bstrOut)
{
	return SetStrProperty(VCLIBID_OutputFile, bstrOut);
}

STDMETHODIMP CVCLibrarianPage::get_AdditionalDependencies(BSTR* pbstrInputs)
{	// additional inputs to the librarian tool such as extra libraries
	return ToolGetStrProperty(VCLIBID_AdditionalDependencies, &(CVCLibrarianTool::s_optHandler), pbstrInputs, true /* local only */);
}

STDMETHODIMP CVCLibrarianPage::put_AdditionalDependencies(BSTR bstrInputs)
{
	return SetStrProperty(VCLIBID_AdditionalDependencies, bstrInputs);
}

STDMETHODIMP CVCLibrarianPage::get_ForceSymbolReferences(BSTR* pbstrSymbol)
{	// (/INCLUDE:[symbol]) force symbol reference, can have multiple
	return ToolGetStrProperty(VCLIBID_ForceSymbolReferences, &(CVCLibrarianTool::s_optHandler), pbstrSymbol, true /* local only */);
}

STDMETHODIMP CVCLibrarianPage::put_ForceSymbolReferences(BSTR bstrSymbol)
{
	return SetStrProperty(VCLIBID_ForceSymbolReferences, bstrSymbol);
}

void CVCLibrarianPage::GetBaseDefault(long id, CComVariant& varValue)
{
	if (id == VCLIBID_OutputFile)
	{
		CComBSTR bstrVal;
		CVCLibrarianTool::s_optHandler.GetDefaultValue( VCLIBID_OutputFile, &bstrVal );
		varValue = bstrVal;
	}
	else if (id == VCLIBID_SuppressStartupBanner)
	{
		VARIANT_BOOL bVal;
		CVCLibrarianTool::s_optHandler.GetDefaultValue( VCLIBID_SuppressStartupBanner, &bVal );
		varValue = bVal;
	}

	else
		CBase::GetBaseDefault(id, varValue);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\vcpb\linklibhelp.h ===
#ifndef LINKLIBHELP_H
#define LINKLIBHELP_H

class CLinkerLibrarianHelper
{
public:
	HRESULT DoGenerateOutput(long type, IVCBuildActionList* pActions, IVCBuildErrorContext* pEC, BOOL bIsLinker,
		IVCToolImpl* pTool);
	HRESULT DoGetPrimaryOutputFromTool(IUnknown* pItem, CPathW& rpath, BOOL bIsLinker);
	HRESULT DoHasDependencies(IVCBuildAction* pAction, BOOL bIsLinker, VARIANT_BOOL* pbHasDependencies);
	HRESULT DoGetDependencies(IVCBuildAction* pAction, IVCBuildStringCollection** ppStrings, VARIANT_BOOL* pbUpToDate,
		BOOL bIsLinker, BOOL bAllowDirty = TRUE);

protected:
	virtual BOOL CreateOutputName(IVCPropertyContainer* pPropContainer, BSTR* pbstrVal) PURE;
	virtual HRESULT DoHasPrimaryOutputFromTool(IUnknown* pItem, VARIANT_BOOL bSchmoozeOnly, VARIANT_BOOL* pbHasPrimaryOutput) PURE;
	int GetNextDep(int nStartDep, CStringW& strDepList, int nDepLen, CStringW& strDep);
	HRESULT DoGetAdditionalDependenciesInternal(IVCPropertyContainer* pItem, IVCBuildAction* pAction, BOOL bForSave, 
		BSTR* pbstrInputs, COptionHandlerBase* poptHandler, UINT idUserDeps, UINT idProjDeps, LPCOLESTR szExtras = L"");

public:
	static void GetProjectCfgForItem(IUnknown* pItem, VCConfiguration** pProjCfg);
};

#endif // end include fence
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\vcpb\linktool.h ===
// VCLinkerTool.h: Definition of the CVCLinkerTool class
//
//////////////////////////////////////////////////////////////////////

#pragma once

#include "vctool.h"
#include "LinkLibHelp.h"
#include "LinkToolBase.h"

// classes in this header
class CVCLinkerTool;
class CLinkerToolOptionHandler;

class CLinkerToolOptionHandler : public COptionHandlerBase
{
public:
	DECLARE_OPTION_TABLE();

public:
	// default value handlers
	// string props
	virtual void GetDefaultValue( long id, BSTR *pVal, IVCPropertyContainer *pPropCnt = NULL );
	// integer props
	virtual void GetDefaultValue( long id, long *pVal, IVCPropertyContainer *pPropCnt = NULL );
	// boolean props
	virtual void GetDefaultValue( long id, VARIANT_BOOL *pVal, IVCPropertyContainer *pPropCnt = NULL );

	virtual HRESULT GenerateCommandLine(IVCPropertyContainer* pPropContainer, BOOL bForDisplay, commandLineOptionStyle fStyle, 
		CStringW& rstrCmdLine);

protected:
	virtual BOOL SetEvenIfDefault(VARIANT *pVarDefault, long idOption);
	virtual BOOL SynthesizeOptionIfNeeded(IVCPropertyContainer* pPropContainer, long idOption);
	virtual BOOL SynthesizeOption(IVCPropertyContainer* pPropContainer, long idOption, CComVariant& rvar);
	virtual void FormatScriptItem(const wchar_t* szOptionName, long idOption, long idOptionPage, CStringW& rstrOption);
	virtual void EvaluateSpecialString(CStringW& rstrVal, BOOL bIsMultiple, LPCOLESTR szOption, long idOption,
		LPCOLESTR szOptionName, long idOptionPage, IVCPropertyContainer* pPropContainer, BOOL bIncludeSlash, 
		BOOL bForDisplay, commandLineOptionStyle fStyle, CStringW& rstrTrailing, CStringW& rstrSwitch);
	virtual BOOL OverrideOptionSet(IVCPropertyContainer* pPropContainer, long idOption);

public:
	BOOL CreateOutputName(IVCPropertyContainer* pPropContainer, BSTR *bstrVal, BOOL bCheckForExistence = TRUE);
	BOOL CreatePDBName(IVCPropertyContainer* pPropContainer, BSTR *pbstrVal, BOOL bCheckForExistence = TRUE);
};

/////////////////////////////////////////////////////////////////////////////
// CVCLinkerTool

class ATL_NO_VTABLE CVCLinkerTool : 
	public IDispatchImpl<VCLinkerTool, &IID_VCLinkerTool, &LIBID_VCProjectEngineLibrary, PublicProjBuildTypeLibNumber,0, CVsTypeInfoHolder>, 
	public CComObjectRoot,
	public CLinkerLibrarianHelper,
	public CVCToolImpl
{
public:
	CVCLinkerTool() 
	{
		m_nLowKey = VCLINKERTOOL_MIN_DISPID;
		m_nHighKey = VCLINKERTOOL_MAX_DISPID;
		m_nDirtyKey = VCLINKID_CmdLineOptionsDirty;
		m_nDirtyOutputsKey = VCLINKID_OutputsDirty;
	}
	static HRESULT CreateInstance(IVCPropertyContainer* pPropContainer, IVCToolImpl** ppTool);

BEGIN_COM_MAP(CVCLinkerTool)
 	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IVCToolImpl)
	COM_INTERFACE_ENTRY(VCLinkerTool)
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE(CVCLinkerTool) 

// VCLinkerTool
public:
	// general
	STDMETHOD(get_ToolName)(BSTR* pbstrToolName);	// friendly name of tool, e.g., "Linker Tool"
	STDMETHOD(get_AdditionalOptions)(BSTR* pbstrAdditionalOptions);	// anything we don't know what to do with, given verbatim, in same order as entered, parent contributions first, goes after all other options
	STDMETHOD(put_AdditionalOptions)(BSTR bstrAdditionalOptions);
	STDMETHOD(get_OutputFile)(BSTR* pbstrOut);	// (/OUT:[file]) change the output file name (default is based on 1st lib or obj name on cmd line)
	STDMETHOD(put_OutputFile)(BSTR bstrOut);
	STDMETHOD(get_ShowProgress)(linkProgressOption* poptSetting);	// see enum above (/VERBOSE)
	STDMETHOD(put_ShowProgress)(linkProgressOption optSetting);
	STDMETHOD(get_Version)(BSTR* pbstrVersion);	// (/VERSION:version) put this version number into header of created image
	STDMETHOD(put_Version)(BSTR bstrVersion);
	STDMETHOD(get_LinkIncremental)(linkIncrementalType* poptSetting);	// (/INCREMENTAL:YES, /INCREMENTAL:NO, not set)
	STDMETHOD(put_LinkIncremental)(linkIncrementalType optSetting);
	STDMETHOD(get_SuppressStartupBanner)(VARIANT_BOOL* pbNoLogo);	// (/NOLOGO) enable suppression of copyright message (no explicit off)
	STDMETHOD(put_SuppressStartupBanner)(VARIANT_BOOL bNoLogo);
	STDMETHOD(get_IgnoreImportLibrary)(VARIANT_BOOL* pbIgnoreExportLib);	// ignore export .lib
	STDMETHOD(put_IgnoreImportLibrary)(VARIANT_BOOL bIgnoreExportLib);
	STDMETHOD(get_RegisterOutput)(VARIANT_BOOL* pbRegister);	// register the primary output of the build
	STDMETHOD(put_RegisterOutput)(VARIANT_BOOL bRegister);
	STDMETHOD(get_AdditionalLibraryDirectories)(BSTR* pbstrLibPath);	// (/LIBPATH:[dir]) specify path to search for libraries on, can have multiple
	STDMETHOD(put_AdditionalLibraryDirectories)(BSTR bstrLibPath);
	STDMETHOD(get_LinkDLL)(VARIANT_BOOL* pbDLL);	// (/DLL) build a DLL as the main output
	STDMETHOD(put_LinkDLL)(VARIANT_BOOL bDLL);
	// input
	STDMETHOD(get_AdditionalDependencies)(BSTR* pbstrDependencies);	// additional inputs to the link line (comdlg32.lib, etc.)
	STDMETHOD(put_AdditionalDependencies)(BSTR bstrDependencies);
	STDMETHOD(get_IgnoreAllDefaultLibraries)(VARIANT_BOOL* pbNoDefaults);	// (/NODEFAULTLIB) ignore all default libraries
	STDMETHOD(put_IgnoreAllDefaultLibraries)(VARIANT_BOOL bNoDefaults);
	STDMETHOD(get_IgnoreDefaultLibraryNames)(BSTR* pbstrLib);	// (/NODEFAULTLIB:[name]) ignore particular default library, can have multiple
	STDMETHOD(put_IgnoreDefaultLibraryNames)(BSTR bstrLib);
	STDMETHOD(get_ModuleDefinitionFile)(BSTR* pbstrDefFile);	// (/DEF:file) use/specify module definition file
	STDMETHOD(put_ModuleDefinitionFile)(BSTR bstrDefFile);
	STDMETHOD(get_AddModuleNamesToAssembly)(BSTR* pbstrNonAssy);	// (/ASSEMBLYMODULE:file) imports a non-assembly file
	STDMETHOD(put_AddModuleNamesToAssembly)(BSTR bstrNonAssy);
	STDMETHOD(get_EmbedManagedResourceFile)(BSTR* pbstrRes);	// (/ASSEMBLYRESOURCE:file) embed an assembly resource file
	STDMETHOD(put_EmbedManagedResourceFile)(BSTR bstrRes);
	STDMETHOD(get_ForceSymbolReferences)(BSTR* pbstrSymbol);	// (/INCLUDE:[symbol]) force symbol reference, can have multiple
	STDMETHOD(put_ForceSymbolReferences)(BSTR bstrSymbol);
	STDMETHOD(get_DelayLoadDLLs)(BSTR* pbstrDLLName);	// (/DELAYLOAD:[dll_name]) delay load specified DLL, can have multiple
	STDMETHOD(put_DelayLoadDLLs)(BSTR bstrDLLName);
	// MIDL
	STDMETHOD(get_MidlCommandFile)(BSTR* pbstrMidlCmdFile);	// (/midl:<@midl cmd file>) specify response file for MIDL commands to use
	STDMETHOD(put_MidlCommandFile)(BSTR bstrMidlCmdFile);
	STDMETHOD(get_IgnoreEmbeddedIDL)(VARIANT_BOOL* pbIgnoreIDL);	// (/ignoreidl) ignore .idlsym sections of .obj files
	STDMETHOD(put_IgnoreEmbeddedIDL)(VARIANT_BOOL bIgnoreIDL);
	STDMETHOD(get_MergedIDLBaseFileName)(BSTR* pbstrIDLFile);	// (/idlout:<filename>) name intermediate IDL output file
	STDMETHOD(put_MergedIDLBaseFileName)(BSTR bstrIDLFile);
	STDMETHOD(get_TypeLibraryFile)(BSTR* pbstrTLBFile);	// (/tlbout:<filename>) name intermediate typelib output file
	STDMETHOD(put_TypeLibraryFile)(BSTR bstrTLBFile);
	STDMETHOD(get_TypeLibraryResourceID)(long* pnResID);	// (/tlbid:<id>) specify resource ID for generated .tlb file
	STDMETHOD(put_TypeLibraryResourceID)(long nResID);
	// debug
	STDMETHOD(get_GenerateDebugInformation)(VARIANT_BOOL* pbDebug);	// (/DEBUG) generate debug info
	STDMETHOD(put_GenerateDebugInformation)(VARIANT_BOOL bDebug);
	STDMETHOD(get_ProgramDatabaseFile)(BSTR* pbstrFile);	// (/PDB:file) use program database
	STDMETHOD(put_ProgramDatabaseFile)(BSTR bstrFile);
	STDMETHOD(get_StripPrivateSymbols)(BSTR* pbstrStrippedPDB);	// (/PDBSTRIPPED:file) strip private symbols from PDB
	STDMETHOD(put_StripPrivateSymbols)(BSTR bstrStrippedPDB);
	STDMETHOD(get_GenerateMapFile)(VARIANT_BOOL* pbMap);	// (/MAP[:file]) generate map file during linking
	STDMETHOD(put_GenerateMapFile)(VARIANT_BOOL bMap);
	STDMETHOD(get_MapFileName)(BSTR* pbstrMapFile);	// optional argument to GenerateMapFile property
	STDMETHOD(put_MapFileName)(BSTR bstrMapFile);
	STDMETHOD(get_MapExports)(VARIANT_BOOL* pbExports);	// (/MAPINFO:EXPORTS) include exported functions in map info
	STDMETHOD(put_MapExports)(VARIANT_BOOL bExports);
	STDMETHOD(get_MapLines)(VARIANT_BOOL* pbLines);	// (/MAPINFO:LINES) include line number info in map info
	STDMETHOD(put_MapLines)(VARIANT_BOOL bLines);
	// System
	STDMETHOD(get_SubSystem)(subSystemOption* poptSetting);	// see subSystem enum (/SUBSYSTEM)
	STDMETHOD(put_SubSystem)(subSystemOption optSetting);
	STDMETHOD(get_HeapReserveSize)(long* pnReserveSize);	// (/HEAP:reserve[,commit]) total heap allocation size in virtual memory
	STDMETHOD(put_HeapReserveSize)(long nReserveSize);
	STDMETHOD(get_HeapCommitSize)(long* pnCommitSize);	// (/HEAP:reserve[,commit]) total heap allocation size in physical memory
	STDMETHOD(put_HeapCommitSize)(long nCommitSize);
	STDMETHOD(get_StackReserveSize)(long* pnReserveSize);	// (/STACK:reserve[,commit]) total stack allocation size in virtual memory
	STDMETHOD(put_StackReserveSize)(long nReserveSize);
	STDMETHOD(get_StackCommitSize)(long* pnCommitSize);	// (/STACK:reserve[,commit]) total stack allocation size in physical memory
	STDMETHOD(put_StackCommitSize)(long nCommitSize);
	STDMETHOD(get_LargeAddressAware)(addressAwarenessType* poptSetting);	// (/LARGEADDRESSAWARE[:NO]) tells the linker the app can handle addresses greater than 2GB
	STDMETHOD(put_LargeAddressAware)(addressAwarenessType optSetting);
	STDMETHOD(get_TerminalServerAware)(termSvrAwarenessType* poptSetting);	// (/TSAWARE, /TSAWARE:NO, not set) not in docs
	STDMETHOD(put_TerminalServerAware)(termSvrAwarenessType optSetting);
	STDMETHOD(get_SwapRunFromCD)(VARIANT_BOOL* pbRun);	// swap run from the CD (/SWAPRUN:CD)
	STDMETHOD(put_SwapRunFromCD)(VARIANT_BOOL bRun);
	STDMETHOD(get_SwapRunFromNet)(VARIANT_BOOL* pbRun);	// swap run from the net (/SWAPRUN:NET)
	STDMETHOD(put_SwapRunFromNet)(VARIANT_BOOL bRun);
	// optimization
	STDMETHOD(get_OptimizeReferences)(optRefType* poptSetting);	// (/OPT:REF, /OPT:NOREF, not set) eliminate/keep functions & data never referenced
	STDMETHOD(put_OptimizeReferences)(optRefType optSetting);
	STDMETHOD(get_EnableCOMDATFolding)(optFoldingType* poptSetting);	// (/OPT:ICF, /OPT:NOICF, not set) eliminate/keep redundant COMDAT data (data folding)
	STDMETHOD(put_EnableCOMDATFolding)(optFoldingType optSetting);
	STDMETHOD(get_OptimizeForWindows98)(optWin98Type* poptSetting);	// (/OPT:WIN98, /OPT:NOWIN98, not set) 
	STDMETHOD(put_OptimizeForWindows98)(optWin98Type optSetting);
	STDMETHOD(get_FunctionOrder)(BSTR* pbstrOrder);	// (/ORDER:@[file]) place functions in order specified in file
	STDMETHOD(put_FunctionOrder)(BSTR bstrOrder);
	STDMETHOD(get_LinkTimeCodeGeneration)(VARIANT_BOOL* pbCodeGen);	// (/LTCG) enable link time code gen of objects compiled with /GL
	STDMETHOD(put_LinkTimeCodeGeneration)(VARIANT_BOOL bCodeGen);
	// advanced
	STDMETHOD(get_EntryPointSymbol)(BSTR* pbstrEntry);	// (/ENTRY:[symbol]) set entry point address for EXE or DLL incompatible with /NOENTRY
	STDMETHOD(put_EntryPointSymbol)(BSTR bstrEntry);
	STDMETHOD(get_ResourceOnlyDLL)(VARIANT_BOOL* pbNoEntry);	// (/NOENTRY) no entry point.  required for resource-only DLLs incompatible with /ENTRY
	STDMETHOD(put_ResourceOnlyDLL)(VARIANT_BOOL bNoEntry);
	STDMETHOD(get_SetChecksum)(VARIANT_BOOL* pbRelease);	// (/RELEASE) set the checksum in the header of a .exe
	STDMETHOD(put_SetChecksum)(VARIANT_BOOL bRelease);
	STDMETHOD(get_BaseAddress)(BSTR* pbstrAddress);	// (/BASE:{address| filename,key}) base address to place program at can be numeric or string
	STDMETHOD(put_BaseAddress)(BSTR bstrAddress);
	STDMETHOD(get_TurnOffAssemblyGeneration)(VARIANT_BOOL* pbNoAssy);	// (/NOASSEMBLY) cause the output file to be built without an assembly
	STDMETHOD(put_TurnOffAssemblyGeneration)(VARIANT_BOOL bNoAssy);
	STDMETHOD(get_SupportUnloadOfDelayLoadedDLL)(VARIANT_BOOL* pbDelay);	// (/DELAY:UNLOAD) use to allow explicit unloading of the DLL
	STDMETHOD(put_SupportUnloadOfDelayLoadedDLL)(VARIANT_BOOL bDelay);
	STDMETHOD(get_MergeSections)(BSTR* pbstrMerge);	// (/MERGE:from=to) merge section 'from' into section 'to'
	STDMETHOD(put_MergeSections)(BSTR bstrMerge);
	STDMETHOD(get_ImportLibrary)(BSTR* pbstrImportLib);	// (/IMPLIB:[library]) generate specified import library
	STDMETHOD(put_ImportLibrary)(BSTR bstrImportLib);
	STDMETHOD(get_TargetMachine)(machineTypeOption* poptSetting);	// (/MACHINE:type) specify target platform
	STDMETHOD(put_TargetMachine)(machineTypeOption optSetting);

	// Automation properties
	STDMETHOD(get_ToolPath)(BSTR *pVal);
	STDMETHOD(get_PropertyOption)(BSTR bstrProp, long dispidProp, BSTR *pVal) { return DoGetPropertyOption(bstrProp, dispidProp, pVal); }
	STDMETHOD(get_VCProjectEngine)(IDispatch** projEngine)	{ return DoGetVCProjectEngine(projEngine); }

// IVCToolImpl
public:
	STDMETHOD(get_DefaultExtensions)(BSTR* pVal);
	STDMETHOD(put_DefaultExtensions)(BSTR newVal);
	STDMETHOD(GetAdditionalOptionsInternal)(IUnknown* pItem, VARIANT_BOOL bForBuild, VARIANT_BOOL bSkipLocal, BSTR* pbstrAdditionalOptions);
	STDMETHOD(GetBuildDescription)(IVCBuildAction* pAction, BSTR* pbstrBuildDescription);
	STDMETHOD(GetAdditionalIncludeDirectoriesInternal)(IVCPropertyContainer* pPropContainer, BSTR* pbstrIncDirs);
	STDMETHOD(get_ToolPathInternal)(BSTR* pbstrToolPath);
	STDMETHOD(get_Bucket)(long *pVal);
	STDMETHOD(GenerateOutput)(long type, IVCBuildActionList* plstActions, IVCBuildErrorContext* pEC);
	STDMETHOD(AffectsOutput)(long nPropID, VARIANT_BOOL* pbAffectsOutput);
	STDMETHOD(IsTargetTool)(IVCBuildAction* pAction, VARIANT_BOOL* pbTargetTool); // tool always operates on target, not on file
	STDMETHOD(IsDeleteOnRebuildFile)(LPCOLESTR szFile, VARIANT_BOOL* pbDelOnRebuild);
	STDMETHOD(get_ToolShortName)(BSTR* pbstrToolName);
	STDMETHOD(MatchName)(BSTR bstrName, VARIANT_BOOL bFullOnly, VARIANT_BOOL* pbMatches);
	STDMETHOD(CreateToolObject)(IVCPropertyContainer* pPropContainer, IVCToolImpl** ppToolObject);
	STDMETHOD(HasPrimaryOutputFromTool)(IUnknown* pItem, VARIANT_BOOL bSchmoozeOnly, VARIANT_BOOL* pbHasPrimaryOutput);	// returns TRUE only if tool generates a primary output (ex: linker)
	STDMETHOD(GetImportLibraryFromTool)(IUnknown* pItem, BSTR* pbstrPath);	// returns TRUE only if tool generates an import library
	STDMETHOD(HasDependencies)(IVCBuildAction* pAction, VARIANT_BOOL* pbHasDependencies);
	STDMETHOD(GetDependencies)(IVCBuildAction* pAction, IVCBuildStringCollection** ppStrings, VARIANT_BOOL* pbUpToDate);
	STDMETHOD(CanScanForDependencies)(VARIANT_BOOL* pbIsScannable);
	STDMETHOD(IsSpecialConsumable)(LPCOLESTR szPath, VARIANT_BOOL* pbSpecial);
	STDMETHOD(GetCommandLinesForBuild)(IVCBuildActionList* pActions, bldAttributes attrib, IVCBuildEngine* pBldEngine, 
		IVCBuildErrorContext* pErrorContext, IVCCommandLineList** ppCmds);
	STDMETHOD(CreatePageObject)(IUnknown **, CLSID*, IVCPropertyContainer *, IVCSettingsPage * );
	STDMETHOD(GetProgramDatabaseFromTool)(IVCPropertyContainer* pContainer, VARIANT_BOOL bSchmoozeOnly, BSTR* pbstrPDB);
	STDMETHOD(GetPrimaryOutputIDFromTool)(IUnknown* pItem, VARIANT_BOOL bSchmoozeOnly, long* pnOutputID);	// return a value only if tool generates a primary output (ex: linker)

	STDMETHOD(get_ToolDisplayIndex)(long* pIndex)
	{
		CHECK_POINTER_NULL(pIndex);
		*pIndex = TOOL_DISPLAY_INDEX_LINK;
		return S_OK;
	}

// helpers

public:
	virtual COptionHandlerBase* GetOptionHandler() { return &s_optHandler; }
	virtual HRESULT GetPrimaryOutputFromTool(IUnknown* pItem, VARIANT_BOOL bSchmoozeOnly, CPathW& rpath);	// return a value only if tool generates a primary output (ex: linker)
	virtual long GetPageCount()	{ return 8; }
	virtual GUID* GetPageIDs();

	virtual void SaveSpecialProps(IStream *xml, IVCPropertyContainer *pPropCnt);

protected:
	virtual BOOL UsesResponseFiles() { return TRUE; }
	virtual BOOL CreateOutputName(IVCPropertyContainer* pPropContainer, BSTR* pbstrVal);
	virtual HRESULT DoHasPrimaryOutputFromTool(IUnknown* pItem, VARIANT_BOOL bSchmoozeOnly, VARIANT_BOOL* pbHasPrimaryOutput)
	{ return HasPrimaryOutputFromTool(pItem, bSchmoozeOnly, pbHasPrimaryOutput); }
	virtual LPCOLESTR GetToolFriendlyName();
	void InitToolName();
	virtual long GetToolID() { return IDS_Link; }
	virtual BOOL IsExtraMultiProp(long idProp) { return (idProp == VCLINKID_AdditionalDependencies); }	// only override this if you have a multi-prop not in an option table
	virtual HRESULT GetAdditionalDependenciesInternal(IVCPropertyContainer* pItem, IVCBuildAction* pAction, BOOL bForSave, 
		BSTR* pbstrInputs);		// additional things to add to command line

protected:
	static const wchar_t *s_pszDelOnRebuildExtensions;
	static CComBSTR s_bstrBuildDescription;
	static CComBSTR s_bstrToolName;
	static CComBSTR s_bstrExtensions;

	static GUID s_pPages[8];
	static BOOL s_bPagesInit;

public:
	static CLinkerToolOptionHandler s_optHandler;
};

// These macros are used to define enum ranges for tool switches.  If you add an enum property to the tool option
// table, please add a matching macro for it to this list.  Use of macros for range definitions helps in keeping
// maintenance of enum range checks as low as possible.
#define ShowProgressMax			 2
#define LinkIncrMax				 2
#define TSAwareMax				 2
#define LinkSubSystemMax		 2
#define LargeAddrMax			 2
#define OptRefMax				 2
#define OptFoldMax				 2
#define OptWin98Max				 2
#define TargetMachineMax		 1
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\vcpb\makefile.inc ===
!include $(_NTROOT)\private\vc7addon\vsenv.inc
!include $(VSROOT)\Src\VC\IDE\makefile.inc


$(O)\$(RCFILE).res: $(RCFILE).rc $(VSBUILT)\$(BUILT_FLAVOR)\bin\$(TARGET_DIRECTORY)\vcpb2.tlb

!ifdef URTTARGET

$(URTTARGET)\Microsoft.VisualStudio.VCProjectEngine.dll: $(VSBUILT)\$(BUILT_FLAVOR)\bin\$(TARGET_DIRECTORY)\VCPB2.tlb
    echo Building and signing Microsoft.VisualStudio.VCProjectEngine.dll (com+ Metadata) from vcpb2.tlb > con
    SET OLDPATHBACK=%%PATH%%
    set PATH=%%PATH%%;$(VSBUILT)\$(BUILT_FLAVOR)\bin\$(TARGET_DIRECTORY);$(URTTARGET)
    $(TLBIMP_CMD)  /nologo /strictref /PublicKey:$(COMMON_ROOT)\security\FinalPublicKey.snk  /Primary $(VSBUILT)\$(BUILT_FLAVOR)\bin\$(TARGET_DIRECTORY)\VCPB2.tlb /Out:$(URTTARGET)\Microsoft.VisualStudio.VCProjectEngine.dll
    $(REGASM_CMD) /regfile:$(O)\Microsoft.VisualStudio.VCProjectEngine.reg $(URTTARGET)\Microsoft.VisualStudio.VCProjectEngine.dll
    $(DEVTOOLS)\$(PROCESSOR_ARCHITECTURE)\radtools\perl.exe $(VSROOT)\public\tools\reg2vrg.pl < $(O)\Microsoft.VisualStudio.VCProjectEngine.reg > $(VSBUILT)\$(BUILT_FLAVOR)\bin\$(TARGET_DIRECTORY)\Microsoft.VisualStudio.VCProjectEngine.vrg

    $(VSPUBLIC)\tools\vsrebase.bat $(URTTARGET)\Microsoft.VisualStudio.VCProjectEngine.dll
    SET PATH=%%OLDPATHBACK%%

!endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\vcpb\linktoolbase.h ===
// VCLinkerBaseTool.h: Definition of the CVCLinkerBaseTool class
//
//////////////////////////////////////////////////////////////////////

#pragma once

#include "vctool.h"
#include "settingspage.h"

template<class T, class IFace>
class ATL_NO_VTABLE CVCLinkerBasePage :
	public IDispatchImpl<IFace, &(__uuidof(IFace)), &LIBID_VCProjectEnginePrivateLibrary, PrivateProjBuildTypeLibNumber, 0, CVsTypeInfoHolder>,
	public CPageObjectImpl<T, VCLINKERTOOL_MIN_DISPID, VCLINKERTOOL_MAX_DISPID>,
	public CComObjectRoot
{
public:
BEGIN_COM_MAP(T)
	COM_INTERFACE_ENTRY(IPerPropertyBrowsing)
	COM_INTERFACE_ENTRY(IVsPerPropertyBrowsing)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IFace)
	COM_INTERFACE_ENTRY(IVCPropertyContainer)
	COM_INTERFACE_ENTRY(IProvidePropertyBuilder)
END_COM_MAP()

	// IDispatch override
	STDMETHOD(Invoke)( DISPID dispid, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS *pdispParams, VARIANT *pvarResult, EXCEPINFO *pexcepInfo, UINT *puArgErr )
	{
		IDispatchImpl<IFace, &(__uuidof(IFace)), &LIBID_VCProjectEnginePrivateLibrary, PrivateProjBuildTypeLibNumber,0, CVsTypeInfoHolder>::Invoke( dispid, riid, lcid, wFlags, pdispParams, pvarResult, pexcepInfo, puArgErr );
		return S_OK;
	}

// IVCPropertyContainer override
public:
	STDMETHOD(Commit)()
	{
		if (m_pContainer)
		{
			// need to set/unset 'generate map file' if name changes and user didn't explictly change the 'generate'
			CComVariant varName;
			if (m_pContainer->GetLocalProp(VCLINKID_MapFileName, &varName) == S_OK)	// name changed
			{
				CComVariant var;
				// if both changed locally, don't do anything about keeping them in sync
				if (m_pContainer->GetLocalProp(VCLINKID_GenerateMapFile, &var) != S_OK)	
				{
					CStringW strName = varName.bstrVal;
					strName.TrimLeft();
					if (m_pContainer->GetProp(VCLINKID_GenerateMapFile, &var) != S_OK)
					{
						var.vt = VT_BOOL;
						var.boolVal = VARIANT_FALSE;
					}
					if (var.boolVal && strName.IsEmpty())
					{
						var.boolVal = VARIANT_FALSE;
						m_pContainer->SetProp(VCLINKID_GenerateMapFile, var);
					}
					else if (!var.boolVal && !strName.IsEmpty())
					{
						var.boolVal = VARIANT_TRUE;
						m_pContainer->SetProp(VCLINKID_GenerateMapFile, var);
					}
				}
			}
		}
		return CPageObjectImpl<T, VCLINKERTOOL_MIN_DISPID, VCLINKERTOOL_MAX_DISPID>::Commit();
	}
};


class ATL_NO_VTABLE CVCLinkerGeneralPage :
	public CVCLinkerBasePage<CVCLinkerGeneralPage, IVCLinkerGeneralPage>
{
// IVCLinkerGeneralPage
public:
	STDMETHOD(get_AdditionalOptions)(BSTR* pbstrAdditionalOptions);
	STDMETHOD(put_AdditionalOptions)(BSTR bstrAdditionalOptions);
	STDMETHOD(get_OutputFile)(BSTR* pbstrOut);	// (/OUT:[file]) change the output file name (default is based on 1st lib or obj name on cmd line)
	STDMETHOD(put_OutputFile)(BSTR bstrOut);
	STDMETHOD(get_ShowProgress)(linkProgressOption* poptSetting);	// see enum above (/VERBOSE)
	STDMETHOD(put_ShowProgress)(linkProgressOption optSetting);
	STDMETHOD(get_Version)(BSTR* pbstrVersion);	// (/VERSION:version) put this version number into header of created image
	STDMETHOD(put_Version)(BSTR bstrVersion);
	STDMETHOD(get_LinkIncremental)(linkIncrementalType* poptSetting);	// (/INCREMENTAL:YES, /INCREMENTAL:NO, not set)
	STDMETHOD(put_LinkIncremental)(linkIncrementalType optSetting);
	STDMETHOD(get_SuppressStartupBanner)(enumSuppressStartupBannerUpBOOL* pbNoLogo);	// (/NOLOGO) enable suppression of copyright message (no explicit off)
	STDMETHOD(put_SuppressStartupBanner)(enumSuppressStartupBannerUpBOOL bNoLogo);
	STDMETHOD(get_IgnoreImportLibrary)(enumBOOL* pbIgnore);	// ignore export .lib
	STDMETHOD(put_IgnoreImportLibrary)(enumBOOL bIgnore);
	STDMETHOD(get_RegisterOutput)(enumBOOL* pbRegister);	// register the primary output of the build
	STDMETHOD(put_RegisterOutput)(enumBOOL bRegister);
	STDMETHOD(get_AdditionalLibraryDirectories)(BSTR* pbstrLibPath);	// (/LIBPATH:[dir]) specify path to search for libraries on, can have multiple
	STDMETHOD(put_AdditionalLibraryDirectories)(BSTR bstrLibPath);

// helpers
public:
	virtual void GetBaseDefault(long id, CComVariant& varValue);
	virtual BOOL UseDirectoryPickerDialog(long id) { return (id == VCLINKID_AdditionalLibraryDirectories); }
};

class ATL_NO_VTABLE CVCLinkerInputPage :
	public CVCLinkerBasePage<CVCLinkerInputPage, IVCLinkerInputPage>
{
// IVCLinkerInputPage
public:
	STDMETHOD(get_AdditionalDependencies)(BSTR* pbstrInputs);	// additional inputs for the link path (comdlg32.lib, etc.)
	STDMETHOD(put_AdditionalDependencies)(BSTR bstrInputs);
	STDMETHOD(get_IgnoreAllDefaultLibraries)(enumIgnoreAllDefaultLibrariesBOOL* pbNoDefaults);	// (/NODEFAULTLIB) ignore all default libraries
	STDMETHOD(put_IgnoreAllDefaultLibraries)(enumIgnoreAllDefaultLibrariesBOOL bNoDefaults);
	STDMETHOD(get_IgnoreDefaultLibraryNames)(BSTR* pbstrLib);	// (/NODEFAULTLIB:[name]) ignore particular default library, can have multiple
	STDMETHOD(put_IgnoreDefaultLibraryNames)(BSTR bstrLib);
	STDMETHOD(get_ModuleDefinitionFile)(BSTR* pbstrDefFile);	// (/DEF:file) use/specify module definition file
	STDMETHOD(put_ModuleDefinitionFile)(BSTR bstrDefFile);
	STDMETHOD(get_AddModuleNamesToAssembly)(BSTR* pbstrNonAssy);	// (/ASSEMBLYMODULE:file) imports a non-assembly file
	STDMETHOD(put_AddModuleNamesToAssembly)(BSTR bstrNonAssy);
	STDMETHOD(get_EmbedManagedResourceFile)(BSTR* pbstrRes);	// (/ASSEMBLYRESOURCE:file) embed an assembly resource file
	STDMETHOD(put_EmbedManagedResourceFile)(BSTR bstrRes);
	STDMETHOD(get_ForceSymbolReferences)(BSTR* pbstrSymbol);	// (/INCLUDE:[symbol]) force symbol reference, can have multiple
	STDMETHOD(put_ForceSymbolReferences)(BSTR bstrSymbol);
	STDMETHOD(get_DelayLoadDLLs)(BSTR* pbstrDLLName);	// (/DELAYLOAD:[dll_name]) delay load specified DLL, can have multiple
	STDMETHOD(put_DelayLoadDLLs)(BSTR bstrDLLName);
};

class ATL_NO_VTABLE CVCLinkerDebugPage :
	public CVCLinkerBasePage<CVCLinkerDebugPage, IVCLinkerDebugPage>
{
// IVCLinkerDebugPage
public:
	STDMETHOD(get_GenerateDebugInformation)(enumGenerateDebugInformationBOOL* pbDebug);	// (/DEBUG) generate debug info
	STDMETHOD(put_GenerateDebugInformation)(enumGenerateDebugInformationBOOL bDebug);
	STDMETHOD(get_ProgramDatabaseFile)(BSTR* pbstrFile);	// (/PDB:file) use program database
	STDMETHOD(put_ProgramDatabaseFile)(BSTR bstrFile);
	STDMETHOD(get_StripPrivateSymbols)(BSTR* pbstrStrippedPDB);	// (/PDBSTRIPPED:file) create PDB with no private symbols
	STDMETHOD(put_StripPrivateSymbols)(BSTR bstrStrippedPDB);
	STDMETHOD(get_GenerateMapFile)(enumGenerateMapFileBOOL* pbMap);	// (/MAP[:file]) generate map file during linking
	STDMETHOD(put_GenerateMapFile)(enumGenerateMapFileBOOL bMap);
	STDMETHOD(get_MapFileName)(BSTR* pbstrMapFile);	// optional argument to GenerateMapFile property
	STDMETHOD(put_MapFileName)(BSTR bstrMapFile);
	STDMETHOD(get_MapExports)(enumMapExportsBOOL* pbExports);	// (/MAPINFO:EXPORTS) include exported functions in map info
	STDMETHOD(put_MapExports)(enumMapExportsBOOL bExports);
	STDMETHOD(get_MapLines)(enumMapLinesBOOL* pbLines);	// (/MAPINFO:LINES) include line number info in map info
	STDMETHOD(put_MapLines)(enumMapLinesBOOL bLines);

// helpers
public:
	virtual void GetBaseDefault(long id, CComVariant& varValue);
};

class ATL_NO_VTABLE CVCLinkerSystemPage :
	public CVCLinkerBasePage<CVCLinkerSystemPage, IVCLinkerSystemPage>
{
// IVsPerPropertyBrowsing
public:
	STDMETHOD(HideProperty)(DISPID dispid, BOOL *pfHide);

// IVCLinkerSystemPage
public:
	STDMETHOD(get_SubSystem)(subSystemOption* poptSetting);	// see subSystem enum (/SUBSYSTEM)
	STDMETHOD(put_SubSystem)(subSystemOption optSetting);
	STDMETHOD(get_HeapReserveSize)(long* pnReserveSize);	// (/HEAP:reserve[,commit]) total heap allocation size in virtual memory
	STDMETHOD(put_HeapReserveSize)(long nReserveSize);
	STDMETHOD(get_HeapCommitSize)(long* pnCommitSize);	// (/HEAP:reserve[,commit]) total heap allocation size in physical memory
	STDMETHOD(put_HeapCommitSize)(long nCommitSize);
	STDMETHOD(get_StackReserveSize)(long* pnReserveSize);	// (/STACK:reserve[,commit]) total stack allocation size in virtual memory
	STDMETHOD(put_StackReserveSize)(long nReserveSize);
	STDMETHOD(get_StackCommitSize)(long* pnCommitSize);	// (/STACK:reserve[,commit]) total stack allocation size in physical memory
	STDMETHOD(put_StackCommitSize)(long nCommitSize);
	STDMETHOD(get_LargeAddressAware)(addressAwarenessType* poptSetting);	// (/LARGEADDRESSAWARE[:NO]) tells the linker the app can handle addresses greater than 2GB
	STDMETHOD(put_LargeAddressAware)(addressAwarenessType optSetting);
	STDMETHOD(get_TerminalServerAware)(termSvrAwarenessType* poptSetting);	// (/TSAWARE, /TSAWARE:NO, not set) not in docs
	STDMETHOD(put_TerminalServerAware)(termSvrAwarenessType optSetting);
	STDMETHOD(get_SwapRunFromCD)(enumSwapRunFromCDBOOL* pbRun);	// swap run from the CD (/SWAPRUN:CD)
	STDMETHOD(put_SwapRunFromCD)(enumSwapRunFromCDBOOL bRun);
	STDMETHOD(get_SwapRunFromNet)(enumSwapRunFromNetBOOL* pbRun);	// swap run from the net (/SWAPRUN:NET)
	STDMETHOD(put_SwapRunFromNet)(enumSwapRunFromNetBOOL bRun);
};

class ATL_NO_VTABLE CVCLinkerOptimizationPage :
	public CVCLinkerBasePage<CVCLinkerOptimizationPage, IVCLinkerOptimizationPage>
{
// IVCLinkerOptimizationPage
public:
	STDMETHOD(get_OptimizeReferences)(optRefType* poptSetting);	// (/OPT:REF, /OPT:NOREF, not set) eliminate/keep functions & data never referenced
	STDMETHOD(put_OptimizeReferences)(optRefType optSetting);
	STDMETHOD(get_EnableCOMDATFolding)(optFoldingType* poptSetting);	// (/OPT:ICF, /OPT:NOICF, not set) eliminate/keep redundant COMDAT data (data folding)
	STDMETHOD(put_EnableCOMDATFolding)(optFoldingType optSetting);
	STDMETHOD(get_OptimizeForWindows98)(optWin98Type* poptSetting);	// (/OPT:WIN98, /OPT:NOWIN98, not set) 
	STDMETHOD(put_OptimizeForWindows98)(optWin98Type optSetting);
	STDMETHOD(get_FunctionOrder)(BSTR* pbstrOrder);	// (/ORDER:@[file]) place functions in order specified in file
	STDMETHOD(put_FunctionOrder)(BSTR bstrOrder);
};

class ATL_NO_VTABLE CVCLinkerAdvancedPage :
	public CVCLinkerBasePage<CVCLinkerAdvancedPage, IVCLinkerAdvancedPage>
{
// IVCLinkerAdvancedPage
public:
	STDMETHOD(get_EntryPointSymbol)(BSTR* pbstrEntry);	// (/ENTRY:[symbol]) set entry point address for EXE or DLL; incompatible with /NOENTRY
	STDMETHOD(put_EntryPointSymbol)(BSTR bstrEntry);
	STDMETHOD(get_ResourceOnlyDLL)(enumResourceOnlyDLLBOOL* pbNoEntry);	// (/NOENTRY) no entry point.  required for resource-only DLLs; incompatible with /ENTRY
	STDMETHOD(put_ResourceOnlyDLL)(enumResourceOnlyDLLBOOL bNoEntry);
	STDMETHOD(get_SetChecksum)(enumSetChecksumBOOL* pbRelease);	// (/RELEASE) set the checksum in the header of a .exe
	STDMETHOD(put_SetChecksum)(enumSetChecksumBOOL bRelease);
	STDMETHOD(get_BaseAddress)(BSTR* pbstrAddress);	// (/BASE:{address| filename,key}) base address to place program at; can be numeric or string
	STDMETHOD(put_BaseAddress)(BSTR bstrAddress);
	STDMETHOD(get_TurnOffAssemblyGeneration)(enumTurnOffAssemblyGenerationBOOL* pbNoAssy);	// (/NOASSEMBLY) cause the output file to be built without an assembly
	STDMETHOD(put_TurnOffAssemblyGeneration)(enumTurnOffAssemblyGenerationBOOL bNoAssy);
	STDMETHOD(get_SupportUnloadOfDelayLoadedDLL)(enumSupportUnloadOfDelayLoadedDLLBOOL* pbDelay);	// (/DELAY:UNLOAD) use to allow explicit unloading of the DLL
	STDMETHOD(put_SupportUnloadOfDelayLoadedDLL)(enumSupportUnloadOfDelayLoadedDLLBOOL bDelay);
	STDMETHOD(get_ImportLibrary)(BSTR* pbstrImportLib);	// (/IMPLIB:[library]) generate specified import library
	STDMETHOD(put_ImportLibrary)(BSTR bstrImportLib);
	STDMETHOD(get_MergeSections)(BSTR* pbstrMerge);	// (/MERGE:from=to) merge section 'from' into section 'to'
	STDMETHOD(put_MergeSections)(BSTR bstrMerge);
	STDMETHOD(get_TargetMachine)(machineTypeOption* poptSetting);	// (/MACHINE:type) specify target platform
	STDMETHOD(put_TargetMachine)(machineTypeOption optSetting);
};

class ATL_NO_VTABLE CVCLinkerMIDLPage :
	public CVCLinkerBasePage<CVCLinkerMIDLPage, IVCLinkerMIDLPage>
{
// IVCLinkerMIDLPage
public:
	STDMETHOD(get_MidlCommandFile)(BSTR* pbstrMidlCmdFile);	// (/midl:<@midl cmd file>) specify response file for MIDL commands to use
	STDMETHOD(put_MidlCommandFile)(BSTR bstrMidlCmdFile);
	STDMETHOD(get_IgnoreEmbeddedIDL)(enumIgnoreEmbeddedIDLBOOL* pbIgnoreIDL);	// (/ignoreidl) ignore .idlsym sections of .obj files
	STDMETHOD(put_IgnoreEmbeddedIDL)(enumIgnoreEmbeddedIDLBOOL bIgnoreIDL);
	STDMETHOD(get_MergedIDLBaseFileName)(BSTR* pbstrIDLFile);	// (/idlout:<filename>) name intermediate IDL output file
	STDMETHOD(put_MergedIDLBaseFileName)(BSTR bstrIDLFile);
	STDMETHOD(get_TypeLibraryFile)(BSTR* pbstrTLBFile);	// (/tlbout:<filename>) name intermediate typelib output file
	STDMETHOD(put_TypeLibraryFile)(BSTR bstrTLBFile);
	STDMETHOD(get_TypeLibraryResourceID)(long* pnResID);	// (/tlbid:<id>) specify resource ID for generated .tlb file
	STDMETHOD(put_TypeLibraryResourceID)(long nResID);

protected:
	virtual BOOL UseCommandsDialog(long id) { return (id == VCLINKID_MidlCommandFile); }
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\vcpb\linktool.cpp ===
// LinkTool.cpp : Implementation of Linker Tool

#include "stdafx.h"
#include "LinkTool.h"
#include "FileRegistry.h"
#include "BldHelpers.h"
#include "BldActions.h"
#include "stylesheet.h"
#include "ProjWriter.h"

// constants
const wchar_t* const wszLinkDefaultExtensions = L"*.obj;*.res;*.lib;*.rsc";	// remember to update vcpb.rgs if you change this...
const wchar_t* const wszLinkImpLibName = L"$(OutDir)/$(TargetName).lib";
const wchar_t* const wszLinkPDBFile = L"$(OutDir)/$(ProjectName).pdb";
const wchar_t* wszLinkerDelOnRebuildExtensions = L"exe;dll;exp;map;lib;ilk;pdb;ocx;pkg";

const linkProgressOption lShowProgress = linkProgressNotSet;
const long lnTypeLibraryResourceID = 1;
const subSystemOption lSubSystem = subSystemNotSet;
const long lnHeapReserveSize = 0;
const long lnHeapCommitSize = 0;
const long lnStackReserveSize = 0;
const long lnStackCommitSize = 0;
const machineTypeOption lTargetMachine = machineNotSet;

// static initializers
CLinkerToolOptionHandler CVCLinkerTool::s_optHandler;
CComBSTR CVCLinkerTool::s_bstrBuildDescription = L"";
CComBSTR CVCLinkerTool::s_bstrToolName = L"";
CComBSTR CVCLinkerTool::s_bstrExtensions = L"";
GUID CVCLinkerTool::s_pPages[8];
BOOL CVCLinkerTool::s_bPagesInit;


////////////////////////////////////////////////////////////////////////////////
// Option Table for the Linker Tool switches

// NOTE: we're using macros for enum value ranges to help in keeping enum range checks as low maintenance as possible.
// If you add an enum to this table, make sure you use macros to define the upper and lower bounds and use CHECK_BOUNDS
// on the get/put methods associated with that property (both object model and property page).
// WARNING: if you change ANYTHING about a multi-prop here (including add/remove), be sure to update how the property
// is obtained on both the tool and page objects.
BEGIN_OPTION_TABLE(CLinkerToolOptionHandler, L"VCLinkerTool", IDS_Link, TRUE /* pre & post */, FALSE /* case sensitive */)
	// general
	OPT_ENUM(ShowProgress,		L"|VERBOSE|VERBOSE:LIB", StdEnumMin, ShowProgressMax,	L"ShowProgress", IDS_LinkGeneral, VCLINKID)
	OPT_BSTR(OutputFile,		L"OUT:%s",						L"OutputFile", single,				IDS_LinkGeneral, VCLINKID)
	OPT_BSTR_NOQUOTE(Version,	L"VERSION:%s",					L"Version",			single,			IDS_LinkGeneral, VCLINKID)
	OPT_ENUM(LinkIncremental,	L"|INCREMENTAL:NO|INCREMENTAL", StdEnumMin, LinkIncrMax, L"LinkIncremental", IDS_LinkGeneral, VCLINKID)
	OPT_BOOL(SuppressStartupBanner, L"|NOLOGO",					L"SuppressStartupBanner",			IDS_LinkGeneral, VCLINKID)
	OPT_BSTR(AdditionalLibraryDirectories, L"LIBPATH:%s",		L"AdditionalLibraryDirectories",	multipleNoCase,		IDS_LinkGeneral, VCLINKID)
	OPT_BOOL(LinkDLL,			L"|DLL",						L"LinkDLL",							SPECIAL_HYPERLINK, VCLINKID)
	// input
	OPT_BOOL(IgnoreAllDefaultLibraries, L"|NODEFAULTLIB",		L"IgnoreAllDefaultLibraries",		IDS_LinkInput, VCLINKID)
	OPT_BSTR(IgnoreDefaultLibraryNames, L"NODEFAULTLIB:%s",		L"IgnoreDefaultLibraryNames", multipleNoCase, IDS_LinkInput, VCLINKID)
	OPT_BSTR(ModuleDefinitionFile, L"DEF:%s",					L"ModuleDefinitionFile",		single, IDS_LinkInput, VCLINKID)
	OPT_BSTR(AddModuleNamesToAssembly, L"ASSEMBLYMODULE:%s",	L"AddModuleNamesToAssembly",	multipleNoCase, IDS_LinkInput, VCLINKID)
	OPT_BSTR(EmbedManagedResourceFile, L"ASSEMBLYRESOURCE:%s",		L"EmbedManagedResourceFile",		multipleNoCase, IDS_LinkInput, VCLINKID)
	OPT_BSTR(ForceSymbolReferences, L"INCLUDE:%s",				L"ForceSymbolReferences", multiple,		IDS_LinkInput, VCLINKID)
	OPT_BSTR(DelayLoadDLLs,		L"DELAYLOAD:%s",				L"DelayLoadDLLs", multipleNoCase,	IDS_LinkInput, VCLINKID)
	// MIDL
	OPT_BSTR_SPECIAL(MidlCommandFile,	L"MIDL:@%s",			L"MidlCommandFile",	single,			IDS_LinkMIDL, VCLINKID)
	OPT_BOOL(IgnoreEmbeddedIDL,	L"|IGNOREIDL",					L"IgnoreEmbeddedIDL",				IDS_LinkMIDL, VCLINKID)
	OPT_BSTR(MergedIDLBaseFileName,	L"IDLOUT:%s",				L"MergedIDLBaseFileName",	single,	IDS_LinkMIDL, VCLINKID)
	OPT_BSTR(TypeLibraryFile,	L"TLBOUT:%s",					L"TypeLibraryFile",		single,		IDS_LinkMIDL, VCLINKID)
	OPT_INT_NOZERO(TypeLibraryResourceID, L"TLBID:%d",			L"TypeLibraryResourceID",			IDS_LinkMIDL, VCLINKID)
	// debug
	OPT_BOOL(GenerateDebugInformation, L"|DEBUG",				L"GenerateDebugInformation",		IDS_LinkDebug, VCLINKID)
	OPT_BSTR(ProgramDatabaseFile, L"PDB:%s",					L"ProgramDatabaseFile",	single,		IDS_LinkDebug, VCLINKID)
	OPT_BSTR(StripPrivateSymbols, L"PDBSTRIPPED:%s",			L"StripPrivateSymbols", single,		IDS_LinkDebug, VCLINKID)
	OPT_BOOL_SET_COND(GenerateMapFile, L"|MAP",					L"GenerateMapFile", MapFileName,	IDS_LinkDebug, VCLINKID)
	OPT_BSTR_COND(MapFileName,	L":%s",					L"MapFileName", GenerateMapFile, single,	IDS_LinkDebug, VCLINKID)
	OPT_BOOL(MapExports,		L"|MAPINFO:EXPORTS",			L"MapExports",						IDS_LinkDebug, VCLINKID)
	OPT_BOOL(MapLines,			L"|MAPINFO:LINES",				L"MapLines",						IDS_LinkDebug, VCLINKID)
	// System
	OPT_ENUM(SubSystem, L"|SUBSYSTEM:CONSOLE|SUBSYSTEM:WINDOWS", StdEnumMin, LinkSubSystemMax, L"SubSystem", IDS_LinkSystem, VCLINKID)
	OPT_INT_NOZERO_SET_COND(HeapReserveSize, L"HEAP:%d",	L"HeapReserveSize", HeapCommitSize,			IDS_LinkSystem, VCLINKID)
	OPT_INT_NOZERO_COND(HeapCommitSize, L",%d",			L"HeapCommitSize", HeapReserveSize,			IDS_LinkSystem, VCLINKID)
	OPT_INT_NOZERO_SET_COND(StackReserveSize, L"STACK:%d",	L"StackReserveSize", StackCommitSize,		IDS_LinkSystem, VCLINKID)
	OPT_INT_NOZERO_COND(StackCommitSize, L",%d",			L"StackCommitSize", StackReserveSize,		IDS_LinkSystem, VCLINKID)
	OPT_ENUM(LargeAddressAware, L"|LARGEADDRESSAWARE:NO|LARGEADDRESSAWARE", StdEnumMin, LargeAddrMax, L"LargeAddressAware", IDS_LinkSystem, VCLINKID)
	OPT_ENUM(TerminalServerAware, L"|TSAWARE:NO|TSAWARE",	StdEnumMin, TSAwareMax,		L"TerminalServerAware", IDS_LinkSystem, VCLINKID)
	OPT_BOOL(SwapRunFromCD,		L"|SWAPRUN:CD",						L"SwapRunFromCD",					IDS_LinkSystem, VCLINKID)
	OPT_BOOL(SwapRunFromNet,	L"|SWAPRUN:NET",					L"SwapRunFromNet",					IDS_LinkSystem, VCLINKID)
	// optimization
	OPT_ENUM(OptimizeReferences, L"|OPT:NOREF|OPT:REF",		StdEnumMin, OptRefMax,	L"OptimizeReferences",	IDS_LinkOptimization, VCLINKID)
	OPT_ENUM(EnableCOMDATFolding, L"|OPT:NOICF|OPT:ICF",	StdEnumMin, OptFoldMax, L"EnableCOMDATFolding",		IDS_LinkOptimization, VCLINKID)
	OPT_ENUM(OptimizeForWindows98, L"|OPT:NOWIN98|OPT:WIN98",	StdEnumMin, OptWin98Max,	L"OptimizeForWindows98", IDS_LinkOptimization, VCLINKID)	 
	OPT_BSTR(FunctionOrder,		L"ORDER:%s",						L"FunctionOrder", single,			IDS_LinkOptimization, VCLINKID)
	OPT_BOOL(LinkTimeCodeGeneration,	L"|LTCG",					L"LinkTimeCodeGeneration",			SPECIAL_HYPERLINK, VCLINKID)
	// advanced
	OPT_BSTR(EntryPointSymbol,	L"ENTRY:%s",						L"EntryPointSymbol", single,		IDS_LinkAdvanced, VCLINKID)
	OPT_BOOL(ResourceOnlyDLL,	L"|NOENTRY",						L"ResourceOnlyDLL",					IDS_LinkAdvanced, VCLINKID)
	OPT_BOOL(SetChecksum,		L"|RELEASE",						L"SetChecksum",						IDS_LinkAdvanced, VCLINKID)
	OPT_BSTR(BaseAddress,		L"BASE:%s",							L"BaseAddress", single,				IDS_LinkAdvanced, VCLINKID)
	OPT_BOOL(TurnOffAssemblyGeneration, L"|NOASSEMBLY",				L"TurnOffAssemblyGeneration",		IDS_LinkAdvanced, VCLINKID)
	OPT_BOOL(SupportUnloadOfDelayLoadedDLL, L"|DELAY:UNLOAD",		L"SupportUnloadOfDelayLoadedDLL",	IDS_LinkAdvanced, VCLINKID)
	OPT_BSTR(ImportLibrary,		L"IMPLIB:%s",						L"ImportLibrary", single,			IDS_LinkAdvanced, VCLINKID)
	OPT_BSTR(MergeSections,		L"MERGE:%s",						L"MergeSections", single,			IDS_LinkAdvanced, VCLINKID)
	OPT_ENUM(TargetMachine,		L"|MACHINE:IX86",			StdEnumMin,	TargetMachineMax,	L"TargetMachine", IDS_LinkAdvanced, VCLINKID)	 
END_OPTION_TABLE()

// default value handlers
// string props
void CLinkerToolOptionHandler::GetDefaultValue( long id, BSTR *pVal, IVCPropertyContainer *pPropContainer )
{
	switch( id )
	{
	case VCLINKID_ImportLibrary:
	{
		if (pPropContainer == NULL)
			GetDefaultString( pVal );
		else
		{
			*pVal = NULL;
			VARIANT_BOOL bDLL = VARIANT_FALSE;
			if (pPropContainer->GetBoolProperty(VCLINKID_LinkDLL, &bDLL) != S_OK || bDLL != VARIANT_TRUE)
				GetDefaultString( pVal );
			else
			{
				VARIANT_BOOL bIgnoreExp = VARIANT_FALSE;
				if (pPropContainer->GetBoolProperty(VCLINKID_IgnoreImportLibrary, &bIgnoreExp) == S_OK && bIgnoreExp == VARIANT_TRUE)
					GetDefaultString( pVal );
				else
					*pVal = SysAllocString( wszLinkImpLibName );
			}
		}
		break;
	}
	case VCLINKID_OutputFile:
	{
		if (pPropContainer == NULL)
			GetDefaultString( pVal );
		else
		{
			*pVal = NULL;
			CComBSTR bstrFile = L"$(OutDir)/$(ProjectName).";
			VARIANT_BOOL bDll = VARIANT_FALSE;
			if (pPropContainer->GetBoolProperty(VCLINKID_LinkDLL, &bDll) == S_OK && bDll == VARIANT_TRUE)
				bstrFile += L"dll";
			else
				bstrFile += L"exe";
			*pVal = bstrFile.Detach();
		}
		break;
	}
	case VCLINKID_ProgramDatabaseFile:
	{
		if (pPropContainer == NULL)
			GetDefaultString( pVal );
		else
		{
			VARIANT_BOOL bGenDebug = VARIANT_FALSE;
			HRESULT hr = pPropContainer->GetBoolProperty(VCLINKID_GenerateDebugInformation, &bGenDebug);
			if (hr != S_OK || bGenDebug == VARIANT_FALSE)
				GetDefaultString( pVal );
			else
				*pVal = SysAllocString( wszLinkPDBFile );
		}
		break;
	}
 	case VCLINKID_EntryPointSymbol:
		{
			if (pPropContainer == NULL)
			{
				GetDefaultString(pVal);
				break;
			}

			VARIANT_BOOL bDLL;
			if (pPropContainer->GetBoolProperty(VCLINKID_LinkDLL, &bDLL) == S_OK && bDLL)
			{
				GetDefaultString(pVal);
				break;	// no need to set the entry point for DLLs
			}

			charSet charSetType = charSetNotSet;
			if (pPropContainer->GetIntProperty(VCCFGID_CharacterSet, (long *)&charSetType) != S_OK ||
				charSetType != charSetUnicode)
			{
				GetDefaultString(pVal);
				break;	// no need to set entry point for non-Unicode code
			}

			compileAsManagedOptions compileManaged;
			if (pPropContainer->GetIntProperty(VCCLID_CompileAsManaged, (long *)&compileManaged) == S_OK &&
				compileManaged != managedNotSet)
			{
				GetDefaultString(pVal);
				break;	// no need to set entry point for managed code
			}

			subSystemOption subSystemType = subSystemNotSet;
			if (pPropContainer->GetIntProperty(VCLINKID_SubSystem, (long *)&subSystemType) == S_OK &&
				subSystemType == subSystemConsole)
			{
				GetDefaultString(pVal);
				break;	// no need to set entry point for console apps
			}

			// Now, let's see if we're linking to MFC.  If the user chose to hand-add libraries, they're on their own.
			useOfMfc useMFC = useMfcStdWin;
			if (pPropContainer->GetIntProperty(VCCFGID_UseOfMFC, (long *)&useMFC) != S_OK || useMFC == useMfcStdWin)
			{
				GetDefaultString(pVal);
				break;	// no need to set entry point for non-MFC apps
			}

			// what we're left with is something that links to MFC and needs an explicit entry point
			CComBSTR bstrEntryPoint = L"wWinMainCRTStartup";
			*pVal = bstrEntryPoint.Detach();
			break;
		}
// 	case VCLINKID_AdditionalLibraryDirectories:
// 	case VCLINKID_DelayLoadDLLs:
// 	case VCLINKID_FunctionOrder:
// 	case VCLINKID_MapFileName:
// 	case VCLINKID_StripPrivateSymbols:
// 	case VCLINKID_MergedIDLBaseFileName:
// 	case VCLINKID_TypeLibraryFile:
// 	case VCLINKID_IgnoreDefaultLibraryNames:
// 	case VCLINKID_ModuleDefinitionFile:
// 	case VCLINKID_AddModuleNamesToAssembly:
// 	case VCLINKID_EmbedManagedResourceFile:
// 	case VCLINKID_MidlCommandFile:
// 	case VCLINKID_AdditionalDependencies:
// 	case VCLINKID_AdditionalOptions:
// 	case VCLINKID_Version:
// 	case VCLINKID_ForceSymbolReferences:
// 	case VCLINKID_BaseAddress:
// 	case VCLINKID_MergeSections:
	default:
		GetDefaultString( pVal );
		break;
	}
}

// integer props
void CLinkerToolOptionHandler::GetDefaultValue( long id, long *pVal, IVCPropertyContainer *pPropCnt )
{
	switch( id )
	{
	case VCLINKID_ShowProgress:
		*pVal = lShowProgress;
		break;
	case VCLINKID_LinkIncremental:
		*pVal = linkIncrementalDefault;
		break;
	case VCLINKID_TypeLibraryResourceID:
		*pVal = lnTypeLibraryResourceID;
		break;
	case VCLINKID_TerminalServerAware:
		*pVal = termSvrAwareDefault;
		break;
	case VCLINKID_SubSystem:
		*pVal = lSubSystem;
		break;
	case VCLINKID_HeapReserveSize:
		*pVal = lnHeapReserveSize;
		break;
	case VCLINKID_HeapCommitSize:
		*pVal = lnHeapCommitSize;
		break;
	case VCLINKID_StackReserveSize:
		*pVal = lnStackReserveSize;
		break;
	case VCLINKID_StackCommitSize:
		*pVal = lnStackCommitSize;
		break;
	case VCLINKID_LargeAddressAware:
		*pVal = addrAwareDefault;
		break;
	case VCLINKID_OptimizeReferences:
		*pVal = optReferencesDefault;
		break;
	case VCLINKID_EnableCOMDATFolding:
		*pVal = optFoldingDefault;
		break;
	case VCLINKID_OptimizeForWindows98:
		*pVal = optWin98Default;
		break;
	case VCLINKID_TargetMachine:
		*pVal = lTargetMachine;
		break;
	default:
		*pVal = 0;
		break;
	}
}

// boolean props
void CLinkerToolOptionHandler::GetDefaultValue( long id, VARIANT_BOOL *pVal, IVCPropertyContainer *pPropCnt )
{
// 	switch( id )
// 	{
// 	case VCLINKID_SuppressStartupBanner:
// 	case VCLINKID_IgnoreImportLibrary:
// 	case VCLINKID_RegisterOutput:
// 	case VCLINKID_IgnoreAllDefaultLibraries:
// 	case VCLINKID_IgnoreEmbeddedIDL:
// 	case VCLINKID_LinkDLL:
// 	case VCLINKID_SwapRunFromCD:
// 	case VCLINKID_SwapRunFromNet:
// 	case VCLINKID_GenerateDebugInformation:
// 	case VCLINKID_GenerateMapFile:
// 	case VCLINKID_MapExports:
// 	case VCLINKID_MapLines:
// 	case VCLINKID_LinkTimeCodeGeneration:
// 	case VCLINKID_SupportUnloadOfDelayLoadedDLL:
// 	case VCLINKID_ResourceOnlyDLL:
// 	case VCLINKID_SetChecksum:
// 	case VCLINKID_TurnOffAssemblyGeneration:
// 	default:
		GetValueFalse( pVal );
// 		break;
// 	}
}

BOOL CLinkerToolOptionHandler::SetEvenIfDefault(VARIANT *pvarDefault, long idOption)
{
	CComVariant varDefault;
	BOOL bRet = FALSE;

	switch (idOption)
	{
	case VCLINKID_SuppressStartupBanner:
		varDefault.vt = VT_BOOL;
		varDefault = VARIANT_TRUE;
		bRet = TRUE;
		break;
	}
	varDefault.Detach(pvarDefault);
	return bRet;
}

BOOL CLinkerToolOptionHandler::SynthesizeOptionIfNeeded(IVCPropertyContainer* pPropContainer, long idOption)
{
	switch (idOption)
	{
	case VCLINKID_OutputFile:
		return TRUE;
	case VCLINKID_ProgramDatabaseFile:
		return TRUE;
	case VCLINKID_EntryPointSymbol:
		return TRUE;
	default:
		return FALSE;
	}
}

BOOL CLinkerToolOptionHandler::SynthesizeOption(IVCPropertyContainer* pPropContainer, long idOption, 
	CComVariant& rvar)
{
	CComBSTR bstrVal;
	switch (idOption)
	{
	case VCLINKID_OutputFile:
		CreateOutputName(pPropContainer, &bstrVal, FALSE);
		break;
	case VCLINKID_ProgramDatabaseFile:
		CreatePDBName(pPropContainer, &bstrVal, FALSE);
		break;
	case VCLINKID_EntryPointSymbol:
		GetDefaultValue(VCLINKID_EntryPointSymbol, &bstrVal, pPropContainer);
		break;
	default:
		VSASSERT(FALSE, "Case statement mismatch between SynthesizeOptionIfNeeded and SynthesizeOption");	// shouldn't be here!!
		return FALSE;
	}

	rvar = bstrVal;
	return TRUE;
}

static const wchar_t* szScriptItemCL = L"\r\n<a title=\"%s | %s\" onclick=\"onHelp('VC.Project.VCConfiguration.%s')\" href=\"settingspage.htm\">%s</a>";

void CLinkerToolOptionHandler::FormatScriptItem(const wchar_t* szOptionName, long idOption, long idOptionPage, CStringW& rstrOption)
{
	if (idOption != SPECIAL_HYPERLINK)
	{
		COptionHandlerBase::FormatScriptItem(szOptionName, idOption, idOptionPage, rstrOption);
		return;
	}

	VSASSERT(idOption == VCLINKID_LinkDLL || idOption == VCLINKID_LinkTimeCodeGeneration, "Hey, unexpected special handling option for linker!");

	CStringW strProp;
	CStringW strPropBase;
	if (idOption == VCLINKID_LinkDLL)
	{
		strProp.LoadString(VCCFGID_ConfigurationType);
		strPropBase = L"ConfigurationType";
	}
	else
	{
		strProp.LoadString(VCCFGID_WholeProgramOptimization);
		strPropBase = L"WholeProgramOptimization";
	}
	long nColon = strProp.Find(L": ");
	if (nColon)
		strProp = strProp.Left(nColon-1);
	strProp.TrimLeft();
	strProp.TrimRight();

	CStringW strGen;
	strGen.LoadString(IDS_GeneralConfigSettings);
	CStringW strTmp;
	strTmp.Format(szScriptItemCL, strGen, strProp, strPropBase, rstrOption);
	rstrOption = strTmp;
}

void CLinkerToolOptionHandler::EvaluateSpecialString(CStringW& rstrVal, BOOL bIsMultiple, LPCOLESTR szOption, long idOption,
	LPCOLESTR szOptionName, long idOptionPage, IVCPropertyContainer* pPropContainer, BOOL bIncludeSlash, 
	BOOL bForDisplay, commandLineOptionStyle fStyle, CStringW& rstrTrailing, CStringW& rstrSwitch) 
{
	if (idOption != VCLINKID_MidlCommandFile)
	{
		EvaluateString(rstrVal, bIsMultiple, szOption, szOptionName, idOption, idOptionPage, bIncludeSlash, TRUE /* quote it */,
			bForDisplay, rstrSwitch);
		return;
	}

	rstrSwitch.Empty();
	if (rstrVal.IsEmpty())	// don't generate anything on empty strings
		return;

	if (pPropContainer == NULL)		// not a lot we can do with no property container
		return;

	CPathW pathMidlFile;
	if (fStyle == cmdLineForRefresh || 
		(CVCToolImpl::CreatePathRelativeToProject(pPropContainer, rstrVal, pathMidlFile) && pathMidlFile.ExistsOnDisk()))
	{	// we were given an actual file to work with
		EvaluateString(rstrVal, bIsMultiple, szOption, szOptionName, idOption, idOptionPage, bIncludeSlash, TRUE /* quote it */,
			bForDisplay, rstrSwitch);
		return;
	}

	if (fStyle == cmdLineForBuild)
	{
		CComPtr<IVCPropertyContainer> spActualContainer;
		CVCProjectEngine::ResolvePropertyContainer(pPropContainer, &spActualContainer);
		CComQIPtr<IVCBuildableItem> spBuildableItem = spActualContainer;
		if (spBuildableItem == NULL)	// not a config or file config, not much we can do
			return;

		CComPtr<IVCBuildEngine> spBuildEngine;
		spBuildableItem->get_ExistingBuildEngine(&spBuildEngine);
		if (spBuildEngine == NULL)	// not doing a build, not much we can do
			return;

		CComBSTR bstrCommentLine;
		bstrCommentLine.LoadString(IDS_CREATING_LINK_MIDL_RSP);
		CComBSTR bstrCommandIn = rstrVal;
		CComBSTR bstrCommandOut;
		spBuildEngine->FormTempFile(bstrCommandIn, bstrCommentLine, &bstrCommandOut);
		rstrVal = bstrCommandOut;
	}
	else	// cmdLineForDisplay
	{
		CStringW strComment;
		strComment.Format(IDS_USE_LINK_MIDL_RSP, rstrVal);
		rstrTrailing += strComment;
		rstrVal.LoadString(IDS_LINK_MIDL_RSP_NAME);
	}

	EvaluateString(rstrVal, bIsMultiple, szOption, szOptionName, idOption, idOptionPage, bIncludeSlash, TRUE /* quote it */,
		bForDisplay, rstrSwitch);
}

BOOL CLinkerToolOptionHandler::CreateOutputName(IVCPropertyContainer* pPropContainer, BSTR *pbstrVal,
	BOOL bCheckForExistence /* = TRUE */)
{
	VSASSERT(pPropContainer != NULL, "Cannot create output name without a property container");
	RETURN_ON_NULL2(pPropContainer, FALSE);

	if (bCheckForExistence &&
		pPropContainer->GetEvaluatedStrProperty(VCLINKID_OutputFile, pbstrVal) == S_OK)	// found it directly set, so use it
		return TRUE;

	CVCLinkerTool::s_optHandler.GetDefaultValue( VCLINKID_OutputFile, pbstrVal, pPropContainer );
	HRESULT hr = pPropContainer->Evaluate(*pbstrVal, pbstrVal);

	return (SUCCEEDED(hr));
}

BOOL CLinkerToolOptionHandler::CreatePDBName(IVCPropertyContainer* pPropContainer, BSTR *pbstrVal,
	BOOL bCheckForExistence /* = TRUE */)
{
	VSASSERT(pPropContainer != NULL, "Cannot create output name without a property container");
	RETURN_ON_NULL2(pPropContainer, FALSE);

	if (bCheckForExistence &&
		pPropContainer->GetEvaluatedStrProperty(VCLINKID_ProgramDatabaseFile, pbstrVal) == S_OK)	// found it directly set, so use it
		return TRUE;

	CVCLinkerTool::s_optHandler.GetDefaultValue( VCLINKID_ProgramDatabaseFile, pbstrVal, pPropContainer );
	HRESULT hr = pPropContainer->Evaluate(*pbstrVal, pbstrVal);

	return (SUCCEEDED(hr));
}

BOOL CLinkerToolOptionHandler::OverrideOptionSet(IVCPropertyContainer* pPropContainer, long idOption)
{
	RETURN_ON_NULL2(g_pProjectEngine, FALSE);

	// Are we an Xbox or not?

	CComBSTR bstrPlatName;
	pPropContainer->GetStrProperty(VCPLATID_Name, &bstrPlatName);
	if (lstrcmpW(bstrPlatName, L"Xbox") != 0)
	{
		return FALSE;	// Not Xbox, don't override any options
	}

	switch (idOption)
	{
	case VCLINKID_SubSystem:	// Override SubSystem option
		return TRUE;
	default:
		return FALSE;
	}
}

HRESULT CLinkerToolOptionHandler::GenerateCommandLine(IVCPropertyContainer* pPropContainer, BOOL bForDisplay, commandLineOptionStyle fStyle, 
		CStringW& rstrCmdLine)
{
	// Are we an Xbox or not?

	CComBSTR bstrPlatName;
	pPropContainer->GetStrProperty(VCPLATID_Name, &bstrPlatName);
	bool bIsXbox = 0 == lstrcmpW(bstrPlatName, L"Xbox");
	if(!bIsXbox){
		return COptionHandlerBase::GenerateCommandLine(pPropContainer, bForDisplay,  fStyle, rstrCmdLine);
	}
	else {
		HRESULT hr = COptionHandlerBase::GenerateCommandLine(pPropContainer, bForDisplay,  fStyle, rstrCmdLine);
		if(SUCCEEDED(hr)){
			// Add /subSystem:Xbox. We do it here to keep from having to add Xbox to the subsystem enumeration.
			rstrCmdLine += L" /subsystem:xbox";
		}
		return hr;
	}
}


/////////////////////////////////////////////////////////////////////////////
HRESULT CVCLinkerTool::CreateInstance(IVCPropertyContainer* pPropContainer, IVCToolImpl** ppLinkTool)
{
	CHECK_POINTER_NULL(ppLinkTool);
	*ppLinkTool = NULL;

	CComObject<CVCLinkerTool> *pObj;
	HRESULT hr = CComObject<CVCLinkerTool>::CreateInstance(&pObj);
	if (SUCCEEDED(hr))
	{
		if( pPropContainer )
			pObj->Initialize(pPropContainer);
		CVCLinkerTool *pVar = pObj;
		pVar->AddRef();
		*ppLinkTool = pVar;
	}
	return hr;
}

STDMETHODIMP CVCLinkerTool::IsDeleteOnRebuildFile(LPCOLESTR szFile, VARIANT_BOOL* pbDelOnRebuild)
{
	CHECK_POINTER_NULL(pbDelOnRebuild);

	BOOL fDel = BldFileNameMatchesExtension(szFile, wszLinkerDelOnRebuildExtensions);
	*pbDelOnRebuild = fDel ? VARIANT_TRUE : VARIANT_FALSE;
	return S_OK;
}

STDMETHODIMP CVCLinkerTool::get_DefaultExtensions(BSTR* pVal)
{
	return DoGetDefaultExtensions(s_bstrExtensions, wszLinkDefaultExtensions, pVal);
}

STDMETHODIMP CVCLinkerTool::put_DefaultExtensions(BSTR newVal)
{
	s_bstrExtensions = newVal;
	return S_OK;
}

STDMETHODIMP CVCLinkerTool::GetAdditionalOptionsInternal(IUnknown* pItem, VARIANT_BOOL bForBuild, VARIANT_BOOL bSkipLocal, 
	BSTR* pbstrAdditionalOptions)
{ 
	return GetProcessedAdditionalOptions(pItem, VCLINKID_AdditionalOptions, bForBuild, bSkipLocal, pbstrAdditionalOptions);
}

STDMETHODIMP CVCLinkerTool::GetBuildDescription(IVCBuildAction* pAction, BSTR* pbstrBuildDescription)
{
	if (s_bstrBuildDescription.Length() == 0)
		s_bstrBuildDescription.LoadString(IDS_DESC_LINKING);
	return s_bstrBuildDescription.CopyTo(pbstrBuildDescription);
}

STDMETHODIMP CVCLinkerTool::GetAdditionalIncludeDirectoriesInternal(IVCPropertyContainer* pPropContainer, BSTR* pbstrIncDirs)
{
	CHECK_POINTER_NULL(pbstrIncDirs);
	CHECK_READ_POINTER_NULL(pPropContainer);
	CComBSTR bstrTmp;
	HRESULT hr = pPropContainer->GetMultiProp(VCLINKID_AdditionalLibraryDirectories, L";", VARIANT_FALSE, &bstrTmp);
	if (SUCCEEDED(hr))
		pPropContainer->Evaluate(bstrTmp, pbstrIncDirs);
	else
		*pbstrIncDirs = bstrTmp.Detach();
	return hr;
}

STDMETHODIMP CVCLinkerTool::get_ToolPathInternal(BSTR* pbstrToolPath)
{ 
	return get_ToolPath(pbstrToolPath);
}

STDMETHODIMP CVCLinkerTool::get_Bucket(long *pVal)
{
	CHECK_POINTER_NULL( pVal );
	*pVal = BUCKET_LINK; 
	return S_OK;
}

STDMETHODIMP CVCLinkerTool::GenerateOutput(long type, IVCBuildActionList* plstActions, IVCBuildErrorContext* pEC)
{
	return DoGenerateOutput(type, plstActions, pEC, TRUE, this);
}

///////////////////////////////////////////////////////////////////////////////
// Affects our output?
STDMETHODIMP CVCLinkerTool::AffectsOutput(long nPropID, VARIANT_BOOL* pbAffectsOutput)
{
	CHECK_POINTER_NULL(pbAffectsOutput);
	*pbAffectsOutput = VARIANT_FALSE;

	// change our outputs?
	switch (nPropID)
	{
	case VCLINKID_LinkDLL:				// enables *.dll
	case VCLINKID_LinkIncremental:		// enables *.ilk
	case VCLINKID_ProgramDatabaseFile:	// *.pdb
	case VCLINKID_GenerateMapFile:		// enables *.map
	case VCLINKID_MapFileName:			// *.map
	case VCLINKID_OutputFile:			// *.exe, *.dll etc.
	case VCLINKID_ModuleDefinitionFile:	// *.def
	case VCLINKID_AdditionalDependencies:	// extra stuff to add to link line
	case VCLINKID_DependentInputs:		// inputs we pick up from dependent projects
	case VCLINKID_IgnoreImportLibrary:	// ignore the import .lib
	case VCLINKID_OutputsDirty:			// anything we care about dirty
	case VCLINKID_RegisterOutput:		// register output of build
		*pbAffectsOutput = VARIANT_TRUE;
		break;
	default:
		*pbAffectsOutput = VARIANT_FALSE;
		break;
	}

	return S_OK;
}

GUID* CVCLinkerTool::GetPageIDs()
{ 
	if (s_bPagesInit == FALSE)
	{
		s_pPages[0] = __uuidof(LinkGeneral);
		s_pPages[1] = __uuidof(LinkInput);
		s_pPages[2] = __uuidof(LinkDebug);
		s_pPages[3] = __uuidof(LinkSystem);
		s_pPages[4] = __uuidof(LinkOptimization);
		s_pPages[5] = __uuidof(LinkMIDL);
		s_pPages[6] = __uuidof(LinkAdvanced);
		s_pPages[7] = __uuidof(LinkAdditionalOptions);
		s_bPagesInit = TRUE;
	}
	return s_pPages; 
}

STDMETHODIMP CVCLinkerTool::IsSpecialConsumable(LPCOLESTR szPath, VARIANT_BOOL* pbSpecial)
{
	CHECK_POINTER_NULL(pbSpecial);

	if (BldFileNameMatchesExtension(szPath, L"def"))
		*pbSpecial = VARIANT_TRUE;
	else
		*pbSpecial = VARIANT_FALSE;
	return S_OK;
}

HRESULT CVCLinkerTool::GetPrimaryOutputFromTool(IUnknown* pItem, VARIANT_BOOL bSchmoozeOnly, CPathW& rpath)
{
	return DoGetPrimaryOutputFromTool(pItem, rpath, TRUE);
}

STDMETHODIMP CVCLinkerTool::HasPrimaryOutputFromTool(IUnknown* pItem, VARIANT_BOOL bSchmoozeOnly, VARIANT_BOOL* pbHasPrimaryOutput)
{
	return COptionHandlerBase::GetValueTrue( pbHasPrimaryOutput );
}

STDMETHODIMP CVCLinkerTool::GetPrimaryOutputIDFromTool(IUnknown* pItem, VARIANT_BOOL bSchmoozeOnly, long* pnOutputID)
{
	CHECK_POINTER_NULL(pnOutputID);
	*pnOutputID = VCLINKID_OutputFile;
	return S_OK;
}

STDMETHODIMP CVCLinkerTool::GetImportLibraryFromTool(IUnknown* pItem, BSTR* pbstrPath)
{
	CHECK_READ_POINTER_NULL(pItem);
	CHECK_POINTER_NULL(pbstrPath);
	*pbstrPath = NULL;

	CComPtr<VCConfiguration> spConfig;
	GetProjectCfgForItem(pItem, &spConfig);
	RETURN_ON_NULL2(spConfig, S_FALSE);

	CComQIPtr<IVCPropertyContainer> spPropContainer = spConfig;
	RETURN_ON_NULL2(spPropContainer, E_UNEXPECTED);

	ConfigurationTypes configType = typeUnknown;
	if (spConfig->get_ConfigurationType(&configType) != S_OK)
	{
		VSASSERT(false, "Hey, how did we get a config without a non-default config type?");
		return E_UNEXPECTED;
	}
	else if (configType != typeDynamicLibrary)
		return S_FALSE;

	VARIANT_BOOL fLib;	// does this dll have an export lib ?
	HRESULT hr = spPropContainer->GetBoolProperty(VCLINKID_IgnoreImportLibrary, &fLib);
	RETURN_ON_FAIL(hr);

	if (fLib == VARIANT_TRUE)
		return S_FALSE;

	CComBSTR bstrImportLib;
	hr = spPropContainer->GetEvaluatedStrProperty(VCLINKID_ImportLibrary, &bstrImportLib);
	RETURN_ON_FAIL(hr);

	CStringW strImportLib = bstrImportLib;
	strImportLib.TrimLeft();
	if (strImportLib.IsEmpty())
	{
		s_optHandler.GetDefaultValue( VCLINKID_ImportLibrary, &bstrImportLib );
		hr = spPropContainer->Evaluate(bstrImportLib, &bstrImportLib);
		RETURN_ON_FAIL(hr);
		strImportLib = bstrImportLib;
	}

	CPathW pathName;
	if (!CreatePathRelativeToProject(spPropContainer, strImportLib, pathName))
		return VCPROJ_E_BAD_PATH;

	pathName.GetFullPath(strImportLib);
	bstrImportLib = strImportLib;
	*pbstrPath = bstrImportLib.Detach();
	return S_OK;
}

STDMETHODIMP CVCLinkerTool::GetProgramDatabaseFromTool(IVCPropertyContainer* pPropContainer, VARIANT_BOOL bSchmoozeOnly, 
	BSTR* pbstrPDB)
{
	CHECK_POINTER_NULL(pbstrPDB);
	*pbstrPDB = NULL;

	VARIANT_BOOL bGenDebug = VARIANT_FALSE;
	HRESULT hr = pPropContainer->GetBoolProperty(VCLINKID_GenerateDebugInformation, &bGenDebug);
	if (hr != S_OK || bGenDebug == VARIANT_FALSE)
		return S_FALSE;

	CComBSTR bstrPDBFile;
	if (!s_optHandler.CreatePDBName(pPropContainer, &bstrPDBFile))
		return S_FALSE;
	CStringW strPDBFile = bstrPDBFile;

	CPathW pathName;
	if (!CreatePathRelativeToProject(pPropContainer, strPDBFile, pathName))
		return VCPROJ_E_BAD_PATH;

	pathName.GetFullPath(strPDBFile);
	bstrPDBFile = strPDBFile;
	*pbstrPDB = bstrPDBFile.Detach();
	return S_OK;
}

STDMETHODIMP CVCLinkerTool::HasDependencies(IVCBuildAction* pAction, VARIANT_BOOL* pbHasDependencies)
{
	return DoHasDependencies(pAction, TRUE, pbHasDependencies);
}

STDMETHODIMP CVCLinkerTool::IsTargetTool(IVCBuildAction* pAction, VARIANT_BOOL* pbTargetTool)
{ // tool always operates on target, not on file
	return COptionHandlerBase::GetValueTrue(pbTargetTool);
}

void CVCLinkerTool::SaveSpecialProps(IStream *xml, IVCPropertyContainer *pPropContainer)
{
	// Register
	CComVariant varRegister;
	if (pPropContainer->GetLocalProp(VCLINKID_RegisterOutput, &varRegister) == S_OK && 
		(varRegister.vt == VT_BOOL || varRegister.vt == VT_I2))
		NodeAttribute( xml, L"RegisterOutput", varRegister.boolVal == VARIANT_TRUE ? L"TRUE" : L"FALSE" );

	// Ignore export lib
	CComVariant varIgnore;
	if (pPropContainer->GetLocalProp(VCLINKID_IgnoreImportLibrary, &varIgnore) == S_OK && 
		(varIgnore.vt == VT_BOOL || varIgnore.vt == VT_I2))
		NodeAttribute( xml, L"IgnoreImportLibrary", varIgnore.boolVal == VARIANT_TRUE ? L"TRUE" : L"FALSE" );
}

STDMETHODIMP CVCLinkerTool::GetCommandLinesForBuild(IVCBuildActionList* pActions, bldAttributes attrib, 
	IVCBuildEngine* pBldEngine, IVCBuildErrorContext* pErrorContext, IVCCommandLineList** ppCmds)
{
	HRESULT hr = CVCToolImpl::GetCommandLinesForBuild(pActions, attrib, pBldEngine, pErrorContext, ppCmds);
	if (hr != S_OK)
		return hr;

	// now need to check if we need to add a command line for registration
	pActions->Reset(NULL);
	while (hr == S_OK)
	{
		CComPtr<IVCBuildAction> spAction;
		hr = pActions->Next(&spAction, NULL);
		BREAK_ON_DONE(hr);
		ASSERT_AND_CONTINUE_ON_NULL(spAction);

		CComPtr<VCConfiguration> spProjCfg;
		HRESULT hr1 = spAction->get_ProjectConfiguration(&spProjCfg);
		ASSERT_AND_CONTINUE_ON_FAIL_OR_NULL(hr1, spProjCfg);

		VARIANT_BOOL bRegister;
		hr1 = spProjCfg->get_RegisterOutput(&bRegister);
		ASSERT_AND_CONTINUE_ON_FAIL(hr1);
		if (bRegister == VARIANT_FALSE)	// nothing more to do if not registering
			continue;

		CComQIPtr<IVCPropertyContainer> spPropContainer = spProjCfg;
		ASSERT_AND_CONTINUE_ON_NULL(spPropContainer);

		CComBSTR bstrTargetPath = L"$(TargetPath)";
		hr1 = spPropContainer->Evaluate(bstrTargetPath, &bstrTargetPath);
		ASSERT_AND_CONTINUE_ON_FAIL(hr1);
		CStringW strTargetTmp = bstrTargetPath;
		CStringW strTargetDir, strTargetDrive;
		VSASSERT(!strTargetTmp.IsEmpty(), "Hey, no target path!");
		if (strTargetTmp.IsEmpty())
			continue;

		CPathW pathTarget;
		if (!pathTarget.Create(strTargetTmp))
			ASSERT_AND_CONTINUE_ON_FAIL(E_FAIL);
		pathTarget.SetAlwaysRelative();

		CStringW strTargetFile = pathTarget.GetFileName();
		CComBSTR bstrProjDir;
		hr1 = spPropContainer->GetStrProperty(VCPROJID_ProjectDirectory, &bstrProjDir);
		ASSERT_AND_CONTINUE_ON_FAIL(hr1);
		CDirW dirProj;
		dirProj.CreateFromKnown(bstrProjDir);
		pathTarget.GetRelativeName(dirProj, strTargetDir);
		int nLastForwardSlash = strTargetDir.ReverseFind(L'/');
		int nLastBackSlash = strTargetDir.ReverseFind(L'\\');
		if (nLastForwardSlash > nLastBackSlash)
			strTargetDir = strTargetDir.Left(nLastForwardSlash);
		else if (nLastBackSlash > nLastForwardSlash)
			strTargetDir = strTargetDir.Left(nLastBackSlash);
		else	// can only be the same if neither was found
			strTargetDir.Empty();
		int nLen = strTargetDir.GetLength();
		if (nLen <= 3)		// this is minimum size to be absolute path
		{}	// do nothing
		else if ((strTargetDir[0] == L'\\' || strTargetDir[0] == L'/') &&
			(strTargetDir[1] == L'\\' || strTargetDir[1] == L'/'))	// in format \\foo\bar\junk
		{
			int cSlashes = 1;
			int idx = 1;
			while (idx < nLen && cSlashes < 4)
			{
				if (strTargetDir[idx] == L'/' || strTargetDir[idx] == L'\\')
					cSlashes++;
				idx++;
			}
			if (idx < nLen)
			{
				strTargetDrive = strTargetDir.Left(idx-1);
				strTargetDir = strTargetDir.Right(nLen-idx);
			}
		}
		else if (strTargetDir[1] == L':' && (strTargetDir[2] == L'/' || strTargetDir[2] == L'\\')) // in format 'c:\foo\bar'
		{
			strTargetDrive = strTargetDir.Left(2);	// want the 'c:'
			if (strTargetDir.GetLength() <= 2)
				strTargetDir.Empty();
			else
				strTargetDir = strTargetDir.Right(nLen-2);	// take off the 'c:'
		}
		else
		{
			if (strTargetDir[0] != L'.' && strTargetDir[0] != L'/' && strTargetDir[0] != L'\\')
				strTargetDir = L".\\" + strTargetDir;
		}

		CComBSTR bstrCmd = L"@echo off\r\n";
		if (!strTargetDrive.IsEmpty())
		{
			bstrCmd += strTargetDir;
			bstrCmd += L"\r\n";
		}
		if (!strTargetDir.IsEmpty())
		{
			bstrCmd += L"cd ";
			bstrCmd += strTargetDir;
			bstrCmd += L"\r\n";
		}
		bstrCmd += L"regsvr32 /s \"";
		bstrCmd += strTargetFile;
		bstrCmd += L"\"";
		CComBSTR bstrCmdForBuild;
		hr1 = pBldEngine->FormBatchFile(bstrCmd, pErrorContext, &bstrCmdForBuild);

		CComBSTR bstrDescription;
		bstrDescription.LoadString(IDS_REGISTER_OUTPUT);

		if (*ppCmds == NULL)
		{
			hr1 = CVCCommandLineList::CreateInstance(ppCmds);
			ASSERT_AND_CONTINUE_ON_FAIL_OR_NULL(hr1, *ppCmds);
		}
		CComPtr<IVCCommandLine> spCmdLine;
		hr1 = CVCCommandLine::CreateInstance(&spCmdLine);
		ASSERT_AND_CONTINUE_ON_FAIL_OR_NULL(hr, spCmdLine);

		spCmdLine->put_CommandLineContents(bstrCmdForBuild);
		spCmdLine->put_Description(bstrDescription);
		spCmdLine->put_NumberOfProcessors(1);

		(*ppCmds)->Add(spCmdLine, FALSE);
	}

	return S_OK;
}

HRESULT CVCLinkerTool::GetAdditionalDependenciesInternal(IVCPropertyContainer* pItem, IVCBuildAction* pAction, BOOL bForSave, 
	BSTR* pbstrInputs)
{		// additional things to add to command line
	BOOL bAdd = FALSE;
	if (!bForSave)
	{
		CComQIPtr<IVCPropertyContainer> spPropContainer = pItem;
		CComBSTR bstrDelayLoad;
		bAdd = (spPropContainer && spPropContainer->GetStrProperty(VCLINKID_DelayLoadDLLs, &bstrDelayLoad) == S_OK 
			&& bstrDelayLoad.Length() > 0);
	}
	return DoGetAdditionalDependenciesInternal(pItem, pAction, bForSave, pbstrInputs, GetOptionHandler(), 
		VCLINKID_AdditionalDependencies, VCLINKID_DependentInputs, bAdd ? L"DelayImp.lib" : L"");
}

STDMETHODIMP CVCLinkerTool::get_ToolShortName(BSTR* pbstrToolName)
{
	*pbstrToolName = SysAllocString( szLinkerToolShortName );
	return S_OK;
}

STDMETHODIMP CVCLinkerTool::MatchName(BSTR bstrName, VARIANT_BOOL bFullOnly, VARIANT_BOOL* pbMatches)
{
	return DoMatchName(bstrName, szLinkerToolType, szLinkerToolShortName, pbMatches);
}

STDMETHODIMP CVCLinkerTool::CreateToolObject(IVCPropertyContainer* pPropContainer, IVCToolImpl** ppToolObject)
{ 
	return CreateInstance(pPropContainer, ppToolObject); 
}

STDMETHODIMP CVCLinkerTool::CanScanForDependencies(VARIANT_BOOL* pbIsScannable)
{
	return COptionHandlerBase::GetValueTrue(pbIsScannable);
}

STDMETHODIMP CVCLinkerTool::GetDependencies(IVCBuildAction* pAction, IVCBuildStringCollection** ppStrings, 
	VARIANT_BOOL* pbUpToDate)
{
	CHECK_READ_POINTER_NULL(pAction);
	return DoGetDependencies(pAction, ppStrings, pbUpToDate, TRUE);
}

BOOL CVCLinkerTool::CreateOutputName(IVCPropertyContainer* pPropContainer, BSTR* pbstrVal)
{
	return s_optHandler.CreateOutputName(pPropContainer, pbstrVal, FALSE);
}

STDMETHODIMP CVCLinkerTool::CreatePageObject(IUnknown **ppUnk, CLSID*pCLSID, IVCPropertyContainer *pPropCntr, IVCSettingsPage *pPage )
{
	// Get the list of pages
	if( CLSID_LinkGeneral == *pCLSID )
	{
		CPageObjectImpl< CVCLinkerGeneralPage, VCLINKERTOOL_MIN_DISPID, VCLINKERTOOL_MAX_DISPID >::CreateInstance(ppUnk, pPropCntr, pPage);
	}
	else if( CLSID_LinkInput == *pCLSID )
	{
		CPageObjectImpl< CVCLinkerInputPage, VCLINKERTOOL_MIN_DISPID, VCLINKERTOOL_MAX_DISPID >::CreateInstance(ppUnk, pPropCntr, pPage);
	}
	else if( CLSID_LinkDebug == *pCLSID )
	{
		CPageObjectImpl< CVCLinkerDebugPage, VCLINKERTOOL_MIN_DISPID, VCLINKERTOOL_MAX_DISPID >::CreateInstance(ppUnk, pPropCntr, pPage);
	}
	else if( CLSID_LinkSystem == *pCLSID )
	{
		CPageObjectImpl< CVCLinkerSystemPage, VCLINKERTOOL_MIN_DISPID, VCLINKERTOOL_MAX_DISPID >::CreateInstance(ppUnk, pPropCntr, pPage);
	}
	else if( CLSID_LinkOptimization == *pCLSID )
	{
		CPageObjectImpl< CVCLinkerOptimizationPage, VCLINKERTOOL_MIN_DISPID, VCLINKERTOOL_MAX_DISPID >::CreateInstance(ppUnk, pPropCntr, pPage);
	}
	else if( CLSID_LinkAdvanced == *pCLSID )
	{
		CPageObjectImpl< CVCLinkerAdvancedPage, VCLINKERTOOL_MIN_DISPID, VCLINKERTOOL_MAX_DISPID >::CreateInstance(ppUnk, pPropCntr, pPage);
	}
	else if( CLSID_LinkMIDL == *pCLSID )
	{
		CPageObjectImpl< CVCLinkerMIDLPage, VCLINKERTOOL_MIN_DISPID, VCLINKERTOOL_MAX_DISPID >::CreateInstance(ppUnk, pPropCntr, pPage);
	}
	else
	{
		return S_FALSE;
	}
		
	return S_OK;
}

LPCOLESTR CVCLinkerTool::GetToolFriendlyName()
{
	InitToolName();
	return s_bstrToolName;
}

void CVCLinkerTool::InitToolName()
{
	if (s_bstrToolName.Length() == 0)
	{
		if (!s_bstrToolName.LoadString(IDS_LINK_TOOLNAME))
			s_bstrToolName = szLinkerToolType;
	}
}

// general
STDMETHODIMP CVCLinkerTool::get_ToolName(BSTR* pbstrToolName)
{	// friendly name of tool, e.g., "C/C++ Compiler Tool"
	CHECK_POINTER_VALID( pbstrToolName );
	InitToolName();
	s_bstrToolName.CopyTo(pbstrToolName);
	return S_OK;
}

STDMETHODIMP CVCLinkerTool::get_AdditionalOptions(BSTR* pbstrAdditionalOptions)
{	// anything we don't know what to do with, given verbatim, in same order as entered, parent contributions first, goes after all other options
	return ToolGetStrProperty(VCLINKID_AdditionalOptions, pbstrAdditionalOptions);
}

STDMETHODIMP CVCLinkerTool::put_AdditionalOptions(BSTR bstrAdditionalOptions)
{
	CHECK_ZOMBIE( m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE );
	return m_spPropertyContainer->SetStrProperty(VCLINKID_AdditionalOptions, bstrAdditionalOptions);
}

STDMETHODIMP CVCLinkerTool::get_OutputFile(BSTR* pbstrOut)
{	// (/OUT:[file]) change the output file name (default is based on 1st lib or obj name on cmd line)
	return ToolGetStrProperty(VCLINKID_OutputFile, pbstrOut);
}

STDMETHODIMP CVCLinkerTool::put_OutputFile(BSTR bstrOut)
{
	CHECK_ZOMBIE( m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE );
	return m_spPropertyContainer->SetStrProperty(VCLINKID_OutputFile, bstrOut);
}

STDMETHODIMP CVCLinkerTool::get_ShowProgress(linkProgressOption* poptSetting)
{	// see enum above (/VERBOSE)
	return ToolGetIntProperty(VCLINKID_ShowProgress, (long *)poptSetting);
}

STDMETHODIMP CVCLinkerTool::put_ShowProgress(linkProgressOption optSetting)
{
	CHECK_ZOMBIE( m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE );
	CHECK_BOUNDS(StdEnumMin, ShowProgressMax, optSetting);
	return m_spPropertyContainer->SetIntProperty(VCLINKID_ShowProgress, optSetting);
}

STDMETHODIMP CVCLinkerTool::get_Version(BSTR* pbstrVersion)
{	// (/VERSION:major[.minor]) put this version number into header of created image
	return ToolGetStrProperty(VCLINKID_Version, pbstrVersion);
}

STDMETHODIMP CVCLinkerTool::put_Version(BSTR bstrVersion)
{
	CHECK_ZOMBIE( m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE );
	return m_spPropertyContainer->SetStrProperty(VCLINKID_Version, bstrVersion);
}

STDMETHODIMP CVCLinkerTool::get_LinkIncremental(linkIncrementalType* poptSetting)
{	// (/INCREMENTAL:YES, /INCREMENTAL:NO, not set)
	return ToolGetIntProperty(VCLINKID_LinkIncremental, (long *)poptSetting);
}

STDMETHODIMP CVCLinkerTool::put_LinkIncremental(linkIncrementalType optSetting)
{
	CHECK_ZOMBIE( m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE );
	CHECK_BOUNDS(StdEnumMin, LinkIncrMax, optSetting);
	return m_spPropertyContainer->SetIntProperty(VCLINKID_LinkIncremental, optSetting);
}

STDMETHODIMP CVCLinkerTool::get_SuppressStartupBanner(VARIANT_BOOL* pbNoLogo)
{	// (/NOLOGO) enable suppression of copyright message (no explicit off)
	return ToolGetBoolProperty(VCLINKID_SuppressStartupBanner, pbNoLogo);
}

STDMETHODIMP CVCLinkerTool::put_SuppressStartupBanner(VARIANT_BOOL bNoLogo)
{
	CHECK_ZOMBIE( m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE );
	CHECK_VARIANTBOOL( bNoLogo );
	return m_spPropertyContainer->SetBoolProperty(VCLINKID_SuppressStartupBanner, bNoLogo);
}

STDMETHODIMP CVCLinkerTool::get_IgnoreImportLibrary(VARIANT_BOOL* pbIgnore)
{	// ignore any export .lib created
	return ToolGetBoolProperty(VCLINKID_IgnoreImportLibrary, pbIgnore);
}

STDMETHODIMP CVCLinkerTool::put_IgnoreImportLibrary(VARIANT_BOOL bIgnore)
{
	CHECK_ZOMBIE(m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE);
	CHECK_VARIANTBOOL(bIgnore);
	return m_spPropertyContainer->SetBoolProperty(VCLINKID_IgnoreImportLibrary, bIgnore);
}

STDMETHODIMP CVCLinkerTool::get_RegisterOutput(VARIANT_BOOL* pbRegister)
{	// register the output if it's a DLL
	return ToolGetBoolProperty(VCLINKID_RegisterOutput, pbRegister);
}

STDMETHODIMP CVCLinkerTool::put_RegisterOutput(VARIANT_BOOL bRegister)
{
	CHECK_ZOMBIE(m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE);
	CHECK_VARIANTBOOL(bRegister);
	return m_spPropertyContainer->SetBoolProperty(VCLINKID_RegisterOutput, bRegister);
}

STDMETHODIMP CVCLinkerTool::get_AdditionalLibraryDirectories(BSTR* pbstrLibPath)
{	// (/LIBPATH:[dir]) specify path to search for libraries on, can have multiple
	return ToolGetStrProperty(VCLINKID_AdditionalLibraryDirectories, pbstrLibPath, true /* local only */);
}

STDMETHODIMP CVCLinkerTool::put_AdditionalLibraryDirectories(BSTR bstrLibPath)
{
	CHECK_ZOMBIE( m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE );
	return m_spPropertyContainer->SetStrProperty(VCLINKID_AdditionalLibraryDirectories, bstrLibPath);
}

// input
STDMETHODIMP CVCLinkerTool::get_AdditionalDependencies(BSTR* pbstrDependencies)
{	// additional inputs to the link line (comdlg32.lib, etc.)
	return ToolGetStrProperty(VCLINKID_AdditionalDependencies, pbstrDependencies, true /* local only */);
}

STDMETHODIMP CVCLinkerTool::put_AdditionalDependencies(BSTR bstrDependencies)
{
	CHECK_ZOMBIE( m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE );
	return m_spPropertyContainer->SetStrProperty(VCLINKID_AdditionalDependencies, bstrDependencies);
}

STDMETHODIMP CVCLinkerTool::get_IgnoreAllDefaultLibraries(VARIANT_BOOL* pbNoDefaults)
{	// (/NODEFAULTLIB) ignore all default libraries
	return ToolGetBoolProperty(VCLINKID_IgnoreAllDefaultLibraries, pbNoDefaults);
}

STDMETHODIMP CVCLinkerTool::put_IgnoreAllDefaultLibraries(VARIANT_BOOL bNoDefaults)
{
	CHECK_ZOMBIE( m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE );
	CHECK_VARIANTBOOL( bNoDefaults );
	return m_spPropertyContainer->SetBoolProperty(VCLINKID_IgnoreAllDefaultLibraries, bNoDefaults);
}

STDMETHODIMP CVCLinkerTool::get_IgnoreDefaultLibraryNames(BSTR* pbstrLib)
{	// (/NODEFAULTLIB:[name]) ignore particular default library, can have multiple
	return ToolGetStrProperty(VCLINKID_IgnoreDefaultLibraryNames, pbstrLib, true /* local only */);
}

STDMETHODIMP CVCLinkerTool::put_IgnoreDefaultLibraryNames(BSTR bstrLib)
{
	CHECK_ZOMBIE( m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE );
	return m_spPropertyContainer->SetStrProperty(VCLINKID_IgnoreDefaultLibraryNames, bstrLib);
}

STDMETHODIMP CVCLinkerTool::get_ModuleDefinitionFile(BSTR* pbstrDefFile)
{	// (/DEF:file) use/specify module definition file
	return ToolGetStrProperty(VCLINKID_ModuleDefinitionFile, pbstrDefFile);
}

STDMETHODIMP CVCLinkerTool::put_ModuleDefinitionFile(BSTR bstrDefFile)
{
	CHECK_ZOMBIE(m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE);
	return m_spPropertyContainer->SetStrProperty(VCLINKID_ModuleDefinitionFile, bstrDefFile);
}

STDMETHODIMP CVCLinkerTool::get_AddModuleNamesToAssembly(BSTR* pbstrNonAssy)
{	// (/ASSEMBLYMODULE:file) imports a non-assembly file
	return ToolGetStrProperty(VCLINKID_AddModuleNamesToAssembly, pbstrNonAssy, true /* local only */);
}

STDMETHODIMP CVCLinkerTool::put_AddModuleNamesToAssembly(BSTR bstrNonAssy)
{
	CHECK_ZOMBIE(m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE);
	return m_spPropertyContainer->SetStrProperty(VCLINKID_AddModuleNamesToAssembly, bstrNonAssy);
}

STDMETHODIMP CVCLinkerTool::get_EmbedManagedResourceFile(BSTR* pbstrRes)
{	// (/ASSEMBLYRESOURCE:file) embed an assembly resource file
	return ToolGetStrProperty(VCLINKID_EmbedManagedResourceFile, pbstrRes, true /* local only */);
}

STDMETHODIMP CVCLinkerTool::put_EmbedManagedResourceFile(BSTR bstrRes)
{
	CHECK_ZOMBIE(m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE);
	return m_spPropertyContainer->SetStrProperty(VCLINKID_EmbedManagedResourceFile, bstrRes);
}

STDMETHODIMP CVCLinkerTool::get_ForceSymbolReferences(BSTR* pbstrSymbol)
{	// (/INCLUDE:[symbol]) force symbol reference, can have multiple
	return ToolGetStrProperty(VCLINKID_ForceSymbolReferences, pbstrSymbol, true /* local only */);
}

STDMETHODIMP CVCLinkerTool::put_ForceSymbolReferences(BSTR bstrSymbol)
{
	CHECK_ZOMBIE( m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE );
	return m_spPropertyContainer->SetStrProperty(VCLINKID_ForceSymbolReferences, bstrSymbol);
}

STDMETHODIMP CVCLinkerTool::get_DelayLoadDLLs(BSTR* pbstrDLLName)
{	// (/DELAYLOAD:[dll_name]) delay load specified DLL, can have multiple
	return ToolGetStrProperty(VCLINKID_DelayLoadDLLs, pbstrDLLName, true /* local only */);
}

STDMETHODIMP CVCLinkerTool::put_DelayLoadDLLs(BSTR bstrDLLName)
{
	CHECK_ZOMBIE( m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE );
	return m_spPropertyContainer->SetStrProperty(VCLINKID_DelayLoadDLLs, bstrDLLName);
}

// MIDL
STDMETHODIMP CVCLinkerTool::get_MidlCommandFile(BSTR* pbstrMidlCmdFile)
{	// (/midl:<@midl cmd file>) specify response file for MIDL commands to use
	return ToolGetStrProperty(VCLINKID_MidlCommandFile, pbstrMidlCmdFile);
}

STDMETHODIMP CVCLinkerTool::put_MidlCommandFile(BSTR bstrMidlCmdFile)
{
	CHECK_ZOMBIE( m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE );
	return m_spPropertyContainer->SetStrProperty(VCLINKID_MidlCommandFile, bstrMidlCmdFile);
}

STDMETHODIMP CVCLinkerTool::get_IgnoreEmbeddedIDL(VARIANT_BOOL* pbIgnoreIDL)
{ 	// (/ignoreidl) ignore .idlsym sections of .obj files
	return ToolGetBoolProperty(VCLINKID_IgnoreEmbeddedIDL, pbIgnoreIDL);
}

STDMETHODIMP CVCLinkerTool::put_IgnoreEmbeddedIDL(VARIANT_BOOL bIgnoreIDL)
{
	CHECK_ZOMBIE( m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE );
	CHECK_VARIANTBOOL( bIgnoreIDL );
	return m_spPropertyContainer->SetBoolProperty(VCLINKID_IgnoreEmbeddedIDL, bIgnoreIDL);
}

STDMETHODIMP CVCLinkerTool::get_MergedIDLBaseFileName(BSTR* pbstrIDLFile)
{	// (/idlout:<filename>) name intermediate IDL output file
	return ToolGetStrProperty(VCLINKID_MergedIDLBaseFileName, pbstrIDLFile);
}

STDMETHODIMP CVCLinkerTool::put_MergedIDLBaseFileName(BSTR bstrIDLFile)
{
	CHECK_ZOMBIE( m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE );
	return m_spPropertyContainer->SetStrProperty(VCLINKID_MergedIDLBaseFileName, bstrIDLFile);
}

STDMETHODIMP CVCLinkerTool::get_TypeLibraryFile(BSTR* pbstrTLBFile)
{	// (/tlbout:<filename>) name intermediate typelib output file
	return ToolGetStrProperty(VCLINKID_TypeLibraryFile, pbstrTLBFile);
}

STDMETHODIMP CVCLinkerTool::put_TypeLibraryFile(BSTR bstrTLBFile)
{
	CHECK_ZOMBIE( m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE );
	return m_spPropertyContainer->SetStrProperty(VCLINKID_TypeLibraryFile, bstrTLBFile);
}

STDMETHODIMP CVCLinkerTool::get_TypeLibraryResourceID(long* pnResID)
{	// (/tlbid:<id>) specify resource ID for generated .tlb file
	return ToolGetIntProperty(VCLINKID_TypeLibraryResourceID, pnResID);
}

STDMETHODIMP CVCLinkerTool::put_TypeLibraryResourceID(long nResID)
{
	CHECK_ZOMBIE( m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE );
	CHECK_POSITIVE(nResID);
	return m_spPropertyContainer->SetIntProperty(VCLINKID_TypeLibraryResourceID, nResID);
}

// output
STDMETHODIMP CVCLinkerTool::get_LinkDLL(VARIANT_BOOL* pbDLL)
{	// (/DLL) build a DLL as the main output
	return ToolGetBoolProperty(VCLINKID_LinkDLL, pbDLL);
}

STDMETHODIMP CVCLinkerTool::put_LinkDLL(VARIANT_BOOL bDLL)
{
	CHECK_ZOMBIE( m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE );
	CHECK_VARIANTBOOL( bDLL );
	return m_spPropertyContainer->SetBoolProperty(VCLINKID_LinkDLL, bDLL);
}

// debug
STDMETHODIMP CVCLinkerTool::get_GenerateDebugInformation(VARIANT_BOOL* pbDebug)
{	// (/DEBUG) generate debug info
	return ToolGetBoolProperty(VCLINKID_GenerateDebugInformation, pbDebug);
}

STDMETHODIMP CVCLinkerTool::put_GenerateDebugInformation(VARIANT_BOOL bDebug)
{
	CHECK_ZOMBIE( m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE );
	CHECK_VARIANTBOOL( bDebug );
	return m_spPropertyContainer->SetBoolProperty(VCLINKID_GenerateDebugInformation, bDebug);
}

STDMETHODIMP CVCLinkerTool::get_ProgramDatabaseFile(BSTR* pbstrFile)
{	// (/PDB:file) use program database
	return ToolGetStrProperty(VCLINKID_ProgramDatabaseFile, pbstrFile);
}

STDMETHODIMP CVCLinkerTool::put_ProgramDatabaseFile(BSTR bstrFile)
{
	CHECK_ZOMBIE( m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE );
	return m_spPropertyContainer->SetStrProperty(VCLINKID_ProgramDatabaseFile, bstrFile);
}

STDMETHODIMP CVCLinkerTool::get_StripPrivateSymbols(BSTR* pbstrStrippedPDB)
{	// (/PDBSTRIPPED:file) strip private symbols from PDB
	return ToolGetStrProperty(VCLINKID_StripPrivateSymbols, pbstrStrippedPDB);
}

STDMETHODIMP CVCLinkerTool::put_StripPrivateSymbols(BSTR bstrStrippedPDB)
{
	CHECK_ZOMBIE( m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE );
	return m_spPropertyContainer->SetStrProperty(VCLINKID_StripPrivateSymbols, bstrStrippedPDB);
}

STDMETHODIMP CVCLinkerTool::get_GenerateMapFile(VARIANT_BOOL* pbMap)
{	// (/MAP[:file]) generate map file during linking
	return ToolGetBoolProperty(VCLINKID_GenerateMapFile, pbMap);
}

STDMETHODIMP CVCLinkerTool::put_GenerateMapFile(VARIANT_BOOL bMap)
{
	CHECK_ZOMBIE( m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE );
	CHECK_VARIANTBOOL( bMap );
	return m_spPropertyContainer->SetBoolProperty(VCLINKID_GenerateMapFile, bMap);
}

STDMETHODIMP CVCLinkerTool::get_MapFileName(BSTR* pbstrMapFile)
{	// optional argument to GenerateMapFile property
	return ToolGetStrProperty(VCLINKID_MapFileName, pbstrMapFile);
}

STDMETHODIMP CVCLinkerTool::put_MapFileName(BSTR bstrMapFile)
{
	CHECK_ZOMBIE( m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE );
	return m_spPropertyContainer->SetStrProperty(VCLINKID_MapFileName, bstrMapFile);
}

STDMETHODIMP CVCLinkerTool::get_MapExports(VARIANT_BOOL* pbExports)
{	// (/MAPINFO:EXPORTS) include exported functions in map info
	return ToolGetBoolProperty(VCLINKID_MapExports, pbExports);
}

STDMETHODIMP CVCLinkerTool::put_MapExports(VARIANT_BOOL bExports)
{
	CHECK_ZOMBIE( m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE );
	CHECK_VARIANTBOOL( bExports );
	return m_spPropertyContainer->SetBoolProperty(VCLINKID_MapExports, bExports);
}

STDMETHODIMP CVCLinkerTool::get_MapLines(VARIANT_BOOL* pbLines)
{	// (/MAPINFO:LINES) include line number info in map info
	return ToolGetBoolProperty(VCLINKID_MapLines, pbLines);
}

STDMETHODIMP CVCLinkerTool::put_MapLines(VARIANT_BOOL bLines)
{
	CHECK_ZOMBIE( m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE );
	CHECK_VARIANTBOOL( bLines );
	return m_spPropertyContainer->SetBoolProperty(VCLINKID_MapLines, bLines);
}

// System
STDMETHODIMP CVCLinkerTool::get_SubSystem(subSystemOption* poptSetting)
{	// see enum above (/SUBSYSTEM)
	return ToolGetIntProperty(VCLINKID_SubSystem, (long *)poptSetting);
}

STDMETHODIMP CVCLinkerTool::put_SubSystem(subSystemOption optSetting)
{
	CHECK_ZOMBIE( m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE );
	CHECK_BOUNDS(StdEnumMin, LinkSubSystemMax, optSetting);
	return m_spPropertyContainer->SetIntProperty(VCLINKID_SubSystem, optSetting);
}

STDMETHODIMP CVCLinkerTool::get_HeapReserveSize(long* pnReserveSize)
{	// (/HEAP:reserve[,commit]) total heap allocation size in virtual memory
	return ToolGetIntProperty(VCLINKID_HeapReserveSize, pnReserveSize);
}

STDMETHODIMP CVCLinkerTool::put_HeapReserveSize(long nReserveSize)
{
	CHECK_ZOMBIE( m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE );
	CHECK_POSITIVE(nReserveSize);
	return m_spPropertyContainer->SetIntProperty(VCLINKID_HeapReserveSize, nReserveSize);
}

STDMETHODIMP CVCLinkerTool::get_HeapCommitSize(long* pnCommitSize)
{	// (/HEAP:reserve[,commit]) total heap allocation size in physical memory
	return ToolGetIntProperty(VCLINKID_HeapCommitSize, pnCommitSize);
}

STDMETHODIMP CVCLinkerTool::put_HeapCommitSize(long nCommitSize)
{
	CHECK_ZOMBIE( m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE );
	CHECK_POSITIVE(nCommitSize);
	return m_spPropertyContainer->SetIntProperty(VCLINKID_HeapCommitSize, nCommitSize);
}

STDMETHODIMP CVCLinkerTool::get_StackReserveSize(long* pnReserveSize)
{	// (/STACK:reserve[,commit]) total stack allocation size in virtual memory
	return ToolGetIntProperty(VCLINKID_StackReserveSize, pnReserveSize);
}

STDMETHODIMP CVCLinkerTool::put_StackReserveSize(long nReserveSize)
{
	CHECK_ZOMBIE( m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE );
	CHECK_POSITIVE(nReserveSize);
	return m_spPropertyContainer->SetIntProperty(VCLINKID_StackReserveSize, nReserveSize);
}

STDMETHODIMP CVCLinkerTool::get_StackCommitSize(long* pnCommitSize)
{	// (/STACK:reserve[,commit]) total stack allocation size in physical memory
	return ToolGetIntProperty(VCLINKID_StackCommitSize, pnCommitSize);
}

STDMETHODIMP CVCLinkerTool::put_StackCommitSize(long nCommitSize)
{
	CHECK_ZOMBIE( m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE );
	CHECK_POSITIVE(nCommitSize);
	return m_spPropertyContainer->SetIntProperty(VCLINKID_StackCommitSize, nCommitSize);
}

STDMETHODIMP CVCLinkerTool::get_LargeAddressAware(addressAwarenessType* poptSetting)
{	// (/LARGEADDRESSAWARE[:NO]) tells the linker the app can handle addresses greater than 2GB
	return ToolGetIntProperty(VCLINKID_LargeAddressAware, (long *)poptSetting);
}

STDMETHODIMP CVCLinkerTool::put_LargeAddressAware(addressAwarenessType optSetting)
{
	CHECK_ZOMBIE( m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE );
	CHECK_BOUNDS(StdEnumMin, LargeAddrMax, optSetting);
	return m_spPropertyContainer->SetIntProperty(VCLINKID_LargeAddressAware, optSetting);
}

STDMETHODIMP CVCLinkerTool::get_TerminalServerAware(termSvrAwarenessType* poptSetting)
{	// (/TSAWARE, /TSAWARE:NO, not set) not in docs
	return ToolGetIntProperty(VCLINKID_TerminalServerAware, (long *)poptSetting);
}

STDMETHODIMP CVCLinkerTool::put_TerminalServerAware(termSvrAwarenessType optSetting)
{
	CHECK_ZOMBIE( m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE );
	CHECK_BOUNDS(StdEnumMin, TSAwareMax, optSetting);
	return m_spPropertyContainer->SetIntProperty(VCLINKID_TerminalServerAware, optSetting);
}

STDMETHODIMP CVCLinkerTool::get_SwapRunFromCD(VARIANT_BOOL* pbRun)
{	// swap run from CD (/SWAPRUN:CD)
	return ToolGetBoolProperty(VCLINKID_SwapRunFromCD, pbRun);
}

STDMETHODIMP CVCLinkerTool::put_SwapRunFromCD(VARIANT_BOOL bRun)
{
	CHECK_ZOMBIE( m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE );
	CHECK_VARIANTBOOL( bRun );
	return m_spPropertyContainer->SetBoolProperty(VCLINKID_SwapRunFromCD, bRun);
}

STDMETHODIMP CVCLinkerTool::get_SwapRunFromNet(VARIANT_BOOL* pbRun)
{	// swap run from the net (/SWAPRUN:NET)
	return ToolGetBoolProperty(VCLINKID_SwapRunFromNet, pbRun);
}

STDMETHODIMP CVCLinkerTool::put_SwapRunFromNet(VARIANT_BOOL bRun)
{
	CHECK_ZOMBIE( m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE );
	CHECK_VARIANTBOOL( bRun );
	return m_spPropertyContainer->SetBoolProperty(VCLINKID_SwapRunFromNet, bRun);
}

// optimization
STDMETHODIMP CVCLinkerTool::get_OptimizeReferences(optRefType* poptSetting)
{	// (/OPT:REF, /OPT:NOREF, not set) eliminate/keep functions & data never referenced
	return ToolGetIntProperty(VCLINKID_OptimizeReferences, (long *)poptSetting);
}

STDMETHODIMP CVCLinkerTool::put_OptimizeReferences(optRefType optSetting)
{
	CHECK_ZOMBIE( m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE );
	CHECK_BOUNDS(StdEnumMin, OptRefMax, optSetting);
	return m_spPropertyContainer->SetIntProperty(VCLINKID_OptimizeReferences, optSetting);
}

STDMETHODIMP CVCLinkerTool::get_EnableCOMDATFolding(optFoldingType* poptSetting)
{	// (/OPT:ICF, /OPT:NOICF, not set) eliminate/keep redundant COMDAT data (data folding)
	return ToolGetIntProperty(VCLINKID_EnableCOMDATFolding, (long *)poptSetting);
}

STDMETHODIMP CVCLinkerTool::put_EnableCOMDATFolding(optFoldingType optSetting)
{
	CHECK_ZOMBIE( m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE );
	CHECK_BOUNDS(StdEnumMin, OptFoldMax, optSetting);
	return m_spPropertyContainer->SetIntProperty(VCLINKID_EnableCOMDATFolding, optSetting);
}

STDMETHODIMP CVCLinkerTool::get_OptimizeForWindows98(optWin98Type* poptSetting)
{	// (/OPT:WIN98, /OPT:NOWIN98, not set) 
	return ToolGetIntProperty(VCLINKID_OptimizeForWindows98, (long *)poptSetting);
}

STDMETHODIMP CVCLinkerTool::put_OptimizeForWindows98(optWin98Type optSetting)
{
	CHECK_ZOMBIE( m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE );
	CHECK_BOUNDS(StdEnumMin, OptWin98Max, optSetting);
	return m_spPropertyContainer->SetIntProperty(VCLINKID_OptimizeForWindows98, optSetting);
}

STDMETHODIMP CVCLinkerTool::get_FunctionOrder(BSTR* pbstrOrder)
{	// (/ORDER:@[file]) place functions in order specified in file
	return ToolGetStrProperty(VCLINKID_FunctionOrder, pbstrOrder);
}

STDMETHODIMP CVCLinkerTool::put_FunctionOrder(BSTR bstrOrder)
{
	CHECK_ZOMBIE( m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE );
	return m_spPropertyContainer->SetStrProperty(VCLINKID_FunctionOrder, bstrOrder);
}

STDMETHODIMP CVCLinkerTool::get_LinkTimeCodeGeneration(VARIANT_BOOL* pbCodeGen)
{	// (/LTCG) enable link time code gen of objects compiled with /GL
	return ToolGetBoolProperty(VCLINKID_LinkTimeCodeGeneration, pbCodeGen);
}

STDMETHODIMP CVCLinkerTool::put_LinkTimeCodeGeneration(VARIANT_BOOL bCodeGen)
{
	CHECK_ZOMBIE( m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE );
	CHECK_VARIANTBOOL( bCodeGen );
	return m_spPropertyContainer->SetBoolProperty(VCLINKID_LinkTimeCodeGeneration, bCodeGen);
}

// Automation properties
STDMETHODIMP CVCLinkerTool::get_ToolPath(BSTR *pVal)
{
	CHECK_ZOMBIE( m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE );
	CHECK_POINTER_VALID(pVal);
	*pVal = SysAllocString( szLinkerToolPath );
	return S_OK;
}

// Advanced
STDMETHODIMP CVCLinkerTool::get_EntryPointSymbol(BSTR* pbstrEntry)
{	// (/ENTRY:[symbol]) set entry point address for EXE or DLL incompatible with /NOENTRY
	return ToolGetStrProperty(VCLINKID_EntryPointSymbol, pbstrEntry);
}

STDMETHODIMP CVCLinkerTool::put_EntryPointSymbol(BSTR bstrEntry)
{
	CHECK_ZOMBIE( m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE );
	return m_spPropertyContainer->SetStrProperty(VCLINKID_EntryPointSymbol, bstrEntry);
}

STDMETHODIMP CVCLinkerTool::get_ResourceOnlyDLL(VARIANT_BOOL* pbNoEntry)
{	// (/NOENTRY) no entry point.  required for resource-only DLLs incompatible with /ENTRY
	return ToolGetBoolProperty(VCLINKID_ResourceOnlyDLL, pbNoEntry);
}

STDMETHODIMP CVCLinkerTool::put_ResourceOnlyDLL(VARIANT_BOOL bNoEntry)
{
	CHECK_ZOMBIE( m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE );
	CHECK_VARIANTBOOL( bNoEntry );
	return m_spPropertyContainer->SetBoolProperty(VCLINKID_ResourceOnlyDLL, bNoEntry);
}

STDMETHODIMP CVCLinkerTool::get_SetChecksum(VARIANT_BOOL* pbRelease)
{	// (/RELEASE) set the checksum in the header of a .exe
	return ToolGetBoolProperty(VCLINKID_SetChecksum, pbRelease);
}

STDMETHODIMP CVCLinkerTool::put_SetChecksum(VARIANT_BOOL bRelease)
{
	CHECK_ZOMBIE( m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE );
	CHECK_VARIANTBOOL( bRelease );
	return m_spPropertyContainer->SetBoolProperty(VCLINKID_SetChecksum, bRelease);
}

STDMETHODIMP CVCLinkerTool::get_BaseAddress(BSTR* pbstrAddress)
{	// (/BASE:{address| filename,key}) base address to place program at can be numeric or string
	return ToolGetStrProperty(VCLINKID_BaseAddress, pbstrAddress);
}

STDMETHODIMP CVCLinkerTool::put_BaseAddress(BSTR bstrAddress)
{
	CHECK_ZOMBIE( m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE );
	return m_spPropertyContainer->SetStrProperty(VCLINKID_BaseAddress, bstrAddress);
}

STDMETHODIMP CVCLinkerTool::get_TurnOffAssemblyGeneration(VARIANT_BOOL* pbTurnOffAssemblyGeneration)
{	// (/NOASSEMBLY) cause the output file to be built without an assembly
	return ToolGetBoolProperty(VCLINKID_TurnOffAssemblyGeneration, pbTurnOffAssemblyGeneration);
}

STDMETHODIMP CVCLinkerTool::put_TurnOffAssemblyGeneration(VARIANT_BOOL bTurnOffAssemblyGeneration)
{
	CHECK_ZOMBIE( m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE );
	CHECK_VARIANTBOOL( bTurnOffAssemblyGeneration );
	return m_spPropertyContainer->SetBoolProperty(VCLINKID_TurnOffAssemblyGeneration, bTurnOffAssemblyGeneration);
}

STDMETHODIMP CVCLinkerTool::get_SupportUnloadOfDelayLoadedDLL(VARIANT_BOOL* pbSupportUnloadOfDelayLoadedDLL)
{	// (/DELAY:UNLOAD) use to allow explicit unloading of the DLL
	return ToolGetBoolProperty(VCLINKID_SupportUnloadOfDelayLoadedDLL, pbSupportUnloadOfDelayLoadedDLL);
}

STDMETHODIMP CVCLinkerTool::put_SupportUnloadOfDelayLoadedDLL(VARIANT_BOOL bSupportUnloadOfDelayLoadedDLL)
{
	CHECK_ZOMBIE( m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE );
	CHECK_VARIANTBOOL( bSupportUnloadOfDelayLoadedDLL );
	return m_spPropertyContainer->SetBoolProperty(VCLINKID_SupportUnloadOfDelayLoadedDLL, bSupportUnloadOfDelayLoadedDLL);
}

STDMETHODIMP CVCLinkerTool::get_ImportLibrary(BSTR* pbstrImportLib)
{	// (/IMPLIB:[library]) generate specified import library
	return ToolGetStrProperty(VCLINKID_ImportLibrary, pbstrImportLib);
}

STDMETHODIMP CVCLinkerTool::put_ImportLibrary(BSTR bstrImportLib)
{
	CHECK_ZOMBIE( m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE );
	return m_spPropertyContainer->SetStrProperty(VCLINKID_ImportLibrary, bstrImportLib);
}

STDMETHODIMP CVCLinkerTool::get_MergeSections(BSTR* pbstrMerge)
{	// (/MERGE:from=to) merge section 'from' into section 'to'
	return ToolGetStrProperty(VCLINKID_MergeSections, pbstrMerge);
}

STDMETHODIMP CVCLinkerTool::put_MergeSections(BSTR bstrMerge)
{
	CHECK_ZOMBIE( m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE );
	return m_spPropertyContainer->SetStrProperty(VCLINKID_MergeSections, bstrMerge);
}

STDMETHODIMP CVCLinkerTool::get_TargetMachine(machineTypeOption* poptSetting)
{
	return ToolGetIntProperty(VCLINKID_TargetMachine, (long *)poptSetting);
}

STDMETHODIMP CVCLinkerTool::put_TargetMachine(machineTypeOption optSetting)
{
	CHECK_ZOMBIE( m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE );
	CHECK_BOUNDS(StdEnumMin, TargetMachineMax, optSetting);
	return m_spPropertyContainer->SetIntProperty(VCLINKID_TargetMachine, optSetting);
}

/*********************************************************************/

STDMETHODIMP CVCLinkerGeneralPage::get_AdditionalOptions(BSTR* pbstrAdditionalOptions)
{	// anything we don't know what to do with, given verbatim, in same order as entered, parent contributions first, goes after all other options
	return ToolGetStrProperty(VCLINKID_AdditionalOptions, &(CVCLinkerTool::s_optHandler), pbstrAdditionalOptions);
}

STDMETHODIMP CVCLinkerGeneralPage::put_AdditionalOptions(BSTR bstrAdditionalOptions)
{
	return SetStrProperty(VCLINKID_AdditionalOptions, bstrAdditionalOptions);
}

STDMETHODIMP CVCLinkerGeneralPage::get_OutputFile(BSTR* pbstrOut)
{	// (/OUT:[file]) change the output file name (default is based on 1st lib or obj name on cmd line)
	return ToolGetStrProperty(VCLINKID_OutputFile, &(CVCLinkerTool::s_optHandler), pbstrOut);
}

STDMETHODIMP CVCLinkerGeneralPage::put_OutputFile(BSTR bstrOut)
{
	return SetStrProperty(VCLINKID_OutputFile, bstrOut);
}

STDMETHODIMP CVCLinkerGeneralPage::get_ShowProgress(linkProgressOption* poptSetting)
{	// see enum above (/VERBOSE)
	return ToolGetIntProperty(VCLINKID_ShowProgress, &(CVCLinkerTool::s_optHandler), (long *)poptSetting);
}

STDMETHODIMP CVCLinkerGeneralPage::put_ShowProgress(linkProgressOption optSetting)
{
	CHECK_BOUNDS(INHERIT_PROP_VALUE, ShowProgressMax, optSetting);
	return SetIntProperty(VCLINKID_ShowProgress, optSetting);
}

STDMETHODIMP CVCLinkerGeneralPage::get_Version(BSTR* pbstrVersion)
{	// (/VERSION:vers) put this version number into header of created image
	return ToolGetStrProperty(VCLINKID_Version, &(CVCLinkerTool::s_optHandler), pbstrVersion);
}

STDMETHODIMP CVCLinkerGeneralPage::put_Version(BSTR bstrVersion)
{
	return SetStrProperty(VCLINKID_Version, bstrVersion);
}

STDMETHODIMP CVCLinkerGeneralPage::get_LinkIncremental(linkIncrementalType* poptSetting)
{	// (/INCREMENTAL:YES, /INCREMENTAL:NO, not set)
	return ToolGetIntProperty(VCLINKID_LinkIncremental, &(CVCLinkerTool::s_optHandler), (long *)poptSetting);
}

STDMETHODIMP CVCLinkerGeneralPage::put_LinkIncremental(linkIncrementalType optSetting)
{
	CHECK_BOUNDS(INHERIT_PROP_VALUE, LinkIncrMax, optSetting);
	return SetIntProperty(VCLINKID_LinkIncremental, optSetting);
}

STDMETHODIMP CVCLinkerGeneralPage::get_SuppressStartupBanner(enumSuppressStartupBannerUpBOOL* pbNoLogo)
{	// (/NOLOGO) enable suppression of copyright message (no explicit off)
	return GetEnumBoolProperty2(VCLINKID_SuppressStartupBanner, (long *)pbNoLogo);
}

STDMETHODIMP CVCLinkerGeneralPage::put_SuppressStartupBanner(enumSuppressStartupBannerUpBOOL bNoLogo)
{
	return SetBoolProperty(VCLINKID_SuppressStartupBanner, bNoLogo);
}

STDMETHODIMP CVCLinkerGeneralPage::get_IgnoreImportLibrary(enumBOOL* pbIgnore)
{	// ignore export lib
	return GetEnumBoolProperty(VCLINKID_IgnoreImportLibrary, pbIgnore);
}

STDMETHODIMP CVCLinkerGeneralPage::put_IgnoreImportLibrary(enumBOOL bIgnore)
{
	return SetBoolProperty(VCLINKID_IgnoreImportLibrary, bIgnore);
}

STDMETHODIMP CVCLinkerGeneralPage::get_RegisterOutput(enumBOOL* pbRegister)
{	// register the primary output of the build
	return GetEnumBoolProperty(VCLINKID_RegisterOutput, pbRegister);
}

STDMETHODIMP CVCLinkerGeneralPage::put_RegisterOutput(enumBOOL bRegister)
{
	return SetBoolProperty(VCLINKID_RegisterOutput, bRegister);
}

STDMETHODIMP CVCLinkerGeneralPage::get_AdditionalLibraryDirectories(BSTR* pbstrLibPath)
{	// (/LIBPATH:[dir]) specify path to search for libraries on, can have multiple
	return ToolGetStrProperty(VCLINKID_AdditionalLibraryDirectories, &(CVCLinkerTool::s_optHandler), pbstrLibPath, true /* local only */);
}

STDMETHODIMP CVCLinkerGeneralPage::put_AdditionalLibraryDirectories(BSTR bstrLibPath)
{
	return SetStrProperty(VCLINKID_AdditionalLibraryDirectories, bstrLibPath);
}

void CVCLinkerGeneralPage::GetBaseDefault(long id, CComVariant& varValue)
{
	switch (id)
	{
	case VCLINKID_ImportLibrary:
	case VCLINKID_OutputFile:
		{
			CComBSTR bstrVal;
			CVCLinkerTool::s_optHandler.GetDefaultValue( id, &bstrVal, m_pContainer );
			if (!bstrVal)
				bstrVal = L"";
			varValue = bstrVal;
		}
		break;
	case VCLINKID_SuppressStartupBanner:
		{
			VARIANT_BOOL bVal;
			CVCLinkerTool::s_optHandler.GetDefaultValue( id, &bVal );
			varValue = bVal;
		}
		break;
	default:
		CBase::GetBaseDefault(id, varValue);
	}
}

// input
STDMETHODIMP CVCLinkerInputPage::get_AdditionalDependencies(BSTR* pbstrInputs)
{	// additional inputs to the link line (comdlg32.lib, etc.)
	return ToolGetStrProperty(VCLINKID_AdditionalDependencies, &(CVCLinkerTool::s_optHandler), pbstrInputs, true /* local only */);
}

STDMETHODIMP CVCLinkerInputPage::put_AdditionalDependencies(BSTR bstrInputs)
{
	return SetStrProperty(VCLINKID_AdditionalDependencies, bstrInputs);
}

STDMETHODIMP CVCLinkerInputPage::get_IgnoreAllDefaultLibraries(enumIgnoreAllDefaultLibrariesBOOL* pbNoDefaults)
{	// (/NODEFAULTLIB) ignore all default libraries
	return GetEnumBoolProperty2(VCLINKID_IgnoreAllDefaultLibraries, (long *)pbNoDefaults);
}

STDMETHODIMP CVCLinkerInputPage::put_IgnoreAllDefaultLibraries(enumIgnoreAllDefaultLibrariesBOOL bNoDefaults)
{
	return SetBoolProperty(VCLINKID_IgnoreAllDefaultLibraries, bNoDefaults);
}

STDMETHODIMP CVCLinkerInputPage::get_IgnoreDefaultLibraryNames(BSTR* pbstrLib)
{	// (/NODEFAULTLIB:[name]) ignore particular default library, can have multiple
	return ToolGetStrProperty(VCLINKID_IgnoreDefaultLibraryNames, &(CVCLinkerTool::s_optHandler), pbstrLib, true /* local only */);
}

STDMETHODIMP CVCLinkerInputPage::put_IgnoreDefaultLibraryNames(BSTR bstrLib)
{
	return SetStrProperty(VCLINKID_IgnoreDefaultLibraryNames, bstrLib);
}

STDMETHODIMP CVCLinkerInputPage::get_ModuleDefinitionFile(BSTR* pbstrDefFile)
{	// (/DEF:file) use/specify module definition file
	return ToolGetStrProperty(VCLINKID_ModuleDefinitionFile, &(CVCLinkerTool::s_optHandler), pbstrDefFile);
}

STDMETHODIMP CVCLinkerInputPage::put_ModuleDefinitionFile(BSTR bstrDefFile)
{
	return SetStrProperty(VCLINKID_ModuleDefinitionFile, bstrDefFile);
}

STDMETHODIMP CVCLinkerInputPage::get_AddModuleNamesToAssembly(BSTR* pbstrNonAssy)
{	// (/ASSEMBLYMODULE:file) imports a non-assembly file
	return ToolGetStrProperty(VCLINKID_AddModuleNamesToAssembly, &(CVCLinkerTool::s_optHandler), pbstrNonAssy, true /* local only */);
}

STDMETHODIMP CVCLinkerInputPage::put_AddModuleNamesToAssembly(BSTR bstrNonAssy)
{
	return SetStrProperty(VCLINKID_AddModuleNamesToAssembly, bstrNonAssy);
}

STDMETHODIMP CVCLinkerInputPage::get_EmbedManagedResourceFile(BSTR* pbstrRes)
{	// (/ASSEMBLYRESOURCE:file) embed a managed resource file
	return ToolGetStrProperty(VCLINKID_EmbedManagedResourceFile, &(CVCLinkerTool::s_optHandler), pbstrRes, true /* local only */);
}

STDMETHODIMP CVCLinkerInputPage::put_EmbedManagedResourceFile(BSTR bstrRes)
{
	return SetStrProperty(VCLINKID_EmbedManagedResourceFile, bstrRes);
}

STDMETHODIMP CVCLinkerInputPage::get_ForceSymbolReferences(BSTR* pbstrSymbol)
{	// (/INCLUDE:[symbol]) force symbol reference, can have multiple
	return ToolGetStrProperty(VCLINKID_ForceSymbolReferences, &(CVCLinkerTool::s_optHandler), pbstrSymbol, true /* local only */);
}

STDMETHODIMP CVCLinkerInputPage::put_ForceSymbolReferences(BSTR bstrSymbol)
{
	return SetStrProperty(VCLINKID_ForceSymbolReferences, bstrSymbol);
}

STDMETHODIMP CVCLinkerInputPage::get_DelayLoadDLLs(BSTR* pbstrDLLName)
{	// (/DELAYLOAD:[dll_name]) delay load specified DLL, can have multiple
	return ToolGetStrProperty(VCLINKID_DelayLoadDLLs, &(CVCLinkerTool::s_optHandler), pbstrDLLName, true /* local only */);
}

STDMETHODIMP CVCLinkerInputPage::put_DelayLoadDLLs(BSTR bstrDLLName)
{
	return SetStrProperty(VCLINKID_DelayLoadDLLs, bstrDLLName);
}

// debug
STDMETHODIMP CVCLinkerDebugPage::get_GenerateDebugInformation(enumGenerateDebugInformationBOOL* pbDebug)
{	// (/DEBUG) generate debug info
	return GetEnumBoolProperty2(VCLINKID_GenerateDebugInformation, (long *)pbDebug);
}

STDMETHODIMP CVCLinkerDebugPage::put_GenerateDebugInformation(enumGenerateDebugInformationBOOL bDebug)
{
	return SetBoolProperty(VCLINKID_GenerateDebugInformation, bDebug);
}

STDMETHODIMP CVCLinkerDebugPage::get_ProgramDatabaseFile(BSTR* pbstrFile)
{	// (/PDB:file) use program database
	return ToolGetStrProperty(VCLINKID_ProgramDatabaseFile, &(CVCLinkerTool::s_optHandler), pbstrFile);
}

STDMETHODIMP CVCLinkerDebugPage::put_ProgramDatabaseFile(BSTR bstrFile)
{
	return SetStrProperty(VCLINKID_ProgramDatabaseFile, bstrFile);
}

STDMETHODIMP CVCLinkerDebugPage::get_StripPrivateSymbols(BSTR* pbstrStrippedPDB)
{	// (/PDBSTRIPPED:file) strip private symbols from PDB
	return ToolGetStrProperty(VCLINKID_StripPrivateSymbols, &(CVCLinkerTool::s_optHandler), pbstrStrippedPDB);
}

STDMETHODIMP CVCLinkerDebugPage::put_StripPrivateSymbols(BSTR bstrStrippedPDB)
{
	return SetStrProperty(VCLINKID_StripPrivateSymbols, bstrStrippedPDB);
}

STDMETHODIMP CVCLinkerDebugPage::get_GenerateMapFile(enumGenerateMapFileBOOL* pbMap)
{	// (/MAP[:file]) generate map file during linking
	return GetEnumBoolProperty2(VCLINKID_GenerateMapFile, (long *)pbMap);
}

STDMETHODIMP CVCLinkerDebugPage::put_GenerateMapFile(enumGenerateMapFileBOOL bMap)
{
	return SetBoolProperty(VCLINKID_GenerateMapFile, bMap);
}

STDMETHODIMP CVCLinkerDebugPage::get_MapFileName(BSTR* pbstrMapFile)
{	// optional argument to GenerateMapFile property
	return ToolGetStrProperty(VCLINKID_MapFileName, &(CVCLinkerTool::s_optHandler), pbstrMapFile);
}

STDMETHODIMP CVCLinkerDebugPage::put_MapFileName(BSTR bstrMapFile)
{
	return SetStrProperty(VCLINKID_MapFileName, bstrMapFile);
}

STDMETHODIMP CVCLinkerDebugPage::get_MapExports(enumMapExportsBOOL* pbExports)
{	// (/MAPINFO:EXPORTS) include exported functions in map info
	return GetEnumBoolProperty2(VCLINKID_MapExports, (long *)pbExports);
}

STDMETHODIMP CVCLinkerDebugPage::put_MapExports(enumMapExportsBOOL bExports)
{
	return SetBoolProperty(VCLINKID_MapExports, bExports);
}

STDMETHODIMP CVCLinkerDebugPage::get_MapLines(enumMapLinesBOOL* pbLines)
{	// (/MAPINFO:LINES) include line number info in map info
	return GetEnumBoolProperty2(VCLINKID_MapLines, (long *)pbLines);
}

STDMETHODIMP CVCLinkerDebugPage::put_MapLines(enumMapLinesBOOL bLines)
{
	return SetBoolProperty(VCLINKID_MapLines, bLines);
}

void CVCLinkerDebugPage::GetBaseDefault(long id, CComVariant& varValue)
{
	if (id == VCLINKID_ProgramDatabaseFile)
	{
		CComBSTR bstrVal;
		CVCLinkerTool::s_optHandler.GetDefaultValue( VCLINKID_ProgramDatabaseFile, &bstrVal );
		varValue = bstrVal;
	}
	else
		CBase::GetBaseDefault(id, varValue);
}

// System
STDMETHODIMP CVCLinkerSystemPage::HideProperty( DISPID dispid, BOOL *pfHide)
{
	CHECK_POINTER_NULL(pfHide);

	*pfHide = FALSE;

	if( dispid == VCLINKID_SubSystem )
	{
		CComBSTR bstrPlatName;
		m_pContainer->GetStrProperty(VCPLATID_Name, &bstrPlatName);
		if (lstrcmpW(bstrPlatName, L"Xbox") == 0)
		{
			*pfHide = TRUE; // Always /Subsystem::Xbox
		}
	}
	return S_OK;
}

STDMETHODIMP CVCLinkerSystemPage::get_SubSystem(subSystemOption* poptSetting)
{	// see enum above (/SUBSYSTEM)
	return ToolGetIntProperty(VCLINKID_SubSystem, &(CVCLinkerTool::s_optHandler), (long *)poptSetting);
}

STDMETHODIMP CVCLinkerSystemPage::put_SubSystem(subSystemOption optSetting)
{
	CHECK_BOUNDS(INHERIT_PROP_VALUE, LinkSubSystemMax, optSetting);
	return SetIntProperty(VCLINKID_SubSystem, optSetting);
}

STDMETHODIMP CVCLinkerSystemPage::get_HeapReserveSize(long* pnReserveSize)
{	// (/HEAP:reserve[,commit]) total heap allocation size in virtual memory
	return ToolGetIntProperty(VCLINKID_HeapReserveSize, &(CVCLinkerTool::s_optHandler), pnReserveSize);
}

STDMETHODIMP CVCLinkerSystemPage::put_HeapReserveSize(long nReserveSize)
{
	CHECK_POSITIVE_FOR_PROP_PAGES(nReserveSize);
	return SetIntProperty(VCLINKID_HeapReserveSize, nReserveSize);
}

STDMETHODIMP CVCLinkerSystemPage::get_HeapCommitSize(long* pnCommitSize)
{	// (/HEAP:reserve[,commit]) total heap allocation size in physical memory
	return ToolGetIntProperty(VCLINKID_HeapCommitSize, &(CVCLinkerTool::s_optHandler), pnCommitSize);
}

STDMETHODIMP CVCLinkerSystemPage::put_HeapCommitSize(long nCommitSize)
{
	CHECK_POSITIVE_FOR_PROP_PAGES(nCommitSize);
	return SetIntProperty(VCLINKID_HeapCommitSize, nCommitSize);
}

STDMETHODIMP CVCLinkerSystemPage::get_StackReserveSize(long* pnReserveSize)
{	// (/STACK:reserve[,commit]) total stack allocation size in virtual memory
	return ToolGetIntProperty(VCLINKID_StackReserveSize, &(CVCLinkerTool::s_optHandler), pnReserveSize);
}

STDMETHODIMP CVCLinkerSystemPage::put_StackReserveSize(long nReserveSize)
{
	CHECK_POSITIVE_FOR_PROP_PAGES(nReserveSize);
	return SetIntProperty(VCLINKID_StackReserveSize, nReserveSize);
}

STDMETHODIMP CVCLinkerSystemPage::get_StackCommitSize(long* pnCommitSize)
{	// (/STACK:reserve[,commit]) total stack allocation size in physical memory
	return ToolGetIntProperty(VCLINKID_StackCommitSize, &(CVCLinkerTool::s_optHandler), pnCommitSize);
}

STDMETHODIMP CVCLinkerSystemPage::put_StackCommitSize(long nCommitSize)
{
	CHECK_POSITIVE_FOR_PROP_PAGES(nCommitSize);
	return SetIntProperty(VCLINKID_StackCommitSize, nCommitSize);
}

STDMETHODIMP CVCLinkerSystemPage::get_LargeAddressAware(addressAwarenessType* poptSetting)
{	// (/LARGEADDRESSAWARE[:NO]) tells the linker the app can handle addresses greater than 2GB
	return ToolGetIntProperty(VCLINKID_LargeAddressAware, &(CVCLinkerTool::s_optHandler),(long *)poptSetting );
}

STDMETHODIMP CVCLinkerSystemPage::put_LargeAddressAware(addressAwarenessType optSetting)
{
	CHECK_BOUNDS(INHERIT_PROP_VALUE, LargeAddrMax, optSetting);
	return SetIntProperty(VCLINKID_LargeAddressAware, optSetting);
}

STDMETHODIMP CVCLinkerSystemPage::get_TerminalServerAware(termSvrAwarenessType* poptSetting)
{	// (/TSAWARE, /TSAWARE:NO, not set) not in docs
	return ToolGetIntProperty(VCLINKID_TerminalServerAware, &(CVCLinkerTool::s_optHandler), (long *)poptSetting);
}

STDMETHODIMP CVCLinkerSystemPage::put_TerminalServerAware(termSvrAwarenessType optSetting)
{
	CHECK_BOUNDS(INHERIT_PROP_VALUE, TSAwareMax, optSetting);
	return SetIntProperty(VCLINKID_TerminalServerAware, optSetting);
}

STDMETHODIMP CVCLinkerSystemPage::get_SwapRunFromCD(enumSwapRunFromCDBOOL* pbRun)
{	// swap run from CD (/SWAPRUN:CD)
	return GetEnumBoolProperty2(VCLINKID_SwapRunFromCD, (long *)pbRun);
}

STDMETHODIMP CVCLinkerSystemPage::put_SwapRunFromCD(enumSwapRunFromCDBOOL bRun)
{
	return SetBoolProperty(VCLINKID_SwapRunFromCD, bRun);
}

STDMETHODIMP CVCLinkerSystemPage::get_SwapRunFromNet(enumSwapRunFromNetBOOL* pbRun)
{	// swap run from the net (/SWAPRUN:NET)
	return GetEnumBoolProperty2(VCLINKID_SwapRunFromNet, (long *)pbRun);
}

STDMETHODIMP CVCLinkerSystemPage::put_SwapRunFromNet(enumSwapRunFromNetBOOL bRun)
{
	return SetBoolProperty(VCLINKID_SwapRunFromNet, bRun);
}

// optimization
STDMETHODIMP CVCLinkerOptimizationPage::get_OptimizeReferences(optRefType* poptSetting)
{	// (/OPT:REF, /OPT:NOREF, not set) eliminate/keep functions & data never referenced
	return ToolGetIntProperty(VCLINKID_OptimizeReferences, &(CVCLinkerTool::s_optHandler), (long *)poptSetting);
}

STDMETHODIMP CVCLinkerOptimizationPage::put_OptimizeReferences(optRefType optSetting)
{
	CHECK_BOUNDS(INHERIT_PROP_VALUE, OptRefMax, optSetting);
	return SetIntProperty(VCLINKID_OptimizeReferences, optSetting);
}

STDMETHODIMP CVCLinkerOptimizationPage::get_EnableCOMDATFolding(optFoldingType* poptSetting)
{	// (/OPT:ICF, /OPT:NOICF, not set) eliminate/keep redundant COMDAT data (data folding)
	return ToolGetIntProperty(VCLINKID_EnableCOMDATFolding, &(CVCLinkerTool::s_optHandler),(long *)poptSetting );
}

STDMETHODIMP CVCLinkerOptimizationPage::put_EnableCOMDATFolding(optFoldingType optSetting)
{
	CHECK_BOUNDS(INHERIT_PROP_VALUE, OptFoldMax, optSetting);
	return SetIntProperty(VCLINKID_EnableCOMDATFolding, optSetting);
}

STDMETHODIMP CVCLinkerOptimizationPage::get_OptimizeForWindows98(optWin98Type* poptSetting)
{	// (/OPT:WIN98, /OPT:NOWIN98, not set) 
	return ToolGetIntProperty(VCLINKID_OptimizeForWindows98, &(CVCLinkerTool::s_optHandler), (long *)poptSetting);
}

STDMETHODIMP CVCLinkerOptimizationPage::put_OptimizeForWindows98(optWin98Type optSetting)
{
	CHECK_BOUNDS(INHERIT_PROP_VALUE, OptWin98Max, optSetting);
	return SetIntProperty(VCLINKID_OptimizeForWindows98, optSetting);
}

STDMETHODIMP CVCLinkerOptimizationPage::get_FunctionOrder(BSTR* pbstrOrder)
{	// (/ORDER:@[file]) place functions in order specified in file
	return ToolGetStrProperty(VCLINKID_FunctionOrder, &(CVCLinkerTool::s_optHandler), pbstrOrder);
}

STDMETHODIMP CVCLinkerOptimizationPage::put_FunctionOrder(BSTR bstrOrder)
{
	return SetStrProperty(VCLINKID_FunctionOrder, bstrOrder);
}

// MIDL page
STDMETHODIMP CVCLinkerMIDLPage::get_MidlCommandFile(BSTR* pbstrMidlCmdFile)
{	// (/midl:<@midl cmd file>) specify response file for MIDL commands to use
	return ToolGetStrProperty(VCLINKID_MidlCommandFile, &(CVCLinkerTool::s_optHandler), pbstrMidlCmdFile);
}

STDMETHODIMP CVCLinkerMIDLPage::put_MidlCommandFile(BSTR bstrMidlCmdFile)
{
	return SetStrProperty(VCLINKID_MidlCommandFile, bstrMidlCmdFile);
}

STDMETHODIMP CVCLinkerMIDLPage::get_IgnoreEmbeddedIDL(enumIgnoreEmbeddedIDLBOOL* pbIgnoreIDL)
{ 	// (/ignoreidl) ignore .idlsym sections of .obj files
	return GetEnumBoolProperty2(VCLINKID_IgnoreEmbeddedIDL, (long *)pbIgnoreIDL);
}

STDMETHODIMP CVCLinkerMIDLPage::put_IgnoreEmbeddedIDL(enumIgnoreEmbeddedIDLBOOL bIgnoreIDL)
{
	return SetBoolProperty(VCLINKID_IgnoreEmbeddedIDL, bIgnoreIDL);
}

STDMETHODIMP CVCLinkerMIDLPage::get_MergedIDLBaseFileName(BSTR* pbstrIDLFile)
{	// (/idlout:<filename>) name intermediate IDL output file
	return ToolGetStrProperty(VCLINKID_MergedIDLBaseFileName, &(CVCLinkerTool::s_optHandler), pbstrIDLFile);
}

STDMETHODIMP CVCLinkerMIDLPage::put_MergedIDLBaseFileName(BSTR bstrIDLFile)
{
	return SetStrProperty(VCLINKID_MergedIDLBaseFileName, bstrIDLFile);
}

STDMETHODIMP CVCLinkerMIDLPage::get_TypeLibraryFile(BSTR* pbstrTLBFile)
{	// (/tlbout:<filename>) name intermediate typelib output file
	return ToolGetStrProperty(VCLINKID_TypeLibraryFile, &(CVCLinkerTool::s_optHandler), pbstrTLBFile);
}

STDMETHODIMP CVCLinkerMIDLPage::put_TypeLibraryFile(BSTR bstrTLBFile)
{
	return SetStrProperty(VCLINKID_TypeLibraryFile, bstrTLBFile);
}

STDMETHODIMP CVCLinkerMIDLPage::get_TypeLibraryResourceID(long* pnResID)
{	// (/tlbid:<id>) specify resource ID for generated .tlb file
	return ToolGetIntProperty(VCLINKID_TypeLibraryResourceID, &(CVCLinkerTool::s_optHandler), pnResID);
}

STDMETHODIMP CVCLinkerMIDLPage::put_TypeLibraryResourceID(long nResID)
{
	CHECK_POSITIVE_FOR_PROP_PAGES(nResID);
	return SetIntProperty(VCLINKID_TypeLibraryResourceID, nResID);
}

// Advanced
STDMETHODIMP CVCLinkerAdvancedPage::get_EntryPointSymbol(BSTR* pbstrEntry)
{	// (/ENTRY:[symbol]) set entry point address for EXE or DLL incompatible with /NOENTRY
	return ToolGetStrProperty(VCLINKID_EntryPointSymbol, &(CVCLinkerTool::s_optHandler), pbstrEntry);
}

STDMETHODIMP CVCLinkerAdvancedPage::put_EntryPointSymbol(BSTR bstrEntry)
{
	return SetStrProperty(VCLINKID_EntryPointSymbol, bstrEntry);
}

STDMETHODIMP CVCLinkerAdvancedPage::get_ResourceOnlyDLL(enumResourceOnlyDLLBOOL* pbNoEntry)
{	// (/NOENTRY) no entry point.  required for resource-only DLLs incompatible with /ENTRY
	return GetEnumBoolProperty2(VCLINKID_ResourceOnlyDLL, (long *)pbNoEntry);
}

STDMETHODIMP CVCLinkerAdvancedPage::put_ResourceOnlyDLL(enumResourceOnlyDLLBOOL bNoEntry)
{
	return SetBoolProperty(VCLINKID_ResourceOnlyDLL, bNoEntry);
}

STDMETHODIMP CVCLinkerAdvancedPage::get_SetChecksum(enumSetChecksumBOOL* pbRelease)
{	// (/RELEASE) set the checksum in the header of a .exe
	return GetEnumBoolProperty2(VCLINKID_SetChecksum, (long *)pbRelease);
}

STDMETHODIMP CVCLinkerAdvancedPage::put_SetChecksum(enumSetChecksumBOOL bRelease)
{
	return SetBoolProperty(VCLINKID_SetChecksum, bRelease);
}

STDMETHODIMP CVCLinkerAdvancedPage::get_BaseAddress(BSTR* pbstrAddress)
{	// (/BASE:{address| filename,key}) base address to place program at can be numeric or string
	return ToolGetStrProperty(VCLINKID_BaseAddress, &(CVCLinkerTool::s_optHandler), pbstrAddress);
}

STDMETHODIMP CVCLinkerAdvancedPage::put_BaseAddress(BSTR bstrAddress)
{
	return SetStrProperty(VCLINKID_BaseAddress, bstrAddress);
}

STDMETHODIMP CVCLinkerAdvancedPage::get_TurnOffAssemblyGeneration(enumTurnOffAssemblyGenerationBOOL* pbNoAssy)
{	// (/NOASSEMBLY) cause the output file to be built without an assembly
	return GetEnumBoolProperty2(VCLINKID_TurnOffAssemblyGeneration, (long *)pbNoAssy);
}

STDMETHODIMP CVCLinkerAdvancedPage::put_TurnOffAssemblyGeneration(enumTurnOffAssemblyGenerationBOOL bNoAssy)
{
	return SetBoolProperty(VCLINKID_TurnOffAssemblyGeneration, bNoAssy);
}

STDMETHODIMP CVCLinkerAdvancedPage::get_SupportUnloadOfDelayLoadedDLL(enumSupportUnloadOfDelayLoadedDLLBOOL* pbSupportUnloadOfDelayLoadedDLL)
{	// (/DELAY:UNLOAD) use to allow explicit unloading of the DLL
	return GetEnumBoolProperty2(VCLINKID_SupportUnloadOfDelayLoadedDLL, (long *)pbSupportUnloadOfDelayLoadedDLL);
}

STDMETHODIMP CVCLinkerAdvancedPage::put_SupportUnloadOfDelayLoadedDLL(enumSupportUnloadOfDelayLoadedDLLBOOL bDelayUnload)
{
	return SetBoolProperty(VCLINKID_SupportUnloadOfDelayLoadedDLL, bDelayUnload);
}

STDMETHODIMP CVCLinkerAdvancedPage::get_ImportLibrary(BSTR* pbstrImportLib)
{	// (/IMPLIB:[library]) generate specified import library
	return ToolGetStrProperty(VCLINKID_ImportLibrary, &(CVCLinkerTool::s_optHandler), pbstrImportLib);
}

STDMETHODIMP CVCLinkerAdvancedPage::put_ImportLibrary(BSTR bstrImportLib)
{
	return SetStrProperty(VCLINKID_ImportLibrary, bstrImportLib);
}

STDMETHODIMP CVCLinkerAdvancedPage::get_MergeSections(BSTR* pbstrMerge)
{	// (/MERGE:from=to) merge section 'from' into section 'to'
	return ToolGetStrProperty(VCLINKID_MergeSections, &(CVCLinkerTool::s_optHandler), pbstrMerge);
}

STDMETHODIMP CVCLinkerAdvancedPage::put_MergeSections(BSTR bstrMerge)
{
	return SetStrProperty(VCLINKID_MergeSections, bstrMerge);
}

STDMETHODIMP CVCLinkerAdvancedPage::get_TargetMachine(machineTypeOption* poptSetting)
{
	return ToolGetIntProperty(VCLINKID_TargetMachine, &(CVCLinkerTool::s_optHandler), (long *)poptSetting);
}

STDMETHODIMP CVCLinkerAdvancedPage::put_TargetMachine(machineTypeOption optSetting)
{
	CHECK_BOUNDS(INHERIT_PROP_VALUE, TargetMachineMax, optSetting);
	return SetIntProperty(VCLINKID_TargetMachine, optSetting);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\vcpb\linklibhelp.cpp ===
#include "stdafx.h"
#include "vctool.h"
#include "bldhelpers.h"
#include "scanner.h"
#include "bldactions.h"

#include "linklibhelp.h"
#include "linktool.h"

HRESULT CLinkerLibrarianHelper::DoGenerateOutput(long type, IVCBuildActionList* plstActions, IVCBuildErrorContext* pEC, 
	BOOL bIsLinker, IVCToolImpl* pTool)
{
	RETURN_ON_NULL2(plstActions, S_OK);	// nothing to do

	CComPtr<VCProject> spProject;
	CComBSTR bstrProjectDirectory;
	BOOL bFirst = TRUE;
	plstActions->Reset(NULL);
	while (TRUE)
	{
		CComPtr<IVCBuildAction> spAction;
		HRESULT hr = plstActions->Next(&spAction, NULL);
		BREAK_ON_DONE(hr);

		CComPtr<IVCBuildableItem> spItem;
		spAction->get_Item(&spItem);
		CComQIPtr<IVCPropertyContainer> spPropContainer = spItem;
		VSASSERT(spPropContainer != NULL, "Cannot generate output without a property container");

		if (bFirst)
		{
			bFirst = TRUE;
			if (spPropContainer != NULL)
				spPropContainer->GetStrProperty(VCPROJID_ProjectDirectory, &bstrProjectDirectory);	// should never have macros in it
		}

		// Remember that for a newly created project, the file path is supposed to be NULL:
		CPathW pathName;
		CStringW strName;
		
		// do we want the primary output?
		if (type & AOGO_Primary)
		{
			VARIANT_BOOL bHasPrimaryOutput = VARIANT_FALSE;
			hr = DoHasPrimaryOutputFromTool(spItem, VARIANT_TRUE, &bHasPrimaryOutput);
			RETURN_ON_FAIL(hr);
			if (bHasPrimaryOutput == VARIANT_FALSE)
				continue;	// nothing more to do

			HRESULT hrT = DoGetPrimaryOutputFromTool(spItem, pathName, bIsLinker);
			RETURN_ON_FAIL(hrT);

			pathName.GetActualCase(TRUE);
			hrT = spAction->AddOutputFromPath((wchar_t *)(const wchar_t *)pathName, pEC, VARIANT_TRUE, VARIANT_TRUE,
				bIsLinker ? VCLINKID_OutputFile : VCLIBID_OutputFile, pTool);
			if (hrT != S_OK)
				return hrT; 	// failure
		}

		if (!bIsLinker)	// librarian doesn't care about other outputs
			continue;

		// do we want other outputs as well?
		if (type & AOGO_Other)
		{
			RETURN_INVALID_ON_NULL(spPropContainer);

//			// linker output paths
//			// warning: this logic depends of pathName from .exe step
//			linkIncrementalType linkType;
//			if (spPropContainer->GetIntProperty(VCLINKID_LinkIncremental, (long *)&linkType) == S_OK
//				&& linkType == linkIncrementalYes)
//			{
//				pathName.ChangeExtension(L"ILK"); // generate .ilk name from .EXE name & path
//				pathName.GetActualCase(FALSE);
//				spAction->AddOutputFromPath((wchar_t *)(const wchar_t *)pathName, pEC, VARIANT_FALSE, VARIANT_TRUE,
//					bIsLinker ? VCLINKID_OutputFile : VCLIBID_OutputFile, pTool);	// no action (2ndary file)
//				// return value from AddOutputFromPath doesn't matter for 2ndary file
//			}

			// warning: this logic depends of pathName from .exe/.dll step
			VARIANT_BOOL fDll;	// is this generating a dynamic link library?
			if (spPropContainer->GetBoolProperty(VCLINKID_LinkDLL, &fDll) == S_OK && fDll == VARIANT_TRUE)
			{
				BOOL bNeedDefault = TRUE;
				CComBSTR bstrImpLib;
				if (spPropContainer->GetEvaluatedStrProperty(VCLINKID_ImportLibrary, &bstrImpLib) == S_OK)
				{
					strName = bstrImpLib;
					strName.TrimLeft();
					if (!strName.IsEmpty())
					{
						bNeedDefault = FALSE;
						CDirW baseDir;
						CVCToolImpl::CreateDirFromBSTR(bstrProjectDirectory, baseDir);
						if (!pathName.CreateFromDirAndFilename(baseDir, strName))
						{
							CBldAction::InformUserAboutBadFileName(pEC, spPropContainer, pTool, 
								VCLINKID_ImportLibrary, strName);
							return CVCProjectEngine::DoSetErrorInfo3(VCPROJ_E_BAD_PATH, IDS_ERR_CANNOT_CREATE_PATH, 
								bstrProjectDirectory, strName);
						}
						pathName.GetActualCase(TRUE);
					}
				}
				if (bNeedDefault)
				{
					// default is just .dll name
					pathName.ChangeExtension(L"LIB"); // generate .LIB name from .DLL name
					pathName.GetActualCase(FALSE);
				}

				spAction->AddOutputFromPath((wchar_t *)(const wchar_t *)pathName, pEC, VARIANT_FALSE, VARIANT_TRUE,
					bNeedDefault ? VCLINKID_OutputFile : VCLINKID_ImportLibrary, pTool);	// no action (2ndary file)
					// return value from AddOutputFromPath doesn't matter for 2ndary file

				// also generate .exp name with same name as .lib
				pathName.ChangeExtension(L"EXP");
				pathName.GetActualCase(FALSE);

				spAction->AddOutputFromPath((wchar_t *)(const wchar_t*)pathName, pEC, VARIANT_FALSE, VARIANT_TRUE,
					bNeedDefault ? VCLINKID_OutputFile : VCLINKID_ImportLibrary, pTool);	// no action (2ndary file)
				// return value from AddOutputFromPath doesn't matter for 2ndary file
			}

			VARIANT_BOOL bIsDebug = VARIANT_FALSE;
			// name of .pdb file is only an output if /debug
			if (spPropContainer->GetBoolProperty(VCLINKID_GenerateDebugInformation, &bIsDebug) == S_OK && bIsDebug == VARIANT_TRUE)
			{
				CComBSTR bstrPDBName;
				hr = spPropContainer->GetEvaluatedStrProperty(VCLINKID_ProgramDatabaseFile, &bstrPDBName);
				if (hr == S_FALSE)
				{
					CVCLinkerTool::s_optHandler.GetDefaultValue( VCLINKID_ProgramDatabaseFile, &bstrPDBName, spPropContainer );
					spPropContainer->Evaluate(bstrPDBName, &bstrPDBName);
				}
				if (bstrPDBName.Length() != 0)
				{
					strName = bstrPDBName;
					CDirW baseDir;
					CVCToolImpl::CreateDirFromBSTR(bstrProjectDirectory, baseDir);
					if (!pathName.CreateFromDirAndFilename(baseDir, strName))
					{
						CBldAction::InformUserAboutBadFileName(pEC, spPropContainer, pTool, 
							VCLINKID_ProgramDatabaseFile, strName);
						return CVCProjectEngine::DoSetErrorInfo3(VCPROJ_E_BAD_PATH, IDS_ERR_CANNOT_CREATE_PATH, 
							bstrProjectDirectory, strName);
					}

					pathName.GetActualCase(TRUE);
					spAction->AddOutputFromPath((wchar_t *)(const wchar_t *)pathName, pEC, VARIANT_FALSE, VARIANT_TRUE,
						VCLINKID_ProgramDatabaseFile, pTool);	// no action (2ndary file)
					// return value from AddOutputFromPath doesn't matter for 2ndary file
				}
			}

			// name of .map file
			VARIANT_BOOL bPropSet = VARIANT_FALSE;
			if (spPropContainer->GetBoolProperty(VCLINKID_GenerateMapFile, &bPropSet) == S_OK && 
				bPropSet == VARIANT_TRUE)
			{
				BOOL bUseDefault = TRUE;
				CComBSTR bstrMap;
				if (spPropContainer->GetEvaluatedStrProperty(VCLINKID_MapFileName, &bstrMap) == S_OK)
				{
					strName = bstrMap;
					strName.TrimLeft();
					if (!strName.IsEmpty())
					{
						bUseDefault = FALSE;
						CDirW baseDir;
						CVCToolImpl::CreateDirFromBSTR(bstrProjectDirectory, baseDir);
						if (!pathName.CreateFromDirAndFilename(baseDir, strName))
						{
							CBldAction::InformUserAboutBadFileName(pEC, spPropContainer, pTool, 
								VCLINKID_MapFileName, strName);
							return CVCProjectEngine::DoSetErrorInfo3(VCPROJ_E_BAD_PATH, IDS_ERR_CANNOT_CREATE_PATH, 
								bstrProjectDirectory, strName);
						}
						pathName.GetActualCase(TRUE);
					}
				}
				if (bUseDefault)
				{
					pathName.ChangeExtension(L"MAP"); // default
					pathName.GetActualCase(FALSE);
					strName = L"";	// failed to get map name, use default
				}

				spAction->AddOutputFromPath((wchar_t *)(const wchar_t *)pathName, pEC, VARIANT_FALSE, VARIANT_TRUE,
					VCLINKID_MapFileName, pTool);	// no action (2ndary file)
				// return value from AddOutputFromPath doesn't matter for 2ndary file
			}
		}
	}

	return S_OK; // success
}

HRESULT CLinkerLibrarianHelper::DoGetPrimaryOutputFromTool(IUnknown* pItem, CPathW& rpath, BOOL bIsLinker)
{
	CComPtr<VCConfiguration> spProjCfg;
	GetProjectCfgForItem(pItem, &spProjCfg);
	VSASSERT(spProjCfg != NULL, "Linker and librarian only work on project config, not file config");
	RETURN_ON_NULL2(spProjCfg, E_UNEXPECTED);

	VARIANT_BOOL bHasPrimaryOutput = VARIANT_FALSE;
	if (FAILED(DoHasPrimaryOutputFromTool(spProjCfg, VARIANT_TRUE, &bHasPrimaryOutput)) || bHasPrimaryOutput == VARIANT_FALSE)
		return S_FALSE;

	CComQIPtr<IVCPropertyContainer> spPropContainer = spProjCfg;
	RETURN_INVALID_ON_NULL(spPropContainer);

	CComBSTR bstrProjName;
	HRESULT hrT = spPropContainer->GetStrProperty(VCPROJID_ProjectDirectory, &bstrProjName);	// should never have macros in it
	RETURN_ON_FAIL(hrT);
	CStringW strDirName = bstrProjName;
	CDirW dirProj;
	if (!dirProj.CreateFromKnown(strDirName))
		return CVCProjectEngine::DoSetErrorInfo(VCPROJ_E_INTERNAL_ERR, IDS_ERR_INTERNAL_ERROR);

	CStringW strName;
	CComBSTR bstrName;
	if (spPropContainer->GetEvaluatedStrProperty(bIsLinker ? VCLINKID_OutputFile : VCLIBID_OutputFile, &bstrName) == S_OK)
	{
		strName = bstrName;
		if (!strName.IsEmpty())
		{
			if( !rpath.CreateFromDirAndFilename(dirProj, strName))
				return CVCProjectEngine::DoSetErrorInfo3(VCPROJ_E_BAD_PATH, IDS_ERR_CANNOT_CREATE_PATH, strDirName, strName);
			rpath.GetActualCase(TRUE);

			return S_OK;
		}
	}

	// if we get here, either the non-default is blank or there isn't one
	CreateOutputName(spPropContainer, &bstrName);
	strName = bstrName;

	if (!rpath.CreateFromDirAndFilename(dirProj, strName))
		return CVCProjectEngine::DoSetErrorInfo3(VCPROJ_E_BAD_PATH, IDS_ERR_CANNOT_CREATE_PATH, strDirName, strName);
	rpath.GetActualCase(TRUE);

	return S_OK;
}

void CLinkerLibrarianHelper::GetProjectCfgForItem(IUnknown* pItem, VCConfiguration** pProjCfg)
{
	if (pProjCfg == NULL)
		return;
	*pProjCfg = NULL;

	CComQIPtr<VCConfiguration> spProjCfg = pItem;
	if (spProjCfg != NULL)
	{
		*pProjCfg = spProjCfg.Detach();
		return;
	}

	CComQIPtr<IVCFileConfigurationImpl> spFileCfgImpl = pItem;
	if (spFileCfgImpl == NULL)
		return;

	CComPtr<IDispatch> spDispProjCfg;
	if (FAILED(spFileCfgImpl->get_Configuration(&spDispProjCfg)) || spDispProjCfg == NULL)
		return;

	spProjCfg = spDispProjCfg;
	*pProjCfg = spProjCfg.Detach();
}

HRESULT CLinkerLibrarianHelper::DoHasDependencies(IVCBuildAction* pAction, BOOL bIsLinker, VARIANT_BOOL* pbHasDependencies)
{
	CHECK_POINTER_NULL(pbHasDependencies);
	*pbHasDependencies = VARIANT_FALSE;
	RETURN_ON_NULL2(pAction, S_FALSE);

	CComPtr<IVCBuildableItem> spItem;
	pAction->get_Item(&spItem);
	CComQIPtr<IVCPropertyContainer> spPropContainer = spItem;
	if (spPropContainer != NULL)
	{
		UINT idUserDeps = bIsLinker ? VCLINKID_AdditionalDependencies : VCLIBID_AdditionalDependencies;
		CComBSTR bstrLibs;
		HRESULT hr = spPropContainer->GetStrProperty(idUserDeps, &bstrLibs);
		if (hr == S_OK)
		{
			*pbHasDependencies = VARIANT_TRUE;
			return S_OK;
		}
	}

	CComPtr<VCConfiguration> spProjCfg;
	GetProjectCfgForItem(spItem, &spProjCfg);
	CComQIPtr<IVCConfigurationImpl> spProjCfgImpl = spProjCfg;
	RETURN_ON_NULL2(spProjCfgImpl, S_FALSE);

	return spProjCfgImpl->get_HasProjectDependencies(pbHasDependencies);
}

HRESULT CLinkerLibrarianHelper::DoGetAdditionalDependenciesInternal(IVCPropertyContainer* pItem, IVCBuildAction* pAction,
	BOOL bForSave, BSTR* pbstrInputs, COptionHandlerBase* poptHandler, UINT idUserDeps, UINT idProjDeps, 
	LPCOLESTR szExtras /* = L"" */)
{
	CHECK_ZOMBIE( pItem, IDS_ERR_CFG_ZOMBIE );
	CHECK_POINTER_NULL( pbstrInputs );

	if (bForSave)
	{
		*pbstrInputs = NULL;
		CComVariant varDeps;
		HRESULT hr = pItem->GetLocalProp(idUserDeps, &varDeps);
		if (hr == S_OK && varDeps.vt == VT_BSTR)
		{
			CComBSTR bstrDeps = varDeps.bstrVal;
			*pbstrInputs = bstrDeps.Detach();
		}
		else if (hr == S_FALSE)
			poptHandler->GetDefaultValue( idUserDeps, pbstrInputs );
		return hr;
	}

	CComBSTR bstrExtras;
	if (szExtras && szExtras[0] != L'\0')
	{
		bstrExtras = L" ";
		bstrExtras += szExtras;
	}

	CComBSTR bstrUserExtraInputs;
	HRESULT hr1 = pItem->GetMultiProp(idUserDeps, L" ", VARIANT_FALSE, &bstrUserExtraInputs);
	if (hr1 == S_FALSE)
		poptHandler->GetDefaultValue( idUserDeps, &bstrUserExtraInputs );
	RETURN_ON_FAIL(hr1);
	HRESULT hr2 = pItem->Evaluate(bstrUserExtraInputs, &bstrUserExtraInputs);
	RETURN_ON_FAIL(hr2);

	// best way to figure out project dependencies, unfortunately, is to go out and get them
	CComPtr<IVCBuildStringCollection> spStrings;
	VARIANT_BOOL bUpToDate;
	HRESULT hr3 = DoGetDependencies(pAction, &spStrings, &bUpToDate, idProjDeps == VCLINKID_DependentInputs, FALSE /* !dirty */);
	RETURN_ON_FAIL(hr3);
	CComBSTR bstrProjExtraInputs;
	hr3 = pItem->GetStrProperty(idProjDeps, &bstrProjExtraInputs);	// shared ID for dependent inputs
	if (hr3 == S_FALSE)
	{
		bstrUserExtraInputs += bstrExtras;
		*pbstrInputs = bstrUserExtraInputs.Detach();
		return hr1;
	}

	CStringW strUserInputs = bstrUserExtraInputs;
	strUserInputs.TrimLeft();
	strUserInputs.TrimRight();
	CStringW strProjInputs = bstrProjExtraInputs;
	strProjInputs.TrimLeft();
	strProjInputs.TrimRight();
	CComBSTR bstrFinalExtras = strUserInputs;
	if (!strUserInputs.IsEmpty() && !strProjInputs.IsEmpty())
		bstrFinalExtras += L" ";
	CComBSTR bstrProjInputs;
	if (!strProjInputs.IsEmpty())
		bstrProjInputs = strProjInputs;
	bstrFinalExtras += bstrProjInputs;
	bstrFinalExtras += bstrExtras;
	*pbstrInputs = bstrFinalExtras.Detach();

	return S_OK;
}

int CLinkerLibrarianHelper::GetNextDep(int nStartDep, CStringW& strDepList, int nDepLen, CStringW& strDep)
{
	strDep.Empty();
	if (nStartDep < 0)
		return nStartDep;
	else if (nStartDep >= nDepLen)
		return -1;

	int nSpace = nStartDep;
	const wchar_t* pchDepList = (const wchar_t*)strDepList + nStartDep;
	while (*pchDepList == L' ' && nSpace < nDepLen)	// first, skip any leading spaces
	{
		pchDepList++;
		nSpace++;
	}

	if (nSpace == nDepLen)	// we were dealing with trailing spaces
		return -1;

	nStartDep = nSpace;
	wchar_t chTerm;
	if (*pchDepList == L'"')
	{
		pchDepList++;	// go to next character;
		nSpace++;
		chTerm = L'"';
	}
	else
		chTerm = L' ';

	while (*pchDepList != chTerm && nSpace < nDepLen)
	{
		pchDepList++;
		nSpace++;
	}
	if (chTerm == L'"' && nSpace < nDepLen)	// need to pick up the terminator in this case...
		nSpace++;

	if (nSpace < nDepLen)
	{
		strDep = strDepList.Mid(nStartDep, nSpace-nStartDep);
		nSpace++;
		return nSpace;
	}

	if (nStartDep < nDepLen)
		strDep = strDepList.Right(nDepLen-nStartDep);

	return -1;
}

HRESULT CLinkerLibrarianHelper::DoGetDependencies(IVCBuildAction* pAction, IVCBuildStringCollection** ppStrings, 
	VARIANT_BOOL* pbUpToDate, BOOL bIsLinker, BOOL bAllowDirty /* = TRUE */)
{
	CHECK_POINTER_NULL(ppStrings);
	*ppStrings = NULL;
	RETURN_ON_NULL2(pAction, S_FALSE);

	BOOL bHasDepend = FALSE;

	HRESULT hr1 = S_FALSE;
	CComPtr<IVCBuildableItem> spItem;
	pAction->get_Item(&spItem);
	CComQIPtr<IVCConfigurationImpl> spProjCfgImpl = spItem;
	if (spProjCfgImpl != NULL)
	{
		hr1 = spProjCfgImpl->get_ProjectDependenciesAsStrings(ppStrings);
		RETURN_ON_FAIL(hr1);
		if (hr1 == S_OK)
			bHasDepend = TRUE;
	}
	

	UINT idUserDeps = bIsLinker ? VCLINKID_AdditionalDependencies : VCLIBID_AdditionalDependencies;
	UINT idProjDeps = bIsLinker ? VCLINKID_DependentInputs : VCLIBID_DependentInputs;
	UINT idDefFile = bIsLinker ? VCLINKID_ModuleDefinitionFile : VCLIBID_ModuleDefinitionFile;
	UINT idBuiltFlag = bIsLinker ? VCLINKID_LinkerCommandLineGenerated : VCLIBID_LibCommandLineGenerated;
	CComPtr<IVCPropertyContainer> spPropContainer;
	pAction->get_PropertyContainer(&spPropContainer);
	VSASSERT(spPropContainer, "Hey, how'd we get to GetDependencies with an action with no property container?!?");
	RETURN_ON_NULL(spPropContainer);
	CComBSTR bstrDef;
	if (spPropContainer->GetEvaluatedStrProperty(idDefFile, &bstrDef) == S_OK)
	{
		CStringW strName = bstrDef;
		strName.TrimLeft();
		if (!strName.IsEmpty())
		{
			CPathW pathName;
			if (!CVCToolImpl::CreatePathRelativeToProject(spPropContainer, strName, pathName))
				return CVCProjectEngine::DoSetErrorInfo2(VCPROJ_E_BAD_PATH, IDS_ERR_CANNOT_CREATE_RELATIVE_PATH, strName);
			if (*ppStrings == NULL)	// not created yet
			{
				HRESULT hr = CVCBuildStringCollection::CreateInstance(ppStrings);
				RETURN_ON_FAIL_OR_NULL2(hr, *ppStrings, E_OUTOFMEMORY);
			}
			(*ppStrings)->Add((wchar_t *)(const wchar_t *)pathName);
			bHasDepend = TRUE;
		}
	}

	// generate dependencies based on linker or librarian additional inputs
	CComBSTR bstrLocalDeps;
	spPropContainer->GetMultiProp(idUserDeps, L" ", VARIANT_FALSE, &bstrLocalDeps);

	CStringW strLocalDeps = bstrLocalDeps;
	strLocalDeps.TrimLeft();
	strLocalDeps.TrimRight();
	if (!strLocalDeps.IsEmpty())
	{
		if (*ppStrings == NULL)	// not created yet
		{
			HRESULT hr = CVCBuildStringCollection::CreateInstance(ppStrings);
			RETURN_ON_FAIL_OR_NULL2(hr, *ppStrings, E_OUTOFMEMORY);
		}

		BldFileRegHandle frh = NULL;
		if (spItem != NULL)
			spItem->get_FileRegHandle((void **)&frh);
		const CPathW* pPath = NULL;
		if (frh)
			pPath = g_FileRegistry.GetRegEntry(frh)->GetFilePath();

		int nIdx = 0;
		int nMax = (int) strLocalDeps.GetLength();
		int	iEntryType = IncTypeCheckLibPath | IncTypeCheckOriginalDir | IncTypeCheckIntDir | IncTypeCheckOutDir;

		CVCStringWList strlstIncs;
		while (nIdx >= 0)
		{
			CStringW strDep;
			nIdx = GetNextDep(nIdx, strLocalDeps, nMax, strDep);
			strDep.TrimLeft();
			if (strDep.IsEmpty())
				continue;

			strDep.TrimRight();
			if (strDep.GetAt(0) == L'"')
				strlstIncs.AddTail(strDep);
			else
				strlstIncs.AddTail( L"\"" + strDep + L"\"" );
		}
		if  (strlstIncs.GetCount() > 0)
		{
			CVCStringWList strlstPaths;
			BOOL bFoundDeps = CVCToolImpl::ResolveIncludeDirectivesToPath(*pPath, pAction, strlstIncs, strlstPaths, FALSE);
			VCPOSITION pos = strlstPaths.GetHeadPosition();
			if (!bFoundDeps)
			{
				pAction->MarkMissingDependencies(TRUE);
				bHasDepend = TRUE;
			}
			else if (pos)
				bHasDepend = TRUE;
			while (pos)
			{
				CStringW strInc = strlstPaths.GetNext(pos);
				CComBSTR bstrInc = strInc;
				(*ppStrings)->Add(bstrInc);
			}
		}

		if (NULL != pbUpToDate)
		{
			*pbUpToDate = FALSE;
		}
	}

	// now that we've got the list of dependencies at the project level, we need to make sure we add them
	// to the list of inputs to the linker or librarian
	BOOL bResetDirty = TRUE;
	if (!bAllowDirty)	// playing with this from somewhere we DON'T want to be setting the dirty flag...
	{
		VARIANT_BOOL bVal;
		bResetDirty = (spPropContainer->GetBoolProperty(idBuiltFlag, &bVal) == S_OK);
		spPropContainer->Clear(idBuiltFlag);
	}

	if (bHasDepend && *ppStrings)
	{
		CStringW strProjDeps;
		CComBSTR bstrProjDir;
		spPropContainer->GetStrProperty(VCPROJID_ProjectDirectory, &bstrProjDir);
		CDirW dirProj;
		bool bNeedSpace = false;
		if (dirProj.CreateFromKnown(bstrProjDir))
		{
			(*ppStrings)->Reset();
			while (TRUE)
			{
				CComBSTR bstrDep;
				if ((*ppStrings)->Next(&bstrDep) != S_OK)
					break;

				CPathW path;
				if (!path.Create(bstrDep))
					continue;

				if (_wcsicmp(path.GetExtension(), L".lib") != 0)	// only looking for .lib extensions
					continue;

				CStringW strPath;
				if (!path.GetRelativeName(dirProj, strPath, TRUE))
					continue;

				if (bNeedSpace)
					strProjDeps += L" ";

				strProjDeps += strPath;
				bNeedSpace = true;
			}
		}

		if (!strProjDeps.IsEmpty())
		{
			CComBSTR bstrProjDeps = strProjDeps;
			CComBSTR bstrOldProjDeps;
			if (spPropContainer->GetStrProperty(idProjDeps, &bstrOldProjDeps) != S_OK || 
				_wcsicmp(bstrProjDeps, bstrOldProjDeps) != 0)
				spPropContainer->SetStrProperty(idProjDeps, bstrProjDeps);
		}
		else
		{
			CComVariant var;
			if (spPropContainer->GetProp(idProjDeps, &var) == S_OK)
				spPropContainer->Clear(idProjDeps);
		}
	}
	else
	{
		CComVariant var;
		if (spPropContainer->GetProp(idProjDeps, &var) == S_OK)
			spPropContainer->Clear(idProjDeps);
	}

	if (bResetDirty)
		spPropContainer->SetBoolProperty(idBuiltFlag, VARIANT_TRUE);	// we've now been through here at least once

	return bHasDepend ? S_OK : S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\vcpb\midltool.h ===
// VCMidlTool.h: Definition of the CVCMidlTool class
//
//////////////////////////////////////////////////////////////////////

#pragma once

#include "vctool.h"
#include "MidlToolBase.h"

// classes in this header
class CVCMidlTool;
class CMidlToolOptionHandler;

class CMidlToolOptionHandler : public COptionHandlerBase
{
public:
	DECLARE_OPTION_TABLE()

public:
	// default value handlers
	// string props
	virtual void GetDefaultValue( long id, BSTR *pVal, IVCPropertyContainer *pPropCnt = NULL );
	// integer props
	virtual void GetDefaultValue( long id, long *pVal, IVCPropertyContainer *pPropCnt = NULL );
	// boolean props
	virtual void GetDefaultValue( long id, VARIANT_BOOL *pVal, IVCPropertyContainer *pPropCnt = NULL );

protected:
	virtual BOOL SetEvenIfDefault(VARIANT *pVarDefault, long idOption);
	virtual BOOL SynthesizeOptionIfNeeded(IVCPropertyContainer* pPropContainer, long idOption);
	virtual BOOL SynthesizeOption(IVCPropertyContainer* pPropContainer, long idOption, CComVariant& rvar);

public:
	BOOL CreatesTypeLib(IVCPropertyContainer* pPropContainer);
};

/////////////////////////////////////////////////////////////////////////////
// CVCMidlTool

class ATL_NO_VTABLE CVCMidlTool : 
	public IDispatchImpl<VCMidlTool, &IID_VCMidlTool, &LIBID_VCProjectEngineLibrary, PublicProjBuildTypeLibNumber,0, CVsTypeInfoHolder>, 
	public CComObjectRoot,
	public CVCToolImpl
{
public:
	CVCMidlTool() 
	{
		m_nLowKey = VCMIDLTOOL_MIN_DISPID;
		m_nHighKey = VCMIDLTOOL_MAX_DISPID;
		m_nDirtyKey = VCMIDLID_CmdLineOptionsDirty;
		m_nDirtyOutputsKey = VCMIDLID_OutputsDirty;
	}
	static HRESULT CreateInstance(IVCPropertyContainer* pPropContainer, IVCToolImpl** ppTool);

BEGIN_COM_MAP(CVCMidlTool)
	COM_INTERFACE_ENTRY(IVCToolImpl)
 	COM_INTERFACE_ENTRY(VCMidlTool)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE(CVCMidlTool) 

// VCMidlTool
public:
	// general (/ms_ext, /c_ext left out because they're archaic); @response deliberately left out
	STDMETHOD(get_ToolName)(BSTR* pbstrToolName);	// friendly name of tool, e.g., "C/C++ Compiler Tool"
	STDMETHOD(get_AdditionalOptions)(BSTR* pbstrAdditionalOptions);	// anything we don't know what to do with, given verbatim, in same order as entered, parent contributions first, goes after all other options
	STDMETHOD(put_AdditionalOptions)(BSTR bstrAdditionalOptions);
	STDMETHOD(get_PreprocessorDefinitions)(BSTR* pbstrDefines);	// (/D![macro]) define macro for MIDL.  can have multiple.
	STDMETHOD(put_PreprocessorDefinitions)(BSTR bstrDefines);
	STDMETHOD(get_AdditionalIncludeDirectories)(BSTR* pbstrIncludePath);	// (/I![path]) directory to add to include path, may have multiple
	STDMETHOD(put_AdditionalIncludeDirectories)(BSTR bstrIncludePath);
	STDMETHOD(get_IgnoreStandardIncludePath)(VARIANT_BOOL* pbIgnore);	// (/no_def_idir) ignore current and INCLUDE path
	STDMETHOD(put_IgnoreStandardIncludePath)(VARIANT_BOOL bIgnore);
	STDMETHOD(get_MkTypLibCompatible)(VARIANT_BOOL* pbCompatible);	// (/mktyplib203) forces compatibility with mktyplib.exe version 2.03
	STDMETHOD(put_MkTypLibCompatible)(VARIANT_BOOL bCompatible);
	STDMETHOD(get_WarningLevel)(midlWarningLevelOption* poptSetting);	// see enum above (/W0 - /W4)
	STDMETHOD(put_WarningLevel)(midlWarningLevelOption optSetting);
	STDMETHOD(get_WarnAsError)(VARIANT_BOOL* pbWarnAsError);	// (/WX) treat warnings as errors
	STDMETHOD(put_WarnAsError)(VARIANT_BOOL bWarnAsError);
	STDMETHOD(get_SuppressStartupBanner)(VARIANT_BOOL* pbNoLogo);	// (/nologo) enable suppression of copyright message
	STDMETHOD(put_SuppressStartupBanner)(VARIANT_BOOL bNoLogo);
	STDMETHOD(get_DefaultCharType)(midlCharOption* poptSetting);	// see enum above (/char)
	STDMETHOD(put_DefaultCharType)(midlCharOption optSetting);
	STDMETHOD(get_TargetEnvironment)(midlTargetEnvironment* poptSetting);	// (/env win64 vs. /env win32) target Win64 (or Win32) environment
	STDMETHOD(put_TargetEnvironment)(midlTargetEnvironment optSetting);
	STDMETHOD(get_GenerateStublessProxies)(VARIANT_BOOL* poptSetting);	// (/Oicf)
	STDMETHOD(put_GenerateStublessProxies)(VARIANT_BOOL optSetting);
	// output 
	STDMETHOD(get_GenerateTypeLibrary)(VARIANT_BOOL* poptSetting);	// (/notlb for no) generate a type library or not; default: yes
	STDMETHOD(put_GenerateTypeLibrary)(VARIANT_BOOL optSetting);
	STDMETHOD(get_OutputDirectory)(BSTR* pbstrOut);	// (/out dir) directory to place output files in; default: project directory
	STDMETHOD(put_OutputDirectory)(BSTR bstrOut);
	STDMETHOD(get_HeaderFileName)(BSTR* pbstrHeaderFile);	// (/h[eader] filename) specify name of header file generated; default: <idlfile>.h
	STDMETHOD(put_HeaderFileName)(BSTR bstrHeaderFile);
	STDMETHOD(get_DLLDataFileName)(BSTR* pbstrDLLData);	// (/dlldata filename) specify name of DLLDATA file generated; default: dlldata.c
	STDMETHOD(put_DLLDataFileName)(BSTR bstrDLLData);
	STDMETHOD(get_InterfaceIdentifierFileName)(BSTR* pbstrIID);	// (/iid filename) specify name of IID file; default: <idlfile>_i.c
	STDMETHOD(put_InterfaceIdentifierFileName)(BSTR bstrIID);
	STDMETHOD(get_ProxyFileName)(BSTR* pbstrProxyFile);	// (/proxy filename) specify name of proxy file; default: <idlfile>_p.c
	STDMETHOD(put_ProxyFileName)(BSTR bstrProxyFile);
	STDMETHOD(get_TypeLibraryName)(BSTR* pbstrTLBFile);	// (/tlb filename) specify name of TLB file; default: <idlfile>.tlb
	STDMETHOD(put_TypeLibraryName)(BSTR bstrTLBFile);
	// advanced (/nocpp ignored as it is not in docs)
	STDMETHOD(get_EnableErrorChecks)(midlErrorCheckOption* poptSetting);	// see enum above (/error {none|all}) 
	STDMETHOD(put_EnableErrorChecks)(midlErrorCheckOption optSetting);
	STDMETHOD(get_ErrorCheckAllocations)(VARIANT_BOOL* pbErrorCheck);	// (/error allocation) check for out of memory errors
	STDMETHOD(put_ErrorCheckAllocations)(VARIANT_BOOL bErrorCheck);
	STDMETHOD(get_ErrorCheckBounds)(VARIANT_BOOL* pbErrorCheck);	// (/error bounds_check) check size	vs. transmission length specifications
	STDMETHOD(put_ErrorCheckBounds)(VARIANT_BOOL bErrorCheck);
	STDMETHOD(get_ErrorCheckEnumRange)(VARIANT_BOOL* pbErrorCheck);	// (/error enum) check enum values to be in allowable range not in docs
	STDMETHOD(put_ErrorCheckEnumRange)(VARIANT_BOOL bErrorCheck);
	STDMETHOD(get_ErrorCheckRefPointers)(VARIANT_BOOL* pbErrorCheck);	// (/error ref) check ref pointers to be non-NULL
	STDMETHOD(put_ErrorCheckRefPointers)(VARIANT_BOOL bErrorCheck);
	STDMETHOD(get_ErrorCheckStubData)(VARIANT_BOOL* pbErrorCheck);	// (/error stub_data) emit additional check for server side data stub validity
	STDMETHOD(put_ErrorCheckStubData)(VARIANT_BOOL bErrorCheck);
	STDMETHOD(get_ValidateParameters)(VARIANT_BOOL* pbValidate);	// (/robust) generate additional information to validate parameters not in docs
	STDMETHOD(put_ValidateParameters)(VARIANT_BOOL bValidate);
	STDMETHOD(get_StructMemberAlignment)(midlStructMemberAlignOption* poptSetting);	// see enum above (/Zp[num])
	STDMETHOD(put_StructMemberAlignment)(midlStructMemberAlignOption optSetting);
	STDMETHOD(get_RedirectOutputAndErrors)(BSTR* pbstrOutput);	// (/o file) redirect output from screen to a file
	STDMETHOD(put_RedirectOutputAndErrors)(BSTR bstrOutput);
	STDMETHOD(get_CPreprocessOptions)(BSTR* pbstrOpt);	// (/cpp_opt"[option]") C-compiler preprocessor option to pass to MIDL.  must be in exact format for desired switches
	STDMETHOD(put_CPreprocessOptions)(BSTR bstrOpt);
	STDMETHOD(get_UndefinePreprocessorDefinitions)(BSTR* pbstrUndefines);	// (/U![macro]) remove any previous definition of symbol.  can have multiple.
	STDMETHOD(put_UndefinePreprocessorDefinitions)(BSTR bstrUndefines);
	// Automation properties
	STDMETHOD(get_ToolPath)(BSTR *pVal);
	STDMETHOD(get_PropertyOption)(BSTR bstrProp, long dispidProp, BSTR *pVal);
	STDMETHOD(get_FullIncludePath)(BSTR* fullIncludePath);	// include path, including all inherited values, plus platform includes
	STDMETHOD(get_VCProjectEngine)(IDispatch** projEngine)	{ return DoGetVCProjectEngine(projEngine); }

// IVCToolImpl
public:
	STDMETHOD(get_DefaultExtensions)(BSTR* pVal);
	STDMETHOD(put_DefaultExtensions)(BSTR newVal);
	STDMETHOD(GetAdditionalOptionsInternal)(IUnknown* pItem, VARIANT_BOOL bForBuild, VARIANT_BOOL bSkipLocal, BSTR* pbstrAdditionalOptions);
	STDMETHOD(GetBuildDescription)(IVCBuildAction* pAction, BSTR* pbstrBuildDescription);
	STDMETHOD(get_ToolPathInternal)(BSTR* pbstrToolPath);
	STDMETHOD(get_Bucket)(long *pVal);
	STDMETHOD(GenerateOutput)(long type, IVCBuildActionList* plstActions, IVCBuildErrorContext* pEC);
	STDMETHOD(AffectsOutput)(long nPropID, VARIANT_BOOL* pbAffectsOutput);
	STDMETHOD(CreateToolObject)(IVCPropertyContainer* pPropContainer, IVCToolImpl** ppToolObject);
	STDMETHOD(GetAdditionalIncludeDirectoriesInternal)(IVCPropertyContainer* pPropContainer, BSTR* pbstrIncDirs);
	STDMETHOD(get_IncludePathID)(long* pnIncludeID);
	STDMETHOD(get_ToolShortName)(BSTR* pbstrToolName);
	STDMETHOD(get_ToolNameInternal)(BSTR* pbstrToolName) { return get_ToolName(pbstrToolName); }
	STDMETHOD(MatchName)(BSTR bstrName, VARIANT_BOOL bFullOnly, VARIANT_BOOL* pbMatches);
	STDMETHOD(CanScanForDependencies)(VARIANT_BOOL* pbIsScannable);
	STDMETHOD(GenerateDependencies)(IVCBuildAction* pAction, void* frhFile, IVCBuildErrorContext* pErrorContext);
	STDMETHOD(CreatePageObject)(IUnknown **, CLSID*, IVCPropertyContainer *, IVCSettingsPage * );

	STDMETHOD(get_ToolDisplayIndex)(long* pIndex)
	{
		CHECK_POINTER_NULL(pIndex);
		*pIndex = TOOL_DISPLAY_INDEX_MIDL;
		return S_OK;
	}

	virtual long GetPageCount()	{ return 4; }
	virtual GUID* GetPageIDs();

// helpers
public:
	virtual COptionHandlerBase* GetOptionHandler() { return &s_optHandler; }

protected:
	virtual BOOL UsesResponseFiles() { return TRUE; }
	void GenerateTypeLibDep(IVCBuildAction* pAction, IVCPropertyContainer* pPropContainer, IVCBuildErrorContext* pEC, 
		CDirW& dirBase);
	virtual LPCOLESTR GetToolFriendlyName();
	void InitToolName();
	virtual long GetToolID() { return IDS_Midl; }

public:
	static CMidlToolOptionHandler s_optHandler;

protected:
	static GUID s_pPages[4];
	static BOOL s_bPagesInit;
	static CComBSTR s_bstrBuildDescription;
	static CComBSTR s_bstrToolName;
	static CComBSTR s_bstrExtensions;
};

// These macros are used to define enum ranges for tool switches.  If you add an enum property to the tool option
// table, please add a matching macro for it to this list.  Use of macros for range definitions helps in keeping
// maintenance of enum range checks as low as possible.
#define midlWarnMax				4
#define charTypeMax				2
#define envMax					2
#define errCheckMax				2
#define midlStructAlignMax		4
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\vcpb\midltoolbase.h ===
// VCMidlTool.h: Definition of the CVCMidlTool class
//
//////////////////////////////////////////////////////////////////////

#pragma once

#include "vctool.h"
#include "settingspage.h"

template<class T, class IFace>
class ATL_NO_VTABLE CVCMidlBasePage :
	public IDispatchImpl<IFace, &(__uuidof(IFace)), &LIBID_VCProjectEnginePrivateLibrary, PrivateProjBuildTypeLibNumber, 0, CVsTypeInfoHolder>,
	public CPageObjectImpl<T,VCMIDLTOOL_MIN_DISPID,VCMIDLTOOL_MAX_DISPID>,
	public CComObjectRoot
{
public:

BEGIN_COM_MAP(T)
	COM_INTERFACE_ENTRY(IPerPropertyBrowsing)
	COM_INTERFACE_ENTRY(IVsPerPropertyBrowsing)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IVCPropertyContainer)
	COM_INTERFACE_ENTRY(IFace)
	COM_INTERFACE_ENTRY(IProvidePropertyBuilder)
END_COM_MAP()

	// IDispatch override
	STDMETHOD(Invoke)( DISPID dispid, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS *pdispParams, VARIANT *pvarResult, EXCEPINFO *pexcepInfo, UINT *puArgErr )
	{
		IDispatchImpl<IFace, &__uuidof(IFace), &LIBID_VCProjectEnginePrivateLibrary, PrivateProjBuildTypeLibNumber,0, CVsTypeInfoHolder>::Invoke( dispid, riid, lcid, wFlags, pdispParams, pvarResult, pexcepInfo, puArgErr );
		return S_OK;
	}
};

class ATL_NO_VTABLE CVCMidlGeneralPage :
	public CVCMidlBasePage<CVCMidlGeneralPage, IVCMidlGeneralPage>
{
// IVCMidlPage
public:
	// general (/ms_ext, /c_ext left out because they're archaic); @response deliberately left out
	STDMETHOD(get_PreprocessorDefinitions)(BSTR* pbstrDefines);	// (/D![macro]) define macro for MIDL.  can have multiple.
	STDMETHOD(put_PreprocessorDefinitions)(BSTR bstrDefines);
	STDMETHOD(get_AdditionalIncludeDirectories)(BSTR* pbstrIncludePath);	// (/I![path]) directory to add to include path, may have multiple
	STDMETHOD(put_AdditionalIncludeDirectories)(BSTR bstrIncludePath);
	STDMETHOD(get_IgnoreStandardIncludePath)(enumMidlIgnoreStandardIncludePathBOOL* pbIgnore);	// (/no_def_idir) ignore current and INCLUDE path
	STDMETHOD(put_IgnoreStandardIncludePath)(enumMidlIgnoreStandardIncludePathBOOL bIgnore);
	STDMETHOD(get_MkTypLibCompatible)(enumMkTypLibCompatibleBOOL* pbCompatible);	// (/mktyplib203) forces compatibility with mktyplib.exe version 2.03
	STDMETHOD(put_MkTypLibCompatible)(enumMkTypLibCompatibleBOOL bCompatible);
	STDMETHOD(get_WarningLevel)(midlWarningLevelOption* poptSetting);	// see enum above (/W0 - /W4)
	STDMETHOD(put_WarningLevel)(midlWarningLevelOption optSetting);
	STDMETHOD(get_WarnAsError)(enumWarnAsErrorBOOL* pbWarnAsError);	// (/WX) treat warnings as errors
	STDMETHOD(put_WarnAsError)(enumWarnAsErrorBOOL bWarnAsError);
	STDMETHOD(get_SuppressStartupBanner)(enumSuppressStartupBannerBOOL* pbNoLogo);	// (/nologo) enable suppression of copyright message
	STDMETHOD(put_SuppressStartupBanner)(enumSuppressStartupBannerBOOL bNoLogo);
	STDMETHOD(get_DefaultCharType)(midlCharOption* poptSetting);	// see enum above (/char)
	STDMETHOD(put_DefaultCharType)(midlCharOption optSetting);
	STDMETHOD(get_TargetEnvironment)(midlTargetEnvironment* poptSetting);	// (/env win64 vs. /env win32) target Win64 (or Win32) environment
	STDMETHOD(put_TargetEnvironment)(midlTargetEnvironment optSetting);
	STDMETHOD(get_GenerateStublessProxies)(enumGenerateStublessProxiesBOOL* poptSetting);	// (/Oicf)
	STDMETHOD(put_GenerateStublessProxies)(enumGenerateStublessProxiesBOOL optSetting);

// helpers
public:
	virtual void GetBaseDefault(long id, CComVariant& varValue);
	virtual BOOL UseDirectoryPickerDialog(long id) { return (id == VCMIDLID_AdditionalIncludeDirectories); }
};

class ATL_NO_VTABLE CVCMidlOutputPage :
	public CVCMidlBasePage<CVCMidlOutputPage, IVCMidlOutputPage>
{
// IVCMidlOutputPage
public:
	// output file names
	STDMETHOD(get_OutputDirectory)(BSTR* pbstrOut);	// (/out dir) directory to place output files in; default: project directory
	STDMETHOD(put_OutputDirectory)(BSTR bstrOut);
	STDMETHOD(get_HeaderFileName)(BSTR* pbstrHeaderFile);	// (/h[eader] filename) specify name of header file generated; default: <idlfile>.h
	STDMETHOD(put_HeaderFileName)(BSTR bstrHeaderFileName);
	STDMETHOD(get_DLLDataFileName)(BSTR* pbstrDLLData);	// (/dlldata filename) specify name of DLLDATA file generated; default: dlldata.c
	STDMETHOD(put_DLLDataFileName)(BSTR bstrDLLData);
	STDMETHOD(get_InterfaceIdentifierFileName)(BSTR* pbstrIID);	// (/iid filename) specify name of IID file; default: <idlfile>_i.c
	STDMETHOD(put_InterfaceIdentifierFileName)(BSTR bstrIID);
	STDMETHOD(get_ProxyFileName)(BSTR* pbstrProxyFile);	// (/proxy filename) specify name of proxy file; default: <idlfile>_p.c
	STDMETHOD(put_ProxyFileName)(BSTR bstrProxyFile);
	STDMETHOD(get_GenerateTypeLibrary)(enumGenerateTypeLibraryBOOL* poptSetting);	// (/notlb for no) generate a type library or not; default: yes
	STDMETHOD(put_GenerateTypeLibrary)(enumGenerateTypeLibraryBOOL optSetting);
	STDMETHOD(get_TypeLibraryName)(BSTR* pbstrTLBFile);	// (/tlb filename) specify name of TLB file; default: <idlfile>.tlb
	STDMETHOD(put_TypeLibraryName)(BSTR bstrTLBFile);

// helpers
public:
	virtual void GetBaseDefault(long id, CComVariant& varValue);
};

class ATL_NO_VTABLE CVCMidlAdvancedPage :
	public CVCMidlBasePage<CVCMidlAdvancedPage, IVCMidlAdvancedPage>
{
// IVCMidlAdvancedPage
public:
	// advanced (/nocpp ignored as it is not in docs)
	STDMETHOD(get_EnableErrorChecks)(midlErrorCheckOption* poptSetting);	// see enum above (/error {none|all}) 
	STDMETHOD(put_EnableErrorChecks)(midlErrorCheckOption optSetting);
	STDMETHOD(get_ErrorCheckAllocations)(enumErrorCheckAllocationsBOOL* pbErrorCheck);	// (/error allocation) check for out of memory errors
	STDMETHOD(put_ErrorCheckAllocations)(enumErrorCheckAllocationsBOOL bErrorCheck);
	STDMETHOD(get_ErrorCheckBounds)(enumErrorCheckBoundsBOOL* pbErrorCheck);	// (/error bounds_check) check size	vs. transmission length specifications
	STDMETHOD(put_ErrorCheckBounds)(enumErrorCheckBoundsBOOL bErrorCheck);
	STDMETHOD(get_ErrorCheckEnumRange)(enumErrorCheckEnumRangeBOOL* pbErrorCheck);	// (/error enum) check enum values to be in allowable range; not in docs
	STDMETHOD(put_ErrorCheckEnumRange)(enumErrorCheckEnumRangeBOOL bErrorCheck);
	STDMETHOD(get_ErrorCheckRefPointers)(enumErrorCheckRefPointersBOOL* pbErrorCheck);	// (/error ref) check ref pointers to be non-NULL
	STDMETHOD(put_ErrorCheckRefPointers)(enumErrorCheckRefPointersBOOL bErrorCheck);
	STDMETHOD(get_ErrorCheckStubData)(enumErrorCheckStubDataBOOL* pbErrorCheck);	// (/error stub_data) emit additional check for server side data stub validity
	STDMETHOD(put_ErrorCheckStubData)(enumErrorCheckStubDataBOOL bErrorCheck);
	STDMETHOD(get_ValidateParameters)(enumValidateParametersBOOL* pbValidate);	// (/robust) generate additional information to validate parameters; not in docs
	STDMETHOD(put_ValidateParameters)(enumValidateParametersBOOL bValidate);
	STDMETHOD(get_StructMemberAlignment)(midlStructMemberAlignOption* poptSetting);	// see enum above (/Zp[num])
	STDMETHOD(put_StructMemberAlignment)(midlStructMemberAlignOption optSetting);
	STDMETHOD(get_RedirectOutputAndErrors)(BSTR* pbstrOutput);	// (/o file) redirect output from screen to a file
	STDMETHOD(put_RedirectOutputAndErrors)(BSTR bstrOutput);
	STDMETHOD(get_CPreprocessOptions)(BSTR* pbstrOpt);	// (/cpp_opt"[option]") C-compiler preprocessor option to pass to MIDL.  must be in exact format for desired switches
	STDMETHOD(put_CPreprocessOptions)(BSTR bstrOpt);
	STDMETHOD(get_UndefinePreprocessorDefinitions)(BSTR* pbstrUndefines);	// (/U![macro]) remove any previous definition of symbol.  can have multiple.
	STDMETHOD(put_UndefinePreprocessorDefinitions)(BSTR bstrUndefines);
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\vcpb\mrdependencies.cpp ===
//
// Implement minimal rebuild dependencies interface.
//
// [tomse]
//

#include "stdafx.h"		// our standard AFX include
#pragma hdrstop
#include "mrdependencies.h"	// our local header file

#include <winver.h>

#ifdef UNICODE
#undef _TCHAR
#define  _TCHAR char
#endif
#include <mrengine.h>


#include <utf.h>
#include "scanner.h"

CTestableSection g_sectionMreMap;

class BldEnumDepContext
{
public:
	BldEnumDepContext() : m_pstrList(NULL), m_bRemovePchIncludes(FALSE), m_bSourceFound(FALSE) {}
	CVCBuildStringCollection* m_pstrList;
	BOOL m_bRemovePchIncludes;
	BOOL m_bSourceFound;
};

BOOL MRECALL FEnumDepFile(PMREUtil pmre, EnumFile& ef, EnumType et)
{
	VSASSERT(etDep == et, "Trying to determine dependencies with bad et value");
	VSASSERT(NULL != ef.pvContext, "No context to determine dependency info for");
	BldEnumDepContext& context = *(BldEnumDepContext*)ef.pvContext;
	VSASSERT(NULL != context.m_pstrList, "No list to return dependency info in");

	// Don't add files that are included by precompiled header.
	if (context.m_bRemovePchIncludes && (ef.fiSrc.dwStatus & fsmInclByPch))
		return TRUE;

	// Check for the slight possibility that ef.szFileSrc was not updated.
	if (NULL != ef.szFileSrc && ef.szFileSrc[0] != 0)
	{
		// Filter out system headers and write into list.
		CStringW str;
		PWSTR pStr = str.GetBuffer(_MAX_PATH);
		UTF8ToUnicode(ef.szFileSrc, NULL_TERMINATED_MODE, pStr, _MAX_PATH);
		str.ReleaseBuffer();
		if (str.IsEmpty())
			return TRUE;
		if (!g_SysInclReg.IsSysInclude(str, FALSE))
			context.m_pstrList->m_strStrings.Add(str);
	}

	return TRUE;
}

BOOL MRECALL FEnumDepFileForDeployment(PMREUtil pmre, EnumFile& ef, EnumType et)
{
	VSASSERT(etDep == et, "Trying to determine dependencies with bad et value");
	VSASSERT(NULL != ef.pvContext, "No context to determine dependency info for");
	BldEnumDepContext& context = *(BldEnumDepContext*)ef.pvContext;
	VSASSERT(NULL != context.m_pstrList, "No list to return dependency info in");

	if ((IncludeType)(ef.fiSrc.ftInclude) == itText)
		return TRUE;

	// Check for the slight possibility that ef.szFileSrc was not updated.
	if (NULL != ef.szFileSrc && ef.szFileSrc[0] != 0)
	{
		// Filter out system-provided stuff and write into list.
		CStringW str;
		PWSTR pStr = str.GetBuffer(_MAX_PATH);
		UTF8ToUnicode(ef.szFileSrc, NULL_TERMINATED_MODE, pStr, _MAX_PATH);
		str.ReleaseBuffer();
		if (str.IsEmpty())
			return TRUE;
		if (!g_SysInclReg.IsSysInclude(str, FALSE))
			context.m_pstrList->m_strStrings.Add(str);
	}

	return TRUE;
}

BOOL MRECALL FEnumSrcFile(PMREUtil pmre, EnumFile& ef, EnumType et)
{
	VSASSERT(NULL != ef.pvContext, "No context to determine dependency info for");
	BldEnumDepContext& context = *(BldEnumDepContext*)ef.pvContext;
	context.m_bSourceFound = TRUE;

	VSASSERT(etSource == et, "Invalid et value");
	pmre->EnumDepFiles(ef, FEnumDepFile);
	return TRUE;
}

BOOL MRECALL FEnumSrcFileForDeployment(PMREUtil pmre, EnumFile& ef, EnumType et)
{
	VSASSERT(NULL != ef.pvContext, "No context to determine dependency info for");
	BldEnumDepContext& context = *(BldEnumDepContext*)ef.pvContext;
	context.m_bSourceFound = TRUE;

	VSASSERT(etSource == et, "Invalid et value");
	pmre->EnumDepFiles(ef, FEnumDepFileForDeployment);
	return TRUE;
}

typedef BOOL (MRECALL *FOpen_fnptr)(OUT PMREngine *ppmre, SZC szPdb, EC& ec, char szErr[], BOOL fReproSig, BOOL fWrite);

class CBldMreDependencies : public IBldMreDependencies
{
public:
	friend IBldMreDependencies* IBldMreDependencies::GetMreDependenciesIFace(LPCOLESTR bstrIdbFile);
	friend void CBldMreDependenciesContainer::UnloadMSPDB();
	virtual BOOL GetDependencies(LPCOLESTR szPath, CVCBuildStringCollection* pCollection, BOOL bUsePch);
	virtual BOOL GetDeploymentDependencies(LPCOLESTR szPath, CVCBuildStringCollection* pCollection);
	virtual BOOL Release();

private:
	CBldMreDependencies() : m_pMre(NULL), m_pMreUtil(NULL), m_cRef(0) {}
	unsigned m_cRef;
	PMREngine m_pMre;
	PMREUtil m_pMreUtil;
	static LPCOLESTR m_szMspdbDll;
	static HINSTANCE s_hInstPdbDll;
	static FOpen_fnptr s_FOpen;

#if defined(_DEBUG)
public:
#endif
	// public for debug builds.
	static CVCMapStringWToPtr s_OpenMreMap;
};

#if defined(_DEBUG)
// Make sure that CBldMreDependencies::s_OpenMreMap is empty when program is finished.
class BldCleanupMreDependencies
{
public:
	~BldCleanupMreDependencies()
	{
		VSASSERT(CBldMreDependencies::s_OpenMreMap.IsEmpty(), "Failed to clean up MreDependencies before destruction");
	}
};

BldCleanupMreDependencies tmpCleanup;
#endif

CVCMapStringWToPtr CBldMreDependencies::s_OpenMreMap;
LPCOLESTR CBldMreDependencies::m_szMspdbDll = L"mspdb70.dll";
HINSTANCE CBldMreDependencies::s_hInstPdbDll = NULL;
FOpen_fnptr CBldMreDependencies::s_FOpen = NULL;

IBldMreDependencies* IBldMreDependencies::GetMreDependenciesIFace(LPCOLESTR bstrIdbFile)
{
	CBldMreDependencies* pMreDepend = NULL;
	CStringW strKey = bstrIdbFile;
	strKey.MakeLower();

	CritSectionT cs(g_sectionMreMap);
	// Check map of open Mre files first.
	if (CBldMreDependencies::s_OpenMreMap.Lookup(strKey, (void*&)pMreDepend))
	{
		VSASSERT(NULL!=pMreDepend, "Bad MreMap key/pointer pair");
		VSASSERT(NULL!=pMreDepend->m_pMre, "Bad PMREngine pointer in MreDepend");
		VSASSERT(NULL!=pMreDepend->m_pMreUtil, "Bad PMREUtil pointer in MreDepend");
		VSASSERT(0<pMreDepend->m_cRef, "Bad refcount on MreDepend");
		pMreDepend->m_cRef++;
	}
	else
	{
		pMreDepend = new CBldMreDependencies;
		PMREngine pMre;
		PMREUtil pMreUtil;
		EC ec;

		if (NULL != pMreDepend)
		{
			if (CBldMreDependencies::s_OpenMreMap.IsEmpty())
			{
				if (CBldMreDependencies::s_hInstPdbDll == NULL || CBldMreDependencies::s_FOpen == NULL)
				{
					if (CBldMreDependencies::s_hInstPdbDll == NULL)
					{
						CBldMreDependencies::s_hInstPdbDll = LoadLibraryW(CBldMreDependencies::m_szMspdbDll);
						VSASSERT(NULL != CBldMreDependencies::s_hInstPdbDll, "Failed to load PDB DLL");
						if (NULL == CBldMreDependencies::s_hInstPdbDll)
							return FALSE;
					}

					VSASSERT(NULL==CBldMreDependencies::s_FOpen, "MREngine already open!");
					CBldMreDependencies::s_FOpen = (FOpen_fnptr)GetProcAddress(
						CBldMreDependencies::s_hInstPdbDll,
#if defined (_M_ALPHA)
						"?FOpen@MREngine@@SAHPAPAU1@PBDAAJQADHH@Z");
#else
#if defined (_WIN64)
						"?FOpen@MREngine@@SAHPEAPEAU1@PEBDAEAJQEADHH@Z");
#else
						"?FOpen@MREngine@@SGHPAPAU1@PBDAAJQADHH@Z");
#endif	// _WIN64
#endif	// _M_ALPHA

					VSASSERT(NULL != CBldMreDependencies::s_FOpen, "Failed to open MREngine");

					if (NULL == CBldMreDependencies::s_FOpen)
					{
						BOOL bOK = FreeLibrary(CBldMreDependencies::s_hInstPdbDll);
						VSASSERT(bOK, "Failed to free CBldMreDependencies::s_hInstPdbDll library!");
						CBldMreDependencies::s_hInstPdbDll = NULL;
						return NULL;
					}
				}
			}

			VSASSERT(NULL != CBldMreDependencies::s_hInstPdbDll, "Failed to load PDB DLL");
			VSASSERT(NULL != CBldMreDependencies::s_FOpen, "Failed to open MREngine");

			// n.b. Don't try to open .idb file unless it already exists
			char szErr[cbErrMax];
			szErr[0] = 0;
			CStringA strIdbFileA = bstrIdbFile;	// yes, ANSI -- 'cause CBldMreDependencies needs it this way
			if  ((_access(strIdbFileA, 0) != -1) && 
				((*CBldMreDependencies::s_FOpen)(&pMre, strIdbFileA, ec, szErr, FALSE, FALSE) && pMre))
			{
				pMre->QueryMreUtil(pMreUtil);
				VSASSERT(NULL!=pMreUtil, "Bad PMREUtil pointer for .idb file");
				pMreDepend->m_cRef = 1;
				pMreDepend->m_pMre = pMre;
				pMreDepend->m_pMreUtil = pMreUtil;
				CBldMreDependencies::s_OpenMreMap[strKey] = pMreDepend;
			}
			else
			{
				delete pMreDepend;
				pMreDepend = NULL;
			}
		}
	}

	return pMreDepend;
}

void CBldMreDependenciesContainer::UnloadMSPDB()
{
	if (CBldMreDependencies::s_hInstPdbDll == NULL)
		return;		// nothing to do

	BOOL bOK = FreeLibrary(CBldMreDependencies::s_hInstPdbDll);
	VSASSERT(bOK, "Failed to free CBldMreDependencies::s_hInstPdbDll library!");
	CBldMreDependencies::s_hInstPdbDll = NULL;
	CBldMreDependencies::s_FOpen = NULL;
}

BOOL CBldMreDependencies::GetDependencies(LPCOLESTR szPath, CVCBuildStringCollection* pCollection, BOOL bUsePch)
{
	BldEnumDepContext context;
	context.m_bRemovePchIncludes = bUsePch;

	VSASSERT(NULL != m_pMre, "Invalid MreDependencies object.  Bad initialization.");
	VSASSERT(NULL != m_pMreUtil, "Invalid MreDependencies object.  Bad initialization.");

	pCollection->Clear();
	context.m_pstrList = pCollection;

	USES_CONVERSION;
	m_pMreUtil->EnumSrcFiles(FEnumSrcFile, W2A(szPath), &context);	// yes, ANSI

	return context.m_bSourceFound;
}

BOOL CBldMreDependencies::GetDeploymentDependencies(LPCOLESTR szPath, CVCBuildStringCollection* pCollection)
{
	BldEnumDepContext context;
	context.m_bRemovePchIncludes = FALSE;

	VSASSERT(NULL != m_pMre, "Invalid MreDependencies object.  Bad initialization.");
	VSASSERT(NULL != m_pMreUtil, "Invalid MreDependencies object.  Bad initialization.");

	pCollection->Clear();
	context.m_pstrList = pCollection;

	USES_CONVERSION;
	m_pMreUtil->EnumSrcFiles(FEnumSrcFileForDeployment, W2A(szPath), &context);  // yes, ANSI

	return context.m_bSourceFound;
}

BOOL CBldMreDependencies::Release()
{
	BOOL bOk = 0 < m_cRef;

	VSASSERT(NULL != m_pMre, "Invalid MreDependencies object.  Bad initialization.");
	VSASSERT(NULL != m_pMreUtil, "Invalid MreDependencies object.  Bad initialization.");

	m_cRef--;
	if (0 == m_cRef)
	{
		bOk = NULL != m_pMreUtil && m_pMreUtil->FRelease() && bOk;
		bOk = NULL != m_pMre && m_pMre->FClose(FALSE) && bOk;

		// Remove from map
		CritSectionT cs(g_sectionMreMap);
		VCPOSITION pos = s_OpenMreMap.GetStartPosition();
		VSASSERT(pos != NULL, "Ref count on MreMap says we have something; but we didn't find anything there");
		while (NULL != pos)
		{
			CStringW strFilename;
			CBldMreDependencies* pMreDepend;
			s_OpenMreMap.GetNextAssoc(pos, strFilename, (void*&)pMreDepend);
			VSASSERT(NULL != pMreDepend, "Bad file name/MreDependencies pointer pair");
			if (this == pMreDepend)
			{
				s_OpenMreMap.RemoveKey(strFilename);
				break;
			}
		}
		delete this;
	}

	return bOk;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\vcpb\midltoolbase.cpp ===
// MidlBaseTool.cpp : Implementation of MIDL Tool

#include "stdafx.h"
#include "MidlTool.h"
#include "BuildEngine.h"
#include "scanner.h"

// constants
const wchar_t* const wszMidlDefaultExtensions = L"*.idl;*.odl";	// remember to update vcpb.rgs if you change this...
const wchar_t* const wszMidlDefaultHeader = L"$(InputName)_h.h";
const wchar_t* const wszMidlDefaultTLBFile = L"$(IntDir)/$(ProjectName).tlb";
const wchar_t* const wszMidlDLLDataFileName = L"dlldata.c";
const midlWarningLevelOption lmidlWarnLevel = midlWarningLevel_1;
const midlCharOption lDefaultCharType = midlCharUnsigned;
const midlTargetEnvironment lTargetEnvironment = midlTargetWin32;
const midlErrorCheckOption lEnableErrorChecks = midlEnableCustom;
const midlStructMemberAlignOption lStructMemberAlignment = midlAlignNotSet;

// static initializers
CMidlToolOptionHandler CVCMidlTool::s_optHandler;
GUID CVCMidlTool::s_pPages[4];
BOOL CVCMidlTool::s_bPagesInit = FALSE;
CComBSTR CVCMidlTool::s_bstrBuildDescription = L"";
CComBSTR CVCMidlTool::s_bstrToolName = L"";
CComBSTR CVCMidlTool::s_bstrExtensions = L"";

////////////////////////////////////////////////////////////////////////////////
// Option Table for MIDL switches

// NOTE: we're using macros for enum value ranges to help in keeping enum range checks as low maintenance as possible.
// If you add an enum to this table, make sure you use macros to define the upper and lower bounds and use CHECK_BOUNDS
// on the get/put methods associated with that property (both object model and property page).
// WARNING: if you change ANYTHING about a multi-prop here (including add/remove), be sure to update how the property
// is obtained on both the tool and page objects.
BEGIN_OPTION_TABLE(CMidlToolOptionHandler, L"VCMidlTool", IDS_Midl, TRUE /* pre & post */, TRUE /* case sensitive */)
	// general
	OPT_BSTR(PreprocessorDefinitions,	L"D %s",						L"PreprocessorDefinitions",		multiple,	IDS_MidlGeneral, VCMIDLID)
	OPT_BSTR(AdditionalIncludeDirectories, L"I %s",						L"AdditionalIncludeDirectories", multipleNoCase,	IDS_MidlGeneral, VCMIDLID)
	OPT_BOOL(IgnoreStandardIncludePath,	L"|no_def_idir",				L"IgnoreStandardIncludePath",	IDS_MidlGeneral, VCMIDLID)
	OPT_BOOL(MkTypLibCompatible,		L"|mktyplib203",				L"MkTypLibCompatible",			IDS_MidlGeneral, VCMIDLID)
	OPT_ENUM(WarningLevel,				L"W0|W1|W2|W3|W4",		StdEnumMin, midlWarnMax,	L"WarningLevel", IDS_MidlGeneral, VCMIDLID)
	OPT_BOOL(WarnAsError,				L"|WX",							L"WarnAsError",					IDS_MidlGeneral, VCMIDLID)
	OPT_BOOL(SuppressStartupBanner,		L"|nologo",						L"SuppressStartupBanner",		IDS_MidlGeneral, VCMIDLID)
	OPT_ENUM(DefaultCharType, L"char unsigned|char signed|char ascii7", StdEnumMin, charTypeMax, L"DefaultCharType", IDS_MidlGeneral, VCMIDLID)
	OPT_ENUM(TargetEnvironment,			L"|env win32|env win64",	 StdEnumMin, envMax,	L"TargetEnvironment", IDS_MidlGeneral, VCMIDLID)
	OPT_BOOL(GenerateStublessProxies,	L"|Oicf",						L"GenerateStublessProxies",		IDS_MidlGeneral, VCMIDLID)
	// output 
	OPT_BOOL_SET_COND(GenerateTypeLibrary, L"notlb|", /* newtlb */,		L"GenerateTypeLibrary", TypeLibraryName, IDS_MidlOutput, VCMIDLID)
	OPT_BSTR_COND(TypeLibraryName,		L" /tlb %s",					L"TypeLibraryName",	GenerateTypeLibrary, single, IDS_MidlOutput, VCMIDLID)
	OPT_BSTR(OutputDirectory,			L"out %s",						L"OutputDirectory",	single,		IDS_MidlOutput, VCMIDLID)
	OPT_BSTR(HeaderFileName,			L"h %s",						L"HeaderFileName",	single,		IDS_MidlOutput, VCMIDLID)
	OPT_BSTR(DLLDataFileName,			L"dlldata %s",					L"DLLDataFileName",	single,		IDS_MidlOutput, VCMIDLID)
	OPT_BSTR(InterfaceIdentifierFileName, L"iid %s",					L"InterfaceIdentifierFileName", single, IDS_MidlOutput, VCMIDLID)
	OPT_BSTR(ProxyFileName,				L"proxy %s",					L"ProxyFileName",	single,		IDS_MidlOutput, VCMIDLID)
	// advanced
	OPT_ENUM(EnableErrorChecks,			L"|error none|error all", StdEnumMin, errCheckMax, L"EnableErrorChecks", IDS_MidlAdvanced, VCMIDLID)
	OPT_BOOL(ErrorCheckAllocations,		L"|error allocation",			L"ErrorCheckAllocations",		IDS_MidlAdvanced, VCMIDLID)
	OPT_BOOL(ErrorCheckBounds,			L"|error bounds_check",			L"ErrorCheckBounds",			IDS_MidlAdvanced, VCMIDLID)
	OPT_BOOL(ErrorCheckEnumRange,		L"|error enum",					L"ErrorCheckEnumRange",			IDS_MidlAdvanced, VCMIDLID)
	OPT_BOOL(ErrorCheckRefPointers,		L"|error ref",					L"ErrorCheckRefPointers",		IDS_MidlAdvanced, VCMIDLID)
	OPT_BOOL(ErrorCheckStubData,		L"|error stub_data",			L"ErrorCheckStubData",			IDS_MidlAdvanced, VCMIDLID)
	OPT_BOOL(ValidateParameters,		L"|robust",						L"ValidateParameters",			IDS_MidlAdvanced, VCMIDLID)
	OPT_ENUM(StructMemberAlignment,		L"|Zp1|Zp2|Zp4|Zp8",		StdEnumMin, midlStructAlignMax,	L"StructMemberAlignment", IDS_MidlAdvanced, VCMIDLID)
	OPT_BSTR(RedirectOutputAndErrors,	L"o %s",						L"RedirectOutputAndErrors", single, IDS_MidlAdvanced, VCMIDLID)
	OPT_BSTR(CPreprocessOptions,		L"cpp_opt%s",					L"CPreprocessOptions",		multiple,	IDS_MidlAdvanced, VCMIDLID)
	OPT_BSTR(UndefinePreprocessorDefinitions, L"U %s",					L"UndefinePreprocessorDefinitions",		multiple,	IDS_MidlAdvanced, VCMIDLID)
END_OPTION_TABLE()

// default value handlers
// string props
void CMidlToolOptionHandler::GetDefaultValue( long id, BSTR *pVal, IVCPropertyContainer *pPropCnt )
{
	switch( id )
	{
	case VCMIDLID_HeaderFileName:
		*pVal = SysAllocString( wszMidlDefaultHeader );
		break;
	case VCMIDLID_TypeLibraryName:
		*pVal = SysAllocString( wszMidlDefaultTLBFile );
		break;
	case VCMIDLID_DLLDataFileName:
		*pVal = SysAllocString( wszMidlDLLDataFileName );
		break;
// 	case VCMIDLID_AdditionalOptions:
// 	case VCMIDLID_PreprocessorDefinitions:
// 	case VCMIDLID_AdditionalIncludeDirectories:
// 	case VCMIDLID_OutputDirectory:
// 	case VCMIDLID_InterfaceIdentifierFileName:
// 	case VCMIDLID_ProxyFileName:
// 	case VCMIDLID_RedirectOutputAndErrors:
// 	case VCMIDLID_CPreprocessOptions:
// 	case VCMIDLID_UndefinePreprocessorDefinitions:
	default:
 		GetDefaultString( pVal );
		break;
	}
}

// integer props
void CMidlToolOptionHandler::GetDefaultValue( long id, long *pVal, IVCPropertyContainer *pPropCnt )
{
	switch( id )
	{
	case VCMIDLID_WarningLevel:
		*pVal = lmidlWarnLevel;
		break;
	case VCMIDLID_DefaultCharType:
		*pVal = lDefaultCharType;
		break;
	case VCMIDLID_TargetEnvironment:
		*pVal = lTargetEnvironment;
		break;
	case VCMIDLID_EnableErrorChecks:
		*pVal = lEnableErrorChecks;
		break;
	case VCMIDLID_StructMemberAlignment:
		*pVal = lStructMemberAlignment;
		break;
	default:
		*pVal = 0;
		break;
	}
}

// boolean props
void CMidlToolOptionHandler::GetDefaultValue( long id, VARIANT_BOOL *pVal, IVCPropertyContainer *pPropCnt )
{
	switch( id )
	{
	case VCMIDLID_SuppressStartupBanner:
	case VCMIDLID_GenerateTypeLibrary:
		GetValueTrue( pVal );
		break;
// 	case VCMIDLID_IgnoreStandardIncludePath:
// 	case VCMIDLID_MkTypLibCompatible:
// 	case VCMIDLID_WarnAsError:
//	case VCMIDLID_GenerateStublessProxies:
// 	case VCMIDLID_ErrorCheckAllocations:
// 	case VCMIDLID_ErrorCheckBounds:
// 	case VCMIDLID_ErrorCheckEnumRange:
// 	case VCMIDLID_ErrorCheckRefPointers:
// 	case VCMIDLID_ErrorCheckStubData:
// 	case VCMIDLID_ValidateParameters:
	default:
 		GetValueFalse( pVal );
		break;
	}
}


BOOL CMidlToolOptionHandler::SetEvenIfDefault(VARIANT *pvarDefault, long idOption)
{
	CComVariant varDefault;
	BOOL bRet = FALSE;

	switch (idOption)
	{
	case VCMIDLID_SuppressStartupBanner:
	case VCMIDLID_GenerateTypeLibrary:
		varDefault.vt = VT_BOOL;
		varDefault = VARIANT_TRUE;
		bRet = TRUE;
		break;
	case VCMIDLID_TargetEnvironment:
		varDefault = lTargetEnvironment;
		bRet = TRUE;
		break;
	}
	varDefault.Detach(pvarDefault);
	return bRet;
}

BOOL CMidlToolOptionHandler::SynthesizeOptionIfNeeded(IVCPropertyContainer* pPropContainer, long idOption)
{
	switch (idOption)
	{
	case VCMIDLID_TypeLibraryName:
		return CreatesTypeLib(pPropContainer);
	case VCMIDLID_HeaderFileName:
		return TRUE;
	default:
		return FALSE;
	}
}

BOOL CMidlToolOptionHandler::SynthesizeOption(IVCPropertyContainer* pPropContainer, long idOption, CComVariant& rvar)
{
	switch (idOption)
	{
	case VCMIDLID_TypeLibraryName:
		{
			CComBSTR bstrTlb;
			GetDefaultValue( idOption, &bstrTlb );
			rvar = bstrTlb;
			return TRUE;
		}
	case VCMIDLID_HeaderFileName:
		{
			CComBSTR bstrHeader;
			GetDefaultValue( idOption, &bstrHeader );
			rvar = bstrHeader;
			return TRUE;
		}
	default:
		VSASSERT(FALSE, "Mismatch between SynthesizeOptionIfNeeded and SynthesizeOption for MIDL tool");
		return FALSE;
	}
}

BOOL CMidlToolOptionHandler::CreatesTypeLib(IVCPropertyContainer* pPropContainer)
{
	VARIANT_BOOL bGen = VARIANT_TRUE;
	HRESULT hr = pPropContainer->GetBoolProperty(VCMIDLID_GenerateTypeLibrary, &bGen);
	if (hr != S_OK)
		bGen = VARIANT_TRUE;
	return (bGen == VARIANT_TRUE);
}

///////////////////////////////////////////////////////////////////////////////
// Midl Tool
HRESULT CVCMidlTool::CreateInstance(IVCPropertyContainer* pPropContainer, IVCToolImpl** ppMidlTool)
{
	CHECK_POINTER_NULL(ppMidlTool);
	*ppMidlTool = NULL;

	CComObject<CVCMidlTool> *pObj;
	HRESULT hr = CComObject<CVCMidlTool>::CreateInstance(&pObj);
	if (SUCCEEDED(hr))
	{
		if( pPropContainer )
			pObj->Initialize(pPropContainer);
		CVCMidlTool *pVar = pObj;
		pVar->AddRef();
		*ppMidlTool = pVar;
	}
	return hr;
}

LPCOLESTR CVCMidlTool::GetToolFriendlyName()
{
	InitToolName();
	return s_bstrToolName;
}

void CVCMidlTool::InitToolName()
{
	if (s_bstrToolName.Length() == 0)
	{
		if (!s_bstrToolName.LoadString(IDS_MIDL_TOOLNAME))
			s_bstrToolName = szMidlToolType;
	}
}

STDMETHODIMP CVCMidlTool::GenerateOutput(long type, IVCBuildActionList* plstActions, IVCBuildErrorContext* pEC)
{
	RETURN_ON_NULL2(plstActions, S_OK);

	BOOL bFirst = TRUE;
	CComBSTR bstrProjectDirectory;

	plstActions->Reset(NULL);
	while (TRUE)
	{
		CComPtr<IVCBuildAction> spAction;
		HRESULT hr = plstActions->Next(&spAction, NULL);
		BREAK_ON_DONE(hr);

		CComPtr<IVCBuildableItem> spItem;
		spAction->get_Item(&spItem);
		VSASSERT(spItem != NULL, "Action created without an item.  Bad initialization.");
		CComQIPtr<IVCPropertyContainer> spPropContainer = spItem;
		VSASSERT(spPropContainer != NULL, "Action's item is not a property container.  Bad initialization.");
		RETURN_INVALID_ON_NULL(spPropContainer);

		if (IsExcludedFromBuild(spPropContainer))
			continue;	// nothing to do for things excluded from build...

		if (bFirst)
		{
			bFirst = FALSE;
			spPropContainer->GetStrProperty(VCPROJID_ProjectDirectory, &bstrProjectDirectory);	// default if not specified; should never have macros in it
		}

		CStringW strDirName;
		CDirW dirOutput;

		CComBSTR bstrDirName;
		CDirW dirBase;
		CreateDirFromBSTR(bstrProjectDirectory, dirBase);
		if (spPropContainer->GetEvaluatedStrProperty(VCMIDLID_OutputDirectory, &bstrDirName) == S_OK)
		{
			strDirName = bstrDirName;
			if (!strDirName.IsEmpty())
			{
				int i = strDirName.GetLength();
				const wchar_t* pszTmp = _wcsdec((const wchar_t*)strDirName, (const wchar_t*)(strDirName)+i);
				// add trailing slash if necessary
				if (*pszTmp != L'\\' && *pszTmp != L'/')
					strDirName += L'\\';

				strDirName += L'a';
				CPathW tmpPath;
				if (tmpPath.CreateFromDirAndFilename(dirBase, strDirName))
				{
					tmpPath.GetActualCase(TRUE);
					if (dirOutput.CreateFromPath(tmpPath))
					{
						dirBase = dirOutput;
						bstrProjectDirectory.Empty();
						strDirName = dirBase;
						bstrProjectDirectory = strDirName;
					}
				}
			}
		}

		CComPtr<VCFileConfiguration> spFileCfg;
		if (spAction->get_FileConfiguration(&spFileCfg) != S_OK || spFileCfg == NULL)
		{
			CComPtr<VCConfiguration> spProjCfg;
			HRESULT hrT = spAction->get_ProjectConfiguration(&spProjCfg);
			RETURN_ON_FAIL(hrT);
			CHECK_ZOMBIE(spProjCfg, IDS_ERR_TOOL_ZOMBIE);

		 	// assemble all the .tlb files from the configuration
			CComPtr<IEnumVARIANT> spFiles;
			HRESULT hr = CBldAction::GetFileCollection(spProjCfg, &spFiles);
			RETURN_ON_FAIL_OR_NULL(hr, spFiles);

			while (TRUE)
			{
				CComVariant var;
				hr = spFiles->Next(1, &var, NULL);
				BREAK_ON_DONE(hr);
				CComPtr<VCFileConfiguration> spFileCfg;
				if (!CBldAction::GetFileCfgForProjCfg(var, spProjCfg, &spFileCfg))
					continue;
				CComQIPtr<IVCBuildableItem> spBuildableFileCfg = spFileCfg;
				if (spBuildableFileCfg == NULL)
				{
					VSASSERT(FALSE, "File configs must support IVCBuildableItem interface.");
					continue;
				}
				CComPtr<IVCBuildActionList> spFileActions;
				if (FAILED(spBuildableFileCfg->get_ActionList(&spFileActions)))
					continue;
				spFileActions->Reset(NULL);

				while (TRUE)
				{
					CComPtr<IVCBuildAction> spFileAction;
					HRESULT hr2 = spFileActions->Next(&spFileAction, NULL);
					BREAK_ON_DONE(hr2);
					BOOL fFound = FALSE;
					spFileAction->MatchesOldTool(this, &fFound);
					if (fFound)
						GenerateTypeLibDep(spAction, spPropContainer, pEC, dirBase);
				}
			}
		}
		else
		{
			GenerateTypeLibDep(spAction, spPropContainer, pEC, dirBase);

			// now we want to check if "/h filename" is in the option table or not, if it is
			// then we need to add it to the outputs list as well. 
			CComBSTR bstrHdr;
			if (spPropContainer->GetEvaluatedStrProperty(VCMIDLID_HeaderFileName, &bstrHdr) == S_FALSE)
			{	// pick up the default instead, then
				s_optHandler.GetDefaultValue( VCMIDLID_HeaderFileName, &bstrHdr );
				spPropContainer->Evaluate(bstrHdr, &bstrHdr);
			}
			CStringW strHdr = bstrHdr;
			strHdr.TrimLeft();
			if (!strHdr.IsEmpty())
			{
				// ignore failures to add an output (due to invalid value
				// provided by the user) and continue on
				spAction->AddOutputFromFileName(bstrHdr, pEC, L".h", (wchar_t *)(const wchar_t *)dirBase, VARIANT_TRUE,
					VCMIDLID_HeaderFileName, this);
			}

			// now we want to check if "/iid filename" is in the option table or not, if it is
			// then we need to add it to the outputs as well. 
			CComBSTR bstrIid;
			if (spPropContainer->GetEvaluatedStrProperty(VCMIDLID_InterfaceIdentifierFileName, &bstrIid) == S_OK)
			{
				CStringW strIid = bstrIid;
				if (!strIid.IsEmpty())
				{
					// ignore failures to add an output (due to invalid value
					// provided by the user) and continue on
					spAction->AddOutputFromFileName(bstrIid, pEC, L".c", (wchar_t *)(const wchar_t *)dirBase, VARIANT_TRUE,
						VCMIDLID_InterfaceIdentifierFileName, this);
				}
			}

			ConfigurationTypes configType = typeUnknown;
			spPropContainer->GetIntProperty(VCCFGID_ConfigurationType, (long *)&configType);
			BOOL fDll = (configType == typeDynamicLibrary);
			if (fDll)
			{
				CComBSTR bstrDllDataFile;
				CStringW strDllDataFile;
				if (spPropContainer->GetEvaluatedStrProperty(VCMIDLID_DLLDataFileName, &bstrDllDataFile) == S_OK)
				{
					strDllDataFile = bstrDllDataFile;
					if (strDllDataFile.IsEmpty())
						strDllDataFile = L"dlldata.c";
				}
				else
					strDllDataFile = L"dlldata.c";
				CPathW path1;
				path1.CreateFromDirAndFilename(dirBase, strDllDataFile);
				path1.GetActualCase(TRUE);
				spAction->AddOutputFromPath((wchar_t *)(const wchar_t *)path1, pEC, VARIANT_FALSE, VARIANT_TRUE, 
					VCMIDLID_DLLDataFileName, this);
			}

			BOOL bGenDefaultStubName = TRUE;
			CComBSTR bstrProxyStub;
			if (spPropContainer->GetStrProperty(VCMIDLID_ProxyFileName, &bstrProxyStub) == S_OK && bstrProxyStub.Length() > 0)
			{
				if (SUCCEEDED(spPropContainer->Evaluate(bstrProxyStub, &bstrProxyStub)))
				{
					CPathW pathStub;
					if (pathStub.CreateFromDirAndFilename(dirBase, bstrProxyStub))
					{
						bGenDefaultStubName = FALSE;
						pathStub.GetActualCase(TRUE);
						spAction->AddOutputFromPath((wchar_t *)(const wchar_t *)pathStub, pEC, VARIANT_FALSE, VARIANT_TRUE,
							VCMIDLID_ProxyFileName, this);
					}
				}
			}
			if (fDll && bGenDefaultStubName)
			{
				CComQIPtr<IVCPropertyContainer> spFileCfgPropContainer = spFileCfg;
				CComBSTR bstrFileName;
				if (spFileCfgPropContainer != NULL)
				{
					spFileCfgPropContainer->GetEvaluatedStrProperty(VCFILEID_Name, &bstrFileName);
				}
				CStringW strFileName = bstrFileName;
				if (!strFileName.IsEmpty())
				{
					CPathW path2;
					path2.CreateFromDirAndFilename(dirBase, strFileName);
					CStringW strFile = path2.GetFileName();
					CStringW strExt;
					int nExt = strFile.ReverseFind(L'.');
					if (nExt >= 0)
						strFile = strFile.Left(nExt);
					strFile += L"_p.c";
					path2.ChangeFileName(strFile);
					path2.GetActualCase(TRUE);
					spAction->AddOutputFromPath((wchar_t *)(const wchar_t *)path2, pEC, VARIANT_FALSE, VARIANT_TRUE, -1,
						this);
				}
			}
		}
	}

	return S_OK; // success
}

void CVCMidlTool::GenerateTypeLibDep(IVCBuildAction* pAction, IVCPropertyContainer* pPropContainer, IVCBuildErrorContext* pEC, 
	CDirW& dirBase)
{
	// .tlb file is not always generated. check if we're supposed to be generating one
	if (s_optHandler.CreatesTypeLib(pPropContainer))
	{
		CComBSTR bstrTlb;
		if (pPropContainer->GetEvaluatedStrProperty(VCMIDLID_TypeLibraryName, &bstrTlb) == S_FALSE)
		{	// pick up the default instead, then
			s_optHandler.GetDefaultValue( VCMIDLID_TypeLibraryName, &bstrTlb );
			pPropContainer->Evaluate(bstrTlb, &bstrTlb);
		}
		CStringW strTlb = bstrTlb;
		strTlb.TrimLeft();
		if (!strTlb.IsEmpty())
		{
			pAction->AddOutputFromFileName(bstrTlb, pEC, L".tlb", (wchar_t *)(const wchar_t *)dirBase, VARIANT_TRUE,
				VCMIDLID_TypeLibraryName, this);
		}
	}
}

///////////////////////////////////////////////////////////////////////////////
// Affects our output?
STDMETHODIMP CVCMidlTool::AffectsOutput(long nPropID, VARIANT_BOOL* pbAffectsOutput)
{
	CHECK_POINTER_NULL(pbAffectsOutput);
	*pbAffectsOutput = VARIANT_FALSE;

	// change our outputs?
	switch (nPropID)
	{
	case VCMIDLID_InterfaceIdentifierFileName:	// *.c
	case VCMIDLID_TypeLibraryName:				// *.tlb
	case VCMIDLID_OutputDirectory:				// ALL
	case VCMIDLID_HeaderFileName:				// *.h
	case VCMIDLID_OutputsDirty:					// regenerate outptus
	case VCFCFGID_ExcludedFromBuild:			// included/excluded from build
	case VCMIDLID_GenerateTypeLibrary:			// do we generate a .tlb?
		*pbAffectsOutput = VARIANT_TRUE;
		break;
	default:
		*pbAffectsOutput = VARIANT_FALSE;
		break;
	}

	return S_OK;
}

STDMETHODIMP CVCMidlTool::CreatePageObject(IUnknown **ppUnk, CLSID*pCLSID, IVCPropertyContainer *pPropCntr, IVCSettingsPage *pPage )
{
	// Get the list of pages
	if( CLSID_MidlGeneral == *pCLSID )
	{
		CPageObjectImpl< CVCMidlGeneralPage,VCMIDLTOOL_MIN_DISPID,VCMIDLTOOL_MAX_DISPID >::CreateInstance(ppUnk, pPropCntr, pPage);
	}
	else if( CLSID_MidlOutput == *pCLSID )
	{
		CPageObjectImpl< CVCMidlOutputPage,VCMIDLTOOL_MIN_DISPID,VCMIDLTOOL_MAX_DISPID >::CreateInstance(ppUnk, pPropCntr, pPage);
	}
	else if( CLSID_MidlAdvanced == *pCLSID )
	{
		CPageObjectImpl< CVCMidlAdvancedPage,VCMIDLTOOL_MIN_DISPID,VCMIDLTOOL_MAX_DISPID >::CreateInstance(ppUnk, pPropCntr, pPage);
	}
	else
	{
		return S_FALSE;
	}
		
	return S_OK;
}

GUID* CVCMidlTool::GetPageIDs()
{ 
	if (s_bPagesInit == FALSE)
	{
		s_pPages[0] = __uuidof(MidlGeneral);
		s_pPages[1] = __uuidof(MidlOutput);
		s_pPages[2] = __uuidof(MidlAdvanced);
		s_pPages[3] = __uuidof(MidlAdditionalOptions);
		s_bPagesInit = TRUE;
	}
	return s_pPages; 
}

STDMETHODIMP CVCMidlTool::CanScanForDependencies(VARIANT_BOOL* pbIsScannable)
{
	return s_optHandler.GetValueTrue(pbIsScannable);
}

////////////////////////////////////////////////////////////////////
//	Scans files for includes.
STDMETHODIMP CVCMidlTool::GenerateDependencies(IVCBuildAction* pAction, void* pfrhFileCookie, IVCBuildErrorContext* pEC)
{
    	// WARNING (KiP) - Generate Dependencies works on ANSI Files
	// Many of the calls n this function will need to be _mbs calls instead of unicode
	// TCHAR characters and _tcs funtions should not be used because when UNICODE is defined,
	// TCHAR becomes UNICODE and we explicitly want _mbs not matter what.
	// yes, ANSI
	
	BldFileRegHandle	frhFile = (BldFileRegHandle)pfrhFileCookie;

	const char*		pFileNameBegin;
	BOOL			bSkipping = FALSE;
	int			iEntryType;
	char			cDelim;

	HANDLE hMem;
	DWORD dwFileSize;

	const char * pcFileMap;
	const CPathW* pPath = g_FileRegistry.GetRegEntry(frhFile)->GetFilePath();

	if (!g_StaticBuildEngine.OpenMemFile(frhFile, hMem, pcFileMap, dwFileSize, pEC, pAction))
		return CVCProjectEngine::DoSetErrorInfo2(VCPROJ_E_NOT_FOUND, IDS_ERR_FILE_NOT_FOUND, pPath->GetFullPath());	// couldn't open, continue with next

	const char* pMax;
	int nLine;

	if (pcFileMap == (const char*)NULL)
		goto CloseMemFile;	// no need to open

	pMax = pcFileMap + dwFileSize;
	nLine = 0;

	//	Check for afx hack.  If the file begins with "//{{NO_DEP", don't scan
	if ((dwFileSize > 10) && _mbsncmp((const unsigned char *)pcFileMap, (const unsigned char *)"//{{NO_DEP", 10) == 0)
	{
		pAction->SetDependencyState(depNone);
		goto CloseMemFile;
	}

	do
	{
		nLine++;	// start of a new line.

		// Skip leading blanks
		while (pcFileMap < pMax && _ismbcspace( (const unsigned char )*pcFileMap))
		{
			if (*pcFileMap == '\r')
				nLine++;
			pcFileMap++;
		}

		if (pcFileMap >= pMax)
			goto SkipToEnd;

		 // Check this first so we ignore comments.
		if (*pcFileMap == '/')
		{
			if (bSkipping)
			{
				if (pMax - pcFileMap >= 17 && _mbsncmp((const unsigned char *)pcFileMap, (const unsigned char *)"//}}START_DEPSCAN", 17) == 0)
					bSkipping = FALSE;
			}
			else
			{
				if (pMax - pcFileMap >= 16 && _mbsncmp((const unsigned char *)pcFileMap, (const unsigned char *)"//{{STOP_DEPSCAN", 16) == 0)
					bSkipping = TRUE;
			}
		}
		else if (*pcFileMap == '#' || *pcFileMap == 'i')
		{
			if (bSkipping) 
				goto SkipToEnd;

			// Go past #
			if( *pcFileMap == '#' )
				if (++pcFileMap >= pMax)
					goto SkipToEnd;

			// Skip white space after #
			while (pcFileMap < pMax && _ismbcspace(*pcFileMap))
				pcFileMap++;

			// Look for "include"
			if (pMax - pcFileMap <= 7)
				goto SkipToEnd;

			if (_mbsncmp((const unsigned char *)pcFileMap, (const unsigned char *)"include", 7) == 0)
				pcFileMap += 7;
			else if (_mbsncmp((const unsigned char *)pcFileMap, (const unsigned char *)"import", 6) == 0)
				pcFileMap += 6;
			else
				goto SkipToEnd;

			// Skip white space after include
			while (pcFileMap < pMax && _ismbcspace( *pcFileMap))
				pcFileMap++;

			if (pcFileMap >= pMax)
				goto SkipToEnd;

			// Look for the delimiter either " or <
			if (*pcFileMap == '"')
			{
				iEntryType = IncTypeCheckParentDir |  IncTypeCheckIncludePath | IncTypeCheckOriginalDir;
				cDelim = '"';
			}
			else if (*pcFileMap == '<')
			{
				iEntryType = IncTypeCheckIncludePath;
				cDelim = '>';
			}
			else 
				goto SkipToEnd;

			pcFileMap++;
			if (pcFileMap >= pMax)
				goto SkipToEnd;

			pFileNameBegin = pcFileMap;

			// Look for	other delimeter, or a return if the user screwed up
			while (pcFileMap < pMax && *pcFileMap != cDelim && *pcFileMap != '\r')
				pcFileMap = (const char *)_mbsinc((const unsigned char *)pcFileMap);

			if ( pcFileMap >= pMax || *pcFileMap == '\r')
				goto SkipToEnd;

			// File name now starts at pFileNameBegin and ends at pcFileMap-1.
			int nNameLength =  (int)(pcFileMap - pFileNameBegin);

			CStringA strFileA;	// yes, ANSI -- 'cause IDL files have ANSI contents
			char *pbuf = strFileA.GetBuffer(nNameLength + 1);

			_mbsncpy((unsigned char*)pbuf, (unsigned char*)pFileNameBegin, nNameLength);
			pbuf[nNameLength] = '\0';
			strFileA.ReleaseBuffer();


			// OK Now switch to unicode and add to list
			CStringW strFile;
			strFile = strFileA;
			CVCStringWList strlstIncs;
			CVCStringWList strlstPaths;
			strlstIncs.AddHead(L"\"" + strFile + L"\"");
			if (!ResolveIncludeDirectivesToPath(*pPath, pAction, strlstIncs, strlstPaths))
			{
				pAction->MarkMissingDependencies(TRUE);
				goto CloseMemFile;
			}
			if (strlstPaths.GetCount())
			{
				CStringW strInc = strlstPaths.GetHead();
				CComBSTR bstrInc = strInc;
				HRESULT hr = pAction->AddScannedDependencyOfType(iEntryType, bstrInc, nLine, TRUE, pEC);
				VSASSERT(hr == S_OK, "pAction->AddScannedDependencyOfType returned unexpected value!");
			}
		}

SkipToEnd:

		while (pcFileMap < pMax && *pcFileMap != '\r')
			pcFileMap = (const char *)_mbsinc((const unsigned char *)pcFileMap);

		if (pcFileMap < pMax && *pcFileMap == '\r')
			pcFileMap++;

	} while (pcFileMap < pMax);

CloseMemFile:

	g_StaticBuildEngine.CloseMemFile(hMem, pEC);

	return S_OK;	 		
}		

///////////////////////////////////////////////////////////////////////////////////////
// CVCMidlTool::VCMidlTool
///////////////////////////////////////////////////////////////////////////////////////

// general (/ms_ext, /c_ext left out because they're archaic); @response deliberately left out
STDMETHODIMP CVCMidlTool::get_ToolName(BSTR* pbstrToolName)
{	// friendly name of tool, e.g., "C/C++ Compiler Tool"
	CHECK_POINTER_VALID( pbstrToolName );
	InitToolName();
	s_bstrToolName.CopyTo(pbstrToolName);
	return S_OK;
}

STDMETHODIMP CVCMidlTool::get_AdditionalOptions(BSTR* pbstrAdditionalOptions)
{	// anything we don't know what to do with, given verbatim, in same order as entered, parent contributions first, goes after all other options
	return ToolGetStrProperty(VCMIDLID_AdditionalOptions, pbstrAdditionalOptions);
}

STDMETHODIMP CVCMidlTool::put_AdditionalOptions(BSTR bstrAdditionalOptions)
{
	CHECK_ZOMBIE( m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE );
	return m_spPropertyContainer->SetStrProperty(VCMIDLID_AdditionalOptions, bstrAdditionalOptions);
}

STDMETHODIMP CVCMidlTool::get_PreprocessorDefinitions(BSTR* pbstrDefines)
{	// (/D![macro]) define macro for MIDL.  can have multiple.
	return ToolGetStrProperty(VCMIDLID_PreprocessorDefinitions, pbstrDefines, true /* local only */);
}

STDMETHODIMP CVCMidlTool::put_PreprocessorDefinitions(BSTR bstrDefines)
{
	CHECK_ZOMBIE( m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE );
	return m_spPropertyContainer->SetStrProperty(VCMIDLID_PreprocessorDefinitions, bstrDefines);
}

STDMETHODIMP CVCMidlTool::get_AdditionalIncludeDirectories(BSTR* pbstrIncludePath)
{	// (/I![path]) directory to add to include path, may have multiple
	return ToolGetStrProperty(VCMIDLID_AdditionalIncludeDirectories, pbstrIncludePath, true /* local only */);
}

STDMETHODIMP CVCMidlTool::put_AdditionalIncludeDirectories(BSTR bstrIncludePath)
{
	CHECK_ZOMBIE( m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE );
	return m_spPropertyContainer->SetStrProperty(VCMIDLID_AdditionalIncludeDirectories, bstrIncludePath);
}

STDMETHODIMP CVCMidlTool::get_IgnoreStandardIncludePath(VARIANT_BOOL* pbIgnore)
{	// (/no_def_idir) ignore current and INCLUDE path
	return ToolGetBoolProperty(VCMIDLID_IgnoreStandardIncludePath, pbIgnore);
}

STDMETHODIMP CVCMidlTool::put_IgnoreStandardIncludePath(VARIANT_BOOL bIgnore)
{
	CHECK_ZOMBIE( m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE );
	CHECK_VARIANTBOOL( bIgnore );
	return m_spPropertyContainer->SetBoolProperty(VCMIDLID_IgnoreStandardIncludePath, bIgnore);
}

STDMETHODIMP CVCMidlTool::get_MkTypLibCompatible(VARIANT_BOOL* pbCompatible)
{	// (/mktyplib203) forces compatibility with mktyplib.exe version 2.03
	return ToolGetBoolProperty(VCMIDLID_MkTypLibCompatible, pbCompatible);
}

STDMETHODIMP CVCMidlTool::put_MkTypLibCompatible(VARIANT_BOOL bCompatible)
{
	CHECK_ZOMBIE( m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE );
	CHECK_VARIANTBOOL( bCompatible );
	return m_spPropertyContainer->SetBoolProperty(VCMIDLID_MkTypLibCompatible, bCompatible);
}

STDMETHODIMP CVCMidlTool::get_WarningLevel(midlWarningLevelOption* poptSetting)
{	// see enum above (/W0 - /W4)
	return ToolGetIntProperty(VCMIDLID_WarningLevel, (long *)poptSetting);
}

STDMETHODIMP CVCMidlTool::put_WarningLevel(midlWarningLevelOption optSetting)
{
	CHECK_ZOMBIE( m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE );
	CHECK_BOUNDS(StdEnumMin, midlWarnMax, optSetting);
	return m_spPropertyContainer->SetIntProperty(VCMIDLID_WarningLevel, optSetting);
}

STDMETHODIMP CVCMidlTool::get_WarnAsError(VARIANT_BOOL* pbWarnAsError)
{	// (/WX) treat warnings as errors
	return ToolGetBoolProperty(VCMIDLID_WarnAsError, pbWarnAsError);
}

STDMETHODIMP CVCMidlTool::put_WarnAsError(VARIANT_BOOL bWarnAsError)
{
	CHECK_ZOMBIE( m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE );
	CHECK_VARIANTBOOL( bWarnAsError );
	return m_spPropertyContainer->SetBoolProperty(VCMIDLID_WarnAsError, bWarnAsError);
}

STDMETHODIMP CVCMidlTool::get_SuppressStartupBanner(VARIANT_BOOL* pbNoLogo)
{	// (/nologo) enable suppression of copyright message
	return ToolGetBoolProperty(VCMIDLID_SuppressStartupBanner, pbNoLogo);
}

STDMETHODIMP CVCMidlTool::put_SuppressStartupBanner(VARIANT_BOOL bNoLogo)
{
	CHECK_ZOMBIE( m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE );
	CHECK_VARIANTBOOL( bNoLogo );
	return m_spPropertyContainer->SetBoolProperty(VCMIDLID_SuppressStartupBanner, bNoLogo);
}

STDMETHODIMP CVCMidlTool::get_DefaultCharType(midlCharOption* poptSetting)
{	// see enum above (/char)
	return ToolGetIntProperty(VCMIDLID_DefaultCharType, (long *)poptSetting);
}

STDMETHODIMP CVCMidlTool::put_DefaultCharType(midlCharOption optSetting)
{
	CHECK_ZOMBIE( m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE );
	CHECK_BOUNDS(StdEnumMin, charTypeMax, optSetting);
	return m_spPropertyContainer->SetIntProperty(VCMIDLID_DefaultCharType, optSetting);
}

STDMETHODIMP CVCMidlTool::get_TargetEnvironment(midlTargetEnvironment* poptSetting)
{	// (/env win64 vs. /env win32) target Win64 (or Win32) environment
	return ToolGetIntProperty(VCMIDLID_TargetEnvironment, (long *)poptSetting);
}

STDMETHODIMP CVCMidlTool::put_TargetEnvironment(midlTargetEnvironment optSetting)
{
	CHECK_ZOMBIE( m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE );
	CHECK_BOUNDS(StdEnumMin, envMax, optSetting);
	return m_spPropertyContainer->SetIntProperty(VCMIDLID_TargetEnvironment, optSetting);
}

STDMETHODIMP CVCMidlTool::get_GenerateStublessProxies(VARIANT_BOOL* poptSetting)
{	// (/Oicf)
	return ToolGetBoolProperty(VCMIDLID_GenerateStublessProxies, poptSetting);
}

STDMETHODIMP CVCMidlTool::put_GenerateStublessProxies(VARIANT_BOOL optSetting)
{
	CHECK_ZOMBIE( m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE );
	CHECK_VARIANTBOOL( optSetting );
	return m_spPropertyContainer->SetBoolProperty(VCMIDLID_GenerateStublessProxies, optSetting);
}

// output 
STDMETHODIMP CVCMidlTool::get_GenerateTypeLibrary(VARIANT_BOOL* poptSetting)
{	// (/notlb for no) generate a type library?; default: yes
	return ToolGetBoolProperty(VCMIDLID_GenerateTypeLibrary, poptSetting);
}

STDMETHODIMP CVCMidlTool::put_GenerateTypeLibrary(VARIANT_BOOL optSetting)
{
	CHECK_ZOMBIE( m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE );
	CHECK_VARIANTBOOL(optSetting);
	return m_spPropertyContainer->SetBoolProperty(VCMIDLID_GenerateTypeLibrary, optSetting);
}

STDMETHODIMP CVCMidlTool::get_OutputDirectory(BSTR* pbstrOut)
{	// (/out dir) directory to place output files in; default: project directory
	return ToolGetStrProperty(VCMIDLID_OutputDirectory, pbstrOut);
}

STDMETHODIMP CVCMidlTool::put_OutputDirectory(BSTR bstrOut)
{
	CHECK_ZOMBIE( m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE );
	return m_spPropertyContainer->SetStrProperty(VCMIDLID_OutputDirectory, bstrOut);
}

STDMETHODIMP CVCMidlTool::get_HeaderFileName(BSTR* pbstrHeaderFile)
{	// (/h[eader] filename) specify name of header file generated; default: <idlfile>.h
	return ToolGetStrProperty(VCMIDLID_HeaderFileName, pbstrHeaderFile);
}

STDMETHODIMP CVCMidlTool::put_HeaderFileName(BSTR bstrHeaderFile)
{
	CHECK_ZOMBIE( m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE );
	return m_spPropertyContainer->SetStrProperty(VCMIDLID_HeaderFileName, bstrHeaderFile);
}

STDMETHODIMP CVCMidlTool::get_DLLDataFileName(BSTR* pbstrDLLData)
{	// (/dlldata filename) specify name of DLLDATA file generated; default: dlldata.c
	return ToolGetStrProperty(VCMIDLID_DLLDataFileName, pbstrDLLData);
}

STDMETHODIMP CVCMidlTool::put_DLLDataFileName(BSTR bstrDLLData)
{
	CHECK_ZOMBIE( m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE );
	return m_spPropertyContainer->SetStrProperty(VCMIDLID_DLLDataFileName, bstrDLLData);
}

STDMETHODIMP CVCMidlTool::get_InterfaceIdentifierFileName(BSTR* pbstrIID)
{	// (/iid filename) specify name of IID file; default: <idlfile>_i.c
	return ToolGetStrProperty(VCMIDLID_InterfaceIdentifierFileName, pbstrIID);
}

STDMETHODIMP CVCMidlTool::put_InterfaceIdentifierFileName(BSTR bstrIID)
{
	CHECK_ZOMBIE( m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE );
	return m_spPropertyContainer->SetStrProperty(VCMIDLID_InterfaceIdentifierFileName, bstrIID);
}

STDMETHODIMP CVCMidlTool::get_ProxyFileName(BSTR* pbstrProxyFile)
{	// (/proxy filename) specify name of proxy file; default: <idlfile>_p.c
	return ToolGetStrProperty(VCMIDLID_ProxyFileName, pbstrProxyFile);
}

STDMETHODIMP CVCMidlTool::put_ProxyFileName(BSTR bstrProxyFile)
{
	CHECK_ZOMBIE( m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE );
	return m_spPropertyContainer->SetStrProperty(VCMIDLID_ProxyFileName, bstrProxyFile);
}

STDMETHODIMP CVCMidlTool::get_TypeLibraryName(BSTR* pbstrTLBFile)
{	// (/tlb filename) specify name of TLB file; default: <idlfile>.tlb
	return ToolGetStrProperty(VCMIDLID_TypeLibraryName, pbstrTLBFile);
}

STDMETHODIMP CVCMidlTool::put_TypeLibraryName(BSTR bstrTLBFile)
{
	CHECK_ZOMBIE( m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE );
	return m_spPropertyContainer->SetStrProperty(VCMIDLID_TypeLibraryName, bstrTLBFile);
}

// Advanced
STDMETHODIMP CVCMidlTool::get_EnableErrorChecks(midlErrorCheckOption* poptSetting)
{	// see enum above (/error {none|all}) 
	return ToolGetIntProperty(VCMIDLID_EnableErrorChecks, (long *)poptSetting);
}

STDMETHODIMP CVCMidlTool::put_EnableErrorChecks(midlErrorCheckOption optSetting)
{
	CHECK_ZOMBIE( m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE );
	CHECK_BOUNDS(StdEnumMin, errCheckMax, optSetting);
	return m_spPropertyContainer->SetIntProperty(VCMIDLID_EnableErrorChecks, optSetting);
}

STDMETHODIMP CVCMidlTool::get_ErrorCheckAllocations(VARIANT_BOOL* pbErrorCheck)
{	// (/error allocation) check for out of memory errors
	return ToolGetBoolProperty(VCMIDLID_ErrorCheckAllocations, pbErrorCheck);
}

STDMETHODIMP CVCMidlTool::put_ErrorCheckAllocations(VARIANT_BOOL bErrorCheck)
{
	CHECK_ZOMBIE( m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE );
	CHECK_VARIANTBOOL( bErrorCheck );
	return m_spPropertyContainer->SetBoolProperty(VCMIDLID_ErrorCheckAllocations, bErrorCheck);
}

STDMETHODIMP CVCMidlTool::get_ErrorCheckBounds(VARIANT_BOOL* pbErrorCheck)
{	// (/error bounds_check) check size	vs. transmission length specifications
	return ToolGetBoolProperty(VCMIDLID_ErrorCheckBounds, pbErrorCheck);
}

STDMETHODIMP CVCMidlTool::put_ErrorCheckBounds(VARIANT_BOOL bErrorCheck)
{
	CHECK_ZOMBIE( m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE );
	CHECK_VARIANTBOOL( bErrorCheck );
	return m_spPropertyContainer->SetBoolProperty(VCMIDLID_ErrorCheckBounds, bErrorCheck);
}

STDMETHODIMP CVCMidlTool::get_ErrorCheckEnumRange(VARIANT_BOOL* pbErrorCheck)
{	// (/error enum) check enum values to be in allowable range not in docs
	return ToolGetBoolProperty(VCMIDLID_ErrorCheckEnumRange, pbErrorCheck);
}

STDMETHODIMP CVCMidlTool::put_ErrorCheckEnumRange(VARIANT_BOOL bErrorCheck)
{
	CHECK_ZOMBIE( m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE );
	CHECK_VARIANTBOOL( bErrorCheck );
	return m_spPropertyContainer->SetBoolProperty(VCMIDLID_ErrorCheckEnumRange, bErrorCheck);
}

STDMETHODIMP CVCMidlTool::get_ErrorCheckRefPointers(VARIANT_BOOL* pbErrorCheck)
{	// (/error ref) check ref pointers to be non-NULL
	return ToolGetBoolProperty(VCMIDLID_ErrorCheckRefPointers, pbErrorCheck);
}

STDMETHODIMP CVCMidlTool::put_ErrorCheckRefPointers(VARIANT_BOOL bErrorCheck)
{
	CHECK_ZOMBIE( m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE );
	CHECK_VARIANTBOOL( bErrorCheck );
	return m_spPropertyContainer->SetBoolProperty(VCMIDLID_ErrorCheckRefPointers, bErrorCheck);
}

STDMETHODIMP CVCMidlTool::get_ErrorCheckStubData(VARIANT_BOOL* pbErrorCheck)
{	// (/error stub_data) emit additional check for server side data stub validity
	return ToolGetBoolProperty(VCMIDLID_ErrorCheckStubData, pbErrorCheck);
}

STDMETHODIMP CVCMidlTool::put_ErrorCheckStubData(VARIANT_BOOL bErrorCheck)
{
	CHECK_ZOMBIE( m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE );
	CHECK_VARIANTBOOL( bErrorCheck );
	return m_spPropertyContainer->SetBoolProperty(VCMIDLID_ErrorCheckStubData, bErrorCheck);
}

STDMETHODIMP CVCMidlTool::get_ValidateParameters(VARIANT_BOOL* pbValidate)
{	// (/robust) generate additional information to validate parameters not in docs
	return ToolGetBoolProperty(VCMIDLID_ValidateParameters, pbValidate);
}

STDMETHODIMP CVCMidlTool::put_ValidateParameters(VARIANT_BOOL bValidate)
{
	CHECK_ZOMBIE( m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE );
	CHECK_VARIANTBOOL( bValidate );
	return m_spPropertyContainer->SetBoolProperty(VCMIDLID_ValidateParameters, bValidate);
}

STDMETHODIMP CVCMidlTool::get_StructMemberAlignment(midlStructMemberAlignOption* poptSetting)
{	// see enum above (/Zp[num])
	return ToolGetIntProperty(VCMIDLID_StructMemberAlignment, (long *)poptSetting);
}

STDMETHODIMP CVCMidlTool::put_StructMemberAlignment(midlStructMemberAlignOption optSetting)
{
	CHECK_ZOMBIE( m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE );
	CHECK_BOUNDS(StdEnumMin, midlStructAlignMax, optSetting);
	return m_spPropertyContainer->SetIntProperty(VCMIDLID_StructMemberAlignment, optSetting);
}

STDMETHODIMP CVCMidlTool::get_RedirectOutputAndErrors(BSTR* pbstrOutput)
{	// (/o file) redirect output from screen to a file
	return ToolGetStrProperty(VCMIDLID_RedirectOutputAndErrors, pbstrOutput);
}

STDMETHODIMP CVCMidlTool::put_RedirectOutputAndErrors(BSTR bstrOutput)
{
	CHECK_ZOMBIE( m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE );
	return m_spPropertyContainer->SetStrProperty(VCMIDLID_RedirectOutputAndErrors, bstrOutput);
}

STDMETHODIMP CVCMidlTool::get_CPreprocessOptions(BSTR* pbstrOpt)
{	// (/cpp_opt"[option]") C-compiler preprocessor option to pass to MIDL.  must be in exact format for desired switches
	return ToolGetStrProperty(VCMIDLID_CPreprocessOptions, pbstrOpt, true /* local only */);
}

STDMETHODIMP CVCMidlTool::put_CPreprocessOptions(BSTR bstrOpt)
{
	CHECK_ZOMBIE( m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE );
	return m_spPropertyContainer->SetStrProperty(VCMIDLID_CPreprocessOptions, bstrOpt);
}

STDMETHODIMP CVCMidlTool::get_UndefinePreprocessorDefinitions(BSTR* pbstrUndefines)
{	// (/U![macro]) remove any previous definition of symbol.  can have multiple.
	return ToolGetStrProperty(VCMIDLID_UndefinePreprocessorDefinitions, pbstrUndefines, true /* local only */);
}

STDMETHODIMP CVCMidlTool::put_UndefinePreprocessorDefinitions(BSTR bstrUndefines)
{
	CHECK_ZOMBIE( m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE );
	return m_spPropertyContainer->SetStrProperty(VCMIDLID_UndefinePreprocessorDefinitions, bstrUndefines);
}

// Automation properties
STDMETHODIMP CVCMidlTool::get_ToolPath(BSTR *pVal)
{
	CHECK_ZOMBIE( m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE );
	*pVal = SysAllocString( szMidlToolPath );
	return S_OK;
}

STDMETHODIMP CVCMidlTool::get_PropertyOption(BSTR bstrProp, long dispidProp, BSTR *pVal)
{ 
	return DoGetPropertyOption(bstrProp, dispidProp, pVal); 
}

STDMETHODIMP CVCMidlTool::get_FullIncludePath(BSTR* fullIncludePath)
{	// include path, including all inherited values, plus platform includes
	return get_FullIncludePathInternal(fullIncludePath);
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
// CVCMidlTool::IVCToolImpl
/////////////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CVCMidlTool::get_DefaultExtensions(BSTR* pVal)
{
	return DoGetDefaultExtensions(s_bstrExtensions, wszMidlDefaultExtensions, pVal);
}

STDMETHODIMP CVCMidlTool::put_DefaultExtensions(BSTR newVal)
{
	s_bstrExtensions = newVal;
	return S_OK;
}

STDMETHODIMP CVCMidlTool::GetAdditionalOptionsInternal(IUnknown* pItem, VARIANT_BOOL bForBuild, VARIANT_BOOL bSkipLocal, 
	BSTR* pbstrAdditionalOptions)
{ 
	return GetProcessedAdditionalOptions(pItem, VCMIDLID_AdditionalOptions, bForBuild, bSkipLocal, pbstrAdditionalOptions);
}

STDMETHODIMP CVCMidlTool::GetBuildDescription(IVCBuildAction* pAction, BSTR* pbstrBuildDescription)
{
	if (s_bstrBuildDescription.Length() == 0)
		s_bstrBuildDescription.LoadString(IDS_DESC_MKTYPLIB_COMPILING);
	return s_bstrBuildDescription.CopyTo(pbstrBuildDescription);
}

STDMETHODIMP CVCMidlTool::get_ToolPathInternal(BSTR* pbstrToolPath)
{ 
	*pbstrToolPath = SysAllocString( szMidlToolPath );
	return S_OK;
}

STDMETHODIMP CVCMidlTool::get_Bucket(long *pVal)
{
	CHECK_POINTER_NULL( pVal );
	*pVal = BUCKET_MIDL;
	return S_OK;
}

STDMETHODIMP CVCMidlTool::CreateToolObject(IVCPropertyContainer* pPropContainer, IVCToolImpl** ppToolObject)
{ 
	return CreateInstance(pPropContainer, ppToolObject); 
}

STDMETHODIMP CVCMidlTool::GetAdditionalIncludeDirectoriesInternal(IVCPropertyContainer* pPropContainer, BSTR* pbstrIncDirs)
{
	CHECK_POINTER_NULL(pbstrIncDirs);
	CHECK_READ_POINTER_NULL(pPropContainer);

	CComBSTR bstrTmp;
	HRESULT hr = pPropContainer->GetMultiProp(VCMIDLID_AdditionalIncludeDirectories, L";", VARIANT_FALSE, &bstrTmp);
	if (SUCCEEDED(hr))
		pPropContainer->Evaluate(bstrTmp, pbstrIncDirs);
	else
		*pbstrIncDirs = bstrTmp.Detach();
	return hr;
}

STDMETHODIMP CVCMidlTool::get_IncludePathID(long* pnIncludeID)
{
	CHECK_POINTER_NULL(pnIncludeID);
	*pnIncludeID = VCMIDLID_AdditionalIncludeDirectories;
	return S_OK;
}

STDMETHODIMP CVCMidlTool::get_ToolShortName(BSTR* pbstrToolName)
{
	*pbstrToolName = SysAllocString( szMidlToolShortName );
	return S_OK;
}

STDMETHODIMP CVCMidlTool::MatchName(BSTR bstrName, VARIANT_BOOL bFullOnly, VARIANT_BOOL* pbMatches)
{
	return DoMatchName(bstrName, szMidlToolType, szMidlToolShortName, pbMatches);
}

// settings pages
/////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CVCMidlGeneralPage::get_PreprocessorDefinitions(BSTR* pbstrDefines)
{	// (/D![macro]) define macro for MIDL.  can have multiple.
	return ToolGetStrProperty(VCMIDLID_PreprocessorDefinitions, &(CVCMidlTool::s_optHandler), pbstrDefines, true /* local only */);
}

STDMETHODIMP CVCMidlGeneralPage::put_PreprocessorDefinitions(BSTR bstrDefines)
{
	return SetStrProperty(VCMIDLID_PreprocessorDefinitions, bstrDefines);
}

STDMETHODIMP CVCMidlGeneralPage::get_AdditionalIncludeDirectories(BSTR* pbstrIncludePath)
{	// (/I![path]) directory to add to include path, may have multiple
	return ToolGetStrProperty(VCMIDLID_AdditionalIncludeDirectories, &(CVCMidlTool::s_optHandler), pbstrIncludePath, true /* local only */);
}

STDMETHODIMP CVCMidlGeneralPage::put_AdditionalIncludeDirectories(BSTR bstrIncludePath)
{
	return SetStrProperty(VCMIDLID_AdditionalIncludeDirectories, bstrIncludePath);
}

STDMETHODIMP CVCMidlGeneralPage::get_IgnoreStandardIncludePath(enumMidlIgnoreStandardIncludePathBOOL* pbIgnore)
{	// (/no_def_idir) ignore current and INCLUDE path
	return GetEnumBoolProperty2(VCMIDLID_IgnoreStandardIncludePath, (long *)pbIgnore);
}

STDMETHODIMP CVCMidlGeneralPage::put_IgnoreStandardIncludePath(enumMidlIgnoreStandardIncludePathBOOL bIgnore)
{
	return SetBoolProperty(VCMIDLID_IgnoreStandardIncludePath, bIgnore);
}

STDMETHODIMP CVCMidlGeneralPage::get_MkTypLibCompatible(enumMkTypLibCompatibleBOOL* pbCompatible)
{	// (/mktyplib203) forces compatibility with mktyplib.exe version 2.03
	return GetEnumBoolProperty2(VCMIDLID_MkTypLibCompatible, (long *)pbCompatible);
}

STDMETHODIMP CVCMidlGeneralPage::put_MkTypLibCompatible(enumMkTypLibCompatibleBOOL bCompatible)
{
	return SetBoolProperty(VCMIDLID_MkTypLibCompatible, bCompatible);
}

STDMETHODIMP CVCMidlGeneralPage::get_WarningLevel(midlWarningLevelOption* poptSetting)
{	// see enum above (/W0 - /W4)
	return ToolGetIntProperty(VCMIDLID_WarningLevel, &(CVCMidlTool::s_optHandler), (long *)poptSetting);
}

STDMETHODIMP CVCMidlGeneralPage::put_WarningLevel(midlWarningLevelOption optSetting)
{
	CHECK_BOUNDS(INHERIT_PROP_VALUE, midlWarnMax, optSetting);
	return SetIntProperty(VCMIDLID_WarningLevel, optSetting);
}

STDMETHODIMP CVCMidlGeneralPage::get_WarnAsError(enumWarnAsErrorBOOL* pbWarnAsError)
{	// (/WX) treat warnings as errors
	return GetEnumBoolProperty2(VCMIDLID_WarnAsError, (long *)pbWarnAsError);
}

STDMETHODIMP CVCMidlGeneralPage::put_WarnAsError(enumWarnAsErrorBOOL bWarnAsError)
{
	return SetBoolProperty(VCMIDLID_WarnAsError, bWarnAsError);
}

STDMETHODIMP CVCMidlGeneralPage::get_SuppressStartupBanner(enumSuppressStartupBannerBOOL* pbNoLogo)
{	// (/nologo) enable suppression of copyright message
	return GetEnumBoolProperty2(VCMIDLID_SuppressStartupBanner, (long *)pbNoLogo);
}

STDMETHODIMP CVCMidlGeneralPage::put_SuppressStartupBanner(enumSuppressStartupBannerBOOL bNoLogo)
{
	return SetBoolProperty(VCMIDLID_SuppressStartupBanner, bNoLogo);
}

STDMETHODIMP CVCMidlGeneralPage::get_DefaultCharType(midlCharOption* poptSetting)
{	// see enum above (/char)
	return ToolGetIntProperty(VCMIDLID_DefaultCharType, &(CVCMidlTool::s_optHandler), (long *)poptSetting);
}

STDMETHODIMP CVCMidlGeneralPage::put_DefaultCharType(midlCharOption optSetting)
{
	CHECK_BOUNDS(INHERIT_PROP_VALUE, charTypeMax, optSetting);
	return SetIntProperty(VCMIDLID_DefaultCharType, optSetting);
}

STDMETHODIMP CVCMidlGeneralPage::get_TargetEnvironment(midlTargetEnvironment* poptSetting)
{	// (/env win64 vs. /env win32) target Win64 (or Win32) environment
	return ToolGetIntProperty(VCMIDLID_TargetEnvironment, &(CVCMidlTool::s_optHandler), (long *)poptSetting);
}

STDMETHODIMP CVCMidlGeneralPage::put_TargetEnvironment(midlTargetEnvironment optSetting)
{
	CHECK_BOUNDS(INHERIT_PROP_VALUE, envMax, optSetting);
	return SetIntProperty(VCMIDLID_TargetEnvironment, optSetting);
}

STDMETHODIMP CVCMidlGeneralPage::get_GenerateStublessProxies(enumGenerateStublessProxiesBOOL* poptSetting)
{	// (/Oicf)
	return GetEnumBoolProperty2(VCMIDLID_GenerateStublessProxies, (long *)poptSetting);
}

STDMETHODIMP CVCMidlGeneralPage::put_GenerateStublessProxies(enumGenerateStublessProxiesBOOL optSetting)
{
	return SetBoolProperty(VCMIDLID_GenerateStublessProxies, optSetting);
}

void CVCMidlGeneralPage::GetBaseDefault(long id, CComVariant& varValue)
{
	if (id == VCMIDLID_SuppressStartupBanner)
	{
		VARIANT_BOOL bVal;
		CVCMidlTool::s_optHandler.GetDefaultValue( id, &bVal );
		varValue = bVal;
	}
	else
		CBase::GetBaseDefault(id, varValue);
}

// output 
STDMETHODIMP CVCMidlOutputPage::get_GenerateTypeLibrary(enumGenerateTypeLibraryBOOL* poptSetting)
{	// (/notlb) generate a type library or not; default is yes
	return GetEnumBoolProperty2(VCMIDLID_GenerateTypeLibrary, (long *)poptSetting);
}

STDMETHODIMP CVCMidlOutputPage::put_GenerateTypeLibrary(enumGenerateTypeLibraryBOOL optSetting)
{
	return SetBoolProperty(VCMIDLID_GenerateTypeLibrary, optSetting);
}

STDMETHODIMP CVCMidlOutputPage::get_OutputDirectory(BSTR* pbstrOut)
{	// (/out dir) directory to place output files in; default: project directory
	return ToolGetStrProperty(VCMIDLID_OutputDirectory, &(CVCMidlTool::s_optHandler), pbstrOut);
}

STDMETHODIMP CVCMidlOutputPage::put_OutputDirectory(BSTR bstrOut)
{
	return SetStrProperty(VCMIDLID_OutputDirectory, bstrOut);
}

STDMETHODIMP CVCMidlOutputPage::get_HeaderFileName(BSTR* pbstrHeaderFile)
{	// (/h[eader] filename) specify name of header file generated; default: <idlfile>.h
	return ToolGetStrProperty(VCMIDLID_HeaderFileName, &(CVCMidlTool::s_optHandler), pbstrHeaderFile);
}

STDMETHODIMP CVCMidlOutputPage::put_HeaderFileName(BSTR bstrHeaderFile)
{
	return SetStrProperty(VCMIDLID_HeaderFileName, bstrHeaderFile);
}

STDMETHODIMP CVCMidlOutputPage::get_DLLDataFileName(BSTR* pbstrDLLData)
{	// (/dlldata filename) specify name of DLLDATA file generated; default: dlldata.c
	return ToolGetStrProperty(VCMIDLID_DLLDataFileName, &(CVCMidlTool::s_optHandler), pbstrDLLData);
}

STDMETHODIMP CVCMidlOutputPage::put_DLLDataFileName(BSTR bstrDLLData)
{
	return SetStrProperty(VCMIDLID_DLLDataFileName, bstrDLLData);
}

STDMETHODIMP CVCMidlOutputPage::get_InterfaceIdentifierFileName(BSTR* pbstrIID)
{	// (/iid filename) specify name of IID file; default: <idlfile>_i.c
	return ToolGetStrProperty(VCMIDLID_InterfaceIdentifierFileName, &(CVCMidlTool::s_optHandler), pbstrIID);
}

STDMETHODIMP CVCMidlOutputPage::put_InterfaceIdentifierFileName(BSTR bstrIID)
{
	return SetStrProperty(VCMIDLID_InterfaceIdentifierFileName, bstrIID);
}

STDMETHODIMP CVCMidlOutputPage::get_ProxyFileName(BSTR* pbstrProxyFile)
{	// (/proxy filename) specify name of proxy file; default: <idlfile>_p.c
	return ToolGetStrProperty(VCMIDLID_ProxyFileName, &(CVCMidlTool::s_optHandler), pbstrProxyFile);
}

STDMETHODIMP CVCMidlOutputPage::put_ProxyFileName(BSTR bstrProxyFile)
{
	return SetStrProperty(VCMIDLID_ProxyFileName, bstrProxyFile);
}

STDMETHODIMP CVCMidlOutputPage::get_TypeLibraryName(BSTR* pbstrTLBFile)
{	// (/tlb filename) specify name of TLB file; default: <idlfile>.tlb
	return ToolGetStrProperty(VCMIDLID_TypeLibraryName, &(CVCMidlTool::s_optHandler), pbstrTLBFile);
}

STDMETHODIMP CVCMidlOutputPage::put_TypeLibraryName(BSTR bstrTLBFile)
{
	return SetStrProperty(VCMIDLID_TypeLibraryName, bstrTLBFile);
}

void CVCMidlOutputPage::GetBaseDefault(long id, CComVariant& varValue)
{
	CComBSTR bstrVal;
	VARIANT_BOOL bVal;
	switch (id)
	{
	case VCMIDLID_HeaderFileName:
	case VCMIDLID_DLLDataFileName:
	case VCMIDLID_TypeLibraryName:
		CVCMidlTool::s_optHandler.GetDefaultValue( id, &bstrVal );
		varValue = bstrVal;
		break;
	case VCMIDLID_GenerateTypeLibrary:
		CVCMidlTool::s_optHandler.GetDefaultValue(VCMIDLID_GenerateTypeLibrary, &bVal);
		varValue = bVal;
		break;
	default:
		CBase::GetBaseDefault(id, varValue);
		return;
	}

}

// Advanced
STDMETHODIMP CVCMidlAdvancedPage::get_EnableErrorChecks(midlErrorCheckOption* poptSetting)
{	// see enum above (/error {none|all}) 
	return ToolGetIntProperty(VCMIDLID_EnableErrorChecks, &(CVCMidlTool::s_optHandler), (long *)poptSetting);
}

STDMETHODIMP CVCMidlAdvancedPage::put_EnableErrorChecks(midlErrorCheckOption optSetting)
{
	CHECK_BOUNDS(INHERIT_PROP_VALUE, errCheckMax, optSetting);
	return SetIntProperty(VCMIDLID_EnableErrorChecks, optSetting);
}

STDMETHODIMP CVCMidlAdvancedPage::get_ErrorCheckAllocations(enumErrorCheckAllocationsBOOL* pbErrorCheck)
{	// (/error allocation) check for out of memory errors
	return GetEnumBoolProperty2(VCMIDLID_ErrorCheckAllocations, (long *)pbErrorCheck);
}

STDMETHODIMP CVCMidlAdvancedPage::put_ErrorCheckAllocations(enumErrorCheckAllocationsBOOL bErrorCheck)
{
	return SetBoolProperty(VCMIDLID_ErrorCheckAllocations, bErrorCheck);
}

STDMETHODIMP CVCMidlAdvancedPage::get_ErrorCheckBounds(enumErrorCheckBoundsBOOL* pbErrorCheck)
{	// (/error bounds_check) check size	vs. transmission length specifications
	return GetEnumBoolProperty2(VCMIDLID_ErrorCheckBounds, (long *)pbErrorCheck);
}

STDMETHODIMP CVCMidlAdvancedPage::put_ErrorCheckBounds(enumErrorCheckBoundsBOOL bErrorCheck)
{
	return SetBoolProperty(VCMIDLID_ErrorCheckBounds, bErrorCheck);
}

STDMETHODIMP CVCMidlAdvancedPage::get_ErrorCheckEnumRange(enumErrorCheckEnumRangeBOOL* pbErrorCheck)
{	// (/error enum) check enum values to be in allowable range not in docs
	return GetEnumBoolProperty2(VCMIDLID_ErrorCheckEnumRange, (long *)pbErrorCheck);
}

STDMETHODIMP CVCMidlAdvancedPage::put_ErrorCheckEnumRange(enumErrorCheckEnumRangeBOOL bErrorCheck)
{
	return SetBoolProperty(VCMIDLID_ErrorCheckEnumRange, bErrorCheck);
}

STDMETHODIMP CVCMidlAdvancedPage::get_ErrorCheckRefPointers(enumErrorCheckRefPointersBOOL* pbErrorCheck)
{	// (/error ref) check ref pointers to be non-NULL
	return GetEnumBoolProperty2(VCMIDLID_ErrorCheckRefPointers, (long *)pbErrorCheck);
}

STDMETHODIMP CVCMidlAdvancedPage::put_ErrorCheckRefPointers(enumErrorCheckRefPointersBOOL bErrorCheck)
{
	return SetBoolProperty(VCMIDLID_ErrorCheckRefPointers, bErrorCheck);
}

STDMETHODIMP CVCMidlAdvancedPage::get_ErrorCheckStubData(enumErrorCheckStubDataBOOL* pbErrorCheck)
{	// (/error stub_data) emit additional check for server side data stub validity
	return GetEnumBoolProperty2(VCMIDLID_ErrorCheckStubData, (long *)pbErrorCheck);
}

STDMETHODIMP CVCMidlAdvancedPage::put_ErrorCheckStubData(enumErrorCheckStubDataBOOL bErrorCheck)
{
	return SetBoolProperty(VCMIDLID_ErrorCheckStubData, bErrorCheck);
}

STDMETHODIMP CVCMidlAdvancedPage::get_ValidateParameters(enumValidateParametersBOOL* pbValidate)
{	// (/robust) generate additional information to validate parameters not in docs
	return GetEnumBoolProperty2(VCMIDLID_ValidateParameters, (long *)pbValidate);
}

STDMETHODIMP CVCMidlAdvancedPage::put_ValidateParameters(enumValidateParametersBOOL bValidate)
{
	return SetBoolProperty(VCMIDLID_ValidateParameters, bValidate);
}

STDMETHODIMP CVCMidlAdvancedPage::get_StructMemberAlignment(midlStructMemberAlignOption* poptSetting)
{	// see enum above (/Zp[num])
	return ToolGetIntProperty(VCMIDLID_StructMemberAlignment, &(CVCMidlTool::s_optHandler), (long *)poptSetting);
}

STDMETHODIMP CVCMidlAdvancedPage::put_StructMemberAlignment(midlStructMemberAlignOption optSetting)
{
	CHECK_BOUNDS(INHERIT_PROP_VALUE, midlStructAlignMax, optSetting);
	return SetIntProperty(VCMIDLID_StructMemberAlignment, optSetting);
}

STDMETHODIMP CVCMidlAdvancedPage::get_RedirectOutputAndErrors(BSTR* pbstrOutput)
{	// (/o file) redirect output from screen to a file
	return ToolGetStrProperty(VCMIDLID_RedirectOutputAndErrors, &(CVCMidlTool::s_optHandler), pbstrOutput);
}

STDMETHODIMP CVCMidlAdvancedPage::put_RedirectOutputAndErrors(BSTR bstrOutput)
{
	return SetStrProperty(VCMIDLID_RedirectOutputAndErrors, bstrOutput);
}

STDMETHODIMP CVCMidlAdvancedPage::get_CPreprocessOptions(BSTR* pbstrOpt)
{	// (/cpp_opt"[option]") C-compiler Advanced option to pass to MIDL.  must be in exact format for desired switches
	return ToolGetStrProperty(VCMIDLID_CPreprocessOptions, &(CVCMidlTool::s_optHandler), pbstrOpt, true /* local only */);
}

STDMETHODIMP CVCMidlAdvancedPage::put_CPreprocessOptions(BSTR bstrOpt)
{
	return SetStrProperty(VCMIDLID_CPreprocessOptions, bstrOpt);
}

STDMETHODIMP CVCMidlAdvancedPage::get_UndefinePreprocessorDefinitions(BSTR* pbstrUndefines)
{	// (/U![macro]) remove any previous definition of symbol.  can have multiple.
	return ToolGetStrProperty(VCMIDLID_UndefinePreprocessorDefinitions, &(CVCMidlTool::s_optHandler), pbstrUndefines, true /* local only */);
}

STDMETHODIMP CVCMidlAdvancedPage::put_UndefinePreprocessorDefinitions(BSTR bstrUndefines)
{
	return SetStrProperty(VCMIDLID_UndefinePreprocessorDefinitions, bstrUndefines);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\vcpb\mrdependencies.h ===
//
// Declare minimal rebuild dependencies interface.
//
// [tomse]
//

#ifndef _INCLUDE_MRDEPEND_H
#define _INCLUDE_MRDEPEND_H

#include <vccolls.h>
#include <path2.h>
#include "fileregistry.h"
#include "bldhelpers.h"

class IBldMreDependencies 
{
public:
	static IBldMreDependencies* GetMreDependenciesIFace(LPCOLESTR bstrIdbFile);
	virtual BOOL GetDependencies(LPCOLESTR szPath, CVCBuildStringCollection* pCollection, BOOL bUsePch) = 0;
	virtual BOOL GetDeploymentDependencies(LPCOLESTR szPath, CVCBuildStringCollection* pCollection) = 0;
	virtual BOOL Release() = 0;
};

// this helper class allows us to cache the IBldMreDependencies interface without having to worry about
// releasing it later (it goes away on destruction)
class CBldMreDependenciesContainer 
{
public:
	CBldMreDependenciesContainer() : m_pMrePtr(NULL)	{}
	CBldMreDependenciesContainer(CStringW& rstrIdbPath) : m_pMrePtr(NULL)
	{
		CalculateIFace(rstrIdbPath);
	}
	~CBldMreDependenciesContainer()
	{
		if (m_pMrePtr)
			m_pMrePtr->Release();
	}
	void CalculateIFace(CStringW& rstrIdbPath)
	{
		if (!rstrIdbPath.IsEmpty())
			m_pMrePtr = IBldMreDependencies::GetMreDependenciesIFace(rstrIdbPath);
	}
	static void UnloadMSPDB();
	IBldMreDependencies* m_pMrePtr;
};

#endif // _INCLUDE_MRDEPEND_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\vcpb\nmaketool.h ===
// NMakeTool.h: Definition of the CVCNMakeTool class
//
//////////////////////////////////////////////////////////////////////

#pragma once

#include "vctool.h"
#include "settingspage.h"

// constants
const wchar_t* const wszNMakeDefaultExtensions = L"";	// remember to update vcpb.rgs if you change this...

// classes in this header
class CVCNMakeTool;

/////////////////////////////////////////////////////////////////////////////
// CVCNMakeTool

class ATL_NO_VTABLE CVCNMakeTool : 
	public IDispatchImpl<VCNMakeTool, &IID_VCNMakeTool, &LIBID_VCProjectEngineLibrary, PublicProjBuildTypeLibNumber,0, CVsTypeInfoHolder>, 
	public CVCToolImpl,
	public CComObjectRoot
{
public:
	CVCNMakeTool() 
	{
		m_nLowKey = VCNMAKETOOL_MIN_DISPID;
		m_nHighKey = VCNMAKETOOL_MAX_DISPID;
		m_nDirtyKey = VCNMAKEID_CmdLineOptionsDirty;
		m_nDirtyOutputsKey = VCNMAKEID_OutputsDirty;
	}
	static HRESULT CreateInstance(IVCPropertyContainer* pPropContainer, IVCToolImpl** ppTool);

BEGIN_COM_MAP(CVCNMakeTool)
 	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IVCToolImpl)
	COM_INTERFACE_ENTRY(VCNMakeTool)
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE(CVCNMakeTool) 

// VCNMakeTool
public:
	// General
	STDMETHOD(get_ToolName)(BSTR* pbstrToolName);	// friendly name of tool, e.g., "C/C++ Compiler Tool"
	STDMETHOD(get_BuildCommandLine)(BSTR *pbstrCommandLine);
	STDMETHOD(put_BuildCommandLine)(BSTR bstrCommandLine);
	STDMETHOD(get_ReBuildCommandLine)(BSTR *pbstrCommandLine);
	STDMETHOD(put_ReBuildCommandLine)(BSTR bstrCommandLine);
	STDMETHOD(get_CleanCommandLine)(BSTR *pbstrCommandLine);
	STDMETHOD(put_CleanCommandLine)(BSTR bstrCommandLine);
	STDMETHOD(get_Output)(BSTR *pbstrOutput);
	STDMETHOD(put_Output)(BSTR bstrOutput);
	
	// Automation properties
	STDMETHOD(get_ToolPath)(BSTR *pbstrToolPath);
	STDMETHOD(get_VCProjectEngine)(IDispatch** projEngine)	{ return DoGetVCProjectEngine(projEngine); }

// IVCToolImpl
public:
	STDMETHOD(get_DefaultExtensions)(BSTR* pVal);
	STDMETHOD(put_DefaultExtensions)(BSTR newVal);
	STDMETHOD(GetAdditionalOptionsInternal)(IUnknown* pItem, VARIANT_BOOL bForBuild, VARIANT_BOOL bSkipLocal, BSTR* pbstrOptions);
	STDMETHOD(GetBuildDescription)(IVCBuildAction* pAction, BSTR* pbstrBuildDescription);
	STDMETHOD(get_ToolPathInternal)(BSTR* pbstrToolPath);
	STDMETHOD(get_Bucket)(long *pVal);
	STDMETHOD(GetCommandLineEx)(IVCBuildAction*,IVCBuildableItem* pBuildableItem, IVCBuildEngine* pBuildEngine, 
		IVCBuildErrorContext* pEC, BSTR* bstrCmd);
	STDMETHOD(GetCleanCommandLineEx)(IVCBuildAction*,IVCBuildableItem* pBuildableItem, IVCBuildEngine* pBuildEngine, 
		IVCBuildErrorContext* pEC, BSTR* bstrCmd);
	STDMETHOD(GetRebuildCommandLineEx)(IVCBuildAction*,IVCBuildableItem* pBuildableItem, IVCBuildEngine* pBuildEngine, 
		IVCBuildErrorContext* pEC, BSTR* bstrCmd);
	STDMETHOD(IsTargetTool)(IVCBuildAction* pAction, VARIANT_BOOL* pbTargetTool);
	STDMETHOD(GenerateOutput)(long type, IVCBuildActionList* plstActions, IVCBuildErrorContext* pEC);
	STDMETHOD(CreateToolObject)(IVCPropertyContainer* pPropContainer, IVCToolImpl** ppToolObject)
		{ return CreateInstance(pPropContainer, ppToolObject); }
	STDMETHOD(get_ToolShortName)(BSTR* pbstrToolName);
	STDMETHOD(get_ToolNameInternal)(BSTR* pbstrToolName) { return get_ToolName(pbstrToolName); }
	STDMETHOD(MatchName)(BSTR bstrName, VARIANT_BOOL bFullOnly, VARIANT_BOOL* pbMatches);
	STDMETHOD(get_IsComspecTool)(VARIANT_BOOL* pbIsComspecTool);
	STDMETHOD(SaveObject)(IStream *xml, IVCPropertyContainer *pPropCnt, long nIndent);
	STDMETHOD(get_ToolDisplayIndex)(long* pIndex);
	STDMETHOD(AffectsOutput)(long nPropID, VARIANT_BOOL* pbAffectsOutput);
	STDMETHOD(HasPrimaryOutputFromTool)(IUnknown* pItem, VARIANT_BOOL bSchmoozeOnly, VARIANT_BOOL* pbHasPrimaryOutput);	// returns TRUE only if tool generates a primary output (ex: linker)
	STDMETHOD(GetPrimaryOutputFromTool)(IUnknown* pItem, VARIANT_BOOL bSchmoozeOnly, BSTR* pbstrPath);	// return a value only if tool generates a primary output (ex: linker)
	STDMETHOD(GetPrimaryOutputIDFromTool)(IUnknown* pItem, VARIANT_BOOL bSchmoozeOnly, long* pnOutputID);	// return a value only if tool generates a primary output (ex: linker)
	STDMETHOD(CreatePageObject)(IUnknown **, CLSID*, IVCPropertyContainer *, IVCSettingsPage * );

	virtual long GetPageCount()	{ return 1; }
	virtual GUID* GetPageIDs();

protected:
	void AddSaveLine(IStream *xml, IVCPropertyContainer* pPropContainer, LPOLESTR bszPropertyName, long nPropertyID);
	virtual LPCOLESTR GetToolFriendlyName();
	void InitToolName();
	virtual long GetToolID() { return IDS_NMake; }

protected:
	static GUID s_pPages[1];
	static BOOL s_bPagesInit;
 	static CComBSTR s_bstrDescription;
 	static CComBSTR s_bstrToolName;
	static CComBSTR s_bstrExtensions;
};

class ATL_NO_VTABLE CVCNMakePage :
	public IDispatchImpl<IVCNMakePage, &IID_IVCNMakePage, &LIBID_VCProjectEnginePrivateLibrary, PrivateProjBuildTypeLibNumber,0, CVsTypeInfoHolder>,
	public CPageObjectImpl<CVCNMakePage,VCNMAKETOOL_MIN_DISPID,VCNMAKETOOL_MAX_DISPID>,
	public CComObjectRoot
{
public:

BEGIN_COM_MAP(CVCNMakePage)
	COM_INTERFACE_ENTRY(IPerPropertyBrowsing)
	COM_INTERFACE_ENTRY(IVsPerPropertyBrowsing)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IVCNMakePage)
	COM_INTERFACE_ENTRY(IVCPropertyContainer)
	COM_INTERFACE_ENTRY(IProvidePropertyBuilder)
END_COM_MAP()

	// IDispatch override
	STDMETHOD(Invoke)( DISPID dispid, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS *pdispParams, VARIANT *pvarResult, EXCEPINFO *pexcepInfo, UINT *puArgErr )
	{
		IDispatchImpl<IVCNMakePage, &IID_IVCNMakePage, &LIBID_VCProjectEnginePrivateLibrary, PrivateProjBuildTypeLibNumber,0, CVsTypeInfoHolder>::Invoke( dispid, riid, lcid, wFlags, pdispParams, pvarResult, pexcepInfo, puArgErr );
		return S_OK;
	}

	STDMETHOD(HasDefaultValue)( DISPID dispid, BOOL *pfDefault)
	{
		CHECK_POINTER_NULL(pfDefault);
		*pfDefault = TRUE;
		return S_OK;
	}

// IVCNMakePage
public:
	STDMETHOD(get_BuildCommandLine)(BSTR *pVal);
	STDMETHOD(put_BuildCommandLine)(BSTR newVal);
	STDMETHOD(get_ReBuildCommandLine)(BSTR *pVal);
	STDMETHOD(put_ReBuildCommandLine)(BSTR newVal);
	STDMETHOD(get_CleanCommandLine)(BSTR *pVal);
	STDMETHOD(put_CleanCommandLine)(BSTR newVal);
	STDMETHOD(get_Output)(BSTR *pVal);
	STDMETHOD(put_Output)(BSTR newVal);

protected:
	virtual BOOL UseCommandsDialog(long id) 
		{ return (id == VCNMAKEID_BuildCommandLine || id == VCNMAKEID_ReBuildCommandLine || id == VCNMAKEID_CleanCommandLine ); }
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\vcpb\Platform.cpp ===
#include "stdafx.h"
#include "Platform.h"
#include "projwriter.h"
#include "regscan.h"
#include "profile.h"
// tool includes
#include "bsctool.h"
#include "bldeventtool.h"
#include "cltool.h"
#include "custombuildtool.h"
#include "DeployTool.h"
#include "libtool.h"
#include "linktool.h"
#include "midltool.h"
#include "nmaketool.h"
#include "rctool.h"
#include "sdltool.h"
#include "util2.h"

const wchar_t* const PLATFORM_NAME_WIN32 = L"Win32";
const wchar_t* const PLATFORM_NAME_WIN64 = L"Win64";

CVCStringWList CPlatformWin32::s_strToolsExcludeList[5];
CVCStringWList CPlatformWin64::s_strToolsExcludeList[5];

/////////////////////////////////////////////////////////////////////////////
//

STDMETHODIMP CPlatformWin32::Initialize( void )
{
	// create instance each of the tools for this platform
	// an add each of them to the tool collection
	HRESULT hr;

	CComBSTR bstrMainKey;
	CVCProjectEngine::GetBasePlatformInfoKey(&bstrMainKey);
	bstrMainKey.Append(L"\\");
	bstrMainKey.Append(PLATFORM_NAME_WIN32);

	CComBSTR bstrExtKey;
	bstrExtKey = bstrMainKey + L"\\ToolDefaultExtensionLists";

	CComPtr<IVCToolImpl> pTool;
	// VCBscMakeTool
	hr = CVCBscMakeTool::CreateInstance( NULL, &pTool);
	ADD_TOOL(hr, pTool, m_rgTools, bstrExtKey, szBscMakeToolShortName);

	// VCCLCompilerTool
	hr = CVCCLCompilerTool::CreateInstance( NULL, &pTool );
	ADD_TOOL(hr, pTool, m_rgTools, bstrExtKey, szCLCompilerToolShortName);

	// VCCustomBuildTool
	hr = CVCCustomBuildTool::CreateInstance( NULL, &pTool );
	ADD_TOOL(hr, pTool, m_rgTools, bstrExtKey, szCustomBuildToolShortName);

	// VCLibrarianTool
	hr = CVCLibrarianTool::CreateInstance( NULL, &pTool );
	ADD_TOOL(hr, pTool, m_rgTools, bstrExtKey, szLibrarianToolShortName);

	// VCLinkerTool
	hr = CVCLinkerTool::CreateInstance( NULL, &pTool );
	ADD_TOOL(hr, pTool, m_rgTools, bstrExtKey, szLinkerToolShortName);

	// VCMIDLTool
	hr = CVCMidlTool::CreateInstance( NULL, &pTool );
	ADD_TOOL(hr, pTool, m_rgTools, bstrExtKey, szMidlToolShortName);

	// VCNMakeTool
	hr = CVCNMakeTool::CreateInstance( NULL, &pTool );
	ADD_TOOL(hr, pTool, m_rgTools, bstrExtKey, szNMakeToolShortName);

	// VCPostBuildEventTool
	hr = CVCPostBuildEventTool::CreateInstance( NULL, &pTool );
	ADD_TOOL(hr, pTool, m_rgTools, bstrExtKey, szPostBuildEventToolShortName);

	// VCPreBuildEventTool
	hr = CVCPreBuildEventTool::CreateInstance( NULL, &pTool );
	ADD_TOOL(hr, pTool, m_rgTools, bstrExtKey, szPreBuildEventToolShortName);

	// VCPreLinkEventTool
	hr = CVCPreLinkEventTool::CreateInstance( NULL, &pTool );
	ADD_TOOL(hr, pTool, m_rgTools, bstrExtKey, szPreLinkEventToolShortName);

	// VCResourceCompilerTool
	hr = CVCResourceCompilerTool::CreateInstance( NULL, &pTool );
	ADD_TOOL(hr, pTool, m_rgTools, bstrExtKey, szResourceCompilerToolShortName);

	// VCWebServiceProxyGeneratorTool
	hr = CVCWebServiceProxyGeneratorTool::CreateInstance( NULL, &pTool );
	ADD_TOOL(hr, pTool, m_rgTools, bstrExtKey, szWebToolShortName);

	// VCWebDeploymentTool
	hr = CVCWebDeploymentTool::CreateInstance( NULL, &pTool );
	ADD_TOOL(hr, pTool, m_rgTools, bstrExtKey, szDeployToolShortName);

	// get the environment variables for the platform parameters
	CComBSTR bstrPath;
	VCGetEnvironmentVariableW(L"PATH", &bstrPath);
	put_ExecutableDirectories(bstrPath);

	CComBSTR bstrInc;
	VCGetEnvironmentVariableW(L"INCLUDE", &bstrInc);
	put_IncludeDirectories(bstrInc);

	CComBSTR bstrRef;
	VCGetEnvironmentVariableW(L"LIBPATH", &bstrRef);
	put_ReferenceDirectories(bstrRef);

	CComBSTR bstrLib;
	VCGetEnvironmentVariableW(L"LIB", &bstrLib);
	put_LibraryDirectories(bstrLib);

	CComBSTR bstrSrc;
	VCGetEnvironmentVariableW(L"SOURCE", &bstrSrc);
	put_SourceDirectories(bstrSrc);

	// These are set up as exclusion lists so that we don't have to special case any user-defined tools later.
	// Also makes for a shorter hunt through the list for the most common cases to see if we should be adding
	// the tool or not.  :-)

	s_strToolsExcludeList[toolSetUtility].AddTail(szBscMakeToolShortName);
	s_strToolsExcludeList[toolSetUtility].AddTail(szResourceCompilerToolShortName);
	s_strToolsExcludeList[toolSetUtility].AddTail(szCLCompilerToolShortName);
	s_strToolsExcludeList[toolSetUtility].AddTail(szPreLinkEventToolShortName);
	s_strToolsExcludeList[toolSetUtility].AddTail(szLinkerToolShortName);
	s_strToolsExcludeList[toolSetUtility].AddTail(szLibrarianToolShortName);
 	s_strToolsExcludeList[toolSetUtility].AddTail(szNMakeToolShortName);
 	s_strToolsExcludeList[toolSetUtility].AddTail(szWebToolShortName);
 	s_strToolsExcludeList[toolSetUtility].AddTail(szDeployToolShortName);

	s_strToolsExcludeList[toolSetMakefile].AddTail(szBscMakeToolShortName);
	s_strToolsExcludeList[toolSetMakefile].AddTail(szMidlToolShortName);
	s_strToolsExcludeList[toolSetMakefile].AddTail(szResourceCompilerToolShortName);
	s_strToolsExcludeList[toolSetMakefile].AddTail(szCLCompilerToolShortName);
	s_strToolsExcludeList[toolSetMakefile].AddTail(szPreLinkEventToolShortName);
	s_strToolsExcludeList[toolSetMakefile].AddTail(szLinkerToolShortName);
	s_strToolsExcludeList[toolSetMakefile].AddTail(szLibrarianToolShortName);
	s_strToolsExcludeList[toolSetMakefile].AddTail(szPreBuildEventToolShortName);
	s_strToolsExcludeList[toolSetMakefile].AddTail(szPostBuildEventToolShortName);
	s_strToolsExcludeList[toolSetMakefile].AddTail(szCustomBuildToolShortName);
 	s_strToolsExcludeList[toolSetMakefile].AddTail(szWebToolShortName);
 	s_strToolsExcludeList[toolSetMakefile].AddTail(szDeployToolShortName);

	s_strToolsExcludeList[toolSetLinker].AddTail(szLibrarianToolShortName);
 	s_strToolsExcludeList[toolSetLinker].AddTail(szNMakeToolShortName);

	s_strToolsExcludeList[toolSetLibrarian].AddTail(szLinkerToolShortName);
 	s_strToolsExcludeList[toolSetLibrarian].AddTail(szNMakeToolShortName);
 	s_strToolsExcludeList[toolSetLibrarian].AddTail(szDeployToolShortName);

	// nothing whatsoever is excluded for toolSetAll

	// now, let's add any vendor tools that have been registered with us
	/*
	Registry looks something like this:
	HKEY_LOCAL_MACHINE\ ... \VC_OBJECTS_PLATFORM_INFO
		Win32 (with default prop = guid)
			directories
				<inc, exe, lib directories>
			Vendor Tools
				vendor tool short name (with default prop = guid)
					<any excluded configs>
	*/

	if( UsingRegistry() )
	{
		CComBSTR bstrToolsSubKey = bstrMainKey;
		bstrToolsSubKey += L"\\VendorTools";

		CRegistryScanner RegScannerTools;
		if (!RegScannerTools.Open(HKEY_LOCAL_MACHINE, bstrToolsSubKey))
			return S_OK;	// nothing to do if no reg key
	
	
		// Now Add In VendorTools
		CComQIPtr<IVCProjectEngineImpl> spProjEngineImpl;
		spProjEngineImpl = g_pProjectEngine;
		if (spProjEngineImpl == NULL)
			return E_UNEXPECTED;

		CStringW strToolBaseKey;
		strToolBaseKey = bstrToolsSubKey;
		strToolBaseKey += L"\\";

		CComPtr<IDispatch> spDispTools;
		CComQIPtr<IVCCollection> spVendorTools;
		hr = spProjEngineImpl->get_VendorTools(&spDispTools);
		spVendorTools = spDispTools;
		RETURN_ON_FAIL_OR_NULL2(hr, spVendorTools, E_UNEXPECTED);

		CComBSTR bstrToolName;
		while (RegScannerTools.EnumKey(&bstrToolName))

		{	
			CComPtr<IDispatch> spDispBaseTool;
			hr = spVendorTools->Item(CComVariant(bstrToolName), &spDispBaseTool);
			if (spDispBaseTool == NULL)	// not already present
			{
				CComBSTR bstrToolGUID;
				if (!RegScannerTools.GetValue(L"\0", &bstrToolGUID))
					return E_UNEXPECTED;
				hr = spProjEngineImpl->AddVendorTool(bstrToolName, bstrToolGUID, &spDispBaseTool);
			}
			RETURN_ON_NULL2(spDispBaseTool, E_UNEXPECTED);
	
			pTool = spDispBaseTool;
			ADD_TOOL2(hr, pTool, m_rgTools);
	
			CStringW strKey = strToolBaseKey;
			strKey += bstrToolName;

			s_strToolsExcludeList[toolSetMakefile].AddTail(bstrToolName);	// nobody gets to add tools here - everything excluded.

			CComBSTR bstrVal;
			hr = GetRegStringW(strKey, L"Include_toolSetUtility", &bstrVal);
			if ( hr == S_OK )	// this is an inclusion element, so element needs to be PRESENT to not be excluded
				s_strToolsExcludeList[toolSetUtility].AddTail(bstrToolName);

			bstrVal.Empty();
			hr = GetRegStringW(strKey, L"Exclude_toolSetLinker", &bstrVal);
			if ( hr == S_OK )	// this is an inclusion element, so element needs to be PRESENT to not be excluded
				s_strToolsExcludeList[toolSetLinker].AddTail(bstrToolName);

			bstrVal.Empty();
			hr = GetRegStringW(strKey, L"Exclude_toolSetLibrarian", &bstrVal);
			if ( hr == S_OK )	// this is an inclusion element, so element needs to be PRESENT to not be excluded
				s_strToolsExcludeList[toolSetLibrarian].AddTail(bstrToolName);
		}
	}
	return S_OK;
}

STDMETHODIMP CPlatformWin32::SaveObject(IStream *xml, IVCPropertyContainer *pPropCnt, long nIndent)
{
	// Name
	NodeAttribute( xml, CComBSTR( L"Name" ), CComBSTR( PLATFORM_NAME_WIN32 ) );
	
	// end of attributes, start children
	EndNodeHeader( xml, false );

	return S_OK;
}

STDMETHODIMP CPlatformWin32::MatchName(BSTR bstrNameToMatch, VARIANT_BOOL bFullOnly, VARIANT_BOOL *pbMatched)
{
	CHECK_POINTER_VALID(pbMatched);
	*pbMatched = VARIANT_FALSE;
	if( bstrNameToMatch && _wcsicmp( PLATFORM_NAME_WIN32, bstrNameToMatch ) == 0 )
	{
		*pbMatched = VARIANT_TRUE;
	}
	return S_OK;
}

STDMETHODIMP CPlatformWin32::get_Name(/*[out, retval]*/ BSTR *pVal)
{
	CComBSTR bstrName( PLATFORM_NAME_WIN32 );
	*pVal = bstrName.Detach();
	return S_OK;
}

// IVCPlatformImpl
STDMETHODIMP CPlatformWin32::IsToolInToolset(toolSetType listStyle, IVCToolImpl* pTool, VARIANT_BOOL* pbInToolset)
{
	CHECK_POINTER_NULL(pbInToolset);
	*pbInToolset = VARIANT_FALSE;

	if (!pTool)
		return S_FALSE;

	CComBSTR bstrToolName;
	if (FAILED(pTool->get_ToolShortName(&bstrToolName)))
	{
		VSASSERT(FALSE, "*All* tools are supposed to have a short name.");
		return S_FALSE;
	}

	CStringW strToolName = bstrToolName;
	if (strToolName.IsEmpty())
	{
		VSASSERT(FALSE, "*All* tools are supposed to have a short name.");
		return S_FALSE;
	}

	*pbInToolset = (!s_strToolsExcludeList[listStyle].Find(strToolName));
	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//

STDMETHODIMP CPlatformWin64::Initialize( void )
{
	// create instance each of the tools for this platform
	// and add each of them to the tool collection
	HRESULT hr;
	CComPtr<IVCToolImpl> pTool;
	CComBSTR bstrMainKey;
	CVCProjectEngine::GetBasePlatformInfoKey(&bstrMainKey);
	bstrMainKey.Append(L"\\");
	bstrMainKey.Append(PLATFORM_NAME_WIN64);

	CComBSTR bstrSubKey;

	CComBSTR bstrExtKey;
	bstrExtKey = bstrMainKey + L"\\ToolDefaultExtensionLists";

	// VCBscMakeTool
	hr = CVCBscMakeTool::CreateInstance( NULL, &pTool );
	ADD_TOOL(hr, pTool, m_rgTools, bstrExtKey, szBscMakeToolShortName);

	// VCCLCompilerTool
	hr = CVCCLCompilerTool::CreateInstance( NULL, &pTool );
	ADD_TOOL(hr, pTool, m_rgTools, bstrExtKey, szCLCompilerToolShortName);

	// VCCustomBuildTool
	hr = CVCCustomBuildTool::CreateInstance( NULL, &pTool );
	ADD_TOOL(hr, pTool, m_rgTools, bstrExtKey, szCustomBuildToolShortName);

	// VCLibrarianTool
	hr = CVCLibrarianTool::CreateInstance( NULL, &pTool );
	ADD_TOOL(hr, pTool, m_rgTools, bstrExtKey, szLibrarianToolShortName);

	// VCLinkerTool
	hr = CVCLinkerTool::CreateInstance( NULL, &pTool );
	ADD_TOOL(hr, pTool, m_rgTools, bstrExtKey, szLinkerToolShortName);

	// VCMIDLTool
	hr = CVCMidlTool::CreateInstance( NULL, &pTool );
	ADD_TOOL(hr, pTool, m_rgTools, bstrExtKey, szMidlToolShortName);

	// VCNMakeTool
	hr = CVCNMakeTool::CreateInstance( NULL, &pTool );
	ADD_TOOL(hr, pTool, m_rgTools, bstrExtKey, szNMakeToolShortName);

	// VCPostBuildEventTool
	hr = CVCPostBuildEventTool::CreateInstance( NULL, &pTool );
	ADD_TOOL(hr, pTool, m_rgTools, bstrExtKey, szPostBuildEventToolShortName);

	// VCPreBuildEventTool
	hr = CVCPreBuildEventTool::CreateInstance( NULL, &pTool );
	ADD_TOOL(hr, pTool, m_rgTools, bstrExtKey, szPreBuildEventToolShortName);

	// VCPreLinkEventTool
	hr = CVCPreLinkEventTool::CreateInstance( NULL, &pTool );
	ADD_TOOL(hr, pTool, m_rgTools, bstrExtKey, szPreLinkEventToolShortName);

	// VCResourceCompilerTool
	hr = CVCResourceCompilerTool::CreateInstance( NULL, &pTool );
	ADD_TOOL(hr, pTool, m_rgTools, bstrExtKey, szResourceCompilerToolShortName);

	// VCWebServiceProxyGeneratorTool
	hr = CVCWebServiceProxyGeneratorTool::CreateInstance( NULL, &pTool );
	ADD_TOOL(hr, pTool, m_rgTools, bstrExtKey, szWebToolShortName);

	// VCWebDeploymentTool
	hr = CVCWebDeploymentTool::CreateInstance( NULL, &pTool );
	ADD_TOOL(hr, pTool, m_rgTools, bstrExtKey, szDeployToolShortName);

	// These are set up as exclusion lists so that we don't have to special case any user-defined tools later.
	// Also makes for a shorter hunt through the list for the most common cases to see if we should be adding
	// the tool or not.  :-)

	s_strToolsExcludeList[toolSetUtility].AddTail(szBscMakeToolShortName);
	s_strToolsExcludeList[toolSetUtility].AddTail(szResourceCompilerToolShortName);
	s_strToolsExcludeList[toolSetUtility].AddTail(szCLCompilerToolShortName);
	s_strToolsExcludeList[toolSetUtility].AddTail(szPreLinkEventToolShortName);
	s_strToolsExcludeList[toolSetUtility].AddTail(szLinkerToolShortName);
	s_strToolsExcludeList[toolSetUtility].AddTail(szLibrarianToolShortName);
 	s_strToolsExcludeList[toolSetUtility].AddTail(szNMakeToolShortName);
 	s_strToolsExcludeList[toolSetUtility].AddTail(szWebToolShortName);
 	s_strToolsExcludeList[toolSetUtility].AddTail(szDeployToolShortName);

	s_strToolsExcludeList[toolSetMakefile].AddTail(szBscMakeToolShortName);
	s_strToolsExcludeList[toolSetMakefile].AddTail(szMidlToolShortName);
	s_strToolsExcludeList[toolSetMakefile].AddTail(szResourceCompilerToolShortName);
	s_strToolsExcludeList[toolSetMakefile].AddTail(szCLCompilerToolShortName);
	s_strToolsExcludeList[toolSetMakefile].AddTail(szPreLinkEventToolShortName);
	s_strToolsExcludeList[toolSetMakefile].AddTail(szLinkerToolShortName);
	s_strToolsExcludeList[toolSetMakefile].AddTail(szLibrarianToolShortName);
	s_strToolsExcludeList[toolSetMakefile].AddTail(szPreBuildEventToolShortName);
	s_strToolsExcludeList[toolSetMakefile].AddTail(szPostBuildEventToolShortName);
	s_strToolsExcludeList[toolSetMakefile].AddTail(szCustomBuildToolShortName);
 	s_strToolsExcludeList[toolSetMakefile].AddTail(szWebToolShortName);
 	s_strToolsExcludeList[toolSetMakefile].AddTail(szDeployToolShortName);

	s_strToolsExcludeList[toolSetLinker].AddTail(szLibrarianToolShortName);
 	s_strToolsExcludeList[toolSetLinker].AddTail(szNMakeToolShortName);

	s_strToolsExcludeList[toolSetLibrarian].AddTail(szLinkerToolShortName);
 	s_strToolsExcludeList[toolSetLibrarian].AddTail(szNMakeToolShortName);
 	s_strToolsExcludeList[toolSetLibrarian].AddTail(szDeployToolShortName);

	// get the environment variables for the platform parameters
	// get the environment variables for the platform parameters
	CComBSTR bstrPath;
	VCGetEnvironmentVariableW(L"PATH", &bstrPath);
	put_ExecutableDirectories(bstrPath);

	CComBSTR bstrInc;
	VCGetEnvironmentVariableW(L"INCLUDE", &bstrInc);
	put_IncludeDirectories(bstrInc);

	CComBSTR bstrRef;
	VCGetEnvironmentVariableW(L"LIBPATH", &bstrRef);
	put_IncludeDirectories(bstrRef);

	CComBSTR bstrLib;
	VCGetEnvironmentVariableW(L"LIB", &bstrLib);
	put_LibraryDirectories(bstrLib);

	CComBSTR bstrSrc;
	VCGetEnvironmentVariableW(L"SOURCE", &bstrSrc);
	put_SourceDirectories(bstrSrc);

	// nothing whatsoever is excluded for toolSetAll

	// now, let's add any vendor tools that have been registered with us
	/*
	Registry looks something like this:
	HKEY_LOCAL_MACHINE\ ... \VC_OBJECTS_PLATFORM_INFO
		Win64 (with default prop = guid)
			directories
				<inc, exe, lib directories>
			Vendor Tools
				vendor tool short name (with default prop = guid)
					<any excluded configs>
	*/


	CComBSTR bstrToolsSubKey = bstrMainKey;
	bstrToolsSubKey.Append( L"\\VendorTools" );

	CRegistryScanner RegScannerTools;
	if (!RegScannerTools.Open(HKEY_LOCAL_MACHINE, bstrToolsSubKey))
		return S_OK;	// nothing to do if no reg key

	CComQIPtr<IVCProjectEngineImpl> spProjEngineImpl;
	spProjEngineImpl = g_pProjectEngine;
	if (spProjEngineImpl == NULL)
		return E_UNEXPECTED;

	CStringW strToolBaseKey;
	strToolBaseKey = bstrToolsSubKey;
	strToolBaseKey += L"\\";

	CComPtr<IDispatch> spDispTools;
	CComQIPtr<IVCCollection> spVendorTools;
	hr = spProjEngineImpl->get_VendorTools(&spDispTools);
	spVendorTools = spDispTools;
	RETURN_ON_FAIL_OR_NULL2(hr, spVendorTools, E_UNEXPECTED);

	CComBSTR bstrToolName;

	while (RegScannerTools.EnumKey(&bstrToolName))
	{
		CComPtr<IDispatch> spDispBaseTool;
		hr = spVendorTools->Item(CComVariant(bstrToolName), &spDispBaseTool);
		if (spDispBaseTool == NULL)	// not already present
		{
			CComBSTR bstrToolGUID;
			if (!RegScannerTools.GetValue(L"\0", &bstrToolGUID))
				return E_UNEXPECTED;
			hr = spProjEngineImpl->AddVendorTool(bstrToolName, bstrToolGUID, &spDispBaseTool);
		}
		RETURN_ON_NULL2(spDispBaseTool, E_UNEXPECTED);

		pTool = spDispBaseTool;
		ADD_TOOL2(hr, pTool, m_rgTools);

		CStringW strKey = strToolBaseKey;
		strKey += bstrToolName;

		s_strToolsExcludeList[toolSetMakefile].AddTail(bstrToolName);	// nobody gets to add tools here - everything excluded.

		CComBSTR bstrVal;
		hr = GetRegStringW(strKey, L"Include_toolSetUtility", &bstrVal);
		if ( hr == S_OK )	// this is an inclusion element, so element needs to be PRESENT to not be excluded
			s_strToolsExcludeList[toolSetUtility].AddTail(bstrToolName);

		bstrVal.Empty();
		hr = GetRegStringW(strKey, L"Exclude_toolSetLinker", &bstrVal);
		if ( hr == S_OK )	// this is an inclusion element, so element needs to be PRESENT to not be excluded
			s_strToolsExcludeList[toolSetLinker].AddTail(bstrToolName);

		bstrVal.Empty();
		hr = GetRegStringW(strKey, L"Exclude_toolSetLibrarian", &bstrVal);
		if ( hr == S_OK )	// this is an inclusion element, so element needs to be PRESENT to not be excluded
			s_strToolsExcludeList[toolSetLibrarian].AddTail(bstrToolName);
	}
	return S_OK;
}

STDMETHODIMP CPlatformWin64::SaveObject(IStream *xml, IVCPropertyContainer *pPropCnt, long nIndent)
{
	// Name
	NodeAttribute( xml, CComBSTR( L"Name" ), CComBSTR( PLATFORM_NAME_WIN64 ) );
	
	// end of attributes, start children
	EndNodeHeader( xml, false );

	return S_OK;
}

STDMETHODIMP CPlatformWin64::MatchName(BSTR bstrNameToMatch, VARIANT_BOOL bFullOnly, VARIANT_BOOL *pbMatched)
{
	CHECK_POINTER_VALID(pbMatched);
	*pbMatched = VARIANT_FALSE;
	if( bstrNameToMatch && _wcsicmp( PLATFORM_NAME_WIN64, bstrNameToMatch ) == 0 )
	{
		*pbMatched = VARIANT_TRUE;
	}
	return S_OK;
}

STDMETHODIMP CPlatformWin64::get_Name(/*[out, retval]*/ BSTR *pVal)
{
	CComBSTR bstrName( PLATFORM_NAME_WIN64 );
	*pVal = bstrName.Detach();
	return S_OK;
}

// IVCPlatformImpl
STDMETHODIMP CPlatformWin64::IsToolInToolset(toolSetType listStyle, IVCToolImpl* pTool, VARIANT_BOOL* pbInToolset)
{
	CHECK_POINTER_NULL(pbInToolset);
	*pbInToolset = VARIANT_FALSE;

	if (!pTool)
		return S_FALSE;

	CComBSTR bstrToolName;
	if (FAILED(pTool->get_ToolShortName(&bstrToolName)))
	{
		VSASSERT(FALSE, "*All* tools are supposed to have a short name.");
		return S_FALSE;
	}

	CStringW strToolName = bstrToolName;
	if (strToolName.IsEmpty())
	{
		VSASSERT(FALSE, "*All* tools are supposed to have a short name.");
		return S_FALSE;
	}

	*pbInToolset = (!s_strToolsExcludeList[listStyle].Find(strToolName));
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\vcpb\Platform.h ===
// Platform.h: Definition of the CBasePlatform, CPlatformWin32, and CPlatformWin64 classes
//
//////////////////////////////////////////////////////////////////////

#pragma once

#include "vccolls.h"
#include "comlist.h"
#include "collection.h"

/////////////////////////////////////////////////////////////////////////////
// CBasePlatform
template <class TClass, const CLSID* TPClsid>
class CBasePlatform : 
	public IDispatchImpl<VCPlatform, &__uuidof(VCPlatform), &LIBID_VCProjectEngineLibrary, PublicProjBuildTypeLibNumber,0, CVsTypeInfoHolder>, 
	public IVCPlatformImpl,
	public CComObjectRoot,
	public CComCoClass<TClass, TPClsid>
{
public:
	CBasePlatform() {}
	~CBasePlatform() {}

BEGIN_COM_MAP(TClass)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(VCPlatform)
	COM_INTERFACE_ENTRY(IVCPlatformImpl)
END_COM_MAP()
//DECLARE_NOT_AGGREGATABLE(TClass) 
// Remove the comment from the line above if you don't want your object to 
// support aggregation. 

public:
	CComBSTR m_bstrExecPath;
	CComBSTR m_bstrIncPath;
	CComBSTR m_bstrRefPath;
	CComBSTR m_bstrLibPath;
	CComBSTR m_bstrSrcPath;

//data
protected:
	CComDynamicListTyped<IVCToolImpl> m_rgTools; // collection of Tools. 

// VCPlatform
public:
//	STDMETHOD(get_Name)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(get_Tools)(/*[out, retval]*/  IDispatch ** ppVal)
	{
		CHECK_POINTER_VALID(ppVal);
		CComPtr<IVCCollection> pCollection;

		HRESULT hr = CCollection<IVCToolImpl>::CreateInstance(&pCollection, &m_rgTools);
		if (SUCCEEDED(hr))
			hr = pCollection.QueryInterface(ppVal);
		return hr;
	}
//	STDMETHOD(MatchName)(BSTR bstrNameToMatch, VARIANT_BOOL bFullOnly, VARIANT_BOOL *pbMatched);

	STDMETHOD(get_ExecutableDirectories)(/*[out, retval]*/ BSTR *pVal)
	{
		return m_bstrExecPath.CopyTo(pVal);
	}
	STDMETHOD(put_ExecutableDirectories)(/*[in]*/ BSTR newVal)
	{
		StripQuotesAndSetValue(newVal, m_bstrExecPath);
		return S_OK;
	}
	STDMETHOD(get_IncludeDirectories)(/*[out, retval]*/ BSTR *pVal)
	{
		return m_bstrIncPath.CopyTo(pVal);
	}
	STDMETHOD(put_IncludeDirectories)(/*[in]*/ BSTR newVal)
	{
		StripQuotesAndSetValue(newVal, m_bstrIncPath);
		return S_OK;
	}
	STDMETHOD(get_ReferenceDirectories)(/*[out, retval]*/ BSTR *pVal)
	{
		return m_bstrRefPath.CopyTo(pVal);
	}
	STDMETHOD(put_ReferenceDirectories)(/*[in]*/ BSTR newVal)
	{
		StripQuotesAndSetValue(newVal, m_bstrRefPath);
		return S_OK;
	}
	STDMETHOD(get_LibraryDirectories)(/*[out, retval]*/ BSTR *pVal)
	{
		return m_bstrLibPath.CopyTo(pVal);
	}
	STDMETHOD(put_LibraryDirectories)(/*[in]*/ BSTR newVal)
	{
		StripQuotesAndSetValue(newVal, m_bstrLibPath);
		return S_OK;
	}
	STDMETHOD(get_SourceDirectories)(/*[out, retval]*/ BSTR *pVal)
	{
		return m_bstrSrcPath.CopyTo(pVal);
	}
	STDMETHOD(put_SourceDirectories)(/*[in]*/ BSTR newVal)
	{
		StripQuotesAndSetValue(newVal, m_bstrSrcPath);
		return S_OK;
	}
	STDMETHOD(get_VCProjectEngine)(IDispatch** projEngine)
	{ 
		CHECK_POINTER_VALID(projEngine);
		RETURN_ON_NULL(g_pProjectEngine);
		return g_pProjectEngine->QueryInterface(IID_IDispatch, (void **)projEngine);
	}
	STDMETHOD(Evaluate)(BSTR In, BSTR* Out)
	{
		RETURN_ON_NULL(g_pProjectEngine);
		return g_pProjectEngine->Evaluate(In, Out);
	}

// IVCPlatformImpl
	STDMETHOD(Close)()
	{
		long l, lcItems;

		lcItems = m_rgTools.GetSize();
		for (l = 0; l < lcItems; l++)
		{
			CComQIPtr<IVCToolImpl> pToolImpl;
			pToolImpl = m_rgTools.GetAt(l);
			if (pToolImpl)
				pToolImpl->Close(); // close down entirely; release all
		}

		m_rgTools.RemoveAll(); // collection of Tools. 
		return S_OK;
	}
//	STDMETHOD(SaveObject)(IStream *xml, IVCPropertyContainer *pPropCnt, long nIndent);
//	STDMETHOD(Initialize)( void ); 	
//	STDMETHOD(IsToolInToolset)(toolSetType listStyle, IVCToolImpl* pTool, VARIANT_BOOL* pbInToolset);

protected:
	void StripQuotesAndSetValue(BSTR newVal, CComBSTR& bstrVal)
	{
		// strip quotations
		CStringW temp( newVal );
		temp.Remove(L'\"');
		CComBSTR out(temp);
		bstrVal = out;
	}

	void DoSetToolExtensions(IVCToolImpl* pTool, LPCOLESTR strKey, LPOLESTR szToolShortName)
	{
		CComBSTR bstrVal;
		HRESULT hr = GetRegStringW(strKey, szToolShortName, &bstrVal);
		if( SUCCEEDED(hr) && bstrVal.Length()>0 )
		{
			pTool->put_DefaultExtensions(bstrVal);
		}
	}
};

/////////////////////////////////////////////////////////////////////////////
// CPlatformWin32

class CPlatformWin32 : 
	public CBasePlatform<CPlatformWin32, &CLSID_VCPlatformWin32>
{
public:
DECLARE_NO_REGISTRY()

// VCPlatform
public:
	STDMETHOD(get_Name)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(MatchName)(BSTR bstrNameToMatch, VARIANT_BOOL bFullOnly, VARIANT_BOOL *pbMatched);

// IVCPlatformImpl
	STDMETHOD(SaveObject)(IStream *xml, IVCPropertyContainer *pPropCnt, long nIndent);
	STDMETHOD(Initialize)( void ); 	
	STDMETHOD(IsToolInToolset)(toolSetType listStyle, IVCToolImpl* pTool, VARIANT_BOOL* pbInToolset);

protected:
	static CVCStringWList		s_strToolsExcludeList[5];		// tools excluded for the tool type
};

/////////////////////////////////////////////////////////////////////////////
// CPlatformWin64

class CPlatformWin64 : 
	public CBasePlatform<CPlatformWin64, &CLSID_VCPlatformWin64>
{
public:
#ifdef _WIN64
DECLARE_VS_REGISTRY_RESOURCEID(IDR_PLATFORM_WIN64)
#else	// _WIN64
DECLARE_NO_REGISTRY()
#endif	// _WIN64

// VCPlatform
public:
	STDMETHOD(get_Name)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(MatchName)(BSTR bstrNameToMatch, VARIANT_BOOL bFullOnly, VARIANT_BOOL *pbMatched);

// IVCPlatformImpl
	STDMETHOD(SaveObject)(IStream *xml, IVCPropertyContainer *pPropCnt, long nIndent);
	STDMETHOD(Initialize)( void ); 	
	STDMETHOD(IsToolInToolset)(toolSetType listStyle, IVCToolImpl* pTool, VARIANT_BOOL* pbInToolset);

protected:
	static CVCStringWList		s_strToolsExcludeList[5];		// tools excluded for the tool type
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\vcpb\nmaketool.cpp ===
// NMakeTool.cpp : Implementation of CVCNMakeTool

#include "stdafx.h"
#include "NMakeTool.h"
#include "FileRegistry.h"
#include "BldHelpers.h"
#include "BldActions.h"
#include "ProjWriter.h"

// static initializers
CComBSTR CVCNMakeTool::s_bstrDescription = L"";
CComBSTR CVCNMakeTool::s_bstrToolName = L"";
CComBSTR CVCNMakeTool::s_bstrExtensions = L"";
GUID CVCNMakeTool::s_pPages[1];
BOOL CVCNMakeTool::s_bPagesInit;

//////////////////////////////////////////////////////////////////////////////
// implementation of CVCNMakeTool; behavior specific to NMake tool, with storage

HRESULT CVCNMakeTool::CreateInstance(IVCPropertyContainer* pPropContainer, IVCToolImpl** ppTool)
{
	CHECK_POINTER_NULL(ppTool);
	*ppTool = NULL;

	CComObject<CVCNMakeTool> *pObj;
	HRESULT hr = CComObject<CVCNMakeTool>::CreateInstance(&pObj);
	if (SUCCEEDED(hr))
	{
		if( pPropContainer )
			pObj->Initialize(pPropContainer);
		CVCNMakeTool *pVar = pObj;
		pVar->AddRef();
		*ppTool = pVar;
	}
	return hr;
}

//////////////////////////////////////////////////////////////////////////////
// VCNMakeTool

STDMETHODIMP CVCNMakeTool::get_ToolName(BSTR* pbstrToolName)	// friendly name of tool, e.g., "C/C++ Compiler Tool"
{
	CHECK_POINTER_VALID( pbstrToolName );
	InitToolName();
	s_bstrToolName.CopyTo(pbstrToolName);
	return S_OK;
}

STDMETHODIMP CVCNMakeTool::get_BuildCommandLine(BSTR *pbstrCommandLine)
{
	return ToolGetStrProperty(VCNMAKEID_BuildCommandLine, pbstrCommandLine);
}

STDMETHODIMP CVCNMakeTool::put_BuildCommandLine(BSTR bstrCommandLine)
{
	CHECK_ZOMBIE( m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE );
	return m_spPropertyContainer->SetStrProperty(VCNMAKEID_BuildCommandLine, bstrCommandLine);
}

STDMETHODIMP CVCNMakeTool::get_ReBuildCommandLine(BSTR *pbstrCommandLine)
{
	return ToolGetStrProperty(VCNMAKEID_ReBuildCommandLine, pbstrCommandLine);
}

STDMETHODIMP CVCNMakeTool::put_ReBuildCommandLine(BSTR bstrCommandLine)
{
	CHECK_ZOMBIE( m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE );
	return m_spPropertyContainer->SetStrProperty(VCNMAKEID_ReBuildCommandLine, bstrCommandLine);
}

STDMETHODIMP CVCNMakeTool::get_CleanCommandLine(BSTR *pbstrCommandLine)
{
	return ToolGetStrProperty(VCNMAKEID_CleanCommandLine, pbstrCommandLine);
}

STDMETHODIMP CVCNMakeTool::put_CleanCommandLine(BSTR bstrCommandLine)
{
	CHECK_ZOMBIE( m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE );
	return m_spPropertyContainer->SetStrProperty(VCNMAKEID_CleanCommandLine, bstrCommandLine);
}

STDMETHODIMP CVCNMakeTool::get_Output(BSTR *pbstrOutput)
{
	return ToolGetStrProperty(VCNMAKEID_Output, pbstrOutput);
}

STDMETHODIMP CVCNMakeTool::put_Output(BSTR bstrOutput)
{
	CHECK_ZOMBIE( m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE );
	return m_spPropertyContainer->SetStrProperty(VCNMAKEID_Output, bstrOutput);
}

// Automation properties
STDMETHODIMP CVCNMakeTool::get_ToolPath(BSTR *pbstrToolPath)
{
	CHECK_POINTER_VALID(pbstrToolPath);
	*pbstrToolPath = SysAllocString( szNMakeToolPath );
	return S_OK;
}

//////////////////////////////////////////////////////////////////////////////
// IVCToolImpl

STDMETHODIMP CVCNMakeTool::get_DefaultExtensions(BSTR* pVal)
{
	return DoGetDefaultExtensions(s_bstrExtensions, wszNMakeDefaultExtensions, pVal);
}

STDMETHODIMP CVCNMakeTool::put_DefaultExtensions(BSTR newVal)
{
	s_bstrExtensions = newVal;
	return S_OK;
}

STDMETHODIMP CVCNMakeTool::GetAdditionalOptionsInternal(IUnknown* pItem, VARIANT_BOOL bForBuild, VARIANT_BOOL bSkipLocal, BSTR* pbstrOptions)
{ 
	return E_NOTIMPL;	// don't have any; but don't want assert
}

STDMETHODIMP CVCNMakeTool::GetBuildDescription(IVCBuildAction* pAction, BSTR* pbstrBuildDescription)
{
	if( s_bstrDescription.Length() == 0 )
		s_bstrDescription.LoadString( IDS_NMAKE_DESC );
	return s_bstrDescription.CopyTo( pbstrBuildDescription );
}

STDMETHODIMP CVCNMakeTool::get_ToolPathInternal(BSTR* pbstrToolPath)
{ 
	return get_ToolPath(pbstrToolPath);
}

STDMETHODIMP CVCNMakeTool::get_Bucket(long *pVal)
{
	CHECK_POINTER_NULL( pVal );
	*pVal = BUCKET_NMAKE;
	return S_OK;
}

STDMETHODIMP CVCNMakeTool::GenerateOutput(long type, IVCBuildActionList* pActions, IVCBuildErrorContext* pEC)
{
	RETURN_ON_NULL2(pActions, S_FALSE);

	pActions->Reset(NULL);
 	while (TRUE)
 	{
		CComPtr<IVCBuildAction> spAction;
		HRESULT hr = pActions->Next(&spAction, NULL);
		BREAK_ON_DONE(hr);
		if (spAction == NULL)
			continue;
				
		// create a bogus, non-existant, output string
		// so that this tool will always run
		CStringW strOutputFile = _wtmpnam( NULL );
		if( !strOutputFile )
		{
			VSASSERT( FALSE, "_wtmpnam() failed" );
			CComBSTR bstrErr;
			bstrErr.LoadString(IDS_ERR_NO_CREATE_TEMP_FILE_PRJ0039);
			CVCProjectEngine::AddProjectError(pEC, bstrErr, L"PRJ0039", pActions);
			return S_FALSE;
		}

		// create our path given this output string
		CPathW pathOutput;		// path of our output based on this spec.
		if (pathOutput.Create(strOutputFile))
		{
			pathOutput.GetActualCase(TRUE);
			if (spAction->AddOutputFromPath((wchar_t *)(const wchar_t *)pathOutput, pEC, VARIANT_TRUE, VARIANT_FALSE, -1, 
				this) != S_OK)
			{
				// FUTURE: error goes here! 
				VSASSERT(FALSE, "Failed to add output for nmake command line");	
			}
		}
 	}

	return S_OK; // success
}

STDMETHODIMP CVCNMakeTool::GetCommandLineEx(IVCBuildAction* pAction, IVCBuildableItem* pBuildableItem, 
	IVCBuildEngine* pBuildEngine, IVCBuildErrorContext* pEC, BSTR *pVal)
{
	CHECK_POINTER_NULL(pVal);
	*pVal = NULL;

	CComQIPtr<IVCPropertyContainer> spPropContainer = pBuildableItem;
	RETURN_INVALID_ON_NULL(spPropContainer);

	CComBSTR bstrCommandLine;
	HRESULT hr = spPropContainer->GetEvaluatedStrProperty(VCNMAKEID_BuildCommandLine, &bstrCommandLine);
	RETURN_ON_FAIL(hr);

	// if it's blank, put a message out to the error context
	if( bstrCommandLine.Length() == 0 )
	{
		CComBSTR bstrMsg;
		bstrMsg.LoadString( IDS_NOBUILDCOMMANDLINEMSG );
		pEC->AddInfo( bstrMsg );
	}

	if (hr != S_OK)
	{
		bstrCommandLine.CopyTo(pVal);
		return S_FALSE;
	}

	if (pBuildEngine == NULL)
		return bstrCommandLine.CopyTo(pVal);

	CComBSTR bstrFullCommandLine;
	BuildCommandLineBatchFile(pAction, bstrCommandLine, bstrFullCommandLine);

	return pBuildEngine->FormBatchFile(bstrFullCommandLine, pEC, pVal);
}

STDMETHODIMP CVCNMakeTool::GetCleanCommandLineEx(IVCBuildAction* pAction, IVCBuildableItem* pBuildableItem, 
	IVCBuildEngine* pBuildEngine, IVCBuildErrorContext* pEC, BSTR *pVal)
{
	CHECK_POINTER_NULL(pVal);
	*pVal = NULL;

	CComQIPtr<IVCPropertyContainer> spPropContainer = pBuildableItem;
	RETURN_INVALID_ON_NULL(spPropContainer);

	CComBSTR bstrCommandLine;
	HRESULT hr = spPropContainer->GetEvaluatedStrProperty(VCNMAKEID_CleanCommandLine, &bstrCommandLine);
	RETURN_ON_FAIL(hr);

	// if it's blank, put a message out to the error context
	if( bstrCommandLine.Length() == 0 )
	{
		CComBSTR bstrMsg;
		bstrMsg.LoadString( IDS_NOCLEANCOMMANDLINEMSG );
		pEC->AddInfo( bstrMsg );
	}
	else
	{
		CComBSTR bstrRealCmd = bstrCommandLine;
		BuildCommandLineBatchFile(pAction, bstrRealCmd, bstrCommandLine);
	}

	if (hr != S_OK)
	{
		bstrCommandLine.CopyTo(pVal);
		return S_FALSE;
	}

	if (pBuildEngine == NULL)
		return bstrCommandLine.CopyTo(pVal);

	return pBuildEngine->FormBatchFile(bstrCommandLine, pEC, pVal);
}

STDMETHODIMP CVCNMakeTool::GetRebuildCommandLineEx(IVCBuildAction* pAction, IVCBuildableItem* pBuildableItem, 
	IVCBuildEngine* pBuildEngine, IVCBuildErrorContext* pEC, BSTR *pVal)
{
	CHECK_POINTER_NULL(pVal);
	*pVal = NULL;

	CComQIPtr<IVCPropertyContainer> spPropContainer = pBuildableItem;
	RETURN_INVALID_ON_NULL(spPropContainer);

	CComBSTR bstrCommandLine;
	HRESULT hr = spPropContainer->GetEvaluatedStrProperty(VCNMAKEID_ReBuildCommandLine, &bstrCommandLine);
	RETURN_ON_FAIL(hr);

	// if it's blank, put a message out to the error context
	if( bstrCommandLine.Length() == 0 )
	{
		CComBSTR bstrMsg;
		bstrMsg.LoadString( IDS_NOREBUILDCOMMANDLINEMSG );
		pEC->AddInfo( bstrMsg );
	}
	else
	{
		CComBSTR bstrRealCmd = bstrCommandLine;
		BuildCommandLineBatchFile(pAction, bstrRealCmd, bstrCommandLine);
	}

	if (hr != S_OK)
	{
		bstrCommandLine.CopyTo(pVal);
		return S_FALSE;
	}

	if (pBuildEngine == NULL)
		return bstrCommandLine.CopyTo(pVal);

	return pBuildEngine->FormBatchFile(bstrCommandLine, pEC, pVal);
}

STDMETHODIMP CVCNMakeTool::IsTargetTool(IVCBuildAction* pAction, VARIANT_BOOL* pbTargetTool)
{
	CHECK_POINTER_NULL( pbTargetTool );
	*pbTargetTool = VARIANT_TRUE;	// this is a target tool
	return S_OK;
}

STDMETHODIMP CVCNMakeTool::get_ToolShortName(BSTR* pbstrToolName)
{
	CHECK_POINTER_NULL(pbstrToolName);
	*pbstrToolName = SysAllocString( szNMakeToolShortName );
	return S_OK;
}

STDMETHODIMP CVCNMakeTool::MatchName(BSTR bstrName, VARIANT_BOOL bFullOnly, VARIANT_BOOL* pbMatches)
{
	return DoMatchName(bstrName, szNMakeToolType, szNMakeToolShortName, pbMatches);
}

STDMETHODIMP CVCNMakeTool::get_IsComspecTool(VARIANT_BOOL* pbIsComspecTool)
{
	CHECK_POINTER_NULL( pbIsComspecTool );
	*pbIsComspecTool = VARIANT_TRUE;
	return S_OK;
}

STDMETHODIMP CVCNMakeTool::SaveObject(IStream *xml, IVCPropertyContainer *pPropContainer, long nIndent)
{
	VSASSERT(pPropContainer, "Cannot save properties without a property container.");
	RETURN_INVALID_ON_NULL(pPropContainer);

	StartNodeHeader( xml, L"Tool", false );

	// Name
	CComBSTR bstrToolShortName;
	get_ToolShortName(&bstrToolShortName);
	if (bstrToolShortName.Length() > 0)
	{
		NodeAttribute( xml, L"Name", bstrToolShortName ); 					
	}
	AddSaveLine( xml, pPropContainer, L"BuildCommandLine", VCNMAKEID_BuildCommandLine );
	AddSaveLine( xml, pPropContainer, L"ReBuildCommandLine", VCNMAKEID_ReBuildCommandLine );
	AddSaveLine( xml, pPropContainer, L"CleanCommandLine", VCNMAKEID_CleanCommandLine );
	AddSaveLine( xml, pPropContainer, L"Output", VCNMAKEID_Output );

	// end of node header
	EndNodeHeader( xml, false );
	// end of node
	EndNode( xml, L"Tool", false );

	return S_OK;
}

void CVCNMakeTool::AddSaveLine(IStream *xml, IVCPropertyContainer* pPropContainer, LPOLESTR bszPropertyName, long nPropertyID)
{
	CComBSTR bstrProp;
	if (pPropContainer->GetStrProperty(nPropertyID, &bstrProp) != S_OK)
		return;

	NodeAttributeWithSpecialChars( xml, bszPropertyName, bstrProp );
}

STDMETHODIMP CVCNMakeTool::get_ToolDisplayIndex(long* pIndex)
{
	CHECK_POINTER_NULL(pIndex);
	*pIndex = TOOL_DISPLAY_INDEX_NMAKE;
	return S_OK;
}

GUID* CVCNMakeTool::GetPageIDs()
{ 
	if (s_bPagesInit == FALSE)
	{
		s_pPages[0] = __uuidof(VCNMakeGeneral);
		s_bPagesInit = TRUE;
	}
	return s_pPages; 
}

LPCOLESTR CVCNMakeTool::GetToolFriendlyName()
{
	InitToolName();
	return s_bstrToolName;
}

void CVCNMakeTool::InitToolName()
{
	if (s_bstrToolName.Length() == 0)
	{
		if (!s_bstrToolName.LoadString(IDS_NMAKE_TOOLNAME))
			s_bstrToolName = szNMakeToolType;
	}
}

STDMETHODIMP CVCNMakeTool::HasPrimaryOutputFromTool(IUnknown* pItem, VARIANT_BOOL bSchmoozeOnly, VARIANT_BOOL* pbHasPrimaryOutput)
{ 
	return COptionHandlerBase::GetValueTrue(pbHasPrimaryOutput);
}

STDMETHODIMP CVCNMakeTool::GetPrimaryOutputFromTool(IUnknown* pItem, VARIANT_BOOL bSchmoozeOnly, BSTR* pbstrPath)
{ 
	CHECK_POINTER_NULL(pbstrPath);
	*pbstrPath = NULL;

	CComQIPtr<IVCPropertyContainer> spPropContainer = pItem;
	RETURN_ON_NULL2(spPropContainer, S_FALSE);

	CComBSTR bstrTemp, bstrFile;
	HRESULT hr = spPropContainer->GetStrProperty(VCNMAKEID_Output, &bstrTemp);
	if (hr != S_OK)
		return hr;
	hr = spPropContainer->Evaluate(bstrTemp, &bstrFile);
	RETURN_ON_FAIL(hr);

	CComBSTR bstrProjDir;
	hr = spPropContainer->GetStrProperty(VCPROJID_ProjectDirectory, &bstrProjDir);
	RETURN_ON_FAIL(hr);

	CDirW dirProj;
	if (!dirProj.CreateFromKnown(bstrProjDir))
		return E_UNEXPECTED;

	CPathW pathOut;
	if (pathOut.CreateFromDirAndRelative(dirProj, bstrFile))
		bstrFile = (const wchar_t*)pathOut;
	
	*pbstrPath = bstrFile.Detach();
	return S_OK;
}

STDMETHODIMP CVCNMakeTool::GetPrimaryOutputIDFromTool(IUnknown* pItem, VARIANT_BOOL bSchmoozeOnly, long* pnOutputID)
{
	CHECK_POINTER_NULL(pnOutputID);
	*pnOutputID = VCNMAKEID_Output;

	return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
// Affects our output?
STDMETHODIMP CVCNMakeTool::AffectsOutput(long nPropID, VARIANT_BOOL* pbAffectsOutput)
{
	CHECK_POINTER_NULL(pbAffectsOutput);
	*pbAffectsOutput = VARIANT_FALSE;

	// change our outputs?
	if (nPropID == VCNMAKEID_Output || nPropID == VCNMAKEID_OutputsDirty)
		*pbAffectsOutput = VARIANT_TRUE;

	return S_OK;
}

STDMETHODIMP CVCNMakeTool::CreatePageObject(IUnknown **ppUnk, CLSID*pCLSID, IVCPropertyContainer *pPropCntr, IVCSettingsPage *pPage )
{
	// Get the list of pages
	if( CLSID_VCNMakeGeneral == *pCLSID )
	{
		CPageObjectImpl<CVCNMakePage, VCNMAKETOOL_MIN_DISPID, VCNMAKETOOL_MAX_DISPID >::CreateInstance(ppUnk, pPropCntr, pPage);
	}
	else
	{
		return S_FALSE;
	}
		
	return S_OK;
}


STDMETHODIMP CVCNMakePage::get_BuildCommandLine(BSTR *pVal)
{
	CHECK_POINTER_NULL(pVal);
	CStringW str;
	if(GetTruncatedStringForProperty(VCNMAKEID_BuildCommandLine, str))
	{
		*pVal = str.AllocSysString();
		return S_OK;
	}
	return GetStrProperty(VCNMAKEID_BuildCommandLine, pVal);
}

STDMETHODIMP CVCNMakePage::put_BuildCommandLine(BSTR newVal)
{
	HRESULT hr = SetStrProperty(VCNMAKEID_BuildCommandLine, newVal);
	RefreshPropGrid();
	return hr;
}

STDMETHODIMP CVCNMakePage::get_ReBuildCommandLine(BSTR *pVal)
{
	CHECK_POINTER_NULL(pVal);
	CStringW str;
	if(GetTruncatedStringForProperty(VCNMAKEID_ReBuildCommandLine, str))
	{
		*pVal = str.AllocSysString();
		return S_OK;
	}
	return GetStrProperty(VCNMAKEID_ReBuildCommandLine, pVal);
}

STDMETHODIMP CVCNMakePage::put_ReBuildCommandLine(BSTR newVal)
{
	HRESULT hr = SetStrProperty(VCNMAKEID_ReBuildCommandLine, newVal);
	RefreshPropGrid();
	return hr;
}

STDMETHODIMP CVCNMakePage::get_CleanCommandLine(BSTR *pVal)
{
	CHECK_POINTER_NULL(pVal);
	CStringW str;
	if(GetTruncatedStringForProperty(VCNMAKEID_CleanCommandLine, str))
	{
		*pVal = str.AllocSysString();
		return S_OK;
	}
	return GetStrProperty(VCNMAKEID_CleanCommandLine, pVal);
}

STDMETHODIMP CVCNMakePage::put_CleanCommandLine(BSTR newVal)
{
	HRESULT hr = SetStrProperty(VCNMAKEID_CleanCommandLine, newVal);
	RefreshPropGrid();
	return hr;
}

STDMETHODIMP CVCNMakePage::get_Output(BSTR *pVal)
{
	CHECK_POINTER_NULL(pVal);
	return GetStrProperty(VCNMAKEID_Output, pVal);
}

STDMETHODIMP CVCNMakePage::put_Output(BSTR newVal)
{
	return SetStrProperty(VCNMAKEID_Output, newVal);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\vcpb\PlatformXbox.h ===
// Platform.h: Definition of the CBasePlatform, CPlatformWin32, and CPlatformWin64 classes
//
//////////////////////////////////////////////////////////////////////

#pragma once

#include "vccolls.h"
#include "comlist.h"
#include "collection.h"
#include "platform.h"

/////////////////////////////////////////////////////////////////////////////
// CPlatformXbox

class CPlatformXbox : 
	public CBasePlatform<CPlatformXbox, &CLSID_VCPlatformXbox>
{
public:
DECLARE_VS_REGISTRY_RESOURCEID(IDR_PLATFORM_XBOX)

// VCPlatform
public:
	STDMETHOD(get_Name)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(MatchName)(BSTR bstrNameToMatch, VARIANT_BOOL bFullOnly, VARIANT_BOOL *pbMatched);

// IVCPlatformImpl
	STDMETHOD(SaveObject)(IStream *xml, IVCPropertyContainer *pPropCnt, long nIndent);
	STDMETHOD(Initialize)( void ); 	
	STDMETHOD(IsToolInToolset)(toolSetType listStyle, IVCToolImpl* pTool, VARIANT_BOOL* pbInToolset);

protected:
	static CVCStringWList		s_strToolsExcludeList[5];		// tools excluded for the tool type
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\vcpb\PlatformXbox.cpp ===
#include "stdafx.h"
#include "PlatformXbox.h"
#include "projwriter.h"
#include "regscan.h"
#include "profile.h"
// tool includes
#include "bsctool.h"
#include "bldeventtool.h"
#include "cltool.h"
#include "custombuildtool.h"
#include "XboxImageTool.h"
#include "XboxDeployTool.h"
#include "libtool.h"
#include "linktool.h"
#include "midltool.h"
#include "nmaketool.h"
#include "rctool.h"
#include "sdltool.h"
#include "util2.h"

const wchar_t* const PLATFORM_NAME_XBOX  = L"Xbox";

CVCStringWList CPlatformXbox::s_strToolsExcludeList[5];

/////////////////////////////////////////////////////////////////////////////
//

STDMETHODIMP CPlatformXbox::Initialize( void )
{
	// create instance each of the tools for this platform
	// an add each of them to the tool collection
	HRESULT hr;

	CComBSTR bstrMainKey;
	CVCProjectEngine::GetBasePlatformInfoKey(&bstrMainKey);
	bstrMainKey.Append(L"\\");
	bstrMainKey.Append(PLATFORM_NAME_XBOX);

	CComBSTR bstrExtKey;
	bstrExtKey = bstrMainKey + L"\\ToolDefaultExtensionLists";

	CComPtr<IVCToolImpl> pTool;
	// VCBscMakeTool
	hr = CVCBscMakeTool::CreateInstance( NULL, &pTool);
	ADD_TOOL(hr, pTool, m_rgTools, bstrExtKey, szBscMakeToolShortName);

	// VCCLCompilerTool
	hr = CVCCLCompilerTool::CreateInstance( NULL, &pTool );
	ADD_TOOL(hr, pTool, m_rgTools, bstrExtKey, szCLCompilerToolShortName);

	// VCCustomBuildTool
	hr = CVCCustomBuildTool::CreateInstance( NULL, &pTool );
	ADD_TOOL(hr, pTool, m_rgTools, bstrExtKey, szCustomBuildToolShortName);

	// VCLibrarianTool
	hr = CVCLibrarianTool::CreateInstance( NULL, &pTool );
	ADD_TOOL(hr, pTool, m_rgTools, bstrExtKey, szLibrarianToolShortName);

	// VCLinkerTool
	hr = CVCLinkerTool::CreateInstance( NULL, &pTool );
	ADD_TOOL(hr, pTool, m_rgTools, bstrExtKey, szLinkerToolShortName);

#if 0

	// VCMIDLTool
	hr = CVCMidlTool::CreateInstance( NULL, &pTool );
	ADD_TOOL(hr, pTool, m_rgTools, bstrExtKey, szMidlToolShortName);

#endif

	// VCNMakeTool
	hr = CVCNMakeTool::CreateInstance( NULL, &pTool );
	ADD_TOOL(hr, pTool, m_rgTools, bstrExtKey, szNMakeToolShortName);

	// VCPostBuildEventTool
	hr = CVCPostBuildEventTool::CreateInstance( NULL, &pTool );
	ADD_TOOL(hr, pTool, m_rgTools, bstrExtKey, szPostBuildEventToolShortName);

	// VCPreBuildEventTool
	hr = CVCPreBuildEventTool::CreateInstance( NULL, &pTool );
	ADD_TOOL(hr, pTool, m_rgTools, bstrExtKey, szPreBuildEventToolShortName);

	// VCPreLinkEventTool
	hr = CVCPreLinkEventTool::CreateInstance( NULL, &pTool );
	ADD_TOOL(hr, pTool, m_rgTools, bstrExtKey, szPreLinkEventToolShortName);

	// VCResourceCompilerTool
	hr = CVCResourceCompilerTool::CreateInstance( NULL, &pTool );
	ADD_TOOL(hr, pTool, m_rgTools, bstrExtKey, szResourceCompilerToolShortName);

#if 0

	// VCWebServiceProxyGeneratorTool
	hr = CVCWebServiceProxyGeneratorTool::CreateInstance( NULL, &pTool );
	ADD_TOOL(hr, pTool, m_rgTools, bstrExtKey, szWebToolShortName);

	// VCWebDeploymentTool
	hr = CVCWebDeploymentTool::CreateInstance( NULL, &pTool );
	ADD_TOOL(hr, pTool, m_rgTools, bstrExtKey, szDeployToolShortName);

#endif

	// CXboxDeploymentTool
	hr = CXboxDeploymentTool::CreateInstance( NULL, &pTool );
	ADD_TOOL(hr, pTool, m_rgTools, bstrExtKey, szXboxDeployToolShortName);

	// CXboxImageTool
	hr = CXboxImageTool::CreateInstance( NULL, &pTool );
	ADD_TOOL(hr, pTool, m_rgTools, bstrExtKey, szXboxImageToolShortName);

	// get the environment variables for the platform parameters

	// Why isn't this set in the rgs script? Ah well

	CComBSTR bstrXDK;
	VCGetEnvironmentVariableW(L"XDK", &bstrXDK);

	// val 'Path Dirs' = s '%XDK%\Xbox\Bin\VC7;%XDK%\Xbox\Bin;%PATH%'


	CComBSTR bstrPath;
	VCGetEnvironmentVariableW(L"PATH", &bstrPath);
	CComBSTR bstrPath2;
	bstrPath2.Append(bstrXDK);
	bstrPath2.Append("\\Xbox\\Bin\\VC7;");
	bstrPath2.Append(bstrXDK);
	bstrPath2.Append("\\Xbox\\Bin;");
	bstrPath2.Append(bstrPath);
	put_ExecutableDirectories(bstrPath2);

	// val 'Include Dirs' = s '%XDK%\Xbox\Include'

	// CComBSTR bstrInc;
	// VCGetEnvironmentVariableW(L"INCLUDE", &bstrInc);
	CComBSTR bstrInc2;
	bstrInc2.Append(bstrXDK);
	bstrInc2.Append("\\Xbox\\Include");
	put_IncludeDirectories(bstrInc2);

	CComBSTR bstrRef;
	VCGetEnvironmentVariableW(L"LIBPATH", &bstrRef);
	put_ReferenceDirectories(bstrRef);

	// val 'Library Dirs' = s '%XDK%\Xbox\Lib'

	// CComBSTR bstrLib;
	// VCGetEnvironmentVariableW(L"LIB", &bstrLib);
	CComBSTR bstrLib2;
	bstrLib2.Append(bstrXDK);
	bstrLib2.Append("\\Xbox\\Lib");
	put_LibraryDirectories(bstrLib2);

	// val 'Source Dirs' = s '%XDK%\Source'

	// CComBSTR bstrSrc;
	// VCGetEnvironmentVariableW(L"SOURCE", &bstrSrc);
	CComBSTR bstrSrc2;
	bstrSrc2.Append(bstrXDK);
	bstrSrc2.Append("\\Source");
	put_SourceDirectories(bstrSrc2);

	// These are set up as exclusion lists so that we don't have to special case any user-defined tools later.
	// Also makes for a shorter hunt through the list for the most common cases to see if we should be adding
	// the tool or not.  :-)

	s_strToolsExcludeList[toolSetUtility].AddTail(szBscMakeToolShortName);
	s_strToolsExcludeList[toolSetUtility].AddTail(szResourceCompilerToolShortName);
	s_strToolsExcludeList[toolSetUtility].AddTail(szCLCompilerToolShortName);
	s_strToolsExcludeList[toolSetUtility].AddTail(szPreLinkEventToolShortName);
	s_strToolsExcludeList[toolSetUtility].AddTail(szLinkerToolShortName);
	s_strToolsExcludeList[toolSetUtility].AddTail(szLibrarianToolShortName);
 	s_strToolsExcludeList[toolSetUtility].AddTail(szNMakeToolShortName);
 	s_strToolsExcludeList[toolSetUtility].AddTail(szWebToolShortName);
 	s_strToolsExcludeList[toolSetUtility].AddTail(szDeployToolShortName);

	s_strToolsExcludeList[toolSetMakefile].AddTail(szBscMakeToolShortName);
	s_strToolsExcludeList[toolSetMakefile].AddTail(szMidlToolShortName);
	s_strToolsExcludeList[toolSetMakefile].AddTail(szResourceCompilerToolShortName);
	s_strToolsExcludeList[toolSetMakefile].AddTail(szCLCompilerToolShortName);
	s_strToolsExcludeList[toolSetMakefile].AddTail(szPreLinkEventToolShortName);
	s_strToolsExcludeList[toolSetMakefile].AddTail(szLinkerToolShortName);
	s_strToolsExcludeList[toolSetMakefile].AddTail(szLibrarianToolShortName);
	s_strToolsExcludeList[toolSetMakefile].AddTail(szPreBuildEventToolShortName);
	s_strToolsExcludeList[toolSetMakefile].AddTail(szPostBuildEventToolShortName);
	s_strToolsExcludeList[toolSetMakefile].AddTail(szCustomBuildToolShortName);
 	s_strToolsExcludeList[toolSetMakefile].AddTail(szWebToolShortName);
 	s_strToolsExcludeList[toolSetMakefile].AddTail(szDeployToolShortName);

	s_strToolsExcludeList[toolSetLinker].AddTail(szLibrarianToolShortName);
 	s_strToolsExcludeList[toolSetLinker].AddTail(szNMakeToolShortName);

	s_strToolsExcludeList[toolSetLibrarian].AddTail(szLinkerToolShortName);
 	s_strToolsExcludeList[toolSetLibrarian].AddTail(szNMakeToolShortName);
 	s_strToolsExcludeList[toolSetLibrarian].AddTail(szDeployToolShortName);

	// nothing whatsoever is excluded for toolSetAll

	// now, let's add any vendor tools that have been registered with us
	/*
	Registry looks something like this:
	HKEY_LOCAL_MACHINE\ ... \VC_OBJECTS_PLATFORM_INFO
		Xbox (with default prop = guid)
			directories
				<inc, exe, lib directories>
			Vendor Tools
				vendor tool short name (with default prop = guid)
					<any excluded configs>
	*/

	if( UsingRegistry() )
	{
		CComBSTR bstrToolsSubKey = bstrMainKey;
		bstrToolsSubKey += L"\\VendorTools";

		CRegistryScanner RegScannerTools;
		if (!RegScannerTools.Open(HKEY_LOCAL_MACHINE, bstrToolsSubKey))
			return S_OK;	// nothing to do if no reg key
	
	
		// Now Add In VendorTools
		CComQIPtr<IVCProjectEngineImpl> spProjEngineImpl;
		spProjEngineImpl = g_pProjectEngine;
		if (spProjEngineImpl == NULL)
			return E_UNEXPECTED;

		CStringW strToolBaseKey;
		strToolBaseKey = bstrToolsSubKey;
		strToolBaseKey += L"\\";

		CComPtr<IDispatch> spDispTools;
		CComQIPtr<IVCCollection> spVendorTools;
		hr = spProjEngineImpl->get_VendorTools(&spDispTools);
		spVendorTools = spDispTools;
		RETURN_ON_FAIL_OR_NULL2(hr, spVendorTools, E_UNEXPECTED);

		CComBSTR bstrToolName;
		while (RegScannerTools.EnumKey(&bstrToolName))

		{	
			CComPtr<IDispatch> spDispBaseTool;
			hr = spVendorTools->Item(CComVariant(bstrToolName), &spDispBaseTool);
			if (spDispBaseTool == NULL)	// not already present
			{
				CComBSTR bstrToolGUID;
				if (!RegScannerTools.GetValue(L"\0", &bstrToolGUID))
					return E_UNEXPECTED;
				hr = spProjEngineImpl->AddVendorTool(bstrToolName, bstrToolGUID, &spDispBaseTool);
			}
			RETURN_ON_NULL2(spDispBaseTool, E_UNEXPECTED);
	
			pTool = spDispBaseTool;
			ADD_TOOL2(hr, pTool, m_rgTools);
	
			CStringW strKey = strToolBaseKey;
			strKey += bstrToolName;

			s_strToolsExcludeList[toolSetMakefile].AddTail(bstrToolName);	// nobody gets to add tools here - everything excluded.

			CComBSTR bstrVal;
			hr = GetRegStringW(strKey, L"Include_toolSetUtility", &bstrVal);
			if ( hr == S_OK )	// this is an inclusion element, so element needs to be PRESENT to not be excluded
				s_strToolsExcludeList[toolSetUtility].AddTail(bstrToolName);

			bstrVal.Empty();
			hr = GetRegStringW(strKey, L"Exclude_toolSetLinker", &bstrVal);
			if ( hr == S_OK )	// this is an inclusion element, so element needs to be PRESENT to not be excluded
				s_strToolsExcludeList[toolSetLinker].AddTail(bstrToolName);

			bstrVal.Empty();
			hr = GetRegStringW(strKey, L"Exclude_toolSetLibrarian", &bstrVal);
			if ( hr == S_OK )	// this is an inclusion element, so element needs to be PRESENT to not be excluded
				s_strToolsExcludeList[toolSetLibrarian].AddTail(bstrToolName);
		}
	}
	return S_OK;
}

STDMETHODIMP CPlatformXbox::SaveObject(IStream *xml, IVCPropertyContainer *pPropCnt, long nIndent)
{
	// Name
	NodeAttribute( xml, CComBSTR( L"Name" ), CComBSTR( PLATFORM_NAME_XBOX ) );
	
	// end of attributes, start children
	EndNodeHeader( xml, false );

	return S_OK;
}

STDMETHODIMP CPlatformXbox::MatchName(BSTR bstrNameToMatch, VARIANT_BOOL bFullOnly, VARIANT_BOOL *pbMatched)
{
	CHECK_POINTER_VALID(pbMatched);
	*pbMatched = VARIANT_FALSE;
	if( bstrNameToMatch && _wcsicmp( PLATFORM_NAME_XBOX, bstrNameToMatch ) == 0 )
	{
		*pbMatched = VARIANT_TRUE;
	}
	return S_OK;
}

STDMETHODIMP CPlatformXbox::get_Name(/*[out, retval]*/ BSTR *pVal)
{
	CComBSTR bstrName( PLATFORM_NAME_XBOX );
	*pVal = bstrName.Detach();
	return S_OK;
}

// IVCPlatformImpl
STDMETHODIMP CPlatformXbox::IsToolInToolset(toolSetType listStyle, IVCToolImpl* pTool, VARIANT_BOOL* pbInToolset)
{
	CHECK_POINTER_NULL(pbInToolset);
	*pbInToolset = VARIANT_FALSE;

	if (!pTool)
		return S_FALSE;

	CComBSTR bstrToolName;
	if (FAILED(pTool->get_ToolShortName(&bstrToolName)))
	{
		VSASSERT(FALSE, "*All* tools are supposed to have a short name.");
		return S_FALSE;
	}

	CStringW strToolName = bstrToolName;
	if (strToolName.IsEmpty())
	{
		VSASSERT(FALSE, "*All* tools are supposed to have a short name.");
		return S_FALSE;
	}

	*pbInToolset = (!s_strToolsExcludeList[listStyle].Find(strToolName));
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\vcpb\Project.h ===
// Project.h: Definition of the CProject class
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_PROJECT_H__625C6496_2C7E_11D3_87BF_A0494CC10000__INCLUDED_)
#define AFX_PROJECT_H__625C6496_2C7E_11D3_87BF_A0494CC10000__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "comlist.h"
#include "FileRegistry.h"
#include "globals.h"
#include "webref.h"

#define closeFlagOpenClean		0x00
#define closeFlagMaybeSCCClose	0x01
#define closeFlagClosed			0x02
#define closeFlagBySCC			(closeFlagMaybeSCCClose | closeFlagClosed)

/////////////////////////////////////////////////////////////////////////////
// CProject

class CProject : 
	public IDispatchImpl<VCProject, &IID_VCProject, &LIBID_VCProjectEngineLibrary, PublicProjBuildTypeLibNumber,0, CVsTypeInfoHolder>, 
	public IVCProjectImpl,
	public IVCBuildableItem,
	public IVCExternalCookie,
	public IVsPerPropertyBrowsing,
	public IPerPropertyBrowsing,
	public IVsAddWebReference,			// KPERRY(21:3:01) uncomment this
	public CComObjectRoot
{
public:
	CProject();
	~CProject();
	static HRESULT CreateInstance(VCProject **ppProject);

BEGIN_COM_MAP(CProject)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(VCProject)
	COM_INTERFACE_ENTRY(IVCProjectImpl)
	COM_INTERFACE_ENTRY(IVCBuildableItem)
	COM_INTERFACE_ENTRY(IVsPerPropertyBrowsing)
	COM_INTERFACE_ENTRY(IPerPropertyBrowsing)
	COM_INTERFACE_ENTRY(IVCExternalCookie)
	COM_INTERFACE_ENTRY(IVCCollectionProvider)
	COM_INTERFACE_ENTRY(VCProjectItem)
	COM_INTERFACE_ENTRY(IVsAddWebReference) 			// KPERRY(21:3:01) uncomment this
END_COM_MAP()
//DECLARE_NOT_AGGREGATABLE(CProject) 
// Remove the comment from the line above if you don't want your object to 
// support aggregation. 

DECLARE_NO_REGISTRY()

// data
protected:
	CComBSTR	m_bstrName;			// the project name. This is independent of the filename
	CComBSTR	m_bstrFileName;		// just the file name, and no path
	CComBSTR	m_bstrFullDir;		// just the full-path's directory. Eg., "c:\projects\stuff\". Assume final slash is there.
	CComDynamicListTyped<VCFile>	m_rgFiles;		// collection of files for this project
	CComDynamicListTyped<VCPlatform>	m_rgPlatforms;	// collection of platforms for this project
	CComDynamicListTyped<VCConfiguration>	m_rgConfigs;	// collection of configs for this project
	CComDynamicListTyped<VCFilter>	m_rgFilters;		// collection of Filters for this project
	CComDynamicListTyped<VCProjectItem> m_rgTopLevelItems;	// collection of top level files & filters for this project
	// data for support of shell's "globals" object
	// RAW pointer
	IVCGlobals 	   *m_pGlobals;

	CComBSTR		m_bstrKeyword;
	VARIANT_BOOL	m_bDirty;
	// scc integration data
	CComBSTR		m_bstrSccProjectName;
	CComBSTR		m_bstrSccAuxPath;
	CComBSTR		m_bstrSccLocalPath;
	CComBSTR		m_bstrSccProvider;
	// what type of file is the project saved as (ANSI, UTF-8, Unicode)
	enumFileFormat	m_eFileFormat;
	CComBSTR		m_bstrFileEncoding;
	bool			m_bItemsCollectionDirty;
	// IVCBuildableItem data/helpers
	BldFileRegHandle	m_frh;
	CBldFileRegistry	m_ProjectRegistry;			// the project registry
	bool			m_bAssignedActions;
	void 		   *m_pExternalCookie;
	// owner project name, for VSEF nested project support
	CComBSTR		m_bstrOwnerKey;
	// Unique ID for this project
	CComBSTR		m_bstrGuid;
	// a flag for handling when SCC does something unspeakable to us like reload us on checkout
	DWORD			m_wCloseFlag;

// IVSAddWebReference
public:
	STDMETHOD(AddWebReferenceEx)(LPCOLESTR bstrUrl);

// VCProjectItem
public:
	STDMETHOD(MatchName)(BSTR NameToMatch, VARIANT_BOOL FullOnly, VARIANT_BOOL *IsMatch);
	STDMETHOD(get_Project)(IDispatch * *Val);
	STDMETHOD(get_Parent)(IDispatch * *Val);
	STDMETHOD(get_Kind)(BSTR* kind);
	STDMETHOD(get_ItemName)(BSTR *Val) { return get_Name(Val); }

// VCProject
public:
	STDMETHOD(get_Platforms)(IDispatch **pVal);
	STDMETHOD(get_Configurations)(/*[out, retval]*/ IDispatch * *pVal);
	STDMETHOD(get_Items)(/*[out, retval]*/ IDispatch * *pVal);
	STDMETHOD(get_Filters)(/*[out, retval]*/ IDispatch * *pVal);
	STDMETHOD(get_Files)(/*[out, retval]*/ IDispatch * *pVal);
	STDMETHOD(get_ProjectDirectory)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(get_ProjectFile)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_ProjectFile)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_Name)(BSTR *Val);
	STDMETHOD(put_Name)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_FileFormat)( enumFileFormat *pType );
	STDMETHOD(put_FileFormat)( enumFileFormat type );
	STDMETHOD(get_FileEncoding)( BSTR *pbstrEncoding );
	STDMETHOD(put_FileEncoding)( BSTR bstrEncoding );
	STDMETHOD(get_IsDirty)(/*[out, retval]*/ VARIANT_BOOL *pVal);
	STDMETHOD(get_Keyword)( BSTR* bstrKeyword );
	STDMETHOD(put_Keyword)( BSTR bstrKeyword );
	STDMETHOD(get_VCProjectEngine)(IDispatch** projEngine);

	STDMETHOD(get_ProjectGUID)( BSTR* bstrGUID );
	STDMETHOD(put_ProjectGUID)( BSTR bstrGUID );
	STDMETHOD(get_OwnerKey)( BSTR* bstrName );
	STDMETHOD(put_OwnerKey)( BSTR bstrName );
	STDMETHOD(get_SccProjectName)( BSTR* bstrName );
	STDMETHOD(put_SccProjectName)( BSTR bstrName );
	STDMETHOD(get_SccAuxPath)( BSTR* bstrName );
	STDMETHOD(put_SccAuxPath)( BSTR bstrName );
	STDMETHOD(get_SccLocalPath)( BSTR* bstrName );
	STDMETHOD(put_SccLocalPath)( BSTR bstrName );
	STDMETHOD(get_SccProvider)( BSTR* bstrName );
	STDMETHOD(put_SccProvider)( BSTR bstrName );

	STDMETHOD(Save)();
	STDMETHOD(SaveProjectOptions)(/*[in]*/ IUnknown *pStreamUnk);
	STDMETHOD(LoadProjectOptions)(/*[in]*/ IUnknown *pStreamUnk);

	STDMETHOD(AddFilter)(BSTR bstrFilterName, /*[out, retval]*/ IDispatch * *ppDisp);
	STDMETHOD(CanAddFilter)(BSTR bstrFilter, VARIANT_BOOL* pbCanAdd);
	STDMETHOD(RemoveFilter)(/*[in]*/  IDispatch *pItem);

	STDMETHOD(AddWebReference)(BSTR bstrUrl, IDispatch** ppFile);
	STDMETHOD(AddFile)(BSTR bstrPath, /*[out, retval]*/ IDispatch * *ppDisp);
	STDMETHOD(CanAddFile)(BSTR bstrFile, VARIANT_BOOL* pbCanAdd);
	STDMETHOD(RemoveFile)(/*[in]*/	IDispatch *pItem);

	STDMETHOD(AddConfiguration)(BSTR bstrConfigurationName);
	STDMETHOD(RemoveConfiguration)(IDispatch *pDispConfig);

	STDMETHOD(AddPlatform)(BSTR bstrPlatformName);
	STDMETHOD(RemovePlatform)(IDispatch* pPlatform);

// IVCProjectImpl
public:
	STDMETHOD(Close)();
	STDMETHOD(AddNewFile)(IDispatch * pFile, LPCOLESTR szRelativePath, VARIANT_BOOL bFireEvents);
	STDMETHOD(CanAddFile2)(BSTR bstrFile);
	STDMETHOD(CanAddFilter2)(BSTR bstrFilter, VARIANT_BOOL bSetErrorInfo);
	STDMETHOD(RemoveExistingFile)(IDispatch* pFile);
	STDMETHOD(SaveObject)(IStream *xml, IVCPropertyContainer *pPropContainer, long nIndent);
	STDMETHOD(FileNameValid)(LPCOLESTR szFileName, VARIANT_BOOL bSetErrorInfo);
	STDMETHOD(put_IsDirty)(VARIANT_BOOL boolDirty);
	STDMETHOD(put_IsConverted)(VARIANT_BOOL boolDirty);
	STDMETHOD(get_CanDirty)(VARIANT_BOOL* pbCanDirty);
	STDMETHOD(DoSave)(LPCOLESTR szFileName);
	STDMETHOD(GetGlobals)(IVCGlobals **ppGlobals);
	STDMETHOD(AddChild)(IDispatch* pChild);
	STDMETHOD(RemoveChild)(IDispatch* pChild);
	STDMETHOD(AddConfigurationInternal)(LPCOLESTR szConfigName);
	STDMETHOD(AddPlatformInternal)(LPCOLESTR szPlatformName);
	STDMETHOD(RemovePlatformInternal)(IDispatch* pPlatform);
	STDMETHOD(IsFileProbablyInProject)(LPCOLESTR szFile, VARIANT_BOOL* pb);
	STDMETHOD(AddWSDL)(BSTR bstrUrl, VCFilter* pFilter, IDispatch** ppFile);
	STDMETHOD(UpdateWSDL)(BSTR bstrUrl, VARIANT_BOOL bExists, BSTR *bstrWSDL);
	STDMETHOD(MakeOutputFileUnique)(VCFile* pFile);

protected:
	// for own use
	HRESULT FindFilter(BSTR bstrFileName, VCFilter **ppFilter);
	HRESULT FindSubFilter(BSTR bstrFileName, VCFilter *pFilterStart, VCFilter **ppFilter);
	HRESULT GetConfigFromVariant(VARIANT varConfiguration, IDispatch **ppDispVal);
	HRESULT AddPlatformConfig(IDispatch *pDispPlatform, LPCOLESTR bstrConfigName, BOOL bSearchExisting);
	HRESULT SetDirty(VARIANT_BOOL bDirty) { return put_IsDirty(bDirty); }
	HRESULT FindFile(BSTR bstrPath, IDispatch** ppDisp, BOOL bSetErrorInfo);
	HRESULT FindExistingFilter(BSTR bstrFilter, CStringW& strCleanedUpName, IDispatch** ppDisp, BOOL bSetErrorInfo);
	HRESULT WrapCanDirty();
	HRESULT DoRemoveExistingFile(IDispatch* pFile, BOOL bRemoveFromFilter);
	void BuildTopLevelItemsCollection();
	HRESULT RemoveConfigurationInternal(VCConfiguration *pConfig);
	HRESULT CheckCanAddFile(BSTR bstrFile, BOOL bSetErrorInfo);
	HRESULT CheckCanAddFilter(BSTR bstrFilter, CStringW& strCleanedUpName, BOOL bSetErrorInfo);

public:
	// helpers
	static HRESULT QueryCanAddFile(VCProject* pProj, VCFilter* pFilter, LPCOLESTR szFile, BOOL bSetErrorInfo);
	static BOOL ForwardTrackEvents(VCFilter* pFilterParent);
	static HRESULT InformFileAdded(VCProject* pProject, VCFile* pFile, BSTR bstrFilePath);
	HRESULT QueryCanRemoveFile(VCFile* pFile);
	HRESULT InformFileRemoved(VCFile* pFile, BSTR bstrFilePath);

protected:
	static BOOL DetermineFileParentFilter(VCFile* pFile, CComQIPtr<VCFilter>& rspFilterParent);

// IVCCollectionProvider
public:
	STDMETHOD(UpdateItemsCollection)(DWORD dwCookie);

// IVCBuildableItem
public:
	STDMETHOD(get_ItemFileName)(BSTR *pVal);
	STDMETHOD(get_ItemFullPath)(BSTR* pbstrFullPath);
	STDMETHOD(get_ActionList)(IVCBuildActionList** ppActions);
	STDMETHOD(get_FileRegHandle)(void** pfrh);
	STDMETHOD(AssignActions)(VARIANT_BOOL bOnOpen);
	STDMETHOD(UnAssignActions)(VARIANT_BOOL bOnClose);
	STDMETHOD(get_ContentList)(IEnumVARIANT** ppContentList);
	STDMETHOD(get_Registry)(void** pFileRegistry);
	STDMETHOD(get_ProjectConfiguration)(VCConfiguration** ppProjCfg);
	STDMETHOD(get_ProjectInternal)(VCProject** ppProject);
	STDMETHOD(get_ExistingBuildEngine)(IVCBuildEngine** ppBldEngine);
	STDMETHOD(get_PersistPath)(BSTR* pbstrPersistPath);
	STDMETHOD(RefreshActionOutputs)(long nPropID, IVCBuildErrorContext* pEC);
	STDMETHOD(HandlePossibleCommandLineOptionsChange)(IVCBuildErrorContext* pEC);
	STDMETHOD(ClearDirtyCommandLineOptionsFlag)();

//	IVCExternalCookie
	STDMETHOD(get_ExternalCookie)(void** ppVal) { *ppVal =	m_pExternalCookie; return S_OK; }
	STDMETHOD(put_ExternalCookie)(void* pVal) { m_pExternalCookie = pVal; return S_OK; }

// IPerPropertyBrowsing
public:
	STDMETHOD(GetDisplayString)( DISPID dispID, BSTR *pBstr ) { return E_NOTIMPL; }
	STDMETHOD(MapPropertyToPage)( DISPID dispID, CLSID *pClsid ) { return E_NOTIMPL; }
	STDMETHOD(GetPredefinedStrings)( DISPID dispID, CALPOLESTR *pCaStringsOut, CADWORD *pCaCookiesOut ) { return E_NOTIMPL; }
	STDMETHOD(GetPredefinedValue)( DISPID dispID, DWORD dwCookie, VARIANT* pVarOut ) { return E_NOTIMPL; }
// IVsPerPropertyBrowsing
public:
	STDMETHOD(HideProperty)( DISPID dispid, BOOL *pfHide) { return E_NOTIMPL; }
	STDMETHOD(DisplayChildProperties)( DISPID dispid, BOOL *pfDisplay) { return E_NOTIMPL; }
	STDMETHOD(HasDefaultValue)( DISPID dispid, BOOL *pfDefault) { return E_NOTIMPL; }
	STDMETHOD(IsPropertyReadOnly)( DISPID dispid, BOOL *fReadOnly);
	STDMETHOD(GetLocalizedPropertyInfo)( DISPID dispid, LCID localeID, BSTR *pbstrName, BSTR *pbstrDesc);
	STDMETHOD(GetClassName)(BSTR* ) {return E_NOTIMPL;} 
	STDMETHOD(CanResetPropertyValue)(DISPID , BOOL* ) {return E_NOTIMPL;}	
	STDMETHOD(ResetPropertyValue)(DISPID ) {return E_NOTIMPL;}

};

#endif // !defined(AFX_PROJECT_H__625C6496_2C7E_11D3_87BF_A0494CC10000__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\vcpb\projectoptions.h ===
// ProjectOptions.h - definition of basic option handling code and tables

#pragma once

/* option table choices and meanings
OPT_ENUM() - enumerated list
OPT_BOOL() - boolean (degenerate enumerated list with two elements)
OPT_BSTR() - string, switch only evaluated if non-empty (will be quoted if it isn't already)
OPT_BSTR_NOQUOTE() - string, switch only evaluated if non-empty (quotes will not be automagically added)
OPT_BSTR_SPECIAL() - string, switch only evaluated if non-empty, derived option handler class responsible
						for generating specific switch
OPT_INT()  - integer element
OPT_INT_NOZERO()	- integer element, but only generate switch if non-zero
OPT_ENUM_SET_COND() - enumerated list; if non-zero, then evaluate conditional property to this one
OPT_BOOL_SET_COND() - boolean; if TRUE, then evaluate conditional properties to this one
OPT_INT_NOZERO_SET_COND() - integer element, only generate switch if non-zero, evaluate conditional
								property if non-zero
OPT_INT_COND()		- only evaluate this integer switch if the property it depends on is TRUE 
						  (or non-zero for an enumerated property).  The '/' is not generated 
						  automagically.
OPT_INT_NOZERO_COND() - only evaluate this integer switch if the property it depends on is TRUE
						  (or non-zero for an enumerated property) AND the property itself is
						  non-zero.  The '/' is not generated automagically.
OPT_BSTR_COND()		- only evaluate this string switch if the property it depends on is TRUE 
						  (or non-zero for an enumerated property).  No switch generated if the
						  storage element is non-empty.  The '/' is not generated automagically.
OPT_INT_NOZERO_COND_CASCADE() - cascading conditional integer switch (i.e., has both a parent property
						and a conditional property).
parser special characters:
- '|' separates options in an enum or boolean
- false condition always comes first in a set
- %<> means format the storage contents into that spot using the specified printf formatting specified by <>
*/

#include <vccolls.h>

const wchar_t* const wszDefaultString = L"";

// forward declarations
class CLookupByDispidMap;
class CLookupByPropertyNameMap;

typedef enum
{
	stdOptEnum,			// option is an enum
	stdOptBool,			// option is a BOOL
	stdOptBstr,			// option is a string (quote it)
	stdOptBstrNoQuote,	// option is a string (don't quote it)
	stdOptInt,			// option is an integer
	noZeroOptInt,		// option is an integer where it must be non-zero to generate a switch
	specOptBstr,		// option is a string with special handling required
	stdOptEnd			// option is the end of the option table
} optionEntryType;

typedef enum
{
	conditionNone,		// doesn't set or have any conditional properties
	conditionSet,		// evaluate the specified conditional property iff non-zero
	conditionProp		// evaluate only if asked directly (i.e., by the prop we're conditional on)
} conditionalOption;

// what type is the option?
typedef enum {single, multiple, multipleNoCase} OptType;

// special option page values
#define NO_HYPERLINK		-1
#define SPECIAL_HYPERLINK	-2

// our definition of an option
struct SOptionEntry
{
	long				idOption;
	const wchar_t *		szOptionName;
	const wchar_t *		szOption;
	int					nStartEnumRange;
	int					nEndEnumRange;
	long				idOptionPage;
	conditionalOption	condType;
	int					nFirstTrue;
	long				idParentOption;
	long				idConditionalOption;
	OptType				type;
	optionEntryType		entryType;
};

#define NoParentProp	0
#define NoNextProp		0

// our tool option tables
#define BEGIN_OPTION_TABLE(tool, szToolString, idSection, fSupportsAdditionalOptions, fCaseSensitive) \
	const BOOL tool::IsCaseSensitive() \
		{ return fCaseSensitive; } \
	const BOOL tool::SupportsAdditionalOptions() \
		{ return fSupportsAdditionalOptions; } \
	const wchar_t * tool::ToolString() \
		{ return szToolString; } \
	const long tool::SectionID() \
		{ return idSection; } \
	BOOL tool::s_bDispidMapInitialized = FALSE; \
	BOOL tool::s_bPropertyNameMapInitialized = FALSE; \
	SOptionEntry tool::m_pOptionEntries[] = {

#define END_OPTION_TABLE() \
	{ 0, L"", L"", 0, 0, 0, conditionNone, 0, NoParentProp, NoNextProp, single, stdOptEnd }};

// declare the option string table
#define DECLARE_OPTION_TABLE() \
public: \
	virtual const BOOL IsCaseSensitive(); \
	virtual const BOOL SupportsAdditionalOptions(); \
	virtual const wchar_t * ToolString(); \
	virtual SOptionEntry* GetOptionTable() { return (SOptionEntry *)m_pOptionEntries; } \
	virtual BOOL PropertyNameLookupIsInitialized() { return s_bPropertyNameMapInitialized; } \
	virtual BOOL DispidLookupIsInitialized() { return s_bDispidMapInitialized; } \
	LPCOLESTR GetSectionString() { if (SectionID() && m_strSectionName.IsEmpty()) m_strSectionName.LoadString(SectionID()); return m_strSectionName; } \
protected: \
	virtual void SetPropertyNameLookupInitialized(BOOL bInit = TRUE) { s_bPropertyNameMapInitialized = bInit; } \
	virtual void SetDispidLookupInitialized(BOOL bInit = TRUE) { s_bDispidMapInitialized = bInit; } \
	virtual const long SectionID(); \
protected: \
	static BOOL s_bDispidMapInitialized; \
	static BOOL s_bPropertyNameMapInitialized; \
	static SOptionEntry m_pOptionEntries[]; \
	CStringW m_strSectionName;

#define OPT_ENUM(prop, propSwitch, startRange, endRange, propName, pageID, idRange) \
	{ idRange##_##prop, propName, propSwitch, startRange, endRange, pageID, conditionNone, 0, NoParentProp, NoNextProp, single, stdOptEnum },
#define OPT_ENUM_SPECIAL(prop, propSwitch, startRange, endRange, propName, pageID, idRange) \
	{ idRange##_##prop, propName, propSwitch, startRange, endRange, pageID, conditionNone, 0, NoParentProp, NoNextProp, single, stdOptEnum },
#define OPT_ENUM_SET_COND(prop, propSwitch, startRange, endRange, firstTrue, propName, nextProp, pageID, idRange) \
	{ idRange##_##prop, propName, propSwitch, startRange, endRange, pageID, conditionSet, firstTrue, NoParentProp, idRange##_##nextProp, single, stdOptEnum },
#define OPT_BOOL(prop, propSwitch, propName, pageID, idRange) \
	{ idRange##_##prop, propName, propSwitch, 0, 0, pageID, conditionNone, 0, NoParentProp, NoNextProp, single, stdOptBool },
#define OPT_BOOL_SET_COND(prop,	propSwitch, propName, nextProp, pageID, idRange) \
	{ idRange##_##prop, propName, propSwitch, 0, 0, pageID, conditionSet, 0, NoParentProp, idRange##_##nextProp, single, stdOptBool },
#define OPT_BSTR(prop, propSwitch, propName, opt_type, pageID, idRange) \
	{ idRange##_##prop, propName, propSwitch, 0, 0, pageID, conditionNone, 0, NoParentProp, NoNextProp, opt_type, stdOptBstr },
#define OPT_BSTR_NOQUOTE(prop, propSwitch, propName, opt_type, pageID, idRange) \
	{ idRange##_##prop, propName, propSwitch, 0, 0, pageID, conditionNone, 0, NoParentProp, NoNextProp, opt_type, stdOptBstrNoQuote },
#define OPT_BSTR_SPECIAL(prop, propSwitch, propName, opt_type, pageID, idRange) \
	{ idRange##_##prop, propName, propSwitch, 0, 0, pageID, conditionNone, 0, NoParentProp, NoNextProp, opt_type, specOptBstr },
#define OPT_BSTR_COND(prop, propSwitch, propName, parentProp, opt_type, pageID, idRange) \
	{ idRange##_##prop, propName, propSwitch, 0, 0, pageID, conditionProp, 0, idRange##_##parentProp, NoNextProp, opt_type, stdOptBstr },
#define OPT_BSTR_COND_NOQUOTE(prop, propSwitch, propName, parentProp, opt_type, pageID, idRange) \
	{ idRange##_##prop, propName, propSwitch, 0, 0, pageID, conditionProp, 0, idRange##_##parentProp, NoNextProp, opt_type, stdOptBstrNoQuote },
#define OPT_INT(prop, propSwitch, propName, pageID, idRange) \
	{ idRange##_##prop, propName, propSwitch, 0, 0, pageID, conditionNone, 0, NoParentProp, NoNextProp, single, stdOptInt },
#define OPT_INT_NOZERO(prop, propSwitch, propName, pageID, idRange) \
	{ idRange##_##prop, propName, propSwitch, 0, 0, pageID, conditionNone, 0, NoParentProp, NoNextProp, single, noZeroOptInt },
#define OPT_INT_NOZERO_SET_COND(prop, propSwitch, propName, nextProp, pageID, idRange) \
	{ idRange##_##prop, propName, propSwitch, 0, 0, pageID, conditionSet, 0, NoParentProp, idRange##_##nextProp, single, noZeroOptInt },
#define OPT_INT_COND(prop, propSwitch, propName, parentProp, pageID, idRange) \
	{ idRange##_##prop, propName, propSwitch, 0, 0, pageID, conditionProp, 0, idRange##_##parentProp, NoNextProp, single, stdOptInt },
#define OPT_INT_NOZERO_COND(prop, propSwitch, propName, parentProp, pageID, idRange) \
	{ idRange##_##prop, propName, propSwitch, 0, 0, pageID, conditionProp, 0, idRange##_##parentProp, NoNextProp, single, noZeroOptInt },
#define OPT_INT_NOZERO_COND_CASCADE(prop, propSwitch, propName, parentProp, nextProp, pageID, idRange) \
	{ idRange##_##prop, propName, propSwitch, 0, 0, pageID, conditionProp, 0, idRange##_##parentProp, idRange##_##nextProp, single, noZeroOptInt },

class CLookupByDispidMap : public CVCMapDWordToPtr
{
public:
	SOptionEntry* FindOptionEntry(DISPID dispidProperty);
};

class CLookupByPropertyNameMap : public CVCMapStringWToPtr
{
public:
	SOptionEntry* FindOptionEntry(BSTR bstrProperty);
};

// pure base class used for generating switches and full command lines
class COptionHandlerBase
{
public:
	COptionHandlerBase() : m_idLastOptionPage(-1) {}
	virtual ~COptionHandlerBase() {}

	CLookupByDispidMap* GetOptionLookupByDispid(BOOL bInitialize = TRUE) 
	{ 
		if (bInitialize)
			InitializeDispidMap();
		return &m_optLookupByDispid; 
	} 
	CLookupByPropertyNameMap* GetOptionLookupByPropertyName(BOOL bInitialize = TRUE) 
	{ 
		if (bInitialize)
			InitializePropertyNameMap();
		return &m_optLookupByPropertyName; 
	} 

	virtual HRESULT GenerateCommandLine(IVCPropertyContainer* pPropContainer, BOOL bForDisplay, commandLineOptionStyle fStyle, 
		CStringW& rstrCmdLine);
	virtual HRESULT ProcessEntry(IVCPropertyContainer* pPropContainer, SOptionEntry* pEntry, CStringW& strOption, 
		commandLineOptionStyle fStyle, CStringW& rstrTrailing, BOOL bIncludeOptionalParts = TRUE, BOOL bIncludeSlash = TRUE, 
		BOOL bForDisplay = FALSE);
	void AdvanceCommandLine(CStringW& rstrCmdLine, CStringW& rstrOption, LPCOLESTR szSep = L" ");
	void GetTrailingCommandLinePart(CStringW& strTrailing) { strTrailing = m_strTrailingPartForDisplay; }
	HRESULT FindSwitch(IVCPropertyContainer* pPropContainer, BSTR bstrProp, DISPID dispidProp, CStringW& rstrSwitch);
	LPCOLESTR PageName(long idOptionPage);
	LPCOLESTR ToolUIName();
	virtual void GetMultiPropSeparator(long id, BSTR* pbstrPreferred, BSTR* pbstrAll);

	virtual void InitializeDispidMap(BOOL bForce = FALSE);
	virtual void InitializePropertyNameMap(BOOL bForce = FALSE);

	// this block of methods is overridden in the declaration/definition of the option table
	virtual const BOOL IsCaseSensitive() PURE;
	virtual const BOOL SupportsAdditionalOptions() PURE;
	virtual SOptionEntry* GetOptionTable() PURE;
	virtual BOOL PropertyNameLookupIsInitialized() PURE;
	virtual BOOL DispidLookupIsInitialized() PURE;
	virtual const wchar_t * ToolString() PURE;
	virtual const long SectionID() PURE;

	// default value handlers
	virtual void GetDefaultValue( long id, BSTR *pVal, IVCPropertyContainer *pPropCnt = NULL ) PURE;
	virtual void GetDefaultValue( long id, long *pVal, IVCPropertyContainer *pPropCnt = NULL ) PURE;
	virtual void GetDefaultValue( long id, VARIANT_BOOL *pVal, IVCPropertyContainer *pPropCnt = NULL ) PURE;

	// default value helpers
	static HRESULT GetValueTrue(VARIANT_BOOL* pbVal)
	{
		*pbVal = VARIANT_TRUE;
		return S_OK;
	}

	static HRESULT GetValueFalse(VARIANT_BOOL* pbVal)
	{
		*pbVal = VARIANT_FALSE;
		return S_OK;
	}

	static HRESULT GetDefaultString(BSTR* pbstrVal)
	{
		CComBSTR bstrRet( wszDefaultString );
		*pbstrVal = bstrRet.Detach();
		return S_OK;
	}

protected:
	void EvaluateEnumAtIndex(int nVal, LPCOLESTR szOption, BOOL bIncludeSlash, CStringW& rstrSwitch);
	void EvaluateString(CStringW& rstrVal, BOOL bIsMultiple, LPCOLESTR szOption, LPCOLESTR szOptionName, long idOption, 
		long idOptionPage, BOOL bIncludeSlash, BOOL bQuoteIt, BOOL bForDisplay, CStringW& rstrSwitch);
	void EvaluateInteger(long nVal, LPCOLESTR szOption, BOOL bIncludeSlash, CStringW& rstrSwitch);
	BOOL GetIntermediateDirectoryForFileCfg(IVCPropertyContainer* pPropContainer, CStringW& rstrIntDir);
	BOOL GetFileNameForFileCfg(IVCPropertyContainer* pPropContainer, CStringW& rstrFileName);
	BOOL GetProjectForFileCfg(IVCPropertyContainer* pPropContainer, VCProject** ppProject);
	BOOL SetBstrInVariant(IVCPropertyContainer* pPropContainer, CComBSTR& bstrVal, CComVariant& rvar);
	virtual void EvaluateSpecialEnumAtIndex(int nVal, LPCOLESTR szOption, long idOption,
		IVCPropertyContainer* pPropContainer, BOOL bIncludeSlash, CStringW& rstrSwitch) 
		{ EvaluateEnumAtIndex(nVal, szOption, bIncludeSlash, rstrSwitch); }
	virtual void EvaluateSpecialString(CStringW& rstrVal, BOOL bIsMultiple, LPCOLESTR szOption, long idOption,
		LPCOLESTR szOptionName, long idOptionPage, IVCPropertyContainer* pPropContainer, BOOL bIncludeSlash, 
		BOOL bForDisplay, commandLineOptionStyle fStyle, CStringW& rstrTrailing, CStringW& rstrSwitch) 
		{ EvaluateString(rstrVal, bIsMultiple, szOption, szOptionName, idOption, idOptionPage, bIncludeSlash, TRUE, bForDisplay, 
			rstrSwitch); }
	virtual BOOL CharIsSeparator(wchar_t ch) { return (ch == L';') || (ch == L','); }
	virtual BOOL SetEvenIfDefault(VARIANT *pvarDefault, long idOption) { return FALSE; }
	virtual BOOL SynthesizeOptionIfNeeded(IVCPropertyContainer* pPropContainer, long idOption)
		{ return FALSE; }
	virtual BOOL SynthesizeOption(IVCPropertyContainer* pPropContainer, long idOption, CComVariant& rvar) 
		{ VSASSERT(FALSE, "Must override base class implementation of SynthesizeOption if SynthesizeOptionIfNeeded is implemented"); return FALSE; }
	virtual BOOL OverrideOptionSet(IVCPropertyContainer* pPropContainer, long idOption)
		{ return FALSE; }
	virtual void FormatScriptItem(const wchar_t* szOptionName, long idOption, long idOptionPage, CStringW& rstrOption);

	// this block of methods is overridden in the declaration/definition of the option table
	virtual void SetPropertyNameLookupInitialized(BOOL bInit = TRUE) PURE;
	virtual void SetDispidLookupInitialized(BOOL bInit = TRUE) PURE;

protected:
	CLookupByDispidMap m_optLookupByDispid;
	CLookupByPropertyNameMap m_optLookupByPropertyName;
	CStringW m_strToolUIName;
	CStringW m_strOptionPage;
	CStringW m_strTrailingPartForDisplay;
	long m_idLastOptionPage;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\vcpb\ProjEvaluator.h ===
// CProjectEvaluator does macro expansion for property containers that are objects in the project system

#pragma once

#include <vcids.h>
#include <vccolls.h>
#include <path2.h>

class CProjectEvaluator
{
public:
	CProjectEvaluator() { m_nDepth = 0; }
	virtual ~CProjectEvaluator() {}

public:
	BOOL MapMacroNameToId(const wchar_t* pchName, int& cchName, UINT& idMacro);
	BOOL MapMacroIdToName(UINT idMacro, CStringW& strName);
	HRESULT ExpandMacros(BSTR* pbstrOut, BSTR bstrIn, IVCPropertyContainer* pPropContainer, BOOL bNoEnvVars, long idProp = 0);

protected:
	virtual BOOL GetMacroValue(UINT idMacro, CStringW& strMacroValue, IVCPropertyContainer* pPropContainer);

	BOOL GetSolutionPath(CPathW& rSolnPath);
	BOOL GetSolutionDirectory(CStringW& rstrDir);
	BOOL GetProjectDirectoryPath(IVCPropertyContainer* pPropContainer, CPathW& rProjDirPath, CStringW& rstrProjDirPath, 
		BOOL bNormalize);
	BOOL GetProjectDirectoryDir(IVCPropertyContainer* pPropContainer, CDirW& rProjDir);
	HRESULT ValidateMacro(UINT idMacro, long idProp);
	BOOL NoInheritOnMultiProp(BSTR bstrVal, LPCOLESTR szSeparator, BSTR* pbstrValue);
	HRESULT MakeMultiPropString(CComBSTR& bstrLocal, CComBSTR& bstrParent, LPCOLESTR szSeparator, BSTR* pbstrValue);
	void GetBuildEngine(IVCPropertyContainer* pPropContainer, CComPtr<IVCBuildEngine>& spBuildEngine);
	HRESULT CollapseMultiples(BSTR bstrIn, LPCOLESTR szSeparator, VARIANT_BOOL bCaseSensitive, BSTR* pbstrOut);
	int DoFindItem(CStringW& rstrItems, CStringW& rstrFindItem, CStringW& strSeparator, int nStart);
	void NormalizeDirectoryString(CStringW& strDir);
	BOOL EvalIntDirOutDir(IVCPropertyContainer* pPropContainer, BOOL bIsIntDir, CStringW& strMacroValue);
	BOOL EvalProjectMacroValue(IVCPropertyContainer* pPropContainer, UINT idMacro, CStringW& strMacroValue);
	BOOL EvalTargetMacroValue(IVCPropertyContainer* pPropContainer, UINT idMacro, CStringW& strMacroValue);
	BOOL EvalInputMacroValue(IVCPropertyContainer* pPropContainer, UINT idMacro, CStringW& strMacroValue);
	void GetDebuggerProperty(IVCPropertyContainer* pPropContainer, long idProp, CStringW& strMacroValue);
	void EvalFrameworkMacro(UINT idMacro, CStringW& strMacroValue);
private:
	int m_nDepth;
	long m_nLastMacroID;

	static CStringW s_strVCDir;
	static CStringW s_strVSDir;
	static CStringW s_strComDir;
	static CStringW s_strComVer;
	static CStringW s_strComSDKDir;
	static bool s_bComDirsInit;
};

//----------------------------------------------------------------
// primitive custom build 'tool macros'
//----------------------------------------------------------------

#define IDMACRO_PLATNAME	1000
#define IDMACRO_ENVDIR		1001
#define IDMACRO_CFGNAME		1002
#define IDMACRO_OUTDIR		1003
#define IDMACRO_INTDIR		1004

#define IDMACRO_SOLNDIR		1005
#define IDMACRO_SOLNPATH	1006
#define IDMACRO_SOLNBASE	1007
#define IDMACRO_SOLNFILE	1008
#define IDMACRO_SOLNEXT		1009

#define IDMACRO_PROJDIR		1010
#define IDMACRO_PROJPATH	1011
#define IDMACRO_PROJBASE	1012
#define IDMACRO_PROJFILE	1013
#define IDMACRO_PROJEXT		1014

#define IDMACRO_TARGDIR		1015
#define IDMACRO_TARGPATH	1016
#define IDMACRO_TARGBASE	1017
#define IDMACRO_TARGFILE	1018
#define IDMACRO_TARGEXT		1019

#define IDMACRO_INPTDIR		1020
#define IDMACRO_INPTPATH	1021
#define IDMACRO_INPTBASE	1022
#define IDMACRO_INPTFILE	1023
#define IDMACRO_INPTEXT		1024

#define IDMACRO_REMOTEMACH	1025

#define IDMACRO_VCDIR		1026
#define IDMACRO_VSDIR		1027
#define IDMACRO_COMDIR		1028
#define IDMACRO_COMSDKDIR	1029
#define IDMACRO_COMVER		1030

#define IDMACRO_INHERIT		1031
#define IDMACRO_NOINHERIT	1032

#define IDMACRO_FIRST		IDMACRO_PLATNAME
#define IDMACRO_LAST		IDMACRO_NOINHERIT
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\vcpb\Project.cpp ===
// Project.cpp : Implementation of 

#include "stdafx.h"
#include "Project.h"
#include "file.h"
#include "configuration.h"
#include "filter.h"
#include "VCProjectEngine.h"
#include "Collection.h"
#include "vccoll.h"
#include "vcmap.h"
#include "BuildEngine.h"
#include "vctool.h"
#include "xmlfile.h"
#include "ProjWriter.h"
#include "util2.h"

class CInProjectClose
{
public:
	CInProjectClose() { m_bOldInClose = g_bInProjClose; g_bInProjClose = TRUE; }
	~CInProjectClose() { g_bInProjClose = m_bOldInClose; }
	BOOL m_bOldInClose;
};

/////////////////////////////////////////////////////////////////////////////
//
HRESULT CProject::CreateInstance(VCProject **ppDispInfo)
{
	HRESULT hr;
	CProject *pVar;
	CComObject<CProject> *pObj;
	hr = CComObject<CProject>::CreateInstance(&pObj);
	if (SUCCEEDED(hr))
	{
		pVar = pObj;
		pVar->AddRef();
		*ppDispInfo = pVar;
		
	}
	return hr;
}

CProject::CProject() :
	m_frh( NULL ),
	m_bDirty( VARIANT_FALSE ),
	m_pExternalCookie( NULL ),
	m_bAssignedActions( false ),
	m_pGlobals( NULL ),
	m_eFileFormat( eANSI ),
	m_bItemsCollectionDirty(true),
	m_wCloseFlag(closeFlagOpenClean)
{
}

CProject::~CProject()
{
	IDispatch* pDisp = this;
	CBldProjectRecord* pProjRecord = g_StaticBuildEngine.GetProjectRecord(pDisp, FALSE);
	VSASSERT(pProjRecord == NULL, "project record should have been disposed of on project close, not object destruction");
	if (pProjRecord)
		g_StaticBuildEngine.RemoveProjectRecord(pDisp);
	VSASSERT(m_frh == NULL, "file reg handle should have been disposed of on project close, not object destruction");
	if (m_frh)
		m_frh->ReleaseFRHRef();
	m_ProjectRegistry.SetFileRegistry(NULL);
	if( m_pGlobals )
		m_pGlobals->Release();
}

STDMETHODIMP CProject::Close()
{
	m_wCloseFlag |= closeFlagClosed;
	long l, lcItems;
	CInProjectClose inClose;

	if (m_bAssignedActions)
		UnAssignActions(VARIANT_TRUE);

	m_rgTopLevelItems.RemoveAll();
	m_bItemsCollectionDirty = true;

	lcItems = m_rgFiles.GetSize();
	for (l = 0; l < lcItems; l++)
	{
		CComPtr<VCFile> pFile;
		pFile = m_rgFiles.GetAt(l);
		CComQIPtr<IVCFileImpl> pFileImpl = pFile;
		if (pFileImpl)
			pFileImpl->Close(); // close down entirely; release all
	}
	m_rgFiles.RemoveAll();		// collection of files for this project

	lcItems = m_rgConfigs.GetSize();
	for (l = 0; l < lcItems; l++)
	{
		CComPtr<VCConfiguration> pConfiguration;
		pConfiguration = m_rgConfigs.GetAt(l);
		CComQIPtr<IVCConfigurationImpl> pConfigurationImpl = pConfiguration;
		if (pConfigurationImpl)
			pConfigurationImpl->Close(); // close down entirely; release all
	}
	m_rgConfigs.RemoveAll();	// collection of configs for this project

	lcItems = m_rgFilters.GetSize();
	for (l = 0; l < lcItems; l++)
	{
		CComPtr<VCFilter> pFilter;
		pFilter = m_rgFilters.GetAt(l);
		CComQIPtr<IVCFilterImpl> pFilterImpl = pFilter;
		if (pFilterImpl)
			pFilterImpl->Close(); // close down entirely; release all
	}
	m_rgFilters.RemoveAll();		// collection of Filters for this project

	if (m_frh)
	{
		m_frh->ReleaseFRHRef();
		m_frh = NULL;
	}

	m_rgPlatforms.RemoveAll();	// collection of platforms for this project

	g_StaticBuildEngine.RemoveProjectRecord(this);

	return S_OK;
}

STDMETHODIMP CProject::AddPlatform(BSTR bstrPlatform)
{
	if (g_bInProjLoad)	// solution already checking for platforms being added
		return AddPlatformInternal(bstrPlatform);

	if (CVCProjectEngine::s_pBuildPackage != NULL)	// let the build package handle letting the solution in on this
		return CVCProjectEngine::s_pBuildPackage->AddPlatformToProject(this, bstrPlatform);

	return AddPlatformInternal(bstrPlatform);
}

STDMETHODIMP CProject::AddPlatformInternal(LPCOLESTR szPlatformName)
{
	// if no configs
	//	Add debug and release
	// else
	//for each platform
	// pCfg = CConfiguration::CreateInstance(pPlatform);
	// Add to config list
	// for each pFile
	//		pFile->AddConfig(pCfg)


	HRESULT hrLoop, hrT, hr;
	int iMac;
	int iIndex;
	CComPtr<IDispatch> pDispPlatform;
	CComQIPtr<VCPlatform> pPlatform;
	
	hr = VCPROJ_E_NOT_FOUND;
	iMac = m_rgPlatforms.GetSize();
	hrLoop = VCPROJ_E_NOT_FOUND;
	for (iIndex = 0; iIndex < iMac && hrLoop != S_FALSE; iIndex++)
	{
		pPlatform = m_rgPlatforms.GetAt(iIndex);
		if (pPlatform == NULL)
			continue;

		CComBSTR bstrName;
		hrT = pPlatform->get_Name(&bstrName);
		if (_wcsicmp(bstrName, szPlatformName) == 0)
		{
			hrLoop = S_FALSE;
			pDispPlatform = pPlatform;
			hr = S_FALSE;
		}
	}

	if (FAILED(hrLoop))
	{ // see if we have a platform of the same name in the global collection
		CComPtr<IDispatch> pDispPlatformList;
		hr = g_pProjectEngine->get_Platforms(&pDispPlatformList);
		CComQIPtr<IVCCollection> pPlatformList = pDispPlatformList;
		if (SUCCEEDED(hr) && pPlatformList)
		{
			long lcItemsToFetch;
			long i;

			pPlatformList->get_Count(&lcItemsToFetch);
			i = 1;
			while (lcItemsToFetch && hrLoop == VCPROJ_E_NOT_FOUND)
			{
				CComVariant varItem = i;
				CComPtr<IDispatch> spDispPlatform2;
				pPlatformList->Item(varItem, &spDispPlatform2);
				pDispPlatform = spDispPlatform2;
				pPlatform = pDispPlatform;
				if (pPlatform == NULL)
					continue;
				CComBSTR bstrName;
				pPlatform->get_Name(&bstrName);
				if (_wcsicmp(bstrName, szPlatformName) == 0)
				{
					hrLoop = S_OK;
					hr = S_OK;
				}
				lcItemsToFetch--;
				i++;
			}
		}
#ifdef NEW_FEATURE_LATER
		if (FAILED(hr))
		{	// create a new platform
			hr = g_pProjectEngine->AddPlatform(bstrPlatform, &pDispPlatform);
		}
#endif
	}

	if (hr == S_OK && pPlatform) // now create new project-configs for the new platform; S_FALSE means it is there already
	{
		CHECK_OK_TO_DIRTY(0);
		m_rgPlatforms.Add(pPlatform);
		// fire an event so the ui becomes aware of the new platform
		CComQIPtr<IVCProjectEngineImpl> pEngine = g_pProjectEngine;
		if( pEngine )
		{
			CComQIPtr<IDispatch> pDispPlatform = pPlatform;
			if( pDispPlatform )
				pEngine->DoFireItemAdded( pDispPlatform, static_cast<IDispatch*>(this) );
		}
		iMac = m_rgConfigs.GetSize();
		if (iMac == 0) // no configs yet added to this project!
		{
// 			// set up the project with default configs and platforms
//  			AddConfiguration(L"Debug");
//  			AddConfiguration(L"Release");
		}
		else
		{
			for (iIndex = 0; iIndex <= iMac; iIndex++)
			{
				CComPtr<VCConfiguration> pConfiguration = m_rgConfigs.GetAt(iIndex);
				if (pConfiguration == NULL)
					continue;
				CComBSTR bstrName;
				hrT = pConfiguration->get_ConfigurationName(&bstrName);
				VSASSERT(SUCCEEDED(hrT), "Configurations without names are generally zombie.");
				hrT = AddPlatformConfig(pDispPlatform, bstrName, m_rgPlatforms.GetSize() > 2);
				VSASSERT(SUCCEEDED(hrT), "Out of memory, perhaps?");
				if (hrT == S_FALSE)	// may be trying to add a config that is already there; if so, override the S_FALSE
					hrT = S_OK;
			}
		}
	}

	if (hr == VCPROJ_E_NOT_FOUND)
		return CVCProjectEngine::DoSetErrorInfo2(VCPROJ_E_NOT_FOUND, IDS_ERR_PLATFORM_NOT_FOUND, szPlatformName);

	return hr;
}

STDMETHODIMP CProject::AddConfigurationInternal(LPCOLESTR szConfigName)
{
	// check for empty string
	CStringW strConfigName = szConfigName;
	strConfigName.TrimLeft();
	strConfigName.TrimRight();
	if (strConfigName.IsEmpty())
		RETURN_INVALID();

	CHECK_OK_TO_DIRTY(0);

	HRESULT hr = VCPROJ_E_NO_PLATFORMS;
	int iIndex;
	int iMac  = m_rgPlatforms.GetSize();
	for (iIndex = 0; iIndex < iMac; iIndex++) // we only add a config for the platforms this project knows about
	{
		CComQIPtr<IDispatch> pDispPlatform = m_rgPlatforms.GetAt(iIndex);
		if (pDispPlatform == NULL)
			continue;

		hr = AddPlatformConfig(pDispPlatform, strConfigName, m_rgPlatforms.GetSize() > 1);
		VSASSERT(SUCCEEDED(hr), "Out of memory, perhaps?");
		if (hr == S_FALSE)	// get around trying to add same config twice...
			hr = S_OK;
	}

	if (hr == VCPROJ_E_NO_PLATFORMS)
		return CVCProjectEngine::DoSetErrorInfo2(VCPROJ_E_NO_PLATFORMS, IDS_ERR_NO_PROJ_PLATFORMS, m_bstrName);
	return hr;
}

STDMETHODIMP CProject::AddConfiguration(BSTR bstrConfigName)
{
	if (g_bInProjLoad)	// solution already checking for configs being added
		return AddConfigurationInternal(bstrConfigName);

	if (CVCProjectEngine::s_pBuildPackage != NULL)	// let the build package handle letting the solution in on this
		return CVCProjectEngine::s_pBuildPackage->AddConfigurationToProject(this, bstrConfigName);

	return AddConfigurationInternal(bstrConfigName);
}

HRESULT CProject::FindFile(BSTR bstrPath, IDispatch** ppDisp, BOOL bSetErrorInfo)
{
	*ppDisp = NULL;		// this is an internal function, so this pointer BETTER be valid...

	// check for empty string
	if( !bstrPath || *bstrPath == L'\0' )
		return CVCProjectEngine::DoSetErrorInfo2(E_INVALIDARG, IDS_ERR_BAD_FILE_NAME, bstrPath, bSetErrorInfo);

	//	Check for duplicate
	int i, iMac;
	VARIANT_BOOL bMatch;

	if( g_bInProjLoad == FALSE )
	{
		// don't validate if loading a project
		iMac = m_rgFiles.GetSize();
		for (i = 0; i < iMac; i++)
		{
			CComPtr<VCFile> pFile;
			pFile = m_rgFiles.GetAt(i); 
			if (pFile)
			{
				HRESULT hr = pFile->MatchName(bstrPath, VARIANT_FALSE, &bMatch);
				if (SUCCEEDED(hr) && bMatch)
					return pFile->QueryInterface(ppDisp);
			}
		}
	}

	return S_OK;
}

HRESULT CProject::CheckCanAddFile(BSTR bstrFile, BOOL bSetErrorInfo)
{
	CComPtr<IDispatch> spExistingFile;
	HRESULT hr = FindFile(bstrFile, &spExistingFile, bSetErrorInfo);
	RETURN_ON_FAIL(hr);
	if (spExistingFile)	// already exists
		return CVCProjectEngine::DoSetErrorInfo2(VCPROJ_E_FILE_EXISTS, IDS_ERR_FILE_EXISTS, bstrFile, bSetErrorInfo);
		
	hr = FileNameValid(bstrFile, bSetErrorInfo ? VARIANT_TRUE : VARIANT_FALSE);
	RETURN_ON_FAIL(hr);

	// it doesn't already exist, and it's a valid name, 
	// need to pass the full path through
	CDirW dir;
	dir.CreateFromString( m_bstrFullDir );
	CPathW path;
	path.CreateFromDirAndFilename( dir, bstrFile );
	CComBSTR bstrFullPath = path.GetFullPath();

	CHECK_OK_TO_DIRTY2(0, bSetErrorInfo);

	return QueryCanAddFile(this, NULL, bstrFullPath, bSetErrorInfo);
}

STDMETHODIMP CProject::CanAddFile(BSTR bstrFile, VARIANT_BOOL* pbCanAdd)
{
	CHECK_POINTER_VALID(pbCanAdd);
	
	HRESULT hr = CheckCanAddFile(bstrFile, TRUE);
	*pbCanAdd = FAILED(hr) ? VARIANT_FALSE : VARIANT_TRUE;

	return SUCCEEDED(hr) ? S_OK : S_FALSE;
}

STDMETHODIMP CProject::CanAddFile2(BSTR bstrFile)
{
	return CheckCanAddFile(bstrFile, FALSE);
}

STDMETHODIMP CProject::AddFile(BSTR bstrPath, /*[out, retval]*/ IDispatch * *ppDisp)
{
	CHECK_POINTER_VALID(ppDisp);

	HRESULT hr = CheckCanAddFile(bstrPath, TRUE);
	RETURN_ON_FAIL(hr);

	//	Add To list of files
	CComPtr<VCFile> pFile;
	CComQIPtr<IDispatch> pDisp;
	CComQIPtr<IDispatch> pDispParent;

	hr = CPEFile::CreateInstance(&pFile); 
	VSASSERT(pFile, "Out of memory, perhaps?");
	RETURN_ON_FAIL_OR_NULL2(hr, pFile, E_OUTOFMEMORY);

	hr = AddNewFile(pFile, bstrPath, VARIANT_FALSE);
	RETURN_ON_FAIL(hr);

	pDisp = pFile;
	VSASSERT(pDisp, "VCFile derives from IDispatch (deep doodoo if it does not anymore).  Out of memory, perhaps?");
	hr = pDisp.CopyTo(ppDisp);
	
	// only look for filter if we're not loading
	// (e.g. during load put the file in exactly the filter the project file
	// says that it's in)
	if( !g_bInProjLoad )
	{
		// find out what Filter to put this in
		CComPtr<VCFilter> pVCFilter;
		CComPtr<IVCFilterImpl> pVCFilterImpl;
		hr = FindFilter(bstrPath, &pVCFilter);
		pVCFilterImpl = pVCFilter;
		if (SUCCEEDED(hr) && pVCFilterImpl)
		{
			hr = pVCFilterImpl->AddItem(pDisp);
			pDispParent = pVCFilter;
			VSASSERT(SUCCEEDED(hr), "Uh.  Why did VCFilter::AddItem fail after VCProject::AddFile succeeded?");
		}
	}

	// fire events
	CComQIPtr<IVCProjectEngineImpl> pEngine;

	pEngine = g_pProjectEngine;
	if (pEngine)
	{
		if(pDispParent == NULL)
			pEngine->DoFireItemAdded(pDisp, (IDispatch*)this);
		else
			pEngine->DoFireItemAdded(pDisp, pDispParent);
	}
	InformFileAdded(this, pFile, bstrPath);

	return hr;
}

STDMETHODIMP CProject::AddNewFile(IDispatch *pFile, LPCOLESTR szRelativePath, VARIANT_BOOL bFireEvents)
{
	CComQIPtr<VCFile> pVCFile;
	CComQIPtr<IVCFileImpl> pVCFileImpl;

	CHECK_OK_TO_DIRTY(0);

	pVCFile = pFile;
	pVCFileImpl = pFile;
	VSASSERT(pFile, "Was pFile NULL when we got here?");
	VSASSERT(pVCFile && pVCFileImpl, "File object must support both VCFile and IVCFileImpl interfaces.");
	RETURN_ON_NULL2(pVCFile, E_UNEXPECTED);

	{
		CComPtr<IDispatch> pProject;
		pVCFile->get_Project(&pProject);
		if (pProject)
			return S_OK;
	}

	HRESULT hr = pVCFileImpl->put_Parent(this);
	VSASSERT(SUCCEEDED(hr), "Out of memory, perhaps?");
	hr = pVCFileImpl->put_Project(this);
	VSASSERT(SUCCEEDED(hr), "Out of memory, perhaps?");

	CStringW strRelPathTmp = szRelativePath;
	strRelPathTmp.TrimLeft();
	strRelPathTmp.TrimRight();
	if (!strRelPathTmp.IsEmpty())
	{
		// if we're not in project load, 
		if( !g_bInProjLoad )
		{
			// make sure this path is relative
			CDirW dir;
			dir.CreateFromString( m_bstrFullDir );
			CPathW path;
			path.CreateFromDirAndFilename( dir, szRelativePath );
			path.SetAlwaysRelative( true );
			CStringW strRelPath; 
			path.GetRelativeName( dir, strRelPath );
			pVCFile->put_RelativePath( CComBSTR( strRelPath ) );
		}
		else
			hr = pVCFile->put_RelativePath(CComBSTR(strRelPathTmp));
	}


	// add all our configs to this file
	{	// scope loadProj below
		CInLoadProject loadProj;
		int i, iMac;
		iMac = m_rgConfigs.GetSize();
		for (i = 0; i <= iMac; i++)
		{
			CComPtr<VCConfiguration> pConfig;
			pConfig = m_rgConfigs.GetAt(i);
			if (pConfig)
				pVCFileImpl->AddConfiguration(pConfig);
		}
	}
	m_rgFiles.Add(pVCFile);
	m_bItemsCollectionDirty = true;
	if (!g_bInProjLoad)
	{
		CComQIPtr<IVCBuildableItem> spBuildableFile = pVCFile;
		if (spBuildableFile)
			spBuildableFile->AssignActions(VARIANT_TRUE);
	}

	// fire events
	if (bFireEvents == VARIANT_TRUE)
	{
		CComQIPtr<IVCProjectEngineImpl> pEngine = g_pProjectEngine;
		if (pEngine)
		{
			CComPtr<IDispatch> pDispParent;
			pVCFile->get_Parent(&pDispParent);
			if (pDispParent == NULL)
				pEngine->DoFireItemAdded(pFile, (IDispatch*)this);
			else
				pEngine->DoFireItemAdded(pFile, pDispParent);
		}
	}

	return hr;
}

STDMETHODIMP CProject::AddChild(IDispatch* pChild)
{
	CComQIPtr<VCFile> spFile = pChild;
	if (spFile != NULL)
	{
		CComQIPtr<IVCFileImpl> spFileImpl = spFile;
		if (spFileImpl)
			spFileImpl->put_Parent(this);
		// should already be in the files collection
		return S_OK;
	}

	CComQIPtr<VCFilter> spFilter = pChild;
	RETURN_ON_NULL2(spFilter, E_UNEXPECTED);	// only know about files and filters for this

	m_rgFilters.AddTail(spFilter);
	CComQIPtr<IVCFilterImpl> spFilterImpl = spFilter;
	if (spFilterImpl)
		spFilterImpl->put_Parent(this);
	return S_OK;
}

STDMETHODIMP CProject::RemoveChild(IDispatch* pChild)
{
	CComQIPtr<VCFile> spFile = pChild;
	if (spFile != NULL)	
	{
		CComQIPtr<IVCFileImpl> spFileImpl = spFile;
		if (spFileImpl)
			spFileImpl->put_Parent(NULL);
		// do NOT remove from the files collection...
		return S_OK;
	}

	CComQIPtr<VCFilter> spFilter = pChild;
	RETURN_ON_NULL2(spFilter, E_UNEXPECTED);	// only know about files and filters for this

	m_rgFilters.Remove(spFilter);
	CComQIPtr<IVCFilterImpl> spFilterImpl = spFilter;
	if (spFilterImpl)
		spFilterImpl->put_Parent(NULL);
	return S_OK;
}

HRESULT CProject::FindFilter(BSTR bstrFileName, VCFilter **ppFilter)
{
	HRESULT hrLoop = VCPROJ_E_NOT_FOUND;
	HRESULT hr = S_FALSE;
	*ppFilter = NULL;

	// find out what Filter to put this in
	long lItem, lcItems;
	VARIANT_BOOL bIsMatch;

	lcItems = m_rgFilters.GetSize();
	bIsMatch = false;
	for (lItem = 0; lItem < lcItems && FAILED(hrLoop) && bIsMatch == false; lItem++)
	{
		CComPtr<VCFilter> pVCFilter;
		CComQIPtr<IVCFilterImpl> pVCFilterImpl;
		pVCFilter = m_rgFilters.GetAt(lItem);
		pVCFilterImpl = pVCFilter;
		if (pVCFilter && pVCFilterImpl)
		{
			hrLoop = FindSubFilter(bstrFileName, pVCFilter, ppFilter);
			if (SUCCEEDED(hrLoop))
			{
				hr = pVCFilter.CopyTo(ppFilter);
			}
		}
	}

	if (hr == VCPROJ_E_NOT_FOUND)
		return CVCProjectEngine::DoSetErrorInfo2(VCPROJ_E_NOT_FOUND, IDS_ERR_FILTER_NOT_FOUND, bstrFileName);

	return hr;
}

HRESULT CProject::FindSubFilter(BSTR bstrFileName, VCFilter *pFilterStart, VCFilter **ppFilter)
{
	CHECK_READ_POINTER_NULL(pFilterStart);
	CHECK_POINTER_NULL(ppFilter);

	CComPtr<IEnumVARIANT> pEnumFilters;
	CComPtr<IDispatch> pDispCollection;
	CComQIPtr<IVCCollection> pCollection;
	VARIANT_BOOL bMatch = VARIANT_FALSE;
	CComQIPtr<IVCFilterImpl> pFilterStartImpl;

	pFilterStartImpl = pFilterStart;
	CHECK_READ_POINTER_NULL(pFilterStartImpl);

	// check to see if start Filter matches
	HRESULT hr = pFilterStartImpl->IsMatch(bstrFileName, &bMatch);

	if (bMatch == VARIANT_FALSE)
	{
		hr = pFilterStart->get_Filters(&pDispCollection);
		pCollection = pDispCollection;
		if (SUCCEEDED(hr) && pCollection)
		{
			pCollection->_NewEnum(reinterpret_cast<IUnknown **>(&pEnumFilters));
		}
		if (SUCCEEDED(hr) && pEnumFilters)
		{
			unsigned long lcItems;
			CComVariant varFilter;
			HRESULT hrT = VCPROJ_E_NOT_FOUND;

			hr = pEnumFilters->Next(1, &varFilter, &lcItems);
			while (SUCCEEDED(hr) && lcItems == 1 && FAILED(hrT))
			{
				CComQIPtr<VCFilter> pVCFilter;
				CComQIPtr<IVCFilterImpl> pVCFilterImpl;

				if (varFilter.vt == VT_UNKNOWN)
				{
					pVCFilter = varFilter.punkVal;
					pVCFilterImpl = pVCFilter;
					VSASSERT(pVCFilterImpl, "NULL filter object in collection with .vt set correctly?!?");
					if (pVCFilter && pVCFilterImpl)
					{
						hr = pVCFilterImpl->IsMatch(bstrFileName, &bMatch);
						if (bMatch == VARIANT_FALSE)
						{
							hrT = FindSubFilter(bstrFileName, pVCFilter, ppFilter); // recurse!
						}
						else
						{
							hrT = S_OK;
							pVCFilter.CopyTo(ppFilter);
						}
					}
				}
				hr = pEnumFilters->Next(1, &varFilter, &lcItems);
			}
			hr = hrT;
			
		}
	}

	if (hr == VCPROJ_E_NOT_FOUND)
		return CVCProjectEngine::DoSetErrorInfo2(VCPROJ_E_NOT_FOUND, IDS_ERR_FILTER_NOT_FOUND, bstrFileName);

	return hr;
}

HRESULT CProject::GetConfigFromVariant(VARIANT varConfiguration, IDispatch **ppDispVal)
{
	HRESULT hr;
	int iMac;
	int iIndex;
	CComPtr<VCConfiguration> pConfig;
	CComQIPtr<IDispatch> pDisp;
	CComBSTR bstrName;

	hr = E_NOINTERFACE;
	*ppDispVal = NULL;
	if (varConfiguration.vt == VT_EMPTY)
	{
		hr = S_FALSE; // ALL configs!
	}
	else
	{
		iMac = m_rgConfigs.GetSize();
		for (iIndex = 0; iIndex <= iMac && hr == S_FALSE; iIndex++)
		{
			pConfig = m_rgConfigs.GetAt(iIndex);
			pDisp = pConfig;
			if (pConfig && pDisp)
			{
				switch (varConfiguration.vt)
				{
				case VT_DISPATCH:
					if (pDisp == varConfiguration.pdispVal)
					{
						hr = S_OK;
					}
					break;
				case VT_BSTR:
					bstrName.Empty();
					pConfig->get_Name(&bstrName);
					if (bstrName == varConfiguration.bstrVal)
					{
						hr = S_OK;
					}
					break;
				}
			}
		}
		pDisp.CopyTo(ppDispVal);
	}
	return hr;
}

HRESULT CProject::AddPlatformConfig(IDispatch *pDispPlatform, LPCOLESTR bstrConfigName, BOOL bSearchExisting)
{ // WARNING: CONTAINS EARLY RETURNS
	HRESULT hr;
	CComBSTR bstrConfigFlavorName;
	CComBSTR bstrPlatformName;
	CComBSTR bstrName;
	CComQIPtr<VCPlatform> pPlatform;
	CComPtr<VCConfiguration> pConfig;
	HRESULT hrT;
	int iMac;
	int iIndex;

	pPlatform = pDispPlatform;
	hr = E_NOINTERFACE;
	if (pPlatform)
	{

		// see if this project, for some reason, already has this project-config
		if (bSearchExisting)
		{
			pPlatform->get_Name(&bstrPlatformName);
			bstrConfigFlavorName = bstrConfigName;
			bstrConfigFlavorName.Append(L"|");
			bstrConfigFlavorName.Append(bstrPlatformName);
			iMac = m_rgConfigs.GetSize();
			for (iIndex = 0; iIndex <= iMac; iIndex++)
			{
				pConfig = m_rgConfigs.GetAt(iIndex);
				if (pConfig)
				{
					bstrName.Empty();
					hrT = pConfig->get_Name(&bstrName);
					if (_wcsicmp(bstrName, bstrConfigFlavorName) == 0)
						return S_FALSE; // WARNING: EARLY RETURN
				}
			}
		}

		CHECK_OK_TO_DIRTY(0);

		{
			// fake the everything into thinking we're loading, so that they
			// don't do AssignActions (we'll handle it afterwards)
			CInLoadProject loadProj;

			// configuration didn't exist. create a new one and set it up.
			hr = CConfiguration::CreateInstance(&pConfig, bstrConfigName, pPlatform, this);
			// Add the config 
			m_rgConfigs.Add(pConfig);
			VSASSERT(pConfig, "Out of memory, perhaps?"); // should have one right now

			// add a file config for each file in the project
			CComPtr<IDispatch> pDispColl;
			hr = get_Files( &pDispColl );
			CComQIPtr<IVCCollection> pColl = pDispColl;
			RETURN_ON_FAIL_OR_NULL2(hr, pColl, E_NOINTERFACE);
			long num_files;
			hr = pColl->get_Count( &num_files );
			RETURN_ON_FAIL(hr);
			for( long i = 1; i <= num_files; i++ )
			{
				CComPtr<IDispatch> pDisp;
				hr = pColl->Item( CComVariant( i ), &pDisp );
				if( FAILED( hr ) )
					continue;
				CComQIPtr<IVCFileImpl> pFileImpl = pDisp;
				if( !pFileImpl )
					continue;
				pFileImpl->AddConfiguration( pConfig );
			}
			// fire an event so the ui becomes aware of the new config
			CComQIPtr<IVCProjectEngineImpl> pEngine = g_pProjectEngine;
			if( pEngine )
			{
				CComQIPtr<IDispatch> pDispConfig = pConfig;
				if( pDispConfig )
					pEngine->DoFireItemAdded( pDispConfig, static_cast<IDispatch*>(this) );
			}
		}	// reset whether we're loading or not

		if (!g_bInProjLoad)
		{
			CComQIPtr<IVCBuildableItem> spBuildableCfg = pConfig;
			VSASSERT(spBuildableCfg, "Configurations of any stripe must support IVCBuildableItem interface.");
			if (spBuildableCfg)
				spBuildableCfg->AssignActions(VARIANT_FALSE);
		}
	}
	return hr;
}

HRESULT CProject::CheckCanAddFilter(BSTR bstrFilter, CStringW& strCleanedUpName, BOOL bSetErrorInfo)
{
	CComPtr<IDispatch> spFilter;
	HRESULT hr = FindExistingFilter(bstrFilter, strCleanedUpName, &spFilter, bSetErrorInfo);
	RETURN_ON_FAIL(hr);
	if (spFilter)	// already there
		return CVCProjectEngine::DoSetErrorInfo2(VCPROJ_E_FILTER_EXISTS, IDS_ERR_FILTER_EXISTS, bstrFilter, bSetErrorInfo);

	CHECK_OK_TO_DIRTY(0);

	return S_OK;
}

STDMETHODIMP CProject::CanAddFilter(BSTR bstrFilter, VARIANT_BOOL* pbCanAdd)
{
	CHECK_POINTER_VALID(pbCanAdd);

	CStringW strCleanedUpName;
	HRESULT hr = CheckCanAddFilter(bstrFilter, strCleanedUpName, TRUE);
	*pbCanAdd = FAILED(hr) ? VARIANT_FALSE : VARIANT_TRUE;

	return SUCCEEDED(hr) ? S_OK : S_FALSE;
}

STDMETHODIMP CProject::CanAddFilter2(BSTR bstrFilter, VARIANT_BOOL bSetErrorInfo)
{
	CStringW strCleanedUpName;
	return CheckCanAddFilter(bstrFilter, strCleanedUpName, (bSetErrorInfo == VARIANT_TRUE));
}

HRESULT CProject::FindExistingFilter(BSTR bstrFilterName, CStringW& strCleanedUpName, IDispatch** ppDisp, BOOL bSetErrorInfo)
{
	*ppDisp = NULL;		// this had BETTER be valid since this is an internal function...

	// Validate: Is this a valid name ?
	strCleanedUpName = bstrFilterName;
	strCleanedUpName.TrimLeft();
	strCleanedUpName.TrimRight();
	if( strCleanedUpName.GetLength() == 0 )
		return CVCProjectEngine::DoSetErrorInfo2(E_INVALIDARG, IDS_ERR_BAD_FILTER_NAME, bstrFilterName, bSetErrorInfo);

	// validate: is there a folder with this name already?
	int iMac = m_rgFilters.GetSize();
	for (int iIndex = 0; iIndex <= iMac; iIndex++)
	{
		CComPtr<VCFilter> pFilterT = m_rgFilters.GetAt(iIndex);
		if (pFilterT)
		{
			CComBSTR bstrExistingName;
			pFilterT->get_Name(&bstrExistingName);
			if( bstrExistingName && wcsicmp( bstrExistingName, strCleanedUpName ) == 0 )
			{
				pFilterT.QueryInterface(ppDisp);
				return S_FALSE;
			}
		}
	}

	return S_OK;
}

STDMETHODIMP CProject::AddFilter(BSTR bstrFilterName, /*[out, retval]*/ IDispatch * *ppDisp)
{
	CHECK_POINTER_VALID(ppDisp);

	CStringW strCleanedUpName;
	HRESULT hr = CheckCanAddFilter(bstrFilterName, strCleanedUpName, TRUE);
	RETURN_ON_FAIL(hr);
	CComBSTR bstrFilter = strCleanedUpName;

	CComQIPtr<VCFilter> pFilter;
	hr = CFilter::CreateInstance(&pFilter);
	if (SUCCEEDED(hr) && pFilter)
	{
		CHECK_OK_TO_DIRTY(0);

		// Add to filter list
		m_rgFilters.Add(pFilter);
		m_bItemsCollectionDirty = true;
		CComQIPtr<IVCFilterImpl> pFilterImpl = pFilter;
		if (pFilterImpl)
			pFilterImpl->put_Parent(this);
		pFilter->put_Name(bstrFilter);
		pFilter.QueryInterface(ppDisp);

		CComQIPtr<IVCProjectEngineImpl> pEngine;
		pEngine = g_pProjectEngine;
		CComPtr<IDispatch> pDispParent;
		pFilter->get_Parent(&pDispParent);
		if(pDispParent == NULL)
			pEngine->DoFireItemAdded(pFilter, static_cast<IDispatch*>(this));
		else
			pEngine->DoFireItemAdded(pFilter, pDispParent);
	}
	return hr;
}

STDMETHODIMP CProject::get_IsDirty(/*[out, retval]*/ VARIANT_BOOL *pBoolDirty)
{
	CHECK_POINTER_VALID( pBoolDirty );
	*pBoolDirty = m_bDirty;
	return S_OK;
}

HRESULT CProject::WrapCanDirty()	// just need to wrap the CHECK_OK_TO_DIRTY macro
{
	CHECK_OK_TO_DIRTY(0);
	return S_OK;
}

STDMETHODIMP CProject::get_CanDirty(VARIANT_BOOL* pbCanDirty)
{
	HRESULT hr = WrapCanDirty();
	if (pbCanDirty)	// optional pointer
	{
		CHECK_POINTER_VALID(pbCanDirty);
		if (SUCCEEDED(hr))
			*pbCanDirty = VARIANT_TRUE;
		else
			*pbCanDirty = VARIANT_FALSE;
	}
	return hr;
}

STDMETHODIMP CProject::put_IsDirty(/*[in]*/  VARIANT_BOOL boolDirty)
{
	if (g_bInProjLoad)	// can't dirty while in project load
		return S_OK;

	return put_IsConverted(boolDirty);
}

STDMETHODIMP CProject::put_IsConverted(VARIANT_BOOL boolDirty)
{
	// can force it dirty even during project load if we're converting a multi-project .mdp file...
	if( boolDirty && !m_bDirty )
	{
		// fire event to notify scc etc 
		CComQIPtr<IVCProjectEngineImpl> pEngine;
		pEngine = g_pProjectEngine;
		VSASSERT( pEngine, "Deep trouble if project engine not available here..." );
		VARIANT_BOOL bRetVal;
		m_wCloseFlag = closeFlagMaybeSCCClose;
		pEngine->DoFireSccEvent( static_cast<IDispatch*>(this), ePreDirtyNotification, &bRetVal );
		if (m_wCloseFlag != closeFlagBySCC)
			m_wCloseFlag = closeFlagOpenClean;
		if( bRetVal == VARIANT_FALSE )
			return E_ACCESSDENIED;
	}
	if(	m_bDirty != boolDirty )
		m_bDirty = boolDirty;

	if (m_wCloseFlag == closeFlagBySCC)
		return CVCProjectEngine::DoSetErrorInfo2(VCPROJ_E_PROJ_RELOADED, IDS_ERR_PROJ_RELOADED, m_bstrName, TRUE /* report */);

	return S_OK;
}

STDMETHODIMP CProject::put_OwnerKey( BSTR bstrName )
{
	CHECK_OK_TO_DIRTY(0);
	m_bstrOwnerKey = bstrName;
	return S_OK;
}

STDMETHODIMP CProject::get_OwnerKey( BSTR *pbstrName )
{
	CHECK_POINTER_VALID( pbstrName );
	return m_bstrOwnerKey.CopyTo( pbstrName );
}

STDMETHODIMP CProject::put_ProjectGUID( BSTR bstrGuid )
{
	CHECK_OK_TO_DIRTY(0);
	m_bstrGuid = bstrGuid;
	return S_OK;
}

STDMETHODIMP CProject::get_ProjectGUID( BSTR *pbstrGuid )
{
	CHECK_POINTER_VALID( pbstrGuid );
	return m_bstrGuid.CopyTo( pbstrGuid );
}

STDMETHODIMP CProject::Save()
{
	if (CVCProjectEngine::s_pBuildPackage != NULL)
		return CVCProjectEngine::s_pBuildPackage->SaveProject(this, NULL);

	return DoSave(NULL);
}

// helper function to sort files
static int FileCompare( const void* fileA, const void* fileB )
{
	CComBSTR bstrNameA, bstrNameB;
	(*(VCFile**)(fileA))->get_Name( &bstrNameA );
	(*(VCFile**)(fileB))->get_Name( &bstrNameB );
	return wcscoll( bstrNameA, bstrNameB );
}

STDMETHODIMP CProject::DoSave(LPCOLESTR szFileName)
{
	// determine the file name
	CComBSTR bstrFile = szFileName;
	if (bstrFile.Length() == 0)	// do a Save rather than a SaveAs
		bstrFile = m_bstrFileName;
	else
		put_ProjectFile(bstrFile);

	// create an XMLFile object
	CComPtr<IVCXMLFile> xmlfile;
	CXMLFile::AdjustFileEncodingForFileFormat(m_eFileFormat, m_eFileFormat, m_bstrFileEncoding, TRUE);
	HRESULT hr = CXMLFile::CreateInstance( &xmlfile, bstrFile, 1024 * 1024, m_bstrFileEncoding, m_eFileFormat );
	CComQIPtr<IStream> xml = xmlfile;
	VSASSERT( xml, "QI for IStream on an IVCXMLFile failed!" );
	RETURN_ON_FAIL_OR_NULL(hr, xml);

	
	// write header
	CStringW strEncoding = m_bstrFileEncoding;
	CStringW strHeaderFormat = L"<?xml version=\"1.0\" encoding = \"%s\"?>\r\n";
	CStringW strHeader;
	strHeader.Format(strHeaderFormat, strEncoding);
	CComBSTR bstrHeader = strHeader;

	unsigned long bytesWritten;
	xml->Write( (void*)bstrHeader, (int) wcslen( bstrHeader ) * sizeof(OLECHAR), &bytesWritten );

	// write project node
	StartNodeHeader( xml, L"VisualStudioProject", true );
	SaveObject( xml, NULL, GetIndent() );
	EndNodeHeader( xml, true );

	// Build node (for vb format compliance only)
	StartNodeHeader( xml, L"Platforms", true );
	EndNodeHeader( xml, true );


	// write platform information
	long lcItems, lItem;
	lcItems = m_rgPlatforms.GetSize();
	for( lItem = 0; lItem < lcItems; lItem++ )
	{
		CComQIPtr<VCPlatform> pPlatform;
		CComQIPtr<IVCPlatformImpl> pPlatformImpl;
		pPlatform = m_rgPlatforms.GetAt( lItem );
		pPlatformImpl = pPlatform;
		if( pPlatform && pPlatformImpl )
		{
			StartNodeHeader( xml, L"Platform", false );
			hr = pPlatformImpl->SaveObject( xml, NULL, GetIndent() );
			EndNode( xml, L"Platform", false );
		}
	}
	// write the end of the Settings node (node for vb format compliance)
	EndNode( xml, L"Platforms", true );

	// Settings node (for vb format compliance only)
	StartNodeHeader( xml, L"Configurations", true );
	EndNodeHeader( xml, true );
	
	// write config information
	lcItems = m_rgConfigs.GetSize();
	for( lItem = 0; lItem < lcItems; lItem++ )
	{
		CComQIPtr<VCConfiguration> pConfig;
		CComQIPtr<IVCConfigurationImpl> pConfigImpl;
		pConfig = m_rgConfigs.GetAt( lItem );
		pConfigImpl= pConfig;
		if( pConfig && pConfigImpl )
		{
			StartNodeHeader( xml, L"Configuration", true ); 			
			hr = pConfigImpl->SaveObject( xml, NULL, GetIndent() );
			EndNode( xml, L"Configuration", true );
		}
	}


	// write the end of the Build node (node for vb format compliance)
	EndNode( xml, L"Configurations", true );

	// Files node (for vb format compliance only)
	StartNodeHeader( xml, L"Files", true );
	EndNodeHeader( xml, true );

	// write filter information
	lcItems = m_rgFilters.GetSize();
	for( lItem = 0; lItem < lcItems; lItem++ )
	{
		CComQIPtr<VCFilter> pVCFilter;
		CComQIPtr<IVCFilterImpl> pVCFilterImpl;
		pVCFilter = m_rgFilters.GetAt( lItem );
		pVCFilterImpl= pVCFilter;
		if( pVCFilter && pVCFilterImpl )
		{
			StartNodeHeader( xml, L"Filter", true );
			hr = pVCFilterImpl->SaveObject( xml, NULL, GetIndent() );
			EndNode( xml, L"Filter", true );
		}
	}

	// sort the files alphabetically before writing
	// allocate an array of ptrs
	VCFile **rgFiles = new VCFile*[m_rgFiles.GetCount()];
	// copy the ptrs (NON-REFCOUNTED!) into the array
	lcItems = m_rgFiles.GetSize();
	int n = 0;
	for( lItem = 0; lItem < lcItems; lItem++ )
	{
		VCFile* pFile = m_rgFiles.GetAt( lItem );
		if (pFile == NULL)
			continue;

		CComPtr<IDispatch> pParent;
		hr = pFile->get_Parent( &pParent );
		VSASSERT(SUCCEEDED(hr), "File without parent generally means file is already zombie.");
		// add only files that are on the project node, not in folders!
		if( pParent == NULL || pParent == static_cast<IDispatch *>(this) ) 
			rgFiles[n++] = pFile;
	}
	// sort the array
	qsort( (void*)rgFiles, n, sizeof(VCFile*), FileCompare );
	
	// write file information for files not in filters
	lcItems = n;
	for( lItem = 0; lItem < lcItems; lItem++ )
	{
		CComQIPtr<VCFile> pFile;
		CComQIPtr<IVCFileImpl> pFileImpl;
		pFile = rgFiles[lItem];
		pFileImpl = pFile;
		if( pFile && pFileImpl )
		{
			StartNodeHeader( xml, L"File", true );
			hr = pFileImpl->SaveObject( xml, NULL, GetIndent() );
			EndNode( xml, L"File", true );
		}
	}
	delete[] rgFiles;

	// write the end of the Files node (node for vb format compliance)
	EndNode( xml, L"Files", true );

	// write globals
	if( m_pGlobals )
	{
		StartNodeHeader( xml, L"Globals", true );
		EndNodeHeader( xml, true );
		hr = m_pGlobals->SaveObject( xml, NULL, GetIndent() );
		EndNode( xml, L"Globals", true );
	}
	
	// write the end of the project node
	EndNode( xml, L"VisualStudioProject", true );

	hr = xml->Commit(0);
	RETURN_ON_FAIL(hr);

	// "un-dirty" the project
	put_IsDirty( VARIANT_FALSE );

	return hr;
}

STDMETHODIMP CProject::GetGlobals(IVCGlobals **ppGlobals)
{
	// do we have a globals object yet?
	if( !m_pGlobals )
	{
		CVCGlobals *pGlobals = NULL;
		HRESULT hr = CVCGlobals::CreateInstance( &pGlobals );
		VSASSERT( SUCCEEDED( hr ) && pGlobals, "Unable to initialize CAutoProject: Can't create Globals object!");
		m_pGlobals = (IVCGlobals*)pGlobals;
	}
	// add ref for return (this is a raw pointer)
	m_pGlobals->AddRef();
	*ppGlobals = m_pGlobals;
	return S_OK;
}

STDMETHODIMP CProject::SaveObject( IStream *xml, IVCPropertyContainer *pPropCnt, long nIndent )
{
	// write ProjectType, Version and Name nodes
	NodeAttribute( xml, L"ProjectType", CComBSTR( L"Visual C++" ) );
	NodeAttribute( xml, L"Version", CComBSTR( L"7.00" ) );
	NodeAttributeWithSpecialChars( xml, L"Name", m_bstrName );

	// write the OwnerKey prop, if there is one
	NodeAttribute( xml, L"OwnerKey", m_bstrOwnerKey );
	NodeAttribute( xml, L"ProjectGUID", m_bstrGuid );

	// write SCC strings if the project is under SCC
	NodeAttributeWithSpecialChars( xml, L"SccProjectName", m_bstrSccProjectName );
	NodeAttributeWithSpecialChars( xml, L"SccAuxPath", m_bstrSccAuxPath );
	NodeAttributeWithSpecialChars( xml, L"SccLocalPath", m_bstrSccLocalPath );
	NodeAttributeWithSpecialChars( xml, L"SccProvider", m_bstrSccProvider );

	NodeAttributeWithSpecialChars( xml, L"Keyword", m_bstrKeyword );

	return S_OK;
}

STDMETHODIMP CProject::MatchName(BSTR bstrNameToMatch, VARIANT_BOOL bFullOnly, VARIANT_BOOL *pbMatched)
{
	CHECK_POINTER_VALID(pbMatched);
	*pbMatched = VARIANT_FALSE;
	if (bstrNameToMatch == NULL)
	{
		if (m_bstrName == NULL)
			*pbMatched = VARIANT_TRUE;
		else
			*pbMatched = VARIANT_FALSE;
	}
	else if (m_bstrName == NULL)
	{
		*pbMatched = VARIANT_FALSE;
	}
	else if (!bFullOnly && _wcsicmp(m_bstrName,bstrNameToMatch) == 0)
	{
		*pbMatched = VARIANT_TRUE;
	}
	else if (_wcsicmp(m_bstrFileName, bstrNameToMatch) == 0)
	{
		*pbMatched = VARIANT_TRUE;
	}
	else
	{
		CComBSTR bstrName;
		bstrName = m_bstrFullDir;
		bstrName.Append(m_bstrFileName);
		if (bstrName == NULL)
		{
			*pbMatched = VARIANT_FALSE;
		}
		else if (_wcsicmp(bstrName, bstrNameToMatch) == 0)
		{
			*pbMatched = VARIANT_TRUE;
		}
		else
		{
			CPathW pathSrc, pathMatch; // to handle case where shell passes in something
			pathSrc.Create(bstrName);
			pathMatch.Create(bstrNameToMatch);
			if (pathSrc == pathMatch)
			{
				*pbMatched = VARIANT_TRUE;
			}
		}
	}
	return S_OK;
}

STDMETHODIMP CProject::get_Name(BSTR *pVal)
{
	CHECK_POINTER_VALID( pVal );
	m_bstrName.CopyTo(pVal);
	return S_OK;
}

STDMETHODIMP CProject::put_Name(BSTR newVal)
{
	// validate name
	// check for all whitespace or 0 length string
	CStringW strName = newVal;
	strName.TrimLeft();
	strName.TrimRight();
	if( strName.IsEmpty() )
		return S_OK;
		
	CHECK_OK_TO_DIRTY(VCPROJID_Name);

	CComBSTR bstrOldName;
	if (!g_bInProjLoad)
		bstrOldName = m_bstrName;
	m_bstrName = newVal;

	// don't update UI during project load!
	if( !g_bInProjLoad)
	{
		if (bstrOldName != m_bstrName)
		{
			long lcItems = m_rgConfigs.GetCount();
			for (long idx = 0; idx < lcItems; idx++)
			{
				CComQIPtr<IVCConfigurationImpl> spConfigImpl = m_rgConfigs.GetAt(idx);
				if (spConfigImpl == NULL)
					continue;
				spConfigImpl->DirtyOutputs(VCPROJID_Name);
			}
		}

		// send an event notifying everyone in the UI business that we've changed
		// appearances
		CComQIPtr<IDispatch> spDisp = this;
		if( spDisp )
		{
			CComQIPtr<IVCProjectEngineImpl> spPrjEngImpl = g_pProjectEngine;
			if( spPrjEngImpl )
				spPrjEngImpl->DoFireItemPropertyChange( spDisp, VCPROJID_Name );
		}
	}
	
	if( !m_bstrFileName )	// do need to give the file name heads up in case of error during load
		put_ProjectFile( newVal );
		
	return S_OK;
}

STDMETHODIMP CProject::get_Keyword(BSTR *pVal)
{
	CHECK_POINTER_VALID( pVal );
	m_bstrKeyword.CopyTo(pVal);
	return S_OK;
}

STDMETHODIMP CProject::put_Keyword(BSTR newVal)
{
	CHECK_OK_TO_DIRTY(0);
	m_bstrKeyword = newVal;
	return S_OK;
}

STDMETHODIMP CProject::get_ProjectFile(BSTR *pVal)
{
	CHECK_POINTER_VALID( pVal );
	m_bstrFileName.CopyTo( pVal );
	return S_OK;
}

STDMETHODIMP CProject::put_ProjectFile(BSTR newVal)
{
	// validate name
	// check for all whitespace or 0 length string
	CStringW strName = newVal;
	strName.TrimLeft();
	strName.TrimRight();
	if( strName.IsEmpty() )
		return S_OK;

	// Much as we'd like to, we cannot dirty the file here.  Must be done MUCH lower down.
	// Please note that we DO have to SET the new values BEFORE the dirty check since we've
	// got our SCC pre-dirty event set up so that it does not take the project file name as
	// a parameter (this is 'cause the 99.95% case is that the project file name isn't changing).
	// If, for some reason, our dirty check fails later, we saved off the old values so we could
	// revert back to them.

	CComBSTR bstrOldFileName = m_bstrFileName;
	CComBSTR bstrOldFullDir = m_bstrFullDir;
	CPathW pathProj;
	if (pathProj.Create(strName))
	{
		CStringW strExt = pathProj.GetExtension();
		if (strExt.IsEmpty())	// had a bare name for this...
			pathProj.ChangeExtension(L".vcproj");
		m_bstrFileName = pathProj.GetFullPath();
	}
	else
		m_bstrFileName = strName;

	// MUST ALWAYS PASS IN FULL PATH
	CDirW dir;
	dir.CreateFromPath( newVal, FALSE, TRUE );
	const wchar_t* wszDir = (const wchar_t*)dir;
	m_bstrFullDir = wszDir;
	int len = m_bstrFullDir.Length();
	VSASSERT( len > 0, "Invalid project directory name: length of name is <= 0!" );
	if( m_bstrFullDir[len-1] != L'\\' )
		// append the trailing backslash, which the build process wants
		m_bstrFullDir += L"\\";

	HRESULT hr = WrapCanDirty();	// wrap the CHECK_OK_TO_DIRTY call so we can revert changes if needed
	if (hr != S_OK)
	{
		m_bstrFileName = bstrOldFileName;
		m_bstrFullDir = bstrOldFullDir;
		return hr;
	}

	return S_OK;
}

STDMETHODIMP CProject::get_FileFormat( enumFileFormat *pType )
{
	CHECK_POINTER_VALID(pType);
	*pType = m_eFileFormat;
	return S_OK;
}

STDMETHODIMP CProject::put_FileFormat( enumFileFormat type )
{
	CHECK_OK_TO_DIRTY(0);
	CXMLFile::AdjustFileEncodingForFileFormat(m_eFileFormat, type, m_bstrFileEncoding);
	m_eFileFormat = type;
	return S_OK;
}

STDMETHODIMP CProject::get_FileEncoding( BSTR *pEncoding )
{
	CHECK_POINTER_VALID( pEncoding );
	m_bstrFileEncoding.CopyTo(pEncoding);
	return S_OK;
}

STDMETHODIMP CProject::put_FileEncoding( BSTR bstrEncoding )
{
	CHECK_OK_TO_DIRTY(0);
	CXMLFile::AdjustFileFormatForFileEncoding(m_bstrFileEncoding, bstrEncoding, m_eFileFormat);
	m_bstrFileEncoding = bstrEncoding;
	return S_OK;
}

STDMETHODIMP CProject::SaveProjectOptions(IUnknown *pStreamUnk)
{
	//Get the IStream interface
	CComQIPtr<IStream> spStream = pStreamUnk;
	RETURN_ON_NULL2(spStream, E_NOINTERFACE);

	//TODO: Write out additional project properties here

	//Write out count of configs
	int iCount = m_rgConfigs.GetCount();
	ULONG iByteCount;
	HRESULT hr = spStream->Write(&iCount, sizeof(int), &iByteCount);
	RETURN_ON_FAIL(hr);
	
	// get the number of configs to iterate over
	iCount = m_rgConfigs.GetSize();

	for (int i = 0; i < iCount; i++)
	{
		//Get config
		CComQIPtr<IVCConfigurationImpl> spConfigImpl = m_rgConfigs.GetAt(i);
		if (spConfigImpl == NULL) continue;
		
		hr = spConfigImpl->WriteToStream(spStream);
		RETURN_ON_FAIL(hr);
	}

	return S_OK;
}

STDMETHODIMP CProject::LoadProjectOptions(IUnknown *pStreamUnk)
{
	//TODO: Load additional project properties here

	//Get the config count
	int iCfgCount = m_rgConfigs.GetSize();

	//Get the IStream interface
	CComQIPtr<IStream> spStream = pStreamUnk;
	RETURN_ON_NULL2(spStream, E_NOINTERFACE);

	//Read the config count
	int iCount;
	ULONG byteCount;
	HRESULT hr = spStream->Read(&iCount, sizeof(int), &byteCount);
	RETURN_ON_FAIL(hr);

	//For each config stored
	for (int i = 0; i < iCount; i++)
	{
		CComPtr<VCConfiguration>		spConfig;
		CComPtr<IDispatch>				pDispDbgSettings;
		CComQIPtr<IVCDebugSettingsImpl> pDbgSettings;
		CComBSTR						bstrName;
		
		//Read in config name
		hr = bstrName.ReadFromStream(spStream);
		RETURN_ON_FAIL(hr);

		//Loop the configs looking for the one we're loading
		CComQIPtr<IVCConfigurationImpl> spConfigImpl;
		for (int j = 0; j < iCfgCount; j++)
		{
			CComBSTR	bstrCfgName;

			CComPtr<VCConfiguration> spConfig = m_rgConfigs.GetAt(j);
			spConfigImpl = spConfig;
			if (spConfig == NULL || spConfigImpl == NULL)
				continue;
			spConfig->get_Name(&bstrCfgName);
			if (bstrCfgName == bstrName) 
				break;
		}
		if (j == iCfgCount) 
			continue;

		hr = spConfigImpl->ReadFromStream(spStream);
		RETURN_ON_FAIL(hr);
	}

	//TODO: handle reading any additional non-config objects here

	return S_OK;
}

STDMETHODIMP CProject::get_SccProjectName( BSTR* bstrName )
{
	CHECK_POINTER_VALID( bstrName );
	return m_bstrSccProjectName.CopyTo( bstrName );
}

STDMETHODIMP CProject::put_SccProjectName( BSTR bstrName )
{
	// Dirty the project ONLY if we're given new information and we're not in
	// project load
	CHECK_READ_POINTER_VALID( bstrName );
	if( PROJECT_IS_LOADED() && (!m_bstrSccProjectName || _wcsicmp( bstrName, m_bstrSccProjectName ) != 0) )
	{
		CHECK_OK_TO_DIRTY(0)
	}
	m_bstrSccProjectName = bstrName;
	return S_OK;
}

STDMETHODIMP CProject::get_SccAuxPath( BSTR* bstrName )
{
	CHECK_POINTER_VALID( bstrName );
	return m_bstrSccAuxPath.CopyTo( bstrName );
}

STDMETHODIMP CProject::put_SccAuxPath( BSTR bstrName )
{
	if (PROJECT_IS_LOADED() && (!m_bstrSccAuxPath || !bstrName || _wcsicmp(bstrName, m_bstrSccAuxPath) != 0))
	{
		CHECK_OK_TO_DIRTY(0);
	}

	m_bstrSccAuxPath = bstrName;
	return S_OK;
}

STDMETHODIMP CProject::get_SccLocalPath( BSTR* bstrName )
{
	CHECK_POINTER_VALID( bstrName );
	return m_bstrSccLocalPath.CopyTo( bstrName );
}

STDMETHODIMP CProject::put_SccLocalPath( BSTR bstrName )
{
	if (PROJECT_IS_LOADED() && (!m_bstrSccLocalPath || !bstrName || _wcsicmp(bstrName, m_bstrSccLocalPath) != 0))
	{
		CHECK_OK_TO_DIRTY(0);
	}

	m_bstrSccLocalPath = bstrName;
	return S_OK;
}

STDMETHODIMP CProject::get_SccProvider( BSTR* bstrName )
{
	CHECK_POINTER_VALID( bstrName );
	return m_bstrSccProvider.CopyTo( bstrName );
}

STDMETHODIMP CProject::put_SccProvider( BSTR bstrName )
{
	if (PROJECT_IS_LOADED() && (!m_bstrSccProvider || !bstrName || _wcsicmp(bstrName, m_bstrSccProvider) != 0))
	{
		CHECK_OK_TO_DIRTY(0);
	}

	m_bstrSccProvider = bstrName;
	return S_OK;
}

STDMETHODIMP CProject::get_ProjectDirectory(BSTR *pVal)
{
	CHECK_POINTER_VALID( pVal );
	m_bstrFullDir.CopyTo(pVal);

	return S_OK;
}

STDMETHODIMP CProject::get_Configurations(IDispatch **ppVal)
{
	CHECK_POINTER_VALID( ppVal );

	CComPtr<IVCCollection> pCollection;

	HRESULT hr = CCollection<VCConfiguration>::CreateInstance(&pCollection, &m_rgConfigs);
	if (SUCCEEDED(hr))
	{
		hr = pCollection.QueryInterface(ppVal);
	}
	return hr;
}

STDMETHODIMP CProject::get_Platforms(IDispatch **ppVal)
{
	CHECK_POINTER_VALID( ppVal );
		
	CComPtr<IVCCollection> pCollection;

	HRESULT hr = CCollection<VCPlatform>::CreateInstance(&pCollection, &m_rgPlatforms);
	if (SUCCEEDED(hr))
	{
		hr = pCollection.QueryInterface(ppVal);
	}
	return hr;
}

STDMETHODIMP CProject::get_Files(IDispatch **ppVal)
{
	CHECK_POINTER_VALID( ppVal );
		
	CComPtr<IVCCollection> pCollection;
	HRESULT hr = CCollection<VCFile>::CreateInstance(&pCollection, &m_rgFiles);
	if (SUCCEEDED(hr))
	{
		hr = pCollection.QueryInterface(ppVal);
	}
	return hr;
}

STDMETHODIMP CProject::get_Filters(IDispatch **ppVal)
{
	CHECK_POINTER_VALID( ppVal );

	CComPtr<IVCCollection> pCollection;

	HRESULT hr = CCollection<VCFilter>::CreateInstance(&pCollection, &m_rgFilters);
	if (SUCCEEDED(hr))
	{
		hr = pCollection.QueryInterface(ppVal);
	}
	return hr;
}

STDMETHODIMP CProject::get_Items(IDispatch** ppVal)
{
	CHECK_POINTER_VALID(ppVal);

	BuildTopLevelItemsCollection();

	CComPtr<IVCCollection> pCollection;
	HRESULT hr = CCollection<VCProjectItem>::CreateInstance(&pCollection, &m_rgTopLevelItems, this, 1);
	if (SUCCEEDED(hr))
		hr = pCollection.QueryInterface(ppVal);
	return hr;
}

STDMETHODIMP CProject::UpdateItemsCollection(DWORD dwCookie)
{
	if (dwCookie != 0)	// only care about updating a single collection
		BuildTopLevelItemsCollection();

	return S_OK;
}

void CProject::BuildTopLevelItemsCollection()
{
	if (!m_bItemsCollectionDirty)
		return;

	m_rgTopLevelItems.RemoveAll();

	long l;
	long lcItems = m_rgFiles.GetSize();
	// all files get added, regardless of where they are in the hierarchy
	for (l = 0; l < lcItems; l++)
	{
		CComQIPtr<VCProjectItem> spItem = m_rgFiles.GetAt(l);
		if (spItem == NULL)
			continue;

		m_rgTopLevelItems.Add(spItem);
	}

	lcItems = m_rgFilters.GetSize();
	for (l = 0; l < lcItems; l++)
	{
		CComQIPtr<VCProjectItem> spFilter = m_rgFilters.GetAt(l);
		if (spFilter == NULL)
			continue;
	
		m_rgTopLevelItems.Add(spFilter);
	}

	m_bItemsCollectionDirty = false;
}


STDMETHODIMP CProject::AssignActions(VARIANT_BOOL bOnLoad)
{
	m_bAssignedActions = true;

	if (bOnLoad == VARIANT_TRUE)
	{
		IVCBuildableItem *pBuildable = this;
		m_ProjectRegistry.RestoreToProject(pBuildable, TRUE);
	}

	int iMac = m_rgConfigs.GetSize();
	for (int idx = 0; idx <= iMac; idx++)
	{
		CComQIPtr<IVCBuildableItem> spBuildableItem = m_rgConfigs.GetAt(idx);
		if (spBuildableItem == NULL)
			continue;

		spBuildableItem->AssignActions(bOnLoad);
	}

	return S_OK;
}

STDMETHODIMP CProject::UnAssignActions(VARIANT_BOOL bOnClose)
{
	m_bAssignedActions = false;

	if (bOnClose == VARIANT_TRUE)
	{
		IVCBuildableItem *pBuildable = this;
		m_ProjectRegistry.RemoveFromProject(pBuildable, TRUE);
	}

	int iMac = m_rgConfigs.GetSize();
	for (int idx = 0; idx <= iMac; idx++)
	{
		CComQIPtr<IVCBuildableItem> spBuildableItem = m_rgConfigs.GetAt(idx);
		if (spBuildableItem == NULL)
			continue;

		spBuildableItem->UnAssignActions(bOnClose);
	}

	return S_OK;
}

STDMETHODIMP CProject::FileNameValid(/*[in]*/  LPCOLESTR szFileName, VARIANT_BOOL bSetErrorInfo)
{
	CPathW path;
	BOOL b = path.Create( szFileName );
	if( b )
	{
		return S_OK;
	}
	else
	{
		if( IsURLW( szFileName ) )
		{
			return CVCProjectEngine::DoSetErrorInfo2(VCPROJ_E_URL_INVALID, IDS_ERR_FILE_AS_URL, szFileName, (bSetErrorInfo == VARIANT_TRUE));
		}
		return CVCProjectEngine::DoSetErrorInfo2(E_INVALIDARG, IDS_ERR_INVALID_FILE_NAME, szFileName, (bSetErrorInfo == VARIANT_TRUE));
	}
}

STDMETHODIMP CProject::RemoveExistingFile(IDispatch* pItem)
{
	return DoRemoveExistingFile(pItem, FALSE);
}

STDMETHODIMP CProject::RemoveFile(/*[in]*/  IDispatch *pItem)
{
	return DoRemoveExistingFile(pItem, TRUE);
}

HRESULT CProject::DoRemoveExistingFile(IDispatch* pItem, BOOL bRemoveFromFilter)
{
	HRESULT hr = VCPROJ_E_NOT_FOUND;
	long l, lcItems;

	lcItems = m_rgFiles.GetSize();
	for (l = 0; l < lcItems && hr == VCPROJ_E_NOT_FOUND; l++)
	{
		CComPtr<VCFile> pFile;
		pFile = m_rgFiles.GetAt(l);
		if (pFile == NULL)
			continue;

		CComQIPtr<IDispatch> pDispFile = pFile;
		if (pItem != pDispFile)
			continue;

		CHECK_OK_TO_DIRTY(0);
		hr = QueryCanRemoveFile(pFile);
		RETURN_ON_FAIL(hr);

		m_rgFiles.RemoveAtIndex(l); // first remove the file from the project so we can't do this recursively...

		m_bItemsCollectionDirty = true;
		CComPtr<IDispatch> pDispParent;
		HRESULT	hrT = pFile->get_Parent(&pDispParent);

		if (pDispParent)
		{
			// fire events
			CComQIPtr<IVCProjectEngineImpl> pEngine = g_pProjectEngine;
			hr = E_UNEXPECTED;
			if (pEngine)
			{
				pEngine->DoFireItemRemoved(pDispFile, pDispParent);
				hr = S_OK;
			}
		}

		if (bRemoveFromFilter && pDispParent && pDispParent != static_cast<IDispatch *>(this))
		{
			CComQIPtr<VCFilter> pFilter = pDispParent;
			if (pFilter)
			{
#ifdef _DEBUG
				CComBSTR bstrName; pFilter->get_Name(&bstrName); // DEBUG
#endif
				pFilter->RemoveFile(pDispFile);
			}
		}
		// do close here, regardless of owner, so that ItemRemove event got fired properly above
		CComQIPtr<IVCFileImpl> pFileImpl = pFile;
		CComBSTR bstrFilePath;
		pFile->get_FullPath(&bstrFilePath);
		InformFileRemoved(pFile, bstrFilePath);		// needs to be before close 'cause we need parent info
		if( pFileImpl )
			pFileImpl->Close();
		hr = S_OK;
	}

	if (hr == VCPROJ_E_NOT_FOUND)
		return CVCProjectEngine::DoSetErrorInfo(VCPROJ_E_NOT_FOUND, IDS_ERR_FILE_NOT_FOUND_FOR_REMOVE, FALSE, NULL, TRUE);
	return hr;
}

STDMETHODIMP CProject::RemoveFilter(/*[in]*/  IDispatch *pItem)
{
	HRESULT hr = VCPROJ_E_NOT_FOUND;
	long l, lcItems;

	lcItems = m_rgFilters.GetSize();
	for (l = 0; l < lcItems && hr == VCPROJ_E_NOT_FOUND; l++)
	{
		CComPtr<VCFilter> pFilter = m_rgFilters.GetAt(l);
		if (pFilter == NULL)
			continue;

		CComQIPtr<IDispatch> pDispFilter = pFilter;
		if (pItem != pDispFilter)
			continue;
		CComQIPtr<IVCFilterImpl> pFilterImpl = pFilter;
		RETURN_ON_NULL2(pFilterImpl, E_UNEXPECTED);

		CHECK_OK_TO_DIRTY(0);

		// fire events
		CComQIPtr<IVCProjectEngineImpl> pEngine;

		pEngine = g_pProjectEngine;
		hr = E_UNEXPECTED;
		if (pEngine)
		{
			CComQIPtr<IDispatch> pDispParent = this;
			if( pDispParent )
				pEngine->DoFireItemRemoved( pDispFilter, pDispParent);
		}

		pFilter->Remove();
		m_rgFilters.RemoveAtIndex(l);
		m_bItemsCollectionDirty = true;
		pFilterImpl->Close();
		hr = S_OK;
	}

	if (hr == VCPROJ_E_NOT_FOUND)
		return CVCProjectEngine::DoSetErrorInfo(VCPROJ_E_NOT_FOUND, IDS_ERR_FILTER_NOT_FOUND_FOR_REMOVE);
	return hr;
}

STDMETHODIMP CProject::RemoveConfiguration(IDispatch *pDispConfig)
{
	// get the config interface
	CComQIPtr<VCConfiguration> pConfig = pDispConfig;
	RETURN_INVALID_ON_NULL(pConfig);

	return RemoveConfigurationInternal(pConfig);
}

HRESULT CProject::RemoveConfigurationInternal(VCConfiguration *pConfig)
{
	CHECK_OK_TO_DIRTY(0);

	// remove file configs
	long lcItems = m_rgFiles.GetSize();
	for( long l = 0; l < lcItems; l++ )
	{
		CComPtr<VCFile> pFile;
		pFile = m_rgFiles.GetAt(l);
		CComQIPtr<IVCFileImpl> pFileImpl = pFile;
		if (pFileImpl)
		{
			CComPtr<VCFileConfiguration> pFileConfig;
			pFileImpl->GetFileConfigurationForProjectConfiguration( pConfig, &pFileConfig );
			if( pFileConfig )
			{
				CComQIPtr<IDispatch> pDispFileConfig = pFileConfig;
				if( pDispFileConfig )
					pFileImpl->RemoveConfiguration( pDispFileConfig );
			}
		}
	}

	// remove the config from the collection
	m_rgConfigs.Remove( pConfig );

	// close the config object
	CComQIPtr<IVCConfigurationImpl> pConfigurationImpl = pConfig;
	if (pConfigurationImpl)
		pConfigurationImpl->Close(); // close down entirely; release all

	// fire an event so the ui becomes aware of the missing config
	CComQIPtr<IVCProjectEngineImpl> pEngine = g_pProjectEngine;
	if( pEngine )
	{
		CComQIPtr<IDispatch> pDispConfig = pConfig;
		if( pDispConfig )
			pEngine->DoFireItemRemoved( pDispConfig, static_cast<IDispatch*>(this) );
	}
	return S_OK;
}

STDMETHODIMP CProject::RemovePlatformInternal(IDispatch* pDispPlatform)
{
	CComQIPtr<VCPlatform> spPlatform = pDispPlatform;
	RETURN_ON_NULL2(spPlatform, E_UNEXPECTED);

	CHECK_OK_TO_DIRTY(0);

	CComBSTR bstrPlatformName;
	HRESULT hr = spPlatform->get_Name(&bstrPlatformName);
	VSASSERT(SUCCEEDED(hr) && bstrPlatformName.Length() > 0, "Hey, platforms should always have valid names!");
	if (SUCCEEDED(hr))
	{
		CStringW strPlatformName = bstrPlatformName;
		long lcItems = m_rgConfigs.GetSize();
		for (long l = 0; l < lcItems; l++)
		{
			CComPtr<VCConfiguration> pConfiguration = m_rgConfigs.GetAt(l);
			if (pConfiguration == NULL)
				continue;
			CComBSTR bstrConfigName;
			if (FAILED(pConfiguration->get_Name(&bstrConfigName)))
				continue;
			CStringW strConfigName = bstrConfigName;
			CStringW strConfigPlatName;
			int nBar = strConfigName.Find(L'|');
			if (nBar)
				strConfigPlatName = strConfigName.Right(strConfigName.GetLength()-nBar-1);
			if (strConfigPlatName.IsEmpty())
				continue;
			RemoveConfigurationInternal(pConfiguration);
		}
	}

	// remove the platform from the collection
	m_rgPlatforms.Remove( spPlatform );

	// fire an event so the ui becomes aware of the missing config
	CComQIPtr<IVCProjectEngineImpl> pEngine = g_pProjectEngine;
	if( pEngine )
	{
		CComQIPtr<IDispatch> spDispPlatform = spPlatform;
		if( spDispPlatform )
			pEngine->DoFireItemRemoved( spDispPlatform, static_cast<IDispatch*>(this) );
	}

	return S_OK;
}

STDMETHODIMP CProject::RemovePlatform(IDispatch* pDispPlatform)
{
	if (g_bInProjClose)
		return RemovePlatformInternal(pDispPlatform);

	if (CVCProjectEngine::s_pBuildPackage != NULL)	// let the build package handle letting the solution in on this
		return CVCProjectEngine::s_pBuildPackage->RemovePlatformFromProject(this, pDispPlatform);

	return RemovePlatformInternal(pDispPlatform);
}

STDMETHODIMP CProject::IsFileProbablyInProject( LPCOLESTR szFile, VARIANT_BOOL *pb)
{
	CHECK_POINTER_NULL(pb);
	*pb = VARIANT_FALSE;
	CStringW strPath = szFile;
	if (strPath.IsEmpty())
		return S_OK;

	BldFileRegHandle frh;
	frh = m_ProjectRegistry.LookupFile(strPath, FALSE /* do NOT verify case */);	// requires caller to have obtained actual case
	if( frh )
	{
		frh->ReleaseFRHRef();
		*pb = VARIANT_TRUE;
		return S_OK;
	}

	// Hmmm.  Might not exist.  If it doesn't, force it through a slow check by saying 
	// that it is probably in the project.
	CPathW pathFile;
	if (pathFile.Create(strPath) && !pathFile.ExistsOnDisk())
	{
		*pb = VARIANT_TRUE;
		return S_OK;
	}

	// OK, it exists, but we're not sure if it is ours or not.
	if (_wcsnicmp(strPath, m_bstrFullDir, m_bstrFullDir.Length()) == 0)
		*pb = VARIANT_TRUE;		// if it is in our directory or a subdirectory, it is likely ours

	return S_OK;
}

STDMETHODIMP CProject::get_ItemFileName(BSTR *pVal)
{
	CHECK_POINTER_NULL( pVal );
	return get_Name(pVal);
}

STDMETHODIMP CProject::get_ItemFullPath(BSTR* pbstrFullPath)
{
	CHECK_POINTER_NULL( pbstrFullPath );
	return get_ProjectFile(pbstrFullPath);
}

STDMETHODIMP CProject::get_ActionList(IVCBuildActionList** ppActionList)
{
	return E_UNEXPECTED;	// project doesn't own one of these
}

STDMETHODIMP CProject::get_FileRegHandle(void** pfrh)
{
	CHECK_POINTER_NULL(pfrh);

	if (m_frh == NULL)
	{
		CComBSTR bstrPath;
		get_ProjectFile(&bstrPath);
		CStringW strPath = bstrPath;
		if (!strPath.IsEmpty())
 			m_frh = CBldFileRegFile::GetFileHandle(strPath, TRUE);
	}
	*pfrh = (void *)m_frh;
	return S_OK;
}

STDMETHODIMP CProject::get_ContentList(IEnumVARIANT** ppContents)
{
	CHECK_POINTER_NULL(ppContents);
	*ppContents = NULL;
	
	CComPtr<IDispatch> spDispFiles;
	HRESULT hr = get_Files(&spDispFiles);
	CComQIPtr<IVCCollection> spCollection = spDispFiles;
	RETURN_ON_FAIL_OR_NULL2(hr, spCollection, E_OUTOFMEMORY);

	return spCollection->_NewEnum(reinterpret_cast<IUnknown **>(ppContents));	
}

STDMETHODIMP CProject::get_Registry(void** ppFileRegistry)
{
	CHECK_POINTER_NULL(ppFileRegistry);
	*ppFileRegistry = (void *)&m_ProjectRegistry;
	return S_OK;
}

STDMETHODIMP CProject::get_ProjectConfiguration(VCConfiguration** ppProjCfg)
{
	CHECK_POINTER_NULL(ppProjCfg);
	*ppProjCfg = NULL;
	return E_UNEXPECTED;
}

STDMETHODIMP CProject::get_ProjectInternal(VCProject** ppProject)
{
	CHECK_POINTER_NULL(ppProject);

	*ppProject = this;
	(*ppProject)->AddRef();
	return S_OK;
}

STDMETHODIMP CProject::get_ExistingBuildEngine(IVCBuildEngine** ppBldEngine)
{
	CHECK_POINTER_NULL(ppBldEngine);
	*ppBldEngine = NULL;
	return E_UNEXPECTED;
}

STDMETHODIMP CProject::get_PersistPath(BSTR* pbstrPersistPath)
{
	CHECK_POINTER_NULL( pbstrPersistPath );
	return get_ProjectFile(pbstrPersistPath);
}

STDMETHODIMP CProject::RefreshActionOutputs(long nPropID, IVCBuildErrorContext* pEC)
{
	return S_OK;	// meaningless to a non-config object
}

STDMETHODIMP CProject::HandlePossibleCommandLineOptionsChange(IVCBuildErrorContext* pEC)
{
	return S_FALSE;		// meaningless to a non-config object
}

STDMETHODIMP CProject::ClearDirtyCommandLineOptionsFlag()
{
	return S_FALSE;		// meaningless to a non-config object
}

STDMETHODIMP CProject::AddWebReference(BSTR bstrUrl, IDispatch** ppFile)
{
	return AddWSDL(bstrUrl, NULL, ppFile);
}

class CDownload : 
	public IBindStatusCallback,
	public CComObjectRoot
{
public:
	CDownload() {}
	~CDownload() {}
	static HRESULT CreateInstance(IBindStatusCallback** ppCallback)
	{
		CDownload *pVar;
		CComObject<CDownload> *pObj;
		HRESULT hr = CComObject<CDownload>::CreateInstance(&pObj);
		RETURN_ON_FAIL_OR_NULL(hr, pObj);
		pVar = pObj;
		pVar->AddRef();
		*ppCallback = pVar;
		return hr;
	}

BEGIN_COM_MAP(CDownload)
	COM_INTERFACE_ENTRY(IBindStatusCallback)
END_COM_MAP()

	// IBindStatusCallback
public:
	STDMETHOD(OnStartBinding)(DWORD, IBinding *) { return E_NOTIMPL; }
	STDMETHOD(GetPriority)(LONG *) { return E_NOTIMPL; }
	STDMETHOD(OnLowResource)(DWORD) { return E_NOTIMPL; }
	STDMETHOD(OnProgress)(ULONG, ULONG, ULONG, LPCWSTR) { return E_NOTIMPL; }
	STDMETHOD(OnStopBinding)(HRESULT, LPCWSTR) { return E_NOTIMPL; }
	STDMETHOD(GetBindInfo)(DWORD *grfBINDF, BINDINFO *pbindinfo)
	{
		CHECK_POINTER_NULL(pbindinfo);
	   pbindinfo->dwOptions |= BINDINFO_OPTIONS_USE_IE_ENCODING;
	   return S_OK;
	}
	STDMETHOD(OnDataAvailable)(DWORD, DWORD, FORMATETC *, STGMEDIUM *) { return E_NOTIMPL; }
	STDMETHOD(OnObjectAvailable)(REFIID, IUnknown *) { return E_NOTIMPL; }
};

STDMETHODIMP CProject::UpdateWSDL( BSTR bstrUrlIn, VARIANT_BOOL bExists, BSTR *pbstrSdlPath )
{
	CComBSTR bstrUrl = bstrUrlIn;

	if (bstrUrl.Length() == 0)
		return CVCProjectEngine::DoSetErrorInfo(E_INVALIDARG, IDS_ERR_EMPTY_URL, TRUE /* report */, NULL /* no help */, 
			FALSE /* !only errinfo */);
	CComVariant varUrl = bstrUrl;

	CComPtr<IXMLDOMDocument> pDoc;
	HRESULT hr = CoCreateInstance( CLSID_DOMDocument, NULL, CLSCTX_INPROC_SERVER, IID_IXMLDOMDocument, (void**)&pDoc );
	RETURN_ON_FAIL(hr);

	pDoc->put_async( VARIANT_FALSE );
	VARIANT_BOOL bSuccess;
	pDoc->load( varUrl, &bSuccess );
	if (bSuccess == VARIANT_FALSE)
	{
		// hmmm.  Wonder if it is a WSDL file someone forgot to append WSDL to for us...
		bstrUrl += L"?WSDL";
		CComVariant varUrl2 = bstrUrl;
		pDoc->load(varUrl2, &bSuccess);
		if (bSuccess == VARIANT_FALSE)	// nope, that wasn't it.  I give up.
			return CVCProjectEngine::DoSetErrorInfo2(E_INVALIDARG, IDS_ERR_UNSUPPORTED_URL, bstrUrlIn, 
			TRUE, L"VC.AddWebReferenceProblems", FALSE /* !only errinfo */);
	}

	CComBSTR bstr = L"contractRef";
	CComPtr<IXMLDOMNodeList> pResultList;
	hr = pDoc->getElementsByTagName( bstr, &pResultList );
	RETURN_ON_FAIL_OR_NULL(hr, pResultList);

	CStringW strSDLName, strSDLBase;
	CComBSTR bstrSDLURL;
	CComPtr<IXMLDOMNode> pNode;
	hr = pResultList->get_item( 0, &pNode );
	if( hr == S_OK )
	{
		// We have been given a vsdisco, transform into a wsdl
		CComPtr<IXMLDOMNamedNodeMap> pNodeMap;
		hr = pNode->get_attributes(&pNodeMap);
		RETURN_ON_FAIL_OR_NULL(hr, pNodeMap);

		CComPtr<IXMLDOMNode> pRefNode;
		CComBSTR bstrRef = L"ref";
		hr = pNodeMap->getNamedItem(bstrRef, &pRefNode);
		RETURN_ON_FAIL_OR_NULL(hr, pRefNode);

		CComVariant varRef;
		hr = pRefNode->get_nodeValue( &varRef );
		RETURN_ON_FAIL(hr);

		wchar_t szBuffer[4096];
		DWORD dwLen = 4095;
		InternetCombineUrlW( bstrUrl, varRef.bstrVal, szBuffer, &dwLen, NULL );
		bstrSDLURL = szBuffer;

		CStringW strVal;
		strVal = varRef.bstrVal;
		if (_wcsnicmp(strVal, L"http:", 5) == 0)
			strVal = strVal.Right(strVal.GetLength()-5);
		else if (_wcsnicmp(strVal, L"https:", 6) == 0)
			strVal = strVal.Right(strVal.GetLength()-6);
		// else leave it.

		CPathW pathTmp;
		if (!pathTmp.Create(strVal))
			return E_FAIL;

		pathTmp.GetBaseNameString(strSDLBase);
	}
	else
	{
		// We have been given a wsdl leave it alone.
		bstrSDLURL = bstrUrl;

		CComBSTR bstr = L"service";
		CComPtr<IXMLDOMNodeList> pResultList;
		hr = pDoc->getElementsByTagName( bstr, &pResultList );
		RETURN_ON_FAIL_OR_NULL(hr, pResultList);

		CComPtr<IXMLDOMNode> pNode;
		hr = pResultList->get_item( 0, &pNode );
		RETURN_ON_FAIL_OR_NULL(hr, pNode);

		// We have been given a vsdisco, transform into a wsdl
		CComPtr<IXMLDOMNamedNodeMap> pNodeMap;
		hr = pNode->get_attributes(&pNodeMap);
		RETURN_ON_FAIL_OR_NULL(hr, pNodeMap);

		CComPtr<IXMLDOMNode> pRefNode;
		CComBSTR bstrRef = L"name";
		hr = pNodeMap->getNamedItem(bstrRef, &pRefNode);
		RETURN_ON_FAIL_OR_NULL(hr, pRefNode);

		CComVariant varRef;
		hr = pRefNode->get_nodeValue( &varRef );
		RETURN_ON_FAIL(hr);

		strSDLBase = varRef.bstrVal;
	}
	if (bExists)
	{
		strSDLName = strSDLBase;
		strSDLName += L".wsdl";
	}
	else
	{
		CComPtr<IDispatch> pDisp;
		hr = get_Files( &pDisp );
		CComQIPtr<IVCCollection> pColl = pDisp;

		RETURN_ON_FAIL_OR_NULL2(hr, pColl, E_NOINTERFACE);
		CStringW strNewName;
		strNewName = strSDLBase;
		strNewName += L".wsdl";
		CComBSTR bstrName = strNewName;
		CComPtr<IDispatch> spDispFile;
		hr = pColl->Item( CComVariant( bstrName ), &spDispFile );
		if (spDispFile)	// exists, so we need to make a name that doesn't
		{
			int nIdx = 1;
			VARIANT_BOOL bFoundMatch = VARIANT_TRUE;
			while (bFoundMatch)
			{
				strNewName.Format(L"%s%d.wsdl", strSDLBase, nIdx);
				bstrName = strNewName;
				CComPtr<IDispatch> spDispFile2;
				hr = pColl->Item( CComVariant( bstrName ), &spDispFile2 );
				bFoundMatch = (spDispFile2 != NULL);
				nIdx++;
			}
		}
		strSDLName = strNewName;
	}

	CStringW strURL = bstrSDLURL;

	// Now write the file to disk
	CComBSTR bstrProjDir;
	hr = get_ProjectDirectory(&bstrProjDir);
	RETURN_ON_FAIL(hr);

	CDirW dirProj;
	if (!dirProj.CreateFromKnown(bstrProjDir))
		return E_FAIL;

	CPathW pathFile;
	if (!pathFile.CreateFromDirAndFilename(dirProj, strSDLName))
		return E_FAIL;
	CStringW strFullSdlPath;
	pathFile.GetFullPath(strFullSdlPath);
	
	CComPtr<IBindStatusCallback> spCallback;
	hr = CDownload::CreateInstance(&spCallback);
	RETURN_ON_FAIL(hr);
	hr = URLDownloadToFileW(NULL, strURL, strFullSdlPath, 0, spCallback);
	RETURN_ON_FAIL(hr);
	*pbstrSdlPath = SysAllocString(strFullSdlPath);
	return S_OK;
}

STDMETHODIMP CProject::AddWSDL(BSTR bstrUrlIn, VCFilter* pFilter, IDispatch** ppFile)
{

	HRESULT hr = S_OK;
	if (ppFile)
	{
		CHECK_POINTER_VALID(ppFile);
		*ppFile = NULL;
	}
	CComBSTR bstrUrl = bstrUrlIn;
	CComBSTR bstrSdlPath;
	hr = UpdateWSDL( bstrUrlIn, VARIANT_FALSE /* !exists */, &bstrSdlPath);
	RETURN_ON_FAIL(hr);

	// is this file in the project already??
	CComPtr<IDispatch> pDisp;
	hr = get_Files( &pDisp );
	CComQIPtr<IVCCollection> pColl = pDisp;

	RETURN_ON_FAIL_OR_NULL2(hr, pColl, E_NOINTERFACE);
	CComBSTR bstrPath;
	CComPtr<IDispatch> spDispFile;
	hr = pColl->Item( CComVariant( bstrSdlPath ), &spDispFile );

	// if the file isn't in the project, we need to add it
	// which means we need to check with SCC first
	if( hr != S_OK || !spDispFile )
	{
		spDispFile = NULL;
		if (pFilter)
			hr = pFilter->AddFile(bstrSdlPath, &spDispFile);

		else
			hr = AddFile(bstrSdlPath, &spDispFile);

		if (hr == VCPROJ_E_FILE_EXISTS)		// don't care if the file is already there
			hr = S_OK;
	}

	RETURN_ON_FAIL(hr);

	// now, we need to persist that URL.  Since we store that on the tool, we need to store it for all configs just to be safe.
	CComQIPtr<VCFile> spFile = spDispFile;
	if (spFile)
	{
		CComPtr<IDispatch> spDispCfgs;
		spFile->get_FileConfigurations(&spDispCfgs);
		CComQIPtr<IVCCollection> spColl = spDispCfgs;
		if (spColl)
		{
			CComPtr<IEnumVARIANT> spCfgs;
			if (SUCCEEDED(spColl->_NewEnum(reinterpret_cast<IUnknown **>(&spCfgs))) && spCfgs)
			{
				spCfgs->Reset();
				while (TRUE)
				{
					CComVariant varRes;
					HRESULT hrT = spCfgs->Next(1, &varRes, NULL);
					if (hrT == S_OK && (varRes.vt == VT_DISPATCH || varRes.vt == VT_UNKNOWN))
					{
						CComQIPtr<VCFileConfiguration> spFileCfg = varRes.pdispVal;
						if (spFileCfg)
						{
							CComPtr<IDispatch> spDispTool;
							hrT = spFileCfg->get_Tool(&spDispTool);
							if (SUCCEEDED(hrT))
							{
								CComQIPtr<VCWebServiceProxyGeneratorTool> spTool = spDispTool;
								if (spTool)
									spTool->put_URL(bstrUrl);
							}
						}
					}
					else
						break;
				}
			}
		}
	}

	// now, make sure we've got a unique output name for the file
	MakeOutputFileUnique(spFile);

	if (ppFile)
		*ppFile = spDispFile.Detach();
	return S_OK;
}

STDMETHODIMP CProject::MakeOutputFileUnique(VCFile* pFile)
{
	CComQIPtr<IVCFileImpl> spFileImpl = pFile;
	RETURN_ON_NULL2(spFileImpl, S_OK);

	long lcItems = m_rgConfigs.GetSize();
	for (long idx = 0; idx < lcItems; idx++)
	{
		CComQIPtr<IVCConfigurationImpl> spCfgImpl = m_rgConfigs.GetAt(idx);
		CComQIPtr<VCConfiguration> spCfg = spCfgImpl;
		if (spCfg == NULL || spCfgImpl == NULL)
			continue;

		VARIANT_BOOL bUnique = VARIANT_TRUE;
		long nSuffix = 1;
		CComPtr<VCFileConfiguration> spFileCfg;
		HRESULT hr = spFileImpl->GetFileConfigurationForProjectConfiguration(spCfg, &spFileCfg);
		if (FAILED(hr))
			continue;
		CComQIPtr<IVCFileConfigurationImpl> spFileCfgImpl = spFileCfg;
		if (spFileCfgImpl == NULL)
			continue;
		if ((spCfgImpl->CreatesUniqueOutputName(spFileCfgImpl, &bUnique) != S_OK || bUnique != VARIANT_TRUE))
		{
			CComBSTR bstrDefFormat;
			spFileCfgImpl->get_DefaultOutputFileFormat(&bstrDefFormat);
			CStringW strDefFormat = bstrDefFormat;
			bUnique = VARIANT_FALSE;
			while (!bUnique)
			{
				CStringW strNewOutName;
				strNewOutName.Format(strDefFormat, nSuffix);
				CComBSTR bstrNewOutName = strNewOutName;
				spFileCfgImpl->put_OutputFile(bstrNewOutName);

				nSuffix++;
				if ((spCfgImpl->CreatesUniqueOutputName(spFileCfgImpl, &bUnique) != S_OK || bUnique != VARIANT_TRUE))
					bUnique = VARIANT_FALSE;
			}
		}
	}

	return S_OK;
}

STDMETHODIMP CProject::get_Project(IDispatch * *Val)
{
	CHECK_POINTER_VALID(Val);
	CComQIPtr<IDispatch> spDisp = this;
	*Val = spDisp.Detach();
	return S_OK;
}

STDMETHODIMP CProject::get_Parent(IDispatch * *Val)
{
	CHECK_POINTER_VALID(Val);
	Val = NULL;
	return S_FALSE;
}

STDMETHODIMP CProject::get_Kind(BSTR* kind)
{
	CHECK_POINTER_VALID(kind);
	CComBSTR bstrKind = L"VCProject";
	*kind = bstrKind.Detach();
	return S_OK;
}

/* static */
BOOL CProject::ForwardTrackEvents(VCFilter* pFilterParent)
{
	if (!PROJECT_IS_LOADED())
		return FALSE;

	RETURN_ON_NULL2(CVCProjectEngine::s_pBuildPackage, FALSE);
	RETURN_ON_NULL2(pFilterParent, TRUE);

	VARIANT_BOOL bScc = VARIANT_TRUE;
	if (SUCCEEDED(pFilterParent->get_SourceControlFiles(&bScc)) && bScc == VARIANT_FALSE)
		return FALSE;

	return TRUE;
}

/* static */
HRESULT CProject::QueryCanAddFile(VCProject* pProj, VCFilter* pFilter, LPCOLESTR szFile, BOOL bSetErrorInfo)
{
	if (!ForwardTrackEvents(NULL))	// call ForwardTrackEvents here ONLY for quick & dirty checks
		return S_OK;
	// once the project is loaded, all files must make this check. files in folders marked 'not for scc'
	// will be excluded from SCC in the ItemAdded event handler
	return CVCProjectEngine::s_pBuildPackage->AllowedToAddFile(pProj, szFile, bSetErrorInfo ? VARIANT_TRUE : VARIANT_FALSE);
}

BOOL CProject::DetermineFileParentFilter(VCFile* pFile, CComQIPtr<VCFilter>& rspFilterParent)
{
	RETURN_ON_NULL2(pFile, FALSE);

	CComPtr<IDispatch> spDispParent;
	pFile->get_Parent(&spDispParent);
	rspFilterParent = spDispParent;

	return (rspFilterParent != NULL);
}

HRESULT CProject::QueryCanRemoveFile(VCFile* pFile)
{
	// warning: if you remove this ForwardTrackEvents, be sure to check CVCProjectEngine::s_pBuildPackage for NULL...
	if (!ForwardTrackEvents(NULL))	// check it once for cheap and dirty check
		return S_OK;

	CComQIPtr<VCFilter> spFilterParent;
	DetermineFileParentFilter(pFile, spFilterParent);
	// warning: if you remove this ForwardTrackEvents, be sure to check CVCProjectEngine::s_pBuildPackage for NULL...
	if (spFilterParent && !ForwardTrackEvents(spFilterParent))	// check it again with the parent resolved
		return S_OK;

	VSASSERT(pFile, "Hey, how did we get here with a NULL pFile?");
	if (pFile == NULL)
		return CVCProjectEngine::DoSetErrorInfo(VCPROJ_E_INTERNAL_ERR, IDS_ERR_INTERNAL_ERROR);
	
	CComBSTR bstrPath;
	HRESULT hr = pFile->get_FullPath(&bstrPath);
	RETURN_ON_FAIL(hr);

	return CVCProjectEngine::s_pBuildPackage->AllowedToRemoveFile(this, bstrPath);
}

HRESULT CProject::InformFileAdded(VCProject* pProject, VCFile* pFile, BSTR bstrPath)
{
	// warning: if you remove this ForwardTrackEvents, be sure to check CVCProjectEngine::s_pBuildPackage for NULL...
	if (!ForwardTrackEvents(NULL))	// check it once for cheap and dirty check
		return S_OK;

	CComQIPtr<VCFilter> spFilterParent;
	DetermineFileParentFilter(pFile, spFilterParent);
	// warning: if you remove this ForwardTrackEvents, be sure to check CVCProjectEngine::s_pBuildPackage for NULL...
	if (spFilterParent && !ForwardTrackEvents(spFilterParent))	// check it again with the parent resolved
		return S_OK;

	// need to pass the full path through
	CDirW dir;
	CComBSTR bstrProjDir;
	pProject->get_ProjectDirectory( &bstrProjDir );
	dir.CreateFromString( bstrProjDir );
	CPathW path;
	path.CreateFromDirAndFilename( dir, bstrPath );
	CComBSTR bstrFullPath = path.GetFullPath();

	return CVCProjectEngine::s_pBuildPackage->InformFileAdded(pProject, bstrFullPath);
}

HRESULT CProject::InformFileRemoved(VCFile* pFile, BSTR bstrPath)
{
	// warning: if you remove this ForwardTrackEvents, be sure to check CVCProjectEngine::s_pBuildPackage for NULL...
	if (!ForwardTrackEvents(NULL))	// check it once for cheap and dirty check
		return S_OK;

	CComQIPtr<VCFilter> spFilterParent;
	DetermineFileParentFilter(pFile, spFilterParent);
	// warning: if you remove this ForwardTrackEvents, be sure to check CVCProjectEngine::s_pBuildPackage for NULL...
	if (spFilterParent && !ForwardTrackEvents(spFilterParent))	// check it again with the parent resolved
		return S_OK;

	return CVCProjectEngine::s_pBuildPackage->InformFileRemoved(this, bstrPath);
}

STDMETHODIMP CProject::AddWebReferenceEx(LPCOLESTR szUrl)
{
    CComPtr<IDispatch> pDisp;
    CComBSTR bstrUrl = szUrl;
    return AddWebReference(bstrUrl, &pDisp);
}


STDMETHODIMP CProject::IsPropertyReadOnly(DISPID dispid, BOOL *fReadOnly)
{ 
	*fReadOnly = TRUE;
	return S_OK; 
}

STDMETHODIMP CProject::GetLocalizedPropertyInfo(DISPID dispid, LCID localeID, BSTR *pbstrName, BSTR *pbstrDesc)
{
	CComQIPtr<IDispatch> pdisp;
	QueryInterface(__uuidof(IDispatch), (void**)&pdisp);
	if (pdisp == NULL)
		return DoSetErrorInfo(VCPROJ_E_INTERNAL_ERR, IDS_ERR_INTERNAL_ERROR);

	CComPtr<ITypeInfo> pTypeInfo;
	HRESULT hr = pdisp->GetTypeInfo(0, LANG_NEUTRAL, &pTypeInfo);
	CComQIPtr<ITypeInfo2> pTypeInfo2 = pTypeInfo;
	RETURN_ON_FAIL(hr);
	if (pTypeInfo2 == NULL)
		return DoSetErrorInfo(VCPROJ_E_INTERNAL_ERR, IDS_ERR_INTERNAL_ERROR);

	CComBSTR bstrDoc;
	hr = pTypeInfo2->GetDocumentation2(dispid, localeID, &bstrDoc, NULL, NULL);
	RETURN_ON_FAIL(hr);
	
	if (bstrDoc.m_str == NULL)
		return DoSetErrorInfo(VCPROJ_E_INTERNAL_ERR, IDS_ERR_INTERNAL_ERROR);

	LPOLESTR pDesc = wcsstr( bstrDoc, L": " );
	if (pDesc == NULL)
		return DoSetErrorInfo(VCPROJ_E_INTERNAL_ERR, IDS_ERR_INTERNAL_ERROR);

	int nSize = (int)(pDesc - bstrDoc);
	pDesc+=2;

	CComBSTR bstrName( nSize, bstrDoc );
	if (pbstrName != NULL)
		*pbstrName = bstrName.Detach();

	CComBSTR bstrDesc( pDesc );
	if (pbstrDesc != NULL)
		*pbstrDesc = bstrDesc.Detach();
	
	return S_OK;
}

STDMETHODIMP CProject::get_VCProjectEngine(IDispatch** ppProjEngine)
{
	CHECK_POINTER_VALID(ppProjEngine);
	RETURN_ON_NULL(g_pProjectEngine);
	return g_pProjectEngine->QueryInterface(IID_IDispatch, (void **)ppProjEngine);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\vcpb\ProjEvaluator.cpp ===
#include "stdafx.h"
#include <register.h>

#include "ProjEvaluator.h"
#include "fileregistry.h"
#include "bldhelpers.h"
#include "BuildEngine.h"

CStringW CProjectEvaluator::s_strVCDir = L"";
CStringW CProjectEvaluator::s_strVSDir = L"";
CStringW CProjectEvaluator::s_strComDir = L"";
CStringW CProjectEvaluator::s_strComVer = L"";
CStringW CProjectEvaluator::s_strComSDKDir = L"";
bool CProjectEvaluator::s_bComDirsInit = false;

//
// primitive custom build 'tool macros'
//

typedef struct 
{
	UINT idMacro;
	const wchar_t * pchName;
} S_ToolMacroMapEl;

// we read this from the bottom, so put most frequently used stuff at the end
const S_ToolMacroMapEl mapToolMacros[] =
{
	{IDMACRO_SOLNEXT,	L"SolutionExt"},		// solution extension (ex: .sln)
	{IDMACRO_PROJEXT,	L"ProjectExt"},			// project extension (ex: .vcproj)
	{IDMACRO_PLATNAME,	L"PlatformName"},		// platform name
	{IDMACRO_SOLNBASE,	L"SolutionName"},		// solution file basename (ex: foo)
	{IDMACRO_SOLNDIR,	L"SolutionDir"},		// absolute path to solution directory (ex: c:\foo\)
	{IDMACRO_SOLNPATH,	L"SolutionPath"},		// absolute path to solution file (ex: c:\foo\foo.sln)
	{IDMACRO_SOLNFILE,	L"SolutionFileName"},	// solution file basename + extension (ex: foo.sln)
	{IDMACRO_REMOTEMACH,L"RemoteMachine"},		// remote machine name (ex: MyServer)
	{IDMACRO_PROJDIR,	L"ProjectDir"},			// absolute path to project directory (ex: c:\foo\bar\)
	{IDMACRO_TARGDIR,	L"TargetDir"},			// target (output) directory (ex: c:\foo\bar\debug\)
	{IDMACRO_INPTDIR,	L"InputDir"},			// input directory (ex: c:\foo\bar\)
	{IDMACRO_ENVDIR,	L"DevEnvDir"},			// devenv directory
	{IDMACRO_TARGFILE,	L"TargetFileName"},		// target (output) file basename + extension (ex: foobar.exe)
	{IDMACRO_INPTEXT,	L"InputExt"},			// input extension (ex: .cpp)
	{IDMACRO_TARGEXT,	L"TargetExt"},			// target (output) file extension (ex: .exe)
	{IDMACRO_PROJFILE,	L"ProjectFileName"},	// project file basename + extension (ex: bar.vcproj)
	{IDMACRO_PROJPATH,	L"ProjectPath"},		// absolute path to project file (ex: c:\foo\bar\bar.vcproj)
	{IDMACRO_INPTFILE,	L"InputFileName"},		// input file basename + extension (ex: myfile.cpp)
	{IDMACRO_INPTPATH,	L"InputPath"},			// full path of input (ex: c:\foo\bar\myfile.cpp)
	{IDMACRO_INPTBASE,	L"InputName"},			// input file basename (ex: myfile)
	{IDMACRO_TARGPATH,	L"TargetPath"},			// full path of target (output) (ex: c:\foo\bar\debug\foobar.exe)
	{IDMACRO_TARGBASE,	L"TargetName"},			// target (output) file basename (ex: foobar)
	{IDMACRO_PROJBASE,	L"ProjectName"},		// project file basename (ex: bar)
	{IDMACRO_CFGNAME,	L"ConfigurationName"},	// configuration name
	{IDMACRO_OUTDIR,	L"OutDir"},				// output directory
	{IDMACRO_INTDIR,	L"IntDir"},				// intermediate directory
	{IDMACRO_VCDIR,		L"VCInstallDir"},		// installation directory for Visual C++
	{IDMACRO_VSDIR,		L"VSInstallDir"},		// installation directory for Visual Studio
	{IDMACRO_COMDIR,	L"FrameworkDir"},		// root directory for COM+
	{IDMACRO_COMSDKDIR,	L"FrameworkSDKDir"},	// root directory for the COM+ framework SDK
	{IDMACRO_COMVER,	L"FrameworkVersion"},	// version of COM+ we're running
	{IDMACRO_INHERIT,	L"Inherit"},			// put multi-prop inheritance HERE (suppress when scanning here)
	{IDMACRO_NOINHERIT,	L"NoInherit"},			// explicitly don't inherit in a multi-prop (suppress when scanning here)
};


// map a macro name to a macro id (IDM_)
BOOL CProjectEvaluator::MapMacroNameToId(const wchar_t* pchName, int& cchName, UINT& idMacro)
{
	cchName = 0;
	WCHAR* chCloseParen = wcschr(pchName, L')');
	int nCloseParenLoc = (chCloseParen == NULL) ? -1 : (int)(chCloseParen - pchName);

	for (int i = sizeof(mapToolMacros) / sizeof(S_ToolMacroMapEl); i > 0; i--)
	{
		int cch = (int)wcslen(mapToolMacros[i-1].pchName);
		if ((cch > cchName) &&
			(_wcsnicmp(mapToolMacros[i-1].pchName, pchName, cch) == 0))
		{
			idMacro = mapToolMacros[i-1].idMacro;
			cchName = cch;	// found one match, possibly try for bigger match....
			if (nCloseParenLoc > 0 && cchName == nCloseParenLoc)	// exact match, let's go
				break;
		}
	}

	return cchName != 0;	// not mapped
}

// map a macro id (IDM_) to the macro name
BOOL CProjectEvaluator::MapMacroIdToName(UINT idMacro, CStringW& strName)
{
	for (int i = sizeof(mapToolMacros) / sizeof(S_ToolMacroMapEl); i > 0; i--)
	{
		if (mapToolMacros[i-1].idMacro == idMacro)
		{
			strName = mapToolMacros[i-1].pchName;
			return TRUE;	// mapped
		}
	}

	return FALSE;	// not mapped
}

BOOL CProjectEvaluator::GetSolutionPath(CPathW& rSolnPath)
{
	CStringW strSolnFile;
	RETURN_ON_NULL2(CVCProjectEngine::s_pBuildPackage, FALSE);
	CComBSTR bstrSolnFile;
	HRESULT hr = CVCProjectEngine::s_pBuildPackage->get_SolutionFile(&bstrSolnFile);
	strSolnFile = bstrSolnFile;
	if (strSolnFile.IsEmpty())
		return FALSE;

	BOOL bOK = rSolnPath.Create(strSolnFile);
	VSASSERT(bOK, "Solution path bad!");
	return TRUE;
}

BOOL CProjectEvaluator::GetSolutionDirectory(CStringW& rstrDir)
{
	CPathW solnPath;
	if (!GetSolutionPath(solnPath))
		return FALSE;

	CDirW solnDir;
	BOOL bOK = solnDir.CreateFromPath(solnPath);
	VSASSERT(bOK, "Solution directory bad!");

	rstrDir = (const wchar_t *)solnDir;
	NormalizeDirectoryString(rstrDir);

	return TRUE;
}

void CProjectEvaluator::NormalizeDirectoryString(CStringW& strDir)
{
	int nLen = strDir.GetLength();
	if (nLen <= 0)
		return;	// nothing to do

	if (strDir[nLen-1] == L'\\')
		return;		// already looks fine
	else if (strDir[nLen-1] == L'/')
		strDir.SetAt(nLen-1, L'\\');		// make it go the correct direction
	else
		strDir += L"\\";
}

BOOL CProjectEvaluator::GetProjectDirectoryPath(IVCPropertyContainer* pPropContainer, CPathW& rProjDirPath, 
	CStringW& rstrProjDirPath, BOOL bNormalize)
{
	RETURN_ON_NULL2(pPropContainer, FALSE);

	CComBSTR bstrProjPath;
	HRESULT hr = pPropContainer->GetStrProperty(VCPROJID_ProjectDirectory, &bstrProjPath);	// should never have macros in it
	VSASSERT(SUCCEEDED(hr), "Should always be able to get project directory!");
	rstrProjDirPath = bstrProjPath;
	if (rstrProjDirPath.IsEmpty())
		return FALSE;
	if (bNormalize)
		NormalizeDirectoryString(rstrProjDirPath);
	else
	{
		int nLast = rstrProjDirPath.GetLength()-1;
		if (rstrProjDirPath.GetAt(nLast) == L'\\' || rstrProjDirPath.GetAt(nLast) == L'/')
			rstrProjDirPath = rstrProjDirPath.Left(nLast);
	}

	if (rProjDirPath.CreateFromKnown(rstrProjDirPath))
		return TRUE;

	VSASSERT(FALSE, "Failed to create project directory path");
	return FALSE;
}

BOOL CProjectEvaluator::GetProjectDirectoryDir(IVCPropertyContainer* pPropContainer, CDirW& rProjDir)
{
	RETURN_ON_NULL2(pPropContainer, FALSE);

	CComBSTR bstrProjPath;
	HRESULT hr = pPropContainer->GetStrProperty(VCPROJID_ProjectDirectory, &bstrProjPath);	// should never have macros in it
	VSASSERT(SUCCEEDED(hr), "Should always be able to get project directory!");
	CStringW strProjPath = bstrProjPath;
	if (strProjPath.IsEmpty())
		return FALSE;

	if (rProjDir.CreateFromKnown(strProjPath))
		return TRUE;

	VSASSERT(FALSE, "Failed to create project directory path");
	return FALSE;
}

// get the value of a macro
BOOL CProjectEvaluator::GetMacroValue(UINT idMacro, CStringW& strMacroValue, IVCPropertyContainer* pPropContainer)
{
	VSASSERT(pPropContainer != NULL, "Cannot evaluate a macro without a property container to look things up in.");
	RETURN_ON_NULL2(pPropContainer, FALSE);

	CPathW path;
	CComBSTR bstrTemp;

	// empty macro-value
	strMacroValue.Empty();

	HRESULT hr = S_OK;

	switch (idMacro)
	{
		case IDMACRO_CFGNAME:	// configuration name
			hr = pPropContainer->GetEvaluatedStrProperty(VCCFGID_ConfigurationName, &bstrTemp);
			VSASSERT(SUCCEEDED(hr), "Should always be able to get configuration name!");
			strMacroValue = bstrTemp;
			break;

		case IDMACRO_INTDIR:	// intermediate directory
		case IDMACRO_OUTDIR:	// output directory
			EvalIntDirOutDir(pPropContainer, idMacro == IDMACRO_INTDIR, strMacroValue);
			break;

		case IDMACRO_ENVDIR:	// devenv directory
			UtilGetDevenvFolder(strMacroValue);
			break;

		case IDMACRO_SOLNDIR:	// solution directory
			GetSolutionDirectory(strMacroValue);
			break;

		case IDMACRO_SOLNBASE:	// solution file basename
			if (GetSolutionPath(path))
				path.GetBaseNameString(strMacroValue);
			break;

		case IDMACRO_SOLNFILE:	// solution file name
			if (GetSolutionPath(path))
				strMacroValue = path.GetFileName();
			break;

		case IDMACRO_SOLNEXT:	// solution file extension
			if (GetSolutionPath(path))
				strMacroValue = path.GetExtension();
			break;

		case IDMACRO_SOLNPATH:	// solution file path
			if (GetSolutionPath(path))
				path.GetFullPath(strMacroValue);
			break;

		case IDMACRO_PROJDIR:	// project directory
			if (!GetProjectDirectoryPath(pPropContainer, path, strMacroValue, TRUE))
				strMacroValue.Empty();
			break;

		case IDMACRO_PROJFILE:	// project file base name + extension
		case IDMACRO_PROJPATH:	// full path of project
		case IDMACRO_PROJEXT:	// project file extension
			EvalProjectMacroValue(pPropContainer, idMacro, strMacroValue);
			break;

		case IDMACRO_PROJBASE:	// project file basename
			hr = pPropContainer->GetEvaluatedStrProperty(VCPROJID_Name, &bstrTemp);
			VSASSERT(SUCCEEDED(hr), "Should always be able to get at least default prop from a property container!");
			strMacroValue = bstrTemp;
			break;

		case IDMACRO_TARGDIR:	// target directory
		case IDMACRO_TARGPATH:	// full path of target
		case IDMACRO_TARGFILE:	// base name + extension of target
		case IDMACRO_TARGEXT:	// extension of target
		case IDMACRO_TARGBASE:	// target file basename
			EvalTargetMacroValue(pPropContainer, idMacro, strMacroValue);
			break;

		case IDMACRO_INPTDIR:	// input directory
		case IDMACRO_INPTEXT:	// extension of input
		case IDMACRO_INPTPATH:	// full path of input
		case IDMACRO_INPTFILE:	// base name + extension of input
		case IDMACRO_INPTBASE:	// input file basename
			EvalInputMacroValue(pPropContainer, idMacro, strMacroValue);
			break;

		case IDMACRO_REMOTEMACH:
			GetDebuggerProperty(pPropContainer, VCDSID_RemoteMachine, strMacroValue);
			break;

		case IDMACRO_PLATNAME:
			hr = pPropContainer->GetEvaluatedStrProperty(VCPLATID_Name, &bstrTemp);
			VSASSERT(SUCCEEDED(hr), "Should always be able to get at least default prop from a property container!");
			strMacroValue = bstrTemp;
			break;

		case IDMACRO_VCDIR:
			if (s_strVCDir.IsEmpty())
				UtilGetVCInstallFolder(s_strVCDir);
			strMacroValue = s_strVCDir;
			break;

		case IDMACRO_VSDIR:
			if (s_strVSDir.IsEmpty())
				UtilGetVSInstallFolder(s_strVSDir);
			strMacroValue = s_strVSDir;
			break;

		case IDMACRO_COMDIR:
		case IDMACRO_COMSDKDIR:
		case IDMACRO_COMVER:
			EvalFrameworkMacro(idMacro, strMacroValue);
			break;

		case IDMACRO_INHERIT:
		case IDMACRO_NOINHERIT:
			strMacroValue.Empty();	// just suppress the macro
			break;

		// didn't deal with this
		default:
			return FALSE;	// invalid
	}

	return TRUE;	// ok
}

BOOL CProjectEvaluator::EvalIntDirOutDir(IVCPropertyContainer* pPropContainer, BOOL bIsIntDir, CStringW& strMacroValue)
{
	// directory prop?
	long idOutDirProp = bIsIntDir ? VCCFGID_IntermediateDirectory : VCCFGID_OutputDirectory;

	CComBSTR bstrDir;
	HRESULT hr = pPropContainer->GetEvaluatedStrProperty(idOutDirProp, &bstrDir);
	VSASSERT(SUCCEEDED(hr), "Should always be able to get at least default prop from a property container!");
	strMacroValue = bstrDir;
	if (strMacroValue.IsEmpty())
		strMacroValue = L'.';

	return TRUE;
}

BOOL CProjectEvaluator::EvalProjectMacroValue(IVCPropertyContainer* pPropContainer, UINT idMacro, CStringW& strMacroValue)
{
	CComBSTR bstrProjFile;
	HRESULT hr = pPropContainer->GetEvaluatedStrProperty(VCPROJID_ProjectFile, &bstrProjFile);

	strMacroValue = bstrProjFile;
	if (idMacro == IDMACRO_PROJPATH)
		return TRUE;	// we're done

	CPathW pathProj;
	if (!pathProj.Create(strMacroValue))
	{
		strMacroValue.Empty();
		return FALSE;
	}

	if (idMacro == IDMACRO_PROJFILE)
		strMacroValue = pathProj.GetFileName();
	else	// idMacro == IDMACRO_PROJEXT
		strMacroValue = pathProj.GetExtension();

	return TRUE;
}

BOOL CProjectEvaluator::EvalTargetMacroValue(IVCPropertyContainer* pPropContainer, UINT idMacro, CStringW& strMacroValue)
{
	CComBSTR bstrOutput;
	HRESULT hr = pPropContainer->GetEvaluatedStrProperty(VCCFGID_PrimaryOutput, &bstrOutput);
//	Actually, you CAN get a bad default prop for this, such as when you have a Custom AppWizard project
//	VSASSERT(SUCCEEDED(hr), "Should always be able to get at least default prop from a property container!");
	CStringW strTemp = bstrOutput;
	if (FAILED(hr))
	{
		CComQIPtr<IVCConfigurationImpl> spProjCfgImpl = pPropContainer;
		if (spProjCfgImpl)
		{
			CComPtr<IVCBuildErrorContext> spEC;
			if (SUCCEEDED(spProjCfgImpl->get_ErrorContext(&spEC)) && spEC)
			{
				long nErrPropID = -1;
				CComPtr<IVCToolImpl> spOutputTool;
				spProjCfgImpl->GetPrimaryOutputFileID(&spOutputTool, &nErrPropID);
				CBldAction::InformUserAboutBadFileName(spEC, pPropContainer, spOutputTool, nErrPropID, strTemp);
			}
		}
		return FALSE;
	}
	if (strTemp.IsEmpty())
		return FALSE;
	CPathW pathOutput;
	if (!pathOutput.CreateFromKnown(strTemp))
		return FALSE;

	if (idMacro == IDMACRO_TARGDIR)
	{
		CDirW dir;
		if (dir.CreateFromPath(pathOutput))
		{
			strMacroValue = (const wchar_t *)dir;
			NormalizeDirectoryString(strMacroValue);
		}
	}
	else if (idMacro == IDMACRO_TARGPATH)
	{	// full path of target
		pathOutput.GetFullPath(strMacroValue);
	}
	else if (idMacro == IDMACRO_TARGFILE)
	{	// base name + extension of target
		strMacroValue = pathOutput.GetFileName();
	}
	else if (idMacro == IDMACRO_TARGEXT)
	{	// extension of target
		strMacroValue = pathOutput.GetExtension();
	}
	else
	{
		VSASSERT(idMacro == IDMACRO_TARGBASE, "Bad macro value");
		pathOutput.GetBaseNameString(strMacroValue);
	}

	return TRUE;
}

BOOL CProjectEvaluator::EvalInputMacroValue(IVCPropertyContainer* pPropContainer, UINT idMacro, CStringW& strMacroValue)
{
	BldFileRegHandle frh = NULL;
	CComPtr<IVCPropertyContainer> spActualContainer;
	CVCProjectEngine::ResolvePropertyContainer(pPropContainer, &spActualContainer);
	CComQIPtr<IVCBuildableItem> spItem = spActualContainer;
	RETURN_ON_NULL2(spItem, FALSE);

	HRESULT hr = spItem->get_FileRegHandle((void **)&frh);
	VSASSERT(SUCCEEDED(hr), "All items have a file reg handle!");

	RETURN_ON_NULL2(frh, FALSE);

	CBldFileRegEntry* fre = g_FileRegistry.GetRegEntry(frh);
	const CPathW* pPath = NULL;
	if (fre)
		pPath = fre->GetFilePath();
	RETURN_ON_NULL2(pPath, FALSE);

	CStringW strTemp;
	if (idMacro == IDMACRO_INPTDIR)
	{
		CDirW dir;
		if (dir.CreateFromPath(*pPath))
		{
			strMacroValue = (const wchar_t *)dir;
			NormalizeDirectoryString(strMacroValue);
		}
	}
	else if (idMacro == IDMACRO_INPTPATH)
	{
		pPath->GetFullPath(strMacroValue);
	}
	else if (idMacro == IDMACRO_INPTFILE)
	{
		strMacroValue = pPath->GetFileName();
	}
	else if (idMacro == IDMACRO_INPTEXT)
	{
		strMacroValue = pPath->GetExtension();
	}
	else
	{
		VSASSERT(idMacro == IDMACRO_INPTBASE, "Bad macro value.");
		pPath->GetBaseNameString(strMacroValue);
	}

	return TRUE;
}

void CProjectEvaluator::GetDebuggerProperty(IVCPropertyContainer* pPropContainer, long idProp, CStringW& strMacroValue)
{
	strMacroValue.Empty();

	CComQIPtr<IVCPropertyContainer> spPropContainerDbg;
	CComQIPtr<VCDebugSettings> spDebugSetting;

	CComPtr<IVCPropertyContainer> spActualContainer;
	CVCProjectEngine::ResolvePropertyContainer(pPropContainer, &spActualContainer);
	CComQIPtr<VCConfiguration> spProjCfg = spActualContainer;
	if (spProjCfg == NULL)
	{
		CComQIPtr<IVCFileConfigurationImpl> spFileCfgImpl = spActualContainer;
		if (spFileCfgImpl == NULL)
		{
			CComQIPtr<VCDebugSettings> spDebugSetting = spActualContainer;
			if (spDebugSetting == NULL)
				return;
			spPropContainerDbg = spActualContainer;
		}
		else
		{
			CComPtr<IDispatch> spDispProjCfg;
			spFileCfgImpl->get_Configuration(&spDispProjCfg);
			spProjCfg = spDispProjCfg;
			if (spProjCfg == NULL)
				return;
		}
	}

	if( spPropContainerDbg == NULL )
	{
		CComPtr<IDispatch> spDispDebugSettings;
		spProjCfg->get_DebugSettings(&spDispDebugSettings);
		spPropContainerDbg = spDispDebugSettings;
	}

	if (spPropContainerDbg == NULL)
		return;

	CComPtr<IVCStagedPropertyContainer> spStagedContainer;
	spPropContainerDbg->GetStagedPropertyContainer(VARIANT_FALSE, &spStagedContainer);
	CComQIPtr<IVCPropertyContainer> spActualDbgContainer;
	if (spStagedContainer)
		spActualDbgContainer = spStagedContainer;
	if (spActualDbgContainer == NULL)
		spActualDbgContainer = spPropContainerDbg;

	CComBSTR bstrTemp;
	HRESULT hr = spActualDbgContainer->GetEvaluatedStrProperty(idProp, &bstrTemp);
	if (SUCCEEDED(hr))
		strMacroValue = bstrTemp;
}

static LONG GetRegEntry(HKEY hSectionKey, LPCOLESTR szValue, CStringW& strBuf)
{
	wchar_t* szBuf = strBuf.GetBuffer(MAX_PATH+1);
	DWORD nType = REG_SZ;
	DWORD nSize = MAX_PATH;
	LONG lRet = RegQueryValueExW( hSectionKey, szValue, NULL, &nType, (LPBYTE)szBuf, &nSize );
	strBuf.ReleaseBuffer(-1);
	return lRet;
}

typedef HRESULT (STDAPICALLTYPE * LPFNGETRUNTIMEVER)(LPWSTR,DWORD,DWORD *);

void CProjectEvaluator::EvalFrameworkMacro(UINT idMacro, CStringW& strMacroValue)
{
	if (!s_bComDirsInit)
	{
		s_bComDirsInit = true;
		CStringW strKey = L"SOFTWARE\\Microsoft\\.NETFramework";
		HKEY hSectionKey = NULL;
		LONG lRet = RegOpenKeyExW( HKEY_LOCAL_MACHINE, strKey, 0, KEY_READ, &hSectionKey );
		if( hSectionKey )
		{
			lRet = GetRegEntry(hSectionKey, L"InstallRoot", s_strComDir);
			lRet = GetRegEntry(hSectionKey, L"sdkInstallRoot", s_strComSDKDir);

			if (s_strComDir.IsEmpty())
			{}	// nothing we can do
			else if (s_strComDir[s_strComDir.GetLength()-1] == L'/')
				s_strComDir = s_strComDir.Left(s_strComDir.GetLength()-1) + L"\\";
			else if (s_strComDir[s_strComDir.GetLength()-1] != L'\\')
				s_strComDir += L"\\";
			if (s_strComSDKDir.IsEmpty())
				s_strComSDKDir = s_strComDir + L"complus\\sdk\\";
			else if (s_strComSDKDir[s_strComSDKDir.GetLength()-1] == L'/')
				s_strComSDKDir = s_strComSDKDir.Left(s_strComSDKDir.GetLength()-1) + L"\\";
			else if (s_strComSDKDir[s_strComSDKDir.GetLength()-1] != L'\\')
				s_strComSDKDir += L"\\";
			RegCloseKey( hSectionKey );
		}

		// now need to run through some fancy footwork to get the version of COM+ the IDE is running
		wchar_t szRuntimeVer[MAX_PATH * 2];
		wchar_t szSys[MAX_PATH];

		szRuntimeVer[0] = L'\0';
		szSys[0] = L'\0';
		if (GetSystemDirectoryW(szSys, MAX_PATH))
		{
			size_t iLen = wcslen(szSys);
			if (iLen > 0 && szSys[iLen - 1] != L'\\')
			wcscat(szSys, L"\\");
			wcscat(szSys, L"mscoree.dll");
			HMODULE hModEE = LoadLibraryExW(szSys, NULL, 0);
			if (hModEE)
			{
				LPFNGETRUNTIMEVER pfnGetRuntimeVer = (LPFNGETRUNTIMEVER)GetProcAddress(hModEE, "GetCORSystemDirectory");
				if (pfnGetRuntimeVer)
				{
					HRESULT hrT = E_FAIL;
					WCHAR wszCORSysDir[MAX_PATH];
					wszCORSysDir[0] = L'\0';
					DWORD dwChars;
					hrT = (pfnGetRuntimeVer)(wszCORSysDir, MAX_PATH, &dwChars);
					if (SUCCEEDED(hrT) && wszCORSysDir[0])
					{
						WCHAR *pszBackslash = wcsrchr(wszCORSysDir, L'\\');
						if (pszBackslash)
						{
							if (pszBackslash[1] == L'\0' && pszBackslash != wszCORSysDir) //trailing backslash, go back one more
							{
								*pszBackslash = L'\0';
								pszBackslash = wcsrchr(wszCORSysDir, L'\\');  
							}

							WCHAR *pszVerString = pszBackslash ? pszBackslash + 1 : NULL;
							s_strComVer = pszVerString;
						}
					}
				}
				// FreeLibrary(hModEE);	// no need to free this -- we want it around until the IDE shuts down...
			}
		}
	}

	switch (idMacro)
	{
		case IDMACRO_COMDIR:
			strMacroValue = s_strComDir;
			break;
		case IDMACRO_COMSDKDIR:
			strMacroValue = s_strComSDKDir;
			break;
		case IDMACRO_COMVER:
			strMacroValue = s_strComVer;
			break;
		default:
			VSASSERT(FALSE, "Hey, unknown location macro!");
			strMacroValue.Empty();
			break;
	}
}

void CProjectEvaluator::GetBuildEngine(IVCPropertyContainer* pPropContainer, CComPtr<IVCBuildEngine>& spBuildEngine)
{
	if (spBuildEngine != NULL)
		return;	// already handled

	CComPtr<IVCPropertyContainer> spActualContainer;
	CVCProjectEngine::ResolvePropertyContainer(pPropContainer, &spActualContainer);
	CComQIPtr<IVCBuildableItem> spBldableItem = spActualContainer;
	if (spBldableItem == NULL)
		return;

	spBldableItem->get_ExistingBuildEngine(&spBuildEngine);
}

#define CCH_ALLOC_EXPAND	2048
class CCounter
{
public:
	int *m_pn;
	long *m_pID;
	CCounter( int *pn, long* pID ){ m_pn = pn; (*m_pn) = (*m_pn)+1; m_pID = pID; }
	~CCounter(){ (*m_pn) = (*m_pn)-1; if ((*m_pn) == 0) (*m_pID) = 0; }
	void SetMacroID(long id) { if ((*m_pn) == 1) (*m_pID) = id; }
};
    	

HRESULT CProjectEvaluator::ExpandMacros(BSTR* pbstrOut, BSTR bstrIn, IVCPropertyContainer* pPropContainer, BOOL bNoEnvVars, 
	long idProp /* = 0 */)
{
    	// First Check expansion depth
	if( m_nDepth > 32 )
	{
		CComQIPtr<IVCBuildEngine> spBuildEngine;
		GetBuildEngine(pPropContainer, spBuildEngine);
		CComQIPtr<IVCBuildEngineImpl> spBuildEngineImpl = spBuildEngine;
		if (spBuildEngineImpl)
		{
			CComPtr<IVCBuildErrorContext> spEC;
			spBuildEngineImpl->get_ErrorContext(&spEC);
			if (spEC)
			{
				CStringW strErr, strMacroName;
				if (m_nLastMacroID)
					MapMacroIdToName(m_nLastMacroID, strMacroName);
				strErr.Format(IDS_ERR_MACRO_EXPANSION_PRJ0030, strMacroName);
				CVCProjectEngine::AddProjectError(spEC, strErr, L"PRJ0030", pPropContainer);
			}
		}
		return E_FAIL;
	}

	CCounter cnt(&m_nDepth, &m_nLastMacroID);
    
	// just test the usage
	BOOL fJustTestUsage = pbstrOut == NULL;

	if (bstrIn == NULL)
	{
		if (pbstrOut != NULL)
		{
			CComBSTR bstrBlank = L"";
			*pbstrOut = bstrBlank.Detach();
		}
		return S_OK;
	}

	const wchar_t * pchSpec = bstrIn;
	int cchOut = 0;
	int cchAlloc = 0;

	wchar_t pchOutBuffer[2048];
	wchar_t *pchOut = NULL;
	wchar_t *pszAllocatedPtr = NULL;

	if (!fJustTestUsage)
	{
		cchAlloc = cchOut = CCH_ALLOC_EXPAND;
		pchOut = pchOutBuffer;
		*pchOut = L'\0';
		cchOut -= sizeof(wchar_t);
	}


	CStringW strMacroValue;
	// copy everything verbatim unless we come across a macro
	while (*pchSpec != L'\0')
	{
		// macro?
		const wchar_t * pch = pchSpec;
		while (!(*pch == L'$' && *(pch + 1) == L'(') && *pch != L'\0')
			pch++;

		int cchReq = 0; 
		const wchar_t * pchBlk = (const wchar_t *)NULL;

		// do block append?
		if (pch != pchSpec)
		{
			// yes
			cchReq = (int)(pch - pchSpec);

			// get block start
			pchBlk = pchSpec;

			// advance
			pchSpec = pch;
		}
		else
		{

			UINT idMacro; int cchMacro;

			// macro-name exact match?
			// skip '$('
			pch += 2;

			if (MapMacroNameToId(pch, cchMacro, idMacro) &&
				*(pch + cchMacro) == L')')
			{
				cnt.SetMacroID(idMacro);
				// advance and skip macro
				pchSpec = pch + cchMacro;

				// skip trailing ')'
				pchSpec++;

				// verify that we're not trying to recurse into a property to evaluate itself...
				HRESULT hr = ValidateMacro(idMacro, idProp);
				RETURN_ON_FAIL(hr);

				// get the macro value
				if ( (!fJustTestUsage) && GetMacroValue(idMacro, strMacroValue, pPropContainer))
				{
					// get the char. block
					cchReq = strMacroValue.GetLength();
					pchBlk = (const wchar_t *)strMacroValue;
				}
			}
			else if( !bNoEnvVars )
			{
				CStringW strMacroBuf;
				wchar_t* pchMacro;
				const wchar_t *pchStart;

				// save the start
				pchStart = pch;

				// Find last char of Macro
				while (!(*pch == L')') && *pch != L'\0' )
					pch++;

				if( *pch == L'\0' ){
					// stand alone "$(" with no trailing ")"
					strMacroValue = "$(";
					pchBlk = (const wchar_t *)strMacroValue;
					cchReq = strMacroValue.GetLength();
					pchSpec = pchStart;
				} else {

					cchMacro = (int)(pch - pchStart);
					pchMacro = strMacroBuf.GetBuffer(cchMacro+1);

					wcsncpy( pchMacro, pchStart, cchMacro );
					pchMacro[cchMacro] = L'\0';
	
					int nSuccess = GetEnvironmentVariableW( pchMacro, strMacroValue.GetBuffer(2048), 2047 );
					if( nSuccess > 2047 )
					{
						GetEnvironmentVariableW( pchMacro, strMacroValue.GetBuffer(nSuccess+1), nSuccess );
					}
					strMacroValue.ReleaseBuffer();
					strMacroBuf.ReleaseBuffer();
					
					if (nSuccess)
					{
						pchBlk = (const wchar_t *)strMacroValue;
						cchReq = strMacroValue.GetLength();
					}
					else {
						CComQIPtr<IVCBuildEngine> spBuildEngine;
						GetBuildEngine(pPropContainer, spBuildEngine);
						if (spBuildEngine)
						{
							CStringW strCmd;
							strCmd.Format(IDS_WRN_ENVVAR, strMacroBuf);		
							CComBSTR bstrCmd = strCmd;
							spBuildEngine->LogTrace(eLogCommand, bstrCmd);
							CComBSTR bstrMacro = strMacroBuf;
							spBuildEngine->AddMissingEnvironmentVariable(bstrMacro);
						}
						strMacroValue.Empty();
					}
	
					if( *pch == L')' )
						pch++;

					// advance and skip macro
					pchSpec = pch;
				}
			}
			else {
				strMacroValue = L"$(";
				pchBlk = (const wchar_t *)strMacroValue;
				cchReq = strMacroValue.GetLength();
				pchSpec = pch;
			}
		} 

		// not just testing usage and chars. req'd and char blk to copy?
		if (!fJustTestUsage && cchReq && pchBlk)
		{
			if (cchReq > cchOut)
			{
				int cchIncAlloc = max(CCH_ALLOC_EXPAND, cchReq);

				cchAlloc += cchIncAlloc;
				cchOut += cchIncAlloc;

				wchar_t *pchToDelete = pszAllocatedPtr;
				pszAllocatedPtr = (wchar_t *)malloc( cchAlloc * sizeof(wchar_t));
				if( pszAllocatedPtr )
				{
					wcscpy(pszAllocatedPtr, pchOut);
				}
				pchOut = pszAllocatedPtr;
				if( pchToDelete )
					free(pchToDelete);
			}
						
			// copy block
			wcsncat(pchOut, pchBlk, cchReq);
			cchOut -= cchReq;
		}
	}

	// copy into BSTR
	if (!fJustTestUsage)
	{
		CComBSTR bstrOut = pchOut;
		*pbstrOut = bstrOut.Detach();

		// free up our local buffer
		if(pszAllocatedPtr)
			free(pszAllocatedPtr);
	}

	return S_OK;
}

HRESULT CProjectEvaluator::ValidateMacro(UINT idMacro, long idProp)
{
	if (idProp == 0)
		return S_OK;

	switch (idMacro)
	{
	case IDMACRO_INTDIR:
		if (idProp == VCCFGID_IntermediateDirectory)
		{
			VSASSERT(FALSE, "Trying to use $(IntDir) to resolve IntermediateDirectory!");
			return CVCProjectEngine::DoSetErrorInfo(E_INVALIDARG, IDS_ERR_RECURSE_INTDIR);	// recursion!
		}
		break;
	case IDMACRO_OUTDIR:
		if (idProp == VCCFGID_OutputDirectory)
		{
			VSASSERT(FALSE, "Trying to use $(OutDir) to resolve OutputDirectory!");
			return CVCProjectEngine::DoSetErrorInfo(E_INVALIDARG, IDS_ERR_RECURSE_OUTDIR);	// recursion!
		}
		break;
	case IDMACRO_TARGDIR:
	case IDMACRO_TARGFILE:
	case IDMACRO_TARGBASE:
		if (idProp == VCCFGID_PrimaryOutput)
		{
			VSASSERT(FALSE, "Trying to use a target macro to resolve PrimaryOutput!");
			return CVCProjectEngine::DoSetErrorInfo(E_INVALIDARG, IDS_ERR_RECURSE_TARG);	// recursion!
		}
		break;
	case IDMACRO_INPTDIR:
	case IDMACRO_INPTFILE:
	case IDMACRO_INPTBASE:
	case IDMACRO_INPTEXT:
		{
			switch (idProp)
			{
			case VCFILEID_Name:
			case VCFILEID_FullPath:
			case VCFILEID_RelativePath:
				VSASSERT(FALSE, "Trying to use an input macro to resolve something about a file!");
				return CVCProjectEngine::DoSetErrorInfo(E_INVALIDARG, IDS_ERR_RECURSE_INPUT);	// recursion!
				break;
			// default is everything is OK
			}
		}
		break;
	case IDMACRO_CFGNAME:
		if (idProp == VCFCFGID_Name)
		{
			VSASSERT(FALSE, "Trying to use the config name to resolve itself!");
				return CVCProjectEngine::DoSetErrorInfo(E_INVALIDARG, IDS_ERR_RECURSE_CFG);	// recursion!
		}
		break;
	case IDMACRO_PROJDIR:
	case IDMACRO_PROJFILE:
	case IDMACRO_PROJBASE:
	case IDMACRO_PROJEXT:
	case IDMACRO_PROJPATH:
		{
			switch(idProp)
			{
			case VCPROJID_Name:
			case VCPROJID_ProjectFile:
			case VCPROJID_ProjectDirectory:
				VSASSERT(FALSE, "Trying to use a project macro to resolve something about a project!");
				return CVCProjectEngine::DoSetErrorInfo(E_INVALIDARG, IDS_ERR_RECURSE_PROJ);	// recursion!
				break;
			// default is everything is OK
			}
		}
	case IDMACRO_REMOTEMACH:
		if (idProp == VCDSID_RemoteMachine)
		{
			VSASSERT(FALSE, "Trying to use the remote machine name to resolve itself!");
			return CVCProjectEngine::DoSetErrorInfo(E_INVALIDARG, IDS_ERR_RECURSE_REMOTE);	// recursion!
		}
		break;
	case IDMACRO_PLATNAME:
		if (idProp == VCPLATID_Name)
		{
			VSASSERT(FALSE, "Trying to use platform name to resolve itself!");
			return CVCProjectEngine::DoSetErrorInfo(E_INVALIDARG, IDS_ERR_RECURSE_PLATFORM);	// recursion!
		}
	// default is everything is OK
	}

	return S_OK;
}

BOOL CProjectEvaluator::NoInheritOnMultiProp(BSTR bstrVal, LPCOLESTR szSeparator, BSTR* pbstrValue)
{
	CStringW strVal = bstrVal;
	if (strVal.IsEmpty())
		return FALSE;

	// NoInherit takes precedence over Inherit
	int nFindElem = strVal.Find(L"$(");
	int nMaxLen = strVal.GetLength();
	const wchar_t* szVal = strVal;
	bool bNoInherit = false;
	while (nFindElem >= 0 && !bNoInherit)
	{
		if (_wcsnicmp(szVal+nFindElem, L"$(NoInherit)", 12) == 0)	// don't inherit
		{
			bNoInherit = true;
			break;
		}
		nFindElem++;
		if (nFindElem >= nMaxLen)	// definitely not found
			break;
		nFindElem = strVal.Find(L"$(", nFindElem);
	}
	if (!bNoInherit)
		return FALSE;	// we're going to do inheritance

	// Now let's remove all the $(Inherit) and $(NoInherit) tags
	CStringW strSeparator = szSeparator;
	nFindElem = strVal.Find(L"$(");
	int nLastStart = 0;
	CStringW strTmp;
	bool bNeedSeparator = false;
	while (nFindElem >= 0 && nLastStart < nMaxLen)
	{
		int nReplaceLen = 0;
		if (_wcsnicmp(szVal+nFindElem, L"$(Inherit)", 10) == 0)
			nReplaceLen = 10;
		else if (_wcsnicmp(szVal+nFindElem, L"$(NoInherit)", 12) == 0)
			nReplaceLen = 12;

		if (nReplaceLen > 0)
		{
			if (nLastStart == 0)
			{
				if (nFindElem > 0)
				{
					strTmp = strVal.Left(nFindElem-1);
					bNeedSeparator = true;
				}
			}
			else
			{
				if (bNeedSeparator && !strSeparator.IsEmpty())
					strTmp += strSeparator.GetAt(0);
				bNeedSeparator = true;
				if (nFindElem+nReplaceLen+1 == nMaxLen)
					strTmp += strVal.Right(nMaxLen-nFindElem-nReplaceLen);
				else
					// if another macro follows immediately, append nothing
					if( nLastStart != nFindElem )
						strTmp += strVal.Mid(nLastStart, nFindElem-1-nLastStart);	// pull out the separator, too
			}
			nLastStart = nFindElem + nReplaceLen + 1;
		}
		nFindElem++;
		if (nFindElem >= nMaxLen)	// definitely no more found
			break;
		nFindElem = strVal.Find(L"$(", nFindElem);
	}
	if (nLastStart < nMaxLen)
	{
		if (!strSeparator.IsEmpty())
			strTmp += strSeparator.GetAt(0);
		strTmp += strVal.Right(nMaxLen-nLastStart);
	}

	CComBSTR bstrValue = strTmp;
	*pbstrValue = bstrValue.Detach();
	return TRUE;
}

HRESULT CProjectEvaluator::MakeMultiPropString(CComBSTR& bstrLocal, CComBSTR& bstrParent, LPCOLESTR szSeparator, BSTR* pbstrValue)
{
	CStringW strParent = bstrParent;
	bool bDidInsertAtLeastOnce = false;
	CStringW strLocal = bstrLocal;
	int nFindElem = strLocal.Find(L"$(");
	int nMaxLen = strLocal.GetLength();
	const wchar_t* szLocal = strLocal;
	CStringW strFull;
	CStringW strSeparator = szSeparator;
	// See if we have a non-default location for Inherit
	int nLastStart = 0;
	int nReplaceLen = 10;
	bool bNeedSeparator1 = !strParent.IsEmpty();
	bool bNeedSeparator2 = false;
	while (nFindElem >= 0 && nLastStart < nMaxLen)
	{
		if (_wcsnicmp(szLocal+nFindElem, L"$(Inherit)", 10) == 0)
		{
			if (nLastStart == 0)
			{
				if (nFindElem > 0)
					strFull = strLocal.Left(nFindElem-1);
			}
			else
			{
				if (bNeedSeparator1 && !strSeparator.IsEmpty())
					strFull += strSeparator.GetAt(0);
				if (nFindElem+nReplaceLen+1 == nMaxLen)
					strFull += strLocal.Right(nMaxLen-nFindElem-nReplaceLen);
				else
					strFull += strLocal.Mid(nLastStart, nFindElem-1-nLastStart);	// pull out the separator, too
			}
			nLastStart = nFindElem + nReplaceLen + 1;
			if (bNeedSeparator2 && !strSeparator.IsEmpty())
				strFull +=  strSeparator.GetAt(0);
			bNeedSeparator2 = true;
			strFull += strParent;
		}
		nFindElem++;
		if (nFindElem >= nMaxLen)	// definitely not found
			break;
		nFindElem = strLocal.Find(L"$(", nFindElem);
	}

	if (strFull.IsEmpty())
	{
		strFull = strLocal;
		if (bNeedSeparator1 && !strSeparator.IsEmpty())
			strFull +=  strSeparator.GetAt(0);
		strFull += strParent;
	}
	else if (nLastStart < nMaxLen)
	{
		if (!strSeparator.IsEmpty())
			strFull += strSeparator.GetAt(0);
		strFull += strLocal.Right(nMaxLen-nLastStart);
	}
	CComBSTR bstrFull = strFull;
	*pbstrValue = bstrFull.Detach();

	return S_OK;
}

HRESULT CProjectEvaluator::CollapseMultiples(BSTR bstrIn, LPCOLESTR szSeparator, VARIANT_BOOL bCaseSensitive, BSTR* pbstrOut)
{
	CHECK_POINTER_NULL(pbstrOut);
	CStringW strIn = bstrIn;
	CStringW strOut, strOutNoCase;
	CStringW strItem, strItemNoCase;
	CStringW strSeparator = szSeparator;
	bool bFirstElem = true;

	int nNextIdx = 0;
	int nMaxIdx = strIn.GetLength();
	int nFoundIdx = 0;
	while (nNextIdx >= 0)
	{
		nNextIdx = g_StaticBuildEngine.GetNextItem(strIn, nNextIdx, nMaxIdx, strSeparator, strItem);
		if (!bCaseSensitive)
		{
			strItemNoCase = strItem;
			strItemNoCase.MakeLower();
			nFoundIdx = DoFindItem(strOutNoCase, strItemNoCase, strSeparator, 0);
		}
		else
			nFoundIdx = DoFindItem(strOut, strItem, strSeparator, 0);
		if (nFoundIdx >= 0)		// already there
			continue;
		if (!bFirstElem)
		{
			if (!strSeparator.IsEmpty())
			{
				strOut += strSeparator.GetAt(0);
				if (!bCaseSensitive)
					strOutNoCase += strSeparator.GetAt(0);
			}
		}
		else
			bFirstElem = false;
		strOut += strItem;
		if (!bCaseSensitive)
			strOutNoCase += strItemNoCase;
	}

	if (strOut.IsEmpty())
	{
		CComBSTR bstrBlank = L"";
		*pbstrOut = bstrBlank.Detach();
	}
	else
		*pbstrOut = strOut.AllocSysString();

	return S_OK;
}

int CProjectEvaluator::DoFindItem(CStringW& rstrItems, CStringW& rstrFindItem, CStringW& strSeparator, int nStart)
{
	if (rstrFindItem.IsEmpty())
		return -1;	// never find a NULL item

	nStart = rstrItems.Find(rstrFindItem, nStart);
	if (nStart < 0)
		return nStart;

	int nItemLen = rstrItems.GetLength();
	int nLen = rstrFindItem.GetLength();

	if (nStart > 0 && nStart + nLen <= nItemLen && strSeparator.Find(rstrItems[nStart-1]) < 0)
	{
		if (nStart + nLen == nItemLen)
			return -1;	// partial match to the end of the string
		else
			return DoFindItem(rstrItems, rstrFindItem, strSeparator, nStart+nLen);
	}
	else if (nItemLen > nStart + nLen && strSeparator.Find(rstrItems[nStart+nLen]) < 0)
		return DoFindItem(rstrItems, rstrFindItem, strSeparator, nStart+nLen);

	return nStart;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\vcpb\ProjWriter.cpp ===
// ProjWriter.cpp

#include "stdafx.h"

const WCHAR XML_ENTITY_QUOTE[] = L"&quot;";
const WCHAR XML_ENTITY_APOSTROPHE[] = L"&apos;";
const WCHAR XML_ENTITY_LESSTHAN[] = L"&lt;";
const WCHAR XML_ENTITY_GREATERTHAN[] = L"&gt;";
const WCHAR XML_ENTITY_AMPERSAND[] = L"&amp;";


// XML writer routines
static int indent = 0;

static inline int StrByteLen( WCHAR *str )
{
	return (int)(wcslen( str ) * sizeof(WCHAR));
}

static void Indent( IStream *xml, int n )
{
	ULONG cbWritten;
	// if there's nothing to do, bail
	if( !n ) 
		return;
	// allocate string on stack
	WCHAR* strIndent = (WCHAR*)_alloca( (n+1) * sizeof(WCHAR) );

	// fill it with tabs
	if( strIndent )
	{
		for( int i = 0; i <= n; i++ )
			strIndent[i] = L'\t';
		strIndent[n] = 0;
	}
	else
		strIndent = L"";
	xml->Write( (void*)strIndent, n * sizeof(WCHAR), &cbWritten );
	return;
}

int GetIndent() { return indent; }
void SetIndent(int nNewIndent) { indent = nNewIndent; }

void StartNodeHeader( IStream *xml, WCHAR* wszName, bool bHasChildren )
{
	ULONG cbWritten;

	// indent one level
	Indent( xml, indent++ );

	xml->Write( (void*)L"<", sizeof(WCHAR), &cbWritten );
	xml->Write( (void*)wszName, StrByteLen( wszName ), &cbWritten );
}

void NodeAttribute( IStream *xml, WCHAR* wszName, WCHAR* wszValue )
{
	ULONG cbWritten;
	
	// if we were handed a null for value, fail gracefully
	if( !wszValue )
		return;
		
	xml->Write( (void*)L"\r\n", StrByteLen( L"\r\n" ), &cbWritten );
	// indent to the current level 
	Indent( xml, indent );
	xml->Write( (void*)wszName, StrByteLen( wszName ), &cbWritten );
	xml->Write( (void*)L"=\"", StrByteLen( L"=\"" ), &cbWritten );
	xml->Write( (void*)wszValue, StrByteLen( wszValue ), &cbWritten );
	xml->Write( (void*)L"\"", StrByteLen( L"\"" ), &cbWritten );
}

void NodeAttributeWithSpecialChars( IStream *xml, WCHAR* wszName, WCHAR* wszValue, bool bFilenameChars )
{
	ULONG cbWritten;
	
	// if we were handed a null for value, fail gracefully
	if( !wszValue )
		return;
		
	// replace all the special chars with their XML entity equivalents
	CStringW strValue = wszValue;
	// all special chars
	if( !bFilenameChars )
	{
		strValue.Replace( L"&", XML_ENTITY_AMPERSAND );
		strValue.Replace( L"\"", XML_ENTITY_QUOTE );
		strValue.Replace( L"'", XML_ENTITY_APOSTROPHE );
		strValue.Replace( L"<", XML_ENTITY_LESSTHAN );
		strValue.Replace( L">", XML_ENTITY_GREATERTHAN );
	}
	// filenames can only have & and '
	else
	{
		strValue.Replace( L"&", XML_ENTITY_AMPERSAND );
		strValue.Replace( L"'", XML_ENTITY_APOSTROPHE );
	}

	
	xml->Write( (void*)L"\r\n", StrByteLen( L"\r\n" ), &cbWritten );
	// indent to the current level 
	Indent( xml, indent );
	xml->Write( (void*)wszName, StrByteLen( wszName ), &cbWritten );
	xml->Write( (void*)L"=\"", StrByteLen( L"=\"" ), &cbWritten );
	xml->Write( (void*)strValue.GetBuffer( 0 ), StrByteLen( strValue.GetBuffer( 0 ) ), &cbWritten );
	xml->Write( (void*)L"\"", StrByteLen( L"\"" ), &cbWritten );
}

void EndNodeHeader( IStream *xml, bool bHasChildren )
{
	ULONG cbWritten;

	if( bHasChildren )
	{
		xml->Write( (void*)L">\r\n", StrByteLen( L">\r\n" ), &cbWritten );
	}
	else
	{
		xml->Write( (void*)L"/>\r\n", StrByteLen( L"/>\r\n" ), &cbWritten );
	}
}

void EndNode( IStream *xml, WCHAR* wszName, bool bHasChildren )
{
	ULONG cbWritten;

	// there's only an end node tag if there were children...
	if( bHasChildren )
	{
		// indent to the current level and reduce the level for following nodes
		Indent( xml, --indent );

		xml->Write( (void*)L"</", StrByteLen( L"</" ), &cbWritten );
		xml->Write( (void*)wszName, StrByteLen( wszName ), &cbWritten );
		xml->Write( (void*)L">\r\n", StrByteLen( L">\r\n" ), &cbWritten );
	}
	else
	{
		indent--;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\vcpb\ProjWriter.h ===
// ProjWriter.h

#ifndef _PROJWRITER_H_
#define _PROJWRITER_H_

// append a string that has quotation marks in it to another string
void WriteString( BSTR *bstrScript, BSTR bstrQuotedStr );
// append a string that has quotation marks in it to another string, with
// surrounding quotation marks
void WriteQuotedString( BSTR *bstrScript, BSTR bstrQuotedStr );
// append a string that contains multiple lines (and quotes) to another string, with
// surrounding quotation marks
void WriteMultiLineString( BSTR *bstrScript, BSTR bstrMultiLineStr );

// XML writer routines
int GetIndent();
void SetIndent(int nNewIndent);
void StartNodeHeader( IStream *xml, WCHAR* bstrName, bool bHasChildren );
void NodeAttribute( IStream *xml, WCHAR* bstrName, BSTR bstrValue );
void NodeAttributeWithSpecialChars( IStream *xml, WCHAR* bstrName, BSTR bstrValue, bool bFilenameChars = false );
void EndNodeHeader( IStream *xml, bool bHasChildren );
void EndNode( IStream *xml, WCHAR* bstrName, bool bHasChildren );

#endif // end include fence
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\vcpb\propcontainer.h ===
#pragma once

// basic property container class; must be derived from, not used directly

#include <vccoll.h>
#include <vcmap.h>
#include "comlist.h"
#include "ProjEvaluator.h"

class CPropertyContainerImpl : 
	public IVCPropertyContainer,
	public CProjectEvaluator
{
public:
	CPropertyContainerImpl() {}
	virtual HRESULT SetDirty(VARIANT_BOOL bDirty) { return E_NOTIMPL; }

// IVCPropertyContainer
public:
	STDMETHOD(HasLocalStorage)(VARIANT_BOOL bForSave, VARIANT_BOOL* pbHasLocalStorage);
	STDMETHOD(GetProp)(long id, /*[in]*/ VARIANT *varValue);
	STDMETHOD(SetProp)(long id, VARIANT varValue);
	STDMETHOD(GetLocalProp)(long id, /*[out]*/ VARIANT *pvarValue);
	STDMETHOD(GetParentProp)(long id, VARIANT_BOOL bAllowInherit,  VARIANT *pvarValue);
	STDMETHOD(GetMultiProp)(long id, LPCOLESTR szSeparator, VARIANT_BOOL bSkipLocal, BSTR *varValue);
	STDMETHOD(IsMultiProp)(long idProp, VARIANT_BOOL* pbIsMulti);
	STDMETHOD(GetMultiPropSeparator)(long id, BSTR* pbstrPreferred, BSTR* pbstrAll);
	STDMETHOD(GetStrProperty)(long idProp, BSTR* pbstrValue);
	STDMETHOD(SetStrProperty)(long idProp, BSTR bstrValue);
	STDMETHOD(GetIntProperty)(long idProp, long* pnValue);
	STDMETHOD(SetIntProperty)(long idProp, long nValue);
	STDMETHOD(GetBoolProperty)(long idProp, VARIANT_BOOL* pbValue);
	STDMETHOD(SetBoolProperty)(long idProp, VARIANT_BOOL bValue);
	STDMETHOD(DirtyProp)(long id) { return S_FALSE; }
	STDMETHOD(Clear)(long id);
	STDMETHOD(ClearAll)();
	STDMETHOD(Evaluate)(BSTR bstrIn, BSTR *bstrOut);
	STDMETHOD(EvaluateWithValidation)(BSTR bstrSource, long idProp, BSTR* pbstrExpanded);
	STDMETHOD(GetEvaluatedStrProperty)(long idProp, BSTR* pbstrOut);
	STDMETHOD(GetEvaluatedMultiProp)(long idProp, LPCOLESTR szSeparator, VARIANT_BOOL bCollapseMultiples, 
		VARIANT_BOOL bCaseSensitive, BSTR* pbstrOut);
	STDMETHOD(Commit)(){ return E_NOTIMPL; }
	STDMETHOD(GetStagedPropertyContainer)(VARIANT_BOOL bCreateIfNecessary, IVCStagedPropertyContainer** ppPropContainer);
	STDMETHOD(ReleaseStagedPropertyContainer)();		// intended for use ONLY by the staged property container itself

// IVCPropertyContainer helpers
protected:
	virtual HRESULT DoGetProp(long id, BOOL bCheckSpecialProps, VARIANT *pVarValue);
	virtual HRESULT DoGetParentProp(long id, VARIANT_BOOL bAllowInherit, BOOL bCheckSpecialProps, VARIANT *pVarValue);
	virtual HRESULT DoSetProp(long id, BOOL bCheckSpecial, VARIANT varValue, long nOverrideID = -1);
	virtual HRESULT FinishSetPropOrClear(long id, long nOverrideID);
	virtual HRESULT DoGetLocalProp(long id, BOOL bCheckSpecial, VARIANT *pvarValue);
	virtual HRESULT DoGetStrProperty(long idProp, BOOL bSpecialPropsOnly, BSTR* pbstrValue);
	virtual HRESULT DoSetStrProperty(long id, BOOL bCheckSpecialProps, BSTR bstrValue, long nOverrideID = -1);
	virtual HRESULT DoGetIntProperty(long idProp, BOOL bCheckSpecial, long* pnValue);
	virtual HRESULT GetParentIntProperty(long idProp, long* pnValue);
	virtual HRESULT GetLocalIntProperty(long idProp, long* pnValue);
	virtual HRESULT DoSetIntProperty(long id, BOOL bCheckSpecialProps, long nValue, long nOverrideID = -1);
	virtual HRESULT DoGetBoolProperty(long idProp, BOOL bCheckSpecial, VARIANT_BOOL* pbValue);
	virtual HRESULT DoSetBoolProperty(long id, BOOL bCheckSpecialProps, VARIANT_BOOL bValue, long nOverrideID = -1);
	virtual HRESULT DoClear(long id, long nOverrideID = -1);
	virtual HRESULT DoClearAll();

	virtual HRESULT FinishClose();
	virtual long GetOverrideID(long idProp) { return -1; }
	virtual BOOL CheckCanDirty() { return TRUE; }
	HRESULT DoGetVCProjectEngine(IDispatch** projEngine);

public:
	//Methods to write properties to stream
	static HRESULT WritePropertyToStream(IStream *pStream, VARIANT_BOOL bProp, DISPID dispid);
	static HRESULT WritePropertyToStream(IStream *pStream, CComBSTR& bstrProp, DISPID dispid);
	static HRESULT WritePropertyToStream(IStream *pStream, long lProp, DISPID dispid);
	static HRESULT WritePropertyToStream(IStream *pStream, CComVariant& variantProp, DISPID dispid);

// ISpecifyPropertyPages
public:
    STDMETHOD(GetPages)(/* [out] */ CAUUID *pPages) { return E_NOTIMPL; }
//DATA
protected:
	CComDynamicListTyped<IVCPropertyContainer> m_rgParents;
 	CVCMap<long,long,CComVariant,VARIANT&> m_PropMap;
	CComPtr<IVCStagedPropertyContainer> m_spStagedContainer;
};

class CVCStagedPropertyContainer : 
	public IVCStagedPropertyContainer, 
	public CPropertyContainerImpl,
	public CComObjectRoot
{
public:
	CVCStagedPropertyContainer() : m_pos(NULL), m_cStaged(0) {}
	~CVCStagedPropertyContainer() {}

	static HRESULT CreateInstance(IVCPropertyContainer* pParentPropContainer, IVCStagedPropertyContainer **ppStagedPropertyContainer);
	HRESULT Initialize(IVCPropertyContainer* pParentPropContainer);

BEGIN_COM_MAP(CVCStagedPropertyContainer)
	COM_INTERFACE_ENTRY(IVCStagedPropertyContainer)
	COM_INTERFACE_ENTRY(IVCPropertyContainer)
END_COM_MAP()
DECLARE_NO_REGISTRY()

// IVCPropertyContainer overrides
public:
	STDMETHOD(GetMultiProp)(long id, LPCOLESTR szSeparator, VARIANT_BOOL bSkipLocal, BSTR *varValue);
	STDMETHOD(GetMultiPropSeparator)(long id, BSTR* pbstrPreferred, BSTR* pbstrAll);
	STDMETHOD(Commit)();

// CPropertyContainerImpl overrides
	HRESULT DoGetParentProp(long id, VARIANT_BOOL bAllowInherit, BOOL bCheckSpecialProps, VARIANT *pVarValue);

// IVCStagedPropertyContainer
public:
	STDMETHOD(get_Parent)(IVCPropertyContainer** ppParent);
	STDMETHOD(ClearPropertyRange)(long nMinID, long nMaxID);
	STDMETHOD(GetGrandParentProp)(long id, VARIANT* pvarValue);		// skip to parent of our non-staged parent
	STDMETHOD(Close)();
	STDMETHOD(CommitPropertyRange)(long nMinID, long nMaxID);
	STDMETHOD(Reset)(void);
	STDMETHOD(NextElement)(long* pKey, VARIANT* pVal);
	STDMETHOD(HoldStagedContainer)();			// number of calls to Hold/Release StagedContainer need to match
	STDMETHOD(ReleaseStagedContainer)();		// number of calls to Hold/Release StagedContainer need to match
	STDMETHOD(HasDefaultValue)(DISPID dispid, BOOL *pfDefault);

// helpers
protected:
	HRESULT DoCommitPropertyRange(long nMinID, long nMaxID, bool bIgnoreRange);
	virtual BOOL CheckCanDirty() { return FALSE; }

protected:
	CComPtr<IVCPropertyContainer> m_spParentPropContainer;

	VCPOSITION m_pos;
	int m_cStaged;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\vcpb\rctool.h ===
// VCResourceCompilerTool.h: Definition of the CVCResourceCompilerTool class
//
//////////////////////////////////////////////////////////////////////

#pragma once

#include "vctool.h"
#include "RCToolBase.h"

enum ResTokens 
{
	TOKEN_EOF,
	TOKEN_NEWLINE,
	TOKEN_HASHSIGN,
	TOKEN_WORD,
	TOKEN_INCLUDE,
	TOKEN_BITMAP,
	TOKEN_CURSOR,
	TOKEN_ICON,
	TOKEN_TYPELIB,
	TOKEN_LOADONCALL,
	TOKEN_PRELOAD,
	TOKEN_FIXED,
	TOKEN_MOVEABLE,
	TOKEN_DISCARDABLE,
	TOKEN_FONT,
	TOKEN_RCINCLUDE,
	TOKEN_COMMENT,
	TOKEN_PURE,
	TOKEN_IMPURE,
	TOKEN_STOP_SCAN,
	TOKEN_START_SCAN,
	TOKEN_ACCELERATORS,
	TOKEN_DIALOG,
	TOKEN_DLGINIT,
	TOKEN_MENU,
	TOKEN_RCDATA,
	TOKEN_STRINGTABLE,
	TOKEN_BEGIN,
	TOKEN_END,
	TOKEN_VERSIONINFO,
	TOKEN_ERROR, 
	TOKEN_UNDEF, 
	TOKEN_DEFINE,
	TOKEN_LANGUAGE,
	TOKEN_GUIDELINES,
	TOKEN_TOOLBAR,
	TOKEN_DIALOGEX,
	TOKEN_MENUEX
};

// classes in this header
class CVCResourceCompilerTool;
class CResourceCompilerToolOptionHandler;

class CResourceCompilerToolOptionHandler : public COptionHandlerBase
{
public:
	DECLARE_OPTION_TABLE();

public:
	// default value handlers
	// string props
	virtual void GetDefaultValue( long id, BSTR *pVal, IVCPropertyContainer *pPropCnt = NULL );
	// integer props
	virtual void GetDefaultValue( long id, long *pVal, IVCPropertyContainer *pPropCnt = NULL );
	// boolean props
	virtual void GetDefaultValue( long id, VARIANT_BOOL *pVal, IVCPropertyContainer *pPropCnt = NULL );

protected:
	virtual BOOL SynthesizeOptionIfNeeded(IVCPropertyContainer* pPropContainer, long idOption);
	virtual BOOL SynthesizeOption(IVCPropertyContainer* pPropContainer, long idOption, CComVariant& rvar);
};

/////////////////////////////////////////////////////////////////////////////
// CVCResourceCompilerTool

class ATL_NO_VTABLE CVCResourceCompilerTool : 
	public IDispatchImpl<VCResourceCompilerTool, &IID_VCResourceCompilerTool, &LIBID_VCProjectEngineLibrary, PublicProjBuildTypeLibNumber,0, CVsTypeInfoHolder>, 
	public CComObjectRoot,
	public CVCToolImpl
{
public:
	CVCResourceCompilerTool() 
	{
		m_nLowKey = VCRCTOOL_MIN_DISPID;
		m_nHighKey = VCRCTOOL_MAX_DISPID;
		m_nDirtyKey = VCRCID_CmdLineOptionsDirty;
		m_nDirtyOutputsKey = VCRCID_OutputsDirty;
	}
	static HRESULT CreateInstance(IVCPropertyContainer* pPropContainer, IVCToolImpl** ppTool);

BEGIN_COM_MAP(CVCResourceCompilerTool)
 	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IVCToolImpl)
	COM_INTERFACE_ENTRY(VCResourceCompilerTool)
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE(CVCResourceCompilerTool) 

// VCResourceCompilerTool -- switches are not case sensitive
public:
	STDMETHOD(get_ToolName)(BSTR* pbstrToolName);	// friendly name of tool, e.g., "Resource Compiler Tool"
	STDMETHOD(get_AdditionalOptions)(BSTR* pbstrAdditionalOptions);	// anything we don't know what to do with, given verbatim, in same order as entered, parent contributions first, goes after all other options
	STDMETHOD(put_AdditionalOptions)(BSTR bstrAdditionalOptions);
	STDMETHOD(get_PreprocessorDefinitions)(BSTR* pbstrDefines);	// (/d) define symbol can have multiple
	STDMETHOD(put_PreprocessorDefinitions)(BSTR bstrDefines);
	STDMETHOD(get_Culture)(enumResourceLangID* pnLangID);	// (/l [num]) resource language ID
	STDMETHOD(put_Culture)(enumResourceLangID nLangID);
	STDMETHOD(get_AdditionalIncludeDirectories)(BSTR* pbstrIncludePath);	// (/I![path]) directory to add to include path, may have multiple
	STDMETHOD(put_AdditionalIncludeDirectories)(BSTR bstrIncludePath);
	STDMETHOD(get_IgnoreStandardIncludePath)(VARIANT_BOOL* pbIgnoreInclPath);	// (/X) ignore standard include path
	STDMETHOD(put_IgnoreStandardIncludePath)(VARIANT_BOOL bIgnoreInclPath);
	STDMETHOD(get_ShowProgress)(VARIANT_BOOL* pbShowProgress);	// (/v) verbose (print progress messages)
	STDMETHOD(put_ShowProgress)(VARIANT_BOOL bShowProgress);
	STDMETHOD(get_ResourceOutputFileName)(BSTR* pbstrResFile);	// (/fo[file]) name .RES file default: <rcfile>.res
	STDMETHOD(put_ResourceOutputFileName)(BSTR bstrResFile);
	// Automation properties
	STDMETHOD(get_ToolPath)(BSTR *pVal);
	STDMETHOD(get_PropertyOption)(BSTR bstrProp, long dispidProp, BSTR *pVal);
	STDMETHOD(get_FullIncludePath)(BSTR* fullIncludePath);	// include path, including all inherited values, plus platform includes
	STDMETHOD(get_VCProjectEngine)(IDispatch** projEngine)	{ return DoGetVCProjectEngine(projEngine); }

// IVCToolImpl
public:
	STDMETHOD(get_DefaultExtensions)(BSTR* pVal);
	STDMETHOD(put_DefaultExtensions)(BSTR newVal);
	STDMETHOD(GetAdditionalOptionsInternal)(IUnknown* pItem, VARIANT_BOOL bForBuild, VARIANT_BOOL bSkipLocal, BSTR* pbstrAdditionalOptions);
	STDMETHOD(GetBuildDescription)(IVCBuildAction* pAction, BSTR* pbstrBuildDescription);
	STDMETHOD(get_ToolPathInternal)(BSTR* pbstrToolPath);
	STDMETHOD(get_Bucket)(long *pVal);
	STDMETHOD(GenerateOutput)(long type, IVCBuildActionList* plstActions, IVCBuildErrorContext* pEC);
	STDMETHOD(AffectsOutput)(long nPropID, VARIANT_BOOL* pbAffectsOutput);
	STDMETHOD(CreateToolObject)(IVCPropertyContainer* pPropContainer, IVCToolImpl** ppToolObject);
	STDMETHOD(GetAdditionalIncludeDirectoriesInternal)(IVCPropertyContainer* pPropContainer, BSTR* pbstrIncDirs);
	STDMETHOD(get_IncludePathID)(long* pnIncludeID);
	STDMETHOD(get_ToolShortName)(BSTR* pbstrToolName);
	STDMETHOD(get_ToolNameInternal)(BSTR* pbstrToolName) { return get_ToolName(pbstrToolName); }
	STDMETHOD(MatchName)(BSTR bstrName, VARIANT_BOOL bFullOnly, VARIANT_BOOL* pbMatches);
	STDMETHOD(CanScanForDependencies)(VARIANT_BOOL* pbIsScannable);
	STDMETHOD(GenerateDependencies)(IVCBuildAction* pAction, void* frhFile, IVCBuildErrorContext* pErrorContext);
	STDMETHOD(CreatePageObject)(IUnknown **, CLSID*, IVCPropertyContainer *, IVCSettingsPage * );

	STDMETHOD(get_ToolDisplayIndex)(long* pIndex)
	{
		CHECK_POINTER_NULL(pIndex);
		*pIndex = TOOL_DISPLAY_INDEX_RC;
		return S_OK;
	}

	virtual long GetPageCount()	{ return 2; }
	virtual GUID* GetPageIDs();

// helpers
public:
	virtual COptionHandlerBase* GetOptionHandler() { return &s_optHandler; }

public:
	static CResourceCompilerToolOptionHandler s_optHandler;

protected:
	static GUID s_pPages[2];
	static BOOL s_bPagesInit;
	static CComBSTR s_bstrBuildDescription;
	static CComBSTR s_bstrToolName;
	static CComBSTR s_bstrExtensions;

protected:
	virtual LPCOLESTR GetToolFriendlyName();
	void InitToolName();
	virtual long GetToolID() { return IDS_RC; }

private:
	// Dependency Scanner Helpers
	static ResTokens GetNextToken(const char* pMax, const char*& pCurrent, const char*& pTokenStart);
	void CopyAndSuppressBackslashes(char* pdestbuf, const char*psrcbuf, int nchar);
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\vcpb\rctool.cpp ===
// RCTool.cpp : Implementation of Resource Compiler Tool

#include "stdafx.h"
#include "RCTool.h"
#include "BuildEngine.h"
#include "scanner.h"

// constants
const wchar_t* const wszRCDefaultExtensions = L"*.rc";	// remember to update vcpb.rgs if you change this...
const wchar_t* const wszRCDefaultResFile = L"$(IntDir)/$(InputName).res";
const enumResourceLangID lnCulture = rcEnglishUS;

// length of longest token in table
#define MAX_RCTOKEN_LEN		12

// static initializers
CComBSTR CVCResourceCompilerTool::s_bstrBuildDescription = L"";
CComBSTR CVCResourceCompilerTool::s_bstrToolName = L"";
CComBSTR CVCResourceCompilerTool::s_bstrExtensions = L"";
GUID CVCResourceCompilerTool::s_pPages[2];
BOOL CVCResourceCompilerTool::s_bPagesInit = FALSE;
CResourceCompilerToolOptionHandler CVCResourceCompilerTool::s_optHandler;

BOOL TokenLookup(const char *str, ResTokens *pTok);

// dependency generation helper
static int g_Line;

////////////////////////////////////////////////////////////////////////////////
// Option Table for the ResourceCompiler Tool switches

// NOTE: we're using macros for enum value ranges to help in keeping enum range checks as low maintenance as possible.
// If you add an enum to this table, make sure you use macros to define the upper and lower bounds and use CHECK_BOUNDS
// on the get/put methods associated with that property (both object model and property page).
// WARNING: if you change ANYTHING about a multi-prop here (including add/remove), be sure to update how the property
// is obtained on both the tool and page objects.
BEGIN_OPTION_TABLE(CResourceCompilerToolOptionHandler, L"VCResourceCompilerTool", IDS_RC, TRUE /* pre & post */, FALSE /* case sensitive */)
	OPT_BSTR(PreprocessorDefinitions,	L"d %s",		L"PreprocessorDefinitions", multiple,	IDS_RCGeneral, VCRCID)
	OPT_INT_NOZERO(Culture,				L"l 0x%x",		L"Culture",						IDS_RCGeneral, VCRCID)
	OPT_BSTR(AdditionalIncludeDirectories, L"I %s",		L"AdditionalIncludeDirectories",	multipleNoCase, IDS_RCGeneral, VCRCID)
	OPT_BOOL(IgnoreStandardIncludePath, L"|X",			L"IgnoreStandardIncludePath",	IDS_RCGeneral, VCRCID)
	OPT_BOOL(ShowProgress,				L"|v",			L"ShowProgress",				IDS_RCGeneral, VCRCID)
	OPT_BSTR(ResourceOutputFileName,	L"fo%s",		L"ResourceOutputFileName",	single, IDS_RCGeneral, VCRCID)
END_OPTION_TABLE()

// default value handlers
// string props
void CResourceCompilerToolOptionHandler::GetDefaultValue( long id, BSTR *pVal, IVCPropertyContainer *pPropCnt )
{
	switch( id )
	{
	case VCRCID_ResourceOutputFileName:
		*pVal = SysAllocString( wszRCDefaultResFile );
		break;
//	case VCRCID_AdditionalOptions:
//	case VCRCID_PreprocessorDefinitions:
//	case VCRCID_AdditionalIncludeDirectories:
	default:
		GetDefaultString( pVal );
		break;
	}
}

// integer props
void CResourceCompilerToolOptionHandler::GetDefaultValue( long id, long *pVal, IVCPropertyContainer *pPropCnt )
{
	switch( id )
	{
	case VCRCID_Culture:
		*pVal = lnCulture;
	default:
		*pVal = 0;
		break;
	}
}

// boolean props
void CResourceCompilerToolOptionHandler::GetDefaultValue( long id, VARIANT_BOOL *pVal, IVCPropertyContainer *pPropCnt )
{
//	switch( id )
//	{
//	case VCRCID_IgnoreStandardIncludePath:
//	case VCRCID_ShowProgress:
//	default:
		GetValueFalse( pVal );
//		break;
//	}
}


BOOL CResourceCompilerToolOptionHandler::SynthesizeOptionIfNeeded(IVCPropertyContainer* pPropContainer, long idOption)
{
	switch (idOption)
	{
	case VCRCID_ResourceOutputFileName:
		return TRUE;
	default:
		return FALSE;
	}
}

BOOL CResourceCompilerToolOptionHandler::SynthesizeOption(IVCPropertyContainer* pPropContainer, long idOption, 
	CComVariant& rvar)
{
	switch (idOption)
	{
	case VCRCID_ResourceOutputFileName:
		{
			VSASSERT(pPropContainer != NULL, "Property container required");
			RETURN_ON_NULL2(pPropContainer, FALSE);
			CComBSTR bstrOutFile;
			GetDefaultValue( idOption, &bstrOutFile );
			rvar = bstrOutFile;
			return TRUE;
		}
	default:
		VSASSERT(FALSE, "Case statement mismatch between SynthesizeOptionIfNeeded and SynthesizeOption");	// shouldn't be able to get here!!
		return FALSE;
	}
}

///////////////////////////////////////////////////////////////////////////////
// Resource Compiler Tool
HRESULT CVCResourceCompilerTool::CreateInstance(IVCPropertyContainer* pPropContainer, IVCToolImpl** ppRCTool)
{
	CHECK_POINTER_NULL(ppRCTool);
	*ppRCTool = NULL;

	CComObject<CVCResourceCompilerTool> *pObj;
	HRESULT hr = CComObject<CVCResourceCompilerTool>::CreateInstance(&pObj);
	if (SUCCEEDED(hr))
	{
		if( pPropContainer )
			pObj->Initialize(pPropContainer);
		CVCResourceCompilerTool *pVar = pObj;
		pVar->AddRef();
		*ppRCTool = pVar;
	}
	return hr;
}

///////////////////////////////////////////////////////////////////////////////
// Return the list of files generated by the resource compiler tool
STDMETHODIMP CVCResourceCompilerTool::GenerateOutput(long type, IVCBuildActionList* plstActions, 
	IVCBuildErrorContext* pEC)
{
	RETURN_ON_NULL2(plstActions, S_FALSE);
	plstActions->Reset(NULL);

	BOOL bFirst = TRUE;
	CComBSTR bstrProjectDirectory;
	while (TRUE)
	{
		CComPtr<IVCBuildAction> spAction;
		HRESULT hr = plstActions->Next(&spAction, NULL);
		BREAK_ON_DONE(hr);

		CComPtr<IVCPropertyContainer> spPropContainer;
		spAction->get_PropertyContainer(&spPropContainer);
		VSASSERT(spPropContainer != NULL, "Property container required");
		if (spPropContainer == NULL)
			continue;

		if (IsExcludedFromBuild(spPropContainer))
			continue;	// nothing to do for things excluded from build...

		if (bFirst)
		{
			bFirst = FALSE;
			spPropContainer->GetStrProperty(VCPROJID_ProjectDirectory, &bstrProjectDirectory);	// should never have macros in it
		}

		// DIANEME_TODO: .res extension is apparently platform-specific, get it for CVCResourceCompilerTool::GenerateOutput
		CComBSTR bstrResFileName, bstrTemp;
		if (spPropContainer->GetStrProperty(VCRCID_ResourceOutputFileName, &bstrTemp) == S_FALSE)
			s_optHandler.GetDefaultValue(VCRCID_ResourceOutputFileName, &bstrTemp);
		spPropContainer->Evaluate(bstrTemp, &bstrResFileName);
		if (spAction->AddOutputFromFileName(bstrResFileName, pEC, L"res", bstrProjectDirectory, VARIANT_TRUE, 
			VCRCID_ResourceOutputFileName, this) != S_OK)
			VSASSERT(FALSE, "Failed to add output dependency .res file");
	}

	return S_OK; // success
}

///////////////////////////////////////////////////////////////////////////////
// Affects our output?
STDMETHODIMP CVCResourceCompilerTool::AffectsOutput(long nPropID, VARIANT_BOOL* pbAffectsOutput)
{
	CHECK_POINTER_NULL(pbAffectsOutput);
	*pbAffectsOutput = VARIANT_FALSE;

	// change our outputs?
	switch (nPropID)
	{
	case VCRCID_ResourceOutputFileName:
	case VCRCID_OutputsDirty:
	case VCFCFGID_ExcludedFromBuild:
		*pbAffectsOutput = VARIANT_TRUE;
		break;
	}

	return S_OK;
}

STDMETHODIMP CVCResourceCompilerTool::CreatePageObject(IUnknown **ppUnk, CLSID*pCLSID, IVCPropertyContainer *pPropCntr, IVCSettingsPage *pPage )
{
	// Get the list of pages
	if( CLSID_RCGeneral == *pCLSID )
	{
		CPageObjectImpl<CVCResourceCompilerPage,VCRCTOOL_MIN_DISPID,VCRCTOOL_MAX_DISPID >::CreateInstance(ppUnk, pPropCntr, pPage);
	}
	else
	{
		return S_FALSE;
	}
		
	return S_OK;
}


GUID* CVCResourceCompilerTool::GetPageIDs()
{ 
	if (s_bPagesInit == FALSE)
	{
		s_pPages[0] = __uuidof(RCGeneral);
		s_pPages[1] = __uuidof(RCAdditionalOptions);
		s_bPagesInit = TRUE;
	}
	return s_pPages; 
}

STDMETHODIMP CVCResourceCompilerTool::CanScanForDependencies(VARIANT_BOOL* pbIsScannable)
{
	return s_optHandler.GetValueTrue(pbIsScannable);
}

///////////////////////////////////////////////////////////////////////////////					
//
//	Scans .RC files for includes.
//
// states
//	0:	initial state
//	1:	'#' received, waiting for 'include', 'define', 'undef' or 'error'
//	2:	'#' and 'include' received, waiting for filename
//	3:	ICON, BITMAP, CURSOR, FONT received, waiting binary filename
//	4:	waiting for newline
//	5:	'rcinclude' received, waiting for filename
//	6:	got newline word, ie. resource identifier
STDMETHODIMP CVCResourceCompilerTool::GenerateDependencies(IVCBuildAction* pAction, void* pfrhFileCookie, IVCBuildErrorContext* pEC)
{
	// WARNING (KiP) - GenerateDependencies works on ANSI Files
	// Many of the calls n this function will need to be _mbs calls instead of unicode
	// TCHAR characters and _tcs funtions should not be used because when UNICODE is defined,
	// TCHAR becomes UNICODE and we explicitly want _mbs no matter what.
	// Yes, ANSI
	
	BldFileRegHandle frhFile = (BldFileRegHandle)pfrhFileCookie;

	const char *pTokenStart, *pLine;

	int			iEntryType = 0, iState;
	int			nNameLength = 0;
	ResTokens	rToken;
	BOOL		bInsideMultiLine;
	char	cDelim;

	HANDLE hMem;
	DWORD dwFileSize;

	const char *pcFileMap;

	const CPathW* pPath = NULL;
	pPath = g_FileRegistry.GetRegEntry(frhFile)->GetFilePath();
	if (!g_StaticBuildEngine.OpenMemFile(frhFile, hMem, pcFileMap, dwFileSize, pEC, pAction))
		return CVCProjectEngine::DoSetErrorInfo2(VCPROJ_E_NOT_FOUND, IDS_ERR_FILE_NOT_FOUND, pPath->GetFullPath());	// couldn't open, continue with next

	const char * pMax;
	int iBegin = 0;
	BOOL fScanNative;

	if (pcFileMap == (const char *)NULL)
		goto CloseMemFile;	// no need to open

	pMax = pcFileMap + dwFileSize;

	// are we scanning a native resource file?
	// if not then don't attempt to scan using resource script syntax...
	// ie. this might happen if we #include "header.h" in the resource file
	fScanNative = FileNameMatchesExtension(pPath, L"*.rc;*.rc2");

	// Check for afx hack.	If the file begins with "//{{NO_DEP", don't scan:
	if (dwFileSize < 10 || _mbsnicmp ((const unsigned char *)pcFileMap, (const unsigned char *)"//{{NO_DEP", 10) == 0)
	{
		pAction->SetDependencyState(depNone);
		goto CloseMemFile;
	}

	g_Line = 1; iState = 0;
	bInsideMultiLine = FALSE;

	for (;;)
	{
		if ((rToken = GetNextToken (pMax, pcFileMap, pTokenStart)) == TOKEN_EOF)
			break;

		if (rToken == TOKEN_STOP_SCAN)
		{
			for (;rToken = GetNextToken (pMax, pcFileMap, pTokenStart),
				rToken != TOKEN_START_SCAN && rToken != TOKEN_EOF;)
			{}

			if (rToken == TOKEN_EOF) 
				break;
			else 
				continue;
		}

		switch (rToken)
		{
			case TOKEN_NEWLINE:
				if (iState == 4 || iState == 1) 
					iState = 0;
				break;

			case TOKEN_HASHSIGN:
				if (iState != 0) 
					iState = 4;
				else 
					iState = 1;
				break;

			case TOKEN_INCLUDE:
				if (iState != 1) 
					iState = 4;
				else 
					iState = 2;
				break;

			case TOKEN_RCINCLUDE:
				if (iState != 0) 
					iState = 4;
				else 
					iState = 5;
				break;

			case TOKEN_DEFINE:
			case TOKEN_UNDEF:
			case TOKEN_ERROR:
				iState = 4;
				break;

			case TOKEN_COMMENT:
				iState = 0;
				break;

			case TOKEN_WORD:
			{
				// Waiting for a newline...
				if (iState == 4 || iState == 1)
					break;

				// only do this if we *know* we are a resource script
				if (fScanNative)
				{
					// 1st non-quoted word on a line?
					if (iState == 0 && *pTokenStart != '"')
					{
						// wait for 2nd word, could be ICON or 'custom resource' name
						iState = 6;
						break; 
					}
					
					// Is this a 'custom resource' identifier (2nd non-quoted word on a line)?
					if (iState == 6 && *pTokenStart != '"')
					{
						iState = !bInsideMultiLine ? 3 : 4; // next token is include : ignore, wait for newline
						break;
					}
				}

				// Waiting for a file name?
				if (iState == 3)
				{
					// Check for a comma on the same line, before any
					// comments. this is to catch the case 'FONT 8, "Helv"'
					for (pLine = pTokenStart; pLine < pMax && *pLine != '/' && *pLine != '\r'; pLine = (const char *)_mbsinc((const unsigned char *)pLine))
					{
						if (*pLine == ',')
						{
							iState = 4;
							break;
						}
					}
				}

				BOOL fScan = FALSE;		// by default, don't scan the include
				BOOL fGotDep = FALSE;;	// by default, this state is not a got dep.
				
				if (iState	== 3 || iState	== 5)
				{
					iEntryType = IncTypeCheckParentDir | IncTypeCheckIncludePath | IncTypeCheckOriginalDir;

					// check for included 'generated' outputs in intermediate dir.
					if (iState == 3)
						iEntryType |= IncTypeCheckIntDir;

					nNameLength = (int)(pcFileMap - pTokenStart);
					fScan = (iState != 3);
					fGotDep = TRUE;
				}
				else if (iState == 2)
				{
					// include file name in the form "xxxxxx.yyy"
					if (*pTokenStart == '"')
					{
						iEntryType = IncTypeCheckParentDir | IncTypeCheckIncludePath | IncTypeCheckOriginalDir;
						cDelim =  '"';
					}
					else if (*pTokenStart == '<')
					{
						iEntryType = IncTypeCheckIncludePath;
						cDelim =  '>';
					}
					else
					{
						break;
					}
				
					nNameLength =  (int)(pcFileMap - pTokenStart);
					
					// must have "foo.h" or <foo.h> with at least a 1 char. name
					if (nNameLength > 2 && *(pcFileMap-1) == cDelim)
					{
						fScan = TRUE;
						fGotDep = TRUE;
					}

					//	else syntax error
				}

				if (fGotDep)	// deal with this dependency
				{
					CStringW	strFile;
					CStringA	strFileA;	// yes, ANSI -- 'cause we're working with RC files which are ANSI
					char *pbuf = strFileA.GetBuffer((nNameLength + 1)*2);
					CopyAndSuppressBackslashes(pbuf, pTokenStart, nNameLength);
					strFileA.ReleaseBuffer();
					strFile = strFileA;		// Finally convert to unicode and go

					CVCStringWList strlstIncs;
					strlstIncs.AddHead( L"\"" + strFile + L"\"" );
					CVCStringWList strlstPaths;
					if (!ResolveIncludeDirectivesToPath(*pPath, pAction, strlstIncs, strlstPaths))
					{
						pAction->MarkMissingDependencies(TRUE /* missing dep */);
						goto CloseMemFile;
					}
					if(strlstPaths.GetCount())
					{
						CStringW strInc = strlstPaths.GetHead();
						CComBSTR bstrInc = strInc;
						HRESULT hr = pAction->AddScannedDependencyOfType(iEntryType, bstrInc, g_Line, fScan, pEC);
						VSASSERT(hr == S_OK, "Unexpected return value from pAction->AddScannedDependencyOfType");
					}
					iState = 4;
				}
				else
				{
					iState = 0;
				}
				break;
			}

			// These tokens are all just noise, so eat them:
			case TOKEN_LOADONCALL:
			case TOKEN_PRELOAD:
			case TOKEN_PURE:
			case TOKEN_IMPURE:
			case TOKEN_FIXED:
			case TOKEN_MOVEABLE:
			case TOKEN_DISCARDABLE:
				if (iState != 3) 
					iState = 4;
				break;

			case TOKEN_ICON:
			case TOKEN_TYPELIB:
			case TOKEN_FONT:
			case TOKEN_BITMAP:
			case TOKEN_CURSOR:
				if (iState == 6 && !bInsideMultiLine) 
					iState = 3;
				else  
					iState = 4;
				break;

			// ignore all info after these tokens
			case TOKEN_LANGUAGE:
				iState = 4;
				break;
			// These tokens are all multiline statements so we expect to have a BEGIN - END pair
			// and we should ignore anything inside the multiline statement (including the ones 
			// before BEGIN-END block)
			case TOKEN_ACCELERATORS:
			case TOKEN_DIALOG:
			case TOKEN_DLGINIT:
			case TOKEN_MENU:
			case TOKEN_TOOLBAR:
			case TOKEN_RCDATA:
			case TOKEN_STRINGTABLE:
			case TOKEN_VERSIONINFO:
			case TOKEN_GUIDELINES:
			case TOKEN_DIALOGEX:
			case TOKEN_MENUEX:
				bInsideMultiLine = TRUE;
				iState = 4;
				break;
		
			// make sure that the number of begin - end matches
			case TOKEN_BEGIN:
				if (bInsideMultiLine)
					iBegin++;
				iState = 4;
				break;

			case TOKEN_END:
				if (bInsideMultiLine)
				{
					iBegin--;
					if (iBegin == 0)
						bInsideMultiLine = FALSE;
				}
				iState = 4;
				break;
			}
	}

CloseMemFile:

	g_StaticBuildEngine.CloseMemFile(hMem, pEC);

	return S_OK;
}

ResTokens CVCResourceCompilerTool::GetNextToken(const char* pMax, const char*& pCurrent,
	const char*& pTokenStart)
{
	// WARNING (KiP) - GetNextToken works on ANSI Files
	// Many of the calls n this function will need to be _mbs calls instead of unicode
	// TCHAR characters and _tcs funtions should not be used because when UNICODE is defined,
	// TCHAR becomes UNICODE and we explicitly want _mbs no matter what.
	// Yes, ANSI

	//
	//	Goes through map of an RC file looking for tokens.	pCurrent
	//	if the 'file pointer" for the map and returns pointing to the
	//	first charcter after the token.	 pTokenStart returns pointing 
	//	to the start of the token.
	//
	ResTokens RetToken;
	int i;

	if (pCurrent >= pMax) 
		return TOKEN_EOF;

	// Skip white space:
	while (_ismbcspace(*pCurrent))
	{
		BOOL bIsNewLine = (*pCurrent == '\r');
		pCurrent++;

		if (pCurrent >= pMax)
			return TOKEN_EOF;

		if (bIsNewLine)
		{
			g_Line++;
			return TOKEN_NEWLINE;
		}
	}

	pTokenStart = pCurrent;

	// See what first not white-sapce character is
	int nRemLen;
	if (*pCurrent == '#')
	{
		pCurrent++;
		return TOKEN_HASHSIGN;
	}
	else if (*pCurrent == '/')
	{
		// Treat anything with this preceding char. as a comment token!
		RetToken = TOKEN_COMMENT;

		// See if we have special start or stop scan delimiters
		nRemLen = (int)(pMax - pCurrent);
		if (nRemLen > 16 &&
			(_mbsnicmp ((const unsigned char *)pCurrent, (const unsigned char *)"//}}START_DEPSCAN", 17) == 0))
			RetToken = TOKEN_START_SCAN;

		else
		if (nRemLen > 15 &&
			(_mbsnicmp ((const unsigned char *)pCurrent, (const unsigned char *)"//{{STOP_DEPSCAN", 16) == 0))
			RetToken = TOKEN_STOP_SCAN;

		// Do we need to skip a comment block?
		BOOL fInCommentBlock = (nRemLen > 1) && (*(pCurrent + 1) == '*');

		// Skip up to and including new line, this will be after a comment
		// block if we have one.
		// This means no TOKEN_NEWLINE follows a comment.
		while (pCurrent < pMax)
		{
			if (*pCurrent == '\r')
			{
				g_Line++;
				if (!fInCommentBlock)
					break;
			}
			// End of the comment block?
			else if (fInCommentBlock && (pCurrent < (pMax - 1)) &&
					 *pCurrent == '*' && *(pCurrent + 1) == '/')
			{
				fInCommentBlock = FALSE;
			}

			pCurrent = (const char *)_mbsinc((const unsigned char *)pCurrent);
		}
		pCurrent = (const char *)_mbsinc((const unsigned char *)pCurrent);
		return RetToken;
	}

	//	If the token begins with a quote, then go till the next quote:
	else if (*pTokenStart== '"')
	{
		pCurrent = (const char *)_mbsinc((const unsigned char *)pCurrent);
		while (pCurrent < pMax && *pCurrent != '"')
			pCurrent = (const char *)_mbsinc((const unsigned char *)pCurrent);
		pCurrent = (const char *)_mbsinc((const unsigned char *)pCurrent);
		return (pCurrent >= pMax) ? TOKEN_EOF : TOKEN_WORD;
	}
		
	//	Some kind of a word.  Skip to the end:
	while (pCurrent < pMax && !_ismbcspace(*pCurrent))
		pCurrent = (const char *)_mbsinc((const unsigned char *)pCurrent);
	if (pCurrent >= pMax + 1)	
		return TOKEN_EOF;

	//	Examine the token.

	i = (int)(pCurrent - pTokenStart);	// Length of token in bytes.

	if ((i > MAX_RCTOKEN_LEN) || (!_ismbcalpha(*pTokenStart))) // REVIEW(KiP): Does this work, what about MBC alpha characters?
		return TOKEN_WORD;		
		
	// look up in map for speed
	char szToken[MAX_RCTOKEN_LEN+1];
	_mbsncpy((unsigned char *)szToken, (unsigned char *)pTokenStart, i);
	szToken[i] = 0;						// nul-terminate
	_mbslwr((unsigned char *)szToken);			// FUTURE: combine with copy operation

	if (TokenLookup((const char *)szToken,	&RetToken))
		return RetToken;

	return TOKEN_WORD;
}


//	Copy an .rc #include from psrcbuf to pdestbuf.	If the fisrt
//	character is a ", then double back slashes in the src
//	are replaced with a single \.
//
//	nchar chars are copied (nchar - 2 of there are quotes),
//	and a terminating null is put on.
//
void CVCResourceCompilerTool::CopyAndSuppressBackslashes(char *pdestbuf, const char * psrcbuf, int nchar)
{
	// WARNING (KiP) - CopyAndSurpressBackslashes works on ANSI Files
	// Many of the calls n this function will need to be _mbs calls instead of unicode
	// TCHAR characters and _tcs funtions should not be used because when UNICODE is defined,
	// TCHAR becomes UNICODE and we explicitly want _mbs no matter what.
	// Yes, ANSI

	const char *pMax;

	if (*psrcbuf != '"' && *psrcbuf != '<')
	{
		_mbsncpy ((unsigned char *)pdestbuf, (unsigned char *)psrcbuf, nchar);
		pdestbuf[nchar] = '\0';
		return;
	}

	BOOL	fSawBackWhack = FALSE;

	psrcbuf++;
	pMax = psrcbuf + nchar -2;	// subtract 2 for leading trailing quotes.

	while (psrcbuf < pMax)
	{
		if (fSawBackWhack ||
			!(*psrcbuf == '\\' && *(psrcbuf+1) == '\\'))
		{
			// copy one (possibly multibyte) character
			if (IsDBCSLeadByte(*pdestbuf++ = *psrcbuf++))
				*pdestbuf++ = *psrcbuf++;
			fSawBackWhack = FALSE;
		}
		else	
		{
			psrcbuf++;
			fSawBackWhack = TRUE;
		}
	}			

	// get trailing slash?
	if (fSawBackWhack)
		*pdestbuf++ = *--psrcbuf;

	*pdestbuf = '\0';
}

struct RCToken
{
	const char *strName;
	ResTokens	tok;

};

// WARNING: Keep this in alphabetical order or the bsearch will fail !
RCToken s_TokenList[31] =
{
	{ "accelerators",TOKEN_ACCELERATORS },
	{ "begin",      TOKEN_BEGIN },
	{ "bitmap",     TOKEN_BITMAP },
	{ "cursor",     TOKEN_CURSOR },
	{ "define", 	TOKEN_DEFINE },
	{ "dialog", 	TOKEN_DIALOG },
	{ "dialogex",	TOKEN_DIALOGEX },
	{ "discardable",TOKEN_DISCARDABLE },
	{ "dlginit",	TOKEN_DLGINIT },
	{ "end",        TOKEN_END },
	{ "error",      TOKEN_ERROR },
	{ "fixed",      TOKEN_FIXED },
	{ "font",       TOKEN_FONT },
	{ "guidelines", TOKEN_GUIDELINES },
	{ "icon",       TOKEN_ICON },
	{ "impure",     TOKEN_IMPURE },
	{ "include",	TOKEN_INCLUDE },
	{ "language",	TOKEN_LANGUAGE },
	{ "loadoncall", TOKEN_LOADONCALL },
	{ "menu",       TOKEN_MENU },
	{ "menuex", 	TOKEN_MENUEX },
	{ "moveable",	TOKEN_MOVEABLE },
	{ "preload",	TOKEN_PRELOAD },
	{ "pure",       TOKEN_PURE },
	{ "rcdata", 	TOKEN_RCDATA },
	{ "rcinclude",	TOKEN_RCINCLUDE },
	{ "stringtable",TOKEN_STRINGTABLE },
	{ "toolbar",	TOKEN_TOOLBAR },
	{ "typelib",	TOKEN_TYPELIB },
	{ "undef",      TOKEN_UNDEF },
	{ "versioninfo",TOKEN_VERSIONINFO }
};

int TokenCompare( char **pKey, RCToken *s2 )
{
	const char *key = *pKey;
	return strcmp( key, s2->strName );
}

BOOL TokenLookup(const char *str, ResTokens *pTok)
{
	RCToken *pRCTok = (RCToken *)bsearch( &str, &s_TokenList,31,sizeof(RCToken), (int(*)(const void *, const void *))TokenCompare);
	if( pRCTok )
	{
		*pTok = pRCTok->tok;
		return TRUE;
	}
	else
		return FALSE;
}


///////////////////////////////////////////////////////////////////////////////////////
// CVCResourceCompilerTool::VCResourceCompilerTool -- switches are not case sensitive
///////////////////////////////////////////////////////////////////////////////////////

LPCOLESTR CVCResourceCompilerTool::GetToolFriendlyName()
{
	InitToolName();
	return s_bstrToolName;
}

void CVCResourceCompilerTool::InitToolName()
{
	if (s_bstrToolName.Length() == 0)
	{
		if (!s_bstrToolName.LoadString(IDS_RC_TOOLNAME))
			s_bstrToolName = szResourceCompilerToolType;
	}
}

STDMETHODIMP CVCResourceCompilerTool::get_ToolName(BSTR* pbstrToolName) // friendly name of tool, e.g., "C/C++ Compiler Tool"
{
	CHECK_POINTER_VALID( pbstrToolName );
	InitToolName();
	s_bstrToolName.CopyTo(pbstrToolName);
	return S_OK;
}

STDMETHODIMP CVCResourceCompilerTool::get_AdditionalOptions(BSTR* pbstrAdditionalOptions)
{	// anything we don't know what to do with, given verbatim, in same order as entered, parent contributions first, goes after all other switches
	return ToolGetStrProperty(VCRCID_AdditionalOptions, pbstrAdditionalOptions);
}

STDMETHODIMP CVCResourceCompilerTool::put_AdditionalOptions(BSTR bstrAdditionalOptions)
{
	CHECK_ZOMBIE( m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE );
	return m_spPropertyContainer->SetStrProperty(VCRCID_AdditionalOptions, bstrAdditionalOptions);
}

STDMETHODIMP CVCResourceCompilerTool::get_PreprocessorDefinitions(BSTR* pbstrDefines)
{	// (/d) define symbol can have multiple
	return ToolGetStrProperty(VCRCID_PreprocessorDefinitions, pbstrDefines);
}

STDMETHODIMP CVCResourceCompilerTool::put_PreprocessorDefinitions(BSTR bstrDefines)
{
	CHECK_ZOMBIE( m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE );
	return m_spPropertyContainer->SetStrProperty(VCRCID_PreprocessorDefinitions, bstrDefines);
}

STDMETHODIMP CVCResourceCompilerTool::get_Culture(enumResourceLangID* pnLangID)
{	// (/l [num]) resource language ID
	return ToolGetIntProperty(VCRCID_Culture, (long *)pnLangID);
}

STDMETHODIMP CVCResourceCompilerTool::put_Culture(enumResourceLangID nLangID)
{
	CHECK_ZOMBIE( m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE );
	CHECK_POSITIVE(nLangID);
	return m_spPropertyContainer->SetIntProperty(VCRCID_Culture, nLangID);
}

STDMETHODIMP CVCResourceCompilerTool::get_AdditionalIncludeDirectories(BSTR* pbstrIncludePath)
{	// (/I![path]) directory to add to include path, may have multiple
	return ToolGetStrProperty(VCRCID_AdditionalIncludeDirectories, pbstrIncludePath);
}

STDMETHODIMP CVCResourceCompilerTool::put_AdditionalIncludeDirectories(BSTR bstrIncludePath)
{
	CHECK_ZOMBIE( m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE );
	return m_spPropertyContainer->SetStrProperty(VCRCID_AdditionalIncludeDirectories, bstrIncludePath);
}

STDMETHODIMP CVCResourceCompilerTool::get_IgnoreStandardIncludePath(VARIANT_BOOL* pbIgnoreInclPath)
{	// (/X) ignore standard include path
	return ToolGetBoolProperty(VCRCID_IgnoreStandardIncludePath, pbIgnoreInclPath);
}

STDMETHODIMP CVCResourceCompilerTool::put_IgnoreStandardIncludePath(VARIANT_BOOL bIgnoreInclPath)
{
	CHECK_ZOMBIE( m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE );
	CHECK_VARIANTBOOL( bIgnoreInclPath );
	return m_spPropertyContainer->SetBoolProperty(VCRCID_IgnoreStandardIncludePath, bIgnoreInclPath);
}

STDMETHODIMP CVCResourceCompilerTool::get_ShowProgress(VARIANT_BOOL* pbShowProgress)
{	// (/v) verbose (print progress messages)
	return ToolGetBoolProperty(VCRCID_ShowProgress, pbShowProgress);
}

STDMETHODIMP CVCResourceCompilerTool::put_ShowProgress(VARIANT_BOOL bShowProgress)
{
	CHECK_ZOMBIE( m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE );
	CHECK_VARIANTBOOL( bShowProgress );
	return m_spPropertyContainer->SetBoolProperty(VCRCID_ShowProgress, bShowProgress);
}

STDMETHODIMP CVCResourceCompilerTool::get_ResourceOutputFileName(BSTR* pbstrResFile)
{	// (/fo[file]) name .RES file default: <rcfile>.res
	return ToolGetStrProperty(VCRCID_ResourceOutputFileName, pbstrResFile);
}

STDMETHODIMP CVCResourceCompilerTool::put_ResourceOutputFileName(BSTR bstrResFile)
{
	CHECK_ZOMBIE( m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE );
	return m_spPropertyContainer->SetStrProperty(VCRCID_ResourceOutputFileName, bstrResFile);
}

// Automation properties
STDMETHODIMP CVCResourceCompilerTool::get_ToolPath(BSTR *pVal)
{
	CHECK_POINTER_VALID(pVal);
	*pVal = SysAllocString( szResourceCompilerToolPath );
	return S_OK;
}

STDMETHODIMP CVCResourceCompilerTool::get_PropertyOption(BSTR bstrProp, long dispidProp, BSTR *pVal)
{ 
	return DoGetPropertyOption(bstrProp, dispidProp, pVal); 
}

STDMETHODIMP CVCResourceCompilerTool::get_FullIncludePath(BSTR* fullIncludePath)
{	// include path, including all inherited values, plus platform includes
	return get_FullIncludePathInternal(fullIncludePath);
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////
// CVCResourceCompilerTool::IVCToolImpl
/////////////////////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CVCResourceCompilerTool::get_DefaultExtensions(BSTR* pVal)
{
	return DoGetDefaultExtensions(s_bstrExtensions, wszRCDefaultExtensions, pVal);
}

STDMETHODIMP CVCResourceCompilerTool::put_DefaultExtensions(BSTR newVal)
{
	s_bstrExtensions = newVal;
	return S_OK;
}

STDMETHODIMP CVCResourceCompilerTool::GetAdditionalOptionsInternal(IUnknown* pItem, VARIANT_BOOL bForBuild, 
	VARIANT_BOOL bSkipLocal, BSTR* pbstrAdditionalOptions)
{ 
	return GetProcessedAdditionalOptions(pItem, VCRCID_AdditionalOptions, bForBuild, bSkipLocal, pbstrAdditionalOptions);
}

STDMETHODIMP CVCResourceCompilerTool::GetBuildDescription(IVCBuildAction* pAction, BSTR* pbstrBuildDescription)
{
	if (s_bstrBuildDescription.Length() == 0)
		s_bstrBuildDescription.LoadString(IDS_DESC_RC_COMPILING);
	return s_bstrBuildDescription.CopyTo(pbstrBuildDescription);
}

STDMETHODIMP CVCResourceCompilerTool::get_ToolPathInternal(BSTR* pbstrToolPath)
{ 
	return get_ToolPath(pbstrToolPath);
}

STDMETHODIMP CVCResourceCompilerTool::get_Bucket(long *pVal)
{
	CHECK_POINTER_NULL( pVal );
	*pVal = BUCKET_RC;
	return S_OK;
}

STDMETHODIMP CVCResourceCompilerTool::CreateToolObject(IVCPropertyContainer* pPropContainer, IVCToolImpl** ppToolObject)
{ 
	return CreateInstance(pPropContainer, ppToolObject); 
}

STDMETHODIMP CVCResourceCompilerTool::GetAdditionalIncludeDirectoriesInternal(IVCPropertyContainer* pPropContainer, BSTR* pbstrIncDirs)
{
	CHECK_POINTER_NULL( pbstrIncDirs );
	CHECK_READ_POINTER_NULL(pPropContainer);

	CComBSTR bstrTmp;
	HRESULT hr = pPropContainer->GetMultiProp(VCRCID_AdditionalIncludeDirectories, L";", VARIANT_FALSE, &bstrTmp);
	if (SUCCEEDED(hr))
		pPropContainer->Evaluate(bstrTmp, pbstrIncDirs);
	else
		*pbstrIncDirs = bstrTmp.Detach();
	return hr;
}

STDMETHODIMP CVCResourceCompilerTool::get_IncludePathID(long* pnIncludeID)
{
	CHECK_POINTER_NULL(pnIncludeID);
	*pnIncludeID = VCRCID_AdditionalIncludeDirectories;
	return S_OK;
}

STDMETHODIMP CVCResourceCompilerTool::get_ToolShortName(BSTR* pbstrToolName)
{
	*pbstrToolName = SysAllocString( szResourceCompilerToolShortName );
	return S_OK;
}

STDMETHODIMP CVCResourceCompilerTool::MatchName(BSTR bstrName, VARIANT_BOOL bFullOnly, VARIANT_BOOL* pbMatches)
{
	return DoMatchName(bstrName, szResourceCompilerToolType, szResourceCompilerToolShortName, pbMatches);
}


STDMETHODIMP CVCResourceCompilerPage::get_AdditionalOptions(BSTR* pbstrAdditionalOptions)
{	// anything we don't know what to do with, given verbatim, in same order as entered, parent contributions first, goes after all other options
	return ToolGetStrProperty(VCRCID_AdditionalOptions, &(CVCResourceCompilerTool::s_optHandler), pbstrAdditionalOptions);
}

STDMETHODIMP CVCResourceCompilerPage::put_AdditionalOptions(BSTR bstrAdditionalOptions)
{
	return SetStrProperty(VCRCID_AdditionalOptions, bstrAdditionalOptions);
}

STDMETHODIMP CVCResourceCompilerPage::get_PreprocessorDefinitions(BSTR* pbstrDefines)
{	// (/d) define symbol can have multiple
	return ToolGetStrProperty(VCRCID_PreprocessorDefinitions, &(CVCResourceCompilerTool::s_optHandler), pbstrDefines);
}

STDMETHODIMP CVCResourceCompilerPage::put_PreprocessorDefinitions(BSTR bstrDefines)
{
	return SetStrProperty(VCRCID_PreprocessorDefinitions, bstrDefines);
}

STDMETHODIMP CVCResourceCompilerPage::get_Culture(enumResourceLangID* pnLangID)
{	// (/l [num]) resource language ID
	return ToolGetIntProperty(VCRCID_Culture, &(CVCResourceCompilerTool::s_optHandler), (long *)pnLangID);
}

STDMETHODIMP CVCResourceCompilerPage::put_Culture(enumResourceLangID nLangID)
{
	CHECK_POSITIVE_FOR_PROP_PAGES(nLangID);
	return SetIntProperty(VCRCID_Culture, nLangID);
}

STDMETHODIMP CVCResourceCompilerPage::get_AdditionalIncludeDirectories(BSTR* pbstrIncludePath)
{	// (/I![path]) directory to add to include path, may have multiple
	return ToolGetStrProperty(VCRCID_AdditionalIncludeDirectories, &(CVCResourceCompilerTool::s_optHandler), pbstrIncludePath);
}

STDMETHODIMP CVCResourceCompilerPage::put_AdditionalIncludeDirectories(BSTR bstrIncludePath)
{
	return SetStrProperty(VCRCID_AdditionalIncludeDirectories, bstrIncludePath);
}

STDMETHODIMP CVCResourceCompilerPage::get_IgnoreStandardIncludePath(enumIgnoreStandardIncludePathBOOL* pbIgnoreInclPath)
{	// (/X) ignore standard include path
	return GetEnumBoolProperty2(VCRCID_IgnoreStandardIncludePath, (long *)pbIgnoreInclPath);
}

STDMETHODIMP CVCResourceCompilerPage::put_IgnoreStandardIncludePath(enumIgnoreStandardIncludePathBOOL bIgnoreInclPath)
{
	return SetBoolProperty(VCRCID_IgnoreStandardIncludePath, bIgnoreInclPath);
}

STDMETHODIMP CVCResourceCompilerPage::get_ShowProgress(enumShowProgressBOOL* pbShowProgress)
{	// (/v) verbose (print progress messages)
	return GetEnumBoolProperty2(VCRCID_ShowProgress, (long *)pbShowProgress);
}

STDMETHODIMP CVCResourceCompilerPage::put_ShowProgress(enumShowProgressBOOL bShowProgress)
{
	return SetBoolProperty(VCRCID_ShowProgress, bShowProgress);
}

STDMETHODIMP CVCResourceCompilerPage::get_ResourceOutputFileName(BSTR* pbstrResFile)
{	// (/fo[file]) name .RES file default: <rcfile>.res
	return ToolGetStrProperty(VCRCID_ResourceOutputFileName, &(CVCResourceCompilerTool::s_optHandler), pbstrResFile);
}

STDMETHODIMP CVCResourceCompilerPage::put_ResourceOutputFileName(BSTR bstrResFile)
{
	return SetStrProperty(VCRCID_ResourceOutputFileName, bstrResFile);
}

void CVCResourceCompilerPage::GetBaseDefault(long id, CComVariant& varValue)
{
	if (id == VCRCID_ResourceOutputFileName)
	{
		CComBSTR bstrVal;
		CVCResourceCompilerTool::s_optHandler.GetDefaultValue( id, &bstrVal );
		varValue = bstrVal;
	}
	else
		CBase::GetBaseDefault(id, varValue);
}

// helper function for the two member functions below
static void FormatLanguageString(long lcid, CStringW& strLang)
{
	wchar_t sz[4096];	
	int dRet = GetLocaleInfoW(lcid, LOCALE_SLANGUAGE, sz, 4095);
	if (dRet > 4095 || dRet == 0)
		strLang.Format(L"0x%x", lcid);
	else
		strLang.Format(L"%s (0x%x)", sz, lcid);
}

STDMETHODIMP CVCResourceCompilerPage::GetDisplayString( DISPID dispID, BSTR *pBstr )
{
	if (dispID != VCRCID_Culture)
		return CBase::GetDisplayString(dispID, pBstr);

	CHECK_POINTER_NULL(pBstr);

	// what type is this?
	CComVariant var;
	HRESULT hr = CComDispatchDriver::GetProperty( this, dispID, &var );
	if( FAILED( hr ) )
		return S_FALSE;
	else if ((var.vt != VT_I2 && var.vt != VT_I4) || var.lVal == INHERIT_PROP_VALUE)
		return CBase::GetDisplayString(dispID, pBstr);

	CStringW strLang;
	if (var.lVal)
		FormatLanguageString(var.lVal, strLang);
	else
		strLang.LoadString(VCTDENUM_Default);
	*pBstr = strLang.AllocSysString();
	return S_OK;
}

void CVCResourceCompilerPage::GetLocalizedName(DISPID dispID, MEMBERID memid, ITypeInfo2* pTypeInfo2Enum, long lVal, CComBSTR& bstrDoc)
{
	if (dispID != VCRCID_Culture || lVal == INHERIT_PROP_VALUE)
		return CBase::GetLocalizedName(dispID, memid, pTypeInfo2Enum, lVal, bstrDoc);

	// try to get the localized name if possible.
	CStringW strLang;
	if (lVal)
		FormatLanguageString(lVal, strLang);
	else
		strLang.LoadString(VCTDENUM_Default);
	bstrDoc = strLang;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\vcpb\regscan.cpp ===
// RegScan.cpp: implementation of the CRegistryScanner class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "RegScan.h"
#include "uniapi.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif


////////////////////////////////////////////////////////////////////////////
// Registry scanner class
CRegistryScanner::CRegistryScanner()
	: m_hKeyRoot(NULL), m_iSubKey(0)
{
}

CRegistryScanner::~CRegistryScanner()
{
	if (m_hKeyRoot != NULL)
		Close();
}

BOOL CRegistryScanner::Open(HKEY hKey, BSTR bstrSubKey)
{
	if (m_hKeyRoot)
		Close();

	m_bstrKey = bstrSubKey;

	// Try to open the key.
	return ::RegOpenKeyW(hKey, bstrSubKey, &m_hKeyRoot) == ERROR_SUCCESS;
}

void CRegistryScanner::Close()
{
	// Close the key.
	::RegCloseKey(m_hKeyRoot);
	m_hKeyRoot = NULL;
}

BOOL CRegistryScanner::EnumKey(BSTR *pbstrKeyName)
{
	BOOL fOK;
	wchar_t szBuffer[_MAX_REG_BUFFER + 1];
	fOK = ::RegEnumKeyW(m_hKeyRoot, m_iSubKey++, szBuffer, _MAX_REG_BUFFER) == ERROR_SUCCESS;
	if( fOK )
	{
		m_bstrKey = szBuffer;
		m_bstrKey.CopyTo(pbstrKeyName);
	}
	return fOK;
}

BOOL CRegistryScanner::GetValue(BSTR bstrKey, BSTR *pbstrValue)
{
	ATLASSERT(m_hKeyRoot != NULL);

	CComBSTR bstrSub = m_bstrKey;
	bstrSub.Append(bstrKey);

	wchar_t szBuffer[_MAX_REG_BUFFER + 1];
	LONG cchBuffer = _MAX_REG_BUFFER;

	LONG lr = ::RegQueryValueW(m_hKeyRoot, bstrSub, szBuffer, &cchBuffer);
	if( lr == ERROR_SUCCESS )
	{
		CComBSTR bstr = szBuffer;
		*pbstrValue = bstr.Detach();
	}
	return lr == ERROR_SUCCESS;
}

BOOL CRegistryScanner::QueryStringValue(BSTR bstrValueName, CStringW& rstrValue)
{
	ATLASSERT(m_hKeyRoot != NULL);

	DWORD dwType;
	DWORD cchBuffer = _MAX_REG_BUFFER;
	LONG lRes;
	
	wchar_t szBuffer[_MAX_REG_BUFFER + 1];
	lRes = ::RegQueryValueExW(m_hKeyRoot, bstrValueName, NULL, &dwType, reinterpret_cast<LPBYTE>(szBuffer), &cchBuffer);
	rstrValue = szBuffer;

	if (lRes != ERROR_SUCCESS)
		return FALSE;
	if (dwType != REG_SZ)
		return FALSE;

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\vcpb\rctoolbase.h ===
// VCResourceCompilerBaseTool.h: Definition of the CVCResourceCompilerBaseTool class
//
//////////////////////////////////////////////////////////////////////

#pragma once

#include "vctool.h"
#include "settingspage.h"

/////////////////////////////////////////////////////////////////////////////
// CVCResourceCompilerPage

class ATL_NO_VTABLE CVCResourceCompilerPage :
	public IDispatchImpl<IVCResourceCompilerPage, &IID_IVCResourceCompilerPage, &LIBID_VCProjectEnginePrivateLibrary, PrivateProjBuildTypeLibNumber,0, CVsTypeInfoHolder>,
	public CPageObjectImpl<CVCResourceCompilerPage,VCRCTOOL_MIN_DISPID,VCRCTOOL_MAX_DISPID>,
	public CComObjectRoot
{
public:
BEGIN_COM_MAP(CVCResourceCompilerPage)
 	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IVCResourceCompilerPage)
	COM_INTERFACE_ENTRY(IPerPropertyBrowsing)
	COM_INTERFACE_ENTRY(IVsPerPropertyBrowsing)
	COM_INTERFACE_ENTRY(IVCPropertyContainer)
	COM_INTERFACE_ENTRY(IProvidePropertyBuilder)
END_COM_MAP()

	// IDispatch override
	STDMETHOD(Invoke)( DISPID dispid, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS *pdispParams, VARIANT *pvarResult, EXCEPINFO *pexcepInfo, UINT *puArgErr )
	{
		IDispatchImpl<IVCResourceCompilerPage, &IID_IVCResourceCompilerPage, &LIBID_VCProjectEnginePrivateLibrary, PrivateProjBuildTypeLibNumber,0, CVsTypeInfoHolder>::Invoke( dispid, riid, lcid, wFlags, pdispParams, pvarResult, pexcepInfo, puArgErr );
		return S_OK;
	}


// IPerPropertyBrowsing methods
public:
	STDMETHOD(GetDisplayString)( DISPID dispID, BSTR *pBstr );

// IVCResourceCompilerPage
public:
	STDMETHOD(get_AdditionalOptions)(BSTR* pbstrAdditionalOptions);
	STDMETHOD(put_AdditionalOptions)(BSTR bstrAdditionalOptions);
	STDMETHOD(get_PreprocessorDefinitions)(BSTR* pbstrDefines);
	STDMETHOD(put_PreprocessorDefinitions)(BSTR bstrDefines);
	STDMETHOD(get_Culture)(enumResourceLangID* pnLangID);
	STDMETHOD(put_Culture)(enumResourceLangID nLangID);
	STDMETHOD(get_AdditionalIncludeDirectories)(BSTR* pbstrIncludePath);
	STDMETHOD(put_AdditionalIncludeDirectories)(BSTR bstrIncludePath);
	STDMETHOD(get_IgnoreStandardIncludePath)(enumIgnoreStandardIncludePathBOOL* pbIgnoreInclPath);
	STDMETHOD(put_IgnoreStandardIncludePath)(enumIgnoreStandardIncludePathBOOL bIgnoreInclPath);
	STDMETHOD(get_ShowProgress)(enumShowProgressBOOL* pbShowProgress);
	STDMETHOD(put_ShowProgress)(enumShowProgressBOOL bShowProgress);
	STDMETHOD(get_ResourceOutputFileName)(BSTR* pbstrResFile);
	STDMETHOD(put_ResourceOutputFileName)(BSTR bstrResFile);

// helpers
public:
	virtual void GetBaseDefault(long id, CComVariant& varValue);
	virtual void GetLocalizedName(DISPID dispID, MEMBERID memid, ITypeInfo2* pTypeInfo2Enum, long lVal, CComBSTR& bstrDoc);
	virtual BOOL UseDirectoryPickerDialog(long id) { return (id == VCRCID_AdditionalIncludeDirectories); }
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\vcpb\propcontainer.cpp ===
//////////////////////////////////////////////////////////////////
// Basic property container base class

#include "stdafx.h"
#include "propcontainer.h"
#include "buildengine.h"
#include "settingspage.h"

HRESULT CPropertyContainerImpl::DoSetProp(long id, BOOL bCheckSpecial, VARIANT varValue, long nOverrideID /* = -1 */)
{
	if (CheckCanDirty())
	{
		CHECK_OK_TO_DIRTY(id);
	}
	m_PropMap.SetAt(id, varValue);
	return FinishSetPropOrClear(id, nOverrideID);
}

HRESULT CPropertyContainerImpl::FinishSetPropOrClear(long id, long nOverride)
{
	return S_OK;	// this method is only for handling side effects of dirtying properties
}

STDMETHODIMP CPropertyContainerImpl::SetProp(long id, VARIANT varValue)
{
	return DoSetProp(id, TRUE, varValue);
}

HRESULT CPropertyContainerImpl::DoGetProp(long id, BOOL bCheckSpecialProps, VARIANT* pVarValue)
{
	CHECK_POINTER_NULL(pVarValue);

	// Check if it's here
	HRESULT hr = DoGetLocalProp(id, bCheckSpecialProps, pVarValue);
	if (hr != S_FALSE)
		return hr;

	// It's not here, so check your parents
	return DoGetParentProp(id, VARIANT_TRUE /* allow inherit */, bCheckSpecialProps, pVarValue);
}

HRESULT CPropertyContainerImpl::DoGetParentProp(long id, VARIANT_BOOL bAllowInherit, BOOL bCheckSpecialProps, VARIANT* pVarValue)
{
	// for a standard property container, always inherit when doing GetParentProp...
	CHECK_POINTER_NULL(pVarValue);

	long lcItems = m_rgParents.GetSize();
	for (long index = 0; index < lcItems; index++)
	{
		CComPtr<IVCPropertyContainer> pParent;
		pParent = m_rgParents.GetAt(index);
		if (pParent)
		{
			CComPtr<IVCStagedPropertyContainer> spStagedParent;
			pParent->GetStagedPropertyContainer(VARIANT_FALSE, &spStagedParent);
			if (spStagedParent)
			{
				CComQIPtr<IVCPropertyContainer> spPropContainer = spStagedParent;
				if (spPropContainer)
				{
					if (spPropContainer->GetProp(id, pVarValue) == S_OK)
						return S_OK;
					else
						return S_FALSE;
				}
			}
			if (pParent->GetProp(id, pVarValue) == S_OK)
				return S_OK;
		}
	}

	// We didn't find it
	return S_FALSE;  
}

STDMETHODIMP CPropertyContainerImpl::GetParentProp(long id, VARIANT_BOOL bAllowInherit, VARIANT *pvarValue)
{
	return DoGetParentProp(id, bAllowInherit, TRUE, pvarValue);
}

STDMETHODIMP CPropertyContainerImpl::GetProp(long id, VARIANT *pVarValue)
{
	return DoGetProp(id, TRUE, pVarValue);
}

STDMETHODIMP CPropertyContainerImpl::GetMultiProp(long id, LPCOLESTR szSeparator, VARIANT_BOOL bSkipLocal, BSTR *pbstrValue)
{
	CHECK_POINTER_NULL(pbstrValue);
	*pbstrValue = NULL;

	CComBSTR bstrLocal, bstrParent;
	HRESULT hrReturn = S_FALSE;
	
	if (!bSkipLocal)
	{
		// look in here.
		CComVariant var;
		BOOL b;
		b = m_PropMap.Lookup(id, var);
		if( b )
		{
			if (NoInheritOnMultiProp(var.bstrVal, szSeparator, pbstrValue))
				return S_OK;	// means we're not doing inheritance
			bstrLocal = var.bstrVal;
			hrReturn = S_OK;
		}
	}
	
	// And check your parents
	long lcItems = m_rgParents.GetSize();
	bool bNeedSeparator = false;
	for (long index = 0; index < lcItems; index++)
	{
		CComPtr<IVCPropertyContainer> pParent;
		pParent = m_rgParents.GetAt(index);
		CComBSTR bstr;
		if (pParent != NULL)
		{
			HRESULT hr = pParent->GetMultiProp(id, szSeparator, VARIANT_FALSE, &bstr);
			if( hr == S_OK )
			{
				hrReturn = S_OK;
				if (!bNeedSeparator)
					bNeedSeparator = (bstrParent.Length() > 0);
				if (bNeedSeparator && bstr.Length() > 0)
				{
					CStringW strTmp = szSeparator;
					if (strTmp.GetLength() > 1)
					{
						strTmp = strTmp.Left(1);
						CComBSTR bstrTmp = strTmp;
						bstrParent.Append(bstrTmp);
					}
					else
						bstrParent.Append(szSeparator);
				}
				bstrParent.Append(bstr);
			}
		}
	}

	if (hrReturn != S_OK)
		return hrReturn;

	return MakeMultiPropString(bstrLocal, bstrParent, szSeparator, pbstrValue);
}

STDMETHODIMP CPropertyContainerImpl::GetEvaluatedMultiProp(long idProp, LPCOLESTR szSeparator, VARIANT_BOOL bCollapseMultiples, 
	VARIANT_BOOL bCaseSensitive, BSTR* pbstrValue)
{
	CHECK_POINTER_NULL(pbstrValue);
	*pbstrValue = NULL;

	HRESULT hr1 = GetMultiProp(idProp, szSeparator, VARIANT_FALSE, pbstrValue);
	RETURN_ON_FAIL(hr1);

	HRESULT hr2 = Evaluate(*pbstrValue, pbstrValue);
	RETURN_ON_FAIL(hr2);

	if (bCollapseMultiples)
	{
		HRESULT hr3 = CollapseMultiples(*pbstrValue, szSeparator, bCaseSensitive, pbstrValue);
		RETURN_ON_FAIL(hr3);
	}

	return hr1;
}

STDMETHODIMP CPropertyContainerImpl::IsMultiProp(long id, VARIANT_BOOL* pbIsMultiProp)
{
	CHECK_POINTER_NULL(pbIsMultiProp);
	*pbIsMultiProp = VARIANT_FALSE;
	return S_FALSE;
}

STDMETHODIMP CPropertyContainerImpl::GetMultiPropSeparator(long id, BSTR* pbstrPreferred, BSTR* pbstrAll)
{
	CHECK_POINTER_NULL(pbstrPreferred);
	CHECK_POINTER_NULL(pbstrAll);
	*pbstrPreferred = NULL;
	*pbstrAll = NULL;
	return S_FALSE;
}

HRESULT CPropertyContainerImpl::DoGetStrProperty(long idProp, BOOL bSpecialPropsOnly, BSTR* pbstrValue)
{
	CHECK_POINTER_NULL(pbstrValue);
	CComVariant var;
	HRESULT hr = DoGetProp(idProp, FALSE, &var);
	if (hr == S_OK)
	{
		if (var.vt != VT_BSTR)	// if it is not a BSTR, then we really didn't get the property no matter WHAT DoGetProp says...
			return S_FALSE;

		CComBSTR bstrVal = var.bstrVal;
		if (bstrVal.Length() > 0)
			*pbstrValue = bstrVal.Detach();
	}

	return hr;
}

STDMETHODIMP CPropertyContainerImpl::GetStrProperty(long idProp, BSTR* pbstrValue)
{
	return DoGetStrProperty(idProp, FALSE, pbstrValue);
}

HRESULT CPropertyContainerImpl::DoSetStrProperty(long idProp, BOOL bCheckSpecial, BSTR bstrValue, long nOverrideID /* = -1 */)
{
	CComVariant var;
	var = bstrValue;	// vt set properly during this assignment
	return DoSetProp(idProp, FALSE, var, nOverrideID);
}

STDMETHODIMP CPropertyContainerImpl::SetStrProperty(long idProp, BSTR bstrValue)
{
	return DoSetStrProperty(idProp, TRUE, bstrValue);
}

STDMETHODIMP CPropertyContainerImpl::GetEvaluatedStrProperty(long idProp, BSTR* pbstrValue)
{
	CHECK_POINTER_NULL(pbstrValue);
	*pbstrValue = NULL;

	HRESULT hr1 = GetStrProperty(idProp, pbstrValue);
	RETURN_ON_FAIL(hr1);

	HRESULT hr2 = EvaluateWithValidation(*pbstrValue, idProp, pbstrValue);
	RETURN_ON_FAIL(hr2);

	return hr1;
}

STDMETHODIMP CPropertyContainerImpl::Evaluate(BSTR bstrIn, BSTR *pbstrOut)
{
	CHECK_POINTER_NULL(pbstrOut);
	return ExpandMacros(pbstrOut, bstrIn, this, FALSE);
}

STDMETHODIMP CPropertyContainerImpl::EvaluateWithValidation(BSTR bstrIn, long idProp, BSTR* pbstrOut)
{
	CHECK_POINTER_NULL(pbstrOut);
	return ExpandMacros(pbstrOut, bstrIn, this, FALSE, idProp);
}

HRESULT CPropertyContainerImpl::DoGetIntProperty(long idProp, BOOL bCheckSpecial, long* pnValue)
{
	CHECK_POINTER_NULL(pnValue);
	*pnValue = 0;

	CComVariant var;
	HRESULT hr = DoGetProp(idProp, bCheckSpecial, &var);
	if (hr == S_OK)
		*pnValue = var.intVal;
	return hr;
}

STDMETHODIMP CPropertyContainerImpl::GetIntProperty(long idProp, long* pnValue)
{
	return DoGetIntProperty(idProp, TRUE, pnValue);
}

HRESULT CPropertyContainerImpl::GetParentIntProperty(long idProp, long* pnValue)
{
	CHECK_POINTER_NULL(pnValue);
	*pnValue = 0;

	CComVariant var;
	HRESULT hr = DoGetParentProp(idProp, VARIANT_TRUE /* allow inherit */, TRUE, &var);
	if (hr == S_OK)
		*pnValue = var.intVal;

	return hr;
}

HRESULT CPropertyContainerImpl::GetLocalIntProperty(long idProp, long* pnValue)
{
	CHECK_POINTER_NULL(pnValue);
	*pnValue = 0;

	CComVariant var;
	HRESULT hr = DoGetLocalProp(idProp, TRUE, &var);
	if (hr == S_OK)
		*pnValue = var.intVal;

	return hr;
}

HRESULT CPropertyContainerImpl::DoSetIntProperty(long idProp, BOOL bCheckSpecial, long nValue, long nOverrideID /* = -1 */)
{
	CComVariant var(nValue);
	return DoSetProp(idProp, FALSE, var, nOverrideID);
}

STDMETHODIMP CPropertyContainerImpl::SetIntProperty(long idProp, long nValue)
{
	return DoSetIntProperty(idProp, TRUE, nValue);
}

HRESULT CPropertyContainerImpl::DoGetBoolProperty(long idProp, BOOL bCheckSpecial, VARIANT_BOOL* pbValue)
{
	CHECK_POINTER_NULL(pbValue);
	*pbValue = VARIANT_FALSE;

	CComVariant var;
	HRESULT hr = GetProp(idProp, &var);
	if (hr == S_OK)
		*pbValue = var.boolVal;
	return hr;
}

STDMETHODIMP CPropertyContainerImpl::GetBoolProperty(long idProp, VARIANT_BOOL* pbValue)
{
	return DoGetBoolProperty(idProp, TRUE, pbValue);
}

HRESULT CPropertyContainerImpl::DoSetBoolProperty(long idProp, BOOL bCheckSpecial, VARIANT_BOOL bValue, long nOverrideID /* = -1 */)
{
	CComVariant var(bValue);
	return DoSetProp(idProp, bCheckSpecial, var, nOverrideID);
}

STDMETHODIMP CPropertyContainerImpl::SetBoolProperty(long idProp, VARIANT_BOOL bValue)
{
	return DoSetBoolProperty(idProp, TRUE, bValue);
}

HRESULT CPropertyContainerImpl::DoClear(long id, long nOverrideID /* = -1 */)
{
	m_PropMap.RemoveKey(id);
	return FinishSetPropOrClear(id, nOverrideID);
}

STDMETHODIMP CPropertyContainerImpl::Clear(long id)
{
	return DoClear(id);
}

HRESULT CPropertyContainerImpl::DoGetLocalProp(long id, BOOL bCheckSpecial, VARIANT *pvarValue)
{
	CComVariant varVal;

	// Check if it's here first
	if( m_PropMap.Lookup(id, varVal) )
	{
		if(pvarValue)
			varVal.Detach(pvarValue);
		return S_OK;
	}

	return S_FALSE;
}

STDMETHODIMP CPropertyContainerImpl::GetLocalProp(long id, VARIANT *pvarValue)
{
	return DoGetLocalProp(id, TRUE, pvarValue);
}

HRESULT CPropertyContainerImpl::DoClearAll()
{
	CHECK_OK_TO_DIRTY(0);

	// this loop allows the property container to handle side effects of dirtying the props that got cleared
	VCPOSITION pos = m_PropMap.GetStartPosition();
	while (pos != NULL)
	{
		long id;
		CComVariant var;
		m_PropMap.GetNextAssoc(pos, id, var);
		FinishSetPropOrClear(id, GetOverrideID(id));
	}

	m_PropMap.RemoveAll();
	return S_OK;
}

STDMETHODIMP CPropertyContainerImpl::ClearAll()
{
	return DoClearAll();
}

STDMETHODIMP CPropertyContainerImpl::GetStagedPropertyContainer(VARIANT_BOOL bCreateIfNecessary, IVCStagedPropertyContainer** ppPropContainer)
{
	CHECK_POINTER_NULL(ppPropContainer);

	if (!m_spStagedContainer)
	{
		if (bCreateIfNecessary)
		{
			HRESULT hr = CVCStagedPropertyContainer::CreateInstance(this, &m_spStagedContainer);
			RETURN_ON_FAIL(hr);
		}
		else
		{
			*ppPropContainer = NULL;
			return S_OK;
		}
	}

	return m_spStagedContainer.CopyTo(ppPropContainer);
}

STDMETHODIMP CPropertyContainerImpl::ReleaseStagedPropertyContainer()		// intended for use ONLY by the staged property container itself
{
	if (m_spStagedContainer)
	{
		m_spStagedContainer->Close();
		m_spStagedContainer.Release();
	}

	return S_OK;
}

HRESULT CPropertyContainerImpl::FinishClose()
{
	if (m_spStagedContainer)
		m_spStagedContainer->Close();
	m_spStagedContainer.Release();
	m_rgParents.RemoveAll();
	return S_OK;
}

STDMETHODIMP CPropertyContainerImpl::HasLocalStorage(VARIANT_BOOL bForSave, VARIANT_BOOL* pbHasLocalStorage)
{
	CHECK_POINTER_NULL(pbHasLocalStorage);
	*pbHasLocalStorage = VARIANT_TRUE;	// always have storage at this level; override when this isn't the case
	return S_OK;
}
/* static */
HRESULT CPropertyContainerImpl::WritePropertyToStream(IStream *pStream, VARIANT_BOOL bProp, DISPID dispid)
{
	ULONG iByteCount;
	VARTYPE type = VT_BOOL;

	//Write out type
	HRESULT hr = pStream->Write(&type, sizeof(VARTYPE), &iByteCount);
	RETURN_ON_FAIL(hr);

	//Write dispid
	hr = pStream->Write(&dispid, sizeof(DISPID), &iByteCount);
	RETURN_ON_FAIL(hr);

	//Write out bool
	hr = pStream->Write(&bProp, sizeof(VARIANT_BOOL), &iByteCount);
	RETURN_ON_FAIL(hr);

	return S_OK;
}

/* static */
HRESULT CPropertyContainerImpl::WritePropertyToStream(IStream *pStream, CComBSTR& bstrProp, DISPID dispid)
{
	ULONG iByteCount;
	VARTYPE type = VT_BSTR;

	//Write out type
	HRESULT hr = pStream->Write(&type, sizeof(VARTYPE), &iByteCount);
	RETURN_ON_FAIL(hr);

	//Write dispid
	hr = pStream->Write(&dispid, sizeof(DISPID), &iByteCount);
	RETURN_ON_FAIL(hr);

	//Write out bstr property
	hr = bstrProp.WriteToStream(pStream);
	RETURN_ON_FAIL(hr);
	
	return S_OK;
}

/* static */
HRESULT CPropertyContainerImpl::WritePropertyToStream(IStream *pStream, long lProp, DISPID dispid)
{
	ULONG iByteCount;
	VARTYPE type = VT_I4;

	//Write out type
	HRESULT hr = pStream->Write(&type, sizeof(VARTYPE), &iByteCount);
	RETURN_ON_FAIL(hr);

	//Write dispid
	hr = pStream->Write(&dispid, sizeof(DISPID), &iByteCount);
	RETURN_ON_FAIL(hr);

	//Write out remote bool
	hr = pStream->Write(&lProp, sizeof(long), &iByteCount);
	RETURN_ON_FAIL(hr);

	return S_OK;

}

/* static */
HRESULT CPropertyContainerImpl::WritePropertyToStream(IStream *pStream, CComVariant& variantProp, DISPID dispid)
{
	ULONG iByteCount;
	VARTYPE type = VT_VARIANT;

	//Write out type
	HRESULT hr = pStream->Write(&type, sizeof(VARTYPE), &iByteCount);
	RETURN_ON_FAIL(hr);

	//Write dispid
	hr = pStream->Write(&dispid, sizeof(DISPID), &iByteCount);
	RETURN_ON_FAIL(hr);

	//Write out variant
	hr = variantProp.WriteToStream(pStream);
	RETURN_ON_FAIL(hr);

	return S_OK;
}

HRESULT CPropertyContainerImpl::DoGetVCProjectEngine(IDispatch** ppProjEngine)
{
	CHECK_POINTER_VALID(ppProjEngine);	// we're providing a single source implementation for automation here...
	RETURN_ON_NULL(g_pProjectEngine);
	return g_pProjectEngine->QueryInterface(IID_IDispatch, (void **)ppProjEngine);
}

HRESULT CVCStagedPropertyContainer::CreateInstance(IVCPropertyContainer* pParentPropContainer, 
	IVCStagedPropertyContainer **ppStagedPropertyContainer)
{
	CVCStagedPropertyContainer *pVar;
	CComObject<CVCStagedPropertyContainer> *pObj;
	HRESULT hr = CComObject<CVCStagedPropertyContainer>::CreateInstance(&pObj);
	if (SUCCEEDED(hr))
	{
		pVar = pObj;
		pVar->AddRef();
		*ppStagedPropertyContainer = pVar;
		hr = pVar->Initialize(pParentPropContainer);
	}
	return hr;
}

HRESULT CVCStagedPropertyContainer::Initialize(IVCPropertyContainer* pParentPropContainer)
{
	m_spParentPropContainer = pParentPropContainer;
	return (m_spParentPropContainer ? S_OK : E_UNEXPECTED);
}

HRESULT CVCStagedPropertyContainer::DoGetParentProp(long id, VARIANT_BOOL bAllowInherit, BOOL bCheckSpecialProps, VARIANT* pVarValue)
{
	CHECK_POINTER_NULL(pVarValue);
	RETURN_ON_NULL2(m_spParentPropContainer, S_FALSE);

	if (bAllowInherit)
	{
		if (m_spParentPropContainer->GetProp(id, pVarValue) == S_OK )
			return S_OK;
	}
	else
	{
		if (m_spParentPropContainer->GetLocalProp(id, pVarValue) == S_OK )
			return S_OK;
	}

	// We didn't find it
	return S_FALSE;  
}

STDMETHODIMP CVCStagedPropertyContainer::GetMultiProp(long id, LPCOLESTR szSeparator, VARIANT_BOOL bSkipLocal, BSTR *pbstrValue)
{
	CHECK_POINTER_NULL(pbstrValue);
	*pbstrValue = NULL;

	CComBSTR bstrLocal, bstrParent;
	HRESULT hrReturn = S_FALSE;
	
	if (!bSkipLocal)
	{
		// look in here.
		CComVariant var;
		BOOL b;
		b = m_PropMap.Lookup(id, var);
		if( b )
		{
			if (NoInheritOnMultiProp(var.bstrVal, szSeparator, pbstrValue))
				return S_OK;	// means we're not doing inheritance
			bstrLocal = var.bstrVal;
			hrReturn = S_OK;
		}
		else if (m_spParentPropContainer)
		{
			HRESULT hr = m_spParentPropContainer->GetLocalProp(id, &var);
			if (hr == S_OK)
			{
				if (NoInheritOnMultiProp(var.bstrVal, szSeparator, pbstrValue))
					return S_OK;	// means we're not doing inheritance
				bstrLocal = var.bstrVal;
				hrReturn = S_OK;
			}
		}
	}
	
	// And check your parents
	if (m_spParentPropContainer && 
		m_spParentPropContainer->GetMultiProp(id, szSeparator, VARIANT_TRUE, &bstrParent) == S_OK)
		hrReturn = S_OK;

	if (hrReturn != S_OK)
		return hrReturn;

	return MakeMultiPropString(bstrLocal, bstrParent, szSeparator, pbstrValue);
}

STDMETHODIMP CVCStagedPropertyContainer::GetMultiPropSeparator(long id, BSTR* pbstrPreferred, BSTR* pbstrAll)
{
	if (m_spParentPropContainer)
		return m_spParentPropContainer->GetMultiPropSeparator(id, pbstrPreferred, pbstrAll);

	// no parent?  make an educated guess
	CHECK_POINTER_NULL(pbstrPreferred);
	CHECK_POINTER_NULL(pbstrAll);
	CComBSTR bstrPreferred = L";";
	CComBSTR bstrAll = L";,";
	*pbstrPreferred = bstrPreferred.Detach();
	*pbstrAll = bstrAll.Detach();
	return S_OK;
}

STDMETHODIMP CVCStagedPropertyContainer::ClearPropertyRange(long nMinID, long nMaxID)
{
	VCPOSITION pos = m_PropMap.GetStartPosition();
	while (pos)
	{
		long key;
		CComVariant varVal;
		m_PropMap.GetNextAssoc(pos, key, varVal);
		if (key >= nMinID && key <= nMaxID)
			m_PropMap.RemoveKey(key);
	}

	return S_OK;
}

STDMETHODIMP CVCStagedPropertyContainer::get_Parent(IVCPropertyContainer** ppParent)
{
	CHECK_POINTER_NULL(ppParent);
	return m_spParentPropContainer.CopyTo(ppParent);
}

STDMETHODIMP CVCStagedPropertyContainer::GetGrandParentProp(long id, VARIANT *pvarValue)		// skip to parent of our non-staged parent
{
	CHECK_ZOMBIE(m_spParentPropContainer, IDS_ERR_CFG_ZOMBIE);
	return m_spParentPropContainer->GetParentProp(id, VARIANT_TRUE /* allow inherit */, pvarValue);
}

STDMETHODIMP CVCStagedPropertyContainer::Close()
{
	m_spParentPropContainer.Release();
	return S_OK;
}

STDMETHODIMP CVCStagedPropertyContainer::CommitPropertyRange(long nMinID, long nMaxID)
{
	return DoCommitPropertyRange(nMinID, nMaxID, false);
}

STDMETHODIMP CVCStagedPropertyContainer::Commit()
{
	return DoCommitPropertyRange(0, 0, true);
}

HRESULT CVCStagedPropertyContainer::DoCommitPropertyRange(long nMinID, long nMaxID, bool bIgnoreRange)
{
	CHECK_ZOMBIE(m_spParentPropContainer, IDS_ERR_CFG_ZOMBIE);

	VCPOSITION iter = m_PropMap.GetStartPosition();
	// iterate over each item in the map
	HRESULT hr = S_OK;
	while( iter && SUCCEEDED(hr))
	{
		long key;
		CComVariant varVal;
		m_PropMap.GetNextAssoc(iter, key, varVal);

		if (!bIgnoreRange && (key < nMinID || key > nMaxID))
			continue;

		BOOL bSetProp = TRUE;
		if ((varVal.vt == VT_I4 && varVal.intVal == INHERIT_PROP_VALUE) || 
			(varVal.vt == VT_I2 && varVal.iVal == INHERIT_PROP_VALUE) || 
			(varVal.vt == VT_BSTR && wcscmp( L"-2", varVal.bstrVal ) == 0))
			bSetProp = FALSE;
		else if (varVal.vt == VT_BSTR && SysStringLen( varVal.bstrVal ) == 0 )
		{
			VARIANT_BOOL bIsMulti = VARIANT_FALSE;
			if (m_spParentPropContainer->IsMultiProp(key, &bIsMulti) != S_OK || bIsMulti == VARIANT_TRUE)
				bSetProp = FALSE;
		}
		if (bSetProp)
			hr = m_spParentPropContainer->SetProp(key, varVal);
		else
			hr = m_spParentPropContainer->Clear(key);
		RETURN_ON_FAIL(hr);
		m_PropMap.RemoveKey(key);
	}

	return S_OK;
}

STDMETHODIMP CVCStagedPropertyContainer::NextElement(long* pKey, VARIANT* pVal)
{
	CHECK_POINTER_NULL(pKey);
	*pKey = 0;
	CHECK_POINTER_NULL(pVal);
	pVal->vt = VT_EMPTY;
	RETURN_ON_NULL2(m_pos, S_FALSE);

	long id;
	CComVariant var;
	m_PropMap.GetNextAssoc(m_pos, id, var);
	*pKey = id;
	var.Detach(pVal);

	return S_OK;
}

STDMETHODIMP CVCStagedPropertyContainer::Reset(void)
{
	m_pos = m_PropMap.GetStartPosition();
	return S_OK;
}

STDMETHODIMP CVCStagedPropertyContainer::HasDefaultValue(DISPID dispid, BOOL *pfDefault)
{
	CHECK_POINTER_NULL(pfDefault);
	*pfDefault = FALSE;
	
	// Check if its here and not clear
	CComVariant varVal;
	if( m_PropMap.Lookup(dispid, varVal) )
	{
		if( (varVal.vt == VT_I4 && varVal.intVal == INHERIT_PROP_VALUE) || (varVal.vt == VT_I2 && varVal.iVal == INHERIT_PROP_VALUE) || (varVal.vt == VT_BSTR && wcscmp( L"-2", varVal.bstrVal ) == 0) )
			*pfDefault = TRUE;
		return S_OK;
	}

	// OK so is it in the parent ?
	if (!m_spParentPropContainer || m_spParentPropContainer->GetLocalProp( dispid, NULL ) != S_OK)
		*pfDefault = TRUE;

	return S_OK;
}

STDMETHODIMP CVCStagedPropertyContainer::HoldStagedContainer()			// number of calls to Hold/Release StagedContainer need to match
{
	m_cStaged++;
	return S_OK;
}

STDMETHODIMP CVCStagedPropertyContainer::ReleaseStagedContainer()		// number of calls to Hold/Release StagedContainer need to match
{
	if (m_cStaged > 0)
		m_cStaged--;
	if (m_cStaged == 0 && m_spParentPropContainer)
		m_spParentPropContainer->ReleaseStagedPropertyContainer();

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\vcpb\regscan.h ===
// RegScan.h

#define _MAX_REG_BUFFER (4095)
class CRegistryScanner
{
// Construction
public:
	CRegistryScanner();
	~CRegistryScanner();

// Operations
public:
	BOOL Open(HKEY hKey, BSTR bstrSubKey);
	void Close();

	BOOL EnumKey(BSTR *strKeyName);

	BOOL GetValue(BSTR bstrKey, BSTR *rValue);
	BOOL QueryStringValue(BSTR bstrValueName, CStringW& rstrValue) throw();

// Attributes
public:
	HKEY m_hKeyRoot;
	DWORD m_iSubKey;
	CComBSTR m_bstrKey;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\vcpb\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by vcpb.rc
//
#define IDR_VCPROJECTENGINE             101
#define IDR_PLATFORM_WIN64              102
#define IDR_PLATFORM_XBOX               103

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           103
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\vcpb\scanner.cpp ===
//
// <Scanner Classes>
// SYSINCL.dat processing and manual #include scanner
//				   

#include "stdafx.h"
#pragma hdrstop

#include <shlobj.h>
#include <profile.h>	// registry info
#include <register.h>
#include "util2.h"

#include "scanner.h"	// local header
#include "mrdependencies.h"
#include "buildengine.h"

#define	OPENFAST 	2
#define	OPENSLOW 	1
#define	NOTOPEN 	0

void StripQuotes(LPCOLESTR szFilePath, LPOLESTR szBuffer, long nMaxLen);
int GetFileFullPath(wchar_t* pstrInclude, wchar_t *pBase, IVCBuildableItem* pItem, wchar_t *buf, 
	CStringW& strOptionPath, const wchar_t* szPlatDirs, BOOL bIsIncludeNotLib, const CDirW& dirProj);

///////////////////////////////////////////////////////////////////////////////
//
// -------------------------------- CBldScannerCache --------------------------
//
///////////////////////////////////////////////////////////////////////////////

void CBldScannerCache::Add(BldFileRegHandle frh, CBldIncludeEntryList* pAddedList)
{
#ifdef _DEBUG
	void *vp;
	VSASSERT(!m_EntryMap.Lookup((void *) frh, vp), "Trying to add something to the cache that is already there");
#endif

	m_EntryMap.SetAt((void *)frh, (void *)pAddedList);

}

///////////////////////////////////////////////////////////////////////////////
CBldIncludeEntryList* CBldScannerCache::LookupFile(BldFileRegHandle frh)
{
	CBldIncludeEntryList* pList;
	if (m_EntryMap.Lookup((void *) frh, (void*&) pList))
			return pList;

	return NULL;
}

CBldScannerCache::~CBldScannerCache ()
{
	VSASSERT(m_EntryMap.IsEmpty(), "Failed to empty scanner cache before destruction.  Anything left will leak.");
	Clear();

};

int CBldScannerCache::BeginCache()
{
	if (!m_nBeginCount++)
	{
		// olympus 1277 (briancr)
		// Now clear the caches when m_nBeginCount is zero.
		// One bug that resulted from the caches *not* being cleared is this:
		// After updating dependencies and getting a missing dep error
		// (no .h file), creating the .h file, and updating deps again,
		// the error was still reported to the user.
		// After updating deps the first time (and clearing the caches in
		// EndCache), the parser reparses all files and, as a side effect,
		// fills the caches again. After creating the .h file (the parser
		// doesn't reparse), we assume that since the parser tells us (via
		// the caches) the file doesn't exist that it doesn't and report this
		// to the user. Note, that we later find that the file does exist and
		// update the Dep folder correctly (as well as subsequent dep scans).
		VSASSERT(m_EntryMap.GetStartPosition() == NULL, "Scanner cache should be empty at this point");
		Clear();
	}
	return ++m_nUniqueNo;
}

void CBldScannerCache::EndCache()
{
	// See comments in BeginCache.
	if (!--m_nBeginCount)
		Clear();
}

static void ClearMapHelper(CVCMapStringWToPtr* pmap)
{
	CStringW strTemp;
	BldFileRegHandle frh = NULL;
	VSASSERT(NULL != pmap, "Passed in NULL pointer to get the scanner cache map.  Bad programmer, bad programmer.");
	VCPOSITION pos = pmap->GetStartPosition();

	while (pos != NULL)
	{
		pmap->GetNextAssoc(pos, strTemp, (void*&)frh);
		VSASSERT(NULL != frh, "Bad file name/reg handle pair in the scanner cache");
		frh->ReleaseFRHRef();
	}
	pmap->RemoveAll();
}

void CBldScannerCache::Clear()
{
	CBldIncludeEntryList* pList;
	BldFileRegHandle frh;

	for (VCPOSITION pos = m_EntryMap.GetStartPosition (); pos != NULL; )
	{
		m_EntryMap.GetNextAssoc(pos, (void *&)frh, (void *&)pList);

		if (pList == (CBldIncludeEntryList *)-1 ) 
			continue;	// A null entry

		delete (pList);       
	}

	m_EntryMap.RemoveAll();		

	ClearMapHelper(&m_AbsCache);
	ClearMapHelper(&m_OrigCache);
	m_NotOrigCache.RemoveAll();		// No references
	ClearMapHelper(&m_ParentCache);
	m_NotParentCache.RemoveAll();	// No references
	ClearMapHelper(&m_IncludeCache);
}

///////////////////////////////////////////////////////////////////////////////
//
// ------------------------------- CBldSysInclReg -----------------------------
//
///////////////////////////////////////////////////////////////////////////////

BOOL CBldSysInclReg::IsSysInclude(CStringW& strFile, BOOL bUseSlowerCompare )
{
	static CStringW strSingleDir;
	static int nSingleLen = 0;

	VCPOSITION pos;

	if (m_nLoadState == NOTOPEN )
	{
		if (!DoLoad())
		{
			ATLTRACE("Loading sys include registry failed!\n");
		}

		if( m_nLoadState == OPENFAST )
		{
			// There should be only 1 entry on the list. Use the speedy algorithm.
			pos = m_dirList.GetHeadPosition();
			strSingleDir = m_dirList.GetNext(pos);
			nSingleLen = strSingleDir.GetLength();
		}
	}

	if( m_nLoadState == OPENFAST )
	{
		if( bUseSlowerCompare )
		{
			if( !wcsnicmp(strFile,strSingleDir, nSingleLen) )
				return TRUE;
		}
		else
		{
			if( !wcsncmp(strFile,strSingleDir, nSingleLen) )
				return TRUE;
		}
	}
	else // m_nLoadState == OPENSLOW
	{
		pos = m_dirList.GetHeadPosition();
		while (pos)
		{
			CStringW strDir = m_dirList.GetNext(pos);
			int nLen = strDir.GetLength();
			if (nLen == 0)
				continue;
			if( bUseSlowerCompare )
			{
				if( !wcsnicmp(strFile,strDir, nLen) )
					return TRUE;
			}
			else
			{
				if( !wcsncmp(strFile,strDir, nLen) )
					return TRUE;
			}
		}
	}

	return FALSE;
}
	
///////////////////////////////////////////////////////////////////////////////
BOOL CBldSysInclReg::DoLoad()
{
	m_dirList.RemoveAll();
	m_nLoadState = OPENFAST; // 2 - use speedy compare algorithm.
							 // 1 - use slow compare algorithm.
							 // 0 - not not yet attempted.

	// First get the default system include directory
	CStringW strVCDir;
	UtilGetVCInstallFolder(strVCDir);

	strVCDir.MakeLower();
	m_dirList.AddHead(strVCDir);

	// Now try to Load the SysIncl.dat file; this is all ANSI since a bunch of the stuff below is ANSI-only
	CPathW pt;

	// Alt reg root is usually software\microsoft\visualstudio\7.0 .... and we need to remove the "software\\" part
	CStringW strAlt = CVCProjectEngine::s_bstrAlternateRegistryRoot;
	CStringW strSoftware = strAlt.Left(8);
	if( strSoftware.CompareNoCase(L"Software") == 0 )
	{
		strAlt = strAlt.Right(strAlt.GetLength()-8);
	}

	CComBSTR bstrAppData;
	HRESULT hr = GetAppDataDirW(&bstrAppData);
	CStringW strAppDataLocal = bstrAppData;
	strAppDataLocal += strAlt;
	strAppDataLocal += L"\\SysIncl.dat";
	
	if ( !pt.Create(strAppDataLocal) )
	{
		return FALSE;
	}

	// Find the file on disk and open it.
	FILE *pFile;
	if ((pFile = fopenW((const wchar_t *)pt, L"rt")) == NULL )
	{
		// Failed probably because dir didn't exist.
		CDirW  dr;
		dr.CreateFromPath(pt);
		dr.CreateOnDisk();

		if ((pFile = fopenW((const wchar_t *)pt, L"w")) != NULL)	// create it for next time
				fclose(pFile);

		return FALSE;  
	}

	// We've got the file open, now read it line by line
	BOOL bLeadByte = FALSE;
	char buf[MAX_PATH], *pb;
	while (1)
	{
    	// yes, ANSI -- this should be re-done
		// Things to worry about are the codepage of the file
		// and we should do the whole conversion at once, and then parse the UNICODE
		pb = buf;
		//	Read in a line up to, but not including the return:
		while (1)
		{
			int i;
			i = fgetc(pFile);	
			if (i == EOF || pb >= buf + MAX_PATH - 1 || (i == '\n' && !bLeadByte)) 
				break;
			*pb++ = (char)i;
			bLeadByte = bLeadByte ? FALSE : IsDBCSLeadByte((unsigned char)i);
		}
		*pb = '\0';
		if (ferror(pFile))
			break;
		// end of yes, ANSI section

		// clean up the string
		CStringW strName = buf;
		strName.MakeUpper();
		strName.TrimLeft();
		if (strName.IsEmpty())
		{
			if(feof(pFile))
				break;
			else
				continue;
		}

		// skip the comments  "#"
		if (strName[0] != L'#')
		{
			strName.TrimRight();
			CStringW strBuf = strName;
			strName.Empty();
			StripQuotes(strBuf, strName.GetBuffer(4096), 4096);
			strName.ReleaseBuffer();
			strName.MakeLower();

			// add it to our list of paths to return.
			// TODO: perf, if it is a sub dir of something already on the list, remove it
			m_dirList.AddHead((LPCOLESTR)strName);
			m_nLoadState = OPENSLOW; // use slower compare algorithm.
		}
	}

	int nVal1 = ferror(pFile);
	int nVal2 = fclose(pFile);
	if (nVal1 || nVal2)
		return FALSE;

	return TRUE;
}	

CBldSysInclReg g_SysInclReg;

///////////////////////////////////////////////////////////////////////////////
//
// --------------------------------- CBldIncludeEntry ----------------------------
//
///////////////////////////////////////////////////////////////////////////////

BOOL CBldIncludeEntry::CheckAbsolute()
{
//	See if this is a fully qualified path name.  We use the compiler's method
//	here.

	const wchar_t *pchr = m_FileReference;
	if (*pchr == L'/' || *pchr == L'\\' || *pchr == L':' || *(pchr + 1) == L':')
	{
		VSASSERT(*pchr != L':', "We managed to get a two character drive letter...");  // should never happen!!!
		m_EntryType = IncTypeCheckAbsolute;
		return TRUE;
	}

	return FALSE;
}	
///////////////////////////////////////////////////////////////////////////////
BOOL CBldIncludeEntry::FindFile(const wchar_t* lpszIncludePath, const CDirW& cdBaseDirectory, 
	const wchar_t* pchProjDirectory, BldFileRegHandle& frhResult, IVCBuildableItem* pItem, CBldScannerCache* pScannerCache,
	const wchar_t* szPlatDirs /* = NULL */)
{
//
//	Try to find our file based on m_Entry type.  Note that order is important here.
//
//	See CBldScannerCache in PROJTOOL.H for a description of how the caches work.

	VSASSERT(m_EntryType & (IncTypeCheckAbsolute | IncTypeCheckParentDir | IncTypeCheckIncludePath | IncTypeCheckLibPath), "Invalid entry type");

	BOOL fIsInclude = !(m_EntryType & IncTypeCheckLibPath);
	void* pvCache;
	CPathW Path;
	wchar_t buf[MAX_PATH];
	int iFound;
	CStringW strOptionPath, strRelative;
	CComPtr<VCConfiguration> spProjCfg;

	// Nullify the return param.
	frhResult = (BldFileRegHandle)NULL;

	CDirW dirProj;
	if (pchProjDirectory)
		dirProj.CreateFromKnown(pchProjDirectory);
	else
		dirProj.CreateFromCurrent();

	// Absolute means file name is right or else
	if (m_EntryType & IncTypeCheckAbsolute)
	{
		if (pScannerCache && pScannerCache->m_AbsCache.Lookup((const wchar_t *)m_FileReference, pvCache))
		{
			frhResult = (BldFileRegHandle)pvCache;
				// frhResult reference
			frhResult->AddFRHRef();
			return TRUE;
		}
		else
		{
			if (GetFileAttributesW((wchar_t *)(const wchar_t *)m_FileReference) != 0xffffffff)
			{
				if (!Path.Create(m_FileReference))
					return FALSE;

				// frhResult reference
				frhResult = CBldFileRegFile::GetFileHandle(Path, TRUE);

				if (pScannerCache)
					pScannerCache->m_AbsCache.SetAt((const wchar_t *)m_FileReference, (void *)frhResult);
				// references in m_AbsCache.
				frhResult->AddFRHRef();
				return TRUE;
			}
		}
	}

	BOOL bGotIt;
	if (m_EntryType & IncTypeCheckOriginalDir)
	{
		bGotIt = ResolveToCache(m_OriginalDir, pScannerCache ? &(pScannerCache->m_OrigCache) : NULL, 
			pScannerCache ? &(pScannerCache->m_NotOrigCache) : NULL, pchProjDirectory, fIsInclude, pItem, buf, frhResult, 
			lpszIncludePath, szPlatDirs, false);
		if (bGotIt)
			return TRUE;
	}	

	if (m_EntryType & IncTypeCheckParentDir)
	{
		bGotIt = ResolveToCache(cdBaseDirectory, pScannerCache ? &(pScannerCache->m_ParentCache) : NULL, 
			pScannerCache ? &(pScannerCache->m_NotParentCache) : NULL, pchProjDirectory, fIsInclude, pItem, buf, frhResult, 
			lpszIncludePath, szPlatDirs, true);
		if (bGotIt)
			return TRUE;
	}	

	if (m_EntryType & IncTypeCheckIncludePath || m_EntryType & IncTypeCheckLibPath)
	{
		CStringW	strLookup;
		wchar_t*	pchLookup = strLookup.GetBuffer(lstrlenW(lpszIncludePath) + m_FileReference.GetLength() + 2);

		wcscpy(pchLookup, lpszIncludePath);
		wcscat(pchLookup, L"#");
		wcscat(pchLookup, (const wchar_t *)m_FileReference);

		if (pScannerCache && pScannerCache->m_IncludeCache.Lookup(pchLookup, pvCache))
		{
			frhResult = (BldFileRegHandle)pvCache;
			frhResult->AddFRHRef();
			return TRUE;
		}
		else
		{
			if ((iFound=GetFileFullPath((wchar_t *)lpszIncludePath, (wchar_t *)(LPCOLESTR)m_FileReference, 
				pItem, buf, strOptionPath, szPlatDirs, fIsInclude, dirProj)) != NOTFOUND)
			{
				BOOL fRet = FALSE;
				if (Path.Create(buf))
				{
					frhResult = CBldFileRegFile::GetFileHandle(Path, TRUE);
					CBldFileRegFile *pFile = (CBldFileRegFile*)g_FileRegistry.GetRegEntry(frhResult);

					if (pScannerCache)
						pScannerCache->m_IncludeCache.SetAt(pchLookup, (void *)frhResult);
					// references in m_IncludeCache.
					frhResult->AddFRHRef();
					if (iFound == ONPATH)
					{
						pFile->SetFileFoundInIncPath();
						if (m_FileReference.Find(L"..\\") != -1)
						{
							pFile->SetOrgName(m_FileReference);
							pFile->SetIndexNameRelative(0);
						}
						else
							pFile->SetIndexNameRelative((int)m_FileReference.GetLength());
					}
					else if (!pFile->IsFileFoundInIncPath())
					{
						// found on option path, should remember the option path
						// reset the m_OrgName to append this option path
						pFile->SetOrgName(strOptionPath);
						pFile->SetIndexNameRelative(0);
						pFile->SetFileNameRelativeToProj();
						const wchar_t *pchr = strOptionPath;
						if (*pchr == L'/' || *pchr == L'\\' || *pchr == L':' || *(pchr + 1) == L':')
						{
							VSASSERT(*pchr != L':', "Managed to get a two char drive letter...");  // should never happen!!!
							CDirW dr;
							dr.CreateFromKnown(pchProjDirectory);
							Path.GetRelativeName(dr, strRelative);

							if (strRelative.GetLength() < (strOptionPath.GetLength()-2))
							{
								// get relative path
								wchar_t *pch = (wchar_t *)(LPCOLESTR)strRelative;
								if (pch && *pch != L'.')
								{
									CStringW strTmp;
									if (*pch == L'\\')
										strTmp = L"." + strRelative;
									else if (*pch != L':')
										strTmp = L".\\" + strRelative;
									else
										VSASSERT(0, "Invalid case in building relative path name");	// Speed bug #3838
									strRelative = strTmp;
								}
								pFile->SetOrgName(strRelative);
							}
							pFile->SetOrgName(strRelative);
						}
					}
					fRet = TRUE;
				}
				return fRet;
			}
		}
	}

	// couldn't find the file so return our best guess
	BOOL fGotUnknown = FALSE, fMatchCase = FALSE;
	if (pItem != (IVCBuildableItem *)NULL &&
		(m_EntryType & IncTypeCheckIntDir) || (m_EntryType & IncTypeCheckOutDir))
	{
		CComQIPtr<IVCPropertyContainer> spPropContainer = pItem;
		if (spPropContainer != NULL)
		{
			// get the output directory
			CComBSTR bstrDirOut;
			HRESULT hr = S_OK;
			if (m_EntryType & IncTypeCheckIntDir)
				hr = spPropContainer->GetEvaluatedStrProperty(VCCFGID_IntermediateDirectory, &bstrDirOut);
			else
				hr = spPropContainer->GetEvaluatedStrProperty(VCCFGID_OutputDirectory, &bstrDirOut);
			if (SUCCEEDED(hr))
			{
				CCurDirW cwd(pchProjDirectory);	// just in case the output dir is relative...
				CStringW strdirOut;
				strdirOut = bstrDirOut;
				// is this empty or a directory?
				if (!strdirOut.IsEmpty())
				{
					const wchar_t* pchStart = strdirOut;
					const wchar_t* pchT;

					pchT = pchStart + wcslen(pchStart);	// point to nul terminator
					pchT = _wcsdec(pchStart, pchT);		// back up one char

					if (*pchT != L'\\' && *pchT != L'/')
					{
						strdirOut.ReleaseBuffer();
						strdirOut += L'/';
					}

					CDirW dirOut;
					if (dirOut.CreateFromString(strdirOut))
					{
						if (Path.CreateFromDirAndFilename(dirOut, m_FileReference))
						{
							fMatchCase = TRUE;
							fGotUnknown = TRUE;
						}
					}
				}
			}
		}	
	}

	if (!fGotUnknown && (m_EntryType & IncTypeCheckAbsolute))
	{
		if (Path.Create(m_FileReference))
		{
			fMatchCase = TRUE;
			fGotUnknown = TRUE;
		}
	}

	if (!fGotUnknown && (m_EntryType & IncTypeCheckOriginalDir))
	{
		if (Path.CreateFromDirAndFilename(m_OriginalDir, m_FileReference))
		{
			fMatchCase = TRUE;
			fGotUnknown = TRUE;
		}
	}	
	
	if (!fGotUnknown && (m_EntryType & IncTypeCheckParentDir))
	{
		if (Path.CreateFromDirAndFilename(cdBaseDirectory, m_FileReference))
		{
			fMatchCase = FALSE;
			fGotUnknown = TRUE;
		}
	}	

	if (fGotUnknown)
	{
		frhResult = CBldFileRegFile::GetFileHandle(Path, TRUE);
	}

	// shouldn't be scanned!
	m_bShouldBeScanned = FALSE;
	return FALSE;
}  

BOOL CBldIncludeEntry::ResolveToCache(const CDirW& baseDir, CVCMapStringWToPtr* pFoundCache, CVCMapStringWToPtr* pNotFoundCache, 
	const wchar_t* pchProjDirectory, BOOL fIsInclude, IVCBuildableItem* pItem, wchar_t* buf, BldFileRegHandle& frhResult, 
	const wchar_t* lpszIncludePath, const wchar_t* szPlatDirs, bool bRelativeToParent)
{
	CStringW	strLookup;
	wchar_t*	pchLookup = strLookup.GetBuffer(lstrlenW((const wchar_t *)baseDir) + m_FileReference.GetLength() + 2);
	wchar_t *pch;
	int ich, iFound;
	void* pvCache;
	CPathW Path;
	CStringW strOptionPath;

	wcscpy(pchLookup, (const wchar_t *)baseDir);
	wcscat(pchLookup, L"#");
	wcscat(pchLookup, (const wchar_t *)m_FileReference);

	if (pFoundCache && pFoundCache->Lookup(pchLookup, pvCache))
	{
		frhResult = (BldFileRegHandle)pvCache;
		frhResult->AddFRHRef();
		return TRUE;
	}
	else if (!pNotFoundCache || !pNotFoundCache->Lookup(pchLookup, pvCache))
	{
		if (!Path.CreateFromDirAndFilename(baseDir, m_FileReference))
			return FALSE;

		if (GetFileAttributesW((wchar_t *)(const wchar_t *) Path) != 0xffffffff)
		{
			frhResult = CBldFileRegFile::GetFileHandle(Path, TRUE);
			CBldFileRegFile *pFile = (CBldFileRegFile*)g_FileRegistry.GetRegEntry(frhResult);
			if (pFoundCache)
				pFoundCache->SetAt(pchLookup, (void *)frhResult);
			// references in foundCache.
			frhResult->AddFRHRef();
			Path.SetAlwaysRelative();     //like this to be relative to proj dir
			//we don't want to resolve relative path(with ..\) unless we have to
			//first, we should make sure to make everything under proj dir is proj dir relative 
			//if orignial dir is sub dir of the proj dir, convert the include name relative to 
			//proj dir, which means adding the sub dir for the include name
			//1) if the path is relative to proj dir, keep it that way
			//2) if the path is relative to include path, keep it that way
			//3) if we can resolve it on the include path, resolve it and keep the relative part
			//4) hey, it is illegal code if user wants a sharable makefile
			pch = (wchar_t *)Path.GetFullPath();
			if (m_FileReference.Find(L"..\\") != -1)
			{	
				//make sub trees relative to proj dir.
				CDirW dirProj;
				if (pchProjDirectory)
					dirProj.CreateFromKnown(pchProjDirectory);
				else
					dirProj.CreateFromCurrent();

				if (!bRelativeToParent && 
					((wcslen((wchar_t *)(const wchar_t *)baseDir) > wcslen(pchProjDirectory)) &&
					wcsnicmp((wchar_t *)(const wchar_t *)baseDir, pchProjDirectory, wcslen(pchProjDirectory))
					== 0))
				{
					CStringW strTmp;
					wchar_t* pchTmp = (wchar_t *)(const wchar_t *)baseDir;

					pchTmp += wcslen(pchProjDirectory)+1;
					strTmp = pchTmp;
					strTmp = strTmp + L"\\" + m_FileReference;

					if (pchProjDirectory && (GetFileFullPath((wchar_t *)pchProjDirectory, (wchar_t *)(LPCOLESTR)strTmp, pItem, buf, 
						strOptionPath, szPlatDirs, fIsInclude, dirProj) != NOTFOUND))
					{
						//yes, make the original name relative to proj
						pFile->SetOrgName(strTmp);
						pFile->SetFileNameRelativeToProj();
						pFile->SetIndexNameRelative(0);
					}
				}
				else if (pchProjDirectory && (GetFileFullPath((wchar_t *)pchProjDirectory, (wchar_t *)(LPCOLESTR)m_FileReference, 
					pItem, buf, strOptionPath, szPlatDirs, fIsInclude, dirProj) != NOTFOUND))
				{
					//first, can we make this relative to the project?
					//yes, let's keep the original name
					pFile->SetOrgName(m_FileReference);
					pFile->SetFileNameRelativeToProj();
					pFile->SetIndexNameRelative(0);
				}
				else
				{
					//we can't make it relative to proj, any luck with the path?
					if ((iFound = GetFileFullPath((wchar_t *)lpszIncludePath, (wchar_t *)(LPCOLESTR)m_FileReference, 
						pItem, buf, strOptionPath, szPlatDirs, fIsInclude, dirProj)) != NOTFOUND)
					{
						CBldFileRegFile* pFile2 = (bRelativeToParent) ? 
							(CBldFileRegFile*)(g_FileRegistry.GetRegEntry(frhResult)) : pFile;
						SetFilePathInfo(pFile, pFile2, 0, strOptionPath, pchProjDirectory, iFound, true);
					}
					else
					{
						//otherwise, see if resoved full path will be relative to the include path
						if ((iFound = SetFileRelativeFromPath((wchar_t *)lpszIncludePath, pch, frhResult, pItem, 
							&ich, strOptionPath, szPlatDirs, fIsInclude)) != NOTFOUND)
						{
							SetFilePathInfo(pFile, pFile, ich, strOptionPath, pchProjDirectory, iFound, false);
						}
						else
						{
							//stuck with the full path, live with it
						}
					}
				}
			}
			else
			{
				if (!bRelativeToParent)
				{
					//always trying to see if we can be relative to the include path
					if (_wcsicmp((wchar_t *)(const wchar_t *)baseDir, (wchar_t *)(const wchar_t *)m_OriginalDir) != 0 
						&& ((iFound = SetFileRelativeFromPath((wchar_t *)lpszIncludePath, pch, frhResult, pItem, &ich, 
						strOptionPath, szPlatDirs, fIsInclude)) != NOTFOUND))
					{
						SetFilePathInfo(pFile, pFile, ich, strOptionPath, pchProjDirectory, iFound, false);
					}
				}
			}
			return TRUE;
		}
		else if (pNotFoundCache)
			pNotFoundCache->SetAt(pchLookup, 0);
	}

	return FALSE;
}

void CBldIncludeEntry::SetFilePathInfo(CBldFileRegFile* pFile1, CBldFileRegFile* pFile2, int idx, CStringW& strOptionPath, 
	const wchar_t* pchProjDirectory, int iFound, bool bSetOrgNameOnPath)
{
	CStringW strRelative;
	if (iFound == ONPATH)
	{
		//set it relative to the path, the ..\ won't be resolved
		if (bSetOrgNameOnPath)
			pFile1->SetOrgName(m_FileReference);
		pFile1->SetIndexNameRelative(idx);
		pFile2->SetFileFoundInIncPath();
	}
	else
	{
		// found on option path, should remember the option path
		// reset the m_OrgName to append this option path
		pFile1->SetOrgName(strOptionPath);
		pFile1->SetIndexNameRelative(0);
		pFile1->SetFileNameRelativeToProj();
		const wchar_t *pchr = strOptionPath;
		if (*pchr == L'/' || *pchr == L'\\' || *pchr == L':' || *(pchr + 1) == L':')
		{
   			VSASSERT(*pchr != L':', "Managed to get a two char drive letter...");  // should never happen!!!
			strRelative = GetRelativeName(strOptionPath, (wchar_t *)pchProjDirectory);
			pFile1->SetOrgName(strRelative);
		}
	}
}
///////////////////////////////////////////////////////////////////////////////
//
// ----------------------------- CBldIncludeEntryList --------------------------
//
///////////////////////////////////////////////////////////////////////////////

void CBldIncludeEntryList::DeleteContents()
{
	VCPOSITION pos;
	for (pos = GetHeadPosition (); pos != NULL; )
		delete(GetNext(pos));
	RemoveAll();
}

static int GetFileFullPathI(wchar_t* pszIncludePathLocal, wchar_t *pBase, const wchar_t* pszIncludePathSys, wchar_t *buf, 
	CStringW &strOptionPath, CBldFileRegistry* pregistry, CDirW& dirBase, const CDirW& dirProj);

// Helper function for finding include file's full path
// replace SearchPath
int GetFileFullPath(wchar_t* pstrInclude, wchar_t *pBase, IVCBuildableItem* pItem, wchar_t *buf, CStringW &strOptionPath, 
	const wchar_t* szPlatDirs, BOOL bIsInclude, const CDirW& dirProj)
{
	VSASSERT(buf != (wchar_t *)NULL, "Trying to use a NULL buffer to return data in.  Bad programmer, bad programmer.");
	CDirW dirBase;
	CBldFileRegistry* pregistry = NULL;

	if (pItem != NULL)
	{
		// the configuration of our file search
		pItem->get_Registry((void **)&pregistry);
		VSASSERT(pregistry != (CBldFileRegistry *)NULL, "No registry associated with item.  Bad initialization.");
	}

	CStringW strIncludeTmp;
	wchar_t* szIncludeTmp = strIncludeTmp.GetBuffer(lstrlenW(pstrInclude) + 1);
	wcscpy(szIncludeTmp, pstrInclude);

	// path of a possible resolved file
	CStringW str1 = szPlatDirs;

	if (pItem != NULL && szPlatDirs == NULL)
	{
		CComQIPtr<IVCPropertyContainer> spPropContainer = pItem;
		if (spPropContainer != NULL)
		{
			CComBSTR bstr1;
			spPropContainer->GetEvaluatedStrProperty(bIsInclude ? VCPLATID_IncludeDirectories : VCPLATID_LibraryDirectories, &bstr1);
			str1 = bstr1;
		}
	}

	// get the include path from env setting of $(INCLUDE)
	const wchar_t* pIncStart = wcsstr(szIncludeTmp, (LPCOLESTR)str1);
	int nFound = GetFileFullPathI(szIncludeTmp, pBase, pIncStart, buf, strOptionPath, pregistry, dirBase,
		dirProj);
	if (nFound == NOTFOUND)
		nFound = GetFileFullPathI(str1.GetBuffer(str1.GetLength()), pBase, str1, buf, strOptionPath, pregistry, 
			dirBase, dirProj);
	return nFound;
}

static int GetFileFullPathI(wchar_t* pszIncludePathLocal, wchar_t *pBase, const wchar_t* pszIncludePathSys, wchar_t *buf, 
	CStringW &strOptionPath, CBldFileRegistry* pregistry, CDirW& dirBase, const CDirW& dirProj)
{
	// separate the include path list
	const wchar_t *pch = wcstok(pszIncludePathLocal, L";,");
	CPathW path;

	while (pch != NULL)
	{
		// remove leading spaces
		while (pch && *pch == L' ')
			pch++;
		if (pch && *pch == L'"')
			pch++;

		INT_PTR nLen = wcslen(pch);
		if (nLen <= 0)
			break;

		// copy our include path
		wcscpy(buf, pch);

		// remove ending spaces
		while (*_wcsdec(buf, buf + nLen) == L' ')
		{
			nLen--;
			if (nLen <= 0)
				break;
		}

		wchar_t chTerm = *_wcsdec(buf, buf + nLen);
		if (chTerm == L'"')	// quoted string, get rid of quote
		{
			nLen--;
			if (nLen <= 0)
				break;
			chTerm = *_wcsdec(buf, buf + nLen);
			// remove ending spaces
			while (*_wcsdec(buf, buf + nLen) == L' ')
			{
				nLen--;
				if (nLen <= 0)
					break;
			}
		}
		while (nLen > 0 && (chTerm == L'/' || chTerm == L'\\'))		// don't want any trailing slashes
		{
			nLen--;
			chTerm = *_wcsdec(buf, buf + nLen);
		}
		if (nLen <= 0)
			break;

		buf[nLen] = L'\0';
		VSASSERT((nLen + wcslen(pBase)) <= MAX_PATH, "Directory path longer than MAX_PATH");
		//wcscpy(buf + nLen, pBase);

		CPathW pathBase;
		if (pathBase.CreateFromDirAndRelative(dirProj, buf))
			dirBase.CreateFromPath(pathBase, TRUE /* known directory */);
		else
			return NOTFOUND;

		if (path.CreateFromDirAndFilename(dirBase, pBase))
		{
			// exist on disk as is?
			if (path.ExistsOnDisk())
			{
				if (pch < pszIncludePathSys)
				{
					strOptionPath = buf;
					strOptionPath += pBase;
				}
				wcscpy(buf, path.GetFullPath());
				return ((pch >= pszIncludePathSys) ? ONPATH : ONOPTION);
			}

			// exist as a file (not yet created perhaps)
			// in our build registry (i.e. build graph)?
			BldFileRegHandle frhTmp = NULL; 
			if ((pregistry != NULL) && ((frhTmp = pregistry->LookupFile((LPCOLESTR)path)) != (BldFileRegHandle)NULL))
			{
				frhTmp->ReleaseFRHRef();
				if (pch < pszIncludePathSys)
					strOptionPath = path.GetFullPath();
				wcscpy(buf, path.GetFullPath() );
				return ((pch >= pszIncludePathSys) ? ONPATH : ONOPTION);
			}
		}

		// next include path
		pch = wcstok(NULL, L";,");
	}

	return NOTFOUND;
}

void StripQuotes(LPCOLESTR szFilePath, LPOLESTR szBuffer, long nMax)
{
	if (szFilePath == NULL || szBuffer == NULL)
	{
		VSASSERT(FALSE, "Cannot strip quotes off a NULL path!");
		return;		// nothing we can do
	}

	const wchar_t * pchLookup = szFilePath;
	wchar_t *pchSet = szBuffer;
	long nIdx = 0;

	while (*pchLookup != L'\0')
	{
		if (*pchLookup != L'"')
 		{
			wcscpy(pchSet, pchLookup);
			pchSet++;
			nIdx++;
			if (nIdx == nMax-1)
			{
				VSASSERT(FALSE, "Buffer too small!");
				break;	// overflow...
			}
 		}
		pchLookup++;
	}

    *pchSet = L'\0';
}

// Help routine to find out if the file is on the search path
int SetFileRelativeFromPath(wchar_t* pstrInclude, wchar_t* pPath, BldFileRegHandle frh, IVCBuildableItem* pItem, 
	int *pich, CStringW &strOptionPath, const wchar_t* szPlatDirs, BOOL bIsInclude)
{
	CStringW strIncludeTmp = pstrInclude;
	strIncludeTmp.MakeUpper();

	CStringW strPath = pPath;
	strPath.MakeUpper();

	const int nPathLen = strPath.GetLength();
	int nPchLen;
	BOOL bHasSlash;

	CStringW str1 = szPlatDirs;

	if (pItem != NULL && szPlatDirs == NULL)
	{
		CComQIPtr<IVCPropertyContainer> spPropContainer = pItem;
		if (spPropContainer != NULL)
		{
			CComBSTR bstr;
			spPropContainer->GetEvaluatedStrProperty(bIsInclude ? VCPLATID_IncludeDirectories : VCPLATID_LibraryDirectories, &bstr);
			str1 = bstr;
		}
	}

	wchar_t *pch, *pIncStart = wcsstr(strIncludeTmp, (LPCOLESTR)str1);

	//separate the include path
	pch = wcstok((wchar_t*)(const wchar_t*)strIncludeTmp, L";,");
	for ( ; pch != NULL; pch = wcstok(NULL, L";,"))
	{
		if (pch[0] != L'\0')
		{
			// do we have a match?
			nPchLen = lstrlenW(pch);

			// no possible match if path is shorter than dir
			if ((nPathLen < nPchLen) || (wcsncmp(strPath, pch, nPchLen)!=0))
				continue;

			bHasSlash = (*_wcsdec(pch, pch + nPchLen)==L'\\');

			if ((bHasSlash) || (strPath[nPchLen]==L'\\'))
			{
				// yes, it is on the search path,
				if (pch >= pIncStart)
				{
					// get the relative name and length
					CStringW str = GetRelativeName(pPath, pch);

					*pich = (int) str.GetLength();

					return ONPATH;
				}
				else
				{
					strOptionPath = pPath;
					return ONOPTION;
				}
			}
		}

	}

	// not found, zero-length
	*pich = 0;
	return NOTFOUND;

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\vcpb\scanner.h ===
#pragma once

///////////////////////////////////////////////////////////////////////////////
//	Map which holds list of all files which have been scanned.  Keeps track
//	of file names using g_FileRegistry and FileRegHandles.

class CBldIncludeEntry;
class CBldIncludeEntryList;
class CBldScannerCache;

#include "FileRegistry.h"

class CBldScannerCache
{
	// This class needs to be a friend because of the "find file" caches described below.
	friend class CBldIncludeEntry;

public:
	CBldScannerCache() : m_EntryMap (29) 
		{
			m_nBeginCount = 0;
			m_nUniqueNo = 0;
			// FUTURE: might need to retune these hash table sizes!
			m_EntryMap.InitHashTable(523);
			m_DirtyGroups.InitHashTable(17);
			m_AbsCache.InitHashTable(29);
			m_OrigCache.InitHashTable(97);
			m_NotOrigCache.InitHashTable(29);
			m_ParentCache.InitHashTable(17);
			m_NotParentCache.InitHashTable(29);
			m_IncludeCache.InitHashTable(29);
		};
	~CBldScannerCache();

	void Add(BldFileRegHandle frh, CBldIncludeEntryList* pAddedList);

	CBldIncludeEntryList* LookupFile(BldFileRegHandle frh);

	int  BeginCache(); 
	void EndCache();   

	//	Deletes all entries:
	void Clear();

private:
	int m_nBeginCount;
	int m_nUniqueNo;
	CVCMapPtrToPtr	m_EntryMap;
	CVCMapPtrToPtr m_DirtyGroups;

	// These caches significantly speed up the process of finding #include
	// files.  All of these map *from* strings *to* FileRegHandles:
	//
	// m_AbsCache			Files found with IncTypeCheckAbsolute
	//						Maps from filename to BldFileRegHandle
	// m_OrigCache			Files found with IncTypeCheckOriginalDir
	//						Maps from filename to BldFileRegHandle
	// m_NotOrigCache		Files *not* found with IncTypeCheckOriginalDir
	//						Maps from filename to BldFileRegHandle
	// m_ParentCache		Files found with IncTypeCheckParentDir
	//						Maps from "<parent_dir>#<filename>" to BldFileRegHandle
	// m_NotParentCache		Files *not* found with IncTypeCheckParentDir
	//						Maps from "<parent_dir>#<filename>" to BldFileRegHandle
	// m_IncludeCache		Files found with IncTypeCheckIncludePath
	//						Maps from "<include_path>#<filename>" to BldFileRegHandle
	//
	// All of these caches are used by CBldIncludeEntry::FindFile().
	//
	// The "Not" caches need some explanation.  CBldIncludeEntry::FindFile() must
	// make each search for the file as indicated by the CBldIncludeEntry's "IncType",
	// and these checks must be in a particular order to emulate the C compiler's
	// behavior.  If a file was previously found as IncTypeCheckIncludePath, that
	// cache (m_IncludeCache) will again locate the file, but not until m_AbsCache,
	// m_OrigCache and m_ParentCache have been potentially checked (assuming those
	// "IncType"s were set as well).  The "Not" caches (m_NotOrigCache and m_Not-
	// ParentCache) keep track of files *not* found for those "IncTypes", so when
	// looking for a file, if it's in the "Not" cache, we know we didn't find it
	// last time and we don't need to look again.
	//
	// In other words, without the "Not" caches, the logic would be something like
	// this.  Assume we have a file which will eventually be found on the INCLUDE
	// path.
	//
	// if (m_EntryType & IncTypeCheckOriginalDir)
	// {
	//		// look in cache -- if not there, must check on disk (expensive)
	//		// won't find hypothetical file here -- will find on INCLUDE path
	//		// we could check on disk multiple times for the same file!
	// }
	//
	// With the "Not" caches, we can avoid the check on disk:
	//
	// if (m_EntryType & IncTypeCheckOriginalDir)
	// {
	//		if (FileInNotCache())
	//		{
	//			// didn't find it last time! -- no reason to look again
	//		}
	//		else
	//		{
	//			// now we have to look in cache and if not there, check on disk
	//		}
	// }
	CVCMapStringWToPtr	m_AbsCache;
	CVCMapStringWToPtr	m_OrigCache;
	CVCMapStringWToPtr	m_NotOrigCache;
	CVCMapStringWToPtr	m_ParentCache;
	CVCMapStringWToPtr	m_NotParentCache;
	CVCMapStringWToPtr	m_IncludeCache;
}; 
///////////////////////////////////////////////////////////////////////////////
//	Map which holds a registry of the system inculdes files and reads 
//	itself in from disk.  Scanning routines can call this to see if the've
//  hit a system include file:

class CBldSysInclReg
{
public:
	CBldSysInclReg()
	{
		m_nLoadState = 0;
	};

	BOOL IsSysInclude(CStringW& strFile, BOOL bUseSlowCompare=TRUE);

private:
	int m_nLoadState;  // 0 => Not initilized, >0 => Loaded, <0 => Load error.
	CVCStringWList  	m_dirList;
	
	BOOL DoLoad();	
};

extern CBldSysInclReg g_SysInclReg;

///////////////////////////////////////////////////////////////////////////////
//	Class for holding an including reference. Each #include "stuff" generates
//	one of these:
//
enum BldIncludeEntryTypes		// Note: these are in order of precendence
{
	IncTypeCheckAbsolute		=  1,
	IncTypeCheckParentDir		=  2,
	IncTypeCheckIncludePath		=  4,
	IncTypeCheckLibPath			=  8,
	IncTypeCheckOriginalDir		= 16,
	IncTypeCheckIntDir			= 32,
	IncTypeCheckOutDir			= 64,
};

class CBldIncludeEntry
{
public:
	//	Finds the file referenced by this entry in cpResultPath  Returns
	//	false if file not found.  Use GetLastError to found out what's
	//	wrong.
	BOOL FindFile(const wchar_t* lpszIncludePath, const CDirW& cdBaseDirectory, const wchar_t* pchProjDirectory,
		BldFileRegHandle& frhResult, IVCBuildableItem* pItem, CBldScannerCache* pScannerCache, 
		const wchar_t* szPlatDirs = NULL);

	//	Examine m_FileReference to find out if this is an absolute
	//	file name, and set EntryType if it is.
	BOOL CheckAbsolute();

	int  		m_EntryType;
	BOOL		m_bShouldBeScanned;	// should be scanned?

	CStringW  	m_FileReference;
	CDirW		m_OriginalDir;		// directory of originally scanned file

	CStringW    m_strReferenceIn;	// the source file that #included this
	int			m_nLineNumber;		// line # in this source file

protected:
	void SetFilePathInfo(CBldFileRegFile* pFile1, CBldFileRegFile* pFile2, int idx, CStringW& strOptionPath, 
		const wchar_t* pchProjDirectory, int iFound, bool bSetOrgNameOnPath);
	BOOL ResolveToCache(const CDirW& baseDir, CVCMapStringWToPtr* pFoundCache, CVCMapStringWToPtr* pNotFoundCache, 
		const wchar_t* pchProjDirectory, BOOL fIsInclude, IVCBuildableItem* pItem, wchar_t* buf, BldFileRegHandle& frhResult, 
		const wchar_t* lpszIncludePath, const wchar_t* szPlatDirs, bool bRelativeToParent);
};

///////////////////////////////////////////////////////////////////////////////
//	Expanded CVCPtrList to hold "touched" mark:
//
class CBldIncludeEntryList : public CVCPtrList
{
public:
	CBldIncludeEntryList(int nBlockSize = 10) : CVCPtrList(nBlockSize)
	{ 
		m_LastTouch = 0;
	};
	virtual ~CBldIncludeEntryList () { DeleteContents (); }
	CBldIncludeEntry *GetNextEntry(VCPOSITION& pos)
	{
		return(CBldIncludeEntry *)CVCPtrList::GetNext(pos);
	};

	CBldIncludeEntry *GetEntryAt(VCPOSITION& pos)  
	{
		return(CBldIncludeEntry *)CVCPtrList::GetAt(pos);
	};
	int m_LastTouch;		// Scratch integer for spotting cycles.

	void DeleteContents(); 
};

extern int SetFileRelativeFromPath(wchar_t* pstrInclude, wchar_t* pPath, BldFileRegHandle frh, IVCBuildableItem* pItem, 
	int *pich, CStringW &strOptionPath, const wchar_t* szPlatDirs, BOOL bIsIncludeNotLib);

enum { ONOPTION, ONPATH, NOTFOUND };
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\vcpb\ScriptExecutor.cpp ===
// ScriptExecutor.cpp: implementation of the CScriptExecutor class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "comlist.h"
#include "ScriptExecutor.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CScriptExecutor::CScriptExecutor()
{
	m_perrors = NULL;
	m_hwnd = NULL;
}

CScriptExecutor::~CScriptExecutor()
{
	if (m_perrors)
	{
		delete m_perrors;
		m_perrors = NULL;
	}
}


STDMETHODIMP CScriptExecutor::put_Wnd(/*[in]*/ HWND hwnd)
{
	m_hwnd = hwnd;
	return S_OK;
}

STDMETHODIMP CScriptExecutor::get_Wnd(/*[out, retval]*/ HWND *phwnd)
{
	*phwnd = m_hwnd;
	return S_OK;
}


STDMETHODIMP CScriptExecutor::Run()
{
	CComVariant var;
	EXCEPINFO excepInfo;
	HRESULT hr = E_FAIL;

	if (m_pParseScript)
	{
		// Add named items
		hr = m_pParseScript->ParseScriptText(m_bstrScript, NULL, NULL, NULL, 0, 1, 0, &var, &excepInfo);
		if (SUCCEEDED(hr))
		{
			// Run script
			hr = m_pScript->SetScriptState(SCRIPTSTATE_CONNECTED);
		}
		else if (hr == DISP_E_EXCEPTION)
		{
			SysFreeString(excepInfo.bstrSource);
			SysFreeString(excepInfo.bstrDescription);
			SysFreeString(excepInfo.bstrHelpFile);
		}
	}

	return hr;
}

STDMETHODIMP CScriptExecutor::EnsureParser()
{
	HRESULT hr = E_NOINTERFACE;
	m_pParseScript = m_pScript;
	if (m_pParseScript)
	{
		if (m_perrors)
		{
			delete m_perrors;
			m_perrors = NULL;
		}

		CComQIPtr<IObjectSafety> pObjectSafety;
		pObjectSafety = m_pParseScript;

		if (pObjectSafety)
		{
			hr = pObjectSafety->SetInterfaceSafetyOptions(__uuidof(IActiveScriptParse),
				INTERFACESAFE_FOR_UNTRUSTED_DATA|INTERFACESAFE_FOR_UNTRUSTED_CALLER,
				INTERFACESAFE_FOR_UNTRUSTED_DATA|INTERFACESAFE_FOR_UNTRUSTED_CALLER);
			if (FAILED(hr))
			{
				hr = pObjectSafety->SetInterfaceSafetyOptions(__uuidof(IActiveScriptParse),
					INTERFACESAFE_FOR_UNTRUSTED_DATA,
					INTERFACESAFE_FOR_UNTRUSTED_DATA);
			}
		}	

		hr = m_pParseScript->InitNew();
		VSASSERT(SUCCEEDED(hr), "Unable to initialize script parser!");
		if (SUCCEEDED(hr))
		{
			CComBSTR bstrItem;

			bstrItem = L"Application";
			hr = m_pScript->AddNamedItem(bstrItem, SCRIPTITEM_ISVISIBLE | 
							 SCRIPTITEM_ISSOURCE | SCRIPTITEM_GLOBALMEMBERS);
			VSASSERT(SUCCEEDED(hr), "Unable to add the Application to the script's environment");
			hr = m_pScript->AddTypeLib(*m_pguid, 1, 0, SCRIPTTYPELIB_ISCONTROL);
		}
	}
	return hr;
}

STDMETHODIMP CScriptExecutor::EnsureEngine()
{
	HRESULT hr = E_NOINTERFACE;
	CLSID clsidEngine;
	CComBSTR bstrScriptEngine;

	bstrScriptEngine = m_bstrEngineName;
	if (bstrScriptEngine.Length() == 0)
	{
		bstrScriptEngine = L"VBScript";
		// LATER (maybe)... get <SCRIPT="VBScript"> from script itself
		// right now, descision is to keep things simpler.
	}

	hr = CLSIDFromProgID(bstrScriptEngine, &clsidEngine);
	if (SUCCEEDED(hr))
	{
		hr = m_pScript.CoCreateInstance(clsidEngine);
		// assert to let us know we couldn't load vbscript
		VSASSERT( SUCCEEDED( hr ), "Unable to create VBScript object. Make sure vbscript.dll is on your system and registered" );
		if (SUCCEEDED(hr))
		{
			hr = m_pScript->SetScriptSite(this);
			VSASSERT(SUCCEEDED(hr), "Unable to set script site");
		}
	}
	return hr;
}

STDMETHODIMP CScriptExecutor::LoadScript(BSTR szProjectPath)
{
	HRESULT hr;

	m_bstrScriptFile = szProjectPath;

	hr = EnsureEngine();
	if (FAILED(hr))
		return hr;

	hr = EnsureParser();
	if (FAILED(hr))
		return hr;

	// load the script...
	FILE *pFile;
	struct _stat stat;
	CString strScript;	// yes, ANSI
	TCHAR * pszScript;	// yes, ANSI

	hr = E_HANDLE;
	m_bstrScript.Empty();
	CString strProjectDir = szProjectPath;	// yes, ANSI
	if (_tstat(strProjectDir, &stat) == 0)
	{
		pszScript = strScript.GetBufferSetLength(stat.st_size);
		pFile = _tfopen(strProjectDir, _T("rb"));
		if (pFile)
		{
			fread(pszScript, stat.st_size, 1, pFile);
			fclose(pFile);
			hr = S_OK;
		}
		strScript.ReleaseBuffer();


		// remove "header"
		int i,j;
		i = strScript.Find(m_strHeaderEnd, 0);
		if (i >= 0)
		{
			j = strScript.Find(_T('\n'), i);
			strScript = strScript.Mid(j);
		}
		
		
		CComBSTR szProjectDir;
//		CString strProjectDir;	// yes, ANSI

//		strProjectDir = szProjectPath;
		i = strProjectDir.ReverseFind(_T('\\'));
		if (i >= 0)
		{
			strProjectDir = strProjectDir.Left(i+1);
		}
		else
		{
			strProjectDir = _T("\\"); // must be at root!
		}
		szProjectDir = strProjectDir;

		m_bstrScript = L"dim ScriptPath\nScriptPath = \"";
		m_bstrScript.Append(szProjectPath);
		m_bstrScript.Append(L"\"\n");
		m_bstrScript.Append(L"dim ScriptDir\nScriptDir = \"");
		m_bstrScript.Append(szProjectDir);
		m_bstrScript.Append(L"\"\n");

		wchar_t *pStr = new wchar_t[strScript.GetLength()+1];
		if( pStr )
		{
			MultiByteToWideChar( CP_ACP,0,strScript,-1, pStr, (int)(strScript.GetLength()+1));
			m_bstrScript.Append(pStr);
			delete []pStr;
		}
	}
	return hr;
}



// ------------ Script Site...

// IActiveScriptSite
STDMETHODIMP CScriptExecutor::GetLCID(ULONG * plcid)
{
	CHECK_POINTER_NULL(plcid);
	return E_NOTIMPL;
}
STDMETHODIMP CScriptExecutor::GetItemInfo(LPCOLESTR pstrName, DWORD dwReturnMask, IUnknown * * ppiunkItem, ITypeInfo * * ppti)
{
	CHECK_POINTER_NULL(ppiunkItem);

	CComBSTR bstrName = pstrName;
	if (bstrName == L"Application" && m_pApplication)
	{
		if (dwReturnMask & SCRIPTINFO_IUNKNOWN)
		{
			m_pApplication.CopyTo( ppiunkItem );
		}
		if (dwReturnMask & SCRIPTINFO_ITYPEINFO)
		{
			VSASSERT(0, _T("Script engine wanted type info"));
			CHECK_POINTER_NULL(ppti);
			*ppti = NULL;
		}
		return S_OK;
	}

	return E_FAIL;
}

STDMETHODIMP CScriptExecutor::GetDocVersionString(BSTR * pbstrVersion)
{
	CHECK_POINTER_NULL(pbstrVersion);
	return E_NOTIMPL;
}

STDMETHODIMP CScriptExecutor::OnScriptTerminate(const VARIANT * pvarResult, const EXCEPINFO * pexcepinfo)
{
	return E_NOTIMPL;
}

STDMETHODIMP CScriptExecutor::OnStateChange(tagSCRIPTSTATE ssScriptState)
{
	return S_OK;
}

STDMETHODIMP CScriptExecutor::OnScriptError(IActiveScriptError * pscripterror)
{
	if (pscripterror == NULL)
		return E_INVALIDARG;

	ULONG ulLineNumber;
	long lCharacterPosition;
	CComBSTR bstrLine;
	DWORD_PTR dwSourceContext;
	EXCEPINFO excepinfo;

	pscripterror->GetSourceLineText(&bstrLine);
	pscripterror->GetSourcePosition(&dwSourceContext, &ulLineNumber, &lCharacterPosition);
	pscripterror->GetExceptionInfo(&excepinfo);
#ifdef _DEBUG
	CStringW strScript, strError, strDesc;
	CString strErrorMsg;	// yes, this needs to be ANSI
	int i, j;

	if (excepinfo.bstrSource)
		strError = excepinfo.bstrSource;
	if (excepinfo.bstrDescription)
		strDesc = excepinfo.bstrDescription;
	strScript = bstrLine;
	i = 1;
	j = i + 1; // just to get the condition later to work
	if (strScript.IsEmpty())
	{
		strScript = m_bstrScript;
		i = 0;
		for (j = ulLineNumber; j > 0 && i >= 0; j--)
		{
			i = strScript.Find(L'\n', i+1);
		}
		j = strScript.Find(L'\n', i+1);
	}
	ulLineNumber -= 1; // account for added lines...
	if (i >= 0 && j > i)
	{
		strScript = strScript.Mid(i+1, j - i);

		AtlTrace(_T("Script Error (%ls): Line %d(%d)\n%ls\n"), m_bstrScriptFile, ulLineNumber, lCharacterPosition, strScript);
		if (!strError.IsEmpty())
		{
			AtlTrace(_T("%ls\n"), strError);
		}
		if (!strDesc.IsEmpty())
		{
			AtlTrace(_T("%ls\n"), strDesc);
		}
		AtlTrace(_T("%ls(%d): %s\n"), m_bstrScriptFile, ulLineNumber, strScript);
		strErrorMsg.Format(_T("%ls(%d): %s\nCheck Debug Output also"), m_bstrScriptFile, ulLineNumber, strScript);
		MessageBox(NULL, strErrorMsg, "VC Load Script Error", MB_OK);
	}
	else
	{
		AtlTrace(_T("Script Error (%ls): Line %d(%d)\n"), m_bstrScriptFile, ulLineNumber, lCharacterPosition);
		if (!strError.IsEmpty())
		{
			AtlTrace(_T("%ls\n"), strError);
		}
		if (!strDesc.IsEmpty())
		{
			AtlTrace(_T("%ls\n"), strDesc);
		}
		AtlTrace(_T("%ls(%d)\n"), m_bstrScriptFile, ulLineNumber);
		strErrorMsg.Format(_T("%ls(%d)\nCheck Debug Output also\n"), m_bstrScriptFile, ulLineNumber);
		MessageBox(NULL, strErrorMsg, "VC Load Script Error", MB_OK);
	}
#endif
	if (m_perrors == NULL)
	{
		m_perrors = new CComDynamicList;
	}
	if (m_perrors)
	{
		m_perrors->Add(pscripterror);
	}
	return S_OK;
}

STDMETHODIMP CScriptExecutor::OnEnterScript()
{
	return E_NOTIMPL;
}

STDMETHODIMP CScriptExecutor::OnLeaveScript()
{
	return E_NOTIMPL;
}

STDMETHODIMP CScriptExecutor::GetWindow(/* [out] */ HWND *phwnd)
{
	CHECK_POINTER_NULL(phwnd);
	*phwnd = m_hwnd;
	return S_OK;
}

STDMETHODIMP CScriptExecutor::EnableModeless(/* [in] */ BOOL fEnable)
{
	return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\vcpb\ScriptExecutor.h ===
// ScriptExecutor.h: interface for the CScriptExecutor class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_SCRIPTEXECUTOR_H__D6BB9575_049A_11D3_8D31_00C04F8EEA30__INCLUDED_)
#define AFX_SCRIPTEXECUTOR_H__D6BB9575_049A_11D3_8D31_00C04F8EEA30__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include <time.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <stdio.h>
#include <OBJSAFE.H>
#include <activscp.h>
#include "comlist.h"

class CScriptExecutor  : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public IActiveScriptSite,
	public IActiveScriptSiteWindow
{
public:
	CScriptExecutor();
	virtual ~CScriptExecutor();
	STDMETHOD(Run)();
	STDMETHOD(LoadScript)(BSTR szProjectPath);
	STDMETHOD(put_Script)(BSTR bstrScript) { m_bstrScript = bstrScript; return S_OK;};
	STDMETHOD(get_Script)(BSTR *pbstrScript) { m_bstrScript.CopyTo(pbstrScript); return S_OK;};
	STDMETHOD(put_strHeaderEnd)(BSTR bstrHeaderEnd) { m_strHeaderEnd = bstrHeaderEnd; return S_OK;};
	STDMETHOD(get_strHeaderEnd)(BSTR *pbstrHeaderEnd) { *pbstrHeaderEnd = m_strHeaderEnd.AllocSysString(); return S_OK;};
	STDMETHOD(put_Application)(IDispatch *pDispApplication) { m_pApplication = NULL; m_pApplication = pDispApplication; return S_OK;};
	STDMETHOD(get_Application)(IUnknown **ppDispApplication) { m_pApplication.CopyTo(ppDispApplication); return S_OK;};
	STDMETHOD(put_EngineName)(BSTR bstrEngineName) { m_bstrEngineName = bstrEngineName; return S_OK;};
	STDMETHOD(get_EngineName)(BSTR *pbstrEngineName) { m_bstrEngineName.CopyTo(pbstrEngineName); return S_OK;};
	STDMETHOD(put_TypeLibraryGuid)(const GUID *pguid) { m_pguid = pguid; return S_OK;};
	STDMETHOD(get_TypeLibraryGuid)(const GUID **ppguid) { *ppguid = m_pguid; return S_OK;};

	STDMETHOD(EnsureEngine)();
	STDMETHOD(EnsureParser)();
	STDMETHOD(put_Wnd)(/*[in]*/ HWND hwnd);
	STDMETHOD(get_Wnd)(/*[out, retval]*/ HWND *phwnd);

	void Close( void )
	{
		if( m_pScript )
			m_pScript->Close();
		m_pApplication.Release();
		m_pParseScript.Release();
		m_pScript.Release();
		if( m_perrors ) 
			m_perrors->RemoveAll();
	}

BEGIN_COM_MAP(CScriptExecutor)
	COM_INTERFACE_ENTRY(IActiveScriptSite)
	COM_INTERFACE_ENTRY(IActiveScriptSiteWindow)
END_COM_MAP()


// IActiveScriptSite
public:
        STDMETHOD(GetLCID)( /* [out] */ LCID *plcid);

        STDMETHOD(GetItemInfo)(
                /* [in] */  LPCOLESTR pstrName,
                /* [in] */  DWORD     dwReturnMask,
                /* [out] */ IUnknown  **ppiunkItem,
                /* [out] */ ITypeInfo **ppti
				);

        STDMETHOD(GetDocVersionString)( /* [out] */ BSTR      *pbstrVersion );

        STDMETHOD(OnScriptTerminate)( /* [in] */  const VARIANT     *pvarResult,
                /* [in] */  const EXCEPINFO   *pexcepinfo );

        STDMETHOD(OnStateChange)( /* [in] */  SCRIPTSTATE       ssScriptState );

        STDMETHOD(OnScriptError)( /* [in] */  IActiveScriptError *pscripterror );

        STDMETHOD(OnEnterScript)(void);

        STDMETHOD(OnLeaveScript)(void);

// IActiveScriptSiteWindow
public:
        STDMETHOD(GetWindow)(/* [out] */ HWND *phwnd);
        STDMETHOD(EnableModeless)(/* [in] */ BOOL fEnable);

protected:
	CComBSTR m_bstrScriptFile;
	CComBSTR m_bstrScript;
	CComBSTR m_bstrEngineName; // eg., L"VBScript"
	CString m_strHeaderEnd; // eg., _T("# ** DO NOT EDIT **")	// yes, ANSI
	CComPtr<IUnknown> m_pApplication; // eg. VCProjectEngine
	CComQIPtr<IActiveScriptParse> m_pParseScript;
	HWND m_hwnd;
	
	const GUID *m_pguid;		// type library to add (single, for now).
	CComPtr<IActiveScript>			m_pScript; // for project load
	CComDynamicList *m_perrors;	// collection of IActiveScriptError's for the current load
};

#endif // !defined(AFX_SCRIPTEXECUTOR_H__D6BB9575_049A_11D3_8D31_00C04F8EEA30__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\vcpb\sdltool.cpp ===
// SdlBaseTool.cpp : Implementation of Web Service Proxy Generator Tool

#include "stdafx.h"
#include "SdlTool.h"
#include "BuildEngine.h"
#include "scanner.h"
#include "ProjWriter.h"

// constants
const wchar_t* const wszWebDefaultExtensions = L"*.sdl;*.wsdl";	// remember to update vcpb.rgs if you change this...

// static initializers
CWebToolOptionHandler CVCWebServiceProxyGeneratorTool::s_optHandler;
CComBSTR CVCWebServiceProxyGeneratorTool::s_bstrBuildDescription = L"";
CComBSTR CVCWebServiceProxyGeneratorTool::s_bstrToolName = L"";
CComBSTR CVCWebServiceProxyGeneratorTool::s_bstrExtensions = L"";
GUID CVCWebServiceProxyGeneratorTool::s_pPages[2];
BOOL CVCWebServiceProxyGeneratorTool::s_bPagesInit;

////////////////////////////////////////////////////////////////////////////////
// Option Table for Web Service Utility switches

// NOTE: we're using macros for enum value ranges to help in keeping enum range checks as low maintenance as possible.
// If you add an enum to this table, make sure you use macros to define the upper and lower bounds and use CHECK_BOUNDS
// on the get/put methods associated with that property (both object model and property page).
// WARNING: if you change ANYTHING about a multi-prop here (including add/remove), be sure to update how the property
// is obtained on both the tool and page objects.
BEGIN_OPTION_TABLE(CWebToolOptionHandler, L"VCWebServiceProxyGeneratorTool", IDS_WEBTOOL, TRUE /* pre & post */, FALSE /* case sensitive */)
	// general
	OPT_BSTR(Output,				L"out:%s",		L"Output",		single,		IDS_WEBTOOL, VCWEBID)	// Output filename
	OPT_BOOL(SuppressStartupBanner,	L"|nologo",		L"SuppressStartupBanner",	IDS_WEBTOOL, VCWEBID)
END_OPTION_TABLE()


BOOL CWebToolOptionHandler::SetEvenIfDefault(VARIANT *pvarDefault, long idOption)
{
	CComVariant varDefault;
	BOOL bRet = FALSE;

	switch (idOption)
	{
	case VCWEBID_SuppressStartupBanner:
		varDefault.vt = VT_BOOL;
		varDefault = VARIANT_TRUE;
		bRet = TRUE;
		break;
	}
	varDefault.Detach(pvarDefault);
	return bRet;
}

BOOL CWebToolOptionHandler::SynthesizeOptionIfNeeded(IVCPropertyContainer* pPropContainer, long idOption)
{
	VSASSERT(pPropContainer != NULL, "Cannot synthesize a tool option without a property container");
	RETURN_ON_NULL2(pPropContainer, FALSE);	// can't synthesize if we don't have a property container...

	switch (idOption)
	{
	case VCWEBID_Output:
		return TRUE;
	default:
		return FALSE;
	}
}

BOOL CWebToolOptionHandler::SynthesizeOption(IVCPropertyContainer* pPropContainer, long idOption, 
	CComVariant& rvar)
{
	switch (idOption)
	{
	case VCWEBID_Output:
		{
			rvar.Clear();
			VSASSERT(pPropContainer != NULL, "Cannot create an option value without a property container");
			CComBSTR bstrVal;
			GetDefaultValue( idOption, &bstrVal, pPropContainer );
			return SetBstrInVariant(pPropContainer, bstrVal, rvar);
		}
	default:
		VSASSERT(FALSE, "Case statement mismatch between SynthesizeOptionIfNeeded and SynthesizeOption");	// shouldn't be here!!
		return FALSE;
	}
}

// default value handlers
// string props
void CWebToolOptionHandler::GetDefaultValue( long id, BSTR *pVal, IVCPropertyContainer *pPropCnt )
{
	if (id == VCWEBID_Output)
	{
		BOOL bIsManaged = FALSE;
		genProxyLanguage genProxy = genProxyNative;
		if( pPropCnt )
		{
		    HRESULT hr = pPropCnt->GetIntProperty(VCWEBID_GeneratedProxyLanguage, (long *)&genProxy);
		    if( hr == S_OK && genProxy == genProxyManaged )
		    	bIsManaged = TRUE;
		}

		CComBSTR bstrOut;
		if( bIsManaged )
			bstrOut = L"$(InputName).dll";
		else
			bstrOut = L"$(InputName).h";

		*pVal = bstrOut.Detach();
	}
	else
		GetDefaultString( pVal );
}

// integer props
void CWebToolOptionHandler::GetDefaultValue( long id, long *pVal, IVCPropertyContainer *pPropCnt )
{
	*pVal = 0;
}

// boolean props
void CWebToolOptionHandler::GetDefaultValue( long id, VARIANT_BOOL *pVal, IVCPropertyContainer *pPropCnt )
{
	if ( id == VCWEBID_SuppressStartupBanner )
		GetValueTrue( pVal );
	else
		GetValueFalse( pVal );
}


///////////////////////////////////////////////////////////////////////////////
// Sdl Tool
HRESULT CVCWebServiceProxyGeneratorTool::CreateInstance(IVCPropertyContainer* pPropContainer, IVCToolImpl** ppSdlTool)
{
	CHECK_POINTER_NULL(ppSdlTool);
	*ppSdlTool = NULL;

	CComObject<CVCWebServiceProxyGeneratorTool> *pObj;
	HRESULT hr = CComObject<CVCWebServiceProxyGeneratorTool>::CreateInstance(&pObj);
	if (SUCCEEDED(hr))
	{
		if( pPropContainer )
			pObj->Initialize(pPropContainer);
		CVCWebServiceProxyGeneratorTool *pVar = pObj;
		pVar->AddRef();
		*ppSdlTool = pVar;
	}
	return hr;
}

STDMETHODIMP CVCWebServiceProxyGeneratorTool::GenerateOutput(long type, IVCBuildActionList* plstActions, IVCBuildErrorContext* pEC)
{
	RETURN_ON_NULL2(plstActions, S_OK);

	BOOL bFirst = TRUE;
	CComBSTR bstrProjectDirectory;

	plstActions->Reset(NULL);
	while( true )
	{
		CComPtr<IVCBuildAction> spAction;
		HRESULT hr = plstActions->Next(&spAction, NULL);
		BREAK_ON_DONE(hr);

		CComPtr<IVCBuildableItem> spItem;
		spAction->get_Item( &spItem );
		VSASSERT( spItem != NULL, "Action created without an item.  Bad initialization." );
		CComQIPtr<IVCPropertyContainer> spPropContainer = spItem;
		VSASSERT( spPropContainer != NULL, "Action's item is not a property container.  Bad initialization." );
		RETURN_INVALID_ON_NULL(spPropContainer);

		if( IsExcludedFromBuild( spPropContainer ) )
			continue;	// nothing to do for things excluded from build...

		if( bFirst )
		{
			bFirst = FALSE;
			// get the project directory
			spPropContainer->GetStrProperty( VCPROJID_ProjectDirectory, &bstrProjectDirectory );
		}

 		CDirW dirBase;
 		CreateDirFromBSTR( bstrProjectDirectory, dirBase );
 
 		// get the output filename
 		CComBSTR bstrOutput;
 		hr = spPropContainer->GetEvaluatedStrProperty( VCWEBID_Output, &bstrOutput );
		if (hr == S_FALSE)
		{
			s_optHandler.GetDefaultValue( VCWEBID_Output, &bstrOutput, spPropContainer );
			spPropContainer->Evaluate(bstrOutput, &bstrOutput);
			hr = S_OK;
		}

		// set the output
		CPathW pathOutput;
		if( pathOutput.CreateFromDirAndFilename( dirBase, CStringW( bstrOutput ) ) )
		{
			pathOutput.GetActualCase(TRUE);
			hr = spAction->AddOutputFromPath( (wchar_t*)(const wchar_t*)pathOutput, pEC, VARIANT_TRUE, VARIANT_FALSE, 
				VCWEBID_Output, this );
			// TODO: handle errors?
			VSASSERT( hr == S_OK, "Failed to add output for sproxy command line" );
		}
	}
	return S_OK; // success
}

STDMETHODIMP CVCWebServiceProxyGeneratorTool::GetCommandLineEx(IVCBuildAction*pAction,IVCBuildableItem* pBuildableItem, 
	IVCBuildEngine* pBuildEngine, IVCBuildErrorContext* pEC, BSTR *pVal)
{
	CHECK_READ_POINTER_NULL(pAction);
	CHECK_READ_POINTER_NULL(pBuildableItem);

	CHECK_POINTER_NULL(pVal);
	*pVal = NULL;

	COptionHandlerBase* pOptionHandler = GetOptionHandler();
	RETURN_ON_NULL2(pOptionHandler, E_NOTIMPL);

	CComQIPtr<IVCPropertyContainer> spPropContainer = pBuildableItem;
	RETURN_INVALID_ON_NULL(spPropContainer);

	CComBSTR bstrProp;
	HRESULT hr = DoGetToolPath(&bstrProp, spPropContainer);	
	RETURN_ON_FAIL(hr);

	CComBSTR bstrToolExe;
	spPropContainer->Evaluate(bstrProp, &bstrToolExe);

	CStringW strOption, strCmdLine, strInput;
	strOption = bstrToolExe;
	pOptionHandler->AdvanceCommandLine(strCmdLine, strOption);

	BOOL bIsManaged = FALSE;
	genProxyLanguage genProxy = genProxyNative;
	hr = spPropContainer->GetIntProperty(VCWEBID_GeneratedProxyLanguage, (long *)&genProxy);
	if( hr == S_OK && genProxy == genProxyManaged )
	    bIsManaged = TRUE;
	

	if (bIsManaged)
	{
		CComBSTR bstrProp2;
		pAction->GetRelativePathsToInputs(TRUE, FALSE, pEC, &bstrProp2);
		strInput = bstrProp2;

    	// finish putting together the wsdl command line
		pOptionHandler->AdvanceCommandLine(strCmdLine, strOption, L" ");
		pOptionHandler->AdvanceCommandLine(strCmdLine, strInput, L" ");

		// get the output filename
		CComBSTR bstrOutput;
		hr = spPropContainer->GetEvaluatedStrProperty( VCWEBID_Output, &bstrOutput );
		if (hr == S_FALSE)
		{
		   	s_optHandler.GetDefaultValue( VCWEBID_Output, &bstrOutput, spPropContainer );
		   	spPropContainer->Evaluate(bstrOutput, &bstrOutput);
			hr = S_OK;
		}
		// get the output filename
		CComBSTR bstrAdditional;
		hr = spPropContainer->GetEvaluatedStrProperty( VCWEBID_AdditionalOptions, &bstrAdditional );

		// finish put together the rest of the batch file
		CComBSTR bstrCmdLine = L"@echo off\n";

		bstrCmdLine += L"wsdl /nologo /l:cs /out:\"$(InputName).cs\" \"";
		bstrCmdLine += strInput;
		bstrCmdLine += L"\" ";
		bstrCmdLine += bstrAdditional;
		bstrCmdLine += L"\n";

		bstrCmdLine += L"csc /t:module /nologo /o+ /debug- /out:\"";
		bstrCmdLine += bstrOutput;
		bstrCmdLine += L"\" \"$(InputName).cs\" \n";

		bstrCmdLine += L"copy \"";
		bstrCmdLine += bstrOutput;
		bstrCmdLine += L"\" \"$(OutDir)\\$(InputName).dll\"\n";

		spPropContainer->Evaluate(bstrCmdLine, &bstrCmdLine);
		
		if (pBuildEngine == NULL)
			return bstrCmdLine.CopyTo(pVal);
	
		return pBuildEngine->FormBatchFile(bstrCmdLine, pEC, pVal);
	}
	else
	{
		CComBSTR bstrProp2;
		pAction->GetRelativePathsToInputs(TRUE, FALSE, pEC, &bstrProp2);
		strInput = bstrProp2;
		pOptionHandler->AdvanceCommandLine(strCmdLine, strInput, L" ");
	
		CComBSTR bstrMidLine;
		hr = GetCommandLineOptions(pBuildableItem, NULL, VARIANT_TRUE /* include additional options */, cmdLineForBuild, &bstrMidLine);
		if (FAILED(hr))
			return hr;
		strOption = bstrMidLine;
	
		pOptionHandler->AdvanceCommandLine(strCmdLine, strOption, L" ");

		CStringW strCommand;
		strCommand.Format(IDS_CREATING_COMMANDLINE, strCmdLine);
		CComBSTR bstrCommand = strCommand;
		if( pBuildEngine )
			pBuildEngine->LogTrace(eLogCommand, bstrCommand);
		*pVal = strCmdLine.AllocSysString();
	}
	return S_OK;
}

HRESULT CVCWebServiceProxyGeneratorTool::GetPrimaryOutputFromTool(IUnknown* pItem, VARIANT_BOOL bSchmoozeOnly, CPathW& rPath)
{
	if (bSchmoozeOnly)
		return S_FALSE;	// not primary project output generator

	CComQIPtr<IVCPropertyContainer> spPropContainer = pItem;
	CComQIPtr<IVCBuildableItem> spBldableItem = pItem;
	if (spPropContainer == NULL || spBldableItem == NULL)
		return S_FALSE;

	CComBSTR bstrProjectDirectory;
	HRESULT hr = spPropContainer->GetStrProperty(VCPROJID_ProjectDirectory, &bstrProjectDirectory);	// should never have macros in it
	VSASSERT(hr == S_OK, "How did we manage to not get a project directory?!?");
	RETURN_ON_FAIL(hr);
	CStringW strProjDir = bstrProjectDirectory;
	CDirW dirProject;
	if (!dirProject.CreateFromKnown(strProjDir))
	{
		VSASSERT(FALSE, "Invalid project directory!");
		return CVCProjectEngine::DoSetErrorInfo(VCPROJ_E_INTERNAL_ERR, IDS_ERR_INTERNAL_ERROR);
	}

	CComBSTR bstrOutFile;
	CStringW strInt;
	hr = spPropContainer->GetStrProperty(VCWEBID_Output, &bstrOutFile);
	RETURN_ON_FAIL(hr);
	if (hr == S_FALSE)
		s_optHandler.GetDefaultValue(VCWEBID_Output, &bstrOutFile, spPropContainer);

	CComBSTR bstrOut2;
	hr = spPropContainer->Evaluate(bstrOutFile, &bstrOut2);
	RETURN_ON_FAIL(hr);
	CStringW strOutFile = bstrOut2;

	if (!rPath.CreateFromDirAndFilename(dirProject, strOutFile))
		return S_FALSE;

	return S_OK;
}

STDMETHODIMP CVCWebServiceProxyGeneratorTool::HasPrimaryOutputFromTool(IUnknown* pItem, VARIANT_BOOL bSchmoozeOnly, VARIANT_BOOL* pbHasPrimaryOutput)
{ 
	CHECK_POINTER_NULL(pbHasPrimaryOutput);
	if (bSchmoozeOnly)
		*pbHasPrimaryOutput = VARIANT_FALSE;	// not primary project output generator
	else
		*pbHasPrimaryOutput = VARIANT_TRUE;	// looking for primary *file* output, so yes, we create one

	return S_OK;
}

STDMETHODIMP CVCWebServiceProxyGeneratorTool::GetPrimaryOutputIDFromTool(IUnknown* pItem, VARIANT_BOOL bSchmoozeOnly, long* pnOutputID)
{
	CHECK_POINTER_NULL(pnOutputID);
	*pnOutputID = -1;

	if (bSchmoozeOnly)
		return S_FALSE;

	*pnOutputID = VCWEBID_Output;
	return S_OK;
}

STDMETHODIMP CVCWebServiceProxyGeneratorTool::GetDefaultOutputFileFormat(IUnknown* pItem, BSTR* pbstrOutMacro)
{	// macro to use for generating default output file if the original default isn't unique
	CHECK_POINTER_NULL(pbstrOutMacro);
	CComQIPtr<IVCPropertyContainer> spPropContainer = pItem;

	CComBSTR bstrOut;
	s_optHandler.GetDefaultValue(VCWEBID_Output, &bstrOut, spPropContainer);
	CStringW strOut = bstrOut;
	int idx = strOut.Find(L'.');
	if (idx >= 0)
	{
		CStringW strLeft, strRight;
		strLeft = strOut.Left(idx-1);
		strRight = strOut.Right(strOut.GetLength()-idx+1);
		strOut = strLeft;
		strOut += L"%d";
		strOut += strRight;
		bstrOut = strOut;
	}
	*pbstrOutMacro = bstrOut.Detach();

	return S_OK;
}

STDMETHODIMP CVCWebServiceProxyGeneratorTool::SetPrimaryOutputForTool(IUnknown* pItem, BSTR bstrFile)
{	// sets the primary output for a tool
	CComQIPtr<IVCPropertyContainer> spPropContainer = pItem;
	RETURN_ON_NULL2(spPropContainer, S_FALSE);		// nothing we can do

	CStringW strFileCheck = bstrFile;
	strFileCheck.TrimLeft();
	strFileCheck.TrimRight();
	if (strFileCheck.IsEmpty())
		return S_FALSE;

	// assuming OK to dirty since we shouldn't be here unless we got called by a wizard that already checked
	return spPropContainer->SetStrProperty(VCWEBID_Output, bstrFile);
}

void CVCWebServiceProxyGeneratorTool::SaveSpecialProps(IStream *xml, IVCPropertyContainer *pPropContainer)
{
	// GeneratedProxyLanguage
	CComVariant varLang;
	if (pPropContainer->GetLocalProp(VCWEBID_GeneratedProxyLanguage, &varLang) == S_OK && 
		(varLang.vt == VT_I2 || varLang.vt == VT_I4))
	{
		OLECHAR szEnumVal[10] = {0};
		NodeAttribute( xml, L"GeneratedProxyLanguage", CComBSTR( _itow( varLang.intVal, szEnumVal, 10 ) ) );
	}

	// URL
	CComVariant varURL;
	if (pPropContainer->GetLocalProp(VCWEBID_URL, &varURL) == S_OK && varURL.vt == VT_BSTR)
		NodeAttribute( xml, L"URL", varURL.bstrVal );
}


///////////////////////////////////////////////////////////////////////////////
// Affects our output?
STDMETHODIMP CVCWebServiceProxyGeneratorTool::AffectsOutput(long nPropID, VARIANT_BOOL* pbAffectsOutput)
{
	CHECK_POINTER_NULL(pbAffectsOutput);

	// change our outputs?
	switch (nPropID)
	{
	case VCWEBID_Output:
		*pbAffectsOutput = VARIANT_TRUE;
		break;
	default:
		*pbAffectsOutput = VARIANT_FALSE;
		break;
	}

	return S_OK;
}

STDMETHODIMP CVCWebServiceProxyGeneratorTool::CreatePageObject(IUnknown **ppUnk, CLSID*pCLSID, IVCPropertyContainer *pPropCntr, IVCSettingsPage *pPage )
{
	// Get the list of pages
	if( CLSID_WebUtilityGeneral == *pCLSID )
	{
		CPageObjectImpl< CVCWebServiceGeneralPage, VCWEBTOOL_MIN_DISPID, VCWEBTOOL_MAX_DISPID >::CreateInstance(ppUnk, pPropCntr, pPage);
	}
	else
	{
		return S_FALSE;
	}
		
	return S_OK;
}


GUID* CVCWebServiceProxyGeneratorTool::GetPageIDs()
{ 
	if (s_bPagesInit == FALSE)
	{
		s_pPages[0] = __uuidof(WebUtilityGeneral);
		s_pPages[1] = __uuidof(WebAdditionalOptions);
		s_bPagesInit = TRUE;
	}
	return s_pPages; 
}

STDMETHODIMP CVCWebServiceProxyGeneratorTool::CanScanForDependencies(VARIANT_BOOL* pbIsScannable)
{
	return COptionHandlerBase::GetValueFalse(pbIsScannable);
}


///////////////////////////////////////////////////////////////////////////////////////
// CVCWebServiceProxyGeneratorTool::CVCWebServiceProxyGeneratorTool
///////////////////////////////////////////////////////////////////////////////////////

// general 
LPCOLESTR CVCWebServiceProxyGeneratorTool::GetToolFriendlyName()
{
	InitToolName();
	return s_bstrToolName;
}

void CVCWebServiceProxyGeneratorTool::InitToolName()
{
	if (s_bstrToolName.Length() == 0)
	{
		if (!s_bstrToolName.LoadString(IDS_WEB_TOOLNAME))
			s_bstrToolName = szWebToolType;
	}
}

STDMETHODIMP CVCWebServiceProxyGeneratorTool::get_ToolName(BSTR* pbstrToolName)
{	// friendly name of tool, e.g., "C/C++ Compiler Tool"
	CHECK_POINTER_VALID( pbstrToolName );
	InitToolName();
	s_bstrToolName.CopyTo(pbstrToolName);
	return S_OK;
}

STDMETHODIMP CVCWebServiceProxyGeneratorTool::get_Output(BSTR *pbstrOutput)
{
	return ToolGetStrProperty(VCWEBID_Output, pbstrOutput);
}

STDMETHODIMP CVCWebServiceProxyGeneratorTool::put_Output(BSTR bstrOutput)
{
	CHECK_ZOMBIE(m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE);
	return m_spPropertyContainer->SetStrProperty( VCWEBID_Output, bstrOutput );
}

STDMETHODIMP CVCWebServiceProxyGeneratorTool::get_SuppressStartupBanner(VARIANT_BOOL* suppress)
{	// /nologo
	return ToolGetBoolProperty(VCWEBID_SuppressStartupBanner, suppress);
}

STDMETHODIMP CVCWebServiceProxyGeneratorTool::put_SuppressStartupBanner(VARIANT_BOOL suppress)
{
	CHECK_ZOMBIE(m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE);
	CHECK_VARIANTBOOL(suppress);
	return m_spPropertyContainer->SetBoolProperty(VCWEBID_SuppressStartupBanner, suppress);
}

STDMETHODIMP CVCWebServiceProxyGeneratorTool::get_GeneratedProxyLanguage(genProxyLanguage* language)	
{	// generated proxy language: native or managed C++
	return ToolGetIntProperty(VCWEBID_GeneratedProxyLanguage, (long *)language);
}

STDMETHODIMP CVCWebServiceProxyGeneratorTool::put_GeneratedProxyLanguage(genProxyLanguage language)
{
	CHECK_BOUNDS(StdEnumMin, WebProxyMax, language);
	CHECK_ZOMBIE(m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE);
	return m_spPropertyContainer->SetIntProperty(VCWEBID_GeneratedProxyLanguage, language);
}

STDMETHODIMP CVCWebServiceProxyGeneratorTool::get_AdditionalOptions(BSTR* options)
{	// any additional options
	return ToolGetStrProperty(VCWEBID_AdditionalOptions, options);
}

STDMETHODIMP CVCWebServiceProxyGeneratorTool::put_AdditionalOptions(BSTR options)
{
	CHECK_ZOMBIE(m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE);
	return m_spPropertyContainer->SetStrProperty( VCWEBID_AdditionalOptions, options );
}

STDMETHODIMP CVCWebServiceProxyGeneratorTool::get_URL(BSTR* url)
{	// any additional options
	return ToolGetStrProperty(VCWEBID_URL, url);
}

STDMETHODIMP CVCWebServiceProxyGeneratorTool::put_URL(BSTR url)
{
	CHECK_ZOMBIE(m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE);
	return m_spPropertyContainer->SetStrProperty( VCWEBID_URL, url );
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
// CVCWebServiceProxyGeneratorTool::IVCToolImpl
/////////////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CVCWebServiceProxyGeneratorTool::get_DefaultExtensions(BSTR* pVal)
{
	return DoGetDefaultExtensions(s_bstrExtensions, wszWebDefaultExtensions, pVal);
}

STDMETHODIMP CVCWebServiceProxyGeneratorTool::put_DefaultExtensions(BSTR newVal)
{
	s_bstrExtensions = newVal;
	return S_OK;
}

STDMETHODIMP CVCWebServiceProxyGeneratorTool::GetAdditionalOptionsInternal(IUnknown* pItem, VARIANT_BOOL bForBuild, VARIANT_BOOL bSkipLocal, 
	BSTR* pbstrAdditionalOptions)
{ 
	return GetProcessedAdditionalOptions(pItem, VCWEBID_AdditionalOptions, bForBuild, bSkipLocal, pbstrAdditionalOptions);
}

STDMETHODIMP CVCWebServiceProxyGeneratorTool::GetBuildDescription(IVCBuildAction* pAction, BSTR* pbstrBuildDescription)
{
	if (s_bstrBuildDescription.Length() == 0)
		s_bstrBuildDescription.LoadString(IDS_DESC_WEB_COMPILING);
	return s_bstrBuildDescription.CopyTo(pbstrBuildDescription);
}

STDMETHODIMP CVCWebServiceProxyGeneratorTool::get_ToolPathInternal(BSTR* pbstrToolPath)
{ 
	return get_ToolPath(pbstrToolPath);
}

STDMETHODIMP CVCWebServiceProxyGeneratorTool::get_Bucket(long *pVal)
{
	CHECK_POINTER_NULL( pVal );
	*pVal = BUCKET_WEB;
	return S_OK;
}

STDMETHODIMP CVCWebServiceProxyGeneratorTool::CreateToolObject(IVCPropertyContainer* pPropContainer, IVCToolImpl** ppToolObject)
{ 
	return CreateInstance(pPropContainer, ppToolObject); 
}

STDMETHODIMP CVCWebServiceProxyGeneratorTool::GetAdditionalIncludeDirectoriesInternal(IVCPropertyContainer* pPropContainer, BSTR* pbstrIncDirs)
{
	return E_NOTIMPL;
}

STDMETHODIMP CVCWebServiceProxyGeneratorTool::get_ToolShortName(BSTR* pbstrToolName)
{
	CHECK_POINTER_NULL(pbstrToolName);
	*pbstrToolName = SysAllocString( szWebToolShortName );
	return S_OK;
}

STDMETHODIMP CVCWebServiceProxyGeneratorTool::MatchName(BSTR bstrName, VARIANT_BOOL bFullOnly, VARIANT_BOOL* pbMatches)
{
	return DoMatchName(bstrName, szWebToolType, szWebToolShortName, pbMatches);
}

HRESULT CVCWebServiceProxyGeneratorTool::DoGetToolPath(BSTR* pbstrToolPath, IVCPropertyContainer* pPropContainer)
{
	CHECK_POINTER_NULL(pbstrToolPath);
	if (pPropContainer)
	{
		genProxyLanguage genProxy = genProxyNative;
		if (pPropContainer->GetIntProperty(VCWEBID_GeneratedProxyLanguage, (long *)&genProxy) == S_OK &&
			genProxy == genProxyManaged)
		{
			*pbstrToolPath = SysAllocString( szWebToolPathManaged );
			return S_OK;
		}
	}

	*pbstrToolPath = SysAllocString( szWebToolPathNative );
	return S_OK;
}

STDMETHODIMP CVCWebServiceProxyGeneratorTool::get_ToolPath(BSTR* pbstrToolPath)
{
	return DoGetToolPath(pbstrToolPath, m_spPropertyContainer);
}

STDMETHODIMP CVCWebServiceProxyGeneratorTool::get_PropertyOption(BSTR bstrProp, long dispidProp, BSTR *pVal)
{ 
	return E_NOTIMPL;
}


// CVCWebServiceGeneralPage
///////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CVCWebServiceGeneralPage::get_Output(BSTR *pbstrOutput)
{
	return ToolGetStrProperty(VCWEBID_Output, &(CVCWebServiceProxyGeneratorTool::s_optHandler), pbstrOutput);
}

STDMETHODIMP CVCWebServiceGeneralPage::put_Output(BSTR bstrOutput)
{
	return SetStrProperty( VCWEBID_Output, bstrOutput );
}

STDMETHODIMP CVCWebServiceGeneralPage::get_SuppressStartupBanner(enumSuppressStartupBannerBOOL* suppress)
{	// /nologo
	return GetEnumBoolProperty2(VCWEBID_SuppressStartupBanner, (long *)suppress);
}

STDMETHODIMP CVCWebServiceGeneralPage::put_SuppressStartupBanner(enumSuppressStartupBannerBOOL suppress)
{
	return SetBoolProperty(VCWEBID_SuppressStartupBanner, suppress);
}

STDMETHODIMP CVCWebServiceGeneralPage::get_GeneratedProxyLanguage(genProxyLanguage* language)
{	// generated proxy language: native or managed C++
	return ToolGetIntProperty(VCWEBID_GeneratedProxyLanguage, &(CVCWebServiceProxyGeneratorTool::s_optHandler), (long *)language);
}

STDMETHODIMP CVCWebServiceGeneralPage::put_GeneratedProxyLanguage(genProxyLanguage language)
{
	CHECK_BOUNDS(INHERIT_PROP_VALUE, WebProxyMax, language);
	return SetIntProperty(VCWEBID_GeneratedProxyLanguage, language);
}

void CVCWebServiceGeneralPage::GetBaseDefault(long id, CComVariant& varValue)
{
	CComBSTR bstrVal;
	VARIANT_BOOL bVal;
	switch (id)
	{
	case VCWEBID_Output:
		CVCWebServiceProxyGeneratorTool::s_optHandler.GetDefaultValue( id, &bstrVal );
		varValue = bstrVal;
		break;
	case VCWEBID_SuppressStartupBanner:
		CVCWebServiceProxyGeneratorTool::s_optHandler.GetDefaultValue( id, &bVal );
		varValue = bVal;
		break;
	default:
		CBase::GetBaseDefault(id, varValue);
		return;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\vcpb\projectoptions.cpp ===
// ProjectOptions.cpp : Implementation of the basic project options handler

#include "stdafx.h"
#include "ProjectOptions.h"

void COptionHandlerBase::AdvanceCommandLine(CStringW& rstrCmdLine, CStringW& rstrOption, LPCOLESTR szSep /* = L" "*/)
{
	if (rstrOption.IsEmpty())
		return;

	if (!rstrCmdLine.IsEmpty())
		rstrCmdLine += szSep;

	rstrCmdLine += rstrOption;
}

void COptionHandlerBase::GetMultiPropSeparator(long id, BSTR* pbstrPreferred, BSTR* pbstrAll)
{
	if (pbstrPreferred)
	{
		CComBSTR bstrPreferred = L";";
		*pbstrPreferred = bstrPreferred.Detach();
	}
	if (pbstrAll)
	{
		CComBSTR bstrAll = L";,";
		*pbstrAll = bstrAll.Detach();
	}
}

static const wchar_t* szScriptStart = L"\
<HTML>\r\n\
<HEAD>\r\n\
<meta name=vs_targetSchema content=\"HTML 4.0\">\r\n\
<META NAME=\"Generator\" Content=\"Microsoft Visual Studio 7.0\">\r\n\
<style>\r\n\
body { font-family: \"ButtonFont\"; font-size: 10pt }\r\n\
a:hover\t{ color:red; TEXT-DECORATION:underline; cursor:hand}\r\n\
a\t{ color:\"ButtonText\"; }\r\n\
</style>\r\n\
</HEAD>\r\n\
<script language=javascript>\r\n\
function onHelp(str)\r\n\
{\r\n\
\twindow.alert(str);\r\n\
}\r\n\
</script>\r\n\
<BODY bgcolor=\"ButtonFace\" leftmargin=0 rightmargin=0 topmargin=0>";

static const wchar_t* szScriptEnd = L"\r\n\
</BODY>\r\n\
</HTML>";

static const wchar_t* szScriptItem = L"\r\n<a title=\"%s | %s | %s\" onclick=\"onHelp('VC.Project.%s.%s')\" href=\"settingspage.htm\">%s</a>";


HRESULT COptionHandlerBase::GenerateCommandLine(IVCPropertyContainer* pPropContainer, BOOL bForDisplay, 
	commandLineOptionStyle fStyle, CStringW& rstrCmdLine)
{
	rstrCmdLine.Empty();
	m_strTrailingPartForDisplay.Empty();

	SOptionEntry* pOptionTable = GetOptionTable();
	if (pOptionTable == NULL)
	{
		VSASSERT(FALSE, "No option table!");
		return DoSetErrorInfo(VCPROJ_E_INTERNAL_ERR, IDS_ERR_INTERNAL_ERROR);
	}

	CStringW strOption;
	HRESULT hr = S_OK;
	
	for (int nIdx = 0; pOptionTable[nIdx].entryType != stdOptEnd && SUCCEEDED(hr); nIdx++)
	{
		if (pOptionTable[nIdx].condType == conditionProp)	// don't evaluate these directly
			continue;

		hr = ProcessEntry(pPropContainer, &pOptionTable[nIdx], strOption, fStyle, m_strTrailingPartForDisplay, TRUE, TRUE, 
			bForDisplay);
		if (hr == S_FALSE || FAILED(hr) || strOption.IsEmpty())
			continue;

		AdvanceCommandLine(rstrCmdLine, strOption);
	}

	if (SUCCEEDED(hr))	// ignore any spurious S_FALSE's lying around near the end of the table
	{
		hr = S_OK;
		if (bForDisplay)
		{
			CStringW strTmp;
			strTmp.Format(L"%s%s%s", szScriptStart, rstrCmdLine, szScriptEnd);
			rstrCmdLine = strTmp;
		}
	}
	return hr;
}

HRESULT COptionHandlerBase::ProcessEntry(IVCPropertyContainer* pPropContainer, SOptionEntry* pEntry, CStringW& rstrOption, 
	commandLineOptionStyle fStyle, CStringW& rstrTrailing, BOOL bIncludeOptionalParts /* = TRUE */, BOOL bIncludeSlash /* = TRUE */, 
	BOOL bForDisplay /* = FALSE */)
{
	rstrOption.Empty();

	CComVariant var;
	HRESULT hr = S_OK;
	if (pEntry->type == single)
		hr = pPropContainer->GetProp(pEntry->idOption, &var);
	else
	{
		hr = pPropContainer->GetEvaluatedMultiProp(pEntry->idOption, L";,", VARIANT_TRUE, 
			pEntry->type == multipleNoCase ? VARIANT_FALSE : VARIANT_TRUE, &var.bstrVal);
		var.vt = VT_BSTR;
	}
	if (hr == S_FALSE)	// default
	{
		CComVariant varDef;
		if (SetEvenIfDefault(&varDef, pEntry->idOption))
		{
			var = varDef;
		}
		else if (SynthesizeOptionIfNeeded(pPropContainer, pEntry->idOption))
		{
			var.Clear();
			if (!SynthesizeOption(pPropContainer, pEntry->idOption, var))
			{
				VSASSERT(FALSE, "Failed to synthesize a synthesizable option");
				return S_FALSE;
			}
		}
		else
			return S_FALSE;		// don't generate anything
		hr = S_OK;
	}
	else if (FAILED(hr))
	{																
		// if you hit here, then a property name in the option table doesn't exist in the property container we're 
		// generating a switch for.  Double check both the table and the property container ancestry.  (Most likely 
		// it is the table at fault.)
		VSASSERT(SUCCEEDED(hr), "Property name not in option table");
		return S_FALSE;
	}
	else if (OverrideOptionSet(pPropContainer, pEntry->idOption))
		return S_FALSE;	// don't generate anything

	BOOL bEvaluateCondition = FALSE;
	switch (pEntry->entryType)
	{
	case stdOptEnum:
		{
			VSASSERT(var.vt == VT_I4, "Wrong variant type!");
			int nVal = var.intVal;
			if (nVal < pEntry->nStartEnumRange || nVal > pEntry->nEndEnumRange)
			{
				VSASSERT(FALSE, "Enum value out of range!");
				return DoSetErrorInfo2(VCPROJ_E_INTERNAL_ERR, IDS_ERR_ENUM_OUT_OF_BOUNDS, pEntry->szOptionName);
			}
			bEvaluateCondition = (nVal >= pEntry->nFirstTrue);
			if (pEntry->entryType == stdOptEnum)
				EvaluateEnumAtIndex(nVal, pEntry->szOption, bIncludeSlash, rstrOption);
			else
				EvaluateSpecialEnumAtIndex(nVal, pEntry->szOption, pEntry->idOption, pPropContainer, bIncludeSlash, 
					rstrOption);
		}
		break;
	case stdOptBool:
		{
			VSASSERT(var.vt == VT_BOOL || var.vt == VT_I2, "Wrong variant type!");
			int nVal = (var.boolVal == VARIANT_TRUE) ? 1 : 0;
			bEvaluateCondition = (nVal == 1);
			EvaluateEnumAtIndex(nVal, pEntry->szOption, bIncludeSlash, rstrOption);
		}
		break;
	case stdOptBstr:
	case stdOptBstrNoQuote:
	case specOptBstr:
		{
			VSASSERT(var.vt == VT_BSTR || var.vt == VT_EMPTY, "Wrong variant type!");
			CStringW strTmp;
			if (var.vt == VT_BSTR)
				strTmp = var.bstrVal;
			strTmp.TrimLeft();
			strTmp.TrimRight();
			bEvaluateCondition = !strTmp.IsEmpty();
			if (bEvaluateCondition)
			{
				CComBSTR bstrIn = strTmp;
				CComBSTR bstrOut;
				if (SUCCEEDED(pPropContainer->Evaluate(bstrIn, &bstrOut)))
					strTmp = bstrOut;
				if (pEntry->entryType == specOptBstr)
					EvaluateSpecialString(strTmp, pEntry->type != single, pEntry->szOption, pEntry->idOption, pEntry->szOptionName, 
						pEntry->idOptionPage, pPropContainer, bIncludeSlash, bForDisplay, fStyle, rstrTrailing, rstrOption);
				else
					EvaluateString(strTmp, pEntry->type != single, pEntry->szOption, pEntry->szOptionName, pEntry->idOption, 
						pEntry->idOptionPage, bIncludeSlash, pEntry->entryType == stdOptBstr, bForDisplay, rstrOption);
			}
		}
		break;
	case stdOptInt:
	case noZeroOptInt:
		{
			VSASSERT(var.vt == VT_I4, "Wrong variant type!");
			long nVal = var.lVal;
			bEvaluateCondition = (nVal != 0);
			if (bEvaluateCondition || pEntry->entryType == stdOptInt)
				EvaluateInteger(nVal, pEntry->szOption, bIncludeSlash, rstrOption);
		}
		break;
	default:
		VSASSERT(FALSE, "Unhandled option type!");	// shouldn't be able to get here!
		return S_FALSE;
	}

	if (bEvaluateCondition && bIncludeOptionalParts && pEntry->condType != conditionNone
		&& pEntry->idConditionalOption != NoNextProp)
	{
		CLookupByDispidMap* pMap = GetOptionLookupByDispid();
		RETURN_ON_NULL2(pMap, hr);

		SOptionEntry* pCondEntry = pMap->FindOptionEntry(pEntry->idConditionalOption);
		CStringW strTmp;
		hr = ProcessEntry(pPropContainer, pCondEntry, strTmp, fStyle, rstrTrailing, bIncludeOptionalParts, FALSE);
		if (hr == S_OK)
			rstrOption += strTmp;
		else if (SUCCEEDED(hr))	// got this far, so there was a non-default...
			hr = S_OK;
	}

	if (bIncludeSlash && bForDisplay && pEntry->type == single && !rstrOption.IsEmpty())
		FormatScriptItem(pEntry->szOptionName, pEntry->idOption, pEntry->idOptionPage, rstrOption);

	return S_OK;
}

LPCOLESTR COptionHandlerBase::PageName(long idOptionPage)
{
	if (idOptionPage != m_idLastOptionPage)
	{
		m_strOptionPage.LoadString(idOptionPage);
		m_idLastOptionPage = idOptionPage;
	}
	return m_strOptionPage;
}

LPCOLESTR COptionHandlerBase::ToolUIName()
{
	VSASSERT(SectionID() != 0, "Hey, must provide a valid string ID for the tool's property page section!");
	if (m_strToolUIName.IsEmpty())
		m_strToolUIName.LoadString(SectionID());
	return m_strToolUIName;
}

void COptionHandlerBase::FormatScriptItem(const wchar_t* szOptionName, long idOption, long idOptionPage, CStringW& rstrOption)
{
	VSASSERT(idOption != SPECIAL_HYPERLINK, "Must override COptionHandlerBase::FormatScriptItem if using SPECIAL_HYPERLINK!");
	if (idOptionPage == NO_HYPERLINK)
		return;	// already looks appropriate in this case

	CStringW strTmp;
	CStringW strProp;
	if (idOption)
	{
		strProp.LoadString(idOption);
		long nColon = strProp.Find(L": ");
		if (nColon)
			strProp = strProp.Left(nColon-1);
		strProp.TrimLeft();
		strProp.TrimRight();
	}
	strTmp.Format(szScriptItem, ToolUIName(), PageName(idOptionPage), strProp, ToolString(), szOptionName, rstrOption);
	rstrOption = strTmp;
}

void COptionHandlerBase::EvaluateEnumAtIndex(int nVal, LPCOLESTR szOption, BOOL bIncludeSlash, CStringW& rstrSwitch)
{
	int nMarker = 0;
	LPCOLESTR szTmp = szOption;
	while (nMarker < nVal && szTmp)
	{
		if (*szTmp == L'|')
			nMarker++;
		szTmp++;
	}
	rstrSwitch = szTmp;
	nMarker = rstrSwitch.Find(L'|');
	if (nMarker >= 0)
		rstrSwitch = rstrSwitch.Left(nMarker);
	if (bIncludeSlash && !rstrSwitch.IsEmpty())
		rstrSwitch = L"/" + rstrSwitch;
}

void COptionHandlerBase::EvaluateString(CStringW& rstrVal, BOOL bIsMultiple, LPCOLESTR szOption, LPCOLESTR szOptionName, 
	long idOption, long idOptionPage, BOOL bIncludeSlash, BOOL bQuoteIt, BOOL bForDisplay, CStringW& rstrSwitch)
{
	rstrSwitch.Empty();

	if (rstrVal.IsEmpty())	// don't generate anything on empty strings
		return;

	LPOLESTR szPtr = rstrVal.GetBuffer(rstrVal.GetLength());
	int nLast = 0, nCurrent = 0;
	int nMax = rstrVal.GetLength();

	BOOL bInQuotes = FALSE;
	BOOL bValueQuoted = FALSE;
	BOOL bFirstOption = TRUE;
	while (nLast < nMax && nCurrent < nMax)
	{
		CStringW strTmp;
		// ignore leading whitespace or we'll end up missing starting "s
		if( *szPtr == L' ' )
		{
			while( *++szPtr == L' ' );
		}

		bValueQuoted = (*szPtr == L'"');
		if (bIsMultiple)
		{
			BOOL bFoundElement = FALSE;
			while (!bFoundElement && *szPtr)
			{
				if (!bInQuotes && CharIsSeparator(*szPtr))
				{
					strTmp = rstrVal.Mid(nLast, nCurrent-nLast);
					nLast = nCurrent + 1;
					bFoundElement = TRUE;
					szPtr++;	// skip past the separator now
					nCurrent++;
				}
				else
				{
					if (*szPtr == L'"')
						bInQuotes = !bInQuotes;
					nCurrent++;
					szPtr++;
				}
			}
			if (!bFoundElement)	// got to end of string
			{
				strTmp = rstrVal.Right(nMax-nLast);
				strTmp.TrimLeft();
				nLast = nMax;
			}
		}
		else
		{
			strTmp = rstrVal;
			nLast = nMax;
		}
		if (!strTmp.IsEmpty())
		{
			int nLen = strTmp.GetLength();
			if (bValueQuoted && nLen > 1 && strTmp[nLen-2] == L'\\')	// looks like an escaped quote
			{
				CStringW strLast = strTmp[nLen-1];
				strTmp = strTmp.Left(nLen-1);	// drop the ending quote
				strTmp += L"\\";				// force the existing backslash escaped
				strTmp += strLast;				// and add the quote back on
				nLen++;
			}
			else if (nLen > 1 && strTmp[nLen-1] == L'\\')
				strTmp += L"\\";	// force it escaped
			if (!bValueQuoted && bQuoteIt)	// gotta quote it
			{
				strTmp = L'"' + strTmp;
				strTmp += L'"';
			}
			CStringW strTmp2;
			strTmp2.Format(szOption, strTmp);
			if (bIncludeSlash)
				strTmp2 = L"/" + strTmp2;
			if (bIsMultiple && bForDisplay)
				FormatScriptItem(szOptionName, idOption, idOptionPage, strTmp2);
			if (!bFirstOption)
				rstrSwitch += L" ";
			bFirstOption = FALSE;
			rstrSwitch += strTmp2;
		}
	}

	rstrVal.ReleaseBuffer();
}

void COptionHandlerBase::EvaluateInteger(long nVal, LPCOLESTR szOption, BOOL bIncludeSlash, CStringW& rstrSwitch)
{
	rstrSwitch.Format(szOption, nVal);
	if (bIncludeSlash)
		rstrSwitch = L"/" + rstrSwitch;
}

BOOL COptionHandlerBase::GetIntermediateDirectoryForFileCfg(IVCPropertyContainer* pPropContainer, CStringW& rstrIntDir)
{
	rstrIntDir.Empty();
	VSASSERT(pPropContainer != NULL, "Property container required");
	RETURN_ON_NULL2(pPropContainer, FALSE);
	CComBSTR bstrIntDir;
	if (FAILED(pPropContainer->GetEvaluatedStrProperty(VCCFGID_IntermediateDirectory, &bstrIntDir)))
		return FALSE;
	rstrIntDir = bstrIntDir;
	return TRUE;
}

BOOL COptionHandlerBase::GetFileNameForFileCfg(IVCPropertyContainer* pPropContainer, CStringW& rstrFileName)
{
	VSASSERT(pPropContainer != NULL, "Property container required");
	RETURN_ON_NULL2(pPropContainer, FALSE);

	rstrFileName.Empty();
	CComBSTR bstrFileName;
	if (FAILED(pPropContainer->GetEvaluatedStrProperty(VCFILEID_Name, &bstrFileName)) || !bstrFileName)
		return FALSE;
	rstrFileName = bstrFileName;
	return TRUE;
}

BOOL COptionHandlerBase::GetProjectForFileCfg(IVCPropertyContainer* pPropContainer, VCProject** ppProject)
{	
	CComQIPtr<VCFileConfiguration> spFileConfig = pPropContainer;
	RETURN_ON_NULL2(spFileConfig, FALSE);
	CComPtr<IDispatch> spDispFile;
	if (FAILED(spFileConfig->get_File(&spDispFile)) || spDispFile == NULL)
		return FALSE;
	CComQIPtr<VCFile> spFile = spDispFile;
	RETURN_ON_NULL2(spFile, FALSE);
	CComPtr<IDispatch> spDispProject;
	if (FAILED(spFile->get_Project(&spDispProject)) || spDispProject == NULL)
		return FALSE;
	CComQIPtr<VCProject> spProject = spDispProject;
	RETURN_ON_NULL2(spProject, FALSE);
	return (SUCCEEDED(spProject.CopyTo(ppProject)));
}

BOOL COptionHandlerBase::SetBstrInVariant(IVCPropertyContainer* pPropContainer, CComBSTR& bstrVal, CComVariant& rvar)
{
	HRESULT hr = pPropContainer->Evaluate(bstrVal, &bstrVal);
	RETURN_ON_FAIL2(hr, FALSE);
	rvar = bstrVal;
	return TRUE;
}


HRESULT COptionHandlerBase::FindSwitch(IVCPropertyContainer* pPropContainer, BSTR bstrProp, DISPID dispidProp, 
	CStringW& rstrSwitch)
{
	SOptionEntry* pOption = NULL;
	CLookupByDispidMap* pDispidMap = GetOptionLookupByDispid();
	if (dispidProp)
	{
		pOption = pDispidMap->FindOptionEntry(dispidProp);
	}
	else
	{
		CLookupByPropertyNameMap* pNameMap = GetOptionLookupByPropertyName();
		if (pNameMap)
			pOption = pNameMap->FindOptionEntry(bstrProp);
	}

	if (pOption == NULL)
		return DoSetErrorInfo(VCPROJ_E_INTERNAL_ERR, IDS_ERR_INTERNAL_ERROR);

	if (pDispidMap)
	{
		while (pOption && pOption->entryType == conditionProp)
			pOption = pDispidMap->FindOptionEntry(pOption->idParentOption);
	}

	CStringW strTrailing;
	return ProcessEntry(pPropContainer, pOption, rstrSwitch, cmdLineForBuild, strTrailing);
}

void COptionHandlerBase::InitializeDispidMap(BOOL bForce /* = FALSE */)
{
	if (!bForce && DispidLookupIsInitialized())
		return;		// all done

	CLookupByDispidMap* pMap = GetOptionLookupByDispid(FALSE /* no init */);
	if (pMap == NULL)
		return;		// no map, nothing to do

	SOptionEntry* pOptionTable = GetOptionTable();
	if (pOptionTable == NULL)
		return;		// no option table, nothing to do

	if (bForce && DispidLookupIsInitialized())
	{
		pMap->RemoveAll();
		SetDispidLookupInitialized(FALSE);
	}

	HRESULT hr = S_OK;
	for (int nIdx = 0; pOptionTable[nIdx].entryType != stdOptEnd && SUCCEEDED(hr); nIdx++)
		pMap->SetAt(pOptionTable[nIdx].idOption, (void *)&pOptionTable[nIdx]);

	SetDispidLookupInitialized();
}

void COptionHandlerBase::InitializePropertyNameMap(BOOL bForce /* = FALSE */)
{
	if (!bForce && PropertyNameLookupIsInitialized())
		return;		// all done

	CLookupByPropertyNameMap* pMap = GetOptionLookupByPropertyName(FALSE /* no init */);
	if (pMap == NULL)
		return;		// no map, nothing to do

	SOptionEntry* pOptionTable = GetOptionTable();
	if (pOptionTable == NULL)
		return;		// no option table, nothing to do

	if (bForce && PropertyNameLookupIsInitialized())
	{
		pMap->RemoveAll();
		SetPropertyNameLookupInitialized(FALSE);
	}

	HRESULT hr = S_OK;
	for (int nIdx = 0; pOptionTable[nIdx].entryType != stdOptEnd && SUCCEEDED(hr); nIdx++)
		pMap->SetAt(pOptionTable[nIdx].szOptionName, (void *)&pOptionTable[nIdx]);

	SetPropertyNameLookupInitialized();
}

SOptionEntry* CLookupByDispidMap::FindOptionEntry(DISPID dispidProperty)
{
	SOptionEntry* pEntry;
	if (Lookup(dispidProperty, (void *&)pEntry))
		return pEntry;
	
	return NULL;
}

SOptionEntry* CLookupByPropertyNameMap::FindOptionEntry(BSTR bstrProperty)
{
	CStringW strTmp = bstrProperty;

	SOptionEntry* pEntry;
	if (Lookup(strTmp, (void *&)pEntry))
		return pEntry;
	
	return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\vcpb\sdltool.h ===
// SdlTool.h: Definition of the CVCWebServiceProxyGeneratorTool class
//
//////////////////////////////////////////////////////////////////////

#pragma once

#include "vctool.h"
#include "settingspage.h"

// classes in this header
class CVCWebServiceProxyGeneratorTool;
class CWebToolOptionHandler;
class CVCWebServiceGeneralPage;

class CWebToolOptionHandler : public COptionHandlerBase
{
public:
	DECLARE_OPTION_TABLE()

public:
	// default value handlers
	// string props
	virtual void GetDefaultValue( long id, BSTR *pVal, IVCPropertyContainer *pPropCnt = NULL );
	// integer props
	virtual void GetDefaultValue( long id, long *pVal, IVCPropertyContainer *pPropCnt = NULL );
	// boolean props
	virtual void GetDefaultValue( long id, VARIANT_BOOL *pVal, IVCPropertyContainer *pPropCnt = NULL );

protected:
	virtual BOOL SetEvenIfDefault(VARIANT *pVarDefault, long idOption);
	virtual BOOL SynthesizeOptionIfNeeded(IVCPropertyContainer* pPropContainer, long idOption);
	virtual BOOL SynthesizeOption(IVCPropertyContainer* pPropContainer, long idOption, CComVariant& rvar);
};

/////////////////////////////////////////////////////////////////////////////
// CVCWebServiceProxyGeneratorTool

class ATL_NO_VTABLE CVCWebServiceProxyGeneratorTool : 
	public IDispatchImpl<VCWebServiceProxyGeneratorTool, &IID_VCWebServiceProxyGeneratorTool, &LIBID_VCProjectEngineLibrary, PublicProjBuildTypeLibNumber,0, CVsTypeInfoHolder>, 
	public CComObjectRoot,
	public CVCToolImpl
{
public:
	CVCWebServiceProxyGeneratorTool() 
	{
		m_nLowKey = VCWEBTOOL_MIN_DISPID;
		m_nHighKey = VCWEBTOOL_MAX_DISPID;
		m_nDirtyKey = VCWEBID_CmdLineOptionsDirty;
		m_nDirtyOutputsKey = VCWEBID_OutputsDirty;
	}
	static HRESULT CreateInstance(IVCPropertyContainer* pPropContainer, IVCToolImpl** ppTool);

BEGIN_COM_MAP(CVCWebServiceProxyGeneratorTool)
	COM_INTERFACE_ENTRY(IVCToolImpl)
 	COM_INTERFACE_ENTRY(VCWebServiceProxyGeneratorTool)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE(CVCWebServiceProxyGeneratorTool) 

// VCWebServiceProxyGeneratorTool
public:
	// general
	STDMETHOD(get_Output)(BSTR *pbstrOutput);
	STDMETHOD(put_Output)(BSTR bstrOutput);
	STDMETHOD(get_SuppressStartupBanner)(VARIANT_BOOL* suppress);		// /nologo
	STDMETHOD(put_SuppressStartupBanner)(VARIANT_BOOL suppress);
	STDMETHOD(get_GeneratedProxyLanguage)(genProxyLanguage* language);	// generated proxy language: native or managed C++
	STDMETHOD(put_GeneratedProxyLanguage)(genProxyLanguage language);
	STDMETHOD(get_AdditionalOptions)(BSTR* options);	// any additional options
	STDMETHOD(put_AdditionalOptions)(BSTR options);
	STDMETHOD(get_URL)(BSTR* url);
	STDMETHOD(put_URL)(BSTR url);

 	STDMETHOD(get_ToolName)(BSTR* pbstrToolName);	// friendly name of tool, e.g., "C/C++ Compiler Tool"
	STDMETHOD(get_VCProjectEngine)(IDispatch** projEngine)	{ return DoGetVCProjectEngine(projEngine); }

	// Automation properties
	STDMETHOD(get_ToolPath)(BSTR *pVal);
	STDMETHOD(get_PropertyOption)(BSTR bstrProp, long dispidProp, BSTR *pVal);

// IVCToolImpl
public:
	STDMETHOD(get_DefaultExtensions)(BSTR* pVal);
	STDMETHOD(put_DefaultExtensions)(BSTR newVal);
	STDMETHOD(GetAdditionalOptionsInternal)(IUnknown* pItem, VARIANT_BOOL bForBuild, VARIANT_BOOL bSkipLocal, BSTR* pbstrAdditionalOptions);
	STDMETHOD(GetBuildDescription)(IVCBuildAction* pAction, BSTR* pbstrBuildDescription);
	STDMETHOD(get_ToolPathInternal)(BSTR* pbstrToolPath);
	STDMETHOD(get_Bucket)(long *pVal);
	STDMETHOD(GenerateOutput)(long type, IVCBuildActionList* plstActions, IVCBuildErrorContext* pEC);
	STDMETHOD(AffectsOutput)(long nPropID, VARIANT_BOOL* pbAffectsOutput);
	STDMETHOD(CreateToolObject)(IVCPropertyContainer* pPropContainer, IVCToolImpl** ppToolObject);
	STDMETHOD(GetAdditionalIncludeDirectoriesInternal)(IVCPropertyContainer* pPropContainer, BSTR* pbstrIncDirs);
	STDMETHOD(get_ToolShortName)(BSTR* pbstrToolName);
	STDMETHOD(get_ToolNameInternal)(BSTR* pbstrToolName) { return get_ToolName(pbstrToolName); }
	STDMETHOD(MatchName)(BSTR bstrName, VARIANT_BOOL bFullOnly, VARIANT_BOOL* pbMatches);
	STDMETHOD(CanScanForDependencies)(VARIANT_BOOL* pbIsScannable);
	STDMETHOD(GetCommandLineEx)(IVCBuildAction*, IVCBuildableItem* pBuildableItem, IVCBuildEngine* pBuildEngine, 
		IVCBuildErrorContext* pEC, BSTR* bstrCmd);
	STDMETHOD(CreatePageObject)(IUnknown **, CLSID*, IVCPropertyContainer *, IVCSettingsPage * );
	STDMETHOD(HasPrimaryOutputFromTool)(IUnknown* pItem, VARIANT_BOOL bSchmoozeOnly, VARIANT_BOOL* pbHasPrimaryOutput);	// returns TRUE only if tool generates a primary output (ex: linker)
	STDMETHOD(SetPrimaryOutputForTool)(IUnknown* pItem, BSTR bstrFile);		// sets the primary output for a tool
	STDMETHOD(GetPrimaryOutputIDFromTool)(IUnknown* pItem, VARIANT_BOOL bSchmoozeOnly, long* pnOutputID);	// return a value only if tool generates a primary output (ex: linker)
	STDMETHOD(GetDefaultOutputFileFormat)(IUnknown* pItem, BSTR* pbstrOutMacro);	// macro to use for generating default output file if the original default isn't unique

	STDMETHOD(get_ToolDisplayIndex)(long* pIndex)
	{
		CHECK_POINTER_NULL(pIndex);
		*pIndex = TOOL_DISPLAY_INDEX_WEB;
		return S_OK;
	}

	virtual long GetPageCount()	{ return 2; }
	virtual GUID* GetPageIDs();

// helpers
public:
	virtual COptionHandlerBase* GetOptionHandler() { return &s_optHandler; }
	virtual HRESULT GetPrimaryOutputFromTool(IUnknown* pItem, VARIANT_BOOL bSchmoozeOnly, CPathW& rPath);	// return a value only if tool generates a primary output (ex: linker)
	virtual LPCOLESTR GetToolFriendlyName();
	void InitToolName();
	virtual long GetToolID() { return IDS_WEBTOOL; }
	virtual void SaveSpecialProps(IStream *xml, IVCPropertyContainer *pPropCnt);

protected:
	HRESULT DoGetToolPath(BSTR* pbstrToolPath, IVCPropertyContainer* pPropContainer);

public:
	static CWebToolOptionHandler s_optHandler;

protected:
	static GUID s_pPages[2];
	static BOOL s_bPagesInit;
	static CComBSTR s_bstrBuildDescription;
	static CComBSTR s_bstrToolName;
	static CComBSTR s_bstrExtensions;
};

class ATL_NO_VTABLE CVCWebServiceGeneralPage :
	public IDispatchImpl<IVCWebServiceGeneralPage, &IID_IVCWebServiceGeneralPage, &LIBID_VCProjectEnginePrivateLibrary, PrivateProjBuildTypeLibNumber,0, CVsTypeInfoHolder>,
	public CPageObjectImpl<CVCWebServiceGeneralPage,VCWEBTOOL_MIN_DISPID,VCWEBTOOL_MAX_DISPID>,
	public CComObjectRoot
{
public:

BEGIN_COM_MAP(CVCWebServiceGeneralPage)
	COM_INTERFACE_ENTRY(IPerPropertyBrowsing)
	COM_INTERFACE_ENTRY(IVsPerPropertyBrowsing)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IVCPropertyContainer)
	COM_INTERFACE_ENTRY(IVCWebServiceGeneralPage)
END_COM_MAP()

	// IDispatch override
	STDMETHOD(Invoke)( DISPID dispid, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS *pdispParams, VARIANT *pvarResult, EXCEPINFO *pexcepInfo, UINT *puArgErr )
	{
		IDispatchImpl<IVCWebServiceGeneralPage, &IID_IVCWebServiceGeneralPage, &LIBID_VCProjectEnginePrivateLibrary, PrivateProjBuildTypeLibNumber,0, CVsTypeInfoHolder>::Invoke( dispid, riid, lcid, wFlags, pdispParams, pvarResult, pexcepInfo, puArgErr );
		return S_OK;
	}


// IVCWebServiceGeneralPage
public:
	// general 
	STDMETHOD(get_Output)(BSTR *pbstrOutput);
	STDMETHOD(put_Output)(BSTR bstrOutput);
	STDMETHOD(get_SuppressStartupBanner)(enumSuppressStartupBannerBOOL* suppress);		// /nologo
	STDMETHOD(put_SuppressStartupBanner)(enumSuppressStartupBannerBOOL suppress);
	STDMETHOD(get_GeneratedProxyLanguage)(genProxyLanguage* language);	// generated proxy language: native or managed C++
	STDMETHOD(put_GeneratedProxyLanguage)(genProxyLanguage language);
	void GetBaseDefault(long id, CComVariant& varValue);
};


#define WebProxyMax 1
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\vcpb\StdAfx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\vcpb\sdltoolbase.h ===
// garbage file
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\vcpb\settingspage.inl ===
// This file contains the method definitions for the template classes in SettingsPage.h

////////////////////////////////////////////////////////////////////////////////////////////////
// CSettingsPageBase

CSettingsPageBaseTemplate inline 
CSettingsPageBaseType::CSettingsPageBase() 
{
	m_dwTitleID = TTitleID;
	m_dwHelpFileID = IDS_VCPROJECT; // dummy ID to get the help method invoked
	m_bActive = FALSE;
	m_nLastObjects = 0;
	m_ppUnkArray = NULL;
}

CSettingsPageBaseTemplate inline 
CSettingsPageBaseType::~CSettingsPageBase() 
{
	if(m_ppUnkArray == NULL)
		return;

	UINT i;
	for (i = 0; i < m_nLastObjects; i++)
	{
		if( m_ppUnkArray[i] != NULL )
		{
			CComQIPtr<IVCStagedPropertyContainer> spStagedContainer = m_ppUnkArray[i];
			if (spStagedContainer)
				spStagedContainer->ReleaseStagedContainer();
			m_ppUnkArray[i]->Release();
		}
	}
	delete [] m_ppUnkArray;
	m_ppUnkArray = NULL;
}

CSettingsPageBaseTemplate inline 
IVSMDPropertyGrid* CSettingsPageBaseType::GetGrid()
{
	if( s_pGrid == NULL )
	{
		CComQIPtr<IVCProjectEngineImpl> spProjEngineImpl = g_pProjectEngine;
		VSASSERT(spProjEngineImpl != NULL, "Project engine isn't what we expect or is not initialized.  Deep, deep trouble.");
		RETURN_ON_NULL2(spProjEngineImpl, NULL);
		HRESULT hr = spProjEngineImpl->CreatePropertyGrid(&s_pGrid);
	}
	return s_pGrid;
}

CSettingsPageBaseTemplate inline 
STDMETHODIMP CSettingsPageBaseType::OnShowPage(BOOL fActivated)
{
	RETURN_ON_NULL2(fActivated, S_OK);
	RETURN_ON_NULL(GetGrid());
	s_pLastActive = this;

	HWND hwndGrid;
	RECT rectGrid;
	
	// get the font to use for dlgs
	CComQIPtr<IVCProjectEngineImpl> pProjEngImpl = g_pProjectEngine;
	RETURN_ON_NULL2(pProjEngImpl, E_NOINTERFACE);
	HFONT hFont;
	pProjEngImpl->GetDialogFont( FALSE, &hFont );
	SetFont( hFont );
	HDC dc = GetDC();
	SelectObject( dc, hFont );
	// get a base "unit" for sizing the dlg
	SIZE unit;
	GetTextExtentPoint32W( dc, L"X", 1, &unit );
	ReleaseDC(dc);
	DeleteObject( hFont );

	rectGrid.top = 0;
	rectGrid.left = 0;
	rectGrid.bottom = m_size.cy >= unit.cy * 24 ? m_size.cy : unit.cy * 24;
	rectGrid.right = m_size.cx >= unit.cx * 67 ? m_size.cx : unit.cx * 67;
	
	SetWindowPos( HWND_TOP, &rectGrid, SWP_FRAMECHANGED );

	GetGrid()->get_Handle(&hwndGrid);
	CWindow wndGrid;
	wndGrid.Attach(hwndGrid);
	wndGrid.SetParent(m_hWnd);

	VARIANT vt;
	VariantInit(&vt);
	V_VT(&vt) = VT_BOOL;
	V_BOOL(&vt) = VARIANT_FALSE;
	GetGrid()->SetOption(PGOPT_TOOLBAR, vt);
	wndGrid.SetWindowPos( HWND_TOP, &rectGrid, SWP_FRAMECHANGED );

	UpdateObjects();
	return S_OK;
}

CSettingsPageBaseTemplate inline 
STDMETHODIMP CSettingsPageBaseType::get_CategoryTitle( UINT iLevel, BSTR *pbstrCategory )
{
	if( (iLevel == 0) && TGroupID )
	{
		CComBSTR bstrTitle;
		bstrTitle.LoadString(TGroupID);
		*pbstrCategory = bstrTitle.Detach();
		return S_OK;
	}
	return S_FALSE;
}

CSettingsPageBaseTemplate inline 
STDMETHODIMP CSettingsPageBaseType::Apply(void)
{
	if (m_ppUnkArray)
	{
		UINT i;
		for (i = 0; i < m_nObjects; i++)
		{
			if( m_ppUnkArray && (m_ppUnkArray[i] != NULL) )
			{
				CComQIPtr<IVCPropertyContainer> pContainer = m_ppUnkArray[i];
				RETURN_ON_NULL(pContainer);
				HRESULT hr = pContainer->Commit();
				RETURN_ON_FAIL(hr);
			}
		}
	}
	SetDirty(FALSE);
	if (GetGrid())
		GetGrid()->Refresh();

	return S_OK;
}

CSettingsPageBaseTemplate inline 
STDMETHODIMP CSettingsPageBaseType::Help(LPCOLESTR pszHelpDir)
{
	CComQIPtr<IVCProjectEngineImpl> pProjEngineImpl = g_pProjectEngine;
	RETURN_ON_NULL(pProjEngineImpl);
	RETURN_ON_NULL(m_ppUnkArray);
	RETURN_ON_NULL(m_ppUnkArray[0]);

	CComQIPtr<IDispatch> pdisp = m_ppUnkArray[0];
	RETURN_ON_NULL(pdisp);

	CComPtr<ITypeInfo> pTypeInfo;
	HRESULT hr = pdisp->GetTypeInfo(0, LANG_NEUTRAL, &pTypeInfo);
	RETURN_ON_FAIL_OR_NULL(hr, pTypeInfo);

	CComBSTR bstrIFace;
	hr = pTypeInfo->GetDocumentation(-1, NULL, &bstrIFace, NULL, NULL);
	RETURN_ON_FAIL(hr);
	
	if( bstrIFace.Length() == 0 )
		return E_FAIL;

	CComBSTR bstrTopic;
	bstrTopic = L"VC.Project.";
	bstrTopic += bstrIFace;
	bstrTopic += L".";
	CComBSTR bstrProp;
	if( GetGrid() )
		GetGrid()->get_SelectedPropertyName(&bstrProp);
	bstrTopic += bstrProp;

	OpenTopic(pProjEngineImpl, bstrTopic);
	return S_OK;
}

CSettingsPageBaseTemplate inline 
STDMETHODIMP CSettingsPageBaseType::Deactivate(void)
{
	s_cGrids--;
	if (s_cGrids <= 0 && s_pGrid)
	{
		s_pGrid = NULL;
		s_cGrids = 0;
		s_pLastActive = NULL;
	}

	// Delete the page objects
	if(m_ppUnkArray)
	{
		UINT i;
		for (i = 0; i < m_nLastObjects; i++)
		{
			if( m_ppUnkArray[i] != NULL )
			{
				CComQIPtr<IVCPropertyContainer> spContainer = m_ppUnkArray[i];
				if (spContainer)
					spContainer->ReleaseStagedPropertyContainer();
				CComQIPtr<IVCPropertyPageObject> spPO = m_ppUnkArray[i];
				if( spPO )
					spPO->Close();
				m_ppUnkArray[i]->Release();
			}
		}
		delete [] m_ppUnkArray;
		m_ppUnkArray = NULL;
		m_nLastObjects = 0;
	}
	
	HRESULT hr = IPropertyPageImpl<T>::Deactivate();
	m_bActive = FALSE;
	return hr;
}

CSettingsPageBaseTemplate inline 
STDMETHODIMP CSettingsPageBaseType::Activate(HWND hWndParent, LPCRECT pRect, BOOL /* bModal */)
{
	ATLTRACE2(atlTraceControls,2,_T("IPropertyPageImpl::Activate\n"));

	if (pRect == NULL)
	{
		ATLTRACE2(atlTraceControls,2,_T("Error : Passed a NULL rect\n"));
		return E_POINTER;
	}
	m_hWnd = Create(hWndParent);
	s_cGrids++;

	if( m_nObjects == 0 )
		return S_OK;

	m_size.cx = pRect->right - pRect->left;
	m_size.cy = pRect->bottom - pRect->top;

	m_bActive = TRUE;

	return S_OK;
}

CSettingsPageBaseTemplate inline 
STDMETHODIMP CSettingsPageBaseType::GetPageInfo(PROPPAGEINFO* pPageInfo)
{
	// call through to atl parent version
	HRESULT hr = IPropertyPageImpl<T>::GetPageInfo( pPageInfo );

	// get the font to use for dlgs
	CComQIPtr<IVCProjectEngineImpl> pProjEngImpl = g_pProjectEngine;
	RETURN_ON_NULL2(pProjEngImpl, E_NOINTERFACE);
	HDC dc;
	dc = ::CreateDCW( L"DisPLAY", NULL, NULL, NULL );
	HFONT hFont;
	pProjEngImpl->GetDialogFont( FALSE, &hFont );
	SelectObject( dc, hFont );
	// get a base "unit" for sizing the dlg
	SIZE unit;
	GetTextExtentPoint32W( dc, L"X", 1, &unit );
	DeleteObject( hFont );
	DeleteDC( dc );

	pPageInfo->size.cx = m_size.cx >= unit.cx * 67 ? m_size.cx : unit.cx * 67;
	pPageInfo->size.cy = m_size.cy >= unit.cy * 24 ? m_size.cy : unit.cy * 24;

	return hr;
}

CSettingsPageBaseTemplate inline 
STDMETHODIMP CSettingsPageBaseType::SetObjects(ULONG nObjects, IUnknown **ppUnk)
{
	HRESULT hr;

	// call base-class implementation
	hr = IPropertyPageImpl<T>::SetObjects( nObjects, ppUnk );
	RETURN_ON_FAIL(hr);

	// update the objects if we have ever been activated.
	if( m_bActive )
		hr = UpdateObjects();
		
	return hr;
}

CSettingsPageBaseTemplate inline 
STDMETHODIMP CSettingsPageBaseType::TranslateAccelerator(MSG *pMsg)
{
	if ((pMsg->message < WM_KEYFIRST || pMsg->message > WM_KEYLAST) &&
		(pMsg->message < WM_MOUSEFIRST || pMsg->message > WM_MOUSELAST))
		return S_FALSE;

	return (::IsDialogMessage(m_hWnd, pMsg)) ? S_OK : S_FALSE;
}

CSettingsPageBaseTemplate 
inline STDMETHODIMP CSettingsPageBaseType::Dirty( void )
{
	SetDirty(TRUE);
	return S_OK;
}

CSettingsPageBaseTemplate inline 
STDMETHODIMP CSettingsPageBaseType::get_NumObjects( int* pNumObjects )
{
	*pNumObjects = m_nLastObjects;
	return S_OK;
}

CSettingsPageBaseTemplate inline 
STDMETHODIMP CSettingsPageBaseType::GetObject( int index, IUnknown **ppUnkObject )
{
	if( (DWORD)index >= m_nLastObjects )
	{
		*ppUnkObject = NULL;
		RETURN_INVALID();
	}
	else if (m_ppUnkArray == NULL)
	{
		*ppUnkObject = NULL;
		return E_UNEXPECTED;
	}
	else
	{
		CComPtr<IUnknown> pRet = m_ppUnkArray[index];
		*ppUnkObject = pRet.Detach();
		return S_OK;
	}
}

CSettingsPageBaseTemplate inline 
STDMETHODIMP CSettingsPageBaseType::Refresh( void )
{
	if (GetGrid())
		GetGrid()->Refresh();
	return S_OK;
}

CSettingsPageBaseTemplate inline 
STDMETHODIMP CSettingsPageBaseType::UpdateObjects( void )
{
	// we want some overlap in refcounts here, so start off by saving off the old list
	IUnknown ** ppOldUnkArray = m_ppUnkArray;
	UINT nOldLastObjects = m_nLastObjects;

	// Make a new list
	m_ppUnkArray = new IUnknown*[ m_nObjects ];
	memset(m_ppUnkArray, 0, m_nObjects*sizeof(IUnknown*));
	m_nLastObjects = m_nObjects;

	UINT i;
	for (i = 0; i < m_nObjects; i++)
	{
		//QI for IVCCfg
		CComQIPtr<IVCCfg> pVcCfg = m_ppUnk[i];
		if (pVcCfg == NULL)
		{
			VSFAIL("Hey, bad config sent to CSettingsPage!");
			continue;
		}
		CComPtr<IDispatch> pDisp;
		HRESULT hr = pVcCfg->get_Object( &pDisp );
		
		CComPtr<IVCSettingsPage> pPage;
		QueryInterface(__uuidof(IVCSettingsPage), (void**)&pPage);

		CComQIPtr<IVCPropertyContainer> pContainer = pDisp;
		CComQIPtr<IVCPropertyContainer> spLiveContainer;
		if (pContainer)
		{
			CComQIPtr<IVCStagedPropertyContainer> spStagedContainer;
			pContainer->GetStagedPropertyContainer(VARIANT_TRUE, &spStagedContainer);
			if (spStagedContainer)
				spStagedContainer->HoldStagedContainer();
			spLiveContainer = spStagedContainer;
		}
		if (spLiveContainer == NULL)
			spLiveContainer = pContainer;

		DoCreatePageObject(i, pDisp, spLiveContainer, pPage);
	}

		// Get Rid of the old list
	if (ppOldUnkArray)
	{
		for (i = 0; i < nOldLastObjects; i++)
		{
			if( ppOldUnkArray[i] != NULL )
			{
				CComQIPtr<IVCPropertyContainer> spContainer = ppOldUnkArray[i];
				if (spContainer)
					spContainer->ReleaseStagedPropertyContainer();
				ppOldUnkArray[i]->Release();
			}
		}
		delete [] ppOldUnkArray;
	}

if (GetGrid() && s_pLastActive == this)
	{
		if(m_nObjects && m_ppUnkArray && m_ppUnkArray[0])
		{
			CComPtr<ICategorizeProperties> pCat;
			m_ppUnkArray[0]->QueryInterface( IID_ICategorizeProperties, (void **)&pCat );

			if( pCat )
				GetGrid()->put_GridSort(PGSORT_CATEGORIZED);
			else
				GetGrid()->put_GridSort(PGSORT_NOSORT);
		}
		GetGrid()->SetSelectedObjects(m_nObjects, m_ppUnkArray);
		GetGrid()->Refresh();
	}

	return S_OK;
}

CSettingsPageBaseTemplate inline 
void CSettingsPageBaseType::DoCreatePageObject(UINT i, IDispatch* pDisp, IVCPropertyContainer* pLiveContainer, IVCSettingsPage* pPage)
{
	HRESULT hr = S_OK;
#ifdef AARDVARK
	CComQIPtr<IVCStyleSheetImpl> pStyle = pDisp;
	if (pStyle)
	{
		hr = pStyle->CreatePageObject(&m_ppUnkArray[i], (CLSID*)Tpclsid, pLiveContainer, pPage);
		return;
	}
#endif	// AARDVARK
	// Ask the Config to create the page object
	CComQIPtr<IVCConfigurationImpl> pCfg = pDisp;
	if( pCfg )
	{
		hr = pCfg->CreatePageObject(&m_ppUnkArray[i], (CLSID*)Tpclsid, pLiveContainer, pPage);
	} else {
		CComQIPtr<IVCFileConfigurationImpl> pCfg = pDisp;
		if( pCfg )
			hr = pCfg->CreatePageObject(&m_ppUnkArray[i], (CLSID*)Tpclsid, pLiveContainer, pPage);
		else
		{
			VSASSERT(FALSE, "Wrong kind of object!");
			m_ppUnkArray[i] = NULL;
		}

	}
}

////////////////////////////////////////////////////////////////////////////////////////////////
// CPageObjectImpl

CPageObjectImplTemplate inline /* static */
HRESULT CPageObjectImplType::CreateInstance(IUnknown **pI, IVCPropertyContainer *pContainer, IVCSettingsPage *pPage)
{
	HRESULT hr;
	CComObject<T> *pObj;
	hr = CComObject<T>::CreateInstance(&pObj);
	if (SUCCEEDED(hr))
	{
		pObj->QueryInterface(__uuidof(IUnknown), (void**)pI);
		pObj->m_pContainer = pContainer;
		pObj->m_pPage = pPage;
		pObj->ResetParentIfNeeded();
	}
	return hr;
}

CPageObjectImplTemplate inline
STDMETHODIMP CPageObjectImplType::Close()		// turn this object into a ZOMBIE
{
	m_pContainer = NULL;
	m_pPage = NULL;
	m_PropMap.RemoveAll();
	return S_OK;
}

CPageObjectImplTemplate inline
STDMETHODIMP CPageObjectImplType::Commit()
{
	CComQIPtr<IVCStagedPropertyContainer> spStagedContainer = m_pContainer;
	if (spStagedContainer)
		return spStagedContainer->CommitPropertyRange(nMin, nMax);

	VCPOSITION iter = m_PropMap.GetStartPosition();
	// iterate over each item in the map
	HRESULT hr = S_OK;
	while( iter )
	{
		long key;
		CComVariant varVal;
		m_PropMap.GetNextAssoc( iter, key, varVal );
		if( (varVal.vt == VT_I4 && varVal.intVal == INHERIT_PROP_VALUE) || (varVal.vt == VT_I2 && varVal.iVal == INHERIT_PROP_VALUE) || (varVal.vt == VT_BSTR && wcscmp( L"-2", varVal.bstrVal ) == 0) || (varVal.vt == VT_BSTR && SysStringLen( varVal.bstrVal ) == 0) )
			hr = m_pContainer->Clear(key);
		else
			hr = m_pContainer->SetProp( key, varVal );
		RETURN_ON_FAIL(hr);
	}
	m_PropMap.RemoveAll();

	return S_OK;
}

// this helper is for anybody who manipulates settings outside its own ID range (like the config general page does)
CPageObjectImplTemplate inline
HRESULT CPageObjectImplType::CommitSingleProp(long id)
{
	CComQIPtr<IVCStagedPropertyContainer> spStagedContainer = m_pContainer;
	if (spStagedContainer)
		return spStagedContainer->CommitPropertyRange(id, id);
	return S_OK;
}

CPageObjectImplTemplate inline
STDMETHODIMP CPageObjectImplType::ClearAll()
{
	CComQIPtr<IVCStagedPropertyContainer> spStagedContainer = m_pContainer;
	if (spStagedContainer)
		return spStagedContainer->ClearPropertyRange(nMin, nMax);

	m_PropMap.RemoveAll();
	return S_OK;
}

CPageObjectImplTemplate inline
STDMETHODIMP CPageObjectImplType::GetLocalProp(long id, /*[out]*/ VARIANT *pvarValue)
{
	CComQIPtr<IVCStagedPropertyContainer> spStagedContainer = m_pContainer;
	if (spStagedContainer)
		return m_pContainer->GetLocalProp(id, pvarValue);

	CComVariant varVal;
	if( !m_PropMap.Lookup(id, varVal) )
		return S_FALSE;

	if( (varVal.vt == VT_I4 && varVal.intVal == INHERIT_PROP_VALUE) || (varVal.vt == VT_I2 && varVal.iVal == INHERIT_PROP_VALUE) || (varVal.vt == VT_BSTR && wcscmp( L"-2", varVal.bstrVal ) == 0) )
		return S_FALSE;

	if(pvarValue)
		varVal.Detach(pvarValue);

	return S_OK;
}

CPageObjectImplTemplate inline
STDMETHODIMP CPageObjectImplType::GetParentProp(long id, VARIANT_BOOL bAllowInherit, VARIANT *pvarValue)
{
	CComQIPtr<IVCStagedPropertyContainer> spStagedContainer = m_pContainer;
	if (spStagedContainer)
		return m_pContainer->GetParentProp(id, bAllowInherit, pvarValue);

	return m_pContainer->GetProp( id, pvarValue );
}

CPageObjectImplTemplate inline
STDMETHODIMP CPageObjectImplType::Clear(long id)
{
	CComQIPtr<IVCStagedPropertyContainer> spStagedContainer = m_pContainer;
	if (spStagedContainer)
		m_pContainer->Clear(id);

	m_PropMap.RemoveKey(id);
	return S_OK;
}

CPageObjectImplTemplate inline
STDMETHODIMP CPageObjectImplType::SetProp(long id, VARIANT varValue)
{
	CComQIPtr<IVCStagedPropertyContainer> spStagedContainer = m_pContainer;

	// if we're not in "set prop now" mode and "Edit..." was chosen, 
	// we need to launch the dlg box to edit this property
	if( !s_bSetPropNow && varValue.vt == VT_BSTR && wcscmp( L"-3", varValue.bstrVal ) == 0 )
	{
		HRESULT hr;
		CComVariant var;
		CComBSTR bstrProp;
		CComBSTR bstrName, bstrDesc;

		// if this is a part of an "unfinished" multi-select, skip it
		// (only the first item in a multi-select actually brings up a dlg)
		if( s_cDlgs > 0 )
		{
			s_cDlgs--;
			return S_OK;
		}

		// allows a particular property page (such as the custom build tool page) to give us a
		// different loc id than the property id itself.
		long locId = KludgeLocID(id);

		GetLocalizedPropertyInfo( locId, LOCALE_USER_DEFAULT, &bstrName, &bstrDesc );

		// if this is the first item in a multi-select, don't get a
		// default value
		int cObjects = 0;
		m_pPage->get_NumObjects( &cObjects );
		if( cObjects > 1 )
		{
			s_cDlgs = cObjects;
			bstrProp = L"";
		}

		else
		{
			// get the prop value, if not local, then get from parent
			if (spStagedContainer)
				hr = m_pContainer->GetProp(id, &var);
			else
			{
				if( !m_PropMap.Lookup( id, var ) )
					hr = m_pContainer->GetProp( id, &var );
			}

			// if we didn't get a property, give the page a chance to tell us what the default would be
			if( hr == S_FALSE )
			{
				var = CComBSTR(L"");
				GetBaseDefault(id, var);
			}

			// if it was an inherit flag value, we need to get the inherited value instead
			if( var.bstrVal && wcscmp( L"-2", var.bstrVal ) == 0 )
			{
				// skip the parent and look it up one level higher still !
				if (spStagedContainer)
					hr = spStagedContainer->GetGrandParentProp(id, &var);
				else
					hr = m_pContainer->GetParentProp( id, VARIANT_TRUE /* allow inherit */, &var );
			}

			// again, if we didn't get a property, try to figure out what the default is
			// NOTE: we MUST do this check separately, or the grid will
			// throw up a msgbox that we don't want during the previous step.
			if( !var.bstrVal || hr == S_FALSE )
			{
				var = CComBSTR(L"");
				GetBaseDefault(id, var);	// allow the page to give us something for a default
			}

			bstrProp = var.bstrVal;
		}

		// get a pointer to the project engine impl
		CComQIPtr<IVCProjectEngineImpl> pProjEngImpl = g_pProjectEngine;
		RETURN_ON_NULL(pProjEngImpl);

		HWND hwndShell;
		pProjEngImpl->get_DialogOwner( &hwndShell );
		RETURN_ON_NULL(hwndShell);

		INT_PTR dlgRet = IDCANCEL;

		// single-line string prop editor
		// create the dlg with the value
		if (SupportsMultiLine(id))
		{
			CStringW strSeparator;
			GetPreferredSeparator(id, strSeparator);
			CSingleLineWithReturnsDlg dlg( m_pContainer, bstrName, bstrProp, strSeparator );
			pProjEngImpl->EnableModeless( FALSE );
			// run the dlg as modal (parented to the shell's main dlg owner window)
			dlgRet = dlg.DoModalW( hwndShell );
			if( dlgRet == IDOK )
				// get the prop
				var = dlg.GetPropertyString();
		}
		else	// multi-value, non-multi-prop
		{
			CSingleLineNoReturnsDlg dlg( m_pContainer, bstrName, bstrProp );
			pProjEngImpl->EnableModeless( FALSE );
			// run the dlg as modal (parented to the shell's main dlg owner window)
			dlgRet = dlg.DoModalW( hwndShell );
			if( dlgRet == IDOK )
				// get the prop
				var = dlg.GetPropertyString();
		}
		
		if( dlgRet == IDOK )
		{
			if( bstrProp != var.bstrVal )
			{
				// if we have multiple objects to set the prop on
				if( cObjects > 1 )
				{
					// set this property on each object
					s_bSetPropNow = true;
					for( int i = 0; i < cObjects; i++ )
					{
						CComPtr<IUnknown> pUnk;
						if( FAILED( m_pPage->GetObject( i, &pUnk ) ) || !pUnk )
							continue;
						CComQIPtr<IVCPropertyContainer> pPropCnt = pUnk;
						if( !pPropCnt )
							continue;
						pPropCnt->SetProp( id, var );
					}
					s_bSetPropNow = false;

					// reduce the number of dialogs that we have to skip
					s_cDlgs--;
				}
				else
				{
					// property changed and OK clicked, so apply the change.
					if( m_pPage )
						m_pPage->Dirty();
					if (spStagedContainer)
						m_pContainer->SetProp(id, var );
					else
						m_PropMap.SetAt(id, var );
				}
			}
		}

		pProjEngImpl->EnableModeless( TRUE );
		
		return S_OK;
	}
	
	// otherwise, set the prop directly
	if (m_pPage)
		m_pPage->Dirty();

	if (spStagedContainer)
		m_pContainer->SetProp(id, varValue);
	else
		m_PropMap.SetAt(id, varValue);
	return S_OK;
}

CPageObjectImplTemplate inline
STDMETHODIMP CPageObjectImplType::GetProp(long id, /*[in]*/ VARIANT *pVarValue)
{
	CComQIPtr<IVCStagedPropertyContainer> spStagedContainer = m_pContainer;
	if (spStagedContainer)
		return m_pContainer->GetProp(id, pVarValue);
	
	CComVariant varVal;
	if( m_PropMap.Lookup(id, varVal) )
	{
		if( (varVal.vt == VT_I4 && varVal.intVal == INHERIT_PROP_VALUE) || (varVal.vt == VT_I2 && varVal.iVal == INHERIT_PROP_VALUE) || (varVal.vt == VT_BSTR && wcscmp( L"-2", varVal.bstrVal ) == 0) )
		{
			// skip you parent and look it up one level higher still !
			HRESULT hr = m_pContainer->GetParentProp( id, VARIANT_TRUE /* allow inherit */, pVarValue );
			return hr;
		}
		else
		{
			varVal.Detach(pVarValue);
			return S_OK;
		}
	}
	HRESULT hr = m_pContainer->GetProp( id, pVarValue );
	return hr;
}

CPageObjectImplTemplate inline
STDMETHODIMP CPageObjectImplType::GetMultiProp(long id, LPCOLESTR szSeparator, VARIANT_BOOL bSkipLocal, BSTR *pbstrValue)
{
	CComQIPtr<IVCStagedPropertyContainer> spStagedContainer = m_pContainer;
	if (spStagedContainer)
		return m_pContainer->GetMultiProp(id, szSeparator, bSkipLocal, pbstrValue);

	CHECK_POINTER_NULL(pbstrValue);
	*pbstrValue = NULL;

	CComBSTR bstrVal;
	if (!bSkipLocal)
	{
		// look in here.
		CComVariant var;
		BOOL b;
		b = m_PropMap.Lookup(id, var);
		if( b )
			bstrVal = var.bstrVal;
	}
	
	// And! check your parents
	HRESULT hr;
	CComBSTR bstr;
	hr = m_pContainer->GetMultiProp( id, szSeparator, VARIANT_FALSE, &bstr );
	if( hr == S_OK )
	{
		bstrVal.Append(szSeparator);
		bstrVal.Append(bstr);
	}

	// did we get anything at all ?
	if( !bstrVal )
		return S_FALSE;
		
	*pbstrValue = bstrVal.Detach();
	return S_OK;
}

CPageObjectImplTemplate inline
STDMETHODIMP CPageObjectImplType::GetEvaluatedMultiProp(long id, LPCOLESTR szSeparator, VARIANT_BOOL bCollapseMultiples, VARIANT_BOOL bCaseSensitive, BSTR* pbstrValue)
{
	return GetMultiProp(id, szSeparator, VARIANT_FALSE, pbstrValue);
}

CPageObjectImplTemplate inline
STDMETHODIMP CPageObjectImplType::IsMultiProp(long id, VARIANT_BOOL* pbIsMultiProp)
{
	CHECK_POINTER_NULL(pbIsMultiProp);
	
	*pbIsMultiProp = VARIANT_FALSE;
	T* pT = static_cast<T*>(this);
	
	// what type is this?
	CComVariant var;
	HRESULT hr = CComDispatchDriver::GetProperty( pT, id, &var );
	RETURN_ON_FAIL2(hr, S_FALSE);

	switch( var.vt )
	{
		case VT_BSTR:
		{
			CComQIPtr<IDispatch> pdisp = pT;
			RETURN_ON_NULL(pdisp);
	
			CComPtr<ITypeInfo> pTypeInfo;
			HRESULT hr = pdisp->GetTypeInfo(0, LANG_NEUTRAL, &pTypeInfo);
			CComQIPtr<ITypeInfo2> pTypeInfo2 = pTypeInfo;
			RETURN_ON_FAIL_OR_NULL(hr, pTypeInfo2);
	
			// find the property we are interested in
			TYPEATTR *pTypeAttr;
			pTypeInfo2->GetTypeAttr(&pTypeAttr);				
			UINT nIndex = -1;
			FUNCDESC *pFuncDesc = NULL;
			for (int i = 7; i < pTypeAttr->cFuncs; i++) // Skip over IUnknown and IDispatch
			{
				// if we do not get the vardesc, just continue
				if (FAILED(pTypeInfo2->GetFuncDesc(i, &pFuncDesc)))
					continue;

				// always look for the put method
				if( id == pFuncDesc->memid && pFuncDesc->invkind == INVOKE_PROPERTYPUT)
				{
					CComVariant var2;
					// this call fails and variant is not set if the custom data is not found
					hr = pTypeInfo2->GetFuncCustData(i, GUID_MULTIEDIT, &var2);
					if( SUCCEEDED( hr ) && var2.vt != VT_EMPTY && var2.lVal == 1 )
						*pbIsMultiProp = VARIANT_TRUE;
					pTypeInfo2->ReleaseFuncDesc(pFuncDesc);
					break;
				}
				pTypeInfo2->ReleaseFuncDesc(pFuncDesc);
				pFuncDesc = NULL;
			}
			pTypeInfo2->ReleaseTypeAttr(pTypeAttr);
		}
	}
	return S_OK;
}

CPageObjectImplTemplate inline
STDMETHODIMP CPageObjectImplType::GetMultiPropSeparator(long id, BSTR* pbstrPreferred, BSTR* pbstrAll)
{
	CHECK_POINTER_NULL(pbstrPreferred);
	CHECK_POINTER_NULL(pbstrAll);
	CComBSTR bstrPreferred = L";";
	CComBSTR bstrAll = L";,";
	*pbstrPreferred = bstrPreferred.Detach();
	*pbstrAll = bstrAll.Detach();
	return S_OK;
}

CPageObjectImplTemplate inline
STDMETHODIMP CPageObjectImplType::GetStrProperty(long idProp, BSTR* pbstrValue)
{
	CComVariant var;
	HRESULT hr = GetProp(idProp, &var);
	if (hr == S_OK)
	{
		CComBSTR bstrVal = var.bstrVal;
		*pbstrValue = bstrVal.Detach();
	}
	return hr;
}

CPageObjectImplTemplate inline
STDMETHODIMP CPageObjectImplType::GetEvaluatedStrProperty(long idProp, BSTR* pbstrValue)
{
	return GetStrProperty(idProp, pbstrValue);
}

CPageObjectImplTemplate inline
STDMETHODIMP CPageObjectImplType::SetStrProperty(long idProp, BSTR bstrValue)
{
	CComVariant var( bstrValue );
	return SetProp(idProp, var);
}

CPageObjectImplTemplate inline
STDMETHODIMP CPageObjectImplType::GetIntProperty(long idProp, long* pnValue)
{
	CComQIPtr<IVCStagedPropertyContainer> spStagedContainer = m_pContainer;
	if (spStagedContainer)
		return m_pContainer->GetIntProperty(idProp, pnValue);

	CHECK_POINTER_NULL(pnValue);
	*pnValue = 0;

	CComVariant var;
	HRESULT hr = GetProp(idProp, &var);
	if (hr == S_OK)
		*pnValue = var.intVal;
	return hr;
}

CPageObjectImplTemplate inline
STDMETHODIMP CPageObjectImplType::SetIntProperty(long idProp, long nValue)
{
	CComVariant var(nValue);
	return SetProp(idProp, var);
}

CPageObjectImplTemplate inline
STDMETHODIMP CPageObjectImplType::GetBoolProperty(long idProp, VARIANT_BOOL* pbValue)
{
	CComQIPtr<IVCStagedPropertyContainer> spStagedContainer = m_pContainer;
	if (spStagedContainer)
		return m_pContainer->GetBoolProperty(idProp, pbValue);

	CHECK_POINTER_NULL(pbValue);
	*pbValue = VARIANT_FALSE;

	CComVariant var;
	HRESULT hr = GetProp(idProp, &var);
	if (hr == S_OK)
		*pbValue = var.boolVal;
	return hr;
}

CPageObjectImplTemplate inline
HRESULT CPageObjectImplType::GetEnumBoolProperty(long idProp, enumBOOL* pbValue)
{
	CHECK_POINTER_NULL(pbValue);
	*pbValue = (enumBOOL)VARIANT_FALSE;

	CComVariant var;
	HRESULT hr = GetProp(idProp, &var);
	if (hr == S_OK)
		*pbValue = (enumBOOL)var.boolVal;
	return hr;
}

CPageObjectImplTemplate inline
HRESULT CPageObjectImplType::GetEnumBoolProperty2(long idProp, long* pbValue, COptionHandlerBase* pOptHandler /* = NULL */)
{
	CHECK_POINTER_NULL(pbValue);
	*pbValue = (long)VARIANT_FALSE;

	CComVariant var;
	HRESULT hr = GetProp(idProp, &var);
	if (hr == S_FALSE)
	{
		var.vt = VT_I2;
		if (pOptHandler)
		{
			VARIANT_BOOL bVal = VARIANT_FALSE;
			pOptHandler->GetDefaultValue(idProp, &bVal, m_pContainer);
			var.boolVal = bVal;
		}
		else
		{
			var.lVal = 0;
			GetBaseDefault(idProp, var);
		}
	}
	if (SUCCEEDED(hr))	// INCLUDES S_FALSE
		*pbValue = (long)var.boolVal;
	return hr;
}

CPageObjectImplTemplate inline
HRESULT CPageObjectImplType::ToolGetIntProperty(long idProp, COptionHandlerBase* pOptHandler, long* pVal)
{
	CHECK_POINTER_NULL( pVal );
	HRESULT hr = GetIntProperty(idProp, pVal);
	if (hr == S_FALSE && pOptHandler)
		pOptHandler->GetDefaultValue( idProp, pVal, m_pContainer );
	return hr;
}

CPageObjectImplTemplate inline
HRESULT CPageObjectImplType::ToolGetStrProperty(long idProp, COptionHandlerBase* pOptHandler, BSTR* pVal, bool bLocalOnly /* = false */)
{
	CHECK_POINTER_NULL( pVal );
	HRESULT hr = S_OK;
	
	if (bLocalOnly)
	{
		CComVariant var;
		*pVal = NULL;
		if (m_pContainer->GetLocalProp(idProp, &var) != S_OK)
			hr = m_pContainer->GetParentProp(idProp, VARIANT_FALSE /* no inherit */, &var);
		if (hr == S_OK)
		{
			CComBSTR bstrProp = var.bstrVal;
			*pVal = bstrProp.Detach();
		}
	}
	else
	{
		hr = GetStrProperty(idProp, pVal);
		if (hr == S_FALSE && pOptHandler)
			pOptHandler->GetDefaultValue( idProp, pVal, m_pContainer );
	}
	return hr;
}

CPageObjectImplTemplate inline
HRESULT CPageObjectImplType::ToolGetBoolProperty(long idProp, COptionHandlerBase* pOptHandler, VARIANT_BOOL* pVal)
{
	CHECK_POINTER_NULL( pVal );
	HRESULT hr = GetBoolProperty(idProp, pVal);
	if (hr == S_FALSE && pOptHandler)
		pOptHandler->GetDefaultValue( idProp, pVal, m_pContainer );
	return hr;
}

CPageObjectImplTemplate inline
STDMETHODIMP CPageObjectImplType::SetBoolProperty(long idProp, VARIANT_BOOL bValue)
{
	if( bValue > 0 || bValue <-2 ) // allow "inherit" through
		RETURN_INVALID();
		
	CComVariant var(bValue);
	return SetProp(idProp, var);
}

CPageObjectImplTemplate inline
STDMETHODIMP CPageObjectImplType::HasLocalStorage(VARIANT_BOOL /* bForSave */, VARIANT_BOOL* pbHasLocalStorage)
{
	CHECK_POINTER_NULL(pbHasLocalStorage);
	*pbHasLocalStorage = VARIANT_TRUE;
	return S_OK;
}

CPageObjectImplTemplate inline
STDMETHODIMP CPageObjectImplType::GetStagedPropertyContainer(VARIANT_BOOL bCreateIfNecessary, IVCStagedPropertyContainer** ppStagedContainer)
{
	CHECK_POINTER_NULL(ppStagedContainer);
	*ppStagedContainer = NULL;
	return E_NOTIMPL;
}

CPageObjectImplTemplate inline
STDMETHODIMP CPageObjectImplType::ReleaseStagedPropertyContainer()		// intended for use ONLY by the staged property container itself
{ 
	CComQIPtr<IVCStagedPropertyContainer> spStagedContainer = m_pContainer;
	if( spStagedContainer )
		spStagedContainer->ReleaseStagedContainer();
	return S_OK; 
}

CPageObjectImplTemplate inline
STDMETHODIMP CPageObjectImplType::HideProperty( DISPID dispid, BOOL *pfHide)
{
	CHECK_POINTER_NULL(pfHide);
	*pfHide = FALSE;
	return E_NOTIMPL;
};

CPageObjectImplTemplate inline
STDMETHODIMP CPageObjectImplType::DisplayChildProperties( DISPID dispid, BOOL *pfDisplay)
{
	CHECK_POINTER_NULL(pfDisplay);
	*pfDisplay = FALSE;
	return S_OK;
}

CPageObjectImplTemplate inline
STDMETHODIMP CPageObjectImplType::GetLocalizedPropertyInfo( DISPID dispid, LCID localeID, BSTR *pbstrName, BSTR *pbstrDesc)
{
	T* pT = static_cast<T*>(this);

	CComQIPtr<IDispatch> pdisp = pT;
	RETURN_ON_NULL(pdisp);

	CComPtr<ITypeInfo> pTypeInfo;
	HRESULT hr = pdisp->GetTypeInfo(0, LANG_NEUTRAL, &pTypeInfo);
	CComQIPtr<ITypeInfo2> pTypeInfo2 = pTypeInfo;
	RETURN_ON_FAIL_OR_NULL(hr, pTypeInfo2);

	CComBSTR bstrDoc;
	hr = pTypeInfo2->GetDocumentation2(dispid, localeID, &bstrDoc, NULL, NULL);
	RETURN_ON_FAIL(hr);
	
	RETURN_ON_NULL(bstrDoc.m_str);

	LPOLESTR pDesc = wcsstr( bstrDoc, L": " );
	RETURN_ON_NULL(pDesc);

	int nSize = (int)(pDesc - bstrDoc);
	pDesc+=2;

	CComBSTR bstrName( nSize-1, bstrDoc );
	if (pbstrName != NULL)
		*pbstrName = bstrName.Detach();

	CComBSTR bstrDesc( pDesc );
	if (pbstrDesc != NULL)
		*pbstrDesc = bstrDesc.Detach();
	
	return S_OK;
}

CPageObjectImplTemplate inline
STDMETHODIMP CPageObjectImplType::HasDefaultValue( DISPID dispid, BOOL *pfDefault)
{
	CComQIPtr<IVCStagedPropertyContainer> spStagedContainer = m_pContainer;
	if (spStagedContainer)
		return spStagedContainer->HasDefaultValue(dispid, pfDefault);

	CHECK_POINTER_NULL(pfDefault);
	
	// Check if its here and not clear
	CComVariant varVal;
	if( m_PropMap.Lookup(dispid, varVal) )
	{
		if( (varVal.vt == VT_I4 && varVal.intVal == INHERIT_PROP_VALUE) || (varVal.vt == VT_I2 && varVal.iVal == INHERIT_PROP_VALUE) || (varVal.vt == VT_BSTR && wcscmp( L"-2", varVal.bstrVal ) == 0) )
		{
			*pfDefault = TRUE;
			return S_OK;
		}
		*pfDefault = FALSE;
		return S_OK;
	}
	// OK so is it in the parent ?
	HRESULT hr = m_pContainer->GetLocalProp( dispid, NULL );
	if( hr == S_OK )
	{
		*pfDefault = FALSE;
		return S_OK;
	}
	*pfDefault = TRUE;
	return S_OK;
}

CPageObjectImplTemplate inline
STDMETHODIMP CPageObjectImplType::IsPropertyReadOnly( DISPID dispid, BOOL *fReadOnly)
{
	CHECK_POINTER_NULL(fReadOnly);
	CStringW str;
	*fReadOnly = GetTruncatedStringForProperty(dispid, str);
	return S_OK;
}

CPageObjectImplTemplate inline
STDMETHODIMP CPageObjectImplType::GetDisplayString( DISPID dispID, BSTR *pBstr )
{
	CHECK_POINTER_NULL(pBstr)
	*pBstr = NULL;
			
	HRESULT hr;

	T* pT = static_cast<T*>(this);
	
	// what type is this?
	CComVariant var;
	hr = CComDispatchDriver::GetProperty( pT, dispID, &var );
	RETURN_ON_FAIL2(hr, S_FALSE);

	switch( var.vt )
	{
		case VT_BSTR:
		{
			// if it was a bstr, return it and let the default behavior happen
			CComBSTR bstrTemp = var.bstrVal;
			*pBstr = bstrTemp.Detach();
			return S_FALSE;
		}
		case VT_BOOL:
		{
			if( var.boolVal == VARIANT_TRUE )
			{
				CComBSTR bstrTrue;
				bstrTrue.LoadString(VCTDENUM_Yes);
				*pBstr = bstrTrue.Detach();
			}
			else 
			{
				CComBSTR bstrFalse;
				bstrFalse.LoadString(VCTDENUM_No);
				*pBstr = bstrFalse.Detach();
			}
			return S_OK;
		}
		case VT_I2:
		case VT_I4:
		{
			T* pT = static_cast<T*>(this);
		
			CComQIPtr<IDispatch> pdisp = pT;
			RETURN_ON_NULL(pdisp);
		
			CComPtr<ITypeInfo> pTypeInfo;
			HRESULT hr = pdisp->GetTypeInfo(0, LANG_NEUTRAL, &pTypeInfo);
			CComQIPtr<ITypeInfo2> pTypeInfo2 = pTypeInfo;
			RETURN_ON_FAIL_OR_NULL(hr, pTypeInfo2);
		
			// find the property we are interested in
			TYPEATTR *pTypeAttr;
			pTypeInfo2->GetTypeAttr(&pTypeAttr);
			UINT nIndex = -1;
			FUNCDESC *pFuncDesc = NULL;
			for (int i = 7; i < pTypeAttr->cFuncs; i++)		// Skip over IUnknown and IDispatch
			{
				// if we do not get the vardesc, just continue
				if (FAILED(pTypeInfo2->GetFuncDesc(i, &pFuncDesc)))
					continue;

				// always look for the put method
				if( dispID == pFuncDesc->memid && pFuncDesc->invkind == INVOKE_PROPERTYPUT)
				{
					break;
				}
				pTypeInfo2->ReleaseFuncDesc(pFuncDesc);
				pFuncDesc = NULL;
			}
			pTypeInfo2->ReleaseTypeAttr(pTypeAttr);
			RETURN_ON_NULL(pFuncDesc);
			
			// look at the first parameter
			TYPEDESC * pTypeDesc = &pFuncDesc->lprgelemdescParam->tdesc;
			HREFTYPE hrt = pTypeDesc->hreftype;

			CComPtr<ITypeInfo> pTypeInfoEnum;
			pTypeInfo2->GetRefTypeInfo(hrt, &pTypeInfoEnum);
			pTypeInfo2->ReleaseFuncDesc(pFuncDesc);

			CComQIPtr<ITypeInfo2> pTypeInfo2Enum = pTypeInfoEnum;
			RETURN_ON_NULL(pTypeInfo2Enum);

			TYPEATTR *pTypeAttrEnum = NULL;
			pTypeInfo2Enum->GetTypeAttr(&pTypeAttrEnum);
			RETURN_ON_NULL(pTypeAttrEnum);
				
			if( pTypeAttrEnum->typekind != TKIND_ENUM )
			{
				// this isn't an enum after all. It must be a number
				pTypeInfoEnum->ReleaseTypeAttr(pTypeAttrEnum);
				return S_FALSE;
			}

			// look for the enum value that this prop is set to.
			for (int j = 0; j < pTypeAttrEnum->cVars; j++)
			{
				CComBSTR	bstrVal;
				VARDESC		*pVarDesc;
				// if we do not get the vardesc, just continue
				if (FAILED(pTypeInfo2Enum->GetVarDesc(j, &pVarDesc)))
					continue;

				long lCurrentValue = pVarDesc->lpvarValue->lVal;
				if (lCurrentValue == var.lVal)
				{
					// we found it so return the string.
					CComBSTR bstrDoc;
					hr = pTypeInfo2Enum->GetDocumentation2(pVarDesc->memid, NULL, &bstrDoc, NULL, NULL);
					if( bstrDoc.m_str == NULL )
					{
						hr = pTypeInfo2Enum->GetDocumentation(pVarDesc->memid, &bstrDoc, NULL, NULL, NULL);
					}

					*pBstr = bstrDoc.Detach();
					pTypeInfoEnum->ReleaseVarDesc(pVarDesc);
					pTypeInfoEnum->ReleaseTypeAttr(pTypeAttrEnum);
					return hr;
				}
				else
				{
					pTypeInfoEnum->ReleaseVarDesc(pVarDesc);
				}
			}

			pTypeInfoEnum->ReleaseTypeAttr(pTypeAttrEnum);
			return S_FALSE;
		}
		default:
		{
			// unhandled type, do default
			return S_FALSE;
		}
	}
}

CPageObjectImplTemplate inline
STDMETHODIMP CPageObjectImplType::GetPredefinedStrings( DISPID dispID, CALPOLESTR *pCaStringsOut, CADWORD *pCaCookiesOut )
{
	CHECK_POINTER_NULL(pCaStringsOut)
	CHECK_POINTER_NULL(pCaCookiesOut)
	
	HRESULT hr;

	T* pT = static_cast<T*>(this);
	
	// what type is this?
	CComVariant var;
	hr = CComDispatchDriver::GetProperty( pT, dispID, &var );
	RETURN_ON_FAIL2(hr, S_FALSE);

	CComBSTR bstrInherit;
	CComPtr<IVCPropertyContainer> spContainer;
	CComQIPtr<IVCStagedPropertyContainer> spStagedContainer = m_pContainer;
	if (spStagedContainer)
		spStagedContainer->get_Parent(&spContainer);
	else
		spContainer = m_pContainer;

	CComQIPtr<VCConfiguration> pPrj = spContainer;
	if( pPrj )
		bstrInherit.LoadString(IDS_INHERITPRJDEF);
	else
		bstrInherit.LoadString(IDS_INHERITPRJ);

	CComBSTR bstrEdit;
	bstrEdit.LoadString(IDS_EDIT);

	pCaCookiesOut->cElems = 0;
	pCaCookiesOut->pElems = NULL;
	pCaStringsOut->cElems = 0;
	pCaStringsOut->pElems = NULL;

	BOOL bInherited;
	HasDefaultValue( dispID, &bInherited );
	
	switch( var.vt )
	{
		case VT_BOOL:
		{
			CComBSTR bstrTrue;
			bstrTrue.LoadString(VCTDENUM_Yes);
			CComBSTR bstrFalse;
			bstrFalse.LoadString(VCTDENUM_No);
			int nElems = 2;

			pCaCookiesOut->pElems = (DWORD*)CoTaskMemAlloc( nElems * sizeof(DWORD) );
			if(pCaCookiesOut->pElems)
			{
				pCaCookiesOut->pElems[0] = 0;
				pCaCookiesOut->pElems[1] = 1;
				pCaCookiesOut->cElems = nElems;
			}
			
			pCaStringsOut->pElems = (LPOLESTR*)CoTaskMemAlloc( nElems * sizeof(LPOLESTR) );
			if(pCaStringsOut->pElems)
			{
				pCaStringsOut->cElems = nElems;
				pCaStringsOut->pElems[0] = (LPOLESTR)CoTaskMemAlloc( (SysStringLen( bstrFalse ) + 1) * sizeof(OLECHAR) );
				wcscpy( pCaStringsOut->pElems[0], bstrFalse );
				pCaStringsOut->pElems[1] = (LPOLESTR)CoTaskMemAlloc( (SysStringLen( bstrTrue ) + 1) * sizeof(OLECHAR) );
				wcscpy( pCaStringsOut->pElems[1], bstrTrue );
			}
			return S_OK;
		}
		case VT_I2:
		case VT_I4:
		{
			T* pT = static_cast<T*>(this);
	
			CComQIPtr<IDispatch> pdisp = pT;
			RETURN_ON_NULL(pdisp);
	
			CComPtr<ITypeInfo> pTypeInfo;
			HRESULT hr = pdisp->GetTypeInfo(0, LANG_NEUTRAL, &pTypeInfo);
			CComQIPtr<ITypeInfo2> pTypeInfo2 = pTypeInfo;
			RETURN_ON_FAIL_OR_NULL(hr, pTypeInfo2);
	
			// find the property we are interested in
			TYPEATTR *pTypeAttr;
			pTypeInfo2->GetTypeAttr(&pTypeAttr);				
			UINT nIndex = -1;
			FUNCDESC *pFuncDesc = NULL;
			for (int i = 7; i < pTypeAttr->cFuncs; i++) // Skip over IUnknown and IDispatch
			{
				// if we do not get the vardesc, just continue
				if (FAILED(pTypeInfo2->GetFuncDesc(i, &pFuncDesc)))
					continue;

				// always look for the put method
				if( dispID == pFuncDesc->memid && pFuncDesc->invkind == INVOKE_PROPERTYPUT)
				{
					break;
				}
				pTypeInfo2->ReleaseFuncDesc(pFuncDesc);
				pFuncDesc = NULL;
			}
			pTypeInfo2->ReleaseTypeAttr(pTypeAttr);
			RETURN_ON_NULL(pFuncDesc);

			// Get the TypeInfo of the first (enum) argument
			TYPEDESC * pTypeDesc = &pFuncDesc->lprgelemdescParam->tdesc;
			HREFTYPE hrt = pTypeDesc->hreftype;
			if( hrt == NULL )
			{
				// this isn't an enum after all. It must be a number
				// determine if we can inherit and display option only if we
				// can
				if( bInherited == FALSE )
				{
					pCaCookiesOut->pElems = (DWORD*)CoTaskMemAlloc( sizeof(DWORD) );
					if(pCaCookiesOut->pElems)
					{
						pCaCookiesOut->cElems = 1;
						pCaCookiesOut->pElems[0] = INHERIT_PROP_VALUE;
					}

					pCaStringsOut->pElems = (LPOLESTR*)CoTaskMemAlloc( sizeof(LPOLESTR) );
					if(pCaStringsOut->pElems)
					{
						pCaStringsOut->cElems = 1;
						pCaStringsOut->pElems[0] = (LPOLESTR)CoTaskMemAlloc( (SysStringLen( bstrInherit ) + 1) * sizeof(OLECHAR) );
						wcscpy( pCaStringsOut->pElems[0], bstrInherit );
					}
				}
				return S_OK;
			}

			CComPtr<ITypeInfo> pTypeInfoEnum;
			pTypeInfo2->GetRefTypeInfo(hrt, &pTypeInfoEnum);
			pTypeInfo2->ReleaseFuncDesc(pFuncDesc);

			CComQIPtr<ITypeInfo2> pTypeInfo2Enum = pTypeInfoEnum;
			RETURN_ON_NULL(pTypeInfo2Enum);

			TYPEATTR *pTypeAttrEnum = NULL;
			pTypeInfo2Enum->GetTypeAttr(&pTypeAttrEnum);
			RETURN_ON_NULL(pTypeAttrEnum);
			
			if( pTypeAttrEnum->typekind != TKIND_ENUM )
			{
				// error condition should have been handled as "just a number"
				return S_OK;
			}

			// Generate the list of enum values
			int n = pTypeAttrEnum->cVars;
			if( bInherited == FALSE )
			{
				n++;
			}

			pCaCookiesOut->pElems = (DWORD*)CoTaskMemAlloc( n * sizeof(DWORD) );
			if(pCaCookiesOut->pElems)
				pCaCookiesOut->cElems = n;
			pCaStringsOut->pElems = (LPOLESTR*)CoTaskMemAlloc( n * sizeof(LPOLESTR) );
			if( pCaStringsOut->pElems )
				pCaStringsOut->cElems = n;
				
			if( pCaStringsOut->cElems && pCaCookiesOut->cElems )
			{
				for (int j = 0; j < pTypeAttrEnum->cVars; j++)
				{
					CComBSTR	bstrVal;
					VARDESC		*pVarDesc;
					// if we do not get the vardesc, just continue
					if (FAILED(pTypeInfo2Enum->GetVarDesc(j, &pVarDesc)))
					{
						// REVIEW(kperry): is it OK to have NULLs in the array?
						pCaCookiesOut->pElems[j] = 0;
						pCaStringsOut->pElems[j] = NULL;
						continue;
					}
	
					// try to get the localized name if possible.
					CComBSTR bstrDoc;
					GetLocalizedName(dispID, pVarDesc->memid, pTypeInfo2Enum, pVarDesc->lpvarValue->lVal, bstrDoc);

					// now fill in the element in the return array.
					pCaCookiesOut->pElems[j] = pVarDesc->lpvarValue->lVal;
					pCaStringsOut->pElems[j] = (LPOLESTR)CoTaskMemAlloc( (bstrDoc.Length()+1) * sizeof(OLECHAR) );
					wcscpy( pCaStringsOut->pElems[j], bstrDoc );
			
					pTypeInfoEnum->ReleaseVarDesc(pVarDesc);
				}
				
				// now add the <inherit> value
				if( bInherited == FALSE )
				{
					// now fill in the lement in the return array.
					pCaCookiesOut->pElems[n-1] = INHERIT_PROP_VALUE;
					pCaStringsOut->pElems[n-1] = (LPOLESTR)CoTaskMemAlloc( (bstrInherit.Length()+1) * sizeof(OLECHAR) );
					wcscpy( pCaStringsOut->pElems[n-1], bstrInherit );
				}
			}

			pTypeInfoEnum->ReleaseTypeAttr(pTypeAttrEnum);
			return S_OK;
		}
		case VT_BSTR:
		{
			if( MapPropertyToBuilder( dispID, NULL, NULL, NULL ) == S_OK )
				return S_OK;

			// determine if we can inherit and display option only if we
			// can
			if( bInherited == FALSE )
			{
				pCaCookiesOut->pElems = (DWORD*)CoTaskMemAlloc( 2* sizeof(DWORD) );
				if(pCaCookiesOut->pElems)
				{
					pCaCookiesOut->cElems = 2;
					pCaCookiesOut->pElems[0] = INHERIT_PROP_VALUE;
					pCaCookiesOut->pElems[1] = EDIT_PROP_VALUE;
				}

				pCaStringsOut->pElems = (LPOLESTR*)CoTaskMemAlloc( 2 * sizeof(LPOLESTR) );
				if( pCaStringsOut->pElems )
				{
					pCaStringsOut->cElems = 2;
					pCaStringsOut->pElems[0] = (LPOLESTR)CoTaskMemAlloc( (SysStringLen( bstrInherit ) + 1) * sizeof(OLECHAR) );
					wcscpy( pCaStringsOut->pElems[0], bstrInherit );
					pCaStringsOut->pElems[1] = (LPOLESTR)CoTaskMemAlloc( (SysStringLen( bstrEdit ) + 1) * sizeof(OLECHAR) );
					wcscpy( pCaStringsOut->pElems[1], bstrEdit );
				}
				return S_OK;
			}
			else
			{
				pCaCookiesOut->pElems = (DWORD*)CoTaskMemAlloc( sizeof(DWORD) );
				if(pCaCookiesOut->pElems)
				{
					pCaCookiesOut->cElems = 1;
					pCaCookiesOut->pElems[0] = EDIT_PROP_VALUE;
				}

				pCaStringsOut->pElems = (LPOLESTR*)CoTaskMemAlloc( sizeof(LPOLESTR) );
				if(pCaStringsOut->pElems)
				{
					pCaStringsOut->cElems = 1;
					pCaStringsOut->pElems[0] = (LPOLESTR)CoTaskMemAlloc( (SysStringLen( bstrEdit ) + 1) * sizeof(OLECHAR) );
					wcscpy( pCaStringsOut->pElems[0], bstrEdit );
				}
				return S_OK;
			}
		}
		default:
		{
			// unhandled type, do default
			return S_FALSE;
		}
	}
	return E_FAIL;
}

CPageObjectImplTemplate inline
STDMETHODIMP CPageObjectImplType::GetPredefinedValue( DISPID dispID, DWORD dwCookie, VARIANT* pVarOut )
{
	CHECK_POINTER_NULL(pVarOut)
	
	HRESULT hr;
	T* pT = static_cast<T*>(this);
	
	// what type is this?
	CComVariant var;
	hr = CComDispatchDriver::GetProperty( pT, dispID, &var );
	RETURN_ON_FAIL2(hr, S_FALSE);
	
	CComVariant varOut;
	
	switch( var.vt )
	{
	// boolean
	case VT_BOOL:
	{
		if( dwCookie == 0 )
		{
			// varOut.boolVal = VARIANT_FALSE;
			CComBSTR bstrFalse(L"False");
			varOut = bstrFalse;
		}
		else if( dwCookie == 1 )
		{
			CComBSTR bstrTrue(L"True");
			varOut = bstrTrue;
			// varOut.boolVal = VARIANT_TRUE;
			// varOut = L"True";
		}
		break;
	}
	case VT_I2:
	case VT_I4:
	{
		// the cookie is always == the enum value
		varOut = (int)dwCookie; // unsigned, to signed conversion intentional.
		break;
	}
	case VT_BSTR:
		// 0 indicates string
		if( dwCookie == 0 )
			varOut = var;
		else
			varOut = (int)dwCookie;
		break;
	default:
		// unhandled type, do default
		return S_FALSE;
	}
	varOut.Detach(pVarOut);
	return S_OK;
}

CPageObjectImplTemplate inline
STDMETHODIMP CPageObjectImplType::MapPropertyToBuilder( LONG dispid, LONG *pdwCtlBldType, BSTR *pbstrGuidBldr, VARIANT_BOOL *pfRetVal )
{
	HRESULT hr = S_OK;
	const wchar_t *szGuid = NULL;
	VARIANT_BOOL bIsMulti = VARIANT_FALSE;
	IsMultiProp( dispid, &bIsMulti );
	if ( UseDirectoryPickerDialog( dispid ) )
	{
		szGuid = L"{7E23E102-4A22-4764-B6A5-E7ED5E2F3C79}";
	}
	else if( bIsMulti == VARIANT_TRUE )
	{
		szGuid = L"{7E23E103-4A22-4764-B6A5-E7ED5E2F3C79}";
	}
	else if( UseCommandsDialog( dispid ) )
	{
		szGuid = L"{7E23E104-4A22-4764-B6A5-E7ED5E2F3C79}";
	}
	else if ( UseSinglePropDirectoryPickerDialog( dispid ))
	{
		szGuid = L"{7E23E105-4A22-4764-B6A5-E7ED5E2F3C79}";
	}
	else if ( UseMultiLineNoInheritDialog( dispid ))
	{
		szGuid = L"{7E23E106-4A22-4764-B6A5-E7ED5E2F3C79}";
	}
	else if( IsFile( dispid ) )
	{
		szGuid = L"{7E23E107-4A22-4764-B6A5-E7ED5E2F3C79}";
	}
	else if( IsDir( dispid ) )
	{
		szGuid = L"{7E23E108-4A22-4764-B6A5-E7ED5E2F3C79}";
	}
	else
		hr = S_FALSE;

	if( hr == S_OK )
	{
		if( pfRetVal != NULL )
			*pfRetVal = VARIANT_TRUE;
		if( pdwCtlBldType != NULL )
			*pdwCtlBldType = CTLBLDTYPE_FINTERNALBUILDER;
		if( pbstrGuidBldr != NULL )
			*pbstrGuidBldr = SysAllocString(szGuid);
	}
	else
	{
		if( pfRetVal != NULL )
			*pfRetVal = VARIANT_FALSE;
	}
	
	return hr;
}

CPageObjectImplTemplate inline
STDMETHODIMP CPageObjectImplType::ExecuteBuilder( LONG dispid, BSTR bstrGuidBldr, IDispatch *pdispApp, 
	LONG_PTR hwndBldrOwner, VARIANT *pvarValue, VARIANT_BOOL *pfRetVal )
{
	HRESULT hr = S_OK;
	CComVariant var;
	var.Attach( pvarValue );

	CComQIPtr<IVCProjectEngineImpl> pProjEngImpl = g_pProjectEngine;
	RETURN_ON_NULL2(pProjEngImpl, E_NOINTERFACE);

	CComBSTR bstrName, bstrDesc, bstrInherit;
	GetLocalizedPropertyInfo( dispid, LOCALE_USER_DEFAULT, &bstrName, &bstrDesc );
	// get the prop value
	CComBSTR bstrProp = (var.vt == VT_BSTR) ? var.bstrVal : L"";

	// get the hwnd for the shell
	HWND hwndShell;
	pProjEngImpl->get_DialogOwner( &hwndShell );
	RETURN_ON_NULL(hwndShell);

	if( wcscmp(bstrGuidBldr, L"{7E23E102-4A22-4764-B6A5-E7ED5E2F3C79}") == 0 || 
		wcscmp(bstrGuidBldr, L"{7E23E103-4A22-4764-B6A5-E7ED5E2F3C79}") == 0 )
	{
		// get the "inherit from XXXX" string for this prop
		CComPtr<IVCPropertyContainer> spContainer;
		CComQIPtr<IVCStagedPropertyContainer> spStagedContainer = m_pContainer;
		if (spStagedContainer)
			spStagedContainer->get_Parent(&spContainer);
		else
			spContainer = m_pContainer;
		CComQIPtr<VCConfiguration> pPrj = spContainer;
		if( pPrj )
			bstrInherit.LoadString( IDS_INHERITPRJDEF2 );
		else
			bstrInherit.LoadString( IDS_INHERITPRJ2 );

		// create the dlg with the value
		CComVariant var2;
		if (m_pContainer->GetLocalProp(dispid, &var2) != S_OK)
			m_pContainer->GetParentProp(dispid, VARIANT_FALSE /* no inherit */, &var2);
		CComBSTR bstrLocalOnly;
		if (var2.vt == VT_BSTR)
			bstrLocalOnly = bstrProp;
		BOOL bOK = FALSE;
		if (wcscmp(bstrGuidBldr, L"{7E23E102-4A22-4764-B6A5-E7ED5E2F3C79}") == 0)	// using directory picker
		{
			CMultiDirectoryPickerEditorDlg dlg(m_pContainer, dispid, bstrName, bstrLocalOnly, bstrInherit);
			pProjEngImpl->EnableModeless( FALSE );
			// run the dlg as modal
			bool bAlreadyRun = false;
			if (m_pContainer)
			{
				CComBSTR bstrProjDir;
				m_pContainer->GetStrProperty(VCPROJID_ProjectDirectory, &bstrProjDir);
				if (bstrProjDir.Length())
				{
					CCurDirW dir(bstrProjDir);
					bOK = ( dlg.DoModalW( hwndShell ) == IDOK );
					bAlreadyRun = true;
				}
			}
			if (!bAlreadyRun)
				bOK = ( dlg.DoModalW( hwndShell ) == IDOK );
			if (bOK)
				var = dlg.GetPropertyString();
		}
		else	// using multi-prop string editor
		{
			CMultiLineDlg dlg( m_pContainer, dispid, bstrName, bstrLocalOnly, bstrInherit );
			pProjEngImpl->EnableModeless( FALSE );
			// run the dlg as modal
			bOK = ( dlg.DoModalW( hwndShell ) == IDOK );
			if (bOK)
				var = dlg.GetPropertyString();
		}
		if (bOK)
		{
			// set the prop
			if( pfRetVal )
				*pfRetVal = VARIANT_TRUE;
		}
		else
		{
			var.Clear();
			if( pfRetVal )
				*pfRetVal = VARIANT_FALSE;
		}
	}
	else if( wcscmp(bstrGuidBldr, L"{7E23E104-4A22-4764-B6A5-E7ED5E2F3C79}") == 0 )
	{
		// create the dlg with the value
		CCommandsDlg dlg( m_pContainer, bstrName, bstrProp );
		pProjEngImpl->EnableModeless( FALSE );
		// run the dlg as modal (parented to the shell's main dlg owner window)
		if( dlg.DoModalW( hwndShell ) == IDOK )
		{
			// set the prop
			var = dlg.GetPropertyString();
			if( pfRetVal )
				*pfRetVal = VARIANT_TRUE;
		}
		else
		{
			var.Clear();
			if( pfRetVal )
				*pfRetVal = VARIANT_FALSE;
		}
	}
	else if( wcscmp(bstrGuidBldr, L"{7E23E105-4A22-4764-B6A5-E7ED5E2F3C79}") == 0 )
	{
		// create the dlg with the value
		CSingleDirectoryPickerEditorDlg dlg( m_pContainer, bstrName, bstrProp );
		pProjEngImpl->EnableModeless( FALSE );
		// run the dlg as modal (parented to the shell's main dlg owner window)
		if( dlg.DoModalW( hwndShell ) == IDOK )
		{
			// set the prop
			var = dlg.GetPropertyString();
			if( pfRetVal )
				*pfRetVal = VARIANT_TRUE;
		}
		else
		{
			var.Clear();
			if( pfRetVal )
				*pfRetVal = VARIANT_FALSE;
		}
	}
	else if( wcscmp(bstrGuidBldr, L"{7E23E106-4A22-4764-B6A5-E7ED5E2F3C79}") == 0 )
	{
		// create the dlg with the value
		CMultiLineNoInheritDlg dlg( m_pContainer, bstrName, bstrProp );
		pProjEngImpl->EnableModeless( FALSE );
		// run the dlg as modal (parented to the shell's main dlg owner window)
		if( dlg.DoModalW( hwndShell ) == IDOK )
		{
			// set the prop
			var = dlg.GetPropertyString();
			if( pfRetVal )
				*pfRetVal = VARIANT_TRUE;
		}
		else
		{
			var.Clear();
			if( pfRetVal )
				*pfRetVal = VARIANT_FALSE;
		}
	}
	else if( wcscmp(bstrGuidBldr, L"{7E23E107-4A22-4764-B6A5-E7ED5E2F3C79}") == 0 )
	{
		CComBSTR bstrTitle;
		bstrTitle.LoadString(dispid);
		wchar_t szBuf[4096];

		VSOPENFILENAMEW openFileName = {0};
		CStringW strFilter( MAKEINTRESOURCE( IDS_EXEFilter ));
		strFilter.Replace( L';', 0 );
		strFilter += L'\0';
		
		openFileName.lStructSize = sizeof (VSOPENFILENAMEW);
		openFileName.hwndOwner = hwndShell;
		openFileName.pwzDlgTitle = bstrTitle;
		openFileName.pwzFileName = szBuf;
		openFileName.nMaxFileName = 4096;
		openFileName.pwzInitialDir = NULL;
		openFileName.pwzFilter = strFilter;
		openFileName.nFilterIndex = 0;
		openFileName.nFileOffset = 0;
		openFileName.nFileExtension = 0;
		openFileName.dwHelpTopic = 0;
		openFileName.dwFlags = 0;
		
		pProjEngImpl->EnableModeless( FALSE );
		hr = static_cast<CVCProjectEngine*>(g_pProjectEngine)->GetOpenFileNameViaDlg( &openFileName );
		if( hr == S_OK )
		{
			var = openFileName.pwzFileName;
			if( pfRetVal )
				*pfRetVal = VARIANT_TRUE;
		}
		else
		{
			if( pfRetVal )
				*pfRetVal = VARIANT_FALSE;
		}
	}
	else if( wcscmp(bstrGuidBldr, L"{7E23E108-4A22-4764-B6A5-E7ED5E2F3C79}") == 0 )
	{
		CComBSTR bstrTitle;
		bstrTitle.LoadString(dispid);
		wchar_t szBuf[4096];

		CComBSTR bstrProjDir;
		if (m_pContainer)
		{
			m_pContainer->GetStrProperty(VCPROJID_ProjectDirectory, &bstrProjDir);
		}

		VSBROWSEINFOW dir;
		dir.lStructSize = sizeof(VSBROWSEINFOW);
		dir.hwndOwner = hwndShell;
		dir.pwzDlgTitle = bstrTitle;
		dir.pwzDirName = szBuf;
		dir.nMaxDirName = 4096;
		dir.pwzInitialDir = bstrProp;
		dir.dwHelpTopic = NULL;
		dir.dwFlags = NULL; // BIF_* flags
		pProjEngImpl->EnableModeless( FALSE );
		if (bstrProjDir.Length())
		{
			CCurDirW cwd(bstrProjDir);
			hr = static_cast<CVCProjectEngine*>(g_pProjectEngine)->GetDirViaDlg( &dir );
		}
		else
		{
			// chances of going through this code path a negligible
			hr = static_cast<CVCProjectEngine*>(g_pProjectEngine)->GetDirViaDlg( &dir );
		}

		if( hr == S_OK )
		{
			var = dir.pwzDirName;
			if( pfRetVal )
				*pfRetVal = VARIANT_TRUE;
		}
		else
		{
			if( pfRetVal )
				*pfRetVal = VARIANT_FALSE;
		}
	}
	
	pProjEngImpl->EnableModeless( TRUE );

	var.Detach( pvarValue );
	return S_OK;
}

CPageObjectImplTemplate inline
void CPageObjectImplType::GetBaseDefault(long id, CComVariant& varValue) 
{ 
	if (varValue.vt == VT_BSTR)
		varValue = CComBSTR(L""); 
	else
	{
		varValue.vt = VT_I2;
		varValue.lVal = 0;
	}
}

CPageObjectImplTemplate inline
void CPageObjectImplType::GetLocalizedName(DISPID dispID, MEMBERID memid, ITypeInfo2* pTypeInfo2Enum, long lVal, CComBSTR& bstrDoc)
{
	HRESULT hr = pTypeInfo2Enum->GetDocumentation2(memid, NULL, &bstrDoc, NULL, NULL);
	if( bstrDoc.m_str == NULL )
	{
		// localized name not available. Use object model name.
		hr = pTypeInfo2Enum->GetDocumentation(memid, &bstrDoc, NULL, NULL, NULL);
	}
}

CPageObjectImplTemplate inline
BOOL CPageObjectImplType::GetTruncatedStringForProperty(DISPID dispid, CStringW & strOut)
{
#ifdef TRUNCATE_MULTILINE_STRINGS
	if (!UseCommandsDialog(dispid))
		return FALSE;

	if (strOut.IsEmpty())
	{
		CComVariant var;
		HRESULT hr = GetProp(dispid, &var);
		if (FAILED(hr))
			return FALSE;

		if(V_VT(&var) != VT_BSTR)
			return FALSE;

		strOut = var.bstrVal;
	}

	int i = strOut.FindOneOf(L"\r\n");
	if (-1 == i)
		return FALSE;

	strOut = strOut.Left(i);
	strOut += L"...";

	return TRUE;
#else
	return FALSE;
#endif
}

CPageObjectImplTemplate inline
void CPageObjectImplType::RefreshPropGrid(void)
{
#ifdef TRUNCATE_MULTILINE_STRINGS
	if(m_pPage)
		m_pPage->Refresh();
#else
	;
#endif
}

////////////////////////////////////////////////////////////////////////////////////////////////
// CAdditionalOptionsPage

CAdditionalOptionsPageTemplate inline
CAdditionalOptionsPageType::CAdditionalOptionsPage() 
{
	m_dwTitleID = IDS_Additional;
	m_dwHelpFileID = IDS_VCPROJECT; // dummy ID to get the help method invoked
	m_bActive = FALSE;
	m_hFont = NULL;
}

CAdditionalOptionsPageTemplate inline
LRESULT CAdditionalOptionsPageType::OnFocus(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
	bHandled = FALSE;
	UpdateObjects(true);
	return FALSE;
}
	
CAdditionalOptionsPageTemplate inline
LRESULT CAdditionalOptionsPageType::OnChange(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
	bHandled = TRUE;
	CComBSTR bstrOptions;
	HWND hwndOpt;
	hwndOpt = ::GetDlgItem(m_hWnd, IDC_ADDOPTIONS);
	wchar_t buf[16000];
	::GetWindowTextW(hwndOpt, buf, 16000);
	bstrOptions = buf;
	bool bUpdateObjects = false;
	
	UINT i;
	for (i = 0; i < m_nObjects; i++)
	{
		CComPtr<IDispatch> pDisp;
		CComQIPtr<IVCCfg> pVcCfg = m_ppUnk[i];
		HRESULT hr = pVcCfg->get_Object( &pDisp );
		CComQIPtr<IVCPropertyContainer> spPropContainer = pDisp;
		if (spPropContainer == NULL)
			continue;

		CComPtr<IVCStagedPropertyContainer> spStagedContainer;
		spPropContainer->GetStagedPropertyContainer(VARIANT_TRUE, &spStagedContainer);
		CComQIPtr<IVCPropertyContainer> spStage = spStagedContainer;
		if (spStagedContainer)
		{
			spStagedContainer->HoldStagedContainer();
			CComBSTR bstrOldOptions;
			spStage->GetStrProperty(nID, &bstrOldOptions);
			if (bstrOldOptions != bstrOptions)
			{
				bUpdateObjects = true;
				spStage->SetStrProperty(nID, bstrOptions);
			}
			spStagedContainer->ReleaseStagedContainer();
		}
		else
			spPropContainer->SetStrProperty(nID, bstrOptions);
	}
	SetDirty(TRUE);
	if (bUpdateObjects)
		UpdateObjects(true);
	return TRUE;
}

CAdditionalOptionsPageTemplate inline
STDMETHODIMP CAdditionalOptionsPageType::Dirty( void )
{
	SetDirty(TRUE);
	return S_OK;
}

CAdditionalOptionsPageTemplate inline
STDMETHODIMP CAdditionalOptionsPageType::get_NumObjects( int* pNumObjects )
{
	*pNumObjects = m_nObjects;
	return S_OK;
}

CAdditionalOptionsPageTemplate inline
STDMETHODIMP CAdditionalOptionsPageType::GetObject( int index, IUnknown **ppUnkObject )
{
	if( (DWORD)index >= m_nObjects )
	{
		*ppUnkObject = NULL;
		RETURN_INVALID();
	}
	else
	{
		CComPtr<IUnknown> pRet = m_ppUnk[index];
		*ppUnkObject = pRet.Detach();
		return S_OK;
	}
}

CAdditionalOptionsPageTemplate inline
STDMETHODIMP CAdditionalOptionsPageType::Refresh( void )
{
	return S_OK;	// not a grid, so this method doesn't matter much
}
	
CAdditionalOptionsPageTemplate inline
STDMETHODIMP CAdditionalOptionsPageType::get_CategoryTitle( UINT iLevel, BSTR *pbstrCategory )
{
	if( (iLevel == 0) && TGroupID )
	{
		CComBSTR bstrTitle;
		bstrTitle.LoadString(TGroupID);
		*pbstrCategory = bstrTitle.Detach();
		return S_OK;
	}
	return S_FALSE;
}

CAdditionalOptionsPageTemplate inline
STDMETHODIMP CAdditionalOptionsPageType::Apply(void)
{
	// set the additional options string here
	CComBSTR bstrOptions;
	HWND hwndOpt;
	hwndOpt = ::GetDlgItem(m_hWnd, IDC_ADDOPTIONS);
	wchar_t buf[16000];
	::GetWindowTextW(hwndOpt, buf, 16000);
	bstrOptions = buf;
	
	UINT i;
	HRESULT hr = S_OK;
	for (i = 0; i < m_nObjects; i++)
	{
		CComPtr<IDispatch> pDisp;
		CComQIPtr<IVCCfg> pVcCfg = m_ppUnk[i];
		HRESULT hr2 = pVcCfg->get_Object( &pDisp );
		CComQIPtr<IVCPropertyContainer> spPropContainer = pDisp;
		if (spPropContainer == NULL)
			continue;

		CComPtr<IVCStagedPropertyContainer> spStagedContainer;
		spPropContainer->GetStagedPropertyContainer(VARIANT_TRUE, &spStagedContainer);
		CComQIPtr<IVCPropertyContainer> spStage = spStagedContainer;
		if (spStagedContainer)
		{
			spStagedContainer->HoldStagedContainer();
			if (SUCCEEDED(hr))
			{
				spStage->SetStrProperty(nID, bstrOptions);
				hr = spStagedContainer->CommitPropertyRange(nID, nID);
			}
			spStagedContainer->ReleaseStagedContainer();
		}
		else
			hr = spPropContainer->SetStrProperty(nID, bstrOptions);
	}
	if (SUCCEEDED(hr))
		SetDirty(FALSE);
	return hr;
}

CAdditionalOptionsPageTemplate inline
STDMETHODIMP CAdditionalOptionsPageType::Help(LPCOLESTR pszHelpDir)
{
	CComQIPtr<IVCProjectEngineImpl> pProjEngineImpl = g_pProjectEngine;
	RETURN_ON_NULL(pProjEngineImpl);

	CComBSTR bstrTopic = L"vc.project.AdditionalOptionsPage";

	OpenTopic(pProjEngineImpl, bstrTopic);
	return S_OK;
}

CAdditionalOptionsPageTemplate inline
STDMETHODIMP CAdditionalOptionsPageType::Deactivate(void)
{
	HRESULT hr;

	hr = IPropertyPageImpl<CAdditionalOptionsPage>::Deactivate();
	m_bActive = FALSE;
	DeleteObject( m_hFont );
	return hr;
}

CAdditionalOptionsPageTemplate inline
STDMETHODIMP CAdditionalOptionsPageType::Activate(HWND hWndParent, LPCRECT pRect, BOOL /* bModal */)
{
	ATLTRACE2(atlTraceControls,2,_T("IPropertyPageImpl::Activate\n"));

	if (pRect == NULL)
	{
		ATLTRACE2(atlTraceControls,2,_T("Error : Passed a NULL rect\n"));
		return E_POINTER;
	}
	m_hWnd = CreateW(hWndParent);

	if( m_nObjects == 0 )
		return S_OK;

	m_size.cx = pRect->right - pRect->left;
	m_size.cy = pRect->bottom - pRect->top;

	RECT rectGrid;
	// get the font to use for dlgs
	CComQIPtr<IVCProjectEngineImpl> pProjEngImpl = g_pProjectEngine;
	RETURN_ON_NULL2(pProjEngImpl, E_NOINTERFACE);
	pProjEngImpl->GetDialogFont( FALSE, &m_hFont );
	SetFont( m_hFont );

	HDC dc;
	dc = ::CreateDCW( L"DisPLAY", NULL, NULL, NULL );
	SelectObject( dc, m_hFont );
	// get a base "unit" for sizing the dlg
	SIZE unit;
	GetTextExtentPoint32W( dc, L"X", 1, &unit );
	DeleteDC( dc );

	rectGrid.top = 0;
	rectGrid.left = 0;
	rectGrid.bottom = m_size.cy >= unit.cy * 24 ? m_size.cy : unit.cy * 24;
	rectGrid.right = m_size.cx >= unit.cx * 67 ? m_size.cx : unit.cx * 67;
	
	SetWindowPos( HWND_TOP, &rectGrid, SWP_FRAMECHANGED );

	// set the control font & sizes
	RECT rect;

	// first static text
	CWindow static1( GetDlgItem( IDC_STATIC_ALLOPTIONS ) );
	static1.SetFont( m_hFont );
	rect.left = 0;
	rect.top = (long)(0.5*unit.cy);
	rect.right = (long)(m_size.cx >= unit.cx * 67 ? m_size.cx : unit.cx * 67);
	rect.bottom = (long)rect.top+(1*unit.cy);
	static1.SetWindowPos( HWND_TOP, &rect, 0 );

	// all options edit
	CWindow allopt( GetDlgItem( IDC_ALLOPTIONS ) );
	allopt.SetFont( m_hFont );
	rect.left = 0;
	rect.top = (long)(2*unit.cy);
	rect.right = (long)(m_size.cx >= unit.cx * 67 ? m_size.cx : unit.cx * 67);
	rect.bottom = (long)rect.top+(14*unit.cy);
	allopt.SetWindowPos( HWND_TOP, &rect, 0 );

	// second static text
	CWindow static2( GetDlgItem( IDC_STATIC_ADDOPTIONS ) );
	static2.SetFont( m_hFont );
	rect.left = 0;
	rect.top = (long)(16.5*unit.cy);
	rect.right = (long)(m_size.cx >= unit.cx * 67 ? m_size.cx : unit.cx * 67);
	rect.bottom = (long)rect.top+(1*unit.cy);
	static2.SetWindowPos( HWND_TOP, &rect, 0 );

	// additional options edit
	CWindow addopt( GetDlgItem( IDC_ADDOPTIONS ) );
	addopt.SetFont( m_hFont );
	rect.left = 0;
	rect.top = (long)(18*unit.cy);
	rect.right = (long)(m_size.cx >= unit.cx * 67 ? m_size.cx : unit.cx * 67);
	rect.bottom = (long)rect.top+(5*unit.cy);
	addopt.SetWindowPos( HWND_TOP, &rect, 0 );

	// set the command line box.
	UpdateObjects();
	m_bActive = TRUE;

	return S_OK;
}

CAdditionalOptionsPageTemplate inline
STDMETHODIMP CAdditionalOptionsPageType::GetPageInfo(PROPPAGEINFO* pPageInfo)
{
	CHECK_POINTER_NULL(pPageInfo);
	// call through to atl parent version
	HRESULT hr = IPropertyPageImpl<CAdditionalOptionsPage>::GetPageInfo( pPageInfo );

	// get the font to use for dlgs
	CComQIPtr<IVCProjectEngineImpl> pProjEngImpl = g_pProjectEngine;
	RETURN_ON_NULL2(pProjEngImpl, E_NOINTERFACE);
	HDC dc;
	dc = ::CreateDCW( L"DisPLAY", NULL, NULL, NULL );
	HFONT hFont;
	pProjEngImpl->GetDialogFont( FALSE, &hFont );
	SelectObject( dc, hFont );
	// get a base "unit" for sizing the dlg
	SIZE unit;
	GetTextExtentPoint32W( dc, L"X", 1, &unit );
	DeleteObject( hFont );
	DeleteDC( dc );

	pPageInfo->size.cx = m_size.cx >= unit.cx * 67 ? m_size.cx : unit.cx * 67;
	pPageInfo->size.cy = m_size.cy >= unit.cy * 24 ? m_size.cy : unit.cy * 24;

	return hr;
}

CAdditionalOptionsPageTemplate inline
STDMETHODIMP CAdditionalOptionsPageType::SetObjects(ULONG nObjects, IUnknown **ppUnk)
{
	// call base-class implementation
	HRESULT hr = IPropertyPageImpl<CAdditionalOptionsPage>::SetObjects( nObjects, ppUnk );
	RETURN_ON_FAIL(hr);

	// update the objects if we have ever been activated.
	if( m_bActive )
		hr = UpdateObjects();
		
	return hr;
}

CAdditionalOptionsPageTemplate inline
STDMETHODIMP CAdditionalOptionsPageType::TranslateAccelerator(MSG *pMsg)
{
	if ((pMsg->message < WM_KEYFIRST || pMsg->message > WM_KEYLAST) &&
		(pMsg->message < WM_MOUSEFIRST || pMsg->message > WM_MOUSELAST))
		return S_FALSE;

	return (::IsDialogMessage(m_hWnd, pMsg)) ? S_OK : S_FALSE;
}

CAdditionalOptionsPageTemplate inline
HRESULT CAdditionalOptionsPageType::UpdateObjects( bool bUpdateAllOnly = false )
{
	CComBSTR	bstrOptionsFirst;
		CComBSTR bstrAllOptions;

	UINT i;
	for (i = 0; i < m_nObjects; i++)
	{
		CComPtr<IDispatch> pDisp;
		CComQIPtr<IVCCfg> pVcCfg = m_ppUnk[i];
		HRESULT hr = pVcCfg->get_Object( &pDisp );
		CComQIPtr<VCConfiguration> pCfg = pDisp;
		CComQIPtr<VCFileConfiguration> pFileCfg = pDisp;
		
		CComQIPtr<IVCToolImpl> pToolImpl;
#ifdef AARDVARK
		CComQIPtr<VCStyleSheet> pStyle = pDisp;
		if( pStyle != NULL )
		{
			CComPtr<IDispatch> pDispTools;
			CComQIPtr<IVCCollection> pCollTools;

			if (pCfg && (pStyle->get_Tools(&pDispTools)==S_OK))
			{
				pCollTools = pDispTools;
				CComPtr<IEnumVARIANT> pEnumTools;
				hr = pCollTools->_NewEnum((IUnknown**)&pEnumTools);
				pEnumTools->Reset();
				while (TRUE)
				{
					CComVariant var;
					hr = pEnumTools->Next(1, &var, NULL);
					BREAK_ON_DONE(hr);
					CComQIPtr<I> pTool;
					pTool = var.pdispVal;
					if( pTool )
					{
						pToolImpl = pTool;
						break;
					}
				}
			}
			if( pToolImpl == NULL )
				return S_OK;
		}
#endif	// AARDVARK
		if( pCfg != NULL )
		{
			CComPtr<IDispatch> pDispTools;
			CComQIPtr<IVCCollection> pCollTools;

			if (pCfg && (pCfg->get_Tools(&pDispTools)==S_OK))
			{
				pCollTools = pDispTools;
				CComPtr<IEnumVARIANT> pEnumTools;
				hr = pCollTools->_NewEnum((IUnknown**)&pEnumTools);
				pEnumTools->Reset();
				while (TRUE)
				{
					CComVariant var;
					hr = pEnumTools->Next(1, &var, NULL);
					BREAK_ON_DONE(hr);
					CComQIPtr<I> pTool;
					pTool = var.pdispVal;
					if( pTool )
					{
						pToolImpl = pTool;
						break;
					}
				}
			}
			RETURN_ON_NULL2(pToolImpl, S_OK);
		}
		else if( pFileCfg != NULL )
		{

			CComPtr<IDispatch> pDisp;
		
			hr = pFileCfg->get_Tool( &pDisp );
			if( FAILED( hr ) ) 
				continue;
		
			// if this file has a tool
			pToolImpl = pDisp;
			if( pToolImpl == NULL )
				continue;
		}

		CComQIPtr<IVCPropertyContainer> pContainer = pDisp;
		CComQIPtr<IVCPropertyContainer> spLiveContainer;
		if (pContainer)
		{
			CComPtr<IVCStagedPropertyContainer> spStagedPropContainer;
			pContainer->GetStagedPropertyContainer(VARIANT_TRUE, &spStagedPropContainer);
			if (spStagedPropContainer)
				spLiveContainer = spStagedPropContainer;
		}
		if (spLiveContainer == NULL)
			spLiveContainer = pDisp;

		// set the additional options string here
		if( m_nObjects == 1 )
		{
			hr = pToolImpl->GetCommandLineOptionsForDisplay(spLiveContainer, VARIANT_FALSE /* !include additional options */, 
				&bstrAllOptions);
			CComBSTR bstrParentOptions;
			HRESULT hr2 = pToolImpl->GetAdditionalOptionsInternal(spLiveContainer, VARIANT_TRUE, VARIANT_TRUE, 
				&bstrParentOptions);
			if (bstrParentOptions.Length())
			{
				if (bstrAllOptions.Length())
					bstrAllOptions += L" ";
				bstrAllOptions += bstrParentOptions;
			}
		}
		else if( bstrAllOptions == NULL )
		{
			bstrAllOptions.LoadString(IDS_MULTISELECT);
		}
		
		if (!bUpdateAllOnly)
		{
			CComBSTR bstrOptions;
			hr = pToolImpl->GetAdditionalOptionsInternal(spLiveContainer, VARIANT_FALSE, VARIANT_FALSE, &bstrOptions);

			if( i == 0 )
			{
				bstrOptionsFirst = bstrOptions;
			}
			else if ( bstrOptionsFirst != bstrOptions )
			{
				bstrOptionsFirst = "";
				break;
			}
		}

	}
	HWND hwndOpt;
	if (!bUpdateAllOnly)
	{
		hwndOpt = ::GetDlgItem(m_hWnd, IDC_ADDOPTIONS);
		::SetWindowTextW(hwndOpt, bstrOptionsFirst);
	}

	hwndOpt = ::GetDlgItem(m_hWnd, IDC_ALLOPTIONS);
	::SetWindowTextW(hwndOpt, bstrAllOptions);

	return S_OK;
}

////////////////////////////////////////////////////////////////////////////////////////////////
// CBaseEditStringDlg

CBaseEditStringDlgTemplate inline
CBaseEditStringDlgType::CBaseEditStringDlg(IVCPropertyContainer* pPropCnt, wchar_t* wszName, wchar_t* wszProp) :
	m_bstrName( wszName ),
	m_bstrProperty( wszProp ),
	m_hFont(NULL),
	m_bExpanded(false),
	m_nExpansionHeight(150),
	m_bInitialSizeDone(false),
	m_wOriginalHeight(-1),
	m_wHeight(-1),
	m_wWidth(-1),
	m_xBorder(-1),
	m_yBorder(-1),
	m_yCaptionSize(-1),
	m_buttonWidth(10),
	m_hpenBtnHilite(NULL),
	m_hpenBtnShadow(NULL),
	m_cxResizeBox(0),
	m_bInPaint(false)

{
	m_pPropContainer = pPropCnt;
}

CBaseEditStringDlgTemplate inline
LRESULT CBaseEditStringDlgType::OnInitDialog( UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled )
{
	// set the caption
	::SetWindowTextW( m_hWnd, m_bstrName );

	// set the appropriate font
	CComQIPtr<IVCProjectEngineImpl> pProjEngImpl = g_pProjectEngine;
	RECT rect;
	if( pProjEngImpl )
	{
		// get the font to use
		pProjEngImpl->GetDialogFont(FALSE, &m_hFont );
		SetFont( m_hFont );

		DoSetWindowFont(IDC_INSERTMACRO);
		DoSetWindowFont(IDC_MACROPICKER);
		DoSetWindowFont(IDCANCEL);
		DoSetWindowFont(IDOK);
		DoSetWindowFont(IDC_SETTINGSEDIT_HELP);

		SetupScreenUnits();

		// set the dlg size
		// 27x21.5 'units'
		MINMAXINFO minMax;
		DoOnMinMaxInfo(&minMax);
		rect.left = 0;
		rect.top = 0;
		rect.right = 0;
		rect.bottom = 0;
		CStringW strRoot  = CVCProjectEngine::s_bstrAlternateRegistryRoot + "\\VC";
		DWORD dwWidth = 0;
		HRESULT hr = GetRegIntW(strRoot, GetSavedWidthString(), &dwWidth);
		rect.right = dwWidth;
		if (rect.right <= 0)
			rect.right = minMax.ptMinTrackSize.x;

		DWORD dwHeight = 0;
		hr = GetRegIntW(strRoot, GetSavedHeightString(), &dwHeight);
		rect.bottom = (DWORD)dwHeight;
		if (rect.bottom <= 0)
			rect.bottom = minMax.ptMinTrackSize.y;
		m_wOriginalHeight = m_wHeight = (WORD)rect.bottom;
		m_wWidth = (WORD)rect.right;
	}
	else
	{
		GetWindowRect(&rect);
		m_wOriginalHeight = m_wHeight = (WORD)(rect.bottom - rect.top);
		m_wWidth = (WORD)(rect.right - rect.left);
	}

	DoChildInit();

	// hide the Macros button
	::ShowWindow(GetDlgItem(IDC_INSERTMACRO), SW_HIDE);

	SetWindowPos( HWND_TOP, &rect, 0 );
	HWND hwndPropDlg = ::GetActiveWindow();
	CenterWindow( hwndPropDlg );

	// Establish the dlg controls' contents
	Reset();

	ShowWindow( SW_SHOWNORMAL );
	SendDlgItemMessage(GetMacroPickerParent(), WM_SETFOCUS, 0, 0);

	DoOnPaint();

	bHandled = TRUE;
	return FALSE;  // don't let the system set the focus
}

CBaseEditStringDlgTemplate inline
void CBaseEditStringDlgType::DoSetWindowFont(int idControl)
{
	CWindow wnd;
	wnd.Attach(GetDlgItem(idControl));
	if (wnd)
		wnd.SetFont(m_hFont);
}

CBaseEditStringDlgTemplate inline
void CBaseEditStringDlgType::SizeButton(int idControl, double left, double top, double right, double bottom)
{
	RECT rect;
	CWindow wnd( GetDlgItem( idControl ) );
	rect.right = m_wWidth - m_xBorder - (long)(right*m_unit.cx);
	if (rect.right < 0)
		rect.right = 0;
	rect.left = (long)(rect.right - left*m_unit.cx);
	if (rect.left < 0)
		rect.left = 0;
	rect.top = (long)(m_wHeight - m_yBorder - top*m_unit.cy);
	if (rect.top < 0)
		rect.top = 0;
	rect.bottom = (long)(rect.top+(bottom*m_unit.cy));
	wnd.SetWindowPos( HWND_TOP, &rect, 0 );
}

CBaseEditStringDlgTemplate inline
void CBaseEditStringDlgType::SizeSubWindow(int idControl, double left, double top, double right, double bottom)
{
	CWindow wnd( GetDlgItem( idControl ) );
	RECT rect;
	rect.left = (long)(left*m_unit.cx);
	rect.top = (long)(top*m_unit.cy);
	rect.right = m_wWidth - m_xBorder - (long)(right*m_unit.cx);
	if (rect.right < rect.left)
		rect.right = rect.left;
	rect.bottom = rect.top+(long)(bottom*m_unit.cy);
	wnd.SetWindowPos( HWND_TOP, &rect, 0 );
}

CBaseEditStringDlgTemplate inline
void CBaseEditStringDlgType::SetExpansionHeight()
{
	if (m_bExpanded)
		m_nExpansionHeight = (long)(0.5*(m_wHeight - 5.0*m_unit.cy));
	else
		m_nExpansionHeight = (long)(m_wHeight - 5.0*m_unit.cy);
}

CBaseEditStringDlgTemplate inline
double CBaseEditStringDlgType::GetExpansionExtent()
{
	if (m_bExpanded)
		return m_nExpansionHeight;
	else
		return 0.0;
}

CBaseEditStringDlgTemplate inline
LRESULT CBaseEditStringDlgType::DoOnSize( UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled )
{
	WORD wOldWidth = m_wWidth;
	WORD wOldHeight = m_wHeight;

	m_wWidth = LOWORD( lParam );
	m_wHeight = HIWORD( lParam );

	// remember the initial size when the dlg is first sized (on creation)
	if( !m_bInitialSizeDone )
	{
		m_wOriginalHeight = m_wHeight;
		m_bInitialSizeDone = true;
		m_hpenBtnShadow = ::CreatePen(PS_SOLID, 0, ::GetSysColor(COLOR_BTNSHADOW));
		m_hpenBtnHilite = ::CreatePen(PS_SOLID, 0, ::GetSysColor(COLOR_BTNHIGHLIGHT));
	}

	SetupScreenUnits();

	if (m_wWidth != wOldWidth || m_wHeight != wOldHeight)
		InvalidateRect(NULL);	// force a repaint

	// help button
	SizeButton(IDC_SETTINGSEDIT_HELP, m_buttonWidth, 2.25, 0.75, 2);

	// cancel button
	SizeButton(IDCANCEL, m_buttonWidth, 2.25, m_buttonWidth+1.25, 2);

	// ok button
	SizeButton(IDOK, m_buttonWidth, 2.25, 2*m_buttonWidth+1.75, 2);

	if (m_bExpanded && MacroPickerSupported())
		SizeButton(IDC_INSERTMACRO, m_buttonWidth, 2.25, 3*m_buttonWidth+2.25, 2);

	// macro button
	SizeButton(IDC_MACROPICKER, m_buttonWidth, 4.75, 0.75, 2);

	// set up the window area the child dialog gets to mess with
	SetExpansionHeight();

	// macro picker list sizes to fit the remaining space below the child windows and above the buttons, so can't 
	// use either SizeButton or SizeSubWindow to size it
	if (m_bExpanded)
	{
		RECT rect;
		rect.left = (long)(EDITSTRINGS_RESIZE_EDGE*m_unit.cx);
		rect.top = GetMacroPickerTop();
		rect.right = m_wWidth - m_xBorder - (long)(EDITSTRINGS_RESIZE_EDGE*m_unit.cx);
		if (rect.right < rect.left)
			rect.right = rect.left;
		rect.bottom = (long)(m_wHeight - m_yBorder - 5.5*m_unit.cy);
		if (rect.bottom < rect.top)
			rect.bottom = rect.top;
		m_wndMacroPicker.SetWindowPos( HWND_TOP, &rect, 0 );
	}

	// do OnSize for anything in the child dialog; this puts the child's subwindows FIRST in the tab order...
	DoChildOnSize();

	DoOnPaint();

	return 0;
}

CBaseEditStringDlgTemplate inline
LRESULT CBaseEditStringDlgType::DoOnPaint()
{
	PAINTSTRUCT paintStruct;
	BeginPaint(&paintStruct);
	// that little resize thingie in the lower right corner
	if (m_hpenBtnShadow && m_hpenBtnHilite)
	{
		RECT rectResizer;
		GetClientRect(&rectResizer);
		rectResizer.top = rectResizer.bottom - m_cxResizeBox;
		rectResizer.left = rectResizer.right - m_cxResizeBox;
		HDC dc = GetDC();
		HGDIOBJ hObjOld = SelectObject(dc, m_hpenBtnHilite);
		int i;
		for (i = 0; i < m_cxResizeBox; i += 4)
		{
			MoveToEx(dc, rectResizer.left+i, rectResizer.bottom, NULL);
			LineTo(dc, rectResizer.left+m_cxResizeBox, rectResizer.bottom-m_cxResizeBox+i);
		}

		SelectObject(dc, m_hpenBtnShadow);
		for (i = 1; i < m_cxResizeBox; i += 4)
		{
			MoveToEx(dc, rectResizer.left+i, rectResizer.bottom, NULL);
			LineTo(dc, rectResizer.left+m_cxResizeBox, rectResizer.bottom-m_cxResizeBox+i);
		}
		for (i = 2; i < m_cxResizeBox; i += 4)
		{
			MoveToEx(dc, rectResizer.left+i, rectResizer.bottom, NULL);
			LineTo(dc, rectResizer.left+m_cxResizeBox, rectResizer.bottom-m_cxResizeBox+i);
		}

		SelectObject(dc, hObjOld);
		ReleaseDC(dc);
	}

	EndPaint(&paintStruct);
	return 0;
}

CBaseEditStringDlgTemplate inline
void CBaseEditStringDlgType::SetupScreenUnits()
{
	CComBSTR bstrOK, bstrCancel, bstrHelp, bstrMacros, bstrInsert;
	RetrieveDynamicInfo(IDOK, bstrOK);
	RetrieveDynamicInfo(IDCANCEL, bstrCancel);
	RetrieveDynamicInfo(IDC_SETTINGSEDIT_HELP, bstrHelp);
	RetrieveDynamicInfo(IDC_MACROPICKER, bstrMacros);
	if (MacroPickerSupported())
		RetrieveDynamicInfo(IDC_INSERTMACRO, bstrInsert);

	HDC dc = GetDC();
	SelectObject( dc, m_hFont );
	// get a base "unit" for sizing the dlg
	GetTextExtentPoint32W( dc, L"X", 1, &m_unit );

	// figure out the minimum sizing for the buttons
	SIZE unitOK, unitCancel, unitHelp, unitMacros, unitInsert;
	GetTextExtentPoint32W( dc, bstrOK, bstrOK.Length(), &unitOK );
	GetTextExtentPoint32W( dc, bstrCancel, bstrCancel.Length(), &unitCancel );
	GetTextExtentPoint32W( dc, bstrHelp, bstrHelp.Length(), &unitHelp );
	GetTextExtentPoint32W( dc, bstrMacros, bstrMacros.Length(), &unitMacros );
	if (MacroPickerSupported())
		GetTextExtentPoint32W( dc, bstrInsert, bstrInsert.Length(), &unitInsert );
	else
		unitInsert.cx = unitInsert.cy = 0;
	ReleaseDC(dc);

	int minButtonWidth = unitOK.cx;
	if (unitCancel.cx > minButtonWidth)
		minButtonWidth = unitCancel.cx;
	if (unitHelp.cx > minButtonWidth)
		minButtonWidth = unitHelp.cx;
	if (unitMacros.cx > minButtonWidth)
		minButtonWidth = unitMacros.cx;
	if (unitInsert.cx > minButtonWidth)
		minButtonWidth = unitInsert.cx;
	if (minButtonWidth > 9 * m_unit.cx)
		m_buttonWidth = (long)(minButtonWidth / m_unit.cx) + 2;

	m_xBorder = GetSystemMetrics( SM_CXSIZEFRAME );
	m_yBorder = GetSystemMetrics( SM_CYSIZEFRAME );
	m_yCaptionSize = GetSystemMetrics( SM_CYCAPTION );
	m_cxResizeBox = (3*GetSystemMetrics(SM_CXVSCROLL)+1)/4;
}

CBaseEditStringDlgTemplate inline
void CBaseEditStringDlgType::RetrieveDynamicInfo(long id, CComBSTR& bstrBuffer)
{
	CStringW strBuffer;
	CWindow editProp(::GetDlgItem(m_hWnd, id));
	int nLen = editProp.GetWindowTextLength();
	wchar_t* szBuf = strBuffer.GetBuffer(nLen+2);
	if (szBuf)
	{
		::GetDlgItemTextW(m_hWnd, id, szBuf, nLen+1);
		szBuf[nLen] = L'\0';
		strBuffer.ReleaseBuffer();
	}
	bstrBuffer = strBuffer;
}

CBaseEditStringDlgTemplate inline
LRESULT CBaseEditStringDlgType::DoOnSetFocus()
{
	CWindow editProp( GetDlgItem( GetMacroPickerParent() ) );
	// de-select
	editProp.SendMessage( EM_SETSEL, -1, 0 );
	return 0;
}

CBaseEditStringDlgTemplate inline
LRESULT CBaseEditStringDlgType::DoOnMacros()
{
	RECT rectParent;
	GetWindowRect(&rectParent);
	bool bFinish = false;
	int nWiggle = 0;

	CStringW strMacros;
	if (m_bExpanded)
	{
		if (m_pMacroPicker)
		{
			SetExpansionHeight();
			::ShowWindow(m_wndMacroPicker, SW_HIDE);
			m_bExpanded = false;
			if (!strMacros.LoadString(IDS_MACROS_CONTRACTED))
				strMacros = "&Macros>>";
			::ShowWindow(GetDlgItem(IDC_INSERTMACRO), SW_HIDE);
			ResetParentBottom(rectParent);
			bFinish = true;
		}
	}
	else
	{
		if (!m_wndMacroPicker)
		{
			RECT rectChild = { 3, 210, 150, 210 };
			m_wndMacroPicker.Create(m_hWnd, rectChild, _T("MacroPicker.VCMacroPicker"), 
				WS_CHILD | WS_VISIBLE | WS_CLIPSIBLINGS | WS_CLIPCHILDREN, 0, IDC_MACROPICKER_LIST);
			m_pMacroPicker.Release();
			m_wndMacroPicker.QueryControl(__uuidof(IVCMacroPicker), (void **)&m_pMacroPicker);
			if (m_pMacroPicker)
			{
				HWND hwndPickerParent = GetMacroPickerParentEditWindow();
				CComBSTR bstrName, bstrValue;
				bstrName.LoadString(IDS_NAME);
				bstrValue.LoadString(IDS_VALUE);
				m_pMacroPicker->Initialize(m_pPropContainer, g_pProjectEngine, (LONG_PTR)hwndPickerParent,
					bstrName, bstrValue);
				m_wndMacroPicker.MoveWindow(&rectChild);
			}
		}
		if (m_pMacroPicker)
		{
			SetExpansionHeight();
			m_bExpanded = true;
			if (!strMacros.LoadString(IDS_MACROS_EXPANDED))
				strMacros = "&Macros<<";
			if (MacroPickerSupported())
				::ShowWindow(GetDlgItem(IDC_INSERTMACRO), SW_SHOW);
			::ShowWindow(m_wndMacroPicker, SW_SHOW);
			rectParent.bottom += m_nExpansionHeight;
			RECT rectWorkArea;
			SystemParametersInfo(SPI_GETWORKAREA, 0, &rectWorkArea, 0);
			if (rectWorkArea.bottom < rectParent.bottom)
			{
				rectParent.top = rectParent.top - (rectParent.bottom - rectWorkArea.bottom);
				if (rectParent.top < rectWorkArea.top)
				{
					m_nExpansionHeight -= rectWorkArea.top - rectParent.top;
					rectParent.top = rectWorkArea.top;
				}
				rectParent.bottom = rectWorkArea.bottom;
			}
			bFinish = true;
		}
	}
	if (bFinish)
	{
		    CString strMacroText = strMacros;
		SetDlgItemText(IDC_MACROPICKER, strMacroText);
		MoveWindow(&rectParent);
	}
	
	return 0;
}

CBaseEditStringDlgTemplate inline
LRESULT CBaseEditStringDlgType::DoOnInsertMacro()
{
	if (m_pMacroPicker)
		m_pMacroPicker->OnInsertMacro();
	return 0;
}

CBaseEditStringDlgTemplate inline
LRESULT CBaseEditStringDlgType::DoOnOk()
{
	RetrieveInfo();

	// the caller will now need to call GetPropertyString() to retrieve the
	// data...
	
	DoCleanup();

	EndDialog( IDOK );
	return 0;
}

CBaseEditStringDlgTemplate inline
LRESULT CBaseEditStringDlgType::DoOnCancel()
{
	DoCleanup();

	EndDialog( IDCANCEL );
	return 0;
}

CBaseEditStringDlgTemplate inline
void CBaseEditStringDlgType::DoCleanup()
{
	// take care of the macro dlg
	ReleaseMacroPicker();

	if (m_hFont)
	{
		DeleteObject( m_hFont );
		m_hFont = NULL;
	}

	if (m_hpenBtnHilite)
	{
		DeleteObject(m_hpenBtnHilite);
		m_hpenBtnHilite = NULL;
	}
	if (m_hpenBtnShadow)
	{
		DeleteObject(m_hpenBtnShadow);
		m_hpenBtnShadow = NULL;
	}

	CStringW strRoot  = CVCProjectEngine::s_bstrAlternateRegistryRoot + "\\VC";
	DWORD dwWidth = (DWORD)m_wWidth;
	WriteRegIntW(strRoot, GetSavedWidthString(), dwWidth);
	DWORD nHeight = (DWORD)m_wHeight;
	if (m_bExpanded)
		nHeight -= m_nExpansionHeight;
	WriteRegIntW(strRoot, GetSavedHeightString(), nHeight);
}

CBaseEditStringDlgTemplate inline
LRESULT CBaseEditStringDlgType::DoOnHelp()
{
	CComQIPtr<IVCProjectEngineImpl> pProjEngineImpl = g_pProjectEngine;
	RETURN_ON_NULL2(pProjEngineImpl, 1);
	OpenTopic( pProjEngineImpl, CComBSTR( L"VC.Project.NotAProp.Edit" ) );

	return 0;
}

CBaseEditStringDlgTemplate inline
LRESULT CBaseEditStringDlgType::DoOnMinMaxInfo( LPMINMAXINFO lpMinMax )
{
	RECT rectWorkArea;
	SystemParametersInfo(SPI_GETWORKAREA, 0, &rectWorkArea, 0);
	lpMinMax->ptMinTrackSize.x = (long)((4*m_buttonWidth + 3.5)*m_unit.cx + 2*m_xBorder); // min track width
	if (lpMinMax->ptMinTrackSize.x > rectWorkArea.right - rectWorkArea.left)
		lpMinMax->ptMinTrackSize.x = rectWorkArea.right - rectWorkArea.left;
	if (m_bExpanded)	// min track height
		lpMinMax->ptMinTrackSize.y = (long)(44*m_unit.cy + 2*m_yBorder + m_yCaptionSize);
	else
		lpMinMax->ptMinTrackSize.y = (long)(22*m_unit.cy + 2*m_yBorder + m_yCaptionSize);
	if (lpMinMax->ptMinTrackSize.y > rectWorkArea.bottom - rectWorkArea.top)
		lpMinMax->ptMinTrackSize.y = rectWorkArea.bottom - rectWorkArea.top;
	return 0;
}

CBaseEditStringDlgTemplate inline
void CBaseEditStringDlgType::ReleaseMacroPicker()
{
	if (!m_pMacroPicker)
		return;

	HWND hwndMacroPicker = NULL;
	m_pMacroPicker->get_HWND((LONG_PTR*)&hwndMacroPicker);
	if (hwndMacroPicker)
		::SendMessage(hwndMacroPicker, WM_CLOSE, 0, 0);
	m_pMacroPicker.Release();
}

CBaseEditStringDlgTemplate inline
void CBaseEditStringDlgType::CleanUpString( CComBSTR & bstrVal, CStringW& strPreferredSeparator, CStringW& strAllSeparators )
{
	CStringW strPropIn = bstrVal;
	strPropIn.TrimLeft();
	strPropIn.TrimRight();

	// if we have an empty string, don't bother
	if( strPropIn.IsEmpty() )
		return;

	CStringW strPropOut;
	// first replace any non-preferred separators with preferred ones;  make sure to respect anything that has been quoted
	int nMax = strAllSeparators.GetLength();
	wchar_t cPreferred = strPreferredSeparator.IsEmpty() ? L';' : strPreferredSeparator[0];
	int nLen = strPropIn.GetLength();
	bool bInSingleQuote = false, bInDoubleQuote = false, bInWhiteSpace = false, bInSeparator = false;
	bool bAtStart = true, bNeedSeparator = false, bRecentChange = false;
	int idx = 0;

	for (idx = 0; idx < nLen; idx++)
	{
		if (strPropIn[idx] == L'"')
		{
			bInDoubleQuote = !bInDoubleQuote;
		}
		else if (strPropIn[idx] == L'\'')
		{
			bInSingleQuote = !bInSingleQuote;
		}

		if (bInSingleQuote || bInDoubleQuote)
		{
			if (bNeedSeparator)
				strPropOut += cPreferred;
			strPropOut += strPropIn[idx];
			bAtStart = false;
			bNeedSeparator = false;
			continue;
		}

		if (strPropIn[idx] == cPreferred || strPropIn[idx] == L'\r' || strPropIn[idx] == L'\n')
		{
			bInWhiteSpace = true;
			bNeedSeparator = true;
			continue;
		}
		
		bInSeparator = false;
		for (int idx2 = 1; idx2 < nMax && !bInSeparator; idx2++)
		{
			wchar_t cCurrent = strAllSeparators[idx2];
			if (strPropIn[idx] == cCurrent)
				bInSeparator = true;
		}

		if (bInSeparator)
		{
			bInWhiteSpace = true;
			bNeedSeparator = true;
			continue;
		}

		if (bNeedSeparator)
		{
			strPropOut += cPreferred;
			bNeedSeparator = false;
		}

		strPropOut += strPropIn[idx];
	}
	
	// save it away
	bstrVal = strPropOut;
}

////////////////////////////////////////////////////////////////////////////////////////////////
// CMultiLineDlgBase

CMultiLineDlgBaseTemplate inline
CMultiLineDlgBaseType::CMultiLineDlgBase( IVCPropertyContainer *pPropCnt, long propid, wchar_t *wszName, wchar_t *wszProp, wchar_t *wszInherit ) :
	CBaseEditStringDlg<T>(pPropCnt, wszName, wszProp),	
	m_lPropId( propid ),
	m_bstrInherit( wszInherit ),
	m_bUserSetInherit( false )
{
	if (pPropCnt)
	{
		CComBSTR bstrPreferred, bstrAll;
		pPropCnt->GetMultiPropSeparator(propid, &bstrPreferred, &bstrAll);
		m_strPreferredSeparator = bstrPreferred;
		m_strAllSeparators = bstrAll;
	}
	else
	{
		m_strPreferredSeparator = L";";
		m_strAllSeparators = L";,";
	}
}

CMultiLineDlgBaseTemplate inline
void CMultiLineDlgBaseType::RetrieveInfo()
{
	CComBSTR bstrFixedData;
	RetrieveSpecificInfo(bstrFixedData);

	// if the user didn't type an inherit macro into the field, use the checkbox
	if( !HasInheritMacros( bstrFixedData ) )
	{
		// check inherit state
		if( !m_bUserSetInherit )
		{
			UINT state = IsDlgButtonChecked( IDC_INHERIT );
			if( state == BST_UNCHECKED )
			{
				wchar_t cPreferred = m_strPreferredSeparator.IsEmpty() ? L';' : m_strPreferredSeparator[0];
				if( bstrFixedData.Length() > 0 && bstrFixedData.m_str[bstrFixedData.Length()-1] != cPreferred )
					bstrFixedData.Append(cPreferred);
				bstrFixedData.Append( L"$(NOINHERIT)" );
			}
		}
	}
	m_bstrProperty = bstrFixedData;
	CleanUpString( m_bstrProperty, m_strPreferredSeparator, m_strAllSeparators );
}

CMultiLineDlgBaseTemplate inline
void CMultiLineDlgBaseType::CheckForInheritOnOpen( CComBSTR & bstrVal )
{
	CStringW strProp = bstrVal;
	int pos;

	// ensure no trailing whitespace
	strProp.TrimRight();

	// look for $(NOINHERIT) first, as it overrides $(INHERIT)
	pos = FindNoCaseW( strProp, L"$(NOINHERIT)" );
	if( pos != -1 )
	{
		// strip it out
		bstrVal = strProp.Left( pos ) + strProp.Right( lstrlenW( bstrVal ) - (pos + lstrlenW( L"$(NOINHERIT)" )) );
		// check box is un-checked by default...
		return;
	}
	// look for $(INHERIT) at the end of the list 
	// find the last newline
	pos = strProp.ReverseFind( L'\n' );
	if( pos != -1 )
	{
		// search forward from there for the macro
		int pos2 = FindNoCaseW( strProp, L"$(INHERIT)", pos );
		if( pos2 != -1 )
		{
			// remove it
 			bstrVal = strProp.Left( pos - 1 );
			// check box is un-checked by default...
			CheckDlgButton( IDC_INHERIT, BST_CHECKED );
			return;
		}
	}
	else
	{
		// found no newlines, so check the whole string 
		// search forward from there for the macro
		int pos2 = FindNoCaseW( strProp, L"$(INHERIT)" );
		if( pos2 != -1 )
		{
			// remove it
			bstrVal = L"";
			// check box is un-checked by default...
			CheckDlgButton( IDC_INHERIT, BST_CHECKED );
			return;
		}
	}
	// look for $(INHERIT) in the rest of the string
	pos = FindNoCaseW( strProp, L"$(INHERIT)" );
	// if we find it in the middle somewhere, grey out the inherit check box
	if( pos != -1 )
	{
		// grey out the checkbox
		CWindow checkBox( GetDlgItem( IDC_INHERIT ) );
		checkBox.SetWindowLong( GWL_STYLE, BS_AUTOCHECKBOX|WS_DISABLED|WS_VISIBLE );
		// set our internal variable
		m_bUserSetInherit = true;
		// (and DON'T remove the macro!)
		return;
	}
	// no macros
	CheckDlgButton( IDC_INHERIT, BST_CHECKED );
	return;
}

CMultiLineDlgBaseTemplate inline
bool CMultiLineDlgBaseType::HasInheritMacros( BSTR bstrVal )
{
	// look for inherit macros
	CStringW strVal = bstrVal;
	if( FindNoCaseW( strVal, L"$(NOINHERIT)" ) != -1 || FindNoCaseW( strVal, L"$(INHERIT)" ) != -1 )
		// return true if we find them
		return true;
	else
		return false;
}

CMultiLineDlgBaseTemplate inline
void CMultiLineDlgBaseType::DoSharedChildOnSize(double& dTotalUnits, double& dWindowUnits)
{
	dTotalUnits = (m_nExpansionHeight - m_yBorder)/(m_unit.cy ? m_unit.cy : 1.0);
	dWindowUnits = dTotalUnits - 3.4;	// this is what's intended for resizable areas

	// inherit check box
	HWND hwndInherit = GetDlgItem( IDC_INHERIT );
	::SetWindowTextW( hwndInherit, m_bstrInherit );
	// figure out how much space we need for the 'Inherit from project' string
	SIZE unit;
	bool bNeedOwnLine = false;
	if (!m_bExpanded)
	{
		HDC dc = GetDC();
		SelectObject( dc, GetFont() );
		GetTextExtentPoint32W( dc, m_bstrInherit, m_bstrInherit.Length(), &unit );
		ReleaseDC(dc);
		if (unit.cx > m_wWidth - (long)(m_unit.cx * (EDITSTRINGS_RESIZE_EDGE + m_buttonWidth + 1.5)))
			bNeedOwnLine = true;
	}

	double lastHeight = dTotalUnits - 1.0;
	double inheritHeight = lastHeight;
	double heightIncrement = 1.0;
	double inheritRight = 0.25;
	if (m_bExpanded)
		inheritHeight += 0.5;
	else if (bNeedOwnLine)
	{
		dWindowUnits -= 0.25;	// need a little extra room for the string...
		lastHeight -= 0.5;
	}
	else	// line it up with the Macros button if the Macro Picker isn't there...
	{
		inheritHeight += 1.5;
		dWindowUnits += 0.5;	// don't need this bit left out for the inherit check box
		lastHeight += 0.5;
		inheritRight = m_buttonWidth + 1.5;
	}
	SizeSubWindow(IDC_INHERIT, EDITSTRINGS_RESIZE_EDGE+0.25, inheritHeight, inheritRight, 1.0);

	// inheritable values read-only edit field
	heightIncrement = (6.5/14.3)*dWindowUnits;
	lastHeight -= heightIncrement;
	SizeSubWindow(IDC_INHERITED, EDITSTRINGS_RESIZE_EDGE, lastHeight, EDITSTRINGS_RESIZE_EDGE, heightIncrement);

	// static inherit text
	lastHeight -= 1.3;
	heightIncrement = 1.0;
	SizeSubWindow(IDC_STATIC_INHERIT, EDITSTRINGS_RESIZE_EDGE, lastHeight, EDITSTRINGS_RESIZE_EDGE, heightIncrement);
}

CMultiLineDlgBaseTemplate inline
void CMultiLineDlgBaseType::DoSharedChildInit()
{
	if (!m_hFont)
		return;

	DoSetWindowFont(IDC_STATIC_INHERIT);
	DoSetWindowFont(IDC_INHERITED);
	DoSetWindowFont(IDC_INHERIT);
}

CMultiLineDlgBaseTemplate inline
void CMultiLineDlgBaseType::DoSharedReset(CComBSTR& bstrFormatted)
{
	CleanUpString( m_bstrProperty, m_strPreferredSeparator, m_strAllSeparators );
	// replace separators with newlines
 	ReplaceSeparatorsWithNewlines( m_bstrProperty, bstrFormatted, m_strPreferredSeparator );
	CheckForInheritOnOpen( bstrFormatted );

	// set up the inheritable values read-only edit field
	CWindow inheritable( GetDlgItem( IDC_INHERITED ) );

	// get the parents values
	CComBSTR bstrProp;
	m_pPropContainer->GetMultiProp( m_lPropId, m_strPreferredSeparator, VARIANT_TRUE, &bstrProp );
	
	CleanUpString( bstrProp, m_strPreferredSeparator, m_strAllSeparators );
	// replace separators with newlines
	CComBSTR bstrFormatted2;
 	ReplaceSeparatorsWithNewlines( bstrProp, bstrFormatted2, m_strPreferredSeparator );
	CheckForInheritOnOpen( bstrFormatted2 );
 	::SetWindowTextW( inheritable, bstrFormatted2 );
}

CMultiLineDlgBaseTemplate inline /* static */
int CMultiLineDlgBaseType::FindNoCaseW( const CStringW & str, const wchar_t* const substr, int pos = 0 )
{
	CStringW strFull = str;
	strFull.MakeLower();
	CStringW strSub = substr;
	strSub.MakeLower();
	return strFull.Find( strSub, pos );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\vcpb\SettingsPage.cpp ===
// SettingsPage.cpp : Implementation of CSettingsPage
#include "stdafx.h"
#include "SettingsPage.h"

// static helper functions
//

static void ReplaceSeparatorsWithNewlines( BSTR in, CComBSTR &out, CStringW& strPreferredSeparator )
{
	CStringW temp = in;
	int idx = 0;
	int nLen = temp.GetLength();
	bool bInSingleQuotes = false, bInDoubleQuotes = false;
	wchar_t cPreferred = strPreferredSeparator.IsEmpty() ? L';' : strPreferredSeparator[0];
	while (idx < nLen)
	{
		if (temp[idx] == L'"')
			bInDoubleQuotes = !bInDoubleQuotes;
		else if (temp[idx] == L'\'')
			bInSingleQuotes = !bInSingleQuotes;

		if (bInDoubleQuotes || bInSingleQuotes)
		{
			idx++;
			continue;	// don't want to do any replacements inside quotes
		}

		if (temp[idx] == cPreferred)
		{
			temp.Delete(idx, 1);
			temp.Insert(idx, L"\r\n");
			nLen++;		// just got a little bigger
			idx++;	// skip over the extra character we added
		}
		idx++;
	}

	out = temp;
	return;
}

static void ReplaceNewlinesWithSeparators( BSTR in, CComBSTR &out, CStringW& strPreferredSeparator )
{
	CStringW temp = in;
	int idx = 0;
	int nMax = temp.GetLength();
	nMax--;		// don't care about very last character
	bool bInSingleQuotes = false, bInDoubleQuotes = false;
	wchar_t cPreferred = strPreferredSeparator.IsEmpty() ? L';' : strPreferredSeparator[0];
	while (idx < nMax)
	{
		if (temp[idx] == L'"')
			bInDoubleQuotes = !bInDoubleQuotes;
		else if (temp[idx] == L'\'')
			bInSingleQuotes = !bInSingleQuotes;

		if (bInDoubleQuotes || bInSingleQuotes)
		{
			idx++;
			continue;	// don't want to do any replacements inside quotes
		}

		if (temp[idx] == L'\r' && temp[idx+1] == L'\n')
		{
			temp.Delete(idx, 2);
			temp.Insert(idx, cPreferred);
			nMax--;	// just lost a character
		}
		idx++;
	}

	out = temp;
	return;
}

/////////////////////////////////////////////////////////////////////////////////
// CMultiLineDlg
//

void CMultiLineDlg::DoChildOnSize()
{
	double dTotalUnits;
	double dWindowUnits;
	DoSharedChildOnSize(dTotalUnits, dWindowUnits);
	
	// list view
	double heightIncrement = (7.8/14.3)*dWindowUnits;
	SizeSubWindow(IDC_MULTILINELIST, EDITSTRINGS_RESIZE_EDGE, EDITSTRINGS_RESIZE_EDGE, EDITSTRINGS_RESIZE_EDGE, heightIncrement);
}

void CMultiLineDlg::DoChildInit()
{
	if (!m_hFont)
		return;

	DoSetWindowFont(IDC_MULTILINELIST);
	DoSharedChildInit();
}

void CMultiLineDlg::Reset()
{
	CComBSTR bstrFormatted;
	DoSharedReset(bstrFormatted);

 	CWindow editProp( GetDlgItem( IDC_MULTILINELIST ) );
 	::SetWindowTextW( editProp, bstrFormatted );
}

void CMultiLineDlg::RetrieveSpecificInfo(CComBSTR& bstrFixedData)
{
	CComBSTR bstrListData;
	RetrieveDynamicInfo(IDC_MULTILINELIST, bstrListData);
 	ReplaceNewlinesWithSeparators( bstrListData, bstrFixedData, m_strPreferredSeparator );
}

void CMultiDirectoryPickerEditorDlg::DoChildOnSize()
{
	double dTotalUnits;
	double dWindowUnits;
	DoSharedChildOnSize(dTotalUnits, dWindowUnits);
	
	// directory picker
	double heightIncrement = (7.8/14.3)*dWindowUnits;
	SizeSubWindow(IDC_DIRCONTROL, EDITSTRINGS_RESIZE_EDGE, EDITSTRINGS_RESIZE_EDGE, EDITSTRINGS_RESIZE_EDGE, heightIncrement);
}

void CMultiDirectoryPickerEditorDlg::DoChildInit()
{
	// this QS is being done in order to get the directory picker SetSite'd properly
	CComPtr<IUnknown> pUnk;
	ExternalQueryService(SID_SDirList, IID_IUnknown, (void **)&pUnk);

	RECT rectChild = { 0, 26, 263, 151 };
	m_wndDirList.Create(m_hWnd, rectChild, L"{AFD20A96-EED8-4D8C-A4EA-18AB96F6C432}",
		WS_CHILD | WS_VISIBLE | WS_CLIPSIBLINGS | WS_CLIPCHILDREN, 0, IDC_DIRCONTROL);
	m_wndDirList.QueryControl(&m_pList);
	CComQIPtr<IDirListSite> pListSite = m_pList;
	if (pListSite)
		pListSite->SetSite((IUnknown *)CVCProjectEngine::s_pServiceProvider);
	if (m_pList)
	{
		m_pList->put_ShowTitle(VARIANT_FALSE);
		m_pList->put_ShowCheck(VARIANT_FALSE);
		m_pList->put_Description(L"   ");
	}

	DoSharedChildInit();
}

void CMultiDirectoryPickerEditorDlg::Reset()
{
	CComBSTR bstrFormatted;
	DoSharedReset(bstrFormatted);

	if( m_pList )
	{
		m_pList->Reset();
		CStringW temp = bstrFormatted;
		int loc = temp.Find(L"\r\n");
		while( -1 != loc )
		{
			CComBSTR bstr = temp.Left( loc );
			temp = temp.Right( temp.GetLength() - loc - 2);
			m_pList->Add(bstr);
			loc = temp.Find(L"\r\n");
		}
		if (!temp.IsEmpty())	// pick up if there is one more on the end...
		{
			CComBSTR bstr = temp;
			m_pList->Add(bstr);
		}
	}
}

void CMultiDirectoryPickerEditorDlg::RetrieveSpecificInfo(CComBSTR& bstrFixedData)
{
	bstrFixedData.Empty();
	if (!m_pList)
		return;

	if( m_pList )
	{
		CComBSTR bstrSeparator = (m_strPreferredSeparator.IsEmpty() ? L";" : m_strPreferredSeparator);
		//
		long i;
		long j;
		m_pList->get_Count(&j);
		for( i=0; i< j; i++)
		{
			CComBSTR bstrItem;
			m_pList->Index(i, &bstrItem);
			if (bstrItem.Length() > 0)
			{
				bstrFixedData += bstrItem;
				bstrFixedData += bstrSeparator;
			}
		}

		CleanUpString(bstrFixedData, m_strPreferredSeparator, m_strAllSeparators);
	}
}

/////////////////////////////////////////////////////////////////////////////////
// CSingleDirectoryPickerEditorDlg
//

void CSingleDirectoryPickerEditorDlg::DoChildInit()
{
	// this QS is being done in order to get the directory picker SetSite'd properly
	CComPtr<IUnknown> pUnk;
	ExternalQueryService(SID_SDirList, IID_IUnknown, (void **)&pUnk);

	RECT rectChild = { 0, 26, 263, 151 };
	m_wndDirList.Create(m_hWnd, rectChild, L"{AFD20A96-EED8-4D8C-A4EA-18AB96F6C432}",
		WS_CHILD | WS_VISIBLE | WS_CLIPSIBLINGS | WS_CLIPCHILDREN, 0, IDC_DIRCONTROL);
	m_wndDirList.QueryControl(&m_pList);
	CComQIPtr<IDirListSite> pListSite = m_pList;
	if (pListSite)
		pListSite->SetSite((IUnknown *)CVCProjectEngine::s_pServiceProvider);
	if (m_pList)
	{
		m_pList->put_ShowTitle(VARIANT_FALSE);
		m_pList->put_ShowCheck(VARIANT_FALSE);
		m_pList->put_Description(L"   ");
	}
}

void CSingleDirectoryPickerEditorDlg::DoChildOnSize()
{
	double dHeight = (double)(m_nExpansionHeight - m_yBorder)/(m_unit.cy ? m_unit.cy : 1.0);
	dHeight -= 2*EDITSTRINGS_RESIZE_EDGE;	// take out the top and bottom edge spacing
	
	// directory picker
	SizeSubWindow(IDC_DIRCONTROL, EDITSTRINGS_RESIZE_EDGE, EDITSTRINGS_RESIZE_EDGE, EDITSTRINGS_RESIZE_EDGE, dHeight);
}

void CSingleDirectoryPickerEditorDlg::Reset()
{
	CStringW strSeparator = L";";
	CleanUpString( m_bstrProperty, strSeparator, strSeparator );
	// replace separators with newlines
	CComBSTR bstrFormatted;
 	ReplaceSeparatorsWithNewlines( m_bstrProperty, bstrFormatted, strSeparator );

	if( m_pList )
	{
		m_pList->Reset();
		CStringW temp = bstrFormatted;
		int loc = temp.Find(L"\r\n");
		while( -1 != loc )
		{
			CComBSTR bstr = temp.Left( loc );
			temp = temp.Right( temp.GetLength() - loc - 2);
			m_pList->Add(bstr);
			loc = temp.Find(L"\r\n");
		}
		if (!temp.IsEmpty())	// pick up if there is one more on the end...
		{
			CComBSTR bstr = temp;
			m_pList->Add(bstr);
		}
	}
}

void CSingleDirectoryPickerEditorDlg::RetrieveInfo()
{
	m_bstrProperty.Empty();
	if (!m_pList)
		return;

	if( m_pList )
	{
		CComBSTR bstrSeparator = L";";
		CStringW strSeparator = L";";
		//
		long i;
		long j;
		m_pList->get_Count(&j);
		for( i=0; i< j; i++)
		{
			CComBSTR bstrItem;
			m_pList->Index(i, &bstrItem);
			if (bstrItem.Length() > 0)
			{
				m_bstrProperty += bstrItem;
				m_bstrProperty += bstrSeparator;
			}
		}

		CleanUpString(m_bstrProperty, strSeparator, strSeparator);
	}
}

/////////////////////////////////////////////////////////////////////////////////
// CSingleLineNoReturnsDlg
//

void CSingleLineNoReturnsDlg::Reset()
{
 	CWindow editProp( GetDlgItem( IDC_STRING_EDIT ) );
 	::SetWindowTextW( editProp, m_bstrProperty );
}

void CSingleLineNoReturnsDlg::RetrieveInfo()
{
	// property edit box
	RetrieveDynamicInfo(IDC_STRING_EDIT, m_bstrProperty);
}

LRESULT CSingleLineNoReturnsDlg::DoOnMinMaxInfo( LPMINMAXINFO lpMinMax )
{
	RECT rectWorkArea;
	SystemParametersInfo(SPI_GETWORKAREA, 0, &rectWorkArea, 0);
	lpMinMax->ptMinTrackSize.x = (long)(43.5*m_unit.cx + 2*m_xBorder); // min track width
	if (lpMinMax->ptMinTrackSize.x > rectWorkArea.right - rectWorkArea.left)
		lpMinMax->ptMinTrackSize.x = rectWorkArea.right - rectWorkArea.left;
	if (m_bExpanded)	// min track height
		lpMinMax->ptMinTrackSize.y = (long)(31*m_unit.cy + 2*m_yBorder + m_yCaptionSize);
	else
		lpMinMax->ptMinTrackSize.y = (long)(9*m_unit.cy + 2*m_yBorder + m_yCaptionSize);
	if (lpMinMax->ptMinTrackSize.y > rectWorkArea.bottom - rectWorkArea.top)
		lpMinMax->ptMinTrackSize.y = rectWorkArea.bottom - rectWorkArea.top;
	return 0;
}

void CSingleLineNoReturnsDlg::DoChildOnSize()
{
	SizeSubWindow(IDC_STRING_EDIT, EDITSTRINGS_RESIZE_EDGE, EDITSTRINGS_RESIZE_EDGE, EDITSTRINGS_RESIZE_EDGE, 3.0);
}

void CSingleLineNoReturnsDlg::ResetParentBottom(RECT& rect)
{
	rect.bottom = rect.top + m_yBorder + (long)(9.3*m_unit.cy);
}
/////////////////////////////////////////////////////////////////////////////////
// CSingleLineWithReturnsDlg
//

void CSingleLineWithReturnsDlg::Reset()
{
	CleanUpString( m_bstrProperty, m_strSeparator, m_strSeparator );
	// replace separators with newlines
	CComBSTR bstrFormatted;
 	ReplaceSeparatorsWithNewlines( m_bstrProperty, bstrFormatted, m_strSeparator );

 	CWindow editProp( GetDlgItem( IDC_STRING_EDIT ) );
 	::SetWindowTextW( editProp, bstrFormatted );
}

void CSingleLineWithReturnsDlg::RetrieveInfo()
{
	// property edit box
	CComBSTR bstrListData;
	RetrieveDynamicInfo(IDC_STRING_EDIT, bstrListData);
 	ReplaceNewlinesWithSeparators( bstrListData, m_bstrProperty, m_strSeparator );
}

void CSingleLineWithReturnsDlg::DoChildOnSize()
{
	double dHeight = (double)(m_nExpansionHeight - m_yBorder)/(m_unit.cy ? m_unit.cy : 1.0);
	dHeight -= 2*EDITSTRINGS_RESIZE_EDGE;	// take out the top and bottom edge spacing
	SizeSubWindow(IDC_STRING_EDIT, EDITSTRINGS_RESIZE_EDGE, EDITSTRINGS_RESIZE_EDGE, EDITSTRINGS_RESIZE_EDGE, 
		dHeight);
}

/////////////////////////////////////////////////////////////////////////////////
// CCommandsDlg
//

LRESULT CCommandsDlg::OnInitDialog( UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled )
{
	return CBaseEditStringDlg<CCommandsDlg>::OnInitDialog(uMsg, wParam, lParam, bHandled);
}

LRESULT CCommandsDlg::OnSize( UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled )
{
	return CBaseEditStringDlg<CCommandsDlg>::DoOnSize(uMsg, wParam, lParam, bHandled);
}

LRESULT CCommandsDlg::OnPaint( UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled )
{
	return CBaseEditStringDlg<CCommandsDlg>::DoOnPaint();
}

LRESULT CCommandsDlg::OnMinMaxInfo( UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled )
{
	return CBaseEditStringDlg<CCommandsDlg>::DoOnMinMaxInfo((LPMINMAXINFO)lParam);
}

void CCommandsDlg::DoChildOnSize()
{
	double dHeight = (double)(m_nExpansionHeight - m_yBorder)/(m_unit.cy ? m_unit.cy : 1.0);
	dHeight -= 2*EDITSTRINGS_RESIZE_EDGE;	// take out the top and bottom edge spacing
	SizeSubWindow(IDC_COMMANDS_EDIT, EDITSTRINGS_RESIZE_EDGE, EDITSTRINGS_RESIZE_EDGE, EDITSTRINGS_RESIZE_EDGE, 
		dHeight);
}

void CCommandsDlg::DoChildInit()
{
	if (m_hFont)
		DoSetWindowFont(IDC_COMMANDS_EDIT);
}

LRESULT CCommandsDlg::OnSetFocus( WORD, UINT, HWND, BOOL& )
{
	return CBaseEditStringDlg<CCommandsDlg>::DoOnSetFocus();
}

void CCommandsDlg::Reset()
{
 	CWindow editProp( GetDlgItem( IDC_COMMANDS_EDIT ) );
 	::SetWindowTextW( editProp, m_bstrProperty );
}

void CCommandsDlg::RetrieveInfo()
{
	// property edit box
	RetrieveDynamicInfo(IDC_COMMANDS_EDIT, m_bstrProperty);
}

LRESULT CCommandsDlg::OnOk( WORD, UINT, HWND, BOOL& )
{
	return CBaseEditStringDlg<CCommandsDlg>::DoOnOk();
}

LRESULT CCommandsDlg::OnCancel( WORD, UINT, HWND, BOOL& )
{
	return CBaseEditStringDlg<CCommandsDlg>::DoOnCancel();
}

LRESULT CCommandsDlg::OnHelp( WORD, UINT, HWND, BOOL& )
{
	return CBaseEditStringDlg<CCommandsDlg>::DoOnHelp();
}

LRESULT CCommandsDlg::OnMacros( WORD, UINT, HWND, BOOL& )
{
	return CBaseEditStringDlg<CCommandsDlg>::DoOnMacros();
}

LRESULT CCommandsDlg::OnInsertMacro( WORD, UINT, HWND, BOOL& )
{
	return CBaseEditStringDlg<CCommandsDlg>::DoOnInsertMacro();
}

/////////////////////////////////////////////////////////////////////////////////
// CMultiLineNoInheritDlg
//

LRESULT CMultiLineNoInheritDlg::OnInitDialog( UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled )
{
	return CBaseEditStringDlg<CMultiLineNoInheritDlg>::OnInitDialog(uMsg, wParam, lParam, bHandled);
}

LRESULT CMultiLineNoInheritDlg::OnSize( UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled )
{
	return CBaseEditStringDlg<CMultiLineNoInheritDlg>::DoOnSize(uMsg, wParam, lParam, bHandled);
}

LRESULT CMultiLineNoInheritDlg::OnPaint( UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled )
{
	return CBaseEditStringDlg<CMultiLineNoInheritDlg>::DoOnPaint();
}

LRESULT CMultiLineNoInheritDlg::OnMinMaxInfo( UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled )
{
	return CBaseEditStringDlg<CMultiLineNoInheritDlg>::DoOnMinMaxInfo((LPMINMAXINFO)lParam);
}

void CMultiLineNoInheritDlg::DoChildOnSize()
{
	double dHeight = (double)(m_nExpansionHeight - m_yBorder)/(m_unit.cy ? m_unit.cy : 1.0);
	dHeight -= 2*EDITSTRINGS_RESIZE_EDGE;	// take out the top and bottom edge spacing
	SizeSubWindow(IDC_MULTILINELIST, EDITSTRINGS_RESIZE_EDGE, EDITSTRINGS_RESIZE_EDGE, EDITSTRINGS_RESIZE_EDGE, 
		dHeight);
}

void CMultiLineNoInheritDlg::DoChildInit()
{
	if (m_hFont)
		DoSetWindowFont(IDC_MULTILINELIST);
}

LRESULT CMultiLineNoInheritDlg::OnSetFocus( WORD, UINT, HWND, BOOL& )
{
	return CBaseEditStringDlg<CMultiLineNoInheritDlg>::DoOnSetFocus();
}

void CMultiLineNoInheritDlg::Reset()
{
	CleanUpString( m_bstrProperty, m_strPreferredSeparator, m_strAllSeparators );
	// replace separators with newlines
	CComBSTR bstrFormatted;
 	ReplaceSeparatorsWithNewlines( m_bstrProperty, bstrFormatted, m_strPreferredSeparator );

  	CWindow editProp( GetDlgItem( IDC_MULTILINELIST ) );
	::SetWindowTextW( editProp, bstrFormatted );
}


void CMultiLineNoInheritDlg::RetrieveInfo()
{
	// property edit box
	CComBSTR bstrListData;
	RetrieveDynamicInfo(IDC_MULTILINELIST, bstrListData);
 	ReplaceNewlinesWithSeparators( bstrListData, m_bstrProperty, m_strPreferredSeparator );
}

LRESULT CMultiLineNoInheritDlg::OnOk( WORD, UINT, HWND, BOOL& )
{
	return CBaseEditStringDlg<CMultiLineNoInheritDlg>::DoOnOk();
}

LRESULT CMultiLineNoInheritDlg::OnCancel( WORD, UINT, HWND, BOOL& )
{
	return CBaseEditStringDlg<CMultiLineNoInheritDlg>::DoOnCancel();
}

LRESULT CMultiLineNoInheritDlg::OnHelp( WORD, UINT, HWND, BOOL& )
{
	return CBaseEditStringDlg<CMultiLineNoInheritDlg>::DoOnHelp();
}

LRESULT CMultiLineNoInheritDlg::OnMacros( WORD, UINT, HWND, BOOL& )
{
	return CBaseEditStringDlg<CMultiLineNoInheritDlg>::DoOnMacros();
}

LRESULT CMultiLineNoInheritDlg::OnInsertMacro( WORD, UINT, HWND, BOOL& )
{
	return CBaseEditStringDlg<CMultiLineNoInheritDlg>::DoOnInsertMacro();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\vcpb\settingspage.h ===
// SettingsPage.h : Declaration of the CSettingsPage

#ifndef __SETTINGSPAGE_H_
#define __SETTINGSPAGE_H_

#include "vsshell.h"	   // IVsPropertyPage
#include "vsmanaged.h"		// IVSMDPropertyGrid
#include "vcprojectengine.h"		// g_pProjectEngine;
#include "DTE.h"
#include "projbld2.h"
#include "vcmap.h"
#include "vshelp.h"
#include "ocdesign.h"
#include "profile.h"
#include "DirControl.h"

class COptionHandlerBase;

#include <vcdlg.h>
	
EXTERN_C const CLSID CLSID_SettingsPage;
#define INHERIT_PROP_VALUE -2
#define EDIT_PROP_VALUE -3

// static count of edit dialogs to skip
static int s_cDlgs = 0;
// static to indicate that we need to set the prop directly and not bother
// with edit dlgs...
static bool s_bSetPropNow = false;

static CComPtr<IVSMDPropertyGrid> s_pGrid;
static int s_cGrids = 0;
static void* s_pLastActive = NULL;

HRESULT OpenTopic(IVCProjectEngineImpl *pProjEngineImpl, BSTR bstrTopic);

/////////////////////////////////////////////////////////////////////////////
// CSettingsPageBase

#define CSettingsPageBaseTemplate template <class T, const CLSID * Tpclsid, DWORD TTitleID, DWORD TGroupID>
#define CSettingsPageBaseType CSettingsPageBase<T, Tpclsid, TTitleID, TGroupID>

template <class T, const CLSID * Tpclsid = &CLSID_NULL, DWORD TTitleID = 0 , DWORD TGroupID = 0>
class ATL_NO_VTABLE CSettingsPageBase :
	public IPropertyPageImpl<T>,
	public IVsPropertyPage,
	public IVCSettingsPage,
	public IVsPropertyPageNotify,
	public CDialogImpl<T>,
	public CComObjectRoot,
	public CComCoClass<T, Tpclsid>
{
public:
	BOOL		m_bActive;
	UINT		m_nLastObjects;
	IUnknown ** m_ppUnkArray;

	CSettingsPageBase();
	~CSettingsPageBase();

	enum {IDD = IDDP_SETTINGSPAGE};

DECLARE_NO_REGISTRY()
DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(T) 
	COM_INTERFACE_ENTRY(IPropertyPage)
	COM_INTERFACE_ENTRY(IVsPropertyPage)
	COM_INTERFACE_ENTRY(IVsPropertyPageNotify)
	COM_INTERFACE_ENTRY(IVCSettingsPage)
END_COM_MAP()

BEGIN_MSG_MAP(T)
	CHAIN_MSG_MAP(IPropertyPageImpl<T>)
END_MSG_MAP()

	IVSMDPropertyGrid* GetGrid();
		
// Handler prototypes:
//	LRESULT MessageHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
//	LRESULT CommandHandler(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
//	LRESULT NotifyHandler(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);

// IVSPropertyPageNotify
	STDMETHOD(OnShowPage)(BOOL fActivated);

// IVSPropertyPage
	STDMETHOD(get_CategoryTitle)( UINT iLevel, BSTR *pbstrCategory );

// IPropertyPage
	STDMETHOD(Apply)(void);
	STDMETHOD(Help)(LPCOLESTR pszHelpDir);
	STDMETHOD(Deactivate)(void);
	STDMETHOD(Activate)(HWND hWndParent, LPCRECT pRect, BOOL /* bModal */);
	STDMETHOD(GetPageInfo)(PROPPAGEINFO* pPageInfo);
	STDMETHOD(SetObjects)(ULONG nObjects, IUnknown **ppUnk);
	STDMETHOD(TranslateAccelerator)(MSG *pMsg);

// IVCSettingsPage
	STDMETHOD(Dirty)( void );
	STDMETHOD(get_NumObjects)( int* pNumObjects );
	STDMETHOD(GetObject)( int index, IUnknown **ppUnkObject );
	STDMETHOD(Refresh)( void );
	STDMETHOD(UpdateObjects)( void );

protected:
	virtual void DoCreatePageObject(UINT i, IDispatch* pDisp, IVCPropertyContainer* pLiveContainer, IVCSettingsPage* pPage);
};

// use this class if you don't have anything you need to override in CSettingsPageBase
template <const CLSID * Tpclsid = &CLSID_NULL, DWORD TTitleID = 0 , DWORD TGroupID = 0>
class ATL_NO_VTABLE CSettingsPage :
	public CSettingsPageBase<CSettingsPage, Tpclsid, TTitleID, TGroupID>
{
};

#define CPageObjectImplTemplate template<class T, long nMin, long nMax>
#define CPageObjectImplType CPageObjectImpl<T, nMin, nMax>

template<class T, long nMin, long nMax>
class CPageObjectImpl :
	public IVCPropertyContainer,
	public IVCPropertyPageObject,
	public IVsPerPropertyBrowsing,
	public IProvidePropertyBuilder,
	public IPerPropertyBrowsing
{
public:
	typedef CPageObjectImpl<T, nMin , nMax> CBase;
	CComPtr<IVCPropertyContainer> m_pContainer;
	CComPtr<IVCSettingsPage> m_pPage;
	CVCMap<long, long, CComVariant, VARIANT&> m_PropMap;

	~CPageObjectImpl(){}

	static HRESULT CreateInstance(IUnknown **pI, IVCPropertyContainer *pContainer, IVCSettingsPage *pPage);

// IVCPropertyPageObject
public:
	STDMETHOD(Close)();		// turn this object into a ZOMBIE
	
// ISpecifyPropertyPages (base for IVCPropertyContainer)
public:
	STDMETHOD(GetPages)(CAUUID*) { return E_NOTIMPL; }

// IVCPropertyContainer
public:
	STDMETHOD(Commit)();
	STDMETHOD(DirtyProp)(long id) { return S_FALSE; }
	STDMETHOD(ClearAll)();
	STDMETHOD(GetLocalProp)(long id, /*[out]*/ VARIANT *pvarValue);
	STDMETHOD(GetParentProp)(long id, VARIANT_BOOL bAllowInherit, VARIANT *pvarValue);
	STDMETHOD(Clear)(long id);
	STDMETHOD(SetProp)(long id, VARIANT varValue);
	STDMETHOD(GetProp)(long id, /*[in]*/ VARIANT *pVarValue);
	STDMETHOD(GetMultiProp)(long id, LPCOLESTR szSeparator, VARIANT_BOOL bSkipLocal, BSTR *pbstrValue);
	STDMETHOD(GetEvaluatedMultiProp)(long id, LPCOLESTR szSeparator, VARIANT_BOOL bCollapseMultiples, 
		VARIANT_BOOL bCaseSensitive, BSTR* pbstrValue);
	STDMETHOD(IsMultiProp)(long id, VARIANT_BOOL* pbIsMultiProp);
	STDMETHOD(GetMultiPropSeparator)(long id, BSTR* pbstrPreferred, BSTR* pbstrAll);
	STDMETHOD(GetStrProperty)(long idProp, BSTR* pbstrValue);
	STDMETHOD(GetEvaluatedStrProperty)(long idProp, BSTR* pbstrValue);
	STDMETHOD(SetStrProperty)(long idProp, BSTR bstrValue);
	STDMETHOD(GetIntProperty)(long idProp, long* pnValue);
	STDMETHOD(SetIntProperty)(long idProp, long nValue);
	STDMETHOD(GetBoolProperty)(long idProp, VARIANT_BOOL* pbValue);
	STDMETHOD(SetBoolProperty)(long idProp, VARIANT_BOOL bValue);
	STDMETHOD(Evaluate)(BSTR bstrIn, BSTR *bstrOut) { return E_NOTIMPL; }
	STDMETHOD(EvaluateWithValidation)(BSTR bstrSource, long idProp, BSTR* pbstrExpanded)
		{ return E_NOTIMPL; }	// TODO: use this to validate whether the input string is biting its own tail...
	STDMETHOD(HasLocalStorage)(VARIANT_BOOL /* bForSave */, VARIANT_BOOL* pbHasLocalStorage);
	STDMETHOD(GetStagedPropertyContainer)(VARIANT_BOOL bCreateIfNecessary, IVCStagedPropertyContainer** ppStagedContainer);
	STDMETHOD(ReleaseStagedPropertyContainer)();		// intended for use ONLY by the staged property container itself

	// this helper is for anybody who manipulates settings outside its own ID range (like the config general page does)
	HRESULT CommitSingleProp(long id);

	HRESULT GetEnumBoolProperty(long idProp, enumBOOL* pbValue);
	HRESULT GetEnumBoolProperty2(long idProp, long* pbValue, COptionHandlerBase* pOptHandler = NULL);
	HRESULT ToolGetIntProperty(long idProp, COptionHandlerBase* pOptHandler, long* pVal);
	HRESULT ToolGetStrProperty(long idProp, COptionHandlerBase* pOptHandler, BSTR* pVal, bool bLocalOnly = false);
	HRESULT ToolGetBoolProperty(long idProp, COptionHandlerBase* pOptHandler, VARIANT_BOOL* pVal);

// IVsPerPropertyBrowsing
public:
	STDMETHOD(HideProperty)( DISPID dispid, BOOL *pfHide);
	STDMETHOD(DisplayChildProperties)( DISPID dispid, BOOL *pfDisplay);
	STDMETHOD(GetLocalizedPropertyInfo)( DISPID dispid, LCID localeID, BSTR *pbstrName, BSTR *pbstrDesc);
	STDMETHOD(HasDefaultValue)( DISPID dispid, BOOL *pfDefault);
	STDMETHOD(IsPropertyReadOnly)( DISPID dispid, BOOL *fReadOnly);
	STDMETHOD(GetClassName)(BSTR* ) {return E_NOTIMPL;} 
	STDMETHOD(CanResetPropertyValue)(DISPID , BOOL* ) {return E_NOTIMPL;}	
	STDMETHOD(ResetPropertyValue)(DISPID ) {return E_NOTIMPL;}

// IPerPropertyBrowsing methods
public:
	STDMETHOD(MapPropertyToPage)( DISPID dispID, CLSID *pClsid ){ return E_NOTIMPL; }
	STDMETHOD(GetDisplayString)( DISPID dispID, BSTR *pBstr );
	STDMETHOD(GetPredefinedStrings)( DISPID dispID, CALPOLESTR *pCaStringsOut, CADWORD *pCaCookiesOut );
	STDMETHOD(GetPredefinedValue)( DISPID dispID, DWORD dwCookie, VARIANT* pVarOut );
	
// IProvidePropertyBuilder
public:
	STDMETHOD(MapPropertyToBuilder)( LONG dispid, LONG *pdwCtlBldType, BSTR *pbstrGuidBldr, VARIANT_BOOL *pfRetVal );
	STDMETHOD(ExecuteBuilder)( LONG dispid, BSTR bstrGuidBldr, IDispatch *pdispApp, LONG_PTR hwndBldrOwner, 
		VARIANT *pvarValue, VARIANT_BOOL *pfRetVal );

// helper functions
public:
	virtual void ResetParentIfNeeded() {}
	virtual void GetBaseDefault(long id, CComVariant& varValue);
	virtual long KludgeLocID(long id) { return id; }
	virtual BOOL UseDirectoryPickerDialog(long id) { return FALSE; }
	virtual BOOL UseCommandsDialog(long id) { return FALSE; }
	virtual BOOL UseSinglePropDirectoryPickerDialog(long id) { return FALSE; }
	virtual BOOL UseMultiLineNoInheritDialog(long id) { return FALSE; }
	virtual BOOL IsDir(long id) { return FALSE; }
	virtual BOOL IsFile(long id) { return FALSE; }
	virtual BOOL SupportsMultiLine(long id) { return FALSE; }
	virtual void GetPreferredSeparator(long id, CStringW& strSeparator) { strSeparator = L";"; }
	virtual void GetLocalizedName(DISPID dispID, MEMBERID memid, ITypeInfo2* pTypeInfo2Enum, long lVal, CComBSTR& bstrDoc);
	BOOL GetTruncatedStringForProperty(DISPID dispid, CStringW & strOut);
	void RefreshPropGrid(void);
};

/////////////////////////////////////////////////////////////////////////////
// CAdditionalOptionsPage

#define CAdditionalOptionsPageTemplate template<class I, const CLSID * Tpclsid, DWORD TGroupID, long nID >
#define CAdditionalOptionsPageType CAdditionalOptionsPage<I, Tpclsid, TGroupID, nID>

template <class I, const CLSID * Tpclsid = &CLSID_NULL, DWORD TGroupID = 0, long nID >
class ATL_NO_VTABLE CAdditionalOptionsPage :
	public IPropertyPageImpl<CAdditionalOptionsPage>,
	public IVsPropertyPage,
	public IVCSettingsPage,
	public CVCAxDialogImpl<CAdditionalOptionsPage>,
	public CComObjectRoot,
	public CComCoClass<CAdditionalOptionsPage, Tpclsid>
{
public:
	BOOL m_bActive;
	HFONT m_hFont;

	CAdditionalOptionsPage();
	~CAdditionalOptionsPage() {}

	enum {IDD = IDDP_ADDITIONALPAGE};

DECLARE_NO_REGISTRY()
DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CAdditionalOptionsPage) 
	COM_INTERFACE_ENTRY(IPropertyPage)
	COM_INTERFACE_ENTRY(IVsPropertyPage)
	COM_INTERFACE_ENTRY(IVCSettingsPage)
END_COM_MAP()

BEGIN_MSG_MAP(CAdditionalOptionsPage)
	COMMAND_HANDLER(IDC_ADDOPTIONS, EN_CHANGE, OnChange)
	MESSAGE_HANDLER(WM_PAINT, OnFocus)
	CHAIN_MSG_MAP(IPropertyPageImpl<CAdditionalOptionsPage>)
END_MSG_MAP()

// Handler prototypes:
//	LRESULT MessageHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
//	LRESULT CommandHandler(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
//	LRESULT NotifyHandler(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);

	LRESULT OnFocus(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
	LRESULT OnChange(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

	STDMETHOD(Dirty)( void );
	STDMETHOD(get_NumObjects)( int* pNumObjects );
	STDMETHOD(GetObject)( int index, IUnknown **ppUnkObject );
	STDMETHOD(Refresh)( void );
	STDMETHOD(get_CategoryTitle)( UINT iLevel, BSTR *pbstrCategory );
	STDMETHOD(Apply)(void);
	STDMETHOD(Help)(LPCOLESTR pszHelpDir);
	STDMETHOD(Deactivate)(void);
	STDMETHOD(Activate)(HWND hWndParent, LPCRECT pRect, BOOL /* bModal */);
	STDMETHOD(GetPageInfo)(PROPPAGEINFO* pPageInfo);
	STDMETHOD(SetObjects)(ULONG nObjects, IUnknown **ppUnk);
	STDMETHOD(TranslateAccelerator)(MSG *pMsg);

private:
	HRESULT UpdateObjects( bool bUpdateAllOnly = false );
};


#define EDITSTRINGS_WIDTH						44.0
#define EDITSTRINGS_BORDER_WIDTH				 2.0
#define EDITSTRINGS_BUTTON_HEIGHT				 2.0
#define EDITSTRINGS_COLLAPSED_HEIGHT			21.6
#define EDITSTRINGS_ROW1_TOP					15.0
#define EDITSTRINGS_ROW2_TOP					17.5
#define EDITSTRINGS_BUTTON_TOP1					 2.5					
#define EDITSTRINGS_COLLAPSED_BOTTOM_EDGE		22.0
#define EDITSTRINGS_RIGHT						10.0
#define EDITSTRINGS_MACROPICKER_LEFT			EDITSTRINGS_WIDTH - (EDITSTRINGS_BORDER_WIDTH + 9.0)
#define EDITSTRINGS_INSERTMACRO_LEFT			EDITSTRINGS_WIDTH - (EDITSTRINGS_BORDER_WIDTH + 40.5)
#define EDITSTRINGS_CANCEL_LEFT					EDITSTRINGS_WIDTH - (EDITSTRINGS_BORDER_WIDTH + 19.5)
#define EDITSTRINGS_OK_LEFT						EDITSTRINGS_WIDTH - (EDITSTRINGS_BORDER_WIDTH + 30.0)
#define EDITSTRINGS_RESIZE_EDGE					 0.5
#define EDITSTRINGS_RESIZE_TOP					10.0
#define EDITSTRINGS_BUTTON_WIDTH				10.0

#define EDITSTRINGS_KEY							L"VC\\EditSettingsStrings"
#define EDITSTRINGS_SAVED_HEIGHT				L"Height"
#define EDITSTRINGS_SAVED_WIDTH					L"Width"
#define EDITSTRINGS_SINGLE_SAVED_HEIGHT			L"SingleLineHeight"
#define EDITSTRINGS_SINGLE_SAVED_WIDTH			L"SingleLineWidth"

/////////////////////////////////////////////////////////////////////////////
// CBaseEditStringDlg

#define CBaseEditStringDlgTemplate template<class T>
#define CBaseEditStringDlgType CBaseEditStringDlg<T>

template <class T>
class CBaseEditStringDlg : 
	public CVCAxDialogImpl<T>
{
public:
	CBaseEditStringDlg(IVCPropertyContainer* pPropCnt, wchar_t* wszName, wchar_t* wszProp);

	// caller must free the return value
	CComBSTR GetPropertyString( void ) 
		{ return m_bstrProperty; }

	LRESULT OnInitDialog( UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled );
	LRESULT DoOnSize( UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled );
	LRESULT DoOnPaint();
	LRESULT DoOnSetFocus();
	LRESULT DoOnMacros();
	LRESULT DoOnInsertMacro();
	LRESULT DoOnOk();
	LRESULT DoOnCancel();
	LRESULT DoOnHelp();
	virtual LRESULT DoOnMinMaxInfo( LPMINMAXINFO lpMinMax );

	void DoSetWindowFont(int idControl);
	void SizeButton(int idControl, double left, double top, double right, double bottom);
	void SizeSubWindow(int idControl, double left, double top, double right, double bottom);
	void SetExpansionHeight();
	double GetExpansionExtent();
	void SetupScreenUnits();
	void RetrieveDynamicInfo(long id, CComBSTR& bstrBuffer);
	void DoCleanup();

protected:
	virtual void Reset() {}
	virtual void RetrieveInfo() {}
	virtual long GetMacroPickerParent() PURE;
	virtual long GetMacroPickerTop() { return m_nExpansionHeight + m_yBorder; }
	virtual void DoChildOnSize() {}
	virtual void DoChildInit() {}
	virtual BOOL MacroPickerSupported() { return TRUE; }
	virtual HWND GetMacroPickerParentEditWindow() { return GetDlgItem(GetMacroPickerParent()); }
	virtual LPCOLESTR GetSavedWidthString() { return EDITSTRINGS_SAVED_WIDTH; }
	virtual LPCOLESTR GetSavedHeightString() { return EDITSTRINGS_SAVED_HEIGHT; }
	virtual void ResetParentBottom(RECT& rect) { rect.bottom -= m_nExpansionHeight; }
	void ReleaseMacroPicker();
	void CleanUpString( CComBSTR & bstrVal, CStringW& strPreferredSeparator, CStringW& strAllSeparators );

protected:
	CComPtr<IVCPropertyContainer> m_pPropContainer;
	CComPtr<IVCMacroPicker> m_pMacroPicker;
	CAxWindow m_wndMacroPicker;
	CComBSTR m_bstrName;
	CComBSTR m_bstrProperty;
	SIZE m_unit;
	HFONT m_hFont;
	HPEN m_hpenBtnHilite;
	HPEN m_hpenBtnShadow;
	long m_nExpansionHeight;
	WORD m_wOriginalHeight;
	WORD m_wHeight;
	WORD m_wWidth;
	int m_xBorder;
	int m_yBorder;
	int m_yCaptionSize;
	int m_cxResizeBox;
	int m_buttonWidth;
	bool m_bExpanded;
	bool m_bInitialSizeDone;
	bool m_bInPaint;
};

/////////////////////////////////////////////////////////////////////////////
// CMultiLineDlgBase

#define CMultiLineDlgBaseTemplate template<class T, WORD wID>
#define CMultiLineDlgBaseType CMultiLineDlgBase<T, wID>

template <class T, WORD wID>
class CMultiLineDlgBase : 
	public CBaseEditStringDlg<T>
{
public:
	CMultiLineDlgBase( IVCPropertyContainer *pPropCnt, long propid, wchar_t *wszName, wchar_t *wszProp, wchar_t *wszInherit );
	~CMultiLineDlgBase() {}

BEGIN_MSG_MAP( T )
	MESSAGE_HANDLER( WM_INITDIALOG, OnInitDialog )
	MESSAGE_HANDLER( WM_SIZE, OnSize )
	MESSAGE_HANDLER( WM_PAINT, OnPaint )
	MESSAGE_HANDLER( WM_GETMINMAXINFO, OnMinMaxInfo )
	COMMAND_HANDLER( wID, EN_SETFOCUS, OnSetFocus )
	COMMAND_ID_HANDLER( IDOK, OnOk )	
	COMMAND_ID_HANDLER( IDCANCEL, OnCancel )	
	COMMAND_ID_HANDLER( IDC_SETTINGSEDIT_HELP, OnHelp )
	COMMAND_ID_HANDLER( IDC_MACROPICKER, OnMacros )
	COMMAND_ID_HANDLER( IDC_INSERTMACRO, OnInsertMacro )	
END_MSG_MAP()

	// handlers:
	LRESULT OnInitDialog( UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled )
		{ return CBaseEditStringDlg<T>::OnInitDialog(uMsg, wParam, lParam, bHandled); }
	LRESULT OnSize( UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled )
		{ return CBaseEditStringDlg<T>::DoOnSize(uMsg, wParam, lParam, bHandled); }
	LRESULT OnPaint( UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled )
		{ return CBaseEditStringDlg<T>::DoOnPaint(); }
	LRESULT OnMinMaxInfo( UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled )
		{ return CBaseEditStringDlg<T>::DoOnMinMaxInfo((LPMINMAXINFO)lParam); }
	LRESULT OnSetFocus( WORD, UINT, HWND, BOOL& )
		{ return CBaseEditStringDlg<T>::DoOnSetFocus(); }
	LRESULT OnOk( WORD, UINT, HWND, BOOL& )
		{ return CBaseEditStringDlg<T>::DoOnOk(); }
	LRESULT OnCancel( WORD, UINT, HWND, BOOL& )
		{ return CBaseEditStringDlg<T>::DoOnCancel(); }
	LRESULT OnHelp( WORD, UINT, HWND, BOOL& )
		{ return CBaseEditStringDlg<T>::DoOnHelp(); }
	LRESULT OnMacros( WORD, UINT, HWND, BOOL& )
		{ return CBaseEditStringDlg<T>::DoOnMacros(); }
	LRESULT OnInsertMacro( WORD, UINT, HWND, BOOL& )
		{ return CBaseEditStringDlg<T>::DoOnInsertMacro(); }

protected:
	virtual void RetrieveSpecificInfo(CComBSTR& bstrFixedData) PURE;

	virtual long GetMacroPickerTop() { return (long)(m_nExpansionHeight + m_yBorder + 0.5*m_unit.cx); }
	virtual long GetMacroPickerParent() { return wID; }
	virtual void RetrieveInfo();
	void CheckForInheritOnOpen( CComBSTR & bstrVal );
	bool HasInheritMacros( BSTR bstrVal );
	void DoSharedChildOnSize(double& dTotalUnits, double& dWindowUnits);
	void DoSharedChildInit();
	void DoSharedReset(CComBSTR& bstrFormatted);
	static int FindNoCaseW( const CStringW & str, const wchar_t* const substr, int pos = 0 );

protected:
	long m_lPropId;
	CComBSTR m_bstrInherit;
	bool m_bUserSetInherit;
	CStringW m_strPreferredSeparator;
	CStringW m_strAllSeparators;
};	

/////////////////////////////////////////////////////////////////////////////
// CMultiLineDlg
class CMultiLineDlg: 
	public CMultiLineDlgBase<CMultiLineDlg, IDC_MULTILINELIST>
{
public:
	CMultiLineDlg( IVCPropertyContainer *pPropCnt, long propid, wchar_t *wszName, wchar_t *wszProp, wchar_t *wszInherit ) 
		: CMultiLineDlgBase<CMultiLineDlg, IDC_MULTILINELIST>( pPropCnt, propid, wszName, wszProp, wszInherit )
	{}

	enum { IDD = IDDP_MULTI_LINE };

protected:
	virtual void DoChildOnSize();
	virtual void DoChildInit();
	virtual void Reset();

	virtual void RetrieveSpecificInfo(CComBSTR& bstrFixedData);
};

/////////////////////////////////////////////////////////////////////////////
// CMultiDirectoryPickerEditorDlg
class CMultiDirectoryPickerEditorDlg :
	public CMultiLineDlgBase<CMultiDirectoryPickerEditorDlg, IDC_DIRCONTROL>
{
public:
	CMultiDirectoryPickerEditorDlg( IVCPropertyContainer *pPropCnt, long propid, wchar_t *wszName, wchar_t *wszProp, wchar_t *wszInherit ) 
		: CMultiLineDlgBase<CMultiDirectoryPickerEditorDlg, IDC_DIRCONTROL>( pPropCnt, propid, wszName, wszProp, wszInherit )
	{}
	enum { IDD = IDDP_MULTI_DIRECTORY_PICKER_EDITOR };

protected:
	virtual void DoChildOnSize();
	virtual void DoChildInit();
	virtual void Reset();

	virtual void RetrieveSpecificInfo(CComBSTR& bstrFixedData);
	virtual BOOL MacroPickerSupported() { return FALSE; }
	virtual HWND GetMacroPickerParentEditWindow() { return NULL; }

protected:
	CAxWindow m_wndDirList;
	CComPtr<IDirList> m_pList;
};

/////////////////////////////////////////////////////////////////////////////
// CSingleLineDlgBase
template <class T, WORD wID>
class CSingleLineDlgBase : 
	public CBaseEditStringDlg<T>
{
public:
	CSingleLineDlgBase( IVCPropertyContainer *pPropCnt, wchar_t *wszName, wchar_t *wszProp ) :
		CBaseEditStringDlg<T>(pPropCnt, wszName, wszProp)
	{}

BEGIN_MSG_MAP( T )
	MESSAGE_HANDLER( WM_INITDIALOG, OnInitDialog )
	MESSAGE_HANDLER( WM_SIZE, OnSize )
	MESSAGE_HANDLER( WM_PAINT, OnPaint )
	MESSAGE_HANDLER( WM_GETMINMAXINFO, OnMinMaxInfo )
	COMMAND_HANDLER( wID, EN_SETFOCUS, OnSetFocus )
	COMMAND_ID_HANDLER( IDOK, OnOk )	
	COMMAND_ID_HANDLER( IDCANCEL, OnCancel )	
	COMMAND_ID_HANDLER( IDC_SETTINGSEDIT_HELP, OnHelp )
	COMMAND_ID_HANDLER( IDC_MACROPICKER, OnMacros ) 
	COMMAND_ID_HANDLER( IDC_INSERTMACRO, OnInsertMacro )	
END_MSG_MAP()

	// handlers:
	LRESULT OnInitDialog( UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled )
		{ return CBaseEditStringDlg<T>::OnInitDialog(uMsg, wParam, lParam, bHandled); }
	LRESULT OnSize( UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled )
		{ return DoOnSize(uMsg, wParam, lParam, bHandled); }
	LRESULT OnPaint( UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled )
		{ return DoOnPaint(); }
	LRESULT OnMinMaxInfo( UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled )
		{ return DoOnMinMaxInfo((LPMINMAXINFO)lParam); }
	LRESULT OnSetFocus( WORD, UINT, HWND, BOOL& )
		{ return DoOnSetFocus(); }
	LRESULT OnOk( WORD, UINT, HWND, BOOL& )
		{ return DoOnOk(); }
	LRESULT OnCancel( WORD, UINT, HWND, BOOL& )
		{ return DoOnCancel(); }
	LRESULT OnHelp( WORD, UINT, HWND, BOOL& )
		{ return DoOnHelp(); }
	LRESULT OnMacros( WORD, UINT, HWND, BOOL& )
		{ return DoOnMacros(); }
	LRESULT OnInsertMacro( WORD, UINT, HWND, BOOL& )
		{ return DoOnInsertMacro(); }

protected:
	virtual long GetMacroPickerParent() { return wID; }
};

/////////////////////////////////////////////////////////////////////////////
// CSingleLineDlg
template <class T>
class CSingleLineDlg : 
	public CSingleLineDlgBase<T, IDC_STRING_EDIT>
{
public:
	CSingleLineDlg( IVCPropertyContainer *pPropCnt, wchar_t *wszName, wchar_t *wszProp ) :
		CSingleLineDlgBase<T, IDC_STRING_EDIT>(pPropCnt, wszName, wszProp)
	{}
	~CSingleLineDlg() 
	{}

protected:
	virtual void DoChildInit()
	{
		if (m_hFont)
			DoSetWindowFont(IDC_STRING_EDIT);
	}
};

/////////////////////////////////////////////////////////////////////////////
// CSingleLineNoReturnsDlg
class CSingleLineNoReturnsDlg : 
	public CSingleLineDlg<CSingleLineNoReturnsDlg>
{
public:
	CSingleLineNoReturnsDlg( IVCPropertyContainer *pPropCnt, wchar_t *wszName, wchar_t *wszProp ) :
		CSingleLineDlg<CSingleLineNoReturnsDlg>(pPropCnt, wszName, wszProp)
	{}
	~CSingleLineNoReturnsDlg()
	{}

	enum { IDD = IDD_STRING_EDIT };

	virtual LRESULT DoOnMinMaxInfo( LPMINMAXINFO lpMinMax );

protected:
	virtual void Reset();
	virtual void RetrieveInfo();
	virtual void DoChildOnSize();
	virtual LPCOLESTR GetSavedWidthString() { return EDITSTRINGS_SINGLE_SAVED_WIDTH; }
	virtual LPCOLESTR GetSavedHeightString() { return EDITSTRINGS_SINGLE_SAVED_HEIGHT; }
	virtual long GetMacroPickerTop() { return (long)(3.8*m_unit.cy) + m_yBorder; }
	virtual void ResetParentBottom(RECT& rect);
};

/////////////////////////////////////////////////////////////////////////////
// CSingleLineWithReturnsDlg
class CSingleLineWithReturnsDlg : 
	public CSingleLineDlg<CSingleLineWithReturnsDlg>
{
public:
	CSingleLineWithReturnsDlg( IVCPropertyContainer *pPropCnt, wchar_t *wszName, wchar_t *wszProp, const wchar_t* wszSeparator ) :
		CSingleLineDlg<CSingleLineWithReturnsDlg>(pPropCnt, wszName, wszProp),
		m_strSeparator(wszSeparator)
	{}

	~CSingleLineWithReturnsDlg()
	{}

	enum { IDD = IDD_STRING_EDIT_WITH_RETURNS };

protected:
	virtual void Reset();
	virtual void RetrieveInfo();
	virtual void DoChildOnSize();
	
protected:
	CStringW m_strSeparator;
};

/////////////////////////////////////////////////////////////////////////////
// CSingleDirectoryPickerEditorDlg
class CSingleDirectoryPickerEditorDlg: 
	public CSingleLineDlgBase<CSingleDirectoryPickerEditorDlg, IDC_DIRCONTROL>
{
public:
	CSingleDirectoryPickerEditorDlg( IVCPropertyContainer *pPropCnt, wchar_t *wszName, wchar_t *wszProp ) :
		CSingleLineDlgBase<CSingleDirectoryPickerEditorDlg, IDC_DIRCONTROL>(pPropCnt, wszName, wszProp)
	{}

	enum { IDD = IDDP_SINGLE_DIRECTORY_PICKER_EDITOR };

protected:
	virtual void Reset();
	virtual void RetrieveInfo();
	virtual void DoChildOnSize();
	virtual void DoChildInit();
	virtual BOOL MacroPickerSupported() { return FALSE; }
	virtual HWND GetMacroPickerParentEditWindow() { return NULL; }

protected:
	CAxWindow m_wndDirList;
	CComPtr<IDirList> m_pList;
};

/////////////////////////////////////////////////////////////////////////////
// CCommandsLineDlg
class CCommandsDlg: 
	public CBaseEditStringDlg<CCommandsDlg>
{
public:
	CCommandsDlg( IVCPropertyContainer *pPropCnt, wchar_t *wszName, wchar_t *wszProp ) :
		CBaseEditStringDlg<CCommandsDlg>(pPropCnt, wszName, wszProp)
	{
	}

	~CCommandsDlg()
	{
	}

	enum { IDD = IDD_COMMANDS_EDIT };

BEGIN_MSG_MAP( CCommandsDlg )
	MESSAGE_HANDLER( WM_INITDIALOG, OnInitDialog )
	MESSAGE_HANDLER( WM_SIZE, OnSize )
	MESSAGE_HANDLER( WM_PAINT, OnPaint )
	MESSAGE_HANDLER( WM_GETMINMAXINFO, OnMinMaxInfo )
	COMMAND_HANDLER( IDC_COMMANDS_EDIT, EN_SETFOCUS, OnSetFocus )
	COMMAND_ID_HANDLER( IDOK, OnOk )	
	COMMAND_ID_HANDLER( IDCANCEL, OnCancel )	
	COMMAND_ID_HANDLER( IDC_SETTINGSEDIT_HELP, OnHelp )
	COMMAND_ID_HANDLER( IDC_MACROPICKER, OnMacros ) 
	COMMAND_ID_HANDLER( IDC_INSERTMACRO, OnInsertMacro )	
END_MSG_MAP()

	// handlers:
	LRESULT OnInitDialog( UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled );
	LRESULT OnSize( UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled );
	LRESULT OnPaint( UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled );
	LRESULT OnMinMaxInfo( UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled );
	LRESULT OnSetFocus( WORD, UINT, HWND, BOOL& ); 
	LRESULT OnOk( WORD, UINT, HWND, BOOL& );
	LRESULT OnCancel( WORD, UINT, HWND, BOOL& );
	LRESULT OnHelp( WORD, UINT, HWND, BOOL& );
	LRESULT OnMacros( WORD, UINT, HWND, BOOL& );
	LRESULT OnInsertMacro( WORD, UINT, HWND, BOOL& );
	
protected:
	virtual void Reset();
	virtual void RetrieveInfo();
	virtual long GetMacroPickerParent() { return IDC_COMMANDS_EDIT; }
	virtual void DoChildOnSize();
	virtual void DoChildInit();
};

/////////////////////////////////////////////////////////////////////////////
// CMultiLineNoInheritDlg
class CMultiLineNoInheritDlg: 
	public CBaseEditStringDlg<CMultiLineNoInheritDlg>
{
public:
	CMultiLineNoInheritDlg( IVCPropertyContainer *pPropCnt, wchar_t *wszName, wchar_t *wszProp ) :
		CBaseEditStringDlg<CMultiLineNoInheritDlg>(pPropCnt, wszName, wszProp)
	{
		m_strPreferredSeparator = L";";
		m_strAllSeparators = L";,";
	}

	~CMultiLineNoInheritDlg()
	{
	}

	enum { IDD = IDDP_MULTI_LINE_NOINHERIT };

BEGIN_MSG_MAP( CMultiLineNoInheritDlg )
	MESSAGE_HANDLER( WM_INITDIALOG, OnInitDialog )
	MESSAGE_HANDLER( WM_SIZE, OnSize )
	MESSAGE_HANDLER( WM_PAINT, OnPaint )
	MESSAGE_HANDLER( WM_GETMINMAXINFO, OnMinMaxInfo )
	COMMAND_HANDLER( IDC_MULTILINELIST, EN_SETFOCUS, OnSetFocus )
	COMMAND_ID_HANDLER( IDOK, OnOk )	
	COMMAND_ID_HANDLER( IDCANCEL, OnCancel )	
	COMMAND_ID_HANDLER( IDC_SETTINGSEDIT_HELP, OnHelp )
	COMMAND_ID_HANDLER( IDC_MACROPICKER, OnMacros ) 
	COMMAND_ID_HANDLER( IDC_INSERTMACRO, OnInsertMacro )	
END_MSG_MAP()

	// handlers:
	LRESULT OnInitDialog( UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled );
	LRESULT OnSize( UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled );
	LRESULT OnPaint( UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled );
	LRESULT OnMinMaxInfo( UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled );
	LRESULT OnSetFocus( WORD, UINT, HWND, BOOL& ); 
	LRESULT OnOk( WORD, UINT, HWND, BOOL& );
	LRESULT OnCancel( WORD, UINT, HWND, BOOL& );
	LRESULT OnHelp( WORD, UINT, HWND, BOOL& );
	LRESULT OnMacros( WORD, UINT, HWND, BOOL& );
	LRESULT OnInsertMacro( WORD, UINT, HWND, BOOL& );
	
protected:
	virtual void Reset();
	virtual void RetrieveInfo();
	virtual long GetMacroPickerParent() { return IDC_MULTILINELIST; }
	virtual void DoChildOnSize();
	virtual void DoChildInit();

protected:
	CStringW m_strPreferredSeparator;
	CStringW m_strAllSeparators;
};

#include "SettingsPage.inl"

#endif //__SETTINGSPAGE_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\vcpb\stylesheet.cpp ===
#include "stdafx.h"
#include "StyleSheet.h"
#include "vctool.h"
#include "collection.h"
//#include "configuration.h"
#include <register.h>
#include "buildengine.h"

class CInStyleClose
{
public:
	CInStyleClose() { m_bOldInClose = g_bInStyleClose; g_bInStyleClose = TRUE; }
	~CInStyleClose() { g_bInStyleClose = m_bOldInClose; }
	BOOL m_bOldInClose;
};

/////////////////////////////////////////////////////////////////////////////
//

CStyleSheetBase::CStyleSheetBase()
{
}

/* static */
HRESULT CStyleSheetBase::GetDefaultValue(long idProp, BSTR* pbstrValue, IVCPropertyContainer* pPropContainer /* = NULL */)
{
	switch (idProp)
	{
	case VCCFGID_DeleteExtensionsOnClean:
		{
			CComBSTR bstrExt = L"*.obj;*.ilk;*.pdb;*.tlb;*.tli;*.tlh;*.tmp;*.rsp;*.bat;$(TargetPath)";	// call it this unless told otherwise...
			*pbstrValue = bstrExt.Detach();
			return S_OK;
		}
//	case VCCFGID_AppliedStyleSheets:
	default:
		return COptionHandlerBase::GetDefaultString(pbstrValue);
	}
}

HRESULT CStyleSheetBase::GetDefaultValue(long idProp, long* pnValue, IVCPropertyContainer* pPropContainer /* = NULL */)
{
	switch (idProp)
	{
	case VCCFGID_UseOfMFC:
		*pnValue = (long)useMfcStdWin;
		break;
	case VCCFGID_UseOfATL:
		*pnValue = (long)useATLNotSet;
		break;
	case VCCFGID_CharacterSet:
		*pnValue = (long)charSetNotSet;
		break;
	default:
		*pnValue = 0;
	}

	return S_OK;
}

HRESULT CStyleSheetBase::GetDefaultValue(long idProp, VARIANT_BOOL* pbValue, IVCPropertyContainer* pPropContainer /* = NULL */)
{
	switch (idProp)
	{
	case VCCFGID_BuildBrowserInformation:
//	case VCCFGID_ManagedExtensions:
//	case VCCFGID_ATLMinimizesCRunTimeLibraryUsage:
	default:
		return COptionHandlerBase::GetValueFalse(pbValue);
	}
}

// this is a helper for iterating over a semi-colon delimited list of applied style sheets and breaking
// them out so they can be loaded individually; nStartStyle is expected to be initialized to zero and
// then left alone for this method to increment (as its return value)
int CStyleSheetBase::GetNextStyle(CStringW& strStyleList, int nStartStyle, int nMaxIdx, CComBSTR& bstrStyle)
{
	if (nStartStyle < 0)
		return nStartStyle;

	CStringW strStyle;
	CStringW strSemi = L";";
	int nRetVal = g_StaticBuildEngine.GetNextItem(strStyleList, nStartStyle, nMaxIdx, strSemi, strStyle);
	bstrStyle = strStyle;
	return nRetVal;
}

int CStyleSheetBase::FindStyle(CComBSTR& rbstrStyles, BSTR bstrFindStyle)
{
	CStringW strFind = bstrFindStyle;
	if (strFind.IsEmpty())
		return -1;
	strFind.MakeLower();
	CStringW strStylesTmp = rbstrStyles;
	strStylesTmp.MakeLower();
	return DoFindStyle(strStylesTmp, strFind, 0);
}

int CStyleSheetBase::DoFindStyle(CStringW& rstrStyles, CStringW& rstrFindStyle, int nStart)
{
	nStart = rstrStyles.Find(rstrFindStyle, nStart);
	if (nStart < 0)
		return nStart;

	int nStyleLen = rstrStyles.GetLength();
	int nLen = rstrFindStyle.GetLength();

	if (nStart > 0 && nStart + nLen < nStyleLen && rstrStyles[nStart-1] != ';')
		return DoFindStyle(rstrStyles, rstrFindStyle, nStart+nLen);

	else if (nStyleLen > nStart +  nLen && rstrStyles[nStart+nLen] != ';')
		return DoFindStyle(rstrStyles, rstrFindStyle, nStart+nLen);

	return nStart;
}

HRESULT CStyleSheetBase::AddStyle(CStyleSheetBase* pContainer, CComBSTR& rbstrStyles, BSTR bstrAddStyle)
{
	if (FindStyle(rbstrStyles, bstrAddStyle) >= 0)
		return S_FALSE;		// already there

	CComBSTR bstrNewStyles = bstrAddStyle;
	if (rbstrStyles.Length() > 0)
		bstrNewStyles += L";";
	bstrNewStyles += rbstrStyles;
	rbstrStyles = bstrNewStyles;

	pContainer->LoadStyle(bstrAddStyle);
	return S_OK;
}

HRESULT CStyleSheetBase::RemoveStyle(CStyleSheetBase* pContainer, CComBSTR& rbstrStyles, BSTR bstrRemoveStyle)
{
	int nLoc = FindStyle(rbstrStyles, bstrRemoveStyle);
	if (nLoc < 0)
		return S_FALSE;	// not there

	CComBSTR bstrDeadStyle = bstrRemoveStyle;
	int nLen = bstrDeadStyle.Length();
	CStringW strStylesTmp = rbstrStyles;
	int nStylesLen = strStylesTmp.GetLength();
	rbstrStyles.Empty();
	if (nLoc + nLen < nStylesLen)
		nLen++;		// there's a trailing semi-colon to get, too
	else if (nLoc > 0)
	{
		nLoc--;		// there's a leading semi-colon to get instead since we're at the end
		nLen++;
	}

	if (nLoc == 0)
		strStylesTmp = strStylesTmp.Right(nStylesLen-nLen-nLoc);
	else if (nLoc + nLen == nStylesLen)
		strStylesTmp = strStylesTmp.Left(nLoc);
	else	// pulling out of the middle
	{
		CStringW strLeft = strStylesTmp.Left(nLoc);
		CStringW strRight = strStylesTmp.Right(nStylesLen-nLen-nLoc);
		strStylesTmp = strLeft + strRight;
	}

	rbstrStyles = strStylesTmp;
	pContainer->UnloadStyle(bstrRemoveStyle);
	return S_OK;
}

HRESULT CStyleSheetBase::DoSetUseOfMFC(useOfMfc useMfc, bool bDirtyProp /* = true */)
{
	HRESULT hr = S_OK;
	if (bDirtyProp)
		hr = DoSetIntProperty(VCCFGID_UseOfMFC, FALSE, useMfc);
	RETURN_ON_FAIL(hr);

	CHECK_OK_TO_DIRTY(VCCFGID_IntrinsicAppliedStyleSheets);
	CComBSTR bstrIntrinsicStyles;
	hr = DoGetStrProperty(VCCFGID_IntrinsicAppliedStyleSheets, FALSE, &bstrIntrinsicStyles);
	RETURN_ON_FAIL(hr);
	hr = ChangeMfcStyle(this, bstrIntrinsicStyles, useMfc);
	if (hr == S_OK)
		hr = DoSetStrProperty(VCCFGID_IntrinsicAppliedStyleSheets, FALSE, bstrIntrinsicStyles);
	else if (hr == S_FALSE)
		hr = S_OK;

	return hr;
}

HRESULT CStyleSheetBase::DoSetUseOfATL(useOfATL useATL)
{
	HRESULT hr = DoSetIntProperty(VCCFGID_UseOfATL, FALSE, useATL);
	RETURN_ON_FAIL(hr);

	CHECK_OK_TO_DIRTY(VCCFGID_IntrinsicAppliedStyleSheets);
	CComBSTR bstrIntrinsicStyles;
	DoGetStrProperty(VCCFGID_IntrinsicAppliedStyleSheets, FALSE, &bstrIntrinsicStyles);
	hr = ChangeATLStyle(this, bstrIntrinsicStyles, useATL);
	if (hr == S_OK)
		DoSetStrProperty(VCCFGID_IntrinsicAppliedStyleSheets, FALSE, bstrIntrinsicStyles);
	else if (hr == S_FALSE)
		hr = S_OK;

	return hr;
}

HRESULT CStyleSheetBase::DoSetATLCRTStyle(VARIANT_BOOL bNoCRT, bool bDirtyProp /* = true */)
{
	HRESULT hr = S_OK;
	if (bDirtyProp)
		hr = DoSetBoolProperty(VCCFGID_ATLMinimizesCRunTimeLibraryUsage, FALSE, bNoCRT);
	RETURN_ON_FAIL(hr);

	CHECK_OK_TO_DIRTY(VCCFGID_IntrinsicAppliedStyleSheets);
	CComBSTR bstrIntrinsicStyles;
	DoGetStrProperty(VCCFGID_IntrinsicAppliedStyleSheets, FALSE, &bstrIntrinsicStyles);
	hr = ChangeATLCRTStyle(this, bstrIntrinsicStyles, bNoCRT);
	if (hr == S_OK)
		DoSetStrProperty(VCCFGID_IntrinsicAppliedStyleSheets, FALSE, bstrIntrinsicStyles);
	else if (hr == S_FALSE)
		hr = S_OK;

	return hr;
}

HRESULT CStyleSheetBase::DoSetCharSet(charSet set)
{
	HRESULT hr = DoSetIntProperty(VCCFGID_CharacterSet, FALSE, set);
	RETURN_ON_FAIL(hr);

	CHECK_OK_TO_DIRTY(VCCFGID_IntrinsicAppliedStyleSheets);
	CComBSTR bstrIntrinsicStyles;
	DoGetStrProperty(VCCFGID_IntrinsicAppliedStyleSheets, FALSE, &bstrIntrinsicStyles);
	hr = ChangeCharSetStyle(this, bstrIntrinsicStyles, set);
	if (hr == S_OK)
		hr = DoSetStrProperty(VCCFGID_IntrinsicAppliedStyleSheets, FALSE, bstrIntrinsicStyles);
	else if (hr == S_FALSE)
		hr = S_OK;

	return hr;
}

HRESULT CStyleSheetBase::DoSetStyle(long idProp, BSTR bstrStyle, VARIANT_BOOL bValue)
{
	HRESULT hr = DoSetBoolProperty(idProp, FALSE, bValue);
	RETURN_ON_FAIL(hr);

	CComBSTR bstrIntrinsicStyles;
	DoGetStrProperty(VCCFGID_IntrinsicAppliedStyleSheets, FALSE, &bstrIntrinsicStyles);
	if (bValue)
		hr = AddStyle(this, bstrIntrinsicStyles, bstrStyle);
	else
		hr = RemoveStyle(this, bstrIntrinsicStyles, bstrStyle);
	if (hr == S_OK)
		hr = DoSetStrProperty(VCCFGID_IntrinsicAppliedStyleSheets, FALSE, bstrIntrinsicStyles);
	else if (hr == S_FALSE)
		hr = S_OK;

	return hr;
}

useOfMfc CStyleSheetBase::DetermineMfcStyle(CComBSTR& rbstrStyles)
{
	if (FindStyle(rbstrStyles, MFCSTATIC_STYLE) >= 0)
		return useMfcStatic;
	else if (FindStyle(rbstrStyles, MFCDYNAMIC_STYLE) >= 0)
		return useMfcDynamic;
	else
		return useMfcStdWin;
}

HRESULT CStyleSheetBase::AddMfcStyle(CComBSTR& rbstrStyles, useOfMfc useMfc, CStyleSheetBase* pContainerClass)
{
	CComBSTR bstrNewStyle;
	if (useMfc == useMfcStatic)
		bstrNewStyle = MFCSTATIC_STYLE;
	else if (useMfc == useMfcDynamic)
		bstrNewStyle = MFCDYNAMIC_STYLE;
	else	// useMfc = useMfcStdWin
		bstrNewStyle = COREWIN_STYLE;

	return AddStyle(pContainerClass, rbstrStyles, bstrNewStyle);
}

HRESULT CStyleSheetBase::RemoveMfcStyle(CStyleSheetBase* pContainer, CComBSTR& rbstrStyles, useOfMfc useMfc)
{
	if (useMfc == useMfcStatic)
		return RemoveStyle(pContainer, rbstrStyles, MFCSTATIC_STYLE);

	else if (useMfc == useMfcDynamic)
		return RemoveStyle(pContainer, rbstrStyles, MFCDYNAMIC_STYLE);

	else	// useMfc = useMfcStdWin
		return RemoveStyle(pContainer, rbstrStyles, COREWIN_STYLE);
}

HRESULT CStyleSheetBase::ChangeMfcStyle(CStyleSheetBase* pContainer, CComBSTR& rbstrStyles, useOfMfc useMfc)
{
	HRESULT hrFinal = S_FALSE;
	HRESULT hr = S_FALSE;

	if (useMfc == useMfcStatic)
		hr = AddStyle(pContainer, rbstrStyles, MFCSTATIC_STYLE);
	else	// not useMfcStatic
		hr = RemoveStyle(pContainer, rbstrStyles, MFCSTATIC_STYLE);

	if (hr == S_OK)
		hrFinal = S_OK;

	if (useMfc == useMfcDynamic)
		hr = AddStyle(pContainer, rbstrStyles, MFCDYNAMIC_STYLE);
	else
		hr = RemoveStyle(pContainer, rbstrStyles, MFCDYNAMIC_STYLE);

	if (hr == S_OK)
		hrFinal = S_OK;

	CComBSTR bstrPlatName;
	pContainer->GetStrProperty(VCPLATID_Name, &bstrPlatName);
	bool bPlatformIsXbox = 0 == lstrcmp(bstrPlatName, L"Xbox");

	if(!bPlatformIsXbox){
		// Non-Xbox logic

		if (useMfc == useMfcStdWin)
			hr = AddStyle(pContainer, rbstrStyles, COREWIN_STYLE);
		else
			hr = RemoveStyle(pContainer, rbstrStyles, COREWIN_STYLE);
	}
	else {
		// Xbox specific stuff goes here
	}

	if (hr == S_OK)
		hrFinal = S_OK;

	return hrFinal;
}

HRESULT CStyleSheetBase::ChangeATLStyle(CStyleSheetBase* pContainer, CComBSTR& rbstrStyles, useOfATL useATL)
{
	HRESULT hrFinal = S_FALSE;
	HRESULT hr = S_FALSE;

	if (useATL == useATLStatic)
		hr = AddStyle(pContainer, rbstrStyles, ATLSTATIC_STYLE);
	else	// not useATLStatic
		hr = RemoveStyle(pContainer, rbstrStyles, ATLSTATIC_STYLE);

	if (hr == S_OK)
		hrFinal = S_OK;

	if (useATL == useATLDynamic)
		hr = AddStyle(pContainer, rbstrStyles, ATLDYNAMIC_STYLE);
	else
		hr = RemoveStyle(pContainer, rbstrStyles, ATLDYNAMIC_STYLE);

	if (hr == S_OK)
		hrFinal = S_OK;

	return hrFinal;
}

HRESULT CStyleSheetBase::ChangeATLCRTStyle(CStyleSheetBase* pContainer, CComBSTR& rbstrStyles, VARIANT_BOOL bNoCRT)
{
	HRESULT hrFinal = S_FALSE;
	HRESULT hr = S_FALSE;

	if (bNoCRT == VARIANT_TRUE)
		hr = AddStyle(pContainer, rbstrStyles, ATLNOCRT_STYLE);
	else	// not useATLStatic
		hr = RemoveStyle(pContainer, rbstrStyles, ATLNOCRT_STYLE);

	if (hr == S_OK)
		hrFinal = S_OK;

	if (bNoCRT == VARIANT_FALSE)
		hr = AddStyle(pContainer, rbstrStyles, ATLWITHCRT_STYLE);
	else
		hr = RemoveStyle(pContainer, rbstrStyles, ATLWITHCRT_STYLE);

	if (hr == S_OK)
		hrFinal = S_OK;

	return hrFinal;
}

HRESULT CStyleSheetBase::ChangeCharSetStyle(CStyleSheetBase* pContainer, CComBSTR& rbstrStyles, charSet set)
{
	HRESULT hrFinal = S_FALSE;
	HRESULT hr = S_FALSE;

	if (set == charSetUnicode)
		hr = AddStyle(pContainer, rbstrStyles, UNICODE_STYLE);
	else
		hr = RemoveStyle(pContainer, rbstrStyles, UNICODE_STYLE);

	if (hr == S_OK)
		hrFinal = S_OK;

	if (set == charSetMBCS)
		hr = AddStyle(pContainer, rbstrStyles, MBCS_STYLE);
	else
		hr = RemoveStyle(pContainer, rbstrStyles, MBCS_STYLE);

	if (hr == S_OK)
		hrFinal = S_OK;

	if (hr == S_OK)
		hrFinal = S_OK;

	return hrFinal;
}

long CStyleSheetBase::GetOverrideID(long idProp)
{
	switch (idProp)
	{
	case VCCFGID_IntermediateDirectory:
	case VCCFGID_OutputDirectory:
	case VCCFGID_Name:
	case VCPROJID_Name:
		return VCCFGID_AllOutputsDirty;	// the case statements here need to match the TRUE return in ConfigBuildProp
		break;
	default:
		return -1;
	};
}

HRESULT CStyleSheetBase::DoGenerateToolWrapperList()
{
	DoClearToolWrapperList();

	// the code below here picks up the tool list in effect when the configuration is created during this session
	// or when the configuration type is changed.
	// DIANEME_TODO: CStyleSheetBase::GenerateToolWrappers -- make sure we dynamically pick up any tools added later
	RETURN_ON_NULL2(m_pPlatform, E_UNEXPECTED);

	CComQIPtr<IVCCollection> spCollection;
	CComPtr<IDispatch> pDisp;
	HRESULT hr = DoGetTools(&pDisp);
	spCollection = pDisp;
	if (FAILED(hr) || spCollection == NULL)
	{
		VSASSERT(FALSE, "No tools!?!");
		return hr;
	}

	CComPtr<IEnumVARIANT> pEnum;
	hr = spCollection->_NewEnum(reinterpret_cast<IUnknown **>(&pEnum));
	RETURN_ON_FAIL_OR_NULL2(hr, pEnum, E_UNEXPECTED);

	pEnum->Reset();
	while (TRUE)
	{
		CComVariant var;
		hr = pEnum->Next(1, &var, NULL);
		if (hr != S_OK)
			break;
		else if (var.vt != VT_UNKNOWN)
		{
			VSASSERT(FALSE, "Bad member of the collection");
			continue;
		}
		IUnknown* pUnkTool = var.punkVal;
		CComQIPtr<IVCToolImpl> spTool = pUnkTool;
		if (spTool == NULL)	// some lists appear to end in NULL...
			continue;

		CBldToolWrapper* pToolWrapper = new CBldToolWrapper(spTool);
		m_toolWrapperList.AddTail(pToolWrapper);
	}

	return S_OK;
}

HRESULT CStyleSheetBase::DoGetPlatform(IDispatch** ppVal)
{
	CHECK_POINTER_VALID(ppVal);
	*ppVal = NULL;
		
	if (m_pPlatform)
		return m_pPlatform.QueryInterface(ppVal);

	return S_OK;
}

HRESULT CStyleSheetBase::DoGetTools(IDispatch** ppVal)
{
	CHECK_POINTER_VALID(ppVal);
		
	CComPtr<IVCCollection> pCollection;
	HRESULT hr = CCollection<IVCToolImpl>::CreateInstance(&pCollection, &m_rgTools);
	if (SUCCEEDED(hr))
	{
		hr = pCollection.QueryInterface(ppVal);
	}
	return hr;
}

HRESULT CStyleSheetBase::DoGetFileTools(IVCCollection** ppVal)
{
	CHECK_POINTER_VALID(ppVal);
		
	CComPtr<IVCCollection> pCollection;
	HRESULT hr = CCollection<IVCToolImpl>::CreateInstance(&pCollection, &m_rgFileTools);
	if (SUCCEEDED(hr))
		*ppVal = pCollection.Detach();
	return hr;
}

HRESULT CStyleSheetBase::DoGetStyleSheets(IDispatch** ppVal)
{
	CHECK_POINTER_VALID(ppVal);

	m_rgStyleSheets.Clear();
	long lcItems = m_rgParents.GetSize();
	for (long l = 0; l < lcItems; l++)
	{
		CComQIPtr<VCStyleSheet> pStyle = m_rgParents.GetAt(l);
		if (pStyle)
			m_rgStyleSheets.AddTail(pStyle);
	}

	CComPtr<IVCCollection> pCollection;
	HRESULT hr = CCollection<VCStyleSheet>::CreateInstance(&pCollection, &m_rgStyleSheets);
	if (SUCCEEDED(hr))
	{
		hr = pCollection.QueryInterface(ppVal);
	}
	return hr;
}

HRESULT CStyleSheetBase::DoClearToolWrapperList()
{
	CBldToolWrapper* pToolWrapper;
	while (!m_toolWrapperList.IsEmpty())
	{
		pToolWrapper = (CBldToolWrapper*)m_toolWrapperList.RemoveHead();
		delete pToolWrapper;
	}

	return S_OK;
}

HRESULT CStyleSheetBase::FinishClose()
{
	long lcItems = m_rgParents.GetSize();
	for (long l = 0; l < lcItems; l++)
	{
		CComPtr<IVCPropertyContainer> spPropContainer;
		spPropContainer = m_rgParents.GetAt(l);
		CComQIPtr<IVCStyleSheetImpl> spStyleSheetImpl = spPropContainer;
		if (spStyleSheetImpl)
			spStyleSheetImpl->RemoveDependent(this, !g_bInProjClose);
	}
	m_rgStyleSheets.RemoveAll();	// this is just a duplicate collection, so don't need to do anything special

	m_pPlatform.Release();
	ClearTools();

	return CPropertyContainerImpl::FinishClose();
}

void CStyleSheetBase::ClearTools()
{
	long l, lcItems;
	lcItems = m_rgTools.GetSize();
	for (l = 0; l < lcItems; l++)
	{
		CComPtr<IVCToolImpl> pToolImpl;
		pToolImpl = m_rgTools.GetAt(l);
		if (pToolImpl)
			pToolImpl->Close(); // close down entirely; release all
	}
	m_rgTools.RemoveAll();
	m_rgFileTools.RemoveAll();	// this is a proper subset of m_rgTools, so close happened above

	DoClearToolWrapperList();
}

toolSetType CStyleSheetBase::DetermineBaseType(ConfigurationTypes configType)
{
	switch (configType)
	{
	case typeUnknown:
		return toolSetMakefile;
		break;
	case typeApplication:
	case typeDynamicLibrary:
		return toolSetLinker;
		break;
	case typeStaticLibrary:
		return toolSetLibrarian;
		break;
	default:
		VSASSERT(FALSE, "Illegal configuration type");
		// fall through
	case typeGeneric:
		return toolSetUtility;
		break;
	}
}

HRESULT CStyleSheetBase::DoSetAppliedStyleSheets(BSTR bstrStyles, BOOL bCheckSpecial)
{
	if (bCheckSpecial)
	{
		CHECK_OK_TO_DIRTY(VCCFGID_AppliedStyleSheets);
		CComBSTR bstrNewStyles = bstrStyles;
		int nNewLen = bstrNewStyles.Length();
		int nStartStyle = 0, nMaxIdx;
		CComBSTR bstrOldStyles;
		CStringW strStyleList;
		HRESULT hr = DoGetStrProperty(VCCFGID_AppliedStyleSheets, FALSE, &bstrOldStyles);
		if (hr == S_OK && bstrOldStyles.Length() > 0)
		{
			strStyleList = bstrOldStyles;
			nMaxIdx = strStyleList.GetLength();
			while (nStartStyle >= 0)
			{
				CComBSTR bstrStyle;
				nStartStyle = GetNextStyle(strStyleList, nStartStyle, nMaxIdx, bstrStyle);
				if (bstrStyle.Length() > 0 && (nNewLen == 0 || FindStyle(bstrNewStyles, bstrStyle) < 0))
					UnloadStyle(bstrStyle);
			}
		}
		if (nNewLen > 0)
		{
			strStyleList = bstrNewStyles;
			nStartStyle = 0;
			nMaxIdx = strStyleList.GetLength();
			while (nStartStyle >= 0)
			{
				CComBSTR bstrStyle;
				nStartStyle = GetNextStyle(strStyleList, nStartStyle, nMaxIdx, bstrStyle);
				if (bstrStyle.Length() > 0)
					LoadStyle(bstrStyle, FALSE, FALSE);
			}
		}
	}
	return DoSetStrProperty(VCCFGID_AppliedStyleSheets, FALSE, bstrStyles);
}

void CStyleSheetBase::ResolveStyleSheetToPath(BSTR bstrStyle, CComBSTR& bstrStylePath)
{
	// DIANEME_TODO: right now, we're going to assume that style sheets are always in the VCProjectDefaults folder
	// This needs to be updated to either check along a path or go to whatever the right place might be.
	CComBSTR bstrPath;
	HRESULT hr = VCGetEnvironmentVariableW(L"VC_STYLESHEETS_PATH",&bstrPath);
	if( FAILED(hr) )
	{
	    CStringW	strPath;
	    UtilGetVCInstallFolder(strPath);
	    strPath += L"VCProjectDefaults\\";
	    strPath += bstrStyle;
	    bstrStylePath = strPath;
	}
	else
	{
	    bstrStylePath = bstrPath;
	    bstrStylePath.Append(bstrStyle);
	}
}

HRESULT CStyleSheetBase::LoadStyle(BSTR bstrStyle, BOOL bLoadFront /* = TRUE */, BOOL bIsSystemStyle /* = TRUE */)
{
	CComQIPtr<IVCProjectEngineImpl> spProjectEngineImpl = g_pProjectEngine;
	if (spProjectEngineImpl == NULL)
		return CVCProjectEngine::DoSetErrorInfo(VCPROJ_E_INTERNAL_ERR, IDS_ERR_INTERNAL_ERROR);

	CComBSTR bstrStylePath;
	ResolveStyleSheetToPath(bstrStyle, bstrStylePath);

	CComPtr<IDispatch> spDispStyleSheet;
	HRESULT hr = spProjectEngineImpl->LoadHiddenStyleSheet(bstrStylePath, &spDispStyleSheet);
	if (FAILED(hr))
	{
		// DIANEME_TODO: do we want to put something in the task list if we fail to load a style sheet?
		CStringW strError;
		strError.Format(bIsSystemStyle ? IDS_E_SYS_STYLE_LOAD_FAILED : IDS_E_USER_STYLE_LOAD_FAILED, bstrStylePath);
		CComBSTR bstrError = strError;
		// DIANEME_TODO: do we want to push a help topic keyword when we report a stylesheet load error?
		spProjectEngineImpl->DoFireReportError(bstrError, hr, NULL);
		return hr;
	}

	CComQIPtr<IVCStyleSheetImpl> spStyleSheetImpl = spDispStyleSheet;
	CComQIPtr<IVCPropertyContainer> spPropContainer = spDispStyleSheet;
	if (spStyleSheetImpl == NULL || spPropContainer == NULL)
		return CVCProjectEngine::DoSetErrorInfo(VCPROJ_E_INTERNAL_ERR, IDS_ERR_INTERNAL_ERROR);

	hr = spStyleSheetImpl->AddDependent(this, !g_bInProjLoad);
	if (hr == S_OK)	// not already there
	{
		if (bLoadFront)
			m_rgParents.AddHead(spPropContainer);
		else
			m_rgParents.AddTail(spPropContainer);
	}

	return hr;
}

HRESULT CStyleSheetBase::UnloadStyle(BSTR bstrStyle)
{
	CComQIPtr<IVCProjectEngineImpl> spProjectEngineImpl = g_pProjectEngine;
	if (spProjectEngineImpl == NULL)
		return CVCProjectEngine::DoSetErrorInfo(VCPROJ_E_INTERNAL_ERR, IDS_ERR_INTERNAL_ERROR);

	CComPtr<IDispatch> spDispStyleSheetList;
	HRESULT hr = spProjectEngineImpl->get_AllStyleSheets(&spDispStyleSheetList);

	CComQIPtr<IVCCollection> spStyleSheetList = spDispStyleSheetList;
	RETURN_ON_FAIL_OR_NULL2(hr, spStyleSheetList, E_UNEXPECTED);

	CComBSTR bstrStylePath;
	ResolveStyleSheetToPath(bstrStyle, bstrStylePath);
	CComPtr<IDispatch> spDispStyleSheet;
	hr = spStyleSheetList->Item(CComVariant(bstrStylePath), &spDispStyleSheet);
	RETURN_ON_FAIL_OR_NULL2(hr, spDispStyleSheet, S_FALSE);		// not a problem not to find it

	CComQIPtr<IVCPropertyContainer> spPropContainer = spDispStyleSheet;
	CComQIPtr<IVCStyleSheetImpl> spStyleSheetImpl = spDispStyleSheet;
	if (spPropContainer == NULL || spStyleSheetImpl == NULL)
		return CVCProjectEngine::DoSetErrorInfo(VCPROJ_E_INTERNAL_ERR, IDS_ERR_INTERNAL_ERROR);

	m_rgParents.Remove(spPropContainer);
	spStyleSheetImpl->RemoveDependent(this, !g_bInProjClose);

	return S_OK;
}

HRESULT CStyleSheetBase::InitializeTools(void)
{
	ClearTools();	// in case we've been here before...

	// fill in tools collection on the config
	HRESULT hr;
	CComQIPtr<IVCCollection> pColl;
	CComQIPtr<IVCPropertyContainer> pPropContainer = this;
	CComPtr<IEnumVARIANT> pEnumVar;
	CComPtr<IDispatch> pDisp;

	CComQIPtr<IVCPlatformImpl> spPlatformImpl = m_pPlatform;
	if (m_pPlatform == NULL || spPlatformImpl == NULL)
		return E_UNEXPECTED;

	// walk the platform tool collection
	hr = m_pPlatform->get_Tools(&pDisp);
	pColl = pDisp;
	RETURN_ON_FAIL(hr);
	if (pColl == NULL)
		return CVCProjectEngine::DoSetErrorInfo(VCPROJ_E_INTERNAL_ERR, IDS_ERR_INTERNAL_ERROR);

	// get the enum
	hr = pColl->_NewEnum(reinterpret_cast<IUnknown **>(&pEnumVar));
	RETURN_ON_FAIL(hr);
	if (pEnumVar == NULL)
		return CVCProjectEngine::DoSetErrorInfo(VCPROJ_E_INTERNAL_ERR, IDS_ERR_INTERNAL_ERROR);

	toolSetType listStyle;
	DoGetToolSetType(listStyle);

	if( !pPropContainer )
		return E_NOINTERFACE;

	hr = pEnumVar->Reset();
	while (true)
	{
		CComVariant varRes;
		hr = pEnumVar->Next(1, &varRes, NULL);
		if (hr == S_OK && (varRes.vt == VT_DISPATCH || varRes.vt == VT_UNKNOWN))
		{
			CComQIPtr<IVCToolImpl> pTool = varRes.pdispVal;
			VARIANT_BOOL bInToolset = VARIANT_FALSE;
			hr = spPlatformImpl->IsToolInToolset(listStyle, pTool, &bInToolset);
			RETURN_ON_FAIL(hr);
			if (!bInToolset)
				continue;

			hr = AddSingleTool(pPropContainer, pTool, FALSE);
			RETURN_ON_FAIL(hr);
		}
		else
			break;
	}

	DoGenerateToolWrapperList();

	VerifyFileTools();

	return S_OK;
}

HRESULT CStyleSheetBase::AddSingleTool(IVCPropertyContainer* pPropContainer, IVCToolImpl* pTool, BOOL bGenWrapper,
	IDispatch** ppDispTool /* = NULL */)
{
	if (ppDispTool)
		*ppDispTool = NULL;

	CComPtr<IVCToolImpl> pCfgTool;
	// IVCToolImpl::CreateToolObject on each tool (passing VCConfiguration)
	HRESULT hr = pTool->CreateToolObject(pPropContainer, &pCfgTool);
	RETURN_ON_FAIL(hr);
	if (pCfgTool == NULL)
		return CVCProjectEngine::DoSetErrorInfo(VCPROJ_E_NO_TOOL, IDS_ERR_NO_MATCHING_TOOL);
	// stuff into collection (m_rgTools)
	m_rgTools.Add(pCfgTool);
	// determine whether we're dealing with a file tool and stuff into collection if it is (m_rgFileTools)
	VARIANT_BOOL bIsFileTool = VARIANT_FALSE;
	pCfgTool->get_IsFileTool(&bIsFileTool);
	if (bIsFileTool)
		m_rgFileTools.Add(pCfgTool);

	if (ppDispTool)
	{
		CComQIPtr<IDispatch> pDispRealTool = pCfgTool;
		*ppDispTool = pDispRealTool.Detach();
	}

	if (bGenWrapper)
	{
		CBldToolWrapper* pToolWrapper = new CBldToolWrapper(pCfgTool);
		m_toolWrapperList.AddTail(pToolWrapper);
	}

	return S_OK;
}

HRESULT CStyleSheetBase::DoSetProp(long id, BOOL bCheckSpecial, VARIANT varValue, long nOverride /* = -1 */)
{
	CHECK_OK_TO_DIRTY(id);

	if (bCheckSpecial)
	{
		switch (varValue.vt)
		{
		case VT_I2:
			return DoSetBoolProperty(id, TRUE, varValue.boolVal);
		case VT_I4:
			return DoSetIntProperty(id, TRUE, varValue.lVal);
		case VT_BSTR:
			return DoSetStrProperty(id, TRUE, varValue.bstrVal);
		// default case is to do nothing here
		}
	}

	return CPropertyContainerImpl::DoSetProp(id, bCheckSpecial, varValue, nOverride);
}

HRESULT CStyleSheetBase::DoGetProp(long id, BOOL bCheckSpecialProps, VARIANT *pVarValue)
{
	// check if it is a special prop that really has local storage (or belongs to a non-property container parent 
	// who does) first
	if (bCheckSpecialProps)
	{
		CHECK_POINTER_NULL(pVarValue);
		CComBSTR bstrProp;
		if (DoGetStrProperty(id, TRUE, &bstrProp) == S_OK)
		{
			pVarValue->bstrVal = bstrProp.Detach();
			pVarValue->vt = VT_BSTR;
			return S_OK;
		}
	}

	return CPropertyContainerImpl::DoGetProp(id, bCheckSpecialProps, pVarValue);
}

HRESULT CStyleSheetBase::DoSetStrProperty(long idProp, BOOL bCheckSpecial, BSTR bstrValue, long nOverrideID /* = -1 */)
{
	if (bCheckSpecial)
	{
		if (idProp == VCCFGID_AppliedStyleSheets)
			return DoSetAppliedStyleSheets(bstrValue, TRUE);
	}

	return CPropertyContainerImpl::DoSetStrProperty(idProp, bCheckSpecial, bstrValue, GetOverrideID(idProp));
}

HRESULT CStyleSheetBase::DoSetIntProperty(long idProp, BOOL bCheckSpecial, long nValue, long nOverrideID /* = -1 */)
{
	if (bCheckSpecial)
	{
		if (idProp == VCCFGID_UseOfMFC || idProp == VCCFGID_UseOfATL || idProp == VCCFGID_CharacterSet)
		{
			long nOldProp;
			HRESULT hr = DoGetIntProperty(idProp, FALSE, (long *)&nOldProp);
			if (hr == S_OK && nValue == nOldProp)
				return S_OK;	// nothing to do
			
			switch (idProp)
			{
			case VCCFGID_UseOfMFC:
				return DoSetUseOfMFC((useOfMfc)nValue);
			case VCCFGID_UseOfATL:
				return DoSetUseOfATL((useOfATL)nValue);
			case VCCFGID_CharacterSet:
				return DoSetCharSet((charSet)nValue);
			}
		}
	}

	return CPropertyContainerImpl::DoSetIntProperty(idProp, bCheckSpecial, nValue, nOverrideID);
}

HRESULT CStyleSheetBase::DoSetBoolProperty(long idProp, BOOL bCheckSpecial, VARIANT_BOOL bValue, long nOverrideID /* = -1 */)
{
	if (bCheckSpecial)
	{
		if (idProp == VCCFGID_BuildBrowserInformation || idProp == VCCFGID_ManagedExtensions 
			|| idProp == VCCFGID_ATLMinimizesCRunTimeLibraryUsage || idProp == VCCFGID_WholeProgramOptimization)
		{
			VARIANT_BOOL bOldValue;
			HRESULT hr = DoGetBoolProperty(idProp, FALSE, &bOldValue);
			if (hr == S_OK && bOldValue == bValue)
				return S_OK;	// nothing to do
			switch (idProp)
			{
			case VCCFGID_BuildBrowserInformation:
				return DoSetStyle(idProp, BSCMAKE_STYLE, bValue);
			case VCCFGID_ManagedExtensions:
				return DoSetStyle(idProp, MANAGED_STYLE, bValue);
			case VCCFGID_ATLMinimizesCRunTimeLibraryUsage:
				return DoSetATLCRTStyle(bValue);
			default:
				VSASSERT(idProp == VCCFGID_WholeProgramOptimization, "Hey, bad case statement!");
				return DoSetStyle(idProp, WHOLEPROGOPTIMIZE_STYLE, bValue);
			}
		}
	}

	return CPropertyContainerImpl::DoSetBoolProperty(idProp, FALSE, bValue);
}

HRESULT CStyleSheetBase::DoClear(long id, long nOverrideID /* = -1 */)
{
	CHECK_OK_TO_DIRTY(id);

	switch (id)		// to fix up the applied styles
	{
	case VCCFGID_BuildBrowserInformation:
	case VCCFGID_ManagedExtensions:
		DoSetBoolProperty(id, FALSE, VARIANT_FALSE);
		break;
	case VCCFGID_UseOfMFC:
		DoSetIntProperty(VCCFGID_UseOfMFC, FALSE, useMfcStdWin);
		break;
	case VCCFGID_ConfigurationType:
		{
			long nOldValue;
			GetParentIntProperty(id, &nOldValue);
			DoSetIntProperty(id, FALSE, nOldValue);	// allow intrinsic style sheets to clear out
		}
		break;
	// nothing to do for default
	};

	return CPropertyContainerImpl::DoClear(id, nOverrideID);
}

STDMETHODIMP CStyleSheetBase::IsMultiProp(long idProp, VARIANT_BOOL* pbIsMulti)
{
	CHECK_POINTER_NULL(pbIsMulti);
	*pbIsMulti = VARIANT_FALSE;

	// let's check locally first
	if (idProp >= VCCONFIGURATION_MIN_DISPID && idProp <= VCCONFIGURATION_MAX_DISPID)
		return S_OK;	// belongs to a config; no multi-props here
	else if (idProp >= VCSTYLESHEET_MIN_DISPID && idProp <= VCSTYLESHEET_MAX_DISPID)
		return S_OK;	// belongs to a style sheet; no multi-props here

	// try our tools
	HRESULT hr = S_FALSE;
	long lcItems = m_rgTools.GetSize();
	// if a tool owns an ID, it will return S_OK regardless of whether the property is a multi-prop or not
	for (long idx = 0; hr != S_OK && idx < lcItems; idx++)
	{
		CComPtr<IVCToolImpl> pToolImpl;
		pToolImpl = m_rgTools.GetAt(idx);
		if (pToolImpl)
			hr = pToolImpl->IsMultiProp(idProp, pbIsMulti);
	}

	return hr;
}

STDMETHODIMP CStyleSheetBase::GetMultiPropSeparator(long idProp, BSTR* pbstrPreferred, BSTR* pbstrAll)
{
	CHECK_POINTER_NULL(pbstrPreferred);
	CHECK_POINTER_NULL(pbstrAll);
	*pbstrPreferred = NULL;
	*pbstrAll = NULL;

	// let's check locally first
	if (idProp >= VCCONFIGURATION_MIN_DISPID && idProp <= VCCONFIGURATION_MAX_DISPID)
		return S_OK;	// belongs to a config; no multi-props here
	else if (idProp >= VCSTYLESHEET_MIN_DISPID && idProp <= VCSTYLESHEET_MAX_DISPID)
		return S_OK;	// belongs to a style sheet; no multi-props here

	// try our tools
	HRESULT hr = S_FALSE;
	long lcItems = m_rgTools.GetSize();
	// if a tool owns an ID, it will return S_OK regardless of whether the property is a multi-prop or not
	for (long idx = 0; hr != S_OK && idx < lcItems; idx++)
	{
		CComPtr<IVCToolImpl> pToolImpl;
		pToolImpl = m_rgTools.GetAt(idx);
		if (pToolImpl)
			hr = pToolImpl->GetMultiPropSeparator(idProp, pbstrPreferred, pbstrAll);
	}

	return hr;
}

HRESULT CStyleSheetBase::DoAddTool(LPCOLESTR szToolName, IDispatch** ppTool)
{
	CHECK_POINTER_VALID(ppTool);
	*ppTool = NULL;

	CComQIPtr<IVCProjectEngineImpl> spProjEngineImpl = g_pProjectEngine;
	RETURN_ON_NULL2(spProjEngineImpl, E_UNEXPECTED);

	CComPtr<IDispatch> spDispTools;
	HRESULT hr = spProjEngineImpl->get_VendorTools(&spDispTools);
	CComQIPtr<IVCCollection> spTools = spDispTools;
	RETURN_ON_FAIL_OR_NULL2(hr, spTools, E_UNEXPECTED);

	CComPtr<IDispatch> spDispBaseTool;
	hr = spTools->Item(CComVariant(szToolName), &spDispBaseTool);
	if (spDispBaseTool == NULL)	// not already present
		hr = spProjEngineImpl->AddVendorTool(szToolName, NULL, &spDispBaseTool);
	CComQIPtr<IVCToolImpl> spBaseTool = spDispBaseTool;
	RETURN_ON_FAIL_OR_NULL2(hr, spBaseTool, E_UNEXPECTED);

	return AddSingleTool(this, spBaseTool, TRUE, ppTool);
}

/////////////////////////////////////////////////////////////////////////////
//
CStyleSheet::CStyleSheet()
{
	m_bDirty = VARIANT_FALSE;
	m_nLoadCount = 0;
}

HRESULT CStyleSheet::CreateInstance(VCStyleSheet **ppVCStyleSheet)
{
	CHECK_POINTER_NULL(ppVCStyleSheet);

	CStyleSheet *pVar;
	CComObject<CStyleSheet> *pObj;
	HRESULT hr = CComObject<CStyleSheet>::CreateInstance(&pObj);
	if (SUCCEEDED(hr))
	{
		pVar = pObj;
		pVar->AddRef();
		pVar->Initialize();
		*ppVCStyleSheet = pVar;
	}
	return hr;
}

HRESULT CStyleSheet::Initialize()
{
	toolSetType ToolSet;
	SGetToolSet(&ToolSet);
	return DoSetToolSet(ToolSet, TRUE);
}

HRESULT CStyleSheet::DoSetToolSet(toolSetType toolSet, BOOL bForceUpdate /* = FALSE */)
{
	if (!bForceUpdate)
	{
		toolSetType oldToolSet;
		GetIntProperty(VCSTYLEID_ToolSet, (long *)&oldToolSet);
		if (oldToolSet == toolSet)
			return S_OK;	// no-op
	}

	HRESULT hr = DoSetIntProperty(VCSTYLEID_ToolSet, FALSE, toolSet);
	RETURN_ON_FAIL(hr);

	InitializeTools();

	return hr;
}

HRESULT CStyleSheet::DoSetIntProperty(long idProp, BOOL bCheckSpecial, long nValue, long nOverrideID /* = -1 */)
{
	if (bCheckSpecial)
	{
		if (idProp == VCSTYLEID_ToolSet)
			return DoSetToolSet((toolSetType)nValue);
	}

	return CStyleSheetBase::DoSetIntProperty(idProp, bCheckSpecial, nValue, nOverrideID);
}

STDMETHODIMP CStyleSheet::get_StyleSheetName(BSTR * pVal)
{
	CHECK_POINTER_VALID(pVal);
	return m_bstrName.CopyTo(pVal);
}

STDMETHODIMP CStyleSheet::put_StyleSheetName(BSTR bstrVal)
{
	CHECK_OK_TO_DIRTY(VCSTYLEID_StyleSheetName);
	m_bstrName = bstrVal;
	return S_OK;
}

STDMETHODIMP CStyleSheet::get_StyleSheetFile(BSTR * pVal)
{
	CHECK_POINTER_VALID( pVal );
	CComBSTR bstrStyleSheetFile;

	bstrStyleSheetFile = m_bstrFullDir;
	bstrStyleSheetFile.Append(m_bstrFileName);
	*pVal = bstrStyleSheetFile.Detach();
	return S_OK;
}

STDMETHODIMP CStyleSheet::put_StyleSheetFile(BSTR bstrVal)
{
	// validate name
	// check for all whitespace or 0 length string
	CStringW strFile = bstrVal;
	strFile.TrimLeft();
	strFile.TrimRight();
	if( strFile.IsEmpty() )
		return S_OK;

	CPathW pathFile;
	if (!pathFile.Create(strFile))
		return E_FAIL;

	CDirW dirStyle;
	if (!dirStyle.CreateFromPath(pathFile))
		return E_FAIL;

	CHECK_OK_TO_DIRTY(VCSTYLEID_StyleSheetFile);

	strFile = pathFile.GetFileName();
	CStringW strStyleDir = dirStyle;

	m_bstrFileName = strFile;
	m_bstrFullDir = strStyleDir;

	return S_OK;
}

STDMETHODIMP CStyleSheet::get_Name(BSTR * pVal)
{
	CHECK_POINTER_VALID(pVal);
	return m_bstrName.CopyTo(pVal);
}

STDMETHODIMP CStyleSheet::put_Name(BSTR newVal)
{
	CHECK_OK_TO_DIRTY(VCSTYLEID_Name);
	m_bstrName = newVal;

	if (m_bstrFileName.Length() == 0)
		put_StyleSheetFile(newVal); // assume we haven't done this either...

	return S_OK;
}

STDMETHODIMP CStyleSheet::MatchName(BSTR bstrNameToMatch, VARIANT_BOOL bFullOnly, VARIANT_BOOL *pbMatched)
{
	CHECK_POINTER_VALID(pbMatched);
	*pbMatched = VARIANT_FALSE;
	if (!bFullOnly && _wcsicmp(m_bstrName,bstrNameToMatch) == 0)
	{
		*pbMatched = VARIANT_TRUE;
	}
	else if (m_bstrFileName == bstrNameToMatch)
	{
		*pbMatched = VARIANT_TRUE;
	}
	else
	{
		CComBSTR bstrName = m_bstrFullDir;
		int nLen = bstrName.Length();
		if (nLen > 0 && bstrName[nLen-1] != L'\\' && bstrName[nLen-1] != L'/')
			bstrName += L"\\";
		bstrName += m_bstrFileName;
		if (_wcsicmp(bstrName,bstrNameToMatch) == 0)
		{
			*pbMatched = VARIANT_TRUE;
		}
		else
		{
			CPathW pathSrc, pathMatch; // to handle case where shell passes in something
			CStringW strMatch; //    like "X:\\tests\mfcone\mfcone.vcstyle"
			CStringW strName = bstrName;
			strMatch = bstrNameToMatch;
			pathSrc.Create(strName);
			pathMatch.Create(strMatch);
			if (pathSrc == pathMatch)
			{
				*pbMatched = VARIANT_TRUE;
			}
		}
	}
	return S_OK;
}

STDMETHODIMP CStyleSheet::get_IsDirty(VARIANT_BOOL *pBoolDirty)
{
	CHECK_POINTER_VALID( pBoolDirty );
	*pBoolDirty = m_bDirty;
	return S_OK;
}

STDMETHODIMP CStyleSheet::put_IsDirty(VARIANT_BOOL boolDirty)
{
	// can't dirty while in style sheet load
	if( !g_bInStyleLoad )
	{
		if( boolDirty && !m_bDirty )
		{
			// FUTURE: when we allow for changing style sheets, we need to hook up to SCC to figure out if we're allowed to do this
		}

		m_bDirty = boolDirty;
	}
	return S_OK;
}


STDMETHODIMP CStyleSheet::SaveObject( IStream *xml, IVCPropertyContainer *pPropCnt, long nIndent )
{
	return E_NOTIMPL;
}

STDMETHODIMP CStyleSheet::get_ToolSet(toolSetType* pToolSet)
{
	CHECK_POINTER_VALID(pToolSet);
	HRESULT hr = GetIntProperty(VCSTYLEID_ToolSet, (long *)pToolSet);
	if (hr == S_FALSE)
		SGetToolSet(pToolSet);
	return hr;
}

STDMETHODIMP CStyleSheet::put_ToolSet(toolSetType ToolSet)
{
	if (ToolSet < toolSetUtility || ToolSet > toolSetAll)
		RETURN_INVALID();	// out of range

	return SetIntProperty(VCSTYLEID_ToolSet, ToolSet);
}

STDMETHODIMP CStyleSheet::get_IntermediateDirectory(BSTR * pVal)
{
	return GetStrProperty(VCCFGID_IntermediateDirectory, pVal);
}

STDMETHODIMP CStyleSheet::put_IntermediateDirectory(BSTR newVal)
{
	return SetStrProperty(VCCFGID_IntermediateDirectory, newVal);
}

STDMETHODIMP CStyleSheet::get_OutputDirectory(BSTR * pVal)
{
	return GetStrProperty(VCCFGID_OutputDirectory, pVal);
}

STDMETHODIMP CStyleSheet::put_OutputDirectory(BSTR newVal)
{
	return SetStrProperty(VCCFGID_OutputDirectory, newVal);
}

STDMETHODIMP CStyleSheet::get_Tools(IDispatch **ppVal)
{
	return DoGetTools(ppVal);
}

STDMETHODIMP CStyleSheet::get_FileTools(IVCCollection **ppVal)
{
	return DoGetFileTools(ppVal);
}

STDMETHODIMP CStyleSheet::Close()
{
	CInStyleClose inClose;
	m_rgDependents.RemoveAll();

	return FinishClose();
}

STDMETHODIMP CStyleSheet::get_LoadCount(long* pnLoadCount)
{	// how many projects/style sheets have this style sheet loaded; used by project engine only
	CHECK_POINTER_NULL(pnLoadCount);
	*pnLoadCount = m_nLoadCount;
	return S_OK;
}

STDMETHODIMP CStyleSheet::put_LoadCount(long nLoadCount)
{
	if (nLoadCount < 0)
	{
		RETURN_INVALID();
	}
	m_nLoadCount = nLoadCount;
	return S_OK;
}

HRESULT CStyleSheet::SGetToolSet(toolSetType* pToolSet)
{
	CHECK_POINTER_NULL(pToolSet);
	*pToolSet = toolSetAll;
	return S_OK;
}

STDMETHODIMP CStyleSheet::get_ConfigurationType(ConfigurationTypes* pconfigType)
{
	CHECK_POINTER_VALID(pconfigType);
	return GetIntProperty(VCCFGID_ConfigurationType, (long *)pconfigType);
}

STDMETHODIMP CStyleSheet::put_ConfigurationType(ConfigurationTypes configType)
{
	return SetIntProperty(VCCFGID_ConfigurationType, configType);
}

STDMETHODIMP CStyleSheet::get_Platform(IDispatch** ppPlatform)
{
	return DoGetPlatform(ppPlatform);
}

STDMETHODIMP CStyleSheet::get_PlatformName(BSTR* pbstrPlatformName)
{
	CHECK_POINTER_VALID(pbstrPlatformName);
	if (m_pPlatform == NULL)
	{
		*pbstrPlatformName = NULL;
		return S_FALSE;
	}

	return m_pPlatform->get_Name(pbstrPlatformName);
}

STDMETHODIMP CStyleSheet::put_PlatformName(BSTR bstrPlatformName)
{
	RETURN_ON_NULL2(g_pProjectEngine, E_UNEXPECTED);

	CComPtr<IDispatch> spDispPlatformList;
	HRESULT hr = g_pProjectEngine->get_Platforms(&spDispPlatformList);
	CComQIPtr<IVCCollection> spPlatformList = spDispPlatformList;
	RETURN_ON_FAIL_OR_NULL2(hr, spPlatformList, E_UNEXPECTED);

	CComPtr<IDispatch> spDispPlatform;
	hr = spPlatformList->Item(CComVariant(bstrPlatformName), &spDispPlatform);
	CComQIPtr<VCPlatform> spPlatform = spDispPlatform;
	RETURN_ON_FAIL(hr);
	if (spPlatform == NULL)
		return CVCProjectEngine::DoSetErrorInfo2(VCPROJ_E_NOT_FOUND, IDS_ERR_PLATFORM_NOT_FOUND, bstrPlatformName);

	CHECK_OK_TO_DIRTY(VCSTYLEID_PlatformName);
	m_pPlatform = spPlatform;
	InitializeTools();
	return S_OK;
}

STDMETHODIMP CStyleSheet::get_AppliedStyleSheets(BSTR* pbstrStyles)
{
	HRESULT hr = GetStrProperty(VCCFGID_AppliedStyleSheets, pbstrStyles);
	if (hr == S_FALSE)
		GetDefaultValue(VCCFGID_AppliedStyleSheets, pbstrStyles, this);
	return hr;
}

STDMETHODIMP CStyleSheet::put_AppliedStyleSheets(BSTR bstrStyles)
{
	return DoSetAppliedStyleSheets(bstrStyles, TRUE);
}

STDMETHODIMP CStyleSheet::get_BuildBrowserInformation(VARIANT_BOOL* pbBsc)
{	// build .bsc file
	CHECK_POINTER_VALID(pbBsc);
	return GetBoolProperty(VCCFGID_BuildBrowserInformation, pbBsc);
}

STDMETHODIMP CStyleSheet::put_BuildBrowserInformation(VARIANT_BOOL bBsc)
{
	return SetBoolProperty(VCCFGID_BuildBrowserInformation, bBsc);
}

STDMETHODIMP CStyleSheet::get_UseOfMFC(useOfMfc* useMfc)
{	// how are we using MFC?
	return GetIntProperty(VCCFGID_UseOfMFC, (long *)useMfc);
}

STDMETHODIMP CStyleSheet::put_UseOfMFC(useOfMfc useMfc)
{
	return SetIntProperty(VCCFGID_UseOfMFC, useMfc);
}

STDMETHODIMP CStyleSheet::get_UseOfATL(useOfATL* useATL)
{	// how are we using ATL?
	CHECK_POINTER_VALID(useATL);
	return GetIntProperty(VCCFGID_UseOfATL, (long *)useATL);
}

STDMETHODIMP CStyleSheet::put_UseOfATL(useOfATL useATL)
{
	return SetIntProperty(VCCFGID_UseOfATL, useATL);
}

STDMETHODIMP CStyleSheet::get_ATLMinimizesCRunTimeLibraryUsage(VARIANT_BOOL* pbCRT)
{	// is this an ATL min dependency?
	CHECK_POINTER_VALID(pbCRT);
	return GetBoolProperty(VCCFGID_ATLMinimizesCRunTimeLibraryUsage, pbCRT);
}

STDMETHODIMP CStyleSheet::put_ATLMinimizesCRunTimeLibraryUsage(VARIANT_BOOL bCRT)
{
	return SetBoolProperty(VCCFGID_ATLMinimizesCRunTimeLibraryUsage, bCRT);
}

STDMETHODIMP CStyleSheet::get_CharacterSet(charSet* pset)
{	// what type of character set are we using?
	CHECK_POINTER_VALID(pset);
	return GetIntProperty(VCCFGID_CharacterSet, (long *)pset);
}

STDMETHODIMP CStyleSheet::put_CharacterSet(charSet set)
{
	return SetIntProperty(VCCFGID_CharacterSet, set);
}

STDMETHODIMP CStyleSheet::get_ManagedExtensions(VARIANT_BOOL* bManaged)
{	// is this a managed extensions project?
	return GetBoolProperty(VCCFGID_ManagedExtensions, bManaged);
}

STDMETHODIMP CStyleSheet::put_ManagedExtensions(VARIANT_BOOL bManaged)
{
	return SetBoolProperty(VCCFGID_ManagedExtensions, bManaged);
}

STDMETHODIMP CStyleSheet::get_DeleteExtensionsOnClean(BSTR* pbstrExt)
{	// wildcard extension list to delete on clean/rebuild from within the intermediate directory
	HRESULT hr = GetStrProperty(VCCFGID_DeleteExtensionsOnClean, pbstrExt);
	if (hr == S_FALSE)
		GetDefaultValue(VCCFGID_DeleteExtensionsOnClean, pbstrExt, this);
	return hr;
}

STDMETHODIMP CStyleSheet::put_DeleteExtensionsOnClean(BSTR bstrExt)
{
	return SetStrProperty(VCCFGID_DeleteExtensionsOnClean, bstrExt);
}

STDMETHODIMP CStyleSheet::get_WholeProgramOptimization(VARIANT_BOOL* pbOptimized)
{  // perform whole program optimization on build; more or less requires optimization turned on to be effective
	return GetBoolProperty(VCCFGID_WholeProgramOptimization, pbOptimized);
}

STDMETHODIMP CStyleSheet::put_WholeProgramOptimization(VARIANT_BOOL bOptimize)
{
	return SetBoolProperty(VCCFGID_WholeProgramOptimization, bOptimize);
}

STDMETHODIMP CStyleSheet::AddDependent(IVCPropertyContainer* pPropContainer, BOOL bInformAboutAllProperties)
{
	RETURN_INVALID_ON_NULL(pPropContainer);

	if (m_rgDependents.Find(pPropContainer) >= 0)	// already there
		return S_FALSE;

	if (m_rgDependents.Add(pPropContainer) < 0)
		return E_OUTOFMEMORY;

	InformAboutProperties(pPropContainer, bInformAboutAllProperties);
	
	return S_OK;
}

STDMETHODIMP CStyleSheet::RemoveDependent(IVCPropertyContainer* pPropContainer, BOOL bInformAboutAllProperties)
{
	RETURN_INVALID_ON_NULL(pPropContainer);

	if (m_rgDependents.Remove(pPropContainer))
		InformAboutProperties(pPropContainer, bInformAboutAllProperties);

	CComQIPtr<IVCProjectEngineImpl> spProjectEngineImpl = g_pProjectEngine;
	if (spProjectEngineImpl != NULL)
		spProjectEngineImpl->UnloadStyleSheet(this);	// this will cause the style sheet to be removed when it is no longer needed

	return S_OK;
}

STDMETHODIMP CStyleSheet::InformAboutProperties(IVCPropertyContainer* pPropContainer, BOOL bAllProperties)
{
	if (g_bInProjClose)	// REALLY don't care to do an inform if the project is gone...
		return S_OK;

	HRESULT hr = S_OK;
	long lcItems = m_rgParents.GetSize();
	for (long index = 0; index < lcItems; index++)
	{
		CComPtr<IVCPropertyContainer> pParent;
		pParent = m_rgParents.GetAt(index);
		CComQIPtr<IVCStyleSheetImpl> spStyleSheetParent = pParent;
		if (spStyleSheetParent)
		{
			hr = spStyleSheetParent->InformAboutProperties(pPropContainer, bAllProperties);
			RETURN_ON_FAIL(hr);
		}
	}

	if (bAllProperties)
	{
		VCPOSITION pos = m_PropMap.GetStartPosition();
		while (pos != (VCPOSITION)NULL)
		{
			long idProp;
			CComVariant var;
			m_PropMap.GetNextAssoc(pos, idProp, var);
			CComVariant var2;
			VARIANT_BOOL bMulti;
			if (pPropContainer->GetLocalProp(idProp, &var2) != S_OK || 
				(pPropContainer->IsMultiProp(idProp, &bMulti) == S_OK && bMulti == VARIANT_TRUE))
				pPropContainer->DirtyProp(idProp);
		}
	}
	else	// just specific ones
	{
		CComVariant varHere;
		CComVariant varChild;
		if (GetProp(VCCLID_RuntimeLibrary, &varHere) == S_OK && 
			pPropContainer->GetProp(VCCLID_RuntimeLibrary, &varChild) != S_OK)
			pPropContainer->DirtyProp(VCCLID_RuntimeLibrary);
	}

	return S_OK;
}

// WARNING: Clone must only be called on a brand new style sheet!!
STDMETHODIMP CStyleSheet::Clone( IVCPropertyContainer *pSource )
{
	// check arg
	CHECK_READ_POINTER_NULL(pSource);

	CStyleSheet* pIn = (CStyleSheet*)pSource;

	// get the start of the map
	VCPOSITION iter = pIn->m_PropMap.GetStartPosition();
	// iterate over each item in the map
	while( iter )
	{
		long key;
		CComVariant value;

		pIn->m_PropMap.GetNextAssoc( iter, key, value );

		// copy this element
		m_PropMap.SetAt( key, value );
	}

	return S_OK;
}

void CStyleSheet::DoGetToolSetType(toolSetType& listStyle)
{
	ConfigurationTypes configType;
	HRESULT hr = GetIntProperty(VCCFGID_ConfigurationType, (long *)&configType);
	if (hr == S_OK)		// configuration type always overrides tool set type
	{
		listStyle = DetermineBaseType(configType);
		return;
	}

	hr = GetIntProperty(VCSTYLEID_ToolSet, (long *)&listStyle);
	VSASSERT(hr == S_OK, "Must either set the toolset or the configuration type!!!");
}

STDMETHODIMP CStyleSheet::AddTool(LPCOLESTR szName, IDispatch** ppTool)
{
	// DIANEME_TODO: need to handle add of tool AFTER project is loaded...
	HRESULT hr = DoAddTool(szName, ppTool);
	RETURN_ON_FAIL_OR_NULL(hr, *ppTool);

	// DIANEME_TODO: inform the loaded projects with this style sheet about the added tool
	return hr;
}

STDMETHODIMP CStyleSheet::CreatePageObject(IUnknown **ppUnk, CLSID*pCLSID, IVCPropertyContainer *pPropCntr, IVCSettingsPage *pPage )
{
#ifdef AARDVARK
	if( __uuidof(GeneralStyleSheetSettings) == *pCLSID )
	{
		return S_OK;
	}
	else
	{
		// not a local one, try the tools.
		long lcItems = m_rgTools.GetSize();
		for (long index = 0; index < lcItems; index++)
		{
			CComPtr<IVCToolImpl> spToolImpl = m_rgTools.GetAt(index);
			if (spToolImpl == NULL)
				continue;
	
			HRESULT hr = spToolImpl->CreatePageObject(ppUnk, pCLSID, pPropCntr, pPage );
			if( hr == S_OK )
				return S_OK;
		}
		return E_FAIL;
	}
#endif

	return E_NOTIMPL;
}

#ifdef AARDVARK
//---------------------------------------------------------------------------
// interface: ISpecifyPropertyPages
//---------------------------------------------------------------------------
STDMETHODIMP CStyleSheet::GetPages(/* [out] */ CAUUID *pPages)
{
	CHECK_POINTER_NULL(pPages);
	
	// Get the list of pages
	long lPageCnt = 0;
	CAUUID aPageSet[1024] = {0};
	unsigned long lTools = 0;

	long lcItems = m_rgTools.GetSize();
	for (long index = 0; index < lcItems; index++)
	{
		CComPtr<IVCToolImpl> spToolImpl = m_rgTools.GetAt(index);
		if (spToolImpl == NULL)
			continue;

		long tool_index;
		spToolImpl->get_ToolDisplayIndex( &tool_index );

		HRESULT hr = spToolImpl->GetPages(&(aPageSet[tool_index]));

		if( SUCCEEDED(hr) && aPageSet[tool_index].cElems )
		{
			lPageCnt += aPageSet[tool_index].cElems;
			lTools++;
			if( lTools > 1024 )
				break;
		}
	}

	// number of tool pages plus number of 'extra' pages
	pPages->cElems = lPageCnt + 1;
	if( lPageCnt == 0 )
	{
		pPages->pElems = (GUID*) NULL;
		return S_OK;
	}

	// number of tool pages plus number of 'extra' pages
	pPages->pElems = (GUID*) CoTaskMemAlloc(sizeof(CLSID)*(lPageCnt+1));
	RETURN_ON_NULL2(pPages->pElems, E_OUTOFMEMORY);
		
	// add the general->configuration page
	pPages->pElems[0] = __uuidof(GeneralStyleSheetSettings);

	// Merge the page lists
	unsigned long lPages = 1;
	// for each possible tool
	for( unsigned long i = 0; i < 1024; i++ )
	{
		// for each page this tool has
		for( unsigned long j = 0; j < aPageSet[i].cElems; j++ )
		{
			pPages->pElems[lPages] = aPageSet[i].pElems[j];
			lPages++;
		}
	}

	return S_OK;
}

STDMETHODIMP CGeneralStyleSheetSettingsPage::get_ToolSet(toolSetType* ToolSetList)
{	// what type of tools do we use?
	HRESULT hr = GetIntProperty(VCSTYLEID_ToolSet, (long *)ToolSetList);
	if (hr == S_FALSE)
		CStyleSheet::GetDefaultValue(VCSTYLEID_ToolSet, (long *)ToolSetList);
	return hr;
}

STDMETHODIMP CGeneralStyleSheetSettingsPage::put_ToolSet(toolSetType ToolSetList)
{
	return SetIntProperty(VCSTYLEID_ToolSet, ToolSetList);
}

STDMETHODIMP CGeneralStyleSheetSettingsPage::get_AppliedStyleSheets(BSTR* StyleNames)
{	// style sheet names applied to this configuration purposely *NOT* in UI, but still browsable
	HRESULT hr = GetStrProperty(VCCFGID_AppliedStyleSheets, StyleNames);
	if (hr == S_FALSE)
		CStyleSheet::GetDefaultValue(VCCFGID_AppliedStyleSheets, StyleNames);
	return hr;
}

STDMETHODIMP CGeneralStyleSheetSettingsPage::put_AppliedStyleSheets(BSTR StyleNames)
{
	return SetStrProperty(VCCFGID_AppliedStyleSheets, StyleNames);
}

STDMETHODIMP CGeneralStyleSheetSettingsPage::get_BuildBrowserInformation(enumBOOL* Bsc)
{	// build .bsc file
	HRESULT hr = GetEnumBoolProperty(VCCFGID_BuildBrowserInformation, Bsc);
	if (hr == S_FALSE)
		CStyleSheet::GetDefaultValue(VCCFGID_BuildBrowserInformation, (VARIANT_BOOL*)Bsc);
	return hr;
}

STDMETHODIMP CGeneralStyleSheetSettingsPage::put_BuildBrowserInformation(enumBOOL Bsc)
{
	return SetBoolProperty(VCCFGID_BuildBrowserInformation, Bsc);
}

STDMETHODIMP CGeneralStyleSheetSettingsPage::get_UseOfMFC(useOfMfc* useMfc)
{	// how are we using MFC?
	HRESULT hr = GetIntProperty(VCCFGID_UseOfMFC, (long *)useMfc);
	if (hr == S_FALSE)
		CStyleSheet::GetDefaultValue(VCCFGID_UseOfMFC, (long *)useMfc);
	return hr;
}

STDMETHODIMP CGeneralStyleSheetSettingsPage::put_UseOfMFC(useOfMfc useMfc)
{
	return SetIntProperty(VCCFGID_UseOfMFC, useMfc);
}

STDMETHODIMP CGeneralStyleSheetSettingsPage::get_UseOfATL(useOfATL* useATL)
{	// how are we using ATL?
	HRESULT hr = GetIntProperty(VCCFGID_UseOfATL, (long *)useATL);
	if (hr == S_FALSE)
		CStyleSheet::GetDefaultValue(VCCFGID_UseOfATL, (long *)useATL);
	return hr;
}

STDMETHODIMP CGeneralStyleSheetSettingsPage::put_UseOfATL(useOfATL useATL)
{
	return SetIntProperty(VCCFGID_UseOfATL, useATL);
}

STDMETHODIMP CGeneralStyleSheetSettingsPage::get_ATLMinimizesCRunTimeLibraryUsage(enumBOOL* UseCRT)
{	// does the user want to link with the static or dynamic CRT?
	HRESULT hr = GetEnumBoolProperty(VCCFGID_ATLMinimizesCRunTimeLibraryUsage, UseCRT);
	if (hr == S_FALSE)
		CStyleSheet::GetDefaultValue(VCCFGID_ATLMinimizesCRunTimeLibraryUsage, (VARIANT_BOOL*)UseCRT);
	return hr;
}

STDMETHODIMP CGeneralStyleSheetSettingsPage::put_ATLMinimizesCRunTimeLibraryUsage(enumBOOL UseCRT)
{
	return SetBoolProperty(VCCFGID_ATLMinimizesCRunTimeLibraryUsage, UseCRT);
}

STDMETHODIMP CGeneralStyleSheetSettingsPage::get_CharacterSet(charSet* optSetting)
{	// character set to use: Unicode, MBCS, default
	HRESULT hr = GetIntProperty(VCCFGID_CharacterSet, (long *)optSetting);
	if (hr == S_FALSE)
		CStyleSheet::GetDefaultValue(VCCFGID_CharacterSet, (long *)optSetting);
	return hr;
}

STDMETHODIMP CGeneralStyleSheetSettingsPage::put_CharacterSet(charSet optSetting)
{
	return SetIntProperty(VCCFGID_CharacterSet, optSetting);
}

STDMETHODIMP CGeneralStyleSheetSettingsPage::get_ManagedExtensions(enumBOOL* Managed)
{	// is this a managed C++ project?
	HRESULT hr = GetEnumBoolProperty(VCCFGID_ManagedExtensions, Managed);
	if (hr == S_FALSE)
		CStyleSheet::GetDefaultValue(VCCFGID_ManagedExtensions, (VARIANT_BOOL*)Managed);
	return hr;
}

STDMETHODIMP CGeneralStyleSheetSettingsPage::put_ManagedExtensions(enumBOOL Managed)
{
	return SetBoolProperty(VCCFGID_ManagedExtensions, Managed);
}

STDMETHODIMP CGeneralStyleSheetSettingsPage::get_DeleteExtensionsOnClean(BSTR* ExtList)
{	// wildcard extension list to delete on clean/rebuild from within the intermediate directory
	HRESULT hr = GetStrProperty(VCCFGID_DeleteExtensionsOnClean, ExtList);
	if (hr == S_FALSE)
		CStyleSheet::GetDefaultValue(VCCFGID_DeleteExtensionsOnClean, ExtList);
	return hr;
}

STDMETHODIMP CGeneralStyleSheetSettingsPage::put_DeleteExtensionsOnClean(BSTR ExtList)
{
	return SetStrProperty(VCCFGID_DeleteExtensionsOnClean, ExtList);
}

STDMETHODIMP CGeneralStyleSheetSettingsPage::get_WholeProgramOptimization(enumBOOL* Optimize)
{	// perform whole program optimization on build more or less requires optimization turned on to be effective
	HRESULT hr = GetEnumBoolProperty(VCCFGID_WholeProgramOptimization, Optimize);
	if (hr == S_FALSE)
		CStyleSheet::GetDefaultValue(VCCFGID_WholeProgramOptimization, (VARIANT_BOOL*)Optimize);
	return hr;
}

STDMETHODIMP CGeneralStyleSheetSettingsPage::put_WholeProgramOptimization(enumBOOL Optimize)
{
	return SetBoolProperty(VCCFGID_WholeProgramOptimization, Optimize);
}
#endif	// AARDVARK
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\vcpb\StdAfx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__9F36701B_33C6_11D3_8D52_00C04F8ECDB6__INCLUDED_)
#define AFX_STDAFX_H__9F36701B_33C6_11D3_8D52_00C04F8ECDB6__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_FREE_THREADED

// this shuts off all ATL TRACE messages, remove this line or change it to turn on what you want
#define ATL_TRACE_CATEGORY 0x0

#include "resource.h"
#include "..\ui_dll\resdll\resource.h"
#include <prjids.h>

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <atlctl.h>
#include <atlstr.h>

#include <wininet.h>
#include <wchar.h>
#include <vcstring.h>
#include <mlang.h>

#include <vcpb2.h>
#include <VCProjectPrivateTypeLib.h>
#include <ProjBldPrivate.h>
#include "macropicker.h"

#include <win9x.h>

#define NO_MFC	// don't allow certain files to include too much (eg., utilbld.h)

#include "filechng.h"
#include "VsCoCreate.h"
#include "VsAssert.h"
#include "objext.h"

#include "VsTypeInfo.h"

#ifndef UNICODE
#ifndef _wcsdec
__inline wchar_t * __cdecl _wcsdec(const wchar_t * _cpc1, const wchar_t * _cpc2) { return (wchar_t *)((_cpc1)>=(_cpc2) ? NULL : ((_cpc2)-1)); }
#endif	// _wcsdec
#endif

#ifndef _wccmp
__inline int __cdecl _wccmp(const wchar_t *_cpc1, const wchar_t *_cpc2) { return (int) ((*_cpc1)-(*_cpc2)); }
#endif	// _wccmp
#ifndef _wclen
__inline size_t __cdecl _wclen(const wchar_t *_cpc) { return (_cpc,1); }
#endif	// _wclen


_declspec(selectany) LPOLESTR szCLCompilerToolType = L"C/C++ Compiler Tool";
_declspec(selectany) LPOLESTR szCLCompilerToolPath = L"cl.exe";
_declspec(selectany) LPOLESTR szCLCompilerToolShortName = L"VCCLCompilerTool";
_declspec(selectany) LPOLESTR szLinkerToolType = L"Linker Tool";
_declspec(selectany) LPOLESTR szLinkerToolPath = L"link.exe";
_declspec(selectany) LPOLESTR szLinkerToolShortName = L"VCLinkerTool";
_declspec(selectany) LPOLESTR szLibrarianToolType = L"Librarian Tool";
_declspec(selectany) LPOLESTR szLibrarianToolPath = L"lib.exe";
_declspec(selectany) LPOLESTR szLibrarianToolShortName = L"VCLibrarianTool";
_declspec(selectany) LPOLESTR szMidlToolType = L"MIDL Tool";
_declspec(selectany) LPOLESTR szMidlToolPath = L"midl.exe";
_declspec(selectany) LPOLESTR szMidlToolShortName = L"VCMIDLTool";
_declspec(selectany) LPOLESTR szCustomBuildToolType = L"Custom Build Tool";
_declspec(selectany) LPOLESTR szCustomBuildToolPath = L"cmd.exe";
_declspec(selectany) LPOLESTR szCustomBuildToolShortName = L"VCCustomBuildTool";
_declspec(selectany) LPOLESTR szResourceCompilerToolType = L"Resource Compiler Tool";
_declspec(selectany) LPOLESTR szResourceCompilerToolPath = L"rc.exe";
_declspec(selectany) LPOLESTR szResourceCompilerToolShortName = L"VCResourceCompilerTool";
_declspec(selectany) LPOLESTR szBuildEventToolPath = L"cmd.exe";
_declspec(selectany) LPOLESTR szPreBuildEventToolShortName = L"VCPreBuildEventTool";
_declspec(selectany) LPOLESTR szPreBuildEventToolType = L"Pre-Build Event Tool";
_declspec(selectany) LPOLESTR szPreLinkEventToolShortName = L"VCPreLinkEventTool";
_declspec(selectany) LPOLESTR szPreLinkEventToolType = L"Pre-Link Event Tool";
_declspec(selectany) LPOLESTR szPostBuildEventToolShortName = L"VCPostBuildEventTool";
_declspec(selectany) LPOLESTR szPostBuildEventToolType = L"Post-Build Event Tool";
_declspec(selectany) LPOLESTR szBscMakeToolType = L"BscMake Tool";
_declspec(selectany) LPOLESTR szBscMakeToolPath = L"bscmake.exe";
_declspec(selectany) LPOLESTR szBscMakeToolShortName = L"VCBscMakeTool";
_declspec(selectany) LPOLESTR szNMakeToolType = L"NMake Tool";
_declspec(selectany) LPOLESTR szNMakeToolPath = L"nmake.exe";
_declspec(selectany) LPOLESTR szNMakeToolShortName = L"VCNMakeTool";
_declspec(selectany) LPOLESTR szWebToolType = L"Web Service Proxy Generator Tool";
_declspec(selectany) LPOLESTR szWebToolPathNative = L"sproxy.exe";
//_declspec(selectany) LPOLESTR szWebToolPathManaged = L"wsdl.exe /language:\"Microsoft.MCpp.MCppCodeGenerator,MCppCodeGenerator\"";
_declspec(selectany) LPOLESTR szWebToolPathManaged = L"wsdl.exe";
_declspec(selectany) LPOLESTR szWebToolShortName = L"VCWebServiceProxyGeneratorTool";
_declspec(selectany) LPOLESTR szDeployToolType = L"Web Deployment Tool";
_declspec(selectany) LPOLESTR szDeployToolPath = L"VCDeploy.exe";
_declspec(selectany) LPOLESTR szDeployToolShortName = L"VCWebDeploymentTool";
_declspec(selectany) LPOLESTR szXboxDeployToolType = L"Xbox Deployment Tool"; // Not used?
_declspec(selectany) LPOLESTR szXboxDeployToolPath = L"XboxDeploy.exe";
_declspec(selectany) LPOLESTR szXboxDeployToolShortName = L"XboxDeploymentTool";

_declspec(selectany) LPOLESTR szXboxImageToolType = L"Xbox Image Tool";
_declspec(selectany) LPOLESTR szXboxImageToolPath = L"imagebld.exe"; // Not used?
_declspec(selectany) LPOLESTR szXboxImageToolShortName = L"XboxImageTool";

_declspec(selectany) LPOLESTR szVcObjectsKey = L"VC_OBJECTS";
_declspec(selectany) LPOLESTR szPlatformRegKeyType = L"_PLATFORM_INFO";
_declspec(selectany) LPOLESTR szVCPlatformRegSubKey = L"\\VC\\VC_OBJECTS_PLATFORM_INFO";

extern BOOL IsRealProp(long id);
extern BOOL IsBuildEvent(bldActionTypes buildType);
extern HRESULT DoSetErrorInfo(HRESULT hrErr, long idErr, BOOL bReportError = TRUE);
extern HRESULT DoSetErrorInfo2(HRESULT hrErr, long idErr, LPCOLESTR szParam, BOOL bReportError = TRUE);
extern HRESULT DoSetErrorInfo3(HRESULT hrErr, long idErr, LPCOLESTR szParam1, LPCOLESTR szParam2, BOOL bReportError = TRUE);

#define CHECK_ZOMBIE(x, err) \
    if( (x) == NULL )\
	return DoSetErrorInfo(VCPROJ_E_ZOMBIE, err);

#define CHECK_POINTER_VALID(x) \
    if( (x) == NULL ){\
		VSASSERT(false, "NULL pointer passed to function");\
		return E_POINTER;} \
	else if (IsBadWritePtr((x), sizeof(*(x)))) {\
		VSASSERT(false, "Bad write pointer passed to function");\
		return E_POINTER; }

#define CHECK_POINTER_NULL(x) \
    if( (x) == NULL ){\
		VSASSERT(false, "NULL pointer passed to function");\
		return E_POINTER;}

#define CHECK_READ_POINTER_VALID(x) \
	if ( (x) == NULL ){\
		VSASSERT(false, "NULL read pointer passed to function"); \
		return E_INVALIDARG; } \
	else if (IsBadReadPtr((x), sizeof (*(x)))) {\
		VSASSERT(false, "Bad read pointer passed to function"); \
		return E_INVALIDARG; }

#define CHECK_READ_POINTER_NULL(x) \
	if ( (x) == NULL ){\
		VSASSERT(false, "NULL read pointer passed to function"); \
		return E_INVALIDARG; } 

#define CHECK_VARIANTBOOL(x) \
    if( (x) != VARIANT_TRUE && (x)!= VARIANT_FALSE )\
        return E_INVALIDARG;

#define CHECK_BOUNDS(a,b,x) \
    if( (x)<(a) || (x)>(b) )\
        return E_INVALIDARG;

#define CHECK_POSITIVE(x) \
	if ((x) < 0)\
		return E_INVALIDARG;

// prop pages can have inherit (-2) or edit(-3)
#define CHECK_POSITIVE_FOR_PROP_PAGES(x) \
	if (((x) < 0) && ((x) != -2) && ((x) != -3))\
		return E_INVALIDARG;

#define ASSERT_AND_CONTINUE_ON_NULL(ptr) \
	if ((ptr) == NULL) \
	{ \
		VSASSERT(FALSE, "NULL pointer part of collection."); \
		continue; \
	}

#define BREAK_ON_DONE(hr) \
	if (FAILED(hr) || hr == S_FALSE) \
		break;

#define ASSERT_AND_CONTINUE_ON_FAIL_OR_NULL(hr, ptr) \
	if (FAILED(hr) || (ptr) == NULL) \
	{ \
		VSASSERT(FALSE, "Collection enumeration either failed or returned NULL pointer"); \
		continue; \
	}

#define ASSERT_AND_CONTINUE_ON_FAIL(hr) \
	if (FAILED(hr)) \
	{ \
		VSASSERT(FALSE, "Collection enumeration either failed or returned NULL pointer"); \
		continue; \
	}

#define RETURN_ON_FAIL_OR_NULL(hr, pObj) \
	if (FAILED(hr)) \
		return hr; \
	else if ((pObj) == NULL) \
		return E_FAIL;

#define RETURN_ON_FAIL_OR_NULL2(hr1, pObj, hr2) \
	if (FAILED(hr1)) \
		return hr1; \
	else if ((pObj) == NULL) \
		return hr2;

#define RETURN_SPECIFIC_ON_FAIL_OR_NULL(hr1, pObj, hr2) \
	if (FAILED(hr1) || (pObj) == NULL) \
		return hr2;

#define RETURN_INVALID_ON_NULL(pObj) \
	if ((pObj) == NULL) \
	{ \
		/* VSASSERT(FALSE, "Returning E_INVALIDARG!"); */ \
		return E_INVALIDARG; \
	}

#define RETURN_INVALID() \
	{ \
		/* VSASSERT(FALSE, "Hey, returning E_INVALIDARG"); */ \
		return E_INVALIDARG; \
	}

#define VCASSERTME(hr) \
	/* VSASSERT(hr != E_INVALIDARG, "Hey, got an error code I was watching for!"); */

#define RETURN_ON_FAIL(hr) \
	if (FAILED(hr)) \
		return hr;

#define RETURN_ON_FAIL2(hr1, hr2) \
	if (FAILED(hr1)) \
		return hr2;

#define RETURN_ON_NULL(pObj) \
	if ((pObj) == NULL) \
		return E_FAIL;

#define RETURN_ON_NULL2(pObj, hr) \
	if ((pObj) == NULL) \
		return hr;

#define PROJECT_IS_LOADED() \
	(!g_bInProjLoad && !g_bInProjClose)

#define STYLESHEET_IS_LOADED() \
	(!g_bInStyleLoad && !g_bInStyleClose)

#define CHECK_OK_TO_DIRTY(idProp) \
	if (PROJECT_IS_LOADED() && STYLESHEET_IS_LOADED() && IsRealProp(idProp)) \
	{ \
		HRESULT hr = SetDirty(VARIANT_TRUE); \
		if (hr == VCPROJ_E_PROJ_RELOADED) \
			return hr;	/* already reported error info */ \
		else if (hr != S_OK) \
			return DoSetErrorInfo(hr, IDS_ERR_PROJ_READ_ONLY); \
	}

#define CHECK_OK_TO_DIRTY2(idProp, bSetErrorInfo) \
	if (PROJECT_IS_LOADED() && STYLESHEET_IS_LOADED() && IsRealProp(idProp)) \
	{ \
		HRESULT hr = SetDirty(VARIANT_TRUE); \
		if (hr == VCPROJ_E_PROJ_RELOADED) \
			return hr;	/* already reported error info */ \
		else if (hr != S_OK) \
			return DoSetErrorInfo(hr, IDS_ERR_PROJ_READ_ONLY, bSetErrorInfo); \
	}

#define ADD_TOOL_INTERNAL(hr, pTool, rgTools) \
	{ \
		if (FAILED(hr)) \
			return hr; \
		if (!pTool) \
			return E_FAIL; \
		rgTools.Add(pTool); \
	}

#define ADD_TOOL(hr, pTool, rgTools, strPlatformKey, szToolShortName) \
	{ \
		ADD_TOOL_INTERNAL(hr, pTool, rgTools); \
		DoSetToolExtensions(pTool, strPlatformKey, szToolShortName); \
		pTool = NULL; \
	}

#define ADD_TOOL2(hr, pTool, rgTools) \
	{ \
		ADD_TOOL_INTERNAL(hr, pTool, rgTools); \
		pTool = NULL; \
	}


extern _ATL_REGMAP_ENTRY g_rm[];

#define DECLARE_VS_REGISTRY_RESOURCEID(x)\
	static HRESULT WINAPI UpdateRegistry(BOOL bRegister) {\
		return _Module.UpdateRegistryFromResource( x, bRegister, g_rm );\
	}

const int  BUCKET_MINIMUM			= 1;
const int  BUCKET_POSTBUILDEVT		= 1;
const int  BUCKET_DEPLOY			= 2;
const int  BUCKET_XBOXDEPLOY		= 2;
const int  BUCKET_POSTBUILD         = 3;
const int  BUCKET_BSC				= 4;
const int  BUCKET_XBOXIMAGE			= 5;
const int  BUCKET_LINK				= 6;
const int  BUCKET_LIB				= 6;
const int  BUCKET_PRELINK			= 7;
const int  BUCKET_RC				= 8;
const int  BUCKET_CPP				= 9;
const int  BUCKET_MIDL				= 10;
const int  BUCKET_WEB				= 11;
const int  BUCKET_CUSTOMBUILD		= 12;
const int  BUCKET_NMAKE				= 13;
const int  BUCKET_PREBUILD			= 14;
const int  BUCKET_MAXIMUM			= 14;

// order of tool display in the settings dlg
const int TOOL_DISPLAY_INDEX_CPP = 0;
const int TOOL_DISPLAY_INDEX_LINK = 1;
const int TOOL_DISPLAY_INDEX_LIB = 2;
const int TOOL_DISPLAY_INDEX_RC = 3;
const int TOOL_DISPLAY_INDEX_MIDL = 4;
const int TOOL_DISPLAY_INDEX_BSC = 5;
const int TOOL_DISPLAY_INDEX_PREBLD = 6;
const int TOOL_DISPLAY_INDEX_PRELINK = 7;
const int TOOL_DISPLAY_INDEX_POSTBLD = 8;
const int TOOL_DISPLAY_INDEX_CUSTBLD = 9;
const int TOOL_DISPLAY_INDEX_NMAKE = 10;
const int TOOL_DISPLAY_INDEX_WEB = 11;
const int TOOL_DISPLAY_INDEX_DEPLOY = 12;
const int TOOL_DISPLAY_INDEX_XBOXIMAGE = 12; // Never used at the same time as DEPLOY
const int TOOL_DISPLAY_INDEX_XBOXDEPLOY = 13;
#ifdef AARDVARK
const int TOOL_DISPLAY_INDEX_CSHARP = 13;
const int TOOL_DISPLAY_INDEX_VB = 14;
#endif // AARDVARK

#define StdEnumMin 0

#define PublicProjBuildTypeLibNumber 1
#define PrivateProjBuildTypeLibNumber 2

//#ifdef _DEBUG
//#define DIANEME_DEP_CHECK_DIAGNOSTICS 1		// this turns on diagnostic trace output
//#endif	// _DEBUG

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__9F36701B_33C6_11D3_8D52_00C04F8ECDB6__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\vcpb\util2.h ===
#ifndef __UTIL2_H__
#define __UTIL2_H__

#pragma once

#ifndef __UTIL_H__
// MBS <-> WCS conversion with truncation
#define _wcstombsz(lpszDest, lpszSrc, nMaxBytes) \
	wcstombs(lpszDest, lpszSrc, nMaxBytes), lpszDest[nMaxBytes-1] = 0
#endif	// __UTIL_H__

//
// Given a EXE filename determine it's executable type if any.
//
typedef enum {
    EXE_FAIL,
    EXE_NONE,
    EXE_DOS,
    EXE_WIN,
    EXE_NT,
    EXE_OS2_NE,
    EXE_OS2_LE
} EXT; /* EXecutable Type */

extern EXT GetExeType(LPCOLESTR lpstrEXEFilename, WORD * pwSubsystem);
bool CanCreateProcess( LPCOLESTR szExe );

extern LRESULT UtilSendMessageW( HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam );
extern LRESULT UtilSendMessageWString( HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam );
FILE *fopenW( const wchar_t *szFilename, const wchar_t* szAttributes);

LPCOLESTR wcsistr(LPCOLESTR szSearch, LPCOLESTR szReqd);
LPSTR 	  stristr(char *szSearch, char *szReqd);

#endif	// __UTIL2_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\vcpb\stylesheet.h ===
#pragma once

#include "bldtool.h"
#include "propcontainer.h"

#ifdef AARDVARK
#include <StyleDemo.h>
#include "settingspage.h"
#endif	// AARDVARK

#define BSCMAKE_STYLE			L"BuildBsc.vcstyle"
#define MFCSTATIC_STYLE			L"MFCStatic.vcstyle"
#define MFCDYNAMIC_STYLE		L"MFCDynamic.vcstyle"
#define MANAGED_STYLE			L"ManagedExtensions.vcstyle"
#define COREWIN_STYLE			L"CoreWin.vcstyle"
#define WINDLL_STYLE			L"WinDLL.vcstyle"
#define ATLSTATIC_STYLE			L"ATLStatic.vcstyle"
#define ATLDYNAMIC_STYLE		L"ATLDynamic.vcstyle"
#define ATLNOCRT_STYLE			L"ATLNoCRT.vcstyle"
#define ATLWITHCRT_STYLE		L"ATLWithCRT.vcstyle"
#define UNICODE_STYLE			L"UnicodeSupport.vcstyle"
#define MBCS_STYLE				L"MultiByteCharSupport.vcstyle"
#define WHOLEPROGOPTIMIZE_STYLE	L"WholeProgOptimize.vcstyle"

/////////////////////////////////////////////////////////////////////////////
// CStyleSheetBase

class CStyleSheetBase : public CPropertyContainerImpl
{
public:
	CStyleSheetBase();
	virtual ~CStyleSheetBase() {}

// Public Interface Helpers (VCConfiguration, VCStyleSheet)
protected:
	virtual HRESULT DoGetPlatform(IDispatch** ppVal);
	virtual HRESULT DoGetTools(IDispatch** ppVal);

// Private Interface Helpers (IVCConfigurationImpl, IVCStyleSheetImpl)
protected:
	virtual HRESULT InitializeTools( void );
	virtual HRESULT DoGenerateToolWrapperList();
	virtual void ClearTools();
	virtual HRESULT VerifyFileTools() { return S_OK; }
	virtual HRESULT DoGetFileTools(IVCCollection** ppVal);
	virtual HRESULT DoClearToolWrapperList();
	virtual HRESULT FinishClose();
	virtual HRESULT DoSetAppliedStyleSheets(BSTR bstrStyles, BOOL bCheckSpecial);
	virtual HRESULT LoadStyle(BSTR bstrStyle, BOOL bAddFront = TRUE, BOOL bIsSystemStyle = TRUE);
	virtual HRESULT UnloadStyle(BSTR bstrStyle);

	HRESULT AddSingleTool(IVCPropertyContainer* pPropContainer, IVCToolImpl* pTool, BOOL bGenWrapper,
		IDispatch** ppDispTool = NULL);
	HRESULT DoAddTool(LPCOLESTR szToolName, IDispatch** ppTool);

public:
	virtual HRESULT SetDirty(VARIANT_BOOL bDirty) { return E_NOTIMPL; }

// IVCPropertyContainer
public:
	STDMETHOD(IsMultiProp)(long idProp, VARIANT_BOOL* pbIsMulti);
	STDMETHOD(GetMultiPropSeparator)(long id, BSTR* pbstrPreferred, BSTR* pbstrAll);

// IVCPropertyContainer helpers
protected:
	virtual HRESULT DoGetProp(long id, BOOL bCheckSpecialProps, VARIANT *pVarValue);
	virtual HRESULT DoSetProp(long id, BOOL bCheckSpecialProps, VARIANT varValue, long nOverride = -1);
	virtual HRESULT DoClear(long id, long nOverrideID = -1);
	virtual HRESULT DoSetStrProperty(long id, BOOL bCheckSpecialProps, BSTR bstrValue, long nOverrideID = -1);
	virtual HRESULT DoSetIntProperty(long id, BOOL bCheckSpecialProps, long nValue, long nOverrideID = -1);
	virtual HRESULT DoSetBoolProperty(long id, BOOL bCheckSpecialProps, VARIANT_BOOL bValue, long nOverrideID = -1);

// LOCAL METHODS
public:
	static HRESULT GetDefaultValue(long idProp, BSTR* pbstrValue, IVCPropertyContainer* pPropContainer = NULL);
	static HRESULT GetDefaultValue(long idProp, long* pnValue, IVCPropertyContainer* pPropContainer = NULL);
	static HRESULT GetDefaultValue(long idProp, VARIANT_BOOL* pbValue, IVCPropertyContainer* pPropContainer = NULL);

	static int		FindStyle(CComBSTR& rbstrStyles, BSTR bstrFindStyle);
	static HRESULT AddStyle(CStyleSheetBase* pContainer, CComBSTR& rbstrStyles, BSTR bstrAddStyle);
	static HRESULT RemoveStyle(CStyleSheetBase* pContainer, CComBSTR& rbstrStyles, BSTR bstrRemoveStyle);
	static useOfMfc DetermineMfcStyle(CComBSTR& rbstrStyles);
	static HRESULT AddMfcStyle(CComBSTR& rbstrStyles, useOfMfc useMfc, CStyleSheetBase* pContainerClass);
	static HRESULT RemoveMfcStyle(CStyleSheetBase* pContainer, CComBSTR& rbstrStyles, useOfMfc useMfc);
	static int	   GetNextStyle(CStringW& strStyleList, int nStartStyle, int nMaxIdx, CComBSTR& bstrStyle);
	static HRESULT ChangeMfcStyle(CStyleSheetBase* pContainerClass, CComBSTR& rbstrStyles, useOfMfc useMfc);
	static HRESULT ChangeATLStyle(CStyleSheetBase* pContainerClass, CComBSTR& rbstrStyles, useOfATL useATL);
	static HRESULT ChangeATLCRTStyle(CStyleSheetBase* pContainerClass, CComBSTR& rbstrStyles, VARIANT_BOOL bNoCRT);
	static HRESULT ChangeCharSetStyle(CStyleSheetBase* pContainerClass, CComBSTR& rbstrStyles, charSet set);
	static toolSetType DetermineBaseType(ConfigurationTypes configType);

	virtual long GetOverrideID(long idProp);

protected:
	static int DoFindStyle(CStringW& rstrStyles, CStringW& rstrFindStyle, int nStart);

protected:
	void ResolveStyleSheetToPath(BSTR bstrStyle, CComBSTR& bstrStylePath);
#ifndef _SHIP
	void ResolveStyleSheetToPathBatch(BSTR bstrStyle, CComBSTR& bstrStylePath);
#endif	// ifndef _SHIP
	virtual void DoGetToolSetType(toolSetType& listStyle) { VSASSERT(FALSE, "DoGetToolSetType must be overridden!"); listStyle = toolSetUtility; }
	HRESULT DoSetUseOfMFC(useOfMfc useMfc, bool bDirtyProp = true);
	HRESULT DoSetUseOfATL(useOfATL useATL);
	HRESULT DoSetCharSet(charSet set);
	HRESULT DoSetATLCRTStyle(VARIANT_BOOL bNoCRT, bool bDirtyProp = true);
	HRESULT DoSetStyle(long idProp, BSTR bstrStyle, VARIANT_BOOL bValue);
	HRESULT DoGetStyleSheets(IDispatch** ppStyles);

//DATA
protected:
	CComBSTR					m_bstrName;	
	CComPtr<VCPlatform>			m_pPlatform;
	CVCPtrList					m_toolWrapperList;

	CComDynamicListTyped<IVCToolImpl> m_rgTools;		// collection of tools for this style sheet
	CComDynamicListTyped<IVCToolImpl> m_rgFileTools;		// collection of tools for files for this style sheet
	CComDynamicListTyped<VCStyleSheet> m_rgStyleSheets;	// collection of style sheets on this style sheet; temporary use only
};

/////////////////////////////////////////////////////////////////////////////
// CStyleSheet

class CStyleSheet : 
	public IDispatchImpl<VCStyleSheet, &__uuidof(VCStyleSheet), &LIBID_VCProjectEngineLibrary, PublicProjBuildTypeLibNumber,0, CVsTypeInfoHolder>, 
	public IVCStyleSheetImpl,
	public CComObjectRoot,
#ifdef AARDVARK
	public IVCExternalCookie,
#endif	// AARDVARK
	public CStyleSheetBase
{
public:
	CStyleSheet();
	~CStyleSheet() {}

	static HRESULT CreateInstance(VCStyleSheet **ppStyleSheet);
	HRESULT Initialize();

BEGIN_COM_MAP(CStyleSheet)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(VCStyleSheet)
	COM_INTERFACE_ENTRY(IVCStyleSheetImpl)
	COM_INTERFACE_ENTRY(IVCPropertyContainer)
#ifdef AARDVARK
	COM_INTERFACE_ENTRY(IVCExternalCookie)
	COM_INTERFACE_ENTRY(ISpecifyPropertyPages)
#endif	// AARDVARK
END_COM_MAP()
//DECLARE_NOT_AGGREGATABLE(CStyleSheet) 
// Remove the comment from the line above if you don't want your object to 
// support aggregation. 

DECLARE_NO_REGISTRY()

// VCStyleSheet
public:
	STDMETHOD(get_Name)(BSTR *pVal);
	STDMETHOD(put_Name)(BSTR newVal);
	STDMETHOD(get_Platform)(IDispatch** ppPlatform);
	STDMETHOD(get_PlatformName)(BSTR* pbstrPlatformName);
	STDMETHOD(put_PlatformName)(BSTR bstrPlatformName);
	STDMETHOD(MatchName)(BSTR bstrNameToMatch, VARIANT_BOOL bFullOnly, VARIANT_BOOL *pbIsMatch);
	STDMETHOD(get_IsDirty)(VARIANT_BOOL *pVal);
	STDMETHOD(get_StyleSheetName)(BSTR *pVal);
	STDMETHOD(put_StyleSheetName)(BSTR newVal);
	STDMETHOD(get_StyleSheetFile)(BSTR *pVal);
	STDMETHOD(put_StyleSheetFile)(BSTR newVal);
	STDMETHOD(get_Tools)(IDispatch * *pVal);
	STDMETHOD(get_FileTools)(IVCCollection * *pVal);
	STDMETHOD(get_ToolSet)(toolSetType* pToolSet);
	STDMETHOD(put_ToolSet)(toolSetType ToolSet);
	STDMETHOD(get_OutputDirectory)(BSTR *pVal);
	STDMETHOD(put_OutputDirectory)(BSTR newVal);
	STDMETHOD(get_IntermediateDirectory)(BSTR *pVal);
	STDMETHOD(put_IntermediateDirectory)(BSTR newVal);
	STDMETHOD(get_DeleteExtensionsOnClean)(BSTR* pbstrExt);	// wildcard extension list to delete on clean/rebuild from within the intermediate directory
	STDMETHOD(put_DeleteExtensionsOnClean)(BSTR bstrExt);
	STDMETHOD(get_ConfigurationType)(ConfigurationTypes* pconfigType);		// Configuration type: application, DLL, etc.
	STDMETHOD(put_ConfigurationType)(ConfigurationTypes configType);
	STDMETHOD(get_AppliedStyleSheets)(BSTR* pbstrStyles);
	STDMETHOD(put_AppliedStyleSheets)(BSTR bstrStyles);
	STDMETHOD(get_BuildBrowserInformation)(VARIANT_BOOL* pbBsc);	// build .bsc file
	STDMETHOD(put_BuildBrowserInformation)(VARIANT_BOOL bBsc);
	STDMETHOD(get_UseOfMFC)(useOfMfc* useMfc);	// how are we using MFC?
	STDMETHOD(put_UseOfMFC)(useOfMfc useMfc);
	STDMETHOD(get_UseOfATL)(useOfATL* useATL);	// how are we using ATL?
	STDMETHOD(put_UseOfATL)(useOfATL useATL);
	STDMETHOD(get_ATLMinimizesCRunTimeLibraryUsage)(VARIANT_BOOL* pbUseCRT);	// does the user want to link with the static or dynamic CRT?
	STDMETHOD(put_ATLMinimizesCRunTimeLibraryUsage)(VARIANT_BOOL bUseCRT);
	STDMETHOD(get_CharacterSet)(charSet* poptSetting);	// character set to use: Unicode, MBCS, default
	STDMETHOD(put_CharacterSet)(charSet optSetting);
	STDMETHOD(get_ManagedExtensions)(VARIANT_BOOL* bManaged);	// is this a managed C++ extensions project?
	STDMETHOD(put_ManagedExtensions)(VARIANT_BOOL bManaged);
	STDMETHOD(get_WholeProgramOptimization)(VARIANT_BOOL* pbOptimized);	// perform whole program optimization on build; more or less requires optimization turned on to be effective
	STDMETHOD(put_WholeProgramOptimization)(VARIANT_BOOL bOptimize);
	STDMETHOD(get_StyleSheets)(IDispatch** styles) { return CStyleSheetBase::DoGetStyleSheets(styles); }
	STDMETHOD(get_VCProjectEngine)(IDispatch** projEngine)	{ return DoGetVCProjectEngine(projEngine); }

// IVCStyleSheetImpl
public:
	STDMETHOD(put_IsDirty)(VARIANT_BOOL boolDirty);
	STDMETHOD(Close)();
	STDMETHOD(SaveObject)(IStream *xml, IVCPropertyContainer *pPropCnt, long nIndent);
	STDMETHOD(Clone)(IVCPropertyContainer *pSource);
	STDMETHOD(AddDependent)(IVCPropertyContainer* pPropContainer, BOOL bInformAboutAllProperties);
	STDMETHOD(RemoveDependent)(IVCPropertyContainer* pPropContainer, BOOL bInformAboutAllProperties);
	STDMETHOD(InformAboutProperties)(IVCPropertyContainer* pPropContainer, BOOL bAllProperties);
	STDMETHOD(get_LoadCount)(long* pnLoadCount);	// how many projects/style sheets have this style sheet loaded; used by project engine only
	STDMETHOD(put_LoadCount)(long nLoadCount);
	STDMETHOD(CreatePageObject)(IUnknown **, CLSID*, IVCPropertyContainer *pSource, IVCSettingsPage * );
	STDMETHOD(AddTool)(LPCOLESTR szToolName, IDispatch** ppTool);	// adds a new tool to the style sheet

#ifdef AARDVARK
//	IVCExternalCookie
public:
	STDMETHOD(get_ExternalCookie)(void** ppVal) { *ppVal = m_pExternalCookie; return S_OK; }
	STDMETHOD(put_ExternalCookie)(void* pVal) { m_pExternalCookie = pVal; return S_OK; }

protected:
	void* m_pExternalCookie;

// ISpecifyPropertyPages
public:
    STDMETHOD(GetPages)( /* [out] */ CAUUID *pPages );
#endif	// AARDVARK

// default IVCPropertyContainer methods are all in a base class
// default ISpecifyPropertyPages method is in a base class
     
// VCStyleSheet helpers
public:
	static HRESULT SGetToolSet(toolSetType* pToolSet);
protected:
	HRESULT DoSetToolSet(toolSetType toolSet, BOOL bForceUpdate = FALSE);

// IVCStyleSheetImpl helpers
public:
	virtual HRESULT SetDirty(VARIANT_BOOL bDirty) { return put_IsDirty(VARIANT_TRUE); }

// IVCPropertyContainer helpers
protected:
	virtual HRESULT DoSetIntProperty(long id, BOOL bCheckSpecialProps, long nValue, long nOverrideID = -1);

// LOCAL METHODS
public:

protected:
	virtual void DoGetToolSetType(toolSetType& listStyle);

//DATA
protected:
	CComDynamicListTyped<IVCPropertyContainer> m_rgDependents;		// collection of dependents for this style sheet
	VARIANT_BOOL m_bDirty;
	CComBSTR m_bstrFileName;
	CComBSTR m_bstrFullDir;
	long m_nLoadCount;
};

#ifdef AARDVARK
class ATL_NO_VTABLE CGeneralStyleSheetSettingsPage :
	public IDispatchImpl<IGeneralStyleSheetSettingsPage, &IID_IGeneralStyleSheetSettingsPage, &LIBID_StyleDemoLibrary, 3,0, CVsTypeInfoHolder>,
	public CPageObjectImpl<CGeneralStyleSheetSettingsPage,VCSTYLESHEET_MIN_DISPID, VCCONFIGURATION_MAX_DISPID>,
	public CComObjectRoot
{
public:
BEGIN_COM_MAP(CGeneralStyleSheetSettingsPage)
 	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IGeneralStyleSheetSettingsPage)
	COM_INTERFACE_ENTRY(IPerPropertyBrowsing)
	COM_INTERFACE_ENTRY(IVsPerPropertyBrowsing)
	COM_INTERFACE_ENTRY(IVCPropertyContainer)
END_COM_MAP()

	// IDispatch override
	STDMETHOD(Invoke)( DISPID dispid, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS *pdispParams, VARIANT *pvarResult, EXCEPINFO *pexcepInfo, UINT *puArgErr )
	{
		IDispatchImpl<IGeneralStyleSheetSettingsPage, &IID_IGeneralStyleSheetSettingsPage, &LIBID_StyleDemoLibrary, 3,0, CVsTypeInfoHolder>::Invoke( dispid, riid, lcid, wFlags, pdispParams, pvarResult, pexcepInfo, puArgErr );
		return S_OK;
	}


// IGeneralStyleSheetSettingsPage
public:
	STDMETHOD(get_ToolSet)(toolSetType* ToolSetList);	// what type of tools do we use?
	STDMETHOD(put_ToolSet)(toolSetType ToolSetList);

	// yes, the use of VCCFGID_ IDs is intentional here...  these *are* things that the configuration can use to default in values for
	STDMETHOD(get_AppliedStyleSheets)(BSTR* StyleNames);	// style sheet names applied to this configuration; purposely *NOT* in UI, but still browsable
	STDMETHOD(put_AppliedStyleSheets)(BSTR StyleNames);
	STDMETHOD(get_BuildBrowserInformation)(enumBOOL* Bsc);	// build .bsc file
	STDMETHOD(put_BuildBrowserInformation)(enumBOOL Bsc);
	STDMETHOD(get_UseOfMFC)(useOfMfc* useMfc);	// how are we using MFC?
	STDMETHOD(put_UseOfMFC)(useOfMfc useMfc);
	STDMETHOD(get_UseOfATL)(useOfATL* useATL);	// how are we using ATL?
	STDMETHOD(put_UseOfATL)(useOfATL useATL);
	STDMETHOD(get_ATLMinimizesCRunTimeLibraryUsage)(enumBOOL* UseCRT);	// does the user want to link with the static or dynamic CRT?
	STDMETHOD(put_ATLMinimizesCRunTimeLibraryUsage)(enumBOOL UseCRT);
	STDMETHOD(get_CharacterSet)(charSet* optSetting);	// character set to use: Unicode, MBCS, default
	STDMETHOD(put_CharacterSet)(charSet optSetting);
	STDMETHOD(get_ManagedExtensions)(enumBOOL* Managed);	// is this a managed C++ project?
	STDMETHOD(put_ManagedExtensions)(enumBOOL Managed);
	STDMETHOD(get_DeleteExtensionsOnClean)(BSTR* ExtList);	// wildcard extension list to delete on clean/rebuild from within the intermediate directory
	STDMETHOD(put_DeleteExtensionsOnClean)(BSTR ExtList);
	STDMETHOD(get_WholeProgramOptimization)(enumBOOL* Optimize);	// perform whole program optimization on build; more or less requires optimization turned on to be effective
	STDMETHOD(put_WholeProgramOptimization)(enumBOOL Optimize);
};

class CGeneralStyleSheetSettings :
	public CSettingsPageBase<CGeneralStyleSheetSettings, &CLSID_GeneralStyleSheetSettings, IDS_GeneralConfigSettings, 0>
{
public:
	CGeneralStyleSheetSettings() {}
// IVSPropertyPage
    STDMETHOD(get_CategoryTitle)( UINT iLevel, BSTR *pbstrCategory )
	{ return S_FALSE; }

protected:
	virtual void DoCreatePageObject(UINT i, IDispatch* pDisp, IVCPropertyContainer* pLiveContainer, IVCSettingsPage* pPage)
	{
		CPageObjectImpl<CGeneralStyleSheetSettingsPage,VCSTYLESHEET_MIN_DISPID, VCCONFIGURATION_MAX_DISPID>::CreateInstance(&m_ppUnkArray[i], pLiveContainer, pPage);
	}
};
#endif	// AARDVARK
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\vcpb\util2.cpp ===
#include "stdafx.h"
#pragma hdrstop

#include "util2.h"

static bool bPlatformInited = false;
static DWORD dwPlatform;

/*** GETEXETYPE
 *
 * PURPOSE: Given an open handle to file determine it's executable type if any.
 *
 * INPUT:
 *      hFile - Handle to an open file
 *
 * OUTPUT:
 *      EXT   - EXecutable Type in return value
 *
 * EXCEPTIONS:
 *
 * IMPLEMENTATION:
 *
 *      This function will save the file pointer and restore it on exit.
 *      A return type of EXE_NONE indicates either an error occured while
 *      seeking/reading or the file wasn't of any recognized EXE type.
 *
 *		If the EXE type is EXE_NT, then *pwSubsystem will indicate
 *		the subsystem type (IMAGE_SUBSYSTEM_...).  If the EXE type is
 *		NOT EXE_NT, the value *pwSubsystem on return is meaningless.
 *
 *		You can pass NULL for pwSubsystem, in which case no value will
 *		be returned through that pointer.
 *
 ****************************************************************************/
#define NE_UNKNOWN	0x0
#define NE_OS2		0x1
#define NE_WINDOWS	0x2
#define NE_DOS		0x3

EXT GetExeType		
(
	LPCOLESTR	lpstrEXEFilename,
	WORD *	pwSubsystem
)
{
	IMAGE_DOS_HEADER        doshdr;
	IMAGE_OS2_HEADER        os2hdr;
	IMAGE_NT_HEADERS        nthdr;
	HANDLE					hFile;
	BOOL					fGotNE = FALSE;
	DWORD					dwBytesRead;

	/*
	** open up our EXE
	*/
	hFile = CreateFileW(
				lpstrEXEFilename,
				GENERIC_READ,
				FILE_SHARE_READ,
				NULL,
				OPEN_EXISTING,
				FILE_ATTRIBUTE_NORMAL, 
				NULL
			);
	if (hFile == INVALID_HANDLE_VALUE) {
		return EXE_FAIL;
	}

    /*
    ** Try to read a an MZ header
    */
    ReadFile(hFile, &doshdr, sizeof (IMAGE_DOS_HEADER),	&dwBytesRead, NULL);

	if (dwBytesRead != sizeof (IMAGE_DOS_HEADER))
    {
		CloseHandle(hFile);
        return EXE_NONE;
    }

    /*
    ** If it was an MZ header and if the address of the relocation table
    ** isn't 0x0040 then it is a DOS non segmented executable.
    */
    if (doshdr.e_magic == IMAGE_DOS_SIGNATURE)
    {
    	if (doshdr.e_lfarlc != 0x0040)
    	{
			CloseHandle(hFile);
			return EXE_DOS;
		}
		else
			fGotNE = TRUE;
    }

    /*
	** Seek now to either the beginning of the file if there was no MZ stub or
	** to the new header specified in the MZ header.
    */
    if (SetFilePointer(hFile, fGotNE ? doshdr.e_lfanew : 0L, NULL, FILE_BEGIN) == 0xFFFFFFFF)
	{
		CloseHandle(hFile);
        return EXE_NONE;
	}

    ReadFile(hFile, &os2hdr, sizeof (IMAGE_OS2_HEADER), &dwBytesRead, NULL);
	if (dwBytesRead != sizeof (IMAGE_OS2_HEADER))
	{
		CloseHandle(hFile);
        return EXE_NONE;
    }

    if (os2hdr.ne_magic == IMAGE_OS2_SIGNATURE)
    {
		EXT	ext;

		switch(os2hdr.ne_exetyp)
		{
			case NE_OS2:
				ext = EXE_OS2_NE;
				break;

			case NE_WINDOWS:
				ext = EXE_WIN;
				break;

			case NE_DOS:
				ext = EXE_DOS;
				break;

			default:
				ext = EXE_NONE;
				break;
		}

		CloseHandle(hFile);
        return ext;
    }
    else if (os2hdr.ne_magic == IMAGE_OS2_SIGNATURE_LE)
    {
		EXT ext;

		ext = (os2hdr.ne_exetyp == NE_UNKNOWN) ? EXE_NONE : EXE_OS2_LE;

		CloseHandle(hFile);
        return EXE_OS2_LE;
    }


    /*
    ** Re-seek to the header, read it as an NT header and check for PE exe.
    */

    if (SetFilePointer(hFile, doshdr.e_lfanew, NULL, FILE_BEGIN) == 0xFFFFFFFF)
	{
		CloseHandle(hFile);
        return EXE_NONE;
    }

    ReadFile(hFile, &nthdr, sizeof (IMAGE_NT_HEADERS), &dwBytesRead, NULL);
	if (dwBytesRead != sizeof (IMAGE_NT_HEADERS))
    {
		CloseHandle(hFile);
        return EXE_NONE;
    }

    if (nthdr.Signature == IMAGE_NT_SIGNATURE)
    {
		// Return the subsystem as well.
		//
		// [CUDA 3557: 4/21/93 mattg]
		if (pwSubsystem != NULL)
		{
			if (nthdr.FileHeader.SizeOfOptionalHeader < IMAGE_SIZEOF_NT_OPTIONAL_HEADER)
				*pwSubsystem = IMAGE_SUBSYSTEM_UNKNOWN;
			else
				*pwSubsystem = nthdr.OptionalHeader.Subsystem;
		}
		CloseHandle(hFile);
        return EXE_NT;
    }


    /*
    ** Well, It isn't an Executable type that we know about....
    */

	CloseHandle(hFile);

    return EXE_NONE;

} /* GetExeType */

void InitPlatform()
{
	if( bPlatformInited )
	    return;

	bPlatformInited = true;
	// what OS are we running on?
	OSVERSIONINFO osver;
	memset( &osver, 0, sizeof(osver) );
	osver.dwOSVersionInfoSize = sizeof(osver);
	GetVersionEx( &osver );
	dwPlatform = osver.dwPlatformId;
	return;
}

//-----------------------------------------------------------------------------
// Handle SendMessage as SendMessageW on NT/Win2k
//-----------------------------------------------------------------------------
LRESULT UtilSendMessageW( HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam )
{
    	InitPlatform();
	// if we're running on NT, use Unicode 
	if( dwPlatform == VER_PLATFORM_WIN32_NT )
		return SendMessageW( hWnd, Msg, wParam, lParam );
	// otherwise, Win9x, we can't use Unicode
	else
		return SendMessage( hWnd, Msg, wParam, lParam );
}

//-----------------------------------------------------------------------------
// Handle SendMessage as SendMessageW on NT/Win2k where the LPARAM is a string
// (hence ANSI on Win9x and Unicode on NT/Win2k...)
//-----------------------------------------------------------------------------
LRESULT UtilSendMessageWString( HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam )
{
    	InitPlatform();
	// if we're running on NT, use Unicode 
	if( dwPlatform == VER_PLATFORM_WIN32_NT )
	{
		return SendMessageW( hWnd, Msg, wParam, lParam );
	}
	// otherwise, Win9x, we can't use Unicode
	else
	{
		// convert the string to ANSI
		USES_CONVERSION;
		char *szString = W2A( (wchar_t*)lParam );
		return SendMessageA( hWnd, Msg, wParam, (LPARAM)szString );
	}
}

FILE *fopenW( const wchar_t *szFileName, const wchar_t* szAttributes)
{
    	FILE *hFile = NULL;
    	InitPlatform();
	if( dwPlatform == VER_PLATFORM_WIN32_NT )
	{
		hFile = _wfopen( szFileName, szAttributes );
	}
	// otherwise, Win9x, we can't use Unicode
	else
	{
		// convert the string to ANSI
		USES_CONVERSION;
		char * szFN = W2A( (wchar_t*)szFileName );
		char * szAT = W2A( (wchar_t*)szAttributes );
		hFile = fopen( szFN, szAT );
	}
	return hFile;
}


bool CanCreateProcess( LPCOLESTR szExe )
{
	// check \\HKCU\Software\Microsoft\Windows\CurrentVersion\Policies\Explorer\RestrictRun
	// to see if we can execute this process or not

	LONG lRet;
	HKEY hSectionKey = NULL;
	DWORD nType = REG_SZ;
	DWORD nSize = 2047;
	wchar_t szRet[2048] = {0};

	// open the reg key
	lRet = RegOpenKeyExW( HKEY_CURRENT_USER, L"Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\Explorer", 0, KEY_READ, &hSectionKey );

	// if we found it, read the value
	if( hSectionKey && lRet == ERROR_SUCCESS )
		lRet = RegQueryValueExW( hSectionKey, L"RestrictRun", NULL, &nType, (LPBYTE)szRet, &nSize );
	// else return true, the key doesn't exist, so we can run whatever we
	// please
	else
	{
		if (hSectionKey)
			RegCloseKey(hSectionKey);
		return true;
	}

	// close the key
	RegCloseKey( hSectionKey );

	// the value doesn't exist, so we can run whatever we please
	if( lRet != ERROR_SUCCESS )
		return true;

	// is szExe in the key?
	if( wcsistr( szRet, (LPOLESTR)szExe ) )
		return true;
	else
		return false;
}

LPCOLESTR wcsistr(LPCOLESTR szSearch, LPCOLESTR szReqd)
{
	// case insensitive string inclusion (like wcsstr but insensitive)
	LPCOLESTR pszRet = NULL;

	wchar_t *pszSrchTmp;
	wchar_t *pszReqdTmp;

	pszSrchTmp = (wchar_t *)malloc(sizeof(wchar_t)*(wcslen(szSearch)+1));
	pszReqdTmp = (wchar_t *)malloc(sizeof(wchar_t)*(wcslen(szReqd)+1));
	if(pszSrchTmp  && pszReqdTmp )
	{
	    wchar_t *pstr;
    
	    wcslwr(wcscpy(pszSrchTmp, szSearch));
	    wcslwr(wcscpy(pszReqdTmp, szReqd));
    
	    pstr = wcsstr(pszSrchTmp, pszReqdTmp);
	    if (pstr)
		    pszRet = (pstr - pszSrchTmp) + szSearch;

	}
	free(pszSrchTmp);
	free(pszReqdTmp);

	return pszRet;
}

LPSTR stristr(char *szSearch, char *szReqd)
{
	// case insensitive string inclusion (like _ftcsstr but insensitive)
	unsigned char *pszRet = NULL;

	unsigned char *pszSrchTmp;
	unsigned char *pszReqdTmp;

	pszSrchTmp = (unsigned char *)malloc(sizeof(char)*(_mbslen((unsigned char *)szSearch)+1));
	pszReqdTmp = (unsigned char *)malloc(sizeof(char)*(_mbslen((unsigned char *)szReqd)+1));

	if(pszSrchTmp  && pszReqdTmp )
	{
	    unsigned char *pstr;
    
	    _mbslwr(_mbscpy(pszSrchTmp, (unsigned char *)szSearch));
	    _mbslwr(_mbscpy(pszReqdTmp, (unsigned char *)szReqd));
    
	    pstr = _mbsstr(pszSrchTmp, pszReqdTmp);
	    if (pstr)
		    pszRet = (unsigned char *)szSearch + (pstr - pszSrchTmp);
	}
    
	free(pszSrchTmp);
	free(pszReqdTmp);

	return (LPSTR)pszRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\vcpb\VCNodeFactory.cpp ===
// VCNodeFactory.cpp : Implementation of CVCNodeFactory
#include "stdafx.h"
#include "VCNodeFactory.h"
#include "vcprojectengine.h"	// g_pProjectEngine


static const WCHAR *wszProject = L"VisualStudioProject";
static const WCHAR *wszStyleSheet = L"VisualStudioStyleSheet";
static const WCHAR *wszConfiguration = L"Configuration";
static const WCHAR *wszFileConfiguration = L"FileConfiguration";
static const WCHAR *wszTool = L"Tool";
static const WCHAR *wszFilter = L"Filter";
static const WCHAR *wszFile = L"File";
static const WCHAR *wszPlatform = L"Platform";
static const WCHAR *wszGlobals = L"Globals";
static const WCHAR *wszGlobal = L"Global";
static const WCHAR *wszXML = L"xml";

/////////////////////////////////////////////////////////////////////////////
// CVCNodeFactory

CVCNodeFactory::CVCNodeFactory()
{
}

CVCNodeFactory::~CVCNodeFactory()
{
}

HRESULT CVCNodeFactory::CreateInstance( IVCNodeFactory **ppNodeFactory )
{
	HRESULT hr;
	CVCNodeFactory *pVar;
	CComObject<CVCNodeFactory> *pObj;
	hr = CComObject<CVCNodeFactory>::CreateInstance( &pObj );
	if( SUCCEEDED( hr ) )
	{
		pVar = pObj;
		pVar->AddRef();
		*ppNodeFactory = pVar;
	}
	return hr;
}

STDMETHODIMP CVCNodeFactory::put_Name( BSTR bstrName )
{
	m_bstrName = bstrName;
	return S_OK;
}

STDMETHODIMP CVCNodeFactory::get_Root( IDispatch **ppDisp )
{
	CHECK_POINTER_NULL( ppDisp );
	m_pRoot.CopyTo( ppDisp );
	return S_OK;
}

STDMETHODIMP CVCNodeFactory::get_FileEncoding( BSTR* pbstrEncoding )
{
	CHECK_POINTER_NULL(pbstrEncoding);
	m_bstrEncoding.CopyTo(pbstrEncoding);
	return S_OK;
}

STDMETHODIMP CVCNodeFactory::NotifyEvent( IXMLNodeSource* pSource, XML_NODEFACTORY_EVENT iEvt )
{
	// TODO: do we actually care about any of this??

	// events we care about:
	switch( iEvt )
	{
	// XMLNF_STARTDOCUMENT - start of document
	case XMLNF_STARTDOCUMENT:
		break;
	// XMLNF_ENDPROLOG ?? - end of prolog, start of 'real' data
	case XMLNF_ENDPROLOG:
		break;
	// XMLNF_ENDDOCUMENT - end of document
	case XMLNF_ENDDOCUMENT:
		break;
	default:
		break;
	}
	return S_OK;
}

STDMETHODIMP CVCNodeFactory::BeginChildren( IXMLNodeSource* pSource, XML_NODE_INFO* pNodeInfo )
{
	// TODO: do we need to do anything here??
	// called when a node may contain children
	// e.g. <foo name="bar"> will cause BeginChildren to be called,
	// but <foo name="bar"/> will not
	return S_OK;
}

STDMETHODIMP CVCNodeFactory::EndChildren( IXMLNodeSource* pSource, BOOL fEmpty, XML_NODE_INFO* pNodeInfo )
{
	// TODO: do we need to do anything here?
	// no more children 
	// e.g. </foo>
	return S_OK;
}

STDMETHODIMP CVCNodeFactory::Error( IXMLNodeSource* pSource, HRESULT hrErrorCode, USHORT cNumRecs, XML_NODE_INFO __RPC_FAR **aNodeInfo )
{
	// TODO: implement
	// an error has occurred reading the xml
	// free all resources and bail
	// (the HRESULT we pass out of here will be the HRESULT that Run returns)
	CComPtr<IDispatch> pDispColl;
	HRESULT hr = g_pProjectEngine->get_Projects( &pDispColl );
	RETURN_ON_FAIL2(hr, hrErrorCode);
	CComQIPtr<IVCCollection> pProjects = pDispColl;
	RETURN_ON_NULL2(pProjects, hrErrorCode);
	CComPtr<IDispatch> pDispProject;
	HRESULT hrProj = pProjects->Item( CComVariant( m_bstrName ), &pDispProject );
	if (SUCCEEDED(hrProj) && pDispProject)
	{
		if (CVCProjectEngine::s_pBuildPackage)
		{
			CComQIPtr<VCProject> spProject = pDispProject;
			if (spProject)
				CVCProjectEngine::s_pBuildPackage->ErrorCloseOfProject(spProject);
		}
		CComQIPtr<IVCProjectEngineImpl> spProjEngineImpl = g_pProjectEngine;
		if (spProjEngineImpl)
			spProjEngineImpl->RemoveProjectUnderShell( pDispProject );
		return hrErrorCode;
	}

	pDispColl.Release();
	CComQIPtr<IVCProjectEngineImpl> spProjectEngineImpl = g_pProjectEngine;
	VSASSERT(spProjectEngineImpl != NULL, "Hey, bad project engine!");
	hr = spProjectEngineImpl->get_AllStyleSheets( &pDispColl );
	RETURN_ON_FAIL2(hr, hrErrorCode);
	CComQIPtr<IVCCollection> pStyleSheets = pDispColl;
	RETURN_ON_NULL2(pStyleSheets, hrErrorCode);
	CComPtr<IDispatch> pDispStyleSheet;
	HRESULT hrStyle = pStyleSheets->Item( CComVariant( m_bstrName ), &pDispStyleSheet );
	if (SUCCEEDED(hrStyle) && pDispStyleSheet)
	{
		CComQIPtr<IVCProjectEngineImpl> spProjectEngineImpl = g_pProjectEngine;
		if (spProjectEngineImpl)
			spProjectEngineImpl->UnloadStyleSheet(pDispStyleSheet);
	}

	return hrErrorCode;
}

STDMETHODIMP CVCNodeFactory::CreateNode( IXMLNodeSource __RPC_FAR *pSource, PVOID pNodeParent, USHORT cNumRecs, XML_NODE_INFO __RPC_FAR **aNodeInfo )
{
	// main method for creating our data
	
	HRESULT hr;

	CComPtr<IDispatch> pDisp; // the dispatch of the last object created

	// counter for looping through attributes
	USHORT i = 0;

	// ignore whitespace
	if( aNodeInfo[0]->dwType == XML_WHITESPACE )
		return S_OK;
	
	// what type of node is this?
	// (the first XML_NODE_INFO in array better be the XML_ELEMENT...)

	// these if-else's are arranged so that the most commonly occuring nodes are
	// first, for better large-project perf (less wcscmp's)

	// File node
	if( wcscmp( aNodeInfo[0]->pwcText, wszFile ) == 0 )
	{
		hr = HandleFileNode(pNodeParent, cNumRecs, aNodeInfo, pDisp);
		RETURN_ON_FAIL(hr);
	}
	// Filter node
	else if( wcscmp( aNodeInfo[0]->pwcText, wszFilter ) == 0 )
	{
		hr = HandleFilterNode(pNodeParent, cNumRecs, aNodeInfo, pDisp);
		RETURN_ON_FAIL(hr);
	}
	// Tool node
	else if( wcscmp( aNodeInfo[0]->pwcText, wszTool ) == 0 )
	{
		hr = HandleToolNode(pNodeParent, cNumRecs, aNodeInfo, pDisp);
		RETURN_ON_FAIL(hr);
	}
	// Configuration node
	else if( wcscmp( aNodeInfo[0]->pwcText, wszConfiguration ) == 0 )
	{
		hr = HandleProjConfigNode(pNodeParent, cNumRecs, aNodeInfo, pDisp);
		RETURN_ON_FAIL(hr);
	}
	// FileConfiguration node
	else if( wcscmp( aNodeInfo[0]->pwcText, wszFileConfiguration ) == 0 )
	{
		hr = HandleFileConfigNode(pNodeParent, cNumRecs, aNodeInfo, pDisp);
		RETURN_ON_FAIL(hr);
	}
	// Platform node
	else if( wcscmp( aNodeInfo[0]->pwcText, wszPlatform ) == 0 )
	{
		hr = HandlePlatformNode(pNodeParent, cNumRecs, aNodeInfo, pDisp);
		RETURN_ON_FAIL(hr);
	}
	// Project node
	else if( wcscmp( aNodeInfo[0]->pwcText, wszProject ) == 0 )
	{
		hr = HandleProjectNode(cNumRecs, aNodeInfo, pDisp, i);
		RETURN_ON_FAIL(hr);
	}
	// style sheet node
	else if (wcscmp( aNodeInfo[0]->pwcText, wszStyleSheet ) == 0 )
	{
		hr = HandleStyleSheetNode(pNodeParent, cNumRecs, aNodeInfo, pDisp);
		RETURN_ON_FAIL(hr);
	}
	else if( wcscmp( aNodeInfo[0]->pwcText, wszGlobal ) == 0 )
	{
		hr = HandleGlobalNode(pNodeParent, cNumRecs, aNodeInfo, pDisp, i);
		RETURN_ON_FAIL(hr);
	}
	else if( wcsicmp( aNodeInfo[0]->pwcText, wszXML ) == 0 )
	{
		hr = HandleXMLHeaderNode(cNumRecs, aNodeInfo);
		RETURN_ON_FAIL(hr);
	}

	// other node types we don't care about, ignore but continue so the parent
	// gets set correctly
			
	// set this object's properties from the attribute list given
	for( ; i < cNumRecs; i++ )
	{
		// type?
		switch( aNodeInfo[i]->dwType )
		{
		case XML_ELEMENT:
			if( pDisp )
				// return the dispatch pointer in the node info structure
				aNodeInfo[i]->pNode = (void*)pDisp;
			else
				aNodeInfo[i]->pNode = pNodeParent;
			break;
		case XML_ATTRIBUTE:
		{
			CComBSTR pwcText, bstrVal;
			CollectAttributeNameAndValue(cNumRecs, aNodeInfo, i, pwcText, bstrVal);
			CComVariant varArg = bstrVal;

			// file configs won't have a parent dispatch pointer set, 
			// all other nodes should
			if( pDisp )
			{
				CComDispatchDriver dispDriver( pDisp );
				hr = dispDriver.PutPropertyByName( pwcText, &varArg );
			}

			break;
		}
		case XML_PCDATA:
			// shouldn't ever get here: the data elements ought to be handled
			// in the XML_ATTRIBUTE case above
			VSASSERT( FALSE, "VC XML Reader: XML_PCDATA nodes ought never be reached here!" );
			return CVCProjectEngine::DoSetErrorInfo(VCPROJ_E_BAD_PROJ_FILE, IDS_ERR_BAD_PROJ_FILE);
		default:
			// ignore the node data we don't care about
			break;
		}
	}
	
	return S_OK;
}

HRESULT CVCNodeFactory::ValidateTagAndGetName(USHORT cNumRecs, XML_NODE_INFO __RPC_FAR ** aNodeInfo, LPCOLESTR szAttribName, CComBSTR& bstrName)
{
	// 1st attribute MUST be of type szAttribName
	VSASSERT( cNumRecs > 2, "Invalid project file, node has insufficient attributes" );
	if( cNumRecs <= 2 )
	{
		RETURN_INVALID();
	}
	if( aNodeInfo[1]->dwType != XML_ATTRIBUTE || aNodeInfo[2]->dwType != XML_PCDATA )
		return CVCProjectEngine::DoSetErrorInfo(VCPROJ_E_BAD_PROJ_FILE, IDS_ERR_BAD_PROJ_FILE);
	if( wcsncmp( szAttribName, aNodeInfo[1]->pwcText, aNodeInfo[1]->ulLen ) != 0 )
		return CVCProjectEngine::DoSetErrorInfo(VCPROJ_E_BAD_PROJ_FILE, IDS_ERR_BAD_PROJ_FILE);
	bstrName = CComBSTR( aNodeInfo[2]->ulLen, aNodeInfo[2]->pwcText );

	return S_OK;
}

HRESULT CVCNodeFactory::HandleFileNode(PVOID pNodeParent, USHORT cNumRecs, XML_NODE_INFO __RPC_FAR ** aNodeInfo, CComPtr<IDispatch>& pDisp)
{	// Add the file to the project or filter, depending on what the parent node is
	CComBSTR bstrName;
	HRESULT hr = ValidateTagAndGetName(cNumRecs, aNodeInfo, L"RelativePath", bstrName);
	RETURN_ON_FAIL(hr);

	CComQIPtr<VCProject> pProject = (IDispatch*)pNodeParent;
	CComQIPtr<VCFilter> pFilter = (IDispatch*)pNodeParent;

	// if the last node was a project
	if( pProject )
	{
		hr = pProject->AddFile( bstrName, &pDisp );
		RETURN_ON_FAIL(hr);
		if (pDisp == NULL)
			return CVCProjectEngine::DoSetErrorInfo2(VCPROJ_E_NOT_FOUND, IDS_ERR_FILE_NOT_FOUND, bstrName);
	}
	// if the last node was a filter
	else if( pFilter )
	{
		hr = pFilter->AddFile( bstrName, &pDisp );
		RETURN_ON_FAIL(hr);
		if (pDisp == NULL)
			return CVCProjectEngine::DoSetErrorInfo2(VCPROJ_E_NOT_FOUND, IDS_ERR_FILTER_NOT_FOUND, bstrName);
	}
	// if the last node was neither, the XML is malformed, bail
	else 
		return CVCProjectEngine::DoSetErrorInfo(VCPROJ_E_BAD_PROJ_FILE, IDS_ERR_BAD_PROJ_FILE);

	return S_OK;
}


HRESULT CVCNodeFactory::HandleFilterNode(PVOID pNodeParent, USHORT cNumRecs, XML_NODE_INFO __RPC_FAR ** aNodeInfo, CComPtr<IDispatch>& pDisp)
{
	// Add the filter to the project or filter, depending on what the parent node is

	CComBSTR bstrName;
	HRESULT hr = ValidateTagAndGetName(cNumRecs, aNodeInfo, L"Name", bstrName);
	RETURN_ON_FAIL(hr);

	CComQIPtr<VCProject> pProject = (IDispatch*)pNodeParent;
	CComQIPtr<VCFilter> pFilter = (IDispatch*)pNodeParent;

	// if the last node was a project
	if( pProject )
	{
		hr = pProject->AddFilter( bstrName, &pDisp );
		RETURN_ON_FAIL(hr);
		if (pDisp == NULL)
			return CVCProjectEngine::DoSetErrorInfo2(VCPROJ_E_NOT_FOUND, IDS_ERR_FILTER_NOT_FOUND, bstrName);
	}
	// if the last node was a filter
	else if( pFilter )
	{
		hr = pFilter->AddFilter( bstrName, &pDisp );
		RETURN_ON_FAIL(hr);
		if (pDisp == NULL)
			return CVCProjectEngine::DoSetErrorInfo2(VCPROJ_E_NOT_FOUND, IDS_ERR_FILTER_NOT_FOUND, bstrName);
	}
	// if the last node was neither, the XML is malformed, bail
	else 
		return CVCProjectEngine::DoSetErrorInfo(VCPROJ_E_BAD_PROJ_FILE, IDS_ERR_BAD_PROJ_FILE);

	return S_OK;
}

HRESULT CVCNodeFactory::HandleToolNode(PVOID pNodeParent, USHORT cNumRecs, XML_NODE_INFO __RPC_FAR ** aNodeInfo, CComPtr<IDispatch>& pDisp)
{
	// Get this tool from the config's or style sheet's tool collection
	// or from the file config, depending on what the parent node is
	
	CComQIPtr<VCConfiguration> pConfig = (IDispatch*)pNodeParent;
	CComQIPtr<VCFileConfiguration> pFileConfig = (IDispatch*)pNodeParent;
	CComQIPtr<VCStyleSheet> pStyleSheet = (IDispatch*)pNodeParent;

	HRESULT hr = S_OK;

	// if the last node was a config or style sheet , we need to index the tool collection
	if( pConfig || pStyleSheet )
	{
		// get the tools collection
		CComPtr<IDispatch> pDispColl;
		if( pConfig )
			hr = pConfig->get_Tools( &pDispColl );
		else
			hr = pStyleSheet->get_Tools( &pDispColl );
		CComQIPtr<IVCCollection> pToolsColl = pDispColl;
		RETURN_ON_FAIL_OR_NULL2(hr, pToolsColl, E_NOINTERFACE);
		CComBSTR bstrName;
		hr = ValidateTagAndGetName(cNumRecs, aNodeInfo, L"Name", bstrName);
		RETURN_ON_FAIL(hr);
		// store the item
		hr = pToolsColl->Item( CComVariant( bstrName ), &pDisp );
		if( FAILED( hr ) )
		{
			if (pConfig)
			{
				CComQIPtr<IVCConfigurationImpl> pConfigImpl = pConfig;
				hr = pConfigImpl->AddTool(bstrName, &pDisp);
			}
			else
			{
				CComQIPtr<IVCStyleSheetImpl> pStyleSheetImpl = pStyleSheet;
				hr = pStyleSheetImpl->AddTool(bstrName, &pDisp);
			}
			if (FAILED(hr))
			{
				pDisp = NULL;
				hr = S_FALSE;
			}
		}
		else if (pDisp == NULL)
		{
			if (pConfig)
			{
				CComQIPtr<IVCConfigurationImpl> pConfigImpl = pConfig;
				hr = pConfigImpl->AddTool(bstrName, &pDisp);
			}
			else
			{
				CComQIPtr<IVCStyleSheetImpl> pStyleSheetImpl = pStyleSheet;
				hr = pStyleSheetImpl->AddTool(bstrName, &pDisp);
			}
			if (FAILED(hr))
			{
				pDisp = NULL;
				hr = S_FALSE;
			}
		}
	}
	
	// if the last node was a file config, just set pDisp to the file
	// config's tool 
	else if( pFileConfig )
	{
		// set the tool
		CComQIPtr<IVCFileConfigurationImpl> pFileCfgImpl = pFileConfig;
		if (!pFileCfgImpl)
			return E_NOINTERFACE;

		CComPtr<IDispatch> pDispConfig;
		hr = pFileCfgImpl->get_Configuration(&pDispConfig);
		CComQIPtr<VCConfiguration> pConfig = pDispConfig;
		RETURN_ON_FAIL_OR_NULL2(hr, pConfig, E_NOINTERFACE);

		CComPtr<IDispatch> pDispColl;
		hr = pConfig->get_Tools( &pDispColl );		
		CComQIPtr<IVCCollection> pToolsColl = pDispColl;
		RETURN_ON_FAIL_OR_NULL2(hr, pToolsColl, E_NOINTERFACE);

		CComBSTR bstrName;
		hr = ValidateTagAndGetName(cNumRecs, aNodeInfo, L"Name", bstrName);
		RETURN_ON_FAIL(hr);

		// find the parent tool
		CComPtr<IDispatch> pDispParentTool;
		hr = pToolsColl->Item( CComVariant( bstrName ), &pDispParentTool );
		if( FAILED( hr ) )
		{
			pDisp = NULL;
			hr = S_FALSE;
		}

		// set the tool
		hr = pFileConfig->put_Tool( pDispParentTool );
		RETURN_ON_FAIL(hr);

		// get the actual tool (as opposed to the parent one used to setup the one we want)
		CComPtr<IDispatch> pDispTool;
		hr = pFileConfig->get_Tool( &pDispTool );
		RETURN_ON_FAIL(hr);
		// store it
		pDisp = pDispTool;
	}

	// if the last node was neither, the XML is malformed, bail
	else 
		return CVCProjectEngine::DoSetErrorInfo(VCPROJ_E_BAD_PROJ_FILE, IDS_ERR_BAD_PROJ_FILE);

	return S_OK;
}

HRESULT CVCNodeFactory::HandleProjConfigNode(PVOID pNodeParent, USHORT cNumRecs, XML_NODE_INFO __RPC_FAR ** aNodeInfo, CComPtr<IDispatch>& pDisp)
{
	// Add the config
	CComQIPtr<VCProject> pProject = (IDispatch*)pNodeParent;
	RETURN_ON_NULL2(pProject, E_NOINTERFACE);

	// get the whole name (cfg name + "|" + platform name)
	CComBSTR bstrName;
	HRESULT hr = ValidateTagAndGetName(cNumRecs, aNodeInfo, L"Name", bstrName);
	RETURN_ON_FAIL(hr);

	// get just the cfg name part
	WCHAR* pos = wcsstr( bstrName, L"|" );
	if (pos == NULL)
		return CVCProjectEngine::DoSetErrorInfo(VCPROJ_E_BAD_PROJ_FILE, IDS_ERR_BAD_PROJ_FILE);
	CComBSTR bstrCfgName( (UINT) (pos - bstrName), bstrName );
	// add this cfg name (adds it to all platforms)
	hr = pProject->AddConfiguration( bstrCfgName );
	// get the config collection from the project
	CComPtr<IDispatch> pDispColl;
	hr = pProject->get_Configurations( &pDispColl );
	CComQIPtr<IVCCollection> pCfgColl = pDispColl;
	RETURN_ON_FAIL_OR_NULL2(hr, pCfgColl, E_NOINTERFACE);
	// index into it by config name + "|" + platform name
	hr = pCfgColl->Item( CComVariant( bstrName ), &pDisp );
	if( FAILED( hr ) )
	{
		pDisp = NULL;
		return hr;
	}

	return S_OK;
}

HRESULT CVCNodeFactory::HandleFileConfigNode(PVOID pNodeParent, USHORT cNumRecs, XML_NODE_INFO __RPC_FAR ** aNodeInfo, CComPtr<IDispatch>& pDisp)
{
	// Get this file config

	CComQIPtr<VCFile> pFile = (IDispatch*)pNodeParent;
	RETURN_ON_NULL2(pFile, E_NOINTERFACE);
	// get the collection
	CComPtr<IDispatch> pDispColl;
	HRESULT hr = pFile->get_FileConfigurations( &pDispColl );
	CComQIPtr<IVCCollection> pFileConfigsColl = pDispColl;
	RETURN_ON_FAIL_OR_NULL2(hr, pFileConfigsColl, E_NOINTERFACE);
	CComBSTR bstrName;
	hr = ValidateTagAndGetName(cNumRecs, aNodeInfo, L"Name", bstrName);
	RETURN_ON_FAIL(hr);

	// store the item
 	hr = pFileConfigsColl->Item( CComVariant( bstrName ), &pDisp );
	if( FAILED( hr ) )
	{
		pDisp = NULL;
		return CVCProjectEngine::DoSetErrorInfo2(VCPROJ_E_NOT_FOUND, IDS_ERR_FILE_CFG_NOT_FOUND, bstrName);
	}

	return S_OK;
}

HRESULT CVCNodeFactory::HandlePlatformNode(PVOID pNodeParent, USHORT cNumRecs, XML_NODE_INFO __RPC_FAR ** aNodeInfo, CComPtr<IDispatch>& pDisp)
{
	CComQIPtr<VCProject> pProject = (IDispatch*)pNodeParent;
	RETURN_ON_NULL2(pProject, E_NOINTERFACE);

	CComBSTR bstrName;
	HRESULT hr = ValidateTagAndGetName(cNumRecs, aNodeInfo, L"Name", bstrName);
	RETURN_ON_FAIL(hr);

	return pProject->AddPlatform( bstrName );
}

HRESULT CVCNodeFactory::HandleStyleSheetNode(PVOID pNodeParent, USHORT cNumRecs, XML_NODE_INFO __RPC_FAR ** aNodeInfo, CComPtr<IDispatch>& pDisp)
{
	// Add the style sheet

	HRESULT hr = S_OK;
	CComQIPtr<IVCProjectEngineImpl> spProjectEngineImpl = g_pProjectEngine;
	if (spProjectEngineImpl)
		hr = spProjectEngineImpl->CreateHiddenStyleSheet(m_bstrName, &pDisp);
	else
		hr = g_pProjectEngine->CreateStyleSheet(m_bstrName, &pDisp);
	CComQIPtr<VCStyleSheet> pStyleSheet = pDisp;
	RETURN_ON_FAIL_OR_NULL2(hr, pStyleSheet, E_NOINTERFACE);

	int cPlatforms = 0;
	for (int idx = 1; idx < cNumRecs; idx++)
	{	// MUST have one and only one platform name attribute somewhere; added way down below
		if (aNodeInfo[idx]->dwType == XML_ATTRIBUTE)
		{
			if (wcsncmp(L"PlatformName", aNodeInfo[idx]->pwcText, aNodeInfo[idx]->ulLen) == 0)
				cPlatforms++;
		}
	}
	if (cPlatforms < 1)
	{
		CComQIPtr<IVCProjectEngineImpl> spProjectEngineImpl = g_pProjectEngine;
		if (spProjectEngineImpl)
			spProjectEngineImpl->UnloadStyleSheet(pDisp);
		return CVCProjectEngine::DoSetErrorInfo(VCPROJ_E_BAD_PROJ_FILE, IDS_ERR_BAD_STYLE_FILE);
	}
	// set the root
	m_pRoot = pDisp;

	return S_OK;
}


HRESULT CVCNodeFactory::HandleGlobalNode(PVOID pNodeParent, USHORT cNumRecs, XML_NODE_INFO __RPC_FAR ** aNodeInfo, 
	CComPtr<IDispatch>& pDisp, USHORT& i)
{
	// Add a global to the collection

	// get the collection (parent node had better be the project!)
	CComQIPtr<IVCProjectImpl> pProjImpl = static_cast<IDispatch*>(pNodeParent);
	VSASSERT( pProjImpl, "Parent of Globals node is not the Project node!" );
	if( !pProjImpl )
		return CVCProjectEngine::DoSetErrorInfo(VCPROJ_E_NOT_FOUND, IDS_ERR_PROJ_NODE_NOT_FOUND);
	CComPtr<IVCGlobals> pGlobals;
	HRESULT hr = pProjImpl->GetGlobals( &pGlobals );
	RETURN_ON_FAIL_OR_NULL(hr, pGlobals);

	// there had better be just two attributes, Name and Value

	// get the name/value
	CComBSTR bstrName, bstrValue;
	for( ; i < cNumRecs; i++ )
	{
		// type?
		switch( aNodeInfo[i]->dwType )
		{
		case XML_ATTRIBUTE:
		{
			CComBSTR bstrAttrName, bstrAttrValue;
			CollectAttributeNameAndValue(cNumRecs, aNodeInfo, i, bstrAttrName, bstrAttrValue);

			// is this the global's Name?
			if( wcscmp( bstrAttrName, L"Name" ) == 0 )
				bstrName = bstrAttrValue;
			// is this the global's Value?
			else if( wcscmp( bstrAttrName, L"Value" ) == 0 )
				bstrValue = bstrAttrValue;

			break;
		}
		case XML_PCDATA:
			// shouldn't ever get here: the data elements ought to be handled
			// in the XML_ATTRIBUTE case above
			VSASSERT( FALSE, "VC XML Reader: XML_PCDATA nodes ought never be reached here!" );
			return CVCProjectEngine::DoSetErrorInfo(VCPROJ_E_BAD_PROJ_FILE, IDS_ERR_BAD_PROJ_FILE);
		default:
			// ignore the node data we don't care about
			break;
		}
	}
	// set the name/value
	pGlobals->SetValue( bstrName, bstrValue );
	pGlobals->SetPersistance( bstrName, VARIANT_TRUE );

	return S_OK;
}

HRESULT CVCNodeFactory::HandleXMLHeaderNode(USHORT cNumRecs, XML_NODE_INFO __RPC_FAR ** aNodeInfo)
{
	for (USHORT i = 0; i < cNumRecs; i++)
	{
		// type?
		switch( aNodeInfo[i]->dwType )
		{
		case XML_ATTRIBUTE:
		{
			CComBSTR bstrAttrName, bstrAttrValue;
			CollectAttributeNameAndValue(cNumRecs, aNodeInfo, i, bstrAttrName, bstrAttrValue);

			// is this the encoding attribute?
			if( wcsicmp( bstrAttrName, L"encoding" ) == 0 )
				m_bstrEncoding = bstrAttrValue;

			break;
		}
		case XML_PCDATA:
			// shouldn't ever get here: the data elements ought to be handled
			// in the XML_ATTRIBUTE case above
			VSASSERT( FALSE, "VC XML Reader: XML_PCDATA nodes ought never be reached here!" );
			return CVCProjectEngine::DoSetErrorInfo(VCPROJ_E_BAD_PROJ_FILE, IDS_ERR_BAD_PROJ_FILE);
		default:
			// ignore the node data we don't care about
			break;
		}
	}
	return S_OK;
}

void CVCNodeFactory::CollectAttributeNameAndValue(USHORT cNumRecs, XML_NODE_INFO __RPC_FAR ** aNodeInfo, USHORT& i, 
	CComBSTR& bstrAttrName, CComBSTR& bstrAttrValue)
{
	// aNodeInfo[i]->pwcText is the attribute name
	bstrAttrName = CComBSTR( aNodeInfo[i]->ulLen, aNodeInfo[i]->pwcText );

	if( (i+1) >= cNumRecs || aNodeInfo[i+1]->dwType != XML_PCDATA )
		bstrAttrValue = CComBSTR( L"" );
	else
	{
		// keep going through XML_PCDATA nodes until there aren't
		// any more, and appending their data strings
		CComBSTR bstrVal( L"" );
		while( (i+1) < cNumRecs && aNodeInfo[i+1]->dwType == XML_PCDATA )
		{
			bstrVal += CComBSTR( aNodeInfo[i+1]->ulLen, aNodeInfo[i+1]->pwcText );
			i++;
		}
		bstrAttrValue = bstrVal;
	}
}

HRESULT CVCNodeFactory::HandleProjectNode(USHORT cNumRecs, XML_NODE_INFO __RPC_FAR ** aNodeInfo, CComPtr<IDispatch>& pDisp, USHORT& i)
{
	HRESULT hr = g_pProjectEngine->CreateProject( m_bstrName, &pDisp );
	CComQIPtr<VCProject> pProject = pDisp;
	RETURN_ON_FAIL_OR_NULL2(hr, pProject, E_NOINTERFACE);
	m_pRoot = pDisp;

	bool bHandledVersion = false;
	// set this object's properties from the attribute list given
	for( ; i < cNumRecs; i++ )
	{
		// type?
		switch( aNodeInfo[i]->dwType )
		{
		case XML_ELEMENT:
			if( pDisp )
				// return the dispatch pointer in the node info structure
				aNodeInfo[i]->pNode = (void*)pDisp;
			else
				aNodeInfo[i]->pNode = NULL;
			break;
		case XML_ATTRIBUTE:
		{
			CComBSTR bstrName, bstrVal;
			CollectAttributeNameAndValue(cNumRecs, aNodeInfo, i, bstrName, bstrVal);

			if (wcscmp(bstrName, L"Version") == 0)
			{
				bHandledVersion = true;
				CStringA strVersionA = bstrVal;	// yes, ANSI
				double fVersion = atof(strVersionA);
				if (fVersion != 7.0)
				{
					CComQIPtr<IVCProjectEngineImpl> spProjEngineImpl = g_pProjectEngine;
					if (spProjEngineImpl)
					{
						CStringW strErr;
						strErr.Format(IDS_PROJ_UP_VERSION, bstrVal);
						CComBSTR bstrErr = strErr;
						spProjEngineImpl->DoFireReportError(bstrErr, E_FAIL, NULL);
					}
					return E_FAIL;
				}
			}
			else
			{
				CComVariant varArg = bstrVal;

				// file configs won't have a parent dispatch pointer set, 
				// all other nodes should
				if( pDisp )
				{
					CComDispatchDriver dispDriver( pDisp );
					hr = dispDriver.PutPropertyByName( bstrName, &varArg );
				}
			}

			break;
		}
		case XML_PCDATA:
			// shouldn't ever get here: the data elements ought to be handled
			// in the XML_ATTRIBUTE case above
			VSASSERT( FALSE, "VC XML Reader: XML_PCDATA nodes ought never be reached here!" );
			return CVCProjectEngine::DoSetErrorInfo(VCPROJ_E_BAD_PROJ_FILE, IDS_ERR_BAD_PROJ_FILE);
		default:
			// ignore the node data we don't care about
			break;
		}
	}
	
	if (!bHandledVersion)
	{
		CComQIPtr<IVCProjectEngineImpl> spProjEngineImpl = g_pProjectEngine;
		if (spProjEngineImpl)
		{
			CComBSTR bstrErr;
			bstrErr.LoadString(IDS_NO_PROJ_VERSION);
			spProjEngineImpl->DoFireReportError(bstrErr, E_FAIL, NULL);
		}
		return E_FAIL;
	}

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\vcpb\VCNodeFactory.h ===
// VCNodeFactory.h : Declaration of the CVCNodeFactory

#ifndef __VCNODEFACTORY_H_
#define __VCNODEFACTORY_H_

#include "stdafx.h"

/////////////////////////////////////////////////////////////////////////////
// CVCNodeFactory
class ATL_NO_VTABLE CVCNodeFactory: 
	public CComObjectRoot,
	public CComCoClass<CVCNodeFactory, &CLSID_VCNodeFactory>,
	IVCNodeFactory,
	IXMLNodeFactory
{
public:
	CVCNodeFactory();
	~CVCNodeFactory();

	static HRESULT CreateInstance( IVCNodeFactory **ppNodeFactory );

DECLARE_NO_REGISTRY()

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CVCNodeFactory)
	COM_INTERFACE_ENTRY(IVCNodeFactory)
	COM_INTERFACE_ENTRY(IXMLNodeFactory)
END_COM_MAP()

// IVCNodeFactory
public:
	STDMETHOD(put_Name)( BSTR bstrName );
	STDMETHOD(get_Root)( IDispatch **ppDisp );
	STDMETHOD(get_FileEncoding)( BSTR* pbstrEncoding );

// IXMLNodeFactory
public:
    STDMETHOD(NotifyEvent)( IXMLNodeSource* pSource, XML_NODEFACTORY_EVENT iEvt );
    STDMETHOD(BeginChildren)( IXMLNodeSource* pSource, XML_NODE_INFO* pNodeInfo );   
    STDMETHOD(EndChildren)( IXMLNodeSource* pSource, BOOL fEmpty, XML_NODE_INFO* pNodeInfo );
    STDMETHOD(Error)( IXMLNodeSource* pSource, HRESULT hrErrorCode, USHORT cNumRecs, XML_NODE_INFO __RPC_FAR **aNodeInfo );
    STDMETHOD(CreateNode)( IXMLNodeSource __RPC_FAR *pSource, PVOID pNodeParent, USHORT cNumRecs, XML_NODE_INFO __RPC_FAR **aNodeInfo );

// helper functions
protected:
	HRESULT HandleFileNode(PVOID pNodeParent, USHORT cNumRecs, XML_NODE_INFO __RPC_FAR ** aNodeInfo, CComPtr<IDispatch>& pDisp);
	HRESULT HandleFilterNode(PVOID pNodeParent, USHORT cNumRecs, XML_NODE_INFO __RPC_FAR ** aNodeInfo, CComPtr<IDispatch>& pDisp);
	HRESULT HandleToolNode(PVOID pNodeParent, USHORT cNumRecs, XML_NODE_INFO __RPC_FAR ** aNodeInfo, CComPtr<IDispatch>& pDisp);
	HRESULT HandleProjConfigNode(PVOID pNodeParent, USHORT cNumRecs, XML_NODE_INFO __RPC_FAR ** aNodeInfo, CComPtr<IDispatch>& pDisp);
	HRESULT HandleFileConfigNode(PVOID pNodeParent, USHORT cNumRecs, XML_NODE_INFO __RPC_FAR ** aNodeInfo, CComPtr<IDispatch>& pDisp);
	HRESULT HandlePlatformNode(PVOID pNodeParent, USHORT cNumRecs, XML_NODE_INFO __RPC_FAR ** aNodeInfo, CComPtr<IDispatch>& pDisp);
	HRESULT HandleProjectNode(USHORT cNumRecs, XML_NODE_INFO __RPC_FAR ** aNodeInfo, CComPtr<IDispatch>& pDisp, USHORT& i);
	HRESULT HandleStyleSheetNode(PVOID pNodeParent, USHORT cNumRecs, XML_NODE_INFO __RPC_FAR ** aNodeInfo, CComPtr<IDispatch>& pDisp);
	HRESULT HandleGlobalNode(PVOID pNodeParent, USHORT cNumRecs, XML_NODE_INFO __RPC_FAR ** aNodeInfo, CComPtr<IDispatch>& pDisp, USHORT& i);
	HRESULT ValidateTagAndGetName(USHORT cNumRecs, XML_NODE_INFO __RPC_FAR ** aNodeInfo, LPCOLESTR szAttribName, CComBSTR& bstrName);
	HRESULT HandleXMLHeaderNode(USHORT cNumRecs, XML_NODE_INFO __RPC_FAR ** aNodeInfo);
	void CollectAttributeNameAndValue(USHORT cNumRecs, XML_NODE_INFO __RPC_FAR ** aNodeInfo, USHORT& i, CComBSTR& bstrAttrName, 
		CComBSTR& bstrAttrValue);

private:
	CComBSTR m_bstrName;
	CComBSTR m_bstrEncoding;
	CComPtr<IDispatch> m_pRoot;
};

#endif // __VCNODEFACTORY_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\vcpb\vcpbengcp.h ===
#ifndef __VcpbengCP_H_
#define __VcpbengCP_H_

template <class T, const IID* piid>
class CProxy_IVCProjectEngineEvents : public IConnectionPointImpl<T, piid, CComDynamicUnkArray>
{
	//Warning this class will  be regenerated by the wizard.
public:
	void Fire_OnItemAdded( IDispatch *pItem, IDispatch *pItemParent )
	{
		int nConnections = m_vec.GetSize();
		if( nConnections )
		{
			T* pT = static_cast<T*>(this);
			int nConnectionIndex;

			for( nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++ )
			{
				pT->Lock();
				CComPtr<IUnknown> sp = m_vec.GetAt( nConnectionIndex );
				pT->Unlock();
				CComQIPtr<IVCProjectEngineEvents> p = sp;
				if( p )
				{
					p->ItemAdded( pItem, pItemParent );
				}
				else
				{
					CComQIPtr<IDispatch> pDisp = reinterpret_cast<IDispatch*>(sp.p);
					if( pDisp )
					{
						CComDispatchDriver disp( pDisp );
						CComVariant varItem( pItem );
						CComVariant varItemParent( pItemParent );
						disp.Invoke2( ENGEVENTID_ItemAdded, &varItem, &varItemParent );
					}
				}
			}
		}
	}

	void Fire_OnItemRemoved( IDispatch *pItem, IDispatch *pItemParent )  
	{
		int nConnections = m_vec.GetSize();
		if( nConnections )
		{
			T* pT = static_cast<T*>(this);
			int nConnectionIndex;

			for( nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++ ) 
			{
				pT->Lock();
				CComPtr<IUnknown> sp = m_vec.GetAt( nConnectionIndex );
				pT->Unlock();

				CComQIPtr<IVCProjectEngineEvents> p = sp;
				if( p )
				{
					p->ItemRemoved( pItem, pItemParent );
				}
				else
				{
					CComQIPtr<IDispatch> pDisp = reinterpret_cast<IDispatch*>(sp.p);
					if( pDisp )
					{
						CComDispatchDriver disp( pDisp );
						CComVariant varItem( pItem );
						CComVariant varItemParent( pItemParent );
						disp.Invoke2( ENGEVENTID_ItemRemoved, &varItem, &varItemParent );
					}
				}
			}
		}
	}


	void Fire_OnItemRenamed( IDispatch *pItem, IDispatch *pItemParent, BSTR bstrOldName )
	{
		int nConnections = m_vec.GetSize();
		if( nConnections )
		{
			T* pT = static_cast<T*>(this);
			int nConnectionIndex;

			for( nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++ )
			{
				pT->Lock();
				CComPtr<IUnknown> sp = m_vec.GetAt( nConnectionIndex );
				pT->Unlock();

				CComQIPtr<IVCProjectEngineEvents> p = sp;
				if( p )
				{
					p->ItemRenamed( pItem, pItemParent, bstrOldName );
				}
				else
				{
					CComQIPtr<IDispatch> pDisp = reinterpret_cast<IDispatch*>(sp.p);
					if( pDisp )
					{
						CComDispatchDriver disp( pDisp );
						CComVariant varArgs[3];
						varArgs[2] = pItem;
						varArgs[1] = pItemParent;
						varArgs[0] = bstrOldName;
						disp.InvokeN( ENGEVENTID_ItemRenamed, varArgs, 3 );
					}
				}
			}
		}
	}


	void Fire_OnItemMoved( IDispatch *pItem, IDispatch *pNewParent, IDispatch* pOldParent )
	{
		int nConnections = m_vec.GetSize();
		if( nConnections )
		{
			T* pT = static_cast<T*>(this);
			int nConnectionIndex;

			for( nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++ )
			{
				pT->Lock();
				CComPtr<IUnknown> sp = m_vec.GetAt( nConnectionIndex );
				pT->Unlock();

				CComQIPtr<IVCProjectEngineEvents> p = sp;
				if( p )
				{
					p->ItemMoved( pItem, pNewParent, pOldParent );
				}
				else
				{
					CComQIPtr<IDispatch> pDisp = reinterpret_cast<IDispatch*>(sp.p);
					if( pDisp )
					{
						CComDispatchDriver disp( pDisp );
						CComVariant varArgs[3];
						varArgs[2] = pItem;
						varArgs[1] = pNewParent;
						varArgs[0] = pOldParent;
						disp.InvokeN( ENGEVENTID_ItemMoved, varArgs, 3 );
					}
				}
			}
		}
	}


	void Fire_OnItemPropertyChange( IDispatch *pItem, long dispid )
	{
		int nConnections = m_vec.GetSize();
		if( nConnections )
		{
			T* pT = static_cast<T*>(this);
			int nConnectionIndex;

			for( nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++ )
			{
				pT->Lock();
				CComPtr<IUnknown> sp = m_vec.GetAt( nConnectionIndex );
				pT->Unlock();

				CComQIPtr<IVCProjectEngineEvents> p = sp;
				if( p )
				{
					p->ItemPropertyChange( pItem, dispid );
				}
				else
				{
					CComQIPtr<IDispatch> pDisp = reinterpret_cast<IDispatch*>(sp.p);
					if( pDisp )
					{
						CComDispatchDriver disp( pDisp );
						CComVariant varItem( pItem );
						CComVariant varDispid( dispid );
						disp.Invoke2( ENGEVENTID_ItemPropertyChange, &varItem, &varDispid );
					}
				}
			}
		}
	}

	void Fire_OnSccEvent( IDispatch* pItem, enumSccEvent event, VARIANT_BOOL *pRet )
	{
		if( pRet == NULL )
			return;

		if (event != eProjectInScc && (!PROJECT_IS_LOADED() || !STYLESHEET_IS_LOADED()))
			return;

		int nConnections = m_vec.GetSize();
		if( nConnections )
		{
			T* pT = static_cast<T*>(this);
			int nConnectionIndex;

			for( nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++ )
			{
				pT->Lock();
				CComPtr<IUnknown> sp = m_vec.GetAt( nConnectionIndex );
				pT->Unlock();
				CComQIPtr<IVCProjectEngineEvents> p = sp;
				if( p )
				{
					p->SccEvent( pItem, event, pRet );
				}
				else
				{
					CComQIPtr<IDispatch> pDisp = reinterpret_cast<IDispatch*>(sp.p);
					if( pDisp )
					{
						CComDispatchDriver disp( pDisp );
						CComVariant varItem;
						CComVariant varEvent;
						varItem = pItem;
						varEvent = event;
						disp.Invoke2( ENGEVENTID_SccEvent, &varItem, &varEvent );
					}
				}
			}
		}
	}

	void Fire_OnReportError( BSTR bstrErrMsg, HRESULT hrReport, BSTR bstrHelpKeyword )
	{
		int nConnections = m_vec.GetSize();
		if( nConnections )
		{
			T* pT = static_cast<T*>(this);
			int nConnectionIndex;

			for( nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++ )
			{
				pT->Lock();
				CComPtr<IUnknown> sp = m_vec.GetAt( nConnectionIndex );
				pT->Unlock();

				CComQIPtr<IVCProjectEngineEvents> p = sp;
				if( p )
				{
					p->ReportError( bstrErrMsg, hrReport, bstrHelpKeyword );
				}
				else
				{
					CComQIPtr<IDispatch> pDisp = reinterpret_cast<IDispatch*>(sp.p);
					if( pDisp )
					{
						CComDispatchDriver disp( pDisp );
						CComVariant varArgs[3];
						varArgs[2] = bstrErrMsg;
						varArgs[1] = (SCODE)hrReport;
						varArgs[0] = bstrHelpKeyword;
						disp.InvokeN( ENGEVENTID_ReportError, varArgs, 3 );
					}
				}
			}
		}
	}

	void Fire_OnProjectBuildStarted( IDispatch *pCfg )
	{
		int nConnections = m_vec.GetSize();
		if( nConnections )
		{
			T* pT = static_cast<T*>(this);
			int nConnectionIndex;

			for( nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++ )
			{
				pT->Lock();
				CComPtr<IUnknown> sp = m_vec.GetAt( nConnectionIndex );
				pT->Unlock();

				CComQIPtr<IVCProjectEngineEvents> p = sp;
				if( p )
				{
					p->ProjectBuildStarted( pCfg );
				}
				else
				{
					CComQIPtr<IDispatch> pDisp = reinterpret_cast<IDispatch*>(sp.p);
					if( pDisp )
					{
						CComDispatchDriver disp( pDisp );
						CComVariant varCfg( pCfg );
						disp.Invoke1( ENGEVENTID_ProjectBuildStarted, &varCfg );
					}
				}
			}
		}
	}

	void Fire_OnProjectBuildFinished( IDispatch *pCfg, long errors, long warnings, VARIANT_BOOL bCancelled )
	{
		int nConnections = m_vec.GetSize();
		if( nConnections )
		{
			T* pT = static_cast<T*>(this);
			int nConnectionIndex;

			for( nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++ )
			{
				pT->Lock();
				CComPtr<IUnknown> sp = m_vec.GetAt( nConnectionIndex );
				pT->Unlock();

				CComQIPtr<IVCProjectEngineEvents> p = sp;
				if( p )
				{
					p->ProjectBuildFinished( pCfg, errors, warnings, bCancelled );
				}
				else
				{
					CComQIPtr<IDispatch> pDisp = reinterpret_cast<IDispatch*>(sp.p);
					if( pDisp )
					{
						CComDispatchDriver disp( pDisp );
						CComVariant rgVars[4];
						rgVars[3] = pCfg;
						rgVars[2] = errors;
						rgVars[1] = warnings;
						rgVars[0] = bCancelled;
						disp.InvokeN( ENGEVENTID_ProjectBuildFinished, rgVars, 4 );
					}
				}
			}
		}
	}
};
#endif	//  __VcpbengCP_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\vcpb\vcpb.cpp ===
// vcpb.cpp : Implementation of DLL Exports.

// Note: Proxy/Stub Information
//	To build a separate proxy/stub DLL, 
//	run nmake -f vcpbps.mk in the project directory.

#include "stdafx.h"
#include "VCProjectEngine.h"

#include "configuration.h"
#include "fileconfiguration.h"

#include "platform.h"
#include "PlatformXbox.h"

#include "debugsettings.h"

#include "SettingsPage.h"

#include "VCNodeFactory.h"
#include "XMLFile.h"

#include "profile.h"
#include "register.h"
#include "util2.h"

static LPOLESTR g_wszAlternateRegistryRoot = NULL;

// Declare the settings dialog pages ...

// Compiler
typedef CSettingsPage<&CLSID_ClGeneral,IDS_ClGeneral,IDS_Cl> CClGeneral;
typedef CSettingsPage<&CLSID_ClOptimization,IDS_ClOptimization,IDS_Cl> CClOptimization;
typedef CSettingsPage<&CLSID_ClPreprocessor,IDS_ClPreprocessor,IDS_Cl> CClPreprocessor;
typedef CSettingsPage<&CLSID_ClAdvanced,IDS_ClAdvanced,IDS_Cl> CClAdvanced;
typedef CSettingsPage<&CLSID_ClCodeGeneration,IDS_ClCodeGeneration,IDS_Cl> CClCodeGeneration;
typedef CSettingsPage<&CLSID_ClLanguage,IDS_ClLanguage,IDS_Cl> CClLanguage;
typedef CSettingsPage<&CLSID_ClPrecompiledHeaders,IDS_ClPrecompiledHeaders,IDS_Cl> CClPrecompiledHeaders;
typedef CSettingsPage<&CLSID_ClOutputFiles,IDS_ClOutputFiles,IDS_Cl> CClOutputFiles;
typedef CSettingsPage<&CLSID_ClBrowseInfo,IDS_ClBrowseInfo,IDS_Cl> CClBrowseInfo;
typedef CAdditionalOptionsPage<VCCLCompilerTool, &CLSID_ClAdditionalOptions,IDS_Cl, VCCLID_AdditionalOptions> CClAdditionalOptions;

// Midl
typedef CSettingsPage<&CLSID_MidlAdvanced,IDS_MidlAdvanced,IDS_Midl> CMidlAdvanced;
typedef CSettingsPage<&CLSID_MidlOutput,IDS_MidlOutput,IDS_Midl> CMidlOutput;
typedef CSettingsPage<&CLSID_MidlGeneral,IDS_MidlGeneral,IDS_Midl> CMidlGeneral;
typedef CAdditionalOptionsPage<VCMidlTool, &CLSID_MidlAdditionalOptions,IDS_Midl, VCMIDLID_AdditionalOptions> CMidlAdditionalOptions;

// RC
typedef CSettingsPage<&CLSID_RCGeneral,IDS_RCGeneral,IDS_RC> CRCGeneral;
typedef CAdditionalOptionsPage<VCResourceCompilerTool, &CLSID_RCAdditionalOptions,IDS_RC, VCRCID_AdditionalOptions> CRCAdditionalOptions;

// Build events
typedef CSettingsPage<&CLSID_VCPreBldGeneral, IDS_PreBuildEvent, IDS_BldEvents> CPreBldEventGeneral;
typedef CSettingsPage<&CLSID_VCPreLinkGeneral, IDS_PreLinkEvent, IDS_BldEvents> CPreLinkEventGeneral;
typedef CSettingsPage<&CLSID_VCPostBldGeneral, IDS_PostBuildEvent, IDS_BldEvents> CPostBldEventGeneral;
typedef CSettingsPage<&CLSID_VCCustomGeneral, IDS_CustomGeneral, IDS_CustomBuild> CCustomBuildGeneral;
// typedef CSettingsPage<&CLSID_VCCustomGeneral, IDS_CustomOutputs, IDS_CustomBuild, 0,szCustomBuildToolType> CCustomBuildOutputs;

// BSC
typedef CSettingsPage<&CLSID_VCBSCGeneral,IDS_BSCGeneral,IDS_BSC> CBSCGeneral;
typedef CAdditionalOptionsPage<VCBscMakeTool, &CLSID_BSCAdditionalOptions,IDS_BSC, VCBSCID_AdditionalOptions> CBSCAdditionalOptions;

// Lib
typedef CSettingsPage<&CLSID_LibGeneral,IDS_LibGeneral,IDS_Lib> CLibGeneral;
typedef CAdditionalOptionsPage<VCLibrarianTool, &CLSID_LibAdditionalOptions,IDS_Lib,VCLIBID_AdditionalOptions> CLibAdditionalOptions;

// Linker
typedef CSettingsPage<&CLSID_LinkGeneral,IDS_LinkGeneral,IDS_Link> CLinkGeneral;
typedef CSettingsPage<&CLSID_LinkInput,IDS_LinkInput,IDS_Link> CLinkInput;
typedef CSettingsPage<&CLSID_LinkDebug,IDS_LinkDebug,IDS_Link> CLinkDebug;
typedef CSettingsPage<&CLSID_LinkSystem,IDS_LinkSystem,IDS_Link> CLinkSystem;
typedef CSettingsPage<&CLSID_LinkOptimization,IDS_LinkOptimization,IDS_Link> CLinkOptimization;
typedef CSettingsPage<&CLSID_LinkAdvanced,IDS_LinkAdvanced,IDS_Link> CLinkAdvanced;
typedef CSettingsPage<&CLSID_LinkMIDL,IDS_LinkMIDL,IDS_Link> CLinkMIDL;
typedef CAdditionalOptionsPage<VCLinkerTool, &CLSID_LinkAdditionalOptions, IDS_Link, VCLINKID_AdditionalOptions> CLinkAdditionalOptions;

// NMake
typedef CSettingsPage<&CLSID_VCNMakeGeneral, IDS_NMake, NULL> CNMakeGeneral;

// Web Service Proxy Generator
typedef CSettingsPage<&CLSID_WebUtilityGeneral, IDS_WebGeneral, IDS_WEBTOOL> CWebUtilityGeneral;
typedef CAdditionalOptionsPage<VCWebServiceProxyGeneratorTool, &CLSID_WebAdditionalOptions,IDS_WEBTOOL, VCWEBID_AdditionalOptions> CWebAdditionalOptions;

// Web Deployment
typedef CSettingsPage<&CLSID_WebDeploymentGeneral, IDS_DeployGeneral, IDS_DEPLOYTOOL> CWebDeployGeneral;

// Xbox Deployment
typedef CSettingsPage<&CLSID_XboxDeploymentGeneral, IDS_XboxDeployGeneral, IDS_XBOXDEPLOYTOOL> CXboxDeployGeneral;

// Xbox Image
typedef CSettingsPage<&CLSID_XboxImageGeneral, IDS_XboxImageGeneral, IDS_XBOXIMAGETOOL> CXboxImageGeneral;
typedef CSettingsPage<&CLSID_XboxImageCertificate, IDS_XboxImageCertificate, IDS_XBOXIMAGETOOL> CXboxImageCertificate;
typedef CSettingsPage<&CLSID_XboxImageTitleInfo, IDS_XboxImageTitleInfo, IDS_XBOXIMAGETOOL> CXboxImageTitleInfo;

// Config General
typedef CSettingsPage<&CLSID_GeneralFileConfigSettingsPage, IDS_GeneralConfigSettings, 0> CGeneralFileConfigSettingsPage;

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
	OBJECT_ENTRY(CLSID_VCProjectEngineObject, CVCProjectEngine)
	OBJECT_ENTRY(CLSID_VCPlatformWin32, CPlatformWin32)
	OBJECT_ENTRY(CLSID_VCPlatformWin64, CPlatformWin64)
	OBJECT_ENTRY(CLSID_VCPlatformXbox, CPlatformXbox)
	OBJECT_ENTRY(CLSID_VCNodeFactory, CVCNodeFactory)

	OBJECT_ENTRY(CLSID__VCDebugSettings, CDebugSettings)
	OBJECT_ENTRY(CLSID_DebugSettingsPage, CDbgSettingsPage)
	OBJECT_ENTRY(CLSID_GeneralConfigSettingsPage, CGeneralConfigSettingsPage)
	OBJECT_ENTRY(CLSID_GeneralFileConfigSettingsPage, CGeneralFileConfigSettingsPage)

#ifdef AARDVARK
	OBJECT_ENTRY(CLSID_GeneralStyleSheetSettings, CGeneralStyleSheetSettings)
#endif	// AARDVARK

	// Compiler
	OBJECT_ENTRY(CLSID_ClGeneral, CClGeneral)
	OBJECT_ENTRY(CLSID_ClOptimization, CClOptimization)
	OBJECT_ENTRY(CLSID_ClPreprocessor, CClPreprocessor)
	OBJECT_ENTRY(CLSID_ClAdvanced, CClAdvanced)
	OBJECT_ENTRY(CLSID_ClCodeGeneration, CClCodeGeneration)
	OBJECT_ENTRY(CLSID_ClLanguage, CClLanguage)
	OBJECT_ENTRY(CLSID_ClPrecompiledHeaders, CClPrecompiledHeaders)
	OBJECT_ENTRY(CLSID_ClOutputFiles, CClOutputFiles)
	OBJECT_ENTRY(CLSID_ClBrowseInfo, CClBrowseInfo)
	OBJECT_ENTRY(CLSID_ClAdditionalOptions, CClAdditionalOptions)

	// MIDL
	OBJECT_ENTRY(CLSID_MidlAdvanced, CMidlAdvanced)
	OBJECT_ENTRY(CLSID_MidlOutput, CMidlOutput)
	OBJECT_ENTRY(CLSID_MidlGeneral, CMidlGeneral)
	OBJECT_ENTRY(CLSID_MidlAdditionalOptions, CMidlAdditionalOptions)

	// RC
	OBJECT_ENTRY(CLSID_RCGeneral, CRCGeneral)
	OBJECT_ENTRY(CLSID_RCAdditionalOptions, CRCAdditionalOptions)

	// BSC
	OBJECT_ENTRY(CLSID_VCBSCGeneral, CBSCGeneral)
	OBJECT_ENTRY(CLSID_BSCAdditionalOptions, CBSCAdditionalOptions)

	// Lib
	OBJECT_ENTRY(CLSID_LibGeneral, CLibGeneral)
	OBJECT_ENTRY(CLSID_LibAdditionalOptions, CLibAdditionalOptions)

	// Link
	OBJECT_ENTRY(CLSID_LinkMIDL, CLinkMIDL)
	OBJECT_ENTRY(CLSID_LinkGeneral, CLinkGeneral)
	OBJECT_ENTRY(CLSID_LinkInput, CLinkInput)
	OBJECT_ENTRY(CLSID_LinkDebug, CLinkDebug)
	OBJECT_ENTRY(CLSID_LinkSystem, CLinkSystem)
	OBJECT_ENTRY(CLSID_LinkOptimization, CLinkOptimization)
	OBJECT_ENTRY(CLSID_LinkAdvanced, CLinkAdvanced)
	OBJECT_ENTRY(CLSID_LinkAdditionalOptions, CLinkAdditionalOptions)
	
	// Custom build
	OBJECT_ENTRY(CLSID_VCCustomGeneral, CCustomBuildGeneral)
	
	// Build events
	OBJECT_ENTRY(CLSID_VCPreBldGeneral, CPreBldEventGeneral)
	OBJECT_ENTRY(CLSID_VCPreLinkGeneral, CPreLinkEventGeneral)
	OBJECT_ENTRY(CLSID_VCPostBldGeneral, CPostBldEventGeneral)

	// NMake 
	OBJECT_ENTRY(CLSID_VCNMakeGeneral, CNMakeGeneral)

	// Web Service Proxy Generator
	OBJECT_ENTRY(CLSID_WebUtilityGeneral, CWebUtilityGeneral)
	OBJECT_ENTRY(CLSID_WebAdditionalOptions, CWebAdditionalOptions)

	// Web Deployment
	OBJECT_ENTRY(CLSID_WebDeploymentGeneral, CWebDeployGeneral)

	// Xbox Deployment
	OBJECT_ENTRY(CLSID_XboxDeploymentGeneral, CXboxDeployGeneral)

	// Xbox Image
	OBJECT_ENTRY(CLSID_XboxImageGeneral, CXboxImageGeneral)
	OBJECT_ENTRY(CLSID_XboxImageCertificate, CXboxImageCertificate)
	OBJECT_ENTRY(CLSID_XboxImageTitleInfo, CXboxImageTitleInfo)
END_OBJECT_MAP()





/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point
extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
#ifdef DEBUG
#endif
	return _Module.DllMain(hInstance, dwReason, lpReserved, ObjectMap, &LIBID_VCProjectEngineLibrary); 
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE
STDAPI DllCanUnloadNow(void)
{
	return _Module.DllCanUnloadNow();
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type
STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
	return _Module.DllGetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// VSDllRegisterServer - Adds entries to the system registry

_ATL_REGMAP_ENTRY g_rm[] = {
	{L"EXEPATH", NULL },
	{L"LIB", NULL },
	{L"INCLUDE", NULL },
	{L"SOURCE", NULL },
	{L"HHPATH", NULL },
	{L"PATHENV", NULL },
	{L"REGROOTBEGIN",NULL },
	{L"REGROOTEND", NULL },
	{L"XDK", NULL },
	{0,0}
};

wchar_t szVsProductDir[MAX_PATH+1] = {0};
CComBSTR bstrPath;
CComBSTR bstrWin;
CComBSTR bstrHhcDir;

CComBSTR bstrRootBegin;
CComBSTR bstrRootEnd;
CComBSTR bstrExePath;
CComBSTR bstrLib;
CComBSTR bstrInclude;
CComBSTR bstrSource;
CComBSTR bstrXDK;

static void SetupMap()
{
	// setup paths in registry
	LONG lRet;
	DWORD nType = REG_SZ;
	DWORD nSize = MAX_PATH;
	HKEY hSectionKey = NULL;

	// get the VS product directory
	CStringW strKey = g_wszAlternateRegistryRoot;
	strKey += L"\\Setup\\VS";
	lRet = RegOpenKeyExW( HKEY_LOCAL_MACHINE, strKey, 0, KEY_READ, &hSectionKey );
	if( hSectionKey )
	{
		lRet = RegQueryValueExW( hSectionKey, L"ProductDir", NULL, &nType, (LPBYTE)szVsProductDir, &nSize );
		RegCloseKey( hSectionKey );
	}

	// figure out where the help compiler is
	bstrHhcDir = szVsProductDir;
	int nLen = bstrHhcDir.Length();
	if (nLen > 0 && bstrHhcDir[nLen-1] != L'\\')
		bstrHhcDir += L'\\';
	bstrHhcDir += L"Visual Studio SDKs\\HTML Help 1.3 SDK\\workshop";

	// append the path for this process
	VCGetEnvironmentVariableW(L"Path", &bstrPath);

	// get the windows directory
	char szWin[2048];
	int rval = GetWindowsDirectoryA(szWin, 2047);
	if( rval )
	{
	    bstrWin = szWin;
	    bstrWin += L"\\";
	}

	// The VC_RealSetup Key should be set only if you are trying to reg the project system after the fact on a
	// real install. Otherwise its not going to be set.
	CComBSTR bstrRealSetup;
	HRESULT hr = ::VCGetEnvironmentVariableW(L"VC_REALSETUP", &bstrRealSetup);
	if( hr != S_OK ) // Batch setup.
	{
	    bstrExePath = L"$(VCInstallDir)bin;$(VSInstallDir)Common7\\Tools;$(VSInstallDir);";
		bstrExePath += L"$(FrameworkDir)$(FrameworkVersion);$(FrameworkSDKDir);";
// 	    bstrExePath += bstrPath;
    
		bstrLib = L"$(VCInstallDir)lib;$(VCInstallDir)atlmfc\\lib;$(FrameworkSDKDir)lib";

		bstrInclude = L"$(VCInstallDir)include;$(VCInstallDir)atlmfc\\include;$(FrameworkSDKDir)include";

		bstrSource = L"$(VCInstallDir)atlmfc\\src\\mfc;$(VCInstallDir)atlmfc\\src\\atl;$(VCInstallDir)crt\\src";
	}
	else  // REAL SETUP USES MANY DIFFERENT PATHS.
	{
		bstrExePath = L"$(VCInstallDir)bin;$(VSInstallDir)Common7\\Tools\\bin\\prerelease;";
		bstrExePath += L"$(VSInstallDir)Common7\\Tools\\bin;$(VSInstallDir)Common7\\Tools;";
		bstrExePath += L"$(VSInstallDir)Common7\\ide;";
	    bstrExePath += bstrHhcDir;
	    bstrExePath +=";$(FrameworkSDKDir)bin;$(FrameworkDir)$(FrameworkVersion);";
// 	    bstrExePath += bstrPath;

		bstrLib = L"$(VCInstallDir)lib;$(VCInstallDir)atlmfc\\lib;$(VCInstallDir)PlatformSDK\\lib\\prerelease;";
	    bstrLib += L"$(VCInstallDir)PlatformSDK\\lib;$(FrameworkSDKDir)lib";

		bstrInclude = L"$(VCInstallDir)include;$(VCInstallDir)atlmfc\\include;";
		bstrInclude += L"$(VCInstallDir)PlatformSDK\\include\\prerelease;$(VCInstallDir)PlatformSDK\\include;";
	    bstrInclude += L"$(FrameworkSDKDir)include";
	    
		bstrSource = L"$(VCInstallDir)atlmfc\\src\\mfc;$(VCInstallDir)atlmfc\\src\\atl;$(VCInstallDir)crt\\src";
	}

	// Get The registry strings for the VS registry root.
	HRESULT chr = GetRegRootStrings( g_wszAlternateRegistryRoot, &bstrRootBegin, &bstrRootEnd );

	// Get the root of the XDK
	VCGetEnvironmentVariableW(L"XDK", &bstrXDK);

	// now fill up everything.
	g_rm[0].szData = bstrExePath.m_str;
	g_rm[1].szData = bstrLib.m_str;
	g_rm[2].szData = bstrInclude.m_str;
	g_rm[3].szData = bstrSource.m_str;
	g_rm[4].szData = bstrHhcDir.m_str;
	g_rm[5].szData = bstrPath.m_str;
	g_rm[6].szData = bstrRootBegin.m_str;
	g_rm[7].szData = bstrRootEnd.m_str;
	g_rm[8].szData = bstrXDK.m_str;
}

STDAPI VSDllRegisterServer(LPOLESTR wszAlternateRegistryRoot)
{
	if( wszAlternateRegistryRoot == NULL ) // Dovii NoProvii
		wszAlternateRegistryRoot = L"Software\\Microsoft\\VisualStudio\\7.0";

	// registers object, typelib and all interfaces in typelib
	g_wszAlternateRegistryRoot = wszAlternateRegistryRoot;

	SetupMap();

	HRESULT hr = _Module.DllRegisterServer();
	_Module.RegisterTypeLib(_T("\\2"));
	g_wszAlternateRegistryRoot = NULL;
	return hr;
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry
STDAPI DllRegisterServer(void)
{
	HRESULT hr= VSDllRegisterServer(L"Software\\Microsoft\\VisualStudio\\7.0");
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// VSDllUnregisterServer - Removes entries from the system registry

STDAPI VSDllUnregisterServer(LPOLESTR wszAlternateRegistryRoot)
{
	g_wszAlternateRegistryRoot = wszAlternateRegistryRoot;
	if( wszAlternateRegistryRoot == NULL )	// Dovii NoProvii
		wszAlternateRegistryRoot = L"Software\\Microsoft\\VisualStudio\\7.0";

	SetupMap();

	HRESULT hr = _Module.DllUnregisterServer();
	_Module.UnRegisterTypeLib(_T("\\2"));
	g_wszAlternateRegistryRoot = NULL;
	return hr;
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry
STDAPI DllUnregisterServer(void)
{
	HRESULT hr= VSDllUnregisterServer(L"Software\\Microsoft\\VisualStudio\\7.0");
	return hr;
}

extern "C" HRESULT __declspec(dllexport) DLLGetDocumentation( ITypeLib *ptlib, ITypeInfo *ptinfo, LCID lcid, DWORD dwHelpStringContext, BSTR *pbstrHelpString)
{
	CComBSTR bstrHelp;
	HRESULT hr = bstrHelp.LoadString(dwHelpStringContext);
	*pbstrHelpString = bstrHelp.Detach();
	return S_OK;
}

HRESULT OpenTopic(IVCProjectEngineImpl *pProjEngineImpl, BSTR bstrTopic)
{
	CComPtr<Help> pHlp;
	HRESULT hr = pProjEngineImpl->GetHelp(&pHlp);
	if( pHlp )
		hr = pHlp->DisplayTopicFromF1Keyword(bstrTopic);
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\vcpb\vcpbtools.cpp ===
// vcpbeng.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To merge the proxy/stub code into the object DLL, add the file 
//      dlldatax.c to the project.  Make sure precompiled headers 
//      are turned off for this file, and add _MERGE_PROXYSTUB to the 
//      defines for the project.  
//
//      If you are not running WinNT4.0 or Win95 with DCOM, then you
//      need to remove the following define from dlldatax.c
//      #define _WIN32_WINNT 0x0400
//
//      Further, if you are running MIDL without /Oicf switch, you also 
//      need to remove the following define from dlldatax.c.
//      #define USE_STUBLESS_PROXY
//
//      Modify the custom build rule for vcpbeng.idl by adding the following 
//      files to the Outputs.
//          vcpbeng_p.c
//          dlldata.c
//      To build a separate proxy/stub DLL, 
//      run nmake -f vcpbengps.mk in the project directory.

#include "stdafx.h"

#ifdef _MERGE_PROXYSTUB
extern "C" HINSTANCE hProxyDll;
#endif


_ATL_OBJMAP_ENTRY ObjectMap2[] = {
	// Base tools

END_OBJECT_MAP()
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\vcpb\VCProjectEngine.cpp ===
// VCProjectEngine.cpp : Implementation of CVCProjectEngine
#include "stdafx.h"
#include "VCProjectEngine.h"
#include "collection.h"

#include "project.h"
#include "regscan.h"
#include "scriptexecutor.h"
#include "buildengine.h"
#include "msgboxes2.h"
#include "profile.h"
#include "StyleSheet.h"
#include "register.h"
#include "VCNodeFactory.h"
#include "xmlfile.h"
#include "ConfigRecords.h"
#include "vsappid.h"
#include "MRDependencies.h"
#include "platform.h"

#include <fcntl.h>
#include <iads.h>

// Shell interface
interface CommandBars;
#include "dte.h"
#include <uilocale.h>
#include "helpsys.h"

// REVIEW: REMOVE THESE WHEN WE GET BETTER LINKAGE BETWEEN DLL'S
const IID 	IID_IVCProjConvert = {0x7D8AE8C4,0x3FD3,0x11D3,{0x8D,0x52,0x00,0xC0,0x4F,0x8E,0xCD,0xB6}};
const IID 	LIBID_VCPROJCNVTLib = {0xD43DAED2,0x3FCF,0x11D3,{0x8D,0x52,0x00,0xC0,0x4F,0x8E,0xCD,0xB6}};
const CLSID CLSID_VCProjConvert = {0x7D8AE8C5,0x3FD3,0x11D3,{0x8D,0x52,0x00,0xC0,0x4F,0x8E,0xCD,0xB6}};

#define LOCALHOST       L"LocalHost"  
#define LOCALHOST_CCH   9     // count of chars in LOCALHOST

// this symbol only for BBT, don't remove.
int ENDBOOT_i = 0;
extern "C" void ENDBOOT_vcpb(void) { ENDBOOT_i++; return; }

class CInLoadStyle
{
public:
	CInLoadStyle() { m_bOldInLoad = g_bInStyleLoad; g_bInStyleLoad = TRUE; }
	~CInLoadStyle() { g_bInStyleLoad = m_bOldInLoad; }
	BOOL m_bOldInLoad;
};

/////////////////////////////////////////////////////////////////////////////
// CVCProjectEngine

VARIANT_BOOL 			 CVCProjectEngine::s_bBuildLogging = VARIANT_TRUE;	// Do we log builds to a file?
IVCBuildPackageInternal* CVCProjectEngine::s_pBuildPackage = NULL;
CComPtr<IServiceProvider> CVCProjectEngine::s_pServiceProvider = NULL;
HANDLE 					 CVCProjectEngine::s_hLogFile = NULL;
CComBSTR                 CVCProjectEngine::s_bstrAlternateRegistryRoot = L"";
BOOL                     CVCProjectEngine::s_fInitializedCom = FALSE;
CComPtr<IMultiLanguage2> CVCProjectEngine::s_spMultiLanguage2 = NULL;
CComPtr<IMultiLanguage> CVCProjectEngine::s_spMultiLanguage = NULL;
CComBSTR				CVCProjectEngine::s_bstrIISRoot = L"";
CComPtr<IMSAdminBase>	CVCProjectEngine::s_spAdminBase = NULL;
CAdsiWrapper*			CVCProjectEngine::s_pAdsiWrapper = NULL;

/////////////////////////////////////////////////////////////////////////////
// CVCProjectEngine
HRESULT CVCProjectEngine::CreateInstance(CVCProjectEngine **ppDispInfo)
{
	HRESULT hr;
	CVCProjectEngine *pVar;
	CComObject<CVCProjectEngine> *pObj;
	hr = CComObject<CVCProjectEngine>::CreateInstance(&pObj);
	if (SUCCEEDED(hr))
	{
		pVar = pObj;
		pVar->AddRef();
		*ppDispInfo = pVar;
		hr = pVar->Initialize(NULL, NULL, NULL, NULL);
	}
	return hr;
}


CVCProjectEngine::CVCProjectEngine()
{
	m_bInitialized = false;
	m_bSoftInitialized = false;
	VSASSERT(g_pProjectEngine == NULL, "Why did we create the project engine twice?");
	g_pProjectEngine = this;
	m_nNextVendorID = VCVENDORTOOL_MIN_DISPID;
	m_dwCookieComposite = 0;
	m_bPerformanceLogging = VARIANT_FALSE;
	m_bSuppressUI = VARIANT_FALSE;
	m_nSKU = -1;
	s_fInitializedCom = FALSE;
	CVCProjectEngineEvents::CreateInstance(&m_pProjectEngineEvents);
}

/*
  Initialize
  Does any and all initialization
   This inludes:
		Registration into the Running Object Table (ROT)
		Start up the property manager and initialize it
		Create global property bags such as environment, include, librarypaths, executablepaths, metaplatform
*/
STDMETHODIMP CVCProjectEngine::Initialize( LONG_PTR hInstResources, IUnknown *pUnk, IVSMDPropertyBrowser *pBrowser, 
	IVCBuildPackageInternal* pBldPkg)
{
	if (m_bInitialized)
		return S_OK;

	m_bInitialized = true;
	return DoInitialize(hInstResources, pUnk, pBrowser, pBldPkg, TRUE);
}

HRESULT CVCProjectEngine::DoInitialize(LONG_PTR hInstResources, IUnknown *pUnk, IVSMDPropertyBrowser *pBrowser, 
	IVCBuildPackageInternal* pBldPkg, BOOL bForceInit)
{
	if (!bForceInit && m_bSoftInitialized)
		return S_OK;

	CComQIPtr<IServiceProvider> pSP = pUnk;
	s_pServiceProvider = pSP;

	bool bInitOnce = m_bSoftInitialized;
	m_bSoftInitialized = true;

	// if we aren't given a module hinst for resources, use the default
	if( !hInstResources )
	{
		// get the system default locale id
		LCID lcid = GetSystemDefaultLCID();
		// create a directory name from it
		wchar_t szDirName[8] = {0};
		_itow( lcid, szDirName, 10 );
		// look in that directory for VCProjectUI.dll
		CStringW strDllName;
		if (UtilGetModuleFileNameW(_Module.GetModuleInstance(), strDllName))
		{
			int index = strDllName.ReverseFind( L'\\' );
			strDllName = strDllName.Left( index+1 );
			strDllName += szDirName;
			strDllName += L"\\VCProjectUI.dll" ;
			HINSTANCE hInst = LoadLibraryW( strDllName );
			if (hInst)
				_Module.SetResourceInstance( hInst );
		}
	}
	else
		_Module.SetResourceInstance( (HINSTANCE)hInstResources );

	s_pBuildPackage = pBldPkg;

	if (pBldPkg == NULL)	// no UI if no back door to here...
	{
		put_SuppressUI(VARIANT_TRUE);
		InitializeForCommandLineUsage();
	}

	if( pSP )
	{
		CComPtr<IVsShell> pShell;
		pSP->QueryService(SID_SVsShell, __uuidof(IVsShell), (void**)&pShell);
		if(pShell)
		{
			HRESULT hr;
			CComVariant var;
			hr = pShell->GetProperty(VSSPROPID_VirtualRegistryRoot, &var);
			if(SUCCEEDED(hr) && var.vt == VT_BSTR)
			{
				s_bstrAlternateRegistryRoot = var.bstrVal;
				CStringA strAltKey = var.bstrVal;		// YES, ansi
				SetAlternateKey(strAltKey);
				VsLoaderSetRegistryRootW( s_bstrAlternateRegistryRoot );
			}
		}
	}
	else
	{
		s_bstrAlternateRegistryRoot = L"Software\\Microsoft\\VisualStudio\\7.0";
	}

	HRESULT hr;

	// create the platforms from the registry
	// (platforms create their own tools)
	hr = GetPlatforms();
	VSASSERT(SUCCEEDED(hr), "No Supported platforms found in the registry.  Rerun vsreg.");

	// read tools->options.project.vc build data from registry

	// build logging
	CStringW strKey = s_bstrAlternateRegistryRoot + L"\\VC";

	VARIANT_BOOL bVal = VARIANT_TRUE;
	hr = GetRegBoolW( strKey, L"Build Logging", &bVal);
	SetBoolProperty(PROJENGID_BuildLogging, bVal);

	// build timing
	bVal = VARIANT_FALSE;
	hr = GetRegBoolW( strKey, L"Build Timing", &bVal);
 	SetBoolProperty(PROJENGID_BuildTiming, bVal);

	// performance logging
	bVal = VARIANT_FALSE;
	hr = GetRegBoolW( strKey, L"Performance Logging", &bVal);
 	m_bPerformanceLogging =  bVal;

	// this call only for BBT, don't remove.
	ENDBOOT_vcpb();
	return S_OK;
}

/* static */
void CVCProjectEngine::GetBasePlatformInfoKey( BSTR *pbstrKey )
{
	CComBSTR bstrKey;
	bstrKey = s_bstrAlternateRegistryRoot;
	bstrKey.Append(szVCPlatformRegSubKey);
	*pbstrKey = bstrKey.Detach();
	return;
}

/* static */
void CVCProjectEngine::GetPlatformInfoKey(BSTR bstrPlatform, BSTR bstrMainKey, BSTR *pRetVal )
{
	CComBSTR bstrSubKey;
	bstrSubKey = bstrMainKey;
	bstrSubKey.Append(L"\\");
	bstrSubKey.Append(bstrPlatform);
	*pRetVal = bstrSubKey.Detach();
}

HRESULT CVCProjectEngine::GetPlatforms()
{
    	HRESULT hr;
	// just in case we've been here before...
	ClearPlatforms();

	if( UsingRegistry() )
	{
	    /*
	    Registry looks something like this:
	    HKEY_LOCAL_MACHINE\ ... \VC_OBJECTS_PLATFORM_INFO
		    Win32 (with default prop = guid)
			    directories
				    <inc, exe, lib directories>
			    vendor tool short name (with default prop = guid)
				    <any excluded configs>
	    */

	    CRegistryScanner RegScanner;
	    CComBSTR bstrMainKey;
	    CComBSTR bstrPlatformName;
	    GetBasePlatformInfoKey(&bstrMainKey);
	    if( !RegScanner.Open(HKEY_LOCAL_MACHINE, bstrMainKey) )
		    return S_OK;	// no key, nothing to do
    
	    hr = VCPROJ_E_NOT_FOUND;
	    while( RegScanner.EnumKey(&bstrPlatformName) )
	    {
			// for each item, create a new platform INSTANCE
			if (bstrPlatformName.Length() == 0)
				continue;	// nothing to do if platform name is empty
			// read the default value for the platform key as a guid,
			// and CoCreate that guid to get the platform
			CComBSTR bstrVal;
			if( !RegScanner.GetValue( L"\0", &bstrVal ) )
				continue;

			// turn the string into a guid
			CLSID clsidPlatform;
			hr = CLSIDFromString( bstrVal, &clsidPlatform );
			VSASSERT( SUCCEEDED( hr ), "Failed to get CLSID of platform. Make sure platforms are registered correctly" );
			if( FAILED( hr ) )
				continue;
	
			// CoCreate it
	// 		hr = pPlatform.CoCreateInstance( clsidPlatform );
			CComPtr<VCPlatform> pPlatform;
			hr = VsLoaderCoCreateInstance<VCPlatform>( clsidPlatform, &pPlatform );
			VSASSERT( SUCCEEDED( hr ), "Failed to CoCreate platform. Make sure platforms are registered correctly" );
			if( FAILED( hr ) )
				continue;
	
			CComQIPtr<IVCPlatformImpl> pPlatformImpl = pPlatform;
			VSASSERT(SUCCEEDED(hr) && pPlatformImpl && pPlatform, "Failed to create platform object for platform name.");
			if (!pPlatform || !pPlatformImpl)
				continue;	// nothing to do if no platform
			// initialize the platform
			pPlatformImpl->Initialize();
			m_rgPlatforms.Add(pPlatform);
		}
	}
	else
	{
		CComPtr<VCPlatform> pPlatform;
		hr = CPlatformWin32::CreateInstance( &pPlatform );
		if( FAILED( hr ) )
			return hr;
		CComQIPtr<IVCPlatformImpl> pPlatformImpl = pPlatform;
		if( pPlatformImpl )
		{
			hr = pPlatformImpl->Initialize();
			m_rgPlatforms.Add(pPlatform);
		}
	}

	if (hr == VCPROJ_E_NOT_FOUND)
		return DoSetErrorInfo(VCPROJ_E_NOT_FOUND, IDS_ERR_NO_PLATFORMS);

	return hr;
}


CVCProjectEngine::~CVCProjectEngine()
{
	// need to Close() for standalone (non-VS shell) clients
	// this should be ok, even if we've already been closed
	Close();
	if (s_pAdsiWrapper != NULL)
		delete s_pAdsiWrapper;

	g_pProjectEngine = NULL; // don't kill the fat lady till she doesn't sing anymore
}

STDMETHODIMP CVCProjectEngine::Close()
{
	long l, lcItems;

	lcItems = m_rgProjects.GetSize();
	for (l = 0; l < lcItems; l++)
	{
		CComQIPtr<IVCProjectImpl> pProjectImpl = m_rgProjects.GetAt(l);
		if (pProjectImpl)
			pProjectImpl->Close(); // close down entirely; release all
	}

	lcItems = m_rgAllStyleSheets.GetSize();
	for (l = 0; l < lcItems; l++)
	{
		CComQIPtr<IVCStyleSheetImpl> pStyleSheetImpl = m_rgAllStyleSheets.GetAt(l);
		if (pStyleSheetImpl)
			pStyleSheetImpl->Close(); // close down entirely; release all
	}

	ClearPlatforms();

	lcItems = m_rgVendorTools.GetSize();
	for (l = 0; l < lcItems; l++)
	{
		CComQIPtr<IVCVendorToolFactory> pToolFactory = m_rgVendorTools.GetAt(l);
		if (pToolFactory)
			pToolFactory->CloseSession();
	}
	m_rgVendorTools.RemoveAll();

	m_pPropBrowser = NULL;
	s_pBuildPackage = NULL;
	m_rgProjects.RemoveAll(); // collection of projects. 
	m_rgStyleSheets.RemoveAll(); // collection of visible style sheets. 
	m_rgAllStyleSheets.RemoveAll();	// collection of *all* style sheets

	g_StaticBuildEngine.Close();
	s_pServiceProvider.Release();

	m_pProjConvert.Release();

	CBldMreDependenciesContainer::UnloadMSPDB();

	if (s_spMultiLanguage2)
		s_spMultiLanguage2.Release();
	if (s_spMultiLanguage)
		s_spMultiLanguage.Release();

	if (s_fInitializedCom)
		CoUninitialize();

	FinishClose();

	return S_OK;
}

void CVCProjectEngine::ClearPlatforms()
{
	long lcItems = m_rgPlatforms.GetSize();
	for (long l = 0; l < lcItems; l++)
	{
		CComQIPtr<IVCPlatformImpl> pPlatformImpl = m_rgPlatforms.GetAt(l);
		if (pPlatformImpl)
			pPlatformImpl->Close(); // close down entirely; release all
	}
	m_rgPlatforms.RemoveAll();
}

STDMETHODIMP CVCProjectEngine::get_BuildEngine(IDispatch **ppBuildEngine)
{
	CHECK_POINTER_NULL(ppBuildEngine);

	CComPtr<IVCBuildEngine> spBuildEngine;
	HRESULT hr = CDynamicBuildEngine::CreateInstance(&spBuildEngine);
	RETURN_ON_FAIL(hr);

	CComQIPtr<IDispatch> spDispBuildEngine = spBuildEngine;
	*ppBuildEngine = spDispBuildEngine.Detach();
	return S_OK;
}

STDMETHODIMP CVCProjectEngine::DoFireItemAdded(IDispatch *pDispObj, IDispatch *pDispParent)
{
	Fire_OnItemAdded(pDispObj, pDispParent);
	CComQIPtr<IVCProjectEngineEventsImpl> pFire = m_pProjectEngineEvents;
	RETURN_ON_NULL2(pFire, S_OK);
	pFire->DoFireItemAdded(pDispObj, pDispParent);
	return S_OK;
}

STDMETHODIMP CVCProjectEngine::DoFireItemRemoved(IDispatch *pDispObj, IDispatch *pDispParent)
{
	Fire_OnItemRemoved(pDispObj, pDispParent);
	CComQIPtr<IVCProjectEngineEventsImpl> pFire = m_pProjectEngineEvents;
	RETURN_ON_NULL2(pFire, S_OK);
	pFire->DoFireItemRemoved(pDispObj, pDispParent);
	return S_OK;
}

STDMETHODIMP CVCProjectEngine::DoFireItemRenamed(IDispatch *pDispObj, IDispatch *pDispParent, BSTR bstrOldName)
{
	Fire_OnItemRenamed(pDispObj, pDispParent, bstrOldName);
	CComQIPtr<IVCProjectEngineEventsImpl> pFire = m_pProjectEngineEvents;
	RETURN_ON_NULL2(pFire, S_OK);
	pFire->DoFireItemRenamed(pDispObj, pDispParent, bstrOldName);
	return S_OK;
}

STDMETHODIMP CVCProjectEngine::DoFireItemMoved(IDispatch* pItem, IDispatch* pNewParent, IDispatch* pOldParent)
{
	Fire_OnItemMoved(pItem, pNewParent, pOldParent);
	CComQIPtr<IVCProjectEngineEventsImpl> pFire = m_pProjectEngineEvents;
	RETURN_ON_NULL2(pFire, S_OK);
	pFire->DoFireItemMoved(pItem, pNewParent, pOldParent);
	return S_OK;
}

STDMETHODIMP CVCProjectEngine::DoFireItemPropertyChange(IDispatch *pDispObj, long lDispid)
{
	Fire_OnItemPropertyChange(pDispObj, lDispid);
	CComQIPtr<IVCProjectEngineEventsImpl> pFire = m_pProjectEngineEvents;
	RETURN_ON_NULL2(pFire, S_OK);
	pFire->DoFireItemPropertyChange(pDispObj, lDispid);
	return S_OK;
}

STDMETHODIMP CVCProjectEngine::DoFireSccEvent( IDispatch* pItem, enumSccEvent event, VARIANT_BOOL *pRet )
{
	Fire_OnSccEvent( pItem, event, pRet );
	CComQIPtr<IVCProjectEngineEventsImpl> pFire = m_pProjectEngineEvents;
	RETURN_ON_NULL2(pFire, S_OK);
	pFire->DoFireSccEvent( pItem, event, pRet );
	return S_OK;
}

STDMETHODIMP CVCProjectEngine::DoFireReportError( BSTR bstrErrMsg, HRESULT hrReport, BSTR bstrHelpKeyword )
{
	Fire_OnReportError( bstrErrMsg, hrReport, bstrHelpKeyword );
	CComQIPtr<IVCProjectEngineEventsImpl> pFire = m_pProjectEngineEvents;
	RETURN_ON_NULL2(pFire, S_OK);
	pFire->DoFireReportError( bstrErrMsg, hrReport, bstrHelpKeyword );
	return S_OK;
}

STDMETHODIMP CVCProjectEngine::DoFireProjectBuildStarted(IDispatch *pCfg)
{
	Fire_OnProjectBuildStarted( pCfg );
	CComQIPtr<IVCProjectEngineEventsImpl> pFire = m_pProjectEngineEvents;
	RETURN_ON_NULL2(pFire, S_OK);
	pFire->DoFireProjectBuildStarted( pCfg );
	return S_OK;
}

STDMETHODIMP CVCProjectEngine::DoFireProjectBuildFinished(IDispatch *pCfg, long warnings, long errors, VARIANT_BOOL bCancelled)
{
	Fire_OnProjectBuildFinished( pCfg, warnings, errors, bCancelled );
	CComQIPtr<IVCProjectEngineEventsImpl> pFire = m_pProjectEngineEvents;
	RETURN_ON_NULL2(pFire, S_OK);
	pFire->DoFireProjectBuildFinished( pCfg, warnings, errors, bCancelled );
	return S_OK;
}

STDMETHODIMP CVCProjectEngine::get_BuildLogging(VARIANT_BOOL * pbLog)
{
	DoInitialize(NULL, NULL, NULL, NULL, FALSE);	// just to make sure we have SOMETHING
	return GetBoolProperty(PROJENGID_BuildLogging, pbLog);
}

STDMETHODIMP CVCProjectEngine::put_BuildLogging(VARIANT_BOOL bLog)
{
	DoInitialize(NULL, NULL, NULL, NULL, FALSE);	// just to make sure we have SOMETHING
	return SetBuildLogging(bLog, true);
}

HRESULT CVCProjectEngine::SetBuildLogging(VARIANT_BOOL bLog, bool bPersist)
{
	HRESULT hr = SetBoolProperty(PROJENGID_BuildLogging, bLog);
	if (bPersist && SUCCEEDED(hr))
	{
		CStringW strRoot  = CVCProjectEngine::s_bstrAlternateRegistryRoot + "\\VC";
		WriteRegBoolW( strRoot, L"Build Logging", bLog );
	}
	return hr;
}

STDMETHODIMP CVCProjectEngine::get_SuppressUI(VARIANT_BOOL* pbSuppressUI)
{
	CHECK_POINTER_NULL(pbSuppressUI);
	*pbSuppressUI = m_bSuppressUI;			
	return S_OK;
}

STDMETHODIMP CVCProjectEngine::put_SuppressUI(VARIANT_BOOL bSuppressUI)
{
	m_bSuppressUI = bSuppressUI;
	return S_OK;
}

STDMETHODIMP CVCProjectEngine::get_BuildTiming(VARIANT_BOOL * pbTime)
{
	DoInitialize(NULL, NULL, NULL, NULL, FALSE);	// just to make sure we have SOMETHING
	return GetBoolProperty(PROJENGID_BuildTiming, pbTime);
}

STDMETHODIMP CVCProjectEngine::put_BuildTiming(VARIANT_BOOL bTime)
{ 
	DoInitialize(NULL, NULL, NULL, NULL, FALSE);	// just to make sure we have SOMETHING
	return SetBuildTiming(bTime, true);
}

HRESULT CVCProjectEngine::SetBuildTiming(VARIANT_BOOL bTime, bool bPersist)
{ 
	HRESULT hr = SetBoolProperty(PROJENGID_BuildTiming, bTime);
	if (bPersist && SUCCEEDED(hr))
	{
		CStringW strRoot  = CVCProjectEngine::s_bstrAlternateRegistryRoot + "\\VC";
		WriteRegBoolW( strRoot, L"Build Timing", bTime );
	}
	return hr;
}

STDMETHODIMP CVCProjectEngine::get_PerformanceLogging(VARIANT_BOOL *pbLog)
{
	CHECK_POINTER_VALID(pbLog);
	DoInitialize(NULL, NULL, NULL, NULL, FALSE);	// just to make sure we have SOMETHING
	*pbLog = m_bPerformanceLogging;
	return S_OK;
}

STDMETHODIMP CVCProjectEngine::put_PerformanceLogging(VARIANT_BOOL bLog)
{
	DoInitialize(NULL, NULL, NULL, NULL, FALSE);	// just to make sure we have SOMETHING
	return SetPerformanceLogging(bLog, true);
}

HRESULT CVCProjectEngine::SetPerformanceLogging(VARIANT_BOOL bLog, bool bPersist)
{
	m_bPerformanceLogging = bLog;
	if (bPersist)
	{
		CStringW strRoot  = CVCProjectEngine::s_bstrAlternateRegistryRoot + "\\VC";
		WriteRegBoolW( strRoot, L"Performance Logging", m_bPerformanceLogging );
	}
	return S_OK;
}

STDMETHODIMP CVCProjectEngine::get_Events(IDispatch * * ppEvents)
{
	CHECK_POINTER_VALID(ppEvents);
	DoInitialize(NULL, NULL, NULL, NULL, FALSE);	// just to make sure we have SOMETHING
	RETURN_ON_NULL(m_pProjectEngineEvents);
	return m_pProjectEngineEvents->QueryInterface(__uuidof(IDispatch), (void**)ppEvents);
}

STDMETHODIMP CVCProjectEngine::get_Platforms(IDispatch * * ppPlatforms)
{
	CHECK_POINTER_VALID(ppPlatforms);
	DoInitialize(NULL, NULL, NULL, NULL, FALSE);	// just to make sure we have SOMETHING
		
	CComPtr<IVCCollection> pCollection;
	HRESULT hr = CCollection<VCPlatform>::CreateInstance(&pCollection, &m_rgPlatforms);
	if (SUCCEEDED(hr))
	{
		*ppPlatforms = pCollection.Detach();
	}
	return hr;
}

STDMETHODIMP CVCProjectEngine::get_Projects(IDispatch * * ppProjects)
{
	CHECK_POINTER_VALID(ppProjects);
	DoInitialize(NULL, NULL, NULL, NULL, FALSE);	// just to make sure we have SOMETHING
		
	CComPtr<IVCCollection> pCollection;
	HRESULT hr = CCollection<VCProject>::CreateInstance(&pCollection, &m_rgProjects);
	if (SUCCEEDED(hr))
	{
		*ppProjects = pCollection.Detach();
	}
	return hr;
}

STDMETHODIMP CVCProjectEngine::get_StyleSheets(IDispatch * * ppStyleSheets)
{
	CHECK_POINTER_VALID(ppStyleSheets);
	DoInitialize(NULL, NULL, NULL, NULL, FALSE);	// just to make sure we have SOMETHING
		
	CComPtr<IVCCollection> pCollection;
	HRESULT hr = CCollection<VCStyleSheet>::CreateInstance(&pCollection, &m_rgStyleSheets);
	if (SUCCEEDED(hr))
	{
		*ppStyleSheets = pCollection.Detach();
	}
	return hr;
}

STDMETHODIMP CVCProjectEngine::get_AllStyleSheets(IDispatch * * ppStyleSheets)
{
	CHECK_POINTER_NULL(ppStyleSheets);
	DoInitialize(NULL, NULL, NULL, NULL, FALSE);	// just to make sure we have SOMETHING
		
	CComPtr<IVCCollection> pCollection;
	HRESULT hr = CCollection<VCStyleSheet>::CreateInstance(&pCollection, &m_rgAllStyleSheets);
	if (SUCCEEDED(hr))
	{
		*ppStyleSheets = pCollection.Detach();
	}
	return hr;
}

STDMETHODIMP CVCProjectEngine::CreateProject(BSTR szProject, IDispatch * * ppProject)
{
	CHECK_POINTER_VALID(ppProject);
	if (*szProject == L'\0')
		return CVCProjectEngine::DoSetErrorInfo(E_INVALIDARG, IDS_ERR_EMPTY_PROJ_NAME);

	*ppProject = NULL; // just in case we fail

	Initialize(NULL, NULL, NULL, NULL); // just to be sure....

	CComPtr<VCProject> pProject;
	HRESULT hr = CProject::CreateInstance(&pProject);
	if (SUCCEEDED(hr) && pProject)
	{
		// firstly, we set the name
		hr = pProject->put_Name(szProject);
		RETURN_ON_FAIL(hr);

		// and get the dispatch to return
		CComQIPtr<IDispatch> pDispProject = pProject;
		pDispProject.CopyTo(ppProject);

		// record the project...
		m_rgProjects.Add(pProject);

		// lastly, tell the world about a new project existing
		DoFireItemAdded(pDispProject, NULL);
		hr = S_OK;
	}
	return hr;
}

HRESULT CVCProjectEngine::LoadXML( BSTR bstrFile, IDispatch **ppDispProject )
{
	HRESULT hr;

	// XML file format reader
	CComPtr<IXMLParser> spParser;
	CComPtr<IVCNodeFactory> spVCNodeFactory;
	
	// co-create one
	hr = spParser.CoCreateInstance( CLSID_XMLParser );
	RETURN_ON_FAIL_OR_NULL(hr, spParser);

	// co-create the node factory
	CComObject< CVCNodeFactory >* pVCNodeFactory = NULL;
	hr = CComObject< CVCNodeFactory >::CreateInstance( &pVCNodeFactory );
	RETURN_ON_FAIL(hr);
	hr = pVCNodeFactory->QueryInterface( __uuidof(IVCNodeFactory), reinterpret_cast<void**>( &spVCNodeFactory ) );
	RETURN_ON_FAIL(hr);
	RETURN_ON_NULL2( spVCNodeFactory, E_NOINTERFACE )
 	CComQIPtr<IXMLNodeFactory> spNodeFactory = spVCNodeFactory;
	RETURN_ON_NULL2(spNodeFactory, E_NOINTERFACE) 

	// set the node factory for the parser to use
	hr = spParser->SetFactory( spNodeFactory );
	RETURN_ON_FAIL(hr);

	hr = spParser->SetURL( NULL, bstrFile, 1 );
	RETURN_ON_FAIL(hr);

	// set the project/style sheet name for the node factory
	hr = spVCNodeFactory->put_Name( bstrFile );
	RETURN_ON_FAIL(hr);

	// run
	hr = spParser->Run( -1 );
	if( FAILED( hr ) )
	{
		// handle error conditions passed back from Run()
		return hr;
	}

	// get the root we just created (either project or stylesheet)
	spVCNodeFactory->get_Root( ppDispProject );

	CComBSTR bstrEncoding;
	spVCNodeFactory->get_FileEncoding(&bstrEncoding);
	if (bstrEncoding.Length() == 0)
		CXMLFile::DetermineDefaultFileEncoding(bstrEncoding);
	if (bstrEncoding.Length() > 0)
	{
		// get the VCProject from it so we can set the project file encoding we just loaded
		CComQIPtr<VCProject> pProject = *ppDispProject;
		if( pProject )	// if not project, probably style sheet
			pProject->put_FileEncoding( bstrEncoding );
	}

	return S_OK;
}

STDMETHODIMP CVCProjectEngine::LoadProject(BSTR szProject, IDispatch * * ppDispProject)
{
	if( s_pBuildPackage )	// only allowed to call this directly if not under the shell!
		return E_FAIL;

	CHECK_POINTER_VALID(ppDispProject);
	return LoadProjectUnderShell(szProject, ppDispProject);
}

STDMETHODIMP CVCProjectEngine::LoadProjectUnderShell(LPCOLESTR szProject, IDispatch * * ppDispProject)
{
	CHECK_POINTER_NULL(ppDispProject);
	Initialize(NULL, NULL, NULL, NULL); // just to be sure....

#ifdef AARDVARK
	{
		CStringW strStyleName = szProject;
		int nLen = strStyleName.GetLength();
		if (nLen > 8)
		{
			strStyleName = strStyleName.Right(8);
			strStyleName.MakeLower();
			if (strStyleName == L".vcstyle")
			{
				CComBSTR bstrStyleSheet = szProject;
				return LoadStyleSheet(bstrStyleSheet, ppDispProject);
			}
		}
	}
#endif
	bool bProjectConverted = false;
	CComPtr<IDispatch> pDispProject;
	CComPtr<IDispatch> pDispProjects;
	CComPtr<IVCCollection> pProjects;
	HRESULT hr = get_Projects(&pDispProjects);
	pProjects = pDispProjects;
	VSASSERT(pProjects, "No Projects collection?  Probably out of memory.");
	RETURN_ON_NULL2(pProjects, E_NOINTERFACE);

	// just in case
	pDispProject = NULL;

	CInLoadProject loadProj;
	
	// see if it is a conversion project...
	BOOL bConvertIt = FALSE;
	CComBSTR bstrProjectName = szProject;
	CComBSTR szDefaultProjExt = L".vcproj";
	if( bstrProjectName.Length() > szDefaultProjExt.Length() )
	{
	    LPCOLESTR pStr = &bstrProjectName[bstrProjectName.Length() - szDefaultProjExt.Length()];
	    if( wcsicmp( pStr, szDefaultProjExt ) )
	    {
			bConvertIt = TRUE;
	    }
	}
	if (bConvertIt)
	{
		CStringW strPath;
		if (!UtilGetModuleFileNameW(NULL, strPath))
			return E_FAIL;
		CCurDirW cwd(strPath, TRUE);	// Find the directory containing MFC before doing this CoCreate

		// only create a new proj converter if we need one
		hr = S_OK;
		if( !m_pProjConvert )
			hr = VsLoaderCoCreateInstance<IVCProjConvert>(CLSID_VCProjConvert, &m_pProjConvert);

		if (SUCCEEDED(hr) && m_pProjConvert)
		{
			CStringW strSourceFilesString;
			strSourceFilesString.LoadString(IDS_CONVERT_SOURCE_FILES);
			CComBSTR bstrSourceFilesString = strSourceFilesString;
			m_pProjConvert->Initialize(bstrSourceFilesString);

			hr = m_pProjConvert->OpenProject(bstrProjectName, static_cast<VCProjectEngine *>(this), s_pServiceProvider );

			// if we failed to convert, put up an error message
			if( FAILED( hr ) )
			{
				// if we got back "VCPROJ_E_UNSUPPORTED_PROJ_FILE" this is an
				// old project file
				const wchar_t *pStr = wcsrchr(bstrProjectName,L'.');
				long i = -1;
				if( pStr )
				{
					i = (long)(pStr - bstrProjectName);
				}

				if( hr == VCPROJ_E_UNSUPPORTED_PROJ_FILE )
				{
					CComBSTR bstrConversionErr;
					bstrConversionErr.LoadString( IDS_UNSUPPORTED_PROJ_FILE );
					DoFireReportError( bstrConversionErr, hr, CComBSTR(L"VC.ProjectConversionProblems") );
				}
				else if (hr == VCPROJ_E_BAD_PROJ_FILE)
				{
					CComBSTR bstrConversionErr;
					bstrConversionErr.LoadString( IDS_ERR_BAD_PROJ_FILE );
					DoFireReportError( bstrConversionErr, hr, CComBSTR(L"VC.ProjectConversionProblems") );
				}
				// check the extension to see if this was an .mak file
				else if( i != -1 && wcsicmp( L".mak", &bstrProjectName[i] ) == 0 )
				{
					CComBSTR bstrConversionErr;
					bstrConversionErr.LoadString( IDS_MAKCONVERSION_ERROR );
					DoFireReportError( bstrConversionErr, hr, CComBSTR(L"VC.ProjectConversionProblems") );
				}
				else
				{
					CComBSTR bstrConversionErr;
					bstrConversionErr.LoadString( IDS_CONVERSION_ERROR );
					DoFireReportError( bstrConversionErr, hr, CComBSTR(L"VC.ProjectConversionProblems") );
				}
				return hr;
			}

			wchar_t *pStr = wcsrchr(bstrProjectName,L'.');
			if( pStr )
			    pStr[0] = L'\0'; 			// temporarily terminate string
			CComBSTR bstrTempProjName = (wchar_t*)bstrProjectName; // Get the length of the string corrected, so that we can append without causing problems
			bstrTempProjName.Append(L".vcproj"); 	// Now append to the string 
			bstrProjectName = bstrTempProjName; 	// should have converted it to this...
			bProjectConverted = true;

			// get the project
			m_pProjConvert->GetProject( &pDispProject );
		}
	}
	else
	{
		hr = LoadXML( bstrProjectName, &pDispProject );
	}
	RETURN_ON_FAIL_OR_NULL(hr, pDispProject);

	CComQIPtr<VCProject> pProj = pDispProject;
	if( pProj )
	{
		// set the project file
		pProj->put_ProjectFile( bstrProjectName );

		// is this project under SCC?
		CComBSTR bstrSccProjectName;
		pProj->get_SccProjectName( &bstrSccProjectName );
		if( bstrSccProjectName.Length() )
		{
			// notify archy
			VARIANT_BOOL bRetVal;
			Fire_OnSccEvent( pDispProject, eProjectInScc, &bRetVal );
		}
	}
	CComQIPtr<IVCBuildableItem> spBuildableItem;
	spBuildableItem = pDispProject;
	VSASSERT(spBuildableItem, "How did we get a project object that doesn't support IVCBuildableItem?");
	if (spBuildableItem != NULL)
		spBuildableItem->AssignActions(VARIANT_TRUE);

	g_bInProjLoad = FALSE;

	// if we're converting, dirty the project file so it gets written
	CComQIPtr<IVCProjectImpl> pProjImpl = pDispProject;
 	if (pProjImpl && bProjectConverted)
 		pProjImpl->put_IsDirty(VARIANT_TRUE);

	// detach the IDispatch project object for return
	*ppDispProject = pDispProject.Detach();
	return hr;
}

STDMETHODIMP CVCProjectEngine::RemoveProject(IDispatch * pDispProject)
{
	if( s_pBuildPackage )	// only allowed to call this directly if not under the shell!
		return E_FAIL;

	return RemoveProjectUnderShell(pDispProject);
}

STDMETHODIMP CVCProjectEngine::RemoveProjectUnderShell(IDispatch * pDispProject)
{
	HRESULT hr = VCPROJ_E_NOT_FOUND;
	long l, lcItems;

	lcItems = m_rgProjects.GetSize();
	for (l = 0; l < lcItems && hr == VCPROJ_E_NOT_FOUND; l++)
	{
		CComPtr<VCProject> pProject;
		CComQIPtr<IDispatch> pDisp;

		pProject = m_rgProjects.GetAt(l);
		pDisp = pProject;
		if (pDisp && pDispProject == pDisp)
		{
			DoFireItemRemoved( pDispProject, NULL );
			CComQIPtr<IVCProjectImpl> pProjectImpl = pProject;
			pProjectImpl->Close(); // close down entirely; release all
			m_rgProjects.RemoveAtIndex(l);
			hr = S_OK;
		}
	}

	if (hr == VCPROJ_E_NOT_FOUND)
		return DoSetErrorInfo(VCPROJ_E_NOT_FOUND, IDS_ERR_PROJ_NOT_FOUND_FOR_REMOVE);

	return hr;
}

STDMETHODIMP CVCProjectEngine::LoadHiddenStyleSheet(LPCOLESTR szStyleSheet, IDispatch **ppDispStyleSheet)
{
	CComPtr<VCStyleSheet> spStyleSheet;
	return DoLoadHiddenStyleSheet(szStyleSheet, &spStyleSheet, ppDispStyleSheet);
}

HRESULT CVCProjectEngine::DoLoadHiddenStyleSheet(LPCOLESTR szStyleSheet, VCStyleSheet** ppStyleSheet, IDispatch** ppDispStyleSheet)
{
	CHECK_POINTER_NULL(ppDispStyleSheet);
	Initialize(NULL, NULL, NULL, NULL); // just to be sure....

	CComPtr<IDispatch> pDispStyleSheets;
	HRESULT hr = get_AllStyleSheets(&pDispStyleSheets);
	CComQIPtr<IVCCollection> pStyleSheets = pDispStyleSheets;
	VSASSERT(pStyleSheets, "No StyleSheets collection?  Probably out of memory.");
	RETURN_ON_NULL2(pStyleSheets, E_NOINTERFACE);

	if (SUCCEEDED(hr))
	{
		hr = pStyleSheets->Item(CComVariant(szStyleSheet), ppDispStyleSheet);
		if (SUCCEEDED(hr) && *ppDispStyleSheet)
		{
			CComQIPtr<IVCStyleSheetImpl> spStyleSheetImpl = *ppDispStyleSheet;
			if (spStyleSheetImpl)
			{
				long nLoadCount = 0;
				spStyleSheetImpl->get_LoadCount(&nLoadCount);
				nLoadCount++;
				spStyleSheetImpl->put_LoadCount(nLoadCount);
			}
			CComQIPtr<VCStyleSheet> spStyle = spStyleSheetImpl;
			*ppStyleSheet = spStyle.Detach();
			return S_FALSE; // indicate that we had one already....
		}
	}

	CInLoadStyle loadStyle;

	hr = LoadXML( CComBSTR(szStyleSheet), ppDispStyleSheet );
	RETURN_ON_FAIL(hr);

	// DIANEME_TODO: we need to figure out how to handle style sheets under SCC


	// lastly, tell the world about a new style sheet existing
	DoFireItemAdded(*ppDispStyleSheet, NULL);

	// initial load count set in CreateHiddenStyleSheet
	CComQIPtr<VCStyleSheet> spStyle = *ppDispStyleSheet;
	*ppStyleSheet = spStyle.Detach();

	return hr;
}

STDMETHODIMP CVCProjectEngine::LoadStyleSheet(BSTR szStyleSheet, IDispatch **ppDispStyleSheet)
{
	CComPtr<VCStyleSheet> spStyleSheet;
	HRESULT hr = DoLoadHiddenStyleSheet(szStyleSheet, &spStyleSheet, ppDispStyleSheet);
	RETURN_ON_FAIL(hr);

	CComPtr<IDispatch> pDispStyleSheets;
	hr = get_StyleSheets(&pDispStyleSheets);
	CComQIPtr<IVCCollection> pStyleSheets = pDispStyleSheets;
	VSASSERT(pStyleSheets, "No StyleSheets collection?  Probably out of memory.");
	RETURN_ON_FAIL_OR_NULL2(hr, pStyleSheets, E_NOINTERFACE);

	CComPtr<IDispatch> pDispStyleSheet;
	hr = pStyleSheets->Item(CComVariant(szStyleSheet), &pDispStyleSheet);
	if (SUCCEEDED(hr) && pDispStyleSheet)
		return S_FALSE;		// already here in the 'visible' collection

	m_rgStyleSheets.Add(spStyleSheet);
	return S_OK;
}

HRESULT CVCProjectEngine::DoCreateHiddenStyleSheet(LPCOLESTR szStyleSheet, VCStyleSheet** ppStyleSheet, IDispatch** ppDispStyle)
{
	CHECK_POINTER_NULL(ppDispStyle);
	if (*szStyleSheet == L'\0')
		RETURN_INVALID();

	*ppDispStyle = NULL; // just in case we fail

	Initialize(NULL, NULL, NULL, NULL); // just to be sure....

	HRESULT hr = CStyleSheet::CreateInstance(ppStyleSheet);
	if (SUCCEEDED(hr) && *ppStyleSheet)
	{
		// firstly, we set the name
		hr = (*ppStyleSheet)->put_Name(CComBSTR(szStyleSheet));
		RETURN_ON_FAIL(hr);

		CComQIPtr<IVCStyleSheetImpl> spStyleSheetImpl = *ppStyleSheet;
		if (spStyleSheetImpl)
			spStyleSheetImpl->put_LoadCount(1);

		// and get the dispatch to return
		CComQIPtr<IDispatch> pDispStyleSheet = *ppStyleSheet;
		pDispStyleSheet.CopyTo(ppDispStyle);

		// record the StyleSheet...
		m_rgAllStyleSheets.Add(*ppStyleSheet);

		hr = S_OK;
	}
	return hr;
}

STDMETHODIMP CVCProjectEngine::CreateHiddenStyleSheet(LPCOLESTR szStyleSheet, IDispatch **ppDispStyle)
{
	CComPtr<VCStyleSheet> spStyleSheet;
	return DoCreateHiddenStyleSheet(szStyleSheet, &spStyleSheet, ppDispStyle);
}

STDMETHODIMP CVCProjectEngine::CreateStyleSheet(BSTR szStyleSheet, IDispatch **ppDispStyle)
{
	CComPtr<VCStyleSheet> pStyleSheet;
	HRESULT hr = DoCreateHiddenStyleSheet(szStyleSheet, &pStyleSheet, ppDispStyle);
	RETURN_ON_FAIL(hr);

	// record the StyleSheet...
	m_rgStyleSheets.Add(pStyleSheet);

	// lastly, tell the world about a new style sheet existing
	DoFireItemAdded(*ppDispStyle, NULL);

	return hr;
}

STDMETHODIMP CVCProjectEngine::RemoveStyleSheet(IDispatch* pDispStyle)
{
	CHECK_READ_POINTER_VALID(pDispStyle);
	return DoRemoveStyleSheet(pDispStyle, FALSE /* don't remove from 'hidden' list */);
}

HRESULT CVCProjectEngine::DoRemoveStyleSheet(IDispatch* pDispStyle, BOOL bRemoveFromHiddenList)
{
	CHECK_READ_POINTER_NULL(pDispStyle);
	HRESULT hr = VCPROJ_E_NOT_FOUND;
	long l, lcItems, nLoadCount = 0;

	lcItems = m_rgStyleSheets.GetSize();
	for (l = 0; l < lcItems && hr == VCPROJ_E_NOT_FOUND; l++)
	{
		CComPtr<VCStyleSheet> spStyleSheet = m_rgStyleSheets.GetAt(l);
		CComQIPtr<IDispatch> spDisp = spStyleSheet;
		if (!spDisp)
			continue;
		if (pDispStyle != spDisp)
			continue;

		m_rgStyleSheets.RemoveAtIndex(l);
		CComQIPtr<IVCStyleSheetImpl> spStyleSheetImpl = spStyleSheet;
		if (spStyleSheetImpl)
		{
			spStyleSheetImpl->get_LoadCount(&nLoadCount);
			if (nLoadCount > 0)
			{
				nLoadCount--;
				spStyleSheetImpl->put_LoadCount(nLoadCount);
			}
		}
		hr = S_OK;
	}

	if ((hr == VCPROJ_E_NOT_FOUND && bRemoveFromHiddenList) || (nLoadCount < 1))
	{
		BOOL bCountAlreadyRemoved = SUCCEEDED(hr);
		lcItems = m_rgAllStyleSheets.GetSize();
		hr = VCPROJ_E_NOT_FOUND;	// if it's on the other list, it BETTER be on this one...
		for (l = 0; l < lcItems && hr == VCPROJ_E_NOT_FOUND; l++)
		{
			CComPtr<VCStyleSheet> spStyleSheet = m_rgAllStyleSheets.GetAt(l);
			CComQIPtr<IDispatch> spDisp = spStyleSheet;
			if (!spDisp)
				continue;
			if (pDispStyle != spDisp)
				continue;

			m_rgAllStyleSheets.RemoveAtIndex(l);
			CComQIPtr<IVCStyleSheetImpl> spStyleSheetImpl = spStyleSheet;
			if (spStyleSheetImpl)
			{
				if (!bCountAlreadyRemoved)
				{
					spStyleSheetImpl->get_LoadCount(&nLoadCount);
					if (nLoadCount > 0)
					{
						nLoadCount--;
						spStyleSheetImpl->put_LoadCount(nLoadCount);
					}
					VSASSERT(nLoadCount <= 0, "Hey, trying to remove a style sheet too early!");
				}
				spStyleSheetImpl->Close(); // close down entirely; release all
				hr = S_OK;
			}
		}
	}

	if (hr == VCPROJ_E_NOT_FOUND)
		return DoSetErrorInfo(VCPROJ_E_NOT_FOUND, IDS_ERR_STYLE_NOT_FOUND_FOR_REMOVE);

	return hr;
}

STDMETHODIMP CVCProjectEngine::UnloadStyleSheet(IDispatch* pDispStyleSheet)
{
	CComQIPtr<IVCStyleSheetImpl> spStyleSheet = pDispStyleSheet;
	RETURN_ON_NULL2(spStyleSheet, E_UNEXPECTED);

	long nLoadCount = 0;
	spStyleSheet->get_LoadCount(&nLoadCount);
	if (nLoadCount > 0)
		nLoadCount--;
	spStyleSheet->put_LoadCount(nLoadCount);
	if (nLoadCount < 1)
		return DoRemoveStyleSheet(pDispStyleSheet, TRUE /* remove from 'hidden' list */);

	return S_OK;
}

STDMETHODIMP CVCProjectEngine::CreatePropertyGrid(IVSMDPropertyGrid **ppGrid)
{
	if( !m_pPropBrowser )
		if( s_pServiceProvider )
			s_pServiceProvider->QueryService( SID_SVSMDPropertyBrowser, __uuidof(IVSMDPropertyBrowser), (LPVOID *)&m_pPropBrowser );
	if( m_pPropBrowser )
		return m_pPropBrowser->CreatePropertyGrid(ppGrid);

	return E_FAIL;
}

STDMETHODIMP CVCProjectEngine::GetHelp(Help **ppHelp)
{
	HRESULT hr = E_FAIL;
	if( s_pServiceProvider )
		hr = s_pServiceProvider->QueryService(SID_SVsHelp, __uuidof(Help), (void **)ppHelp);
	return hr;
}

STDMETHODIMP CVCProjectEngine::IsSystemInclude(BSTR bstrFileName, VARIANT_BOOL *pbInclude)
{
	CHECK_POINTER_VALID(pbInclude);
	*pbInclude = VARIANT_FALSE;

    CStringW strFileName(bstrFileName);
	INT_PTR nLen = strFileName.GetLength();
	if (nLen == 0)
		return S_OK;

	// let's see if we were given a full path.  If so, get the actual OS case so that IsSysInclude can recognize it
	if (nLen > 3)
	{
		bool bNormalizePath = false;
		if (strFileName[1] == L':' && (strFileName[2] == L'/' || strFileName[2] == L'\\'))
			bNormalizePath = true;
		else if ((strFileName[0] == L'/' || strFileName[0] == L'\\') && (strFileName[1] == L'/' || strFileName[1] == L'\\'))
			bNormalizePath = true;

		if (bNormalizePath)
		{
			CPathW path;
			if (path.Create(strFileName))
			{
				path.GetActualCase(TRUE);
				strFileName = path;
			}
		}
	}
	if (g_SysInclReg.IsSysInclude(strFileName))
		*pbInclude = VARIANT_TRUE;
		
	return S_OK;
}

void CVCProjectEngine::InitializeForCommandLineUsage()
{
	// make sure we have console output
	HANDLE hStdOut = ::GetStdHandle(STD_OUTPUT_HANDLE);

	if ((hStdOut != INVALID_HANDLE_VALUE) && (hStdOut != NULL))
		s_hLogFile = hStdOut;

	// should be okay
	if (!s_hLogFile)
		s_hLogFile = hStdOut;
}

STDMETHODIMP CVCProjectEngine::WriteLog(LPCOLESTR lpszOut, BOOL bAppendCRLF)
{
	if (DoWriteLog(lpszOut, bAppendCRLF))
		return S_OK;

	return S_FALSE;
}

BOOL CVCProjectEngine::DoWriteLog(LPCOLESTR szOut, BOOL bAppendCRLF /* = FALSE */)
{
	RETURN_ON_NULL2(s_hLogFile, FALSE);

	// NULL means close stdout
	if (szOut == NULL || *szOut == L'\0')
	{
		::CloseHandle(s_hLogFile);
		s_hLogFile = NULL;
		return TRUE;
	}

	CStringA strOut = szOut;		// yes, ANSI -- due to the fact that we write an ANSI log
	strOut.AnsiToOem();

	int len;
	DWORD nBytes;
	const char* szOutA = strOut;
	const char* pszC = szOutA;
	while ((pszC = (const char *) _mbschr((const unsigned char*)szOutA, '\n')) != NULL)
	{
		len = (int)(pszC - szOutA);
		if (len > 0)
		{
			nBytes = (DWORD)(len*sizeof(char));
			WriteFile(s_hLogFile, szOutA, (DWORD)(len*sizeof(char)), &nBytes, NULL);
		}

		WriteFile(s_hLogFile, "\r\n", 2*sizeof(char), &nBytes, NULL);
		szOutA = ++pszC;
	}

	// check for any remainder
	len = lstrlenA(szOutA);
	if (len > 0)
	{
		nBytes = (DWORD)(len*sizeof(char));
		WriteFile(s_hLogFile, szOutA, (DWORD)(len*sizeof(char)), &nBytes, NULL);
	}

	if (bAppendCRLF)
	{
		WriteFile(s_hLogFile, "\r\n", 2*sizeof(char), &nBytes, NULL);
	}
	return TRUE;
}

STDMETHODIMP CVCProjectEngine::get_DialogOwner( HWND *pHwnd )
{
	CHECK_POINTER_NULL( pHwnd );

	CComPtr<IVsUIShell> pUIShell;
	HRESULT hr = E_FAIL;
	if( s_pServiceProvider )
	    hr = s_pServiceProvider->QueryService( SID_SVsUIShell, __uuidof(IVsUIShell), reinterpret_cast<void **>(&pUIShell) );
	RETURN_ON_FAIL_OR_NULL(hr, pUIShell);
	return pUIShell->GetDialogOwnerHwnd( pHwnd );
}

STDMETHODIMP CVCProjectEngine::EnableModeless( BOOL bEnable )
{
	CComPtr<IVsUIShell> pUIShell;
	HRESULT hr = E_FAIL;
	if( s_pServiceProvider )
		hr = s_pServiceProvider->QueryService( SID_SVsUIShell, __uuidof(IVsUIShell), reinterpret_cast<void **>(&pUIShell) );
	RETURN_ON_FAIL_OR_NULL(hr, pUIShell);

	return pUIShell->EnableModeless( bEnable );
}

STDMETHODIMP CVCProjectEngine::GetIVCProjConvert( IUnknown ** ppUnkProjConvert )
{
	// if we have a valid project conversion pointer, return it
	if( m_pProjConvert )
	{
		CComPtr<IUnknown> pUnk;
	   	m_pProjConvert.QueryInterface( &pUnk );
		if( pUnk )
			*ppUnkProjConvert = pUnk.Detach();
	}
	else
		*ppUnkProjConvert = NULL;
	return S_OK;
}

STDMETHODIMP CVCProjectEngine::GetSKU( long *pSKU )
{
	HRESULT hr = E_FAIL;

    	if( m_nSKU == -1 )
	{
		CComPtr<IVsAppId> pAppID;
		CComVariant var;
		if( s_pServiceProvider )
		{
			hr = s_pServiceProvider->QueryService( SID_SVsAppId, __uuidof(IVsAppId), (void **)&pAppID );
			RETURN_ON_FAIL_OR_NULL(hr, pAppID);
			hr = pAppID->GetProperty(VSAPROPID_SKUEdition, &var );
			if( SUCCEEDED(hr) )
			{
			    m_nSKU = var.lVal;
			}
		}
	}
	else
	{
	    hr = S_OK;
	}

	*pSKU = m_nSKU;
	return hr;
}

STDMETHODIMP CVCProjectEngine::GetDialogFont( BOOL bBold, HFONT *pHFont )
{
	UIDLGLOGFONT logFont;
	CComPtr<IUIHostLocale> pLocale;

	*pHFont = 0;
	
	HRESULT hr = E_FAIL;
	if( s_pServiceProvider )
	{
		hr = s_pServiceProvider->QueryService( SID_SUIHostLocale, __uuidof(IUIHostLocale), (void**)&pLocale );
		RETURN_ON_FAIL_OR_NULL(hr, pLocale);
		pLocale->GetDialogFont( &logFont );
		if( bBold )
			logFont.lfWeight = 700;
	}
		
	*pHFont = CreateFontIndirectW( (LOGFONTW*)&logFont );
	
	return S_OK;
}

STDMETHODIMP CVCProjectEngine::get_VendorTools(IDispatch** ppVendorTools)
{
	CHECK_POINTER_NULL(ppVendorTools);
		
	CComPtr<IVCCollection> pCollection;
	HRESULT hr = CCollection<IVCToolImpl>::CreateInstance(&pCollection, &m_rgVendorTools);
	if (SUCCEEDED(hr))
	{
		hr = pCollection.QueryInterface(ppVendorTools);
	}
	return hr;
}

STDMETHODIMP CVCProjectEngine::AddVendorTool(LPCOLESTR szToolName, LPCOLESTR szToolGUID, IDispatch** ppVendorTool)
{
	CHECK_POINTER_NULL(ppVendorTool);
	CStringW strToolName = szToolName;
	strToolName.TrimLeft();
	strToolName.TrimRight();
	if (strToolName.IsEmpty())
		RETURN_INVALID();

	CComPtr<IDispatch> spDispTool;
	HRESULT hr = E_FAIL;
	if (szToolGUID)
	{
		CStringW strToolGUID = szToolGUID;
		strToolGUID.TrimLeft();
		strToolGUID.TrimRight();
		if (!strToolGUID.IsEmpty())
			hr = spDispTool.CoCreateInstance(LPCOLESTR(strToolGUID.GetBuffer(strToolGUID.GetLength())));
	}
	if (FAILED(hr))	// if we couldn't create it from the tool GUID, then try the tool name proper
		spDispTool.CoCreateInstance(LPCOLESTR(strToolName.GetBuffer(strToolName.GetLength())));
	RETURN_ON_FAIL(hr);

	CComQIPtr<IVCToolImpl> spToolImpl = spDispTool;
	CComQIPtr<IVCVendorToolFactory> spVendorToolFactory = spToolImpl;
	RETURN_ON_NULL2(spVendorToolFactory, E_UNEXPECTED);

	CComPtr<IDispatch> spDispProjEngine = g_pProjectEngine;
	spVendorToolFactory->SetProjectEngine(spDispProjEngine);

	// DIANEME_TODO: need to do validation on whether the number of IDs requested will
	// fit into whatever is left of the vendor tool ID range.  If it doesn't, then we
	// need to figure out how to get other chunks to stick stuff into.
	long cIDs = 0;
	spVendorToolFactory->get_RequiredPropertyRange(&cIDs);
	spVendorToolFactory->SetStartID(m_nNextVendorID);
	m_nNextVendorID += cIDs;

	// DIANEME_TODO: call GetBuildOnlyPropertyRange and do something with the results
	// DIANEME_TODO: call SupportsPlatform with all supported platforms and do something with the results
	*ppVendorTool = spDispTool.Detach();

	m_rgVendorTools.AddTail(spToolImpl);
	return S_OK;
}

STDMETHODIMP CVCProjectEngine::GetStringForPropertyID(long nID, BSTR* pbstrString)
{
	CHECK_POINTER_NULL(pbstrString);
	if (nID <= 0)
		RETURN_INVALID();

	CComBSTR bstr;
	bstr.LoadString(nID);
	*pbstrString = bstr.Detach();
	return S_OK;
}

STDMETHODIMP CVCProjectEngine::GetMultiProp(long id, LPCOLESTR szSeparator, VARIANT_BOOL bSkipLocal, BSTR *pbstrValue)
{
	CHECK_POINTER_NULL(pbstrValue);

	// no multi-props as yet
	return GetStrProperty(id, pbstrValue);
}

HRESULT CVCProjectEngine::DoGetProp(long id, VARIANT* pVarValue)
{
	CComVariant varVal;

	if (m_PropMap.Lookup(id, varVal))
	{
		if (pVarValue)
			varVal.Detach(pVarValue);
		return S_OK;
	}

	if (pVarValue)
		pVarValue = NULL;

	// We didn't find it
	return S_FALSE;
}

HRESULT CVCProjectEngine::DoSetProp(long id, BOOL bCheckSpecial, VARIANT varValue, long nOverrideID /* = -1 */)
{
	if (bCheckSpecial)
	{
		switch (id)
		{
		case PROJENGID_BuildLogging:
			return DoSetBoolProperty(PROJENGID_BuildLogging, TRUE, varValue.boolVal);
			break;
		default:
			// fall through
			break;
		}
	}

	m_PropMap.SetAt(id, varValue);
	return S_OK;
}

HRESULT CVCProjectEngine::DoSetStrProperty(long idProp, BOOL bCheckSpecial, BSTR bstrValue, long nOverrideID /* = -1 */)
{
	return CPropertyContainerImpl::DoSetStrProperty(idProp, bCheckSpecial, bstrValue, nOverrideID);
}

HRESULT CVCProjectEngine::DoSetBoolProperty(long idProp, BOOL bCheckSpecial, VARIANT_BOOL bValue, long nOverrideID /* = -1 */)
{
	CHECK_VARIANTBOOL(bValue);

	if (bCheckSpecial && idProp == PROJENGID_BuildLogging)
	{
		s_bBuildLogging = bValue;
		return DoSetBoolProperty(PROJENGID_BuildLogging, FALSE, bValue);
	}

	CComVariant var(bValue);
	return DoSetProp(idProp, bCheckSpecial, var);
}

void CVCProjectEngine::AddProjectError(IVCBuildErrorContext* pEC, BSTR bstrErr, BSTR bstrPrjErrCode, 
	IVCPropertyContainer* pPropContainer)
{
	if (pEC == NULL)
		return;

	CComBSTR bstrProj;
	if (pPropContainer == NULL || FAILED(pPropContainer->GetStrProperty(VCPROJID_Name, &bstrProj)) || 
		bstrProj.Length() == 0)
		bstrProj.LoadString(IDS_PROJECT_WORD);
	pEC->AddError(bstrErr, bstrPrjErrCode, bstrProj, 0, NULL);
}

void CVCProjectEngine::AddProjectError(IVCBuildErrorContext* pEC, BSTR bstrErr, BSTR bstrPrjErrCode, IVCBuildActionList* pActionList)
{
	if (pActionList)
	{
		CComPtr<IVCBuildAction> spAction;
		pActionList->get_LastAction(&spAction);
		AddProjectError(pEC, bstrErr, bstrPrjErrCode, spAction);
		return;
	}

	AddProjectError(pEC, bstrErr, bstrPrjErrCode, (IVCPropertyContainer*)NULL);
}

void CVCProjectEngine::AddProjectError(IVCBuildErrorContext* pEC, BSTR bstrErr, BSTR bstrPrjErrCode, IVCBuildAction* pAction)
{
	CComPtr<IVCPropertyContainer> spPropContainer;
	if (pAction)
		pAction->get_PropertyContainer(&spPropContainer);

	AddProjectError(pEC, bstrErr, bstrPrjErrCode, spPropContainer);
}

void CVCProjectEngine::AddProjectError(IVCBuildErrorContext* pEC, BSTR bstrErr, BSTR bstrPrjErrCode, CBldCfgRecord* pCfgRecord)
{
	CComQIPtr<IVCPropertyContainer> spPropContainer;
	if (pCfgRecord)
	{
		VCConfiguration* pConfig = pCfgRecord->GetVCConfiguration();	// not ref-counted
		spPropContainer = pConfig;
	}

	AddProjectError(pEC, bstrErr, bstrPrjErrCode, spPropContainer);
}

void CVCProjectEngine::AddProjectError(IVCBuildErrorContext* pEC, CStringW& strErr, BSTR bstrPrjErrCode,
	IVCPropertyContainer* pPropContainer)
{
	CComBSTR bstrErr = strErr;
	AddProjectError(pEC, bstrErr, bstrPrjErrCode, pPropContainer);
}

void CVCProjectEngine::AddProjectError(IVCBuildErrorContext* pEC, CStringW& rstrErr, BSTR bstrPrjErrCode, CBldCfgRecord* pCfgRecord)
{
	CComBSTR bstrErr = rstrErr;
	AddProjectError(pEC, bstrErr, bstrPrjErrCode, pCfgRecord);
}

void CVCProjectEngine::AddProjectError(IVCBuildErrorContext* pEC, CStringW& strErr, BSTR bstrPrjErrCode,
	IVCBuildActionList* pActionList)
{
	CComBSTR bstrErr = strErr;
	AddProjectError(pEC, bstrErr, bstrPrjErrCode, pActionList);
}

void CVCProjectEngine::AddProjectError(IVCBuildErrorContext* pEC, CStringW& strErr, BSTR bstrPrjErrCode, IVCBuildAction* pAction)
{
	CComBSTR bstrErr = strErr;
	AddProjectError(pEC, bstrErr, bstrPrjErrCode, pAction);
}

void CVCProjectEngine::AddProjectWarning(IVCBuildErrorContext* pEC, BSTR bstrWarn, BSTR bstrPrjWarnCode, 
	IVCPropertyContainer* pPropContainer)
{
	if (pEC == NULL)
		return;

	CComBSTR bstrProj;
	if (pPropContainer == NULL || FAILED(pPropContainer->GetStrProperty(VCPROJID_Name, &bstrProj)) || 
		bstrProj.Length() == 0)
		bstrProj.LoadString(IDS_PROJECT_WORD);
	pEC->AddWarning(bstrWarn, bstrPrjWarnCode, bstrProj, 0, NULL);
}

void CVCProjectEngine::AddProjectWarning(IVCBuildErrorContext* pEC, CStringW& strWarn, BSTR bstrPrjWarnCode,
	IVCPropertyContainer* pPropContainer)
{
	CComBSTR bstrWarn = strWarn;
	AddProjectWarning(pEC, bstrWarn, bstrPrjWarnCode, pPropContainer);
}

void CVCProjectEngine::AddProjectWarning(IVCBuildErrorContext* pEC, CStringW& strWarn, BSTR bstrPrjWarnCode, CBldCfgRecord* pCfgRecord)
{
	CComBSTR bstrWarn = strWarn;
	CComQIPtr<IVCPropertyContainer> spPropContainer;
	if (pCfgRecord)
	{
		VCConfiguration* pConfig = pCfgRecord->GetVCConfiguration();	// not ref-counted
		spPropContainer = pConfig;
	}

	AddProjectWarning(pEC, bstrWarn, bstrPrjWarnCode, spPropContainer);
}

void CVCProjectEngine::DoUpdateAfterApply()
{
	if (!s_pServiceProvider)
		return;

	CComPtr<IVsPropertyPageFrame> pPPFrame;
	HRESULT hr = s_pServiceProvider->QueryService(SID_SVsPropertyPageFrame, __uuidof(IVsPropertyPageFrame), (void**)&pPPFrame);
	if (SUCCEEDED(hr) && pPPFrame)
		pPPFrame->UpdateAfterApply();
}

/* static */
void CVCProjectEngine::ResolvePropertyContainer(IVCPropertyContainer* pPropContainer, IVCPropertyContainer** ppActualContainer)
{
	*ppActualContainer = NULL;
	if (pPropContainer == NULL)
		return;		// not a lot we can do

	CComQIPtr<IVCStagedPropertyContainer> spStagedContainer = pPropContainer;
	if (spStagedContainer)
		spStagedContainer->get_Parent(ppActualContainer);
	else
	{
		CComPtr<IVCPropertyContainer> spContainer = pPropContainer;
		*ppActualContainer = spContainer.Detach();
	}
}

/* static */
BOOL CVCProjectEngine::FLoadMlang()
{
	HRESULT hr = S_OK;

	if (!s_fInitializedCom)
	{
		hr = CoInitialize(NULL);
		RETURN_ON_FAIL2(hr, FALSE);

		s_fInitializedCom = TRUE;
	}

	if (!s_spMultiLanguage2 && !s_spMultiLanguage)
	{
		hr = CoCreateInstance(CLSID_CMultiLanguage, NULL, CLSCTX_INPROC_SERVER, __uuidof(IMultiLanguage2)
			, (void **)&s_spMultiLanguage2);
		if (FAILED(hr) || s_spMultiLanguage2 == NULL)
			hr = CoCreateInstance(CLSID_CMultiLanguage, NULL, CLSCTX_INPROC_SERVER, __uuidof(IMultiLanguage), 
			(void **)&s_spMultiLanguage);
		if (FAILED(hr) || (s_spMultiLanguage2 == NULL && s_spMultiLanguage == NULL))
			return FALSE;
	}

	return(SUCCEEDED(hr));
}

/* static */
UINT CVCProjectEngine::ConvertFromUnicodeMlang(UINT cp, BOOL fNoBestFit, BOOL fWriteEntities, LPCWSTR rgchUtf16, UINT cchUtf16, 
	LPSTR rgchMbcs, UINT cchMbcs, BOOL *pfDefCharUsed)
{
	if (!FLoadMlang())
		return(0);

	DWORD dwMode = 0;
	UINT cchSrc = cchUtf16;
	UINT cchDst = cchMbcs;
	DWORD dwFlags = fWriteEntities ? MLCONVCHARF_NCR_ENTITIZE : MLCONVCHARF_USEDEFCHAR;

	if (fNoBestFit)
		dwFlags |= MLCONVCHARF_NOBESTFITCHARS;

	HRESULT hr = S_OK;
	if (s_spMultiLanguage2)
		hr = s_spMultiLanguage2->ConvertStringFromUnicodeEx(&dwMode, cp, (WCHAR *) rgchUtf16, &cchSrc, rgchMbcs, &cchDst, 
			dwFlags, NULL);
	else
		hr = s_spMultiLanguage->ConvertStringFromUnicode(&dwMode, cp, (WCHAR *) rgchUtf16, &cchSrc, rgchMbcs, &cchDst);
	RETURN_ON_FAIL2(hr, 0);

	if (pfDefCharUsed != NULL)
		*pfDefCharUsed = (hr == S_FALSE);

	return(cchDst);
}

/* static */
BOOL CVCProjectEngine::GetCodePageName(int iCodePage, CComBSTR& bstrEncoding)
{
	bstrEncoding.Empty();

	if (!FLoadMlang())
		return FALSE;

	MIMECPINFO mimeInfo;
	HRESULT hr = S_OK;
	if (s_spMultiLanguage2)
		hr = s_spMultiLanguage2->GetCodePageInfo(iCodePage, 0, &mimeInfo);
	else
		hr = s_spMultiLanguage->GetCodePageInfo(iCodePage, &mimeInfo);
	RETURN_ON_FAIL2(hr, FALSE);
	bstrEncoding = mimeInfo.wszWebCharset;

	return TRUE;
}

/* static */
int CVCProjectEngine::GetCodePageFromCharSet(CComBSTR& bstrEncoding)
{
	if (!FLoadMlang())
		return 0;

	MIMECSETINFO mimeInfo;
	HRESULT hr = S_OK;
	if (s_spMultiLanguage2)
		hr = s_spMultiLanguage2->GetCharsetInfo(bstrEncoding, &mimeInfo);
	else
		hr = s_spMultiLanguage->GetCharsetInfo(bstrEncoding, &mimeInfo);
	RETURN_ON_FAIL2(hr, 0);

	return mimeInfo.uiCodePage;
}

// DIANEME_TODO: update CVCWebDeploymentTool to use this IISGetLocalPathForVirtualRoot instead of GetPathWWWRoot 
// once we lift the restriction on localhost.
// This version gets the FIRST vroot that we can find...  Won't work for anything other than localhost.
// Debug & use IISGetLocalPathForVirtualRoot to work with active directory & non-localhost 
/* static */
HRESULT CVCProjectEngine::GetPathWWWRoot(CComBSTR& bstrRoot)
{
	bstrRoot.Empty();
	HRESULT hr = S_OK;
	if (!s_fInitializedCom)
	{
		hr = CoInitialize(NULL);
		RETURN_ON_FAIL(hr);

		s_fInitializedCom = TRUE;
	}

	if (s_bstrIISRoot.Length() == 0)
	{
		CComPtr<IMSAdminBase> spAdmBase;
		hr = spAdmBase.CoCreateInstance(CLSID_MSAdminBase);
		RETURN_ON_FAIL_OR_NULL(hr, spAdmBase);

		METADATA_HANDLE hRootHandle = NULL;
		CStringW strKey(L"/LM/W3SVC/1");

		hr = spAdmBase->OpenKey(METADATA_MASTER_ROOT_HANDLE, strKey, METADATA_PERMISSION_READ, 20, &hRootHandle);
		RETURN_ON_FAIL(hr);

		METADATA_RECORD mr;
		ZeroMemory(&mr, sizeof(mr));
		DWORD dwLen = 0;
		int n = 0;
		CTempBuffer<wchar_t, MAX_PATH> buff;
		
		mr.pbMDData = (unsigned char*)(wchar_t*)buff.Allocate(MAX_PATH);
		mr.dwMDDataLen = MAX_PATH * sizeof(wchar_t); //size in bytes
		mr.dwMDDataType = ALL_METADATA;
		mr.dwMDUserType = IIS_MD_UT_WAM;
		mr.dwMDAttributes = METADATA_INHERIT;
		mr.dwMDIdentifier = MD_VR_PATH;
		hr = spAdmBase->GetData(hRootHandle, L"/ROOT", &mr, &dwLen);
		if (SUCCEEDED(hr))
		{
			CPathW pathRoot;
			if (pathRoot.Create(buff) && pathRoot.ExistsOnDisk())
				s_bstrIISRoot = buff;
		}
		else if (hr == E_ACCESSDENIED)
			s_bstrIISRoot = L"!admin";

		spAdmBase->CloseKey(hRootHandle);
	}

	bstrRoot = s_bstrIISRoot;
	return (bstrRoot.Length() > 0 ? S_OK : E_FAIL);
}

static void BuildPath(CStringW& strDir, LPCOLESTR pszFilename);
static void UrlSlashToPathSlash(LPOLESTR pBuff);
static void SplitUrl2(LPCOLESTR pszUrl, CStringW& strProtocol, CStringW& strServer, CStringW& strPort, CStringW& strWebPath);
static void SplitUrl(LPCOLESTR pszUrl, CStringW& strServer, CStringW& strWeb);
static void ReplaceLocalHost(CStringW& strServerName);
static BOOL FIsIPAddr(CStringW& strDNSName);
static HRESULT GetServerDescriptors(LPCWSTR pszWebUrl,     // IN: full web url
                          BOOL *pbIsRootDir,         // OUT: set to true if this project is at a root
                          CStringW &strServerDNSName,// OUT: server name
                          CStringW &strAdsWebDirPath,// OUT: /Root/webdir - ADS path to web directory
                          CStringW &strPortNum,      // OUT: port server is on
                          CStringW &strIPAddr);       // OUT server ip addr
static void CreateIISBindings(LPCWSTR pszPortNum,  // IN: port for server
                      LPCWSTR pszIPAddr,   // IN: server ipaddr
                      CStringW &strIISBindingsGenericMatch,   // OUT: generic k2 binding string
                      CStringW &strIISBindingsBestMatch);      // OUT: best binding
static void CreateADSRootPath(LPCWSTR pszServerDNSName,   // IN: server name
                       CString &strADSRootPath); // OUT: path to root

/* static */
HRESULT CVCProjectEngine::InitAdminBase()
{
	if (s_spAdminBase != NULL)
		return S_OK;

	HRESULT hr = S_OK;
	if (!s_fInitializedCom)
	{
		hr = CoInitialize(NULL);
		RETURN_ON_FAIL(hr);

		s_fInitializedCom = TRUE;
	}

    // Create the IIS admin base object
    return ::CoCreateInstance(CLSID_MSAdminBase, NULL, CLSCTX_SERVER, __uuidof(IMSAdminBase), (void**)&s_spAdminBase);
}

//---------------------------------------------------------------------------
// It uses the IIS metabase to lookup the local path for the given virtual root.
//---------------------------------------------------------------------------
// DIANEME_TODO: update CVCWebDeploymentTool to use this method once we lift the restriction on localhost
// This version finds the actual path for the given vroot.  Adapted from VSProject code of the same name(s).
// Currently using GetPathWWWRoot since we're only after localhost.
/* static */	
HRESULT CVCProjectEngine::IISGetLocalPathForVirtualRoot(LPCWSTR pszWebUrl, CStringW& strLocalPath)
{
	// Init return value
	strLocalPath.Empty();

	CStringW strWebNum;
	HRESULT hr = IISGetWebNumberForUrl(pszWebUrl, strWebNum);

	if(FAILED(hr))
		strWebNum = L"1";

	// Create the IIS admin base object
	hr = InitAdminBase();
	RETURN_ON_FAIL(hr);

	VSASSERT(s_spAdminBase, "Hey, how did we get this far with no IMSAdminBase service?");
	RETURN_ON_NULL(s_spAdminBase);

	// We are going to walk forward starting at the root until we get the best match for the vroot. As we walk forward,
	// if we get the same path in subsequent calls we stop and append the remaining vroot path. We need to
	// do this because IIS doesn't purge metadata information and when you ask for the path of a folder which no longer
	// exists it may return the iis root path. 

	CStringW strVRootPath;
	WCHAR szPath [MAX_PATH + 1];
	METADATA_RECORD mdrNewVrootData;
	ZeroMemory(&mdrNewVrootData, sizeof(mdrNewVrootData));

	mdrNewVrootData.dwMDIdentifier = MD_VR_PATH;
	mdrNewVrootData.dwMDAttributes = METADATA_INHERIT;
	mdrNewVrootData.dwMDUserType = IIS_MD_UT_FILE;
	mdrNewVrootData.dwMDDataType = STRING_METADATA;
	mdrNewVrootData.pbMDData = (PBYTE)szPath;
	mdrNewVrootData.dwMDDataLen = (_MAX_PATH) * sizeof (WCHAR);
	mdrNewVrootData.dwMDDataTag = 0;  // datatag is a reserved field.
	strVRootPath = L"/LM/W3SVC/";
	strVRootPath += strWebNum + L"/root";
	DWORD dwReqLen;

    // Get the trailing vroot part
    CStringW strVRoot;
    CStringW strServer;
	SplitUrl(pszWebUrl, strServer, strVRoot);

	// Algorithm below requires a leading slash
	if(strVRoot[0] != L'/')
		strVRoot.Insert(0, L'/');
        
	// Setup our string pointers. We use them in the loop to walk forward slash by slash. pszCurrent points to
	// the current one we are attempting, pszNext points to the next token
	WCHAR* pszCurrent = strVRoot.GetBuffer(MAX_PATH+1);
	WCHAR* pszNext = pszCurrent + 1;
	while(TRUE)
	{
		METADATA_HANDLE hVRootHandle = 0;
		hr = s_spAdminBase->OpenKey(METADATA_MASTER_ROOT_HANDLE, strVRootPath.GetBuffer(MAX_PATH+1), METADATA_PERMISSION_READ, 1000, &hVRootHandle);
		strVRootPath.ReleaseBuffer();
		if (FAILED(hr)) // Break outta here on any failure
			break;

		// VRoot found. Get the local path (note that we must reset the datalength each time through)
		mdrNewVrootData.dwMDDataLen = (_MAX_PATH) * sizeof (WCHAR);
		hr = s_spAdminBase->GetData(hVRootHandle, L"/", &mdrNewVrootData, &dwReqLen);
		// Close the key we opened
		s_spAdminBase->CloseKey(hVRootHandle);
		if (FAILED(hr)) // Break outta here on any failure
			break;

		// If path matches the last path, we are done and we will append the remaining vroot onto it.
		if (strLocalPath.CompareNoCase(szPath) == 0)
		{
			break;
		}
		else
		{   // Paths differ. Update to the new path and we will try again
			strLocalPath = szPath;

			// Find the next slash, or end.
			pszCurrent = pszNext;
			if(pszCurrent == NULL || *pszCurrent == 0)
				break;
			pszNext = wcschr(pszNext, L'/');
			if(pszNext)
			{
				*pszNext = 0;
				strVRootPath += L'/';
				strVRootPath += pszCurrent;
				*pszNext = L'/';
				pszNext++;
			}
			else
			{   // No more slashes, just add in the last one.
				strVRootPath += L'/';
				strVRootPath += pszCurrent;
			}
		}
	}

	// Just append the remaining part (pszCurrent) to get the full path. 
	if (!strLocalPath.IsEmpty())
	{
		if (pszCurrent && *pszCurrent != 0)
		{
			UrlSlashToPathSlash(pszCurrent);
			BuildPath(strLocalPath, pszCurrent);
		}
		hr = S_OK;
	}

	return hr;
}

//---------------------------------------------------------------------------
// Returns the IIS web number for the given url
//---------------------------------------------------------------------------
/* static */
HRESULT CVCProjectEngine::IISGetWebNumberForUrl(LPCWSTR pszWebUrl, CStringW& strWebNum)
{
	CStringW strServerDNSName;
	CStringW strAdsWebDirPath;
	CStringW strPortNum;
	CStringW strIPAddr;
	CStringW strIISBindingsGenericMatch;
	CStringW strIISBindingsBestMatch;
	CStringW strADSRootPath;
	BOOL    bIsRootDir;

	// First get some information about the target server
	HRESULT hr = GetServerDescriptors(pszWebUrl, &bIsRootDir, strServerDNSName, strAdsWebDirPath, strPortNum, strIPAddr);
	RETURN_ON_FAIL(hr);

	// Create IIS bindings. Used to get server number
	CreateIISBindings(strPortNum, strIPAddr, strIISBindingsGenericMatch, strIISBindingsBestMatch);
	CreateADSRootPath(strServerDNSName, strADSRootPath);

	// Go get the web number
	return GetWebNumberForServer(strADSRootPath, strIISBindingsGenericMatch, strIISBindingsBestMatch, strWebNum);
}   

//---------------------------------------------------------------------------
// Returns the web number of the IIS server which best matches the bindings 
// passed in. It's ugly, real ugly
//---------------------------------------------------------------------------
/* static */
HRESULT CVCProjectEngine::GetWebNumberForServer(LPCWSTR pszADSRootPath,           // IN: path to ads root
                              const CStringW& strIISBindingsGenericMatch, // IN: generic IIS bindings
                              const CStringW& strIISBindingsBestMatch,   // IN: best IIS bindings
                              CStringW &strWebNum)               // OUT: web number
{
	CComPtr<IADsContainer> srpContainer;
	IEnumVARIANT* pEnum = NULL; // Not a smartptr since we need to free it with ADsFreeEnumerator().
	CComPtr<IADs> srpChild;
	CComPtr<IADs> srpMatch;
	CComPtr<IADs> srpNonStartedMatch;
	CComPtr<IADs> srpADsRoot;
	int idHelp = 0;
	CComVariant varTemp;
	BOOL bFound = FALSE;
	HRESULT hr;

	// Get the ActiveDs wrapper object. If ADSI is not installed we return a web number of 1 adn S_FALSE
	if (s_pAdsiWrapper == NULL)
	{
		s_pAdsiWrapper = new CAdsiWrapper();
        // Init the wrapper. If it fails we clean up the object
        if(s_pAdsiWrapper && s_pAdsiWrapper->Init() == FALSE)
        {
            delete s_pAdsiWrapper;
            s_pAdsiWrapper = NULL;
        }
	}
	if(s_pAdsiWrapper == NULL)
	{
		DoSetErrorInfo(E_FAIL, IDS_E_ADSI_NOTINSTALLED);
		return E_FAIL;
	}

	hr = s_pAdsiWrapper->ADsGetObject(pszADSRootPath, __uuidof(IADs), reinterpret_cast<void **>(&srpADsRoot));
	if(FAILED(hr)) 
	{	// IIS changed their schema between ver4 and ver5. This means we can't set the approot on 
		// an iis4 machine from an iis5 machine.
		if(hr == MD_ERROR_IISAO_INVALID_SCHEMA)
		{
			DoSetErrorInfo(MD_ERROR_IISAO_INVALID_SCHEMA, IDS_E_CANTCFG_APPROOT_IIS4_FROM_IIS5);
		}
		goto done;
	}        

	// Find the correct server number for this server.
	hr = srpADsRoot->QueryInterface(__uuidof(IADsContainer), (void **)&srpContainer);
	if(SUCCEEDED(hr))
		hr = s_pAdsiWrapper->ADsBuildEnumerator(srpContainer, &pEnum);
	if(FAILED(hr)) 
		goto done;

	while (!bFound && (S_OK == (hr = s_pAdsiWrapper->ADsEnumerateNext(pEnum, 1, &varTemp, NULL))))
	{
		CComBSTR bstrTemp1;
		// This should be a dispatch interface...
		if (varTemp.vt != VT_DISPATCH) 
		{
			VSASSERT(FALSE, "Wrong kind of item in ADs enumerator!");
			varTemp.Clear();
			continue;
		}
		if (varTemp.pdispVal == NULL)
		{
			VSASSERT(FALSE, "Null pointer in ADs enumerator!");
			varTemp.Clear();
			continue;
		}

		// The class of the ADSI object needs to be IIS_CLASS_WEB_SERVER
		srpChild = NULL;
		hr = varTemp.pdispVal->QueryInterface(__uuidof(IADs), (void **)&srpChild);
		if(SUCCEEDED(hr) && srpChild != NULL)
			hr = srpChild->get_Class(&bstrTemp1);

		// Free IDispatch
		varTemp.Clear();
		if(FAILED(hr) || !bstrTemp1 || wcscmp(IIS_CLASS_WEB_SERVER_W, bstrTemp1)) 
		{   
			continue;
		}

		// We have a web server. Is this THE ONE?
		hr = srpChild->Get(L"ServerBindings", &varTemp);
		if(FAILED(hr) || V_VT(&varTemp) != (VT_ARRAY|VT_VARIANT)) 
		{
			VSASSERT(FALSE, "Bad server binding!");
			varTemp.Clear();
			continue;
		}
		SAFEARRAY *psaBindings = V_ARRAY(&varTemp);
		if(::SafeArrayGetDim(psaBindings) != 1) 
		{
			varTemp.Clear();
			VSASSERT(FALSE, "Bad server binding!");
			continue;
		}
		long lLBound, lUBound;
		hr = ::SafeArrayGetLBound(psaBindings, 1, &lLBound);
		if SUCCEEDED(hr)
			hr = ::SafeArrayGetUBound(psaBindings, 1, &lUBound);
		if (FAILED(hr)) 
		{
			varTemp.Clear();
			VSASSERT(FALSE, "Bad server binding!");
			continue;
		}
		// Iterate over the bindings list looking for a match
		for (long l = lLBound; l <= lUBound && SUCCEEDED(hr); l++) 
		{
			CComVariant varItem;
			hr = ::SafeArrayGetElement(psaBindings, &l, &varItem);
			if (FAILED(hr) || V_VT(&varItem) != (VT_BSTR) || varItem.bstrVal == NULL) 
			{
				VSASSERT(FALSE, "Bad server binding!");
				continue;
			}
			if(!_wcsnicmp(strIISBindingsBestMatch, V_BSTR(&varItem), strIISBindingsBestMatch.GetLength()))
			{	// exact match. We're done
				srpMatch = srpChild;
				bFound = TRUE;
				break;
			} 
			else if(!_wcsnicmp(strIISBindingsGenericMatch, V_BSTR(&varItem),  strIISBindingsGenericMatch.GetLength()))
			{	// So far this is the best match. See if this web server is started. If so, set it as a match.
				// We have a web server. Is this THE ONE?
				CComVariant varState;
				hr = srpChild->Get(L"ServerState", &varState);
				if(SUCCEEDED(hr) && varState.vt == (VT_I4) && varState.lVal == MD_SERVER_STATE_STARTED) 
				{
					srpMatch = srpChild;
					continue;
				}
				else if(srpNonStartedMatch == NULL)
				{	// Save it as a nonstarted server. We will use this in the end if all else fails and there are
					// no started servers.
					srpNonStartedMatch = srpChild;
				}
			}
		}
		// Free the safeArray
		varTemp.Clear();
	}

	// If all we got were non started servers we use it
	if(srpMatch == NULL && srpNonStartedMatch)
		srpMatch = srpNonStartedMatch;

	// Get the web number. It is the name of the match object. 
	if(srpMatch) 
	{
		CComBSTR bstrWebNum;
		hr = srpMatch->get_Name(&bstrWebNum);
		if(SUCCEEDED(hr)) 
			strWebNum = bstrWebNum;
	} 
	else 
	{	// Did not find anything
		hr = E_FAIL;
	}

done:
	if(pEnum)
	{   // Free ourr enumerator
		VSASSERT(s_pAdsiWrapper, "How did we get an enumerator without an active directory wrapper?");
		s_pAdsiWrapper->ADsFreeEnumerator(pEnum);
	}
	return hr;
}

HRESULT CVCProjectEngine::GetOpenFileNameViaDlg( VSOPENFILENAMEW* pOpenFileName )
{
	HRESULT hr = S_FALSE;
	CComPtr<IVsUIShell> pShell;
	if (s_pServiceProvider)
		hr = s_pServiceProvider->QueryService( SID_SVsUIShell, &pShell );
	if (pShell)
		hr = pShell->GetOpenFileNameViaDlg( pOpenFileName );
	return hr;
}

HRESULT CVCProjectEngine::GetDirViaDlg( VSBROWSEINFOW* pDir )
{
	HRESULT hr = S_FALSE;
	CComPtr<IVsUIShell> pShell;
	if (s_pServiceProvider)
		hr = s_pServiceProvider->QueryService( SID_SVsUIShell, &pShell );
	if (pShell)
		hr = pShell->GetDirectoryViaBrowseDlg(pDir);
	return hr;
}

/* static */
HRESULT CVCProjectEngine::DoSetErrorInfo(HRESULT hrErr, long idErr, BOOL bReportError /* = TRUE */, 
	BSTR bstrHelpTopic /* = NULL */, BOOL bErrorInfoOnly /* = TRUE */)
{
	VCASSERTME(hrErr);

	if (bReportError)
	{
		CComBSTR bstrErr;
		bstrErr.LoadString(idErr);
		HandleSetErrorInfo(hrErr, bstrErr, bstrHelpTopic, bErrorInfoOnly);
	}

	return hrErr;
}

/* static */
HRESULT CVCProjectEngine::DoSetErrorInfo2(HRESULT hrErr, long idErr, LPCOLESTR szParam, BOOL bReportError /* = TRUE */, 
	BSTR bstrHelpTopic /* = NULL */, BOOL bErrorInfoOnly /* = TRUE */)
{
	if (bReportError)
	{
		CStringW strErr;
		strErr.Format(idErr, szParam);
		CComBSTR bstrErr = strErr;
		HandleSetErrorInfo(hrErr, bstrErr, bstrHelpTopic, bErrorInfoOnly);
	}

	return hrErr;
}

/* static */
HRESULT CVCProjectEngine::DoSetErrorInfo3(HRESULT hrErr, long idErr, LPCOLESTR szParam1, LPCOLESTR szParam2, 
	BOOL bReportError /*= TRUE */, BSTR bstrHelpTopic /* = NULL */, BOOL bErrorInfoOnly /* = TRUE */)
{
	if (bReportError)
	{
		CStringW strErr;
		strErr.Format(idErr, szParam1, szParam2);
		CComBSTR bstrErr = strErr;
		HandleSetErrorInfo(hrErr, bstrErr, bstrHelpTopic, bErrorInfoOnly);
	}

	return hrErr;
}

/* static */
HRESULT CVCProjectEngine::HandleSetErrorInfo(HRESULT hrError, LPCOLESTR pszDescription, BSTR bstrHelpTopic, 
	BOOL bErrorInfoOnly)
{
	if (hrError == S_OK)
	{
		if (pszDescription == NULL)
		return (::SetErrorInfo(0, NULL));
	}

	CComPtr<ICreateErrorInfo> spCreateErrInfo;
	CComPtr<IErrorInfo> spErrInfo;
	HRESULT hr = ::CreateErrorInfo(&spCreateErrInfo);
	RETURN_ON_FAIL(hr);
	hr = spCreateErrInfo->SetDescription((LPOLESTR)pszDescription);
	RETURN_ON_FAIL(hr);
	hr = spCreateErrInfo->SetGUID(GUID_NULL);
	RETURN_ON_FAIL(hr);
	hr = spCreateErrInfo->SetHelpContext(0);
	RETURN_ON_FAIL(hr);
	hr = spCreateErrInfo->QueryInterface(__uuidof(IErrorInfo), (void **)&spErrInfo);
	RETURN_ON_FAIL(hr);
	::SetErrorInfo(0, spErrInfo);
	if (bErrorInfoOnly)
		return hrError;

	CComQIPtr<IVCProjectEngineImpl> spProjEngineImpl = g_pProjectEngine;
	if (spProjEngineImpl)
	{
		CComBSTR bstrErr = pszDescription;
		spProjEngineImpl->DoFireReportError(bstrErr, hrError, bstrHelpTopic);
	}

	return hrError;
}

HRESULT ExternalQueryService(REFGUID rsid, REFIID iid, void **ppvObj)
{
	CHECK_POINTER_NULL(ppvObj);
	*ppvObj = NULL;
	RETURN_ON_NULL2(CVCProjectEngine::s_pServiceProvider, S_FALSE);
	return CVCProjectEngine::s_pServiceProvider->QueryService(rsid, iid, ppvObj);
}

HRESULT DoSetErrorInfo(HRESULT hrErr, long idErr, BOOL bReport /* = TRUE */)
{
	return CVCProjectEngine::DoSetErrorInfo(hrErr, idErr, bReport);
}

HRESULT DoSetErrorInfo2(HRESULT hrErr, long idErr, LPCOLESTR szParam, BOOL bReport /* = TRUE */)
{
	return CVCProjectEngine::DoSetErrorInfo2(hrErr, idErr, szParam, bReport);
}

HRESULT DoSetErrorInfo3(HRESULT hrErr, long idErr, LPCOLESTR szParam1, LPCOLESTR szParam2, BOOL bReport /* = TRUE */)
{
	return CVCProjectEngine::DoSetErrorInfo3(hrErr, idErr, szParam1, szParam2, bReport);
}

//---------------------------------------------------------------------------
// This class does a loadlibrary on the active directory services dll, and 
// exposes methods to call its functions.
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
// Constructor.
//---------------------------------------------------------------------------
CAdsiWrapper::CAdsiWrapper() :
	m_hAdsiLib(NULL),
	m_pADsGetObject(NULL),
	m_pADsBuildEnumerator(NULL),
	m_pADsEnumerateNext(NULL),
	m_pADsFreeEnumerator(NULL),
	m_pADsGetLastError(NULL)
{
}

//---------------------------------------------------------------------------
// Free up our library if need be
//---------------------------------------------------------------------------
CAdsiWrapper::~CAdsiWrapper()
{
	if(m_hAdsiLib)
		::FreeLibrary(m_hAdsiLib);
}

//---------------------------------------------------------------------------
// Used to intialize the class. Will call LoadLibaryEx() to try and load
// the active directory services dll. If it fails, it returns FALSE;
//---------------------------------------------------------------------------
BOOL CAdsiWrapper::Init()
{
	BOOL bRet = FALSE;
	VSASSERT(m_hAdsiLib == NULL, "Already initialized?");
	if (m_hAdsiLib == NULL)
		m_hAdsiLib = ::LoadLibraryExW(L"activeds.dll", NULL, LOAD_WITH_ALTERED_SEARCH_PATH);
	if (m_hAdsiLib >= (HINSTANCE)HINSTANCE_ERROR) 
	{
		bRet = TRUE;
	}
	else
	{
		m_hAdsiLib = 0;
	}
	return bRet;
}

//---------------------------------------------------------------------------
// Calls the ADsGetObject() function
//---------------------------------------------------------------------------
HRESULT CAdsiWrapper::ADsGetObject(LPCWSTR pszADSRootPath, REFIID riid, void** ppADsRoot)
{
	HRESULT hr = E_UNEXPECTED;
	VSASSERT(m_hAdsiLib, "Trying to call ADsGetObject without initializing wrapper first!");
	if(m_hAdsiLib)
	{	// Get a pointer to the function if we haven't done so already.
		if (m_pADsGetObject == NULL)
			m_pADsGetObject = (fnpADsGetObject)GetProcAddress(m_hAdsiLib, "ADsGetObject");

		// Call ADsGetObject()
		if (m_pADsGetObject)
			hr = m_pADsGetObject(pszADSRootPath, riid, ppADsRoot);
	}
	return hr;
}
//---------------------------------------------------------------------------
// Calls the ADsBuildEnumerator function
//---------------------------------------------------------------------------
HRESULT CAdsiWrapper::ADsBuildEnumerator(IADsContainer *pADsContainer, IEnumVARIANT **ppEnumVariant)
{
	HRESULT hr = E_UNEXPECTED;
	VSASSERT(m_hAdsiLib, "Trying to call ADsGetObject without initializing wrapper first!");
	if (m_hAdsiLib)
	{	// Get a pointer to the function if we haven't done so already.
		if (m_pADsBuildEnumerator == NULL)
			m_pADsBuildEnumerator = (fnpADsBuildEnumerator)GetProcAddress(m_hAdsiLib, "ADsBuildEnumerator");

		// Call ADsGetObject()
		if (m_pADsBuildEnumerator)
			hr = m_pADsBuildEnumerator(pADsContainer, ppEnumVariant);
	}
	return hr;
}
//---------------------------------------------------------------------------
// Calls the ADsEnumerateNext function
//---------------------------------------------------------------------------
HRESULT CAdsiWrapper::ADsEnumerateNext(IEnumVARIANT *pEnumVariant, ULONG cElements, VARIANT* pvar, ULONG* pcElementsFetched)
{
	HRESULT hr = E_UNEXPECTED;
	VSASSERT(m_hAdsiLib, "Trying to call ADsGetObject without initializing wrapper first!");
	if(m_hAdsiLib)
	{	// Get a pointer to the function if we haven't done so already.
		if(m_pADsEnumerateNext == NULL)
			m_pADsEnumerateNext = (fnpADsEnumerateNext)GetProcAddress(m_hAdsiLib, "ADsEnumerateNext");

		// Call ADsEnumberateNext()
		if(m_pADsEnumerateNext)
			hr = m_pADsEnumerateNext(pEnumVariant, cElements, pvar, pcElementsFetched);
	}
	return hr;
}

//---------------------------------------------------------------------------
// Calls the ADsFreeEnumerator function
//---------------------------------------------------------------------------
HRESULT CAdsiWrapper::ADsFreeEnumerator(IEnumVARIANT *pEnumVariant)
{
	HRESULT hr = E_UNEXPECTED;
	VSASSERT(m_hAdsiLib, "Trying to call ADsGetObject without initializing wrapper first!");
	if(m_hAdsiLib)
	{	// Get a pointer to the function if we haven't done so already.
		if(m_pADsFreeEnumerator == NULL)
			m_pADsFreeEnumerator = (fnpADsFreeEnumerator)GetProcAddress(m_hAdsiLib, "ADsFreeEnumerator");

		// Call ADsGetObject()
		if(m_pADsFreeEnumerator)
			hr = m_pADsFreeEnumerator(pEnumVariant);
	}
	return hr;
}
//---------------------------------------------------------------------------
// Calls the ADsGetLastError function
//---------------------------------------------------------------------------
HRESULT CAdsiWrapper::ADsGetLastError(LPDWORD lpError, LPWSTR lpErrorBuf, DWORD dwErrorBufLen, LPWSTR lpNameBuf, DWORD dwNameBufLen)
{
	HRESULT hr = E_UNEXPECTED;
	VSASSERT(m_hAdsiLib, "Trying to call ADsGetObject without initializing wrapper first!");
	if (m_hAdsiLib)
	{	// Get a pointer to the function if we haven't done so already.
		if (m_pADsGetLastError == NULL)
			m_pADsGetLastError = (fnpADsGetLastError)GetProcAddress(m_hAdsiLib, "ADsGetLastError");

		// Call ADsGetObject()
		if (m_pADsGetLastError)
			hr = m_pADsGetLastError(lpError, lpErrorBuf, dwErrorBufLen, lpNameBuf, dwNameBufLen);
	}
	return hr;
}

STDMETHODIMP CVCProjectEngineEvents::DoFireItemAdded(IDispatch *pDispObj, IDispatch *pDispParent)
{
	Fire_OnItemAdded(pDispObj, pDispParent);
	return S_OK;
}

STDMETHODIMP CVCProjectEngineEvents::DoFireItemRemoved(IDispatch *pDispObj, IDispatch *pDispParent)
{
	Fire_OnItemRemoved(pDispObj, pDispParent);
	return S_OK;
}

STDMETHODIMP CVCProjectEngineEvents::DoFireItemRenamed(IDispatch *pDispObj, IDispatch *pDispParent, BSTR bstrOldName)
{
	Fire_OnItemRenamed(pDispObj, pDispParent, bstrOldName);
	return S_OK;
}

STDMETHODIMP CVCProjectEngineEvents::DoFireItemMoved(IDispatch* pItem, IDispatch* pNewParent, IDispatch* pOldParent)
{
	Fire_OnItemMoved(pItem, pNewParent, pOldParent);
	return S_OK;
}

STDMETHODIMP CVCProjectEngineEvents::DoFireItemPropertyChange(IDispatch *pDispObj, long lDispid)
{
	Fire_OnItemPropertyChange(pDispObj, lDispid);
	return S_OK;
}

STDMETHODIMP CVCProjectEngineEvents::DoFireSccEvent( IDispatch* pItem, enumSccEvent event, VARIANT_BOOL *pRet )
{
	Fire_OnSccEvent( pItem, event, pRet );
	return S_OK;
}

STDMETHODIMP CVCProjectEngineEvents::DoFireReportError( BSTR bstrErrMsg, HRESULT hrReport, BSTR bstrHelpKeyword )
{
	Fire_OnReportError( bstrErrMsg, hrReport, bstrHelpKeyword );
	return S_OK;
}

STDMETHODIMP CVCProjectEngineEvents::DoFireProjectBuildStarted(IDispatch *pCfg)
{
	Fire_OnProjectBuildStarted( pCfg );
	return S_OK;
}

STDMETHODIMP CVCProjectEngineEvents::DoFireProjectBuildFinished(IDispatch *pCfg, long warnings, long errors, VARIANT_BOOL bCancelled)
{
	Fire_OnProjectBuildFinished( pCfg, warnings, errors, bCancelled );
	return S_OK;
}

//-----------------------------------------------------------------------------
// Given protocol://server/web, splits the url into protocol://server, web
//-----------------------------------------------------------------------------
static void SplitUrl(LPCOLESTR pszUrl, CStringW& strServer, CStringW& strWeb)
{
	if (!pszUrl)
		return;

	wchar_t szTemp[_MAX_PATH+1];
	wcscpy(szTemp, pszUrl);

	// Find protocol ":"
	wchar_t* p1 = wcschr(szTemp, L':');
	if (p1)
	{   // Skip 2 slashes
		p1++;
		if (*p1 == L'/')
		{
			p1++;
			if(*p1 == L'/')
				p1++;
		}
		// Now find next slash. This denotes the end of the server part. For file urls
		// this should be file://
		p1 = _tcschr(p1, L'/');
		if (p1)
		{   // Terminate to set the server
			*p1 = 0;
			strServer = szTemp;
			// Increment to the web and assign.
			p1++;
			strWeb = p1;
		}
		else
		{   // No webname
			strServer = pszUrl;
			strWeb.Empty();
		}
	}
}

//-----------------------------------------------------------------------------
// Given a full url, http://server:80/folder1/folder2, splits the url into:
// strProtocol  - "http:"
// strPort      - "80" - empty string if no port specified
// strServer    - "server"
// strWebPath   - "folder1/folder2"
//-----------------------------------------------------------------------------
static void SplitUrl2(LPCOLESTR pszUrl, CStringW& strProtocol, CStringW& strServer, CStringW& strPort, CStringW& strWebPath)
{
	if (!pszUrl)
		return;

	wchar_t szTemp[_MAX_PATH+1];
	wcscpy(szTemp, pszUrl);

	// Find protocol ":"
	wchar_t* p1 = wcschr(szTemp, L':');
	if (p1)
	{   // Skip colon
		p1 = _wcsinc(p1);
		wchar_t temp = *p1;
		*p1 = 0;
		// Save the protocol
		strProtocol = szTemp;
		*p1 = temp;
		// Now skip leading slashes
		while(*p1 == L'/')
		{
			p1 = _wcsinc(p1);
		}
		// p1 now points to the server part
		wchar_t* pszTemp = p1;
		// Search for a port colon
		p1 = wcschr(p1, L':');
		if(p1)
		{
			*p1 = 0;
			strServer = pszTemp;
			// Search for next slash - end of port
			p1 =_tcsinc(p1);
			pszTemp = p1;
			p1 = wcschr(p1, L'/');
			if(p1)
			{
				*p1 = 0;
				strPort = pszTemp;
			}
		}
		else
		{   // No port. Find next slash and terminate. If no trailing slash
			// we are done.
			p1 = wcschr(pszTemp, L'/');
			if(p1)
				*p1 = 0;
			strServer = pszTemp;
		}
		if(p1)
		{   // Skip the slash, remainder is the webpath
			p1 =_wcsinc(p1);
			strWebPath = p1;
		}
	}
}

//-----------------------------------------------------------------------------
// Converts all forward slashes to backslashes in pBuff.
//-----------------------------------------------------------------------------
static void UrlSlashToPathSlash(LPOLESTR pBuff)
{
	if (!pBuff)
		return;

	while(*pBuff != 0)
	{
		if(*pBuff == L'/')
			*pBuff = L'\\';
		pBuff++;	// no MBCS to worry about
	}
}

//-----------------------------------------------------------------------------
// Given a path and a filename, concatanates the two correctly (handles trailing
// nontrailing slash in folder name).  If strDir is empty, this function just
// returns whatever is in pszfilename
//-----------------------------------------------------------------------------
static void BuildPath(CStringW& strDir, LPCOLESTR pszFilename)
{
	if(strDir.IsEmpty())
	{
		strDir = pszFilename;
	}
	else if(strDir[strDir.GetLength()-1] != L'\\' && pszFilename[0] != L'\\')
	{   // Folder does not have a trailing slash and filename does not have a leading slash
		strDir += L'\\';
		strDir += pszFilename;
	}
	else if(strDir[strDir.GetLength()-1] == L'\\' && pszFilename[0] == L'\\')
	{   // Folder has trailing slash and filename has a leading slash  we need to remove 
		// one of them
		strDir += &pszFilename[1];
	}
	else
	{   // Either Folder has trailing slash or filename has leading slash but not both
		strDir += pszFilename;
	}
}

//-----------------------------------------------------------------------------
// Replaces "LocalHost:port//rest of url" with "computername:port//rest of url". Note that
// url cannot have a leading protocol. It can have a trailing url, however
//-----------------------------------------------------------------------------
static void ReplaceLocalHost(CStringW& strServerName)
{
	// Replace "LocalHost" with the actual machine name if localhost is specified
	if(_wcsnicmp(LOCALHOST, strServerName, LOCALHOST_CCH) == 0)
	{	// The next char needs to be a ':' or a '\0'  or a '/' for a match
		// CString asserts if you try to index the null terminator - I think it's a bug....
		// So to get around that, we get the buffer
		LPCWSTR pszServerName = strServerName;
		if(pszServerName[LOCALHOST_CCH] == L'/' || pszServerName[LOCALHOST_CCH] == L':' || pszServerName[LOCALHOST_CCH] == L'\0') 
		{   // Get our computer name. If it fails for some reason, we stick to localhost
			CHAR szComputerName[MAX_COMPUTERNAME_LENGTH + 1];
			DWORD dwSize = sizeof(szComputerName);
			if(::GetComputerNameA(szComputerName, &dwSize))
			{
				CStringW strTemp = szComputerName;
				strTemp += strServerName.Right(strServerName.GetLength() - LOCALHOST_CCH);
				strServerName = strTemp;
			}
		}
	}
}

//---------------------------------------------------------------------------
// Validates an IP address.
//---------------------------------------------------------------------------
static BOOL FIsIPAddr(CStringW& strDNSName)
{
    // string must be only numbers and digits
    CStringW strSubstring;
    strSubstring = strDNSName.SpanIncluding(L"0123456789.");
    if (strSubstring != strDNSName)
		return FALSE;

    // now we need to see exactly 3 periods
    int cPeriods = 0;   // number of .'s seen
    int cchDNSName = strDNSName.GetLength();
    for (int i = 0; i < cchDNSName; i++)
    {
        if ( strDNSName.GetAt(i) == L'.')
            cPeriods++;
    }

    return (cPeriods == 3);
}

//---------------------------------------------------------------------------
// Helper function to find the server's name, port and ipaddr for a project
//---------------------------------------------------------------------------
static HRESULT GetServerDescriptors(LPCWSTR pszWebUrl,     // IN: full web url
                          BOOL *pbIsRootDir,         // OUT: set to true if this project is at a root
                          CStringW &strServerDNSName,// OUT: server name
                          CStringW &strAdsWebDirPath,// OUT: /Root/webdir - ADS path to web directory
                          CStringW &strPortNum,      // OUT: port server is on
                          CStringW &strIPAddr)       // OUT server ip addr
{
	USES_CONVERSION;
	HRESULT hr = E_FAIL;
	CStringW strTemp;
	CStringW strWebPath, strProtocol;
	CStringW strWork;

	// Parse ServerName string into server, port number and folder
	SplitUrl2(pszWebUrl, strProtocol, strServerDNSName, strPortNum, strWebPath);
	*pbIsRootDir = strWebPath.IsEmpty();
	strAdsWebDirPath = L"/Root";
	if (!*pbIsRootDir) 
	{
		strAdsWebDirPath += L"/";
		strAdsWebDirPath += strWebPath;
	}   

	// If no port specified, set default
	if(strPortNum.IsEmpty())
	{
		if(_wcsicmp(strProtocol, L"http:") == 0) 
			strPortNum = L"80";
		else
		{
			VSASSERT(_wcsicmp(strProtocol, L"https:") == 0, "Bad protocol!");
			strPortNum = L"443";
		}
	}
	// replace local host with machine name
	ReplaceLocalHost(strServerDNSName);

	// Determine the server machine's IP address
	if (FIsIPAddr(strServerDNSName))
	{
		strIPAddr = strServerDNSName;
		hr = S_OK;
	}
	else
	{   // We use windows sockets to get the ip address
		WSADATA wsaData;
		WORD wVersionRequested = MAKEWORD(1,1);
		if (::WSAStartup(wVersionRequested, &wsaData) == 0) 
		{
			HOSTENT *pHostEnt;
			pHostEnt = ::gethostbyname(W2A(strServerDNSName));
			if(pHostEnt)
			{
				struct in_addr addr;
				memcpy (&addr, pHostEnt->h_addr_list[0], sizeof(addr));
				strIPAddr = A2W(::inet_ntoa(addr));
				hr = S_OK;
			}
			// Must cleanup the sockets
			WSACleanup();
		}
	}
	return hr;
}

//---------------------------------------------------------------------------
// Creates binding strings for IIS
//---------------------------------------------------------------------------
static void CreateIISBindings(LPCWSTR pszPortNum,  // IN: port for server
                      LPCWSTR pszIPAddr,   // IN: server ipaddr
                      CStringW &strIISBindingsGenericMatch,   // OUT: generic k2 binding string
                      CStringW &strIISBindingsBestMatch)      // OUT: best binding
{
	strIISBindingsGenericMatch = L":";
	strIISBindingsGenericMatch += pszPortNum;
	strIISBindingsGenericMatch += L":";
	strIISBindingsBestMatch = pszIPAddr + strIISBindingsGenericMatch;
}

//---------------------------------------------------------------------------
// Create path of the ads root
//---------------------------------------------------------------------------
static void CreateADSRootPath(LPCWSTR pszServerDNSName,   // IN: server name
                       CString &strADSRootPath) // OUT: path to root
{
	// Open an ADSI DCOM connection to the server.
	strADSRootPath = L"IIS://";
	strADSRootPath += pszServerDNSName;
	strADSRootPath += "/w3svc";
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\vcpb\VCProjectEngine.h ===
// VCProjectEngine.h : Declaration of the CVCProjectEngine

#ifndef __VCPROJECTENGINE_H_
#define __VCPROJECTENGINE_H_

#include "VcpbengCP.h"
#include "comlist.h"
#include "scriptexecutor.h"
#include <vccolls.h>
#include <vcmap.h>
#include "PropContainer.h"
#include "vcprojcnvt2.h"
#include <iadmw.h>
#include <iiscnfg.h>

interface IVSMDPropertyGrid;
interface IVsHelp;

class CBldCfgRecord;

// forward declarations
class CAdsiWrapper;

/////////////////////////////////////////////////////////////////////////////
// CVCProjectEngine
class ATL_NO_VTABLE CVCProjectEngineEvents : 
	public CComObjectRoot,
	public IVCProjectEngineEventsImpl,
	public IConnectionPointContainerImpl<CVCProjectEngineEvents>,
	public CProxy_IVCProjectEngineEvents<CVCProjectEngineEvents, &DIID__dispVCProjectEngineEvents>,
	public IProvideClassInfo2Impl<&CLSID_VCProjectEngineEvents, &DIID__dispVCProjectEngineEvents, &LIBID_VCProjectEngineLibrary, PublicProjBuildTypeLibNumber, /*unused =*/ 0, CVsTypeInfoHolder>,
	public IDispatchImpl<_VCProjectEngineEvents, &IID__VCProjectEngineEvents, &LIBID_VCProjectEngineLibrary, PublicProjBuildTypeLibNumber, /*unused =*/ 0, CVsTypeInfoHolder>
{
public:
BEGIN_COM_MAP(CVCProjectEngineEvents)
	COM_INTERFACE_ENTRY(_VCProjectEngineEvents)
	COM_INTERFACE_ENTRY(IVCProjectEngineEventsImpl)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IConnectionPointContainer)
	COM_INTERFACE_ENTRY(IProvideClassInfo)
	COM_INTERFACE_ENTRY(IProvideClassInfo2)
END_COM_MAP()

BEGIN_CONNECTION_POINT_MAP(CVCProjectEngineEvents)
	CONNECTION_POINT_ENTRY(DIID__dispVCProjectEngineEvents)
END_CONNECTION_POINT_MAP()

public:
	STDMETHOD(DoFireItemAdded)(IDispatch *pDispObj, IDispatch *pDispParent);
	STDMETHOD(DoFireItemRemoved)(IDispatch *pDispObj, IDispatch *pDispParent);
	STDMETHOD(DoFireItemRenamed)(IDispatch *pDispObj, IDispatch *pDispParent, BSTR bstrOldName);
	STDMETHOD(DoFireItemMoved)(IDispatch* pDispObj, IDispatch* pNewParent, IDispatch* pOldParent);
	STDMETHOD(DoFireItemPropertyChange)(IDispatch *pDispObj, long lDispid);
	STDMETHOD(DoFireSccEvent)(IDispatch* pItem, enumSccEvent event, VARIANT_BOOL *pRet);
	STDMETHOD(DoFireReportError)(BSTR bstrErrMsg, HRESULT hrReport, BSTR bstrHelpKeyword);
	STDMETHOD(DoFireProjectBuildStarted)(IDispatch *pCfg);
	STDMETHOD(DoFireProjectBuildFinished)(IDispatch *pCfg, long errors, long warnings, VARIANT_BOOL bCancelled);

	static HRESULT CreateInstance(_VCProjectEngineEvents** ppDisp)
	{
		CComObject<CVCProjectEngineEvents> *pObj;
		HRESULT hr = CComObject<CVCProjectEngineEvents>::CreateInstance(&pObj);
		if (SUCCEEDED(hr))
		{
			CVCProjectEngineEvents *pVar = pObj;
			pVar->AddRef();
			*ppDisp = pVar;
		}
		return hr;
	}
};

class ATL_NO_VTABLE CVCProjectEngine : 
	public CComObjectRoot,
	public CComCoClass<CVCProjectEngine, &CLSID_VCProjectEngineObject>,
	public IConnectionPointContainerImpl<CVCProjectEngine>,
	public CPropertyContainerImpl,
	public CProxy_IVCProjectEngineEvents<CVCProjectEngine, &__uuidof(IVCProjectEngineEvents)>,
	public IDispatchImpl<VCProjectEngine, &IID_VCProjectEngine, &LIBID_VCProjectEngineLibrary, PublicProjBuildTypeLibNumber, /*unused =*/ 0, CVsTypeInfoHolder>,
	public IVCProjectEngineImpl
{
public:
	CVCProjectEngine();
	~CVCProjectEngine();


BEGIN_COM_MAP(CVCProjectEngine)
	COM_INTERFACE_ENTRY(VCProjectEngine)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IVCProjectEngineImpl)
	COM_INTERFACE_ENTRY(IConnectionPointContainer)
	COM_INTERFACE_ENTRY(IVCPropertyContainer)
END_COM_MAP()

BEGIN_CONNECTION_POINT_MAP(CVCProjectEngine)
	CONNECTION_POINT_ENTRY(__uuidof(IVCProjectEngineEvents))
END_CONNECTION_POINT_MAP()

DECLARE_VS_REGISTRY_RESOURCEID(IDR_VCPROJECTENGINE)

	static HRESULT CreateInstance(CVCProjectEngine **ppProjectEngine);

// IVCProjectEngineImpl
public:
	// Review: this should probably be public ?
	STDMETHOD(get_SuppressUI)(/*[out, retval]*/ VARIANT_BOOL *pVal); // don't trigger anything that would cause ui
	STDMETHOD(put_SuppressUI)(/*[in]*/ VARIANT_BOOL newVal);
	// Does any and all initialization
	STDMETHOD(Initialize)(LONG_PTR hInst, IUnknown *pSP, IVSMDPropertyBrowser *pBrowser, IVCBuildPackageInternal* pBuildPackage);
	STDMETHOD(Close)();
	STDMETHOD(DoFireItemAdded)(IDispatch *pDispObj, IDispatch *pDispParent);
	STDMETHOD(DoFireItemRemoved)(IDispatch *pDispObj, IDispatch *pDispParent);
	STDMETHOD(DoFireItemRenamed)(IDispatch *pDispObj, IDispatch *pDispParent, BSTR bstrOldName);
	STDMETHOD(DoFireItemMoved)(IDispatch* pDispObj, IDispatch* pNewParent, IDispatch* pOldParent);
	STDMETHOD(DoFireItemPropertyChange)(IDispatch *pDispObj, long lDispid);
	STDMETHOD(DoFireSccEvent)(IDispatch* pItem, enumSccEvent event, VARIANT_BOOL *pRet);
	STDMETHOD(DoFireReportError)(BSTR bstrErrMsg, HRESULT hrReport, BSTR bstrHelpKeyword);
	STDMETHOD(DoFireProjectBuildStarted)(IDispatch *pCfg);
	STDMETHOD(DoFireProjectBuildFinished)(IDispatch *pCfg, long errors, long warnings, VARIANT_BOOL bCancelled);
	STDMETHOD(CreatePropertyGrid)(IVSMDPropertyGrid**);
	STDMETHOD(GetHelp)(IVsHelp **ppHelp);
	STDMETHOD(get_BuildEngine)(IDispatch **ppBuildEngine);
	STDMETHOD(WriteLog)(LPCOLESTR szOut, BOOL bAppendCRLF);
	STDMETHOD(get_DialogOwner)(HWND *pHwnd);
	STDMETHOD(EnableModeless)(BOOL bEnable);
	STDMETHOD(LoadProjectUnderShell)(LPCOLESTR szProject, IDispatch **pProject);
	STDMETHOD(RemoveProjectUnderShell)(IDispatch * pProject);
	STDMETHOD(UnloadStyleSheet)(IDispatch* pStyleSheet);	// call this to tell project engine we're done with this style sheet
	STDMETHOD(get_AllStyleSheets)(IDispatch** ppStyleSheets);
	STDMETHOD(CreateHiddenStyleSheet)(LPCOLESTR szName, IDispatch **ppDispStyle);
	STDMETHOD(LoadHiddenStyleSheet)(LPCOLESTR szStyleSheet, IDispatch **ppDispStyle);
	STDMETHOD(GetIVCProjConvert)( IUnknown ** ppDispProjConvert );
	STDMETHOD(GetSKU)( long *pSKU );
	STDMETHOD(GetDialogFont)( BOOL bBold, HFONT *pHFont );
	STDMETHOD(get_VendorTools)(IDispatch** ppVendorTools);
	STDMETHOD(AddVendorTool)(LPCOLESTR szToolName, LPCOLESTR szToolGUID, IDispatch** ppVendorTool);
	STDMETHOD(GetStringForPropertyID)(long nID, BSTR* pbstrString);

// VCProjectEngine
public:
	STDMETHOD(get_BuildLogging)(VARIANT_BOOL * pbLog);
	STDMETHOD(put_BuildLogging)(VARIANT_BOOL pbLog);
	STDMETHOD(get_BuildTiming)(VARIANT_BOOL * pbTime);
	STDMETHOD(put_BuildTiming)(VARIANT_BOOL pbTime);
	STDMETHOD(get_Platforms)(IDispatch * * ppPlatforms);
	STDMETHOD(get_Projects)(IDispatch * * ppProjects);
	STDMETHOD(get_StyleSheets)(IDispatch** ppStyleSheets);
	STDMETHOD(CreateProject)(BSTR szProject, IDispatch * * pProject);
	STDMETHOD(LoadProject)(BSTR szProject, IDispatch * * pProject);
	STDMETHOD(RemoveProject)(IDispatch * pProject);
	STDMETHOD(LoadStyleSheet)(BSTR bstrName, IDispatch **ppDispStyle);
	STDMETHOD(CreateStyleSheet)(BSTR bstrName, IDispatch **ppDispStyle);
	STDMETHOD(RemoveStyleSheet)(IDispatch* pDispStyle);
	STDMETHOD(get_PerformanceLogging)(VARIANT_BOOL *pbLog);
	STDMETHOD(put_PerformanceLogging)(VARIANT_BOOL bLog);
	STDMETHOD(IsSystemInclude)(BSTR bstrInclude, VARIANT_BOOL *pbInclude);
	STDMETHOD(get_Events)(IDispatch **pProjecEngineEvents);
	STDMETHOD(Evaluate)(BSTR In, BSTR* Out) { return CPropertyContainerImpl::Evaluate(In, Out); }

// IVCPropertyContainer; most methods in base class
public:
	STDMETHOD(GetMultiProp)(long id, LPCOLESTR szSeparator, VARIANT_BOOL bSkipLocal, BSTR *varValue);

// default ISpecifyPropertyPages method in base class
       
protected:
	HRESULT GetPlatforms();
	HRESULT DoGetProp(long id, VARIANT* pvarValue);
	HRESULT DoSetProp(long id, BOOL bCheckSpecial, VARIANT varValue, long nOverrideID = -1);
	HRESULT DoSetStrProperty(long idProp, BOOL bCheckSpecial, BSTR bstrValue, long nOverrideID = -1);
	HRESULT DoSetBoolProperty(long idProp, BOOL bCheckSpecial, VARIANT_BOOL bValue, long nOverrideID = -1);
	virtual BOOL CheckCanDirty() { return FALSE; }
	HRESULT DoLoadHiddenStyleSheet(LPCOLESTR szStyleSheet, VCStyleSheet** ppStyleSheet, IDispatch** ppDispStyleSheet);
	HRESULT DoCreateHiddenStyleSheet(LPCOLESTR szStyleSheet, VCStyleSheet** ppStyle, IDispatch** ppDispStyle);
	HRESULT DoRemoveStyleSheet(IDispatch* pDispStyle, BOOL bRemoveFromHiddenList);
	HRESULT SetBuildLogging(VARIANT_BOOL bLog, bool bPersist);
	HRESULT SetBuildTiming(VARIANT_BOOL bTime, bool bPersist);
	HRESULT SetPerformanceLogging(VARIANT_BOOL bLog, bool bPersist);

// helper functions
protected:
	HRESULT LoadXML( BSTR bstrFile, IDispatch **ppDispProject );
	HRESULT DoInitialize(LONG_PTR hInst, IUnknown *pSP, IVSMDPropertyBrowser *pBrowser, IVCBuildPackageInternal* pBuildPackage,
		BOOL bForceInit);
	void ClearPlatforms();

protected:
	DWORD m_dwCookieComposite;	// cookie for RunningObjectTable for the composite moniker

	VARIANT_BOOL m_bPerformanceLogging;	// Do we log performance statistics to stdout?; NOTE: if unhidden, USE PROPCONTAINER SPACE FOR IT
	VARIANT_BOOL m_bSuppressUI;	// Try not to trigger any UI when this is true

	bool m_bInitialized;		// Have we truly been initialized....
	bool m_bSoftInitialized;	// Have we been even sort of initialized...
	CComPtr<IVSMDPropertyBrowser>	m_pPropBrowser;
	CComDynamicListTyped<VCProject> m_rgProjects; // collection of projects. 
	CComDynamicListTyped<VCStyleSheet> m_rgStyleSheets; // collection of 'visible' style sheets. 
	CComDynamicListTyped<VCStyleSheet> m_rgAllStyleSheets; // collection of *all* style sheets. 
	CComDynamicListTyped<VCPlatform> m_rgPlatforms; // collection of Platforms. 
	CComDynamicListTyped<IVCToolImpl> m_rgVendorTools;	// collection of vendor-supplied tools
	CComPtr<IActiveScriptSite> m_pScriptSite; // we use this to clean up...
	CComPtr<IVCProjConvert> m_pProjConvert;		// this is needed on the UI side to setup VC 4.x dependencies

	CComPtr<_VCProjectEngineEvents> m_pProjectEngineEvents;

	long m_nSKU;
	long m_nNextVendorID;

public:
	static BOOL DoWriteLog(LPCOLESTR szOut, BOOL bAppendCRLF = FALSE);
	static void InitializeForCommandLineUsage();
	static void AddProjectError(IVCBuildErrorContext* pEC, BSTR bstrErr, BSTR bstrPrjErrCode, IVCPropertyContainer* pPropContainer);
	static void AddProjectError(IVCBuildErrorContext* pEC, BSTR bstrErr, BSTR bstrPrjErrCode, IVCBuildActionList* pActionList);
	static void AddProjectError(IVCBuildErrorContext* pEC, BSTR bstrErr, BSTR bstrPrjErrCode, IVCBuildAction* pAction);
	static void AddProjectError(IVCBuildErrorContext* pEC, BSTR bstrErr, BSTR bstrPrjErrCode, CBldCfgRecord* pCfgRecord);
	static void AddProjectError(IVCBuildErrorContext* pEC, CStringW& strErr, BSTR bstrPrjErrCode,
		IVCPropertyContainer* pPropContainer);
	static void AddProjectError(IVCBuildErrorContext* pEC, CStringW& strErr, BSTR bstrPrjErrCode, IVCBuildAction* pAction);
	static void AddProjectError(IVCBuildErrorContext* pEC, CStringW& strErr, BSTR bstrPrjErrCode, IVCBuildActionList* pActionList);
	static void AddProjectError(IVCBuildErrorContext* pEC, CStringW& strErr, BSTR bstrPrjErrCode, CBldCfgRecord* pCfgRecord);
	static void AddProjectWarning(IVCBuildErrorContext* pEC, BSTR bstrWarn, BSTR bstrPrjWarnCode,
		IVCPropertyContainer* pPropContainer);
	static void AddProjectWarning(IVCBuildErrorContext* pEC, CStringW& strWarn, BSTR bstrPrjWarnCode,
		IVCPropertyContainer* pPropContainer);
	static void AddProjectWarning(IVCBuildErrorContext* pEC, CStringW& strWarn, BSTR bstrPrjWarnCode,
		CBldCfgRecord* pCfgRecord);
	static void DoUpdateAfterApply();
	static void GetBasePlatformInfoKey( BSTR *pbstrKey );
	static void GetPlatformInfoKey( BSTR bstrPlatform, BSTR bstrMainKey, BSTR *pbstrKey );
	static void ResolvePropertyContainer(IVCPropertyContainer* pPropContainer, IVCPropertyContainer** ppActualContainer);
	static BOOL FLoadMlang();
	static UINT ConvertFromUnicodeMlang(UINT cp, BOOL fNoBestFit, BOOL fWriteEntities, LPCWSTR rgchUtf16, UINT cchUtf16, 
		LPSTR rgchMbcs, UINT cchMbcs, BOOL *pfDefCharUsed);
	static BOOL GetCodePageName(int iCodePage, CComBSTR& bstrEncoding);
	static int GetCodePageFromCharSet(CComBSTR& bstrCharSet);
	static HRESULT GetPathWWWRoot(CComBSTR& bstrRoot);
	static HRESULT IISGetLocalPathForVirtualRoot(LPCWSTR pszWebUrl, CStringW& strLocalPath);
	static HRESULT DoSetErrorInfo(HRESULT hrErr, long idErr, BOOL bReportError = TRUE, BSTR bstrHelpTopic = NULL, 
		BOOL bErrorInfoOnly = TRUE);
	static HRESULT DoSetErrorInfo2(HRESULT hrErr, long idErr, LPCOLESTR szParam, BOOL bReportError = TRUE, 
		BSTR bstrHelpTopic = NULL, BOOL bErrorInfoOnly = TRUE);
	static HRESULT DoSetErrorInfo3(HRESULT hrErr, long idErr, LPCOLESTR szParam1, LPCOLESTR szParam2, 
		BOOL bReportError = TRUE, BSTR bstrHelpTopic = NULL, BOOL bErrorInfoOnly = TRUE);
	static HRESULT HandleSetErrorInfo(HRESULT hrErr, LPCOLESTR szErr, BSTR bstrHelpTopic, BOOL bErrorInfoOnly);

	HRESULT GetOpenFileNameViaDlg( VSOPENFILENAMEW* pOpenFileName );
	HRESULT GetDirViaDlg( VSBROWSEINFOW* pDir );

protected:
	static HRESULT InitAdminBase();
	static HRESULT IISGetWebNumberForUrl(LPCWSTR pszWebUrl, CStringW& strWebNum);
	static HRESULT GetWebNumberForServer(LPCWSTR pszADSRootPath,           // IN: path to ads root
                              const CStringW& strIISBindingsGenericMatch, // IN: generic IIS bindings
                              const CStringW& strIISBindingsBestMatch,   // IN: best IIS bindings
                              CStringW &strWebNum);               // OUT: web number

public:
	static VARIANT_BOOL s_bBuildLogging;	// Do we log builds to a file
											// NOTE: keep propcontainer IN PARALLEL WITH s_bBuildLogging
	static BOOL s_fInitializedCom;
	static IVCBuildPackageInternal* s_pBuildPackage;
	static CComPtr<IServiceProvider> s_pServiceProvider;
	static CComPtr<IMultiLanguage2> s_spMultiLanguage2;
	static CComPtr<IMultiLanguage> s_spMultiLanguage;
	static CComPtr<IMSAdminBase> s_spAdminBase;
	static HANDLE s_hLogFile;				// log file handle
	static CComBSTR s_bstrAlternateRegistryRoot;
	static CComBSTR s_bstrIISRoot;		// root to where IIS is expecting PathWWWRoot to be
	static CAdsiWrapper* s_pAdsiWrapper;
};

_declspec(selectany) VCProjectEngine * g_pProjectEngine = NULL; // NOTE: Not Addref'd.

extern BOOL g_bInProjLoad;			// project load in progres
extern HRESULT ExternalQueryService(REFGUID rsid, REFIID iid, void **ppvObj);

inline BOOL UsingRegistry( void )
{
	wchar_t buff[4096];
	buff[0] = L'0';
	::GetEnvironmentVariableW(L"VC_PROJECT_ENGINE_NOT_USING_REGISTRY_FOR_INIT", buff, 4095);
	if( buff[0] == L'1' )
	{
	    return FALSE;
	}
	return TRUE;
}

class CInLoadProject
{
public:
	CInLoadProject() { m_bOldInLoad = g_bInProjLoad; g_bInProjLoad = TRUE; }
	~CInLoadProject() { g_bInProjLoad = m_bOldInLoad; }
	BOOL m_bOldInLoad;
};

#if 0
/////////////////////////////////////////////////////////////////////////////
// CBuildPackage
// This Pkg only exists to provide VsCoCreate functionality and to provide SetSite
// The DLL is deisgned to act a co-creatable engine independant of the shell.
// This IVsPackage should provide absolute minimal functionality.
class CEnginePkg: 
    public IVsPackage,
    public IServiceProvider,
	public CComObjectRoot,
	public CComCoClass<CEnginePkg, &CLSID_EnginePackage>
{
public:
	CEnginePkg(){};
	~CEnginePkg(){};

DECLARE_REGISTRY_RESOURCEID(IDR_ENGINEPACKAGE)

BEGIN_COM_MAP(CBuildPackage)
	COM_INTERFACE_ENTRY(IVsPackage)
	COM_INTERFACE_ENTRY(IServiceProvider)
END_COM_MAP()

static CComPtr<IServiceProvider> s_pServiceProvider;
static CComPtr<IVSMDPropertyBrowser> s_pBrowser;
static CComBSTR s_bstrAlternateRegistryRoot;

// IVsPackage
public:
   	STDMETHOD(SetSite)(IServiceProvider *pSP);
	{
		RETURN_ON_NULL(pSP);
		s_pServiceProvider = pSP;

		CComPtr<IVsShell> pShell;
		HRESULT hr = pSP->QueryService(SID_SVsShell, IID_IVsShell, (void**)&pShell);
		RETURN_ON_NULL2(pShell, hr);

		CComVariant var;
		hr = pShell->GetProperty(VSSPROPID_VirtualRegistryRoot, &var);
		if(SUCCEEDED(hr) && var.vt == VT_BSTR)
			s_bstrAlternateRegistryRoot = var.bstrVal;

		pSP->QueryService( SID_SVSMDPropertyBrowser, __uuidof(IVSMDPropertyBrowser), (LPVOID *)&s_pBrowser );
		return hr;
	}

	STDMETHOD(QueryClose)(BOOL *pCanClose);
	{
		if (pCanClose != NULL)
		{
			*pCanClose = TRUE;
			return S_OK;
		}
		RETURN_INVALID();
	}
	
	STDMETHOD(Close)();
	{
	    m_pServiceProvider = NULL;
		s_pBrowser = NULL;
		s_bstrAlternateRegistryRoot = NULL;
	}

	STDMETHOD(GetAutomationObject)(LPCOLESTR pszPropName, IDispatch **ppDisp);
		{ return E_NOTIMPL; }
	STDMETHOD(GetPropertyPage)(REFGUID rguidPage, VSPROPSHEETPAGE *ppage);
		{ return E_NOTIMPL; }
	STDMETHOD(ResetDefaults)(PKGRESETFLAGS dwFlags);
		{ return E_NOTIMPL; }
	STDMETHOD(CreateTool)(REFGUID rguidPersistenceSlot);
		{ return E_NOTIMPL; }

// IServiceProvider
	STDMETHOD(QueryService)(THIS_ REFGUID rsid, REFIID iid, void ** ppvObj);
};
#endif

// This class does a loadlibrary on the active directory services dll, and 
// exposes methods to call its functions.
//---------------------------------------------------------------------------
#pragma once

interface IADsContainer;

// ADSI Function prototypes
typedef HRESULT (WINAPI *fnpADsGetObject)(LPCWSTR, REFIID, void**);
typedef HRESULT (WINAPI *fnpADsBuildEnumerator)(IADsContainer*, IEnumVARIANT**);
typedef HRESULT (WINAPI *fnpADsEnumerateNext)(IEnumVARIANT*, ULONG , VARIANT*, ULONG*);
typedef HRESULT (WINAPI *fnpADsFreeEnumerator)(IEnumVARIANT*);
typedef HRESULT (WINAPI *fnpADsGetLastError)(LPDWORD, LPWSTR, DWORD, LPWSTR, DWORD );

class CAdsiWrapper
{
public:
    CAdsiWrapper();
    ~CAdsiWrapper();
    BOOL Init();

    HRESULT ADsGetObject(LPCWSTR pszADSRootPath, REFIID riid, void** ppADsRoot);
    HRESULT ADsBuildEnumerator(IADsContainer *pADsContainer, IEnumVARIANT **ppEnumVariant);
    HRESULT ADsEnumerateNext(IEnumVARIANT *pEnumVariant, ULONG cElements, VARIANT* pvar, ULONG* pcElementsFetched);
    HRESULT ADsFreeEnumerator(IEnumVARIANT *pEnumVariant);
    HRESULT ADsGetLastError(LPDWORD lpError, LPWSTR lpErrorBuf, DWORD dwErrorBufLen, LPWSTR lpNameBuf, DWORD dwNameBufLen);
protected:
    HINSTANCE             m_hAdsiLib;
    fnpADsGetObject       m_pADsGetObject;
    fnpADsBuildEnumerator m_pADsBuildEnumerator;
    fnpADsEnumerateNext   m_pADsEnumerateNext;
    fnpADsFreeEnumerator  m_pADsFreeEnumerator;
    fnpADsGetLastError    m_pADsGetLastError;
};

#endif //__VCPROJECTENGINE_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\vcpb\vctool.cpp ===
#include "stdafx.h"
#include "VCTool.h"
#include "CmdLines.h"
#include "BldActions.h"
#include "scanner.h"
#include "BuildEngine.h"
#include "ProjWriter.h"
#include "stylesheet.h"

BOOL CVCToolImpl::ConfigBuildProp(long idProp)
{
	switch(idProp)
	{
	case VCCFGID_IntermediateDirectory:
	case VCCFGID_OutputDirectory:
		return TRUE;	// the case statements above here need to match those for the override ID VCCFGID_AllOutputsDirty in GetOverrideID
	default:
		return FALSE;
	};
}

STDMETHODIMP CVCToolImpl::GetAdditionalIncludeDirectoriesInternal(IVCPropertyContainer* pPropContainer, BSTR* pbstrIncPaths)
{
	if (pbstrIncPaths != NULL)
		*pbstrIncPaths = NULL;
	return S_FALSE;
}

STDMETHODIMP CVCToolImpl::get_IncludePathID(long* pnIncludeID)
{
	CHECK_POINTER_NULL(pnIncludeID);
	*pnIncludeID = 0;
	return S_FALSE;
}

STDMETHODIMP CVCToolImpl::SaveObject(IStream *xml, IVCPropertyContainer *pPropContainer, long nIndent)
{
	VSASSERT(pPropContainer, "Property container required in order to save tool properties");
	CHECK_READ_POINTER_NULL(pPropContainer);
	CHECK_READ_POINTER_NULL(xml);

	COptionHandlerBase* pOptionHandler = GetOptionHandler();
	RETURN_ON_NULL2(pOptionHandler, E_UNEXPECTED);

	HRESULT hr = S_OK;

	CComQIPtr<IVCFileConfigurationImpl> spFileCfgImpl = pPropContainer;
	bool bWriteProps = false;
 	if (spFileCfgImpl != NULL)	 // need to figure out whether we need to set what tool to use or can just set properties for it
 	{
 		VARIANT_BOOL bIgnoreDefaultTool = VARIANT_FALSE;
 		if (SUCCEEDED(spFileCfgImpl->get_IgnoreDefaultTool(&bIgnoreDefaultTool)) && bIgnoreDefaultTool == VARIANT_TRUE)
			bWriteProps = true;
 	}

 	if (!bWriteProps)
 	{
 		VARIANT_BOOL bHaveLocalStorage = VARIANT_FALSE;
		pPropContainer->HasLocalStorage(VARIANT_TRUE /*for save*/, &bHaveLocalStorage);	 // real cheap way to know we've got nothing going on...
		if ( bHaveLocalStorage == VARIANT_FALSE )
			return S_OK;
	}
	StartNodeHeader( xml, L"Tool", false );

	// Name
	CComBSTR bstrToolShortName;
	get_ToolShortName(&bstrToolShortName);
	if (bstrToolShortName.Length() > 0)
	{
		NodeAttribute( xml, L"Name", bstrToolShortName ); 					
	}

	// Now allow the tool to inject anything it needs that isn't in the prop table
	SaveSpecialProps(xml, pPropContainer);

	SOptionEntry * pOptTableEntry;
	
	// Additional Options
	if (pOptionHandler->SupportsAdditionalOptions())
	{
		CComBSTR bstrAdditionalOptions;
		if (GetAdditionalOptionsInternal(pPropContainer, VARIANT_FALSE, VARIANT_FALSE, &bstrAdditionalOptions) == S_OK)
		{
			NodeAttributeWithSpecialChars( xml, L"AdditionalOptions", bstrAdditionalOptions );
		}
	}

	// Additional Dependencies
	CComBSTR bstrAdditionalDependencies;
	if (GetAdditionalDependenciesInternal(pPropContainer, NULL, TRUE, &bstrAdditionalDependencies) == S_OK)
	{
		NodeAttributeWithSpecialChars( xml, L"AdditionalDependencies", bstrAdditionalDependencies );
	}

	// options from property container
	pOptTableEntry = pOptionHandler->GetOptionTable();
	if (pOptTableEntry)
	{
		CStringW strOption;
		HRESULT hr = S_OK;

		for (; pOptTableEntry->entryType != stdOptEnd && SUCCEEDED(hr); pOptTableEntry++)
		{
			bool bString = false;
			CComVariant var;
			hr = pPropContainer->GetLocalProp(pOptTableEntry->idOption, &var);
			if (hr == S_FALSE || FAILED(hr))
				continue;
			switch (pOptTableEntry->entryType)
			{
			case stdOptEnum:
				{
				// ChangeType() in the Invoke() call will handle this for us
// 				CComQIPtr<IDispatch> pDisp;
// 				pDisp = static_cast<IUnknown *>(this);
// 				GetEnumVal(pPropContainer, pOptTableEntry, var, pDisp);
 				}
				break;
			case stdOptBstr:			// option is a string (quote it)
			case specOptBstr:		// option is a string with special handling required
				bString = true;	// put quotes around it...
				break;

			case stdOptBool:
				{
				CComBSTR bstrBool = var.boolVal == VARIANT_TRUE ? L"TRUE" : L"FALSE";
				var = bstrBool;
				}
				break;

			case stdOptBstrNoQuote:	// option is a string (don't quote it)
				break;

			}
			var.ChangeType(VT_BSTR);
			// TODO: these names should be bstr to start with
			CComBSTR bstrPropName = pOptTableEntry->szOptionName; 
// 			if( bString )
// 			{
// 				// prepend "
// 				CComBSTR bstrPropVal = L"&quot;";
// 				bstrPropVal += var.bstrVal;
// 				// append "
// 				bstrPropVal += L"&quot;";
//  				NodeAttribute( xml, bstrPropName, bstrPropVal );
// 			} 				
// 			else
			{
				NodeAttributeWithSpecialChars( xml, bstrPropName, var.bstrVal );
			} 				
		}
		hr = S_OK;
	}
	// end of node header
	EndNodeHeader( xml, false );
	// end of node
	EndNode( xml, L"Tool", false );
	return hr;
}

HRESULT CVCToolImpl::GetCommandLineOptions(IUnknown* pItem, IVCBuildAction* pAction, VARIANT_BOOL bIncludeAdditional, 
	VARIANT_BOOL bForDisplay, commandLineOptionStyle fStyle, CStringW& rstrCmdLine)
{
	CComQIPtr<IVCPropertyContainer> spPropContainer = pItem;
	RETURN_ON_NULL2(spPropContainer, E_NOINTERFACE);

	COptionHandlerBase* pOptionHandler = GetOptionHandler();
	RETURN_ON_NULL2(pOptionHandler, E_NOTIMPL);

	CComBSTR bstrProp;
	CComBSTR bstrOut;
	CStringW strOption;
	HRESULT hr = S_OK;

	BOOL bCForDisplay = (bForDisplay == VARIANT_TRUE);
	hr = pOptionHandler->GenerateCommandLine(spPropContainer, bCForDisplay, fStyle, strOption);
	RETURN_ON_FAIL(hr);
	pOptionHandler->AdvanceCommandLine(rstrCmdLine, strOption);

	if (pOptionHandler->SupportsAdditionalOptions() && bIncludeAdditional)
	{
		CComBSTR bstrOptions;
		hr = GetAdditionalOptionsInternal(pItem, VARIANT_TRUE, VARIANT_FALSE, &bstrOptions);
		if (hr == S_OK)
		{
			spPropContainer->Evaluate(bstrOptions, &bstrOptions);
			strOption = bstrOptions;
			pOptionHandler->AdvanceCommandLine(rstrCmdLine, strOption);
		}
		if (hr == S_FALSE)	// don't override a general S_OK with a single S_FALSE at the end here...
			hr = S_OK;
	}

	CComBSTR bstrAdditionalDependencies;
	if (GetAdditionalDependenciesInternal(spPropContainer, pAction, FALSE, &bstrAdditionalDependencies) == S_OK)
	{
		CComBSTR bstrDependenciesOut;
		spPropContainer->Evaluate(bstrAdditionalDependencies, &bstrDependenciesOut);
		strOption = bstrDependenciesOut;
		pOptionHandler->AdvanceCommandLine(rstrCmdLine, strOption);
	}

	if (fStyle == cmdLineForDisplay)
	{
		CStringW strTrailing;
		pOptionHandler->GetTrailingCommandLinePart(strTrailing);
		if (!strTrailing.IsEmpty())
			strTrailing = L"\r\n\r\n" + strTrailing;
		pOptionHandler->AdvanceCommandLine(rstrCmdLine, strTrailing);
	}

	return hr;
}

STDMETHODIMP CVCToolImpl::GetCommandLineOptions(IUnknown* pItem, IVCBuildAction* pAction, VARIANT_BOOL bIncludeAdditional, 
	commandLineOptionStyle fStyle, BSTR *pVal)
{
	CHECK_POINTER_NULL(pVal);
	*pVal = NULL;

	CStringW strVal;
	HRESULT hr = GetCommandLineOptions(pItem, pAction, bIncludeAdditional, VARIANT_FALSE /* !for display */, fStyle, strVal);
	if (SUCCEEDED(hr))
		*pVal = strVal.AllocSysString();

	return hr;
}

STDMETHODIMP CVCToolImpl::GetCommandLineOptionsForDisplay(IUnknown* pItem, VARIANT_BOOL bIncludeAdditional, BSTR *pVal)
{
	CHECK_POINTER_NULL(pVal);
	*pVal = NULL;

	CStringW strVal;
	// DIANEME_TODO: CVCToolImpl::GetCommandLineOptionsForDisplay - turn the for display parameter ON
	HRESULT hr = GetCommandLineOptions(pItem, NULL, bIncludeAdditional, VARIANT_FALSE /* !for display (temporary) */, cmdLineForDisplay, strVal);
	if (SUCCEEDED(hr))
		*pVal = strVal.AllocSysString();

	return hr;
}

STDMETHODIMP CVCToolImpl::GetCommandLineEx(IVCBuildAction*pAction,IVCBuildableItem* pBuildableItem, 
	IVCBuildEngine* pBuildEngine, IVCBuildErrorContext* pEC, BSTR *pVal)
{
	CHECK_READ_POINTER_NULL(pAction);
	CHECK_READ_POINTER_NULL(pBuildableItem);

	CHECK_POINTER_NULL(pVal);
	*pVal = NULL;

	CComBSTR bstrMidLine;
	HRESULT hr = GetCommandLineOptions(pBuildableItem, pAction, VARIANT_TRUE /* include additional options */, cmdLineForBuild, &bstrMidLine);
	RETURN_ON_FAIL(hr);

	COptionHandlerBase* pOptionHandler = GetOptionHandler();
	RETURN_ON_NULL2(pOptionHandler, E_NOTIMPL);

	CComBSTR bstrProp;
	hr = get_ToolPathInternal(&bstrProp);	// safe since we don't change the tool path on a per file cfg basis...
	RETURN_ON_FAIL(hr);

	CComQIPtr<IVCPropertyContainer> spPropContainer = pBuildableItem;
	RETURN_INVALID_ON_NULL(spPropContainer);
	CComBSTR bstrToolExe;
	spPropContainer->Evaluate(bstrProp, &bstrToolExe);

	CStringW strOption, strCmdLine;
	CComQIPtr<IVCBuildEngine> spUseBuildEngine;
	if (UsesResponseFiles())
		spUseBuildEngine = pBuildEngine;
	if (spUseBuildEngine == NULL)
	{
		strOption = bstrToolExe;
		pOptionHandler->AdvanceCommandLine(strCmdLine, strOption);
	}
	strOption = bstrMidLine;
	pOptionHandler->AdvanceCommandLine(strCmdLine, strOption);
	CComBSTR bstrProp2;
	BOOL bUsesRSP = UsesResponseFiles();
	pAction->GetRelativePathsToInputs(TRUE, bUsesRSP, pEC, &bstrProp2);
	strOption = bstrProp2;
	pOptionHandler->AdvanceCommandLine(strCmdLine, strOption, bUsesRSP ? L"\n" : L" ");
	if (spUseBuildEngine == NULL)
	{
		if (pBuildEngine)
		{
			CStringW strCommand;
			strCommand.Format(IDS_CREATING_COMMANDLINE, strCmdLine);
			CComBSTR bstrCommand = strCommand;
			pBuildEngine->LogTrace(eLogCommand, bstrCommand);
		}
		*pVal = strCmdLine.AllocSysString();
		return S_OK;
	}

	CComBSTR bstrCmdLineIn = strCmdLine;
	return spUseBuildEngine->FormCommandLine(bstrToolExe, bstrCmdLineIn, pEC, bUsesRSP, TRUE, pVal);
}

// by default tools don't do this (makefile tool is the exception)
STDMETHODIMP CVCToolImpl::GetCleanCommandLineEx(IVCBuildAction*pAction,IVCBuildableItem* pBuildableItem, 
	IVCBuildEngine* pBuildEngine, IVCBuildErrorContext* pEC, BSTR *pVal)
{
	CHECK_POINTER_NULL(pVal);
	pVal = NULL;
	return E_NOTIMPL;
}

// by default tools don't do this (makefile tool is the exception)
STDMETHODIMP CVCToolImpl::GetRebuildCommandLineEx(IVCBuildAction*pAction,IVCBuildableItem* pBuildableItem, 
	IVCBuildEngine* pBuildEngine, IVCBuildErrorContext* pEC, BSTR *pVal)
{
	CHECK_POINTER_NULL(pVal);
	pVal = NULL;
	return E_NOTIMPL;
}

STDMETHODIMP CVCToolImpl::GetPages(CAUUID* pPages)
{
	CHECK_POINTER_NULL(pPages);
		
	// normally these would be CoTaskMemAlloced, but the caller of this is going to 
	// merge the set of pages and do an alloc later, so we don't have to.
	pPages->cElems = GetPageCount();
	pPages->pElems = GetPageIDs();
	return S_OK;
}

STDMETHODIMP CVCToolImpl::GetPropertyOptionInternal(IUnknown* pItem, BSTR bstrProp, long dispidProp, BSTR *pVal)
{
	CComQIPtr<IVCPropertyContainer> spPropContainer = pItem;
	RETURN_ON_NULL2(spPropContainer, E_NOINTERFACE);

	CHECK_POINTER_NULL(pVal);
	*pVal = NULL;

	HRESULT hr = S_OK;
	COptionHandlerBase* pOptionHandler = GetOptionHandler();
	RETURN_ON_NULL2(pOptionHandler, E_NOTIMPL);

	CStringW strSwitch;
	hr = pOptionHandler->FindSwitch(spPropContainer, bstrProp, dispidProp, strSwitch);
	RETURN_ON_FAIL(hr);
	*pVal = strSwitch.AllocSysString();
	return hr;
}

STDMETHODIMP CVCToolImpl::IsTargetTool(IVCBuildAction* pAction, VARIANT_BOOL* pbIsTargetTool)
{ 
	return COptionHandlerBase::GetValueFalse(pbIsTargetTool);	// by default, not a target tool
}

STDMETHODIMP CVCToolImpl::get_PerformIfAble(VARIANT_BOOL* pbPerformIfAble)
{ 
	return COptionHandlerBase::GetValueFalse(pbPerformIfAble);	// by default, stop on error
}

STDMETHODIMP CVCToolImpl::get_IsComspecTool(VARIANT_BOOL* pbIsComspecTool)
{ 
	return COptionHandlerBase::GetValueFalse(pbIsComspecTool);	// by default, doesn't require comspec
}

STDMETHODIMP CVCToolImpl::get_IsCustomBuildTool(VARIANT_BOOL* pbIsCustom)
{
	return get_IsComspecTool(pbIsCustom);	// so far, all custom tools are comspec tools...
}

HRESULT CVCToolImpl::GetAdditionalDependenciesInternal(IVCPropertyContainer* pItem, IVCBuildAction* pAction, BOOL bForSave, 
	BSTR* pbstrInputs)
{
	CHECK_ZOMBIE(pItem, IDS_ERR_TOOL_ZOMBIE);
	CHECK_POINTER_NULL(pbstrInputs);
	*pbstrInputs = NULL;	// by default, doesn't have additional inputs
	return S_FALSE;
}

STDMETHODIMP CVCToolImpl::PrePerformBuildActions(bldActionTypes type, IVCBuildActionList* pActions, 
	bldAttributes aob, IVCBuildErrorContext* pEC, actReturnStatus* pActReturn)
{
	CHECK_POINTER_NULL(pActReturn);
	*pActReturn = ACT_Complete;
	return S_OK;
}

STDMETHODIMP CVCToolImpl::PostPerformBuildActions(bldActionTypes type, IVCBuildActionList* pActions, 
	bldAttributes aob, IVCBuildErrorContext* pEC, actReturnStatus* pActReturn)
{
	return S_OK;
}

STDMETHODIMP CVCToolImpl::IsDeleteOnRebuildFile(LPCOLESTR szFile, VARIANT_BOOL* pbDelOnRebuild)
{
	return COptionHandlerBase::GetValueTrue(pbDelOnRebuild);
}

STDMETHODIMP CVCToolImpl::GetCommandLinesForBuild(IVCBuildActionList* pActions, bldAttributes attrib, 
	IVCBuildEngine* pBldEngine, IVCBuildErrorContext* pErrorContext, IVCCommandLineList** ppCmds)
{
	CHECK_POINTER_NULL(ppCmds);
	*ppCmds = NULL;

	RETURN_ON_NULL2(pActions, S_FALSE);

	// generate standard command-line
	HRESULT hr = S_OK;
	BOOL bFirstTime = TRUE;
	pActions->Reset(NULL);
	while (hr == S_OK)
	{
		CComPtr<IVCBuildAction> spAction;
		hr = pActions->Next(&spAction, NULL);
		BREAK_ON_DONE(hr);
		ASSERT_AND_CONTINUE_ON_NULL(spAction);

		CComPtr<IVCBuildableItem> spBuildableItem;
		HRESULT hr1 = spAction->get_Item(&spBuildableItem);
		ASSERT_AND_CONTINUE_ON_FAIL_OR_NULL(hr1, spBuildableItem);
		if (bFirstTime)
		{
			bFirstTime = FALSE;
			CComPtr<VCConfiguration> spProjCfg;
			hr1 = spAction->get_ProjectConfiguration(&spProjCfg);
			ASSERT_AND_CONTINUE_ON_FAIL_OR_NULL(hr1, spProjCfg);

			if (!HaveCommandLine(spAction))
				continue;	// nothing whatsoever to do if there's nothing there to build...
		}

		VARIANT_BOOL bIsTargetTool = VARIANT_FALSE;
		IsTargetTool(spAction, &bIsTargetTool);

		// this keeps the non-schmooze tools off the schmooze list...
		CComQIPtr<VCFileConfiguration> spFileCfg = spBuildableItem;
		if (bIsTargetTool == VARIANT_TRUE && spFileCfg != NULL)	// schmooze tool on file
			continue;
		else if (bIsTargetTool == VARIANT_FALSE && spFileCfg == NULL)	// non-schmooze tool on cfg
			continue;

		CComBSTR bstrCmd;
		hr1 = GetCommandLineEx(spAction, spBuildableItem, pBldEngine, pErrorContext, &bstrCmd);
		ASSERT_AND_CONTINUE_ON_FAIL(hr1);

		CComBSTR bstrDescription;
		hr1 = GetBuildDescription(spAction, &bstrDescription);
		ASSERT_AND_CONTINUE_ON_FAIL(hr1);

		if (*ppCmds == NULL)
		{
			hr1 = CVCCommandLineList::CreateInstance(ppCmds);
			ASSERT_AND_CONTINUE_ON_FAIL_OR_NULL(hr1, *ppCmds);
			VARIANT_BOOL bIsComspec = VARIANT_FALSE;
			if (SUCCEEDED(get_IsComspecTool(&bIsComspec)))
				(*ppCmds)->put_UseConsoleCodePageForSpawner(bIsComspec);
		}
		CComPtr<IVCCommandLine> spCmdLine;
		hr1 = CVCCommandLine::CreateInstance(&spCmdLine);
		ASSERT_AND_CONTINUE_ON_FAIL_OR_NULL(hr, spCmdLine);

		spCmdLine->put_CommandLineContents(bstrCmd);
		spCmdLine->put_Description(bstrDescription);
		spCmdLine->put_NumberOfProcessors(1);

		(*ppCmds)->Add(spCmdLine, FALSE);
	}

	return S_OK;
}

STDMETHODIMP CVCToolImpl::GetCommandLinesForClean(IVCBuildActionList* pActions, bldAttributes attrib, 
	IVCBuildEngine* pBldEngine, IVCBuildErrorContext* pErrorContext, IVCCommandLineList** ppCmds)
{
	CHECK_POINTER_NULL(ppCmds);
	*ppCmds = NULL;

	RETURN_ON_NULL2(pActions, S_FALSE);

	// generate standard command-line
	HRESULT hr = S_OK;
	BOOL bFirstTime = TRUE;
	pActions->Reset(NULL);
	while (hr == S_OK)
	{
		CComPtr<IVCBuildAction> spAction;
		hr = pActions->Next(&spAction, NULL);
		BREAK_ON_DONE(hr);
		ASSERT_AND_CONTINUE_ON_NULL(spAction);

		CComPtr<IVCBuildableItem> spBuildableItem;
		HRESULT hr1 = spAction->get_Item(&spBuildableItem);
		ASSERT_AND_CONTINUE_ON_FAIL_OR_NULL(hr1, spBuildableItem);
		if (bFirstTime)
		{
			bFirstTime = FALSE;
			CComPtr<VCConfiguration> spProjCfg;
			hr1 = spAction->get_ProjectConfiguration(&spProjCfg);
			ASSERT_AND_CONTINUE_ON_FAIL_OR_NULL(hr1, spProjCfg);

			if (!HaveCommandLine(spAction))
				continue;	// nothing whatsoever to do if there's nothing there to build...
		}

		VARIANT_BOOL bIsTargetTool = VARIANT_FALSE;
		IsTargetTool(spAction, &bIsTargetTool);

		// this keeps the non-schmooze tools off the schmooze list...
		CComQIPtr<VCFileConfiguration> spFileCfg = spBuildableItem;
		if (bIsTargetTool == VARIANT_TRUE && spFileCfg != NULL)	// schmooze tool on file
			continue;
		else if (bIsTargetTool == VARIANT_FALSE && spFileCfg == NULL)	// non-schmooze tool on cfg
			continue;

		CComBSTR bstrCmd;
		hr1 = GetCleanCommandLineEx(spAction, spBuildableItem, pBldEngine, pErrorContext, &bstrCmd);
		ASSERT_AND_CONTINUE_ON_FAIL(hr1);

		CComBSTR bstrDescription;
		hr1 = GetBuildDescription(spAction, &bstrDescription);
		ASSERT_AND_CONTINUE_ON_FAIL(hr1);

		if (*ppCmds == NULL)
		{
			hr1 = CVCCommandLineList::CreateInstance(ppCmds);
			ASSERT_AND_CONTINUE_ON_FAIL_OR_NULL(hr1, *ppCmds);
			VARIANT_BOOL bIsComspec = VARIANT_FALSE;
			if (SUCCEEDED(get_IsComspecTool(&bIsComspec)))
				(*ppCmds)->put_UseConsoleCodePageForSpawner(bIsComspec);
		}
		CComPtr<IVCCommandLine> spCmdLine;
		hr1 = CVCCommandLine::CreateInstance(&spCmdLine);
		ASSERT_AND_CONTINUE_ON_FAIL_OR_NULL(hr, spCmdLine);

		spCmdLine->put_CommandLineContents(bstrCmd);
		spCmdLine->put_Description(bstrDescription);
		spCmdLine->put_NumberOfProcessors(1);

		(*ppCmds)->Add(spCmdLine, FALSE);
	}

	return S_OK;
}

STDMETHODIMP CVCToolImpl::GetCommandLinesForRebuild(IVCBuildActionList* pActions, bldAttributes attrib, 
	IVCBuildEngine* pBldEngine, IVCBuildErrorContext* pErrorContext, IVCCommandLineList** ppCmds)
{
	CHECK_POINTER_NULL(ppCmds);
	*ppCmds = NULL;

	RETURN_ON_NULL2(pActions, S_FALSE);

	// generate standard command-line
	HRESULT hr = S_OK;
	BOOL bFirstTime = TRUE;
	pActions->Reset(NULL);
	while (hr == S_OK)
	{
		CComPtr<IVCBuildAction> spAction;
		hr = pActions->Next(&spAction, NULL);
		BREAK_ON_DONE(hr);
		ASSERT_AND_CONTINUE_ON_NULL(spAction);

		CComPtr<IVCBuildableItem> spBuildableItem;
		HRESULT hr1 = spAction->get_Item(&spBuildableItem);
		ASSERT_AND_CONTINUE_ON_FAIL_OR_NULL(hr1, spBuildableItem);
		if (bFirstTime)
		{
			bFirstTime = FALSE;
			CComPtr<VCConfiguration> spProjCfg;
			hr1 = spAction->get_ProjectConfiguration(&spProjCfg);
			ASSERT_AND_CONTINUE_ON_FAIL_OR_NULL(hr1, spProjCfg);

			if (!HaveCommandLine(spAction))
				continue;	// nothing whatsoever to do if there's nothing there to build...
		}

		VARIANT_BOOL bIsTargetTool = VARIANT_FALSE;
		IsTargetTool(spAction, &bIsTargetTool);

		// this keeps the non-schmooze tools off the schmooze list...
		CComQIPtr<VCFileConfiguration> spFileCfg = spBuildableItem;
		if (bIsTargetTool == VARIANT_TRUE && spFileCfg != NULL)	// schmooze tool on file
			continue;
		else if (bIsTargetTool == VARIANT_FALSE && spFileCfg == NULL)	// non-schmooze tool on cfg
			continue;

		CComBSTR bstrCmd;
		hr1 = GetRebuildCommandLineEx(spAction, spBuildableItem, pBldEngine, pErrorContext, &bstrCmd);
		ASSERT_AND_CONTINUE_ON_FAIL(hr1);

		CComBSTR bstrDescription;
		hr1 = GetBuildDescription(spAction, &bstrDescription);
		ASSERT_AND_CONTINUE_ON_FAIL(hr1);

		if (*ppCmds == NULL)
		{
			hr1 = CVCCommandLineList::CreateInstance(ppCmds);
			ASSERT_AND_CONTINUE_ON_FAIL_OR_NULL(hr1, *ppCmds);
			VARIANT_BOOL bIsComspec = VARIANT_FALSE;
			if (SUCCEEDED(get_IsComspecTool(&bIsComspec)))
				(*ppCmds)->put_UseConsoleCodePageForSpawner(bIsComspec);
		}
		CComPtr<IVCCommandLine> spCmdLine;
		hr1 = CVCCommandLine::CreateInstance(&spCmdLine);
		ASSERT_AND_CONTINUE_ON_FAIL_OR_NULL(hr, spCmdLine);

		spCmdLine->put_CommandLineContents(bstrCmd);
		spCmdLine->put_Description(bstrDescription);
		spCmdLine->put_NumberOfProcessors(1);

		(*ppCmds)->Add(spCmdLine, FALSE);
	}

	return S_OK;
}
STDMETHODIMP CVCToolImpl::IsSpecialConsumable(LPCOLESTR szPath, VARIANT_BOOL* pbSpecial)
{
	return COptionHandlerBase::GetValueFalse(pbSpecial);	// by default, nothing is a special consumable
}


STDMETHODIMP CVCToolImpl::GenerateOutput(long type, IVCBuildActionList* pActions, IVCBuildErrorContext* pEC)
{
	// meant to be overridden
	return S_FALSE;
}

///////////////////////////////////////////////////////////////////////////////
// Affects our output?
STDMETHODIMP CVCToolImpl::AffectsOutput(long nPropID, VARIANT_BOOL* pbAffectsOutput)
{
	// meant to be overridden
	CHECK_POINTER_NULL(pbAffectsOutput);
	*pbAffectsOutput = VARIANT_FALSE;

	return S_OK;
}

STDMETHODIMP CVCToolImpl::HasPrimaryOutputFromTool(IUnknown* pItem, VARIANT_BOOL bSchmoozeOnly, VARIANT_BOOL* pbHasPrimaryOutput)
{ 
	return COptionHandlerBase::GetValueFalse(pbHasPrimaryOutput);	// by default, not primary output generator
}

STDMETHODIMP CVCToolImpl::GetPrimaryOutputFromTool(IUnknown* pItem, VARIANT_BOOL bSchmoozeOnly, BSTR* pbstrPath)
{ 
	CHECK_POINTER_NULL(pbstrPath);
	*pbstrPath = NULL;

	CPathW path;
	HRESULT hr = GetPrimaryOutputFromTool(pItem, bSchmoozeOnly, path);
	if (hr != S_OK)
		return hr;
	path.GetActualCase(TRUE);

	CStringW strPath = path;
	if (!strPath.IsEmpty())
		*pbstrPath = strPath.AllocSysString();
	return S_OK;
}

STDMETHODIMP CVCToolImpl::GetPrimaryOutputIDFromTool(IUnknown* pItem, VARIANT_BOOL bSchmoozeOnly, long* pnOutputID)
{
	// meant to be overridden
	CHECK_POINTER_NULL(pnOutputID);
	*pnOutputID = -1;

	return S_FALSE;
}

STDMETHODIMP CVCToolImpl::GetImportLibraryFromTool(IUnknown* pItem, BSTR* pbstrPath)
{
	CHECK_POINTER_NULL(pbstrPath);
	*pbstrPath = NULL;
	return S_FALSE;
}

STDMETHODIMP CVCToolImpl::GetDefaultOutputFileFormat(IUnknown* pItem, BSTR* pbstrOutMacro)
{	// macro to use for generating default output file if the original default isn't unique
	// meant to be overridden
	CHECK_POINTER_NULL(pbstrOutMacro);
	*pbstrOutMacro = NULL;

	return S_FALSE;
}

STDMETHODIMP CVCToolImpl::GetProgramDatabaseFromTool(IVCPropertyContainer* pContainer, VARIANT_BOOL bSchmoozeOnly, BSTR* pbstrPDB)
{
	CHECK_POINTER_NULL(pbstrPDB);
	*pbstrPDB = NULL;
	return S_FALSE;
}

STDMETHODIMP CVCToolImpl::SetPrimaryOutputForTool(IUnknown* pItem, BSTR bstrFile)
{	// sets the primary output for a tool
	return S_FALSE;		// by default, you can't do this; override for tools that want to
}

STDMETHODIMP CVCToolImpl::get_IsFileTool(VARIANT_BOOL* pbIsFileTool)
{
	CHECK_POINTER_NULL(pbIsFileTool);

	// in general, anything that isn't a primary output tool is a file tool (includes custom tool)
	VARIANT_BOOL bIsTargetTool = VARIANT_FALSE;
	HasPrimaryOutputFromTool(NULL, VARIANT_TRUE, &bIsTargetTool);
	if (bIsTargetTool == VARIANT_TRUE)
		*pbIsFileTool = VARIANT_FALSE;
	else
		*pbIsFileTool = VARIANT_TRUE;
	return S_OK;
}

STDMETHODIMP CVCToolImpl::HasDependencies(IVCBuildAction* pAction, VARIANT_BOOL* pbHasDependencies)
{
	return COptionHandlerBase::GetValueFalse(pbHasDependencies);	// by default, has no dependencies
}

STDMETHODIMP CVCToolImpl::GetDependencies(IVCBuildAction* pAction, IVCBuildStringCollection** ppStrings, 
	VARIANT_BOOL* pbUpToDate)
{
	CHECK_POINTER_NULL(ppStrings);
	*ppStrings = NULL;
	return S_FALSE;
}

STDMETHODIMP CVCToolImpl::CanScanForDependencies(VARIANT_BOOL* pbIsScannable)
{
	return COptionHandlerBase::GetValueFalse(pbIsScannable);	// by default, the tool can't scan for dependencies
}

STDMETHODIMP CVCToolImpl::ScanDependencies(IVCBuildAction* pAction, IVCBuildErrorContext* pEC, VARIANT_BOOL bWriteOutput)
{
	RETURN_INVALID_ON_NULL(pAction);
	return pAction->ScanToolDependencies(this, pEC, bWriteOutput);
}

STDMETHODIMP CVCToolImpl::GetDeploymentDependencies(IVCBuildAction* pAction, IVCBuildStringCollection** ppDeployDepStrings)
{
	return S_FALSE;	// by default, tools don't have deployment dependencies
}

STDMETHODIMP CVCToolImpl::GetDeployableOutputsCount(IVCPropertyContainer* pPropContainer, long* pnOutputs)
{	// number of deployable outputs
	CHECK_POINTER_NULL(pnOutputs);
	*pnOutputs = 0;

	VARIANT_BOOL bHasPrimaryOutput = VARIANT_FALSE;
	if (SUCCEEDED(HasPrimaryOutputFromTool(pPropContainer, VARIANT_TRUE, &bHasPrimaryOutput)) && bHasPrimaryOutput == VARIANT_TRUE)
	{
		CComBSTR bstrPrimaryOutput;
		if (SUCCEEDED(GetPrimaryOutputFromTool(pPropContainer, VARIANT_TRUE, &bstrPrimaryOutput)) 
			&& bstrPrimaryOutput != NULL && bstrPrimaryOutput[0] != L'\0')
			*pnOutputs = 1;
	}

	return S_OK;
}

STDMETHODIMP CVCToolImpl::GetDeployableOutputs(IVCPropertyContainer* pPropContainer, IVCBuildStringCollection** ppDeployableOutputs)
{	// the deployable outputs
	CHECK_POINTER_NULL(ppDeployableOutputs);
	*ppDeployableOutputs = NULL;

	VARIANT_BOOL bHasPrimaryOutput = VARIANT_FALSE;
	if (FAILED(HasPrimaryOutputFromTool(pPropContainer, VARIANT_TRUE, &bHasPrimaryOutput)) || bHasPrimaryOutput != VARIANT_TRUE)
		return S_OK;	// nothing to do

	CComBSTR bstrPrimaryOutput;
	HRESULT hr = GetPrimaryOutputFromTool(pPropContainer, VARIANT_TRUE, &bstrPrimaryOutput);
	if (FAILED(hr) || bstrPrimaryOutput.Length() == 0)
		return hr;

	hr = CVCBuildStringCollection::CreateInstance(ppDeployableOutputs);
	RETURN_ON_FAIL_OR_NULL2(hr, *ppDeployableOutputs, E_OUTOFMEMORY);
	(*ppDeployableOutputs)->Add(bstrPrimaryOutput);

	return S_OK;
}

STDMETHODIMP CVCToolImpl::DirtyCommandLineOptions(long nLowPropID, long nHighPropID, VARIANT_BOOL bDirty)
{
	CHECK_ZOMBIE(m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE);
	VSASSERT(m_nDirtyKey >= 0, "Dirty key must be initialized");
	if (!bDirty || AffectsTool(nLowPropID, nHighPropID, NULL) == S_OK)
	{
		BOOL bCTypeDirty = (bDirty == VARIANT_TRUE);
		VARIANT_BOOL bAlreadyDirty;
		BOOL bExists = (m_spPropertyContainer->GetBoolProperty(m_nDirtyKey, &bAlreadyDirty) == S_OK);
		HRESULT hr = S_FALSE;
		if (bCTypeDirty != bExists)	// no-op when they match
		{
			if (bDirty)
				m_spPropertyContainer->SetBoolProperty(m_nDirtyKey, VARIANT_TRUE);
			else 
				m_spPropertyContainer->Clear(m_nDirtyKey);
			hr = S_OK;
		}
		if (m_nDirtyOutputsKey >= 0)
		{
			bExists = (m_spPropertyContainer->GetBoolProperty(m_nDirtyOutputsKey, &bAlreadyDirty) == S_OK);
			if (!bDirty  && bExists)
				m_spPropertyContainer->Clear(m_nDirtyOutputsKey);
			else if (bDirty && !bExists)
			{
				VARIANT_BOOL bAffectsOutput = VARIANT_FALSE;
				for (long idx = nLowPropID; idx <= nHighPropID && !bAffectsOutput; idx++)
					AffectsOutput(idx, &bAffectsOutput);
				if (bAffectsOutput)
				{
					m_spPropertyContainer->SetBoolProperty(m_nDirtyOutputsKey, VARIANT_TRUE);
					hr = S_OK;
				}
			}
		}
		return hr;
	}

	return S_FALSE;
}

STDMETHODIMP CVCToolImpl::HasVirtualLocalStorage(IVCPropertyContainer* pPropContainer, VARIANT_BOOL* pbHasVirtualLocalStorage)
{
	CHECK_POINTER_NULL(pbHasVirtualLocalStorage);
	CHECK_READ_POINTER_NULL(pPropContainer);
	*pbHasVirtualLocalStorage = VARIANT_FALSE;
	return S_OK;
}

STDMETHODIMP CVCToolImpl::AffectsTool(long nLowPropID, long nHighPropID, VARIANT_BOOL* pbCanDirty)
{
	VSASSERT(m_nLowKey >= 0 && m_nHighKey >= 0 && m_nHighKey >= m_nLowKey, "Key range to watch must be initialized and in ascending order");
	if (pbCanDirty)
		*pbCanDirty = FALSE;
	BOOL bAffectsUs = FALSE;

	if (nLowPropID == nHighPropID)
	{	// single prop check
		if ((nLowPropID == -1) ||  	// override range checking
			ConfigBuildProp(nLowPropID))	// affects all outputs
			bAffectsUs = TRUE;
		if (!bAffectsUs && nLowPropID == VCFCFGID_ExcludedFromBuild)
		{
			CComQIPtr<VCFileConfiguration> spFileCfg = m_spPropertyContainer;
			bAffectsUs = (spFileCfg != NULL);
		}
	}
	if (!bAffectsUs &&						// may need to check single key against range
		((nLowPropID >= m_nLowKey && nLowPropID <= m_nHighKey) ||	// low key in range
		(nHighPropID >= m_nLowKey && nHighPropID <= m_nHighKey) ||	// high key in range
		(nLowPropID < m_nLowKey && nHighPropID > m_nHighKey)))	// desired range completely overlaps our range
	{
		bAffectsUs = TRUE;
	}

	if (bAffectsUs && pbCanDirty)
		*pbCanDirty = VARIANT_TRUE;

	return (bAffectsUs ? S_OK : S_FALSE);
}

STDMETHODIMP CVCToolImpl::IsMultiProp(long idProp, VARIANT_BOOL* pbIsMulti)
{
	CHECK_POINTER_NULL(pbIsMulti);

	*pbIsMulti = VARIANT_FALSE;
	if (idProp < m_nLowKey || idProp > m_nHighKey)	// doesn't belong to this tool, anyway
		return S_FALSE;

	if (GetOptionHandler() == NULL)
		return S_OK;	// by default, tools without option tables don't have multi-props

	if (IsExtraMultiProp(idProp))	// override this method for multi-props not found in option tables, ex: VCLINKID_AdditionalDependencies
	{
		*pbIsMulti = VARIANT_TRUE;
		return S_OK;
	}

	CLookupByDispidMap* pOptionMap = GetOptionHandler()->GetOptionLookupByDispid();
	RETURN_ON_NULL2(pOptionMap, S_FALSE);

	SOptionEntry* pEntry = pOptionMap->FindOptionEntry(idProp);
	RETURN_ON_NULL2(pEntry, S_FALSE);

	if (pEntry->type == multiple)
		*pbIsMulti = VARIANT_TRUE;
	
	return S_OK;
}

STDMETHODIMP CVCToolImpl::GetMultiPropSeparator(long idProp, BSTR* pbstrPreferred, BSTR* pbstrAll)
{
	CHECK_POINTER_NULL(pbstrPreferred);
	CHECK_POINTER_NULL(pbstrAll);
	*pbstrPreferred = NULL;
	*pbstrAll = NULL;

	if (idProp < m_nLowKey || idProp > m_nHighKey)	// doesn't belong to this tool, anyway
		return S_FALSE;

	if (GetOptionHandler() == NULL)
		return S_OK;	// by default, tools without option tables don't have multi-props

	if (IsExtraMultiProp(idProp))	// override this method for multi-props not found in option tables, ex: VCLINKID_AdditionalDependencies
	{
		CComBSTR bstrSep = L" ";
		bstrSep.CopyTo(pbstrPreferred);
		bstrSep.CopyTo(pbstrAll);
		return S_OK;
	}

	GetOptionHandler()->GetMultiPropSeparator(idProp, pbstrPreferred, pbstrAll);
	
	return S_OK;
}

STDMETHODIMP CVCToolImpl::CommandLineOptionsAreDirty(IVCPropertyContainer* pPropContainer, VARIANT_BOOL* pbIsDirty)
{
	VSASSERT(m_nDirtyKey >= 0, "Dirty key must be initialized");
	CHECK_POINTER_NULL(pbIsDirty);
	CHECK_ZOMBIE(pPropContainer, IDS_ERR_TOOL_ZOMBIE);

	VARIANT_BOOL bDirty;
	HRESULT hr = pPropContainer->GetBoolProperty(m_nDirtyKey, &bDirty);
	if (hr == S_OK)	// value doesn't really matter since we clear the property when we undirty it...
		*pbIsDirty = VARIANT_TRUE;
	else
		*pbIsDirty = VARIANT_FALSE;

	return hr;
}

STDMETHODIMP CVCToolImpl::OutputsAreDirty(IVCPropertyContainer* pPropContainer, VARIANT_BOOL* pbIsDirty)
{
	CHECK_POINTER_NULL(pbIsDirty);
	CHECK_ZOMBIE(pPropContainer, IDS_ERR_TOOL_ZOMBIE);
	if (m_nDirtyOutputsKey < 0)
	{
		*pbIsDirty = VARIANT_FALSE;
		return S_FALSE;
	}

	VARIANT_BOOL bDirty;
	HRESULT hr = pPropContainer->GetBoolProperty(m_nDirtyOutputsKey, &bDirty);
	if (hr == S_OK)	// value doesn't really matter since we clear the property when we undirty it...
		*pbIsDirty = VARIANT_TRUE;
	else
		*pbIsDirty = VARIANT_FALSE;

	return hr;
}

STDMETHODIMP CVCToolImpl::ClearDirtyOutputs(IVCPropertyContainer* pPropContainer)
{
	CHECK_ZOMBIE(pPropContainer, IDS_ERR_TOOL_ZOMBIE);
	if (m_nDirtyOutputsKey < 0)
		return S_OK;	// nothing to clear

	pPropContainer->Clear(m_nDirtyOutputsKey);
	return S_OK;
}

HRESULT CVCToolImpl::GetPrimaryOutputFromTool(IUnknown* pItem, VARIANT_BOOL bSchmoozeOnly, CPathW& rPath)
{ 
	return S_FALSE;	// by default, not primary output generator
}

void CVCToolImpl::ConvertPathToBSTR(CPathW& rpath, CComBSTR& rbstrPath)
{
	CStringW strPath = rpath;
	rbstrPath = strPath;
}

void CVCToolImpl::CreateDirFromBSTR(BSTR bstrDir, CDirW& rDir)
{
	CStringW strDir = bstrDir;
	rDir.CreateFromKnown(strDir);
}

STDMETHODIMP CVCToolImpl::GenerateDependencies(IVCBuildAction* pAction, void* frhFile, IVCBuildErrorContext* pEC)
{
	return S_OK;	// ok
}

#define HAVE_FILENAME	0x001
#define HAVE_PROPNAME	0x010
#define HAVE_TOOLNAME	0x100

STDMETHODIMP CVCToolImpl::InformUserAboutBadFileName(IVCBuildErrorContext* pEC, IVCPropertyContainer* pPropContainer,
	long nErrPropID, LPCOLESTR szFile)
{
	CStringW strFile = szFile;
	CStringW strPropName;
	if (nErrPropID > 0)
	{
		CStringW strProp;
		strProp.LoadString(nErrPropID);
		int nLoc = strProp.Find(L" :");
		if (nLoc > 0)
			strPropName = strProp.Left(nLoc);
		else
			strPropName = strProp;
		strPropName.TrimLeft();
		strPropName.TrimRight();
	}
	CStringW strTool;
	long nToolID = GetToolID();
	if (nToolID > 0)
		strTool.LoadString(nToolID);

	int nCombo = 0;
	if (!strPropName.IsEmpty())
		nCombo |= HAVE_PROPNAME;
	if (!strFile.IsEmpty())
		nCombo |= HAVE_FILENAME;
	if (!strTool.IsEmpty())
		nCombo |= HAVE_TOOLNAME;

	CStringW strMsg;
	CComBSTR bstrErr;
	if (nCombo == (HAVE_PROPNAME | HAVE_FILENAME | HAVE_TOOLNAME))
	{
		strMsg.Format(IDS_ERR_BADFILE_PRJ0020, strTool, strPropName, strFile);
		bstrErr = L"PRJ0020";
	}
	else if (nCombo == (HAVE_PROPNAME | HAVE_TOOLNAME))
	{
		strMsg.Format(IDS_ERR_BADFILE_PRJ0021, strTool, strPropName);
		bstrErr = L"PRJ0021";
	}
	else if (nCombo == (HAVE_PROPNAME | HAVE_FILENAME))
	{
		strMsg.Format(IDS_ERR_BADFILE_PRJ0022, strPropName, strFile);
		bstrErr = L"PRJ0022";
	}
	else if (nCombo == (HAVE_TOOLNAME | HAVE_FILENAME))
	{
		strMsg.Format(IDS_ERR_BADFILE_PRJ0023, strTool, strFile);
		bstrErr = L"PRJ0023";
	}

	if (!strMsg.IsEmpty())
	{
		CComBSTR bstrMsg = strMsg;
		CVCProjectEngine::AddProjectError(pEC, bstrMsg, bstrErr, pPropContainer);
	}

	return S_OK;
}

void CVCToolImpl::GetEnumVal(IUnknown *pUnk, SOptionEntry *pEntry, CComVariant &var, IDispatch *pDispTool)
{// use type lib to get an enumval
	CComPtr<IDispatch> pDisp = pDispTool;
	if (!pDisp)
	{
		CComQIPtr<VCFileConfiguration> pFileConfig;
		pFileConfig = pUnk;
		if (pFileConfig) // play games to get the tool
		{
			pFileConfig->get_Tool(&pDisp);
		}
	}
	VSASSERT(pDisp, "No tool associated with this file config.  Need either file config or tool to be passed in to GetEnumValue");
	if (!pDisp)
		return;// have to have a dispatch to do this...
	CComPtr<ITypeInfo> pTypeInfo;
	HRESULT  hr = pDisp->GetTypeInfo(0, LOCALE_SYSTEM_DEFAULT, &pTypeInfo);
	if (pTypeInfo && SUCCEEDED(hr))
	{
		TYPEATTR* pta;
		bool bBreak = false;
		hr = pTypeInfo->GetTypeAttr(&pta);
		if (pta)
		{
			for (int iIndex=0; iIndex<pta->cFuncs && !bBreak; iIndex++)
			{
				FUNCDESC* pfd;
				if (SUCCEEDED(pTypeInfo->GetFuncDesc(iIndex, &pfd)) && pfd)
				{
					#ifdef _DEBUG
								CComBSTR bstrPropName;
								pTypeInfo->GetDocumentation(pfd->memid, &bstrPropName, NULL, NULL, NULL);
					#endif
					if (pfd->memid == pEntry->idOption)
					{
						if (pfd->elemdescFunc.tdesc.vt == VT_USERDEFINED)
						{
							CComPtr<ITypeInfo> pTypeInfoRef;
							hr = pTypeInfo->GetRefTypeInfo(pfd->elemdescFunc.tdesc.hreftype, &pTypeInfoRef);
							if (SUCCEEDED(hr) && pTypeInfoRef)
							{
								TYPEATTR* ptaRef;
								hr = pTypeInfoRef->GetTypeAttr(&ptaRef);
								if (ptaRef)
								{
									for (int iIndexRef = 0; ptaRef && SUCCEEDED(hr) && iIndexRef < ptaRef->cVars && !bBreak; iIndexRef++)
									{
										VARDESC* pvdRef;
										if (SUCCEEDED(pTypeInfoRef->GetVarDesc(iIndexRef, &pvdRef)))
										{
											CComBSTR bstrNameItem;
											if (SUCCEEDED(pTypeInfoRef->GetDocumentation(pvdRef->memid, &bstrNameItem, NULL, NULL, NULL)))
											{
												VSASSERT(pvdRef->varkind == VAR_CONST, "Bad varkind");
												if (var == *pvdRef->lpvarValue)
												{
													bBreak = true;
													var = bstrNameItem;
												}
											}
											pTypeInfoRef->ReleaseVarDesc(pvdRef);
										}
									}
									pTypeInfoRef->ReleaseTypeAttr(ptaRef);
								}
							}
						}
					}
					pTypeInfo->ReleaseFuncDesc(pfd);
				}
			}
			pTypeInfo->ReleaseTypeAttr(pta);
		}
	}
}

// Given a path to a source file, 'pathSrc', and a list of include directives, 'strlstIncs',
// this function will return a list of paths, 'lstpath', that represent the 'resolved' (or
// absolute) location of the file represented by each include directive.
// Any standard includes, eg. #include <stdio.h>, will be ignored
// If per-file include directives, eg. compiler /I, exist for the 'pathSrc' then these will be used.
//
// Returns FALSE if the operation cannot be performed.
BOOL CVCToolImpl::ResolveIncludeDirectivesToPath(const CPathW& pathSrc, IVCBuildAction* pAction, 
	const CVCStringWList& strlstIncs, CVCStringWList& lstPath, BOOL fIsInclude /* = TRUE */)
{
	CStringW strIncDirs;	// our include directories
	CStringW strPlatDirs;	// the platform include path
	
	if (!GetIncludePathI(pAction, strIncDirs, &pathSrc, strPlatDirs, fIsInclude))
		return FALSE;
		
	// our base directory
	CDirW dirBase;
	if (!dirBase.CreateFromPath(pathSrc))
		return FALSE;	// failed to get the base directory for the source

	return ResolveIncludeDirectivesI(pAction, strIncDirs, (const CDirW &)dirBase, strlstIncs, lstPath, &pathSrc, strPlatDirs, 
		fIsInclude);
}

// Return the full search path for includes for a file.
// FUTURE: Use per-file include paths, eg. as specified by /i for the linker
BOOL CVCToolImpl::GetIncludePathI(IVCBuildAction* pAction, CStringW& strIncDirs, const CPathW* ppathSrc, CStringW& strPlatDirs, 
	BOOL fIsInclude)
{
	VSASSERT(pAction, "pAction required for GetIncludePathI!");
	RETURN_ON_NULL2(pAction, FALSE);

	BOOL fGotPerFile = FALSE;

	// make all of these relative to the project directory
				
	CComBSTR bstrIncDirs;
	CComPtr<IVCPropertyContainer> spPropContainer;
	pAction->get_PropertyContainer(&spPropContainer);
	VSASSERT(spPropContainer != NULL, "Property container required in order to get IncludeDirectories");
	if (spPropContainer != NULL)
	{
		if (ppathSrc != (const CPathW *)NULL)
		{
			// get the include directories for this tool
			CComPtr<IVCToolImpl> spTool;
			HRESULT hr = pAction->get_VCToolImpl(&spTool);
			VSASSERT(SUCCEEDED(hr), "Action must have a tool!");
			if (spTool != NULL)
			{
				spTool->GetAdditionalIncludeDirectoriesInternal(spPropContainer, &bstrIncDirs);
				fGotPerFile = TRUE;
			}
		}

		// set up the platform dirs
		CComBSTR bstrPlatDirs;
		spPropContainer->GetEvaluatedStrProperty(fIsInclude ? VCPLATID_IncludeDirectories : VCPLATID_LibraryDirectories, 
			&bstrPlatDirs);
		strPlatDirs = bstrPlatDirs;
		if (fGotPerFile)
		{
			spPropContainer->Evaluate(bstrIncDirs, &bstrIncDirs);
			strIncDirs = bstrIncDirs;
		}
	}

	// got per-file includes?
	if (fGotPerFile)
	{
		if (strIncDirs.IsEmpty())	// probably didn't get to evaluate for some reason...
			strIncDirs = bstrIncDirs;
		else if (!strPlatDirs.IsEmpty())
		{
			strIncDirs += L";";
			strIncDirs += strPlatDirs;
		}
	}
	else
		strIncDirs = strPlatDirs;

	return TRUE;	// success 
}

// Internal core for CVCToolImpl::ResolveIncludeDirectives*() methods.
BOOL CVCToolImpl::ResolveIncludeDirectivesI(IVCBuildAction* pAction, CStringW& strlstIncDirs, const CDirW& dirBase,
	const CVCStringWList& strlstIncs, CVCStringWList& lstPath, const CPathW *pathSrc, CStringW& strPlatDirs, BOOL fIsInclude)
{
	// FUTURE: use this information to update our own cache

	// include directive information
	CBldIncludeEntry entry;
	entry.m_OriginalDir = dirBase;
	entry.m_nLineNumber = 0;			// N/A 
	entry.m_bShouldBeScanned = FALSE;	// N/A (not to be scanned)

	CStringW strInclude, strFile;

	VCPOSITION posInc = strlstIncs.GetHeadPosition();
	CBldScannerCache* pScannerCache = NULL;
	if (posInc != (VCPOSITION)NULL && pAction)
	{
		CComPtr<IVCBuildableItem> spItem;
		pAction->get_Item(&spItem);
		if (spItem)
		{
			CComPtr<IVCBuildEngine> spBuildEngine;
			spItem->get_ExistingBuildEngine(&spBuildEngine);
			CComQIPtr<IVCBuildEngineImpl> spBuildEngineImpl = spBuildEngine;
			if (spBuildEngineImpl)
				spBuildEngineImpl->get_ScannerCache((void **)&pScannerCache);
		}
	}

	while (posInc != (VCPOSITION)NULL)
	{
		// get the include directive,
		// this is of the forms "file" or <file>
		strInclude = strlstIncs.GetNext(posInc);

		int cchInclude = strInclude.GetLength();
		const wchar_t * pchInclude = strInclude;

		if (*pchInclude != L'<' && *pchInclude != L'\"' && *pchInclude != L'\'')
		{
            // [paulde] change from assert to TRACE because some callers have a 
            // legitimate need to pass names that don't begin with these chars,
            // and for those that care, you at least get a trace message.
			ATLTRACE("CVCToolImpl::ResolveIncludeDirectivesI: file does not begin with [<\"']\n");
			return FALSE;
		}

		// standard include?
		if (fIsInclude)
			entry.m_EntryType = (*pchInclude == L'<') ?	IncTypeCheckIncludePath : IncTypeCheckIncludePath | IncTypeCheckOriginalDir;
		else
			entry.m_EntryType = IncTypeCheckLibPath | IncTypeCheckIntDir | IncTypeCheckOutDir | IncTypeCheckOriginalDir;

		// strip the leading and trailing characters from 'strInclude'
		wchar_t* pchFile = strFile.GetBuffer(cchInclude - 1);
		wcsncpy(pchFile, pchInclude + 1, cchInclude - 2);
		pchFile[cchInclude - 2] = L'\0';
		strFile.ReleaseBuffer();

		BOOL fIgnore = TRUE;	// by default ignore

		// is this a system include? ignore?
		CComPtr<VCConfiguration> spProjCfg;
		if (pAction != NULL)
		{
			pAction->get_ProjectConfiguration(&spProjCfg);
		}

		entry.m_FileReference = strFile;	// the file
		entry.CheckAbsolute();				// check the absoluteness of scanned dep.

		BldFileRegHandle frhFile = NULL;	// the 'resolved' file

		// build directory to make relative to?
		CStringW strProjDir;
		CComPtr<IVCBuildableItem> spItem;
		if (pAction != NULL)
		{
			pAction->get_Item(&spItem);
			CComQIPtr<IVCPropertyContainer> spPropContainer = spItem;
			VSASSERT(spPropContainer != NULL, "Property container required in order to get ProjectDirectory");
			CComBSTR bstrProjDir;
			if (spPropContainer != NULL)
				spPropContainer->GetStrProperty(VCPROJID_ProjectDirectory, &bstrProjDir);	// should never have macros in it
			strProjDir = bstrProjDir;
		}

		if (entry.FindFile((const wchar_t *)strlstIncDirs, dirBase, (const wchar_t *)strProjDir, frhFile, spItem, 
			pScannerCache, strPlatDirs))
		{
			CStringW strFile2;
			frhFile->GetFilePath()->GetFullPath(strFile2);
			if (g_SysInclReg.IsSysInclude(strFile2))
				frhFile->ReleaseFRHRef();	// going to be ignoring it
			else
			{
				CBldFileRegEntry * pfilereg = g_FileRegistry.GetRegEntry(frhFile);
				VSASSERT(pfilereg != (CBldFileRegEntry *)NULL, "frhFile not in global registry.  Either released too early or not added to begin with.");

				// add path to our list
				lstPath.AddTail((CStringW)*pfilereg->GetFilePath());
				frhFile->ReleaseFRHRef();
				fIgnore = FALSE;	// don't ignore 
			}
		}
		else if (NULL != frhFile)
		{
			frhFile->ReleaseFRHRef();
#ifdef DIANEME_DEP_CHECK_DIAGNOSTICS
			CStringA str = strFile;
			ATLTRACE("\tFailed to find input dependency file '%s'\n", str);
#endif	// DIANEME_DEP_CHECK_DIAGNOSTICS
			return FALSE;	// didn't find it
		}
	}

	return TRUE;	// success
}

BOOL CVCToolImpl::FileNameMatchesExtension(const CPathW* pPath, const  wchar_t* pExtensions)
{
	if (pPath == (const CPathW *)NULL)	
		return FALSE;

	const wchar_t* pExtNext = pExtensions;
	const wchar_t* pFileExt = pPath->GetExtension();
	if (*pFileExt)
		pFileExt++;
		// GetExtension() returns pointer to '.'

	INT_PTR n = wcslen(pFileExt);

	if (n)
	{
		while (*pExtNext != L'\0')
		{
			pExtNext = pExtensions;
			while (*pExtNext != L';' && *pExtNext != L',' && *pExtNext != L'\0')
				pExtNext++;

			// skip over the optional '*.'
			if (pExtensions[0] == L'*' && pExtensions[1] == L'.')
				pExtensions += 2;
			else if (pExtensions[0] == L'.')
				pExtensions += 1;

			// compare extensions in case-insensitive fashion
			if ((n == (pExtNext - pExtensions)) &&			// check for ext. length equivalence
				_wcsnicmp (pFileExt, pExtensions, n) == 0)	// check for ext. string equivalence
				return TRUE;

			pExtensions = pExtNext + 1;	// skip over the sep.
		}
	}

	return FALSE;
}

BOOL CVCToolImpl::IsExcludedFromBuild(IVCPropertyContainer* pPropContainer)
{
	RETURN_ON_NULL2(pPropContainer, TRUE);	// nothing there to build...

	VARIANT_BOOL bExcluded = VARIANT_FALSE;
	if (pPropContainer->GetBoolProperty(VCFCFGID_ExcludedFromBuild, &bExcluded) != S_OK)
		return FALSE;

	return (bExcluded == VARIANT_TRUE);
}

HRESULT CVCToolImpl::GetProcessedAdditionalOptions(IUnknown* pItem, long idProp, VARIANT_BOOL bForBuild, 
	VARIANT_BOOL bSkipLocal, BSTR* pbstrAdditionalOptions)
{
	CComQIPtr<IVCPropertyContainer> spContainer = pItem;
	RETURN_ON_NULL2(spContainer, E_NOINTERFACE);
	CHECK_POINTER_NULL(pbstrAdditionalOptions);
	*pbstrAdditionalOptions = NULL;
	
	HRESULT hr;
	if (bSkipLocal)
	{
		CComPtr<IVCPropertyContainer> spActualPropContainer;
		CVCProjectEngine::ResolvePropertyContainer(spContainer, &spActualPropContainer);
		hr = spActualPropContainer->GetMultiProp(idProp, L" ", VARIANT_TRUE, pbstrAdditionalOptions);
	}
	else if (bForBuild)
		hr = spContainer->GetMultiProp(idProp, L" ", VARIANT_FALSE, pbstrAdditionalOptions);
	else
	{
		CComVariant var;
		hr = spContainer->GetLocalProp(idProp, &var);
		if (hr == S_OK && var.vt == VT_BSTR)
		{
			CComBSTR bstrOptions = var.bstrVal;
			*pbstrAdditionalOptions = bstrOptions.Detach();
		}
		else if (SUCCEEDED(hr))
		{
			CComPtr<IVCPropertyContainer> spActualPropContainer;
			CVCProjectEngine::ResolvePropertyContainer(spContainer, &spActualPropContainer);
			if (spActualPropContainer)
			{
				hr = spActualPropContainer->GetLocalProp(idProp, &var);
				if (hr == S_OK && var.vt == VT_BSTR)
				{
					CComBSTR bstrOptions = var.bstrVal;
					*pbstrAdditionalOptions = bstrOptions.Detach();
				}
			}
		}
	}
	if (hr == S_FALSE)
		COptionHandlerBase::GetDefaultString(pbstrAdditionalOptions);
	return hr;
}

BOOL CVCToolImpl::CreatePathRelativeToProject(IVCPropertyContainer* pPropContainer, CStringW& strName, CPathW& pathName)
{
	CComBSTR bstrProjectDirectory;
	pPropContainer->GetStrProperty(VCPROJID_ProjectDirectory, &bstrProjectDirectory);
	CDirW baseDir;
	CreateDirFromBSTR(bstrProjectDirectory, baseDir);
	return pathName.CreateFromDirAndFilename(baseDir, strName);
}

HRESULT CVCToolImpl::DoMatchName(BSTR bstrName, const wchar_t* szToolType, const wchar_t* szShortName, VARIANT_BOOL* pbMatches)
{
	CHECK_POINTER_NULL(pbMatches);	// this MatchName is on a private interface and so doesn't need the strong protection
	*pbMatches = VARIANT_FALSE;
	RETURN_INVALID_ON_NULL(bstrName);

	*pbMatches = _wcsicmp(szShortName, bstrName) == 0 ? VARIANT_TRUE : VARIANT_FALSE;
	if (*pbMatches == VARIANT_TRUE)
		return S_OK;

	*pbMatches = _wcsicmp(szToolType, bstrName) == 0 ? VARIANT_TRUE : VARIANT_FALSE;
	if (*pbMatches == VARIANT_TRUE)
		return S_OK;
	
	*pbMatches = _wcsicmp(GetToolFriendlyName(), bstrName) == 0 ? VARIANT_TRUE : VARIANT_FALSE;
	return S_OK;
}

HRESULT CVCToolImpl::DoGetDefaultExtensions(CComBSTR& bstrSetExtensions, const wchar_t* const wszBaseDefaultExtensions, BSTR* pbstrVal)
{
	CHECK_POINTER_NULL(pbstrVal);
	if (bstrSetExtensions.Length() == 0)
		bstrSetExtensions = wszBaseDefaultExtensions;
	bstrSetExtensions.CopyTo(pbstrVal);
	return S_OK;
}

STDMETHODIMP CVCToolImpl::get_FullIncludePathInternal(BSTR* pbstrIncPath)
{	// include path, including all inherited values, plus platform includes
	CHECK_POINTER_NULL(pbstrIncPath);
	*pbstrIncPath = NULL;
	CHECK_ZOMBIE(m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE);

	CComBSTR bstrPlatformIncs, bstrTemp;
	HRESULT hr = m_spPropertyContainer->GetStrProperty(VCPLATID_IncludeDirectories, &bstrTemp);
	RETURN_ON_FAIL(hr);
	hr = m_spPropertyContainer->Evaluate(bstrTemp, &bstrPlatformIncs);
	RETURN_ON_FAIL(hr);

	long nPathID = 0;
	if (FAILED(get_IncludePathID(&nPathID)) || nPathID <= 0)
	{
		if (bstrPlatformIncs)
			*pbstrIncPath = bstrPlatformIncs.Detach();
		return S_OK;
	}

	CComBSTR bstrOverridePath;
	hr = m_spPropertyContainer->GetEvaluatedMultiProp(nPathID, L";,", VARIANT_FALSE, VARIANT_FALSE, &bstrOverridePath);
	if (FAILED(hr))
	{
		*pbstrIncPath = bstrPlatformIncs.Detach();
		return S_OK;
	}

	int nPlatLen = bstrPlatformIncs.Length();
	int nOverrideLen = bstrOverridePath.Length();

	if( nOverrideLen > 0 )
	{
		// fix up embeded spaces that shouldn't be there.
		CStringW str;
		wchar_t* szNoSpaces = str.GetBuffer(nOverrideLen+1);
		BOOL skipping = TRUE;
		int i,j;
		wchar_t c;
		for( i=0,j=0; bstrOverridePath[i] != NULL; i++ )
		{
		    	c=bstrOverridePath[i];
		    	if( c == L',' )
				c = L';';

			if( skipping )
			{
				if( c == L' ' )
					continue;
				else
					skipping = FALSE;
			}
			if( c == L';' )
				skipping = TRUE;

			szNoSpaces[j] = c;
			j++;
		}
		szNoSpaces[j] = NULL;
		str.ReleaseBuffer();
		bstrOverridePath = str;
		nOverrideLen = bstrOverridePath.Length();
	}

	if (nPlatLen && nOverrideLen)
	{ 
		bstrOverridePath += L";";
		bstrOverridePath += bstrPlatformIncs;
		*pbstrIncPath = bstrOverridePath.Detach();
	}
	else if (nPlatLen)
		*pbstrIncPath = bstrPlatformIncs.Detach();
	else if (nOverrideLen)
		*pbstrIncPath = bstrOverridePath.Detach();

	return S_OK;
}

static const wchar_t* const wszEnd =
	L"\nif errorlevel 1 goto VCReportError\n"
	L"goto VCEnd\n"
	L":VCReportError\n"
	L"echo Project : error PRJ0019: ";

void CVCToolImpl::BuildCommandLineBatchFile(IVCBuildAction* pAction, CComBSTR& bstrCommandLineEnd, CComBSTR& bstrCmdLine)
{
	bstrCmdLine = L"@echo off\n";
	bstrCmdLine += bstrCommandLineEnd;
	bstrCmdLine.Append(wszEnd);
	CComBSTR bstrError;
	bstrError.LoadString( IDS_ERR_CUSTOM_PRJ0019 );
	bstrCmdLine.Append( bstrError );

	CComBSTR bstrDesc;
	GetBuildDescription( pAction, &bstrDesc );

	int nLen = bstrDesc.Length();
	if (nLen > 0)
	{
		bstrCmdLine += L"\"";
		bstrCmdLine += bstrDesc;
		bstrCmdLine += L"\"";
	}
	bstrCmdLine += L"\nexit 1\n:VCEnd";
}

#ifndef _SHIP
HRESULT CVCToolImpl::ForceDirty()
{
	CComPtr<IVCPropertyContainer> spActualContainer;
	CVCProjectEngine::ResolvePropertyContainer(m_spPropertyContainer, &spActualContainer);
	CHECK_ZOMBIE(spActualContainer, IDS_ERR_TOOL_ZOMBIE);

	HRESULT hr = VCPROJ_E_ZOMBIE;
	CComPtr<IDispatch> spDispProject;
	CComQIPtr<VCConfiguration> spProjConfig;
	CComQIPtr<IVCFileConfigurationImpl> spFileCfgImpl = spActualContainer;
	if (spFileCfgImpl)
	{
		CComPtr<IDispatch> spDispCfg;
		hr = spFileCfgImpl->get_Configuration(&spDispCfg);
		RETURN_ON_FAIL(hr);
		spProjConfig = spDispCfg;
	}
	else
		spProjConfig = spActualContainer;

	if (spProjConfig)
		hr = spProjConfig->get_Project(&spDispProject);
	else
		return CVCProjectEngine::DoSetErrorInfo(VCPROJ_E_ZOMBIE, IDS_ERR_TOOL_ZOMBIE);

	CComQIPtr<IVCProjectImpl> spProjectImpl = spDispProject;
	if (spProjectImpl)
		return spProjectImpl->put_IsConverted(VARIANT_TRUE);

	return CVCProjectEngine::DoSetErrorInfo(VCPROJ_E_ZOMBIE, IDS_ERR_TOOL_ZOMBIE);
}
#endif	// _SHIP

HRESULT CVCToolImpl::DoGetVCProjectEngine(IDispatch** ppProjEngine)
{
	CHECK_POINTER_VALID(ppProjEngine);
	RETURN_ON_NULL(g_pProjectEngine);
	return g_pProjectEngine->QueryInterface(IID_IDispatch, (void **)ppProjEngine);
}

HRESULT CVCToolImpl::ToolGetStrProperty(long idProp, BSTR* pVal, bool bLocalOnly /* = false */)
{
	CHECK_ZOMBIE( m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE );
	CHECK_POINTER_VALID( pVal );
	HRESULT hr = S_OK;
	
	if (bLocalOnly)
	{
		*pVal = NULL;
		CComVariant var;
		hr = m_spPropertyContainer->GetLocalProp(idProp, &var);
		if (hr == S_OK && var.vt == VT_BSTR)
		{
			CComBSTR bstrVal = var.bstrVal;
			*pVal = bstrVal.Detach();
		}
	}
	else
	{
		hr = m_spPropertyContainer->GetStrProperty(idProp, pVal);
		if (hr == S_FALSE && GetOptionHandler())
			GetOptionHandler()->GetDefaultValue( idProp, pVal, m_spPropertyContainer );
	}
	return hr;
}

HRESULT CVCToolImpl::ToolGetIntProperty(long idProp, long* pVal)
{
	CHECK_ZOMBIE( m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE );
	CHECK_POINTER_VALID( pVal );
	HRESULT hr = m_spPropertyContainer->GetIntProperty(idProp, pVal);
	if (hr == S_FALSE && GetOptionHandler())
		GetOptionHandler()->GetDefaultValue( idProp, pVal, m_spPropertyContainer );
	return hr;
}

HRESULT CVCToolImpl::ToolGetBoolProperty(long idProp, VARIANT_BOOL* pVal)
{
	CHECK_ZOMBIE( m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE );
	CHECK_POINTER_VALID( pVal );
	HRESULT hr = m_spPropertyContainer->GetBoolProperty(idProp, pVal);
	if (hr == S_FALSE && GetOptionHandler())
		GetOptionHandler()->GetDefaultValue( idProp, pVal, m_spPropertyContainer );
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\vcpb\XboxDeployTool.cpp ===
// XboxDeployTool.cpp : Implementation of Xbox Deployment Tool

#include "stdafx.h"
#include "XboxDeployTool.h"
#include "BuildEngine.h"
#include "scanner.h"
#include "ProjWriter.h"
#include "XMLFile.h"
#include "stylesheet.h"
#include "linktool.h"

// constants
const wchar_t* const wszXboxDeployDefaultExtensions = L"";	// remember to update Xbox.rgs if you change this...

// static initializers
CXboxDeployToolOptionHandler CXboxDeploymentTool::s_optHandler;
CComBSTR CXboxDeploymentTool::s_bstrBuildDescription = L"";
CComBSTR CXboxDeploymentTool::s_bstrToolName = L"";
CComBSTR CXboxDeploymentTool::s_bstrExtensions = L"";
GUID CXboxDeploymentTool::s_pPages[1];
BOOL CXboxDeploymentTool::s_bPagesInit;

////////////////////////////////////////////////////////////////////////////////
// Option Table for Web Service Utility switches

// NOTE: we're using macros for enum value ranges to help in keeping enum range checks as low maintenance as possible.
// If you add an enum to this table, make sure you use macros to define the upper and lower bounds and use CHECK_BOUNDS
// on the get/put methods associated with that property (both object model and property page).
// NOTE 2: this table is being used for persistence ONLY.  We generate our command line elsewhere since it is an XML file.
// WARNING: if you change ANYTHING about a multi-prop here (including add/remove), be sure to update how the property
// is obtained on both the tool and page objects.
BEGIN_OPTION_TABLE(CXboxDeployToolOptionHandler, L"XboxDeploymentTool", IDS_XBOXDEPLOYTOOL, TRUE /* pre & post */, FALSE /* case sensitive */)
	// general
	OPT_BOOL(ExcludedFromBuild,		L"F1|T1",		L"ExcludedFromBuild",		IDS_XBOXDEPLOYTOOL,	XBOXDPLYID)
	OPT_BSTR(RemotePath,			L"B %s",		L"RemotePath",	single,	IDS_XBOXDEPLOYTOOL,	XBOXDPLYID)
	OPT_BSTR(AdditionalFiles,		L"A %s",		L"AdditionalFiles",	single,	IDS_XBOXDEPLOYTOOL,	XBOXDPLYID)
END_OPTION_TABLE()


// default value handlers
// string props
void CXboxDeployToolOptionHandler::GetDefaultValue( long id, BSTR *pVal, IVCPropertyContainer *pPropCnt )
{
	CComBSTR bstrDef;
	switch (id)
	{
	case XBOXDPLYID_RemotePath:
		bstrDef = L"xe:\\$(SolutionName)";
		*pVal = bstrDef.Detach();
		break;
//	case XBOXDPLYID_AdditionalFiles:
//	case XBOXDPLYID_ApplicationMappings:
	default:
		GetDefaultString(pVal);
		break;
	}
}

// integer props
void CXboxDeployToolOptionHandler::GetDefaultValue( long id, long *pVal, IVCPropertyContainer *pPropCnt )
{
	// Nothing
	*pVal = 0;
}

// boolean props
void CXboxDeployToolOptionHandler::GetDefaultValue( long id, VARIANT_BOOL *pVal, IVCPropertyContainer *pPropCnt )
{
	// XBOXDPLYID_ExcludedFromBuild
	GetValueFalse( pVal );
}


///////////////////////////////////////////////////////////////////////////////
// Xbox Deployment Tool
HRESULT CXboxDeploymentTool::CreateInstance(IVCPropertyContainer* pPropContainer, IVCToolImpl** ppDeployTool)
{
	CHECK_POINTER_NULL(ppDeployTool);
	*ppDeployTool = NULL;

	CComObject<CXboxDeploymentTool> *pObj;
	HRESULT hr = CComObject<CXboxDeploymentTool>::CreateInstance(&pObj);
	if (SUCCEEDED(hr))
	{
		if( pPropContainer )
			pObj->Initialize(pPropContainer);
		CXboxDeploymentTool *pVar = pObj;
		pVar->AddRef();
		*ppDeployTool = pVar;
	}
	return hr;
}

STDMETHODIMP CXboxDeploymentTool::CreatePageObject(IUnknown **ppUnk, CLSID*pCLSID, IVCPropertyContainer *pPropCntr, IVCSettingsPage *pPage )
{
	// Get the list of pages
	if( CLSID_XboxDeploymentGeneral == *pCLSID )
	{
		CPageObjectImpl< CXboxDeploymentGeneralPage, XBOXVCDPLYTOOL_MIN_DISPID, XBOXVCDPLYTOOL_MAX_DISPID >::CreateInstance(ppUnk, pPropCntr, pPage);
	}
	else
	{
		return S_FALSE;
	}
		
	return S_OK;
}


GUID* CXboxDeploymentTool::GetPageIDs()
{ 
	if (s_bPagesInit == FALSE)
	{
		s_pPages[0] = __uuidof(XboxDeploymentGeneral);
		s_bPagesInit = TRUE;
	}
	return s_pPages; 
}


///////////////////////////////////////////////////////////////////////////////////////
// CXboxDeploymentTool::CXboxDeploymentTool
///////////////////////////////////////////////////////////////////////////////////////

// general 
LPCOLESTR CXboxDeploymentTool::GetToolFriendlyName()
{
	InitToolName();
	return s_bstrToolName;
}

void CXboxDeploymentTool::InitToolName()
{
	if (s_bstrToolName.Length() == 0)
	{
		if (!s_bstrToolName.LoadString(IDS_XBOXDEPLOY_TOOLNAME))
			s_bstrToolName = szXboxDeployToolType;
	}
}

STDMETHODIMP CXboxDeploymentTool::get_ToolName(BSTR* pbstrToolName)
{	// friendly name of tool, e.g., "C/C++ Compiler Tool"
	CHECK_POINTER_VALID( pbstrToolName );
	InitToolName();
	s_bstrToolName.CopyTo(pbstrToolName);
	return S_OK;
}

STDMETHODIMP CXboxDeploymentTool::get_ExcludedFromBuild(VARIANT_BOOL* disableDeploy)
{	// exclude from build? default: yes
	return ToolGetBoolProperty(XBOXDPLYID_ExcludedFromBuild, disableDeploy);
}

STDMETHODIMP CXboxDeploymentTool::put_ExcludedFromBuild(VARIANT_BOOL disableDeploy)
{
	CHECK_ZOMBIE(m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE);
	CHECK_VARIANTBOOL(disableDeploy);
	return m_spPropertyContainer->SetBoolProperty(XBOXDPLYID_ExcludedFromBuild, disableDeploy);
}

STDMETHODIMP CXboxDeploymentTool::get_RemotePath(BSTR* dir)
{	// relative path to deploy to
	return ToolGetStrProperty(XBOXDPLYID_RemotePath, dir);
}

STDMETHODIMP CXboxDeploymentTool::put_RemotePath(BSTR dir)
{
	CHECK_ZOMBIE(m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE);
	return m_spPropertyContainer->SetStrProperty(XBOXDPLYID_RemotePath, dir);
}

STDMETHODIMP CXboxDeploymentTool::get_AdditionalFiles(BSTR* files)
{	// additional files to deploy
	return ToolGetStrProperty(XBOXDPLYID_AdditionalFiles, files);
}

STDMETHODIMP CXboxDeploymentTool::put_AdditionalFiles(BSTR files)
{
	CHECK_ZOMBIE(m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE);
	return m_spPropertyContainer->SetStrProperty(XBOXDPLYID_AdditionalFiles, files);
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
// CXboxDeploymentTool::IVCToolImpl
/////////////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CXboxDeploymentTool::get_DefaultExtensions(BSTR* pVal)
{
	return DoGetDefaultExtensions(s_bstrExtensions, wszXboxDeployDefaultExtensions, pVal);
}

STDMETHODIMP CXboxDeploymentTool::put_DefaultExtensions(BSTR newVal)
{
	s_bstrExtensions = newVal;
	return S_OK;
}

STDMETHODIMP CXboxDeploymentTool::GetAdditionalOptionsInternal(IUnknown* pItem, VARIANT_BOOL bForBuild, VARIANT_BOOL bSkipLocal, 
	BSTR* pbstrAdditionalOptions)
{
	return S_FALSE;
}

STDMETHODIMP CXboxDeploymentTool::GetBuildDescription(IVCBuildAction* pAction, BSTR* pbstrBuildDescription)
{
	if (s_bstrBuildDescription.Length() == 0)
		s_bstrBuildDescription.LoadString(IDS_DESC_XBOXDEPLOYING);
	return s_bstrBuildDescription.CopyTo(pbstrBuildDescription);
}

STDMETHODIMP CXboxDeploymentTool::get_ToolPathInternal(BSTR* pbstrToolPath)
{ 
	return get_ToolPath(pbstrToolPath);
}

STDMETHODIMP CXboxDeploymentTool::get_Bucket(long *pVal)
{
	CHECK_POINTER_NULL( pVal );
	*pVal = BUCKET_XBOXDEPLOY;
	return S_OK;
}

STDMETHODIMP CXboxDeploymentTool::CreateToolObject(IVCPropertyContainer* pPropContainer, IVCToolImpl** ppToolObject)
{ 
	return CreateInstance(pPropContainer, ppToolObject); 
}

STDMETHODIMP CXboxDeploymentTool::GetAdditionalIncludeDirectoriesInternal(IVCPropertyContainer* pPropContainer, BSTR* pbstrIncDirs)
{
	return E_NOTIMPL;
}

STDMETHODIMP CXboxDeploymentTool::get_ToolShortName(BSTR* pbstrToolName)
{
	CHECK_POINTER_NULL(pbstrToolName);
	*pbstrToolName = SysAllocString( szXboxDeployToolShortName );
	return S_OK;
}

STDMETHODIMP CXboxDeploymentTool::MatchName(BSTR bstrName, VARIANT_BOOL bFullOnly, VARIANT_BOOL* pbMatches)
{
	return DoMatchName(bstrName, szXboxDeployToolType, szXboxDeployToolShortName, pbMatches);
}

HRESULT CXboxDeploymentTool::DoGetToolPath(BSTR* pbstrToolPath, IVCPropertyContainer* pPropContainer)
{
	CHECK_POINTER_NULL(pbstrToolPath);
	*pbstrToolPath = SysAllocString( szXboxDeployToolPath );
	return S_OK;
}

STDMETHODIMP CXboxDeploymentTool::get_ToolPath(BSTR* pbstrToolPath)
{
	return DoGetToolPath(pbstrToolPath, m_spPropertyContainer);
}

STDMETHODIMP CXboxDeploymentTool::get_PropertyOption(BSTR bstrProp, long dispidProp, BSTR *pVal)
{ 
	return E_NOTIMPL;
}

STDMETHODIMP CXboxDeploymentTool::IsTargetTool(IVCBuildAction* pAction, VARIANT_BOOL* pbTargetTool)
{ // tool always operates on target, not on file
	return COptionHandlerBase::GetValueTrue(pbTargetTool);
}

STDMETHODIMP CXboxDeploymentTool::get_IsFileTool(VARIANT_BOOL* pbIsFileTool)
{
	return COptionHandlerBase::GetValueFalse(pbIsFileTool);
}

static HRESULT ConvertExeToXbe(CComBSTR& b)
{
	// Replace .exe with .xbe
	int nLength = b.Length();
	if(nLength >= 4){
		LPWSTR p =  b.m_str + nLength - 4;
		if(p[0] == '.'
			&& (p[1] == 'e' || p[1] == 'E')
			&& (p[2] == 'x' || p[2] == 'X')
			&& (p[3] == 'e' || p[3] == 'E'))
		{
			p[1] = 'x';
			p[2] = 'b';
			p[3] = 'e';
			return S_OK;
		}
	}
	return E_FAIL;
}

STDMETHODIMP CXboxDeploymentTool::GetCommandLineEx(IVCBuildAction* pAction, IVCBuildableItem* pBuildableItem, 
	IVCBuildEngine* pBuildEngine, IVCBuildErrorContext* pEC, BSTR *pVal)
{
	CHECK_POINTER_NULL(pVal);
	*pVal = NULL;
	CHECK_READ_POINTER_NULL(pBuildableItem);
	CHECK_READ_POINTER_NULL(pBuildEngine);

	CComQIPtr<IVCPropertyContainer> spPropContainer = pBuildableItem;
	CHECK_ZOMBIE(spPropContainer, IDS_ERR_TOOL_ZOMBIE);

#ifdef USE_XML

	// NONE of this stuff is localizable which is why it is inline here...
	CComBSTR bstrCmdLine = L"<?xml version=\"1.0\" encoding=\"";
	CComBSTR bstrTmp, bstrTmp2;
	CXMLFile::DetermineDefaultFileEncoding(bstrTmp);
	bstrCmdLine += bstrTmp;

#if 0
	bstrCmdLine += L"\"?>\n<ATLSINSTSETTINGS>\n\t<WEBHOSTNAME>localhost</WEBHOSTNAME>\n";
#endif

#if 1 // No Virtual Directory name
	HRESULT hr = S_OK;
	int nLen;
#else

	// figure out the virtual root and the IIS root directory
	bstrTmp.Empty();
	CComBSTR bstrVirtDir;
	HRESULT hr = spPropContainer->GetStrProperty(XBOXDPLYID_VirtualDirectoryName, &bstrTmp);
	if (hr == S_FALSE)
		s_optHandler.GetDefaultValue(XBOXDPLYID_VirtualDirectoryName, &bstrTmp);
	hr = spPropContainer->Evaluate(bstrTmp, &bstrVirtDir);
	RETURN_ON_FAIL(hr);
	if (bstrVirtDir.Length() == 0)	// cannot have a blank virtual root...
	{
		bstrTmp.Empty();
		bstrVirtDir.Empty();
		s_optHandler.GetDefaultValue(XBOXDPLYID_VirtualDirectoryName, &bstrTmp);
		hr = spPropContainer->Evaluate(bstrTmp, &bstrVirtDir);
		RETURN_ON_FAIL(hr);
	}

	bstrCmdLine += L"\t<VIRTDIRNAME>";
	if (bstrVirtDir.Length())
		bstrCmdLine += bstrVirtDir;
	bstrCmdLine += L"</VIRTDIRNAME>\n";

	bstrTmp.Empty();
	hr = CVCProjectEngine::GetPathWWWRoot(bstrTmp);
//	RETURN_ON_FAIL(hr);		// Don't return on fail here.  Let VCDeploy have the chance to tell the user there 
							// is a problem with their install.
	BOOL bNotAdmin = bstrTmp.Length() && wcscmp(bstrTmp, L"!admin") == 0;
	int nLen = bstrTmp.Length();
	if (bNotAdmin)
	{}	// don't do anything
	else if (nLen <= 0)
		bstrTmp = L"";
	else if (bstrTmp[nLen-1] != L'/' && bstrTmp[nLen-1] != L'\\')
		bstrTmp += L"\\";

	bstrCmdLine += L"\t<VIRTDIRFSPATH>";
	bstrCmdLine += bstrTmp;
	if (!bNotAdmin)
		bstrCmdLine += bstrVirtDir;
	bstrCmdLine += L"</VIRTDIRFSPATH>\n";

	VARIANT_BOOL bReg = VARIANT_FALSE;
	if (spPropContainer->GetBoolProperty(XBOXDPLYID_RegisterOutput, &bReg) == S_OK && bReg)
		bstrCmdLine += L"\t<REGISTERISAPI>true</REGISTERISAPI>\n";

	VARIANT_BOOL bUnload = VARIANT_FALSE;
	if (spPropContainer->GetBoolProperty(XBOXDPLYID_UnloadBeforeCopy, &bUnload) == S_OK && bUnload)
		bstrCmdLine += L"\t<UNLOADBEFORECOPY>true</UNLOADBEFORECOPY>\n";

	long nProtect = 0;
	hr = spPropContainer->GetIntProperty(XBOXDPLYID_ApplicationProtection, &nProtect);
	if (hr == S_FALSE)
		s_optHandler.GetDefaultValue(XBOXDPLYID_ApplicationProtection, &nProtect, spPropContainer);
	if (SUCCEEDED(hr))
	{
		CStringW strTmp;
		strTmp.Format(L"\t<APPISOLATION>%d</APPISOLATION>\n", nProtect);
		bstrTmp = strTmp;
		bstrCmdLine += bstrTmp;
	}

	bstrTmp.Empty();
	bstrTmp2.Empty();
	BOOL bHaveMappings = FALSE;
	if (spPropContainer->GetStrProperty(XBOXDPLYID_ApplicationMappings, &bstrTmp) == S_OK && bstrTmp.Length() > 0)
	{
		hr = spPropContainer->Evaluate(bstrTmp, &bstrTmp2);
		RETURN_ON_FAIL(hr);
		CStringW strMapList = bstrTmp2;
		int nMaxIdx = strMapList.GetLength();
		int nStartMap = 0;
		while (nStartMap >= 0)
		{
			CComBSTR bstrMapping;
			nStartMap = CStyleSheetBase::GetNextStyle(strMapList, nStartMap, nMaxIdx, bstrMapping);
			if (bstrMapping.Length() > 0)
			{
				bstrCmdLine += L"\n\t<APPMAPPING fileext=\"";
				bstrCmdLine += bstrMapping;
				bstrCmdLine += L"\">\n\t\t<VERB>GET</VERB>\n\t\t<VERB>HEAD</VERB>\n\t\t<VERB>POST</VERB>\n\t\t<VERB>DEBUG</VERB>\n\t</APPMAPPING>\n";
				bHaveMappings = TRUE;
			}
		}
	}
#endif

	
	CComBSTR bstrProjDir;
	spPropContainer->GetStrProperty(VCPROJID_ProjectDirectory, &bstrProjDir);
	CStringW strProjDir = bstrProjDir;
	int nProjDirLen = strProjDir.GetLength();
	if (strProjDir.IsEmpty())
		return CVCProjectEngine::DoSetErrorInfo(VCPROJ_E_INTERNAL_ERR, IDS_ERR_INTERNAL_ERROR);

	CDirW dirProj;
	dirProj.CreateFromKnown(strProjDir);

	// now, let's get the files we're going to be transferring
	bstrCmdLine += L"\n\t<APPFILEGROUP>\n";

	CVCMapStringWToPtr mapFiles;	// this will cover any files we already know about so we don't add them twice...

	// first, let's pass through any additional files we may have been given
	bstrTmp.Empty();
	if (spPropContainer->GetStrProperty(XBOXDPLYID_AdditionalFiles, &bstrTmp) == S_OK && bstrTmp.Length() > 0)
	{
		bstrTmp2.Empty();
		hr = spPropContainer->Evaluate(bstrTmp, &bstrTmp2);
		RETURN_ON_FAIL(hr);

		CStringW strFileList = bstrTmp2;
		int nMaxIdx = strFileList.GetLength();
		int nStartFiles = 0;
		while (nStartFiles >= 0)
		{
			CComBSTR bstrFile;
			nStartFiles = CStyleSheetBase::GetNextStyle(strFileList, nStartFiles, nMaxIdx, bstrFile);
			CStringW strFile = bstrFile;
			if (!strFile.IsEmpty())
			{
				CPathW pathFile;
				if (!pathFile.CreateFromDirAndFilename(dirProj, strFile))
				{
					CComBSTR bstrErr;
					bstrErr.LoadString(IDS_ERR_DEPLOY_ADDL_FILE_INVALID_PRJ0036);
					CVCProjectEngine::AddProjectError(pEC, bstrErr, L"PRJ0036", spPropContainer);
					return E_FAIL;
				}
				CStringW strFileLower = pathFile.GetFullPath();
				strFileLower.MakeLower();
				void* pDummy;
				if (!mapFiles.Lookup(strFileLower, pDummy))
				{
					bstrCmdLine += L"\t\t<APPFILENAME>\n\t\t\t<SRC>";
					strFile = pathFile.GetFullPath();
					bstrTmp = strFile;
					bstrCmdLine += bstrTmp;
					bstrCmdLine += L"</SRC>\n\t\t\t<DEST>";
					if (_wcsnicmp(strProjDir, strFile, nProjDirLen) == 0)
						pathFile.GetRelativeName(dirProj, strFile);
					else
						strFile = pathFile.GetFileName();
					bstrFile = strFile;
					bstrCmdLine += bstrFile;
					bstrCmdLine += L"</DEST>\n\t\t</APPFILENAME>\n";
					mapFiles.SetAt(strFileLower, pDummy);
				}
			}
		}
	}

	// now, add any deployment content
	CComQIPtr<VCConfiguration> spProjCfg = spPropContainer;
	if (spProjCfg == NULL)
	{
		CComQIPtr<IVCFileConfigurationImpl> spFileCfgImpl = spPropContainer;
		RETURN_ON_NULL(spFileCfgImpl);
		CComPtr<IDispatch> spDispProjCfg;
		spFileCfgImpl->get_Configuration(&spDispProjCfg);
		spProjCfg = spDispProjCfg;
		RETURN_ON_NULL(spProjCfg);
	}
	CComPtr<IDispatch> spDispProj;
	spProjCfg->get_Project(&spDispProj);
	CComQIPtr<VCProject> spProj = spDispProj;
	RETURN_ON_NULL(spProj);
	CComPtr<IDispatch> spDispFileColl;
	spProj->get_Files(&spDispFileColl);
	CComQIPtr<IVCCollection> spFileColl = spDispFileColl;
	RETURN_ON_NULL(spFileColl);
	CComPtr<IEnumVARIANT> spFiles;
	spFileColl->_NewEnum(reinterpret_cast<IUnknown **>(&spFiles));
	RETURN_ON_NULL(spFiles);
	spFiles->Reset();
	while (TRUE)
	{
		CComVariant var;
		hr = spFiles->Next(1, &var, NULL);
		if (hr != S_OK)
			break;
		if (var.vt != VT_UNKNOWN && var.vt != VT_DISPATCH)
			continue;
		CComQIPtr<VCFile> spFile = var.punkVal;
		if (spFile == NULL)
			continue;
		VARIANT_BOOL bDeploy;
		if (spFile->get_DeploymentContent(&bDeploy) == S_OK && bDeploy)
		{
			CComBSTR bstrFullPath, bstrRemPath;
			spFile->get_FullPath(&bstrFullPath);
			CStringW strFullPathLower = bstrFullPath;
			strFullPathLower.MakeLower();
			void* pDummy;
			if (!mapFiles.Lookup(strFullPathLower, pDummy))
			{
				bstrCmdLine += L"\t\t<APPFILENAME>\n\t\t\t<SRC>";
				bstrCmdLine += bstrFullPath;
				bstrCmdLine += L"</SRC>\n\t\t\t<DEST>";
				if (_wcsnicmp(strProjDir, bstrFullPath, nProjDirLen) == 0)
				{
					spFile->get_RemotePath(&bstrRemPath);
					bstrTmp2.Empty();
					spPropContainer->Evaluate(bstrRemPath, &bstrTmp2);
				}
				else
					spFile->get_Name(&bstrTmp2);
				bstrCmdLine += bstrTmp2;
				bstrCmdLine += L"</DEST>\n\t\t</APPFILENAME>\n";
				mapFiles.SetAt(strFullPathLower, pDummy);
			}
		}
	}
	RETURN_ON_FAIL(hr);

	CComBSTR bstrSubDir;
	hr = spPropContainer->GetStrProperty(XBOXDPLYID_RemotePath, &bstrSubDir);
	RETURN_ON_FAIL(hr);
	if (hr == S_FALSE)
		s_optHandler.GetDefaultValue(XBOXDPLYID_RemotePath, &bstrSubDir, spPropContainer);
	CStringW strSubDir = bstrSubDir;
	nLen = strSubDir.GetLength();
	if (nLen > 0)
	{
		if (nLen == 1 && strSubDir[0] == L'.')
		{	// this is a no-op directory...
			strSubDir.Empty();
			nLen = 0;
		}
		if (nLen > 0 && strSubDir[nLen-1] != L'/' && strSubDir[nLen-1] != L'\\')
			strSubDir += L"\\";		// need a trailing slash...
	}
	if (strSubDir.IsEmpty())
		bstrSubDir.Empty();
	else
		bstrSubDir = strSubDir;

	//  add the primary output
	bstrCmdLine += L"\t\t<APPFILENAME";
#if 0
	if (bHaveMappings)
		bstrCmdLine += L" type=\"extension\"";
#endif
	bstrCmdLine += L">\n\t\t\t<SRC>";
	bstrTmp = L"$(TargetPath)";
	bstrTmp2.Empty();
	hr = spPropContainer->Evaluate(bstrTmp, &bstrTmp2);
	RETURN_ON_FAIL(hr);
	bstrCmdLine += bstrTmp2;
	bstrCmdLine += L"</SRC>\n\t\t\t<DEST>";
	if (bstrSubDir)
		bstrCmdLine += bstrSubDir;
	bstrTmp = L"$(TargetFileName)";
	bstrTmp2.Empty();
	hr = spPropContainer->Evaluate(bstrTmp, &bstrTmp2);
	RETURN_ON_FAIL(hr);
	bstrCmdLine += bstrTmp2;
	bstrCmdLine += L"</DEST>\n\t\t</APPFILENAME>\n";
	// if this is a managed C++ project, then we have to copy the PDB file as well
	VARIANT_BOOL bGenDebug = VARIANT_FALSE;
	if (spPropContainer->GetBoolProperty(VCLINKID_GenerateDebugInformation, &bGenDebug) == S_OK &&
		bGenDebug)	// yep, have debug info
	{
		VARIANT_BOOL bManaged = VARIANT_FALSE;
		compileAsManagedOptions managedOption = managedNotSet;
		HRESULT hr1 = spPropContainer->GetBoolProperty(VCCFGID_ManagedExtensions, &bManaged);
		HRESULT hr2 = spPropContainer->GetIntProperty(VCCLID_CompileAsManaged, (long *)&managedOption);
		if ((hr2 == S_OK && managedOption == managedAssembly) || (hr1 == S_OK && bManaged))
		{	// yep, managed
			CComBSTR bstrPDBName;
			if (spPropContainer->GetStrProperty(VCLINKID_ProgramDatabaseFile, &bstrPDBName) == S_FALSE)
				CVCLinkerTool::s_optHandler.GetDefaultValue(VCLINKID_ProgramDatabaseFile, &bstrPDBName, spPropContainer);
			if (bstrPDBName.Length() > 0)
			{
				bstrTmp = bstrPDBName.Detach();
				hr = spPropContainer->Evaluate(bstrTmp, &bstrPDBName);
				RETURN_ON_FAIL(hr);
				CPathW pathPDB;
				if (pathPDB.CreateFromDirAndFilename(dirProj, bstrPDBName))
				{
					bstrPDBName = pathPDB.GetFullPath();
					bstrCmdLine += L"\t\t<APPFILENAME>\n\t\t\t<SRC>";
					bstrCmdLine += bstrPDBName;
					bstrCmdLine += L"</SRC>\n\t\t\t<DEST>";
					if (bstrSubDir)
						bstrCmdLine += bstrSubDir;
					bstrPDBName = pathPDB.GetFileName();
					bstrCmdLine += bstrPDBName;
					bstrCmdLine += L"</DEST>\n\t\t</APPFILENAME>\n";
				}
			}
		}
	}
 
/*	Take out this whole bit on deployment outputs.  This code can be removed later (long after 6/15/01)
	if we decide to keep it this way.
	// add any deployment outputs
	CComQIPtr<IVCConfigurationImpl> spProjCfgImpl = spProjCfg;
	if (spProjCfgImpl)
	{
		CComPtr<IVCBuildStringCollection> spDeployDeps;
		if (SUCCEEDED(spProjCfgImpl->get_KnownDeploymentDependencies(&spDeployDeps)) && spDeployDeps)
		{
			CStringW strKey = L"SOFTWARE\\Microsoft\\.NETFramework";
			CStringW strComDir;
			CStringW strComSDKDir;
			DWORD nType = REG_SZ;
			DWORD nSize = MAX_PATH;
			HKEY hSectionKey = NULL;
			LONG lRet = RegOpenKeyExW( HKEY_LOCAL_MACHINE, strKey, 0, KEY_READ, &hSectionKey );
			if( hSectionKey )
			{
				wchar_t szComplusDir[MAX_PATH+1] = {0};
				wchar_t szComplusSDKDir[MAX_PATH+1] = {0};
				lRet = RegQueryValueExW( hSectionKey, L"InstallRoot", NULL, &nType, (LPBYTE)szComplusDir, &nSize );
				lRet = RegQueryValueExW( hSectionKey, L"sdkInstallRoot", NULL, &nType, (LPBYTE)szComplusSDKDir, &nSize );
				strComDir = szComplusDir;
				strComSDKDir = szComplusSDKDir;
				int nLen1 = strComDir.GetLength();
				int nLen2 = strComSDKDir.GetLength();
				int nLenMin = nLen1 > nLen2 ? nLen2 : nLen1;
				if (nLenMin > 0 && _wcsnicmp(strComDir, strComSDKDir, nLenMin) == 0)
				{	// same root, so need to have to check twice lower down.
					if (nLen1 == nLenMin)
						strComSDKDir.Empty();	// this is the longer one, so toss it
					else
						strComDir.Empty();	// longer one, so toss it
				}
				RegCloseKey( hSectionKey );
			}
			while (TRUE)
			{
				CComBSTR bstrDep;
				hr = spDeployDeps->Next(&bstrDep);
				if (hr != S_OK)
					break;
				if (!bstrDep || bstrDep[0] == '\0')
					continue;
				CPathW pathDep;
				if (!pathDep.Create(bstrDep))
					continue;
				if (!strComDir.IsEmpty() && _wcsnicmp(strComDir, bstrDep, strComDir.GetLength()) == 0)
					continue;	// don't want to deal with COM+ stuff here
				if (!strComSDKDir.IsEmpty() && _wcsnicmp(strComSDKDir, bstrDep, strComSDKDir.GetLength()) == 0)
					continue;	// don't want to deal with COM+ SDK stuff here, either
				bstrCmdLine += L"\t\t<APPFILENAME>\n\t\t\t<SRC>";
				bstrCmdLine += bstrDep;
				bstrDep = pathDep.GetFileName();
				bstrCmdLine += L"</SRC>\n\t\t\t<DEST>";
				if (bstrSubDir)
					bstrCmdLine += bstrSubDir;
				bstrCmdLine += bstrDep;
				bstrCmdLine += L"</DEST>\n\t\t</APPFILENAME>\n";
			}
		}
	}
*/

	// finally, close it all off
	bstrCmdLine += L"\t</APPFILEGROUP>\n</ATLSINSTSETTINGS>\n";

	return pBuildEngine->FormXMLCommand(bstrCmdLine, szXboxDeployToolPath, L"/nologo", pVal);

#else // USE_XML
	HRESULT hr = S_OK;

	CComBSTR bstrCmdLine;
	bstrCmdLine.Append("xbecopy");
	bstrCmdLine.Append(" /NOLOGO");
	bstrCmdLine.Append(" \"");

	{
		CComBSTR bstrSubDir;
		hr = spPropContainer->GetStrProperty(XBOXDPLYID_RemotePath, &bstrSubDir);
		RETURN_ON_FAIL(hr);
		if (hr == S_FALSE)
			s_optHandler.GetDefaultValue(XBOXDPLYID_RemotePath, &bstrSubDir, spPropContainer);
		CComBSTR bstrSubDir2;
		hr = spPropContainer->Evaluate(bstrSubDir, &bstrSubDir2);
		RETURN_ON_FAIL(hr);
		CStringW strSubDir = bstrSubDir2;
		int nLen = strSubDir.GetLength();
		if (nLen > 0)
		{
			if (nLen == 1 && strSubDir[0] == L'.')
			{	// this is a no-op directory...
				strSubDir.Empty();
				nLen = 0;
			}
			if (nLen > 0 && strSubDir[nLen-1] != L'/' && strSubDir[nLen-1] != L'\\')
				strSubDir += L"\\";		// need a trailing slash...
		}
		if (strSubDir.IsEmpty())
			bstrSubDir.Empty();
		else
			bstrSubDir = strSubDir;

		//  add the primary output
		CComBSTR bstrTmp;
		CComBSTR bstrTmp2;
		bstrTmp = L"$(TargetPath)";
		bstrTmp2.Empty();
		hr = spPropContainer->Evaluate(bstrTmp, &bstrTmp2);
		RETURN_ON_FAIL(hr);
		hr = ConvertExeToXbe(bstrTmp2);
		RETURN_ON_FAIL(hr);
		bstrCmdLine += bstrTmp2;
		bstrCmdLine += L"\"";
		
		bstrCmdLine += L" ";
		bstrCmdLine += L"\"";
		if (bstrSubDir)
			bstrCmdLine += bstrSubDir;
		bstrTmp = L"$(TargetFileName)";
		bstrTmp2.Empty();
		hr = spPropContainer->Evaluate(bstrTmp, &bstrTmp2);
		RETURN_ON_FAIL(hr);

		hr = ConvertExeToXbe(bstrTmp2);
		RETURN_ON_FAIL(hr);

		bstrCmdLine += bstrTmp2;
		bstrCmdLine += L"\"";
	}

	CComBSTR bstrFullCommandLine;
	BuildCommandLineBatchFile(pAction, bstrCmdLine, bstrFullCommandLine);

	return pBuildEngine->FormBatchFile(bstrFullCommandLine, pEC, pVal);

#endif // USE_XML

}

// IVCBuildEventToolInternal
///////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CXboxDeploymentTool::get_CommandLineInternal(BSTR *pVal)
{
	HRESULT hr = GetCommandLineOptions(m_spPropertyContainer, NULL, VARIANT_FALSE /* !additional */, cmdLineForRefresh, pVal);
	if(SUCCEEDED(hr))
	{
		if(pVal && SysStringLen(*pVal) == 0)
		{
			// We have only the default options list, so the build system thinks we have nothing to do.
			SysFreeString(*pVal);
			CComBSTR dummy;
			dummy.Append(" ");
			*pVal = dummy.Detach();
		}
	}
	return hr;
}

STDMETHODIMP CXboxDeploymentTool::put_CommandLineInternal(BSTR newVal)
{
	return E_NOTIMPL;
}

STDMETHODIMP CXboxDeploymentTool::get_DescriptionInternal(BSTR *pVal)
{
	return E_NOTIMPL;
}

STDMETHODIMP CXboxDeploymentTool::put_DescriptionInternal(BSTR newVal)
{
	return E_NOTIMPL;
}

STDMETHODIMP CXboxDeploymentTool::get_ExcludedFromBuildInternal(VARIANT_BOOL* pbExcludedFromBuild)
{
	return get_ExcludedFromBuild(pbExcludedFromBuild);
}

STDMETHODIMP CXboxDeploymentTool::put_ExcludedFromBuildInternal(VARIANT_BOOL bExcludedFromBuild)
{
	return E_NOTIMPL;
}

// CXboxDeploymentGeneralPage
///////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CXboxDeploymentGeneralPage::MapPropertyToCategory(DISPID dispid, PROPCAT* ppropcat)
{
	CHECK_POINTER_NULL(ppropcat);

	switch (dispid)
	{
	case XBOXDPLYID_ExcludedFromBuild:
	case XBOXDPLYID_AdditionalFiles:
	case XBOXDPLYID_RemotePath:
		*ppropcat = IDS_GENERALCAT;
		break;
	default:
		*ppropcat = 0;
		break;
	}

	return S_OK;
}

STDMETHODIMP CXboxDeploymentGeneralPage::GetCategoryName(PROPCAT propcat, LCID lcid, BSTR* pbstrName)
{
	CComBSTR bstrCat;
	bstrCat.LoadString(propcat);
	*pbstrName = bstrCat.Detach();
	return S_OK;
}

// file copy
STDMETHODIMP CXboxDeploymentGeneralPage::get_AdditionalFiles(BSTR* files)
{	// additional files to deploy
	return GetStrProperty(XBOXDPLYID_AdditionalFiles, files);
}

STDMETHODIMP CXboxDeploymentGeneralPage::put_AdditionalFiles(BSTR files)
{
	return SetStrProperty(XBOXDPLYID_AdditionalFiles, files);
}

STDMETHODIMP CXboxDeploymentGeneralPage::get_RemotePath(BSTR* dir)
{	// relative path to deploy to
	return ToolGetStrProperty(XBOXDPLYID_RemotePath, &(CXboxDeploymentTool::s_optHandler), dir);
}

STDMETHODIMP CXboxDeploymentGeneralPage::put_RemotePath(BSTR dir)
{
	return SetStrProperty(XBOXDPLYID_RemotePath, dir);
}

// general 
STDMETHODIMP CXboxDeploymentGeneralPage::get_ExcludedFromBuild(VARIANT_BOOL* disableDeploy)
{	// exclude from build? default: no
	return ToolGetBoolProperty(XBOXDPLYID_ExcludedFromBuild, &(CXboxDeploymentTool::s_optHandler), disableDeploy);
}

STDMETHODIMP CXboxDeploymentGeneralPage::put_ExcludedFromBuild(VARIANT_BOOL disableDeploy)
{
	return SetBoolProperty(XBOXDPLYID_ExcludedFromBuild, disableDeploy);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\vcpb\XboxDeployTool.h ===
// XboxDeployTool.h: Definition of the CXboxDeploymentTool class
//
//////////////////////////////////////////////////////////////////////

#pragma once

#include "vctool.h"
#include "settingspage.h"

// classes in this header
class CXboxDeploymentTool;
class CXboxDeployToolOptionHandler;
class CXboxDeploymentGeneralPage;

class CXboxDeployToolOptionHandler : public COptionHandlerBase
{
public:
	DECLARE_OPTION_TABLE()

public:
	// default value handlers
	// string props
	virtual void GetDefaultValue( long id, BSTR *pVal, IVCPropertyContainer *pPropCnt = NULL );
	// integer props
	virtual void GetDefaultValue( long id, long *pVal, IVCPropertyContainer *pPropCnt = NULL );
	// boolean props
	virtual void GetDefaultValue( long id, VARIANT_BOOL *pVal, IVCPropertyContainer *pPropCnt = NULL );
};

/////////////////////////////////////////////////////////////////////////////
// CXboxDeploymentTool

class ATL_NO_VTABLE CXboxDeploymentTool : 
	public IDispatchImpl<XboxDeploymentTool, &IID_XboxDeploymentTool, &LIBID_VCProjectEngineLibrary, PublicProjBuildTypeLibNumber,0, CVsTypeInfoHolder>, 
	public IVCBuildEventToolInternal,
	public CComObjectRoot,
	public CVCToolImpl
{
public:
	CXboxDeploymentTool() 
	{
		m_nLowKey = XBOXVCDPLYTOOL_MIN_DISPID;
		m_nHighKey = XBOXVCDPLYTOOL_MAX_DISPID;
		m_nDirtyKey = XBOXDPLYID_CmdLineOptionsDirty;
	}
	static HRESULT CreateInstance(IVCPropertyContainer* pPropContainer, IVCToolImpl** ppTool);

BEGIN_COM_MAP(CXboxDeploymentTool)
	COM_INTERFACE_ENTRY(IVCToolImpl)
 	COM_INTERFACE_ENTRY(XboxDeploymentTool)
	COM_INTERFACE_ENTRY(IVCBuildEventToolInternal)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE(CXboxDeploymentTool) 

// XboxDeploymentTool
public:
	// general
	STDMETHOD(get_ExcludedFromBuild)(VARIANT_BOOL* disableDeploy);	// exclude from build? default: yes
	STDMETHOD(put_ExcludedFromBuild)(VARIANT_BOOL disableDeploy);
	STDMETHOD(get_RemotePath)(BSTR* dir);	// remote path to deploy to
	STDMETHOD(put_RemotePath)(BSTR dir);
	STDMETHOD(get_AdditionalFiles)(BSTR* files);	// additional files to deploy
	STDMETHOD(put_AdditionalFiles)(BSTR files);

 	STDMETHOD(get_ToolName)(BSTR* pbstrToolName);	// friendly name of tool, e.g., "C/C++ Compiler Tool"
	STDMETHOD(get_VCProjectEngine)(IDispatch** projEngine)	{ return DoGetVCProjectEngine(projEngine); }

	// Automation properties
	STDMETHOD(get_ToolPath)(BSTR *pVal);
	STDMETHOD(get_PropertyOption)(BSTR bstrProp, long dispidProp, BSTR *pVal);

// IVCBuildEventToolInternal
public:
	STDMETHOD(get_CommandLineInternal)(BSTR *pVal);
	STDMETHOD(put_CommandLineInternal)(BSTR newVal);
	STDMETHOD(get_DescriptionInternal)(BSTR *pVal);
	STDMETHOD(put_DescriptionInternal)(BSTR newVal);
	STDMETHOD(get_ExcludedFromBuildInternal)(VARIANT_BOOL* pbExcludedFromBuild);
	STDMETHOD(put_ExcludedFromBuildInternal)(VARIANT_BOOL bExcludedFromBuild);

// IVCToolImpl
public:
	STDMETHOD(get_DefaultExtensions)(BSTR* pVal);
	STDMETHOD(put_DefaultExtensions)(BSTR newVal);
	STDMETHOD(GetAdditionalOptionsInternal)(IUnknown* pItem, VARIANT_BOOL bForBuild, VARIANT_BOOL bSkipLocal, BSTR* pbstrAdditionalOptions);
	STDMETHOD(GetBuildDescription)(IVCBuildAction* pAction, BSTR* pbstrBuildDescription);
	STDMETHOD(get_ToolPathInternal)(BSTR* pbstrToolPath);
	STDMETHOD(get_Bucket)(long *pVal);
	STDMETHOD(CreateToolObject)(IVCPropertyContainer* pPropContainer, IVCToolImpl** ppToolObject);
	STDMETHOD(GetAdditionalIncludeDirectoriesInternal)(IVCPropertyContainer* pPropContainer, BSTR* pbstrIncDirs);
	STDMETHOD(get_ToolShortName)(BSTR* pbstrToolName);
	STDMETHOD(get_ToolNameInternal)(BSTR* pbstrToolName) { return get_ToolName(pbstrToolName); }
	STDMETHOD(MatchName)(BSTR bstrName, VARIANT_BOOL bFullOnly, VARIANT_BOOL* pbMatches);
	STDMETHOD(CreatePageObject)(IUnknown **, CLSID*, IVCPropertyContainer *, IVCSettingsPage * );
	STDMETHOD(IsTargetTool)(IVCBuildAction* pAction, VARIANT_BOOL* pbTargetTool); // tool always operates on target, not on file
	STDMETHOD(get_IsFileTool)(VARIANT_BOOL* pbIsFileTool);
	STDMETHOD(GetCommandLineEx)(IVCBuildAction* pAction, IVCBuildableItem* pBuildableItem, IVCBuildEngine* pBuildEngine, 
		IVCBuildErrorContext* pEC, BSTR *pVal);

	STDMETHOD(get_ToolDisplayIndex)(long* pIndex)
	{
		CHECK_POINTER_NULL(pIndex);
		*pIndex = TOOL_DISPLAY_INDEX_XBOXDEPLOY;
		return S_OK;
	}

	virtual long GetPageCount()	{ return 1; }
	virtual GUID* GetPageIDs();

// helpers
public:
	virtual COptionHandlerBase* GetOptionHandler() { return &s_optHandler; }
	virtual LPCOLESTR GetToolFriendlyName();
	void InitToolName();
	virtual long GetToolID() { return IDS_DEPLOYTOOL; }

protected:
	HRESULT DoGetToolPath(BSTR* pbstrToolPath, IVCPropertyContainer* pPropContainer);

public:
	static CXboxDeployToolOptionHandler s_optHandler;

protected:
	static GUID s_pPages[1];
	static BOOL s_bPagesInit;
	static CComBSTR s_bstrBuildDescription;
	static CComBSTR s_bstrToolName;
	static CComBSTR s_bstrExtensions;
};

class ATL_NO_VTABLE CXboxDeploymentGeneralPage :
	public IDispatchImpl<IXboxDeploymentGeneralPage, &IID_IXboxDeploymentGeneralPage, &LIBID_VCProjectEnginePrivateLibrary, PrivateProjBuildTypeLibNumber,0, CVsTypeInfoHolder>,
	public ICategorizeProperties,
	public CPageObjectImpl<CXboxDeploymentGeneralPage,XBOXVCDPLYTOOL_MIN_DISPID,XBOXVCDPLYTOOL_MAX_DISPID>,
	public CComObjectRoot
{
public:

BEGIN_COM_MAP(CXboxDeploymentGeneralPage)
	COM_INTERFACE_ENTRY(IPerPropertyBrowsing)
	COM_INTERFACE_ENTRY(IVsPerPropertyBrowsing)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IVCPropertyContainer)
	COM_INTERFACE_ENTRY(IXboxDeploymentGeneralPage)
	COM_INTERFACE_ENTRY(IProvidePropertyBuilder)
	COM_INTERFACE_ENTRY_IID(IID_ICategorizeProperties, ICategorizeProperties)
END_COM_MAP()

	// IDispatch override
	STDMETHOD(Invoke)( DISPID dispid, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS *pdispParams, VARIANT *pvarResult, EXCEPINFO *pexcepInfo, UINT *puArgErr )
	{
		IDispatchImpl<IXboxDeploymentGeneralPage, &IID_IXboxDeploymentGeneralPage, &LIBID_VCProjectEnginePrivateLibrary, PrivateProjBuildTypeLibNumber,0, CVsTypeInfoHolder>::Invoke( dispid, riid, lcid, wFlags, pdispParams, pvarResult, pexcepInfo, puArgErr );
		return S_OK;
	}


// ICategorizeProperties
public:
	STDMETHOD(MapPropertyToCategory)(DISPID dispid, PROPCAT* ppropcat);
	STDMETHOD(GetCategoryName)(PROPCAT propcat, LCID lcid, BSTR* pbstrName);

// IXboxDeploymentGeneralPage
public:
	// general 
	STDMETHOD(get_ExcludedFromBuild)(VARIANT_BOOL* disableDeploy);	// exclude from build? default: yes
	STDMETHOD(put_ExcludedFromBuild)(VARIANT_BOOL disableDeploy);
	STDMETHOD(get_RemotePath)(BSTR* dir);	// remote path to deploy to
	STDMETHOD(put_RemotePath)(BSTR dir);
	STDMETHOD(get_AdditionalFiles)(BSTR* files);	// additional files to deploy
	STDMETHOD(put_AdditionalFiles)(BSTR files);

// helpers
public:
	virtual BOOL UseMultiLineNoInheritDialog(long id) { return (id == XBOXDPLYID_AdditionalFiles); }
};

#define DeployProtectMax 2
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\vcpb\vctool.h ===
#pragma once

#include "ProjectOptions.h"
#include <vccoll.h>
#include <path2.h>
#include "FileRegistry.h"

#ifdef _SHIP
#define FORCE_DIRTY() ;
#else
#define FORCE_DIRTY() \
	{ \
		HRESULT hr = ForceDirty(); \
		if (hr != S_OK) \
			return hr; \
	}
#endif


class CVCToolImpl : 
	public IVCToolImpl
{
public:
	CVCToolImpl() 
	{
		m_nLowKey = -1;
		m_nHighKey = -1;
		m_nDirtyKey = -1;
		m_nDirtyOutputsKey = -1;
	}
	virtual ~CVCToolImpl() {}

protected:
	virtual void Initialize(IVCPropertyContainer* pPropContainer) 
	{
		m_spPropertyContainer = pPropContainer;
	}

// IVCToolImpl
public:
	STDMETHOD(get_DefaultExtensions)(BSTR *pVal)
	{ VSASSERT(FALSE, "get_DefaultExtensions must be overridden");	return VCPROJ_E_INTERNAL_ERR; }	// required override
	STDMETHOD(put_DefaultExtensions)(BSTR newVal)
	{ VSASSERT(FALSE, "put_DefaultExtensions must be overridden");	return VCPROJ_E_INTERNAL_ERR; }	// required override
	STDMETHOD(GetAdditionalOptionsInternal)(IUnknown* pItem, VARIANT_BOOL bForBuild, VARIANT_BOOL bSkipLocal, BSTR* pbstrOptions)
	{ VSASSERT(FALSE, "GetAdditionalOptionsInternal must be overridden");	return VCPROJ_E_INTERNAL_ERR; }	// required override
	STDMETHOD(GetBuildDescription)(IVCBuildAction* pAction, BSTR* pbstrBuildDescription)
	{ VSASSERT(FALSE, "GetBuildDescription must be overridden");	return VCPROJ_E_INTERNAL_ERR; }	// required override
	STDMETHOD(get_ToolPathInternal)(BSTR* pbstrToolPath)	// repeat of ToolPath from tools so as to make command line building easier
	{ VSASSERT(FALSE, "get_ToolPathInternal must be overridden");	return VCPROJ_E_INTERNAL_ERR; }	// required override
	STDMETHOD(get_Bucket)(long *pVal)
	{ VSASSERT(FALSE, "get_Bucket must be overridden");	return VCPROJ_E_INTERNAL_ERR; }	// required override
	STDMETHOD(get_ToolNameInternal)(BSTR* pbstrToolName)
	{ VSASSERT(FALSE, "get_ToolNameInternal must be overridden by file tools"); return VCPROJ_E_INTERNAL_ERR; }	// required override for file tools
	STDMETHOD(CreateToolObject)(IVCPropertyContainer* pPropContainer, IVCToolImpl** ppToolObject)
	{ VSASSERT(FALSE, "CreateToolObject must be overridden");	return VCPROJ_E_INTERNAL_ERR; }	// required override
	STDMETHOD(get_ToolDisplayIndex)(long* index)
	{ VSASSERT( false, "get_ToolDisplayIndex must be overridden" ); return VCPROJ_E_INTERNAL_ERR; }	// required override
	
	STDMETHOD(GetAdditionalIncludeDirectoriesInternal)(IVCPropertyContainer* pPropContainer, BSTR* pbstrIncPaths);
	STDMETHOD(get_IncludePathID)(long* pnIncludeID);
	STDMETHOD(GetCommandLineEx)(IVCBuildAction*, IVCBuildableItem* pBuildableItem, IVCBuildEngine* pBuildEngine, IVCBuildErrorContext* pEC, BSTR* bstrCmd);
	STDMETHOD(GetCommandLineOptions)(IUnknown* pItem, IVCBuildAction* pAction, VARIANT_BOOL bIncludeAdditional, commandLineOptionStyle fStyle, BSTR* pVal);
	STDMETHOD(GetCommandLineOptionsForDisplay)(IUnknown* pItem, VARIANT_BOOL bIncludeAdditional, BSTR* pVal);
	STDMETHOD(GetPages)(CAUUID* pPages);
	STDMETHOD(IsTargetTool)(IVCBuildAction* pAction, VARIANT_BOOL* pbTargetTool); // tool operates on target, not on file
	STDMETHOD(get_PerformIfAble)(VARIANT_BOOL* pbPerformIfAble); // tool can run, even given previous errors
	STDMETHOD(get_IsComspecTool)(VARIANT_BOOL* pbIsComspecTool); // tool requires comspec
	STDMETHOD(get_IsCustomBuildTool)(VARIANT_BOOL* pbIsCustomTool);	// tool counts as custom
	STDMETHOD(PrePerformBuildActions)(bldActionTypes type, IVCBuildActionList* pActions, bldAttributes aob, IVCBuildErrorContext* pEC, actReturnStatus* pActReturn);
	STDMETHOD(PostPerformBuildActions)(bldActionTypes type, IVCBuildActionList* pActions, bldAttributes aob, IVCBuildErrorContext* pEC, actReturnStatus* pActReturn);
	STDMETHOD(IsDeleteOnRebuildFile)(LPCOLESTR szFile, VARIANT_BOOL* pbDelOnRebuild);
	STDMETHOD(GetCommandLinesForBuild)(IVCBuildActionList* pActions, bldAttributes attrib, IVCBuildEngine* pBldEngine, IVCBuildErrorContext* pErrorContext, IVCCommandLineList** ppCmds);
	STDMETHOD(GenerateOutput)(long type, IVCBuildActionList* pActions, IVCBuildErrorContext* pEC);
	STDMETHOD(AffectsOutput)(long nPropID, VARIANT_BOOL* pbAffectsOutput);
	STDMETHOD(GetPropertyOptionInternal)(IUnknown* pItem, BSTR bstrProp, long dispidProp, BSTR *pVal);
	STDMETHOD(SaveObject)(IStream *xml, IVCPropertyContainer *pPropCnt, long nIndent);
	STDMETHOD(WriteToStream)(IStream *pStream, IVCPropertyContainer* pPropContainer) { return S_FALSE; }		// nothing written
	STDMETHOD(ReadFromStream)(IStream *pStream, IVCPropertyContainer* pPropContainer) { return S_FALSE; }		// nothing written
	STDMETHOD(HasPrimaryOutputFromTool)(IUnknown* pItem, VARIANT_BOOL bSchmoozeOnly, VARIANT_BOOL* pbHasPrimaryOutput);	// returns TRUE only if tool generates a primary output (ex: linker)
	STDMETHOD(GetPrimaryOutputFromTool)(IUnknown* pItem, VARIANT_BOOL bSchmoozeOnly, BSTR* pbstrPath);	// return a value only if tool generates a primary output (ex: linker)
	STDMETHOD(GetPrimaryOutputIDFromTool)(IUnknown* pItem, VARIANT_BOOL bSchmoozeOnly, long* pnOutputID);	// return a value only if tool generates a primary output (ex: linker)
	STDMETHOD(GetImportLibraryFromTool)(IUnknown* pItem, BSTR* pbstrPath);	// return a value only if the tool generates an import library
	STDMETHOD(SetPrimaryOutputForTool)(IUnknown* pItem, BSTR bstrFile);		// sets the primary output for a tool
	STDMETHOD(GetDefaultOutputFileFormat)(IUnknown* pItem, BSTR* pbstrOutMacro);	// macro to use for generating default output file if the original default isn't unique
	STDMETHOD(GetProgramDatabaseFromTool)(IVCPropertyContainer* pContainer, VARIANT_BOOL bSchmoozeOnly, BSTR* pbstrPDB);
	STDMETHOD(get_IsFileTool)(VARIANT_BOOL* pbIsFileTool);
	STDMETHOD(Close)() { m_spPropertyContainer.Release(); return S_OK; }
	STDMETHOD(HasDependencies)(IVCBuildAction* pAction, VARIANT_BOOL* pbHasDependencies);
	STDMETHOD(GetDependencies)(IVCBuildAction* pAction, IVCBuildStringCollection** ppStrings, VARIANT_BOOL* bUpToDate);
	STDMETHOD(CanScanForDependencies)(VARIANT_BOOL* pbIsScannable);
	STDMETHOD(GetCleanCommandLineEx)( IVCBuildAction *pAction, IVCBuildableItem* pBuildableItem, IVCBuildEngine* pBuildEngine, IVCBuildErrorContext* pEC, BSTR* bstrCmd );
	STDMETHOD(GetCommandLinesForClean)( IVCBuildActionList* pActions, bldAttributes attrib, IVCBuildEngine* pBldEngine, IVCBuildErrorContext* pErrorContext, IVCCommandLineList** ppCmds );
	STDMETHOD(GetRebuildCommandLineEx)( IVCBuildAction *pAction, IVCBuildableItem* pBuildableItem, IVCBuildEngine* pBuildEngine, IVCBuildErrorContext* pEC, BSTR* bstrCmd );
	STDMETHOD(GetCommandLinesForRebuild)(IVCBuildActionList* pActions, bldAttributes attrib, IVCBuildEngine* pBldEngine, IVCBuildErrorContext* pErrorContext, IVCCommandLineList** ppCmds);
	STDMETHOD(IsSpecialConsumable)(LPCOLESTR szPath, VARIANT_BOOL* pbSpecial);
	STDMETHOD(DirtyCommandLineOptions)(long nLowPropID, long nHighPropID, VARIANT_BOOL bDirty);
	STDMETHOD(AffectsTool)(long nLowPropID, long nHighPropID, VARIANT_BOOL* pbAffects);
	STDMETHOD(CommandLineOptionsAreDirty)(IVCPropertyContainer* pPropContainer, VARIANT_BOOL* pbIsDirty);
	STDMETHOD(OutputsAreDirty)(IVCPropertyContainer* pPropContainer, VARIANT_BOOL* pbIsDirty);
	STDMETHOD(ClearDirtyOutputs)(IVCPropertyContainer* pPropContainer);
	STDMETHOD(IsMultiProp)(long idProp, VARIANT_BOOL* pbIsMulti);
	STDMETHOD(GetMultiPropSeparator)(long id, BSTR* pbstrPreferred, BSTR* pbstrAll);
	STDMETHOD(HasVirtualLocalStorage)(IVCPropertyContainer* pPropContainer, VARIANT_BOOL* pbHasVirtualLocalStorage);
	STDMETHOD(CreatePageObject)(IUnknown **, CLSID*, IVCPropertyContainer *, IVCSettingsPage * ) {return E_NOTIMPL;};
	STDMETHOD(GenerateDependencies)(IVCBuildAction* pAction, void* frhFile, IVCBuildErrorContext* pErrorContext);
	STDMETHOD(ScanDependencies)(IVCBuildAction* pAction, IVCBuildErrorContext* pEC, VARIANT_BOOL bWriteOutput);
	STDMETHOD(InformUserAboutBadFileName)(IVCBuildErrorContext* pEC, IVCPropertyContainer* pPropContainer, long nErrPropID, 
		LPCOLESTR szFile);
	STDMETHOD(get_FullIncludePathInternal)(BSTR* pbstrFullIncludePath);
	STDMETHOD(GetDeploymentDependencies)(IVCBuildAction* pAction, IVCBuildStringCollection** ppDeployDepStrings);
	STDMETHOD(GetDeployableOutputsCount)(IVCPropertyContainer* pPropContainer, long* pnOutputs);	// number of deployable outputs
	STDMETHOD(GetDeployableOutputs)(IVCPropertyContainer* pPropContainer, IVCBuildStringCollection** ppDeployableOutputs);	// the deployable outputs

// helpers
public:	
	virtual COptionHandlerBase* GetOptionHandler() { return NULL; }
	virtual HRESULT GetPrimaryOutputFromTool(IUnknown* pItem, VARIANT_BOOL bSchmoozeOnly, CPathW& rPath);	// return a value only if tool generates a primary output (ex: linker)

	virtual long GetPageCount() { return 0; }
	virtual GUID* GetPageIDs() { return (GUID*)NULL; }
	virtual BOOL HaveCommandLine(IVCBuildAction* pAction) { return TRUE; }
	virtual BOOL UsesResponseFiles() { return FALSE; }
	virtual void SaveSpecialProps(IStream *xml, IVCPropertyContainer *pPropCnt) { return; }

	HRESULT ToolGetStrProperty(long idProp, BSTR* pVal, bool bLocalOnly = false);
	HRESULT ToolGetIntProperty(long idProp, long* pVal);
	HRESULT ToolGetBoolProperty(long idProp, VARIANT_BOOL* pVal);

	void GetEnumVal(IUnknown *pUnk, SOptionEntry *pEntry, CComVariant &var, IDispatch *pDispTool);
	BOOL FileNameMatchesExtension(const CPathW *pPath, const wchar_t *pExtensions);
	
	static BOOL ResolveIncludeDirectivesToPath(const CPathW& pathSrc, IVCBuildAction* pAction, const CVCStringWList& strlstIncs, CVCStringWList& lstPath, BOOL fIsInclude = TRUE);
	static void ConvertPathToBSTR(CPathW& path, CComBSTR& rbstrPath);
	static void CreateDirFromBSTR(BSTR bstrPath, CDirW& rdir);
	static BOOL CreatePathRelativeToProject(IVCPropertyContainer* pPropContainer, CStringW& strName, CPathW& pathName);
	static BOOL ConfigBuildProp(long idProp);

protected:
	static BOOL GetIncludePathI(IVCBuildAction* pAction, CStringW& strIncDirs, const CPathW* ppathSrc, CStringW& strPlatDirs, BOOL fIsInclude);
	static BOOL ResolveIncludeDirectivesI(IVCBuildAction* pAction, CStringW& strlstIncDirs, const CDirW& dirBase, const CVCStringWList& strlstIncs, CVCStringWList& lstPath, const CPathW *pathSrc, CStringW& strPlatDirs, BOOL fIsInclude);

	virtual HRESULT GetCommandLineOptions(IUnknown* pItem, IVCBuildAction* pAction, VARIANT_BOOL bIncludeAdditional, VARIANT_BOOL bForDisplay, commandLineOptionStyle fStyle, CStringW& rstrCmdLine);
	HRESULT DoGetPropertyOption(BSTR bstrProp, long dispidProp, BSTR *pVal) { return E_NOTIMPL; }	// DIANEME_TODO: CVCToolImpl::DoGetPropertyOption
	BOOL IsExcludedFromBuild(IVCPropertyContainer* pPropContainer);
	HRESULT GetProcessedAdditionalOptions(IUnknown* pItem, long idProp, VARIANT_BOOL bForSave, VARIANT_BOOL bSkipLocal, BSTR* pbstrAdditionalOptions);
	HRESULT DoMatchName(BSTR bstrName, const wchar_t* szToolType, const wchar_t* szShortName, VARIANT_BOOL* pbMatches);
	HRESULT DoGetDefaultExtensions(CComBSTR& bstrSetExtensions, const wchar_t* const wszBaseDefaultExtensions, BSTR* pbstrVal);
	void BuildCommandLineBatchFile(IVCBuildAction* pAction, CComBSTR& bstrCommandLineEnd, CComBSTR& bstrCmdLine);
	HRESULT DoGetVCProjectEngine(IDispatch** projEngine);
	virtual BOOL IsExtraMultiProp(long idProp) { return FALSE; }	// only override this if you have a multi-prop not in an option table
	virtual HRESULT GetAdditionalDependenciesInternal(IVCPropertyContainer* pItem, IVCBuildAction* pAction, BOOL bForSave, BSTR* pbstrInputs);		// additional things to add to command line

	virtual LPCOLESTR GetToolFriendlyName() PURE;
	virtual long GetToolID() PURE;
#ifndef _SHIP
	HRESULT ForceDirty();
#endif	// _SHIP

protected:
	CComPtr<IVCPropertyContainer> m_spPropertyContainer;
	long m_nLowKey;
	long m_nHighKey;
	long m_nDirtyKey;
	long m_nDirtyOutputsKey;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\vcpb\XMLFile.cpp ===
// XMLFile.cpp : Implementation of CXMLFile

#include "stdafx.h"
#include "XMLFile.h"
#include "VCProjectEngine.h"
#include "util2.h"

/////////////////////////////////////////////////////////////////////////////
// CCXMLFile

int CXMLFile::DetermineDefaultCodePage()
{
	int cChars = GetLocaleInfo(LOCALE_SYSTEM_DEFAULT, LOCALE_IDEFAULTANSICODEPAGE, NULL, 0);
	CStringW strBuf;
	wchar_t *szInfo = strBuf.GetBuffer(cChars+1);
	GetLocaleInfoW(LOCALE_SYSTEM_DEFAULT, LOCALE_IDEFAULTANSICODEPAGE, szInfo, cChars);
	int iCodePage = _wtoi(szInfo);
	if (!iCodePage)
		iCodePage = CP_ACP;
	strBuf.ReleaseBuffer();

	return iCodePage;
}

void CXMLFile::DetermineDefaultFileEncoding(CComBSTR& bstrEncoding)
{
	CVCProjectEngine::GetCodePageName(DetermineDefaultCodePage(), bstrEncoding);
}

void CXMLFile::AdjustFileFormatForFileEncoding(LPCOLESTR szOldEncoding, LPCOLESTR szNewEncoding, enumFileFormat& eFormat, 
	BOOL bForce /* = FALSE */)
{
	if (!bForce)
	{
		if (!szOldEncoding && !szNewEncoding)
			return;		// they're NULL, but the same
		else if (szOldEncoding && szNewEncoding && wcscmp(szOldEncoding, szNewEncoding) == 0)
			return;		// nothing really changed
	}


	CStringW strEncoding = szNewEncoding;
	if (strEncoding.GetLength() < 5)
	{
		eFormat = eANSI;
		return;
	}

	strEncoding.MakeLower();
	if (wcsncmp(strEncoding, L"utf-8", 5) == 0)
		eFormat = eUTF8;
	else if (wcsncmp(strEncoding, L"utf-", 4) == 0)
		eFormat = eUnicode;
	else
		eFormat = eANSI;
}

void CXMLFile::AdjustFileEncodingForFileFormat(enumFileFormat eOldFormat, enumFileFormat eNewFormat, CComBSTR& bstrEncoding,
	BOOL bForce /* = FALSE */)
{
	if (!bForce && eOldFormat == eNewFormat)
		return;		// nothing more to do

	switch (eNewFormat)
	{
	case eUTF8:
		bstrEncoding = L"UTF-8";
		break;
	case eUnicode:
		bstrEncoding = L"UTF-16";
		break;
	default:	// eANSI
		if (!bForce || bstrEncoding.Length() == 0)
			DetermineDefaultFileEncoding(bstrEncoding);
		break;
	}
}


HRESULT CXMLFile::CreateInstance( IVCXMLFile **ppXMLFile, LPCOLESTR szFilename, DWORD dwBufSize, LPCOLESTR szFileEncoding,
	enumFileFormat eFileFormat)
{
	HRESULT hr;
	CXMLFile *pVar;
	CComObject<CXMLFile> *pObj;
	hr = CComObject<CXMLFile>::CreateInstance(&pObj);
	if( SUCCEEDED( hr ) )
	{
		pVar = pObj;
		pVar->AddRef();
		*ppXMLFile = pVar;
		CComBSTR bstrFileEncoding;
		if (szFileEncoding)
			bstrFileEncoding = szFileEncoding;
		else
			AdjustFileEncodingForFileFormat(eFileFormat, eFileFormat, bstrFileEncoding, TRUE);
		hr = pVar->Initialize( szFilename, dwBufSize, szFileEncoding );
	}
	return hr;
}

CXMLFile::CXMLFile() : 
	m_file( NULL ), 
	m_bstrFilename( NULL ), 
	m_dwBufSize( 0 ), 
	m_pBuf( NULL ),
	m_dwBytesInBuffer( 0 ),
	m_dwOffset( 0 )
{
}

CXMLFile::~CXMLFile()
{
	if (m_pBuf)
	{
		delete [] m_pBuf;
		m_pBuf = NULL;
	}
	if (m_file)
	{
		fclose(m_file);
		m_file = NULL;
	}
}

STDMETHODIMP CXMLFile::Initialize( LPCOLESTR szFilename, DWORD dwBufSize, LPCOLESTR szFileEncoding )
{
	m_bstrFilename = szFilename;

	m_file = fopenW( m_bstrFilename, L"wb" );
	if( !m_file )
	{
		// TODO: determine why the file wasn't opened so we can generate a
		// somewhat meaningful error message
		return E_ACCESSDENIED;
	}
	// set the buffer size
	m_dwBufSize = dwBufSize;
	// allocate the buffer
	m_pBuf = new char[m_dwBufSize];
	VSASSERT( m_pBuf, "Failed to allocate stream buffer" );
	RETURN_ON_NULL2(m_pBuf, E_OUTOFMEMORY);

	// file format to write 
	m_bstrFileEncoding = szFileEncoding;

	return S_OK;
}

STDMETHODIMP CXMLFile::Read(
	void *pv,
	ULONG cb,
	ULONG *pcbRead)
{
	// validate cb
	if( (m_dwOffset + cb) > m_dwBytesInBuffer )
		return STG_E_INVALIDPOINTER;
	// copy data
	memcpy( pv, (void*)(m_pBuf + m_dwOffset), cb );
	*pcbRead = cb;

	return S_OK;
}

STDMETHODIMP CXMLFile::Write(
	void const *pv,
	ULONG cb,
	ULONG *pcbWritten)
{
	// append into the buffer, expanding it if necessary
	if( (m_dwBytesInBuffer + cb) > m_dwBufSize )
	{
		char *newBuf = new char[m_dwBufSize * 2];
		memcpy( (void*)newBuf, (void*)m_pBuf, m_dwBytesInBuffer );
		delete[] m_pBuf;
		m_pBuf = newBuf;
		m_dwBufSize *= 2;
	}
	memcpy( (void*)(m_pBuf + m_dwOffset), pv, cb );
	*pcbWritten = cb;

	// adjust m_dwOffset, m_dwBytesInBuffer
	m_dwOffset += cb;
	m_dwBytesInBuffer += cb;
	
	return S_OK;
}

STDMETHODIMP CXMLFile::Seek(
	LARGE_INTEGER dlibMove,
	DWORD dwOrigin,
	ULARGE_INTEGER *plibNewPosition)
{
	// NOTE:
	// this method only uses the low 32 bits of the offset given!!!

	// validate, set m_dwOffset
	DWORD newOffset;
	switch( dwOrigin )
	{
	case STREAM_SEEK_SET:
		newOffset = dlibMove.LowPart;
		break;
	case STREAM_SEEK_CUR:
		newOffset = m_dwOffset + dlibMove.LowPart;
		break;
	case STREAM_SEEK_END:
		newOffset = m_dwBytesInBuffer + dlibMove.LowPart;
		break;
	default:
		return STG_E_INVALIDFUNCTION;
	}

	// if the offset is greater than the end of the stream, bail
	if( newOffset > m_dwBytesInBuffer )
		return STG_E_INVALIDPOINTER;
	// if the offset is less than 0, bail
	else if( newOffset < 0 )
		return STG_E_INVALIDPOINTER;
	else
		m_dwOffset = newOffset + dlibMove.LowPart;

	// write plibNewPosition, if it's not NULL
	if( plibNewPosition )
	{
		plibNewPosition->LowPart = m_dwOffset;
		plibNewPosition->HighPart = 0;
	}

	return S_OK;
}

STDMETHODIMP CXMLFile::SetSize(
	ULARGE_INTEGER libNewSize)
{
	// NOTE:
	// this method only uses the low 32 bits of the offset given!!!
	
	// validate (new size not less than existing data)
	if( libNewSize.LowPart < m_dwBytesInBuffer )
		return STG_E_INVALIDPOINTER;
	// allocate new buffer
	char *newBuf = new char[libNewSize.LowPart];
	// copy old buffer into new buffer
	memcpy( (void*)newBuf, (void*)m_pBuf, m_dwBytesInBuffer );
	// free old buffer
	delete[] m_pBuf;
	// set buffer pointer to new buffer
	m_pBuf = newBuf;
	// set buf size
	m_dwBufSize = libNewSize.LowPart;

	return S_OK;
}

STDMETHODIMP CXMLFile::CopyTo(
	IStream *pstm,
	ULARGE_INTEGER cb,
	ULARGE_INTEGER *pcbRead,
	ULARGE_INTEGER *pcbWritten)
{
	return E_NOTIMPL;
}

STDMETHODIMP CXMLFile::Commit(DWORD grfCommitFlags)
{
	RETURN_ON_NULL2(m_file, S_FALSE);		// nothing to do in this case...

	char* buffer;
	unsigned int buf_size = 0;
	// write the correct format
	enumFileFormat eFileFormat;
	AdjustFileFormatForFileEncoding(NULL, m_bstrFileEncoding, eFileFormat, TRUE);

	HRESULT hr = S_OK;
	switch( eFileFormat )
	{
	case eANSI:
	{
		// convert the entire buffer

		// determine the user's choice of code page
		int iCodePage = CVCProjectEngine::GetCodePageFromCharSet(m_bstrFileEncoding);
		if (!iCodePage)
			iCodePage = CP_ACP;

		// determine the buffer size in ANSI MBCS
		buf_size = CVCProjectEngine::ConvertFromUnicodeMlang( iCodePage, TRUE, TRUE, (wchar_t*)m_pBuf, 
			m_dwBytesInBuffer/sizeof(wchar_t), NULL, 0, NULL );
		if( buf_size )
		{
			// alloc a buffer
			buffer = new char[buf_size];
			// convert
			CVCProjectEngine::ConvertFromUnicodeMlang( iCodePage, TRUE, TRUE, (wchar_t*)m_pBuf, m_dwBytesInBuffer/sizeof(wchar_t),
				buffer, buf_size, NULL /* &<usedDefault>*/);
			// WARNING: RichardS (in VS7 200565) says we shouldn't be telling the user if there was a problem, so don't.
			// set the member buffer to the converted one
			delete[] m_pBuf;
			m_pBuf = buffer;
			buffer = NULL;
		}
		break;
	}
	case eUTF8:
	{
		// convert the entire buffer

		// determine the buffer size in UTF-8 MBCS
		buf_size = CVCProjectEngine::ConvertFromUnicodeMlang( CP_UTF8, TRUE, TRUE, (wchar_t*)m_pBuf, 
			m_dwBytesInBuffer/sizeof(wchar_t), NULL, 0, NULL );
		if( buf_size )
		{
			// alloc a buffer of buf_size + 3 byte UTF-8 file prefix
			buffer = new char[buf_size+3];
			buffer[0] = (char)0xEF;
			buffer[1] = (char)0xBB;
			buffer[2] = (char)0xBF;
			// convert
			CVCProjectEngine::ConvertFromUnicodeMlang( CP_UTF8, TRUE, TRUE, (wchar_t*)m_pBuf, m_dwBytesInBuffer/sizeof(wchar_t),
				buffer+3, buf_size, NULL);
			buf_size += 3;
			// set the member buffer to the converted one
			delete[] m_pBuf;
			m_pBuf = buffer;
			buffer = NULL;
		}
		break;
	}
	case eUnicode:
	{
		// write the two byte Unicode file prefix
		unsigned char buf[2] = { 0xFF, 0xFE };
		fwrite( (void*)buf, 1, 2, m_file );
		// set the buffer size (number of bytes to write)
		buf_size = m_dwBytesInBuffer;
		break;
	}
	default:
		break;
	}

	// if we have a file
	if( m_file )
	{
		if (SUCCEEDED(hr))
		{
			// flush the buffer to disk
			DWORD dwBytesWritten;
			dwBytesWritten = (DWORD) fwrite( (void*)m_pBuf, 1, buf_size, m_file );
			if( dwBytesWritten != buf_size )
			{
				int err = ferror( m_file );
				if( err )
				{
					// an error occurred
					clearerr( m_file );
					return E_FAIL;
				}
			}
		}
		// close the file
		fclose( m_file );
		m_file = NULL;
	}

	// free the buffer
	delete[] m_pBuf;
	m_pBuf = NULL;

	return hr;
}

STDMETHODIMP CXMLFile::Revert()
{
	return E_NOTIMPL;
}

STDMETHODIMP CXMLFile::LockRegion(
	ULARGE_INTEGER libOffset,
	ULARGE_INTEGER cb,
	DWORD dwLockType)
{
	return E_NOTIMPL;
}

STDMETHODIMP CXMLFile::UnlockRegion(
	ULARGE_INTEGER libOffset,
	ULARGE_INTEGER cb,
	DWORD dwLockType)
{
	return E_NOTIMPL;
}

STDMETHODIMP CXMLFile::Stat(
	STATSTG *pstatstg,
	DWORD grfStatFlag)
{
	return E_NOTIMPL;
}

STDMETHODIMP CXMLFile::Clone(
	IStream **ppstm)
{
	return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\vcpb\XboxImageTool.h ===
//////////////////////////////////////////////////////////////////////
//
// XboxImageTool.h: Definition of the Xbox Image Tool classes
//
//////////////////////////////////////////////////////////////////////

#pragma once

#include "vctool.h"
#include "settingspage.h"

template<class T, class IFace>
class ATL_NO_VTABLE CXboxImageBasePage :
	public IDispatchImpl<IFace, &(__uuidof(IFace)), &LIBID_VCProjectEnginePrivateLibrary, PrivateProjBuildTypeLibNumber, 0, CVsTypeInfoHolder>,
	public CPageObjectImpl<T, XBOXIMAGETOOL_MIN_DISPID, XBOXIMAGETOOL_MAX_DISPID>,
	public CComObjectRoot
{
public:
BEGIN_COM_MAP(T)
	COM_INTERFACE_ENTRY(IPerPropertyBrowsing)
	COM_INTERFACE_ENTRY(IVsPerPropertyBrowsing)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IFace)
	COM_INTERFACE_ENTRY(IVCPropertyContainer)
	COM_INTERFACE_ENTRY(IProvidePropertyBuilder)
END_COM_MAP()

	// IDispatch override
	STDMETHOD(Invoke)( DISPID dispid, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS *pdispParams, VARIANT *pvarResult, EXCEPINFO *pexcepInfo, UINT *puArgErr )
	{
		IDispatchImpl<IFace, &(__uuidof(IFace)), &LIBID_VCProjectEnginePrivateLibrary, PrivateProjBuildTypeLibNumber,0, CVsTypeInfoHolder>::Invoke( dispid, riid, lcid, wFlags, pdispParams, pvarResult, pexcepInfo, puArgErr );
		return S_OK;
	}

	// Can override Commit here, if nescessary. See XboxImage tool for an example.
};

class ATL_NO_VTABLE CXboxImageGeneralPage :
	public CXboxImageBasePage<CXboxImageGeneralPage, IXboxImageGeneralPage>
{
// IXboxImageGeneralPage
public:
	STDMETHOD(get_AdditionalOptions)(BSTR* pbstrAdditionalOptions);
	STDMETHOD(put_AdditionalOptions)(BSTR pbstrAdditionalOptions);
	STDMETHOD(get_FileName)(BSTR* pbstrFileName);
	STDMETHOD(put_FileName)(BSTR pbstrFileName);
	STDMETHOD(get_XBEFlags)(long* pnFlags);
	STDMETHOD(put_XBEFlags)(long pnFlags);
	STDMETHOD(get_StackSize)(long* pnStackSize);
	STDMETHOD(put_StackSize)(long nStackSize);
	STDMETHOD(get_IncludeDebugInfo)(enumBOOL* pbIncludeDebugInfo);
	STDMETHOD(put_IncludeDebugInfo)(enumBOOL bIncludeDebugInfo);
	STDMETHOD(get_LimitAvailableMemoryTo64MB)(enumBOOL* pbLimitAvailableMemoryTo64MB);
	STDMETHOD(put_LimitAvailableMemoryTo64MB)(enumBOOL bLimitAvailableMemoryTo64MB);

// helpers
public:
	virtual void GetBaseDefault(long id, CComVariant& varValue);
};

class ATL_NO_VTABLE CXboxImageCertificatePage :
	public CXboxImageBasePage<CXboxImageCertificatePage, IXboxImageCertificatePage>
{
// IVCXboxImageCertificatePage
public:
	STDMETHOD(get_TitleID)(long* pnTitleID);
	STDMETHOD(put_TitleID)(long pnTitleID);
	STDMETHOD(get_XboxGameRegion)(long* pnXboxGameRegion);
	STDMETHOD(put_XboxGameRegion)(long nXboxGameRegion);
	STDMETHOD(get_XboxGameRating)(enumXboxGameRating* peXboxGameRating);
	STDMETHOD(put_XboxGameRating)(enumXboxGameRating eXboxGameRating);
};

class ATL_NO_VTABLE CXboxImageTitleInfoPage :
	public CXboxImageBasePage<CXboxImageTitleInfoPage, IXboxImageTitleInfoPage>
{
// IVCXboxImageTitleInfoPage
public:
	STDMETHOD(get_TitleInfo)(BSTR* pbstrTitleInfo);
	STDMETHOD(put_TitleInfo)(BSTR pbstrTitleInfo);
	STDMETHOD(get_TitleName)(BSTR* pbstrTitleName);
	STDMETHOD(put_TitleName)(BSTR pbstrTitleName);
	STDMETHOD(get_TitleImage)(BSTR* pbstrTitleImage);
	STDMETHOD(put_TitleImage)(BSTR pbstrTitleImage);
	STDMETHOD(get_SaveGameImage)(BSTR* pbstrSaveGameImage);
	STDMETHOD(put_SaveGameImage)(BSTR pbstrSaveGameImage);
};

// classes in this header
class CXboxImageTool;
class CXboxImageToolOptionHandler;

class CXboxImageToolOptionHandler : public COptionHandlerBase
{
public:
	DECLARE_OPTION_TABLE();

public:
	// default value handlers
	// string props
	virtual void GetDefaultValue( long id, BSTR *pVal, IVCPropertyContainer *pPropCnt = NULL );
	// integer props
	virtual void GetDefaultValue( long id, long *pVal, IVCPropertyContainer *pPropCnt = NULL );
	// boolean props
	virtual void GetDefaultValue( long id, VARIANT_BOOL *pVal, IVCPropertyContainer *pPropCnt = NULL );

protected:
	virtual BOOL SynthesizeOptionIfNeeded(IVCPropertyContainer* pPropContainer, long idOption);
	virtual BOOL SynthesizeOption(IVCPropertyContainer* pPropContainer, long idOption, CComVariant& rvar);
public:
	BOOL CreateFileName(IVCPropertyContainer* pPropContainer, BSTR *bstrVal, BOOL bCheckForExistence = TRUE);
};

class CXboxImageToolHelper
{
public:
	HRESULT DoGenerateOutput(long type, IVCBuildActionList* pActions, IVCBuildErrorContext* pEC,
		IVCToolImpl* pTool);
	HRESULT DoGetPrimaryOutputFromTool(IUnknown* pItem, CPathW& rpath);
	HRESULT DoHasDependencies(IVCBuildAction* pAction, VARIANT_BOOL* pbHasDependencies);
	HRESULT DoGetDependencies(IVCBuildAction* pAction, IVCBuildStringCollection** ppStrings, VARIANT_BOOL* pbUpToDate,
		BOOL bAllowDirty = TRUE);

protected:
	virtual BOOL CreateFileName(IVCPropertyContainer* pPropContainer, BSTR* pbstrVal) PURE;
	virtual HRESULT DoHasPrimaryOutputFromTool(IUnknown* pItem, VARIANT_BOOL bSchmoozeOnly, VARIANT_BOOL* pbHasPrimaryOutput) PURE;
	int GetNextDep(int nStartDep, CStringW& strDepList, int nDepLen, CStringW& strDep);
	HRESULT DoGetAdditionalDependenciesInternal(IVCPropertyContainer* pItem, IVCBuildAction* pAction, BOOL bForSave, 
		BSTR* pbstrInputs, COptionHandlerBase* poptHandler, UINT idUserDeps, UINT idProjDeps, LPCOLESTR szExtras = L"");

public:
	static void GetProjectCfgForItem(IUnknown* pItem, VCConfiguration** pProjCfg);
};

/////////////////////////////////////////////////////////////////////////////
// CXboxImageTool

class ATL_NO_VTABLE CXboxImageTool	: 
	public IDispatchImpl<XboxImageTool, &IID_XboxImageTool, &LIBID_VCProjectEngineLibrary, PublicProjBuildTypeLibNumber,0, CVsTypeInfoHolder>, 
	public CComObjectRoot,
	public CXboxImageToolHelper,
	public CVCToolImpl
{
public:
	CXboxImageTool(); 
	static HRESULT CreateInstance(IVCPropertyContainer* pPropContainer, IVCToolImpl** ppTool);

BEGIN_COM_MAP(CXboxImageTool)
 	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IVCToolImpl)
	COM_INTERFACE_ENTRY(XboxImageTool)
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE(CXboxImageTool) 

#define XBOXIMAGETOOL_NUMPAGES 3

// VCXboxImageTool
public:
	// general
	STDMETHOD(get_ToolName)(BSTR* pbstrToolName);	// friendly name of tool, e.g., "XboxImage Tool"
	STDMETHOD(get_AdditionalOptions)(BSTR* pbstrAdditionalOptions);	// anything we don't know what to do with, given verbatim, in same order as entered, parent contributions first, goes after all other options
	STDMETHOD(put_AdditionalOptions)(BSTR bstrAdditionalOptions);
	STDMETHOD(get_FileName)(BSTR* pbstrFileName);
	STDMETHOD(put_FileName)(BSTR pbstrFileName);
	STDMETHOD(get_XBEFlags)(long* pnFlags);
	STDMETHOD(put_XBEFlags)(long pnFlags);
	STDMETHOD(get_StackSize)(long* pnStackSize);
	STDMETHOD(put_StackSize)(long nStackSize);
	STDMETHOD(get_IncludeDebugInfo)(VARIANT_BOOL* pbIncludeDebugInfo);
	STDMETHOD(put_IncludeDebugInfo)(VARIANT_BOOL bIncludeDebugInfo);
	STDMETHOD(get_LimitAvailableMemoryTo64MB)(VARIANT_BOOL* pbLimitAvailableMemoryTo64MB);
	STDMETHOD(put_LimitAvailableMemoryTo64MB)(VARIANT_BOOL bLimitAvailableMemoryTo64MB);
	// certificate
	STDMETHOD(get_TitleID)(long* pnTitleID);
	STDMETHOD(put_TitleID)(long pnTitleID);
	STDMETHOD(get_XboxGameRegion)(long* pnXboxGameRegion);
	STDMETHOD(put_XboxGameRegion)(long nXboxGameRegion);
	STDMETHOD(get_XboxGameRating)(enumXboxGameRating* peXboxGameRating);
	STDMETHOD(put_XboxGameRating)(enumXboxGameRating eXboxGameRating);
	// title info
	STDMETHOD(get_TitleInfo)(BSTR* pbstrTitleInfo);
	STDMETHOD(put_TitleInfo)(BSTR pbstrTitleInfo);
	STDMETHOD(get_TitleName)(BSTR* pbstrTitleName);
	STDMETHOD(put_TitleName)(BSTR pbstrTitleName);
	STDMETHOD(get_TitleImage)(BSTR* pbstrTitleImage);
	STDMETHOD(put_TitleImage)(BSTR pbstrTitleImage);
	STDMETHOD(get_SaveGameImage)(BSTR* pbstrSaveGameImage);
	STDMETHOD(put_SaveGameImage)(BSTR pbstrSaveGameImage);

	// Automation properties
	STDMETHOD(get_ToolPath)(BSTR *pVal);
	STDMETHOD(get_PropertyOption)(BSTR bstrProp, long dispidProp, BSTR *pVal) { return DoGetPropertyOption(bstrProp, dispidProp, pVal); }
	STDMETHOD(get_VCProjectEngine)(IDispatch** projEngine)	{ return DoGetVCProjectEngine(projEngine); }

// IVCToolImpl
public:
	STDMETHOD(get_DefaultExtensions)(BSTR* pVal);
	STDMETHOD(put_DefaultExtensions)(BSTR newVal);
	STDMETHOD(GetAdditionalOptionsInternal)(IUnknown* pItem, VARIANT_BOOL bForBuild, VARIANT_BOOL bSkipLocal, BSTR* pbstrAdditionalOptions);
	STDMETHOD(GetBuildDescription)(IVCBuildAction* pAction, BSTR* pbstrBuildDescription);
	STDMETHOD(get_ToolPathInternal)(BSTR* pbstrToolPath);
	STDMETHOD(get_Bucket)(long *pVal);
	STDMETHOD(GenerateOutput)(long type, IVCBuildActionList* plstActions, IVCBuildErrorContext* pEC);
	STDMETHOD(AffectsOutput)(long nPropID, VARIANT_BOOL* pbAffectsOutput);
	STDMETHOD(IsTargetTool)(IVCBuildAction* pAction, VARIANT_BOOL* pbTargetTool); // tool always operates on target, not on file
	STDMETHOD(IsDeleteOnRebuildFile)(LPCOLESTR szFile, VARIANT_BOOL* pbDelOnRebuild);
	STDMETHOD(get_ToolShortName)(BSTR* pbstrToolName);
	STDMETHOD(MatchName)(BSTR bstrName, VARIANT_BOOL bFullOnly, VARIANT_BOOL* pbMatches);
	STDMETHOD(CreateToolObject)(IVCPropertyContainer* pPropContainer, IVCToolImpl** ppToolObject);
	STDMETHOD(HasPrimaryOutputFromTool)(IUnknown* pItem, VARIANT_BOOL bSchmoozeOnly, VARIANT_BOOL* pbHasPrimaryOutput);	// returns TRUE only if tool generates a primary output (ex: XboxImage)
	STDMETHOD(HasDependencies)(IVCBuildAction* pAction, VARIANT_BOOL* pbHasDependencies);
	STDMETHOD(GetDependencies)(IVCBuildAction* pAction, IVCBuildStringCollection** ppStrings, VARIANT_BOOL* pbUpToDate);
	STDMETHOD(CanScanForDependencies)(VARIANT_BOOL* pbIsScannable);
	STDMETHOD(IsSpecialConsumable)(LPCOLESTR szPath, VARIANT_BOOL* pbSpecial);
	STDMETHOD(CreatePageObject)(IUnknown **, CLSID*, IVCPropertyContainer *, IVCSettingsPage * );
	STDMETHOD(GetPrimaryOutputIDFromTool)(IUnknown* pItem, VARIANT_BOOL bSchmoozeOnly, long* pnOutputID);	// return a value only if tool generates a primary output (ex: XboxImage)

	STDMETHOD(get_ToolDisplayIndex)(long* pIndex)
	{
		CHECK_POINTER_NULL(pIndex);
		*pIndex = TOOL_DISPLAY_INDEX_XBOXIMAGE;
		return S_OK;
	}

// helpers

public:
	virtual COptionHandlerBase* GetOptionHandler() { return &s_optHandler; }
	virtual HRESULT GetPrimaryOutputFromTool(IUnknown* pItem, VARIANT_BOOL bSchmoozeOnly, CPathW& rpath);	// return a value only if tool generates a primary output (ex: XboxImage)
	virtual long GetPageCount();
	virtual GUID* GetPageIDs();

protected:
	virtual BOOL UsesResponseFiles() { return TRUE; }
	virtual BOOL CreateFileName(IVCPropertyContainer* pPropContainer, BSTR* pbstrVal);
	virtual HRESULT DoHasPrimaryOutputFromTool(IUnknown* pItem, VARIANT_BOOL bSchmoozeOnly, VARIANT_BOOL* pbHasPrimaryOutput)
	{ return HasPrimaryOutputFromTool(pItem, bSchmoozeOnly, pbHasPrimaryOutput); }
	virtual LPCOLESTR GetToolFriendlyName();
	void InitToolName();
	virtual long GetToolID() { return IDS_XBOXIMAGETOOL; }

protected:
	static const wchar_t *s_pszDelOnRebuildExtensions;
	static CComBSTR s_bstrBuildDescription;
	static CComBSTR s_bstrToolName;
	static CComBSTR s_bstrExtensions;

	static GUID s_pPages[XBOXIMAGETOOL_NUMPAGES];
	static BOOL s_bPagesInit;

public:
	static CXboxImageToolOptionHandler s_optHandler;
};

// These macros are used to define enum ranges for tool switches.  If you add an enum property to the tool option
// table, please add a matching macro for it to this list.  Use of macros for range definitions helps in keeping
// maintenance of enum range checks as low as possible.
#define XboxGameRatingMin			 0
#define XboxGameRatingMax			 7
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\res\src\inc\binddefs.h ===
/////////////////////////////////////////////////////////////////////////////
//	BINDDEFS.H
//		Defines for bound control extended properties

#ifndef __BINDDEFS_H__
#define __BINDDEFS_H__


#define DISPID_DATASOURCE	0x80010001
#define DISPID_DATAFIELD	0x80010002

#define DISPID_NAME			0x80010009
#define DISPID_ID			0x80010003
#define DISPID_VISIBLE		0x80010004
#define DISPID_DISABLED		0x80010005
#define DISPID_GROUP		0x80010006
#define DISPID_TABSTOP1		0x80010007
#define DISPID_HELP			0x80010008

#endif	// __BINDDEFS_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\langapi\attribute\include\evntusag.h ===
[CODE: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\vcpb\XboxImageTool.cpp ===
// XboxImageTool.cpp : Implementation of Xbox Image Tool

#include "stdafx.h"
#include "XboxImageTool.h"
#include "FileRegistry.h"
#include "BldHelpers.h"
#include "BldActions.h"
#include "stylesheet.h"
#include "ProjWriter.h"

// constants
const wchar_t* const wszXboxImageDefaultExtensions = L"*.exe;*.pdb";	// remember to update Xbox.rgs if you change this...
const wchar_t* wszXboxImageDelOnRebuildExtensions = L"xbe";

const long lnTypeLibraryResourceID = 1;
const subSystemOption lSubSystem = subSystemNotSet;
const long lnHeapReserveSize = 0;
const long lnHeapCommitSize = 0;
const long lnStackReserveSize = 0;
const long lnStackCommitSize = 0;
const machineTypeOption lTargetMachine = machineNotSet;

// static initializers
CXboxImageToolOptionHandler CXboxImageTool::s_optHandler;
CComBSTR CXboxImageTool::s_bstrBuildDescription = L"";
CComBSTR CXboxImageTool::s_bstrToolName = L"";
CComBSTR CXboxImageTool::s_bstrExtensions = L"";
GUID CXboxImageTool::s_pPages[XBOXIMAGETOOL_NUMPAGES];
BOOL CXboxImageTool::s_bPagesInit;


////////////////////////////////////////////////////////////////////////////////
// Option Table for the Xbox Image Tool switches

// NOTE: we're using macros for enum value ranges to help in keeping enum range checks as low maintenance as possible.
// If you add an enum to this table, make sure you use macros to define the upper and lower bounds and use CHECK_BOUNDS
// on the get/put methods associated with that property (both object model and property page).
// WARNING: if you change ANYTHING about a multi-prop here (including add/remove), be sure to update how the property
// is obtained on both the tool and page objects.
BEGIN_OPTION_TABLE(CXboxImageToolOptionHandler, L"XboxImageTool", IDS_XBOXIMAGETOOL, TRUE /* pre & post */, FALSE /* case sensitive */)

	// general
	OPT_BSTR(FileName,			L"OUT:%s",						L"FileName", single,				IDS_XboxImageGeneral, XBOXIMAGEID)
	OPT_INT(XBEFlags,			L"initflags:0x%x",				L"XBEFlags",						IDS_XboxImageGeneral, XBOXIMAGEID)
	OPT_INT(StackSize,			L"stack:0x%x",					L"StackSize",						IDS_XboxImageGeneral, XBOXIMAGEID)
	OPT_BOOL(IncludeDebugInfo,	L"|debug",						L"IncludeDebugInfo",				IDS_XboxImageGeneral, XBOXIMAGEID)
	OPT_BOOL(LimitAvailableMemoryTo64MB,	L"|limitmem",		L"LimitAvailableMemoryTo64MB",		IDS_XboxImageGeneral, XBOXIMAGEID)

	// certificate
	OPT_INT(TitleID,			L"testid:0x%x",					L"TitleID",							IDS_XboxImageCertificate, XBOXIMAGEID)
	OPT_INT(XboxGameRegion,		L"testregion:0x%x",				L"XboxGameRegion",					IDS_XboxImageCertificate, XBOXIMAGEID)
	OPT_ENUM(XboxGameRating,	L"|testratings:%d", XboxGameRatingMin, XboxGameRatingMax, L"XboxGameRating", IDS_XboxImageCertificate, XBOXIMAGEID)
	
	// Title info
	OPT_BSTR(TitleInfo, L"|titleinfo:%s",						L"TitleInfo",		single,			IDS_XboxImageTitleInfo, XBOXIMAGEID)
	OPT_BSTR(TitleName, L"|testname:%s",						L"TitleName",		single,			IDS_XboxImageTitleInfo, XBOXIMAGEID)
	OPT_BSTR(TitleImage, L"|titleimage:%s",						L"TitleImage",		single,			IDS_XboxImageTitleInfo, XBOXIMAGEID)
	OPT_BSTR(SaveGameImage, L"|defaultsaveimage:%s",			L"SaveGameImage",	single,			IDS_XboxImageTitleInfo, XBOXIMAGEID)

END_OPTION_TABLE()

// default value handlers
// string props
void CXboxImageToolOptionHandler::GetDefaultValue( long id, BSTR *pVal, IVCPropertyContainer *pPropContainer )
{
	switch( id )
	{
	case XBOXIMAGEID_FileName:
	{
		if (pPropContainer == NULL)
			GetDefaultString( pVal );
		else
		{
			*pVal = NULL;
			CComBSTR bstrFile = L"$(OutDir)/$(ProjectName).xbe";
			*pVal = bstrFile.Detach();
		}
		break;
	}

	default:
		GetDefaultString( pVal );
		break;
	}
}

// integer props
void CXboxImageToolOptionHandler::GetDefaultValue( long id, long *pVal, IVCPropertyContainer *pPropCnt )
{
//	switch( id )
//	{
//	default:
		*pVal = 0;
//		break;
//	}
}

// boolean props
void CXboxImageToolOptionHandler::GetDefaultValue( long id, VARIANT_BOOL *pVal, IVCPropertyContainer *pPropCnt )
{
// 	switch( id )
// 	{
// 	default:
		GetValueFalse( pVal );
// 		break;
// 	}
}

BOOL CXboxImageToolOptionHandler::SynthesizeOptionIfNeeded(IVCPropertyContainer* pPropContainer, long idOption)
{
	switch (idOption)
	{
	case XBOXIMAGEID_FileName:
		return TRUE;
	default:
		return FALSE;
	}
}

BOOL CXboxImageToolOptionHandler::SynthesizeOption(IVCPropertyContainer* pPropContainer, long idOption, 
	CComVariant& rvar)
{
	CComBSTR bstrVal;
	switch (idOption)
	{
	case XBOXIMAGEID_FileName:
		CreateFileName(pPropContainer, &bstrVal, FALSE);
		break;
	default:
		VSASSERT(FALSE, "Case statement mismatch between SynthesizeOptionIfNeeded and SynthesizeOption");	// shouldn't be here!!
		return FALSE;
	}

	rvar = bstrVal;
	return TRUE;
}

static const wchar_t* szScriptItemCL = L"\r\n<a title=\"%s | %s\" onclick=\"onHelp('VC.Project.VCConfiguration.%s')\" href=\"settingspage.htm\">%s</a>";

BOOL CXboxImageToolOptionHandler::CreateFileName(IVCPropertyContainer* pPropContainer, BSTR *pbstrVal,
	BOOL bCheckForExistence /* = TRUE */)
{
	VSASSERT(pPropContainer != NULL, "Cannot create output name without a property container");
	RETURN_ON_NULL2(pPropContainer, FALSE);

	if (bCheckForExistence &&
		pPropContainer->GetEvaluatedStrProperty(XBOXIMAGEID_FileName, pbstrVal) == S_OK)	// found it directly set, so use it
		return TRUE;

	CXboxImageTool::s_optHandler.GetDefaultValue( XBOXIMAGEID_FileName, pbstrVal, pPropContainer );
	HRESULT hr = pPropContainer->Evaluate(*pbstrVal, pbstrVal);

	return (SUCCEEDED(hr));
}

/////////////////////////////////////////////////////////////////////////////
HRESULT CXboxImageToolHelper::DoGenerateOutput(long type, IVCBuildActionList* plstActions, IVCBuildErrorContext* pEC, 
	IVCToolImpl* pTool)
{
	RETURN_ON_NULL2(plstActions, S_OK);	// nothing to do

	CComPtr<VCProject> spProject;
	CComBSTR bstrProjectDirectory;
	BOOL bFirst = TRUE;
	plstActions->Reset(NULL);
	while (TRUE)
	{
		CComPtr<IVCBuildAction> spAction;
		HRESULT hr = plstActions->Next(&spAction, NULL);
		BREAK_ON_DONE(hr);

		CComPtr<IVCBuildableItem> spItem;
		spAction->get_Item(&spItem);
		CComQIPtr<IVCPropertyContainer> spPropContainer = spItem;
		VSASSERT(spPropContainer != NULL, "Cannot generate output without a property container");

		if (bFirst)
		{
			bFirst = TRUE;
			if (spPropContainer != NULL)
				spPropContainer->GetStrProperty(VCPROJID_ProjectDirectory, &bstrProjectDirectory);	// should never have macros in it
		}

		// Remember that for a newly created project, the file path is supposed to be NULL:
		CPathW pathName;
		CStringW strName;
		
		// do we want the primary output?
		if (type & AOGO_Primary)
		{
			VARIANT_BOOL bHasPrimaryOutput = VARIANT_FALSE;
			hr = DoHasPrimaryOutputFromTool(spItem, VARIANT_TRUE, &bHasPrimaryOutput);
			RETURN_ON_FAIL(hr);
			if (bHasPrimaryOutput == VARIANT_FALSE)
				continue;	// nothing more to do

			HRESULT hrT = DoGetPrimaryOutputFromTool(spItem, pathName);
			RETURN_ON_FAIL(hrT);

			pathName.GetActualCase(TRUE);
			hrT = spAction->AddOutputFromPath((wchar_t *)(const wchar_t *)pathName, pEC, VARIANT_TRUE, VARIANT_TRUE,
				XBOXIMAGEID_FileName, pTool);
			if (hrT != S_OK)
				return hrT; 	// failure
		}

	}

	return S_OK; // success
}

HRESULT CXboxImageToolHelper::DoGetPrimaryOutputFromTool(IUnknown* pItem, CPathW& rpath)
{
	CComPtr<VCConfiguration> spProjCfg;
	GetProjectCfgForItem(pItem, &spProjCfg);
	VSASSERT(spProjCfg != NULL, "Xbox Image only works on project config, not file config");
	RETURN_ON_NULL2(spProjCfg, E_UNEXPECTED);

	VARIANT_BOOL bHasPrimaryOutput = VARIANT_FALSE;
	if (FAILED(DoHasPrimaryOutputFromTool(spProjCfg, VARIANT_TRUE, &bHasPrimaryOutput)) || bHasPrimaryOutput == VARIANT_FALSE)
		return S_FALSE;

	CComQIPtr<IVCPropertyContainer> spPropContainer = spProjCfg;
	RETURN_INVALID_ON_NULL(spPropContainer);

	CComBSTR bstrProjName;
	HRESULT hrT = spPropContainer->GetStrProperty(VCPROJID_ProjectDirectory, &bstrProjName);	// should never have macros in it
	RETURN_ON_FAIL(hrT);
	CStringW strDirName = bstrProjName;
	CDirW dirProj;
	if (!dirProj.CreateFromKnown(strDirName))
		return CVCProjectEngine::DoSetErrorInfo(VCPROJ_E_INTERNAL_ERR, IDS_ERR_INTERNAL_ERROR);

	CStringW strName;
	CComBSTR bstrName;
	if (spPropContainer->GetEvaluatedStrProperty(XBOXIMAGEID_FileName, &bstrName) == S_OK)
	{
		strName = bstrName;
		if (!strName.IsEmpty())
		{
			if( !rpath.CreateFromDirAndFilename(dirProj, strName))
				return CVCProjectEngine::DoSetErrorInfo3(VCPROJ_E_BAD_PATH, IDS_ERR_CANNOT_CREATE_PATH, strDirName, strName);
			rpath.GetActualCase(TRUE);

			return S_OK;
		}
	}

	// if we get here, either the non-default is blank or there isn't one
	CreateFileName(spPropContainer, &bstrName);
	strName = bstrName;

	if (!rpath.CreateFromDirAndFilename(dirProj, strName))
		return CVCProjectEngine::DoSetErrorInfo3(VCPROJ_E_BAD_PATH, IDS_ERR_CANNOT_CREATE_PATH, strDirName, strName);
	rpath.GetActualCase(TRUE);

	return S_OK;
}

void CXboxImageToolHelper::GetProjectCfgForItem(IUnknown* pItem, VCConfiguration** pProjCfg)
{
	if (pProjCfg == NULL)
		return;
	*pProjCfg = NULL;

	CComQIPtr<VCConfiguration> spProjCfg = pItem;
	if (spProjCfg != NULL)
	{
		*pProjCfg = spProjCfg.Detach();
		return;
	}

	CComQIPtr<IVCFileConfigurationImpl> spFileCfgImpl = pItem;
	if (spFileCfgImpl == NULL)
		return;

	CComPtr<IDispatch> spDispProjCfg;
	if (FAILED(spFileCfgImpl->get_Configuration(&spDispProjCfg)) || spDispProjCfg == NULL)
		return;

	spProjCfg = spDispProjCfg;
	*pProjCfg = spProjCfg.Detach();
}

HRESULT CXboxImageToolHelper::DoHasDependencies(IVCBuildAction* pAction, VARIANT_BOOL* pbHasDependencies)
{
	CHECK_POINTER_NULL(pbHasDependencies);
	*pbHasDependencies = VARIANT_FALSE;
	RETURN_ON_NULL2(pAction, S_FALSE);

	CComPtr<IVCBuildableItem> spItem;
	pAction->get_Item(&spItem);

	CComPtr<VCConfiguration> spProjCfg;
	GetProjectCfgForItem(spItem, &spProjCfg);
	CComQIPtr<IVCConfigurationImpl> spProjCfgImpl = spProjCfg;
	RETURN_ON_NULL2(spProjCfgImpl, S_FALSE);

	return spProjCfgImpl->get_HasProjectDependencies(pbHasDependencies);
}

HRESULT CXboxImageToolHelper::DoGetAdditionalDependenciesInternal(IVCPropertyContainer* pItem, IVCBuildAction* pAction,
	BOOL bForSave, BSTR* pbstrInputs, COptionHandlerBase* poptHandler, UINT idUserDeps, UINT idProjDeps, 
	LPCOLESTR szExtras /* = L"" */)
{
	CHECK_ZOMBIE( pItem, IDS_ERR_CFG_ZOMBIE );
	CHECK_POINTER_NULL( pbstrInputs );

	if (bForSave)
	{
		*pbstrInputs = NULL;
		CComVariant varDeps;
		HRESULT hr = pItem->GetLocalProp(idUserDeps, &varDeps);
		if (hr == S_OK && varDeps.vt == VT_BSTR)
		{
			CComBSTR bstrDeps = varDeps.bstrVal;
			*pbstrInputs = bstrDeps.Detach();
		}
		else if (hr == S_FALSE)
			poptHandler->GetDefaultValue( idUserDeps, pbstrInputs );
		return hr;
	}

	CComBSTR bstrExtras;
	if (szExtras && szExtras[0] != L'\0')
	{
		bstrExtras = L" ";
		bstrExtras += szExtras;
	}

	CComBSTR bstrUserExtraInputs;
	HRESULT hr1 = pItem->GetMultiProp(idUserDeps, L" ", VARIANT_FALSE, &bstrUserExtraInputs);
	if (hr1 == S_FALSE)
		poptHandler->GetDefaultValue( idUserDeps, &bstrUserExtraInputs );
	RETURN_ON_FAIL(hr1);
	HRESULT hr2 = pItem->Evaluate(bstrUserExtraInputs, &bstrUserExtraInputs);
	RETURN_ON_FAIL(hr2);

	// best way to figure out project dependencies, unfortunately, is to go out and get them
	CComPtr<IVCBuildStringCollection> spStrings;
	VARIANT_BOOL bUpToDate;
	HRESULT hr3 = DoGetDependencies(pAction, &spStrings, &bUpToDate, FALSE /* !dirty */);
	RETURN_ON_FAIL(hr3);
	CComBSTR bstrProjExtraInputs;
	hr3 = pItem->GetStrProperty(idProjDeps, &bstrProjExtraInputs);	// shared ID for dependent inputs
	if (hr3 == S_FALSE)
	{
		bstrUserExtraInputs += bstrExtras;
		*pbstrInputs = bstrUserExtraInputs.Detach();
		return hr1;
	}

	CStringW strUserInputs = bstrUserExtraInputs;
	strUserInputs.TrimLeft();
	strUserInputs.TrimRight();
	CStringW strProjInputs = bstrProjExtraInputs;
	strProjInputs.TrimLeft();
	strProjInputs.TrimRight();
	CComBSTR bstrFinalExtras = strUserInputs;
	if (!strUserInputs.IsEmpty() && !strProjInputs.IsEmpty())
		bstrFinalExtras += L" ";
	CComBSTR bstrProjInputs;
	if (!strProjInputs.IsEmpty())
		bstrProjInputs = strProjInputs;
	bstrFinalExtras += bstrProjInputs;
	bstrFinalExtras += bstrExtras;
	*pbstrInputs = bstrFinalExtras.Detach();

	return S_OK;
}

int CXboxImageToolHelper::GetNextDep(int nStartDep, CStringW& strDepList, int nDepLen, CStringW& strDep)
{
	strDep.Empty();
	if (nStartDep < 0)
		return nStartDep;
	else if (nStartDep >= nDepLen)
		return -1;

	int nSpace = nStartDep;
	const wchar_t* pchDepList = (const wchar_t*)strDepList + nStartDep;
	while (*pchDepList == L' ' && nSpace < nDepLen)	// first, skip any leading spaces
	{
		pchDepList++;
		nSpace++;
	}

	if (nSpace == nDepLen)	// we were dealing with trailing spaces
		return -1;

	nStartDep = nSpace;
	wchar_t chTerm;
	if (*pchDepList == L'"')
	{
		pchDepList++;	// go to next character;
		nSpace++;
		chTerm = L'"';
	}
	else
		chTerm = L' ';

	while (*pchDepList != chTerm && nSpace < nDepLen)
	{
		pchDepList++;
		nSpace++;
	}
	if (chTerm == L'"' && nSpace < nDepLen)	// need to pick up the terminator in this case...
		nSpace++;

	if (nSpace < nDepLen)
	{
		strDep = strDepList.Mid(nStartDep, nSpace-nStartDep);
		nSpace++;
		return nSpace;
	}

	if (nStartDep < nDepLen)
		strDep = strDepList.Right(nDepLen-nStartDep);

	return -1;
}

HRESULT CXboxImageToolHelper::DoGetDependencies(IVCBuildAction* pAction, IVCBuildStringCollection** ppStrings, 
	VARIANT_BOOL* pbUpToDate, BOOL bAllowDirty /* = TRUE */)
{
	CHECK_POINTER_NULL(ppStrings);
	*ppStrings = NULL;
	RETURN_ON_NULL2(pAction, S_FALSE);

	BOOL bHasDepend = FALSE;

	HRESULT hr1 = S_FALSE;
	CComPtr<IVCBuildableItem> spItem;
	pAction->get_Item(&spItem);
	CComQIPtr<IVCConfigurationImpl> spProjCfgImpl = spItem;
	if (spProjCfgImpl != NULL)
	{
		hr1 = spProjCfgImpl->get_ProjectDependenciesAsStrings(ppStrings);
		RETURN_ON_FAIL(hr1);
		if (hr1 == S_OK)
			bHasDepend = TRUE;
	}

	UINT idBuiltFlag = XBOXIMAGEID_ImageCommandLineGenerated;
	CComPtr<IVCPropertyContainer> spPropContainer;
	pAction->get_PropertyContainer(&spPropContainer);
	VSASSERT(spPropContainer, "Hey, how'd we get to GetDependencies with an action with no property container?!?");
	RETURN_ON_NULL(spPropContainer);

	// now that we've got the list of dependencies at the project level, we need to make sure we add them
	// to the list of inputs to the xbox image program
	BOOL bResetDirty = TRUE;
	if (!bAllowDirty)	// playing with this from somewhere we DON'T want to be setting the dirty flag...
	{
		VARIANT_BOOL bVal;
		bResetDirty = (spPropContainer->GetBoolProperty(idBuiltFlag, &bVal) == S_OK);
		spPropContainer->Clear(idBuiltFlag);
	}

	if (bHasDepend && *ppStrings)
	{
		CStringW strProjDeps;
		CComBSTR bstrProjDir;
		spPropContainer->GetStrProperty(VCPROJID_ProjectDirectory, &bstrProjDir);
		CDirW dirProj;
		bool bNeedSpace = false;
		if (dirProj.CreateFromKnown(bstrProjDir))
		{
			(*ppStrings)->Reset();
			while (TRUE)
			{
				CComBSTR bstrDep;
				if ((*ppStrings)->Next(&bstrDep) != S_OK)
					break;

				CPathW path;
				if (!path.Create(bstrDep))
					continue;

				if (_wcsicmp(path.GetExtension(), L".lib") != 0)	// only looking for .lib extensions
					continue;

				CStringW strPath;
				if (!path.GetRelativeName(dirProj, strPath, TRUE))
					continue;

				if (bNeedSpace)
					strProjDeps += L" ";

				strProjDeps += strPath;
				bNeedSpace = true;
			}
		}
	}

	if (bResetDirty)
		spPropContainer->SetBoolProperty(idBuiltFlag, VARIANT_TRUE);	// we've now been through here at least once

	return bHasDepend ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
CXboxImageTool::CXboxImageTool() 
{
	m_nLowKey = XBOXIMAGETOOL_MIN_DISPID;
	m_nHighKey = XBOXIMAGETOOL_MAX_DISPID;
	m_nDirtyKey = XBOXIMAGEID_CmdLineOptionsDirty;
	m_nDirtyOutputsKey = XBOXIMAGEID_OutputsDirty;
}

HRESULT CXboxImageTool::CreateInstance(IVCPropertyContainer* pPropContainer, IVCToolImpl** ppXboxImageTool)
{
	CHECK_POINTER_NULL(ppXboxImageTool);
	*ppXboxImageTool = NULL;

	CComObject<CXboxImageTool> *pObj;
	HRESULT hr = CComObject<CXboxImageTool>::CreateInstance(&pObj);
	if (SUCCEEDED(hr))
	{
		if( pPropContainer )
			pObj->Initialize(pPropContainer);
		CXboxImageTool *pVar = pObj;
		pVar->AddRef();
		*ppXboxImageTool = pVar;
	}
	return hr;
}

STDMETHODIMP CXboxImageTool::IsDeleteOnRebuildFile(LPCOLESTR szFile, VARIANT_BOOL* pbDelOnRebuild)
{
	CHECK_POINTER_NULL(pbDelOnRebuild);

	BOOL fDel = BldFileNameMatchesExtension(szFile, wszXboxImageDelOnRebuildExtensions);
	*pbDelOnRebuild = fDel ? VARIANT_TRUE : VARIANT_FALSE;
	return S_OK;
}

STDMETHODIMP CXboxImageTool::get_DefaultExtensions(BSTR* pVal)
{
	return DoGetDefaultExtensions(s_bstrExtensions, wszXboxImageDefaultExtensions, pVal);
}

STDMETHODIMP CXboxImageTool::put_DefaultExtensions(BSTR newVal)
{
	s_bstrExtensions = newVal;
	return S_OK;
}

STDMETHODIMP CXboxImageTool::GetAdditionalOptionsInternal(IUnknown* pItem, VARIANT_BOOL bForBuild, VARIANT_BOOL bSkipLocal, 
	BSTR* pbstrAdditionalOptions)
{ 
	return GetProcessedAdditionalOptions(pItem, XBOXIMAGEID_AdditionalOptions, bForBuild, bSkipLocal, pbstrAdditionalOptions);
}

STDMETHODIMP CXboxImageTool::GetBuildDescription(IVCBuildAction* pAction, BSTR* pbstrBuildDescription)
{
	if (s_bstrBuildDescription.Length() == 0)
		s_bstrBuildDescription.LoadString(IDS_DESC_XBOXIMAGEING);
	return s_bstrBuildDescription.CopyTo(pbstrBuildDescription);
}

STDMETHODIMP CXboxImageTool::get_ToolPathInternal(BSTR* pbstrToolPath)
{ 
	return get_ToolPath(pbstrToolPath);
}

STDMETHODIMP CXboxImageTool::get_Bucket(long *pVal)
{
	CHECK_POINTER_NULL( pVal );
	*pVal = BUCKET_XBOXIMAGE; 
	return S_OK;
}

STDMETHODIMP CXboxImageTool::GenerateOutput(long type, IVCBuildActionList* plstActions, IVCBuildErrorContext* pEC)
{
	return DoGenerateOutput(type, plstActions, pEC, this);
}

///////////////////////////////////////////////////////////////////////////////
// Affects our output?
STDMETHODIMP CXboxImageTool::AffectsOutput(long nPropID, VARIANT_BOOL* pbAffectsOutput)
{
	CHECK_POINTER_NULL(pbAffectsOutput);
	*pbAffectsOutput = VARIANT_FALSE;

	// change our outputs?
	switch (nPropID)
	{
	case XBOXIMAGEID_FileName:			// *.xbe
		// anything we care about dirty
		*pbAffectsOutput = VARIANT_TRUE;
		break;
	default:
		*pbAffectsOutput = VARIANT_FALSE;
		break;
	}

	return S_OK;
}

long CXboxImageTool::GetPageCount()	{ return XBOXIMAGETOOL_NUMPAGES; }


GUID* CXboxImageTool::GetPageIDs()
{
	if (s_bPagesInit == FALSE)
	{
		s_pPages[0] = __uuidof(XboxImageGeneral);
		s_pPages[1] = __uuidof(XboxImageCertificate);
		s_pPages[2] = __uuidof(XboxImageTitleInfo);
		s_bPagesInit = TRUE;
	}
	return s_pPages; 
}

STDMETHODIMP CXboxImageTool::IsSpecialConsumable(LPCOLESTR szPath, VARIANT_BOOL* pbSpecial)
{
	CHECK_POINTER_NULL(pbSpecial);

	//if (BldFileNameMatchesExtension(szPath, L"def"))
	//	*pbSpecial = VARIANT_TRUE;
	//else
		*pbSpecial = VARIANT_FALSE;
	return S_OK;
}

HRESULT CXboxImageTool::GetPrimaryOutputFromTool(IUnknown* pItem, VARIANT_BOOL bSchmoozeOnly, CPathW& rpath)
{
	return DoGetPrimaryOutputFromTool(pItem, rpath);
}

STDMETHODIMP CXboxImageTool::HasPrimaryOutputFromTool(IUnknown* pItem, VARIANT_BOOL bSchmoozeOnly, VARIANT_BOOL* pbHasPrimaryOutput)
{
	return COptionHandlerBase::GetValueTrue( pbHasPrimaryOutput );
}

STDMETHODIMP CXboxImageTool::GetPrimaryOutputIDFromTool(IUnknown* pItem, VARIANT_BOOL bSchmoozeOnly, long* pnOutputID)
{
	CHECK_POINTER_NULL(pnOutputID);
	*pnOutputID = XBOXIMAGEID_FileName;
	return S_OK;
}

STDMETHODIMP CXboxImageTool::HasDependencies(IVCBuildAction* pAction, VARIANT_BOOL* pbHasDependencies)
{
	return DoHasDependencies(pAction, pbHasDependencies);
}

STDMETHODIMP CXboxImageTool::IsTargetTool(IVCBuildAction* pAction, VARIANT_BOOL* pbTargetTool)
{ // tool always operates on target, not on file
	return COptionHandlerBase::GetValueTrue(pbTargetTool);
}

STDMETHODIMP CXboxImageTool::get_ToolShortName(BSTR* pbstrToolName)
{
	*pbstrToolName = SysAllocString( szXboxImageToolShortName );
	return S_OK;
}

STDMETHODIMP CXboxImageTool::MatchName(BSTR bstrName, VARIANT_BOOL bFullOnly, VARIANT_BOOL* pbMatches)
{
	return DoMatchName(bstrName, szXboxImageToolType, szXboxImageToolShortName, pbMatches);
}

STDMETHODIMP CXboxImageTool::CreateToolObject(IVCPropertyContainer* pPropContainer, IVCToolImpl** ppToolObject)
{ 
	return CreateInstance(pPropContainer, ppToolObject); 
}

STDMETHODIMP CXboxImageTool::CanScanForDependencies(VARIANT_BOOL* pbIsScannable)
{
	return COptionHandlerBase::GetValueTrue(pbIsScannable);
}

STDMETHODIMP CXboxImageTool::GetDependencies(IVCBuildAction* pAction, IVCBuildStringCollection** ppStrings, 
	VARIANT_BOOL* pbUpToDate)
{
	CHECK_READ_POINTER_NULL(pAction);
	return DoGetDependencies(pAction, ppStrings, pbUpToDate);
}

BOOL CXboxImageTool::CreateFileName(IVCPropertyContainer* pPropContainer, BSTR* pbstrVal)
{
	return s_optHandler.CreateFileName(pPropContainer, pbstrVal, FALSE);
}

STDMETHODIMP CXboxImageTool::CreatePageObject(IUnknown **ppUnk, CLSID*pCLSID, IVCPropertyContainer *pPropCntr, IVCSettingsPage *pPage )
{
	// Get the list of pages
	if( CLSID_XboxImageGeneral == *pCLSID )
	{
		CPageObjectImpl< CXboxImageGeneralPage, XBOXIMAGETOOL_MIN_DISPID, XBOXIMAGETOOL_MAX_DISPID >::CreateInstance(ppUnk, pPropCntr, pPage);
	}
	else if( CLSID_XboxImageCertificate == *pCLSID )
	{
		CPageObjectImpl< CXboxImageCertificatePage, XBOXIMAGETOOL_MIN_DISPID, XBOXIMAGETOOL_MAX_DISPID >::CreateInstance(ppUnk, pPropCntr, pPage);
	}
	else if( CLSID_XboxImageTitleInfo == *pCLSID )
	{
		CPageObjectImpl< CXboxImageTitleInfoPage, XBOXIMAGETOOL_MIN_DISPID, XBOXIMAGETOOL_MAX_DISPID >::CreateInstance(ppUnk, pPropCntr, pPage);
	}
	else
	{
		return S_FALSE;
	}
		
	return S_OK;
}

LPCOLESTR CXboxImageTool::GetToolFriendlyName()
{
	InitToolName();
	return s_bstrToolName;
}

void CXboxImageTool::InitToolName()
{
	if (s_bstrToolName.Length() == 0)
	{
		if (!s_bstrToolName.LoadString(IDS_XBOXIMAGE_TOOLNAME))
			s_bstrToolName = szXboxImageToolType;
	}
}

// general
STDMETHODIMP CXboxImageTool::get_ToolName(BSTR* pbstrToolName)
{	// friendly name of tool, e.g., "C/C++ Compiler Tool"
	CHECK_POINTER_VALID( pbstrToolName );
	InitToolName();
	s_bstrToolName.CopyTo(pbstrToolName);
	return S_OK;
}

STDMETHODIMP CXboxImageTool::get_AdditionalOptions(BSTR* pbstrAdditionalOptions)
{	// anything we don't know what to do with, given verbatim, in same order as entered, parent contributions first, goes after all other options
	return ToolGetStrProperty(XBOXIMAGEID_AdditionalOptions, pbstrAdditionalOptions);
}

STDMETHODIMP CXboxImageTool::put_AdditionalOptions(BSTR bstrAdditionalOptions)
{
	CHECK_ZOMBIE( m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE );
	return m_spPropertyContainer->SetStrProperty(XBOXIMAGEID_AdditionalOptions, bstrAdditionalOptions);
}

STDMETHODIMP CXboxImageTool::get_FileName(BSTR* pbstrFileName)
{	// (/OUT:[file]) change the output file name (default is based on 1st lib or obj name on cmd line)
	return ToolGetStrProperty(XBOXIMAGEID_FileName, pbstrFileName);
}

STDMETHODIMP CXboxImageTool::put_FileName(BSTR bstrFileName)
{
	CHECK_ZOMBIE( m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE );
	return m_spPropertyContainer->SetStrProperty(XBOXIMAGEID_FileName, bstrFileName);
}

STDMETHODIMP CXboxImageTool::get_XBEFlags(long* pnFlags)
{
	return ToolGetIntProperty(XBOXIMAGEID_XBEFlags, pnFlags);
}

STDMETHODIMP CXboxImageTool::put_XBEFlags(long nFlags)
{
	CHECK_ZOMBIE( m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE );
	return m_spPropertyContainer->SetIntProperty(XBOXIMAGEID_XBEFlags, nFlags);
}

STDMETHODIMP CXboxImageTool::get_StackSize(long* pnStackSize)
{
	return ToolGetIntProperty(XBOXIMAGEID_StackSize, pnStackSize);
}

STDMETHODIMP CXboxImageTool::put_StackSize(long nStackSize)
{
	CHECK_ZOMBIE( m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE );
	return m_spPropertyContainer->SetIntProperty(XBOXIMAGEID_StackSize, nStackSize);
}

STDMETHODIMP CXboxImageTool::get_IncludeDebugInfo(VARIANT_BOOL* pbIncludeDebugInfo)
{	// (/NOLOGO) enable suppression of copyright message (no explicit off)
	return ToolGetBoolProperty(XBOXIMAGEID_IncludeDebugInfo, pbIncludeDebugInfo);
}

STDMETHODIMP CXboxImageTool::put_IncludeDebugInfo(VARIANT_BOOL bIncludeDebugInfo)
{
	CHECK_ZOMBIE( m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE );
	CHECK_VARIANTBOOL( bIncludeDebugInfo );
	return m_spPropertyContainer->SetBoolProperty(XBOXIMAGEID_IncludeDebugInfo, bIncludeDebugInfo);
}

STDMETHODIMP CXboxImageTool::get_LimitAvailableMemoryTo64MB(VARIANT_BOOL* pbLimitAvailableMemoryTo64MB)
{	// (/NOLOGO) enable suppression of copyright message (no explicit off)
	return ToolGetBoolProperty(XBOXIMAGEID_LimitAvailableMemoryTo64MB, pbLimitAvailableMemoryTo64MB);
}

STDMETHODIMP CXboxImageTool::put_LimitAvailableMemoryTo64MB(VARIANT_BOOL bLimitAvailableMemoryTo64MB)
{
	CHECK_ZOMBIE( m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE );
	CHECK_VARIANTBOOL( bLimitAvailableMemoryTo64MB );
	return m_spPropertyContainer->SetBoolProperty(XBOXIMAGEID_LimitAvailableMemoryTo64MB, bLimitAvailableMemoryTo64MB);
}

STDMETHODIMP CXboxImageTool::get_TitleID(long* pnTitleID)
{
	return ToolGetIntProperty(XBOXIMAGEID_TitleID, pnTitleID);
}

STDMETHODIMP CXboxImageTool::put_TitleID(long nTitleID)
{
	CHECK_ZOMBIE( m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE );
	return m_spPropertyContainer->SetIntProperty(XBOXIMAGEID_TitleID, nTitleID);
}

STDMETHODIMP CXboxImageTool::get_XboxGameRegion(long* pnXboxGameRegion)
{
	return ToolGetIntProperty(XBOXIMAGEID_XboxGameRegion, pnXboxGameRegion);
}

STDMETHODIMP CXboxImageTool::put_XboxGameRegion(long nXboxGameRegion)
{
	CHECK_ZOMBIE( m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE );
	return m_spPropertyContainer->SetIntProperty(XBOXIMAGEID_XboxGameRegion, nXboxGameRegion);
}


STDMETHODIMP CXboxImageTool::get_XboxGameRating(enumXboxGameRating* peXboxGameRating)
{
	return ToolGetIntProperty(XBOXIMAGEID_XboxGameRating, (long *)peXboxGameRating);
}

STDMETHODIMP CXboxImageTool::put_XboxGameRating(enumXboxGameRating eXboxGameRating)
{
	CHECK_ZOMBIE( m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE );
	CHECK_BOUNDS(XboxGameRatingMin, XboxGameRatingMax, eXboxGameRating);
	return m_spPropertyContainer->SetIntProperty(XBOXIMAGEID_XboxGameRating, eXboxGameRating);
}

STDMETHODIMP CXboxImageTool::get_TitleInfo(BSTR* pbstrTitleInfo)
{
	return ToolGetStrProperty(XBOXIMAGEID_TitleInfo, pbstrTitleInfo);
}

STDMETHODIMP CXboxImageTool::put_TitleInfo(BSTR bstrTitleInfo)
{
	CHECK_ZOMBIE( m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE );
	return m_spPropertyContainer->SetStrProperty(XBOXIMAGEID_TitleInfo, bstrTitleInfo);
}

STDMETHODIMP CXboxImageTool::get_TitleName(BSTR* pbstrTitleName)
{
	return ToolGetStrProperty(XBOXIMAGEID_TitleName, pbstrTitleName);
}

STDMETHODIMP CXboxImageTool::put_TitleName(BSTR bstrTitleName)
{
	CHECK_ZOMBIE( m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE );
	return m_spPropertyContainer->SetStrProperty(XBOXIMAGEID_TitleName, bstrTitleName);
}

STDMETHODIMP CXboxImageTool::get_TitleImage(BSTR* pbstrTitleImage)
{
	return ToolGetStrProperty(XBOXIMAGEID_TitleImage, pbstrTitleImage);
}

STDMETHODIMP CXboxImageTool::put_TitleImage(BSTR bstrTitleImage)
{
	CHECK_ZOMBIE( m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE );
	return m_spPropertyContainer->SetStrProperty(XBOXIMAGEID_TitleImage, bstrTitleImage);
}

STDMETHODIMP CXboxImageTool::get_SaveGameImage(BSTR* pbstrSaveGameImage)
{
	return ToolGetStrProperty(XBOXIMAGEID_SaveGameImage, pbstrSaveGameImage);
}

STDMETHODIMP CXboxImageTool::put_SaveGameImage(BSTR bstrSaveGameImage)
{
	CHECK_ZOMBIE( m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE );
	return m_spPropertyContainer->SetStrProperty(XBOXIMAGEID_SaveGameImage, bstrSaveGameImage);
}

#if 0

STDMETHODIMP CXboxImageTool::get_SuppressStartupBanner(VARIANT_BOOL* pbNoLogo)
{	// (/NOLOGO) enable suppression of copyright message (no explicit off)
	return ToolGetBoolProperty(XBOXIMAGEID_SuppressStartupBanner, pbNoLogo);
}

STDMETHODIMP CXboxImageTool::put_SuppressStartupBanner(VARIANT_BOOL bNoLogo)
{
	CHECK_ZOMBIE( m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE );
	CHECK_VARIANTBOOL( bNoLogo );
	return m_spPropertyContainer->SetBoolProperty(XBOXIMAGEID_SuppressStartupBanner, bNoLogo);
}

#endif

// Automation properties
STDMETHODIMP CXboxImageTool::get_ToolPath(BSTR *pVal)
{
	CHECK_ZOMBIE( m_spPropertyContainer, IDS_ERR_TOOL_ZOMBIE );
	CHECK_POINTER_VALID(pVal);
	*pVal = SysAllocString( szXboxImageToolPath );
	return S_OK;
}

/*********************************************************************/

STDMETHODIMP CXboxImageGeneralPage::get_AdditionalOptions(BSTR* pbstrAdditionalOptions)
{	// anything we don't know what to do with, given verbatim, in same order as entered, parent contributions first, goes after all other options
	return ToolGetStrProperty(XBOXIMAGEID_AdditionalOptions, &(CXboxImageTool::s_optHandler), pbstrAdditionalOptions);
}

STDMETHODIMP CXboxImageGeneralPage::put_AdditionalOptions(BSTR bstrAdditionalOptions)
{
	return SetStrProperty(XBOXIMAGEID_AdditionalOptions, bstrAdditionalOptions);
}

STDMETHODIMP CXboxImageGeneralPage::get_FileName(BSTR* pbstrFileName)
{	// (/OUT:[file]) change the output file name (default is based on 1st lib or obj name on cmd line)
	return ToolGetStrProperty(XBOXIMAGEID_FileName, &(CXboxImageTool::s_optHandler), pbstrFileName);
}

STDMETHODIMP CXboxImageGeneralPage::put_FileName(BSTR bstrFileName)
{
	return SetStrProperty(XBOXIMAGEID_FileName, bstrFileName);
}

STDMETHODIMP CXboxImageGeneralPage::get_XBEFlags(long* pnFlags)
{
	return ToolGetIntProperty(XBOXIMAGEID_XBEFlags, &(CXboxImageTool::s_optHandler), pnFlags);
}

STDMETHODIMP CXboxImageGeneralPage::put_XBEFlags(long nFlags)
{
	return SetIntProperty(XBOXIMAGEID_XBEFlags, nFlags);
}

STDMETHODIMP CXboxImageGeneralPage::get_StackSize(long* pnStackSize)
{
	return ToolGetIntProperty(XBOXIMAGEID_StackSize, &(CXboxImageTool::s_optHandler), pnStackSize);
}

STDMETHODIMP CXboxImageGeneralPage::put_StackSize(long nStackSize)
{
	return SetIntProperty(XBOXIMAGEID_StackSize, nStackSize);
}

STDMETHODIMP CXboxImageGeneralPage::get_IncludeDebugInfo(enumBOOL* pbIncludeDebugInfo)
{	// ignore export lib
	return GetEnumBoolProperty(XBOXIMAGEID_IncludeDebugInfo, pbIncludeDebugInfo);
}

STDMETHODIMP CXboxImageGeneralPage::put_IncludeDebugInfo(enumBOOL bIncludeDebugInfo)
{
	return SetBoolProperty(XBOXIMAGEID_IncludeDebugInfo, bIncludeDebugInfo);
}

STDMETHODIMP CXboxImageGeneralPage::get_LimitAvailableMemoryTo64MB(enumBOOL* pbLimitAvailableMemoryTo64MB)
{	// ignore export lib
	return GetEnumBoolProperty(XBOXIMAGEID_LimitAvailableMemoryTo64MB, pbLimitAvailableMemoryTo64MB);
}

STDMETHODIMP CXboxImageGeneralPage::put_LimitAvailableMemoryTo64MB(enumBOOL bLimitAvailableMemoryTo64MB)
{
	return SetBoolProperty(XBOXIMAGEID_LimitAvailableMemoryTo64MB, bLimitAvailableMemoryTo64MB);
}

void CXboxImageGeneralPage::GetBaseDefault(long id, CComVariant& varValue)
{
	MessageBox(NULL,L"CXboxImageGeneralPage::GetBaseDefault",0,0);
	switch (id)
	{
	case XBOXIMAGEID_FileName:
		{
			CComBSTR bstrVal;
			CXboxImageTool::s_optHandler.GetDefaultValue( id, &bstrVal, m_pContainer );
			if (!bstrVal)
				bstrVal = L"";
			varValue = bstrVal;
		}
		break;
#if 0
	case XBOXIMAGEID_SuppressStartupBanner:
		{
			VARIANT_BOOL bVal;
			CXboxImageTool::s_optHandler.GetDefaultValue( id, &bVal );
			varValue = bVal;
		}
		break;
#endif
	default:
		CBase::GetBaseDefault(id, varValue);
	}
}

// XBox Image Certifacte Page

STDMETHODIMP CXboxImageCertificatePage::get_TitleID(long* pnTitleID)
{
	return ToolGetIntProperty(XBOXIMAGEID_TitleID, &(CXboxImageTool::s_optHandler), pnTitleID);
}

STDMETHODIMP CXboxImageCertificatePage::put_TitleID(long nTitleID)
{
	return SetIntProperty(XBOXIMAGEID_TitleID, nTitleID);
}

STDMETHODIMP CXboxImageCertificatePage::get_XboxGameRegion(long* pnXboxGameRegion)
{
	return ToolGetIntProperty(XBOXIMAGEID_XboxGameRegion, &(CXboxImageTool::s_optHandler), pnXboxGameRegion);
}

STDMETHODIMP CXboxImageCertificatePage::put_XboxGameRegion(long nXboxGameRegion)
{
	return SetIntProperty(XBOXIMAGEID_XboxGameRegion, nXboxGameRegion);
}

STDMETHODIMP CXboxImageCertificatePage::get_XboxGameRating(enumXboxGameRating* pnXboxGameRating)
{
	return ToolGetIntProperty(XBOXIMAGEID_XboxGameRating, &(CXboxImageTool::s_optHandler), (long*) pnXboxGameRating);
}

STDMETHODIMP CXboxImageCertificatePage::put_XboxGameRating(enumXboxGameRating nXboxGameRating)
{
	CHECK_BOUNDS(XboxGameRatingMin, XboxGameRatingMax, nXboxGameRating);
	return SetIntProperty(XBOXIMAGEID_XboxGameRating, nXboxGameRating);
}

// XBox Image Title Info Page

STDMETHODIMP CXboxImageTitleInfoPage::get_TitleInfo(BSTR* pbstrTitleInfo)
{
	return ToolGetStrProperty(XBOXIMAGEID_TitleInfo, &(CXboxImageTool::s_optHandler), pbstrTitleInfo);
}

STDMETHODIMP CXboxImageTitleInfoPage::put_TitleInfo(BSTR bstrTitleInfo)
{
	return SetStrProperty(XBOXIMAGEID_TitleInfo, bstrTitleInfo);
}

STDMETHODIMP CXboxImageTitleInfoPage::get_TitleName(BSTR* pbstrTitleName)
{
	return ToolGetStrProperty(XBOXIMAGEID_TitleName, &(CXboxImageTool::s_optHandler), pbstrTitleName);
}

STDMETHODIMP CXboxImageTitleInfoPage::put_TitleName(BSTR bstrTitleName)
{
	return SetStrProperty(XBOXIMAGEID_TitleName, bstrTitleName);
}

STDMETHODIMP CXboxImageTitleInfoPage::get_TitleImage(BSTR* pbstrTitleImage)
{
	return ToolGetStrProperty(XBOXIMAGEID_TitleImage, &(CXboxImageTool::s_optHandler), pbstrTitleImage);
}

STDMETHODIMP CXboxImageTitleInfoPage::put_TitleImage(BSTR bstrTitleImage)
{
	return SetStrProperty(XBOXIMAGEID_TitleImage, bstrTitleImage);
}

STDMETHODIMP CXboxImageTitleInfoPage::get_SaveGameImage(BSTR* pbstrSaveGameImage)
{
	return ToolGetStrProperty(XBOXIMAGEID_SaveGameImage, &(CXboxImageTool::s_optHandler), pbstrSaveGameImage);
}

STDMETHODIMP CXboxImageTitleInfoPage::put_SaveGameImage(BSTR bstrSaveGameImage)
{
	return SetStrProperty(XBOXIMAGEID_SaveGameImage, bstrSaveGameImage);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\projbld\vcpb\XMLFile.h ===
// XMLFile.h : Declaration of the CXMLFile

#ifndef __XMLFILE_H_
#define __XMLFILE_H_

/////////////////////////////////////////////////////////////////////////////
// CXMLFile
class ATL_NO_VTABLE CXMLFile : 
	public CComObjectRoot,
	IVCXMLFile,
	IStream
{
public:
	CXMLFile();
	~CXMLFile();

	static HRESULT CreateInstance( IVCXMLFile **ppXMLFile, LPCOLESTR szFilename, DWORD dwBufSize, LPCOLESTR szFileEncoding,
		enumFileFormat eFileFormat );
DECLARE_NO_REGISTRY()

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CXMLFile)
	COM_INTERFACE_ENTRY(IVCXMLFile)
	COM_INTERFACE_ENTRY(IStream)
END_COM_MAP()

// IVCXMLFile
public:
	STDMETHOD(Initialize)( LPCOLESTR szFilename, DWORD dwBufSize, LPCOLESTR szFileEncoding );

// IStream
public:
    STDMETHOD(Read)(void *pv, ULONG cb, ULONG *pcbRead);
    STDMETHOD(Write)(void const *pv, ULONG cb, ULONG *pcbWritten);
    STDMETHOD(Seek)(LARGE_INTEGER dlibMove, DWORD dwOrigin, ULARGE_INTEGER *plibNewPosition);
    STDMETHOD(SetSize)(ULARGE_INTEGER libNewSize);
    STDMETHOD(CopyTo)(IStream *pstm, ULARGE_INTEGER cb, ULARGE_INTEGER *pcbRead, ULARGE_INTEGER *pcbWritten);
    STDMETHOD(Commit)(DWORD grfCommitFlags);
    STDMETHOD(Revert)();
    STDMETHOD(LockRegion)(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType);
    STDMETHOD(UnlockRegion)(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType);
    STDMETHOD(Stat)(STATSTG *pstatstg, DWORD grfStatFlag);
    STDMETHOD(Clone)(IStream **ppstm);

private:
	FILE *m_file;					// file pointer
	CComBSTR m_bstrFilename;		// filename
	DWORD m_dwBufSize;				// buffer size
	char *m_pBuf;					// buffer
	DWORD m_dwBytesInBuffer;		// bytes contained in the buffer waiting to be flushed
	DWORD m_dwOffset;				// current read/write offset
	CComBSTR m_bstrFileEncoding;	// file format to write

public:
	static int DetermineDefaultCodePage();
	static void DetermineDefaultFileEncoding(CComBSTR& bstrEncoding);
	static void AdjustFileFormatForFileEncoding(LPCOLESTR szOldEncoding, LPCOLESTR szNewEncoding, enumFileFormat& eFormat,
		BOOL bForce = FALSE);
	static void AdjustFileEncodingForFileFormat(enumFileFormat eOldFormat, enumFileFormat eNewFormat, CComBSTR& bstrEncoding,
		BOOL bForce = FALSE);
};

#endif //__XMLFILE_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\pkgs\vcpkg\ui\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by D:\vs\src\vc\ide\pkgs\vcpkg\src\vc.rc
//
#define EXTENTION_CPP_INDEX             0
#define EXTENTION_C_INDEX               1
#define EXTENTION_H_INDEX               2
#define EXTENTION_IDL_INDEX             3
#define EXTENTION_RES_INDEX             4
#define EXTENTION_ALL_INDEX             5
#define EXTENTION_TXT_INDEX             6
#define IDR_VCPKG                       102
#define IDS_PROD_NAME                   1000
#define IDS_PROD_DESC                   1001
#define IDB_IC                          1004
#define IDB_FASTTREECTL                 1005
#define IDB_EMPTYWORKSPACE              1006
#define IDB_WORKSPACE_ROOT              1007
#define IDB_CLSWELL                     1008
#define IDB_CANVAS_TEXTURE              1009
#define IDB_SPLASHSCREEN                1010
#define IDB_RESVIEW                     1011
#define IDB_ATLPERFMON                  1012
#define IDS_CPPSOURCEFILEITEMLABEL      1075
#define IDS_CPPSOURCEFILEITEMDESC       1076
#define IDS_CPPSOURCEFILEITEMBASENAME   1077
#define IDS_HFILEITEMLABEL              1078
#define IDS_HFILEITEMDESC               1079
#define IDI_IC                          1079
#define IDS_HFILEITEMBASENAME           1080
#define IDI_Taliesin                    1080
#define IDS_RGSFILEITEMLABEL            1081
#define IDI_ZDesigner                   1081
#define IDS_RGSFILEITEMDESC             1082
#define IDS_RGSFILEITEMBASENAME         1083
#define IDS_IDLFILEITEMLABEL            1084
#define IDS_IDLFILEITEMDESC             1085
#define IDS_IDLFILEITEMBASENAME         1086
#define IDS_DEFFILEITEMLABEL            1087
#define IDS_DEFFILEITEMDESC             1088
#define IDS_DEFFILEITEMBASENAME         1089
#define IDS_ADDCLASSLABEL               1090
#define IDS_ADDCLASSDESC                1091
#define IDS_ADDCLASSBASENAME            1092
#define IDS_ICOFILEITEMLABEL            1093
#define IDS_ICOFILEITEMDESC             1094
#define IDS_ICOFILEITEMBASENAME         1095
#define IDS_CURFILEITEMLABEL            1096
#define IDS_CURFILEITEMDESC             1097
#define IDS_CURFILEITEMBASENAME         1098
#define IDS_BMPFILEITEMLABEL            1099
#define IDS_BMPFILEITEMDESC             1100
#define IDS_BMPFILEITEMBASENAME         1101
#define IDS_RCFILEITEMLABEL             1102
#define IDS_RCFILEITEMDESC              1103
#define IDS_RCFILEITEMBASENAME          1104
#define IDS_DESIGNSURFACEFILEITEMLABEL  1105
#define IDS_DESIGNSURFACEFILEITEMDESC   1106
#define IDS_DESIGNSURFACEFILEITEMBASENAME 1107
#define IDS_SRFSOURCEFILEITEMLABEL      1108
#define IDS_SRFSOURCEFILEITEMDESC       1109
#define IDS_SRFSOURCEFILEITEMBASENAME   1110
#define IDS_TXTFILEITEMLABEL            1111
#define IDS_TXTFILEITEMDESC             1112
#define IDS_TXTFILEITEMBASENAME         1113
#define IDS_BINFILEITEMLABEL            1114
#define IDS_BINFILEITEMDESC             1115
#define IDS_BINFILEITEMBASENAME         1116
#define IDS_RCTFILEITEMLABEL            1117
#define IDS_RCTFILEITEMDESC             1118
#define IDS_RCTFILEITEMBASENAME         1119
#define IDS_SQLFILEITEMLABEL            1120
#define IDS_SQLFILEITEMDESC             1121
#define IDS_SQLFILEITEMBASENAME         1122
#define IDS_ADDCLASS_BASENAME           1123
#define IDS_ADD_ATL_TO_MFC_LABEL        1124
#define IDS_ADD_ATL_TO_MFC_DESC         1125
#define IDS_ADD_ATL_ASPCOMPONENT_LABEL  1126
#define IDS_ADD_ATL_ASPCOMPONENT_DESC   1127
#define IDS_ADD_ATL_ACTIVEX_CONTROL_LABEL 1128
#define IDS_ADD_ATL_ACTIVEX_CONTROL_DESC 1129
#define IDS_ADD_ATL_DLG_CLASS_LABEL     1130
#define IDS_ADD_ATL_DLG_CLASS_DESC      1131
#define IDS_ADD_ATL_MMC_SNAPIN_LABEL    1132
#define IDS_ADD_ATL_MMC_SNAPIN_DESC     1133
#define IDS_ADD_ATL_MTS_COMPONENT_LABEL 1134
#define IDS_ADD_ATL_MTS_COMPONENT_DESC  1135
#define IDS_ADD_ATL_OLEDB_CONSUMER_LABEL 1136
#define IDS_ADD_ATL_OLEDB_CONSUMER_DESC 1137
#define IDS_ADD_ATL_OLEDB_PROVIDER_LABEL 1138
#define IDS_ADD_ATL_OLEDB_PROVIDER_DESC 1139
#define IDS_ADD_ATL_PROPERTY_PAGE_OBJECT_LABEL 1140
#define IDS_ADD_ATL_PROPERTY_PAGE_OBJECT_DESC 1141
#define IDS_ADD_ATL_SIMPLE_OBJECT_LABEL 1142
#define IDS_ADD_ATL_SIMPLE_OBJECT_DESC  1143
#define IDS_ADD_PERF_MONITOR_OBJECT_LABEL 1144
#define IDS_ADD_PERF_MONITOR_OBJECT_DESC 1145
#define IDS_ADD_GENERIC_CLASS_LABEL     1146
#define IDS_ADD_GENERIC_CLASS_DESC      1147
#define IDS_ADD_MFC_CLASS_LABEL         1148
#define IDS_ADD_MFC_CLASS_DESC          1149
#define IDS_ADD_MFC_ODBC_CONSUMER_CLASS_LABEL 1150
#define IDS_ADD_MFC_ODBC_CONSUMER_CLASS_DESC 1151
#define IDS_ADD_MFC_CLASS_FROM_TYPELIB_LABEL 1152
#define IDS_ADD_MFC_CLASS_FROM_TYPELIB_DESC 1153
#define IDS_APPWIZ_BASENAME             1154
#define IDS_ATL_PROJECT_LABEL           1155
#define IDS_ATL_PROJECT_DESC            1156
#define IDS_ATL_SERVER_PROJECT_LABEL    1157
#define IDS_ATL_SERVER_PROJECT_DESC     1158
#define IDS_ATL_SERVER_WEB_SERVICE_PROJECT_LABEL 1159
#define IDS_ATL_SERVER_WEB_SERVICE_PROJECT_DESC 1160
#define IDS_MFC_APPLICATION_PROJECT_LABEL 1161
#define IDS_MFC_APPLICATION_PROJECT_DESC 1162
#define IDS_MFC_DLL_PROJECT_LABEL       1163
#define IDS_MFC_DLL_PROJECT_DESC        1164
#define IDS_MFC_ACTIVEX_CONTROL_PROJECT_LABEL 1165
#define IDS_MFC_ACTIVEX_CONTROL_PROJECT_DESC 1166
#define IDS_MFC_ISAPI_EXTENSION_PROJECT_LABEL 1167
#define IDS_MFC_ISAPI_EXTENSION_PROJECT_DESC 1168
#define IDS_EXTENDED_STORED_PROCEDURE_PROJECT_LABEL 1169
#define IDS_EXTENDED_STORED_PROCEDURE_PROJECT_DESC 1170
#define IDS_WIN32_PROJECT_LABEL         1171
#define IDS_WIN32_PROJECT_DESC          1172
#define IDS_MANAGED_CPP_APP_PROJECT_LABEL 1173
#define IDS_MANAGED_CPP_APP_PROJECT_DESC 1174
#define IDS_MANAGED_CPP_CLASS_LIB_PROJECT_LABEL 1175
#define IDS_MANAGED_CPP_CLASS_LIB_PROJECT_DESC 1176
#define IDS_MANAGED_CPP_EMPTY_PROJECT_LABEL 1177
#define IDS_MANAGED_CPP_EMPTY_PROJECT_DESC 1178
#define IDS_MANAGED_CPP_WEB_SVC_PROJECT_LABEL 1179
#define IDS_MANAGED_CPP_WEB_SVC_PROJECT_DESC 1180
#define IDS_CUSTOM_APPWIZARD_LABEL      1181
#define IDS_CUSTOM_APPWIZARD_DESC       1182
#define IDS_MAKEFILE_PROJECT_LABEL      1183
#define IDS_MAKEFILE_PROJECT_DESC       1184
#define IDS_VCCOMPLUS20                 1185
#define IDS_WIN32                       1186
#define IDS_UTILITY                     1187
#define IDS_ADDWEBSVCFILEEITEMLABEL     1188
#define IDS_ADDWEBSVCFILEITEMDESC       1189
#define IDS_ADDWEBSVCFILEITEMBASENAME   1190
#define IDS_ADDMCWEBSVCFILEEITEMLABEL   1191
#define IDS_ADDMCWEBSVCFILEITEMDESC     1192
#define IDS_ADDMCWEBSVCFILEITEMBASENAME 1193
#define IDS_WMI_EVENTPROV_WIZARD_LABEL  1194
#define IDS_WMI_EVENTPROV_WIZARD_DESC   1195
#define IDS_WMI_INSTPROV_WIZARD_LABEL   1196
#define IDS_WMI_INSTPROV_WIZARD_DESC    1197
#define IDS_ADD_MFC_CLASS_FROM_AXCONTROL_LABEL 1198
#define IDS_ADD_MFC_CLASS_FROM_AXCONTROL_DESC 1199
#define IDS_STATDISCOFILEITEMLABEL      1200
#define IDS_STATDISCOFILEITEMDESC       1201
#define IDS_STATDISCOFILEITEMBASENAME   1202
#define IDS_DYNDISCOFILEITEMLABEL       1203
#define IDS_DYNDISCOFILEITEMDESC        1204
#define IDS_DYNDISCOFILEITEMBASENAME    1205
#define IDS_HTMLFILEITEMLABEL           1206
#define IDS_HTMLFILEITEMDESC            1207
#define IDS_HTMLFILEITEMBASENAME        1208
#define IDS_ASPFILEITEMLABEL            1209
#define IDS_ASPFILEITEMDESC             1210
#define IDS_ASPFILEITEMBASENAME         1211
#define IDS_FRAMESETFILEITEMLABEL       1212
#define IDS_FRAMESETFILEITEMDESC        1213
#define IDS_FRAMESETFILEITEMBASENAME    1214
#define IDS_XMLFILEITEMLABEL            1215
#define IDS_XMLFILEITEMDESC             1216
#define IDS_XMLFILEITEMBASENAME         1217
#define IDS_CSSFILEITEMLABEL            1218
#define IDS_CSSFILEITEMDESC             1219
#define IDS_CSSFILEITEMBASENAME         1220
#define IDS_REGSVR32_NAME               1300
#define IDS_ERRLOOK_NAME                1301
#define IDS_TSTCON32_NAME               1302
#define IDS_XBOX_PROJECT_LABEL          1380
#define IDS_XBOX_PROJECT_DESC           1381
#define ID_EDIT_FILTER                  3001
#define ID_NEW_FILTER                   3002
#define ID_APPLY_FILTER                 3003
#define IDC_FOLDER_NAME                 3004
#define IDC_AVAILABLE_ATTRIBUTES        3005
#define IDC_GROUP_ATTRIBUTES            3006
#define IDC_GROUP_ARGUMENTS             3007
#define IDC_GROUP_BASES                 3008
#define IDC_GROUP_CLASSES               3009
#define IDC_GROUP_ENUMS                 3010
#define IDC_GROUP_ENUM_ITEMS            3011
#define IDC_GROUP_INTERFACES            3012
#define IDC_GROUP_MACROS                3013
#define IDC_GROUP_MAPS                  3014
#define IDC_GROUP_MAP_ITEMS             3015
#define IDC_GROUP_METHODS               3016
#define IDC_GROUP_TYPEDEFS              3017
#define IDC_GROUP_VARIABLES             3018
#define IDC_GROUP_UNIONS                3019
#define IDC_GROUP_STRUCTS               3020
#define IDC_GROUP_PARAMETERS            3021
#define IDC_GROUP_NAMESPACES            3022
#define IDC_GROUP_PROJECTS              3023
#define IDC_SHOW_INJECTED_ITEMS         3024
#define IDB_DAVEWAGON                   3025
#define IDC_EMULATE_VC60_CLASSVIEW      3025
#define IDB_PANEGLYPH_BITMAP            3026
#define IDS_PANE_NAME                   3027
#define IDS_UNDO_ADD_FOLDER             3028
#define IDS_FOLDER                      3029
#define IDS_WARNING                     3030
#define IDS_FolderDO                    3031
#define IDS_ImplementedInterfacesDO     3032
#define IDS_DUPLICATE_FOLDER_NAME       3033
#define IDS_INVALID_FOLDER_NAME         3034
#define IDI_ProjectDO                   3037
#define IDC_DD_SINGLEMOVE               3038
#define IDC_DD_SINGLECOPY               3039
#define IDC_DD_MULTIMOVE                3040
#define IDC_DD_MULTICOPY                3041
#define IDS_WorkspaceDO                 3045
#define IDI_WorkspaceDO                 3046
#define IDS_WorkspaceDO2                3047
#define IDS_ProjectDO                   3048
#define IDD_CLASSVIEW_NEW_CLASS_SUBFOLDER 3049
#define IDI_FolderDO                    3050
#define IDD_ADDATTRIBUTE                3051
#define IDI_Filter                      3052
#define IDI_Protected                   3053
#define IDI_Private                     3054
#define IDD_SET_FILTER                  3055
#define IDI_Link                        3056
#define IDD_NEW_FILTER                  3057
#define IDI_TeamFolder                  3058
#define IDD_RESOLVEAMBIGUITY            3058
#define IDI_InactiveFilter              3059
#define IDI_ImplementedInterfacesDO     3060
#define IDI_LinkZombie                  3061
#define IDC_EXISTING_ATTRIBUTES         3062
#define IDC_FILTER_LIST                 3063
#define IDC_NEW_FILTER_NAME             3064
#define IDC_BUTTON_ADD                  3065
#define IDC_BUTTON_REMOVE               3066
#define IDC_IMPLEMENTS                  3067
#define IDC_AVAILABLE                   3068
#define IDC_ATTRINFO                    3069
#define IDD_OPTIONS_CLASSVIEW           3070
#define IDC_KRBRACE                     3071
#define IDC_AUTO_QUICKINFO              3072
#define IDC_OUTLININGON                 3073
#define IDC_INDENTBRACES                3074
#define IDD_TOOLS_OPTIONS_PAGE          3080
#define IDI_ASPPAGE                     4500
#define IDI_FRAMESET                    4501
#define IDI_HTMLFILE                    4502
#define IDI_STYLESHEET                  4544
#define IDS_CRT_LIBNAME_PROJECT         5000
#define IDS_CRT_LIBNAME_REFERENCES      5001
#define IDS_ATLEDO                      6000
#define IDS_COMClassEDO                 6001
#define IDS_ClassDO                     6002
#define IDS_FunctionDO                  6003
#define IDS_VariableDO                  6004
#define IDS_PropertyDO                  6005
#define IDS_NamespaceDO                 6006
#define IDS_ParameterDO                 6007
#define IDS_AttributeDO                 6008
#define IDS_InterfaceDO                 6009
#define IDS_EnumDO                      6010
#define IDS_StructDO                    6011
#define IDS_UnionDO                     6012
#define IDS_TypedefDO                   6013
#define IDS_IncludeDirective            6014
#define IDS_MacroDO                     6015
#define IDS_MapDO                       6016
#define IDS_ImportDirective             6017
#define IDS_IDL_Import                  6018
#define IDS_CoClass                     6019
#define IDS_IDL_Library                 6020
#define IDS_ImportStatement             6021
#define IDS_UsingStatement              6022
#define IDS_MapItemDO                   6023
#define IDS_EnumItemDO                  6024
#define IDS_FileDO                      6026
#define IDS_ConstantDO                  6027
#define IDS_CollectionDO                6028
#define IDS_Classes                     6029
#define IDS_Attributes                  6030
#define IDS_Constants                   6031
#define IDS_Enums                       6032
#define IDS_EnumItems                   6033
#define IDS_Files                       6034
#define IDS_Interfaces                  6035
#define IDS_Macros                      6036
#define IDS_Maps                        6037
#define IDS_MapEntries                  6038
#define IDS_Functions                   6039
#define IDS_Namespaces                  6040
#define IDS_Parameters                  6041
#define IDS_Typedefs                    6042
#define IDS_Unions                      6043
#define IDS_Variables                   6044
#define IDS_BaseDO                      6045
#define IDS_Bases                       6046
#define IDS_GlobalNamespaceDO           6047
#define IDS_ArgumentDO                  6048
#define IDS_Arguments                   6065
#define IDS_PROPCAT_CPP                 6066
#define IDS_PROPCAT_MODULE              6067
#define IDS_PROPCAT_INTERFACE           6068
#define IDS_PROPCAT_COM                 6069
#define IDS_PROPCAT_CONTROL             6070
#define IDS_PROPCAT_WINDOW              6071
#define IDS_PROPCAT_DBCLIENT            6072
#define IDS_PROPCAT_DBSERVER            6073
#define IDS_PROPCAT_STOCKPROPS          6074
#define IDI_VariableDO                  6075
#define IDI_FileDO                      6076
#define IDS_Structs                     6076
#define IDI_AttributeDO                 6077
#define IDS_PROPCAT_REGISTRY            6077
#define IDI_UnionDO                     6078
#define IDS_PROPCAT_INTERNALDEBUG       6078
#define IDI_MapDO                       6079
#define IDI_MapItemDO                   6080
#define IDI_EnumDO                      6081
#define IDS_ObjectModelDO               6081
#define IDI_EnumItemDO                  6082
#define IDS_ObjectModels                6082
#define IDI_MethodDO                    6083
#define IDS_Tables                      6083
#define IDI_ClassDO                     6084
#define IDS_Procedures                  6084
#define IDI_TypedefDO                   6085
#define IDS_DatabaseDO                  6085
#define IDI_InterfaceDO                 6086
#define IDS_TableDO                     6086
#define IDI_NamespaceDO                 6087
#define IDS_ProcedureDO                 6087
#define IDI_MacroDO                     6088
#define IDS_CreatorDO                   6088
#define IDI_ParameterDO                 6089
#define IDS_Creators                    6089
#define IDI_CollectionDO                6090
#define IDS_PROPCAT_COMPLUS             6090
#define IDI_GlobalNamespaceDO           6091
#define IDS_PROPCAT_COMPILER            6091
#define IDI_Attributes                  6092
#define IDS_PROPCAT_IDL                 6092
#define IDI_BaseDO                      6093
#define IDS_PROPCAT_USERDEFINED         6093
#define IDI_Variables                   6094
#define IDS_PROPCAT_DHTML               6094
#define IDI_Unions                      6095
#define IDS_PROPCAT_ATTRIBUTE           6095
#define IDI_Typedefs                    6096
#define IDS_Miscellaneous               6096
#define IDI_Parameters                  6097
#define IDS_IncludeDirectives           6097
#define IDI_Namespaces                  6098
#define IDS_UsingDirectives             6098
#define IDI_Methods                     6099
#define IDS_ImportDirectives            6099
#define IDI_MapItems                    6100
#define IDS_ImportStatements            6100
#define IDI_Maps                        6101
#define IDS_ImportLibStatements         6101
#define IDI_Macros                      6102
#define IDS_CoClasses                   6102
#define IDI_Interfaces                  6103
#define IDS_Libraries                   6103
#define IDI_EnumItems                   6104
#define IDS_Delegates                   6104
#define IDI_Enums                       6105
#define IDS_Properties                  6105
#define IDI_Classes                     6106
#define IDS_Events                      6106
#define IDI_Bases                       6107
#define IDI_StructDO                    6108
#define IDI_Structs                     6109
#define IDS_OBJECT_TYPE_MSG             6110
#define IDI_IncludeDO                   6111
#define IDI_ImportDO                    6112
#define IDI_UsingDO                     6113
#define IDI_IDLImportDO                 6114
#define IDI_IDLImportLibDO              6115
#define IDI_IDLCoClassDO                6116
#define IDI_IDLLibraryDO                6117
#define IDI_DialogClass                 6118
#define IDS_E_OPERATOR_UNARY_BINARAY_ONLY 6125
#define IDS_E_OPERATOR_MEMBER_UNARY_BINARAY_ONLY 6126
#define IDI_ADDCLASS                    6128
#define IDS_E_CM_NEW_CE_FAILED          6130
#define IDS_E_CM_OPERATION_FAILED       6131
#define IDS_E_OBJECT_EXISTS             6132
#define IDS_E_PROPERTYGET_EXISTS        6133
#define IDS_E_PROPERTYPUT_EXISTS        6134
#define IDS_E_OBJECT_TYPE_INVALID       6135
#define IDS_E_CREATION_FAIL             6140
#define IDS_E_DUP_BASE_CLASS            6141
#define IDS_E_MEMBER_CONFLICTS          6142
#define IDS_E_MEMBER_NOT_FOUND          6143
#define IDS_E_PARSE_INVALID_TOKEN       6144
#define IDS_E_FUNC_NAME_FIXED           6145
#define IDS_E_INVALID_ATTRIBUTE         6146
#define IDS_E_REQUIRED_ATTRIBUTE        6147
#define IDS_E_INTERFACE_METHOD_TYPE     6148
#define IDS_E_VALUE_NOT_PERMITTED       6149
#define IDS_E_VALUE_CANNOT_ERASE        6150
#define IDS_E_ITEM_NOT_FOUND            6151
#define IDS_E_CM_DERIVEDMUSTIMPLEMENT   6152
#define IDS_E_CM_POSTPONED              6153
#define IDS_E_CANNOT_FIND_PROJECT       6154
#define IDS_E_RENAME_CTOR_DTOR          6155
#define IDS_E_INTRINSIC_NAME            6156
#define IDS_E_CREATE_FILE               6157
#define IDS_E_ACCESS_FILE               6158
#define IDS_E_CM_FILE_NOT_IN_PROJECT    6159
#define IDS_E_OPEN_DOCUMENT             6160
#define IDS_E_FIND_OBJECT_LOCATION      6161
#define IDS_E_TRANSACTION_RO_FILES      6162
#define IDS_E_INVALID_IDENTIFIER_NAME   6170
#define IDS_E_EMPTY_IDENTIFIER_NAME     6171
#define IDS_E_SPACESIN_IDENTIFIER_NAME  6172
#define IDS_E_ILLEGALCHARS_IDENTIFIER   6173
#define IDS_E_IDENTIFIER_TO_LONG        6174
#define IDS_E_NONTYPE_KEYWORD           6176
#define IDS_E_EMPTY_TYPE_NAME           6177
#define IDS_E_INVALID_TYPE_NAME         6178
#define IDS_E_INVALID_CSTYLE_TYPE       6179
#define IDS_E_INVALID_CE_NAME           6180
#define IDS_INVALID_PATHNAME            6181
#define IDS_E_PARAM_NOT_IN_DESTRUCTOR   6182
#define IDS_E_INVALID_PARAMETER         6183
#define IDS_E_OVERLOAD_FUNC_EXIST       6184
#define IDS_E_EMPTY_FILE_NAME           6185
#define IDS_E_FNAME_INVALID_CHARS       6186
#define IDS_E_FNAME_TO_LONG             6187
#define IDS_E_INVALID_PATHNAME          6188
#define IDS_E_INVALID_FTYPE             6189
#define IDS_E_INVALID_HTMLFTYPE         6190
#define IDS_E_RESERVED_NAME             6191
#define IDS_E_RESERVED_FUNCTION_NAME    6192
#define IDS_E_RESERVED_VARIABLE_NAME    6193
#define IDS_E_RESERVED_MACRO_NAME       6194
#define IDS_E_RESERVED_TYPEDEF_NAME     6195
#define IDS_E_RESERVED_STRUCNAM_NAME    6196
#define IDS_E_RESERVED_ENUMNAM_NAME     6197
#define IDS_E_RESERVED_ENUMMEM_NAME     6198
#define IDS_E_RESERVED_UNION_NAME       6199
#define IDS_E_RESERVED_CLASS_NAME       6200
#define IDS_E_RESERVED_TEMPLATE_NAME    6201
#define IDS_E_RESERVED_NAMESPACE_NAME   6202
#define IDS_E_RESERVED_ATTRIBUTE_NAME   6203
#define IDS_E_RESERVED_INTERFACE_NAME   6204
#define IDS_E_RENAME_MAP                6205
#define IDS_E_FNAME_REQUIRED            6206
#define IDS_E_PARAMS_IN_DTOR            6207
#define IDS_E_CTOR_DTOR_RETURN          6208
#define IDS_E_INVALID_QUALIFIED_NAME    6209
#define IDS_E_INVALID_SOURCE_FILE       6210
#define IDS_E_INVALID_IMPL_FTYPE        6211
#define IDS_E_EMPTY_OPERATOR_NAME       6220
#define IDS_E_INVALID_OPERATOR_NAME     6221
#define IDS_E_OPERATOR_VOID_PARAM       6222
#define IDS_E_OPERATOR_GLOBAL_UNARY_ONLY 6223
#define IDS_E_OPERATOR_MEMBER_UNARY_ONLY 6224
#define IDS_E_OPERATOR_GLOBAL_BINARY_ONLY 6227
#define IDS_E_OPERATOR_MEMBER_BINARY_ONLY 6228
#define IDS_E_OPERATOR_MEMFUNC_ONLY     6229
#define IDS_VCCM_E_INVALID_BASE         6230
#define IDS_E_CTOR_CLASSSTRUCT_ONLY     6231
#define IDS_E_FIXED_HANDLER_NAME        6250
#define IDS_E_CANNOT_REN_HANDLER        6251
#define IDS_E_CANNOT_CHANGE_CLASS       6252
#define IDS_E_RESVIEW_LOADFAILED        6300
#define IDS_E_RESVIEW_ANOTHERVIEW       6301
#define IDS_CPOP_RESNODE_SAVE           6302
#define IDS_CPOP_RESNODE_SAVE_AS        6303
#define IDI_AboutBox                    8082
#define IDS_CPPINFO_DESC                9000
#define IDS_SYNTAX_KEYWORD              9001
#define IDS_SYNTAX_COMMENT              9002
#define IDS_SYNTAX_IDENTIFIER           9003
#define IDS_SYNTAX_STRING               9004
#define IDS_SYNTAX_NUMBER               9005
#define IDS_SYNTAX_OPERATOR             9006
#define IDS_SYNTAX_PPKEYWORD            9007
#define IDS_SYNTAX_USERKEYWORD          9008
#define IDS_SYNTAX_WIZARDCODE           9009
#define IDI_XMLFILE                     9009
#define IDS_USERTYPEFILE                9010
#define IDS_LANGUAGE                    9011
#define IDS_VC_SOURCES                  9013
#define IDS_VC_INCLUDES                 9014
#define IDS_VC_ALL                      9015
#define IDS_VC_COLLAPSE_BLOCK           9016
#define IDS_VC_COLLAPSE_ALL             9017
#define IDI_ADDItemHFile                9020
#define IDI_ADDItemCPPFile              9021
#define IDI_ADDItemRCFile               9022
#define IDI_ADDItemTxtFile              9023
#define IDI_RGSFILEITEM                 9024
#define IDI_IDLFILEITEM                 9025
#define IDI_DEFFILEITEM                 9026
#define IDI_BMPFILEITEM                 9027
#define IDI_ICOFILEITEM                 9028
#define IDI_CURFILEITEM                 9029
#define IDI_DESIGNSURFACEFILEITEM       9030
#define IDI_ADDItemSRFFile              9031
#define IDI_STDISCOFile                 9032
#define IDI_DYNDISCOFile                9033
#define IDS_ACTION_COMMENT              9216
#define IDS_ACTION_UNCOMMENT            9217
#define IDS_VCCM_ADD                    9218
#define IDS_VCCM_PUT_NAME               9219
#define IDS_ACTION_WIZARD_DEL           9220
#define IDS_ACTION_AUTOINDENT           9221
#define IDS_ACTION_WIZARD_CHANGE_ACCESS 9222
#define IDS_VCCM_PUT_TYPESTRING         9223
#define IDS_VCCM_ADDNAMESPACE           9224
#define IDS_VCCM_ADDCLASS               9225
#define IDS_VCCM_ADDSTRUCT              9226
#define IDS_VCCM_ADDUNION               9227
#define IDS_VCCM_ADDBASE                9228
#define IDS_VCCM_ADDINTERFACE           9229
#define IDS_VCCM_ADDFUNCTION            9230
#define IDS_VCCM_ADDMEMBERFN            9231
#define IDS_VCCM_ADDVARIABLE            9232
#define IDS_VCCM_ADDTYPEDEF             9233
#define IDS_VCCM_ADDMAP                 9234
#define IDS_VCCM_ADDENUM                9235
#define IDS_VCCM_ADDMACRO               9236
#define IDS_VCCM_ADDPARAMETER           9237
#define IDS_VCCM_ADDMAPITEM             9238
#define IDS_VCCM_ADDENUMITEM            9239
#define IDS_VCCM_ADDATTRIBUTE           9240
#define IDS_VCCM_ADDARGUMENT            9241
#define IDS_VCCM_PUT_VALUE              9242
#define IDS_VCCM_ADDINCLUDE             9243
#define IDS_VCCM_ADDIMPORT              9244
#define IDS_VCCM_ADDUSING               9245
#define IDS_VCCM_ADDIDLIMPORT           9246
#define IDS_VCCM_ADDIDLIMPORTLIB        9247
#define IDS_VCCM_PUT_COMMENT            9250
#define IDS_VCCM_PUT_BODYTEXT           9251
#define IDS_VCCM_PUT_DECLARATIONTEXT    9252
#define IDS_VCCM_PUT_ISCONSTANT         9253
#define IDS_VCCM_PUT_ISSHARED           9254
#define IDS_VCCM_PUT_MUSTIMPLEMENT      9255
#define IDS_VCCM_PUT_ISVIRTUAL          9256
#define IDS_VCCM_PUT_ISINLINE           9257
#define IDS_VCCM_PUT_ISMANAGED          9258
#define IDS_VCCM_PUT_ISABSTRACT         9259
#define IDS_VCCM_PUT_ISSEALED           9260
#define IDS_VCCM_PUT_ISVALUE            9261
#define IDS_VCCM_E_NCBUNAVAILABLE       9262
#define IDS_VCCM_E_NOTREADY             9263
#define IDS_VCCM_E_INLINE_MEMBER_WITH_FILE 9264
#define IDS_VCCM_E_PURE_MEMBER_WITH_FILE 9265
#define IDS_VCCM_E_COM_VIRTUAL_REDUNDANT 9266
#define IDS_VCCM_E_STATIC_COM_METHOD    9267
#define IDS_VCMB_ADDFUNCTION            9556
#define IDS_VCMB_DELFUNCTION            9557
#define IDS_PROJNAME                    10000
#define IDR_VCPACKAGE                   10001
#define IDS_VCFILENODE_DESC             10002
#define IDS_ADD_CLASS                   10003
#define IDS_VCFILE_DESC                 10004
#define IDS_VCGENERIC_DESC              10006
#define IDS_WIZARDNODE_DESC             10008
#define IDS_WIZARDTRANSACTION_DESC      10010
#define IDS_WIZARDENUM_DESC             10012
#define IDS_LANGNODES_DESC              10014
#define IDS_LANGUAGENODES_DESC          10016
#define IDS_LANGUAGENODES_DESC1         10018
#define IDS_WIZARDINTEGERS_DESC         10020
#define IDS_BSCCOLL_DESC                10022
#define IDS_LANGUAGEITEMS_DESC          10024
#define IDS_PRIVLANGITEMS_DESC          10026
#define IDS_BSCPERSISTENTITEM_DESC      10028
#define IDS_OLECOLLECTION_DESC          10030
#define IDC_PROJECT_NAME                10201
#define IDC_PROJECT_LOCATION            10202
#define IDR_PROJMENU                    10203
#define IDD_PROJECT_NEW                 10204
#define IDC_PLATFROMS                   10206
#define IDC_EDIT_PROJNAME               10207
#define IDC_EDIT_PROJLOCATION           10208
#define IDC_LIST_PLATFORMS              10209
#define IDR_VCPCCOMMANDTABLE            10211
#define IDR_VCPCCOMMANDTABLE2           10212
#define IDS_PROJECT_UI_DIR              11273
#define IDS_PROJECTS_DIR                11712
#define IDS_PROJECT_ITEMS_DIR           11713
#define ID_PROJ_FILE_OPEN               12771
#define ID_PROJ_SETTINGS                12772
#define ID_PROJ_COMPILE                 12773
#define ID_PROJ_NEW_FOLDER              12774
#define ID_PROJ_ADD_FILES               12775
#define ID_PROJ_BUILD                   12776
#define ID_PROJ_EXECUTE                 12777
#define IDS_PlainTextFormatList         12778
#define IDS_NO_UNICODE_SUPPORT          12779
#define IDS_FILE_NOT_FOUND_ON_PATH      12780
#define IDS_FILE_NOT_FOUND_ON_PATH2     12781
#define IDS_E_FNAME_RESERVED            12782
#define IDS_ISENSE_CODECOMMENTS_FILE    12783
#define IDS_ISENSE_CODECOMMENTS_FILE_NS 12784
#define IDS_VC_CCPP_OPTIONS             12790
#define IDS_DDB_GLOBALS                 12791
#define IDS_VC_CLASS_WIZBAR_TIP         12792
#define IDS_VC_METH_WIZBAR_TIP          12793
#define IDS_DELETE_HANDLER              12794
#define IDS_ADD_HANDLER                 12795
#define IDS_EDIT_CODE                   12796
#define IDS_CATEGORY_MENU_COMMANDS      12797
#define IDS_CATEGORY_ACCEL_COMMANDS     12798
#define IDS_CATEGORY_CONTORLS           12799
#define IDS_MFC_MIN_DDX_FIELD_MODIFIED  12800
#define IDS_MFC_MAX_DDX_FIELD_MODIFIED  12801
#define IDS_E_NULL_STRING_VAR           12802
#define IDS_E_INVALID_TYPE              12803
#define IDS_E_OUT_OF_RANGE              12804
#define IDS_E_MIN_OUT_OF_RANGE          12805
#define IDS_E_MAX_OUT_OF_RANGE          12806
#define IDS_BSCFILEITEMLABEL            12900
#define IDS_RCNODE_NAME                 13000
#define IDS_RCNODE_UNAVAILABLE          13001
#define IDS_E_OPEN_NCB_FAILED           14000
#define IDS_E_CREATE_NCB_FAILED         14001
#define IDS_BROW_AVAILO                 14100
#define IDS_BROW_BASES                  14101
#define IDS_BROW_MAPS                   14102
#define IDS_BROW_MACROS                 14103
#define IDS_BROW_GVARS                  14104
#define IDS_NCB_LOAD                    14105
#define IDS_BROW_COMPILE                14106
#define IDS_BROW_E_NOREF                14107
#define IDS_BROW_E_NOBSC                14108
#define IDS_BROW_E_BSCLOADFAILURE       14109
#define IDS_BROW_TYPEDEFS               14110
#define IDS_NCB_SEARCH                  14111
#define IDS_BROW_SEARCH                 14112
#define IDS_BROW_LOAD                   14113
#define IDS_BROW_E_NOGOTOREF            14114
#define IDS_BROW_E_NOGOTODEF            14115
#define IDS_BROW_DESCPANE_MEMBEROF      14116
#define IDS_BROW_E_NOSCOPEDSEARCH       14117
#define IDS_BROW_DERIVED                14118
#define IDS_E_FILE_LIMIT                14119
#define IDS_ACTION_GOTOSOURCE           14200
#define IDS_E_ACP_NOERROR               15000
#define IDS_E_ACP_D_FAULT               15001
#define IDS_E_ACP_D_STACK_OVERFLOW      15002
#define IDS_E_ACP_D_EOF_ABORT           15003
#define IDS_E_ACP_D_FATAL_OVERFLOW      15004
#define IDS_E_ACP_D_ERROR_OVERFLOW      15005
#define IDS_E_ACP_D_PARSER_OVERFLOW     15006
#define IDS_E_ACP_D_CHKBUF_OVERFLOW     15007
#define IDS_E_ACP_D_DA_NOTREE           15008
#define IDS_E_ACP_D_DA_NOTYPE           15009
#define IDS_E_ACP_D_DA_INDIRECTION      15010
#define IDS_E_ACP_D_DA_NOTCSU           15011
#define IDS_E_ACP_D_QI_NOTFOUND         15012
#define IDS_E_ACP_D_QI_NOTYPE           15013
#define IDS_E_ACP_D_QI_TENTATIVE        15014
#define IDS_E_ACP_D_QI_ERRSYM           15015
#define IDS_E_ACP_D_PE_ABORT            15016
#define IDS_E_ACP_D_LI_ABORT            15017
#define IDS_E_ACP_D_NCB_CALL_FAILED     15018
#define IDS_E_ACP_D_OUT_OF_HEAP_MEMORY  15019
#define IDS_E_ACP_D_EXIT_ERRORS         15020
#define IDS_E_ACP_D_N_EXIT_ERRORS       15021
#define IDS_E_ACP_D_QI_KEYWORD          15022
#define IDS_E_ACP_D_QI_NOT_IDENT        15023
#define IDS_E_ACP_D_NO_TARGET_FOR_IMOD  15024
#define IDS_E_ACP_D_DA_NO_DOT_ARROW     15025
#define IDS_E_ACP_D_DA_TENTATIVE        15026
#define IDS_E_ACP_D_DA_TEMPLATE_PARAMETER 15027
#define IDS_E_ACP_D_UNDOC_ERRCODE       15050
#define IDS_E_ACP_R_OPERATION_FAILED    15100
#define IDS_E_ACP_R_DA_NOTREE           15101
#define IDS_E_ACP_R_DA_NOTYPE           15102
#define IDS_E_ACP_R_DA_INDIRECTION      15103
#define IDS_E_ACP_R_DA_NOTCSU           15104
#define IDS_E_ACP_R_QI_NOTFOUND         15105
#define IDS_E_ACP_R_QI_NOTYPE           15106
#define IDS_E_ACP_R_QI_TENTATIVE        15107
#define IDS_E_ACP_R_QI_ERRSYM           15108
#define IDS_E_ACP_R_QI_KEYWORD          15109
#define IDS_E_ACP_R_QI_NOT_IDENT        15110
#define IDS_E_ACP_R_DA_TENTATIVE        15111
#define IDS_E_ACP_R_DA_TEMPLATE_PARAMETER 15112
#define ID_AMB_LIST                     24001
#define ID_AMB_SYM                      24002
#define ID_AMB_OK                       24003
#define ID_AMB_CANCEL                   24004
#define ID_HELP                         0xE146

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        9010
#define _APS_NEXT_COMMAND_VALUE         9000
#define _APS_NEXT_CONTROL_VALUE         9000
#define _APS_NEXT_SYMED_VALUE           9000
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\wizards\xboxwiz\templates\1033\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
// [!output PROJECT_NAME].pch will be the pre-compiled header
// stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\wizards\xboxwiz\templates\1033\root.cpp ===
[!if XBOX_APP]
// [!output PROJECT_NAME].cpp : Defines the entry point for the application.
[!endif]
//

#include "stdafx.h"

//-----------------------------------------------------------------------------
// Global variables
//-----------------------------------------------------------------------------
LPDIRECT3D8             g_pD3D       = NULL; // Used to create the D3DDevice
LPDIRECT3DDEVICE8       g_pd3dDevice = NULL; // Our rendering device
LPDIRECT3DVERTEXBUFFER8 g_pVB        = NULL; // Buffer to hold vertices

// A structure for our custom vertex type
struct CUSTOMVERTEX
{
    FLOAT x, y, z, rhw; // The transformed position for the vertex
    DWORD color;        // The vertex color
};

// Our custom FVF, which describes our custom vertex structure
#define D3DFVF_CUSTOMVERTEX (D3DFVF_XYZRHW|D3DFVF_DIFFUSE)




//-----------------------------------------------------------------------------
// Name: InitD3D()
// Desc: Initializes Direct3D
//-----------------------------------------------------------------------------
HRESULT InitD3D()
{
    // Create the D3D object.
    if( NULL == ( g_pD3D = Direct3DCreate8( D3D_SDK_VERSION ) ) )
        return E_FAIL;

    // Set up the structure used to create the D3DDevice.
    D3DPRESENT_PARAMETERS d3dpp; 
    ZeroMemory( &d3dpp, sizeof(d3dpp) );
    d3dpp.BackBufferWidth        = 640;
    d3dpp.BackBufferHeight       = 480;
    d3dpp.BackBufferFormat       = D3DFMT_X8R8G8B8;
    d3dpp.BackBufferCount        = 1;
    d3dpp.EnableAutoDepthStencil = TRUE;
    d3dpp.AutoDepthStencilFormat = D3DFMT_D24S8;
    d3dpp.SwapEffect             = D3DSWAPEFFECT_DISCARD;

    // Create the Direct3D device.
    if( FAILED( g_pD3D->CreateDevice( 0, D3DDEVTYPE_HAL, NULL,
                                      D3DCREATE_HARDWARE_VERTEXPROCESSING,
                                      &d3dpp, &g_pd3dDevice ) ) )
        return E_FAIL;

    // After creating the device, initial state would normally be set here.

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: InitVB()
// Desc: Creates a vertex buffer and fills it with our vertices. The vertex
//       buffer is basically just a chuck of memory that holds vertices. After
//       creating it, we must Lock()/Unlock() it to fill it. For indices, D3D
//       also uses index buffers. The special thing about vertex and index
//       buffers is that the ycan be created in device memory, allowing some
//       cards to process them in hardware, resulting in a dramatic
//       performance gain.
//-----------------------------------------------------------------------------
HRESULT InitVB()
{
    // Initialize three vertices for rendering a triangle
    CUSTOMVERTEX g_Vertices[] =
    {
        { 320.0f, 150.0f, 0.5f, 1.0f, 0xffff0000, }, // x, y, z, rhw, color
        { 420.0f, 330.0f, 0.5f, 1.0f, 0xff00ff00, },
        { 220.0f, 330.0f, 0.5f, 1.0f, 0xff00ffff, },
    };

    // Create the vertex buffer. Here we are allocating enough memory
    // (from the default pool) to hold all our 3 custom vertices. We also
    // specify the FVF, so the vertex buffer knows what data it contains.
    if( FAILED( g_pd3dDevice->CreateVertexBuffer( 3*sizeof(CUSTOMVERTEX),
                                                  D3DUSAGE_WRITEONLY, 
                                                  D3DFVF_CUSTOMVERTEX,
                                                  D3DPOOL_MANAGED, &g_pVB ) ) )
        return E_FAIL;

    // Now we fill the vertex buffer. To do this, we need to Lock() the VB to
    // gain access to the vertices. This mechanism is required becuase vertex
    // buffers may be in device memory.
    CUSTOMVERTEX* pVertices;
    if( FAILED( g_pVB->Lock( 0, 0, (BYTE**)&pVertices, 0 ) ) )
        return E_FAIL;
    memcpy( pVertices, g_Vertices, 3*sizeof(CUSTOMVERTEX) );
    g_pVB->Unlock();

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Render()
// Desc: Draws the scene
//-----------------------------------------------------------------------------
VOID Render()
{
    // Clear the backbuffer to a blue color
    g_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_TARGET|D3DCLEAR_ZBUFFER, 
                         D3DCOLOR_XRGB(0,0,255), 1.0f, 0L );

    // Begin the scene
    g_pd3dDevice->BeginScene();

    // Draw the triangles in the vertex buffer. This is broken into a few
    // steps. We are passing the vertices down a "stream", so first we need
    // to specify the source of that stream, which is our vertex buffer. Then
    // we need to let D3D know what vertex shader to use. Full, custom vertex
    // shaders are an advanced topic, but in many cases the vertex shader is
    // just the FVF, so that D3D knows what type of vertices we are dealing
    // with. Finally, we call DrawPrimitive() which does the actual rendering
    // of our geometry (in this case, just one triangle).
    g_pd3dDevice->SetStreamSource( 0, g_pVB, sizeof(CUSTOMVERTEX) );
    g_pd3dDevice->SetVertexShader( D3DFVF_CUSTOMVERTEX );
    g_pd3dDevice->DrawPrimitive( D3DPT_TRIANGLELIST, 0, 1 );

    // End the scene
    g_pd3dDevice->EndScene();
}




//-----------------------------------------------------------------------------
// Name: main()
// Desc: The application's entry point
//-----------------------------------------------------------------------------
void __cdecl main()
{
    // Initialize Direct3D
    if( FAILED( InitD3D() ) )
        return;

    // Initialize the vertex buffer
    InitVB();

    while( TRUE )
    {
        // Render the scene
        Render();

        // Present the backbuffer contents to the display
        g_pd3dDevice->Present( NULL, NULL, NULL, NULL );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\ide\wizards\xboxwiz\templates\1033\stdafx.h ===
// stdafx.h : include file for standard system include files,
// or project specific include files that are used frequently, but
// are changed infrequently
//

#pragma once

#include <xtl.h>

// TODO: reference additional headers your program requires here
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\langapi\attribute\include\prov_64.h ===
#if _WIN64
typedef __int64             intptr_t;
typedef unsigned __int64    uintptr_t;
#elif _M_IX86 && defined(Wp64)
typedef __w64 int           intptr_t;
typedef __w64 unsigned int  uintptr_t;
#else
typedef int                 intptr_t;
typedef unsigned int        uintptr_t;
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\langapi\attribute\include\fake_p1.h ===
#if !defined(__FAKE_P1_H__)
#define __FAKE_P1_H__

#if (VERSP_RELEASE || VERSP_TEST || VERSP_DEBUG)

#if !defined(CXXDELETE)
#define CXXDELETE(x) 
#endif

#if !defined(CXXVECDELETE)
#define CXXVECDELETE(x) 
#endif

#else // (VERSP_RELEASE || VERSP_TEST || VERSP_DEBUG)

#include <stdio.h>

#if defined(__ATLBASE_H__)

#define DASSERT(x) ATLASSERT(x)

#else // __ATLBASE_H__

#include <string.h>
#include <assert.h>

#if !defined(STDMETHODCALLTYPE)
#define STDMETHODCALLTYPE
#endif
#if !defined(S_OK)
#define S_OK 0
#endif
#if !defined(TRUE)
#define TRUE 0
#endif
#if !defined(FALSE)
#define FALSE 0
#endif

typedef int HRESULT;
typedef int BOOL;
typedef char CHAR;
typedef short *BSTR;

#if defined(_DEBUG)
#define DASSERT(x) assert(x)
#else
#define DASSERT(x)
#endif

#endif // __ATLBASE_H__

#if !defined(UNREACHED)
#define UNREACHED 0
#endif

#if !defined(CXXNEW)
#define CXXNEW(x, y) new x
#endif

#if !defined(CXXDELETE)
#define CXXDELETE(x) delete x
#endif

#if !defined(CXXVECDELETE)
#define CXXVECDELETE(x) if (x) delete[] x
#endif

#if !defined(ALLOC_ARB)
#define ALLOC_ARB(x, y, z) (x*) new char[z];
#endif

#if !defined(ALLOC_STRINGA)
#define ALLOC_STRINGA(x, y) (char*) new char[x];
#endif

#if !defined(SRC)
#define SRC(x) 
#endif

enum lifetime_e {
    M_FILELIFE,
    M_STMTLIFE
};

typedef bool bool_t;

#include <ctype.h>

#endif // (VERSP_RELEASE || VERSP_TEST || VERSP_DEBUG)

#endif // __FAKE_P1_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\langapi\attribute\include\usage.h ===
#if !defined(__USAGE_H__)
#define __USAGE_H__

static UsageType UsageTypeVector[eUsageCount] = {
#define DAT(e,val,str) e,
#include "usage_dat.h"
#undef DAT
};

static char *UsageStringVector[eUsageCount] = {
#define DAT(e,val,str) #e,
#include "usage_dat.h"
#undef DAT
};

static char* UsageToHumanVector[eUsageCount] = {
#define DAT(e,val,str) str,
#include "usage_dat.h"
#undef DAT
};

enum UsageIndex {
#define DAT(e,val,str) idx_ ## e,
#include "usage_dat.h"
#undef DAT
};

inline char* UsageTo(int usage, char* buf, int startIdx, char* prefix)
{
    DASSERT(eAnyUsage == 0 && eAnyUsage == UsageTypeVector[0]);
    DASSERT(usage >= 0 && usage <= eMaxUsage && buf != 0);
    DASSERT(eCOMInterfaceUsage == UsageTypeVector[idx_eCOMInterfaceUsage]);
    DASSERT(eInterfaceUsage == UsageTypeVector[idx_eInterfaceUsage]);
    DASSERT(idx_eInterfaceUsage == (UsageType) (idx_eCOMInterfaceUsage+1));
    DASSERT(eInterfaceParameterUsage == UsageTypeVector[idx_eInterfaceParameterUsage]);
    DASSERT(eMethodParameterUsage == UsageTypeVector[idx_eMethodParameterUsage]);
    DASSERT(idx_eMethodParameterUsage == (UsageType) (idx_eInterfaceParameterUsage+1));
    DASSERT(eAnyIDLUsage == UsageTypeVector[eUsageCount-1]);

    buf[0] = 0;
    char* pBufEnd = buf;
    bool_t fFirst = true;

    for (int i = startIdx; i < eUsageCount-5 /*Skip eAnyIDLUsage*/; ++i) {
        if ((usage & UsageTypeVector[i]) || (i == 0 && usage == 0)) {

            if ((i == idx_eCOMInterfaceUsage) && (usage & (eInterfaceUsage & ~eCOMInterfaceUsage))) {
                i = idx_eInterfaceUsage;
            }
            if ((i == idx_eInterfaceParameterUsage) && (usage & (eMethodParameterUsage & ~eInterfaceParameterUsage))) {
                i = idx_eMethodParameterUsage; 
            }

            pBufEnd += sprintf(pBufEnd, "%s%s", ((fFirst) ? "" : prefix), UsageToHumanVector[i]);
            fFirst = false;
        }
    }

    return buf;
}

inline char* UsageToHuman(int usage, char* buf)
{
    return UsageTo(usage, buf, idx_eCoClassUsage, ", ");
}

inline char* UsageToString(int usage, char* buf)
{
    return UsageTo(usage, buf, 0, "| ");
}

inline __int64 GetValueKind(const char* val) {
    if (strcmp(val, "eANSIStringValue") == 0) {
        return eANSIStringValue;
    } else if (strcmp(val, "eWideStringValue") == 0) {
        return eWideStringValue;
    } else if (strcmp(val, "eIntegerValue") == 0) {
        return eIntegerValue;
    } else if (strcmp(val, "eInteger64Value") == 0) {
        return eInteger64Value;
    } else if (strcmp(val, "eFloatValue") == 0) {
        return eFloatValue;
    } else if (strcmp(val, "eDoubleValue") == 0) {
        return eDoubleValue;
    } else if (strcmp(val, "eIdentValue") == 0) {
        return eIdentValue;
    } else if (strcmp(val, "eMacroValue") == 0) {
        return eMacroValue;
    } else if (strcmp(val, "eBooleanValue") == 0) {
        return eBooleanValue;
    } else if (strcmp(val, "eGuidValue") == 0) {
        return eGuidValue;
    } else if (strcmp(val, "eSystemTypeValue") == 0) {
        return eSystemTypeValue;
    } else if (strcmp(val, "eVariantValue") == 0) {
        return eVariantValue;
#if VERSP_RELEASE
    } else {
        return eUnknownValue;
    }
#else
    } else if (strcmp(val, "eUnknownValue") == 0) {
        return eUnknownValue;
    } else {
        printf("error in GetValueKind(val=%s)\n", val);
        fflush(stdout);
        DASSERT(UNREACHED);
        return eUnknownValue;
    }
#endif
}

static char* ValueKindVector[eMaxValueKind] = {
    "string",
    "wide string",
    "managed string",
    "integer",
    "integer64",
    "float",
    "double",
    "identifier",
    "macro",
    "boolean",
    "GUID",
    "System::Type",
    "unknown",
    "unknown",
    "unknown"
};

inline __int64 GetUsageType(const char* val) {
    if (strcmp(val, "eAnyUsage") == 0) {
        return eAnyUsage;
    } else if (strcmp(val, "eCoClassUsage") == 0) {
        return eCoClassUsage;
    } else if (strcmp(val, "eCOMInterfaceUsage") == 0) {
        return eCOMInterfaceUsage;
    } else if (strcmp(val, "eInterfaceUsage") == 0) {
        return eInterfaceUsage;
    } else if (strcmp(val, "eMemberUsage") == 0) {
        return eMemberUsage;
    } else if (strcmp(val, "eMethodUsage") == 0) {
        return eMethodUsage;
    } else if (strcmp(val, "eInterfaceMethodUsage") == 0) {
        return eInterfaceMethodUsage;
    } else if (strcmp(val, "eCoClassMemberUsage") == 0) {
        return eCoClassMemberUsage;
    } else if (strcmp(val, "eCoClassMethodUsage") == 0) {
        return eCoClassMethodUsage;
    } else if (strcmp(val, "eGlobalMethodUsage") == 0) {
        return eGlobalMethodUsage;
    } else if (strcmp(val, "eGlobalDataUsage") == 0) {
        return eGlobalDataUsage;
    } else if (strcmp(val, "eClassUsage") == 0) {
        return eClassUsage;
    } else if (strcmp(val, "eInterfaceParameterUsage") == 0) {
        return eInterfaceParameterUsage;
    } else if (strcmp(val, "eMethodParameterUsage") == 0) {
        return eMethodParameterUsage;
    } else if (strcmp(val, "eIDLModuleUsage") == 0) {
        return eIDLModuleUsage;
    } else if (strcmp(val, "eAnonymousUsage") == 0) {
        return eAnonymousUsage;
    } else if (strcmp(val, "eTypedefUsage") == 0) {
        return eTypedefUsage;
    } else if (strcmp(val, "eUnionUsage") == 0) {
        return eUnionUsage;
    } else if (strcmp(val, "eEnumUsage") == 0) {
        return eEnumUsage;
    } else if (strcmp(val, "eDefineTagUsage") == 0) {
        return eDefineTagUsage;
    } else if (strcmp(val, "eStructUsage") == 0) {
        return eStructUsage;
    } else if (strcmp(val, "eLocalUsage") == 0) {
        return eLocalUsage;
    } else if (strcmp(val, "ePropertyUsage") == 0) {
        return ePropertyUsage;
    } else if (strcmp(val, "eEventUsage") == 0) {
        return eEventUsage;
    } else if (strcmp(val, "eTemplateUsage") == 0) {
        return eTemplateUsage;
    } else if (strcmp(val, "eModuleUsage") == 0) {
        return eModuleUsage;
    } else if (strcmp(val, "eIllegalUsage") == 0) {
        return eIllegalUsage;
    } else if (strcmp(val, "eAsynchronousUsage") == 0) {
        return eAsynchronousUsage;
    } else if (strcmp(val, "eAnyIDLUsage") == 0) {
        return eAnyIDLUsage;
    } else {
        char buf[512];
        _snprintf(buf, 512, "%s: incorrect format for attribute \'usage\'", val);
#if VERSP_RELEASE || VERSP_TEST || VERSP_DEBUG
        error(C2338, buf);
#else
        printf("%s\n", buf);
#endif
        DASSERT(UNREACHED);
        return eAnyUsage;
    }
}

#endif // __USAGE_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\langapi\attribute\include\quickhash.h ===
#if !defined(__QUICKHASH_H__)
#define __QUICKHASH_H__

/////////////////////////////////////////////////////////////////////////////
// QuickHash
//
// NOTE:
//  To use load or operator[], VALUE must have a ctor that takes an integer argument
//

template <class KEY, class VALUE>
struct QuickHash {
    static const int hashsize;
    struct List {
        List(const KEY& d = 0, const VALUE& i = 0) { next = 0; data = d; idx = i; }
        List* next;
        KEY data;
        VALUE idx;
    };
    int size;
    List** hashtable;
    lifetime_e life;
    List* next(int* x) {
        DASSERT(x != 0 && *x >= 0 && *x <= size);
        for (int i = *x; i < size; ++i) {
            if (hashtable[i] != 0) {
                break;
            }
        }
        if (i < size) {
            *x = i;
            return hashtable[i];
        }
        return 0;
    }
    List* first(int* x) {
        DASSERT(x != 0 && *x < size);
        *x = 0;
        return next(x);
    }
    List* next(int* x, List* p) {
        DASSERT(p != 0 && x != 0 && *x < size);
        if (p->next != 0) {
            return p->next;
        } else {
            ++*x;
            return next(x);
        }
    }
    void zero() {
        memset(hashtable, 0, size*sizeof(List*));
    }
    QuickHash(lifetime_e l = M_FILELIFE) {
        size = 0;
        hashtable = 0;
        life = l;
    }
    QuickHash(int sz, lifetime_e l = M_FILELIFE) {
        init(sz, l);
    }
    QuickHash(KEY* keys, int numkeys, int sz = hashsize, lifetime_e l = M_FILELIFE) {
        load(keys, numkeys);
    }
    void init(int sz = hashsize, lifetime_e l = M_FILELIFE) {
        size = sz;
        life = l;
#if VERSP_PARSEONLY
        hashtable = new List*[size];
#else
        hashtable = CXXNEW(List*, life)[size];
#endif
        memset(hashtable, 0, size*sizeof(List*));
    }
    void load(KEY* keys, int numkeys) {
        DASSERT(numkeys == 0 || keys != 0);
        if (size == 0) {
            init();
        }
        for (int i = 0; i < numkeys; ++i) {
            insert(keys[i], VALUE(i));
        }
    }
    void clear() {
#if (VERSP_RELEASE || VERSP_TEST || VERSP_DEBUG) && !VERSP_PARSEONLY
    // don't delete anything inside compiler
#else
        for (int i = 0; i < size; ++i) {
            List* node = hashtable[i];
            while (node != 0) {
                List* next = node->next;
                delete node;
                node = next;
            }
        }
        delete [] hashtable;
#endif
    }
    VALUE& operator[] (const KEY& k) {
        VALUE v;
        List* node = lookup(k, key(k), &v);
        if (node == 0) {
            node = insert(k, v);
        }
        DASSERT(node != 0);
        return node->idx;
    }
            
    List* insert(const KEY& k, const VALUE& idx) {
        int the_key = key(k);
        List* node = lookup(k, the_key);
        if (node == 0) {
#if VERSP_PARSEONLY
            node = new List(k, idx);
#else
            node = CXXNEW(List, life)(k, idx);
#endif
            node->next = hashtable[the_key];
            hashtable[the_key] = node;
            return node;
        }
        node->idx = idx;
        return 0;
    }
    List* lookup(const KEY& k, int the_key, VALUE* pidx = 0) {
        DASSERT(the_key >= 0 && the_key < size);
        List* node = hashtable[the_key];
        while (node != 0) {
            DASSERT(node->data != 0);
            if (node->data == k) {
                if (pidx != 0) {
                    *pidx = node->idx;
                }
                return node;
            }
            node = node->next;
        }
        return 0;
    }
    bool_t lookup(const KEY& k, VALUE* pidx = 0) {
        return (lookup(k, key(k), pidx) != 0) ? true : false;
    }
    unsigned int key(const KEY& k) const {
        return key(k, size);
    }
    static unsigned int key(const KEY& k, int the_size) {
        unsigned int nHash = 0;
        char* the_key = (char*) k;
		for (int i = 0; i < sizeof(KEY); ++i) {
            nHash += (nHash << 5) + (int)(char) the_key++;
        }
        DASSERT(the_size > 0);
        return nHash % the_size;
    }
    ~QuickHash() {
        clear();
    }
};

template <class KEY, class VALUE>
const int QuickHash<KEY, VALUE>::hashsize = 511;

//
// We really need partial specialization
//
template <>
QuickHash<char*, int>::List* QuickHash<char*, int>::lookup(char* const& k, int the_key, int* pidx) {
    DASSERT(the_key >= 0 && the_key < size);
    List* node = hashtable[the_key];
    while (node != 0) {
        DASSERT(node->data != 0);
        if (strcmp(node->data, k) == 0) {
            if (pidx != 0) {
                *pidx = node->idx;
            }
            return node;
        }
        node = node->next;
    }
    return 0;
}

//
// We really need partial specialization
//
template <>
QuickHash<char*, void*>::List* QuickHash<char*, void*>::lookup(char* const& k, int the_key, void** pidx) {
    DASSERT(the_key >= 0 && the_key < size);
    List* node = hashtable[the_key];
    while (node != 0) {
        DASSERT(node->data != 0);
        if (strcmp(node->data, k) == 0) {
            if (pidx != 0) {
                *pidx = node->idx;
            }
            return node;
        }
        node = node->next;
    }
    return 0;
}

//
// We really need partial specialization
//
template <>
unsigned int QuickHash<char*, int>::key(char* const& k, int the_size) {
    unsigned int nHash = 0;
    char* the_key = (char*) k;
    while (*the_key) {
        nHash = (nHash << 3) + nHash + *the_key++;
    }
    DASSERT(the_size > 0);
    return nHash % the_size;
}

//
// We really need partial specialization
//
template <>
unsigned int QuickHash<char*, void*>::key(char* const& k, int the_size) {
    unsigned int nHash = 0;
    char* the_key = (char*) k;
    while (*the_key) {
        nHash = (nHash << 3) + nHash + *the_key++;
    }
    DASSERT(the_size > 0);
    return nHash % the_size;
}

//
// We really need partial specialization
//
template <>
unsigned int QuickHash<char*, FastList<char*>*>::key(char* const& k, int the_size) {
    unsigned int nHash = 0;
    char* the_key = (char*) k;
    while (*the_key) {
        nHash = (nHash << 3) + nHash + *the_key++;
    }
    DASSERT(the_size > 0);
    return nHash % the_size;
}

//
// We really need partial specialization
//
template <>
unsigned int QuickHash<int, char*>::key(const int& k, int the_size) {
    unsigned int nHash = k;    
    DASSERT(the_size > 0);
    return nHash % the_size;
}

#endif // __QUICKHASH_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\langapi\include\bld_version.h ===
//
// Define the build revision number.  Default is zero.
//
//  Typical use is to use a -D define to override this one
//  so you do not need to update this file.
//
//  example:  cl ... -Drbld=1 ...
//
//
#if !defined(_build_version_h)
#define _build_version_h
#pragma once

#if !defined(rbld)
#define rbld 0
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc7addon\vs\src\vc\langapi\attribute\include\__attribute.h ===
#include <unknwn.h>

[emitidl];

[export]
typedef enum tagEvent
{
    seenNoEvent = 0x0,        
    seenDefineTag = 0x1,
    seenAllBases = 0x2,
    seenFunctionFormal = 0x3,
    seenMember = 0x4, 
    seenAllMembers = 0x5,
    seenEndTag = 0x6,                      
    seenAllSource = 0x7,        
    seenDumpGlobals = 0x8,
    MAX_EVENT = 0x9
} Event;

// Must be kept in sync with Event
[export]
typedef enum tagEvent2 {
    seenNoEvent2        = (1 << seenNoEvent),
    seenDefineTag2      = (1 << seenDefineTag),
    seenAllBases2       = (1 << seenAllBases),
    seenFunctionFormal2 = (1 << seenFunctionFormal),
    seenMember2         = (1 << seenMember),
    seenAllMembers2     = (1 << seenAllMembers),
    seenEndTag2         = (1 << seenEndTag),
    seenAllSource2      = (1 << seenAllSource),
    seenDumpGlobals2    = (1 << seenDumpGlobals)
} Event2;
    
[export]
typedef enum tagMemberAttrs
{
    eNone = 0x0,
    ePrivate = 0x1,
    eProtected = 0x2,
    ePublic = 0x3,
    eAccMask = 0x3,
    eVirtual = 0x4,
    eStatic = 0x8,
    eConst = 0x10,
    eMethod = 0x20,
    eField = 0x40,
    eBase = 0x80,
    eOverload = 0x100,
    eCdecl = 0x200,
    eStdcall = 0x400,
    eThiscall = 0x800,
    eInterface = 0x1000,
    eCoclass = 0x2000,
    eClass = 0x4000,
    eStruct = 0x8000,
    eEnum = 0x10000,
    eUnion = 0x20000,
    eNamespace = 0x40000,
    eDefined = 0x80000,
    eQueuable = 0x100000,
    ePure = 0x200000,
    eOtherCall = 0x400000,
    eSymbol = 0x800000  // should be typedef
} MemberAttrs;

[export]
typedef enum tagInterfaceType
{
    eNoInterface = 0x0,
    eDual = 0x1,
    eDispinterface = 0x2,
    eCustom = 0x3,
    eCOMPlus = 0x4
} InterfaceType;

// scopes
[export]
typedef enum tagScopeType
{
    eNoScope = 0x0,
    eGlobalScope = 0x1,
    eClassScope = 0x2,
    eNamespaceScope = 0x4,
    eMemberScope = 0x8,
    eMethodScope = 0x10,
    eFormalScope = 0x20,
    eSymbolScope = 0x40,    // typedefs, etc.
    eMAXSCOPE
} ScopeType;

[export]
typedef enum tagPropertyType
{
    ePropNone = 0x0,
    ePropPut = 0x1,
    ePropGet = 0x2,
    ePropPutRef = 0x3
} PropertyType;

[export]
typedef enum tagUsageType
{   
    eAnyUsage                = 0x0,
    eCoClassUsage            = 0x1,
    eCPPInterfaceUsage       = 0x2,        
    eInterfaceUsage          = 0x4,
    eAnyInterfaceUsage       = 0x6,
    eMemberUsage             = 0x8,
    eMethodUsage             = 0x10,
    eInterfaceMethodUsage    = 0x20,
    eCoClassMemberUsage      = 0x40,
    eCoClassMethodUsage      = 0x80,
    eGlobalMethodUsage       = 0x100,  // global funcs
    eGlobalDataUsage         = 0x200,  // global data
    eClassUsage              = 0x400,  // any struct or class (non-coclass) but not typedef, union, enum, coclass or interface
    eInterfaceParameterUsage = 0x800,  // interface function formals only
    eCoClassParameterUsage   = 0x1000,  // coclass function formals only
    eIDLModuleUsage          = 0x2000,
    eAnonymousUsage          = 0x4000,        
    eNamespaceUsage          = 0x8000,
    eTypedefUsage            = 0x10000,
    eUnionUsage              = 0x20000,
    eEnumUsage               = 0x40000,
    eDefineTagUsage          = 0x80000,
    eStructUsage             = 0x100000,           
    eLocalUsage              = 0x200000,           
    eModuleUsage             = 0x400000, // Not real -- nothing should have module usage 
    eIllegalUsage            = 0x800000,          
    eAnyIDLUsage             = 0x3FBFFF,  // eAnyUsage - eAnonymousUsage
    eMaxUsage                = 0x7FFFFF,
    eUsageCount              = 0x1A // 3 less than the number of enum entries
} UsageType;

[export]
typedef enum tagGroupType
{
    eCPlusPlusGroup         = 0x0,
    eModuleGroup            = 0x1,
    eInterfaceGroup         = 0x2,
    eComGroup               = 0x3,
    eComPlusMetaDataGroup   = 0x4,
    eControlGroup           = 0x5,
    eWindowGroup            = 0x6,
    eRegistryGroup          = 0x7,
    eDBConsumerGroup        = 0x8,
    eDBProviderGroup        = 0x9,
    eStockPMEGroup          = 0xA,
    eDebugGroup             = 0xB,
    eDHTMLGroup             = 0xC,
    eCompilerGroup          = 0xD,
    eIDLGroup               = 0xE,
    eUserDefinedGroup       = 0xF,
    eMaxGroup               = 0x10
} GroupType;

[export]
typedef enum tagProviderFlags
{
    eNoDefaultBehavior      = 0x0,
    eWarningUponDup         = 0x1
} ProviderFlags;

[export]
typedef struct StrToStrList
{
    [string] char* str;
    [size_is(strlist_len)] char** strlist;
    int strlist_len;
} StrToStrList;

[export]
struct AttributeSpecs
{
    [string] char* attribute;

    [size_is(arg_list_len)] char** argument_list;
    int arg_list_len;

    [size_is(arg_list_len)] char** argument_type;

    [size_is(req_args_len)] char** required_arguments;
    int req_args_len;

    [size_is(req_attrs_len)] char** required_class_attributes;
    int req_class_attrs_len;

    [size_is(req_attrs_len)] char** required_attributes;
    int req_attrs_len;
    [size_is(prop_req_list_len)] char** prop_required_attribute_keys;
    [size_is(prop_req_list_len)] char*** prop_required_attributes;
    [size_is(prop_req_list_len)] int* prop_req_attrs_len;
    int prop_req_list_len;

    [size_is(inv_attrs_len)] char** invalid_class_attributes;
    int inv_class_attrs_len;

    [size_is(inv_attrs_len)] char** invalid_attributes;
    int inv_attrs_len;
    [size_is(prop_inv_list_len)] char** prop_invalid_attribute_keys;
    [size_is(prop_inv_list_len)] char*** prop_invalid_attributes;
    [size_is(prop_inv_list_len)] int* prop_inv_attrs_len;
    int prop_inv_list_len;

    [size_is(imp_attrs_len)] char** implied_attributes;
    int imp_attrs_len;

    [size_is(arg_list_len)] char*** check_argument;
    [size_is(arg_list_len)] int* chk_arg_len;

    [size_is(arg_list_len)] char** default_value;

    [string] char* help_string;
    [size_is(arg_list_len)] char** prop_help_strings;

    [size_is(num_meta_types)] char** meta_types;
    [size_is(num_meta_types)] char** meta;
    int num_meta_types;

    [string] char* usage;   // usually UsageType, but user extendible -- not yet though
    [string] char* group;   // usually GroupType, but user extendible -- not yet though

    [string] char* listen_to;

    int repeatable;     // usually boolean  
    [size_is(arg_list_len)] int* arg_repeatable; // usually boolean 
    
    [size_is(arg_list_len)] int* multivalue;

    int frequently_used;// usually boolean
    int shipping;       // usually boolean
    int variable_args;  // required # of props+defaults is not fixed
    int explicit_args;  // usually boolean

    [string] char* qa;
    [string] char* ue;
    [string] char* pm;
    [string] char* dev;
};

[export]
struct MemberSpecs
{
    [string] char* name;
    [string] char* desc;
    uintptr_t attrs;
    uintptr_t alias;
};

[export]
typedef enum tagMetadataTypes
{
    eClassDef = 0,
    eClassRef = 1,
    eMethodDef = 2,
    eMethodRef = 3,
    eMethodImpl = 4
} MetadataTypes;

[export]
typedef enum tagValueKind
{
    eANSIStringValue = 0,
    eWideStringValue = 1,
    eIntegerValue = 2,
    eInteger64Value = 3,
    eFloatValue = 4,
    eDoubleValue = 5,
    eIdentValue = 6,
    eMacroValue = 7,
    eBooleanValue = 8,
    eGuidValue = 9,
    eUnknownValue = 10,
    eMaxValueKind = 11
} ValueKind;

[export]
typedef enum tagForceIncludeKind
{
    eInclude = 0,
    eSysInclude = 1,
    eImport = 2,
    eSysImport = 3
} ForceIncludeKind;

#if 0
[export]
struct SizedValue
{
    [switch_type(char), switch_is(kind)] union {        
    [case(1)]
        [string] wchar_t* wval;
    [default]
        [string] char* val;
    };
    char kind;
};
#else
[export]
struct SizedValue
{
    [string] char* val;
    char kind;
};
#endif

[export]
struct AttributeArg
{
    [string] char* name;
    [size_is(valcount)] struct SizedValue* vals;
    int valcount;
};

[export]
struct Attribute
{
    [string] char* name;
    [size_is(argcount)] struct AttributeArg* args;
    int argcount;
    DWORD vPos;
    DWORD vEndPos;
};

[
    object,
    uuid(64626784-83F5-11d2-B8DA-00C04F799BBB),
    helpstring("ICompiler Interface"),
    pointer_default(unique)
]
__interface ICompiler : IUnknown
{
    [id(1)] HRESULT AddBaseClass([in] struct MemberSpecs* specs, [in, defaultvalue(FALSE)] const boolean backpatch);
    [id(2)] HRESULT AddtoMemberList([in, string] const char* toks);
    [id(3)] HRESULT AddtoGlobalList([in, string] const char* toks, [in, defaultvalue(seenNoEvent)] Event e);
    [id(4)] HRESULT QueryScope([out] int* pScope, [out, retval] char** pScopename);
    [id(5)] HRESULT EmitGlobalsNow([in, defaultvalue(FALSE)] const boolean freeMemory);
    [id(6)] HRESULT InjectAtBeginningOfFunction([in, string] const char* toks, [in] const uintptr_t alias);
    [id(7)] HRESULT InjectAtEndOfFunction([in, string] const char* toks, [in] const uintptr_t alias);
    [id(8)] HRESULT InjectIntoFunctionHere([in, string] const char* toks);
    [id(9)] HRESULT AlterName([in, string] const char* name, [in] const uintptr_t alias);
    [id(10)] HRESULT QueryBases([in, out, size_is( , *count)] struct MemberSpecs** specs, [in, out] int* count, [in, defaultvalue(FALSE)] const boolean recursive);
    [id(11)] HRESULT QueryCurrentClass([out, retval] struct MemberSpecs* spec);
    [id(12)] HRESULT QueryCurrentLibrary([out, retval] struct MemberSpecs* spec);
    [id(13)] HRESULT QueryCurrentMember([out, retval] struct MemberSpecs* spec);        
    [id(14)] HRESULT QueryMembers([in, out, size_is( , *count)] struct MemberSpecs** specs, [in, out] int* count);
    [id(15)] HRESULT QueryMacro([in, string] const char* macro, [out, retval] char** expansion);
    [id(16)] HRESULT QuerySymbol([in, out] struct MemberSpecs* specs, [out] boolean* isDefd, [in] const boolean lookonlyinclass, [in] const uintptr_t enclosingclass);
    [id(17)] HRESULT QueryAttributes([in, out, size_is( , *pcount)] struct Attribute** ppattr, [in, out] int* pcount, [in] const uintptr_t alias);
    [id(18)] HRESULT EmitMetadata([out] uintptr_t* emit_alias, [out] uintptr_t* import_alias); 
    [id(19)] HRESULT Guid([out] LPGUID* ppGuid, [out] struct SizedValue* pid, [in] const uintptr_t alias);
    [id(20)] HRESULT EmitWarning([in] const int level, [in, string] const char* warn);
    [id(21)] HRESULT EmitError([in, string] const char* error);      
    [id(22)] HRESULT ForceInclude([in, string] const char* fullpath, [in] const ForceIncludeKind e, [in, defaultvalue(FALSE)] const boolean freeMemory);
    [id(23)] HRESULT Pragma([in, string] const char* pragma);
    [id(24)] HRESULT EmitMembersNow();
    [id(25)] HRESULT IntegralExpressionEvaluator([in, string] const char* toks, [out, retval] int* out);    
    [id(26)] HRESULT GetValue([in] struct SizedValue* sv, [string, out, retval] char** val);
    [id(27)] HRESULT GetDispid([in] uintptr_t alias, [out] long* dispid, [out] PropertyType* prop, [out] long* vfoffset);
    [id(28)] HRESULT QueryStunDepth([out, retval] intptr_t *sd);
    [id(29)] HRESULT QueryPosition([in] struct Attribute* attr, [in] const uintptr_t alias, [out, string] char** file, [out] uintptr_t *line);
    [id(30)] HRESULT QueryName([in, string] const char* decorname, [out, string] char** undecorname);
    [id(31)] HRESULT QueryToken([in] uintptr_t alias, [in] MetadataTypes e, [out] uintptr_t* token);
    [id(32)] HRESULT QueryFullPath([in, string] const char* filename, [out, string] char** fullpath); 
};

[
    hidden,
    restricted,
    object,
    uuid(64626785-83F5-11d2-B8DA-00C04F799BBB),
    helpstring("ICompiler2 Interface"),
    pointer_default(unique)
]
__interface ICompiler2 : ICompiler
{
    [id(1)] HRESULT QueryFunctionFormal([out, retval] uintptr_t* ppsym);
    [id(2)] HRESULT AttributeMap([in, string] const char* scope, [in, string] const char* attr);    
    [id(3)] HRESULT SetGuid([in] struct SizedValue *pValue);
    [id(4)] HRESULT SetModule([in] struct Attribute* pattr);
    [id(5)] HRESULT SetThreading([in] struct Attribute* pattr);
    [id(6)] HRESULT SetInterface([in] InterfaceType einterface);
    [id(7)] HRESULT SetVersion([in] struct Attribute* ppattr);
    [id(8)] HRESULT SetControl([in] const boolean isdefined);
    [id(9)] HRESULT EmitGlobalsAt(Event e, const boolean freeMemory);   
    [id(10)] HRESULT SetProgid([in] struct SizedValue *pValue);
    [id(11)] HRESULT SetProperty([in] struct Attribute* pattr);
    [id(12)] HRESULT QueryCurrentSymbol([out, retval] struct MemberSpecs* spec);
    [id(13)] HRESULT SetPropput([in] const boolean isProperty);
    [id(14)] HRESULT SetPropget([in] const boolean isProperty);
    [id(15)] HRESULT SetPropputref([in] const boolean isProperty);
    [id(16)] HRESULT SetCOM([in] const boolean isCOM);
    [id(17)] HRESULT SetObject([in] const boolean isObject);
    [id(18)] HRESULT SetCoClass([in] const boolean isCoClass);
#if CC_RAW
    [id(19)] HRESULT SetRaw([in] const boolean isRaw);
#endif  // CC_RAW
#if CC_COR
    [id(20)] HRESULT SetManaged([in] const boolean isManaged);
    [id(21)] HRESULT SetDelegate([in] const boolean isDelegate);
    [id(22)] HRESULT SetMulticastDelegate([in] const boolean isMulticastDelegate);
#endif  // CC_COR
#if CC_COMARRAY
    [id(23)] HRESULT SetComArray([in] const boolean isComArray);
#endif  // CC_COMARRAY
#if CC_COR
    [id(24)] HRESULT SetFinal([in] const boolean isFinal);
#endif  // CC_COR
    [id(25)] HRESULT RegisterHandler([in] LPGUID pClsid, [out] uintptr_t* ppHandler);
#if CC_COR
    [id(26)] HRESULT SetPDirect([in] struct Attribute* pattr);
#endif  // CC_COR
};


extern "C" const __declspec(selectany) GUID CATID_AttributeProvider = { 0xd57875f0, 0x2f34, 0x11d3, { 0xbe, 0x70, 0x0, 0xa0, 0xc9, 0xa3, 0xa5, 0x9b } };
    

[
    object,
    uuid(64626787-83F5-11d2-B8DA-00C04F799BBB),
    helpstring("IAttributeGrammar Interface"),
    pointer_default(unique)
]
__interface IAttributeGrammar : IUnknown
{       
    [id(1)] HRESULT GetAllAttributes([out] char*** ppszAttributes, [out] int* pnCount);
    [id(2)] HRESULT GetListenToAttributes([out] char*** ppszAttributes, [out] int* pnCount);
    [id(3)] HRESULT GetAttributeList([in] UsageType usage, [out] char*** ppszAttributes, [out] int* pnCount);
    [id(4)] HRESULT GetArgumentList([in] int nAttribute, [out] char*** ppszArguments, [out] int* pnArgCount);
    [id(5)] HRESULT GetArgumentValueList([in] int nAttribute, [in] int nArgument, [out] char*** ppszValues, [out] int* pnValCount);
    [id(6)] HRESULT GetAttributeUsage([in] int nAttribute, [out] int* pUsageType, [out] BSTR* pUsageStr);
    [id(7)] HRESULT GetArgumentDefault([in] int nAttribute, [in] int nArgument, [out] char** pszDefault);
    [id(8)] HRESULT GetAttributeCategory([in] int nAttribute, [out] char** pszCategory);
    [id(9)] HRESULT GetRepeatable([in] int nAttribute, [out] BOOL* pbRepeatable);
    [id(10)] HRESULT GetArgumentType([in] int nAttribute, [in] int nArgument, [out] int* pbType);
    [id(11)] HRESULT GetRequiredArguments([in] int nAttribute, [out] char**