                 {
                                        pGrandParent = new TG_Shape();
                                        pGrandParent->SetNodeName( (*iter).pParent->NodeName );
                                        m_pRoot->AddChild( pGrandParent );
                                    }
                                    break;
                                }
                            }
                        }
                       
                        pGrandParent->AddChild( pParent );                       
                    }


                    pParent->AddChild( pKid ); 
                    pKid = NULL;
                }
                else
                {
				    m_pRoot->AddChild( pKid );
				    pKid = NULL;
                }
			}

			numObjects++;
			if ( pNext )
				*pNext = 'G';

            // increment
		    pSeeker += strlen( "GEOMOBJECT " );
            pSeeker = FindNextObject( pSeeker );


		}
		OutputDebugStringA("Finished loading objects\n");

		if ( pKid )
			delete pKid;
        pKid = NULL;
	}

    const char* pSortItems[] = {
                            "ORB",
                            "CONNECT",
                            "FRAME",
                            "PROGRESS BAR",
                            "LISTBOX",
                          "SPINNER",
                          "BUTTON",
                          "SPINNER_UP",
                          "SPINNER_DOWN",
						  "ICON",
                          "TEXT"
                        };


    m_pRoot->SortShapes( pSortItems, 11 );

    m_pRoot->Dump();


	

}

//////////////////////////////////////////////////////////////////////////////
// Recursivly goes through the tree and makes the appropriate objects
// when it hits an intellignet object, it knows that it's at the end of the
// tree
HRESULT ASEScene::CreateIntelligentObjects( TG_Shape* pShape, const char* pStringName )
{
    const char* pName = pShape->GetNodeName();

    if ( pName )
    {
   
        // DO NOT call find with wild cards, otherwise text belonging to buttons
        // will not resolve properly

        CharUpperA( (char*)pName );
        DbgPrint( (char*)pName );
        DbgPrint( "\n" );
        if ( strstr( pName, "BUTTON_" ) )
        {
            CreateButtonObject( pShape, pStringName );
        }
        else if ( strstr( pName, "TEXT_" ) )
        {
            CreateTextObject( pShape, pStringName );
        }
        else if ( strstr( pName, "LISTBOX" ) )
        {
            CreateListBox( pShape, pStringName );
        }
        else if ( strstr( pName, "SPINNER_" ) )
        {
            CreateSpinner( pShape, pStringName );
        }
    
        else // just background art
        {
            TG_Shape* pChild = pShape->GetFirstChild();
            while( pChild )
            {
                CreateIntelligentObjects( pChild, pStringName );
                pChild = pShape->GetNextChild( pChild );
            }
        }
    }
    else // just background art
    {
        TG_Shape* pChild = pShape->GetFirstChild();
        while( pChild )
        {
            CreateIntelligentObjects( pChild, pStringName );
            pChild = pShape->GetNextChild( pChild );
        }
    }

       return S_OK;


}

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
// Create's a button object and potentially any associated text
HRESULT ASEScene::CreateButtonObject( TG_Shape* pShape, const char* pNameInCSV )
{
    ButtonInfo* pInfo = new ButtonInfo;
    memset( pInfo, 0, sizeof( ButtonInfo ) );

    float z;


    long size = sizeof( ButtonInfo );

    list< TG_Shape* > shapeList;

    FindTG_ShapeWildCards( shapeList, pShape, "STANDARD" );
      
    pInfo->m_cStandardMatCount = (unsigned char)shapeList.size( );
    pInfo->m_cStandardMaterials = new char*[pInfo->m_cStandardMatCount];
    
    pInfo->m_cTextObjectID2 = pInfo->m_cTextObjectID = -1;
    
    int i = 0;
    for( list< TG_Shape* >::iterator iter = shapeList.begin(); 
        iter != shapeList.end(); iter++ )
    {
        
        pInfo->m_cStandardMaterials[i] = new char[strlen((*iter)->GetNodeName())+1];
        strcpy( pInfo->m_cStandardMaterials[i],(*iter)->GetNodeName() );
        size += strlen( pInfo->m_cStandardMaterials[i] );
        i++;
     }

    shapeList.clear();
    i = 0;

    FindTG_ShapeWildCards( shapeList, pShape, "EGGLOW" );
      
    pInfo->m_cEgglowMatCount = (char)shapeList.size( );
    pInfo->m_cEgglowMaterials = new char*[pInfo->m_cEgglowMatCount];
    for( iter = shapeList.begin(); 
        iter != shapeList.end(); iter++ )
    {
        
        pInfo->m_cEgglowMaterials[i] = new char[strlen((*iter)->GetNodeName())+1];
        strcpy( pInfo->m_cEgglowMaterials[i],(*iter)->GetNodeName() );
        size += strlen( pInfo->m_cEgglowMaterials[i] );
    }

    shapeList.clear();

    FindTG_ShapeWildCards( shapeList, pShape, "TEXT" );
    if ( shapeList.size() )
    {
        ASSERT( shapeList.size() == 1 || shapeList.size() == 2); // two texts per button????

      iter = shapeList.begin();
      (*iter)->GetNodeCenter( pInfo->m_fXLoc, z, pInfo->m_fYLoc );

        if ( shapeList.size() == 1 )
        {

            pInfo->m_cTextObjectID = (char)m_TextCount;
            CreateTextObject( (*iter), pNameInCSV );   
        }
        else if ( shapeList.size() == 2 )
        {
            char ID1 = (char)m_TextCount;
            char ID2 = (char)m_TextCount+1;

            float fY1, fY2, fX1, fX2;

            iter = shapeList.begin();

            //pInfo->m_cTextObjectID = (char)m_TextCount;
            float z;
            CreateTextObject( (*iter), pNameInCSV );
            (*iter)->GetNodeCenter( fX1, z, fY1);
            
            iter ++;
            CreateTextObject( (*iter), pNameInCSV );
            (*iter)->GetNodeCenter( fX2, z, fY2 );

            // OK, now figure out which one is on top
            if ( fY1 > fY2 )
            {
                pInfo->m_cTextObjectID = ID1;
                pInfo->m_cTextObjectID2 = ID2;
            }
            else if ( fY2 > fY1 )
            {
                pInfo->m_cTextObjectID = ID2;
                pInfo->m_cTextObjectID2 = ID1;
            }
            else if ( fX1 < fX2 )
            {
              pInfo->m_cTextObjectID = ID1;
              pInfo->m_cTextObjectID2 = ID2;  
            }
            else
            {
                 pInfo->m_cTextObjectID = ID1;
                 pInfo->m_cTextObjectID2 = ID2;   
            }
        }
    }

    

     
    strcpy( pInfo->m_TG_ShapeID, pShape->GetNodeName() );
    m_ButtonCount++;
    pInfo->m_nButtonSize = size;
    m_ButtonList.push_back( pInfo );

    return S_OK;
}

void ASEScene::FindTG_ShapeWildCards( list< TG_Shape* >& shapeList, 
                                     TG_Shape* pShape, const char* pWildCard )
{
    TG_Shape* pChild = pShape->GetFirstChild();
    while( pChild )
    {
        const char* pNodeID = pChild->GetNodeName();
        if ( pNodeID && strstr( pNodeID, pWildCard ) != NULL )
        {
            shapeList.push_back( pChild );
        }

        FindTG_ShapeWildCards( shapeList, pChild, pWildCard );


        pChild = pChild->GetNextChild( pChild );

    }

}

//////////////////////////////////////////////////////////////////////////////
// Create's a text object
HRESULT ASEScene::CreateTextObject( TG_Shape* pShape, const char* pNameInCSV )
{
    TextInfo* pInfo = new TextInfo();
    const char* pName = pShape->GetNodeName();
    char* pAttributeStr = strstr( pName, "TEXT_" );
    pAttributeStr += strlen( "TEXT_" );
  
     pInfo->m_nFontType = 0;

    // OK, here we need to look up the real values somewhere....
    pInfo->m_bIsHelpText = strstr( pName, "HELP" ) || strstr( pName, "META" ) ? 1 : 0;
    pInfo->m_fScaleX = .1f;
    pInfo->m_fScaleY = .1f;
    pInfo->m_fScrollDelay = 0.f;
    pInfo->m_fScrollRate = 0.f;
    pInfo->m_fTimeToScroll = 0.f;
    pInfo->m_nFontType = 0;
    pInfo->m_pTextID = NULL;
    pInfo->m_cHorizontalAlignment = 'C';
    pInfo->m_cVerticalAlignment = 'C';
    pInfo->m_bSingleLine = 1;

    char textPath[256];
    strcpy( textPath, MEDIA_PATH_ANSI );
    strcat( textPath, "text.csv" );
    File csvFile;
    csvFile.open( textPath, MC2_APPEND );




    // now figure out height and width.... these should be in model coords since the
    // text WILL move and stuff
    pShape->GetRectDimsRecenterBuildRotation( pInfo->m_fWidth, pInfo->m_fHeight );

    strcpy( pInfo->m_TG_ShapeID, pShape->GetNodeName() );

    m_TextList.push_back( pInfo );
    m_TextCount++;

    //set up string info...
    bool bFound = false;
    for ( std::list< StringInfo* >::iterator iter = m_StringList.begin();
        iter != m_StringList.end(); iter++ )
        {
            if ( _stricmp( (*iter)->m_szFileName, pNameInCSV ) == 0 )
            {
                if ( _stricmp( pInfo->m_TG_ShapeID, (*iter)->m_TG_ShapeID ) == 0 )
                {
                    pInfo->m_fScaleX = (*iter)->m_fXScale;
                    pInfo->m_fScaleY = (*iter)->m_fYScale;
                    pInfo->m_pTextID = new TCHAR[strlen((*iter)->m_TextID)+1];
                    Unicode( pInfo->m_pTextID, (*iter)->m_TextID, strlen((*iter)->m_TextID)+1 );
                    pInfo->m_bLocalize = (*iter)->m_bLocalize;
                    pInfo->m_fScrollRate = (*iter)->m_fScrollRate;
                    pInfo->m_fScrollDelay = (*iter)->m_fScrollDelay;
                    pInfo->m_cHorizontalAlignment = (*iter)->m_cHorizAlignment;
                    pInfo->m_cVerticalAlignment = (*iter)->m_cVertAlignment;
                    pInfo->m_bSingleLine = !(*iter)->m_bMultiLine;
                    pInfo->m_nFontType = (*iter)->m_Font;
                    pInfo->m_bIsHelpText = (*iter)->m_bHelp;

                    bFound = true;
                }
            }
        }
 
        if ( !bFound )
        {
            char errorStr[256];
            sprintf( errorStr, "Couldn't find string info for %s", pInfo->m_TG_ShapeID );
            ASSERT( !"Missing string info!" );

            ASSERT( "Missing StringInfo" );
            sprintf( errorStr, "%s,%s,%s,1,.1,.1,0,0,C,C,0,0", pNameInCSV, pShape->GetNodeName(), "Done" );
            csvFile.writeLine( errorStr );

            pInfo->m_pTextID = new TCHAR[_tcslen( _T("Missing Text" ) )+1];
            _tcscpy( pInfo->m_pTextID, _T("Missing Text" ) );
        }


     int len = pInfo->m_pTextID ? _tcslen( pInfo->m_pTextID ) : 0;
     pInfo->m_nTextInfoSize = sizeof( TextInfo ) + len * sizeof( TCHAR ) - sizeof( TCHAR*);


     csvFile.close();
    return S_OK;
}


//////////////////////////////////////////////////////////////////////////////
// Create's a spinner object -- i.e. one button
HRESULT ASEScene::CreateSpinner(TG_Shape* pShape, const char* pNameInCSV )
{
    char cSpinnerButtonID = -1;

    TG_Shape* pChild = pShape->GetFirstChild();
    while( pChild  )
    {
        const char* pChildName = pChild->GetNodeName();
        if ( -1 == cSpinnerButtonID && strstr( pChildName, "BUTTON_" ) )
        {
            CreateButtonObject( pChild, pNameInCSV );
        }

        pChild = pShape->GetNextChild( pChild );

        if ( cSpinnerButtonID != -1 )
            break;
    }

    // we're out of children, make sure we got all three needed items
    ASSERT( cSpinnerButtonID != -1 );

    SpinnerInfo* pSpinner = new SpinnerInfo;

    pSpinner->m_pButton = m_ButtonList.back();

    strcpy( pSpinner->m_TG_ShapeID, pShape->GetNodeName() );

    m_SpinnerList.push_back( pSpinner );
    m_SpinnerCount++;

    return S_OK;

}


//////////////////////////////////////////////////////////////////////////////
// create's a list group, which is a series of buttons 
HRESULT ASEScene::CreateListBox( TG_Shape* pShape, const char* pNameInCSV )
{
    ListBoxInfo* pInfo = new ListBoxInfo;
    strcpy( pInfo->m_TG_ShapeID, pShape->GetNodeName() );
    TG_Shape* pChild = pShape->GetFirstChild();
    
    while( pChild  )
    {
        const char* pChildName = pChild->GetNodeName();
        if ( strstr( pChildName, "BUTTON" ) )
        {
            CreateButtonObject( pChild, pNameInCSV );
            pInfo->m_buttonList.push_back( m_ButtonList.back() );

        }    
        
        pChild = pShape->GetNextChild( pChild );
    }


    m_ListBoxList.push_back(pInfo);
    m_ListBoxCount++;

    return S_OK;


}


//////////////////////////////////////////////////////////////////////////////
HRESULT ASEScene::SaveBinary( const char* strFilename  )
{
   
    // Open the file to write
    File file;
    if ( NO_ERR != file.create( strFilename ) )
    {
        char ErrorStr[256];
        sprintf( ErrorStr, "Couldn't open file %s", strFilename );
        DbgPrint( ErrorStr );
        ASSERT(!"XBG file marked as read-only\n");
        return -1;
    }

    // need to do this first so we recenter text...
    CreateIntelligentObjects( m_pRoot, m_SceneStringNames[0] );


    m_pRoot->SaveBinary( &file );

    m_Camera.SaveBinary( &file );


    file.writeLong( m_SceneStringNameCount );

    long beginningOfSubsets = file.getLogicalPosition();

    long* subSets = (long*)_alloca( sizeof( long ) * m_SceneStringNameCount );

    // pad for header info
    for ( int i = 0; i < m_SceneStringNameCount; i++ )
    {
        
        file.writeString( m_SceneStringNames[i] );
        file.writeLong( 0 );        
        subSets[i] = 0;
    }

    for ( int i = 0; i < m_SceneStringNameCount; i++ )
    {
        subSets[i] = file.getLogicalPosition();

		ClearIntelligentObjects();

        CreateIntelligentObjects( m_pRoot, m_SceneStringNames[i] );
        SortButtons(m_SceneStringNames[i]);

        file.writeLong( m_TextCount );
        file.writeLong( m_ButtonCount );
        file.writeLong( 0 ); // padding
        file.writeLong( 0 );
        file.writeLong( m_ListBoxCount );
        file.writeLong( m_SpinnerCount );

        long nOffsetPos = file.getLogicalPosition();
        // Pad the offsets
        for ( int i = 0; i < 4; i++ )
        {
            file.writeLong( 0 );
        }
    
        long nTextOffset = file.getLogicalPosition();
        WriteTexts( &file );
        long nButtonOffset = file.getLogicalPosition();
        WriteButtons( &file );
        long nListBoxOffset = file.getLogicalPosition();
        WriteListBoxes( &file);
        long nSpinnerOffset = file.getLogicalPosition();
        WriteSpinners( &file );

		long endOfFilePos = file.getLogicalPosition();
        file.seek( nOffsetPos );
        file.writeLong( nTextOffset );
        file.writeLong( nButtonOffset );
        file.writeLong( nListBoxOffset );
        file.writeLong( nSpinnerOffset );

		file.seek( endOfFilePos );
    }

     file.seek(beginningOfSubsets);

    // go back in and fill headers
    for ( int i = 0; i < m_SceneStringNameCount; i++ )
    {
   
        file.writeString( m_SceneStringNames[i] );
        file.writeLong( subSets[i] );        
    }


    return S_OK;

}

/////////////////////////////////////////////////////////////////
// writes all the info for a button object
void ASEScene::WriteButtons( File* pFile )
{
      
    long counter = 0;
    for ( std::list< ButtonInfo*>::iterator iter = m_ButtonList.begin();
        iter != m_ButtonList.end(); iter++, counter++ )
    {
        pFile->write( (BYTE*)(*iter), sizeof ( ButtonInfo ) - 2 * (sizeof ( char** ) ));
        for ( unsigned char i = 0; i < (*iter)->m_cStandardMatCount; i++ )
        {
            pFile->writeString( (*iter)->m_cStandardMaterials[i] );
        }
        for ( i = 0; i < (*iter)->m_cEgglowMatCount; i++ )
        {
            pFile->writeString( (*iter)->m_cEgglowMaterials[i] );
        }
         
         /*pFile->writeLong( (*iter)->m_nButtonSize );       // size of the particular ButtonInfo instance 
        pFile->write( (*iter).m_TG_ShapeID, NODE_NAME_LEN * sizeof( char ) );
        pFile->writeByte( (*iter).m_cTextObjectID );
        pFile->writeString( m_HelpTextID );
        pFile->writeByte( (*iter).m_cStandardMatCount );
        pFile->write( (*iter).m_cstandardMatCount );
        pFile->writeByte( (*iter).m_cEgglowMatCount );
        pFile->write( (*iter).m_cEgglowMaterials );*/
    }


}

////////////////////////////////////////////////////////////////////
// writes all the info for all the text objects
void ASEScene::WriteTexts( File* pFile )
{

    long counter = 0;
    for ( std::list< TextInfo*>::iterator iter = m_TextList.begin(); 
            iter != m_TextList.end(); iter++, counter++ )
    {

        pFile->write( (BYTE*)(*iter), sizeof( TextInfo ) - sizeof( TCHAR*) );
        if ( (*iter)->m_pTextID )
            pFile->write( (BYTE*)(*iter)->m_pTextID, (_tcslen((*iter)->m_pTextID) * sizeof( TCHAR ))  );
     /*   pFile->writeLong( m_nTextInfoSize );
        pFile->write( m_Tg_ShapeID, NODE_NAME_LEN * sizeof( char ) );
        pFile->writeChar( (*iter)->m_cVerticalAlignment );
        pFile->writeChar( (*iter)->m_cHorizontalAlignment );
        pFile->writeBoolean( (*iter)->m_bSingleLine );
        pFile->writeLong( (*iter)->m_nFontType );
        pFile->writeFloat( (*iter)->m_fWidth );
        pFile->writeFloat( (*iter)->m_fHeight );
        pFile->writeByte( (*iter)->m_bIsHelpText );
        pFile->writeFloat( (*iter)->m_fScaleX );
        pFile->writeFloat( (*iter)->m_fScaleY );
        pFile->writeFloat( (*iter)->m_fScaleScrollRate );
        pFile->writeFloat( (*iter)->m_fScaleScrollDelay );
        pFile->writeString( m_pTextID );*/

    }
}

////////////////////////////////////////////////////////////////////
// writes all the info for all the spinner objects
void ASEScene::WriteSpinners( File* pFile )
{
   
    long counter = 0;
    for ( std::list< SpinnerInfo*>::iterator iter = m_SpinnerList.begin(); 
            iter != m_SpinnerList.end(); iter++, counter++ )
    {
       pFile->write( (BYTE*)(*iter)->m_TG_ShapeID, sizeof ( (*iter)->m_TG_ShapeID ) );
      
       unsigned char finder = 0;

       // we have to do this because we sadly sorted all the buttons earlier
       for ( std::list< ButtonInfo*>::iterator buttonIter = m_ButtonList.begin();
            buttonIter != m_ButtonList.end(); buttonIter ++ )
            {
                if ( (*buttonIter == (*iter)->m_pButton ) )
                {
                    pFile->writeByte( finder );
                    break;
                }
                finder++;
            }
     }
}

////////////////////////////////////////////////////////////////////
// writes all the info for all the list box objects
void ASEScene::WriteListBoxes( File* pFile )
{

    long counter = 0;
    for ( std::list< ListBoxInfo*>::iterator iter = m_ListBoxList.begin(); 
        iter != m_ListBoxList.end(); iter++, counter++ )
    {
       pFile->write( (unsigned char*)(*iter)->m_TG_ShapeID, sizeof ( (*iter)->m_TG_ShapeID ) );
       pFile->writeByte( (unsigned char)(*iter)->m_buttonList.size() );

         for ( std::list< ButtonInfo*>::iterator lbIter = (*iter)->m_buttonList.begin();
            lbIter !=  (*iter)->m_buttonList.end(); lbIter ++ )
            {
 
                long finder = 0;

                for ( std::list< ButtonInfo*>::iterator buttonIter = m_ButtonList.begin();
                    buttonIter != m_ButtonList.end(); buttonIter ++ )
                {
                    if ( (*buttonIter == *lbIter ) )
                    {
                        pFile->writeByte( (unsigned char)finder );
                        break;
                    }
                    finder++;
                }
            }   

    }
}

void ASEScene::SortButtons( const char* pNameOfId )
{
 
    float tolerance = .01f;
    float linebreak = .25;

    // HACK -- the keyboard needs a crazy big tolerance to work
    if ( _stricmp( m_SceneName, "Keyboard" ) == 0 )
    {
        tolerance = .025f;
        linebreak = .025f;
    }

     
    // first need to sort vertically
    if ( m_ButtonList.size() )
    {

        for (std::list< ButtonInfo*>::iterator iter = m_ButtonList.begin();
            iter != m_ButtonList.end(); iter++ )
        {
                float curY = (*iter)->m_fYLoc;
                float curX = (*iter)->m_fXLoc;
                for ( std::list< ButtonInfo* >::iterator inner = m_ButtonList.begin();
                    inner != iter; inner++ )
                {
                    float prevX = (*inner)->m_fXLoc;
                    float prevY = (*inner)->m_fYLoc;

                    if ( (prevY < curY) && fabs( prevY - curY ) > tolerance )
                    {
                        m_ButtonList.insert( inner, (*iter) );
                        m_ButtonList.erase( iter );
                        iter = inner;
                        break;

                    }             
                    
                }
                  
         }
//        std::list< ButtonInfo*>::iterator lastIter = m_ButtonList.begin();
        
        for (std::list< ButtonInfo*>::iterator iter = m_ButtonList.begin();
            iter != m_ButtonList.end(); iter++ )
        {
                float curY = (*iter)->m_fYLoc;
                float curX = (*iter)->m_fXLoc;
                for ( std::list< ButtonInfo* >::iterator inner = m_ButtonList.begin();
                    inner != iter; inner++ )
                {
                    float prevX = (*inner)->m_fXLoc;
                    float prevY = (*inner)->m_fYLoc;

                    if ( fabs( prevY - curY ) < linebreak &&  prevX - curX > tolerance  )
                    {
                        m_ButtonList.insert( inner, (*iter) );
                        m_ButtonList.erase( iter );
                        iter = inner;
                        break;
                    }
              
                    
                }
                  
         }

 

        long firstVert = 0;
        long firstHoriz = 0;
        if ( m_ButtonList.size() )
        {
            iter = m_ButtonList.begin();
            float xPrev    =(*iter)->m_fXLoc;
            float yPrev     = (*iter)->m_fYLoc;
            long  count = 0;
            iter++;
            bool bSetPrev = 0;
            // now go back and find the first horizontal and fist vertical
            for (iter = m_ButtonList.begin(); iter != m_ButtonList.end(); iter++, count++ )
            {
                (*iter)->m_buttonEnumID = eNullButtonId;
                bool bFoundId = 0;
                char* pLookupName = strstr( (*iter)->m_TG_ShapeID, "BUTTON_" );

                if ( pLookupName )
                {
                    char finalName[256];
                    sprintf( finalName, "%s%s", pNameOfId, pLookupName + strlen( "BUTTON_" ) );
                    for ( long i =0; i < (long)eLastButtonId; i++ )
                    {
                        if ( _stricmp( ButtonName[i], finalName ) == 0 )
                        {
                            (*iter)->m_buttonEnumID = i;
                            bFoundId = true;
                            break;
                        }
                    }
                }

                ASSERT( bFoundId );
                if ( !bFoundId )
                {
                    char tmpStr[256];
                    sprintf( tmpStr, "Couldn't find ID for %lf, %lf, %s, \n", (*iter)->m_fXLoc, (*iter)->m_fYLoc, (*iter)->m_TG_ShapeID );
                    DbgPrint( tmpStr ); 
                }
                if ( fabs((*iter)->m_fXLoc - xPrev) < .01) 
                {
                    (*iter)->m_orientation = eButtonVerticalOrientation;
                    bSetPrev = false;

                    if ( bSetPrev )
                    {
                       std::list< ButtonInfo*>::iterator prevIter = iter;
                       prevIter --;
                       (*iter)->m_orientation = eButtonVerticalOrientation;
                    }
                }
                else if ( fabs((*iter)->m_fYLoc - yPrev) < .01)
                {
                    (*iter)->m_orientation = eButtonHorizontalOrientation;
                    bSetPrev = false;

                    if ( bSetPrev )
                    {
                       std::list< ButtonInfo*>::iterator prevIter = iter;
                       prevIter --;
                       (*iter)->m_orientation = eButtonHorizontalOrientation;
                    }
                }
                else
                {
                    bSetPrev = true;
                }

               

                yPrev = (*iter)->m_fYLoc;
                xPrev    =(*iter)->m_fXLoc;
            }

            iter = m_ButtonList.begin();
            std::list< ButtonInfo*>::iterator tmpIter = iter;
            iter++;
            if ( iter != m_ButtonList.end() )
            {
                (*tmpIter)->m_orientation = (*iter)->m_orientation;
            }
        }

    }
}

void    ASEScene::LoadStrings( CSVFile* pFile, const char* aseName, const char** pSceneName, long sceneCount )
{
    strcpy( m_SceneName, aseName );

    if ( sceneCount )
    {
        m_SceneStringNameCount = sceneCount;
        m_SceneStringNames = new char*[sceneCount];
        for ( int i = 0; i < sceneCount; i++ )
        {
            m_SceneStringNames[i] = new char[strlen( pSceneName[i] ) + 1];
            strcpy( m_SceneStringNames[i], pSceneName[i] );
        }
    }
    
    for ( int i = 0; i < pFile->getTotalRows(); i++ )
    {
        char sceneName[256];
        pFile->readString( i+1, 1, sceneName, 255 );

        for ( int j = 0; j < sceneCount; j++ )
        {

            if ( _stricmp( sceneName, pSceneName[j] ) == 0 ) // only load ones for this scene
            {
                StringInfo* pInfo = new StringInfo;
                strcpy( pInfo->m_szFileName, pSceneName[j] );
                pFile->readString( i+1, 2, pInfo->m_TG_ShapeID, NODE_NAME_LEN ); 
                pFile->readString( i+1, 3, pInfo->m_TextID, 63 );
                CharUpperA( pInfo->m_TextID );
                pFile->readBoolean( i+1, 4, pInfo->m_bLocalize );
                pFile->readFloat( i+1, 5, pInfo->m_fXScale );
                pFile->readFloat( i+1, 6, pInfo->m_fYScale );
                pFile->readFloat( i+1, 7, pInfo->m_fScrollRate );
                pFile->readFloat( i+1, 8, pInfo->m_fScrollDelay );
                pFile->readChar( i+1, 9,  pInfo->m_cHorizAlignment );
                pFile->readChar( i+1, 10, pInfo->m_cVertAlignment );
                pFile->readBoolean( i+1, 11, pInfo->m_bMultiLine );
                pFile->readLong( i+1, 12, (long&) pInfo->m_Font ); 
                pFile->readBoolean( i+1, 13, pInfo->m_bHelp );

  

                m_StringList.push_back( pInfo );
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\voice\queuexmop.h ===
//-----------------------------------------------------------------------------
// File: QueueXMOp.h
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef QUEUEXMOP_H_INCLUDED
#define QUEUEXMOP_H_INCLUDED

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef VOICEPEERAFX_H
#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <stddef.h>
#include <ntos.h>

#ifdef __cplusplus
}
#endif // __cplusplus
#endif
#define  NODSOUND
#include <xtl.h>
#include <dsound.h>
#include "xvoice.h"
#include <assert.h>


//
// Typedefs
//
//////////////////////////////////////////////////////////////////////////////
typedef DWORD TimeStamp;
typedef DWORD TimeInterval;

//
// Constants
//
//////////////////////////////////////////////////////////////////////////////
const WORD MAX_MILISECONDS_OF_ATTENUATED_VOICE = 80;

//
// Debug Tools
//
//////////////////////////////////////////////////////////////////////////////
extern "C"
{
	ULONG __cdecl
	DebugPrint(
		PCHAR Format,
		...
		);
}

#define VERIFY_SUCCESS(xprsn) \
{\
    HRESULT hrTemp = (xprsn);\
    if(!SUCCEEDED(hrTemp))\
    {\
        DebugPrint("Call failed: %s(%d): 0x%0.8x\n", __FILE__, __LINE__, hrTemp);\
    }\
}

//
// Structures
//
//////////////////////////////////////////////////////////////////////////////
struct BufferList
{
	TimeStamp		m_timestamp;
	BYTE			*m_pbBuffer;
	BufferList      *m_pPrev;
	BufferList      *m_pNext;
	
	BufferList() : m_timestamp(0), m_pbBuffer(NULL) , m_pPrev(NULL), m_pNext(NULL){}
	~BufferList(){}
};

//
// Class CQueueXMO
//
//////////////////////////////////////////////////////////////////////////////
class CQueueXMO:public XVoiceQueueMediaObject 
{
public:
	//
    // Construction/Destruction
    //
	CQueueXMO() : m_cRef(1),
	              m_pBufferPool(NULL),
				  m_pHeapForBuffers(NULL),
		          m_pFreeEntriesList(NULL),
				  m_pInUseEntriesListHead(NULL),
				  m_pInUseEntriesListTail(NULL),
				  m_LogicalOutputTime(0),
				  m_RealStartOutputTime(0),
				  m_wCurrentSeqNo(0),
				  m_pDecoder(NULL) ,
      			  m_wInUseEntriesCount(0),
				  m_bStartTiming(FALSE),
				  m_pdHighWaterMarkQuality(NULL),
				  m_pSavedBuffer(NULL),
				  m_bVoiceReturned(TRUE)
	{
		m_LastOutputInfo.cbSize = sizeof(PCM_INFO);
		m_LastOutputInfo.nMaxPower = 0; // no voice
	}

	virtual ~CQueueXMO()
	{
		Cleanup();
	}


	//
    // Initialization
    //
	HRESULT STDMETHODCALLTYPE Initialize( LPQUEUE_XMO_CONFIG pConfig );

	//
    // IUnknown Methods
    //
    virtual STDMETHODIMP_(ULONG) AddRef( void ) 
	{
       return InterlockedIncrement( (long*) &m_cRef );
    }

    virtual STDMETHODIMP_(ULONG) Release( void ) 
	{
       long l = InterlockedDecrement( (long*) &m_cRef );

       if ( l == 0 )
	   {
          delete this;
	   }

       return l;
    }
    
	//
    // XMediaObject methods
    //
    virtual HRESULT STDMETHODCALLTYPE Flush( void )
    {
		m_wHighWaterMark = 0;
        return QUEUE_S_OK;
    }

    virtual HRESULT STDMETHODCALLTYPE Discontinuity( void )
    {
        return QUEUE_S_OK;
    }

    virtual HRESULT STDMETHODCALLTYPE GetStatus( LPDWORD pdwStatus )
    {
        return QUEUE_S_OK;
    }

	virtual HRESULT STDMETHODCALLTYPE GetInfo( LPXMEDIAINFO pXMediaInfo )
	{
		return QUEUE_S_OK;
	}
    virtual HRESULT STDMETHODCALLTYPE Process( LPCXMEDIAPACKET pSrcBuffer, LPCXMEDIAPACKET pDstBuffer );

	
	//
    // XVoiceQueueMediaObject methods
    //
    virtual HRESULT STDMETHODCALLTYPE GetLastOutputInfo(LPPCM_INFO pPCMInfo);

protected:
	void Cleanup();
	void SetConfigDefaults(LPQUEUE_XMO_CONFIG pConfig);
	ULONG m_cRef;

	//
    // Specific queuing members
    //
protected:
	BufferList       *m_pBufferPool;         // The array of BufferList from which the Free and InUse lists are composed
	BYTE             *m_pHeapForBuffers;     // Amount of contigous memory for the actual codec buffers
	WORD              m_wBufferPoolSize ;    // Maximum number of free buffers
	WORD              m_wMsOfDataPerBuffer;  // Miliseconds of compressed data in a codec buffer
	WORD              m_wXVoiceBufferSize;   // Size of decompressed data in bytes
	WORD              m_wCodecBufferSize;    // Size of codec buffer in bytes(contains header + compressed voice)

	BufferList       *m_pFreeEntriesList;       // Double linked list of free buffers to be used to get the input from process
	BufferList       *m_pInUseEntriesListHead;  // Double linked list of buffers to be used to process input data
	BufferList       *m_pInUseEntriesListTail;  // End of in use list

	TimeStamp         m_LogicalOutputTime;   // Time for an input packet to be introduced into the output stream
	TimeStamp         m_PreviousTime;        // Most recent time a packet was introduced into the output stream
	TimeStamp         m_RealStartOutputTime; // The real time that the output process began with; reference time
	WORD              m_wCurrentSeqNo;       // Sequence number for the current received packet
	WORD              m_wSafeDeltaSeq;       // Safe difference between input sequence numbers

	XMediaObject     *m_pDecoder;            // Decoder XMO
	WORD			  m_wHighWaterMark;      // Current high water mark(in miliseconds)
	WORD			  m_wInUseEntriesCount;  // Number of buffers waiting to be decompressed 

	BOOL              m_bStartTiming;        // Start measuring real time of the queue

	DOUBLE            *m_pdHighWaterMarkQuality;    // Array that keeps the history of performances of the queue
	WORD	          m_wMaxHighWaterMark;			// Maximum delay for the queue in miliseconds
	WORD	          m_wMinHighWaterMark;			// Minimum delay for the queue in miliseconds
	WORD              m_wHighWaterMarkQualitySize;  // Size of the array

	DOUBLE            m_dIdealQuality;              // Ideal quality for high water mark 
	DOUBLE            m_dFrameStrength;             // Current frame strength
	DOUBLE            m_dCurrentTalkspurtWeighting; // Computed current talkspurt weighting
	WORD              m_wNumberOfFramesInTalkspurt; // Counter for each talkspurt
	BYTE              m_bCurrentTalkspurtID;        // The message ID of the current talkspurt
	WORD              m_wErrorCount;                // Number of errors in current talkspurt

	BYTE             *m_pSavedBuffer;          // Buffer saved between outputs in case of lost packets
	BOOL              m_bVoiceReturned;        // True if previous output buffer contained voice
	WORD              m_wAttenuatedBackupMs;   // Number of miliseconds of attenuated voice provided for lost voice

	PCM_INFO          m_LastOutputInfo;        // PCM info on the last returned buffer         

	//
    // Specific queuing methods
    //
protected:
	void RecomputeQueueParameters();
	void IncrementErrorCount(){ m_wErrorCount++; }
	void AddFreeBuffer(BufferList *pBuffer);
	HRESULT AddInUseBuffer(BufferList *pBuffer);

	BufferList* RemoveFirstBuffer(BufferList **pHead , BufferList **pTail = NULL);
	BufferList* GetInputWorkingBuffer();
	BufferList* GetOutputWorkingBuffer(BOOL *pbReturnSilence , BOOL *pbIsNextPacketLost);

	HRESULT OutputProcess(LPCXMEDIAPACKET pOutMediaPacket);
	HRESULT InputProcess(LPCXMEDIAPACKET pInMediaPacket);
	HRESULT DecompressMediaBuffer(BufferList *pSrc, LPCXMEDIAPACKET pDst);

	void CopyAttenuatedBuffer(LPCXMEDIAPACKET pOutMediaPacket , DOUBLE dAttenuationFactor);

};


#endif  // QUEUEXMOP_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\xodash\aseConv\ASEScene.h ===
#include "std.h"
#include "PrimitiveScene.h"
#include <list>

using namespace std;

#define NODE_NAME_LEN 64
class File;
class CSVFile;

  #pragma pack(1)

  struct ButtonInfo

    {

        long    m_nButtonSize;       // size of the particular ButtonInfo instance 
        char    m_cTextObjectID2;
        char    m_TG_ShapeID[NODE_NAME_LEN];   // ID of the base shape
        char    m_cTextObjectID;    // ID (index) of the text object defined below
        long    m_buttonEnumID;
        long    m_orientation;
        unsigned char       m_cStandardMatCount;   // TG_Shape info for setting materials
        unsigned char       m_cEgglowMatCount;
        float   m_fXLoc;
        float   m_fYLoc;
        char**  m_cStandardMaterials;
        char**  m_cEgglowMaterials;

    };
 

    struct TextInfo

    { 

        long  m_nTextInfoSize;  // the size of the particular TextInfo instance
        char    m_TG_ShapeID[NODE_NAME_LEN];       // ID of the base shape
        char    m_cVerticalAlignment;   // alignment
        char    m_cHorizontalAlignment; // alignment
        char    m_bSingleLine;          // wether this text wraps across multiple lines
        long    m_nFontType;            // body or header (NATALY, should this be a string?)  
        float   m_fHeight;              // height of the field
        float   m_fWidth;               // width of the field
        char    m_bIsHelpText;          // is this a help text
        float   m_fScaleX;              // text scale
        float   m_fScaleY;              // text scale
        float   m_fScrollRate;          
        float   m_fScrollDelay;
        float   m_fTimeToScroll;  
        bool    m_bLocalize;
        TCHAR*   m_pTextID;             // maybe an integer????  

    };


    struct SpinnerInfo
    {
        char    m_TG_ShapeID[NODE_NAME_LEN]; // ID of the base shape
        ButtonInfo* m_pButton;
    };


    struct ListBoxInfo
    {
        char    m_TG_ShapeID[NODE_NAME_LEN]; // ID of the base shape
        std::list< ButtonInfo* >  m_buttonList;
    };

    #pragma pack()

    struct StringInfo // read from csv
    {
       char     m_szFileName[64];                 // friendly name, first column of csv
       char     m_TG_ShapeID[NODE_NAME_LEN];     // shape this belongs to
       char     m_TextID[64];
       bool     m_bLocalize;
       float    m_fXScale;
       float    m_fYScale; 
       float    m_fScrollRate;
       float    m_fScrollDelay;
       char     m_cHorizAlignment;
       char     m_cVertAlignment;
       bool     m_bMultiLine;
       char     m_Font;
       bool     m_bHelp;


    };


class ASEScene : public CPrimitiveScene
{
 
    public:

    ASEScene();

    virtual ~ASEScene();
    
    // HELPER FUNCTIONS
    HRESULT CreateIntelligentObjects( TG_Shape* pShap, const char* pNameInCSV );
    HRESULT CreateButtonObject( TG_Shape* pShape, const char* pNameInCSV );
    HRESULT CreateTextObject( TG_Shape* pShape, const char* pNameInCSV );
    HRESULT CreateSpinner( TG_Shape* pShape, const char* pNameInCSV );
    HRESULT CreateListBox( TG_Shape* pShape, const char* pNameInCSV );



    void WriteButtons( File* file );
    void WriteTexts( File* file );
    void WriteSpinners( File* file );
    void WriteListBoxes( File* file );

    HRESULT SaveBinary( const char* strFilename  );


   	virtual void Load( const char* pBuffer );

    void    LoadStrings( CSVFile* pFile, const char* aseName, const char** pSceneName, long sceneCount   );

    void    FindTG_ShapeWildCards( std::list< TG_Shape* >&,TG_Shape* pShape,  const char* pWildCard );


    void    SortButtons(const char* pIDName );
    void    ClearIntelligentObjects();




    private:

        char    m_ButtonCount;
        char    m_TextCount;
        char    m_ListBoxCount;
        char    m_SpinnerCount;

        char    m_FirstHorizontalButton;
        char    m_FirstVerticalButton;

        long    m_ButtonOffset;     // offset to the first one in the file
        long    m_TextOffset;       // offset to the first one in the file
        long    m_ListBoxOffset;    // offset to the first one in the file
        long    m_SpinnerOffset;    // offset to the first one in the file

        char    m_SceneName[256];   // name of the ase file
        char**  m_SceneStringNames; // name in the csv file identifying strings
        long    m_SceneStringNameCount; // number of the above

        std::list< ButtonInfo*>  m_ButtonList;
        std::list< TextInfo* >    m_TextList;
        std::list< SpinnerInfo* > m_SpinnerList;
        std::list< ListBoxInfo* > m_ListBoxList;
        std::list< StringInfo* >  m_StringList;

};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\xodash\aseConv\ASEConv.h ===
//-----------------------------------------------------------------------------
// File: XODash.h
//
// Container for XOnline's dash.  Stolen from ATG
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef XBAPP_H
#define XBAPP_H

#include "std.h"
#include "XBInput.h"
#include "translator.h"


class ASEScene;

//-----------------------------------------------------------------------------
// Global access to common members
//-----------------------------------------------------------------------------
extern LPDIRECT3DDEVICE8 g_pd3dDevice;




//-----------------------------------------------------------------------------
// Name: class XOApplication
// Desc: holds all really high level objects, sets up D3D
//          Initialize()          - To initialize the device-dependant objects
//          FrameMove()           - To animate the scene
//          Render()              - To render the scene
//-----------------------------------------------------------------------------
class ASEConv
{
protected:
    // Main objects used for creating and rendering the 3D scene
    D3DPRESENT_PARAMETERS m_d3dpp;
    LPDIRECT3D8           m_pD3D;              // The D3D enumerator object
    LPDIRECT3DDEVICE8     m_pd3dDevice;        // The D3D rendering device
    LPDIRECT3DSURFACE8    m_pBackBuffer;       // The backbuffer
    LPDIRECT3DSURFACE8    m_pDepthBuffer;      // The depthbuffer

    // Variables for timing
    FLOAT      m_fTime;             // Current absolute time in seconds
    FLOAT      m_fElapsedTime;      // Elapsed absolute time since last frame
    FLOAT      m_fAppTime;          // Current app time in seconds
    FLOAT      m_fElapsedAppTime;   // Elapsed app time since last frame
    BOOL       m_bPaused;           // Whether app time is paused by user
    FLOAT      m_fFPS;              // Instanteous frame rate
    WCHAR      m_strFrameRate[20];  // Frame rate written to a string
    HANDLE     m_hFrameCounter;     // Handle to framerate perf counter

	ASEScene*			m_pScene;		// currently rendered scene


    // Members to init the XINPUT devices.
    XDEVICE_PREALLOC_TYPE* m_InputDeviceTypes;
    DWORD                  m_dwNumInputDeviceTypes;
    XBGAMEPAD*             m_Gamepad;
    XBGAMEPAD              m_DefaultGamepad;


    // Helper functions
    HRESULT RenderGradientBackground( DWORD dwTopColor, DWORD dwBottomColor );

    // Overridable functions for the 3D scene created by the app
    virtual HRESULT Initialize();
    virtual HRESULT FrameMove();
    virtual HRESULT Render();
    virtual HRESULT Cleanup();
	HRESULT Update();

public:

	TCHAR					m_szAppDir[MAX_PATH];

    ULONG                   curFile;

    // Functions to create, run, and clean up the application
    HRESULT Create();
    INT     Run();
    VOID    Destroy();

    // Internal constructor
    ASEConv();
    ~ASEConv();

	float	GetTime(){ return m_fAppTime; }

    void    GetFilesToOpen( const char* path, const char* pExtension );


private:

    struct  XBGFileData
    {
        char*   m_pAseName;
        char**   m_pTextButtonNames;
        long    m_nTextButtonCount;

    };

    XBGFileData*        m_ConvertedFiles;
    ULONG                m_nConvertedFileCount;
	
    HRESULT InitAudio();
};


extern ASEConv	theApp; // the single instance


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\xodash\aseConv\main.cpp ===
#include "std.h"
#include "ASEConv.h"


ASEConv  theApp;
void __cdecl main()
{
	theApp.Create();
	while (1)
	{
		theApp.Run();
	}

	theApp.Destroy();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\xodash\aseConv\std.h ===
#ifdef _XBOX
#ifdef __cplusplus
extern "C" {
#endif // __cplusplus
#include <ntos.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntdddisk.h>
#include <ntddcdrm.h>
#include <ntddscsi.h>
#include <ntddcdvd.h>
#include <smcdef.h>
#include <scsi.h>
#include <init.h>
#ifdef __cplusplus
}
#endif // __cplusplus
#include <dsoundp.h>
#include <xtl.h>
#include <xgraphics.h>
#include <xboxp.h>
#include <xapip.h>
#include <av.h>
#include "xonlinep.h"


#ifndef D3DLOCK_DISCARD
#define D3DLOCK_DISCARD 0
#endif

#endif

#ifdef _WINDOWS
#include <winsock2.h>
#include <windows.h>
#endif

#include <tchar.h>
typedef TCHAR* PTCHAR;

// "Filesystem" Character Type...What do *most* of the file system API's use...
#if defined(_XBOX)
typedef char FSCHAR;
#define _FS(s) s
#else
typedef TCHAR FSCHAR;
#define _FS(s) _T(s)
#endif

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <stdarg.h>
#include <math.h>

#include <crtdbg.h>

#if !defined(_NOD3D)
#define D3D_OVERLOADS
#include <d3d8.h>
#include <d3dx8.h>

#endif

#define ASSERTHR(f)		do { HRESULT hrverify = (f); if (FAILED(hrverify) && AssertFailed(_T(__FILE__), __LINE__, hrverify)) _CrtDbgBreak(); } while (0)
#define VERIFYHR(f)		ASSERTHR(f)
EXTERN_C bool AssertFailed(const TCHAR* szFile, int nLine, HRESULT hr);
#define BREAKONFAIL(a,b)  {if(FAILED(a)) {DbgPrint(b);break;} }

/*
#undef TRACE
#ifdef _DEBUG
#define TRACE Trace
#define TRACEFILE TraceInFile
extern "C" void Trace(char* szMsg, ...);
extern "C" void TraceInFile(char* szMsg, ...);
#endif
*/
/*
#ifdef _UNICODE
extern void Unicode(TCHAR* wsz, const char* sz, int nMaxChars);
extern void Ansi(char* sz, const TCHAR* wsz, int nMaxChars);
#endif

#undef ASSERT
#undef VERIFY
#undef ASSERTHR
#undef VERIFYHR
#undef TRACE
#undef ALERT

#ifdef _DEBUG

#define ASSERT(f)		if (!(f)) RtlAssert(#f, __FILE__, __LINE__, NULL)
#define VERIFY(f)		ASSERT(f)
#define ASSERTHR(f)		do { HRESULT hrverify = (f); if (FAILED(hrverify) && AssertFailed(_T(__FILE__), __LINE__, hrverify)) _CrtDbgBreak(); } while (0)
#define VERIFYHR(f)		ASSERTHR(f)
#define TRACE			Trace
#define ALERT			Alert

EXTERN_C bool AssertFailed(const TCHAR* szFile, int nLine, HRESULT hr);
EXTERN_C void Trace(const TCHAR* szMsg, ...);

#else // !_DEBUG

#define ASSERT(f)		((void)0)
#define VERIFY(f)		((void)(f))
#define ASSERTHR(f)		((void)0)
#define VERIFYHR(f)		((void)(f))
#define TRACE			1 ? (void)0 : Trace
#define ALERT			1 ? (void)0 : Alert

inline void Trace(const TCHAR* szMsg, ...) { }

#endif

EXTERN_C void Alert(const TCHAR* szMsg, ...);


////////////////////////////////////////////////////////////////////////////

#ifdef _XBOX
#include "xprofp.h"

#ifdef _PROFILE
#define START_PROFILE() XProfpControl(XPROF_START, 0)
#define END_PROFILE() XProfpControl(XPROF_STOP, 0)
#else
#define START_PROFILE()
#define END_PROFILE()
#endif
#else
#define START_PROFILE()
#define END_PROFILE()
#endif

*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\xodash\aseConv\csvfile.h ===
//---------------------------------------------------------------------------
//
// csvfile.h - This file contains the class declaration for the CSV Files
//
//				The CSV file is an Excel csv style file.
//
//	MechCommander 2 -- Microsoft
//
//	Copyright (c) 1999 Microsoft
//
//
//---------------------------------------------------------------------------

#ifndef CSVFILE_H
#define CSVFILE_H
//---------------------------------------------------------------------------
// Include files
#ifndef FILE_H
#include "file.h"
#endif

//---------------------------------------------------------------------------
// Macro Definitions

//---------------------------------------------------------------------------
// Enums

//---------------------------------------------------------------------------
// Structs

//---------------------------------------------------------------------------
//									CSVFile
class CSVFile : public File
{
	// Data Members
	//--------------
	protected:
		DWORD totalRows;			//Number of ROWS CSV file has.
		DWORD totalCols;			//NUmber of COLS CSV file has.
		
		char dataBuffer[2048];

	// Member Functions
	//------------------
	protected:
		long afterOpen (void);
		void atClose (void);

     	long countRows (void);
    	long countCols (void);
	
		long getNextWord (char *&line, char *buffer, unsigned long bufLen);

		float textToFloat (char *num);
		
		long textToLong (char *num);
		unsigned long textToULong (char *num);
		
		short textToShort (char *num);
		unsigned short textToUShort (char *num);
		
		char textToChar (char *num);
		unsigned char textToUChar (char *num);

		bool booleanToLong (char *num);

		long floatToText (char *result, float num, unsigned long bufLen);
		
		long longToTextDec (char *result, long num, unsigned long bufLen);
		long longToTextHex (char *result, long num, unsigned long bufLen);

		long shortToTextDec (char *result, short num, unsigned long bufLen);
		long shortToTextHex (char *result, short num, unsigned long bufLen);

		long byteToTextDec (char *result, byte num, unsigned long bufLen);	
		long byteToTextHex (char *result, byte num, unsigned long bufLen);
		
		long copyString (char* dest, char *src, unsigned long bufLen);

	public:
		CSVFile (void);
		~CSVFile (void);

		virtual long open (const char* fName, FileMode _mode = READ, long numChildren = 50);
		virtual long open (File* _parent, unsigned long fileSize, long numChildren = 50);
		
		virtual long create (char* fName);

		virtual void close (void);

		virtual FileClass getFileClass (void)
		{
			return CSVFILE;
		}

        long getTotalRows() const { return totalRows; }
        long getTotalCols() const { return totalCols; }
		


		long seekRowCol (DWORD row, DWORD col);
		
		long readFloat (DWORD row, DWORD col, float &value);
		
		long readBoolean (DWORD row, DWORD col, bool &value);
		long readLong (DWORD row, DWORD col, long &value);
		long readULong (DWORD row, DWORD col, unsigned long &value);
		
		long readShort (DWORD row, DWORD col, short &value);
		long readUShort (DWORD row, DWORD col, unsigned short &value);
		
		long readChar (DWORD row, DWORD col, char &value);
		long readUChar (DWORD row, DWORD col, unsigned char &value);
		
		long readString (DWORD row, DWORD col, char *result, unsigned long bufferSize);
};

//---------------------------------------------------------------------------
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\xodash\imageConv\basetexture.cpp ===
//-----------------------------------------------------------------------------
// File: BaseTexture.cpp
//
// Desc: Contains the basic texture-specific logic for the bundler tool
//
// Hist: 04.13.01 - New for May XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <stdio.h>
#include "BaseTexture.h"
#include "Bundler.h"
#include "LoadImage.h"
#include "xgraphics.h"




// Texture formats
const FORMATSPEC g_TextureFormats[] = 
{
    // Format name           Xbox save format        Type           #alphabits
    { "D3DFMT_A8R8G8B8",     X_D3DFMT_A8R8G8B8,      FMT_SWIZZLED,   8    },
    { "D3DFMT_X8R8G8B8",     X_D3DFMT_X8R8G8B8,      FMT_SWIZZLED,   8    },
    { "D3DFMT_A8B8G8R8",     X_D3DFMT_A8B8G8R8,      FMT_SWIZZLED,   8    },
    { "D3DFMT_B8G8R8A8",     X_D3DFMT_B8G8R8A8,      FMT_SWIZZLED,   8    },
    { "D3DFMT_R8G8B8A8",     X_D3DFMT_R8G8B8A8,      FMT_SWIZZLED,   8    },
    { "D3DFMT_X8L8V8U8",     X_D3DFMT_X8L8V8U8,      FMT_SWIZZLED,   0    },
    { "D3DFMT_Q8W8V8U8",     X_D3DFMT_Q8W8V8U8,      FMT_SWIZZLED,   0    },
    { "D3DFMT_V16U16",       X_D3DFMT_V16U16,        FMT_SWIZZLED,   0    },
    { "D3DFMT_A4R4G4B4",     X_D3DFMT_A4R4G4B4,      FMT_SWIZZLED,   4    },
    { "D3DFMT_R4G4B4A4",     X_D3DFMT_R4G4B4A4,      FMT_SWIZZLED,   4    },
    { "D3DFMT_X1R5G5B5",     X_D3DFMT_X1R5G5B5,      FMT_SWIZZLED,   0    },
    { "D3DFMT_A1R5G5B5",     X_D3DFMT_A1R5G5B5,      FMT_SWIZZLED,   1    },
    { "D3DFMT_R5G5B5A1",     X_D3DFMT_R5G5B5A1,      FMT_SWIZZLED,   1    },
    { "D3DFMT_R5G6B5",       X_D3DFMT_R5G6B5,        FMT_SWIZZLED,   0    },
    { "D3DFMT_R6G5B5",       X_D3DFMT_R6G5B5,        FMT_SWIZZLED,   0    },
    { "D3DFMT_L6V5U5",       X_D3DFMT_L6V5U5,        FMT_SWIZZLED,   0    },
    { "D3DFMT_R8B8",         X_D3DFMT_R8B8,          FMT_SWIZZLED,   0    },
    { "D3DFMT_G8B8",         X_D3DFMT_G8B8,          FMT_SWIZZLED,   0    },
    { "D3DFMT_V8U8",         X_D3DFMT_V8U8,          FMT_SWIZZLED,   0    },
    { "D3DFMT_A8L8",         X_D3DFMT_A8L8,          FMT_SWIZZLED,   8    },
    { "D3DFMT_AL8",          X_D3DFMT_AL8,           FMT_SWIZZLED,   8    },
    { "D3DFMT_A8",           X_D3DFMT_A8,            FMT_SWIZZLED,   8    },
    { "D3DFMT_L8",           X_D3DFMT_L8,            FMT_SWIZZLED,   0    },
//  { "D3DFMT_P8",           X_D3DFMT_P8,            FMT_SWIZZLED,   8    }, // Bundler doesn't support (yet)
    { "D3DFMT_L16",          X_D3DFMT_L16,           FMT_SWIZZLED,   0    },
    { "D3DFMT_DXT1",         X_D3DFMT_DXT1,          FMT_COMPRESSED, 1    },
    { "D3DFMT_DXT2",         X_D3DFMT_DXT2,          FMT_COMPRESSED, 8    },
//  { "D3DFMT_DXT3",         X_D3DFMT_DXT3,          FMT_COMPRESSED, 8    }, // Not supported on Xbox
    { "D3DFMT_DXT4",         X_D3DFMT_DXT4,          FMT_COMPRESSED, 8    },
//  { "D3DFMT_DXT5",         X_D3DFMT_DXT5,          FMT_COMPRESSED, 8    }, // Not supported on Xbox
    { "D3DFMT_LIN_A8B8G8R8", X_D3DFMT_LIN_A8B8G8R8,  FMT_LINEAR    , 8    },
    { "D3DFMT_LIN_A8R8G8B8", X_D3DFMT_LIN_A8R8G8B8,  FMT_LINEAR    , 8    },
    { "D3DFMT_LIN_B8G8R8A8", X_D3DFMT_LIN_B8G8R8A8,  FMT_LINEAR    , 8    },
    { "D3DFMT_LIN_R8G8B8A8", X_D3DFMT_LIN_R8G8B8A8,  FMT_LINEAR    , 8    },
    { "D3DFMT_LIN_X8R8G8B8", X_D3DFMT_LIN_X8R8G8B8,  FMT_LINEAR    , 0    },
    { "D3DFMT_LIN_X8L8V8U8", X_D3DFMT_LIN_X8L8V8U8,  FMT_LINEAR    , 0    },
    { "D3DFMT_LIN_Q8W8V8U8", X_D3DFMT_LIN_Q8W8V8U8,  FMT_LINEAR    , 0    },
    { "D3DFMT_LIN_V16U16",   X_D3DFMT_LIN_V16U16,    FMT_LINEAR    , 0    },
    { "D3DFMT_LIN_A4R4G4B4", X_D3DFMT_LIN_A4R4G4B4,  FMT_LINEAR    , 4    },
    { "D3DFMT_LIN_R4G4B4A4", X_D3DFMT_LIN_R4G4B4A4,  FMT_LINEAR    , 4    },
    { "D3DFMT_LIN_A1R5G5B5", X_D3DFMT_LIN_A1R5G5B5,  FMT_LINEAR    , 1    },
    { "D3DFMT_LIN_R5G5B5A1", X_D3DFMT_LIN_R5G5B5A1,  FMT_LINEAR    , 1    },
    { "D3DFMT_LIN_X1R5G5B5", X_D3DFMT_LIN_X1R5G5B5,  FMT_LINEAR    , 0    },
    { "D3DFMT_LIN_R5G6B5",   X_D3DFMT_LIN_R5G6B5,    FMT_LINEAR    , 0    },
    { "D3DFMT_LIN_R6G5B5",   X_D3DFMT_LIN_R6G5B5,    FMT_LINEAR    , 0    },
    { "D3DFMT_LIN_L6V5U5",   X_D3DFMT_LIN_L6V5U5,    FMT_LINEAR    , 0    },
    { "D3DFMT_LIN_G8B8",     X_D3DFMT_LIN_G8B8,      FMT_LINEAR    , 0    },
    { "D3DFMT_LIN_R8B8",     X_D3DFMT_LIN_R8B8,      FMT_LINEAR    , 0    },
    { "D3DFMT_LIN_A8L8",     X_D3DFMT_LIN_A8L8,      FMT_LINEAR    , 8    },
    { "D3DFMT_LIN_V8U8",     X_D3DFMT_LIN_V8U8,      FMT_LINEAR    , 0    },
    { "D3DFMT_LIN_AL8",      X_D3DFMT_LIN_AL8,       FMT_LINEAR    , 8    },
    { "D3DFMT_LIN_L16",      X_D3DFMT_LIN_L16,       FMT_LINEAR    , 0    },
    { "D3DFMT_LIN_L8",       X_D3DFMT_LIN_L8,        FMT_LINEAR    , 0    },
    { "D3DFMT_LIN_A8",       X_D3DFMT_LIN_A8,        FMT_LINEAR    , 8    },
};




//-----------------------------------------------------------------------------
// Name: ConvertTextureFormat()
// Desc: 
// TODO: Make this handle the pitch requirements of small textures
//-----------------------------------------------------------------------------
HRESULT ConvertTextureFormat( VOID* pSrcData, 
                              DWORD dwWidth, DWORD dwHeight, DWORD dwDepth, 
                              VOID* pDstData, DWORD dwDstFormat )
{
    // Create convenient access ptrs
    DWORD* pSrcData32 = (DWORD*)pSrcData;
    BYTE*  pDstData8  =  (BYTE*)pDstData;
    WORD*  pDstData16 =  (WORD*)pDstData;
    DWORD* pDstData32 = (DWORD*)pDstData;

    // Look through all pixels
    for( DWORD z=0; z<dwDepth; z++ )
    {
        for( DWORD y=0; y<dwHeight; y++ )
        {
            for( DWORD x=0; x<dwWidth; x++ )
            {
                // Read src pixel
                FLOAT a = (((*pSrcData32)&0xff000000)>>24L)/255.0f;
                FLOAT r = (((*pSrcData32)&0x00ff0000)>>16L)/255.0f;
                FLOAT g = (((*pSrcData32)&0x0000ff00)>> 8L)/255.0f;
                FLOAT b = (((*pSrcData32)&0x000000ff)>> 0L)/255.0f;
                pSrcData32++;

                // Assign values to non-ARGB channels
                FLOAT q = a;
                FLOAT w = r;
                FLOAT v = g;
                FLOAT u = b;
                FLOAT l = (r+g+b)/3;

                // Write dst pixel
                switch( dwDstFormat )
                {
                    case X_D3DFMT_A8R8G8B8:     // case X_D3DFMT_Q8W8V8U8:
                    case X_D3DFMT_LIN_A8R8G8B8: // case X_D3DFMT_LIN_Q8W8V8U8:
                        (*pDstData32++) = (((DWORD)(a*0xff))<<24L) | 
                                          (((DWORD)(r*0xff))<<16L) | 
                                          (((DWORD)(g*0xff))<< 8L) | 
                                          (((DWORD)(b*0xff))<< 0L);
                        break;
                    case X_D3DFMT_X8R8G8B8:     // case X_D3DFMT_X8L8V8U8:
                    case X_D3DFMT_LIN_X8R8G8B8: // case X_D3DFMT_LIN_X8L8V8U8:
                        (*pDstData32++) = (((DWORD)(r*0xff))<<16L) | 
                                          (((DWORD)(g*0xff))<< 8L) | 
                                          (((DWORD)(b*0xff))<< 0L);
                        break;
                    case X_D3DFMT_A8B8G8R8:
                    case X_D3DFMT_LIN_A8B8G8R8:
                        (*pDstData32++) = (((DWORD)(a*0xff))<<24L) | 
                                          (((DWORD)(b*0xff))<<16L) | 
                                          (((DWORD)(g*0xff))<< 8L) | 
                                          (((DWORD)(r*0xff))<< 0L);
                        break;
                    case X_D3DFMT_B8G8R8A8:
                    case X_D3DFMT_LIN_B8G8R8A8:
                        (*pDstData32++) = (((DWORD)(b*0xff))<<24L) | 
                                          (((DWORD)(g*0xff))<<16L) | 
                                          (((DWORD)(r*0xff))<< 8L) | 
                                          (((DWORD)(a*0xff))<< 0L);
                        break;
                    case X_D3DFMT_R8G8B8A8:
                    case X_D3DFMT_LIN_R8G8B8A8:
                        (*pDstData32++) = (((DWORD)(r*0xff))<<24L) | 
                                          (((DWORD)(g*0xff))<<16L) | 
                                          (((DWORD)(b*0xff))<< 8L) | 
                                          (((DWORD)(a*0xff))<< 0L);
                        break;
                    case X_D3DFMT_A1R5G5B5:
                    case X_D3DFMT_LIN_A1R5G5B5:
                        (*pDstData16++) = (((WORD)(a*0x01))<<15L) | 
                                          (((WORD)(r*0x1f))<<10L) | 
                                          (((WORD)(g*0x1f))<< 5L) | 
                                          (((WORD)(b*0x1f))<< 0L);
                        break;
                    case X_D3DFMT_X1R5G5B5:
                    case X_D3DFMT_LIN_X1R5G5B5:
                        (*pDstData16++) = (((WORD)(r*0x1f))<<10L) | 
                                          (((WORD)(g*0x1f))<< 5L) | 
                                          (((WORD)(b*0x1f))<< 0L);
                        break;
                    case X_D3DFMT_R5G5B5A1:
                    case X_D3DFMT_LIN_R5G5B5A1:
                        (*pDstData16++) = (((WORD)(r*0x1f))<<11L) | 
                                          (((WORD)(g*0x1f))<< 6L) | 
                                          (((WORD)(b*0x1f))<< 1L) | 
                                          (((WORD)(a*0x01))<< 0L);
                        break;
                    case X_D3DFMT_R5G6B5:
                    case X_D3DFMT_LIN_R5G6B5:
                        (*pDstData16++) = (((WORD)(r*0x1f))<<11L) | 
                                          (((WORD)(g*0x3f))<< 5L) | 
                                          (((WORD)(b*0x1f))<< 0L);
                        break;
                    case X_D3DFMT_R6G5B5:     // case X_D3DFMT_L6V5U5:
                    case X_D3DFMT_LIN_R6G5B5: // case X_D3DFMT_LIN_L6V5U5:
                        (*pDstData16++) = (((WORD)(r*0x3f))<<10L) | 
                                          (((WORD)(g*0x1f))<< 5L) | 
                                          (((WORD)(b*0x1f))<< 0L);
                        break;
                    case X_D3DFMT_A4R4G4B4:
                    case X_D3DFMT_LIN_A4R4G4B4:
                        (*pDstData16++) = (((WORD)(a*0x0f))<<12L) | 
                                          (((WORD)(r*0x0f))<< 8L) | 
                                          (((WORD)(g*0x0f))<< 4L) | 
                                          (((WORD)(b*0x0f))<< 0L);
                        break;
                    case X_D3DFMT_R4G4B4A4:
                    case X_D3DFMT_LIN_R4G4B4A4:
                        (*pDstData16++) = (((WORD)(r*0x0f))<<12L) | 
                                          (((WORD)(g*0x0f))<< 8L) | 
                                          (((WORD)(b*0x0f))<< 4L) | 
                                          (((WORD)(a*0x0f))<< 0L);
                        break;
                    case X_D3DFMT_R8B8:
                    case X_D3DFMT_LIN_R8B8:
                        (*pDstData16++) = (((WORD)(r*0xff))<< 8L) | 
                                          (((WORD)(b*0xff))<< 0L);
                        break;
                    case X_D3DFMT_G8B8:     // case X_D3DFMT_V8U8:
                    case X_D3DFMT_LIN_G8B8: // case X_D3DFMT_LIN_V8U8:
                        (*pDstData16++) = (((WORD)(g*0xff))<< 8L) | 
                                          (((WORD)(b*0xff))<< 0L);
                        break;
                    case X_D3DFMT_A8L8:
                    case X_D3DFMT_LIN_A8L8:
                        (*pDstData16++) = (((WORD)(a*0xff))<< 8L) | 
                                          (((WORD)(l*0xff))<< 0L);
                        break;
                    case X_D3DFMT_L16:
                    case X_D3DFMT_LIN_L16:
                        (*pDstData16++) = (((WORD)(l*0xffff))<< 0L);
                        break;
                    case X_D3DFMT_L8:
                    case X_D3DFMT_LIN_L8:
                        (*pDstData8++)  = (((BYTE)(l*0xff))<< 0L);
                        break;
                    case X_D3DFMT_A8:
                    case X_D3DFMT_LIN_A8:
                        (*pDstData8++)  = (((BYTE)(a*0xff))<< 0L);
                        break;
                    case X_D3DFMT_AL8:
                    case X_D3DFMT_LIN_AL8:
                        (*pDstData8++)  = (((BYTE)(l*0xff))<< 0L);
                        break;
                    case X_D3DFMT_V16U16:
                    case X_D3DFMT_LIN_V16U16:
                        (*pDstData32++) = (((DWORD)(v*0xffff))<<16L) | 
                                          (((DWORD)(u*0xffff))<< 0L);
                        break;
                }
            }
        }
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: CBaseTexture()
// Desc: Initializes member variables
//-----------------------------------------------------------------------------
CBaseTexture::CBaseTexture( CBundler * pBundler )
{
    m_nFormat      = -1;
    m_strFormat[0] = 0;
    m_dwFilter     = D3DX_FILTER_TRIANGLE;
    m_dwLevels     = 1;
    m_pBundler     = pBundler;
}




//-----------------------------------------------------------------------------
// Name: ~CBaseTexture()
// Desc: Performs any cleanup needed before the object is destroyed
//-----------------------------------------------------------------------------
CBaseTexture::~CBaseTexture()
{
}




//-----------------------------------------------------------------------------
// Name: FormatFromString()
// Desc: Returns an index into the format spec array corresponding to the
//       given string
//-----------------------------------------------------------------------------
int CBaseTexture::FormatFromString( char* strFormat )
{
    if( strFormat[0] == 0 )
        return 0;

    DWORD dwNumFormats = sizeof(g_TextureFormats) / sizeof(g_TextureFormats[0]);

    for( DWORD i = 0; i < dwNumFormats; i++ )
    {
        if( !lstrcmpi( strFormat, g_TextureFormats[i].strFormat ) )
            return i;
    }

    return -2;
}




//-----------------------------------------------------------------------------
// Name: FormatFromString()
// Desc: Returns an index into the format spec array corresponding to the
//       given string
//-----------------------------------------------------------------------------
int CBaseTexture::FormatFromPCFormat( D3DFORMAT d3dFormat )
{
    switch( d3dFormat )
    {
        case D3DFMT_A8R8G8B8: return FormatFromString( "D3DFMT_A8R8G8B8" );
        case D3DFMT_X8R8G8B8: return FormatFromString( "D3DFMT_X8R8G8B8" );
//      case D3DFMT_A8B8G8R8: return FormatFromString( "D3DFMT_A8B8G8R8" );
//      case D3DFMT_B8G8R8A8: return FormatFromString( "D3DFMT_B8G8R8A8" );
//      case D3DFMT_R8G8B8A8: return FormatFromString( "D3DFMT_R8G8B8A8" );
        case D3DFMT_X8L8V8U8: return FormatFromString( "D3DFMT_X8L8V8U8" );
        case D3DFMT_Q8W8V8U8: return FormatFromString( "D3DFMT_Q8W8V8U8" );
        case D3DFMT_V16U16:   return FormatFromString( "D3DFMT_V16U16" );
        case D3DFMT_A4R4G4B4: return FormatFromString( "D3DFMT_A4R4G4B4" );
//      case D3DFMT_R4G4B4A4: return FormatFromString( "D3DFMT_R4G4B4A4" );
        case D3DFMT_X1R5G5B5: return FormatFromString( "D3DFMT_X1R5G5B5" );
        case D3DFMT_A1R5G5B5: return FormatFromString( "D3DFMT_A1R5G5B5" );
//      case D3DFMT_R5G5B5A1: return FormatFromString( "D3DFMT_R5G5B5A1" );
        case D3DFMT_R5G6B5:   return FormatFromString( "D3DFMT_R5G6B5" );
//      case D3DFMT_R6G5B5:   return FormatFromString( "D3DFMT_R6G5B5" );
        case D3DFMT_L6V5U5:   return FormatFromString( "D3DFMT_L6V5U5" );
//      case D3DFMT_R8B8:     return FormatFromString( "D3DFMT_R8B8" );
//      case D3DFMT_G8B8:     return FormatFromString( "D3DFMT_G8B8" );
        case D3DFMT_V8U8:     return FormatFromString( "D3DFMT_V8U8" );
        case D3DFMT_A8L8:     return FormatFromString( "D3DFMT_A8L8" );
//      case D3DFMT_AL8:      return FormatFromString( "D3DFMT_AL8" );
        case D3DFMT_A8:       return FormatFromString( "D3DFMT_A8" );
        case D3DFMT_L8:       return FormatFromString( "D3DFMT_L8" );
//      case D3DFMT_A8R8G8B8: return FormatFromString( "D3DFMT_P8" );
//      case D3DFMT_L16:      return FormatFromString( "D3DFMT_L16" );
        case D3DFMT_DXT1:     return FormatFromString( "D3DFMT_DXT1" );
        case D3DFMT_DXT2:     return FormatFromString( "D3DFMT_DXT2" );
//      case D3DFMT_DXT3:     return FormatFromString( "D3DFMT_DXT3" );
        case D3DFMT_DXT4:     return FormatFromString( "D3DFMT_DXT4" );
//      case D3DFMT_DXT5:     return FormatFromString( "D3DFMT_DXT5" );
    }

    return -2;
}




//-----------------------------------------------------------------------------
// Name: LoadSurface()
// Desc: Loads source and alphasource surfaces
//-----------------------------------------------------------------------------
HRESULT CBaseTexture::LoadSurface( CHAR* strSource, CHAR* strAlphaSource, 
                                   LPDIRECT3DSURFACE8* ppSurface )
{
    CImage             ColorImage;
    CImage             AlphaImage;
    LPDIRECT3DSURFACE8 pOrigColorSurface;
    LPDIRECT3DSURFACE8 pOrigAlphaSurface;
    LPDIRECT3DSURFACE8 pResizedColorSurface;
    LPDIRECT3DSURFACE8 pResizedAlphaSurface;
    D3DLOCKED_RECT     lock;
    HRESULT hr; 

    // Add the path (if necessary) to the source filename
    CHAR strImageFilePath[MAX_PATH];
    if( strchr( strSource, ':' ) )
        strcpy( strImageFilePath, strSource );
    else
    {
        strcpy( strImageFilePath, m_pBundler->m_strPath );
        strcat( strImageFilePath, strSource );
    }

    // Load the texture from the source file
    hr = ColorImage.Load( strImageFilePath );
    if( FAILED( hr ) )
        return hr;

    // Depalettize any palettized images
    if( D3DFMT_P8 == ColorImage.m_Format )
        ColorImage.Depalettize();

    // Create a surface for the image
    hr = m_pBundler->m_pd3ddev->CreateImageSurface( ColorImage.m_Width, ColorImage.m_Height,
                                                       ColorImage.m_Format, &pOrigColorSurface );
    pOrigColorSurface->LockRect( &lock, 0, 0 );
    memcpy( lock.pBits, ColorImage.m_pData, ColorImage.m_Pitch * ColorImage.m_Height );
    pOrigColorSurface->UnlockRect();

    if( strAlphaSource[0] )
    {
        // Add the path (if necessary) to the source filename
        CHAR strImageFilePath[MAX_PATH];
        if( strchr( strSource, ':' ) )
            strcpy( strImageFilePath, strAlphaSource );
        else
        {
            strcpy( strImageFilePath, m_pBundler->m_strPath );
            strcat( strImageFilePath, strAlphaSource );
        }

        // Load the texture from the alpha source file
        hr = AlphaImage.Load( strImageFilePath );
        if( FAILED( hr ) )
            return hr;

        // Can't currently deal with palettized images
        if( D3DFMT_P8 == AlphaImage.m_Format )
            return E_FAIL;

        hr = m_pBundler->m_pd3ddev->CreateImageSurface( AlphaImage.m_Width, AlphaImage.m_Height,
                                                           AlphaImage.m_Format, &pOrigAlphaSurface );
        pOrigAlphaSurface->LockRect( &lock, 0, 0 );
        memcpy( lock.pBits, AlphaImage.m_pData, AlphaImage.m_Pitch * AlphaImage.m_Height );
        pOrigAlphaSurface->UnlockRect();
    }

    // Determine final texture size
    DWORD dwWidth  = ColorImage.m_Width;
    DWORD dwHeight = ColorImage.m_Height;
    
    if( strAlphaSource[0] )
    {
        if( dwWidth  < AlphaImage.m_Width  )   dwWidth  = AlphaImage.m_Width;
        if( dwHeight < AlphaImage.m_Height )   dwHeight = AlphaImage.m_Height;
    }

    // Do the size conversion for the source image
    hr = m_pBundler->m_pd3ddev->CreateImageSurface( dwWidth, dwHeight, D3DFMT_A8R8G8B8,
                                                       &pResizedColorSurface );

    hr = D3DXLoadSurfaceFromSurface( pResizedColorSurface, NULL, NULL, 
                                     pOrigColorSurface, ColorImage.m_pPalette, NULL,
                                     m_dwFilter, 0 );

    if( strAlphaSource[0] )
    {
        // Do the size conversion for the alpha source image
        hr = m_pBundler->m_pd3ddev->CreateImageSurface( dwWidth, dwHeight, D3DFMT_A8R8G8B8,
                                                           &pResizedAlphaSurface );

        hr = D3DXLoadSurfaceFromSurface( pResizedAlphaSurface, NULL, NULL, 
                                         pOrigAlphaSurface, AlphaImage.m_pPalette, NULL,
                                         m_dwFilter, 0 );
    }

    // Merge in the alpha channel
    if( strAlphaSource[0] )
    {
        D3DLOCKED_RECT lockColor;
        D3DLOCKED_RECT lockAlpha;
        hr = pResizedColorSurface->LockRect( &lockColor, NULL, 0 );
        hr = pResizedAlphaSurface->LockRect( &lockAlpha, NULL, 0 );

        DWORD* pColorBits = (DWORD*)lockColor.pBits;
        DWORD* pAlphaBits = (DWORD*)lockAlpha.pBits;

        for( DWORD yp = 0; yp < dwHeight; yp++ )
        {
            for( DWORD xp = 0; xp < dwWidth; xp++ )
            {
                DWORD dwAlpha = (*pAlphaBits) << 24;
                (*pColorBits) &= 0x00ffffff;
                (*pColorBits) |= dwAlpha;

                pColorBits++;
                pAlphaBits++;
            }
        }

        pResizedColorSurface->UnlockRect();
        pResizedAlphaSurface->UnlockRect();
    }
        
    // Return the surface in the output parameter
    (*ppSurface) = pResizedColorSurface;
    (*ppSurface)->AddRef();

    // Release the color surfaces
    pOrigColorSurface->Release();
    pResizedColorSurface->Release();

    // Release the alpha surfaces
    if( strAlphaSource[0] )
    {
        pOrigAlphaSurface->Release();
        pResizedAlphaSurface->Release();
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: LoadSurfaceUsingD3DX()
// Desc: Loads source and alphasource surfaces. This should be used after other
//       load attempts failed, since D3DX forces surfaces to have dimensions
//       that are a power of two.
//-----------------------------------------------------------------------------
HRESULT CBaseTexture::LoadSurfaceUsingD3DX( CHAR* strSource, CHAR* strAlphaSource, 
                                            LPDIRECT3DSURFACE8* ppSurface )
{
    D3DSURFACE_DESC    ColorImageDesc;
    D3DSURFACE_DESC    AlphaImageDesc;
    LPDIRECT3DSURFACE8 pOrigColorSurface;
    LPDIRECT3DSURFACE8 pOrigAlphaSurface;
    LPDIRECT3DSURFACE8 pResizedColorSurface;
    LPDIRECT3DSURFACE8 pResizedAlphaSurface;
    HRESULT hr; 

    // Add the path (if necessary) to the source filename
    CHAR strImageFilePath[MAX_PATH];
    if( strchr( strSource, ':' ) )
        strcpy( strImageFilePath, strSource );
    else
    {
        strcpy( strImageFilePath, m_pBundler->m_strPath );
        strcat( strImageFilePath, strSource );
    }


    // Load the texture from the source file
    LPDIRECT3DTEXTURE8 pImageTexture;
    hr = D3DXCreateTextureFromFileEx( m_pBundler->m_pd3ddev, strImageFilePath, 
                                      D3DX_DEFAULT, D3DX_DEFAULT, 1,
                                      0, D3DFMT_UNKNOWN, D3DPOOL_SYSTEMMEM,
                                      D3DX_DEFAULT, D3DX_DEFAULT, 0,
                                      NULL, NULL, &pImageTexture );
    if( FAILED( hr ) )
    {
        m_pBundler->ErrorMsg( "Couldn't load image <%s>\n", strSource );
        return hr;
    }

    // Get a surface for the image
    pImageTexture->GetSurfaceLevel( 0, &pOrigColorSurface );
    pImageTexture->Release();
    pOrigColorSurface->GetDesc( &ColorImageDesc );

    if( m_nFormat < 0 )
    {
        m_nFormat   = FormatFromPCFormat( ColorImageDesc.Format );
        if( m_nFormat < 0 )
        {
            m_pBundler->ErrorMsg( "Unssupported format for image <%s>\n", strSource );
            return E_FAIL;
        }
        lstrcpyA( m_strFormat, g_TextureFormats[m_nFormat].strFormat );
    }

    if( strAlphaSource[0] )
    {
        // Add the path (if necessary) to the source filename
        CHAR strImageFilePath[MAX_PATH];
        if( strchr( strSource, ':' ) )
            strcpy( strImageFilePath, strAlphaSource );
        else
        {
            strcpy( strImageFilePath, m_pBundler->m_strPath );
            strcat( strImageFilePath, strAlphaSource );
        }

        // Load the texture from the alpha source file
        LPDIRECT3DTEXTURE8 pAlphaTexture;
        hr = D3DXCreateTextureFromFileEx( m_pBundler->m_pd3ddev, strImageFilePath, 
                                          D3DX_DEFAULT, D3DX_DEFAULT, 1,
                                          0, D3DFMT_UNKNOWN, D3DPOOL_DEFAULT,
                                          D3DX_DEFAULT, D3DX_DEFAULT, 0,
                                          NULL, NULL, &pAlphaTexture );
        if( FAILED( hr ) )
        {
            m_pBundler->ErrorMsg( "Couldn't load image <%s>\n", strAlphaSource );
            return hr;
        }

        pAlphaTexture->GetSurfaceLevel( 0, &pOrigAlphaSurface );
        pAlphaTexture->Release();
        pOrigAlphaSurface->GetDesc( &AlphaImageDesc );
    }

    // Determine final texture size
    DWORD dwWidth  = ColorImageDesc.Width;
    DWORD dwHeight = ColorImageDesc.Height;
    
    if( strAlphaSource[0] )
    {
        if( dwWidth  < AlphaImageDesc.Width  )   dwWidth  = AlphaImageDesc.Width;
        if( dwHeight < AlphaImageDesc.Height )   dwHeight = AlphaImageDesc.Height;
    }

    // Do the size conversion for the source image
    hr = m_pBundler->m_pd3ddev->CreateImageSurface( dwWidth, dwHeight, D3DFMT_A8R8G8B8,
                                                    &pResizedColorSurface );

    hr = D3DXLoadSurfaceFromSurface( pResizedColorSurface, NULL, NULL, 
                                     pOrigColorSurface, NULL, NULL,
                                     m_dwFilter, 0 );

    if( strAlphaSource[0] )
    {
        // Do the size conversion for the alpha source image
        hr = m_pBundler->m_pd3ddev->CreateImageSurface( dwWidth, dwHeight, D3DFMT_A8R8G8B8,
                                                        &pResizedAlphaSurface );

        hr = D3DXLoadSurfaceFromSurface( pResizedAlphaSurface, NULL, NULL, 
                                         pOrigAlphaSurface, NULL, NULL,
                                         m_dwFilter, 0 );
    }

    // Merge in the alpha channel
    if( strAlphaSource[0] )
    {
        D3DLOCKED_RECT lockColor;
        D3DLOCKED_RECT lockAlpha;
        hr = pResizedColorSurface->LockRect( &lockColor, NULL, 0 );
        hr = pResizedAlphaSurface->LockRect( &lockAlpha, NULL, 0 );

        DWORD* pColorBits = (DWORD*)lockColor.pBits;
        DWORD* pAlphaBits = (DWORD*)lockAlpha.pBits;

        for( DWORD yp = 0; yp < dwHeight; yp++ )
        {
            for( DWORD xp = 0; xp < dwWidth; xp++ )
            {
                DWORD dwAlpha = (*pAlphaBits) << 24;
                (*pColorBits) &= 0x00ffffff;
                (*pColorBits) |= dwAlpha;

                pColorBits++;
                pAlphaBits++;
            }
        }

        pResizedColorSurface->UnlockRect();
        pResizedAlphaSurface->UnlockRect();
    }
        
    // Return the surface in the output parameter
    (*ppSurface) = pResizedColorSurface;
    (*ppSurface)->AddRef();

    // Release the color surfaces
    pOrigColorSurface->Release();
    pResizedColorSurface->Release();

    // Release the alpha surfaces
    if( strAlphaSource[0] )
    {
        pOrigAlphaSurface->Release();
        pResizedAlphaSurface->Release();
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: ResizeSurface()
// Desc: Convert the surface to the new width, height, and format
//-----------------------------------------------------------------------------
HRESULT CBaseTexture::ResizeSurface( DWORD dwWidth, DWORD dwHeight, 
                                     LPDIRECT3DSURFACE8* ppSurface )
{
    LPDIRECT3DSURFACE8 pOldSurface = (*ppSurface);
    HRESULT hr; 

    // Do the size/format conversion for the final surface
    hr = m_pBundler->m_pd3ddev->CreateImageSurface( dwWidth, dwHeight, D3DFMT_A8R8G8B8,
                                                    ppSurface );

    hr = D3DXLoadSurfaceFromSurface( (*ppSurface), NULL, NULL, 
                                     pOldSurface, NULL, NULL,
                                     m_dwFilter, 0 );

    // Release the old surface
    pOldSurface->Release();

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: WriteSwizzledTextureData()
// Desc: Swizzles the texture data to NVidia's swizzled format.  
//       XGSwizzleRect requires that the memory being swizzled to is 16-byte
//       aligned.
//-----------------------------------------------------------------------------
DWORD CBaseTexture::WriteSwizzledTextureData( VOID* pBits, DWORD dwWidth, 
                                              DWORD dwHeight, DWORD dwDepth )
{
    // Get info about the texture. Note that the pitch of a sizzled texture
    // is Width * BytesPerTexel
    DWORD  dwBytesPerTexel = XGBytesPerPixelFromFormat( D3DFORMAT(g_TextureFormats[m_nFormat].dwXboxFormat) );
    DWORD  dwPitch         = dwWidth*dwBytesPerTexel;
    DWORD  dwTextureSize   = dwPitch * dwHeight * dwDepth;
    BYTE*  pBitsUnaligned  = new BYTE[ dwTextureSize + 16 ];
    int    temp      = (int)pBitsUnaligned;
    BYTE*  pBitsTemp = (BYTE*)(( temp + 15 ) & ~15);   // 16-byte aligned ptr.

    // Swizzle the data into a temporary buffer, and then copy it back
    XGSwizzleBox( pBits, 0, 0, NULL, pBitsTemp, dwWidth, dwHeight, dwDepth,
                  NULL, dwBytesPerTexel );

    if( FAILED( m_pBundler->WriteData( pBitsTemp, dwTextureSize ) ) )
        return 0;

    delete[] pBitsUnaligned;

    return dwTextureSize;
}




//-----------------------------------------------------------------------------
// Name: WriteCompressedTextureData()
// Desc: Compresses the texture data
//-----------------------------------------------------------------------------
DWORD CBaseTexture::WriteCompressedTextureData( VOID* pSrcBits, DWORD dwWidth, 
                                                DWORD dwHeight, DWORD dwDepth )
{
    // Get info about the texture. Note that the pitch of a compressed texture
    // is Width*2 or Width*4, depending on the compression 
    DWORD dwBlockSize;
    DWORD dwCompressedSize;
//    DWORD dwSrcPitch   = (dwWidth*4+D3DTEXTURE_PITCH_ALIGNMENT-1)&~(D3DTEXTURE_PITCH_ALIGNMENT-1);
    DWORD dwSrcPitch   = dwWidth*sizeof(DWORD);
    BOOL  bPreMultiply = g_TextureFormats[m_nFormat].strFormat[10] == '2' ||
                         g_TextureFormats[m_nFormat].strFormat[10] == '4';

    switch( g_TextureFormats[m_nFormat].dwXboxFormat )
    {
        case X_D3DFMT_DXT1: 
            dwBlockSize      = 8;
            dwCompressedSize = dwWidth*dwHeight/2; 
            break;
        case X_D3DFMT_DXT2:
            dwBlockSize      = 16;
            dwCompressedSize = dwWidth*dwHeight; 
            break;
        case X_D3DFMT_DXT4:
            dwBlockSize      = 16;
            dwCompressedSize = dwWidth*dwHeight; 
            break;
        default:
            return E_FAIL;
    }

    // Allocate space for the compressed data
    BYTE* pCompressedData = new BYTE[dwDepth*dwCompressedSize];
    BYTE* pDstBits        = pCompressedData;

    for( DWORD i=0; i<dwDepth; i++ )
    {
        // Compress the data
        if( FAILED( XGCompressRect( pDstBits,
                                    D3DFORMAT(g_TextureFormats[m_nFormat].dwXboxFormat),
                                    0, dwWidth, dwHeight, pSrcBits, 
                                    D3DFORMAT(X_D3DFMT_LIN_A8R8G8B8), 
                                    dwSrcPitch, 0.5,
                                    bPreMultiply ? XGCOMPRESS_PREMULTIPLY : 0 ) ) )
            return 0;

        pSrcBits = (BYTE*)pSrcBits + dwSrcPitch*dwHeight;
        pDstBits = (BYTE*)pDstBits + dwCompressedSize;
    }

    if( dwDepth == 1 )
    {
        // Write the compressed data
        if( FAILED( m_pBundler->WriteData( pCompressedData, dwCompressedSize ) ) )
            return 0;
    }
    else
    {
        // For volume textures, compressed blocks are stored in block linear
        // format, so we need to write them in the correct order.
        DWORD dwNumXBlocks = dwWidth/4;
        DWORD dwNumYBlocks = dwHeight/4;
        DWORD dwNumWBlocks = (dwDepth<4) ? 1 : dwDepth/4;

        for( DWORD w=0; w<dwDepth; w+=4 )
        {
            for( DWORD by=0; by<dwNumYBlocks; by++ )
            {
                for( DWORD bx=0; bx<dwNumXBlocks; bx++ )
                {
                    BYTE* pBits0 = &pCompressedData[ dwBlockSize * ( bx + by*dwNumXBlocks + (w+0)*dwNumXBlocks*dwNumYBlocks ) ];
                    BYTE* pBits1 = &pCompressedData[ dwBlockSize * ( bx + by*dwNumXBlocks + (w+1)*dwNumXBlocks*dwNumYBlocks ) ];
                    BYTE* pBits2 = &pCompressedData[ dwBlockSize * ( bx + by*dwNumXBlocks + (w+2)*dwNumXBlocks*dwNumYBlocks ) ];
                    BYTE* pBits3 = &pCompressedData[ dwBlockSize * ( bx + by*dwNumXBlocks + (w+3)*dwNumXBlocks*dwNumYBlocks ) ];
    
                    // Write the compressed data
                    if( dwDepth >= 1 ) 
                        m_pBundler->WriteData( pBits0, dwBlockSize );
                    if( dwDepth >= 2 ) 
                        m_pBundler->WriteData( pBits1, dwBlockSize );
                    if( dwDepth >= 3 ) 
                        m_pBundler->WriteData( pBits2, dwBlockSize );
                    if( dwDepth >= 4 ) 
                        m_pBundler->WriteData( pBits3, dwBlockSize );
                }
            }
        }
    }

    // Cleanup
    delete[] pCompressedData;

    // Return the number of bytes written
    return dwDepth*dwCompressedSize;
}




//-----------------------------------------------------------------------------
// Name: WriteLinearTextureData()
// Desc: 
//-----------------------------------------------------------------------------
DWORD CBaseTexture::WriteLinearTextureData( VOID* pBits, DWORD dwWidth, 
                                            DWORD dwHeight, DWORD dwDepth )
{
    // Get info about the texture. Note that the pitch of a linear texture
    // needs to be a multiple of 64 bytes.
    DWORD dwBytesPerTexel = XGBytesPerPixelFromFormat( D3DFORMAT(g_TextureFormats[m_nFormat].dwXboxFormat) );
    DWORD dwPitch         = (dwWidth*dwBytesPerTexel+D3DTEXTURE_PITCH_ALIGNMENT-1)&~(D3DTEXTURE_PITCH_ALIGNMENT-1);
    DWORD dwTextureSize   = dwPitch * dwHeight * dwDepth;

    // Write the texture
    if( dwPitch == dwWidth*dwBytesPerTexel )
    {
        if( FAILED( m_pBundler->WriteData( pBits, dwTextureSize ) ) )
            return 0;
    }
    else
    {
        // For textures with non-conforming pitches, write the data aligned
        // according to the pitch
        BYTE* pTempBits = (BYTE*)pBits;
        BYTE  pZeroes[64];
        ZeroMemory( pZeroes, 64 );
        
        for( DWORD z=0; z<dwDepth; z++ )
        {
            for( DWORD y=0; y<dwHeight; y++ )
            {
                // Write data
                if( FAILED( m_pBundler->WriteData( pTempBits, dwWidth*dwBytesPerTexel ) ) )
                    return 0;
                pTempBits += dwWidth*dwBytesPerTexel;

                // Pad to 64-bytes
                if( FAILED( m_pBundler->WriteData( pZeroes, dwPitch - dwWidth*dwBytesPerTexel ) ) )
                    return 0;
            }
        }
    }

    return dwTextureSize;
}




//-----------------------------------------------------------------------------
// Name: SaveSurface()
// Desc: Saves the raw surface data to the XPR file
//-----------------------------------------------------------------------------
HRESULT CBaseTexture::SaveSurface( DWORD* pcbData, DWORD dwLevels, 
                                   LPDIRECT3DSURFACE8 pSurface )
{
    D3DSURFACE_DESC desc;
    HRESULT hr;

    // Pad data file to proper alignment for the start of the texture
    hr = m_pBundler->PadToAlignment( D3DTEXTURE_ALIGNMENT );
    if( FAILED( hr ) )
        return hr;

    // Get the surface desc, used to create mipmap levels
    pSurface->GetDesc( &desc );
    DWORD dwWidth  = desc.Width;
    DWORD dwHeight = desc.Height;

    // Allocate memory for converting the surface format
    VOID* pSurfaceData = (VOID*)new BYTE[dwWidth*dwHeight*4];

    // Loop over each mipmap level of the texture
    for( DWORD dwLevel = 0; dwLevel < dwLevels; dwLevel++ )
    {
        // Create the mipmap
        LPDIRECT3DSURFACE8 pMipmapLevel;
        hr = m_pBundler->m_pd3ddev->CreateImageSurface( dwWidth, dwHeight, desc.Format,
                                                        &pMipmapLevel );
        hr = D3DXLoadSurfaceFromSurface( pMipmapLevel, NULL, NULL, 
                                         pSurface, NULL, NULL,
                                         m_dwFilter, 0 );

        // Lock the surface data
        D3DLOCKED_RECT  lock;
        hr = pMipmapLevel->LockRect( &lock, NULL, D3DLOCK_READONLY );
        if( FAILED( hr ) )
            return hr;

        if( g_TextureFormats[m_nFormat].Type == FMT_COMPRESSED )
        {
            // If we're writing a compressed format, compress the texture data
            (*pcbData) += WriteCompressedTextureData( lock.pBits, dwWidth, dwHeight, 1 );
        }
        else
        {
            // Convert the surface data to the destination format
            ConvertTextureFormat( lock.pBits, dwWidth, dwHeight, 1,
                                  pSurfaceData, g_TextureFormats[m_nFormat].dwXboxFormat );

            if( g_TextureFormats[m_nFormat].Type == FMT_SWIZZLED )
            {
                // If we're writing a swizzled format, swizzle the texture data
                (*pcbData) += WriteSwizzledTextureData( pSurfaceData, dwWidth, dwHeight, 1 );
            }
            else
            {
                // Write out linear surface data
                (*pcbData) += WriteLinearTextureData( pSurfaceData, dwWidth, dwHeight, 1 );
            }
        }

        pMipmapLevel->UnlockRect();

        // Shrink dimensions down to next lower mipmap level
        if( dwWidth >= 2 )
            dwWidth >>= 1;
        if( dwHeight >= 2 )
            dwHeight >>= 1;

        if( g_TextureFormats[m_nFormat].Type == FMT_COMPRESSED )
        {
            dwWidth  = max( dwWidth, 4 );
            dwHeight = max( dwHeight, 4 );
        }
            
        // Release the mipmap level
        pMipmapLevel->Release();
    }

    // Cleanup
    delete[] pSurfaceData;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: SaveVolumeTexture()
// Desc: Saves the raw surface data to the XPR file
//-----------------------------------------------------------------------------
HRESULT CBaseTexture::SaveVolumeTexture( DWORD* pcbData, DWORD dwLevels, 
                                         LPDIRECT3DVOLUMETEXTURE8 pVolumeTexture )
{
    D3DVOLUME_DESC desc;
    HRESULT        hr;

    // Pad data file to proper alignment for the start of the texture
    hr = m_pBundler->PadToAlignment( D3DTEXTURE_ALIGNMENT );
    if( FAILED( hr ) )
        return hr;

    // Get the surface desc, used to create mipmap levels
    pVolumeTexture->GetLevelDesc( 0, &desc );
    DWORD dwWidth  = desc.Width;
    DWORD dwHeight = desc.Height;
    DWORD dwDepth  = desc.Depth;

    // Get the source volume
    LPDIRECT3DVOLUME8 pSrcVolume;
    pVolumeTexture->GetVolumeLevel( 0, &pSrcVolume );

    // Allocate memory for converting the surface format
    VOID* pVolumeData = (VOID*)new BYTE[dwWidth*dwHeight*dwDepth*4];

    // Create a temporary destination volumetexture
    LPDIRECT3DVOLUMETEXTURE8 pDstVolumeTexture;
    hr = m_pBundler->m_pd3ddev->CreateVolumeTexture( dwWidth, dwHeight, dwDepth, dwLevels, 0, desc.Format,
                                                     D3DPOOL_SYSTEMMEM, &pDstVolumeTexture );

    // Loop over each mipmap level of the texture
    for( DWORD dwLevel = 0; dwLevel < dwLevels; dwLevel++ )
    {
        // Create the mipmap
        LPDIRECT3DVOLUME8 pDstVolume;
        pDstVolumeTexture->GetVolumeLevel( dwLevel, &pDstVolume );
        hr = D3DXLoadVolumeFromVolume( pDstVolume, NULL, NULL, 
                                       pSrcVolume, NULL, NULL,
                                       m_dwFilter, 0 );

        // Lock the volume data
        D3DLOCKED_BOX lock;
        hr = pDstVolume->LockBox( &lock, NULL, D3DLOCK_READONLY );
        if( FAILED( hr ) )
            return hr;

        if( g_TextureFormats[m_nFormat].Type == FMT_COMPRESSED )
        {
            // If we're writing a compressed format, compress the texture data
            (*pcbData) += WriteCompressedTextureData( lock.pBits, dwWidth, 
                                                      dwHeight, dwDepth );
        }
        else
        {
            // Convert the surface data to the destination format
            ConvertTextureFormat( lock.pBits, dwWidth, dwHeight, dwDepth,
                                  pVolumeData, g_TextureFormats[m_nFormat].dwXboxFormat );

            // If we're writing a swizzled format, swizzle the texture data
            (*pcbData) += WriteSwizzledTextureData( pVolumeData, dwWidth, dwHeight, dwDepth );
        }

        pDstVolume->UnlockBox();

        // Shrink dimensions down to next lower mipmap level
        if( dwWidth >= 2 )
            dwWidth >>= 1;
        if( dwHeight >= 2 )
            dwHeight >>= 1;
        if( dwDepth >= 2 )
            dwDepth >>= 1;

        if( g_TextureFormats[m_nFormat].Type == FMT_COMPRESSED )
        {
            dwWidth  = max( dwWidth, 4 );
            dwHeight = max( dwHeight, 4 );
        }
            
        // Release the mipmap level
        pDstVolume->Release();
    }

    // Cleanup
    delete[] pVolumeData;
    pDstVolumeTexture->Release();

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\xodash\aseConv\csvfile.cpp ===
//---------------------------------------------------------------------------
//
// csvfile.cpp - This file contains the class declaration for the CSV Files
//
//				The CSV file is an Excel csv style file.
//
//	MechCommander2 -- Microsoft
//
//	Copyright (c) 1999 Microsoft
//
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
// Include files
#include "std.h"
#ifndef CSVFILE_H
#include "csvfile.h"
#endif
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <string.h>
#include <ctype.h>


//---------------------------------------------------------------------------
// Static Globals

#undef isspace		//Macro Chokes under Intel Compiler!!

//---------------------------------------------------------------------------
// class CSVIniFile
CSVFile::CSVFile (void) : File()
{
	totalRows = totalCols = 0L;
}

//---------------------------------------------------------------------------
CSVFile::~CSVFile (void)
{
	close();
}

//---------------------------------------------------------------------------
long CSVFile::countRows (void)
{
	long count = 0;
	long oldPosition = logicalPosition;
	
	seek(0);		//Start at the top.
	char tmp[2048];
	
//	readLine((BYTE*)tmp,2047);
	while (!eof())
	{
		if ( readLine((BYTE*)tmp,2047) )
		    count++;
	}
	
	//----------------------------------
	// Move back to where we were.
	seek(oldPosition);
	
	return(count);
}

//---------------------------------------------------------------------------
long CSVFile::countCols (void)
{
	long count = 0, maxCols = 0;
	long oldPosition = logicalPosition;
	
	seek(0);		//Start at the top.
	char tmp[2048];
	char *currentChk = tmp;
	
	readLine((BYTE*)tmp,2047);
	currentChk = tmp;
	while (currentChk && (*currentChk != '\n') && (*currentChk != '\r'))
	{
		count++;
		currentChk++;
		currentChk = strstr(currentChk,",");
	}
	
	if (count > maxCols)
		maxCols = count;
		
	readLine((BYTE*)tmp,2047);
	
	//----------------------------------
	// Move back to where we were.
	seek(oldPosition);
	
	return(maxCols);
}

//---------------------------------------------------------------------------
long CSVFile::getNextWord (char *&line, char *buffer, unsigned long bufLen)
{
	//--------------------------------------------------
	// Check to see if we are at end of line
	if (*line == '\0')
		return(-1);
		
	//--------------------------------------------------
	// Check to see if the rest of the line is comments
	if (*line == '/')
		return(-1);

	if ( *line == ',' ) // empty column, move on
		return -1;
		
	//------------------------------------------
	// Find start of word from current location
	while ((*line != '\0') && ((*line == ' ') || (*line == '\t') || (*line == ',')))
	{
		line++;
	}
	
	//--------------------------------------------------
	// Check to see if we are at end of line
	if (*line == '\0')
		return(-1);
		
	//--------------------------------------------------
	// Check to see if the rest of the line is comments
	if (*line == '/')
		return(-1);
		
	//-------------------------------------------
	// Find length of word from current location
	char *startOfWord = line;
	unsigned long wordLength = 0;
	while ((*line != '\0') && ((*line != ',')))
	{
		line++;
		wordLength++;
	}
	
	if (wordLength > bufLen)
		return(-2);
		
	strncpy(buffer, startOfWord, wordLength);
	buffer[wordLength] = '\0';
	
	return(NO_ERR);
}

//---------------------------------------------------------------------------
long CSVFile::afterOpen (void)
{
	//-------------------------------------------------------
	// Check if we opened this with CREATE and write the
	// FITini Header and position to Write Start.
	if (fileMode == CREATE && parent == NULL)
	{
		ASSERT(("Cannot write CSV files at present."));
	}
	else
	{
		//------------------------------------------------------
		// Find out how many Rows and cols we have
		totalRows = countRows();
		totalCols = countCols();
	}

	return(NO_ERR);
}

//---------------------------------------------------------------------------
void CSVFile::atClose (void)
{
	//------------------------------------------------------------
	// Check if we are in create mode and if so, write the footer
	if (fileMode == CREATE)
	{
		ASSERT(("Cannot write CSV files at present."));
	}

	totalRows = totalCols = 0;
}

//---------------------------------------------------------------------------
float CSVFile::textToFloat (char *num)
{
	float result = (float)atof(num);
	return(result);
}

//---------------------------------------------------------------------------
long CSVFile::textToLong (char *num)
{
	long result = 0;
	
	//------------------------------------
	// Check if Hex Number
	char *hexOffset = strstr(num,"0x");
	if (hexOffset == NULL)
	{
		result = atol(num);
	}
	else
	{
		hexOffset += 2;
		long numDigits = strlen(hexOffset)-1;
		for (int i=0; i<=numDigits; i++)
		{
			if (!isalnum(hexOffset[i]) || (isalpha(hexOffset[i]) && toupper(hexOffset[i]) > 'F'))
			{
				hexOffset[i] = 0;	// we've reach a "wrong" character. Either start of a comment or something illegal. Either way, stop evaluation here.
				break;
			}
		}
		numDigits = strlen(hexOffset)-1;
		long power = 0;
		for (long count = numDigits;count >= 0;count--,power++)
		{
			unsigned char currentDigit = (unsigned char)toupper(hexOffset[count]);
			
			if (currentDigit >= 'A' && currentDigit <= 'F')
			{
				result += (currentDigit - 'A' + 10)<<(4*power);
			}
			else if (currentDigit >= '0' && currentDigit <= '9')
			{
				result += (currentDigit - '0')<<(4*power);
			}
			else
			{
				//---------------------------------------------------------
				// There is a digit in here I don't understand.  Return 0.
				result = 0;
				break;
			}
		}
	}

	
	return(result);
}


//---------------------------------------------------------------------------
short CSVFile::textToShort (char *num)
{
	short result = 0;
	
	//------------------------------------
	// Check if Hex Number
	char *hexOffset = strstr(num,"0x");
	if (hexOffset == NULL)
	{
		result = (short)atol(num);
	}
	else
	{
		hexOffset += 2;
		long numDigits = strlen(hexOffset)-1;
		for (int i=0; i<=numDigits; i++)
		{
			if (!isalnum(hexOffset[i]) || (isalpha(hexOffset[i]) && toupper(hexOffset[i]) > 'F'))
			{
				hexOffset[i] = 0;	// we've reach a "wrong" character. Either start of a comment or something illegal. Either way, stop evaluation here.
				break;
			}
		}
		numDigits = strlen(hexOffset)-1;
		long power = 0;
		for (long count = numDigits;count >= 0;count--,power++)
		{
			unsigned char currentDigit = (unsigned char)toupper(hexOffset[count]);
			
			if (currentDigit >= 'A' && currentDigit <= 'F')
			{
				result += (currentDigit - 'A' + 10)<<(4*power);
			}
			else if (currentDigit >= '0' && currentDigit <= '9')
			{
				result += (currentDigit - '0')<<(4*power);
			}
			else
			{
				//---------------------------------------------------------
				// There is a digit in here I don't understand.  Return 0.
				result = 0;
				break;
			}
		}
	}
	
	return(result);
}


//---------------------------------------------------------------------------
char CSVFile::textToChar (char *num)
{
	char result = 0;
	
	//------------------------------------
	// Check if Hex Number
	char *hexOffset = strstr(num,"0x");
	if (hexOffset == NULL)
	{
		result = (char)atol(num);
	}
	else
	{
		hexOffset += 2;
		long numDigits = strlen(hexOffset)-1;
		for (int i=0; i<=numDigits; i++)
		{
			if (!isalnum(hexOffset[i]) || (isalpha(hexOffset[i]) && toupper(hexOffset[i]) > 'F'))
			{
				hexOffset[i] = 0;	// we've reach a "wrong" character. Either start of a comment or something illegal. Either way, stop evaluation here.
				break;
			}
		}
		numDigits = strlen(hexOffset)-1;
		long power = 0;
		for (long count = numDigits;count >= 0;count--,power++)
		{
			unsigned char currentDigit = (unsigned char)toupper(hexOffset[count]);
			
			if (currentDigit >= 'A' && currentDigit <= 'F')
			{
				result += (currentDigit - 'A' + 10)<<(4*power);
			}
			else if (currentDigit >= '0' && currentDigit <= '9')
			{
				result += (currentDigit - '0')<<(4*power);
			}
			else
			{
				//---------------------------------------------------------
				// There is a digit in here I don't understand.  Return 0.
				result = 0;
				break;
			}
		}
	}
	
	return(result);
}

//---------------------------------------------------------------------------
unsigned long CSVFile::textToULong (char *num)
{
	unsigned long result = 0;
	
	//------------------------------------
	// Check if Hex Number
	char *hexOffset = strstr(num,"0x");
	if (hexOffset == NULL)
	{
		result = atol(num);
	}
	else
	{
		hexOffset += 2;
		long numDigits = strlen(hexOffset)-1;
		for (int i=0; i<=numDigits; i++)
		{
			if (!isalnum(hexOffset[i]) || (isalpha(hexOffset[i]) && toupper(hexOffset[i]) > 'F'))
			{
				hexOffset[i] = 0;	// we've reach a "wrong" character. Either start of a comment or something illegal. Either way, stop evaluation here.
				break;
			}
		}
		numDigits = strlen(hexOffset)-1;
		long power = 0;
		for (long count = numDigits;count >= 0;count--,power++)
		{
			unsigned char currentDigit = (unsigned char)toupper(hexOffset[count]);
			
			if (currentDigit >= 'A' && currentDigit <= 'F')
			{
				result += (currentDigit - 'A' + 10)<<(4*power);
			}
			else if (currentDigit >= '0' && currentDigit <= '9')
			{
				result += (currentDigit - '0')<<(4*power);
			}
			else
			{
				//---------------------------------------------------------
				// There is a digit in here I don't understand.  Return 0.
				result = 0;
				break;
			}
		}
	}
	
	return(result);
}


//---------------------------------------------------------------------------
unsigned short CSVFile::textToUShort (char *num)
{
	unsigned short result = 0;
	
	//------------------------------------
	// Check if Hex Number
	char *hexOffset = strstr(num,"0x");
	if (hexOffset == NULL)
	{
		result = (unsigned short)atol(num);
	}
	else
	{
		hexOffset += 2;
		long numDigits = strlen(hexOffset)-1;
		for (int i=0; i<=numDigits; i++)
		{
			if (!isalnum(hexOffset[i]) || (isalpha(hexOffset[i]) && toupper(hexOffset[i]) > 'F'))
			{
				hexOffset[i] = 0;	// we've reach a "wrong" character. Either start of a comment or something illegal. Either way, stop evaluation here.
				break;
			}
		}
		numDigits = strlen(hexOffset)-1;
		long power = 0;
		for (long count = numDigits;count >= 0;count--,power++)
		{
			unsigned char currentDigit = (unsigned char)toupper(hexOffset[count]);
			
			if (currentDigit >= 'A' && currentDigit <= 'F')
			{
				result += (currentDigit - 'A' + 10)<<(4*power);
			}
			else if (currentDigit >= '0' && currentDigit <= '9')
			{
				result += (currentDigit - '0')<<(4*power);
			}
			else
			{
				//---------------------------------------------------------
				// There is a digit in here I don't understand.  Return 0.
				result = 0;
				break;
			}
		}
	}
	
	return(result);
}


//---------------------------------------------------------------------------
unsigned char CSVFile::textToUChar (char *num)
{
	unsigned char result = 0;
	
	//------------------------------------
	// Check if Hex Number
	char *hexOffset = strstr(num,"0x");
	if (hexOffset == NULL)
	{
		result = (unsigned char)atol(num);
	}
	else
	{
		hexOffset += 2;
		long numDigits = strlen(hexOffset)-1;
		for (int i=0; i<=numDigits; i++)
		{
			if (!isalnum(hexOffset[i]) || (isalpha(hexOffset[i]) && toupper(hexOffset[i]) > 'F'))
			{
				hexOffset[i] = 0;	// we've reach a "wrong" character. Either start of a comment or something illegal. Either way, stop evaluation here.
				break;
			}
		}
		numDigits = strlen(hexOffset)-1;
		long power = 0;
		for (long count = numDigits;count >= 0;count--,power++)
		{
			unsigned char currentDigit = (unsigned char)toupper(hexOffset[count]);
			
			if (currentDigit >= 'A' && currentDigit <= 'F')
			{
				result += (currentDigit - 'A' + 10)<<(4*power);
			}
			else if (currentDigit >= '0' && currentDigit <= '9')
			{
				result += (currentDigit - '0')<<(4*power);
			}
			else
			{
				//---------------------------------------------------------
				// There is a digit in here I don't understand.  Return 0.
				result = 0;
				break;
			}
		}
	}
	
	return(result);
}

//---------------------------------------------------------------------------
bool CSVFile::booleanToLong (char *num)
{
	char testChar = 0;
	while (num[testChar] && isspace(num[testChar]))
		testChar++;

	// 'N' == NO if you can believe that
	if ((toupper(num[testChar]) == 'F') || (toupper(num[testChar]) == '0') || (toupper(num[testChar]) == 'N') )
		return FALSE;
	else
		return(TRUE);
}	

//---------------------------------------------------------------------------
long CSVFile::floatToText (char *result, float num, unsigned long bufLen)
{
	char temp[250];
	sprintf(temp,"%f4",num);

	unsigned long numLength = strlen(temp);
	if (numLength >= bufLen)
		return(-2);

	strncpy(result,temp,numLength);
	result[numLength] = '\0';
	
	return(NO_ERR);
}			

//---------------------------------------------------------------------------
long CSVFile::longToTextDec (char *result, long num, unsigned long bufLen)
{
	char temp[250];
	sprintf(temp,"%d",num);

	unsigned long numLength = strlen(temp);
	if (numLength >= bufLen)
		return(-2);

	strncpy(result,temp,numLength);
	result[numLength] = '\0';
	
	return(NO_ERR);
}	

//---------------------------------------------------------------------------
long CSVFile::longToTextHex (char *result, long num, unsigned long bufLen)
{
	char temp[250];
	sprintf(temp,"0x%x",num);

	unsigned long numLength = strlen(temp);
	if (numLength >= bufLen)
		return(-2);

	strncpy(result,temp,numLength);
	result[numLength] = '\0';
	
	return(NO_ERR);
}	

//---------------------------------------------------------------------------
long CSVFile::shortToTextDec (char *result, short num, unsigned long bufLen)
{
	char temp[250];
	sprintf(temp,"%d",num);

	unsigned long numLength = strlen(temp);
	if (numLength >= bufLen)
		return(-2);

	strncpy(result,temp,numLength);
	result[numLength] = '\0';
	
	return(NO_ERR);
}	

//---------------------------------------------------------------------------
long CSVFile::shortToTextHex (char *result, short num, unsigned long bufLen)
{
	char temp[250];
	sprintf(temp,"0x%x",num);

	unsigned long numLength = strlen(temp);
	if (numLength >= bufLen)
		return(-2);

	strncpy(result,temp,numLength);
	result[numLength] = '\0';
	
	return(NO_ERR);
}	

//---------------------------------------------------------------------------
long CSVFile::byteToTextDec (char *result, byte num, unsigned long bufLen)
{
	char temp[250];
	sprintf(temp,"%d",num);

	unsigned long numLength = strlen(temp);
	if (numLength >= bufLen)
		return(-2);

	strncpy(result,temp,numLength);
	result[numLength] = '\0';
	
	return(NO_ERR);
}	

//---------------------------------------------------------------------------
long CSVFile::byteToTextHex (char *result, byte num, unsigned long bufLen)
{
	char temp[250];
	sprintf(temp,"0x%x",num);

	unsigned long numLength = strlen(temp);
	if (numLength >= bufLen)
		return(-2);

	strncpy(result,temp,numLength);
	result[numLength] = '\0';
	
	return(NO_ERR);
}	

//---------------------------------------------------------------------------
long CSVFile::open (const char* fName, FileMode _mode, long numChild)
{
	long result = File::open(fName,_mode,numChild);
	if (result != NO_ERR)
		return(result);
		
	seek(0);

	result = afterOpen();
	
	return(result);
}

//---------------------------------------------------------------------------
long CSVFile::open (File* _parent, unsigned long fileSize, long numChild)
{
	numChild = -1;		//Force all parented CSVs to load from RAM.
	long result = File::open(_parent,fileSize,numChild);
	if (result != NO_ERR)
		return(result);
		
	result = afterOpen();
	
	return(result);
}

//---------------------------------------------------------------------------
long CSVFile::create (char* fName)
{
	fName;
	//STOP(("CSV file write is not supported %s",fName));
	return(-1);
}

//---------------------------------------------------------------------------
void CSVFile::close (void)
{
	if (isOpen())
	{
		atClose();
		File::close();
	}
}

//---------------------------------------------------------------------------
long CSVFile::seekRowCol (DWORD row, DWORD col)
{
	if ((row > totalRows) || (col > totalCols) || (row < 1) || (col < 1) )
		return -1;
		
	DWORD rowCount = 0;
	
	seek(0);		//Start at the top.
	char tmp[2048];
	
	do
	{
		rowCount++;
		readLine((BYTE*)tmp,2047);
	} while (rowCount != row);  
	
	char *currentChk = tmp;
	if (col)
	{
		DWORD colCount = 1;
		
		while (currentChk && (colCount != col))
		{
			colCount++;
			currentChk = strstr(currentChk,",");
			if ( currentChk ) // if we increment to one, all hell breaks loose
				currentChk++;

		}
	}
	
	//---------------------------------------------------
	// We are now pointing at the row and col specified.
	if (currentChk)
	{
		char *data = dataBuffer;
		return getNextWord(currentChk,data,2047);
	}
	else
	{
		return -1;
		// CAN'T do this, for some reason excel writes out empty rows.
		//STOP(("Unable to parse CSV %s, ROW %d, COL %D, ERROR: NULL",getFilename(),row,col));
	}
	
	//return(NO_ERR);
}

//---------------------------------------------------------------------------
long CSVFile::readFloat (DWORD row, DWORD col, float &value)
{
	long result = seekRowCol(row,col);
	if (result == NO_ERR)
	{
		value = textToFloat(dataBuffer);
	}
	else
		value = 0.0f;
	
	return(NO_ERR);
}

//---------------------------------------------------------------------------
long CSVFile::readLong (DWORD row, DWORD col, long &value)
{
	long result = seekRowCol(row,col);
	if (result == NO_ERR)
	{
		value = textToLong(dataBuffer);
	}
	else
		value = 0;
	
	return(NO_ERR);
}

//---------------------------------------------------------------------------
long CSVFile::readBoolean (DWORD row, DWORD col, bool &value)
{
	long result = seekRowCol(row,col);
	if (result == NO_ERR)
	{
		value = booleanToLong(dataBuffer);
	}
	else
		value = 0;
	
	return(NO_ERR);
}

//---------------------------------------------------------------------------
long CSVFile::readShort (DWORD row, DWORD col, short &value)
{
	long result = seekRowCol(row,col);
	if (result == NO_ERR)
	{
		value = textToShort(dataBuffer);
	}
	else
		value = 0;
	
	return(NO_ERR);
}

//---------------------------------------------------------------------------
long CSVFile::readChar (DWORD row, DWORD col, char &value)
{
	long result = seekRowCol(row,col);
	if (result == NO_ERR)
	{
        value =  *dataBuffer;
	//	value = textToChar(dataBuffer);
	}
	else
		value = 0;
	
	return(NO_ERR);
}

//---------------------------------------------------------------------------
long CSVFile::readULong (DWORD row, DWORD col, unsigned long &value)
{
	long result = seekRowCol(row,col);
	if (result == NO_ERR)
	{
		value = textToULong(dataBuffer);
	}
	else
		value = 0;
	
	return(NO_ERR);
}

//---------------------------------------------------------------------------
long CSVFile::readUShort (DWORD row, DWORD col, unsigned short &value)
{
	long result = seekRowCol(row,col);
	if (result == NO_ERR)
	{
		value = textToUShort(dataBuffer);
	}
	else
		value = 0;
	
	return(NO_ERR);
}

//---------------------------------------------------------------------------
long CSVFile::readUChar (DWORD row, DWORD col, unsigned char &value)
{
	long result = seekRowCol(row,col);
	if (result == NO_ERR)
	{
		value = textToUChar(dataBuffer);
	}
	else
		value = 0;
	
	return(NO_ERR);
}

//---------------------------------------------------------------------------
long CSVFile::copyString (char *dest, char *src, unsigned long bufLen)
{
	unsigned long offset = 0;
	//---------------------------------------
	// Copy each character until close quote
	while (*src != '"' && *src != '\0' && offset < bufLen)
	{
		dest[offset] = *src;
		src++;
		offset++;
	}

	//----------------------------------------------------
	// If this string is longer than buffer, let em know.
	if (offset == bufLen)
	{
		return(-2);
	}

	//---------------------------------
	// otherwise, NULL term and return	
	dest[offset] = '\0';
	return(NO_ERR);
}

//---------------------------------------------------------------------------
long CSVFile::readString (DWORD row, DWORD col, char *result, unsigned long bufferSize)
{
	long res = seekRowCol(row,col);
	if (res == NO_ERR)
	{
		long errorCode = copyString(result,dataBuffer,bufferSize);
		if (errorCode != NO_ERR)
			return(errorCode);
	}
	else
		return 1;	
	return(0); // gotta return some kind of error!
}

//---------------------------------------------------------------------------
//
// Edit log
//
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\xodash\aseConv\Inifile.cpp ===
//---------------------------------------------------------------------------
//
// inifile.cpp - This file contains the class declaration for the FitIni Files
//
//				The FitIni file is a ini style file.
//
//	Honor Bound -- FASA Interactive Technologies
//
//	Copyright (c) 1995 FASA Interactive Technologies
//
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
// Include files

#include "std.h"
#ifndef INIFILE_H
#include "inifile.h"
#endif
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <ctype.h>

#include "err.h"

#define strnicmp _strnicmp


//---------------------------------------------------------------------------
// Static Globals
char fitIniHeader[7] = "FITini";
char fitIniFooter[7] = "FITend";

#undef isspace		//Macro Chokes under Intel Compiler!!

//---------------------------------------------------------------------------
// class FitIniFile
FitIniFile::FitIniFile (void) : File()
{
	totalBlocks = 0;
	fileBlocks = NULL;
	
	currentBlockId = NULL;
	currentBlockOffset = 0;
	currentBlockSize = 0;
}

//---------------------------------------------------------------------------
FitIniFile::~FitIniFile (void)
{
	close();
}

//---------------------------------------------------------------------------
long FitIniFile::findNextBlockStart (char *line, unsigned long lineLen)
{
	char thisLine[255];
	char *common = NULL;
	
	do
	{
		if (line)
		{
			readLine((BYTE*)line,lineLen);
			common = line;
		}
		else
		{
			readLine((BYTE*)thisLine,254);
			common = thisLine;
		}
	}
	while(!eof() && (common[0] != '['));
	
	if (eof())
	{
		return(NO_MORE_BLOCKS);
	}

	return(NO_ERR);
}	

//---------------------------------------------------------------------------
long FitIniFile::countBlocks (void)
{
	long count = 0;
	long oldPosition = logicalPosition;
	
	while (findNextBlockStart() != NO_MORE_BLOCKS)
	{
		count++;
	}
	
	//----------------------------------
	// Move back to where we were.
	seek(oldPosition);
	
	return(count);
}

//---------------------------------------------------------------------------
long FitIniFile::getNextWord (char *&line, char *buffer, unsigned long bufLen)
{
	//--------------------------------------------------
	// Check to see if we are at end of line
	if (*line == '\0')
		return(GET_NEXT_LINE);
		
	//--------------------------------------------------
	// Check to see if the rest of the line is comments
	if (*line == '/')
		return(GET_NEXT_LINE);
		
	//------------------------------------------
	// Find start of word from current location
	while ((*line != '\0') && ((*line == ' ') || (*line == '\t') || (*line == ',')))
	{
		line++;
	}
	
	//--------------------------------------------------
	// Check to see if we are at end of line
	if (*line == '\0')
		return(GET_NEXT_LINE);
		
	//--------------------------------------------------
	// Check to see if the rest of the line is comments
	if (*line == '/')
		return(GET_NEXT_LINE);
		
	//-------------------------------------------
	// Find length of word from current location
	char *startOfWord = line;
	unsigned long wordLength = 0;
	while ((*line != '\0') && ((*line != ' ') && (*line != '\t') && (*line != ',')))
	{
		line++;
		wordLength++;
	}
	
	if (wordLength > bufLen)
		return(BUFFER_TOO_SMALL);
		
	strncpy(buffer, startOfWord, wordLength);
	buffer[wordLength] = '\0';
	
	return(NO_ERR);
}

//---------------------------------------------------------------------------
long FitIniFile::afterOpen (void)
{
	char line[255];
	
	//-------------------------------------------------------
	// Check if we opened this with CREATE and write the
	// FITini Header and position to Write Start.
	if (fileMode == CREATE && parent == NULL)
	{
		sprintf(line,"%s \r\n",fitIniHeader);
		write((BYTE*)line,strlen(line));

		totalBlocks = 0;
	}
	else
	{
		//------------------------------------------------------
		// Check if this is a FitIniFile by looking for header.
		char chkHeader[12];
	
		readLine((BYTE*)chkHeader,11);
		if (strstr(chkHeader,fitIniHeader) == NULL)
			return(NOT_A_FITINIFILE);

				//------------------------------------------------------
		// Find out how many blocks we have	
		totalBlocks = countBlocks();
		
		//--------------------------------------------------------------------------
		// Allocate RAM for the BlockInfoNodes.  Check if system Heap is available
		fileBlocks = new IniBlockNode[totalBlocks];
		
		ASSERT(fileBlocks != NULL);

		memset(fileBlocks,0,sizeof(IniBlockNode) * totalBlocks);
		
		//--------------------------------------------------------------------------
		// Put Info into fileBlocks.
		
		unsigned long currentBlockNum = 0;
		while (findNextBlockStart(line,254) != NO_MORE_BLOCKS)
		{
			//----------------------------------------------------
			// If we write too many fileBlocks, we will trash RAM
			// Shouldn't be able to happen but...
			if (currentBlockNum == totalBlocks)
				return(TOO_MANY_BLOCKS);

			long count = 1;
			while (line[count] != ']' && line[count] != '\n')
			{
				fileBlocks[currentBlockNum].blockId[count-1] = line[count];
				count++;
			}
			if (count >= 49)
				ASSERT(("BlockId To large in Fit File %s",fileName));

			if (line[count] == '\n')
			{
				char error[256];
				sprintf( error, "couldn't resolve block %s in file %s", line, getFilename() );
				ASSERT( error );
				return SYNTAX_ERROR;
			}
			
			fileBlocks[currentBlockNum].blockId[count-1] = '\0';
			
			//----------------------------------------------------------------------
			// Since we just read all of last line, we now point to start of data
			fileBlocks[currentBlockNum].blockOffset = logicalPosition;
			currentBlockNum++;
		}

		//------------------------------------------------------
		// If we didn't read in enough, CD-ROM error?
		if (currentBlockNum != totalBlocks)
			return(NOT_ENOUGH_BLOCKS);
	}

	return(NO_ERR);
}

//---------------------------------------------------------------------------
void FitIniFile::atClose (void)
{
	//------------------------------------------------------------
	// Check if we are in create mode and if so, write the footer
	char line[200];
	if (fileMode == CREATE)
	{
		seek(0,SEEK_END);
		sprintf(line,"%s \r\n",fitIniFooter);
		write((BYTE*)line,strlen(line));
	}

	//-----------------------------
	// Free up the fileBlocks
	if ( fileBlocks )
    {
        delete fileBlocks;
    }
	fileBlocks = NULL;
}

//---------------------------------------------------------------------------
float FitIniFile::textToFloat (const char *num)
{
	float result = (float)atof(num);
	return(result);
}

//---------------------------------------------------------------------------
double FitIniFile::textToDouble (const char *num)
{
	double result = atof(num);
	return(result);
}

//---------------------------------------------------------------------------
long FitIniFile::textToLong (const char *num)
{
	long result = 0;
	
	//------------------------------------
	// Check if Hex Number
	char *hexOffset = strstr(num,"0x");
	if (hexOffset == NULL)
	{
		result = atol(num);
	}
	else
	{
		hexOffset += 2;
		long numDigits = strlen(hexOffset)-1;
		for (int i=0; i<=numDigits; i++)
		{
			if (!isalnum(hexOffset[i]) || (isalpha(hexOffset[i]) && toupper(hexOffset[i]) > 'F'))
			{
				hexOffset[i] = 0;	// we've reach a "wrong" character. Either start of a comment or something illegal. Either way, stop evaluation here.
				break;
			}
		}
		numDigits = strlen(hexOffset)-1;
		long power = 0;
		for (long count = numDigits;count >= 0;count--,power++)
		{
			unsigned char currentDigit = (unsigned char)toupper(hexOffset[count]);
			
			if (currentDigit >= 'A' && currentDigit <= 'F')
			{
				result += (currentDigit - 'A' + 10)<<(4*power);
			}
			else if (currentDigit >= '0' && currentDigit <= '9')
			{
				result += (currentDigit - '0')<<(4*power);
			}
			else
			{
				//---------------------------------------------------------
				// There is a digit in here I don't understand.  Return 0.
				result = 0;
				break;
			}
		}
	}

	
	return(result);
}


//---------------------------------------------------------------------------
short FitIniFile::textToShort (const char *num)
{
	short result = 0;
	
	//------------------------------------
	// Check if Hex Number
	char *hexOffset = strstr(num,"0x");
	if (hexOffset == NULL)
	{
		result = (short)atol(num);
	}
	else
	{
		hexOffset += 2;
		long numDigits = strlen(hexOffset)-1;
		for (int i=0; i<=numDigits; i++)
		{
			if (!isalnum(hexOffset[i]) || (isalpha(hexOffset[i]) && toupper(hexOffset[i]) > 'F'))
			{
				hexOffset[i] = 0;	// we've reach a "wrong" character. Either start of a comment or something illegal. Either way, stop evaluation here.
				break;
			}
		}
		numDigits = strlen(hexOffset)-1;
		long power = 0;
		for (long count = numDigits;count >= 0;count--,power++)
		{
			unsigned char currentDigit = (unsigned char)toupper(hexOffset[count]);
			
			if (currentDigit >= 'A' && currentDigit <= 'F')
			{
				result += (currentDigit - 'A' + 10)<<(4*power);
			}
			else if (currentDigit >= '0' && currentDigit <= '9')
			{
				result += (currentDigit - '0')<<(4*power);
			}
			else
			{
				//---------------------------------------------------------
				// There is a digit in here I don't understand.  Return 0.
				result = 0;
				break;
			}
		}
	}
	
	return(result);
}


//---------------------------------------------------------------------------
char FitIniFile::textToChar (const char *num)
{
	char result = 0;
	
	//------------------------------------
	// Check if Hex Number
	char *hexOffset = strstr(num,"0x");
	if (hexOffset == NULL)
	{
		result = (char)atol(num);
	}
	else
	{
		hexOffset += 2;
		long numDigits = strlen(hexOffset)-1;
		for (int i=0; i<=numDigits; i++)
		{
			if (!isalnum(hexOffset[i]) || (isalpha(hexOffset[i]) && toupper(hexOffset[i]) > 'F'))
			{
				hexOffset[i] = 0;	// we've reach a "wrong" character. Either start of a comment or something illegal. Either way, stop evaluation here.
				break;
			}
		}
		numDigits = strlen(hexOffset)-1;
		long power = 0;
		for (long count = numDigits;count >= 0;count--,power++)
		{
			unsigned char currentDigit = (unsigned char)toupper(hexOffset[count]);
			
			if (currentDigit >= 'A' && currentDigit <= 'F')
			{
				result += (currentDigit - 'A' + 10)<<(4*power);
			}
			else if (currentDigit >= '0' && currentDigit <= '9')
			{
				result += (currentDigit - '0')<<(4*power);
			}
			else
			{
				//---------------------------------------------------------
				// There is a digit in here I don't understand.  Return 0.
				result = 0;
				break;
			}
		}
	}
	
	return(result);
}

//---------------------------------------------------------------------------
unsigned long FitIniFile::textToULong (const char *num)
{
	unsigned long result = 0;
	
	//------------------------------------
	// Check if Hex Number
	char *hexOffset = strstr(num,"0x");
	if (hexOffset == NULL)
	{
		result = atol(num);
	}
	else
	{
		hexOffset += 2;
		long numDigits = strlen(hexOffset)-1;
		for (int i=0; i<=numDigits; i++)
		{
			if (!isalnum(hexOffset[i]) || (isalpha(hexOffset[i]) && toupper(hexOffset[i]) > 'F'))
			{
				hexOffset[i] = 0;	// we've reach a "wrong" character. Either start of a comment or something illegal. Either way, stop evaluation here.
				break;
			}
		}
		numDigits = strlen(hexOffset)-1;
		long power = 0;
		for (long count = numDigits;count >= 0;count--,power++)
		{
			unsigned char currentDigit = (unsigned char)toupper(hexOffset[count]);
			
			if (currentDigit >= 'A' && currentDigit <= 'F')
			{
				result += (currentDigit - 'A' + 10)<<(4*power);
			}
			else if (currentDigit >= '0' && currentDigit <= '9')
			{
				result += (currentDigit - '0')<<(4*power);
			}
			else
			{
				//---------------------------------------------------------
				// There is a digit in here I don't understand.  Return 0.
				result = 0;
				break;
			}
		}
	}
	
	return(result);
}


//---------------------------------------------------------------------------
unsigned short FitIniFile::textToUShort (const char *num)
{
	unsigned short result = 0;
	
	//------------------------------------
	// Check if Hex Number
	char *hexOffset = strstr(num,"0x");
	if (hexOffset == NULL)
	{
		result = (short)atol(num);
	}
	else
	{
		hexOffset += 2;
		long numDigits = strlen(hexOffset)-1;
		for (int i=0; i<=numDigits; i++)
		{
			if (!isalnum(hexOffset[i]) || (isalpha(hexOffset[i]) && toupper(hexOffset[i]) > 'F'))
			{
				hexOffset[i] = 0;	// we've reach a "wrong" character. Either start of a comment or something illegal. Either way, stop evaluation here.
				break;
			}
		}
		numDigits = strlen(hexOffset)-1;
		long power = 0;
		for (long count = numDigits;count >= 0;count--,power++)
		{
			unsigned char currentDigit = (unsigned char)toupper(hexOffset[count]);
			
			if (currentDigit >= 'A' && currentDigit <= 'F')
			{
				result += (currentDigit - 'A' + 10)<<(4*power);
			}
			else if (currentDigit >= '0' && currentDigit <= '9')
			{
				result += (currentDigit - '0')<<(4*power);
			}
			else
			{
				//---------------------------------------------------------
				// There is a digit in here I don't understand.  Return 0.
				result = 0;
				break;
			}
		}
	}
	
	return(result);
}


//---------------------------------------------------------------------------
unsigned char FitIniFile::textToUChar (const char *num)
{
	unsigned char result = 0;
	
	//------------------------------------
	// Check if Hex Number
	char *hexOffset = strstr(num,"0x");
	if (hexOffset == NULL)
	{
		result = (unsigned char)atol(num);
	}
	else
	{
		hexOffset += 2;
		long numDigits = strlen(hexOffset)-1;
		for (int i=0; i<=numDigits; i++)
		{
			if (!isalnum(hexOffset[i]) || (isalpha(hexOffset[i]) && toupper(hexOffset[i]) > 'F'))
			{
				hexOffset[i] = 0;	// we've reach a "wrong" character. Either start of a comment or something illegal. Either way, stop evaluation here.
				break;
			}
		}
		numDigits = strlen(hexOffset)-1;
		long power = 0;
		for (long count = numDigits;count >= 0;count--,power++)
		{
			unsigned char currentDigit = (unsigned char)toupper(hexOffset[count]);
			
			if (currentDigit >= 'A' && currentDigit <= 'F')
			{
				result += (currentDigit - 'A' + 10)<<(4*power);
			}
			else if (currentDigit >= '0' && currentDigit <= '9')
			{
				result += (currentDigit - '0')<<(4*power);
			}
			else
			{
				//---------------------------------------------------------
				// There is a digit in here I don't understand.  Return 0.
				result = 0;
				break;
			}
		}
	}
	
	return(result);
}

//---------------------------------------------------------------------------
bool FitIniFile::booleanToLong (const char *num)
{
char testChar = 0;
	while (num[testChar] && isspace(num[testChar]))
		testChar++;

	if ((toupper(num[testChar]) == 'F') || (toupper(num[testChar]) == '0'))
		return FALSE;
	else
		return(TRUE);
}	

//---------------------------------------------------------------------------
long FitIniFile::floatToText (char *result, float num, unsigned long bufLen)
{
	char temp[250];
	sprintf(temp,"%f4",num);

	unsigned long numLength = strlen(temp);
	if (numLength >= bufLen)
		return(BUFFER_TOO_SMALL);

	strncpy(result,temp,numLength);
	result[numLength] = '\0';
	
	return(NO_ERR);
}			

//---------------------------------------------------------------------------
long FitIniFile::longToTextDec (char *result, long num, unsigned long bufLen)
{
	char temp[250];
	sprintf(temp,"%d",num);

	unsigned long numLength = strlen(temp);
	if (numLength >= bufLen)
		return(BUFFER_TOO_SMALL);

	strncpy(result,temp,numLength);
	result[numLength] = '\0';
	
	return(NO_ERR);
}	

//---------------------------------------------------------------------------
long FitIniFile::longToTextHex (char *result, long num, unsigned long bufLen)
{
	char temp[250];
	sprintf(temp,"0x%x",num);

	unsigned long numLength = strlen(temp);
	if (numLength >= bufLen)
		return(BUFFER_TOO_SMALL);

	strncpy(result,temp,numLength);
	result[numLength] = '\0';
	
	return(NO_ERR);
}	

//---------------------------------------------------------------------------
long FitIniFile::shortToTextDec (char *result, short num, unsigned long bufLen)
{
	char temp[250];
	sprintf(temp,"%d",num);

	unsigned long numLength = strlen(temp);
	if (numLength >= bufLen)
		return(BUFFER_TOO_SMALL);

	strncpy(result,temp,numLength);
	result[numLength] = '\0';
	
	return(NO_ERR);
}	

//---------------------------------------------------------------------------
long FitIniFile::shortToTextHex (char *result, short num, unsigned long bufLen)
{
	char temp[250];
	sprintf(temp,"0x%x",num);

	unsigned long numLength = strlen(temp);
	if (numLength >= bufLen)
		return(BUFFER_TOO_SMALL);

	strncpy(result,temp,numLength);
	result[numLength] = '\0';
	
	return(NO_ERR);
}	

//---------------------------------------------------------------------------
long FitIniFile::byteToTextDec (char *result, byte num, unsigned long bufLen)
{
	char temp[250];
	sprintf(temp,"%d",num);

	unsigned long numLength = strlen(temp);
	if (numLength >= bufLen)
		return(BUFFER_TOO_SMALL);

	strncpy(result,temp,numLength);
	result[numLength] = '\0';
	
	return(NO_ERR);
}	

//---------------------------------------------------------------------------
long FitIniFile::byteToTextHex (char *result, byte num, unsigned long bufLen)
{
	char temp[250];
	sprintf(temp,"0x%x",num);

	unsigned long numLength = strlen(temp);
	if (numLength >= bufLen)
		return(BUFFER_TOO_SMALL);

	strncpy(result,temp,numLength);
	result[numLength] = '\0';
	
	return(NO_ERR);
}	

//---------------------------------------------------------------------------
long FitIniFile::open (const char* fName, FileMode _mode, long numChild)
{
	long result = File::open(fName,_mode,numChild);
	if (result != NO_ERR)
		return(result);
		
	seek(0);

	result = afterOpen();
	
	return(result);
}

//---------------------------------------------------------------------------
long FitIniFile::open (File* _parent, unsigned long fileSize, long numChild)
{
	numChild = -1;		//Force all parented FitINIs to load from RAM.
	long result = File::open(_parent,fileSize,numChild);
	if (result != NO_ERR)
		return(result);
		
	result = afterOpen();
	
	return(result);
}

//---------------------------------------------------------------------------
long FitIniFile::create (char* fName)
{
	long result = File::create(fName);
	afterOpen();
	return(result);
}

long FitIniFile::createWithCase( char* fName )
{
	long result = File::createWithCase( fName );
	afterOpen();
	return result;
}

//---------------------------------------------------------------------------
void FitIniFile::close (void)
{
	if (isOpen())
	{
		atClose();
		File::close();
	}
}

//---------------------------------------------------------------------------
long FitIniFile::seekBlock (const char *blockId)
{
	unsigned long blockNum = 0;
	
	while ((blockNum < totalBlocks) && (strcmp(fileBlocks[blockNum].blockId,blockId) != 0))
	{
		blockNum++;
	}
	
	if (blockNum == totalBlocks)
	{
		return(BLOCK_NOT_FOUND);
	}

	//----------------------------------------
	// Block was found, seek to that position
	seek(fileBlocks[blockNum].blockOffset);
	
	//----------------------------------------
	// Setup all current Block Info
	currentBlockId = fileBlocks[blockNum].blockId;
	currentBlockOffset = fileBlocks[blockNum].blockOffset;
	
	blockNum++;
	if (blockNum == totalBlocks)
	{
		currentBlockSize = getLength() - currentBlockOffset;
	}
	else
	{
		currentBlockSize = fileBlocks[blockNum].blockOffset - currentBlockOffset;
	}
		
	return(NO_ERR);
}

//---------------------------------------------------------------------------
long FitIniFile::readIdFloat (const char *varName, float &value)
{
	char line[255];
	char searchString[255];
	
	//--------------------------------
	// Always read from top of Block.
	seek(currentBlockOffset);
	unsigned long endOfBlock = currentBlockOffset+currentBlockSize;
	
	//------------------------
	// Put prefix on varName.
	sprintf(searchString,"f %s",varName);
	
	//--------------------------------
	// Search line by line for varName
	int	testy;
	do
	{
		readLine((BYTE*)line,254);
		testy = strnicmp(line, searchString, strlen(searchString));
		if (testy == 0)
		{
		char* tc = &line[strlen(searchString)];
			while (isspace(*tc))
				tc++;
			if (*tc != '=')
				testy = 1;
		}
	}
	while((testy != 0) && (logicalPosition < endOfBlock));
	
	if (logicalPosition >= endOfBlock)
	{
		value = 0.0;
		return(VARIABLE_NOT_FOUND);
	}
	
	char *equalSign = strstr(line, "=");
	if (equalSign)
	{
		equalSign++;
		value = textToFloat(equalSign);
	}
	else
	{
		return(SYNTAX_ERROR);
	}
	
	return(NO_ERR);
}

//---------------------------------------------------------------------------
long FitIniFile::readIdDouble (const char *varName, double &value)
{
	char line[255];
	char searchString[255];
	
	//--------------------------------
	// Always read from top of Block.
	seek(currentBlockOffset);
	unsigned long endOfBlock = currentBlockOffset+currentBlockSize;
	
	//------------------------
	// Put prefix on varName.
	sprintf(searchString,"f %s",varName);
	
	//--------------------------------
	// Search line by line for varName
	int	testy;
	do
	{
		readLine((BYTE*)line,254);
		testy = strnicmp(line, searchString, strlen(searchString));
		if (testy == 0)
		{
		char* tc = &line[strlen(searchString)];
			while (isspace(*tc))
				tc++;
			if (*tc != '=')
				testy = 1;
		}
	}
	while((testy != 0) && (logicalPosition < endOfBlock));
	
	if (logicalPosition >= endOfBlock)
	{
		value = 0.0;
		return(VARIABLE_NOT_FOUND);
	}
	
	char *equalSign = strstr(line, "=");
	if (equalSign)
	{
		equalSign++;
		value = textToDouble(equalSign);
	}
	else
	{
		return(SYNTAX_ERROR);
	}
	
	return(NO_ERR);
}

//---------------------------------------------------------------------------
long FitIniFile::readIdLong (const char *varName, long &value)
{
	char line[255];
	char searchString[255];
	
	//--------------------------------
	// Always read from top of Block.
	seek(currentBlockOffset);
	unsigned long endOfBlock = currentBlockOffset+currentBlockSize;
	
	//------------------------
	// Put prefix on varName.
	sprintf(searchString,"l %s",varName);
	
	//--------------------------------
	// Search line by line for varName
	int	testy;
	do
	{
		readLine((BYTE*)line,254);
		testy = strnicmp(line, searchString, strlen(searchString));
		if (testy == 0)
		{
		char* tc = &line[strlen(searchString)];
			while (isspace(*tc))
				tc++;
			if (*tc != '=')
				testy = 1;
		}
	}
	while((testy != 0) && (logicalPosition < endOfBlock));
	
	if (logicalPosition >= endOfBlock)
	{
		value = 0;
		return(VARIABLE_NOT_FOUND);
	}
	
	char *equalSign = strstr(line, "=");
	if (equalSign)
	{
		equalSign++;
		value = textToLong(equalSign);
	}
	else
	{
		return(SYNTAX_ERROR);
	}
	
	return(NO_ERR);
}

//---------------------------------------------------------------------------
long FitIniFile::readIdBoolean (const char *varName, bool &value)
{
	char line[255];
	char searchString[255];
	
	//--------------------------------
	// Always read from top of Block.
	seek(currentBlockOffset);
	unsigned long endOfBlock = currentBlockOffset+currentBlockSize;
	
	//------------------------
	// Put prefix on varName.
	sprintf(searchString,"b %s",varName);
	
	//--------------------------------
	// Search line by line for varName
	int	testy;
	do
	{
		readLine((BYTE*)line,254);
		testy = strnicmp(line, searchString, strlen(searchString));
		if (testy == 0)
		{
		char* tc = &line[strlen(searchString)];
			while (isspace(*tc))
				tc++;
			if (*tc != '=')
				testy = 1;
		}
	}
	while((testy != 0) && (logicalPosition < endOfBlock));
	
	if (logicalPosition >= endOfBlock)
	{
		value = 0;
		return(VARIABLE_NOT_FOUND);
	}
	
	char *equalSign = strstr(line, "=");
	if (equalSign)
	{
		equalSign++;
		value = booleanToLong(equalSign);
	}
	else
	{
		return(SYNTAX_ERROR);
	}
	
	return(NO_ERR);
}

//---------------------------------------------------------------------------
long FitIniFile::readIdShort (const char *varName, short &value)
{
	char line[255];
	char searchString[255];
	
	//--------------------------------
	// Always read from top of Block.
	seek(currentBlockOffset);
	unsigned long endOfBlock = currentBlockOffset+currentBlockSize;
	
	//------------------------
	// Put prefix on varName.
	sprintf(searchString,"s %s",varName);
	
	//--------------------------------
	// Search line by line for varName
	int	testy;
	do
	{
		readLine((BYTE*)line,254);
		testy = strnicmp(line, searchString, strlen(searchString));
		if (testy == 0)
		{
		char* tc = &line[strlen(searchString)];
			while (isspace(*tc))
				tc++;
			if (*tc != '=')
				testy = 1;
		}
	}
	while((testy != 0) && (logicalPosition < endOfBlock));
	
	if (logicalPosition >= endOfBlock)
	{
		value = 0;
		return(VARIABLE_NOT_FOUND);
	}
	
	char *equalSign = strstr(line, "=");
	if (equalSign)
	{
		equalSign++;
		value = textToShort(equalSign);
	}
	else
	{
		return(SYNTAX_ERROR);
	}
	
	return(NO_ERR);
}

//---------------------------------------------------------------------------
long FitIniFile::readIdChar (const char *varName, char &value)
{
	char line[255];
	char searchString[255];
	
	//--------------------------------
	// Always read from top of Block.
	seek(currentBlockOffset);
	unsigned long endOfBlock = currentBlockOffset+currentBlockSize;
	
	//------------------------
	// Put prefix on varName.
	sprintf(searchString,"c %s",varName);
	
	//--------------------------------
	// Search line by line for varName
	int	testy;
	do
	{
		readLine((BYTE*)line,254);
		testy = strnicmp(line, searchString, strlen(searchString));
		if (testy == 0)
		{
		char* tc = &line[strlen(searchString)];
			while (isspace(*tc))
				tc++;
			if (*tc != '=')
				testy = 1;
		}
	}
	while((testy != 0) && (logicalPosition < endOfBlock));
	
	if (logicalPosition >= endOfBlock)
	{
		value = 0;
		return(VARIABLE_NOT_FOUND);
	}
	
	char *equalSign = strstr(line, "=");
	if (equalSign)
	{
		equalSign++;
		value = textToChar(equalSign);
	}
	else
	{
		return(SYNTAX_ERROR);
	}
	
	return(NO_ERR);
}

//---------------------------------------------------------------------------
long FitIniFile::readIdULong (const char *varName, unsigned long &value)
{
	char line[255];
	char searchString[255];
	
	//--------------------------------
	// Always read from top of Block.
	seek(currentBlockOffset);
	unsigned long endOfBlock = currentBlockOffset+currentBlockSize;
	
	//------------------------
	// Put prefix on varName.
	sprintf(searchString,"ul %s",varName);
	
	//--------------------------------
	// Search line by line for varName
	int	testy;
	do
	{
		readLine((BYTE*)line,254);
		testy = strnicmp(line, searchString, strlen(searchString));
		if (testy == 0)
		{
			char* tc = &line[strlen(searchString)];
			
			while (isspace(*tc))
				tc++;
				
			if (*tc != '=')
				testy = 1;
		}
	}
	while((testy != 0) && (logicalPosition < endOfBlock));
	
	if (logicalPosition >= endOfBlock)
	{
		value = 0;
		return(VARIABLE_NOT_FOUND);
	}
	
	char *equalSign = strstr(line, "=");
	if (equalSign)
	{
		equalSign++;
		value = textToULong(equalSign);
	}
	else
	{
		return(SYNTAX_ERROR);
	}
	
	return(NO_ERR);
}

//---------------------------------------------------------------------------
long FitIniFile::readIdUShort (const char *varName, unsigned short &value)
{
	char line[255];
	char searchString[255];
	
	//--------------------------------
	// Always read from top of Block.
	seek(currentBlockOffset);
	unsigned long endOfBlock = currentBlockOffset+currentBlockSize;
	
	//------------------------
	// Put prefix on varName.
	sprintf(searchString,"us %s",varName);
	
	//--------------------------------
	// Search line by line for varName
	int	testy;
	do
	{
		readLine((BYTE*)line,254);
		testy = strnicmp(line, searchString, strlen(searchString));
		if (testy == 0)
		{
		char* tc = &line[strlen(searchString)];
			while (isspace(*tc))
				tc++;
			if (*tc != '=')
				testy = 1;
		}
	}
	while((testy != 0) && (logicalPosition < endOfBlock));
	
	if (logicalPosition >= endOfBlock)
	{
		value = 0;
		return(VARIABLE_NOT_FOUND);
	}
	
	char *equalSign = strstr(line, "=");
	if (equalSign)
	{
		equalSign++;
		value = textToUShort(equalSign);
	}
	else
	{
		return(SYNTAX_ERROR);
	}
	
	return(NO_ERR);
}

//---------------------------------------------------------------------------
long FitIniFile::readIdUChar (const char *varName, unsigned char &value)
{
	char line[255];
	char searchString[255];
	
	//--------------------------------
	// Always read from top of Block.
	seek(currentBlockOffset);
	unsigned long endOfBlock = currentBlockOffset+currentBlockSize;
	
	//------------------------
	// Put prefix on varName.
	sprintf(searchString,"uc %s",varName);
	
	//--------------------------------
	// Search line by line for varName
	int	testy;
	do
	{
		readLine((BYTE*)line,254);
		testy = strnicmp(line, searchString, strlen(searchString));
		if (testy == 0)
		{
		char* tc = &line[strlen(searchString)];
			while (isspace(*tc))
				tc++;
			if (*tc != '=')
				testy = 1;
		}
	}
	while((testy != 0) && (logicalPosition < endOfBlock));
	
	if (logicalPosition >= endOfBlock)
	{
		value = 0;
		return(VARIABLE_NOT_FOUND);
	}
	
	char *equalSign = strstr(line, "=");
	if (equalSign)
	{
		equalSign++;
		value = textToUChar(equalSign);
	}
	else
	{
		return(SYNTAX_ERROR);
	}
	
	return(NO_ERR);
}

//---------------------------------------------------------------------------
long FitIniFile::copyString (char *dest, char *src, unsigned long bufLen)
{
	unsigned long offset = 0;
	//---------------------
	// Find starting Quote
	while (*src != '"')
	{
		src++;
	}
	
	src++;		//One more to get to first character past quote.
	
	//---------------------------------------
	// Copy each character until close quote
	while (*src != '"' && offset < bufLen)
	{
		dest[offset] = *src;
		src++;
		offset++;
	}

	//----------------------------------------------------
	// If this string is longer than buffer, let em know.
	if (offset == bufLen)
	{
		return(BUFFER_TOO_SMALL);
	}

	//---------------------------------
	// otherwise, NULL term and return	
	dest[offset] = '\0';
	return(NO_ERR);
}

//---------------------------------------------------------------------------
long FitIniFile::readIdString (const char *varName, char *result, unsigned long bufferSize)
{
	char line[2048];
	char searchString[255];
	
	//--------------------------------
	// Always read from top of Block.
	seek(currentBlockOffset);
	unsigned long endOfBlock = currentBlockOffset+currentBlockSize;
	
	//------------------------
	// Put prefix on varName.
	sprintf(searchString,"st %s",varName);
	
	//--------------------------------
	// Search line by line for varName
	int	testy;
	do
	{
		readLine((BYTE*)line,2047);
		testy = strnicmp(line, searchString, strlen(searchString));
		if (testy == 0)
		{
		char* tc = &line[strlen(searchString)];
			while (isspace(*tc))
				tc++;
			if (*tc != '=')
				testy = 1;
		}
	}
	while((testy != 0) && (logicalPosition < endOfBlock));
	
	if (logicalPosition >= endOfBlock)
	{
		return(VARIABLE_NOT_FOUND);
	}
	
	char *equalSign = strstr(line, "=");
	if (equalSign)
	{
		equalSign++;

		

		char* pFound = NULL;
		char* pFirstEqual = strstr( equalSign, "\"" );
		// strings can span more than one line, make sure there is another equal sign
		if ( pFirstEqual && !strstr( pFirstEqual+1, "\"" ) ) 
		{
			long curLen = strlen( equalSign );
			char tmpLine[2047];
			do
			{
				readLine((BYTE*)tmpLine,2047);
				pFound = strstr( tmpLine, "\"" );

				long addedLen = strlen( tmpLine ) + 1;
				if ( curLen + addedLen < 2048 )
				{
					strcat( equalSign, tmpLine );
					strcat( equalSign, "\n" );
					curLen += addedLen;
				}
				else
					break;

			}while( !pFound && (logicalPosition < endOfBlock) );
		}
		
		long errorCode = copyString(result,equalSign,bufferSize);
		if (errorCode != NO_ERR)
			return(errorCode);
	}
	else
	{
		return(SYNTAX_ERROR);
	}
	
	
	return(NO_ERR);
}

//---------------------------------------------------------------------------
long FitIniFile::getIdStringLength (const char *varName)
{
	char line[255];
	char searchString[255];
	
	//--------------------------------
	// Always read from top of Block.
	seek(currentBlockOffset);
	unsigned long endOfBlock = currentBlockOffset+currentBlockSize;
	
	//------------------------
	// Put prefix on varName.
	sprintf(searchString,"st %s",varName);
	
	//--------------------------------
	// Search line by line for varName
	int	testy;
	do
	{
		readLine((BYTE*)line,254);
		testy = strnicmp(line, searchString, strlen(searchString));
		if (testy == 0)
		{
		char* tc = &line[strlen(searchString)];
			while (isspace(*tc))
				tc++;
			if (*tc != '=')
				testy = 1;
		}
	}
	while((testy != 0) && (logicalPosition < endOfBlock));
	
	if (logicalPosition >= endOfBlock)
	{
		return(VARIABLE_NOT_FOUND);
	}
	
	char *equalSign = strchr(line, '"');
	if (equalSign)
	{
		equalSign++;
		char* end = equalSign;
		while (*end != '"' && *end != 0)
			end++;
		if (*end)
			return (end - equalSign + 1);	// + for terminator
		else
			return(SYNTAX_ERROR);
	}

	return(SYNTAX_ERROR);
}

//---------------------------------------------------------------------------
long FitIniFile::readIdFloatArray (const char *varName, float *result, unsigned long numElements)
{
	char line[255];
	char frontSearch[10];
	char searchString[255];
	
	//--------------------------------
	// Always read from top of Block.
	seek(currentBlockOffset);
	unsigned long endOfBlock = currentBlockOffset+currentBlockSize;
	
	//------------------------------------------------------------------
	// Create two search strings so that we can match any number in []
	sprintf(frontSearch,"f[");
	sprintf(searchString,"] %s",varName);
	
	//--------------------------------
	// Search line by line for varName
	char *fSearch = NULL;
	char *bSearch = NULL;
	
	do
	{
		readLine((BYTE*)line,254);
		
		fSearch = strstr(line,frontSearch);
		bSearch = strstr(line,searchString);
	}
	while(((fSearch == NULL) || (bSearch == NULL)) && (logicalPosition < endOfBlock));
	
	if (logicalPosition >= endOfBlock)
	{
		return(VARIABLE_NOT_FOUND);
	}

	//--------------------------------------
	// Get number of elements in array.
	char elementString[10];
	unsigned long actualElements;
	
	fSearch += 2;												//Move pointer to first number in brackets.
	long numDigits = bSearch - fSearch;

	if (numDigits > 9)
		return(TOO_MANY_ELEMENTS);

	strncpy(elementString,fSearch,numDigits);
	elementString[numDigits] = '\0';
	
	actualElements = textToULong(elementString);	

	if (actualElements > numElements)
		return(USER_ARRAY_TOO_SMALL);
		
	//------------------------------
	// Parse out the elements here.
	char *equalSign = strstr(line, "=");
	unsigned long elementsRead = 0;
	if (equalSign)
	{
		equalSign++; //Move to char past equal sign.

		//--------------------------------------------------------------------------------
		// Now, loop until we reach the end of block or we've read in all of the elements
		while ((logicalPosition < endOfBlock) && (elementsRead < actualElements))
		{
			long errorCode = getNextWord(equalSign,elementString,9);
			if (errorCode == GET_NEXT_LINE)
			{
				readLine((BYTE*)line,254);
				equalSign = line;
				continue;
			}

			if (errorCode != NO_ERR)
			{
				return(errorCode);
			}
			
			result[elementsRead] = textToFloat(elementString);
			elementsRead++;
		}
		
		if (logicalPosition >= endOfBlock && elementsRead < actualElements)
			return(NOT_ENOUGH_ELEMENTS_FOR_ARRAY);
	}
	else
	{
		return(SYNTAX_ERROR);
	}
		
	return(NO_ERR);
}
		
//---------------------------------------------------------------------------
long FitIniFile::readIdLongArray (const char *varName, long *result, unsigned long numElements)
{
	char line[255];
	char frontSearch[10];
	char searchString[255];
	
	//--------------------------------
	// Always read from top of Block.
	seek(currentBlockOffset);
	unsigned long endOfBlock = currentBlockOffset+currentBlockSize;
	
	//------------------------------------------------------------------
	// Create two search strings so that we can match any number in []
	sprintf(frontSearch,"l[");
	sprintf(searchString,"] %s",varName);
	
	//--------------------------------
	// Search line by line for varName
	char *fSearch = NULL;
	char *bSearch = NULL;
	
	do
	{
		readLine((BYTE*)line,254);
		
		fSearch = strstr(line,frontSearch);
		bSearch = strstr(line,searchString);
	}
	while(((fSearch == NULL) || (bSearch == NULL)) && (logicalPosition < endOfBlock));
	
	if (logicalPosition >= endOfBlock)
	{
		return(VARIABLE_NOT_FOUND);
	}

	//--------------------------------------
	// Get number of elements in array.
	char elementString[10];
	unsigned long actualElements;
	
	fSearch += 2;												//Move pointer to first number in brackets.
	long numDigits = bSearch - fSearch;

	if (numDigits > 9)
		return(TOO_MANY_ELEMENTS);

	strncpy(elementString,fSearch,numDigits);
	elementString[numDigits] = '\0';
	
	actualElements = textToULong(elementString);	

	if (actualElements > numElements)
		return(USER_ARRAY_TOO_SMALL);
		
	//------------------------------
	// Parse out the elements here.
	char *equalSign = strstr(line, "=");
	unsigned long elementsRead = 0;
	if (equalSign)
	{
		equalSign++; //Move to char past equal sign.

		//--------------------------------------------------------------------------------
		// Now, loop until we reach the end of block or we've read in all of the elements
		while ((logicalPosition < endOfBlock) && (elementsRead < actualElements))
		{
			long errorCode = getNextWord(equalSign,elementString,9);
			if (errorCode == GET_NEXT_LINE)
			{
				readLine((BYTE*)line,254);
				equalSign = line;
				continue;
			}

			if (errorCode != NO_ERR)
			{
				return(errorCode);
			}
			
			result[elementsRead] = textToLong(elementString);
			elementsRead++;
		}
		
		if (logicalPosition >= endOfBlock && elementsRead < actualElements)
			return(NOT_ENOUGH_ELEMENTS_FOR_ARRAY);
	}
	else
	{
		return(SYNTAX_ERROR);
	}
		
	return(NO_ERR);
}

//---------------------------------------------------------------------------
long FitIniFile::readIdULongArray (const char *varName, unsigned long *result, unsigned long numElements)
{
	char line[255];
	char frontSearch[10];
	char searchString[255];
	
	//--------------------------------
	// Always read from top of Block.
	seek(currentBlockOffset);
	unsigned long endOfBlock = currentBlockOffset+currentBlockSize;
	
	//------------------------------------------------------------------
	// Create two search strings so that we can match any number in []
	sprintf(frontSearch,"ul[");
	sprintf(searchString,"] %s",varName);
	
	//--------------------------------
	// Search line by line for varName
	char *fSearch = NULL;
	char *bSearch = NULL;
	
	do
	{
		readLine((BYTE*)line,254);
		
		fSearch = strstr(line,frontSearch);
		bSearch = strstr(line,searchString);
	}
	while(((fSearch == NULL) || (bSearch == NULL)) && (logicalPosition < endOfBlock));
	
	if (logicalPosition >= endOfBlock)
	{
		return(VARIABLE_NOT_FOUND);
	}

	//--------------------------------------
	// Get number of elements in array.
	char elementString[10];
	unsigned long actualElements;
	
	fSearch += 3;												//Move pointer to first number in brackets.
	long numDigits = bSearch - fSearch;

	if (numDigits > 9)
		return(TOO_MANY_ELEMENTS);

	strncpy(elementString,fSearch,numDigits);
	elementString[numDigits] = '\0';
	
	actualElements = textToULong(elementString);	

	if (actualElements > numElements)
		return(USER_ARRAY_TOO_SMALL);
		
	//------------------------------
	// Parse out the elements here.
	char *equalSign = strstr(line, "=");
	unsigned long elementsRead = 0;
	if (equalSign)
	{
		equalSign++; //Move to char past equal sign.

		//--------------------------------------------------------------------------------
		// Now, loop until we reach the end of block or we've read in all of the elements
		while ((logicalPosition < endOfBlock) && (elementsRead < actualElements))
		{
			long errorCode = getNextWord(equalSign,elementString,9);
			if (errorCode == GET_NEXT_LINE)
			{
				readLine((BYTE*)line,254);
				equalSign = line;
				continue;
			}

			if (errorCode != NO_ERR)
			{
				return(errorCode);
			}
			
			result[elementsRead] = textToULong(elementString);
			elementsRead++;
		}
		
		if (logicalPosition >= endOfBlock && elementsRead < actualElements)
			return(NOT_ENOUGH_ELEMENTS_FOR_ARRAY);
	}
	else
	{
		return(SYNTAX_ERROR);
	}
		
	return(NO_ERR);
}
		
//---------------------------------------------------------------------------
long FitIniFile::readIdShortArray (const char *varName, short *result, unsigned long numElements)
{
	char line[255];
	char frontSearch[10];
	char searchString[255];
	
	//--------------------------------
	// Always read from top of Block.
	seek(currentBlockOffset);
	unsigned long endOfBlock = currentBlockOffset+currentBlockSize;
	
	//------------------------------------------------------------------
	// Create two search strings so that we can match any number in []
	sprintf(frontSearch,"s[");
	sprintf(searchString,"] %s",varName);
	
	//--------------------------------
	// Search line by line for varName
	char *fSearch = NULL;
	char *bSearch = NULL;
	
	do
	{
		readLine((BYTE*)line,254);
		
		fSearch = strstr(line,frontSearch);
		bSearch = strstr(line,searchString);
	}
	while(((fSearch == NULL) || (bSearch == NULL)) && (logicalPosition < endOfBlock));
	
	if (logicalPosition >= endOfBlock)
	{
		return(VARIABLE_NOT_FOUND);
	}

	//--------------------------------------
	// Get number of elements in array.
	char elementString[10];
	unsigned long actualElements;
	
	fSearch += 2;												//Move pointer to first number in brackets.
	long numDigits = bSearch - fSearch;

	if (numDigits > 9)
		return(TOO_MANY_ELEMENTS);

	strncpy(elementString,fSearch,numDigits);
	elementString[numDigits] = '\0';
	
	actualElements = textToULong(elementString);	

	if (actualElements > numElements)
		return(USER_ARRAY_TOO_SMALL);
		
	//------------------------------
	// Parse out the elements here.
	char *equalSign = strstr(line, "=");
	unsigned long elementsRead = 0;
	if (equalSign)
	{
		equalSign++; //Move to char past equal sign.

		//--------------------------------------------------------------------------------
		// Now, loop until we reach the end of block or we've read in all of the elements
		while ((logicalPosition < endOfBlock) && (elementsRead < actualElements))
		{
			long errorCode = getNextWord(equalSign,elementString,9);
			if (errorCode == GET_NEXT_LINE)
			{
				readLine((BYTE*)line,254);
				equalSign = line;
				continue;
			}

			if (errorCode != NO_ERR)
			{
				return(errorCode);
			}
			
			result[elementsRead] = textToShort(elementString);
			elementsRead++;
		}
		
		if (logicalPosition >= endOfBlock && elementsRead < actualElements)
			return(NOT_ENOUGH_ELEMENTS_FOR_ARRAY);
	}
	else
	{
		return(SYNTAX_ERROR);
	}
		
	return(NO_ERR);
}

//---------------------------------------------------------------------------
long FitIniFile::readIdUShortArray (const char *varName, unsigned short *result, unsigned long numElements)
{
	char line[255];
	char frontSearch[10];
	char searchString[255];
	
	//--------------------------------
	// Always read from top of Block.
	seek(currentBlockOffset);
	unsigned long endOfBlock = currentBlockOffset+currentBlockSize;
	
	//------------------------------------------------------------------
	// Create two search strings so that we can match any number in []
	sprintf(frontSearch,"us[");
	sprintf(searchString,"] %s",varName);
	
	//--------------------------------
	// Search line by line for varName
	char *fSearch = NULL;
	char *bSearch = NULL;
	
	do
	{
		readLine((BYTE*)line,254);
		
		fSearch = strstr(line,frontSearch);
		bSearch = strstr(line,searchString);
	}
	while(((fSearch == NULL) || (bSearch == NULL)) && (logicalPosition < endOfBlock));
	
	if (logicalPosition >= endOfBlock)
	{
		return(VARIABLE_NOT_FOUND);
	}

	//--------------------------------------
	// Get number of elements in array.
	char elementString[10];
	unsigned long actualElements;
	
	fSearch += 3;												//Move pointer to first number in brackets.
	long numDigits = bSearch - fSearch;

	if (numDigits > 9)
		return(TOO_MANY_ELEMENTS);

	strncpy(elementString,fSearch,numDigits);
	elementString[numDigits] = '\0';
	
	actualElements = textToULong(elementString);	

	if (actualElements > numElements)
		return(USER_ARRAY_TOO_SMALL);
		
	//------------------------------
	// Parse out the elements here.
	char *equalSign = strstr(line, "=");
	unsigned long elementsRead = 0;
	if (equalSign)
	{
		equalSign++; //Move to char past equal sign.

		//--------------------------------------------------------------------------------
		// Now, loop until we reach the end of block or we've read in all of the elements
		while ((logicalPosition < endOfBlock) && (elementsRead < actualElements))
		{
			long errorCode = getNextWord(equalSign,elementString,9);
			if (errorCode == GET_NEXT_LINE)
			{
				readLine((BYTE*)line,254);
				equalSign = line;
				continue;
			}

			if (errorCode != NO_ERR)
			{
				return(errorCode);
			}
			
			result[elementsRead] = textToUShort(elementString);
			elementsRead++;
		}
		
		if (logicalPosition >= endOfBlock && elementsRead < actualElements)
			return(NOT_ENOUGH_ELEMENTS_FOR_ARRAY);
	}
	else
	{
		return(SYNTAX_ERROR);
	}
		
	return(NO_ERR);
}
		
//---------------------------------------------------------------------------
long FitIniFile::readIdCharArray (const char *varName, char *result, unsigned long numElements)
{
	char line[255];
	char frontSearch[10];
	char searchString[255];
	
	//--------------------------------
	// Always read from top of Block.
	seek(currentBlockOffset);
	unsigned long endOfBlock = currentBlockOffset+currentBlockSize;
	
	//------------------------------------------------------------------
	// Create two search strings so that we can match any number in []
	sprintf(frontSearch,"c[");
	sprintf(searchString,"] %s",varName);
	
	//--------------------------------
	// Search line by line for varName
	char *fSearch = NULL;
	char *bSearch = NULL;
	
	do
	{
		readLine((BYTE*)line,254);
		
		fSearch = strstr(line,frontSearch);
		bSearch = strstr(line,searchString);
	}
	while(((fSearch == NULL) || (bSearch == NULL)) && (logicalPosition < endOfBlock));
	
	if (logicalPosition >= endOfBlock)
	{
		return(VARIABLE_NOT_FOUND);
	}

	//--------------------------------------
	// Get number of elements in array.
	char elementString[10];
	unsigned long actualElements;
	
	fSearch += 2;												//Move pointer to first number in brackets.
	long numDigits = bSearch - fSearch;

	if (numDigits > 9)
		return(TOO_MANY_ELEMENTS);

	strncpy(elementString,fSearch,numDigits);
	elementString[numDigits] = '\0';
	
	actualElements = textToULong(elementString);	

	if (actualElements > numElements)
		return(USER_ARRAY_TOO_SMALL);
		
	//------------------------------
	// Parse out the elements here.
	char *equalSign = strstr(line, "=");
	unsigned long elementsRead = 0;
	if (equalSign)
	{
		equalSign++; //Move to char past equal sign.

		//--------------------------------------------------------------------------------
		// Now, loop until we reach the end of block or we've read in all of the elements
		while ((logicalPosition < endOfBlock) && (elementsRead < actualElements))
		{
			long errorCode = getNextWord(equalSign,elementString,9);
			if (errorCode == GET_NEXT_LINE)
			{
				readLine((BYTE*)line,254);
				equalSign = line;
				continue;
			}

			if (errorCode != NO_ERR)
			{
				return(errorCode);
			}
			
			result[elementsRead] = textToChar(elementString);
			elementsRead++;
		}
		
		if (logicalPosition >= endOfBlock && elementsRead < actualElements)
			return(NOT_ENOUGH_ELEMENTS_FOR_ARRAY);
	}
	else
	{
		return(SYNTAX_ERROR);
	}
		
	return(NO_ERR);
}

//---------------------------------------------------------------------------
long FitIniFile::readIdUCharArray (const char *varName, unsigned char *result, unsigned long numElements)
{
	char line[255];
	char frontSearch[10];
	char searchString[255];
	
	//--------------------------------
	// Always read from top of Block.
	seek(currentBlockOffset);
	unsigned long endOfBlock = currentBlockOffset+currentBlockSize;
	
	//------------------------------------------------------------------
	// Create two search strings so that we can match any number in []
	sprintf(frontSearch,"uc[");
	sprintf(searchString,"] %s",varName);
	
	//--------------------------------
	// Search line by line for varName
	char *fSearch = NULL;
	char *bSearch = NULL;
	
	do
	{
		readLine((BYTE*)line,254);
		
		fSearch = strstr(line,frontSearch);
		bSearch = strstr(line,searchString);
	}
	while(((fSearch == NULL) || (bSearch == NULL)) && (logicalPosition < endOfBlock));
	
	if (logicalPosition >= endOfBlock)
	{
		return(VARIABLE_NOT_FOUND);
	}

	//--------------------------------------
	// Get number of elements in array.
	char elementString[10];
	unsigned long actualElements;
	
	fSearch += 3;												//Move pointer to first number in brackets.
	long numDigits = bSearch - fSearch;

	if (numDigits > 9)
		return(TOO_MANY_ELEMENTS);

	strncpy(elementString,fSearch,numDigits);
	elementString[numDigits] = '\0';
	
	actualElements = textToULong(elementString);	

	if (actualElements > numElements)
		return(USER_ARRAY_TOO_SMALL);
		
	//------------------------------
	// Parse out the elements here.
	char *equalSign = strstr(line, "=");
	unsigned long elementsRead = 0;
	if (equalSign)
	{
		equalSign++; //Move to char past equal sign.

		//--------------------------------------------------------------------------------
		// Now, loop until we reach the end of block or we've read in all of the elements
		while ((logicalPosition < endOfBlock) && (elementsRead < actualElements))
		{
			long errorCode = getNextWord(equalSign,elementString,9);
			if (errorCode == GET_NEXT_LINE)
			{
				readLine((BYTE*)line,254);
				equalSign = line;
				continue;
			}

			if (errorCode != NO_ERR)
			{
				return(errorCode);
			}
			
			result[elementsRead] = textToUChar(elementString);
			elementsRead++;
		}
		
		if (logicalPosition >= endOfBlock && elementsRead < actualElements)
			return(NOT_ENOUGH_ELEMENTS_FOR_ARRAY);
	}
	else
	{
		return(SYNTAX_ERROR);
	}
		
	return(NO_ERR);
}
		
//---------------------------------------------------------------------------
unsigned long FitIniFile::getIdFloatArrayElements (const char *varName)
{
	char line[255];
	char frontSearch[10];
	char searchString[255];
	
	//--------------------------------
	// Always read from top of Block.
	seek(currentBlockOffset);
	unsigned long endOfBlock = currentBlockOffset+currentBlockSize;
	
	//------------------------------------------------------------------
	// Create two search strings so that we can match any number in []
	sprintf(frontSearch,"f[");
	sprintf(searchString,"] %s",varName);
	
	//--------------------------------
	// Search line by line for varName
	char *fSearch = NULL;
	char *bSearch = NULL;
	
	do
	{
		readLine((BYTE*)line,254);
		
		fSearch = strstr(line,frontSearch);
		bSearch = strstr(line,searchString);
	}
	while(((fSearch == NULL) || (bSearch == NULL)) && (logicalPosition < endOfBlock));
	
	if (logicalPosition >= endOfBlock)
	{
		return(VARIABLE_NOT_FOUND);
	}

	//--------------------------------------
	// Get number of elements in array.
	char elementString[10];
	unsigned long actualElements;
	
	fSearch += 2;												//Move pointer to first number in brackets.
	long numDigits = bSearch - fSearch;

	if (numDigits > 9)
		return(TOO_MANY_ELEMENTS);

	strncpy(elementString,fSearch,numDigits);
	elementString[numDigits] = '\0';
	
	actualElements = textToULong(elementString);	
	
	return(actualElements);
}	
	
//---------------------------------------------------------------------------
unsigned long FitIniFile::getIdLongArrayElements (const char *varName)
{
	char line[255];
	char frontSearch[10];
	char searchString[255];
	
	//--------------------------------
	// Always read from top of Block.
	seek(currentBlockOffset);
	unsigned long endOfBlock = currentBlockOffset+currentBlockSize;
	
	//------------------------------------------------------------------
	// Create two search strings so that we can match any number in []
	sprintf(frontSearch,"l[");
	sprintf(searchString,"] %s",varName);
	
	//--------------------------------
	// Search line by line for varName
	char *fSearch = NULL;
	char *bSearch = NULL;
	
	do
	{
		readLine((BYTE*)line,254);
		
		fSearch = strstr(line,frontSearch);
		bSearch = strstr(line,searchString);
	}
	while(((fSearch == NULL) || (bSearch == NULL)) && (logicalPosition < endOfBlock));
	
	if (logicalPosition >= endOfBlock)
	{
		return(VARIABLE_NOT_FOUND);
	}

	//--------------------------------------
	// Get number of elements in array.
	char elementString[10];
	unsigned long actualElements;
	
	fSearch += 2;												//Move pointer to first number in brackets.
	long numDigits = bSearch - fSearch;

	if (numDigits > 9)
		return(TOO_MANY_ELEMENTS);

	strncpy(elementString,fSearch,numDigits);
	elementString[numDigits] = '\0';
	
	actualElements = textToULong(elementString);	
	
	return(actualElements);
}

//---------------------------------------------------------------------------
unsigned long FitIniFile::getIdULongArrayElements (const char *varName)
{
	char line[255];
	char frontSearch[10];
	char searchString[255];
	
	//--------------------------------
	// Always read from top of Block.
	seek(currentBlockOffset);
	unsigned long endOfBlock = currentBlockOffset+currentBlockSize;
	
	//------------------------------------------------------------------
	// Create two search strings so that we can match any number in []
	sprintf(frontSearch,"ul[");
	sprintf(searchString,"] %s",varName);
	
	//--------------------------------
	// Search line by line for varName
	char *fSearch = NULL;
	char *bSearch = NULL;
	
	do
	{
		readLine((BYTE*)line,254);
		
		fSearch = strstr(line,frontSearch);
		bSearch = strstr(line,searchString);
	}
	while(((fSearch == NULL) || (bSearch == NULL)) && (logicalPosition < endOfBlock));
	
	if (logicalPosition >= endOfBlock)
	{
		return(VARIABLE_NOT_FOUND);
	}

	//--------------------------------------
	// Get number of elements in array.
	char elementString[10];
	unsigned long actualElements;
	
	fSearch += 3;												//Move pointer to first number in brackets.
	long numDigits = bSearch - fSearch;

	if (numDigits > 9)
		return(TOO_MANY_ELEMENTS);

	strncpy(elementString,fSearch,numDigits);
	elementString[numDigits] = '\0';
	
	actualElements = textToULong(elementString);	
	
	return(actualElements);
}
											 
//---------------------------------------------------------------------------
unsigned long FitIniFile::getIdShortArrayElements (const char *varName)
{
	char line[255];
	char frontSearch[10];
	char searchString[255];
	
	//--------------------------------
	// Always read from top of Block.
	seek(currentBlockOffset);
	unsigned long endOfBlock = currentBlockOffset+currentBlockSize;
	
	//------------------------------------------------------------------
	// Create two search strings so that we can match any number in []
	sprintf(frontSearch,"s[");
	sprintf(searchString,"] %s",varName);
	
	//--------------------------------
	// Search line by line for varName
	char *fSearch = NULL;
	char *bSearch = NULL;
	
	do
	{
		readLine((BYTE*)line,254);
		
		fSearch = strstr(line,frontSearch);
		bSearch = strstr(line,searchString);
	}
	while(((fSearch == NULL) || (bSearch == NULL)) && (logicalPosition < endOfBlock));
	
	if (logicalPosition >= endOfBlock)
	{
		return(VARIABLE_NOT_FOUND);
	}

	//--------------------------------------
	// Get number of elements in array.
	char elementString[10];
	unsigned long actualElements;
	
	fSearch += 2;												//Move pointer to first number in brackets.
	long numDigits = bSearch - fSearch;

	if (numDigits > 9)
		return(TOO_MANY_ELEMENTS);

	strncpy(elementString,fSearch,numDigits);
	elementString[numDigits] = '\0';
	
	actualElements = textToULong(elementString);	
	
	return(actualElements);
}

//---------------------------------------------------------------------------
unsigned long FitIniFile::getIdUShortArrayElements (const char *varName)
{
	char line[255];
	char frontSearch[10];
	char searchString[255];
	
	//--------------------------------
	// Always read from top of Block.
	seek(currentBlockOffset);
	unsigned long endOfBlock = currentBlockOffset+currentBlockSize;
	
	//------------------------------------------------------------------
	// Create two search strings so that we can match any number in []
	sprintf(frontSearch,"us[");
	sprintf(searchString,"] %s",varName);
	
	//--------------------------------
	// Search line by line for varName
	char *fSearch = NULL;
	char *bSearch = NULL;
	
	do
	{
		readLine((BYTE*)line,254);
		
		fSearch = strstr(line,frontSearch);
		bSearch = strstr(line,searchString);
	}
	while(((fSearch == NULL) || (bSearch == NULL)) && (logicalPosition < endOfBlock));
	
	if (logicalPosition >= endOfBlock)
	{
		return(VARIABLE_NOT_FOUND);
	}

	//--------------------------------------
	// Get number of elements in array.
	char elementString[10];
	unsigned long actualElements;
	
	fSearch += 3;												//Move pointer to first number in brackets.
	long numDigits = bSearch - fSearch;

	if (numDigits > 9)
		return(TOO_MANY_ELEMENTS);

	strncpy(elementString,fSearch,numDigits);
	elementString[numDigits] = '\0';
	
	actualElements = textToULong(elementString);	
	
	return(actualElements);
}

//---------------------------------------------------------------------------
unsigned long FitIniFile::getIdCharArrayElements (const char *varName)
{
	char line[255];
	char frontSearch[10];
	char searchString[255];
	
	//--------------------------------
	// Always read from top of Block.
	seek(currentBlockOffset);
	unsigned long endOfBlock = currentBlockOffset+currentBlockSize;
	
	//------------------------------------------------------------------
	// Create two search strings so that we can match any number in []
	sprintf(frontSearch,"c[");
	sprintf(searchString,"] %s",varName);
	
	//--------------------------------
	// Search line by line for varName
	char *fSearch = NULL;
	char *bSearch = NULL;
	
	do
	{
		readLine((BYTE*)line,254);
		
		fSearch = strstr(line,frontSearch);
		bSearch = strstr(line,searchString);
	}
	while(((fSearch == NULL) || (bSearch == NULL)) && (logicalPosition < endOfBlock));
	
	if (logicalPosition >= endOfBlock)
	{
		return(VARIABLE_NOT_FOUND);
	}

	//--------------------------------------
	// Get number of elements in array.
	char elementString[10];
	unsigned long actualElements;
	
	fSearch += 2;												//Move pointer to first number in brackets.
	long numDigits = bSearch - fSearch;

	if (numDigits > 9)
		return(TOO_MANY_ELEMENTS);

	strncpy(elementString,fSearch,numDigits);
	elementString[numDigits] = '\0';
	
	actualElements = textToULong(elementString);	
	
	return(actualElements);
}

//---------------------------------------------------------------------------
unsigned long FitIniFile::getIdUCharArrayElements (const char *varName)
{
	char line[255];
	char frontSearch[10];
	char searchString[255];
	
	//--------------------------------
	// Always read from top of Block.
	seek(currentBlockOffset);
	unsigned long endOfBlock = currentBlockOffset+currentBlockSize;
	
	//------------------------------------------------------------------
	// Create two search strings so that we can match any number in []
	sprintf(frontSearch,"uc[");
	sprintf(searchString,"] %s",varName);
	
	//--------------------------------
	// Search line by line for varName
	char *fSearch = NULL;
	char *bSearch = NULL;
	
	do
	{
		readLine((BYTE*)line,254);
		
		fSearch = strstr(line,frontSearch);
		bSearch = strstr(line,searchString);
	}
	while(((fSearch == NULL) || (bSearch == NULL)) && (logicalPosition < endOfBlock));
	
	if (logicalPosition >= endOfBlock)
	{
		return(VARIABLE_NOT_FOUND);
	}

	//--------------------------------------
	// Get number of elements in array.
	char elementString[10];
	unsigned long actualElements;
	
	fSearch += 3;												//Move pointer to first number in brackets.
	long numDigits = bSearch - fSearch;

	if (numDigits > 9)
		return(TOO_MANY_ELEMENTS);

	strncpy(elementString,fSearch,numDigits);
	elementString[numDigits] = '\0';
	
	actualElements = textToULong(elementString);	
	
	return(actualElements);
}
	
//---------------------------------------------------------------------------
long FitIniFile::writeBlock (const char *blockId)
{
	char thisLine[255];
	sprintf(thisLine,"\r\n[%s]\r\n",blockId);
	
	long result = write((BYTE*)thisLine,strlen(thisLine));
	return(result);
}

//---------------------------------------------------------------------------
long FitIniFile::writeIdFloat (const char *varName, float value)
{
	char thisLine[255];
	sprintf(thisLine,"f %s = %f\r\n",varName,value);
	
	long result = write((BYTE*)thisLine,strlen(thisLine));
	return(result);
}

//---------------------------------------------------------------------------
long FitIniFile::writeIdBoolean (const char *varName, bool value)
{
	char thisLine[255];
	if (value)
		sprintf(thisLine,"b %s = %s\r\n",varName,"TRUE");
	else
		sprintf(thisLine,"b %s = %s\r\n",varName,"FALSE");
	
	long result = write((BYTE*)thisLine,strlen(thisLine));
	return(result);
}

//---------------------------------------------------------------------------
long FitIniFile::writeIdLong (const char *varName, long value)
{
	char thisLine[255];
	sprintf(thisLine,"l %s = %d\r\n",varName,value);
	
	long result = write((BYTE*)thisLine,strlen(thisLine));
	return(result);
}

//---------------------------------------------------------------------------
long FitIniFile::writeIdShort (const char *varName, short value)
{
	char thisLine[255];
	sprintf(thisLine,"s %s = %d\r\n",varName,value);
	
	long result = write((BYTE*)thisLine,strlen(thisLine));
	return(result);
}

//---------------------------------------------------------------------------
long FitIniFile::writeIdChar (const char *varName, char value)
{
	char thisLine[255];
	sprintf(thisLine,"c %s = %d\r\n",varName,value);
	
	long result = write((BYTE*)thisLine,strlen(thisLine));
	return(result);
}

//---------------------------------------------------------------------------
long FitIniFile::writeIdULong (const char *varName, unsigned long value)
{
	char thisLine[255];
	sprintf(thisLine,"ul %s = %d\r\n",varName,value);
	
	long result = write((BYTE*)thisLine,strlen(thisLine));
	return(result);
}

//---------------------------------------------------------------------------
long FitIniFile::writeIdUShort (const char *varName, unsigned short value)
{
	char thisLine[255];
	sprintf(thisLine,"us %s = %d\r\n",varName,value);
	
	long result = write((BYTE*)thisLine,strlen(thisLine));
	return(result);
}

//---------------------------------------------------------------------------
long FitIniFile::writeIdUChar (const char *varName, unsigned char value)
{
	char thisLine[255];
	sprintf(thisLine,"uc %s = %d\r\n",varName,value);
	
	long result = write((BYTE*)thisLine,strlen(thisLine));
	return(result);
}

//---------------------------------------------------------------------------
long FitIniFile::writeIdString (const char *varName, const char *result)
{
	char thisLine[4096];
	char tmpString[4000];
	memset(tmpString,0,4000);
	strncpy(tmpString,result,3999);

	if (strlen(result) >= 4000)
		ASSERT(("String passed to WriteIdString is longer then 4000 characters"));

	sprintf(thisLine,"st %s = \"%s\"\r\n",varName,result);
	
	long bytesWritten = write((BYTE*)thisLine,strlen(thisLine));
	return(bytesWritten);
}

//---------------------------------------------------------------------------
long FitIniFile::writeIdUShortArray (const char *varName, unsigned short *array, unsigned long numElements)
{
	char thisLine[255];
	sprintf(thisLine,"us[%d] %s = %d,",numElements,varName,array[0]);
	
	long bytesWritten = write((BYTE*)thisLine,strlen(thisLine));

	for (long i=1;i<(long)numElements;i++)
	{
		sprintf(thisLine,"%d,",array[i]);
		bytesWritten += write((BYTE*)thisLine,strlen(thisLine));
	}
	sprintf(thisLine,"\r\n");
	bytesWritten += write((BYTE*)thisLine,strlen(thisLine));

	return (bytesWritten);
}

//---------------------------------------------------------------------------
long FitIniFile::writeIdLongArray (const char *varName, long *array, unsigned long numElements)
{
	char thisLine[255];
	sprintf(thisLine,"l[%d] %s = %d,",numElements,varName,array[0]);
	
	long bytesWritten = write((BYTE*)thisLine,strlen(thisLine));

	for (long i=1;i<(long)numElements;i++)
	{
		sprintf(thisLine,"%d,",array[i]);
		bytesWritten += write((BYTE*)thisLine,strlen(thisLine));
	}
	sprintf(thisLine,"\r\n");
	bytesWritten += write((BYTE*)thisLine,strlen(thisLine));

	return (bytesWritten);
}

//---------------------------------------------------------------------------
long FitIniFile::writeIdFloatArray (const char *varName, float *array, unsigned long numElements)
{
	char thisLine[255];
	sprintf(thisLine,"f[%d] %s = %.2f,",numElements,varName,array[0]);
	
	long bytesWritten = write((BYTE*)thisLine,strlen(thisLine));

	for (long i=1;i<(long)numElements;i++)
	{
		sprintf(thisLine," %.2f,",array[i]);
		bytesWritten += write((BYTE*)thisLine,strlen(thisLine));
	}
	sprintf(thisLine,"\r\n");
	bytesWritten += write((BYTE*)thisLine,strlen(thisLine));

	return (bytesWritten);
}

//---------------------------------------------------------------------------
long FitIniFile::writeIdUCharArray (const char *varName, unsigned char *array, unsigned long numElements)
{
	char thisLine[255];
	sprintf(thisLine,"uc[%d] %s = %d,",numElements,varName,array[0]);
	
	long bytesWritten = write((BYTE*)thisLine,strlen(thisLine));

	for (long i=1;i<(long)numElements;i++)
	{
		sprintf(thisLine," %d,",array[i]);
		bytesWritten += write((BYTE*)thisLine,strlen(thisLine));
	}
	sprintf(thisLine,"\r\n");
	bytesWritten += write((BYTE*)thisLine,strlen(thisLine));

	return (bytesWritten);
}

//---------------------------------------------------------------------------
//
// Edit log
//
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\xodash\imageConv\basetexture.h ===
//-----------------------------------------------------------------------------
// File: BaseTexture.h
//
// Desc: Header file containing class, struct, and constant definitions
//       for the basic texture-related functionality of the bundler tool
//
// Hist: 04.13.01 - New for May XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef BASETEXTURE_H
#define BASETEXTURE_H

#include <windows.h>
#include <d3dx8.h>
#include <xgraphics.h>


class CBundler;


// Xbox-specific defines, taken from d3d8types-xbox.h and d3d8-xbox.h
#define X_D3DFMT_A8R8G8B8              0x00000006
#define X_D3DFMT_X8R8G8B8              0x00000007
#define X_D3DFMT_R5G6B5                0x00000005
#define X_D3DFMT_R6G5B5                0x00000027
#define X_D3DFMT_X1R5G5B5              0x00000003
#define X_D3DFMT_A1R5G5B5              0x00000002
#define X_D3DFMT_A4R4G4B4              0x00000004
#define X_D3DFMT_A8                    0x00000019
#define X_D3DFMT_A8B8G8R8              0x0000003A   
#define X_D3DFMT_B8G8R8A8              0x0000003B   
#define X_D3DFMT_R4G4B4A4              0x00000039   
#define X_D3DFMT_R5G5B5A1              0x00000038   
#define X_D3DFMT_R8G8B8A8              0x0000003C   
#define X_D3DFMT_R8B8                  0x00000029   
#define X_D3DFMT_G8B8                  0x00000028   
#define X_D3DFMT_P8                    0x0000000B
#define X_D3DFMT_L8                    0x00000000
#define X_D3DFMT_A8L8                  0x0000001A
#define X_D3DFMT_AL8                   0x00000001   
#define X_D3DFMT_L16                   0x00000032   
#define X_D3DFMT_V8U8                  0x00000028
#define X_D3DFMT_L6V5U5                0x00000027
#define X_D3DFMT_X8L8V8U8              0x00000007
#define X_D3DFMT_Q8W8V8U8              0x0000003A
#define X_D3DFMT_V16U16                0x00000033
#define X_D3DFMT_DXT1                  0x0000000C
#define X_D3DFMT_DXT2                  0x0000000E
#define X_D3DFMT_DXT3                0x0000000E // Not valid on Xbox
#define X_D3DFMT_DXT4                  0x0000000F
#define X_D3DFMT_DXT5                0x0000000F // Not valid on Xbox
#define X_D3DFMT_LIN_A1R5G5B5          0x00000010   
#define X_D3DFMT_LIN_A4R4G4B4          0x0000001D   
#define X_D3DFMT_LIN_A8                0x0000001F   
#define X_D3DFMT_LIN_A8B8G8R8          0x0000003F   
#define X_D3DFMT_LIN_A8R8G8B8          0x00000012   
#define X_D3DFMT_LIN_B8G8R8A8          0x00000040   
#define X_D3DFMT_LIN_G8B8              0x00000017   
#define X_D3DFMT_LIN_R4G4B4A4          0x0000003E   
#define X_D3DFMT_LIN_R5G5B5A1          0x0000003D   
#define X_D3DFMT_LIN_R5G6B5            0x00000011   
#define X_D3DFMT_LIN_R6G5B5            0x00000037   
#define X_D3DFMT_LIN_R8B8              0x00000016   
#define X_D3DFMT_LIN_R8G8B8A8          0x00000041   
#define X_D3DFMT_LIN_X1R5G5B5          0x0000001C   
#define X_D3DFMT_LIN_X8R8G8B8          0x0000001E   
#define X_D3DFMT_LIN_A8L8              0x00000020   
#define X_D3DFMT_LIN_AL8               0x0000001B   
#define X_D3DFMT_LIN_L16               0x00000035   
#define X_D3DFMT_LIN_L8                0x00000013   
#define X_D3DFMT_LIN_V16U16            0x00000036
#define X_D3DFMT_LIN_V8U8              0x00000017
#define X_D3DFMT_LIN_L6V5U5            0x00000037
#define X_D3DFMT_LIN_X8L8V8U8          0x0000001E
#define X_D3DFMT_LIN_Q8W8V8U8          0x00000012

#define D3DTEXTURE_ALIGNMENT            128

#define D3DFORMAT_DMACHANNEL_MASK       0x00000003
#define D3DFORMAT_DMACHANNEL_A          0x00000001
#define D3DFORMAT_DMACHANNEL_B          0x00000002

#define D3DFORMAT_CUBEMAP               0x00000004
#define D3DFORMAT_BORDERSOURCE_COLOR    0x00000008
#define D3DFORMAT_DIMENSION_MASK        0x000000F0
#define D3DFORMAT_DIMENSION_SHIFT       4
#define D3DFORMAT_FORMAT_MASK           0x0000FF00
#define D3DFORMAT_FORMAT_SHIFT          8
#define D3DFORMAT_MIPMAP_MASK           0x000F0000
#define D3DFORMAT_MIPMAP_SHIFT          16
#define D3DFORMAT_USIZE_MASK            0x00F00000
#define D3DFORMAT_USIZE_SHIFT           20
#define D3DFORMAT_VSIZE_MASK            0x0F000000
#define D3DFORMAT_VSIZE_SHIFT           24
#define D3DFORMAT_PSIZE_MASK            0xF0000000
#define D3DFORMAT_PSIZE_SHIFT           28

#define D3DCOMMON_TYPE_SHIFT         16
#define D3DCOMMON_TYPE_VERTEXBUFFER  0x00000000
#define D3DCOMMON_TYPE_INDEXBUFFER   0x00010000
#define D3DCOMMON_TYPE_PALETTE       0x00030000
#define D3DCOMMON_TYPE_TEXTURE       0x00040000
#define D3DCOMMON_TYPE_SURFACE       0x00050000
#define D3DCOMMON_VIDEOMEMORY        0x00800000

#define D3DTEXTURE_PITCH_ALIGNMENT   64


// Texture Resource Format
struct D3DTexture
{
    DWORD Common;
    DWORD Data;
    DWORD Lock;
    DWORD Format;
    DWORD Size;
};


// Enum for format definitions
typedef enum { FMT_LINEAR, FMT_SWIZZLED, FMT_COMPRESSED } FMT_TYPE;


// Format definition
struct FORMATSPEC
{
    CHAR*    strFormat;
    DWORD    dwXboxFormat;
    FMT_TYPE Type;
    DWORD    dwNumAlphaBits;
};
extern const FORMATSPEC g_TextureFormats[];




//-----------------------------------------------------------------------------
// Name: class CBaseTexture
// Desc: Handles all texture-specific processing, such as loading textures,
//       format conversion, swizzling, etc.
//-----------------------------------------------------------------------------
class CBaseTexture
{
public:
    CBaseTexture( CBundler* pBundler );
    ~CBaseTexture();

    CHAR  m_strFormat[MAX_PATH];
    int   m_nFormat;
    DWORD m_dwFilter;
    DWORD m_dwLevels;

protected:
    int     FormatFromString( CHAR* strFormat );            // Format processing
    int     FormatFromPCFormat( D3DFORMAT d3dFormat );
    HRESULT LoadSurface( CHAR* strSource, CHAR* strAlphaSource, 
                         LPDIRECT3DSURFACE8* ppSurface );
    HRESULT LoadSurfaceUsingD3DX( CHAR* strSource, CHAR* strAlphaSource, 
                                  LPDIRECT3DSURFACE8* ppSurface );
    HRESULT ResizeSurface( DWORD dwWidth, DWORD dwHeight, LPDIRECT3DSURFACE8* ppSurface );
    HRESULT SaveSurface( DWORD* pcbData, DWORD dwLevels, 
                         LPDIRECT3DSURFACE8 pSurface );
    HRESULT SaveVolumeTexture( DWORD* pcbData, DWORD dwLevels, 
                               LPDIRECT3DVOLUMETEXTURE8 pVolume );
    DWORD   WriteLinearTextureData( VOID* pBits, DWORD dwWidth, 
                                    DWORD dwHeight, DWORD dwDepth );
    DWORD   WriteSwizzledTextureData( VOID* pBits, DWORD dwWidth, 
                                      DWORD dwHeight, DWORD dwDepth );
    DWORD   WriteCompressedTextureData( VOID* pBits, DWORD dwWidth, 
                                        DWORD dwHeight, DWORD dwDepth );

    CBundler* m_pBundler;
};


#endif // BASETEXTURE_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\xodash\aseConv\Inifile.h ===
//---------------------------------------------------------------------------
//
// inifile.h - This file contains the class declaration for the FitIni Files
//
//				The FitIni file is a ini style file.
//
//	Honor Bound -- FASA Interactive Technologies
//
//	Copyright (c) 1995 FASA Interactive Technologies
//
//
//---------------------------------------------------------------------------

#ifndef INIFILE_H
#define INIFILE_H
//---------------------------------------------------------------------------
// Include files


#ifndef FILE_H
#include "file.h"
#endif

//---------------------------------------------------------------------------
// Macro Definitions
#ifndef 	NO_ERR
#define	NO_ERR						0x00000000
#endif

#define BLOCK_NOT_FOUND						0xFADA0000
#define ID_NOT_FOUND							0xFADA0001
#define DATA_NOT_CORRECT_TYPE				0xFADA0002
#define BUFFER_TOO_SMALL					0xFADA0003
#define NOT_A_FITINIFILE					0xFADA0004
#define NO_RAM_FOR_INI_BLOCKS				0xFADA0005
#define NO_MORE_BLOCKS						0xFADA0006
#define TOO_MANY_BLOCKS						0xFADA0007
#define NOT_ENOUGH_BLOCKS					0xFADA0008
#define VARIABLE_NOT_FOUND					0xFADA0009
#define SYNTAX_ERROR							0xFADA000A
#define NOT_ENOUGH_ELEMENTS_FOR_ARRAY	0xFADA000B
#define GET_NEXT_LINE						0xFADA000C
#define USER_ARRAY_TOO_SMALL				0xFADA000D
#define TOO_MANY_ELEMENTS					0xFADA000E

//---------------------------------------------------------------------------
// Enums

//---------------------------------------------------------------------------
// Structs
struct IniBlockNode
{
	char blockId[50];
	unsigned long blockOffset;
};

//---------------------------------------------------------------------------
//									FitIniFile
class FitIniFile : public File
{
	// Data Members
	//--------------
	protected:
		unsigned long 	totalBlocks;					//Total number of blocks in file
		IniBlockNode 	*fileBlocks;					//Data for blocks to speed up file
		char 				*currentBlockId;				//Id of current block
		unsigned long 	currentBlockOffset;			//Offset into file of block start
		unsigned long 	currentBlockSize;				//Length of current block

	// Member Functions
	//------------------
	protected:
		long afterOpen (void);
		void atClose (void);
		
		long findNextBlockStart (char *line = NULL, unsigned long lineLen = 0);
		long countBlocks (void);
		
		long getNextWord (char *&line, char *buffer, unsigned long bufLen);

		float textToFloat (const char *num);
		double textToDouble (const char *num);
		
		long textToLong (const char *num);
		unsigned long textToULong (const char *num);
		
		short textToShort (const char *num);
		unsigned short textToUShort (const char *num);
		
		char textToChar (const char *num);
		unsigned char textToUChar (const char *num);

		bool booleanToLong (const char *num);

		float mathToFloat (const char *num);
		
		long mathToLong (const char *num);
		unsigned long mathToULong (const char *num);
		
		short mathToShort (const char *num);
		unsigned short mathToUShort (const char *num);
		
		char mathToChar (const char *num);
		unsigned char mathToUChar (const char *num);

		long floatToText (char *result, float num, unsigned long bufLen);
		
		long longToTextDec (char *result, long num, unsigned long bufLen);
		long longToTextHex (char *result, long num, unsigned long bufLen);

		long shortToTextDec (char *result, short num, unsigned long bufLen);
		long shortToTextHex (char *result, short num, unsigned long bufLen);

		long byteToTextDec (char *result, byte num, unsigned long bufLen);	
		long byteToTextHex (char *result, byte num, unsigned long bufLen);
		
		long copyString (char* dest, char *src, unsigned long bufLen);

	public:
		FitIniFile (void);
		~FitIniFile (void);

		virtual long open (const char* fName, FileMode _mode = READ, long numChildren = 50);
		virtual long open (File* _parent, unsigned long fileSize, long numChildren = 50);
		
		virtual long create (char* fName);
		virtual long createWithCase( char* fName );


		virtual void close (void);

		virtual FileClass getFileClass (void)
		{
			return INIFILE;
		}

		long seekBlock (const char *blockId);

		long readIdFloat (const char *varName, float &value);
		long readIdDouble (const char *varName, double &value);
		
		long readIdBoolean (const char *varName, bool &value);
		long readIdLong (const char *varName, long &value);
		long readIdULong (const char *varName, unsigned long &value);
		
		long readIdShort (const char *varName, short &value);
		long readIdUShort (const char *varName, unsigned short &value);
		
		long readIdChar (const char *varName, char &value);
		long readIdUChar (const char *varName, unsigned char &value);
		
		long readIdString (const char *varName, char *result, unsigned long bufferSize);

		long getIdStringLength (const char *varName);
		
		long readIdFloatArray (const char *varName, float *result, unsigned long numElements);
		
		long readIdLongArray (const char *varName, long *result, unsigned long numElements);
		long readIdULongArray (const char *varName, unsigned long *result, unsigned long numElements);
		
		long readIdShortArray (const char *varName, short *result, unsigned long numElements);
		long readIdUShortArray (const char *varName, unsigned short *result, unsigned long numElements);
		
		long readIdCharArray (const char *varName, char *result, unsigned long numElements);
		long readIdUCharArray (const char *varName, unsigned char *result, unsigned long numElements);
		
		unsigned long getIdFloatArrayElements (const char *varName);
		
		unsigned long getIdLongArrayElements (const char *varName);
		unsigned long getIdULongArrayElements (const char *varName);
											 
		unsigned long getIdShortArrayElements (const char *varName);
		unsigned long getIdUShortArrayElements (const char *varName);
		
		unsigned long getIdCharArrayElements (const char *varName);
		unsigned long getIdUCharArrayElements (const char *varName);
		
		long writeBlock (const char *blockId);

		long writeIdFloat (const char *varName, float value);
		
		long writeIdBoolean (const char *varName, bool value);
		long writeIdLong (const char *varName, long value);
		long writeIdULong (const char *varName, unsigned long value);
		
		long writeIdShort (const char *varName, short value);
		long writeIdUShort (const char *varName, unsigned short value);
		
		long writeIdChar (const char *varName, char value);
		long writeIdUChar (const char *varName, unsigned char value);
		
		long writeIdString (const char *varName, const char *result);

		long writeIdFloatArray (const char *varName, float *array, unsigned long numElements);
		long writeIdLongArray (const char *varName, long *array, unsigned long numElements);
		long writeIdUShortArray (const char *varName, unsigned short *array, unsigned long numElements);
		long writeIdUCharArray (const char *varName, unsigned char *array, unsigned long numElements);
};

//---------------------------------------------------------------------------
#endif

//---------------------------------------------------------------------------
//
// Edit Log
//
//
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\xodash\imageConv\bundler.cpp ===
//-----------------------------------------------------------------------------
// File: Bundler.cpp
//
// Desc: Bundles up a list of resources into an Xbox Packed Resource (xpr)
//       file.
//
// Hist: 02.06.01 - New for March XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include "Bundler.h"
#include "Texture.h"
#include "Cubemap.h"
#include "VolumeTexture.h"
#include "VB.h"
#include "UserData.h"
#include <stdio.h>
#include <string.h>
#include <stdlib.h>


#define INITIAL_HEADER_ALLOC 1024
#define INITIAL_DATA_ALLOC 65536




//-----------------------------------------------------------------------------
// Name: CBundler()
// Desc: Sets initial values of member variables
//-----------------------------------------------------------------------------
CBundler::CBundler()
{
    m_strRDF[0] = m_strXPR[0] = m_strHDR[0] = m_strERR[0] = 0;
    m_strPrefix[0] =  0;
    m_hfRDF    = m_hfXPR    = m_hfHDR    = m_hfERR    = INVALID_HANDLE_VALUE;
    m_cbHeader = m_cbData   = 0;
    m_bExplicitHDR = m_bExplicitXPR = m_bExplicitERR = FALSE;
    m_bExplicitPrefix = FALSE;
    m_pbHeaderBuff = m_pbDataBuff   = NULL;
    m_nResourceCount = 0;
    m_cNext0 = m_cNext1 = m_cNext2 = m_cNext3 = ' ';
    m_bSingleTexture = FALSE;
	m_pd3ddev = NULL;
	m_pd3d = NULL;
}




//-----------------------------------------------------------------------------
// Name: ~CBundler()
// Desc: Performs any needed cleanup before shutting down the object
//-----------------------------------------------------------------------------
CBundler::~CBundler()
{
    CloseFiles();
    if( m_pbHeaderBuff )
        free( m_pbHeaderBuff );
    if( m_pbDataBuff )
        free( m_pbDataBuff );

	if( m_pd3ddev != NULL )
		m_pd3ddev->Release();
	if( m_pd3d != NULL )
		m_pd3d->Release();
}




//-----------------------------------------------------------------------------
// Name: PrintUsage()
// Desc: Prints out the usage string for help
//-----------------------------------------------------------------------------
void CBundler::PrintUsage()
{
    ErrorMsg( "USAGE: Bundler <resource description file> [-o <packed resource filename>]\n" );
    ErrorMsg( "                                           [-h <header filename>]\n");
    ErrorMsg( "                                           [-p <prefix for header file constants>]\n");
    ErrorMsg( "                                           [-e <error filename>]\n");
    ErrorMsg( "                                           [-?]\n");
}




//-----------------------------------------------------------------------------
// Name: ErrorMsg()
// Desc: Prints an error message to stdout, and writes to the error file
//-----------------------------------------------------------------------------
void CBundler::ErrorMsg( CHAR* strFmt, ... )
{
    DWORD cb;
    va_list arglist;
    char strTemp[MAX_PATH];

    if( INVALID_HANDLE_VALUE == m_hfERR )
    {   
        m_hfERR = CreateFile( m_strERR, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0, NULL );
    }

    va_start( arglist, strFmt );

    vprintf( strFmt, arglist );
    vsprintf( strTemp, strFmt, arglist );
    WriteFile( m_hfERR, strTemp, strlen( strTemp ), &cb, NULL );

    va_end( arglist );
}




//-----------------------------------------------------------------------------
// Name: InitD3D()
// Desc: Initializes D3D for texture gunk
//-----------------------------------------------------------------------------
HRESULT CBundler::InitD3D()
{
    HRESULT hr;
    D3DDISPLAYMODE dispMode;
    D3DPRESENT_PARAMETERS presentParams;

    m_pd3d = Direct3DCreate8(D3D_SDK_VERSION);
    if (m_pd3d == NULL)
    {
        ErrorMsg("Couldn't create Direct3d - is it installed?\n");
        return E_FAIL;
    }

    m_pd3d->GetAdapterDisplayMode(D3DADAPTER_DEFAULT, &dispMode);

    ZeroMemory(&presentParams, sizeof(presentParams));
    presentParams.Windowed = TRUE;
    presentParams.SwapEffect = D3DSWAPEFFECT_COPY_VSYNC;
    presentParams.BackBufferWidth = 8;
    presentParams.BackBufferHeight = 8;
    presentParams.BackBufferFormat = ( ( dispMode.Format == D3DFMT_R8G8B8 ) ? D3DFMT_R5G6B5 : dispMode.Format );

    hr = m_pd3d->CreateDevice(D3DADAPTER_DEFAULT, D3DDEVTYPE_REF, GetDesktopWindow(),
        D3DCREATE_SOFTWARE_VERTEXPROCESSING, &presentParams, &m_pd3ddev);
    if (FAILED(hr))
    {
        ErrorMsg("Couldn't create reference device.  Error: %x\n", hr);
        return E_FAIL;
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Initialize()
// Desc: Parses and validates the command line arguments
//-----------------------------------------------------------------------------
HRESULT CBundler::Initialize( int argc, char * argv[] )
{
    HRESULT hr;
    BOOL bHaveRDF = FALSE;

/*  for(n=1; n<argc; n++)
    {
        // step through each command line parameter
        if((argv[n][0] == '/') || (argv[n][0] == '-'))
        {
            if((n+1) == argc)
                return E_INVALIDARG;

            // found an option
            if(lstrcmpi("o", &(argv[n][1])) == 0)
            {
                // Output file
                lstrcpyA( m_strXPR, argv[n+1] );
                m_bExplicitXPR = TRUE;
            }
            else if(lstrcmpi("h", &(argv[n][1])) == 0)
            {
                // Header file
                lstrcpyA( m_strHDR, argv[n+1] );
                m_bExplicitHDR = TRUE;
            }
            else if(lstrcmpi("p", &(argv[n][1])) == 0)
            {
                // Prefix for header file constants
                lstrcpyA( m_strPrefix, argv[n+1] );
                m_bExplicitPrefix = TRUE;
            }
            else if(lstrcmpi("e", &(argv[n][1])) == 0)
            {
                // Error file
                lstrcpyA( m_strERR, argv[n+1] );
                m_bExplicitERR = TRUE;
            }
            else if(lstrcmpi("?", &(argv[n][1])) == 0)
                return E_INVALIDARG;    // causes usage to be displayed
            else
                return E_INVALIDARG;
            
            n++;    // skip two args
        }
        else
        {
            // Grab the RDF filename
            lstrcpyA( m_strRDF, argv[1] );
        
            // Find where the filename ends and the extension begins
            pch = m_strRDF;
            while( pch && strchr( pch, '.' ) )
            {
                pch = strchr( pch, '.' ) + 1;
            }
        
            // If we never found a '.', use the whole filename
            if( pch == m_strRDF )
                pch = m_strRDF + lstrlen( m_strRDF ) + 1;
        
            // Must have something for a base filename
            nBaseFileLen = pch - m_strRDF - 1;
            if( nBaseFileLen <= 0 )
                return E_INVALIDARG;
        
            // Check to see if we are doing a quick single-texture conversion
            if((_stricmp(pch, "bmp") == 0) ||
               (_stricmp(pch, "jpg") == 0) ||
               (_stricmp(pch, "tga") == 0) ||
               (_stricmp(pch, "dds") == 0) ||
               (_stricmp(pch, "png") == 0))
            {
                m_bSingleTexture = TRUE;
            }
            
            // Copy the base filename + appropriate extension to each string
            strncpy( m_strXPR, m_strRDF, nBaseFileLen );
            m_strXPR[nBaseFileLen] = 0;
            strcat( m_strXPR, XPREXT );
            strncpy( m_strHDR, m_strRDF, nBaseFileLen );
            m_strHDR[nBaseFileLen] = 0;
            strcat( m_strHDR, HDREXT );
            strncpy( m_strERR, m_strRDF, nBaseFileLen );
            m_strERR[nBaseFileLen] = 0;
            strcat( m_strERR, ERREXT );

            strcpy( m_strPath, m_strXPR );
            if( strrchr( m_strPath, '\\' ) )
                strrchr( m_strPath, '\\' )[1] = 0;
            else
                m_strPath[0] = 0;

            bHaveRDF = TRUE;
        }
    }

    if(!bHaveRDF)
        return E_INVALIDARG;
*/

    hr = InitD3D();
    if( FAILED( hr ) )
        return hr;

    // Allocate buffers for storing data
    m_pbHeaderBuff = (BYTE *)malloc( INITIAL_HEADER_ALLOC );
    if( !m_pbHeaderBuff )
        return E_OUTOFMEMORY;
    m_cbHeaderAlloc = INITIAL_HEADER_ALLOC;

    m_pbDataBuff = (BYTE *)malloc( INITIAL_DATA_ALLOC );
    if( !m_pbDataBuff )
        return E_OUTOFMEMORY;
    m_cbDataAlloc = INITIAL_DATA_ALLOC;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: OpenFiles()
// Desc: Opens file handles for all our output files
//-----------------------------------------------------------------------------
HRESULT CBundler::OpenFiles()
{
    m_hfXPR = CreateFile( m_strXPR, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0, NULL );
    if( INVALID_HANDLE_VALUE == m_hfXPR )
    {
        ErrorMsg( "Couldn't open XPR file <%s>", m_strXPR );
        return E_FAIL;
    }

/*    m_hfHDR = CreateFile( m_strHDR, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0, NULL );
    if( INVALID_HANDLE_VALUE == m_hfHDR )
    {
        ErrorMsg( "Coudln't open header file <%s>", m_strHDR );
        return E_FAIL;
    }
*/

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: CloseFiles()
// Desc: Closes file handles for all our input/output files
//-----------------------------------------------------------------------------
HRESULT CBundler::CloseFiles()
{
    if( INVALID_HANDLE_VALUE != m_hfRDF )
        CloseHandle( m_hfRDF );
    if( INVALID_HANDLE_VALUE != m_hfXPR )
        CloseHandle( m_hfXPR );
    if( INVALID_HANDLE_VALUE != m_hfHDR )
        CloseHandle( m_hfHDR );
    if( INVALID_HANDLE_VALUE != m_hfERR )
        CloseHandle( m_hfERR );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: FilterFromString()
// Desc: Returns a D3DXFILTER from the given string
//-----------------------------------------------------------------------------
DWORD CBundler::FilterFromString( char* strFilter )
{
    DWORD filter  = D3DX_FILTER_TRIANGLE; // The default
    DWORD address = 0;
    DWORD dither  = 0;

    if( strFilter[0] )
    {
        // Scan string
        CHAR* strToken = strtok( strFilter, "|" );
        while( strToken != NULL )
        {
            if( !lstrcmpi( strToken, "NONE" ) )      filter  = D3DX_FILTER_NONE;
            if( !lstrcmpi( strToken, "POINT" ) )     filter  = D3DX_FILTER_POINT;
            if( !lstrcmpi( strToken, "LINEAR" ) )    filter  = D3DX_FILTER_LINEAR;
            if( !lstrcmpi( strToken, "TRIANGLE" ) )  filter  = D3DX_FILTER_TRIANGLE;
            if( !lstrcmpi( strToken, "BOX" ) )       filter  = D3DX_FILTER_BOX;
            if( !lstrcmpi( strToken, "WRAP" ) )      address = 0;
            if( !lstrcmpi( strToken, "CLAMP" ) )     address = D3DX_FILTER_MIRROR;
            if( !lstrcmpi( strToken, "DITHER" ) )    dither  = D3DX_FILTER_DITHER;

            strToken = strtok( NULL, "|" );
        }
    }

    return (filter|address|dither);
}




//-----------------------------------------------------------------------------
// Name: HandleTextureToken()
// Desc: Takes over to handle a texture token. Reads all tokens up to and
//       including the closing brace
//-----------------------------------------------------------------------------
HRESULT CBundler::HandleTextureToken()
{
    HRESULT hr;
    BUNDLERTOKEN tok;
    char strBuff[MAX_PATH];
    CTexture2D tex(this);
    BOOL bDone = FALSE;
    DWORD cbHeader, cbData;

    // This is the texture name.
    hr = GetNextTokenString( m_aResources[m_nResourceCount].strIdentifier, TT_IDENTIFIER );
    if( FAILED( hr ) )
        return hr;

    // Check to see if it's a repeat identifier
    if( IsExistingIdentifier( m_aResources[m_nResourceCount].strIdentifier ) )
    {
        ErrorMsg( "Second usage of identifier <%s>", m_aResources[m_nResourceCount].strIdentifier );
        return E_FAIL;
    }

    // This should be the open brace
    hr = GetNextToken( &tok );
    if( FAILED( hr ) )
        return hr;

    if( tok.eType != TOKEN_RESOURCE_OPENBRACE )
    {
        ErrorMsg( "Texture name should be followed by an open brace\n" );
        return E_FAIL;
    }

    // Loop over all the properties
    while( !bDone )
    {
        hr = GetNextToken( &tok );
        if( FAILED( hr ) )
            return hr;

        // Any property token needs a value
        if( tok.eType & TOKEN_PROPERTY_TEXTURE )
        {
            hr = GetNextTokenString( strBuff, tok.propType );
            if( FAILED( hr ) )
                return hr;
        }

        switch( tok.eType )
        {
            case TOKEN_PROPERTY_TEXTURE_SOURCE:
                strcpy( tex.m_strSource, strBuff );
                break;
            case TOKEN_PROPERTY_TEXTURE_ALPHASOURCE:
                strcpy( tex.m_strAlphaSource, strBuff );
                break;
            case TOKEN_PROPERTY_TEXTURE_FILTER:
                tex.m_dwFilter = FilterFromString( strBuff );
                break;
            case TOKEN_PROPERTY_TEXTURE_FORMAT:
                strcpy( tex.m_strFormat, strBuff );
                break;
            case TOKEN_PROPERTY_TEXTURE_WIDTH:
                tex.m_dwWidth = atoi( strBuff );
                break;
            case TOKEN_PROPERTY_TEXTURE_HEIGHT:
                tex.m_dwHeight = atoi( strBuff );
                break;
            case TOKEN_PROPERTY_TEXTURE_LEVELS:
                tex.m_dwLevels = atoi( strBuff );
                break;
            case TOKEN_RESOURCE_CLOSEBRACE:
                bDone = TRUE;
                break;
            default:
                ErrorMsg("<%s> is not a texture property.\n", tok.strKeyword );
        }
    }

    // Save the texture to the bundle
    hr = tex.SaveToBundle( &cbHeader, &cbData );
    if( FAILED( hr ) )
        return hr;

    printf("Texture: Wrote %s out in format %s (%d bytes)\n", 
        m_aResources[m_nResourceCount].strIdentifier, tex.m_strFormat, cbData );
    printf("     %d x %d, %d levels\n\n", tex.m_dwWidth, tex.m_dwHeight, tex.m_dwLevels);

    m_aResources[m_nResourceCount++].dwOffset = m_cbHeader;
    m_cbHeader += cbHeader;
    //m_cbData += cbData;

    return S_OK;
}


//-----------------------------------------------------------------------------
// Name: HandleTexture()
// Desc: Takes over to handle a texture. Reads all parameters to 
//       generate a bundled file
//-----------------------------------------------------------------------------
HRESULT CBundler::HandleTexture( CImageItem *imageFile )
{
    HRESULT hr;
    CTexture2D tex(this);
    BOOL bDone = FALSE;
    DWORD cbHeader, cbData;

	strcpy( m_strXPR, imageFile->outputpath );			// Set the destination location
    strcpy( tex.m_strSource, imageFile->fullpath );		// Set the source location
 
	if(imageFile->depth <= 24)  // 24 bit or less image, thus no Alpha Channel
		strcpy( tex.m_strFormat, "D3DFMT_DXT1" );
    else if(imageFile->depth == 32)
		strcpy( tex.m_strFormat, "D3DFMT_DXT2" );

    tex.m_dwWidth  = imageFile->width;
    tex.m_dwHeight = imageFile->height;

	// verify the width is a power of two
	if((tex.m_dwWidth & (tex.m_dwWidth - 1)) != 0)
	{
		for (DWORD nOutputWidth = 1;  nOutputWidth < tex.m_dwWidth; nOutputWidth <<= 1);
		tex.m_dwWidth = nOutputWidth;
		
		printf("WARNING: The image %s width is not a power of two, scaling up.\n", imageFile->filename);
	}

	// verify the height is a power of two
	if((tex.m_dwHeight & (tex.m_dwHeight - 1)) != 0)
	{
		for (DWORD nOutputWidth = 1;  nOutputWidth < tex.m_dwHeight; nOutputWidth <<= 1);
		tex.m_dwHeight = nOutputWidth;

		printf("WARNING: The image %s height is not a power of two, scaling up.\n", imageFile->filename);
	}

    tex.m_dwLevels = 1;			// Default to 1 mips level

    // Save the texture to the bundle
    hr = tex.SaveToBundle( &cbHeader, &cbData );
    if( FAILED( hr ) )
        return hr;

    printf("TEXTURE: Wrote %s\n", imageFile->outputpath);
    printf("     %d x %d, %d levels, (%d bytes), %s format\n\n", tex.m_dwWidth, tex.m_dwHeight, tex.m_dwLevels, cbData, tex.m_strFormat);

    m_aResources[m_nResourceCount++].dwOffset = m_cbHeader;
    m_cbHeader += cbHeader;
    //m_cbData += cbData;

	HandleEOFToken();

    return S_OK;
}


//-----------------------------------------------------------------------------
// Name: HandleCubemapToken()
// Desc: Takes over to handle a cubemap token. Reads all tokens up to and
//       including the closing brace
//-----------------------------------------------------------------------------
HRESULT CBundler::HandleCubemapToken()
{
    HRESULT      hr;
    BUNDLERTOKEN token;
    char         strBuffer[MAX_PATH];
    CCubemap     tex(this);
    BOOL         bDone = FALSE;
    DWORD        cbHeader;
    DWORD        cbData;

    // This is the texture name.
    hr = GetNextTokenString( m_aResources[m_nResourceCount].strIdentifier, TT_IDENTIFIER );
    if( FAILED( hr ) )
        return hr;

    // Check to see if it's a repeat identifier
    if( IsExistingIdentifier( m_aResources[m_nResourceCount].strIdentifier ) )
    {
        ErrorMsg( "Second usage of identifier <%s>", m_aResources[m_nResourceCount].strIdentifier );
        return E_FAIL;
    }

    // This should be the open brace
    hr = GetNextToken( &token );
    if( FAILED( hr ) )
        return hr;

    if( token.eType != TOKEN_RESOURCE_OPENBRACE )
    {
        ErrorMsg( "Cubemap name should be followed by an open brace\n" );
        return E_FAIL;
    }

    // Loop over all the properties
    while( !bDone )
    {
        hr = GetNextToken( &token );
        if( FAILED( hr ) )
            return hr;

        // Any property token needs a value
        if( token.eType & (TOKEN_PROPERTY_CUBEMAP|TOKEN_PROPERTY_TEXTURE) )
        {
            hr = GetNextTokenString( strBuffer, token.propType );
            if( FAILED( hr ) )
                return hr;
        }

        switch( token.eType )
        {
            case TOKEN_PROPERTY_CUBEMAP_SOURCE_XP:
                strcpy( tex.m_strSourceXP, strBuffer );
                break;
            case TOKEN_PROPERTY_CUBEMAP_SOURCE_XN:
                strcpy( tex.m_strSourceXN, strBuffer );
                break;
            case TOKEN_PROPERTY_CUBEMAP_SOURCE_YP:
                strcat( tex.m_strSourceYP, strBuffer );
                break;
            case TOKEN_PROPERTY_CUBEMAP_SOURCE_YN:
                strcpy( tex.m_strSourceYN, strBuffer );
                break;
            case TOKEN_PROPERTY_CUBEMAP_SOURCE_ZP:
                strcpy( tex.m_strSourceZP, strBuffer );
                break;
            case TOKEN_PROPERTY_CUBEMAP_SOURCE_ZN:
                strcpy( tex.m_strSourceZN, strBuffer );
                break;
            case TOKEN_PROPERTY_CUBEMAP_ALPHASOURCE_XP:
                strcpy( tex.m_strAlphaSourceXP, strBuffer );
                break;
            case TOKEN_PROPERTY_CUBEMAP_ALPHASOURCE_XN:
                strcpy( tex.m_strAlphaSourceXN, strBuffer );
                break;
            case TOKEN_PROPERTY_CUBEMAP_ALPHASOURCE_YP:
                strcpy( tex.m_strAlphaSourceYP, strBuffer );
                break;
            case TOKEN_PROPERTY_CUBEMAP_ALPHASOURCE_YN:
                strcpy( tex.m_strAlphaSourceYN, strBuffer );
                break;
            case TOKEN_PROPERTY_CUBEMAP_ALPHASOURCE_ZP:
                strcpy( tex.m_strAlphaSourceZP, strBuffer );
                break;
            case TOKEN_PROPERTY_CUBEMAP_ALPHASOURCE_ZN:
                strcpy( tex.m_strAlphaSourceZN, strBuffer );
                break;
            case TOKEN_PROPERTY_TEXTURE_FILTER:
                tex.m_dwFilter = FilterFromString( strBuffer );
                break;
            case TOKEN_PROPERTY_TEXTURE_FORMAT:
                strcpy( tex.m_strFormat, strBuffer );
                break;
            case TOKEN_PROPERTY_CUBEMAP_SIZE:
                tex.m_dwSize = atoi( strBuffer );
                break;
            case TOKEN_PROPERTY_TEXTURE_LEVELS:
                tex.m_dwLevels = atoi( strBuffer );
                break;
            case TOKEN_RESOURCE_CLOSEBRACE:
                bDone = TRUE;
                break;
            default:
                ErrorMsg("<%s> is not a cubemap property.\n", token.strKeyword );
        }
    }

    // Save the texture to the bundle
    hr = tex.SaveToBundle( &cbHeader, &cbData );
    if( FAILED( hr ) )
        return hr;

    printf("Cubemap: Wrote %s out in format %s (%d bytes)\n", 
        m_aResources[m_nResourceCount].strIdentifier, tex.m_strFormat, cbData );
    printf("     6 x %d x %d, %d levels\n\n", tex.m_dwSize, tex.m_dwSize, tex.m_dwLevels);

    m_aResources[m_nResourceCount++].dwOffset = m_cbHeader;
    m_cbHeader += cbHeader;
    //m_cbData += cbData;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: HandleVolumeTextureToken()
// Desc: Takes over to handle a volume texture token. Reads all tokens up to
//       and including the closing brace
//-----------------------------------------------------------------------------
HRESULT CBundler::HandleVolumeTextureToken()
{
    HRESULT        hr;
    BUNDLERTOKEN   token;
    char           strBuffer[MAX_PATH];
    CVolumeTexture tex(this);
    BOOL           bDone = FALSE;
    DWORD          cbHeader;
    DWORD          cbData;
    DWORD          srcnum = 0;
    DWORD          alphasrcnum = 0;

    // This is the texture name.
    hr = GetNextTokenString( m_aResources[m_nResourceCount].strIdentifier, TT_IDENTIFIER );
    if( FAILED( hr ) )
        return hr;

    // Check to see if it's a repeat identifier
    if( IsExistingIdentifier( m_aResources[m_nResourceCount].strIdentifier ) )
    {
        ErrorMsg( "Second usage of identifier <%s>", m_aResources[m_nResourceCount].strIdentifier );
        return E_FAIL;
    }

    // This should be the open brace
    hr = GetNextToken( &token );
    if( FAILED( hr ) )
        return hr;

    if( token.eType != TOKEN_RESOURCE_OPENBRACE )
    {
        ErrorMsg( "Cubemap name should be followed by an open brace\n" );
        return E_FAIL;
    }

    // Loop over all the properties
    while( !bDone )
    {
        hr = GetNextToken( &token );
        if( FAILED( hr ) )
            return hr;

        // Any property token needs a value
        if( token.eType & (TOKEN_PROPERTY_CUBEMAP|TOKEN_PROPERTY_TEXTURE) )
        {
            hr = GetNextTokenString( strBuffer, token.propType );
            if( FAILED( hr ) )
                return hr;
        }

        switch( token.eType )
        {
            case TOKEN_PROPERTY_TEXTURE_SOURCE:
                if( tex.m_dwDepth )
                {
                    if( srcnum <tex.m_dwDepth )
                        strcpy( tex.m_astrSource[srcnum++], strBuffer );
                    else
                        srcnum++;
                }
                else
                    ErrorMsg("Must specify volume texture DEPTH before SOURCE.\n" );
                break;
            case TOKEN_PROPERTY_TEXTURE_ALPHASOURCE:
                if( tex.m_dwDepth )
                {
                    if( alphasrcnum <tex.m_dwDepth )
                        strcpy( tex.m_astrAlphaSource[alphasrcnum++], strBuffer );
                    else
                        alphasrcnum++;
                }
                else
                    ErrorMsg("Must specify volume texture DEPTH before ALPHASOURCE.\n" );
                break;
            case TOKEN_PROPERTY_TEXTURE_FILTER:
                tex.m_dwFilter = FilterFromString( strBuffer );
                break;
            case TOKEN_PROPERTY_TEXTURE_FORMAT:
                strcpy( tex.m_strFormat, strBuffer );
                break;
            case TOKEN_PROPERTY_TEXTURE_WIDTH:
                tex.m_dwWidth = atoi( strBuffer );
                break;
            case TOKEN_PROPERTY_TEXTURE_HEIGHT:
                tex.m_dwHeight = atoi( strBuffer );
                break;
            case TOKEN_PROPERTY_VOLUMETEXTURE_DEPTH:
                if( 0 == tex.m_dwDepth )
                {   
                    tex.m_dwDepth         = atoi( strBuffer );
                    tex.m_astrSource      = new FILENAME[tex.m_dwDepth];
                    tex.m_astrAlphaSource = new FILENAME[tex.m_dwDepth];
                    ZeroMemory( tex.m_astrSource,      sizeof(FILENAME) * tex.m_dwDepth );
                    ZeroMemory( tex.m_astrAlphaSource, sizeof(FILENAME) * tex.m_dwDepth );
                }
                else
                    ErrorMsg("VolumeTexture DEPTH already specified.\n" );
                break;
            case TOKEN_PROPERTY_TEXTURE_LEVELS:
                tex.m_dwLevels = atoi( strBuffer );
                break;
            case TOKEN_RESOURCE_CLOSEBRACE:
                bDone = TRUE;
                break;
            default:
                ErrorMsg("<%s> is not a volume texture property.\n", token.strKeyword );
        }
    }

    // Check that we have a good number of sources
    if( ( srcnum != tex.m_dwDepth ) || ( alphasrcnum > 0  && alphasrcnum != tex.m_dwDepth ) )
    {   
        ErrorMsg("Volume texture must have same number of sources as the depth.\n" );
        return E_FAIL;
    }

    // Save the texture to the bundle
    hr = tex.SaveToBundle( &cbHeader, &cbData );
    if( FAILED( hr ) )
        return hr;

    printf("Volume texture: Wrote %s out in format %s (%d bytes)\n", 
        m_aResources[m_nResourceCount].strIdentifier, tex.m_strFormat, cbData );
    printf("     %d x %d x %d, %d levels\n\n", tex.m_dwWidth, tex.m_dwHeight, tex.m_dwDepth, tex.m_dwLevels);

    m_aResources[m_nResourceCount++].dwOffset = m_cbHeader;
    m_cbHeader += cbHeader;
    //m_cbData += cbData;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Match()
// Desc: Returns TRUE if it successfuly reads a token of the specified type.
//-----------------------------------------------------------------------------
BOOL CBundler::Match(INT TokType, BUNDLERTOKEN *pTok)
{
    HRESULT hr;
    hr = GetNextToken( pTok );
    if( FAILED( hr ) )
        return FALSE;

    if( pTok->eType != TokType )
        return FALSE;
    
    return TRUE;
}




//-----------------------------------------------------------------------------
// Name: HandleVertexBuffer()
// Desc: Takes over to handle a VertexBuffer token.  Reads all tokens up to and
//       including the closing brace
//-----------------------------------------------------------------------------
HRESULT CBundler::HandleVertexBufferToken()
{
    HRESULT hr;
    BUNDLERTOKEN tok;
    char strBuff[MAX_PATH], *pEnd;
    BOOL bDone = FALSE;
    DWORD cbHeader, cbData;

    // This is the vertex buffer name.
    hr = GetNextTokenString( m_aResources[m_nResourceCount].strIdentifier, TT_IDENTIFIER );
    if( FAILED( hr ) )
        return hr;

    // Check to see if it's a repeat identifier
    if( IsExistingIdentifier( m_aResources[m_nResourceCount].strIdentifier ) )
    {
        ErrorMsg( "Second usage of identifier <%s>", m_aResources[m_nResourceCount].strIdentifier );
        return E_FAIL;
    }

    if(!Match(TOKEN_RESOURCE_OPENBRACE, &tok))
    {
        ErrorMsg( "Vertexbuffer name should be followed by an open brace\n" );
        return E_FAIL;
    }

    CVertexBuffer *vb = new CVertexBuffer(this);
    
    // Loop over all the properties
    while( !bDone )
    {
        hr = GetNextToken( &tok );
        if( FAILED( hr ) )
            return hr;

        switch( tok.eType )
        {
            case TOKEN_PROPERTY_VB_VERTEXDATA:
                if(!Match(TOKEN_RESOURCE_OPENBRACE, &tok))
                {
                    ErrorMsg( "VertexData property must begin with an open brace.\n" );
                    return E_FAIL;
                }
                while(TRUE)
                {
                    if(FAILED(hr = GetNextTokenString( strBuff, TT_ANY ))) return hr;
                
                    if((strBuff[0] == '}') || (strBuff[0] == TOKEOF))
                        break;
                    else if(ValidateType(strBuff, TT_HEXNUMBER) == S_OK)
                        vb->AddVertexData((DOUBLE)strtoul(strBuff, &pEnd, 16));
                    else if(ValidateType(strBuff, TT_INTEGER) == S_OK)
                        vb->AddVertexData(atof(strBuff));
                    else if(ValidateType(strBuff, TT_FLOAT) == S_OK)
                        vb->AddVertexData(atof(strBuff));
                }
                break;
            case TOKEN_PROPERTY_VB_VERTEXFORMAT:
                if(!Match(TOKEN_RESOURCE_OPENBRACE, &tok))
                {
                    ErrorMsg( "VertexFormat property must begin with an open brace.\n" );
                    return E_FAIL;
                }
                while(TRUE)
                {
                    if(FAILED(hr = GetNextTokenString( strBuff, TT_ANY ))) return hr;
                
                    if((strBuff[0] == '}') || (strBuff[0] == TOKEOF))
                        break;
                    else
                    {
                        if((strcmp(strBuff, "D3DVSDT_FLOAT1") == 0) ||
                           (strcmp(strBuff, "FLOAT1") == 0))
                            vb->AddVertexFormat(XD3DVSDT_FLOAT1);
                        else if((strcmp(strBuff, "D3DVSDT_FLOAT2") == 0) ||
                                (strcmp(strBuff, "FLOAT2") == 0))
                            vb->AddVertexFormat(XD3DVSDT_FLOAT2);
                        else if((strcmp(strBuff, "D3DVSDT_FLOAT3") == 0) ||
                                (strcmp(strBuff, "FLOAT3") == 0))
                            vb->AddVertexFormat(XD3DVSDT_FLOAT3);
                        else if((strcmp(strBuff, "D3DVSDT_FLOAT4") == 0) ||
                                (strcmp(strBuff, "FLOAT4") == 0))
                            vb->AddVertexFormat(XD3DVSDT_FLOAT4);
                        else if((strcmp(strBuff, "D3DVSDT_D3DCOLOR") == 0) ||
                                (strcmp(strBuff, "D3DCOLOR") == 0))
                            vb->AddVertexFormat(XD3DVSDT_D3DCOLOR);
                        else if((strcmp(strBuff, "D3DVSDT_SHORT2") == 0) ||
                                (strcmp(strBuff, "SHORT2") == 0))
                            vb->AddVertexFormat(XD3DVSDT_SHORT2);
                        else if((strcmp(strBuff, "D3DVSDT_SHORT4") == 0) ||
                                (strcmp(strBuff, "SHORT4") == 0))
                            vb->AddVertexFormat(XD3DVSDT_SHORT4);
                        else if((strcmp(strBuff, "D3DVSDT_NORMSHORT1") == 0) ||
                                (strcmp(strBuff, "NORMSHORT1") == 0))
                            vb->AddVertexFormat(XD3DVSDT_NORMSHORT1);
                        else if((strcmp(strBuff, "D3DVSDT_NORMSHORT2") == 0) ||
                                (strcmp(strBuff, "NORMSHORT2") == 0))
                            vb->AddVertexFormat(XD3DVSDT_NORMSHORT2);
                        else if((strcmp(strBuff, "D3DVSDT_NORMSHORT3") == 0) ||
                                (strcmp(strBuff, "NORMSHORT3") == 0))
                            vb->AddVertexFormat(XD3DVSDT_NORMSHORT3);
                        else if((strcmp(strBuff, "D3DVSDT_NORMSHORT4") == 0) ||
                                (strcmp(strBuff, "NORMSHORT4") == 0))
                            vb->AddVertexFormat(XD3DVSDT_NORMSHORT4);
                        else if((strcmp(strBuff, "D3DVSDT_NORMPACKED3") == 0) ||
                                (strcmp(strBuff, "NORMPACKED3") == 0))
                            vb->AddVertexFormat(XD3DVSDT_NORMPACKED3);
                        else if((strcmp(strBuff, "D3DVSDT_SHORT1") == 0) ||
                                (strcmp(strBuff, "SHORT1") == 0))
                            vb->AddVertexFormat(XD3DVSDT_SHORT1);
                        else if((strcmp(strBuff, "D3DVSDT_SHORT3") == 0) ||
                                (strcmp(strBuff, "SHORT3") == 0))
                            vb->AddVertexFormat(XD3DVSDT_SHORT3);
                        else if((strcmp(strBuff, "D3DVSDT_PBYTE1") == 0) ||
                                (strcmp(strBuff, "PBYTE1") == 0))
                            vb->AddVertexFormat(XD3DVSDT_PBYTE1);
                        else if((strcmp(strBuff, "D3DVSDT_PBYTE2") == 0) ||
                                (strcmp(strBuff, "PBYTE2") == 0))
                            vb->AddVertexFormat(XD3DVSDT_PBYTE2);
                        else if((strcmp(strBuff, "D3DVSDT_PBYTE3") == 0) ||
                                (strcmp(strBuff, "PBYTE3") == 0))
                            vb->AddVertexFormat(XD3DVSDT_PBYTE3);
                        else if((strcmp(strBuff, "D3DVSDT_PBYTE4") == 0) ||
                                (strcmp(strBuff, "PBYTE4") == 0))
                            vb->AddVertexFormat(XD3DVSDT_PBYTE4);
                        else if((strcmp(strBuff, "D3DVSDT_FLOAT2H") == 0) ||
                                (strcmp(strBuff, "FLOAT2H") == 0))
                            vb->AddVertexFormat(XD3DVSDT_FLOAT2H);
                        else
                        {
                            ErrorMsg( "Unrecognized attribute format: %s\n", strBuff );
                            return E_FAIL;
                        }
                    }
                }
                break;

            case TOKEN_RESOURCE_CLOSEBRACE:
                bDone = TRUE;
                break;
            default:
                ErrorMsg("<%s> is not a vertexbuffer property.\n", tok.strKeyword );
        }
    }

    // Save the vertexbuffer to the bundle
    hr = vb->SaveToBundle( &cbHeader, &cbData );
    if( FAILED( hr ) )
        return hr;

    printf("VB:  Wrote %s: %d bytes per vertex, %d vertices (%d bytes)\n\n", 
           m_aResources[m_nResourceCount].strIdentifier, vb->m_cBytesPerVertex,
           vb->m_cVertices, cbData );

    m_aResources[m_nResourceCount++].dwOffset = m_cbHeader;
    m_cbHeader += cbHeader;
    //m_cbData += cbData;

    delete vb;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: HandleUserDataToken()
// Desc: Takes over to handle a UserData token.  Reads all tokens up to and
//       including the closing brace
//-----------------------------------------------------------------------------
HRESULT CBundler::HandleUserDataToken()
{
    BUNDLERTOKEN token;
    CUserData    ud(this);
    CHAR         strBuff[MAX_PATH];
    BOOL         bDone = FALSE;
    DWORD        cbHeader, cbData;
    HRESULT      hr;

    // This is the texture name.
    hr = GetNextTokenString( m_aResources[m_nResourceCount].strIdentifier, TT_IDENTIFIER );
    if( FAILED( hr ) )
        return hr;

    // Check to see if it's a repeat identifier
    if( IsExistingIdentifier( m_aResources[m_nResourceCount].strIdentifier ) )
    {
        ErrorMsg( "Second usage of identifier <%s>", m_aResources[m_nResourceCount].strIdentifier );
        return E_FAIL;
    }

    // This should be the open brace
    hr = GetNextToken( &token );
    if( FAILED( hr ) )
        return hr;

    if( token.eType != TOKEN_RESOURCE_OPENBRACE )
    {
        ErrorMsg( "Texture name should be followed by an open brace\n" );
        return E_FAIL;
    }

    // Loop over all the properties
    while( !bDone )
    {
        hr = GetNextToken( &token );
        if( FAILED( hr ) )
            return hr;

        // Any property token needs a value
        if( token.eType & TOKEN_PROPERTY_USERDATA )
        {
            hr = GetNextTokenString( strBuff, token.propType );
            if( FAILED( hr ) )
                return hr;
        }

        switch( token.eType )
        {
            case TOKEN_PROPERTY_USERDATA_DATAFILE:
                strcpy( ud.m_strSource, strBuff );
                break;
            case TOKEN_RESOURCE_CLOSEBRACE:
                bDone = TRUE;
                break;
            default:
                ErrorMsg("<%s> is not a userdata property.\n", token.strKeyword );
        }
    }

    // Save the UserData to the bundle
    hr = ud.SaveToBundle( &cbHeader, &cbData );
    if( FAILED( hr ) )
        return hr;

    printf( "UserData: Wrote %ld bytes.\n", cbHeader );

    m_aResources[m_nResourceCount++].dwOffset = m_cbHeader;
    m_cbHeader += cbHeader;
    //m_cbData += cbData;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: FlushDataFile()
// Desc: Writes out all the buffered data to the data file, including
//       appropriate padding
//-----------------------------------------------------------------------------
HRESULT CBundler::FlushDataFile()
{
    BOOL bWriteOK;
    DWORD cb;
    XPR_HEADER xprh;
    BYTE * pbTemp;
    DWORD cbFill = 0;

    // Pad the data buffer out to be a multiple of the DVD sector size (2k).
    // This is needed in order to DMA the file off the DVD drive on the
    // Xbox.
    PadToAlignment( 2048 );

    xprh.dwMagic = XPR_MAGIC_VALUE;
    xprh.dwHeaderSize = m_cbHeader + sizeof( XPR_HEADER );

    // We may need to pad the file to a sector multiple for the 
    // start of the data block
    if( xprh.dwHeaderSize % 2048 )
    {
        cbFill = 2048 - ( xprh.dwHeaderSize % 2048 );
        xprh.dwHeaderSize += cbFill;
    }
    xprh.dwTotalSize = xprh.dwHeaderSize + m_cbData;

    // Write out header stuff
    if( !WriteFile( m_hfXPR, &xprh, sizeof( XPR_HEADER ), &cb, NULL ) )
        return E_FAIL;
    if( !WriteFile( m_hfXPR, m_pbHeaderBuff, m_cbHeader, &cb, NULL ) )
        return E_FAIL;

    if( cbFill )
    {
        // Allocate a buffer for fill data
        pbTemp = (BYTE *)malloc( cbFill );
        memset( pbTemp, 0xDEAD, cbFill );

        // Write it out
        bWriteOK = WriteFile( m_hfXPR, pbTemp, cbFill, &cb, NULL );
        free( pbTemp );
        if( !bWriteOK )
            return E_FAIL;
    }

    if( !WriteFile( m_hfXPR, m_pbDataBuff, m_cbData, &cb, NULL ) )
        return E_FAIL;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: WriteHeaderFile()
// Desc: Writes out a .h file with useful defitions:
//       * NUM_RESOURCES
//       * XXX_OFFSET for each resource
//-----------------------------------------------------------------------------
HRESULT CBundler::WriteHeaderFile()
{
    DWORD i;
    DWORD cb;
    char strBuff[256];

    sprintf( strBuff, "// Automatically generated by the bundler tool from %s\n\n", m_strRDF );
    if( !WriteFile( m_hfHDR, strBuff, strlen(strBuff), &cb, NULL ) )
        return E_FAIL;

    // strip root filename out of m_strRDF;
    CHAR strPrefix[MAX_PATH];

    if( m_strPrefix[0] )
    {
        strcpy( strPrefix, m_strPrefix );
    }
    else
    {
        // Use the resource name as a prefix, after removing prepending path
        // and file extension.
        CHAR* pStr = strrchr( m_strRDF, '\\' );
        if( pStr )
            strcpy( strPrefix, pStr+1 );
        else
            strcpy( strPrefix, m_strRDF );

        pStr = strchr( strPrefix, '.' );
        if( pStr )
            *pStr = '\0';
    }

    // Write out the number of resources
    sprintf( strBuff, "#define %s_NUM_RESOURCES %dUL\n\n", strPrefix, m_nResourceCount );
    if( !WriteFile( m_hfHDR, strBuff, strlen(strBuff), &cb, NULL ) )
        return E_FAIL;

    // Write out the offset of each resource
    if( m_bSingleTexture )
    {
        sprintf( strBuff, "#define %s_OFFSET %dUL\n", strPrefix, 
                          m_aResources[0].dwOffset );
        if( !WriteFile( m_hfHDR, strBuff, strlen(strBuff), &cb, NULL ) )
            return E_FAIL;
    }
    else
    {
        for( i = 0; i < m_nResourceCount; i++ )
        {
            sprintf( strBuff, "#define %s_%s_OFFSET %dUL\n", strPrefix, 
                    m_aResources[i].strIdentifier, m_aResources[i].dwOffset );
            if( !WriteFile( m_hfHDR, strBuff, strlen(strBuff), &cb, NULL ) )
                return E_FAIL;
        }
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: HandleEOFToken()
// Desc: Handles any necessary end-of-input processing, such as patching up
//       header information
//-----------------------------------------------------------------------------
HRESULT CBundler::HandleEOFToken()
{
    if( FAILED( OpenFiles() ) )
        return E_FAIL;

    // write one last header entry to terminate the list
    DWORD tmp = 0xffffffff;
    WriteHeader( &tmp, sizeof( tmp ) );
    m_cbHeader += sizeof( tmp );

    if( FAILED( FlushDataFile() ) )
        return E_FAIL;

//  if( FAILED( WriteHeaderFile() ) )
//      return E_FAIL;

    return S_FALSE;
}




//-----------------------------------------------------------------------------
// Name: HandleOutPackedResourceToken()
// Desc: Takes over to handle the out_packedresource token.  
//-----------------------------------------------------------------------------
HRESULT CBundler::HandleOutPackedResourceToken()
{
    CHAR strFilename[MAX_PATH];
    GetNextTokenString( strFilename, TT_FILENAME );

    if( m_nResourceCount > 0 )
    {
        ErrorMsg( "Warning: output files must be specified before resources\n" );
    }
    else if( !m_bExplicitXPR )
    {
        if( strchr( strFilename, ':' ) )
            strcpy( m_strXPR, strFilename );
        else
        {
            strcpy( m_strXPR, m_strPath );
            strcat( m_strXPR, strFilename );
        }
    }
    else
    {
        ErrorMsg( "Warning: out_packedresource overriden by command line\n" );
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: HandleOutHeaderToken()
// Desc: Takes over to handle the out_header token.  
//-----------------------------------------------------------------------------
HRESULT CBundler::HandleOutHeaderToken()
{
    CHAR strFilename[MAX_PATH];
    GetNextTokenString( strFilename, TT_FILENAME );

    if( m_nResourceCount > 0 )
    {
        ErrorMsg( "Warning: output files must be specified before resources\n" );
    }
    else if( !m_bExplicitHDR )
    {
        if( strchr( strFilename, ':' ) )
            strcpy( m_strHDR, strFilename );
        else
        {
            strcpy( m_strHDR, m_strPath );
            strcat( m_strHDR, strFilename );
        }
    }
    else
    {
        ErrorMsg( "Warning: out_header overriden by command line\n" );
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: HandleOutPrefixToken()
// Desc: Takes over to handle the out_header token.  
//-----------------------------------------------------------------------------
HRESULT CBundler::HandleOutPrefixToken()
{
    CHAR strPrefix[MAX_PATH];
    GetNextTokenString( strPrefix, TT_ANY );

    if( m_nResourceCount > 0 )
    {
        ErrorMsg( "Warning: output prefix must be specified before resources\n" );
    }
    else if( !m_bExplicitPrefix )
    {
        strcpy( m_strPrefix, strPrefix );
    }
    else
    {
        ErrorMsg( "Warning: out_prefix overriden by command line\n" );
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: HandleOutErrorToken()
// Desc: Takes over to handle the out_error token.  
//-----------------------------------------------------------------------------
HRESULT CBundler::HandleOutErrorToken()
{
    CHAR strFilename[MAX_PATH];
    GetNextTokenString( strFilename, TT_FILENAME );

    if( m_nResourceCount > 0 )
    {
        ErrorMsg( "Warning: output files must be specified before resources\n" );
    }
    else if( !m_bExplicitERR )
    {
        if( strchr( strFilename, ':' ) )
            strcpy( m_strERR, strFilename );
        else
        {
            strcpy( m_strERR, m_strPath );
            strcat( m_strERR, strFilename );
        }
    }
    else
    {
        ErrorMsg( "Warning: out_error overriden by command line\n" );
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: WriteHeader()
// Desc: Copies resource header info to the header buffer.  Grows the header
//       buffer by multiples of 2.
//-----------------------------------------------------------------------------
HRESULT CBundler::WriteHeader( void * pbBuff, DWORD cb )
{
    DWORD cbNew = m_cbHeaderAlloc;

    // Find the next power-of-2 size that is big enough to hold the data
    while( m_cbHeader + cb > cbNew )
        cbNew <<= 1;

    // Realloc if necessary
    if( cbNew > m_cbHeaderAlloc )
    {
        BYTE * pbTemp = (BYTE *)realloc( m_pbHeaderBuff, cbNew );
        if( !pbTemp )
            return E_OUTOFMEMORY;
        m_pbHeaderBuff = pbTemp;
        m_cbHeaderAlloc = cbNew;
    }

    // Copy over the data
    memcpy( m_pbHeaderBuff + m_cbHeader, pbBuff, cb );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: WriteData()
// Desc: Copies data to the data buffer.  Grows our data buffer by multiples
//       of 2
//-----------------------------------------------------------------------------
HRESULT CBundler::WriteData( void * pbBuff, DWORD cb )
{
    DWORD cbNew = m_cbDataAlloc;

    //
    // Find the next power-of-2 size that is 
    // big enough to hold the data
    //
    while( m_cbData + cb > cbNew )
        cbNew <<= 1;
    
    // Realloc if necessary
    if( cbNew > m_cbDataAlloc )
    {
        BYTE * pbTemp = (BYTE *)realloc( m_pbDataBuff, cbNew );
        if( !pbTemp )
            return E_OUTOFMEMORY;
        m_pbDataBuff = pbTemp;
        m_cbDataAlloc = cbNew;
    }

    // Copy over the data
    memcpy( m_pbDataBuff + m_cbData, pbBuff, cb );
    m_cbData += cb;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: PadToAlignment()
// Desc: Pads the data buffer to the specified alignment
//-----------------------------------------------------------------------------
HRESULT CBundler::PadToAlignment( DWORD dwAlign )
{
    HRESULT hr = S_OK;
    BYTE * pbTemp = NULL;
    DWORD cbFill = 0;

    if( m_cbData % dwAlign )
        cbFill = dwAlign - ( m_cbData % dwAlign );

    if( cbFill )
    {
        pbTemp = (BYTE *)malloc( cbFill );
        memset( pbTemp, 0xDEAD, cbFill );

        hr = WriteData( pbTemp, cbFill );
        
        free( pbTemp );
    }

    return hr;
}




//-----------------------------------------------------------------------------
// Name: IsExistingIdentifier()
// Desc: Returns TRUE if we've already processed a resource with the given
//       identifier
//-----------------------------------------------------------------------------
BOOL CBundler::IsExistingIdentifier( char * strIdentifier )
{
    DWORD dwIndex;
    DWORD dwStrLen = strlen( strIdentifier );

    for( dwIndex = 0; dwIndex < m_nResourceCount; dwIndex++ )
    {
        if( strlen( m_aResources[ dwIndex ].strIdentifier ) == dwStrLen &&
            !strncmp( strIdentifier, m_aResources[ dwIndex ].strIdentifier, dwStrLen ) )
            return TRUE;
    }

    return FALSE;
}




//-----------------------------------------------------------------------------
// Name: Process()
// Desc: Processes the resource definition file and processes it to create our
//       Xbox Packed Resource (xpr) file and header file
//-----------------------------------------------------------------------------
HRESULT CBundler::Process()
{
    HRESULT hr;
    BUNDLERTOKEN tok;

/*
    // Special case: single-texture conversion
    if( m_bSingleTexture )
    {
        CTexture2D tex(this);
        DWORD cbHeader, cbData;
        
        if( strrchr( m_strRDF, '\\' ) )
            strcpy( tex.m_strSource, strrchr( m_strRDF, '\\' )+1 );
        else
            strcpy( tex.m_strSource, m_strRDF );
        
        // Save the texture to the bundle
        hr = tex.SaveToBundle( &cbHeader, &cbData );
        if( FAILED( hr ) )
            return hr;
    
        printf( "Texture: Wrote %s out in format %s (%d bytes)\n", 
                 tex.m_strSource, tex.m_strFormat, cbData );
        printf( "     %d x %d, %d levels\n\n", tex.m_dwWidth, tex.m_dwHeight, tex.m_dwLevels );
    
        m_aResources[m_nResourceCount++].dwOffset = m_cbHeader;
        m_cbHeader += cbHeader;

        HandleEOFToken();

        return S_OK;
    }
    
    // Open the file
    m_hfRDF = CreateFile( m_strRDF, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL );
    if( INVALID_HANDLE_VALUE == m_hfRDF )
    {
        ErrorMsg( "Error: Can't open <%s>\n", m_strRDF );
        return E_FAIL;
    }
*/
    // Iterate over top-level tokens (Texture, out_xxxx, EOF, etc)
    for( ; ; )
    {
        hr = GetNextToken( &tok );
        if( FAILED( hr ) )
            return hr;

        hr = (this->*tok.pfnHandler)();
        if( FAILED( hr ) )
            return hr;
        else if( hr == S_FALSE  )
            break;

    }

    return S_OK;
}



/*
//-----------------------------------------------------------------------------
// Name: main()
// Desc: Entry point to the program
//-----------------------------------------------------------------------------
int _cdecl main( int argc, char * argv[] )
{
    HRESULT hr;
    CBundler bundler;

    hr = bundler.Initialize( argc, argv );
    if(hr == E_INVALIDARG)
    {
        bundler.PrintUsage();
        return 0;
    }
    else if(FAILED(hr))
    {
        bundler.ErrorMsg( "ERROR: D3D Initialization failed.\n" );
        return 0;
    }

    hr = bundler.Process();
    if( FAILED( hr ) )
        return 0;

    return 0;
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\xodash\imageConv\bundler.h ===
//-----------------------------------------------------------------------------
// File: Bundler.h
//
// Desc: Header file for the bundler tool
//
// Hist: 02.06.01 - New for March XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef BUNDLER_H
#define BUNLDER_H

#include "imageConv.h"
#include <assert.h>
#include <windows.h>
#include <d3dx8.h>


// Default extensions for output files
#define XPREXT ".xpr"
#define HDREXT ".h"
#define ERREXT ".err"

#define MAX_RESOURCES 1024

#define TOKEOF ((CHAR)0xff)


class CBundler;
typedef HRESULT (CBundler::* TOKENHANDLERFN)();


// Enums for all of our known tokens
typedef enum 
{ 
    TOKEN_RESOURCE_OPENBRACE             = 0x00000001,
    TOKEN_RESOURCE_CLOSEBRACE            = 0x00000002,
    TOKEN_RESOURCE_EOF                   = 0x00000003,
    TOKEN_RESOURCE_OUT_PACKEDRESOURCE    = 0x00000004,
    TOKEN_RESOURCE_OUT_HEADER            = 0x00000005, 
    TOKEN_RESOURCE_OUT_PREFIX            = 0x00000006, 
    TOKEN_RESOURCE_OUT_ERROR             = 0x00000007,
    TOKEN_RESOURCE_TEXTURE               = 0x00000010,
    TOKEN_RESOURCE_CUBEMAP               = 0x00000030,
    TOKEN_RESOURCE_VOLUMETEXTURE         = 0x00000050,
    TOKEN_RESOURCE_VERTEXBUFFER          = 0x00000100,
    TOKEN_RESOURCE_USERDATA              = 0x00000200,

    // Properties for a resource have the resource
    // value shifted over by 16 bits
    TOKEN_PROPERTY_TEXTURE                = 0x00100000,
    TOKEN_PROPERTY_TEXTURE_SOURCE         = 0x00100001,
    TOKEN_PROPERTY_TEXTURE_ALPHASOURCE    = 0x00100002,
    TOKEN_PROPERTY_TEXTURE_FILTER         = 0x00100003,
    TOKEN_PROPERTY_TEXTURE_FORMAT         = 0x00100004,
    TOKEN_PROPERTY_TEXTURE_WIDTH          = 0x00100005,
    TOKEN_PROPERTY_TEXTURE_HEIGHT         = 0x00100006,
    TOKEN_PROPERTY_TEXTURE_LEVELS         = 0x00100007,

    TOKEN_PROPERTY_CUBEMAP                = 0x00300000,
    TOKEN_PROPERTY_CUBEMAP_SOURCE_XP      = 0x00300001,
    TOKEN_PROPERTY_CUBEMAP_SOURCE_XN      = 0x00300002,
    TOKEN_PROPERTY_CUBEMAP_SOURCE_YP      = 0x00300003,
    TOKEN_PROPERTY_CUBEMAP_SOURCE_YN      = 0x00300004,
    TOKEN_PROPERTY_CUBEMAP_SOURCE_ZP      = 0x00300005,
    TOKEN_PROPERTY_CUBEMAP_SOURCE_ZN      = 0x00300006,
    TOKEN_PROPERTY_CUBEMAP_ALPHASOURCE_XP = 0x00300011,
    TOKEN_PROPERTY_CUBEMAP_ALPHASOURCE_XN = 0x00300012,
    TOKEN_PROPERTY_CUBEMAP_ALPHASOURCE_YP = 0x00300013,
    TOKEN_PROPERTY_CUBEMAP_ALPHASOURCE_YN = 0x00300014,
    TOKEN_PROPERTY_CUBEMAP_ALPHASOURCE_ZP = 0x00300015,
    TOKEN_PROPERTY_CUBEMAP_ALPHASOURCE_ZN = 0x00300016,
    TOKEN_PROPERTY_CUBEMAP_SIZE           = 0x00300022,

    TOKEN_PROPERTY_VOLUMETEXTURE             = 0x00500000,
//    TOKEN_PROPERTY_VOLUMETEXTURE_SOURCE      = 0x00500001,
//    TOKEN_PROPERTY_VOLUMETEXTURE_ALPHASOURCE = 0x00500002,
    TOKEN_PROPERTY_VOLUMETEXTURE_DEPTH       = 0x00500003,

    TOKEN_PROPERTY_VB                     = 0x01000000,
    TOKEN_PROPERTY_VB_VERTEXDATA          = 0x01000001,
    TOKEN_PROPERTY_VB_VERTEXFORMAT        = 0x01000002,

    TOKEN_PROPERTY_USERDATA               = 0x02000000,
    TOKEN_PROPERTY_USERDATA_DATAFILE      = 0x02000001,

} TOKEN_ID;


// Types of tokens for validation
typedef enum
{
    TT_ANY = 0,
    TT_IDENTIFIER,
    TT_HEXNUMBER,
    TT_INTEGER,
    TT_FLOAT,
    TT_FILENAME,
} TOKENTYPE;


// Token struct that is passed around
typedef struct _BUNDLERTOKEN
{
    char *          strKeyword;
    TOKEN_ID        eType;
    TOKENTYPE       propType;
    TOKENHANDLERFN  pfnHandler;
} BUNDLERTOKEN;


// Resource struct for tracking
typedef struct 
{
    char    strIdentifier[128];
    DWORD   dwOffset;
} RESOURCE_STRUCT;




//-----------------------------------------------------------------------------
// Name: class CBundler
// Desc: Main application class for driving the bundler.  Handles data 
//       management, resource tracking, file management, and tokenizing
//-----------------------------------------------------------------------------
class CBundler
{
public:
    CBundler();
    ~CBundler();

    HRESULT InitD3D();
    HRESULT Initialize( int argc, char * argv[] );
    HRESULT Process();
    void    PrintUsage();

    HRESULT WriteHeader( void * pbBuff, DWORD cb );
    HRESULT WriteData( void * pbBuff, DWORD cb );
    HRESULT PadToAlignment( DWORD dwAlign );

    // Token handling routines
    HRESULT HandleOutPackedResourceToken();
    HRESULT HandleOutHeaderToken();
    HRESULT HandleOutPrefixToken();
    HRESULT HandleOutErrorToken();
    HRESULT HandleTextureToken();
	HRESULT HandleTexture( CImageItem *imageFile );
    HRESULT HandleCubemapToken();
	HRESULT HandleVolumeTextureToken();
    HRESULT HandleVertexBufferToken();
    HRESULT HandleUserDataToken();
    HRESULT HandleEOFToken();

    DWORD   FilterFromString( char* strFilter );

    // D3D stuff for manipulating textures
    LPDIRECT3D8 m_pd3d;
    LPDIRECT3DDEVICE8 m_pd3ddev;

    // Routine to call w/ error messages - prints to stdout and file
    void ErrorMsg( char * strFmt, ... );

    BOOL IsExistingIdentifier( char * strIdentifier );

    DWORD m_cbHeader;
    DWORD m_cbData;

public:

    HRESULT OpenFiles();            // Open output files
    HRESULT CloseFiles();           // Close all files
    HRESULT FlushDataFile();        // Flush from buffer to output file
    HRESULT WriteHeaderFile();      // Create .h header file

    BOOL    Match( INT TokenType, BUNDLERTOKEN* pToken );
    HRESULT GetNextToken( BUNDLERTOKEN* pToken );
    HRESULT GetNextTokenString( CHAR* strTokenString, TOKENTYPE tt );
    HRESULT ValidateType( CHAR* strToken, TOKENTYPE tt );
    HRESULT GetTokenFromString( CHAR* strTokenString, BUNDLERTOKEN* pToken );
    CHAR    GetChar();
    CHAR    PeekChar();

    // Filenames
	CHAR   m_strPath[MAX_PATH];
    CHAR   m_strRDF[MAX_PATH];
    CHAR   m_strXPR[MAX_PATH];
    CHAR   m_strHDR[MAX_PATH];
    CHAR   m_strERR[MAX_PATH];

	// Prefix for header file constants
    CHAR   m_strPrefix[MAX_PATH];

    // File handles
    HANDLE m_hfRDF;
    HANDLE m_hfXPR;
    HANDLE m_hfHDR;
    HANDLE m_hfERR;

    // Data buffer management
    BYTE*  m_pbHeaderBuff;
    DWORD  m_cbHeaderAlloc;
    BYTE*  m_pbDataBuff;
    DWORD  m_cbDataAlloc;

    // Resource tracking
    RESOURCE_STRUCT  m_aResources[MAX_RESOURCES];
    DWORD  m_nResourceCount;

    // For specifying output files and prefix on cmd line vs. in RDF
    BOOL   m_bExplicitXPR;
    BOOL   m_bExplicitHDR;
    BOOL   m_bExplicitERR;
	BOOL   m_bExplicitPrefix;

    // Single character read buffers
    CHAR   m_cNext0;
    CHAR   m_cNext1;
    CHAR   m_cNext2;
    CHAR   m_cNext3;

    // Indicates a single-texture conversion
    BOOL   m_bSingleTexture;
};


#endif // BUNDLER_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\xodash\imageConv\cubemap.cpp ===
//-----------------------------------------------------------------------------
// File: Cubemap.cpp
//
// Desc: Contains the cubemap-specific logic for the bundler tool
//
// Hist: 04.11.01 - New for May XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include "Cubemap.h"
#include "Bundler.h"




//-----------------------------------------------------------------------------
// Name: CCubemap()
// Desc: Initializes member variables
//-----------------------------------------------------------------------------
CCubemap::CCubemap( CBundler* pBundler )
         :CBaseTexture( pBundler )
{
    m_pSurfaceXP            = NULL;
    m_pSurfaceXN            = NULL;
    m_pSurfaceYP            = NULL;
    m_pSurfaceYN            = NULL;
    m_pSurfaceZP            = NULL;
    m_pSurfaceZN            = NULL;

    m_strSourceXP[0]         = '\0';
    m_strSourceXN[0]         = '\0';
    m_strSourceYP[0]         = '\0';
    m_strSourceYN[0]         = '\0';
    m_strSourceZP[0]         = '\0';
    m_strSourceZN[0]         = '\0';
    m_strAlphaSourceXP[0]    = '\0';
    m_strAlphaSourceXN[0]    = '\0';
    m_strAlphaSourceYP[0]    = '\0';
    m_strAlphaSourceYN[0]    = '\0';
    m_strAlphaSourceZP[0]    = '\0';
    m_strAlphaSourceZN[0]    = '\0';
}




//-----------------------------------------------------------------------------
// Name: ~CCubemap()
// Desc: Performs any cleanup needed before the object is destroyed
//-----------------------------------------------------------------------------
CCubemap::~CCubemap()
{
    if( m_pSurfaceXP )
        m_pSurfaceXP->Release();
    if( m_pSurfaceXN )
        m_pSurfaceXN->Release();
    if( m_pSurfaceYP )
        m_pSurfaceYP->Release();
    if( m_pSurfaceYN )
        m_pSurfaceYN->Release();
    if( m_pSurfaceZP )
        m_pSurfaceZP->Release();
    if( m_pSurfaceZN )
        m_pSurfaceZN->Release();
}




//-----------------------------------------------------------------------------
// Name: SaveToBundle()
// Desc: Handles saving the appropriate data to the packed resource file
//-----------------------------------------------------------------------------
HRESULT CCubemap::SaveToBundle( DWORD* pcbHeader, DWORD* pcbData )
{
    HRESULT hr;

    hr = LoadCubemap();
    if( FAILED( hr ) )
        return hr;

    // Pad data file to proper alignment for the start of the texture
    hr = m_pBundler->PadToAlignment( D3DTEXTURE_ALIGNMENT );
    if( FAILED( hr ) )
        return hr;

    // Save resource header
    hr = SaveHeaderInfo( m_pBundler->m_cbData, pcbHeader );
    if( FAILED( hr ) )
        return hr;

    // Save cubemap data
    (*pcbData) = 0;
    SaveSurface( pcbData, m_dwLevels, m_pSurfaceXP );
    SaveSurface( pcbData, m_dwLevels, m_pSurfaceXN );
    SaveSurface( pcbData, m_dwLevels, m_pSurfaceYP );
    SaveSurface( pcbData, m_dwLevels, m_pSurfaceYN );
    SaveSurface( pcbData, m_dwLevels, m_pSurfaceZP );
    SaveSurface( pcbData, m_dwLevels, m_pSurfaceZN );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: LoadCubemap()
// Desc: Loads the texture from the file, and sets any properties that were
//       not specified with values from the file (width, height, format, etc)
//-----------------------------------------------------------------------------
HRESULT CCubemap::LoadCubemap()
{
    D3DSURFACE_DESC desc;
    HRESULT hr;

    // Try to look up our format string
    m_nFormat = FormatFromString( m_strFormat );
    if( m_nFormat < -1 )
    {
        m_pBundler->ErrorMsg( "Error: Invalid texture format: %s", m_strFormat );
        return E_FAIL;
    }
    lstrcpyA( m_strFormat, g_TextureFormats[m_nFormat].strFormat );

    // Check for linear textures
    if( g_TextureFormats[m_nFormat].Type == FMT_LINEAR )
    {
        m_pBundler->ErrorMsg( "Error: Cubemaps cannot have linear formats", m_strFormat );
        return E_FAIL;
    }

    // If an alpha source was specified, make sure the format supports alpha
    if( m_strAlphaSourceXP[0] || m_strAlphaSourceXN[0] || 
        m_strAlphaSourceYP[0] || m_strAlphaSourceYN[0] || 
        m_strAlphaSourceZP[0] || m_strAlphaSourceZN[0] ) 
    {
        if( g_TextureFormats[m_nFormat].dwNumAlphaBits == 0 )
        {
            m_pBundler->ErrorMsg( "Warning: an ALPHASOURCE was specified, yet the " \
                                  "requested texture format, %s,  does not have " \
                                  "any alpha.\n", m_strFormat );
        }
    }

    // Load the image surfaces from the file (using default width, height, and a
    // A8R8G8B8 surface format)
    if( FAILED( hr = LoadSurface( m_strSourceXP, m_strAlphaSourceXP, &m_pSurfaceXP ) ) )
    {
		if( m_strAlphaSourceXP[0] )
			m_pBundler->ErrorMsg( "Cubemap: Couldn't load source file <%s> or <%s>\n", m_strSourceXP, m_strAlphaSourceXP );
		else
			m_pBundler->ErrorMsg( "Cubemap: Couldn't load source file <%s>\n", m_strSourceXP );
        return hr;
    }
    if( FAILED( hr = LoadSurface( m_strSourceXN, m_strAlphaSourceXN, &m_pSurfaceXN ) ) )
    {
		if( m_strAlphaSourceXN[0] )
			m_pBundler->ErrorMsg( "Cubemap: Couldn't load source file <%s> or <%s>\n", m_strSourceXN, m_strAlphaSourceXN );
		else
			m_pBundler->ErrorMsg( "Cubemap: Couldn't load source file <%s>\n", m_strSourceXN );
        return hr;
    }
    if( FAILED( hr = LoadSurface( m_strSourceYP, m_strAlphaSourceYP, &m_pSurfaceYP ) ) )
    {
		if( m_strAlphaSourceYP[0] )
			m_pBundler->ErrorMsg( "Cubemap: Couldn't load source file <%s> or <%s>\n", m_strSourceYP, m_strAlphaSourceYP );
		else
			m_pBundler->ErrorMsg( "Cubemap: Couldn't load source file <%s>\n", m_strSourceYP );
        return hr;
    }
    if( FAILED( hr = LoadSurface( m_strSourceYN, m_strAlphaSourceYN, &m_pSurfaceYN ) ) )
    {
		if( m_strAlphaSourceYN[0] )
			m_pBundler->ErrorMsg( "Cubemap: Couldn't load source file <%s> or <%s>\n", m_strSourceYN, m_strAlphaSourceYN );
		else
			m_pBundler->ErrorMsg( "Cubemap: Couldn't load source file <%s>\n", m_strSourceYN );
        return hr;
    }
    if( FAILED( hr = LoadSurface( m_strSourceZP, m_strAlphaSourceZP, &m_pSurfaceZP ) ) )
    {
		if( m_strAlphaSourceZP[0] )
			m_pBundler->ErrorMsg( "Cubemap: Couldn't load source file <%s> or <%s>\n", m_strSourceZP, m_strAlphaSourceZP );
		else
			m_pBundler->ErrorMsg( "Cubemap: Couldn't load source file <%s>\n", m_strSourceZP );
        return hr;
    }
    if( FAILED( hr = LoadSurface( m_strSourceZN, m_strAlphaSourceZN, &m_pSurfaceZN ) ) )
    {
		if( m_strAlphaSourceZN[0] )
			m_pBundler->ErrorMsg( "Cubemap: Couldn't load source file <%s> or <%s>\n", m_strSourceZN, m_strAlphaSourceZN );
		else
			m_pBundler->ErrorMsg( "Cubemap: Couldn't load source file <%s>\n", m_strSourceZN );
        return hr;
    }

    // Determine final width and height
    if( m_dwSize==0 )
    {
        hr = m_pSurfaceXP->GetDesc( &desc );

        // Enforce power-of-two dimensions for cubemap faces
        for( m_dwSize=1;  m_dwSize  < desc.Width;  m_dwSize<<=1 );
    }

    // Determine final number of miplevels
    DWORD dwLevels = 1; 
    while( (1UL<<(dwLevels-1)) < m_dwSize )
        dwLevels++;
        
    if( m_dwLevels < 1 || m_dwLevels > dwLevels )
        m_dwLevels = dwLevels;

    // Change the size of the surfaces
    hr = ResizeSurface( m_dwSize, m_dwSize, &m_pSurfaceXP );
    hr = ResizeSurface( m_dwSize, m_dwSize, &m_pSurfaceXN );
    hr = ResizeSurface( m_dwSize, m_dwSize, &m_pSurfaceYP );
    hr = ResizeSurface( m_dwSize, m_dwSize, &m_pSurfaceYN );
    hr = ResizeSurface( m_dwSize, m_dwSize, &m_pSurfaceZP );
    hr = ResizeSurface( m_dwSize, m_dwSize, &m_pSurfaceZN );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: SaveHeaderInfo()
// Desc: Saves the appropriate data to the header file
//-----------------------------------------------------------------------------
HRESULT CCubemap::SaveHeaderInfo( DWORD dwStart, DWORD* pcbHeader )
{
    D3DTexture d3dtex;

    XGSetCubeTextureHeader( m_dwSize, m_dwLevels, 0,
                            (D3DFORMAT)g_TextureFormats[m_nFormat].dwXboxFormat,
                            D3DPOOL_DEFAULT, (IDirect3DCubeTexture8*)&d3dtex,
                            dwStart, 0 );

    // Write the resource header out
    if( FAILED( m_pBundler->WriteHeader( &d3dtex, sizeof( d3dtex ) ) ) )
        return E_FAIL;

    (*pcbHeader) = sizeof(d3dtex);

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\xodash\imageConv\imageConv.h ===
//-----------------------------------------------------------------------------
// File: imageConv.h
//
// Desc: Header file for the Image Converter
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef IMAGECONV_H
#define IMAGECONV_H

#include <assert.h>
#include <windows.h>
#include <d3dx8.h>
#include <list>

class CImageItem
{
public:
	CHAR		 fullpath[MAX_PATH];	// Holds the full path and filename of the image
	CHAR		 filename[MAX_PATH]; 	// Holds the actual name of the file
	CHAR		 outputpath[MAX_PATH];  // Holds the destination location for the image
	unsigned int width;					// Width of Image
	unsigned int height;				// Height of Image
	unsigned int depth;					// Depth of Image
};

using namespace std;
typedef list<CImageItem*>  ImageList;

#pragma pack(1)

// TGA file header data
typedef struct
{
	BYTE		   image_id_len;
	BYTE		   color_map;
	BYTE		   image_type;
	unsigned short cm_first_entry;
	unsigned short cm_length;
	BYTE		   cm_entry_size;
	unsigned short x_origin;
	unsigned short y_origin;
	unsigned short width;
	unsigned short height;
	BYTE		   pixel_depth;
	BYTE		   image_descriptor;
} TGAHeader;

// BMP file header data
typedef struct
{ 
	unsigned short Type;          // signature - 'BM'
	unsigned long  Size;          // file size in bytes
	unsigned short Reserved1;     // 0
	unsigned short Reserved2;     // 0
	unsigned long  OffBits;       // offset to bitmap
	unsigned long  StructSize;    // size of this struct (40)
	unsigned long  Width;         // bmap width in pixels
	unsigned long  Height;        // bmap height in pixels
	unsigned short Planes;        // num planes - always 1
	unsigned short BitCount;      // bits per pixel
	unsigned long  Compression;   // compression flag
	unsigned long  SizeImage;     // image size in bytes
	long           XPelsPerMeter; // horz resolution
	long           YPelsPerMeter; // vert resolution
	unsigned long  ClrUsed;       // 0 -> color table size
	unsigned long  ClrImportant;  // important color count
} BMPHeader;

#pragma pack()



//-----------------------------------------------------------------------------
// Name: class CImageConv
// Desc: Main application class for driving the Image Converter.  Handles 
//		 directory polling, error checking, and the convertion.
//-----------------------------------------------------------------------------
class CImageConv
{
public:
    CImageConv();
    ~CImageConv();
	
	void    PrintUsage();

	HRESULT Initialize ( int argc, char * argv[] );
	HRESULT ValidateDir ( char* dir );
	HRESULT FindImages ( char* extension );
	HRESULT FillImageInfo ( CImageItem *imageFile );
	HRESULT CheckImageDest ( CImageItem *imageFile );

	// Linked list of original image filenames
	int				m_nImageFiles;	
	ImageList		m_ImageFiles;
   
public:

	// Path Strings
	CHAR   m_strInputDir[MAX_PATH];
    CHAR   m_strOutputDir[MAX_PATH];

    // For specifying output directories on cmd line vs. in code
    BOOL   m_bExplicitInput;
    BOOL   m_bExplicitOutput;  
	BOOL   m_bForceOutput;  
};


#endif // IMAGECONV_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\xodash\imageConv\LoadImage.h ===
//-----------------------------------------------------------------------------
// File: LoadImage.h
//
// Desc: Loads image files
//
// Hist: 04.13.01 - New for May XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef LOADIMAGE_H
#define LOADIMAGE_H


#define DPF(x,y)
#define D3DXASSERT(x)
#define D3DXERR_INVALIDDATA -1




//-----------------------------------------------------------------------------
// Name: class CImage
// Desc: Class to load different image formats
//-----------------------------------------------------------------------------
class CImage
{
public:
    VOID*           m_pData;
    D3DFORMAT       m_Format;
    DWORD           m_Width;
    DWORD           m_Height;
    DWORD           m_Pitch;
    PALETTEENTRY*   m_pPalette;

    RECT            m_Rect;

    BOOL            m_bDeleteData;
    BOOL            m_bDeletePalette;

    HRESULT LoadBMP( const VOID* pData, DWORD dwSize );
    HRESULT LoadDIB( const VOID* pData, DWORD dwSize );
    HRESULT LoadTGA( const VOID* pData, DWORD dwSize );
    HRESULT LoadPPM( const VOID* pData, DWORD dwSize );

public:
    HRESULT Load( const VOID* pData, DWORD dwSize );
    HRESULT Load( CHAR* strFilename );

    HRESULT Depalettize();

    CImage();
    ~CImage();
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\xodash\imageConv\cubemap.h ===
//-----------------------------------------------------------------------------
// File: Cubemap.h
//
// Desc: Header file containing class, struct, and constant definitions
//       for the cubemap-related functionality of the bundler tool
//
// Hist: 04.11.01 - New for May XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef CUBEMAP_H
#define CUBEMAP_H

#include "Texture.h"




//-----------------------------------------------------------------------------
// Name: class CCubemap
// Desc: Handles all texture-specific processing, such as loading textures,
//       format conversion, swizzling, etc.
//-----------------------------------------------------------------------------
class CCubemap : public CBaseTexture
{
    LPDIRECT3DSURFACE8 m_pSurfaceXP;
    LPDIRECT3DSURFACE8 m_pSurfaceXN;
    LPDIRECT3DSURFACE8 m_pSurfaceYP;
    LPDIRECT3DSURFACE8 m_pSurfaceYN;
    LPDIRECT3DSURFACE8 m_pSurfaceZP;
    LPDIRECT3DSURFACE8 m_pSurfaceZN;

    HRESULT LoadCubemap();
    HRESULT SaveHeaderInfo( DWORD dwStart, DWORD* pcbHeader );

public:
    char  m_strSourceXP[MAX_PATH];
    char  m_strSourceXN[MAX_PATH];
    char  m_strSourceYP[MAX_PATH];
    char  m_strSourceYN[MAX_PATH];
    char  m_strSourceZP[MAX_PATH];
    char  m_strSourceZN[MAX_PATH];
    char  m_strAlphaSourceXP[MAX_PATH];
    char  m_strAlphaSourceXN[MAX_PATH];
    char  m_strAlphaSourceYP[MAX_PATH];
    char  m_strAlphaSourceYN[MAX_PATH];
    char  m_strAlphaSourceZP[MAX_PATH];
    char  m_strAlphaSourceZN[MAX_PATH];
    DWORD m_dwSize;

    HRESULT SaveToBundle( DWORD* pcbHeader, DWORD* pcbData );

    CCubemap( CBundler* pBundler );
    ~CCubemap();
};


#endif // CUBEMAP_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\xodash\imageConv\imageConv.cpp ===
//-----------------------------------------------------------------------------
// File: imageConv.cpp
//
// Desc: Utility for converting a directory of images to the Xbox Online
//		 Dashboard bundled format.
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include "imageConv.h"
#include "bundler.h"
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

//-----------------------------------------------------------------------------
// Name: CImageConv()
// Desc: Sets initial values of member variables
//-----------------------------------------------------------------------------
CImageConv::CImageConv()
{
    m_strInputDir[0] = m_strOutputDir[0] = 0;
    m_bExplicitOutput = m_bExplicitInput = m_bForceOutput = FALSE;
}

//-----------------------------------------------------------------------------
// Name: ~CImageConv()
// Desc: Performs any needed cleanup before shutting down the object
//-----------------------------------------------------------------------------
CImageConv::~CImageConv()
{
	// Clean up the linked list of image files
    ImageList::iterator i;
	for(i = m_ImageFiles.begin(); i != m_ImageFiles.end(); i++)
	{
		delete *i;
	}

	m_ImageFiles.erase(m_ImageFiles.begin(), m_ImageFiles.end());

}

//-----------------------------------------------------------------------------
// Name: PrintUsage()
// Desc: Prints out the usage string for help
//-----------------------------------------------------------------------------
void CImageConv::PrintUsage()
{
    printf( "USAGE: imageConv [-i <input image directory (required)>]\n" );
    printf( "                 [-o <output bundled image directory (required)>]\n" );
	printf( "                 [-f] force overwrite of destination files\n" );
    printf( "                 [-?]\n");
}

//-----------------------------------------------------------------------------
// Name: Initialize()
// Desc: Parses and validates the command line arguments
//-----------------------------------------------------------------------------
HRESULT CImageConv::Initialize ( int argc, char * argv[] )
{
    for(int n = 1; n < argc; n++)
    {
        // step through each command line parameter
        if((argv[n][0] == '/') || (argv[n][0] == '-'))
        {				
			if(((argv[n][1] == 'i') || (argv[n][1] == 'o')) && ((n+1) == argc))
				return E_INVALIDARG;

            // found an option
            if(lstrcmpi("i", &(argv[n][1])) == 0)
            {
                // Input Directory
                lstrcpyA( m_strInputDir, argv[n+1] );
                m_bExplicitInput = TRUE;
				n++;    // skip two args
            }
            
			else if(lstrcmpi("o", &(argv[n][1])) == 0)
            {
                // Output Directory
                lstrcpyA( m_strOutputDir, argv[n+1] );
                m_bExplicitOutput = TRUE;
				n++;    // skip two args
            }

			else if(lstrcmpi("f", &(argv[n][1])) == 0)
			{
				m_bForceOutput = TRUE;
			}

            else if(lstrcmpi("?", &(argv[n][1])) == 0)
                return E_INVALIDARG;    // causes usage to be displayed
            else
                return E_INVALIDARG;
        }
	}

	if(!m_bExplicitInput || !m_bExplicitOutput)
		return E_INVALIDARG;

	if(ValidateDir( m_strInputDir ) == E_FAIL)
	{
		printf( "ERROR: Input image directory does not exist.\n" );
		return E_FAIL;
	}
	if(ValidateDir( m_strOutputDir ) == E_FAIL)
	{
		if(!CreateDirectory( m_strOutputDir, NULL))
		{
			printf( "ERROR: Unable to create output directory.\n" );
			return E_FAIL;
		}
		printf( "WARNING: Output image directory does not exist, creating...\n" );
	}

    return S_OK;
}

//-----------------------------------------------------------------------------
// Name: ValidateDir()
// Desc: Append a trailing slash if necessary, and ensure the 
//       directory exists
//-----------------------------------------------------------------------------
HRESULT CImageConv::ValidateDir ( char* dir )
{
	WIN32_FIND_DATA FindFileData;
	HANDLE hFind;

	// add a trailing back slash if not present
	if( dir[strlen(dir)] != '\\')
		dir = strcat(dir, "\\");

	// check to see if directory is present
	char searchDir[MAX_PATH];
	strcpy(searchDir, dir);
	strcat(searchDir, "*");
	hFind = FindFirstFile(searchDir, &FindFileData);

	if (hFind == INVALID_HANDLE_VALUE) 
	{
		return E_FAIL;
	} 
	else 
	{
		FindClose(hFind);
	}

	return S_OK;
}


//-----------------------------------------------------------------------------
// Name: FindImages()
// Desc: Traverses the image files from the input directory
//	     and stores them in a linked list
//-----------------------------------------------------------------------------
HRESULT CImageConv::FindImages ( char* extension )
{
	HRESULT			hr;
	WIN32_FIND_DATA FindFileData;  
	HANDLE			hFoundFile;
	char			searchDir[MAX_PATH];
	BOOL			fileResult;

	strcpy(searchDir, m_strInputDir);
	strcat(searchDir, extension);
	hFoundFile = FindFirstFile(searchDir, &FindFileData);

	fileResult = hFoundFile != INVALID_HANDLE_VALUE;
	while (fileResult)
	{
		// Add the first image file to the file list
		CImageItem *newImage = new CImageItem();

		char fullDir[MAX_PATH];
		strcpy(fullDir, m_strInputDir);
		strcat(fullDir, FindFileData.cFileName);
		strcpy(newImage->fullpath, fullDir);
		strcpy(newImage->filename, FindFileData.cFileName);

		// Find out the width, height, and depth of the image
		hr = FillImageInfo(newImage);

		// Is the image valid?
		if(hr == S_OK)
		{
			hr = CheckImageDest(newImage);
			
			// Does the destination image already exist?
			if(hr == S_OK || m_bForceOutput)
			{			
				// Insert the image data for the file into the list
				m_ImageFiles.insert( m_ImageFiles.end(), newImage );
				m_nImageFiles++;
			}
		}

		fileResult = FindNextFile(hFoundFile, &FindFileData);
	}

	FindClose(hFoundFile);

	return S_OK;
}

//-----------------------------------------------------------------------------
// Name: CheckImageDest()
// Desc: Checks to see if the destination image already exists
//-----------------------------------------------------------------------------
HRESULT CImageConv::CheckImageDest ( CImageItem *imageFile )
{
	WIN32_FIND_DATA FindFileData;  
	HANDLE			hFoundFile;
	char			destDir[MAX_PATH];
	char			drive[MAX_PATH];
	char			dir[MAX_PATH];
	char			fname[MAX_PATH];
	char			ext[MAX_PATH];

	_splitpath (imageFile->fullpath, drive, dir, fname, ext);

	// Generate output location, and store the value in the CImageItem
	sprintf(destDir, "%s%s.xbx", m_strOutputDir, fname);
	strcpy(imageFile->outputpath, destDir);

	// Does the destination file already exist?
	hFoundFile = FindFirstFile(imageFile->outputpath, &FindFileData);
	if (hFoundFile == INVALID_HANDLE_VALUE)
	{
		// Destination image file not found
		return S_OK;
	}
	
	return E_FAIL;
}

//-----------------------------------------------------------------------------
// Name: FillImageInfo()
// Desc: Takes in an imageFile data structure, reads out the image file,
//	     and populates the remaining fields of the data structure with
//		 the correct image information (width, height, depth).
//
// Current Support: BMP, TGA
//-----------------------------------------------------------------------------
HRESULT CImageConv::FillImageInfo ( CImageItem *imageFile )
{
	char drive[MAX_PATH];
	char dir[MAX_PATH];
	char fname[MAX_PATH];
	char ext[MAX_PATH];
	_splitpath (imageFile->fullpath, drive, dir, fname, ext);

	FILE * fImage;								// Image file pointer
	fImage = fopen(imageFile->fullpath, "rb");	// Open image For reading

	if(fImage == NULL)					
	{
		fclose(fImage);
		return E_FAIL;	
	}

	if(strcmp(ext, ".tga") == 0)
	{
		// dealing with a Targa file
		TGAHeader tgaInfo;

		if(fread(&tgaInfo, sizeof(TGAHeader), 1, fImage) == 0)
		{
			fclose(fImage);
			return E_FAIL;
		}	

		imageFile->width  = tgaInfo.width;				// Set Height
		imageFile->height = tgaInfo.height;				// Set The Width
		imageFile->depth  = tgaInfo.pixel_depth;		// Set Bits Per Pixel
	}
	else if(strcmp(ext, ".bmp") == 0)
	{
		// dealing with a Bitmap file
		BMPHeader bmpInfo;

		if(fread(&bmpInfo, sizeof(BMPHeader), 1, fImage) == 0)
		{
			fclose(fImage);
			return E_FAIL;
		}

		imageFile->width  = bmpInfo.Width;				// Set Height
		imageFile->height = bmpInfo.Height;				// Set The Width
		imageFile->depth  = bmpInfo.BitCount;			// Set Bits Per Pixel
	}

	// Validate image information
	if((imageFile->width <= 0) || (imageFile->height <= 0) || (imageFile->depth <= 0))
	{
		printf( "ERROR: Image file format is invalid" );
		fclose(fImage);
		return E_FAIL;
	}

	fclose(fImage);

	return S_OK;
}


//-----------------------------------------------------------------------------
// Name: main()
// Desc: Entry point to the program
//-----------------------------------------------------------------------------
int _cdecl main( int argc, char * argv[] )
{
    HRESULT hr;
    CImageConv imgConverter;

    hr = imgConverter.Initialize( argc, argv );
    if(hr == E_INVALIDARG)
    {
        imgConverter.PrintUsage();
        return 0;
    }
    else if(FAILED(hr))
	{
        return 0;
	}

	imgConverter.FindImages( "*.tga" );
	imgConverter.FindImages( "*.bmp" );


	// Bundle Images
	CBundler bundler;
	hr = bundler.Initialize( argc, argv );
    if(FAILED(hr))
    {
        bundler.ErrorMsg( "ERROR: D3D Initialization failed.\n" );
        return 0;
    }

	ImageList::iterator i;
	for(i = imgConverter.m_ImageFiles.begin(); i != imgConverter.m_ImageFiles.end(); i++)
	{
		bundler.HandleTexture( *i );
	}

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\xodash\imageConv\userdata.h ===
//-----------------------------------------------------------------------------
// File: UserData.h
//
// Desc: Header file containing class, struct, and constant definitions
//       for the userdata-related functionality of the bundler tool
//
// Hist: 02.06.01 - New for March XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef USERDATA_H
#define USERDATA_H

#include <windows.h>
#include <d3dx8.h>
#include <xgraphics.h>


class CBundler;


// Xbox-specific defines, taken from d3d8types-xbox.h and d3d8-xbox.h

#define USERDATA_ALIGNMENT     4




//-----------------------------------------------------------------------------
// Name: class CUserData
// Desc: Handles all vb-specific processing
//-----------------------------------------------------------------------------
class CUserData
{
    CBundler* m_pBundler;

    HRESULT SaveHeaderInfo( DWORD dwStart, DWORD* pcbHeader );
    HRESULT SaveUserDataData( DWORD* pcbData );

public:
    HRESULT SaveToBundle( DWORD* pcbHeader, DWORD* pcbData );

    CHAR  m_strSource[MAX_PATH];
    VOID* m_pData;
    DWORD m_dwDataSize;

    CUserData( CBundler* pBundler );
    ~CUserData();
};


#endif // USERDATA_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\xodash\imageConv\LoadImage.cpp ===
//-----------------------------------------------------------------------------
// File: LoadImage.cpp
//
// Desc: Loads image files.
//
// Hist: 04.13.01 - New for May XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <windows.h>
#include <d3d8.h>
#include "LoadImage.h"




//-----------------------------------------------------------------------------
// Name: CImage()
// Desc: Initializes object
//-----------------------------------------------------------------------------
CImage::CImage()
{
    m_Format         = D3DFMT_UNKNOWN;
    m_pData          = NULL;
    m_pPalette       = NULL;
    m_bDeleteData    = FALSE;
    m_bDeletePalette = FALSE;
}




//-----------------------------------------------------------------------------
// Name: ~CImage()
// Desc: Frees resources held by the object
//-----------------------------------------------------------------------------
CImage::~CImage()
{
    if( m_pData && m_bDeleteData )
        delete[] m_pData;

    if( m_pPalette && m_bDeletePalette )
        delete[] m_pPalette;
}




//-----------------------------------------------------------------------------
// Name: Load()
// Desc: Attempts to load the given data as an image
//-----------------------------------------------------------------------------
HRESULT CImage::Load( const VOID* pData, DWORD cbData )
{
    HRESULT hr;

    // Try all known image loading subroutines
    for( int i = 0; i < 4; i++ )
    {
        switch(i)
        {
            case 0: hr = LoadBMP( pData, cbData ); break;
            case 1: hr = LoadPPM( pData, cbData ); break;
            case 2: hr = LoadTGA( pData, cbData ); break;
            case 3: hr = LoadDIB( pData, cbData ); break;
        }

        if( SUCCEEDED(hr) )
            break;

        if( m_pData && m_bDeleteData )
            delete[] m_pData;

        if( m_pPalette && m_bDeletePalette )
            delete[] m_pPalette;

        m_pData          = NULL;
        m_pPalette       = NULL;
        m_bDeleteData    = FALSE;
        m_bDeletePalette = FALSE;
    }

    if( 4 == i )
    {
        DPF(0, "Unsupported file format");
        return D3DXERR_INVALIDDATA;
    }

    m_Rect.left   = 0;
    m_Rect.top    = 0;
    m_Rect.right  = m_Width;
    m_Rect.bottom = m_Height;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Depalettize()
// Desc: Depalettize palettized images
//-----------------------------------------------------------------------------
HRESULT CImage::Depalettize()
{
    if( NULL == m_pPalette )
        return S_OK;

    BYTE*  pSrcData = (BYTE*)m_pData;
    DWORD* pDstData = new DWORD[m_Width*m_Height];

    BYTE*  pOldData = (BYTE*)pSrcData;
    BYTE*  pNewData = (BYTE*)pDstData;

    // Loop through all texels and get 32-bit color from the 8-bit palette index
    for( DWORD y=0; y<m_Height; y++ )
    {
        for( DWORD x=0; x<m_Width; x++ )
        {
            BYTE  index = *pSrcData++;

            DWORD red   = m_pPalette[index].peRed;
            DWORD green = m_pPalette[index].peGreen;
            DWORD blue  = m_pPalette[index].peBlue;
            DWORD alpha = m_pPalette[index].peFlags;

            *pDstData++ = (alpha<<24) | (red<<16) | (green<<8) | (blue<<0);
        }
    }

    // Delete the old palette
    if( m_bDeletePalette )
        delete[] m_pPalette;
    m_pPalette       = NULL;
    m_bDeletePalette = FALSE;

    // Delete the old data, and assign the new data
    if( m_bDeleteData )
        delete[] m_pData;
    m_pData          = pNewData;
    m_bDeleteData    = TRUE;

    // The format is now A8R8G8B8
    m_Format = D3DFMT_A8R8G8B8;
    m_Pitch  = m_Width * sizeof(DWORD);

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Load()
// Desc: Reads the data from the file and tries to load it as an image
//-----------------------------------------------------------------------------
HRESULT CImage::Load( CHAR* strFilename )
{
    HANDLE hFile = CreateFileA( strFilename, GENERIC_READ, FILE_SHARE_READ, NULL, 
                                OPEN_EXISTING, FILE_FLAG_RANDOM_ACCESS, NULL );
    if( INVALID_HANDLE_VALUE == hFile )
        return E_FAIL;

    // Allocate memory
    DWORD dwFileSize = GetFileSize( hFile, NULL );
    VOID* pFileData  = malloc( dwFileSize );

    // Read it the file
    DWORD dwRead;
    ReadFile( hFile, (VOID*)pFileData, dwFileSize, &dwRead, NULL );

    HRESULT hr = Load( pFileData, dwFileSize );

    // Free stuff
    CloseHandle( hFile );
    free( pFileData );

    return hr;
}




//-----------------------------------------------------------------------------
// Name: LoadBMP()
// Desc: Attempts to load the given data as a BMP
//-----------------------------------------------------------------------------
HRESULT CImage::LoadBMP( const VOID* pvData, DWORD cbData )
{
    // Examine header
    if(cbData < sizeof(BITMAPFILEHEADER))
        return E_FAIL;

    BITMAPFILEHEADER *pFH = (BITMAPFILEHEADER *) pvData;

    if(pFH->bfType != (('B') | ('M' << 8)) || pFH->bfSize > cbData)
        return E_FAIL;

    return LoadDIB((BYTE *) pvData + sizeof(BITMAPFILEHEADER), cbData - sizeof(BITMAPFILEHEADER));
}




//-----------------------------------------------------------------------------
// Name: LoadDIB()
// Desc: Attempts to load the given data as a DIB
//-----------------------------------------------------------------------------
HRESULT CImage::LoadDIB( const VOID* pvData, DWORD cbData )
{
    UNALIGNED BITMAPINFOHEADER *pIH;
    DWORD     dwWidth, dwHeight, dwOffset, dwClrUsed;

    if(cbData < sizeof(BITMAPINFOHEADER))
        return E_FAIL;

    pIH = (BITMAPINFOHEADER *) pvData;

    if(pIH->biSize < sizeof(BITMAPINFOHEADER))
        return E_FAIL;

    dwWidth   = (DWORD) (pIH->biWidth);
    dwHeight  = (DWORD) (pIH->biHeight > 0 ? pIH->biHeight : -pIH->biHeight);
    dwClrUsed = (DWORD) (pIH->biClrUsed);

    if((pIH->biBitCount <= 8) && (0 == dwClrUsed))
        dwClrUsed = (DWORD) (1 << pIH->biBitCount);

    dwOffset  = (DWORD) pIH->biSize + dwClrUsed * sizeof(DWORD);

    if(dwOffset > (DWORD) cbData)
        return E_FAIL;

    if(pIH->biPlanes != 1)
        return E_FAIL;


    // Only RGB and BITFIELD bitmaps can be inverted
    if(pIH->biHeight < 0 && pIH->biCompression != BI_RGB && pIH->biCompression != BI_BITFIELDS)
        return E_FAIL;


    // Compute format
    DWORD dwB, dwG, dwR, dwA;
    D3DFORMAT Format = D3DFMT_UNKNOWN;

    switch(pIH->biCompression)
    {
        case BI_RGB:
        case BI_RLE4:
        case BI_RLE8:

            switch(pIH->biBitCount)
            {
                case 1:
                case 4:
                case 8:
                    Format = D3DFMT_P8;
                    break;

                case 16:
                    Format = D3DFMT_X1R5G5B5;
                    break;

                case 24:
#if 0
                    Format = D3DFMT_R8G8B8;
                    break;
#endif
                case 32:
                    Format = D3DFMT_X8R8G8B8;
                    break;

                default:
                    return E_FAIL;
            }
            break;

        case BI_BITFIELDS:
            if(pIH->biSize < sizeof(BITMAPV4HEADER))
                return E_FAIL;

            dwB = ((BITMAPV4HEADER *) pIH)->bV4BlueMask;
            dwG = ((BITMAPV4HEADER *) pIH)->bV4GreenMask;
            dwR = ((BITMAPV4HEADER *) pIH)->bV4RedMask;
            dwA = ((BITMAPV4HEADER *) pIH)->bV4AlphaMask;

            switch(pIH->biBitCount)
            {
                case 16:
                    if(dwB == 0x00ff && dwG == 0x00ff && dwR == 0x00ff && dwA == 0xff00)
                        Format = D3DFMT_A8L8;

                    else if(dwB == 0x001f && dwG == 0x07e0 && dwR == 0xf800 && dwA == 0x0000)
                        Format = D3DFMT_R5G6B5;

                    else if(dwB == 0x001f && dwG == 0x03e0 && dwR == 0x7c00 && dwA == 0x0000)
                        Format = D3DFMT_X1R5G5B5;

                    else if(dwB == 0x001f && dwG == 0x03e0 && dwR == 0x7c00 && dwA == 0x8000)
                        Format = D3DFMT_A1R5G5B5;

                    else if(dwB == 0x000f && dwG == 0x00f0 && dwR == 0x0f00 && dwA == 0xf000)
                        Format = D3DFMT_A4R4G4B4;
        #if 0
                    else if(dwB == 0x0003 && dwG == 0x001c && dwR == 0x00e0 && dwA == 0xff00)
                        Format = D3DFMT_A8R3G3B2;
        #endif
                    break;

                case 24:
                    if(dwB == 0x0000ff && dwG == 0x00ff00 && dwR == 0xff0000 && dwA == 0x000000)
        #if 0                
                        Format = D3DFMT_R8G8B8;
        #else
                        Format = D3DFMT_X8R8G8B8;
        #endif
                    break;

                case 32:
                    if(dwB == 0x000000ff && dwG == 0x0000ff00 && dwR == 0x00ff0000 && dwA == 0x00000000)
                        Format = D3DFMT_X8R8G8B8;

                    else if(dwB == 0x000000ff && dwG == 0x0000ff00 && dwR == 0x00ff0000 && dwA == 0xff000000)
                        Format = D3DFMT_A8R8G8B8;

                    break;
            }

            break;

        default:
            DPF(0, "LoadBMP: JPEG compression not supported");
            return E_NOTIMPL;
    }


    if(D3DFMT_UNKNOWN == Format)
    {
        return E_FAIL;
    }


    if(D3DFMT_P8 == Format)
    {
        DWORD dwClrUsed = pIH->biClrUsed;

        if(!dwClrUsed)
            dwClrUsed = 1 << pIH->biBitCount;

        m_bDeletePalette = TRUE;

        if(!(m_pPalette = new PALETTEENTRY[256]))
            return E_OUTOFMEMORY;

        DWORD dw;
        RGBQUAD* prgb = (RGBQUAD*) (((BYTE *) pIH) + pIH->biSize);

        for(dw = 0; dw < dwClrUsed; dw++, prgb++)
        {
            m_pPalette[dw].peRed   = prgb->rgbRed;
            m_pPalette[dw].peGreen = prgb->rgbGreen;
            m_pPalette[dw].peBlue  = prgb->rgbBlue;
            m_pPalette[dw].peFlags = 0xff;
        }

        for(dw = dwClrUsed; dw < 256; dw++)
        {
            m_pPalette[dw].peRed   = 0xff;
            m_pPalette[dw].peGreen = 0xff;
            m_pPalette[dw].peBlue  = 0xff;
            m_pPalette[dw].peFlags = 0xff;
        }
    }

    DWORD dwWidthBytes;
    DWORD dwSrcInc, dwDstInc;

    switch(pIH->biBitCount)
    {
        case 1:
            dwWidthBytes = dwWidth;
            dwSrcInc = ((dwWidth >> 3) + 3) & ~3;
            break;

        case 4:
            dwWidthBytes = dwWidth;
            dwSrcInc = ((dwWidth >> 1) + 3) & ~3;
            break;

        default:
            dwWidthBytes = (dwWidth * (pIH->biBitCount >> 3));
            dwSrcInc = (dwWidthBytes + 3) & ~3;
            break;
    }

    m_Format  = Format;
    m_Pitch   = (DWORD)((dwWidthBytes + 3) & ~3);
    m_Width   = (DWORD)dwWidth;
    m_Height  = (DWORD)dwHeight;
#if 1
    if (pIH->biBitCount == 24 && Format == D3DFMT_X8R8G8B8)
    {
        UNALIGNED BYTE* pbSrc;
        DWORD*          pdwDst;
        int             nStrideDst;
        UINT            i, j;

        dwWidthBytes = (dwWidth * (32 >> 3));
        m_Pitch      = (DWORD)((dwWidthBytes + 3) & ~3);

        m_bDeleteData = TRUE;

        m_pData = new BYTE[dwHeight * m_Pitch];
        if (!m_pData)
            return E_OUTOFMEMORY;

        pbSrc = ((BYTE*)pvData) + dwOffset;
        if (pIH->biHeight < 0)
        {
            pdwDst = (DWORD*)m_pData;
            nStrideDst = m_Pitch >> 2;
        }
        else
        {
            pdwDst = (DWORD*)((BYTE*)m_pData + m_Pitch * (dwHeight - 1));
            nStrideDst = -(int)(m_Pitch >> 2);
        }

        for (i = 0; i < dwHeight; i++)
        {
            for (j = 0; j < dwWidth; j++)
            {
                pdwDst[j] = pbSrc[2] << 16 | pbSrc[1] << 8 | *pbSrc;
                pbSrc += 3;
            }

            pdwDst += nStrideDst;
        }

        return S_OK;
    }
#endif
    if(pIH->biHeight < 0 && pIH->biBitCount >= 8)
    {
        // The data is in the correct format already in the file.
        m_pData  = new BYTE[dwHeight * m_Pitch];
        memcpy( m_pData, ((BYTE *)pvData) + dwOffset, dwHeight * m_Pitch );
        m_bDeleteData = TRUE;

        return S_OK;
    }

    // Data in file needs to be converted.. so lets allocate the destination
    // buffer which will contain the image..

    m_bDeleteData = TRUE;
    m_pData  = new BYTE[dwHeight * m_Pitch];

    if(!m_pData)
        return E_OUTOFMEMORY;

    UNALIGNED BYTE *pbSrc, *pbDest, *pbDestMin, *pbDestLim, *pbDestLine;

    pbSrc = ((BYTE *) pvData) + dwOffset;

    if(pIH->biHeight < 0)
    {
        dwDstInc = m_Pitch;
        pbDest = (BYTE *) m_pData;
    }
    else
    {
        dwDstInc = 0 - (DWORD)m_Pitch;
        pbDest = (BYTE *) m_pData + (dwHeight - 1) * m_Pitch;
    }

    pbDestLine = pbDest;
    pbDestMin = (BYTE *) m_pData;
    pbDestLim = (BYTE *) m_pData + dwHeight * m_Pitch;



    if(BI_RLE4 == pIH->biCompression)
    {
        // RLE4. Always encoded upsidedown.

        while(pbDest >= pbDestMin)
        {
            if(0 == pbSrc[0])
            {
                switch(pbSrc[1])
                {
                    case 0:
                        D3DXASSERT(pbDest == pbDestLine + dwWidth);
                        pbDestLine -= m_Pitch;
                        pbDest = pbDestLine;
                        break;

                    case 1:
                        pbDest = pbDestMin - m_Pitch;
                        break;

                    case 2:
                        pbDest += pbSrc[2] - pbSrc[3] * m_Pitch;
                        pbSrc += 2;
                        break;

                    default:
                        for(int i = 0; i < pbSrc[1]; i++)
                            pbDest[i] = (i & 1) ?  (pbSrc[2 + (i >> 1)] & 0x0f) : (pbSrc[2 + (i >> 1)] >> 4);

                        pbDest += pbSrc[1];
                        pbSrc += ((pbSrc[1] >> 1) + 1) & ~1;
                        break;
                }
            }
            else
            {
                for(int i = 0; i < pbSrc[0]; i++)
                    pbDest[i] = (i & 1) ? (pbSrc[1] & 0x0f) : (pbSrc[1] >> 4);

                pbDest += pbSrc[0];
            }

            pbSrc += 2;
        }

        return S_OK;
    }

    if(pIH->biCompression == BI_RLE8)
    {
        // RLE8. Always encoded upsidedown.

        while(pbDest >= pbDestMin)
        {
            if(0 == pbSrc[0])
            {
                switch(pbSrc[1])
                {
                    case 0:
                        D3DXASSERT(pbDest == pbDestLine + dwWidth);
                        pbDestLine -= m_Pitch;
                        pbDest = pbDestLine;
                        break;

                    case 1:
                        pbDest = pbDestMin - m_Pitch;
                        break;

                    case 2:
                        pbDest += pbSrc[2] - pbSrc[3] * m_Pitch;
                        pbSrc += 2;
                        break;

                    default:
                        memcpy(pbDest, pbSrc + 2, pbSrc[1]);
                        pbDest += pbSrc[1];
                        pbSrc += (pbSrc[1] + 1) & ~1;
                        break;
                }
            }
            else
            {
                memset(pbDest, pbSrc[1], pbSrc[0]);
                pbDest += pbSrc[0];
            }

            pbSrc += 2;
        }

        return S_OK;
    }


    if(1 == pIH->biBitCount)
    {
        while(pbDest >= pbDestMin && pbDest < pbDestLim)
        {
            for(UINT i = 0; i < dwWidth; i++)
                pbDest[i] = (pbSrc[i >> 3] >> (7 - (i & 7))) & 1;

            pbDest += dwDstInc;
            pbSrc  += dwSrcInc;
        }

        return S_OK;
    }

    if(4 == pIH->biBitCount)
    {
        while(pbDest >= pbDestMin && pbDest < pbDestLim)
        {
            for(UINT i = 0; i < dwWidth; i++)
                pbDest[i] = (i & 1) ? pbSrc[i >> 1] & 0x0f : (pbSrc[i >> 1] >> 4);

            pbDest += dwDstInc;
            pbSrc  += dwSrcInc;
        }

        return S_OK;
    }


    while(pbDest >= pbDestMin && pbDest < pbDestLim)
    {
        memcpy(pbDest, pbSrc, dwWidthBytes);

        pbDest += dwDstInc;
        pbSrc  += dwSrcInc;
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: struct TGAHEADER
// Desc: Defines the header format for TGA files
//-----------------------------------------------------------------------------
#pragma pack(1)
struct TGAHEADER
{
    BYTE IDLength;
    BYTE ColormapType;
    BYTE ImageType;

    WORD wColorMapIndex;
    WORD wColorMapLength;
    BYTE bColorMapBits;

    WORD wXOrigin;
    WORD wYOrigin;
    WORD wWidth;
    WORD wHeight;
    BYTE PixelDepth;
    BYTE ImageDescriptor;
};
#pragma pack()




//-----------------------------------------------------------------------------
// Name: LoadTGA()
// Desc: Attempts to load the given data as a TGA file
//-----------------------------------------------------------------------------
HRESULT CImage::LoadTGA( const VOID* pvData, DWORD cbData )
{
    // Validate header.  TGA files don't seem to have any sort of magic number
    // to identify them.  Therefore, we will proceed as if this is a real TGA
    // file, until we see something we don't understand.

    BYTE*      pbData = (BYTE*)pvData;
    TGAHEADER* pFH    = (TGAHEADER*)pbData;

    if( cbData < sizeof(TGAHEADER) )
        return E_FAIL;

    if( pFH->ColormapType & ~0x01 )
        return E_FAIL;

    if( pFH->ImageType & ~0x0b )
        return E_FAIL;

    if( !pFH->wWidth || !pFH->wHeight )
        return E_FAIL;



    // Colormap size and format
    UINT uColorMapBytes = ((UINT) pFH->bColorMapBits + 7) >> 3;
    D3DFORMAT ColorMapFormat = D3DFMT_UNKNOWN;

    if(pFH->ColormapType)
    {
        switch(pFH->bColorMapBits)
        {
            case 15: ColorMapFormat = D3DFMT_X1R5G5B5; break;
            case 16: ColorMapFormat = D3DFMT_A1R5G5B5; break;
            case 24: ColorMapFormat = D3DFMT_X8R8G8B8; break;
            case 32: ColorMapFormat = D3DFMT_A8R8G8B8; break;
            default: return E_FAIL;
        }
    }


    // Image size and format
    UINT uBytes = ((UINT) pFH->PixelDepth + 7) >> 3;
    D3DFORMAT Format = D3DFMT_UNKNOWN;

    switch(pFH->ImageType & 0x03)
    {
        case 1:
            if(!pFH->ColormapType)
                return E_FAIL;

            switch(pFH->PixelDepth)
            {
                case 8: Format = D3DFMT_P8; break;
                default: return E_FAIL;
            }
            break;

        case 2:
            switch(pFH->PixelDepth)
            {
                case 15: Format = D3DFMT_X1R5G5B5; break;
                case 16: Format = D3DFMT_A1R5G5B5; break;
                case 24: Format = D3DFMT_X8R8G8B8;   break;
                case 32: Format = D3DFMT_A8R8G8B8; break;
                default: return E_FAIL;
            }
            break;

        case 3:
            switch(pFH->PixelDepth)
            {
                case 8: Format = D3DFMT_L8; break;
                default: return E_FAIL;
            }
            break;

        default:
            return E_FAIL;
    }

    BOOL bRLE         = pFH->ImageType & 0x08;
    BOOL bTopToBottom = 0x20 == (pFH->ImageDescriptor & 0x20);
    BOOL bLeftToRight = 0x10 != (pFH->ImageDescriptor & 0x10);

    pbData += sizeof(TGAHEADER);
    cbData -= sizeof(TGAHEADER);


    // Skip ID
    if(cbData < pFH->IDLength)
        return E_FAIL;

    pbData += pFH->IDLength;
    cbData -= pFH->IDLength;


    // Color map
    UINT cbColorMap = (UINT) pFH->wColorMapLength * uColorMapBytes;

    if(cbData < cbColorMap)
        return E_FAIL;

    if(D3DFMT_P8 == Format)
    {
        if(pFH->wColorMapIndex + pFH->wColorMapLength > 256)
            return E_FAIL;

        if(!(m_pPalette = new PALETTEENTRY[256]))
            return E_OUTOFMEMORY;

        m_bDeletePalette = TRUE;
        memset(m_pPalette, 0xff, 256 * sizeof(PALETTEENTRY));

        BYTE *pb = pbData;
        PALETTEENTRY *pColor = m_pPalette + pFH->wColorMapIndex;
        PALETTEENTRY *pColorLim = pColor + pFH->wColorMapLength;

        while(pColor < pColorLim)
        {
            UINT u, uA, uR, uG, uB;

            switch(ColorMapFormat)
            {
                case D3DFMT_X1R5G5B5:
                    u = *((WORD *) pb);

                    uA = 0xff;
                    uR = (u >> 10) & 0x1f;
                    uG = (u >>  5) & 0x1f;
                    uB = (u >>  0) & 0x1f;

                    uR = (uR << 3) | (uR >> 2);
                    uG = (uG << 3) | (uG >> 2);
                    uB = (uB << 3) | (uB >> 2);

                    pb += 2;
                    break;

                case D3DFMT_A1R5G5B5:
                    u = *((WORD *) pb);

                    uA = (u >> 15) * 0xff;
                    uR = (u >> 10) & 0x1f;
                    uG = (u >>  5) & 0x1f;
                    uB = (u >>  0) & 0x1f;

                    uR = (uR << 3) | (uR >> 2);
                    uG = (uG << 3) | (uG >> 2);
                    uB = (uB << 3) | (uB >> 2);

                    pb += 2;
                    break;

                case D3DFMT_X8R8G8B8:
                    uA = 0xff;
                    uR = pb[2];
                    uG = pb[1];
                    uB = pb[0];

                    pb += 3;
                    break;

                case D3DFMT_A8R8G8B8:
                    u = *((DWORD *) pb);

                    uA = (u >> 24) & 0xff;
                    uR = (u >> 16) & 0xff;
                    uG = (u >>  8) & 0xff;
                    uB = (u >>  0) & 0xff;

                    pb += 4;
                    break;
            }
            
            pColor->peRed   = (BYTE) uR;
            pColor->peGreen = (BYTE) uG;
            pColor->peBlue  = (BYTE) uB;
            pColor->peFlags = (BYTE) uA;
        
            pColor++;
        }
    }

    pbData += cbColorMap;
    cbData -= cbColorMap;


    // Image data
    UINT cbImage;
    if(Format == D3DFMT_X8R8G8B8)
        cbImage = (UINT) pFH->wWidth * (UINT) pFH->wHeight * (uBytes+1);
    else
        cbImage = (UINT) pFH->wWidth * (UINT) pFH->wHeight * uBytes;

    m_Format  = Format;
    m_pData   = pbData;
    m_Pitch   = (UINT) pFH->wWidth * uBytes;

    m_Width  = pFH->wWidth;
    m_Height = pFH->wHeight;


    if(!bRLE && bTopToBottom && bLeftToRight )
    {
        // Data is already in a format usable to D3D.. no conversion is necessary
        
        m_pData = new BYTE[cbImage];
        memcpy( m_pData, pbData, min(cbData, cbImage) );
        m_bDeleteData = TRUE;

        pbData += cbImage;
        cbData -= cbImage;
    }
    else
    {
        // Image data is compressed, or does not have origin at top-left
        if(!(m_pData = new BYTE[cbImage]))
            return E_OUTOFMEMORY;

        m_bDeleteData = TRUE;


        BYTE *pbDestY = bTopToBottom ? (BYTE *) m_pData : ((BYTE *) m_pData + (pFH->wHeight - 1) * m_Pitch);

        for(UINT uY = 0; uY < pFH->wHeight; uY++)
        {
            BYTE *pbDestX = bLeftToRight ? pbDestY : (pbDestY + m_Pitch - uBytes);

            for(UINT uX = 0; uX < pFH->wWidth; )
            {
                BOOL bRunLength;
                UINT uCount;

                if(bRLE)
                {
                    if(cbData < 1)
                        return E_FAIL;

                    bRunLength = *pbData & 0x80;
                    uCount = (*pbData & 0x7f) + 1;

                    pbData++;
                    cbData--;
                }
                else
                {
                    bRunLength = FALSE;
                    uCount = pFH->wWidth;
                }

                uX += uCount;

                while(uCount--)
                {
                    if(cbData < uBytes)
                        return E_FAIL;

                    memcpy(pbDestX, pbData, uBytes);

                    if(!bRunLength)
                    {
                        pbData += uBytes;
                        cbData -= uBytes;
                    }

                    pbDestX = bLeftToRight ? (pbDestX + uBytes) : (pbDestX - uBytes);
                }

                if(bRunLength)
                {
                    pbData += uBytes;
                    cbData -= uBytes;
                }
            }

            pbDestY = bTopToBottom ? (pbDestY + m_Pitch) : (pbDestY - m_Pitch);
        }
    }

    if(Format == D3DFMT_X8R8G8B8)
    {
        //convert from 24-bit R8G8B8 to 32-bit X8R8G8B8
        // do the conversion in-place
        BYTE *pSrc, *pDst;
        pSrc = (BYTE *)m_pData + (m_Height)*(m_Width*uBytes) - uBytes;
        pDst = (BYTE *)m_pData + (m_Height)*(m_Width*(uBytes+1)) - (uBytes+1);
            
        while(pSrc >= m_pData)
        {
            *(pDst+3) = 0xff;       //A
            *(pDst+2) = *(pSrc+2);  //R
            *(pDst+1) = *(pSrc+1);  //G
            *(pDst+0) = *pSrc;      //B
            pSrc -= 3;
            pDst -= 4;
        }
        m_Pitch   = m_Width * (uBytes+1);
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Anonymous enum
// Desc: Enumerations used for loading PPM files
//-----------------------------------------------------------------------------
enum
{
    PPM_WIDTH, PPM_HEIGHT, PPM_MAX, PPM_DATA_R, PPM_DATA_G, PPM_DATA_B
};




//-----------------------------------------------------------------------------
// Name: LoadPPM()
// Desc: Attempts to load the given data as a PPM file
//-----------------------------------------------------------------------------
HRESULT CImage::LoadPPM( const VOID* pvData, DWORD cbData )
{
    BYTE *pbData = (BYTE *)pvData;

    // Check header
    BOOL bAscii;

    if(cbData < 2)
        return E_FAIL;

    if('P' == pbData[0] && '3' == pbData[1])
        bAscii = TRUE;
    else if('P' == pbData[0] && '6' == pbData[1])
        bAscii = FALSE;
    else
        return E_FAIL;

    pbData += 2;
    cbData -= 2;

    // Image data
    UINT uMode   = PPM_WIDTH;
    UINT uWidth  = 0;
    UINT uHeight = 0;
    UINT uMax    = 255;

    DWORD *pdw, *pdwLim;

    while(cbData)
    {
        if(!bAscii && PPM_DATA_R == uMode)
        {
            // Binary image data
            if(uMax > 255)
                return E_FAIL;

            if(cbData > 1 && '\r' == *pbData)
            {
                pbData++;
                cbData--;
            }

            pbData++;
            cbData--;

            while(cbData && pdw < pdwLim)
            {
                *pdw++ = ((255 * pbData[0] / uMax) << 16) |
                         ((255 * pbData[1] / uMax) <<  8) |
                         ((255 * pbData[2] / uMax) <<  0) | 0xff000000;

                pbData += 3;
                cbData -= 3;
            }

            if(pdw != pdwLim)
                return E_FAIL;

            return S_OK;
        }
        if(isspace(*pbData))
        {
            // Whitespace
            pbData++;
            cbData--;
        }
        else if('#' == *pbData)
        {
            // Comment
            while(cbData && '\n' != *pbData)
            {
                pbData++;
                cbData--;
            }

            pbData++;
            cbData--;
        }
        else
        {
            // Number
            UINT u = 0;

            while(cbData && !isspace(*pbData))
            {
                if(!isdigit(*pbData))
                    return E_FAIL;

                u = u * 10 + (*pbData - '0');

                pbData++;
                cbData--;
            }

            switch(uMode)
            {
                case PPM_WIDTH:
                    uWidth = u;

                    if(0 == uWidth)
                        return E_FAIL;

                    break;

                case PPM_HEIGHT:
                    uHeight = u;

                    if(0 == uHeight)
                        return E_FAIL;

                    if(!(m_pData = new BYTE[uWidth * uHeight * sizeof(DWORD)]))
                        return E_OUTOFMEMORY;

                    m_bDeleteData = TRUE;

                    pdw = (DWORD *) m_pData;
                    pdwLim = pdw + uWidth * uHeight;

                    m_Format = D3DFMT_X8R8G8B8;
                    m_Pitch  = uWidth * sizeof(DWORD);

                    m_Width  = uWidth;
                    m_Height = uHeight;
                    break;

                case PPM_MAX:
                    uMax = u;

                    if(0 == uMax)
                        return E_FAIL;

                    break;

                case PPM_DATA_R:
                    if(pdw >= pdwLim)
                        return E_FAIL;

                    *pdw  = ((u * 255 / uMax) << 16) | 0xff000000;
                    break;

                case PPM_DATA_G:
                    *pdw |= ((u * 255 / uMax) <<  8);
                    break;

                case PPM_DATA_B:
                    *pdw |= ((u * 255 / uMax) <<  0);

                    if(++pdw == pdwLim)
                        return S_OK;

                    uMode = PPM_DATA_R - 1;
                    break;
            }

            uMode++;
        }
    }

    return E_FAIL;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\xodash\imageConv\texture.cpp ===
//-----------------------------------------------------------------------------
// File: Texture.cpp
//
// Desc: Contains the texture-specific logic for the bundler tool
//
// Hist: 02.06.01 - New for March XDK release
//       04.13.01 - Reorganized for May XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <stdio.h>
#include "Texture.h"
#include "Bundler.h"
#include "LoadImage.h"




//-----------------------------------------------------------------------------
// Name: CTexture2D()
// Desc: Initializes member variables
//-----------------------------------------------------------------------------
CTexture2D::CTexture2D( CBundler* pBundler )
           :CBaseTexture( pBundler )
{
    m_strSource[0]      = 0;
    m_strAlphaSource[0] = 0;
    m_pSurface         = NULL;
    m_dwWidth          = 0;
    m_dwHeight         = 0;
}




//-----------------------------------------------------------------------------
// Name: ~CTexture2D()
// Desc: Performs any cleanup needed before the object is destroyed
//-----------------------------------------------------------------------------
CTexture2D::~CTexture2D()
{
    if( m_pSurface )
        m_pSurface->Release();
}




//-----------------------------------------------------------------------------
// Name: SaveToBundle()
// Desc: Handles saving the appropriate data to the packed resource file
//-----------------------------------------------------------------------------
HRESULT CTexture2D::SaveToBundle( DWORD* pcbHeader, DWORD* pcbData )
{
    HRESULT hr;

    // Load the texture from disk, and set default values from it
    hr = LoadTexture();
    if( FAILED( hr ) )
        return hr;

    // Pad data file to proper alignment for the start of the texture
    hr = m_pBundler->PadToAlignment( D3DTEXTURE_ALIGNMENT );
    if( FAILED( hr ) )
        return hr;

    // Save resource header
    hr = SaveHeaderInfo( m_pBundler->m_cbData, pcbHeader );
    if( FAILED( hr ) )
        return hr;

    // Save texture data
    (*pcbData) = 0;
    SaveSurface( pcbData, m_dwLevels, m_pSurface );
     
    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: LoadTexture()
// Desc: Loads the texture from the file, and sets any properties that were
//       not specified with values from the file (width, height, format, etc)
//-----------------------------------------------------------------------------
HRESULT CTexture2D::LoadTexture()
{
    D3DSURFACE_DESC desc;
    HRESULT hr;

    // Load the imagesurfaces from the file (using default width, height, and a
    // A8R8G8B8 surface format)
    hr = LoadSurface( m_strSource, m_strAlphaSource, &m_pSurface );
    if( FAILED( hr ) )
    {
        // If the conventional load methods failed, we can try using D3DX as a
        // last ditch effort. This will load DDS files, JPGs, etc., but has
        // limitations like only pow-2 dimensions.

        hr = LoadSurfaceUsingD3DX( m_strSource, m_strAlphaSource, &m_pSurface );
        if( FAILED( hr ) )
        {
            if( m_strAlphaSource[0] )
                m_pBundler->ErrorMsg( "Texture: Couldn't load source file <%s> or <%s>\n", m_strSource, m_strAlphaSource );
            else
                m_pBundler->ErrorMsg( "Texture: Couldn't load source file <%s>\n", m_strSource );
            return hr;
        }
    }

    // Try to look up our format string
    if( m_strFormat[0] )
    {
        m_nFormat = FormatFromString( m_strFormat );
        if( m_nFormat < -1 )
        {
            m_pBundler->ErrorMsg( "Error: Invalid texture format: %s", m_strFormat );
            return E_FAIL;
        }
    }

    // If the format is still not determined, resort to A8R8G8B8
    if( m_nFormat < 0 )
    {
        lstrcpyA( m_strFormat, "D3DFMT_A8R8G8B8" );
        m_nFormat = FormatFromString( m_strFormat );
    }

    // Determine final width and height
    if( m_dwWidth==0 || m_dwHeight==0 )
    {
        hr = m_pSurface->GetDesc( &desc );

        if( g_TextureFormats[m_nFormat].Type == FMT_LINEAR )
        {
            // Linear textures can have any size
            m_dwWidth  = desc.Width;
            m_dwHeight = desc.Height;
        }
        else
        {
            // Enforce power-of-two dimensions for swizzled and compressed textures
            for( m_dwWidth=1;  m_dwWidth  < desc.Width;  m_dwWidth<<=1 );
            for( m_dwHeight=1; m_dwHeight < desc.Height; m_dwHeight<<=1 );
        }
    }

    // Determine final number of miplevels
    if( g_TextureFormats[m_nFormat].Type == FMT_LINEAR )
    {
        m_dwLevels = 1;
    }
    else
    {
        // Count levels
        DWORD dwLevels = 1; 
        while( ( (1UL<<(dwLevels-1)) < m_dwWidth ) && ( (1UL<<(dwLevels-1))<m_dwHeight ) )
            dwLevels++;
            
        if( m_dwLevels < 1 || m_dwLevels > dwLevels )
            m_dwLevels = dwLevels;
    }

    // Change the size of the surface
    hr = ResizeSurface( m_dwWidth, m_dwHeight, &m_pSurface );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: SaveHeaderInfo()
// Desc: Saves the appropriate data to the header file
//-----------------------------------------------------------------------------
HRESULT CTexture2D::SaveHeaderInfo( DWORD dwStart, DWORD * pcbHeader )
{
    D3DTexture d3dtex;

    XGSetTextureHeader(m_dwWidth, m_dwHeight, m_dwLevels, 0,
                       (D3DFORMAT)g_TextureFormats[m_nFormat].dwXboxFormat,
                       D3DPOOL_DEFAULT, (IDirect3DTexture8*)&d3dtex,
                       dwStart, 0);

    // Write the resource header out
    if( FAILED( m_pBundler->WriteHeader( &d3dtex, sizeof( d3dtex ) ) ) )
        return E_FAIL;

    *pcbHeader = sizeof( d3dtex );

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\xodash\imageConv\texture.h ===
//-----------------------------------------------------------------------------
// File: Texture.h
//
// Desc: Header file containing class definition for the 2d texture-related 
//       functionality of the bundler tool
//
// Hist: 02.06.01 - New for March XDK release
//       04.13.01 - Reorganized for May XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef TEXTURE_H
#define TEXTURE_H

#include "BaseTexture.h"




//-----------------------------------------------------------------------------
// Name: class CTexture2D
// Desc: Handles all texture-specific processing, such as loading textures,
//       format conversion, swizzling, etc.
//-----------------------------------------------------------------------------
class CTexture2D : public CBaseTexture
{
public:
    CTexture2D( CBundler* pBundler );
    ~CTexture2D();

    HRESULT SaveToBundle( DWORD* pcbHeader, DWORD* pcbData );

    CHAR  m_strSource[MAX_PATH];
    CHAR  m_strAlphaSource[MAX_PATH];
    DWORD m_dwWidth;
    DWORD m_dwHeight;

protected:
    HRESULT LoadTexture();
    HRESULT SaveHeaderInfo( DWORD dwStart, DWORD* pcbHeader );

    LPDIRECT3DSURFACE8 m_pSurface;
};


#endif // TEXTURE_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\xodash\imageConv\userdata.cpp ===
//-----------------------------------------------------------------------------
// File: UserData.cpp
//
// Desc: Contains the userdata-specific logic for the bundler tool
//
// Hist: 02.06.01 - New for March XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include "UserData.h"
#include "Bundler.h"
#include <stdio.h>




//-----------------------------------------------------------------------------
// Name: CUserData()
// Desc: Initializes member variables
//-----------------------------------------------------------------------------
CUserData::CUserData( CBundler* pBundler )
{
    m_pBundler     = pBundler;
    m_strSource[0] = '\0';
    m_pData        = NULL;
    m_dwDataSize   = 0;
}




//-----------------------------------------------------------------------------
// Name: ~CUserData()
// Desc: Performs any cleanup needed before the object is destroyed
//-----------------------------------------------------------------------------
CUserData::~CUserData()
{
    if( m_pData )
        delete[] m_pData;
}




//-----------------------------------------------------------------------------
// Name: SaveToBundle()
// Desc: Handles saving the appropriate data to the packed resource file
//-----------------------------------------------------------------------------
HRESULT CUserData::SaveToBundle( DWORD* pcbHeader, DWORD* pcbData )
{
    HRESULT hr;

    if( 0 == m_strSource[0] )
    {
        m_pBundler->ErrorMsg( "Error: No source specified\n" );
        return E_FAIL;
    }

    // Add the path (if necessary) to the source filename
    CHAR strUserDataFilePath[MAX_PATH];
    if( strchr( m_strSource, ':' ) )
        strcpy( strUserDataFilePath, m_strSource );
    else
    {
        strcpy( strUserDataFilePath, m_pBundler->m_strPath );
        strcat( strUserDataFilePath, m_strSource );
    }

    HANDLE hFile = CreateFileA( strUserDataFilePath, GENERIC_READ, FILE_SHARE_READ,
                                NULL, OPEN_EXISTING, FILE_FLAG_RANDOM_ACCESS, NULL );
    if( INVALID_HANDLE_VALUE == hFile )
    {
        m_pBundler->ErrorMsg( "Error: Could not find userdata source: %s\n", m_strSource );
        return E_FAIL;
    }

    // Allocate memory
    m_dwDataSize = GetFileSize( hFile, NULL );
    m_pData      = new BYTE[8+m_dwDataSize];

    ((DWORD*)m_pData)[0] = 0x80000000;
    ((DWORD*)m_pData)[1] = m_dwDataSize;

    // Read the file
    DWORD dwRead;
    ReadFile( hFile, (BYTE*)m_pData+8, m_dwDataSize, &dwRead, NULL );
    CloseHandle( hFile );

    // Pad data file to proper alignment for the start of the userdata
    hr = m_pBundler->PadToAlignment( USERDATA_ALIGNMENT );
    if( FAILED( hr ) )
        return hr;

    // Save resource header
    hr = SaveHeaderInfo( m_pBundler->m_cbData, pcbHeader );
    if( FAILED( hr ) )
        return hr;

    // Save userdata data
    hr = SaveUserDataData( pcbData );
    if( FAILED( hr ) )
        return hr;
     
    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: SaveHeaderInfo()
// Desc: Saves the appropriate data to the header file
//-----------------------------------------------------------------------------
HRESULT CUserData::SaveHeaderInfo( DWORD dwStart, DWORD * pcbHeader )
{
/*
    DWORD dwUserDataID = 0x8000000;

    // Write the userdata tag to the resource header
    if( FAILED( m_pBundler->WriteHeader( &dwUserDataID, sizeof(DWORD) ) ) )
        return E_FAIL;

    // Write the userdata size to the resource header
    if( FAILED( m_pBundler->WriteHeader( &m_dwDataSize, sizeof(DWORD) ) ) )
        return E_FAIL;

    // Write the resource header out
    if( FAILED( m_pBundler->WriteHeader( m_pData, m_dwDataSize ) ) )
        return E_FAIL;
*/
    // Write the resource header out
    if( FAILED( m_pBundler->WriteHeader( m_pData, m_dwDataSize+8 ) ) )
        return E_FAIL;

    (*pcbHeader) = m_dwDataSize+8;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: SaveUserDataData()
// Desc: Saves the raw UserData data to the XPR file
//-----------------------------------------------------------------------------
HRESULT CUserData::SaveUserDataData( DWORD* pcbData )
{
    // There shouldn't be any video memory data to write
    (*pcbData) = 0;

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\xodash\imageConv\token.cpp ===
//-----------------------------------------------------------------------------
// File: Token.cpp
//
// Desc: Contains the logic for extracting tokens from the resource
//       description file
//
// Hist: 02.06.01 - New for March XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include "Bundler.h"
#include <stdio.h>


// Token defintions
const BUNDLERTOKEN g_Tokens[] =
{
    // Token string         token enumeration                   type            handler function
    { "",                   TOKEN_RESOURCE_EOF,                 TT_ANY,         CBundler::HandleEOFToken        },
    { "{",                  TOKEN_RESOURCE_OPENBRACE,           TT_ANY,         NULL                            },
    { "}",                  TOKEN_RESOURCE_CLOSEBRACE,          TT_ANY,         NULL                            },
    { "out_packedresource", TOKEN_RESOURCE_OUT_PACKEDRESOURCE,  TT_ANY,         CBundler::HandleOutPackedResourceToken      },
    { "out_header",         TOKEN_RESOURCE_OUT_HEADER,          TT_ANY,         CBundler::HandleOutHeaderToken  },
    { "out_prefix",         TOKEN_RESOURCE_OUT_PREFIX,          TT_ANY,         CBundler::HandleOutPrefixToken  },
    { "out_error",          TOKEN_RESOURCE_OUT_ERROR,           TT_ANY,         CBundler::HandleOutErrorToken   },

    { "Texture",            TOKEN_RESOURCE_TEXTURE,             TT_ANY,         CBundler::HandleTextureToken    },
    { "Source",             TOKEN_PROPERTY_TEXTURE_SOURCE,      TT_FILENAME,    NULL                            },
    { "AlphaSource",        TOKEN_PROPERTY_TEXTURE_ALPHASOURCE, TT_FILENAME,    NULL                            },
    { "Filter",             TOKEN_PROPERTY_TEXTURE_FILTER,      TT_ANY,         NULL                            },
    { "Format",             TOKEN_PROPERTY_TEXTURE_FORMAT,      TT_IDENTIFIER,  NULL                            },
    { "Width",              TOKEN_PROPERTY_TEXTURE_WIDTH,       TT_INTEGER,     NULL                            },
    { "Height",             TOKEN_PROPERTY_TEXTURE_HEIGHT,      TT_INTEGER,     NULL                            },
    { "Levels",             TOKEN_PROPERTY_TEXTURE_LEVELS,      TT_INTEGER,     NULL                            },
    
    { "Cubemap",            TOKEN_RESOURCE_CUBEMAP,                TT_ANY,         CBundler::HandleCubemapToken    },
    { "SourceXP",           TOKEN_PROPERTY_CUBEMAP_SOURCE_XP,      TT_FILENAME,    NULL                            },
    { "SourceXN",           TOKEN_PROPERTY_CUBEMAP_SOURCE_XN,      TT_FILENAME,    NULL                            },
    { "SourceYP",           TOKEN_PROPERTY_CUBEMAP_SOURCE_YP,      TT_FILENAME,    NULL                            },
    { "SourceYN",           TOKEN_PROPERTY_CUBEMAP_SOURCE_YN,      TT_FILENAME,    NULL                            },
    { "SourceZP",           TOKEN_PROPERTY_CUBEMAP_SOURCE_ZP,      TT_FILENAME,    NULL                            },
    { "SourceZN",           TOKEN_PROPERTY_CUBEMAP_SOURCE_ZN,      TT_FILENAME,    NULL                            },
    { "AlphaSourceXP",      TOKEN_PROPERTY_CUBEMAP_ALPHASOURCE_XP, TT_FILENAME,    NULL                            },
    { "AlphaSourceXN",      TOKEN_PROPERTY_CUBEMAP_ALPHASOURCE_XN, TT_FILENAME,    NULL                            },
    { "AlphaSourceYP",      TOKEN_PROPERTY_CUBEMAP_ALPHASOURCE_YP, TT_FILENAME,    NULL                            },
    { "AlphaSourceYN",      TOKEN_PROPERTY_CUBEMAP_ALPHASOURCE_YN, TT_FILENAME,    NULL                            },
    { "AlphaSourceZP",      TOKEN_PROPERTY_CUBEMAP_ALPHASOURCE_ZP, TT_FILENAME,    NULL                            },
    { "AlphaSourceZN",      TOKEN_PROPERTY_CUBEMAP_ALPHASOURCE_ZN, TT_FILENAME,    NULL                            },
    { "Size",               TOKEN_PROPERTY_CUBEMAP_SIZE,           TT_INTEGER,     NULL                            },

    { "VolumeTexture",      TOKEN_RESOURCE_VOLUMETEXTURE,             TT_ANY,         CBundler::HandleVolumeTextureToken    },
//    { "Source",             TOKEN_PROPERTY_VOLUMETEXTURE_SOURCE,      TT_FILENAME,    NULL                            },
//    { "AlphaSource",        TOKEN_PROPERTY_VOLUMETEXTURE_ALPHASOURCE, TT_FILENAME,    NULL                            },
    { "Depth",              TOKEN_PROPERTY_VOLUMETEXTURE_DEPTH,       TT_INTEGER,     NULL                            },

    { "VertexBuffer",       TOKEN_RESOURCE_VERTEXBUFFER,        TT_ANY,         CBundler::HandleVertexBufferToken},
    { "VertexData",         TOKEN_PROPERTY_VB_VERTEXDATA,       TT_ANY,         NULL                            },
    { "VertexFormat",       TOKEN_PROPERTY_VB_VERTEXFORMAT,     TT_ANY,         NULL                            },

    { "UserData",           TOKEN_RESOURCE_USERDATA,            TT_ANY,         CBundler::HandleUserDataToken},
    { "DataFile",           TOKEN_PROPERTY_USERDATA_DATAFILE,   TT_ANY,         NULL },
};




//-----------------------------------------------------------------------------
// Name: IsAlphaChar()
// Desc: TRUE for [a-zA-Z]
//-----------------------------------------------------------------------------
BOOL IsAlphaChar( char ch )
{
    return( ( ( ch >= 'a' ) && ( ch <= 'z' ) )  ||
            ( ( ch >= 'A' ) && ( ch <= 'Z' ) ) );
}




//-----------------------------------------------------------------------------
// Name: IsNumberChar()
// Desc: TRUE for [0-9]
//-----------------------------------------------------------------------------
BOOL IsNumberChar( char ch )
{
    return( ( ch >= '0' ) && ( ch <= '9' ) );
}




//-----------------------------------------------------------------------------
// Name: IsIdentifierChar()
// Desc: TRUE for [a-zA-Z0-9_]
//-----------------------------------------------------------------------------
BOOL IsIdentifierChar( char ch )
{
    return( IsAlphaChar( ch )  ||
            IsNumberChar( ch ) ||
            ch == '_' );
}




//-----------------------------------------------------------------------------
// Name: IsHexChar()
// Desc: TRUE for [a-fA-F0-9]
//-----------------------------------------------------------------------------
BOOL IsHexChar( char ch )
{
    return( ( ( ch >= 'a' ) && ( ch <= 'f' ) )  ||
            ( ( ch >= 'A' ) && ( ch <= 'F' ) )  ||
            IsNumberChar( ch ) );
}
            



//-----------------------------------------------------------------------------
// Name: IsWhiteSpaceChar()
// Desc: TRUE for [ \t\r\n]
//-----------------------------------------------------------------------------
BOOL IsWhiteSpaceChar( char ch )
{
    return( ( ch == ' '  ) ||
            ( ch == '\t' ) ||
            ( ch == '\r' ) ||
            ( ch == '\n' ) ||
            ( ch == ','  ) );   // commas are whitespace for this parser
}




//-----------------------------------------------------------------------------
// Name: TerminatesToken()
// Desc: True if next char starts new token or breaks between token
//-----------------------------------------------------------------------------
BOOL TerminatesToken( char ch )
{
    if(IsWhiteSpaceChar( ch )) return TRUE;
    if((ch == '{') ||
       (ch == '}') ||
       (ch == TOKEOF)) return TRUE;

    return FALSE;
}




//-----------------------------------------------------------------------------
// Name: IsFilenameChar()
// Desc: TRUE for [^\[\]\:\\/<>\=;,\t\r\n ]
//-----------------------------------------------------------------------------
BOOL IsFilenameChar( char ch )
{
    return( ch != '[' &&
            ch != ']' &&
            ch != ':' &&
            ch != '\\' &&
            ch != '/' &&
            ch != '<' &&
            ch != '>' &&
            ch != '=' &&
            ch != ';' &&
            ch != ',' &&
            ch != '\t' &&
            ch != '\r' &&
            ch != '\n' );
}




//-----------------------------------------------------------------------------
// Name: GetChar()
// Desc: Gets the next character from the input file, removed comments
//-----------------------------------------------------------------------------
CHAR CBundler::GetChar()
{
    DWORD cb;
    CHAR tmp = m_cNext0;
    m_cNext0 = m_cNext1;
    m_cNext1 = m_cNext2;
    m_cNext2 = m_cNext3;
    ReadFile( m_hfRDF, &m_cNext3, 1, &cb, NULL );
    if(cb == 0)
        m_cNext3 = TOKEOF;

    if((m_cNext0 == (CHAR)0xff) && (m_cNext1 == (CHAR)0xfe))
    {
        ErrorMsg( "Error: Unicode files are not supported\n");
        return TOKEOF;
    }
    
    while(TRUE)
    {
        // check for // comment
        if((m_cNext2 == '/') && (m_cNext3 == '/'))
        {
            // skip until \n for eof
            while((m_cNext2 != '\n') && (m_cNext2 != TOKEOF))
            {
                m_cNext2 = m_cNext3;
                ReadFile( m_hfRDF, &m_cNext3, 1, &cb, NULL );
                if(cb == 0)
                    m_cNext3 = TOKEOF;
            }
        }
        // check for /* comment
        if((m_cNext2 == '/') && (m_cNext3 == '*'))
        {
            // skip until */ or eof
            while(!(((m_cNext2 == '*') && (m_cNext3 == '/')) || (m_cNext2 == TOKEOF)))
            {
                m_cNext2 = m_cNext3;
                ReadFile( m_hfRDF, &m_cNext3, 1, &cb, NULL );
                if(cb == 0)
                    m_cNext3 = TOKEOF;
            }
            ReadFile( m_hfRDF, &m_cNext2, 1, &cb, NULL );
            if(cb == 0)
                m_cNext2 = TOKEOF;
            ReadFile( m_hfRDF, &m_cNext3, 1, &cb, NULL );
            if(cb == 0)
                m_cNext3 = TOKEOF;
        }
        return tmp;
    }
}




//-----------------------------------------------------------------------------
// Name: PeekChar()
// Desc: Gets the next character from the input file without advancing the read
//       pointer.
//-----------------------------------------------------------------------------
CHAR CBundler::PeekChar()
{
    return m_cNext0;
}




//-----------------------------------------------------------------------------
// Name: GetNextTokenString()
// Desc: Gets the next token from the resource definition file.  
//-----------------------------------------------------------------------------
HRESULT CBundler::GetNextTokenString( char *strTokenString, TOKENTYPE tt )
{
    CHAR *cPtr = strTokenString;
    CHAR c;

    // skip whitespace
    while(IsWhiteSpaceChar(c=GetChar()));
    
    if(c == TOKEOF)
        return S_OK;        // eof

    *cPtr++ = c;

    if((c == '{') ||
       (c == '}'))
        return S_OK;        // single character tokens
    
    while(!TerminatesToken(PeekChar()))
        *cPtr++ = GetChar();

    *cPtr++ = '\0';     // terminate the string

    // Check that it's an appropriate type
    if( FAILED( ValidateType( strTokenString, tt ) ) )
        return E_FAIL;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: ValidateIdentifier()
// Desc: Verifies that the token is in the proper form for an identifier:
// ([A-za-z]+[A-Za-z0-9_]*)
//-----------------------------------------------------------------------------
static BOOL ValidateIdentifier( char* strToken )
{
    int i;

    if( !IsAlphaChar( strToken[0] ) )
        return FALSE;

    for( i = 1; strToken[i] != 0; i++ )
    {
        if( !IsIdentifierChar( strToken[i] ) )
            return FALSE;
    }

    return TRUE;
}




//-----------------------------------------------------------------------------
// Name: ValidateHexNumber()
// Desc: Verifies that the token is in the proper form for a hex number:
// (0[x|X][0-9A-Fa-f]+)
//-----------------------------------------------------------------------------
static BOOL ValidateHexNumber( char* strToken )
{
    int i;

    if( strToken[0] != '0' )
        return FALSE;
    if( strToken[1] != 'x' &&
        strToken[1] != 'X' )
        return FALSE;
    
    for( i = 2; strToken[i] != 0; i++ )
    {
        if( !IsHexChar( strToken[i] ) )
            return FALSE;
    }

    return TRUE;
}




//-----------------------------------------------------------------------------
// Name: ValidateInteger()
// Desc: Verifies that the token is in the proper form for a integer:
// ([-|][0-9]+)
//-----------------------------------------------------------------------------
static BOOL ValidateInteger( char* strToken )
{
    int i = 0;

    if( strToken[0] == '-' )
        i++;

    for( ; strToken[i] != 0; i++ )
    {
        if( !IsNumberChar( strToken[i] ) )
            return FALSE;
    }

    return TRUE;
}




//-----------------------------------------------------------------------------
// Name: ValidateFloat()
// Desc: Verifies that the token is in the proper form for a float:
// [-|](([0-9]+(\.[0-9]+|)|\.[0-9]+)([Ee](\+|-|)[0-9]+|))
//-----------------------------------------------------------------------------
static BOOL ValidateFloat( char* strToken )
{
    int i = 0;
    BOOL bDecimal = FALSE;
    BOOL bExponent = FALSE;
    
    if( strToken[0] == '-' )
        i++;

    for( ; strToken[i] != 0; i++ )
    {
        if( strToken[i] == '.' )
        {
            if( bDecimal )
                return FALSE;
            bDecimal = TRUE;
        }
        else if( strToken[i] == 'e' ||
                 strToken[i] == 'E' )
        {
            if( bExponent )
                return FALSE;

            bDecimal = bExponent = TRUE;
            if( strToken[i + 1] == '+' ||
                strToken[i + 1] == '-' )
                i++;
        }
        else if( !IsNumberChar( strToken[i] ) )
            return FALSE;
    }

    return TRUE;
}




//-----------------------------------------------------------------------------
// Name: ValidateFilename()
// Desc: Verifies that the token is in the proper form for a filename:
// (([A-Za-z]:|)(\\|/)(\:f(\\|/))*\:f)  where :f is a sequence of filename chars
//-----------------------------------------------------------------------------
static BOOL ValidateFilename( char* strToken )
{
    int i = 0;
    BOOL bLastWasSlash = FALSE;

    if( IsAlphaChar( strToken[0] ) &&
        strToken[1] == ':' )
    {
        i = 2;
    }

    for( ; strToken[i] != 0; i++ )
    {
        if( strToken[i] == '\\' ||
            strToken[i] == '/' )
        {
            bLastWasSlash = TRUE;
            continue;
        }

        if( !IsFilenameChar( strToken[i] ) )
            return FALSE;

        bLastWasSlash = FALSE;
    }

    return !bLastWasSlash;
}




//-----------------------------------------------------------------------------
// Name: ValidateType()
// Desc: Checks to see if the token is of the appropriate type.  If not, 
//       outputs an error message
//-----------------------------------------------------------------------------
HRESULT CBundler::ValidateType( char* strToken, TOKENTYPE tt )
{
    BOOL bValid;

    switch( tt )
    {
		case TT_ANY:
			bValid = TRUE;
			break;
		case TT_IDENTIFIER:
			bValid = ValidateIdentifier( strToken );
			break;
		case TT_HEXNUMBER:
			bValid = ValidateHexNumber( strToken );
			break;
		case TT_INTEGER:
			bValid = ValidateInteger( strToken );
			break;
		case TT_FLOAT:
			bValid = ValidateFloat( strToken );
			break;
		case TT_FILENAME:
			bValid = ValidateFilename( strToken );
			break;
    }

    if( !bValid )
        return E_FAIL;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: GetTokenFromString()
// Desc: Finds the token matching the given string
//-----------------------------------------------------------------------------
HRESULT CBundler::GetTokenFromString( char * strTokenString, BUNDLERTOKEN * pTok )
{
    // This lookup could be made faster via binary search or hashing
    for( int i = 0; i < sizeof( g_Tokens ) / sizeof( g_Tokens[0] ); i++ )
    {
        // Do we have a match?
        if( !lstrcmpi( strTokenString, g_Tokens[i].strKeyword ) )
        {
            *pTok = g_Tokens[i];
            return S_OK;
        }
    }

    ErrorMsg( "Unknown token <%s>\n", strTokenString );
    return E_FAIL;
}




//-----------------------------------------------------------------------------
// Name: GetNextToken()
// Desc: Gets the next token from the resource definition file
//-----------------------------------------------------------------------------
HRESULT CBundler::GetNextToken( BUNDLERTOKEN* pTok )
{
    HRESULT hr;
    char strTemp[MAX_PATH];

    ZeroMemory(strTemp, MAX_PATH);   // clear out old token string
    hr = GetNextTokenString( strTemp, TT_ANY );
    if( FAILED( hr ) )
        return hr;

    hr = GetTokenFromString( strTemp, pTok );
    if( FAILED( hr ) )
        return hr;

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\xodash\imageConv\VolumeTexture.cpp ===
//-----------------------------------------------------------------------------
// File: VolumeTexture.cpp
//
// Desc: Contains the VolumeTexture-specific logic for the bundler tool
//
// Hist: 04.11.01 - New for May XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include "VolumeTexture.h"
#include "Bundler.h"




//-----------------------------------------------------------------------------
// Name: CVolumeTexture()
// Desc: Initializes member variables
//-----------------------------------------------------------------------------
CVolumeTexture::CVolumeTexture( CBundler* pBundler )
               :CBaseTexture( pBundler )
{
    m_pVolumeTexture  = NULL;
    m_apSurface       = NULL;
    m_astrSource      = NULL;
    m_astrAlphaSource = NULL;
    m_dwWidth         = 0L;
    m_dwHeight        = 0L;
    m_dwDepth         = 0L;
}




//-----------------------------------------------------------------------------
// Name: ~CVolumeTexture()
// Desc: Performs any cleanup needed before the object is destroyed
//-----------------------------------------------------------------------------
CVolumeTexture::~CVolumeTexture()
{
    if( m_pVolumeTexture )
        m_pVolumeTexture->Release();

    if( m_apSurface )
    {
        for( DWORD i=0; i<m_dwDepth; i++ )
        {
            if( m_apSurface[i] )
                m_apSurface[i]->Release();
        }
        delete[] m_apSurface;
    }

    if( m_astrSource )
        delete[] m_astrSource;
    if( m_astrAlphaSource )
        delete[] m_astrAlphaSource;
}




//-----------------------------------------------------------------------------
// Name: SaveToBundle()
// Desc: Handles saving the appropriate data to the packed resource file
//-----------------------------------------------------------------------------
HRESULT CVolumeTexture::SaveToBundle( DWORD* pcbHeader, DWORD* pcbData )
{
    HRESULT hr;

    hr = LoadVolumeTexture();
    if( FAILED( hr ) )
        return hr;

    // Pad data file to proper alignment for the start of the texture
    hr = m_pBundler->PadToAlignment( D3DTEXTURE_ALIGNMENT );
    if( FAILED( hr ) )
        return hr;

    // Save resource header
    hr = SaveHeaderInfo( m_pBundler->m_cbData, pcbHeader );
    if( FAILED( hr ) )
        return hr;

    // Save voleume texture data
    (*pcbData) = 0;

    SaveVolumeTexture( pcbData, m_dwLevels, m_pVolumeTexture );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: LoadVolumeTexture()
// Desc: Loads the texture from the file, and sets any properties that were
//       not specified with values from the file (width, height, format, etc)
//-----------------------------------------------------------------------------
HRESULT CVolumeTexture::LoadVolumeTexture()
{
    D3DSURFACE_DESC desc;
    HRESULT hr;

    // Try to look up our format string
    m_nFormat = FormatFromString( m_strFormat );
    if( m_nFormat < -1 )
    {
        m_pBundler->ErrorMsg( "Error: Invalid texture format: %s", m_strFormat );
        return E_FAIL;
    }
    lstrcpyA( m_strFormat, g_TextureFormats[m_nFormat].strFormat );

    // Make sure depth is a power of two for non-linear textures
    if( g_TextureFormats[m_nFormat].Type == FMT_LINEAR )
    {
        m_pBundler->ErrorMsg( "Error: Volume textures must be swizzled or compressed.\n" );
        return E_FAIL;
    }

    // Make sure depth is a power of two
    DWORD dwDepth;
    for( dwDepth=1; dwDepth < m_dwDepth; dwDepth<<=1 );
    if( dwDepth != m_dwDepth )
    {
        m_pBundler->ErrorMsg( "Error: Volume texture dimensions must be a power-of-two" );
        return E_FAIL;
    }

    // If an alpha source was specified, make sure the format supports alpha
    for( DWORD i=0; i<m_dwDepth; i++ )
    {
        if( m_astrAlphaSource[i][0] ) 
        {
            if( g_TextureFormats[m_nFormat].dwNumAlphaBits == 0 )
            {
                m_pBundler->ErrorMsg( "Warning: an ALPHASOURCE was specified, yet the " \
                                      "requested texture format, %s,  does not have " \
                                      "any alpha.\n", m_strFormat );
            }
        }
    }

    // Load the image surfaces from the file (using default width, height, and a
    // A8R8G8B8 surface format)
    m_apSurface = new LPDIRECT3DSURFACE8[m_dwDepth];
    for( i=0; i<m_dwDepth; i++ )
    {
        if( FAILED( hr = LoadSurface( m_astrSource[i], m_astrAlphaSource[i], &m_apSurface[i] ) ) )
        {
			if( m_astrAlphaSource[i] )
				m_pBundler->ErrorMsg( "Volume texture: Couldn't load source file <%s> or <%s>", m_astrSource[i], m_astrAlphaSource[i] );
			else
				m_pBundler->ErrorMsg( "Volume texture: Couldn't load source file <%s>", m_astrSource[i] );
            return hr;
        }
    }

    // If width or height wasn't specified, use dimensions from first source texture
    if( m_dwWidth==0 || m_dwHeight==0 )
    {
        hr = m_apSurface[0]->GetDesc( &desc );
        m_dwWidth  = desc.Width;
        m_dwHeight = desc.Height;

        // Enforce power-of-two dimensions
        for( m_dwWidth=1;   m_dwWidth  < desc.Width;   m_dwWidth<<=1 );
        for( m_dwHeight=1;  m_dwHeight < desc.Height;  m_dwHeight<<=1 );
    }

    // Keep dimensions in check
    if( m_dwWidth>512 || m_dwHeight>512 || m_dwDepth>512 )
    {
        m_pBundler->ErrorMsg( "Error: The max for volume texture dimensions is 512.\n" );
        return hr;
    }

    // Determine final number of miplevels
    DWORD dwLevels = 1; 
    while( (1UL<<(dwLevels-1)) < min( m_dwWidth, min( m_dwHeight, m_dwDepth ) ) )
        dwLevels++;
    
    if( m_dwLevels < 1 || m_dwLevels > dwLevels )
        m_dwLevels = dwLevels;

    // Change the size of the surfaces
    for( i=0; i<m_dwDepth; i++ )
    {
        hr = ResizeSurface( m_dwWidth, m_dwHeight, &m_apSurface[i] );
    }

    // Create the volume texture
    m_pBundler->m_pd3ddev->CreateVolumeTexture( m_dwWidth, m_dwHeight, m_dwDepth, 1, 
                                                0, D3DFMT_A8R8G8B8, D3DPOOL_SYSTEMMEM, 
                                                &m_pVolumeTexture );

    D3DLOCKED_BOX destlock;
    m_pVolumeTexture->LockBox( 0, &destlock, 0, 0 );
    for( i=0; i<m_dwDepth; i++ )
    {
        D3DLOCKED_RECT srclock;
        m_apSurface[i]->LockRect( &srclock, 0, 0 );
        memcpy( destlock.pBits, srclock.pBits, sizeof(DWORD)*m_dwWidth*m_dwHeight );
        m_apSurface[i]->UnlockRect();
        destlock.pBits = ((BYTE*)destlock.pBits) + sizeof(DWORD)*m_dwWidth*m_dwHeight;
    }
    m_pVolumeTexture->UnlockBox( 0 );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: SaveHeaderInfo()
// Desc: Saves the appropriate data to the header file
//-----------------------------------------------------------------------------
HRESULT CVolumeTexture::SaveHeaderInfo( DWORD dwStart, DWORD* pcbHeader )
{
    D3DTexture d3dtex;

    XGSetVolumeTextureHeader( m_dwWidth, m_dwHeight, m_dwDepth, m_dwLevels, 0,
                              (D3DFORMAT)g_TextureFormats[m_nFormat].dwXboxFormat,
                              D3DPOOL_DEFAULT, (IDirect3DVolumeTexture8*)&d3dtex,
                              dwStart, 0 );

    // Overwrite the error in XGSetVolumeTextureHeader
    {
        for( DWORD LogWidth=0;  (1UL<<LogWidth)  <= m_dwWidth;  LogWidth++ )
        for( DWORD LogHeight=0; (1UL<<LogHeight) <= m_dwHeight; LogHeight++ )
        for( DWORD LogDepth=0;  (1UL<<LogDepth)  <= m_dwDepth;  LogDepth++ )
        d3dtex.Format =  3 << D3DFORMAT_DIMENSION_SHIFT /* UNDONE: verify */
                         | g_TextureFormats[m_nFormat].dwXboxFormat << D3DFORMAT_FORMAT_SHIFT
                         | m_dwLevels << D3DFORMAT_MIPMAP_SHIFT
                         | LogWidth   << D3DFORMAT_USIZE_SHIFT
                         | LogHeight  << D3DFORMAT_VSIZE_SHIFT
                         | LogDepth   << D3DFORMAT_PSIZE_SHIFT
                         | D3DFORMAT_DMACHANNEL_B
                         | D3DFORMAT_BORDERSOURCE_COLOR;
    }

    // Write the resource header out
    if( FAILED( m_pBundler->WriteHeader( &d3dtex, sizeof( d3dtex ) ) ) )
        return E_FAIL;

    (*pcbHeader) = sizeof(d3dtex);

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\xodash\imageConv\vb.h ===
//-----------------------------------------------------------------------------
// File: vb.cpp
//
// Desc: Header file containing class, struct, and constant definitions
//       for the vertexbuffer-related functionality of the bundler tool
//
// Hist: 02.06.01 - New for March XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef VB_H
#define VB_H

#include <windows.h>
#include <d3dx8.h>
#include <xgraphics.h>


class CBundler;


// Xbox-specific defines, taken from d3d8types-xbox.h and d3d8-xbox.h

#define D3DVERTEXBUFFER_ALIGNMENT     4

#define D3DCOMMON_TYPE_SHIFT         16
#define D3DCOMMON_TYPE_VERTEXBUFFER  0x00000000
#define D3DCOMMON_TYPE_INDEXBUFFER   0x00010000
#define D3DCOMMON_TYPE_PALETTE       0x00030000
#define D3DCOMMON_TYPE_TEXTURE       0x00040000
#define D3DCOMMON_TYPE_SURFACE       0x00050000
#define D3DCOMMON_VIDEOMEMORY        0x00800000

// Vertex attribute formats
#define XD3DVSDT_FLOAT1      0x00    // 1D float expanded to (value, 0., 0., 1.)
#define XD3DVSDT_FLOAT2      0x01    // 2D float expanded to (value, value, 0., 1.)
#define XD3DVSDT_FLOAT3      0x02    // 3D float expanded to (value, value, value, 1.)
#define XD3DVSDT_FLOAT4      0x03    // 4D float
#define XD3DVSDT_D3DCOLOR    0x04    // 4D packed unsigned bytes mapped to 0. to 1. range
#define XD3DVSDT_SHORT2      0x06    // 2D signed short expanded to (value, value, 0., 1.)
#define XD3DVSDT_SHORT4      0x07    // 4D signed short
#define XD3DVSDT_NORMSHORT1  0x08    // 1D signed, normalized short expanded to (value, 0, 0., 1.)
#define XD3DVSDT_NORMSHORT2  0x09    // 2D signed, normalized short expanded to (value, value, 0., 1.)
#define XD3DVSDT_NORMSHORT3  0x0A    // 3D signed, normalized short expanded to (value, value, value, 1.)  
#define XD3DVSDT_NORMSHORT4  0x0B    // 4D signed, normalized short expanded to (value, value, value, value)  
#define XD3DVSDT_NORMPACKED3 0x0C    // 3 signed, normalized components packed in 32-bits.  (11,11,10).  
#define XD3DVSDT_SHORT1      0x0D    // 1D signed short expanded to (value, 0., 0., 1.)  
#define XD3DVSDT_SHORT3      0x0E    // 3D signed short expanded to (value, value, value, 1.)
#define XD3DVSDT_PBYTE1      0x0F    // 1D packed byte expanded to (value, 0., 0., 1.)  
#define XD3DVSDT_PBYTE2      0x10    // 2D packed byte expanded to (value, value, 0., 1.)
#define XD3DVSDT_PBYTE3      0x11    // 3D packed byte expanded to (value, value, value, 1.)
#define XD3DVSDT_PBYTE4      0x12    // 4D packed byte expanded to (value, value, value, value) 
#define XD3DVSDT_FLOAT2H     0x13    // 2D homogeneous float expanded to (value, value,0., value.)


// VertexBuffer Format
typedef struct 
{
    DWORD Common;
    DWORD Data;
    DWORD Lock;
} D3DVertexBuffer;


#define MAX_VB_DATA 655360
#define MAX_VB_FORMATS 32




//-----------------------------------------------------------------------------
// Name: class CVertexBuffer
// Desc: Handles all vb-specific processing
//-----------------------------------------------------------------------------
class CVertexBuffer
{
public:
    CVertexBuffer( CBundler * pBundler );
    ~CVertexBuffer();

    HRESULT SaveToBundle( DWORD *pcbHeader, DWORD *pcbData );
    HRESULT AddVertexData( DOUBLE val);
    HRESULT AddVertexFormat( DWORD format);
    DWORD   m_cBytesPerVertex;
    DWORD   m_cInputValuesPerVertex;
    DWORD   m_cVertices;
    DWORD   m_cTotalBytesinVB;

private:
    HRESULT SaveHeaderInfo( DWORD dwStart, DWORD * pcbHeader );
    HRESULT SaveVertexBufferData( DWORD * pcbData );

    CBundler * m_pBundler;
    DOUBLE m_Data[MAX_VB_DATA];
    DWORD  m_Format[MAX_VB_FORMATS];
    DWORD  m_DataCount;
    DWORD  m_FormatCount;
};


#endif // VB_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\xodash\imageConv\vb.cpp ===
//-----------------------------------------------------------------------------
// File: VB.cpp
//
// Desc: Contains the vertexbuffer-specific logic for the bundler tool
//
// Hist: 02.06.01 - New for March XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include "VB.h"
#include "Bundler.h"
#include <stdio.h>




//-----------------------------------------------------------------------------
// Name: CVertexBuffer()
// Desc: Initializes member variables
//-----------------------------------------------------------------------------
CVertexBuffer::CVertexBuffer( CBundler* pBundler )
{
    m_pBundler = pBundler;
    m_DataCount = m_FormatCount = 0;
}




//-----------------------------------------------------------------------------
// Name: ~CVertexBuffer (destructor)
// Desc: Performs any cleanup needed before the object is destroyed
//-----------------------------------------------------------------------------
CVertexBuffer::~CVertexBuffer()
{
}




//-----------------------------------------------------------------------------
// Name: AddVertexData()
// Desc: Adds a single value to the vertex data stream
//-----------------------------------------------------------------------------
HRESULT CVertexBuffer::AddVertexData( DOUBLE val)
{
    if(m_DataCount >= MAX_VB_DATA)
    {
        m_pBundler->ErrorMsg( "Error: Vertex Data Buffer Overflow\n" );
        return E_FAIL;
    }
    m_Data[m_DataCount++] = val;
    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: AddVertexFormat()
// Desc: Adds a single value to the vertex data format
//-----------------------------------------------------------------------------
HRESULT CVertexBuffer::AddVertexFormat( DWORD format)
{
    if(m_FormatCount >= MAX_VB_FORMATS)
    {
        m_pBundler->ErrorMsg( "Error: Vertex Format Buffer Overflow\n" );
        return E_FAIL;
    }
    m_Format[m_FormatCount++] = format;
    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: SaveToBundle()
// Desc: Handles saving the appropriate data to the packed resource file
//-----------------------------------------------------------------------------
HRESULT CVertexBuffer::SaveToBundle( DWORD * pcbHeader, DWORD * pcbData )
{
    HRESULT hr;

    if(m_FormatCount == 0)
    {
        m_pBundler->ErrorMsg( "Error: No attribute formats specified\n" );
        return E_FAIL;
    }
    
    if(m_DataCount == 0)
    {
        m_pBundler->ErrorMsg( "Error: No attribute data specified\n" );
        return E_FAIL;
    }
    
    // Pad data file to proper alignment for the start of the vertex buffer
    hr = m_pBundler->PadToAlignment( D3DVERTEXBUFFER_ALIGNMENT );
    if( FAILED( hr ) )
        return hr;

    // Save resource header
    hr = SaveHeaderInfo( m_pBundler->m_cbData, pcbHeader );
    if( FAILED( hr ) )
        return hr;

    // Save vertexbuffer data
    hr = SaveVertexBufferData( pcbData );
    if( FAILED( hr ) )
        return hr;
     
    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: SaveHeaderInfo()
// Desc: Saves the appropriate data to the header file
//-----------------------------------------------------------------------------
HRESULT CVertexBuffer::SaveHeaderInfo( DWORD dwStart, DWORD * pcbHeader )
{
    D3DVertexBuffer d3dvb;

    d3dvb.Common =  D3DCOMMON_TYPE_VERTEXBUFFER |    // Type
                    D3DCOMMON_VIDEOMEMORY |          // VB lives in video memory
                    1;                               // Initial Refcount

    d3dvb.Data   = dwStart;                    // Offset of data in data file
    d3dvb.Lock   = 0;                          // Must be zero


    // Write the resource header out
    if( FAILED( m_pBundler->WriteHeader( &d3dvb, sizeof( d3dvb ) ) ) )
        return E_FAIL;

    *pcbHeader = sizeof( d3dvb );

    return S_OK;
}




// This structure specifies how many values are read by each attribute
// type and how many bytes are output.
struct inout
{
    DWORD inputs;
    DWORD bytesout;
} FormatInfo[] =
{
    {1, sizeof(FLOAT)},   //XD3DVSDT_FLOAT1
    {2, 2*sizeof(FLOAT)}, //XD3DVSDT_FLOAT2
    {3, 3*sizeof(FLOAT)}, //XD3DVSDT_FLOAT3
    {4, 4*sizeof(FLOAT)}, //XD3DVSDT_FLOAT4
    {4, 4*sizeof(BYTE)},  //XD3DVSDT_D3DCOLOR
    {2, 2*sizeof(SHORT)}, //XD3DVSDT_SHORT2
    {4, 4*sizeof(SHORT)}, //XD3DVSDT_SHORT4
    {1, sizeof(SHORT)},   //XD3DVSDT_NORMSHORT1
    {2, 2*sizeof(SHORT)}, //XD3DVSDT_NORMSHORT2
    {3, 3*sizeof(SHORT)}, //XD3DVSDT_NORMSHORT3
    {4, 4*sizeof(SHORT)}, //XD3DVSDT_NORMSHORT4
    {3, sizeof(DWORD)},   //XD3DVSDT_NORMPACKED3
    {1, sizeof(SHORT)},   //XD3DVSDT_SHORT1
    {3, 3*sizeof(SHORT)}, //XD3DVSDT_SHORT3
    {1, sizeof(BYTE)},    //XD3DVSDT_PBYTE1
    {2, 2*sizeof(BYTE)},  //XD3DVSDT_PBYTE2
    {3, 3*sizeof(BYTE)},  //XD3DVSDT_PBYTE3
    {4, 4*sizeof(BYTE)},  //XD3DVSDT_PBYTE4
    {3, 3*sizeof(FLOAT)}, //XD3DVSDT_FLOAT2H
};




//-----------------------------------------------------------------------------
// Name: SaveVertexBufferData()
// Desc: Saves the raw VertexBuffer data to the XPR file
//-----------------------------------------------------------------------------
HRESULT CVertexBuffer::SaveVertexBufferData( DWORD * pcbData )
{
    DWORD cData, cFormat, cVertex;
    FLOAT fOut[4];
    DWORD dwOut[4];
    SHORT sOut[4];
    BYTE  bOut[4];

    // calculate how many bytes per vertex
    m_cBytesPerVertex = 0;
    m_cInputValuesPerVertex = 0;
    for(cFormat=0; cFormat < m_FormatCount; cFormat++)
    {
        m_cBytesPerVertex += FormatInfo[m_Format[cFormat]].bytesout;
        m_cInputValuesPerVertex += FormatInfo[m_Format[cFormat]].inputs;
    }
    m_cVertices = m_DataCount/m_cInputValuesPerVertex;
    m_cTotalBytesinVB = m_cVertices*m_cBytesPerVertex;

    if((m_cVertices * m_cInputValuesPerVertex) != m_DataCount)
    {
        m_pBundler->ErrorMsg( "Warning: Extra Vertex Buffer Data:\n");
        m_pBundler->ErrorMsg( "         Format specifies %d values per vertex\n", m_cInputValuesPerVertex);
        m_pBundler->ErrorMsg( "         %d values supplied\n", m_DataCount);
        m_pBundler->ErrorMsg( "         Enough for %d vertices with %d values left over\n", m_cVertices, 
                             m_DataCount - m_cVertices * m_cInputValuesPerVertex);
    }

    for(cData = 0, cVertex = 0; cVertex < m_cVertices; cVertex++ )
    {
        for(cFormat=0; cFormat < m_FormatCount; cFormat++)
        {
            switch(m_Format[cFormat])
            {
				case XD3DVSDT_FLOAT1:
					*pcbData += sizeof(FLOAT);
					fOut[0] = (FLOAT)m_Data[cData++];
					if( FAILED( m_pBundler->WriteData( fOut, sizeof(FLOAT) ) ) )
						return E_FAIL;
					break;
				case XD3DVSDT_FLOAT2:
					*pcbData += 2*sizeof(FLOAT);
					fOut[0] = (FLOAT)m_Data[cData++];
					fOut[1] = (FLOAT)m_Data[cData++];
					if( FAILED( m_pBundler->WriteData( fOut, 2*sizeof(FLOAT) ) ) )
						return E_FAIL;
					break;
				case XD3DVSDT_FLOAT2H:
				case XD3DVSDT_FLOAT3:
					*pcbData += 3*sizeof(FLOAT);
					fOut[0] = (FLOAT)m_Data[cData++];
					fOut[1] = (FLOAT)m_Data[cData++];
					fOut[2] = (FLOAT)m_Data[cData++];
					if( FAILED( m_pBundler->WriteData( fOut, 3*sizeof(FLOAT) ) ) )
						return E_FAIL;
					break;
				case XD3DVSDT_FLOAT4:
					*pcbData += 4*sizeof(FLOAT);
					fOut[0] = (FLOAT)m_Data[cData++];
					fOut[1] = (FLOAT)m_Data[cData++];
					fOut[2] = (FLOAT)m_Data[cData++];
					fOut[3] = (FLOAT)m_Data[cData++];
					if( FAILED( m_pBundler->WriteData( fOut, 4*sizeof(FLOAT) ) ) )
						return E_FAIL;
					break;
				case XD3DVSDT_D3DCOLOR:
					*pcbData += 4*sizeof(BYTE);
					bOut[0] = (BYTE)(m_Data[cData++] * 255.0);
					bOut[1] = (BYTE)(m_Data[cData++] * 255.0);
					bOut[2] = (BYTE)(m_Data[cData++] * 255.0);
					bOut[3] = (BYTE)(m_Data[cData++] * 255.0);
					if( FAILED( m_pBundler->WriteData( bOut, 4*sizeof(BYTE) ) ) )
						return E_FAIL;
					break;
				case XD3DVSDT_SHORT1:
					*pcbData += sizeof(SHORT);
					sOut[0] = (SHORT)m_Data[cData++];
					if( FAILED( m_pBundler->WriteData( sOut, sizeof(SHORT) ) ) )
						return E_FAIL;
					break;
				case XD3DVSDT_SHORT2:
					*pcbData += 2*sizeof(SHORT);
					sOut[0] = (SHORT)m_Data[cData++];
					sOut[1] = (SHORT)m_Data[cData++];
					if( FAILED( m_pBundler->WriteData( sOut, 2*sizeof(SHORT) ) ) )
						return E_FAIL;
					break;
				case XD3DVSDT_SHORT3:
					*pcbData += 3*sizeof(SHORT);
					sOut[0] = (SHORT)m_Data[cData++];
					sOut[1] = (SHORT)m_Data[cData++];
					sOut[2] = (SHORT)m_Data[cData++];
					if( FAILED( m_pBundler->WriteData( sOut, 3*sizeof(SHORT) ) ) )
						return E_FAIL;
					break;
				case XD3DVSDT_SHORT4:
					*pcbData += 4*sizeof(SHORT);
					sOut[0] = (SHORT)m_Data[cData++];
					sOut[1] = (SHORT)m_Data[cData++];
					sOut[2] = (SHORT)m_Data[cData++];
					sOut[3] = (SHORT)m_Data[cData++];
					if( FAILED( m_pBundler->WriteData( sOut, 4*sizeof(SHORT) ) ) )
						return E_FAIL;
					break;
				case XD3DVSDT_NORMSHORT1:
					*pcbData += sizeof(SHORT);
					sOut[0] = (SHORT)(m_Data[cData++]*32767.0);
					if( FAILED( m_pBundler->WriteData( sOut, sizeof(SHORT) ) ) )
						return E_FAIL;
					break;
				case XD3DVSDT_NORMSHORT2:
					*pcbData += 2*sizeof(SHORT);
					sOut[0] = (SHORT)(m_Data[cData++]*32767.0);
					sOut[1] = (SHORT)(m_Data[cData++]*32767.0);
					if( FAILED( m_pBundler->WriteData( sOut, 2*sizeof(SHORT) ) ) )
						return E_FAIL;
					break;
				case XD3DVSDT_NORMSHORT3:
					*pcbData += 3*sizeof(SHORT);
					sOut[0] = (SHORT)(m_Data[cData++]*32767.0);
					sOut[1] = (SHORT)(m_Data[cData++]*32767.0);
					sOut[2] = (SHORT)(m_Data[cData++]*32767.0);
					if( FAILED( m_pBundler->WriteData( sOut, 3*sizeof(SHORT) ) ) )
						return E_FAIL;
					break;
				case XD3DVSDT_NORMSHORT4:
					*pcbData += 4*sizeof(SHORT);
					sOut[0] = (SHORT)(m_Data[cData++]*32767.0);
					sOut[1] = (SHORT)(m_Data[cData++]*32767.0);
					sOut[2] = (SHORT)(m_Data[cData++]*32767.0);
					sOut[3] = (SHORT)(m_Data[cData++]*32767.0);
					if( FAILED( m_pBundler->WriteData( sOut, 4*sizeof(SHORT) ) ) )
						return E_FAIL;
					break;
				case XD3DVSDT_NORMPACKED3:
					*pcbData += sizeof(DWORD);
					dwOut[0] = (DWORD)(m_Data[cData++]*2147483648.0);
					dwOut[1] = (DWORD)(m_Data[cData++]*2147483648.0);
					dwOut[2] = (DWORD)(m_Data[cData++]*2147483648.0);
					dwOut[3] = (dwOut[0] & 0xffe00000) |
							   ((dwOut[1] >> 11) & 0x001ffc00) |
							   ((dwOut[2] >> 22) & 0x000003ff);
					if( FAILED( m_pBundler->WriteData( &(dwOut[3]), sizeof(DWORD) ) ) )
						return E_FAIL;
					break;
				case XD3DVSDT_PBYTE1:
					*pcbData += sizeof(BYTE);
					bOut[0] = (BYTE)(m_Data[cData++] * 255.0);
					if( FAILED( m_pBundler->WriteData( bOut, sizeof(BYTE) ) ) )
						return E_FAIL;
					break;
				case XD3DVSDT_PBYTE2:
					*pcbData += 2*sizeof(BYTE);
					bOut[0] = (BYTE)(m_Data[cData++] * 255.0);
					bOut[1] = (BYTE)(m_Data[cData++] * 255.0);
					if( FAILED( m_pBundler->WriteData( bOut, 2*sizeof(BYTE) ) ) )
						return E_FAIL;
					break;
				case XD3DVSDT_PBYTE3:
					*pcbData += 3*sizeof(BYTE);
					bOut[0] = (BYTE)(m_Data[cData++] * 255.0);
					bOut[1] = (BYTE)(m_Data[cData++] * 255.0);
					bOut[2] = (BYTE)(m_Data[cData++] * 255.0);
					if( FAILED( m_pBundler->WriteData( bOut, 3*sizeof(BYTE) ) ) )
						return E_FAIL;
					break;
				case XD3DVSDT_PBYTE4:
					*pcbData += 4*sizeof(BYTE);
					bOut[0] = (BYTE)(m_Data[cData++] * 255.0);
					bOut[1] = (BYTE)(m_Data[cData++] * 255.0);
					bOut[2] = (BYTE)(m_Data[cData++] * 255.0);
					bOut[3] = (BYTE)(m_Data[cData++] * 255.0);
					if( FAILED( m_pBundler->WriteData( bOut, 4*sizeof(BYTE) ) ) )
						return E_FAIL;
					break;
            }
        }
    }
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\xodash\imageConv\VolumeTexture.h ===
//-----------------------------------------------------------------------------
// File: VolumeTexture.h
//
// Desc: Header file containing class, struct, and constant definitions
//       for the volume texture-related functionality of the bundler tool
//
// Hist: 05.25.01 - New for July XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef VOLUMETEXTURE_H
#define VOLUMETEXTURE_H

#include "Texture.h"


typedef CHAR FILENAME[80];


//-----------------------------------------------------------------------------
// Name: class CVolumeTexture
// Desc: Handles all VolumeTexture-specific processing, such as loading slices,
//       format conversion, swizzling, etc.
//-----------------------------------------------------------------------------
class CVolumeTexture : public CBaseTexture
{
	LPDIRECT3DVOLUMETEXTURE8 m_pVolumeTexture;
    LPDIRECT3DSURFACE8* m_apSurface;

    HRESULT LoadVolumeTexture();
    HRESULT SaveHeaderInfo( DWORD dwStart, DWORD* pcbHeader );

public:
    FILENAME* m_astrSource;
    FILENAME* m_astrAlphaSource;
    DWORD     m_dwWidth;
    DWORD     m_dwHeight;
    DWORD     m_dwDepth;

    HRESULT SaveToBundle( DWORD* pcbHeader, DWORD* pcbData );

    CVolumeTexture( CBundler* pBundler );
    ~CVolumeTexture();
};


#endif // VOLUMETEXTURE_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\xodash\XODashBuilder\ButtonPicker.cpp ===
// ButtonPicker.cpp : implementation file
//

#include "stdafx.h"
#include "XODashBuilder.h"
#include "ButtonPicker.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CButtonPicker dialog


CButtonPicker::CButtonPicker(CWnd* pParent /*=NULL*/)
	: CDialog(CButtonPicker::IDD, pParent)
{
	//{{AFX_DATA_INIT(CButtonPicker)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT

    CurrentScenes = NULL;
}


void CButtonPicker::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CButtonPicker)
	DDX_Control(pDX, IDC_BUTTONLIST, m_ButtonList);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CButtonPicker, CDialog)
	//{{AFX_MSG_MAP(CButtonPicker)
	ON_WM_SHOWWINDOW()
	ON_LBN_DBLCLK(IDC_BUTTONLIST, OnDblclkButtonlist)
	ON_BN_CLICKED(IDC_CANCELBUTTON, OnCancelbutton)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

void CButtonPicker::getSceneCollection(VSceneCollection *pScenes)
{
	// Get the pointer to the scenelist
	CurrentScenes = pScenes;
}

/////////////////////////////////////////////////////////////////////////////
// CButtonPicker message handlers

void CButtonPicker::OnShowWindow(BOOL bShow, UINT nStatus) 
{
	CDialog::OnShowWindow(bShow, nStatus);
	
    // Populate the list with all of the possible buttons
    VButtonList::iterator i;
    for(i = CurrentScenes->m_gVButtonList.begin(); i != CurrentScenes->m_gVButtonList.end(); i++)
    {
        m_ButtonList.AddString((*i)->m_pVButtonName);
    }	
}

void CButtonPicker::OnDblclkButtonlist() 
{
	// User has double clicked a button to choose it.
    int nCurSelection = m_ButtonList.GetCurSel();

    CString newButton;
    m_ButtonList.GetText(nCurSelection, newButton);
//    m_returnButton = new char[strlen((LPCTSTR)newButton) + 1];
    strcpy(m_returnButton, (LPCTSTR)newButton);

    CDialog::OnOK();
}

BOOL CButtonPicker::DestroyWindow() 
{
    CurrentScenes = NULL;
	
	return CDialog::DestroyWindow();
}

void CButtonPicker::OnCancelbutton() 
{
    CDialog::OnCancel();	
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\xodash\XODashBuilder\ButtonDialog.cpp ===
// ButtonDialog.cpp : implementation file
//

#include "stdafx.h"
#include "XODashBuilder.h"
#include "ButtonDialog.h"
#include "ButtonPicker.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/////////////////////////////////////////////////////////////////////////////
// CButtonDialog dialog

CButtonDialog::CButtonDialog(CWnd* pParent /*=NULL*/)
	: CDialog(CButtonDialog::IDD, pParent)
{
	//{{AFX_DATA_INIT(CButtonDialog)
	//}}AFX_DATA_INIT

	CurrentScenes = NULL;
	nCurEditButton = 0;
}

void CButtonDialog::getSceneCollection(VSceneCollection *pScenes)
{
	// Get the pointer to the scenelist
	CurrentScenes = pScenes;
}

void CButtonDialog::getSelectedScene(CString selectedScene)
{
	m_pzSelectedScene = selectedScene;
}

void CButtonDialog::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CButtonDialog)
	DDX_Control(pDX, IDC_DELETEBUTTON, m_DeleteButton);
	DDX_Control(pDX, IDC_EDITBUTTON, m_EditButton);
	DDX_Control(pDX, IDC_SAVEBUTTON, m_SaveButton);
	DDX_Control(pDX, IDC_NEWBUTTON, m_NewButton);
	DDX_Control(pDX, IDC_BUTTONLIST, m_ButtonList);
	DDX_Control(pDX, IDC_HELPTEXT, m_ButtonHelp);
	DDX_Control(pDX, IDC_BUTTONLINK, m_ButtonLink);
	DDX_Control(pDX, IDC_BUTTONID, m_ButtonID);
	DDX_Control(pDX, IDC_BUTTONNAME, m_ButtonName);
	DDX_Control(pDX, IDC_SCENENAME, m_SceneName);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CButtonDialog, CDialog)
	//{{AFX_MSG_MAP(CButtonDialog)
	ON_WM_SHOWWINDOW()
	ON_LBN_SELCHANGE(IDC_BUTTONLIST, OnSelchangeButtonlist)
	ON_BN_CLICKED(IDC_NEWBUTTON, OnNewbutton)
	ON_BN_CLICKED(IDC_EDITBUTTON, OnEditbutton)
	ON_BN_CLICKED(IDC_SAVEBUTTON, OnSavebutton)
	ON_BN_CLICKED(IDC_DELETEBUTTON, OnDeletebutton)
	ON_BN_CLICKED(IDC_DEBUGBUTTON, OnDebugbutton)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CButtonDialog message handlers

void CButtonDialog::OnShowWindow(BOOL bShow, UINT nStatus) 
{
	CDialog::OnShowWindow(bShow, nStatus);
	
	// Fill in Scene name and Button List
	m_SceneName.SetWindowText(m_pzSelectedScene);

    // Get a pointer to the selected scene
    VSceneList::iterator i;
    i = CurrentScenes->m_gVSceneList.begin();
    for(int j = 0; j < CurrentScenes->m_gVSceneList.size(); j++)
    {
		if((*i)->m_pzVSceneName.Compare(m_pzSelectedScene) == 0)
        {
			m_pScene = (*i);
            break;
		}
        i++;
    }
	FillButtonList();
    if( m_ButtonList.GetCount() > 0 )
    {
	    m_ButtonList.SetCurSel(0);
	    OnSelchangeButtonlist();
    }

    // Fields
    m_ButtonName.SetReadOnly(true);
    m_ButtonID.SetReadOnly(true);
	m_ButtonLink.SetReadOnly(true);
    m_ButtonHelp.SetReadOnly(true);

    // List
    m_ButtonList.EnableWindow(true);

    // Buttons
    m_EditButton.EnableWindow(true);
    m_NewButton.EnableWindow(true);
    m_SaveButton.EnableWindow(false);
	m_DeleteButton.EnableWindow(true);

	bButtonChange = false;
	bButtonNew	  = false;
}

void CButtonDialog::FillButtonList(void)
{
    m_ButtonList.ResetContent();

    // Get a pointer to the selected scene
    VButtonSceneList::iterator i;
    for(i = m_pScene->m_VButtonList.begin(); i != m_pScene->m_VButtonList.end(); i++)
    {
		m_ButtonList.AddString((*i)->m_pVButton->m_pVButtonName);
    }

}

void CButtonDialog::OnSelchangeButtonlist() 
{
	// Getting the name of the scene selected
    nCurEditButton = m_ButtonList.GetCurSel();
    CString pzCurrentString;
    m_ButtonList.GetText(nCurEditButton, pzCurrentString);

    // Finding the Scene in the current list of scenes
    VButtonSceneList::iterator i;
    for(i = m_pScene->m_VButtonList.begin(); i != m_pScene->m_VButtonList.end(); i++)
    {
        if((*i)->m_pVButton->m_pVButtonName.Compare(pzCurrentString) == 0)
        {
            // Populate the data fields
			m_ButtonName.SetWindowText((*i)->m_pVButton->m_pVButtonName);
			m_ButtonID.SetWindowText  ((*i)->m_pVButton->m_pVButtonID);
			m_ButtonHelp.SetWindowText((*i)->m_pVButton->m_pVHelpText);
			m_ButtonLink.SetWindowText((*i)->m_pVButtonLink);
	
            break;
        }
    }	
}

void CButtonDialog::OnEditbutton() 
{
    // Fields
    m_ButtonName.SetReadOnly(false);
    m_ButtonID.SetReadOnly(false);
	m_ButtonLink.SetReadOnly(false);
    m_ButtonHelp.SetReadOnly(false);

    // List
    m_ButtonList.EnableWindow(false);

    // Buttons
    m_EditButton.EnableWindow(false);
    m_NewButton.EnableWindow(false);
    m_SaveButton.EnableWindow(true);
	m_DeleteButton.EnableWindow(false);

	bButtonChange = true;
}

void CButtonDialog::OnNewbutton() 
{
    // Fields
    m_ButtonName.SetReadOnly(false);
	m_ButtonName.SetWindowText("");
    m_ButtonID.SetReadOnly(false);
	m_ButtonID.SetWindowText("");
	m_ButtonLink.SetReadOnly(false);
	m_ButtonLink.SetWindowText("");
    m_ButtonHelp.SetReadOnly(false);
	m_ButtonHelp.SetWindowText("");

    // List
    m_ButtonList.EnableWindow(false);
	m_ButtonList.SetCurSel(-1);

    // Buttons
    m_EditButton.EnableWindow(false);
    m_NewButton.EnableWindow(false);
    m_SaveButton.EnableWindow(true);
	m_DeleteButton.EnableWindow(false);

	bButtonNew = true;

    // Load up the button picker
    CButtonPicker *pickerDialog;
    pickerDialog = new CButtonPicker();
    pickerDialog->getSceneCollection(CurrentScenes);
    pickerDialog->DoModal();

    // has the user choosen a value?
    if(pickerDialog->m_returnButton != NULL)
    {
        // find the button in the list
        VButtonList::iterator i;
        for(i = CurrentScenes->m_gVButtonList.begin(); i != CurrentScenes->m_gVButtonList.end(); i++)
        {
            if(strcmp((*i)->m_pVButtonName, pickerDialog->m_returnButton) == 0)
            {
                // Found a match
	            m_ButtonName.SetWindowText((*i)->m_pVButtonName);
	            m_ButtonID.SetWindowText((*i)->m_pVButtonID);
	            m_ButtonLink.SetWindowText("eNullSceneId");
	            m_ButtonHelp.SetWindowText((*i)->m_pVHelpText);
            }
        }	
    }

    delete pickerDialog;
}

void CButtonDialog::OnSavebutton() 
{
    // Get data from fields into an array of strings
    CString textString[4];
	m_ButtonName.GetWindowText(textString[0]);
	m_ButtonID.GetWindowText(textString[1]);
	m_ButtonHelp.GetWindowText(textString[2]);
	m_ButtonLink.GetWindowText(textString[3]);

    // If only editing existing data, plug back into data structure
    if(bButtonChange)
    {
        // Save any edits if any
        CString pzEditedButton;
        m_ButtonList.GetText(nCurEditButton, pzEditedButton);
        VButtonSceneList::iterator j;
        for(j = m_pScene->m_VButtonList.begin(); j != m_pScene->m_VButtonList.end(); j++)
        {
            if((*j)->m_pVButton->m_pVButtonName.Compare(pzEditedButton) == 0)
            {
                (*j)->m_pVButton->m_pVButtonName  = textString[0];
                (*j)->m_pVButton->m_pVButtonID    = textString[1];
                (*j)->m_pVButton->m_pVHelpText    = textString[2];
                (*j)->m_pVButtonLink              = textString[3];
                break;
            }
        }
    }
    // If adding a new button, create the button, and insert it into the list
    else if(bButtonNew)
    {
        // Check to see if the button already exists in the global array
        VButtonList::iterator j;
        bool buttonExists = false;
        for(j = CurrentScenes->m_gVButtonList.begin(); j != CurrentScenes->m_gVButtonList.end(); j++)
        {
            if((*j)->m_pVButtonName.Compare(textString[0]) == 0)
            {
                // Push button onto the scene button array
                VButtonScene *newLinkButton    = new VButtonScene();
                newLinkButton->m_pVButton      = (*j);
                newLinkButton->m_pVButtonLink  = textString[3];
                m_pScene->m_VButtonList.push_back(newLinkButton);

                buttonExists = true;
                break;
            }
        }

        if(!buttonExists)
        {
            // Create a new button in the global list
            VButton *newButton = new VButton();
            newButton->m_pVButtonName = textString[0];
            newButton->m_pVButtonID   = textString[1];
            newButton->m_pVHelpText   = textString[2];

            CurrentScenes->m_gVButtonList.push_back(newButton);

            // Create a button for the Scene
            VButtonScene *newLinkButton = new VButtonScene();
            newLinkButton->m_pVButton     = newButton;
            newLinkButton->m_pVButtonLink = textString[3];

            m_pScene->m_VButtonList.push_back(newLinkButton);
        }
    }

    // Update list based on changes, and move selection to proper item
    FillButtonList();
    nCurEditButton = m_ButtonList.FindString(0, textString[0]);
    m_ButtonList.SetCurSel(nCurEditButton);
    OnSelchangeButtonlist();

    // Fields
    m_ButtonName.SetReadOnly(true);
    m_ButtonID.SetReadOnly(true);
	m_ButtonLink.SetReadOnly(true);
    m_ButtonHelp.SetReadOnly(true);

    // List
    m_ButtonList.EnableWindow(true);

    // Buttons
    m_EditButton.EnableWindow(true);
    m_NewButton.EnableWindow(true);
    m_SaveButton.EnableWindow(false);
	m_DeleteButton.EnableWindow(true);

    bButtonChange  = false;
    bButtonNew     = false;
}

void CButtonDialog::OnDeletebutton() 
{
	// Getting the name of the scene selected
    nCurEditButton = m_ButtonList.GetCurSel();
    CString pzCurrentString;
    m_ButtonList.GetText(nCurEditButton, pzCurrentString);

    // Finding the Button in the current list of Buttons
    VButtonSceneList::iterator i;
    for(i = m_pScene->m_VButtonList.begin(); i != m_pScene->m_VButtonList.end(); i++)
    {
        if((*i)->m_pVButton->m_pVButtonName.Compare(pzCurrentString) == 0)
        {
			// Remove the Button link from the data structure
            if((*i)->m_pVButtonLink.GetLength())
            {
                (*i)->m_pVButtonLink.Empty();
            }
			m_pScene->m_VButtonList.remove(*i);
            break;
        }
    }

	FillButtonList();
    nCurEditButton = 0;
    m_ButtonList.SetCurSel(nCurEditButton);
    OnSelchangeButtonlist();		
}

void CButtonDialog::OnDebugbutton() 
{
    VButtonList::iterator j;
    for(j = CurrentScenes->m_gVButtonList.begin(); j != CurrentScenes->m_gVButtonList.end(); j++)
    {
        // for every scenes button, print out the name to the debugger
        CString outputStr;
        outputStr.Format("%s\n", (*j)->m_pVButtonName);
        OutputDebugString(outputStr);
    }
    OutputDebugString("\n\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\xodash\XODashBuilder\checkedout.h ===
#if !defined(AFX_CHECKEDOUT_H__02FBA4AC_B3A0_4ADC_B190_CD6CFE733650__INCLUDED_)
#define AFX_CHECKEDOUT_H__02FBA4AC_B3A0_4ADC_B190_CD6CFE733650__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// CheckedOut.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CCheckedOut dialog

class CCheckedOut : public CDialog
{
// Construction
public:
	CCheckedOut(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CCheckedOut)
	enum { IDD = IDD_CHECKEDOUT };
	CListBox	m_FilesCheckedIn;
	//}}AFX_DATA

    void CheckFile(char *szFilePath, char *szFileName);

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CCheckedOut)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CCheckedOut)
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_CHECKEDOUT_H__02FBA4AC_B3A0_4ADC_B190_CD6CFE733650__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\xodash\XODashBuilder\ButtonDialog.h ===
#if !defined(AFX_BUTTONDIALOG_H__F37EEF82_6F6E_48F3_BE67_5133A4AFAB57__INCLUDED_)
#define AFX_BUTTONDIALOG_H__F37EEF82_6F6E_48F3_BE67_5133A4AFAB57__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// ButtonDialog.h : header file
//

#include "scene.h"

/////////////////////////////////////////////////////////////////////////////
// CButtonDialog dialog

class CButtonDialog : public CDialog
{
// Construction
public:
	CButtonDialog(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CButtonDialog)
	enum { IDD = IDD_BUTTONMAP };
	CButton	m_DeleteButton;
	CButton	m_EditButton;
	CButton	m_SaveButton;
	CButton	m_NewButton;
	CListBox	m_ButtonList;
	CEdit	m_ButtonHelp;
	CEdit	m_ButtonLink;
	CEdit	m_ButtonID;
	CEdit	m_ButtonName;
	CEdit		m_SceneName;
	//}}AFX_DATA

	void getSceneCollection(VSceneCollection *pScenes);
	void getSelectedScene(CString selectedScene);
	void FillButtonList(void);

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CButtonDialog)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

	VSceneCollection *CurrentScenes;
	CString			 m_pzSelectedScene;
	VScene			 *m_pScene;

	
	int				 nCurEditButton;
	bool			 bButtonChange;
	bool			 bButtonNew;

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CButtonDialog)
	afx_msg void OnShowWindow(BOOL bShow, UINT nStatus);
	afx_msg void OnSelchangeButtonlist();
	afx_msg void OnNewbutton();
	afx_msg void OnEditbutton();
	afx_msg void OnSavebutton();
	afx_msg void OnDeletebutton();
	afx_msg void OnDebugbutton();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_BUTTONDIALOG_H__F37EEF82_6F6E_48F3_BE67_5133A4AFAB57__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\xodash\XODashBuilder\CntrItem.h ===
// CntrItem.h : interface of the CXODashBuilderCntrItem class
//

#if !defined(AFX_CNTRITEM_H__07266C95_7258_4980_9D46_DD8CC2206BEA__INCLUDED_)
#define AFX_CNTRITEM_H__07266C95_7258_4980_9D46_DD8CC2206BEA__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

class CXODashBuilderDoc;
class CXODashBuilderView;

class CXODashBuilderCntrItem : public COleClientItem
{
	DECLARE_SERIAL(CXODashBuilderCntrItem)

// Constructors
public:
	CXODashBuilderCntrItem(CXODashBuilderDoc* pContainer = NULL);
		// Note: pContainer is allowed to be NULL to enable IMPLEMENT_SERIALIZE.
		//  IMPLEMENT_SERIALIZE requires the class have a constructor with
		//  zero arguments.  Normally, OLE items are constructed with a
		//  non-NULL document pointer.

// Attributes
public:
	CXODashBuilderDoc* GetDocument()
		{ return (CXODashBuilderDoc*)COleClientItem::GetDocument(); }
	CXODashBuilderView* GetActiveView()
		{ return (CXODashBuilderView*)COleClientItem::GetActiveView(); }

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CXODashBuilderCntrItem)
	public:
	virtual void OnChange(OLE_NOTIFICATION wNotification, DWORD dwParam);
	virtual void OnActivate();
	protected:
	virtual void OnGetItemPosition(CRect& rPosition);
	virtual void OnDeactivateUI(BOOL bUndoable);
	virtual BOOL OnChangeItemPosition(const CRect& rectPos);
	//}}AFX_VIRTUAL

// Implementation
public:
	~CXODashBuilderCntrItem();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif
	virtual void Serialize(CArchive& ar);
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_CNTRITEM_H__07266C95_7258_4980_9D46_DD8CC2206BEA__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\xodash\XODashBuilder\ButtonPicker.h ===
#if !defined(AFX_BUTTONPICKER_H__B2FC0106_A3F0_4E1A_B41A_AF315901C11C__INCLUDED_)
#define AFX_BUTTONPICKER_H__B2FC0106_A3F0_4E1A_B41A_AF315901C11C__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// ButtonPicker.h : header file
//

#include "scene.h"

/////////////////////////////////////////////////////////////////////////////
// CButtonPicker dialog

class CButtonPicker : public CDialog
{
// Construction
public:
	CButtonPicker(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CButtonPicker)
	enum { IDD = IDD_BUTTONPICK };
	CListBox	m_ButtonList;
	//}}AFX_DATA

	void getSceneCollection(VSceneCollection *pScenes);
    char m_returnButton[255];

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CButtonPicker)
	public:
	virtual BOOL DestroyWindow();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

	VSceneCollection *CurrentScenes;

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CButtonPicker)
	afx_msg void OnShowWindow(BOOL bShow, UINT nStatus);
	afx_msg void OnDblclkButtonlist();
	afx_msg void OnCancelbutton();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_BUTTONPICKER_H__B2FC0106_A3F0_4E1A_B41A_AF315901C11C__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\xodash\XODashBuilder\CntrItem.cpp ===
// CntrItem.cpp : implementation of the CXODashBuilderCntrItem class
//

#include "stdafx.h"
#include "XODashBuilder.h"

#include "XODashBuilderDoc.h"
#include "XODashBuilderView.h"
#include "CntrItem.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CXODashBuilderCntrItem implementation

IMPLEMENT_SERIAL(CXODashBuilderCntrItem, COleClientItem, 0)

CXODashBuilderCntrItem::CXODashBuilderCntrItem(CXODashBuilderDoc* pContainer)
	: COleClientItem(pContainer)
{
	// TODO: add one-time construction code here
	
}

CXODashBuilderCntrItem::~CXODashBuilderCntrItem()
{
	// TODO: add cleanup code here
	
}

void CXODashBuilderCntrItem::OnChange(OLE_NOTIFICATION nCode, DWORD dwParam)
{
	ASSERT_VALID(this);

	COleClientItem::OnChange(nCode, dwParam);

	// When an item is being edited (either in-place or fully open)
	//  it sends OnChange notifications for changes in the state of the
	//  item or visual appearance of its content.

	// TODO: invalidate the item by calling UpdateAllViews
	//  (with hints appropriate to your application)

	GetDocument()->UpdateAllViews(NULL);
		// for now just update ALL views/no hints
}

BOOL CXODashBuilderCntrItem::OnChangeItemPosition(const CRect& rectPos)
{
	ASSERT_VALID(this);

	// During in-place activation CXODashBuilderCntrItem::OnChangeItemPosition
	//  is called by the server to change the position of the in-place
	//  window.  Usually, this is a result of the data in the server
	//  document changing such that the extent has changed or as a result
	//  of in-place resizing.
	//
	// The default here is to call the base class, which will call
	//  COleClientItem::SetItemRects to move the item
	//  to the new position.

	if (!COleClientItem::OnChangeItemPosition(rectPos))
		return FALSE;

	// TODO: update any cache you may have of the item's rectangle/extent

	return TRUE;
}

void CXODashBuilderCntrItem::OnGetItemPosition(CRect& rPosition)
{
	ASSERT_VALID(this);

	// During in-place activation, CXODashBuilderCntrItem::OnGetItemPosition
	//  will be called to determine the location of this item.  The default
	//  implementation created from AppWizard simply returns a hard-coded
	//  rectangle.  Usually, this rectangle would reflect the current
	//  position of the item relative to the view used for activation.
	//  You can obtain the view by calling CXODashBuilderCntrItem::GetActiveView.

	// TODO: return correct rectangle (in pixels) in rPosition

	rPosition.SetRect(10, 10, 210, 210);
}

void CXODashBuilderCntrItem::OnActivate()
{
    // Allow only one inplace activate item per frame
    CXODashBuilderView* pView = GetActiveView();
    ASSERT_VALID(pView);
    COleClientItem* pItem = GetDocument()->GetInPlaceActiveItem(pView);
    if (pItem != NULL && pItem != this)
        pItem->Close();
    
    COleClientItem::OnActivate();
}

void CXODashBuilderCntrItem::OnDeactivateUI(BOOL bUndoable)
{
	COleClientItem::OnDeactivateUI(bUndoable);

    // Hide the object if it is not an outside-in object
    DWORD dwMisc = 0;
    m_lpObject->GetMiscStatus(GetDrawAspect(), &dwMisc);
    if (dwMisc & OLEMISC_INSIDEOUT)
        DoVerb(OLEIVERB_HIDE, NULL);
}

void CXODashBuilderCntrItem::Serialize(CArchive& ar)
{
	ASSERT_VALID(this);

	// Call base class first to read in COleClientItem data.
	// Since this sets up the m_pDocument pointer returned from
	//  CXODashBuilderCntrItem::GetDocument, it is a good idea to call
	//  the base class Serialize first.
	COleClientItem::Serialize(ar);

	// now store/retrieve data specific to CXODashBuilderCntrItem
	if (ar.IsStoring())
	{
		// TODO: add storing code here
	}
	else
	{
		// TODO: add loading code here
	}
}

/////////////////////////////////////////////////////////////////////////////
// CXODashBuilderCntrItem diagnostics

#ifdef _DEBUG
void CXODashBuilderCntrItem::AssertValid() const
{
	COleClientItem::AssertValid();
}

void CXODashBuilderCntrItem::Dump(CDumpContext& dc) const
{
	COleClientItem::Dump(dc);
}
#endif

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\xodash\XODashBuilder\checkedout.cpp ===
// CheckedOut.cpp : implementation file
//

#include "stdafx.h"
#include "XODashBuilder.h"
#include "CheckedOut.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

extern bool CheckReadOnly(char *szFileName);

/////////////////////////////////////////////////////////////////////////////
// CCheckedOut dialog


CCheckedOut::CCheckedOut(CWnd* pParent /*=NULL*/)
	: CDialog(CCheckedOut::IDD, pParent)
{
	//{{AFX_DATA_INIT(CCheckedOut)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}


void CCheckedOut::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CCheckedOut)
	DDX_Control(pDX, IDC_LIST1, m_FilesCheckedIn);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CCheckedOut, CDialog)
	//{{AFX_MSG_MAP(CCheckedOut)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

void CCheckedOut::CheckFile(char *szFilePath, char *szFileName)
{
    if(CheckReadOnly(szFilePath))
        m_FilesCheckedIn.AddString(szFileName);
}

/////////////////////////////////////////////////////////////////////////////
// CCheckedOut message handlers

BOOL CCheckedOut::OnInitDialog() 
{
	CDialog::OnInitDialog();
	
    CheckFile("..\\xodashlib\\ButtonName.h", "\\xodashlib\\ButtonName.h");
    CheckFile("..\\xodashlib\\ButtonId.h", "\\xodashlib\\ButtonId.h");
    CheckFile("..\\xodashlib\\ButtonHelp.h", "\\xodashlib\\ButtonHelp.h");
    CheckFile("..\\xodashlib\\SceneName.h", "\\xodashlib\\SceneName.h");
    CheckFile("..\\xodashlib\\SceneId.h", "\\xodashlib\\SceneId.h");
    CheckFile("..\\XODashMain\\NavigationDesc.cpp", "\\XODashMain\\NavigationDesc.cpp");
    CheckFile("..\\XODashMain\\NavigationMap.cpp", "\\XODashMain\\NavigationMap.cpp");

	return TRUE;
}

void CCheckedOut::OnOK() 
{

	CDialog::OnOK();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\xodash\XODashBuilder\MainFrm.cpp ===
// MainFrm.cpp : implementation of the CMainFrame class
//

#include "stdafx.h"
#include "XODashBuilder.h"
#include "Scene.h"
#include "SceneDialog.h"

#include "MainFrm.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CMainFrame

IMPLEMENT_DYNCREATE(CMainFrame, CFrameWnd)

BEGIN_MESSAGE_MAP(CMainFrame, CFrameWnd)
	//{{AFX_MSG_MAP(CMainFrame)
	ON_WM_CREATE()
	ON_COMMAND(ID_FILE_START, OnFileStart)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

static UINT indicators[] =
{
	ID_SEPARATOR,           // status line indicator
	ID_INDICATOR_CAPS,
	ID_INDICATOR_NUM,
	ID_INDICATOR_SCRL,
};

/////////////////////////////////////////////////////////////////////////////
// CMainFrame construction/destruction

CMainFrame::CMainFrame()
{
	// TODO: add member initialization code here
	
}

CMainFrame::~CMainFrame()
{
}

int CMainFrame::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	if (CFrameWnd::OnCreate(lpCreateStruct) == -1)
		return -1;

	if (!m_wndStatusBar.Create(this) ||
		!m_wndStatusBar.SetIndicators(indicators,
		  sizeof(indicators)/sizeof(UINT)))
	{
		TRACE0("Failed to create status bar\n");
		return -1;      // fail to create
	}

	return 0;
}

BOOL CMainFrame::PreCreateWindow(CREATESTRUCT& cs)
{
	if( !CFrameWnd::PreCreateWindow(cs) )
		return FALSE;
	// TODO: Modify the Window class or styles here by modifying
	//  the CREATESTRUCT cs

	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CMainFrame diagnostics

#ifdef _DEBUG
void CMainFrame::AssertValid() const
{
	CFrameWnd::AssertValid();
}

void CMainFrame::Dump(CDumpContext& dc) const
{
	CFrameWnd::Dump(dc);
}

#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CMainFrame message handlers


void CMainFrame::OnFileStart() 
{
	// TODO: Add your command handler code here
    m_wndStatusBar.SetPaneText(0, "Opening include files from Xdash Online");

    // Display the Scene Dialog box now that we are initialized
	CSceneDialog *sceneDlg;
    sceneDlg = new CSceneDialog();

    sceneDlg->DoModal();

	delete sceneDlg;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\xodash\XODashBuilder\Resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by XODashBuilder.rc
//
#define IDR_CNTR_INPLACE                6
#define IDD_ABOUTBOX                    100
#define IDP_OLE_INIT_FAILED             100
#define IDP_FAILED_TO_CREATE            102
#define IDR_MAINFRAME                   128
#define IDR_XODASHTYPE                  129
#define IDD_SCENEDESC                   131
#define IDD_BUTTONMAP                   132
#define IDD_BUTTONPICK                  133
#define IDD_CHECKEDOUT                  134
#define IDC_LIST1                       1000
#define IDC_EDIT1                       1001
#define IDC_EDIT2                       1002
#define IDC_CHECK1                      1005
#define IDC_EDIT3                       1006
#define IDC_EDIT4                       1008
#define IDC_NEWSCENE                    1009
#define IDC_EDITSCENE                   1010
#define IDC_SAVEBUTTON                  1011
#define IDC_BUTTONS                     1012
#define IDC_EDIT5                       1013
#define IDC_BUTTONLINK                  1013
#define IDC_NEWBUTTON                   1014
#define IDC_EDITBUTTON                  1015
#define IDC_SCENENAME                   1017
#define IDC_BUTTONNAME                  1018
#define IDC_BUTTONID                    1019
#define IDC_HELPTEXT                    1020
#define IDC_BUTTONLIST                  1021
#define IDC_DELETEBUTTON                1022
#define IDC_CANCELBUTTON                1024
#define IDC_DEBUGBUTTON                 1025
#define ID_CANCEL_EDIT_CNTR             32768
#define ID_FILE_START                   32771

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_3D_CONTROLS                     1
#define _APS_NEXT_RESOURCE_VALUE        135
#define _APS_NEXT_COMMAND_VALUE         32772
#define _APS_NEXT_CONTROL_VALUE         1027
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\xodash\XODashBuilder\Scene.h ===
#pragma once
#include "stdafx.h"
#include <list>

using namespace std;

class VButton
{
public:
    VButton();
    ~VButton();

    CString m_pVButtonName;
    CString m_pVButtonID;
    CString m_pVHelpText;
};

class VButtonScene
{
public:
    VButtonScene();
    ~VButtonScene();

    VButton *m_pVButton;

    CString m_pVButtonLink;
};

typedef list<VButtonScene*> VButtonSceneList;
typedef list<VButton*> VButtonList;

class VScene
{
public:
    VScene();
    ~VScene();

    // General Scene Information
    CString   m_pzVSceneName;
    CString   m_pzVSceneID;
    
    CString   m_pzVScenePath;
    CString   m_pzVSceneTextName;
    CString   m_pzVSceneShowTop;
    CString   m_pzVButtonFocus;
   
    VButtonSceneList	m_VButtonList;
};

typedef list<VScene*> VSceneList;
typedef list<CString> VStringList;

class VSceneCollection
{
public:
    VSceneCollection();
    ~VSceneCollection();

    HRESULT initalize(void);

    VSceneList	m_gVSceneList;
    VButtonList	m_gVButtonList;

    HRESULT writeButtonNames(char *fileName);
    HRESULT writeButtonIds(char *fileName);
    HRESULT writeButtonHelp(char *fileName);
    HRESULT writeNavDesc(char *fileName);
    HRESULT writeNavMap(char *fileName);
    HRESULT writeSceneNames(char *fileName);
    HRESULT writeSceneIds(char *fileName);
    HRESULT writeScenesToLoad(char *fileName);

private:
    HRESULT initalizeButtons(void);
    HRESULT initalizeScenes(void);
    HRESULT readNavMap(void);
    HRESULT readNavDesc(void);
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\xodash\XODashBuilder\SceneDialog.h ===
#if !defined(AFX_SCENEDIALOG_H__6155FBD3_1474_4AF5_9BF7_6BCEBDE24A1A__INCLUDED_)
#define AFX_SCENEDIALOG_H__6155FBD3_1474_4AF5_9BF7_6BCEBDE24A1A__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// SceneDialog.h : header file
//
#include "Scene.h"

/////////////////////////////////////////////////////////////////////////////
// CSceneDialog dialog

class CSceneDialog : public CDialog
{
// Construction
public:
	CSceneDialog(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CSceneDialog)
	enum { IDD = IDD_SCENEDESC };
	CButton	m_DeleteButton;
	CButton	m_ButtonsButton;
	CButton	m_EditButton;
	CButton	m_NewSceneButton;
	CButton	m_SaveButton;
	CEdit	m_SceneName;
	CEdit	m_FieldSceneID;
	CButton	m_ShowOnTop;
	CEdit	m_TextName;
	CEdit	m_FilePath;
	CListBox	m_SceneList;
	CString	m_SceneIDField;
	//}}AFX_DATA

	VSceneCollection CurrentScenes;
    bool             bSceneChange;
    bool             bSceneNew;
    int              nCurEditScene;

    void FillSceneList(void);


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CSceneDialog)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CSceneDialog)
	afx_msg void OnShowWindow(BOOL bShow, UINT nStatus);
	afx_msg void OnSelchangeSceneList();
	afx_msg void OnEditscene();
	afx_msg void OnNewscene();
	afx_msg void OnSavebutton();
	virtual void OnOK();
	virtual void OnCancel();
	afx_msg void OnButtons();
	afx_msg void OnDeletebutton();
	virtual BOOL OnInitDialog();
	afx_msg void OnDebugbutton();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SCENEDIALOG_H__6155FBD3_1474_4AF5_9BF7_6BCEBDE24A1A__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\xodash\XODashBuilder\MainFrm.h ===
// MainFrm.h : interface of the CMainFrame class
//
/////////////////////////////////////////////////////////////////////////////

#if !defined(AFX_MAINFRM_H__AE519123_0D59_4361_800D_A66946881C65__INCLUDED_)
#define AFX_MAINFRM_H__AE519123_0D59_4361_800D_A66946881C65__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

class CMainFrame : public CFrameWnd
{
	
protected: // create from serialization only
	CMainFrame();
	DECLARE_DYNCREATE(CMainFrame)

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CMainFrame)
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CMainFrame();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:  // control bar embedded members
	CStatusBar  m_wndStatusBar;

// Generated message map functions
protected:
	//{{AFX_MSG(CMainFrame)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnFileStart();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_MAINFRM_H__AE519123_0D59_4361_800D_A66946881C65__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\xodash\XODashBuilder\SceneDialog.cpp ===
// SceneDialog.cpp : implementation file
//

#include "stdafx.h"
#include "XODashBuilder.h"
#include "SceneDialog.h"
#include "ButtonDialog.h"
#include "CheckedOut.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

bool CheckReadOnly(char *szFileName)
{
    DWORD nFileAttrib = GetFileAttributes(szFileName);
    if(nFileAttrib & FILE_ATTRIBUTE_READONLY)
        return true;

    return false;
}

bool CheckSceneFiles(void)
{
    bool nResults = CheckReadOnly("..\\xodashlib\\ButtonName.h");
    nResults |= CheckReadOnly("..\\xodashlib\\ButtonId.h");
    nResults |= CheckReadOnly("..\\xodashlib\\ButtonHelp.h");
    nResults |= CheckReadOnly("..\\XODashMain\\NavigationDesc.cpp");
    nResults |= CheckReadOnly("..\\XODashMain\\NavigationMap.cpp");
    nResults |= CheckReadOnly("..\\xodashlib\\SceneName.h");
    nResults |= CheckReadOnly("..\\xodashlib\\SceneId.h");

    if(nResults)
    {
        return true;
    }
    
    return false;
}

/////////////////////////////////////////////////////////////////////////////
// CSceneDialog dialog


CSceneDialog::CSceneDialog(CWnd* pParent /*=NULL*/)
	: CDialog(CSceneDialog::IDD, pParent)
{
	//{{AFX_DATA_INIT(CSceneDialog)
	m_SceneIDField = _T("");
	//}}AFX_DATA_INIT
}


void CSceneDialog::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CSceneDialog)
	DDX_Control(pDX, IDC_DELETEBUTTON, m_DeleteButton);
	DDX_Control(pDX, IDC_BUTTONS, m_ButtonsButton);
	DDX_Control(pDX, IDC_EDITSCENE, m_EditButton);
	DDX_Control(pDX, IDC_NEWSCENE, m_NewSceneButton);
	DDX_Control(pDX, IDC_SAVEBUTTON, m_SaveButton);
	DDX_Control(pDX, IDC_EDIT4, m_SceneName);
	DDX_Control(pDX, IDC_EDIT3, m_FieldSceneID);
	DDX_Control(pDX, IDC_CHECK1, m_ShowOnTop);
	DDX_Control(pDX, IDC_EDIT2, m_TextName);
	DDX_Control(pDX, IDC_EDIT1, m_FilePath);
	DDX_Control(pDX, IDC_LIST1, m_SceneList);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CSceneDialog, CDialog)
	//{{AFX_MSG_MAP(CSceneDialog)
	ON_WM_SHOWWINDOW()
	ON_LBN_SELCHANGE(IDC_LIST1, OnSelchangeSceneList)
	ON_BN_CLICKED(IDC_EDITSCENE, OnEditscene)
	ON_BN_CLICKED(IDC_NEWSCENE, OnNewscene)
	ON_BN_CLICKED(IDC_SAVEBUTTON, OnSavebutton)
	ON_BN_CLICKED(IDC_BUTTONS, OnButtons)
	ON_BN_CLICKED(IDC_DELETEBUTTON, OnDeletebutton)
	ON_BN_CLICKED(IDC_DEBUGBUTTON, OnDebugbutton)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

void CSceneDialog::FillSceneList(void)
{
    m_SceneList.ResetContent();

    // Populate our UI with the initial values
    VSceneList::iterator i;
    i = CurrentScenes.m_gVSceneList.begin();
    for(int j = 0; j < CurrentScenes.m_gVSceneList.size(); j++)
    {
        m_SceneList.AddString((*i)->m_pzVSceneName);
        i++;
    }
}

void CSceneDialog::OnShowWindow(BOOL bShow, UINT nStatus) 
{
	CDialog::OnShowWindow(bShow, nStatus);

    FillSceneList();

    m_SceneList.SetCurSel(0);
    OnSelchangeSceneList();

    // Fields
    m_SceneName.SetReadOnly(true);
    m_TextName.SetReadOnly(true);
	m_FilePath.SetReadOnly(true);
    m_FieldSceneID.SetReadOnly(true);
    m_ShowOnTop.EnableWindow(false);

    // List
    m_SceneList.EnableWindow(true);

    // Buttons
    m_EditButton.EnableWindow(true);
    m_NewSceneButton.EnableWindow(true);
    m_SaveButton.EnableWindow(false);
    m_ButtonsButton.EnableWindow(true);
	m_DeleteButton.EnableWindow(true);

    bSceneChange  = false;
    bSceneNew     = false;
}

// Event when the user changes the selection in the scene list
void CSceneDialog::OnSelchangeSceneList() 
{
	// Getting the name of the scene selected
    nCurEditScene = m_SceneList.GetCurSel();
    char* pzCurrentString = new char[255];
    m_SceneList.GetText(nCurEditScene, pzCurrentString);

    // Finding the Scene in the current list of scenes
    VSceneList::iterator i;
    for(i = CurrentScenes.m_gVSceneList.begin(); i != CurrentScenes.m_gVSceneList.end(); i++)
    {
        if(strcmp((*i)->m_pzVSceneName, pzCurrentString) == 0)
        {
            // Populate the data fields
            if(strcmp((*i)->m_pzVSceneShowTop, "true") == 0)
                m_ShowOnTop.SetCheck(1);
            else
                m_ShowOnTop.SetCheck(0);
            
            m_TextName.SetWindowText((*i)->m_pzVSceneTextName);
	        m_FilePath.SetWindowText((*i)->m_pzVScenePath);
            m_FieldSceneID.SetWindowText((*i)->m_pzVSceneID);
            m_SceneName.SetWindowText((*i)->m_pzVSceneName);
            break;
        }
    }

    m_SceneName.SetReadOnly(true);
    m_TextName.SetReadOnly(true);
	m_FilePath.SetReadOnly(true);
    m_FieldSceneID.SetReadOnly(true);
    m_ShowOnTop.EnableWindow(false);
    
    m_SceneList.EnableWindow(true);

    delete [] pzCurrentString;
}

void CSceneDialog::OnEditscene() 
{
	// Text fields
    m_SceneName.SetReadOnly(false);
    m_TextName.SetReadOnly(false);
	m_FilePath.SetReadOnly(false);
    m_FieldSceneID.SetReadOnly(false);
    m_ShowOnTop.EnableWindow(true);

    // Scene list
    m_SceneList.EnableWindow(false);

    // Buttons
    m_EditButton.EnableWindow(false);
    m_NewSceneButton.EnableWindow(false);
    m_SaveButton.EnableWindow(true);
    m_ButtonsButton.EnableWindow(false);
	m_DeleteButton.EnableWindow(false);
    
    bSceneChange  = true;
}

void CSceneDialog::OnNewscene() 
{
	// Text fields
    m_SceneName.SetReadOnly(false);
    m_SceneName.SetWindowText("");
    m_TextName.SetReadOnly(false);
    m_TextName.SetWindowText("");
	m_FilePath.SetReadOnly(false);
    m_FilePath.SetWindowText("");
    m_FieldSceneID.SetReadOnly(false);
    m_FieldSceneID.SetWindowText("");
    m_ShowOnTop.EnableWindow(true);
    m_ShowOnTop.SetCheck(true);

    // Scene list
    m_SceneList.EnableWindow(false);
    m_SceneList.SetCurSel(-1);

    // Buttons
    m_EditButton.EnableWindow(false);
    m_NewSceneButton.EnableWindow(false);
    m_SaveButton.EnableWindow(true);
    m_ButtonsButton.EnableWindow(false);
	m_DeleteButton.EnableWindow(false);
    
    bSceneChange  = false;
    bSceneNew     = true;
}

void CSceneDialog::OnSavebutton() 
{
    // Get data from fields into an array of strings
    CString textString[5];
    if(m_ShowOnTop.GetCheck())
        textString[0] = "true";
    else
        textString[0] = "false";

    m_TextName.GetWindowText(textString[1]);
	m_FilePath.GetWindowText(textString[2]);
    m_FieldSceneID.GetWindowText(textString[3]);
    m_SceneName.GetWindowText(textString[4]);

    // If only editing existing data, plug back into data structure
    if(bSceneChange)
    {
        // Save any edits if any
        char* pzEditedScene = new char[255];
        m_SceneList.GetText(nCurEditScene, pzEditedScene);
        VSceneList::iterator j;
        for(j = CurrentScenes.m_gVSceneList.begin(); j != CurrentScenes.m_gVSceneList.end(); j++)
        {
            if(strcmp((*j)->m_pzVSceneName, pzEditedScene) == 0)
            {
                (*j)->m_pzVSceneShowTop  = textString[0];
                (*j)->m_pzVSceneTextName = textString[1];
                (*j)->m_pzVScenePath     = textString[2];
                (*j)->m_pzVSceneID       = textString[3];
                (*j)->m_pzVSceneName     = textString[4];
                break;
            }
        }
		delete [] pzEditedScene;
    }
    
    // If adding a new scene, create the scene, and insert it into the list
    else if(bSceneNew)
    {
        VScene *newScene = new VScene();
        newScene->m_pzVSceneShowTop  = textString[0];
        newScene->m_pzVSceneTextName = textString[1];
        newScene->m_pzVScenePath     = textString[2];
        newScene->m_pzVSceneID       = textString[3];
        newScene->m_pzVSceneName     = textString[4];

        CurrentScenes.m_gVSceneList.push_back(newScene);
    }

    // Update list based on changes, and move selection to proper item
    FillSceneList();
    nCurEditScene = m_SceneList.FindString(0, textString[4]);
    m_SceneList.SetCurSel(nCurEditScene);
    OnSelchangeSceneList();

	// Text fields
    m_SceneName.SetReadOnly(true);
    m_TextName.SetReadOnly(true);
	m_FilePath.SetReadOnly(true);
    m_FieldSceneID.SetReadOnly(true);
    m_ShowOnTop.EnableWindow(false);

    // Scene list
    m_SceneList.EnableWindow(true);

    // Buttons
    m_EditButton.EnableWindow(true);
    m_NewSceneButton.EnableWindow(true);
    m_SaveButton.EnableWindow(false);
    m_ButtonsButton.EnableWindow(true);
	m_DeleteButton.EnableWindow(true);

    bSceneChange  = false;
    bSceneNew     = false;
}

void CSceneDialog::OnOK() 
{
	if(bSceneChange || bSceneNew)
        OnSavebutton(); 
	
	CDialog::OnOK();

    CurrentScenes.writeButtonNames("..\\xodashlib\\ButtonName.h");
    CurrentScenes.writeButtonIds("..\\xodashlib\\ButtonId.h");
    CurrentScenes.writeButtonHelp("..\\xodashlib\\ButtonHelp.h");
    CurrentScenes.writeNavDesc("..\\XODashMain\\NavigationDesc.cpp");
    CurrentScenes.writeNavMap("..\\XODashMain\\NavigationMap.cpp");
    CurrentScenes.writeSceneNames("..\\xodashlib\\SceneName.h");
    CurrentScenes.writeSceneIds("..\\xodashlib\\SceneId.h");
    CurrentScenes.writeScenesToLoad("..\\media\\scenetoload.csv");
}

void CSceneDialog::OnCancel() 
{
	CDialog::OnCancel();
}

void CSceneDialog::OnButtons() 
{
	// Display the Button Dialog box now that we are initialized with a scene
	CButtonDialog *buttonDlg;
    buttonDlg = new CButtonDialog();
	buttonDlg->getSceneCollection(&CurrentScenes);

	// Getting the name of the scene selected
    nCurEditScene = m_SceneList.GetCurSel();
    CString pzCurrentString;
    m_SceneList.GetText(nCurEditScene, pzCurrentString);
	buttonDlg->getSelectedScene(pzCurrentString);

    buttonDlg->DoModal();

	delete buttonDlg;
}

void CSceneDialog::OnDeletebutton() 
{
	// Getting the name of the scene selected
    nCurEditScene = m_SceneList.GetCurSel();
    CString pzCurrentString;
    m_SceneList.GetText(nCurEditScene, pzCurrentString);

    // Finding the Scene in the current list of scenes
    VSceneList::iterator i;
    for(i = CurrentScenes.m_gVSceneList.begin(); i != CurrentScenes.m_gVSceneList.end(); i++)
    {
        if(strcmp((*i)->m_pzVSceneName, pzCurrentString) == 0)
        {
			// Remove the Scene element from the data structure
			delete (*i);
			CurrentScenes.m_gVSceneList.remove(*i);
            break;
        }
    }

	FillSceneList();
    nCurEditScene = 0;
    m_SceneList.SetCurSel(nCurEditScene);
    OnSelchangeSceneList();
}

BOOL CSceneDialog::OnInitDialog() 
{
	CDialog::OnInitDialog();
	
    // Check first to see if the scene and button files are checked out 
    if(CheckSceneFiles())
    {
        // Files are not checked out yet
        ShellExecute(GetSafeHwnd(), "open", "checkout.bat", "", NULL, SW_SHOW );
    }

    // Load up our scenes
    CurrentScenes.initalize();
    bSceneChange  = false;
    bSceneNew     = false;
    nCurEditScene = 0;
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CSceneDialog::OnDebugbutton() 
{
    VButtonList::iterator j;
    for(j = CurrentScenes.m_gVButtonList.begin(); j != CurrentScenes.m_gVButtonList.end(); j++)
    {
        // for every scenes button, print out the name to the debugger
        CString outputStr;
        outputStr.Format("%s\n", (*j)->m_pVButtonName);
        OutputDebugString(outputStr);
    }
    OutputDebugString("\n\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\xodash\XODashBuilder\Scene.cpp ===
#include "stdafx.h"
#include "scene.h"

// VButton Class Member Functions

VButton::VButton()
{
}

VButton::~VButton()
{
    m_pVButtonName.Empty();
    m_pVButtonID.Empty();
    m_pVHelpText.Empty();
}

// VButton Class Member Functions

VButtonScene::VButtonScene()
{
    m_pVButton = NULL;
}

VButtonScene::~VButtonScene()
{
    m_pVButton = NULL;
    m_pVButtonLink.Empty();
}

// VScene Class Member Functions

VScene::VScene()
{
    m_VButtonList.clear();
}

VScene::~VScene()
{
    m_pzVSceneName.Empty();
    m_pzVSceneID.Empty();
    m_pzVScenePath.Empty();
    m_pzVSceneTextName.Empty();
    m_pzVSceneShowTop.Empty();
    m_pzVButtonFocus.Empty();

	// Clean up the buttons
	VButtonSceneList::iterator i;
	for(i = m_VButtonList.begin(); i != m_VButtonList.end(); i++)
	{
        delete (*i);
	}
    m_VButtonList.clear();
}

// VSceneCollection Member Functions

VSceneCollection::VSceneCollection()
{
    m_gVSceneList.clear();
}

VSceneCollection::~VSceneCollection()
{

	// Clean up the Global Button list
	VButtonList::iterator i;
	for(i = m_gVButtonList.begin(); i != m_gVButtonList.end(); i++)
	{
	    delete (*i);
	}
    m_gVButtonList.clear();

	// Clean up the Scenes
	VSceneList::iterator j;
	for(j = m_gVSceneList.begin(); j != m_gVSceneList.end(); j++)
    {
		delete (*j);
	}
    m_gVSceneList.clear();
}

HRESULT ReadList(char *fileName, VStringList *buttonList)
{
    HRESULT retVal = S_OK;

    // Load the button name structure
    HANDLE nameFile = CreateFile(fileName,
                                 GENERIC_READ,
                                 FILE_SHARE_READ,
                                 NULL,
                                 OPEN_EXISTING,
                                 FILE_ATTRIBUTE_NORMAL,
                                 NULL);

    DWORD dwSize = GetFileSize(nameFile, NULL);

    char *pInputBuffer = new char[dwSize + 1];
    DWORD numRead = 0;

    ReadFile(nameFile, pInputBuffer, dwSize, &numRead, NULL);
    pInputBuffer[dwSize] = '\0';

    // Now that we have the file loaded into inputBuffer, remove everything
    // before and after the { }
    int nBeginStringPos = strcspn( pInputBuffer, "{" );

    // Get a pointer to the beginning of the text we care about
    char *pCleanString = pInputBuffer + nBeginStringPos + 1;

    char seps[] = ",\t\n\r\" ;}";
    char *token;

    token = strtok( pCleanString, seps );
    while( token != NULL )
    {
        // Add the token to the linked list
        if((strncmp("/*", token, 2) != 0) &&
           (strcmp("_T(", token) != 0) &&
           (strcmp(")", token) != 0) &&
           (strcmp("eNullButtonId", token) != 0) &&
           (strcmp("eNullSceneId", token) != 0) &&
           (strcmp("=", token) != 0) &&
           (strcmp("-1", token) != 0) &&
           (strcmp("eLastButtonId", token) != 0) &&
           (strcmp("eLastSceneId", token) != 0))
        { 
            CString newToken;
            newToken = token;
            buttonList->push_back(newToken);
        }
        
        // Get the next token
        token = strtok( NULL, seps );
    }

    delete [] pInputBuffer;
    CloseHandle(nameFile);

    return retVal;
}

HRESULT VSceneCollection::initalizeButtons(void)
{
    HRESULT retVal = S_OK;

    VStringList VButtonNames;
    VStringList VButtonIds;
    VStringList VButtonHelp;

    // Load the button names from the include files
    retVal = ReadList("..\\xodashlib\\ButtonName.h", &VButtonNames);
    retVal = ReadList("..\\xodashlib\\ButtonId.h", &VButtonIds);
    retVal = ReadList("..\\xodashlib\\ButtonHelp.h", &VButtonHelp);

    // Populate the Button Structure
    VStringList::iterator i;
    VStringList::iterator j;
    VStringList::iterator k;

	i = VButtonNames.begin();
	j = VButtonIds.begin();
	k = VButtonHelp.begin();

    for(int x = 0; x < VButtonNames.size(); x++)
    {
        VButton *newButton = new VButton();

        newButton->m_pVButtonName = (*i);
        newButton->m_pVButtonID   = (*j);
        newButton->m_pVHelpText   = (*k);
        (*i).Empty();
        (*j).Empty();
        (*k).Empty();
        i++; j++; k++;

        m_gVButtonList.push_back(newButton);
    }

	VButtonNames.clear();
    VButtonIds.clear();
    VButtonHelp.clear();

    return retVal;
}

HRESULT VSceneCollection::initalizeScenes(void)
{
    HRESULT retVal = S_OK;

    VStringList VSceneNames;
    VStringList VSceneIds;

    // Load the button names from the include files
    retVal = ReadList("..\\xodashlib\\SceneName.h", &VSceneNames);
    retVal = ReadList("..\\xodashlib\\SceneId.h", &VSceneIds);

    // Populate the Button Structure
    VStringList::iterator i;
    VStringList::iterator j;

	i = VSceneNames.begin();
	j = VSceneIds.begin();

    for(int x = 0; x < VSceneNames.size(); x++)
    {
        VScene *newScene = new VScene();

        newScene->m_pzVSceneName = (*i);
        newScene->m_pzVSceneID   = (*j);
        (*i).Empty();
        (*j).Empty();
        i++; j++;

        m_gVSceneList.push_back(newScene);
    }

	VSceneNames.clear();
    VSceneIds.clear();

    return retVal;
}

HRESULT VSceneCollection::readNavMap(void)
{
    HRESULT retVal = S_OK;

    // Load the button name structure
    HANDLE nameFile = CreateFile("..\\XODashMain\\NavigationMap.cpp",
                                 GENERIC_READ,
                                 FILE_SHARE_READ,
                                 NULL,
                                 OPEN_EXISTING,
                                 FILE_ATTRIBUTE_NORMAL,
                                 NULL);

    DWORD dwSize = GetFileSize(nameFile, NULL);

    char *pInputBuffer = new char[dwSize + 1];
    DWORD numRead = 0;

    ReadFile(nameFile, pInputBuffer, dwSize, &numRead, NULL);
    pInputBuffer[dwSize] = '\0';

    // Now that we have the file loaded into inputBuffer, remove everything
    // before the first { 
    int nBeginStringPos = strcspn( pInputBuffer, "{" );

    // Get a pointer to the beginning of the text we care about
    char *pCleanString = pInputBuffer + nBeginStringPos + 1;

    char seps[] = "{,\t\n\r ;";
    char *token;
    int  currentState = 0;    // current state tracks the naviation map data
    VSceneList::iterator i;  // our current scene
    i = m_gVSceneList.begin();

    VButtonSceneList::iterator j;  // our current button in the scene

    token = strtok( pCleanString, seps );
    while( token != NULL )
    {
        if(strcmp(token, "}") == 0)
        {
            currentState++;
            if(currentState > 2)
            {
                currentState = 0;
                i++; // next scene
                token = strtok( NULL, seps );
            }
            
            token = strtok( NULL, seps );

            if( strcmp("eLastSceneId", token) == 0)  // we are at the end of the navigation links
            {
                break;
            }

            j = (*i)->m_VButtonList.begin();
        }

        // Reading out the comments
        if(strcmp(token, "/*") == 0)
        {
            while(strcmp(token, "*/") != 0)
            {
                token = strtok( NULL, seps );
            }      
            // Get the next appropriate token
            token = strtok( NULL, seps );
        }

        if(currentState == 0)  // we are reading the links
        {
            if(strcmp("eLastSceneId", token) == 0)
            {
                break;  // we are finished reading the navigation links
            }

            // Add the button to the scene and save the link
            VButtonScene *newButton = new VButtonScene();
            newButton->m_pVButtonLink = token;
        
            (*i)->m_VButtonList.push_back(newButton);
        }

        if(currentState == 1) // we are reading in the buttons for the scene
        {
            // find the cooresponding button in our global list
            if( strcmp("eNullButtonId", token) == 0)
            {
				// we are at the last button, so remove it's reference
				delete (*j);
				(*i)->m_VButtonList.remove(*j);
            }
            else
            {
                VButtonList::iterator x;
                for(x = m_gVButtonList.begin(); x != m_gVButtonList.end(); x++)
                {
                    if((*x)->m_pVButtonID.Compare(token) == 0)
                    {
                        // found the button reference in our global list, point to it!
                        (*j)->m_pVButton = (*x);

                        break;
                    }
                }
                j++; // next button
            }
        }   

        // Get the next token
        token = strtok( NULL, seps );
    }

    delete [] pInputBuffer;
    CloseHandle(nameFile);

    return retVal;
}

HRESULT VSceneCollection::readNavDesc(void)
{
    HRESULT retVal = S_OK;

    // Load the button name structure
    HANDLE nameFile = CreateFile("..\\XODashMain\\NavigationDesc.cpp",
                                 GENERIC_READ,
                                 FILE_SHARE_READ,
                                 NULL,
                                 OPEN_EXISTING,
                                 FILE_ATTRIBUTE_NORMAL,
                                 NULL);

    DWORD dwSize = GetFileSize(nameFile, NULL);

    char *pInputBuffer = new char[dwSize + 1];
    DWORD numRead = 0;

    ReadFile(nameFile, pInputBuffer, dwSize, &numRead, NULL);

    // Now that we have the file loaded into inputBuffer, remove everything
    // before the first { 
    int nBeginStringPos = strcspn( pInputBuffer, "{" );

    // Get a pointer to the beginning of the text we care about
    char *pCleanString = pInputBuffer + nBeginStringPos + 1;

    char seps[] = "{,\t\n\r\" ;}";
    char *token;

    VSceneList::iterator i;  // our current scene
    i = m_gVSceneList.begin();

    token = strtok( pCleanString, seps );
    while( token != NULL )
    {

        // Reading out the comments
        if(strcmp(token, "/*") == 0)
        {
            while(strcmp(token, "*/") != 0)
            {
                token = strtok( NULL, seps );
            }      
            // Get the next appropriate token
            token = strtok( NULL, seps );
        }

        // Ignore the ANSI header
        if(strcmp("NULL", token) == 0)  // The end of the scenes
        {
            break;
        }

        // Read in the scene path
        token = strtok( NULL, seps );
        (*i)->m_pzVScenePath = token;

        // Read in the text name
        token = strtok( NULL, seps );
        (*i)->m_pzVSceneTextName = token;

        // Read in the top value
        token = strtok( NULL, seps );
        (*i)->m_pzVSceneShowTop = token;

        // Pass the NULL token
        token = strtok( NULL, seps );

        // Get the Button Focus
        token = strtok( NULL, seps );
        (*i)->m_pzVButtonFocus = token;

        i++;

        // Get the next token
        token = strtok( NULL, seps );
    }

    delete [] pInputBuffer;
    CloseHandle(nameFile);

    return retVal;
}

HRESULT VSceneCollection::initalize(void)
{
    HRESULT retVal = S_OK;
    
    initalizeButtons();
    initalizeScenes();
    readNavMap();
    readNavDesc();
    
    return retVal;
}

void WriteFilePragma(HANDLE nameFile)
{
    // Write file Pragma Header
    unsigned long numWrite;
    CString outputBuffer = "//Copyright (c) Microsoft Corporation.  All rights reserved.\n\n#pragma once\n\n";
    WriteFile(nameFile, outputBuffer, strlen(outputBuffer), &numWrite, NULL);
}

void WriteCopyRight(HANDLE nameFile)
{
    // Write file Pragma Header
    unsigned long numWrite;
    CString outputBuffer = "//Copyright (c) Microsoft Corporation.  All rights reserved.\n\n";
    WriteFile(nameFile, outputBuffer, strlen(outputBuffer), &numWrite, NULL);
}

HRESULT VSceneCollection::writeButtonNames(char *fileName)
{
    HRESULT retVal = S_OK;
    unsigned long numWrite = 0;

    // Load the button name structure
    HANDLE nameFile = CreateFile(fileName,
                                 GENERIC_WRITE,
                                 FILE_SHARE_WRITE,
                                 NULL,
                                 CREATE_ALWAYS,
                                 FILE_ATTRIBUTE_NORMAL,
                                 NULL);

    WriteFilePragma(nameFile);

    // Write file Header
    CString outputBuffer = "static char* ButtonName[] = \n{\n";
    WriteFile(nameFile, outputBuffer, strlen(outputBuffer), &numWrite, NULL);

    VButtonList::iterator j;
    for(j = m_gVButtonList.begin(); j != m_gVButtonList.end(); j++)
    {
        // for every scenes button, print out the name into a file
        CString outputStr;
        outputStr.Format("\t\"%s\",\n", (*j)->m_pVButtonName);
        WriteFile(nameFile, outputStr, outputStr.GetLength(), &numWrite, NULL);
    }

    WriteFile(nameFile, "};", strlen("};"), &numWrite, NULL);

    CloseHandle(nameFile);

    return retVal;
}

HRESULT VSceneCollection::writeButtonIds(char *fileName)
{
    HRESULT retVal = S_OK;
    unsigned long numWrite = 0;

    // Load the button name structure
    HANDLE nameFile = CreateFile(fileName,
                                 GENERIC_WRITE,
                                 FILE_SHARE_WRITE,
                                 NULL,
                                 CREATE_ALWAYS,
                                 FILE_ATTRIBUTE_NORMAL,
                                 NULL);

    WriteFilePragma(nameFile);

    // Write file Header
    CString outputBuffer = "enum eButtonId\n{\n\teNullButtonId = -1,\n";
    WriteFile(nameFile, outputBuffer, strlen(outputBuffer), &numWrite, NULL);

    VButtonList::iterator j;
    for(j = m_gVButtonList.begin(); j != m_gVButtonList.end(); j++)
    {
        // for every scenes button, print out the name into a file
        char outputStr[255];
        sprintf(outputStr, "\t%s,\n", (*j)->m_pVButtonID);
        WriteFile(nameFile, outputStr, strlen(outputStr), &numWrite, NULL);
    }

    WriteFile(nameFile, "\teLastButtonId\n};", strlen("\teLastButtonId\n};"), &numWrite, NULL);

    CloseHandle(nameFile);

    return retVal;
}

HRESULT VSceneCollection::writeButtonHelp(char *fileName)
{
    HRESULT retVal = S_OK;
    unsigned long numWrite = 0;

    // Load the button name structure
    HANDLE nameFile = CreateFile(fileName,
                                 GENERIC_WRITE,
                                 FILE_SHARE_WRITE,
                                 NULL,
                                 CREATE_ALWAYS,
                                 FILE_ATTRIBUTE_NORMAL,
                                 NULL);

    WriteFilePragma(nameFile);

    // Write file Header
    CString outputBuffer = "static TCHAR* ButtonHelpText[] =\n{\n";
    WriteFile(nameFile, outputBuffer, strlen(outputBuffer), &numWrite, NULL);

    VButtonList::iterator j;
    for(j = m_gVButtonList.begin(); j != m_gVButtonList.end(); j++)
    {
        // for every scenes button, print out the name into a file
        CString outputStr;
        outputStr.Format("\t/*%s*/\n\t_T(\"%s\"),\n", (*j)->m_pVButtonName, (*j)->m_pVHelpText);
        WriteFile(nameFile, outputStr, outputStr.GetLength(), &numWrite, NULL);
    }

    WriteFile(nameFile, "};", strlen("};"), &numWrite, NULL);

    CloseHandle(nameFile);

    return retVal;
}

HRESULT VSceneCollection::writeNavDesc(char *fileName)
{
    HRESULT retVal = S_OK;
    unsigned long numWrite = 0;

    // Load the button name structure
    HANDLE nameFile = CreateFile(fileName,
                                 GENERIC_WRITE,
                                 FILE_SHARE_WRITE,
                                 NULL,
                                 CREATE_ALWAYS,
                                 FILE_ATTRIBUTE_NORMAL,
                                 NULL);

    WriteCopyRight(nameFile);

    // Write file Header
    CString outputBuffer = "CSceneNavigator* CSceneNavigator::pinstance = 0;\nSceneDescription CSceneNavigator::m_SceneDataMap[] = \n{\n";
    WriteFile(nameFile, outputBuffer, strlen(outputBuffer), &numWrite, NULL);

    VSceneList::iterator j;
    for(j = m_gVSceneList.begin(); j != m_gVSceneList.end(); j++)
    {
        // Dump out some comments
        CString szSceneComments;
        szSceneComments.Format("\n\t/* %s Scene */\n", (*j)->m_pzVSceneName);
        WriteFile(nameFile, szSceneComments, strlen(szSceneComments), &numWrite, NULL);

        WriteFile(nameFile, "\t{\n\t\t", strlen("\t{\n\t\t"), &numWrite, NULL);

        // for every scenes button, print out the name into a file
        char outputStr[255];
        sprintf(outputStr, "XBG_PATH_ANSI\"%s\", \"%s\", %s, NULL, %s\n", (*j)->m_pzVScenePath, (*j)->m_pzVSceneTextName, (*j)->m_pzVSceneShowTop, (*j)->m_pzVButtonFocus );
        WriteFile(nameFile, outputStr, strlen(outputStr), &numWrite, NULL);

        WriteFile(nameFile, "\t},\n", strlen("\t},\n"), &numWrite, NULL);
    }

    CString closeBuffer = "\t{ NULL, false, NULL },\n};";
    WriteFile(nameFile, closeBuffer, strlen(closeBuffer), &numWrite, NULL);

    CloseHandle(nameFile);

    return retVal;
}

HRESULT VSceneCollection::writeNavMap(char *fileName)
{
    HRESULT retVal = S_OK;
    unsigned long numWrite = 0;

    // Load the button name structure
    HANDLE nameFile = CreateFile(fileName,
                                 GENERIC_WRITE,
                                 FILE_SHARE_WRITE,
                                 NULL,
                                 CREATE_ALWAYS,
                                 FILE_ATTRIBUTE_NORMAL,
                                 NULL);

    WriteCopyRight(nameFile);

    // Write file Header
    CString outputBuffer = "SceneChild CSceneNavigator::m_SceneHierarchy[] =\n{\n";
    WriteFile(nameFile, outputBuffer, strlen(outputBuffer), &numWrite, NULL);

    VSceneList::iterator j;
    for(j = m_gVSceneList.begin(); j != m_gVSceneList.end(); j++)
    {
        // Dump out some comments
        CString szSceneComments;
        szSceneComments.Format("\n\t/* %s Scene */\n", (*j)->m_pzVSceneName);
        WriteFile(nameFile, szSceneComments, strlen(szSceneComments), &numWrite, NULL);

        WriteFile(nameFile, "\t{\n\t\t", strlen("\t{\n\t\t"), &numWrite, NULL);

        // Write out the links
        WriteFile(nameFile, "{ ", strlen("{ "), &numWrite, NULL);
        VButtonSceneList::iterator i;
        for(i = (*j)->m_VButtonList.begin(); i != (*j)->m_VButtonList.end(); i++)
        {
            char outputStr[255];
            sprintf(outputStr, "%s, ", (*i)->m_pVButtonLink);
            WriteFile(nameFile, outputStr, strlen(outputStr), &numWrite, NULL);
        }
        WriteFile(nameFile, "eNullSceneId },\n", strlen("eNullSceneId },\n"), &numWrite, NULL);

        // Write out the buttons
        WriteFile(nameFile, "\t\t{ ", strlen("\t\t{ "), &numWrite, NULL);
        for(i = (*j)->m_VButtonList.begin(); i != (*j)->m_VButtonList.end(); i++)
        {
            char outputStr[255];
            sprintf(outputStr, "%s, ", (*i)->m_pVButton->m_pVButtonID);
            WriteFile(nameFile, outputStr, strlen(outputStr), &numWrite, NULL);
        }
        WriteFile(nameFile, "eNullButtonId },\n", strlen("eNullButtonId },\n"), &numWrite, NULL);

        // Write out the callbacks
        WriteFile(nameFile, "\t\t{ ", strlen("\t\t{ "), &numWrite, NULL);
        for(int x = 0; x < (*j)->m_VButtonList.size(); x++)
        {
            WriteFile(nameFile, "NULL, ", strlen("NULL, "), &numWrite, NULL);
        }
        WriteFile(nameFile, "NULL }\n\t},\n", strlen("NULL }\n\t},\n"), &numWrite, NULL);
    }

    CString closeBuffer = "\t{\n\t\t{ eLastSceneId },\n\t\t{ eNullButtonId },\n\t\t{ NULL }\n\t}\n};";
    WriteFile(nameFile, closeBuffer, strlen(closeBuffer), &numWrite, NULL);

    CloseHandle(nameFile);

    return retVal;
}

HRESULT VSceneCollection::writeSceneNames(char *fileName)
{
    HRESULT retVal = S_OK;
    unsigned long numWrite = 0;

    // Load the button name structure
    HANDLE nameFile = CreateFile(fileName,
                                 GENERIC_WRITE,
                                 FILE_SHARE_WRITE,
                                 NULL,
                                 CREATE_ALWAYS,
                                 FILE_ATTRIBUTE_NORMAL,
                                 NULL);

    WriteFilePragma(nameFile);

    // Write file Header
    CString outputBuffer = "static char* SceneName[] = \n{\n";
    WriteFile(nameFile, outputBuffer, strlen(outputBuffer), &numWrite, NULL);

    VSceneList::iterator j;
    for(j = m_gVSceneList.begin(); j != m_gVSceneList.end(); j++)
    {
        // for every scenes button, print out the name into a file
        char outputStr[255];
        sprintf(outputStr, "\t\"%s\",\n", (*j)->m_pzVSceneName);
        WriteFile(nameFile, outputStr, strlen(outputStr), &numWrite, NULL);
    }

    WriteFile(nameFile, "};", strlen("};"), &numWrite, NULL);

    CloseHandle(nameFile);

    return retVal;
}

HRESULT VSceneCollection::writeSceneIds(char *fileName)
{
    HRESULT retVal = S_OK;
    unsigned long numWrite = 0;

    // Load the button name structure
    HANDLE nameFile = CreateFile(fileName,
                                 GENERIC_WRITE,
                                 FILE_SHARE_WRITE,
                                 NULL,
                                 CREATE_ALWAYS,
                                 FILE_ATTRIBUTE_NORMAL,
                                 NULL);

    WriteFilePragma(nameFile);

    // Write file Header
    CString outputBuffer = "enum eSceneId\n{\n\teNullSceneId = -1,\n";
    WriteFile(nameFile, outputBuffer, strlen(outputBuffer), &numWrite, NULL);

    VSceneList::iterator j;
    for(j = m_gVSceneList.begin(); j != m_gVSceneList.end(); j++)
    {
        // for every scenes button, print out the name into a file
        char outputStr[255];
        sprintf(outputStr, "\t%s,\n", (*j)->m_pzVSceneID);
        WriteFile(nameFile, outputStr, strlen(outputStr), &numWrite, NULL);
    }

    WriteFile(nameFile, "\teLastSceneId\n};", strlen("\teLastButtonId\n};"), &numWrite, NULL);

    CloseHandle(nameFile);

    return retVal;
}

HRESULT VSceneCollection::writeScenesToLoad(char *fileName)
{
    HRESULT retVal = S_OK;
    unsigned long numWrite = 0;

    // Load the button name structure
    HANDLE nameFile = CreateFile(fileName,
                                 GENERIC_WRITE,
                                 FILE_SHARE_WRITE,
                                 NULL,
                                 CREATE_ALWAYS,
                                 FILE_ATTRIBUTE_NORMAL,
                                 NULL);

    // Create an array to see if the scene has been written out yet
    bool *bWriteCheck;
    bWriteCheck = new bool[m_gVSceneList.size()];

    for(int i = 0; i < m_gVSceneList.size(); i++)
    {
        bWriteCheck[i] = true;
    }

    int nCurrentCheck = 0;
    VSceneList::iterator j;
    for(j = m_gVSceneList.begin(); j != m_gVSceneList.end(); j++)
    {
        // for every scenes button, print out the name into a file
        if(bWriteCheck[nCurrentCheck])
        {
            char outputStr[255];
            CString szScenePath = (*j)->m_pzVScenePath;
            sprintf(outputStr, "%s", szScenePath.Left(szScenePath.GetLength() - 4));
            WriteFile(nameFile, outputStr, strlen(outputStr), &numWrite, NULL);

            // Now write out all scenes that share that filename
            int nCheckFile = 0;
            VSceneList::iterator k;
            for(k = m_gVSceneList.begin(); k != m_gVSceneList.end(); k++)
            {
                if(strcmp((*k)->m_pzVScenePath, (*j)->m_pzVScenePath) == 0)
                {
                    CString szOutputStr;
                    szOutputStr.Format(",%s", (*k)->m_pzVSceneTextName);
                    WriteFile(nameFile, szOutputStr, strlen(szOutputStr), &numWrite, NULL);
                    bWriteCheck[nCheckFile] = false;
                }
                nCheckFile++;
            }
            WriteFile(nameFile, "\n", strlen("\n"), &numWrite, NULL);
        }
        
        nCurrentCheck++;
    }
    
    CloseHandle(nameFile);

    delete [] bWriteCheck;

    return retVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\xodash\XODashBuilder\StdAfx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	XODashBuilder.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\xodash\XODashBuilder\StdAfx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__16440695_944D_4C9C_AA60_EE7DBB7D240E__INCLUDED_)
#define AFX_STDAFX_H__16440695_944D_4C9C_AA60_EE7DBB7D240E__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxole.h>         // MFC OLE classes
#include <afxodlgs.h>       // MFC OLE dialog classes
#include <afxdtctl.h>		// MFC support for Internet Explorer 4 Common Controls
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__16440695_944D_4C9C_AA60_EE7DBB7D240E__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\xodash\XODashBuilder\XODashBuilder.cpp ===
// XODashBuilder.cpp : Defines the class behaviors for the application.
//

#include "stdafx.h"
#include "XODashBuilder.h"

#include "MainFrm.h"
#include "XODashBuilderDoc.h"
#include "XODashBuilderView.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CXODashBuilderApp

BEGIN_MESSAGE_MAP(CXODashBuilderApp, CWinApp)
	//{{AFX_MSG_MAP(CXODashBuilderApp)
	ON_COMMAND(ID_APP_ABOUT, OnAppAbout)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG_MAP
	// Standard file based document commands
	ON_COMMAND(ID_FILE_NEW, CWinApp::OnFileNew)
	ON_COMMAND(ID_FILE_OPEN, CWinApp::OnFileOpen)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CXODashBuilderApp construction

CXODashBuilderApp::CXODashBuilderApp()
{
	// TODO: add construction code here,
	// Place all significant initialization in InitInstance
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CXODashBuilderApp object

CXODashBuilderApp theApp;

/////////////////////////////////////////////////////////////////////////////
// CXODashBuilderApp initialization

BOOL CXODashBuilderApp::InitInstance()
{
	// Initialize OLE libraries
	if (!AfxOleInit())
	{
		AfxMessageBox(IDP_OLE_INIT_FAILED);
		return FALSE;
	}

	// Standard initialization
	// If you are not using these features and wish to reduce the size
	//  of your final executable, you should remove from the following
	//  the specific initialization routines you do not need.

#ifdef _AFXDLL
	Enable3dControls();			// Call this when using MFC in a shared DLL
#else
	Enable3dControlsStatic();	// Call this when linking to MFC statically
#endif

	// Change the registry key under which our settings are stored.
	// TODO: You should modify this string to be something appropriate
	// such as the name of your company or organization.
	SetRegistryKey(_T("Local AppWizard-Generated Applications"));

	LoadStdProfileSettings();  // Load standard INI file options (including MRU)

	// Register the application's document templates.  Document templates
	//  serve as the connection between documents, frame windows and views.

	CSingleDocTemplate* pDocTemplate;
	pDocTemplate = new CSingleDocTemplate(
		IDR_MAINFRAME,
		RUNTIME_CLASS(CXODashBuilderDoc),
		RUNTIME_CLASS(CMainFrame),       // main SDI frame window
		RUNTIME_CLASS(CXODashBuilderView));
	pDocTemplate->SetContainerInfo(IDR_CNTR_INPLACE);
	AddDocTemplate(pDocTemplate);

	// Parse command line for standard shell commands, DDE, file open
	CCommandLineInfo cmdInfo;
	ParseCommandLine(cmdInfo);

	// Dispatch commands specified on the command line
	if (!ProcessShellCommand(cmdInfo))
		return FALSE;

	// The one and only window has been initialized, so show and update it.
	m_pMainWnd->ShowWindow(SW_SHOW);
	m_pMainWnd->UpdateWindow();

	return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
// CAboutDlg dialog used for App About

class CAboutDlg : public CDialog
{
public:
	CAboutDlg();

// Dialog Data
	//{{AFX_DATA(CAboutDlg)
	enum { IDD = IDD_ABOUTBOX };
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAboutDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	//{{AFX_MSG(CAboutDlg)
		// No message handlers
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

CAboutDlg::CAboutDlg() : CDialog(CAboutDlg::IDD)
{
	//{{AFX_DATA_INIT(CAboutDlg)
	//}}AFX_DATA_INIT
}

void CAboutDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAboutDlg)
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CAboutDlg, CDialog)
	//{{AFX_MSG_MAP(CAboutDlg)
		// No message handlers
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

// App command to run the dialog
void CXODashBuilderApp::OnAppAbout()
{
	CAboutDlg aboutDlg;
	aboutDlg.DoModal();
}

/////////////////////////////////////////////////////////////////////////////
// CXODashBuilderApp message handlers
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\xodash\XODashBuilder\XODashBuilderDoc.cpp ===
// XODashBuilderDoc.cpp : implementation of the CXODashBuilderDoc class
//

#include "stdafx.h"
#include "XODashBuilder.h"

#include "XODashBuilderDoc.h"
#include "CntrItem.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CXODashBuilderDoc

IMPLEMENT_DYNCREATE(CXODashBuilderDoc, COleDocument)

BEGIN_MESSAGE_MAP(CXODashBuilderDoc, COleDocument)
	//{{AFX_MSG_MAP(CXODashBuilderDoc)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG_MAP
	// Enable default OLE container implementation
	ON_UPDATE_COMMAND_UI(ID_EDIT_PASTE, COleDocument::OnUpdatePasteMenu)
	ON_UPDATE_COMMAND_UI(ID_EDIT_PASTE_LINK, COleDocument::OnUpdatePasteLinkMenu)
	ON_UPDATE_COMMAND_UI(ID_OLE_EDIT_CONVERT, COleDocument::OnUpdateObjectVerbMenu)
	ON_COMMAND(ID_OLE_EDIT_CONVERT, COleDocument::OnEditConvert)
	ON_UPDATE_COMMAND_UI(ID_OLE_EDIT_LINKS, COleDocument::OnUpdateEditLinksMenu)
	ON_COMMAND(ID_OLE_EDIT_LINKS, COleDocument::OnEditLinks)
	ON_UPDATE_COMMAND_UI_RANGE(ID_OLE_VERB_FIRST, ID_OLE_VERB_LAST, COleDocument::OnUpdateObjectVerbMenu)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CXODashBuilderDoc construction/destruction

CXODashBuilderDoc::CXODashBuilderDoc()
{
	// TODO: add one-time construction code here

}

CXODashBuilderDoc::~CXODashBuilderDoc()
{
}

BOOL CXODashBuilderDoc::OnNewDocument()
{
	if (!COleDocument::OnNewDocument())
		return FALSE;

	// TODO: add reinitialization code here
	// (SDI documents will reuse this document)

	return TRUE;
}



/////////////////////////////////////////////////////////////////////////////
// CXODashBuilderDoc serialization

void CXODashBuilderDoc::Serialize(CArchive& ar)
{
	if (ar.IsStoring())
	{
		// TODO: add storing code here
	}
	else
	{
		// TODO: add loading code here
	}

	// Calling the base class COleDocument enables serialization
	//  of the container document's COleClientItem objects.
	COleDocument::Serialize(ar);
}

/////////////////////////////////////////////////////////////////////////////
// CXODashBuilderDoc diagnostics

#ifdef _DEBUG
void CXODashBuilderDoc::AssertValid() const
{
	COleDocument::AssertValid();
}

void CXODashBuilderDoc::Dump(CDumpContext& dc) const
{
	COleDocument::Dump(dc);
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CXODashBuilderDoc commands
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\xodash\XODashBuilder\XODashBuilder.h ===
// XODashBuilder.h : main header file for the XODASHBUILDER application
//

#if !defined(AFX_XODASHBUILDER_H__AF6BEC48_71D1_4F0A_85CE_FEC9218741FA__INCLUDED_)
#define AFX_XODASHBUILDER_H__AF6BEC48_71D1_4F0A_85CE_FEC9218741FA__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CXODashBuilderApp:
// See XODashBuilder.cpp for the implementation of this class
//

class CXODashBuilderApp : public CWinApp
{
public:
	CXODashBuilderApp();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CXODashBuilderApp)
	public:
	virtual BOOL InitInstance();
	//}}AFX_VIRTUAL

// Implementation
	//{{AFX_MSG(CXODashBuilderApp)
	afx_msg void OnAppAbout();
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_XODASHBUILDER_H__AF6BEC48_71D1_4F0A_85CE_FEC9218741FA__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\xodash\XODashBuilder\XODashBuilderDoc.h ===
// XODashBuilderDoc.h : interface of the CXODashBuilderDoc class
//
/////////////////////////////////////////////////////////////////////////////

#if !defined(AFX_XODASHBUILDERDOC_H__C0195150_01F6_4BF0_9636_CD2CA79F24D0__INCLUDED_)
#define AFX_XODASHBUILDERDOC_H__C0195150_01F6_4BF0_9636_CD2CA79F24D0__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000


class CXODashBuilderDoc : public COleDocument
{
protected: // create from serialization only
	CXODashBuilderDoc();
	DECLARE_DYNCREATE(CXODashBuilderDoc)

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CXODashBuilderDoc)
	public:
	virtual BOOL OnNewDocument();
	virtual void Serialize(CArchive& ar);
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CXODashBuilderDoc();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:

// Generated message map functions
protected:
	//{{AFX_MSG(CXODashBuilderDoc)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_XODASHBUILDERDOC_H__C0195150_01F6_4BF0_9636_CD2CA79F24D0__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\xodash\XODashLib\aniso.h ===
DWORD dwAnisoVertexShader[] = {
	0x000a2078,
	0x00000000, 0x00ec001b, 0x0836186c, 0x20708800,
	0x00000000, 0x00ec201b, 0x0836186c, 0x20704800,
	0x00000000, 0x00ec401b, 0x0836186c, 0x20702800,
	0x00000000, 0x00ec601b, 0x0836186c, 0x20701800,
	0x00000000, 0x00ac861b, 0x0836186c, 0x21200ff8,
	0x00000000, 0x002e001b, 0x0c36106c, 0x2f300ff8,
	0x00000000, 0x014000ff, 0x27fe486c, 0x21400ff8,
	0x00000000, 0x008de01b, 0x35fe886c, 0x3070f818,
	0x00000000, 0x0647401b, 0xc4361bff, 0x1078e800,
	0x00000000, 0x0087601b, 0xc400286c, 0x3070e801
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\xodash\XODashBuilder\XODashBuilderView.cpp ===
// XODashBuilderView.cpp : implementation of the CXODashBuilderView class
//

#include "stdafx.h"
#include "XODashBuilder.h"

#include "XODashBuilderDoc.h"
#include "CntrItem.h"
#include "XODashBuilderView.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CXODashBuilderView

IMPLEMENT_DYNCREATE(CXODashBuilderView, CView)

BEGIN_MESSAGE_MAP(CXODashBuilderView, CView)
	//{{AFX_MSG_MAP(CXODashBuilderView)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	ON_WM_DESTROY()
	ON_WM_SETFOCUS()
	ON_WM_SIZE()
	ON_COMMAND(ID_OLE_INSERT_NEW, OnInsertObject)
	ON_COMMAND(ID_CANCEL_EDIT_CNTR, OnCancelEditCntr)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CXODashBuilderView construction/destruction

CXODashBuilderView::CXODashBuilderView()
{
	m_pSelection = NULL;
	// TODO: add construction code here

}

CXODashBuilderView::~CXODashBuilderView()
{
}

BOOL CXODashBuilderView::PreCreateWindow(CREATESTRUCT& cs)
{
	// TODO: Modify the Window class or styles here by modifying
	//  the CREATESTRUCT cs

	return CView::PreCreateWindow(cs);
}

/////////////////////////////////////////////////////////////////////////////
// CXODashBuilderView drawing

void CXODashBuilderView::OnDraw(CDC* pDC)
{
	CXODashBuilderDoc* pDoc = GetDocument();
	ASSERT_VALID(pDoc);
	// TODO: add draw code for native data here
	// TODO: also draw all OLE items in the document

	// Draw the selection at an arbitrary position.  This code should be
	//  removed once your real drawing code is implemented.  This position
	//  corresponds exactly to the rectangle returned by CXODashBuilderCntrItem,
	//  to give the effect of in-place editing.

	// TODO: remove this code when final draw code is complete.

	if (m_pSelection == NULL)
	{
		POSITION pos = pDoc->GetStartPosition();
		m_pSelection = (CXODashBuilderCntrItem*)pDoc->GetNextClientItem(pos);
	}
	if (m_pSelection != NULL)
		m_pSelection->Draw(pDC, CRect(10, 10, 210, 210));
}

void CXODashBuilderView::OnInitialUpdate()
{
	CView::OnInitialUpdate();


	// TODO: remove this code when final selection model code is written
	m_pSelection = NULL;    // initialize selection

}

void CXODashBuilderView::OnDestroy()
{
	// Deactivate the item on destruction; this is important
	// when a splitter view is being used.
   CView::OnDestroy();
   COleClientItem* pActiveItem = GetDocument()->GetInPlaceActiveItem(this);
   if (pActiveItem != NULL && pActiveItem->GetActiveView() == this)
   {
      pActiveItem->Deactivate();
      ASSERT(GetDocument()->GetInPlaceActiveItem(this) == NULL);
   }
}


/////////////////////////////////////////////////////////////////////////////
// OLE Client support and commands

BOOL CXODashBuilderView::IsSelected(const CObject* pDocItem) const
{
	// The implementation below is adequate if your selection consists of
	//  only CXODashBuilderCntrItem objects.  To handle different selection
	//  mechanisms, the implementation here should be replaced.

	// TODO: implement this function that tests for a selected OLE client item

	return pDocItem == m_pSelection;
}

void CXODashBuilderView::OnInsertObject()
{
	// Invoke the standard Insert Object dialog box to obtain information
	//  for new CXODashBuilderCntrItem object.
	COleInsertDialog dlg;
	if (dlg.DoModal() != IDOK)
		return;

	BeginWaitCursor();

	CXODashBuilderCntrItem* pItem = NULL;
	TRY
	{
		// Create new item connected to this document.
		CXODashBuilderDoc* pDoc = GetDocument();
		ASSERT_VALID(pDoc);
		pItem = new CXODashBuilderCntrItem(pDoc);
		ASSERT_VALID(pItem);

		// Initialize the item from the dialog data.
		if (!dlg.CreateItem(pItem))
			AfxThrowMemoryException();  // any exception will do
		ASSERT_VALID(pItem);
		
        if (dlg.GetSelectionType() == COleInsertDialog::createNewItem)
			pItem->DoVerb(OLEIVERB_SHOW, this);

		ASSERT_VALID(pItem);

		// As an arbitrary user interface design, this sets the selection
		//  to the last item inserted.

		// TODO: reimplement selection as appropriate for your application

		m_pSelection = pItem;   // set selection to last inserted item
		pDoc->UpdateAllViews(NULL);
	}
	CATCH(CException, e)
	{
		if (pItem != NULL)
		{
			ASSERT_VALID(pItem);
			pItem->Delete();
		}
		AfxMessageBox(IDP_FAILED_TO_CREATE);
	}
	END_CATCH

	EndWaitCursor();
}

// The following command handler provides the standard keyboard
//  user interface to cancel an in-place editing session.  Here,
//  the container (not the server) causes the deactivation.
void CXODashBuilderView::OnCancelEditCntr()
{
	// Close any in-place active item on this view.
	COleClientItem* pActiveItem = GetDocument()->GetInPlaceActiveItem(this);
	if (pActiveItem != NULL)
	{
		pActiveItem->Close();
	}
	ASSERT(GetDocument()->GetInPlaceActiveItem(this) == NULL);
}

// Special handling of OnSetFocus and OnSize are required for a container
//  when an object is being edited in-place.
void CXODashBuilderView::OnSetFocus(CWnd* pOldWnd)
{
	COleClientItem* pActiveItem = GetDocument()->GetInPlaceActiveItem(this);
	if (pActiveItem != NULL &&
		pActiveItem->GetItemState() == COleClientItem::activeUIState)
	{
		// need to set focus to this item if it is in the same view
		CWnd* pWnd = pActiveItem->GetInPlaceWindow();
		if (pWnd != NULL)
		{
			pWnd->SetFocus();   // don't call the base class
			return;
		}
	}

	CView::OnSetFocus(pOldWnd);
}

void CXODashBuilderView::OnSize(UINT nType, int cx, int cy)
{
	CView::OnSize(nType, cx, cy);
	COleClientItem* pActiveItem = GetDocument()->GetInPlaceActiveItem(this);
	if (pActiveItem != NULL)
		pActiveItem->SetItemRects();
}

/////////////////////////////////////////////////////////////////////////////
// CXODashBuilderView diagnostics

#ifdef _DEBUG
void CXODashBuilderView::AssertValid() const
{
	CView::AssertValid();
}

void CXODashBuilderView::Dump(CDumpContext& dc) const
{
	CView::Dump(dc);
}

CXODashBuilderDoc* CXODashBuilderView::GetDocument() // non-debug version is inline
{
	ASSERT(m_pDocument->IsKindOf(RUNTIME_CLASS(CXODashBuilderDoc)));
	return (CXODashBuilderDoc*)m_pDocument;
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CXODashBuilderView message handlers
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\xodash\XODashLib\Audio.h ===
#pragma once
#define TRANSPORT_STOP	0
#define TRANSPORT_PLAY	1
#define TRANSPORT_PAUSE	2

class CAudioBuf;

class CAudioClip
{

public:
	CAudioClip();
	~CAudioClip();

	TCHAR* m_url;

	void SetUrl(const TCHAR* AudioFile);

	void Play(bool bLoop = false);
	void Pause();
	void PlayOrPause();
	void Stop();

	int getMinutes();
	int getSeconds();

	void* GetSampleBuffer();
	int GetSampleBufferSize();

	HRESULT Initialize();
	HRESULT Cleanup();

protected:
	bool m_bDirty;
	float m_lastVolume;
	float m_lastPan;
	float m_lastFrequency;
	float m_lastTransportMode;
	float m_fade;
	float m_volume;
	float m_pan;
	float m_frequency;

	int m_transportMode;

	CAudioBuf* m_pSound;


	bool OpenWaveFile();

	XBOXADPCMWAVEFORMAT m_format;

	void OnIsActiveChanged();

	bool m_bLoop;
	bool m_isActive;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\xodash\XODashBuilder\XODashBuilderView.h ===
// XODashBuilderView.h : interface of the CXODashBuilderView class
//
/////////////////////////////////////////////////////////////////////////////

#if !defined(AFX_XODASHBUILDERVIEW_H__74AC8383_E147_4209_AFE5_FA7571318EF2__INCLUDED_)
#define AFX_XODASHBUILDERVIEW_H__74AC8383_E147_4209_AFE5_FA7571318EF2__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

class CXODashBuilderCntrItem;

class CXODashBuilderView : public CView
{
protected: // create from serialization only
	CXODashBuilderView();
	DECLARE_DYNCREATE(CXODashBuilderView)

// Attributes
public:
	CXODashBuilderDoc* GetDocument();
	// m_pSelection holds the selection to the current CXODashBuilderCntrItem.
	// For many applications, such a member variable isn't adequate to
	//  represent a selection, such as a multiple selection or a selection
	//  of objects that are not CXODashBuilderCntrItem objects.  This selection
	//  mechanism is provided just to help you get started.

	// TODO: replace this selection mechanism with one appropriate to your app.
	CXODashBuilderCntrItem* m_pSelection;

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CXODashBuilderView)
	public:
	virtual void OnDraw(CDC* pDC);  // overridden to draw this view
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
	protected:
	virtual void OnInitialUpdate(); // called first time after construct
	virtual BOOL IsSelected(const CObject* pDocItem) const;// Container support
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CXODashBuilderView();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:

// Generated message map functions
protected:
	//{{AFX_MSG(CXODashBuilderView)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	afx_msg void OnDestroy();
	afx_msg void OnSetFocus(CWnd* pOldWnd);
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnInsertObject();
	afx_msg void OnCancelEditCntr();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

#ifndef _DEBUG  // debug version in XODashBuilderView.cpp
inline CXODashBuilderDoc* CXODashBuilderView::GetDocument()
   { return (CXODashBuilderDoc*)m_pDocument; }
#endif

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_XODASHBUILDERVIEW_H__74AC8383_E147_4209_AFE5_FA7571318EF2__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\xodash\XODashLib\Audio.cpp ===
#include "std.h"
#include "Audio.h"

#include "FileUtil.h"
#include "AudioPump.h"

#include "xoconst.h"
#include "xcdplay.h"


CAudioClip::CAudioClip() :
	m_fade(0.0f),
	m_volume(1.0f),
	m_pan(0.0f),
	m_frequency(0.0f),
	m_url(NULL),
	m_transportMode(TRANSPORT_STOP)

{
	m_bDirty = true;
	m_lastTransportMode = -1;
	m_lastVolume = 1.0f;
	m_lastPan = 0.0f;
	m_lastFrequency = 0.0f;

	m_pSound = NULL;
}

CAudioClip::~CAudioClip()
{
	Cleanup();

	delete [] m_url;

}

void CAudioClip::OnIsActiveChanged()
{
	if (m_bDirty)
		Initialize();

	if (m_isActive)
		Play();
	else
		Stop();
}


HRESULT CAudioClip::Cleanup()
{
	Stop();

	delete m_pSound;
	m_pSound = NULL;
	m_lastVolume = 1.0f;
	m_lastPan = 0.0f;
	m_lastFrequency = 0.0f;
#ifdef DETECT_MEMORY_LEAKS
    EndLeakTest();
#endif
	return S_OK;
}



HRESULT CAudioClip::Initialize()
{
	HRESULT hr = S_OK;
	ASSERT(m_bDirty);

	// Out with the old...
	Cleanup();
	m_bDirty = false;

	if (m_url == NULL || m_url[0] == 0)
		return S_FALSE;

	do
	{
		// In with the new...
		if (_tcsnicmp(m_url, _T("cd:"), 3) == 0)
		{
			int nTrack = _ttoi(m_url + 3); // 0=nothing; >0 is track number to play

			if (nTrack > 0)
			{
	#ifdef DETECT_MEMORY_LEAKS
				StartLeakTest();
	#endif
				m_pSound = new XCDPlayer;		
				hr = ((XCDPlayer*) m_pSound) ->Initialize(nTrack - 1, &m_format.wfx);			
				BREAKONFAIL(hr, "CAudioClip::Initialize - fail to init XCDRPlayer");
	
			}
		}
		else if (_tcsnicmp(m_url, _T("st:"), 3) == 0)
		{
			DWORD dwSongID = _tcstoul(m_url + 3, NULL, 0); // SongID

			m_pSound = new CWMAPump;
			hr = ((CWMAPump*) m_pSound) ->Initialize(dwSongID, &m_format.wfx);
			BREAKONFAIL(hr, "CAudioClip::Initialize - fail to init CWA");
		}
		else
		{
			const TCHAR* pch = _tcsrchr(m_url, '.');
			if (pch != NULL)
			{
				if (_tcsicmp(pch + 1, _T("wav")) == 0)
				{
					OpenWaveFile();
				}
				else if (_tcsicmp(pch + 1, _T("wma")) == 0)
				{
					m_pSound = new CWMAPump;
					hr = ((CWMAPump*) m_pSound) ->Initialize(m_url, NULL, &m_format.wfx);
					BREAKONFAIL(hr, "CAudioClip::Initialize - fail to init CWA");
				}
				else
				{
					DbgPrint("Invalid AudioClip url: %s\n", m_url);
				}
			}
		}
	}while(0);


	if (FAILED(hr))
	{
		delete m_pSound;
		m_pSound = NULL;
	}
	return hr;
}

struct WAVFILE1
{
	BYTE riff [4];
	DWORD dwSize;
	BYTE wave [4];
	BYTE fmt [4];
	DWORD dwFormatSize;
};

struct WAVFILE2
{
	BYTE data [4];
	DWORD dwDataSize;
};

typedef struct
{
    FOURCC  fccChunkId;
    DWORD   dwDataSize;
} RIFFHEADER, *LPRIFFHEADER;

#ifndef FOURCC_RIFF
#define FOURCC_RIFF 'FFIR'
#endif // FOURCC_RIFF

#ifndef FOURCC_WAVE
#define FOURCC_WAVE 'EVAW'
#endif // FOURCC_WAVE

#ifndef FOURCC_FORMAT
#define FOURCC_FORMAT ' tmf'
#endif // FOURCC_FORMAT

#ifndef FOURCC_DATA
#define FOURCC_DATA 'atad'
#endif // FOURCC_DATA

bool CAudioClip::OpenWaveFile()
{
	TCHAR szBuf [MAX_PATH];
    _tcscpy( szBuf, SOUNDS_PATH );
    _tcscat( szBuf, m_url );
	HANDLE hFile = XAppCreateFile(szBuf, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_FLAG_SEQUENTIAL_SCAN, NULL);
	if (hFile == INVALID_HANDLE_VALUE)
	{
 	    DbgPrint("\001Cannot open wave file: %s\n", m_url);
		return false;
	}

	DWORD dwRead;
	WAVFILE1 header;
    RIFFHEADER RiffHeader;

	if (!ReadFile(hFile, &header, sizeof (header), &dwRead, NULL) || dwRead != sizeof (header))
	{
		DbgPrint("\001%s is not a valid wave file...\n", m_url);
		CloseHandle(hFile);
		return false;
	}

	if (header.riff[0] != 'R' || header.riff[1] != 'I' || header.riff[2] != 'F' || header.riff[3] != 'F' ||
		header.wave[0] != 'W' || header.wave[1] != 'A' || header.wave[2] != 'V' || header.wave[3] != 'E' ||
		header.fmt[0] != 'f' || header.fmt[1] != 'm' || header.fmt[2] != 't' || header.fmt[3] != ' ')
	{
		DbgPrint("\001%s is not a valid wave file (bad header chunk)\n", m_url);
		CloseHandle(hFile);
		return false;
	}

	DWORD dwFormatSize = header.dwFormatSize;
	ZeroMemory(&m_format, sizeof(m_format));

	if (dwFormatSize > sizeof(m_format))
    {
		dwFormatSize = sizeof(m_format);
    }

	if (!ReadFile(hFile, &m_format, dwFormatSize, &dwRead, NULL) || dwRead != dwFormatSize)
	{
		DbgPrint("\001%s is not a valid wave file (bad format chunk)\n", m_url);
		CloseHandle(hFile);
		return false;
	}

    if (header.dwFormatSize != dwFormatSize)
    {
        SetFilePointer(hFile, header.dwFormatSize - dwFormatSize, 0, FILE_CURRENT);
    }

    BOOL b;
    DWORD dwDataSize = 0;

    ASSERT(m_format.wfx.wFormatTag == WAVE_FORMAT_PCM || m_format.wfx.wFormatTag == WAVE_FORMAT_XBOX_ADPCM);

	do
	{
        b = ReadFile(hFile, &RiffHeader, sizeof(RiffHeader), &dwRead, NULL);
        if (b)
        {
            if (RiffHeader.fccChunkId == FOURCC_DATA)
            {
                dwDataSize = RiffHeader.dwDataSize;
                break;
            }

            b = SetFilePointer(hFile, RiffHeader.dwDataSize, 0, FILE_CURRENT);
        }
	}
	while (b);

    if (!b || dwDataSize == 0)
    {
        DbgPrint("\001%s is not a valid wave file (bad data chunk)\n", m_url);
        CloseHandle(hFile);
        return false;
    }

	HRESULT hr = S_OK;
	ASSERT(m_pSound == NULL);
	if (dwDataSize > 65536)
	{
		CFilePump* pSound = new CFilePump;
		m_pSound = pSound;
		hr = pSound->Initialize(hFile, dwDataSize, &m_format.wfx);
		if (FAILED(hr))
		{
			DbgPrint("Could not initialize CFilePump for %s\n", m_url);
			CloseHandle(hFile);
			delete pSound;
			m_pSound = NULL;
			return false;
		}

		// NOTE: File will be closed by CFilePump when it's done...
	}
	else
	{
		m_pSound = new CAudioBuf;
		hr = m_pSound->Initialize(&m_format.wfx, dwDataSize);
		if(FAILED(hr))
		{
			DbgPrint("Could not initialize CAudioBuf for %s\n", m_url);
			CloseHandle(hFile);
			delete m_pSound;
			m_pSound = NULL;
			return false;
		}

		void* pvBuffer = m_pSound->Lock();
		bool bError = !ReadFile(hFile, pvBuffer, dwDataSize, &dwRead, NULL) || dwRead != dwDataSize;
		m_pSound->Unlock(pvBuffer);

		CloseHandle(hFile);

		if (bError)
		{
			DbgPrint("\001%s is not a valid wave file...\n", m_url);
			delete m_pSound;
			m_pSound = NULL;

			return false;
		}
	}

	return true;
}


void CAudioClip::PlayOrPause()
{
 
	switch (m_transportMode)
	{
	case TRANSPORT_PLAY:
	case TRANSPORT_PAUSE:
		Pause();
		break;

	default:
		Play();
		break;
	}
}

void CAudioClip::Play(bool bLoop /*false*/)
{
	if (m_bDirty)
		Initialize();
	m_bLoop = bLoop;
	if (m_pSound != NULL)
	{
		m_pSound->SetAttenuation((1.0f - m_volume) * 100.0f);
		m_pSound->SetPan(m_pan);
		m_pSound->SetFrequency(m_frequency);

		if (m_pSound->Play(m_bLoop))
		{
			m_transportMode = TRANSPORT_PLAY;
			m_isActive = true;
		}
        else DbgPrint("Play failed!\n");
	}

}

void CAudioClip::Stop()
{
	if (m_transportMode == TRANSPORT_STOP)
		return;

	m_transportMode = TRANSPORT_STOP;

	if (m_pSound != NULL)
		m_pSound->Stop();

	delete m_pSound;
	m_pSound = NULL;

	m_isActive = false;
	m_bDirty = true; // so audio buffer is re-created and will start over
}

void CAudioClip::Pause()
{
	if (m_bDirty)
		Initialize();

	if (m_transportMode == TRANSPORT_PAUSE)
	{
		m_transportMode = TRANSPORT_PLAY;

		if (m_pSound != NULL)
			m_pSound->Pause(false);
	}
	else
	{
		m_transportMode = TRANSPORT_PAUSE;

		if (m_pSound != NULL)
			m_pSound->Pause(true);
	}
}

int CAudioClip::getMinutes()
{
	if (m_bDirty)
		Initialize();

	if (m_pSound == NULL)
		return 0;

	return (int)m_pSound->GetPlaybackTime() / 60;
}

int CAudioClip::getSeconds()
{
	if (m_bDirty)
		Initialize();

	if (m_pSound == NULL)
		return 0;

	return (int)m_pSound->GetPlaybackTime() % 60;
}


void* CAudioClip::GetSampleBuffer()
{
	if (m_pSound == NULL)
		return NULL;

	return m_pSound->GetSampleBuffer();
}

int CAudioClip::GetSampleBufferSize()
{
	if (m_pSound == NULL)
		return 0;

	return m_pSound->GetSampleBufferSize();
}


void CAudioClip::SetUrl(const TCHAR* pszAudioFile)
{
	if(m_url)
	{
		delete [] m_url;
	}
	m_bDirty = true;
	if(pszAudioFile)
	{
		m_url = new TCHAR[_tcslen(pszAudioFile)+1];
		_tcscpy(m_url, pszAudioFile);
	}

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\xodash\XODashLib\AudioPump.h ===
#pragma once

#define _D3DTYPES_H_


#include <dsound.h>

// Static audio buffer for sound effects...
class CAudioBuf
{
public:
	CAudioBuf();
	virtual ~CAudioBuf();

	HRESULT Initialize(WAVEFORMATEX* pWaveFormat, int nBufferBytes, const void* pvSamples = NULL);
	void* Lock();
	void Unlock(void* pvBuffer);

	virtual bool Play(bool bLoop = false);
	virtual void Stop();
	virtual float GetPlaybackTime();
	virtual float GetPlaybackLength(); // NOTE: will return 0 if unknown!
	virtual bool IsPlaying();

	virtual void Pause(bool bPause);
	inline bool IsPaused() const { return m_bPaused; }
	
	virtual void* GetSampleBuffer();
	virtual DWORD GetSampleBufferSize();

	void SetAttenuation(float nAttenuation); // 0..100 dB
	void SetPan(float nPan); // -100..100 dB
	void SetFrequency(float nFrequency); // 0 (normal), or 100..100,000

protected:
	bool m_bLoop;
	bool m_bPaused;
	int m_nBufferBytes;
	int m_nBytesPerSecond;
	LPDIRECTSOUNDBUFFER m_pDSBuffer;
};


// Double-buffered Audio Buffer for streaming...
class CAudioPump : public CAudioBuf
{
public:
	CAudioPump();
	virtual ~CAudioPump();

	HRESULT Initialize(DWORD dwStackSize, WAVEFORMATEX* pWaveFormat, int nBufferBytes, int nSegmentsPerBuffer = 4, int nPrebufferSegments = 1);

	virtual bool Play(bool bLoop = false);
	virtual void Stop();
	virtual bool IsPlaying();
	virtual float GetPlaybackTime();
	virtual void Pause(bool bPause);
	virtual float GetPlaybackLength(); // NOTE: will return 0 if unknown!

protected:
	enum
    {
        PUMPSTATE_STOPPED,
        PUMPSTATE_BUFFERING,
        PUMPSTATE_RUNNING,
        PUMPSTATE_STOPPING,
    };

    static DWORD CALLBACK StartThread(LPVOID pvContext);
	DWORD ThreadProc();

	HANDLE m_hPlayThread;
	HANDLE m_hTerminate;
	HANDLE m_hRun;
	HANDLE* m_ahNotify; // m_nSegmentsPerBuffer events
    HANDLE m_hMutex;

    DWORD m_dwPrevCursor;
	int m_nCompletedBuffers;
    int m_nFilledBuffers;
    bool* m_pfBufferFilled; // m_nSegmentsPerBuffer bools
    int m_nPumpState;

    int m_nSegmentsPerBuffer;
    int m_nPrebufferSegments;

	bool FillBuffer(int nBuffer);
	virtual int GetData(BYTE* pbBuffer, int cbBuffer) = 0;
	virtual void OnAudioEnd() {} 
};


// Audio Buffer for streaming large files...
class CFilePump : public CAudioPump
{
public:
	CFilePump();
	virtual ~CFilePump();

	HRESULT Initialize(HANDLE hFile, int nFileBytes, WAVEFORMATEX* pFormat);
	virtual void Stop();

	virtual float GetPlaybackLength();

	virtual void* GetSampleBuffer();
	virtual DWORD GetSampleBufferSize();

protected:
	virtual int GetData(BYTE* pbBuffer, int cbBuffer);
	HANDLE m_hFile;
	void* m_pvBuffer;
	float m_nPlaybackLength;
	DWORD m_dwStartPos;
    DWORD m_dwBufferSize;
};

#ifdef _XBOX

// WMA decoding Audio Buffer for soundtracks...
class CWMAPump : public CAudioPump
{
public:
	CWMAPump();
	virtual ~CWMAPump();

	HRESULT Initialize(const TCHAR* szFileName, HANDLE hFile, WAVEFORMATEX* pFormat);
	HRESULT Initialize(DWORD dwSongID, WAVEFORMATEX* pFormat);

	virtual float GetPlaybackLength();

	virtual void* GetSampleBuffer();
	virtual DWORD GetSampleBufferSize();

    virtual void Stop();

protected:
	virtual int GetData(BYTE* pbBuffer, int cbBuffer);
	HANDLE m_hFile;
	XFileMediaObject* m_pSourceFilter;
	void* m_pvBuffer;
	float m_nPlaybackLengthInSeconds;	// Used to store the length of the WMA song from the Database
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\xodash\XODashLib\AudioPump.cpp ===
//-------------------------------------------------------------
// Copyright (c) Microsoft Corporation.  All rights reserved
//-------------------------------------------------------------
#include "std.h"

#include "utilities.h"
#include "globals.h"
#include "AudioPump.h"
#include "DSoundManager.h"

 
////////////////////////////////////////////////////////////////////////////

CAudioBuf::CAudioBuf()
{
	m_pDSBuffer = NULL;
	m_bPaused = false;
	m_bLoop = false;
	m_nBufferBytes = 0;
}

CAudioBuf::~CAudioBuf()
{
	if (m_pDSBuffer != NULL)
	{
		m_pDSBuffer->Stop();
		m_pDSBuffer->Release();
	}
}

HRESULT CAudioBuf::Initialize(WAVEFORMATEX* pWaveFormat, int nBufferBytes, const void* pvSamples/*=NULL*/)
{
	m_nBufferBytes = nBufferBytes;
	m_nBytesPerSecond = pWaveFormat->nAvgBytesPerSec;
	HRESULT hr = S_OK;
	
	do
	{
		hr = DSoundManager::Instance()-> DSoundCreateSoundBuffer( pWaveFormat, nBufferBytes, DSBCAPS_CTRLVOLUME | DSBCAPS_CTRLFREQUENCY,&m_pDSBuffer);
		BREAKONFAIL(hr,"CAudioBuf::Initialize - fail to create sound buffer");
			
		if (m_pDSBuffer == NULL)
		{
			hr = E_INVALIDARG;
			BREAKONFAIL(hr,"CAudioBuf::Initialize - fail to create sound buffer");
		}

		if (pvSamples != NULL)
		{
			hr = DSoundManager::Instance() ->DSoundSetSoundBufferData(m_pDSBuffer, 0, nBufferBytes, pvSamples);
			BREAKONFAIL(hr, "CAudioBuf::Initialize - fail to set sound buffer");
		}

	}while(0);

	return hr;

}

void* CAudioBuf::Lock()
{
	LPVOID pvBuffer;
	DWORD dwBufferLength;

	ASSERT(m_pDSBuffer != NULL);

	VERIFYHR(m_pDSBuffer->Lock(0, m_nBufferBytes, &pvBuffer, &dwBufferLength, NULL, NULL, 0L));
	ASSERT(dwBufferLength == (DWORD)m_nBufferBytes);
	return pvBuffer;
}

void CAudioBuf::Unlock(void* pvBuffer)
{
	VERIFYHR(m_pDSBuffer->Unlock(pvBuffer, m_nBufferBytes, NULL, 0));
}

bool CAudioBuf::Play(bool bLoop/*=false*/)
{
	m_bPaused = false;
	m_bLoop = bLoop;

	if (m_pDSBuffer == NULL)
	{
		return false;
	}

	VERIFYHR(m_pDSBuffer->SetCurrentPosition(0));
	VERIFYHR(m_pDSBuffer->Play(0, 0, m_bLoop ? DSBPLAY_LOOPING : 0));

	return true;
}

void CAudioBuf::Stop()
{
	if (m_pDSBuffer != NULL)
    {
		VERIFYHR(m_pDSBuffer->Stop());
    }
}

void CAudioBuf::Pause(bool bPause)
{
	if (m_pDSBuffer == NULL)
	{
		return;
	}

	if (bPause)
	{
		m_bPaused = true;
		VERIFYHR(m_pDSBuffer->Stop());
	}
	else
	{
		m_bPaused = false;
		VERIFYHR(m_pDSBuffer->Play(0, 0, m_bLoop ? DSBPLAY_LOOPING : 0));
	}
}

bool CAudioBuf::IsPlaying()
{
	if (m_pDSBuffer == NULL)
	{
		return false;
	}

	DWORD dwStatus;
	VERIFYHR(m_pDSBuffer->GetStatus(&dwStatus));
	return (dwStatus & DSBSTATUS_PLAYING) != 0;
}

void CAudioBuf::SetAttenuation(float nAttenuation)
{
	ASSERT(m_pDSBuffer != NULL);

	VERIFYHR(m_pDSBuffer->SetVolume(-(int)(nAttenuation * 100.0f)));
}

void CAudioBuf::SetPan(float nPan)
{
	ASSERT(m_pDSBuffer != NULL);

#ifndef _XBOX
	VERIFYHR(m_pDSBuffer->SetPan((int)(nPan * 100.0f)));
#endif
}

void CAudioBuf::SetFrequency(float nFrequency)
{
	ASSERT(m_pDSBuffer != NULL);

	VERIFYHR(m_pDSBuffer->SetFrequency(nFrequency == 0.0f ? DSBFREQUENCY_ORIGINAL : (DWORD)nFrequency));
}

float CAudioBuf::GetPlaybackTime()
{
	if (m_pDSBuffer == NULL)
		return 0.0f;

	DWORD dwPlayCursor;
	VERIFYHR(m_pDSBuffer->GetCurrentPosition(&dwPlayCursor, NULL));

	return (float)dwPlayCursor / m_nBytesPerSecond;
}

float CAudioBuf::GetPlaybackLength()
{
	return (float)m_nBufferBytes / m_nBytesPerSecond;
}

void* CAudioBuf::GetSampleBuffer()
{
	return NULL;
}

DWORD CAudioBuf::GetSampleBufferSize()
{
	return 0;
}

////////////////////////////////////////////////////////////////////////////

CAudioPump::CAudioPump()
{
	m_hPlayThread = NULL;
	m_hTerminate = NULL;
    m_hMutex = NULL;
	m_nBufferBytes = 0;
	m_nCompletedBuffers = 0;
    m_dwPrevCursor = 0;
    m_nFilledBuffers = 0;
    m_nPumpState = PUMPSTATE_STOPPED;

    m_ahNotify = NULL;
    m_nSegmentsPerBuffer = 0;
    m_pfBufferFilled = 0;
}

CAudioPump::~CAudioPump()
{
	if (m_hTerminate != NULL)
		SetEvent(m_hTerminate);

	if (m_hPlayThread != NULL)
	{
		WaitForSingleObject(m_hPlayThread, INFINITE);
		CloseHandle(m_hPlayThread);
	}
	
	if (m_hTerminate != NULL)
		CloseHandle(m_hTerminate);

	if (m_hMutex != NULL)
		CloseHandle(m_hMutex);

	if (m_pDSBuffer != NULL)
	{
		m_pDSBuffer->Stop();
		m_pDSBuffer->Release();
		m_pDSBuffer = NULL;
	}

    if(m_ahNotify){
	    for (int i = 0; i < m_nSegmentsPerBuffer; i++)
        {
            if (m_ahNotify[i])
                CloseHandle(m_ahNotify[i]);
        }
        delete [] m_ahNotify;
    }
    if(m_pfBufferFilled){
        delete [] m_pfBufferFilled;
    }
}

DWORD CALLBACK CAudioPump::StartThread(LPVOID pvContext)
{
	CAudioPump *pThis = (CAudioPump*)pvContext;
	return pThis->ThreadProc();
}

DWORD CAudioPump::ThreadProc()
{
    const HANDLE ahMutex[] = { m_hTerminate, m_hMutex };
    HANDLE* ahNotify = new HANDLE[1 + m_nSegmentsPerBuffer];
    if(!ahNotify){
        return -1;
    }
    int nBuffer;
    bool fMutex = false;
    DWORD dwWaitObj;

    ahNotify[0] = m_hTerminate;

    for (int i = 0; i < m_nSegmentsPerBuffer; i++)
    {
        ahNotify[i + 1] = m_ahNotify[i];
    }

	for (;;)
	{
		if (fMutex)
        {
            ReleaseMutex(m_hMutex);
            fMutex = false;
        }

        dwWaitObj = WaitForMultipleObjects(1 + m_nSegmentsPerBuffer, ahNotify, FALSE, INFINITE);
		if (dwWaitObj == WAIT_OBJECT_0)
        {
            break;
        }

        dwWaitObj = WaitForMultipleObjects(2, ahMutex, FALSE, INFINITE);
		if (dwWaitObj == WAIT_OBJECT_0)
        {
			break;
        }

        fMutex = true;

        if (m_nPumpState == PUMPSTATE_STOPPED)
        {
            continue;
        }

        if (m_nPumpState == PUMPSTATE_BUFFERING)
        {
            FillBuffer(m_nFilledBuffers);
            continue;
        }

        if ((m_nPumpState == PUMPSTATE_STOPPING) && (m_nFilledBuffers <= 0))
        {
            Stop();
			OnAudioEnd();  // check if smthng to be done at the end of the play, 
						   // eg. change track to the next one for the CD player
            continue;
        }

        for (int i = 0; i < m_nSegmentsPerBuffer; i++)
        {
            if (WAIT_OBJECT_0 == WaitForSingleObject(m_ahNotify[i], 0))
            {
                nBuffer = i;

                break;
            }
        }

        if (i >= m_nSegmentsPerBuffer)
        {
            continue;
        }

        // We start the ball rolling by signaled all events. This
        // wakes us enough times that we can fill up all our buffers.
        // But, a side effect is that we get a bunch of false
        // signals. When we are playing very short audio clips, there may
        // actually be more false signals than there is data to play.
        // To keep this case from confusing us, we need to keep track
        // of which buffers actually have data in them.
        //
        // The m_pfBufferFilled array keeps track of which buffers are
        // actually  filled. This allows us to distinguish the initial
        // false signals from the normal signals.

        if(m_pfBufferFilled[nBuffer]){
            m_pfBufferFilled[nBuffer] = false;
            m_nFilledBuffers--;
        }

		FillBuffer(nBuffer);
	}

    Stop();

    if (fMutex)
    {
        ReleaseMutex(m_hMutex);
    }

    if(ahNotify){
        delete [] ahNotify;
    }

	return 0;
}

HRESULT CAudioPump::Initialize(DWORD dwStackSize, WAVEFORMATEX* pWaveFormat, int nBufferBytes, int nSegmentsPerBuffer, int nPrebufferSegments)
{

	m_nBytesPerSecond = pWaveFormat->nAvgBytesPerSec;
	m_nBufferBytes = nBufferBytes;

    m_nSegmentsPerBuffer = nSegmentsPerBuffer;
    m_nPrebufferSegments = nPrebufferSegments;

    ASSERT((m_nPrebufferSegments <= m_nSegmentsPerBuffer));

    m_ahNotify = new HANDLE[m_nSegmentsPerBuffer];
    if(m_ahNotify == NULL)
	{
        return E_OUTOFMEMORY;
    }

    for (int i = 0; i < m_nSegmentsPerBuffer; i++)
    {
        m_ahNotify[i] = NULL;
    }

	m_hTerminate = CreateEvent(NULL, FALSE, FALSE, NULL);
	ASSERT(	m_hTerminate != INVALID_HANDLE_VALUE);
	if(m_hTerminate == INVALID_HANDLE_VALUE)
	{
		return ERROR_INVALID_HANDLE;
	}

    m_hMutex = CreateMutex(NULL, FALSE, NULL);
	ASSERT(m_hMutex != INVALID_HANDLE_VALUE );
	if(m_hMutex == INVALID_HANDLE_VALUE)
	{
		return ERROR_INVALID_HANDLE;
	}

    for (int i = 0; i < m_nSegmentsPerBuffer; i++)
    {
	    m_ahNotify[i] = CreateEvent(NULL, TRUE, FALSE, NULL);
		if(m_ahNotify[i] == INVALID_HANDLE_VALUE)
		{
// TBD release memory
			return E_OUTOFMEMORY;
		}
    }

    m_pfBufferFilled = new bool[m_nSegmentsPerBuffer];
    if(!m_pfBufferFilled){
        return E_OUTOFMEMORY;
    }

	DWORD dwThreadId;
	m_hPlayThread = CreateThread(NULL, dwStackSize, StartThread, this, 0, &dwThreadId);

	ASSERT(m_hPlayThread!= INVALID_HANDLE_VALUE);
	if(m_hPlayThread == INVALID_HANDLE_VALUE)
	{
		return ERROR_INVALID_HANDLE;
	}

	HRESULT hr = DSoundManager::Instance()->DSoundCreateSoundBuffer(pWaveFormat, m_nSegmentsPerBuffer * m_nBufferBytes, DSBCAPS_CTRLPOSITIONNOTIFY | DSBCAPS_CTRLVOLUME | DSBCAPS_CTRLFREQUENCY, &m_pDSBuffer);
	
    if (m_pDSBuffer == NULL)
	{
		DbgPrint("CAudioPump::Initialize - fail to create sound buffer");
		return hr;
	}

	// BLOCK: Set notification positions
	{
		DSBPOSITIONNOTIFY* dsbpn = new DSBPOSITIONNOTIFY[m_nSegmentsPerBuffer];
        if(dsbpn == NULL){
            return E_OUTOFMEMORY;
        }

        for (i = 0; i < m_nSegmentsPerBuffer; i++)
        {
		    dsbpn[i].dwOffset = m_nBufferBytes * (i + 1) - pWaveFormat->nBlockAlign;
		    dsbpn[i].hEventNotify = m_ahNotify[i];
        }

		hr = DSoundManager::Instance()->DSoundSetSoundBufferNotify(m_pDSBuffer, m_nSegmentsPerBuffer, dsbpn);
		if (FAILED(hr))
		{
			DbgPrint("CAudioPump::Initialize - fail to set sound buffer notify");
		}
        delete [] dsbpn;
	}

	return hr;
}

bool CAudioPump::Play(bool bLoop/*=false*/)
{
    m_bLoop = bLoop;

	if (m_pDSBuffer == NULL)
		return false;

    WaitForSingleObject(m_hMutex, INFINITE);

    Stop();

    m_nPumpState = PUMPSTATE_BUFFERING;

    for (int i = 0; i < m_nSegmentsPerBuffer; i++)
    {
        SetEvent(m_ahNotify[i]);
        m_pfBufferFilled[i] = false;
    }


	for (int i = 0; i < m_nPrebufferSegments; i++)
    {
        FillBuffer(i);
    }


	VERIFYHR(m_pDSBuffer->Play(0, 0, DSBPLAY_LOOPING));

    ReleaseMutex(m_hMutex);

	return true;
}

void CAudioPump::Stop()
{
	if (m_pDSBuffer == NULL)
		return;

    WaitForSingleObject(m_hMutex, INFINITE);

	VERIFYHR(m_pDSBuffer->Stop());
	VERIFYHR(m_pDSBuffer->SetCurrentPosition(0));

    DirectSoundDoWork();

    for (int i = 0; i < m_nSegmentsPerBuffer; i++)
    {
        ResetEvent(m_ahNotify[i]);
    }

	m_nCompletedBuffers = 0;
    m_nFilledBuffers = 0;
    m_nPumpState = PUMPSTATE_STOPPED;

    ReleaseMutex(m_hMutex);
}

void CAudioPump::Pause(bool bPause)
{
	if (m_pDSBuffer == NULL)
		return;

    WaitForSingleObject(m_hMutex, INFINITE);

	if (bPause)
	{
		m_bPaused = true;
		VERIFYHR(m_pDSBuffer->Stop());
	}
	else
	{
		m_bPaused = false;
		VERIFYHR(m_pDSBuffer->Play(0, 0, DSBPLAY_LOOPING));
	}

    ReleaseMutex(m_hMutex);
}

bool CAudioPump::IsPlaying()
{
	return (PUMPSTATE_STOPPED != m_nPumpState);
}

bool CAudioPump::FillBuffer(int nBuffer)
{
	int nBytes;

    ASSERT(m_pDSBuffer != NULL);

	LPVOID pvBuffer;
	DWORD dwBufferLength;

    WaitForSingleObject(m_hMutex, INFINITE);

    ResetEvent(m_ahNotify[nBuffer]);

	VERIFYHR(m_pDSBuffer->Lock(nBuffer * m_nBufferBytes, m_nBufferBytes, &pvBuffer, &dwBufferLength, NULL, NULL, 0L));
	ASSERT(dwBufferLength == (DWORD)m_nBufferBytes);

	if (PUMPSTATE_STOPPING == m_nPumpState)
    {
        nBytes = 0;
    }
    else
    {
        nBytes = GetData((BYTE*)pvBuffer, m_nBufferBytes);
    }

	if (nBytes < m_nBufferBytes)
    {
        m_nPumpState = PUMPSTATE_STOPPING;

        if (nBytes > 0)
        {
		    ZeroMemory(((BYTE*)pvBuffer) + nBytes, m_nBufferBytes - nBytes);
        }
        else
        {
		    ZeroMemory(pvBuffer, m_nBufferBytes);
        }
    }

	VERIFYHR(m_pDSBuffer->Unlock(pvBuffer, dwBufferLength, NULL, 0));

    if (nBytes > 0)
    {
        m_pfBufferFilled[nBuffer] = true;
        m_nFilledBuffers++;

        if (PUMPSTATE_BUFFERING == m_nPumpState)
        {
            if(m_nFilledBuffers >= m_nSegmentsPerBuffer)
            {
                m_nPumpState = PUMPSTATE_RUNNING;
            }
        }
    }

    ReleaseMutex(m_hMutex);

	return nBytes > 0;
}

float CAudioPump::GetPlaybackTime()
{
	if (m_pDSBuffer == NULL)
		return 0.0f;

	DWORD dwPlayCursor;
	VERIFYHR(m_pDSBuffer->GetCurrentPosition(&dwPlayCursor, NULL));

    if( dwPlayCursor < m_dwPrevCursor )
    {
        m_nCompletedBuffers++;
    }

    m_dwPrevCursor = dwPlayCursor;

    return (float)(m_nCompletedBuffers * ( m_nBufferBytes * m_nSegmentsPerBuffer ) + dwPlayCursor) / m_nBytesPerSecond;
}

float CAudioPump::GetPlaybackLength()
{
	return 0.0f;
}

////////////////////////////////////////////////////////////////////////////

CFilePump::CFilePump()
{
	m_pvBuffer = NULL;
	m_hFile = INVALID_HANDLE_VALUE;
	m_dwStartPos = 0;
    m_dwBufferSize = 0;
}

CFilePump::~CFilePump()
{
	if (m_hFile != INVALID_HANDLE_VALUE)
		CloseHandle(m_hFile);
}

HRESULT CFilePump::Initialize(HANDLE hFile, int nFileBytes, WAVEFORMATEX* pFormat)
{
	HRESULT hr = S_OK;
    m_dwBufferSize = (0x2000/pFormat->nBlockAlign) * pFormat->nBlockAlign;

	hr = CAudioPump::Initialize(8192, pFormat, m_dwBufferSize);
	if (FAILED(hr))
	{
		DbgPrint("CFilePump::Initialize - fail to init CAudioPump");
		return hr;
	}

	m_hFile = hFile;
	m_nPlaybackLength = (float)nFileBytes / m_nBytesPerSecond;
	m_dwStartPos = SetFilePointer(m_hFile, 0, NULL, FILE_CURRENT);

	return hr;
}

void CFilePump::Stop()
{
	if (m_hFile == INVALID_HANDLE_VALUE)
		return;

	CAudioPump::Stop();

	SetFilePointer(m_hFile, m_dwStartPos, NULL, FILE_BEGIN);
}

float CFilePump::GetPlaybackLength()
{
	return m_nPlaybackLength;
}

void* CFilePump::GetSampleBuffer()
{
	return m_pvBuffer;
}

DWORD CFilePump::GetSampleBufferSize()
{
	return m_dwBufferSize;
}

int CFilePump::GetData(BYTE* pbBuffer, int cbBuffer)
{
	DWORD dwRead;

	if (!ReadFile(m_hFile, pbBuffer, cbBuffer, &dwRead, NULL))
	{
		DbgPrint("CFilePump::GetData ReadFile failed (%d)\n", GetLastError());
		return -1;
	}

	if (m_bLoop && dwRead != (DWORD)cbBuffer)
	{
//		DbgPrint("AutoLooping CFilePump...\n");

		SetFilePointer(m_hFile, m_dwStartPos, NULL, FILE_BEGIN);

		DWORD dwRead2;
		if (!ReadFile(m_hFile, pbBuffer + dwRead, cbBuffer - dwRead, &dwRead2, NULL))
		{
			DbgPrint("CFilePump::GetData ReadFile failed (%d)\n", GetLastError());
			return -1;
		}

		dwRead += dwRead2;
	}

	m_pvBuffer = pbBuffer;

	return (int)dwRead;
}

////////////////////////////////////////////////////////////////////////////

const DWORD WMA_SEGMENTS_PER_BUFFER=4;

const DWORD WMASTRM_LOOKAHEAD_SIZE = 0x8000 * WMA_SEGMENTS_PER_BUFFER;
const DWORD WMASTRM_SOURCE_PACKET_BYTES = 0x8000;

CWMAPump::CWMAPump()
: m_nPlaybackLengthInSeconds( 0 ),
m_pSourceFilter( NULL ),
m_pvBuffer( NULL ),
m_hFile( INVALID_HANDLE_VALUE )
{
}

CWMAPump::~CWMAPump()
{
	if (m_pSourceFilter != NULL)
	{
        SignalObjectAndWait(m_hTerminate, m_hPlayThread, INFINITE, FALSE);
		m_pSourceFilter->Release();
		m_pSourceFilter = NULL;
	}

	if (m_hFile != INVALID_HANDLE_VALUE)
	{
		CloseHandle(m_hFile);
		m_hFile = INVALID_HANDLE_VALUE;
	}
}

HRESULT CWMAPump::Initialize(DWORD dwSongID, WAVEFORMATEX* pFormat)
{
    HANDLE hFile = XOpenSoundtrackSong(dwSongID, FALSE);
    if (hFile == INVALID_HANDLE_VALUE)
    {
        DbgPrint("Cannot open song 0x%08x\n", dwSongID);
        return HRESULT_FROM_WIN32(ERROR_INVALID_HANDLE);
    }

    // HACK: There is no way to use a SongID to get the Length of the Song
    // You must know the "index" within the SoundTrack of the song in order to get it's info
    // Because of this, we will loop on all the Songs in the current Soundtrack until we find
    // the correct one, and then store it's Length
    unsigned int uiSongIndex = 0;
    DWORD dwReturnedSongID;
    DWORD dwReturnedSongLength;

    while( TRUE )// Since we are using a SongID that is valid, this should be ok
    {
        if( !XGetSoundtrackSongInfo( DWORD HIWORD( dwSongID),
                                     uiSongIndex,
                                     &dwReturnedSongID,
                                     &dwReturnedSongLength,
                                     NULL,
                                     0 ) )
        {
            break;  // If this call fails, we should break out of our loop.
        }

        // Check to see if we found the song we are looking for
        if( dwSongID == dwReturnedSongID )
        {
            m_nPlaybackLengthInSeconds = (float)dwReturnedSongLength / 1000.0f;

            break;  // Since we found our song, we can stop searching
        };

        uiSongIndex++;
    }

    return Initialize(NULL, hFile, pFormat);
}

HRESULT CWMAPump::Initialize(const TCHAR* szFileName, HANDLE hFile, WAVEFORMATEX* pFormat)
{
	ASSERT(szFileName == NULL || hFile == NULL);
	ASSERT(szFileName != NULL || hFile != NULL);

	ASSERT(m_hFile == INVALID_HANDLE_VALUE);

	if (szFileName == NULL)
		m_hFile = hFile;

	char szBuf [MAX_PATH];
	if (szFileName != NULL)
		Ansi(szBuf, szFileName, MAX_PATH);

	HRESULT hr = WmaCreateDecoder(szBuf, hFile, FALSE, WMASTRM_LOOKAHEAD_SIZE, m_nSegmentsPerBuffer, 0, pFormat, &m_pSourceFilter);
	if (hr != S_OK)
	{
#ifdef _DEBUG
    	LogComError(hr, "WmaCreateDecoder");
#endif
		CloseHandle(m_hFile);
		m_hFile = INVALID_HANDLE_VALUE;

		return hr;
	}

	hr = CAudioPump::Initialize(0, pFormat, WMASTRM_SOURCE_PACKET_BYTES, WMA_SEGMENTS_PER_BUFFER);
	if (FAILED(hr))
	{
		m_pSourceFilter->Release();
		m_pSourceFilter = NULL;

		CloseHandle(m_hFile);
		m_hFile = INVALID_HANDLE_VALUE;

		return hr;
	}

    m_pDSBuffer->SetHeadroom(0);

	return hr;
}

int CWMAPump::GetData(BYTE* pbBuffer, int cbBuffer)
{
	ASSERT(cbBuffer == WMASTRM_SOURCE_PACKET_BYTES);

    DWORD dwSourceUsed;
    XMEDIAPACKET xmp;
    ZeroMemory(&xmp, sizeof(xmp));
    xmp.pvBuffer = pbBuffer;
    xmp.dwMaxSize = cbBuffer;
    xmp.pdwCompletedSize = &dwSourceUsed;

    HRESULT hr = m_pSourceFilter->Process(NULL, &xmp);
    if (FAILED(hr))
	{
		DbgPrint("\001m_pSourceFilter->Process() failed!\n");
        return -1;
	}

    if (dwSourceUsed < xmp.dwMaxSize)
	{
		DbgPrint("WMA PLAYBACK IS DONE!\n");

        // Call Flush so that the position is reset to begining
        m_pSourceFilter->Flush();
		return 0;
	}

	m_pvBuffer = pbBuffer;

	return WMASTRM_SOURCE_PACKET_BYTES;
}

float CWMAPump::GetPlaybackLength()
{
    return m_nPlaybackLengthInSeconds;
}

void* CWMAPump::GetSampleBuffer()
{
	return m_pvBuffer;
}

DWORD CWMAPump::GetSampleBufferSize()
{
	return WMASTRM_SOURCE_PACKET_BYTES;
}

void CWMAPump::Stop()
{
    CAudioPump::Stop();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\xodash\XODashLib\Button.cpp ===
#include "std.h"
#include "SmartObject.h"
#include "XOConst.h"
#include "globals.h"
#include "tgl.h"
#include "File.h"
#include <malloc.h>
#include "StringObj.h"
#include "utilities.h"

/*	eButtonDefault = 0,
	eButtonPressed ,
	eButtonHighlighted,
	eButtonDisabled,
 */

long CButton::MaterialMap[eButtonStateMax][3] =  // standard, egglow, text
{
     eFlatSurfaces2sided3, 0, 14,
    eGameHilite, eEggGlow, 2,
    eGameHilite, eEggGlow, 2,
    eFlatSurfaces, eEggGlow, 2,
    eGameHilite, eEggGlow, 2

};

CButton::CButton( TG_Shape* pAppearance ):
 m_pHelpText(NULL),
 m_eButtonState(eButtonDefault),
 m_eButtonId(eNullButtonId),
 m_eOrientation(eButtonVerticalOrientation),
 m_pfnCallBack(NULL),
 m_pTextObj(NULL),
 m_nEgglowCount(0),
 m_pEgglowShapes(NULL),
 m_nStandardCount(0),
 m_pStandardShapes(NULL),
 m_textObjId(-1),
 m_eType(eOneTextButton),
 SmartObject(pAppearance),
 m_eSound( eStandardSound )
 { 

 }


CButton::~CButton()
{
	Cleanup();
}

void CButton::Cleanup()
{
    if ( m_pEgglowShapes )
    {
        delete[] m_pEgglowShapes;
        m_pEgglowShapes = NULL;
        m_nEgglowCount = 0;
    }
    if ( m_pStandardShapes )
    {
        delete[] m_pStandardShapes;
        m_pStandardShapes = NULL;
        m_nStandardCount = 0;
    }

    delete[] m_pHelpText;
	m_pHelpText = NULL;

	m_pTextObj = NULL;  // no we do not delete CText, Scene deletes all the text objects
	SmartObject::Cleanup();
}


void CButton::SetState(eButtonState newState)
{
    if ( m_eButtonState != newState )
    {
       // need to go ahead and set all the materials appropriately
        long oldMaterialStandard = MaterialMap[m_eButtonState][0];
        long newMaterialStandard = MaterialMap[newState][0];
        
        long oldMaterialEgglow = MaterialMap[m_eButtonState][1];
        long newMaterialEgglow = MaterialMap[newState][1];

        long text = MaterialMap[newState][2];

        if ( m_pTextObj )
            m_pTextObj->SetMaterial( text );

        for ( int i = 0; i < m_nStandardCount; i++ )
        {
            m_pStandardShapes[i]->SwapMaterials(oldMaterialStandard, newMaterialStandard);
        }
        for ( int i = 0; i < m_nEgglowCount; i++ )
        {
            m_pEgglowShapes[i]->SwapMaterials(oldMaterialEgglow, newMaterialEgglow);
        }            
    }

    if(m_eButtonId != eNullButtonId)
  	    DbgPrint("CButton::SetState,button = %d(%s), newstate = %d\n", m_eButtonId, ButtonName[m_eButtonId], newState);
    else 
        DbgPrint("CButton::SetState,button = %d(%s), newstate = %d\n", m_eButtonId, "eNullButton", newState);

    m_eButtonState = newState;
}

bool CButton::IsDisabled () const
{
    if( m_eButtonState == eButtonDisabled || 
        m_eButtonState == eButtonDisabledHighlighted )
        return true;

    return false;
}

void CButton::SetHelpText(const TCHAR* pHelpText)
{
    delete[] m_pHelpText;
    m_pHelpText = NULL;

    if ( pHelpText )
    {
        m_pHelpText = new TCHAR[_tcslen(pHelpText)+1];
        _tcscpy( m_pHelpText, pHelpText );
    }
}





HRESULT CButton::LoadFromXBG( File* pFile, TG_Shape* pRoot )
{
        
    char nodeName[64];
    

    long buttonSize =   pFile->readLong( );
    BYTE* pReadBuffer = (BYTE*)_alloca(buttonSize); // max this could ever be
	if(!pReadBuffer)
	{
		return E_OUTOFMEMORY;
	}

    m_textObjId2 = pFile->readByte();

     pFile->read( (BYTE*)nodeName, 64 * sizeof( char ) );
     m_pAppearance = pRoot->FindObject( nodeName );

    ASSERT( m_pAppearance );

    if ( !m_pAppearance )
    {
        return -1;        
    }

    m_textObjId =       pFile->readByte();
    m_eButtonId =       (eButtonId)pFile->readLong();
    m_eOrientation =    (eButtonOrientation)pFile->readLong();
    m_nStandardCount =  pFile->readByte();
    m_nEgglowCount =    pFile->readByte();
    float tmp =         pFile->readFloat();
    tmp =               pFile->readFloat();
	
	if (m_eButtonId == eNullButtonId)
	{
		m_pHelpText = new TCHAR[_tcslen(_T("HELP_NULL"))+1];
		_tcscpy(m_pHelpText, _T("HELP_NULL"));
	}
	else
	{
		ASSERT(m_eButtonId < countof(ButtonHelpText));
		if(m_eButtonId < countof(ButtonHelpText))
		{
			m_pHelpText = new TCHAR[ _tcslen( ButtonHelpText[m_eButtonId] ) + 1];
			_tcscpy(m_pHelpText, ButtonHelpText[m_eButtonId]);
		}
	}

    long count = 0;
    if ( m_nStandardCount ) // load up standard shapes
    {
        m_pStandardShapes = new TG_Shape*[m_nStandardCount];
		if(!m_pStandardShapes)
		{
			return E_OUTOFMEMORY;
		}

        for ( char i = 0; i < m_nStandardCount; i++ )
        {
            pFile->readString( pReadBuffer );
            TG_Shape* pFound = pRoot->FindObject( (const char*)pReadBuffer );
            ASSERT( pFound );
            if ( pFound )
            {
                m_pStandardShapes[count++] = pFound;
                // temp, until we get real swap info                
                pFound->SetMaterials( MaterialMap[eButtonDefault][0] );

            }


        }
    }

    count = 0;
    if ( m_nEgglowCount ) // now the egglow ones
    {
        m_pEgglowShapes = new TG_Shape*[m_nEgglowCount];
		if(!m_pEgglowShapes)
		{
			return E_OUTOFMEMORY;
		}
        for ( char i = 0; i < m_nEgglowCount; i++ )
        {
            pFile->readString( pReadBuffer );
            TG_Shape* pFound = pRoot->FindObject( (const char*)pReadBuffer );
            ASSERT( pFound );
            if ( pFound )
            {
                m_pEgglowShapes[count++] = pFound;
                // temp, until we get real swap info                
                pFound->SetMaterials( MaterialMap[eButtonDefault][1] );

            }
        }
    }
    
    return S_OK; 
}


const TCHAR* CButton::GetHelpText() const
{	
	return m_pHelpText;
}

void CButton::AutoTest()
{
	if(!m_pTextObj)
	{
		DbgPrint("This is a button without text: %d [%s]\n",m_eButtonId, ButtonName[m_eButtonId]);
		return;
	}
	const TCHAR*pTextId = m_pTextObj->GetTextId();
	char szBuf [256];
	ZeroMemory(szBuf, countof(szBuf));
	if(pTextId)
	{
		Ansi(szBuf, pTextId,min(_tcslen(pTextId),countof(szBuf) - 1) );
	}
	else
	{
		strcpy(szBuf, "NULL");
	}
	
	const TCHAR*pText = m_pTextObj->GetText();
	char szBuf2 [256];
	ZeroMemory(szBuf2, countof(szBuf));
	if(pText)
	{
		Ansi(szBuf2, pText, min(_tcslen(pText),countof(szBuf2) - 1) );
	}
	else
	{
		strcpy(szBuf2, "NULL");
	}
	
	DbgPrint("AUTO:BUTTON=BUTTON_ID[%d], BUTTON_NAME[%s], BUTTON_STATE[%d], TEXT_ID[%s], TEXT[%s]\n",m_eButtonId, ButtonName[m_eButtonId], m_eButtonState, szBuf, szBuf2);
}

void CButton::Dump(bool bAllData)
{

	DbgPrint("Button:[%s] State:[%d]", (m_eButtonId == eNullButtonId) ? "[null]": ButtonName[m_eButtonId], m_eButtonState);	

	if(bAllData)
	{
	    DbgPrint(" Orientation:[%d]",m_eOrientation);
		if(m_pHelpText)
		{
			char szBuf[256];
			Ansi(szBuf, m_pHelpText, countof(szBuf));
			DbgPrint("HelpText:[%s]", szBuf);
		}
		else
		{
			DbgPrint("HelpText:[null]");
		}

		DbgPrint("\n");

		if(m_pTextObj)
		{
			m_pTextObj->Dump(bAllData);
		}
		else
		{
			DbgPrint("TextObj:[null]\n");
		}
	}
}

void CButton::Show( bool bDrawThisObject )
{
    SmartObject::Show( bDrawThisObject );
    if ( m_pTextObj )
    {
        m_pTextObj->Show(bDrawThisObject);
    }
}
void CButton::SetTextId( const TCHAR* pTextTop, const TCHAR* pTextBottom  )
{
    if(m_pTextObj)
	{
		m_pTextObj->SetTextId(pTextTop);
	}
}

void CButton::SetText( const TCHAR* pTextTop, const TCHAR* pTextBottom )
{
    if ( m_pTextObj )
    {
        m_pTextObj->SetText( pTextTop );
    }
}

HRESULT    CButton::HandlePress()
{
    if ( m_pfnCallBack )
        return m_pfnCallBack();

    return S_OK;
}

void CInputButton::Show( bool bDrawThisObject )
{
    CButton::Show( bDrawThisObject );
    if ( m_pInputTextObj )
    {
        m_pInputTextObj->Show(bDrawThisObject);
    }
}

void CInputButton::SetTextId( const TCHAR* pTextTop, const TCHAR* pTextBottom  )
{
    CButton::SetTextId( pTextTop, NULL );
    if ( m_pInputTextObj )
    {
        m_pInputTextObj->SetTextId(pTextBottom); 
    }
}

void CInputButton::SetText( const TCHAR* pTextTop, const TCHAR* pTextBottom)
{
    CButton::SetText( pTextTop );
    if ( m_pInputTextObj )
    {
        m_pInputTextObj->SetText( pTextBottom );
    }
}

void CInputButton::Dump(bool bAllData)
{
	CButton::Dump(bAllData);
	m_pInputTextObj->Dump(bAllData);					  
}


void CInputButton::SetState(eButtonState newState)
{
	if(m_eButtonState == newState)
	{
		return;
	}
	if ( m_pInputTextObj && (newState == eButtonDisabled || m_eButtonState == eButtonDisabled)  )
	{
		m_pInputTextObj->SetMaterial(MaterialMap[newState][2]);
	}
	
	CButton::SetState(newState);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\xodash\XODashLib\ButtonName.h ===
//Copyright (c) Microsoft Corporation.  All rights reserved.

#pragma once

static char* ButtonName[] = 
{
	"3buttonsSettings",
	"3buttonsMusic",
	"3buttonsMemory",
	"KeyboardShift",
	"KeyboardCapsLock",
	"KeyboardAccent",
	"KeyboardSymbols",
	"KeyboardSpace",
	"KeyboardBackspace",
	"Keyboard<",
	"Keyboard>",
	"KeyboardDone",
	"Keyboard01",
	"Keyboard02",
	"Keyboard03",
	"Keyboard04",
	"Keyboard05",
	"Keyboard06",
	"Keyboard07",
	"Keyboard08",
	"Keyboard09",
	"Keyboard10",
	"Keyboard11",
	"Keyboard12",
	"Keyboard13",
	"Keyboard14",
	"Keyboard15",
	"Keyboard16",
	"Keyboard17",
	"Keyboard18",
	"Keyboard19",
	"Keyboard20",
	"Keyboard21",
	"Keyboard22",
	"Keyboard23",
	"Keyboard24",
	"Keyboard25",
	"Keyboard26",
	"Keyboard27",
	"Keyboard28",
	"Keyboard29",
	"Keyboard30",
	"Keyboard31",
	"Keyboard32",
	"Keyboard33",
	"Keyboard34",
	"Keyboard35",
	"Keyboard36",
	"Keypad01",
	"Keypad02",
	"Keypad03",
	"Keypad04",
	"Keypad05",
	"Keypad06",
	"Keypad07",
	"Keypad08",
	"Keypad09",
	"Keypad00",
	"Keypadperiod",
	"Keypadbackspace",
	"Keypad<",
	"Keypad>",
	"Keypaddone",
	"NTS_settingsIP",
	"NTS_settingsDNS",
	"NTS_settingsHost",
	"NTS_settingsPPPoE",
	"NTS_settingsCancel",
	"NTS_settingsConnect",
	"NTS_HostnameHostname",
	"NTS_HostnameDomainName",
	"NTS_HostnameContinue",
	"NTS_PPPoEToggle",
	"NTS_PPPoEPrimary",
	"NTS_PPPoESecondary",
	"NTS_PPPoEContinue",
	"NTS_IPToggle",
	"NTS_IPIP",
	"NTS_IPSubnet",
	"NTS_IPGate",
	"NTS_DNSToggle",
	"NTS_DNSPrimary",
	"NTS_DNSSecondary",
	"NTS_DNSContinue",
	"gen_mess_panelYES",
	"gen_mess_panelCENTER",
	"gen_mess_panelNO",
	"gen_mess_panelMANUAL",
	"gen_mess_panelAUTO",
	"act_online01",
	"act_online02",
	"act_online03",
	"act_online04",
	"act_idname",
	"act_idtag",
	"act_idDOB",
	"act_idcontinue",
	"NTS_Status01",
	"NTS_Status02",
	"NTS_Status03",
	"NTS_Status04",
	"NTS_Status05",
	"NTS_Status06",
	"NTS_StatusPPPoeInput",
	"NTS_StatusHostInput",
	"NTS_StatusDNSInput",
	"NTS_CableHelp01",
	"NTS_PPPoEHelp01",
	"NTS_IPHelp01",
	"NTS_DNSHelp01",
	"NTS_ServicesHelp01",
	"ACT_Credit01",
	"ACT_Credit02",
	"ACT_Credit03",
	"ACT_Credit04",
	"ACT_New_Billing01",
	"ACT_New_Billing02",
	"ACT_New_Billing03",
	"ACT_New_Billing04",
	"ACT_New_Billing05",
	"ACT_New_Billing06",
	"ACT_New_Billingdone",
	"ACT_Country01",
	"ACT_Countrycanada",
	"ACT_Country02",
	"ACT_Countryusa",
	"ACT_Country03",
	"ACT_Billing01",
	"ACT_Billing02",
	"ACT_Billing03",
	"ACT_Billing04",
	"ACT_Billing05",
	"ACT_Billingdone",
	"ACT_Billingcredit",
	"ACT_Creditdone",
	"ACT_Creditbilling",
	"Gen_Large_Panel01",
	"Gen_Large_Panel02",
	"act_idHidden",
	"GEN_Exp_TumblersMonth",
	"GEN_Exp_TumblersYear",
	"GEN_Dob_TumblersMonth",
	"GEN_Dob_TumblersDay",
	"GEN_Dob_TumblersYear",
	"Gen_Welcome_Panel01",
	"Gen_Welcome_Panel02",
	"ACT_Billing_Country01",
	"ACT_Billing_Countrycanada",
	"ACT_Billing_Country02",
	"ACT_Billing_Countryusa",
	"ACT_Billing_Country03",
	"ACT_Cost_Confirm_Yes",
	"NTS_ConfigChoice01",
	"NTS_ConfigChoice02",

};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\xodash\XODashLib\ButtonHelp.h ===
//Copyright (c) Microsoft Corporation.  All rights reserved.

#pragma once

static TCHAR* ButtonHelpText[] =
{
	/*3buttonsSettings*/
	_T("HELP_SETTINGS"),
	/*3buttonsMusic*/
	_T("HELP_MUSIC"),
	/*3buttonsMemory*/
	_T("HELP_NULL"),
	/*KeyboardShift*/
	_T("HELP_NULL"),
	/*KeyboardCapsLock*/
	_T("HELP_NULL"),
	/*KeyboardAccent*/
	_T("HELP_NULL"),
	/*KeyboardSymbols*/
	_T("HELP_NULL"),
	/*KeyboardSpace*/
	_T("HELP_NULL"),
	/*KeyboardBackspace*/
	_T("HELP_NULL"),
	/*Keyboard<*/
	_T("HELP_NULL"),
	/*Keyboard>*/
	_T("HELP_NULL"),
	/*KeyboardDone*/
	_T("HELP_NULL"),
	/*Keyboard01*/
	_T("HELP_NULL"),
	/*Keyboard02*/
	_T("HELP_NULL"),
	/*Keyboard03*/
	_T("HELP_NULL"),
	/*Keyboard04*/
	_T("HELP_NULL"),
	/*Keyboard05*/
	_T("HELP_NULL"),
	/*Keyboard06*/
	_T("HELP_NULL"),
	/*Keyboard07*/
	_T("HELP_NULL"),
	/*Keyboard08*/
	_T("HELP_NULL"),
	/*Keyboard09*/
	_T("HELP_NULL"),
	/*Keyboard10*/
	_T("HELP_NULL"),
	/*Keyboard11*/
	_T("HELP_NULL"),
	/*Keyboard12*/
	_T("HELP_NULL"),
	/*Keyboard13*/
	_T("HELP_NULL"),
	/*Keyboard14*/
	_T("HELP_NULL"),
	/*Keyboard15*/
	_T("HELP_NULL"),
	/*Keyboard16*/
	_T("HELP_NULL"),
	/*Keyboard17*/
	_T("HELP_NULL"),
	/*Keyboard18*/
	_T("HELP_NULL"),
	/*Keyboard19*/
	_T("HELP_NULL"),
	/*Keyboard20*/
	_T("HELP_NULL"),
	/*Keyboard21*/
	_T("HELP_NULL"),
	/*Keyboard22*/
	_T("HELP_NULL"),
	/*Keyboard23*/
	_T("HELP_NULL"),
	/*Keyboard24*/
	_T("HELP_NULL"),
	/*Keyboard25*/
	_T("HELP_NULL"),
	/*Keyboard26*/
	_T("HELP_NULL"),
	/*Keyboard27*/
	_T("HELP_NULL"),
	/*Keyboard28*/
	_T("HELP_NULL"),
	/*Keyboard29*/
	_T("HELP_NULL"),
	/*Keyboard30*/
	_T("HELP_NULL"),
	/*Keyboard31*/
	_T("HELP_NULL"),
	/*Keyboard32*/
	_T("HELP_NULL"),
	/*Keyboard33*/
	_T("HELP_NULL"),
	/*Keyboard34*/
	_T("HELP_NULL"),
	/*Keyboard35*/
	_T("HELP_NULL"),
	/*Keyboard36*/
	_T("HELP_NULL"),
	/*Keypad01*/
	_T("HELP_NULL"),
	/*Keypad02*/
	_T("HELP_NULL"),
	/*Keypad03*/
	_T("HELP_NULL"),
	/*Keypad04*/
	_T("HELP_NULL"),
	/*Keypad05*/
	_T("HELP_NULL"),
	/*Keypad06*/
	_T("HELP_NULL"),
	/*Keypad07*/
	_T("HELP_NULL"),
	/*Keypad08*/
	_T("HELP_NULL"),
	/*Keypad09*/
	_T("HELP_NULL"),
	/*Keypad00*/
	_T("HELP_NULL"),
	/*Keypadperiod*/
	_T("HELP_NULL"),
	/*Keypadbackspace*/
	_T("HELP_NULL"),
	/*Keypad<*/
	_T("HELP_NULL"),
	/*Keypad>*/
	_T("HELP_NULL"),
	/*Keypaddone*/
	_T("HELP_NULL"),
	/*NTS_settingsIP*/
	_T("HELP_IP"),
	/*NTS_settingsDNS*/
	_T("HELP_DNS"),
	/*NTS_settingsHost*/
	_T("HELP_HOST"),
	/*NTS_settingsPPPoE*/
	_T("HELP_PPPOE"),
	/*NTS_settingsCancel*/
	_T("HELP_SET_CANCEL"),
	/*NTS_settingsConnect*/
	_T("HELP_SET_CONNECT"),
	/*NTS_HostnameHostname*/
	_T("HELP_HOSTNAME"),
	/*NTS_HostnameDomainName*/
	_T("HELP_DOMAINNAME"),
	/*NTS_HostnameContinue*/
	_T("HELP_NULL"),
	/*NTS_PPPoEToggle*/
	_T("HELP_PPP_USERNAME"),
	/*NTS_PPPoEPrimary*/
	_T("HELP_PPP_PASSWORD"),
	/*NTS_PPPoESecondary*/
	_T("HELP_PPP_SERVICENAME"),
	/*NTS_PPPoEContinue*/
	_T("HELP_NULL"),
	/*NTS_IPToggle*/
	_T("HELP_IP_TOGGLE"),
	/*NTS_IPIP*/
	_T("HELP_IP_IP"),
	/*NTS_IPSubnet*/
	_T("HELP_IP_SUBNET"),
	/*NTS_IPGate*/
	_T("HELP_IP_GATEWAY"),
	/*NTS_DNSToggle*/
	_T("HELP_DNS_TOGGLE"),
	/*NTS_DNSPrimary*/
	_T("HELP_DNS_PRIMARY"),
	/*NTS_DNSSecondary*/
	_T("HELP_DNS_SECONDARY"),
	/*NTS_DNSContinue*/
	_T("HELP_NULL"),
	/*gen_mess_panelYES*/
	_T("HELP_NULL"),
	/*gen_mess_panelCENTER*/
	_T("HELP_NULL"),
	/*gen_mess_panelNO*/
	_T("HELP_NULL"),
	/*gen_mess_panelMANUAL*/
	_T("HELP_NULL"),
	/*gen_mess_panelAUTO*/
	_T("HELP_NULL"),
	/*act_online01*/
	_T("HELP_NULL"),
	/*act_online02*/
	_T("HELP_NULL"),
	/*act_online03*/
	_T("HELP_NULL"),
	/*act_online04*/
	_T("HELP_NULL"),
	/*act_idname*/
	_T("ID_HELP_NAME"),
	/*act_idtag*/
	_T("ID_HELP_TAG"),
	/*act_idDOB*/
	_T("ID_HELP_DOB"),
	/*act_idcontinue*/
	_T("ID_HELP_CONTINUE"),
	/*NTS_Status01*/
	_T("HELP_STAT_F_PENDING"),
	/*NTS_Status02*/
	_T("HELP_STAT_F_PENDING"),
	/*NTS_Status03*/
	_T("HELP_STAT_F_PENDING"),
	/*NTS_Status04*/
	_T("HELP_STAT_F_PENDING"),
	/*NTS_Status05*/
	_T("HELP_STAT_SETTINGS"),
	/*NTS_Status06*/
	_T("HELP_STAT_DONE"),
	/*NTS_StatusPPPoeInput*/
	_T("HELP_NULL"),
	/*NTS_StatusHostInput*/
	_T("HELP_NULL"),
	/*NTS_StatusDNSInput*/
	_T("HELP_NULL"),
	/*NTS_CableHelp01*/
	_T("HELP_NULL"),
	/*NTS_PPPoEHelp01*/
	_T("HELP_NULL"),
	/*NTS_IPHelp01*/
	_T("HELP_NULL"),
	/*NTS_DNSHelp01*/
	_T("HELP_NULL"),
	/*NTS_ServicesHelp01*/
	_T("HELP_NULL"),
	/*ACT_Credit01*/
	_T("HELP_NULL"),
	/*ACT_Credit02*/
	_T("HELP_NULL"),
	/*ACT_Credit03*/
	_T("HELP_NULL"),
	/*ACT_Credit04*/
	_T("HELP_NULL"),
	/*ACT_New_Billing01*/
	_T("HELP_NULL"),
	/*ACT_New_Billing02*/
	_T("HELP_NULL"),
	/*ACT_New_Billing03*/
	_T("HELP_NULL"),
	/*ACT_New_Billing04*/
	_T("HELP_NULL"),
	/*ACT_New_Billing05*/
	_T("HELP_NULL"),
	/*ACT_New_Billing06*/
	_T("HELP_NULL"),
	/*ACT_New_Billingdone*/
	_T("HELP_NULL"),
	/*ACT_Country01*/
	_T("HELP_NULL"),
	/*ACT_Countrycanada*/
	_T("HELP_NULL"),
	/*ACT_Country02*/
	_T("HELP_NULL"),
	/*ACT_Countryusa*/
	_T("HELP_NULL"),
	/*ACT_Country03*/
	_T("HELP_NULL"),
	/*ACT_Billing01*/
	_T("HELP_NULL"),
	/*ACT_Billing02*/
	_T("HELP_NULL"),
	/*ACT_Billing03*/
	_T("HELP_NULL"),
	/*ACT_Billing04*/
	_T("HELP_NULL"),
	/*ACT_Billing05*/
	_T("HELP_NULL"),
	/*ACT_Billingdone*/
	_T("HELP_NULL"),
	/*ACT_Billingcredit*/
	_T("HELP_NULL"),
	/*ACT_Creditdone*/
	_T("HELP_NULL"),
	/*ACT_Creditbilling*/
	_T("HELP_NULL"),
	/*Gen_Large_Panel01*/
	_T("HELP_NULL"),
	/*Gen_Large_Panel02*/
	_T("HELP_NULL"),
	/*act_idHidden*/
	_T("HELP_NULL"),
	/*GEN_Exp_TumblersMonth*/
	_T("HELP_NULL"),
	/*GEN_Exp_TumblersYear*/
	_T("HELP_NULL"),
	/*GEN_Dob_TumblersMonth*/
	_T("HELP_NULL"),
	/*GEN_Dob_TumblersDay*/
	_T("HELP_NULL"),
	/*GEN_Dob_TumblersYear*/
	_T("HELP_NULL"),
	/*Gen_Welcome_Panel01*/
	_T("HELP_NULL"),
	/*Gen_Welcome_Panel02*/
	_T("HELP_NULL"),
	/*ACT_Billing_Country01*/
	_T("HELP_NULL"),
	/*ACT_Billing_Countrycanada*/
	_T("HELP_NULL"),
	/*ACT_Billing_Country02*/
	_T("HELP_NULL"),
	/*ACT_Billing_Countryusa*/
	_T("HELP_NULL"),
	/*ACT_Billing_Country03*/
	_T("HELP_NULL"),
	/*ACT_Cost_Confirm_Yes*/
	_T("HELP_NULL"),
	/* NTS_ConfigChoice01 */
	_T("HELP_NULL"),
	/* NTS_ConfigChoice02*/
	_T("HELP_NULL"),
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\xodash\XODashLib\ButtonId.h ===
//Copyright (c) Microsoft Corporation.  All rights reserved.

#pragma once

enum eButtonId
{
	eNullButtonId = -1,
	eSettingsButtonId,
	eMusicButtonId,
	eMemoryButtonId,
	eShiftButtonId,
	eCapsLockButtonId,
	eAccentsButtonId,
	eSymbolsButtonId,
	eSpaceButtonId,
	eBackspaceButtonId,
	eLessThanButtonId,
	eGreaterThanButtonId,
	eDoneButtonId,
	eKeyboard01,
	eKeyboard02,
	eKeyboard03,
	eKeyboard04,
	eKeyboard05,
	eKeyboard06,
	eKeyboard07,
	eKeyboard08,
	eKeyboard09,
	eKeyboard10,
	eKeyboard11,
	eKeyboard12,
	eKeyboard13,
	eKeyboard14,
	eKeyboard15,
	eKeyboard16,
	eKeyboard17,
	eKeyboard18,
	eKeyboard19,
	eKeyboard20,
	eKeyboard21,
	eKeyboard22,
	eKeyboard23,
	eKeyboard24,
	eKeyboard25,
	eKeyboard26,
	eKeyboard27,
	eKeyboard28,
	eKeyboard29,
	eKeyboard30,
	eKeyboard31,
	eKeyboard32,
	eKeyboard33,
	eKeyboard34,
	eKeyboard35,
	eKeyboard36,
	eKeypad01,
	eKeypad02,
	eKeypad03,
	eKeypad04,
	eKeypad05,
	eKeypad06,
	eKeypad07,
	eKeypad08,
	eKeypad09,
	eKeypad00,
	eKeypadPeriodButtonId,
	eKeypadBackspaceButtonId,
	eKeypadLessThanButtonId,
	eKeypadGreaterThanButtonId,
	eKeypadDoneButtonId,
	eNTS_settingsIP,
	eNTS_settingsDNS,
	eNTS_settingsHost,
	eNTS_settingsPPPoE,
	eNTS_settingsCancel,
	eNTS_settingsConnect,
	eNTS_HostnameHostname,
	eNTS_HostnameDomainName,
	eNTS_HostnameContinue,
	eNTS_PPPoEUserName,
	eNTS_PPPoEPassword,
	eNTS_PPPoEServiceName,
	eNTS_PPPoEContinue,
	eNTS_IPToggle,
	eNTS_IPIP,
	eNTS_IPSubnet,
	eNTS_IPGate,
	eNTS_DNSToggle,
	eNTS_DNSPrimary,
	eNTS_DNSSecondary,
	eNTS_DNSContinue,
	eMessage_YES,
	eMessage_CENTER,
	eMessage_NO,
	eMessage_BIGYES,
	eMessage_BIGNO,
	eACT_Online01,
	eACT_Online02,
	eACT_Online03,
	eACT_Online04,
	eACT_Idname,
	eACT_Idtag,
	eACT_IdDOB,
	eACT_Idcontinue,
	eNTS_Status01,
	eNTS_Status02,
	eNTS_Status03,
	eNTS_Status04,
	eNTS_Status05,
	eNTS_Status06,
	eNTS_StatusPPPoeInput,
	eNTS_StatusHostInput,
	eNTS_StatusDNSInput,
	eNTS_CableHelp01,
	eNTS_PPPoEHelp01,
	eNTS_IPHelp01,
	eNTS_DNSHelp01,
	eNTS_ServicesHelp01,
	eACT_Credit01,
	eACT_Credit02,
	eACT_Credit03,
	eACT_Credit04,
	eACT_New_Billing01,
	eACT_New_Billing02,
	eACT_New_Billing03,
	eACT_New_Billing04,
	eACT_New_Billing05,
	eACT_New_Billing06,
	eACT_New_Billingdone,
	eACT_Country01,
	eACT_Countrycanada,
	eACT_Country02,
	eACT_Countryusa,
	eACT_Country03,
	eACT_Billing01,
	eACT_Billing02,
	eACT_Billing03,
	eACT_Billing04,
	eACT_Billing05,
	eACT_Billingdone,
	eACT_Billingcredit,
	eACT_Creditdone,
	eACT_Creditbilling,
	eGen_Large_Panel01,
	eGen_Large_Panel02,
	eACT_idHiddenBadName,
	eGEN_Exp_TumblersMonth,
	eGEN_Exp_TumblersYear,
	eGEN_Dob_TumblersMonth,
	eGEN_Dob_TumblersDay,
	eGEN_Dob_TumblersYear,
	eGen_Welcome_Panel01,
	eGen_Welcome_Panel02,
	eACT_Billing_Country01,
	eACT_Billing_Countrycanada,
	eACT_Billing_Country02,
	eACT_Billing_Countryusa,
	eACT_Billing_Country03,
	eACT_Cost_Confirm_Yes,
	eNTS_ConfigChoice01,
	eNTS_ConfigChoice02,
	eLastButtonId
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\xodash\XODashLib\Camera.h ===
#ifndef CAMERA_H
#define CAMERA_H

#include "TGL.h"

struct XBGAMEPAD;
class File;
class Camera
{

public:

	void SetUp(IDirect3DDevice8* pDev );
	long Load( const char* ASEBuffer, TG_Animation* pAnimHeader );
	void Update(XBGAMEPAD* pPad, float elapsedTime);
    void SaveBinary( File* file );
    void LoadBinary( File* file );
    
    HRESULT FrameMove( float frameLen );

    ~Camera();
    Camera();



private:

	D3DXVECTOR3		m_vPosition;
	D3DXVECTOR3		m_vLookAt;
	D3DXVECTOR3		m_vUp;

	float			m_fFov;
	float			m_fNearClip;
	float			m_fFarClip;

    TG_Animation    m_PositionAnimation;
    TG_Animation    m_LookAtAnimation;

    float           m_curTime;


};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\xodash\XODashLib\camera.cpp ===
/*************************************************************************************************\
Camera.cpp			: Implementation of the Camera component.
Creation Date		: 2/18/2002 8:46:26 PM
Copyright Notice	: Copyright (c) Microsoft Corporation
Author				: Heidi Gaertner
//-------------------------------------------------------------------------------------------------
Notes				: 
\*************************************************************************************************/

#include "std.h"

#include "camera.h"
#include <stdio.h>
#include "utilities.h"
#include "XBInput.h"
#include "globals.h"
#include "File.h"

#define ASE_CAMERAHEADER	"*CAMERAOBJECT"
#define ASE_CAMERAPOS		"*TM_POS"
#define ASE_CAMERAMAT		"*TM_ROW%ld"
#define ASE_CAMERANEAR		"*CAMERA_NEAR"
#define ASE_CAMERAFAR		"*CAMERA_FAR"
#define ASE_CAMERAFOV		"*CAMERA_FOV"

Camera::Camera()
{
    memset( &m_PositionAnimation, 0, sizeof( m_PositionAnimation ) );
    memset( &m_LookAtAnimation, 0, sizeof( m_LookAtAnimation ) );
}
Camera::~Camera()
{
    if ( m_PositionAnimation.m_pPos )
    {
        delete [] m_PositionAnimation.m_pPos;
    }

    if ( m_LookAtAnimation.m_pPos )
    {
        delete [] m_LookAtAnimation.m_pPos;
    }

    if ( m_PositionAnimation.m_pQuat )
    {
        delete [] m_PositionAnimation.m_pQuat;
    }

    if ( m_LookAtAnimation.m_pQuat )
    {
        delete [] m_LookAtAnimation.m_pQuat;
    }

}

HRESULT Camera::FrameMove( float frameLen )
{
    m_curTime+= frameLen;
       // are we animating?
    if ( m_PositionAnimation.m_numFrames )
    {
        float totalLen = (m_PositionAnimation.m_numFrames/m_PositionAnimation.m_frameRate );
        while ( m_curTime > totalLen  )
            m_curTime -= totalLen;

        DWORD curFrame = (DWORD)(m_curTime * (float)m_PositionAnimation.m_frameRate);
  
        // build current animation position & rotation info
        if ( m_PositionAnimation.m_pPos )
            m_vPosition = m_PositionAnimation.m_pPos[curFrame];

        // TO DO: return different hr if anim is over
    }

    // are we animating?
    if ( m_LookAtAnimation.m_numFrames )
    {
        float totalLen = (m_LookAtAnimation.m_numFrames/m_LookAtAnimation.m_frameRate );
        while ( m_curTime > totalLen  )
            m_curTime -= totalLen;

        DWORD curFrame = (DWORD)(m_curTime * (float)m_PositionAnimation.m_frameRate);

        // build current animation LookAt & rotation info
        m_vLookAt = m_LookAtAnimation.m_pPos[curFrame];
  
        // TO DO: return different hr if anim is over
    }
	
	return S_OK;
}

void Camera::SetUp(IDirect3DDevice8* pDev )
{
	float degreeFOV = (float)m_fFov * 180.0f / 3.14159f;

	float widthFOV  = degreeFOV;
	float heightFOV = (degreeFOV / 4.0f) * 3.3f;

	D3DXMATRIX matProj;
	D3DXMatrixIdentity( &matProj );
	float fov_horiz = (float)((widthFOV) / 180.0) * 3.14159f;
	float fov_vert  = (float)((heightFOV) / 180.0) * 3.14159f;
	float far_plane = 10000.0f;
	float near_plane = 1.0f;

	float w = (float)(1/tan(fov_horiz * 0.5));
	float h = (float)(1/tan(fov_vert * 0.5));
	float Q = far_plane / (far_plane - near_plane);

	matProj._11 = w;	//0.999996;
	matProj._22 = h;	//0.999996;
	matProj._33 = -Q;		
	matProj._43 = -Q * near_plane;
	matProj._34 = -1.0f;
	matProj._44 = 0.0f;

 	D3DXMATRIX viewMatrix;
	D3DXMatrixLookAtRH( &viewMatrix, &m_vPosition, &m_vLookAt, &m_vUp );
	pDev->SetTransform( D3DTS_VIEW, &viewMatrix );

	// For the projection matrix, we set up a perspective transform (which
	// transforms geometry from 3D view space to 2D viewport space, with
	// a perspective divide making objects smaller in the distance). To build
	// a perpsective transform, we need the field of view (1/4 pi is common),
	// the aspect ratio, and the near and far clipping planes (which define at
	// what distances geometry should be no longer be rendered).

	//float aspectRatio = 640.0f / 480.0f;
	//D3DXMATRIX matProj;
	//D3DXMatrixPerspectiveFovRH( &matProj, m_fFov, aspectRatio, m_fNearClip, m_fFarClip );
	pDev->SetTransform( D3DTS_PROJECTION, &matProj );
}

float yRotation = 0.f; // ditch this, for debugging only
float xRotation = 0.f;
void Camera::Update(XBGAMEPAD* pPad, float elapsedTime)
{
	D3DXMATRIX rot;
	D3DXMatrixRotationY( &rot, yRotation );
	if ( pPad->bAnalogButtons[XINPUT_GAMEPAD_A] )
		yRotation += .001f;
	else if ( pPad->bAnalogButtons[XINPUT_GAMEPAD_B] )
		yRotation -= .001f;

	g_pd3dDevice->SetTransform( D3DTS_WORLD, &rot );
}

long Camera::Load( const char* ASEBuffer, TG_Animation* pAnimHeader )
{
    memset( &m_PositionAnimation, 0, sizeof( m_PositionAnimation ) );
    memset( &m_LookAtAnimation, 0, sizeof( m_LookAtAnimation ) );
    m_curTime = 0.f;


	long retVal = -1;
	char* pHeader = strstr( ASEBuffer, ASE_CAMERAHEADER );
	if ( pHeader )
	{

        char* pNodeName = strstr( pHeader, "*NODE_NAME " );
        char NodeName[64];
        if ( pNodeName )
        {
            GetNameData (pNodeName + strlen( "*NODE_NAME " ), NodeName);

        }

        CharUpperA( NodeName );

		pHeader = strstr( pHeader, ASE_CAMERAPOS );
		pHeader += strlen( ASE_CAMERAPOS ) + 1;
		m_vPosition.x = GetFloat( &pHeader );
		m_vPosition.y = GetFloat( &pHeader );
		m_vPosition.z = GetFloat( &pHeader );
        TG_Shape::LoadAnimationFromASE( (char*)ASEBuffer, NodeName, m_vPosition, pAnimHeader, &m_PositionAnimation );

        strcat( NodeName, ".TARGET" );


		pHeader = strstr( pHeader, ASE_CAMERAPOS );
		pHeader += strlen( ASE_CAMERAPOS ) + 1;
		m_vLookAt.x = GetFloat( &pHeader );
		m_vLookAt.y = GetFloat( &pHeader );
		m_vLookAt.z = GetFloat( &pHeader );

		m_vUp.x = 0.0;
		m_vUp.y = 0.0;
		m_vUp.z = 1.0;

        TG_Shape::LoadAnimationFromASE( (char*)ASEBuffer, NodeName, m_vLookAt, pAnimHeader, &m_LookAtAnimation );


		pHeader = strstr( pHeader, ASE_CAMERANEAR );
		pHeader += strlen( ASE_CAMERANEAR ) +1;

		m_fNearClip = GetFloat( &pHeader );
		if ( m_fNearClip == 0.f )
			m_fNearClip = 1.f;

		pHeader = strstr( pHeader, ASE_CAMERAFAR );
		pHeader += strlen( ASE_CAMERAFAR ) +1;

		m_fFarClip = GetFloat( &pHeader );

		pHeader = strstr( pHeader, ASE_CAMERAFOV );
		pHeader += strlen( ASE_CAMERAFOV ) + 1;

		m_fFov = GetFloat( &pHeader );
	}

	return retVal;

	
}

void Camera::SaveBinary( File* file )
{
    file->write( (BYTE*)&m_vPosition, sizeof ( D3DXVECTOR3 ) );
    file->write( (BYTE*)&m_vLookAt, sizeof ( D3DXVECTOR3 ) );
    file->write( (BYTE*)&m_vUp, sizeof ( D3DXVECTOR3 ) );

    file->writeFloat( m_fFov );
    file->writeFloat( m_fFarClip );
    file->writeFloat( m_fNearClip);

    file->write( (BYTE*)&m_PositionAnimation, sizeof( m_PositionAnimation ) );
    file->write( (BYTE*)&m_LookAtAnimation, sizeof( m_LookAtAnimation ) );

    if ( m_PositionAnimation.m_pPos )
    {
        file->write( (BYTE*)m_PositionAnimation.m_pPos, m_PositionAnimation.m_numFrames * sizeof( D3DXVECTOR3 ) );
    }

    if ( m_PositionAnimation.m_pQuat )
    {
        file->write( (BYTE*)m_PositionAnimation.m_pQuat, m_PositionAnimation.m_numFrames * sizeof( D3DXQUATERNION ) );
    }

    if ( m_LookAtAnimation.m_pPos )
    {
        file->write( (BYTE*)m_LookAtAnimation.m_pPos, m_LookAtAnimation.m_numFrames * sizeof( D3DXVECTOR3 ) );
    }

    if ( m_LookAtAnimation.m_pQuat )
    {
        file->write( (BYTE*)m_LookAtAnimation.m_pQuat, m_LookAtAnimation.m_numFrames * sizeof( D3DXQUATERNION ) );
    }
}

void Camera::LoadBinary( File* file )
{

    file->read( (BYTE*)&m_vPosition, sizeof ( D3DXVECTOR3 ) );
    file->read( (BYTE*)&m_vLookAt, sizeof ( D3DXVECTOR3 ) );
    file->read( (BYTE*)&m_vUp, sizeof ( D3DXVECTOR3 ) );

    m_fFov =        file->readFloat(  );
    m_fFarClip =    file->readFloat(  );
    m_fNearClip =   file->readFloat(  );

    // hack, but far clip is too close in max sometimes
    m_fFarClip = 10000;

    m_curTime = 0.f;
    file->read( (BYTE*)&m_PositionAnimation, sizeof( m_PositionAnimation ) );
    file->read( (BYTE*)&m_LookAtAnimation, sizeof( m_LookAtAnimation ) );

    if ( m_PositionAnimation.m_pPos )
    {
        m_PositionAnimation.m_pPos = new D3DXVECTOR3[m_PositionAnimation.m_numFrames];
        file->read( (BYTE*)m_PositionAnimation.m_pPos, m_PositionAnimation.m_numFrames * sizeof( D3DXVECTOR3 ) );

    }

    if ( m_PositionAnimation.m_pQuat )
    {
        m_PositionAnimation.m_pQuat = new D3DXQUATERNION[m_PositionAnimation.m_numFrames];
        file->read( (BYTE*)m_PositionAnimation.m_pQuat, m_PositionAnimation.m_numFrames * sizeof( D3DXQUATERNION ) );

    }

    if ( m_LookAtAnimation.m_pPos )
    {
        m_LookAtAnimation.m_pPos = new D3DXVECTOR3[m_LookAtAnimation.m_numFrames];
        file->read( (BYTE*)m_LookAtAnimation.m_pPos, m_LookAtAnimation.m_numFrames * sizeof( D3DXVECTOR3 ) );

    }

    if ( m_LookAtAnimation.m_pQuat )
    {
        m_LookAtAnimation.m_pQuat = new D3DXQUATERNION[m_LookAtAnimation.m_numFrames];
        file->read( (BYTE*)m_LookAtAnimation.m_pQuat, m_LookAtAnimation.m_numFrames * sizeof( D3DXQUATERNION ) );

    }


}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\xodash\XODashLib\cdda.cpp ===
#include "std.h"


#include "cdda.h"

////////////////////////////////////////////////////////////////////////////

CCDDAStreamer::CCDDAStreamer(CNtIoctlCdromService* pDrive, DWORD dwRetries)
{
	ASSERT(pDrive != NULL);

	m_ibChunk = 0;
	m_pDrive = pDrive;
    m_dwRetries = dwRetries;
	m_dwCurFrame = 0;
    m_chunk = (BYTE *)XPhysicalAlloc(CDDA_BUFFER_SIZE, -1, 0, PAGE_READWRITE);
}

CCDDAStreamer::~CCDDAStreamer()
{
    if (m_chunk)
        XPhysicalFree(m_chunk);
}

int CCDDAStreamer::ReadFrames(void* pvBuffer, DWORD nFrameCount)
{

#ifdef _DEBUG

    const DWORD dwStartTime = GetTickCount();

#endif

    DWORD nTotalFrames = m_pDrive->GetTrackFrame(m_pDrive->GetTrackCount());
    nFrameCount = min(nFrameCount, nTotalFrames - m_dwCurFrame);
    ASSERT((int)nFrameCount > 0);

	HRESULT hr = m_pDrive->Read(m_dwCurFrame, nFrameCount, pvBuffer, m_dwRetries);
	if (FAILED(hr))
	{
        ZeroMemory(pvBuffer, nFrameCount * CDAUDIO_BYTES_PER_FRAME);
        if (hr != HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER))
        {
            return -1;
        }
        else
        {
            // REVIEW: we probably hit end of the disc but need better way to detect this
            return 0;
        }
	}

#ifdef _DEBUG

    const DWORD dwEndTime = GetTickCount();

    if(dwEndTime - dwStartTime >= nFrameCount * 1000 / CDAUDIO_FRAMES_PER_SECOND)
    {
        DbgPrint("\001CCDDAStreamer: read of frames %lu through %lu took longer than real-time (%lu ms)\n", m_dwCurFrame, m_dwCurFrame + nFrameCount - 1, dwEndTime - dwStartTime);
    }

#endif

	m_dwCurFrame += nFrameCount;

	return nFrameCount * CDAUDIO_BYTES_PER_FRAME;
}

int CCDDAStreamer::Read(void* pvBuffer, int cbWanted)
{
    BYTE *pbBuffer = (BYTE *)pvBuffer;
    int cbRead;

    if (!m_chunk)
        return -1;

    if (m_ibChunk)
    {
        cbRead = min(cbWanted, CDDA_BUFFER_SIZE - m_ibChunk);

        CopyMemory(pbBuffer, m_chunk + m_ibChunk, cbRead);

        m_ibChunk += cbRead;
        m_ibChunk %= CDDA_BUFFER_SIZE;

        cbWanted -= cbRead;
        pbBuffer += cbRead;
    }

    while (cbWanted >= CDDA_MAX_FRAMES_PER_READ * CDAUDIO_BYTES_PER_FRAME)
    {
        cbRead = ReadFrames(pbBuffer, CDDA_MAX_FRAMES_PER_READ);
        if (cbRead <= 0)
            return cbRead;

        cbWanted -= cbRead;
        pbBuffer += cbRead;
    }

    while (cbWanted >= CDDA_BUFFER_SIZE)
    {
        cbRead = ReadFrames(pbBuffer, CDDA_BUFFER_SIZE / CDAUDIO_BYTES_PER_FRAME);
        if (cbRead <= 0)
            return cbRead;

        cbWanted -= cbRead;
        pbBuffer += cbRead;
    }

    if (cbWanted)
    {
        cbRead = ReadFrames(m_chunk, CDDA_BUFFER_SIZE / CDAUDIO_BYTES_PER_FRAME);
        if (cbRead <= 0)
            return cbRead;

        if (cbRead < CDDA_BUFFER_SIZE)
            ZeroMemory(m_chunk + cbRead, CDDA_BUFFER_SIZE - cbRead);

        m_ibChunk = cbWanted;
        cbRead = min(cbRead, cbWanted);

        CopyMemory(pbBuffer, m_chunk, cbRead);

        cbWanted -= cbRead;
        pbBuffer += cbRead;
	}

	return pbBuffer - (LPBYTE)pvBuffer;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\xodash\XODashLib\cdda.h ===
#pragma once
#include "ntiosvc.h"

#define CDDA_MAX_FRAMES_PER_READ 16
#define CDDA_BUFFER_SIZE (CDDA_MAX_FRAMES_PER_READ * CDAUDIO_BYTES_PER_FRAME)

class CCDDAStreamer
{
public:
	CCDDAStreamer(CNtIoctlCdromService* pDrive, DWORD dwRetries = 0);
	~CCDDAStreamer();

	int Read(void* pvBuffer, int nBytes);
	
	inline DWORD GetFrame() const
	{
		return m_dwCurFrame;
	}
	
	inline void SetFrame(DWORD dwFrame)
	{
		DbgPrint("Reseting CDDAStreamer frame to %d\n", dwFrame);
		m_dwCurFrame = dwFrame;
		m_ibChunk = 0;
	}

protected:
	int ReadFrames(void* pvBuffer, DWORD nFrameCount);

	BYTE *m_chunk;
	int m_ibChunk;

	CNtIoctlCdromService* m_pDrive;
    DWORD m_dwRetries;
	DWORD m_dwCurFrame;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\xodash\XODashLib\cdplayer.h ===
#pragma once

#ifdef _WINDOWS
#include <devioctl.h>
#include <ntddcdrm.h>

#include <dbt.h>
#endif


#include <dsound.h>

#include "xcdplay.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\xodash\XODashLib\DiscType.cpp ===
#include "std.h"
  
#include "ntiosvc.h"
#include "XOConst.h"
#include "fileutil.h"
#include "globals.h"


struct DISCTYPECHECK
{
    TCHAR* szPath;
    TCHAR* szDiscType;
    int nDiscType;
};

static const DISCTYPECHECK rgddc [] =
{
    { _T("CDROM0:\\default.xbe"), _T("Title"), eDiscTitle },
    { _T("CDROM0:\\video_ts\\video_ts.ifo"), _T("Video"), eDiscVideo },
    { _T("CDROM0:\\track01.cda"), _T("Audio"), eDiscAudio },
};



int GetDiscType()
{
    int nDiscType = eDiscBad;
    bool bRetry = true;

    if (g_cdrom.IsOpen())
        g_cdrom.Close();

    OBJECT_STRING DeviceName;
    RtlInitObjectString(&DeviceName, "\\??\\CdRom0:");
    IoDismountVolumeByName(&DeviceName);

    NTSTATUS Status;
    ULONG TrayState;
    Status = HalReadSMCTrayState(&TrayState, NULL);
    if (NT_SUCCESS(Status) && TrayState != SMC_TRAY_STATE_MEDIA_DETECT)
    {
        if (TrayState == SMC_TRAY_STATE_NO_MEDIA)
        {
            HANDLE hDevice;

            // At this point, the drive has told the SMC that media could not be
            // detected.  To decide whether this means that the tray is empty
            // versus the tray have unrecognized media, we need to send an IOCTL
            // to the device.

            hDevice = CreateFileA("cdrom0:", GENERIC_READ, FILE_SHARE_READ, NULL,
                OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

            if (hDevice != NULL)
            {
                BOOL fReturn;
                DWORD cbReturned;

                fReturn = DeviceIoControl(hDevice, IOCTL_CDROM_CHECK_VERIFY,
                    NULL, 0, NULL, 0, &cbReturned, NULL);

                // If the device reports back that the unit is ready (which it
                // shouldn't since the SMC thinks the tray is empty) or if the
                // media is unrecognized, then the disc is bad.
                if (fReturn || (GetLastError() == ERROR_UNRECOGNIZED_MEDIA))
                {
                    CloseHandle(hDevice);
                    return eDiscBad;
                }

                CloseHandle(hDevice);
            }
        }

        return eDiscNone;
    }

    g_cdrom.Open(1);

    if (g_cdrom.IsOpen())
        return eDiscAudio;

    for (int i = 0; i < sizeof (rgddc) / sizeof (DISCTYPECHECK); )
    {
        if (DoesFileExist(rgddc[i].szPath))
        {
            nDiscType = rgddc[i].nDiscType;
            break;
        }

        DWORD dwError = GetLastError();

        if (dwError != ERROR_FILE_NOT_FOUND && dwError != ERROR_PATH_NOT_FOUND)
        {
            DbgPrint("\001Error %d on %s\n", dwError, rgddc[i].szPath);

            if (bRetry)
            {
                DbgPrint("Retrying...\n");
                bRetry = false;
                Sleep(100);
                continue;
            }
        }

        i += 1;
        bRetry = true;
    }

    return nDiscType;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\xodash\XODashLib\DSoundManager.h ===
#pragma once


class DSoundManager 
  {
  public:
      static DSoundManager* Instance();
	  ~DSoundManager();
	  HRESULT Initialize();
	  HRESULT Cleanup();
	  HRESULT DSoundCreateSoundBuffer(IN WAVEFORMATEX* pwfx, IN int nByteCount, IN DWORD dwFlags, OUT LPDIRECTSOUNDBUFFER* pDirectBuf);
	  HRESULT DSoundSetSoundBufferData(LPDIRECTSOUNDBUFFER pDirectSoundBuffer, UINT nByteOffset, UINT nByteCount, const void* pvData);
	  HRESULT DSoundSetSoundBufferNotify(LPDIRECTSOUNDBUFFER pDirectSoundBuffer, int nPositionCount, DSBPOSITIONNOTIFY* positions);
	  
	  bool m_bShutdown;

  protected:
      DSoundManager();
      DSoundManager(const DSoundManager&);
      DSoundManager& operator= (const DSoundManager&);
  private:

      static DSoundManager* pinstance;
	  LPDIRECTSOUND8 m_pDirectSound;
	  HANDLE m_hDirectSoundThread;


 };
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\xodash\XODashLib\date.cpp ===
/*************************************************************************************************\
Date.cpp  			: Implementation of all necessary Date functions
Creation Date		: 2/12/2002 9:47:54 AM
Copyright (c) Microsoft Corporation.  All rights reserved
Author				: Victor Blanco
//-------------------------------------------------------------------------------------------------
Notes				: 
\*************************************************************************************************/

#include "std.h"
#include "date.h"

int CDateObject::isLeapYear(int nYear)
{
    if (nYear % 100 == 0 && nYear % 400 != 0)
		return 0;

	if (nYear % 4 == 0)
		return 1;

	return 0;
}

int CDateObject::getDaysInMonth(int nMonth, int nYear)
{
	static short rgdays [] = { 31, 0, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };

	if (nMonth != 2)
		return rgdays[nMonth - 1];

	return isLeapYear(nYear) ? 29 : 28;
}

CDateObject::CDateObject()
{
    SYSTEMTIME stime;
    GetSystemTime( &stime );
    SystemTimeToFileTime(&stime, &m_time);
}

CDateObject::~CDateObject()
{
}

void CDateObject::setFileTime ( FILETIME ftTime )
{
    if( ftTime.dwHighDateTime == 0 && ftTime.dwLowDateTime == 0 )
    {
	    SYSTEMTIME stime;
        GetSystemTime( &stime );
	    SystemTimeToFileTime(&stime, &m_time);
    }
    else
    {
        m_time.dwHighDateTime = ftTime.dwHighDateTime;
        m_time.dwLowDateTime  = ftTime.dwLowDateTime;
    }
}

int CDateObject::getDate()
{
	FILETIME local;
	FileTimeToLocalFileTime(&m_time, &local);

	SYSTEMTIME st;
	FileTimeToSystemTime(&local, &st);

	return st.wDay;
}

int CDateObject::getDay()
{
	SYSTEMTIME st;
	FileTimeToSystemTime(&m_time, &st);

	return st.wDay;
}

int CDateObject::getFullYear()
{
	SYSTEMTIME st;
	FileTimeToSystemTime(&m_time, &st);

	return st.wYear;
}

int CDateObject::getHours()
{
	FILETIME local;
	FileTimeToLocalFileTime(&m_time, &local);

	SYSTEMTIME st;
	FileTimeToSystemTime(&local, &st);

	return st.wHour;
}

int CDateObject::getMilliseconds()
{
	FILETIME local;
	FileTimeToLocalFileTime(&m_time, &local);

	SYSTEMTIME st;
	FileTimeToSystemTime(&local, &st);

	return st.wMilliseconds;
}

int CDateObject::getMinutes()
{
	FILETIME local;
	FileTimeToLocalFileTime(&m_time, &local);

	SYSTEMTIME st;
	FileTimeToSystemTime(&local, &st);

	return st.wMinute;
}

int CDateObject::getMonth()
{
	SYSTEMTIME st;
	FileTimeToSystemTime(&m_time, &st);

	return st.wMonth;
}

int CDateObject::getSeconds()
{
	FILETIME local;
	FileTimeToLocalFileTime(&m_time, &local);

	SYSTEMTIME st;
	FileTimeToSystemTime(&local, &st);

	return st.wSecond;
}

int CDateObject::getUTCDate()
{
	SYSTEMTIME st;
	FileTimeToSystemTime(&m_time, &st);

	return st.wDay;
}

int CDateObject::getUTCDay()
{
	SYSTEMTIME st;
	FileTimeToSystemTime(&m_time, &st);

	return st.wDayOfWeek;
}

int CDateObject::getUTCFullYear()
{
	SYSTEMTIME st;
	FileTimeToSystemTime(&m_time, &st);

	return st.wYear;
}

int CDateObject::getUTCHours()
{
	SYSTEMTIME st;
	FileTimeToSystemTime(&m_time, &st);

	return st.wHour;
}

int CDateObject::getUTCMilliseconds()
{
	SYSTEMTIME st;
	FileTimeToSystemTime(&m_time, &st);

	return st.wMilliseconds;
}

int CDateObject::getUTCMinutes()
{
	SYSTEMTIME st;
	FileTimeToSystemTime(&m_time, &st);

	return st.wMinute;
}

int CDateObject::getUTCMonth()
{
	SYSTEMTIME st;
	FileTimeToSystemTime(&m_time, &st);

	return st.wMonth - 1;
}

int CDateObject::getUTCSeconds()
{
	SYSTEMTIME st;
	FileTimeToSystemTime(&m_time, &st);

	return st.wSecond;
}

int CDateObject::getYear()
{
	int nYear = getFullYear();

	return nYear;
}

const TCHAR* rgszMonth3 [] = { _T("Jan"), _T("Feb"), _T("Mar"), _T("Apr"), _T("May"), _T("Jun"), _T("Jul"), _T("Aug"), _T("Sep"), _T("Oct"), _T("Nov"), _T("Dec") };

TCHAR* CDateObject::toGMTString()
{
	SYSTEMTIME st;
	FileTimeToSystemTime(&m_time, &st);

	TCHAR *szBuf = new TCHAR[32];
	_stprintf(szBuf, _T("%02d %s %d %02d:%02d:%02d GMT"), st.wDay, rgszMonth3[st.wMonth - 1], st.wYear, st.wHour, st.wMinute, st.wSecond);
	return szBuf;
}

// Initalize all of the date values to 1's and the current year
void CDateObject::clearDate()
{
    SYSTEMTIME st;
    GetSystemTime( &st );
    st.wMonth = st.wSecond = st.wDay = st.wHour = 1;

    SystemTimeToFileTime( &st, &m_time );
}

void CDateObject::setDay( unsigned int nDay )
{
	SYSTEMTIME st;
	FileTimeToSystemTime(&m_time, &st);

    st.wDay = (WORD)nDay;
    SystemTimeToFileTime( &st, &m_time );
}

void CDateObject::setMonth( unsigned int nMonth )
{
	SYSTEMTIME st;
	FileTimeToSystemTime(&m_time, &st);

    st.wMonth = (WORD)nMonth;
    SystemTimeToFileTime( &st, &m_time );
}

void CDateObject::setYear( unsigned int nYear )
{
	SYSTEMTIME st;
	FileTimeToSystemTime(&m_time, &st);

    st.wYear = (WORD)nYear;
    SystemTimeToFileTime( &st, &m_time );
}

// Calc Age looks at the current system time against the time stored as the member variable
int CDateObject::calcAge( void )
{
    // Current time
    SYSTEMTIME stToday;
    GetSystemTime( &stToday );
	
    SYSTEMTIME stBday;
	FileTimeToSystemTime( &m_time, &stBday );

    int nYearsOld = stToday.wYear - stBday.wYear - 1;
    if( ( stToday.wMonth <= stBday.wMonth ) && ( stToday.wDay <= stBday.wDay ) )
        nYearsOld++;
    
    return nYearsOld;
}

void CDateObject::zeroTime( void )
{
    m_time.dwHighDateTime = 0;
    m_time.dwHighDateTime = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\xodash\XODashLib\date.h ===
/*************************************************************************************************\
Date.h  			: Implementation of all necessary Date functions
Creation Date		: 2/12/2002 9:47:54 AM
Copyright (c) Microsoft Corporation.  All rights reserved
Author				: Victor Blanco
//-------------------------------------------------------------------------------------------------
Notes				: 
\*************************************************************************************************/

#pragma once

class CDateObject
{
public:
	CDateObject();
    ~CDateObject();

    void setFileTime ( FILETIME ftTime );
	int getDate();
	int getDay();
	int getFullYear();
	int getHours();
	int getMilliseconds();
	int getMinutes();
	int getMonth();
	int getSeconds();
	int getUTCDate();
	int getUTCDay();
	int getUTCFullYear();
	int getUTCHours();
	int getUTCMilliseconds();
	int getUTCMinutes();
	int getUTCMonth();
	int getUTCSeconds();
	int getYear();
    void clearDate();
    void setDay( unsigned int nDay );
    void setMonth( unsigned int nMonth );
    void setYear( unsigned int nYear );
    void zeroTime( void );
    int calcAge( void );

	int isLeapYear(int nYear);
	int getDaysInMonth(int nMonth, int nYear);

	void SetSystemClock();

	TCHAR* toGMTString();
	TCHAR* toLocaleString();
	TCHAR* toUTCString();

	FILETIME m_time; // 100-nanosecond intervals since January 1, 1601
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\xodash\XODashLib\DSoundManager.cpp ===
#include "std.h"
#include "utilities.h"
#include "DSoundManager.h"
#include "globals.h"
#include "XOConst.h"


DSoundManager* DSoundManager::pinstance = 0;// initialize pointer
  
DSoundManager* DSoundManager::Instance () 
{
    if (pinstance == 0)  // is it the first call?
    {  
      pinstance = new DSoundManager; 
    }
    return pinstance; // address of sole instance
}
  
DSoundManager::DSoundManager() : m_pDirectSound(NULL), m_hDirectSoundThread(NULL), m_bShutdown(false)
{ 

}

static DWORD WINAPI DirectSoundThreadProc(LPVOID pvParameter)
{
	DSoundManager *pThis = static_cast<DSoundManager*> (pvParameter);
	
    while(!pThis->m_bShutdown)
    {
        DirectSoundDoWork();
        Sleep(1000);
    }

    return 0;
}


HRESULT DSoundManager::Initialize()
{
	HRESULT hr = S_OK;

	DbgPrint("Initializing DirectSound...\n");
	if(m_pDirectSound != NULL)
	{
		return S_FALSE;
	}

	//
	// BUGBUG: remove this hack to prevent dsound from initializing when we're playing a DVD
	//
	if (eDiscVideo == g_nDiscType)
	{
		//LogComError(E_FAIL, "DSound_Init: Not initializing with DVD-Video disc in drive");
		return false;
	}

#ifdef _XBOX

    DWORD dwSpeakerConfig = XAudioGetSpeakerConfig();

    if(DSSPEAKER_MONO == DSSPEAKER_BASIC(dwSpeakerConfig))
    {
        g_dwDirectSoundOverrideSpeakerConfig = DSSPEAKER_COMBINED(DSSPEAKER_MONO, 0);
    }
    else
    {
        g_dwDirectSoundOverrideSpeakerConfig = DSSPEAKER_COMBINED(DSSPEAKER_STEREO, 0);
    }

#endif

	if (FAILED(hr = DirectSoundCreate(NULL, &m_pDirectSound, NULL)))
	{
		LogComError(hr, "DSound_Init: DirectSoundCreate");
		return hr;
	}

    if (FAILED(hr = m_pDirectSound->SetMixBinHeadroom(NULL, 0)))
    {
		LogComError(hr, "DSound_Init: SetMixBinHeadroom");
	}

#ifdef _XBOX

    DWORD dwThreadId;
    m_hDirectSoundThread = CreateThread(NULL, 0, DirectSoundThreadProc, this, 0, &dwThreadId);
    if (!m_hDirectSoundThread)
    {
		hr = HRESULT_FROM_WIN32(GetLastError());
		LogComError(hr, "DSound_Init: failed to create DirectSound worker thread");
		return hr;
	}

#else

	ASSERT(theApp.m_hWnd != NULL);
	if (FAILED(hr = m_pDirectSound->SetCooperativeLevel(theApp.m_hWnd, DSSCL_PRIORITY)))
	{
		LogComError(hr, "DSound_Init: SetCooperativeLevel");
		// Not fatal!
	}

	DSBUFFERDESC dsbdesc;
	dsbdesc.dwSize = sizeof (dsbdesc);
	dsbdesc.dwFlags = DSBCAPS_PRIMARYBUFFER | DSBCAPS_GLOBALFOCUS;
	dsbdesc.dwBufferBytes = 0;
	dsbdesc.dwReserved = 0;
	dsbdesc.lpwfxFormat = NULL;
	dsbdesc.guid3DAlgorithm = GUID_NULL;

	LPDIRECTSOUNDBUFFER pDSBPrimary;
	if (FAILED(hr = m_pDirectSound->CreateSoundBuffer(&dsbdesc, &pDSBPrimary, NULL)))
	{
		DbgPrint("\002CreateSoundBuffer with DSBCAPS_GLOBALFOCUS failed, trying without...\n");
		dsbdesc.dwFlags &= ~DSBCAPS_GLOBALFOCUS;
		if (FAILED(hr = m_pDirectSound->CreateSoundBuffer(&dsbdesc, &pDSBPrimary, NULL)))
		{
			LogComError(hr, "DSound_Init: CreateSoundBuffer");
			return hr;
		}
	}

	WAVEFORMATEX wfx;
	ZeroMemory(&wfx, sizeof(WAVEFORMATEX));
	wfx.wFormatTag = WAVE_FORMAT_PCM;
	wfx.nChannels = 2;
	wfx.nSamplesPerSec = 44100;
	wfx.wBitsPerSample = 16;
	wfx.nBlockAlign = wfx.wBitsPerSample / 8 * wfx.nChannels;
	wfx.nAvgBytesPerSec = wfx.nSamplesPerSec * wfx.nBlockAlign;

	DbgPrint("SetFormat...");
	if (FAILED(hr = pDSBPrimary->SetFormat(&wfx)))
		LogComError(hr, "DSound_Init: SetFormat");

	pDSBPrimary->Release();
#endif

	return hr;
}

HRESULT DSoundManager::Cleanup()
{
	m_bShutdown = true;  // close the Direct sound thread
	if (m_pDirectSound != NULL)
    {
		m_pDirectSound->Release();
        m_pDirectSound = NULL;
    }

    if (m_hDirectSoundThread != NULL)
    {
        CloseHandle(m_hDirectSoundThread);
    }
	return S_OK;
}

DSoundManager::~DSoundManager()
{
	Cleanup();
}

HRESULT DSoundManager::DSoundCreateSoundBuffer(IN WAVEFORMATEX* pwfx, IN int nByteCount, IN DWORD dwFlags, OUT LPDIRECTSOUNDBUFFER* pDirectBuf)
{
    HRESULT hr = S_OK;
	*pDirectBuf = NULL;
	if (!m_pDirectSound == NULL)
	{
		hr = Initialize();	
	}

	if(FAILED(hr))
	{
		DbgPrint("DSoundManager::DSoundCreateSoundBuffer - fail to Init DSoundManager");
		return hr;
	}

	LPDIRECTSOUNDBUFFER lpDirectSoundBuffer = NULL;
	DSBUFFERDESC dsbd;
	ZeroMemory(&dsbd, sizeof (DSBUFFERDESC));
	dsbd.dwSize = sizeof (DSBUFFERDESC);

	dsbd.dwFlags = dwFlags;
#ifndef _XBOX
	dsbd.dwFlags |= DSBCAPS_GLOBALFOCUS;
#endif
	dsbd.dwBufferBytes = nByteCount;
	dsbd.lpwfxFormat = pwfx;

    hr = m_pDirectSound->CreateSoundBuffer(&dsbd, &lpDirectSoundBuffer, NULL);

#ifdef _XBOX

    if(SUCCEEDED(hr))
    {
        lpDirectSoundBuffer->SetHeadroom(1200);
    }

#endif
	
	*pDirectBuf = lpDirectSoundBuffer;
	return hr;
}

HRESULT DSoundManager::DSoundSetSoundBufferData(LPDIRECTSOUNDBUFFER pDirectSoundBuffer, UINT nByteOffset, UINT nByteCount, const void* pvData)
{
	LPVOID pbBuffer;
	DWORD dwBufferLength;

	ASSERT(pDirectSoundBuffer != NULL);

	HRESULT hr = pDirectSoundBuffer->Lock(nByteOffset, nByteCount, &pbBuffer, &dwBufferLength, NULL, NULL, 0L);
	if (FAILED(hr))
	{
		DbgPrint("DSoundManager::DSoundSetSoundBufferData - Fail to locksound buffer");
		return hr;
	}

	CopyMemory(pbBuffer, pvData, nByteCount);

	hr = pDirectSoundBuffer->Unlock(pbBuffer, dwBufferLength, NULL, 0);
	if (FAILED(hr))
	{
		DbgPrint("DSoundManager::DSoundSetSoundBufferData - Fail to unlock sound buffer");
		return hr;
	}
	return hr;
}


HRESULT DSoundManager::DSoundSetSoundBufferNotify(LPDIRECTSOUNDBUFFER pDirectSoundBuffer, int nPositionCount, DSBPOSITIONNOTIFY* positions)
{

// #pragma _TODO_ (Handle Non-XBox errors)
	HRESULT hr;
#ifdef _XBOX
	hr = pDirectSoundBuffer->SetNotificationPositions(nPositionCount, positions);
#else
	LPDIRECTSOUNDNOTIFY pDSNotify;
	hr = pDirectSoundBuffer->QueryInterface(IID_IDirectSoundNotify, (void**)&pDSNotify));
	hr = pDSNotify->SetNotificationPositions(nPositionCount, positions));
	hr = pDSNotify->Release();
#endif
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\xodash\XODashLib\effect3.h ===
DWORD dwEffect3VertexShader[] = {
	0x00152078,
	0x00000000, 0x00ec001b, 0x0836186c, 0x20708800,
	0x00000000, 0x00ed401b, 0x0836186c, 0x28200ff8,
	0x00000000, 0x00aca61b, 0x0836186c, 0x28300ff8,
	0x00000000, 0x00ec201b, 0x0836186c, 0x20704800,
	0x00000000, 0x00ed601b, 0x0836186c, 0x24200ff8,
	0x00000000, 0x00acc61b, 0x0836186c, 0x24300ff8,
	0x00000000, 0x00ec401b, 0x0836186c, 0x20702800,
	0x00000000, 0x00ed801b, 0x0836186c, 0x22200ff8,
	0x00000000, 0x00ace61b, 0x0836186c, 0x22300ff8,
	0x00000000, 0x00ec601b, 0x0836186c, 0x20701800,
	0x00000000, 0x02a00c1b, 0x3436686c, 0x2140f84c,
	0x00000000, 0x002e001b, 0x0c36106c, 0x2fa00ff8,
	0x00000000, 0x08a0001b, 0x24364bfd, 0x11510ff8,
	0x00000000, 0x0647401b, 0xc4361bff, 0x1078e800,
	0x00000000, 0x0800001b, 0x083613fd, 0x50610ff8,
	0x00000000, 0x0040001b, 0x35fe286c, 0x2e700ff8,
	0x00000000, 0x0040001b, 0x25fec86c, 0x2e800ff8,
	0x00000000, 0x00a0001b, 0x7437086c, 0x21900ff8,
	0x00000000, 0x0087601b, 0xc400286c, 0x3070e800,
	0x00000000, 0x014000ff, 0x97ff286c, 0x21b00ff8,
	0x00000000, 0x008de01b, 0xa5ff686c, 0x3070f819
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\xodash\XODashLib\effect2.h ===
DWORD dwEffect2VertexShader[] = {
	0x00152078,
	0x00000000, 0x00ec001b, 0x0836186c, 0x20708800,
	0x00000000, 0x00ed401b, 0x0836186c, 0x28200ff8,
	0x00000000, 0x00aca61b, 0x0836186c, 0x28300ff8,
	0x00000000, 0x00ec201b, 0x0836186c, 0x20704800,
	0x00000000, 0x00ed601b, 0x0836186c, 0x24200ff8,
	0x00000000, 0x00acc61b, 0x0836186c, 0x24300ff8,
	0x00000000, 0x00ec401b, 0x0836186c, 0x20702800,
	0x00000000, 0x00ed801b, 0x0836186c, 0x22200ff8,
	0x00000000, 0x00ace61b, 0x0836186c, 0x22300ff8,
	0x00000000, 0x00ec601b, 0x0836186c, 0x20701800,
	0x00000000, 0x02a00e18, 0x3430686c, 0x2140f84c,
	0x00000000, 0x002e001b, 0x0c36106c, 0x2fa00ff8,
	0x00000000, 0x08a00018, 0x24304bfd, 0x11510ff8,
	0x00000000, 0x0647401b, 0xc4361bff, 0x1078e800,
	0x00000000, 0x0800001b, 0x083613fd, 0x50610ff8,
	0x00000000, 0x00400018, 0x35fe286c, 0x2e700ff8,
	0x00000000, 0x00400018, 0x25fec86c, 0x2e800ff8,
	0x00000000, 0x00a00018, 0x7431086c, 0x21900ff8,
	0x00000000, 0x0087601b, 0xc400286c, 0x3070e800,
	0x00000000, 0x014000ff, 0x97ff286c, 0x21b00ff8,
	0x00000000, 0x008de01b, 0xa5ff686c, 0x3070f819
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\xodash\XODashLib\effect.h ===
DWORD dwEffectVertexShader[] = {
	0x00152078,
	0x00000000, 0x00ec001b, 0x0836186c, 0x20708800,
	0x00000000, 0x00ed401b, 0x0836186c, 0x28200ff8,
	0x00000000, 0x00aca61b, 0x0836186c, 0x28300ff8,
	0x00000000, 0x00ec201b, 0x0836186c, 0x20704800,
	0x00000000, 0x00ed601b, 0x0836186c, 0x24200ff8,
	0x00000000, 0x00acc61b, 0x0836186c, 0x24300ff8,
	0x00000000, 0x00ec401b, 0x0836186c, 0x20702800,
	0x00000000, 0x00ed801b, 0x0836186c, 0x22200ff8,
	0x00000000, 0x00ace61b, 0x0836186c, 0x22300ff8,
	0x00000000, 0x00ec601b, 0x0836186c, 0x20701800,
	0x00000000, 0x00a0001b, 0x3436686c, 0x21400ff8,
	0x00000000, 0x002e001b, 0x0c36106c, 0x2f500ff8,
	0x00000000, 0x08a0001b, 0x24364bfd, 0x11610ff8,
	0x00000000, 0x0647401b, 0xc4361bff, 0x1078e800,
	0x00000000, 0x0800001b, 0x083613fd, 0x90710ff8,
	0x00000000, 0x0040001b, 0x35fe286c, 0x2e800ff8,
	0x00000000, 0x0040001b, 0x25fee86c, 0x2e900ff8,
	0x00000000, 0x00a0001b, 0x8437286c, 0x21a00ff8,
	0x00000000, 0x0087601b, 0xc400286c, 0x3070e800,
	0x00000000, 0x014000ff, 0xa7ff486c, 0x21b00ff8,
	0x00000000, 0x008de01b, 0x55ff686c, 0x3070f819
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\xodash\XODashLib\effect4.h ===
DWORD dwEffect4VertexShader[] = {
	0x001d2078,
	0x00000000, 0x00f1001b, 0x0836186c, 0x28200ff8,
	0x00000000, 0x00f1201b, 0x0836186c, 0x24200ff8,
	0x00000000, 0x00f1401b, 0x0836186c, 0x22200ff8,
	0x00000000, 0x00f1601b, 0x0836186c, 0x21200ff8,
	0x00000000, 0x00b1061b, 0x0836186c, 0x28300ff8,
	0x00000000, 0x00b1261b, 0x0836186c, 0x24300ff8,
	0x00000000, 0x00b1461b, 0x0836186c, 0x22300ff8,
	0x00000000, 0x00f1801b, 0x2436186c, 0x20708800,
	0x00000000, 0x00f1a01b, 0x2436186c, 0x20704800,
	0x00000000, 0x00f1c01b, 0x2436186c, 0x20702800,
	0x00000000, 0x00f1e01b, 0x2436186c, 0x20701800,
	0x00000000, 0x00a0001b, 0x3436686c, 0x21400ff8,
	0x00000000, 0x00b2261b, 0x0836186c, 0x21800ff8,
	0x00000000, 0x08a0001b, 0x24364bfd, 0x11610ff8,
	0x00000000, 0x002e001b, 0x0c36106c, 0x2f900ff8,
	0x00000000, 0x0040001b, 0x35fe286c, 0x2e500ff8,
	0x00000000, 0x0940001b, 0x86370bfd, 0x91a10ff8,
	0x00000000, 0x008de01b, 0x95ff486c, 0x3070f818,
	0x00000000, 0x0040001b, 0x25fe286c, 0x2e700ff8,
	0x00000000, 0x00a0001b, 0x7436a86c, 0x21b00ff8,
	0x00000000, 0x0647401b, 0xc4361bff, 0x1078e800,
	0x00000000, 0x006000ff, 0xb43613fe, 0xd1000ff8,
	0x00000000, 0x0087601b, 0xc400286c, 0x3070e800,
	0x00000000, 0x008000ff, 0x0434ac69, 0xde200ff8,
	0x00000000, 0x0072001a, 0x0c361068, 0x9e300ff8,
	0x00000000, 0x00a0001b, 0x3436686c, 0x21400ff8,
	0x00000000, 0x0800001b, 0x083613fd, 0x10110ff8,
	0x00000000, 0x005200ff, 0x15fe186c, 0x21500ff8,
	0x00000000, 0x0092001a, 0x25feabfc, 0x3070e849
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\xodash\XODashLib\File.cpp ===
//---------------------------------------------------------------------------
//
// file.cpp - This file contains the class functions for File
//
//				The File class simply calls the Windows file functions.
//				It is purely a wrapper.
//
//				The mmFile Class is a wrapper for the Win32 Memory Mapped
//				file functionality.  It is used exactly the same as above class.
//
//	Honor Bound -- FASA Interactive Technologies
//
//	Copyright (c) 1995 FASA Interactive Technologies
//
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
// Include files
#include "std.h"
#include <sys/stat.h>

#ifndef FILE_H
#include "file.h"
#endif
#include <io.h>

#include "utilities.h"


// putting the paths here....
char* g_pScenePath = "d:\\media\\";

//-----------------
// Static Variables
unsigned long File::lastError = NO_ERR;
bool		  File::logFileTraffic = FALSE;

File* fileTrafficLog = NULL;
char CDInstallPath[1024];
void EnterWindowMode();
void EnterFullScreenMode();
void __stdcall ExitGameOS();

extern char FileMissingString[];
extern char CDMissingString[];
extern char MissingTitleString[];

#undef INVALID_HANDLE_VALUE
#define INVALID_HANDLE_VALUE	-1
//---------------------------------------------------------------------------
void createTrafficLog (void)
{
	if (fileTrafficLog && fileTrafficLog->isOpen())
		return;

	fileTrafficLog = new File;
	fileTrafficLog->create("filetraffic.log");
}

//---------------------------------------------------------------------------
// Global Functions
long fileExists (char* fName)
{
	struct _stat st;
	if (_stat(fName,&st) != -1)
	{
		return 1;
	}

/*	long fastFileHandle = -1;
	FastFile*	fastFile = FastFileFind(fName,fastFileHandle);
	if (fastFile)
		return 2;*/

	return 0;
}

//---------------------------------------------------------------------------
long fileExistsOnCD (char* fName)
{
	//Just add the CD path here and see if its there.
	char bigPath[2048];
	strcpy(bigPath,CDInstallPath);
	strcat(bigPath,fName);

	struct _stat st;
	if (_stat(bigPath,&st) != -1)
	{
		return 1;
	}

	return 0;
}

//---------------------------------------------------------------------------
bool file1OlderThan2 (char* file1, char* file2)
{
	if ((fileExists(file1) == 1) && (fileExists(file2) == 1))
	{
		struct _stat st1, st2;
		_stat(file1,&st1);
		_stat(file2,&st2);
		
		if (st1.st_mtime < st2.st_mtime)
			return true;
	}

	return false;
}


//---------------------------------------------------------------------------
File::File (void)
{
	fileName = NULL;
	fileMode = NOMODE;
	handle = -1;
	length = 0;
	logicalPosition = 0;
	bufferResult = 0;

	parent = NULL;
	parentOffset = 0;
	physicalLength = 0;

	childList = NULL;
	numChildren = 0;

	inRAM = FALSE;
	fileImage = NULL;

//	fastFile = NULL;
}
			
//---------------------------------------------------------------------------
inline void File::setup (void)
{
	logicalPosition = 0;
	
	//----------------------------------------------------------------------
	//This is only called from an open with a filename, not a file pointer.
	// ie. It assumes we are the parent.
	if (isOpen())
		length = fileSize();
	else
		length = 0;

	parent = NULL;
	parentOffset = 0;
	physicalLength = length;
	
	childList = NULL;
	numChildren = 0;
}

//---------------------------------------------------------------------------
File::~File (void)
{
	close();
}

//---------------------------------------------------------------------------
bool File::eof (void)
{
	return (logicalPosition >= getLength());
}

//---------------------------------------------------------------------------
long File::open (const char* fName, FileMode _mode, long numChild)
{
	ASSERT( !isOpen() );
	//-------------------------------------------------------------
	long fNameLength = strlen(fName);
	
	fileName = new char[fNameLength+1];
	ASSERT(fileName != NULL);
		
	strncpy(fileName,fName,fNameLength+1);
	fileMode = _mode;
	_fmode = _O_BINARY;

	_strlwr(fileName);

	if (fileMode == CREATE)
	{
		handle = _creat(fileName,_S_IWRITE);
		if (handle == INVALID_HANDLE_VALUE)
		{
			lastError = errno;
			return lastError;
		}
	}
    else if ( fileMode == MC2_APPEND )
    {
        handle = _open(fileName, _O_APPEND | _O_WRONLY );
        if (handle == INVALID_HANDLE_VALUE)
		{
			lastError = errno;
			return lastError;
		}
    }
	else
	{
		//----------------------------------------------------------------
		//-- First, see if file is in normal place.  Useful for patches!!
		handle = _open(fileName,_O_RDONLY);


        if (handle == INVALID_HANDLE_VALUE)
        {
            char errorStr[255];
            sprintf( errorStr, "couldn't find file %s", fileName );
            DbgPrint( errorStr );
            ASSERT( !errorStr );
 //           TRACE( errorStr );
            return 2;
        }

		//------------------------------------------
		//-- Next, see if file is in fastFile.
		/*if (handle == INVALID_HANDLE_VALUE)
		{
			lastError = errno;

			fastFile = FastFileFind(fileName,fastFileHandle);
			if (!fastFile)
			{
				//Not in main installed directory and not in fastfile.  Look on CD.

				char actualPath[2048];
				strcpy(actualPath,CDInstallPath);
				strcat(actualPath,fileName);
				handle = _open(actualPath,_O_RDONLY);
				if (handle == INVALID_HANDLE_VALUE)
				{
					bool openFailed = false;
					bool alreadyFullScreen = (Environment.fullScreen != 0);
					while (handle == INVALID_HANDLE_VALUE)
					{
						openFailed = true;

						//OK, check to see if the CD is actually present.
						// Do this by checking for tgl.fst on the CD Path.
						// If its there, the CD is present BUT the file is missing.
						// MANY files in MechCommander 2 are LEGALLY missing!
						// Tell it to the art staff.
						char testCDPath[2048];
						strcpy(testCDPath,CDInstallPath);
						strcat(testCDPath,"tgl.fst");

						DWORD findCD = fileExists(testCDPath);
						if (findCD == 1)	//File exists. CD is in drive.  Return 2 to indicate file not found.
							return 2;

						EnterWindowMode();
		
						char data[2048];
						sprintf(data,FileMissingString,fileName,CDMissingString);
						DWORD result1 = MessageBox(NULL,data,MissingTitleString,MB_OKCANCEL | MB_ICONWARNING);
						if (result1 == IDCANCEL)
						{
							ExitGameOS();
							return (2);		//File not found.  Never returns though!
						}
		
						handle = _open(actualPath,_O_RDONLY);
					}
		
					if (openFailed && (Environment.fullScreen == 0) && alreadyFullScreen)
						EnterFullScreenMode();
				}
				else
				{
					if (logFileTraffic && (handle != INVALID_HANDLE_VALUE))
					{
						if (!fileTrafficLog)
						{
							createTrafficLog();
						}

						char msg[300];
						sprintf(msg,"CFHandle  Length: %010d    File: %s",fileSize(),fileName);
						fileTrafficLog->writeLine(msg);
					}

					setup();

					//------------------------------------------------------------
					// NEW FUNCTIONALITY!!!
					// 
					// Each file may have a number of files open as children which
					// use the parent's handle for reads and writes.  This would
					// allow us to open a packet file and read a packet as a fitIni
					// or allow us to write a packet as a fit ini and so forth.
					//
					// It also allows us to use the packet file extensions as tree
					// files to avoid the ten thousand file syndrome.
					//
					// There is now an open which takes a FilePtr and a size.
					maxChildren = numChild;
					childList = (FilePtr *)systemHeap->Malloc(sizeof(FilePtr) * maxChildren);

					if (!childList)
					{
						return(NO_RAM_FOR_CHILD_LIST);
					}

					numChildren = 0;
					for (long i=0;i<(long)maxChildren;i++)
					{
						childList[i] = NULL;
					}	

					return (NO_ERR);
				}
			}

			if (logFileTraffic)
			{
				if (!fileTrafficLog)
				{
					createTrafficLog();
				}
	
				char msg[300];
				sprintf(msg,"FASTF     Length: %010d    File: %s",fileSize(),fileName);
				fileTrafficLog->writeLine(msg);
			}

			//---------------------------------------------------------------------
			//-- FastFiles are all compressed.  Must read in entire chunk into RAM
			//-- Then close fastfile!!!!!
			inRAM = TRUE;

			fileImage = (unsigned char *)malloc(fileSize());
			if (fileImage)
			{
				fastFile->readFast(fastFileHandle,fileImage,fileSize());

				physicalLength = getLength();
				//------------------------------------
				//-- Image is in RAM.  Shut the file.
				//fastFile->closeFast(fastFileHandle);
				//fastFile = NULL;
				//fastFileHandle = -1;

				logicalPosition = 0;
			}

			return NO_ERR;
		}*/
		else
		{
			if (logFileTraffic && (handle != INVALID_HANDLE_VALUE))
			{
				if (!fileTrafficLog)
				{
					createTrafficLog();
				}
	
				char msg[300];
				sprintf(msg,"CFHandle  Length: %010d    File: %s",fileSize(),fileName);
				fileTrafficLog->writeLine(msg);
			}

			setup();
	
			//------------------------------------------------------------
			// NEW FUNCTIONALITY!!!
			// 
			// Each file may have a number of files open as children which
			// use the parent's handle for reads and writes.  This would
			// allow us to open a packet file and read a packet as a fitIni
			// or allow us to write a packet as a fit ini and so forth.
			//
			// It also allows us to use the packet file extensions as tree
			// files to avoid the ten thousand file syndrome.
			//
			// There is now an open which takes a FilePtr and a size.
			maxChildren = numChild;
			childList = new File*[maxChildren];
			
			if (!childList)
			{
				return(NO_RAM_FOR_CHILD_LIST);
			}
		
			numChildren = 0;
			for (long i=0;i<(long)maxChildren;i++)
			{
				childList[i] = NULL;
			}	
	
			return (NO_ERR);
		}
	}
	
	return(NO_ERR);
}
		
//---------------------------------------------------------------------------
long File::open (File* _parent, unsigned long fileSize, long numChild)
{
	if (_parent/* && (_parent->fastFile == NULL)*/)
	{
		parent = _parent;
		if (parent->getFileMode() != READ)
		{
			return(CANT_WRITE_TO_CHILD);
		}
		
		physicalLength = fileSize;
		parentOffset = parent->getLogicalPosition();
		logicalPosition = 0;

		//-------------------------------------------------------------
		fileName = parent->getFilename();
		fileMode = parent->getFileMode();
		
		handle = parent->getFileHandle();
		
		if (logFileTraffic)
		{
			if (!fileTrafficLog)
			{
				createTrafficLog();
			}
		
			char msg[300];
			sprintf(msg,"CHILD     Length: %010d    File: %s",fileSize,_parent->getFilename());
			fileTrafficLog->writeLine(msg);
		}

		long result = parent->addChild(this);
		if (result != NO_ERR)
			return(result);

		//------------------------------------------------------------
		// NEW FUNCTIONALITY!!!
		// 
		// Each file may have a number of files open as children which
		// use the parent's handle for reads and writes.  This would
		// allow us to open a packet file and read a packet as a fitIni
		// or allow us to write a packet as a fit ini and so forth.
		//
		// It also allows us to use the packet file extensions as tree
		// files to avoid the ten thousand file syndrome.
		//
		// There is now an open which takes a File* and a size.
		// 
		// IF a numChild parameter is passed in as -1, we want this file in RAM!!
		// This means NO CHILDREN!!!!!!!!!!!!!
		if (numChild != -1)
		{
			maxChildren = numChild;
			childList = new File*[maxChildren];
			
			ASSERT(childList != NULL);

			numChildren = 0;
			for (long i=0;i<(long)maxChildren;i++)
			{
				childList[i] = NULL;
			}	
		}
		else
		{
			maxChildren = 0;
			inRAM = TRUE;
			unsigned long result = 0;

			fileImage = new BYTE[fileSize];
			if (!fileImage)
				inRAM = FALSE;

/*			if (_parent->getFileClass() == PACKETFILE)
			{
				result = ((PacketFile*)_parent)->readPacket(((PacketFile*)_parent)->getCurrentPacket(),fileImage);
			}
			else*/
			{
				result = _read(handle,fileImage,fileSize);
				if (result != fileSize)
					lastError = errno;
			}
		}
	}
	else
	{
		return(PARENT_NULL);
	}
	
	return(NO_ERR);
}

long File::open(const char* buffer, int bufferLength )
{
	if ( buffer && bufferLength > 0 )
	{	
		fileImage = (unsigned char*)buffer;
		physicalLength = bufferLength;
		logicalPosition = 0;
		fileMode = RDWRITE;
		inRAM = true;
	}
	else// fail on NULL
	{
		return FILE_NOT_OPEN;
	}

	return NO_ERR;


}

//---------------------------------------------------------------------------
long File::create (const char* fName)
{
	return (open(fName,CREATE));
}

long File::createWithCase( char* fName )
{
	ASSERT( !isOpen() );
	//-------------------------------------------------------------
	long fNameLength = strlen(fName);
	
	fileName = new char[fNameLength+1];
	ASSERT(fileName != NULL);
		
	strncpy(fileName,fName,fNameLength+1);
	fileMode = CREATE;
	_fmode = _O_BINARY;

	handle = _creat(fileName,_S_IWRITE);
	if (handle == INVALID_HANDLE_VALUE)
	{
		lastError = errno;
		return lastError;
	}

	return 0;
}
//---------------------------------------------------------------------------
long File::addChild (File* child)
{
	if (maxChildren)
	{
		for (long i=0;i < (long)maxChildren;i++)
		{
			if (childList[i] == NULL)
			{
				childList[i] = child;
				return NO_ERR;
			}
		}
	}

	return(TOO_MANY_CHILDREN);
}

//---------------------------------------------------------------------------
void File::removeChild (File* child)
{
	if (maxChildren)
	{
		if (childList)
		{
			for (long i=0;i < (long)maxChildren;i++)
			{
				if (childList[i] == child)
				{
					childList[i] = NULL;
					break;
				}
			}
		}
	}
}

//---------------------------------------------------------------------------
void File::close (void)
{
	//------------------------------------------------------------------------
	// First, close us if we are the parent.  Otherwise, just NULL the handle
	// DO NOT CALL CLOSE IF WE ARE A CHILD!!
	//
	// The actual stored filename is also in the parent.  Everyone else just has
	// pointer and, as such, only the parent frees the memory.

	bool bFast = false;

	if ((parent == NULL) && (fileName != NULL))
	{
		delete fileName;
	}

	fileName = NULL;
	length = 0;

	if (isOpen())
	{
		if ((parent == NULL) && (handle != NULL) && (-1 != handle))
			_close(handle);
			
		handle = NULL;

/*		if (fastFile)
		{
   			fastFile->closeFast(fastFileHandle);
			bFast = true; // save that it was a fast file
		}

		fastFile = NULL;			//DO NOT DELETE THE FASTFILE!!!!!!!!!!!!!
		fastFileHandle = -1;*/
	}
	
	//---------------------------------------------------------------------
	// Check if we have any children and close them.  This will set their
	// handle to NULL and their filename to NULL.  It will also close any
	// of THEIR children.
	if (maxChildren)
	{
		if (childList)
		{
			for (long i=0;i<(long)maxChildren;i++)
			{
				if (childList[i])
					childList[i]->close();
			}
		}

		if (childList)
			delete childList;
	}
	
	if (parent != NULL)
		parent->removeChild(this);

	childList = NULL;
	numChildren = 0;

	if (inRAM && (bFast || parent)) // don't want to delete memFiles
	{
		if (fileImage)
			free(fileImage);
		fileImage = NULL;
		inRAM = FALSE;
	}
}

//---------------------------------------------------------------------------
void File::deleteFile (void)
{
	//--------------------------------------------------------------
	// Must be the ultimate parent to delete this file.  Close will
	// make sure all of the children close themselves.
	if (isOpen() && (parent == NULL))
		close();
}

long newPosition = 0;
//---------------------------------------------------------------------------
long File::seek (long pos, long from)
{
	switch (from)
	{
		case SEEK_SET:
			if (pos > (long)getLength())
			{
				return READ_PAST_EOF_ERR;
			}
			break;

		case SEEK_END:
			if ((abs(pos) > (long)getLength()) || (pos > 0))
			{
				return READ_PAST_EOF_ERR;
			}
			break;

		case SEEK_CUR:
			if (pos+logicalPosition > getLength())
			{
				return READ_PAST_EOF_ERR;
			}
			break;
	}

	if (inRAM && fileImage)
	{
		if (parent)
		{
			switch (from)
			{
				case SEEK_SET:
					newPosition = pos;
					break;

				case SEEK_END:
					newPosition = getLength()+parentOffset;
					newPosition += pos;
					break;

				case SEEK_CUR:
					newPosition += pos;
					break;
			}
		}
		else
		{
			switch (from)
			{
				case SEEK_SET:
					newPosition = pos;
					break;

				case SEEK_END:
					newPosition = getLength() + pos;
					break;

				case SEEK_CUR:
					newPosition += pos;
					break;
			}
		}

		if (newPosition == -1)
		{
			return (INVALID_SEEK_ERR);
		}

		logicalPosition = newPosition;

	}
//	else if (fastFile)
//	{
//		newPosition = fastFile->seekFast(fastFileHandle,pos,from);
//		logicalPosition = newPosition;
//	}
	else
	{
		if (parent)
		{
			switch (from)
			{
				case SEEK_SET:
					_lseek(handle,pos+parentOffset,SEEK_SET);
					newPosition = pos;
					break;

				case SEEK_END:
					_lseek(handle,getLength()+parentOffset,SEEK_SET);
					_lseek(handle,pos,SEEK_CUR);
					newPosition = getLength() + pos;
					break;

				case SEEK_CUR:
					_lseek(handle,pos,SEEK_CUR);
					newPosition = logicalPosition + pos;
					break;
			}
		}
		else
		{
			newPosition = _lseek(handle,pos,from);
		}

		if (newPosition == -1)
		{
			return (INVALID_SEEK_ERR);
		}

		logicalPosition = newPosition;
	}

	return (NO_ERR);
}

//---------------------------------------------------------------------------
long File::read (unsigned long pos, BYTE* buffer, long length)
{
	long result = 0;

	if (inRAM && fileImage)
	{
		char *readAddress = ((char *)fileImage)+pos;
		memcpy((char *)buffer,readAddress,length);
		return(length);
	}
/*	else if (fastFile)
	{
		if (logicalPosition != pos)
			fastFile->seekFast(fastFileHandle,pos);

		result = fastFile->readFast(fastFileHandle,buffer,length);
	}*/
	else
	{
		if (isOpen())
		{
			if (logicalPosition != pos)
				seek(pos);

			result = _read(handle,buffer,length);
			if (result != length)
				lastError = errno;
		}
		else
		{
			lastError = FILE_NOT_OPEN;
		}
	}
		
	return(result);
}

//---------------------------------------------------------------------------
unsigned char File::readByte (void)
{
	unsigned char value = 0;
	long result = 0;

	if (inRAM && fileImage)
	{
		char *readAddress = (char*)fileImage+logicalPosition;
		memcpy((char *)&value,readAddress,sizeof(value));
		logicalPosition += sizeof(value);
	}
/*	else if (fastFile)
	{
		result = fastFile->readFast(fastFileHandle,(char *)&value,sizeof(value));
		logicalPosition += sizeof(value);
	}*/
	else
	{
		if (isOpen())
		{
			result = _read(handle,(&value),sizeof(value));
			logicalPosition += sizeof(value);
			
			if (result != sizeof(value))
				lastError = errno;
		}
		else
		{
			lastError = FILE_NOT_OPEN;
		}
	}

	return value;
}

//---------------------------------------------------------------------------
short File::readWord (void)
{
	short value = 0;
	long result =0;

	if (inRAM && fileImage)
	{
		char *readAddress = (char*)fileImage+logicalPosition;
		memcpy((char *)(&value),readAddress,sizeof(value));
		logicalPosition += sizeof(value);
	}
/*	else if (fastFile)
	{
		result = fastFile->readFast(fastFileHandle,(char *)&value,sizeof(value));
		logicalPosition += sizeof(value);
	}*/
	else
	{
		if (isOpen())
		{
			result = _read(handle,(&value),sizeof(value));
			logicalPosition += sizeof(value);
			
			if (result != sizeof(value))
				lastError = errno;
		}
		else
		{
			lastError = FILE_NOT_OPEN;
		}
	}

	return value;
}

//---------------------------------------------------------------------------
short File::readShort (void)
{
	return (readWord());
}

//---------------------------------------------------------------------------
long File::readLong (void)
{
	long value = 0;
	unsigned long result = 0;

	if (inRAM && fileImage)	
	{
		char *readAddress = (char*)fileImage+logicalPosition;
		memcpy((char *)(&value),readAddress,sizeof(value));
		logicalPosition += sizeof(value);
	}
/*	else if (fastFile)
	{
		result = fastFile->readFast(fastFileHandle,(char *)&value,sizeof(value));
		logicalPosition += sizeof(value);
	}*/
	else
	{
		if (isOpen())
		{
			result = _read(handle,(&value),sizeof(value));
			logicalPosition += sizeof(value);

			if (result != sizeof(value))
				lastError = errno;
		}
		else
		{
			lastError = FILE_NOT_OPEN;
		}
	}
	
	return value;
}

bool isNAN(float *pFloat)
{
	/* We're assuming ansi/ieee 754 floating point representation. See http://www.research.microsoft.com/~hollasch/cgindex/coding/ieeefloat.html. */
	BYTE *byteArray = (BYTE *)pFloat;
	if ((0x7f == (0x7f & byteArray[3])) && (0x80 == (0x80 & byteArray[2]))) {
		if (0x80 == (0x80 & byteArray[3])) {
			/* if the mantissa is a 1 followed by all zeros in this case then it is technically
			"Indeterminate" rather than an NaN, but we'll just count it as a NaN here. */
			return true;
		} else {
			return true;
		}
	}
	return false;
}

float File::readFloat( void )
{
	float value = 0;
	unsigned long result = 0;

	if (inRAM && fileImage)	
	{
		char *readAddress = (char*)fileImage+logicalPosition;
		memcpy((char *)(&value),readAddress,sizeof(value));
		logicalPosition += sizeof(value);
	}
/*	else if (fastFile)
	{
		result = fastFile->readFast(fastFileHandle,(char *)&value,sizeof(value));
		logicalPosition += sizeof(value);
	}*/
	else
	{
		if (isOpen())
		{
			result = _read(handle,(&value),sizeof(value));
			logicalPosition += sizeof(value);

			if (result != sizeof(value))
				lastError = errno;
		}
		else
		{
			lastError = FILE_NOT_OPEN;
		}
	}

	if (isNAN(&value)) {
		ASSERT(false);
		value = 1.0/*arbitrary value that seems safe*/;
	}
	return value;
}

//---------------------------------------------------------------------------
long File::readString (BYTE* buffer)
{
	long last = 0;

	if (isOpen())
	{
		for(;;)
		{
			byte ch = readByte();

			buffer[last] = ch;

			if (ch)
				++last;
			else
				break;
		}
	}
	else
	{
		lastError = FILE_NOT_OPEN;
	}

	return last;
}

//---------------------------------------------------------------------------
long File::readWideString (TCHAR* buffer)
{
	long last = 0;

	if (isOpen())
	{
		for(;;)
		{
			short ch = readShort();

			buffer[last] = ch;

			if (ch)
				++last;
			else
				break;
		}
	}
	else
	{
		lastError = FILE_NOT_OPEN;
	}

	return last;
}


//---------------------------------------------------------------------------
long File::read (BYTE* buffer, long length)
{
	long result = 0;
	
	if (inRAM && fileImage)
	{
		char *readAddress = (char *)fileImage+logicalPosition;
		memcpy((char *)buffer,readAddress,length);
		logicalPosition += length;
		return(length);
	}
/*	else if (fastFile)
	{
		result = fastFile->readFast(fastFileHandle,buffer,length);
		logicalPosition += result;
	}*/
	else
	{
		if (isOpen())
		{
			result = _read(handle,buffer,length);
			if (result != length)
				lastError = errno;
			else
				logicalPosition += result;
		}
		else
		{
			lastError = FILE_NOT_OPEN;
		}
	}
	
	return result;
}

//---------------------------------------------------------------------------
/*long File::readRAW (unsigned long * &buffer, UserHeapPtr heap)
{
	long result = 0;
	
/*	if (fastFile && heap && fastFile->isLZCompressed())
	{
		long lzSizeNeeded = fastFile->lzSizeFast(fastFileHandle);
		buffer = new unsigned long[lzSizeNeeded];

		result = fastFile->readFastRAW(fastFileHandle,buffer,lzSizeNeeded);
		logicalPosition += result;
	}
	
	return result;
}*/

//---------------------------------------------------------------------------
long File::readLine (BYTE* buffer, long maxLength)
{
	long i = 0;
	
	if (inRAM && fileImage)
	{
		if (isOpen())
		{
			unsigned char *readAddress = (unsigned char *)fileImage+logicalPosition;

			while ((i<maxLength) && ((i+logicalPosition) < fileSize()) && readAddress[i]!='\r' )
				i++;

			memcpy( buffer, readAddress, i );

			buffer[i++]=0;

			logicalPosition+=i;

			if ( logicalPosition > fileSize() )
				return READ_PAST_EOF_ERR;

			if( readAddress[i]=='\n' )
				logicalPosition+=1;
		}
		else
		{
			lastError = FILE_NOT_OPEN;
		}
	}
/*	else if (fastFile)
	{
		long bytesread;
		bytesread = fastFile->readFast(fastFileHandle,buffer,maxLength);

		if (maxLength > bytesread)
			maxLength = bytesread;

		while ((i<maxLength) && (buffer[i]!='\r'))
			i++;

		buffer[i++]=0;
		logicalPosition += i;

		if( buffer[i]=='\n' )
			logicalPosition+=1;

		fastFile->seekFast(fastFileHandle,logicalPosition);
	}*/
	else
	{
		if (isOpen())
		{
			long bytesread;
			bytesread = _read(handle,buffer,maxLength);
			if( maxLength > bytesread )
				maxLength=bytesread;

			while( i<maxLength && buffer[i]!='\r' )
				i++;

			buffer[i++]=0;

			logicalPosition+=i;

			if( buffer[i]=='\n' )
				logicalPosition+=1;

			seek(logicalPosition);
		}
		else
		{
			lastError = FILE_NOT_OPEN;
		}
	}
	return i;
}

//---------------------------------------------------------------------------
long File::readLineEx (BYTE* buffer, long maxLength)
{
	long i = 0;
	
	if (inRAM && fileImage)
	{
		if (isOpen())
		{
			unsigned char *readAddress = (unsigned char *)fileImage+logicalPosition;

			while( i<maxLength && readAddress[i]!='\n' )
				i++;

			i++;									//Include Newline
			memcpy( buffer, readAddress, i );

			buffer[i++]=0;

			logicalPosition+=(i-1);
		}
		else
		{
			lastError = FILE_NOT_OPEN;
		}
	}
/*	else if (fastFile)
	{
		long bytesread;
		bytesread = fastFile->readFast(fastFileHandle,buffer,maxLength);

		if (maxLength > bytesread)
			maxLength = bytesread;

		while ((i<maxLength) && (buffer[i]!='\n'))
			i++;

		i++;					//Include Newline
		buffer[i++]=0;
		logicalPosition += (i-1);

		fastFile->seekFast(fastFileHandle,logicalPosition);
	}*/
	else
	{
		if (isOpen())
		{
			long bytesread = _read(handle,buffer,maxLength);
			if( maxLength > bytesread )
				maxLength=bytesread;

			while( i<maxLength && buffer[i]!='\n' )
				i++;

			i++;
			buffer[i++]=0;

			logicalPosition+= (i-1);

			seek(logicalPosition);
		}
		else
		{
			lastError = FILE_NOT_OPEN;
		}
	}
	return i;
}

//---------------------------------------------------------------------------
long File::write (unsigned long pos, BYTE* buffer, long bytes)
{
	unsigned long result = 0;

	if (parent == NULL)	
	{
		if (isOpen())
		{
			if (logicalPosition != pos)
				seek(pos);

			if ( inRAM )
			{
				if ( logicalPosition + bytes > physicalLength )
					return BAD_WRITE_ERR;
				memcpy( fileImage + logicalPosition, buffer, bytes );
				result = bytes;

			}
			else
			{
				result = _write(handle,buffer,bytes);
				if (result != length)
					lastError = errno;
			}
		}
		else
		{
			lastError = FILE_NOT_OPEN;
		}
	}
	else
	{
		lastError = CANT_WRITE_TO_CHILD;
	}
	
	return(result);
}

//---------------------------------------------------------------------------
long File::writeByte (byte value)
{
	long result = 0;

	if (parent == NULL)
	{
		if (isOpen())	
		{
			if ( inRAM )
			{
				if ( logicalPosition + sizeof(byte) > physicalLength )
					return BAD_WRITE_ERR;
				memcpy( fileImage + logicalPosition, &value, sizeof( byte ) );
				result = sizeof( byte );				
			}
			else
				result = _write(handle,(&value),sizeof(value));
			if (result == sizeof(value))
			{
				logicalPosition += sizeof(value);
				result = NO_ERR;
			}
			else
			{
				result = BAD_WRITE_ERR;
			}
		}
		else
		{
			lastError = FILE_NOT_OPEN;
		}
	}
	else
	{
		lastError = CANT_WRITE_TO_CHILD;
	}
	
	return(result);
}

//---------------------------------------------------------------------------
long File::writeWord (short value)
{
	unsigned long result = 0;
	
	if (parent == NULL)
	{
		if (isOpen())
		{
			if ( inRAM )
			{
				if ( logicalPosition + sizeof( short ) > physicalLength )
					return BAD_WRITE_ERR;
				memcpy( fileImage + logicalPosition, &value, sizeof( short ) );
				result = sizeof( value );				
			}
			else
				result = _write(handle,(&value),sizeof(value));

			if (result == sizeof(value))
			{
				logicalPosition += sizeof(value);
				result = NO_ERR;
			}
			else
			{
				result = BAD_WRITE_ERR;
			}
		}
		else
		{
			lastError = FILE_NOT_OPEN;
		}
	}
	else
	{
		lastError = CANT_WRITE_TO_CHILD;
	}

	return(result);
}

//---------------------------------------------------------------------------
long File::writeShort (short value)
{
	long result = writeWord(value);
	return(result);
}

//---------------------------------------------------------------------------
long File::writeLong (long value)
{
	unsigned long result = 0;
	
	if (parent == NULL)
	{
		if (isOpen())
		{
			if ( inRAM )
			{
				if ( logicalPosition + sizeof( value ) > physicalLength )
					return BAD_WRITE_ERR;
				memcpy( fileImage + logicalPosition, &value, sizeof( value ) );
				result = sizeof( value );				
			}
			else
				result = _write(handle,(&value),sizeof(value));

			if (result == sizeof(value))
			{
				logicalPosition += sizeof(value);
				result = NO_ERR;	
			}
			else
			{
				result = BAD_WRITE_ERR;
			}
		}
		else
		{
			lastError = FILE_NOT_OPEN;
		}
	}
	else
	{
		lastError = CANT_WRITE_TO_CHILD;
	}

	return(result);
}

//---------------------------------------------------------------------------
long File::writeFloat (float value)
{
	unsigned long result = 0;

	ASSERT(!isNAN(&value));
	if (parent == NULL)
	{
		if (isOpen())
		{
			if ( inRAM )
			{
				if ( logicalPosition + sizeof( value ) > physicalLength )
					return BAD_WRITE_ERR;
				memcpy( fileImage + logicalPosition, &value, sizeof( value ) );
				result = sizeof( value );				
			}
			else
				result = _write(handle,(&value),sizeof(float));

			if (result == sizeof(float))
			{
				logicalPosition += sizeof(float);
				result = NO_ERR;	
			}
			else
			{
				result = BAD_WRITE_ERR;
			}
		}
		else
		{
			lastError = FILE_NOT_OPEN;
		}
	}
	else
	{
		lastError = CANT_WRITE_TO_CHILD;
	}

	return(result);
}

//---------------------------------------------------------------------------

long File::writeString (char *buffer)
{
	long result = -1;
	
	if (parent == NULL)
	{
		if (isOpen())
		{
			char *ch = buffer;

			for(; *ch; ++ch)
				writeByte((byte)* ch);

            writeByte(*ch);
			
			return ch - buffer;
		}
		else
		{
			lastError = FILE_NOT_OPEN;
		}
	}
	else
	{
		lastError = CANT_WRITE_TO_CHILD;
	}
	
	return(result);
}

//---------------------------------------------------------------------------

long File::writeWideString (TCHAR *buffer)
{
	long result = -1;

    if ( !buffer )
        return -1;
	
	if (parent == NULL)
	{
		if (isOpen())
		{
			TCHAR *ch = buffer;

			for(; *ch; ++ch)
				writeShort((short)* ch);

            writeShort(*ch); // need that NULL
			
			return ch - buffer;
		}
		else
		{
			lastError = FILE_NOT_OPEN;
		}
	}
	else
	{
		lastError = CANT_WRITE_TO_CHILD;
	}
	
	return(result);
}

//---------------------------------------------------------------------------
long File::writeLine (char *buffer)
{
	long result = -1;
	
	if (parent == NULL)
	{
		if (isOpen())
		{
			char *ch = buffer;

			for(; *ch; ++ch)
				writeByte((byte)* ch);

			writeByte('\r');
			writeByte('\n');
			
			return ch - buffer;
		}
		else
		{
			lastError = FILE_NOT_OPEN;
		}
	}
	else
	{
		lastError = CANT_WRITE_TO_CHILD;
	}
	
	return(result);
}

//---------------------------------------------------------------------------
long File::write (BYTE* buffer, long bytes)
{
	long result = 0;
	
	if (parent == NULL)
	{
		if (isOpen())
		{
			if ( inRAM )
			{
				if ( logicalPosition + bytes > physicalLength )
					return BAD_WRITE_ERR;
				memcpy( fileImage + logicalPosition, buffer, bytes );
				result = bytes;
			}
			else
			{
				result = _write(handle,buffer,bytes);
				if (result != bytes)
				{
					lastError = errno;
					return result;
				}
			}

			logicalPosition += result;
		}
		else
		{
			lastError = FILE_NOT_OPEN;
		}
	}
	else
	{
		lastError = CANT_WRITE_TO_CHILD;
	}
	
	return result;
}

//---------------------------------------------------------------------------
bool File::isOpen (void)
{
	return ((handle != NULL && handle != -1) || (fileImage != NULL));
}

//---------------------------------------------------------------------------
char* File::getFilename (void)
{
	return (fileName);
}

//---------------------------------------------------------------------------
long File::getFileMTime (void)
{
	long mTime = 0;

	if (isOpen())
	{
		struct _stat st;
		_fstat(handle,&st);
		mTime = st.st_mtime;

		//Time\Date Stamp is WAY out of line.
		// Return January 1, 1970
		if (mTime == -1)
			mTime = 0;
	}

	return mTime;
}

//---------------------------------------------------------------------------
unsigned long File::getLength (void)
{
/*	if (fastFile && (length == 0))
	{
		length = fastFile->sizeFast(fastFileHandle);
	}
	else*/
    if ((length == 0) && (parent || inRAM))
	{
		length = physicalLength;
	}
	else if (isOpen() && ((length == 0) || (fileMode > READ) && !inRAM))
	{
		/* _fstat() was being used to get the length of the file, but it was wrong. It was
		   not giving the *logical* size, which is what we want. */
		length = _filelength(handle);
	}

	return length;
}

//---------------------------------------------------------------------------
unsigned long File::fileSize (void)
{
	return getLength();
}

//---------------------------------------------------------------------------
unsigned long File::getNumLines (void)
{
	unsigned long currentPos = logicalPosition;
	unsigned long numLines = 0;

	seek(0);
	for (unsigned long i=0;i<getLength();i++)
	{
		unsigned char check1 = readByte();
		if (check1 == '\n')
			numLines++;
	}	
	
	seek(currentPos);

	return numLines;
}

//---------------------------------------------------------------------------
void File::seekEnd (void)
{
	seek(0,SEEK_END);
}

//---------------------------------------------------------------------------
void File::skip (long bytesToSkip)
{
	if (bytesToSkip)
	{
		seek(logicalPosition+bytesToSkip);
	}
}
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\xodash\XODashLib\file.h ===
//---------------------------------------------------------------------------
//
// file.h - This file contains the class declaration for File
//
//				The File class simply calls the Windows 32bit file functions.
//				It is purely a wrapper.
//
//				The mmFile Class is a wrapper for the Win32 Memory Mapped
//				file functionality.  It is used exactly the same as above class.
//
//	Honor Bound -- FASA Interactive Technologies
//
//	Copyright (c) 1995 FASA Interactive Technologies
//
//
//---------------------------------------------------------------------------

#ifndef FILE_H
#define FILE_H
//---------------------------------------------------------------------------
// Include files
#include "std.h"
#include <stdlib.h>
#include <stdio.h>
#include <fcntl.h>
//---------------------------------------------------------------------------
// Enums
enum FileMode
{
	NOMODE = 0,
	READ,
	CREATE,
	MC2_APPEND,
	WRITE,
	RDWRITE
};

enum FileClass
{
	BASEFILE = 0,
	INIFILE,
	PACKETFILE,
	CSVFILE
};

//---------------------------------------------------------------------------
// Function Declarations
//Returns 1 if file is on HardDrive and 2 if file is in FastFile
long fileExists(char *fName);
long fileExistsOnCD(char *fName);
bool file1OlderThan2(char *file1, char* file2);

//---------------------------------------------------------------------------
// Macro Definitions
#ifndef	NO_ERR
#define	NO_ERR					0x00000000
#endif

#define	DISK_FULL_ERR			0xBADF0001
#define	SHARE_ERR				0xBADF0002
#define	FILE_NOT_FOUND_ERR		0xBADF0003
#define	PACKET_OUT_OF_RANGE		0xBADF0004
#define	PACKET_WRONG_SIZE		0xBADF0005
#define	READ_ONLY_ERR			0xBADF0006
#define	TOO_MANY_FILES_ERR		0xBADF0007
#define	READ_PAST_EOF_ERR		0xBADF0008
#define	INVALID_SEEK_ERR		0xBADF0009
#define	BAD_WRITE_ERR			0xBADF000A
#define	BAD_PACKET_VERSION		0xBADF000B
#define	NO_RAM_FOR_SEEK_TABLE	0xBADF000C
#define	NO_RAM_FOR_FILENAME		0xBADF000D
#define	PARENT_NULL				0xBADF000E
#define	TOO_MANY_CHILDREN		0xBADF000F
#define	FILE_NOT_OPEN			0xBADF0010
#define	CANT_WRITE_TO_CHILD		0xBADF0011
#define	NO_RAM_FOR_CHILD_LIST	0xBADF0012
#define MAPPED_WRITE_NOT_SUPPORTED	0xBADF0013
#define COULD_NOT_MAP_FILE		0xBADF0014

//---------------------------------------------------------------------------
//									File
//---------------------------------------------------------------------------
class File
{
	// Data Members
	//--------------
	protected:
	
		char 					*fileName;
		FileMode				fileMode;
	
		long					handle;

//		FastFile*				fastFile;
//		long					fastFileHandle;

		unsigned long 			length;
		unsigned long 			logicalPosition;

		unsigned long			bufferResult;

		File*					*childList;
		unsigned long			numChildren;
		unsigned long			maxChildren;
				
		File*					parent;
		unsigned long			parentOffset;
		unsigned long			physicalLength;

		bool					inRAM;
		BYTE*				    fileImage;

	public:

		static bool				logFileTraffic;
		static unsigned long	lastError;

	// Member Functions
	//------------------
		protected:

			void setup (void);

		public:

			File (void);
			~File (void);

			bool eof (void);

			virtual long open ( const char* fName, FileMode _mode = READ, long numChildren = 50);
			virtual long open( const char* buffer, int bufferLength ); // for streaming from memory

			virtual long create (const char* fName);
			virtual long createWithCase( char* fName ); // don't strlwr for me please!

			virtual void close (void);

			virtual long open (File *_parent, unsigned long fileSize, long numChildren = 50);
			
			void deleteFile (void);

			long seek (long pos, long from = SEEK_SET);
			void seekEnd (void);
			void skip (long bytesToSkip);

			long read (unsigned long pos, BYTE* buffer, long length);
			long read (BYTE* buffer, long length);

			//Used to dig the LZ data directly out of the fastfiles.
			// For textures.
//			long readRAW (unsigned long * &buffer, UserHeapPtr heap);

			unsigned char readByte (void);
			short readWord (void);
			short readShort (void);
			long readLong (void);
			float readFloat( void );

			long readString (BYTE* buffer);
            long readWideString( wchar_t* buffer );
			long readLine (BYTE* buffer, long maxLength);
			long readLineEx (BYTE* buffer, long maxLength);

			long write (unsigned long pos, BYTE* buffer, long bytes);
			long write (BYTE* buffer, long bytes);

			long writeByte (unsigned char value);
			long writeWord (short value);
			long writeShort (short value);
			long writeLong (long value);
			long writeFloat (float value);

			long writeString (char *buffer);
            long writeWideString( wchar_t* buffer );
			long writeLine (char *buffer);

			bool isOpen (void);

			virtual FileClass getFileClass (void)
			{
				return BASEFILE;
			}

			char* getFilename (void);

			unsigned long getLength (void);
			unsigned long fileSize (void);
			unsigned long getNumLines (void);

			unsigned long getLastError (void) {
				return(lastError);
			}

			unsigned long getLogicalPosition (void)
			{
				return logicalPosition;
			}
			
			File* getParent (void)
			{
				return parent;
			}

			FileMode getFileMode (void)
			{
				return(fileMode);
			}
			
			long getFileHandle (void)
			{
				return(handle);
			}

			long getFileMTime (void);
			
			long addChild (File* child);
			void removeChild (File* child);

};

//---------------------------------------------------------------------------



//---------------------------------------------------------------------------
#endif

//---------------------------------------------------------------------------
//
// Edit Log
//
//
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\xodash\XODashLib\FileUtil.h ===
#pragma once

#include <xtl.h>
#include <tchar.h>

bool DoesFileExist(const TCHAR* szFileName);

void MakePath(TCHAR* szBuf, const TCHAR* szDir, const TCHAR* szFile);

int GetDirectoryBlocks(const TCHAR* szDirPath, int nBlockSize, bool bRecursive, HANDLE hCancelEvent);
int GetFileBlocks(const TCHAR* szFilePath, int nBlockSize);

void CleanFilePath(char* szPath, const TCHAR* szSrcPath);
//#ifdef _UNICODE
void CleanFilePath(TCHAR* szPath, const TCHAR* szSrcPath);
//#endif

void UpdateCurDirFromFile(const TCHAR* szURL);
void MakeAbsoluteURL2(TCHAR* szBuf, const TCHAR* szBase, const TCHAR* szURL);
void MakeAbsoluteURL(TCHAR* szBuf, const TCHAR* szBase, const TCHAR* szURL);
void MakeAbsoluteURL(TCHAR* szBuf, const TCHAR* szURL);

DWORD GetUniqueFile(const TCHAR* szBase, TCHAR* szPath/*=NULL*/);
DWORD CreateUniqueDir(const TCHAR* szBase);

bool DeleteDirectory(const TCHAR* szPath);
bool CopyDirectory(const TCHAR* szSrcPath, const TCHAR* szDestPath);

void FindFilePath(TCHAR* szFullPath/*[MAX_PATH]*/, const TCHAR* szFile);

int GetFileSize(const TCHAR* szFilePath);

inline HANDLE XAppCreateFile(const TCHAR* szFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes = 0, HANDLE hTemplateFile = NULL)
{
	char sszFileName [MAX_PATH];
	CleanFilePath(sszFileName, szFileName);
	return CreateFile(sszFileName, dwDesiredAccess, dwShareMode, lpSecurityAttributes, dwCreationDisposition, dwFlagsAndAttributes, hTemplateFile);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\xodash\XODashLib\Globals.h ===
#pragma once 
#include <xtl.h>
#include <xgraphics.h>
#include "materiallibrary.h"
#include "texturecache.h"

class CNtIoctlCdromService;
class CInputHandle;
class XOApplication;
class CNetConfig;

extern LPDIRECT3DDEVICE8 g_pd3dDevice;
extern TCHAR* g_szAppDir;
extern float* g_fAppTime;

extern CMaterialLibrary g_MaterialLib;

extern CNtIoctlCdromService g_cdrom;
extern int g_nDiscType;

extern CInputHandle g_szUserInput;
extern XOApplication*    g_pXBApp;

extern CNetConfig g_NetConfig;
extern bool g_ResetAutomation;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\xodash\XODashLib\font.cpp ===
//-------------------------------------------------------------
// Copyright (c) Microsoft Corporation.  All rights reserved
//-------------------------------------------------------------
#include "std.h"
#include "font.h"
#include "FileUtil.h"
#include "XOConst.h"
#include "globals.h"
#include "utilities.h"



// Adjust the alpha value for verts whose x is between nStart and nEnd such that they fade
// from opaque to transparent (bRight==true) or transparent to opaque (bRight==false).
static void HorizontalFade(TEXTVERTEX* verts, int nVertexCount, float nStart, float nEnd, bool bRight)
{
	float nWidth = nEnd - nStart;

	for (int i = 0; i < nVertexCount; i += 1)
	{
		float a = (verts[i].x - nStart) / nWidth;
		a = smoothstep(0.0f, 1.0f, a);

		if (bRight)
			a = 1.0f - a;

		float a0 = (float)(verts[i].color >> 24);
		verts[i].color = (verts[i].color & 0x00ffffff) | (((DWORD)(a0 * a)) << 24);
	}
}

inline void FadeLeftEdge(TEXTVERTEX* verts, int nVertexCount, float nStart, float nEnd)
{
	HorizontalFade(verts, nVertexCount, nStart, nEnd, false);
}

inline void FadeRightEdge(TEXTVERTEX* verts, int nVertexCount, float nStart, float nEnd)
{
	HorizontalFade(verts, nVertexCount, nStart, nEnd, true);
}



CFont::CFont()
{
	m_hFile = INVALID_HANDLE_VALUE;
	m_pGlyphSet = NULL;
	m_rgGlyphObjects = NULL;
	m_rgGlyphLoaded = NULL;
    
}

CFont::~CFont()
{
	Close();
}

void CFont::Close()
{
	if (m_hFile != INVALID_HANDLE_VALUE)
	{
		DWORD dwRes = CloseHandle(m_hFile);
		ASSERT(dwRes);
	}

	if (m_pGlyphSet != NULL)
	{
		for (UINT i = 0; i < m_pGlyphSet->cGlyphsSupported; i += 1)
		{
			if (m_rgGlyphLoaded[i])
			{
				CGlyphShape* pGlyphShape = m_rgGlyphObjects[i].m_pGlyphShape;
				delete [] pGlyphShape->m_indices;
				delete [] pGlyphShape->m_vertices;
				delete pGlyphShape;
			}
		}
	}

	delete [] (BYTE*)m_pGlyphSet;
	delete [] m_rgGlyphObjects;
	delete [] m_rgGlyphLoaded;

	m_hFile = INVALID_HANDLE_VALUE;
	m_pGlyphSet = NULL;
	m_rgGlyphObjects = NULL;
	m_rgGlyphLoaded = NULL;
}

bool CFont::Open(const TCHAR* szFile)
{
	ASSERT(m_hFile == INVALID_HANDLE_VALUE);

	m_hFile = XAppCreateFile(szFile, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL);
	if (m_hFile == INVALID_HANDLE_VALUE)
		return false;

	DWORD dwRead;

	DWORD dwMagic;
	if(!ReadFile(m_hFile, &dwMagic, 4, &dwRead, NULL))
	{
		ASSERT(false);
		DbgPrint("CFont::Open-Fail to open the font file\n");
		return false;
	}


	if (dwMagic != 0x30465458) // "XTF0"
	{
		DbgPrint("\001Invalid font file: %s\n", szFile);

		DWORD dwRes = CloseHandle(m_hFile);
		ASSERT(dwRes);
		m_hFile = INVALID_HANDLE_VALUE;

		return false;
	}

	// BLOCK: Skip header...
	{
		DWORD dwHeaderLen;
		DWORD dwRes = ReadFile(m_hFile, &dwHeaderLen, 4, &dwRead, NULL);
		ASSERT(dwRes);

		ASSERT(dwHeaderLen == LF_FACESIZE);

		char szFace [LF_FACESIZE];
		dwRes = ReadFile(m_hFile, szFace, LF_FACESIZE, &dwRead, NULL);
		ASSERT(dwRes);

	}

	DWORD cbGlyphSet=0;
	DWORD dwRes = ReadFile(m_hFile, &cbGlyphSet, 4, &dwRead, NULL);
	ASSERT(dwRes);

	m_pGlyphSet = (CGlyphSet*)new BYTE [cbGlyphSet];
	m_pGlyphSet->cbThis = cbGlyphSet;
	dwRes = ReadFile(m_hFile, ((BYTE*)m_pGlyphSet) + 4, cbGlyphSet - 4, &dwRead, NULL);
	ASSERT(dwRes);

	m_rgGlyphObjects = new CGlyphObject [m_pGlyphSet->cGlyphsSupported];
	dwRes = ReadFile(m_hFile, m_rgGlyphObjects, sizeof (CGlyphObject) * m_pGlyphSet->cGlyphsSupported, &dwRead, NULL);
	ASSERT(dwRes);

	m_rgGlyphLoaded = new bool [m_pGlyphSet->cGlyphsSupported];
	ZeroMemory(m_rgGlyphLoaded, sizeof (bool) * m_pGlyphSet->cGlyphsSupported);

	return true;
}

bool CFont::LoadGlyph(int nGlyphIndex)
{
	ASSERT(m_pGlyphSet != NULL);
	ASSERT(nGlyphIndex >= 0 && (UINT)nGlyphIndex < m_pGlyphSet->cGlyphsSupported);

	if (m_rgGlyphLoaded[nGlyphIndex])
		return true;

	ASSERT(SetFilePointer(m_hFile, (DWORD)m_rgGlyphObjects[nGlyphIndex].m_pGlyphShape, 0, FILE_BEGIN) != ~0);
	CGlyphShape* pGlyphShape = new CGlyphShape;
    ASSERT(pGlyphShape);

	DWORD dwRead;
	
	DWORD dwRes = ReadFile(m_hFile, &pGlyphShape->m_nIndexCount, 2, &dwRead, NULL);
	ASSERT(dwRes);
	pGlyphShape->m_indices = new WORD [pGlyphShape->m_nIndexCount];

	dwRes = ReadFile(m_hFile, &pGlyphShape->m_nVertexCount, 2, &dwRead, NULL);
	ASSERT(dwRes);
	pGlyphShape->m_vertices = new CGlyphVertex [pGlyphShape->m_nVertexCount];

	dwRes = ReadFile(m_hFile, pGlyphShape->m_indices, sizeof (WORD) * pGlyphShape->m_nIndexCount, &dwRead, NULL);
	ASSERT(dwRes);
	dwRes = ReadFile(m_hFile, pGlyphShape->m_vertices, sizeof (CGlyphVertex) * pGlyphShape->m_nVertexCount, &dwRead, NULL);
	ASSERT(dwRes);

	m_rgGlyphObjects[nGlyphIndex].m_pGlyphShape = pGlyphShape;
	m_rgGlyphLoaded[nGlyphIndex] = true;

	return true;
}

int CFont::FindGlyphIndex(WCHAR wch)
{
	int nIndex = 0;

	for (UINT i = 0; i < m_pGlyphSet->cRanges; i += 1)
	{
		if (wch >= m_pGlyphSet->ranges[i].wcLow && wch < m_pGlyphSet->ranges[i].wcLow + m_pGlyphSet->ranges[i].cGlyphs)
			return nIndex + wch - m_pGlyphSet->ranges[i].wcLow;

		nIndex += m_pGlyphSet->ranges[i].cGlyphs;
	}

	if (wch != 127)
		return FindGlyphIndex(127); // the invalid char box

	return 0; // "invalid char" glyph (it's a space)
}

bool CFont::IsBreakChar(TCHAR ch)
{
    // Basically, we will break after double byte or single byte Kana
    if (ch == ' ' || (ch >= 0x3040 && ch < 0xF000) || ch >= 0xFF66)
    {
        return true;
    }

    return false;
}


HRESULT CFont::CreateTextMesh(const TCHAR* pchText, int nChars, LPD3DXMESH* ppMesh, D3DXVECTOR3* pMin, D3DXVECTOR3* pMax, float nFormatWidth,bool bDoNotBreak, int nCursorPos)
{
	HRESULT hr = S_OK;
	bool bFade = bDoNotBreak;

	// do not call this funciton if no mesh is to be created
	ASSERT(pchText || nCursorPos >=0);
	if(!pchText)
	{
		return S_FALSE;
	}
	if (nChars == -1 && pchText)
		nChars = _tcslen(pchText);

	LPD3DXMESH pMesh = NULL;
	int nFaces = 0, nVerts = 0;

	int ich = 0;
	float nMaxCol1Width = 0.0f;
	float nMaxCol2Width = 0.0f;
	bool bSingleLine = true;
	bool bSingleColumn = true;
	bool bAsterisk = false;
	for (int nLine = 0; ich < nChars; nLine += 1)
	{
		int nColumn = 1;
		float nCol1Width = 0.0f;
		float nCol2Width = 0.0f;

		while (ich < nChars)
		{
			TCHAR ch = pchText[ich];
			ich += 1;

			if (bDoNotBreak == false && ch == '\r' && ich < nChars && pchText[ich] == '\n')
            {
				ich += 1;
            }

			if (bDoNotBreak == false && (ch == '\n' || ch == '\r'))
			{
				bSingleLine = false;
				break;
			}

			if (ch == '\t' && bDoNotBreak == false)
			{
				nColumn = 2;
				bSingleColumn = false;
				continue;
			}

			int nGlyphIndex = FindGlyphIndex(ch);
			if (nGlyphIndex == -1)
				continue;

			DWORD dwRes = LoadGlyph(nGlyphIndex);
			ASSERT(dwRes);

			CGlyphShape* pGlyphShape = m_rgGlyphObjects[nGlyphIndex].m_pGlyphShape;
			pGlyphShape->m_nGlyphIndex = nGlyphIndex;

			if (nVerts + pGlyphShape->m_nVertexCount > 65535)
			{
				DbgPrint("CreateTextMesh: too much text!\n");
				nChars = ich - 1; // truncate string
				break;
			}

			if (nColumn == 1)
				nCol1Width += m_rgGlyphObjects[nGlyphIndex].m_metrics.gmfCellIncX;
			else
				nCol2Width += m_rgGlyphObjects[nGlyphIndex].m_metrics.gmfCellIncX;

			nFaces += pGlyphShape->m_nIndexCount / 3;
			nVerts += pGlyphShape->m_nVertexCount;
		}

		if (nCol1Width > nMaxCol1Width)
			nMaxCol1Width = nCol1Width;

		if (nCol2Width > nMaxCol2Width)
			nMaxCol2Width = nCol2Width;
	}

	if (nCursorPos >= 0 && nCursorPos <= nChars)
	{
		// TBD handle cursor only 
		nFaces += 2;
		nVerts += 4;
	}

	if (nFaces == 0)
	{ 
		// check it out
		ASSERT(false);
		return S_FALSE;
	}

	if (nFormatWidth > 0.0f)
	{
		if (bSingleColumn)
		{
			nMaxCol1Width = nFormatWidth;
		}
		else if (nMaxCol1Width + nMaxCol2Width > nFormatWidth)
		{
			nMaxCol1Width = nFormatWidth - nMaxCol2Width;
			bFade = true;
		}
	}
	else
	{
		bFade = false;
	}

//	DbgPrint("Creating text mesh with %d indices and %d vertices (about %dKB)\n", nFaces * 3, nVerts, ((nFaces * 3 * sizeof (WORD)) + (nVerts * 6 * sizeof (float)) + 512) / 1024);

	// Nat TBD: handle out of memory case
	hr = D3DXCreateMeshFVF(nFaces, nVerts, D3DXMESH_MANAGED, D3DFVF_XYZ | D3DFVF_NORMAL | D3DFVF_DIFFUSE, g_pd3dDevice, &pMesh);
	ASSERT(SUCCEEDED(hr));
	if(FAILED(hr))
	{
		DbgPrint("CFont::CreateTextMesh - Fail to create Mesh, hr = 0x%x", hr);
		return hr;
	}

	*ppMesh = pMesh;

	WORD* indices;
	hr = pMesh->LockIndexBuffer(D3DLOCK_DISCARD, (BYTE**)&indices);
	VERIFYHR(hr);

	TEXTVERTEX* verts;
	hr = pMesh->LockVertexBuffer(D3DLOCK_DISCARD, (BYTE**)&verts);
	VERIFYHR(hr);

	float r = 1.0f;
	float g = 1.0f;
	float b = 1.0f;  

	bool bStartPara = true;
	int nCurIndex = 0;
	int nCurVertex = 0;
	float x = 0.0f;
	float y = 0.0f;
	ich = 0;
	for (nLine = 0; ich < nChars; nLine += 1)
	{
		int nColumn = 1;
		int nFirstColVertex = nCurVertex;
		float nCol2Width = 0.0f;
		float nMaxColWidth = nMaxCol1Width;

		int nBreakChar = -1;
		int nBreakVertex = nCurVertex;
		int nBreakIndex = nCurIndex;

		for (;;)
		{
			TCHAR ch = '\r';
			if (ich < nChars)
			{
				ch = pchText[ich];
				ich += 1;

				if (ch == '\r' && ich < nChars && pchText[ich] == '\n')
					ich += 1;
			}

			if (ch == '\n' || ch == '\r')
			{
                if (bDoNotBreak && bFade)
                {
                    FadeRightEdge(verts + nFirstColVertex, nCurVertex - nFirstColVertex, nMaxColWidth - 1, nMaxColWidth);
                    break;
                }

				if (nColumn == 2)
				{
					// Right justify the second column...
					for (int i = nFirstColVertex; i < nCurVertex; i += 1)
						verts[i].x += nMaxCol2Width - nCol2Width;
				}
				else
				{
					if (bFade)
						FadeRightEdge(verts + nFirstColVertex, nCurVertex - nFirstColVertex, nMaxColWidth - 1, nMaxColWidth);
				}

				if (ich != nChars)
				{
					x = 0.0f;
					if (/*bTitle ||*/ ch == '\r' || !bSingleColumn)
						y -= 1.0f;
					else
						y -= 1.5f;
				}

				bStartPara = true;
				break;
			}

			if (ch == '\t' && bDoNotBreak == false)
			{
				if (bFade)
					FadeRightEdge(verts + nFirstColVertex, nCurVertex - nFirstColVertex, nMaxColWidth - 2, nMaxColWidth);

				nColumn = 2;
				x = nFormatWidth - nMaxCol2Width;
				nFirstColVertex = nCurVertex;
				nMaxColWidth = nMaxCol2Width;
				bStartPara = true;

				continue;
			}

			bStartPara = false;

			int nGlyphIndex = FindGlyphIndex(ch);
			if (nGlyphIndex == -1)
				continue;

			ASSERT(m_rgGlyphLoaded[nGlyphIndex]);

			if (nFormatWidth > 0.0f)
			{
				if (bDoNotBreak)
				{
					if (x > nFormatWidth)
					{
						// TODO: Don't bother placing these chars in the buffer...
//						continue; // messes up vert count from first pass!
					}
				}
				else
				{
					if (ch != ' ' && nColumn == 1 && x + m_rgGlyphObjects[nGlyphIndex].m_metrics.gmfCellIncX > nFormatWidth)
					{

						// break line

						if (nBreakChar > -1)
						{
							x = 0.0f;
							y -= 1.0f;

							ich = nBreakChar /*- 1*/;
							nCurVertex = nBreakVertex;
							nCurIndex = nBreakIndex;

							nBreakChar = -1;
							nBreakVertex = nCurVertex;
							nBreakIndex = nCurIndex;

							continue;
						}
						else
						{
							// one word was too long to fit, fade it!
							bFade = true;
						}
					}
				}
			}

			CGlyphShape* pGlyphShape = m_rgGlyphObjects[nGlyphIndex].m_pGlyphShape;

			for (int j = 0; j < pGlyphShape->m_nIndexCount; j += 1)
				indices[nCurIndex++] = nCurVertex + pGlyphShape->m_indices[j];

			float fontAdjust = 1.0f;

			if(pGlyphShape->m_nGlyphIndex > 190)   //character is in the japanese font set
			{
				fontAdjust = 0.9f;
			}

			for (j = 0; j < pGlyphShape->m_nVertexCount; j += 1)
			{
				verts[nCurVertex].x = x + (pGlyphShape->m_vertices[j].x * fontAdjust);
				verts[nCurVertex].y = y + (pGlyphShape->m_vertices[j].y * fontAdjust);
				verts[nCurVertex].z = 0.0f;

				verts[nCurVertex].nx = 0.0f;
				verts[nCurVertex].ny = 0.0f;
				verts[nCurVertex].nz = -1.0f;

				verts[nCurVertex].color = D3DCOLOR_COLORVALUE(r, g, b, 1.0f);

				nCurVertex += 1;
			}

			if (ich - 1 == nCursorPos)
			{
				CreateCursorMesh(indices, nCurIndex, verts, nCurVertex, x, y, true);
			}

			x += (m_rgGlyphObjects[nGlyphIndex].m_metrics.gmfCellIncX * fontAdjust);

			if (nColumn == 2)
				nCol2Width += m_rgGlyphObjects[nGlyphIndex].m_metrics.gmfCellIncX;

			if (IsBreakChar(ch))
			{
				nBreakChar = ich;
				nBreakVertex = nCurVertex;
				nBreakIndex = nCurIndex;
			}
		}
	}

	if (nCursorPos == nChars)
	{
		bool visible = false;
		if(x < 16.556152f)  //value to keep the cursor from extending past the keyboard blank
			visible = true;

		CreateCursorMesh(indices, nCurIndex, verts, nCurVertex, x, y, visible);
	}

	ASSERT(nCurVertex == nVerts);
	ASSERT(nCurIndex == nFaces * 3);

	
	if (pMin != NULL && pMax != NULL)
	{
		hr = D3DXComputeBoundingBox(verts, nCurVertex, D3DFVF_XYZ | D3DFVF_NORMAL | D3DFVF_DIFFUSE, pMin, pMax);
		VERIFYHR(hr);
	}

	hr = pMesh->UnlockIndexBuffer();
	VERIFYHR(hr);

	pMesh->UnlockVertexBuffer();
	VERIFYHR(hr);

	return hr;

}

void CFont::CreateCursorMesh(WORD*& indices, int& nCurIndex, TEXTVERTEX*& verts, int& nCurVertex, float x, float y, bool visible)
{
	float t = (float) (XAppGetNow()) * 2.0f;
	float a = fabsf(sinf(t * D3DX_PI));
	if(!visible)
		a = 0.0f;

	indices[nCurIndex++] = (WORD)nCurVertex;
	indices[nCurIndex++] = (WORD)nCurVertex + 1;
	indices[nCurIndex++] = (WORD)nCurVertex + 2;

	indices[nCurIndex++] = (WORD)nCurVertex;
	indices[nCurIndex++] = (WORD)nCurVertex + 2;
	indices[nCurIndex++] = (WORD)nCurVertex + 3;

	verts[nCurVertex].x = x;
	verts[nCurVertex].y = y - 0.1f;
	verts[nCurVertex].z = 0.0f;

	verts[nCurVertex].nx = 0.0f;
	verts[nCurVertex].ny = 0.0f;
	verts[nCurVertex].nz = 1.0f;

	verts[nCurVertex].color = D3DCOLOR_COLORVALUE(1.0f, 1.0f, 1.0f, a);

	nCurVertex += 1;

	verts[nCurVertex].x = x + 0.1f;
	verts[nCurVertex].y = y - 0.1f;
	verts[nCurVertex].z = 0.0f;

	verts[nCurVertex].nx = 0.0f;
	verts[nCurVertex].ny = 0.0f;
	verts[nCurVertex].nz = 1.0f;

	verts[nCurVertex].color = D3DCOLOR_COLORVALUE(1.0f, 1.0f, 1.0f, a);

	nCurVertex += 1;

	verts[nCurVertex].x = x + 0.1f;
	verts[nCurVertex].y = y + 0.75f;
	verts[nCurVertex].z = 0.0f;

	verts[nCurVertex].nx = 0.0f;
	verts[nCurVertex].ny = 0.0f;
	verts[nCurVertex].nz = 1.0f;

	verts[nCurVertex].color = D3DCOLOR_COLORVALUE(1.0f, 1.0f, 1.0f, a);

	nCurVertex += 1;

	verts[nCurVertex].x = x;
	verts[nCurVertex].y = y + 0.75f;
	verts[nCurVertex].z = 0.0f;

	verts[nCurVertex].nx = 0.0f;
	verts[nCurVertex].ny = 0.0f;
	verts[nCurVertex].nz = 1.0f;

	verts[nCurVertex].color = D3DCOLOR_COLORVALUE(1.0f, 1.0f, 1.0f, a);

	nCurVertex += 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\xodash\XODashLib\Inifile.h ===
//---------------------------------------------------------------------------
//
// inifile.h - This file contains the class declaration for the FitIni Files
//
//				The FitIni file is a ini style file.
//
//	Honor Bound -- FASA Interactive Technologies
//
//	Copyright (c) 1995 FASA Interactive Technologies
//
//
//---------------------------------------------------------------------------

#ifndef INIFILE_H
#define INIFILE_H
//---------------------------------------------------------------------------
// Include files


#ifndef FILE_H
#include "file.h"
#endif

//---------------------------------------------------------------------------
// Macro Definitions
#ifndef 	NO_ERR
#define	NO_ERR						0x00000000
#endif

#define BLOCK_NOT_FOUND						0xFADA0000
#define ID_NOT_FOUND							0xFADA0001
#define DATA_NOT_CORRECT_TYPE				0xFADA0002
#define BUFFER_TOO_SMALL					0xFADA0003
#define NOT_A_FITINIFILE					0xFADA0004
#define NO_RAM_FOR_INI_BLOCKS				0xFADA0005
#define NO_MORE_BLOCKS						0xFADA0006
#define TOO_MANY_BLOCKS						0xFADA0007
#define NOT_ENOUGH_BLOCKS					0xFADA0008
#define VARIABLE_NOT_FOUND					0xFADA0009
#define SYNTAX_ERROR							0xFADA000A
#define NOT_ENOUGH_ELEMENTS_FOR_ARRAY	0xFADA000B
#define GET_NEXT_LINE						0xFADA000C
#define USER_ARRAY_TOO_SMALL				0xFADA000D
#define TOO_MANY_ELEMENTS					0xFADA000E

//---------------------------------------------------------------------------
// Enums

//---------------------------------------------------------------------------
// Structs
struct IniBlockNode
{
	char blockId[50];
	unsigned long blockOffset;
};

//---------------------------------------------------------------------------
//									FitIniFile
class FitIniFile : public File
{
	// Data Members
	//--------------
	protected:
		unsigned long 	totalBlocks;					//Total number of blocks in file
		IniBlockNode 	*fileBlocks;					//Data for blocks to speed up file
		char 				*currentBlockId;				//Id of current block
		unsigned long 	currentBlockOffset;			//Offset into file of block start
		unsigned long 	currentBlockSize;				//Length of current block

	// Member Functions
	//------------------
	protected:
		long afterOpen (void);
		void atClose (void);
		
		long findNextBlockStart (char *line = NULL, unsigned long lineLen = 0);
		long countBlocks (void);
		
		long getNextWord (char *&line, char *buffer, unsigned long bufLen);

		float textToFloat (const char *num);
		double textToDouble (const char *num);
		
		long textToLong (const char *num);
		unsigned long textToULong (const char *num);
		
		short textToShort (const char *num);
		unsigned short textToUShort (const char *num);
		
		char textToChar (const char *num);
		unsigned char textToUChar (const char *num);

		bool booleanToLong (const char *num);

		float mathToFloat (const char *num);
		
		long mathToLong (const char *num);
		unsigned long mathToULong (const char *num);
		
		short mathToShort (const char *num);
		unsigned short mathToUShort (const char *num);
		
		char mathToChar (const char *num);
		unsigned char mathToUChar (const char *num);

		long floatToText (char *result, float num, unsigned long bufLen);
		
		long longToTextDec (char *result, long num, unsigned long bufLen);
		long longToTextHex (char *result, long num, unsigned long bufLen);

		long shortToTextDec (char *result, short num, unsigned long bufLen);
		long shortToTextHex (char *result, short num, unsigned long bufLen);

		long byteToTextDec (char *result, byte num, unsigned long bufLen);	
		long byteToTextHex (char *result, byte num, unsigned long bufLen);
		
		long copyString (char* dest, char *src, unsigned long bufLen);

	public:
		FitIniFile (void);
		~FitIniFile (void);

		virtual long open (const char* fName, FileMode _mode = READ, long numChildren = 50);
		virtual long open (File* _parent, unsigned long fileSize, long numChildren = 50);
		
		virtual long create (char* fName);
		virtual long createWithCase( char* fName );


		virtual void close (void);

		virtual FileClass getFileClass (void)
		{
			return INIFILE;
		}

		long seekBlock (const char *blockId);

		long readIdFloat (const char *varName, float &value);
		long readIdDouble (const char *varName, double &value);
		
		long readIdBoolean (const char *varName, bool &value);
		long readIdLong (const char *varName, long &value);
		long readIdULong (const char *varName, unsigned long &value);
		
		long readIdShort (const char *varName, short &value);
		long readIdUShort (const char *varName, unsigned short &value);
		
		long readIdChar (const char *varName, char &value);
		long readIdUChar (const char *varName, unsigned char &value);
		
		long readIdString (const char *varName, char *result, unsigned long bufferSize);

		long getIdStringLength (const char *varName);
		
		long readIdFloatArray (const char *varName, float *result, unsigned long numElements);
		
		long readIdLongArray (const char *varName, long *result, unsigned long numElements);
		long readIdULongArray (const char *varName, unsigned long *result, unsigned long numElements);
		
		long readIdShortArray (const char *varName, short *result, unsigned long numElements);
		long readIdUShortArray (const char *varName, unsigned short *result, unsigned long numElements);
		
		long readIdCharArray (const char *varName, char *result, unsigned long numElements);
		long readIdUCharArray (const char *varName, unsigned char *result, unsigned long numElements);
		
		unsigned long getIdFloatArrayElements (const char *varName);
		
		unsigned long getIdLongArrayElements (const char *varName);
		unsigned long getIdULongArrayElements (const char *varName);
											 
		unsigned long getIdShortArrayElements (const char *varName);
		unsigned long getIdUShortArrayElements (const char *varName);
		
		unsigned long getIdCharArrayElements (const char *varName);
		unsigned long getIdUCharArrayElements (const char *varName);
		
		long writeBlock (const char *blockId);

		long writeIdFloat (const char *varName, float value);
		
		long writeIdBoolean (const char *varName, bool value);
		long writeIdLong (const char *varName, long value);
		long writeIdULong (const char *varName, unsigned long value);
		
		long writeIdShort (const char *varName, short value);
		long writeIdUShort (const char *varName, unsigned short value);
		
		long writeIdChar (const char *varName, char value);
		long writeIdUChar (const char *varName, unsigned char value);
		
		long writeIdString (const char *varName, const char *result);

		long writeIdFloatArray (const char *varName, float *array, unsigned long numElements);
		long writeIdLongArray (const char *varName, long *array, unsigned long numElements);
		long writeIdUShortArray (const char *varName, unsigned short *array, unsigned long numElements);
		long writeIdUCharArray (const char *varName, unsigned char *array, unsigned long numElements);
};

//---------------------------------------------------------------------------
#endif

//---------------------------------------------------------------------------
//
// Edit Log
//
//
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\xodash\XODashLib\FileUtil.cpp ===
#include "std.h"

#include "globals.h"
#include "fileutil.h"
#include "utilities.h"
#include <stdio.h>
#include <tchar.h>


bool DoesFileExist(const TCHAR* szFileName)
{
    CHAR szFile[MAX_PATH];
    WIN32_FILE_ATTRIBUTE_DATA fad;
	
	Ansi(szFile, szFileName, MAX_PATH-1);
    return GetFileAttributesEx(szFile, GetFileExInfoStandard, &fad) != 0;
}

void MakePath(TCHAR* szBuf, const TCHAR* szDir, const TCHAR* szFile)
{
	int cch = _tcslen(szDir);

	if (szBuf != szDir)
		memcpy(szBuf, szDir, (cch) * sizeof (TCHAR));

	ASSERT(cch > 0);
	if (szBuf[cch - 1] != '\\')
	{
		szBuf[cch] = '\\';
		cch += 1;
	}

	_tcscpy(szBuf + cch, szFile);
}

void CleanFilePath(char* szPath, const TCHAR* szSrcPath)
{
	char* pchPath = szPath;
	const TCHAR* pch = szSrcPath;
	if (_tcsnicmp(pch, _T("file:"), 5) == 0)
		pch += 5;
	for (; *pch != '\0'; pch += 1)
	{
		if (*pch == '/')
			*pchPath++ = '\\';
		else if (*pch == '?')
			break;
		else
			*pchPath++ = (char)*pch;
	}
	*pchPath = '\0';
}

#if defined(UNICODE)
void CleanFilePath(TCHAR* szPath, const TCHAR* szSrcPath)
{
	TCHAR* pchPath = szPath;
	const TCHAR* pch = szSrcPath;
	if (_tcsnicmp(pch, _T("file:"), 5) == 0)
		pch += 5;
	for (; *pch != '\0'; pch += 1)
	{
		if (*pch == '/')
			*pchPath++ = '\\';
		else if (*pch == '?')
			break;
		else
			*pchPath++ = (TCHAR)*pch;
	}
	*pchPath = '\0';
}
#endif

void MakeAbsoluteURL2(TCHAR* szBuf, const TCHAR* szBase, const TCHAR* szURL)
{
	if (_tcschr(szURL, ':') != NULL || (szURL[0] == '\\' && szURL[1] == '\\') || szBase == NULL || (_tcschr(szBase, ':') == NULL && _tcschr(szBase, '/') == NULL))
	{
		_tcscpy(szBuf, szURL);
		return;
	}

	const TCHAR* pchURL = szURL;

	// make relative url absolute...
	_tcscpy(szBuf, szBase);
	TCHAR* pch = _tcsrchr(szBuf, '/');
	if (pch == NULL)
		pch = _tcsrchr(szBuf, '\\');
	if (*pch == NULL)
	{
		pch = szBuf + _tcslen(szBuf) - 1;
	}
	else
	{
		while (pchURL[0] == '.' && pchURL[1] == '.' && (pchURL[2] == '/' || pchURL[2] == '\\'))
		{
			pchURL += 3;

			*pch = '\0';
			pch = _tcsrchr(szBuf, '/');
			if (pch == NULL)
				pch = _tcsrchr(szBuf, '\\');
			if (pch == NULL)
			{
				pch = szBuf + _tcslen(szBuf) - 1;
				break;
			}
		}
	}

	*pch = '/';
	_tcscpy(pch + 1, pchURL);
}

void MakeAbsoluteURL(TCHAR* szBuf, const TCHAR* szBase, const TCHAR* szURL)
{
	if (szBase == NULL)
	{
		MakeAbsoluteURL2(szBuf, g_szAppDir, szURL);
	}
	else
	{
		TCHAR szBuf2 [1024];
		MakeAbsoluteURL2(szBuf2, g_szAppDir, szBase);
		MakeAbsoluteURL2(szBuf, szBuf2, szURL);
	}
}

TCHAR g_szCurDir [1024];

void UpdateCurDirFromFile(const TCHAR* szURL)
{
	TCHAR szBuf [1024];
	MakeAbsoluteURL(szBuf, szURL);

	if (_tcschr(szBuf, ':') != NULL || (szBuf[0] == '\\' && szBuf[1] == '\\'))
	{
//		if (_tcsicmp(g_szCurDir, szBuf) != 0)
//		{
			_tcscpy(g_szCurDir, szBuf);
//			TRACE(_T("Setting base directory to %s\n"), g_szCurDir);
//		}

/* REVIEW: File is removed in MakeAbsoluteURL...
		TCHAR* pch = _tcsrchr(g_szCurDir, '/');
		if (pch == NULL)
			pch = _tcsrchr(g_szCurDir, '\\');
		if (pch != NULL)
			*pch = '\0';
		TRACE(_T("Set base URL to: %s\n"), g_szCurDir);
*/
	}
}

void MakeAbsoluteURL(TCHAR* szBuf, const TCHAR* szURL)
{
	TCHAR szCurDir [1024];
	MakeAbsoluteURL2(szCurDir, g_szAppDir, g_szCurDir);
	MakeAbsoluteURL2(szBuf, szCurDir, szURL);
}

void FindFilePath(TCHAR* szFullPath/*[MAX_PATH]*/, const TCHAR* szFile)
{
	// Make it absolute...
	MakeAbsoluteURL(szFullPath, szFile);

	if (!DoesFileExist(szFullPath))
	{
		DbgPrint("File not found: %s\n", szFullPath);
		_tcscpy(szFullPath, g_szAppDir);
		_tcscat(szFullPath, szFile);
		DbgPrint("\ttrying %s instead...\n", szFullPath);
	}
}


DWORD GetUniqueFile(const TCHAR* szBase, TCHAR* szPath/*=NULL*/)
{
	TCHAR szDirBuf [MAX_PATH];
	if (szPath == NULL)
		szPath = szDirBuf;

	for (DWORD dw = 0; ; dw += 1)
	{
		_stprintf(szPath, _T("%s\\%08x"), szBase, dw);
		if (!DoesFileExist(szPath))
			return dw;
	}
}

DWORD CreateUniqueDir(const TCHAR* szBase)
{
	TCHAR szDirBuf [MAX_PATH];
	DWORD dw = GetUniqueFile(szBase, szDirBuf);
	DbgPrint("CreateDirectory: %s\n", szDirBuf);

	char sszFileName [MAX_PATH];
	CleanFilePath(sszFileName, szDirBuf);
	ASSERT(CreateDirectory(sszFileName, NULL));

	return dw;
}

int GetFileBlocks(const TCHAR* szFilePath, int nBlockSize)
{
	HANDLE hFile = XAppCreateFile(szFilePath, GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, 0, NULL);
	if (hFile == INVALID_HANDLE_VALUE)
		return 0;

	int nBytes = GetFileSize(hFile, NULL);

	CloseHandle(hFile);

	return (nBytes + nBlockSize - 1) / nBlockSize;
}

int GetDirectoryBlocks(const TCHAR* szDirPath, int nBlockSize, bool bRecursive, HANDLE hCancelEvent)
{
    if (hCancelEvent && WaitForSingleObject(hCancelEvent, 0) == WAIT_OBJECT_0)
    {
        return -1;
    }

	TCHAR szBuf [MAX_PATH];
	MakePath(szBuf, szDirPath, _T("*.*"));
	
    WIN32_FIND_DATA fd;

	//
	// nTotalBlocks starts out with 1 to take into account the size taken up from the directory entry itself.
	//
	int nTotalBlocks = 1;
    bool bCancel = false;

	char sszBuf [MAX_PATH];
	Ansi(sszBuf, szBuf, MAX_PATH);
	HANDLE hFind = FindFirstFile(sszBuf, &fd);

	if (hFind == INVALID_HANDLE_VALUE)
		return 0;

	do
	{
        if (hCancelEvent && WaitForSingleObject(hCancelEvent, 0) == WAIT_OBJECT_0)
        {
            bCancel = true;
            break;
        }

		if ((fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0)
		{
			nTotalBlocks += (fd.nFileSizeLow + nBlockSize - 1) / nBlockSize;
		}
		else if (bRecursive && fd.cFileName[0] != '.')
		{
			TCHAR szFileName [MAX_PATH];
#ifdef _UNICODE
			Unicode(szFileName, fd.cFileName, MAX_PATH);
#endif
			MakePath(szBuf, szDirPath, szFileName);
			nTotalBlocks += GetDirectoryBlocks(szBuf, nBlockSize, true, hCancelEvent);
		}
	}
	while (FindNextFile(hFind, &fd));
	FindClose(hFind);

	return bCancel ? -1 : nTotalBlocks;
}

int GetFileSize(const TCHAR* szFilePath)
{
	HANDLE hFile = XAppCreateFile(szFilePath, GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE, NULL, OPEN_EXISTING, FILE_FLAG_BACKUP_SEMANTICS, NULL);
	if (hFile == INVALID_HANDLE_VALUE)
		return 0;

	int nFileSize = GetFileSize(hFile, NULL);

	CloseHandle(hFile);

	return nFileSize;
}

#ifdef _WINDOWS // TODO: Need Xbox versions too!

bool DeleteDirectory(const TCHAR* szPath)
{
	TCHAR szBuf [MAX_PATH];
	_stprintf(szBuf, _T("%s\\*.*"), szPath);

	WIN32_FIND_DATA fd;
	HANDLE h = FindFirstFile(szBuf, &fd);
	if (h != INVALID_HANDLE_VALUE)
	{
		do
		{
			if (_tcscmp(fd.cFileName, _T(".")) == 0 || _tcscmp(fd.cFileName, _T("..")) == 0)
				continue;

			_stprintf(szBuf, _T("%s\\%s"), szPath, fd.cFileName);

			if ((fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) != 0)
			{
				if (!DeleteDirectory(szBuf))
					return false;
			}
			else
			{
				if (!DeleteFile(szBuf))
					return false;
			}
		}
		while (FindNextFile(h, &fd));
		FindClose(h);
	}

	return RemoveDirectory(szPath) != FALSE;
}

bool CopyDirectory(const TCHAR* szSrcPath, const TCHAR* szDestPath)
{
	CreateDirectory(szDestPath, NULL);

	TCHAR szBuf [MAX_PATH];
	_stprintf(szBuf, _T("%s\\*.*"), szSrcPath);

	WIN32_FIND_DATA fd;
	HANDLE h = FindFirstFile(szBuf, &fd);
	if (h != INVALID_HANDLE_VALUE)
	{
		do
		{
			if (_tcscmp(fd.cFileName, _T(".")) == 0 || _tcscmp(fd.cFileName, _T("..")) == 0)
				continue;

			_stprintf(szBuf, _T("%s\\%s"), szSrcPath, fd.cFileName);

			TCHAR szBuf2 [MAX_PATH];
			_stprintf(szBuf2, _T("%s\\%s"), szDestPath, fd.cFileName);

			if ((fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) != 0)
			{
				if (!CopyDirectory(szBuf, szBuf2))
					return false;
			}
			else
			{
				if (!CopyFile(szBuf, szBuf2, FALSE))
					return false;
			}
		}
		while (FindNextFile(h, &fd));
		FindClose(h);
	}

	return true;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\xodash\XODashLib\falloff.cpp ===
#include "std.h"
#include "globals.h"

extern D3DXMATRIX g_matPosition;

#include "effect.h"
#include "effect2.h"
#include "effect3.h"
#include "effect4.h"
#include "aniso.h"
#include "utilities.h"

#define D3DFVF_NORMPACKED3		0x20000000


struct SHADEDESC
{
	int m_nEffect;
	DWORD* m_rgdwMicrocode;
	DWORD m_fvf;
	DWORD m_dwShader;
	bool m_bReportedError;
};

#define SHADERNAME(name) dw##name##VertexShader

SHADEDESC fixed_shaders [] =
{
	{
		0,
		SHADERNAME(Effect),
		D3DFVF_XYZ | D3DFVF_NORMPACKED3 | D3DFVF_DIFFUSE
	},
	{
		1,
		SHADERNAME(Effect),
		D3DFVF_XYZ | D3DFVF_NORMPACKED3
	},
	{
		2,
		SHADERNAME(Effect),
		D3DFVF_XYZ | D3DFVF_NORMPACKED3 | D3DFVF_TEX1
	},
};

SHADEDESC shaders [] =
{
	{
		1,
		SHADERNAME(Effect),
		D3DFVF_XYZ | D3DFVF_NORMPACKED3 | D3DFVF_DIFFUSE
	},
	{
		1,
		SHADERNAME(Effect),
		D3DFVF_XYZ | D3DFVF_NORMPACKED3
	},
	{
		1,
		SHADERNAME(Effect2),
		D3DFVF_XYZ | D3DFVF_NORMPACKED3 | D3DFVF_TEX1
	},
	{
		2,
		SHADERNAME(Aniso),
		D3DFVF_XYZ | D3DFVF_NORMPACKED3
	},
	{
		3,
		SHADERNAME(Effect3),
		D3DFVF_XYZ | D3DFVF_NORMPACKED3 | D3DFVF_TEX1
	},
	{
		4,
		SHADERNAME(Effect4),
		D3DFVF_XYZ | D3DFVF_NORMPACKED3
	},
    // Temporary shaders for uncompressed normals
	{
		1,
		SHADERNAME(Effect),
		D3DFVF_XYZ | D3DFVF_NORMAL | D3DFVF_DIFFUSE
	},
	{
		1,
		SHADERNAME(Effect),
		D3DFVF_XYZ | D3DFVF_NORMAL
	},
	{
		1,
		SHADERNAME(Effect2),
		D3DFVF_XYZ | D3DFVF_NORMAL | D3DFVF_TEX1
	},
	{
		2,
		SHADERNAME(Aniso),
		D3DFVF_XYZ | D3DFVF_NORMAL
	},
	{
		3,
		SHADERNAME(Effect3),
		D3DFVF_XYZ | D3DFVF_NORMAL | D3DFVF_TEX1
	},
	{
		4,
		SHADERNAME(Effect4),
		D3DFVF_XYZ | D3DFVF_NORMAL
	},
};

DWORD GetEffectShader(int nEffect, DWORD fvf)
{
	if (nEffect == 0)
		return fvf;

	SHADEDESC* pShadeDesc = shaders;
	for (int i = 0; pShadeDesc->m_nEffect != nEffect || pShadeDesc->m_fvf != fvf; i += 1, pShadeDesc += 1)
	{
		if (i >= countof (shaders) - 1)
		{
			DbgPrint("\001Cannot find effect %d shader for fvf: 0x%08x\n", nEffect, fvf);
			return fvf;
		}
	}

	if (pShadeDesc->m_dwShader == 0)
	{
		const DWORD* rgdwFunction = NULL;

		ASSERT(pShadeDesc->m_rgdwMicrocode != NULL);
		rgdwFunction = pShadeDesc->m_rgdwMicrocode;

		static DWORD decl1 [] = 
		{
			D3DVSD_STREAM( 0 ),
			D3DVSD_REG( 0, D3DVSDT_FLOAT3 ), // Position of first mesh
			D3DVSD_REG( 3, D3DVSDT_NORMPACKED3 ), // Normal
			D3DVSD_END()
		};

		static DWORD decl2 [] = 
		{
			D3DVSD_STREAM( 0 ),
			D3DVSD_REG( 0, D3DVSDT_FLOAT3 ), // Position of first mesh
			D3DVSD_REG( 3, D3DVSDT_NORMPACKED3 ), // Normal
			D3DVSD_REG( 6, D3DVSDT_FLOAT2 ), // Tex coords
			D3DVSD_END()
		};

		static DWORD decl3 [] = 
		{
			D3DVSD_STREAM( 0 ),
			D3DVSD_REG( 0, D3DVSDT_FLOAT3 ), // Position of first mesh
			D3DVSD_REG( 3, D3DVSDT_FLOAT3 ), // Normal
			D3DVSD_END()
		};

		static DWORD decl4 [] = 
		{
			D3DVSD_STREAM( 0 ),
			D3DVSD_REG( 0, D3DVSDT_FLOAT3 ), // Position of first mesh
			D3DVSD_REG( 3, D3DVSDT_FLOAT3 ), // Normal
			D3DVSD_REG( 6, D3DVSDT_FLOAT2 ), // Tex coords
			D3DVSD_END()
		};


		if (fvf & D3DFVF_NORMPACKED3) 
		{
			g_pd3dDevice->CreateVertexShader(/*decl*/ (fvf & D3DFVF_TEX1) ? decl2 : decl1, rgdwFunction, &pShadeDesc->m_dwShader, 0);
		}
		else 
		{
			g_pd3dDevice->CreateVertexShader(/*decl*/ (fvf & D3DFVF_TEX1) ? decl4 : decl3, rgdwFunction, &pShadeDesc->m_dwShader, 0);
		}
	}

	return pShadeDesc->m_dwShader;
}

DWORD GetFixedFunctionShader(DWORD fvf)
{
	SHADEDESC* pShadeDesc = fixed_shaders;
	for (int i = 0; pShadeDesc->m_fvf != fvf; i += 1, pShadeDesc += 1)
	{
		if (i >= countof (fixed_shaders) - 1)
		{
			if (fvf & D3DFVF_NORMAL)
			{
//				DbgPrint("\001Cannot find compressed fixed function shader for fvf: 0x%08x\n", fvf);
			}

			return fvf;
		}
	}

	if (pShadeDesc->m_dwShader == 0)
	{
		static DWORD decl[3][5] = 
		{
			{
				D3DVSD_STREAM( 0 ),
				D3DVSD_REG( D3DVSDE_POSITION, D3DVSDT_FLOAT3 ), // Position of first mesh
				D3DVSD_REG( D3DVSDE_NORMAL, D3DVSDT_NORMPACKED3 ), // Normal
				D3DVSD_REG( D3DVSDE_DIFFUSE, D3DVSDT_D3DCOLOR ), // Diffuse color
				D3DVSD_END()
			},
			{
				D3DVSD_STREAM( 0 ),
				D3DVSD_REG( D3DVSDE_POSITION, D3DVSDT_FLOAT3 ), // Position of first mesh
				D3DVSD_REG( D3DVSDE_NORMAL, D3DVSDT_NORMPACKED3 ), // Normal
				D3DVSD_END()
			},
			{
				D3DVSD_STREAM( 0 ),
				D3DVSD_REG( D3DVSDE_POSITION, D3DVSDT_FLOAT3 ), // Position of first mesh
				D3DVSD_REG( D3DVSDE_NORMAL, D3DVSDT_NORMPACKED3 ), // Normal
				D3DVSD_REG( D3DVSDE_TEXCOORD0, D3DVSDT_FLOAT2 ), // Tex coords
				D3DVSD_END()
			},
		};

		g_pd3dDevice->CreateVertexShader(&decl[i][0], NULL, &pShadeDesc->m_dwShader, 0);
	}

	return pShadeDesc->m_dwShader;
}

DWORD CompressNormal(float* pvNormal) {

    float vNormal[3];
    float fLength;

    fLength = (float)sqrt(pvNormal[0] * pvNormal[0] + pvNormal[1] * pvNormal[1] + pvNormal[2] * pvNormal[2]);

    vNormal[0] = pvNormal[0] / fLength;
    vNormal[1] = pvNormal[1] / fLength;
    vNormal[2] = pvNormal[2] / fLength;

    return ((((DWORD)(vNormal[0] * 1023.0f) & 0x7FF) << 0)  |
            (((DWORD)(vNormal[1] * 1023.0f) & 0x7FF) << 11) |
            (((DWORD)(vNormal[2] *  511.0f) & 0x3FF) << 22));
}



void SetReflectShaderFrameValues()
{
    D3DXMATRIX mat, worldView, viewTrans, projTrans;

    g_pd3dDevice->GetTransform( D3DTS_WORLD, &worldView );
	g_pd3dDevice->GetTransform( D3DTS_VIEW, &viewTrans );
	D3DXMatrixMultiply(&worldView, &worldView, &viewTrans);

     // World/View
    D3DXMatrixTranspose(&mat, &worldView);
    g_pd3dDevice->SetVertexShaderConstant(40, &mat(0,0), 4);

    // Projection
    g_pd3dDevice->GetTransform( D3DTS_PROJECTION, &projTrans );
    D3DXMatrixTranspose(&mat, &projTrans);
    g_pd3dDevice->SetVertexShaderConstant(44, &mat(0,0), 4);

    g_pd3dDevice->SetVertexShaderConstant(48, &D3DXVECTOR4(0.0f, 0.0f, 1.0f, 0.5f), 1);

	D3DXVECTOR4 lightDir(1.0f, 1.0f, -1.0f, 0.0f);
	D3DXVec4Normalize(&lightDir, &lightDir);
	D3DXMatrixTranspose(&mat, &worldView);
	D3DXVec3TransformNormal((D3DXVECTOR3*)&lightDir, (D3DXVECTOR3*)&lightDir, &mat);
	D3DXVec4Normalize(&lightDir, &lightDir);
	g_pd3dDevice->SetVertexShaderConstant(49, &lightDir, 1);

    g_pd3dDevice->SetRenderState(D3DRS_LIGHTING, FALSE);
}



void SetFalloffShaderFrameValues()
{

////////////////////////////////////////////////////
	D3DXMATRIX mat, worldView, viewMat, projMat, worldMat;

	g_pd3dDevice->GetTransform( D3DTS_VIEW, &viewMat );
	g_pd3dDevice->GetTransform( D3DTS_PROJECTION, &projMat );
	g_pd3dDevice->GetTransform( D3DTS_WORLD, &worldMat );



	D3DXMatrixMultiply(&worldView, &worldMat, &viewMat );

	// World/View/Projection
	D3DXMatrixMultiply(&mat, &worldView, &projMat);
	D3DXMatrixTranspose(&mat, &mat);
	g_pd3dDevice->SetVertexShaderConstant(0, &mat(0,0), 4);

	// Position Transform
	D3DXMatrixTranspose(&mat, &worldView);
	//D3DXMatrixTranspose(&mat, &worldMat);
	g_pd3dDevice->SetVertexShaderConstant(10, &mat(0,0), 4);

	// Normal Transform
	D3DXMatrixInverse(&mat, NULL, &worldView);
	g_pd3dDevice->SetVertexShaderConstant(5, &mat(0,0), 4);

	D3DXVECTOR4 v(0.0f, 0.5f, 1.0f, -1.0f);
	g_pd3dDevice->SetVertexShaderConstant(9, &v, 1);
	
	D3DXVECTOR4 lightDir(1.0f, 1.0f, -1.0f, 0.0f);
	D3DXVec4Normalize(&lightDir, &lightDir);
	D3DXMatrixTranspose(&mat, &worldView);
	D3DXVec3TransformNormal((D3DXVECTOR3*)&lightDir, (D3DXVECTOR3*)&lightDir, &mat);
	D3DXVec4Normalize(&lightDir, &lightDir);
	g_pd3dDevice->SetVertexShaderConstant(4, &lightDir, 1);

	g_pd3dDevice->SetTexture(0, NULL);
	g_pd3dDevice->SetRenderState(D3DRS_LIGHTING, FALSE);
}

float g_nEffectAlpha = 1.0f;

void SetFalloffShaderValues(const D3DXCOLOR& sideColor, const D3DXCOLOR& frontColor)
{
	D3DXVECTOR4 v;

	v.x = sideColor.r;
	v.y = sideColor.g;
	v.z = sideColor.b;
	v.w = sideColor.a * g_nEffectAlpha;
	g_pd3dDevice->SetVertexShaderConstant(15, &v, 1);

	v.x = frontColor.r - sideColor.r;
	v.y = frontColor.g - sideColor.g;
	v.z = frontColor.b - sideColor.b;
	v.w = (frontColor.a - sideColor.a) * g_nEffectAlpha;
	g_pd3dDevice->SetVertexShaderConstant(16, &v, 1);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\xodash\XODashLib\font.h ===
#pragma once 

struct TEXTVERTEX
{
	float x, y, z;
	float nx, ny, nz;
	DWORD color;
};

struct CGlyphVertex
{
	float x, y;
};

struct CGlyphShape
{
	WORD m_nIndexCount;
	WORD m_nVertexCount;
	WORD* m_indices;
	CGlyphVertex* m_vertices;
	int m_nGlyphIndex;    // added to hold the index of the character
};

struct CGlyphMetrics
{
    float gmfBlackBoxX;
    float gmfBlackBoxY;
    CGlyphVertex gmfptGlyphOrigin;
    float gmfCellIncX;
    float gmfCellIncY;
};

struct CGlyphObject
{
	CGlyphMetrics m_metrics;
	CGlyphShape* m_pGlyphShape; // or DWORD m_dwFileOffsetOfGlyphShape
};

struct CWCRange
{
	WCHAR wcLow;
	USHORT cGlyphs;
};

struct CGlyphSet
{
	DWORD cbThis;
	DWORD flAccel;
	DWORD cGlyphsSupported;
	DWORD cRanges;
	CWCRange ranges [1];
};

inline float smoothstep(float a, float b, float x)
{
	if (x < a)
		return 0.0f;

	if (x >= b)
		return 1.0f;

	x = (x - a) / (b - a);

	return (x * x * (3 - 2 * x));
}

class CFont
{
public:
	CFont();
	~CFont();

	bool Open(const TCHAR* szFile);
	void Close();
	bool LoadGlyph(int nGlyphIndex);
	int FindGlyphIndex(WCHAR wch);
	HRESULT CreateTextMesh(const TCHAR* pchText, int nChars, LPD3DXMESH* ppMesh, D3DXVECTOR3* pMin, D3DXVECTOR3* pMax, float nFormatWidth, bool bDoNotBreak, int nCursorPos);
	void CreateCursorMesh(WORD*& indices, int& nCurIndex, TEXTVERTEX*& verts, int& nCurVertex, float x, float y, bool visible);
	HANDLE m_hFile;

private:
    bool IsBreakChar(TCHAR ch);


	CGlyphSet* m_pGlyphSet;
	CGlyphObject* m_rgGlyphObjects;
	bool* m_rgGlyphLoaded;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\xodash\XODashLib\locale.h ===
#ifndef LOCALE_H
#define LOCALE_H
/*************************************************************************************************\
AccountData.h		: Interface for all locale related info
Creation Date		: 2/8/2002 6:31:00 PM
Library				: .lib
Copyright Notice	: (C) 2000 Microsoft
Author				: Victor Blanco
//-------------------------------------------------------------------------------------------------
Notes				: 
\*************************************************************************************************/

//*************************************************************************************************
#include "xonline.h"
#include "xoconst.h"

#define REGION_AMERICA				0
#define REGION_EUROPE				1
#define REGION_ASIA					2

#define LANGUAGE_ENGLISH            1
#define LANGUAGE_SPANISH            2
#define LANGUAGE_FRENCH             3
#define LANGUAGE_GERMAN             4
#define LANGUAGE_JAPANESE           5
#define LANGUAGE_ITALIAN            6

static const CHAR* szLocaleDir[] =
{
	"NoLanguage", 
    "English",
    "Japanese",
    "German",
    "French",
    "Spanish",
    "Italian"
};

/**************************************************************************************************
CLASS DESCRIPTION
UserLocaleInfo:  Structure that stores all of the necessary locale related
                 values based on the region/language settings
**************************************************************************************************/
struct UserLocaleInfo
{
    char               m_cDateSeperator;  // m.d.y vs. m/d/y
    int                m_bMonthFirstFormatting;  // m/d/y vs. d/m/y
    char               m_cTimeSeperator;  // hh:mm vs. hh.mm
    int                m_bTwentyFourHourTime;
    char               m_cIntegerSeperator;  // , vs ' ' vs .
};



/**************************************************************************************************
CLASS DESCRIPTION
LocaleInfo:  Class that deals with all of the necessary locale related
             functions based on the region/language settings
**************************************************************************************************/
class LocaleInfo
{
public:
    LocaleInfo();
    ~LocaleInfo();
    HRESULT LoadLocale( int nLanguage, int nCountry );
    static HRESULT UpdateLocaleInfo();
    

private:
    UserLocaleInfo  m_LocaleData;
};

//*************************************************************************************************
#endif  // end of file ( Locale.h )
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\xodash\XODashLib\locale.cpp ===
/*************************************************************************************************\
Locale.cpp		    : Implementation of the Locale component.
Creation Date		: 2/8/2002 6:52:28 PM
Copyright Notice	: (C) 2000 Microsoft
Author				: Victor Blanco
//-------------------------------------------------------------------------------------------------
Notes				: 
\*************************************************************************************************/
#include "std.h"
#include "locale.h"
#include "file.h"

HRESULT ReturnLocaleFile( const char *szDirName, int nCountry, char **szReturnBuffer )
{
    CHAR strPath[MAX_PATH];
    sprintf( strPath, "%s%s\\%s.%3d", CONTENT_PATH_ANSI, szDirName, LOCALE_FILE_ANSI, nCountry );

    // Try to open the file
    File inputFile;
	if( inputFile.open( strPath, READ ) != NO_ERR )
    {
        // Return error
        CHAR strBuffer[80];
        sprintf( strBuffer, "Locale::LoadLocale(): Could not find file [%s]\n", strPath );
        OutputDebugStringA( strBuffer );
        ASSERT( false );
        return E_FAIL;
    }

    DWORD dwSize = inputFile.fileSize();

    *szReturnBuffer = new char[dwSize + 1];
    DWORD numRead = 0;

    if( !inputFile.read( (BYTE *)*szReturnBuffer, dwSize ) )
    {
        // Return error
        CHAR strBuffer[80];
        sprintf( strBuffer, "Locale::LoadLocaleFile(): Could not read from file [%s]\n", strPath );
        OutputDebugStringA( strBuffer );
        ASSERT( false );
        return E_FAIL;
    }

    (*szReturnBuffer)[dwSize] = '\0';

    // Found the file. Close the file and return
    inputFile.close();

    return S_OK;
}

LocaleInfo::LocaleInfo()
{
    m_LocaleData.m_bMonthFirstFormatting = 0;
    m_LocaleData.m_bTwentyFourHourTime   = 0;
    m_LocaleData.m_cDateSeperator        = '\0';
    m_LocaleData.m_cIntegerSeperator     = '\0';
    m_LocaleData.m_cTimeSeperator        = '\0';
}

LocaleInfo::~LocaleInfo()
{

}

HRESULT LocaleInfo::LoadLocale( int nLanguage, int nCountry )
{
    char *szLocaleStream = NULL;
    if( FAILED(ReturnLocaleFile( szLocaleDir[nLanguage], nCountry, &szLocaleStream ) ) )
    {   
        return E_FAIL;
    }

    char seps[] = "=\n\0";
    char *token = "\0";

    token = strtok( szLocaleStream, seps );     

    while( token != NULL )
    {
        if( strcmp( "MonthFirstFormatting", token ) == 0 )
        {
            m_LocaleData.m_bMonthFirstFormatting = atoi( strtok( NULL, seps ) );
        }
        else if( strcmp ("TwentyFourHourTime", token ) == 0 )
        {
             m_LocaleData.m_bTwentyFourHourTime  = atoi( strtok( NULL, seps ) );
        }
        else if( strcmp ("DateSeperator", token ) == 0 )
        {
            token = strtok( NULL, seps );
            m_LocaleData.m_cDateSeperator = token[0];
        }
        else if( strcmp ("IntegerSeperator", token ) == 0 )
        {
            token = strtok( NULL, seps );
            m_LocaleData.m_cIntegerSeperator = token[0];
        }
        else if( strcmp ("TimeSeperator", token ) == 0 )
        {
            token = strtok( NULL, seps );
            m_LocaleData.m_cTimeSeperator = token[0];
        }
        token = strtok( NULL, seps ); 
    }   

    delete [] szLocaleStream;

    return S_OK;
}

HRESULT LocaleInfo::UpdateLocaleInfo()
{
    HRESULT hr = S_OK;

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\xodash\XODashLib\material.cpp ===
//-----------------------------------------------------------------------------
// File: Material.cpp
//
// Desc: Classes designed to define the different types of materials.
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include "std.h"
#include "material.h"
#include "texturecache.h"

extern LPDIRECT3DDEVICE8 g_pd3dDevice;

//-----------------------------------------------------------------------------
// Name: CBaseMaterial()
// Desc: Sets initial values of member variables and sets itself to the
//		 passed in material entry.
//-----------------------------------------------------------------------------
CBaseMaterial::CBaseMaterial()
{
    m_sMatName = NULL;
	m_MaterialDef.Diffuse.r  = m_MaterialDef.Diffuse.g  = m_MaterialDef.Diffuse.b  = m_MaterialDef.Diffuse.a  = 1.0f;
	m_MaterialDef.Ambient.r  = m_MaterialDef.Ambient.g  = m_MaterialDef.Ambient.b  = m_MaterialDef.Ambient.a  = 1.0f;
	m_MaterialDef.Specular.r = m_MaterialDef.Specular.g = m_MaterialDef.Specular.b = m_MaterialDef.Specular.a = 1.0f;
	m_MaterialDef.Emissive.r = m_MaterialDef.Emissive.g = m_MaterialDef.Emissive.b = m_MaterialDef.Emissive.a = 1.0f;
	m_MaterialDef.Power		 = 0.0f;
	m_ID		  = -1;
}

//-----------------------------------------------------------------------------
// Name: CBaseMaterial()
// Desc: Sets initial values of member variables and sets itself to the
//		 passed in material entry.
//-----------------------------------------------------------------------------
CBaseMaterial::CBaseMaterial(char *sMatName, int index)
{
    m_sMatName = new char[strlen(sMatName) + 1];
	strcpy( m_sMatName, sMatName );
	m_MaterialDef.Diffuse.r  = m_MaterialDef.Diffuse.g  = m_MaterialDef.Diffuse.b  = m_MaterialDef.Diffuse.a  = 1.0f;
	m_MaterialDef.Ambient.r  = m_MaterialDef.Ambient.g  = m_MaterialDef.Ambient.b  = m_MaterialDef.Ambient.a  = 1.0f;
	m_MaterialDef.Specular.r = m_MaterialDef.Specular.g = m_MaterialDef.Specular.b = m_MaterialDef.Specular.a = 1.0f;
	m_MaterialDef.Emissive.r = m_MaterialDef.Emissive.g = m_MaterialDef.Emissive.b = m_MaterialDef.Emissive.a = 1.0f;
	m_MaterialDef.Power		 = 0.0f;
	m_ID					 = index;
}

//-----------------------------------------------------------------------------
// Name: ~CBaseMaterial()
// Desc: Performs any needed cleanup before shutting down the object
//-----------------------------------------------------------------------------
CBaseMaterial::~CBaseMaterial()
{
	if(m_sMatName != NULL)
		delete [] m_sMatName;

	m_sMatName = NULL;
}

//-----------------------------------------------------------------------------
// Name: SetName()
// Desc: Sets the material's name
//-----------------------------------------------------------------------------
void CBaseMaterial::SetName(char *matName)
{
	m_sMatName = new char[strlen(matName) + 1];
	strcpy(m_sMatName, matName);
}

//-----------------------------------------------------------------------------
// Name: SetAllColors()
// Desc: Sets all of the materials colors if they are identical coming
//		 out of 3D Studio Max
//-----------------------------------------------------------------------------
void CBaseMaterial::SetAllColors(float r, float g, float b, float a)
{
	m_MaterialDef.Diffuse.r = m_MaterialDef.Ambient.r = m_MaterialDef.Specular.r = m_MaterialDef.Emissive.r = r;
	m_MaterialDef.Diffuse.g = m_MaterialDef.Ambient.g = m_MaterialDef.Specular.g = m_MaterialDef.Emissive.g = g;
	m_MaterialDef.Diffuse.b = m_MaterialDef.Ambient.b = m_MaterialDef.Specular.b = m_MaterialDef.Emissive.b = b;
	m_MaterialDef.Diffuse.a = m_MaterialDef.Ambient.a = m_MaterialDef.Specular.a = m_MaterialDef.Emissive.a = a;
}

//-----------------------------------------------------------------------------
// Name: SetDiffuse()
// Desc: Sets the diffuse color of the material
//-----------------------------------------------------------------------------
void CBaseMaterial::SetDiffuse(float r, float g, float b, float a)
{
	m_MaterialDef.Diffuse.r = r;
	m_MaterialDef.Diffuse.g = g;
	m_MaterialDef.Diffuse.b = b;
	m_MaterialDef.Diffuse.a = a;
}

//-----------------------------------------------------------------------------
// Name: SetAmbient()
// Desc: Sets the ambient color of the material
//-----------------------------------------------------------------------------
void CBaseMaterial::SetAmbient(float r, float g, float b, float a)
{
	m_MaterialDef.Ambient.r = r;
	m_MaterialDef.Ambient.g = g;
	m_MaterialDef.Ambient.b = b;
	m_MaterialDef.Ambient.a = a;
}

//-----------------------------------------------------------------------------
// Name: SetSpecular()
// Desc: Sets the specular color of the material
//-----------------------------------------------------------------------------
void CBaseMaterial::SetSpecular(float r, float g, float b, float a)
{
	m_MaterialDef.Specular.r = r;
	m_MaterialDef.Specular.g = g;
	m_MaterialDef.Specular.b = b;
	m_MaterialDef.Specular.a = a;
}

//-----------------------------------------------------------------------------
// Name: SetEmissive()
// Desc: Sets the emissive color of the material
//-----------------------------------------------------------------------------
void CBaseMaterial::SetEmissive(float r, float g, float b, float a)
{
	m_MaterialDef.Emissive.r = r;
	m_MaterialDef.Emissive.g = g;
	m_MaterialDef.Emissive.b = b;
	m_MaterialDef.Emissive.a = a;
}

//-----------------------------------------------------------------------------
// Name: SetPower()
// Desc: Sets the power of the material
//-----------------------------------------------------------------------------
void CBaseMaterial::SetPower(float power)
{
	m_MaterialDef.Power = power;
}

//-----------------------------------------------------------------------------
// Name: Setup()
// Desc: Initalizes the material for Direct3D
//-----------------------------------------------------------------------------
HRESULT CBaseMaterial::Setup( DWORD FVF, CTextureCache *pTexCache )
{
	if ( g_pd3dDevice != NULL )
	{
		g_pd3dDevice->SetVertexShader( FVF );

		// Set the material
		g_pd3dDevice->SetMaterial( &m_MaterialDef );

		// Set the texture
		g_pd3dDevice->SetTexture( 0, 0 );

		g_pd3dDevice->SetTextureStageState(0, D3DTSS_ADDRESSV, D3DTADDRESS_WRAP);
		g_pd3dDevice->SetTextureStageState(0, D3DTSS_COLOROP, D3DTOP_SELECTARG1);
		g_pd3dDevice->SetTextureStageState(0, D3DTSS_COLORARG1, D3DTA_TFACTOR);
		g_pd3dDevice->SetTextureStageState(0, D3DTSS_ALPHAOP, D3DTOP_MODULATE);
		g_pd3dDevice->SetTextureStageState(0, D3DTSS_ALPHAARG1, D3DTA_DIFFUSE);
		g_pd3dDevice->SetTextureStageState(0, D3DTSS_ALPHAARG2, D3DTA_TFACTOR);
		D3DCOLOR DiffuseColor = D3DCOLOR_RGBA((BYTE)(m_MaterialDef.Diffuse.r * 255), 
											  (BYTE)(m_MaterialDef.Diffuse.g * 255),
											  (BYTE)(m_MaterialDef.Diffuse.b * 255), 
											  (BYTE)(m_MaterialDef.Diffuse.a * 255));
		g_pd3dDevice->SetRenderState(D3DRS_TEXTUREFACTOR, DiffuseColor);

		g_pd3dDevice->SetRenderState( D3DRS_ZENABLE, D3DZB_FALSE );

		// Edge Aliasing mode disable
		g_pd3dDevice->SetRenderState(D3DRS_EDGEANTIALIAS, TRUE);
		g_pd3dDevice->SetRenderState(D3DRS_MULTISAMPLEANTIALIAS, FALSE);

		g_pd3dDevice->SetRenderState(D3DRS_CULLMODE, D3DCULL_CCW);
	}
	else
	{
		return E_FAIL;
	}

	return S_OK;
}

//-----------------------------------------------------------------------------
// Name: CSolidTexMaterial()
// Desc: Sets initial values of member variables
//-----------------------------------------------------------------------------
CSolidTexMaterial::CSolidTexMaterial() :
	CBaseMaterial()
{
	m_sTexName		= NULL;
	m_nTextureIndex = -1; 
}

//-----------------------------------------------------------------------------
// Name: CSolidTexMaterial()
// Desc: Sets initial values of member variables
//-----------------------------------------------------------------------------
CSolidTexMaterial::CSolidTexMaterial(char *sMatName, int index) :
	CBaseMaterial(sMatName, index)
{
	m_sTexName		= NULL;
	m_nTextureIndex = -1;
}

//-----------------------------------------------------------------------------
// Name: ~CSolidTexMaterial()
// Desc: Performs any needed cleanup before shutting down the object
//-----------------------------------------------------------------------------
CSolidTexMaterial::~CSolidTexMaterial()
{
	if( m_sTexName != NULL )
		delete [] m_sTexName;
}

//-----------------------------------------------------------------------------
// Name: SetTexture()
// Desc: Calls into the texture cache to load a texture for the requested
//		 material
//-----------------------------------------------------------------------------
HRESULT CSolidTexMaterial::SetTexture(char *texFileName)
{
	// Store the texture name in the material so we can request it during setup
	m_sTexName = new char[strlen(texFileName) + 1];
	strcpy(m_sTexName, texFileName);

	return S_OK;
}

//-----------------------------------------------------------------------------
// Name: Setup()
// Desc: Retrieves the texture from the texture cache, and sets up the
//		 appropriate states to render the scene.
//-----------------------------------------------------------------------------
HRESULT CSolidTexMaterial::Setup( DWORD FVF, CTextureCache *pTexCache )
{
	if ( g_pd3dDevice != NULL)
	{
		g_pd3dDevice->SetVertexShader( FVF );

		// set the texture
		IDirect3DBaseTexture8 *pTexture = pTexCache->FindTexture(&m_nTextureIndex, m_sTexName);

		if(pTexture == NULL)	// texture was not found
			return E_FAIL;

		g_pd3dDevice->SetTexture( 0, pTexture );

		// set the material
		g_pd3dDevice->SetMaterial( &m_MaterialDef );

		g_pd3dDevice->SetTextureStageState(0, D3DTSS_ADDRESSU, D3DTADDRESS_WRAP);
		g_pd3dDevice->SetTextureStageState(0, D3DTSS_ADDRESSV, D3DTADDRESS_WRAP);

		g_pd3dDevice->SetTextureStageState(0, D3DTSS_COLOROP, D3DTOP_MODULATE);
		g_pd3dDevice->SetTextureStageState(0, D3DTSS_COLORARG1, D3DTA_DIFFUSE);
		g_pd3dDevice->SetTextureStageState(0, D3DTSS_COLORARG2, D3DTA_TEXTURE);
		g_pd3dDevice->SetTextureStageState(0, D3DTSS_ALPHAOP, D3DTOP_MODULATE);
		g_pd3dDevice->SetTextureStageState(0, D3DTSS_ALPHAARG1, D3DTA_DIFFUSE);
		g_pd3dDevice->SetTextureStageState(0, D3DTSS_ALPHAARG2, D3DTA_TEXTURE);

		g_pd3dDevice->SetRenderState( D3DRS_ZENABLE, D3DZB_FALSE );
		g_pd3dDevice->SetRenderState( D3DRS_CULLMODE, D3DCULL_NONE);

		// Edge Aliasing mode disable
		g_pd3dDevice->SetRenderState(D3DRS_EDGEANTIALIAS, TRUE);
		g_pd3dDevice->SetRenderState(D3DRS_MULTISAMPLEANTIALIAS, FALSE);
	}
	else
	{
		return E_FAIL;
	}

	return S_OK;
}

//-----------------------------------------------------------------------------
// Name: CBackingTexMaterial()
// Desc: Sets initial values of member variables
//-----------------------------------------------------------------------------
CBackingTexMaterial::CBackingTexMaterial() :
	CBaseMaterial()
{
	m_sTexName		= NULL;
	m_nTextureIndex = -1; 
}

//-----------------------------------------------------------------------------
// Name: CBackingTexMaterial()
// Desc: Sets initial values of member variables
//-----------------------------------------------------------------------------
CBackingTexMaterial::CBackingTexMaterial(char *sMatName, int index) :
	CBaseMaterial(sMatName, index)
{
	m_sTexName		= NULL;
	m_nTextureIndex = -1;
}

//-----------------------------------------------------------------------------
// Name: ~CBackingTexMaterial()
// Desc: Performs any needed cleanup before shutting down the object
//-----------------------------------------------------------------------------
CBackingTexMaterial::~CBackingTexMaterial()
{
	if( m_sTexName != NULL )
		delete [] m_sTexName;
}

//-----------------------------------------------------------------------------
// Name: SetTexture()
// Desc: Calls into the texture cache to load a texture for the requested
//		 material
//-----------------------------------------------------------------------------
HRESULT CBackingTexMaterial::SetTexture(char *texFileName)
{
	// Store the texture name in the material so we can request it during setup
	m_sTexName = new char[strlen(texFileName) + 1];
	strcpy(m_sTexName, texFileName);

	return S_OK;
}

//-----------------------------------------------------------------------------
// Name: Setup()
// Desc: Retrieves the texture from the texture cache, and sets up the
//		 appropriate states to render the scene.
//-----------------------------------------------------------------------------
HRESULT CBackingTexMaterial::Setup( DWORD FVF, CTextureCache *pTexCache )
{
	if ( g_pd3dDevice != NULL)
	{
		g_pd3dDevice->SetVertexShader( FVF );

		// set the texture
		IDirect3DBaseTexture8 *pTexture = pTexCache->FindTexture(&m_nTextureIndex, m_sTexName);

		if(pTexture == NULL)	// texture was not found
			return E_FAIL;

		g_pd3dDevice->SetTexture( 0, pTexture );

		// set the material
		g_pd3dDevice->SetMaterial( &m_MaterialDef );

		g_pd3dDevice->SetTextureStageState(0, D3DTSS_ADDRESSV, D3DTADDRESS_WRAP);
		g_pd3dDevice->SetTextureStageState(0, D3DTSS_ALPHAOP, D3DTOP_MODULATE);
		g_pd3dDevice->SetTextureStageState(0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE);
		g_pd3dDevice->SetTextureStageState(0, D3DTSS_ALPHAARG2, D3DTA_TFACTOR);
		g_pd3dDevice->SetTextureStageState(0, D3DTSS_COLOROP, D3DTOP_SELECTARG1);
		g_pd3dDevice->SetTextureStageState(0, D3DTSS_COLORARG1, D3DTA_TFACTOR);
		g_pd3dDevice->SetRenderState(D3DRS_TEXTUREFACTOR, D3DCOLOR_RGBA( 0, 0, 0, 255));

		g_pd3dDevice->SetRenderState( D3DRS_ZENABLE, D3DZB_FALSE );
		g_pd3dDevice->SetRenderState( D3DRS_CULLMODE, D3DCULL_NONE);

		// Edge Aliasing mode disable
		g_pd3dDevice->SetRenderState(D3DRS_EDGEANTIALIAS, FALSE);
		g_pd3dDevice->SetRenderState(D3DRS_MULTISAMPLEANTIALIAS, TRUE);
	}
	else
	{
		return E_FAIL;
	}

	return S_OK;
}

//-----------------------------------------------------------------------------
// Name: CFalloffMaterial()
// Desc: Sets initial values of member variables
//-----------------------------------------------------------------------------
CFalloffMaterial::CFalloffMaterial(char *sMatName, int index) :
	CBaseMaterial(sMatName, index)
{
	m_colorSide  = D3DCOLOR_RGBA(255, 255, 255, 255);
	m_colorFront = D3DCOLOR_RGBA(0, 0, 0, 0,);
}

//-----------------------------------------------------------------------------
// Name: ~CFalloffMaterial()
// Desc: Performs any needed cleanup before shutting down the object
//-----------------------------------------------------------------------------
CFalloffMaterial::~CFalloffMaterial()
{
}

//-----------------------------------------------------------------------------
// Name: SetFalloffColors()
// Desc: Sets the side color/alpha and front color/alpha for the side fade
//		 effect
//-----------------------------------------------------------------------------
void CFalloffMaterial::SetFalloffColors(D3DCOLOR side, D3DCOLOR front)
{
	m_colorSide  = side;
	m_colorFront = front;
}

//-----------------------------------------------------------------------------
// Name: Setup()
// Desc: Sets up the appropriate states to render the material.
//-----------------------------------------------------------------------------
HRESULT CFalloffMaterial::Setup( DWORD FVF, CTextureCache *pTexCache )
{
	if( g_pd3dDevice != NULL )
	{
		g_pd3dDevice->SetTextureStageState(0, D3DTSS_ADDRESSV, D3DTADDRESS_WRAP);
		
		g_pd3dDevice->SetVertexShader(GetEffectShader(1, FVF));
		SetFalloffShaderValues(m_colorSide, m_colorFront);
		SetFalloffShaderFrameValues();	
		
		g_pd3dDevice->SetTextureStageState(0, D3DTSS_COLOROP, D3DTOP_DISABLE);
		g_pd3dDevice->SetTextureStageState(0, D3DTSS_ALPHAOP, D3DTOP_DISABLE);

		g_pd3dDevice->SetRenderState(D3DRS_ALPHABLENDENABLE, 1);
		g_pd3dDevice->SetRenderState(D3DRS_SRCBLEND, D3DBLEND_SRCALPHA);
		g_pd3dDevice->SetRenderState(D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA);

		g_pd3dDevice->SetRenderState(D3DRS_CULLMODE, D3DCULL_NONE);
		g_pd3dDevice->SetRenderState( D3DRS_ZENABLE, D3DZB_FALSE );
   		g_pd3dDevice->SetRenderState( D3DRS_LIGHTING, 0 );

		// Edge Aliasing mode enable
		g_pd3dDevice->SetRenderState(D3DRS_EDGEANTIALIAS, TRUE);
		g_pd3dDevice->SetRenderState(D3DRS_MULTISAMPLEANTIALIAS, FALSE);
	}
	else
	{
		return E_FAIL;
	}
	

	return S_OK;
}

//-----------------------------------------------------------------------------
// Name: CFalloffTexMaterial()
// Desc: Sets initial values of member variables
//-----------------------------------------------------------------------------
CFalloffTexMaterial::CFalloffTexMaterial(char *sMatName, int index) :
	CBaseMaterial(sMatName, index)
{
	m_colorSide  = D3DCOLOR_RGBA(255, 255, 255, 255);
	m_colorFront = D3DCOLOR_RGBA(0, 0, 0, 0,);

	m_sTexName		= NULL;
	m_nTextureIndex = -1;
}

//-----------------------------------------------------------------------------
// Name: ~CFalloffTexMaterial()
// Desc: Performs any needed cleanup before shutting down the object
//-----------------------------------------------------------------------------
CFalloffTexMaterial::~CFalloffTexMaterial()
{
	if( m_sTexName != NULL )
		delete [] m_sTexName;
}

//-----------------------------------------------------------------------------
// Name: SetFalloffColors()
// Desc: Sets the side color/alpha and front color/alpha for the side fade
//		 effect
//-----------------------------------------------------------------------------
void CFalloffTexMaterial::SetFalloffColors(D3DCOLOR side, D3DCOLOR front)
{
	m_colorSide  = side;
	m_colorFront = front;
}

//-----------------------------------------------------------------------------
// Name: SetTexture()
// Desc: Calls into the texture cache to load a texture for the requested
//		 material
//-----------------------------------------------------------------------------
HRESULT CFalloffTexMaterial::SetTexture(char *texFileName)
{
	// Store the texture name in the material so we can request it during setup
	m_sTexName = new char[strlen(texFileName) + 1];
	strcpy(m_sTexName, texFileName);

	return S_OK;
}

//-----------------------------------------------------------------------------
// Name: Setup()
// Desc: Sets up the appropriate states to render the material.
//-----------------------------------------------------------------------------
HRESULT CFalloffTexMaterial::Setup( DWORD FVF, CTextureCache *pTexCache )
{
	if( g_pd3dDevice != NULL )
	{
		SetFalloffShaderFrameValues();

		g_pd3dDevice->SetVertexShader(GetEffectShader(3, FVF));

		// set the texture
		IDirect3DBaseTexture8 *pTexture = pTexCache->FindTexture(&m_nTextureIndex, m_sTexName);

		if(pTexture == NULL)	// texture was not found
			return E_FAIL;

		g_pd3dDevice->SetTexture( 0, pTexture );

		// set the material
		g_pd3dDevice->SetMaterial( &m_MaterialDef );

		g_pd3dDevice->SetTextureStageState(0, D3DTSS_ADDRESSV, D3DTADDRESS_WRAP);
		g_pd3dDevice->SetTextureStageState(0, D3DTSS_ALPHAOP, D3DTOP_MODULATE);
		g_pd3dDevice->SetTextureStageState(0, D3DTSS_ALPHAARG1, D3DTA_DIFFUSE);
		g_pd3dDevice->SetTextureStageState(0, D3DTSS_ALPHAARG2, D3DTA_TEXTURE);
		g_pd3dDevice->SetTextureStageState(0, D3DTSS_COLOROP, D3DTOP_MODULATE);
		g_pd3dDevice->SetTextureStageState(0, D3DTSS_COLORARG1, D3DTA_DIFFUSE);
		g_pd3dDevice->SetTextureStageState(0, D3DTSS_COLORARG2, D3DTA_TEXTURE);
		g_pd3dDevice->SetTextureStageState(0, D3DTSS_TEXCOORDINDEX, 0);

		g_pd3dDevice->SetTextureStageState(1, D3DTSS_ALPHAOP, D3DTOP_DISABLE);
		g_pd3dDevice->SetTextureStageState(1, D3DTSS_COLOROP, D3DTOP_DISABLE);

		g_pd3dDevice->SetTextureStageState(0, D3DTSS_ADDRESSU, D3DTADDRESS_WRAP);
		g_pd3dDevice->SetTextureStageState(0, D3DTSS_ADDRESSV, D3DTADDRESS_WRAP);

//		g_pd3dDevice->SetRenderState( D3DRS_ZENABLE, TRUE ); 
		g_pd3dDevice->SetRenderState( D3DRS_CULLMODE, D3DCULL_NONE);

		// Edge Aliasing mode enable
		g_pd3dDevice->SetRenderState(D3DRS_EDGEANTIALIAS, FALSE);
		g_pd3dDevice->SetRenderState(D3DRS_MULTISAMPLEANTIALIAS, TRUE);
        /*
		g_pd3dDevice->SetRenderState( D3DRS_ZENABLE, D3DZB_FALSE );
		g_pd3dDevice->SetRenderState(D3DRS_ALPHABLENDENABLE, 1);
		g_pd3dDevice->SetRenderState(D3DRS_SRCBLEND, D3DBLEND_SRCALPHA);
		g_pd3dDevice->SetRenderState(D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA);

   		g_pd3dDevice->SetRenderState( D3DRS_LIGHTING, 0 );*/

		SetFalloffShaderValues(m_colorSide, m_colorFront);
	}
	else
	{
		return E_FAIL;
	}

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\xodash\XODashLib\listbox.cpp ===
#define LISTBOX_CPP
/*************************************************************************************************\
listbox.cpp			: Implementation of the listbox component.
Creation Date		: 1/16/2002 12:47:03 PM
Copyright Notice	: (C) 2000 Microsoft
Author				: Heidi Gaertner
//-------------------------------------------------------------------------------------------------
Notes				: 
\*************************************************************************************************/
#include "std.h"
#include "smartobject.h"
#include "tgl.h"
#include "xbInput.h"
#include "XOConst.h"
#include "File.h"

/*************************************************************************************************/
CListBox::CListBox()
{
    m_nCurTextIndex = 0;
    m_pScrollUpButton = NULL;
    m_pScrollDownButton = NULL;
    
}


/*************************************************************************************************/
CListBox::~CListBox()
{
   RemoveAllItems();
    // don't delete these here, their memory is controlled by Primitive Scene
   m_pListButtons.clear();
}

/*************************************************************************************************/
void CListBox::Show( bool bDrawThisObject )
{
    if ( m_pAppearance )
    {
        m_pAppearance->setVisible( bDrawThisObject );
    }

    for ( unsigned long i = 0; i < m_pListButtons.size(); i++ )
    {
        m_pListButtons[i]->Show( bDrawThisObject );
    }        
}

/*************************************************************************************************/
HRESULT CListBox::FrameMove( XBGAMEPAD& GamepadInput, float fElapsedTime )
{
    
 
   	if(GamepadInput.wPressedButtons & XINPUT_GAMEPAD_DPAD_DOWN ||
			GamepadInput.fY1 == -1)
		{
	        // figure out who's currently highlighted.
            int lastButtonIndex = m_pListButtons.size() - 1;
            if ( lastButtonIndex > -1 )
            {
                if ( m_pListButtons[lastButtonIndex]->GetState() == eButtonHighlighted )
                {
                    // is i at the bottom of the list, and we 
                    // need to scroll
                    if ( m_ItemList.size() - m_nCurTextIndex > m_pListButtons.size() )
                    {
                        m_nCurTextIndex++;

                        UpdateText();
                    }
                       
                }
                
            }
        }


	else if(GamepadInput.wPressedButtons & XINPUT_GAMEPAD_DPAD_UP ||
			GamepadInput.fY1 == 1)
		{
		    if ( m_pListButtons.size() &&
                m_pListButtons[0]->GetState() == eButtonHighlighted
                && m_nCurTextIndex > 0 )
            {
                // is i at the bottom of the list, and we 
                // need to scroll
                m_nCurTextIndex --;
               
                UpdateText();
            }
		}


     // hide and show buttons as appropriate
    if ( m_nCurTextIndex == 0 && m_pScrollUpButton)
    {
        m_pScrollUpButton->setVisible( 0 );
    }
    else if ( m_pScrollUpButton )
    {
        m_pScrollUpButton->setVisible( 1 );
    }

    if ( m_ItemList.size() - m_nCurTextIndex > m_pListButtons.size() )
    {
        if ( m_pScrollDownButton )
            m_pScrollDownButton->setVisible( 1 );
    }
    else
    {
        
        if ( m_pScrollDownButton )
            m_pScrollDownButton->setVisible( 0 );
    }


    return S_OK;
    



    
}

void CListBox::UpdateText()
{
     unsigned long curButton = 0;
    // get the iterator to the right place
    TEXT_LIST::iterator iter = m_ItemList.begin();
    TEXT_LIST::iterator helpIter = m_ItemHelpText.begin();

    for ( int i = 0; i < m_nCurTextIndex; i++ )
    {
        iter++;
        helpIter++;
    }
    
    // fill in the buttons with the proper text
    for ( ; iter != m_ItemList.end(), curButton < m_pListButtons.size(); 
        iter++ )
        {
            m_pListButtons[curButton]->SetText( (*iter) );
             m_pListButtons[curButton]->SetHelpText( (*helpIter) );

            curButton++;
        }

}
/*************************************************************************************************/
HRESULT CListBox::SetItemText( unsigned long index, const TCHAR* pText, const TCHAR* pHelpText )
{

    if ( index < m_ItemList.size() )
    {
        TEXT_LIST::iterator iter = m_ItemList.begin();
        for ( unsigned long i = 0; i < index; i++ )
        {
            iter++;
        }
        if ( (*iter ) )
        {
            delete [] *iter;
            (*iter) = NULL;
        }

        if ( pText )
        {
            (*iter) = new TCHAR[_tcslen( pText )+1];
            _tcscpy( (*iter), pText );
        }

        // set the help text

        iter = m_ItemHelpText.begin();
        for ( unsigned long i = 0; i < index; i++ )
        {
            iter++;
        }
        if ( (*iter ) )
        {
            delete [] *iter;
            (*iter) = NULL;
        }

        if ( pHelpText )
        {
            (*iter) = new TCHAR[_tcslen( pHelpText )+1];
            _tcscpy( (*iter), pHelpText );
        }

        // need to find the appropriate button and set that
        if ( m_nCurTextIndex + index < m_pListButtons.size() )
        {
            m_pListButtons[m_nCurTextIndex + index]->SetText( pText );
            m_pListButtons[m_nCurTextIndex + index]->SetHelpText( pHelpText );
        }


        return S_OK;
    }

    return E_FAIL;
}
/*************************************************************************************************/
HRESULT CListBox::RemoveAllItems()
{
    for ( TEXT_LIST::iterator iter = m_ItemList.begin(); 
        iter != m_ItemList.end(); iter ++ )
    {
        if ( (*iter ) )
            delete (*iter);
    }

    m_ItemList.clear();

    for ( iter = m_ItemHelpText.begin(); 
        iter != m_ItemHelpText.end(); iter ++ )
    {
        if ( (*iter ) )
            delete (*iter);
    }

    m_ItemHelpText.clear();

    for ( unsigned long i = 0; i < m_pListButtons.size(); i++ )
    {
        m_pListButtons[i]->Show( 0 );
    } 

    m_nCurTextIndex = 0;
    
    if ( m_pScrollDownButton ) 
        m_pScrollDownButton->setVisible( 0 );
    if ( m_pScrollUpButton )
        m_pScrollUpButton->setVisible( 0 );
    
    return S_OK;
}
/*************************************************************************************************/
HRESULT CListBox::AppendItem( const TCHAR* pText, const TCHAR* pHelpText )
{
    TCHAR* pTextToAdd = NULL;
    if ( pText )
    {
        pTextToAdd = new TCHAR[_tcslen(pText)+1];
        _tcscpy( pTextToAdd, pText );
    }

    m_ItemList.push_back( pTextToAdd );

    // can be NULL I suppose
    TCHAR* pHelpTextToAdd = NULL;
    if ( pHelpText )
    {
        pHelpTextToAdd = new TCHAR[_tcslen(pHelpText)+1];
        _tcscpy( pHelpTextToAdd, pHelpText );
    }

    m_ItemHelpText.push_back( pHelpTextToAdd );

    for ( unsigned long i = 0; i < m_ItemList.size() && i < m_pListButtons.size(); i++ )
    {
        m_pListButtons[i]->Show( 1 );
    }

    if ( m_ItemList.size() <= m_pListButtons.size() )
    {
        m_pListButtons[m_ItemList.size() -1]->SetText( pText );
        m_pListButtons[m_ItemList.size() -1]->SetHelpText( pHelpText );

        if ( m_pAppearance && m_pAppearance->isVisible() )
        {
            m_pListButtons[m_ItemList.size() -1]->Show(1);
        }
    }

    if ( m_ItemList.size() + m_nCurTextIndex > m_pListButtons.size() )
    {
        if ( m_pScrollDownButton )
            m_pScrollDownButton->setVisible( 1 );
    }

    return S_OK;
}
/*************************************************************************************************/ 
HRESULT CListBox::AppendItems( const TCHAR** ppText, const TCHAR** ppHelpText, int count )
{
    for ( int i = 0; i < count; i++ )
    {
        AppendItem( ppText[i], ppHelpText[i] );
    }

    return S_OK;
}

 /*************************************************************************************************/
HRESULT CListBox::LoadFromXBG( File* pFile, TG_Shape* pRoot, CButton** pButtons, unsigned long count )
{

    BYTE shapeID[64];
    pFile->read( shapeID, 64 );

    m_pAppearance = pRoot->FindObject( (char*)shapeID );
    ASSERT( m_pAppearance );


    unsigned char entryCount = pFile->readByte( );
    m_pListButtons.resize( entryCount );

    for ( int i = 0; i < entryCount; i++ )
    {
        unsigned char curButton = pFile->readByte();
        ASSERT( curButton < count );

        if ( ( curButton < count ) )
        {
            m_pListButtons[i] = pButtons[curButton];
            m_pListButtons[i]->Show( 0 ); // hide until we have text attributed
        }
        else
            return E_FAIL;

        m_pScrollUpButton = m_pAppearance->FindObject( "Spinner_Up" );
        m_pScrollDownButton = m_pAppearance->FindObject( "Spinner_Down" );

        ASSERT( m_pScrollUpButton && m_pScrollDownButton );

        if ( m_pScrollUpButton )
            m_pScrollUpButton->setVisible( 0 );

        if ( m_pScrollDownButton )
            m_pScrollDownButton->setVisible( 0 );
    }

    return S_OK;
     
}




//*************************************************************************************************
// end of file ( listbox.cpp )
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\xodash\XODashLib\Inifile.cpp ===
//---------------------------------------------------------------------------
//
// inifile.cpp - This file contains the class declaration for the FitIni Files
//
//				The FitIni file is a ini style file.
//
//	Honor Bound -- FASA Interactive Technologies
//
//	Copyright (c) 1995 FASA Interactive Technologies
//
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
// Include files

#include "std.h"
#ifndef INIFILE_H
#include "inifile.h"
#endif
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <ctype.h>

#include "err.h"

#define strnicmp _strnicmp


//---------------------------------------------------------------------------
// Static Globals
char fitIniHeader[7] = "FITini";
char fitIniFooter[7] = "FITend";

#undef isspace		//Macro Chokes under Intel Compiler!!

//---------------------------------------------------------------------------
// class FitIniFile
FitIniFile::FitIniFile (void) : File()
{
	totalBlocks = 0;
	fileBlocks = NULL;
	
	currentBlockId = NULL;
	currentBlockOffset = 0;
	currentBlockSize = 0;
}

//---------------------------------------------------------------------------
FitIniFile::~FitIniFile (void)
{
	close();
}

//---------------------------------------------------------------------------
long FitIniFile::findNextBlockStart (char *line, unsigned long lineLen)
{
	char thisLine[255];
	char *common = NULL;
	
	do
	{
		if (line)
		{
			readLine((BYTE*)line,lineLen);
			common = line;
		}
		else
		{
			readLine((BYTE*)thisLine,254);
			common = thisLine;
		}
	}
	while(!eof() && (common[0] != '['));
	
	if (eof())
	{
		return(NO_MORE_BLOCKS);
	}

	return(NO_ERR);
}	

//---------------------------------------------------------------------------
long FitIniFile::countBlocks (void)
{
	long count = 0;
	long oldPosition = logicalPosition;
	
	while (findNextBlockStart() != NO_MORE_BLOCKS)
	{
		count++;
	}
	
	//----------------------------------
	// Move back to where we were.
	seek(oldPosition);
	
	return(count);
}

//---------------------------------------------------------------------------
long FitIniFile::getNextWord (char *&line, char *buffer, unsigned long bufLen)
{
	//--------------------------------------------------
	// Check to see if we are at end of line
	if (*line == '\0')
		return(GET_NEXT_LINE);
		
	//--------------------------------------------------
	// Check to see if the rest of the line is comments
	if (*line == '/')
		return(GET_NEXT_LINE);
		
	//------------------------------------------
	// Find start of word from current location
	while ((*line != '\0') && ((*line == ' ') || (*line == '\t') || (*line == ',')))
	{
		line++;
	}
	
	//--------------------------------------------------
	// Check to see if we are at end of line
	if (*line == '\0')
		return(GET_NEXT_LINE);
		
	//--------------------------------------------------
	// Check to see if the rest of the line is comments
	if (*line == '/')
		return(GET_NEXT_LINE);
		
	//-------------------------------------------
	// Find length of word from current location
	char *startOfWord = line;
	unsigned long wordLength = 0;
	while ((*line != '\0') && ((*line != ' ') && (*line != '\t') && (*line != ',')))
	{
		line++;
		wordLength++;
	}
	
	if (wordLength > bufLen)
		return(BUFFER_TOO_SMALL);
		
	strncpy(buffer, startOfWord, wordLength);
	buffer[wordLength] = '\0';
	
	return(NO_ERR);
}

//---------------------------------------------------------------------------
long FitIniFile::afterOpen (void)
{
	char line[255];
	
	//-------------------------------------------------------
	// Check if we opened this with CREATE and write the
	// FITini Header and position to Write Start.
	if (fileMode == CREATE && parent == NULL)
	{
		sprintf(line,"%s \r\n",fitIniHeader);
		write((BYTE*)line,strlen(line));

		totalBlocks = 0;
	}
	else
	{
		//------------------------------------------------------
		// Check if this is a FitIniFile by looking for header.
		char chkHeader[12];
	
		readLine((BYTE*)chkHeader,11);
		if (strstr(chkHeader,fitIniHeader) == NULL)
			return(NOT_A_FITINIFILE);

				//------------------------------------------------------
		// Find out how many blocks we have	
		totalBlocks = countBlocks();
		
		//--------------------------------------------------------------------------
		// Allocate RAM for the BlockInfoNodes.  Check if system Heap is available
		fileBlocks = new IniBlockNode[totalBlocks];
		
		ASSERT(fileBlocks != NULL);

		memset(fileBlocks,0,sizeof(IniBlockNode) * totalBlocks);
		
		//--------------------------------------------------------------------------
		// Put Info into fileBlocks.
		
		unsigned long currentBlockNum = 0;
		while (findNextBlockStart(line,254) != NO_MORE_BLOCKS)
		{
			//----------------------------------------------------
			// If we write too many fileBlocks, we will trash RAM
			// Shouldn't be able to happen but...
			if (currentBlockNum == totalBlocks)
				return(TOO_MANY_BLOCKS);

			long count = 1;
			while (line[count] != ']' && line[count] != '\n')
			{
				fileBlocks[currentBlockNum].blockId[count-1] = line[count];
				count++;
			}
			if (count >= 49)
			{
				ASSERT(("BlockId To large in Fit File %s",fileName));
			}

			if (line[count] == '\n')
			{
				char error[256];
				sprintf( error, "couldn't resolve block %s in file %s", line, getFilename() );
				ASSERT( error );
				return SYNTAX_ERROR;
			}
			
			fileBlocks[currentBlockNum].blockId[count-1] = '\0';
			
			//----------------------------------------------------------------------
			// Since we just read all of last line, we now point to start of data
			fileBlocks[currentBlockNum].blockOffset = logicalPosition;
			currentBlockNum++;
		}

		//------------------------------------------------------
		// If we didn't read in enough, CD-ROM error?
		if (currentBlockNum != totalBlocks)
			return(NOT_ENOUGH_BLOCKS);
	}

	return(NO_ERR);
}

//---------------------------------------------------------------------------
void FitIniFile::atClose (void)
{
	//------------------------------------------------------------
	// Check if we are in create mode and if so, write the footer
	char line[200];
	if (fileMode == CREATE)
	{
		seek(0,SEEK_END);
		sprintf(line,"%s \r\n",fitIniFooter);
		write((BYTE*)line,strlen(line));
	}

	//-----------------------------
	// Free up the fileBlocks
	if ( fileBlocks )
    {
        delete fileBlocks;
    }
	fileBlocks = NULL;
}

//---------------------------------------------------------------------------
float FitIniFile::textToFloat (const char *num)
{
	float result = (float)atof(num);
	return(result);
}

//---------------------------------------------------------------------------
double FitIniFile::textToDouble (const char *num)
{
	double result = atof(num);
	return(result);
}

//---------------------------------------------------------------------------
long FitIniFile::textToLong (const char *num)
{
	long result = 0;
	
	//------------------------------------
	// Check if Hex Number
	char *hexOffset = strstr(num,"0x");
	if (hexOffset == NULL)
	{
		result = atol(num);
	}
	else
	{
		hexOffset += 2;
		long numDigits = strlen(hexOffset)-1;
		for (int i=0; i<=numDigits; i++)
		{
			if (!isalnum(hexOffset[i]) || (isalpha(hexOffset[i]) && toupper(hexOffset[i]) > 'F'))
			{
				hexOffset[i] = 0;	// we've reach a "wrong" character. Either start of a comment or something illegal. Either way, stop evaluation here.
				break;
			}
		}
		numDigits = strlen(hexOffset)-1;
		long power = 0;
		for (long count = numDigits;count >= 0;count--,power++)
		{
			unsigned char currentDigit = (unsigned char)toupper(hexOffset[count]);
			
			if (currentDigit >= 'A' && currentDigit <= 'F')
			{
				result += (currentDigit - 'A' + 10)<<(4*power);
			}
			else if (currentDigit >= '0' && currentDigit <= '9')
			{
				result += (currentDigit - '0')<<(4*power);
			}
			else
			{
				//---------------------------------------------------------
				// There is a digit in here I don't understand.  Return 0.
				result = 0;
				break;
			}
		}
	}

	
	return(result);
}


//---------------------------------------------------------------------------
short FitIniFile::textToShort (const char *num)
{
	short result = 0;
	
	//------------------------------------
	// Check if Hex Number
	char *hexOffset = strstr(num,"0x");
	if (hexOffset == NULL)
	{
		result = (short)atol(num);
	}
	else
	{
		hexOffset += 2;
		long numDigits = strlen(hexOffset)-1;
		for (int i=0; i<=numDigits; i++)
		{
			if (!isalnum(hexOffset[i]) || (isalpha(hexOffset[i]) && toupper(hexOffset[i]) > 'F'))
			{
				hexOffset[i] = 0;	// we've reach a "wrong" character. Either start of a comment or something illegal. Either way, stop evaluation here.
				break;
			}
		}
		numDigits = strlen(hexOffset)-1;
		long power = 0;
		for (long count = numDigits;count >= 0;count--,power++)
		{
			unsigned char currentDigit = (unsigned char)toupper(hexOffset[count]);
			
			if (currentDigit >= 'A' && currentDigit <= 'F')
			{
				result += (currentDigit - 'A' + 10)<<(4*power);
			}
			else if (currentDigit >= '0' && currentDigit <= '9')
			{
				result += (currentDigit - '0')<<(4*power);
			}
			else
			{
				//---------------------------------------------------------
				// There is a digit in here I don't understand.  Return 0.
				result = 0;
				break;
			}
		}
	}
	
	return(result);
}


//---------------------------------------------------------------------------
char FitIniFile::textToChar (const char *num)
{
	char result = 0;
	
	//------------------------------------
	// Check if Hex Number
	char *hexOffset = strstr(num,"0x");
	if (hexOffset == NULL)
	{
		result = (char)atol(num);
	}
	else
	{
		hexOffset += 2;
		long numDigits = strlen(hexOffset)-1;
		for (int i=0; i<=numDigits; i++)
		{
			if (!isalnum(hexOffset[i]) || (isalpha(hexOffset[i]) && toupper(hexOffset[i]) > 'F'))
			{
				hexOffset[i] = 0;	// we've reach a "wrong" character. Either start of a comment or something illegal. Either way, stop evaluation here.
				break;
			}
		}
		numDigits = strlen(hexOffset)-1;
		long power = 0;
		for (long count = numDigits;count >= 0;count--,power++)
		{
			unsigned char currentDigit = (unsigned char)toupper(hexOffset[count]);
			
			if (currentDigit >= 'A' && currentDigit <= 'F')
			{
				result += (currentDigit - 'A' + 10)<<(4*power);
			}
			else if (currentDigit >= '0' && currentDigit <= '9')
			{
				result += (currentDigit - '0')<<(4*power);
			}
			else
			{
				//---------------------------------------------------------
				// There is a digit in here I don't understand.  Return 0.
				result = 0;
				break;
			}
		}
	}
	
	return(result);
}

//---------------------------------------------------------------------------
unsigned long FitIniFile::textToULong (const char *num)
{
	unsigned long result = 0;
	
	//------------------------------------
	// Check if Hex Number
	char *hexOffset = strstr(num,"0x");
	if (hexOffset == NULL)
	{
		result = atol(num);
	}
	else
	{
		hexOffset += 2;
		long numDigits = strlen(hexOffset)-1;
		for (int i=0; i<=numDigits; i++)
		{
			if (!isalnum(hexOffset[i]) || (isalpha(hexOffset[i]) && toupper(hexOffset[i]) > 'F'))
			{
				hexOffset[i] = 0;	// we've reach a "wrong" character. Either start of a comment or something illegal. Either way, stop evaluation here.
				break;
			}
		}
		numDigits = strlen(hexOffset)-1;
		long power = 0;
		for (long count = numDigits;count >= 0;count--,power++)
		{
			unsigned char currentDigit = (unsigned char)toupper(hexOffset[count]);
			
			if (currentDigit >= 'A' && currentDigit <= 'F')
			{
				result += (currentDigit - 'A' + 10)<<(4*power);
			}
			else if (currentDigit >= '0' && currentDigit <= '9')
			{
				result += (currentDigit - '0')<<(4*power);
			}
			else
			{
				//---------------------------------------------------------
				// There is a digit in here I don't understand.  Return 0.
				result = 0;
				break;
			}
		}
	}
	
	return(result);
}


//---------------------------------------------------------------------------
unsigned short FitIniFile::textToUShort (const char *num)
{
	unsigned short result = 0;
	
	//------------------------------------
	// Check if Hex Number
	char *hexOffset = strstr(num,"0x");
	if (hexOffset == NULL)
	{
		result = (short)atol(num);
	}
	else
	{
		hexOffset += 2;
		long numDigits = strlen(hexOffset)-1;
		for (int i=0; i<=numDigits; i++)
		{
			if (!isalnum(hexOffset[i]) || (isalpha(hexOffset[i]) && toupper(hexOffset[i]) > 'F'))
			{
				hexOffset[i] = 0;	// we've reach a "wrong" character. Either start of a comment or something illegal. Either way, stop evaluation here.
				break;
			}
		}
		numDigits = strlen(hexOffset)-1;
		long power = 0;
		for (long count = numDigits;count >= 0;count--,power++)
		{
			unsigned char currentDigit = (unsigned char)toupper(hexOffset[count]);
			
			if (currentDigit >= 'A' && currentDigit <= 'F')
			{
				result += (currentDigit - 'A' + 10)<<(4*power);
			}
			else if (currentDigit >= '0' && currentDigit <= '9')
			{
				result += (currentDigit - '0')<<(4*power);
			}
			else
			{
				//---------------------------------------------------------
				// There is a digit in here I don't understand.  Return 0.
				result = 0;
				break;
			}
		}
	}
	
	return(result);
}


//---------------------------------------------------------------------------
unsigned char FitIniFile::textToUChar (const char *num)
{
	unsigned char result = 0;
	
	//------------------------------------
	// Check if Hex Number
	char *hexOffset = strstr(num,"0x");
	if (hexOffset == NULL)
	{
		result = (unsigned char)atol(num);
	}
	else
	{
		hexOffset += 2;
		long numDigits = strlen(hexOffset)-1;
		for (int i=0; i<=numDigits; i++)
		{
			if (!isalnum(hexOffset[i]) || (isalpha(hexOffset[i]) && toupper(hexOffset[i]) > 'F'))
			{
				hexOffset[i] = 0;	// we've reach a "wrong" character. Either start of a comment or something illegal. Either way, stop evaluation here.
				break;
			}
		}
		numDigits = strlen(hexOffset)-1;
		long power = 0;
		for (long count = numDigits;count >= 0;count--,power++)
		{
			unsigned char currentDigit = (unsigned char)toupper(hexOffset[count]);
			
			if (currentDigit >= 'A' && currentDigit <= 'F')
			{
				result += (currentDigit - 'A' + 10)<<(4*power);
			}
			else if (currentDigit >= '0' && currentDigit <= '9')
			{
				result += (currentDigit - '0')<<(4*power);
			}
			else
			{
				//---------------------------------------------------------
				// There is a digit in here I don't understand.  Return 0.
				result = 0;
				break;
			}
		}
	}
	
	return(result);
}

//---------------------------------------------------------------------------
bool FitIniFile::booleanToLong (const char *num)
{
char testChar = 0;
	while (num[testChar] && isspace(num[testChar]))
		testChar++;

	if ((toupper(num[testChar]) == 'F') || (toupper(num[testChar]) == '0'))
		return FALSE;
	else
		return(TRUE);
}	

//---------------------------------------------------------------------------
long FitIniFile::floatToText (char *result, float num, unsigned long bufLen)
{
	char temp[250];
	sprintf(temp,"%f4",num);

	unsigned long numLength = strlen(temp);
	if (numLength >= bufLen)
		return(BUFFER_TOO_SMALL);

	strncpy(result,temp,numLength);
	result[numLength] = '\0';
	
	return(NO_ERR);
}			

//---------------------------------------------------------------------------
long FitIniFile::longToTextDec (char *result, long num, unsigned long bufLen)
{
	char temp[250];
	sprintf(temp,"%d",num);

	unsigned long numLength = strlen(temp);
	if (numLength >= bufLen)
		return(BUFFER_TOO_SMALL);

	strncpy(result,temp,numLength);
	result[numLength] = '\0';
	
	return(NO_ERR);
}	

//---------------------------------------------------------------------------
long FitIniFile::longToTextHex (char *result, long num, unsigned long bufLen)
{
	char temp[250];
	sprintf(temp,"0x%x",num);

	unsigned long numLength = strlen(temp);
	if (numLength >= bufLen)
		return(BUFFER_TOO_SMALL);

	strncpy(result,temp,numLength);
	result[numLength] = '\0';
	
	return(NO_ERR);
}	

//---------------------------------------------------------------------------
long FitIniFile::shortToTextDec (char *result, short num, unsigned long bufLen)
{
	char temp[250];
	sprintf(temp,"%d",num);

	unsigned long numLength = strlen(temp);
	if (numLength >= bufLen)
		return(BUFFER_TOO_SMALL);

	strncpy(result,temp,numLength);
	result[numLength] = '\0';
	
	return(NO_ERR);
}	

//---------------------------------------------------------------------------
long FitIniFile::shortToTextHex (char *result, short num, unsigned long bufLen)
{
	char temp[250];
	sprintf(temp,"0x%x",num);

	unsigned long numLength = strlen(temp);
	if (numLength >= bufLen)
		return(BUFFER_TOO_SMALL);

	strncpy(result,temp,numLength);
	result[numLength] = '\0';
	
	return(NO_ERR);
}	

//---------------------------------------------------------------------------
long FitIniFile::byteToTextDec (char *result, byte num, unsigned long bufLen)
{
	char temp[250];
	sprintf(temp,"%d",num);

	unsigned long numLength = strlen(temp);
	if (numLength >= bufLen)
		return(BUFFER_TOO_SMALL);

	strncpy(result,temp,numLength);
	result[numLength] = '\0';
	
	return(NO_ERR);
}	

//---------------------------------------------------------------------------
long FitIniFile::byteToTextHex (char *result, byte num, unsigned long bufLen)
{
	char temp[250];
	sprintf(temp,"0x%x",num);

	unsigned long numLength = strlen(temp);
	if (numLength >= bufLen)
		return(BUFFER_TOO_SMALL);

	strncpy(result,temp,numLength);
	result[numLength] = '\0';
	
	return(NO_ERR);
}	

//---------------------------------------------------------------------------
long FitIniFile::open (const char* fName, FileMode _mode, long numChild)
{
	long result = File::open(fName,_mode,numChild);
	if (result != NO_ERR)
		return(result);
		
	seek(0);

	result = afterOpen();
	
	return(result);
}

//---------------------------------------------------------------------------
long FitIniFile::open (File* _parent, unsigned long fileSize, long numChild)
{
	numChild = -1;		//Force all parented FitINIs to load from RAM.
	long result = File::open(_parent,fileSize,numChild);
	if (result != NO_ERR)
		return(result);
		
	result = afterOpen();
	
	return(result);
}

//---------------------------------------------------------------------------
long FitIniFile::create (char* fName)
{
	long result = File::create(fName);
	afterOpen();
	return(result);
}

long FitIniFile::createWithCase( char* fName )
{
	long result = File::createWithCase( fName );
	afterOpen();
	return result;
}

//---------------------------------------------------------------------------
void FitIniFile::close (void)
{
	if (isOpen())
	{
		atClose();
		File::close();
	}
}

//---------------------------------------------------------------------------
long FitIniFile::seekBlock (const char *blockId)
{
	unsigned long blockNum = 0;
	
	while ((blockNum < totalBlocks) && (strcmp(fileBlocks[blockNum].blockId,blockId) != 0))
	{
		blockNum++;
	}
	
	if (blockNum == totalBlocks)
	{
		return(BLOCK_NOT_FOUND);
	}

	//----------------------------------------
	// Block was found, seek to that position
	seek(fileBlocks[blockNum].blockOffset);
	
	//----------------------------------------
	// Setup all current Block Info
	currentBlockId = fileBlocks[blockNum].blockId;
	currentBlockOffset = fileBlocks[blockNum].blockOffset;
	
	blockNum++;
	if (blockNum == totalBlocks)
	{
		currentBlockSize = getLength() - currentBlockOffset;
	}
	else
	{
		currentBlockSize = fileBlocks[blockNum].blockOffset - currentBlockOffset;
	}
		
	return(NO_ERR);
}

//---------------------------------------------------------------------------
long FitIniFile::readIdFloat (const char *varName, float &value)
{
	char line[255];
	char searchString[255];
	
	//--------------------------------
	// Always read from top of Block.
	seek(currentBlockOffset);
	unsigned long endOfBlock = currentBlockOffset+currentBlockSize;
	
	//------------------------
	// Put prefix on varName.
	sprintf(searchString,"f %s",varName);
	
	//--------------------------------
	// Search line by line for varName
	int	testy;
	do
	{
		readLine((BYTE*)line,254);
		testy = strnicmp(line, searchString, strlen(searchString));
		if (testy == 0)
		{
		char* tc = &line[strlen(searchString)];
			while (isspace(*tc))
				tc++;
			if (*tc != '=')
				testy = 1;
		}
	}
	while((testy != 0) && (logicalPosition < endOfBlock));
	
	if (logicalPosition >= endOfBlock)
	{
		value = 0.0;
		return(VARIABLE_NOT_FOUND);
	}
	
	char *equalSign = strstr(line, "=");
	if (equalSign)
	{
		equalSign++;
		value = textToFloat(equalSign);
	}
	else
	{
		return(SYNTAX_ERROR);
	}
	
	return(NO_ERR);
}

//---------------------------------------------------------------------------
long FitIniFile::readIdDouble (const char *varName, double &value)
{
	char line[255];
	char searchString[255];
	
	//--------------------------------
	// Always read from top of Block.
	seek(currentBlockOffset);
	unsigned long endOfBlock = currentBlockOffset+currentBlockSize;
	
	//------------------------
	// Put prefix on varName.
	sprintf(searchString,"f %s",varName);
	
	//--------------------------------
	// Search line by line for varName
	int	testy;
	do
	{
		readLine((BYTE*)line,254);
		testy = strnicmp(line, searchString, strlen(searchString));
		if (testy == 0)
		{
		char* tc = &line[strlen(searchString)];
			while (isspace(*tc))
				tc++;
			if (*tc != '=')
				testy = 1;
		}
	}
	while((testy != 0) && (logicalPosition < endOfBlock));
	
	if (logicalPosition >= endOfBlock)
	{
		value = 0.0;
		return(VARIABLE_NOT_FOUND);
	}
	
	char *equalSign = strstr(line, "=");
	if (equalSign)
	{
		equalSign++;
		value = textToDouble(equalSign);
	}
	else
	{
		return(SYNTAX_ERROR);
	}
	
	return(NO_ERR);
}

//---------------------------------------------------------------------------
long FitIniFile::readIdLong (const char *varName, long &value)
{
	char line[255];
	char searchString[255];
	
	//--------------------------------
	// Always read from top of Block.
	seek(currentBlockOffset);
	unsigned long endOfBlock = currentBlockOffset+currentBlockSize;
	
	//------------------------
	// Put prefix on varName.
	sprintf(searchString,"l %s",varName);
	
	//--------------------------------
	// Search line by line for varName
	int	testy;
	do
	{
		readLine((BYTE*)line,254);
		testy = strnicmp(line, searchString, strlen(searchString));
		if (testy == 0)
		{
		char* tc = &line[strlen(searchString)];
			while (isspace(*tc))
				tc++;
			if (*tc != '=')
				testy = 1;
		}
	}
	while((testy != 0) && (logicalPosition < endOfBlock));
	
	if (logicalPosition >= endOfBlock)
	{
		value = 0;
		return(VARIABLE_NOT_FOUND);
	}
	
	char *equalSign = strstr(line, "=");
	if (equalSign)
	{
		equalSign++;
		value = textToLong(equalSign);
	}
	else
	{
		return(SYNTAX_ERROR);
	}
	
	return(NO_ERR);
}

//---------------------------------------------------------------------------
long FitIniFile::readIdBoolean (const char *varName, bool &value)
{
	char line[255];
	char searchString[255];
	
	//--------------------------------
	// Always read from top of Block.
	seek(currentBlockOffset);
	unsigned long endOfBlock = currentBlockOffset+currentBlockSize;
	
	//------------------------
	// Put prefix on varName.
	sprintf(searchString,"b %s",varName);
	
	//--------------------------------
	// Search line by line for varName
	int	testy;
	do
	{
		readLine((BYTE*)line,254);
		testy = strnicmp(line, searchString, strlen(searchString));
		if (testy == 0)
		{
		char* tc = &line[strlen(searchString)];
			while (isspace(*tc))
				tc++;
			if (*tc != '=')
				testy = 1;
		}
	}
	while((testy != 0) && (logicalPosition < endOfBlock));
	
	if (logicalPosition >= endOfBlock)
	{
		value = 0;
		return(VARIABLE_NOT_FOUND);
	}
	
	char *equalSign = strstr(line, "=");
	if (equalSign)
	{
		equalSign++;
		value = booleanToLong(equalSign);
	}
	else
	{
		return(SYNTAX_ERROR);
	}
	
	return(NO_ERR);
}

//---------------------------------------------------------------------------
long FitIniFile::readIdShort (const char *varName, short &value)
{
	char line[255];
	char searchString[255];
	
	//--------------------------------
	// Always read from top of Block.
	seek(currentBlockOffset);
	unsigned long endOfBlock = currentBlockOffset+currentBlockSize;
	
	//------------------------
	// Put prefix on varName.
	sprintf(searchString,"s %s",varName);
	
	//--------------------------------
	// Search line by line for varName
	int	testy;
	do
	{
		readLine((BYTE*)line,254);
		testy = strnicmp(line, searchString, strlen(searchString));
		if (testy == 0)
		{
		char* tc = &line[strlen(searchString)];
			while (isspace(*tc))
				tc++;
			if (*tc != '=')
				testy = 1;
		}
	}
	while((testy != 0) && (logicalPosition < endOfBlock));
	
	if (logicalPosition >= endOfBlock)
	{
		value = 0;
		return(VARIABLE_NOT_FOUND);
	}
	
	char *equalSign = strstr(line, "=");
	if (equalSign)
	{
		equalSign++;
		value = textToShort(equalSign);
	}
	else
	{
		return(SYNTAX_ERROR);
	}
	
	return(NO_ERR);
}

//---------------------------------------------------------------------------
long FitIniFile::readIdChar (const char *varName, char &value)
{
	char line[255];
	char searchString[255];
	
	//--------------------------------
	// Always read from top of Block.
	seek(currentBlockOffset);
	unsigned long endOfBlock = currentBlockOffset+currentBlockSize;
	
	//------------------------
	// Put prefix on varName.
	sprintf(searchString,"c %s",varName);
	
	//--------------------------------
	// Search line by line for varName
	int	testy;
	do
	{
		readLine((BYTE*)line,254);
		testy = strnicmp(line, searchString, strlen(searchString));
		if (testy == 0)
		{
		char* tc = &line[strlen(searchString)];
			while (isspace(*tc))
				tc++;
			if (*tc != '=')
				testy = 1;
		}
	}
	while((testy != 0) && (logicalPosition < endOfBlock));
	
	if (logicalPosition >= endOfBlock)
	{
		value = 0;
		return(VARIABLE_NOT_FOUND);
	}
	
	char *equalSign = strstr(line, "=");
	if (equalSign)
	{
		equalSign++;
		value = textToChar(equalSign);
	}
	else
	{
		return(SYNTAX_ERROR);
	}
	
	return(NO_ERR);
}

//---------------------------------------------------------------------------
long FitIniFile::readIdULong (const char *varName, unsigned long &value)
{
	char line[255];
	char searchString[255];
	
	//--------------------------------
	// Always read from top of Block.
	seek(currentBlockOffset);
	unsigned long endOfBlock = currentBlockOffset+currentBlockSize;
	
	//------------------------
	// Put prefix on varName.
	sprintf(searchString,"ul %s",varName);
	
	//--------------------------------
	// Search line by line for varName
	int	testy;
	do
	{
		readLine((BYTE*)line,254);
		testy = strnicmp(line, searchString, strlen(searchString));
		if (testy == 0)
		{
			char* tc = &line[strlen(searchString)];
			
			while (isspace(*tc))
				tc++;
				
			if (*tc != '=')
				testy = 1;
		}
	}
	while((testy != 0) && (logicalPosition < endOfBlock));
	
	if (logicalPosition >= endOfBlock)
	{
		value = 0;
		return(VARIABLE_NOT_FOUND);
	}
	
	char *equalSign = strstr(line, "=");
	if (equalSign)
	{
		equalSign++;
		value = textToULong(equalSign);
	}
	else
	{
		return(SYNTAX_ERROR);
	}
	
	return(NO_ERR);
}

//---------------------------------------------------------------------------
long FitIniFile::readIdUShort (const char *varName, unsigned short &value)
{
	char line[255];
	char searchString[255];
	
	//--------------------------------
	// Always read from top of Block.
	seek(currentBlockOffset);
	unsigned long endOfBlock = currentBlockOffset+currentBlockSize;
	
	//------------------------
	// Put prefix on varName.
	sprintf(searchString,"us %s",varName);
	
	//--------------------------------
	// Search line by line for varName
	int	testy;
	do
	{
		readLine((BYTE*)line,254);
		testy = strnicmp(line, searchString, strlen(searchString));
		if (testy == 0)
		{
		char* tc = &line[strlen(searchString)];
			while (isspace(*tc))
				tc++;
			if (*tc != '=')
				testy = 1;
		}
	}
	while((testy != 0) && (logicalPosition < endOfBlock));
	
	if (logicalPosition >= endOfBlock)
	{
		value = 0;
		return(VARIABLE_NOT_FOUND);
	}
	
	char *equalSign = strstr(line, "=");
	if (equalSign)
	{
		equalSign++;
		value = textToUShort(equalSign);
	}
	else
	{
		return(SYNTAX_ERROR);
	}
	
	return(NO_ERR);
}

//---------------------------------------------------------------------------
long FitIniFile::readIdUChar (const char *varName, unsigned char &value)
{
	char line[255];
	char searchString[255];
	
	//--------------------------------
	// Always read from top of Block.
	seek(currentBlockOffset);
	unsigned long endOfBlock = currentBlockOffset+currentBlockSize;
	
	//------------------------
	// Put prefix on varName.
	sprintf(searchString,"uc %s",varName);
	
	//--------------------------------
	// Search line by line for varName
	int	testy;
	do
	{
		readLine((BYTE*)line,254);
		testy = strnicmp(line, searchString, strlen(searchString));
		if (testy == 0)
		{
		char* tc = &line[strlen(searchString)];
			while (isspace(*tc))
				tc++;
			if (*tc != '=')
				testy = 1;
		}
	}
	while((testy != 0) && (logicalPosition < endOfBlock));
	
	if (logicalPosition >= endOfBlock)
	{
		value = 0;
		return(VARIABLE_NOT_FOUND);
	}
	
	char *equalSign = strstr(line, "=");
	if (equalSign)
	{
		equalSign++;
		value = textToUChar(equalSign);
	}
	else
	{
		return(SYNTAX_ERROR);
	}
	
	return(NO_ERR);
}

//---------------------------------------------------------------------------
long FitIniFile::copyString (char *dest, char *src, unsigned long bufLen)
{
	unsigned long offset = 0;
	//---------------------
	// Find starting Quote
	while (*src != '"')
	{
		src++;
	}
	
	src++;		//One more to get to first character past quote.
	
	//---------------------------------------
	// Copy each character until close quote
	while (*src != '"' && offset < bufLen)
	{
		dest[offset] = *src;
		src++;
		offset++;
	}

	//----------------------------------------------------
	// If this string is longer than buffer, let em know.
	if (offset == bufLen)
	{
		return(BUFFER_TOO_SMALL);
	}

	//---------------------------------
	// otherwise, NULL term and return	
	dest[offset] = '\0';
	return(NO_ERR);
}

//---------------------------------------------------------------------------
long FitIniFile::readIdString (const char *varName, char *result, unsigned long bufferSize)
{
	char line[2048];
	char searchString[255];
	
	//--------------------------------
	// Always read from top of Block.
	seek(currentBlockOffset);
	unsigned long endOfBlock = currentBlockOffset+currentBlockSize;
	
	//------------------------
	// Put prefix on varName.
	sprintf(searchString,"st %s",varName);
	
	//--------------------------------
	// Search line by line for varName
	int	testy;
	do
	{
		readLine((BYTE*)line,2047);
		testy = strnicmp(line, searchString, strlen(searchString));
		if (testy == 0)
		{
		char* tc = &line[strlen(searchString)];
			while (isspace(*tc))
				tc++;
			if (*tc != '=')
				testy = 1;
		}
	}
	while((testy != 0) && (logicalPosition < endOfBlock));
	
	if (logicalPosition >= endOfBlock)
	{
		return(VARIABLE_NOT_FOUND);
	}
	
	char *equalSign = strstr(line, "=");
	if (equalSign)
	{
		equalSign++;

		

		char* pFound = NULL;
		char* pFirstEqual = strstr( equalSign, "\"" );
		// strings can span more than one line, make sure there is another equal sign
		if ( pFirstEqual && !strstr( pFirstEqual+1, "\"" ) ) 
		{
			long curLen = strlen( equalSign );
			char tmpLine[2047];
			do
			{
				readLine((BYTE*)tmpLine,2047);
				pFound = strstr( tmpLine, "\"" );

				long addedLen = strlen( tmpLine ) + 1;
				if ( curLen + addedLen < 2048 )
				{
					strcat( equalSign, tmpLine );
					strcat( equalSign, "\n" );
					curLen += addedLen;
				}
				else
					break;

			}while( !pFound && (logicalPosition < endOfBlock) );
		}
		
		long errorCode = copyString(result,equalSign,bufferSize);
		if (errorCode != NO_ERR)
			return(errorCode);
	}
	else
	{
		return(SYNTAX_ERROR);
	}
	
	
	return(NO_ERR);
}

//---------------------------------------------------------------------------
long FitIniFile::getIdStringLength (const char *varName)
{
	char line[255];
	char searchString[255];
	
	//--------------------------------
	// Always read from top of Block.
	seek(currentBlockOffset);
	unsigned long endOfBlock = currentBlockOffset+currentBlockSize;
	
	//------------------------
	// Put prefix on varName.
	sprintf(searchString,"st %s",varName);
	
	//--------------------------------
	// Search line by line for varName
	int	testy;
	do
	{
		readLine((BYTE*)line,254);
		testy = strnicmp(line, searchString, strlen(searchString));
		if (testy == 0)
		{
		char* tc = &line[strlen(searchString)];
			while (isspace(*tc))
				tc++;
			if (*tc != '=')
				testy = 1;
		}
	}
	while((testy != 0) && (logicalPosition < endOfBlock));
	
	if (logicalPosition >= endOfBlock)
	{
		return(VARIABLE_NOT_FOUND);
	}
	
	char *equalSign = strchr(line, '"');
	if (equalSign)
	{
		equalSign++;
		char* end = equalSign;
		while (*end != '"' && *end != 0)
			end++;
		if (*end)
			return (end - equalSign + 1);	// + for terminator
		else
			return(SYNTAX_ERROR);
	}

	return(SYNTAX_ERROR);
}

//---------------------------------------------------------------------------
long FitIniFile::readIdFloatArray (const char *varName, float *result, unsigned long numElements)
{
	char line[255];
	char frontSearch[10];
	char searchString[255];
	
	//--------------------------------
	// Always read from top of Block.
	seek(currentBlockOffset);
	unsigned long endOfBlock = currentBlockOffset+currentBlockSize;
	
	//------------------------------------------------------------------
	// Create two search strings so that we can match any number in []
	sprintf(frontSearch,"f[");
	sprintf(searchString,"] %s",varName);
	
	//--------------------------------
	// Search line by line for varName
	char *fSearch = NULL;
	char *bSearch = NULL;
	
	do
	{
		readLine((BYTE*)line,254);
		
		fSearch = strstr(line,frontSearch);
		bSearch = strstr(line,searchString);
	}
	while(((fSearch == NULL) || (bSearch == NULL)) && (logicalPosition < endOfBlock));
	
	if (logicalPosition >= endOfBlock)
	{
		return(VARIABLE_NOT_FOUND);
	}

	//--------------------------------------
	// Get number of elements in array.
	char elementString[10];
	unsigned long actualElements;
	
	fSearch += 2;												//Move pointer to first number in brackets.
	long numDigits = bSearch - fSearch;

	if (numDigits > 9)
		return(TOO_MANY_ELEMENTS);

	strncpy(elementString,fSearch,numDigits);
	elementString[numDigits] = '\0';
	
	actualElements = textToULong(elementString);	

	if (actualElements > numElements)
		return(USER_ARRAY_TOO_SMALL);
		
	//------------------------------
	// Parse out the elements here.
	char *equalSign = strstr(line, "=");
	unsigned long elementsRead = 0;
	if (equalSign)
	{
		equalSign++; //Move to char past equal sign.

		//--------------------------------------------------------------------------------
		// Now, loop until we reach the end of block or we've read in all of the elements
		while ((logicalPosition < endOfBlock) && (elementsRead < actualElements))
		{
			long errorCode = getNextWord(equalSign,elementString,9);
			if (errorCode == GET_NEXT_LINE)
			{
				readLine((BYTE*)line,254);
				equalSign = line;
				continue;
			}

			if (errorCode != NO_ERR)
			{
				return(errorCode);
			}
			
			result[elementsRead] = textToFloat(elementString);
			elementsRead++;
		}
		
		if (logicalPosition >= endOfBlock && elementsRead < actualElements)
			return(NOT_ENOUGH_ELEMENTS_FOR_ARRAY);
	}
	else
	{
		return(SYNTAX_ERROR);
	}
		
	return(NO_ERR);
}
		
//---------------------------------------------------------------------------
long FitIniFile::readIdLongArray (const char *varName, long *result, unsigned long numElements)
{
	char line[255];
	char frontSearch[10];
	char searchString[255];
	
	//--------------------------------
	// Always read from top of Block.
	seek(currentBlockOffset);
	unsigned long endOfBlock = currentBlockOffset+currentBlockSize;
	
	//------------------------------------------------------------------
	// Create two search strings so that we can match any number in []
	sprintf(frontSearch,"l[");
	sprintf(searchString,"] %s",varName);
	
	//--------------------------------
	// Search line by line for varName
	char *fSearch = NULL;
	char *bSearch = NULL;
	
	do
	{
		readLine((BYTE*)line,254);
		
		fSearch = strstr(line,frontSearch);
		bSearch = strstr(line,searchString);
	}
	while(((fSearch == NULL) || (bSearch == NULL)) && (logicalPosition < endOfBlock));
	
	if (logicalPosition >= endOfBlock)
	{
		return(VARIABLE_NOT_FOUND);
	}

	//--------------------------------------
	// Get number of elements in array.
	char elementString[10];
	unsigned long actualElements;
	
	fSearch += 2;												//Move pointer to first number in brackets.
	long numDigits = bSearch - fSearch;

	if (numDigits > 9)
		return(TOO_MANY_ELEMENTS);

	strncpy(elementString,fSearch,numDigits);
	elementString[numDigits] = '\0';
	
	actualElements = textToULong(elementString);	

	if (actualElements > numElements)
		return(USER_ARRAY_TOO_SMALL);
		
	//------------------------------
	// Parse out the elements here.
	char *equalSign = strstr(line, "=");
	unsigned long elementsRead = 0;
	if (equalSign)
	{
		equalSign++; //Move to char past equal sign.

		//--------------------------------------------------------------------------------
		// Now, loop until we reach the end of block or we've read in all of the elements
		while ((logicalPosition < endOfBlock) && (elementsRead < actualElements))
		{
			long errorCode = getNextWord(equalSign,elementString,9);
			if (errorCode == GET_NEXT_LINE)
			{
				readLine((BYTE*)line,254);
				equalSign = line;
				continue;
			}

			if (errorCode != NO_ERR)
			{
				return(errorCode);
			}
			
			result[elementsRead] = textToLong(elementString);
			elementsRead++;
		}
		
		if (logicalPosition >= endOfBlock && elementsRead < actualElements)
			return(NOT_ENOUGH_ELEMENTS_FOR_ARRAY);
	}
	else
	{
		return(SYNTAX_ERROR);
	}
		
	return(NO_ERR);
}

//---------------------------------------------------------------------------
long FitIniFile::readIdULongArray (const char *varName, unsigned long *result, unsigned long numElements)
{
	char line[255];
	char frontSearch[10];
	char searchString[255];
	
	//--------------------------------
	// Always read from top of Block.
	seek(currentBlockOffset);
	unsigned long endOfBlock = currentBlockOffset+currentBlockSize;
	
	//------------------------------------------------------------------
	// Create two search strings so that we can match any number in []
	sprintf(frontSearch,"ul[");
	sprintf(searchString,"] %s",varName);
	
	//--------------------------------
	// Search line by line for varName
	char *fSearch = NULL;
	char *bSearch = NULL;
	
	do
	{
		readLine((BYTE*)line,254);
		
		fSearch = strstr(line,frontSearch);
		bSearch = strstr(line,searchString);
	}
	while(((fSearch == NULL) || (bSearch == NULL)) && (logicalPosition < endOfBlock));
	
	if (logicalPosition >= endOfBlock)
	{
		return(VARIABLE_NOT_FOUND);
	}

	//--------------------------------------
	// Get number of elements in array.
	char elementString[10];
	unsigned long actualElements;
	
	fSearch += 3;												//Move pointer to first number in brackets.
	long numDigits = bSearch - fSearch;

	if (numDigits > 9)
		return(TOO_MANY_ELEMENTS);

	strncpy(elementString,fSearch,numDigits);
	elementString[numDigits] = '\0';
	
	actualElements = textToULong(elementString);	

	if (actualElements > numElements)
		return(USER_ARRAY_TOO_SMALL);
		
	//------------------------------
	// Parse out the elements here.
	char *equalSign = strstr(line, "=");
	unsigned long elementsRead = 0;
	if (equalSign)
	{
		equalSign++; //Move to char past equal sign.

		//--------------------------------------------------------------------------------
		// Now, loop until we reach the end of block or we've read in all of the elements
		while ((logicalPosition < endOfBlock) && (elementsRead < actualElements))
		{
			long errorCode = getNextWord(equalSign,elementString,9);
			if (errorCode == GET_NEXT_LINE)
			{
				readLine((BYTE*)line,254);
				equalSign = line;
				continue;
			}

			if (errorCode != NO_ERR)
			{
				return(errorCode);
			}
			
			result[elementsRead] = textToULong(elementString);
			elementsRead++;
		}
		
		if (logicalPosition >= endOfBlock && elementsRead < actualElements)
			return(NOT_ENOUGH_ELEMENTS_FOR_ARRAY);
	}
	else
	{
		return(SYNTAX_ERROR);
	}
		
	return(NO_ERR);
}
		
//---------------------------------------------------------------------------
long FitIniFile::readIdShortArray (const char *varName, short *result, unsigned long numElements)
{
	char line[255];
	char frontSearch[10];
	char searchString[255];
	
	//--------------------------------
	// Always read from top of Block.
	seek(currentBlockOffset);
	unsigned long endOfBlock = currentBlockOffset+currentBlockSize;
	
	//------------------------------------------------------------------
	// Create two search strings so that we can match any number in []
	sprintf(frontSearch,"s[");
	sprintf(searchString,"] %s",varName);
	
	//--------------------------------
	// Search line by line for varName
	char *fSearch = NULL;
	char *bSearch = NULL;
	
	do
	{
		readLine((BYTE*)line,254);
		
		fSearch = strstr(line,frontSearch);
		bSearch = strstr(line,searchString);
	}
	while(((fSearch == NULL) || (bSearch == NULL)) && (logicalPosition < endOfBlock));
	
	if (logicalPosition >= endOfBlock)
	{
		return(VARIABLE_NOT_FOUND);
	}

	//--------------------------------------
	// Get number of elements in array.
	char elementString[10];
	unsigned long actualElements;
	
	fSearch += 2;												//Move pointer to first number in brackets.
	long numDigits = bSearch - fSearch;

	if (numDigits > 9)
		return(TOO_MANY_ELEMENTS);

	strncpy(elementString,fSearch,numDigits);
	elementString[numDigits] = '\0';
	
	actualElements = textToULong(elementString);	

	if (actualElements > numElements)
		return(USER_ARRAY_TOO_SMALL);
		
	//------------------------------
	// Parse out the elements here.
	char *equalSign = strstr(line, "=");
	unsigned long elementsRead = 0;
	if (equalSign)
	{
		equalSign++; //Move to char past equal sign.

		//--------------------------------------------------------------------------------
		// Now, loop until we reach the end of block or we've read in all of the elements
		while ((logicalPosition < endOfBlock) && (elementsRead < actualElements))
		{
			long errorCode = getNextWord(equalSign,elementString,9);
			if (errorCode == GET_NEXT_LINE)
			{
				readLine((BYTE*)line,254);
				equalSign = line;
				continue;
			}

			if (errorCode != NO_ERR)
			{
				return(errorCode);
			}
			
			result[elementsRead] = textToShort(elementString);
			elementsRead++;
		}
		
		if (logicalPosition >= endOfBlock && elementsRead < actualElements)
			return(NOT_ENOUGH_ELEMENTS_FOR_ARRAY);
	}
	else
	{
		return(SYNTAX_ERROR);
	}
		
	return(NO_ERR);
}

//---------------------------------------------------------------------------
long FitIniFile::readIdUShortArray (const char *varName, unsigned short *result, unsigned long numElements)
{
	char line[255];
	char frontSearch[10];
	char searchString[255];
	
	//--------------------------------
	// Always read from top of Block.
	seek(currentBlockOffset);
	unsigned long endOfBlock = currentBlockOffset+currentBlockSize;
	
	//------------------------------------------------------------------
	// Create two search strings so that we can match any number in []
	sprintf(frontSearch,"us[");
	sprintf(searchString,"] %s",varName);
	
	//--------------------------------
	// Search line by line for varName
	char *fSearch = NULL;
	char *bSearch = NULL;
	
	do
	{
		readLine((BYTE*)line,254);
		
		fSearch = strstr(line,frontSearch);
		bSearch = strstr(line,searchString);
	}
	while(((fSearch == NULL) || (bSearch == NULL)) && (logicalPosition < endOfBlock));
	
	if (logicalPosition >= endOfBlock)
	{
		return(VARIABLE_NOT_FOUND);
	}

	//--------------------------------------
	// Get number of elements in array.
	char elementString[10];
	unsigned long actualElements;
	
	fSearch += 3;												//Move pointer to first number in brackets.
	long numDigits = bSearch - fSearch;

	if (numDigits > 9)
		return(TOO_MANY_ELEMENTS);

	strncpy(elementString,fSearch,numDigits);
	elementString[numDigits] = '\0';
	
	actualElements = textToULong(elementString);	

	if (actualElements > numElements)
		return(USER_ARRAY_TOO_SMALL);
		
	//------------------------------
	// Parse out the elements here.
	char *equalSign = strstr(line, "=");
	unsigned long elementsRead = 0;
	if (equalSign)
	{
		equalSign++; //Move to char past equal sign.

		//--------------------------------------------------------------------------------
		// Now, loop until we reach the end of block or we've read in all of the elements
		while ((logicalPosition < endOfBlock) && (elementsRead < actualElements))
		{
			long errorCode = getNextWord(equalSign,elementString,9);
			if (errorCode == GET_NEXT_LINE)
			{
				readLine((BYTE*)line,254);
				equalSign = line;
				continue;
			}

			if (errorCode != NO_ERR)
			{
				return(errorCode);
			}
			
			result[elementsRead] = textToUShort(elementString);
			elementsRead++;
		}
		
		if (logicalPosition >= endOfBlock && elementsRead < actualElements)
			return(NOT_ENOUGH_ELEMENTS_FOR_ARRAY);
	}
	else
	{
		return(SYNTAX_ERROR);
	}
		
	return(NO_ERR);
}
		
//---------------------------------------------------------------------------
long FitIniFile::readIdCharArray (const char *varName, char *result, unsigned long numElements)
{
	char line[255];
	char frontSearch[10];
	char searchString[255];
	
	//--------------------------------
	// Always read from top of Block.
	seek(currentBlockOffset);
	unsigned long endOfBlock = currentBlockOffset+currentBlockSize;
	
	//------------------------------------------------------------------
	// Create two search strings so that we can match any number in []
	sprintf(frontSearch,"c[");
	sprintf(searchString,"] %s",varName);
	
	//--------------------------------
	// Search line by line for varName
	char *fSearch = NULL;
	char *bSearch = NULL;
	
	do
	{
		readLine((BYTE*)line,254);
		
		fSearch = strstr(line,frontSearch);
		bSearch = strstr(line,searchString);
	}
	while(((fSearch == NULL) || (bSearch == NULL)) && (logicalPosition < endOfBlock));
	
	if (logicalPosition >= endOfBlock)
	{
		return(VARIABLE_NOT_FOUND);
	}

	//--------------------------------------
	// Get number of elements in array.
	char elementString[10];
	unsigned long actualElements;
	
	fSearch += 2;												//Move pointer to first number in brackets.
	long numDigits = bSearch - fSearch;

	if (numDigits > 9)
		return(TOO_MANY_ELEMENTS);

	strncpy(elementString,fSearch,numDigits);
	elementString[numDigits] = '\0';
	
	actualElements = textToULong(elementString);	

	if (actualElements > numElements)
		return(USER_ARRAY_TOO_SMALL);
		
	//------------------------------
	// Parse out the elements here.
	char *equalSign = strstr(line, "=");
	unsigned long elementsRead = 0;
	if (equalSign)
	{
		equalSign++; //Move to char past equal sign.

		//--------------------------------------------------------------------------------
		// Now, loop until we reach the end of block or we've read in all of the elements
		while ((logicalPosition < endOfBlock) && (elementsRead < actualElements))
		{
			long errorCode = getNextWord(equalSign,elementString,9);
			if (errorCode == GET_NEXT_LINE)
			{
				readLine((BYTE*)line,254);
				equalSign = line;
				continue;
			}

			if (errorCode != NO_ERR)
			{
				return(errorCode);
			}
			
			result[elementsRead] = textToChar(elementString);
			elementsRead++;
		}
		
		if (logicalPosition >= endOfBlock && elementsRead < actualElements)
			return(NOT_ENOUGH_ELEMENTS_FOR_ARRAY);
	}
	else
	{
		return(SYNTAX_ERROR);
	}
		
	return(NO_ERR);
}

//---------------------------------------------------------------------------
long FitIniFile::readIdUCharArray (const char *varName, unsigned char *result, unsigned long numElements)
{
	char line[255];
	char frontSearch[10];
	char searchString[255];
	
	//--------------------------------
	// Always read from top of Block.
	seek(currentBlockOffset);
	unsigned long endOfBlock = currentBlockOffset+currentBlockSize;
	
	//------------------------------------------------------------------
	// Create two search strings so that we can match any number in []
	sprintf(frontSearch,"uc[");
	sprintf(searchString,"] %s",varName);
	
	//--------------------------------
	// Search line by line for varName
	char *fSearch = NULL;
	char *bSearch = NULL;
	
	do
	{
		readLine((BYTE*)line,254);
		
		fSearch = strstr(line,frontSearch);
		bSearch = strstr(line,searchString);
	}
	while(((fSearch == NULL) || (bSearch == NULL)) && (logicalPosition < endOfBlock));
	
	if (logicalPosition >= endOfBlock)
	{
		return(VARIABLE_NOT_FOUND);
	}

	//--------------------------------------
	// Get number of elements in array.
	char elementString[10];
	unsigned long actualElements;
	
	fSearch += 3;												//Move pointer to first number in brackets.
	long numDigits = bSearch - fSearch;

	if (numDigits > 9)
		return(TOO_MANY_ELEMENTS);

	strncpy(elementString,fSearch,numDigits);
	elementString[numDigits] = '\0';
	
	actualElements = textToULong(elementString);	

	if (actualElements > numElements)
		return(USER_ARRAY_TOO_SMALL);
		
	//------------------------------
	// Parse out the elements here.
	char *equalSign = strstr(line, "=");
	unsigned long elementsRead = 0;
	if (equalSign)
	{
		equalSign++; //Move to char past equal sign.

		//--------------------------------------------------------------------------------
		// Now, loop until we reach the end of block or we've read in all of the elements
		while ((logicalPosition < endOfBlock) && (elementsRead < actualElements))
		{
			long errorCode = getNextWord(equalSign,elementString,9);
			if (errorCode == GET_NEXT_LINE)
			{
				readLine((BYTE*)line,254);
				equalSign = line;
				continue;
			}

			if (errorCode != NO_ERR)
			{
				return(errorCode);
			}
			
			result[elementsRead] = textToUChar(elementString);
			elementsRead++;
		}
		
		if (logicalPosition >= endOfBlock && elementsRead < actualElements)
			return(NOT_ENOUGH_ELEMENTS_FOR_ARRAY);
	}
	else
	{
		return(SYNTAX_ERROR);
	}
		
	return(NO_ERR);
}
		
//---------------------------------------------------------------------------
unsigned long FitIniFile::getIdFloatArrayElements (const char *varName)
{
	char line[255];
	char frontSearch[10];
	char searchString[255];
	
	//--------------------------------
	// Always read from top of Block.
	seek(currentBlockOffset);
	unsigned long endOfBlock = currentBlockOffset+currentBlockSize;
	
	//------------------------------------------------------------------
	// Create two search strings so that we can match any number in []
	sprintf(frontSearch,"f[");
	sprintf(searchString,"] %s",varName);
	
	//--------------------------------
	// Search line by line for varName
	char *fSearch = NULL;
	char *bSearch = NULL;
	
	do
	{
		readLine((BYTE*)line,254);
		
		fSearch = strstr(line,frontSearch);
		bSearch = strstr(line,searchString);
	}
	while(((fSearch == NULL) || (bSearch == NULL)) && (logicalPosition < endOfBlock));
	
	if (logicalPosition >= endOfBlock)
	{
		return(VARIABLE_NOT_FOUND);
	}

	//--------------------------------------
	// Get number of elements in array.
	char elementString[10];
	unsigned long actualElements;
	
	fSearch += 2;												//Move pointer to first number in brackets.
	long numDigits = bSearch - fSearch;

	if (numDigits > 9)
		return(TOO_MANY_ELEMENTS);

	strncpy(elementString,fSearch,numDigits);
	elementString[numDigits] = '\0';
	
	actualElements = textToULong(elementString);	
	
	return(actualElements);
}	
	
//---------------------------------------------------------------------------
unsigned long FitIniFile::getIdLongArrayElements (const char *varName)
{
	char line[255];
	char frontSearch[10];
	char searchString[255];
	
	//--------------------------------
	// Always read from top of Block.
	seek(currentBlockOffset);
	unsigned long endOfBlock = currentBlockOffset+currentBlockSize;
	
	//------------------------------------------------------------------
	// Create two search strings so that we can match any number in []
	sprintf(frontSearch,"l[");
	sprintf(searchString,"] %s",varName);
	
	//--------------------------------
	// Search line by line for varName
	char *fSearch = NULL;
	char *bSearch = NULL;
	
	do
	{
		readLine((BYTE*)line,254);
		
		fSearch = strstr(line,frontSearch);
		bSearch = strstr(line,searchString);
	}
	while(((fSearch == NULL) || (bSearch == NULL)) && (logicalPosition < endOfBlock));
	
	if (logicalPosition >= endOfBlock)
	{
		return(VARIABLE_NOT_FOUND);
	}

	//--------------------------------------
	// Get number of elements in array.
	char elementString[10];
	unsigned long actualElements;
	
	fSearch += 2;												//Move pointer to first number in brackets.
	long numDigits = bSearch - fSearch;

	if (numDigits > 9)
		return(TOO_MANY_ELEMENTS);

	strncpy(elementString,fSearch,numDigits);
	elementString[numDigits] = '\0';
	
	actualElements = textToULong(elementString);	
	
	return(actualElements);
}

//---------------------------------------------------------------------------
unsigned long FitIniFile::getIdULongArrayElements (const char *varName)
{
	char line[255];
	char frontSearch[10];
	char searchString[255];
	
	//--------------------------------
	// Always read from top of Block.
	seek(currentBlockOffset);
	unsigned long endOfBlock = currentBlockOffset+currentBlockSize;
	
	//------------------------------------------------------------------
	// Create two search strings so that we can match any number in []
	sprintf(frontSearch,"ul[");
	sprintf(searchString,"] %s",varName);
	
	//--------------------------------
	// Search line by line for varName
	char *fSearch = NULL;
	char *bSearch = NULL;
	
	do
	{
		readLine((BYTE*)line,254);
		
		fSearch = strstr(line,frontSearch);
		bSearch = strstr(line,searchString);
	}
	while(((fSearch == NULL) || (bSearch == NULL)) && (logicalPosition < endOfBlock));
	
	if (logicalPosition >= endOfBlock)
	{
		return(VARIABLE_NOT_FOUND);
	}

	//--------------------------------------
	// Get number of elements in array.
	char elementString[10];
	unsigned long actualElements;
	
	fSearch += 3;												//Move pointer to first number in brackets.
	long numDigits = bSearch - fSearch;

	if (numDigits > 9)
		return(TOO_MANY_ELEMENTS);

	strncpy(elementString,fSearch,numDigits);
	elementString[numDigits] = '\0';
	
	actualElements = textToULong(elementString);	
	
	return(actualElements);
}
											 
//---------------------------------------------------------------------------
unsigned long FitIniFile::getIdShortArrayElements (const char *varName)
{
	char line[255];
	char frontSearch[10];
	char searchString[255];
	
	//--------------------------------
	// Always read from top of Block.
	seek(currentBlockOffset);
	unsigned long endOfBlock = currentBlockOffset+currentBlockSize;
	
	//------------------------------------------------------------------
	// Create two search strings so that we can match any number in []
	sprintf(frontSearch,"s[");
	sprintf(searchString,"] %s",varName);
	
	//--------------------------------
	// Search line by line for varName
	char *fSearch = NULL;
	char *bSearch = NULL;
	
	do
	{
		readLine((BYTE*)line,254);
		
		fSearch = strstr(line,frontSearch);
		bSearch = strstr(line,searchString);
	}
	while(((fSearch == NULL) || (bSearch == NULL)) && (logicalPosition < endOfBlock));
	
	if (logicalPosition >= endOfBlock)
	{
		return(VARIABLE_NOT_FOUND);
	}

	//--------------------------------------
	// Get number of elements in array.
	char elementString[10];
	unsigned long actualElements;
	
	fSearch += 2;												//Move pointer to first number in brackets.
	long numDigits = bSearch - fSearch;

	if (numDigits > 9)
		return(TOO_MANY_ELEMENTS);

	strncpy(elementString,fSearch,numDigits);
	elementString[numDigits] = '\0';
	
	actualElements = textToULong(elementString);	
	
	return(actualElements);
}

//---------------------------------------------------------------------------
unsigned long FitIniFile::getIdUShortArrayElements (const char *varName)
{
	char line[255];
	char frontSearch[10];
	char searchString[255];
	
	//--------------------------------
	// Always read from top of Block.
	seek(currentBlockOffset);
	unsigned long endOfBlock = currentBlockOffset+currentBlockSize;
	
	//------------------------------------------------------------------
	// Create two search strings so that we can match any number in []
	sprintf(frontSearch,"us[");
	sprintf(searchString,"] %s",varName);
	
	//--------------------------------
	// Search line by line for varName
	char *fSearch = NULL;
	char *bSearch = NULL;
	
	do
	{
		readLine((BYTE*)line,254);
		
		fSearch = strstr(line,frontSearch);
		bSearch = strstr(line,searchString);
	}
	while(((fSearch == NULL) || (bSearch == NULL)) && (logicalPosition < endOfBlock));
	
	if (logicalPosition >= endOfBlock)
	{
		return(VARIABLE_NOT_FOUND);
	}

	//--------------------------------------
	// Get number of elements in array.
	char elementString[10];
	unsigned long actualElements;
	
	fSearch += 3;												//Move pointer to first number in brackets.
	long numDigits = bSearch - fSearch;

	if (numDigits > 9)
		return(TOO_MANY_ELEMENTS);

	strncpy(elementString,fSearch,numDigits);
	elementString[numDigits] = '\0';
	
	actualElements = textToULong(elementString);	
	
	return(actualElements);
}

//---------------------------------------------------------------------------
unsigned long FitIniFile::getIdCharArrayElements (const char *varName)
{
	char line[255];
	char frontSearch[10];
	char searchString[255];
	
	//--------------------------------
	// Always read from top of Block.
	seek(currentBlockOffset);
	unsigned long endOfBlock = currentBlockOffset+currentBlockSize;
	
	//------------------------------------------------------------------
	// Create two search strings so that we can match any number in []
	sprintf(frontSearch,"c[");
	sprintf(searchString,"] %s",varName);
	
	//--------------------------------
	// Search line by line for varName
	char *fSearch = NULL;
	char *bSearch = NULL;
	
	do
	{
		readLine((BYTE*)line,254);
		
		fSearch = strstr(line,frontSearch);
		bSearch = strstr(line,searchString);
	}
	while(((fSearch == NULL) || (bSearch == NULL)) && (logicalPosition < endOfBlock));
	
	if (logicalPosition >= endOfBlock)
	{
		return(VARIABLE_NOT_FOUND);
	}

	//--------------------------------------
	// Get number of elements in array.
	char elementString[10];
	unsigned long actualElements;
	
	fSearch += 2;												//Move pointer to first number in brackets.
	long numDigits = bSearch - fSearch;

	if (numDigits > 9)
		return(TOO_MANY_ELEMENTS);

	strncpy(elementString,fSearch,numDigits);
	elementString[numDigits] = '\0';
	
	actualElements = textToULong(elementString);	
	
	return(actualElements);
}

//---------------------------------------------------------------------------
unsigned long FitIniFile::getIdUCharArrayElements (const char *varName)
{
	char line[255];
	char frontSearch[10];
	char searchString[255];
	
	//--------------------------------
	// Always read from top of Block.
	seek(currentBlockOffset);
	unsigned long endOfBlock = currentBlockOffset+currentBlockSize;
	
	//------------------------------------------------------------------
	// Create two search strings so that we can match any number in []
	sprintf(frontSearch,"uc[");
	sprintf(searchString,"] %s",varName);
	
	//--------------------------------
	// Search line by line for varName
	char *fSearch = NULL;
	char *bSearch = NULL;
	
	do
	{
		readLine((BYTE*)line,254);
		
		fSearch = strstr(line,frontSearch);
		bSearch = strstr(line,searchString);
	}
	while(((fSearch == NULL) || (bSearch == NULL)) && (logicalPosition < endOfBlock));
	
	if (logicalPosition >= endOfBlock)
	{
		return(VARIABLE_NOT_FOUND);
	}

	//--------------------------------------
	// Get number of elements in array.
	char elementString[10];
	unsigned long actualElements;
	
	fSearch += 3;												//Move pointer to first number in brackets.
	long numDigits = bSearch - fSearch;

	if (numDigits > 9)
		return(TOO_MANY_ELEMENTS);

	strncpy(elementString,fSearch,numDigits);
	elementString[numDigits] = '\0';
	
	actualElements = textToULong(elementString);	
	
	return(actualElements);
}
	
//---------------------------------------------------------------------------
long FitIniFile::writeBlock (const char *blockId)
{
	char thisLine[255];
	sprintf(thisLine,"\r\n[%s]\r\n",blockId);
	
	long result = write((BYTE*)thisLine,strlen(thisLine));
	return(result);
}

//---------------------------------------------------------------------------
long FitIniFile::writeIdFloat (const char *varName, float value)
{
	char thisLine[255];
	sprintf(thisLine,"f %s = %f\r\n",varName,value);
	
	long result = write((BYTE*)thisLine,strlen(thisLine));
	return(result);
}

//---------------------------------------------------------------------------
long FitIniFile::writeIdBoolean (const char *varName, bool value)
{
	char thisLine[255];
	if (value)
		sprintf(thisLine,"b %s = %s\r\n",varName,"TRUE");
	else
		sprintf(thisLine,"b %s = %s\r\n",varName,"FALSE");
	
	long result = write((BYTE*)thisLine,strlen(thisLine));
	return(result);
}

//---------------------------------------------------------------------------
long FitIniFile::writeIdLong (const char *varName, long value)
{
	char thisLine[255];
	sprintf(thisLine,"l %s = %d\r\n",varName,value);
	
	long result = write((BYTE*)thisLine,strlen(thisLine));
	return(result);
}

//---------------------------------------------------------------------------
long FitIniFile::writeIdShort (const char *varName, short value)
{
	char thisLine[255];
	sprintf(thisLine,"s %s = %d\r\n",varName,value);
	
	long result = write((BYTE*)thisLine,strlen(thisLine));
	return(result);
}

//---------------------------------------------------------------------------
long FitIniFile::writeIdChar (const char *varName, char value)
{
	char thisLine[255];
	sprintf(thisLine,"c %s = %d\r\n",varName,value);
	
	long result = write((BYTE*)thisLine,strlen(thisLine));
	return(result);
}

//---------------------------------------------------------------------------
long FitIniFile::writeIdULong (const char *varName, unsigned long value)
{
	char thisLine[255];
	sprintf(thisLine,"ul %s = %d\r\n",varName,value);
	
	long result = write((BYTE*)thisLine,strlen(thisLine));
	return(result);
}

//---------------------------------------------------------------------------
long FitIniFile::writeIdUShort (const char *varName, unsigned short value)
{
	char thisLine[255];
	sprintf(thisLine,"us %s = %d\r\n",varName,value);
	
	long result = write((BYTE*)thisLine,strlen(thisLine));
	return(result);
}

//---------------------------------------------------------------------------
long FitIniFile::writeIdUChar (const char *varName, unsigned char value)
{
	char thisLine[255];
	sprintf(thisLine,"uc %s = %d\r\n",varName,value);
	
	long result = write((BYTE*)thisLine,strlen(thisLine));
	return(result);
}

//---------------------------------------------------------------------------
long FitIniFile::writeIdString (const char *varName, const char *result)
{
	char thisLine[4096];
	char tmpString[4000];
	memset(tmpString,0,4000);
	strncpy(tmpString,result,3999);

	if (strlen(result) >= 4000)
	{
		ASSERT(("String passed to WriteIdString is longer then 4000 characters"));
	}

	sprintf(thisLine,"st %s = \"%s\"\r\n",varName,result);
	
	long bytesWritten = write((BYTE*)thisLine,strlen(thisLine));
	return(bytesWritten);
}

//---------------------------------------------------------------------------
long FitIniFile::writeIdUShortArray (const char *varName, unsigned short *array, unsigned long numElements)
{
	char thisLine[255];
	sprintf(thisLine,"us[%d] %s = %d,",numElements,varName,array[0]);
	
	long bytesWritten = write((BYTE*)thisLine,strlen(thisLine));

	for (long i=1;i<(long)numElements;i++)
	{
		sprintf(thisLine,"%d,",array[i]);
		bytesWritten += write((BYTE*)thisLine,strlen(thisLine));
	}
	sprintf(thisLine,"\r\n");
	bytesWritten += write((BYTE*)thisLine,strlen(thisLine));

	return (bytesWritten);
}

//---------------------------------------------------------------------------
long FitIniFile::writeIdLongArray (const char *varName, long *array, unsigned long numElements)
{
	char thisLine[255];
	sprintf(thisLine,"l[%d] %s = %d,",numElements,varName,array[0]);
	
	long bytesWritten = write((BYTE*)thisLine,strlen(thisLine));

	for (long i=1;i<(long)numElements;i++)
	{
		sprintf(thisLine,"%d,",array[i]);
		bytesWritten += write((BYTE*)thisLine,strlen(thisLine));
	}
	sprintf(thisLine,"\r\n");
	bytesWritten += write((BYTE*)thisLine,strlen(thisLine));

	return (bytesWritten);
}

//---------------------------------------------------------------------------
long FitIniFile::writeIdFloatArray (const char *varName, float *array, unsigned long numElements)
{
	char thisLine[255];
	sprintf(thisLine,"f[%d] %s = %.2f,",numElements,varName,array[0]);
	
	long bytesWritten = write((BYTE*)thisLine,strlen(thisLine));

	for (long i=1;i<(long)numElements;i++)
	{
		sprintf(thisLine," %.2f,",array[i]);
		bytesWritten += write((BYTE*)thisLine,strlen(thisLine));
	}
	sprintf(thisLine,"\r\n");
	bytesWritten += write((BYTE*)thisLine,strlen(thisLine));

	return (bytesWritten);
}

//---------------------------------------------------------------------------
long FitIniFile::writeIdUCharArray (const char *varName, unsigned char *array, unsigned long numElements)
{
	char thisLine[255];
	sprintf(thisLine,"uc[%d] %s = %d,",numElements,varName,array[0]);
	
	long bytesWritten = write((BYTE*)thisLine,strlen(thisLine));

	for (long i=1;i<(long)numElements;i++)
	{
		sprintf(thisLine," %d,",array[i]);
		bytesWritten += write((BYTE*)thisLine,strlen(thisLine));
	}
	sprintf(thisLine,"\r\n");
	bytesWritten += write((BYTE*)thisLine,strlen(thisLine));

	return (bytesWritten);
}

//---------------------------------------------------------------------------
//
// Edit log
//
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\xodash\XODashLib\material.h ===
//-----------------------------------------------------------------------------
// File: Material.h
//
// Desc: Header file for the main material definition class
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef MATERIAL_H
#define MATERIAL_H

#include "texturecache.h"

// free functions used by this class
void SetFalloffShaderValues(const D3DXCOLOR& sideColor, const D3DXCOLOR& frontColor);
DWORD GetEffectShader(int nEffect, DWORD fvf);
void SetFalloffShaderFrameValues();
void SetReflectShaderFrameValues();

//-----------------------------------------------------------------------------
// Name: class CBaseMaterial
// Desc: Base material class
//-----------------------------------------------------------------------------
class CBaseMaterial
{
public:
	CBaseMaterial();
	CBaseMaterial(char *sMatName, int index);
	virtual ~CBaseMaterial();

	char			*m_sMatName;	// Name of the material
	D3DMATERIAL8	m_MaterialDef;	// D3D material definition (ambient, diffuse, specular)
	int				m_ID;			// index into array where its stored

	void SetName(char *matName);
	void SetAllColors(float r, float g, float b, float a);
	void SetDiffuse(float r, float g, float b, float a);
	void SetAmbient(float r, float g, float b, float a);
	void SetSpecular(float r, float g, float b, float a);
	void SetEmissive(float r, float g, float b, float a);
	void SetPower(float power);
	virtual HRESULT Setup( DWORD FVF, CTextureCache *pTexCache );
    virtual bool    HasTexture() const { return false;}
};

//-----------------------------------------------------------------------------
// Name: class CSolidMaterial
// Desc: Solid material class
//-----------------------------------------------------------------------------
class CSolidTexMaterial : public CBaseMaterial
{
public:
	CSolidTexMaterial();
	CSolidTexMaterial(char *sMatName, int index);
	virtual ~CSolidTexMaterial();
	
	char    *m_sTexName;
	long	m_nTextureIndex;

	HRESULT SetTexture(char *texFileName);
	HRESULT Setup( DWORD FVF, CTextureCache *pTexCache );
    virtual bool    HasTexture() const { return true;}

};

//-----------------------------------------------------------------------------
// Name: class CBackingMaterial
// Desc: Backing material class
//-----------------------------------------------------------------------------
class CBackingTexMaterial : public CBaseMaterial
{
public:
	CBackingTexMaterial();
	CBackingTexMaterial(char *sMatName, int index);
	virtual ~CBackingTexMaterial();
	
	char    *m_sTexName;
	long	m_nTextureIndex;

	HRESULT SetTexture(char *texFileName);
	HRESULT Setup( DWORD FVF, CTextureCache *pTexCache );
    virtual bool    HasTexture() const { return true;}
};

//-----------------------------------------------------------------------------
// Name: class CFalloffMaterial
// Desc: Solid material class
//-----------------------------------------------------------------------------
class CFalloffMaterial : public CBaseMaterial
{
public:
	CFalloffMaterial(char *sMatName, int index);
	virtual ~CFalloffMaterial();

	D3DCOLOR m_colorSide;
	D3DCOLOR m_colorFront;

	void	SetFalloffColors(D3DCOLOR side, D3DCOLOR front);
	HRESULT Setup( DWORD FVF, CTextureCache *pTexCache );
};	

//-----------------------------------------------------------------------------
// Name: class CFalloffTexMaterial
// Desc: Solid material class
//-----------------------------------------------------------------------------
class CFalloffTexMaterial : public CBaseMaterial
{
public:
	CFalloffTexMaterial(char *sMatName, int index);
	virtual ~CFalloffTexMaterial();

	D3DCOLOR m_colorSide;
	D3DCOLOR m_colorFront;

	char	*m_sTexName;
	long	m_nTextureIndex;

	HRESULT SetTexture(char *texFileName);
	void	SetFalloffColors(D3DCOLOR side, D3DCOLOR front);
	HRESULT Setup( DWORD FVF, CTextureCache *pTexCache );
    virtual bool    HasTexture() const { return true;}
};	

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\xodash\XODashLib\materiallibrary.h ===
//-----------------------------------------------------------------------------
// File: MaterialLibrary.h
//
// Desc: Header file for the main material management class
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef MATERIALLIBRARY_H
#define MATERIALLIBRARY_H

#include "material.h"
#include "texturecache.h"
#include "xoconst.h"

enum eMaterialLib
{
	eFlatSurfaces = 0,
	eEggGlow,
	eHilightedType,
	eFlatSurfaces2sided3,
	eIconParts,
	eCellEgg_Parts,
	eGameHilite,
	eCellWallStructure,
	eGamePod,
	eInnerWall_02,
	eDarkenBacking,
	eInnerWall_01,
	eMetal_Chrome,
	eTubes,
	eNavType,
	eShell,
	eFlatSrfc_PodParts,
	eXBoxGreen,
	ePanelBacking_01,
	ePanelBacking_02,
	ePanelBacking_03,
	ePanelBacking_04,
	ePanelBacking_05,
	ePanelBacking_06,
	eCell_Light,
	eMenuCell,
	eWireframe,
	eOuterWall01,
    eredHighlight,
    egreenHighlight,
	eMissingMaterial,

	eNum_Materials
};

#define NUMBER_OF_MATERIALS eNum_Materials

//-----------------------------------------------------------------------------
// Name: class CMaterialLibrary
// Desc: Base material manager class
//-----------------------------------------------------------------------------
class CMaterialLibrary
{
public:
	long				m_nCurrentMat;						  // index of the current material in the array
	CBaseMaterial*		m_pMaterialLib[NUMBER_OF_MATERIALS];  // array of all the available 3D engine materials
	CTextureCache		m_TextureCache;
	
	long				m_nASEentries;	// the number of materials in the current ASE file
	long				*m_pASEtable;	// the conversion table when loading the ASE file

	CMaterialLibrary();
	~CMaterialLibrary();

	HRESULT Initialize( void );
	HRESULT Setup( long index, DWORD FVF );
	HRESULT LoadFromASE( long nMtrlID, BYTE* pBuffer );
	long	ReturnIndex( const long tableIndex );
	long	ReturnIndex( const char *szMatName );
	long	GetButtonTextMaterial( eButtonState curState = (eButtonState)eButtonDefault );
    bool    MaterialUsesTexture( long nMtrlID );
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\xodash\XODashLib\materiallibrary.cpp ===
//-----------------------------------------------------------------------------
// File: MaterialLibrary.cpp
//
// Desc: Classes designed to support the loading and indexing of materials.
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include "std.h"
#include "materiallibrary.h"
#include "utilities.h"

//-----------------------------------------------------------------------------
// Name: CMaterialLibrary()
// Desc: Sets initial values of member variables
//-----------------------------------------------------------------------------
CMaterialLibrary::CMaterialLibrary()
{
	m_nCurrentMat = 0;
	for(long i = 0; i < NUMBER_OF_MATERIALS; i++)
		m_pMaterialLib[i] = NULL;

	m_pASEtable = NULL;
	m_nASEentries = 0;

	// Setup the default materials
	Initialize();
}

//-----------------------------------------------------------------------------
// Name: ~CMaterialLibrary()
// Desc: Performs any needed cleanup before shutting down the object
//-----------------------------------------------------------------------------
CMaterialLibrary::~CMaterialLibrary()
{
	for(long i = 0; i < NUMBER_OF_MATERIALS; i++)
	{
		if ( m_pMaterialLib[i] != NULL )
			delete m_pMaterialLib[i];
	}

	if(m_pASEtable != NULL)
		delete m_pASEtable;
}

//-----------------------------------------------------------------------------
// Name: Initalize()
// Desc: Initalizes the main material library for the Xbox Online Dashboard
//-----------------------------------------------------------------------------
HRESULT CMaterialLibrary::Initialize( void )
{
	m_nCurrentMat = 0;

	//-----------------------------------------------------------
	// Material : FlatSurfaces [0]
	//-----------------------------------------------------------
	m_pMaterialLib[m_nCurrentMat] = new CFalloffMaterial("FlatSurfaces", eFlatSurfaces);
	((CFalloffMaterial*)m_pMaterialLib[m_nCurrentMat])->SetAllColors(1.0f, 1.0f, 1.0f, 1.0f);
	((CFalloffMaterial*)m_pMaterialLib[m_nCurrentMat])->SetFalloffColors(D3DCOLOR_RGBA(243, 255, 107, 192),
								   D3DCOLOR_RGBA(20, 192, 0, 0));
	m_nCurrentMat++;

	//-----------------------------------------------------------
	// Material : EggGlow [1]
	//-----------------------------------------------------------
	m_pMaterialLib[m_nCurrentMat] = new CFalloffMaterial("EggGlow", eEggGlow);
	((CFalloffMaterial*)m_pMaterialLib[m_nCurrentMat])->SetAllColors(1.0f, 1.0f, 1.0f, 1.0f);
	((CFalloffMaterial*)m_pMaterialLib[m_nCurrentMat])->SetFalloffColors(D3DCOLOR_RGBA(252, 255, 0, 0), //side
								 D3DCOLOR_RGBA(254, 255, 188, 228)); //front
	m_nCurrentMat++;

	//-----------------------------------------------------------
	// Material : HilightedType [2]
	//-----------------------------------------------------------
	m_pMaterialLib[m_nCurrentMat] = new CBaseMaterial("HilightedType", eHilightedType);
	m_pMaterialLib[m_nCurrentMat]->SetAllColors(0.0118f, 0.1725f, 0.0f, 1.0f);
	m_nCurrentMat++;

	//-----------------------------------------------------------
	// Material : FlatSurfaces2sided3 [3]
	//-----------------------------------------------------------
	m_pMaterialLib[m_nCurrentMat] = new CFalloffMaterial("FlatSurfaces2sided3", eFlatSurfaces2sided3);
	((CFalloffMaterial*)m_pMaterialLib[m_nCurrentMat])->SetAllColors(1.0f, 1.0f, 1.0f, 1.0f);
	((CFalloffMaterial*)m_pMaterialLib[m_nCurrentMat])->SetFalloffColors(D3DCOLOR_RGBA(243, 255, 107, 255),
								      D3DCOLOR_RGBA(30, 255, 0, 0));
	m_nCurrentMat++;

	//-----------------------------------------------------------
	// Material : IconParts [4]
	//-----------------------------------------------------------
	m_pMaterialLib[m_nCurrentMat] = new CFalloffMaterial("IconParts", eIconParts);
	((CFalloffMaterial*)m_pMaterialLib[m_nCurrentMat])->SetAllColors(1.0f, 1.0f, 1.0f, 1.0f);
	((CFalloffMaterial*)m_pMaterialLib[m_nCurrentMat])->SetFalloffColors(D3DCOLOR_RGBA(191, 255, 107, 192),
								D3DCOLOR_RGBA(0, 255, 18, 0));
	m_nCurrentMat++;

	//-----------------------------------------------------------
	// Material : CellEgg/Parts [5]
	//-----------------------------------------------------------
	m_pMaterialLib[m_nCurrentMat] = new CFalloffMaterial("CellEgg/Parts", eCellEgg_Parts);
	((CFalloffMaterial*)m_pMaterialLib[m_nCurrentMat])->SetAllColors(1.0f, 1.0f, 1.0f, 1.0f);
	((CFalloffMaterial*)m_pMaterialLib[m_nCurrentMat])->SetFalloffColors(D3DCOLOR_RGBA(243, 255, 107, 192),
								   D3DCOLOR_RGBA(30, 255, 0, 0));
	m_nCurrentMat++;

	//-----------------------------------------------------------
	// Material : GameHilite [6]
	//-----------------------------------------------------------
	m_pMaterialLib[m_nCurrentMat] = new CSolidTexMaterial("GameHilite", eGameHilite);
	((CSolidTexMaterial*)m_pMaterialLib[m_nCurrentMat])->SetAllColors(1.0f, 1.0f, 1.0f, 1.0f);
	((CSolidTexMaterial*)m_pMaterialLib[m_nCurrentMat])->SetTexture("GameHilite_01.xbx");
	m_nCurrentMat++;

	//-----------------------------------------------------------
	// Material : CellWallStructure [7]
	//-----------------------------------------------------------
	m_pMaterialLib[m_nCurrentMat] = new CFalloffMaterial("CellWallStructure", eCellWallStructure);
	((CFalloffMaterial*)m_pMaterialLib[m_nCurrentMat])->SetAllColors(1.0f, 1.0f, 1.0f, 1.0f);
	((CFalloffMaterial*)m_pMaterialLib[m_nCurrentMat])->SetFalloffColors(D3DCOLOR_RGBA(191, 255, 107, 51),
								     D3DCOLOR_RGBA(0, 255, 18, 0));
	m_nCurrentMat++;

	//-----------------------------------------------------------
	// Material : GamePod [8]
	//-----------------------------------------------------------
	m_pMaterialLib[m_nCurrentMat] = new CFalloffMaterial("GamePod", eGamePod);
	((CFalloffMaterial*)m_pMaterialLib[m_nCurrentMat])->SetAllColors(1.0f, 1.0f, 1.0f, 1.0f);
	((CFalloffMaterial*)m_pMaterialLib[m_nCurrentMat])->SetFalloffColors(D3DCOLOR_RGBA(243, 255, 107, 192),
							  D3DCOLOR_RGBA(20, 192, 0, 0));
	m_nCurrentMat++;

	//-----------------------------------------------------------
	// Material : InnerWall_02 [9]
	//-----------------------------------------------------------
	m_pMaterialLib[m_nCurrentMat] = new CFalloffTexMaterial("InnerWall_02", eInnerWall_02);
	((CFalloffTexMaterial*)m_pMaterialLib[m_nCurrentMat])->SetAllColors(1.0f, 1.0f, 1.0f, 1.0f);
	((CFalloffTexMaterial*)m_pMaterialLib[m_nCurrentMat])->SetFalloffColors(D3DCOLOR_RGBA(243, 255, 107, 255),
								 D3DCOLOR_RGBA(20, 192, 0, 20));
	((CFalloffTexMaterial*)m_pMaterialLib[m_nCurrentMat])->SetTexture("cellwall.xbx");
	m_nCurrentMat++;

	//-----------------------------------------------------------
	// Material : DarkenBacking [10]
	//-----------------------------------------------------------
	m_pMaterialLib[m_nCurrentMat] = new CBackingTexMaterial("DarkenBacking", eDarkenBacking);
	((CBackingTexMaterial*)m_pMaterialLib[m_nCurrentMat])->SetAllColors(1.0f, 1.0f, 1.0f, 1.0f);
	((CBackingTexMaterial*)m_pMaterialLib[m_nCurrentMat])->SetTexture("panel4.xbx");
	m_nCurrentMat++;

	//-----------------------------------------------------------
	// Material : InnerWall_01 [11]
	//-----------------------------------------------------------
	m_pMaterialLib[m_nCurrentMat] = new CFalloffMaterial("InnerWall_01", eInnerWall_01);
	((CFalloffMaterial*)m_pMaterialLib[m_nCurrentMat])->SetAllColors(1.0f, 1.0f, 1.0f, 1.0f);
	((CFalloffMaterial*)m_pMaterialLib[m_nCurrentMat])->SetFalloffColors(D3DCOLOR_RGBA(243, 255, 107, 255),
								 D3DCOLOR_RGBA(40, 212, 20, 20));
	m_nCurrentMat++;

	//-----------------------------------------------------------
	// Material : Metal_Chrome [12]
	//-----------------------------------------------------------
	m_pMaterialLib[m_nCurrentMat] = new CSolidTexMaterial("Metal_Chrome", eMetal_Chrome);
	((CSolidTexMaterial*)m_pMaterialLib[m_nCurrentMat])->SetAllColors(1.0f, 1.0f, 1.0f, 1.0f);
	((CSolidTexMaterial*)m_pMaterialLib[m_nCurrentMat])->SetTexture("steel.xbx");
	m_nCurrentMat++;

	//-----------------------------------------------------------
	// Material : Tubes [13]
	//-----------------------------------------------------------
	m_pMaterialLib[m_nCurrentMat] = new CFalloffMaterial("Tubes", eTubes);
	((CFalloffMaterial*)m_pMaterialLib[m_nCurrentMat])->SetAllColors(1.0f, 1.0f, 1.0f, 1.0f);
	((CFalloffMaterial*)m_pMaterialLib[m_nCurrentMat])->SetFalloffColors(D3DCOLOR_RGBA(242, 250, 153, 215),
						    D3DCOLOR_RGBA(7, 104, 0, 37));
	m_nCurrentMat++;

	//-----------------------------------------------------------
	// Material : NavType [14]
	//-----------------------------------------------------------
	m_pMaterialLib[m_nCurrentMat] = new CBaseMaterial("NavType", eNavType);
	m_pMaterialLib[m_nCurrentMat]->SetAllColors(0.8667f, 0.8157f, 0.4706f, 1.0f);
	m_nCurrentMat++;

	//-----------------------------------------------------------
	// Material : Shell [15]
	//-----------------------------------------------------------
	m_pMaterialLib[m_nCurrentMat] = new CFalloffMaterial("Shell", eShell);
	((CFalloffMaterial*)m_pMaterialLib[m_nCurrentMat])->SetAllColors(1.0f, 1.0f, 1.0f, 1.0f);
	((CFalloffMaterial*)m_pMaterialLib[m_nCurrentMat])->SetFalloffColors(D3DCOLOR_RGBA(243, 255, 107, 192),
								   D3DCOLOR_RGBA(20, 192, 0, 0));
	m_nCurrentMat++;

	//-----------------------------------------------------------
	// Material : FlatSrfc/PodParts [16]
	//-----------------------------------------------------------
	m_pMaterialLib[m_nCurrentMat] = new CFalloffMaterial("FlatSrfc/PodParts", eFlatSrfc_PodParts);
	((CFalloffMaterial*)m_pMaterialLib[m_nCurrentMat])->SetAllColors(1.0f, 1.0f, 1.0f, 1.0f);
	((CFalloffMaterial*)m_pMaterialLib[m_nCurrentMat])->SetFalloffColors(D3DCOLOR_RGBA(243, 255, 107, 192),
								   D3DCOLOR_RGBA(20, 192, 0, 0));
	m_nCurrentMat++;

	//-----------------------------------------------------------
	// Material : XBoxGreen [17]
	//-----------------------------------------------------------
	m_pMaterialLib[m_nCurrentMat] = new CBaseMaterial("XBoxGreen", eXBoxGreen);
	m_pMaterialLib[m_nCurrentMat]->SetAllColors(0.5451f, 0.7843f, 0.0941f, 1.0f);
	m_nCurrentMat++;

	//-----------------------------------------------------------
	// Material : PanelBacking_01 [18]
	//-----------------------------------------------------------
	m_pMaterialLib[m_nCurrentMat] = new CBackingTexMaterial("PanelBacking_01", ePanelBacking_01);
	((CBackingTexMaterial*)m_pMaterialLib[m_nCurrentMat])->SetAllColors(1.0f, 1.0f, 1.0f, 1.0f);
	((CBackingTexMaterial*)m_pMaterialLib[m_nCurrentMat])->SetTexture("panel6.xbx");
	m_nCurrentMat++;

	//-----------------------------------------------------------
	// Material : PanelBacking_02 [19]
	//-----------------------------------------------------------
	m_pMaterialLib[m_nCurrentMat] = new CBackingTexMaterial("PanelBacking_02", ePanelBacking_02);
	((CBackingTexMaterial*)m_pMaterialLib[m_nCurrentMat])->SetAllColors(1.0f, 1.0f, 1.0f, 1.0f);
	((CBackingTexMaterial*)m_pMaterialLib[m_nCurrentMat])->SetTexture("keyboard_alpha.xbx");
	m_nCurrentMat++;

	//-----------------------------------------------------------
	// Material : PanelBacking_03 [20]
	//-----------------------------------------------------------
	m_pMaterialLib[m_nCurrentMat] = new CBackingTexMaterial("PanelBacking_03", ePanelBacking_03);
	((CBackingTexMaterial*)m_pMaterialLib[m_nCurrentMat])->SetAllColors(1.0f, 1.0f, 1.0f, 1.0f);
	((CBackingTexMaterial*)m_pMaterialLib[m_nCurrentMat])->SetTexture("panel4.xbx");
	m_nCurrentMat++;

	//-----------------------------------------------------------
	// Material : PanelBacking_04 [21]
	//-----------------------------------------------------------
	m_pMaterialLib[m_nCurrentMat] = new CBackingTexMaterial("PanelBacking_04", ePanelBacking_04);
	((CBackingTexMaterial*)m_pMaterialLib[m_nCurrentMat])->SetAllColors(1.0f, 1.0f, 1.0f, 1.0f);
	((CBackingTexMaterial*)m_pMaterialLib[m_nCurrentMat])->SetTexture("panel8.xbx");
	m_nCurrentMat++;

	//-----------------------------------------------------------
	// Material : PanelBacking_05 [22]
	//-----------------------------------------------------------
	m_pMaterialLib[m_nCurrentMat] = new CBackingTexMaterial("PanelBacking_05", ePanelBacking_05);
	((CBackingTexMaterial*)m_pMaterialLib[m_nCurrentMat])->SetAllColors(1.0f, 1.0f, 1.0f, 1.0f);
	((CBackingTexMaterial*)m_pMaterialLib[m_nCurrentMat])->SetTexture("panel2.xbx");
	m_nCurrentMat++;

    //-----------------------------------------------------------
	// Material : PanelBacking_06 [23]
	//-----------------------------------------------------------
	m_pMaterialLib[m_nCurrentMat] = new CBackingTexMaterial("PanelBacking_06", ePanelBacking_06);
	((CBackingTexMaterial*)m_pMaterialLib[m_nCurrentMat])->SetAllColors(1.0f, 1.0f, 1.0f, 1.0f);
	((CBackingTexMaterial*)m_pMaterialLib[m_nCurrentMat])->SetTexture("panel3.xbx");
	m_nCurrentMat++;

	//-----------------------------------------------------------
	// Material : Cell_Light [24]
	//-----------------------------------------------------------
	m_pMaterialLib[m_nCurrentMat] = new CFalloffMaterial("Cell_Light", eCell_Light);
	((CFalloffMaterial*)m_pMaterialLib[m_nCurrentMat])->SetAllColors(1.0f, 1.0f, 1.0f, 1.0f);
	((CFalloffMaterial*)m_pMaterialLib[m_nCurrentMat])->SetFalloffColors(D3DCOLOR_RGBA(243, 255, 107, 192),
								   D3DCOLOR_RGBA(20, 192, 0, 0));
	m_nCurrentMat++;

	//-----------------------------------------------------------
	// Material : MenuCell [25]
	//-----------------------------------------------------------
	m_pMaterialLib[m_nCurrentMat] = new CFalloffMaterial("MenuCell", eMenuCell);
	((CFalloffMaterial*)m_pMaterialLib[m_nCurrentMat])->SetAllColors(1.0f, 1.0f, 1.0f, 1.0f);
	((CFalloffMaterial*)m_pMaterialLib[m_nCurrentMat])->SetFalloffColors(D3DCOLOR_RGBA(243, 255, 107, 192),
								   D3DCOLOR_RGBA(30, 255, 0, 0));
	m_nCurrentMat++;

	//-----------------------------------------------------------
	// Material : wireframe [26]
	//-----------------------------------------------------------
	m_pMaterialLib[m_nCurrentMat] = new CFalloffTexMaterial("wireframe", eWireframe);
	((CFalloffTexMaterial*)m_pMaterialLib[m_nCurrentMat])->SetAllColors(1.0f, 1.0f, 1.0f, 1.0f);
	((CFalloffTexMaterial*)m_pMaterialLib[m_nCurrentMat])->SetFalloffColors(D3DCOLOR_RGBA(243, 255, 107, 255),
								 D3DCOLOR_RGBA(20, 192, 0, 20));
	((CFalloffTexMaterial*)m_pMaterialLib[m_nCurrentMat])->SetTexture("wireframe.xbx");
	m_nCurrentMat++;

	//-----------------------------------------------------------
	// Material : OuterWall01 [27]
	//-----------------------------------------------------------
	m_pMaterialLib[m_nCurrentMat] = new CFalloffMaterial("OuterWall01", eOuterWall01);
	((CFalloffMaterial*)m_pMaterialLib[m_nCurrentMat])->SetAllColors(1.0f, 1.0f, 1.0f, 1.0f);
	((CFalloffMaterial*)m_pMaterialLib[m_nCurrentMat])->SetFalloffColors(D3DCOLOR_RGBA(243, 255, 107, 192),
								   D3DCOLOR_RGBA(30, 255, 0, 0));
	m_nCurrentMat++;

	//-----------------------------------------------------------
	// Material : redHighlight [28]
	//-----------------------------------------------------------
	m_pMaterialLib[m_nCurrentMat] = new CFalloffMaterial("red Highlight", eredHighlight);
	((CFalloffMaterial*)m_pMaterialLib[m_nCurrentMat])->SetAllColors(1.0f, 1.0f, 1.0f, 1.0f);
	((CFalloffMaterial*)m_pMaterialLib[m_nCurrentMat])->SetFalloffColors(D3DCOLOR_RGBA(248, 12, 0, 192),
								   D3DCOLOR_RGBA(235, 105, 0, 0));
	m_nCurrentMat++;

	//-----------------------------------------------------------
	// Material : greenHighlight [29]
	//-----------------------------------------------------------
	m_pMaterialLib[m_nCurrentMat] = new CFalloffMaterial("green Highlight", egreenHighlight);
	((CFalloffMaterial*)m_pMaterialLib[m_nCurrentMat])->SetAllColors(1.0f, 1.0f, 1.0f, 1.0f);
	((CFalloffMaterial*)m_pMaterialLib[m_nCurrentMat])->SetFalloffColors(D3DCOLOR_RGBA(167, 236, 106, 192),
								   D3DCOLOR_RGBA(30, 255, 0, 0));
	m_nCurrentMat++;

	//-----------------------------------------------------------
	// Material : MissingMaterial [30]
	//-----------------------------------------------------------
	m_pMaterialLib[m_nCurrentMat] = new CBaseMaterial("MissingMaterial", eMissingMaterial);
	m_pMaterialLib[m_nCurrentMat]->SetAllColors(1.0f, 1.0f, 1.0f, 1.0f);
	m_nCurrentMat++;

	return S_OK;
}

//-----------------------------------------------------------------------------
// Name: Setup()
// Desc: Setup is called just before the engine passes the polygons up
//		 to the video card for rendering.  Setup will make all of the
//		 appropriate calls to D3D to initalize the rendering enviornment
//		 for the upcoming polys.
//-----------------------------------------------------------------------------
HRESULT CMaterialLibrary::Setup( long index, DWORD FVF )
{
	// make sure index actually exists in our array
	ASSERT((index >= 0) && (index < NUMBER_OF_MATERIALS));
	if (((index < 0) || (index >= NUMBER_OF_MATERIALS)) )
	{
		m_pMaterialLib[NUMBER_OF_MATERIALS - 1]->Setup(FVF, &m_TextureCache);
	}
    else
    {
	    // material index does not exist
	    if(m_pMaterialLib[index] == NULL)
		    return E_FAIL;

	    if(FAILED(m_pMaterialLib[index]->Setup(FVF, &m_TextureCache)))
		    return E_FAIL;
    }

	return S_OK;
}

//-----------------------------------------------------------------------------
// Name: LoadFromASE()
// Desc: Loads the base material library from the ASE file
//-----------------------------------------------------------------------------
HRESULT CMaterialLibrary::LoadFromASE( long nMtrlID, BYTE* pBuffer )
{
	char* Buffer     = (char*)pBuffer;
	char pSearch[256];

	// Pull out the number of materials in the ASE file
	sprintf( pSearch, "*MATERIAL_COUNT " );
	char* pHeader = strstr( Buffer, pSearch );

	char numberData[256];
	GetNumberData( pHeader, numberData );
	m_nASEentries = atol( numberData );

	// make sure our ASE conversion table wasn't allocated for a previous 
	// conversion
	if(NULL != m_pASEtable)
		delete m_pASEtable;

	m_pASEtable = new long[m_nASEentries];

	// Now that we have the material count, go through the list and build
	// a mapping from the ASE materials to our default library
	for(int i = 0; i < m_nASEentries; i++)
	{
		// Get to the correct material index
		sprintf( pSearch, "*MATERIAL %ld", i );
		char* pMaterial = strstr( Buffer, pSearch );

		sprintf( pSearch, "*MATERIAL_NAME" );
		char* pMatNameBuf = strstr( pMaterial, pSearch );

		// Get the material name
		char materialName[256];
		GetNameData( pMatNameBuf, materialName );
		m_pASEtable[i] = ReturnIndex( materialName );
	}

	return S_OK;
}

//-----------------------------------------------------------------------------
// Name: ReturnIndex()
// Desc: Given the name of a material in the ASE library, the function
//	     will return the index in the material library;
//-----------------------------------------------------------------------------
long CMaterialLibrary::ReturnIndex( const char *szMatName )
{
	for(long i = 0; i < NUMBER_OF_MATERIALS; i++)
	{
		if(0 == strcmp( m_pMaterialLib[i]->m_sMatName, szMatName ))
			return i;
	}

	DbgPrint("Material: %s not found in Material Library\n", szMatName);
	ASSERT(false);

	return NUMBER_OF_MATERIALS - 1;
}

//-----------------------------------------------------------------------------
// Name: ReturnIndex()
// Desc: Given the number of the material in the ASE library, the function
//		 will return the index in the material library
//-----------------------------------------------------------------------------
long CMaterialLibrary::ReturnIndex( const long tableIndex )
{
	// make sure index actually exists in our array
	ASSERT((tableIndex >= 0) && (tableIndex < NUMBER_OF_MATERIALS));
	if (((tableIndex > 1) || (tableIndex < NUMBER_OF_MATERIALS)) )
	{
		return m_pASEtable[tableIndex];
	}

	return NUMBER_OF_MATERIALS - 1;
}

//-----------------------------------------------------------------------------
// Name: GetButtonTextMaterial()
// Desc: Returns the material index for a button text object in the scene. 
//-----------------------------------------------------------------------------
long CMaterialLibrary::GetButtonTextMaterial( eButtonState curState )
{
	switch(curState)
	{
	case eButtonDefault:
		return eNavType;
		break;
	case eButtonPressed:
		return eHilightedType;
		break;
	case eButtonHighlighted:
		return eHilightedType;
		break;
	case eButtonDisabled:
		return eNavType;
		break;
    case eButtonStateMax:
		return eHilightedType;
		break;
	default:
		// state of the text in the button is not defined, assert
		ASSERT(true);
		return eNavType;
		break;
	}
}

//-----------------------------------------------------------------------------
// Name: MaterialUsesTexture()
// Desc: Returns wether the given material uses a texture map or not 
//-----------------------------------------------------------------------------
bool    CMaterialLibrary::MaterialUsesTexture( long index )
{
    	// make sure index actually exists in our array
	ASSERT((index >= 0) && (index < NUMBER_OF_MATERIALS));
	if (((index < 0) || (index >= NUMBER_OF_MATERIALS)) )
	{
		return m_pMaterialLib[NUMBER_OF_MATERIALS - 1]->HasTexture();
	}
    else
    {
	    // material index does not exist
	    if(m_pMaterialLib[index] == NULL)
		    return false;

    }

    return (m_pMaterialLib[index]->HasTexture());


}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\xodash\XODashLib\Node.h ===
#pragma once
class Node
{
	virtual HRESULT Initialize() = 0;
	virtual HRESULT Cleanup() = 0;
	virtual HRESULT Advance( float fElapsedTime ) = 0;
	virtual HRESULT Render( DWORD flags ) { return S_OK;}
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\xodash\XODashLib\NetConfig.cpp ===
//-------------------------------------------------------------
// Copyright (c) Microsoft Corporation.  All rights reserved
// Author: Natalyp
//-------------------------------------------------------------
#include "std.h"

#include "NetConfig.h"
#include "globals.h"
#include "Utilities.h"
#include "XOConst.h"


//-------------------------------------------------------------
// Function name	: CIp::DefaultMask
// Description	    : get Default mask for IP address
// Return type		: CIp 
//-------------------------------------------------------------
CIp CIp::DefaultMask() const
{
    if (IsClassA()) return(IP_CLASSA_NETMASK);
    if (IsClassB()) return(IP_CLASSB_NETMASK);
    if (IsClassC()) return(IP_CLASSC_NETMASK);
    if (IsClassD()) return(IP_CLASSD_NETMASK);
    return(0);
}


//-------------------------------------------------------------
// Function name	: CIp::IsValidUnicast
// Description	    : validate the IP address
// Return type		: bool 
//-------------------------------------------------------------
bool CIp::IsValidUnicast() const
{
    return(_dw != 0 && !IsSecure() && !IsBroadcast() && !IsMulticast() && !IsLoopback());
}

// 
TCHAR CNetConfig::m_szResult[];
CNetConfig::CNetConfig(): m_bDirty(true), 
						  m_eCurrentStatus (eCablePending), 
						  m_NetConfigFlags(XNET_STARTUP_BYPASS_SECURITY)
{
}



//----------------------------------------------------------------
// Function name	: CNetConfig::~CNetConfig
// Description	    : 
// Return type		: 
//----------------------------------------------------------------
CNetConfig::~CNetConfig()
{
	Cleanup();
}


//----------------------------------------------------------------
// Function name	: CNetConfig::Cleanup
// Description	    : cleanup all the resources
// Return type		: void 
//----------------------------------------------------------------
void CNetConfig::Cleanup()
{
	if(m_hLogon)
	{
		XOnlineTaskClose(m_hLogon);
	}
	m_hLogon = NULL;
	XOnlineCleanup();
	DbgPrint("XonlineCleanup() called\n");
	XNetCleanup();
}

static const char szStaticIp[] = "STATIC_IP";
static const char szDynamicIp[] = "DYNAMIC_IP";


//-------------------------------------------------------------
// Function name	: CNetConfig::GetValue
// Description	    : 
// Return type		: const TCHAR* 
// Argument         : eButtonId eField - the field a value is required for
//-------------------------------------------------------------
const TCHAR* CNetConfig::GetValue(eButtonId eField)
{
	HRESULT hr = S_OK;
	ZeroMemory(m_szResult, countof(m_szResult));

	do
	{
		if(m_bDirty)
		{
			hr = Initialize();
			BREAKONFAIL(hr, "Fail to retreive network stack state\n");
		}
		switch(eField)
		{
		// NTS_Hostname screen
		case eNTS_HostnameHostname:
			Unicode (m_szResult, m_xNetConfig.achDhcpHostName, countof(m_szResult)-1);
			break;
		case eNTS_HostnameDomainName:
			Unicode (m_szResult, "ASKD", countof(m_szResult)-1);
			break;

		// NTS_PPPoE screen
		case eNTS_PPPoEUserName:
			Unicode (m_szResult, m_xNetConfig.achPppUserName, countof(m_szResult)-1);
			break;
		case eNTS_PPPoEPassword:
			Unicode(m_szResult, m_xNetConfig.achPppPassword, countof(m_szResult)-1);
			break;
		case eNTS_PPPoEServiceName:
			Unicode(m_szResult, m_xNetConfig.achPppServer, countof(m_szResult)-1);
			break;

		// NTS_IP screen
		case eNTS_IPToggle:
		case eNTS_DNSToggle:
			Unicode(m_szResult, m_xNetConfig.bDynamicIp ? szDynamicIp : szStaticIp, countof(m_szResult)-1 );
			break;
		case eNTS_IPIP:
			Unicode(m_szResult, m_xNetConfig.m_szIp, countof(m_szResult)-1);
			break;
		case eNTS_IPSubnet:
			Unicode(m_szResult, m_xNetConfig.m_szSubnet, countof(m_szResult)-1);
			break;
		case eNTS_IPGate:
			Unicode(m_szResult, m_xNetConfig.m_szGateway, countof(m_szResult)-1);
			break;

		//	NTS_DNS	screen
		case eNTS_DNSPrimary:
			Unicode(m_szResult, m_xNetConfig.m_szPrimaryDns, countof(m_szResult)-1);
			break;
		case eNTS_DNSSecondary:
			Unicode(m_szResult, m_xNetConfig.m_szSecondaryDns, countof(m_szResult)-1);
			break;
			// no values to be set for those fields
		case eNTS_HostnameContinue:
		case eNTS_PPPoEContinue:
		case eNTS_DNSContinue:
			break;
		default:
			// requested value is not found
			ASSERT(false);
		}
	}while (0);
	
	//return found value
	return m_szResult;
}


//-------------------------------------------------------------
// Function name	: CNetConfig::SetValue
// Description	    : Set value for a field specified by eField parameter
// Return type		: HRESULT  - indication whether set succeeded or the value is invalid for this field
// Argument         : eButtonId eField
// Argument         : TCHAR* pNewValue
//-------------------------------------------------------------
HRESULT CNetConfig::SetValue(eButtonId eField, TCHAR* pNewValue)
{
	DWORD dwIp = 0;
	HRESULT hr = S_OK;
	do
	{
		if(m_bDirty)
		{
			hr = Initialize();
			BREAKONFAIL(hr, "Fail to retreive network stack state\n");
		}

		switch(eField)
		{
		case eNTS_HostnameHostname:
			hr = ValidateString(pNewValue);
			if(FAILED(hr))
			{
				break;
			}
			ZeroMemory(m_xNetConfig.achDhcpHostName, countof(m_xNetConfig.achDhcpHostName));
			Ansi(m_xNetConfig.achDhcpHostName, pNewValue,  min(_tcslen(pNewValue), countof(m_xNetConfig.achDhcpHostName)-1) );		
			break;
		case eNTS_HostnameDomainName:
			hr = ValidateString(pNewValue);
			if(FAILED(hr))
			{
				break;
			}
			ZeroMemory(m_xNetConfig.achDhcpHostName, countof(m_xNetConfig.achDhcpHostName));
			// TBD ???Ansi(m_xNetConfig.achDhcpHostName, pNewValue,  min(_tcslen(pNewValue)-1, countof(m_xNetConfig.achDhcpHostName)-1) );		
			break;
		// NTS_PPPoE 
		case eNTS_PPPoEUserName:
			hr = ValidateString(pNewValue);
			if(FAILED(hr))
			{
				break;
			}
			ZeroMemory(m_xNetConfig.achPppUserName, countof(m_xNetConfig.achPppUserName));
			Ansi(m_xNetConfig.achPppUserName, pNewValue,  min(_tcslen(pNewValue), countof(m_xNetConfig.achPppUserName)-1) );		
			break;
		case eNTS_PPPoEPassword:
			hr = ValidateString(pNewValue);
			if(FAILED(hr))
			{
				break;
			}

			ZeroMemory(m_xNetConfig.achPppPassword, countof(m_xNetConfig.achPppPassword));
			Ansi(m_xNetConfig.achPppPassword, pNewValue, min(_tcslen(pNewValue), countof(m_xNetConfig.achPppPassword)-1) );		
			break;
		case eNTS_PPPoEServiceName:
			hr = ValidateString(pNewValue);
			if(FAILED(hr))
			{
				break;
			}
			ZeroMemory(m_xNetConfig.achPppServer, countof(m_xNetConfig.achPppServer));
			Ansi(m_xNetConfig.achPppServer, pNewValue, min(_tcslen(pNewValue), countof(m_xNetConfig.achPppServer)-1) );		
			break;

		// NTS_IP
		case eNTS_IPToggle:
			{
			m_xNetConfig.bDynamicIp = !m_xNetConfig.bDynamicIp;
			XNetConfigParams* xncp = (XNetConfigParams*) &m_xNetConfig;
			{
				xncp->ina.s_addr = 0L;
				xncp->inaMask.s_addr = 0L;
				xncp->inaGateway.s_addr = 0L;
			}

			StringFromIP(m_xNetConfig.ina.s_addr, m_xNetConfig.m_szIp);
			StringFromIP(m_xNetConfig.inaMask.s_addr, m_xNetConfig.m_szSubnet);
			StringFromIP(m_xNetConfig.inaGateway.s_addr, m_xNetConfig.m_szGateway);
			}
			break;

		case eNTS_DNSToggle:
			{
			XNetConfigParams* xncp = (XNetConfigParams*) &m_xNetConfig;
			m_xNetConfig.bDynamicIp = !m_xNetConfig.bDynamicIp;
			xncp->inaDnsPrimary.s_addr = 0L;
			xncp->inaDnsSecondary.s_addr = 0L;
			StringFromIP(m_xNetConfig.inaDnsPrimary.s_addr, m_xNetConfig.m_szPrimaryDns);
			StringFromIP(m_xNetConfig.inaDnsSecondary.s_addr, m_xNetConfig.m_szSecondaryDns);
			}
			break;
		case eNTS_IPIP:
			hr = IPFromString(pNewValue, &dwIp);
			if(FAILED(hr))
			{
				break;
			}

			m_xNetConfig.ina.s_addr = dwIp;
			SetIPString(m_xNetConfig.m_szIp, pNewValue);
			break;
		case eNTS_IPSubnet:
			hr = IPFromString(pNewValue, &dwIp);
			if(FAILED(hr))
			{
				break;
			}
			m_xNetConfig.inaMask.s_addr = dwIp;			
			SetIPString(m_xNetConfig.m_szSubnet, pNewValue);
			break;
		case eNTS_IPGate:
			hr = IPFromString(pNewValue, &dwIp);
			if(FAILED(hr))
			{
				break;
			}
			m_xNetConfig.inaGateway.s_addr = dwIp;
			SetIPString(m_xNetConfig.m_szGateway, pNewValue);
			break;

		//	"NTS_DNS"
		case eNTS_DNSPrimary:
			hr = IPFromString(pNewValue, &dwIp);
			if(FAILED(hr))
			{
				break;
			}		
			
			m_xNetConfig.inaDnsPrimary.s_addr = dwIp;
			SetIPString(m_xNetConfig.m_szPrimaryDns, pNewValue);
			break;
		case eNTS_DNSSecondary:
			hr = IPFromString(pNewValue, &dwIp);
			if(FAILED(hr))
			{
				break;
			}		
			m_xNetConfig.inaDnsSecondary.s_addr = dwIp;
			SetIPString(m_xNetConfig.m_szSecondaryDns, pNewValue);
			break;
		default:
			;
		}
	 }while (0);
	return hr;
}




//-------------------------------------------------------------
// Function name	: CNetConfig::Initialize
// Description	    : initialize all internals structures
// Return type		: HRESULT 
//-------------------------------------------------------------
HRESULT CNetConfig::Initialize()
{
	HRESULT hr = S_OK;
	XNetStartupParams xnsp;
	ZeroMemory( &xnsp, sizeof(xnsp) );
	xnsp.cfgSizeOfStruct = sizeof(xnsp);
	xnsp.cfgFlags = m_NetConfigFlags;
 
    XNetStartup( &xnsp );
	g_ResetAutomation = true; // net stack is reset, simulator needs to reset the connection

	XNetLoadConfigParams(&m_xNetConfig);
	StringFromIP(m_xNetConfig.ina.s_addr, m_xNetConfig.m_szIp);
	StringFromIP(m_xNetConfig.inaMask.s_addr, m_xNetConfig.m_szSubnet);
	StringFromIP(m_xNetConfig.inaGateway.s_addr, m_xNetConfig.m_szGateway);
	StringFromIP(m_xNetConfig.inaDnsPrimary.s_addr, m_xNetConfig.m_szPrimaryDns);
	StringFromIP(m_xNetConfig.inaDnsSecondary.s_addr, m_xNetConfig.m_szSecondaryDns);
	
	(0L == m_xNetConfig.ina.s_addr)?	m_xNetConfig.bDynamicIp = true : m_xNetConfig.bDynamicIp = false;
	m_bDirty = false;

	m_eCurrentStatus = eCablePending;
	if(m_hLogon)
	{
		XOnlineTaskClose(m_hLogon);
		m_hLogon = NULL;
	}

	hr = XOnlineStartup(NULL);
	DbgPrint("XOnlineStartup called\n");
	if(FAILED(hr))
	{
		DbgPrint("Failed XOnlineStartup with 0x%x\n", hr);
	} 

	m_NetConfigFlags = XNET_STARTUP_BYPASS_SECURITY;
	m_xNetOrigConfig = m_xNetConfig;
	return hr;
}


//-------------------------------------------------------------
// Function name	: CNetConfig::StringFromIP
// Description	    : Converts an IP Address from a DWORD to a string
// Return type		: void 
// Argument         :  DWORD dwIPAddr
// Argument         : char* szIp
//-------------------------------------------------------------
void CNetConfig::StringFromIP( DWORD dwIPAddr, char* szIp )
{
	ASSERT(szIp);
	if(!szIp)
	{
		return;
	}
	if ( dwIPAddr == 0l )
    {
        strcpy(szIp,"0.0.0.0");
        return ;
    }

	BYTE b4 = (BYTE)( dwIPAddr >> 24 );
	BYTE b3 = (BYTE)( dwIPAddr >> 16 );
	BYTE b2 = (BYTE)( dwIPAddr >> 8 );
	BYTE b1 = (BYTE)dwIPAddr;

	ZeroMemory(szIp, IP_ADDRESS_SIZE + 1);
	_snprintf( szIp, IP_ADDRESS_SIZE , "%d.%d.%d.%d", b1, b2, b3, b4 );
}


//-------------------------------------------------------------
// Function name	: CNetConfig::IPFromString
// Description	    : Converts an Ip address from string to DWORD
// Return type		: HRESULT 
// Argument         : TCHAR* szIP
// Argument         : DWORD* dwIPAddr
//-------------------------------------------------------------
HRESULT CNetConfig::IPFromString(TCHAR* szIP, DWORD* dwIPAddr)
{
	HRESULT hr = S_OK;
	ASSERT(szIP);
	*dwIPAddr = 0L;	

	if(!szIP || (szIP && _tcslen(szIP) > IP_ADDRESS_SIZE))
	{
		return XBAPPERR_INVALIDIP;
	}

   // make a private copy because tsctok modifies the buffer
   static TCHAR szBuf[IP_ADDRESS_SIZE + 1];
   ZeroMemory(szBuf, (IP_ADDRESS_SIZE + 1)*sizeof(TCHAR));
   _tcscpy(szBuf, szIP);
   
   int nDotCount = 0;
   for (TCHAR* pCur = szIP; *pCur!='\0';pCur++)
   {
	   if(*pCur == _T('.'))
	   {
		   nDotCount++;
	   }
   }
   
   if(nDotCount != 3)
   {
		return XBAPPERR_INVALIDIP;	
   }

   TCHAR* token = _tcstok( szBuf, _T(".") );
   int nOctetNum = 0;
   while( token != NULL )
   {
	  if(_tcslen(token) > 3 || !token[0] )
	  {
		return XBAPPERR_INVALIDIP;
	  }
	  unsigned int uNextOctet = _ttoi(token);
	  if (uNextOctet > 255)
	  {
		  return XBAPPERR_INVALIDIP;
	  }
	  *dwIPAddr = uNextOctet<<nOctetNum*8 | *dwIPAddr;

	  /* Get next token: */
      token = _tcstok( NULL, _T("."));
	  nOctetNum++;
   }
   if(nOctetNum != 4)
   {
		*dwIPAddr = 0L;	
		return XBAPPERR_INVALIDIP;
   }

   CIp cTestAddr = *dwIPAddr;
   if(cTestAddr.IsValidUnicast() )
   {
	    return hr;
   }

   return XBAPPERR_INVALIDIP;
}


//-------------------------------------------------------------
// Function name	: CNetConfig::IsEditable
// Description	    : return if the field is allowed to edit. E.g. IP address is not allowed to be changed 
//					  if Dynamic IP is chosen
// Return type		: bool 
// Argument         : eButtonId eField
//-------------------------------------------------------------
bool CNetConfig::IsEditable(eButtonId eField)
{
	switch(eField)
	{
	case eNTS_HostnameHostname:
	case eNTS_HostnameDomainName:
	case eNTS_PPPoEUserName:
	case eNTS_PPPoEPassword:
	case eNTS_PPPoEServiceName:
	case eNTS_IPToggle:
	case eNTS_DNSToggle:
		return true;

	case eNTS_IPIP:
	case eNTS_IPSubnet:
	case eNTS_IPGate:
	case eNTS_DNSPrimary:
	case eNTS_DNSSecondary:
		return !m_xNetConfig.bDynamicIp;
	default:
		ASSERT(false);
		return false;
	}	
}


//-------------------------------------------------------------
// Function name	: CNetConfig::ValidateString
// Description	    : All strings should include ASCII characters in the range of '' and '~'
//					  invalidate everything else
// Return type		: HRESULT 
// Argument         : TCHAR* szValue
//-------------------------------------------------------------
HRESULT CNetConfig::ValidateString(TCHAR* szValue)
{
	HRESULT hr = S_OK;
	if(!szValue)
	{
		return S_OK;
	}
	
	for(size_t i =0; i < _tcslen(szValue); i++)
	{
		if( *(szValue +i) >= _T(' ') && *(szValue +i) < _T('~') ) 
		{
			continue;
		}
		hr = XBAPPERR_INVALIDSTR;
		break;	
	}
	return hr;
}




//-------------------------------------------------------------
// Function name	: CNetConfig::CheckNetworkState
// Description	    : This is the main function that calls all appropriate APIs and sets the status 
//					  according to the return from APIs result
// Return type		: eNetworkState 
//-------------------------------------------------------------
eNetworkState CNetConfig::CheckNetworkStatus()
{
	HRESULT hr = S_OK;
	if(m_bDirty)
	{
		hr = Initialize();
		if(FAILED(hr))
		{
			DbgPrint("CNetConfig::GetNetworkState - failed to initialize the stack - hr=0x%x\n", hr);
			m_eCurrentStatus = eIPFail;
			return m_eCurrentStatus;
		}

	}

	switch (m_eCurrentStatus)
	{
	case eCablePending:
	case eCableFail:
		{
			DWORD dwStatus = XNetGetEthernetLinkStatus();
			(dwStatus & XNET_ETHERNET_LINK_ACTIVE ) != 0 ? m_eCurrentStatus = eCablePass : m_eCurrentStatus = eCableFail;	
		}
	break;
	case eCablePass:
		GetIp();
		break;
// do nothing 
	case eIPFail:
	case eDNSFail:
	case eServiceFail:
	case eDone:
		break;
	case eIPPass:
		CheckServiceStatus();
		break;
	default:
		// why I'm here ? 
		ASSERT(false);
	}
 	return m_eCurrentStatus;
}



//-------------------------------------------------------------
// Function name	: CNetConfig::CheckServiceStatus
// Description	    : verify connectivity with the DataCenter
// Return type		: void 
//-------------------------------------------------------------
eNetworkState CNetConfig::CheckServiceStatus()
{
	HRESULT hr = S_OK;
	if(m_bDirty)
	{
		hr = Initialize();
		if(FAILED(hr))
		{
			DbgPrint("CNetConfig::CheckServiceStatus - failed to initialize the stack - hr=0x%x\n", hr);
			m_eCurrentStatus = eIPFail;
			return m_eCurrentStatus;
		}
	}
	if(!m_hLogon)
	{
    // need to log onto all of our services here
        DWORD serviceIDs[] = {XONLINE_USER_ACCOUNT_SERVICE,
							  XONLINE_BILLING_OFFERING_SERVICE};
		
		XONLINE_USER Users[XONLINE_MAX_LOGON_USERS];
		ZeroMemory( Users, sizeof( Users ) );

		hr = XOnlineLogon( Users, serviceIDs, countof(serviceIDs), NULL,  &m_hLogon );
	}
	else
	{
		ASSERT(m_hLogon);
		if(!m_hLogon)
		{
			m_eCurrentStatus = eServiceFail;
			return m_eCurrentStatus;
		}
		hr =XOnlineTaskContinue( m_hLogon );
		switch(hr)
		{
		case XONLINE_E_LOGON_DNS_LOOKUP_FAILED :
		case XONLINE_E_LOGON_NO_IP_ADDRESS:
		case XONLINE_E_LOGON_NO_DNS_SERVICE:
		case XONLINE_E_LOGON_DNS_LOOKUP_TIMEDOUT:
			m_eCurrentStatus = eDNSFail;
			break;

		case XONLINETASK_S_RUNNING:
//			DbgPrint("CNetConfig::GetNetworkState() - pumping\n");
			break;


		case XONLINE_S_LOGON_CONNECTION_ESTABLISHED:
			m_eCurrentStatus = eDone;
 			break;
		
		default:
			m_eCurrentStatus = eServiceFail;
			DbgPrint("CNetConfig::CheckConnectivity, XOnlineLogon fail hr = 0x%x\n", hr);
			break;
			
		}
	}
	return m_eCurrentStatus;
}

//-------------------------------------------------------------
// Function name	: CNetConfig::GetIp
// Description	    : acquire IP, save settings to disk if IP has been obtained successfully
// Return type		: void 
//-------------------------------------------------------------
void CNetConfig::GetIp()
{
	XNetConfigParams* xncp = (XNetConfigParams*) &m_xNetConfig;
	INT err = XNetConfig(xncp, XNET_CONFIG_NORMAL);
	err? m_eCurrentStatus = eIPFail : m_eCurrentStatus = eIPPass;	
	if(m_eCurrentStatus != eIPPass)
	{
		DbgPrint("CNetConfig::GetIp - failed to obtain IP, res = %d\n",err);
	}
}


//-------------------------------------------------------------
// Function name	: CNetConfig::SetIPString
// Description	    : Set IP string for the pDest field
// Return type		: void 
// Argument         : char* pDest
// Argument         : const TCHAR* pSource
//-------------------------------------------------------------
void CNetConfig::SetIPString(char* pDest, const TCHAR* pSource)
{
	ASSERT(pDest && pSource && _tcslen(pSource) <= IP_ADDRESS_SIZE + 1 );
	if(!pDest || !pSource || (pSource && _tcslen(pSource) > IP_ADDRESS_SIZE + 1))
	{
		return;
	}

	ZeroMemory(pDest, IP_ADDRESS_SIZE + 1);
	Ansi(pDest, pSource,  _tcslen(pSource) );		
}


//-------------------------------------------------------------
// Function name	: CNetConfig::SaveConfig
// Description	    : save new configuration to the hard drive
// Return type		: void 
//-------------------------------------------------------------
void CNetConfig::SaveConfig()
{
	if(m_bDirty)
	{
		HRESULT hr = Initialize();
		if (FAILED(hr))
		{
			DbgPrint("CNetConfig::SaveConfig - fail to init the net stack\n");
		}

	}
	XNetConfigParams* xncp = (XNetConfigParams*) &m_xNetConfig;
	XNetSaveConfigParams(xncp);	
}


//-------------------------------------------------------------
// Function name	: CNetConfig::RestoreConfig
// Description	    : revert configuration to the presious one. 
//					  When user hit cancel from the Settings screen, 
//                    the previous settings are restored
// Return type		: void 
//-------------------------------------------------------------
void CNetConfig::RestoreConfig()
{
	m_xNetConfig = m_xNetOrigConfig;
}


//-------------------------------------------------------------
// Function name	: CNetConfig::ResetNetworkState
// Description	    : reset network state, network discovery process
//                    will be restarted next time GetNetworkStatus is called  
// Return type		: void 
//-------------------------------------------------------------
void CNetConfig::ResetNetworkState() 
{
	m_eCurrentStatus = eCablePending;
	DbgPrint("CNetConfig::ResetNetworkState() - network state is set to eCablePending\n");
	Cleanup();
	m_bDirty = true;
	// restart the stack and troubleshoot the network problems
	m_NetConfigFlags = XNET_STARTUP_BYPASS_SECURITY | XNET_STARTUP_MANUAL_CONFIG;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\xodash\XODashLib\msgdialog.h ===
#pragma once
/*************************************************************************************************\
CMsgDialog.h		: Interface for the CMsgDialog component.  This is the standard OK/YES/No dlg 
                        for the dash.  There are easy to use global functions to make these 
                        objects in Globals.h
Creation Date		: 1/8/2002 11:08:29 AM
Copyright Notice	: (C) 2000 Microsoft
Author				: Heidi Gaertner
//-------------------------------------------------------------------------------------------------
Notes				: 
\*************************************************************************************************/

#include "PrimitiveScene.h"
#include "tgl.h"
#include "XBInput.h"

//*************************************************************************************************

/**************************************************************************************************
CLASS DESCRIPTION
CMsgDialog:
**************************************************************************************************/
// progress functions need to pass back the float  a value between 0 and 1 to display progress
// the returned HRESULT determines wether the called function succeeded or failed
typedef HRESULT (*ProgressFunction)(float*);
typedef HRESULT (*WaitFunction)();

class TG_Shape;







struct MSGPARAMETERS
{
    eSceneId        m_SceneID;
    const TCHAR*    m_pStrMessageID; // text in the panel
    const TCHAR*    m_pStrYesID; // set these ID's to NULL if you want to hide the button
    const TCHAR*    m_pStrNoID;
    const TCHAR*    m_pStrCenterButtonID;
    bool            m_bUseBigButtons;
    ProgressFunction    m_pFunction;
    WaitFunction    m_pWaitFunction;    // version with no known time
};
class CMsgDialog: public CPrimitiveScene // must derive from this to get into navigation map, but don't call any CScene functions
{
	public:

        CMsgDialog(){}
        virtual ~CMsgDialog(){}

        // set all the necessary info
        virtual HRESULT SetParameters( const MSGPARAMETERS& params ); // builds a standard OK dlg
        

        HRESULT FrameMove(XBGAMEPAD& GamepadInput, float elapsedTime );


        HRESULT SetMessage( const TCHAR* strIDMessage ); // in case the message needs to change

    protected:
        void SetButtonText( eButtonId ID, const TCHAR* pText );



	private:
      	
        CMsgDialog& operator=( const CMsgDialog& MsgDialog );
		CMsgDialog( const CMsgDialog& src );
		
};

class CWaitCursor : public CPrimitiveScene
{
public:
    // set all the necessary info
    virtual HRESULT SetParameters( const MSGPARAMETERS& params ); 
    HRESULT FrameMove(XBGAMEPAD& GamepadInput, float elapsedTime );

private:

    WaitFunction        m_pWaitFunction;
    float               m_fTime;


};


/**************************************************************************************************
CLASS DESCRIPTION
CProgressDialog:  Progress Bar!
**************************************************************************************************/


class CProgressDialog: public CMsgDialog
{
	public:

        virtual HRESULT SetParameters( const MSGPARAMETERS& params );

       	virtual HRESULT FrameMove(XBGAMEPAD& GamepadInput, float elapsedTime );

        CProgressDialog();

        float   SetProgress( float newProgress );
        


	private:
      	
        CProgressDialog& operator=( const CMsgDialog& MsgDialog );
		CProgressDialog( const CMsgDialog& src );

        ProgressFunction    m_pCallback;
        TG_Shape*           m_pSliderBar;
		
};



//*************************************************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\xodash\XODashLib\NetConfig.h ===
// Copyright (c) Microsoft Corporation.  All rights reserved

#pragma once
#include "SmartObject.h"
#include <winsockp.h>
#include <xonlinep.h>

enum eNetworkState
{
	eCableFail,
	eCablePending,
	eCablePass,
	eIPFail,
	eIPPending,
	eIPPass,
	ePPPoEFail,
	ePPPoEPending,
	eDNSFail,
	eDNSPending,
	eDNSPass,
	eServiceFail,
	eServicePending,
	eDone,
};

// NTS_Status screen, icons' states
enum eNetworkIconStatus{
	eFailIcon,
	eSuccessIcon,
	eDisableIcon
} ;

#ifndef HTONL
#define HTONL(l) \
        ((((l) >> 24) & 0x000000FFL) | \
         (((l) >>  8) & 0x0000FF00L) | \
         (((l) <<  8) & 0x00FF0000L) | \
         (((l) << 24)              ))

#endif

#ifndef NTOHL
#define NTOHL HTONL
#endif

// this class has been copied and changed from the CIpAddr class, names have been changed to 
// prevent possible names collision. The sole purpose of this utility class is to verify that
// set IP address has a valid format

struct CIp                      // IP Address in Network Byte Order
{
    union
    {
        BYTE        _ab[4];
        DWORD       _dw;
    };

    #define IP_BROADCAST            CIp(HTONL(0xFFFFFFFF))
    #define IP_LOOPBACK             CIp(HTONL(0x7F000001))
    #define IP_CLASSA_NETMASK       CIp(HTONL(0xFF000000))
    #define IP_CLASSB_NETMASK       CIp(HTONL(0xFFFF0000))
    #define IP_CLASSC_NETMASK       CIp(HTONL(0xFFFFFF00))
    #define IP_CLASSD_NETMASK       CIp(HTONL(0xF0000000))
    #define IP_LOOPBACK_NETID       CIp(HTONL(0x7F000000))
    #define IP_SECURE_NETID         CIp(HTONL(0x00000000))
    #define IP_SECURE_NETMASK       CIp(HTONL(0xFF000000))


    inline operator DWORD () const { return(_dw); }
    inline DWORD operator = (DWORD & dw) { return(_dw = dw); }
    inline CIp(DWORD dw) { _dw = dw; }
    inline CIp() {}

    inline bool IsBroadcast() const { return(_dw == IP_BROADCAST); }
    inline bool IsMulticast() const { return(IsClassD() && !IsBroadcast()); }
    inline bool IsLoopback() const { return((_dw & IP_CLASSA_NETMASK) == IP_LOOPBACK_NETID); }
    inline bool IsSecure() const { return(_dw && (_dw & IP_SECURE_NETMASK) == IP_SECURE_NETID); }

    inline bool IsClassA() const { return((_dw & HTONL(0x80000000)) == HTONL(0x00000000)); }
    inline bool IsClassB() const { return((_dw & HTONL(0xC0000000)) == HTONL(0x80000000)); }
    inline bool IsClassC() const { return((_dw & HTONL(0xE0000000)) == HTONL(0xC0000000)); }
    inline bool IsClassD() const { return((_dw & HTONL(0xF0000000)) == HTONL(0xE0000000)); }
    inline bool IsValidMask() const { DWORD dw = ~NTOHL(_dw); return((dw & (dw + 1)) == 0); }
    bool IsValidUnicast() const;
    CIp DefaultMask() const;
};

struct CXNetData : public XNetConfigParams
{
	char m_szIp[IP_ADDRESS_SIZE + 1];
	char m_szSubnet[IP_ADDRESS_SIZE + 1];
	char m_szGateway[IP_ADDRESS_SIZE + 1];
	char m_szPrimaryDns[IP_ADDRESS_SIZE + 1];
	char m_szSecondaryDns[IP_ADDRESS_SIZE + 1];
	bool bDynamicIp;
};

class CNetConfig
{
public:
    
	CNetConfig();
	virtual ~CNetConfig();
 
	const TCHAR* GetValue(eButtonId eField);
	HRESULT SetValue(eButtonId, TCHAR*);
	HRESULT Initialize();
	void Cleanup();
	
	bool IsEditable(eButtonId eField);
	eNetworkState GetNetworkStatus() { return m_eCurrentStatus;}
	eNetworkState CheckNetworkStatus();
	eNetworkState CheckServiceStatus();

	void ResetNetworkState();
	void SaveConfig();
	void RestoreConfig();
	

private:
	bool m_bDirty;
	eNetworkState m_eCurrentStatus;
	XONLINETASK_HANDLE   m_hLogon;
	BYTE m_NetConfigFlags;

	CXNetData m_xNetConfig;
	CXNetData m_xNetOrigConfig;
	
	static TCHAR m_szResult[MAX_NTS_SIZE+1];

private:
	void StringFromIP( DWORD dwIPAddr, char* szIp );
	HRESULT IPFromString(TCHAR* szIP, DWORD* dwIPAddr);
	HRESULT ValidateString(TCHAR*);
	void SetIPString(char*, const TCHAR*);

	
	void GetIp();
	
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\xodash\XODashLib\ntiosvc.cpp ===
#include "std.h"

#include "utilities.h"
#include "FileUtil.h"
#include "ntiosvc.h"


CNtIoctlCdromService::CNtIoctlCdromService()
{
    m_hDevice = INVALID_HANDLE_VALUE;
}

CNtIoctlCdromService::~CNtIoctlCdromService()
{
    Close();
}

void CNtIoctlCdromService::Close()
{
    if (m_hDevice != INVALID_HANDLE_VALUE)
    {
        CloseHandle(m_hDevice);
        m_hDevice = INVALID_HANDLE_VALUE;
    }

    m_toc.Delete();
}

HRESULT CNtIoctlCdromService::Open(DWORD dwDriveNumber)
{

    ASSERT(m_hDevice == INVALID_HANDLE_VALUE);

#ifdef _WINDOWS
    TCHAR szPath [] = _T("\\\\.\\A:");
    szPath[4] += (TCHAR)dwDriveNumber;
#endif
#ifdef _XBOX
    TCHAR szPath [] = _T("CDROM0:");
#endif

    m_hDevice = XAppCreateFile(szPath, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

    if (m_hDevice == INVALID_HANDLE_VALUE)
    {
        HRESULT hr = HRESULT_FROM_WIN32(GetLastError());
#ifdef _DEBUG
        LogComError(hr, "CNtIoctlCdromService::Initialize");
#endif
        return hr;
    }

    if (!GetTableOfContents())
        Close();

    return S_OK;
}


bool CNtIoctlCdromService::GetTableOfContents()
{
    HRESULT hr;
    CDROM_TOC toc;

    for (int nRetry = 0; nRetry < 1; nRetry += 1)
    {
        hr = DeviceIoControl(IOCTL_CDROM_READ_TOC, NULL, 0, &toc, sizeof (toc));

        if (SUCCEEDED(hr))
            break;

        if (hr != HRESULT_FROM_WIN32(ERROR_NOT_READY))
        {
#ifdef _DEBUG
            LogComError(hr, "CNtIoctlCdromService::GetTableOfContents");
#endif
            return false;
        }
        else
        {
            DbgPrint("ERROR_NOT_READY\n");
        }

//      Sleep(10);
    }

    if (FAILED(hr))
        return false;

    // BLOCK: Convert TOC format...
    {
        DbgPrint("Read TOC: %d tracks\n", toc.LastTrack);

        // Verify that the TOC is structurally correct and has at least one
        // track.
        if (toc.FirstTrack > toc.LastTrack)
            return false;

        BOOL fFoundEndTrack = FALSE;

        for (DWORD i = 0; i <= (DWORD)(toc.LastTrack - toc.FirstTrack + 1); i++)
        {
#define TOC_DATA_TRACK              (0x04)
#define TOC_LAST_TRACK              (0xaa)

            m_toc.TrackAddr[i] = TocValToFrames(toc.TrackData[i].Address);

            // Break out if we find a last track marker.
            if (toc.TrackData[i].TrackNumber == TOC_LAST_TRACK)
            {
                fFoundEndTrack = TRUE;
                break;
            }

            // Break out if we find a data track.
            if ((toc.TrackData[i].Control & TOC_DATA_TRACK) != 0)
            {
                // Knock off 2.5 minutes to account for the final leadin.
                toc.TrackData[i].Address[1] -= 2;
                toc.TrackData[i].Address[2] += 30;

                if (toc.TrackData[i].Address[2] < 60)
                    toc.TrackData[i].Address[1] -= 1;
                else
                    toc.TrackData[i].Address[2] -= 60;

                m_toc.TrackAddr[i] = TocValToFrames(toc.TrackData[i].Address);

                fFoundEndTrack = TRUE;
                break;
            }
        }

        // If we didn't find an ending track, whether it be a data track or a
        // track with the last track marker, then knock off one track because we
        // don't know how long the last "audio" track might really be.  We can't
        // underflow "i" here because the above code already checked for an
        // empty TOC.
        if (!fFoundEndTrack)
            i--;

        m_toc.LastTrack = i;
    }

#ifdef _CD_INFO
    if (m_toc.LastTrack > 0)
    {
        m_toc.UpdateDiscID();
        FetchDiscInfo(&m_toc);
    }
#endif

    return m_toc.LastTrack > 0;
}

HRESULT CNtIoctlCdromService::Read(DWORD  dwReadStart, DWORD  dwReadLength, LPVOID pvBuffer, DWORD dwRetries)
{
    RAW_READ_INFO rri;
    HRESULT hr;

    // NT drivers seem to want the disk offset to be (sector - 150) * 2048,
    // regardless of what the actual disk lead-in amount is.
    rri.DiskOffset.QuadPart = (ULONGLONG)(dwReadStart - 150) * (ULONGLONG)2048;
    rri.SectorCount = dwReadLength;
    rri.TrackMode = CDDA;

    do
    {
        hr = DeviceIoControl(IOCTL_CDROM_RAW_READ, &rri, sizeof (rri), pvBuffer, CDAUDIO_BYTES_PER_FRAME * dwReadLength);

        if (SUCCEEDED(hr))
            break;

#ifdef _DEBUG
        if (hr != HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER))
            LogComError(hr, "CNtIoctlCdromService::Read");
#endif
    }
    while(dwRetries--);

    return hr;
}

HRESULT CNtIoctlCdromService::DeviceIoControl(DWORD dwControlCode, LPVOID pvInBuffer, DWORD dwInBufferSize, LPVOID pvOutBuffer, DWORD dwOutBufferSize, LPDWORD pdwBytesReturned)
{
    DWORD dwBytesReturned;

    if (pdwBytesReturned == NULL)
        pdwBytesReturned = &dwBytesReturned;

    if (!::DeviceIoControl(m_hDevice, dwControlCode, pvInBuffer, dwInBufferSize, pvOutBuffer, dwOutBufferSize, pdwBytesReturned, NULL))
        return HRESULT_FROM_WIN32(GetLastError());

    return S_OK;
}

bool CNtIoctlCdromService::GetTotalLength(int* pnMinutes, int* pnSeconds, int* pnFrames)
{
    if (!IsOpen())
        return false;

    DWORD dwFrames = m_toc.TrackAddr[GetTrackCount()] - m_toc.TrackAddr[0];
    DWORD dwMsf = FramesToMsf(dwFrames);

    if (pnMinutes != NULL)
        *pnMinutes = MCI_MSF_MINUTE(dwMsf);

    if (pnSeconds != NULL)
        *pnSeconds = MCI_MSF_SECOND(dwMsf);

    if (pnFrames != NULL)
        *pnFrames = MCI_MSF_FRAME(dwMsf);

    return true;
}

bool CNtIoctlCdromService::GetTrackLength(int nTrack, int* pnMinutes, int* pnSeconds, int* pnFrames)
{
    if (!IsOpen() || nTrack < 0 || nTrack > GetTrackCount() - 1)
        return false;

    DWORD dwFrames = m_toc.TrackAddr[nTrack + 1] - m_toc.TrackAddr[nTrack];
    DWORD dwMsf = FramesToMsf(dwFrames);

    if (pnMinutes != NULL)
        *pnMinutes = MCI_MSF_MINUTE(dwMsf);

    if (pnSeconds != NULL)
        *pnSeconds = MCI_MSF_SECOND(dwMsf);

    if (pnFrames != NULL)
        *pnFrames = MCI_MSF_FRAME(dwMsf);

    return true;
}


#ifdef _CD_INFO
const TCHAR* CNtIoctlCdromService::GetTitle()
{
    if (!IsOpen())
        return NULL;

    return m_toc.szTitle;
}

const TCHAR* CNtIoctlCdromService::GetArtist()
{
    if (!IsOpen())
        return NULL;

    return m_toc.szArtist;
}

const TCHAR* CNtIoctlCdromService::GetTrackName(int nTrack)
{
    if (!IsOpen())
        return NULL;

    ASSERT(nTrack >= 0 && nTrack < m_toc.LastTrack);

    return m_toc.rgszTrack[nTrack];
}
#endif//_CD_INFO

////////////////////////////////////////////////////////////////////////////

XCDROM_TOC::XCDROM_TOC()
{
    Clear();
}

XCDROM_TOC::~XCDROM_TOC()
{
    Delete();
}

void XCDROM_TOC::Delete()
{
#ifdef _CD_INFO
    delete [] szTitle;
    delete [] szArtist;
    delete [] szID;

    for (unsigned i = 0; i < 100; i += 1)
        delete [] rgszTrack[i];
#endif

    Clear();
}

void XCDROM_TOC::Clear()
{
#ifdef _CD_INFO
    szTitle = NULL;
    szArtist = NULL;
    szID = NULL;

    for (unsigned i = 0; i < 100; i += 1)
    {
        rgszTrack[i] = NULL;
        TrackAddr[i] = 0;
    }
#endif

    LastTrack = 0;
}

int XCDROM_TOC::GetTrackFromFrame(DWORD dwPosition) const
{
    for (int i = 0; i < LastTrack; i += 1)
    {
        if (dwPosition < TrackAddr[i + 1])
            return i;
    }

    return 0;
}

// Calculate the disc id used by WindowsMedia.com
#ifdef _CD_INFO
void XCDROM_TOC::UpdateDiscID()
{
    ASSERT(szID == NULL);
    szID = new TCHAR [6 * LastTrack + 1];

    TCHAR* pch = szID;
    for (int i = 0; i < LastTrack; i += 1)
        pch += _stprintf(pch, _T("%06X"), TrackAddr[i]);
    *pch = 0;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\xodash\XODashLib\msgdialog.cpp ===
#include "std.h"
#include "msgdialog.h"

//-------------------------------------------------------------------------------------------------

HRESULT CMsgDialog::SetParameters( const MSGPARAMETERS& params )
{
 
    SetMessage( params.m_pStrMessageID );
   
    if ( params.m_bUseBigButtons )
    {
        SetButtonText( eMessage_BIGYES, params.m_pStrYesID );
        SetButtonText( eMessage_BIGNO, params.m_pStrNoID );
        SetButtonText( eMessage_CENTER, params.m_pStrCenterButtonID );
        SetButtonText( eMessage_YES, NULL );
        SetButtonText( eMessage_NO, NULL );
    }
    else
    {
        SetButtonText( eMessage_YES, params.m_pStrYesID );
        SetButtonText( eMessage_NO, params.m_pStrNoID );
        SetButtonText( eMessage_CENTER, params.m_pStrCenterButtonID );
        SetButtonText( eMessage_BIGYES, NULL );
        SetButtonText( eMessage_BIGNO, NULL );
    }

	HRESULT hr = S_OK;
    TG_Shape* pShape = m_pRoot->FindObject( "progress bar" );
    if ( pShape )
    {
        pShape->setVisible( 0 );
    }

	if(!m_pButtons.size())
	{
		return hr;
	}

	if(m_pButtons.size() && !m_pButtons[m_nActiveButtonIndex]->IsShowing())
	{
		FindNextActiveButton();	
	}

	m_pButtons[m_nActiveButtonIndex]->SetState(eButtonHighlighted);
    return hr;
    
}



//-------------------------------------------------------------------------------------------------

void CMsgDialog::SetButtonText( eButtonId ID, const TCHAR* pText )
{
    int buttonIndex = FindButton( ID );
    ASSERT( buttonIndex > -1 );
    if ( buttonIndex != -1 )
    {
        if( pText )
        {
            m_pButtons[buttonIndex]->Show( 1 );
            m_pButtons[buttonIndex]->SetTextId( pText );
        }
        else
        {
            m_pButtons[buttonIndex]->Show( 0 );
        }
    }
}

// in case the message needs to change
//-------------------------------------------------------------------------------------------------
HRESULT CMsgDialog::SetMessage( const TCHAR* pStrIDMessage  )
{
   int nTextId = FindTextObjForShape( "TEXT_PANEL" );
   if ( nTextId != -1 )
   {
        CText* pText = m_pTexts[nTextId];
        pText->SetTextId( pStrIDMessage );
   }

   return S_OK;

}

HRESULT CMsgDialog::FrameMove(XBGAMEPAD& GamepadInput, float elapsedTime )
{
    HRESULT hr = S_OK;

    CPrimitiveScene::FrameMove(GamepadInput, elapsedTime );
   
    // presumably OK Button pressed
	if(GamepadInput.bPressedAnalogButtons[XINPUT_GAMEPAD_A] || 
	   GamepadInput.wPressedButtons & XINPUT_GAMEPAD_START)
	{
		DbgPrint("CMsgDialog::FrameMove - Scene:%s, A/START is pressed\n", SceneName[m_eSceneId]);

        eButtonId buttonID = m_pButtons[m_nActiveButtonIndex]->GetButtonId();

        if (  buttonID ==  eMessage_NO || buttonID == eMessage_BIGNO )
        {
           hr = XBMSG_CANCEL;
        }
        else
        {
           hr = XBMSG_OK;
        }
	}

	// cancel button pressed, but only if its visible
    else if(GamepadInput.bPressedAnalogButtons[XINPUT_GAMEPAD_B] ||
	   GamepadInput.wPressedButtons & XINPUT_GAMEPAD_BACK)
	{
		DbgPrint("CMsgDialog::FrameMove - Scene:%s, B/BACK is pressed\n", SceneName[m_eSceneId]);
		// scene is destroyed by now do not touch any private data
		hr = XBMSG_BACK;
	}

    return hr;


}

HRESULT CWaitCursor::SetParameters( const MSGPARAMETERS& params )
{
     m_pWaitFunction = params.m_pWaitFunction;
     m_fTime = 0.f;

     return S_OK;
}
  
HRESULT CWaitCursor::FrameMove(XBGAMEPAD& GamepadInput, float elapsedTime )
{
   HRESULT hr = S_OK;
   if ( m_pWaitFunction )
      hr = m_pWaitFunction();

   if ( m_pRoot )
       m_pRoot->FrameMove( elapsedTime );

   m_Camera.FrameMove( elapsedTime );

   m_fTime += elapsedTime;

   if ( m_fTime < 5.f && m_eSceneId == eConnectAnim )
       hr = S_OK;

   // should probably put a min time length in here
   return hr;

}





//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------

LARGE_INTEGER oldTime = {0,0};
HRESULT TestProgressDlg( float* pProgress )
{
    LARGE_INTEGER counterFreq;
    QueryPerformanceFrequency( &counterFreq );

    if ( !oldTime.QuadPart )
        QueryPerformanceCounter( &oldTime );

    LARGE_INTEGER newTime;
    QueryPerformanceCounter( &newTime );

    float time = ((float)newTime.QuadPart - (float)oldTime.QuadPart)/(float)counterFreq.QuadPart;

    *pProgress = time/30.f;

    if ( time > 30.f )
    {
        memset( &oldTime, 0, sizeof ( LARGE_INTEGER ) );
        return XBMSG_OK;
    }


    return S_OK;
}

CProgressDialog::CProgressDialog()
{
    m_pSliderBar = NULL;
    m_pCallback = NULL;
}

//-------------------------------------------------------------------------------------------------

HRESULT CProgressDialog::SetParameters( const MSGPARAMETERS& params )
{
    m_pCallback = params.m_pFunction;
    CMsgDialog::SetParameters( params );

    TG_Shape* pShape = m_pRoot->FindObject( "progress bar" );
    if ( pShape )
    {
        pShape->setVisible( 1 );
        m_pSliderBar = pShape->FindObject( "slider" );
    }

    return S_OK;

}

//-------------------------------------------------------------------------------------------------


HRESULT CProgressDialog::FrameMove(XBGAMEPAD& GamepadInput, float elapsedTime )
{
    // need to call function here, figure out how much time is left on the clock
    // and then update the graphic appropriately.
    float fTime = 0.f;
    HRESULT hr = S_OK;

    if ( m_pCallback )
        hr = m_pCallback( &fTime );
    
    SetProgress( fTime );
    // presumably only cancel works???
	if(GamepadInput.bPressedAnalogButtons[XINPUT_GAMEPAD_A] || 
	   GamepadInput.wPressedButtons & XINPUT_GAMEPAD_START)
	{
		DbgPrint("CProgressDlg::FrameMove - Scene:%s, A/START is pressed\n", SceneName[m_eSceneId]);
        
        hr = XBMSG_CANCEL;
		return hr;
	}

		// cancel button pressed, but only if its visible
    else if(GamepadInput.bPressedAnalogButtons[XINPUT_GAMEPAD_B] ||
	   GamepadInput.wPressedButtons & XINPUT_GAMEPAD_BACK)
	{
		DbgPrint("CProgressDlg::FrameMove - Scene:%s, B/BACK is pressed\n", SceneName[m_eSceneId]);
		// scene is destroyed by now do not touch any private data
		hr = XBMSG_BACK;
	}
	return hr;
}

float   CProgressDialog::SetProgress( float newProgress )
{
    if ( m_pSliderBar )
    {
        m_pSliderBar->SetScale( newProgress, 1.0f, 1.0f );
    }

    return S_OK;

}



//-------------------------------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\xodash\XODashLib\ntiosvc.h ===
#pragma once
#include "xcddefs.h"
#include "utilities.h"
#include <devioctl.h>
#include <ntddcdrm.h>


class CNtIoctlCdromService
{
private:
	HANDLE m_hDevice;

public:
	CNtIoctlCdromService();
	~CNtIoctlCdromService();

	HRESULT Open(DWORD dwDriveNumber);
	void Close();
	HRESULT Read(DWORD dwReadStart, DWORD dwReadLength, LPVOID pvBuffer, DWORD dwRetries = 0);

	inline bool IsOpen() const
	{
		return m_hDevice != INVALID_HANDLE_VALUE;
	}

	inline int GetTrackCount() const
	{
		if (!IsOpen())
			return 0;

		return m_toc.LastTrack;
	}

	bool GetTotalLength(int* pnMinutes, int* pnSeconds, int* pnFrames);
	bool GetTrackLength(int nTrack, int* pnMinutes, int* pnSeconds, int* pnFrames);

#ifdef _CD_INFO
	const TCHAR* GetTitle();
	const TCHAR* GetArtist();
	const TCHAR* GetTrackName(int nTrack);
#endif

	inline DWORD GetTrackFrame(int nTrack) const
	{
		if (!IsOpen())
			return 0;

		_ASSERT(nTrack >= 0 && nTrack <= m_toc.LastTrack);
		return m_toc.TrackAddr[nTrack];
	}

	inline int GetTrackFromFrame(DWORD dwFrame) const
	{
		return m_toc.GetTrackFromFrame(dwFrame);
	}

protected:
	XCDROM_TOC m_toc;
	bool GetTableOfContents();
	HRESULT DeviceIoControl(DWORD dwControlCode, LPVOID pvInBuffer = NULL, DWORD dwInBufferSize = 0, LPVOID pvOutBuffer = NULL, DWORD dwOutBufferSize = 0, LPDWORD pdwBytesReturned = NULL);
};

// Nat extern CNtIoctlCdromService g_cdrom;
extern bool OpenCDROM();
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\xodash\XODashLib\PrimitiveScene.cpp ===
///////////////////////////////////////////////////////////////////////////////
// CPrimitiveScene.h
// base class for all individual screens.
// This class holds all the geometry, plus lists of interactive objects
// all individual screens should derive from this object
//////////////////////////////////////////////////////////////////////////////
#include "std.h"

#include "PrimitiveScene.h"
#include "utilities.h"
#include "XGMath.h"
#include "TGL.h"
#include "globals.h"
#include "XBInput.h"
#include "SmartObject.h"
#include "IniFile.h"
#include "Translator.h"

// static audio clip for all the button sounds
// WE do not want to keep calling set URL, this causes
// the file to reopen and reread the whole contents, painfully slow
CAudioClip* CPrimitiveScene::s_AudioFiles[eLastSoundType][4] = { 0,0,0,0,0,0,0,0};

//////////////////////////////////////////////////////////////////////////////
CPrimitiveScene::CPrimitiveScene()
{
	m_pRoot = 0;
	memset ( &m_Light, 0x00, sizeof ( D3DLIGHT8 ) );

    m_pVideoMem = NULL;

	m_bVerticalButtons = true;
	m_nActiveButtonIndex = 0;
	m_pHelpText = NULL;
    m_pListBox = NULL;
	m_eSceneId = eNullSceneId;
    m_pAnimMem = NULL;
}

//////////////////////////////////////////////////////////////////////////////
CPrimitiveScene::~CPrimitiveScene()
{
	Cleanup();
 }


HRESULT CPrimitiveScene::Initialize(char* szUrl, char* szTextURL, eSceneId eCurSceneId,bool bAutoTest )
{
	m_szUrlName = szUrl;
	m_eSceneId = eCurSceneId;
	HRESULT hr = LoadFromXBG(g_pd3dDevice, szUrl, szTextURL );
	ASSERT(SUCCEEDED(hr));
	if(FAILED(hr))
	{
		DbgPrint("CPrimitiveScene::Initialize - fail to load a scene");
	}

	if(FAILED(hr))
	{
		DbgPrint("CPrimitiveScene::Initialize - fail to bind data");
	}
	return hr;
}

//////////////////////////////////////////////////////////////////////////////
HRESULT CPrimitiveScene::Cleanup()
{
	
	if(m_eSceneId < countof(SceneName))
	{
		DbgPrint("Deleting scene %d [%s]\n", m_eSceneId, SceneName[m_eSceneId]);
	}
	
     // must do this in case the memory below is being referenced
    g_pd3dDevice->SetStreamSource( 0, 0, 0 );
    g_pd3dDevice->SetIndices( 0, 0 );

 
 

    if ( NULL != m_pVideoMem )
    {
        D3D_FreeContiguousMemory(m_pVideoMem);     

    }

    m_pVideoMem = NULL;


    if ( NULL != m_pAnimMem )
    {
        delete [] m_pAnimMem;
    }

    m_pAnimMem = NULL;


    // must be done BEFORE we kill the buttons
    if ( m_pListBox )
        delete m_pListBox;

	int nSize = m_pButtons.size();
	for (size_t i = 0; i<m_pButtons.size(); i++)
	{
		CButton* pButt = m_pButtons[i];
		delete m_pButtons[i];
		m_pButtons[i] = NULL;
	}
	m_pButtons.erase(m_pButtons.begin(), m_pButtons.end());

	nSize = m_pTexts.size();
	for (size_t i = 0; i<m_pTexts.size(); i++)
	{
		delete m_pTexts[i];
		m_pTexts[i] = NULL;
	}
	m_pTexts.erase(m_pTexts.begin(), m_pTexts.end());

	nSize = m_pSpinners.size();
	for (size_t i = 0; i<m_pSpinners.size(); i++)
	{
		delete m_pSpinners[i];
		m_pSpinners[i] = NULL;
	}
	m_pSpinners.erase(m_pSpinners.begin(), m_pSpinners.end());

    m_pSpinners.resize( 0 );
    m_pButtons.resize( 0 );
    m_pTexts.resize( 0 );

	// help text is deleted as part of the m_pTexts vector
	m_pHelpText = NULL;

 
    m_pListBox = NULL;

    //must be done last because other objects reference this
    if ( m_pRoot )
        delete m_pRoot;

    m_pRoot = NULL;

	
	return S_OK;
}


//////////////////////////////////////////////////////////////////////////////
// Draw the entire geometry, starting from the root and trickling down
/////////////////////////////////////////////////////////////////////////////
HRESULT CPrimitiveScene::Render( DWORD flags )
{
	ASSERT(m_pRoot);
    if ( m_pRoot )
	{
		if ( m_Light.Type != 0 )
		{
		   g_pd3dDevice->SetRenderState( D3DRS_LIGHTING, TRUE );
		   g_pd3dDevice->SetLight( 0, &m_Light );
		}
		else
		{
			g_pd3dDevice->SetRenderState(D3DRS_AMBIENT, 0x002f2f2f);
		}

		m_Camera.SetUp(g_pd3dDevice);
		m_pRoot->Render();

		for ( unsigned long i = 0; i < m_pTexts.size(); i++ )
		{
			m_pTexts[i]->Render(flags);
		}
	}
	return S_OK;

}


// Controller repeat values
const FLOAT fINITIAL_REPEAT = 0.333f; // 333 mS recommended for first repeat
const FLOAT fSTD_REPEAT     = 0.085f; // 85 mS recommended for repeat rate

HRESULT CPrimitiveScene::FrameMove( XBGAMEPAD& GamepadInput, float elapsedTime )
{	
	HRESULT hr = S_OK;

    m_pRoot->FrameMove( elapsedTime );
    m_Camera.FrameMove( elapsedTime );

	AutoTest(GamepadInput);

    // Spinners have control changes when there is no input, so sits above the eNoInput return
    for (unsigned int i = 0; i < m_pSpinners.size(); i++ )
    {
        m_pSpinners[i]->FrameMove( GamepadInput, elapsedTime );
    }

	if(GetInputState(GamepadInput) == eNoInput)
	{
		return hr;
	}
		// no buttons on the screen, do not care about input
	if(m_pButtons.empty())	
	{
		return hr;
	}

    // need to do the list box BEFORE we do the button highlight switch
    // this just takes care of updating text and scroll buttons
    if ( m_pListBox )
    {
        m_pListBox->FrameMove( GamepadInput, elapsedTime );
    }

	ASSERT(m_eSceneId < countof(SceneName));
	if (m_bVerticalButtons)
	{
		// allow to navigate up & down
		if(GamepadInput.wPressedButtons & XINPUT_GAMEPAD_DPAD_DOWN ||
			GamepadInput.fY1 == -1)
		{
			if((size_t)m_nActiveButtonIndex < m_pButtons.size()-1)
			{
				SetActiveButton(false);				
			}
			
		}

		if(GamepadInput.wPressedButtons & XINPUT_GAMEPAD_DPAD_UP ||
			GamepadInput.fY1 == 1)
		{
			if(m_nActiveButtonIndex > 0)
			{
				SetActiveButton(true);
			}
		}
	}
	else
	{
		if(GamepadInput.wPressedButtons & XINPUT_GAMEPAD_DPAD_RIGHT ||
		   GamepadInput.fX1 == 1)
		{
			if((size_t)m_nActiveButtonIndex < m_pButtons.size() -1 )
			{
				SetActiveButton(false);
			}
			
		}

		if(GamepadInput.wPressedButtons & XINPUT_GAMEPAD_DPAD_LEFT ||
			GamepadInput.fX1 == -1)
		{
			if(m_nActiveButtonIndex > 0)
			{
				SetActiveButton(true);
			}
		}
	}
	
	if(GamepadInput.bPressedAnalogButtons[XINPUT_GAMEPAD_WHITE])
	{
		CTranslator::Instance()->SetLanguage();
	}

	for(size_t i = 0; i<m_pTexts.size(); i++)
	{
		m_pTexts[i]->FrameMove(elapsedTime);
	}


	return hr;
}


//-----------------------------------------------------------------------------
// Name: LoadFromXBG()
// Desc: Loads a .xbg file
//-----------------------------------------------------------------------------
HRESULT CPrimitiveScene::LoadFromXBG( LPDIRECT3DDEVICE8 pd3dDevice, char* strFilename, char* strButtonTextNames )
{

    pd3dDevice->SetStreamSource( 0, 0, 0 );
	pd3dDevice->SetIndices( 0, 0 );

    // Open the file
    File file;
    if ( NO_ERR != file.open( strFilename ) )
            return E_FAIL;

    // Read the magic number
    DWORD dwFileID;
    file.read( (BYTE*)&dwFileID, sizeof(DWORD) ); 

    if( dwFileID != XBG_FILE_ID )
    {
        char errorStr[256];
        sprintf( errorStr, "FILE %s NEEDS TO BE RESAVED\n", strFilename );
        DbgPrint( errorStr );
        ASSERT( !"Old File format found, please resave" );
        file.close( );
        return E_FAIL;
    }

    // Read in header
    DWORD dwNumMeshes;  // Number of meshes in files
    DWORD dwSysMemSize; // Num bytes needed for system memory objects
    DWORD dwVidMemSize; // Num bytes needed for video memory objects
    DWORD dwAnimMemSize; // num bytes needed for animation info

    file.read( (BYTE*)&dwNumMeshes,  sizeof(DWORD)  );
    file.read( (BYTE*)&dwSysMemSize, sizeof(DWORD)  );
    file.read( (BYTE*)&dwVidMemSize, sizeof(DWORD)  );
    file.read( (BYTE*)&dwAnimMemSize, sizeof(DWORD)  );


    // Read in system memory objects
    VOID* pSysMemData = (VOID*)new BYTE[dwSysMemSize];
    file.read( (BYTE*)pSysMemData, dwSysMemSize );

    if ( NULL != m_pVideoMem )
    {
        D3D_FreeContiguousMemory( m_pVideoMem );
        m_pVideoMem = NULL;
    }

    // Read in video memory objects
    m_pVideoMem = (VOID*)D3D_AllocContiguousMemory( dwVidMemSize, D3DVERTEXBUFFER_ALIGNMENT );
    file.read( (BYTE*)m_pVideoMem, dwVidMemSize ); 

    if ( dwAnimMemSize )
    {
        m_pAnimMem = (VOID*)new BYTE[dwAnimMemSize];
        file.read( (BYTE*)m_pAnimMem, dwAnimMemSize );
    }
    
    // Do post-load, per-mesh processing
    XBMESH_FRAME* pFrameData = (XBMESH_FRAME*)pSysMemData;

    DWORD dwSysMemBaseAddr = (DWORD)pSysMemData;
    DWORD dwVidMemBaseAddr = (DWORD)m_pVideoMem;
    DWORD dwAnimMemBaseAddr = (DWORD)m_pAnimMem - sizeof(XBG_HEADER); 

    for( DWORD i=0; i<dwNumMeshes; i++ )
    {
        XBMESH_FRAME* pFrame = &pFrameData[i];
        XBMESH_DATA*  pMesh  = &pFrameData[i].m_MeshData;

        // Patch the mesh data. Any pointers read from the file were stored as
        // file offsets. So, we simply need to add a base address to patch
        // things up.
        if( pFrame->m_pChild )
            pFrame->m_pChild  = (XBMESH_FRAME*)( (DWORD)pFrame->m_pChild + dwSysMemBaseAddr );
        if( pFrame->m_pNext )
            pFrame->m_pNext   = (XBMESH_FRAME*)( (DWORD)pFrame->m_pNext + dwSysMemBaseAddr );
        if( pMesh->m_pSubsets )
            pMesh->m_pSubsets = (XBMESH_SUBSET*)( (DWORD)pMesh->m_pSubsets + dwSysMemBaseAddr );
        if( pMesh->m_dwNumIndices )
            pMesh->m_IB.Data  = pMesh->m_IB.Data + dwSysMemBaseAddr;

        if ( pMesh->m_pPos )
            pMesh->m_pPos = (D3DXVECTOR3*)(dwAnimMemBaseAddr + (DWORD)pMesh->m_pPos );

        if ( pMesh->m_pQuats )
            pMesh->m_pQuats = (D3DXQUATERNION*)(dwAnimMemBaseAddr + (DWORD)pMesh->m_pQuats);

    }

    // make sure there isn't an old one hanging around
    if ( m_pRoot )
        delete m_pRoot;

    m_pRoot = NULL;

    // In one swoop, create the frame hierarchy
    m_pRoot = new TG_Shape( pd3dDevice, NULL, pFrameData, m_pVideoMem );

    m_Camera.LoadBinary( &file );

    // need to figure out which smart objects to load based on passed in strings
    long numSubSets =  file.readLong();

    char tmpURL[256];
    long offset = file.getLogicalPosition() + numSubSets * sizeof( long );
    bool bFoundOffset =0;

    // pad for header info
    for ( int i = 0; i < numSubSets; i++ )
    {
        
        file.readString( (BYTE*)tmpURL );
        if ( _stricmp( tmpURL, strButtonTextNames ) == 0 )
        {
            offset = file.readLong();
            bFoundOffset = true;
            break;
        }
    
        offset = file.readLong();        

    }

 //   ASSERT( bFoundOffset );

    file.seek( offset );

      // now create the smart objects
    CreateSmartObjects(&file);

	// Cleanup allocated memory
    delete [] pSysMemData;
    pSysMemData = NULL;
    
 // Done with the file
    file.close( );


 
    return S_OK;
}

HRESULT CPrimitiveScene::CreateSmartObjects( File* pFile )
{
    ASSERT( pFile != NULL );
	HRESULT hr = S_OK;
	
    long buttonCount, textCount, listBoxCount, spinnerCount;

    textCount       = pFile->readLong();
    buttonCount     = pFile->readLong();
// TBD remove firstVert, firstHoriz
    long firstVert = pFile->readLong();
    long firstHoriz = pFile->readLong();
    listBoxCount    = pFile->readLong();
    spinnerCount    = pFile->readLong();

    long nTextOffset = pFile->readLong( );
    long buttonOffset = pFile->readLong( );
    long nListBoxOffset = pFile->readLong( );
    long nSpinnerOffset = pFile->readLong( );

    // I can't stand to watch the stl allocate lots of little chunks and recopy all the objects
    // for each push back...

    m_pTexts.resize( textCount );
    m_pButtons.resize( buttonCount );
    m_pSpinners.resize( spinnerCount );

	////////////////////////////// 

	do
	{
		// first create all the Text objects
		for (long i = 0; i< textCount; i++)
		{
			CText* pNewText = new CText;
			if(!pNewText)
			{
				hr = E_OUTOFMEMORY;
				BREAKONFAIL(hr, "CPrimitiveScene::CreateSmartObjects - Fail to create text");	
			}
				

			hr = pNewText->Initialize();
			BREAKONFAIL(hr, "CPrimitiveScene::CreateSmartObjects - Fail to Init a text");

			hr = pNewText->LoadFromXBG( pFile, m_pRoot );
			BREAKONFAIL(hr, "CPrimitiveScene::CreateSmartObjects - Fail to LoadFromXBG a text");

			m_pTexts[i] = (pNewText);
		}
		// now find a HelpText Text
		bool bHelpTextFound = false;
		for (long i=0; i<textCount;i++)
		{
			if(m_pTexts[i]->IsHelpText())
			{
				m_pHelpText = m_pTexts[i];
				// only one help text per scene is allowed
				ASSERT(!bHelpTextFound);
				bHelpTextFound = true;
			}
		}

		if (bHelpTextFound)
		{
			DbgPrint("CPrimitiveScene::CreateSmartObjects - helpText found");
		}
		else
		{
			DbgPrint("CPrimitiveScene::CreateSmartObjects - no helpText found");
		}

		// create all the buttons
		for (long i = 0; i < buttonCount; i++ )
		{
			CButton* pNewButton = NULL;
			long nPos = pFile->getLogicalPosition();
			long nSize = pFile->readLong();
			char nInputObjectTextId = pFile->readByte();
			
			if(nInputObjectTextId!=-1)
			{
				pNewButton = new CInputButton;
			}
			else
			{
				pNewButton = new CButton;
			}
			// put the pointer back
			pFile->seek(nPos);
			if (!pNewButton)
			{
				hr = E_OUTOFMEMORY;
				BREAKONFAIL(hr, "CPrimitiveScene::CreateSmartObjects - Fail to create a button");	
			}

			hr = pNewButton ->Initialize();
			BREAKONFAIL(hr, "CPrimitiveScene::CreateSmartObjects - Fail to Init a button");

			hr = pNewButton->LoadFromXBG( pFile, m_pRoot );
			BREAKONFAIL(hr, "CPrimitiveScene::CreateSmartObjects - Fail to LoadFromXBG a button");
			
			m_pButtons[i] = (pNewButton);
			
			CText* pText = NULL;
			CText* pInputText = NULL;
			if ( m_pButtons[i]->m_textObjId != -1 )
			{
				pText = m_pTexts[m_pButtons[i]->m_textObjId];
			}
			if (m_pButtons[i]->m_textObjId2 !=-1)
			{
				pInputText = m_pTexts[m_pButtons[i]->m_textObjId2];
			}

			m_pButtons[i]->SetTextObjects(pText, pInputText);
			m_nActiveButtonIndex = 0;
		}
		
		int nVertButtons = CountButtons(eButtonVerticalOrientation);
		int nHorizButtons = CountButtons(eButtonHorizontalOrientation);
		if (nVertButtons > 0 && nHorizButtons > 0)
		{// do not allow vertical and horizontal buttons on the same page except of 
		 // the Keyboard, NTS_Settings. DO NOT REMOVE THE ASSERT. IT MEANS THAT YOUR CLASS
		// NEEDS TO OVERLOAD FRAMEMOVE(), BECAUSE YOUR NAVIGATION IS NOT CONSIDERED STANADARD
		// ADD YOUR SCENE TO THE IF

			if(m_eSceneId != eKeyboardSceneId && m_eSceneId != eNTS_SettingsId &&
               m_eSceneId != eKeypadSceneId   && m_eSceneId != eKeypadPeriodSceneId &&
               m_eSceneId != eACT_BillingId   && m_eSceneId != eACT_CreditId)
			{
				ASSERT(false);
			}
		}
		
		
		nVertButtons > 0? m_bVerticalButtons = true : m_bVerticalButtons = false;
		
		SetFocus();

        // more than one would be a little bit wierd here...
        // we can't currently handle that many object highlighted, so
        // we'll implement that when (if) the time comes.
        ASSERT( listBoxCount < 2 );
        if ( listBoxCount )
        {
            m_pListBox = new CListBox();

            if ( !m_pListBox )
            {
                hr = E_OUTOFMEMORY;
				BREAKONFAIL(hr, "CPrimitiveScene::CreateSmartObjects - Fail to create list box");	
            }

            hr = m_pListBox->Initialize();
			BREAKONFAIL(hr, "CPrimitiveScene::CreateSmartObjects - Fail to Init a list box");

            hr = m_pListBox->LoadFromXBG( pFile, m_pRoot, &m_pButtons[0], m_pButtons.size() );
   			BREAKONFAIL(hr, "CPrimitiveScene::CreateSmartObjects - Fail to Load a list box");

        }

        // The number of spinners, and the number of buttons must be equal
        for (long i = 0; i < spinnerCount; i++)
        {
            CSpinner *pNewSpinner = new CSpinner();
            if ( !pNewSpinner )
            {
                hr = E_OUTOFMEMORY;
				BREAKONFAIL(hr, "CPrimitiveScene::CreateSmartObjects - Fail to create spinner");	
            }

            hr = pNewSpinner->Initialize();
			BREAKONFAIL(hr, "CPrimitiveScene::CreateSmartObjects - Fail to Init a spinner");

            hr = pNewSpinner->LoadFromXBG( pFile, m_pRoot, &m_pButtons[0], i );
   			BREAKONFAIL(hr, "CPrimitiveScene::CreateSmartObjects - Fail to Load a spinner");

            m_pSpinners[i] = (pNewSpinner);
        }
       


	} while(0);
	if (FAILED(hr))
	{
		Cleanup();
	}

	return hr;

}   


int CPrimitiveScene::CountButtons(eButtonOrientation eOrientation)
{
	int nButtons = 0;
	for (size_t i=0; i<m_pButtons.size(); i++)
	{
		if(m_pButtons[i]->GetOrientation() == eOrientation)
		{
			nButtons++;
		}
	
	}
	return nButtons;
}


void CPrimitiveScene::Dump(bool bAllData)
{	

	if(bAllData)
	{
		DbgPrint("=============================================================\n");
		DbgPrint("Scene Dump\n");
		DbgPrint("=============================================================\n");
		DbgPrint("SceneName: [%s]\n", SceneName[m_eSceneId]);
		
		DbgPrint("Vertical Buttons scene: [%s]\n", m_bVerticalButtons? "TRUE":"FALSE");
		for(size_t i = 0; i< m_pButtons.size(); i++)
		{	
			DbgPrint("\n-----------------------------------------------------------\n");
			m_pButtons[i]->Dump(bAllData);
		}
		DbgPrint("\nHelpText:");
		if (m_pHelpText)
		{
			m_pHelpText->Dump(bAllData);
		}
		else
		{
			DbgPrint("[null]");
		}

		DbgPrint("\n");
	}
				
}

const FLOAT JOY_THRESHOLD = 0.25f;
bool CPrimitiveScene::IsAnyButtonActive( const XBGAMEPAD* pGamePad )
{
    // Check digital buttons
    if( pGamePad->wButtons )
        return true;

    // Check analog buttons
    for( DWORD i = 0; i < 8; ++i )
    {
        if( pGamePad->bAnalogButtons[ i ] > XINPUT_GAMEPAD_MAX_CROSSTALK )
            return true;
    }

    // Check thumbsticks
    if( pGamePad->fX1 >  JOY_THRESHOLD ||
        pGamePad->fX1 < -JOY_THRESHOLD ||
        pGamePad->fY1 >  JOY_THRESHOLD ||
        pGamePad->fY1 < -JOY_THRESHOLD )
    {
        return true;
    }

    if( pGamePad->fX2 >  JOY_THRESHOLD ||
        pGamePad->fX2 < -JOY_THRESHOLD ||
        pGamePad->fY2 >  JOY_THRESHOLD ||
        pGamePad->fY2 < -JOY_THRESHOLD )
    {
        return true;
    }

    // Nothing active
    return false;
}

void CPrimitiveScene::SetActiveButton(bool bGoUp)
{
	if (m_pButtons.size())
	{
        long oldIndex = m_nActiveButtonIndex;

        // go from disabled but highlighted to disabled
        if ( m_pButtons[m_nActiveButtonIndex]->GetState() == eButtonDisabledHighlighted )
        {
            m_pButtons[m_nActiveButtonIndex]->SetState( eButtonDisabled );
        }
        else
        {
		    m_pButtons[m_nActiveButtonIndex]->SetState(eButtonDefault);
        }
		bGoUp ? FindPrevActiveButton() : FindNextActiveButton();

        if ( m_nActiveButtonIndex != oldIndex )
        {
            eSoundType  soundType = m_pButtons[m_nActiveButtonIndex]->GetSoundType();
            PlaySound( soundType, eSoundHighlight );
        }

		// go from disabled to disabled yet highlighted
        if ( eButtonDisabled == m_pButtons[m_nActiveButtonIndex]->GetState() )
        {
            m_pButtons[m_nActiveButtonIndex]->SetState( eButtonDisabledHighlighted );
        }
        else
        {
            m_pButtons[m_nActiveButtonIndex]->SetState(eButtonHighlighted);
        }

		if (m_pHelpText)
		{
			m_pHelpText->SetTextId(m_pButtons[m_nActiveButtonIndex]->GetHelpText());
		}
		AutoTest(eChangeFocus);
	}
}


int CPrimitiveScene::FindButton(eButtonId eButton)
{
	
	for(size_t nIndex = 0; nIndex < m_pButtons.size(); nIndex++)
	{
		if(eButton == m_pButtons[nIndex]->GetButtonId())
			break;
	}
	if(nIndex == m_pButtons.size())
	{
		return -1;
	}

	return nIndex;
}

int CPrimitiveScene::FindTextObjForId(const TCHAR* szTextId)
{
	ASSERT(szTextId);
	if(!szTextId)
	{
		return -1;
	}
	for(size_t nIndex = 0; nIndex < m_pTexts.size(); nIndex++)
	{
		if(!m_pTexts[nIndex]->GetTextId())
		{
			continue;
		}
		if(_tcsicmp(m_pTexts[nIndex]->GetTextId(), szTextId) == 0)
			break;
	}
	if(nIndex == m_pTexts.size())
	{
		nIndex = -1;
	}
	return nIndex;
}

int CPrimitiveScene::FindTextObjForShape(const char* szNodeName)
{
	ASSERT(szNodeName);
	if(!szNodeName)
	{
		return -1;
	}
	for(size_t nIndex = 0; nIndex < m_pTexts.size(); nIndex++)
	{
		TG_Shape* pAppearance =const_cast<TG_Shape*> (m_pTexts[nIndex]->GetShape());
		if(_stricmp(pAppearance->GetNodeName(), szNodeName) == 0)
			break;
	}
	if(nIndex == m_pTexts.size())
	{
		nIndex = -1;
	}
	return nIndex;
}

eInputState CPrimitiveScene::GetInputState(XBGAMEPAD& GamepadInput)
{	
	if( IsAnyButtonActive(&GamepadInput) )
    {
        // If the timer is running, the button is being held. If it's
        // held long enough, it triggers a repeat. If the timer isn't
        // running, we start it.
        if( m_RepeatTimer.IsRunning() )
        {
            // If the timer is running but hasn't expired, bail out
            if( m_RepeatTimer.GetElapsedSeconds() < m_fRepeatDelay )
                return eNoInput;
			// timer expired, receive new input
            m_fRepeatDelay = fSTD_REPEAT;
            m_RepeatTimer.StartZero();
			return eRepetitivePress;
        }
        else
        {
            m_fRepeatDelay = fINITIAL_REPEAT;
            m_RepeatTimer.StartZero();
			return eFirstTimePress;
        }
    }
    else
    {
        // No buttons or joysticks active; kill the repeat timer
        m_fRepeatDelay = fINITIAL_REPEAT;
        m_RepeatTimer.Stop();
		return eNoInput;
    }
	
}

int CPrimitiveScene::FindButtonForTextObj(const TCHAR* szTextId)
{
	// non localized strings do not have Ids
	if(!szTextId)
	{
		return -1;
	}
	int nIndex; 
	for(nIndex = 0; nIndex < (int) m_pButtons.size(); nIndex++)
	{
		CText* pText = const_cast<CText*> (m_pButtons[nIndex]->GetTextObject());

        // don't crash if we don't find it.
        if ( !pText )
            continue;
		// non localized strings do not have Ids
		if(!pText->GetTextId())
			continue;

		if(_tcsicmp(pText->GetTextId(), szTextId) == 0)
			break;
	}
	if( nIndex == m_pButtons.size())
	{
		nIndex = -1;
	}
	return nIndex;
}

void CPrimitiveScene::AutoTest(eAutoTestData eState)
{
	if(m_eSceneId >= countof(SceneName))
	{
		DbgPrint("CPrimitiveScene::AutoTest - wrong screenId\n");
		return;
	}

	switch(eState)
	{
	case eSceneInit:
		DbgPrint("\nAUTO:SCREEN=SCREEN_ID[%d], SCREEN_NAME[%s]\n",m_eSceneId, SceneName[m_eSceneId]);
		for(size_t i = 0; i< m_pButtons.size(); i++)
		{	
			m_pButtons[i]->AutoTest();
		}

		for(size_t i = 0; i< m_pTexts.size(); i++)
		{	
			int nIndex = FindButtonForTextObj(m_pTexts[i]->GetTextId());
			if (nIndex == -1)
			{
				m_pTexts[i]->AutoTest();
			}
		}
		break;
	case eChangeFocus:
		eButtonId eFocusButton = m_pButtons[m_nActiveButtonIndex]->GetButtonId();
		ASSERT(eFocusButton < countof(ButtonName));
		DbgPrint("\nAUTO:FOCUS=BUTTON_ID[%d], BUTTON_NAME[%s]\n",eFocusButton, ButtonName[eFocusButton]);
		if (m_pHelpText)
		{
			const TCHAR* pszHelp = m_pHelpText->GetTextId();
			char szBuf[256];
			ZeroMemory(szBuf, countof(szBuf));
			Ansi(szBuf,pszHelp, min(countof(szBuf)-1, _tcslen(pszHelp)) );
			DbgPrint("\nAUTO:TEXT=HELP_TEXT[%s]\n",szBuf);
		}
		break;

	}
}

void CPrimitiveScene::AutoTest(XBGAMEPAD& GamepadInput)
{
	if(GamepadInput.wPressedButtons & XINPUT_GAMEPAD_DPAD_DOWN ||
			GamepadInput.fY1 == -1)
	{
		DbgPrint("\nAUTO:INPUT=DOWN\n");
	}
	if (GamepadInput.wPressedButtons & XINPUT_GAMEPAD_DPAD_UP ||
			GamepadInput.fY1 == 1)
	{
			DbgPrint("\nAUTO:INPUT=UP\n");
	}
	if(GamepadInput.wPressedButtons & XINPUT_GAMEPAD_DPAD_RIGHT ||
		   GamepadInput.fX1 == 1)
	{
		DbgPrint("\nAUTO:INPUT=RIGHT\n");
	}
	if(GamepadInput.wPressedButtons & XINPUT_GAMEPAD_DPAD_LEFT ||
			GamepadInput.fX1 == -1)
	{
		DbgPrint("\nAUTO:INPUT=LEFT\n");
	}
	if(GamepadInput.bPressedAnalogButtons[XINPUT_GAMEPAD_A] || 
		GamepadInput.wPressedButtons & XINPUT_GAMEPAD_START)
	{
		DbgPrint("\nAUTO:INPUT=START/A\n");
	}
	if(GamepadInput.bPressedAnalogButtons[XINPUT_GAMEPAD_B] ||
	   GamepadInput.wPressedButtons & XINPUT_GAMEPAD_BACK)
	{
		DbgPrint("\nAUTO:INPUT=BACK/B\n");
	}
	if(GamepadInput.bPressedAnalogButtons[XINPUT_GAMEPAD_X])
	{
		DbgPrint("\nAUTO:INPUT=X\n");
	}
	if(GamepadInput.bPressedAnalogButtons[XINPUT_GAMEPAD_Y])
	{
		DbgPrint("\nAUTO:INPUT=Y\n");
	}
	if(GamepadInput.bPressedAnalogButtons[XINPUT_GAMEPAD_BLACK])
	{
		DbgPrint("\nAUTO:INPUT=BLACK\n");
	}
	if(GamepadInput.bPressedAnalogButtons[XINPUT_GAMEPAD_WHITE])
	{
		DbgPrint("\nAUTO:INPUT=WHITE\n");
	}
	if(GamepadInput.bPressedAnalogButtons[XINPUT_GAMEPAD_LEFT_TRIGGER])
	{
			DbgPrint("\nAUTO:INPUT=LEFT_TRIGGER\n");
	}
	if(GamepadInput.bPressedAnalogButtons[XINPUT_GAMEPAD_RIGHT_TRIGGER])
	{
		DbgPrint("\nAUTO:INPUT=RIGHT_TRIGGER\n");
	}
}


int CPrimitiveScene::FindNextActiveButton()
{
	int nOrigPos = m_nActiveButtonIndex; 

	while (1)
	{

		if(	++m_nActiveButtonIndex >= (int) m_pButtons.size())
		{
			break;
		}
		if(!m_pButtons[m_nActiveButtonIndex]->IsShowing())
		{
			continue;
		}
		break;
	}
	// all the rest buttons are hidden, revert to the orig position
	if(m_nActiveButtonIndex >= (int) m_pButtons.size())
	{
		m_nActiveButtonIndex = nOrigPos;
	}
	
	return m_nActiveButtonIndex;
}

int CPrimitiveScene::FindPrevActiveButton()
{
	int nOrigPos = m_nActiveButtonIndex; 
	
	while(1)
	{
		if(--m_nActiveButtonIndex < 0)
		{
			break;
		}

		if(!m_pButtons[m_nActiveButtonIndex]->IsShowing())
		{
			continue;
		}
		break;
	}

		// all the rest buttons are hidden, revert to the orig position
	if(m_nActiveButtonIndex < 0)
	{
		m_nActiveButtonIndex = nOrigPos;
	}
	
	return m_nActiveButtonIndex;
}

void CPrimitiveScene::PlaySound( eSoundType type, eSound whichOne )
{
    ASSERT( type < eLastSoundType && whichOne < 4 );
   

    if ( !s_AudioFiles[type][whichOne] )
    {
        s_AudioFiles[type][whichOne] = new CAudioClip();
        if ( !s_AudioFiles[type][whichOne] )
        {
            // OUT OF MEMORY??
            ASSERT( !"CPrimitiveScene::PlaySound memory error" );
            return;
        }

        TCHAR* url = SoundInfo[type][whichOne];
        if ( url )
        {
             s_AudioFiles[type][whichOne]->SetUrl( url );
        }
    }

    if ( s_AudioFiles[type][whichOne] )
    {
        s_AudioFiles[type][whichOne]->Play();
    }
}

void CPrimitiveScene::CleanupSounds()
{
    for ( int i = 0; i < eLastSound; i++ )
    {
        for ( int j = 0; j < eLastSoundType; j++ )
        {
            if ( s_AudioFiles[j][i] )
            {
                delete s_AudioFiles[j][i];
            }

            s_AudioFiles[j][i] = NULL;
        }
    }
}

void CPrimitiveScene::SetActiveButton(eButtonId eButton)
{
	int nIndex = FindButton(eButton);
	ASSERT(nIndex!=-1);
	if(-1 == nIndex)
	{
		return;
	}

	if(!m_pButtons[nIndex]->IsShowing())
	{
		DbgPrint("CPrimitiveScene::SetActiveButton - can't set invisible button to be active Id = %d\n", eButton);
		return;
	}

	if (m_pButtons.size())
	{
        long oldIndex = m_nActiveButtonIndex;
		
        // go from disabled but highlighted to disabled
        if ( m_pButtons[m_nActiveButtonIndex]->GetState() == eButtonDisabledHighlighted )
        {
            m_pButtons[m_nActiveButtonIndex]->SetState( eButtonDisabled );
        }
        else
        {
		    m_pButtons[m_nActiveButtonIndex]->SetState(eButtonDefault);
        }

		m_nActiveButtonIndex = nIndex;

        if ( m_nActiveButtonIndex != oldIndex )
        {
            eSoundType  soundType = m_pButtons[m_nActiveButtonIndex]->GetSoundType();
            PlaySound( soundType, eSoundHighlight );
        }

		// go from disabled to disabled yet highlighted
        if ( eButtonDisabled == m_pButtons[m_nActiveButtonIndex]->GetState() )
        {
            m_pButtons[m_nActiveButtonIndex]->SetState( eButtonDisabledHighlighted );
        }
        else
        {
            m_pButtons[m_nActiveButtonIndex]->SetState(eButtonHighlighted);
        }
		if (m_pHelpText)
		{
			m_pHelpText->SetTextId(m_pButtons[m_nActiveButtonIndex]->GetHelpText());
		}
		AutoTest(eChangeFocus);
	}
}


void CPrimitiveScene::SetFocus()
{
	// highlight first button
	if(!m_pButtons.size())
	{
		return;
	}
	
	if(!m_pButtons[m_nActiveButtonIndex]->IsShowing())
	{
		FindNextActiveButton();	
	}

    if ( m_pButtons[m_nActiveButtonIndex]->GetState() == eButtonDisabled )
    {
        m_pButtons[m_nActiveButtonIndex]->SetState(eButtonDisabledHighlighted);
    }
    else
    {
    	m_pButtons[m_nActiveButtonIndex]->SetState(eButtonHighlighted);
    }

	if (m_pHelpText)
	{
		m_pHelpText->SetTextId(m_pButtons[0]->GetHelpText());
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\xodash\XODashLib\sceneid.h ===
//Copyright (c) Microsoft Corporation.  All rights reserved.

#pragma once

enum eSceneId
{
	eNullSceneId = -1,
	eMainSceneId,
	eMemorySceneId,
	eMusicSceneId,
	eSettingsSceneId,
	eKeyboardSceneId,
	eKeypadSceneId,
	eKeypadPeriodSceneId,
	eNTS_SettingsId,
	eNTS_HostnameId,
	eNTS_HostnameTSId,
	eNTS_PPPoEId,
	eNTS_PPPoETSId,
	eNTS_IPId,
	eNTS_DNSId,
	eNTS_DNSTSId,
	eCellWallSceneId,
	eMsgBoxSceneId,
	eProgressBarSceneId,
	eACT_OnlineId,
	eACT_IdId,
	eNTS_StatusId,
	eNTS_ConfigChoiceId,
	eNTS_CableHelpId,
	eNTS_PPPoEHelpId,
	eNTS_IPHelpId,
	eNTS_DNSHelpId,
	eNTS_ServicesHelpId,
	eACT_CreditId,
	eACT_CountryId,
	eACT_BillingId,
	eGen_Large_PanelId,
	eGEN_Exp_TumblersId,
	eGEN_Dob_TumblersId,
	eGEN_Welcome_PanelId,
	eACT_Billing_CountryId,
	eAnimWait,
	eConnectAnim,
	eLastSceneId
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\xodash\XODashLib\SmartObject.cpp ===
#include "std.h"
#include "SmartObject.h"
#include "XOConst.h"
#include "globals.h"
#include "tgl.h"


SmartObject::~SmartObject()
{
	Cleanup();
}

void SmartObject::Cleanup()
{
   // do not remove tg_Shape, CScene will release the memory
	m_pAppearance = NULL;
}


void SmartObject::CopyObj(const SmartObject& OtherObj)
{
	if(OtherObj.m_pAppearance)
	{
		m_pAppearance = new TG_Shape(*OtherObj.m_pAppearance);
		ASSERT(m_pAppearance);
	}
}

SmartObject& SmartObject::operator= (const SmartObject& OtherObj)
{
	if(&OtherObj != this)
	{
		Cleanup();
		CopyObj(OtherObj);
	}
	return *this;
}

SmartObject::SmartObject(const SmartObject& OtherObj)
{
	CopyObj(OtherObj);
}

void SmartObject::Show( bool bDrawThisObject )
{
    if ( m_pAppearance )
    {
        m_pAppearance->setVisible( bDrawThisObject );
    }
}

bool    SmartObject::IsShowing()  const
{ 
    if ( m_pAppearance )
    {
        return m_pAppearance->isVisible();
    }

    return false;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\xodash\XODashLib\scenename.h ===
//Copyright (c) Microsoft Corporation.  All rights reserved.

#pragma once

static char* SceneName[] = 
{
	"MainScene",
	"MemoryScene",
	"MusicScene",
	"SettingsScene",
	"Keyboard",
	"Keypad",
	"KeypadPeriod",
	"NTS_Settings",
	"NTS_Hostname",
	"NTS_HostnameTS",
	"NTS_PPPoE",
	"NTS_PPPoETS",
	"NTS_IP",
	"NTS_DNS",
	"NTS_DNSTS",
	"CellWall",
	"gen_mess_panel",
	"gen_mess_panel",
	"ACT_Online",
	"ACT_Id",
	"NTS_Status",
	"NTS_ConfigChoice",
	"NTS_CableHelp",
	"NTS_PPPoEHelp",
	"NTS_IPHelp",
	"NTS_DNSHelp",
	"NTS_ServicesHelp",
	"ACT_Credit",
	"ACT_Country",
	"ACT_Billing",
	"Gen_Large_Panel",
	"GEN_Exp_Tumblers",
	"GEN_Dob_Tumblers",
	"GEN_Welcome_Panel",
	"ACT_Billing_Country",
	"Anim_Wait",
	"Anim_Connect",
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\xodash\XODashLib\PrimitiveScene.h ===
#pragma once
#include "std.h"
#include "Node.h"
#include "camera.h"
#include "StringObj.h"
#include "XOConst.h"
#include "SmartObject.h"
#include "XBStopWatch.h"
#include "Audio.h"

#include <vector>

using namespace std;

class TG_Shape;
class CText;
class FitIniFile;
class CNetConfig;
struct XBGAMEPAD;



class CPrimitiveScene 
{
	
public:
	// When Initialization is completed, we need to spew screen topology
	// base class will spew it or not based on the bAutoTest flag
	virtual HRESULT Initialize(char* pUrl, char* pButtonTextName,  eSceneId eCurSceneId, bool bAutoTest = true);
	virtual HRESULT Cleanup();
	virtual HRESULT Render( DWORD flags );

    
	virtual HRESULT FrameMove(XBGAMEPAD& GamepadInput, float elapsedTime );

    HRESULT LoadFromXBG( LPDIRECT3DDEVICE8 pd3dDevice, char* strFilename, char* pButtonTextName );
    virtual HRESULT CreateSmartObjects( File* pFile );

	CPrimitiveScene();
    virtual ~CPrimitiveScene();
	virtual void Dump(bool bAllData = false);
	virtual void AutoTest(eAutoTestData);
	void AutoTest(XBGAMEPAD& GamepadInput);
    void AutoTest(eAutoTestData eState, const char* pszPressedKey);

    static void CleanupSounds();

protected: 
	Camera			m_Camera;
	TG_Shape*		m_pRoot;
	D3DLIGHT8		m_Light;

	CStringObj m_szUrlName;
	eSceneId m_eSceneId;

    static CAudioClip*       s_AudioFiles[eLastSoundType][eLastSound];

	vector <CText*>     m_pTexts;
	vector <CButton*>   m_pButtons;
	CListBox*           m_pListBox;
    vector <CSpinner*>  m_pSpinners;
	void*               m_pVideoMem;
    void*               m_pAnimMem;

	CXBStopWatch m_RepeatTimer;
	float m_fRepeatDelay;

	CText* m_pHelpText;

	bool IsAnyButtonActive( const XBGAMEPAD* pGamePad );
	int CountButtons(eButtonOrientation eOrientation);
	int FindButton(eButtonId);
	// find the textobj for given textId
	int FindTextObjForId(const TCHAR* szTextId);
	// find the text object for given NodeName of the TG_Shape
	int FindTextObjForShape(const char* szTextId);
	// find button that includes the Text with given TextId
	int FindButtonForTextObj(const TCHAR* szTextId);
	void SetActiveButton(bool bGoUp);
	void SetActiveButton(eButtonId eButton);
	eInputState GetInputState(XBGAMEPAD& GamepadInput);
	int FindNextActiveButton();
	int FindPrevActiveButton();
	
	virtual void SetFocus();  // set focus on the right button (not necessarily the very first one)  during initialization stage

    static void PlaySound( eSoundType type, eSound whichOne );


	
	bool m_bVerticalButtons;
	int m_nActiveButtonIndex;


};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\xodash\XODashLib\std.h ===
#ifdef _XBOX
#ifdef __cplusplus
extern "C" {
#endif // __cplusplus
#include <ntos.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntdddisk.h>
#include <ntddcdrm.h>
#include <ntddscsi.h>
#include <ntddcdvd.h>
#include <smcdef.h>
#include <scsi.h>
#include <init.h>
#ifdef __cplusplus
}
#endif // __cplusplus
#include <dsoundp.h>
#include <xtl.h>
#include <xgraphics.h>
#include <xboxp.h>
#include <xapip.h>
#include <av.h>
#include "xonlinep.h"



#ifndef D3DLOCK_DISCARD
#define D3DLOCK_DISCARD 0
#endif

#endif

#ifdef _WINDOWS
#include <winsock2.h>
#include <windows.h>
#endif

#include <tchar.h>
typedef TCHAR* PTCHAR;

// "Filesystem" Character Type...What do *most* of the file system API's use...
#if defined(_XBOX)
typedef char FSCHAR;
#define _FS(s) s
#else
typedef TCHAR FSCHAR;
#define _FS(s) _T(s)
#endif

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <stdarg.h>
#include <math.h>

#include <crtdbg.h>

#if !defined(_NOD3D)
#define D3D_OVERLOADS
#include <d3d8.h>
#include <d3dx8.h>

#endif

#define ASSERTHR(f)		do { HRESULT hrverify = (f); if (FAILED(hrverify) && AssertFailed(_T(__FILE__), __LINE__, hrverify)) _CrtDbgBreak(); } while (0)
#define VERIFYHR(f)		ASSERTHR(f)


EXTERN_C bool AssertFailed(const TCHAR* szFile, int nLine, HRESULT hr);
#define BREAKONFAIL(a,b)  {if(FAILED(a)) {DbgPrint(b);break;} }
#define BREAKONFAIL2(a,b,c)  {if(FAILED(a)) {DbgPrint(b,c);break;} }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\xodash\XODashLib\spinner.cpp ===
#define SPINNER_CPP
/*************************************************************************************************\
spinner.cpp			: Implementation of the spinner component.
Creation Date		: 2/4/2002 12:47:03 PM
Copyright Notice	: (C) 2000 Microsoft
Author				: Victor Blanco
//-------------------------------------------------------------------------------------------------
Notes				: 
\*************************************************************************************************/
#include "std.h"
#include "smartobject.h"
#include "tgl.h"
#include "xbInput.h"
#include "XOConst.h"
#include "File.h"

/*************************************************************************************************/
CSpinner::CSpinner()
{
    m_nStartValue   = 0;
    m_nEndValue     = 0;
    m_nCurrentValue = 0;
    m_nPrecision    = 2;
    m_nScrollUpChangeDelay = 0;
    m_nScrollDownChangeDelay = 0;
    m_pScrollUpButton   = NULL;
    m_pScrollDownButton = NULL;
}


/*************************************************************************************************/
CSpinner::~CSpinner()
{

}

/*************************************************************************************************/
void CSpinner::SetRange( unsigned int nStartVal, unsigned int nEndVal )
{
    m_nStartValue   = nStartVal;
    m_nEndValue     = nEndVal;
    m_nCurrentValue = nStartVal;
        
    // Reset scroll arrow states
    m_pScrollUpButton->setVisible( 0 );
    m_pScrollDownButton->setVisible( 0 );

    UpdateText();
}

/*************************************************************************************************/
void CSpinner::UpdateRange( unsigned int nStartVal, unsigned int nEndVal )
{
    m_nStartValue   = nStartVal;
    m_nEndValue     = nEndVal;
        
    // Reset scroll arrow states
    m_pScrollUpButton->setVisible( 0 );
    m_pScrollDownButton->setVisible( 0 );

    UpdateText();
}

/*************************************************************************************************/
void CSpinner::SetValue( unsigned int nCurVal )
{
    ASSERT( nCurVal <= m_nEndValue );
    ASSERT( nCurVal >= m_nStartValue );
    
    m_nCurrentValue = nCurVal;
    
    UpdateText();
}

/*************************************************************************************************/
unsigned int CSpinner::GetValue( void )
{
    return m_nCurrentValue;
}

/*************************************************************************************************/
void CSpinner::SetPrecision( unsigned int nPrecision )
{
    ASSERT( nPrecision > 0 );
    m_nPrecision = nPrecision;
}

/*************************************************************************************************/
HRESULT CSpinner::IncrementValue( )
{
    if( (m_nCurrentValue + 1 ) <= m_nEndValue )
    {
        m_nCurrentValue++;
        UpdateText();
        return S_OK;
    }

    return E_FAIL;
}

/*************************************************************************************************/
HRESULT CSpinner::DecrementValue( )
{
    if( (m_nCurrentValue - 1 ) >= m_nStartValue )
    {
        m_nCurrentValue--;
        UpdateText();
        return S_OK;
    }

    return E_FAIL;
}

/*************************************************************************************************/
void CSpinner::Show( bool bDrawThisObject )
{
    if ( m_pAppearance )
    {
        m_pAppearance->setVisible( bDrawThisObject );
    }
}

/*************************************************************************************************/
HRESULT CSpinner::FrameMove( XBGAMEPAD& GamepadInput, float fElapsedTime )
{
    UpdateText();

    // Reset scroll arrow states
    if( !m_nScrollUpChangeDelay )
        m_pScrollUpButton->setVisible( 0 );
    else
        m_nScrollUpChangeDelay--;

    if( !m_nScrollDownChangeDelay )
        m_pScrollDownButton->setVisible( 0 );
    else    
        m_nScrollDownChangeDelay--;
 
    // The spinner must have focus to get render control
    if ( m_pSpinnerButton->GetState() == eButtonHighlighted )
    {
        // Joystick Down, Increment our value
        if(GamepadInput.wPressedButtons & XINPUT_GAMEPAD_DPAD_DOWN || GamepadInput.fY1 == -1)
        {
            m_pScrollDownButton->setVisible( 1 );
            m_nScrollDownChangeDelay = 3;
            DecrementValue();
            UpdateText();
        }
        
        
        // Joystick Down, Decrement our value
        else if(GamepadInput.wPressedButtons & XINPUT_GAMEPAD_DPAD_UP || GamepadInput.fY1 == 1)
        {
            m_pScrollUpButton->setVisible( 1 );
            m_nScrollUpChangeDelay = 3;
            IncrementValue();
            UpdateText();
        }
    }

    return S_OK;
    
}

/*************************************************************************************************/
void CSpinner::UpdateText()
{
    // fill in the buttons with the proper text
    TCHAR buffer[11];

    wsprintf( buffer, L"%010d", m_nCurrentValue );  // Create using maximum 
    
    m_pSpinnerButton->SetText( buffer + ( 10 - m_nPrecision ) );
    m_pSpinnerButton->SetHelpText( L"helptest" );
}

 /*************************************************************************************************/
HRESULT CSpinner::LoadFromXBG( File* pFile, TG_Shape* pRoot, CButton** pButtons, unsigned long count )
{

    BYTE shapeID[64];

    pFile->read( shapeID, 64 );

    m_pAppearance = pRoot->FindObject( (char*)shapeID );
    ASSERT( m_pAppearance );

    unsigned char entryCount = pFile->readByte( );
    
    m_pSpinnerButton = pButtons[entryCount];

    m_pScrollUpButton = m_pAppearance->FindObject( "Spinner_Up" );
    m_pScrollDownButton = m_pAppearance->FindObject( "Spinner_Down" );

    ASSERT( m_pScrollUpButton && m_pScrollDownButton );

    if ( m_pScrollUpButton )
        m_pScrollUpButton->setVisible( 1 );

    if ( m_pScrollDownButton )
        m_pScrollDownButton->setVisible( 1 );

    return S_OK;
     
}

//*************************************************************************************************
// end of file ( listbox.cpp )
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\xodash\XODashLib\StringObj.h ===
#pragma once


class CStringObj
{
public:
	virtual ~CStringObj();
	explicit CStringObj();
/*	CStringObj(TCHAR* pBuf, int len);
	CStringObj(TCHAR* pBuf);
	CStringObj(char* pBuf);
	CStringObj(char* pBuf, int len);
*/
	CStringObj(const TCHAR* pBuf, int len);
	CStringObj(const TCHAR* pBuf);
	CStringObj(const char* pBuf);
	CStringObj(const char* pBuf, int len);


	CStringObj(const CStringObj& Obj);

	CStringObj& operator = (const CStringObj& Obj);
	
	friend bool operator < (const CStringObj& Obj1,const CStringObj& Obj2)
	{
		if(!Obj1.m_pBuf && !Obj2.m_pBuf)
			return false;
		if(!Obj1.m_pBuf && Obj2.m_pBuf)
			return true;
		if(Obj1.m_pBuf && !Obj2.m_pBuf)
			return false;

		if(_tcsicmp(Obj1.m_pBuf, Obj2.m_pBuf) >= 0)
			return false;
		if(_tcsicmp(Obj1.m_pBuf, Obj2.m_pBuf) < 0)
			return true;
		return false;

	}
	
	friend bool operator >= (const CStringObj& Obj1,const CStringObj& Obj2)
	{
		return !(Obj1 < Obj2);
		
	}
	size_t length();
	bool empty();
	bool CompareNoCase(const CStringObj& Obj);
	const TCHAR* c_str();
	void Cleanup();
private:
	TCHAR* m_pBuf;
	
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\xodash\XODashLib\StringObj.cpp ===
#include "std.h"
#include "StringObj.h"
#include "utilities.h"



CStringObj::CStringObj():m_pBuf (NULL)
{
}
CStringObj::CStringObj(const TCHAR* pBuf, int len)
{
	ASSERT(pBuf);
	m_pBuf = new TCHAR[len+1];
	ASSERT(m_pBuf);
	if (m_pBuf == NULL)
	{
		DbgPrint("CStringObj::CStringObj - OUTOFMEMORY");
	}
	_tcsncpy(m_pBuf,pBuf, len);
	m_pBuf[len] = '\0';
}

CStringObj::CStringObj(const TCHAR* pBuf)
{
	ASSERT(pBuf);
	m_pBuf = new TCHAR[_tcslen(pBuf)+1];
	
	if (m_pBuf)
	{
		_tcscpy(m_pBuf,pBuf);
	}
	
}

CStringObj::CStringObj(const char* pBuf, int nLen)
{
	ASSERT(pBuf);
	m_pBuf = new TCHAR[nLen+1];
	
	ASSERT(m_pBuf);
	if (m_pBuf == NULL)
	{
		DbgPrint("CStringObj::CStringObj - OUTOFMEMORY");
	}
	Unicode(m_pBuf,pBuf, nLen);
	m_pBuf[nLen] = '\0';
}

CStringObj::CStringObj(const char* pBuf)
{
	ASSERT(pBuf);
	int nLen = strlen(pBuf)+1;
	m_pBuf = new TCHAR[nLen];
	
	if (m_pBuf)
	{
		Unicode(m_pBuf,pBuf, nLen);
	}
	
}

CStringObj::CStringObj(const CStringObj& Obj)
{
	if(	Obj.m_pBuf)
	{
		m_pBuf = new TCHAR[_tcslen(Obj.m_pBuf)+1];
		if(m_pBuf)
		{
			_tcscpy(m_pBuf,Obj.m_pBuf);
		}
	}
}

const TCHAR* CStringObj::c_str()
{
	return m_pBuf;
}


void CStringObj::Cleanup()
{
	delete [] m_pBuf;
	m_pBuf = NULL;
}


CStringObj& CStringObj::operator = (const CStringObj& Obj)
{
	if(Obj.m_pBuf != this->m_pBuf)
	{
		Cleanup();
	}

	if(Obj.m_pBuf)
	{
		m_pBuf = new TCHAR[_tcslen(Obj.m_pBuf)+1];
		if(m_pBuf)
		{
			_tcscpy(m_pBuf, Obj.m_pBuf);
		}
	}
	return *this;
}

CStringObj::~CStringObj()
{
	Cleanup();
}

size_t CStringObj::length()
{
	if(m_pBuf)
	{
		return _tcslen(m_pBuf);
	}
	return 0;
}

bool CStringObj::empty()
{
	if(m_pBuf==NULL)
	{
		return true;
	}
	return false;
}

bool CStringObj::CompareNoCase(const CStringObj& Obj)
{
	return false;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\xodash\XODashLib\SmartObject.h ===
#pragma once

#include "std.h"
#include "XOConst.h"
#include <list>
#include <vector>
class TG_Shape;
class CFont;
class File;


using namespace std;

class CSceneKeyboard;
struct XBGAMEPAD;

class SmartObject 
{
public:
	// Keyboard generates buttons, access to TG_Shape is required
	friend CSceneKeyboard;
	SmartObject(TG_Shape* pAppearance = NULL) : m_pAppearance(pAppearance) {}
	virtual ~SmartObject();
	SmartObject(const SmartObject&);
	SmartObject& operator=(const SmartObject&);
    // override as necessary
    virtual HRESULT Initialize() { return S_OK;}
	virtual void Cleanup();
	virtual HRESULT FrameMove( float fElapsedTime ) {return S_OK;};
	virtual HRESULT Render( DWORD flags = 0) { return S_OK;}

    
    virtual HRESULT LoadFromXBG( File* pFile, TG_Shape* m_pRoot  ){return S_OK; }
    
    virtual void Dump(bool bAllData = false) {} 
	inline const TG_Shape* GetShape() { return m_pAppearance;}
	virtual void AutoTest() {}

    virtual void Show( bool bDrawThisObject );
    virtual bool    IsShowing() const;

protected:
	TG_Shape* m_pAppearance;
	void CopyObj(const SmartObject&);
};



struct TEXTVERTEX;
class CText: public SmartObject
{

public:
	CText();
	~CText();
	CText(const CText&);
	CText& operator = (const CText& OtherObj);
	
	void SetTextId(const TCHAR* pNewTextId);
	inline const TCHAR* GetTextId() const { return m_szTextId;}

	void SetText(const TCHAR*);
	inline const TCHAR* GetText() const { return m_szText;}
	void    SetMaterial( long resourceMgrID );

	inline bool IsHelpText() { return m_bIsHelpText;}
	const int GetCursorPosition() {return m_nCursorPosition;}
	int MoveCursorLeft(int nPos = 1); 
	int MoveCursorRight(int nPos = 1);
	inline int HideCursor() { m_nCursorPosition = -1; return m_nCursorPosition;}
	int MoveCursorHome();
	int MoveCursorEnd();

	HRESULT Render( DWORD flags = 0) ;
	HRESULT FrameMove( float fElapsedTime );
	HRESULT Initialize();
    HRESULT LoadFromXBG( File* pFile, TG_Shape* m_pRoot );
	void Cleanup();

	void Dump(bool bAllData = false);

	void AutoTest();

    virtual void Show( bool bDrawThisObject );
    virtual bool    IsShowing() const { return m_bDraw; }



private:

	bool m_bTranslate;    // whether the text needs to be localized ,default is true

	TCHAR* m_szTextId;    // TextId if the text should be translated,
	TCHAR* m_szText;       // text to be displayed 

	const TCHAR* m_szFont;       // Valid Values: body, heading, default is body 
	char m_adjust;      // Valid Values: 'L','R','M'. 
	bool m_bSingleLine;  // Break to next line or not if the width of text is larger then the specified width
	
	float m_height;      // the height of the text rectangular, default is 0, when 0 height is set by geometry 
	float m_width;       // the width of the text rectangular, default is 0, when 0 width is set by geometry 
	// if width is specified and less than the width to render the text then the text is broken to separate lines
    // if m_bSingleLine = false, otherwise (m_bSingleLine = false) text is cut to fit the width
	
	float m_scroll;     // calculated based on ScrollRate - applied only for the text that does not fit the preset rectangular boundaries 
	float m_scrollRate;  // scroll rate for the scrolling text - stores what part of the whole text height should be changed when  scrolling
	float m_scrollDelay;  // speed of scrolling

    float m_fScaleX;        // scale for the mesh
    float m_fScaleY;        // scale for the mesh

	long    m_materialID;       // set the color

    bool  m_bIsHelpText;    // is this a piece of help text that needs to get updated?
	int m_nCursorPosition;  // for input text draw cursor, -1 for static texts
	float m_fLastRedraw;    // if cursor presents, redraw the mesh once in a while

	LPD3DXMESH m_pMesh;  // Mesh is build based on text string  
	D3DXVECTOR3 m_bboxMin, m_bboxMax;  // actual size of text to render calculated 

	float m_timeToScroll;  // calculated 

	void CopyObj(const CText& OtherObj);

    static D3DXMATRIX   s_scaleMatrix;
	DWORD m_nCurLanguage;

    bool    m_bDraw;

private:
	static void VerticalFade(TEXTVERTEX* verts, int nVertexCount, float nTop, float nBottom, float nScroll);
};

class CButton : public SmartObject
{
 
    public: 
        CButton(TG_Shape* pAppearance = NULL );
        virtual ~CButton();
      	virtual void Cleanup();

        virtual void SetState(eButtonState);
        eButtonState GetState() const { return m_eButtonState; }
        bool IsDisabled () const;
        void SetHelpText(const TCHAR* pHelpText);
		const TCHAR* GetHelpText() const;

        virtual void SetTextObjects( CText* pTextObj, CText* pInputText )
		{ // should be NULL
			ASSERT(!pInputText);
			m_pTextObj = pTextObj; 
		}

        virtual void SetTextId( const TCHAR* pTextTopID, const TCHAR* pTextBottomID = NULL );
        virtual void SetText( const TCHAR* pTextTop, const TCHAR* pTextBottom = NULL );

        void            SetSoundType( eSoundType type ){ m_eSound = type; }
        eSoundType      GetSoundType( ) const{ return m_eSound; }

      	virtual inline const CText* GetInputTextObject() { return NULL; }        

		inline const CText* GetTextObject() { return m_pTextObj;}

        virtual HRESULT LoadFromXBG( File* pFile, TG_Shape* pRoot );

        inline void SetCallback(ButtonCallBack );
	    inline eButtonId GetButtonId();
		inline eButtonOrientation GetOrientation();
        virtual void Show( bool bDrawThisObject );

        HRESULT    HandlePress(); // call the callback if there is one
		
		void Dump(bool bAllData = false);

        char     m_textObjId;
		char     m_textObjId2;
		void AutoTest();

		eButtonRTTI m_eType;

	protected:
		static long MaterialMap[eButtonStateMax][3]; // standard, egglow, text
		eButtonState    m_eButtonState; 

        eSoundType      m_eSound;
    private:
		// if required think about TG_Shape creation when new button is created
		// main problem: if text should be associated with specific button then 
		// two texts nodes will be created: one in the copy ctor of the button and
		// one in copy ctor of the text ( remember that text's TG_Shape is a child of the Button)
		CButton(const CButton&);
		CButton operator= (const CButton&);

        TCHAR*           m_pHelpText;  // help string 
		CText*          m_pTextObj;   // pointer to the text object associated with the Button, button is not 
		// responsible for the allocation and release of Text object memory
        
		TG_Shape**      m_pEgglowShapes;
        long            m_nEgglowCount;

        TG_Shape**      m_pStandardShapes;
        long            m_nStandardCount;

	    eButtonId       m_eButtonId ;
	    eButtonOrientation m_eOrientation;
	    ButtonCallBack m_pfnCallBack;

        void CopyObj(const CButton& OtherButton);

};


inline eButtonId CButton::GetButtonId()
{
	return m_eButtonId;
}

inline void CButton::SetCallback(ButtonCallBack pFoo)
{
	m_pfnCallBack = pFoo;
}

inline eButtonOrientation CButton::GetOrientation()
{
	return m_eOrientation;
}

// this button is a button that has two pieces of texts assoiated with it 
// the first piece is a static text with the name of the button, the second one 
// is the input field
class CInputButton : public CButton
{
public:
	virtual void SetTextObjects( CText* pTextObj, CText* pInputText )
	{
		m_pInputTextObj = pInputText;
		CButton::SetTextObjects(pTextObj, NULL);
	}
	virtual inline const CText* GetInputTextObject() { return m_pInputTextObj;}
	CInputButton(TG_Shape* pAppearance = NULL ) : m_pInputTextObj(NULL), CButton(pAppearance) 
	{
		m_eType = eTwoTextButton;
	}

    virtual void SetTextId( const TCHAR* pTextTopID, const TCHAR* pTextBottomID = NULL );
    virtual void SetText( const TCHAR* pTextTop, const TCHAR* pTextBottom = NULL );
    virtual void Show( bool bDrawThisObject );
	virtual void Dump(bool bAllData = false);
	virtual void SetState(eButtonState);
private:
	CText* m_pInputTextObj;

};

// standard list box class.  The way list box's work is that when you scroll,
// we go through and change the text of each button that's part of the list box.  
// Thus we have no smooth scrolling,
// And we aren't terribly fast.
class CListBox : public SmartObject
{
public:
    
    CListBox();
    virtual ~CListBox();
    // need the buttons so we can hook up them....
    virtual HRESULT LoadFromXBG( File* pFile, TG_Shape* pRoot, CButton** pButtons, unsigned long count  );


    virtual void Show( bool bDrawThisObject );

	HRESULT FrameMove( XBGAMEPAD& GamepadInput, float fElapsedTime );

    HRESULT SetItemText( unsigned long index, const TCHAR* pText, const TCHAR* pHelpText );
    HRESULT RemoveAllItems();
    HRESULT RemoveItem( int index );
    HRESULT RemoveItem( const TCHAR* pText );
    // Kind of wierd but the help text needs to be an ID in the resource file, the text does not
    HRESULT AppendItem( const TCHAR* pText, const TCHAR* pHelpText );
    HRESULT AppendItems( const TCHAR** ppText, const TCHAR** ppHelpText, int count );


private:

    typedef list< TCHAR* > TEXT_LIST;

    TEXT_LIST  m_ItemList;
    TEXT_LIST  m_ItemHelpText;
    vector< CButton* > m_pListButtons;

    long       m_nCurTextIndex;

    TG_Shape*           m_pScrollUpButton;
    TG_Shape*           m_pScrollDownButton;

    // suppress
    CListBox( const CListBox& );
    CListBox& operator=( const CListBox& );

    // Helper
    void UpdateText();

    
};

class CSpinner : public SmartObject
{
public:
    CSpinner();
    virtual ~CSpinner();

    // need the buttons so we can hook up them....
    virtual HRESULT LoadFromXBG( File* pFile, TG_Shape* pRoot, CButton** pButtons, unsigned long count  );
    virtual void Show( bool bDrawThisObject );

    HRESULT FrameMove( XBGAMEPAD& GamepadInput, float fElapsedTime );

    void         SetValue( unsigned int nCurVal );
    unsigned int GetValue( void );
    void         SetRange( unsigned int nStartVal, unsigned int nEndVal );
    void         UpdateRange( unsigned int nStartVal, unsigned int nEndVal );
    void         SetPrecision( unsigned int nPrecision );
    HRESULT IncrementValue( void );
    HRESULT DecrementValue( void );


private:
    unsigned int    m_nStartValue;
    unsigned int    m_nEndValue;
    unsigned int    m_nCurrentValue;
    unsigned int    m_nPrecision;

    CButton*        m_pSpinnerButton;

    unsigned int    m_nScrollUpChangeDelay;
    TG_Shape*       m_pScrollUpButton;
    unsigned int    m_nScrollDownChangeDelay;
    TG_Shape*       m_pScrollDownButton;

    // Helper
    void UpdateText();
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\xodash\XODashLib\texture.h ===
//-----------------------------------------------------------------------------
// File: Texture.h
//
// Desc: Header file for the main texture loading/clearing class
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef TEXTURE_H
#define TEXTURE_H

//-----------------------------------------------------------------------------
// Name: class CBaseTexture
// Desc: Base texture class
//-----------------------------------------------------------------------------
class CBaseTexture
{
public:
	CBaseTexture();
	virtual ~CBaseTexture();

	char					*m_sTexDirectory;
	unsigned int			m_nTexSizeBytes;
	D3DFORMAT				m_TexFormat;
	IDirect3DBaseTexture8	*m_pTexture;
};

class CTexture : public CBaseTexture
{
private:
	BYTE	*m_pResourceSysMemData; // Sysmem data for the packed resource
	BYTE	*m_pResourceVidMemData; // Vidmem data for the packed resource

public:
	CTexture();
	virtual ~CTexture();

	unsigned int m_nWidth;
	unsigned int m_nHeight;


	HRESULT CreateTexture( int &nWidth, int &nHeight, D3DFORMAT format );
	HRESULT GetTextureInfo( void );
	HRESULT LoadTexture( const char* sFilepath );
	DWORD	SizeOnDisk (const char* sFilepath );
};

class CVolumeTexture : public CBaseTexture
{
public:
	unsigned int m_nWidth;
	unsigned int m_nHeight;
	unsigned int m_nDepth;
};

class CCubeTexture : public CBaseTexture
{
public:
	unsigned int m_nLength;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\xodash\XODashLib\text.cpp ===
//-------------------------------------------------------------
// Copyright (c) Microsoft Corporation.  All rights reserved
//-------------------------------------------------------------
#include "std.h"

#include "Locale.h"
#include "FileUtil.h"
#include "globals.h"
#include "utilities.h"
#include "SmartObject.h"
#include "Translator.h"
#include "IniFile.h"
#include "TGL.h"
#include "Font.h"
#include "XOConst.h"

#define TEXT_SCALE 40


D3DXMATRIX  CText::s_scaleMatrix;


void CText::VerticalFade(TEXTVERTEX* verts, int nVertexCount, float nTop, float nBottom, float nScroll)
{
	for (int i = 0; i < nVertexCount; i += 1)
	{
		float a = 1.0f;
		float y = verts[i].y + nScroll;

		if (y > nTop || y < nBottom)
		{
			a = 0.0f;
		}
		else if (y > nTop - 1.0f)
		{
			a = 1.0f - (y - (nTop - 1.0f));
		}
		else if (y < nBottom + 1.0f)
		{
			a = 1.0f - ((nBottom + 1.0f) - y);
		}
		else //if (y >= nTop + 1.0f && y <= nBottom - 1.0f)
		{
			a = 1.0f;
		}

		ASSERT(a >= 0.0f && a <= 1.0f);

		a = smoothstep(0.0f, 1.0f, a);
//		float a0 = (float)(verts[i].color >> 24);
		verts[i].color = (verts[i].color & 0x00ffffff) | (((DWORD)(255.0f * a)) << 24);
	}
}


////////////////////////////////////////////////////////////////////////////

struct CFontTableEntry
{
	CFontTableEntry()
	{
		m_szFaceName = NULL;
		m_szFileName = NULL;
	}

	CFontTableEntry(const TCHAR* szFaceName, const TCHAR* szFileName)
	{
		m_szFaceName = szFaceName;
		m_szFileName = szFileName;
	}

	const TCHAR* m_szFaceName;
	const TCHAR* m_szFileName;
	CFont m_font;
};

#define MAX_FONT_COUNT 10

CFontTableEntry g_fonts [MAX_FONT_COUNT] =
{
	// NOTE: The first font is used as the default when a specified font is not found!
	CFontTableEntry(_T("HGGothicM"), _T("HGGothicM.xtf")),
};

int g_nFontCount = 1;

void InitFontTable()
{
	TCHAR szWild [MAX_PATH];
	WIN32_FIND_DATA fd;
	HANDLE h;


	TCHAR szFontPath [MAX_PATH];
	_tcscpy(szFontPath, XTF_PATH);

	_tcscpy(szWild, szFontPath);
	_tcscat(szWild, _T("*.xtf"));

#if defined(_XBOX)
	char szWildA [MAX_PATH];
	Ansi(szWildA, szWild, MAX_PATH);
	h = FindFirstFile(szWildA, &fd);
#else
	h = FindFirstFile(szWild, &fd);
#endif

	if (h == INVALID_HANDLE_VALUE)
	{
		DbgPrint("\001InitFontTable: No fonts!\n");
		return;
	}

	do
	{
		TCHAR szFileName [MAX_PATH];

		_tcscpy(szFileName, szFontPath);


#if defined(_XBOX)
		Unicode(szFileName + _tcslen(szFileName), fd.cFileName, countof(szFileName));
#else
		_tcscpy(szFileName + cchAppDir, fd.cFileName);
#endif

		if (g_nFontCount >= MAX_FONT_COUNT)
		{
			DbgPrint("\001InitFontTable: too many fonts!\n");
			continue;
		}

		HANDLE hFont = XAppCreateFile(szFileName, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL);
		if (hFont != INVALID_HANDLE_VALUE)
		{
			DWORD dwRead;
			DWORD cbGlyphSet;
			if(!ReadFile(hFont, &cbGlyphSet, 4, &dwRead, NULL))
			{
				CloseHandle(hFont);
				DbgPrint("InitFontTable() - fail to read from font file\n");
				continue;
			}

			if (cbGlyphSet == 0x30465458)
			{
				DWORD dwHeaderLen;
				ReadFile(hFont, &dwHeaderLen, 4, &dwRead, NULL);

				ASSERT(dwHeaderLen == LF_FACESIZE);

				char szFaceA [LF_FACESIZE];
				ReadFile(hFont, szFaceA, LF_FACESIZE, &dwRead, NULL);

				TCHAR* szFace = new TCHAR [strlen(szFaceA) + 1];
#ifdef _UNICODE
				Unicode(szFace, szFaceA, LF_FACESIZE);
#else
				_tcscpy(szFace, szFaceA);
#endif

				// Don't add the default font twice!
				if (_tcscmp(szFace, g_fonts[0].m_szFaceName) == 0)
				{
					delete [] szFace;
				}
				else
				{
					TCHAR* szFile = new TCHAR [_tcslen(szFileName) + 1];
					if(!szFile)
					{
						// we are out of memory nothing to do
						CloseHandle(hFont);
						FindClose(h);
						return;
					}
					_tcscpy(szFile, szFileName);

					g_fonts[g_nFontCount].m_szFaceName = szFace;
					g_fonts[g_nFontCount].m_szFileName = szFile;
					g_nFontCount += 1;

					DbgPrint("Adding font: %s (%s)\n", szFace, szFile);
				}
			}

			CloseHandle(hFont);
		}
	}
	while (FindNextFile(h, &fd));

	FindClose(h);
}

CFont* GetFont(const TCHAR* szFaceName)
{
	if (g_nFontCount == 1)
		InitFontTable();

	for (int i = 0; i < g_nFontCount; i += 1)
	{
		if (_tcsicmp(szFaceName, g_fonts[i].m_szFaceName) == 0)
			break;
	}

	if (i == g_nFontCount)
	{
		DbgPrint("Substituting font '%s' for '%s'\n", g_fonts[0].m_szFaceName, szFaceName);
		i = 0;
	}

	if (g_fonts[i].m_font.m_hFile == INVALID_HANDLE_VALUE)
	{
		TCHAR szFontPath [MAX_PATH];

		if (_tcschr(g_fonts[i].m_szFileName, ':') == NULL)
			_stprintf(szFontPath, _T("%s%s"), g_szAppDir, g_fonts[i].m_szFileName);
		else
			_tcscpy(szFontPath, g_fonts[i].m_szFileName);

		if (!g_fonts[i].m_font.Open(szFontPath))
		{
			DbgPrint("\001Cannot load font: %s\n", szFaceName);

			if (g_fonts[0].m_font.m_hFile == INVALID_HANDLE_VALUE)
			{
				if (!g_fonts[0].m_font.Open(g_fonts[0].m_szFileName))
				{
					ASSERT(FALSE);
					return NULL;
				}
			}
		}
	}

	return &g_fonts[i].m_font;
}

void Text_Exit()
{
	for (int i = 0; i < g_nFontCount; i += 1)
	{
		if (i > 0)
		{
			delete [] (TCHAR*)g_fonts[i].m_szFaceName;
			delete [] (TCHAR*)g_fonts[i].m_szFileName;
			g_fonts[i].m_szFaceName = NULL;
			g_fonts[i].m_szFileName = NULL;
		}
		g_fonts[i].m_font.Close();
	}
	g_nFontCount = 1;
}

////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////

static const float nScrollSpace = 1.0f;


CText::CText() :
	m_szTextId(NULL),
	m_szText(NULL),
	m_szFont(NULL),
	m_adjust('L'),

	m_bTranslate(true),
	m_width(0.0f),
	m_height(0.0f),
	m_scroll(0.0f),
	m_scrollRate(0.0f),
	m_scrollDelay(0.0f),
	m_bboxMin(0.0f,0.0f,0.0f), 
	m_bboxMax(0.0f,0.0f,0.0f),
	m_bSingleLine(false),
	m_pMesh(NULL),
	m_timeToScroll(0.0f),
	m_nCursorPosition(-1),
	m_fLastRedraw (0.0f),
	m_nCurLanguage (XC_LANGUAGE_UNKNOWN),
    m_bDraw( 1 )
	

	{
	}
	

void CText::CopyObj(const CText& OtherObj)
{
	if(OtherObj.m_szFont)
	{
		m_szFont = OtherObj.m_szFont; 
		ASSERT(m_szFont);
	}

	if(OtherObj.m_szText)
	{
		m_szText = new TCHAR[_tcslen(OtherObj.m_szText)+1];
		ASSERT(m_szText);
		if(m_szText)
		{
			_tcscpy(m_szText, OtherObj.m_szText);
		}
	}
	else
	{
		m_szText = NULL;
	}
	
	if(OtherObj.m_szTextId)
	{
		m_szTextId = new TCHAR[_tcslen(OtherObj.m_szTextId)+1];
		ASSERT(m_szTextId);
		if(m_szTextId)
		{
			_tcscpy(m_szTextId, OtherObj.m_szTextId);
		}
	}
	else
	{
		m_szTextId = NULL;
	}

	m_pMesh = NULL;

	m_adjust = OtherObj.m_adjust;

	m_bTranslate = OtherObj.m_bTranslate;
	m_width  = OtherObj.m_width;
	m_height = OtherObj.m_height;
	m_scroll = OtherObj.m_scroll;
	m_scrollRate = OtherObj.m_scrollRate;
	m_scrollDelay = OtherObj.m_scrollDelay;
	m_fScaleX = OtherObj.m_fScaleX;
    m_fScaleY = OtherObj.m_fScaleY;

	m_materialID = OtherObj.m_materialID;

	m_bboxMin = OtherObj.m_bboxMin;
	m_bboxMax = OtherObj.m_bboxMax;
	m_bSingleLine = OtherObj.m_bSingleLine;
	m_bIsHelpText = OtherObj.m_bIsHelpText;
	m_nCursorPosition = -1;
	m_fLastRedraw = OtherObj.m_fLastRedraw;
	
    m_pAppearance = new TG_Shape(*(OtherObj.m_pAppearance));

}

CText::CText(const CText& OtherObj)
{
	CopyObj(OtherObj);
}


CText& CText::operator = (const CText& OtherObj)
{
	if(&OtherObj != this)
	{
		Cleanup();
		CopyObj(OtherObj);
	}
	return *this;
}
void CText::Cleanup()
{

	delete [] m_szTextId;
	m_szTextId = NULL;

	delete [] m_szText;
	m_szText = NULL;

	if (m_pMesh != NULL)
	{
		m_pMesh->Release();
		m_pMesh = NULL;
	}
	SmartObject::Cleanup();
}
CText::~CText()
{
	Cleanup();
}

HRESULT CText::Initialize()
{
    m_materialID = g_MaterialLib.GetButtonTextMaterial();
	return S_OK;
}


HRESULT CText::FrameMove(float nSeconds)
{
	float now;
	if (m_scrollRate > 0.0f && m_pMesh != NULL)
	{
		now = XAppGetNow();

		if (m_timeToScroll == 0.0f)
			m_timeToScroll = now + m_scrollDelay;

		if (now >= m_timeToScroll )
		{
			float nContentHeight = m_bboxMax.y - m_bboxMin.y;
			if (nContentHeight > m_height)
			{
				m_scroll += m_height * nSeconds * m_scrollRate;
				if (m_scroll >= nContentHeight + nScrollSpace)
					m_scroll -= nContentHeight + nScrollSpace;
			}
		}
		
	}
	
	// make cursor blinking, recreate Mesh once in a while
	m_fLastRedraw += nSeconds;
	if(m_nCursorPosition >= 0 && m_pMesh != NULL && m_fLastRedraw > 0.3f)
	{
		m_fLastRedraw = 0.0f;
		m_pMesh->Release();
		m_pMesh = NULL;
	}
	return S_OK;
}

const TCHAR* FaceFromFont(long font)
{
	const TCHAR* szFace = _T("XBox Book"); //default to something real
	{
		if (font == HEADING_FONT)
			szFace = _T("Xbox");
	}

	return szFace;
}


HRESULT CText::Render( DWORD flags /*= 0*/) 
{
    if ( !m_bDraw ) // just invisible, don't sweat
        return S_OK;

	bool bInvalidMesh = false;
    HRESULT hr =S_OK;
	if (m_nCurLanguage != CTranslator::Instance()->GetCurLanguage())
	{
		// invalidate the mesh only for localized texts
		bInvalidMesh = m_bTranslate;
		m_nCurLanguage = CTranslator::Instance()->GetCurLanguage();
	}

	if (m_pMesh != NULL && bInvalidMesh)
	{
		m_pMesh->Release();
		m_pMesh = NULL;
	
		delete [] m_szText;
		m_szText = NULL;

	}

	if (m_pMesh == NULL)
	{
		if (m_bTranslate && !m_szText)
		{
			// for localized text, textId should be not null
			ASSERT(m_szTextId && m_szTextId[0]!= 0);

			TCHAR* pRes = NULL;
			if (m_szTextId && m_szTextId[0])
			{
				pRes = const_cast <TCHAR*> (CTranslator::Instance()->Translate(m_szTextId));
			}

            if ( !pRes )
            {
                m_szText = new TCHAR[_tcslen(_T("Missing Text"))+1];
			    _tcscpy(m_szText, _T("Missing Text"));
            }
            else
            {
			    m_szText = new TCHAR[_tcslen(pRes)+1];
			    _tcscpy(m_szText, pRes);
            }

			ASSERT(m_szText);
			if (m_szText == NULL)
			{
				DbgPrint("CText::Render - Translation is not found, text is empty");
				return hr;
			}
		} 
		
			// allow empty text string
		if(m_szText && m_szText[0] == 0 && m_nCursorPosition < 0)
		{
			return hr; 
		}


	    CFont* pFont = GetFont(m_szFont);
	
	    hr = pFont->CreateTextMesh(m_szText, -1, &m_pMesh, &m_bboxMin, &m_bboxMax, fabsf(m_width/m_fScaleX),m_bSingleLine, m_nCursorPosition);

	    ASSERT(m_pMesh && SUCCEEDED(hr));
	    if (m_pMesh == NULL || FAILED(hr))
		{
			if(m_pMesh)
			{
				m_pMesh->Release();
				m_pMesh = NULL;
			}
			DbgPrint("CText::Render - fail to create the mesh, hr = 0x%x",hr);
			return hr;
		}
	}
	
	float nContentHeight = (m_bboxMax.y - m_bboxMin.y)*m_fScaleY;

	float xOffset = 0.0f;
    float yOffset = 0.f;

    {
		float nWidth = (m_bboxMax.x - m_bboxMin.x)*m_fScaleX;
		if (m_width != 0.0f)
		{
			float widthLimit = fabsf(m_width);
			if (nWidth > widthLimit)
				nWidth = widthLimit;
		}

        if ( m_bSingleLine ) // center vertically
        {
            yOffset = nContentHeight/2.f;
            
        }
		else
		{
			yOffset = (-m_height/ 2.0f) + nScrollSpace * m_fScaleY;
		}

        if (m_adjust == 'L')
        {
   			xOffset = -m_width / 2.0f;
        }
		else if (m_adjust == 'C')
		{
			xOffset = -nWidth / 2.0f;
			if (m_width < 0.0f)
			{
				// TODO: Fade both sides
			}
		}
		else if (m_adjust == 'R')
		{
			xOffset = -nWidth + m_width/2.f;
			if (m_width < 0.0f)
			{
				// TODO: Fade left side
			}
		}
		else
		{
			 ASSERT(false);
		}
	}

	for (int i = 0; i < 2; i += 1)
	{
		if (m_height != 0.0f && nContentHeight > m_height)
		{
			TEXTVERTEX* verts;
			m_pMesh->LockVertexBuffer(0, (BYTE**)&verts);
			float yTop = -m_scroll + 1.0f;
			float yBottom = yTop - m_height - 2.0f;
			if (m_scroll == 0.0f)
				yTop += 1.0f; // don't fade at top when not scrolled...
			CText::VerticalFade(verts, m_pMesh->GetNumVertices(), yTop/* + 0.5f*/, yBottom, i == 0 ? 0 : -(nContentHeight + nScrollSpace));
			m_pMesh->UnlockVertexBuffer();
		}
		else if (i == 1)
		{
			// Don't need second pass if not scrolling...
			break;
		}

		// Don't need second pass unless part of it is visible...
		if (i == 1 && m_scroll + m_height < nContentHeight)
			break;

		hr = g_MaterialLib.Setup( m_materialID, D3DFVF_XYZ | D3DFVF_NORMAL | D3DFVF_DIFFUSE );
		ASSERT(SUCCEEDED(hr) );
     	if(FAILED(hr))
		{
			DbgPrint("CText::Render - fail to get material");
		}


        // need to get the transform    
        D3DXMATRIX worldTransform;
        m_pAppearance->GetWorldTransform( worldTransform  );

      
        float fScale = TEXT_SCALE;

        g_pd3dDevice->SetRenderState( D3DRS_ZENABLE, D3DZB_FALSE ); // draw on top regardless...

        D3DXMATRIX oldWorldTransform;
        g_pd3dDevice->GetTransform( D3DTS_WORLD, &oldWorldTransform  );


	    D3DXMATRIX finalWorld;
        D3DXMATRIX flipX;
        // need to move to left edge
        D3DXMATRIX offset;
        D3DXMatrixTranslation( &offset, xOffset, -yOffset, 0.f );
        D3DXMatrixRotationX( &flipX, D3DX_PI/2.f );
        D3DXMatrixMultiply( &worldTransform, &oldWorldTransform, &worldTransform );
        D3DXMatrixMultiply( &worldTransform, &flipX, &worldTransform );
        D3DXMatrixMultiply( &worldTransform, &offset, &worldTransform );
        D3DXMatrixScaling(&s_scaleMatrix, m_fScaleX, m_fScaleY, m_fScaleY);
        D3DXMatrixMultiply( &worldTransform, &s_scaleMatrix, &worldTransform );

        g_pd3dDevice->SetTransform( D3DTS_WORLD, &worldTransform );

		VERIFYHR(g_pd3dDevice ->SetRenderState(D3DRS_CULLMODE, D3DCULL_NONE));

		hr = m_pMesh->DrawSubset(0);
		VERIFYHR(g_pd3dDevice ->SetRenderState(D3DRS_CULLMODE, D3DCULL_CCW));

        g_pd3dDevice->SetTransform( D3DTS_WORLD, &oldWorldTransform  );

	}
	return hr;
}

#ifndef NODE_NAME_LEN
#define NODE_NAME_LEN 64
#endif

HRESULT CText::LoadFromXBG( File* pFile, TG_Shape* pRoot )
{

   long oldPos = pFile->getLogicalPosition();
    long objSize = pFile->readLong( );
   char shapeID[NODE_NAME_LEN];

   pFile->read( (BYTE*)shapeID, NODE_NAME_LEN * sizeof( char ) );

   m_pAppearance = pRoot->FindObject( shapeID );
   ASSERT(m_pAppearance);
   m_pAppearance->setVisible( false );


   char vertAdjust =    pFile->readByte(  );
   m_adjust =           pFile->readByte(  );
   m_bSingleLine =      pFile->readByte( ) ? 1 : 0;
   long fontType =      pFile->readLong();

   m_height =            pFile->readFloat( );
   m_width =           pFile->readFloat( );
   m_bIsHelpText =      pFile->readByte(  ) ? 1 : 0;
   m_fScaleX =          pFile->readFloat(  );
   m_fScaleY =          pFile->readFloat(  );
   m_scrollRate =       pFile->readFloat(  );
   m_scrollDelay =      pFile->readFloat( );
   m_timeToScroll =     pFile->readFloat();   
   m_bTranslate =       pFile->readByte( ) ? 1 : 0;

   long newPos =        pFile->getLogicalPosition();
   long count = (objSize - (newPos - oldPos))/2;
   if ( count )
   {
       m_szTextId = new TCHAR[count+1];
       pFile->read( (BYTE*)m_szTextId, count * sizeof( TCHAR ) );
       m_szTextId[count] = 0;
   }
// TBD REMOVE
   if ( !m_bTranslate ) // need placeholder text of some kind so we don't crash
   {
        m_szText = new TCHAR[3];
        _tcscpy( m_szText, _T("A") );
   }
   m_szFont = FaceFromFont( fontType );

    return S_OK;
}


void    CText::SetMaterial( long resourceMgrID )
{
    m_materialID = resourceMgrID;
}


void CText::Dump(bool bAllData)
{
	if(bAllData)
	{
		char szBuf[256];
		if(m_szTextId)
		{
			ZeroMemory(szBuf,countof(szBuf)); 
			Ansi(szBuf, m_szTextId, min(countof(szBuf)-1, _tcslen(m_szTextId)) );
		}
		else 
		{
			strcpy(szBuf, "[null]");
		}

		DbgPrint("TextId:[%s]\n", szBuf);
		DbgPrint("Translate:[%s]", m_bTranslate? "TRUE":"FALSE");

		if(m_szText!=NULL)
		{
			ZeroMemory(szBuf,countof(szBuf)); 
			Ansi(szBuf, m_szText, countof(szBuf));
			DbgPrint(" Text:[%s]", szBuf);
		}
		else
		{
			DbgPrint(" Text:[null]");
		}		
		
		Ansi(szBuf, m_szFont, countof(szBuf));
		DbgPrint(" Font:[%s]", szBuf);

		DbgPrint(" Adjust:[%c]", m_adjust);
		DbgPrint(" SingleLine:[%s]\n", m_bSingleLine?"TRUE":"FALSE");

		int nLen = sprintf(szBuf,"Height:[%f] Width:[%f] ScrollRate:[%f] ScrollDelay: [%f] \n", m_height, m_width, m_scrollRate, m_scrollDelay );
		ASSERT(nLen < countof(szBuf));
		DbgPrint("%s", szBuf);
		
		nLen = sprintf(szBuf,"ScaleX:[%f] ScaleY:[%f]", m_fScaleX, m_fScaleY);
		ASSERT(nLen < countof(szBuf));
		DbgPrint("%s\n", szBuf);

		DbgPrint("HelpText:[%s]", m_bIsHelpText? "TRUE":"FALSE");
	}

}



void CText::SetTextId(const TCHAR* pNewTextId)
{
	ASSERT(pNewTextId && pNewTextId[0]);
	TG_Shape* pCurShape = m_pAppearance;
	Cleanup();

	// safer to call Cleanup and restore the TG_Shape ptr
	m_pAppearance = pCurShape;
	if (pNewTextId)
	{
		m_szTextId = new TCHAR[_tcslen(pNewTextId)+1];
		if (m_szTextId)
		{
			_tcscpy(m_szTextId, pNewTextId);
		}
	}
}


void CText::SetText(const TCHAR* pNewText)
{
	ASSERT(pNewText);
	TG_Shape* pCurShape = m_pAppearance;
	Cleanup();

	m_pAppearance = pCurShape;
	if (pNewText)
	{
		m_szText = new TCHAR[_tcslen(pNewText)+1];
		if (m_szText)
		{
			_tcscpy(m_szText, pNewText);
		}
	}

    // this won't reset the text properly if its translatable
    m_bTranslate = 0;
}

int CText::MoveCursorLeft(int nPos) 
{
	if(m_nCursorPosition-nPos >= 0)
	{
		m_nCursorPosition = m_nCursorPosition-nPos; 
		if (m_pMesh)
		{
			m_pMesh->Release();
			m_pMesh = NULL;
		}
	}
	return m_nCursorPosition;
}

int CText::MoveCursorRight(int nPos) 
{
	bool bInvalidateMesh = false;
	// allow to draw cursor only
	if(!m_szText || m_szText && !m_szText[0] && nPos == 1)
	{
		bInvalidateMesh = true;
	}

	if(m_szText && (m_nCursorPosition + nPos <=(int) _tcslen(m_szText) )  ) 
	{
		bInvalidateMesh = true;
		m_nCursorPosition = m_nCursorPosition + nPos;
	}
	
	if (bInvalidateMesh && m_pMesh)
	{
			m_pMesh->Release();
			m_pMesh = NULL;
	}
	
	return m_nCursorPosition;
}

int CText::MoveCursorHome()
{
	if(m_szText && !m_szText[0])
	{
		MoveCursorRight();
	}
	MoveCursorLeft(m_nCursorPosition);
	return 	m_nCursorPosition;
}

int CText::MoveCursorEnd()
{
	int nNewPos, nPos =0;
	if(m_szText && m_szText[0])
	{
		nNewPos = _tcslen(m_szText);
	}
	else
	{
		return MoveCursorHome();
	}
	if(m_nCursorPosition>=0)
	{
		nPos = nNewPos - nPos;
	}
	else
	{
		nPos = nNewPos+1;
	}
	MoveCursorRight(nPos);
	return 	m_nCursorPosition;			
}
void CText::AutoTest()
{
	char szBuf[256];
	if(m_szTextId)
	{
		ZeroMemory(szBuf,countof(szBuf)); 
		Ansi(szBuf, m_szTextId, min(countof(szBuf)-1, _tcslen(m_szTextId)) );
	}
	else 
	{
		strcpy(szBuf, "[null]");
	}

	DbgPrint("\nAUTO:TEXT=TEXT_ID[%s]\n", szBuf);

}

void CText::Show( bool bDrawThisObject )
{
    m_bDraw = bDrawThisObject;
  
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\xodash\XODashLib\texture.cpp ===
//-----------------------------------------------------------------------------
// File: Texture.cpp
//
// Desc: Classes designed to support the creation, loading, and
//		 clearing of texture surfaces.
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include "std.h"
#include "texture.h"
#include "file.h"

extern LPDIRECT3DDEVICE8 g_pd3dDevice;

//-----------------------------------------------------------------------------
// Name: CBaseTexture()
// Desc: Sets initial values of member variables
//-----------------------------------------------------------------------------
CBaseTexture::CBaseTexture()
{
    m_sTexDirectory	   = NULL;
	m_nTexSizeBytes	   = 0;
	m_TexFormat		   = D3DFMT_UNKNOWN;
    m_pTexture		   = NULL;
}

//-----------------------------------------------------------------------------
// Name: ~CBaseTexture()
// Desc: Performs any needed cleanup before shutting down the object
//-----------------------------------------------------------------------------
CBaseTexture::~CBaseTexture()
{
	if ( m_sTexDirectory != NULL )
	{
		delete [] m_sTexDirectory;
		m_sTexDirectory = NULL;
	}

	// Because we allocate memory in another structure and point to it with m_pTexture
	// I simply set the variable to NULL without a delete
	m_pTexture = NULL;
}

//-----------------------------------------------------------------------------
// Name: CTexture()
// Desc: Sets initial values of member variables
//-----------------------------------------------------------------------------
CTexture::CTexture() : 
	CBaseTexture()
{
    m_nWidth  = 0;
	m_nHeight = 0;
	m_pResourceSysMemData = NULL;
	m_pResourceVidMemData = NULL;
}

//-----------------------------------------------------------------------------
// Name: ~CTexture()
// Desc: Performs any needed cleanup before shutting down the object
//-----------------------------------------------------------------------------
CTexture::~CTexture()
{
	// Free up texture memory
	if( m_pResourceSysMemData != NULL )
	{
		delete [] m_pResourceSysMemData;
		m_pResourceSysMemData = NULL;
	}

	if( m_pResourceVidMemData != NULL )
	{
		D3D_FreeContiguousMemory(m_pResourceVidMemData);
		m_pResourceVidMemData = NULL;
	}
}

//-----------------------------------------------------------------------------
// Name: CreateTexture()
// Desc: Creates an empty texture canvas of the specified dimensions
//-----------------------------------------------------------------------------
HRESULT CTexture::CreateTexture(int &nWidth, int &nHeight, D3DFORMAT format)
{
	if (FAILED(g_pd3dDevice->CreateTexture(nWidth, nHeight, 1, 0, format, D3DPOOL_MANAGED, (LPDIRECT3DTEXTURE8*)m_pTexture)))
	{
		return E_FAIL;
	}

	// Populate the texture member data (width, height, size, format)
	if(FAILED(GetTextureInfo()))
		return E_FAIL;

	return S_OK;
}

//-----------------------------------------------------------------------------
// Name: GetTextureSize()
// Desc: Updates the values of the texture dimensions
//-----------------------------------------------------------------------------
HRESULT CTexture::GetTextureInfo( void )
{
	D3DSURFACE_DESC sd;
	if((((LPDIRECT3DTEXTURE8)m_pTexture)->GetLevelDesc(0, &sd)) != D3D_OK )
	{
		return E_FAIL;
	}

	m_nWidth		= (int)sd.Width;
	m_nHeight		= (int)sd.Height;
	m_nTexSizeBytes	= sd.Size;
	m_TexFormat		= sd.Format;


	return S_OK;
}

//-----------------------------------------------------------------------------
// Name: LoadTexture()
// Desc: Loads a bundled file into a texture surface, and store the
//		 width, height, format, and size of the texture into member
//		 variables.
//-----------------------------------------------------------------------------
HRESULT CTexture::LoadTexture( const char* sFilepath )
{
	// Variables necessary for extracting bundled images from our .XBX files
	DWORD resource_NUM_RESOURCES	 = 1UL;
	DWORD resource_background_OFFSET = 0UL;

	// Copy filepath to the member variable
	m_sTexDirectory = new char [strlen(sFilepath) + 1];
	strcpy(m_sTexDirectory, sFilepath);

	if (m_sTexDirectory[0] == '\0')
	{
		delete [] m_sTexDirectory;
		m_sTexDirectory = NULL;
		return E_FAIL;
	}

    // Open the bundled file to read the XPR headers
	File inputFile;
	if(inputFile.open( m_sTexDirectory, READ ) != NO_ERR)
	{
		DbgPrint( "Unable to open texture file %s\n", sFilepath ); 
		ASSERT(false);
        return E_FAIL;
	}

    // Read in and verify the XPR magic header
    XPR_HEADER xprh;
    inputFile.read( (BYTE*)&xprh, sizeof(XPR_HEADER) );
    if( xprh.dwMagic != XPR_MAGIC_VALUE )
    {
        OutputDebugStringA( "ERROR: Invalid Xbox Packed Resource (.xpr) file" );
        inputFile.close();
        return E_INVALIDARG;
    }

    // Compute memory requirements
    DWORD dwSysMemDataSize = xprh.dwHeaderSize - sizeof(XPR_HEADER);
    DWORD dwVidMemDataSize = xprh.dwTotalSize - xprh.dwHeaderSize;

    // Allocate memory
    m_pResourceSysMemData = new BYTE[dwSysMemDataSize];
    m_pResourceVidMemData = (BYTE*)D3D_AllocContiguousMemory( dwVidMemDataSize, D3DTEXTURE_ALIGNMENT );

    // Read in the data from the file
    inputFile.read( m_pResourceSysMemData, dwSysMemDataSize );
    inputFile.read( m_pResourceVidMemData, dwVidMemDataSize );

    // Done with the file
    inputFile.close();
    
    // Loop over resources, calling Register()
    BYTE* pData = m_pResourceSysMemData;

    for( DWORD i = 0; i < resource_NUM_RESOURCES; i++ )
    {
        // Get the resource
        LPDIRECT3DRESOURCE8 pResource = (LPDIRECT3DRESOURCE8)pData;

        // Register the resource
        pResource->Register( m_pResourceVidMemData );
    
        // Advance the pointer
        switch( pResource->GetType() )
        {
            case D3DRTYPE_TEXTURE:       pData += sizeof(D3DTexture);       break;
            case D3DRTYPE_VOLUMETEXTURE: pData += sizeof(D3DVolumeTexture); break;
            case D3DRTYPE_CUBETEXTURE:   pData += sizeof(D3DCubeTexture);   break;
            case D3DRTYPE_VERTEXBUFFER:  pData += sizeof(D3DVertexBuffer);  break;
            case D3DRTYPE_INDEXBUFFER:   pData += sizeof(D3DIndexBuffer);   break;
            case D3DRTYPE_PALETTE:       pData += sizeof(D3DPalette);       break;
            default:                     return E_FAIL;
        }
    }

	m_pTexture = (LPDIRECT3DTEXTURE8)&m_pResourceSysMemData[ resource_background_OFFSET ];

	// Populate the texture member data (width, height, size, format)
	if(FAILED(GetTextureInfo()))
		return E_FAIL;

    return S_OK;
}

//-----------------------------------------------------------------------------
// Name: SizeOnDisk()
// Desc: Find the approximate size of the texture by getting the file size
//		 from the disk
//-----------------------------------------------------------------------------
DWORD CTexture::SizeOnDisk (const char* sFilepath )
{
	if(sFilepath == NULL)
		return -1;
	
	File textureFile;
	if(FAILED(textureFile.open(sFilepath, READ)))
	{
		// File cannot be opened
		return -1;
	}

	return textureFile.fileSize();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\xodash\XODashLib\texturecache.h ===
//-----------------------------------------------------------------------------
// File: TextureCache.h
//
// Desc: Header file for the main texture manager
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef TEXTURECACHE_H
#define TEXTURECACHE_H

#define TOTAL_TEXTURE_CACHE_SIZE 10000000

#include <list>
#include "texture.h"

//-----------------------------------------------------------------------------
// Name: class CTextureItem
// Desc: Base data type for each texture object in the texture cache
//-----------------------------------------------------------------------------
class CTextureItem
{
public:
	CTextureItem();
	~CTextureItem();

	CHAR		     *m_sTextureName;		// Holds the filename of the image
	long			 m_nID;					// The ID index of the texture
	BOOL		     m_bProtected;			// Specifies if the image should always stay in the cache
	DWORD		     m_nRefCount;			// Stores the number of times the texture has been referenced
	unsigned __int64 m_nLastTouched;		// Stores the tick count when the texture was last referenced
	CTexture	     *m_pTexture;			// The actual texture data
};

using namespace std;
typedef list<CTextureItem*>  TextureList;

//-----------------------------------------------------------------------------
// Name: class CTextureCache
// Desc: Base texture manager class
//-----------------------------------------------------------------------------
class CTextureCache
{
public:
	CTextureCache();
	~CTextureCache();

	LPDIRECT3DTEXTURE8		 FindTexture( long *texIndex, CHAR *sTexName );
	LPDIRECT3DVOLUMETEXTURE8 FindVolumeTexture( CHAR *sTexName );
	LPDIRECT3DCUBETEXTURE8	 FindCubeTexture( CHAR *sTexName );
	unsigned int			 TotalTextures( void );
	DWORD					 TotalCacheSize( void );
	unsigned __int64		 GetTextureTime( void );

private:
	TextureList	m_TextureCache;   // The linked list that will store the textures
	DWORD		m_nTotalBytes;    // The total number of bytes the Texture cache is currently using
	long		m_nTotalTextures; // The total number of textures in the texture cache (-1 if empty)

	LPDIRECT3DTEXTURE8 		 LoadTexture( long *texIndex, CHAR *sTexName );
	
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\xodash\XODashLib\texturecache.cpp ===
//-----------------------------------------------------------------------------
// File: TextureCache.cpp
//
// Desc: The texture cache is designed to store a linked list of textures that
//		 are available
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include "std.h"
#include "texturecache.h"
#include "xoconst.h"
#include "file.h"
#include "utilities.h"

extern char* g_pScenePath;

//-----------------------------------------------------------------------------
// Name: CTextureItem()
// Desc: Sets initial values of member variables
//-----------------------------------------------------------------------------
CTextureItem::CTextureItem()
{
	m_sTextureName  = NULL;		
	m_nID			= -1;					
	m_bProtected	= false;			
	m_nLastTouched	= 0;		
	m_nRefCount		= 0;			
	m_pTexture		= NULL;		
}

//-----------------------------------------------------------------------------
// Name: ~CTextureItem()
// Desc: Performs any needed cleanup before shutting down the object
//-----------------------------------------------------------------------------
CTextureItem::~CTextureItem()
{
	if( m_sTextureName != NULL )
	{
		delete [] m_sTextureName;
		m_sTextureName = NULL;
	}

	if( m_pTexture != NULL )
	{
		delete m_pTexture;
		m_pTexture = NULL;
	} 
}

//-----------------------------------------------------------------------------
// Name: CTextureCache()
// Desc: Sets initial values of member variables
//-----------------------------------------------------------------------------
CTextureCache::CTextureCache()
{
	m_nTotalBytes	 = 0;
	m_nTotalTextures = -1;
}

//-----------------------------------------------------------------------------
// Name: ~CTextureCache()
// Desc: Performs any needed cleanup before shutting down the object
//-----------------------------------------------------------------------------
CTextureCache::~CTextureCache()
{
	// Clean up the texture items in the texture cache
	TextureList::iterator i;
	for(i = m_TextureCache.begin(); i != m_TextureCache.end(); i++)
	{
		if ( *i != NULL )
			delete (*i);
	}

	m_TextureCache.clear();
}

//-----------------------------------------------------------------------------
// Name: FindTexture()
// Desc: Find texture is the main function for getting a pointer to a texture
//		 on the Xbox.  It will first traverse the existing list of textures in
//		 the texture cache until it finds the texture, then it will return the
//		 pointer to that texture.  If texture is not found in the cache, the
//		 function will clear out the necessary space for the texture, and load
//		 it into the cache.  It will then return the pointer to this newly
//		 loaded texture.
//-----------------------------------------------------------------------------
LPDIRECT3DTEXTURE8 CTextureCache::FindTexture( long *texIndex, CHAR *sTexName )
{
	// Check to make sure the texture string is passed in
	if(sTexName == NULL)
		return NULL;

	// If the texture hasn't already been indexed, load it for the first time and assign an index
	if(*texIndex < 0)
	{
		// Traverse the texture cache to see if the texture is already loaded
		TextureList::iterator i;
		for(i = m_TextureCache.begin(); i != m_TextureCache.end(); i++)
		{
			if(strcmp((*i)->m_sTextureName, sTexName) == 0)
			{
				if((*i)->m_pTexture != NULL)
				{
					// Found a texture match in the cache, set the index and return the texture
					*texIndex = (*i)->m_nID;
					(*i)->m_nRefCount++;
					(*i)->m_nLastTouched = GetTextureTime();
					return (LPDIRECT3DTEXTURE8)(*i)->m_pTexture->m_pTexture;
				}
			}
		}

		// The requested texture isn't currently in the cache, so load it and return the 
		// proper texture index
		return LoadTexture( &*texIndex, sTexName );
	}
	else   
	{
		// Traverse the texture cache to see if the texture is already loaded
		TextureList::iterator i;
		i = m_TextureCache.begin();
		for(long j = 0; j < *texIndex; j++)
		{
			i++;
		}

		if((*i)->m_pTexture != NULL)
		{
			// Found a texture match in the cache, set the index and return the texture
			(*i)->m_nRefCount++;
			(*i)->m_nLastTouched = GetTextureTime();
			return (LPDIRECT3DTEXTURE8)(*i)->m_pTexture->m_pTexture;
		}

		// The texture has been indexed before, so traverse to that index point and make
		// sure that the file is still in memory
		return LoadTexture( &*texIndex, sTexName );
	}

	return NULL;
}

//------------------------------------------------------------------------------
// Name: LoadTexture()
// Desc: A local function designed to do all of the necessary loading of a texture
//		 file into the cache
//------------------------------------------------------------------------------

LPDIRECT3DTEXTURE8 CTextureCache::LoadTexture( long *texIndex, CHAR *sTexName )
{
	// Get an approximate file size of the texture on disk
	char *xbxPath		 = new char[wcslen(XBX_PATH) + 1];
	Ansi(xbxPath, XBX_PATH, wcslen(XBX_PATH) + 1);

	char *pTexturePath = new char[strlen(xbxPath) + strlen(sTexName) + 1];
	sprintf(pTexturePath, "%s%s", xbxPath, sTexName);
	CTexture *pTexture = new CTexture();
	DWORD nTextureSize = pTexture->SizeOnDisk(pTexturePath);

	if(nTextureSize == -1)		
	{
		// Texture was not found in the specified location
		delete [] pTexturePath;
		delete pTexture;
		delete [] xbxPath;	 
		return NULL;
	}

	// Check if the texture cache needs to clear an entry to import a new texture
	m_nTotalBytes = TotalCacheSize();
	
	// Traverse through the texture cache, and LRU textures until we have enough space
	while((m_nTotalBytes + nTextureSize) > TOTAL_TEXTURE_CACHE_SIZE)
	{
		unsigned __int64 nOldestTickCount = 0xffffffffffffffff;
		TextureList::iterator iOldestTextureItem;

		// The current texture cache, plus the addition of the new texture
		// is currently too large.  Find the LRU texture, and remove it from the cache
		TextureList::iterator i;
		for(i = m_TextureCache.begin(); i != m_TextureCache.end(); i++)
		{
			// Is the current texture older than the previous?
			if((*i)->m_pTexture != NULL)
			{
				if((*i)->m_nLastTouched < nOldestTickCount)
				{
					nOldestTickCount = (*i)->m_nLastTouched;
					iOldestTextureItem = i;
				}
			}
		}

		// Remove the oldest referenced texture from the cache, but leave it's info in the linked list
		m_nTotalBytes -= (*iOldestTextureItem)->m_pTexture->m_nTexSizeBytes;
		delete (*iOldestTextureItem)->m_pTexture;
		(*iOldestTextureItem)->m_pTexture = NULL;
	}

	// Texture cache has enough room to store the texture.  Push the texture on
	// to the texture cache

	if(FAILED(pTexture->LoadTexture(pTexturePath)))
	{
		delete [] pTexturePath;
		delete pTexture;
		delete [] xbxPath;	
		return NULL;
	}
	delete [] pTexturePath;
	delete [] xbxPath;	

	// If the texture hasn't already been indexed, load it for the first time and assign an index
	if(*texIndex < 0)
	{
		m_nTotalTextures += 1;

		CTextureItem *pNewTexItem = new CTextureItem();

		pNewTexItem->m_sTextureName = new char[strlen(sTexName) + 1];
		strcpy(pNewTexItem->m_sTextureName, sTexName);
		pNewTexItem->m_nLastTouched = GetTextureTime();
		pNewTexItem->m_nRefCount	= 1;
		pNewTexItem->m_nID			= m_nTotalTextures;
		*texIndex					= m_nTotalTextures;

		pNewTexItem->m_pTexture		= pTexture;

		m_TextureCache.push_back(pNewTexItem);
	}
	else
	{
		// Texture has already been loaded, so just update the pointer and member data
		TextureList::iterator i;
		i = m_TextureCache.begin();
		for(long j = 0; j < *texIndex; j++)
			i++;

		(*i)->m_pTexture	 = pTexture;
		(*i)->m_nLastTouched = GetTextureTime();
		(*i)->m_nRefCount	 = 1;
	}

	// Return the pointer to the recently loaded texture
	return (LPDIRECT3DTEXTURE8)pTexture->m_pTexture;
}

//-----------------------------------------------------------------------------
// Name: GetCurrentTime()
// Desc: Returns the current time from the system and parses it to a friendly
//		 format for us
//-----------------------------------------------------------------------------
unsigned __int64 CTextureCache::GetTextureTime( void )
{
	LPFILETIME nCurrentTime = new FILETIME();
	GetSystemTimeAsFileTime(nCurrentTime);
	unsigned __int64 nTime = nCurrentTime->dwHighDateTime << 32 | nCurrentTime->dwLowDateTime;
	delete nCurrentTime;
	return nTime;
}

//-----------------------------------------------------------------------------
// Name: TotalCacheSize()
// Desc: Returns the current size of the texture cache in bytes
//-----------------------------------------------------------------------------
DWORD CTextureCache::TotalCacheSize( void )
{
	DWORD nTotalBytes = 0;
	TextureList::iterator i;
	for(i = m_TextureCache.begin(); i != m_TextureCache.end(); i++)
	{
		// summing the total sizes of all of the textures
		if((*i)->m_pTexture != NULL)
			nTotalBytes += (*i)->m_pTexture->m_nTexSizeBytes;
	}

	return nTotalBytes;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\xodash\XODashLib\tgl.cpp ===
/*************************************************************************************************\
tgl.cpp		    : IMplementation for the TG_Shape and TG_TypeShape classes.  These do the brunt of the
                    the work for our graphics.  They render, and load
                    and save themselves to files.
Creation Date		: 1/8/2002 11:08:29 AM
Copyright Notice	: (C) 2000 Microsoft
Author				: Heidi Gaertner
//-------------------------------------------------------------------------------------------------
Notes				: 
\*************************************************************************************************/
#include "std.h"
#include <stdio.h>
#include <io.h>

#ifndef TGL_H


#include "tgl.h"
#endif


#include "utilities.h"
#include "globals.h"
#include "File.h"
#define MAX_SCAN_LENGTH 256

// global data used during save time
DWORD TG_Shape::            s_dwNumFrames= 0;
DWORD TG_Shape::            s_dwFrameSpace= 0;
DWORD TG_Shape::            s_dwSubsetSpace= 0;
DWORD TG_Shape::            s_dwIndicesSpace= 0;
DWORD TG_Shape::            s_dwVerticesSpace= 0;
DWORD TG_Shape::            s_dwAnimSpace= 0;
DWORD TG_Shape::            s_dwMeshFileOffset= 0;
DWORD TG_Shape::            s_dwSubsetFileOffset= 0;
DWORD TG_Shape::            s_dwIndicesFileOffset= 0;
DWORD TG_Shape::            s_dwVerticesFileOffset = 0;
DWORD TG_Shape::            s_dwAnimFileOffset = 0;



// stuff to help with memory problems
#ifdef FIND_MEMORY_LEAK
void* __cdecl operator new(size_t nSize, const char* lpszFileName, int nLine);
void* __cdecl operator new[](size_t nSize, const char* lpszFileName, int nLine);

#define DEBUG_NEW new(__FILE__, __LINE__)
#undef new
#define new DEBUG_NEW
#endif
		


//-------------------------------------------------------------------------------
// ASE File Parse String Macros
#define ASE_OBJECT				"*GEOMOBJECT {"
#define ASE_HELP_OBJECT			"*HELPEROBJECT {"
#define ASE_MESH				"*MESH {"
#define ASE_NUM_VERTEX			"*MESH_NUMVERTEX"
#define ASE_NUM_FACE			"*MESH_NUMFACES"
#define ASE_VERTEX_LIST			"*MESH_VERTEX_LIST {"
#define ASE_FACE_LIST			"*MESH_FACE_LIST {"
#define ASE_NUM_TVERTEX			"*MESH_NUMTVERTEX"
#define ASE_TVERTLIST			"*MESH_TVERTLIST {"
#define ASE_NUM_TVFACES			"*MESH_NUMTVFACES"
#define ASE_TFACELIST			"*MESH_TFACELIST {"
#define ASE_NUM_CVERTEX			"*MESH_NUMCVERTEX"
#define ASE_CVERTLIST			"*MESH_CVERTLIST {"
#define ASE_NUM_CVFACES			"*MESH_NUMCVFACES"
#define	ASE_CFACELIST			"*MESH_CFACELIST {"
#define ASE_MESH_NORMALS		"*MESH_NORMALS {"

#define ASE_NODE_NAME			"*NODE_NAME"
#define ASE_GROUP_NAME          "GROUP"
#define ASE_NODE_POS			"*TM_POS"

#define ASE_ANIMATION			"*TM_ANIMATION {"
#define ASE_ANIM_ROT_HEADER		"*CONTROL_ROT_TRACK {"
#define ASE_ANIM_ROT_SAMPLE		"*CONTROL_ROT_SAMPLE"
#define ASE_ANIM_POS_HEADER		"*CONTROL_POS_TRACK {"
#define ASE_ANIM_POS_SAMPLE		"*CONTROL_POS_SAMPLE"
#define ASE_ANIM_FIRST_FRAME	"*SCENE_FIRSTFRAME"
#define ASE_ANIM_LAST_FRAME		"*SCENE_LASTFRAME"
#define ASE_ANIM_FRAME_SPEED	"*SCENE_FRAMESPEED"
#define ASE_ANIM_TICKS_FRAME	"*SCENE_TICKSPERFRAME"

#define ASE_FACE_NORMAL_ID		"*MESH_FACENORMAL"
#define ASE_VERTEX_NORMAL_ID	"*MESH_VERTEXNORMAL"
#define ASE_MESH_CFACE_ID		"*MESH_CFACE"
#define ASE_MESH_VERTCOL_ID		"*MESH_VERTCOL"
#define ASE_MESH_TFACE_ID		"*MESH_TFACE"
#define ASE_MESH_TVERT_ID		"*MESH_TVERT"
#define ASE_MESH_FACE_ID		"*MESH_FACE"
#define ASE_MESH_VERTEX_ID		"*MESH_VERTEX"

#define ASE_MATERIAL_COUNT		"*MATERIAL_COUNT"
#define ASE_SUBMATERIAL_COUNT	"*NUMSUBMTLS"
#define ASE_MATERIAL_ID			"*MATERIAL"
#define ASE_MATERIAL_BITMAP_ID	"*BITMAP "
#define ASE_MATERIAL_CLASS		"*MATERIAL_CLASS"
#define ASE_MATERIAL_TWOSIDED	"*MATERIAL_TWOSIDED"
#define ASE_FACE_MATERIAL_ID	"*MESH_MTLID"
#define ASE_MATERIAL_REF		"*MATERIAL_REF"
#define ASE_ROTATION_AXIS       "*TM_ROTAXIS"
#define ASE_ROTATION_ANGLE            "*TM_ROTANGLE"



//-------------------------------------------------------------------------------
/*extern bool useVertexLighting;
extern bool useFaceLighting;
extern bool hasGuardBand;
extern bool useFog;
extern DWORD BaseVertexColor;
bool drawOldWay = false;
extern bool useShadows;
bool useLocalShadows = false;

bool renderTGLShapes = true;

bool silentMode s false;*/		//Used for automated builds to keep errors from popping up.




//-------------------------------------------------------------------------------
// Frees memory and resets locals to defaults.
void TG_TypeNode::destroy (void)
{
	init();
}

//-------------------------------------------------------------------------------
TG_TypeNode::TG_TypeNode( TG_TypeNode& src )
{
    m_nodeCenter = src.m_nodeCenter;
	strcpy( m_strNodeId, src.m_strNodeId );
}

//-------------------------------------------------------------------------------
// virtual copy c'tor
TG_TypeNode* TG_TypeNode::Copy()
{
    return new TG_TypeNode( *this );
}

//-------------------------------------------------------------------------------
TG_TypeNode::TG_TypeNode( XBMESH_FRAME* pFrameData )
{
    init();

    // Frame info
    strcpy( m_strNodeId, pFrameData->m_strName );

    // Mesh info
    m_nodeCenter          = D3DXVECTOR3(0,0,0);
}



//-------------------------------------------------------------------------------
TG_TypeShape::TG_TypeShape( TG_TypeShape& src )
: TG_TypeNode( src )
{
    m_nNumVertices  = src.m_nNumVertices;
    m_nFVF          = src.m_nFVF;
    m_nFVFSize      = src.m_nFVFSize;
    m_nNumFaces     = src.m_nNumFaces;
    m_nMaterialCount= src.m_nMaterialCount;
    m_pMem          = NULL;
    m_pIndexBuffer  = NULL;

    m_VertexBuffer.Common =  D3DCOMMON_TYPE_VERTEXBUFFER | D3DCOMMON_VIDEOMEMORY | 1;


    if ( m_nNumVertices )
    {
        m_pMem = (BYTE*)D3D_AllocContiguousMemory( m_nFVFSize * m_nNumVertices, D3DVERTEXBUFFER_ALIGNMENT );
        BYTE* pMem = NULL;
        src.m_VertexBuffer.Lock( 0, 0, &pMem, 0 );
        memcpy( m_pMem, pMem, m_nFVFSize * m_nNumVertices );
        m_VertexBuffer.Data = 0;
        m_VertexBuffer.Register( m_pMem );
        src.m_VertexBuffer.Unlock();
    }

    if ( src.m_pIndexBuffer )
    {
        g_pd3dDevice->CreateIndexBuffer( sizeof ( WORD ) * m_nNumFaces * 3,  0, D3DFMT_D16, 0, &m_pIndexBuffer );
        WORD* pOldIndices;
        WORD* pIndices;
        src.m_pIndexBuffer->Lock( 0, 0, (BYTE**)&pOldIndices, 0 );
        m_pIndexBuffer->Lock( 0, 0, (BYTE**)&pIndices, 0 );
        memcpy( pIndices, pOldIndices, m_nNumFaces * 3*sizeof(WORD) );
        m_pIndexBuffer->Unlock();
        src.m_pIndexBuffer->Unlock();

    }

    m_pMaterialIDs = new XBMESH_SUBSET[m_nMaterialCount];

    for ( unsigned long i = 0; i < m_nMaterialCount; i++ )
    {
        m_pMaterialIDs[i] = src.m_pMaterialIDs[i];
    }

}

//-------------------------------------------------------------------------------
// virtual copy c'tor
TG_TypeNode* TG_TypeShape::Copy()
{
    return new TG_TypeShape( *this );
}



//-------------------------------------------------------------------------------
//Frees memory and resets locals to defaults.
void TG_TypeShape::destroy (void)

{
    // do not release the vertex buffer, since QueryInterface was never called
    if ( m_pMaterialIDs )
		delete [] m_pMaterialIDs;

	if ( m_pIndexBuffer )
		m_pIndexBuffer->Release();

	m_pMaterialIDs = NULL;
	m_pIndexBuffer = NULL;

    if ( m_pMem ) // for aseconv only ... otherwise the scene cleans up ALL the memory
    {
        D3D_FreeContiguousMemory( m_pMem );
        m_pMem = NULL;

    }

}	

//-------------------------------------------------------------------------------
//Frees memory and resets locals to defaults.
void TG_Shape::Destroy (void)
{

    TG_Shape* pShape = m_pChild;
    while( pShape )
    {
        TG_Shape* pTmpShape = pShape->m_pNext;
        delete pShape;
        pShape = pTmpShape;
    }

    m_pChild = NULL;
    //THIS IS CORRECT!!!!
	// They come from a common pool now, Deleteing them would be BAD!!
    // unless we read from an ASE
//    if ( m_bDeleteType )
      delete m_pMyType;

    m_pMyType = NULL;

    if ( !m_bCommonMemory )
    {
         if ( m_Animation.m_pQuat )
                delete [] m_Animation.m_pQuat;

         if ( m_Animation.m_pPos )
                delete [] m_Animation.m_pPos;
    }

    m_Animation.m_pQuat = NULL;
    m_Animation.m_pPos = NULL;

}	

//-------------------------------------------------------------------------------


HRESULT GetTextureIndices( BYTE* aseBuffer, long faceNum, long& t0, long& t1, long& t2 )
{
	char faceId[256];
	sprintf(faceId,"%s",ASE_NUM_TVFACES);

	char numberData[256];

	char* faceData = strstr((char *)aseBuffer,faceId);
	if (faceData)
	{
		faceData += strlen(faceId);
 		GetNumberData(faceData,numberData);

		sprintf(faceId,"%s %d",ASE_MESH_TFACE_ID,faceNum);

		faceData = strstr(faceData,faceId);
		_ASSERT(faceData != NULL);

		faceData += strlen(faceId);
			
		GetNumberData(faceData,numberData);
		t0 = atol(numberData);
		faceData += strlen(numberData)+1;
			
		GetNumberData(faceData,numberData);
		t1 = atol(numberData);
		faceData += strlen(numberData)+1;

		GetNumberData(faceData,numberData);
		t2 = atol(numberData);

		return S_OK;
	}

	return -1;
}

HRESULT GetTextureUVs( BYTE* aseBuffer, long index, float& u, float& v )
{
	char numberData[256];
	
	u = 0.f;
	v = 0.f;
	char tmpBuffer[255];
	//Load up the TVERT0
	sprintf(tmpBuffer,"%s",ASE_NUM_TVERTEX);

	char* faceData = strstr((char *)aseBuffer,tmpBuffer);
	_ASSERT(faceData != NULL);

	sprintf(tmpBuffer,"%s %d",ASE_MESH_TVERT_ID,index);

	faceData = strstr(faceData,tmpBuffer);
	_ASSERT(faceData != NULL);

	faceData += strlen(tmpBuffer);
		
	GetNumberData(faceData,numberData);
	u = (float)atof(numberData);

	if ((u > 100.0f) || (u < -100.0f))
	{
#ifdef _DEBUG
//		if (!silentMode)
//			PAUSE(("WARNING: U0 is %f which is out of range in Shape %s!",u,fileName));
#endif
		u = 0.0f;
	}

	faceData += strlen(numberData)+1;
		
	GetNumberData(faceData,numberData);
	v = 1.0f - (float)atof(numberData);

	if ((v > 100.0f) || (v < -100.0f))
	{
#ifdef _DEBUG
//		if (!silentMode)
//			PAUSE(("WARNING: V0 is %f which is out of range in Shape %s!",listOfTypeTriangles[i].uvdata.v0,fileName));
#endif
		v = 0.0f;
	}

	return 0;
}


// Read in color data
HRESULT getColorData( BYTE* aseBuffer, long cIndex1, long cIndex2, long cIndex3, unsigned long& color1,	
						unsigned long& color2, unsigned long& color3 )
{
	long alpha = 0xa8; // this needs to be passed in
	char faceId[256];

	char numberData[256];

	sprintf(faceId,"%s",ASE_NUM_CVERTEX);

	char* faceData = strstr((char *)aseBuffer,faceId);
	_ASSERT(faceData != NULL);

	sprintf(faceId,"%s %d",ASE_MESH_VERTCOL_ID,(long)cIndex1);

	faceData = strstr(faceData,faceId);
	_ASSERT(faceData != NULL);

	faceData += strlen(faceId);
		
	GetNumberData(faceData,numberData);
	float red = (float)atof(numberData);

	faceData += strlen(numberData)+1;
		
	GetNumberData(faceData,numberData);
	float green = (float)atof(numberData);

	faceData += strlen(numberData)+1;

	GetNumberData(faceData,numberData);
	float blue = (float)atof(numberData);

	DWORD redC = (DWORD)(red * 255.f + .5);
	DWORD greenC = (DWORD)(green * 255.f + .5);
	DWORD blueC = (DWORD)(blue * 255.f + .5);

	color1 = (alpha << 24) + (redC << 16) + (greenC << 8) + blueC;

	//Load up the VERTCOL1
	sprintf(faceId,"%s",ASE_NUM_CVERTEX);

	faceData = strstr((char *)aseBuffer,faceId);
	_ASSERT(faceData != NULL);

	sprintf(faceId,"%s %d",ASE_MESH_VERTCOL_ID,(long)cIndex2);

	faceData = strstr(faceData,faceId);
	_ASSERT(faceData != NULL);

	faceData += strlen(faceId);
		
	GetNumberData(faceData,numberData);
	red = (float)atof(numberData);

	faceData += strlen(numberData)+1;
		
	GetNumberData(faceData,numberData);
	green = (float)atof(numberData);

	faceData += strlen(numberData)+1;

	GetNumberData(faceData,numberData);
	blue = (float)atof(numberData);

	redC = (DWORD)(red * 255.f + .5);
	greenC = (DWORD)(green * 255.f + .5);
	blueC = (DWORD)(blue * 255.f + .5);
	
	color2 = (alpha << 24) + (redC << 16) + (greenC << 8) + blueC;

	//Load up the VERTCOL2
	sprintf(faceId,"%s",ASE_NUM_CVERTEX);

	faceData = strstr((char *)aseBuffer,faceId);
	_ASSERT(faceData != NULL);

	sprintf(faceId,"%s %d",ASE_MESH_VERTCOL_ID,(long)cIndex3);

	faceData = strstr(faceData,faceId);
	_ASSERT(faceData != NULL);

	faceData += strlen(faceId);
		
	GetNumberData(faceData,numberData);
	red = (float)atof(numberData);

	faceData += strlen(numberData)+1;
		
	GetNumberData(faceData,numberData);
	green = (float)atof(numberData);

	faceData += strlen(numberData)+1;

	GetNumberData(faceData,numberData);
	blue = (float)atof(numberData);

	redC = (DWORD)(red * 255.f + .5);
	greenC = (DWORD)(green * 255.f + .5);
	blueC = (DWORD)(blue * 255.f + .5);
	
	color3 = (alpha << 24) + (redC << 16) + (greenC << 8) + blueC;

	return 0;
}

////////////////////////////////////////////////////////////////////////////
// Hack for figuring out how much room we have for text
// this will never work for seriously rotated text...
void        TG_TypeShape::GetRectDims( float& width, float& height )
{
    width = 0;
    height = 0;

    ASSERT( m_nNumVertices > 3 );
    
    if ( m_nNumVertices > 3 )
    {
        BYTE* pBuffer = NULL;
        m_VertexBuffer.Lock(0, 0, &pBuffer, 0);

        // need to figure out the size of the vertex
        D3DVECTOR* v1 = (D3DVECTOR*)pBuffer;
        D3DVECTOR* v2 = (D3DVECTOR*)(pBuffer + m_nFVFSize);
        D3DVECTOR* v3 = (D3DVECTOR*)(pBuffer + 2*m_nFVFSize);
        D3DVECTOR* v4 = (D3DVECTOR*)(pBuffer + 3*m_nFVFSize);

        width = (float)fabs(v1->x - v2->x);
        float fWidth2 = (float)fabs(v3->x - v1->x);

        height = (float)fabs(v1->y - v2->y);
        float fHeight2 = (float)fabs(v3->y - v1->y);

        if ( fWidth2 > width )
        {
            width =  fWidth2;
        }
        if ( fHeight2 > height )
        {
            height = fHeight2;

        }


        m_VertexBuffer.Unlock();

    }
}
////////////////////////////////////////////////////////////////////////////
// this function will never work on under than the x/y plane...
void        TG_TypeShape::GetRectDimsAndRecenter(float& width, float& height, float& depth)
{
    width = 0;
    height = 0;

    ASSERT( m_nNumVertices > 3 );
    
    if ( m_nNumVertices > 3 )
    {
        BYTE* pBuffer = NULL;
        m_VertexBuffer.Lock(0, 0, &pBuffer, 0);

        // need to figure out the size of the vertex
        D3DVECTOR* v1 = (D3DVECTOR*)pBuffer;
        D3DVECTOR* v2 = (D3DVECTOR*)(pBuffer + m_nFVFSize);
        D3DVECTOR* v3 = (D3DVECTOR*)(pBuffer + 2*m_nFVFSize);
        D3DVECTOR* v4 = (D3DVECTOR*)(pBuffer + 3*m_nFVFSize);

        width = (float)fabs(v1->x - v2->x);
        float fNewCenterX = (v1->x + v2->x)/2.f;

        float fWidth2 = (float)fabs(v3->x - v1->x);

        height = (float)fabs(v1->z - v2->z);
        float fHeight2 = (float)fabs(v3->z - v1->z);
        float fNewCenterZ = (v1->z + v2->z)/2.f;

        depth = (float)fabs(v1->y - v2->y);
        float fDepth2 = (float)fabs(v3->y - v1->y);
        float fNewCenterY = (v1->y + v2->y)/2.f;


        if ( fWidth2 > width )
        {
            fNewCenterX = (v3->x + v1->x)/2.f;
            width =  fWidth2;
        }
        if ( fHeight2 > height )
        {
            height = fHeight2;
            fNewCenterZ = (v1->z + v3->z)/2.f;

        }
        if ( fDepth2 > depth )
        {
            depth = fDepth2;
            fNewCenterY = (v1->z + v3->z)/2.f;
        }

        m_nodeCenter.x += fNewCenterX;
        m_nodeCenter.z += fNewCenterZ;
        m_nodeCenter.y += fNewCenterY;


        m_VertexBuffer.Unlock();

    }
}


long TG_TypeShape::ParseASENoTextures (BYTE *aseBuffer, const char *fileName, const D3DVECTOR& parentLoc)
{
	m_nFVF = NORMAL_VERTEX_FVF;
	m_nFVFSize = sizeof( TG_NormalVertex );
	
	//------------------------------------------
	// Store off the Node Names.
	char *nodeName = strstr((char *)aseBuffer,ASE_NODE_NAME);
	if (!nodeName )
    {
        nodeName = strstr((char *)aseBuffer,ASE_GROUP_NAME);
      	nodeName += strlen(ASE_GROUP_NAME)+1;

    }
    else
    {
       	nodeName += strlen(ASE_NODE_NAME)+1;
    }

	_ASSERT(nodeName != NULL);
	char nodeString[1024];
	GetNameData(nodeName,nodeString);

    ASSERT( strlen( nodeString ) < 32 );

	strncpy(m_strNodeId,nodeString,32);
    CharUpperA( m_strNodeId );
	unsigned long maxMaterialCount = 0;

	//----------------------------------------------------
	// Store off NODE ABS position for heirarchy
	nodeName = strstr((char *)aseBuffer,ASE_NODE_POS);
    if ( !nodeName ) // this is a group
        return -1;

	_ASSERT(nodeName != NULL);

	nodeName += strlen(ASE_NODE_POS)+1;

	char numData[512];

	GetNumberData(nodeName,numData);
	m_nodeCenter.x = (float)atof(numData);
	nodeName += strlen(numData)+1;

	GetNumberData(nodeName,numData);
	m_nodeCenter.y = (float)atof(numData);
	nodeName += strlen(numData)+1;

	GetNumberData(nodeName,numData);
	m_nodeCenter.z = (float)atof(numData);

//    m_nodeCenter += parentLoc;

    m_fMinZDepth = -99999999999.f;



	//----------------------------------------
	// Find the Number of Vertices
	char *vertexCount = strstr((char *)aseBuffer,ASE_NUM_VERTEX);

    if ( !vertexCount ) // dummy object, probably just animates
        return -1;
	_ASSERT(vertexCount != NULL);
		
	vertexCount += strlen(ASE_NUM_FACE)+1;
	long numTmpVertices = atol(vertexCount);
	if (numTmpVertices == 0)			//NO Data for this node.  WARN and then do NOT allocate anything!
	{
#ifdef _DEBUG
//		if (!silentMode)
//			PAUSE(("WARNING: No Vertices for Shape Node %s in Shape %s!",m_strNodeID,fileName));
#endif
		init();

		return (0);
	}

	//---------------------------------------
	// Find the material index of the object
	//---------------------------------------
	char *matIndex = strstr((char *)aseBuffer,ASE_MATERIAL_REF);
    unsigned long nMaterialNum = 0;

	if ( matIndex )
    {
    // Pull the ASE specific material index
	    matIndex += strlen(ASE_MATERIAL_REF)+1;
	    nMaterialNum = atol(matIndex);
    }

	// Now find the cooresponding material index in the Material Library
	long nMaterialIndex = g_MaterialLib.ReturnIndex(nMaterialNum);

	//---------------------------------------
	// Find the Number of faces
	//---------------------------------------
	char *faceCount = strstr((char *)aseBuffer,ASE_NUM_FACE);
	_ASSERT(faceCount != NULL);
			
	faceCount += strlen(ASE_NUM_FACE)+1;
	long numFaces = atol(faceCount);
	if ( numFaces )
	{
		m_nNumVertices = numTmpVertices;
        m_nNumFaces = numFaces;

		WORD* pIndices = new WORD[numFaces*3];

        // going to deliberately allocate too much memory here, we can't always share normals, 
        // too many square objects
        BYTE* pVertexMem = (BYTE*)D3D_AllocContiguousMemory( numFaces * 3 * sizeof( TG_NormalVertex ), D3DVERTEXBUFFER_ALIGNMENT );

		g_pd3dDevice->CreateIndexBuffer( numFaces * 3 * sizeof( WORD ), 0, D3DFMT_D16, 0, &m_pIndexBuffer);

		// going to store materials, and then sort them later
		long*	tmpMaterialArray = new long[ numFaces ];
		memset( tmpMaterialArray, 0, sizeof ( long ) * numFaces );
		
		TG_NormalVertex* finalVertices = (TG_NormalVertex*)pVertexMem;
		memset(finalVertices,0xff,sizeof(TG_NormalVertex) * numFaces * 3);

		long*	normalCounts = new long[ numFaces * 3];
		memset( normalCounts, 0, sizeof( long ) *  numFaces * 3 );

        long*   altVertex = new long[numFaces * 3];
        memset( altVertex, 0, sizeof( long ) *  numFaces * 3 );

		for (long i=0;i<numTmpVertices;i++)
		{
			char numberData[256];

			//------------------------------------------------
			// First the Vertex Position
			char vertexID[256];
			sprintf(vertexID,"%s% 5d",ASE_MESH_VERTEX_ID,i);

			char *vertexData = strstr((char *)aseBuffer,vertexID);
			_ASSERT(vertexData != NULL);
				
			vertexData += strlen(vertexID)+1;

			GetNumberData(vertexData,numberData);
			vertexData += strlen(numberData)+1;
			finalVertices[i].position.x = (float)atof(numberData);
			finalVertices[i].position.x -= m_nodeCenter.x;

			GetNumberData(vertexData,numberData);
			vertexData += strlen(numberData)+1;
			finalVertices[i].position.y = (float)atof(numberData);
			finalVertices[i].position.y -= m_nodeCenter.y;

			GetNumberData(vertexData,numberData);
			finalVertices[i].position.z = (float)atof(numberData);
			finalVertices[i].position.z -= m_nodeCenter.z;
            finalVertices[i].normal.x = 0.f;
            finalVertices[i].normal.y = 0.f;
            finalVertices[i].normal.z = 0.f;

            if ( finalVertices[i].position.y > m_fMinZDepth )
                m_fMinZDepth = finalVertices[i].position.y;

		}


        char* prevFace = (char*)aseBuffer;
        char* prevNormal = (char*)aseBuffer;

		for (i=0;i<numFaces;i++)
		{
			char numberData[256];

			//-----------------------------------------------
			// First the Vertices for the face
			char faceId[256];
			sprintf(faceId,"%s% 5d:",ASE_MESH_FACE_ID,i);

			char *faceData = strstr((char *)prevFace,faceId);
			_ASSERT(faceData != NULL);

            prevFace = faceData;

			faceData = strstr(faceData,"A:");
			_ASSERT(faceData != NULL);
				
			GetNumberData(faceData,numberData);
			long index0 = atol(numberData);

			faceData = strstr(faceData,"B:");
			_ASSERT(faceData != NULL);

			GetNumberData(faceData,numberData);
			long index1 = atol(numberData);

			faceData = strstr(faceData,"C:");
			_ASSERT(faceData != NULL);
		
			GetNumberData(faceData,numberData);
			long index2 = atol(numberData);

			faceData = strstr( faceData, "MESH_MTLID " );
			GetNumberData(faceData,numberData);
			unsigned long matrlID = atol(numberData );

//			tmpMaterialArray[i] = matrlID;
			tmpMaterialArray[i] = nMaterialIndex;
//			if ( matrlID >= maxMaterialCount ) // store the number so we can make the array
//				maxMaterialCount = matrlID + 1;


            D3DXVECTOR3 v1, v2, tmpNormal;
            v1 = finalVertices[index2].position - finalVertices[index1].position;
            v2 = finalVertices[index0].position - finalVertices[index1].position;
            

            D3DXVec3Cross( &tmpNormal, &v2, &v1 );
            D3DXVec3Normalize( &tmpNormal, &tmpNormal );

            // figure out what the avg normal is now, if this one is more than ~10deg off
            // then make a new vertex with a new normal, move around the index
            if ( CreateNewNormal( tmpNormal, finalVertices, normalCounts, index0, altVertex ) )
            {
                finalVertices[m_nNumVertices] = finalVertices[index0];
                finalVertices[m_nNumVertices].normal.x = finalVertices[m_nNumVertices].normal.y = 
                        finalVertices[m_nNumVertices].normal.z = 0.f;

                altVertex[index0] = m_nNumVertices;
                index0 = m_nNumVertices;
            
                m_nNumVertices++;
            }
           

            
            if ( CreateNewNormal( tmpNormal, finalVertices, normalCounts, index1, altVertex ) )
            {
                finalVertices[m_nNumVertices] = finalVertices[index1];
                finalVertices[m_nNumVertices].normal.x = finalVertices[m_nNumVertices].normal.y = 
                        finalVertices[m_nNumVertices].normal.z = 0.f;
                altVertex[index1] = m_nNumVertices;
                index1 = m_nNumVertices;

                m_nNumVertices++;
            }

            if ( CreateNewNormal( tmpNormal, finalVertices, normalCounts, index2, altVertex ) )
            {
                finalVertices[m_nNumVertices] = finalVertices[index2];
                finalVertices[m_nNumVertices].normal.x = finalVertices[m_nNumVertices].normal.y = 
                        finalVertices[m_nNumVertices].normal.z = 0.f;
                altVertex[index2] = m_nNumVertices;
                index2 = m_nNumVertices;

                m_nNumVertices++;
            }
  
            finalVertices[index0].normal += tmpNormal;
            finalVertices[index1].normal += tmpNormal;
            finalVertices[index2].normal += tmpNormal;


            normalCounts[index0]++;
            normalCounts[index1]++;
            normalCounts[index2]++;


   			// set up the vertices
			pIndices[3*i]	=	(WORD)index0;
			pIndices[3*i+1] =	(WORD)index1;
			pIndices[3*i+2] =	(WORD)index2;


			//------------------------------------------------------------		
			//------------------------------------------------------------
			//------------------------------------------------------------

		}

		// now I need to go back and calculate the average normals
		for ( unsigned long j = 0; j < m_nNumVertices; j++ )
		{
			if ( normalCounts[j] > 0 )
			{
				finalVertices[j].normal.x/=(float)normalCounts[j];
				finalVertices[j].normal.y/=(float)normalCounts[j];
				finalVertices[j].normal.z/=(float)normalCounts[j];

                D3DXVec3Normalize( &finalVertices[j].normal,  &finalVertices[j].normal );
                
			}
		}


		// OK, now need to sort the faces based on materials, saves on state changes later
		m_pMaterialIDs = new XBMESH_SUBSET[maxMaterialCount+1];

		WORD* pFinalIndices = NULL;
		m_pIndexBuffer->Lock(0, 0, (BYTE**)&pFinalIndices, 0);

		for ( int i = 0; i < numFaces; i++ )
		{	
			*pFinalIndices++ = pIndices[3*i];
			*pFinalIndices++ = pIndices[3*i+1];
			*pFinalIndices++ = pIndices[3*i+2];		
		}
		m_nMaterialCount = 1;
		m_pMaterialIDs[0].m_ID = nMaterialIndex;
		m_pMaterialIDs[0].m_numUsed = numFaces;

		m_pIndexBuffer->Unlock();
        m_VertexBuffer.Data = 0;
        m_VertexBuffer.Register( pVertexMem );
        m_pMem = pVertexMem; // so we free later



		delete [] pIndices;
		delete [] tmpMaterialArray;
		delete [] normalCounts;
        delete [] altVertex;

        m_nodeCenter -= parentLoc;

	}
	else // no faces
	{
		return -1;
	}

	return(S_OK);
}

// helper function to determine wether the new vector is significantly different than the old one
bool TG_TypeShape::CreateNewNormal( const D3DXVECTOR3& newNormal, TG_NormalVertex* pListOfVertices, 
                                   long* normalCounts, long& index, long* altIndex  )
{
    while(true)
    {
        if ( normalCounts[index] )
        {
            D3DXVECTOR3 oldNormal = pListOfVertices[index].normal/((float)normalCounts[index]);
            if ( (float)(fabs( D3DXVec3Dot( &oldNormal, &newNormal )) < cos(20.f * D3DX_PI/180.f) ) )
            {
                if ( altIndex[index]  )
                {
                    index = altIndex[index];
                }
                else
                {
                    return true;
                }
            }
            else
                break;
        }
        else
            break;
    }

    return false;

}


long TG_TypeShape::ParseASEColors (BYTE *aseBuffer, const char *fileName, const D3DVECTOR& parentLoc)
{
	m_nFVF = COLOR_VERTEX_FVF;
	m_nFVFSize = sizeof( TG_ColorVertex );

    m_fMinZDepth = -9999999.f;

	//------------------------------------------
	// Store off the Node Names.
	char *nodeName = strstr((char *)aseBuffer,ASE_NODE_NAME);
	if (!nodeName )
    {
        nodeName = strstr((char *)aseBuffer,ASE_GROUP_NAME);
      	nodeName += strlen(ASE_GROUP_NAME)+1;

    }
    else
    {
       	nodeName += strlen(ASE_NODE_NAME)+1;
    }

	_ASSERT(nodeName != NULL);


	char nodeString[1024];
	GetNameData(nodeName,nodeString);

    ASSERT( strlen( nodeString ) < 32 );

	strncpy(m_strNodeId,nodeString,32);
    CharUpperA( m_strNodeId );
	
	//----------------------------------------------------
	// Store off NODE ABS position for heirarchy
	nodeName = strstr((char *)aseBuffer,ASE_NODE_POS);
	_ASSERT(nodeName != NULL);
    if ( !nodeName ) // this is a group
       return -1;


	nodeName += strlen(ASE_NODE_POS)+1;

	char numData[512];

	GetNumberData(nodeName,numData);
	m_nodeCenter.x = (float)atof(numData);
	nodeName += strlen(numData)+1;

	GetNumberData(nodeName,numData);
	m_nodeCenter.y = (float)atof(numData);
	nodeName += strlen(numData)+1;

	GetNumberData(nodeName,numData);
	m_nodeCenter.z = (float)atof(numData);

    //m_nodeCenter += parentLoc;

	//----------------------------------------
	// Find the Number of Vertices
	char *vertexCount = strstr((char *)aseBuffer,ASE_NUM_VERTEX);
    if ( !vertexCount )
        return -1;
	_ASSERT(vertexCount != NULL);
		
	vertexCount += strlen(ASE_NUM_FACE)+1;
	long numTmpVertices = atol(vertexCount);
	if (numTmpVertices == 0)			//NO Data for this node.  WARN and then do NOT allocate anything!
	{
#ifdef _DEBUG
//		if (!silentMode)
//			PAUSE(("WARNING: No Vertices for Shape Node %s in Shape %s!",m_strNodeID,fileName));
#endif
		init();

		return (0);
	}


	//---------------------------------------
	// Find the Number of faces
	char *faceCount = strstr((char *)aseBuffer,ASE_NUM_FACE);
	_ASSERT(faceCount != NULL);
			
	faceCount += strlen(ASE_NUM_FACE)+1;
	long numFaces = atol(faceCount);
	if ( numFaces )
	{

		TG_NormalVertex* pTmpVertices = new TG_NormalVertex[numTmpVertices];
		memset( pTmpVertices, 0xff, numTmpVertices * sizeof( TG_NormalVertex ) );

	
		m_nMaterialCount = 1;
		m_pMaterialIDs = new XBMESH_SUBSET;
		m_pMaterialIDs[0].m_ID = -1;
		m_pMaterialIDs[0].m_numUsed = numFaces;
		//-------------------
		// Vertex Data Next.

		m_nNumVertices = numFaces * 3;

        BYTE* pVertexMem = (BYTE*)D3D_AllocContiguousMemory( m_nNumVertices * sizeof( TG_ColorVertex ), D3DVERTEXBUFFER_ALIGNMENT );
		TG_ColorVertex* finalVertices = (TG_ColorVertex*)pVertexMem;

		memset(finalVertices,0xff,sizeof(TG_ColorVertex) * m_nNumVertices);

		for (long i=0;i<numTmpVertices;i++)
		{
			char numberData[256];

			//------------------------------------------------
			// First the Vertex Position
			char vertexID[256];
			sprintf(vertexID,"%s% 5d",ASE_MESH_VERTEX_ID,i);

			char *vertexData = strstr((char *)aseBuffer,vertexID);
			_ASSERT(vertexData != NULL);
				
			vertexData += strlen(vertexID)+1;

			GetNumberData(vertexData,numberData);
			vertexData += strlen(numberData)+1;
			pTmpVertices[i].position.x = (float)atof(numberData);
			pTmpVertices[i].position.x -= m_nodeCenter.x;

			GetNumberData(vertexData,numberData);
			vertexData += strlen(numberData)+1;
			pTmpVertices[i].position.y = (float)atof(numberData);
			pTmpVertices[i].position.y -= m_nodeCenter.y;

			GetNumberData(vertexData,numberData);
			pTmpVertices[i].position.z = (float)atof(numberData);
			pTmpVertices[i].position.z -= m_nodeCenter.z;

            if ( pTmpVertices[i].position.y > m_fMinZDepth )
                m_fMinZDepth = pTmpVertices[i].position.y;



		}



        char* prevFace = (char*)aseBuffer;
        char* prevColor = (char*)aseBuffer;

		for (i=0;i<numFaces;i++)
		{
			char numberData[256];

			//-----------------------------------------------
			// First the Vertices for the face
			char faceId[256];
			sprintf(faceId,"%s% 5d:",ASE_MESH_FACE_ID,i);

			char *faceData = strstr((char *)prevFace,faceId);
			_ASSERT(faceData != NULL);
            prevFace = faceData;

			faceData = strstr(faceData,"A:");
			_ASSERT(faceData != NULL);
				
			GetNumberData(faceData,numberData);
			long index0 = atol(numberData);

			faceData = strstr(faceData,"B:");
			_ASSERT(faceData != NULL);

			GetNumberData(faceData,numberData);
			long index1 = atol(numberData);

			faceData = strstr(faceData,"C:");
			_ASSERT(faceData != NULL);
		
			GetNumberData(faceData,numberData);
			long index2 = atol(numberData);

			// set up the vertices
			finalVertices[3*i].position.x = pTmpVertices[index0].position.x;
			finalVertices[3*i].position.y = pTmpVertices[index0].position.y;
			finalVertices[3*i].position.z = pTmpVertices[index0].position.z;

			finalVertices[3*i+1].position.x = pTmpVertices[index1].position.x;
			finalVertices[3*i+1].position.y = pTmpVertices[index1].position.y;
			finalVertices[3*i+1].position.z = pTmpVertices[index1].position.z;

			finalVertices[3*i+2].position.x = pTmpVertices[index2].position.x;
			finalVertices[3*i+2].position.y = pTmpVertices[index2].position.y;
			finalVertices[3*i+2].position.z = pTmpVertices[index2].position.z;

			//------------------------------------------------------------

			//---------------------------------------------------------------------
			// Color Data for the face.
			//Load up the CFaces
			// Shelley says she doesn't do this.
			
			unsigned long color1, color2, color3;
			color1 = color2 = color3 = 0xffffffff;
			
			sprintf(faceId,"%s",ASE_NUM_CVFACES);


			faceData = strstr((char *)aseBuffer,faceId);
			if (faceData)
			{
				_ASSERT(faceData != NULL);

				faceData += strlen(faceId);
				GetNumberData(faceData,numberData);

				long cIndex1, cIndex2, cIndex3;
				sprintf(faceId,"%s %d",ASE_MESH_CFACE_ID,i);

				faceData = strstr(prevColor,faceId);
                prevColor = faceData;
				_ASSERT(faceData != NULL);

				faceData += strlen(faceId);
					
				GetNumberData(faceData,numberData);
				cIndex1 = atol(numberData);
				faceData += strlen(numberData)+1;
					
				GetNumberData(faceData,numberData);
				cIndex2 = atol(numberData);
				faceData += strlen(numberData)+1;

				GetNumberData(faceData,numberData);
				cIndex3 = atol(numberData);

				//Load up the VERTCOL0

				getColorData( aseBuffer, cIndex1, cIndex2, cIndex3, color1, color2, color3 );
				
			}
			
			finalVertices[3*i].argb = color1;
			finalVertices[3*i+1].argb = color2;
			finalVertices[3*i+2].argb = color3;

		
		}	

        m_VertexBuffer.Data = 0;
        m_VertexBuffer.Register( pVertexMem );
        m_pMem = pVertexMem; // so we free later

		delete [] pTmpVertices;

        m_nodeCenter -= parentLoc;
		
	}
	else // no faces
	{
		return -1;
	}

	return(S_OK);
}	

//-------------------------------------------------------------------------------
//Function return 0 is OK.  -1 if file is not ASE Format or missing data.
//This function simply parses the ASE buffers handed to it.  This allows
//users to load the ase file themselves and manage their own memory for it.
//It allocates memory for internal Lists.  These are straight tglHeap->Mallocs at present.
//
// NOTE: Only takes the first GEOMOBJECT from the ASE file.  Multi-object
// Files will require user intervention to parse!!


long TG_TypeShape::ParseASEFile (BYTE *aseBuffer, const char *fileName, const D3DVECTOR& parentLoc)
{
	m_nFVF = TEXTURE_VERTEX_FVF;
	m_nFVFSize = sizeof( TG_UVVertex );

    m_fMinZDepth = -9999999.f;

	unsigned long maxMaterialCount = 0;


	//------------------------------------------
	// Store off the Node Names.
	char *nodeName = strstr((char *)aseBuffer,ASE_NODE_NAME);
	if (!nodeName )
    {
        nodeName = strstr((char *)aseBuffer,ASE_GROUP_NAME);
      	nodeName += strlen(ASE_GROUP_NAME)+1;

    }
    else
    {
       	nodeName += strlen(ASE_NODE_NAME)+1;
    }

	_ASSERT(nodeName != NULL);

	char nodeString[1024];
	GetNameData(nodeName,nodeString);

    ASSERT( strlen( nodeString ) < 32 );

	strncpy(m_strNodeId,nodeString,32);
    CharUpperA( m_strNodeId );
	//if ( strstr( m_strNodeId, "Text" ) )
	//	return -1;
	

	//----------------------------------------------------
	// Store off NODE ABS position for heirarchy
	nodeName = strstr((char *)aseBuffer,ASE_NODE_POS);
	_ASSERT(nodeName != NULL);
    if ( !nodeName ) // this is a group
        return -1;


	nodeName += strlen(ASE_NODE_POS)+1;

	char numData[512];

	GetNumberData(nodeName,numData);
	m_nodeCenter.x = (float)atof(numData);
	nodeName += strlen(numData)+1;

	GetNumberData(nodeName,numData);
	m_nodeCenter.y = (float)atof(numData);
	nodeName += strlen(numData)+1;

	GetNumberData(nodeName,numData);
	m_nodeCenter.z = (float)atof(numData);

    //m_nodeCenter += parentLoc;

	//----------------------------------------
	// Find the Number of Vertices
	char *vertexCount = strstr((char *)aseBuffer,ASE_NUM_VERTEX);
    if ( !vertexCount )
        return -1;
	_ASSERT(vertexCount != NULL);
		
	vertexCount += strlen(ASE_NUM_FACE)+1;
	long numTmpVertices = atol(vertexCount);
	if (numTmpVertices == 0)			//NO Data for this node.  WARN and then do NOT allocate anything!
	{
#ifdef _DEBUG
//		if (!silentMode)
//			PAUSE(("WARNING: No Vertices for Shape Node %s in Shape %s!",m_strNodeID,fileName));
#endif
		init();

		return (0);
	}

	//---------------------------------------
	// Find the material index of the object
	//---------------------------------------
    unsigned long nMaterialNum = 0;
	char *matIndex = strstr((char *)aseBuffer,ASE_MATERIAL_REF);

    if ( matIndex )
    {
	    // Pull the ASE specific material index
	    matIndex += strlen(ASE_MATERIAL_REF)+1;
	    nMaterialNum = atol(matIndex);
    }

	// Now find the cooresponding material index in the Material Library
	long nMaterialIndex = g_MaterialLib.ReturnIndex(nMaterialNum);

    // if we don't use textures, don't allocate them
    if ( !g_MaterialLib.MaterialUsesTexture( nMaterialIndex ) )
        return ParseASENoTextures( aseBuffer, fileName, parentLoc );


	//---------------------------------------
	// Find the Number of faces
	//---------------------------------------
	char *faceCount = strstr((char *)aseBuffer,ASE_NUM_FACE);
	_ASSERT(faceCount != NULL);
			
	faceCount += strlen(ASE_NUM_FACE)+1;
	long numFaces = atol(faceCount);
    char* prevFace = (char*)aseBuffer;
	if ( numFaces )
	{

		TG_NormalVertex* pTmpVertices = new TG_NormalVertex[numTmpVertices];
		memset( pTmpVertices, 0xff, numTmpVertices * sizeof( TG_NormalVertex ) );

		// going to store materials, and then sort them later
		long*	tmpMaterialArray = new long[ numFaces ];
		memset( tmpMaterialArray, 0, sizeof ( long ) * numFaces );


		//-------------------
		// Vertex Data Next.

		m_nNumVertices = numFaces * 3;
		
		TG_UVVertex* finalVertices = new TG_UVVertex[m_nNumVertices];
		memset(finalVertices,0xff,sizeof(TG_UVVertex) * m_nNumVertices);

		for (long i=0;i<numTmpVertices;i++)
		{
			char numberData[256];

			//------------------------------------------------
			// First the Vertex Position
			char vertexID[256];
			sprintf(vertexID,"%s% 5d",ASE_MESH_VERTEX_ID,i);

			char *vertexData = strstr((char *)prevFace,vertexID);
			_ASSERT(vertexData != NULL);
            prevFace = vertexData;
				
			vertexData += strlen(vertexID)+1;

			GetNumberData(vertexData,numberData);
			vertexData += strlen(numberData)+1;
			pTmpVertices[i].position.x = (float)atof(numberData);
			pTmpVertices[i].position.x -= m_nodeCenter.x;

			GetNumberData(vertexData,numberData);
			vertexData += strlen(numberData)+1;
			pTmpVertices[i].position.y = (float)atof(numberData);
			pTmpVertices[i].position.y -= m_nodeCenter.y;


			GetNumberData(vertexData,numberData);
			pTmpVertices[i].position.z = (float)atof(numberData);
			pTmpVertices[i].position.z -= m_nodeCenter.z;

            if ( pTmpVertices[i].position.y > m_fMinZDepth )
                m_fMinZDepth = pTmpVertices[i].position.y;


		}


		//-----------------------------------------------
		// Find the number of Texture Vertex List entries
		//-----------------------------------------------
		char *tVertCount = strstr((char *)aseBuffer,ASE_NUM_TVERTEX);
		_ASSERT(tVertCount != NULL);
				
		tVertCount += strlen(ASE_NUM_TVERTEX)+1;
		long numTVertices = atol(tVertCount);

		// Read in the Texture Vertex List
		TG_TVert *TVertexList = new TG_TVert[numTVertices];
		for(i = 0; i < numTVertices; i++)
		{
			char numberData[256];

			char TvertexID[256];
			sprintf(TvertexID,"%s %d",ASE_MESH_TVERT_ID,i);

			char *TvertexData = strstr((char *)tVertCount, TvertexID);
			_ASSERT(TvertexData != NULL);
				
			TvertexData += strlen(TvertexID)+1;

			GetNumberData(TvertexData, numberData);
			TvertexData += strlen(numberData)+1;
			TVertexList[i].u = (float)atof(numberData);

			GetNumberData(TvertexData, numberData);
			TvertexData += strlen(numberData)+1;
			TVertexList[i].v = (float)atof(numberData);
			TVertexList[i].v = 1.0f - TVertexList[i].v;
		}

		//-----------------------------------------------
		// Find the number of Texture Face List entries
		//-----------------------------------------------
		char *tVFaceCount = strstr((char *)aseBuffer,ASE_NUM_TVFACES);
		_ASSERT(tVFaceCount != NULL);
				
		tVFaceCount += strlen(ASE_NUM_TVFACES)+1;
		long numTFaces = atol(tVFaceCount);

		// Read in the Texture Face List
		TG_TFace *TFaceList = new TG_TFace[numTFaces];
        char* prevTextFace = (char*)aseBuffer;
		for(i = 0; i < numTFaces; i++)
		{
			char numberData[256];

			char TfaceID[256];
			sprintf(TfaceID,"%s %d",ASE_MESH_TFACE_ID,i);

			char *TfaceData = strstr((char *)prevTextFace, TfaceID);
            prevTextFace = TfaceData;
			_ASSERT(TfaceData != NULL);
				
			TfaceData += strlen(TfaceID)+1;

			GetNumberData(TfaceData, numberData);
			TfaceData += strlen(numberData)+1;
			TFaceList[i].index0 = atol(numberData);

			GetNumberData(TfaceData, numberData);
			TfaceData += strlen(numberData)+1;
			TFaceList[i].index1 = atol(numberData);

			GetNumberData(TfaceData, numberData);
			TfaceData += strlen(numberData)+1;
			TFaceList[i].index2 = atol(numberData);
		}

        char* prevFace = (char*)aseBuffer;

		for (i=0;i<numFaces;i++)
		{
			char numberData[256];

			//-----------------------------------------------
			// First the Vertices for the face
			//-----------------------------------------------
			char faceId[256];
			sprintf(faceId,"%s% 5d:",ASE_MESH_FACE_ID,i);

			char *faceData = strstr((char *)prevFace,faceId);
            prevFace = faceData;
			_ASSERT(faceData != NULL);

			faceData = strstr(faceData,"A:");
			_ASSERT(faceData != NULL);
				
			GetNumberData(faceData,numberData);
			long index0 = atol(numberData);

			faceData = strstr(faceData,"B:");
			_ASSERT(faceData != NULL);

			GetNumberData(faceData,numberData);
			long index1 = atol(numberData);

			faceData = strstr(faceData,"C:");
			_ASSERT(faceData != NULL);
		
			GetNumberData(faceData,numberData);
			long index2 = atol(numberData);

			faceData = strstr( faceData, "MESH_MTLID " );
			GetNumberData(faceData,numberData);
			long matrlID = atol(numberData );

			//tmpMaterialArray[i] = matrlID;
			tmpMaterialArray[i] = nMaterialNum;
            //if ( matrlID >= maxMaterialCount )
            //    maxMaterialCount = matrlID;

			// set up the vertices
			finalVertices[3*i].position.x = pTmpVertices[index0].position.x;
			finalVertices[3*i].position.y = pTmpVertices[index0].position.y;
			finalVertices[3*i].position.z = pTmpVertices[index0].position.z;

			finalVertices[3*i+1].position.x = pTmpVertices[index1].position.x;
			finalVertices[3*i+1].position.y = pTmpVertices[index1].position.y;
			finalVertices[3*i+1].position.z = pTmpVertices[index1].position.z;

			finalVertices[3*i+2].position.x = pTmpVertices[index2].position.x;
			finalVertices[3*i+2].position.y = pTmpVertices[index2].position.y;
			finalVertices[3*i+2].position.z = pTmpVertices[index2].position.z;


            D3DXVECTOR3 v1, v2, tmpNormal;
            v1 = finalVertices[3*i+2].position - finalVertices[3*i+1].position;
            v2 = finalVertices[3*i].position - finalVertices[3*i+1].position;
            

            D3DXVec3Cross( &tmpNormal, &v2, &v1 );
            D3DXVec3Normalize( &tmpNormal, &tmpNormal );


  
            finalVertices[3*i].normal = tmpNormal;
            finalVertices[3*i+1].normal = tmpNormal;
            finalVertices[3*i+2].normal = tmpNormal;



			// set up the texture coordinates
			finalVertices[3*i].u = TVertexList[TFaceList[i].index0].u;
			finalVertices[3*i].v = TVertexList[TFaceList[i].index0].v;

			finalVertices[3*i+1].u = TVertexList[TFaceList[i].index1].u;
			finalVertices[3*i+1].v = TVertexList[TFaceList[i].index1].v;

			finalVertices[3*i+2].u = TVertexList[TFaceList[i].index2].u;
			finalVertices[3*i+2].v = TVertexList[TFaceList[i].index2].v;

			//------------------------------------------------------------
		}

		// OK, now need to sort the faces based on materials, saves on state changes later
		m_pMaterialIDs = new XBMESH_SUBSET[maxMaterialCount+1];

		BYTE* pVertexMem = (BYTE*)D3D_AllocContiguousMemory( m_nNumVertices * sizeof( TG_UVVertex ), D3DVERTEXBUFFER_ALIGNMENT );

		BYTE* pTmp = NULL;
		TG_UVVertex* pVertices = (TG_UVVertex*)pVertexMem;
		TG_UVVertex*pCurVertex = pVertices;

        char outputStr[256];
		for ( int i = 0; i < numFaces; i++ )
		{	
				*pCurVertex++ = finalVertices[3*i];
				*pCurVertex++ = finalVertices[3*i+1];
				*pCurVertex++ = finalVertices[3*i+2];

     	}
		m_nMaterialCount = 1;
		m_pMaterialIDs[0].m_ID = nMaterialIndex;
		m_pMaterialIDs[0].m_numUsed = numFaces;


        m_VertexBuffer.Data = 0;

        m_VertexBuffer.Register( pVertexMem );
        m_pMem = pVertexMem; // so we free later


		delete [] pTmpVertices;
		delete [] tmpMaterialArray;
		delete [] finalVertices;
        delete [] TVertexList;
        delete [] TFaceList;

        m_nodeCenter -= parentLoc;
	}
	else // no faces
	{
		return -1;
	}

	return(S_OK);
}	

//-------------------------------------------------------------------------------
//Function figures out what format to keep the data in		
//
long TG_TypeShape::LoadTGShapeFromASE (const char* aseContents, const char* fileName, const D3DVECTOR& parentLoc )
{

	// figure out if this has textures or not
	// no textures, use index buffer,
	// textures, use vertex buffer
	//----------------------------------------
	char* pTextureInfo = strstr( aseContents, ASE_NUM_TVERTEX );
	char numberData[32];
	GetNumberData(pTextureInfo,numberData);

	long textureCount = atol( numberData );
	long parseResult = -1;

	// figure out if it uses colors or not
	char* pColorInfo = strstr( aseContents, ASE_NUM_CVERTEX );
	GetNumberData(pColorInfo,numberData);
	long colorCount = atol( numberData );

	if ( textureCount )
	{
		parseResult = ParseASEFile((BYTE*)aseContents,fileName, parentLoc);
//        parseResult = ParseASENoTextures((BYTE*)aseContents,fileName, parentLoc );

	}
	else if ( colorCount )
	{
		parseResult = ParseASEColors( (BYTE*)aseContents,fileName, parentLoc);
	}
	else
	{
		//parseResult = ParseASEFile((BYTE*)aseContents,fileName);
        parseResult = ParseASENoTextures((BYTE*)aseContents,fileName, parentLoc );
	}

	return(parseResult);
}	


//-------------------------------------------------------------------------------
// looks for the existing material, and replaces it with the new one
long TG_TypeShape::SwapMaterials (DWORD indexToReplace, DWORD replaceItWithThis)
{

    for ( unsigned long i = 0; i < m_nMaterialCount; i++ )
    {
        if ( m_pMaterialIDs[i].m_ID == indexToReplace )
        {
            m_pMaterialIDs[i].m_ID = replaceItWithThis;
            return S_OK;
        }
    }

	return -1;
}	

//-------------------------------------------------------------------------------
// just sets the new material
void TG_TypeShape::SetMaterials (DWORD replaceItWithThis)
{

    for ( unsigned long i = 0; i < m_nMaterialCount; i++ )
    {
        m_pMaterialIDs[i].m_ID = replaceItWithThis;
    }

}	


//-------------------------------------------------------------------------------
//-------------------------------------------------------------------------------
// initialization
void TG_TypeShape::init (void)
{
	m_nodeCenter.x = m_nodeCenter.y = m_nodeCenter.z = 0.0f;
	m_pMaterialIDs = NULL;
	m_pIndexBuffer = NULL;			// not necessarily used
	m_nNumFaces = 0;
    m_nNumVertices = 0;
    m_pMem = 0;
    m_fMinZDepth = 0;           // also for ase parsing...

    m_nMaterialCount = 0;

    memset( &m_VertexBuffer, 0, sizeof( m_VertexBuffer ) );
    m_VertexBuffer.Common =  D3DCOMMON_TYPE_VERTEXBUFFER |    // Type
            D3DCOMMON_VIDEOMEMORY |          // VB lives in video memory
            1;                               // Initial Refcount  

}

extern CMaterialLibrary g_MaterialLib;
static temp = 0;

HRESULT TG_TypeShape::Render()
{
	if ( m_nNumVertices < 1 )
		return -1;

	
    g_pd3dDevice->SetStreamSource( 0, &m_VertexBuffer, m_nFVFSize );
	g_pd3dDevice->SetIndices( m_pIndexBuffer, 0 ); 

	int curOffset = 0;
	for ( DWORD j = 0; j < m_nMaterialCount; j++ )
	{
		if ( m_pMaterialIDs[j].m_numUsed )
		{			
			if(FAILED(g_MaterialLib.Setup( m_pMaterialIDs[j].m_ID, m_nFVF )))
				return E_FAIL;

			if ( m_pIndexBuffer )
			{
				g_pd3dDevice->DrawIndexedPrimitive( D3DPT_TRIANGLELIST, 0, 
					m_nNumVertices, curOffset*3, m_pMaterialIDs[j].m_numUsed );
			}
			else
			{
               g_pd3dDevice->DrawPrimitive( D3DPT_TRIANGLELIST, curOffset*3, m_pMaterialIDs[j].m_numUsed );
			}
			curOffset += m_pMaterialIDs[j].m_numUsed;
		}
	}

    return S_OK;
}


//-------------------------------------------------------------------------------

TG_Shape::TG_Shape( TG_Shape& src )
{
    m_pMyType       = NULL;
    m_transform     = src.m_transform;
    m_bRender       = src.m_bRender;                // turn off things like text regions
    m_bCommonMemory = false;

    m_pChild = m_pParent = m_pNext = NULL;

    if ( src.m_pMyType )
        m_pMyType = src.m_pMyType->Copy();			//Pointer to the instance of the shape.
    

    if ( src.m_pChild )
        m_pChild = new TG_Shape( *src.m_pChild );

    if ( src.m_pNext )
        m_pNext = new TG_Shape( *src.m_pNext); 

}

static long childCounter = 0;
//-------------------------------------------------------------------------------
void TG_Shape::Dump(bool bAllData)
{
	if ( m_pMyType )
	{
		DbgPrint( "TG_Shape:: Node Name = %s\nChildren=\n", m_pMyType->m_strNodeId );
	}

	// render all children
    TG_Shape* pShape = m_pChild;
    childCounter++;

    while( pShape )
    {   
        for ( int i = 0; i < childCounter; i++ )
		    DbgPrint( "\t" );
        pShape->Dump();
        pShape = pShape->m_pNext;
    }
    childCounter--;
}

//-------------------------------------------------------------------------------
long TG_Shape::Render ( )
{
		

    if ( !m_bRender )
        return 0; // nothing to render, not really a problem

	TG_TypeNode* theShape = m_pMyType;
        
	D3DXMATRIX curWorld;
	g_pd3dDevice->GetTransform( D3DTS_WORLD, &curWorld );

	D3DXMATRIX finalWorld;
	D3DXMatrixMultiply( &finalWorld, &curWorld, &m_transform );
   
    D3DXMATRIX scaleMatrix;
    D3DXMatrixScaling( &scaleMatrix, m_Scale.x, m_Scale.y, m_Scale.z );

    D3DXMatrixMultiply( &finalWorld, &scaleMatrix, &finalWorld );

   

	g_pd3dDevice->SetTransform( D3DTS_WORLD, &finalWorld );
    
  	if ( m_pMyType != NULL )
	    m_pMyType->Render(); 

    // render all children
    TG_Shape* pShape = m_pChild;
    while( pShape )
    {
        pShape->Render( );
        pShape = pShape->m_pNext;
    }

 
    // clean up after ourselves
	g_pd3dDevice->SetTransform( D3DTS_WORLD, &curWorld );




	// otherwise do this

	return 0;


}

HRESULT TG_Shape::FrameMove (float frameLength)
{
    HRESULT hr = S_OK;
    // are we animating?
    if ( m_Animation.m_numFrames )
    {
         m_curTime += frameLength;
     
         float totalLen = (m_Animation.m_numFrames/m_Animation.m_frameRate );
         while ( m_curTime > totalLen  )
                m_curTime -= totalLen;

         DWORD curFrame = (DWORD)(m_curTime * (float)m_Animation.m_frameRate);
  
 
        // build current animation position & rotation info
        D3DXMATRIX anim;
        D3DXMatrixTransformation( &m_transform, NULL, NULL, NULL, NULL, 
            m_Animation.m_pQuat ? &m_Animation.m_pQuat[curFrame] : 0,
            m_Animation.m_pPos ? &m_Animation.m_pPos[curFrame]  : &m_pMyType->m_nodeCenter );

        // TO DO: return different hr if anim is over
    }

    // render all children
    TG_Shape* pShape = m_pChild;
    while( pShape )
    {
        pShape->FrameMove( frameLength );
        pShape = pShape->m_pNext;
    }

    return hr;
}

////////////////////////////////////////////////////////////////
// this is load from an ASE, need to write a load from Binary
long TG_Shape::Load(const char* buffer, const char* path, const D3DVECTOR& parentLoc, TG_Animation* pAnimationHeader )
{
	if ( NULL != m_pMyType )
	{
		m_pMyType->destroy();
	}

	if ( NULL == m_pMyType )
		m_pMyType = new TG_TypeShape;

    m_bCommonMemory = false;

    // I know I can do this cast because I just allocated it a few lines up

	long retVal = ((TG_TypeShape*)m_pMyType)->LoadTGShapeFromASE(buffer, path, parentLoc );

	D3DXMATRIX translation;
	D3DXMatrixTranslation( &m_transform, m_pMyType->m_nodeCenter.x, m_pMyType->m_nodeCenter.y, m_pMyType->m_nodeCenter.z );

    // easily could fail if no animation info
    if ( pAnimationHeader )
    {
        long animRetVal = 
            LoadAnimationFromASE( (char*)buffer, m_pMyType->m_strNodeId, m_pMyType->m_nodeCenter, pAnimationHeader, &m_Animation );

        if ( retVal == -1 ) // you can have animation info without mesh info and vice versa
            retVal = animRetVal;
    }

  	return retVal;



}

//////////////////////////////////////////////////////////////
// explicitly set a transform
// 
void TG_Shape::SetTransform( const D3DXMATRIX& newTransform )
{
	m_transform = newTransform;
}

//-------------------------------------------------------------------------------
void TG_Shape::LocalRotateY( float angle )
{
	D3DXMATRIX rotationMat;
	D3DXMatrixRotationY( &rotationMat, angle );
    D3DXMatrixMultiply( &m_transform, &m_transform, &rotationMat );
}

//-------------------------------------------------------------------------------
void TG_Shape::LocalRotateX( float angle )
{
	D3DXMATRIX rotationMat;
	D3DXMatrixRotationX( &rotationMat, angle );
    D3DXMatrixMultiply( &m_transform, &m_transform, &rotationMat );
}


//-------------------------------------------------------------------------------
void TG_Shape::LocalRotateZ( float angle )
{
	D3DXMATRIX rotationMat;
	D3DXMatrixRotationZ( &rotationMat, angle );
    D3DXMatrixMultiply( &m_transform, &rotationMat, &m_transform );
	
}

//-------------------------------------------------------------------------------
void        TG_Shape::SetScale( float newX, float newY, float newZ )
{
    m_Scale.x = newX;
    m_Scale.y = newY;
    m_Scale.z = newZ;
}
//////////////////////////////////////////////////////////////
// add a child node to this object, it'll go through the 
// root node's transform
HRESULT TG_Shape::AddChild( TG_Shape* pChild )
{
	if (!m_pChild )
	{
		// if we're loading an ASE, this is OK, if not
        // we're in trouble
        m_pChild = pChild;
        pChild->m_pParent = this;
        pChild->m_dwEnumeratedID = 0;

	}
    else
    {
        unsigned long dwCounter = 0;
        TG_Shape* pKid = m_pChild;
        while( pKid->m_pNext )
        {
            pKid = pKid->m_pNext;
            dwCounter++;
        }
        pKid->m_pNext = pChild;
        pChild->m_pNext = NULL;
  
        pChild->m_pParent = this;
        pChild->m_dwEnumeratedID = dwCounter;
    }

    return S_OK;

	
}

//////////////////////////////////////////////////////////////
// set the name of this object
//////////////////////////////////////////////////////////////
void  TG_Shape::SetNodeName(const char* pNewName )
{
    ASSERT( strlen( pNewName ) <= 32 );
    if ( m_pMyType )
    {
        strcpy( m_pMyType->m_strNodeId, pNewName );
        CharUpperA( m_pMyType->m_strNodeId );
    }
    else
    {
        m_pMyType = new TG_TypeNode; // needs to have a name
        strcpy( m_pMyType->m_strNodeId, pNewName );  
    }

}

	
//////////////////////////////////////////////////////////////
// get the name of this object
//////////////////////////////////////////////////////////////
char * TG_Shape::GetNodeName (void) const
{
	if ( m_pMyType != NULL )
	{
		return m_pMyType->getNodeId();
	}
	return NULL;
}

// search for subobject with this name
TG_Shape*    TG_Shape::FindObject( const char* pName )
{
    TG_Shape* pRetVal = NULL;
    if ( m_pMyType )
    {
        if ( _stricmp( m_pMyType->getNodeId(), pName ) == 0 )
            pRetVal = this;
    }
    if ( !pRetVal )
    {
        TG_Shape* pKid = m_pChild;   
       while( pKid && !pRetVal )
       {
           pRetVal = pKid->FindObject( pName );
           pKid = pKid->m_pNext;
       }
    }

    return pRetVal;

}
//-----------------------------------------------------------------------------
// Name: ComputeMemoryRequirementsCB()
// Desc: Frame enumeration callback to compute memory requirements
//-----------------------------------------------------------------------------
BOOL TG_Shape::ComputeMemoryRequirementsCB( TG_Shape* pFrame, VOID* )
{
    pFrame->m_dwFrameID = s_dwNumFrames;
    s_dwNumFrames++;

    // Compute memory requirements
    s_dwFrameSpace    += sizeof(XBMESH_FRAME);

    if ( pFrame->m_pMyType && pFrame->m_pMyType->isShape() )
    {
        TG_TypeShape* pTypeShape = (TG_TypeShape*)pFrame->m_pMyType;
        
        s_dwSubsetSpace   += sizeof(XBMESH_SUBSET) * pTypeShape->m_nMaterialCount;
        s_dwIndicesSpace  += sizeof(WORD) * pTypeShape->m_nNumFaces * 3;
        s_dwVerticesSpace += pTypeShape->m_nFVFSize * pTypeShape->m_nNumVertices;
        if ( pFrame->m_Animation.m_pPos )
            s_dwAnimSpace += pFrame->m_Animation.m_numFrames * sizeof( D3DXVECTOR3 );

        if ( pFrame->m_Animation.m_pQuat )
            s_dwAnimSpace += pFrame->m_Animation.m_numFrames * sizeof( D3DXQUATERNION );
    }  

    return TRUE;
}


//-----------------------------------------------------------------------------
// Name: WriteMeshInfoCB()
// Desc: Writes mesh info to a file
//-----------------------------------------------------------------------------
BOOL TG_Shape::WriteMeshInfoCB( TG_Shape* pFrame, VOID* pData )
{
    File* file = (File*)pData;

    // Set up mesh info to be written. Note that, in order for Xbox fast math
	// (via xgmath.h) to work, all D3DXMATRIX's must be 16-byte aligned.
    XBMESH_FRAME frame;
    memset( &frame, 0, sizeof( XBMESH_FRAME ) );
    frame.m_pChild       = NULL;
    frame.m_pNext        = NULL;
    frame.m_MeshData.m_VB.Common     = 1 | D3DCOMMON_TYPE_VERTEXBUFFER;
    frame.m_MeshData.m_VB.Data       = 0L;
//    frame.m_MeshData.m_VB.Lock       = 0L;
    frame.m_MeshData.m_dwNumVertices = 0;
    frame.m_MeshData.m_IB.Common     = 1 | D3DCOMMON_TYPE_INDEXBUFFER;
    frame.m_MeshData.m_IB.Data       = 0L;
//    frame.m_MeshData.m_IB.Lock       = 0L;
    frame.m_MeshData.m_dwNumIndices  = 0L;
    frame.m_MeshData.m_dwFVF         = 0;
    frame.m_MeshData.m_dwVertexSize  = 0;
    frame.m_MeshData.m_dwNumSubsets  = 0;
    frame.m_MeshData.m_pSubsets      = NULL;
    frame.m_MeshData.m_numFrames    = pFrame->m_Animation.m_numFrames;
    frame.m_MeshData.m_frameRate    = pFrame->m_Animation.m_frameRate;
    frame.m_MeshData.m_tickRate     = pFrame->m_Animation.m_tickRate;
    frame.m_transform = pFrame->m_transform;

    if ( pFrame->m_pMyType )
    {
        strcpy( frame.m_strName, pFrame->m_pMyType->m_strNodeId );

        frame.m_translation = pFrame->m_pMyType->m_nodeCenter;


        if (pFrame->m_pMyType->isShape() )
        {
            TG_TypeShape* pShape =    (TG_TypeShape*)pFrame->m_pMyType;
            frame.m_MeshData.m_dwNumVertices = pShape->m_nNumVertices;
            frame.m_MeshData.m_dwNumIndices  = pShape->m_nNumFaces*3;
            frame.m_MeshData.m_dwFVF         = pShape->m_nFVF;
            frame.m_MeshData.m_dwVertexSize  = pShape->m_nFVFSize;
            frame.m_MeshData.m_dwPrimType    = D3DPT_TRIANGLELIST;
            frame.m_MeshData.m_dwNumSubsets  = pShape->m_nMaterialCount;
            frame.m_MeshData.m_pSubsets      = NULL;
        }
    }

	DWORD size = sizeof(frame);


    // Write pointers as file offsets
    if( pFrame->m_pChild )  
    {
       s_dwMeshFileOffset = sizeof( XBMESH_FRAME )* (pFrame->m_pChild->m_dwFrameID);
       frame.m_pChild = (XBMESH_FRAME*)( s_dwMeshFileOffset );
    }
    if( pFrame->m_pNext )   
    {
       s_dwMeshFileOffset = sizeof( XBMESH_FRAME )* (pFrame->m_pNext->m_dwFrameID);
        frame.m_pNext  = (XBMESH_FRAME*)( s_dwMeshFileOffset );
    }
    if ( pFrame->m_pMyType && pFrame->m_pMyType->isShape())
    {
        TG_TypeShape* pType = (TG_TypeShape*)(pFrame->m_pMyType);
        if( pType->m_nMaterialCount )
            frame.m_MeshData.m_pSubsets = (XBMESH_SUBSET*)s_dwSubsetFileOffset;
        if( frame.m_MeshData.m_dwNumIndices )
            frame.m_MeshData.m_IB.Data  = (DWORD)s_dwIndicesFileOffset;
        if( frame.m_MeshData.m_dwNumVertices )
            frame.m_MeshData.m_VB.Data  = (DWORD)s_dwVerticesFileOffset;

        s_dwSubsetFileOffset   += sizeof(XBMESH_SUBSET) * pType->m_nMaterialCount;
        s_dwIndicesFileOffset  += sizeof(WORD) * pType->m_nNumFaces * 3;
        s_dwVerticesFileOffset += pType->m_nFVFSize * pType->m_nNumVertices;

        if ( pFrame->m_Animation.m_pPos )
        {
            frame.m_MeshData.m_pPos = (D3DXVECTOR3*)s_dwAnimFileOffset;
            s_dwAnimFileOffset += pFrame->m_Animation.m_numFrames * sizeof( D3DXVECTOR3 );
        }
    
        if ( pFrame->m_Animation.m_pQuat )
        {
            frame.m_MeshData.m_pQuats = (D3DXQUATERNION*)s_dwAnimFileOffset;
            s_dwAnimFileOffset += pFrame->m_Animation.m_numFrames * sizeof( D3DXQUATERNION );
        }
        

    }


    // Write out mesh info
    file->write( (BYTE*)&frame,sizeof(XBMESH_FRAME) ); 

    return TRUE;
}


    

//-----------------------------------------------------------------------------
// Name: WriteSubsetsCB()
// Desc: Write out the mesh subsets
//-----------------------------------------------------------------------------
BOOL TG_Shape::WriteSubsetsCB( TG_Shape* pFrame, VOID* pData )
{
    File* file = (File*)pData;

    VOID* pTexturePtr = NULL;

    if ( pFrame->m_pMyType && pFrame->m_pMyType->isShape() )
    {
        TG_TypeShape* pShape =    (TG_TypeShape*)pFrame->m_pMyType;


        for( DWORD i=0; i<pShape->m_nMaterialCount; i++ )
        {
            file->write( (BYTE*)&pShape->m_pMaterialIDs[i], sizeof(XBMESH_SUBSET) );
        }
    }

    return TRUE;
}


    

//-----------------------------------------------------------------------------
// Name: WriteIndicesCB()
// Desc: Write out the mesh indices
//-----------------------------------------------------------------------------
BOOL TG_Shape::WriteIndicesCB( TG_Shape* pFrame, VOID* pData )
{
    File* file = (File*)pData;

    if ( pFrame->m_pMyType && pFrame->m_pMyType->isShape() )
    {
        TG_TypeShape* pShape =    (TG_TypeShape*)pFrame->m_pMyType;
        
        if( pShape->m_pIndexBuffer )
        {
            BYTE* pIndexData;
            pShape->m_pIndexBuffer->Lock( 0, 0, &pIndexData, 0 );
            file->write( pIndexData, sizeof(WORD) * pShape->m_nNumFaces * 3 ); 
            pShape->m_pIndexBuffer->Unlock();
        }
     }

    return TRUE;
}

//-----------------------------------------------------------------------------
// Name: WriteIndicesCB()
// Desc: Write out the mesh indices
//-----------------------------------------------------------------------------
BOOL TG_Shape::WriteAnimationCB( TG_Shape* pFrame, VOID* pData )
{
    File* file = (File*)pData;

    if ( pFrame->m_Animation.m_pPos )
    {
       file->write( (BYTE*)pFrame->m_Animation.m_pPos, pFrame->m_Animation.m_numFrames * sizeof( D3DXVECTOR3 ) );
    }

    if ( pFrame->m_Animation.m_pQuat )
    {
       file->write( (BYTE*)pFrame->m_Animation.m_pQuat, pFrame->m_Animation.m_numFrames * sizeof( D3DXQUATERNION ) );
    }
 
   
   return TRUE;
}


    


    

//-----------------------------------------------------------------------------
// Name: WriteVerticesCB()
// Desc: Write out the mesh vertices
//-----------------------------------------------------------------------------
BOOL TG_Shape::WriteVerticesCB( TG_Shape* pFrame, VOID* pData )
{
    File* file = (File*)pData;

    if ( pFrame->m_pMyType && pFrame->m_pMyType->isShape() )
    {
        TG_TypeShape* pShape =    (TG_TypeShape*)pFrame->m_pMyType;
        if( pShape->m_nNumVertices )
        {
            BYTE* pVertexData;
            pShape->m_VertexBuffer.Lock( 0, 0, &pVertexData, 0 );
            file->write( pVertexData, pShape->m_nFVFSize * pShape->m_nNumVertices ); 
            pShape->m_VertexBuffer.Unlock();
        }
    }

    return TRUE;
}






//-----------------------------------------------------------------------------
// Name: EnumFrames()
// Desc: Called recursively to walk the frame hierarchy, calling a user 
//       supplied callback function for every frame.
//-----------------------------------------------------------------------------
BOOL TG_Shape::EnumFrames( BOOL (*EnumFramesCB)(TG_Shape*,VOID*),
                            VOID* pData )
{
    EnumFramesCB( this, pData );

    if( m_pChild )
        m_pChild->EnumFrames( EnumFramesCB, pData );
    
    if( m_pNext )
        m_pNext->EnumFrames( EnumFramesCB, pData );

    return TRUE;
}



//-----------------------------------------------------------------------------
// Name: CD3DFrame()
// Desc: Construct a new CD3DFrame from the data in a XBMESH_FRAME structure.
//-----------------------------------------------------------------------------
TG_Shape::TG_Shape( LPDIRECT3DDEVICE8 pd3dDevice, TG_Shape* pParent, 
                      XBMESH_FRAME* pFrameData, void* pVBData )
{
    init();
    m_pParent         = pParent;
    m_pChild          = NULL;
    m_pNext           = NULL;

    m_Animation.m_numFrames = pFrameData->m_MeshData.m_numFrames;
    m_Animation.m_firstFrame = 0;
    m_Animation.m_frameRate = pFrameData->m_MeshData.m_frameRate;
    m_Animation.m_tickRate = pFrameData->m_MeshData.m_tickRate;
    m_Animation.m_pPos = pFrameData->m_MeshData.m_pPos;
    m_Animation.m_pQuat = pFrameData->m_MeshData.m_pQuats;

    m_bCommonMemory = true;

     
    
    // Copy info from XBMESH_FRAME structure
    m_transform = pFrameData->m_transform;
  
    if ( pFrameData->m_MeshData.m_dwNumVertices || pFrameData->m_MeshData.m_dwNumIndices )
    {
        m_pMyType = new TG_TypeShape( pFrameData, pVBData );
    }
    else
    {
        m_pMyType = new TG_TypeNode( pFrameData );
    }

    m_pMyType->m_nodeCenter = pFrameData->m_translation;


    // Create the child frame
    if( pFrameData->m_pChild )
        m_pChild = new TG_Shape( pd3dDevice, this, pFrameData->m_pChild, pVBData );

    // Create the sibling frame
    if( pFrameData->m_pNext )
        m_pNext = new TG_Shape( pd3dDevice, pParent, pFrameData->m_pNext, pVBData );


}

TG_TypeShape::TG_TypeShape( XBMESH_FRAME* pFrameData, void* pVBData )
{
    init();

    // Frame info
    strcpy( m_strNodeId, pFrameData->m_strName );

    // Mesh info
    m_nodeCenter          = D3DXVECTOR3(0,0,0);

    m_nNumVertices           = pFrameData->m_MeshData.m_dwNumVertices;
    m_pIndexBuffer           = NULL;
    m_nNumFaces              = pFrameData->m_MeshData.m_dwNumIndices/3;
    m_nFVF                   = pFrameData->m_MeshData.m_dwFVF;
    m_nFVFSize               = pFrameData->m_MeshData.m_dwVertexSize;
    m_nMaterialCount         = pFrameData->m_MeshData.m_dwNumSubsets;
    m_pMaterialIDs           = NULL;

    // Convet the primitive type
  //  if( pFrameData->m_MeshData.m_dwPrimType == (D3DPRIMITIVETYPE)5 )
  //      m_dwMeshPrimType = D3DPT_TRIANGLELIST;
  //  else
  //      m_dwMeshPrimType = D3DPT_TRIANGLESTRIP;


    // Create the vertex buffer
    if( m_nNumVertices )
    {
      
        m_VertexBuffer = pFrameData->m_MeshData.m_VB;
        m_VertexBuffer.Register( pVBData );
    }
        

    // Create the index buffer
    if( m_nNumFaces )
    {
        g_pd3dDevice->CreateIndexBuffer( m_nNumFaces * 3 *sizeof(WORD), 
                                       D3DUSAGE_WRITEONLY, D3DFMT_INDEX16, D3DPOOL_MANAGED, 
                                       &m_pIndexBuffer );
        WORD* pIndices;
        m_pIndexBuffer->Lock( 0, 0, (BYTE**)&pIndices, 0 );
        memcpy( pIndices, (VOID*)pFrameData->m_MeshData.m_IB.Data, m_nNumFaces * 3*sizeof(WORD) );
        m_pIndexBuffer->Unlock();
    }

    // Create the subsets
    if( m_nMaterialCount )
    {
        m_pMaterialIDs = new XBMESH_SUBSET[m_nMaterialCount];
        memcpy( m_pMaterialIDs, pFrameData->m_MeshData.m_pSubsets, m_nMaterialCount*sizeof(XBMESH_SUBSET) );

    }



}



//-----------------------------------------------------------------------------
// Name: WriteToXBG()
// Desc: Writes the geometry objects to a file
//-----------------------------------------------------------------------------
HRESULT TG_Shape::SaveBinary( File* file  )
{
    s_dwNumFrames = 0;

    // Before writing the file, walk the nodes to compute memory requirements
    s_dwFrameSpace    = 0;
    s_dwSubsetSpace   = 0;
    s_dwIndicesSpace  = 0;
    s_dwVerticesSpace = 0;
    s_dwAnimSpace = 0;
    EnumFrames( ComputeMemoryRequirementsCB, NULL );

    // As parts of the file are written, these global file offset variables
    // are used to convert object pointers to file offsets
    s_dwMeshFileOffset     = sizeof(XBG_HEADER);
    s_dwSubsetFileOffset   = s_dwFrameSpace;
    s_dwIndicesFileOffset  = s_dwSubsetFileOffset + s_dwSubsetSpace;
    s_dwVerticesFileOffset = 0;
    s_dwAnimFileOffset = sizeof(XBG_HEADER);


    // Setup the file header
    XBG_HEADER xbgHeader;
    xbgHeader.dwMagic         = XBG_FILE_ID;
    xbgHeader.dwNumMeshFrames = s_dwNumFrames;
    xbgHeader.dwSysMemSize    = s_dwFrameSpace + s_dwSubsetSpace + s_dwIndicesSpace;
    xbgHeader.dwVidMemSize    = s_dwVerticesSpace;
    xbgHeader.dwAnimMemSize    = s_dwAnimSpace;


    // Write out the header
    file->write( (BYTE*)&xbgHeader, sizeof(XBG_HEADER) ); 

    // Write the mesh's parts. Note that, starting at this file offset, in
	// order for Xbox fast math (via xgmath.h) to work, all D3DXMATRIX's must
	// be 16-byte aligned.
    EnumFrames( WriteMeshInfoCB, file );
    EnumFrames( WriteSubsetsCB,  file );
    EnumFrames( WriteIndicesCB,  file );
    EnumFrames( WriteVerticesCB, file );
    EnumFrames( WriteAnimationCB, file );

    
    return S_OK;
}

//-----------------------------------------------------------------------------
TG_Shape*   TG_Shape::GetFirstChild()
{
    return m_pChild;
}


//-----------------------------------------------------------------------------
TG_Shape*   TG_Shape::GetNextChild(TG_Shape* pLast)
{
    ASSERT( pLast );
    if ( pLast )
        return pLast->m_pNext;
    return NULL;
}

//-----------------------------------------------------------------------------
void        TG_Shape::GetRectDims( float& width, float& height )
{
    width = 0;
    height = 0;
    m_pMyType->GetRectDims( width, height );
}

//-----------------------------------------------------------------------------
void        TG_Shape::GetRectDimsAndRecenter(float& width, float& height)
{
    float depth = 0.f;
    m_pMyType->GetRectDimsAndRecenter( width, height, depth );
	D3DXMatrixTranslation( &m_transform, m_pMyType->m_nodeCenter.x, m_pMyType->m_nodeCenter.y, m_pMyType->m_nodeCenter.z );

}

//-----------------------------------------------------------------------------
void TG_Shape::GetRectDimsRecenterBuildRotation(float& width, float& height)
{
    float depth = 0.f;
    m_pMyType->GetRectDimsAndRecenter( width, height, depth );
	D3DXMatrixTranslation( &m_transform, m_pMyType->m_nodeCenter.x, m_pMyType->m_nodeCenter.y, m_pMyType->m_nodeCenter.z );
    
    float theta = 0.f;
    if ( width )
    {
        theta = (float)atan(depth/width);
    }
    D3DXMATRIX rotMat;
    D3DXMatrixRotationZ( &rotMat, -theta  );

    D3DXMatrixMultiply( &m_transform, &rotMat, &m_transform );

}



//-----------------------------------------------------------------------------

void        TG_Shape::GetLocalTransform( D3DXMATRIX& transform )
{
    transform = m_transform;
}


//-----------------------------------------------------------------------------
void        TG_Shape::GetWorldTransform( D3DXMATRIX& transform )
{
    // OK, need to multiply up the parent change
    D3DXMATRIX worldTransform;

    TG_Shape* pParent = m_pParent;
    if ( pParent )
    {
        D3DXMATRIX parentTransform;
        pParent->GetWorldTransform(parentTransform);
	    D3DXMatrixMultiply( &transform, &parentTransform, &m_transform );

    }
    else
    {
        transform = m_transform;
    }
}

//-----------------------------------------------------------------------------
void        TG_Shape::GetNodeCenter( float& x, float& y, float& z )
{
    if ( m_pMyType )
    {
        x = m_pMyType->m_nodeCenter.x;
        y = m_pMyType->m_nodeCenter.y;
        z = m_pMyType->m_nodeCenter.z;
    }
    else
    {
        x = y = z = 0.f;
    }
}

//-----------------------------------------------------------------------------
void        TG_Shape::SwapMaterials( long oldMaterial, long newMaterial )
{
    if ( m_pMyType )
    {
        m_pMyType->SwapMaterials( oldMaterial, newMaterial );
    }
}

//-----------------------------------------------------------------------------
void        TG_Shape::SetMaterials(long newMaterial )
{
    if ( m_pMyType )
    {
        m_pMyType->SetMaterials( newMaterial );
    }
}

//-----------------------------------------------------------------------------
void       TG_Shape::GetZVals(float& numberOfVertices, float& zVal)
{
   D3DVECTOR v = m_pMyType->GetNodeCenter(  );
   zVal = v.y;
   zVal += m_pMyType->GetMinZ();
   
   float VCount = (float)m_pMyType->GetVertexCount();
   numberOfVertices = VCount;
}

//-----------------------------------------------------------------------------
void       TG_Shape::GetMinZ(float& curCount, float& z)
{
    float tmpZ;
    float tmpCount;
    GetZVals( tmpCount, tmpZ );


    if ( tmpCount )
    {
        if ( tmpZ > z )
            z = tmpZ;

        curCount += tmpCount;

        TG_Shape* pKid = m_pChild;
        while( pKid )
        {
            pKid->GetMinZ( curCount, z );
            pKid = pKid->m_pNext;
        }
    }

}

//-----------------------------------------------------------------------------
float TG_Shape::GetMinZ( )
{
    float vertexCount = 0;
    float zVal = -999999999.f;

    GetMinZ( vertexCount, zVal );

    return zVal;
}

//-----------------------------------------------------------------------------
void        TG_Shape::SortShapesZ( )
{
    
    TG_Shape* pPrev = NULL;

    TG_Shape* pKid = m_pChild;
      // first sort by z
    while( pKid )
    {
       pKid->SortShapesZ();
       pKid = pKid->m_pNext;
    }

    pKid = m_pChild;
    pPrev = NULL;
    while( pKid )
    {
        float kidZ = pKid->GetMinZ(); 
        TG_Shape* pCompare = m_pChild;
        TG_Shape* pCompPrev = NULL;
        while( pCompare && pCompare != pKid )
        {
            float compZ = pCompare->GetMinZ();
            if ( compZ < kidZ)
            {
                ASSERT( pPrev );

                // remove this kid frm the list
                pPrev->m_pNext = pKid->m_pNext;
                pKid->m_pNext = pCompare;

                
                // insert it again before kid to compare
                if ( pCompPrev )
                {
                    pCompPrev->m_pNext = pKid;
                }
                else
                {
                    m_pChild = pKid;
                }

                if ( pCompPrev )
                    pKid = pCompPrev; // so when we move the pointer forward, we're on pKid again...
                break;
            }

            pCompPrev = pCompare;
            pCompare = pCompare->m_pNext;

        }
        pPrev = pKid;
        pKid = pKid->m_pNext;
       
    }


}

//-----------------------------------------------------------------------------
void        TG_Shape::SortShapesName( const char** strNames, long nameCount )
{

    TG_Shape* pKid = m_pChild;
    while( pKid )
    {
        pKid->SortShapesName( strNames, nameCount );
        pKid = pKid->m_pNext;
    }

 
    TG_Shape* pFirstChild = m_pChild;
    TG_Shape* pPrev = NULL;
    m_pChild = NULL;

    for ( int i = nameCount-1; i > -1; i-- )
    {
        pKid = pFirstChild;
        pPrev = NULL;
        while( pKid )
        {
            const char* pName = pKid->GetNodeName();
            CharUpperA( (char*)pName );

            if ( strstr( pName, strNames[i] ) )
            {
                 // take out of the temp list;
                if ( pPrev )
                {
                    pPrev->m_pNext = pKid->m_pNext;
                }
                else
                {
                    pFirstChild = pKid->m_pNext;
                }

                TG_Shape* pAdded = pKid;
                pKid = pKid->m_pNext;

                // put in the final
                pAdded->m_pNext = m_pChild;
                m_pChild = pAdded; 

            }
            else

            {
                pPrev = pKid; 
                pKid = pKid->m_pNext;
            }

        }
    }

    // insert untagged ones before the rest...
    if ( pFirstChild )
    {
        TG_Shape* pCurFirst = m_pChild;
        m_pChild = pFirstChild;

        TG_Shape* pCurLast = m_pChild;
        while( pCurLast->m_pNext )
        {
            pCurLast = pCurLast->m_pNext;
        }
        pCurLast->m_pNext = pCurFirst;
    }
   
}

//-----------------------------------------------------------------------------
void        TG_Shape::SortShapes( const char** strNames, long nameCount )
{
    SortShapesZ();
    SortShapesName( strNames, nameCount );  
}

long TG_Shape::ParseAnimationHeader( char* aseContents, TG_Animation* pAnim )
{
  		//------------------------------------------
		// Get first frame of animation from header
		long firstFrame, lastFrame;
		char *frameId = strstr((char *)aseContents,ASE_ANIM_FIRST_FRAME);

        if ( !frameId )
        {
            // no big deal, this file doesn't have animation info
            return E_FAIL;
        }
		ASSERT(frameId != NULL);
		frameId += strlen(ASE_ANIM_FIRST_FRAME)+1;
	
		char numData[512];
		GetNumberData(frameId,numData);
		firstFrame = atol(numData);
	
		frameId = strstr((char *)aseContents,ASE_ANIM_LAST_FRAME);
		ASSERT(frameId != NULL);
	
		frameId += strlen(ASE_ANIM_LAST_FRAME)+1;
	
		GetNumberData(frameId,numData);
		lastFrame = atol(numData);
	
		//ASSERT(firstFrame == 0);
		ASSERT(firstFrame <= lastFrame);
	
		//if (firstFrame == lastFrame)
			//No Animation data at all. Possible?

        pAnim->m_firstFrame = firstFrame;
	
		pAnim->m_numFrames = (lastFrame - firstFrame) + 1;
	
		frameId = strstr((char *)aseContents,ASE_ANIM_FRAME_SPEED);
		ASSERT(frameId != NULL);
	
		frameId += strlen(ASE_ANIM_FRAME_SPEED)+1;
	
		GetNumberData(frameId,numData);
		pAnim->m_frameRate = (float)atof(numData);
	
		frameId = strstr((char *)aseContents,ASE_ANIM_TICKS_FRAME);
		ASSERT(frameId != NULL);
	
		frameId += strlen(ASE_ANIM_TICKS_FRAME)+1;
	
		GetNumberData(frameId,numData);
		pAnim->m_tickRate = (float)atof(numData);
	
    return S_OK;
}

//-------------------------------------------------------------------------------
void GetNextLine (char *rawData, char *result)
{
	long startIndex = 0;
	long endIndex = 0;
	while (	(rawData[startIndex] != '\n') )
	{
		startIndex++;
	}

	startIndex++;
	endIndex = startIndex;
	while (	(rawData[endIndex] != '\n') )
	{
		endIndex++;
	}

	strncpy(result,&rawData[startIndex],endIndex - startIndex);
	result[endIndex-startIndex] = 0;
}

long TG_Shape::LoadAnimationFromASE (char *aseContents, const char* pNodeName, 
                                     D3DXVECTOR3 nodeCenter, TG_Animation* pHeader, TG_Animation* pOneToFill )
{
    long actualCount = 0;

    long retVal = -1;
	
	char *animScan = (char *)aseContents;
	animScan = strstr(animScan,ASE_ANIMATION);

	char nodeName[512];
	sprintf(nodeName,"*NODE_NAME \"%s\"", pNodeName );

    bool countUp = false;
        
	while (animScan != NULL)
	{
		animScan += strlen(ASE_ANIMATION)+1;

		//------------------------------------------------------
		// We found a TM_ANIMATION Section.
		// Check if the VERY NEXT LINE is the correct NodeName
		char nextLine[1024];
		GetNextLine(animScan,nextLine);
        CharUpperA( nextLine );

		if (strstr(nextLine,nodeName) == NULL)
		{
			animScan = strstr(animScan,ASE_ANIMATION);
		}
		else
		{
			animScan += strlen(nodeName)+1;
			break;
		}
	}

	if (animScan != NULL)
	{
        pOneToFill->m_numFrames = pHeader->m_numFrames;
		pOneToFill->m_frameRate = pHeader->m_frameRate;
		pOneToFill->m_tickRate = pHeader->m_tickRate;
        pOneToFill->m_firstFrame = pHeader->m_firstFrame;
		pOneToFill->m_pQuat = NULL;
		pOneToFill->m_pPos = NULL;

        retVal = 0; // OK, we found data
		
		//---------------------------------
		// Check for positional data first!
		char* scanStart = animScan;

		char numData[512];
		char nextLine[1024];
		float timeStamp = (pOneToFill->m_firstFrame+1) * pOneToFill->m_tickRate;

		//----------------------------------------------------
		// Then the very NEXT LINE most be POS_TRACK data OR
		// there is ONLY rotational Data for this node.
		GetNextLine(animScan,nextLine);
		if (strstr(nextLine,ASE_ANIM_POS_HEADER) != NULL)
		{
			animScan = strstr(animScan,ASE_ANIM_POS_HEADER);
			if (animScan)
			{
				countUp = true;
				actualCount++;
				animScan += strlen(ASE_ANIM_POS_HEADER);

				D3DXVECTOR3 thisOffset = nodeCenter;

//				char LineData[1024]; 
//				GetNextLine(animScan,LineData);
//				animScan += strlen(LineData)+1;

                // find close brace, and set to NULL
                char* pClose = strstr( animScan, "}" );
                if ( pClose )
                    *pClose = 0;

  
                for (DWORD j=0;j<pOneToFill->m_numFrames;j++)
				{
					sprintf(nodeName,"%s %d",ASE_ANIM_POS_SAMPLE,(long)timeStamp);
					char* scanData = strstr(animScan,nodeName);

					if (scanData)
					{
						scanData += strlen(nodeName)+1;

						GetNumberData(scanData,numData);
						thisOffset.x = (float)atof(numData);
						scanData += strlen(numData)+1;

						GetNumberData(scanData,numData);
						thisOffset.y = (float)atof(numData);
						scanData += strlen(numData)+1;

						GetNumberData(scanData,numData);
						thisOffset.z = (float)atof(numData);
						scanData += strlen(numData)+1;

//						GetNextLine(animScan,LineData);
//						animScan += strlen(LineData)+1;
					}

                    if ( !pOneToFill->m_pPos )
                    {
                        pOneToFill->m_pPos = new D3DXVECTOR3[pOneToFill->m_numFrames];
                    }

					pOneToFill->m_pPos[j] = thisOffset;
					timeStamp += pOneToFill->m_tickRate;
				}

                if ( pClose )
                    *pClose = '}';
            }
		}
									   
		//-------------------------------------------------------------
		// Check for rotational data. Again, use nextLine.
		
		//----------------------------------------------------
		// Then the very NEXT LINE most be POS_TRACK data OR
		// there is ONLY rotational Data for this node.
		GetNextLine(animScan,nextLine);
		if (strstr(nextLine,ASE_ANIM_ROT_HEADER) != NULL)
		{
			animScan = scanStart;
			timeStamp = (pOneToFill->m_firstFrame+1) * pOneToFill->m_tickRate;

			animScan = strstr(animScan,ASE_ANIM_ROT_HEADER);

			if (animScan)
			{
				countUp = true;
				actualCount++;
				animScan += strlen(ASE_ANIM_ROT_HEADER);

                char* pClose = strstr( animScan, "}" );
                if ( pClose )
                    *pClose = 0;


   			
				for (DWORD j=0;j<pOneToFill->m_numFrames;j++)
				{
					sprintf(nodeName,"%s %d",ASE_ANIM_ROT_SAMPLE,(long)timeStamp);
					char* scanData = strstr(animScan,nodeName);
                    if ( !scanData )
                    {
                        pOneToFill->m_numFrames = j;
                        if ( pClose )
                            *pClose = '}';

                        break;
                    }
                    animScan = scanData;

					D3DXQUATERNION thisFrame;

					float b=0.0f,c=0.0f,d=0.0f,phi=0.0f;

					if (scanData)
					{
						scanData += strlen(nodeName)+1;

						GetNumberData(scanData,numData);
						b = (float)atof(numData);
						scanData += strlen(numData)+1;

						GetNumberData(scanData,numData);
						c = (float)atof(numData);
						scanData += strlen(numData)+1;

						GetNumberData(scanData,numData);
						d = (float)atof(numData);
						scanData += strlen(numData)+1;

						GetNumberData(scanData,numData);
						phi = (float)atof(numData);
	
						//--------------------------------------------
						// MAX Writes out Quaternions as Angle, Axis.
						// Must Convert to real quaternion here.
						thisFrame.w = (float)cos(phi / 2.0f);
						thisFrame.x = b * (float)sin(-phi / 2.0f);
						thisFrame.y = c * (float)sin(-phi / 2.0f);
						thisFrame.z = d * (float)sin(-phi / 2.0f);
					}
					else
					{
						//Otherwise rotation is 0.
						thisFrame.w = 1.0f;
						thisFrame.x = 0.0f;
						thisFrame.y = 0.0f;
						thisFrame.z = 0.0f;
					}

                    D3DXQuaternionNormalize( &thisFrame, &thisFrame );

                    if ( !pOneToFill->m_pQuat )
                    {
                        // We have rotational data at least.  Store everything off.
				        pOneToFill->m_pQuat = new D3DXQUATERNION[pOneToFill->m_numFrames];
				        ASSERT(pOneToFill->m_pQuat != NULL);
                    }

					if (!j)
					{
						pOneToFill->m_pQuat[j] = thisFrame;
					}
					else
					{
                        D3DXQuaternionMultiply( &pOneToFill->m_pQuat[j], &pOneToFill->m_pQuat[j-1], &thisFrame );
						D3DXQuaternionNormalize( &pOneToFill->m_pQuat[j], &pOneToFill->m_pQuat[j] );
					}

					timeStamp += pOneToFill->m_tickRate;
				}

                if ( pClose )
                    *pClose = '}';

			}
		}
		
		countUp = false;
	}

    return retVal;
}
	





#ifdef FIND_MEMORY_LEAK

int fLogMemory = 1;       // Perform logging (0=no; nonzero=yes)?
int cBlocksAllocated = 0;  // Count of blocks allocated.
#undef new


void* __cdecl operator new[](size_t nSize, const char* lpszFileName, int nLine)
{
    return operator new( nSize, lpszFileName, nLine );
}


void* __cdecl operator new(size_t nSize, const char* lpszFileName, int nLine)
{
    static fInOpNew = 0;    // Guard flag.
    void* pRetVal = malloc( nSize );

    if( fLogMemory && !fInOpNew )
    {
    //    fInOpNew = 1;
        char outputStr[256];
        sprintf( outputStr,"MemoryBlock %ld: at %ld allocated %ld bytes, file = %s, line = %ld\n", 
            ++cBlocksAllocated, pRetVal, nSize, lpszFileName, nLine);
        DbgPrint( outputStr );
       
        fInOpNew = 0;
    }

    return pRetVal;

}

/*void* __cdecl operator new(size_t nSize)
{
    static fInOpNew = 0;    // Guard flag.
    void* pRetVal = malloc( nSize );

    if( fLogMemory && !fInOpNew )
    {
    //    fInOpNew = 1;
        char outputStr[256];
        sprintf( outputStr,"MemoryBlock %ld: at %ld allocated %ld bytes\n", 
            ++cBlocksAllocated, pRetVal, nSize);
        DbgPrint( outputStr );
       
        fInOpNew = 0;
    }

    return pRetVal;

}*/

void __cdecl operator delete( void* pMem, const char* lpszFileName, int nLine )
{
    static fInOpDelete = 0;    // Guard flag.
    if( fLogMemory && !fInOpDelete )
    {
    //    fInOpDelete = 1;        
        char outputStr[256];
        sprintf( outputStr,"MemoryBlock %ld: at %ld freed n file = %s, line = %ld\n",
            --cBlocksAllocated, pMem, lpszFileName, nLine );
        DbgPrint( outputStr );
    }

    free( pMem );

}

void __cdecl operator delete( void* pMem )
{
    static fInOpDelete = 0;    // Guard flag.
    if( fLogMemory && !fInOpDelete )
    {
  //      fInOpDelete = 1;        
        char outputStr[256];
        sprintf( outputStr,"MemoryBlock %ld: at %ld freed\n", --cBlocksAllocated, pMem );
        DbgPrint( outputStr );
    }

    free( pMem );

}



#endif



//-------------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\xodash\XODashLib\Translator.cpp ===
//-------------------------------------------------------------
// Copyright (c) Microsoft Corporation.  All rights reserved
// Author: Natalyp
//-------------------------------------------------------------
#include "std.h"
#include "utilities.h"
#include "Translator.h"
#include "StringObj.h"

static const CHAR* rgszTranslateSection[] =
{
	"NoLanguageXlate", 
    "EnglishXlate",
    "JapaneseXlate",
    "GermanXlate",
    "FrenchXlate",
    "SpanishXlate",
    "ItalianXlate"
};

CTranslator* CTranslator::pinstance = 0;// initialize pointer
CTranslator::CTranslator() 
{ 

}

CTranslator* CTranslator::Instance () 
{
   if (pinstance == 0)  // is it the first call?
   {  
      pinstance = new CTranslator; // create sole instance
	  pinstance->m_nCurLanguage = -1;
	  pinstance->m_nCurGameRegion = -1;
	  pinstance->m_hXlate = INVALID_HANDLE_VALUE;
   }
   return pinstance; // address of sole instance
}

HRESULT CTranslator::Initialize()
{
	m_nCurLanguage = XGetLanguage() ;
	m_nCurGameRegion = XGetGameRegion();
    
    // BUGBUG: Currently default to US....need to get other country codes
    if( FAILED( m_LocaleInfo.LoadLocale( m_nCurLanguage, 103) ) )
    {
        return E_FAIL;
    }
    
	return LoadXlate();
}

HRESULT CTranslator::Initialize( int nCountryCode )
{
	m_nCurLanguage = XGetLanguage() ;
	m_nCurGameRegion = XGetGameRegion();
    
    if( FAILED( m_LocaleInfo.LoadLocale( m_nCurLanguage, nCountryCode ) ) )
    {
        return E_FAIL;
    }
    
	return LoadXlate();
}

HRESULT CTranslator::LoadXlate()
{
	ASSERT(m_nCurLanguage>=0);
	ASSERT(m_nCurLanguage < countof(rgszTranslateSection));
	HRESULT hr = S_OK;
	TCHAR* rgchXlateData = NULL;
    
	do
	{
		m_hXlate = XGetSectionHandle(rgszTranslateSection[m_nCurLanguage]);
		if(m_hXlate == INVALID_HANDLE_VALUE)
		{
			hr = HRESULT_FROM_WIN32(ERROR_INVALID_HANDLE);
			BREAKONFAIL2(hr, "CTranslator::LoadXlate- fail to get SectionHandle for %s", rgszTranslateSection[m_nCurLanguage]);
		}
		
		rgchXlateData =(TCHAR*) XLoadSectionByHandle(m_hXlate);
		ASSERT(*(WORD*)rgchXlateData == 0xFEFF);
		if (m_hXlate == INVALID_HANDLE_VALUE || !rgchXlateData || *(WORD*)rgchXlateData != 0xFEFF)
		{
			hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA	);
			BREAKONFAIL2(hr, "Unable to load translation \"%hs\" from section, data maybe corrupted", rgszTranslateSection[m_nCurLanguage] );
		}

		{
			TCHAR* pch = rgchXlateData + 1; // Skip Unicode BOM
			TCHAR* pchLineStart = rgchXlateData + 1;
			TCHAR* pchLineEnd = rgchXlateData + 1;

			while (*pchLineEnd != 0)
			{
        
				while (*pchLineEnd != '\n' && *pchLineEnd!=0)
					pchLineEnd++ ;

				if(*pchLineStart != '[' && *pchLineStart != ';' && *pchLineStart != 0x0D && *pchLineStart != ' ')
				{
					ParseLine(pchLineStart, pchLineEnd);
				}
						
				pchLineEnd++;
				pchLineStart = pchLineEnd;
			}

		}

	} while(0);

	if(m_hXlate != INVALID_HANDLE_VALUE)
	{
		ASSERT(XFreeSectionByHandle(m_hXlate));
	}
  
	return hr;
}


bool CTranslator::ParseLine(TCHAR* pchStart, TCHAR* pchEnd)
{
	TCHAR* pchKeyEnd = NULL;	

	for (pchKeyEnd = pchStart; pchKeyEnd <= pchEnd; pchKeyEnd++)
	{
		if(*pchKeyEnd == '=')
			break;
	}
	ASSERT(pchKeyEnd < pchEnd);

	TCHAR* pchStringEnd = NULL;

	ASSERT(*(pchKeyEnd+1) == '"');
	
	for (pchStringEnd = pchKeyEnd+2; pchStringEnd <= pchEnd; pchStringEnd++)
	{
		if(*pchStringEnd == '"')
			break;
	}
	
	ASSERT(*pchStringEnd == '"');

	CStringObj StringId(pchStart, pchKeyEnd-pchStart);
	CStringObj StringText(pchKeyEnd+2, pchStringEnd - (pchKeyEnd+2));

	m_TranslateMap.insert(TranslateMap::value_type(StringId, StringText));

	return true;
}


const TCHAR* CTranslator::Translate(TCHAR* szString)
{
	CStringObj KeyStr(szString);
	TranslateMapIterator iter = m_TranslateMap.find(KeyStr);

//	ASSERT(iter!= m_TranslateMap.end());
	if(iter == m_TranslateMap.end())
		return NULL;
	return (*iter).second.c_str();
}

void CTranslator::Cleanup()
{
	m_TranslateMap.erase(m_TranslateMap.begin(), m_TranslateMap.end());
}

void CTranslator::SetLanguage(DWORD dwLang)
{
	if(XC_LANGUAGE_UNKNOWN == dwLang)
	{
		m_nCurLanguage +=1;
		if (m_nCurLanguage > 6)
		{
			m_nCurLanguage = 1;
		}
	}
	else
	{
		if(dwLang >0 && dwLang <=6)
		{
			m_nCurLanguage = dwLang;
		}
	}

	XSetValue(XC_LANGUAGE, REG_DWORD, (DWORD*)&m_nCurLanguage, 4);
	Cleanup();
	Initialize();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\xodash\XODashLib\Translator.h ===
#pragma once
#include <map>
#include "StringObj.h"
#include "locale.h"

using namespace std;


typedef map <CStringObj, CStringObj> TranslateMap;
typedef TranslateMap::iterator TranslateMapIterator;

class CTranslator
  {
  public:
      static CTranslator* Instance();
      LocaleInfo m_LocaleInfo;
	  const TCHAR* Translate(TCHAR*);
	  HRESULT Initialize();
      HRESULT Initialize( int nCountryCode );
	  void Cleanup();

	  void SetLanguage(DWORD dwLang = XC_LANGUAGE_UNKNOWN);
	  inline DWORD GetCurLanguage() { return m_nCurLanguage;}
  protected:
      CTranslator(const CTranslator&);
      CTranslator& operator= (const CTranslator&);
	  CTranslator();
  private:
      static CTranslator* pinstance;

	  HRESULT LoadXlate();
	  bool ParseLine(TCHAR* pchStart, TCHAR* pchEnd);
	  HANDLE m_hXlate;
	  TranslateMap m_TranslateMap;

	  long m_nCurLanguage;
	  long m_nCurGameRegion;
  };
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\xodash\XODashLib\utilities.h ===
#pragma once 

#include "std.h"


float GetFloat( char** pStr );
void GetNameData (char *rawData, char *result);
void GetWordData (char *rawData, char *result);
void GetNumberData (char *rawData, char *result);
float XAppGetNow();

void Unicode(wchar_t* wsz, const char* sz, int nMaxChars);
void Ansi(char* sz, const TCHAR* wsz, int nMaxChars);

#define countof(n) (sizeof (n) / sizeof (n[0]))


#ifdef _DEBUG
void XAppGetErrorString(HRESULT hr, TCHAR* szBuf, int cchBuf);
const TCHAR* XAppGetErrorString(HRESULT hr);
void LogComError(HRESULT hr, const char* szFunc = NULL);
void LogError(const char* szFunc);
#else
inline void LogComError(HRESULT hr, const char* szFunc = NULL) {}
inline void LogError(const char* szFunc) {}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\xodash\XODashLib\XbStopWatch.h ===
//-----------------------------------------------------------------------------
// File: XbStopWatch.h
//
// Desc: StopWatch object using QueryPerformanceCounter
//
// Hist: 01.19.01 - New for March XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef XBSTOPWATCH_H
#define XBSTOPWATCH_H

#include <xtl.h>




//-----------------------------------------------------------------------------
// Name: class CXBStopWatch
// Desc: Simple timing object using stopwatch metaphor
//-----------------------------------------------------------------------------
class CXBStopWatch
{
    FLOAT    m_fTimerPeriod;        // seconds per tick (1/Hz)
    LONGLONG m_nStartTick;          // time watch last started/reset
    LONGLONG m_nPrevElapsedTicks;   // time watch was previously running
    BOOL     m_bIsRunning;          // TRUE if watch is running

public:

    explicit CXBStopWatch( BOOL bStartWatch = TRUE );

    VOID  Start();
    VOID  StartZero();
    VOID  Stop();
    VOID  Reset();

    BOOL  IsRunning() const;
    FLOAT GetElapsedSeconds() const;
    FLOAT GetElapsedMilliseconds() const;

private:

    LONGLONG GetTicks() const;

};

#endif // XBSTOPWATCH_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\xodash\XODashLib\utilities.cpp ===
#include "std.h"

#include "globals.h"

float XAppGetNow()
{
	return *g_fAppTime;
}

void Unicode(wchar_t* wsz, const char* sz, int nMaxChars)
{
	while (nMaxChars-- > 0)
	{
		if ((*wsz++ = (unsigned char)*sz++) == 0)
			return;
	}
}

void Ansi(char* sz, const TCHAR* wsz, int nMaxChars)
{
	while (nMaxChars-- > 0)
	{
		if ((*sz++ = (char)*wsz++) == 0)
			return;
	}
}	

float GetFloat( char** pStr )
{
	float retVal = 0.f;
	char* pTmp = *pStr;
	bool bNumFound = 0;
	char* pStart = *pStr;
	while(true)
	{
		if ( isspace( *pTmp ) )
		{
			if ( bNumFound )
				break;
			
			pTmp++;
		}
		else if ( *pTmp == NULL )
			break;
		else if ( !isdigit( *pTmp ) && *pTmp != '.' && *pTmp != '-' )
			break;
		else
		{
			if ( !bNumFound )
				pStart = pTmp;
			pTmp++;
			bNumFound = true;
		}
	}

	char tmpBuffer[32];
	tmpBuffer[0] = 0;
	strncpy( tmpBuffer, pStart, pTmp - pStart );
	tmpBuffer[pTmp-pStart] = 0;

	retVal = (float)atof( tmpBuffer );

	*pStr = pTmp;

	return retVal;
}
//-------------------------------------------------------------------------------
void GetNameData (char *rawData, char *result)
{
	long startIndex = 0;
	long endIndex = 0;
	while (	(rawData[startIndex] != '"') )
	{
		startIndex++;
	}

	startIndex++;
	endIndex = startIndex;
	while (	(rawData[endIndex] != '"') )
	{
		endIndex++;
	}

	strncpy(result,&rawData[startIndex],endIndex - startIndex);
	result[endIndex-startIndex] = 0;
}


//-------------------------------------------------------------------------------
// Parse Functions
void GetNumberData (char *rawData, char *result)
{
	long startIndex = 0;
	long endIndex = 0;

    if ( NULL == rawData )
    {
        *result = 0;
        return;
    }


	while (	(rawData[startIndex] != '+') &&
			(rawData[startIndex] != '-') &&
			(rawData[startIndex] != '.') &&
			(rawData[startIndex] < '0') ||
			(rawData[startIndex] > '9'))
	{
		startIndex++;
	}

	endIndex = startIndex;
	while (	(rawData[endIndex] == '+') ||
			(rawData[endIndex] == '-') ||
			(rawData[endIndex] == '.') ||
			(rawData[endIndex] >= '0') &&
			(rawData[endIndex] <= '9'))
	{
		endIndex++;
	}

	strncpy(result,&rawData[startIndex],endIndex - startIndex);
	result[endIndex-startIndex] = 0;
}	

//-------------------------------------------------------------------------------
void GetWordData (char *rawData, char *result)
{
	long startIndex = 0;
	long endIndex = 0;
	while (	(rawData[startIndex] < 'A') ||
			(rawData[startIndex] > 'Z') &&
			(rawData[startIndex] < 'a') ||
			(rawData[startIndex] > 'z'))
	{
		startIndex++;
	}

	endIndex = startIndex;
	while (	((rawData[endIndex] >= 'A') && (rawData[endIndex] <= 'Z')) ||
			(rawData[endIndex] == '_') ||
			((rawData[endIndex] >= 'a') && (rawData[endIndex] <= 'z')) )
	{
		endIndex++;
	}

	strncpy(result,&rawData[startIndex],endIndex - startIndex);
	result[endIndex-startIndex] = 0;
}	


extern "C" bool AssertFailed(const TCHAR* szFile, int nLine, HRESULT hr)
{
	TCHAR szBuffer [256];

	if (hr == 0)
	{
		_stprintf(szBuffer, _T("Assertion failed in %s at line %d (last error code is 0x%x)."), szFile, nLine, GetLastError());
	}
	else
	{
	//	TCHAR szComError [100];
	//	XAppGetErrorString(hr, szComError, countof(szComError));
	//	_stprintf(szBuffer, _T("COM Failure in %s at line %d.\n\nFacility: %d %s\nCode %d (0x%04x)\n\n%s"),
	//		szFile, nLine, HRESULT_FACILITY(hr), GetFacilityName(HRESULT_FACILITY(hr)), HRESULT_CODE(hr), HRESULT_CODE(hr), szComError);
	}

#ifdef _XBOX
	DbgPrint("\001XApp: %s\n", szBuffer);
	return true;
#else
//	_tcscat(szBuffer, _T("\n\nDo you want to debug?"));
//	return XAppMessageBox(szBuffer, MB_YESNO) == IDYES;
#endif
}

#ifdef _DEBUG
#define countof(n) (sizeof (n) / sizeof (n[0]))


extern "C" void Trace(char* szMsg, ...)
{
	DbgPrint("[%s][line %d] ",__FILE__, __LINE__);

	va_list args;
	va_start(args, szMsg);

	CHAR szBuffer [512];
	_vsnprintf(szBuffer, 512, szMsg, args);
	DbgPrint("%s\n", szBuffer);
	va_end(args);
}

extern "C" void TraceInFile(char* szMsg, ...)
{
	va_list args;
	va_start(args, szMsg);

	CHAR szBuffer [512];
	_vsnprintf(szBuffer, 512, szMsg, args);
	Trace("%s\n", szBuffer);
	va_end(args);
// #ifdef TRACEFILE
	FILE *stream = fopen("c:\\temp\\temp1.txt", "w");
	if (!stream)
	{
		;
	}
	fprintf(stream,"%s\n",szBuffer);
	fclose(stream);
// #endif

}





extern "C" void Alert(const TCHAR* szMsg, ...)
{
	va_list args;
	va_start(args, szMsg);

	TCHAR szBuffer [512];
	_vsntprintf(szBuffer, 512, szMsg, args);
	DbgPrint("\007%s\n", szBuffer);
	va_end(args);
}


const TCHAR* GetFacilityName(int nFacility)
{
	const TCHAR* szFacility;

	switch (nFacility)
	{
	default:
		szFacility = _T("Unknown Facility");
		break;

	case FACILITY_NULL:
		szFacility = _T("null");
		break;

	case FACILITY_RPC:
		szFacility = _T("RPC");
		break;

	case FACILITY_DISPATCH:
		szFacility = _T("Dispatch");
		break;

	case FACILITY_STORAGE:
		szFacility = _T("Storage");
		break;

	case FACILITY_ITF:
		szFacility = _T("ITF");
		break;

	case FACILITY_WIN32:
		szFacility = _T("Win32");
		break;

	case FACILITY_WINDOWS:
		szFacility = _T("Windows");
		break;

	case FACILITY_SSPI:
		szFacility = _T("SSPI");
		break;

	case FACILITY_CONTROL:
		szFacility = _T("Control");
		break;

	case FACILITY_CERT:
		szFacility = _T("Cert");
		break;

	case FACILITY_INTERNET:
		szFacility = _T("Internet");
		break;

	case FACILITY_MEDIASERVER:
		szFacility = _T("Media Server");
		break;

	case FACILITY_MSMQ:
		szFacility = _T("MSMQ");
		break;

	case FACILITY_SETUPAPI:
		szFacility = _T("Setup API");
		break;

	case 0x15: // _FACDPV
		szFacility = _T("DirectPlayVoice");
		break;

	case 0x876: // _FACDD, _FACD3D
		szFacility = _T("Direct3D");
		break;

	case 0x877: // _FACDP
		szFacility = _T("DirectPlay");
		break;

	case 0x878: // _FACDS
		szFacility = _T("DirectSound");
		break;
	}

	return szFacility;
}
///////////////////////////


/////////////////////////////////////
// Nat Tracing utils
void XAppGetErrorString(HRESULT hr, TCHAR* szErrorBuf, int cchErrorBuf)
{
	int nCode = HRESULT_CODE(hr);
	int nFacility = HRESULT_FACILITY(hr);

	const TCHAR* szFacility = GetFacilityName(nFacility);
	_tcsncpy(szErrorBuf, szFacility, cchErrorBuf);
	int cchFacility = _tcslen(szFacility);
	szErrorBuf += cchFacility;
	cchErrorBuf -= cchFacility;

	if (cchErrorBuf > 2)
	{
		*szErrorBuf++ = ':';
		*szErrorBuf++ = ' ';
		cchErrorBuf -= 2;
	}

#ifdef _LAN
	if (nFacility == FACILITY_INTERNET)
	{
		extern void GetInternetErrorString(int nCode, TCHAR* szBuf, int cchBuf);
		GetInternetErrorString(nCode, szErrorBuf, cchErrorBuf);
		return;
	}
#endif

	if (nFacility == FACILITY_WIN32)
	{
#ifndef _XBOX
		if (FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM, NULL, nCode, 0, szErrorBuf, cchErrorBuf, NULL) == 0)
#endif
			_stprintf(szErrorBuf, _T("Lookup %d in winerror.h!"), nCode);
		return;
	}

	D3DXGetErrorString(hr, szErrorBuf, cchErrorBuf);
}

const TCHAR* XAppGetErrorString(HRESULT hr)
{
	static TCHAR szBuf [100];
	XAppGetErrorString(hr, szBuf, (sizeof (szBuf) / sizeof (szBuf[0]))  );
	return szBuf;
}

void LogComError(HRESULT hr, const char* szFunc/*= NULL*/)
{
	TCHAR szError [100];
	XAppGetErrorString(hr, szError, countof(szError));

	DbgPrint("\001Error in function: %s\n\001%s\n", szFunc == NULL ? "unknown" : szFunc, szError);
}

void LogError(const char* szFunc)
{
	DbgPrint("\001Error in function: %s\n", szFunc);
}




#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\xodash\XODashLib\tgl.h ===
/*************************************************************************************************\
TGL.h		        : Interface for TG_Shape and TG_TypeShape -- the main rendered objects for the
                        dash, these objects are created with ASEConv.  The scene class holds a 
                        root node for all of them, and calls the load functions.  ASEScene calls 
                        the save function.
                        
Creation Date		: 1/8/2002 11:08:29 AM
Copyright Notice	: (C) 2000 Microsoft
Author				: Heidi Gaertner
//-------------------------------------------------------------------------------------------------
Notes				: 
\*************************************************************************************************/


#ifndef TGL_H
#define TGL_H

#include "std.h"

class File;

//-----------------------------------------------------------------------------
// Mimicking resource structures as the Xbox will see them
//-----------------------------------------------------------------------------
#define D3DCOMMON_TYPE_VERTEXBUFFER  0x00000000
#define D3DCOMMON_TYPE_INDEXBUFFER   0x00010000

// The magic number to identify .xbg files
#define XBG_FILE_ID (((DWORD)'X'<<0)|(((DWORD)'B'<<8))|(((DWORD)'A'<<16))|(2<<24))

class TG_Shape;

// for finding memory leaks
#ifdef FIND_MEMORY_LEAK
void* __cdecl operator new (size_t size );
void __cdecl operator delete( void* pMem );
//void* operator new [] ( size_t size );
#endif

//-----------------------------------------------------------------------------
// Name: struct XBG_HEADER
// Desc: Header for a .xbg file
//-----------------------------------------------------------------------------
struct XBG_HEADER
{
    DWORD dwMagic;
    DWORD dwNumMeshFrames;
    DWORD dwSysMemSize;
    DWORD dwVidMemSize;
    DWORD dwAnimMemSize;
};


//-----------------------------------------------------------------------------
// Name: struct XBMESH_SUBSET
// Desc: Struct to hold data for rendering a mesh
//-----------------------------------------------------------------------------
struct XBMESH_SUBSET
{
    DWORD m_ID;		// from our resource MGR
    DWORD m_numUsed; // range of vertices
};

//-----------------------------------------------------------------------------
// Name: struct XBMESH_DATA
// Desc: Struct to hold data for a mesh
//-----------------------------------------------------------------------------
#pragma pack(1) 
struct XBMESH_DATA
{
    D3DVertexBuffer    m_VB;           // Mesh geometry
    DWORD              m_dwNumVertices;
    D3DIndexBuffer     m_IB;
    DWORD              m_dwNumIndices;
    
    DWORD              m_dwFVF;         // Mesh vertex info
    DWORD              m_dwVertexSize;
    D3DPRIMITIVETYPE   m_dwPrimType;

    DWORD              m_dwNumSubsets;  // Subset info, for rendering
    XBMESH_SUBSET*     m_pSubsets;

   	DWORD						m_numFrames;				//Number of Frames of animation.
	float 						m_frameRate;				//Number of Frames Per Second.
	float						m_tickRate;				    //Number of Ticks Per Second.
    D3DXVECTOR3*                m_pPos;
    D3DXQUATERNION*             m_pQuats;


};

#pragma pack()


//-----------------------------------------------------------------------------
// Name: struct XBMESH_FRAME
// Desc: Struct to provide a hierarchial layout of meshes. Note: in order for
//       Xbox fast math (via xgmath.h) to work, all D3DXMATRIX's must be
//       16-byte aligned.
//-----------------------------------------------------------------------------
__declspec(align(16)) struct XBMESH_FRAME
{
    D3DXVECTOR3        m_translation;  // Make sure this is 16-byte aligned!
    D3DXMATRIX         m_transform;
    
    XBMESH_DATA        m_MeshData;
    
    CHAR               m_strName[64];
    
    XBMESH_FRAME*      m_pChild;
    XBMESH_FRAME*      m_pNext;
};

struct TG_Animation
{
	DWORD						m_numFrames;				//Number of Frames of animation.
    DWORD                       m_firstFrame;
	float 						m_frameRate;				//Number of Frames Per Second.
	float						m_tickRate;				//Number of Ticks Per Second.
	D3DXQUATERNION*		        m_pQuat;					//Stores animation offset in Quaternion rotation.
	D3DXVECTOR3* 				m_pPos;					//Stores Positional offsets if present.  OTHERWISE NULL!!!!!!!!
		
};


//-------------------------------------------------------------------------------
// Structs used by layer.
//
typedef DWORD* DWORDPtr;

#define MAX_CHILD_OBJECTS   32

#define TG_SHAPE_TOO_MANY_CHILDREN 0x0001000

// empty TG_Shape, has a name, maybe a transform
class TG_TypeNode
{
	//---------------
	// Data Members
	protected:
		D3DXVECTOR3				m_nodeCenter;
		char					m_strNodeId[32];
		
	//---------------------
	// Member Functions
    protected:
        TG_TypeNode( TG_TypeNode& );

    private:
        // suppresed
        TG_TypeNode& operator=( const TG_TypeNode& );

	public:
	     TG_TypeNode( XBMESH_FRAME* pFrameData );
         TG_TypeNode() { init(); }
         virtual ~TG_TypeNode(){}

         virtual TG_TypeNode* Copy(); // virtual copy c'tor

         virtual long GetVertexCount() const { return 0; }

			
 		virtual void init (void)
		{
			m_strNodeId[0] = '\0';
			m_nodeCenter.x = m_nodeCenter.y = m_nodeCenter.z = 0.0f;
		}
		
		virtual void destroy (void);
		
		char *getNodeId (void)
		{
			return m_strNodeId;
		}

		D3DVECTOR GetNodeCenter (void) const
		{
			return m_nodeCenter;
		}

        virtual void GetRectDims(float& width, float& height){}
        virtual void GetRectDimsAndRecenter(float& width, float& height, float& depth){}

        virtual long SwapMaterials (DWORD indexToReplace, DWORD replaceItWithThis) { return -1; }
        virtual void SetMaterials (DWORD replaceItWithThis) {}
        virtual bool isShape() { return 0; }    // hack instead of RTTI
        virtual float GetMinZ() { return 0.f; }

        virtual HRESULT Render (){ return S_OK; } \

        friend class TG_Shape;

};

typedef TG_TypeNode* TG_TypeNodePtr;

class TG_MultiShape;
class TG_TypeMultiShape;
class TG_Shape;

#define TEXTURE_VERTEX_FVF D3DFVF_XYZ |D3DFVF_NORMAL|D3DFVF_TEX1 
#define NORMAL_VERTEX_FVF			D3DFVF_XYZ |D3DFVF_NORMAL	
#define COLOR_VERTEX_FVF			D3DFVF_XYZ | D3DFVF_DIFFUSE
//-------------------------------------------------------------------------------
// The meat and Potatoes part.
// TG_Shape
class TG_TypeShape : public TG_TypeNode
{
	//-------------------------------------------------------
	// This class runs the shape.  Knows how to load/import
	// an ASE file.  Can dig information out of the file for
	// User use (i.e. Texture Names).  Transforms, lights, clips
	// and renders the shape.

	friend TG_TypeMultiShape;
	friend TG_MultiShape;
	friend TG_Shape;

	
	//-------------
	//Data Members
	protected:
		DWORD					m_nNumVertices;			//Number of vertices in Shape
		D3DVertexBuffer	        m_VertexBuffer;
		D3DIndexBuffer*	        m_pIndexBuffer;			// not necessarily used
		DWORD					m_nNumFaces;
		XBMESH_SUBSET*			m_pMaterialIDs;				//Number of textures in Shape
		DWORD					m_nMaterialCount;
		DWORD					m_nFVF;
		DWORD					m_nFVFSize;

        BYTE*                   m_pMem;                 // for ASE parsing only, or copy c'tors
        float                   m_fMinZDepth;           // also for ase parsing...


		//-------------------------------------------------------------------------------
		// TG_TypeVertex
		//This Structure stores information for each vertex of the shape which DOES NOT CHANGE by instance
		struct TG_NormalVertex
		{
			//Only changes at load time.
			D3DXVECTOR3	position;				//Position of vertex relative to base position of shape.
			D3DXVECTOR3	normal;
		};

		struct TG_UVVertex
		{
			D3DXVECTOR3	position; // The 3D position for the vertex
			D3DXVECTOR3	normal;
			float u,v;
		};

		struct TG_ColorVertex
		{
			D3DXVECTOR3	position;				//Position of vertex relative to base position of shape.
			DWORD		argb;
		};


	//-----------------
	//Member Functions
	protected:

	public:

        virtual TG_TypeNode* Copy(); // virtual copy c'tor


		virtual void init (void);
		
		TG_TypeShape (void)
		{
			init();
		}

        TG_TypeShape( XBMESH_FRAME* pFrameData, void* pVBData );
        TG_TypeShape( TG_TypeShape& );


		virtual void destroy (void);

		virtual ~TG_TypeShape (void)
		{
			destroy();
		}

         virtual bool isShape() { return 1; }    // hack instead of RTTI

 		//Function return 0 is OK.  -1 if file is not ASE Format or missing data.
		//This function simply parses the ASE buffers handed to it.  This allows
		//users to load the ase file themselves and manage their own memory for it.
		//It allocates memory for internal Lists.  These are straight mallocs at present.
		//
		// NOTE: Only takes the first GEOMOBJECT from the ASE file.  Multi-object
		// Files will require user intervention to parse!!
		long ParseASEFile (BYTE *aseBuffer, const char *filename, const D3DVECTOR& parentLoc);	//filename for error reporting ONLY


		long ParseASENoTextures (BYTE *aseBuffer, const char *fileName, const D3DVECTOR& parentLoc);

		//Function returns 0 if OK.  -1 if file not found or file not ASE Format.		
		//This function loads the ASE file into the TG_Triangle and TG_Vertex lists.
		//It allocates memory.  These are straight news at present.
		//
		// NOTE: Only takes the first GEOMOBJECT from the ASE file.  Multi-object
		// Files will require user intervention to parse!!
		long LoadTGShapeFromASE (const char* buffer,  const char *fileName, const D3DVECTOR& parentLoc);

		// pre-lit vertices
		long ParseASEColors (BYTE *aseBuffer, const char *fileName, const D3DVECTOR& parentLoc);


		//Function returns 0 if OK.  -1 if textureNum is out of range of numTextures.
		//This function takes the gosTextureHandle passed in and assigns it to the
		//textureNum entry of the listOfTextures;
        long SwapMaterials (DWORD indexToReplace, DWORD replaceItWithThis);
        void SetMaterials( DWORD newMaterial );


        virtual void GetRectDims( float& width, float& height );
        virtual void GetRectDimsAndRecenter(float& width, float& height, float& depth);
       
   		virtual HRESULT Render ( );

        virtual long GetVertexCount() const { return m_nNumVertices; }
        virtual float GetMinZ() { return m_fMinZDepth; }


		struct TG_TVert
		{
			float	u, v;
		};

		struct TG_TFace
		{
			long   index0, index1, index2;
		};

  

    private:

    bool CreateNewNormal( const D3DXVECTOR3& newNormal, TG_NormalVertex* pListOfVertices, 
        long* normalCounts, long& index, long* altIndex  );

};

typedef TG_TypeShape* TG_TypeShapePtr;

//-------------------------------------------------------------------------------------
// The OTHER meat and Potatoes part.  This is the actual instance the game draws with.
// TG_Shape
class TG_Shape
{
	//-------------------------------------------------------
	// This class runs the shape instance.
	// Transforms, lights, clips and renders the shape.

	friend TG_MultiShape;
	friend TG_TypeShape;
	friend TG_TypeNode;
	friend TG_TypeMultiShape;

	
	
	//-------------
	//Data Members
	protected:
		TG_TypeNode*			m_pMyType;						//Pointer to the instance of the shape.
		D3DXMATRIX				m_transform;
		
		TG_Shape*				m_pChild;					    // array of kids
		TG_Shape*				m_pParent;
        TG_Shape*               m_pNext;

        TG_Animation            m_Animation;


        bool                    m_bCommonMemory;                  // if from ASE, we alloc ourseleves, otherwise need to clean up
        DWORD                   m_dwEnumeratedID;

        bool                    m_bRender;                      // turn off things like text regions
        long                    m_dwFrameID;                    // only needed when saving ASE;s

        D3DXVECTOR3             m_Scale;                       // too hard to put in and out of the transform
        float                   m_curTime;                     // animate

        static DWORD            s_dwNumFrames;
        static DWORD            s_dwFrameSpace;
        static DWORD            s_dwSubsetSpace;
        static DWORD            s_dwIndicesSpace;
        static DWORD            s_dwVerticesSpace;
        static DWORD            s_dwAnimSpace;
        static DWORD            s_dwMeshFileOffset;
        static DWORD            s_dwSubsetFileOffset;
        static DWORD            s_dwIndicesFileOffset;
        static DWORD            s_dwVerticesFileOffset;
        static DWORD            s_dwAnimFileOffset;


        
		

	public:

	//-----------------
	//Member Functions
	protected:

	public:

		void init (void)
		{
			m_pMyType = NULL;
			D3DXMatrixIdentity(&m_transform);
			m_pChild = NULL;
			m_pParent = NULL;
            m_pNext = NULL;
            m_dwEnumeratedID = 0;
            m_bRender = 1;
            m_Scale.x = m_Scale.y = m_Scale.z = 1.f;
            memset( &m_Animation, 0, sizeof( m_Animation  ) );
            m_curTime = 0.f;
            m_bCommonMemory = 0;

		}
		
		TG_Shape (void)
		{
			init();
		}

        TG_Shape( TG_Shape& src );

        TG_Shape( LPDIRECT3DDEVICE8 pd3dDevice, TG_Shape* pParent, 
                      XBMESH_FRAME* pFrameData, void* pVBData );
        
		// add a child to the heirarchy
        HRESULT AddChild( TG_Shape* pKid );
        
		void Destroy (void);

		~TG_Shape (void)
		{
			Destroy();
		}

		void Dump(bool bAllData = false);


		// ASE parsing routine
        long        Load(const char* buffer, const char* fileName, const D3DVECTOR& parentLoc, TG_Animation* pHeader );

        // Move this thing around with these
		void        SetTransform( const D3DXMATRIX& newTransform );
   		void		LocalRotateY( float angle );
		void		LocalRotateZ( float angle );
        void        LocalRotateX( float angle );

        // scale it with this
        void        SetScale( float newX, float newY, float newZ );

        void        GetLocalTransform( D3DXMATRIX& transform );
        void        GetWorldTransform( D3DXMATRIX& transform );


		// draw
        long        Render (  );
        HRESULT     FrameMove( float frameLength );

        // Use these to iterate through the tree
        TG_Shape*   GetFirstChild();
        TG_Shape*   GetNextChild(TG_Shape* pLast);

		
		char *      GetNodeName (void) const;

        TG_Shape*   GetParent( ) {return m_pParent;}


        // set the name of this object
        void        SetNodeName(const char*);

        // search for subobject with this name, will recurse
        TG_Shape*   FindObject( const char* pName );

        HRESULT     SaveBinary(File* pFile);

        // returns the width and height of the first 4 vertices of this object
        void        GetRectDims( float& width, float& height );
        // does the above, and moves the center point
        void        GetRectDimsAndRecenter(float& width, float& height);
        // does the above, and builds a rotation into the transform -- this is for text
        void        GetRectDimsRecenterBuildRotation(float& width, float& height);

        void        GetNodeCenter( float& x, float& y, float& z );

        // swap the old with the new
        void        SwapMaterials( long oldMaterial, long newMaterial );
        // set all materials to the new one
        void        SetMaterials( long newMaterial );

        void setVisible( bool bVisible )
        {
            m_bRender = bVisible;
        }

        bool isVisible() const { return m_bRender; }

        // sort all the children.. first by Z, then by the names that are passed in
        void        SortShapes( const char** strNames, long nameCount );
        void        SortShapesName( const char** strNames, long nameCount );
        // sort by Z
        void        SortShapesZ( );

        HRESULT     BeginAnimation(bool bLoop);
        HRESULT     EndAnimation( );

        
        static long    ParseAnimationHeader( char* aseContents, TG_Animation* pHeader );
        static long    LoadAnimationFromASE (char *aseContents, const char* pNodeName, 
                                     D3DXVECTOR3 nodeCenter, TG_Animation* pHeader, TG_Animation* pOneToFill );


// HELPER FUNCTIONS
    private:

    



    static BOOL ComputeMemoryRequirementsCB( TG_Shape* pFrame, VOID* );
    static BOOL WriteSubsetsCB( TG_Shape* pFrame, VOID* pData );
    static BOOL WriteIndicesCB( TG_Shape* pFrame, VOID* pData );
    static BOOL WriteVerticesCB( TG_Shape* pFrame, VOID* pData );
    static BOOL WriteMeshInfoCB( TG_Shape* pFrame, VOID* pData );
    static BOOL WriteAnimationCB( TG_Shape* pFrame, VOID* pData );


    void        GetZVals(float& numberOfVertices, float& zVal);
    void        GetMinZ(float& curCount, float& z);
    float       GetMinZ();





      // HELPERS
        BOOL EnumFrames( BOOL (*EnumFramesCB)(TG_Shape*,VOID*),
                            VOID* pData );

        // suppressed
         TG_Shape& operator= ( const TG_Shape& src );


		
};

typedef TG_Shape* TG_ShapePtr;


//-------------------------------------------------------------------------------
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\xodash\XODashLib\xbinput.h ===
//-----------------------------------------------------------------------------
// File: XBInput.h
//
// Desc: Input helper functions for the XBox samples
//
// Hist: 12.15.00 - Separated from XBUtil.h for December XDK release
//       01.03.00 - Made changes for real Xbox controller
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef XBINPUT_H
#define XBINPUT_H




//-----------------------------------------------------------------------------
// Name: struct XBGAMEPAD
// Desc: structure for holding Gamepad data
//-----------------------------------------------------------------------------
struct XBGAMEPAD : public XINPUT_GAMEPAD
{
    // The following members are inherited from XINPUT_GAMEPAD:
    //    WORD    wButtons;
    //    BYTE    bAnalogButtons[8];
    //    SHORT   sThumbLX;
    //    SHORT   sThumbLY;
    //    SHORT   sThumbRX;
    //    SHORT   sThumbRY;

    // Thumb stick values converted to range [-1,+1]
    FLOAT      fX1;
    FLOAT      fY1;
    FLOAT      fX2;
    FLOAT      fY2;
    
    // State of buttons tracked since last poll
    WORD       wLastButtons;
    BOOL       bLastAnalogButtons[8];
    WORD       wPressedButtons;
    BOOL       bPressedAnalogButtons[8];

    // Rumble properties
    XINPUT_RUMBLE   Rumble;
    XINPUT_FEEDBACK Feedback;

    // Device properties
    XINPUT_CAPABILITIES caps;
    HANDLE     hDevice;

    // Flags for whether gamepad was just inserted or removed
    BOOL       bInserted;
    BOOL       bRemoved;
};




//-----------------------------------------------------------------------------
// Global access to gamepad devices
//-----------------------------------------------------------------------------
extern XBGAMEPAD g_Gamepads[4];




//-----------------------------------------------------------------------------
// Name: XBInput_CreateGamepads()
// Desc: Creates the gamepad devices
//-----------------------------------------------------------------------------
HRESULT XBInput_CreateGamepads( XBGAMEPAD** ppGamepads = NULL );




//-----------------------------------------------------------------------------
// Name: XBInput_GetInput()
// Desc: Processes input from the gamepads
//-----------------------------------------------------------------------------
VOID XBInput_GetInput( XBGAMEPAD* pGamepads = NULL );




#endif // XBINPUT_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\xodash\XODashLib\XbStopWatch.cpp ===
//-----------------------------------------------------------------------------
// File: XbStopWatch.cpp
//
// Desc: StopWatch object using QueryPerformanceCounter
//
// Hist: 01.19.01 - New for March XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include "std.h"
#include "XbStopWatch.h"




//-----------------------------------------------------------------------------
// Name: CXBStopWatch()
// Desc: Creates the stopwatch. By default, stopwatch starts running immediately
//-----------------------------------------------------------------------------
CXBStopWatch::CXBStopWatch( BOOL bStartWatch )
:
    m_fTimerPeriod      ( 0.0f ),
    m_nStartTick        ( 0 ),
    m_nPrevElapsedTicks ( 0 ),
    m_bIsRunning        ( FALSE )   // set in Start()
{
    // Get the timer frequency (ticks per second)
    LARGE_INTEGER qwTimerFreq;
    QueryPerformanceFrequency( &qwTimerFreq );

    // Store as period to avoid division in GetElapsed()
    m_fTimerPeriod = 1.0f / (FLOAT)( qwTimerFreq.QuadPart );

    if( bStartWatch )
        Start();
}




//-----------------------------------------------------------------------------
// Name: Start()
// Desc: Starts the stopwatch running. Does not clear any previous time held
//       by the watch.
//-----------------------------------------------------------------------------
VOID CXBStopWatch::Start()
{
    m_nStartTick = GetTicks();
    m_bIsRunning = TRUE;
}




//-----------------------------------------------------------------------------
// Name: StartZero()
// Desc: Starts the stopwatch running at time zero. Same as calling Reset() and
//       then Start();
//-----------------------------------------------------------------------------
VOID CXBStopWatch::StartZero()
{
    m_nPrevElapsedTicks = 0;
    m_nStartTick = GetTicks();
    m_bIsRunning = TRUE;
}




//-----------------------------------------------------------------------------
// Name: Stop()
// Desc: Stops the stopwatch. After stopping the watch, GetElapsed() will 
//       return the same value until the watch is started or reset.
//-----------------------------------------------------------------------------
VOID CXBStopWatch::Stop()
{
    if( m_bIsRunning )
    {
        // Store the elapsed time
        m_nPrevElapsedTicks += GetTicks() - m_nStartTick;
        m_nStartTick = 0;

        // Stop running
        m_bIsRunning = FALSE;
    }
}




//-----------------------------------------------------------------------------
// Name: Reset()
// Desc: Resets the stopwatch to zero. If the watch was running, it continues
//       to run.
//-----------------------------------------------------------------------------
VOID CXBStopWatch::Reset()
{
    m_nPrevElapsedTicks = 0;
    if( m_bIsRunning )
        m_nStartTick = GetTicks();
}




//-----------------------------------------------------------------------------
// Name: IsRunning()
// Desc: TRUE if the stopwatch is running, else FALSE
//-----------------------------------------------------------------------------
BOOL CXBStopWatch::IsRunning() const
{
    return( m_bIsRunning );
}




//-----------------------------------------------------------------------------
// Name: GetElapsedSeconds()
// Desc: The amount of time the watch has been running since it was last
//       reset, in seconds
//-----------------------------------------------------------------------------
FLOAT CXBStopWatch::GetElapsedSeconds() const
{
    // Start with any previous time
    LONGLONG nTotalTicks( m_nPrevElapsedTicks );

    // If the watch is running, add the time since the last start
    if( m_bIsRunning )
        nTotalTicks += GetTicks() - m_nStartTick;

    // Convert to floating pt
    FLOAT fSeconds = (FLOAT)( nTotalTicks ) * m_fTimerPeriod;
    return( fSeconds );
}




//-----------------------------------------------------------------------------
// Name: GetElapsedMilliseconds()
// Desc: The amount of time the watch has been running since it was last
//       reset, in mS
//-----------------------------------------------------------------------------
FLOAT CXBStopWatch::GetElapsedMilliseconds() const
{
    return( GetElapsedSeconds() * 1000.0f );
}




//-----------------------------------------------------------------------------
// Name: GetTicks()
// Desc: Private function wraps QueryPerformanceCounter()
//-----------------------------------------------------------------------------
LONGLONG CXBStopWatch::GetTicks() const
{
    // Grab the current tick count
    LARGE_INTEGER qwCurrTicks;
    QueryPerformanceCounter( &qwCurrTicks );
    return( qwCurrTicks.QuadPart );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\xodash\XODashLib\xbinput.cpp ===
//-----------------------------------------------------------------------------
// File: XBInput.cpp
//
// Desc: Input helper functions for the XBox samples
//
// Hist: 12.15.00 - Separated from XBUtil.cpp for December XDK release
//       01.03.01 - Made changes for real Xbox controller
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include "std.h"

#include <xtl.h>
#include "XBInput.h"




//-----------------------------------------------------------------------------
// Globals
//-----------------------------------------------------------------------------

// Deadzone for thumbsticks
#define XBINPUT_DEADZONE 0.24f

// Global instance of gamepad devices
XBGAMEPAD g_Gamepads[4];




//-----------------------------------------------------------------------------
// Name: XBInput_CreateGamepads()
// Desc: Creates the gamepad devices
//-----------------------------------------------------------------------------
HRESULT XBInput_CreateGamepads( XBGAMEPAD** ppGamepads )
{
    // Get a mask of all currently available devices
    DWORD dwDeviceMask = XGetDevices( XDEVICE_TYPE_GAMEPAD );

    // Open the devices
    for( DWORD i=0; i < XGetPortCount(); i++ )
    {
        ZeroMemory( &g_Gamepads[i], sizeof(XBGAMEPAD) );
        if( dwDeviceMask & (1<<i) ) 
        {
            // Get a handle to the device
            g_Gamepads[i].hDevice = XInputOpen( XDEVICE_TYPE_GAMEPAD, i, 
                                                XDEVICE_NO_SLOT, NULL );

            // Store capabilites of the device
            XInputGetCapabilities( g_Gamepads[i].hDevice, &g_Gamepads[i].caps );
        }
    }

    // Created devices are kept global, but for those who prefer member
    // variables, they can get a pointer to the gamepads returned.
    if( ppGamepads )
        (*ppGamepads) = g_Gamepads;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: XBInput_GetInput()
// Desc: Processes input from the gamepads
//-----------------------------------------------------------------------------
VOID XBInput_GetInput( XBGAMEPAD* pGamepads )
{
    if( NULL == pGamepads )
        pGamepads = g_Gamepads;

    // TCR 3-21 Controller Discovery
    // Get status about gamepad insertions and removals. Note that, in order to
    // not miss devices, we will check for removed device BEFORE checking for
    // insertions
    DWORD dwInsertions, dwRemovals;
    XGetDeviceChanges( XDEVICE_TYPE_GAMEPAD, &dwInsertions, &dwRemovals );

    // Loop through all gamepads
    for( DWORD i=0; i < XGetPortCount(); i++ )
    {
        // Handle removed devices.
        pGamepads[i].bRemoved = ( dwRemovals & (1<<i) ) ? TRUE : FALSE;
        if( pGamepads[i].bRemoved )
        {
            XInputClose( pGamepads[i].hDevice );
            pGamepads[i].hDevice = NULL;
            pGamepads[i].Feedback.Rumble.wLeftMotorSpeed  = 0;
            pGamepads[i].Feedback.Rumble.wRightMotorSpeed = 0;
        }

        // Handle inserted devices
        pGamepads[i].bInserted = ( dwInsertions & (1<<i) ) ? TRUE : FALSE;
        if( pGamepads[i].bInserted ) 
        {
            // TCR 1-14 Device Types
            pGamepads[i].hDevice = XInputOpen( XDEVICE_TYPE_GAMEPAD, i, 
                                               XDEVICE_NO_SLOT, NULL );
            XInputGetCapabilities( pGamepads[i].hDevice, &pGamepads[i].caps );
        }

        // If we have a valid device, poll it's state and track button changes
        if( pGamepads[i].hDevice )
        {
            // Read the input state
            XINPUT_STATE xiState;
            XInputGetState( pGamepads[i].hDevice, &xiState );

            // Copy gamepad to local structure
            memcpy( &pGamepads[i], &xiState.Gamepad, sizeof(XINPUT_STATE) );

            // Put Xbox device input for the gamepad into our custom format
            FLOAT fX1 = (pGamepads[i].sThumbLX+0.5f)/32767.5f;
            pGamepads[i].fX1 = ( fX1 >= 0.0f ? 1.0f : -1.0f ) *
                               max( 0.0f, (fabsf(fX1)-XBINPUT_DEADZONE)/(1.0f-XBINPUT_DEADZONE) );

            FLOAT fY1 = (pGamepads[i].sThumbLY+0.5f)/32767.5f;
            pGamepads[i].fY1 = ( fY1 >= 0.0f ? 1.0f : -1.0f ) *
                               max( 0.0f, (fabsf(fY1)-XBINPUT_DEADZONE)/(1.0f-XBINPUT_DEADZONE) );

            FLOAT fX2 = (pGamepads[i].sThumbRX+0.5f)/32767.5f;
            pGamepads[i].fX2 = ( fX2 >= 0.0f ? 1.0f : -1.0f ) *
                               max( 0.0f, (fabsf(fX2)-XBINPUT_DEADZONE)/(1.0f-XBINPUT_DEADZONE) );

            FLOAT fY2 = (pGamepads[i].sThumbRY+0.5f)/32767.5f;
            pGamepads[i].fY2 = ( fY2 >= 0.0f ? 1.0f : -1.0f ) *
                               max( 0.0f, (fabsf(fY2)-XBINPUT_DEADZONE)/(1.0f-XBINPUT_DEADZONE) );

            // Get the boolean buttons that have been pressed since the last
            // call. Each button is represented by one bit.
            pGamepads[i].wPressedButtons = ( pGamepads[i].wLastButtons ^ pGamepads[i].wButtons ) & pGamepads[i].wButtons;
            pGamepads[i].wLastButtons    = pGamepads[i].wButtons;

            // Get the analog buttons that have been pressed or released since
            // the last call.
            for( DWORD b=0; b<8; b++ )
            {
                // Turn the 8-bit polled value into a boolean value
                BOOL bPressed = ( pGamepads[i].bAnalogButtons[b] > 0 );

                if( bPressed )
                    pGamepads[i].bPressedAnalogButtons[b] = !pGamepads[i].bLastAnalogButtons[b];
                else
                    pGamepads[i].bPressedAnalogButtons[b] = FALSE;
                
                // Store the current state for the next time
                pGamepads[i].bLastAnalogButtons[b] = bPressed;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\xodash\XODashLib\xbutil.cpp ===
//-----------------------------------------------------------------------------
// File: XBUtil.cpp
//
// Desc: Shortcut macros and helper functions for the XBox samples
//
// Hist: 11.01.00 - New for November XDK release
//       12.01.00 - Moved input code to XBInput.cpp
//       12.15.00 - Changes for December XDK release
//       02.19.00 - Changes for March XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include "std.h"

#include <xtl.h>
#include <xgraphics.h>
#include <tchar.h> 
#include <stdio.h> 
#include "XBUtil.h"




//-----------------------------------------------------------------------------
// Path to the XBox media files on the target machine
//-----------------------------------------------------------------------------
CHAR g_strMediaPath[512] = "D:\\Media\\";




//-----------------------------------------------------------------------------
// Name: XBUtil_SetMediaPath()
// Desc: Sets the path to media files
//-----------------------------------------------------------------------------
VOID XBUtil_SetMediaPath( const CHAR* strPath )
{
    strcpy( g_strMediaPath, strPath );
}

    
    
    
//-----------------------------------------------------------------------------
// Name: XBUtil_FindMediaFile()
// Desc: Returns a valid path to a media file.
//-----------------------------------------------------------------------------
HRESULT XBUtil_FindMediaFile( CHAR* strPath, const CHAR* strFilename )
{
    // Check for valid arguments
    if( NULL==strFilename || NULL==strPath )
    {
        OutputDebugStringA( "XBUtil_FindMediaFile(): Invalid arguments\n" );
        return E_INVALIDARG;
    }

    // Default path is the filename itself as a fully qualified path
    strcpy( strPath, strFilename );

    // Check for the ':' character to see if the filename is a fully
    // qualified path. If not, prepend the media directory
    if( strFilename[1] != ':' )
        sprintf( strPath, "%s%s", g_strMediaPath, strFilename );

    // Try to open the file
    HANDLE hFile = CreateFile( strPath, GENERIC_READ, FILE_SHARE_READ, NULL, 
                               OPEN_EXISTING, 0, NULL );
    if( INVALID_HANDLE_VALUE == hFile )
    {
        // Return error
        CHAR strBuffer[80];
        sprintf( strBuffer, "XBUtil_FindMediaFile(): Could not find file [%s]\n", 
                            strFilename );
        OutputDebugStringA( strBuffer );
        return 0x82000004;
    }

    // Found the file. Close the file and return
    CloseHandle( hFile );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: XBUtil_Timer()
// Desc: Performs timer opertations. Use the following commands:
//          TIMER_RESET           - to reset the timer
//          TIMER_START           - to start the timer
//          TIMER_STOP            - to stop (or pause) the timer
//          TIMER_ADVANCE         - to advance the timer by 0.1 seconds
//          TIMER_GETABSOLUTETIME - to get the absolute system time
//          TIMER_GETAPPTIME      - to get the current time
//-----------------------------------------------------------------------------
FLOAT XBUtil_Timer( TIMER_COMMAND command )
{
    static BOOL  m_bTimerInitialized = FALSE;
    static FLOAT m_fSecsPerTick = 0.0f;
    static FLOAT m_fBaseTime    = 0.0f;
    static FLOAT m_fStopTime    = 0.0f;
    FLOAT        fTime;

    // Initialize the timer
    if( FALSE == m_bTimerInitialized )
    {
        m_bTimerInitialized = TRUE;

        // Use QueryPerformanceFrequency() to get frequency of timer.
        LARGE_INTEGER qwTicksPerSec;
        QueryPerformanceFrequency( &qwTicksPerSec );
        m_fSecsPerTick = 1.0f / (FLOAT)qwTicksPerSec.QuadPart;
    }

    // Get the current time using QueryPerformanceCounter() or timeGetTime()
    LARGE_INTEGER qwTime;
    QueryPerformanceCounter( &qwTime );
    fTime = ((FLOAT)qwTime.QuadPart) * m_fSecsPerTick;

    // Reset the timer
    if( command == TIMER_RESET )
    {
        m_fBaseTime = fTime;
        return 0.0f;
    }

    // Return the current time
    if( command == TIMER_GETAPPTIME )
        return fTime - m_fBaseTime;

    // Start the timer
    if( command == TIMER_START )
        m_fBaseTime += fTime - m_fStopTime;

    // Stop the timer
    if( command == TIMER_STOP )
        m_fStopTime = fTime;

    // Advance the timer by 1/10th second
    if( command == TIMER_ADVANCE )
        m_fBaseTime += fTime - ( m_fStopTime + 0.1f );

    // Retract the timer by 1/10th second
    if( command == TIMER_RETRACT )
        m_fBaseTime += fTime - ( m_fStopTime - 0.1f );

    return fTime;
}




//-----------------------------------------------------------------------------
// Name: XBUtil_InitMaterial()
// Desc: Initializes a D3DMATERIAL8 structure, setting the diffuse and ambient
//       colors. It does not set emissive or specular colors.
//-----------------------------------------------------------------------------
VOID XBUtil_InitMaterial( D3DMATERIAL8& mtrl, FLOAT r, FLOAT g, FLOAT b,
                          FLOAT a )
{
    ZeroMemory( &mtrl, sizeof(D3DMATERIAL8) );
    mtrl.Diffuse.r = mtrl.Ambient.r = r;
    mtrl.Diffuse.g = mtrl.Ambient.g = g;
    mtrl.Diffuse.b = mtrl.Ambient.b = b;
    mtrl.Diffuse.a = mtrl.Ambient.a = a;
}




//-----------------------------------------------------------------------------
// Name: XBUtil_InitLight()
// Desc: Initializes a D3DLIGHT structure, setting the light position. The
//       diffuse color is set to white, specular and ambient left as black.
//-----------------------------------------------------------------------------
VOID XBUtil_InitLight( D3DLIGHT8& light, D3DLIGHTTYPE ltType,
                       FLOAT x, FLOAT y, FLOAT z )
{
    ZeroMemory( &light, sizeof(D3DLIGHT8) );
    light.Type         = ltType;
    light.Diffuse.r    = 1.0f;
    light.Diffuse.g    = 1.0f;
    light.Diffuse.b    = 1.0f;
    light.Position     = D3DXVECTOR3(x,y,z);

    light.Position.x   = x;
    light.Position.y   = y;
    light.Position.z   = z;
    D3DXVECTOR3 vSource(x,y,z);
    D3DXVec3Normalize( (D3DXVECTOR3*)&light.Direction, &vSource );
    light.Range        = 1000.0f;
}




//-----------------------------------------------------------------------------
// Name: XBUtil_CreateTexture()
// Desc: Helper function to create a texture.
//-----------------------------------------------------------------------------
HRESULT XBUtil_CreateTexture( LPDIRECT3DDEVICE8 pd3dDevice, const CHAR* strTexture,
                              LPDIRECT3DTEXTURE8* ppTexture, D3DFORMAT d3dFormat )
{
    HRESULT hr;

    // Find the media file
    CHAR strTexturePath[512];
    if( FAILED( hr = XBUtil_FindMediaFile( strTexturePath, strTexture ) ) )
        return hr;

    // Create the texture using D3DX. Check the current directory
    return D3DXCreateTextureFromFileEx( pd3dDevice, strTexturePath, 
                                        D3DX_DEFAULT, D3DX_DEFAULT, D3DX_DEFAULT, 
                                        0, d3dFormat, D3DPOOL_DEFAULT, 
                                        D3DX_DEFAULT, D3DX_DEFAULT, 0, NULL, NULL, 
                                        ppTexture );
}




//-----------------------------------------------------------------------------
// Name: XBUtil_UnswizzleTexture2D()
// Desc: Unswizzles a 2D texture before it gets unlocked. Note: this operation
//       can be very slow.
//-----------------------------------------------------------------------------
VOID XBUtil_UnswizzleTexture2D( D3DLOCKED_RECT* pLock, const D3DSURFACE_DESC* pDesc )
{
    DWORD dwPixelSize   = XGBytesPerPixelFromFormat( pDesc->Format );
    DWORD dwTextureSize = pDesc->Width * pDesc->Height * dwPixelSize;

    BYTE* pSrcBits = new BYTE[ dwTextureSize ];
    memcpy( pSrcBits, pLock->pBits, dwTextureSize );
    
    XGUnswizzleRect( pSrcBits, pDesc->Width, pDesc->Height, NULL, pLock->pBits, 
                     0, NULL, dwPixelSize );

    SAFE_DELETE_ARRAY( pSrcBits );
}




//-----------------------------------------------------------------------------
// Name: XBUtil_UnswizzleTexture3D()
// Desc: Unswizzles a 3D texture before it gets unlocked. Note: this operation
//       can be very slow.
//-----------------------------------------------------------------------------
VOID XBUtil_UnswizzleTexture3D( D3DLOCKED_BOX* pLock, const D3DVOLUME_DESC* pDesc )
{
    DWORD dwPixelSize   = XGBytesPerPixelFromFormat( pDesc->Format );
    DWORD dwTextureSize = pDesc->Width * pDesc->Height * pDesc->Depth * dwPixelSize;

    BYTE* pSrcBits = new BYTE[ dwTextureSize ];
    memcpy( pSrcBits, pLock->pBits, dwTextureSize );
    
    XGUnswizzleBox( pSrcBits, pDesc->Width, pDesc->Height, pDesc->Depth, NULL, pLock->pBits,
                    0, 0, NULL, dwPixelSize );

    SAFE_DELETE_ARRAY( pSrcBits );
}




//-----------------------------------------------------------------------------
// Name: XBUtil_SwizzleTexture2D()
// Desc: Swizzles a 2D texture before it gets unlocked. Note: this operation
//       can be very slow.
//-----------------------------------------------------------------------------
VOID XBUtil_SwizzleTexture2D( D3DLOCKED_RECT* pLock, const D3DSURFACE_DESC* pDesc )
{
    DWORD dwPixelSize   = XGBytesPerPixelFromFormat( pDesc->Format );
    DWORD dwTextureSize = pDesc->Width * pDesc->Height * dwPixelSize;

    BYTE* pSrcBits = new BYTE[ dwTextureSize ];
    memcpy( pSrcBits, pLock->pBits, dwTextureSize );
    
    XGSwizzleRect( pSrcBits, 0, NULL, pLock->pBits,
                  pDesc->Width, pDesc->Height, 
                  NULL, dwPixelSize );

    SAFE_DELETE_ARRAY( pSrcBits );
}




//-----------------------------------------------------------------------------
// Name: XBUtil_SwizzleTexture3D()
// Desc: Swizzles a 3D texture before it gets unlocked. Note: this operation
//       can be very slow.
//-----------------------------------------------------------------------------
VOID XBUtil_SwizzleTexture3D( D3DLOCKED_BOX* pLock, const D3DVOLUME_DESC* pDesc )
{
    DWORD dwPixelSize   = XGBytesPerPixelFromFormat( pDesc->Format );
    DWORD dwTextureSize = pDesc->Width * pDesc->Height * pDesc->Depth * dwPixelSize;

    BYTE* pSrcBits = new BYTE[ dwTextureSize ];
    memcpy( pSrcBits, pLock->pBits, dwTextureSize );
    
    XGSwizzleBox( pSrcBits, 0, 0, NULL, pLock->pBits,
                  pDesc->Width, pDesc->Height, pDesc->Depth, 
                  NULL, dwPixelSize );

    SAFE_DELETE_ARRAY( pSrcBits );
}




//-----------------------------------------------------------------------------
// Name: XBUtil_CreateVertexShader()
// Desc: Creates a file-based vertex shader
//-----------------------------------------------------------------------------
HRESULT XBUtil_CreateVertexShader( LPDIRECT3DDEVICE8 pd3dDevice, 
                                   const CHAR* strFilename,
                                   const DWORD* pdwVertexDecl,
                                   DWORD* pdwVertexShader )
{
    HRESULT hr;

    // Find the media file
    CHAR strShaderPath[512];
    if( FAILED( hr = XBUtil_FindMediaFile( strShaderPath, strFilename ) ) )
        return hr;

    // Open the vertex shader file
    HANDLE hFile = CreateFile( strShaderPath, GENERIC_READ, FILE_SHARE_READ, 
                               NULL, OPEN_EXISTING, 0, NULL );
    if( INVALID_HANDLE_VALUE == hFile )
        return E_FAIL;

    // Allocate memory to read the vertex shader file
    DWORD dwSize = GetFileSize( hFile, NULL );
    BYTE* pData  = new BYTE[dwSize+4];
    if( NULL == pData )
        return E_FAIL;
    ZeroMemory( pData, dwSize+4 );

    // Read the pre-compiled vertex shader microcode
    DWORD dwBytesRead;
    ReadFile( hFile, pData, dwSize, &dwBytesRead, NULL );

    // Create the vertex shader
    hr = pd3dDevice->CreateVertexShader( pdwVertexDecl, (const DWORD*)pData,
                                         pdwVertexShader, 0 );

    // Cleanup and return
    CloseHandle( hFile );
    delete [] pData;
    return hr;
}




//-----------------------------------------------------------------------------
// Name: XBUtil_CreatePixelShader()
// Desc: Creates a file-based pixel shader
//-----------------------------------------------------------------------------
HRESULT XBUtil_CreatePixelShader( LPDIRECT3DDEVICE8 pd3dDevice, 
                                  const CHAR* strFilename, DWORD* pdwPixelShader )
{
    HRESULT hr;

    // Find the media file
    CHAR strShaderPath[512];
    if( FAILED( hr = XBUtil_FindMediaFile( strShaderPath, strFilename ) ) )
        return hr;

    // Open the pixel shader file
    HANDLE hFile = CreateFile( strShaderPath, GENERIC_READ, FILE_SHARE_READ, 
                               NULL, OPEN_EXISTING, 0, NULL );
    if( INVALID_HANDLE_VALUE == hFile )
        return E_FAIL;

    // Load the pre-compiled pixel shader microcode
    D3DPIXELSHADERDEF_FILE psdf;
    DWORD                  dwBytesRead;
    ReadFile( hFile, &psdf, sizeof(D3DPIXELSHADERDEF_FILE), &dwBytesRead, NULL );
    CloseHandle( hFile );

    // Make sure the pixel shader is valid
    if( dwBytesRead != sizeof(D3DPIXELSHADERDEF_FILE) || 
        psdf.FileID != D3DPIXELSHADERDEF_FILE_ID )
    {
        OutputDebugString( _T("XBUtil_CreatePixelShader(): Invalid pixel shader file\n") );
        return E_FAIL;
    }

    // Create the pixel shader
    if( FAILED( hr = pd3dDevice->CreatePixelShader( &(psdf.Psd), pdwPixelShader ) ) )
    {
        OutputDebugString( _T("XBUtil_CreatePixelShader(): Could not create pixel shader\n") );
        return hr;
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: XBUtil_GetCubeMapViewMatrix()
// Desc: Returns a view matrix for rendering to a face of a cubemap.
//-----------------------------------------------------------------------------
D3DXMATRIX XBUtil_GetCubeMapViewMatrix( DWORD dwFace )
{
    D3DXVECTOR3 vEyePt   = D3DXVECTOR3( 0.0f, 0.0f, 0.0f );
    D3DXVECTOR3 vLookDir = D3DXVECTOR3( 1.0f, 0.0f, 0.0f );
    D3DXVECTOR3 vUpDir   = D3DXVECTOR3( 0.0f, 1.0f, 0.0f );

    switch( dwFace )
    {
        case D3DCUBEMAP_FACE_POSITIVE_X:
            vLookDir = D3DXVECTOR3( 1.0f, 0.0f, 0.0f );
            vUpDir   = D3DXVECTOR3( 0.0f, 1.0f, 0.0f );
            break;
        case D3DCUBEMAP_FACE_NEGATIVE_X:
            vLookDir = D3DXVECTOR3(-1.0f, 0.0f, 0.0f );
            vUpDir   = D3DXVECTOR3( 0.0f, 1.0f, 0.0f );
            break;
        case D3DCUBEMAP_FACE_POSITIVE_Y:
            vLookDir = D3DXVECTOR3( 0.0f, 1.0f, 0.0f );
            vUpDir   = D3DXVECTOR3( 0.0f, 0.0f,-1.0f );
            break;
        case D3DCUBEMAP_FACE_NEGATIVE_Y:
            vLookDir = D3DXVECTOR3( 0.0f,-1.0f, 0.0f );
            vUpDir   = D3DXVECTOR3( 0.0f, 0.0f, 1.0f );
            break;
        case D3DCUBEMAP_FACE_POSITIVE_Z:
            vLookDir = D3DXVECTOR3( 0.0f, 0.0f, 1.0f );
            vUpDir   = D3DXVECTOR3( 0.0f, 1.0f, 0.0f );
            break;
        case D3DCUBEMAP_FACE_NEGATIVE_Z:
            vLookDir = D3DXVECTOR3( 0.0f, 0.0f,-1.0f );
            vUpDir   = D3DXVECTOR3( 0.0f, 1.0f, 0.0f );
            break;
    }

    // Set the view transform for this cubemap surface
    D3DXMATRIX matView;
    D3DXMatrixLookAtLH( &matView, &vEyePt, &vLookDir, &vUpDir );
    return matView;
}




//-----------------------------------------------------------------------------
// Name: XBUtil_CreateNormalizationCubeMap()
// Desc: Creates a cubemap and fills it with normalized RGBA vectors
//-----------------------------------------------------------------------------
HRESULT XBUtil_CreateNormalizationCubeMap( LPDIRECT3DDEVICE8 pd3dDevice, 
                                           DWORD dwSize, 
                                           LPDIRECT3DCUBETEXTURE8* ppCubeMap )
{
    HRESULT hr;

    // Create the cube map
    if( FAILED( hr = pd3dDevice->CreateCubeTexture( dwSize, 1, 0, D3DFMT_X8R8G8B8, 
                                                    D3DPOOL_DEFAULT, ppCubeMap ) ) )
        return E_FAIL;
    
    // Allocate temp space for swizzling the cubemap surfaces
    DWORD* pSourceBits = new DWORD[ dwSize * dwSize ];

    // Fill all six sides of the cubemap
    for( DWORD i=0; i<6; i++ )
    {
        // Lock the i'th cubemap surface
        LPDIRECT3DSURFACE8 pCubeMapFace;
        (*ppCubeMap)->GetCubeMapSurface( (D3DCUBEMAP_FACES)i, 0, &pCubeMapFace );

        // Write the RGBA-encoded normals to the surface pixels
        DWORD*      pPixel = pSourceBits;
        D3DXVECTOR3 n;
        FLOAT       w, h;

        for( DWORD y = 0; y < dwSize; y++ )
        {
            h  = (FLOAT)y / (FLOAT)(dwSize-1);  // 0 to 1
            h  = ( h * 2.0f ) - 1.0f;           // -1 to 1
            
            for( DWORD x = 0; x < dwSize; x++ )
            {
                w = (FLOAT)x / (FLOAT)(dwSize-1);   // 0 to 1
                w = ( w * 2.0f ) - 1.0f;            // -1 to 1

                // Calc the normal for this texel
                switch( i )
                {
                    case D3DCUBEMAP_FACE_POSITIVE_X:    // +x
                        n.x = +1.0;
                        n.y = -h;
                        n.z = -w;
                        break;
                        
                    case D3DCUBEMAP_FACE_NEGATIVE_X:    // -x
                        n.x = -1.0;
                        n.y = -h;
                        n.z = +w;
                        break;
                        
                    case D3DCUBEMAP_FACE_POSITIVE_Y:    // y
                        n.x = +w;
                        n.y = +1.0;
                        n.z = +h;
                        break;
                        
                    case D3DCUBEMAP_FACE_NEGATIVE_Y:    // -y
                        n.x = +w;
                        n.y = -1.0;
                        n.z = -h;
                        break;
                        
                    case D3DCUBEMAP_FACE_POSITIVE_Z:    // +z
                        n.x = +w;
                        n.y = -h;
                        n.z = +1.0;
                        break;
                        
                    case D3DCUBEMAP_FACE_NEGATIVE_Z:    // -z
                        n.x = -w;
                        n.y = -h;
                        n.z = -1.0;
                        break;
                }

                // Store the normal as an RGBA color
                D3DXVec3Normalize( &n, &n );
                *pPixel++ = XBUtil_VectorToRGBA( &n );
            }
        }
        
        // Swizzle the result into the cubemap face surface
        D3DLOCKED_RECT lock;
        pCubeMapFace->LockRect( &lock, 0, 0L );
        XGSwizzleRect( pSourceBits, 0, NULL, lock.pBits, dwSize, dwSize,
                       NULL, sizeof(DWORD) );
        pCubeMapFace->UnlockRect();

        // Release the cubemap face
        pCubeMapFace->Release();
    }

    // Free temp space
    SAFE_DELETE_ARRAY( pSourceBits );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: XBUtil_DumpSurface()
// Desc: Writes the contents of a surface (32-bit only) to a .tga file. This
//       could be a backbuffer, texture, or any other 32-bit surface.
//-----------------------------------------------------------------------------
HRESULT XBUtil_DumpSurface( LPDIRECT3DSURFACE8 pSurface, const CHAR* strFileName )
{
    // Get the surface description. Make sure it's a 32-bit format
    D3DSURFACE_DESC desc;
    pSurface->GetDesc( &desc );
    if( desc.Size != ( desc.Width * desc.Height * sizeof(DWORD) ) )
        return E_NOTIMPL;

    // Lock the surface
    D3DLOCKED_RECT lock;
    if( FAILED( pSurface->LockRect( &lock, 0, 0 ) ) )
        return E_FAIL;

    // Allocate memory for storing the surface bits
    VOID* pBits = (VOID*)new DWORD[desc.Width*desc.Height];

    // Unswizzle the bits, if necessary
    if( XGIsSwizzledFormat( desc.Format ) )
        XGUnswizzleRect( lock.pBits, desc.Width, desc.Height, NULL,
                         pBits, lock.Pitch, NULL, sizeof(DWORD) );
    else
        memcpy( pBits, lock.pBits, desc.Size );
    
    // Unlock the surface
    pSurface->UnlockRect();

    // Setup the TGA file header
    struct TargaHeader
    {
        BYTE IDLength;
        BYTE ColormapType;
        BYTE ImageType;
        BYTE ColormapSpecification[5];
        WORD XOrigin;
        WORD YOrigin;
        WORD ImageWidth;
        WORD ImageHeight;
        BYTE PixelDepth;
        BYTE ImageDescriptor;
    } tgaHeader;

    ZeroMemory( &tgaHeader, sizeof(tgaHeader) );
    tgaHeader.IDLength        = 0;
    tgaHeader.ImageType       = 2;
    tgaHeader.ImageWidth      = (WORD)desc.Width;
    tgaHeader.ImageHeight     = (WORD)desc.Height;
    tgaHeader.PixelDepth      = 32;
    tgaHeader.ImageDescriptor = 0x28;

    // Create a new file
    FILE* file = fopen( strFileName, "wb" );
    if( NULL == file )
    {
        pSurface->UnlockRect();
        return E_FAIL;
    }

    // Write the Targa header and the surface pixels to the file
    fwrite( &tgaHeader, sizeof(TargaHeader), 1, file );
    fwrite( pBits, sizeof(BYTE), desc.Size, file );
    fclose( file );

    // Cleanup and return
    delete[] pBits;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: XBUtil_EvaluateHermite()
// Desc: Evaluate a cubic parametric equation. Returns the point at u on a
//       Hermite curve.
//-----------------------------------------------------------------------------
D3DXVECTOR3 XBUtil_EvaluateHermite( const D3DXVECTOR3& p0, const D3DXVECTOR3& p1, 
                                    const D3DXVECTOR3& v0, const D3DXVECTOR3& v1,
                                    FLOAT u )
{
    // Generate coeffecients from the two end points and two tangents
    D3DXVECTOR3 a =  2*p0 - 2*p1 +   v0 + v1; // a = 2p0 - 2p1 +  v0 + v1
    D3DXVECTOR3 b = -3*p0 + 3*p1 - 2*v0 - v1; // b =-3p0 + 3p1 - 2v0 + v1
    D3DXVECTOR3 c =                  v0;      // c = v0  
    D3DXVECTOR3 d =    p0;                    // d = p0

    // Evaluate the equation at u, where:
    //    f(u) = au^3 + bu^2 + cu + d
    return ( ( a * u + b ) * u + c ) * u + d;
}




//-----------------------------------------------------------------------------
// Name: XBUtil_EvaluateCatmullRom()
// Desc: Evaluate a cubic parametric equation. Returns the point at u on a
//       Catmull-Rom curve.
//-----------------------------------------------------------------------------
D3DXVECTOR3 XBUtil_EvaluateCatmullRom( const D3DXVECTOR3& p1, const D3DXVECTOR3& p2, 
                                       const D3DXVECTOR3& p3, const D3DXVECTOR3& p4,
                                       FLOAT u )
{
    // Generate coeffecients from four spline points
    D3DXVECTOR3 a =   -p1 + 3*p2 - 3*p3 + p4;
    D3DXVECTOR3 b =  2*p1 - 5*p2 + 4*p3 - p4;
    D3DXVECTOR3 c =   -p1        +   p3;
    D3DXVECTOR3 d =         2*p2;

    // Evaluate the equation at u, where:
    //    f(u) = 0.5 * ( au^3 + bu^2 + cu + d )
    return 0.5f * ( ( ( a * u + b ) * u + c ) * u + d );
}




//-----------------------------------------------------------------------------
// Name: XBUtil_GetSplinePoint()
// Desc: Returns a point on a spline. The spline is defined by an array of
//       points, and the point and tangent returned are located at position t
//       on the spline, where 0 < t < dwNumSpinePts.
//-----------------------------------------------------------------------------
VOID XBUtil_GetSplinePoint( const D3DXVECTOR3* pSpline, DWORD dwNumSpinePts,
                            FLOAT t, D3DXVECTOR3* pvPoint, D3DXVECTOR3* pvTangent )
{
    DWORD p0 = ( t > 1.0 ) ? (DWORD)floorf(t)-1 : dwNumSpinePts-1;
    DWORD p1 = ( p0 < dwNumSpinePts-1 ) ? p0 + 1 : 0;
    DWORD p2 = ( p1 < dwNumSpinePts-1 ) ? p1 + 1 : 0;
    DWORD p3 = ( p2 < dwNumSpinePts-1 ) ? p2 + 1 : 0;
    FLOAT u  = t - floorf(t);

    if( pvPoint )
        (*pvPoint) = XBUtil_EvaluateCatmullRom( pSpline[p0], pSpline[p1], 
                                                pSpline[p2], pSpline[p3], u );

    if( pvTangent )
        (*pvTangent) = 0.5f * ( (1-u) * ( pSpline[p2] - pSpline[p0] ) + 
                                  (u) * ( pSpline[p3] - pSpline[p1] ) );
}




//-----------------------------------------------------------------------------
// Name: XBUtil_RenderSpline()
// Desc: For debugging purposes, visually renders a spline.
//-----------------------------------------------------------------------------
VOID XBUtil_RenderSpline( LPDIRECT3DDEVICE8 pd3dDevice, const D3DXVECTOR3* pSpline, 
                          DWORD dwNumSplinePts, DWORD dwColor, BOOL bRenderAxes )
{
    pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, FALSE );
    pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_SELECTARG1 );
    pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TFACTOR );
    pd3dDevice->SetVertexShader( D3DFVF_XYZ );

    for( FLOAT u = 0; u < dwNumSplinePts; u += 1.0f )
    {
        D3DXVECTOR3 p[2];
        D3DXVECTOR3 vTangent, vSide, vUp;

        XBUtil_GetSplinePoint( pSpline, dwNumSplinePts, u+0, &p[0], &vTangent );
        XBUtil_GetSplinePoint( pSpline, dwNumSplinePts, u+1, &p[1], NULL );

        D3DXVec3Normalize( &vTangent, &vTangent );
        D3DXVECTOR3 v1( 0, 1, 0 );
        D3DXVec3Cross( &vSide, &v1, &vTangent );
        D3DXVec3Cross( &vUp, &vTangent, &vSide );

        pd3dDevice->SetRenderState( D3DRS_TEXTUREFACTOR, dwColor );
        pd3dDevice->DrawPrimitiveUP( D3DPT_LINELIST, 1, p, sizeof(D3DXVECTOR3) );

        if( bRenderAxes )
        {
            p[1] = p[0] + vTangent/4;
            pd3dDevice->SetRenderState( D3DRS_TEXTUREFACTOR, 0xffff0000 );
            pd3dDevice->DrawPrimitiveUP( D3DPT_LINELIST, 1, p, sizeof(D3DXVECTOR3) );

            p[1] = p[0] + vSide/4;
            pd3dDevice->SetRenderState( D3DRS_TEXTUREFACTOR, 0xff00ff00 );
            pd3dDevice->DrawPrimitiveUP( D3DPT_LINELIST, 1, p, sizeof(D3DXVECTOR3) );

            p[1] = p[0] + vUp/4;
            pd3dDevice->SetRenderState( D3DRS_TEXTUREFACTOR, 0xffffffff );
            pd3dDevice->DrawPrimitiveUP( D3DPT_LINELIST, 1, p, sizeof(D3DXVECTOR3) );
        }
    }
}




//-----------------------------------------------------------------------------
// Name: XBUtil_DeclaratorFromFVF()
// Desc: Create a vertex declaration from an FVF. Registers are assigned as
//       follows:
//          v0     = Vertex position
//          v1     = Vertex blend weights
//          v2     = Vertex normal
//          v3     = Vertex diffuse color
//          v4     = Vertex specular color
//       // v5     = Vertex fog (no FVF code)
//       // v6     = Vertex pointsize (no FVF code)
//       // v7     = Vertex back diffuse color (no FVF code)
//       // v8     = Vertex back specular color (no FVF code)
//          v9-v12 = Vertex texture coords
//-----------------------------------------------------------------------------
HRESULT XBUtil_DeclaratorFromFVF( DWORD dwFVF, 
                                  DWORD Declaration[MAX_FVF_DECL_SIZE] )
{
    // Start the declaration
    DWORD decl = 0;
    Declaration[decl++] = D3DVSD_STREAM(0);

    // Handle position
    DWORD dwPositionFVF = ( dwFVF & D3DFVF_POSITION_MASK );
    if( dwPositionFVF == D3DFVF_XYZRHW ) Declaration[decl++] = D3DVSD_REG( 0, D3DVSDT_FLOAT4 ); 
    else                                 Declaration[decl++] = D3DVSD_REG( 0, D3DVSDT_FLOAT3 ); 

    // Handle blend weights
    if( dwPositionFVF == D3DFVF_XYZB1 )  Declaration[decl++] = D3DVSD_REG( 1, D3DVSDT_FLOAT1 ); 
    if( dwPositionFVF == D3DFVF_XYZB2 )  Declaration[decl++] = D3DVSD_REG( 1, D3DVSDT_FLOAT2 ); 
    if( dwPositionFVF == D3DFVF_XYZB3 )  Declaration[decl++] = D3DVSD_REG( 1, D3DVSDT_FLOAT3 ); 
    if( dwPositionFVF == D3DFVF_XYZB4 )  Declaration[decl++] = D3DVSD_REG( 1, D3DVSDT_FLOAT4 ); 

    // Handle normal, diffuse, and specular
    if( dwFVF & D3DFVF_NORMAL )          Declaration[decl++] = D3DVSD_REG( 2, D3DVSDT_FLOAT3 );
    if( dwFVF & D3DFVF_DIFFUSE )         Declaration[decl++] = D3DVSD_REG( 3, D3DVSDT_D3DCOLOR );
    if( dwFVF & D3DFVF_SPECULAR )        Declaration[decl++] = D3DVSD_REG( 4, D3DVSDT_D3DCOLOR );

    // Handle texture coordinates
    DWORD dwNumTextures = (dwFVF & D3DFVF_TEXCOUNT_MASK) >> D3DFVF_TEXCOUNT_SHIFT;

    for( DWORD i=0; i<dwNumTextures; i++ )
    {
        DWORD dwNumTexCoords = 0;
        if( ( dwFVF & D3DFVF_TEXCOORDSIZE1(i) ) == (DWORD)D3DFVF_TEXCOORDSIZE1(i) )
            dwNumTexCoords = D3DVSDT_FLOAT1;
        if( ( dwFVF & D3DFVF_TEXCOORDSIZE2(i) ) == (DWORD)D3DFVF_TEXCOORDSIZE2(i) )
            dwNumTexCoords = D3DVSDT_FLOAT2;
        if( ( dwFVF & D3DFVF_TEXCOORDSIZE3(i) ) == (DWORD)D3DFVF_TEXCOORDSIZE3(i) )
            dwNumTexCoords = D3DVSDT_FLOAT3;
        if( ( dwFVF & D3DFVF_TEXCOORDSIZE4(i) ) == (DWORD)D3DFVF_TEXCOORDSIZE4(i) )
            dwNumTexCoords = D3DVSDT_FLOAT4;

        Declaration[decl++] = D3DVSD_REG( 9 + i, dwNumTexCoords );
    }

    // End the declarator
    Declaration[decl++] = D3DVSD_END();

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\xodash\XODashLib\xcddefs.h ===
#pragma once


// CD audio type conversions

#define CDAUDIO_BYTES_PER_FRAME         2352
#define CDAUDIO_BYTES_PER_SECOND        176400
#define CDAUDIO_BYTES_PER_MINUTE        10584000

#define CDAUDIO_FRAMES_PER_SECOND       75
#define CDAUDIO_FRAMES_PER_MINUTE       4500

// MCI time format conversion macros

#define MCI_MSF_MINUTE(msf)             ((BYTE)(msf))
#define MCI_MSF_SECOND(msf)             ((BYTE)(((WORD)(msf)) >> 8))
#define MCI_MSF_FRAME(msf)              ((BYTE)((msf)>>16))

#define MCI_MAKE_MSF(m, s, f)           ((DWORD)(((BYTE)(m) | \
                                        ((WORD)(s)<<8)) | \
                                        (((DWORD)(BYTE)(f))<<16)))

__inline DWORD MsfToFrames(DWORD dwMsf)
{
    return MCI_MSF_MINUTE(dwMsf) * CDAUDIO_FRAMES_PER_MINUTE +
           MCI_MSF_SECOND(dwMsf) * CDAUDIO_FRAMES_PER_SECOND +
           MCI_MSF_FRAME(dwMsf);
}

__inline DWORD FramesToMsf(DWORD dwFrames)
{
    return MCI_MAKE_MSF(
        dwFrames / CDAUDIO_FRAMES_PER_MINUTE,
        (dwFrames % CDAUDIO_FRAMES_PER_MINUTE) / CDAUDIO_FRAMES_PER_SECOND,
        (dwFrames % CDAUDIO_FRAMES_PER_MINUTE) % CDAUDIO_FRAMES_PER_SECOND);
}

__inline DWORD TocValToMsf(LPBYTE ab)
{
    return MCI_MAKE_MSF(ab[1], ab[2], ab[3]);
}

__inline DWORD TocValToFrames(LPBYTE ab)
{
    return MsfToFrames(TocValToMsf(ab));
}

struct XCDROM_TOC
{
public:
	XCDROM_TOC();
	~XCDROM_TOC();

	void Delete();
	int GetTrackFromFrame(DWORD dwPosition) const;

    int LastTrack;
    DWORD TrackAddr [100];

#ifdef _CD_INFO
	void UpdateDiscID();

	TCHAR* rgszTrack [100];
	TCHAR* szTitle;
	TCHAR* szArtist;
	TCHAR* szID;
#endif

protected:
	void Clear();
};

typedef XCDROM_TOC* PXCDROM_TOC;

// FRAMES_PER_CHUNK should be kept small, to maximize granularity. We stop music on
// a chunk boundary.

// Some CD hardware (Thompson, .94 firmware revision) is happiest with 1 second reads.

#define FRAMES_PER_CHUNK (CDAUDIO_FRAMES_PER_SECOND)

#define CD_AUDIO_SEGMENTS_PER_BUFFER ((4*CDAUDIO_FRAMES_PER_SECOND)/FRAMES_PER_CHUNK)

#define BYTES_PER_CHUNK (FRAMES_PER_CHUNK * CDAUDIO_BYTES_PER_FRAME)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\xodash\XODashLib\xbutil.h ===
//-----------------------------------------------------------------------------
// File: XBUtil.h
//
// Desc: Shortcut macros and helper functions for the XBox samples
//
// Hist: 11.01.00 - New for November XDK release
//       12.01.00 - Moved input code to XBInput.cpp
//       12.15.00 - Changes for December XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef XBUTIL_H
#define XBUTIL_H

#include <tchar.h>




//-----------------------------------------------------------------------------
// Miscellaneous helper functions
//-----------------------------------------------------------------------------

// For deleting and releasing objects
#define SAFE_DELETE(p)       { delete (p);     (p)=NULL; }
#define SAFE_DELETE_ARRAY(p) { delete[] (p);   (p)=NULL; }
#define SAFE_RELEASE(p)      { if(p) { (p)->Release(); (p)=NULL; } }

// For converting a FLOAT to a DWORD (useful for SetRenderState() calls)
inline DWORD FtoDW( FLOAT f ) { return *((DWORD*)&f); }




//-----------------------------------------------------------------------------
// Name: XBUtil_SetMediaPath() and XBUtil_FindMediaFile()
// Desc: Functions for setting a media path and returning a valid path to a
//       media file.
//-----------------------------------------------------------------------------
VOID    XBUtil_SetMediaPath( const CHAR* strPath );
HRESULT XBUtil_FindMediaFile( CHAR* strPath, const CHAR* strFilename );




//-----------------------------------------------------------------------------
// Name: XBUtil_Timer()
// Desc: Performs timer operations. Use the following commands:
//          TIMER_RESET           - to reset the timer
//          TIMER_START           - to start the timer
//          TIMER_STOP            - to stop (or pause) the timer
//          TIMER_ADVANCE         - to advance the timer by 0.1 seconds
//          TIMER_RETRACT         - to retract the timer by 0.1 seconds
//          TIMER_GETABSOLUTETIME - to get the absolute system time
//          TIMER_GETAPPTIME      - to get the current time
//-----------------------------------------------------------------------------
enum TIMER_COMMAND { TIMER_RESET, TIMER_START, TIMER_STOP, 
                     TIMER_ADVANCE, TIMER_RETRACT, 
                     TIMER_GETABSOLUTETIME, TIMER_GETAPPTIME };
FLOAT XBUtil_Timer( TIMER_COMMAND command );




//-----------------------------------------------------------------------------
// Name: XBUtil_InitMaterial()
// Desc: Initializes a D3DMATERIAL8 structure, setting the diffuse and ambient
//       colors. It does not set emissive or specular colors.
//-----------------------------------------------------------------------------
VOID XBUtil_InitMaterial( D3DMATERIAL8& mtrl, FLOAT r=0.0f, FLOAT g=0.0f,
                                              FLOAT b=0.0f, FLOAT a=1.0f );




//-----------------------------------------------------------------------------
// Name: XBUtil_InitLight()
// Desc: Initializes a D3DLIGHT structure, setting the light position. The
//       diffuse color is set to white, specular and ambient left as black.
//-----------------------------------------------------------------------------
VOID XBUtil_InitLight( D3DLIGHT8& light, D3DLIGHTTYPE ltType,
                       FLOAT x=0.0f, FLOAT y=0.0f, FLOAT z=0.0f );




//-----------------------------------------------------------------------------
// Name: XBUtil_CreateTexture()
// Desc: Helper function to create a texture.
//-----------------------------------------------------------------------------
HRESULT XBUtil_CreateTexture( LPDIRECT3DDEVICE8 pd3dDevice, const CHAR* strTexture,
                              LPDIRECT3DTEXTURE8* ppTexture,
                              D3DFORMAT d3dFormat = D3DFMT_UNKNOWN );




//-----------------------------------------------------------------------------
// Name: XBUtil_UnswizzleTexture() / XBUtil_SwizzleTexture()
// Desc: Unswizzles / swizzles a texture before it gets unlocked. Note: this
//       operation is typically very slow.
//-----------------------------------------------------------------------------
VOID XBUtil_UnswizzleTexture2D( D3DLOCKED_RECT* pLock, const D3DSURFACE_DESC* pDesc );
VOID XBUtil_UnswizzleTexture3D( D3DLOCKED_BOX* pLock, const D3DVOLUME_DESC* pDesc );
VOID XBUtil_SwizzleTexture2D( D3DLOCKED_RECT* pLock, const D3DSURFACE_DESC* pDesc );
VOID XBUtil_SwizzleTexture3D( D3DLOCKED_BOX* pLock, const D3DVOLUME_DESC* pDesc );




//-----------------------------------------------------------------------------
// Name: XBUtil_CreateVertexShader()
// Desc: Creates a file-based vertex shader
//-----------------------------------------------------------------------------
HRESULT XBUtil_CreateVertexShader( LPDIRECT3DDEVICE8 pd3dDevice, 
                                   const CHAR* strFilename, 
                                   const DWORD* pdwVertexDecl,
                                   DWORD* pdwVertexShader );




//-----------------------------------------------------------------------------
// Name: XBUtil_CreatePixelShader()
// Desc: Creates a file-based pixel shader
//-----------------------------------------------------------------------------
HRESULT XBUtil_CreatePixelShader( LPDIRECT3DDEVICE8 pd3dDevice, 
                                  const CHAR* strFilename, DWORD* pdwPixelShader );

                                    
                                    
                                    
//-----------------------------------------------------------------------------
// Name: XBUtil_VectorToRGBA()
// Desc: Converts a normal into an RGBA vector.
//-----------------------------------------------------------------------------
inline D3DCOLOR XBUtil_VectorToRGBA( const D3DXVECTOR3* v, FLOAT fHeight = 1.0f )
{
    D3DCOLOR r = (D3DCOLOR)( ( v->x + 1.0f ) * 127.5f );
    D3DCOLOR g = (D3DCOLOR)( ( v->y + 1.0f ) * 127.5f );
    D3DCOLOR b = (D3DCOLOR)( ( v->z + 1.0f ) * 127.5f );
    D3DCOLOR a = (D3DCOLOR)( 255.0f * fHeight );
    return( (a<<24L) + (r<<16L) + (g<<8L) + (b<<0L) );
}




//-----------------------------------------------------------------------------
// Name: XBUtil_GetCubeMapViewMatrix()
// Desc: Returns a view matrix for rendering to a face of a cubemap.
//-----------------------------------------------------------------------------
D3DXMATRIX XBUtil_GetCubeMapViewMatrix( DWORD dwFace );




//-----------------------------------------------------------------------------
// Name: XBUtil_CreateNormalizationCubeMap()
// Desc: Creates a cubemap and fills it with normalized RGBA vectors.
//-----------------------------------------------------------------------------
HRESULT XBUtil_CreateNormalizationCubeMap( LPDIRECT3DDEVICE8 pd3dDevice, 
                                           DWORD dwSize, 
                                           LPDIRECT3DCUBETEXTURE8* ppCubeMap );




//-----------------------------------------------------------------------------
// Name: XBUtil_DumpSurface()
// Desc: Writes the contents of a surface (32-bit only) to a .tga file. This
//       could be a backbuffer, texture, or any other 32-bit surface.
//-----------------------------------------------------------------------------
HRESULT XBUtil_DumpSurface( LPDIRECT3DSURFACE8 pSurface, const CHAR* strFileName );




//-----------------------------------------------------------------------------
// Name: XBUtil_EvaluateHermite()
// Desc: Evaluate a cubic parametric equation. Returns the point at u on a
//       Hermite curve.
//-----------------------------------------------------------------------------
D3DXVECTOR3 XBUtil_EvaluateHermite( const D3DXVECTOR3& p0, const D3DXVECTOR3& p1, 
                                    const D3DXVECTOR3& v0, const D3DXVECTOR3& v1,
                                    FLOAT u );




//-----------------------------------------------------------------------------
// Name: XBUtil_EvaluateCatmullRom()
// Desc: Evaluate a cubic parametric equation. Returns the point at u on a
//       Catmull-Rom curve.
//-----------------------------------------------------------------------------
D3DXVECTOR3 XBUtil_EvaluateCatmullRom( const D3DXVECTOR3& p1, const D3DXVECTOR3& p2, 
                                       const D3DXVECTOR3& p3, const D3DXVECTOR3& p4,
                                       FLOAT u );




//-----------------------------------------------------------------------------
// Name: XBUtil_GetSplinePoint()
// Desc: Returns a point on a spline. The spline is defined by an array of
//       points, and the point and tangent returned are located at position t
//       on the spline, where 0 < t < dwNumSpinePts.
//-----------------------------------------------------------------------------
VOID XBUtil_GetSplinePoint( const D3DXVECTOR3* pSpline, DWORD dwNumSpinePts, FLOAT t, 
                            D3DXVECTOR3* pvPoint, D3DXVECTOR3* pvTangent );




//-----------------------------------------------------------------------------
// Name: XBUtil_RenderSpline()
// Desc: For debugging purposes, visually renders a spline.
//-----------------------------------------------------------------------------
VOID XBUtil_RenderSpline( LPDIRECT3DDEVICE8 pd3dDevice, const D3DXVECTOR3* pSpline, 
                          DWORD dwNumSplinePts, DWORD dwColor, BOOL bRenderAxes );




//-----------------------------------------------------------------------------
// Name: XBUtil_DeclaratorFromFVF()
// Desc: Create a vertex declaration from an FVF. Registers are assigned as
//       follows:
//          v0    = Vertex position
//          v1    = Vertex blend weights
//          v2    = Vertex normal
//          v3    = Vertex pointsize
//          v4    = Vertex diffuse color
//          v5    = Vertex specular color
//          v6-v9 = Vertex texture coords
//-----------------------------------------------------------------------------
HRESULT XBUtil_DeclaratorFromFVF( DWORD dwFVF, 
								  DWORD Declaration[MAX_FVF_DECL_SIZE] );

#endif // XBUTIL_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\xodash\XODashLib\xcdplay.h ===
#pragma once
#include "cdda.h"
#include "AudioPump.h"

class XCDPlayer : public CAudioPump
{
public:
    XCDPlayer();
    ~XCDPlayer();

    HRESULT Initialize(int nTrack, WAVEFORMATEX* pFormat);
//    void Seek(BOOL fForward);
    void Stop();

	void* GetSampleBuffer();
	DWORD GetSampleBufferSize();

	float GetPlaybackTime();
	float GetPlaybackLength();
	virtual void OnAudioEnd();

private:
   	int GetData(BYTE* pbBuffer, int cbBuffer);
	bool SelectTrack(int nTrack);
    DWORD GetPosition();
    void SetPosition(DWORD dwPosition);

	DWORD m_dwStartPosition;
	DWORD m_dwStopPosition;
	CCDDAStreamer m_streamer;
    LPVOID m_pvBuffer;
	int m_nCurrentTrack;
	int m_nTotalTracks;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\xodash\XODashLib\xcdplay.cpp ===
#include "std.h"
#include "utilities.h"
#include "xcdplay.h"
#include "ntiosvc.h"

extern CNtIoctlCdromService g_cdrom; 

XCDPlayer::XCDPlayer() :
	m_streamer(&g_cdrom)
{
	m_dwStartPosition = 0;
	m_dwStopPosition = 0;
    m_pvBuffer = NULL;
}

XCDPlayer::~XCDPlayer()
{
	if (m_hPlayThread != NULL)
	{
		if (m_hTerminate != NULL)
			SetEvent(m_hTerminate);

		WaitForSingleObject(m_hPlayThread, INFINITE);
	}
}

HRESULT XCDPlayer::Initialize(int nTrack, WAVEFORMATEX* pFormat)
{
	HRESULT hr = S_OK;
	if (!SelectTrack(nTrack) )
	{
		return E_INVALIDARG;
	}
	ZeroMemory(pFormat, sizeof (WAVEFORMATEX));
	pFormat->wFormatTag = WAVE_FORMAT_PCM;
	pFormat->nChannels = 2;
	pFormat->nSamplesPerSec = 44100;
	pFormat->wBitsPerSample = 16;
	pFormat->nBlockAlign = pFormat->wBitsPerSample / 8 * pFormat->nChannels;
	pFormat->nAvgBytesPerSec = pFormat->nSamplesPerSec * pFormat->nBlockAlign;

	hr  = CAudioPump::Initialize(0, pFormat, BYTES_PER_CHUNK, CD_AUDIO_SEGMENTS_PER_BUFFER);
	if(FAILED(hr))
	{
		DbgPrint("XCDPlayer::Initialize - fail to init AudioPump");
		return hr;
	}
    m_pDSBuffer->SetHeadroom(0);

	return hr;
}

// NOTE: This is called from a secondary thread!
int XCDPlayer::GetData(BYTE* pbBuffer, int cbBuffer)
{
    const DWORD dwPosition = GetPosition();
    
    if (dwPosition >= m_dwStopPosition)
		return 0; // all done!

    if (dwPosition + ((cbBuffer + CDAUDIO_BYTES_PER_FRAME - 1) / CDAUDIO_BYTES_PER_FRAME) >= m_dwStopPosition)
        cbBuffer = (m_dwStopPosition - dwPosition) * CDAUDIO_BYTES_PER_FRAME;

	int nRead = m_streamer.Read(pbBuffer, cbBuffer);
    if (nRead <= 0)
        return nRead;

    m_pvBuffer = pbBuffer;

    return nRead;
}


/*
void XCDPlayer::Seek(BOOL fForward)
{
	DWORD dwCurPosition;
	dwCurPosition = GetPosition();
	if (fForward)
	{
		dwCurPosition += CDAUDIO_FRAMES_PER_SECOND;

		DWORD dwLastFrame = g_cdrom.GetTrackFrame(g_cdrom.GetTrackCount());
		if (dwCurPosition >= dwLastFrame)
		{
			dwCurPosition -= dwLastFrame - g_cdrom.GetTrackFrame(0);
		}
	}
	else
	{
		dwCurPosition -= CDAUDIO_FRAMES_PER_SECOND;

		if (dwCurPosition < g_cdrom.GetTrackFrame(0))
		{
			dwCurPosition += g_cdrom.GetTrackFrame(g_cdrom.GetTrackCount()) - g_cdrom.GetTrackFrame(0);
		}
	}

	SetPosition(dwCurPosition);
}
*/

void XCDPlayer::Stop()
{
    CAudioPump::Stop();
    m_streamer.SetFrame(m_dwStartPosition);
}

float XCDPlayer::GetPlaybackLength()
{
	DWORD dwLength = m_dwStopPosition - m_dwStartPosition;
	return (float)dwLength / CDAUDIO_FRAMES_PER_SECOND;
}

float XCDPlayer::GetPlaybackTime()
{
    // Keep the UI from displaying playback time past the end of the song, even if we
    // play a little silence after the song.
    float playbackTime = CAudioPump::GetPlaybackTime();
    float length = GetPlaybackLength();
    if(playbackTime > length){
        playbackTime = length;
    }
    return playbackTime;
}

void* XCDPlayer::GetSampleBuffer()
{
	return m_pvBuffer;
}

DWORD XCDPlayer::GetSampleBufferSize()
{
	return BYTES_PER_CHUNK;
}


void XCDPlayer::SetPosition(DWORD dwPosition)
{
	WaitForSingleObject(m_hMutex, INFINITE);
	m_streamer.SetFrame(dwPosition);
	ReleaseMutex(m_hMutex);
}

DWORD XCDPlayer::GetPosition()
{
	WaitForSingleObject(m_hMutex, INFINITE);
	DWORD dw = m_streamer.GetFrame();
	ReleaseMutex(m_hMutex);
	return dw;
}

bool XCDPlayer::SelectTrack(int nTrack)
{
	m_nCurrentTrack = nTrack;
	
	DbgPrint("XCDPlayer::Initialize()\n");

	if (!g_cdrom.IsOpen())
	{
		DbgPrint("Cannot open CD player; g_cdrom is not open!\n");
		return false;
	}

	// BLOCK: Select track
	{
		m_nTotalTracks = g_cdrom.GetTrackCount();
		ASSERT(m_nTotalTracks > 0);

		if (nTrack < 0 || nTrack >= m_nTotalTracks)
        {
			DbgPrint("XCDPlayer::Initialize invalid track %d\n", nTrack);
			return false;
		}

		m_dwStartPosition = g_cdrom.GetTrackFrame(nTrack);
		m_dwStopPosition = g_cdrom.GetTrackFrame(nTrack + 1);

		m_streamer.SetFrame(m_dwStartPosition);
	}
	return true;
}

void XCDPlayer::OnAudioEnd()
{
	m_nCurrentTrack++;
	if (m_nCurrentTrack >= m_nTotalTracks)
	{
		m_nCurrentTrack = 0;
	}
	else 
	{
		if (SelectTrack(m_nCurrentTrack))
		{
			CAudioPump::Play();
		}

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\xodash\XODashLib\xcrypt.h ===
/*++

Copyright (c) 1989-2000  Microsoft Corporation

Module Name:

    xcrypt.h

Abstract:

    This module contains definitions the XBox encryption and certificate

--*/


#ifndef _XCRYPT_H
#define _XCRYPT_H

#ifdef __cplusplus
extern "C" {
#endif

#include <guiddef.h>

//
// Number of bits for keys in the public key algorithms
//
#define XC_KEY_BITS               (2048)

//
// Size of sigunature corresponding to the keysize.  This is the
// buffer size needed for public key encryption of a digest
//
#define XC_ENC_SIGNATURE_SIZE     ((XC_KEY_BITS + 7) / 8)

//
// Number of bytes in the public key based on the key size
//
#define XC_PUBLIC_KEYDATA_SIZE    (284)

//
// Size of our symmetric key
//
#define XC_SYMMETRIC_KEY_SIZE     16

//
// Number of bytes in a digest (same as A_SHA_DIGEST_LEN)
// NOTE: do not change this value.  XE needs this to be 20
//
#define XC_DIGEST_LEN             20

//
// Size for SHA digest
//
#define XC_SERVICE_DIGEST_SIZE    XC_DIGEST_LEN

//
// Number of bytes in SHA Buffer
//
#define XC_SERVICE_SHA_CONTEXT_SIZE  116
 
//
// Number of bytes in RC4 Buffer
//
#define XC_SERVICE_RC4_KEYSTRUCT_SIZE   258

//
// Constanst needed for DES
//
#define XC_SERVICE_DES_TABLESIZE	128
#define XC_SERVICE_DES_BLOCKLEN	    8
#define XC_SERVICE_DES_KEYSIZE	    8

#define XC_SERVICE_DES3_TABLESIZE	(3 * XC_SERVICE_DES_TABLESIZE)
#define XC_SERVICE_DES3_KEYSIZE	    24

// constants for Block operations
#define XC_SERVICE_ENCRYPT		1
#define XC_SERVICE_DECRYPT		0

// constants for selecting DES or triple DES cipher
#define XC_SERVICE_DES_CIPHER		0
#define XC_SERVICE_DES3_CIPHER		1

//
// Low level crypto API
//

VOID
XCCalcDigest(
    IN  PUCHAR MsgData,
    IN  ULONG  MsgDataLen,
    IN  PUCHAR Digest
    );

VOID
XCSymmetricEncDec(
    IN  PUCHAR MsgData,
    IN  ULONG  MsgDataLen,
    IN  PUCHAR Key,
    IN  ULONG  KeyBytes
    );

ULONG
XCCalcSigSize(
    IN  PUCHAR  pbPrivateKey
    );

ULONG
XCCalcKeyLen(
    IN  PUCHAR  pbPublicKey
    );

BOOLEAN
XCSignDigest(
    IN   PUCHAR    pbDigest,
    IN   PUCHAR    pbPrivateKey,
    OUT  PUCHAR    pbSig
    );

BOOLEAN
XCVerifyDigest(
    IN   PUCHAR   pbSig,
    IN   PUCHAR   pbPublicKey,
    IN   PUCHAR   pbWorkspace,
    IN   PUCHAR   pbCompareDigest
    );

//
// Crypto APIs the ROM exports
//

//
// Equivalent to A_SHAInit. Byte array pointed to by pbSHAContext
// must be at least XC_SERVICE_SHA_CONTEXT_SIZE (116) bytes long.
//
void
XcSHAInit(
    OUT PUCHAR pbSHAContext
    );
   
//
// Equivalent to A_SHAUpdate. Byte array pointed to by pbSHAContext
// must be at least XC_SERVICE_SHA_CONTEXT_SIZE (116) bytes long.
//
void
XcSHAUpdate(
    IN OUT PUCHAR pbSHAContext,
    IN PUCHAR pbInput,
    IN ULONG dwInputLength
    );
   
//
// Equivalent to A_SHAFinal.
// Byte array pbDigest must be able to hold XC_SERVICE_DIGEST_SIZE (20) bytes
//
void
XcSHAFinal(
    IN PUCHAR pbSHAContext,
    OUT PUCHAR pbDigest
    );
   
//
// Equivalent to rc4_key. Byte array pointed to by pbKeyStruct
// must be at least XC_SERVICE_RC4_KEYSTRUCT_SIZE (258) bytes long.
//
void
XcRC4Key(
    OUT PUCHAR pbKeyStruct,
    IN ULONG dwKeyLength,
    IN PUCHAR pbKey
    );
   
//
// Equivalent to rc4. Byte array pointed to by pbKeyStruct
// must be at least XC_SERVICE_RC4_KEYSTRUCT_SIZE (258) bytes long.
//
void
XcRC4Crypt(
    IN PUCHAR pbKeyStruct,
    IN ULONG dwInputLength,
    IN OUT PUCHAR pbInput
    );
   
//
// Computes SHA1-HMAC according to RFC 2104 for 2 pieces of input data.
// Byte array pbDigest must be able to hold XC_SERVICE_DIGEST_SIZE (20) bytes
//
void
XcHMAC(
    IN PUCHAR pbKey,
    IN ULONG dwKeyLength,
    IN PUCHAR pbInput,
    IN ULONG dwInputLength,
    IN PUCHAR pbInput2,
    IN ULONG dwInputLength2,
    OUT PUCHAR pbDigest
    );
   
//
// Equivalent to BSafeEncPublic.
//
ULONG
XcPKEncPublic(
    IN PUCHAR pbPubKey,
    IN PUCHAR pbInput,
    OUT PUCHAR pbOutput
    );
   
//
// Equivalent to BSafeDecPrivate.
//
ULONG
XcPKDecPrivate(
    IN PUCHAR pbPrvKey,
    IN PUCHAR pbInput,
    OUT PUCHAR pbOutput
    );

//
// Get keylen for public key
//
ULONG
XcPKGetKeyLen(
    IN PUCHAR pbPubKey
    );

//
// Verify PKCS1 signature for given XC_SERVICE_DIGEST_SIZE (20) byte digest
//
BOOLEAN
XcVerifyPKCS1Signature(
    IN PUCHAR pbSig,
    IN PUCHAR pbPubKey,
    IN PUCHAR pbDigest
    );
  
//
// Equivalent to BenalohModExp
// computes A = B ^ C mod D, N = len of params in DWORDs
//
ULONG
XcModExp(
    OUT ULONG* pA,
    IN ULONG* pB,
    IN ULONG* pC,
    IN ULONG* pD,
    IN ULONG dwN
    );
   
//
// Equivalent to desparityonkey
//
void
XcDESKeyParity(
    IN OUT PUCHAR pbKey,
    IN ULONG dwKeyLength
    );
   
//
// Equivalent to deskey or tripledes3key.
// dwKeyLength must be either XC_SERVICE_DES_KEYSIZE (8) or XC_SERVICE_DES3_KEYSIZE (24)
// Byte array pbKeyTable must be able to hold XC_SERVICE_DES_TABLESIZE (128)
// or XC_SERVICE_DES3_TABLESIZE (384) bytes
//
void
XcKeyTable(
    IN ULONG dwCipher,
    OUT PUCHAR pbKeyTable,
    IN PUCHAR pbKey
    );

//
// Equivalent to des or tripledes.
// dwCipher must be either XC_SERVICE_DES_CIPHER (0) or XC_SERVICE_DES3_CIPHER (1)
// dwOp must be either XC_SERVICE_DECRYPT (0) or XC_SERVICE_ENCRYPT (1)
//
void
XcBlockCrypt(
    IN ULONG dwCipher,
    OUT PUCHAR pbOutput,
    IN PUCHAR pbInput,
    IN PUCHAR pbKeyTable,
    IN ULONG dwOp
    );
   
//
// Roughly equivalent to CBC. Will loop through multiple blocks.
// dwInputLength can contain any multiple of XC_SERVICE_DES_BLOCKLEN (8)
// dwCipher must be either XC_SERVICE_DES_CIPHER (0) or XC_SERVICE_DES3_CIPHER (1)
// dwOp must be either XC_SERVICE_DECRYPT (0) or XC_SERVICE_ENCRYPT (1)
//
void
XcBlockCryptCBC(
    IN ULONG dwCipher,
    IN ULONG dwInputLength,
    OUT PUCHAR pbOutput,
    IN PUCHAR pbInput,
    IN PUCHAR pbKeyTable,
    IN ULONG dwOp,
    IN PUCHAR pbFeedback
    );

//
// Generic Crypt Service function for future extension
//
ULONG
XcCryptService(
    IN ULONG dwOp,
    IN void* pArgs
    );

//
// typedef's of all the ROM crypto exports
//
typedef void (*pfXcSHAInit)(PUCHAR pbSHAContext);
typedef void (*pfXcSHAUpdate)(PUCHAR pbSHAContext, PUCHAR pbInput, ULONG dwInputLength);
typedef void (*pfXcSHAFinal)(PUCHAR pbSHAContext, PUCHAR pbDigest);
typedef void (*pfXcRC4Key)(PUCHAR pbKeyStruct, ULONG dwKeyLength, PUCHAR pbKey);
typedef void (*pfXcRC4Crypt)(PUCHAR pbKeyStruct, ULONG dwInputLength, PUCHAR pbInput);
typedef void (*pfXcHMAC)(PUCHAR pbKey, ULONG dwKeyLength, PUCHAR pbInput, ULONG dwInputLength, PUCHAR pbInput2, ULONG dwInputLength2, PUCHAR pbDigest);
typedef ULONG (*pfXcPKEncPublic)(PUCHAR pbPubKey, PUCHAR pbInput, PUCHAR pbOutput);
typedef ULONG (*pfXcPKDecPrivate)(PUCHAR pbPrvKey, PUCHAR pbInput, PUCHAR pbOutput);
typedef ULONG (*pfXcPKGetKeyLen)(PUCHAR pbPubKey);
typedef BOOLEAN (*pfXcVerifyPKCS1Signature)(PUCHAR pbSig, PUCHAR pbPubKey, PUCHAR pbDigest);
typedef ULONG (*pfXcModExp)(ULONG* pA, ULONG* pB, ULONG* pC, ULONG* pD, ULONG dwN);
typedef void (*pfXcDESKeyParity)(PUCHAR pbKey, ULONG dwKeyLength);
typedef void (*pfXcKeyTable)(ULONG dwCipher, PUCHAR pbKeyTable, PUCHAR pbKey);
typedef void (*pfXcBlockCrypt)(ULONG dwCipher, PUCHAR pbOutput, PUCHAR pbInput, PUCHAR pbKeyTable, ULONG dwOp);
typedef void (*pfXcBlockCryptCBC)(ULONG dwCipher, ULONG dwInputLength, PUCHAR pbOutput, PUCHAR pbInput, PUCHAR pbKeyTable, ULONG dwOp, PUCHAR pbFeedback);
typedef ULONG (*pfXcCryptService)(ULONG dwOp, void* pArgs);

//
// Vector to store all ROM Crypto routines
//
typedef struct {
    pfXcSHAInit pXcSHAInit;
    pfXcSHAUpdate pXcSHAUpdate;
    pfXcSHAFinal pXcSHAFinal;
    pfXcRC4Key pXcRC4Key;
    pfXcRC4Crypt pXcRC4Crypt;
    pfXcHMAC pXcHMAC;
    pfXcPKEncPublic pXcPKEncPublic;
    pfXcPKDecPrivate pXcPKDecPrivate;
    pfXcPKGetKeyLen pXcPKGetKeyLen;
    pfXcVerifyPKCS1Signature pXcVerifyPKCS1Signature;
    pfXcModExp pXcModExp;
    pfXcDESKeyParity pXcDESKeyParity;
    pfXcKeyTable pXcKeyTable;
    pfXcBlockCrypt pXcBlockCrypt;
    pfXcBlockCryptCBC pXcBlockCryptCBC;
    pfXcCryptService pXcCryptService;
} CRYPTO_VECTOR, *PCRYPTO_VECTOR;

//
// Update the current set of crypto routines with updated ones.
// Also return back the original ROM routines if needed.
//
void
XcUpdateCrypto(
    IN PCRYPTO_VECTOR pNewVector,
    OUT OPTIONAL PCRYPTO_VECTOR pROMVector
    );

#ifdef __cplusplus
}      // extern "C"
#endif

#endif // _XCRYPT_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\xodash\XODashMain\accountdata.cpp ===
/*************************************************************************************************\
AccountInfo.cpp		: Implementation of the AccountInfo component.
Creation Date		: 1/23/2002 6:52:28 PM
Copyright Notice	: (C) 2000 Microsoft
Author				: Heidi Gaertner
//-------------------------------------------------------------------------------------------------
Notes				: 
\*************************************************************************************************/
#include "std.h"
#include "AccountData.h"
#include "dialog.h"

#define     TAG_COUNT 5

// keep as a pointer so this can be deallocated if necessary
Accounts*                Accounts::s_pAccounts = NULL;

#define ALTERNATE_NAME_COUNT 5



#define BIND(id,address)  { ##id, s_pAccounts->##address, countof( s_pAccounts->##address ) },


Accounts::ACT_BINDING_DATA Accounts::s_pBindData[] = 
{
    BIND( eACT_Idname,    m_NewAccountInfo.m_Data.wszNickname )
    BIND( eACT_Billing01, m_NewAccountInfo.m_Data.wszStreet1 )
    BIND( eACT_Billing02, m_NewAccountInfo.m_Data.wszPostalCode ) 
    BIND( eACT_Billing03, m_NewAccountInfo.m_Data.wszCity )
    BIND( eACT_Billing04, m_NewAccountInfo.m_Data.wszState )
    BIND( eACT_Billing05, m_NewAccountInfo.m_Data.wszBranchCode ) // they took away country code,,,,
    BIND( eACT_Idname, m_NewAccountInfo.m_Data.wszNickname )
    BIND( eACT_Idtag, m_NewAccountInfo.m_Data.wszKingdom )
    //BIND( eACT_Credit01, m_NewAccountInfo.m_Data.wszCardType )  // slamb: this is now bCardTypeId
    BIND( eACT_Credit02, m_NewAccountInfo.m_Data.wszCardHolder )
    BIND( eACT_Credit03, m_NewAccountInfo.m_Data.wszCardNumber )
    { eNullButtonId, 0, 0 } // need to terminate array
};


/*struct USER_ACCOUNT_INFO
{
    WCHAR   wszNickname[XONLINE_NAME_SIZE];
    WCHAR   wszKingdom[XONLINE_KINGDOM_SIZE];
    
    WCHAR   wszFirstName[MAX_FIRSTNAME_SIZE];
    WCHAR   wszLastName[MAX_LASTNAME_SIZE];
    WCHAR   wszStreet1[MAX_STREET_SIZE];
    WCHAR   wszStreet2[MAX_STREET_SIZE];
    WCHAR   wszStreet3[MAX_STREET_SIZE];
    WCHAR   wszCity[MAX_CITY_SIZE];
    WCHAR   wszState[MAX_STATE_SIZE];
    WCHAR   wszCountryCode[MAX_COUNTRYCODE_SIZE];
    WCHAR   wszPostalCode[MAX_POSTALCODE_SIZE];
    WCHAR   wszPhonePrefix[MAX_PHONE_PREFIX_SIZE];
    WCHAR   wszPhoneNumber[MAX_PHONE_NUMBER_SIZE];
    WCHAR   wszPhoneExtension[MAX_PHONE_EXTENSION_SIZE];
    
    WCHAR   wszCardHolder[MAX_CC_NAME_SIZE];
    WCHAR   wszCardType[MAX_CC_TYPE_SIZE];
    WCHAR   wszCardNumber[MAX_CC_NUMBER_SIZE];
    WCHAR   wszCardExpiration[MAX_CC_EXPIRATION_SIZE];
    
    WCHAR   wszEmail[MAX_EMAIL_SIZE];
    WCHAR   wszBankCode[MAX_BANK_CODE_SIZE];
    WCHAR   wszBranchCode[MAX_BRANCH_CODE_SIZE];
    WCHAR   wszCheckDigits[MAX_CHECK_DIGITS_SIZE];
}; */     



NewAccountInfo::NewAccountInfo()
{
    memset( &m_Data, 0, sizeof( m_Data ) );
    
    // Initalize Credit Card Expiration to 0 dates/times
    m_Data.ftCardExpiration.dwHighDateTime = 0;
    m_Data.ftCardExpiration.dwLowDateTime  = 0;
    m_ftDOB.dwHighDateTime = 0;
    m_ftDOB.dwLowDateTime  = 0;
}


//*************************************************************************************************
Accounts::Accounts()
{
    m_bHaveTask = 0;
    m_nCurTask = -1;
    m_CountryID = -1;

    // default to USA
    m_CountryID = 103;

    // need to fix up pointers...
    // grisly hack.
    int counter = 0; 
    while( s_pBindData[counter].buttonId != eNullButtonId )
    {
        long nonOffsetAddress = (long)s_pBindData[counter].pAddress;
        nonOffsetAddress += (long)this;
        s_pBindData[counter].pAddress = (TCHAR*)nonOffsetAddress;
        counter++;
    }
}

//*************************************************************************************************
Accounts::~Accounts()
{
}

//*************************************************************************************************
Accounts* Accounts::Instance()
{
    ASSERT( s_pAccounts );
    // don't allocate in here, because then we won't know who does the clean up.

    return s_pAccounts;
}

//*************************************************************************************************
HRESULT Accounts::Initialize()
{
    s_pAccounts = new Accounts();
    if ( !s_pAccounts )
    {
        return XBAPPERR_MEMORYERR;
    }

    return S_OK;
}

//*************************************************************************************************
HRESULT Accounts::CleanUp()
{
  if ( s_pAccounts )
      delete s_pAccounts;

  s_pAccounts = NULL;

  return S_OK;
}

//*************************************************************************************************
HRESULT  Accounts::UpdateAccountInfo()
{
    ASSERT( s_pAccounts );

    if ( s_pAccounts )
    {
        return s_pAccounts->FrameMove();
    }

    return -1; // truly hosed if this happens
}


//*************************************************************************************************
const TCHAR*    Accounts::GetValue(eButtonId eField)
{
    int index = 0;
    while( s_pBindData[index].buttonId != eNullButtonId )
    {
        if ( s_pBindData[index].buttonId == eField )
            return s_pBindData[index].pAddress;
        index++;
    }

    switch (eField)
    {
    case eACT_Credit04:
        {
            TCHAR *szExpiration = new TCHAR[20];
            swprintf( szExpiration, L"" );

            if ( 0 != m_NewAccountInfo.m_Data.ftCardExpiration.dwHighDateTime &&
                 0 != m_NewAccountInfo.m_Data.ftCardExpiration.dwLowDateTime )
            {
                // Credit Card Expiration 
                CDateObject tExpiration;
                tExpiration.setFileTime( m_NewAccountInfo.m_Data.ftCardExpiration );

                ASSERT( tExpiration.getMonth() >= 1 );
                ASSERT( tExpiration.getMonth() <= 12 );
                ASSERT( tExpiration.getYear()  >= 2000 );
                
                TCHAR *szYear = new TCHAR[6];
                _itow( tExpiration.getYear(), szYear, 10 );
           
                //BUGBUG: We should get this string from our locale class
                swprintf(szExpiration, L"%02d/%s", tExpiration.getMonth(), szYear + 2 );
            }
            return szExpiration;
        }
    case eACT_IdDOB:
        {
            TCHAR *szDOB = new TCHAR[20];
            swprintf( szDOB, L"" );

            if ( 0 != m_NewAccountInfo.m_ftDOB.dwHighDateTime &&
                 0 != m_NewAccountInfo.m_ftDOB.dwLowDateTime )
            {
                // Date of birth button
                CDateObject tDOB;
                tDOB.setFileTime( m_NewAccountInfo.m_ftDOB );

                ASSERT( tDOB.getDay()   >= 1 );
                ASSERT( tDOB.getDay()   <= 31 );
                ASSERT( tDOB.getMonth() >= 1 );
                ASSERT( tDOB.getMonth() <= 12 );
                
                TCHAR szYear[6];
                _itow( tDOB.getYear() , szYear, 10 );

                //BUGBUG: We should get this string from our locale class
                swprintf(szDOB, L"%02d/%02d/%s", tDOB.getMonth(), tDOB.getDay(), szYear + 2 );
            }
            return szDOB;
        }
    }

    return NULL;
}

//*************************************************************************************************
unsigned int Accounts::GetNumericValue(eButtonId eField)
{
    switch (eField)
    {
    case eGEN_Exp_TumblersMonth:
        {
            // Credit Card Expiration Month Tumbler
            CDateObject tExpiration; 
            tExpiration.setFileTime( m_NewAccountInfo.m_Data.ftCardExpiration );

            ASSERT( tExpiration.getMonth() >= 1 );
            ASSERT( tExpiration.getMonth() <= 12 );
            return tExpiration.getMonth();      
        }
    case eGEN_Exp_TumblersYear:
        {
            // Credit Card Expiration Year Tumbler
            CDateObject tExpiration; 

            tExpiration.setFileTime( m_NewAccountInfo.m_Data.ftCardExpiration );

            ASSERT( tExpiration.getYear() >= 2000 );
            return tExpiration.getYear();
        }
    case eGEN_Dob_TumblersMonth:
        {
            // Date of Birth Month Tumbler
            CDateObject tDOB; 
            tDOB.setFileTime( m_NewAccountInfo.m_ftDOB );
            return tDOB.getMonth();
        }
    case eGEN_Dob_TumblersDay:
        {
            // Date of Birth Day Tumbler
            CDateObject tDOB; 
            tDOB.setFileTime( m_NewAccountInfo.m_ftDOB );
            return tDOB.getDay();
        }
    case eGEN_Dob_TumblersYear:
        {
            // Date of Birth Year Tumbler
            CDateObject tDOB; 
            tDOB.setFileTime( m_NewAccountInfo.m_ftDOB );
            return tDOB.getYear();
        }
    }

    return NULL;
}

//*************************************************************************************************
// this will return XBMSG_NEED_WAITCURSOR, if there is
// a task pump involved, if so, pass UpdateAccountInfo 
// into the wait cursor dlg object
//*************************************************************************************************
HRESULT Accounts::Validate( eButtonId eField, const TCHAR* pNewValue )
{
    HRESULT hr = S_OK;


    // figure out which button needs to do what...
    switch (eField)
    {
        case eACT_Idname:
        {
             
        }
	    break;
        
        case eACT_Idtag:
        {
            // do we have tags?
            if ( !m_NewAccountInfo.m_TagList.size() )
            {
                hr = BeginTask( TASK_BEGIN_TAGS, pNewValue ); // start up this, so we're ready when the tags button is pressed
            }

        }
        break;
        
        case eACT_Idcontinue:
        {
            hr = BeginTask( TASK_ALT_NAMES, pNewValue );
        }
	    break;

        case eACT_Billing_Country01:
        case eACT_Billing_Country02:
        case eACT_Billing_Country03:
        {
            // Now that we have the country from the user, reinitalize local info
            hr = CTranslator::Instance()-> Initialize( m_CountryID );
        }
        break;

        case eACT_Cost_Confirm_Yes:
        {
            // User confirmed payment, create the account
            hr = BeginTask( TASK_CREATE_ACCOUNT, NULL );
        }
        break;
    }

    return hr;
}

HRESULT Accounts::Validate( eButtonId eField, const FILETIME* pNewValue )
{
    HRESULT hr = S_OK;


    switch (eField)
    {
    case eGEN_Exp_TumblersMonth:
    case eGEN_Exp_TumblersYear:
        {
            // Credit Card expiration date validation
        }
        break;
    case eGEN_Dob_TumblersMonth:
    case eGEN_Dob_TumblersDay:
    case eGEN_Dob_TumblersYear:
        {

        }
        break;
    case eACT_Credit04: // we do need to check that the date is before today.
        {

        }
        break;
	}


    return hr;
}




HRESULT Accounts::CopyString( TCHAR** pWhere, const TCHAR* pCopyMe )
{
    if ( *pWhere )
    {
        delete [] *pWhere;
        *pWhere = NULL;
    }

    if ( pCopyMe )
    {
        *pWhere = new TCHAR[_tcslen(pCopyMe)+1];
        if ( !*pWhere )
        {
            return XBAPPERR_MEMORYERR;
        }
        _tcscpy( *pWhere, pCopyMe );
    }

    return S_OK;
}

//*************************************************************************************************
// this will return XBMSG_NEED_WAITCURSOR, if there is
// a task pump involved, if so, pass UpdateAccountInfo 
// into the wait cursor dlg object
//*************************************************************************************************
HRESULT  Accounts::SetValue( eButtonId eField, const TCHAR* pNewValue )
{
    HRESULT hr = S_OK;

    int index = 0;
    while( s_pBindData[index].buttonId != eNullButtonId )
    {
        if ( s_pBindData[index].buttonId == eField )
        {
            wcsncpy( s_pBindData[index].pAddress, pNewValue, s_pBindData[index].maxChars );
            return hr;
        }
        index++;
    }

    return E_FAIL;
}

HRESULT  Accounts::SetValue(eButtonId eField, const FILETIME* pNewValue)
{
    HRESULT hr = S_OK;

    switch (eField)
    {
    case eGEN_Exp_TumblersMonth:
    case eGEN_Exp_TumblersYear:
        {
            // Credit Card Expiration Tumbler
            m_NewAccountInfo.m_Data.ftCardExpiration = *pNewValue;
            return S_OK;
        }
    case eGEN_Dob_TumblersMonth:
    case eGEN_Dob_TumblersDay:
    case eGEN_Dob_TumblersYear:
        {
            // Date of Birth Tumbler
            m_NewAccountInfo.m_ftDOB = *pNewValue;
            return S_OK;
        }
    }

    return E_FAIL;
}

//*************************************************************************************************
// this will return XBMSG_NEED_WAITCURSOR, if there is
// a task pump involved, if so, pass UpdateAccountInfo 
// into the wait cursor dlg object
//*************************************************************************************************
HRESULT         Accounts::EnableButton( eButtonId eID  )
{
    HRESULT hr = S_OK;

    // figure out which button needs to do what...
    switch (eID)
    {
        // Account ID Screen
        case eACT_Idname: // always enable
            {
                break;
            }

        case eACT_Idtag:  // disable until we have a name
            {
                if ( 0 == wcslen( m_NewAccountInfo.m_Data.wszNickname ) )
                    hr = E_FAIL;
                break;
            }
        case eACT_IdDOB: // disable until Tag is filled in
            {
                if ( 0 == wcslen( m_NewAccountInfo.m_Data.wszKingdom ) )
                    hr = E_FAIL;
                break;
            }
        case eACT_Idcontinue:  // disable until we have a birthday
            {
                // disable until we have a real birthday
                if ( 0 == m_NewAccountInfo.m_ftDOB.dwHighDateTime &&
                     0 == m_NewAccountInfo.m_ftDOB.dwLowDateTime )
                    hr = E_FAIL;
                break;
            }

        // Account Credit Card Info Screen
/*        case eACT_Credit01: // always enable
            {
                break;
            }
        case eACT_Credit02: // disable until a credit card is choosen
            {
                if ( 0 != m_NewAccountInfo.m_Data.bCardTypeId )
                    hr = E_FAIL;
                break;
            }
        case eACT_Credit03: // disable until the user gives us their name
            {
                if ( 0 == wcslen( m_NewAccountInfo.m_Data.wszCardHolder ) )
                    hr = E_FAIL;
                break;
            }
*/
    }

    return hr;
}


//*************************************************************************************************
// Helper function, just to set wether we have a task pump going
//*************************************************************************************************
HRESULT Accounts::BeginTask(DWORD nTaskID, const TCHAR* pNewValue )
{
   // need to make sure the handle isn't in use,
    // I can't imagine that it is, but...

    HRESULT hr = S_OK;
    ASSERT( !m_bHaveTask );

    if ( m_bHaveTask )
        return -1; 

    switch( nTaskID )
    {
        case TASK_ALT_NAMES:
            hr = _XOnlineReserveName( m_NewAccountInfo.m_Data.wszNickname,
                                      m_NewAccountInfo.m_Data.wszKingdom,
                                      ALTERNATE_NAME_COUNT,
                                      m_CountryID,
                                      NULL,
                                      &m_hTask );
            break;
        
        case TASK_CREATE_ACCOUNT:
            hr = _XOnlineCreateAccount( &m_NewAccountInfo.m_Data, NULL, &m_hTask);
            break;

        case TASK_BEGIN_TAGS:
            hr = BeginGetTags( pNewValue );
            break;


        default:
            ASSERT( !"Accounts::BeginTask couldn't resolve the task\n" );
            break;
    }



    if ( SUCCEEDED( hr ) || hr == XBMSG_NEED_WAITCURSOR )
    {
        m_bHaveTask = true;
        m_nCurTask = (char)nTaskID;
        hr = XBMSG_NEED_WAITCURSOR; // tell 'em to wait for an answer
    }
    else
    {
        DbgPrint( "Accounts::BeginTask Couldn't start up the work pump\n" );
    }   

    return hr;

}

//*************************************************************************************************
// Call after you're finished pumping
//*************************************************************************************************
HRESULT Accounts::EndTask(DWORD nTaskID )
{
    ASSERT( m_bHaveTask );

    m_bHaveTask = false;

    HRESULT hr = S_OK;

    switch( nTaskID )
    {

        case TASK_ALT_NAMES:
            {
                hr = EndAlternateNames();
            }
          break;
        
        case TASK_CREATE_ACCOUNT:
            {
                hr = _XOnlineGetCreateAccountResults(m_hTask, &m_NewAccountInfo.m_User);
                if (FAILED(hr))    
                {
                    DbgPrint( "Accounts::EndTask temp create account failed\n" );
                }
                else 
                    hr = S_OK;

                XOnlineTaskClose( m_hTask );
            }
            break;

        case TASK_BEGIN_TAGS: // needs to be done from setValue
            hr = EndGetTags(NULL ); // closes handle for us

          break;
    }

    return hr;
}


//*************************************************************************************************
// helper function to setup the tag task pump
//*************************************************************************************************
HRESULT Accounts::BeginGetTags( const TCHAR* pName )
{
    HRESULT  hr  = S_OK;

     // Get the info from the server
    // HACK, 103 = US for now
    hr = _XOnlineGetTags(m_CountryID, TAG_COUNT, NULL, NULL, &m_hTask);

    if (FAILED(hr))
    {
         ASSERT( "Accounts::GetTags Couldn't begin the XOnlineGetTags account task pump\n" );
         return hr;
    }

    return XBMSG_NEED_WAITCURSOR;
   
}

//*************************************************************************************************
// Call after you're finished pumping
//*************************************************************************************************
HRESULT Accounts::EndGetTags( const TCHAR* pName )
{

    HRESULT hr = S_OK;

    LPWSTR pTags[TAG_COUNT];
    for ( int i = 0; i < TAG_COUNT; i++ )
    {
        pTags[i] = NULL;

    }
    WORD    nTagCount = TAG_COUNT;

    hr = _XOnlineGetTagsResults( m_hTask, pTags, &nTagCount );


    // YEAH, it worked!
    if ( SUCCEEDED( hr ) )
    {
        for ( int i = 0; i < nTagCount; i++ )
        {
            if ( pTags[i] )
            {
                TCHAR* pChar = new TCHAR[_tcslen( pTags[i] ) +1];
                if ( !pChar )
                    return XBAPPERR_MEMORYERR;
        
                _tcscpy( pChar, pTags[i] );
        
                m_NewAccountInfo.m_TagList.push_back( pChar );
            }
        }

        // this should be removed after beta, for now we default to the one and only tag
        if ( m_NewAccountInfo.m_TagList.size() )
        {
            wcsncpy( m_NewAccountInfo.m_Data.wszKingdom, 
                m_NewAccountInfo.m_TagList.front(), XONLINE_KINGDOM_SIZE );
        }

       // close old task, start a new one
       XOnlineTaskClose(m_hTask);
    

    }
    else  if ( hr == XONLINE_S_ACCOUNTS_NAME_TAKEN || hr == XONLINE_E_ACCOUNTS_INVALID_USER )
    // get some other names to try
    {
        XOnlineTaskClose(m_hTask);
        hr = BeginTask( TASK_ALT_NAMES, pName );
        // nullify the name
        m_NewAccountInfo.m_Data.wszNickname[0] = 0;
    }

    return hr;
}

HRESULT Accounts::EndAlternateNames( )
{
    PUSER_XNAME altNames = NULL;
    DWORD wordCount = 0;

    HRESULT hr = _XOnlineGetReserveNameResults( m_hTask, &altNames, &wordCount );
    if (FAILED(hr))    
    {
        DbgPrint( "Accounts::EndAlternate names failed to get the names back from the server\n" );
    }
    else // store new names locally
    { 
        for ( DWORD i = 0; i < wordCount; i++ )
        {
            TCHAR* pChar = new TCHAR[ _tcslen( altNames[i].wszNickname ) + 1 ];
            if ( !pChar )
                return XBAPPERR_MEMORYERR;
        
            _tcscpy( pChar, altNames[i].wszNickname );
        
            m_NewAccountInfo.m_AltNameList.push_back( pChar );
        }
    }

    XOnlineTaskClose( m_hTask );

    // tell 'em to press the alternate names button
    return hr;
}



//*************************************************************************************************
HRESULT Accounts::FrameMove()
{
    HRESULT hr = XBMSG_NEED_WAITCURSOR;

    // if we have a work pump flowing, run with it
    if ( m_bHaveTask )
    {
        hr = XOnlineTaskContinue(m_hTask);

        if (FAILED(hr))
        {
             ASSERT( !"Accounts::FrameMove Couldn't resume the task pump\n" );
             EndTask( m_nCurTask ); // need to clean up anyway
        }

        else if ( (hr) != XONLINETASK_S_RUNNING )
        {
            hr = EndTask( m_nCurTask );
            // do something here
            hr = XBMSG_OK;
          
        }
    }
    else
        hr = S_OK;

    return hr;

}

//*************************************************************************************************
void    Accounts::CleanUpNewAccountData()
{
    for ( list<TCHAR*>::iterator iter = m_NewAccountInfo.m_AltNameList.begin();
        iter != m_NewAccountInfo.m_AltNameList.end(); iter++ )
        {
            delete *iter;
        }

    m_NewAccountInfo.m_AltNameList.clear();

     for ( list<TCHAR*>::iterator iter = m_NewAccountInfo.m_TagList.begin();
        iter != m_NewAccountInfo.m_TagList.end(); iter++ )
        {
            delete *iter;
        }

    m_NewAccountInfo.m_TagList.clear();

    memset( &m_NewAccountInfo.m_Data, 0, sizeof( m_NewAccountInfo.m_Data ) );

}

//*************************************************************************************************
//  Local function to help create TCHAR memory and copy a string
//*************************************************************************************************
TCHAR* CreateUnicodeStr(const TCHAR *szInputStr)
{
    TCHAR *szDestStr = new TCHAR[wcslen(szInputStr) + 1];
    wcscpy(szDestStr, szInputStr);
    return szDestStr;
}


//*************************************************************************************************
//  Call this function to fill your listbox with the appropriate items from the server
//*************************************************************************************************
HRESULT Accounts::SetListBoxItems(eSceneId eCurSceneId, TCHAR*** ppszListItems, TCHAR*** ppszListHelp, int* nNumItems )
{
    HRESULT hr = S_OK;  

    switch(eCurSceneId)
    {
    case eACT_CountryId:
        {
            // These are placeholder credit cards.
            *ppszListItems = new TCHAR*[4];
            *ppszListHelp = new TCHAR*[4];
            TCHAR** pArray      = *ppszListItems;
            TCHAR** pHelpArray  = *ppszListHelp;

            pArray[0]     = CreateUnicodeStr(L"American Express");
            pHelpArray[0] = CreateUnicodeStr(L"HELP_NULL");
            pArray[1]     = CreateUnicodeStr(L"MasterCard");
            pHelpArray[1] = CreateUnicodeStr(L"HELP_NULL");
            pArray[2]     = CreateUnicodeStr(L"Visa");
            pHelpArray[2] = CreateUnicodeStr(L"HELP_NULL");
            pArray[3]     = CreateUnicodeStr(L"Discover");
            pHelpArray[3] = CreateUnicodeStr(L"HELP_NULL");
            *nNumItems = 4;
        break;
        }
    case eACT_Billing_CountryId:
        {
            // These are placeholder countries.
            *ppszListItems = new TCHAR*[2];
            *ppszListHelp = new TCHAR*[2];
            TCHAR** pArray      = *ppszListItems;
            TCHAR** pHelpArray  = *ppszListHelp;

            pArray[0]     = CreateUnicodeStr(L"United States");
            pHelpArray[0] = CreateUnicodeStr(L"HELP_NULL");
            pArray[1]     = CreateUnicodeStr(L"Canada");
            pHelpArray[1] = CreateUnicodeStr(L"HELP_NULL");
            *nNumItems = 2;
        break;
        }
    default:

        break;
    }

    return hr;
}


HRESULT Accounts::SetListBoxValue( eSceneId eCurSceneId, TCHAR* pNewValue )
{
    HRESULT hr = S_OK;  

    switch(eCurSceneId)
    {
    case eACT_CountryId:
        {
            // Credit Card Name screen (Amex, Mastercard, etc.)
            //wcscpy( m_NewAccountInfo.m_Data.wszCardType, (pNewValue) );
            // this is now bCardTypeId
        break;
        }
    case eACT_Billing_CountryId:
        {
            // User's Billing Country

            // BUGBUG: need to load a table with countries & country codes
            // Currently defaulting to 103 - United States
            m_NewAccountInfo.m_Data.bCountryId = 0x67;
        break;
        }
    default:

        break;
    }

    return hr;
}


void Accounts::ClearNewAccountData( void )
{
    memset( &m_NewAccountInfo.m_Data, 0, sizeof( m_NewAccountInfo.m_Data ) );
    memset( &m_NewAccountInfo.m_User, 0, sizeof( m_NewAccountInfo.m_User ) );
    
    // Initalize Dates and Times to 0
    m_NewAccountInfo.m_Data.ftCardExpiration.dwHighDateTime = 0;
    m_NewAccountInfo.m_Data.ftCardExpiration.dwLowDateTime  = 0;
    m_NewAccountInfo.m_ftDOB.dwHighDateTime = 0;
    m_NewAccountInfo.m_ftDOB.dwLowDateTime  = 0;

    m_NewAccountInfo.m_TagList.clear();
    m_NewAccountInfo.m_AltNameList.clear();
}

//*************************************************************************************************
// end of file ( AccountInfo.cpp )
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\xodash\XODashMain\AccountData.h ===
#ifndef ACCOUNTDATA_H
#define ACCOUNTDATA_H
/*************************************************************************************************\
AccountData.h		: Interface for all account and billing info
Creation Date		: 1/23/2002 6:31:00 PM
Library				: .lib
Copyright Notice	: (C) 2000 Microsoft
Author				: Heidi Gaertner
//-------------------------------------------------------------------------------------------------
Notes				: 
\*************************************************************************************************/

//*************************************************************************************************
#include "xonline.h"
#include <list>
#include "XOConst.h"
#include "SmartObject.h"
#include "Date.h"
#include "Translator.h"

using namespace std;

#define TASK_ALT_NAMES 1
#define TASK_CREATE_ACCOUNT 2
#define TASK_BEGIN_TAGS 3

#define MAX_ACCOUNT_STRLEN 64
/**************************************************************************************************
CLASS DESCRIPTION
AccountInfo:  This structure holds the basic for accounts
**************************************************************************************************/

struct AccountInfo // the basics
{
    XONLINE_USER		m_User;   // might have no XName if this is an owner account
 	char				m_cLocation; //  -1 == in process of creation...0 == HD, 1-8 = MU slots .... could be more if ever a splitter.

};

/**************************************************************************************************
CLASS DESCRIPTION
UserAccountInfo:  This is the class for user accounts, these have their own xname and stuff, but 
                there might be multiple of these tied to a single credit card
**************************************************************************************************/
struct UserAccountInfo : public AccountInfo// user Accounts
{
    DWORD               m_dwPurchasingPower; // might as well be bit field
    DWORD               m_dwParentalControls;
    TCHAR*              m_szPassport;
    BYTE                m_bPassportCanBeChanged; // could look for XBox.com in the passport itself

};

/**************************************************************************************************
CLASS DESCRIPTION
CreditCardInfo:  Everything you need to define a credit card
**************************************************************************************************/
struct CreditCardInfo
{
    TCHAR*				m_szType;
    TCHAR*				m_szCardholder;
    TCHAR*              m_szNumber;// only last 4 digits
    TCHAR*              m_szBillingAddress;
    TCHAR*              m_szCity;
    TCHAR*              m_szState;
    TCHAR*              m_szZip;
    SYSTEMTIME          m_ExpirationDate;
    TCHAR*              m_szCountryDisplayName;

};

/**************************************************************************************************
CLASS DESCRIPTION
OwnerAccountInfo:  This is the account that gets stuck paying for all the various user accounts,
                    if the account is already created, you probably don't get ALL the credit card
                    info
**************************************************************************************************/
struct OwnerAccountInfo : public AccountInfo // owner accounts
{
    WORD                m_localeID;
    CreditCardInfo      m_CardInfo;
    TCHAR*              m_pPassport;
};

struct NewAccountInfo
{
    NewAccountInfo();
    USER_ACCOUNT_INFO               m_Data;
    FILETIME                        m_ftDOB;
    list< TCHAR* >                  m_TagList;
    list< TCHAR* >                  m_AltNameList;
    XONLINE_USER                    m_User;

};

/**************************************************************************************************
CLASS DESCRIPTION
NewAccountInfo:  The info you need to create a new account
**************************************************************************************************/
class Accounts
{
public:

    // call this BEFORE you do anything else
    static HRESULT Initialize();
    static HRESULT CleanUp();

    static Accounts* Instance();
    static HRESULT  UpdateAccountInfo();

    const TCHAR*    GetValue(eButtonId eField);
    unsigned int    GetNumericValue(eButtonId eField);

    // this will return XBMSG_NEED_WAITCURSOR, if there is
    // a task pump involved, if so, pass UpdateAccountInfo 
    // into the wait cursor dlg object
    HRESULT         Validate( eButtonId eField, const TCHAR*    pNewValue );
    HRESULT         Validate( eButtonId eField, const FILETIME* pNewValue );

    // make sure you call Validate before SetValue
    HRESULT         SetValue(eButtonId eField, const TCHAR*    pNewValue);
    HRESULT         SetValue(eButtonId eField, const FILETIME* pNewValue);

    HRESULT         FrameMove();     // update task pumps etc, called from UpdateAccountInfo

    HRESULT         SetListBoxItems( eSceneId eCurSceneId, TCHAR*** ppszListItems, TCHAR*** ppszListHelp, int* nNumItems );
    HRESULT         SetListBoxValue( eSceneId eCurSceneId, TCHAR* pNewValue );

    HRESULT         EnableButton( eButtonId eID  );

    void            ClearNewAccountData( void );

  
private:

    Accounts();
    ~Accounts();

    struct ACT_BINDING_DATA
    {
        eButtonId   buttonId;
        TCHAR*      pAddress;
        long        maxChars;
    };

    static ACT_BINDING_DATA   s_pBindData[];


    HRESULT     BeginTask(DWORD nTaskID, const TCHAR* pValue );
    HRESULT     EndTask(DWORD  nTaskID);

    void        CleanUpNewAccountData();
    static HRESULT     CopyString( TCHAR** pWhere, const TCHAR* pCopyMe );


    static Accounts*               s_pAccounts;

    
    NewAccountInfo                 m_NewAccountInfo;
    WORD                           m_CountryID;

    
    // for task pumping purposes
    XONLINETASK_HANDLE             m_hTask;
    bool                           m_bHaveTask;
    char                           m_nCurTask;
    
    // HELPERS
    HRESULT     BeginGetTags( const TCHAR* pName);
    HRESULT     EndGetTags( const TCHAR* pName );
    HRESULT     EndAlternateNames( );
};
 



//*************************************************************************************************
#endif  // end of file ( AccountData.h )
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\xodash\XODashMain\act_online.cpp ===
/*************************************************************************************************\
act_online.cpp			: Implementation of all account creation and modification scenes
Creation Date		: 2/4/2002 9:47:54 AM
Copyright (c) Microsoft Corporation.  All rights reserved
Author				: Heidi Gaertner
//-------------------------------------------------------------------------------------------------
Notes				: 
\*************************************************************************************************/

#include "std.h"
#include "Scene.h"
#include "XBInput.h"
#include "NetConfig.h"
#include "globals.h"
#include "InputHandle.h"
#include "Dialog.h"
#include "tgl.h"
#include "AccountData.h"
#include "SceneNavigator.h"
#include "netConfig.h"
#include "date.h"
#include "accountdata.h"

HRESULT CACT_OnlineScene::m_hrLogon = -1;
//*************************************************************************************

HRESULT CACT_OnlineScene::Initialize(char* pUrl, char* pButtonTextName,  eSceneId eCurSceneId, bool bAutoTest)
{
    HRESULT hr = CCellWallScene::Initialize( pUrl, pButtonTextName, eCurSceneId, bAutoTest );
    

    // store, we can't pop dialog right here, in case this is the first screen

      return hr;

}

//*************************************************************************************

HRESULT CACT_OnlineScene::FrameMove(XBGAMEPAD& GamepadInput, float elapsedTime )
{
	ASSERT(m_pButtons.size() == 4);
    bool bRenderParentScene = true;

    if ( GamepadInput.bPressedAnalogButtons[XINPUT_GAMEPAD_A] || GamepadInput.wPressedButtons & XINPUT_GAMEPAD_START )
    {
        eButtonId id = m_pButtons[m_nActiveButtonIndex]->GetButtonId();

        switch( id )
        {
        case eACT_Online02:
            {
                // Insure that we have a connection before going any further
                if( eServiceFail == g_NetConfig.CheckNetworkStatus() )
                {
                    RunOKDlg( L"ERR_NOT_CONNECTED" );
                    CSceneNavigator::Instance()->MoveNextScene( eACT_Online03 );
                    bRenderParentScene = false;
                }
            }
            break;
        }
    }

    HRESULT hr;
    if( bRenderParentScene )
        hr = CCellWallScene::FrameMove(GamepadInput, elapsedTime );

    // if we've never logged on, log on 
    if ( m_hrLogon == -1 )
     {
        if ( XBMSG_CANCEL == RunWaitCursor( _T("NTS_DIALOG_CONNECT"), AttemptMachineLogon ) )
        {
            m_hrLogon = XBAPP_ERR_LOGON_CANCELED;
        }
     }
    // we failed at logging on, go to network settings 
    else if ( m_hrLogon == XBAPP_ERR_LOGON_FAILED )
     {
         RunOKDlg( _T("NTS_DIALOG_REDIRECT") );

         CSceneNavigator::Instance()->MoveNextScene( eACT_Online03 );                       

         m_hrLogon = 0;
     }

    return hr;
}


//*************************************************************************************

HRESULT CACT_OnlineScene::AttemptMachineLogon()
{
  eNetworkState ns = g_NetConfig.CheckServiceStatus();
  HRESULT hr = S_OK;

  switch ( ns )
  {
      // all the failure cases I hope, the above function would
      // be nicer if it returned HRESULTS
      case 	eCableFail:
      case  eIPFail:
      case  ePPPoEFail:
      case  eDNSFail:
      case  eServiceFail:
          m_hrLogon = XBAPP_ERR_LOGON_FAILED;
          hr = XBMSG_OK;
          // press the nts buttons
          break;

      case eDone:
          m_hrLogon = 0; // all is clear
          hr = XBMSG_OK;
          break;

      default: // keep pumping
          hr = S_OK;
          break;
  }

  

   return hr;
    

}

//*************************************************************************************
// ACT_Scene, base class for all account objects
//*************************************************************************************
HRESULT CACT_Scene::Initialize(char* pUrl, char* pButtonTextName,  eSceneId eCurSceneId, bool bAutoTest )
{
    HRESULT hr = CCellWallScene::Initialize( pUrl, pButtonTextName, eCurSceneId, bAutoTest );

    UpdateButtons();

    return hr;
}

//*************************************************************************************
// call this after something has changed, or when you enter the screen
//*************************************************************************************
void CACT_Scene::UpdateButtons()
{
    for ( unsigned long i = 0; i < m_pButtons.size(); i++ )
    {
	    CText* pInput = (CText*)m_pButtons[i]->GetInputTextObject();
        if ( pInput )   
        {
            const TCHAR* pText = Accounts::Instance()->GetValue( m_pButtons[i]->GetButtonId() );
            if ( pText )
            {
                pInput->SetText( pText );
            }
        }

        // If a listbox exists in the scene, populate it here
        if ( m_pListBox )
        {
            int   numListItems;
            TCHAR **ppszListItems = NULL;
            TCHAR **ppszListHelp  = NULL;
            Accounts::Instance()->SetListBoxItems(m_eSceneId, &ppszListItems, &ppszListHelp, &numListItems);
            m_pListBox->RemoveAllItems();
            m_pListBox->AppendItems((const TCHAR**)ppszListItems, (const TCHAR**)ppszListHelp, numListItems );
        }

        HRESULT enable = Accounts::Instance()->EnableButton( m_pButtons[i]->GetButtonId() );
        if ( FAILED( enable ) )
        {
            if ( m_pButtons[i]->GetState() == eButtonHighlighted || 
                m_pButtons[i]->GetState() == eButtonDisabledHighlighted )
            {
                m_pButtons[i]->SetState( eButtonDisabledHighlighted );
            }
            else
            {
                m_pButtons[i]->SetState( eButtonDisabled );
            }
        }
        else if ( m_pButtons[i]->GetState() != eButtonHighlighted )
        {
            m_pButtons[i]->SetState( eButtonDefault );
        }

    }
}

//*************************************************************************************
// Base class for all scene objects that use account/billing data info
//*************************************************************************************
HRESULT CACT_Scene::SetValue(const TCHAR* szValue)
{
    eButtonId id = m_pButtons[m_nActiveButtonIndex]->GetButtonId();

	const CText* pInput = m_pButtons[m_nActiveButtonIndex]->GetInputTextObject();
    if ( pInput )    
    { 
        HRESULT validateHR = Accounts::Instance()->SetValue( id, szValue );
        if ( SUCCEEDED( validateHR ) )
        {
    	    (const_cast <CText*> (pInput))->SetText(szValue);

             // need to update buttons that might have been affected
             UpdateButtons();
        }
        else
            return validateHR;
    } 
    
    return S_OK;
}

HRESULT CACT_Scene::Validate( eButtonId id, const TCHAR* szValue )
{
    // make sure this is what we want to see
    HRESULT validateHR  = Accounts::Instance()->Validate( id, szValue );
    bool bRanWaitCursor = false;
    while ( validateHR == XBMSG_NEED_WAITCURSOR )
    {
        validateHR     = RunWaitCursor( NULL, Accounts::UpdateAccountInfo, _T("CANCEL") );
        bRanWaitCursor = true;
    }

    // check return value....
    if ( SUCCEEDED( validateHR ) || (validateHR == XBMSG_OK) )
    {
        UpdateButtons();
        if( bRanWaitCursor )
            return XBMSG_HAD_TO_WAIT;
        else
            return S_OK;
    }
    else // we failed
    {
        if ( ( validateHR & XBAPP_BUTTON_ID) == XBAPP_BUTTON_ID ) // data says go somewhere else
        {
            CSceneNavigator::Instance()->MoveNextScene( (eButtonId)(validateHR & 0x0000ffff) );                       
        }
        else // pop error message 
        {
            validateHR = RunOKDlg( validateHR );
            UpdateButtons(); 
        }
     }

    return validateHR;    
}


HRESULT CACT_Scene::FrameMove(XBGAMEPAD& GamepadInput, float elapsedTime )
{
	HRESULT hr = S_OK;
    bool bCallBaseClass = true;

    if (!g_szUserInput.Empty())
	{
		SetValue(g_szUserInput.GetInputText());
		g_szUserInput.ResetInputText();
	}

     // Check to see if we need to populate the keyboard global buffer
    if ( GamepadInput.bPressedAnalogButtons[XINPUT_GAMEPAD_A] || GamepadInput.wPressedButtons & XINPUT_GAMEPAD_START )
    {
         CText* pText = const_cast <CText*> (m_pButtons[m_nActiveButtonIndex]->GetInputTextObject());
         // should probably put a check to see if the button belongs to this list box
         // but it might not matter
         if ( m_pListBox )
         {
            const TCHAR *pText = m_pButtons[m_nActiveButtonIndex]->GetTextObject()->GetText();
            hr = Accounts::Instance()->SetListBoxValue(m_eSceneId, (TCHAR *)pText);
         }
         else if ( pText )
         {
            g_szUserInput.SetInputText(pText->GetText()); 
         }
         
         // validate no matter what
         if ( FAILED( hr = Validate( m_pButtons[m_nActiveButtonIndex]->GetButtonId(), NULL ) ) )
         {
             // we don't want to move on, the CScene will do that if we aren't careful
             bCallBaseClass = false;
         }
         else if ( hr == XBMSG_HAD_TO_WAIT )
         {
             hr = S_OK;
             bCallBaseClass = false;
             CSceneNavigator::Instance()->MoveNextScene( m_pButtons[m_nActiveButtonIndex]->GetButtonId() );
         }
         else
         {
             UpdateButtons();            
         }
    }

    Accounts::Instance()->FrameMove(); // call all the time, we might spawn tasks when we expect they are coming
	
    if ( bCallBaseClass )
        hr = CCellWallScene::FrameMove(GamepadInput, elapsedTime );
    
    return hr;
    
}


//*************************************************************************************
// ACT Signup Screens
//*************************************************************************************

int  CACT_SignupAccount::m_nSignupAge            = 0;
bool CACT_SignupAccount::m_bDisplayParentMessage = false;

CACT_SignupAccount::CACT_SignupAccount()
{

}

CACT_SignupAccount::~CACT_SignupAccount()
{

}

HRESULT CACT_SignupAccount::Initialize(char* pUrl, char* pButtonTextUrl,  eSceneId eCurSceneId, bool bAutoTest)
{
    HRESULT hr = S_OK;

    hr = CACT_Scene::Initialize(pUrl, pButtonTextUrl, eCurSceneId, bAutoTest);

    switch(eCurSceneId)
    {
    case eACT_CountryId:
        {
        }
        break;
    case eACT_IdId: 
        {
            break;
        }
    case eACT_BillingId:
        {
            HideObject("button_credit");
            HideText("text_NAME");
            HideText("text_credit");
            break;
        }
    case eACT_CreditId:
        {
            HideObject("button_billing");
            HideText("text_NAME");
            HideText("text_billing");               
            break;
        }
    case eGEN_Exp_TumblersId:
        {
            // Our credit card date expiration ranges
            CDateObject currentDate;
            m_pSpinners[1]->SetRange( 1, 12 );
            m_pSpinners[0]->SetRange( currentDate.getFullYear(), currentDate.getFullYear() + 10 );

            m_pSpinners[1]->SetPrecision(2);
            m_pSpinners[0]->SetPrecision(2);

            m_pSpinners[1]->SetValue( Accounts::Instance()->GetNumericValue( eGEN_Exp_TumblersMonth ) );
            m_pSpinners[0]->SetValue( Accounts::Instance()->GetNumericValue( eGEN_Exp_TumblersYear ) );
            break;
        }
    case eGEN_Dob_TumblersId:
        {
            // Date of Birth Tumblers
            CDateObject currentDate;  
            m_pSpinners[2]->SetRange( 1, 12 );  // month
            m_pSpinners[1]->SetRange( 1, 31 );  // day
            m_pSpinners[0]->SetRange( currentDate.getFullYear() - 50, currentDate.getFullYear() );  // year

            m_pSpinners[2]->SetPrecision(2);
            m_pSpinners[1]->SetPrecision(2);
            m_pSpinners[0]->SetPrecision(2);

            m_pSpinners[2]->SetValue( Accounts::Instance()->GetNumericValue( eGEN_Dob_TumblersMonth ) );
            m_pSpinners[1]->SetValue( Accounts::Instance()->GetNumericValue( eGEN_Dob_TumblersDay ) );
            m_pSpinners[0]->SetValue( Accounts::Instance()->GetNumericValue( eGEN_Dob_TumblersYear ) );

            CACT_SignupAccount::m_nSignupAge = 0;
            CACT_SignupAccount::m_bDisplayParentMessage = false;
            break;
        }
    default:

        break;
    }

    return hr;
}
    

HRESULT CACT_SignupAccount::FrameMove(XBGAMEPAD& GamepadInput, float elapsedTime )
{
    HRESULT hr = S_OK;
    bool bSceneFrameMove = true;
 
    switch ( m_eSceneId )
    {
    case eGEN_Dob_TumblersId:
        {
            // Date of Birth Spinners must behave based on days in month
            CDateObject newTime;
            int nMonth = m_pSpinners[2]->GetValue();
            int nDay   = m_pSpinners[1]->GetValue();
            int nYear  = m_pSpinners[0]->GetValue();
 
            int nDaysInMonth = newTime.getDaysInMonth( nMonth, nYear );
            if( nDay > nDaysInMonth ) // month changed with date too high
            {
                nDay = nDaysInMonth;
                m_pSpinners[1]->SetValue( nDay );
            }

            m_pSpinners[1]->UpdateRange( 1, nDaysInMonth );
        }
        break;
    case eACT_CreditId:
        {    
            if( CACT_SignupAccount::m_bDisplayParentMessage )
            {
                RunOKDlg( L"CRED_UNDER_18_MESSAGE" );
                bSceneFrameMove         = false;
                CACT_SignupAccount::m_bDisplayParentMessage = false;
            }
        }
        break;
    }

    // Save the current spinner Values
    if ( GamepadInput.bPressedAnalogButtons[XINPUT_GAMEPAD_A] || GamepadInput.wPressedButtons & XINPUT_GAMEPAD_START )
    {
        eButtonId id = m_pButtons[m_nActiveButtonIndex]->GetButtonId();

        switch( m_eSceneId )
        {
        case eGEN_Welcome_PanelId:
            {
                // User has choosen to decline the Account signup, confirm their choice
                if( id == eGen_Welcome_Panel02 )
                {
                    HRESULT hDialogReturn;
                    hDialogReturn = RunYesNoDlg( L"GEN_WELCOME_EXIT_CONFIRM", L"YES", L"NO", true );
                    if( hDialogReturn == XBMSG_BACK || hDialogReturn == XBMSG_CANCEL )
                    {
                        // Return the user to the welcome screen
                        bSceneFrameMove         = false;
                    }
                }
            }
            break;
        case eACT_IdId:  // Account ID entry
            {
                if( id == eACT_Idcontinue )
                {
                    // Make sure the user is over 13, else return to root menu
                    if( CACT_SignupAccount::m_nSignupAge < 13 )
                    {
                        hr = RunOKDlg( XACT_E_USER_TOO_YOUNG );
                        Accounts::Instance()->ClearNewAccountData();

                        // Navigate them back to the online root
                        bSceneFrameMove         = false;
                        CSceneNavigator::Instance()->MoveNextScene( eACT_idHiddenBadName );
                        break;
                    }
                }
            }
            break;
        case eGEN_Exp_TumblersId:  // Credit card expiration
            {
                CDateObject newTime;
                newTime.clearDate();
                newTime.setMonth( (WORD)m_pSpinners[1]->GetValue() );
                newTime.setYear(  (WORD)m_pSpinners[0]->GetValue() );

                hr = Accounts::Instance()->SetValue( m_pButtons[m_nActiveButtonIndex]->GetButtonId(), &newTime.m_time );
            }
            break;
        case eGEN_Dob_TumblersId:   // Date of Birth Tumbler
            {
                CDateObject newTime;
                newTime.clearDate();
                newTime.setMonth( (WORD)m_pSpinners[2]->GetValue() );
                newTime.setDay(   (WORD)m_pSpinners[1]->GetValue() );
                newTime.setYear(  (WORD)m_pSpinners[0]->GetValue() );

                hr = Accounts::Instance()->SetValue( m_pButtons[m_nActiveButtonIndex]->GetButtonId(), &newTime.m_time );
                
                // Store the users age for later checks
                CACT_SignupAccount::m_nSignupAge = newTime.calcAge();
                
                // If the user is under 18, ask for a parents presence
                if( CACT_SignupAccount::m_nSignupAge < 18 )
                    CACT_SignupAccount::m_bDisplayParentMessage = true;
            }
            break;
        case eGen_Large_PanelId:  // Deal with Cost Screen and Exiting
            {
                HRESULT hDialogReturn = S_OK;

                while( 1 )
                {
                    // Confirm that the user must pay $ to sign up for the service
                    hDialogReturn = RunYesNoDlg( L"SIGNUP_COST_MESSAGE", L"YES", L"NO", true );

                    if( hDialogReturn == XBMSG_CANCEL )      
                    {
                        // They don't want to pay, so we should ask them if they wish to exit
                        HRESULT hDialogExit = RunYesNoDlg( L"SIGNUP_COST_CANCEL", L"YES", L"NO", true );
                
                        if( hDialogExit == XBMSG_OK )
                        {
                            //BUGBUG: Navigate user back to Xdash, or back to game
                            Accounts::Instance()->ClearNewAccountData();
                            CSceneNavigator::Instance()->MoveNextScene( eGen_Large_Panel02 );
                            bSceneFrameMove = false;
                            break;
                        }
                    }
                    else if( hDialogReturn == XBMSG_BACK )
                    {
                        // User wanted to go back from the payment screen
                        bSceneFrameMove = false;
                        break;
                    }
                    else
                    {
                        // Create the Account
                        hr = Accounts::Instance()->Validate( eACT_Cost_Confirm_Yes, L"" );
                        hDialogReturn = RunOKDlg( L"SIGNUP_CONGRATS_MESSAGE" );
                        
                        break;
                    }
                }
            }
        }
    }

    if( bSceneFrameMove )
        hr = CACT_Scene::FrameMove(GamepadInput, elapsedTime );

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\xodash\XODashLib\XOConst.h ===
#pragma once

#include "winerror.h"
// DVD types enun

#include "ButtonName.h"
#include "ButtonId.h"
#include "ButtonHelp.h"
#include "SceneName.h"
#include "SceneId.h"

enum DiscType
{ 
	eDiscNone = 0,
	eDiscBad ,
	eDiscTitle ,
	eDiscAudio ,
	eDiscVideo
};


#define MAX_BLOCKS_TO_SHOW 50000
#define LF_FACESIZE 32


#define BODY_FONT 0
#define HEADING_FONT 1


#define MAX_SCENE_NUM 300
#define MAX_CHILD_SCENE_NUM 50
#define MAX_BUTTON_IN_SCENE 50
#define MAX_EXIT_POINT_NUM 20
#define MAX_URL_SIZE 100
#define MAX_NAVIGATOR_STACK_SIZE 30
#define MAX_INPUT_TEXT_SIZE  20

// NTS specific consts
#define IP_ADDRESS_SIZE 15
#define MAX_NTS_SIZE 64

//-----------------------------------------------------------------------------
// Error codes
//-----------------------------------------------------------------------------
#define XBAPP_S_BASE 0x00000040
#define XBMSG_HAD_TO_WAIT       XBAPP_S_BASE+1



#define XBAPP_INFO_BASE 0x82000000
#define XBMSG_OK                XBAPP_INFO_BASE+1
#define XBMSG_CANCEL            XBAPP_INFO_BASE+2
#define XBMSG_NEED_WAITCURSOR   XBAPP_INFO_BASE+3
#define XBMSG_BACK              XBAPP_INFO_BASE+4

#define XBAPPERR_BASE  XBAPP_INFO_BASE+1000
#define XBAPPERR_MEDIANOTFOUND  (XBAPPERR_BASE)+1
#define XBAPPERR_INVALIDIP		(XBAPPERR_BASE)+2
#define XBAPPERR_INVALIDSTR		(XBAPPERR_BASE)+3
#define XBAPPERR_MEMORYERR		(XBAPPERR_BASE)+3
#define XBAPPERR_INTERNAL_ERROR (XBAPPERR_BASE)+4

#define XBAPP_ERR_LOGON_CANCELED (XBAPPERR_BASE)+5
#define XBAPP_ERR_LOGON_FAILED (XBAPPERR_BASE)+6

#define XACT_E_USER_TOO_YOUNG (XBAPPERR_BASE)+7



#define XBAPPWRN_BASE  XBAPPERR_BASE+1000
#define XBAPPWRN_SCENE_CHANGED  XBAPPWRN_BASE+1

// bottom bits = bitField of button ID to press next
// this is the return value from some validation calls
#define XBAPP_BUTTON_ID 0x83000000



enum eSoundType
{
    eKeyboardSound,
    eStandardSound,
    eLastSoundType
};

enum eSound
{
    eSoundAPress,
    eSoundBPress,
    eSoundHighlight,
    eSoundDisabled,
    eLastSound
};

static TCHAR* SoundInfo[eLastSoundType][eLastSound] = 
{
    {_T("mainaudio\\Global Keyboard Stroke 2.wav"), _T("mainaudio\\Global B Button Back.wav"), 
        _T("mainaudio\\Global Keyboard Stroke 1.wav"), _T("mainaudio\\Global Error Message B.wav") },
    {_T("mainaudio\\Global A Button Select.wav"), _T("mainaudio\\Global B Button Back.wav"), 
            _T("mainaudio\\Global Scroll Beep.wav"), _T("mainaudio\\Global Error Message B.wav") },
};





typedef HRESULT (*ButtonCallBack)(void);

struct ErrorStrInfo
{
    HRESULT             m_hrError;
    const TCHAR*        m_pErrorID;
};

#define ERROR_STR_COUNT 9
static ErrorStrInfo ErrorStringIDs[ERROR_STR_COUNT] = 
{
    { XBAPPERR_MEDIANOTFOUND, _T("HELP_SETTINGS") },
    { XBAPPERR_INVALIDIP, _T("ERR_INVALID_IP")},
    { XBAPPERR_INVALIDSTR, _T("ERR_INVALID_STR")},
    { XONLINE_E_INTERNAL_ERROR,     _T("ERR_NO_SERVER")},
    //{ XUAC_E_NAME_TAKEN,           _T("ERR_NAME_UNAVAILABLE")},
    { XONLINE_E_ACCOUNTS_INVALID_KINGDOM,      _T("ERR_INAVLID_KINGDOM")},
    { XONLINE_E_ACCOUNTS_INVALID_USER,         _T("ERR_INVALID_USER")},
    { ERROR_SERVICE_SPECIFIC_ERROR, _T("ERR_NO_SERVER")},
    { XACT_E_USER_TOO_YOUNG,    _T("ERR_TOO_YOUNG")}
};

enum eGlobalModels
{
	eCellWallId = 0,
	eAButton,
	eBButton
};

enum eButtonState
{
	eButtonDefault = 0,
	eButtonPressed ,
	eButtonHighlighted,
	eButtonDisabled,
    eButtonDisabledHighlighted, // focused, but not pressable
    eButtonStateMax
};

enum eButtonOrientation
{
	eButtonVerticalOrientation,
	eButtonHorizontalOrientation,
};

enum eInputState
{
	eNoInput = 0,
	eFirstTimePress,
	eRepetitivePress
};

enum eAutoTestData
{
	eSceneInit,
	eChangeFocus,
	ePressed
};

// RTTI could not be enabled with XBox OS code, reinventing the weel
enum eButtonRTTI
{
	eOneTextButton,
	eTwoTextButton
};


// pathes app uses
#define LOCALE  "Locale\\"
#define XBG     "Xbg\\"
#define XBX     "Xbx\\"
#define ASE     "Ase\\"
#define SOUNDS  "Audio\\"
#define CONTENT "Content\\"

#define DASH_PARTITION		     "\\Device\\Harddisk0\\Partition2"
#define DASH_DRIVE_LETTER        'd'

#define APPLICATION_PATH_ANSI     "d:\\"
#define MEDIA_PATH_ANSI           "d:\\Media\\"
#define LOCALE_PATH_ANSI          MEDIA_PATH_ANSI LOCALE
#define XBG_PATH_ANSI             MEDIA_PATH_ANSI XBG
#define XBX_PATH_ANSI             MEDIA_PATH_ANSI XBX 
#define XTF_PATH_ANSI             APPLICATION_PATH_ANSI 
#define ASE_PATH_ANSI             MEDIA_PATH_ANSI ASE 
#define SOUNDS_PATH_ANSI          APPLICATION_PATH_ANSI SOUNDS
#define CONTENT_PATH_ANSI         MEDIA_PATH_ANSI CONTENT 


#define APPLICATION_PATH         _T(APPLICATION_PATH_ANSI) 
#define MEDIA_PATH               _T(MEDIA_PATH_ANSI) 
#define LOCALE_PATH              MEDIA_PATH _T(LOCALE) 
#define XBG_PATH                 MEDIA_PATH _T(XBG)
#define XBX_PATH                 MEDIA_PATH _T(XBX) 
#define XTF_PATH                 APPLICATION_PATH  
#define ASE_PATH                 MEDIA_PATH _T(ASE)  
#define SOUNDS_PATH              APPLICATION_PATH _T(SOUNDS)
#define CONTENT_PATH             MEDIA_PATH _T(CONTENT)  

#define LOCALE_FILE_ANSI         "locale"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\xodash\XODashLib\xip.h ===
#pragma once

#define XIP_MAGIC 0x30504958
#define XIP_DIGEST_LENGTH 20

#include <tchar.h>

struct XIPHEADER
{
	DWORD m_dwMagic;
	DWORD m_dwDataStart;
	WORD m_wFileCount;
	WORD m_wNameCount;
	DWORD m_dwDataSize;
};

struct FILEDATA
{
	DWORD m_dwDataOffset;
	DWORD m_dwSize;
	DWORD m_dwType;
	DWORD m_dwTimestamp;
};

struct FILENAME
{
	WORD m_wFileDataIndex;
	WORD m_wNameOffset;
};


typedef struct {

	UCHAR Signature[XIP_DIGEST_LENGTH];

} XIP_SIG, *PXIP_SIG;

typedef struct {

	WCHAR Name[MAX_PATH];
	UINT SignatureCount;

} XIP_PROTECTION, *PXIP_PROTECTION;



#define XIP_TYPE_GENERIC			0
#define XIP_TYPE_MESH				1
#define XIP_TYPE_TEXTURE			2
#define XIP_TYPE_WAVE				3
#define XIP_TYPE_MESH_REFERENCE		4 // m_dwDataOffset is MESHID; m_dwSize is nPrimitiveCount
#define XIP_TYPE_INDEXBUFFER		5
#define XIP_TYPE_VERTEXBUFFER		6

#ifndef BUILD_XIPSIGN

#define MAX_MESHBUFFER 10

struct CMeshBuffer
{
	DWORD m_fvf;
	int m_nVertexStride;
	int m_nVertexCount;
	int m_nIndexCount;
	IDirect3DVertexBuffer8* m_pVertexBuffer;
	IDirect3DIndexBuffer8* m_pIndexBuffer;
};

class CFileBuffer
{
public:
	CFileBuffer();
	~CFileBuffer();

	void SetFile(const TCHAR* Name, HANDLE hFile);
	int Read(void* pv, int cb);
	bool Seek(int nPos);
	void FreeBuffer();
	void StartSignature (VOID);
	void EndSignature (XCALCSIG_SIGNATURE * Signature);



	HANDLE m_hFile;
	PXIP_PROTECTION m_XipSigs;
	BYTE* m_pbBuffer;
	int m_cbBuffer;
	int m_ibRead;
    int m_nBlkCur;
private:
    void VerifyXipSignature(PBYTE Buffer, DWORD DataSize);
};

class CXipFile
{
public:
	CXipFile();
	~CXipFile();

	bool Open(const TCHAR* szXipFileName);
	void Reload();
	int Find(const TCHAR* szURL);
//	bool Find(const char* szURL, BYTE*& pbContent, DWORD& cbContent);
	void* FindObject(const TCHAR* szURL, int nType = -1);

	TCHAR* m_szDirPath;
	TCHAR* m_szXipFileName;

	XIPHEADER m_header;
	FILEDATA* m_filedata;
	FILENAME* m_directory;
	TCHAR* m_names;

	void** m_objects;
	bool m_bLoaded;

	CMeshBuffer m_rgMeshBuffer [MAX_MESHBUFFER];
	int m_nVertexBufferCount;
	int m_nIndexBufferCount;

	void DeleteMeshBuffers();

	float m_cacheTime;

	bool m_bLocked;

	bool IsUnloaded() const;
	bool IsReloading() const;
	inline bool IsReady() const
		{ return m_bLoaded && !m_bReloading; }

protected:
	CFileBuffer m_file;
	bool m_bReloading;

	bool Load();
	void CreateObjects();
	void ReloadMeshBuffers();
	void ReadIndexBuffer(int nFileIndex, int nIndexBuffer);
	void ReadVertexBuffer(int nFileIndex, int nVertexBuffer);

	static DWORD CALLBACK StartLoadThread(LPVOID pvContext);
	static CXipFile* LoadXIP(const TCHAR* szURL, bool bSync);
};

//extern CXipFile* LoadXIP(const char* szURL, bool bSync = false);
extern bool FindInXIPAndDetach(const char* szURL, BYTE*& pbContent, DWORD& cbContent);
extern void* FindObjectInXIP(const TCHAR* szURL, const TCHAR* szFilename, int nType = -1);

#endif // BUILD_XIPSIGN
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\xodash\XODashLib\xip.cpp ===
#include "std.h"

#include <tchar.h>
#include <xtl.h>
#include "xip.h"
#include "FileUtil.h"
#include "utilities.h"
//#include "Mesh.h"
#include "xcrypt.h"
#include "globals.h"

extern BOOL g_bEdgeAntialiasOverride;


extern "C" void* WINAPI D3D_AllocNoncontiguousMemory(DWORD Size);
extern "C" void WINAPI D3D_FreeNoncontiguousMemory(void *pMemory);


#define FILE_BUFFER_SIZE 65536


void FileProtectionError()
{
#ifdef _DEBUG
	DbgPrint("XIP File Protection Error");
    __asm int 3;
#else
    HalReturnToFirmware(HalFatalErrorRebootRoutine);
#endif
}

CFileBuffer::CFileBuffer()
{
	m_hFile = INVALID_HANDLE_VALUE;
	m_pbBuffer = NULL;
	m_cbBuffer = 0;
	m_ibRead = 0;
    m_nBlkCur = 0;
	m_XipSigs = NULL;
}

void CFileBuffer::SetFile(const TCHAR* Name, HANDLE hFile)
{

	ASSERT(m_hFile == INVALID_HANDLE_VALUE);
	m_hFile = hFile;

//	wchar_t uniName[MAX_PATH];
//	Unicode( uniName, Name, MAX_PATH );

	
    if (m_XipSigs)
    {
        ASSERT(XFreeSectionByHandle(XGetSectionHandle("XIPS")));
    }

	m_XipSigs = (PXIP_PROTECTION)XLoadSection("XIPS");

	if (!m_XipSigs)
    {
		//
		// No Xip Signatures in the XBE.
		//
		DbgPrint("No XIP section in XBE.");
		FileProtectionError();
	}
	else
    {	
		while (m_XipSigs->SignatureCount != 0 && lstrcmpi(Name + 3, m_XipSigs->Name))
        {
			m_XipSigs = (PXIP_PROTECTION)((PBYTE)(m_XipSigs + 1) +
                (m_XipSigs->SignatureCount * sizeof (XIP_SIG)));
		}

		if (m_XipSigs->SignatureCount == 0)
        {
			//
			// Did not find this XIP file in the XIP section.
			//
			DbgPrint("File %s not found in XBE Xip section.", Name);
			FileProtectionError();
		}
	}
}

CFileBuffer::~CFileBuffer()
{
	FreeBuffer();

    // Keep the section load counts valid
    if (m_XipSigs)
    {
        ASSERT(XFreeSectionByHandle(XGetSectionHandle("XIPS")));
    }
}

void CFileBuffer::FreeBuffer()
{
	if (m_pbBuffer != NULL)
	{
		ASSERT(VirtualFree(m_pbBuffer, 0, MEM_RELEASE));
		m_pbBuffer = NULL;
	}
}

void CFileBuffer::VerifyXipSignature(PBYTE Buffer, DWORD DataSize)
{
	UCHAR digest[XC_DIGEST_LEN];

	//
	// Check the signature of this 64k block.
	//
//	XCCalcDigest(Buffer, DataSize, digest);

	if (!m_XipSigs || (ULONG)m_nBlkCur >= m_XipSigs->SignatureCount ||
        memcmp (digest, ((PXIP_SIG)(m_XipSigs + 1))[m_nBlkCur].Signature,
        XIP_DIGEST_LENGTH))
    {
		DbgPrint("File modified or corrupt!\n");
		FileProtectionError();
	}
}

bool CFileBuffer::Seek(int nPos)
{
#if DBG
    static int nLastPos;
    nLastPos = nPos;
#endif

	int nBlock = nPos / FILE_BUFFER_SIZE;

	if (m_pbBuffer == NULL)
	{
        for (;;)
        {
            m_pbBuffer = (BYTE*)VirtualAlloc(NULL, FILE_BUFFER_SIZE, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);
            if (m_pbBuffer)
            {
                break;
            }
            ASSERT( !"faled to allocate file buffer\n" );
        }
		m_nBlkCur = -1;
	}

	if (nBlock != m_nBlkCur)
	{
        ASSERT(m_XipSigs == NULL || (ULONG)nBlock < m_XipSigs->SignatureCount);

		ASSERT(SetFilePointer(m_hFile, nBlock * FILE_BUFFER_SIZE, NULL, FILE_BEGIN) != ~0);
        m_nBlkCur = nBlock;

		DWORD dwRead;
		if (!ReadFile(m_hFile, m_pbBuffer, FILE_BUFFER_SIZE, &dwRead, NULL) || dwRead == 0)
        {
			return false;
        }

        VerifyXipSignature(m_pbBuffer, dwRead);
        ++m_nBlkCur;

		m_cbBuffer = (int)dwRead;
	}

	m_ibRead = nPos % FILE_BUFFER_SIZE;

	return true;
}

int CFileBuffer::Read(void* pv, int cb)
{
	if (m_pbBuffer == NULL)
	{
        for (;;)
        {
    		m_pbBuffer = (BYTE*)VirtualAlloc(NULL, FILE_BUFFER_SIZE, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);
            if (m_pbBuffer)
            {
                break;
            }
            ASSERT( !"Failed to create fileBuffer\n" );
        }
	}

	int cbTotalRead = 0;
	int cbRead = 0;
	BYTE* pb = (BYTE*)pv;

	while (cb > 0)
	{
		if (m_ibRead < m_cbBuffer)
		{
			cbRead = m_cbBuffer - m_ibRead;
			if (cbRead > cb)
				cbRead = cb;

			CopyMemory(pb, m_pbBuffer + m_ibRead, cbRead);

			pb += cbRead;
			cb -= cbRead;
			ASSERT(cb >= 0);

			m_ibRead += cbRead;
			cbTotalRead += cbRead;
		}

		if (m_ibRead == m_cbBuffer)
		{
			DWORD dwRead = 0;
			if (!ReadFile(m_hFile, m_pbBuffer, FILE_BUFFER_SIZE, &dwRead, NULL))
            {
                ASSERT(FALSE && "Unable to read from XIP!");
                FileProtectionError();
                return -1;
            }

            if (dwRead == 0)
            {
                return -1;
            }
				
            VerifyXipSignature(m_pbBuffer, dwRead);
            ++m_nBlkCur;

			m_cbBuffer = (int)dwRead;
			m_ibRead = 0;
		}
	}

	return cbTotalRead;
}

CXipFile c_rgXipFile[20];
int c_nXipFileCount = 0;

CXipFile* CXipFile::LoadXIP(const TCHAR* szURL, bool bSync/*=false*/)
{
	TCHAR szBuf [MAX_PATH];

    if (szURL[0] && szURL[1] != ':')
    {
        // REVIEW: all xip files must be on y:\ if szURL is relative
        _tcscpy(szBuf, _T("y:/"));
    }
    else
    {
        szBuf[0] = 0;
    }

    _tcscat(szBuf, szURL);

	{
		TCHAR szDirPath [MAX_PATH];
		CleanFilePath(szDirPath, szBuf);
		TCHAR* pch = _tcsrchr(szDirPath, _T('.'));
		ASSERT(pch != NULL);
		*pch = 0;

		for (int i = 0; i < c_nXipFileCount; i += 1)
		{
			if (_tcsicmp(szDirPath, c_rgXipFile[i].m_szDirPath) == 0)
			{
//				DbgPrint("\002XIP %s is already loaded!\n", szURL);
				
				c_rgXipFile[i].m_cacheTime = XAppGetNow();
				if (c_rgXipFile[i].m_bLoaded && c_rgXipFile[i].m_nVertexBufferCount > 0 && c_rgXipFile[i].m_rgMeshBuffer[0].m_pVertexBuffer == NULL)
					c_rgXipFile[i].ReloadMeshBuffers();

				return &c_rgXipFile[i];
			}
		}
	}

//	DbgPrint("\003LoadXIP: %s\n", szURL);

	ASSERT(c_nXipFileCount < 20);
	CXipFile* pXipFile = &c_rgXipFile[c_nXipFileCount];

	if (!pXipFile->Open(szBuf))
    {
		return NULL;
    }

	c_nXipFileCount += 1;

	if (bSync)
	{
		pXipFile->Load();
	}
	else
	{
		DWORD dwThreadID;
		HANDLE hThread = CreateThread(NULL, 0, CXipFile::StartLoadThread, pXipFile, 0, &dwThreadID);
		if (hThread)
        {
            CloseHandle(hThread);
        }
        else
        {
            CXipFile::StartLoadThread(pXipFile);
        }
	}

	return pXipFile;
}

bool FindInXIPAndDetach(const TCHAR* szURL, BYTE*& pbContent, DWORD& cbContent)
{
	TCHAR szFilePath [MAX_PATH];
	CleanFilePath(szFilePath, szURL);

	for (int i = c_nXipFileCount - 1; i >= 0; i -= 1)
	{
		if (c_rgXipFile[i].m_bLocked || !c_rgXipFile[i].m_bLoaded)
			continue;

		int nObject = c_rgXipFile[i].Find(szFilePath);
		if (nObject >= 0 && c_rgXipFile[i].m_objects[nObject] != NULL)
		{
			pbContent = (BYTE*)c_rgXipFile[i].m_objects[nObject];
			cbContent = c_rgXipFile[i].m_filedata[nObject].m_dwSize;
			c_rgXipFile[i].m_objects[nObject] = NULL;
			return true;
		}
	}

	return false;
}

void* FindObjectInXIP(const TCHAR* szURL, const TCHAR* szFilename, int nType/*=-1*/)
{
	TCHAR szFilePath [MAX_PATH];
	CleanFilePath(szFilePath, szURL);

	for (int i = c_nXipFileCount - 1; i >= 0; i -= 1)
	{
		if (c_rgXipFile[i].m_bLocked || !c_rgXipFile[i].m_bLoaded)
        {
			continue;
        }

		if(i == 0 && nType == XIP_TYPE_TEXTURE)
		{
			TCHAR szBuf [MAX_PATH];
			TCHAR szBufName [MAX_PATH];
			_tcscpy(szBufName, szFilename);
			_tcscpy(_tcsrchr(szBufName, _T('.')) + 1, _T("xbx"));
			_tcscpy(szBuf, g_szAppDir);
			_tcscpy(szBuf, szBufName);
			CleanFilePath(szFilePath, szBuf);
			void* pObject = c_rgXipFile[i].FindObject(szFilePath, nType);

			if (pObject != NULL)
				return pObject;
		}
		else
		{
			void* pObject = c_rgXipFile[i].FindObject(szFilePath, nType);

			if (pObject != NULL)
				return pObject;
		}
	}

	return NULL;
}

////////////////////////////////////////////////////////////////////////////

CXipFile::CXipFile()
{
	m_szXipFileName = NULL;
	m_szDirPath = NULL;
	m_bLoaded = false;
	m_bLocked = false;
	m_bReloading = false;

	ZeroMemory(m_rgMeshBuffer, sizeof (m_rgMeshBuffer));
	m_nVertexBufferCount = 0;
	m_nIndexBufferCount = 0;
}

CXipFile::~CXipFile()
{
	delete [] m_szXipFileName;
	m_szXipFileName = NULL;

	delete [] m_szDirPath;
	m_szDirPath = NULL;

	delete [] m_filedata;
	m_filedata = NULL;

	delete [] m_directory;
	m_directory = NULL;

	delete [] m_names;
	m_names = NULL;

	DeleteMeshBuffers();

	ZeroMemory(m_rgMeshBuffer, sizeof (m_rgMeshBuffer));
	m_nVertexBufferCount = 0;
	m_nIndexBufferCount = 0;
}

bool CXipFile::Open(const TCHAR
					* szXipFileName)
{
/*
	HANDLE hFile;
	if ((hFile = XAppCreateFile(szXipFileName, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN | FILE_FLAG_NO_BUFFERING, NULL)) == INVALID_HANDLE_VALUE)
	{
		DbgPrint(_T("\001CXipFile::Open (%s) failed %d\n"), szXipFileName, GetLastError());
		return false;
	}

	m_file.SetFile(hFile);
*/
	m_szXipFileName = new TCHAR [_tcslen(szXipFileName) + 1];
	_tcscpy(m_szXipFileName, szXipFileName);

	TCHAR szDirPath [MAX_PATH];
	CleanFilePath(szDirPath, szXipFileName);

	TCHAR* pch = _tcsrchr(szDirPath, _T('.'));
	ASSERT(pch != NULL);
	*pch = 0;

	pch = _tcsrchr(szDirPath, _T('\\'));
	if (pch == NULL)
		pch = szDirPath;
	else
		pch += 1;

	if (_tcsicmp(pch, _T("default")) == 0)
	{
		if (pch > szDirPath)
			pch -= 1;
		*pch = 0;
	}

	m_szDirPath = new TCHAR [_tcslen(szDirPath) + 1];
	_tcscpy(m_szDirPath, szDirPath);

	return true;
}

DWORD CALLBACK CXipFile::StartLoadThread(LPVOID pvContext)
{
	CXipFile *pThis = (CXipFile*)pvContext;

	if (pThis->m_bReloading)
		pThis->ReloadMeshBuffers();
	else
		ASSERT(pThis->Load());

	return 0;
}

bool CXipFile::Load()
{
#ifdef _DEBUG
	TCHAR szDirPath [MAX_PATH];
	DWORD ticks = GetTickCount ();
#endif

	HANDLE hFile;
//	XCALCSIG_SIGNATURE sig;
	

	if ((hFile = XAppCreateFile(m_szXipFileName, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN | FILE_FLAG_NO_BUFFERING, NULL)) == INVALID_HANDLE_VALUE)
	{
		DbgPrint("\001CXipFile::Open (%s) failed %d\n", m_szXipFileName, GetLastError());
		return false;
	}



	m_file.SetFile(m_szXipFileName, hFile);
	if (!m_file.Read(&m_header, sizeof (XIPHEADER)))
		return false;

	if (m_header.m_dwMagic != XIP_MAGIC)
	{
#ifdef _DEBUG
		DbgPrint("\001CXipFile::Open (%s.xip) not a valid XIP file!\n", szDirPath);
#endif
		return false;
	}

	m_filedata = new FILEDATA [m_header.m_wFileCount];
	if (!m_file.Read(m_filedata, m_header.m_wFileCount * sizeof (FILEDATA)))
		return false;
	m_directory = new FILENAME [m_header.m_wNameCount];
	if (!m_file.Read(m_directory, m_header.m_wNameCount * sizeof (FILENAME)))
		return false;


	{
		int cbNames = m_header.m_dwDataStart - (sizeof (XIPHEADER) + m_header.m_wFileCount * sizeof (FILEDATA) + m_header.m_wNameCount * sizeof (FILENAME));
		m_names = new TCHAR [cbNames];
		if (!m_file.Read(m_names, cbNames))
			return false;


	}

	ASSERT(GetFileSize(m_file.m_hFile, NULL) == m_header.m_dwDataStart + m_header.m_dwDataSize);

	CreateObjects();

	m_bLoaded = true;

	return true;
}

LPDIRECT3DTEXTURE8 ReadTexture(CFileBuffer& file, int nBytes)
{
	BYTE* pbContent = new BYTE[nBytes];
	file.Read(pbContent, nBytes);

	const XPR_HEADER* pxprh = (const XPR_HEADER*)pbContent;
	if (pxprh->dwMagic == XPR_MAGIC_VALUE)
	{
		int cbHeaders = pxprh->dwHeaderSize - sizeof (XPR_HEADER);
		int cbData = pxprh->dwTotalSize - pxprh->dwHeaderSize;

		IDirect3DTexture8* pTexture = (IDirect3DTexture8*)D3D_AllocNoncontiguousMemory(sizeof (D3DBaseTexture));
		if (pTexture == NULL)
		{
			DbgPrint("Not enough memory to load XBX image file!\n");
			return NULL;
		}

		CopyMemory(pTexture, pbContent + sizeof (XPR_HEADER), sizeof (IDirect3DTexture8));

		BYTE* pbData = (BYTE*)D3D_AllocContiguousMemory(cbData, D3DTEXTURE_ALIGNMENT);
		if (pbData == NULL)
		{
			// TODO: Leaking pTexture!
			DbgPrint("Not enough memory to load XBX image file!\n");
			return NULL;
		}

		CopyMemory(pbData, pbContent + pxprh->dwHeaderSize, cbData);
		D3D_CopyContiguousMemoryToVideo(pbData);

		pTexture->Data = NULL;
		pTexture->Register(pbData);
		pTexture->Common |= D3DCOMMON_D3DCREATED;

		return pTexture;
	}
	else
	{
		DbgPrint("Unable to load XBX file for scene!");
		return NULL;
	}
}

void CXipFile::CreateObjects()
{
	m_bLocked = true;

	m_objects = new void* [m_header.m_wFileCount];
	ZeroMemory(m_objects, sizeof (void*) * m_header.m_wFileCount);

	for (UINT i = 0; i < m_header.m_wFileCount; i += 1)
	{
		switch (m_filedata[i].m_dwType)
		{
		default:
			m_objects[i] = GlobalAlloc(GMEM_FIXED, m_filedata[i].m_dwSize);
			m_file.Read(m_objects[i], m_filedata[i].m_dwSize);			
			
			break;

		case XIP_TYPE_MESH:
			ASSERT(FALSE); // Obsolete...
//			m_objects[i] = CreateMesh(m_hFile);
			break;

		case XIP_TYPE_MESH_REFERENCE:
			{
			/*	CMeshRef* pMeshRef = new CMeshRef;
				pMeshRef->m_pXipFile = this;
				pMeshRef->m_nMeshBuffer = m_filedata[i].m_dwDataOffset >> 24;
				ASSERT(pMeshRef->m_nMeshBuffer < MAX_MESHBUFFER);
				pMeshRef->m_nFirstIndex = m_filedata[i].m_dwDataOffset & 0x00ffffff;
				pMeshRef->m_nPrimitiveCount = m_filedata[i].m_dwSize;
				m_objects[i] = pMeshRef;*/
			}
			break;

		case XIP_TYPE_TEXTURE:
			m_objects[i] = ReadTexture(m_file, m_filedata[i].m_dwSize);
			
			break;

		case XIP_TYPE_INDEXBUFFER:
			ASSERT(m_nIndexBufferCount < MAX_MESHBUFFER);
//			ReadIndexBuffer(i, m_nVertexBufferCount);
			m_nIndexBufferCount += 1;
			break;

		case XIP_TYPE_VERTEXBUFFER:
			ASSERT(m_nVertexBufferCount < MAX_MESHBUFFER);
//			ReadVertexBuffer(i, m_nVertexBufferCount);
			m_nVertexBufferCount += 1;
			break;
		}
	}

	ASSERT(m_nVertexBufferCount == m_nIndexBufferCount);

	m_bLocked = false;
}

struct SEARCHXIP
{
	SEARCHXIP(CXipFile* pXipFile, const TCHAR* szFind)
	{
		m_names = pXipFile->m_names;
		m_szFind = szFind;
	}

	const TCHAR* m_names;
	const TCHAR* m_szFind;
};

static int __cdecl SearchXipCompare(const void *elem1, const void *elem2)
{
	const SEARCHXIP* pSearch = (const SEARCHXIP*)elem1;
	const FILENAME* pName = (const FILENAME*)elem2;
	return _tcscmp(pSearch->m_szFind, pSearch->m_names + pName->m_wNameOffset);
}

int CXipFile::Find(const TCHAR* szURL)
{
	int cchDirPath = _tcslen(m_szDirPath);

    if (_tcsncmp(szURL, m_szDirPath, cchDirPath) != 0)
        return -1;

    const TCHAR* szFile = szURL + cchDirPath;

    if (*szFile != '\\')
        return -1;

    szFile += 1;

	SEARCHXIP searchxip(this, szFile);
	FILENAME* pFileName = (FILENAME*)bsearch(&searchxip, m_directory, m_header.m_wNameCount, sizeof (FILENAME), SearchXipCompare);

	if (pFileName == NULL)
		return -1;

	return m_directory[(int)((BYTE*)pFileName - (BYTE*)m_directory) / sizeof (FILENAME)].m_wFileDataIndex;
}

void* CXipFile::FindObject(const TCHAR* szURL, int nType/*=-1*/)
{
	int nObject = Find(szURL);
    if (nObject == -1)
	{
        return NULL;
	}

    if (nType != -1 && m_filedata[nObject].m_dwType != (DWORD)nType)
	{
        return NULL;
	}

    //
    //  Bug 7092 - AddRef Textures when we give them out
    //             such that they don't get deleted
    //             when the caller is done with them.
    if(XIP_TYPE_TEXTURE == nType)
    {
        ((LPDIRECT3DTEXTURE8)m_objects[nObject])->AddRef();
    }

    return m_objects[nObject];
}

void CXipFile::DeleteMeshBuffers()
{
	ASSERT(!m_bLocked); // thread synchronization issue!

//#ifdef _DEBUG
//	TCHAR szDirPath [MAX_PATH];
//	Unicode(szDirPath, m_szDirPath, MAX_PATH);
//	DbgPrint(_T("\002DeleteMeshBuffers: %s.xip\n"), szDirPath);
//#endif

	for (int i = 0; i < MAX_MESHBUFFER; i += 1)
	{
		if (m_rgMeshBuffer[i].m_pVertexBuffer != NULL)
		{
            m_rgMeshBuffer[i].m_pVertexBuffer->Release();
            m_rgMeshBuffer[i].m_pVertexBuffer = NULL;
		}

		if (m_rgMeshBuffer[i].m_pIndexBuffer != NULL)
		{
            m_rgMeshBuffer[i].m_pIndexBuffer->Release();
            m_rgMeshBuffer[i].m_pIndexBuffer = NULL;
		}
	}
}

bool CleanupMeshCache()
{
//	DbgPrint(_T("\002CleanupMeshCache\n"));

	CXipFile* pOldOne = NULL;

	for (int i = 0; i < c_nXipFileCount; i += 1)
	{
//#ifdef _DEBUG
//		TCHAR szDirPath [MAX_PATH];
//		Unicode(szDirPath, c_rgXipFile[i].m_szDirPath, MAX_PATH);
//		DbgPrint(_T("\002\tchecking: %s.xip (%f)\n"), szDirPath, c_rgXipFile[i].m_cacheTime);
//#endif
		if (c_rgXipFile[i].m_bLocked)
		{
//			DbgPrint(_T("\002\t\tlocked\n"));
			continue;
		}

		if (!c_rgXipFile[i].m_bLoaded)
		{
//			DbgPrint(_T("\002\t\tnot loaded\n"));
			continue;
		}

		if (c_rgXipFile[i].m_nVertexBufferCount == 0)
		{
//			DbgPrint(_T("\002\t\tno vertex buffers\n"));
			continue;
		}

		if (c_rgXipFile[i].m_rgMeshBuffer[0].m_pVertexBuffer == NULL)
		{
//			DbgPrint(_T("\002\t\tunloaded\n"));
			continue;
		}

		if (pOldOne == NULL || c_rgXipFile[i].m_cacheTime < pOldOne->m_cacheTime)
			pOldOne = &c_rgXipFile[i];
	}

	if (pOldOne == NULL)
		return false;

	pOldOne->DeleteMeshBuffers();

	return true;
}

/*void CXipFile::ReadIndexBuffer(int nFileIndex, int nIndexBuffer)
{
	CMeshBuffer* pMeshBuffer = &m_rgMeshBuffer[nIndexBuffer];

	XAppCreateIndexBuffer(m_filedata[nFileIndex].m_dwSize, D3DUSAGE_DYNAMIC, D3DFMT_INDEX16, D3DPOOL_DEFAULT, &pMeshBuffer->m_pIndexBuffer);

	BYTE* indices;
#ifdef _XBOX
	const DWORD dwLockFlags = D3DLOCK_DISCARD | D3DLOCK_NOFLUSH;
#else
	const DWORD dwLockFlags = D3DLOCK_DISCARD;
#endif
	VERIFYHR(pMeshBuffer->m_pIndexBuffer->Lock(0, m_filedata[nFileIndex].m_dwSize, (BYTE**)&indices, dwLockFlags));
	m_file.Read(indices, m_filedata[nFileIndex].m_dwSize);
	VERIFYHR(pMeshBuffer->m_pIndexBuffer->Unlock());

	pMeshBuffer->m_nIndexCount = m_filedata[nFileIndex].m_dwSize /  sizeof (WORD);
}

void CXipFile::ReadVertexBuffer(int nFileIndex, int nVertexBuffer)
{
	CMeshBuffer* pMeshBuffer = &m_rgMeshBuffer[nVertexBuffer];

	int nVertexCount;
	DWORD fvf;

	m_file.Read(&nVertexCount, sizeof (int));
	m_file.Read(&fvf, sizeof (DWORD));
	
	pMeshBuffer->m_nVertexStride = (m_filedata[nFileIndex].m_dwSize - 8) / nVertexCount;

	XAppCreateVertexBuffer(m_filedata[nFileIndex].m_dwSize - 8, D3DUSAGE_DYNAMIC, fvf, D3DPOOL_DEFAULT, &pMeshBuffer->m_pVertexBuffer);

	
	BYTE* verts;
#ifdef _XBOX
	const DWORD dwLockFlags = D3DLOCK_DISCARD | D3DLOCK_NOFLUSH;
#else
	const DWORD dwLockFlags = D3DLOCK_DISCARD;
#endif
	VERIFYHR(pMeshBuffer->m_pVertexBuffer->Lock(0, 0, &verts, dwLockFlags));
	m_file.Read(verts, m_filedata[nFileIndex].m_dwSize - 8);
	VERIFYHR(pMeshBuffer->m_pVertexBuffer->Unlock());

	pMeshBuffer->m_fvf = fvf;
	pMeshBuffer->m_nVertexCount = nVertexCount;
}*/

void CXipFile::ReloadMeshBuffers()
{
//#ifdef _DEBUG
//	TCHAR szDirPath [MAX_PATH];
//	Unicode(szDirPath, m_szDirPath, MAX_PATH);
//	DbgPrint(_T("\002ReloadMeshBuffers: %s.xip\n"), szDirPath);
//#endif

	ASSERT(!m_bLocked);
	m_bLocked = true;

	int nIndexBuffer = 0;
	int nVertexBuffer = 0;

	for (UINT i = 0; i < m_header.m_wFileCount; i += 1)
	{
		switch (m_filedata[i].m_dwType)
		{
		case XIP_TYPE_INDEXBUFFER:
			ASSERT(nIndexBuffer < m_nIndexBufferCount);
			m_file.Seek(m_header.m_dwDataStart + m_filedata[i].m_dwDataOffset);
//			ReadIndexBuffer(i, nIndexBuffer);
			nIndexBuffer += 1;
			break;

		case XIP_TYPE_VERTEXBUFFER:
			ASSERT(nVertexBuffer < m_nVertexBufferCount);
			m_file.Seek(m_header.m_dwDataStart + m_filedata[i].m_dwDataOffset);
//			ReadVertexBuffer(i, nVertexBuffer);
			nVertexBuffer += 1;
			break;
		}
	}

	ASSERT(nIndexBuffer == m_nIndexBufferCount);
	ASSERT(nVertexBuffer == m_nVertexBufferCount);

	m_bLocked = false;
	m_bReloading = false;
}

void CXipFile::Reload()
{
	ASSERT(!m_bReloading);

	m_bReloading = true;
	DWORD dwThreadID;
	HANDLE hThread = CreateThread(NULL, 0, CXipFile::StartLoadThread, this, 0, &dwThreadID);
    if (hThread)
    {
        CloseHandle(hThread);
    }
    else
    {
        StartLoadThread(this);
    }
}

bool CXipFile::IsUnloaded() const
{
	if (!m_bLoaded)
		return false;

	if (m_bReloading)
		return false;

	if (m_nVertexBufferCount == 0)
		return false;

	if (m_rgMeshBuffer[0].m_pVertexBuffer != NULL)
		return false;

	return true;
}

bool CXipFile::IsReloading() const
{
	return m_bReloading;
}

//void CMeshRef::Render(bool bSetFVF/*=true*/)
/*{
	ASSERT(m_nMeshBuffer < m_pXipFile->m_nVertexBufferCount);
	CMeshBuffer* pMeshBuffer = &m_pXipFile->m_rgMeshBuffer[m_nMeshBuffer];

	m_pXipFile->m_cacheTime = XAppGetNow();

	if (m_pXipFile->IsReloading())
		return;

	if (pMeshBuffer->m_pVertexBuffer == NULL)
	{
		m_pXipFile->Reload();
		return;
	}

	if (bSetFVF)
		XAppSetVertexShader(GetFixedFunctionShader(pMeshBuffer->m_fvf));

	if (m_nPrimitiveCount > 800 && !g_bEdgeAntialiasOverride) {
		XAppSetRenderState(D3DRS_EDGEANTIALIAS, FALSE);
		XAppSetRenderState(D3DRS_MULTISAMPLEANTIALIAS, TRUE);
		//XAppSetRenderState(D3DRS_MULTISAMPLETYPE, D3DMULTISAMPLE_4_SAMPLES_MULTISAMPLE_GAUSSIAN);
	}

	XAppSetStreamSource(0, pMeshBuffer->m_pVertexBuffer, pMeshBuffer->m_nVertexStride);
	XAppSetIndices(pMeshBuffer->m_pIndexBuffer, 0);

	XAppDrawIndexedPrimitive(D3DPT_TRIANGLELIST, 0, pMeshBuffer->m_nVertexCount, m_nFirstIndex, m_nPrimitiveCount);
}

DWORD CMeshRef::GetFVF() const
{
	ASSERT(m_nMeshBuffer < m_pXipFile->m_nVertexBufferCount);
	return m_pXipFile->m_rgMeshBuffer[m_nMeshBuffer].m_fvf;
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\xodash\XODashMain\AutomationMsg.h ===
//-------------------------------------------------------------
// Copyright (c) Microsoft Corporation.  All rights reserved
// Author: Natalyp
//-------------------------------------------------------------

#pragma once
#include "std.h"
#include "XBInput.h"

enum  eAutoMessage
{
	eControllerInput=1,  // Substitute pereferal input when Automation simulator is connected to the Dash
	eHeartBit,    // mechanism to maintain connection open. Only one simulataneous client is allowed to connect
	// to the Dash. Although it's valid to set multiple bits in XBGAMEPAD structure to simulate input from a 
	// a number of controllers simulteneously
	eNullMsg // for server only, not to be used by client
};


class CSocket;

class CAutomationMsg
{
	friend CSocket;
public:

    explicit CAutomationMsg( BYTE byMessageId = 0 ) : m_byMessageId( byMessageId ) {}
    ~CAutomationMsg() {}
    inline int  GetMaxSize() const { return sizeof(*this); }
	int GetSize();
    inline int GetId() const      { return m_byMessageId; }
	void Dump(bool bAll =true);
	void SetGamepadData(XBGAMEPAD* pGamePad);
	
private:

	char m_byMessageId;
	union Data
	{
		XBGAMEPAD xbGamepad;
	} m_Data;
	bool IsFiltered ()
	{
		if (eControllerInput == m_byMessageId)
		{
			return false;
		}
		return true;
	}
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\xodash\XODashMain\AutomationMsg.cpp ===
//-------------------------------------------------------------
// Copyright (c) Microsoft Corporation.  All rights reserved
// Author: Natalyp
//-------------------------------------------------------------
#include "std.h"
#include "AutomationMsg.h"


//-------------------------------------------------------------
// Function name	: CAutomationMsg::Dump
// Description	    : dump all the data
// Return type		: void 
// Argument         : bool bAll/*=true*/
//-------------------------------------------------------------
void CAutomationMsg::Dump(bool bAll/*=true*/)
{
	switch (m_byMessageId)
	{
		case eControllerInput:
			DbgPrint("CAutomationMsg: ControllerInput message\n==============================\n");			
			DbgPrint("wLastButtons=[%d]\n", m_Data.xbGamepad.wLastButtons);
			DbgPrint("wPressedButtons=[%d]\n", m_Data.xbGamepad.wPressedButtons);
			DbgPrint("==============================\n");			
			break;

		case eHeartBit:
			DbgPrint("CAutomationMsg: HeartBit message\n==============================\n");
			break;
		default:
			// unknown message
			ASSERT(false);
	}
}


//-------------------------------------------------------------
// Function name	: CAutomationMsg::GetSize
// Description	    : get the actual size of the message
// Return type		: int 
//-------------------------------------------------------------
int CAutomationMsg::GetSize()
{
	switch( m_byMessageId )
    {
	case eControllerInput:
		return sizeof(XBGAMEPAD)+ sizeof(m_byMessageId);
		break;
	case eHeartBit:
		return sizeof(m_byMessageId);
		break;
	default: 
		// unknown message 
		ASSERT(false);
		return -1;
		break;
	}
}


//-------------------------------------------------------------
// Function name	: CAutomationMsg::SetGamepadData
// Description	    : 
// Return type		: void 
// Argument         : XBGAMEPAD* pGamePad
//-------------------------------------------------------------
void CAutomationMsg::SetGamepadData(XBGAMEPAD* pGamePad)
{
	// only this message includes valid data for the gamepad structure
	ASSERT(m_byMessageId == eControllerInput);
	*pGamePad = m_Data.xbGamepad;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\xodash\XODashMain\cellwallscene.cpp ===
#include "std.h"

#include "Scene.h"
#include "utilities.h"
#include "XGMath.h"
#include "TGL.h"
#include "globals.h"
#include "IniFile.h"
#include "SceneNavigator.h"
#include "XBInput.h"

// static member declarations
void* CCellWallScene::m_pVideoMemCellWall    = NULL;
void* CCellWallScene::m_pVideoMemSelect      = NULL;
void* CCellWallScene::m_pVideoMemBack        = NULL;
TG_Shape* CCellWallScene::s_pCellWallSphere	 = NULL;
TG_Shape* CCellWallScene::s_pBackButton		 = NULL;
TG_Shape* CCellWallScene::s_pSelectButton	 = NULL;
CText* CCellWallScene::m_pSelectText         = NULL;
CText* CCellWallScene::m_pBackText           = NULL;

CCellWallScene::CCellWallScene():
	CScene()
{
	bRenderSelect		 = true;
	bRenderBack			 = true;

	m_field = D3DX_PI / 4.0f;
    m_now = 0.f;
}

CCellWallScene::~CCellWallScene()
{
	Cleanup();
}

HRESULT CCellWallScene::Initialize(char* pUrl, char* pButtonTextUrl,  eSceneId eCurSceneId, bool bAutoTest)
{
	HRESULT hr = S_OK;
    
    do {

        // Load Cell Wall if not already loaded
        if(CCellWallScene::s_pCellWallSphere == NULL)
        {
            hr = LoadFromXBG( g_pd3dDevice, XBG_PATH_ANSI"cellwall.xbg", "cellwall" );
            BREAKONFAIL(hr, "CCellWallScene::Cannot load cellwall.xbg");

            CCellWallScene::s_pCellWallSphere = m_pRoot;
            m_pRoot = NULL;
            CCellWallScene::m_pVideoMemCellWall = m_pVideoMem;
            m_pVideoMem = NULL;
        }

        // Load Back Button if not already loaded 
        if(CCellWallScene::s_pBackButton == NULL)
        {
            hr = LoadFromXBG( g_pd3dDevice, XBG_PATH_ANSI"backbutton.xbg", "backbutton" );
            BREAKONFAIL(hr, "CCellWallScene::Cannot load backbutton.xbg");

            CCellWallScene::s_pBackButton = m_pRoot;
            m_pRoot = NULL;
            CCellWallScene::m_pVideoMemBack = m_pVideoMem;
            m_pVideoMem = NULL;

		    ASSERT(m_pButtons.size() == 1);
		    m_pButtons.clear();

            ASSERT( m_pTexts.size() == 1 );
            CCellWallScene::m_pBackText = m_pTexts[0];
            m_pTexts.clear();
        }

        // Load Select Button if not already loaded
        if(CCellWallScene::s_pSelectButton == NULL)
        {
            hr = LoadFromXBG( g_pd3dDevice, XBG_PATH_ANSI"selectbutton.xbg", "selectbutton" );
            BREAKONFAIL(hr, "CCellWallScene::Cannot load selectbutton.xbg");

            CCellWallScene::s_pSelectButton = m_pRoot;
            m_pRoot = NULL;
            CCellWallScene::m_pVideoMemSelect = m_pVideoMem;
            m_pVideoMem = NULL;
		
		    ASSERT(m_pButtons.size() == 1);
		    m_pButtons.clear();

            ASSERT( m_pTexts.size() == 1 );
            CCellWallScene::m_pSelectText = m_pTexts[0];
            m_pTexts.clear();
        }

        // Initialize the scene
        hr = CScene::Initialize(pUrl, pButtonTextUrl, eCurSceneId, true);
        BREAKONFAIL(hr, "CScene::Initialize fail to init CCellWallScene");
    } while(0);
	if (FAILED(hr))
	{
		Cleanup();
	}

	return hr;
}

#if DEBUG
static bool CellWallMove = false;
#endif //DEBUG

HRESULT CCellWallScene::FrameMove(XBGAMEPAD& GamepadInput, float elapsedTime )
{
    if ( s_pBackButton )
        s_pBackButton->FrameMove( elapsedTime );

    if ( s_pSelectButton )
        s_pSelectButton->FrameMove( elapsedTime );

    if ( s_pCellWallSphere )
        s_pCellWallSphere->FrameMove( elapsedTime );

    HRESULT hr = CScene::FrameMove( GamepadInput, elapsedTime );
	
	if(hr == XBAPPWRN_SCENE_CHANGED)
	{ // scene is destroyed, do not touch private data
		return hr;
	}

	CellWallRotate(GamepadInput);
	return hr;
}



void CCellWallScene::CellWallRotate(XBGAMEPAD& GamepadInput)
{
	m_dwFrameTick = GetTickCount();
    float oldNow = (float)m_now;
	m_now = m_dwFrameTick / 1000.0;

#if DEBUG
    // Support for testing to stop the back sphere from rotating
    if(GamepadInput.bPressedAnalogButtons[XINPUT_GAMEPAD_LEFT_TRIGGER] &&
       GamepadInput.bPressedAnalogButtons[XINPUT_GAMEPAD_RIGHT_TRIGGER])
	{
        CellWallMove = !CellWallMove;
	}

    if(CellWallMove)
    {
        m_now = 0.0;
    }
#endif //DEBUG
   

	float fRpm = .75f;

	float fAngle = sinf((float) (m_now * D3DX_PI * fRpm / 60.0f)) * m_field / 2.0f;
  	float fOldAngle = sinf((float) (oldNow * D3DX_PI * fRpm / 60.0f)) * m_field / 2.0f;


	CCellWallScene::s_pCellWallSphere->LocalRotateZ( fAngle - fOldAngle);
}


HRESULT CCellWallScene::Render( DWORD flags )
{
	// Render the Cell Wall
	ASSERT( CCellWallScene::s_pCellWallSphere );
    if ( CCellWallScene::s_pCellWallSphere )
	{
		if ( m_Light.Type != 0 )
		{
		   g_pd3dDevice->SetRenderState( D3DRS_LIGHTING, TRUE );
		   g_pd3dDevice->SetLight( 0, &m_Light );
		}
		else
		{
			g_pd3dDevice->SetRenderState(D3DRS_AMBIENT, 0x002f2f2f);
		}
		m_Camera.SetUp(g_pd3dDevice);
		CCellWallScene::s_pCellWallSphere->Render();

		// Render the A Button
		if( bRenderSelect )
		{
			ASSERT( CCellWallScene::s_pSelectButton );
			if ( CCellWallScene::s_pSelectButton )
            {
				CCellWallScene::s_pSelectButton->Render();
                CCellWallScene::m_pSelectText->Render( flags );
            }
		}
	
		// Render the B Button
		if( bRenderBack )
		{
			ASSERT( CCellWallScene::s_pBackButton );
			if ( CCellWallScene::s_pBackButton )
            {
				CCellWallScene::s_pBackButton->Render();
                CCellWallScene::m_pBackText->Render( flags );
            }
		}
	}

    // Render the main Scene
	CScene::Render( flags );

	return S_OK;
}

void CCellWallScene::AutoTest(eAutoTestData eState)
{
	switch(eState)
	{
	case eSceneInit:
		DbgPrint("\nAUTO:CELLWALL, A_BUTTON=%d, B_BUTTON=%d\n",bRenderSelect, bRenderBack);
		break;
	}
}

void CCellWallScene::AutoTest(XBGAMEPAD& GamepadInput)
{

}

HRESULT CCellWallScene::Cleanup()
{
	HRESULT hr = S_OK;

	CScene::Cleanup();

	return hr;
}

void CCellWallScene::RenderSelect(bool renderState)
{
	bRenderSelect = renderState;
}

void CCellWallScene::RenderBack(bool renderState)
{
	bRenderBack = renderState;
}

void CCellWallScene::HideObject(const char *pName)
{
    TG_Shape* pObject = m_pRoot->FindObject(pName);
    if ( pObject )
        pObject->setVisible(false);
}

void CCellWallScene::HideText(const char *pName)
{
	int nIndex = FindTextObjForShape(pName);
	CText *pInputText = m_pTexts[nIndex];
	pInputText->SetText(_T(""));
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\xodash\XODashMain\dialog.h ===
#ifndef DIALOG_H
#define DIALOG_H
/*************************************************************************************************
Dialog.h			: Dialog headers.. There are no current versions that take anything not from
                        a string table.  We might want to change that if we end up formatting strings
                        
Creation Date		: 1/9/2002 6:04:23 PM
Library				: .lib
Copyright Notice	: (C) 2000 Microsoft
Author				: Heidi Gaertner
//-------------------------------------------------------------------------------------------------
Notes				: 
//*************************************************************************************************/
#include "MsgDialog.h"


// This version of the dialog has just an OK button, and an error message
HRESULT RunOKDlg( long ErrorID );

// Set textID, not an error
HRESULT RunOKDlg( const TCHAR* pMessageID, const TCHAR* pOKStrID = _T("OK") );


HRESULT RunYesNoDlg( const TCHAR* pMessageID, const TCHAR* pYESStrID = _T("YES"), 
                   const TCHAR* pNoStrID = _T("NO"), bool bUseBigButtons = 0 );
HRESULT RunProgressDlg( const TCHAR* pMessageID, ProgressFunction pFunction, const TCHAR* pCancelButtonStrID = _T("CANCEL") );
HRESULT RunWaitCursor( const TCHAR* pMessageID, WaitFunction pFunction, const TCHAR* pCancelButtonStrID = _T("CANCEL") );



//*************************************************************************************************/
#endif  // end of file ( Dialog.h )
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\xodash\XODashMain\dialog.cpp ===
/*************************************************************************************************\
CMsgDialog.cpp		: Implementation of the CMsgDialog and the CProgress Dialog
Creation Date		: 1/8/2002 11:43:08 AM
Copyright Notice	: (C) 2000 Microsoft
Author				: Heidi Gaertner
//-------------------------------------------------------------------------------------------------
Notes				: 
\*************************************************************************************************/
#include "std.h"
#include "MsgDialog.h"
#include "XOConst.h"
#include "XBInput.h"
#include "SmartObject.h"
#include "tgl.h"
#include "SceneNavigator.h"
#include "globals.h"
#include "XODash.h"
#include "Dialog.h"

const TCHAR* FindErrorStrID(HRESULT hrError )
{
    // see if it's local, if so 
    // we could change this to be lots faster
    for ( int i = 0; i < ERROR_STR_COUNT; i++ )
    {
        if ( ErrorStringIDs[i].m_hrError == hrError )
        {
            // get the error out of the locale file
            return ErrorStringIDs[i].m_pErrorID;
        }
    }

    // for now ASSERT that we couldn't find it
    ASSERT( !"Missing error string\n" );

    // if we haven't found it go bugger a server as soon as the API's are done
    // but for now return NULL
    return NULL;
}

HRESULT RunDialog(MSGPARAMETERS* pData)
{
	HRESULT hr = CSceneNavigator::Instance()->RunDialog(pData);
	hr = g_pXBApp->Run();
	CSceneNavigator::Instance()->CleanupDialog();
	return hr;
}




HRESULT RunOKDlg( long ErrorID )
{
    return RunOKDlg( FindErrorStrID( ErrorID ), _T("OK") );
}
HRESULT RunOKDlg( const TCHAR* pMessageID, const TCHAR* pOKStrID )
{
    MSGPARAMETERS params;
    memset( &params, 0, sizeof( MSGPARAMETERS ) );
    params.m_SceneID = eMsgBoxSceneId;
    params.m_pStrMessageID = pMessageID;
    params.m_pStrCenterButtonID = pOKStrID;
    return RunDialog( &params );
}
HRESULT RunYesNoDlg( const TCHAR* pMessageID, const TCHAR* pYESStrID,
                   const TCHAR* pNoStrID, bool bUseBigButtons )
{
    MSGPARAMETERS params;
    memset( &params, 0, sizeof( MSGPARAMETERS ) );
    params.m_SceneID = eMsgBoxSceneId;
    params.m_pStrMessageID = pMessageID;
    params.m_bUseBigButtons = bUseBigButtons;
    params.m_pStrYesID = pYESStrID;
    params.m_pStrNoID = pNoStrID;
    
    return RunDialog( &params );
}
HRESULT RunProgressDlg( const TCHAR* pMessageID, ProgressFunction pFunction, const TCHAR* pCancelButtonStrID )
{
    MSGPARAMETERS params;
    memset( &params, 0, sizeof( MSGPARAMETERS ) );
    params.m_SceneID = eProgressBarSceneId;
    params.m_pStrMessageID = pMessageID;
    params.m_pFunction = pFunction;
    params.m_pStrCenterButtonID = pCancelButtonStrID;
    
    return RunDialog( &params );

}

HRESULT RunWaitCursor( const TCHAR* pMessageID, WaitFunction pFunction, const TCHAR* pCancelButtonStrID )
{
    MSGPARAMETERS params;
    memset( &params, 0, sizeof( MSGPARAMETERS ) );
    params.m_SceneID = pMessageID ? eConnectAnim : eAnimWait;
    params.m_pStrMessageID = pMessageID;
    params.m_pWaitFunction = pFunction;
    params.m_pStrCenterButtonID = pCancelButtonStrID;
    
    return RunDialog( &params );

}


//*************************************************************************************************
// end of file ( CMsgDialog.cpp )
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\xodash\XODashMain\InputHandle.h ===
class CInputHandle
{
public: 
	CInputHandle(): m_bDirty(false), m_nCurLen(MAX_INPUT_TEXT_SIZE) {}
	inline void SetInputText(const TCHAR* szSource);
	inline void SetInputMaxLength(size_t nLen);
	inline size_t GetInputMaxLength() { return m_nCurLen;}
	inline void ResetInputText() {ZeroMemory(m_szBuffer,(MAX_INPUT_TEXT_SIZE+1)*sizeof(TCHAR)); m_bDirty = false; m_nCurLen = MAX_INPUT_TEXT_SIZE;}
	inline bool Empty() {return (_tcslen(m_szBuffer) == 0);}
	inline bool IsNewInput(){return m_bDirty;}
	inline const TCHAR* GetInputText() { return m_szBuffer;}
	void Dirty(bool bDirty) { m_bDirty = bDirty;}
private:
	TCHAR m_szBuffer[MAX_INPUT_TEXT_SIZE+1];
	size_t m_nCurLen;
	bool m_bDirty;
};

void CInputHandle::SetInputText(const TCHAR* szSource)
{
	ASSERT(szSource && _tcslen(szSource) <= m_nCurLen );
	if(szSource)
	{
		ZeroMemory(m_szBuffer,(MAX_INPUT_TEXT_SIZE+1)*sizeof(TCHAR) );
		_tcsncpy(m_szBuffer, szSource, min(_tcslen(szSource), m_nCurLen));
	}

}

void CInputHandle::SetInputMaxLength(size_t nLen) 
{ 
	nLen <= MAX_INPUT_TEXT_SIZE? m_nCurLen = nLen: m_nCurLen = MAX_INPUT_TEXT_SIZE; 
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\xodash\XODashMain\main.cpp ===
#include "std.h"
#include "XODash.h"


XOApplication  theApp;
void __cdecl main()
{
	HRESULT hr = theApp.Create();
	if(FAILED(hr))
	{
		DbgPrint("main - fail to Initialize the app, hr = 0x%x\n. Aborting execution",hr);
		theApp.Destroy();
		return;
	}
	while (1)
	{
		theApp.Run();
	}

	theApp.Destroy();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\xodash\XODashMain\NavigationExit.cpp ===
ExitPoint CSceneNavigator::m_ExitPoint[] =
{
	{XLD_LAUNCH_DASHBOARD_NETWORK_CONFIGURATION, eNTS_StatusId, eNTS_Status06},
	{XLD_LAUNCH_DASHBOARD_NEW_ACCOUNT_SIGNUP, eNullSceneId, eNullButtonId},
	{XLD_LAUNCH_DASHBOARD_NEW_ACCOUNT_SIGNUP, eNullSceneId, eNullButtonId},
	{XLD_LAUNCH_DASHBOARD_NEW_ACCOUNT_SIGNUP, eNullSceneId, eNullButtonId},
	{XLD_LAUNCH_DASHBOARD_MESSAGE_SERVER_INFO, eNullSceneId, eNullButtonId},
	{XLD_LAUNCH_DASHBOARD_POLICY_DOCUMENT, eNullSceneId, eNullButtonId},
	{XLD_LAUNCH_DASHBOARD_ONLINE_MENU, eNullSceneId, eNullButtonId},
	{XLD_LAUNCH_DASHBOARD_FORCED_NAME_CHANGE, eNullSceneId, eNullButtonId},
	{XLD_LAUNCH_DASHBOARD_FORCED_BILLING_EDIT, eNullSceneId, eNullButtonId},

	{eLastSceneId, eLastSceneId, eNullButtonId},
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\xodash\XODashMain\keyboard.cpp ===
#include "std.h"
#include "Scene.h"
#include "Font.h"
#include "tgl.h"
#include "XBInput.h"
#include "SceneNavigator.h"
#include "globals.h"
#include "InputHandle.h"

CFont* GetFont(const TCHAR* szFaceName); 


static const char cszKeyboardTitle[] = "TEXT_NAMESOUNDTRACK";
static const char cszInputText[] = "TEXT_ENTRY";

static const TCHAR cszAccentTextId[]     =  _T("ACCENTS"); 
static const TCHAR cszAlphabetTextId[]   =  _T("ALPHABET");
static const TCHAR cszSymbolsTextId[]    =  _T("SYMBOLS");
static const TCHAR cszSpaceTextId[]      =  _T("SPACE");
static const TCHAR cszBackspaceTextId[]  =  _T("BACKSPACE");
static const TCHAR cszLeftShiftTextId[]  =  _T("LEFT_SHIFT");
static const TCHAR cszRightShiftTextId[] =  _T("RIGHT_SHIFT");

const float cfOffsetX = .1343f;
const float cfOffsetY = .1067f;



static eButtonId eFirstColumnButtons[] = 
{
	eDoneButtonId,    
	eShiftButtonId,   
	eCapsLockButtonId, 
	eAccentsButtonId,  
	eSymbolsButtonId
};


static eButtonId eLastRow[] = 
{
	eSpaceButtonId,
	eLessThanButtonId, 
	eGreaterThanButtonId, 
};
	

#define _nbsp		0x00a0 // non-breaking space
#define _iexcl		0x00a1 // 
#define _cent		0x00a2 // 
#define _pound		0x00a3 // 
#define _curren		0x00a4 // 
#define _yen		0x00a5 // 
#define _brvbar		0x00a6 // 
#define _sect		0x00a7 // 
#define _uml		0x00a8 // 
#define _copy		0x00a9 // 
#define _ordf		0x00aa // 
#define _laquo		0x00ab // 
#define _not		0x00ac // 
#define _shy		0x00ad // soft hyphen
#define _reg		0x00ae // 
#define _macr		0x00af // 
#define _deg		0x00b0 // 
#define _plusmn		0x00b1 // 
#define _sup2		0x00b2 // 
#define _sup3		0x00b3 // 
#define _acute		0x00b4 // 
#define _micro		0x00b5 // 
#define _para		0x00b6 // 
#define _middot		0x00b7 // 
#define _cedil		0x00b8 // 
#define _sup1		0x00b9 // 
#define _ordm		0x00ba // 
#define _raquo		0x00bb // 
#define _iquest		0x00bf // 
#define _Agrave		0x00c0 // 
#define _Aacute		0x00c1 // 
#define _Acirc		0x00c2 // 
#define _Atilde		0x00c3 // 
#define _Auml		0x00c4 // 
#define _Aring		0x00c5 // 
#define _AElig		0x00c6 // 
#define _Ccedil		0x00c7 // 
#define _Egrave		0x00c8 // 
#define _Eacute		0x00c9 // 
#define _Ecirc		0x00ca // 
#define _Euml		0x00cb // 
#define _Igrave		0x00cc // 
#define _Iacute		0x00cd // 
#define _Icirc		0x00ce // 
#define _Iuml		0x00cf // 
#define _ETH		0x00d0 // 
#define _Ntilde		0x00d1 // 
#define _Ograve		0x00d2 // 
#define _Oacute		0x00d3 // 
#define _Ocirc		0x00d4 // 
#define _Otilde		0x00d5 // 
#define _Ouml		0x00d6 // 
#define _times		0x00d7 // 
#define _Oslash		0x00d8 // 
#define _Ugrave		0x00d9 // 
#define _Uacute		0x00da // 
#define _Ucirc		0x00db // 
#define _Uuml		0x00dc // 
#define _Yacute		0x00dd // 
#define _THORN		0x00de // 
#define _szlig		0x00df // 
#define _agrave		0x00e0 // 
#define _aacute		0x00e1 // 
#define _acirc		0x00e2 // 
#define _atilde		0x00e3 // 
#define _auml		0x00e4 // 
#define _aring		0x00e5 // 
#define _aelig		0x00e6 // 
#define _ccedil		0x00e7 // 
#define _egrave		0x00e8 // 
#define _eacute		0x00e9 // 
#define _ecirc		0x00ea // 
#define _euml		0x00eb // 
#define _igrave		0x00ec // 
#define _iacute		0x00ed // 
#define _icirc		0x00ee // 
#define _iuml		0x00ef // 
#define _eth		0x00f0 // 
#define _ntilde		0x00f1 // 
#define _ograve		0x00f2 // 
#define _oacute		0x00f3 // 
#define _ocirc		0x00f4 // 
#define _otilde		0x00f5 // 
#define _ouml		0x00f6 // 
#define _divide		0x00f7 // 
#define _oslash		0x00f8 // 
#define _ugrave		0x00f9 // 
#define _uacute		0x00fa // 
#define _ucirc		0x00fb // 
#define _uuml		0x00fc // 
#define _yacute		0x00fd // 
#define _thorn		0x00fe // 
#define _yuml		0x00ff // 

#define _euro		0x20ac // euro sign

static const WORD rgkeyAlpha [] =
{
	L'1',	L'2',	L'3',	L'4',	L'5',	L'6',	L'7',	L'8',	L'9',	L'0',
	L'a',	L'b',	L'c',	L'd',	L'e',	L'f',	L'g',	L'h',	L'i',	L'j',
	L'k',	L'l',	L'm',	L'n',	L'o',	L'p',	L'q',	L'r',	L's',	L't',
	L'u',	L'v',	L'w',	L'x',	L'y',	L'z'
};

static const WORD rgkeySymbol [] =
{
	L'(',	L')',	L'&',	L'_',	L'^',		L'%',	L'\\',	L'/',	L'@',	L'#',
	L'[',	L']',	L'$',	_pound,	_euro,		_yen,	L';',	L':',	L'\'',	L'"',
	L'<',	L'>',	L'?',	L'!',	_iquest,	_iexcl,	L'-',	L'*',	L'+',	L'=',
	L'{',	L'}',	_laquo,	_raquo,	',',		L'.',	
};

static const WORD rgkeyAccent [] =
{
	L'1',		L'2',		L'3',		L'4',		L'5',		L'6',		L'7',		L'8',		L'9',		L'0',
	_agrave,	_aacute,	_acirc,		_auml,		_egrave,	_eacute,	_ecirc,		_euml,		_igrave,	_iacute,
	_icirc,		_iuml,		_ograve,	_oacute,	_ocirc,		_otilde,	_ugrave,	_uacute,	_ucirc,		_uuml,
	_yacute,	_yuml,		_ccedil,	_szlig,		_ntilde,	_aelig
};


static const WORD* rgKeys[] = {rgkeyAlpha,  rgkeySymbol, rgkeyAccent};


CKeyboardScene::CKeyboardScene():
	m_nActiveRow (0),
	m_nActiveColumn(0),
	m_nRealPosition(0),
	m_bCapitalActive(false),
	m_bAccentActive(false),
	m_bSymbolsActive(false),
	m_bShiftActive(false),
	m_nActiveCharSetIndex(0),
	m_pTitleText(NULL),
	m_pInputText(NULL),
	CScene(),
	m_bResetInput(false)

{

}

HRESULT CKeyboardScene::Initialize(char* pUrl, char* pTextButtonUrl, eSceneId eCurSceneId, bool bAutoTest)
{
	HRESULT hr = CScene::Initialize(pUrl, pTextButtonUrl, eCurSceneId, false);
	if (FAILED(hr))
	{
		DbgPrint("CScene::Initialize fail to init CKeyboardScene");
		return hr;
	}
	hr = BuildKeyboard();
	if(FAILED(hr))
	{
		DbgPrint("CScene::Initialize fail to Buildkeyboard");
		return hr;
	}

	// it should be exactly 5 rows
    ASSERT(m_pKeyboard.size() == 5);
	ASSERT((*m_pKeyboard[0]).size() == 11);
	ASSERT((*m_pKeyboard[1]).size() == 11);
	ASSERT((*m_pKeyboard[2]).size() == 11);
	ASSERT((*m_pKeyboard[3]).size() == 8);
	ASSERT((*m_pKeyboard[4]).size() == 4);

	ASSERT(countof(rgkeyAlpha) == countof(rgkeySymbol));
	ASSERT(countof(rgkeyAlpha) == countof(rgkeyAccent));

	Dump();
	AutoTest(eSceneInit);
	if(!g_szUserInput.Empty())
	{
		m_pInputText->SetText(g_szUserInput.GetInputText());
		m_pInputText->HideCursor();
		// first char typed by a user should substitute this string
		m_bResetInput = false;
	}

	return hr;
}

HRESULT CKeyboardScene::FrameMove(XBGAMEPAD& GamepadInput, float elapsedTime )
{
	HRESULT hr = S_OK;
	eInputState eCurState = GetInputState(GamepadInput);
	
	do
	{
		if(eCurState == eNoInput)
		{
			break;
		}

		// allow repetition only for up, down, left, right
		if(eCurState == eRepetitivePress)
		{
			if(
				GamepadInput.wButtons & XINPUT_GAMEPAD_DPAD_DOWN ||
				GamepadInput.fY1 == -1 ||
				GamepadInput.wButtons & XINPUT_GAMEPAD_DPAD_UP ||
				GamepadInput.fY1 == 1  ||
				GamepadInput.wButtons & XINPUT_GAMEPAD_DPAD_RIGHT ||
				GamepadInput.fX1 == 1 ||
				GamepadInput.wButtons & XINPUT_GAMEPAD_DPAD_LEFT ||
				GamepadInput.fX1 == -1 
				)
				; // continue execution and handle repetition of navigation keys
			else 
			{
				break;
			}
		}

		
		CPrimitiveScene::AutoTest(GamepadInput);
		ASSERT(m_nActiveRow >= 0 && m_nActiveColumn >= 0);
		ASSERT((size_t) m_nActiveRow < m_pKeyboard.size() && (size_t)m_nActiveColumn < (*m_pKeyboard[m_nActiveRow]).size());
	
		if(GamepadInput.wButtons & XINPUT_GAMEPAD_DPAD_DOWN ||
		GamepadInput.fY1 == -1)
		{
			DbgPrint("CKeyboardScene::FrameMove - Scene:%s, DOWN is pressed\n", SceneName[m_eSceneId]);
			MoveDown();	
			AutoTest(eChangeFocus);
            PlaySound( eKeyboardSound, eSoundHighlight ); 
		}

		if(GamepadInput.wButtons & XINPUT_GAMEPAD_DPAD_UP ||
			GamepadInput.fY1 == 1)
		{
			DbgPrint("CKeyboardScene::FrameMove - Scene:%s, UP is pressed\n", SceneName[m_eSceneId]);
			MoveUp();
			AutoTest(eChangeFocus);
            PlaySound( eKeyboardSound, eSoundHighlight ); 
		}

		if(GamepadInput.wButtons & XINPUT_GAMEPAD_DPAD_RIGHT ||
			   GamepadInput.fX1 == 1)
		{
			DbgPrint("CKeyboardScene::FrameMove - Scene:%s, RIGHT is pressed\n", SceneName[m_eSceneId]);
			MoveRight();
			AutoTest(eChangeFocus);
            PlaySound( eKeyboardSound, eSoundHighlight ); 
		}

		if(GamepadInput.wButtons & XINPUT_GAMEPAD_DPAD_LEFT ||
			GamepadInput.fX1 == -1)
		{
			DbgPrint("CKeyboardScene::FrameMove - Scene:%s, LEFT is pressed\n", SceneName[m_eSceneId]);
			MoveLeft();
			AutoTest(eChangeFocus);
            PlaySound( eKeyboardSound, eSoundHighlight ); 
		}
		
		if(GamepadInput.bAnalogButtons[ XINPUT_GAMEPAD_A ] > XINPUT_GAMEPAD_MAX_CROSSTALK)
		{
			DbgPrint("CKeyboardScene::FrameMove - Scene:%s, A is pressed\n", SceneName[m_eSceneId]);
	

			hr = PressedA();
			
			if (hr == XBAPPWRN_SCENE_CHANGED)
			{
				// scene is destroyed by now do not touch any private data 
				g_szUserInput.Dirty(true);
				return hr;
			}

           // PressedA takes care of pressing sounds
		}

		if(GamepadInput.bPressedAnalogButtons[XINPUT_GAMEPAD_WHITE])
		{
	        eSound  soundType = eSoundAPress;
            if ( g_szUserInput.Empty() )
                soundType = eSoundDisabled;

		    CText BackSpace;
			BackSpace.SetTextId(cszBackspaceTextId);
			UpdateInputText(&BackSpace);

             PlaySound( eKeyboardSound, soundType ); 
		}

		if(GamepadInput.bPressedAnalogButtons[XINPUT_GAMEPAD_BLACK])
		{
			CText Space;
			Space.SetTextId(cszSpaceTextId);
			UpdateInputText(&Space);

            PlaySound( eKeyboardSound, eSoundAPress ); 

 		}
		

		if(GamepadInput.bPressedAnalogButtons[XINPUT_GAMEPAD_LEFT_TRIGGER])
		{
			int nPos = 1;
			if(!m_bResetInput)
			{
				m_pInputText->MoveCursorHome(); 
				m_bResetInput = !m_bResetInput;
			}
			else
			{
				if ( m_pInputText->GetCursorPosition() < 1 )
                {
                    PlaySound( eKeyboardSound, eSoundDisabled );
                }
                m_pInputText->MoveCursorLeft();
            }
		}

		if(GamepadInput.bPressedAnalogButtons[XINPUT_GAMEPAD_RIGHT_TRIGGER])
		{
			
			int nPos = 1;
			int nNewPos = 0;
			if(!m_bResetInput)
			{
				m_pInputText->MoveCursorEnd();
				m_bResetInput = !m_bResetInput;
			}
			else
			{
                if ( !m_pInputText->GetText() || (unsigned long)m_pInputText->GetCursorPosition() >= _tcslen(m_pInputText->GetText() ) )
                {
                    PlaySound( eKeyboardSound, eSoundDisabled );
                }
				m_pInputText->MoveCursorRight();
			}
		}
		
		if(GamepadInput.bAnalogButtons[ XINPUT_GAMEPAD_X ] > XINPUT_GAMEPAD_MAX_CROSSTALK)
		{
			DbgPrint("CKeyboardScene::FrameMove - Scene:%s, X is pressed\n", SceneName[m_eSceneId]);
			PressedX();
		}

		if(GamepadInput.bPressedAnalogButtons[XINPUT_GAMEPAD_B] ||
			GamepadInput.wPressedButtons & XINPUT_GAMEPAD_BACK)
		{
            PlaySound( eKeyboardSound, eSoundBPress );
			CSceneNavigator::Instance()->MovePreviousScene();
			// scene is destroyed by now do not touch any private data
			g_szUserInput.Dirty(false);
			return hr;
		}
	} while(0);	

	ASSERT(m_nActiveRow >= 0 && m_nActiveColumn >= 0 && m_nRealPosition >= 0);
	ASSERT((size_t) m_nActiveRow < m_pKeyboard.size() && (size_t)m_nActiveColumn < (*m_pKeyboard[m_nActiveRow]).size());	
	
	for(size_t i = 0; i<m_pTexts.size(); i++)
	{
		m_pTexts[i]->FrameMove(elapsedTime);
	}


	return hr;
}

void CKeyboardScene::MoveUp()
{	
	(*m_pKeyboard[m_nActiveRow])[m_nActiveColumn] ->SetState(eButtonDefault);
	m_nActiveRow--;
	if(m_nActiveRow < 0)
	{
		m_nActiveRow = 4;
	}
	switch(m_nActiveRow)
	{
	case 2: 
		m_nActiveColumn = m_nRealPosition;
		break;
	case 3:
		m_nActiveColumn = min(7,m_nRealPosition);
		break;
	case 4:
		m_nRealPosition = m_nActiveColumn;
		if(m_nActiveColumn == 0)
			break;

		if(m_nActiveColumn <7)
		{
			m_nActiveColumn = 1;
			break;
		}
		// 7-8 maps to <
		if(m_nRealPosition == 7 || m_nRealPosition == 8)
		{
			m_nActiveColumn = 2;
			break;
		}
		if(m_nRealPosition == 9 || m_nRealPosition == 10)
		{
			m_nActiveColumn = 3;
			break;
		}
		ASSERT(false);
		break;
	default:
		ASSERT(m_nActiveRow == 1 || m_nActiveRow == 0);
	}
	(*m_pKeyboard[m_nActiveRow])[m_nActiveColumn] ->SetState(eButtonHighlighted);

}

void CKeyboardScene::MoveDown()
{
	(*m_pKeyboard[m_nActiveRow])[m_nActiveColumn] ->SetState(eButtonDefault);
	m_nActiveRow = (++m_nActiveRow) % 5;
	switch (m_nActiveRow)
	{
		case 0:
			m_nActiveColumn = m_nRealPosition;
			break;
		case 2:
			m_nRealPosition = m_nActiveColumn; // save it 
			break;
		case 3:
			m_nActiveColumn = min(7,m_nActiveColumn);
			break;
		case 4:
			// map 1-6 to Space
			if(m_nActiveColumn == 0)
			{
				break;
			}
			if(m_nRealPosition < 7)
			{
				m_nActiveColumn = 1;
				break;
			}
			// 7-8 maps to <
			if(m_nRealPosition == 7 || m_nRealPosition == 8)
			{
				m_nActiveColumn = 2;
				break;
			}
			if(m_nRealPosition == 9 || m_nRealPosition == 10)
			{
				m_nActiveColumn = 3;
				break;
			}
			ASSERT(false);
			break;
		default:
			ASSERT(m_nActiveRow == 1);
	}
	(*m_pKeyboard[m_nActiveRow])[m_nActiveColumn] ->SetState(eButtonHighlighted);

}
void CKeyboardScene::MoveLeft()
{
	(*m_pKeyboard[m_nActiveRow])[m_nActiveColumn] ->SetState(eButtonDefault);
	m_nActiveColumn--;
	if(m_nActiveColumn < 0)
	{
		switch(m_nActiveRow)
		{
		case 0:
		case 1:
		case 2:
			m_nActiveColumn = 10;
			break;
		case 3:
			m_nActiveColumn = 7;
			break;
		case 4:
			m_nActiveColumn = 3;
			break;

		default:
			ASSERT(false);
		};
	}

	switch(m_nActiveRow)
	{
	case 0:
	case 1:
	case 2:
		m_nRealPosition = m_nActiveColumn;
		break;
	case 3:
		m_nRealPosition = ((7 == m_nActiveColumn) ? 10 : m_nActiveColumn);
		break;
	case 4:
		if(m_nActiveColumn == 0)
		{
			m_nRealPosition = 0;
			break;
		}
		if(m_nActiveColumn == 1)
		{
			m_nRealPosition = 6;
			break;
		}

		if(m_nActiveColumn == 2)
		{
			m_nRealPosition = 8;
			break;
		}
		
		if(m_nActiveColumn == 3)
		{
			m_nRealPosition = 10;
			break;
		}
	default:
		ASSERT(false);
	}
	(*m_pKeyboard[m_nActiveRow])[m_nActiveColumn] ->SetState(eButtonHighlighted);
    


}

void CKeyboardScene::MoveRight()
{
	(*m_pKeyboard[m_nActiveRow])[m_nActiveColumn] ->SetState(eButtonDefault);
	switch(m_nActiveRow)
	{
	case 0:
	case 1:
	case 2:
		m_nActiveColumn = (++m_nActiveColumn)%11;
		m_nRealPosition = m_nActiveColumn;
		break;
    case 3:
		m_nActiveColumn = (++m_nActiveColumn)%8;
		m_nRealPosition = min(7, m_nActiveColumn);
		break;
	case 4:
		m_nActiveColumn = (++m_nActiveColumn)%4;
		if(m_nActiveColumn < 2)
		{
			m_nRealPosition = m_nActiveColumn;
			break;
		}
		if(m_nActiveColumn == 2)
		{
			m_nRealPosition = 7;
			break;
		}
		if(m_nActiveColumn == 3)
		{
			m_nRealPosition = 9;
			break;
		}

		break;

	default:
		ASSERT(false);
	};
	(*m_pKeyboard[m_nActiveRow])[m_nActiveColumn] ->SetState(eButtonHighlighted);	

 
}

HRESULT CKeyboardScene::BuildKeyboard()
{

	HRESULT hr = S_OK;
	for (int i=0; i < 5; i++)
	{
		CharRowVector* pNextRow = new CharRowVector;
		if(pNextRow)
		{
			m_pKeyboard.push_back(pNextRow);
		}
	}
	if(m_pKeyboard.size() < 5)
	{
		hr = E_OUTOFMEMORY;
		return hr;
	}

	// the exact number of buttons should 45 = 36 symbols + 9 buttons
	ASSERT(m_pButtons.size() == 45);
	int nCurButtonIndex = 0;
	for(size_t i = 0; i < m_pKeyboard.size(); i++)
	{
		for(size_t j = 0; j < 11; j++)
		{
			if (i == 3 && j > 7)
			{
				break;
			}
			if(i == 4 && j > 3)
			{
				break;
			}
			ASSERT(nCurButtonIndex < 45);
			m_pKeyboard[i]->push_back(m_pButtons[nCurButtonIndex++]);

		}
	}

	for(size_t i = 0; i < m_pButtons.size() - 5; i++)
	{
		// skip all the buttons and hold only input symbols
		if( i % 11 == 0)
			continue;
		m_pSymbols.push_back(const_cast<CText*> (m_pButtons[i]->GetTextObject())  );
	}
	SetCharacterSet();
	int nIndex = FindTextObjForShape(cszInputText);
	ASSERT(nIndex!=-1);
	m_pInputText = m_pTexts[nIndex];
	m_pInputText->SetText(_T(""));

	nIndex = FindTextObjForShape(cszKeyboardTitle);
	ASSERT(nIndex!=-1);
	m_pTitleText = m_pTexts[nIndex];
	m_pTitleText->SetText(_T("KB TITLE"));
	
	return hr;
}


CKeyboardScene::~CKeyboardScene()
{
	Cleanup();
	CScene::Cleanup();

}

HRESULT CKeyboardScene::Cleanup()
{
	// TBD clean up 
	HRESULT hr = S_OK;

// just unacquire the pointers, scene will take care of memory relase.
	for (size_t i =0; i<m_pKeyboard.size(); i++)
	{
		CharRowVector* pCurRow = m_pKeyboard[i];		
		pCurRow->erase(pCurRow->begin(), pCurRow->end());
		delete pCurRow;
		pCurRow = NULL;
	}

	m_pKeyboard.erase(m_pKeyboard.begin(), m_pKeyboard.end());

	m_pSymbols.erase(m_pSymbols.begin(), m_pSymbols.end());
	return hr;
}



void CKeyboardScene::FindControlButton(eButtonId eButton, int* pnRow, int* pnCol)
{
	
	size_t j=0 ;
	*pnRow = -1;
	*pnCol = -1;
	bool bFound = false;
	
	for (size_t i =0; i<m_pKeyboard.size(); i++)
	{
		if(bFound)
		{
			break;
		}

		CharRowVector* pCurRow = m_pKeyboard[i];
		for(j=0; j< m_pKeyboard[i]->size(); j++)
		{
			if((*pCurRow)[j] && ((*pCurRow)[j])->GetButtonId() == eButton)
			{
				bFound = true;
				*pnRow = i;
				*pnCol = j;
				break;
			}
		}
	}


}

void CKeyboardScene::Dump(bool bAllData )
{
	if(bAllData)
	{
		DbgPrint("=====================================================\n");
		DbgPrint("Keyboard dump\n");
		DbgPrint("=====================================================\n");

		for (size_t i =0; i<m_pKeyboard.size(); i++)
		{
			CharRowVector* pCurRow = m_pKeyboard[i];

			for(size_t j=0; j< m_pKeyboard[i]->size(); j++)
			{
				DbgPrint("\n++++++++++++++++++++++++++\n");
				(*pCurRow)[j]->Dump(true);
				DbgPrint("\n++++++++++++++++++++++++++\n");
			}
			DbgPrint("---------------------------------------------------\n");
		}
		DbgPrint("=====================================================\n");
	}
}

HRESULT CKeyboardScene::PressedA()
{
	CButton* pCurButton = (*m_pKeyboard[m_nActiveRow])[m_nActiveColumn];

	eButtonId eCurButton = pCurButton->GetButtonId();
    	
    eSoundType  soundType = pCurButton->GetSoundType();

	CText* pCurText = (const_cast<CText*> (pCurButton->GetTextObject()));
	HRESULT hr = S_OK;
	switch(eCurButton)
	{
	case eDoneButtonId:
		CSceneNavigator::Instance()->MovePreviousScene();
		hr = XBAPPWRN_SCENE_CHANGED;
		break;
	case eShiftButtonId:
		m_bShiftActive = true;
		m_bCapitalActive = !m_bCapitalActive;
		SetCharacterSet();
		break;

	case eCapsLockButtonId:
		m_bCapitalActive = !m_bCapitalActive;
		SetCharacterSet();
		break;

	case eAccentsButtonId:
		m_bAccentActive = !m_bAccentActive; 
		m_bAccentActive? m_nActiveCharSetIndex = 2 : m_nActiveCharSetIndex = 0;
		SetCharacterSet();
		
		m_bAccentActive? pCurText->SetTextId(cszAlphabetTextId) : pCurText->SetTextId(cszAccentTextId);
		if(m_bAccentActive)
		{
			int nRow, nCol; 
			FindControlButton(eSymbolsButtonId, &nRow, &nCol);
			ASSERT(nRow!=-1 && nCol!=-1);
			CButton* pButton = (*m_pKeyboard[nRow])[nCol];
			ASSERT(pButton);
			CText* pText = const_cast<CText*> (pButton->GetTextObject());
			ASSERT(pText);
			if(_tcsicmp(pText->GetTextId(), pCurText->GetTextId()) == 0)
			{
				pText->SetTextId(cszSymbolsTextId);
			}
		}
		break;

	case eSymbolsButtonId:
		
		m_bSymbolsActive = !m_bSymbolsActive;
		m_bSymbolsActive? m_nActiveCharSetIndex = 1 : m_nActiveCharSetIndex = 0;
		SetCharacterSet();
		
		m_bSymbolsActive? pCurText->SetTextId(cszAlphabetTextId) : pCurText->SetTextId(cszSymbolsTextId);
		if(m_bSymbolsActive)
		{
			int nRow, nCol; 
			FindControlButton(eAccentsButtonId, &nRow, &nCol);
			ASSERT(nRow!=-1 && nCol!=-1);
			CButton* pButton = (*m_pKeyboard[nRow])[nCol];
			ASSERT(pButton);
			CText* pText = const_cast<CText*> (pButton->GetTextObject());
			ASSERT(pText);
			if(_tcsicmp(pText->GetTextId(), pCurText->GetTextId()) == 0)
			{
				pText->SetTextId(cszAccentTextId);
			}
		}
		
		break;
	default:
		// input character
		UpdateInputText(pCurText);
		// shift affects only the next typed character
		if(m_bShiftActive)
		{
			m_bCapitalActive = !m_bCapitalActive;
			SetCharacterSet();
			m_bShiftActive = false;
		}
	}

    PlaySound( eKeyboardSound, eSoundAPress );

	return hr;
}

void CKeyboardScene::SetCharacterSet()
{	
	ASSERT(m_nActiveCharSetIndex < countof(rgKeys));
	const WORD* pCur = rgKeys[m_nActiveCharSetIndex];
	static WORD delta = (_agrave - _Agrave);

	for (int i=0; i<countof(rgkeyAlpha); i++)
	{
		TCHAR szSymbol[2];
		
		if(m_bCapitalActive)
		{
			_stprintf(szSymbol,_T("%c"),ToUpper(rgKeys[m_nActiveCharSetIndex][i]) );
		}
		else
		{
			_stprintf(szSymbol,_T("%c"), ToLower(rgKeys[m_nActiveCharSetIndex][i]) );
		}
		m_pSymbols[i]->SetText(szSymbol);
	}
}

void CKeyboardScene::PressedX()
{
	m_nActiveCharSetIndex = (++m_nActiveCharSetIndex)%3;
	ASSERT(m_nActiveCharSetIndex < countof(rgKeys));
	SetCharacterSet();
}


//-----------------------------------------------------------------------------
// Name: ToUpper()
// Desc: Convert WCHAR to upper case. Handles accented characters properly.
//-----------------------------------------------------------------------------
WCHAR  CKeyboardScene::ToUpper( WCHAR c ) // static
{
    // The code solution is slower but smaller
    if( c >= 'a' && c <= 'z' )
        return c - ('a' - 'A');
    if( c >= 0xE0 && c <= 0xFD )
        return c - (0xE0 - 0xC0);
    return c;
}




//-----------------------------------------------------------------------------
// Name: ToLower()
// Desc: Convert WCHAR to lower case. Handles accented characters properly.
//-----------------------------------------------------------------------------
WCHAR  CKeyboardScene::ToLower( WCHAR c ) // static
{
    // The code solution is slower but smaller
    if( c >= 'A' && c <= 'Z' )
        return c + ( 'a' - 'A' );
    if( c >= 0xC0 && c <= 0xDD )
        return c + ( 0xE0 - 0xC0 );
    return c;

}


void  CKeyboardScene::UpdateInputText(CText* pCurText)
{
		bool bAddChar = true;
		bool bInputProcessed = false;

		// too many possibilities:
		// basic idea: when you first time popup the keyboard it includes original string (if any) in the input
		// field. If string is not empty, first user input dictates whether to erase original value or not
		// If the very first user input is left/right trigger or '<'/'>' then preserve the string, otherwise
		// remove the string.
		if(!m_bResetInput)
		{
			if(pCurText->GetTextId())
			{
			
				if ((_tcsicmp(cszLeftShiftTextId, pCurText->GetTextId()) == 0))
				{
					m_pInputText->MoveCursorHome();
					bInputProcessed = true;
				}
				else if ( (_tcsicmp(cszRightShiftTextId, pCurText->GetTextId()) == 0 ))
				{
					m_pInputText->MoveCursorEnd();
					bInputProcessed = true;
				}
			}
			else
			{
				m_pInputText->SetText(_T(""));
				m_pInputText->MoveCursorHome();
			}
			m_bResetInput = !m_bResetInput;	
		}
		
		// stop getting input after the max len is reached
		int nLen = _tcslen(m_pInputText->GetText());
		if(_tcslen(m_pInputText->GetText()) >= g_szUserInput.GetInputMaxLength())
		{
			bAddChar = false;
		}
		
		TCHAR szBuf[MAX_INPUT_TEXT_SIZE+1];
		ZeroMemory(szBuf, (MAX_INPUT_TEXT_SIZE+1)*sizeof(TCHAR));
		if(pCurText->GetTextId() && !bInputProcessed)
		{
			if(_tcsicmp(cszBackspaceTextId, pCurText->GetTextId())  == 0)
			{	
				int nOrigLen =_tcslen(m_pInputText->GetText());
				int nPos = m_pInputText->GetCursorPosition();
				const TCHAR* pszInputText = m_pInputText->GetText();
				if( nOrigLen > 0 && nPos >= 1)
				{
					_tcsncpy(szBuf, pszInputText, nPos-1);
					_tcsncpy(szBuf+nPos-1,pszInputText+nPos,nOrigLen - nPos);

					szBuf[nOrigLen-1] = '\0';
				}// if we are at the begining of the buffer, preserve original string
				else if (nPos <= 1)
				{
					_tcscpy(szBuf, pszInputText);
				}
				else 
				{
					szBuf[0] = '\0';
				}
				m_pInputText->SetText(szBuf);
				m_pInputText->MoveCursorLeft();
				bInputProcessed = true;
			}
			else if (_tcsicmp(cszLeftShiftTextId, pCurText->GetTextId()) == 0)
			{
				m_pInputText->MoveCursorLeft();
				bInputProcessed = true;
			}
			else if (_tcsicmp(cszRightShiftTextId, pCurText->GetTextId()) == 0)
			{
				m_pInputText->MoveCursorRight();
				bInputProcessed = true;
			}
		}

		if(bAddChar && !bInputProcessed)
		{
			TCHAR szSymbol[2];
			const TCHAR* pszInputText = m_pInputText->GetText();
			const TCHAR* pszCurSymbol = pCurText->GetText();
			if(pCurText->GetTextId() && _tcsicmp(cszSpaceTextId, pCurText->GetTextId()) == 0)
			{
				_tcscpy(szSymbol,_T(" "));
			}
			else
			{
				ASSERT(_tcslen(pszCurSymbol) == 1);
				_tcscpy(szSymbol,pszCurSymbol);
			}
			
			int nPos = m_pInputText->GetCursorPosition();
			if(nPos < 0)
			{
				m_pInputText->MoveCursorRight();
				nPos = m_pInputText->GetCursorPosition();
			}
			
			_tcsncpy(szBuf, pszInputText, nPos);
			_tcsncpy(szBuf+nPos,szSymbol, 1);
			_tcsncpy(szBuf+nPos+1,pszInputText+nPos,_tcslen(pszInputText) - nPos);

			szBuf[_tcslen(pszInputText) +1] = '\0';
			m_pInputText->SetText(szBuf);
			m_pInputText->MoveCursorRight();
			g_szUserInput.SetInputText(m_pInputText->GetText());
		}
		
}



void CKeyboardScene::AutoTest(eAutoTestData eState)
{
	switch(eState)
	{
	case eSceneInit:
		DbgPrint("\nAUTO:SCREEN=SCREEN_ID[%d], SCREEN_NAME[%s]\n",m_eSceneId, SceneName[m_eSceneId]);
		for(size_t i = 0; i< m_pButtons.size(); i++)
		{	
			m_pButtons[i]->AutoTest();
		}
		break;
	case eChangeFocus:

		CButton* pCurButton = (*m_pKeyboard[m_nActiveRow])[m_nActiveColumn];

		eButtonId eFocusButton = pCurButton->GetButtonId();
		ASSERT(eFocusButton < countof(ButtonName));

		DbgPrint("\nAUTO:FOCUS=BUTTON_ID[%d], BUTTON_NAME[%s]\n",eFocusButton, eFocusButton == eNullButtonId? "NULL": ButtonName[eFocusButton]);
		if (m_pHelpText)
		{
			const TCHAR* pszHelp = m_pHelpText->GetTextId();
			char szBuf[256];
			ZeroMemory(szBuf, countof(szBuf));
			Ansi(szBuf,pszHelp, min(countof(szBuf)-1, _tcslen(pszHelp)) );
			DbgPrint("\nAUTO:TEXT=HELP_TEXT[%s]\n",szBuf);
		}
		break;

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\xodash\XODashMain\keypad.cpp ===
#include "std.h"
#include "Scene.h"
#include "Font.h"
#include "tgl.h"
#include "XBInput.h"
#include "SceneNavigator.h"
#include "globals.h"
#include "InputHandle.h"

CFont* GetFont(const TCHAR* szFaceName); 

static const TCHAR czsKbPressSoundUrl[] = _T("KeyboardStrokePress.wav");
static const TCHAR czsKbSelectSoundUrl[] = _T("KeyboardStrokeSelect.wav");

static const char cszKeypadTitle[] = "text_title";
static const char cszKeypadInputText[] = "text_input";

static const TCHAR cszKeypadBackspaceTextId[]  =  _T("BACKSPACE");
static const TCHAR cszKeypadLeftShiftTextId[]  =  _T("LEFT_SHIFT");
static const TCHAR cszKeypadRightShiftTextId[] =  _T("RIGHT_SHIFT");

static const WORD rgkeypadPeriod [] =
{
	L'1',	L'2',	L'3',
	L'4',	L'5',	L'6',
	L'7',	L'8',	L'9',
	L'0',	L'.'
};

static const WORD rgkeypadBasic [] =
{
	L'1',	L'2',	L'3',
	L'4',	L'5',	L'6',
	L'7',	L'8',	L'9',
	L'0',	L''
};

CKeypadScene::CKeypadScene(bool keypadPeriod)
{
    m_nActiveRow    = 0;
    m_nActiveColumn = 0;
    m_nRealPosition = 0;
	m_pTitleText    = NULL;
	m_pInputText    = NULL;
    m_bkeypadPeriod = keypadPeriod;
    CScene();
    m_bResetInput   = false;
}

HRESULT CKeypadScene::Initialize(char* pUrl, char* pTextButtonUrl, eSceneId eCurSceneId, bool bAutoTest)
{
	HRESULT hr = CScene::Initialize(pUrl, pTextButtonUrl, eCurSceneId, false);
	if (FAILED(hr))
	{
		DbgPrint("CScene::Initialize fail to init CKeypadScene");
		return hr;
	}
	hr = BuildKeypad();
	if(FAILED(hr))
	{
		DbgPrint("CScene::Initialize fail to Build Keypad");
		return hr;
	}

	// it should be exactly 4 rows
    ASSERT(m_pKeypad.size() == 4);
	ASSERT((*m_pKeypad[0]).size() == 4);
	ASSERT((*m_pKeypad[1]).size() == 5);
	ASSERT((*m_pKeypad[2]).size() == 4);
	ASSERT((*m_pKeypad[3]).size() == 2);

	Dump();
	AutoTest(eSceneInit);
	if(!g_szUserInput.Empty())
	{
		m_pInputText->SetText(g_szUserInput.GetInputText());
		m_pInputText->HideCursor();
		// first char typed by a user should substitute this string
		m_bResetInput = false;
	}
	return hr;
}

HRESULT CKeypadScene::FrameMove(XBGAMEPAD& GamepadInput, float elapsedTime )
{
	HRESULT hr = S_OK;
	eInputState eCurState = GetInputState(GamepadInput);
	
	do
	{
		if(eCurState == eNoInput)
		{
			break;
		}

		// allow repetition only for up, down, left, right
		if(eCurState == eRepetitivePress)
		{
			if(
				GamepadInput.wButtons & XINPUT_GAMEPAD_DPAD_DOWN ||
				GamepadInput.fY1 == -1 ||
				GamepadInput.wButtons & XINPUT_GAMEPAD_DPAD_UP ||
				GamepadInput.fY1 == 1  ||
				GamepadInput.wButtons & XINPUT_GAMEPAD_DPAD_RIGHT ||
				GamepadInput.fX1 == 1 ||
				GamepadInput.wButtons & XINPUT_GAMEPAD_DPAD_LEFT ||
				GamepadInput.fX1 == -1 
				)
				; // continue execution and handle repetition of navigation keys
			else 
			{
				break;
			}

		}
			
		ASSERT(m_nActiveRow >= 0 && m_nActiveColumn >= 0);
		ASSERT((size_t) m_nActiveRow < m_pKeypad.size() && (size_t)m_nActiveColumn < (*m_pKeypad[m_nActiveRow]).size());
	
        // dump the currently pressed joystick input
        CPrimitiveScene::AutoTest(GamepadInput);

		if(GamepadInput.wButtons & XINPUT_GAMEPAD_DPAD_DOWN ||
		GamepadInput.fY1 == -1)
		{
			DbgPrint("CKeypadScene::FrameMove - Scene:%s, DOWN is pressed\n", SceneName[m_eSceneId]);
			MoveDown();	
			AutoTest(eChangeFocus);
            PlaySound( eKeyboardSound, eSoundHighlight ); 

		}

		if(GamepadInput.wButtons & XINPUT_GAMEPAD_DPAD_UP ||
			GamepadInput.fY1 == 1)
		{
			DbgPrint("CKeypadScene::FrameMove - Scene:%s, UP is pressed\n", SceneName[m_eSceneId]);
			MoveUp();
			AutoTest(eChangeFocus);
            PlaySound( eKeyboardSound, eSoundHighlight ); 

		}

		if(GamepadInput.wButtons & XINPUT_GAMEPAD_DPAD_RIGHT ||
			   GamepadInput.fX1 == 1)
		{
			DbgPrint("CKeypadScene::FrameMove - Scene:%s, RIGHT is pressed\n", SceneName[m_eSceneId]);
			MoveRight();
			AutoTest(eChangeFocus);
            PlaySound( eKeyboardSound, eSoundHighlight ); 
		}

		if(GamepadInput.wButtons & XINPUT_GAMEPAD_DPAD_LEFT ||
			GamepadInput.fX1 == -1)
		{
			DbgPrint("CKeypadScene::FrameMove - Scene:%s, LEFT is pressed\n", SceneName[m_eSceneId]);
			MoveLeft();
			AutoTest(eChangeFocus);            
            PlaySound( eKeyboardSound, eSoundHighlight ); 

		}
        
		if(GamepadInput.bAnalogButtons[ XINPUT_GAMEPAD_A ] > XINPUT_GAMEPAD_MAX_CROSSTALK)
		{
			DbgPrint("CKeypadScene::FrameMove - Scene:%s, A is pressed\n", SceneName[m_eSceneId]);
			
            hr = PressedA();

			if (hr == XBAPPWRN_SCENE_CHANGED)
			{
				// new input is available
				g_szUserInput.Dirty(true);
				// scene is destroyed by now do not touch any private data 
				return hr;
			}
		}

		if(GamepadInput.bPressedAnalogButtons[XINPUT_GAMEPAD_WHITE])
		{
	
            eSound  soundType = eSoundAPress;
            if ( g_szUserInput.Empty() )
                soundType = eSoundDisabled;
		    
            CText BackSpace;
			BackSpace.SetTextId(cszKeypadBackspaceTextId);
			UpdateInputText(&BackSpace);
            PlaySound( eKeyboardSound, soundType ); 
		}

		if(GamepadInput.bPressedAnalogButtons[XINPUT_GAMEPAD_LEFT_TRIGGER])
		{
			int nPos = 1;
			if(!m_bResetInput)
			{
				m_pInputText->MoveCursorHome(); 
				m_bResetInput = !m_bResetInput;
			}
			else
			{
                if ( m_pInputText->GetCursorPosition() < 1 )
                {
                    PlaySound( eKeyboardSound, eSoundDisabled );
                }
				m_pInputText->MoveCursorLeft();
			}
		}

		if(GamepadInput.bPressedAnalogButtons[XINPUT_GAMEPAD_RIGHT_TRIGGER])
		{
			
			int nPos = 1;
			int nNewPos = 0;
			if(!m_bResetInput)
			{
				m_pInputText->MoveCursorEnd();
				m_bResetInput = !m_bResetInput;
			}
			else
			{
				if ( !m_pInputText->GetText() || (unsigned long)m_pInputText->GetCursorPosition() >= _tcslen(m_pInputText->GetText() ) )
                {
                    PlaySound( eKeyboardSound, eSoundDisabled );
                }
                m_pInputText->MoveCursorRight();
			}
		}

		if(GamepadInput.bPressedAnalogButtons[XINPUT_GAMEPAD_B] ||
			GamepadInput.wPressedButtons & XINPUT_GAMEPAD_BACK)
		{
            PlaySound( eKeyboardSound, eSoundBPress );
			CSceneNavigator::Instance()->MovePreviousScene();
			// discard the new string, back button was pressed
			g_szUserInput.Dirty(false);
			// scene is destroyed by now do not touch any private data
			return hr;
		}

	} while(0);	

	ASSERT(m_nActiveRow >= 0 && m_nActiveColumn >= 0 && m_nRealPosition >= 0);
	ASSERT((size_t) m_nActiveRow < m_pKeypad.size() && (size_t)m_nActiveColumn < (*m_pKeypad[m_nActiveRow]).size());	
    
	for(size_t i = 0; i<m_pTexts.size(); i++)
	{
		m_pTexts[i]->FrameMove(elapsedTime);
	}
	
	return hr;
}

void CKeypadScene::MoveUp()
{	
	(*m_pKeypad[m_nActiveRow])[m_nActiveColumn]->SetState(eButtonDefault);
	m_nActiveRow--;

	switch(m_nActiveColumn)
	{
    case 0:
        if(m_nActiveRow < 0)
        {
            m_nActiveRow = 3;
            m_nRealPosition = 0;
        }
		break;
    case 1:
        if(m_nActiveRow < 0)
        {
            m_nActiveRow = 3;
            m_nActiveColumn = 0;
            m_nRealPosition = 1;
        }
		break;
	case 2: 
        if(m_nActiveRow < 0)
        {
            if(m_bkeypadPeriod)  // period key
            {
		        m_nActiveRow = 3;
                m_nActiveColumn = 1;
                m_nRealPosition = 2;
            }
            else
            {
		        m_nActiveRow = 2;
                m_nRealPosition = 2;
            }
        }
		break;
	case 3:
    case 4:
        if(m_nActiveRow < 0)
       	    m_nActiveRow = 2;

        // moving onto the arrows
        if(m_nActiveRow == 1)
        {
            if(m_nRealPosition > 2)
                m_nActiveColumn = m_nRealPosition;
            else
                m_nRealPosition = m_nActiveColumn;
        }

        // moving off the arrows
        if(m_nActiveRow == 0)
        {
            m_nRealPosition = m_nActiveColumn;
            m_nActiveColumn = 3;
        }
        break;
	default:
		ASSERT(false);
	};

    if(m_nActiveRow == 2)  // just moved off of the last row
    {
        switch(m_nActiveColumn)
	    {
            case 0:
            case 1:
            case 2:
                m_nActiveColumn = m_nRealPosition;
                break;
            default:
		        ASSERT(m_nActiveColumn == 3);
        };
    }

	(*m_pKeypad[m_nActiveRow])[m_nActiveColumn] ->SetState(eButtonHighlighted);
}

void CKeypadScene::MoveDown()
{
	(*m_pKeypad[m_nActiveRow])[m_nActiveColumn] ->SetState(eButtonDefault);
	m_nActiveRow = (++m_nActiveRow) % 4;

    switch(m_nActiveColumn)
    {
        case 0:
            // snap to 0 button
            if(m_nActiveRow == 3)
            {
                m_nActiveColumn = 0;
                m_nRealPosition = 0;
            }
            break;
        case 1:
            // snap to 0 button
            if(m_nActiveRow == 3)
            {
                m_nActiveColumn = 0;
                m_nRealPosition = 1;
            }
            break;
        case 2:
            if(m_nActiveRow == 3)
            {
                if(m_bkeypadPeriod)  // period key
                {
                    m_nActiveColumn = 1;
                    m_nRealPosition = 2;
                }
                else
                {
                    m_nActiveRow = 0;
                    m_nRealPosition = 2;
                }
            }
            break;
        case 3:
        case 4:
            if(m_nActiveRow == 3)
                m_nActiveRow = 0;

            // moving onto the arrows
            if(m_nActiveRow == 1)
            {
                if(m_nRealPosition > 2)
                    m_nActiveColumn = m_nRealPosition;
                else
                    m_nRealPosition = m_nActiveColumn;
            }

            // moving off the arrows
            if(m_nActiveRow == 2)
            {
                m_nRealPosition = m_nActiveColumn;
                m_nActiveColumn = 3;
            }

            break;
        default:
            ASSERT(false);
    };
    if(m_nActiveRow == 0)  // just moved off of the last row
    {
        switch(m_nActiveColumn)
	    {
            case 0:
            case 1:
            case 2:
                m_nActiveColumn = m_nRealPosition;
                break;
            default:
		        ASSERT(m_nActiveColumn == 3);
        };
    }
	(*m_pKeypad[m_nActiveRow])[m_nActiveColumn] ->SetState(eButtonHighlighted);

}
void CKeypadScene::MoveLeft()
{
	(*m_pKeypad[m_nActiveRow])[m_nActiveColumn] ->SetState(eButtonDefault);
	m_nActiveColumn--;

    if(m_nActiveColumn < 0)
	{
		switch(m_nActiveRow)
		{
		case 0:
            m_nActiveColumn = 3;
			break;
		case 1:
            m_nActiveColumn = 4;
			break;
		case 2:
            m_nActiveColumn = 3;
			break;
		case 3:
            if(m_bkeypadPeriod)  // period key
            {
                m_nActiveColumn = 1;
                m_nRealPosition = 2;
            }
            else
            {
                m_nActiveColumn = 0;
            }
			break;
		default:
			ASSERT(false);
		};
	}
    if(m_nActiveColumn == 0 && m_nActiveRow == 3 && m_bkeypadPeriod) // moving to zero button
    {
        m_nRealPosition = 1;
    }

	(*m_pKeypad[m_nActiveRow])[m_nActiveColumn] ->SetState(eButtonHighlighted);
}

void CKeypadScene::MoveRight()
{
	(*m_pKeypad[m_nActiveRow])[m_nActiveColumn] ->SetState(eButtonDefault);
    m_nActiveColumn++;

    switch(m_nActiveRow)
	{
	case 0:
        if(m_nActiveColumn > 3)
            m_nActiveColumn = 0;
        break;
	case 1:
        if(m_nActiveColumn > 4)
            m_nActiveColumn = 0;
        break;
	case 2:
        if(m_nActiveColumn > 3)
            m_nActiveColumn = 0;
        break;
    case 3:
        if(m_bkeypadPeriod)  // period key
        {
            if(m_nActiveColumn > 1)
            {
                m_nActiveColumn = 0;
                m_nRealPosition = 0;
            }
        }
        else
        {
            if(m_nActiveColumn > 0)
            {
                m_nActiveColumn = 0;
            }
        }
        break;
	default:
		ASSERT(false);
	};
    if(m_nActiveColumn == 1 && m_nActiveRow == 3 && m_bkeypadPeriod) // moving to period button
    {
        m_nRealPosition = 2;
    }
	(*m_pKeypad[m_nActiveRow])[m_nActiveColumn] ->SetState(eButtonHighlighted);
}

HRESULT CKeypadScene::BuildKeypad()
{

	HRESULT hr = S_OK;

    for (int i=0; i < 4; i++)
	{
		CharRowVector* pNextRow = new CharRowVector;
		if(pNextRow)
		{
			m_pKeypad.push_back(pNextRow);
		}
	}
	if(m_pKeypad.size() < 4)
	{
		hr = E_OUTOFMEMORY;
		return hr;
	}

	// the exact number of buttons should 15 = 11 symbols + 4 buttons
	ASSERT(m_pButtons.size() == 15);

	int nCurButtonIndex = 0;
	for(size_t i = 0; i < m_pKeypad.size(); i++)
	{
		for(size_t j = 0; j < 5; j++)
		{
            if ((i == 0 || i == 2) && j > 3)
			{
				break;
			}
			if (i == 3 && j > 1)
			{
                break;
			}

			ASSERT(nCurButtonIndex < 15);
			m_pKeypad[i]->push_back(m_pButtons[nCurButtonIndex++]);
		}
	}

    // Hide the key if not using the period
    if(!m_bkeypadPeriod)
    {
        TG_Shape* pPeriodButton = m_pRoot->FindObject("button_period");
        pPeriodButton->setVisible(false);
    }

    // Set the default focus to the first key
    (*m_pKeypad[0])[3]->SetState(eButtonDefault);
    (*m_pKeypad[0])[0]->SetState(eButtonHighlighted);

	SetCharacterSet();
	int nIndex = FindTextObjForShape(cszKeypadInputText);
	ASSERT(nIndex!=-1);
	m_pInputText = m_pTexts[nIndex];
	m_pInputText->SetText(_T(""));
	m_pInputText->MoveCursorRight(1);

	nIndex = FindTextObjForShape(cszKeypadTitle);
	ASSERT(nIndex!=-1);
	m_pTitleText = m_pTexts[nIndex];
	m_pTitleText->SetText(_T("KeyPad Title"));

	return hr;
}

static const char* kpbuttonIndex [] =
{
	"text_01",	"text_02",	"text_03",
	"text_04",	"text_05",	"text_06",
	"text_07",	"text_08",	"text_09",
	"text_00",	"text_period"
};

void CKeypadScene::SetCharacterSet()
{	    
    for(int i = 0; i < countof(rgkeypadPeriod); i++)
    {
        TCHAR szSymbol[2];
        if(!m_bkeypadPeriod)  // sets period button text to null
	        _stprintf(szSymbol,_T("%c"), rgkeypadBasic[i] );
        else
            _stprintf(szSymbol,_T("%c"), rgkeypadPeriod[i] );

        m_pTexts[FindTextObjForShape(kpbuttonIndex[i])]->SetText(szSymbol);
    }
}

CKeypadScene::~CKeypadScene()
{
	Cleanup();
	CScene::Cleanup();
}

HRESULT CKeypadScene::Cleanup()
{
	// TBD clean up 
	HRESULT hr = S_OK;

    // just unacquire the pointers, scene will take care of memory relase.
	for (size_t i = 0; i < m_pKeypad.size(); i++)
	{
		CharRowVector* pCurRow = m_pKeypad[i];		
        pCurRow->erase(pCurRow->begin(), pCurRow->end());
		delete pCurRow;
        pCurRow = NULL;
	}

	m_pKeypad.erase(m_pKeypad.begin(), m_pKeypad.end());
	return hr;
}

void CKeypadScene::Dump(bool bAllData )
{
	if(bAllData)
	{
		DbgPrint("=====================================================\n");
		DbgPrint("Keypad dump\n");
		DbgPrint("=====================================================\n");

		for (size_t i =0; i<m_pKeypad.size(); i++)
		{
			CharRowVector* pCurRow = m_pKeypad[i];

			for(size_t j=0; j< m_pKeypad[i]->size(); j++)
			{
				DbgPrint("\n++++++++++++++++++++++++++\n");
				(*pCurRow)[j]->Dump(true);
				DbgPrint("\n++++++++++++++++++++++++++\n");
			}
			DbgPrint("---------------------------------------------------\n");
		}
		DbgPrint("=====================================================\n");
	}
}

HRESULT CKeypadScene::PressedA()
{
	CButton* pCurButton = (*m_pKeypad[m_nActiveRow])[m_nActiveColumn];

	eButtonId eCurButton = pCurButton->GetButtonId();

    eSound sound =   eSoundAPress; 

	CText* pCurText = (const_cast<CText*> (pCurButton->GetTextObject()));
	HRESULT hr = S_OK;
	switch(eCurButton)
	{
	case eKeypadDoneButtonId:
		CSceneNavigator::Instance()->MovePreviousScene();
		hr = XBAPPWRN_SCENE_CHANGED;
		break;

	default:
		// input character
		UpdateInputText(pCurText);
        break;
	}

    PlaySound( eKeyboardSound, eSoundAPress );


    return hr;
}

void  CKeypadScene::UpdateInputText(CText* pCurText)
{
		bool bAddChar = true;
		bool bInputProcessed = false;

		if(!m_bResetInput)
		{
			if(pCurText->GetTextId())
			{
			
				if ((_tcsicmp(cszKeypadLeftShiftTextId, pCurText->GetTextId()) == 0))
				{
					m_pInputText->MoveCursorHome();
					bInputProcessed = true;
				}
				else if ( (_tcsicmp(cszKeypadRightShiftTextId, pCurText->GetTextId()) == 0 ))
				{
					m_pInputText->MoveCursorEnd();
					bInputProcessed = true;
				}
			}
			else
			{
				m_pInputText->SetText(_T(""));
				m_pInputText->MoveCursorHome();
			}
			m_bResetInput = !m_bResetInput;	
		}

		// stop getting input after the max len is reached
		if(_tcslen(m_pInputText->GetText()) >= g_szUserInput.GetInputMaxLength())
		{
			bAddChar = false;
		}
		
		TCHAR szBuf[MAX_INPUT_TEXT_SIZE+1];
		ZeroMemory(szBuf, (MAX_INPUT_TEXT_SIZE+1)*sizeof(TCHAR));
		if(pCurText->GetTextId() && !bInputProcessed)
		{
			if(_tcsicmp(cszKeypadBackspaceTextId, pCurText->GetTextId())  == 0)
			{	
				int nOrigLen =_tcslen(m_pInputText->GetText());
				int nPos = m_pInputText->GetCursorPosition();
				const TCHAR* pszInputText = m_pInputText->GetText();
				if( nOrigLen > 0 && nPos >= 1)
				{
					_tcsncpy(szBuf, pszInputText, nPos-1);
					_tcsncpy(szBuf+nPos-1,pszInputText+nPos,nOrigLen - nPos);

					szBuf[nOrigLen-1] = '\0';
				}// if we are at the begining of the buffer, preserve original string
				else if (nPos <= 1)
				{
					_tcscpy(szBuf, pszInputText);
				}
				else 
				{
					szBuf[0] = '\0';
				}
				m_pInputText->SetText(szBuf);
				m_pInputText->MoveCursorLeft();
				bInputProcessed = true;
			}
			else if (_tcsicmp(cszKeypadLeftShiftTextId, pCurText->GetTextId()) == 0)
			{
				m_pInputText->MoveCursorLeft();
				bInputProcessed = true;
			}
			else if (_tcsicmp(cszKeypadRightShiftTextId, pCurText->GetTextId()) == 0)
			{
				m_pInputText->MoveCursorRight();
				bInputProcessed = true;
			}
		}

		if(bAddChar && !bInputProcessed)
		{
			TCHAR szSymbol[2];
			const TCHAR* pszInputText = m_pInputText->GetText();
			const TCHAR* pszCurSymbol = pCurText->GetText();

            ASSERT(_tcslen(pszCurSymbol) == 1);
			_tcscpy(szSymbol,pszCurSymbol);
			
			int nPos = m_pInputText->GetCursorPosition();
			if(nPos < 0)
			{
				m_pInputText->MoveCursorRight();
				nPos = m_pInputText->GetCursorPosition();
			}
			
			_tcsncpy(szBuf, pszInputText, nPos);
			_tcsncpy(szBuf+nPos,szSymbol, 1);
			_tcsncpy(szBuf+nPos+1,pszInputText+nPos,_tcslen(pszInputText) - nPos);

			szBuf[_tcslen(pszInputText) +1] = '\0';
			m_pInputText->SetText(szBuf);
			m_pInputText->MoveCursorRight();		
		}
		g_szUserInput.SetInputText(m_pInputText->GetText());
}




void CKeypadScene::AutoTest(eAutoTestData eState)
{
	switch(eState)
	{
	case eSceneInit:
		DbgPrint("\nAUTO:SCREEN=SCREEN_ID[%d], SCREEN_NAME[%s]\n",m_eSceneId, SceneName[m_eSceneId]);
		for(size_t i = 0; i< m_pButtons.size(); i++)
		{	
			m_pButtons[i]->AutoTest();
		}
		break;
	case eChangeFocus:

		CButton* pCurButton = (*m_pKeypad[m_nActiveRow])[m_nActiveColumn];

		eButtonId eFocusButton = pCurButton->GetButtonId();
		ASSERT(eFocusButton < countof(ButtonName));

		DbgPrint("\nAUTO:FOCUS=BUTTON_ID[%d], BUTTON_NAME[%s]\n",eFocusButton, eFocusButton == eNullButtonId? "NULL": ButtonName[eFocusButton]);
		if (m_pHelpText)
		{
			const TCHAR* pszHelp = m_pHelpText->GetTextId();
			char szBuf[256];
			ZeroMemory(szBuf, countof(szBuf));
			Ansi(szBuf,pszHelp, min(countof(szBuf)-1, _tcslen(pszHelp)) );
			DbgPrint("\nAUTO:TEXT=HELP_TEXT[%s]\n",szBuf);
		}
		break;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\xodash\XODashMain\NavigationDesc.cpp ===
//Copyright (c) Microsoft Corporation.  All rights reserved.

CSceneNavigator* CSceneNavigator::pinstance = 0;
SceneDescription CSceneNavigator::m_SceneDataMap[] = 
{

	/* MainScene Scene */
	{
		XBG_PATH_ANSI"3buttons.xbg", "3buttons", false, NULL, eNullButtonId
	},

	/* MemoryScene Scene */
	{
		XBG_PATH_ANSI"onetext.xbg", "onetext", false, NULL, eNullButtonId
	},

	/* MusicScene Scene */
	{
		XBG_PATH_ANSI"threetext.xbg", "threetext", false, NULL, eNullButtonId
	},

	/* SettingsScene Scene */
	{
		XBG_PATH_ANSI"twotext.xbg", "twotext", false, NULL, eNullButtonId
	},

	/* Keyboard Scene */
	{
		XBG_PATH_ANSI"keyboard.xbg", "keyboard", false, NULL, eNullButtonId
	},

	/* Keypad Scene */
	{
		XBG_PATH_ANSI"keypad.xbg", "keypad", false, NULL, eNullButtonId
	},

	/* KeypadPeriod Scene */
	{
		XBG_PATH_ANSI"keypad.xbg", "keypad", false, NULL, eNullButtonId
	},

	/* NTS_Settings Scene */
	{
		XBG_PATH_ANSI"NTS_Settings.xbg", "NTS_Settings", false, NULL, eNullButtonId
	},

	/* NTS_Hostname Scene */
	{
		XBG_PATH_ANSI"NTS_Hostname.xbg", "NTS_Hostname", true, NULL, eNullButtonId
	},

	/* NTS_HostnameTS Scene */
	{
		XBG_PATH_ANSI"NTS_Hostname.xbg", "NTS_Hostname", true, NULL, eNullButtonId
	},

	/* NTS_PPPoE Scene */
	{
		XBG_PATH_ANSI"NTS_DNS.xbg", "NTS_PPPoE", true, NULL, eNullButtonId
	},

	/* NTS_PPPoETS Scene */
	{
		XBG_PATH_ANSI"NTS_DNS.xbg", "NTS_PPPoE", true, NULL, eNullButtonId
	},

	/* NTS_IP Scene */
	{
		XBG_PATH_ANSI"NTS_IP.xbg", "NTS_IP", true, NULL, eNullButtonId
	},

	/* NTS_DNS Scene */
	{
		XBG_PATH_ANSI"NTS_DNS.xbg", "NTS_DNS", true, NULL, eNullButtonId
	},

	/* NTS_DNSTS Scene */
	{
		XBG_PATH_ANSI"NTS_DNS.xbg", "NTS_DNS", true, NULL, eNullButtonId
	},

	/* CellWall Scene */
	{
		XBG_PATH_ANSI"cellwall.xbg", "cellwall", false, NULL, eNullButtonId
	},

	/* gen_mess_panel Scene */
	{
		XBG_PATH_ANSI"gen_mess_panel.xbg", "gen_mess_panel", false, NULL, eNullButtonId
	},

	/* gen_mess_panel Scene */
	{
		XBG_PATH_ANSI"gen_mess_panel.xbg", "gen_mess_panel", false, NULL, eNullButtonId
	},

	/* ACT_Online Scene */
	{
		XBG_PATH_ANSI"act_online.xbg", "ACT_Online", true, NULL, eNullButtonId
	},

	/* ACT_Id Scene */
	{
		XBG_PATH_ANSI"act_id.xbg", "ACT_Id", true, NULL, eNullButtonId
	},

	/* NTS_Status Scene */
	{
		XBG_PATH_ANSI"NTS_status.xbg", "NTS_Status", false, NULL, eNullButtonId
	},

	/* NTS_ConfigChoice Scene */
	{
		XBG_PATH_ANSI"gen_large_panel.xbg", "NTS_ConfigChoice", false, NULL, eNullButtonId
	},

	/* NTS_CableHelp Scene */
	{
		XBG_PATH_ANSI"NTS_Help.xbg", "NTS_CableHelp", false, NULL, eNullButtonId
	},

	/* NTS_PPPoEHelp Scene */
	{
		XBG_PATH_ANSI"NTS_Help.xbg", "NTS_PPPoEHelp", false, NULL, eNullButtonId
	},

	/* NTS_IPHelp Scene */
	{
		XBG_PATH_ANSI"NTS_Help.xbg", "NTS_IPHelp", false, NULL, eNullButtonId
	},

	/* NTS_DNSHelp Scene */
	{
		XBG_PATH_ANSI"NTS_Help.xbg", "NTS_DNSHelp", false, NULL, eNullButtonId
	},

	/* NTS_ServicesHelp Scene */
	{
		XBG_PATH_ANSI"NTS_Help.xbg", "NTS_ServicesHelp", false, NULL, eNullButtonId
	},

	/* ACT_Credit Scene */
	{
		XBG_PATH_ANSI"act_credit.xbg", "ACT_Credit", true, NULL, eNullButtonId
	},

	/* ACT_Country Scene */
	{
		XBG_PATH_ANSI"act_country.xbg", "ACT_Country", false, NULL, eNullButtonId
	},

	/* ACT_Billing Scene */
	{
		XBG_PATH_ANSI"act_billing.xbg", "ACT_Billing", true, NULL, eNullButtonId
	},

	/* Gen_Large_Panel Scene */
	{
		XBG_PATH_ANSI"gen_large_panel.xbg", "Gen_Large_Panel", true, NULL, eNullButtonId
	},

	/* GEN_Exp_Tumblers Scene */
	{
		XBG_PATH_ANSI"gen_exp_tumblers.xbg", "GEN_Exp_Tumblers", false, NULL, eNullButtonId
	},

	/* GEN_Dob_Tumblers Scene */
	{
		XBG_PATH_ANSI"gen_dob_tumblers.xbg", "GEN_Dob_Tumblers", false, NULL, eNullButtonId
	},

	/* GEN_Welcome_Panel Scene */
	{
		XBG_PATH_ANSI"gen_large_panel.xbg", "GEN_Welcome_Panel", true, NULL, eNullButtonId
	},

	/* ACT_Billing_Country Scene */
	{
		XBG_PATH_ANSI"act_country.xbg", "ACT_Billing_Country", true, NULL, eNullButtonId
	},

	/* Anim_Wait Scene */
	{
		XBG_PATH_ANSI"anim_wait.xbg", "anim_wait", true, NULL, eNullButtonId
	},

	/* Anim_Connect Scene */
	{
		XBG_PATH_ANSI"Anim_Connecting.xbg", "Anim_Connecting", true, NULL, eNullButtonId
	},
	{ NULL, false, NULL },
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\xodash\XODashMain\NTS.cpp ===
//-------------------------------------------------------------
// Copyright (c) Microsoft Corporation.  All rights reserved
// Author: Natalyp
//-------------------------------------------------------------
#include "std.h"
#include "Scene.h"

#include "NetConfig.h"
#include "XBInput.h"
#include "globals.h"
#include "InputHandle.h"
#include "Dialog.h"
#include "SceneNavigator.h"



//-------------------------------------------------------------
// Function name	: CNTS::SetValue
// Description	    : set value for currently highlighted button
// Return type		: HRESULT 
// Argument         : const TCHAR* szValue
//-------------------------------------------------------------
HRESULT CNTS::SetValue(const TCHAR* szValue)
{
	HRESULT hr = g_NetConfig.SetValue(m_pButtons[m_nActiveButtonIndex]->GetButtonId(), const_cast<TCHAR*> (szValue) );
	if (FAILED(hr))
	{
		return hr;
	}
	const CText* pInput = m_pButtons[m_nActiveButtonIndex]->GetInputTextObject();
    if ( pInput )
    {
	    (const_cast <CText*> (pInput)) ->SetText(szValue);
    }
	return hr;
}


static const TCHAR cszStaticIp[] = _T("STATIC_IP");
static const TCHAR cszDynamicIp[] = _T("DYNAMIC_IP");
static const TCHAR cszContinue[] = _T("CONTINUE");
static const TCHAR cszToggle[] = _T("TOGGLE");


//-------------------------------------------------------------
// Function name	: CNTS::BindData
// Description	    : part of initialization process, retrieve the data from the Data object
// Return type		: HRESULT 
//-------------------------------------------------------------
HRESULT CNTS::BindData()
{
	HRESULT hr = S_OK;
	for(size_t i =0; i<m_pButtons.size(); i++)
	{
		const TCHAR* szValue = g_NetConfig.GetValue(m_pButtons[i]->GetButtonId());
		
		if(m_pButtons[i]->m_eType == eTwoTextButton)
		{
			const CText* pcInput =m_pButtons[i]->GetInputTextObject();
         
			CText* pButtonText = const_cast<CText*> (m_pButtons[i]->GetTextObject());

			CText* pInput = const_cast<CText*> (pcInput); 

			if(_tcsstr(pButtonText->GetTextId(), cszToggle) )
			{ 
				pInput ->SetTextId(szValue);
				SetButtonsState(szValue);
			}
			else if ( pInput )
			{
				pInput->SetText(szValue);
			}
		}
	}
// hide continue button if necessary	
	if (m_bHideContinue)
	{
		int nIndex = FindButtonForTextObj(cszContinue);
		if(nIndex == -1 && m_eSceneId != eNTS_IPId)
		{
			//all screens except of IP should have this button
			ASSERT(false);
		}
		if(nIndex >=0 && nIndex < (int)m_pButtons.size())
		{
			m_pButtons[nIndex]->Show(false);
		}

	}
	return hr;
}


//-------------------------------------------------------------
// Function name	: CNTS::FrameMove
// Description	    : Update an edited previously value, handle toggle Static/Dynamic button
// Return type		: HRESULT 
// Argument         : XBGAMEPAD& GamepadInput
// Argument         : float elapsedTime
//-------------------------------------------------------------
HRESULT CNTS::FrameMove(XBGAMEPAD& GamepadInput, float elapsedTime )
{
	HRESULT hr = S_OK;

	if (g_szUserInput.IsNewInput())
	{
		hr = SetValue(g_szUserInput.GetInputText());
		// do not reset invalid value it'll reappear next time keyboard pops up
		if(FAILED(hr))
		{
			DbgPrint("CNTS::FrameMove - Failed to set value, hr = 0x%x\n", hr);
		}
		else 
		{
			g_szUserInput.ResetInputText();
		}
	}

	bool bActiveToggle = false;
	if(SUCCEEDED(hr))
	{		

		if(GamepadInput.bPressedAnalogButtons[XINPUT_GAMEPAD_A] || 
		   GamepadInput.wPressedButtons & XINPUT_GAMEPAD_START)
		{
			CText* pText = const_cast <CText*> (m_pButtons[m_nActiveButtonIndex]->GetTextObject());
			CText* pInput = const_cast <CText*> (m_pButtons[m_nActiveButtonIndex]->GetInputTextObject());

			if(_tcsstr(pText->GetTextId(), cszToggle) )
			{
				g_NetConfig.SetValue(m_pButtons[m_nActiveButtonIndex]->GetButtonId(), NULL);
				const TCHAR* szValue= g_NetConfig.GetValue(m_pButtons[m_nActiveButtonIndex]->GetButtonId());
				bActiveToggle = true;
				if(m_pButtons[m_nActiveButtonIndex]->m_eType == eTwoTextButton)
				{
                    if ( pInput )
                    {
					    pInput ->SetTextId(szValue);
                    }
					// TBD change the button from and to disable
					SetButtonsState(szValue);
					// refresh all the fields
					BindData();
				
				}
				else
				{
					// this button must have two texts
					ASSERT(false);
				}
			}
			else // A is pressed set value into the global buffer for keyboard to load
			{
				if(pInput && pInput->GetText())
				{
					g_szUserInput.SetInputText(pInput->GetText());
					// for IP and DNS screens we need to collect IP address, limit the size of input to the IP_ADDRESS_SIZE
					if(m_eSceneId == eNTS_IPId || m_eSceneId == eNTS_DNSId || m_eSceneId == eNTS_DNSTSId)
					{
						g_szUserInput.SetInputMaxLength(IP_ADDRESS_SIZE);
					}
				}
			}
		} // if A is pressed

		

		if(GamepadInput.bPressedAnalogButtons[XINPUT_GAMEPAD_B] || 
		   GamepadInput.wPressedButtons & XINPUT_GAMEPAD_BACK)
		{
			return CCellWallScene::FrameMove(GamepadInput, elapsedTime);
		}
	}

	if(FAILED(hr))
	{
		AutoTest(GamepadInput);
		RunOKDlg( hr );
		CSceneNavigator::Instance()->MoveNextScene(m_pButtons[m_nActiveButtonIndex]->GetButtonId());
	}

	if( !m_bEditMode || bActiveToggle || FAILED(hr) )
	{
		AutoTest(GamepadInput);
		CCellWallScene::CellWallRotate(GamepadInput);
		hr = CPrimitiveScene::FrameMove(GamepadInput, elapsedTime);
		return hr;
	}

	return CCellWallScene::FrameMove(GamepadInput, elapsedTime);

}


void CNTS::SetButtonsState(const TCHAR* szValue)
{
	eButtonState eState = eButtonDefault;
	if(_tcsicmp(szValue, cszDynamicIp) == 0 )
	{
		eState = eButtonDisabled;
		m_bEditMode = false;
	}
	else
	{
		m_bEditMode = true;
	}
	// the first button is toggle do not disabled it
	for (size_t i = 1; i<m_pButtons.size(); i++)
	{
		m_pButtons[i]->SetState(eState);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\xodash\XODashMain\NTS_Help.cpp ===
#include "std.h"
#include "scene.h"
#include "globals.h"
#include "NetConfig.h"

const char cszHelpNodeName[] = "TEXT_PANEL";
const char cszTitleNodeName[] = "TEXT_TITLE";

HRESULT CNTSHelpScene::Initialize(char* pUrl, char* pButtonTextName,  eSceneId eCurSceneId, bool bAutoTest)
{
	HRESULT hr = CCellWallScene::Initialize(pUrl, pButtonTextName, eCurSceneId, bAutoTest);
	if(FAILED(hr))
	{
		return hr;
	}
	
	int nTextIndex = CPrimitiveScene::FindTextObjForShape(cszHelpNodeName);
	int nTitleTextIndex = CPrimitiveScene::FindTextObjForShape(cszTitleNodeName);

	ASSERT(nTitleTextIndex != -1 && nTextIndex != -1);
	if(nTitleTextIndex == -1 || nTextIndex == -1)
	{
		DbgPrint("CNTSHelpScene::Initialize - fail to find texts\n");
		return XBAPPERR_INTERNAL_ERROR;
	}
	eNetworkState eCurState = g_NetConfig.GetNetworkStatus();
	// set the proper text based on the current network status
	switch (m_eSceneId)
	{
		case eNTS_CableHelpId:
//			eCurState == eCableFail ? m_pTexts[nTextIndex]->SetTextId(				
			break;
		case eNTS_PPPoEHelpId:
			break;
		case eNTS_IPHelpId:
			break;
		case eNTS_DNSHelpId:
			break;
		case eNTS_ServicesHelpId:
			break;
		default:
			// not supposed to be here, unknown screen
			ASSERT(false);
	};

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\xodash\XODashMain\NTS_ConfigChoice.cpp ===
//-------------------------------------------------------------
// Copyright (c) Microsoft Corporation.  All rights reserved
// Author: Natalyp
//-------------------------------------------------------------
#include "std.h"
#include "Scene.h"
#include "tgl.h"
#include "XBInput.h"
#include "globals.h"
#include "NetConfig.h"

static const char szProgressBar[] = "progress bar";
static const char szTextFrame[]="TEXT_PANEL";
static const TCHAR szPanelTextId[]=_T("NTS_TEXT_PANEL");


//-------------------------------------------------------------
// Function name	: CNTS_ConfigChoice::Initialize
// Description	    : Hide buttons irrelevant for this screen
// Return type		: HRESULT 
// Argument         : char* pUrl
// Argument         : char* pButtonTextName
// Argument         : eSceneId eCurSceneId
// Argument         : bool bAutoTest
//-------------------------------------------------------------
HRESULT CNTS_ConfigChoice::Initialize(char* pUrl, char* pButtonTextName,  eSceneId eCurSceneId, bool bAutoTest)
{
	HRESULT hr = CCellWallScene::Initialize(pUrl, pButtonTextName, eCurSceneId, bAutoTest);
	if(FAILED(hr))
	{
		return hr;
	}
	// TBD change focus if necessary
	return hr;
}

HRESULT CNTS_ConfigChoice::FrameMove(XBGAMEPAD& GamepadInput, float elapsedTime )
{
	if(GamepadInput.bPressedAnalogButtons[XINPUT_GAMEPAD_A] || GamepadInput.wPressedButtons & XINPUT_GAMEPAD_START) 
	{
		if(m_pButtons[m_nActiveButtonIndex]->GetButtonId() == eNTS_ConfigChoice01)
		{
			// kick network discovery process from the beginning
			g_NetConfig.ResetNetworkState();
		}
	}
	return CCellWallScene::FrameMove(GamepadInput, elapsedTime );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\xodash\XODashMain\NavigationMap.cpp ===
//Copyright (c) Microsoft Corporation.  All rights reserved.

SceneChild CSceneNavigator::m_SceneHierarchy[] =
{

	/* MainScene Scene */
	{
		{ eMemorySceneId, eMusicSceneId, eSettingsSceneId, eNullSceneId },
		{ eMemoryButtonId, eMusicButtonId, eSettingsButtonId, eNullButtonId },
		{ NULL, NULL, NULL, NULL }
	},

	/* MemoryScene Scene */
	{
		{ eNullSceneId },
		{ eNullButtonId },
		{ NULL }
	},

	/* MusicScene Scene */
	{
		{ eNullSceneId },
		{ eNullButtonId },
		{ NULL }
	},

	/* SettingsScene Scene */
	{
		{ eNullSceneId },
		{ eNullButtonId },
		{ NULL }
	},

	/* Keyboard Scene */
	{
		{ eNullSceneId, eNullSceneId, eNullSceneId, eNullSceneId, eNullSceneId, eNullSceneId, eNullSceneId, eNullSceneId, eNullSceneId, eNullSceneId, eNullSceneId },
		{ eShiftButtonId, eCapsLockButtonId, eAccentsButtonId, eSymbolsButtonId, eSymbolsButtonId, eSpaceButtonId, eBackspaceButtonId, eLessThanButtonId, eGreaterThanButtonId, eDoneButtonId, eNullButtonId },
		{ NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL }
	},

	/* Keypad Scene */
	{
		{ eNullSceneId, eNullSceneId, eNullSceneId, eNullSceneId, eNullSceneId },
		{ eBackspaceButtonId, eLessThanButtonId, eGreaterThanButtonId, eDoneButtonId, eNullButtonId },
		{ NULL, NULL, NULL, NULL, NULL }
	},

	/* KeypadPeriod Scene */
	{
		{ eNullSceneId, eNullSceneId, eNullSceneId, eNullSceneId, eNullSceneId },
		{ eBackspaceButtonId, eLessThanButtonId, eGreaterThanButtonId, eDoneButtonId, eNullButtonId },
		{ NULL, NULL, NULL, NULL, NULL }
	},

	/* NTS_Settings Scene */
	{
		{ eNTS_IPId, eNTS_DNSId, eNTS_HostnameId, eNTS_PPPoEId, eACT_OnlineId, eNTS_StatusId, eNullSceneId },
		{ eNTS_settingsIP, eNTS_settingsDNS, eNTS_settingsHost, eNTS_settingsPPPoE, eNTS_settingsCancel, eNTS_settingsConnect, eNullButtonId },
		{ NULL, NULL, NULL, NULL, NULL, NULL, NULL }
	},

	/* NTS_Hostname Scene */
	{
		{ eKeyboardSceneId, eKeyboardSceneId, eNullSceneId, eNullSceneId },
		{ eNTS_HostnameHostname, eNTS_HostnameDomainName, eNTS_HostnameContinue, eNullButtonId },
		{ NULL, NULL, NULL, NULL }
	},

	/* NTS_HostnameTS Scene */
	{
		{ eKeyboardSceneId, eKeyboardSceneId, eNTS_StatusId, eNullSceneId },
		{ eNTS_HostnameHostname, eNTS_HostnameDomainName, eNTS_HostnameContinue, eNullButtonId },
		{ NULL, NULL, NULL, NULL }
	},

	/* NTS_PPPoE Scene */
	{
		{ eKeyboardSceneId, eKeyboardSceneId, eKeyboardSceneId, eNullSceneId, eNullSceneId },
		{ eNTS_PPPoEUserName, eNTS_PPPoEPassword, eNTS_PPPoEServiceName, eNTS_PPPoEContinue, eNullButtonId },
		{ NULL, NULL, NULL, NULL, NULL }
	},

	/* NTS_PPPoETS Scene */
	{
		{ eKeyboardSceneId, eKeyboardSceneId, eKeyboardSceneId, eNTS_StatusId, eNullSceneId },
		{ eNTS_PPPoEUserName, eNTS_PPPoEPassword, eNTS_PPPoEServiceName, eNTS_PPPoEContinue, eNullButtonId },
		{ NULL, NULL, NULL, NULL, NULL }
	},

	/* NTS_IP Scene */
	{
		{ eNullSceneId, eKeypadPeriodSceneId, eKeypadPeriodSceneId, eKeypadPeriodSceneId, eNullSceneId },
		{ eNTS_IPToggle, eNTS_IPIP, eNTS_IPSubnet, eNTS_IPGate, eNullButtonId },
		{ NULL, NULL, NULL, NULL, NULL }
	},

	/* NTS_DNS Scene */
	{
		{ eNullSceneId, eKeypadPeriodSceneId, eKeypadPeriodSceneId, eNullSceneId, eNullSceneId },
		{ eNTS_DNSToggle, eNTS_DNSPrimary, eNTS_DNSSecondary, eNTS_DNSContinue, eNullButtonId },
		{ NULL, NULL, NULL, NULL, NULL }
	},

	/* NTS_DNSTS Scene */
	{
		{ eNullSceneId, eKeypadPeriodSceneId, eKeypadPeriodSceneId, eNTS_StatusId, eNullSceneId },
		{ eNTS_DNSToggle, eNTS_DNSPrimary, eNTS_DNSSecondary, eNTS_DNSContinue, eNullButtonId },
		{ NULL, NULL, NULL, NULL, NULL }
	},

	/* CellWall Scene */
	{
		{ eNullSceneId },
		{ eNullButtonId },
		{ NULL }
	},

	/* gen_mess_panel Scene */
	{
		{ eNullSceneId, eNullSceneId, eNullSceneId, eNullSceneId, eNullSceneId, eNullSceneId },
		{ eMessage_YES, eMessage_CENTER, eMessage_NO, eMessage_BIGYES, eMessage_BIGNO, eNullButtonId },
		{ NULL, NULL, NULL, NULL, NULL, NULL }
	},

	/* gen_mess_panel Scene */
	{
		{ eNullSceneId, eNullSceneId, eNullSceneId, eNullSceneId, eNullSceneId, eNullSceneId },
		{ eMessage_YES, eMessage_CENTER, eMessage_NO, eMessage_BIGYES, eMessage_BIGNO, eNullButtonId },
		{ NULL, NULL, NULL, NULL, NULL, NULL }
	},

	/* ACT_Online Scene */
	{
		{ eNullSceneId, eGEN_Welcome_PanelId, eNTS_ConfigChoiceId, eNullSceneId, eNullSceneId },
		{ eACT_Online01, eACT_Online02, eACT_Online03, eACT_Online04, eNullButtonId },
		{ NULL, NULL, NULL, NULL, NULL }
	},

	/* ACT_Id Scene */
	{
		{ eKeyboardSceneId, eACT_IdId, eGEN_Dob_TumblersId, eACT_CreditId, eACT_OnlineId, eNullSceneId },
		{ eACT_Idname, eACT_Idtag, eACT_IdDOB, eACT_Idcontinue, eACT_idHiddenBadName, eNullButtonId },
		{ NULL, NULL, NULL, NULL, NULL, NULL }
	},

	/* NTS_Status Scene */
	{
		{ eNTS_CableHelpId, eNTS_IPHelpId, eNTS_DNSHelpId, eNTS_ServicesHelpId, eNTS_SettingsId, eACT_OnlineId, eNTS_PPPoETSId, eNTS_HostnameTSId, eNTS_DNSTSId, eNullSceneId },
		{ eNTS_Status01, eNTS_Status02, eNTS_Status03, eNTS_Status04, eNTS_Status05, eNTS_Status06, eNTS_StatusPPPoeInput, eNTS_StatusHostInput, eNTS_StatusDNSInput, eNullButtonId },
		{ NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL }
	},

	/* NTS_ConfigChoice Scene */
	{
		{ eNTS_StatusId, eNTS_SettingsId, eNullSceneId },
		{ eNTS_ConfigChoice01, eNTS_ConfigChoice02, eNullButtonId },
		{ NULL, NULL, NULL }
	},

	/* NTS_CableHelp Scene */
	{
		{ eNullSceneId, eNullSceneId },
		{ eNTS_CableHelp01, eNullButtonId },
		{ NULL, NULL }
	},

	/* NTS_PPPoEHelp Scene */
	{
		{ eNullSceneId, eNullSceneId },
		{ eNTS_PPPoEHelp01, eNullButtonId },
		{ NULL, NULL }
	},

	/* NTS_IPHelp Scene */
	{
		{ eNullSceneId, eNullSceneId },
		{ eNTS_IPHelp01, eNullButtonId },
		{ NULL, NULL }
	},

	/* NTS_DNSHelp Scene */
	{
		{ eNullSceneId, eNullSceneId },
		{ eNTS_DNSHelp01, eNullButtonId },
		{ NULL, NULL }
	},

	/* NTS_ServicesHelp Scene */
	{
		{ eNullSceneId, eNullSceneId },
		{ eNTS_ServicesHelp01, eNullButtonId },
		{ NULL, NULL }
	},

	/* ACT_Credit Scene */
	{
		{ eACT_CountryId, eKeyboardSceneId, eKeypadSceneId, eGEN_Exp_TumblersId, eACT_BillingId, eNullSceneId, eNullSceneId },
		{ eACT_Credit01, eACT_Credit02, eACT_Credit03, eACT_Credit04, eACT_Creditdone, eACT_Creditbilling, eNullButtonId },
		{ NULL, NULL, NULL, NULL, NULL, NULL, NULL }
	},

	/* ACT_Country Scene */
	{
		{ eNullSceneId, eNullSceneId, eNullSceneId, eNullSceneId },
		{ eACT_Country01, eACT_Country02, eACT_Country03, eNullButtonId },
		{ NULL, NULL, NULL, NULL }
	},

	/* ACT_Billing Scene */
	{
		{ eKeyboardSceneId, eKeypadSceneId, eKeyboardSceneId, eKeyboardSceneId, eKeypadSceneId, eGen_Large_PanelId, eNullSceneId, eNullSceneId },
		{ eACT_Billing01, eACT_Billing02, eACT_Billing03, eACT_Billing04, eACT_Billing05, eACT_Billingdone, eACT_Billingcredit, eNullButtonId },
		{ NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL }
	},

	/* Gen_Large_Panel Scene */
	{
		{ eACT_OnlineId, eACT_OnlineId, eNullSceneId },
		{ eGen_Large_Panel01, eGen_Large_Panel02, eNullButtonId },
		{ NULL, NULL, NULL }
	},

	/* GEN_Exp_Tumblers Scene */
	{
		{ eNullSceneId, eNullSceneId, eNullSceneId },
		{ eGEN_Exp_TumblersMonth, eGEN_Exp_TumblersYear, eNullButtonId },
		{ NULL, NULL, NULL }
	},

	/* GEN_Dob_Tumblers Scene */
	{
		{ eNullSceneId, eNullSceneId, eNullSceneId, eNullSceneId },
		{ eGEN_Dob_TumblersMonth, eGEN_Dob_TumblersDay, eGEN_Dob_TumblersYear, eNullButtonId },
		{ NULL, NULL, NULL, NULL }
	},

	/* GEN_Welcome_Panel Scene */
	{
		{ eACT_Billing_CountryId, eACT_OnlineId, eNullSceneId },
		{ eGen_Welcome_Panel01, eGen_Welcome_Panel02, eNullButtonId },
		{ NULL, NULL, NULL }
	},

	/* ACT_Billing_Country Scene */
	{
		{ eACT_IdId, eACT_IdId, eACT_IdId, eNullSceneId },
		{ eACT_Billing_Country01, eACT_Billing_Country02, eACT_Billing_Country03, eNullButtonId },
		{ NULL, NULL, NULL, NULL }
	},

	/* Anim_Wait Scene */
	{
		{ eNullSceneId },
		{ eNullButtonId },
		{ NULL }
	},

	/* Anim_Connect Scene */
	{
		{ eNullSceneId },
		{ eNullButtonId },
		{ NULL }
	},
	{
		{ eLastSceneId },
		{ eNullButtonId },
		{ NULL }
	}
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\xodash\XODashMain\NTS_Settings.cpp ===
//-------------------------------------------------------------
// Copyright (c) Microsoft Corporation.  All rights reserved
// Author: Natalyp
//-------------------------------------------------------------
#include "std.h"
#include "scene.h"
#include "XBInput.h"
#include "globals.h"
#include "NetConfig.h"


//-------------------------------------------------------------
// Function name	: CNTS_SettingsScene::FrameMove
// Description	    : Handle vertical(1-4 buttons) navigation and horizontal (5-6) navigation
// Return type		: HRESULT 
// Argument         : XBGAMEPAD& GamepadInput
// Argument         : float elapsedTime
//-------------------------------------------------------------
HRESULT CNTS_SettingsScene::FrameMove(XBGAMEPAD& GamepadInput, float elapsedTime )
{
	ASSERT(m_pButtons.size() == 6);
	bool bCallAutoTest = false;
	if(m_nActiveButtonIndex == 4)
	{
		if (GamepadInput.wPressedButtons & XINPUT_GAMEPAD_DPAD_RIGHT || GamepadInput.fX1 == 1)
		{
			m_bVerticalButtons = false;	
		} 
		else if(GamepadInput.wPressedButtons & XINPUT_GAMEPAD_DPAD_UP || GamepadInput.fY1 == 1)
		{
			m_bVerticalButtons = true;	
		}
		else if ( GamepadInput.wPressedButtons & XINPUT_GAMEPAD_DPAD_LEFT || GamepadInput.fX1 == -1)
		{
			bCallAutoTest = true;
		}
		else if (GamepadInput.wPressedButtons & XINPUT_GAMEPAD_DPAD_DOWN ||
			GamepadInput.fY1 == -1)
		{
			bCallAutoTest = true;
		}
	}
	else if(m_nActiveButtonIndex == 5)
	{
		m_bVerticalButtons = false;
		// RRRRgh - forced by PM to add it 
		if(GamepadInput.wPressedButtons & XINPUT_GAMEPAD_DPAD_UP || GamepadInput.fY1 == 1)
		{
			m_bVerticalButtons = true; 
			CPrimitiveScene::SetActiveButton(m_eSceneId == eNTS_SettingsId? eNTS_settingsPPPoE : eNTS_Status04);
			bCallAutoTest = true;
		}
	}
	if(bCallAutoTest)
	{
		AutoTest(GamepadInput);
		return S_OK;
	}
	
	// In Settings screen "Connect" saves new configuration to the hard drive, "Cancel" rollback all recent changes
	if(m_eSceneId == eNTS_SettingsId)
	{
		if(GamepadInput.bPressedAnalogButtons[XINPUT_GAMEPAD_A] || GamepadInput.wPressedButtons & XINPUT_GAMEPAD_START) 
		{
			if(m_nActiveButtonIndex == 4)
			{
				// something wrong with the screen unexpected button
				ASSERT(m_pButtons[m_nActiveButtonIndex]->GetButtonId() == eNTS_settingsConnect);
				g_NetConfig.SaveConfig();
				g_NetConfig.ResetNetworkState();
			}
			else if (m_nActiveButtonIndex == 5)
			{
				// something wrong with the screen unexpected button
				ASSERT(m_pButtons[m_nActiveButtonIndex]->GetButtonId() == eNTS_settingsCancel);
				g_NetConfig.RestoreConfig();
			}
		}
		
		else if (GamepadInput.bPressedAnalogButtons[XINPUT_GAMEPAD_B] || GamepadInput.wPressedButtons & XINPUT_GAMEPAD_BACK) 
		{
			// Back button is pressed, save the changes
			g_NetConfig.SaveConfig();
		}
	}
	return CCellWallScene::FrameMove(GamepadInput, elapsedTime );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\xodash\XODashMain\NTS_Status.cpp ===
//-------------------------------------------------------------
// Copyright (c) Microsoft Corporation.  All rights reserved
// Author: Natalyp
//-------------------------------------------------------------
#pragma once
#include "std.h"
#include "Scene.h"
#include "tgl.h"
#include "materiallibrary.h"
#include "globals.h"
#include "NetConfig.h"
#include "XBInput.h"

static const char szIconFail[] = "Icon_fail";
static const char szIconPass[] = "Icon_pass";
static const char szIconDisable[] = "Icon_untested";

struct ButtonInfo
{
	TCHAR* pText;
	TCHAR* pHelpText;
};



static ButtonInfo sButtonsInfo[] =
{
	{/*szIconFail,*/ _T("STAT_F_CABLE"), _T("HELP_STAT_F_CABLE")},
	{/*szIconPass,*/ _T("STAT_S_CABLE"), _T("HELP_STAT_S_CABLE")},
	{/*szIconDisable,*/ _T("STAT_F_PENDING"), _T("HELP_STAT_F_PENDING")},

	{/*szIconFail,*/ _T("STAT_F_DHCP"), _T("HELP_STAT_F_DHCP")},
	{/*szIconPass,*/ _T("STAT_S_DHCP"), _T("HELP_STAT_S_DHCP")},
	{/*szIconDisable,*/ _T("STAT_F_PENDING"), _T("HELP_STAT_F_PENDING")},

	{/*szIconFail,*/ _T("STAT_F_PPPOE"), _T("HELP_STAT_F_PPPOE")},
	{/*szIconPass,*/ _T("STAT_S_PPPOE"), _T("HELP_STAT_S_PPPOE")},
	{/*szIconDisable,*/ _T("STAT_F_PENDING"), _T("HELP_STAT_F_PENDING")},

	{/*szIconFail,*/ _T("STAT_F_DNS"), _T("HELP_STAT_F_DNS")},
	{/*szIconPass,*/ _T("STAT_S_DNS"), _T("HELP_STAT_S_DNS")},
	{/*szIconDisable,*/ _T("STAT_F_PENDING"), _T("HELP_STAT_F_PENDING")},

	{/*szIconFail,*/ _T("STAT_F_SERVICES"), _T("HELP_STAT_F_SERVICES")},
	{/*szIconPass,*/ _T("STAT_S_SERVICES"), _T("HELP_STAT_S_SERVICES")},
	{/*szIconDisable,*/ _T("STAT_F_PENDING"), _T("HELP_STAT_F_PENDING")},


};


//-------------------------------------------------------------
// Function name	: CNTS_StatusScene::Initialize
// Description	    : 
// Return type		: HRESULT 
// Argument         : char* pUrl
// Argument         : char* pButtonTextName
// Argument         : eSceneId eCurSceneId
// Argument         : bool bAutoTest
//-------------------------------------------------------------
HRESULT CNTS_StatusScene::Initialize(char* pUrl, char* pButtonTextName,  eSceneId eCurSceneId, bool bAutoTest)
{
	HRESULT hr = CNTS_SettingsScene::Initialize(pUrl, pButtonTextName, eCurSceneId, bAutoTest);
	if(FAILED(hr))
	{
		DbgPrint("CNTS_StatusScene::Initialize - failed to init base class hr = 0x%x\n", hr);
		return hr;
	}

	for(size_t i = 0; i<m_pButtons.size(); i++)
	{
		SetIcon(i,eDisableIcon);
	}
	m_nNetworkStatus = -1;
	m_bFinalState = false;
	UpdateScene();
	return hr;
}



//-------------------------------------------------------------
// Function name	: CNTS_StatusScene::SetIcon
// Description	    : Choose on of the three available icons(pass, fail, pending)
//                    and hide the rest two icons
// Return type		: void 
// Argument         : int nIndex
// Argument         : long eStatus
// Argument         : bool bDHCP
//-------------------------------------------------------------
void CNTS_StatusScene::SetIcon(int nIndex, long eStatus, bool bDHCP/*=true*/, bool bShowText/*=true*/)
{
	ASSERT(nIndex >= 0 && nIndex < (int) m_pButtons.size());
	// first four buttons are dynamic
	if(nIndex < 0 || nIndex >= 4)
	{
		return;
	}
	int nButtonInfoIndex = 0;
	switch (nIndex)
	{
	case 0:
		nButtonInfoIndex = 0;
		break;
	case 1:
		bDHCP? nButtonInfoIndex = 1 : nButtonInfoIndex = 2;
		break;
	case 2:
    case 3:
		nButtonInfoIndex = nIndex+1;
		break;
	default:
		ASSERT(false);
	}

	nButtonInfoIndex = nButtonInfoIndex*3+eStatus;
	TG_Shape* pRoot = const_cast<TG_Shape*> (m_pButtons[nIndex]->GetShape());
	TG_Shape* pFailIcon = pRoot->FindObject(szIconFail);
	TG_Shape* pSuccessIcon = pRoot->FindObject(szIconPass);
	TG_Shape* pDisableIcon = pRoot->FindObject(szIconDisable);
	ASSERT(pFailIcon && pSuccessIcon && pDisableIcon);
	if(!pFailIcon || !pSuccessIcon || !pDisableIcon)
	{
		return;
	}

	pFailIcon->setVisible(false);
	pSuccessIcon->setVisible(false);
	pDisableIcon->setVisible(false);

	switch (eStatus)
	{
	case eFailIcon:
		pFailIcon->setVisible(true);
		break;
	case eSuccessIcon:
		pSuccessIcon->setVisible(true);
		break;
	case eDisableIcon:
		if(bShowText)
		{
			pDisableIcon->setVisible(true);
		}
		break;
	default:
		ASSERT(0);
	}

	m_pButtons[nIndex]->SetTextId(sButtonsInfo[nButtonInfoIndex].pText);
	m_pButtons[nIndex]->SetHelpText(sButtonsInfo[nButtonInfoIndex].pHelpText);
	CText* pText = const_cast<CText*> (m_pButtons[nIndex]->GetTextObject());
	pText -> Show(bShowText);

}


//-------------------------------------------------------------
// Function name	: CNTS_StatusScene::FrameMove
// Description	    : Get the current network status, change the icons and focus as appropriate                 
// Return type		: HRESULT 
// Argument         : XBGAMEPAD& GamepadInput
// Argument         : float elapsedTime
//-------------------------------------------------------------
HRESULT CNTS_StatusScene::FrameMove(XBGAMEPAD& GamepadInput, float elapsedTime )
{
	UpdateScene();
	// while we are not done, allow to navigate back only
	if(!m_bFinalState)
	{
		if(GamepadInput.bPressedAnalogButtons[XINPUT_GAMEPAD_B] ||
		   GamepadInput.wPressedButtons & XINPUT_GAMEPAD_BACK)	
		 
		{
			return CNTS_SettingsScene::FrameMove(GamepadInput, elapsedTime);		
		}

		AutoTest(GamepadInput);
		CCellWallScene::CellWallRotate(GamepadInput);
		return S_OK;
	}
	return CNTS_SettingsScene::FrameMove(GamepadInput, elapsedTime);
}


//-------------------------------------------------------------
// Function name	: CNTS_StatusScene::UpdateScene
// Description	    : discover current Network state and update 
//                    presentation if necessary
//					  For a transit state (e.g eCablePass) hide all the following stages data
// Return type		: void 
//-------------------------------------------------------------
void CNTS_StatusScene::UpdateScene()
{
	eNetworkState eCurState = g_NetConfig.CheckNetworkStatus();
	if (m_nNetworkStatus != eCurState)
	{
		m_nNetworkStatus = eCurState;
		for(size_t i = 0; i<m_pButtons.size(); i++)
		{
			 SetIcon(i,eDisableIcon, true, false);
		}
		switch(eCurState)
		{
		case eCableFail: // final state
			for(size_t i=0; i< m_pButtons.size(); i++)
			{
				SetIcon(i, eFailIcon);
			}
			DbgPrint ("CNTS_StatusScene::UpdateScene - network state: Cable fail\n");
			break;

		case eCablePass: // transit state, continue
			SetIcon(0, eSuccessIcon);
			CPrimitiveScene::SetActiveButton(eNTS_Status02);
			SetIcon(1,eDisableIcon);
			DbgPrint ("CNTS_StatusScene::UpdateScene - network state: Cable pass\n");
			break;

		case eIPPass: // transit state, continue
			SetIcon(0, eSuccessIcon);
			SetIcon(1, eSuccessIcon);
			SetIcon(2,eDisableIcon);
			CPrimitiveScene::SetActiveButton(eNTS_Status03);
			DbgPrint ("CNTS_StatusScene::UpdateScene - network state: IP pass\n");
			break;

		case eDNSFail: // final state
			CPrimitiveScene::SetActiveButton(eNTS_Status03); // highlight the failed state
			SetIcon(0, eSuccessIcon);
			SetIcon(1, eSuccessIcon);
			SetIcon(2, eFailIcon);
			SetIcon(3, eFailIcon);
			m_bFinalState = true;
			DbgPrint ("CNTS_StatusScene::UpdateScene - network state: DNS fail\n");
			break;

		case eServiceFail:  // final state
			CPrimitiveScene::SetActiveButton(eNTS_Status04);
			SetIcon(0, eSuccessIcon);
			SetIcon(1, eSuccessIcon);
			SetIcon(2, eSuccessIcon);
			SetIcon(3, eFailIcon);
			m_bFinalState = true;
			DbgPrint ("CNTS_StatusScene::UpdateScene - network state: Service fail\n");
			break;

		case eDone:  //final state 
			CPrimitiveScene::SetActiveButton(eNTS_Status06);
			for(size_t i = 0; i<m_pButtons.size(); i++)
			{
				SetIcon(i,eSuccessIcon);
			}
			m_bFinalState = true;
			DbgPrint ("CNTS_StatusScene::UpdateScene - network state: Connected\n");
			break;
		default:
			break;
		}
		
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\xodash\XODashMain\Scene.cpp ===
///////////////////////////////////////////////////////////////////////////////
// CPrimitiveScene.h
// base class for all individual screens.
// This class holds all the geometry, plus lists of interactive objects
// all individual screens should derive from this object
//////////////////////////////////////////////////////////////////////////////
#include "std.h"



#include "Scene.h"
#include "XBInput.h"
#include "globals.h"

#include "SceneNavigator.h"
#include "xodash.h"

HRESULT CScene::Initialize(char* pUrl, char* pButtonTextUrl, eSceneId eCurSceneId, bool bAutoTest)
{
	HRESULT hr = CPrimitiveScene::Initialize(pUrl, pButtonTextUrl, eCurSceneId, bAutoTest);
	if (FAILED(hr))
	{
		DbgPrint("CScene::Initialize fail to init CPrimitiveScene");
		return hr;
	}
	
	vector <eButtonId> ButtonIds;
	for (size_t i = 0; i< m_pButtons.size(); i++)
	{
		ButtonIds.push_back(m_pButtons[i]->GetButtonId());
	}

	vector<ButtonCallBack> pfnCallBack;
	CSceneNavigator::Instance()->GetButtonsCallBack(eCurSceneId, ButtonIds, &pfnCallBack); 
	for (size_t i = 0; i< m_pButtons.size(); i++)
	{
		m_pButtons[i]->SetCallback(pfnCallBack[i]);
	}

	hr = BindData();

	if(bAutoTest)
	{
		AutoTest(eSceneInit);
	}
    return S_OK;
}

CScene::CScene() :CPrimitiveScene()
{

}

CScene::~CScene()
{
	CPrimitiveScene::Cleanup();
}


HRESULT CScene::FrameMove(XBGAMEPAD& GamepadInput, float elapsedTime )
{
	HRESULT hr = CPrimitiveScene::FrameMove(GamepadInput, elapsedTime);
	if(FAILED(hr))
	{
		DbgPrint("CScene::FrameMove - Fail in CPrimitiveScene::FrameMove");
		return hr;
	}

	if(GamepadInput.bPressedAnalogButtons[XINPUT_GAMEPAD_A] || 
	   GamepadInput.wPressedButtons & XINPUT_GAMEPAD_START)
	{
		DbgPrint("CPrimitiveScene::FrameMove - Scene:%s, A/START is pressed\n", SceneName[m_eSceneId]);

		eButtonId eActiveButton = eNullButtonId;
		if (!m_pButtons.empty())
		{
			eActiveButton = m_pButtons[m_nActiveButtonIndex]->GetButtonId();
		}

        eSoundType  soundType = m_pButtons[m_nActiveButtonIndex]->GetSoundType();  
        eSound sound = eSoundAPress; 
      
        if ( m_pButtons[m_nActiveButtonIndex]->GetState() == eButtonDisabled 
            || m_pButtons[m_nActiveButtonIndex]->GetState() == eButtonDisabledHighlighted )
        {
            sound = eSoundDisabled;     
        }
        else
        {
      		CSceneNavigator::Instance()->MoveNextScene(eActiveButton);
       		hr = XBAPPWRN_SCENE_CHANGED;
        }

        PlaySound( soundType, sound );

 
		// scene is destroyed by now do not touch any private data
		return hr;
	}

	else if(GamepadInput.bPressedAnalogButtons[XINPUT_GAMEPAD_B] ||
	   GamepadInput.wPressedButtons & XINPUT_GAMEPAD_BACK)
	{
		DbgPrint("CPrimitiveScene::FrameMove - Scene:%s, B/BACK is pressed\n", SceneName[m_eSceneId]);
        
        eSoundType  soundType = m_pButtons[m_nActiveButtonIndex]->GetSoundType();
        PlaySound( soundType, eSoundBPress );

		CSceneNavigator::Instance()->MovePreviousScene();
		// scene is destroyed by now do not touch any private data
		hr = XBAPPWRN_SCENE_CHANGED;
		return hr;
	}
	return hr;
}


HRESULT CScene::RenderGradientBackground( DWORD dwTopColor, 
                                                  DWORD dwBottomColor )
{
    // First time around, allocate a vertex buffer
    static LPDIRECT3DVERTEXBUFFER8 g_pVB  = NULL;
    if( g_pVB == NULL )
    {
        g_pd3dDevice->CreateVertexBuffer( 4*5*sizeof(FLOAT), D3DUSAGE_WRITEONLY, 
                                          0L, D3DPOOL_DEFAULT, &g_pVB );
        struct BACKGROUNDVERTEX { D3DXVECTOR4 p; D3DCOLOR color; };
        BACKGROUNDVERTEX* v;
        g_pVB->Lock( 0, 0, (BYTE**)&v, 0L );
        v[0].p = D3DXVECTOR4(   0,   0, 1.0f, 1.0f ); v[0].color = dwTopColor;
        v[1].p = D3DXVECTOR4( 640,   0, 1.0f, 1.0f ); v[1].color = dwTopColor;
        v[2].p = D3DXVECTOR4(   0, 480, 1.0f, 1.0f ); v[2].color = dwBottomColor;
        v[3].p = D3DXVECTOR4( 640, 480, 1.0f, 1.0f ); v[3].color = dwBottomColor;
        g_pVB->Unlock();
    }

    // Set states
    g_pd3dDevice->SetTexture( 0, NULL );
    g_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP, D3DTOP_DISABLE );
    g_pd3dDevice->SetRenderState( D3DRS_ZENABLE, FALSE ); 
    g_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE ); 
    g_pd3dDevice->SetVertexShader( D3DFVF_XYZRHW|D3DFVF_DIFFUSE );
    g_pd3dDevice->SetStreamSource( 0, g_pVB, 5*sizeof(FLOAT) );

    g_pd3dDevice->DrawPrimitive( D3DPT_TRIANGLESTRIP, 0, 2 );

    // Clear the zbuffer
    g_pd3dDevice->Clear( 0, NULL, D3DCLEAR_ZBUFFER|D3DCLEAR_STENCIL, 0x00000000, 1.0f, 0L );

    return S_OK;
}


void CScene::SetFocus()
{
	// no buttons, nothing to set focus to
	if(!m_pButtons.size() || m_eSceneId == eNullButtonId)
	{
		return;
	}
	eButtonId eFocusButton = CSceneNavigator::Instance()->GetFocus(m_eSceneId);
	

	if(eFocusButton != eNullButtonId)
	{
		int nIndex = FindButton(eFocusButton);
		// Navigator is absolutely out of sync with the scene
		ASSERT(nIndex != -1);
		if(nIndex !=-1 && m_pButtons[nIndex]->IsShowing())
		{
			SetActiveButton(eFocusButton);
			return;
		}		
	}

	CPrimitiveScene::SetFocus();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\xodash\XODashMain\Scene.h ===
///////////////////////////////////////////////////////////////////////////////
// Scene.h
// base class for all individual screens.
// This class holds all the geometry, plus lists of interactive objects
//////////////////////////////////////////////////////////////////////////////
#pragma once

#include "std.h"
#include "Node.h"
#include "camera.h"
#include "StringObj.h"
#include "XOConst.h"
#include "SmartObject.h"
#include "XBStopWatch.h"
#include "Audio.h"
#include "PrimitiveScene.h"

#include <vector>

using namespace std;

class TG_Shape;
class CText;
class FitIniFile;

struct XBGAMEPAD;




// this separation is reqired for AseConv to detach SceneNavigator from Scene
class CScene: public CPrimitiveScene
{
public:
	CScene();
	virtual ~CScene();
	HRESULT Initialize(char* pUrl, char* pButtonTextName,  eSceneId eCurSceneId, bool bAutoTest = true);
	HRESULT FrameMove(XBGAMEPAD& GamepadInput, float elapsedTime );
	virtual HRESULT BindData() {return S_OK;}
	virtual void SetFocus();
	static HRESULT RenderGradientBackground( DWORD dwTopColor, 
                                                  DWORD dwBottomColor );
};


typedef vector <CButton*> CharRowVector;
typedef vector <CharRowVector*> Keyboard;


class CKeyboardScene :public CScene 
{
public:
	HRESULT FrameMove(XBGAMEPAD& GamepadInput, float elapsedTime );
	CKeyboardScene();
	HRESULT Initialize(char* pUrl, char* pButtonTextName, eSceneId eCurSceneId, bool bAutoTest = true);
	virtual ~CKeyboardScene();
	HRESULT Cleanup();
	void Dump(bool bAllData = false);
	inline void SetTitle(CText* pText) {ASSERT(pText); m_pTitleText =	pText;}
	void AutoTest(eAutoTestData eState);

private:

	int m_nActiveRow;     // row number of highlighted button - zero based
	int m_nActiveColumn;  // column number of highlighted button - zero based
	int m_nRealPosition;  // real (column) position - required for navigation since rows have different number of columns
	

	bool m_bCapitalActive;  // if Capital characterset is active or not
	bool m_bAccentActive;   // Accents are active
	bool m_bSymbolsActive;  // Symbols are active
	bool m_bShiftActive;    // Shift is active

	CText* m_pInputText;    // accumulate the input here
	CText* m_pTitleText;    // Title for the keyboard - different for different screens
	Keyboard m_pKeyboard;   
	vector<CText*> m_pSymbols; // characters only
	int m_nActiveCharSetIndex; // there are three character sets: letters, symbols, accents
	CAudioClip m_AudioClip;    // play sound based on input

private:
	void MoveUp();
	void MoveDown();
	void MoveLeft();
	void MoveRight();
	HRESULT PressedA();
	void PressedX();
	HRESULT BuildKeyboard();
	void SetCharacterSet();
	void FindControlButton(eButtonId eButton, int* pnRow, int* pnCol);
	static WCHAR  ToLower( WCHAR c );
	static WCHAR  ToUpper( WCHAR c );
	void UpdateInputText(CText* pCurText);
	bool m_bResetInput; 

};

typedef vector <CharRowVector*> Keypad;

class CKeypadScene :public CScene 
{
public:
    CKeypadScene(bool keypadPeriod);
    virtual ~CKeypadScene();

	HRESULT FrameMove(XBGAMEPAD& GamepadInput, float elapsedTime );
	HRESULT Initialize(char* pUrl, char* pTextButtonUrl, eSceneId eCurSceneId, bool bAutoTest = true);
	HRESULT Cleanup();
	void Dump(bool bAllData = false);
	inline void SetTitle(CText* pText) {ASSERT(pText); m_pTitleText =	pText;}
	void AutoTest(eAutoTestData eState);

private:

	int m_nActiveRow;     // row number of highlighted button - zero based
	int m_nActiveColumn;  // column number of highlighted button - zero based
	int m_nRealPosition;  // real (column) position - required for navigation since rows have different number of columns
    bool m_bkeypadPeriod;

	CText* m_pInputText;    // accumulate the input here
	CText* m_pTitleText;    // Title for the keyboard - different for different screens
	Keypad m_pKeypad;   

private:
	void MoveUp();
	void MoveDown();
	void MoveLeft();
	void MoveRight();
	HRESULT PressedA();
	HRESULT BuildKeypad();
	void UpdateInputText(CText* pCurText);
    void SetCharacterSet();
    bool m_bResetInput;
};

class CCellWallScene :public CScene 
{
public:
	CCellWallScene();
	virtual ~CCellWallScene();
	HRESULT Initialize(char* pUrl, char* pButtonTextName,  eSceneId eCurSceneId, bool bAutoTest = true);
	HRESULT FrameMove(XBGAMEPAD& GamepadInput, float elapsedTime );
	HRESULT Render( DWORD flags );
    virtual void AutoTest(eAutoTestData);
    void AutoTest(XBGAMEPAD& GamepadInput);
	HRESULT Cleanup();
    void    HideText(const char *pName);
    void    HideObject(const char *pName);
	void    RenderSelect(bool renderState);
	void    RenderBack(bool renderState);

protected:
	void CellWallRotate(XBGAMEPAD& GamepadInput);
private:
	static void*       m_pVideoMemCellWall;
	static void*       m_pVideoMemSelect;
	static void*       m_pVideoMemBack;

	static TG_Shape*	s_pCellWallSphere;
	static TG_Shape*	s_pSelectButton;
	static TG_Shape*	s_pBackButton;

	static CText*		m_pSelectText;
    static CText*		m_pBackText;
	bool bRenderSelect;
	bool bRenderBack;

	// Waver member variables
	float m_field;
	DWORD m_dwFrameTick;
	double m_now;

};


class CNTS_StatusScene;
class CNTS: public CCellWallScene
{
public:
	CNTS(bool bHide = true): m_bHideContinue(bHide), m_bEditMode(true) {}
	HRESULT BindData();
	HRESULT SetValue(const TCHAR*);
	const TCHAR* GetValue(eButtonId);
	HRESULT FrameMove(XBGAMEPAD& GamepadInput, float elapsedTime );

private:
	void SetButtonsState(const TCHAR* szValue);	
	bool m_bEditMode;
	bool m_bHideContinue;
};

class CNTS_ConfigChoice: public CCellWallScene
{
public:
	HRESULT Initialize(char* pUrl, char* pButtonTextName,  eSceneId eCurSceneId, bool bAutoTest = true);
	HRESULT FrameMove(XBGAMEPAD& GamepadInput, float elapsedTime );
};

class CNTS_SettingsScene :public CCellWallScene
{
public:
	HRESULT FrameMove(XBGAMEPAD& GamepadInput, float elapsedTime );
};

class CNTS_StatusScene :public CNTS_SettingsScene
{
public:
	HRESULT Initialize(char* pUrl, char* pButtonTextName,  eSceneId eCurSceneId, bool bAutoTest = true);
	HRESULT FrameMove(XBGAMEPAD& GamepadInput, float elapsedTime );
private:
	void SetIcon(int nIndex, long eStatus, bool bDHCP=true, bool bHideText = true);
	void UpdateScene();

	long m_nNetworkStatus;
	bool m_bFinalState;
};

class CNTSHelpScene: public CCellWallScene
{
public:
	HRESULT Initialize(char* pUrl, char* pButtonTextName,  eSceneId eCurSceneId, bool bAutoTest = true);
};

// online main menu scene, probalby poorly named
class CACT_OnlineScene :public CCellWallScene
{
public:
	HRESULT FrameMove(XBGAMEPAD& GamepadInput, float elapsedTime );
  	virtual HRESULT Initialize(char* pUrl, char* pButtonTextName,  eSceneId eCurSceneId, bool bAutoTest = true);
    static HRESULT AttemptMachineLogon();

private:

    static HRESULT m_hrLogon;


};

// base class for all scene's that use account data
class CACT_Scene :public CCellWallScene
{
public:
  	virtual HRESULT Initialize(char* pUrl, char* pButtonTextName,  eSceneId eCurSceneId, bool bAutoTest = true);
	HRESULT FrameMove(XBGAMEPAD& GamepadInput, float elapsedTime );
    
    void UpdateButtons();
    HRESULT Validate( eButtonId id, const TCHAR* szValue );
    HRESULT SetValue(const TCHAR* szValue);


};

class CACT_SignupAccount :public CACT_Scene
{
public:
    CACT_SignupAccount();
    virtual ~CACT_SignupAccount();

    virtual HRESULT Initialize(char* pUrl, char* pButtonTextUrl,  eSceneId eCurSceneId, bool bAutoTest);
	HRESULT FrameMove(XBGAMEPAD& GamepadInput, float elapsedTime );

private:
    static bool  m_bDisplayParentMessage;
    static int   m_nSignupAge;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\xodash\XODashMain\SceneNavigator.cpp ===
#include "std.h"
#include "SceneNavigator.h"
#include "XOConst.h"
#include "Scene.h"
#include "utilities.h"
#include "AccountData.h"
#include "NavigationMap.cpp"
#include "NavigationDesc.cpp"
#include "NavigationExit.cpp"

#include "MsgDialog.h"
#include "xlaunch.h"

// for DbgPrint buffer 
#define MAX_BUF_LEN 200 
extern "C" PLAUNCH_DATA_PAGE* LaunchDataPage;

CSceneNavigator::CSceneNavigator() :
	m_pCurrentScene (NULL),
	m_nStackTop(0),
	m_eCurrentSceneId (eNullSceneId),
	m_bLaunchFromTitle(false),
	m_dwTitleID(0),
    m_dwLaunchReason(0),
    m_dwLaunchContext(0),
    m_dwLaunchParameter1(0),
    m_dwLaunchParameter2(0)
	{}



HRESULT CSceneNavigator::CreateScene(eSceneId eNewScene, bool bCreateNew)
{
	HRESULT hr = S_OK;
	
	CPrimitiveScene* pNewScene = NULL;
	if(bCreateNew)
	{
		// little class factory for different scenes  
		switch(eNewScene)
		{
		case eKeyboardSceneId:
			pNewScene = new CKeyboardScene;
			break;
		case eKeypadSceneId:
			pNewScene = new CKeypadScene(false);
			break;
		case eKeypadPeriodSceneId:
			pNewScene = new CKeypadScene(true);
			break;
		case eCellWallSceneId:
		case eNTS_CableHelpId:
		case eNTS_PPPoEHelpId:
		case eNTS_IPHelpId:
		case eNTS_DNSHelpId:
		case eNTS_ServicesHelpId:
			pNewScene = new CCellWallScene;
			break;
		case eNTS_SettingsId:
			pNewScene = new CNTS_SettingsScene;
			break;
		case eNTS_StatusId:
			pNewScene = new CNTS_StatusScene;
			break;
		case eNTS_HostnameId:
		case eNTS_PPPoEId:
		case eNTS_IPId:
		case eNTS_DNSId:
			pNewScene = new CNTS;
			break;
		case eNTS_HostnameTSId:
		case eNTS_PPPoETSId:
		case eNTS_DNSTSId:
			pNewScene = new CNTS(false);
			break;
        case eACT_OnlineId:
            pNewScene = new CACT_OnlineScene;
            break;
        case eMsgBoxSceneId:
            pNewScene = new CMsgDialog;
            break;
        case eProgressBarSceneId:
            pNewScene = new CProgressDialog;
            break;
		case eNTS_ConfigChoiceId:
			pNewScene = new CNTS_ConfigChoice;
			break;
        case eACT_IdId:
        case eACT_CreditId:
        case eACT_CountryId:
        case eACT_Billing_CountryId:
        case eACT_BillingId:
        case eGEN_Exp_TumblersId:
        case eGen_Large_PanelId:
        case eGEN_Dob_TumblersId:
        case eGEN_Welcome_PanelId:
            pNewScene = new CACT_SignupAccount;
            break;
        case eAnimWait:
        case eConnectAnim:
            pNewScene = new CWaitCursor;
            break;
		default:
			pNewScene = new CScene;

		};
		
		DbgPrint("Moving to %s Scene, url %s\n", SceneName[eNewScene], m_SceneDataMap[eNewScene].m_url);
		if(!pNewScene)
		{
			hr = E_OUTOFMEMORY;
			return hr;
		}

		hr = pNewScene->Initialize(m_SceneDataMap[eNewScene].m_url, m_SceneDataMap[eNewScene].m_buttonTextUrl,  eNewScene);
		if(FAILED(hr))
		{
			DbgPrint("CSceneNavigator::Initialize - failed to Init the Scene %s", SceneName[eNewScene]);
			return hr;
		}
	}
	else
	{
		pNewScene = m_SceneDataMap[m_FlowStack[m_nStackTop]].m_pScene;
	}

	// remove previous scene if exists 
	if(m_pCurrentScene)
	{
		// if the current scene is not visible on deactive (i.e. no other screens supposed to be on top)
		//  or if it is visible, but we move
		// to any scene that is not keyboard, keypad or dialog, we need to release the current scene
		if(!m_SceneDataMap[m_eCurrentSceneId].m_bVisibleOnDeactive ||
			
			(m_SceneDataMap[m_eCurrentSceneId].m_bVisibleOnDeactive && 
            !IsDialogScene( eNewScene ) )
			)
		{	
			delete m_pCurrentScene;
			m_SceneDataMap[m_eCurrentSceneId].m_pScene = NULL;
		}
		else
		{
			// the only scenes which are allowed to be on top of another one
			if(!IsDialogScene( eNewScene ))
			{
				ASSERT(false);
			}
		}
	}

	m_pCurrentScene = pNewScene;
	m_eCurrentSceneId = eNewScene;
	m_SceneDataMap[eNewScene].m_pScene = m_pCurrentScene;
	
	return hr;

}

HRESULT CSceneNavigator::Initialize()
{
	HRESULT hr = S_OK;
	m_nStackTop = 0;

	DWORD dwLaunchType = 0 ;
	LAUNCH_DATA ld;
	ZeroMemory(&ld, sizeof(ld));

// Retrieve the launch data, if any
    if (*LaunchDataPage && (*LaunchDataPage)->Header.dwLaunchDataType == LDT_LAUNCH_DASHBOARD) 
	{
        PLD_LAUNCH_DASHBOARD pLaunchDashboard =
            (PLD_LAUNCH_DASHBOARD) ((*LaunchDataPage)->LaunchData);

        m_dwTitleID = (*LaunchDataPage)->Header.dwTitleId;
        m_dwLaunchReason = pLaunchDashboard->dwReason;
        m_dwLaunchContext = pLaunchDashboard->dwContext;
        m_dwLaunchParameter1 = pLaunchDashboard->dwParameter1;
        m_dwLaunchParameter2 = pLaunchDashboard->dwParameter2;

        PLAUNCH_DATA_PAGE pTemp = *LaunchDataPage;
        *LaunchDataPage = NULL;
        MmFreeContiguousMemory(pTemp);
    	
		m_bLaunchFromTitle = true;
		DbgPrint("CSceneNavigator::Initialize - Reason = [%d]\n", m_dwLaunchReason);
	}
	
	eSceneId eFirstScene = FindEntryPoint();
	DbgPrint("SceneId = [%d], name = [%s]\n", eFirstScene, SceneName[eFirstScene]);

	m_FlowStack[m_nStackTop] = eFirstScene;
	m_eCurrentSceneId = eFirstScene;
	hr = CreateScene(eFirstScene);
	return hr;
}

eSceneId CSceneNavigator::FindEntryPoint()
{
	eSceneId eFirstScene;
	switch(m_dwLaunchReason)
	{
	case XLD_LAUNCH_DASHBOARD_NETWORK_CONFIGURATION:
		eFirstScene = eNTS_ConfigChoiceId;
		break;

	case XLD_LAUNCH_DASHBOARD_NEW_ACCOUNT_SIGNUP:        
		eFirstScene = eGEN_Welcome_PanelId;
		break;

	case XLD_LAUNCH_DASHBOARD_MESSAGE_SERVER_INFO:
	case XLD_LAUNCH_DASHBOARD_POLICY_DOCUMENT:
	case XLD_LAUNCH_DASHBOARD_ONLINE_MENU:
	case XLD_LAUNCH_DASHBOARD_FORCED_NAME_CHANGE:
	case XLD_LAUNCH_DASHBOARD_FORCED_BILLING_EDIT:
		eFirstScene = eACT_OnlineId;
		break;
	default:
		eFirstScene = eACT_OnlineId;
	}
	return eFirstScene;	
}


void CSceneNavigator::Dump(bool bAllData)
{	
#ifdef DEBUG
	ValidateData();
#endif
	if(bAllData)
	{
		DbgPrint("=============================================================\n");
		DbgPrint("SceneNavigator Dump\n");
		DbgPrint("=============================================================\n");
		DbgPrint("Dump m_SceneHierarchy\n");
		
		int nLen = countof(m_SceneHierarchy);

		int nSceneNameSize = countof(SceneName);
		int nButtonNameSize = countof(ButtonName);

		for (int i = 0; m_SceneHierarchy[i].m_Children[0]!= eLastSceneId ; i++)
		{
			DbgPrint("\nScene: [%s]\n\tChildren:\n\t\t", SceneName[i]);
			
			for(int j =0 ; m_SceneHierarchy[i].m_Children[j]!= eNullSceneId; j++)
			{
			  DbgPrint("%s   ", SceneName[m_SceneHierarchy[i].m_Children[j]]);
			}
			if(j == 0)
			{
				DbgPrint("[null]");
			}

			DbgPrint("\n\tButtons: \n\t\t");
			for(int j =0 ; m_SceneHierarchy[i].m_ButtonId[j]!= eNullButtonId; j++)
			{
			  DbgPrint("%s   ", ButtonName[m_SceneHierarchy[i].m_ButtonId[j]]);
			}
			if(j == 0)
			{
				DbgPrint("[null]");
			}
		}
	}
	DbgPrint("Flow stack\n");

	for(int j = m_nStackTop ; j >= 0; j--)
	{
		DbgPrint("%d [Scene = %s]\n", m_FlowStack[j], SceneName[m_FlowStack[j]]);	
	}
	DbgPrint("\n=============================================================\n");
			
}


#ifdef DEBUG
void CSceneNavigator::ValidateData()
{
	DbgPrint("++++++++++++++++++++++++++++++++++++++++\n");
	DbgPrint("Validating CSceneNavigator data ...\n");
	// check that number of buttons = number of callbacks

	for (int i = 0; m_SceneHierarchy[i].m_Children[0]!= eLastSceneId ; i++)
	{
		for(int nChild =0 ; m_SceneHierarchy[i].m_Children[nChild]!= eNullSceneId; nChild++)
			; // empty loop		

		for(int nButton =0 ; m_SceneHierarchy[i].m_ButtonId[nButton]!= eNullButtonId; nButton++)
				; //empty loop 
	//TBD BACK	ASSERT(nChild == nButton); 
	}
	
	// check that all children scenes are present in the SceneName[]
	// check that all buttons are present in the ButtonName[]
	int nSceneNameSize = countof(SceneName);
	int nButtonNameSize = countof(ButtonName);
	for (int i = 0; m_SceneHierarchy[i].m_Children[0]!= eLastSceneId ; i++)
	{
		for(int j =0 ; m_SceneHierarchy[i].m_Children[j]!= eNullSceneId; j++)
		{
			ASSERT(m_SceneHierarchy[i].m_Children[j] < nSceneNameSize);
		}
		
		for(int j =0 ; m_SceneHierarchy[i].m_ButtonId[j]!= eNullButtonId; j++)
		{
		  ASSERT(m_SceneHierarchy[i].m_ButtonId[j] < nButtonNameSize); 
		}
			
	}

}
#endif



void CSceneNavigator::GetButtonsCallBack(
			eSceneId SceneId,  vector<eButtonId> ButtonIds, vector<ButtonCallBack> *pFnVec)
{
	ASSERT(SceneId < countof(SceneName));
#ifdef DEBUG
	int nButtonNum = GetButtonNum(SceneId);

// NAT put it back	ASSERT(nButtonNum == ButtonIds.size());
	if(ButtonIds.size()!= nButtonNum)
	{
		DbgPrint("CSceneNavigator::GetButtonsCallBack - mismatch in button number. Fix it!!!\n");
	}
#endif 

	if(SceneId < countof(SceneName))
	{
		int nIndex = 0;
		for(size_t j =0 ; j < ButtonIds.size(); j++)
		{
			
			nIndex = FindButtonIndex(SceneId, ButtonIds[j]);
			if(SceneId!= eKeyboardSceneId && SceneId!= eKeypadSceneId && SceneId!= eKeypadPeriodSceneId 
				&& SceneId!= eNTS_ConfigChoiceId)
			{
				// DO NOT REMOVE THIS ASSERT, VERIFY THAT THE NUMBER OF BUTTONS YOU SPECIFY IN 
			// NAVIGATION MAP IS THE SAME AS NUMBER OF LINKS TO DIFFERENT SCENES. ALL SCENES
			// IN THE IF CONDITION ARE SPECIAL CASES, FOR EXAMPLE CONFIGCHOICE INCLUDES HIDDEN
			// BUTTONS
				ASSERT(nIndex != -1);
			}
			pFnVec->push_back(m_SceneHierarchy[SceneId].m_fnCallBack[j]);
		}
	}
}

void CSceneNavigator::MoveNextScene(eButtonId eButton)
{
	eSceneId eCurSceneId = m_FlowStack[m_nStackTop];
	
	
	ASSERT(m_nStackTop < MAX_NAVIGATOR_STACK_SIZE);
	ASSERT(eCurSceneId  < countof(SceneName));
	if (m_nStackTop >= MAX_NAVIGATOR_STACK_SIZE)
		return;
	if (eCurSceneId  >= countof(SceneName))
		return;

	int nIndex = FindButtonIndex(eCurSceneId, eButton);
	ASSERT(nIndex != -1);	
	
	// if the Dash is launched by a title and this is an exit point, return back to the title
	if(IsExitPoint(eButton))
	{
		BootToTitle();
	}

	if(nIndex != -1 && m_SceneHierarchy[eCurSceneId].m_Children[nIndex]!=eNullSceneId)
	{
		// save the focus. When navigating back restore the focus as it was before
		m_SceneDataMap[m_eCurrentSceneId].m_eButtonInFocus = eButton;
		eSceneId eNextScene = m_SceneHierarchy[eCurSceneId].m_Children[nIndex];
		// allow self-references. In some cases pressing A on a screen that does not have any further links should
		// leave user on the same screen
		// The default Dash behaviour the user is taken back one screen		
		if(eCurSceneId == eNextScene)
		{
			// do not move anywhere, stay where you are
			return;
		}

		// handle the loops: search the stack for the scene with the same Id, if exists pop up all scenes till you get
		// to the chosen scene
		int nSceneCount = 0;
		for (int nTop = m_nStackTop; nTop >= 0; nTop --)
		{
			// scene could appear not more than one time on the stack
			ASSERT(nSceneCount <=1);
			if(m_FlowStack[nTop] == eNextScene)
			{
				nSceneCount++;
				for (int i = m_nStackTop; i >= nTop; i--)
				{
					// verify why the CScene is left on the stack 
					ASSERT(!m_SceneDataMap[m_FlowStack[nTop]].m_pScene);
					// cleanup the focus history
					m_SceneDataMap[m_FlowStack[i]].m_eButtonInFocus = eNullButtonId;
				}
				m_nStackTop = nTop;
			}

		}
		// otherwise: that's a new scene, push it on the stack
		if(!nSceneCount)
		{
			m_nStackTop ++;
		}
		
	
		m_FlowStack[m_nStackTop] = eNextScene;
		CreateScene(eNextScene);

		
		Dump(false);
	}
	// no more child scenes, come back
	else 
	{
		MovePreviousScene();
	}
	
}

void CSceneNavigator::MovePreviousScene()
{
	if(m_nStackTop <= 0)
	{
		// check if the Dash was launched by a title
		if(m_bLaunchFromTitle)
		{
			BootToTitle();
		}
		return;
	}

	bool bNewScene = true;
	m_nStackTop --;
	// for keyboard and dialogs check if multiple screens are visible. If it's true, do not create new scene
	// just make previous existing scene active
	if(IsDialogScene(m_eCurrentSceneId)) 
	{
		
		ASSERT(m_SceneDataMap[m_FlowStack[m_nStackTop]].m_bVisibleOnDeactive == true 
			&& m_SceneDataMap[m_FlowStack[m_nStackTop]].m_pScene);
		// do not create a new scene, retrieve an existing one
		if(m_SceneDataMap[m_FlowStack[m_nStackTop]].m_pScene)
		{
			bNewScene = false;
		}
	}
	eSceneId eOldScene = m_FlowStack[m_nStackTop];
	HRESULT hr = CreateScene(m_FlowStack[m_nStackTop], bNewScene);
	if (SUCCEEDED(hr))
	{// erase the history after we moved back
		m_SceneDataMap[eOldScene].m_eButtonInFocus = eNullButtonId;
	}
	Dump(false);
}

eSceneId CSceneNavigator::GetSceneId(char* pSceneName)
{
	ASSERT(pSceneName && pSceneName[0]);
	for (int i = 0; i< countof(SceneName); i++)
	{
		if (_stricmp(SceneName[i], pSceneName))
			break;
	}
	if (i == countof(SceneName))
		return eNullSceneId; 
	return static_cast<eSceneId> (i);
}

eButtonId CSceneNavigator::GetButtonId(char* pButtonName)
{
	ASSERT(pButtonName && pButtonName[0]);
	for (int i = 0; i< countof(ButtonName); i++)
	{
		if (_stricmp(ButtonName[i], pButtonName))
			break;
	}
	if (i == countof(ButtonName))
		return eNullButtonId;
	return static_cast<eButtonId> (i);

}

int CSceneNavigator::FindButtonIndex(eSceneId eCurSceneId, eButtonId eButton)
{
	ASSERT(eCurSceneId  < countof(SceneName));
	for(int j =0 ; m_SceneHierarchy[eCurSceneId].m_ButtonId[j]!= eNullButtonId ; j++)
		if(m_SceneHierarchy[eCurSceneId].m_ButtonId[j] == eButton)
		{
			break;
		}

	if (m_SceneHierarchy[eCurSceneId].m_ButtonId[j] == eNullButtonId && eButton!= eNullButtonId)
		return -1;
	return j;
}


int CSceneNavigator::GetButtonNum(eSceneId SceneId)
{
	for(int j =0 ; m_SceneHierarchy[SceneId].m_ButtonId[j]!= eNullButtonId ; j++)
		; //empty loop
	return j;
}

// TBD render all visible scenes
HRESULT CSceneNavigator::Render(DWORD dwFlags)
{
	HRESULT hr = S_OK;
// for keyboards and dialogs, draw the previous scene as well
	if(IsDialogScene(m_eCurrentSceneId) ) 
	{
		// TBD put it back ASSERT(m_nStackTop > 0);

		if(m_nStackTop > 0)
		{
			eSceneId ePrevScene = m_FlowStack[m_nStackTop-1];
			CPrimitiveScene* pPrevScene = m_SceneDataMap[ePrevScene].m_pScene;
            // HKG:  You should be able to render the keyboard by itself if you want
//			ASSERT(pPrevScene);
			if(pPrevScene)
			{
				pPrevScene->Render(dwFlags);
			}
		}
		CScene::RenderGradientBackground( 0xcc000000, 0xcc000000);
	}
	
	m_pCurrentScene->Render(dwFlags);
	return hr;
}


CSceneNavigator* CSceneNavigator::Instance () 
{
	if (pinstance == 0)  // is it the first call?
	{  
		pinstance = new CSceneNavigator; // create sole instance
	}
	return pinstance; // address of sole instance
}


HRESULT CSceneNavigator::Cleanup()
{
// TBD check what else to remove
	HRESULT hr = S_OK;
	delete m_pCurrentScene;
	m_pCurrentScene = NULL;
	return hr;
}


eButtonId CSceneNavigator::GetFocus(eSceneId SceneId)
{
	ASSERT(SceneId != eNullSceneId && SceneId < countof(SceneName));
	
	return m_SceneDataMap[SceneId].m_eButtonInFocus;

}

static float fTotalElapsed = 0;
static bool bFirstTime = true;
HRESULT CSceneNavigator::FrameMove(XBGAMEPAD& GamepadInput, float fElapsedTime)
{
	HRESULT hr = S_OK;
	ASSERT(m_pCurrentScene);
	hr = m_pCurrentScene->FrameMove(GamepadInput, fElapsedTime);

	fTotalElapsed+=fElapsedTime;
	if (fTotalElapsed > 2.0f && !bFirstTime)
	{
//		CreateScene(eKeypadPeriodSceneId);
//		CreateScene(eKeyboardSceneId);
//		CreateScene(eNTS_SettingsId);
// CreateScene(eKeyboardSceneId);
		fTotalElapsed = 0;
	}
	bFirstTime = false;
	return hr;
}


HRESULT CSceneNavigator::RunDialog(MSGPARAMETERS* pData)
{
	HRESULT hr = S_OK;

	m_nStackTop ++;
	m_FlowStack[m_nStackTop] = pData->m_SceneID;
	hr = CreateScene(pData->m_SceneID);

    if ( SUCCEEDED( hr ) )
    {

	    // TBD set all dialog data 

        // NATALY -- I really don't know what I'm doing here ... feel free to change this
        CMsgDialog* pDialog = (CMsgDialog*)m_SceneDataMap[m_FlowStack[m_nStackTop]].m_pScene;
        pDialog->SetParameters( *pData );
    }
	return hr;
}

HRESULT CSceneNavigator::CleanupDialog()
{
	HRESULT hr = S_OK;
	MovePreviousScene();
	return hr;
}

bool    CSceneNavigator::IsDialogScene( eSceneId SceneId )
{
    if (
    SceneId == eKeyboardSceneId ||
    SceneId == eKeypadSceneId ||
    SceneId == eKeypadSceneId ||
    SceneId == eKeypadPeriodSceneId ||
    SceneId == eProgressBarSceneId ||
    SceneId == eMsgBoxSceneId ||
    SceneId == eAnimWait )
    {
        return true;
    }

    return false;
}

bool CSceneNavigator::IsExitPoint(eButtonId eButton)
{
	if(!m_bLaunchFromTitle)
	{
		return false;
	}
	for (int i = 0; m_ExitPoint[i].m_ExitPointId != eLastSceneId; i++)
	{
		if(m_ExitPoint[i].m_dwReason == m_dwLaunchReason 
			&& m_ExitPoint[i].m_ExitPointId == m_eCurrentSceneId
			&& m_ExitPoint[i].m_ButtonId == eButton)
		{
			return true;
		}

	}
	return false;
}

void CSceneNavigator::BootToTitle()
{
	// do not boot anywhere if the Dash was not boot from a title
	ASSERT(m_bLaunchFromTitle);
	if (!m_bLaunchFromTitle)
	{
		return;
	}

	LD_FROM_DASHBOARD ld;
	ZeroMemory(&ld, sizeof(ld));
	ld.dwContext = m_dwLaunchContext;
	DbgPrint("CSceneNavigator::MovePreviousScene - boot back to the title, Context = [%d], DashEntry = [%s]\n",
		m_dwLaunchContext, SceneName[m_eCurrentSceneId]);
	
	XWriteTitleInfoAndReboot("default.xbe", "\\Device\\CdRom0", LDT_FROM_DASHBOARD, m_dwTitleID, (PLAUNCH_DATA)&ld);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\xodash\XODashMain\Socket.h ===
//-------------------------------------------------------------
// Copyright (c) Microsoft Corporation.  All rights reserved
// Author: Natalyp
//-------------------------------------------------------------
#pragma once
#include <xtl.h>
#include "AutomationMsg.h"
#include "XBStopWatch.h"


const int ciTCPServerPort = 10000;      // port open by the TCP server to listen to
const float cfAutomationTimeout = 60.0f; // (in seconds)- if there is no activity in ciAutomationTimeout, client will be disconnected


///////////////////////////////////////////////////////////////
// Class:		CSocket
// Description: CSocket wraps winsock. CSocket implements standard 
// TCP server object. CSocket opnes one non-blocking socket and waits 
// for client to connnect. CSocket allows only one simultaneous connection
// CSocket will shutdown the accepted socket if no traffic discovered
// during predefined period of time
// Usage:		Used by automation tests to simulate input of pereferral device
///////////////////////////////////////////////////////////////
class CSocket
{
public:
	CSocket();
	~CSocket();
	HRESULT InitServer(bool bTCP = true);
	bool ReceiveMessage(CAutomationMsg* pMsg);
	void Close();
	bool IsAutomationActive ();

private:
	HRESULT ProcessMessage();
	HRESULT BindSocket(bool bNonBlocking = true);
	HRESULT InitNetworkStack();
	
private:
	SOCKET m_ListenSocket;
	SOCKET m_AcceptedSocket;
	bool m_bClientConnected;
	CXBStopWatch m_AutomationTimer;

};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\xodash\XODashMain\SceneNavigator.h ===
//-------------------------------------------------------------
// Copyright (c) Microsoft Corporation.  All rights reserved
// Author: Natalyp
//-------------------------------------------------------------
#pragma once 

#include "StringObj.h"
#include "XOConst.h"
#include "PrimitiveScene.h"
#include <vector>
 
using namespace std;
 
class CScene;
struct XBGAMEPAD;
struct MSGPARAMETERS;

//-------------------------------------------------------------
// Name: SceneDesription
// Purpose: holds relevant data for scene's manipulation
// Description: 
//-------------------------------------------------------------
struct SceneDescription
{
	char m_url[MAX_URL_SIZE];   // xbg file to load art from
    char m_buttonTextUrl[64];   // one xbg could contain more than one screen, this is a tag where to look for 
	// this screen specific data (text, buttons, etc.)inside of the xbg file
	bool m_bVisibleOnDeactive;  // true if the scene should be present when the child scene is active
	CPrimitiveScene* m_pScene;
	eButtonId m_eButtonInFocus;   // keep track of highlighted button, when navigating back highligh this button 
	// instead of the first one

};



//-------------------------------------------------------------
// Name: SceneChild
// Purpose: navigation map for a specific scene
// Description:
//-------------------------------------------------------------
struct SceneChild
{
	eSceneId m_Children[MAX_CHILD_SCENE_NUM];  // screens to navigate to
	eButtonId m_ButtonId[MAX_BUTTON_IN_SCENE]; // highlighted button that caused navigation to different screen
	// has one to one correlation with m_Children
	ButtonCallBack m_fnCallBack[MAX_BUTTON_IN_SCENE];
};

//-------------------------------------------------------------
// Name:	ExitPoint
// Purpose: Define exit points when the dash wash launched by a title
// Description:  
//-------------------------------------------------------------
struct ExitPoint
{
	DWORD m_dwReason;
	eSceneId m_ExitPointId;
	eButtonId m_ButtonId;
};

//-------------------------------------------------------------
// Name: CSceneNavigator
// Purpose: The class is responsible for changing the screens based 
//			on user input and/or server/application conditions
// Description: singleton
//-------------------------------------------------------------
class CSceneNavigator
{
public:
	static CSceneNavigator* Instance();
	HRESULT Initialize();
	HRESULT Cleanup();
	HRESULT Render(DWORD dwFlags);

	HRESULT FrameMove(XBGAMEPAD& , float);
	void Dump(bool bAllData = false);
	void GetButtonsCallBack(eSceneId SceneId, vector<eButtonId> ButtonIds, vector<ButtonCallBack> *pFnVec );
	void MoveNextScene(eButtonId = eNullButtonId);
	void MovePreviousScene();
	eButtonId GetFocus(eSceneId SceneId);

	HRESULT RunDialog(MSGPARAMETERS* pData);
	HRESULT CleanupDialog();


protected:
      CSceneNavigator();
      CSceneNavigator(const CSceneNavigator&);
      CSceneNavigator& operator= (const CSceneNavigator&);

private:
    static CSceneNavigator* pinstance;

	eSceneId m_FlowStack[MAX_NAVIGATOR_STACK_SIZE];
	int m_nStackTop;
	CPrimitiveScene* m_pCurrentScene;
	eSceneId m_eCurrentSceneId;

// Launch data if the Dash is launched by a title
	DWORD m_dwTitleID;
    DWORD m_dwLaunchReason;
    DWORD m_dwLaunchContext;
    DWORD m_dwLaunchParameter1;
    DWORD m_dwLaunchParameter2;
	bool m_bLaunchFromTitle;

	static SceneChild m_SceneHierarchy[MAX_CHILD_SCENE_NUM]; 
	static SceneDescription m_SceneDataMap[MAX_SCENE_NUM];
	static ExitPoint m_ExitPoint[MAX_EXIT_POINT_NUM];

private:
	static eSceneId GetSceneId(char*);
	static eButtonId GetButtonId(char*);
	HRESULT CreateScene(eSceneId eNewScene, bool bCreateNew = true);
	int FindButtonIndex(eSceneId, eButtonId);
	int GetButtonNum(eSceneId);
	void SetActiveButton(int nIndex);

    bool    IsDialogScene( eSceneId SceneId );
	
	eSceneId FindEntryPoint();
	bool IsExitPoint(eButtonId eButtonId);
	void BootToTitle();
	

// validation of Navigator's maps
#ifdef DEBUG
	void ValidateData();
#endif
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\xodash\XODashMain\socket.cpp ===
//-------------------------------------------------------------
// Copyright (c) Microsoft Corporation.  All rights reserved
// Author: Natalyp
//-------------------------------------------------------------
#include "std.h"
#include "Socket.h"
#include "AutomationMsg.h"
#include "globals.h"
#include "NetConfig.h"

CSocket::CSocket(): m_ListenSocket(INVALID_SOCKET), 
					m_AcceptedSocket(INVALID_SOCKET), 
					m_bClientConnected(false)
				
					
{} 



CSocket::~CSocket()
{
	Close();
}


//-------------------------------------------------------------
// Function name	: CSocket::InitNetworkStack
// Description	    : Global network initialization
// Return type		: HRESULT 
//-------------------------------------------------------------
HRESULT CSocket::InitNetworkStack()
{
		XNetStartupParams xnsp;
		ZeroMemory( &xnsp, sizeof(xnsp) );
		xnsp.cfgSizeOfStruct = sizeof(xnsp);
    
        xnsp.cfgFlags = XNET_STARTUP_BYPASS_SECURITY;

        INT iResult = XNetStartup( &xnsp );
        if( iResult != NO_ERROR )
        {
            return E_FAIL;
        }

       // Standard WinSock startup
        WSADATA WsaData;
        iResult = WSAStartup( MAKEWORD(2,2), &WsaData );
        if( iResult != NO_ERROR )
        {
            return E_FAIL;
        }
		return S_OK;
}

//-------------------------------------------------------------
// Function name	: CSocket::InitServer
// Description	    : Initialize listen socket
// Return type		: HRESULT 
// Argument         : bool bTCP/*=true*/
//-------------------------------------------------------------
HRESULT CSocket::InitServer(bool bTCP/*=true*/)
{
	if (!g_ResetAutomation)
	{
		return S_FALSE;
	}
	HRESULT hr = S_OK;
	// wait till IP obtained and only then reinitialize the socket
	eNetworkState eCurState = g_NetConfig.GetNetworkStatus();

	switch(eCurState)
	{
	case eCablePending:
	case eCableFail: 
	case eCablePass: 
		return S_FALSE;
	case eIPPass:
	case eDNSFail: 
	case eServiceFail: 
	case eDone: 
		break;
	}

	unsigned short iType, iProtocol = 0; 
	if(bTCP) 
	{
		iType = SOCK_STREAM;
		iProtocol = IPPROTO_TCP;
	}
	else
	{
		iType = SOCK_DGRAM;
		iProtocol = IPPROTO_UDP;
	}

	do
	{
		// create socket
		m_ListenSocket = socket( AF_INET, iType, iProtocol);
		if(INVALID_SOCKET == m_ListenSocket)
		{
			DbgPrint( "CSocket::InitServer - Fail to open a socket hr = 0x%x\n", WSAGetLastError() );
			break;
		}

		// bind socket
		hr = BindSocket();
		if (FAILED(hr))
		{
			break;
		}

		// listen
		int iResult = listen(m_ListenSocket, SOMAXCONN);
		if(SOCKET_ERROR == iResult)
		{
			DbgPrint("CSocket::InitServer - Fail to listen hr = 0x%x\n", WSAGetLastError() );
			break;
		}
	}while (0);

	if(FAILED(hr))
	{
		Close();
	}
	else
	{
		DbgPrint("CSocket::InitServer - TCP server waits for connections...\n");
	}

	g_ResetAutomation = false;
	return hr;
}


//-------------------------------------------------------------
// Function name	: CSocket::BindSocket
// Description	    : part of initialization process
// Return type		: HRESULT 
// Argument         : bool bNonBlock /*=true*/
//-------------------------------------------------------------
HRESULT CSocket::BindSocket(bool bNonBlock /*=true*/)
{
	HRESULT hr = S_OK;
	ASSERT(m_ListenSocket != INVALID_SOCKET);

    SOCKADDR_IN sa;
	sa.sin_family = AF_INET;
    sa.sin_addr.s_addr = INADDR_ANY;
    sa.sin_port = htons(ciTCPServerPort);

    int iResult = bind( m_ListenSocket, (const sockaddr *)&sa, 
                        sizeof( SOCKADDR_IN ) );

	if(SOCKET_ERROR == iResult)
	{
		DbgPrint("CSocket::BindSocket - Fail to bind the socket, hr=0x%x\n", WSAGetLastError());
		return E_FAIL;
	}

	if(bNonBlock)
	{
		DWORD dwNonBlocking = 1;
		int iResult = ioctlsocket( m_ListenSocket, FIONBIO, &dwNonBlocking);
		if(SOCKET_ERROR == iResult )
		{
			DbgPrint("CSocket::BindSocket - Fail in ioctlsocket, hr=0x%x\n",WSAGetLastError());
			return E_FAIL;
		}
	}

	return hr;
}



bool CSocket::IsAutomationActive()
{
	if(g_ResetAutomation)
	{
		InitServer();
	}
	else if(!m_bClientConnected)
	{
		int iSize = sizeof( SOCKADDR_IN );
		SOCKADDR sa;
		m_AcceptedSocket = accept( m_ListenSocket, &sa, &iSize );
		DWORD dw = WSAGetLastError();
		if ( dw != 10035)
			DbgPrint("Accept result = [%d]",WSAGetLastError());

		if(m_AcceptedSocket != INVALID_SOCKET)
		{
			DbgPrint("CSocket::ReceiveMessage - Client is connected\n");
			m_bClientConnected = true;
			m_AutomationTimer.StartZero();
		}
	}
	return m_bClientConnected;
}

//-------------------------------------------------------------
// Function name	: CSocket::ReceiveMessage
// Description	    : Get new message, initiate/discover client disconnect
// Return type		: HRESULT 
// Argument         : CAutomationMsg* pMsg
//-------------------------------------------------------------
bool CSocket::ReceiveMessage(CAutomationMsg* pMsg)
{
	HRESULT hr = S_OK;
	ASSERT(pMsg);
	if (!pMsg)
	{
		return false;
	}

	if(!IsAutomationActive())
	{
		return false;
	}
	
	pMsg->m_byMessageId = eNullMsg;
	ASSERT( m_ListenSocket != INVALID_SOCKET );
	
	// client is connected, check for messages 
	int nSize = pMsg->GetMaxSize();
	int iResult = recv(m_AcceptedSocket, (char*) pMsg, nSize, 0);

	// exactly one message is expected to be in the Q
	if(iResult > 0)
	{
		ASSERT(iResult == nSize);
	}

	// do we need to disconnect
	if (SOCKET_ERROR == iResult || !iResult )
	{
		int iReason = WSAGetLastError();
		// message supposed to fit into provided buffer
		ASSERT(iReason!= WSAEMSGSIZE);
		bool bTimeout = (m_AutomationTimer.GetElapsedSeconds() >= cfAutomationTimeout);
		if(!iResult || iResult < 0 && iReason == WSAECONNRESET || bTimeout)
		{
			DbgPrint("CSocket::ReceiveMessage - Client is disconnected [%d]\n", iReason);
			// close 
			Close();
			m_AutomationTimer.Stop();
		}
	}
	else
	{
		// new msg is received
		pMsg->Dump();
		m_AutomationTimer.StartZero();
	}
	
	// filter irrelevant msgs
	return !pMsg->IsFiltered();
}


//-------------------------------------------------------------
// Function name	: CSocket::Close
// Description	    : cleanup both listen and accepted sockets
// Return type		: void 
// Argument         : bool bCloseListen /*= true*/
//-------------------------------------------------------------
void CSocket::Close()
{
    int iResult = 0;
	// close accepted socket if open
	if( m_AcceptedSocket != INVALID_SOCKET )
    {
		iResult = shutdown(m_AcceptedSocket, SD_SEND);
        iResult = closesocket( m_AcceptedSocket );
		if (SOCKET_ERROR == iResult)
		{
			DbgPrint("CSocket::Close - Fail to close the Accepted socket, hr=0x%x\n",WSAGetLastError());
		}
        m_AcceptedSocket = INVALID_SOCKET;
    }

	// close listen socket if open
    if( m_ListenSocket != INVALID_SOCKET )
    {
        iResult = closesocket( m_ListenSocket );
		if (SOCKET_ERROR == iResult)
		{
			DbgPrint("CSocket::Close - Fail to close the Listen socket, hr=0x%x\n",WSAGetLastError());
		}
        m_ListenSocket = INVALID_SOCKET;
    }

	m_bClientConnected = false;
	g_ResetAutomation = true;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\xodash\XODashUpdate\main.cpp ===
#include "std.h"
#include "XODash.h"


XOApplication  theApp;
void __cdecl main()
{
	HRESULT hr = theApp.Create();
	if(FAILED(hr))
	{
		DbgPrint("main - fail to Initialize the app, hr = 0x%x\n. Aborting execution",hr);
		theApp.Destroy();
		return;
	}
	while (1)
	{
		theApp.Run();
	}

	theApp.Destroy();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\xodash\XODashMain\XNetConfig.h ===
#pragma once


// Those two API are used to pass user input to the network stack.
// First the XNetConfigParams are load, then changed by UI and then saved back to hard disk.
// void    WSAAPI XNetLoadConfigParams(XNetConfigParams * pxncp);
// void    WSAAPI XNetSaveConfigParams(const XNetConfigParams * pxncp);

////////////////////////////////////////////////////////////
// Description: 
// This call triggers network discovery process
// IN Params: None
// OUT Params: None
// Assumptions: XNetSaveConfigParams() is called prior to this function 	
//
////////////////////////////////////////////////////////////
void XNetConnect();


////////////////////////////////////////////////////////////
// Description: 
// XNetCancelConnect terminates network discovery process. 
// IN Params: None
// OUT Params: None
// Assumptions: XNetConnect() could be called prior to this call. 
//		Although it's valid to call this API without XNetConnect()
//		Syncronous call. Caller is not blocked and could call XNetConnect() 
//		immediately after XNetCancelConnect()
////////////////////////////////////////////////////////////
void XNetCancelConnect();

////////////////////////////////////////////////////////////
// Description: 
//  This API is a communication channel between UI and network stack.
//  UI runs in a tight loop, retrieves the status and provide data 
// IN Params: None
// OUT Params: HRESULT with the current status
//		XNET_BUSY - wait for the result, ask later
//		XNET_GET_PPPOE - user should enter PPPoE information, service is optional field
//		XNET_GET_PPPOE_SERVICE - user should enter PPPoE service name
//		XNET_GET_DNS - user should enter DNS server
//		XNET_GET_HOSTNAME - user should enter Hostname to be passed to DHCP server
//		XNET_IDLE - valid while waiting for user input (e.g. after XNET_GET_YYYYYY - see above
//		S_XNET_SUCCESS - we are connected.
//
//		E_XNET_NO_CABLE - cable is not plugged in
//		E_XNET_INVALID_PPPoE - PPPoE concentrator is found, but probably PPPoE data is incorrect
//		E_XNET_INVALID_HOSTNAME - DHCP server was found but rejected to provide IP
//		E_XNET_IP_EXPIRED - Leased time of IP expired and DHCP refuses to renew it. Do we need it?
//		E_XNET_INVALID_DNS - IP obtained, but can't resolve IP addresses for online services
//		E_NO_IDEA - do not know, nothing works, show help pages and ask user to verify configuration
//		Assumptions: 
/////////////////////////////////////////////////////////////
HRESULT XNetConnectionStatus();

/* 
The code will look something like this:

XNetConfigParams xncp;
XNetLoadConfigParams(&xncp);
// get user input ....
XNetSaveConfigParams(&xncp);
XNetConnect();
HRESULT hr = S_OK;
while(1)
{
	
	hr = XNetConnectionStatus();
	// process the status
	if(hr == XNET_GET_YYYY)
	{	XNetLoadConfigParams(&xncp);
		// get user input ....
		XNetSaveConfigParams(&xncp);
		XNetConnect();
	}
	// call XNetCancelConnect() if user requested or time expired
		
}
General questions:
1. Does achDhcpHostName include both Domain name and HostName. If yes what is the expected format?
*/

struct XNetDashConfig: public XNetConfigParams
{
	bool bStaticIP;    // true if current IP is static, false if received from DHCP server
	bool bStaticDNS;   // true if DNS is configured manually, false if received from DHCP server    
};

////////////////////////////////////////////////////////////
// Description: 
// this is a private online dash API for retrieving current network settings
// Dash uses this API to display to user current network settings. 
// The following scenario is a valid example: User gets all network configuration from DHCP server, no user input is required,
// he is connected to the online services and just curious to see his network settings. 
// IN Params: None
// OUT Params: XNetDashConfig - with all the requested data
//		pxncp->achLan[20] - ignored
//		pxncp->ina.s_addr - current IP address, received from DHCP server or Static IP 
//		pxncp->ina.inaMask.s_addr - current subnet mask
//		pxncp->ina.inaDnsPrimary.s_addr - primary DNS 
//		pxncp->ina.inaDnsSecondary.s_addr - secondary DNS
//		pxncp->achDhcpHostName            // Host name for DHCP ("" means no host name)
//		pxncp->achPppUserName             // User name for PPPoE ("" means no PPPoE)
//		pxncp->achPppPassword             // User password for PPPoE
//		pxncp->achPppServer               // Server name for PPPoE ("" ok)
//		pxncp->abReserved - ignored               
//		pxncp->dwSigEnd   - ignored
//		pxncp->bStaticIP  - valid values: true/false
//		pxncp->bStaticDNS  - valid values: true/false
//
// Assumptions: Call should be synchronous  and the result is expected immediately 
//
void    WSAAPI XNetGetConfigParams(XNetDashConfig * pxncp);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\xodash\XODashMain\XODash.cpp ===
//-----------------------------------------------------------------------------
// File: XODash.cpp
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------


#include "std.h"

#include "XODash.h"
#include "Scene.h"

#include "utilities.h"
#include "XOConst.h"
#include "DSoundManager.h"
#include "ntiosvc.h"
#include "globals.h"
#include "XOConst.h"

#include "SceneNavigator.h"
#include "Translator.h"
#include "InputHandle.h"
#include "AccountData.h"
#include "NetConfig.h"

//-----------------------------------------------------------------------------
// Global access to common members
//-----------------------------------------------------------------------------
XOApplication*    g_pXBApp     = NULL;
LPDIRECT3DDEVICE8  g_pd3dDevice = NULL;
CMaterialLibrary   g_MaterialLib;

float* g_fAppTime = 0;
TCHAR* g_szAppDir = MEDIA_PATH; // _T("d:\\media\\");

// audio related const
CNtIoctlCdromService g_cdrom;
int g_nDiscType = eDiscNone;
int GetDiscType();
CInputHandle g_szUserInput;
bool g_ResetAutomation = true;
CNetConfig g_NetConfig;

//-----------------------------------------------------------------------------
// Name: XOApplication()
// Desc: Constructor
//-----------------------------------------------------------------------------
XOApplication::XOApplication()
{
    // Initialize member variables
    g_pXBApp          = this;

    // Direct3D variables
    m_pD3D            = NULL;
    m_pd3dDevice      = NULL;
    m_pDepthBuffer    = NULL;
    m_pBackBuffer     = NULL;

    // Variables to perform app timing
    m_fTime           = 0.0f;
    m_fStartTime      = 0.0f;
    m_fElapsedTime    = 0.0f;
	m_fSecsPerTick    = 0.0f;

    // Set up the presentation parameters for a double-bufferd, 640x480,
    // 32-bit display using depth-stencil. Override these parameters in
    // your derived class as your app requires.
    ZeroMemory( &m_d3dpp, sizeof(m_d3dpp) );
    m_d3dpp.BackBufferWidth        = 640;
    m_d3dpp.BackBufferHeight       = 480;
    m_d3dpp.BackBufferFormat       = D3DFMT_A8R8G8B8;
    m_d3dpp.BackBufferCount        = 1;
    m_d3dpp.EnableAutoDepthStencil = TRUE;
    m_d3dpp.AutoDepthStencilFormat = D3DFMT_D24S8;
    m_d3dpp.SwapEffect             = D3DSWAPEFFECT_DISCARD;
	m_d3dpp.FullScreen_RefreshRateInHz      = D3DPRESENT_RATE_DEFAULT;
	m_d3dpp.FullScreen_PresentationInterval = D3DPRESENT_INTERVAL_ONE;
    m_d3dpp.MultiSampleType        = D3DMULTISAMPLE_4_SAMPLES_SUPERSAMPLE_GAUSSIAN;

    // Specify number and type of input devices this app will be using. By
    // default, you can use 0 and NULL, which triggers XInputDevices() to
    // prealloc the default number and types of devices. To use chat or
    // other devices, override these variables in your derived class.
    m_dwNumInputDeviceTypes = 0;
    m_InputDeviceTypes      = NULL;
	g_fAppTime = &m_fTime;
    _tcscpy( m_szAppDir,g_szAppDir);
}




//-----------------------------------------------------------------------------
// Name: Create()
// Desc: Create the app
//-----------------------------------------------------------------------------
HRESULT XOApplication::Create()
{
    HRESULT hr;

    float zero = 0.0f;
	float one = 1.0f;


    // Create the Direct3D object
    DbgPrint( "XBApp: Creating Direct3D...\n" );
    if( NULL == ( m_pD3D = Direct3DCreate8(D3D_SDK_VERSION) ) )
    {
        DbgPrint( "XBApp: Unable to create Direct3D!\n");
        return E_FAIL;
    }

    // Create the device
    DbgPrint( "XBApp: Creating the D3D device...\n");
    if( FAILED( hr = m_pD3D->CreateDevice( 0, D3DDEVTYPE_HAL, NULL, 
                                           D3DCREATE_HARDWARE_VERTEXPROCESSING, 
                                           &m_d3dpp, &m_pd3dDevice ) ) )
    {
        DbgPrint( "XBApp: Could not create D3D device!\n");
        return hr;
    }

    // Allow global access to the device
    g_pd3dDevice = m_pd3dDevice;

    // Store pointers to the depth and back buffers
    m_pd3dDevice->GetDepthStencilSurface( &m_pDepthBuffer );
    m_pd3dDevice->GetBackBuffer( 0, 0, &m_pBackBuffer );

    // Initialize core peripheral port support. Note: If these parameters
    // are 0 and NULL, respectively, then the default number and types of 
    // controllers will be initialized.
    XInitDevices( m_dwNumInputDeviceTypes, m_InputDeviceTypes );

    // Create the gamepad devices
    DbgPrint( "XBApp: Creating gamepad devices...\n");
    if( FAILED( hr = XBInput_CreateGamepads( &m_Gamepad ) ) )
    {
        DbgPrint( "XBApp: Call to CreateGamepads() failed!\n" );
        return hr;
    }

	
	if(FAILED(hr = MapDrive(DASH_DRIVE_LETTER, DASH_PARTITION)) )
	{
		DbgPrint("XOApplication:Create - fail to map drive\n");
		return hr;
	}
    // Initialize the app's device-dependent objects
    DbgPrint("XBApp: Initializing the app...\n");
    if( FAILED( hr = Initialize() ) )
    {
        DbgPrint("XBApp: Call to Initialize() failed!\n" );
        return hr;
    }

	
	LARGE_INTEGER qwTicksPerSec;
	QueryPerformanceFrequency( &qwTicksPerSec );
	m_fSecsPerTick = 1.0f / (FLOAT)qwTicksPerSec.QuadPart;


    g_pd3dDevice->SetRenderState(D3DRS_FILLMODE, D3DFILL_SOLID);
	g_pd3dDevice->SetRenderState(D3DRS_SHADEMODE, D3DSHADE_GOURAUD);
	g_pd3dDevice->SetRenderState(D3DRS_ZWRITEENABLE, TRUE);
	g_pd3dDevice->SetRenderState(D3DRS_ALPHATESTENABLE, FALSE);
	g_pd3dDevice->SetRenderState(D3DRS_SRCBLEND, D3DBLEND_ONE);
	g_pd3dDevice->SetRenderState(D3DRS_DESTBLEND, D3DBLEND_ZERO);
	g_pd3dDevice->SetRenderState(D3DRS_CULLMODE, D3DCULL_CCW);
	g_pd3dDevice->SetRenderState(D3DRS_ZFUNC, D3DCMP_LESSEQUAL);
	g_pd3dDevice->SetRenderState(D3DRS_ALPHAREF, 0);
	g_pd3dDevice->SetRenderState(D3DRS_ALPHAFUNC, D3DCMP_ALWAYS);
	g_pd3dDevice->SetRenderState(D3DRS_DITHERENABLE, TRUE);
	g_pd3dDevice->SetRenderState(D3DRS_ALPHABLENDENABLE, TRUE);
	g_pd3dDevice->SetRenderState(D3DRS_FOGENABLE, FALSE);
	g_pd3dDevice->SetRenderState(D3DRS_SPECULARENABLE, FALSE);
	g_pd3dDevice->SetRenderState(D3DRS_FOGCOLOR, 0);
	g_pd3dDevice->SetRenderState(D3DRS_FOGTABLEMODE, D3DFOG_NONE);
	g_pd3dDevice->SetRenderState(D3DRS_FOGDENSITY, *(LPDWORD)&one);
	g_pd3dDevice->SetRenderState(D3DRS_EDGEANTIALIAS, FALSE);
	g_pd3dDevice->SetRenderState(D3DRS_ZBIAS, 0);
	g_pd3dDevice->SetRenderState(D3DRS_RANGEFOGENABLE, FALSE);
	g_pd3dDevice->SetRenderState(D3DRS_STENCILENABLE, FALSE);
	g_pd3dDevice->SetRenderState(D3DRS_STENCILFAIL, D3DSTENCILOP_KEEP);
	g_pd3dDevice->SetRenderState(D3DRS_STENCILZFAIL, D3DSTENCILOP_KEEP);
	g_pd3dDevice->SetRenderState(D3DRS_STENCILPASS, D3DSTENCILOP_KEEP);
	g_pd3dDevice->SetRenderState(D3DRS_STENCILFUNC, D3DCMP_ALWAYS);
	g_pd3dDevice->SetRenderState(D3DRS_STENCILREF, 0);
	g_pd3dDevice->SetRenderState(D3DRS_STENCILMASK, 0xffffffff);
	g_pd3dDevice->SetRenderState(D3DRS_STENCILWRITEMASK, 0xffffffff);
	g_pd3dDevice->SetRenderState(D3DRS_WRAP0, 0);
	g_pd3dDevice->SetRenderState(D3DRS_WRAP1, 0);
	g_pd3dDevice->SetRenderState(D3DRS_WRAP2, 0);
	g_pd3dDevice->SetRenderState(D3DRS_WRAP3, 0);
	g_pd3dDevice->SetRenderState(D3DRS_LIGHTING, TRUE);
	g_pd3dDevice->SetRenderState(D3DRS_AMBIENT, 0);
	g_pd3dDevice->SetRenderState(D3DRS_COLORVERTEX, TRUE);
	g_pd3dDevice->SetRenderState(D3DRS_LOCALVIEWER, TRUE);
	g_pd3dDevice->SetRenderState(D3DRS_NORMALIZENORMALS, FALSE);
	g_pd3dDevice->SetRenderState(D3DRS_DIFFUSEMATERIALSOURCE, D3DMCS_COLOR1);
	g_pd3dDevice->SetRenderState(D3DRS_SPECULARMATERIALSOURCE, D3DMCS_COLOR2);
	g_pd3dDevice->SetRenderState(D3DRS_AMBIENTMATERIALSOURCE, D3DMCS_COLOR2);
	g_pd3dDevice->SetRenderState(D3DRS_EMISSIVEMATERIALSOURCE, D3DMCS_MATERIAL);
	g_pd3dDevice->SetRenderState(D3DRS_VERTEXBLEND, D3DVBF_DISABLE);
	g_pd3dDevice->SetRenderState(D3DRS_POINTSIZE, *(LPDWORD)&one);
	g_pd3dDevice->SetRenderState(D3DRS_POINTSIZE_MIN, *(LPDWORD)&one);
	g_pd3dDevice->SetRenderState(D3DRS_POINTSPRITEENABLE, FALSE);
	g_pd3dDevice->SetRenderState(D3DRS_POINTSCALEENABLE, FALSE);
	g_pd3dDevice->SetRenderState(D3DRS_POINTSCALE_A, *(LPDWORD)&one);
	g_pd3dDevice->SetRenderState(D3DRS_POINTSCALE_B, *(LPDWORD)&zero);
	g_pd3dDevice->SetRenderState(D3DRS_POINTSCALE_C, *(LPDWORD)&zero);
	g_pd3dDevice->SetRenderState(D3DRS_MULTISAMPLEANTIALIAS, TRUE);
	g_pd3dDevice->SetRenderState(D3DRS_MULTISAMPLEMASK, 0xffffffff);
	g_pd3dDevice->SetRenderState(D3DRS_COLORWRITEENABLE, D3DCOLORWRITEENABLE_RED | D3DCOLORWRITEENABLE_GREEN | D3DCOLORWRITEENABLE_BLUE | D3DCOLORWRITEENABLE_ALPHA);


    return hr;
}




//-----------------------------------------------------------------------------
// Name: Destroy()
// Desc: Cleanup objects
//-----------------------------------------------------------------------------
VOID XOApplication::Destroy()
{
    // Perform app-specific cleanup
    Cleanup();

    // Release display objects
    SAFE_RELEASE( m_pd3dDevice );
    SAFE_RELEASE( m_pD3D );
	// erase the drive mapping
	UnMapDrive(DASH_DRIVE_LETTER); 
}




//-----------------------------------------------------------------------------
// Name: Run()
// Desc: 
//-----------------------------------------------------------------------------

INT XOApplication::Run()
{
    DbgPrint("XBApp: Running the application...\n");
	
	HRESULT hrRender = S_OK;
    HRESULT hrFrameMove = S_OK;

	LARGE_INTEGER qwTime;
	QueryPerformanceCounter( &qwTime ); 
	m_fStartTime =  m_fSecsPerTick * ((FLOAT)(qwTime.QuadPart));

    // Run the game loop, animating and rendering frames
    while( SUCCEEDED(hrFrameMove) && SUCCEEDED(hrRender) )
    {
    
        //-----------------------------------------
        // Animate and render a frame
        //-----------------------------------------

        hrFrameMove = FrameMove();

        // Render the scene
        // honestly, this really can't fail...
        hrRender = Render();

        // Finally, show the frame (swaps the backbuffer to the front)
        m_pd3dDevice->Present( NULL, NULL, NULL, NULL );
    }

    return hrFrameMove;
}



void XOApplication::ProcessUserInput()
{
	HRESULT hr = S_OK;

    // Read the input for all connected gampads
    XBInput_GetInput( m_Gamepad );

    // Lump inputs of all connected gamepads into one common structure.
    // This is done so apps that need only one gamepad can function with
    // any gamepad.
    
    for( DWORD i=0; i<4; i++ )
    {
        if( m_Gamepad[i].hDevice )
        {
            m_DefaultGamepad.sThumbLX += m_Gamepad[i].sThumbLX;
            m_DefaultGamepad.sThumbLY += m_Gamepad[i].sThumbLY;
            m_DefaultGamepad.sThumbRX += m_Gamepad[i].sThumbRX;
            m_DefaultGamepad.sThumbRY += m_Gamepad[i].sThumbRY;

            m_DefaultGamepad.fX1      += m_Gamepad[i].fX1;
            m_DefaultGamepad.fY1      += m_Gamepad[i].fY1;
            m_DefaultGamepad.fX2      += m_Gamepad[i].fX2;
            m_DefaultGamepad.fY2      += m_Gamepad[i].fY2;
            m_DefaultGamepad.wButtons        |= m_Gamepad[i].wButtons;
            m_DefaultGamepad.wPressedButtons |= m_Gamepad[i].wPressedButtons;
            m_DefaultGamepad.wLastButtons    |= m_Gamepad[i].wLastButtons;

            for( DWORD b=0; b<8; b++ )
            {
                m_DefaultGamepad.bAnalogButtons[b]        |= m_Gamepad[i].bAnalogButtons[b];
                m_DefaultGamepad.bPressedAnalogButtons[b] |= m_Gamepad[i].bPressedAnalogButtons[b];
                m_DefaultGamepad.bLastAnalogButtons[b]    |= m_Gamepad[i].bLastAnalogButtons[b];
            }
        }
    }


    // Handle special input combo to trigger a reboot to the Xbox Dashboard
    if( m_DefaultGamepad.bAnalogButtons[XINPUT_GAMEPAD_LEFT_TRIGGER] > 0 )
    {
        if( m_DefaultGamepad.bAnalogButtons[XINPUT_GAMEPAD_RIGHT_TRIGGER] > 0 )
        {
            if( m_DefaultGamepad.bPressedAnalogButtons[XINPUT_GAMEPAD_BLACK] )
                XLaunchNewImage( NULL, NULL );
        }
    }

}

HRESULT XOApplication::FrameMove()
{
	HRESULT hr = S_OK;
	ZeroMemory( &m_DefaultGamepad, sizeof(m_DefaultGamepad) );

    //-----------------------------------------
    // Handle input
    //-----------------------------------------
	// if automation test are active, ignore all inputs from the pereferral devices
	if (m_AutomationSocket.IsAutomationActive())
	{
		CAutomationMsg msg;
		if(m_AutomationSocket.ReceiveMessage(&msg))
		{
			msg.SetGamepadData(&m_DefaultGamepad);
		}
	}
	else
	{
		ProcessUserInput();
	}
  
	//-----------------------------------------
    // Perform app timing
    //-----------------------------------------

    // Get the current time (keep in LARGE_INTEGER format for precision)
	LARGE_INTEGER qwTime;
    QueryPerformanceCounter( &qwTime );
    
    // Store the current time values as floating point
    
    m_fElapsedTime    = m_fSecsPerTick * ((FLOAT)(qwTime.QuadPart)) - m_fTime;
    
    // don't screw up animation's or anything just because we're debugging
    if ( m_fElapsedTime > .1f )
        m_fElapsedTime = .1f;
    m_fTime           = m_fSecsPerTick * ((FLOAT)(qwTime.QuadPart));
    
	hr = CSceneNavigator::Instance()->FrameMove(m_DefaultGamepad, m_fElapsedTime);
	return hr;
}


HRESULT XOApplication::Cleanup()
{
	HRESULT hr = S_OK;

    // clean up more sounds
    CPrimitiveScene::CleanupSounds();

	hr = DSoundManager::Instance()->Cleanup();
	if (FAILED(hr))
	{
		DbgPrint("XOApplication::Cleanup - fail to cleanup DirectSound, hr = 0x%x", hr);
	}
	else
	{
		DbgPrint("XOApplication::Cleanup - DirectSound clean");
	}

    // clean the translator

	CTranslator::Instance()->Cleanup();

	// now the navigator
    hr = CSceneNavigator::Instance()->Cleanup();
	if (FAILED(hr))
	{
		DbgPrint("XOApplication::Cleanup - fail to cleanup SceneNavigator, hr = 0x%x", hr);
	}
	else
	{
		DbgPrint("XOApplication::Cleanup - SceneNavigator clean");
	}

    // clean up accounts
    hr = Accounts::CleanUp();
   	if (FAILED(hr))
	{
		DbgPrint("XOApplication::Cleanup - fail to cleanup Accounts, hr = 0x%x", hr);
	}
	else
	{
        DbgPrint("XOApplication::Cleanup - Accounts clean");
	}


//	m_AutomationSocket.Close(true);
	return hr;
}

HRESULT XOApplication::Render()
{
	if ( m_pd3dDevice )
	{
	
		m_pd3dDevice->BeginScene();

		// Clear the backbuffer 
		m_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_TARGET|D3DCLEAR_ZBUFFER, 
                         D3DCOLOR_XRGB( (int)0, (int)0, (int)0 ), 1.0f, 0L );

		CSceneNavigator::Instance()->Render(0);

		m_pd3dDevice->EndScene();
	}

	return S_OK;
}



HRESULT XOApplication::InitAudio()
{
	HRESULT hr = S_OK;
	do
	{
	// retreive the status of DVD/CD Rom 
		g_cdrom.Open(1);
        g_nDiscType = GetDiscType();
	
		// initialize DSound 
		if(!DSoundManager::Instance())
		{
			hr = E_OUTOFMEMORY; 
			BREAKONFAIL(hr,"XOApplication::InitAudio - fail to create DSoundManager");
		}
		
		hr = DSoundManager::Instance()->Initialize();
		BREAKONFAIL(hr, "XOApplication::InitAudio fail to init DSound");
	
	}while(0);

	return hr;

}

HRESULT XOApplication::Initialize()
{
	HRESULT hr = S_OK;
	do
	{
		hr = InitAudio();
		BREAKONFAIL(hr, "XOApplication::Initialize - Fail to init DirectSound");
		DbgPrint("XOApplication::Initialize - Audio is initialized\n");
		
		hr = CTranslator::Instance()-> Initialize();
		BREAKONFAIL(hr, "XOApplication::Initialize - Fail to init XLate table");
		DbgPrint("XOApplication::Initialize - Translator is initialized\n");

		hr = CSceneNavigator::Instance()->Initialize();
		BREAKONFAIL(hr, "XOApplication::Initialize - Fail to init SceneNavigator");
		DbgPrint("XOApplication::Initialize - SceneNavigator is initialized\n");

        hr = Accounts::Initialize();
   		BREAKONFAIL(hr, "XOApplication::Initialize - Fail to init accounts");
		DbgPrint("XOApplication::Initialize - accounts is initialized\n");
		
	}while(0);

	return hr;
}



// Map a drive to a partiticular drive letter
HRESULT XOApplication::MapDrive( char cDriveLetter, char* pszPartition )
{
    ASSERT( pszPartition != NULL );

	UnMapDrive( cDriveLetter);
	DbgPrint("Mapping partition [%s] to drive [%c]\n", pszPartition, cDriveLetter);
    char pszDrive[20];
    ZeroMemory( pszDrive, 20 );

    sprintf( pszDrive, "\\??\\%c:", cDriveLetter );

    ANSI_STRING ostDrive, ostPath;

    RtlInitObjectString( &ostDrive, pszDrive );
    RtlInitObjectString( &ostPath, pszPartition );
    NTSTATUS status = IoCreateSymbolicLink( &ostDrive, &ostPath );

	DbgPrint("MapDrive, status = [%d]\n", status);

    return HRESULT_FROM_WIN32(RtlNtStatusToDosError( status ));
}


// Un-map a drive from the specified drive letter
HRESULT XOApplication::UnMapDrive( char cDriveLetter )
{
    char pszDrive[20];
    ZeroMemory( pszDrive, 20 );

    sprintf( pszDrive, "\\??\\%c:", cDriveLetter );

    ANSI_STRING ostDrive;

    RtlInitObjectString( &ostDrive, pszDrive );
    NTSTATUS status = IoDeleteSymbolicLink(&ostDrive);

    return HRESULT_FROM_WIN32(RtlNtStatusToDosError( status ));
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\xodash\XODashUpdate\keys.cpp ===
BYTE g_rgbTitleKey[] =
{
	0x54, 0x45, 0x53, 0x54, 0x54, 0x45, 0x53, 0x54, 0x54, 0x45, 0x53, 0x54, 0x54, 0x45, 0x53, 0x54
};

const unsigned char g_rgbSymmetricKey[] = {
        0xF8, 0x23, 0x7C, 0xDC, 0x16, 0x25, 0x53, 0x2C,
        0xB0, 0x2B, 0x2D, 0x80, 0x7A, 0x31, 0x1A, 0x43
};

BYTE g_rgbPublicKey[] =
{
	0x52, 0x53, 0x41, 0x31, 0x08, 0x01, 0x00, 0x00, 
	0x00, 0x08, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00,
	0x01, 0x00, 0x01, 0x00, 0xe7, 0x74, 0xac, 0x08, 
	0xdf, 0x33, 0xc7, 0xb4, 0x30, 0xf7, 0x98, 0x58, 
	0x03, 0x87, 0x92, 0x3e, 0xa6, 0x2b, 0x05, 0x61, 
	0x9c, 0x15, 0xc0, 0x64, 0x0f, 0x01, 0xcd, 0x69, 
	0xcf, 0x93, 0x2e, 0xc9, 0xb8, 0xf4, 0xb7, 0x70, 
	0xb5, 0x33, 0x43, 0x9e, 0x6a, 0x88, 0x4f, 0x14, 
	0x3c, 0x21, 0xcb, 0x6c, 0x91, 0xf4, 0x12, 0x80, 
	0xbe, 0xea, 0xe7, 0xb3, 0x08, 0x05, 0xff, 0x43, 
	0x97, 0xd9, 0x51, 0xee, 0x26, 0x97, 0x71, 0x87, 
	0x39, 0x0a, 0x44, 0xb6, 0xff, 0x14, 0xfc, 0x1d, 
	0x94, 0x48, 0x33, 0xe1, 0xa6, 0xc0, 0xf9, 0xf0, 
	0x67, 0xbc, 0x1c, 0xe6, 0x7e, 0xe2, 0x90, 0xa9, 
	0x61, 0x8a, 0xd5, 0xb0, 0x15, 0xbb, 0xa5, 0xce, 
	0x18, 0x73, 0x6d, 0xfa, 0xbe, 0x76, 0xeb, 0xf8, 
	0x78, 0xe2, 0x5f, 0x59, 0xea, 0x3c, 0x02, 0x0c, 
	0x3f, 0x1a, 0xc3, 0xa3, 0x00, 0x85, 0x7b, 0x29, 
	0x4d, 0x9f, 0x3a, 0xdd, 0x52, 0x1b, 0xce, 0x84, 
	0x48, 0x04, 0x6e, 0x72, 0xad, 0x74, 0x9c, 0x95, 
	0xc0, 0x4b, 0xab, 0xa6, 0x0c, 0x44, 0xd2, 0xde, 
	0x70, 0xa1, 0xfa, 0xdb, 0x3c, 0x97, 0xe5, 0xdc, 
	0x38, 0xa5, 0xac, 0x2b, 0xc5, 0xdf, 0xdc, 0xf6, 
	0x2a, 0xcc, 0x58, 0x7a, 0x19, 0x21, 0xfc, 0x95, 
	0x97, 0xdc, 0x4c, 0x4d, 0xf0, 0xbd, 0x42, 0xf7, 
	0x4b, 0x91, 0x1b, 0xb6, 0xbc, 0x30, 0x13, 0x0b, 
	0xcf, 0xd0, 0x1b, 0xbb, 0x25, 0xd4, 0x13, 0x77, 
	0x16, 0x83, 0x26, 0x54, 0xa6, 0x67, 0xaa, 0x40, 
	0x47, 0xe0, 0x11, 0x54, 0xc9, 0x68, 0x8a, 0xb2, 
	0x50, 0xd0, 0x51, 0x9d, 0xe5, 0x45, 0xc4, 0x95, 
	0xc8, 0x45, 0x2c, 0xae, 0x08, 0x7f, 0x4d, 0xd1, 
	0x6f, 0x34, 0xd2, 0xf1, 0x87, 0x4c, 0x16, 0x97, 
	0x0c, 0xfc, 0xcf, 0xd1, 0xb9, 0x1e, 0x7b, 0x4b, 
	0xa4, 0x02, 0xfd, 0xc6, 0xff, 0x2b, 0xf9, 0xc3, 
	0xee, 0xde, 0x12, 0xd7, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00 
};

const DWORD g_cbPublicKey = sizeof(g_rgbPublicKey);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\xodash\XODashMain\xODash.h ===
//-----------------------------------------------------------------------------
// File: XODash.h
//
// Container for XOnline's dash.  Stolen from ATG
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef XBAPP_H
#define XBAPP_H

#include <xtl.h>
#include <xgraphics.h>
#include <stdio.h>
#include "XBInput.h"
#include "XBUtil.h"
#include "Socket.h"



//-----------------------------------------------------------------------------
// Global access to common members
//-----------------------------------------------------------------------------
extern LPDIRECT3DDEVICE8 g_pd3dDevice;




//-----------------------------------------------------------------------------
// Name: class XOApplication
// Desc: holds all really high level objects, sets up D3D
//          Initialize()          - To initialize the device-dependant objects
//          FrameMove()           - To animate the scene
//          Render()              - To render the scene
//-----------------------------------------------------------------------------
class XOApplication
{
protected:
    // Main objects used for creating and rendering the 3D scene
    D3DPRESENT_PARAMETERS m_d3dpp;
    LPDIRECT3D8           m_pD3D;              // The D3D enumerator object
    LPDIRECT3DDEVICE8     m_pd3dDevice;        // The D3D rendering device
    LPDIRECT3DSURFACE8    m_pBackBuffer;       // The backbuffer
    LPDIRECT3DSURFACE8    m_pDepthBuffer;      // The depthbuffer

    // Variables for timing
    float      m_fTime;             // Current absolute time in seconds
    float      m_fElapsedTime;      // Elapsed absolute time since last frame
	float      m_fStartTime;        // absolute start time in seconds
	float      m_fSecsPerTick;

    // Members to init the XINPUT devices.
    XDEVICE_PREALLOC_TYPE* m_InputDeviceTypes;
    DWORD                  m_dwNumInputDeviceTypes;
    XBGAMEPAD*             m_Gamepad;
    XBGAMEPAD              m_DefaultGamepad;


    // Overridable functions for the 3D scene created by the app
    virtual HRESULT Initialize();
    virtual HRESULT FrameMove();
    virtual HRESULT Render();
    virtual HRESULT Cleanup();

public:

    // Functions to create, run, and clean up the application
    HRESULT Create();
    INT     Run();
    VOID    Destroy();

    // Internal constructor
    XOApplication();

	float	GetTime(){ return m_fTime; }
	void ProcessUserInput();


private:
	TCHAR					m_szAppDir[MAX_PATH];
	CSocket m_AutomationSocket;

private:
	HRESULT MapDrive( char cDriveLetter, char* pszPartition);
	HRESULT UnMapDrive( char cDriveLetter );
	HRESULT InitAudio();

};


extern XOApplication	theApp; // the single instance


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\xvchat\makefile.inc ===
$(XDK_LIB_PATH)\$(TARGETNAME).lib: $(SDK_LIB_PATH)\$(TARGETNAME).lib
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\xodash\XODashMain\std.h ===
#ifdef _XBOX


#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <stddef.h>

#include <ntos.h>

#include <ntdddisk.h>
#include <ntddcdrm.h>
#include <ntddscsi.h>
#include <ntddcdvd.h>
#include <smcdef.h>
#include <scsi.h>
#include <init.h>
#ifdef __cplusplus
}
#endif // __cplusplus
#define  NODSOUND
#include <xtl.h>
#include <dsound.h>

#include <xgraphics.h>
#include <xboxp.h>
#include <xapip.h>
#include <av.h>
#include "xonlinep.h"


#ifndef D3DLOCK_DISCARD
#define D3DLOCK_DISCARD 0
#endif

#endif

#ifdef _WINDOWS
#include <winsock2.h>
#include <windows.h>
#endif

#include <tchar.h>
typedef TCHAR* PTCHAR;

// "Filesystem" Character Type...What do *most* of the file system API's use...
#if defined(_XBOX)
typedef char FSCHAR;
#define _FS(s) s
#else
typedef TCHAR FSCHAR;
#define _FS(s) _T(s)
#endif

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <stdarg.h>
#include <math.h>

#include <crtdbg.h>

#if !defined(_NOD3D)
#define D3D_OVERLOADS
#include <d3d8.h>
#include <d3dx8.h>

#endif


////////////////////////////////////////////////////////////////////////////

#ifdef  __cplusplus

#define EXTERN_C extern "C"


#define RELEASENULL(object) { if ((object) != NULL) { (object)->Release(); (object) = NULL; } }

#else // !__cplusplus

#define EXTERN_C extern
#define bool BOOL
#define true TRUE
#define false FALSE
#define inline _inline

#endif

#define CopyChars(dest, src, count) CopyMemory(dest, src, (count) * sizeof (TCHAR))
#define countof(n) (sizeof (n) / sizeof (n[0]))


#ifdef _UNICODE
extern void Unicode(TCHAR* wsz, const char* sz, int nMaxChars);
extern void Ansi(char* sz, const TCHAR* wsz, int nMaxChars);
#endif


#undef VERIFY


#undef ALERT

#ifdef _DEBUG

// #define ASSERT(f)		if (!(f)) RtlAssert(#f, __FILE__, __LINE__, NULL)
#define VERIFY(f)		ASSERT(f)


#define ALERT			Alert

EXTERN_C bool AssertFailed(const TCHAR* szFile, int nLine, HRESULT hr);


#else // !_DEBUG

// #define ASSERT(f)		((void)0)
#define VERIFY(f)		((void)(f))

#define ALERT			1 ? (void)0 : Alert



#endif

EXTERN_C void Alert(const TCHAR* szMsg, ...);


////////////////////////////////////////////////////////////////////////////

#ifdef _XBOX
#include "xprofp.h"

#ifdef _PROFILE
#define START_PROFILE() XProfpControl(XPROF_START, 0)
#define END_PROFILE() XProfpControl(XPROF_STOP, 0)
#else
#define START_PROFILE()
#define END_PROFILE()
#endif
#else
#define START_PROFILE()
#define END_PROFILE()
#endif

////////////////////////////////////////////////////////////////////////////
// Stuff from Windows that Xbox should have...
//
/*
#ifdef _XBOX
typedef  PVOID           HDEVNOTIFY;

typedef struct tagRGBQUAD {
        BYTE    rgbBlue;
        BYTE    rgbGreen;
        BYTE    rgbRed;
        BYTE    rgbReserved;
} RGBQUAD;
typedef RGBQUAD FAR* LPRGBQUAD;

#define MAX_COMPUTERNAME_LENGTH 15 // REVIEW: What is this really?
#endif
*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\xodash\XODashUpdate\std.h ===
#ifdef _XBOX


#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <stddef.h>

#include <ntos.h>

#include <ntdddisk.h>
#include <ntddcdrm.h>
#include <ntddscsi.h>
#include <ntddcdvd.h>
#include <smcdef.h>
#include <scsi.h>
#include <init.h>
#ifdef __cplusplus
}
#endif // __cplusplus
#define  NODSOUND
#include <xtl.h>
#include <dsound.h>

#include <xgraphics.h>
#include <xboxp.h>
#include <xapip.h>
#include <av.h>
#include "xonlinep.h"


#ifndef D3DLOCK_DISCARD
#define D3DLOCK_DISCARD 0
#endif

#endif

#ifdef _WINDOWS
#include <winsock2.h>
#include <windows.h>
#endif

#include <tchar.h>
typedef TCHAR* PTCHAR;

// "Filesystem" Character Type...What do *most* of the file system API's use...
#if defined(_XBOX)
typedef char FSCHAR;
#define _FS(s) s
#else
typedef TCHAR FSCHAR;
#define _FS(s) _T(s)
#endif

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <stdarg.h>
#include <math.h>

#include <crtdbg.h>

#if !defined(_NOD3D)
#define D3D_OVERLOADS
#include <d3d8.h>
#include <d3dx8.h>

#endif


////////////////////////////////////////////////////////////////////////////

#ifdef  __cplusplus

#define EXTERN_C extern "C"


#define RELEASENULL(object) { if ((object) != NULL) { (object)->Release(); (object) = NULL; } }

#else // !__cplusplus

#define EXTERN_C extern
#define bool BOOL
#define true TRUE
#define false FALSE
#define inline _inline

#endif

#define CopyChars(dest, src, count) CopyMemory(dest, src, (count) * sizeof (TCHAR))
#define countof(n) (sizeof (n) / sizeof (n[0]))


#ifdef _UNICODE
extern void Unicode(TCHAR* wsz, const char* sz, int nMaxChars);
extern void Ansi(char* sz, const TCHAR* wsz, int nMaxChars);
#endif


#undef VERIFY


#undef ALERT

#ifdef _DEBUG

// #define ASSERT(f)		if (!(f)) RtlAssert(#f, __FILE__, __LINE__, NULL)
#define VERIFY(f)		ASSERT(f)


#define ALERT			Alert

EXTERN_C bool AssertFailed(const TCHAR* szFile, int nLine, HRESULT hr);


#else // !_DEBUG

// #define ASSERT(f)		((void)0)
#define VERIFY(f)		((void)(f))

#define ALERT			1 ? (void)0 : Alert



#endif

EXTERN_C void Alert(const TCHAR* szMsg, ...);


////////////////////////////////////////////////////////////////////////////

#ifdef _XBOX
#include "xprofp.h"

#ifdef _PROFILE
#define START_PROFILE() XProfpControl(XPROF_START, 0)
#define END_PROFILE() XProfpControl(XPROF_STOP, 0)
#else
#define START_PROFILE()
#define END_PROFILE()
#endif
#else
#define START_PROFILE()
#define END_PROFILE()
#endif

////////////////////////////////////////////////////////////////////////////
// Stuff from Windows that Xbox should have...
//
/*
#ifdef _XBOX
typedef  PVOID           HDEVNOTIFY;

typedef struct tagRGBQUAD {
        BYTE    rgbBlue;
        BYTE    rgbGreen;
        BYTE    rgbRed;
        BYTE    rgbReserved;
} RGBQUAD;
typedef RGBQUAD FAR* LPRGBQUAD;

#define MAX_COMPUTERNAME_LENGTH 15 // REVIEW: What is this really?
#endif
*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\xvchat\QueueXMO.cpp ===
//-----------------------------------------------------------------------------
// File: QueueXMO.cpp
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include "xvocver.h"
#include "QueueXMOp.h"
#include "voiceencoder.h"



//
// The interface
//
//////////////////////////////////////////////////////////////////////////////
XBOXAPI 
HRESULT 
WINAPI
XVoiceQueueCreateMediaObject(LPQUEUE_XMO_CONFIG pConfig , LPXMEDIAOBJECT *ppMediaObject)
{   
    
    CQueueXMO *pQueueXmo;

	HRESULT hr = QUEUE_S_OK;
    
    do
    {
		*ppMediaObject = NULL;

		//
		// Create Queue XMO
		//
		pQueueXmo = new CQueueXMO;

		if ( NULL == pQueueXmo )
		{
			hr = QUEUE_E_OUTOFMEMORY;
			break;
		}

		//
        // Initialize with the given parameters
        //
		hr = pQueueXmo->Initialize(pConfig);

		if (SUCCEEDED(hr)) 
		{
			*ppMediaObject = pQueueXmo;
		}
		else
		{
			delete pQueueXmo;
		}
     
    }
    while( FALSE );
    
    return( hr );

}

//
// Public Method: Get output buffer size for the encoder depending on the PCM buffer size to be encoded 
// The same buffer sizes apply to the decoder , too
//
XBOXAPI 
HRESULT 
WINAPI
XVoiceGetCodecBufferSize( const LPXMEDIAOBJECT pCodecMediaObject, WORD wPCMBufferSize , WORD *pwCodecBufferSize)
{
	DOUBLE dCompressionRate;

    if( NULL !=  pCodecMediaObject)
    {
        XMEDIAINFO info;
        pCodecMediaObject->GetInfo(&info);

        //
        // The codec has a fixed compression rate and the compressed packet contains a header
        //
		if( info.dwInputSize >  info.dwOutputSize)
        {
			//
            // Encoder
            //
			dCompressionRate = (DOUBLE)info.dwInputSize / (DOUBLE)(info.dwOutputSize - sizeof(VOICE_ENCODER_HEADER));
        }
		else
		{
            //
            // Decoder
            //
			dCompressionRate = (DOUBLE)info.dwOutputSize / (DOUBLE)(info.dwInputSize - sizeof(VOICE_ENCODER_HEADER));
		}

        *pwCodecBufferSize = (WORD)((DOUBLE)wPCMBufferSize / dCompressionRate) + sizeof(VOICE_ENCODER_HEADER);
    }
    else
    {
        *pwCodecBufferSize = 0;
    }

	return (QUEUE_S_OK);
}


//
// Class CQueueXMO implementation
//
//////////////////////////////////////////////////////////////////////////////
void CQueueXMO::Cleanup()
{
	if( NULL != m_pdHighWaterMarkQuality )
    {
		delete [] m_pdHighWaterMarkQuality;
    }

	if( NULL != m_pBufferPool )
    {
		delete [] m_pBufferPool;
    }

	if( NULL != m_pHeapForBuffers )
    {
		delete [] m_pHeapForBuffers;
    }

	if( NULL != m_pSavedBuffer )
    {
		delete [] m_pSavedBuffer;
    }
}

void CQueueXMO::SetConfigDefaults(LPQUEUE_XMO_CONFIG pConfig)
{
    //
    // In case pConfig members set to 0 -> use defaults
    //
	if( 0 == pConfig->wVoiceSamplingRate )
    {
		pConfig->wVoiceSamplingRate = 8000;
    }
	RIP_ON_NOT_TRUE("XVoiceQueueCreateMediaObject()", ( 8000 == pConfig->wVoiceSamplingRate));

	if( 0 ==  pConfig->wMsOfDataPerPacket)
    {
		pConfig->wMsOfDataPerPacket = 20;
    }
	RIP_ON_NOT_TRUE("XVoiceQueueCreateMediaObject()", ( 0 == pConfig->wMsOfDataPerPacket % 20 ));

	if( 0 ==  pConfig->wBufferSize)
    {
		pConfig->wBufferSize = 20;
    }
	RIP_ON_NOT_TRUE("XVoiceQueueCreateMediaObject()", (0 != pConfig->wBufferSize));


	if( 0 == pConfig->wMinDelay )
    {
		pConfig->wMinDelay = 80;
    }

	if( 0 ==  pConfig->wMaxDelay)
    {
		pConfig->wMaxDelay = 1000;
    }
	RIP_ON_NOT_TRUE("XVoiceQueueCreateMediaObject()", ( pConfig->wMaxDelay >= pConfig->wMinDelay ));

	if( 0 == pConfig->wInitialHighWaterMark )
    {
		pConfig->wInitialHighWaterMark = 80;
    }
	RIP_ON_NOT_TRUE("XVoiceQueueCreateMediaObject()", ( pConfig->wInitialHighWaterMark >= pConfig->wMinDelay ));

	if( 0.0 == pConfig->dIdealQuality )
    {
		pConfig->dIdealQuality = 0.005;
    }
	RIP_ON_NOT_TRUE("XVoiceQueueCreateMediaObject()", (( 0 <= pConfig->dIdealQuality ) && (1 >= pConfig->dIdealQuality)));

	pConfig->dInitialFrameStrength = (DOUBLE)(pConfig->wMsOfDataPerPacket)/(DOUBLE)30000;

}

HRESULT STDMETHODCALLTYPE CQueueXMO::Initialize( LPQUEUE_XMO_CONFIG pConfig )
{
	HRESULT hr = QUEUE_S_OK;
	int i;

	do
	{
		SetConfigDefaults(pConfig);

		//
        // Compute dimensions for the queue
        //
		m_wMsOfDataPerBuffer = pConfig->wMsOfDataPerPacket;
		m_wCodecBufferSize = pConfig->wBufferSize;
		m_wBufferPoolSize = pConfig->wMaxDelay / m_wMsOfDataPerBuffer;

		m_wHighWaterMark = pConfig->wInitialHighWaterMark;
		m_PreviousTime = 0;

		m_dIdealQuality = pConfig->dIdealQuality;
		m_dFrameStrength = pConfig->dInitialFrameStrength;
		m_dCurrentTalkspurtWeighting = 0;
		m_wNumberOfFramesInTalkspurt = 0;
		m_bCurrentTalkspurtID = 0;
		m_wErrorCount = 0;

		m_wMaxHighWaterMark = pConfig->wMaxDelay;
	    m_wMinHighWaterMark = pConfig->wMinDelay;

		m_wHighWaterMarkQualitySize = (m_wMaxHighWaterMark - m_wMinHighWaterMark) / m_wMsOfDataPerBuffer + 1;


		//
        // Allocate memory for the array of HWM quality history
        //
		m_pdHighWaterMarkQuality = new DOUBLE[m_wHighWaterMarkQualitySize];
		if ( NULL == m_pdHighWaterMarkQuality )
		{
			hr = QUEUE_E_OUTOFMEMORY;
			break;
		}

		//
        // Allocate memory for saved buffer for lost packets
        //
		m_pSavedBuffer = new BYTE[m_wCodecBufferSize];
		if( NULL ==  m_pSavedBuffer)
        {	
			hr = QUEUE_E_OUTOFMEMORY;
			break;
        }
				
		//
        // Allocate memory for the buffers
        //
		m_pHeapForBuffers = new BYTE[ m_wBufferPoolSize * m_wCodecBufferSize];		
		if ( NULL == m_pHeapForBuffers )
		{
			hr = QUEUE_E_OUTOFMEMORY;
			break;
		}

		//
        // Allocate memory for the list of buffers
        //
		m_pBufferPool = new BufferList[m_wBufferPoolSize];
		if ( NULL == m_pBufferPool )
		{
			Cleanup();
			hr = QUEUE_E_OUTOFMEMORY;
			break;
		}

		//
        // Initialize free buffers list 
        //
		for( i = 1 ; i < m_wBufferPoolSize - 1; i++ )
        {
			m_pBufferPool[i].m_pbBuffer = m_pHeapForBuffers + i * m_wCodecBufferSize;
			m_pBufferPool[i].m_pPrev = &m_pBufferPool[i - 1];
			m_pBufferPool[i].m_pNext = &m_pBufferPool[i + 1];
        }
		m_pFreeEntriesList = &m_pBufferPool[0];
		m_pBufferPool[0].m_pNext = &m_pBufferPool[1];
		m_pBufferPool[0].m_pbBuffer = m_pHeapForBuffers;
		m_pBufferPool[m_wBufferPoolSize - 1].m_pPrev = &m_pBufferPool[m_wBufferPoolSize - 2];
		m_pBufferPool[m_wBufferPoolSize - 1].m_pbBuffer = m_pHeapForBuffers + (m_wBufferPoolSize - 1) * m_wCodecBufferSize;

		//
		// Initialize the array of HWM quality history
		//
		for( i = 0 ; i < m_wHighWaterMarkQualitySize ; i++ )
        {
			m_pdHighWaterMarkQuality[i] = m_dIdealQuality;
        }
	}
	while( FALSE );

	return( hr );
}

HRESULT STDMETHODCALLTYPE CQueueXMO::Process( LPCXMEDIAPACKET pSrcBuffer, LPCXMEDIAPACKET pDstBuffer )
{
	HRESULT hr = QUEUE_S_OK;
    
    if( NULL != pSrcBuffer )
    {
    	hr = InputProcess(pSrcBuffer);
    }

	if( NULL != pDstBuffer )
    {
		hr = OutputProcess(pDstBuffer);
    }
    
    return( hr );
}


HRESULT CQueueXMO::InputProcess(LPCXMEDIAPACKET pInMediaPacket)
{
	HRESULT hr = QUEUE_S_OK;
    
    do
    {
		if( VOICE_MESSAGE_TYPE_VOICE != ((PVOICE_ENCODER_HEADER)(pInMediaPacket->pvBuffer))->bType)
        {
			if(m_bStartTiming)
			{
#ifdef _DEBUG_PRINT
			    DebugPrint("CQueueXMO::InputProcess...Drop silence packet!\n");
#endif
			    break;
			}
        }

		//
        // Get an empty buffer for putting the new data in
        //
		BufferList *pWorkingBuffer = GetInputWorkingBuffer();
		if( NULL == pWorkingBuffer )
        {
			hr = QUEUE_E_FULL;
#ifdef _DEBUG_PRINT
			DebugPrint("CQueueXMO::InputProcess...The queue is full!\n");
#endif
			break;
        }
     

		//
        // Fill the buffer with the contents of input media packet
        //
		WORD wInSeqNo = ((PVOICE_ENCODER_HEADER)(pInMediaPacket->pvBuffer))->wSeqNum;
		BYTE bMsgNum = ((PVOICE_ENCODER_HEADER)(pInMediaPacket->pvBuffer))->bMsgNum;

		if( !m_bStartTiming )
	    {
			//
			// Start measuring the real time
			//
			m_RealStartOutputTime = GetTickCount();
			m_LogicalOutputTime = 0;
			m_wCurrentSeqNo = wInSeqNo;
		    m_bCurrentTalkspurtID = bMsgNum;

			//
            // Up to 1 second of difference between arrived sequences 
			// After that, we do some computation to recover from the "discontinuity"
            // that came up on the other end
			//
			m_wSafeDeltaSeq = 1000 / m_wMsOfDataPerBuffer;
			
			m_bStartTiming = TRUE;
		}

		//
        // Check for a new talkspurt
        //
		if( bMsgNum !=  m_bCurrentTalkspurtID )
        {
			//
            // Get into account the completed talkspurt - adapt to new network conditions
            //
			RecomputeQueueParameters();
			m_bCurrentTalkspurtID = bMsgNum;
        }
		
			

		if( wInSeqNo + m_wSafeDeltaSeq < m_wCurrentSeqNo )
        {
			// Assuming reset sequence numbers on the other side
		    // GetTickCount() - m_RealStartOutputTime + m_wMsOfDataPerBuffer -> fair guess of this packet's output time
		    // round to complete packet time 
		    TimeStamp outputTime = GetTickCount() - m_RealStartOutputTime + m_wMsOfDataPerBuffer;
		    outputTime -= (outputTime % m_wMsOfDataPerBuffer);
			
			//
            // Make sure 2 packets don't have the same output time
            //
			pWorkingBuffer->m_timestamp = max(outputTime , m_PreviousTime + m_wMsOfDataPerBuffer);

        }
		else
		{
			//
            // Normal sequencing
            //
			pWorkingBuffer->m_timestamp = m_PreviousTime + (wInSeqNo - m_wCurrentSeqNo) * m_wMsOfDataPerBuffer;
		}

		if( 0 == m_wNumberOfFramesInTalkspurt  )
        {
			//
			// Resync the local clock with the time given by the input
			//
#ifdef _DEBUG_PRINT
			DebugPrint("***Resync clock - Before: %d\n" , m_RealStartOutputTime);
#endif

			m_RealStartOutputTime = GetTickCount() - pWorkingBuffer->m_timestamp;

#ifdef _DEBUG_PRINT
			DebugPrint("***Resync clock - After: %d\n" , m_RealStartOutputTime);
#endif
        }
		m_wNumberOfFramesInTalkspurt++;

#ifdef _DEBUG_PRINT
		DebugPrint("wInSeqNo=%d bCurrentTalkspurtID=%d\n", wInSeqNo , m_bCurrentTalkspurtID);
#endif

		if( m_LogicalOutputTime > pWorkingBuffer->m_timestamp)
        {
			//
            // This buffer is late
            //
#ifdef _DEBUG_PRINT
			DebugPrint("Buffer late: pWorkingBuffer->m_timestamp = %d\n", pWorkingBuffer->m_timestamp);
#endif
			if( bMsgNum ==  m_bCurrentTalkspurtID )
            {
           		//
				// Count it as an error only if it's part of the current talkspurt
				//
				IncrementErrorCount();
			}
		    AddFreeBuffer(pWorkingBuffer);
        }
		else
		{
#ifdef _DEBUG_PRINT
			DebugPrint("Insert buffer: pWorkingBuffer->m_timestamp = %d\n", pWorkingBuffer->m_timestamp);
#endif

			memcpy(pWorkingBuffer->m_pbBuffer , pInMediaPacket->pvBuffer , m_wCodecBufferSize);

			//
			// Add the buffer to the list of in use entries
			//
			AddInUseBuffer(pWorkingBuffer);
			
			//
			// Update the current sequence number and previous time
			//
			m_wCurrentSeqNo = wInSeqNo;
			m_PreviousTime = pWorkingBuffer->m_timestamp;
			
		}			

		//
        // Update output parameters
        //
		if(pInMediaPacket->pdwCompletedSize) 
		{
            *pInMediaPacket->pdwCompletedSize = SUCCEEDED(hr) ? pInMediaPacket->dwMaxSize : 0;
        }

        if(pInMediaPacket->pdwStatus) 
		{
            *pInMediaPacket->pdwStatus = SUCCEEDED(hr) ? XMEDIAPACKET_STATUS_SUCCESS : XMEDIAPACKET_STATUS_FAILURE;
        }

        if (pInMediaPacket->hCompletionEvent)
		{
            SetEvent(pInMediaPacket->hCompletionEvent);
        }
    
        hr = QUEUE_S_OK;
    }
    while( FALSE );
    
    return( hr );

}


HRESULT CQueueXMO::OutputProcess(LPCXMEDIAPACKET pOutMediaPacket)
{
	HRESULT hr = QUEUE_S_OK;
	BOOL bReturnSilence;
	BOOL bIsNextPacketLost;
    
	assert(pOutMediaPacket->dwMaxSize % m_wCodecBufferSize == 0);

    do
    {
		if( !m_bStartTiming )
        {
			hr = QUEUE_E_NOINPUTYET;
#ifdef _DEBUG_PRINT
			DebugPrint("CQueueXMO::OutputProcess...No input yet!\n");
#endif
			break;
        }
		//
        // Get the next buffer to be returned
        //
		BufferList *pWorkingBuffer = GetOutputWorkingBuffer(&bReturnSilence , &bIsNextPacketLost);	        
		memset(pOutMediaPacket->pvBuffer , 0 , pOutMediaPacket->dwMaxSize);

		if( NULL == pWorkingBuffer )
        {
			if(!bReturnSilence)
			{
				//
                // The high water mark is not reached
                //
				hr = QUEUE_E_HWMNOTREACHED;
#ifdef _DEBUG_PRINT
				DebugPrint("CQueueXMO::OutputProcess...High water mark not reached!\n");
#endif
				break;
			}
			else
			{
				//
                // Packet lost or late
                //
			    if(m_bVoiceReturned)
				{
    				//
                    // Mark the starting moment for rendering previous packet
                    //
				    m_bVoiceReturned = FALSE;
			        m_wAttenuatedBackupMs = 0;
				}

			    if(m_wAttenuatedBackupMs < MAX_MILISECONDS_OF_ATTENUATED_VOICE)
				{
					m_wAttenuatedBackupMs += m_wMsOfDataPerBuffer;

					CopyAttenuatedBuffer(pOutMediaPacket , 1.0);

					// m_LastOutputInfo.nMaxPower is the same as the previous

#ifdef _DEBUG_PRINT
					DebugPrint("CQueueXMO::OutputProcess...Return attenuated(1.0) previous packet!\n");
#endif
				}
				else
				{
				    //
                    // Silence returned for some time now
                    //
#ifdef _DEBUG_PRINT
				    DebugPrint("CQueueXMO::OutputProcess...Return silence!\n");
#endif
				}
			}
        }
		else
		{
			//
            // Copy working buffer in output buffer 
            //
			memcpy(pOutMediaPacket->pvBuffer, pWorkingBuffer, pOutMediaPacket->dwMaxSize);
			
#ifdef _DEBUG_PRINT
			DebugPrint("CQueueXMO::Return buffer pWorkingBuffer->m_timestamp = %d\n", pWorkingBuffer->m_timestamp);
#endif

			//
			// Free the working buffer
			//
			AddFreeBuffer(pWorkingBuffer);

			m_bVoiceReturned = TRUE;
			if( bIsNextPacketLost )
            {
				//
                // Save this buffer in case next one doesn't show up until its output time
                //
				memcpy(m_pSavedBuffer , pOutMediaPacket->pvBuffer , pOutMediaPacket->dwMaxSize); 
            }

			
		}
    
		//
        // Update the logical output time
        //
		m_LogicalOutputTime += m_wMsOfDataPerBuffer;

        hr = QUEUE_S_OK;
    }
    while( FALSE );

	//
    // Update output parameters
    //
	if(pOutMediaPacket->pdwCompletedSize) 
	{
	    *pOutMediaPacket->pdwCompletedSize = SUCCEEDED(hr) ? pOutMediaPacket->dwMaxSize : 0;
    }

    if(pOutMediaPacket->pdwStatus) 
	{
        *pOutMediaPacket->pdwStatus = SUCCEEDED(hr) ? XMEDIAPACKET_STATUS_SUCCESS : XMEDIAPACKET_STATUS_FAILURE;
    }

    if (pOutMediaPacket->hCompletionEvent)
	{
        SetEvent(pOutMediaPacket->hCompletionEvent);
    }
    
    return( hr );
}

BufferList* CQueueXMO::GetInputWorkingBuffer()
{
	BufferList *pWorkingBuffer;

	if( NULL == m_pFreeEntriesList )
    {
		//
        // All the buffers are in use: drop this packet
        //
		pWorkingBuffer = NULL;
    }
	else
	{
		//
        // Get the first free buffer
        //
		pWorkingBuffer = RemoveFirstBuffer(&m_pFreeEntriesList);
	}

	return pWorkingBuffer;

}


BufferList* CQueueXMO::RemoveFirstBuffer(BufferList **pHead , BufferList **pTail)
{
	assert(*pHead);

	//
    // Remove the head of the double linked list and return it
    //
	BufferList *pTemp = *pHead;
	*pHead = pTemp->m_pNext;

	if( NULL !=  *pHead)
    {
		(*pHead)->m_pPrev = NULL;
    }
	pTemp->m_pNext = NULL;

	if(( NULL != pTail ) && (NULL == *pHead))
    {
		*pTail = NULL;
    }

	return pTemp;

}

void CQueueXMO::AddInUseBuffer(BufferList *pBuffer)
{
	m_wInUseEntriesCount++;

	if( NULL == m_pInUseEntriesListHead )
    {
		//
        // Empty in use list
        //
		assert(NULL == m_pInUseEntriesListTail);
		m_pInUseEntriesListHead = m_pInUseEntriesListTail = pBuffer;
    }
	else
	{
		//
        // At least one element, insert in sorted list
        //
		BufferList *pTmpBuffer = m_pInUseEntriesListTail;
		while((NULL != pTmpBuffer) && (pBuffer->m_timestamp < pTmpBuffer->m_timestamp))
		{		
			pTmpBuffer = pTmpBuffer->m_pPrev;
		}

		if( NULL == pTmpBuffer )
        {
			//
            // We are at the beginning of the list
            //
			m_pInUseEntriesListHead->m_pPrev = pBuffer;
			pBuffer->m_pNext = m_pInUseEntriesListHead;
			m_pInUseEntriesListHead = pBuffer;
        }
		else
		{
			if( pBuffer->m_timestamp != pTmpBuffer->m_timestamp )
            {
			    //
                // Insert after pTmpBuffer
			    //
			    pBuffer->m_pNext = pTmpBuffer->m_pNext;
			    pBuffer->m_pPrev = pTmpBuffer;

			    pTmpBuffer->m_pNext = pBuffer;
			    if( NULL == pBuffer->m_pNext )
				{
				    m_pInUseEntriesListTail = pBuffer;
				}
			    else
				{
				    (pBuffer->m_pNext)->m_pPrev = pBuffer;
				}	
            }
			else
			{
				//
                // Drop duplicate
                //
				m_wInUseEntriesCount--;
			}
		}
	}
}

BufferList* CQueueXMO::GetOutputWorkingBuffer(BOOL *pbReturnSilence , BOOL *pbIsNextPacketLost)
{
	BufferList *pOutBuffer = NULL;
	*pbReturnSilence = FALSE;
	*pbIsNextPacketLost = TRUE;

	assert(((0 == m_wInUseEntriesCount) && (NULL == m_pInUseEntriesListHead)) ||
		   ((0 != m_wInUseEntriesCount) && (NULL != m_pInUseEntriesListHead)));

	DWORD realOutputTime = GetTickCount() - m_RealStartOutputTime;

#ifdef _DEBUG_PRINT
	DebugPrint("CQueueXMO::LogicalOutputTime = %d InUseEntriesCount = %d RealOutputTime=%d HWM=%d\n" , 
		        m_LogicalOutputTime , m_wInUseEntriesCount , realOutputTime , m_wHighWaterMark);
#endif


	//
    // 1. Because a packet can be asked for output just before the high water mark is reached, 
	// allow a window of 5 ms around HWM for output
    //
	//
    // 2. If more packets in the queue than HWM enforces, let them go
    //
	if( ((LONG)realOutputTime - (LONG)m_LogicalOutputTime >= (LONG)m_wHighWaterMark - 5) ||
		(m_wInUseEntriesCount > m_wHighWaterMark / m_wMsOfDataPerBuffer))
	{
		//
		// We send to output packet either silence or decompressed data
		//
		if(( m_wInUseEntriesCount > 0 ) && (m_LogicalOutputTime == m_pInUseEntriesListHead->m_timestamp))
		{
			//
			// The buffer is in the list
			//
			pOutBuffer = RemoveFirstBuffer(&m_pInUseEntriesListHead , &m_pInUseEntriesListTail); 
			m_wInUseEntriesCount--;
			if( (m_wInUseEntriesCount > 0 ) && (m_pInUseEntriesListHead->m_timestamp == pOutBuffer->m_timestamp + m_wMsOfDataPerBuffer) )
            {
				*pbIsNextPacketLost = FALSE;
            }
		}
		else
		{
			*pbReturnSilence = TRUE;
		}
	}
	
	return pOutBuffer;
}

void CQueueXMO::AddFreeBuffer(BufferList *pBuffer)
{
	
	//
    // Attach buffer to the head of free buffers list
    //
	if( NULL == m_pFreeEntriesList )
    {
		m_pFreeEntriesList = pBuffer;
    }
	else
	{
		m_pFreeEntriesList->m_pPrev = pBuffer;
		pBuffer->m_pNext = m_pFreeEntriesList;
		m_pFreeEntriesList = pBuffer;
	}
}


void CQueueXMO::RecomputeQueueParameters()
{
	WORD wCurrentIndex = (m_wHighWaterMark - m_wMinHighWaterMark) / m_wMsOfDataPerBuffer;

	DOUBLE dTalkspurtQuality = min( ((DOUBLE)m_wErrorCount) / ((DOUBLE)m_wNumberOfFramesInTalkspurt) , 1.0);

	assert(wCurrentIndex < m_wHighWaterMarkQualitySize);

#ifdef _DEBUG_PRINT
	DebugPrint("***CurrentTalkspurt = %d NumberOfFramesInTalkspurt = %d Errors = %d m_dFrameStrength = %f\n",
		       m_bCurrentTalkspurtID , m_wNumberOfFramesInTalkspurt , m_wErrorCount , m_dFrameStrength);
#endif

	//
    // Compute new parameters
    //
	m_dCurrentTalkspurtWeighting = min( m_dFrameStrength * m_wNumberOfFramesInTalkspurt , 1.0);
	m_pdHighWaterMarkQuality[wCurrentIndex] = m_pdHighWaterMarkQuality[wCurrentIndex] * (1 - m_dCurrentTalkspurtWeighting) +
		                                      dTalkspurtQuality * m_dCurrentTalkspurtWeighting;

	//
    // Reset counters for the new talkspurt
    //
	m_wNumberOfFramesInTalkspurt = 0;
	m_wErrorCount = 0;

	if( m_pdHighWaterMarkQuality[wCurrentIndex] < m_dIdealQuality )
    {
		//
        // Better quality --> try to decrease the highwatermark
        //
		if( wCurrentIndex > 0 )
        {
			//
            // See if wCurrentIndex - 1 is closer to ideal quality
            //
			if( fabs( m_pdHighWaterMarkQuality[ wCurrentIndex - 1 ] - m_dIdealQuality) < 
				fabs( m_pdHighWaterMarkQuality[ wCurrentIndex ] - m_dIdealQuality))
            {
				m_wHighWaterMark -= m_wMsOfDataPerBuffer;

				//
                // When we decrease the HWM, we already render packets with the delay introduced by the previous HWM
				// By skipping one packet(if the queue was empty, we don't lose anything), we reduce the delay 
				// between LOT and ROT
                //
				m_LogicalOutputTime += m_wMsOfDataPerBuffer;

		        if(( m_wInUseEntriesCount > 0 ) && 
				   (m_LogicalOutputTime > m_pInUseEntriesListHead->m_timestamp))
                {
					BufferList *pDroppedBuffer = RemoveFirstBuffer(&m_pInUseEntriesListHead , &m_pInUseEntriesListTail); 
					m_wInUseEntriesCount--;
					AddFreeBuffer(pDroppedBuffer);
                }
            }
        }

    }
	else
	{
		//
        // Worse quality --> try to increase the highwatermark 
        //
		if( wCurrentIndex + 1 < m_wHighWaterMarkQualitySize  )
        {
			//
            // See if wCurrentIndex + 1 is closer to ideal quality
            //
			if( fabs( m_pdHighWaterMarkQuality[ wCurrentIndex + 1 ] - m_dIdealQuality) < 
				fabs( m_pdHighWaterMarkQuality[ wCurrentIndex ] - m_dIdealQuality))
            {
				m_wHighWaterMark += m_wMsOfDataPerBuffer;

				//
                // In order for the queueXMO to behave continuous, and the hwm stuff to not affect the user of the queue,
                // we will "play again" one packet to give time to the HWM to be reached
				// By changing the LOT, there will be silence(attenuated packet) returned
				//
				assert(0 != m_LogicalOutputTime);
				m_LogicalOutputTime -= m_wMsOfDataPerBuffer;
            }
        }

	}

#ifdef _DEBUG_PRINT
	DebugPrint("***TalkspurtQuality = %f CurrentTalkspurtWeighting = %f HighWaterMarkQuality[%d] = %f HighWaterMark = %d\n" ,
		       dTalkspurtQuality , m_dCurrentTalkspurtWeighting , wCurrentIndex , 
			   m_pdHighWaterMarkQuality[wCurrentIndex] , m_wHighWaterMark);
#endif



}

void CQueueXMO::CopyAttenuatedBuffer(LPCXMEDIAPACKET pOutMediaPacket , DOUBLE dAttenuationFactor)
{
	assert(pOutMediaPacket);

	//
    // TBD : take into account attenuation factor
    //
	memcpy(pOutMediaPacket->pvBuffer , m_pSavedBuffer , pOutMediaPacket->dwMaxSize);

#ifdef _DEBUG_PRINT
	DebugPrint("Copy attenuated buffer = %d\n", pOutMediaPacket->dwMaxSize);
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\xodash\XODashUpdate\xODash.h ===
//-----------------------------------------------------------------------------
// File: XODash.h
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef XBAPP_H
#define XBAPP_H

#include <xtl.h>
#include <xgraphics.h>
#include <stdio.h>
#include "XBInput.h"
#include "XBUtil.h"
#include  "MsgDialog.h"



//-----------------------------------------------------------------------------
// Global access to common members
//-----------------------------------------------------------------------------
extern LPDIRECT3DDEVICE8 g_pd3dDevice;


//
// Define the dash title ID
//
#define AUTOUPD_DASH_TITLE_ID            ((DWORD)0xfffe0000)

#ifndef ARRAYSIZE
#define ARRAYSIZE(a)    (sizeof(a)/sizeof((a)[0]))
#endif

//-----------------------------------------------------------------------------
// Name: class XOApplication
// Desc: holds all really high level objects, sets up D3D
//          Initialize()          - To initialize the device-dependant objects
//          FrameMove()           - To animate the scene
//          Render()              - To render the scene
//-----------------------------------------------------------------------------
class XOApplication
{
protected:
    // Main objects used for creating and rendering the 3D scene
    D3DPRESENT_PARAMETERS m_d3dpp;
    LPDIRECT3D8           m_pD3D;              // The D3D enumerator object
    LPDIRECT3DDEVICE8     m_pd3dDevice;        // The D3D rendering device
    LPDIRECT3DSURFACE8    m_pBackBuffer;       // The backbuffer
    LPDIRECT3DSURFACE8    m_pDepthBuffer;      // The depthbuffer

    // Variables for timing
    float      m_fTime;             // Current absolute time in seconds
    float      m_fElapsedTime;      // Elapsed absolute time since last frame
	float      m_fStartTime;        // absolute start time in seconds
	float      m_fSecsPerTick;

	DWORD      m_dwLastUpdate;

    // Members to init the XINPUT devices.
    XDEVICE_PREALLOC_TYPE* m_InputDeviceTypes;
    DWORD                  m_dwNumInputDeviceTypes;
    XBGAMEPAD*             m_Gamepad;
    XBGAMEPAD              m_DefaultGamepad;

    // Overridable functions for the 3D scene created by the app
    virtual HRESULT Initialize();
    virtual HRESULT FrameMove();
    virtual HRESULT Render();
    virtual HRESULT Cleanup();

public:

    // Functions to create, run, and clean up the application
    HRESULT Create();
    INT     Run();
    VOID    Destroy();

    // Internal constructor
    XOApplication();

	float	GetTime(){ return m_fTime; }


private:
	HRESULT InitAudio();
	TCHAR					m_szAppDir[MAX_PATH];
	CProgressDialog m_ProgressBar;
	HRESULT CreateProgressBar();

	DWORD RebootWhilePreservingDDrive(
			    LPCSTR lpTitlePath,
    		    PLD_FROM_TITLE_UPDATE pldftu
			    );
};


extern XOApplication	theApp; // the single instance


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\xvchat\QueueXMOp.h ===
//-----------------------------------------------------------------------------
// File: QueueXMOp.h
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef QUEUEXMOP_H_INCLUDED
#define QUEUEXMOP_H_INCLUDED

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef VOICEPEERAFX_H
#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <stddef.h>
#include <ntos.h>

#ifdef __cplusplus
}
#endif // __cplusplus
#endif
#define  NODSOUND
#include <xtl.h>
#include <dsound.h>
#include "xvchat.h"
#include <assert.h>


//
// Typedefs
//
//////////////////////////////////////////////////////////////////////////////
typedef DWORD TimeStamp;
typedef DWORD TimeInterval;

//
// Constants
//
//////////////////////////////////////////////////////////////////////////////
const WORD MAX_MILISECONDS_OF_ATTENUATED_VOICE = 80;

//
// Debug Tools
//
//////////////////////////////////////////////////////////////////////////////
extern "C"
{
	ULONG __cdecl
	DebugPrint(
		PCHAR Format,
		...
		);
}

#define VERIFY_SUCCESS(xprsn) \
{\
    HRESULT hrTemp = (xprsn);\
    if(!SUCCEEDED(hrTemp))\
    {\
        DebugPrint("Call failed: %s(%d): 0x%0.8x\n", __FILE__, __LINE__, hrTemp);\
    }\
}

//
// Structures
//
//////////////////////////////////////////////////////////////////////////////
struct BufferList
{
	TimeStamp		m_timestamp;
	BYTE			*m_pbBuffer;
	BufferList      *m_pPrev;
	BufferList      *m_pNext;
	
	BufferList() : m_timestamp(0), m_pbBuffer(NULL) , m_pPrev(NULL), m_pNext(NULL){}
	~BufferList(){}
};

//
// Class CQueueXMO
//
//////////////////////////////////////////////////////////////////////////////
class CQueueXMO:public XMediaObject 
{
public:
	//
    // Construction/Destruction
    //
	CQueueXMO() : m_cRef(1),
	              m_pBufferPool(NULL),
				  m_pHeapForBuffers(NULL),
		          m_pFreeEntriesList(NULL),
				  m_pInUseEntriesListHead(NULL),
				  m_pInUseEntriesListTail(NULL),
				  m_LogicalOutputTime(0),
				  m_RealStartOutputTime(0),
				  m_wCurrentSeqNo(0),
      			  m_wInUseEntriesCount(0),
				  m_bStartTiming(FALSE),
				  m_pdHighWaterMarkQuality(NULL),
				  m_pSavedBuffer(NULL),
				  m_bVoiceReturned(TRUE)
	{
	}

	virtual ~CQueueXMO()
	{
		Cleanup();
	}


	//
    // Initialization
    //
	HRESULT STDMETHODCALLTYPE Initialize( LPQUEUE_XMO_CONFIG pConfig );

	//
    // IUnknown Methods
    //
    virtual STDMETHODIMP_(ULONG) AddRef( void ) 
	{
       return InterlockedIncrement( (long*) &m_cRef );
    }

    virtual STDMETHODIMP_(ULONG) Release( void ) 
	{
       long l = InterlockedDecrement( (long*) &m_cRef );

       if ( l == 0 )
	   {
          delete this;
	   }

       return l;
    }
    
	//
    // XMediaObject methods
    //
    virtual HRESULT STDMETHODCALLTYPE Flush( void )
    {
		m_wHighWaterMark = 0;
        return QUEUE_S_OK;
    }

    virtual HRESULT STDMETHODCALLTYPE Discontinuity( void )
    {
        return QUEUE_S_OK;
    }

    virtual HRESULT STDMETHODCALLTYPE GetStatus( LPDWORD pdwStatus )
    {
        return QUEUE_S_OK;
    }

	virtual HRESULT STDMETHODCALLTYPE GetInfo( LPXMEDIAINFO pXMediaInfo )
	{
		return QUEUE_S_OK;
	}
    virtual HRESULT STDMETHODCALLTYPE Process( LPCXMEDIAPACKET pSrcBuffer, LPCXMEDIAPACKET pDstBuffer );

	
protected:
	void Cleanup();
	void SetConfigDefaults(LPQUEUE_XMO_CONFIG pConfig);
	ULONG m_cRef;

	//
    // Specific queuing members
    //
protected:
	BufferList       *m_pBufferPool;         // The array of BufferList from which the Free and InUse lists are composed
	BYTE             *m_pHeapForBuffers;     // Amount of contigous memory for the actual codec buffers
	WORD              m_wBufferPoolSize ;    // Maximum number of free buffers
	WORD              m_wMsOfDataPerBuffer;  // Miliseconds of compressed data in a codec buffer
	WORD              m_wCodecBufferSize;    // Size of codec buffer in bytes(contains header + compressed voice)

	BufferList       *m_pFreeEntriesList;       // Double linked list of free buffers to be used to get the input from process
	BufferList       *m_pInUseEntriesListHead;  // Double linked list of buffers to be used to process input data
	BufferList       *m_pInUseEntriesListTail;  // End of in use list

	TimeStamp         m_LogicalOutputTime;   // Time for an input packet to be introduced into the output stream
	TimeStamp         m_PreviousTime;        // Most recent time a packet was introduced into the output stream
	TimeStamp         m_RealStartOutputTime; // The real time that the output process began with; reference time
	WORD              m_wCurrentSeqNo;       // Sequence number for the current received packet
	WORD              m_wSafeDeltaSeq;       // Safe difference between input sequence numbers

	WORD			  m_wHighWaterMark;      // Current high water mark(in miliseconds)
	WORD			  m_wInUseEntriesCount;  // Number of buffers waiting in the queue

	BOOL              m_bStartTiming;        // Start measuring real time of the queue

	DOUBLE            *m_pdHighWaterMarkQuality;    // Array that keeps the history of performances of the queue
	WORD	          m_wMaxHighWaterMark;			// Maximum delay for the queue in miliseconds
	WORD	          m_wMinHighWaterMark;			// Minimum delay for the queue in miliseconds
	WORD              m_wHighWaterMarkQualitySize;  // Size of the array

	DOUBLE            m_dIdealQuality;              // Ideal quality for high water mark 
	DOUBLE            m_dFrameStrength;             // Current frame strength
	DOUBLE            m_dCurrentTalkspurtWeighting; // Computed current talkspurt weighting
	WORD              m_wNumberOfFramesInTalkspurt; // Counter for each talkspurt
	BYTE              m_bCurrentTalkspurtID;        // The message ID of the current talkspurt
	WORD              m_wErrorCount;                // Number of errors in current talkspurt

	BYTE             *m_pSavedBuffer;          // Buffer saved between outputs in case of lost packets
	BOOL              m_bVoiceReturned;        // True if previous output buffer contained voice
	WORD              m_wAttenuatedBackupMs;   // Number of miliseconds of attenuated voice provided for lost voice

	//
    // Specific queuing methods
    //
protected:
	void RecomputeQueueParameters();
	void IncrementErrorCount(){ m_wErrorCount++; }
	void AddFreeBuffer(BufferList *pBuffer);
	void AddInUseBuffer(BufferList *pBuffer);

	BufferList* RemoveFirstBuffer(BufferList **pHead , BufferList **pTail = NULL);
	BufferList* GetInputWorkingBuffer();
	BufferList* GetOutputWorkingBuffer(BOOL *pbReturnSilence , BOOL *pbIsNextPacketLost);

	HRESULT OutputProcess(LPCXMEDIAPACKET pOutMediaPacket);
	HRESULT InputProcess(LPCXMEDIAPACKET pInMediaPacket);

	void CopyAttenuatedBuffer(LPCXMEDIAPACKET pOutMediaPacket , DOUBLE dAttenuationFactor);

};


#endif  // QUEUEXMOP_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\xvchat\XVoiceChat.cpp ===
//-----------------------------------------------------------------------------
// File: XVoiceChat.cpp
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include "XVoiceChatp.h"

//////////////////////////////////////////////////////////////////////////////
/*XOnlineVChatStartup - Routine Description:

    Initializes the voice chat manager on the xbox. 

Arguments:
    pConfig[in]            Pointer to the configuration structure.
    phVChatMgr[out]        Handle to the created voice chat manager.

Return Value:

    HRESULT

Memory Allocation:

    Allocates voice chat manager.
*/
//////////////////////////////////////////////////////////////////////////////
XBOXAPI
HRESULT
WINAPI 
XOnlineVChatStartup(
       IN  LPVOICE_CHAT_CONFIG   pConfig, 
	   OUT PHANDLE               phVChatMgr
	   )
{
    HRESULT hr = S_OK;

    assert(NULL != pConfig);
    assert(NULL != phVChatMgr);
    
    XONVCHAT_MGR_HANDLE hVChatMgr = NULL;

    *phVChatMgr = NULL;    

   
    do
    {
        //
        // Allocate space for the voice chat manager structures in memory
        //
        hVChatMgr = new CCommunicatorMgr;
        if( NULL ==  hVChatMgr)
        {
            hr = E_OUTOFMEMORY;
            break;
        }

        //
        // Initialize the voice chat manager structure
        //
        hr = hVChatMgr->Initialize(pConfig);
        if( FAILED( hr ) )
        {
            break;
        }
    }
    while( FALSE );
    
    if( FAILED( hr ) )
    {
        if( NULL != hVChatMgr )
        {
            //
            // Cleanup allocated memory
            //
            delete hVChatMgr;
        }
    }
    else
    {
        //
        //  Return the handle to the newly created voice chat manager
        //
        *phVChatMgr = hVChatMgr;
    }

    return( hr );
}

//////////////////////////////////////////////////////////////////////////////
/*XOnlineVChatChatterAdd - Routine Description:

    Adds a player from a team to the voice chat going on on this machine. 

Arguments:
    hVChatMgr[in]            Handle to the voice chat manager.
    bTeamNo[in]              Team # in which the player will be added.
	bPlayerNo[in]            Player # whithin a game ( 0 - 256 ; maximum players in a game 16 )
	bHeadsetPort[in]         Headset port (0 - 3) if the player is on this machine, 0xFF if it's not

Return Value:

    HRESULT

Memory Allocation:

    Allocates CCommunicator resources for a player on the local machine.
	Allocates a QueueXMO structure for a player on another XBOX.
*/
//////////////////////////////////////////////////////////////////////////////
XBOXAPI
HRESULT
WINAPI 
XOnlineVChatChatterAdd(
       IN HANDLE                   hVChatMgr, 
	   IN BYTE                     bTeamNo, 
	   IN BYTE                     bPlayerNo, 
	   IN BYTE                     bHeadsetPort
	   )
{
	return (S_OK);
}

//////////////////////////////////////////////////////////////////////////////
/*XOnlineVChatChatterRemove - Routine Description:

    Removes a player from the voice chat going on on this machine. 

Arguments:
    hVChatMgr[in]            Handle to the voice chat manager.
	bPlayerNo[in]            Player # whithin a game ( 0 - 256 ; maximum players in a game 16 )
	
Return Value:

    HRESULT

Memory Allocation:

    No. (Frees the memory allocated to the player's resources)
*/
//////////////////////////////////////////////////////////////////////////////
XBOXAPI
HRESULT
WINAPI 
XOnlineVChatChatterRemove(
       IN HANDLE                   hVChatMgr, 
	   IN BYTE                     bPlayerNo
	   )
{
	return (S_OK);
}

//////////////////////////////////////////////////////////////////////////////
/*XOnlineVChatChatterGetStates - Routine Description:

    Tells the client which are the current state of the communicators on each port
	(connected/not connected).

Arguments:
    hVChatMgr[in]            Handle to the voice chat manager.
	pbStatus[out]            The last four bytes represent the status of the communicators
	                         To extract specific information, the client should apply the 
							 masks defined by COMMUNICATORS array.
Return Value:

    HRESULT

Memory Allocation:

    No. 
*/
//////////////////////////////////////////////////////////////////////////////
XBOXAPI
HRESULT
WINAPI 
XOnlineVChatChatterGetStates(
       IN HANDLE                   hVChatMgr, 
	   OUT PBYTE                   pbStatus
	   )
{
	return (S_OK);
}

//////////////////////////////////////////////////////////////////////////////
/*XOnlineVChatMute - Routine Description:

    Mutes a certain chatter for one of the players.

Arguments:
    hVChatMgr[in]            Handle to the voice chat manager.
	bMutedPlayerNo[in]       The player # to be muted.
    bMutingPlayerNo[in]      The player # that will see the effect of the muting.

Return Value:

    HRESULT

Memory Allocation:

    No. 
*/
//////////////////////////////////////////////////////////////////////////////
XBOXAPI
HRESULT
WINAPI 
XOnlineVChatMute(
       IN HANDLE                   hVChatMgr, 
	   IN BYTE                     bMutedPlayerNo, 
	   IN BYTE                     bMutingPlayerNo
	   )
{
	return (S_OK);
}

//////////////////////////////////////////////////////////////////////////////
/*XOnlineVChatVoiceEffect - Routine Description:

    Applies a voice effect to one player's voice.

Arguments:
    hVChatMgr[in]            Handle to the voice chat manager.
	bPlayerNo[in]            The player # whose voice will be masked.
    voiceEffect[in]          The voice effect applied (from the VOICE_EFFECTS 
	                         enumeration).

Return Value:

    HRESULT

Memory Allocation:

    No. 
*/
//////////////////////////////////////////////////////////////////////////////
XBOXAPI
HRESULT
WINAPI 
XOnlineVChatVoiceEffect(
       IN HANDLE                   hVChatMgr, 
	   IN BYTE                     bPlayerNo, 
	   IN VOICE_EFFECTS            voiceEffect
	   )
{
	return (S_OK);
}

//////////////////////////////////////////////////////////////////////////////
/*XOnlineVChatPacketReceive - Routine Description:

    Gives the voice chat manager the packet that came from the network. The mgr
	breaks the big network packet into pieces and distributes them into the appropriate
	queues. No voice processing involved.

Arguments:
    hVChatMgr[in]            Handle to the voice chat manager.
	pvNetworkPacketIn[in]    Pointer to the network packet.
    bNetworkPacketInSize[in] Size of the network packet.

Return Value:

    HRESULT

Memory Allocation:

    No. 
*/
//////////////////////////////////////////////////////////////////////////////
XBOXAPI
HRESULT
WINAPI 
XOnlineVChatPacketReceive(
       IN HANDLE                   hVChatMgr, 
	   IN PVOID                    pvNetworkPacketIn, 
	   IN BYTE                     bNetworkPacketInSize
	   )
{
	return (S_OK);
}

//////////////////////////////////////////////////////////////////////////////
/*XOnlineVChatPacketSend - Routine Description:

    Copies the current network packet internally created to a buffer provided 
	by the client.

Arguments:
    hVChatMgr[in]             Handle to the voice chat manager.
	pvNetworkPacketOut[in]    Pointer to the network packet.
    bNetworkPacketOutSize[in] Size of the network packet.

Return Value:

    HRESULT

Memory Allocation:

    No. 
*/
//////////////////////////////////////////////////////////////////////////////
XBOXAPI
HRESULT
WINAPI 
XOnlineVChatPacketSend(
       IN HANDLE                   hVChatMgr, 
	   IN OUT PVOID                pvNetworkPacketOut, 
	   IN BYTE                     bNetworkPacketOutSize
	   )
{
	return (S_OK);
}

//////////////////////////////////////////////////////////////////////////////
/*XOnlineVChatProcess - Routine Description:

    Engine of the voice chat. Should be called once in the game infinite loop. 

Arguments:
    hVChatMgr[in]             Handle to the voice chat manager.

Return Value:

    HRESULT

Memory Allocation:

    No. 
*/
//////////////////////////////////////////////////////////////////////////////
XBOXAPI
HRESULT
WINAPI 
XOnlineVChatProcess(
       IN HANDLE                   hVChatMgr
	  )
{
	return (S_OK);
}

//////////////////////////////////////////////////////////////////////////////
/*XOnlineVChatCleanup - Routine Description:

    Cleans up the resources associated with a communicator manager and disables 
	voice chat on the local machine. 

Arguments:
    hVChatMgr[in]             Handle to the voice chat manager.

Return Value:

    HRESULT

Memory Allocation:

    No. (Frees memory associated with the resources of the voice chat manager).
*/
//////////////////////////////////////////////////////////////////////////////
XBOXAPI
HRESULT
WINAPI 
XOnlineVChatCleanup(
       IN HANDLE                   hVChatMgr
	   )
{
	assert(NULL != hVChatMgr);

	delete ((XONVCHAT_MGR_HANDLE)hVChatMgr);

	return (S_OK);
}

//////////////////////////////////////////////////////////////////////////////
//
// Implementation of CHeadsetXMediaPacket 
//
//////////////////////////////////////////////////////////////////////////////
VOID CHeadsetXMediaPacket::Initialize(PBYTE pbBuffer , DWORD dwSize , DWORD dwStatus, HANDLE hWorkEvent) 
{
	m_XMediaPacket.dwMaxSize = dwSize;

	assert(NULL != pbBuffer);

    m_XMediaPacket.pvBuffer = pbBuffer;
    memset(m_XMediaPacket.pvBuffer , 0 , dwSize);

	//
    // Initialize all other members
    //
	m_dwStatus = dwStatus;
	m_dwCompletedSize = 0;
}

VOID CHeadsetXMediaPacket::Dump()
{
	DebugPrint( "CHeadsetXMediaPacket - Dump object 0x%x :m_XMediaPacket.pvBuffer = 0x%x m_dwStatus = %d m_dwCompletedSize = %d\n",
		               this, m_XMediaPacket.pvBuffer, m_dwStatus, m_dwCompletedSize );
}

//////////////////////////////////////////////////////////////////////////////
//
// Implementation of CHeadsetXMediaPacketQueue 
//
//////////////////////////////////////////////////////////////////////////////
HRESULT CHeadsetXMediaPacketQueue::CreateHeadsetQueue(DWORD dwXMPCount, DWORD dwSize, DWORD dwStatus, HANDLE hWorkEvent)
{
	HRESULT hr = S_OK;
     
	assert( 0 != dwXMPCount);
    assert( 0 < dwSize && 640 >= dwSize);

    do
    {
		m_dwSize = dwSize;
		m_dwXMPCount = dwXMPCount;

		m_pbBufferSpace = new BYTE[ m_dwXMPCount * m_dwSize];

		if( NULL == m_pbBufferSpace )
		{
			hr = E_OUTOFMEMORY;
			break;
		}    

		m_pXMPQueue = new CHeadsetXMediaPacket[m_dwXMPCount];

		if( NULL == m_pXMPQueue )
        {
			hr = E_OUTOFMEMORY;
			break;
        }

		for( DWORD i = 0; i < m_dwXMPCount ; i++)
        {
			m_pXMPQueue[i].Initialize( (m_pbBufferSpace + i * m_dwSize) ,m_dwSize, dwStatus, hWorkEvent);
        }
    }
    while( FALSE );
       
    return( hr );
}

LPXMEDIAPACKET CHeadsetXMediaPacketQueue::GetCurrentXMP()
{
	assert(m_dwCurrentIndex < m_dwXMPCount);

	LPXMEDIAPACKET pXMP = m_pXMPQueue[m_dwCurrentIndex].GetXMP();

	m_dwCurrentIndex = (m_dwCurrentIndex + 1) % m_dwXMPCount;

	return (pXMP);
}

VOID CHeadsetXMediaPacketQueue::Cleanup()
{
	if( NULL != m_pbBufferSpace )
    {
		delete [] m_pbBufferSpace;
		m_pbBufferSpace = NULL;
		DebugPrint("Deleted headset buffer space\n" );
    }

	if( NULL != m_pXMPQueue )
    {
		delete [] m_pXMPQueue;
		m_pXMPQueue = NULL;
		DebugPrint( "Deleted headset queue\n" );
    }

	m_dwXMPCount = 0;
	m_dwSize = 0;
	m_dwCurrentIndex = 0;

	DebugPrint( "Headset queue cleanup done!\n");
}

VOID CHeadsetXMediaPacketQueue::Dump()
{
	DebugPrint( "CHeadsetXMediaPacketQueue - Dump object 0x%x: m_dwXMPCount = %d m_dwSize = %d m_pXMPQueue = 0x%x m_pbBufferSpace = %x m_dwCurrentIndex = %d\n",
		              this, m_dwXMPCount, m_dwSize, m_pXMPQueue, m_pbBufferSpace, m_dwCurrentIndex );

	for( DWORD i = 0; i < m_dwXMPCount ; i++ )
    {
		m_pXMPQueue[i].Dump();
    }
}

VOID CHeadsetXMediaPacketQueue::Verify()
{
	if( (NULL != m_pbBufferSpace) && ((0 == m_dwXMPCount) || (0 == m_dwSize)) )
    {
		DebugPrint("Headset queue error!\n");
		assert(FALSE);
    }

	if( (NULL == m_pbBufferSpace) && (0 != m_dwXMPCount) )
    {
		DebugPrint("Headset queue error!\n");
		assert(FALSE);
    }

	DebugPrint( "Verify...OK!\n");

}

//////////////////////////////////////////////////////////////////////////////
//
// Implementation of CCommunicator 
//
//////////////////////////////////////////////////////////////////////////////

//-----------------------------------------------------------------------------
// Name: CCommunicator
// Desc: Constructor
//-----------------------------------------------------------------------------
CCommunicator::CCommunicator( ):
		m_bHeadsetPort(0),
        m_pMicrophone(NULL),
        m_pHeadphone(NULL),
        m_pEncoder(NULL),
		m_bChannel(0),
		m_bPlayerNo(0),
        m_bCommActive(FALSE)
        {           
        }

//-----------------------------------------------------------------------------
// Name: ~CCommunicator
// Desc: Destructor
//-----------------------------------------------------------------------------
CCommunicator::~CCommunicator()
{
    Cleanup();
}

//-----------------------------------------------------------------------------
// Name: Cleanup
// Desc: Called at destruction time or when the communicator is removed
//-----------------------------------------------------------------------------
VOID CCommunicator::Cleanup()
{
    if(m_pMicrophone)
    {
        m_pMicrophone->Release();
        m_pMicrophone = NULL;
    }    

    if(m_pHeadphone)
    {
        m_pHeadphone->Release();
        m_pHeadphone = NULL;
    }

    if(m_pEncoder)
    {
        m_pEncoder->Release();
        m_pEncoder = NULL;
    }

	DebugPrint( "Communicator 0x%x's cleanup done!\n", this);
}

//-----------------------------------------------------------------------------
// Name: Inserted
// Desc: Called when a communicator is newly detected in this slot, does all initializations
//-----------------------------------------------------------------------------
HRESULT CCommunicator::Inserted(
			LPCVChatParameters   pVChatParams,
			BYTE                 bHeadsetPort,
			HANDLE               hEvtMicInput
			)
{
    HRESULT         hr = S_OK;
    WAVEFORMATEX    wfxFormat;

	assert( (INVALID_HANDLE_VALUE != hEvtMicInput) && (NULL != hEvtMicInput));
	assert( NULL != pVChatParams );
	assert( (bHeadsetPort >= 0) && (bHeadsetPort < 4));

	m_bHeadsetPort = bHeadsetPort;

	//
    // Computes PCM buffer size from the current settings
    //
    WORD wVoiceBufferSize = pVChatParams->GetPCMBufferTime() * (((WORD)( pVChatParams->GetVoiceSamplingRate() / 1000.0 )) * 2 );
    
    DebugPrint( "CCommunicator::Inserted()...Xbox Communicator Inserted\n");

	do
	{

		//
		// The headset initialization
		//
		wfxFormat.wFormatTag = WAVE_FORMAT_PCM;
		wfxFormat.nChannels = 1;
		wfxFormat.nSamplesPerSec = pVChatParams->GetVoiceSamplingRate();
		wfxFormat.nAvgBytesPerSec = 2 * pVChatParams->GetVoiceSamplingRate();
		wfxFormat.nBlockAlign = 2;
		wfxFormat.wBitsPerSample = 16;
		wfxFormat.cbSize = 0;

		//
		//  Create a microphone and a headphone
		//
		DebugPrint( "CCommunicator::Inserted()...Creating microphone...\n");
		hr = XVoiceCreateMediaObject(XDEVICE_TYPE_VOICE_MICROPHONE, (DWORD)m_bHeadsetPort , PCM_BUFFERS_COUNT,
									 &wfxFormat, &m_pMicrophone);

		if( FAILED( hr ) )
		{
			DebugPrint( "CCommunicator::Inserted()...Microphone failed with %x", hr);
			break;
		}

		DebugPrint( "CCommunicator::Inserted()...Creating headphone...\n");
		hr = XVoiceCreateMediaObject(XDEVICE_TYPE_VOICE_HEADPHONE, (DWORD)m_bHeadsetPort , PCM_BUFFERS_COUNT,
									 &wfxFormat, &m_pHeadphone);

		if( FAILED( hr ) )
		{
			DebugPrint( "CCommunicator::Inserted()...Headphone failed with %x", hr);
			break;
		}

		DebugPrint( "CCommunicator::Inserted()...Creating voice encoder...\n");
		hr = XVoiceEncoderCreateMediaObject( FALSE, // manual mode
											 pVChatParams->GetCodecTag(),
											 &wfxFormat,
											 20, // voice activation threshold (0 - 255)
											 &m_pEncoder );

		if( FAILED( hr ) )
		{
			DebugPrint( "CCommunicator::Inserted()...Voice encoder failed with %x", hr);
			break;
		}

		//
		// Create the buffers for microphone
		//
		hr = m_MicrophoneQueue.CreateHeadsetQueue(PCM_BUFFERS_COUNT , 
			                                      wVoiceBufferSize, 
												  (DWORD)XMEDIAPACKET_STATUS_PENDING, 
												  hEvtMicInput);

		if( FAILED( hr ) )
		{
			DebugPrint( "CCommunicator::Inserted()...Create microphone queue failed with %x", hr);
			break;
		}


		//
		// Create the buffers for headphone
		//
		hr = m_HeadphoneQueue.CreateHeadsetQueue(PCM_BUFFERS_COUNT , 
			                                     wVoiceBufferSize, 
												 (DWORD)XMEDIAPACKET_STATUS_SUCCESS, 
												 NULL);

		if( FAILED( hr ) )
		{
			DebugPrint( "CCommunicator::Inserted()...Create headphone queue failed with %x", hr);
			break;
		}

		//
		// Feed the microphone with buffers; we enqueue all the buffers to the microphone which is going to fill 
		// them with data gradually
		//
		for( DWORD i = 0 ; i < PCM_BUFFERS_COUNT ; i++ )
		{
			LPXMEDIAPACKET pXMP = m_MicrophoneQueue.GetCurrentXMP();

			//
			//  Submit the buffer
			//
			hr = m_pMicrophone->Process(NULL, pXMP);

			assert(SUCCEEDED(hr));
		}

		//
		// We don't enqueue buffers to the headphone yet; this is going to be done when buffers from the microphone
		// start to arrive
		//

		//
        // Set the communicator active status to TRUE
        //
		m_bCommActive = TRUE;
	}
	while(FALSE);

    return (hr);
}

//-----------------------------------------------------------------------------
// Name: Removed
// Desc: Called when the communicator is unplugged
//-----------------------------------------------------------------------------
VOID CCommunicator::Removed()
{
    Cleanup();

	m_MicrophoneQueue.Cleanup();
	m_HeadphoneQueue.Cleanup();

	m_bChannel = 0;
	m_bPlayerNo = 0;
    m_bCommActive = FALSE;

    DebugPrint("Communicator removed!\n");
}


//-----------------------------------------------------------------------------
// Name: EncodeXMP 
// Desc: Compresses a PCM buffer and returns the encoded buffer and a status on voice detected
//-----------------------------------------------------------------------------
HRESULT CCommunicator::EncodeXMP(LPXMEDIAPACKET pSrcXMP, LPXMEDIAPACKET pDstXMP , BOOL *pvbVoiceDetected)
{
    HRESULT hr;
    DWORD dwSizeDst = 0; 

    memset(pDstXMP->pvBuffer, 0 , pDstXMP->dwMaxSize);

    pDstXMP->pdwCompletedSize = &dwSizeDst;
    pDstXMP->hCompletionEvent = NULL;

    //
    // Call encoding xmo - it's synchronous
    //
    hr = m_pEncoder->Process( pSrcXMP , pDstXMP);

    assert(SUCCEEDED(hr));
    
    /*
	
	  VAD & stuff

	if( dwSizeDst < m_wCodecBufferSize )
    {
        *pvbVoiceDetected = FALSE;
    }
    else
    {
        *pvbVoiceDetected = TRUE;
    }
	
	*/

    pDstXMP->pdwCompletedSize = NULL;

    return( hr );
}

LPXMEDIAPACKET CCommunicator::GetMicrophoneOutput()
{
	if( NULL != m_pMicrophone )
    {
		LPXMEDIAPACKET pXMP = m_MicrophoneQueue.GetCurrentXMP();

		if( XMEDIAPACKET_STATUS_PENDING != *(pXMP->pdwStatus) )
		{
			return (pXMP);
		}
    }
	
	return (NULL);
}

VOID CCommunicator::EnqueueMicrophoneBuffer(LPXMEDIAPACKET pMicrophoneXMP)
{
	assert(NULL != pMicrophoneXMP);

	//
    // Requeue microphone packet - submit the buffer
    //
	HRESULT hr = m_pMicrophone->Process(NULL, pMicrophoneXMP);

	assert(SUCCEEDED(hr));
}

VOID CCommunicator::EnqueueHeadphoneBuffer(LPXMEDIAPACKET pHeadphoneXMP)
{
	assert(NULL != pHeadphoneXMP);

	//
    // Requeue headphone packet - submit the buffer
    //
	HRESULT hr = m_pHeadphone->Process(NULL, pHeadphoneXMP);

	assert(SUCCEEDED(hr));
}

//////////////////////////////////////////////////////////////////////////////
//
// Implementation of CCommunicatorMgr that tracks multiple Xbox Communicators
//
//////////////////////////////////////////////////////////////////////////////

//-----------------------------------------------------------------------------
// Name: CCommunicatorMgr
// Desc: Constructor
//-----------------------------------------------------------------------------
CCommunicatorMgr::CCommunicatorMgr() : m_hMicrophoneWorkEvent(NULL),
                                       m_hNetworkPacketReadyEvent(NULL),
                                       m_pbNetworkPacket(NULL),
									   m_dwNetworkPacketSize(0),
									   m_dwNetworkPacketIndex(0)
{
	for( BYTE i = 0 ; i < COMMUNICATOR_COUNT ; i++)
    {
		m_bEncodePriorityArray[i] = i;
    }		

	m_CodecMediaBuffer.pvBuffer = NULL;
}

//-----------------------------------------------------------------------------
// Name: ~CCommunicatorMgr
// Desc: Destructor
//-----------------------------------------------------------------------------
CCommunicatorMgr::~CCommunicatorMgr()
{
    //
    // The microphone event is for internal use - close handle
    //
	if (m_hMicrophoneWorkEvent) 
    {
        CloseHandle(m_hMicrophoneWorkEvent);
    }

	//
    // m_hNetworkPacketReadyEvent is provided by the client, don't close the handle
    //

	//
    // Delete the network packet allocated by the mgr
    //
	if( NULL != m_pbNetworkPacket )
    {
		delete [] m_pbNetworkPacket;
    }

	//
    // The codec buffer is actually a pointer in the network buffer - don't delete
    //

}

//-----------------------------------------------------------------------------
// Name: Initialize
// Desc: Called when the voice chat is initiated on this xbox
//-----------------------------------------------------------------------------
HRESULT CCommunicatorMgr::Initialize(LPVOICE_CHAT_CONFIG pVoiceChatConfig)
{

    HRESULT hr = S_OK;

	assert(NULL != pVoiceChatConfig);

	
	//
    // Initialize the config structure
    //
	m_VoiceParams.Initialize(pVoiceChatConfig);
	
	do
	{
		//
		// Create the work event for the voice units
		//
		m_hMicrophoneWorkEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
		if( NULL ==  m_hMicrophoneWorkEvent)
		{
			hr = E_FAIL;
			break;
		}

		//
		// Verify the initial state of the voice devices
		//
		hr = CheckInitialState();

		if( FAILED( hr ) )
        {
			break;
        }

		//
        // Allocate buffer for outgoing network packet
        //
		m_dwNetworkPacketSize = CODEC_BUFFER_SIZE * m_VoiceParams.GetMaxEncoders();
		DWORD dwRows = m_VoiceParams.GetSendBufferingTime() / m_VoiceParams.GetPCMBufferTime();
		if( 0 != m_VoiceParams.GetSendBufferingTime() % m_VoiceParams.GetPCMBufferTime() )
        {
			dwRows++;
        }
		m_dwNetworkPacketSize *= dwRows;
		
		m_pbNetworkPacket = new BYTE[m_dwNetworkPacketSize];
		if( NULL == m_pbNetworkPacket )
        {
			hr = E_FAIL;
			break;
        }

	}
	while(FALSE);

	return( hr );
        
}

//-----------------------------------------------------------------------------
// Name: ProcessMicrophones
// Desc: Called in each Process() to check if there is some work TBD for microphones
//-----------------------------------------------------------------------------
HRESULT CCommunicatorMgr::ProcessMicrophones()
{
	HRESULT hr = S_OK;
    BOOL bVoiceDetected = TRUE;
	LPXMEDIAPACKET pMicrophoneXMP = NULL;
	DWORD dwEncodeOps = 0;
    
	
	for( DWORD i = 0 ; (i < COMMUNICATOR_COUNT) && (dwEncodeOps < m_VoiceParams.GetMaxEncoders()) ; i++ )
    {
		//
        // Get the microphone output from 
        //
		pMicrophoneXMP = m_CommArray[m_bEncodePriorityArray[i]].GetMicrophoneOutput();

		if( NULL != pMicrophoneXMP )
        {
            if( SUCCEEDED( *(pMicrophoneXMP->pdwStatus) ) )
			{
				//
                // Assign space in the network buffer for encoding
                //
				m_CodecMediaBuffer.pvBuffer = m_pbNetworkPacket + m_dwNetworkPacketIndex;

				//
                // Update index in the network packet
                //
                m_dwNetworkPacketIndex += CODEC_BUFFER_SIZE;
				
				//
                // Encode PCM data
                //
                hr = m_CommArray[m_bEncodePriorityArray[i]].EncodeXMP(pMicrophoneXMP, &m_CodecMediaBuffer , &bVoiceDetected);

				//
                // If ok, change the priorities for future
                //
				if( SUCCEEDED( hr ) )
                {
				    BYTE bTemp = m_bEncodePriorityArray[dwEncodeOps];
                    m_bEncodePriorityArray[dwEncodeOps] = m_bEncodePriorityArray[i];
                    m_bEncodePriorityArray[i] = bTemp;
                }
				else
				{
					//
                    // Reassign space in the network buffer
                    //
                    m_dwNetworkPacketIndex -= CODEC_BUFFER_SIZE;
				}

				//
                // If network packet is overflown, write from the beginning
                //
				if( m_dwNetworkPacketIndex >= m_dwNetworkPacketSize)
                {
					m_dwNetworkPacketIndex = 0;
                }

				//
                // Count the encoding operation so that we stay in a certain CPU limit
                //
				dwEncodeOps++;

            } // end if

			//
            // Put the packet back in row to be processed by the microphone
            //
			m_CommArray[m_bEncodePriorityArray[i]].EnqueueMicrophoneBuffer(pMicrophoneXMP);
        }
    }

    return (hr);
}

/*
//-----------------------------------------------------------------------------
// Name: Process 
// Desc: The engine of the whole voice chat, called in the main infinite loop
//-----------------------------------------------------------------------------
HRESULT CCommunicatorMgr::Process(MsgVoicePort *msgCommunicatorStatus)
{
    BYTE i;
    HRESULT hr;

	assert(NULL != msgCommunicatorStatus);

    DWORD dwReason = WaitForSingleObject(m_hCommunicatorWorkEvent ,  0);


    //
    // One of the voice units has microphone input
    //
    if( WAIT_OBJECT_0 == dwReason )
    {
		for( i = 0 ; i <  COMMUNICATOR_COUNT ; i++ )
        {
			hr = m_pVoiceUnits[i]->OnMicrophoneInput();
		    if(FAILED(hr))
			{
                DebugPrint("CCommunicatorMgr::Process()...Error OnMicrophoneInput = %d\n" , hr);
			    return (hr);
			}
        }
	    
    }
			
	//
    // Check for output data even if no microphone input(read the network for example)
    //
	for( i = 0 ; i <  COMMUNICATOR_COUNT ; i++ )
    {
		m_pVoiceUnits[i]->CheckForOutputData();
    }
	
    //
    //  Always check for hot-plugs
    //
    return ( CheckForHotPlugs(msgCommunicatorStatus) );

}
*/

//-----------------------------------------------------------------------------
// Name: CheckInitialState
// Desc: Get the initial state of the devices plugged in, called in Initialize()
//-----------------------------------------------------------------------------
HRESULT CCommunicatorMgr::CheckInitialState()
{
    DWORD dwConnectedMicrophones;
    DWORD dwConnectedHeadphones;
    
    HRESULT hr = S_OK;
    
	do
	{
		//
		//  Get the initial connected state of the devices
		//
		dwConnectedMicrophones = XGetDevices(XDEVICE_TYPE_VOICE_MICROPHONE);
		dwConnectedHeadphones = XGetDevices(XDEVICE_TYPE_VOICE_HEADPHONE);

		if( dwConnectedMicrophones != dwConnectedHeadphones)
		{
			DebugPrint( "CCommunicatorMgr::CheckInitialState()...dwConnectedMicrophones != dwConnectedHeadphone\n");
			hr = E_FAIL;
			break;
		}

		if((0 == dwConnectedMicrophones) || (0 == dwConnectedHeadphones))
		{
			DebugPrint( "CCommunicatorMgr::CheckInitialState()... No Xbox Communicator found!\n");
			hr = E_FAIL;
			break;
		}

		for(BYTE i = 0 ; i < COMMUNICATOR_COUNT ; i++ )
		{
			if(dwConnectedMicrophones&(1<<i))
			{
				if(!SUCCEEDED(m_CommArray[i].Inserted(&m_VoiceParams, i, m_hMicrophoneWorkEvent)))
				{
					DebugPrint( "CCommunicatorMgr::CheckInitialState()...Voice unit initialization failed!\n");
					hr = E_FAIL;
					break;
				}
				else
				{
					DebugPrint( "CCommunicatorMgr::CheckInitialState()...Voice unit %d initialized.\n" , i);
				}
			}
		}
	}
	while(FALSE);
    
    return( hr );
}


//-----------------------------------------------------------------------------
// Name: CheckForHotPlugs
// Desc: Called in Process to check if new inserts/removes occured
//-----------------------------------------------------------------------------
HRESULT CCommunicatorMgr::CheckForHotPlugs()
{
    DWORD dwMicrophoneInsertions, dwHeadphoneInsertions;
    DWORD dwMicrophoneRemovals, dwHeadphoneRemovals;

    HRESULT hr = S_OK;

    do
	{
		if(XGetDeviceChanges(XDEVICE_TYPE_VOICE_MICROPHONE, &dwMicrophoneInsertions, &dwMicrophoneRemovals))
		{
			if(!XGetDeviceChanges(XDEVICE_TYPE_VOICE_HEADPHONE, &dwHeadphoneInsertions, &dwHeadphoneRemovals))
			{
				DebugPrint("CCommunicatorMgr::CheckForHotPlugs()...GetDeviceChanges does not match\n");
				hr = E_FAIL;
				break;
			}

			if( (dwMicrophoneInsertions != dwHeadphoneInsertions) ||
				(dwMicrophoneRemovals != dwHeadphoneRemovals))
			{
				DebugPrint("CCommunicatorMgr::CheckForHotPlugs()...GetDeviceChanges does not match, different\n");
				hr = E_FAIL;
				break;
			}

			//
			//  Loop over all the ports
			//
			for(BYTE i = 0 ; i < COMMUNICATOR_COUNT ; i++ )
			{
				//
				//  Handle Removal, if there is one.
				//
				if(dwMicrophoneRemovals&(1<<i))
				{
					m_CommArray[i].Removed();

					if( FAILED( hr ) )
					{
						break;
					}

				}

				//
				//  Handle Insertion, if there is one.
				//
				if(dwMicrophoneInsertions&(1<<i))
				{
					hr = m_CommArray[i].Inserted(&m_VoiceParams, i, m_hMicrophoneWorkEvent);

					if( FAILED( hr ) )
					{
						break;
					}
					
				}
			} //end of loop over ports

		}  //end of check for getting device changes
	}
	while(FALSE);
	
    return (hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\xvchat\XVoiceChatp.h ===
//-----------------------------------------------------------------------------
// File: XVoiceChatp.h
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef XVCHATP_H_INCLUDED
#define XVCHATP_H_INCLUDED

#include "queuexmop.h"

const BYTE   COMMUNICATOR_COUNT       = 4;
const BYTE   PCM_BUFFERS_COUNT        = 2;
const BYTE   MAX_PLAYERS              = 16;
const WORD   MAX_PCM_BUFFER           = 100;
const WORD   MIN_PCM_BUFFER           = 20;
const DWORD  MAX_BUFFERING_TIME       = 1000;

const WORD   CODEC_TAG                = WAVE_FORMAT_VOXWARE_SC03;
const WORD   VOICE_SAMPLING_RATE      = 8000;
const WORD   CODEC_SAMPLING_RATE      = 8000;
const WORD   PCM_TIME                 = 20;
const WORD   MAX_CHANNELS             = 2;
const WORD   MAX_ENCODERS             = 2;
const WORD   MAX_DECODERS_PER_CHANNEL = 2;    
const WORD   SEND_BUFFERING_TIME      = 100;
const WORD   RECV_BUFFERING_TIME      = 200;

const DWORD  CODEC_BUFFER_SIZE        = 20; // change this! - codec header should include player no

const BYTE   OUTSIDE_PLAYER           = 0xFF;

//----------------------------------------------------------------------------
//
// Classes
//
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
//
// Class CVChatParameters - configuration class for voice chat
//
//----------------------------------------------------------------------------
class CVChatParameters
{

public:

	CVChatParameters() : m_wPCMBufferTime(PCM_TIME),
						 m_wCodecTag(WAVE_FORMAT_VOXWARE_SC03),
		                 m_wVoiceSamplingRate(VOICE_SAMPLING_RATE)
	{
		memset(&m_publicVChatConfig , 0 , sizeof(VOICE_CHAT_CONFIG));
	}

	VOID Initialize(LPVOICE_CHAT_CONFIG pVoiceChatConfig)
	{
		assert(NULL != pVoiceChatConfig);

		assert(pVoiceChatConfig->wMaxEncoders <= COMMUNICATOR_COUNT);
		assert(pVoiceChatConfig->wMaxChannels <= COMMUNICATOR_COUNT);
		assert(pVoiceChatConfig->wMaxDecodersPerChannel < MAX_PLAYERS);
		assert(pVoiceChatConfig->wSendBufferingTime <= MAX_BUFFERING_TIME);
		assert(pVoiceChatConfig->wRecvBufferingTime <= MAX_BUFFERING_TIME);

        m_publicVChatConfig.wMaxEncoders = (0 == pVoiceChatConfig->wMaxEncoders)?MAX_ENCODERS:(pVoiceChatConfig->wMaxEncoders);
		m_publicVChatConfig.wMaxChannels = (0 == pVoiceChatConfig->wMaxChannels)?MAX_CHANNELS:(pVoiceChatConfig->wMaxChannels);
		m_publicVChatConfig.wMaxDecodersPerChannel = (0 == pVoiceChatConfig->wMaxDecodersPerChannel)?MAX_DECODERS_PER_CHANNEL:(pVoiceChatConfig->wMaxDecodersPerChannel);
		m_publicVChatConfig.wSendBufferingTime = (0 == pVoiceChatConfig->wSendBufferingTime)?SEND_BUFFERING_TIME:(pVoiceChatConfig->wSendBufferingTime);
		m_publicVChatConfig.wRecvBufferingTime = (0 == pVoiceChatConfig->wRecvBufferingTime)?RECV_BUFFERING_TIME:(pVoiceChatConfig->wRecvBufferingTime);

	}

	WORD GetVoiceSamplingRate()
	{
		return (m_wVoiceSamplingRate);
	}

	WORD GetCodecTag()
	{
		return (m_wCodecTag);
	}

	WORD GetPCMBufferTime()
	{
		return (m_wPCMBufferTime);
	}

	WORD GetMaxEncoders()
	{
		return (m_publicVChatConfig.wMaxEncoders);
	}

	WORD GetMaxChannels()
	{
		return (m_publicVChatConfig.wMaxChannels);
	}

	WORD GetMaxDecodersPerChannel()
	{
        return (m_publicVChatConfig.wMaxDecodersPerChannel);
	}

	WORD GetSendBufferingTime()
	{
		return (m_publicVChatConfig.wSendBufferingTime);
	}

	WORD GetRecvBufferingTime()
	{
		return (m_publicVChatConfig.wRecvBufferingTime);
	}

private:
	//
    // Configurable part by the client through the API
    //
    VOICE_CHAT_CONFIG     m_publicVChatConfig;

	//
    // Non-configurable part by the client
    //
    WORD                  m_wPCMBufferTime;
	WORD                  m_wCodecTag;
	WORD                  m_wVoiceSamplingRate;

};

typedef CVChatParameters *LPCVChatParameters;


//----------------------------------------------------------------------------
//
// Class CHeadsetXMediaPacket - XMediaPacket wrapper
//
//----------------------------------------------------------------------------
class CHeadsetXMediaPacket

{

public:
	CHeadsetXMediaPacket() : m_dwStatus(0),
                             m_dwCompletedSize(0)
	{
		m_XMediaPacket.pvBuffer = NULL;
		m_XMediaPacket.pdwStatus = &m_dwStatus;
		m_XMediaPacket.pdwCompletedSize = &m_dwCompletedSize;
		m_XMediaPacket.prtTimestamp = NULL;
		m_XMediaPacket.hCompletionEvent = NULL;
	}

	VOID Initialize(PBYTE pbBuffer , DWORD dwSize , DWORD dwStatus, HANDLE hWorkEvent); 

	LPXMEDIAPACKET GetXMP()
	{
		return (&m_XMediaPacket);
	}

	VOID Dump();

private:

	XMEDIAPACKET        m_XMediaPacket;
    DWORD               m_dwStatus;
    DWORD               m_dwCompletedSize;


};

typedef CHeadsetXMediaPacket *LPCHeadsetXMediaPacket;

//----------------------------------------------------------------------------
//
// Class CHeadsetXMediaQueue - the XMP queues for microphone/headphone
//
//----------------------------------------------------------------------------
class CHeadsetXMediaPacketQueue
{

public:

	CHeadsetXMediaPacketQueue() : m_dwXMPCount(0),
		                          m_dwSize(0),
		                          m_pXMPQueue(NULL),
		                          m_pbBufferSpace(NULL),
								  m_dwCurrentIndex(0)
	{
	}

    ~CHeadsetXMediaPacketQueue()
	{
		Cleanup();
	}

	HRESULT CreateHeadsetQueue(DWORD dwHMPCount , DWORD dwSize, DWORD dwStatus, HANDLE hWorkEvent);

	LPXMEDIAPACKET GetCurrentXMP();

	VOID Cleanup();

	VOID Dump();

	VOID Verify();


private:

	DWORD                    m_dwXMPCount;
	DWORD                    m_dwSize;

	LPCHeadsetXMediaPacket   m_pXMPQueue;
	PBYTE                    m_pbBufferSpace;

	DWORD                    m_dwCurrentIndex;

};

typedef CHeadsetXMediaPacketQueue *LPCHeadsetXMediaPacketQueue;

//----------------------------------------------------------------------------
//
// Class CComunicator - implements the functionalities associated with 
//                      an Xbox Communicator
//
//----------------------------------------------------------------------------
class CCommunicator
{
public:
    //
    // Constructor / destructor
    //
    CCommunicator();
    ~CCommunicator();

    //
    // Insert/Remove
    //
    HRESULT Inserted(
		        LPCVChatParameters pVChatParams,
		        BYTE  bHeadsetPort,
		        HANDLE hEvtMicInput
				);

    VOID Removed();

	//
    // Status function
    //
	BOOL IsCommunicatorActive()
	{
		return (m_bCommActive);
	}

	BYTE GetPlayerNo()
	{
		return (m_bPlayerNo);
	}

	LPXMEDIAPACKET GetMicrophoneOutput();


    HRESULT EncodeXMP(LPXMEDIAPACKET pSrcXMP, LPXMEDIAPACKET pDstXMP , BOOL *pvbVoiceDetected );
	VOID EnqueueMicrophoneBuffer(LPXMEDIAPACKET pMicrophoneXMP);
	VOID EnqueueHeadphoneBuffer(LPXMEDIAPACKET pHeadphoneXMP);

private:    

    VOID Cleanup();

private:

    //
    // XMO objects created on call to Inserted()
    //
    XMediaObject                *m_pMicrophone;
    XMediaObject                *m_pHeadphone;
    XMediaObject                *m_pEncoder;

    //
    // Port number for headset - 0 , 1 , 2 , 3
    //
    BYTE                        m_bHeadsetPort; 
	BYTE                        m_bChannel;
	BYTE                        m_bPlayerNo;

	//
    // Status in chat
    //
	BOOL                        m_bCommActive;

    //
    // The 2 queues for the buffers that are sent to the microphone/headphone
    //
    CHeadsetXMediaPacketQueue   m_MicrophoneQueue;
    CHeadsetXMediaPacketQueue   m_HeadphoneQueue;

};

//----------------------------------------------------------------------------
//
// Class CCommunicatorMgr ; manages the array of CCommunicators on an XBOX
//
//----------------------------------------------------------------------------
class CCommunicatorMgr
{
public:
    CCommunicatorMgr();
    ~CCommunicatorMgr();

    
    HRESULT Initialize(LPVOICE_CHAT_CONFIG pVoiceChatConfig);

private:
    //
    // Check status for the voice units
    //
    HRESULT CheckForHotPlugs();
    HRESULT CheckInitialState();

	//
    // Encoding & decoding processing
    //
	HRESULT ProcessMicrophones();
	

private:
	//
    // Configuration structure
    //
	CVChatParameters    m_VoiceParams;

    //
    // The array of voice units
    //
    CCommunicator       m_CommArray[COMMUNICATOR_COUNT];

    //
    // Event for microphone
    //
    HANDLE              m_hMicrophoneWorkEvent;

	//
    // Event for network packet ready
    //
	HANDLE              m_hNetworkPacketReadyEvent;

	//
    // Network packet
    //
	PBYTE               m_pbNetworkPacket;
	DWORD               m_dwNetworkPacketSize;
	DWORD               m_dwNetworkPacketIndex;

	//
    // Priority list for encoding
    //
	BYTE                m_bEncodePriorityArray[COMMUNICATOR_COUNT];

	//
    // Working buffer for codec
    //
	XMEDIAPACKET        m_CodecMediaBuffer;

};

typedef CCommunicatorMgr *XONVCHAT_MGR_HANDLE;

#endif  // XVCHATP_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\online\xodash\XODashUpdate\XODash.cpp ===
//-----------------------------------------------------------------------------
// File: XODash.cpp
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------


#include "std.h"

#include "XODash.h"

#include "utilities.h"
#include "XOConst.h"
#include "Materiallibrary.h"
#include "globals.h"
#include "DSoundManager.h"
#include "ntiosvc.h"
#include "Translator.h"

#include "keys.cpp"

CNtIoctlCdromService g_cdrom;
int g_nDiscType = eDiscNone;
int GetDiscType();
// CInputHandle g_szUserInput;
//-----------------------------------------------------------------------------
// Global access to common members
//-----------------------------------------------------------------------------
XOApplication*    g_pXBApp     = NULL;
LPDIRECT3DDEVICE8  g_pd3dDevice = NULL;
CMaterialLibrary   g_MaterialLib;

float* g_fAppTime = 0;
TCHAR* g_szAppDir = MEDIA_PATH; // _T("d:\\media\\");

//
// Global task handle for update task
//
XONLINETASK_HANDLE	g_hTask = NULL;
XONLINETASK_HANDLE	g_hLogon = NULL;

//
// Autoupdate service
//
#define NUM_SERVICES	1
DWORD			g_rgServices[NUM_SERVICES] =
{
	XONLINE_AUTO_UPDATE_SERVICE
};



//-----------------------------------------------------------------------------
// Name: XOApplication()
// Desc: Constructor
//-----------------------------------------------------------------------------
XOApplication::XOApplication()
{
    // Initialize member variables
    g_pXBApp          = this;

    // Direct3D variables
    m_pD3D            = NULL;
    m_pd3dDevice      = NULL;
    m_pDepthBuffer    = NULL;
    m_pBackBuffer     = NULL;

    // Variables to perform app timing
    m_fTime           = 0.0f;
    m_fStartTime      = 0.0f;
    m_fElapsedTime    = 0.0f;
	m_fSecsPerTick    = 0.0f;

    // Set up the presentation parameters for a double-bufferd, 640x480,
    // 32-bit display using depth-stencil. Override these parameters in
    // your derived class as your app requires.
    ZeroMemory( &m_d3dpp, sizeof(m_d3dpp) );
    m_d3dpp.BackBufferWidth        = 640;
    m_d3dpp.BackBufferHeight       = 480;
    m_d3dpp.BackBufferFormat       = D3DFMT_A8R8G8B8;
    m_d3dpp.BackBufferCount        = 1;
    m_d3dpp.EnableAutoDepthStencil = TRUE;
    m_d3dpp.AutoDepthStencilFormat = D3DFMT_D24S8;
    m_d3dpp.SwapEffect             = D3DSWAPEFFECT_DISCARD;
	m_d3dpp.FullScreen_RefreshRateInHz      = D3DPRESENT_RATE_DEFAULT;
	m_d3dpp.FullScreen_PresentationInterval = D3DPRESENT_INTERVAL_ONE;
    m_d3dpp.MultiSampleType        = D3DMULTISAMPLE_4_SAMPLES_SUPERSAMPLE_GAUSSIAN;

    // Specify number and type of input devices this app will be using. By
    // default, you can use 0 and NULL, which triggers XInputDevices() to
    // prealloc the default number and types of devices. To use chat or
    // other devices, override these variables in your derived class.
    m_dwNumInputDeviceTypes = 0;
    m_InputDeviceTypes      = NULL;
	g_fAppTime = &m_fTime;
    _tcscpy( m_szAppDir,g_szAppDir);
}




//-----------------------------------------------------------------------------
// Name: Create()
// Desc: Create the app
//-----------------------------------------------------------------------------
HRESULT XOApplication::Create()
{
    HRESULT hr;
	XONLINE_STARTUP_PARAMS	xosp = { 0 };

    float zero = 0.0f;
	float one = 1.0f;


    // Create the Direct3D object
    DbgPrint( "XBApp: Creating Direct3D...\n" );
    if( NULL == ( m_pD3D = Direct3DCreate8(D3D_SDK_VERSION) ) )
    {
        DbgPrint( "XBApp: Unable to create Direct3D!\n");
        return E_FAIL;
    }

    // Create the device
    DbgPrint( "XBApp: Creating the D3D device...\n");
    if( FAILED( hr = m_pD3D->CreateDevice( 0, D3DDEVTYPE_HAL, NULL, 
                                           D3DCREATE_HARDWARE_VERTEXPROCESSING, 
                                           &m_d3dpp, &m_pd3dDevice ) ) )
    {
        DbgPrint( "XBApp: Could not create D3D device!\n");
        return hr;
    }

    // Allow global access to the device
    g_pd3dDevice = m_pd3dDevice;

    // Store pointers to the depth and back buffers
    m_pd3dDevice->GetDepthStencilSurface( &m_pDepthBuffer );
    m_pd3dDevice->GetBackBuffer( 0, 0, &m_pBackBuffer );

    // Initialize core peripheral port support. Note: If these parameters
    // are 0 and NULL, respectively, then the default number and types of 
    // controllers will be initialized.
    XInitDevices( m_dwNumInputDeviceTypes, m_InputDeviceTypes );

    // Create the gamepad devices
    DbgPrint( "XBApp: Creating gamepad devices...\n");
    if( FAILED( hr = XBInput_CreateGamepads( &m_Gamepad ) ) )
    {
        DbgPrint( "XBApp: Call to CreateGamepads() failed!\n" );
        return hr;
    }

    // Initialize the app's device-dependent objects
    DbgPrint("XBApp: Initializing the app...\n");
    if( FAILED( hr = Initialize() ) )
    {
        DbgPrint("XBApp: Call to Initialize() failed!\n" );
        return hr;
    }

	
	LARGE_INTEGER qwTicksPerSec;
	QueryPerformanceFrequency( &qwTicksPerSec );
	m_fSecsPerTick = 1.0f / (FLOAT)qwTicksPerSec.QuadPart;


    g_pd3dDevice->SetRenderState(D3DRS_FILLMODE, D3DFILL_SOLID);
	g_pd3dDevice->SetRenderState(D3DRS_SHADEMODE, D3DSHADE_GOURAUD);
	g_pd3dDevice->SetRenderState(D3DRS_ZWRITEENABLE, TRUE);
	g_pd3dDevice->SetRenderState(D3DRS_ALPHATESTENABLE, FALSE);
	g_pd3dDevice->SetRenderState(D3DRS_SRCBLEND, D3DBLEND_ONE);
	g_pd3dDevice->SetRenderState(D3DRS_DESTBLEND, D3DBLEND_ZERO);
	g_pd3dDevice->SetRenderState(D3DRS_CULLMODE, D3DCULL_CCW);
	g_pd3dDevice->SetRenderState(D3DRS_ZFUNC, D3DCMP_LESSEQUAL);
	g_pd3dDevice->SetRenderState(D3DRS_ALPHAREF, 0);
	g_pd3dDevice->SetRenderState(D3DRS_ALPHAFUNC, D3DCMP_ALWAYS);
	g_pd3dDevice->SetRenderState(D3DRS_DITHERENABLE, TRUE);
	g_pd3dDevice->SetRenderState(D3DRS_ALPHABLENDENABLE, TRUE);
	g_pd3dDevice->SetRenderState(D3DRS_FOGENABLE, FALSE);
	g_pd3dDevice->SetRenderState(D3DRS_SPECULARENABLE, FALSE);
	g_pd3dDevice->SetRenderState(D3DRS_FOGCOLOR, 0);
	g_pd3dDevice->SetRenderState(D3DRS_FOGTABLEMODE, D3DFOG_NONE);
	g_pd3dDevice->SetRenderState(D3DRS_FOGDENSITY, *(LPDWORD)&one);
	g_pd3dDevice->SetRenderState(D3DRS_EDGEANTIALIAS, FALSE);
	g_pd3dDevice->SetRenderState(D3DRS_ZBIAS, 0);
	g_pd3dDevice->SetRenderState(D3DRS_RANGEFOGENABLE, FALSE);
	g_pd3dDevice->SetRenderState(D3DRS_STENCILENABLE, FALSE);
	g_pd3dDevice->SetRenderState(D3DRS_STENCILFAIL, D3DSTENCILOP_KEEP);
	g_pd3dDevice->SetRenderState(D3DRS_STENCILZFAIL, D3DSTENCILOP_KEEP);
	g_pd3dDevice->SetRenderState(D3DRS_STENCILPASS, D3DSTENCILOP_KEEP);
	g_pd3dDevice->SetRenderState(D3DRS_STENCILFUNC, D3DCMP_ALWAYS);
	g_pd3dDevice->SetRenderState(D3DRS_STENCILREF, 0);
	g_pd3dDevice->SetRenderState(D3DRS_STENCILMASK, 0xffffffff);
	g_pd3dDevice->SetRenderState(D3DRS_STENCILWRITEMASK, 0xffffffff);
	g_pd3dDevice->SetRenderState(D3DRS_WRAP0, 0);
	g_pd3dDevice->SetRenderState(D3DRS_WRAP1, 0);
	g_pd3dDevice->SetRenderState(D3DRS_WRAP2, 0);
	g_pd3dDevice->SetRenderState(D3DRS_WRAP3, 0);
	g_pd3dDevice->SetRenderState(D3DRS_LIGHTING, TRUE);
	g_pd3dDevice->SetRenderState(D3DRS_AMBIENT, 0);
	g_pd3dDevice->SetRenderState(D3DRS_COLORVERTEX, TRUE);
	g_pd3dDevice->SetRenderState(D3DRS_LOCALVIEWER, TRUE);
	g_pd3dDevice->SetRenderState(D3DRS_NORMALIZENORMALS, FALSE);
	g_pd3dDevice->SetRenderState(D3DRS_DIFFUSEMATERIALSOURCE, D3DMCS_COLOR1);
	g_pd3dDevice->SetRenderState(D3DRS_SPECULARMATERIALSOURCE, D3DMCS_COLOR2);
	g_pd3dDevice->SetRenderState(D3DRS_AMBIENTMATERIALSOURCE, D3DMCS_COLOR2);
	g_pd3dDevice->SetRenderState(D3DRS_EMISSIVEMATERIALSOURCE, D3DMCS_MATERIAL);
	g_pd3dDevice->SetRenderState(D3DRS_VERTEXBLEND, D3DVBF_DISABLE);
	g_pd3dDevice->SetRenderState(D3DRS_POINTSIZE, *(LPDWORD)&one);
	g_pd3dDevice->SetRenderState(D3DRS_POINTSIZE_MIN, *(LPDWORD)&one);
	g_pd3dDevice->SetRenderState(D3DRS_POINTSPRITEENABLE, FALSE);
	g_pd3dDevice->SetRenderState(D3DRS_POINTSCALEENABLE, FALSE);
	g_pd3dDevice->SetRenderState(D3DRS_POINTSCALE_A, *(LPDWORD)&one);
	g_pd3dDevice->SetRenderState(D3DRS_POINTSCALE_B, *(LPDWORD)&zero);
	g_pd3dDevice->SetRenderState(D3DRS_POINTSCALE_C, *(LPDWORD)&zero);
	g_pd3dDevice->SetRenderState(D3DRS_MULTISAMPLEANTIALIAS, TRUE);
	g_pd3dDevice->SetRenderState(D3DRS_MULTISAMPLEMASK, 0xffffffff);
	g_pd3dDevice->SetRenderState(D3DRS_COLORWRITEENABLE, D3DCOLORWRITEENABLE_RED | D3DCOLORWRITEENABLE_GREEN | D3DCOLORWRITEENABLE_BLUE | D3DCOLORWRITEENABLE_ALPHA);

    OutputDebugStringA("Calling XOnlineStartup...\n");
    hr = XOnlineStartup(&xosp);
    if (FAILED(hr))
    {
        OutputDebugStringA("Error in XOnlineStartup\n");
    }


    return hr;
}




//-----------------------------------------------------------------------------
// Name: Destroy()
// Desc: Cleanup objects
//-----------------------------------------------------------------------------
VOID XOApplication::Destroy()
{
    // Perform app-specific cleanup
    Cleanup();

    // Release display objects
    SAFE_RELEASE( m_pd3dDevice );
    SAFE_RELEASE( m_pD3D );
}

//-----------------------------------------------------------------------------
// Name: RebootWhilePreservingDDrive()
// Desc: This is a straight port of XLaunchNewImage!!
//-----------------------------------------------------------------------------
const OBJECT_STRING	   g_DDosDevicePrefix = CONSTANT_OBJECT_STRING(OTEXT("\\??\\D:"));
const CHAR             g_szDVDDevicePrefix[] = "\\Device\\Cdrom0";

DWORD XOApplication::RebootWhilePreservingDDrive(
		    LPCSTR lpTitlePath,
		    PLD_FROM_TITLE_UPDATE pldftu
		    )
{
    //
    // We require the path is NULL or D:\something
    //

    if ((NULL != lpTitlePath) &&
        ((('D' != lpTitlePath[0]) && ('d' != lpTitlePath[0])) ||
         (':' != lpTitlePath[1]) ||
         ('\\' != lpTitlePath[2])))
    {
    	RIP_ON_NOT_TRUE("XOApplication::RebootWhilePreservingDDrive", (FALSE));
        return(ERROR_INVALID_PARAMETER);
    }

    if (NULL == lpTitlePath)
    {
        //
        // NULL lpTitlePath means reboot to the dashboard - don't preserve D: drive mapping
        //

        return(XWriteTitleInfoAndReboot(NULL,
                                        NULL,
                                        LDT_FROM_TITLE_UPDATE,
                                        XeImageHeader()->Certificate->TitleID,
                                        (PLAUNCH_DATA)pldftu));
    }
    else
    {
        NTSTATUS Status;
        OBJECT_ATTRIBUTES Obja;
        HANDLE LinkHandle;
        OCHAR szLinkTarget[MAX_PATH * 2];
        OCHAR szDDrivePath[MAX_PATH * 2];
        OBJECT_STRING LinkTarget;
        int cch;

        szDDrivePath[0] = '\0';

        //
        // If the D: drive is mapped in some unique fashion, preserve that mapping
        // across the reboot
        //

        InitializeObjectAttributes(&Obja,
                                   (POBJECT_STRING) &g_DDosDevicePrefix,
                                   OBJ_CASE_INSENSITIVE,
                                   NULL,
                                   NULL);

        Status = NtOpenSymbolicLinkObject(&LinkHandle, &Obja);

        if (NT_SUCCESS(Status))
        {
            LinkTarget.Buffer = szLinkTarget;
            LinkTarget.Length = 0;
            LinkTarget.MaximumLength = sizeof(szLinkTarget);

            Status = NtQuerySymbolicLinkObject(LinkHandle, &LinkTarget, NULL);

            NtClose(LinkHandle);
        }

        if (NT_SUCCESS(Status))
        {
            lstrcpynA(szDDrivePath,
                      szLinkTarget,
                      min(ARRAYSIZE(szDDrivePath), (LinkTarget.Length / sizeof(CHAR)) + 1));
        }
        else
        {
            /* Got no path.  The D: drive should always be mapped to something, so
             * we're in trouble if we get here.  Fall back on the DVD device
             * path */
            ASSERT(FALSE);
            strcpy(szDDrivePath, g_szDVDDevicePrefix);
        }

        return(XWriteTitleInfoAndReboot(&(lpTitlePath[3]),
                                        szDDrivePath,
                                        LDT_FROM_TITLE_UPDATE,
                                        XeImageHeader()->Certificate->TitleID,
                                        (PLAUNCH_DATA)pldftu));
    }
}

//-----------------------------------------------------------------------------
// Name: Run()
// Desc: 
//-----------------------------------------------------------------------------

INT XOApplication::Run()
{
    DbgPrint("XBApp: Running the application...\n");
	
	HRESULT hrRender = S_OK;
    HRESULT hrFrameMove = S_OK;

	HRESULT	hr = S_OK;
    DWORD		dwError;
    DWORD		dwType;
    LAUNCH_DATA	ld;
    PLAUNCH_UPDATE_INFO plui = (PLAUNCH_UPDATE_INFO)&ld;
    LD_FROM_TITLE_UPDATE ldftu;

    PBYTE	pbSymmetricKey;
    PBYTE	pbPublicKey;
    PBYTE	pbTitleKey;
    DWORD	cbPublicKey;

    CHAR	szMessage[MAX_PATH];

	LARGE_INTEGER qwTime;
	QueryPerformanceCounter( &qwTime ); 
	m_fStartTime =  m_fSecsPerTick * ((FLOAT)(qwTime.QuadPart));

	// Get the launch info
	dwError = XGetLaunchInfo(&dwType, &ld);
	if (dwError != ERROR_NOT_FOUND)
	{
		OutputDebugStringA("Got Launch data ...\n");
		
		if (dwError != ERROR_SUCCESS)
		{
			sprintf(szMessage, "Launch data error: %x\n", dwError);
			OutputDebugStringA(szMessage);
			hr = HRESULT_FROM_WIN32(dwError);
			goto Error;
		}
		if (dwType != LDT_TITLE_UPDATE)
		{
			sprintf(szMessage, "Bad LDT: %u\n", dwType);
			OutputDebugStringA(szMessage);
			hr = HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
			goto Error;
		}

		// Kick off the update
		if (plui->dwUpdateFlags & LAUNCH_UPDATE_FLAG_ONLINE)
		{

			// Logon with no users
			XONLINE_USER Users[4];
		    DWORD i;
                                                
			OutputDebugStringA("Doing Online update\n");

			for (i = 0; i < 4; i += 1)
				Users[i].xuid.qwUserID = 0;
			hr = XOnlineLogon(Users, g_rgServices, NUM_SERVICES, NULL, &g_hLogon);
			if (FAILED(hr))
			{
				sprintf(szMessage, "Logon failed hr: %08x\n", hr);
				OutputDebugStringA(szMessage);				
				goto Error;
			}

			// Pump until logon returns
			while( (hr = XOnlineTaskContinue(g_hLogon)) == XONLINETASK_S_RUNNING )
				;
			if (FAILED(hr))
			{
				sprintf(szMessage, "Logon TaskContinue failed hr: %08x\n", hr);
				OutputDebugStringA(szMessage);				
				goto Error;
			}
			
			// Online update
			hr = XOnlineTitleUpdateInternal(
						plui->dwTitleId,
						plui->dwBaseVersion,
						plui->rgbTitleKey,
						NULL, &g_hTask);
		}
		else
		{
			if (plui->dwUpdateFlags & LAUNCH_UPDATE_FLAG_USE_DEFAULT_KEYS)
			{
				OutputDebugStringA("Using default keys\n");
			
				// We use the built-in keys for this
				pbSymmetricKey = (PBYTE)g_rgbSymmetricKey;
				pbPublicKey = g_rgbPublicKey;
				cbPublicKey = g_cbPublicKey;
				pbTitleKey = g_rgbTitleKey;
			}
			else
			{
				pbSymmetricKey = plui->rgbSymmetricKey;
				pbPublicKey = plui->rgbPublicKey;
				cbPublicKey = plui->cbPublicKey;
				pbTitleKey = plui->rgbTitleKey;
			}

			OutputDebugStringA("Doing DVD update\n");
			sprintf(szMessage, "  Update path: %s\n", plui->szUpdatePath);
			OutputDebugStringA(szMessage);
			sprintf(szMessage, "  Title ID: %08x\n", plui->dwTitleId);
			OutputDebugStringA(szMessage);
			sprintf(szMessage, "  dwBaseVersion: %08x\n", plui->dwBaseVersion);
			OutputDebugStringA(szMessage);
			sprintf(szMessage, "  cbPublicKey: %u\n", cbPublicKey);
			OutputDebugStringA(szMessage);

			// Offline update
			hr = XOnlineTitleUpdateFromDVDInternal(
						plui->szUpdatePath,
						plui->dwTitleId,
						plui->dwBaseVersion,
						pbTitleKey,
						pbSymmetricKey,
						XONLINE_KEY_LENGTH,
						pbPublicKey,
						cbPublicKey,
						NULL, &g_hTask);
		}
	}
	else
	{
		hr = E_FAIL;
		RIP("Failed");
	}

	if (FAILED(hr))
	{
		// BUGBUG: Need to display some UI here
		sprintf(szMessage, "Fialed hr: %08x\n", hr);
		OutputDebugStringA(szMessage);
		goto Error;
	}

    // Run the game loop, animating and rendering frames
    while( SUCCEEDED(hrFrameMove) && SUCCEEDED(hrRender) )
    {

		// Pump the task
		if (g_hLogon)
		{
			hr = XOnlineTaskContinue(g_hLogon);
			if (FAILED(hr))
			{
				// BUGBUG: Need to display some UI here
				sprintf(szMessage, "Logon TaskContinue Fialed hr: %08x\n", hr);
				OutputDebugStringA(szMessage);
				goto Error;
			}
		}

		hr = XOnlineTaskContinue(g_hTask);
		if (XONLINETASK_STATUS_AVAILABLE(hr))
			goto Reboot;
			
		if (FAILED(hr))
		{
			// BUGBUG: Need to display some UI here
			sprintf(szMessage, "TaskContinue Fialed hr: %08x\n", hr);
			OutputDebugStringA(szMessage);
			goto Error;
		}
    
        //-----------------------------------------
        // Animate and render a frame
        //-----------------------------------------

        hrFrameMove = FrameMove();

        // Render the scene
        // honestly, this really can't fail...
        hrRender = Render();

        // Finally, show the frame (swaps the backbuffer to the front)
        m_pd3dDevice->Present( NULL, NULL, NULL, NULL );
    }

Reboot:

	Destroy();
	
	ldftu.dwContext = plui->dwContext;
	ldftu.hr = hr;

	OutputDebugStringA("Rebooting ...\n");

	// Reboot to where we're supposed to go
	RebootWhilePreservingDDrive(
			(plui->dwTitleId == AUTOUPD_DASH_TITLE_ID)?NULL:"d:\\default.xbe",
			&ldftu);

    return hrFrameMove;

Error:
	// BUGBUG: Best place to display UI here ...

	goto Reboot;
}




HRESULT XOApplication::FrameMove()
{
	HRESULT hr = S_OK;

    //-----------------------------------------
    // Handle input
    //-----------------------------------------

    // Read the input for all connected gampads
    XBInput_GetInput( m_Gamepad );

    // Lump inputs of all connected gamepads into one common structure.
    // This is done so apps that need only one gamepad can function with
    // any gamepad.
    ZeroMemory( &m_DefaultGamepad, sizeof(m_DefaultGamepad) );
    for( DWORD i=0; i<4; i++ )
    {
        if( m_Gamepad[i].hDevice )
        {
            m_DefaultGamepad.sThumbLX += m_Gamepad[i].sThumbLX;
            m_DefaultGamepad.sThumbLY += m_Gamepad[i].sThumbLY;
            m_DefaultGamepad.sThumbRX += m_Gamepad[i].sThumbRX;
            m_DefaultGamepad.sThumbRY += m_Gamepad[i].sThumbRY;

            m_DefaultGamepad.fX1      += m_Gamepad[i].fX1;
            m_DefaultGamepad.fY1      += m_Gamepad[i].fY1;
            m_DefaultGamepad.fX2      += m_Gamepad[i].fX2;
            m_DefaultGamepad.fY2      += m_Gamepad[i].fY2;
            m_DefaultGamepad.wButtons        |= m_Gamepad[i].wButtons;
            m_DefaultGamepad.wPressedButtons |= m_Gamepad[i].wPressedButtons;
            m_DefaultGamepad.wLastButtons    |= m_Gamepad[i].wLastButtons;

            for( DWORD b=0; b<8; b++ )
            {
                m_DefaultGamepad.bAnalogButtons[b]        |= m_Gamepad[i].bAnalogButtons[b];
                m_DefaultGamepad.bPressedAnalogButtons[b] |= m_Gamepad[i].bPressedAnalogButtons[b];
                m_DefaultGamepad.bLastAnalogButtons[b]    |= m_Gamepad[i].bLastAnalogButtons[b];
            }
        }
    }


    // Handle special input combo to trigger a reboot to the Xbox Dashboard
    if( m_DefaultGamepad.bAnalogButtons[XINPUT_GAMEPAD_LEFT_TRIGGER] > 0 )
    {
        if( m_DefaultGamepad.bAnalogButtons[XINPUT_GAMEPAD_RIGHT_TRIGGER] > 0 )
        {
            if( m_DefaultGamepad.bPressedAnalogButtons[XINPUT_GAMEPAD_BLACK] )
                XLaunchNewImage( NULL, NULL );
        }
    }

    //-----------------------------------------
    // Perform app timing
    //-----------------------------------------

    // Get the current time (keep in LARGE_INTEGER format for precision)
	LARGE_INTEGER qwTime;
    QueryPerformanceCounter( &qwTime );
    
    // Store the current time values as floating point
    
    m_fElapsedTime    = m_fSecsPerTick * ((FLOAT)(qwTime.QuadPart)) - m_fTime;
    m_fTime           = m_fSecsPerTick * ((FLOAT)(qwTime.QuadPart));

	m_ProgressBar.FrameMove(m_DefaultGamepad, m_fElapsedTime);
	return hr;
}


HRESULT XOApplication::Cleanup()
{
	HRESULT hr = S_OK;
	CTranslator::Instance()->Cleanup();
	return hr;
}

HRESULT XOApplication::Render()
{
	if ( m_pd3dDevice )
	{
	
		m_pd3dDevice->BeginScene();

		// Clear the backbuffer 
		m_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_TARGET|D3DCLEAR_ZBUFFER, 
                         D3DCOLOR_XRGB( (int)0, (int)0, (int)0 ), 1.0f, 0L );

		m_ProgressBar.Render(0);
		m_pd3dDevice->EndScene();
	}

	return S_OK;
}



HRESULT XOApplication::Initialize()
{
	HRESULT hr = S_OK;
	do
	{
		hr = CTranslator::Instance()-> Initialize();
		BREAKONFAIL(hr, "XOApplication::Initialize - Fail to init XLate table");
		DbgPrint("XOApplication::Initialize - Translator is initialized\n");

		hr = CreateProgressBar();
		BREAKONFAIL(hr, "XOApplication::Initialize - Fail to create progress bar");
		DbgPrint("XOApplication::Initialize - the screen is initialized\n");
		
	}while(0);

	return hr;
}


HRESULT AutoUpdateCB( float* pProgress )
{
	DWORD	dwPercent;
	float	fPercent;

	*pProgress = 0.0;
	if (g_hTask)
	{
		if (SUCCEEDED(XOnlineTitleUpdateGetProgress(g_hTask, &dwPercent, NULL, NULL)))
		{
			fPercent = (float)dwPercent;
			*pProgress = fPercent / 100.0f;
		}
	}
	return(S_OK);
}

HRESULT XOApplication::CreateProgressBar()
{
	static const TCHAR cszText[] = _T("AUTOUPDATE");
	HRESULT hr = m_ProgressBar.Initialize(XBG_PATH_ANSI"gen_mess_panel.xbg", "gen_mess_panel", eProgressBarSceneId, false);
	MSGPARAMETERS params;
	memset( &params, 0, sizeof( MSGPARAMETERS ) );
	params.m_SceneID = eProgressBarSceneId;
	params.m_pStrMessageID = cszText;
	params.m_pFunction = AutoUpdateCB;
	m_ProgressBar.SetParameters(params);
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\SDK\sdkfiles\common\src\dxutil.cpp ===
//-----------------------------------------------------------------------------
// File: DXUtil.cpp
//
// Desc: Shortcut macros and functions for using DX objects
//
//
// Copyright (c) 1997-2000 Microsoft Corporation. All rights reserved
//-----------------------------------------------------------------------------
#define STRICT
#include <windows.h>
#include <mmsystem.h>
#include <tchar.h>
#include <stdio.h> 
#include <stdarg.h>
#include "DXUtil.h"




//-----------------------------------------------------------------------------
// Name: DXUtil_GetDXSDKMediaPath()
// Desc: Returns the DirectX SDK media path
//-----------------------------------------------------------------------------
const TCHAR* DXUtil_GetDXSDKMediaPath()
{
    static TCHAR strNull[2] = _T("");
    static TCHAR strPath[MAX_PATH];
    DWORD dwType;
    DWORD dwSize = MAX_PATH;
    HKEY  hKey;

    // Open the appropriate registry key
    LONG lResult = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                                _T("Software\\Microsoft\\XboxSDK"),
                                0, KEY_READ, &hKey );
    if( ERROR_SUCCESS != lResult )
        return strNull;

    lResult = RegQueryValueEx( hKey, _T("XboxSDK Samples Path"), NULL,
                              &dwType, (BYTE*)strPath, &dwSize );
    RegCloseKey( hKey );

    if( ERROR_SUCCESS != lResult )
        return strNull;

    _tcscat( strPath, _T("\\Media\\") );

    return strPath;
}




//-----------------------------------------------------------------------------
// Name: DXUtil_FindMediaFile()
// Desc: Returns a valid path to a DXSDK media file
//-----------------------------------------------------------------------------
HRESULT DXUtil_FindMediaFile( TCHAR* strPath, TCHAR* strFilename )
{
    HANDLE file;

    if( NULL==strFilename || NULL==strPath )
        return E_INVALIDARG;

    // Check if the file exists in the current directory
    _tcscpy( strPath, strFilename );

    file = CreateFile( strPath, GENERIC_READ, FILE_SHARE_READ, NULL, 
                       OPEN_EXISTING, 0, NULL );
    if( INVALID_HANDLE_VALUE != file )
    {
        CloseHandle( file );
        return S_OK;
    }
    
    // Check if the file exists in the current directory
    _stprintf( strPath, _T("%s%s"), DXUtil_GetDXSDKMediaPath(), strFilename );

    file = CreateFile( strPath, GENERIC_READ, FILE_SHARE_READ, NULL, 
                       OPEN_EXISTING, 0, NULL );
    if( INVALID_HANDLE_VALUE != file )
    {
        CloseHandle( file );
        return S_OK;
    }

    // On failure, just return the file as the path
    _tcscpy( strPath, strFilename );
    return E_FAIL;
}




//-----------------------------------------------------------------------------
// Name: DXUtil_ReadStringRegKey()
// Desc: Helper function to read a registry key string
//-----------------------------------------------------------------------------
HRESULT DXUtil_ReadStringRegKey( HKEY hKey, TCHAR* strRegName, TCHAR* strValue, 
                                 DWORD dwLength, TCHAR* strDefault )
{
    DWORD dwType;

    if( ERROR_SUCCESS != RegQueryValueEx( hKey, strRegName, 0, &dwType, 
                                          (BYTE*)strValue, &dwLength ) )
    {
        _tcscpy( strValue, strDefault );
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: DXUtil_WriteStringRegKey()
// Desc: Helper function to write a registry key string
//-----------------------------------------------------------------------------
HRESULT DXUtil_WriteStringRegKey( HKEY hKey, TCHAR* strRegName,
                                  TCHAR* strValue )
{
    if( ERROR_SUCCESS != RegSetValueEx( hKey, strRegName, 0, REG_SZ, 
                                        (BYTE*)strValue, 
                                        (_tcslen(strValue)+1)*sizeof(TCHAR) ) )
        return E_FAIL;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: DXUtil_ReadIntRegKey()
// Desc: Helper function to read a registry key int
//-----------------------------------------------------------------------------
HRESULT DXUtil_ReadIntRegKey( HKEY hKey, TCHAR* strRegName, DWORD* pdwValue, 
                              DWORD dwDefault )
{
    DWORD dwType;
    DWORD dwLength = sizeof(DWORD);

    if( ERROR_SUCCESS != RegQueryValueEx( hKey, strRegName, 0, &dwType, 
                                          (BYTE*)pdwValue, &dwLength ) )
    {
        *pdwValue = dwDefault;
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: DXUtil_WriteIntRegKey()
// Desc: Helper function to write a registry key int
//-----------------------------------------------------------------------------
HRESULT DXUtil_WriteIntRegKey( HKEY hKey, TCHAR* strRegName, DWORD dwValue )
{
    if( ERROR_SUCCESS != RegSetValueEx( hKey, strRegName, 0, REG_DWORD, 
                                        (BYTE*)&dwValue, sizeof(DWORD) ) )
        return E_FAIL;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: DXUtil_ReadBoolRegKey()
// Desc: Helper function to read a registry key BOOL
//-----------------------------------------------------------------------------
HRESULT DXUtil_ReadBoolRegKey( HKEY hKey, TCHAR* strRegName, BOOL* pbValue, 
                              BOOL bDefault )
{
    DWORD dwType;
    DWORD dwLength = sizeof(BOOL);

    if( ERROR_SUCCESS != RegQueryValueEx( hKey, strRegName, 0, &dwType, 
                                          (BYTE*)pbValue, &dwLength ) )
    {
        *pbValue = bDefault;
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: DXUtil_WriteBoolRegKey()
// Desc: Helper function to write a registry key BOOL
//-----------------------------------------------------------------------------
HRESULT DXUtil_WriteBoolRegKey( HKEY hKey, TCHAR* strRegName, BOOL bValue )
{
    if( ERROR_SUCCESS != RegSetValueEx( hKey, strRegName, 0, REG_DWORD, 
                                        (BYTE*)&bValue, sizeof(BOOL) ) )
        return E_FAIL;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: DXUtil_ReadGuidRegKey()
// Desc: Helper function to read a registry key guid
//-----------------------------------------------------------------------------
HRESULT DXUtil_ReadGuidRegKey( HKEY hKey, TCHAR* strRegName, GUID* pGuidValue, 
                               GUID& guidDefault )
{
    DWORD dwType;
    DWORD dwLength = sizeof(GUID);

    if( ERROR_SUCCESS != RegQueryValueEx( hKey, strRegName, 0, &dwType, 
                                          (LPBYTE) pGuidValue, &dwLength ) )
    {
        *pGuidValue = guidDefault;
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: DXUtil_WriteGuidRegKey()
// Desc: Helper function to write a registry key guid
//-----------------------------------------------------------------------------
HRESULT DXUtil_WriteGuidRegKey( HKEY hKey, TCHAR* strRegName, GUID guidValue )
{
    if( ERROR_SUCCESS != RegSetValueEx( hKey, strRegName, 0, REG_BINARY, 
                                        (BYTE*)&guidValue, sizeof(GUID) ) )
        return E_FAIL;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: DXUtil_Timer()
// Desc: Performs timer opertations. Use the following commands:
//          TIMER_RESET           - to reset the timer
//          TIMER_START           - to start the timer
//          TIMER_STOP            - to stop (or pause) the timer
//          TIMER_ADVANCE         - to advance the timer by 0.1 seconds
//          TIMER_GETABSOLUTETIME - to get the absolute system time
//          TIMER_GETAPPTIME      - to get the current time
//          TIMER_GETELAPSEDTIME  - to get the time that elapsed between 
//                                  TIMER_GETELAPSEDTIME calls
//-----------------------------------------------------------------------------
FLOAT __stdcall DXUtil_Timer( TIMER_COMMAND command )
{
    static BOOL     m_bTimerInitialized = FALSE;
    static BOOL     m_bUsingQPF         = FALSE;
    static LONGLONG m_llQPFTicksPerSec  = 0;

    // Initialize the timer
    if( FALSE == m_bTimerInitialized )
    {
        m_bTimerInitialized = TRUE;

        // Use QueryPerformanceFrequency() to get frequency of timer.  If QPF is
        // not supported, we will timeGetTime() which returns milliseconds.
        LARGE_INTEGER qwTicksPerSec;
        m_bUsingQPF = QueryPerformanceFrequency( &qwTicksPerSec );
        if( m_bUsingQPF )
            m_llQPFTicksPerSec = qwTicksPerSec.QuadPart;
    }

    if( m_bUsingQPF )
    {
        static LONGLONG m_llStopTime        = 0;
        static LONGLONG m_llLastElapsedTime = 0;
        static LONGLONG m_llBaseTime        = 0;
        double fTime;
        double fElapsedTime;
        LARGE_INTEGER qwTime;
        
        // Get the current time using QueryPerformanceCounter() 
        if( m_llStopTime )
            qwTime.QuadPart = m_llStopTime;
        else
            QueryPerformanceCounter( &qwTime );
    
        // Return the elapsed time
        if( command == TIMER_GETELAPSEDTIME )
        {
            fElapsedTime = (double) ( qwTime.QuadPart - m_llLastElapsedTime ) / (double) m_llQPFTicksPerSec;
            m_llLastElapsedTime = qwTime.QuadPart;
            return (FLOAT) fElapsedTime;
        }
    
        // Return the current time
        if( command == TIMER_GETAPPTIME )
        {
            double fAppTime = (double) ( qwTime.QuadPart - m_llBaseTime ) / (double) m_llQPFTicksPerSec;
            return (FLOAT) fAppTime;
        }
    
        // Reset the timer
        if( command == TIMER_RESET )
        {
            m_llBaseTime        = qwTime.QuadPart;
            m_llLastElapsedTime = qwTime.QuadPart;
            return 0.0f;
        }
    
        // Start the timer
        if( command == TIMER_START )
        {
            QueryPerformanceCounter( &qwTime );
            m_llBaseTime += qwTime.QuadPart - m_llStopTime;
            m_llStopTime = 0;
            m_llLastElapsedTime = qwTime.QuadPart;
        }
    
        // Stop the timer
        if( command == TIMER_STOP )
        {
            m_llStopTime = qwTime.QuadPart;
            m_llLastElapsedTime = qwTime.QuadPart;
        }
    
        // Advance the timer by 1/10th second
        if( command == TIMER_ADVANCE )
        {
            m_llStopTime += m_llQPFTicksPerSec/10;
        }
    
        fTime = qwTime.QuadPart / (double) m_llQPFTicksPerSec;
        return (FLOAT) fTime;
    }
    else
    {
        // Get the time using timeGetTime()
        static double m_fLastElapsedTime  = 0.0;
        static double m_fBaseTime         = 0.0;
        static double m_fStopTime         = 0.0;
        double fTime;
        double fElapsedTime;
        
        if( m_fStopTime )
            fTime = m_fStopTime;
        else
            fTime = timeGetTime() * 0.001;
    
        // Return the elapsed time
        if( command == TIMER_GETELAPSEDTIME )
        {   
            fElapsedTime = (double) (fTime - m_fLastElapsedTime);
            m_fLastElapsedTime = fTime;
            return (FLOAT) fElapsedTime;
        }
    
        // Return the current time
        if( command == TIMER_GETAPPTIME )
        {
            return (FLOAT) (fTime - m_fBaseTime);
        }
    
        // Reset the timer
        if( command == TIMER_RESET )
        {
            m_fBaseTime         = fTime;
            m_fLastElapsedTime  = fTime;
            return 0.0f;
        }
    
        // Start the timer
        if( command == TIMER_START )
        {
            fTime = timeGetTime() * 0.001;
            m_fBaseTime += fTime - m_fStopTime;
            m_fStopTime = 0.0f;
            m_fLastElapsedTime  = fTime;
        }
    
        // Stop the timer
        if( command == TIMER_STOP )
            m_fStopTime = fTime;
    
        // Advance the timer by 1/10th second
        if( command == TIMER_ADVANCE )
        {
            m_fStopTime += 0.1f;
        }
    
        return (FLOAT) fTime;
    }
}




//-----------------------------------------------------------------------------
// Name: DXUtil_ConvertAnsiStringToWide()
// Desc: This is a UNICODE conversion utility to convert a CHAR string into a
//       WCHAR string. cchDestChar defaults -1 which means it 
//       assumes strDest is large enough to store strSource
//-----------------------------------------------------------------------------
VOID DXUtil_ConvertAnsiStringToWide( WCHAR* wstrDestination, const CHAR* strSource, 
                                     int cchDestChar )
{
    if( wstrDestination==NULL || strSource==NULL )
        return;

    if( cchDestChar == -1 )
        cchDestChar = strlen(strSource)+1;

    MultiByteToWideChar( CP_ACP, 0, strSource, -1, 
                         wstrDestination, cchDestChar-1 );

    wstrDestination[cchDestChar-1] = 0;
}




//-----------------------------------------------------------------------------
// Name: DXUtil_ConvertWideStringToAnsi()
// Desc: This is a UNICODE conversion utility to convert a WCHAR string into a
//       CHAR string. cchDestChar defaults -1 which means it 
//       assumes strDest is large enough to store strSource
//-----------------------------------------------------------------------------
VOID DXUtil_ConvertWideStringToAnsi( CHAR* strDestination, const WCHAR* wstrSource, 
                                     int cchDestChar )
{
    if( strDestination==NULL || wstrSource==NULL )
        return;

    if( cchDestChar == -1 )
        cchDestChar = wcslen(wstrSource)+1;

    WideCharToMultiByte( CP_ACP, 0, wstrSource, -1, strDestination, 
                         cchDestChar-1, NULL, NULL );

    strDestination[cchDestChar-1] = 0;
}




//-----------------------------------------------------------------------------
// Name: DXUtil_ConvertGenericStringToAnsi()
// Desc: This is a UNICODE conversion utility to convert a TCHAR string into a
//       CHAR string. cchDestChar defaults -1 which means it 
//       assumes strDest is large enough to store strSource
//-----------------------------------------------------------------------------
VOID DXUtil_ConvertGenericStringToAnsi( CHAR* strDestination, const TCHAR* tstrSource, 
                                        int cchDestChar )
{
    if( strDestination==NULL || tstrSource==NULL )
        return;

#ifdef _UNICODE
    DXUtil_ConvertWideStringToAnsi( strDestination, tstrSource, cchDestChar );
#else
    if( cchDestChar == -1 )
    	strcpy( strDestination, tstrSource );
    else
    	strncpy( strDestination, tstrSource, cchDestChar );
#endif
}




//-----------------------------------------------------------------------------
// Name: DXUtil_ConvertGenericStringToWide()
// Desc: This is a UNICODE conversion utility to convert a TCHAR string into a
//       WCHAR string. cchDestChar defaults -1 which means it 
//       assumes strDest is large enough to store strSource
//-----------------------------------------------------------------------------
VOID DXUtil_ConvertGenericStringToWide( WCHAR* wstrDestination, const TCHAR* tstrSource, 
                                        int cchDestChar )
{
    if( wstrDestination==NULL || tstrSource==NULL )
        return;

#ifdef _UNICODE
    if( cchDestChar == -1 )
	    wcscpy( wstrDestination, tstrSource );
    else
	    wcsncpy( wstrDestination, tstrSource, cchDestChar );
#else
    DXUtil_ConvertAnsiStringToWide( wstrDestination, tstrSource, cchDestChar );
#endif
}




//-----------------------------------------------------------------------------
// Name: DXUtil_ConvertAnsiStringToGeneric()
// Desc: This is a UNICODE conversion utility to convert a CHAR string into a
//       TCHAR string. cchDestChar defaults -1 which means it 
//       assumes strDest is large enough to store strSource
//-----------------------------------------------------------------------------
VOID DXUtil_ConvertAnsiStringToGeneric( TCHAR* tstrDestination, const CHAR* strSource, 
                                        int cchDestChar )
{
    if( tstrDestination==NULL || strSource==NULL )
        return;
        
#ifdef _UNICODE
    DXUtil_ConvertAnsiStringToWide( tstrDestination, strSource, cchDestChar );
#else
    if( cchDestChar == -1 )
    	strcpy( tstrDestination, strSource );
    else
    	strncpy( tstrDestination, strSource, cchDestChar );
#endif
}




//-----------------------------------------------------------------------------
// Name: DXUtil_ConvertAnsiStringToGeneric()
// Desc: This is a UNICODE conversion utility to convert a WCHAR string into a
//       TCHAR string. cchDestChar defaults -1 which means it 
//       assumes strDest is large enough to store strSource
//-----------------------------------------------------------------------------
VOID DXUtil_ConvertWideStringToGeneric( TCHAR* tstrDestination, const WCHAR* wstrSource, 
                                        int cchDestChar )
{
    if( tstrDestination==NULL || wstrSource==NULL )
        return;

#ifdef _UNICODE
    if( cchDestChar == -1 )
	    wcscpy( tstrDestination, wstrSource );
    else
	    wcsncpy( tstrDestination, wstrSource, cchDestChar );
#else
    DXUtil_ConvertWideStringToAnsi( tstrDestination, wstrSource, cchDestChar );
#endif
}




//-----------------------------------------------------------------------------
// Name: _DbgOut()
// Desc: Outputs a message to the debug stream
//-----------------------------------------------------------------------------
HRESULT _DbgOut( TCHAR* strFile, DWORD dwLine, HRESULT hr, TCHAR* strMsg )
{
    TCHAR buffer[256];
    wsprintf( buffer, _T("%s(%ld): "), strFile, dwLine );
    OutputDebugString( buffer );
    OutputDebugString( strMsg );

    if( hr )
    {
        wsprintf( buffer, _T("(hr=%08lx)\n"), hr );
        OutputDebugString( buffer );
    }

    OutputDebugString( _T("\n") );

    return hr;
}




//-----------------------------------------------------------------------------
// Name: DXUtil_Trace()
// Desc: Outputs to the debug stream a formatted string with a variable-
//       argument list.
//-----------------------------------------------------------------------------
VOID DXUtil_Trace( TCHAR* strMsg, ... )
{
#if defined(DEBUG) | defined(_DEBUG)
    TCHAR strBuffer[512];
    
    va_list args;
    va_start(args, strMsg);
    _vsntprintf( strBuffer, 512, strMsg, args );
    va_end(args);

    OutputDebugString( strBuffer );
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\SDK\sdksetup\autorun\source\autorun\autorun.h ===
//-----------------------------------------------------------------------------
// File: autorun.h
//
// Desc:Main header file for the AUTORUN application
//
// Hist: 10.27.00 Emily Wang Created For XBOX
//       
// Copyright (c) 1998-2000 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

#if !defined(AFX_AUTORUN_H__03A697D8_6DE4_4754_8108_A425119BCF60__INCLUDED_)
#define AFX_AUTORUN_H__03A697D8_6DE4_4754_8108_A425119BCF60__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"		// main symbols

/////////////////////////////////////////////////////////////////////////////
// CAutorunApp:
// See autorun.cpp for the implementation of this class
//

typedef struct SAutorunLink
{
	PTSTR pszName;
	RECT  rcRect;
	PTSTR pszCommand;
} *PSAutorunLink;

typedef struct SAutorunInfo
{
	PTSTR         pszTitle;                 // Title
	TCHAR         szFontName[LF_FACESIZE];  // Font name
	TCHAR		  szFolderName[MAX_PATH];
	INT           nFontSize;
	COLORREF      crFont;
	COLORREF      crHighLight;
	TCHAR         szImagePath[MAX_PATH];
    TCHAR         szIconPath[MAX_PATH];
	TCHAR		  szPath[MAX_PATH];
	TCHAR		  szCursorPath[MAX_PATH];
	INT           cnLinks;
	PSAutorunLink psLinks;
} *PSAutorunInfo;

class CAutorunApp : public CWinApp
{
public:
	CAutorunApp();
   ~CAutorunApp();

	PSAutorunInfo GetInfo(void) { return &m_sInfo; }


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAutorunApp)
	public:
	virtual BOOL InitInstance();
	//}}AFX_VIRTUAL

// Implementation

	//{{AFX_MSG(CAutorunApp)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:
	SAutorunInfo m_sInfo;
};


/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_AUTORUN_H__03A697D8_6DE4_4754_8108_A425119BCF60__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\SDK\sdksetup\autorun\source\autorun\autorun.cpp ===
//-----------------------------------------------------------------------------
// File: autorun.cpp
//
// Desc: Defines the class behaviors for the application
//
// Hist: 10.27.00 Emily Wang Created For XBOX
//       
// Copyright (c) 1998-2000 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------


#include "stdafx.h"
#include "autorun.h"
#include "autorunDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif



//-----------------------------------------------------------------------------
// CAutorunApp 
//-----------------------------------------------------------------------------
HANDLE g_hmutexPrevInst = NULL; // For checking prevous instance.

BEGIN_MESSAGE_MAP(CAutorunApp, CWinApp)
	//{{AFX_MSG_MAP(CAutorunApp)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG
	ON_COMMAND(ID_HELP, CWinApp::OnHelp)
END_MESSAGE_MAP()



//-----------------------------------------------------------------------------
// CAutorunApp construction
//-----------------------------------------------------------------------------
CAutorunApp::CAutorunApp()
{
	// TODO: add construction code here,
	// Place all significant initialization in InitInstance
	ZeroMemory(&m_sInfo, sizeof(m_sInfo));
}

CAutorunApp::~CAutorunApp()
{
	delete m_sInfo.pszTitle;
	for (INT i = 0; i < m_sInfo.cnLinks; i++)
	{
		delete m_sInfo.psLinks[i].pszName;
		delete m_sInfo.psLinks[i].pszCommand;
	}
	delete m_sInfo.psLinks;
}


//-----------------------------------------------------------------------------
// The one and only CAutorunApp object
//-----------------------------------------------------------------------------
CAutorunApp theApp;



//-----------------------------------------------------------------------------
// Name: InitIstance()
// Desc: Entry point to the program. CAutorunApp initialization.
//-----------------------------------------------------------------------------
BOOL CAutorunApp::InitInstance()
{
	INT    nResponse, cnTries;
	INT		nPathLength, nStringLength;
	TCHAR szBuffer[512];
	TCHAR szSection[128];
	CAutorunDlg dlg;

TryAgain:

    g_hmutexPrevInst = CreateMutex(NULL, TRUE, TEXT("Mutex_XBoxAutoRun"));
    if (!g_hmutexPrevInst)
    {
        return FALSE;
    }
    else if (GetLastError() == ERROR_ALREADY_EXISTS)
    {
        // Is there a previous instance existing?
        cnTries = 0;
        while(cnTries--)
        {
            // Wait for a while
            Sleep(3000);
            ReleaseMutex(g_hmutexPrevInst);
            goto TryAgain;
        }
        
		return FALSE;
    }

	

//-----------------------------------------------------------------------------
// Name: GetModuleFileName()
// Desc: Get install path
//-----------------------------------------------------------------------------	

	INT		nFileLength;
	TCHAR	szFilePath[MAX_PATH];
	TCHAR	FileBuffer[MAX_PATH];
	LPTSTR	lpFilePart;
	lpFilePart = 0;


	nPathLength = GetModuleFileName(NULL, szFilePath, MAX_PATH);
	nFileLength = GetFullPathName(szFilePath,MAX_PATH, FileBuffer, &lpFilePart);
	
	// Remove the file name.
	*(lpFilePart) = 0;
	
	// Path of CD ROM, image, cursor and icon.
	_tcscpy(m_sInfo.szPath, FileBuffer);
_tcscpy(m_sInfo.szImagePath, FileBuffer);
	_tcscpy(m_sInfo.szCursorPath, FileBuffer);
	_tcscpy(m_sInfo.szIconPath, FileBuffer);
	

	// Path of ini file
	_tcscpy(szFilePath, FileBuffer);
	_tcscat(szFilePath, _T("autorun.ini"));


//-----------------------------------------------------------------------------
// Name: GetUserDefaultLangID()
// Desc: Get user default Language
//-----------------------------------------------------------------------------	
	int nLangID = GetUserDefaultLangID();
		
	if (nLangID == 0)
	{
		_tcscpy(szSection, "Default");
	}
	else
	{
		_itot(nLangID, szSection, 10);
	
		nStringLength = GetPrivateProfileString(szSection, _T("TITLE"), _T(""), szBuffer, sizeof(szBuffer), szFilePath);
		if (nStringLength == 0) 
		{
			_tcscpy(szSection, "Default");			
		}
	}



//-----------------------------------------------------------------------------
// Name: GetPrivateProfileString()
// Desc: Get info of dialog.
//-----------------------------------------------------------------------------	
	nStringLength = GetPrivateProfileString(szSection, _T("TITLE"), _T(""), szBuffer, sizeof(szBuffer), szFilePath);
	// process title
	m_sInfo.pszTitle = new TCHAR[_tcslen(szBuffer) + 1 ];
	_tcscpy(m_sInfo.pszTitle, szBuffer);
	
	nStringLength = GetPrivateProfileString(szSection, _T("IMAGE"), _T(""), szBuffer, sizeof(szBuffer), szFilePath);
	// process image path
	_tcscat(m_sInfo.szImagePath, szBuffer);

	nStringLength = GetPrivateProfileString(szSection, _T("ICON"), _T(""), szBuffer, sizeof(szBuffer), szFilePath);
	// process icon path
	_tcscat(m_sInfo.szIconPath, szBuffer);

	nStringLength = GetPrivateProfileString(szSection, _T("CURSOR"), _T(""), szBuffer, sizeof(szBuffer), szFilePath);
	// process cursor path
	_tcscat(m_sInfo.szCursorPath, szBuffer);

	nStringLength = GetPrivateProfileString(szSection, _T("NAME"), _T(""), szBuffer, sizeof(szBuffer), szFilePath);
	// process text name
	_tcscpy(m_sInfo.szFontName, szBuffer);
	
	nStringLength = GetPrivateProfileString(szSection, _T("SIZE"), _T(""), szBuffer, sizeof(szBuffer), szFilePath);
	// process text size
	m_sInfo.nFontSize = atoi(szBuffer);

	nStringLength = GetPrivateProfileString(szSection, _T("COLOR"), _T(""), szBuffer, sizeof(szBuffer), szFilePath);
	// process text color 
	m_sInfo.crFont = (COLORREF)_tcstoul(szBuffer, NULL, 16);

	nStringLength = GetPrivateProfileString(szSection, _T("HIGHLIGHTCOLOR"), _T(""), szBuffer, sizeof(szBuffer), szFilePath);
	// process text highlight color
	m_sInfo.crHighLight = (COLORREF)_tcstoul(szBuffer, NULL, 16);

	// Count the links
	for ( int i = 0; ; i++ )
	{
		TCHAR* pszDelimit;
		TCHAR* pszLine;
		TCHAR szKey[128];
		
		_stprintf(szKey, _T("LINK%d"), i);
		nStringLength = GetPrivateProfileString(szSection, szKey, _T(""), szBuffer, sizeof(szBuffer), szFilePath);
		if(nStringLength == 0) break;

		pszLine = szBuffer;

		for(int cDelims = 0; ; cDelims++)
		{
			pszDelimit = _tcsstr(pszLine, TEXT(","));
			if(pszDelimit == NULL) break;
			pszLine = pszDelimit + 1;
		}
		ASSERT(cDelims == 3);
		if(cDelims != 3)
		{
			break;
		}
	}
	m_sInfo.cnLinks = i;

	// Allocat link buffer
	m_sInfo.psLinks = new SAutorunLink[m_sInfo.cnLinks];
	ZeroMemory(m_sInfo.psLinks, sizeof(SAutorunLink) * m_sInfo.cnLinks);
	
	// Get the links
	for ( i = 0; i < m_sInfo.cnLinks; i++ )
	{
		TCHAR* pszDelimit;
		TCHAR* pszLine;
		TCHAR szKey[128];
		
		_stprintf(szKey, _T("LINK%d"), i);
		nStringLength = GetPrivateProfileString(szSection, szKey, _T(""), szBuffer, sizeof(szBuffer), szFilePath);

		// Get link names
		pszLine = szBuffer;
		pszDelimit = _tcsstr(pszLine, TEXT(","));
		*pszDelimit = 0;
		m_sInfo.psLinks[i].pszName = new TCHAR[_tcslen(pszLine) + 1];
		_tcscpy(m_sInfo.psLinks[i].pszName, pszLine);
		pszLine = pszDelimit + 1;

		// Get link positions
		pszDelimit = _tcsstr(pszLine, TEXT(","));
		*pszDelimit = 0;
		m_sInfo.psLinks[i].rcRect.right = m_sInfo.psLinks[i].rcRect.left = atoi(pszLine);
		pszLine = pszDelimit + 1;

		pszDelimit = _tcsstr(pszLine, TEXT(","));
		*pszDelimit = 0;
		m_sInfo.psLinks[i].rcRect.bottom = m_sInfo.psLinks[i].rcRect.top = atoi(pszLine);
		pszLine = pszDelimit + 1;

		// Get link commands
		pszDelimit = _tcsstr(pszLine, TEXT(","));
        if (pszDelimit)
        {
            *pszDelimit = 0;
        }
		m_sInfo.psLinks[i].pszCommand = new TCHAR[_tcslen(pszLine) + 1];
		_tcscpy(m_sInfo.psLinks[i].pszCommand, pszLine);
	}

	if (i != m_sInfo.cnLinks)
	{
		ASSERT(FALSE);
		goto Error;
	}

    m_pMainWnd = &dlg;
	nResponse = dlg.DoModal();
	if (nResponse == IDOK)
		{
			// TODO: Place code here to handle when the dialog is
			//  dismissed with OK
		}
		else if (nResponse == IDCANCEL)
		{
			// TODO: Place code here to handle when the dialog is
			//  dismissed with Cancel
		}
Error:
	    
    ReleaseMutex(g_hmutexPrevInst);

	// Since the dialog has been closed, return FALSE so that we exit the
	//  application, rather than start the application's message pump.
	return FALSE; 
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\SDK\sdksetup\autorun\source\autorun\autorunDlg.h ===
//-----------------------------------------------------------------------------
// File: autorun.cpp
//
// Desc: header file
//
// Hist: 10.27.00 Emily Wang Created For XBOX
//       
// Copyright (c) 1998-2000 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

#if !defined(AFX_AUTORUNDLG_H__BBCC11C6_4698_4E91_A0D7_7AB6D85084F3__INCLUDED_)
#define AFX_AUTORUNDLG_H__BBCC11C6_4698_4E91_A0D7_7AB6D85084F3__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

/////////////////////////////////////////////////////////////////////////////
// CAutorunDlg dialog
#include "bitmap.h"

class CAutorunDlg : public CDialog
{
// Construction
public:
	CAutorunDlg(CWnd* pParent = NULL);	// standard constructor

// Dialog Data
	//{{AFX_DATA(CAutorunDlg)
	enum { IDD = IDD_AUTORUN_DIALOG };
		// NOTE: the ClassWizard will add data members here
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAutorunDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);	// DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	HICON	m_hIcon;
	HCURSOR m_hCursor;
    HCURSOR m_hOldCursor;

	// Generated message map functions
	//{{AFX_MSG(CAutorunDlg)
	virtual BOOL OnInitDialog();
	afx_msg void OnPaint();
	afx_msg HCURSOR OnQueryDragIcon();
	afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnLButtonUp(UINT nFlags, CPoint point);
	afx_msg void OnMouseMove(UINT nFlags, CPoint point);
    afx_msg void OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags);
    afx_msg UINT OnGetDlgCode();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:
	SIZE CalculateTextSize(CDC* pDC, LPCTSTR pszString);
    void DrawLink(CDC* pDC, LPCTSTR pszText, COLORREF crText, RECT rcRect);

    void OnOK(void);

private:
    // The font of links
    CFont            m_font;

    // The index of link which is hited by mouse. If m_nIndexHitLink = -1, no link has been hitted
    INT              m_nIndexHitLink;

    // The image of the dialog background
    CBitmapFileImage m_cImage;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#define IDC_STATIC_AUTORUN_LINK  0x0101

#endif // !defined(AFX_AUTORUNDLG_H__BBCC11C6_4698_4E91_A0D7_7AB6D85084F3__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\SDK\sdksetup\autorun\source\autorun\autorunDlg.cpp ===
//-----------------------------------------------------------------------------
// File: autorunDlg.cpp
//
// Desc: Implemention file
//
// Hist: 10.27.00 Emily Wang Created For XBOX
//       
// Copyright (c) 1998-2000 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

#include "stdafx.h"
#include "autorun.h"
#include "autorunDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define EXTRA_CXBORDER   10
#define EXTRA_CYBORDER   10

/////////////////////////////////////////////////////////////////////////////
// CAutorunDlg dialog

CAutorunDlg::CAutorunDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CAutorunDlg::IDD, pParent),
    m_nIndexHitLink(-1),
    m_hOldCursor(NULL)
{
	//{{AFX_DATA_INIT(CAutorunDlg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
	// Note that LoadIcon does not require a subsequent DestroyIcon in Win32
}

void CAutorunDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAutorunDlg)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CAutorunDlg, CDialog)
	//{{AFX_MSG_MAP(CAutorunDlg)
	ON_WM_PAINT()
	ON_WM_QUERYDRAGICON()
	ON_WM_LBUTTONDOWN()
	ON_WM_LBUTTONUP()
	ON_WM_MOUSEMOVE()
    ON_WM_KEYDOWN()
    ON_WM_GETDLGCODE()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CAutorunDlg message handlers

//-----------------------------------------------------------------------------
// Name: OnInitDialog()
// Desc: AutorunDialog initialization.
//-----------------------------------------------------------------------------
BOOL CAutorunDlg::OnInitDialog()
{
	
	CClientDC dc(this);
    RECT      rcBounding;
    SIZE      size;

	CDialog::OnInitDialog();

	PSAutorunInfo psInfo = ((CAutorunApp*)AfxGetApp())->GetInfo();
	ASSERT(psInfo != NULL);

    // Load icon 
    m_hIcon = (HICON)LoadImage(NULL, psInfo->szIconPath, IMAGE_ICON, 0, 0, LR_LOADFROMFILE | LR_DEFAULTSIZE);
    if (!m_hIcon)
    {
        // If fail, we use the default icon in the resource
        m_hIcon = AfxGetApp()->LoadIcon(IDR_MAINFRAME);
    }

	// Set the icon for this dialog.  The framework does this automatically
	//  when the application's main window is not a dialog

	SetIcon(m_hIcon, FALSE);			// Set big icon
	SetIcon(m_hIcon, TRUE);		// Set small icon

	// Load cursor 
	m_hCursor = (HCURSOR)LoadImage(NULL, psInfo->szCursorPath, IMAGE_CURSOR, 0, 0, LR_LOADFROMFILE | LR_DEFAULTSIZE);
   
	// Set dialog text
	SetWindowText(psInfo->pszTitle);

	// Create font
    LOGFONT logFont;
	
	//Sets buffers to a specified character
    memset(&logFont, 0, sizeof(logFont));
    strcpy(logFont.lfFaceName, psInfo->szFontName);
    logFont.lfCharSet = DEFAULT_CHARSET;
    logFont.lfHeight = -MulDiv(psInfo->nFontSize, GetDeviceCaps(dc.m_hDC, LOGPIXELSY), 72);
    logFont.lfWeight = 700; // Bold
    m_font.CreateFontIndirect(&logFont);
	
    // Init bounding rect
    rcBounding.left   = rcBounding.top   = INT_MAX;
    rcBounding.bottom = rcBounding.right = INT_MIN;

	for (INT i = 0; i < psInfo->cnLinks; i++)
	{
		size = CalculateTextSize(&dc, psInfo->psLinks[i].pszName);

        psInfo->psLinks[i].rcRect.right  = psInfo->psLinks[i].rcRect.left + size.cx;
        psInfo->psLinks[i].rcRect.bottom = psInfo->psLinks[i].rcRect.top  + size.cy;
        
        // Get the maximun rectangle boundary.
        if (rcBounding.left > psInfo->psLinks[i].rcRect.left)
            rcBounding.left = psInfo->psLinks[i].rcRect.left;

        if (rcBounding.top > psInfo->psLinks[i].rcRect.top)
            rcBounding.top = psInfo->psLinks[i].rcRect.top;

        if (rcBounding.right < psInfo->psLinks[i].rcRect.right)
            rcBounding.right = psInfo->psLinks[i].rcRect.right;

        if (rcBounding.bottom < psInfo->psLinks[i].rcRect.bottom)
            rcBounding.bottom = psInfo->psLinks[i].rcRect.bottom;
	}

    //Set bmp file
	m_cImage.InitData(psInfo->szImagePath);

    // Calculate the size of window
    size = m_cImage.GetSize();
    if (!size.cx && !size.cy && psInfo->cnLinks)
    {
        size.cx = rcBounding.right  + EXTRA_CXBORDER;
        size.cy = rcBounding.bottom + EXTRA_CYBORDER;
    }

    size.cx += 2 * GetSystemMetrics(SM_CXBORDER);
    size.cy += 2 * GetSystemMetrics(SM_CYBORDER) + GetSystemMetrics(SM_CYCAPTION);

    // Change the size of the window
    SetWindowPos(NULL, 0, 0, size.cx, size.cy, SWP_NOMOVE | SWP_NOZORDER);

	return TRUE;  // return TRUE  unless you set the focus to a control
}

//-----------------------------------------------------------------------------
// Name: OnPaint()
// Desc: Draw the icon for minimize button to dialog.  
//-----------------------------------------------------------------------------

void CAutorunDlg::OnPaint() 
{
	if (IsIconic())
	{
		CPaintDC dc(this); // device context for painting

		SendMessage(WM_ICONERASEBKGND, (WPARAM) dc.GetSafeHdc(), 0);

		// Center icon in client rectangle
		int cxIcon = GetSystemMetrics(SM_CXICON);
		int cyIcon = GetSystemMetrics(SM_CYICON);
		CRect rect;
		GetClientRect(&rect);
		int x = (rect.Width() - cxIcon + 1) / 2;
		int y = (rect.Height() - cyIcon + 1) / 2;

		// Draw the icon
		dc.DrawIcon(x, y, m_hIcon);
	}
	else
	{
	    PSAutorunInfo psInfo = ((CAutorunApp*)AfxGetApp())->GetInfo();
	    ASSERT(psInfo != NULL);

		CPaintDC dc(this); // device context for painting

        m_cImage.DrawImage(&dc, 0, 0, FALSE);

        CFont* pOldFont = dc.SelectObject(&m_font);

        for (INT i = 0; i < psInfo->cnLinks; i++)
        {
            COLORREF crText = m_nIndexHitLink == i ? psInfo->crHighLight : psInfo->crFont;

            DrawLink(&dc, psInfo->psLinks[i].pszName, crText, psInfo->psLinks[i].rcRect);
        }

	    dc.SelectObject(pOldFont);

		CDialog::OnPaint();
	}
}

//-----------------------------------------------------------------------------
// Name: OnQueryDrayIcon()
// Desc: The system calls to obtain the cursor to display while the user drags
//		 the minimized window.
//-----------------------------------------------------------------------------
HCURSOR CAutorunDlg::OnQueryDragIcon()
{
	return (HCURSOR) m_hIcon;
}

//-----------------------------------------------------------------------------
// Name: OnLButtonDown()
// Desc: Performs the commands to display others when left button down.
//-----------------------------------------------------------------------------
void CAutorunDlg::OnLButtonDown(UINT nFlags, CPoint point) 
{
}

//-----------------------------------------------------------------------------
// Name: OnLButtonUP()
// Desc: Performs the commands to display others when left button up.
//-----------------------------------------------------------------------------
void CAutorunDlg::OnLButtonUp(UINT nFlags, CPoint point) 
{
    PSAutorunInfo psInfo = ((CAutorunApp*)AfxGetApp())->GetInfo();

    OnOK();
}

//-----------------------------------------------------------------------------
// Name: OnMouseMove()
// Desc: Performs change the text color between mouse on and off of the text.
//-----------------------------------------------------------------------------
void CAutorunDlg::OnMouseMove(UINT nFlags, CPoint point)
{
	PSAutorunInfo psInfo = ((CAutorunApp*)AfxGetApp())->GetInfo();
    static BOOL   bPrevOver = FALSE;

	for (INT i = 0; i < psInfo->cnLinks; i++)
	{
		if (PtInRect(&psInfo->psLinks[i].rcRect, point))
		{
			break;
		}
	}

	if (i >= psInfo->cnLinks)
	{
		if (m_nIndexHitLink >= 0)
		{
			InvalidateRect(&psInfo->psLinks[m_nIndexHitLink].rcRect, TRUE);
		}
		m_nIndexHitLink = -1;
	}
	else 
	{
		if (m_nIndexHitLink < 0)
		{
			InvalidateRect(&psInfo->psLinks[i].rcRect, TRUE);
        }
        
        if (m_nIndexHitLink >= 0 && i != m_nIndexHitLink)
        {
			InvalidateRect(&psInfo->psLinks[m_nIndexHitLink].rcRect, TRUE);
        }
		m_nIndexHitLink = i;
	}

    if (m_nIndexHitLink >= 0 && m_hCursor)
    {
        m_hOldCursor = SetCursor(m_hCursor);
    } 
    else if (m_hOldCursor)
    {
        SetCursor(m_hOldCursor);
        m_hOldCursor = NULL;
    }
}

//-----------------------------------------------------------------------------
// Name: CalculateTextSize()
// Desc: Performs a calculation on each of the strings to determine
//       the text sizes.
//-----------------------------------------------------------------------------
SIZE CAutorunDlg::CalculateTextSize(CDC* pDC, LPCTSTR pszString)
{
	SIZE   size;
	CFont* pOldFont = pDC->SelectObject(&m_font);

	size = pDC->GetTextExtent(pszString, _tcslen(pszString));

	pDC->SelectObject(pOldFont);

	return size;
}

//-----------------------------------------------------------------------------
// Name: DrawLink()
// Desc: Draw the text on the image with transparent background color.
//-----------------------------------------------------------------------------
void CAutorunDlg::DrawLink(CDC* pDC, LPCTSTR pszText, COLORREF crText, RECT rcRect)
{

    INT nPrevBkMode = pDC->SetBkMode(TRANSPARENT);
    COLORREF crPrevColor = pDC->SetTextColor(crText);

    pDC->TextOut(rcRect.left, rcRect.top, pszText);

    pDC->SetTextColor(crPrevColor);
    pDC->SetBkMode(nPrevBkMode);
}


//-----------------------------------------------------------------------------
// Name: OnKeyDown()
// Desc: Function for Keyboard access
//-----------------------------------------------------------------------------
void CAutorunDlg::OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags)
{
    PSAutorunInfo psInfo = ((CAutorunApp*)AfxGetApp())->GetInfo();
    INT           nPrevHit = m_nIndexHitLink;

    if (!psInfo->cnLinks)
    {
        return;
    }

    switch(nChar)
    {
    case VK_RETURN:
        OnOK();
        break;

    case VK_PRIOR:
    case VK_DOWN:
        m_nIndexHitLink++;
        if (m_nIndexHitLink < 0 || m_nIndexHitLink >= psInfo->cnLinks)
        {
            m_nIndexHitLink = 0;
        }
        break;

    case VK_NEXT:
    case VK_UP:
        m_nIndexHitLink--;
        if (m_nIndexHitLink < 0)
        {
            m_nIndexHitLink = psInfo->cnLinks - 1;
        }
        break;
    }

    if (nPrevHit != m_nIndexHitLink)
    {
        if (nPrevHit >= 0)
        {
			InvalidateRect(&psInfo->psLinks[nPrevHit].rcRect, TRUE);
        }
        if (m_nIndexHitLink >= 0)
        {
            InvalidateRect(&psInfo->psLinks[m_nIndexHitLink].rcRect, TRUE);
        }
    }
}


//-----------------------------------------------------------------------------
// Name: OnGetDlgCode()
// Desc: Release the key that locked by dlg
//-----------------------------------------------------------------------------
UINT CAutorunDlg::OnGetDlgCode()
{
    return DLGC_WANTALLKEYS;
}


//-----------------------------------------------------------------------------
// Name: OnOK()
// Desc: Function for Keyboard access
//-----------------------------------------------------------------------------
void CAutorunDlg::OnOK(void)
{
    PSAutorunInfo psInfo = ((CAutorunApp*)AfxGetApp())->GetInfo();

    if (m_nIndexHitLink >= 0)
    {
        // Do link actions
        if (!psInfo->psLinks[m_nIndexHitLink].pszCommand ||! psInfo->psLinks[m_nIndexHitLink].pszCommand[0])
        {
            EndDialog(IDOK);
        }
        else
        {
	        PROCESS_INFORMATION piCmd;
	        STARTUPINFO         si;

		    memset(&si, 0, sizeof(STARTUPINFO));
		    si.cb = sizeof(STARTUPINFO);

            CreateProcess(	NULL,			// pointer to name of executable module 
			      psInfo->psLinks[m_nIndexHitLink].pszCommand,		// pointer to command line string
			      NULL,				// pointer to process security attributes
			      NULL,				// pointer to thread security attributes
			      FALSE,				// handle inheritance flag 
			      DETACHED_PROCESS,	// creation flags 
			      NULL,				// pointer to new environment block
			      psInfo->szPath,	// pointer to current directory name
			      &si,				// pointer to STARTUPINFO
			      &piCmd);		
        }

        // Restore the highlight link
		InvalidateRect(&psInfo->psLinks[m_nIndexHitLink].rcRect, TRUE);
        m_nIndexHitLink = -1;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\SDK\sdksetup\autorun\source\autorun\bitmap.h ===
#ifndef  __BITMAP_DECLARE__
#define  __BITMAP_DECLARE__

#include "image.h"
#include <vfw.h>
#pragma comment (lib, "vfw32.lib")

#define PALVERSION 0x300

class CBitmapDataImage : public CImage 
{
public:
    CBitmapDataImage();
   ~CBitmapDataImage();

public:
    BOOL InitData(int nWidth, int nHeight, int nPlandes, int nBitPerPel, void*, LONG);

public:
    BOOL DrawImage(CDC* pcDC, int x, int y, BOOL bForeBackGround);

private:
    int   m_nPlanes;
    int   m_nBitPerPel;
    void* m_pData;
    LONG  m_lDataSize;
};

class CBitmapResourceImage : public CImage 
{
public:
    CBitmapResourceImage();
   ~CBitmapResourceImage();

public:
    BOOL InitData(int nResourceID);

public:
    BOOL DrawImage(CDC* pcDC, int x, int y, BOOL bForeBackGround);

private:
    CBitmap m_cBitmapData;
};

class CBitmapFileImage : public CImage
{
public:
    CBitmapFileImage();
   ~CBitmapFileImage();

public:
    BOOL InitData(LPCSTR lpctszFile);

public:
    BOOL DrawImage(CDC* pcDC, int x, int y, BOOL bForeBackGround = TRUE);

protected:
    CPalette* CreatePalette(void);
    BYTE*     GetBits(void);
    void      Close(void);
    DWORD     GetColorNum(void);
    
private:
    LPBYTE   m_pDIB;
    HDRAWDIB m_hDrawDib;
};

#endif //__BITMAP_DECLARE__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\SDK\sdksetup\autorun\source\autorun\bitmap.cpp ===
#include "stdafx.h"
#include "bitmap.h"
//#include "globfunc.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////
// CBitmapDataImage

CBitmapDataImage::CBitmapDataImage() :
    CImage(),
    m_nPlanes(0),
    m_nBitPerPel(0),
    m_pData(NULL),
    m_lDataSize(0)
{
}

CBitmapDataImage::~CBitmapDataImage()
{
    delete m_pData;
}

BOOL CBitmapDataImage::InitData(
    int   nWidth,
    int   nHeight,
    int   nPlanes, 
    int   nBitPerPel, 
    void* pData,
    LONG  lDataSize)
{
    m_sizeImage.cx = nWidth;
    m_sizeImage.cy = nHeight;
    m_nPlanes      = nPlanes;
    m_nBitPerPel   = nBitPerPel;
    m_pData        = pData;
    m_lDataSize    = lDataSize;

    return TRUE;
}

BOOL CBitmapDataImage::DrawImage(
    CDC* pcDC,
    int  x,
    int  y,
    BOOL bForeBackGround)
{
    CBitmap cBitmap, *pcOldBitmap;
    CRect   rectImage, rectIntersect;
    CDC     cMemDC;

    rectImage.SetRect(0, 0,  m_sizeImage.cx, m_sizeImage.cy);
    rectImage.OffsetRect(x, y);
    if (m_fHaveBounding) {
        if (!rectIntersect.IntersectRect(m_rectBounding, rectImage)) {
            return FALSE;
        }
    } else {
        rectIntersect = rectImage;
    }

    cMemDC.CreateCompatibleDC(pcDC);

    if (!cBitmap.CreateBitmap(m_sizeImage.cx, m_sizeImage.cy, m_nPlanes, 
        m_nBitPerPel, m_pData)) {
        return FALSE;
    }

    pcOldBitmap = (CBitmap*)cMemDC.SelectObject(&cBitmap);

    pcDC->BitBlt(rectIntersect.left, rectIntersect.top, 
        rectIntersect.Width(), rectIntersect.Height(), 
        &cMemDC, 
        rectIntersect.left - rectImage.left, 
        rectIntersect.top  - rectImage.top, SRCCOPY);

    cMemDC.SelectObject(pcOldBitmap);

    return TRUE;
}

/////////////////////////////////////////////////////
// CBitmapResourceImage

CBitmapResourceImage::CBitmapResourceImage() :
    CImage()
{
}

CBitmapResourceImage::~CBitmapResourceImage()
{
}

BOOL CBitmapResourceImage::InitData(
    INT iResourceID)
{
    BITMAP  sBitmapInfo;

    m_cBitmapData.DeleteObject();
    if (!m_cBitmapData.LoadBitmap(iResourceID)) {
        return FALSE;
    }
    if (!m_cBitmapData.GetObject(sizeof(BITMAP), &sBitmapInfo)) {
        return FALSE;
    }
    m_sizeImage.cx = sBitmapInfo.bmWidth;
    m_sizeImage.cy = sBitmapInfo.bmHeight;
    return TRUE;
}

BOOL CBitmapResourceImage::DrawImage(
    CDC* pcDC,
    int  x,
    int  y,
    BOOL bForeBackGround)
{
    CBitmap *pcOldBitmap;
    CRect   rectImage, rectIntersect;
    CDC     cMemDC;

    rectImage.SetRect(0, 0,  m_sizeImage.cx, m_sizeImage.cy);
    rectImage.OffsetRect(x, y);
    if (m_fHaveBounding) {
        if (!rectIntersect.IntersectRect(m_rectBounding, rectImage)) {
            return FALSE;
        }
    } else {
        rectIntersect = rectImage;
    }

    cMemDC.CreateCompatibleDC(pcDC);

    pcOldBitmap = (CBitmap*)cMemDC.SelectObject(&m_cBitmapData);

    pcDC->BitBlt(rectIntersect.left, rectIntersect.top, 
        rectIntersect.Width(), rectIntersect.Height(), 
        &cMemDC, 
        rectIntersect.left - rectImage.left, 
        rectIntersect.top  - rectImage.top, SRCCOPY);

    cMemDC.SelectObject(pcOldBitmap);

    return TRUE;
}

/////////////////////////////////////////////////////
// CBitmapFileImage

CBitmapFileImage::CBitmapFileImage() : 
    CImage(),
    m_pDIB(NULL),
    m_hDrawDib(NULL)
{
}

CBitmapFileImage::~CBitmapFileImage()
{
    Close();
}

void CBitmapFileImage::Close(void)
{
    if (m_hDrawDib) {
        DrawDibClose(m_hDrawDib);
        m_hDrawDib = NULL;
    }
    if (m_pDIB) {
        delete m_pDIB;
        m_pDIB = NULL;
    }
}

BOOL CBitmapFileImage::InitData(
    LPCSTR lpcszFile)
{
    BITMAPFILEHEADER  bmpfh;
    BITMAPINFOHEADER* pDib;
    CFile             cFile;
    INT               nHeaderSize;

    Close();

    //DrawDibOpen initializes the DrawDib library and
    //returns a handle for all DrawDib operations
    if (!(m_hDrawDib = DrawDibOpen())) {
        goto fail;
    }

    //Open and read the Dib file header
    nHeaderSize = sizeof(BITMAPFILEHEADER);

    if (!cFile.Open(lpcszFile, CFile::modeRead | CFile::typeBinary)) {
        goto fail;
    }

    if (!(cFile.Read((void*)&bmpfh, nHeaderSize) == (UINT)nHeaderSize) ||
        !(bmpfh.bfType == *((WORD*)"BM"))) {
        goto failFile;
    }

    m_pDIB = new BYTE[bmpfh.bfSize - nHeaderSize];
    if (!m_pDIB) {
        goto fail;
    }

    cFile.ReadHuge(m_pDIB, bmpfh.bfSize - nHeaderSize);

    pDib = (BITMAPINFOHEADER*)m_pDIB;
    if (pDib->biSizeImage == 0) {
        pDib->biSizeImage = 
            ((((pDib->biWidth * pDib->biBitCount)+31)&~31)>>3)*pDib->biHeight;
    }

    m_sizeImage.cx = pDib->biWidth;
    m_sizeImage.cy = pDib->biHeight;

    cFile.Close();

    return TRUE;
failFile:
    cFile.Close();
fail:
    Close();

    return FALSE;
}

BOOL CBitmapFileImage::DrawImage(
    CDC* pcDC,
    int  x,
    int  y,
    BOOL bForeBackGround)
{
    BITMAPINFOHEADER* pDib;
    CPalette          cPalette, *pOldPalette;

    if (!m_pDIB)
    {
        return FALSE;
    }

    ASSERT(m_hDrawDib != NULL);

    pDib   = (BITMAPINFOHEADER*)m_pDIB;    
    
    CPalette* pPalette = CreatePalette();
    if (pPalette) {
        pOldPalette = pcDC->SelectPalette(&cPalette, bForeBackGround);
    }

    DrawDibRealize(m_hDrawDib, pcDC->GetSafeHdc(), bForeBackGround);

    DrawDibDraw(m_hDrawDib, pcDC->GetSafeHdc(),
        x,
        y, 
        m_sizeImage.cx,
        m_sizeImage.cy,
        (BITMAPINFOHEADER*)m_pDIB,
        (LPVOID)GetBits(),
        0, 
        0, 
        m_sizeImage.cx,
        m_sizeImage.cy,
        DDF_BACKGROUNDPAL);

    if (pPalette) {
        pcDC->SelectPalette(pOldPalette, bForeBackGround);
        delete pPalette;
    }

    return TRUE;
}

LPBYTE CBitmapFileImage::GetBits(void)
{
    BITMAPINFOHEADER* pDib;
    DWORD             dwNumColors, dwColorTableSize;
    WORD              cwBits;

    pDib   = (BITMAPINFOHEADER*)m_pDIB;
    cwBits = pDib->biBitCount;

    dwNumColors = pDib->biSize >= 36 ? dwNumColors = pDib->biClrUsed : 0;
       
    if (!dwNumColors) {
        dwNumColors = cwBits != 24 ? 1L << cwBits : 0;
    }

    dwColorTableSize = dwNumColors * sizeof(RGBQUAD);

    return m_pDIB + pDib->biSize + dwColorTableSize;
}

DWORD CBitmapFileImage::GetColorNum(void)
{
    BITMAPINFOHEADER* pDib;
    DWORD             dwNumColors;
    WORD              cwBits;

    pDib   = (BITMAPINFOHEADER*)m_pDIB;
    cwBits = pDib->biBitCount;

    if (cwBits == 24) {
        return NULL;
    }

    dwNumColors = pDib->biSize >= 36 ? dwNumColors = pDib->biClrUsed : 0;
       
    if (!dwNumColors) {
        dwNumColors = cwBits != 24 ? 1L << cwBits : 0;
    }

    return dwNumColors;
}

CPalette* CBitmapFileImage::CreatePalette(void)
{
    LOGPALETTE* pLogPalette;
    BITMAPINFO* psInfo;
    DWORD       i, dwColorNum;

    dwColorNum = GetColorNum();
    if (!dwColorNum) {
        return NULL;
    }

    psInfo = (BITMAPINFO*)m_pDIB;
    CPalette* pPalette = new CPalette;
    if (!pPalette) {
        return NULL;
    }

    pLogPalette = (LOGPALETTE*)new BYTE[sizeof(LOGPALETTE) + dwColorNum * sizeof(PALETTEENTRY)];
    if (!pLogPalette) {
        delete pPalette;
        return NULL;
    }

    for (i = 0; i < dwColorNum; i++) {
        pLogPalette->palPalEntry[i].peRed   = psInfo->bmiColors[i].rgbRed;
        pLogPalette->palPalEntry[i].peGreen = psInfo->bmiColors[i].rgbGreen;
        pLogPalette->palPalEntry[i].peBlue  = psInfo->bmiColors[i].rgbBlue;
        pLogPalette->palPalEntry[i].peFlags = 0;
    }

    pLogPalette->palVersion    = PALVERSION;
    pLogPalette->palNumEntries = (WORD)dwColorNum;
    pPalette->CreatePalette(pLogPalette);

    delete pLogPalette;

    return pPalette;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\SDK\sdksetup\autorun\source\autorun\image.cpp ===
#include "stdafx.h"
#include "bitmap.h"
#include "image.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

CImage* CreateImage(
    DWORD   dwType, 
    LPCTSTR lpctszImageFile)
{
    CImage* pcImage = NULL;

    switch(dwType) {
    case IMAGE_TYPE_BITMAP:
        {
            CBitmapFileImage* pcBitmap = new CBitmapFileImage;
            if (!pcBitmap && !pcBitmap->InitData(lpctszImageFile)) {
                delete pcBitmap;
                pcBitmap = NULL;
            }
            pcImage = pcBitmap;
        }
        break;
    default:
        ASSERT(FALSE);
        break;
    }

    return pcImage;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\SDK\sdksetup\autorun\source\autorun\image.h ===
#ifndef  __IMAGE_DECLARE__
#define  __IMAGE_DECLARE__

enum IMAGE_TYPE {
    IMAGE_TYPE_NONE   = 0,
    IMAGE_TYPE_BITMAP = 1,
};

class CImage
{
public:
    CImage() : m_fHaveBounding(FALSE) 
        {
            m_rectBounding.SetRectEmpty();
            m_sizeImage = CSize(0, 0);
        };
    virtual ~CImage() {};

public:
    virtual BOOL DrawImage(CDC* pcDC, int x, int y, BOOL bForeBackGround = TRUE) = 0;
    CSize        GetSize(void) const { return m_sizeImage; }
    void         SetBoundingRect(const CRect& rectBounding) 
                    { 
                      m_rectBounding = rectBounding; 
                      m_fHaveBounding = TRUE;
                    }
    void         ClearBoundingRect(void) 
                    { m_fHaveBounding = FALSE; }
protected:
    BOOL  m_fHaveBounding;
    CRect m_rectBounding;
    CSize m_sizeImage;
};

CImage* CreateImage(DWORD dwType, LPCTSTR);

#endif //__IMAGE_DECLARE__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\SDK\sdksetup\autorun\source\autorun\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by autorun.rc
//
#define IDS_ERROR                       1
#define IDS_MISS_INI_FILE               2
#define IDD_AUTORUN_DIALOG              102
#define IDR_MAINFRAME                   128
#define IDB_XBOX                        129
#define IDB_BITMAP1                     130
#define IDI_ICON1                       132
#define IDC_STATIC_README               1006

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        136
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1007
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\SDK\sdksetup\autorun\source\autorun\StdAfx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__235D928D_075D_484D_A2A0_585F6129435A__INCLUDED_)
#define AFX_STDAFX_H__235D928D_075D_484D_A2A0_585F6129435A__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxdtctl.h>		// MFC support for Internet Explorer 4 Common Controls
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT


//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__235D928D_075D_484D_A2A0_585F6129435A__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\SDK\sdksetup\autorun\source\autorun\StdAfx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	autorun.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\SDK\test\include\asm.h ===
// -*- Mode:C++ -*-
//
//      Copyright (c) 1996, Microsoft Corp. All rights reserved. 
//
// $Header: /ast/sdk/lib/alloc.cpp 8     5/02/96 4:43p Rusa $
// $NoKeywords: $
//
// 

#ifndef INC_ASM_H
#define INC_ASM_H

///////////////////////////////////////////////////////////////////////////////
// Class structure (forward declarations)

class AsmInstruction;
class  AsmGenericInstruction;
class  Asm386Instruction;

///////////////////////////////////////////////////////////////////////////////
// Exterior definitions

#ifdef AST_LIBRARY

enum Asm386OpCode {
#define CC_ASM 1
#define _VC_VER_INC
#if CC_VERSION60
#define CC_P5P6ASM 1
#endif
#define DAT(op, dope, num_oprs, osize, byte2, name, ACLS, ASM, template, XX, machine) ASM_O ## op,
#include "386\asmdat.h"
#undef CC_ASM
#undef _VC_VER_INC
#if CC_VERSION60
#undef CC_P5P6ASM
#endif
#undef DAT
};
#include "md.h"
typedef e_asmmode Asm386Mode;

#else AST_LIBRARY

enum Asm386OpCode;
enum Asm386Mode;

#endif AST_LIBRARY

///////////////////////////////////////////////////////////////////////////////
// Nodes

class AsmInstruction: public Object
{
  public:
    enum JumpKind { jkNoJump, jkUncond, jkCond, jkReturn, jkCall, jkUnknown };
    ASTAPI virtual void Disassemble(StringStream& stream)  = 0;
    ASTAPI virtual JumpKind GetJumpKind()                         = 0;
    ASTAPI virtual Symbol * JumpDestination()                     = 0;
  internal:
    AsmInstruction(Byte *codeBytes, int length, SymbolTable *symbolTable) {}
};

class AsmGenericInstruction : public AsmInstruction
{
  public:
    ASTAPI void  Disassemble(StringStream& stream);
    ASTAPI JumpKind GetJumpKind()     { return jkUnknown; }
    ASTAPI Symbol * JumpDestination() { return NULL; }
  internal:
    AsmGenericInstruction(Byte *codeBytes, int length, SymbolTable *symbolTable);
  private:
    Byte *codeBytes;
    int codeLength;
};

class Asm386Instruction : public AsmInstruction
{
  public:
    ASTAPI void Disassemble(StringStream& stream);
    ASTAPI JumpKind GetJumpKind();
    ASTAPI Symbol * JumpDestination();
  internal:
    Asm386Instruction(Byte *codeBytes, int length, SymbolTable *symbolTable);
  private:
    union SizeCC {
        Byte CC;
        Byte Size;
    };
    struct Asm386Operand {
        Asm386Mode mode;
        union {
            Symbol *symbol;
            Byte reg;
        };
        Byte segreg;
        Byte basereg;
        Byte indexreg;
        Byte scaling;
        Byte prefixreg;
        Symbol *prefixSymbol;
        union {
            long displacement;
            long offset;
            long immediate;
        };
    };

    static void DisassembleOperand(const Asm386Operand& operand,
                                   Byte size,
                                   StringStream& stream);
    static void DisassembleFloatOperand(const Asm386Operand& operand,
                                        Byte size,
                                        StringStream& stream);
    Asm386OpCode asmOpCode;
    SizeCC sizeCC;
    int operandCount;
    Asm386Operand operands[ 3 ];
};

#endif // INC_ASM_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\SDK\test\include\alloc.h ===
// -*- Mode:C++ -*-
//
//      Copyright (c) 1996, Microsoft Corp. All rights reserved. 
//
// $Header: /ast/sdk/lib/alloc.h 9     5/09/96 1:25p Erikruf $
// $NoKeywords: $
//
// 


#ifndef INC_ALLOC_H 
#define INC_ALLOC_H

//
// Forward declarations
//

///////////////////////////////////////////////////////////////////////////////
// Class structure (forward declarations)
//
//   hit ^X^E at end of this line (cxx-replace-class-hierarchy)

class Allocator;
class   HeapAllocator;
class   ArenaAllocator;
class     UnalignedArenaAllocator;
class WithArena;
class WithOwnArena;
class WithOwnUnalignedArena;

////END////

//
// Allocator (abstract class)
//
class Allocator: public Object
{
  public: 
    ASTAPI virtual ~Allocator() { }

#ifndef _CRTDBG_MAP_ALLOC
#  define ALLOC_FORMALS(KIND,FILE,LINE)
#  define ALLOC_ACTUALS(KIND,FILE,LINE)
#  define ALLOC_OVERRIDE(PARENT) \
    ASTAPI virtual void * Alloc(size_t size)
#else
#  define ALLOC_FORMALS(KIND,FILE,LINE) , int KIND, const char *FILE, int LINE
#  define ALLOC_ACTUALS(KIND,FILE,LINE) , KIND, FILE, LINE
#  define ALLOC_OVERRIDE(PARENT) \
    using PARENT::Alloc;  /* so as not to break overloading */  \
    ASTAPI virtual void * Alloc(size_t size ALLOC_FORMALS(kind,file,line))

        // this would work better as a #define, but...
    ASTAPI inline void *  Alloc(size_t size) 
      { return Alloc(size, _NORMAL_BLOCK, __FILE__, __LINE__); }
#endif // _CRTDBG_MAP_ALLOC

    ASTAPI virtual void * Alloc(size_t size ALLOC_FORMALS(kind,file,line)) = 0;
    ASTAPI virtual void   Dealloc(void *obj) = 0;
    ASTAPI static void    Initialize();
    ASTAPI static void    Finalize();
    ASTAPI static HeapAllocator *heapAllocator;
    ASTAPI static HeapAllocator *GetHeapAllocator();
  protected:
    ASTAPI Allocator(): arenaSpace(0) { }
  internal:
    size_t arenaSpace;          // total space in use by child arenas
};

// Teach the global "new" operator how to allocate using Allocators
// We need this because we may want to allocate an array of objects
// using an Allocator, and (until VC decides to support operator new[] 
// overloading on a per-class basis) invokes the (*&%]&$#* global 
// allocator!
//
// Please note that objects allocated using "new" with an Allocator
// placement operand may not be deallocatable using "delete".  (As of
// this writing, delete happens to work for HeapAllocator, but this
// may change).
//
// REVIEW: export this?
ASTAPI void * operator new(size_t size, Allocator *baseAllocator
                           ALLOC_FORMALS(kind,file,line));
#ifdef _CRTDBG_MAP_ALLOC
ASTAPI inline void * operator new(size_t size, Allocator *baseAllocator)
{ return ::operator new(size, baseAllocator, _NORMAL_BLOCK, __FILE__, __LINE__); }
#endif

//
// Direct delegation to CRT malloc
//
class HeapAllocator: public Allocator
{
  public: // client entry points
    ASTAPI HeapAllocator(): 
        numAllocs(0), numDeallocs(0), numAllocBytes(0) 
      { }
    ASTAPI virtual ~HeapAllocator();
    // overrides
    ALLOC_OVERRIDE(Allocator);
    ASTAPI virtual void   Dealloc(void *obj);
    ASTAPI virtual void   DumpMethod(DumpContext *dc);
  private:
    int numAllocs, numDeallocs, numAllocBytes;
};


//
// Allocation in arenas
//

#define AST_ARENA_GRANULARITY 4            // must be power of 2
#define AST_ARENA_DEFAULT_BLOCKSIZE (16384-16)  // must be multiple of granularity

class ArenaAllocator: public Allocator
{
  public:
    ASTAPI ArenaAllocator(
        Allocator *baseAllocator = NULL, 
        size_t blockSize         = AST_ARENA_DEFAULT_BLOCKSIZE
      );
    ASTAPI virtual ~ArenaAllocator();
    ASTAPI void    Reset(void);
    ASTAPI void    SetBlockSize(size_t size);
    // overrides
    ALLOC_OVERRIDE(Allocator);
    ASTAPI virtual void   Dealloc(void *obj);
    ASTAPI virtual void   DumpMethod(DumpContext *dc);
  protected:
    inline size_t RoundUp(size_t);
    void *        RawAlloc(size_t);
    int numAllocs, numDeallocs, numAllocBytes;
    int numFragBytesItem, numFragBytesBlock;
  private: 
    Allocator *baseAllocator;
    size_t blockSize;
    struct Block;
    struct Block *rootBlock;
    Byte *freeByte;
    size_t bytesRemaining;

    size_t totalSize;           // of all allocated blocks in arena
};


// Version of ArenaAllocator to use if you don't care about 
// the alignment of what new/Alloc returns.
class UnalignedArenaAllocator : public ArenaAllocator
{
  public:
    ASTAPI UnalignedArenaAllocator(
        Allocator *baseAllocator = NULL, 
        size_t blockSize         = AST_ARENA_DEFAULT_BLOCKSIZE
      ): 
        ArenaAllocator(baseAllocator, blockSize) { }
    // overrides
    ALLOC_OVERRIDE(ArenaAllocator);
};    

// Mixin for objects that want to use an existing ArenaAllocator
//
// Subclass constructors must invoke the WithArena constructor on the
// existing ArenaAllocator.
//
// Subclass gains protected members
// - pAllocator holds the Allocator
// Subclass gains public members
// - Alloc(size_t size) allocates using pAllocator

class WithArena
{
  public:    
    ASTAPI void *Alloc(size_t size)
      { return pAllocator->Alloc(size); }

  protected:
    ASTAPI WithArena(ArenaAllocator *pAllocator):
        pAllocator(pAllocator) { }
    ASTAPI ~WithArena() { }
    ArenaAllocator *pAllocator;
};


// Mixin for objects that want to create a new ArenaAllocator on creation,
// and free it on destruction
//
// Subclass constructors must invoke the WithOwnArena constructor on
// the desired base Allocator and block size.  If not specified, these
// default to the default base/size for arena Allocators as specified in
// class ArenaAllocator.
//
// Subclass gains protected members
// - pAllocator holds the Allocator
// Subclass gains public members
// - Alloc(size_t size) allocates using pAllocator

class WithOwnArena
{
  public:
    ASTAPI void *Alloc(size_t size)
      { return pAllocator->Alloc(size); }
  protected: 
    ASTAPI WithOwnArena(
        Allocator *baseAllocator = NULL,
        size_t blockSize         = AST_ARENA_DEFAULT_BLOCKSIZE
      ): 
        myAllocator(baseAllocator, blockSize),
        pAllocator(&myAllocator) 
    { }
    ASTAPI ~WithOwnArena() { }
    ArenaAllocator *pAllocator;
  private: 
    ArenaAllocator myAllocator;
};    


class WithOwnUnalignedArena
{
  public:
    ASTAPI void *Alloc(size_t size) 
      { return pAllocator->Alloc(size); }
  protected: 
    ASTAPI WithOwnUnalignedArena(
        Allocator *baseAllocator = NULL,
        size_t blockSize         = AST_ARENA_DEFAULT_BLOCKSIZE
      ): 
        myAllocator(baseAllocator, blockSize),
        pAllocator(&myAllocator) 
      { }
    ASTAPI ~WithOwnUnalignedArena() { }
    UnalignedArenaAllocator *pAllocator;
  private: 
    UnalignedArenaAllocator myAllocator;
};    

#endif // INC_ALLOC_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\SDK\test\include\astdriver.h ===
// -*- Mode:C++ -*-
//
//      Copyright (c) 1996, Microsoft Corp. All rights reserved. 
//
// $Header: /ast/driver\60/astdriver.h 1     8/27/98 4:30p Lindaog $
// $NoKeywords: $
//
 
// Main include file for Ast library.

#ifndef INC_ASTDRIVER_H 
#define INC_ASTDRIVER_H

// We assume that ast.h is already included by any file that includes this one.

// Configuration macros set by makefile
//
// AST_DRIVER                   True for Driver, false for client
// AST_DRIVER_VERSION           4, 5, or 6

#ifndef AST_DRIVER_VERSION
#  define AST_DRIVER_VERSION 6
#elif AST_DRIVER_VERSION != 6
#  error "wrong driver being included"
#endif

#ifdef AST_DRIVER
#  define AST_DRIVER_API __declspec(dllexport)
#else
#  define AST_DRIVER_API __declspec(dllimport)
#endif // AST_LIBRARY

#ifndef ASTDRIVERAPI
#define ASTDRIVERAPI AST_DRIVER_API
#endif

#ifndef ASTDRIVERCALL
#define ASTDRIVERCALL __stdcall
#endif

#endif // INC_ASTDRIVER_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\SDK\test\include\ast.h ===
// -*- Mode:C++ -*-
//
//      Copyright (c) 1996-1998, Microsoft Corp. All rights reserved. 
//
// $Header: /ast/sdk/lib/ast.h 22    5/16/96 10:27a Erikruf2 $
// $NoKeywords: $
//
 
// Main include file for Ast library.

#ifndef INC_AST_H 
#define INC_AST_H

// Configuration macros set by makefile
//
// AST_LIBRARY                  True for library, false for client
// AST_STATIC                   True for static library/.LIB client,
//                              False for dynamic library/.DLL client;
// AST_USE_NAMESPACE            Wraps decls in namespace Ast { }
// AST_HIDE_NON_ESSENTIAL_DEFS  Exports fewer names to client.
//                              NOP if AST_LIBRARY is defined

#ifdef AST_STATIC
#  define AST_IMPORT_EXPORT
#else
#  ifdef AST_LIBRARY
#    define AST_IMPORT_EXPORT __declspec(dllexport)
#  else
#    define AST_IMPORT_EXPORT __declspec(dllimport)
#  endif // AST_LIBRARY
#endif // AST_STATIC

#ifndef ASTAPI
#define ASTAPI AST_IMPORT_EXPORT
#endif
#ifndef AST_TEMPLATE_API
#define AST_TEMPLATE_API
#endif

#ifndef ASTCALL
#define ASTCALL  __stdcall
#endif

#ifdef AST_USE_NAMESPACE
#  define BEGIN_AST_NAMESPACE namespace Ast {
#  define END_AST_NAMESPACE }
#  define AST_NAMESPACE_IZE(foo) Ast::##foo
#else
#  define BEGIN_AST_NAMESPACE
#  define END_AST_NAMESPACE
#  define AST_NAMESPACE_IZE(foo) foo
#endif 

#ifdef AST_LIBRARY
#  undef AST_HIDE_NON_ESSENTIAL_DEFS
#  define AST_INCLUDE_NON_ESSENTIAL
#endif // AST_LIBRARY

#ifdef AST_HIDE_NON_ESSENTIAL_DEFS
#  undef AST_INCLUDE_NON_ESSENTIAL
#else
#  define AST_INCLUDE_NON_ESSENTIAL
#endif

// Visibility class "internal:" is used in the implementation
// for symbols that are internal to the library.
// Client should not use "internal" symbols.
#define internal public

//
// System includes
//
#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#ifdef AST_LIBRARY              // implementation needs these; client doesn't
#  define WIN32_EXTRA_LEAN
#  define WIN32_LEAN_AND_MEAN
#  include <windows.h> 
#  include <malloc.h>
#  include <string.h>
#  include <io.h>
#  include <errno.h>
#  include <typeinfo.h>
#endif 

#ifdef _CRTDBG_MAP_ALLOC
   // confusion occurs if client wants malloc
   // but crtdbg.h is included first, thus...
#  include <malloc.h>
#  include <crtdbg.h>
#endif

#ifndef AST_LIBRARY             
// Clients don't need complete definitions.
  struct PDB;
  struct TPI;
#endif

//
// Library includes
//
BEGIN_AST_NAMESPACE

// Basic types, macros, utilities
#include "base.h"
#include "object.h"
#include "stream.h"
#include "alloc.h"
#include "debug.h"
#include "version.h"

// IL reading utilities
#ifdef AST_LIBRARY
#  include "ilutil.h" 
#else
#endif
#include "ilpath.h"

// AST data structures known to IL utils
#include "literal.h"
#include "attrib.h"
#ifdef AST_LIBRARY
#include "typeio.h"
#else
class TypeIO;  // all clients need is a forward declaration
#endif


// AST data structures
#include "source.h"
#include "type.h"
#include "symbol.h"
#include "asm.h"
#include "node.h"
#include "module.h"
#include "util.h"
#include "astlib.h"

#ifdef AST_LIBRARY
#include "walker.h"
#include "stats.h"
#endif

END_AST_NAMESPACE
 
#endif // INC_AST_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\SDK\test\win32.cpp ===
#define _WIN32_WINNT        0x0403
#define WIN32
#define NT

#define IN  __declspec("[in]")
#define OUT __declspec("[out]")

#include <windows.h>
#include <ole2.h>
#include <shellapi.h>
#include <oleauto.h>
#include <oaidl.h>
#include <objbase.h>
#include <objidl.h>
#include <ocidl.h>
#include <olectl.h>
#include <urlmon.h>
#include <shlobj.h>
#include <gl\gl.h>
#include <gl\glu.h>
#include <winver.h>

void main(void)
{
    PVOID pv;

    //  pv = (PVOID)GetCurrentThread;
    pv = (PVOID)GetCurrentThreadId;

    // user32.dll
    pv = (PVOID)ActivateKeyboardLayout;
    pv = (PVOID)AdjustWindowRect;
    pv = (PVOID)AdjustWindowRectEx;
    //  pv = (PVOID)AlignRects;
    //  pv = (PVOID)AllowSetForegroundWindow;
    //  pv = (PVOID)AnimateWindow;
    pv = (PVOID)AnyPopup;
    pv = (PVOID)AppendMenuA;
    pv = (PVOID)AppendMenuW;
    pv = (PVOID)ArrangeIconicWindows;
    pv = (PVOID)AttachThreadInput;
    pv = (PVOID)BeginDeferWindowPos;
    pv = (PVOID)BeginPaint;
    //  pv = (PVOID)BlockInput;
    pv = (PVOID)BringWindowToTop;
    pv = (PVOID)BroadcastSystemMessage;
    pv = (PVOID)BroadcastSystemMessageA;
    pv = (PVOID)BroadcastSystemMessageW;
    pv = (PVOID)CallMsgFilter;
    pv = (PVOID)CallMsgFilterA;
    pv = (PVOID)CallMsgFilterW;
    pv = (PVOID)CallNextHookEx;
    pv = (PVOID)CallWindowProcA;
    pv = (PVOID)CallWindowProcW;
    //  pv = (PVOID)CascadeChildWindows;
    pv = (PVOID)CascadeWindows;
    pv = (PVOID)ChangeClipboardChain;
    pv = (PVOID)ChangeDisplaySettingsA;
    pv = (PVOID)ChangeDisplaySettingsExA;
    pv = (PVOID)ChangeDisplaySettingsExW;
    pv = (PVOID)ChangeDisplaySettingsW;
    pv = (PVOID)ChangeMenuA;
    pv = (PVOID)ChangeMenuW;
    pv = (PVOID)CharLowerA;
    pv = (PVOID)CharLowerBuffA;
    pv = (PVOID)CharLowerBuffW;
    pv = (PVOID)CharLowerW;
    pv = (PVOID)CharNextA;
    pv = (PVOID)CharNextExA;
    pv = (PVOID)CharNextW;
    pv = (PVOID)CharPrevA;
    pv = (PVOID)CharPrevExA;
    pv = (PVOID)CharPrevW;
    pv = (PVOID)CharToOemA;
    pv = (PVOID)CharToOemBuffA;
    pv = (PVOID)CharToOemBuffW;
    pv = (PVOID)CharToOemW;
    pv = (PVOID)CharUpperA;
    pv = (PVOID)CharUpperBuffA;
    pv = (PVOID)CharUpperBuffW;
    pv = (PVOID)CharUpperW;
    pv = (PVOID)CheckDlgButton;
    pv = (PVOID)CheckMenuItem;
    pv = (PVOID)CheckMenuRadioItem;
    pv = (PVOID)CheckRadioButton;
    pv = (PVOID)ChildWindowFromPoint;
    pv = (PVOID)ChildWindowFromPointEx;
    //  pv = (PVOID)CliImmSetHotKey;
    //  pv = (PVOID)ClientThreadSetup;
    pv = (PVOID)ClientToScreen;
    pv = (PVOID)ClipCursor;
    pv = (PVOID)CloseClipboard;
    pv = (PVOID)CloseDesktop;
    pv = (PVOID)CloseWindow;
    pv = (PVOID)CloseWindowStation;
    pv = (PVOID)CopyAcceleratorTableA;
    pv = (PVOID)CopyAcceleratorTableW;
    pv = (PVOID)CopyIcon;
    pv = (PVOID)CopyImage;
    pv = (PVOID)CopyRect;
    pv = (PVOID)CountClipboardFormats;
    pv = (PVOID)CreateAcceleratorTableA;
    pv = (PVOID)CreateAcceleratorTableW;
    pv = (PVOID)CreateCaret;
    pv = (PVOID)CreateCursor;
    pv = (PVOID)CreateDesktopA;
    pv = (PVOID)CreateDesktopW;
    pv = (PVOID)CreateDialogIndirectParamA;
    //  pv = (PVOID)CreateDialogIndirectParamAorW;
    pv = (PVOID)CreateDialogIndirectParamW;
    pv = (PVOID)CreateDialogParamA;
    pv = (PVOID)CreateDialogParamW;
    pv = (PVOID)CreateIcon;
    pv = (PVOID)CreateIconFromResource;
    pv = (PVOID)CreateIconFromResourceEx;
    pv = (PVOID)CreateIconIndirect;
    pv = (PVOID)CreateMDIWindowA;
    pv = (PVOID)CreateMDIWindowW;
    pv = (PVOID)CreateMenu;
    pv = (PVOID)CreatePopupMenu;
    pv = (PVOID)CreateWindowExA;
    pv = (PVOID)CreateWindowExW;
    pv = (PVOID)CreateWindowStationA;
    pv = (PVOID)CreateWindowStationW;
    //  pv = (PVOID)CtxInitUser32;
    pv = (PVOID)DdeAbandonTransaction;
    pv = (PVOID)DdeAccessData;
    pv = (PVOID)DdeAddData;
    pv = (PVOID)DdeClientTransaction;
    pv = (PVOID)DdeCmpStringHandles;
    pv = (PVOID)DdeConnect;
    pv = (PVOID)DdeConnectList;
    pv = (PVOID)DdeCreateDataHandle;
    pv = (PVOID)DdeCreateStringHandleA;
    pv = (PVOID)DdeCreateStringHandleW;
    pv = (PVOID)DdeDisconnect;
    pv = (PVOID)DdeDisconnectList;
    pv = (PVOID)DdeEnableCallback;
    pv = (PVOID)DdeFreeDataHandle;
    pv = (PVOID)DdeFreeStringHandle;
    pv = (PVOID)DdeGetData;
    pv = (PVOID)DdeGetLastError;
    //  pv = (PVOID)DdeGetQualityOfService;
    pv = (PVOID)DdeImpersonateClient;
    //  pv = (PVOID)DdeInitializeA;
    //  pv = (PVOID)DdeInitializeW;
    pv = (PVOID)DdeKeepStringHandle;
    pv = (PVOID)DdeNameService;
    pv = (PVOID)DdePostAdvise;
    pv = (PVOID)DdeQueryConvInfo;
    pv = (PVOID)DdeQueryNextServer;
    pv = (PVOID)DdeQueryStringA;
    pv = (PVOID)DdeQueryStringW;
    pv = (PVOID)DdeReconnect;
    pv = (PVOID)DdeSetQualityOfService;
    pv = (PVOID)DdeSetUserHandle;
    pv = (PVOID)DdeUnaccessData;
    pv = (PVOID)DdeUninitialize;
    pv = (PVOID)DefDlgProcA;
    pv = (PVOID)DefDlgProcW;
    pv = (PVOID)DefFrameProcA;
    pv = (PVOID)DefFrameProcW;
    pv = (PVOID)DefMDIChildProcA;
    pv = (PVOID)DefMDIChildProcW;
    pv = (PVOID)DefWindowProcA;
    pv = (PVOID)DefWindowProcW;
    pv = (PVOID)DeferWindowPos;
    pv = (PVOID)DeleteMenu;
    //  pv = (PVOID)DeregisterShellHookWindow;
    pv = (PVOID)DestroyAcceleratorTable;
    pv = (PVOID)DestroyCaret;
    pv = (PVOID)DestroyCursor;
    pv = (PVOID)DestroyIcon;
    pv = (PVOID)DestroyMenu;
    pv = (PVOID)DestroyWindow;
    //  pv = (PVOID)DeviceEventWorker;
    pv = (PVOID)DialogBoxIndirectParamA;
    //  pv = (PVOID)DialogBoxIndirectParamAorW;
    pv = (PVOID)DialogBoxIndirectParamW;
    pv = (PVOID)DialogBoxParamA;
    pv = (PVOID)DialogBoxParamW;
    pv = (PVOID)DispatchMessageA;
    pv = (PVOID)DispatchMessageW;
    pv = (PVOID)DlgDirListA;
    pv = (PVOID)DlgDirListComboBoxA;
    pv = (PVOID)DlgDirListComboBoxW;
    pv = (PVOID)DlgDirListW;
    pv = (PVOID)DlgDirSelectComboBoxExA;
    pv = (PVOID)DlgDirSelectComboBoxExW;
    pv = (PVOID)DlgDirSelectExA;
    pv = (PVOID)DlgDirSelectExW;
    pv = (PVOID)DragDetect;
    pv = (PVOID)DragObject;
    pv = (PVOID)DrawAnimatedRects;
    pv = (PVOID)DrawCaption;
    //  pv = (PVOID)DrawCaptionTempA;
    //  pv = (PVOID)DrawCaptionTempW;
    pv = (PVOID)DrawEdge;
    pv = (PVOID)DrawFocusRect;
    //  pv = (PVOID)DrawFrame;
    pv = (PVOID)DrawFrameControl;
    pv = (PVOID)DrawIcon;
    pv = (PVOID)DrawIconEx;
    pv = (PVOID)DrawMenuBar;
    //  pv = (PVOID)DrawMenuBarTemp;
    pv = (PVOID)DrawStateA;
    pv = (PVOID)DrawStateW;
    pv = (PVOID)DrawTextA;
    pv = (PVOID)DrawTextExA;
    pv = (PVOID)DrawTextExW;
    pv = (PVOID)DrawTextW;
    //  pv = (PVOID)EditWndProc;
    pv = (PVOID)EmptyClipboard;
    pv = (PVOID)EnableMenuItem;
    pv = (PVOID)EnableScrollBar;
    pv = (PVOID)EnableWindow;
    pv = (PVOID)EndDeferWindowPos;
    pv = (PVOID)EndDialog;
    //  pv = (PVOID)EndMenu;
    pv = (PVOID)EndPaint;
    //  pv = (PVOID)EndTask;
    pv = (PVOID)EnumChildWindows;
    pv = (PVOID)EnumClipboardFormats;
    pv = (PVOID)EnumDesktopWindows;
    pv = (PVOID)EnumDesktopsA;
    pv = (PVOID)EnumDesktopsW;
    //  pv = (PVOID)EnumDisplayDevicesA;
    //  pv = (PVOID)EnumDisplayDevicesW;
    //  pv = (PVOID)EnumDisplayMonitors;
    pv = (PVOID)EnumDisplaySettingsA;
    //  pv = (PVOID)EnumDisplaySettingsExA;
    //  pv = (PVOID)EnumDisplaySettingsExW;
    pv = (PVOID)EnumDisplaySettingsW;
    pv = (PVOID)EnumPropsA;
    pv = (PVOID)EnumPropsExA;
    pv = (PVOID)EnumPropsExW;
    pv = (PVOID)EnumPropsW;
    pv = (PVOID)EnumThreadWindows;
    pv = (PVOID)EnumWindowStationsA;
    pv = (PVOID)EnumWindowStationsW;
    pv = (PVOID)EnumWindows;
    pv = (PVOID)EqualRect;
    pv = (PVOID)ExcludeUpdateRgn;
    pv = (PVOID)ExitWindowsEx;
    pv = (PVOID)FillRect;
    pv = (PVOID)FindWindowA;
    pv = (PVOID)FindWindowExA;
    pv = (PVOID)FindWindowExW;
    pv = (PVOID)FindWindowW;
    pv = (PVOID)FlashWindow;
    //  pv = (PVOID)FlashWindowEx;
    pv = (PVOID)FrameRect;
    pv = (PVOID)FreeDDElParam;
    pv = (PVOID)GetActiveWindow;
    //  pv = (PVOID)GetAltTabInfo;
    //  pv = (PVOID)GetAltTabInfoA;
    //  pv = (PVOID)GetAltTabInfoW;
    //  pv = (PVOID)GetAncestor;
    //  pv = (PVOID)GetAppCompatFlags;
    //  pv = (PVOID)GetAppCompatFlags2;
    pv = (PVOID)GetAsyncKeyState;
    pv = (PVOID)GetCapture;
    pv = (PVOID)GetCaretBlinkTime;
    pv = (PVOID)GetCaretPos;
    pv = (PVOID)GetClassInfoA;
    pv = (PVOID)GetClassInfoExA;
    pv = (PVOID)GetClassInfoExW;
    pv = (PVOID)GetClassInfoW;
    pv = (PVOID)GetClassLongA;
    pv = (PVOID)GetClassLongW;
    pv = (PVOID)GetClassNameA;
    pv = (PVOID)GetClassNameW;
    pv = (PVOID)GetClassWord;
    pv = (PVOID)GetClientRect;
    pv = (PVOID)GetClipCursor;
    pv = (PVOID)GetClipboardData;
    pv = (PVOID)GetClipboardFormatNameA;
    pv = (PVOID)GetClipboardFormatNameW;
    pv = (PVOID)GetClipboardOwner;
    //  pv = (PVOID)GetClipboardSequenceNumber;
    pv = (PVOID)GetClipboardViewer;
    //  pv = (PVOID)GetComboBoxInfo;
    pv = (PVOID)GetCursor;
    //  pv = (PVOID)GetCursorFrameInfo;
    //  pv = (PVOID)GetCursorInfo;
    pv = (PVOID)GetCursorPos;
    pv = (PVOID)GetDC;
    pv = (PVOID)GetDCEx;
    pv = (PVOID)GetDesktopWindow;
    pv = (PVOID)GetDialogBaseUnits;
    pv = (PVOID)GetDlgCtrlID;
    pv = (PVOID)GetDlgItem;
    pv = (PVOID)GetDlgItemInt;
    pv = (PVOID)GetDlgItemTextA;
    pv = (PVOID)GetDlgItemTextW;
    pv = (PVOID)GetDoubleClickTime;
    pv = (PVOID)GetFocus;
    pv = (PVOID)GetForegroundWindow;
    //  pv = (PVOID)GetGUIThreadInfo;
    //  pv = (PVOID)GetGuiResources;
    pv = (PVOID)GetIconInfo;
    //  pv = (PVOID)GetInputDesktop;
    pv = (PVOID)GetInputState;
    //  pv = (PVOID)GetInternalWindowPos;
    pv = (PVOID)GetKBCodePage;
    pv = (PVOID)GetKeyNameTextA;
    pv = (PVOID)GetKeyNameTextW;
    pv = (PVOID)GetKeyState;
    pv = (PVOID)GetKeyboardLayout;
    pv = (PVOID)GetKeyboardLayoutList;
    pv = (PVOID)GetKeyboardLayoutNameA;
    pv = (PVOID)GetKeyboardLayoutNameW;
    pv = (PVOID)GetKeyboardState;
    pv = (PVOID)GetKeyboardType;
    pv = (PVOID)GetLastActivePopup;
    //  pv = (PVOID)GetLastInputInfo;
    //  pv = (PVOID)GetListBoxInfo;
    pv = (PVOID)GetMenu;
    //  pv = (PVOID)GetMenuBarInfo;
    pv = (PVOID)GetMenuCheckMarkDimensions;
    pv = (PVOID)GetMenuContextHelpId;
    pv = (PVOID)GetMenuDefaultItem;
    //  pv = (PVOID)GetMenuInfo;
    pv = (PVOID)GetMenuItemCount;
    pv = (PVOID)GetMenuItemID;
    pv = (PVOID)GetMenuItemInfoA;
    pv = (PVOID)GetMenuItemInfoW;
    pv = (PVOID)GetMenuItemRect;
    pv = (PVOID)GetMenuState;
    pv = (PVOID)GetMenuStringA;
    pv = (PVOID)GetMenuStringW;
    pv = (PVOID)GetMessageA;
    pv = (PVOID)GetMessageExtraInfo;
    pv = (PVOID)GetMessagePos;
    pv = (PVOID)GetMessageTime;
    pv = (PVOID)GetMessageW;
    //  pv = (PVOID)GetMonitorInfoA;
    //  pv = (PVOID)GetMonitorInfoW;
    //  pv = (PVOID)GetMouseMovePointsEx;
    pv = (PVOID)GetNextDlgGroupItem;
    pv = (PVOID)GetNextDlgTabItem;
    pv = (PVOID)GetOpenClipboardWindow;
    pv = (PVOID)GetParent;
    pv = (PVOID)GetPriorityClipboardFormat;
    //  pv = (PVOID)GetProcessDefaultLayout;
    pv = (PVOID)GetProcessWindowStation;
    //  pv = (PVOID)GetProgmanWindow;
    pv = (PVOID)GetPropA;
    pv = (PVOID)GetPropW;
    pv = (PVOID)GetQueueStatus;
    //  pv = (PVOID)GetScrollBarInfo;
    pv = (PVOID)GetScrollInfo;
    pv = (PVOID)GetScrollPos;
    pv = (PVOID)GetScrollRange;
    //  pv = (PVOID)GetShellWindow;
    pv = (PVOID)GetSubMenu;
    pv = (PVOID)GetSysColor;
    pv = (PVOID)GetSysColorBrush;
    pv = (PVOID)GetSystemMenu;
    pv = (PVOID)GetSystemMetrics;
    pv = (PVOID)GetTabbedTextExtentA;
    pv = (PVOID)GetTabbedTextExtentW;
    //  pv = (PVOID)GetTaskmanWindow;
    pv = (PVOID)GetThreadDesktop;
    //  pv = (PVOID)GetTitleBarInfo;
    pv = (PVOID)GetTopWindow;
    pv = (PVOID)GetUpdateRect;
    pv = (PVOID)GetUpdateRgn;
    pv = (PVOID)GetUserObjectInformationA;
    pv = (PVOID)GetUserObjectInformationW;
    pv = (PVOID)GetUserObjectSecurity;
    //  pv = (PVOID)GetWinStationInfo;
    pv = (PVOID)GetWindow;
    pv = (PVOID)GetWindowContextHelpId;
    pv = (PVOID)GetWindowDC;
    //  pv = (PVOID)GetWindowInfo;
    pv = (PVOID)GetWindowLongA;
    pv = (PVOID)GetWindowLongW;
    //  pv = (PVOID)GetWindowModuleFileName;
    //  pv = (PVOID)GetWindowModuleFileNameA;
    //  pv = (PVOID)GetWindowModuleFileNameW;
    pv = (PVOID)GetWindowPlacement;
    pv = (PVOID)GetWindowRect;
    pv = (PVOID)GetWindowRgn;
    pv = (PVOID)GetWindowTextA;
    pv = (PVOID)GetWindowTextLengthA;
    pv = (PVOID)GetWindowTextLengthW;
    pv = (PVOID)GetWindowTextW;
    pv = (PVOID)GetWindowThreadProcessId;
    pv = (PVOID)GetWindowWord;
    pv = (PVOID)GrayStringA;
    pv = (PVOID)GrayStringW;
    pv = (PVOID)HideCaret;
    pv = (PVOID)HiliteMenuItem;
    //  pv = (PVOID)IMPGetIMEA;
    //  pv = (PVOID)IMPGetIMEW;
    //  pv = (PVOID)IMPQueryIMEA;
    //  pv = (PVOID)IMPQueryIMEW;
    //  pv = (PVOID)IMPSetIMEA;
    //  pv = (PVOID)IMPSetIMEW;
    pv = (PVOID)ImpersonateDdeClientWindow;
    pv = (PVOID)InSendMessage;
    //  pv = (PVOID)InSendMessageEx;
    pv = (PVOID)InflateRect;
    //  pv = (PVOID)InitializeLpkHooks;
    //  pv = (PVOID)InitializeWin32EntryTable;
    pv = (PVOID)InsertMenuA;
    pv = (PVOID)InsertMenuItemA;
    pv = (PVOID)InsertMenuItemW;
    pv = (PVOID)InsertMenuW;
    //  pv = (PVOID)InternalGetWindowText;
    pv = (PVOID)IntersectRect;
    pv = (PVOID)InvalidateRect;
    pv = (PVOID)InvalidateRgn;
    pv = (PVOID)InvertRect;
    pv = (PVOID)IsCharAlphaA;
    pv = (PVOID)IsCharAlphaNumericA;
    pv = (PVOID)IsCharAlphaNumericW;
    pv = (PVOID)IsCharAlphaW;
    pv = (PVOID)IsCharLowerA;
    pv = (PVOID)IsCharLowerW;
    pv = (PVOID)IsCharUpperA;
    pv = (PVOID)IsCharUpperW;
    pv = (PVOID)IsChild;
    pv = (PVOID)IsClipboardFormatAvailable;
    pv = (PVOID)IsDialogMessage;
    pv = (PVOID)IsDialogMessageA;
    pv = (PVOID)IsDialogMessageW;
    pv = (PVOID)IsDlgButtonChecked;
    //  pv = (PVOID)IsHungAppWindow;
    pv = (PVOID)IsIconic;
    pv = (PVOID)IsMenu;
    pv = (PVOID)IsRectEmpty;
    pv = (PVOID)IsWindow;
    pv = (PVOID)IsWindowEnabled;
    pv = (PVOID)IsWindowUnicode;
    pv = (PVOID)IsWindowVisible;
    pv = (PVOID)IsZoomed;
    //  pv = (PVOID)KillSystemTimer;
    pv = (PVOID)KillTimer;
    pv = (PVOID)LoadAcceleratorsA;
    pv = (PVOID)LoadAcceleratorsW;
    pv = (PVOID)LoadBitmapA;
    pv = (PVOID)LoadBitmapW;
    pv = (PVOID)LoadCursorA;
    pv = (PVOID)LoadCursorFromFileA;
    pv = (PVOID)LoadCursorFromFileW;
    pv = (PVOID)LoadCursorW;
    pv = (PVOID)LoadIconA;
    pv = (PVOID)LoadIconW;
    pv = (PVOID)LoadImageA;
    pv = (PVOID)LoadImageW;
    pv = (PVOID)LoadKeyboardLayoutA;
    //  pv = (PVOID)LoadKeyboardLayoutEx;
    pv = (PVOID)LoadKeyboardLayoutW;
    //  pv = (PVOID)LoadLocalFonts;
    pv = (PVOID)LoadMenuA;
    pv = (PVOID)LoadMenuIndirectA;
    pv = (PVOID)LoadMenuIndirectW;
    pv = (PVOID)LoadMenuW;
    //  pv = (PVOID)LoadRemoteFonts;
    pv = (PVOID)LoadStringA;
    pv = (PVOID)LoadStringW;
    //  pv = (PVOID)LockSetForegroundWindow;
    //  pv = (PVOID)LockWindowStation;
    pv = (PVOID)LockWindowUpdate;
    //  pv = (PVOID)LockWorkStation;
    pv = (PVOID)LookupIconIdFromDirectory;
    pv = (PVOID)LookupIconIdFromDirectoryEx;
    //  pv = (PVOID)MBToWCSEx;
    //  pv = (PVOID)MB_GetString;
    pv = (PVOID)MapDialogRect;
    pv = (PVOID)MapVirtualKeyA;
    pv = (PVOID)MapVirtualKeyExA;
    pv = (PVOID)MapVirtualKeyExW;
    pv = (PVOID)MapVirtualKeyW;
    pv = (PVOID)MapWindowPoints;
    pv = (PVOID)MenuItemFromPoint;
    //  pv = (PVOID)MenuWindowProcA;
    //  pv = (PVOID)MenuWindowProcW;
    pv = (PVOID)MessageBeep;
    pv = (PVOID)MessageBoxA;
    pv = (PVOID)MessageBoxExA;
    pv = (PVOID)MessageBoxExW;
    pv = (PVOID)MessageBoxIndirectA;
    pv = (PVOID)MessageBoxIndirectW;
    pv = (PVOID)MessageBoxW;
    pv = (PVOID)ModifyMenuA;
    pv = (PVOID)ModifyMenuW;
    //  pv = (PVOID)MonitorFromPoint;
    //  pv = (PVOID)MonitorFromRect;
    //  pv = (PVOID)MonitorFromWindow;
    pv = (PVOID)MoveWindow;
    pv = (PVOID)MsgWaitForMultipleObjects;
    pv = (PVOID)MsgWaitForMultipleObjectsEx;
    //  pv = (PVOID)NotifyWinEvent;
    pv = (PVOID)OemKeyScan;
    pv = (PVOID)OemToCharA;
    pv = (PVOID)OemToCharBuffA;
    pv = (PVOID)OemToCharBuffW;
    pv = (PVOID)OemToCharW;
    pv = (PVOID)OffsetRect;
    pv = (PVOID)OpenClipboard;
    pv = (PVOID)OpenDesktopA;
    pv = (PVOID)OpenDesktopW;
    pv = (PVOID)OpenIcon;
    pv = (PVOID)OpenInputDesktop;
    pv = (PVOID)OpenWindowStationA;
    pv = (PVOID)OpenWindowStationW;
    pv = (PVOID)PackDDElParam;
    pv = (PVOID)PaintDesktop;
    pv = (PVOID)PeekMessageA;
    pv = (PVOID)PeekMessageW;
    pv = (PVOID)PostMessageA;
    pv = (PVOID)PostMessageW;
    pv = (PVOID)PostQuitMessage;
    pv = (PVOID)PostThreadMessageA;
    pv = (PVOID)PostThreadMessageW;
    //  pv = (PVOID)PrivateExtractIconExA;
    //  pv = (PVOID)PrivateExtractIconExW;
    //  pv = (PVOID)PrivateExtractIconsA;
    //  pv = (PVOID)PrivateExtractIconsW;
    //  pv = (PVOID)PrivateSetDbgTag;
    //  pv = (PVOID)PrivateSetRipFlags;
    pv = (PVOID)PtInRect;
    //  pv = (PVOID)QuerySendMessage;
    //  pv = (PVOID)QueryUserCounters;
    //  pv = (PVOID)RealChildWindowFromPoint;
    //  pv = (PVOID)RealGetWindowClass;
    //  pv = (PVOID)RealGetWindowClassA;
    //  pv = (PVOID)RealGetWindowClassW;
    pv = (PVOID)RedrawWindow;
    pv = (PVOID)RegisterClassA;
    pv = (PVOID)RegisterClassExA;
    pv = (PVOID)RegisterClassExW;
    pv = (PVOID)RegisterClassW;
    pv = (PVOID)RegisterClipboardFormatA;
    pv = (PVOID)RegisterClipboardFormatW;
    //  pv = (PVOID)RegisterDeviceNotificationA;
    //  pv = (PVOID)RegisterDeviceNotificationW;
    pv = (PVOID)RegisterHotKey;
    //  pv = (PVOID)RegisterLogonProcess;
    //  pv = (PVOID)RegisterServicesProcess;
    //  pv = (PVOID)RegisterShellHookWindow;
    //  pv = (PVOID)RegisterSystemThread;
    //  pv = (PVOID)RegisterTasklist;
    pv = (PVOID)RegisterWindowMessageA;
    pv = (PVOID)RegisterWindowMessageW;
    pv = (PVOID)ReleaseCapture;
    pv = (PVOID)ReleaseDC;
    pv = (PVOID)RemoveMenu;
    pv = (PVOID)RemovePropA;
    pv = (PVOID)RemovePropW;
    pv = (PVOID)ReplyMessage;
    //  pv = (PVOID)ResolveDesktopForWOW;
    pv = (PVOID)ReuseDDElParam;
    pv = (PVOID)ScreenToClient;
    //  pv = (PVOID)ScrollChildren;
    pv = (PVOID)ScrollDC;
    pv = (PVOID)ScrollWindow;
    pv = (PVOID)ScrollWindowEx;
    pv = (PVOID)SendDlgItemMessageA;
    pv = (PVOID)SendDlgItemMessageW;
    //  pv = (PVOID)SendIMEMessageExA;
    //  pv = (PVOID)SendIMEMessageExW;
    //  pv = (PVOID)SendInput;
    pv = (PVOID)SendMessageA;
    pv = (PVOID)SendMessageCallbackA;
    pv = (PVOID)SendMessageCallbackW;
    pv = (PVOID)SendMessageTimeoutA;
    pv = (PVOID)SendMessageTimeoutW;
    pv = (PVOID)SendMessageW;
    pv = (PVOID)SendNotifyMessageA;
    pv = (PVOID)SendNotifyMessageW;
    pv = (PVOID)SetActiveWindow;
    pv = (PVOID)SetCapture;
    pv = (PVOID)SetCaretBlinkTime;
    pv = (PVOID)SetCaretPos;
    pv = (PVOID)SetClassLongA;
    pv = (PVOID)SetClassLongW;
    pv = (PVOID)SetClassWord;
    pv = (PVOID)SetClipboardData;
    pv = (PVOID)SetClipboardViewer;
    //  pv = (PVOID)SetConsoleReserveKeys;
    pv = (PVOID)SetCursor;
    //  pv = (PVOID)SetCursorContents;
    pv = (PVOID)SetCursorPos;
    pv = (PVOID)SetDebugErrorLevel;
    //  pv = (PVOID)SetDeskWallpaper;
    pv = (PVOID)SetDlgItemInt;
    pv = (PVOID)SetDlgItemTextA;
    pv = (PVOID)SetDlgItemTextW;
    pv = (PVOID)SetDoubleClickTime;
    pv = (PVOID)SetFocus;
    pv = (PVOID)SetForegroundWindow;
    //  pv = (PVOID)SetInternalWindowPos;
    pv = (PVOID)SetKeyboardState;
    //  pv = (PVOID)SetLastErrorEx;
    //  pv = (PVOID)SetLayeredWindowAttributes;
    //  pv = (PVOID)SetLogonNotifyWindow;
    pv = (PVOID)SetMenu;
    pv = (PVOID)SetMenuContextHelpId;
    pv = (PVOID)SetMenuDefaultItem;
    //  pv = (PVOID)SetMenuInfo;
    pv = (PVOID)SetMenuItemBitmaps;
    pv = (PVOID)SetMenuItemInfoA;
    pv = (PVOID)SetMenuItemInfoW;
    pv = (PVOID)SetMessageExtraInfo;
    pv = (PVOID)SetMessageQueue;
    pv = (PVOID)SetParent;
    //  pv = (PVOID)SetProcessDefaultLayout;
    pv = (PVOID)SetProcessWindowStation;
    //  pv = (PVOID)SetProgmanWindow;
    pv = (PVOID)SetPropA;
    pv = (PVOID)SetPropW;
    pv = (PVOID)SetRect;
    pv = (PVOID)SetRectEmpty;
    pv = (PVOID)SetScrollInfo;
    pv = (PVOID)SetScrollPos;
    pv = (PVOID)SetScrollRange;
    //  pv = (PVOID)SetShellWindow;
    //  pv = (PVOID)SetShellWindowEx;
    pv = (PVOID)SetSysColors;
    //  pv = (PVOID)SetSysColorsTemp;
    pv = (PVOID)SetSystemCursor;
    //  pv = (PVOID)SetSystemMenu;
    //  pv = (PVOID)SetSystemTimer;
    //  pv = (PVOID)SetTaskmanWindow;
    pv = (PVOID)SetThreadDesktop;
    pv = (PVOID)SetTimer;
    pv = (PVOID)SetUserObjectInformationA;
    pv = (PVOID)SetUserObjectInformationW;
    pv = (PVOID)SetUserObjectSecurity;
    //  pv = (PVOID)SetWinEventHook;
    pv = (PVOID)SetWindowContextHelpId;
    pv = (PVOID)SetWindowLongA;
    pv = (PVOID)SetWindowLongW;
    pv = (PVOID)SetWindowPlacement;
    pv = (PVOID)SetWindowPos;
    pv = (PVOID)SetWindowRgn;
    //  pv = (PVOID)SetWindowStationUser;
    pv = (PVOID)SetWindowTextA;
    pv = (PVOID)SetWindowTextW;
    pv = (PVOID)SetWindowWord;
    pv = (PVOID)SetWindowsHookA;
    pv = (PVOID)SetWindowsHookExA;
    pv = (PVOID)SetWindowsHookExW;
    pv = (PVOID)SetWindowsHookW;
    pv = (PVOID)ShowCaret;
    pv = (PVOID)ShowCursor;
    pv = (PVOID)ShowOwnedPopups;
    pv = (PVOID)ShowScrollBar;
    //  pv = (PVOID)ShowStartGlass;
    pv = (PVOID)ShowWindow;
    pv = (PVOID)ShowWindowAsync;
    //  pv = (PVOID)SoftModalMessageBox;
    pv = (PVOID)SubtractRect;
    pv = (PVOID)SwapMouseButton;
    pv = (PVOID)SwitchDesktop;
    //  pv = (PVOID)SwitchToThisWindow;
    pv = (PVOID)SystemParametersInfoA;
    pv = (PVOID)SystemParametersInfoW;
    pv = (PVOID)TabbedTextOutA;
    pv = (PVOID)TabbedTextOutW;
    //  pv = (PVOID)TileChildWindows;
    pv = (PVOID)TileWindows;
    pv = (PVOID)ToAscii;
    pv = (PVOID)ToAsciiEx;
    pv = (PVOID)ToUnicode;
    pv = (PVOID)ToUnicodeEx;
    pv = (PVOID)TrackMouseEvent;
    pv = (PVOID)TrackPopupMenu;
    pv = (PVOID)TrackPopupMenuEx;
    pv = (PVOID)TranslateAccelerator;
    pv = (PVOID)TranslateAcceleratorA;
    pv = (PVOID)TranslateAcceleratorW;
    pv = (PVOID)TranslateMDISysAccel;
    pv = (PVOID)TranslateMessage;
    //  pv = (PVOID)TranslateMessageEx;
    //  pv = (PVOID)UnhookWinEvent;
    pv = (PVOID)UnhookWindowsHook;
    pv = (PVOID)UnhookWindowsHookEx;
    pv = (PVOID)UnionRect;
    pv = (PVOID)UnloadKeyboardLayout;
    //  pv = (PVOID)UnlockWindowStation;
    pv = (PVOID)UnpackDDElParam;
    pv = (PVOID)UnregisterClassA;
    pv = (PVOID)UnregisterClassW;
    //  pv = (PVOID)UnregisterDeviceNotification;
    pv = (PVOID)UnregisterHotKey;
    //  pv = (PVOID)UpdateLayeredWindow;
    //  pv = (PVOID)UpdatePerUserSystemParameters;
    pv = (PVOID)UpdateWindow;
    //  pv = (PVOID)User32InitializeImmEntryTable;
    //  pv = (PVOID)UserClientDllInitialize;
    //  pv = (PVOID)UserHandleGrantAccess;
    //  pv = (PVOID)UserLpkPSMTextOut;
    //  pv = (PVOID)UserLpkTabbedTextOut;
    //  pv = (PVOID)UserRealizePalette;
    //  pv = (PVOID)UserRegisterWowHandlers;
    //  pv = (PVOID)VRipOutput;
    //  pv = (PVOID)VTagOutput;
    pv = (PVOID)ValidateRect;
    pv = (PVOID)ValidateRgn;
    pv = (PVOID)VkKeyScanA;
    pv = (PVOID)VkKeyScanExA;
    pv = (PVOID)VkKeyScanExW;
    pv = (PVOID)VkKeyScanW;
    //  pv = (PVOID)WCSToMBEx;
    //  pv = (PVOID)WINNLSEnableIME;
    //  pv = (PVOID)WINNLSGetEnableStatus;
    //  pv = (PVOID)WINNLSGetIMEHotkey;
    pv = (PVOID)WaitForInputIdle;
    pv = (PVOID)WaitMessage;
    pv = (PVOID)WinHelpA;
    pv = (PVOID)WinHelpW;
    pv = (PVOID)WindowFromDC;
    pv = (PVOID)WindowFromPoint;
    pv = (PVOID)keybd_event;
    pv = (PVOID)mouse_event;
    //  pv = (PVOID)wsprintfA;
    //  pv = (PVOID)wsprintfW;
    //  pv = (PVOID)wvsprintfA;
    //  pv = (PVOID)wvsprintfW;

    // kernel32.dll
    pv = (PVOID)AddAtomA;
    pv = (PVOID)AddAtomW;
    //  pv = (PVOID)AddConsoleAliasA;
    //  pv = (PVOID)AddConsoleAliasW;
    pv = (PVOID)AllocConsole;
    //  pv = (PVOID)AllocateUserPhysicalPages;
    pv = (PVOID)AreFileApisANSI;
    //  pv = (PVOID)AssignProcessToJobObject;
    pv = (PVOID)BackupRead;
    pv = (PVOID)BackupSeek;
    pv = (PVOID)BackupWrite;
    //  pv = (PVOID)BaseAttachCompleteThunk;
    pv = (PVOID)Beep;
    pv = (PVOID)BeginUpdateResourceA;
    pv = (PVOID)BeginUpdateResourceW;
    //  pv = (PVOID)BindIoCompletionCallback;
    pv = (PVOID)BuildCommDCBA;
    pv = (PVOID)BuildCommDCBAndTimeoutsA;
    pv = (PVOID)BuildCommDCBAndTimeoutsW;
    pv = (PVOID)BuildCommDCBW;
    pv = (PVOID)CallNamedPipeA;
    pv = (PVOID)CallNamedPipeW;
    //  pv = (PVOID)CancelDeviceWakeupRequest;
    pv = (PVOID)CancelIo;
    //  pv = (PVOID)CancelTimerQueueTimer;
    pv = (PVOID)CancelWaitableTimer;
    //  pv = (PVOID)ChangeTimerQueueTimer;
    pv = (PVOID)ClearCommBreak;
    pv = (PVOID)ClearCommError;
    //  pv = (PVOID)CloseConsoleHandle;
    pv = (PVOID)CloseHandle;
    //  pv = (PVOID)CloseProfileUserMapping;
    //  pv = (PVOID)CmdBatNotification;
    pv = (PVOID)CommConfigDialogA;
    pv = (PVOID)CommConfigDialogW;
    pv = (PVOID)CompareFileTime;
    pv = (PVOID)CompareStringA;
    pv = (PVOID)CompareStringW;
    pv = (PVOID)ConnectNamedPipe;
    //  pv = (PVOID)ConsoleMenuControl;
    pv = (PVOID)ContinueDebugEvent;
    pv = (PVOID)ConvertDefaultLocale;
    pv = (PVOID)ConvertThreadToFiber;
    pv = (PVOID)CopyFileA;
    pv = (PVOID)CopyFileExA;
    pv = (PVOID)CopyFileExW;
    pv = (PVOID)CopyFileW;
    pv = (PVOID)CreateConsoleScreenBuffer;
    pv = (PVOID)CreateDirectoryA;
    pv = (PVOID)CreateDirectoryExA;
    pv = (PVOID)CreateDirectoryExW;
    pv = (PVOID)CreateDirectoryW;
    pv = (PVOID)CreateEventA;
    pv = (PVOID)CreateEventW;
    pv = (PVOID)CreateFiber;
    pv = (PVOID)CreateFileA;
    pv = (PVOID)CreateFileMappingA;
    pv = (PVOID)CreateFileMappingW;
    pv = (PVOID)CreateFileW;
    //  pv = (PVOID)CreateHardLinkA;
    //  pv = (PVOID)CreateHardLinkW;
    pv = (PVOID)CreateIoCompletionPort;
    //  pv = (PVOID)CreateJobObjectA;
    //  pv = (PVOID)CreateJobObjectW;
    pv = (PVOID)CreateMailslotA;
    pv = (PVOID)CreateMailslotW;
    pv = (PVOID)CreateMutexA;
    pv = (PVOID)CreateMutexW;
    pv = (PVOID)CreateNamedPipeA;
    pv = (PVOID)CreateNamedPipeW;
    pv = (PVOID)CreatePipe;
    pv = (PVOID)CreateProcessA;
    pv = (PVOID)CreateProcessW;
    pv = (PVOID)CreateRemoteThread;
    pv = (PVOID)CreateSemaphoreA;
    pv = (PVOID)CreateSemaphoreW;
    pv = (PVOID)CreateTapePartition;
    pv = (PVOID)CreateThread;
    //  pv = (PVOID)CreateTimerQueue;
    //  pv = (PVOID)CreateTimerQueueTimer;
    //  pv = (PVOID)CreateToolhelp32Snapshot;
    //  pv = (PVOID)CreateVirtualBuffer;
    pv = (PVOID)CreateWaitableTimerA;
    pv = (PVOID)CreateWaitableTimerW;
    pv = (PVOID)DebugActiveProcess;
    pv = (PVOID)DebugBreak;
    pv = (PVOID)DefineDosDeviceA;
    pv = (PVOID)DefineDosDeviceW;
    //  pv = (PVOID)DelayLoadFailureHook;
    pv = (PVOID)DeleteAtom;
    pv = (PVOID)DeleteCriticalSection;
    pv = (PVOID)DeleteFiber;
    pv = (PVOID)DeleteFileA;
    pv = (PVOID)DeleteFileW;
    //  pv = (PVOID)DeleteTimerQueue;
    //  pv = (PVOID)DeleteTimerQueueEx;
    //  pv = (PVOID)DeleteTimerQueueTimer;
    //  pv = (PVOID)DeleteVolumeMountPointA;
    //  pv = (PVOID)DeleteVolumeMountPointW;
    pv = (PVOID)DeviceIoControl;
    pv = (PVOID)DisableThreadLibraryCalls;
    pv = (PVOID)DisconnectNamedPipe;
    //  pv = (PVOID)DnsHostnameToComputerNameA;
    //  pv = (PVOID)DnsHostnameToComputerNameW;
    pv = (PVOID)DosDateTimeToFileTime;
    //  pv = (PVOID)DosPathToSessionPathA;
    //  pv = (PVOID)DosPathToSessionPathW;
    //  pv = (PVOID)DuplicateConsoleHandle;
    pv = (PVOID)DuplicateHandle;
    pv = (PVOID)EndUpdateResourceA;
    pv = (PVOID)EndUpdateResourceW;
    pv = (PVOID)EnterCriticalSection;
    pv = (PVOID)EnumCalendarInfoA;
    //  pv = (PVOID)EnumCalendarInfoExA;
    //  pv = (PVOID)EnumCalendarInfoExW;
    pv = (PVOID)EnumCalendarInfoW;
    pv = (PVOID)EnumDateFormatsA;
    //  pv = (PVOID)EnumDateFormatsExA;
    //  pv = (PVOID)EnumDateFormatsExW;
    pv = (PVOID)EnumDateFormatsW;
    //  pv = (PVOID)EnumLanguageGroupLocalesA;
    //  pv = (PVOID)EnumLanguageGroupLocalesW;
    pv = (PVOID)EnumResourceLanguagesA;
    pv = (PVOID)EnumResourceLanguagesW;
    pv = (PVOID)EnumResourceNamesA;
    pv = (PVOID)EnumResourceNamesW;
    pv = (PVOID)EnumResourceTypesA;
    pv = (PVOID)EnumResourceTypesW;
    pv = (PVOID)EnumSystemCodePagesA;
    pv = (PVOID)EnumSystemCodePagesW;
    //  pv = (PVOID)EnumSystemLanguageGroupsA;
    //  pv = (PVOID)EnumSystemLanguageGroupsW;
    pv = (PVOID)EnumSystemLocalesA;
    pv = (PVOID)EnumSystemLocalesW;
    pv = (PVOID)EnumTimeFormatsA;
    pv = (PVOID)EnumTimeFormatsW;
    //  pv = (PVOID)EnumUILanguagesA;
    //  pv = (PVOID)EnumUILanguagesW;
    pv = (PVOID)EraseTape;
    pv = (PVOID)EscapeCommFunction;
    pv = (PVOID)ExitProcess;
    pv = (PVOID)ExitThread;
    //  pv = (PVOID)ExitVDM;
    pv = (PVOID)ExpandEnvironmentStringsA;
    pv = (PVOID)ExpandEnvironmentStringsW;
    //  pv = (PVOID)ExpungeConsoleCommandHistoryA;
    //  pv = (PVOID)ExpungeConsoleCommandHistoryW;
    //  pv = (PVOID)ExtendVirtualBuffer;
    pv = (PVOID)FatalAppExitA;
    pv = (PVOID)FatalAppExitW;
    pv = (PVOID)FatalExit;
    pv = (PVOID)FileTimeToDosDateTime;
    pv = (PVOID)FileTimeToLocalFileTime;
    pv = (PVOID)FileTimeToSystemTime;
    pv = (PVOID)FillConsoleOutputAttribute;
    pv = (PVOID)FillConsoleOutputCharacterA;
    pv = (PVOID)FillConsoleOutputCharacterW;
    pv = (PVOID)FindAtomA;
    pv = (PVOID)FindAtomW;
    pv = (PVOID)FindClose;
    pv = (PVOID)FindCloseChangeNotification;
    pv = (PVOID)FindFirstChangeNotificationA;
    pv = (PVOID)FindFirstChangeNotificationW;
    pv = (PVOID)FindFirstFileA;
    pv = (PVOID)FindFirstFileExA;
    pv = (PVOID)FindFirstFileExW;
    pv = (PVOID)FindFirstFileW;
    //  pv = (PVOID)FindFirstVolumeA;
    //  pv = (PVOID)FindFirstVolumeMountPointA;
    //  pv = (PVOID)FindFirstVolumeMountPointW;
    //  pv = (PVOID)FindFirstVolumeW;
    pv = (PVOID)FindNextChangeNotification;
    pv = (PVOID)FindNextFileA;
    pv = (PVOID)FindNextFileW;
    //  pv = (PVOID)FindNextVolumeA;
    //  pv = (PVOID)FindNextVolumeMountPointA;
    //  pv = (PVOID)FindNextVolumeMountPointW;
    //  pv = (PVOID)FindNextVolumeW;
    pv = (PVOID)FindResourceA;
    pv = (PVOID)FindResourceExA;
    pv = (PVOID)FindResourceExW;
    pv = (PVOID)FindResourceW;
    //  pv = (PVOID)FindVolumeClose;
    //  pv = (PVOID)FindVolumeMountPointClose;
    pv = (PVOID)FlushConsoleInputBuffer;
    pv = (PVOID)FlushFileBuffers;
    pv = (PVOID)FlushViewOfFile;
    pv = (PVOID)FoldStringA;
    pv = (PVOID)FoldStringW;
    pv = (PVOID)FormatMessageA;
    pv = (PVOID)FormatMessageW;
    pv = (PVOID)FreeConsole;
    pv = (PVOID)FreeEnvironmentStringsA;
    pv = (PVOID)FreeEnvironmentStringsW;
    pv = (PVOID)FreeLibrary;
    pv = (PVOID)FreeLibraryAndExitThread;
    pv = (PVOID)FreeResource;
    //  pv = (PVOID)FreeUserPhysicalPages;
    //  pv = (PVOID)FreeVirtualBuffer;
    pv = (PVOID)GenerateConsoleCtrlEvent;
    pv = (PVOID)GetACP;
    pv = (PVOID)GetAtomNameA;
    pv = (PVOID)GetAtomNameW;
    pv = (PVOID)GetBinaryType;
    pv = (PVOID)GetBinaryTypeA;
    pv = (PVOID)GetBinaryTypeW;
    pv = (PVOID)GetCPInfo;
    //  pv = (PVOID)GetCPInfoExA;
    //  pv = (PVOID)GetCPInfoExW;
    //  pv = (PVOID)GetCalendarInfoA;
    //  pv = (PVOID)GetCalendarInfoW;
    pv = (PVOID)GetCommConfig;
    pv = (PVOID)GetCommMask;
    pv = (PVOID)GetCommModemStatus;
    pv = (PVOID)GetCommProperties;
    pv = (PVOID)GetCommState;
    pv = (PVOID)GetCommTimeouts;
    pv = (PVOID)GetCommandLineA;
    pv = (PVOID)GetCommandLineW;
    pv = (PVOID)GetCompressedFileSizeA;
    pv = (PVOID)GetCompressedFileSizeW;
    pv = (PVOID)GetComputerNameA;
    //  pv = (PVOID)GetComputerNameExA;
    //  pv = (PVOID)GetComputerNameExW;
    pv = (PVOID)GetComputerNameW;
    //  pv = (PVOID)GetConsoleAliasA;
    //  pv = (PVOID)GetConsoleAliasExesA;
    //  pv = (PVOID)GetConsoleAliasExesLengthA;
    //  pv = (PVOID)GetConsoleAliasExesLengthW;
    //  pv = (PVOID)GetConsoleAliasExesW;
    //  pv = (PVOID)GetConsoleAliasW;
    //  pv = (PVOID)GetConsoleAliasesA;
    //  pv = (PVOID)GetConsoleAliasesLengthA;
    //  pv = (PVOID)GetConsoleAliasesLengthW;
    //  pv = (PVOID)GetConsoleAliasesW;
    pv = (PVOID)GetConsoleCP;
    //  pv = (PVOID)GetConsoleCharType;
    //  pv = (PVOID)GetConsoleCommandHistoryA;
    //  pv = (PVOID)GetConsoleCommandHistoryLengthA;
    //  pv = (PVOID)GetConsoleCommandHistoryLengthW;
    //  pv = (PVOID)GetConsoleCommandHistoryW;
    pv = (PVOID)GetConsoleCursorInfo;
    //  pv = (PVOID)GetConsoleCursorMode;
    //  pv = (PVOID)GetConsoleDisplayMode;
    //  pv = (PVOID)GetConsoleFontInfo;
    //  pv = (PVOID)GetConsoleFontSize;
    //  pv = (PVOID)GetConsoleHardwareState;
    //  pv = (PVOID)GetConsoleInputExeNameA;
    //  pv = (PVOID)GetConsoleInputExeNameW;
    //  pv = (PVOID)GetConsoleInputWaitHandle;
    //  pv = (PVOID)GetConsoleKeyboardLayoutNameA;
    //  pv = (PVOID)GetConsoleKeyboardLayoutNameW;
    pv = (PVOID)GetConsoleMode;
    //  pv = (PVOID)GetConsoleNlsMode;
    pv = (PVOID)GetConsoleOutputCP;
    pv = (PVOID)GetConsoleScreenBufferInfo;
    pv = (PVOID)GetConsoleTitleA;
    pv = (PVOID)GetConsoleTitleW;
    //  pv = (PVOID)GetConsoleWindow;
    pv = (PVOID)GetCurrencyFormatA;
    pv = (PVOID)GetCurrencyFormatW;
    //  pv = (PVOID)GetCurrentConsoleFont;
    pv = (PVOID)GetCurrentDirectoryA;
    pv = (PVOID)GetCurrentDirectoryW;
    pv = (PVOID)GetCurrentProcess;
    pv = (PVOID)GetCurrentProcessId;
    pv = (PVOID)GetDateFormatA;
    pv = (PVOID)GetDateFormatW;
    pv = (PVOID)GetDefaultCommConfigA;
    pv = (PVOID)GetDefaultCommConfigW;
    //  pv = (PVOID)GetDefaultSortkeySize;
    //  pv = (PVOID)GetDevicePowerState;
    pv = (PVOID)GetDiskFreeSpaceA;
    pv = (PVOID)GetDiskFreeSpaceExA;
    pv = (PVOID)GetDiskFreeSpaceExW;
    pv = (PVOID)GetDiskFreeSpaceW;
    pv = (PVOID)GetDriveTypeA;
    pv = (PVOID)GetDriveTypeW;
    pv = (PVOID)GetEnvironmentStrings;
    pv = (PVOID)GetEnvironmentStringsA;
    pv = (PVOID)GetEnvironmentStringsW;
    pv = (PVOID)GetEnvironmentVariableA;
    pv = (PVOID)GetEnvironmentVariableW;
    pv = (PVOID)GetExitCodeProcess;
    pv = (PVOID)GetExitCodeThread;
    pv = (PVOID)GetFileAttributesA;
    pv = (PVOID)GetFileAttributesExA;
    pv = (PVOID)GetFileAttributesExW;
    pv = (PVOID)GetFileAttributesW;
    pv = (PVOID)GetFileInformationByHandle;
    pv = (PVOID)GetFileSize;
    //  pv = (PVOID)GetFileSizeEx;
    pv = (PVOID)GetFileTime;
    pv = (PVOID)GetFileType;
    pv = (PVOID)GetFullPathNameA;
    pv = (PVOID)GetFullPathNameW;
    pv = (PVOID)GetHandleInformation;
    //  pv = (PVOID)GetLargestConsoleWindowSize;
    //  pv = (PVOID)GetLastError;
    //  pv = (PVOID)GetLinguistLangSize;
    pv = (PVOID)GetLocalTime;
    pv = (PVOID)GetLocaleInfoA;
    pv = (PVOID)GetLocaleInfoW;
    pv = (PVOID)GetLogicalDriveStringsA;
    pv = (PVOID)GetLogicalDriveStringsW;
    pv = (PVOID)GetLogicalDrives;
    //  pv = (PVOID)GetLongPathNameA;
    //  pv = (PVOID)GetLongPathNameW;
    pv = (PVOID)GetMailslotInfo;
    pv = (PVOID)GetModuleFileNameA;
    pv = (PVOID)GetModuleFileNameW;
    pv = (PVOID)GetModuleHandleA;
    pv = (PVOID)GetModuleHandleW;
    pv = (PVOID)GetNamedPipeHandleStateA;
    pv = (PVOID)GetNamedPipeHandleStateW;
    pv = (PVOID)GetNamedPipeInfo;
    //  pv = (PVOID)GetNextVDMCommand;
    //  pv = (PVOID)GetNlsSectionName;
    pv = (PVOID)GetNumberFormatA;
    pv = (PVOID)GetNumberFormatW;
    //  pv = (PVOID)GetNumberOfConsoleFonts;
    pv = (PVOID)GetNumberOfConsoleInputEvents;
    pv = (PVOID)GetNumberOfConsoleMouseButtons;
    pv = (PVOID)GetOEMCP;
    pv = (PVOID)GetOverlappedResult;
    pv = (PVOID)GetPriorityClass;
    pv = (PVOID)GetPrivateProfileIntA;
    pv = (PVOID)GetPrivateProfileIntW;
    pv = (PVOID)GetPrivateProfileSectionA;
    pv = (PVOID)GetPrivateProfileSectionNamesA;
    pv = (PVOID)GetPrivateProfileSectionNamesW;
    pv = (PVOID)GetPrivateProfileSectionW;
    pv = (PVOID)GetPrivateProfileStringA;
    pv = (PVOID)GetPrivateProfileStringW;
    pv = (PVOID)GetPrivateProfileStructA;
    pv = (PVOID)GetPrivateProfileStructW;
    pv = (PVOID)GetProcAddress;
    pv = (PVOID)GetProcessAffinityMask;
    pv = (PVOID)GetProcessHeap;
    pv = (PVOID)GetProcessHeaps;
    //  pv = (PVOID)GetProcessIoCounters;
    pv = (PVOID)GetProcessPriorityBoost;
    pv = (PVOID)GetProcessShutdownParameters;
    pv = (PVOID)GetProcessTimes;
    pv = (PVOID)GetProcessVersion;
    pv = (PVOID)GetProcessWorkingSetSize;
    pv = (PVOID)GetProfileIntA;
    pv = (PVOID)GetProfileIntW;
    pv = (PVOID)GetProfileSectionA;
    pv = (PVOID)GetProfileSectionW;
    pv = (PVOID)GetProfileStringA;
    pv = (PVOID)GetProfileStringW;
    pv = (PVOID)GetQueuedCompletionStatus;
    pv = (PVOID)GetShortPathNameA;
    pv = (PVOID)GetShortPathNameW;
    pv = (PVOID)GetStartupInfoA;
    pv = (PVOID)GetStartupInfoW;
    pv = (PVOID)GetStdHandle;
    //  pv = (PVOID)GetStringTypeA;
    //  pv = (PVOID)GetStringTypeExA;
    //  pv = (PVOID)GetStringTypeExW;
    //  pv = (PVOID)GetStringTypeW;
    pv = (PVOID)GetSystemDefaultLCID;
    pv = (PVOID)GetSystemDefaultLangID;
    //  pv = (PVOID)GetSystemDefaultUILanguage;
    pv = (PVOID)GetSystemDirectoryA;
    pv = (PVOID)GetSystemDirectoryW;
    pv = (PVOID)GetSystemInfo;
    pv = (PVOID)GetSystemPowerStatus;
    pv = (PVOID)GetSystemTime;
    pv = (PVOID)GetSystemTimeAdjustment;
    pv = (PVOID)GetSystemTimeAsFileTime;
    //  pv = (PVOID)GetSystemWindowsDirectoryA;
    //  pv = (PVOID)GetSystemWindowsDirectoryW;
    pv = (PVOID)GetTapeParameters;
    pv = (PVOID)GetTapePosition;
    pv = (PVOID)GetTapeStatus;
    pv = (PVOID)GetTempFileNameA;
    pv = (PVOID)GetTempFileNameW;
    pv = (PVOID)GetTempPathA;
    pv = (PVOID)GetTempPathW;
    pv = (PVOID)GetThreadContext;
    pv = (PVOID)GetThreadLocale;
    pv = (PVOID)GetThreadPriority;
    pv = (PVOID)GetThreadPriorityBoost;
    pv = (PVOID)GetThreadSelectorEntry;
    pv = (PVOID)GetThreadTimes;
    pv = (PVOID)GetTickCount;
    pv = (PVOID)GetTimeFormatA;
    pv = (PVOID)GetTimeFormatW;
    pv = (PVOID)GetTimeZoneInformation;
    pv = (PVOID)GetUserDefaultLCID;
    pv = (PVOID)GetUserDefaultLangID;
    //  pv = (PVOID)GetUserDefaultUILanguage;
    //  pv = (PVOID)GetVDMCurrentDirectories;
    pv = (PVOID)GetVersion;
    pv = (PVOID)GetVersionExA;
    pv = (PVOID)GetVersionExW;
    pv = (PVOID)GetVolumeInformationA;
    pv = (PVOID)GetVolumeInformationW;
    //  pv = (PVOID)GetVolumeNameForVolumeMountPointA;
    //  pv = (PVOID)GetVolumeNameForVolumeMountPointW;
    //  pv = (PVOID)GetVolumePathNameA;
    //  pv = (PVOID)GetVolumePathNameW;
    pv = (PVOID)GetWindowsDirectoryA;
    pv = (PVOID)GetWindowsDirectoryW;
    pv = (PVOID)GlobalAddAtomA;
    pv = (PVOID)GlobalAddAtomW;
    pv = (PVOID)GlobalAlloc;
    pv = (PVOID)GlobalCompact;
    pv = (PVOID)GlobalDeleteAtom;
    pv = (PVOID)GlobalFindAtomA;
    pv = (PVOID)GlobalFindAtomW;
    pv = (PVOID)GlobalFix;
    pv = (PVOID)GlobalFlags;
    pv = (PVOID)GlobalFree;
    pv = (PVOID)GlobalGetAtomNameA;
    pv = (PVOID)GlobalGetAtomNameW;
    pv = (PVOID)GlobalHandle;
    pv = (PVOID)GlobalLock;
    pv = (PVOID)GlobalMemoryStatus;
    //  pv = (PVOID)GlobalMemoryStatusEx;
    pv = (PVOID)GlobalReAlloc;
    pv = (PVOID)GlobalSize;
    pv = (PVOID)GlobalUnWire;
    pv = (PVOID)GlobalUnfix;
    pv = (PVOID)GlobalUnlock;
    pv = (PVOID)GlobalWire;
    //  pv = (PVOID)Heap32First;
    //  pv = (PVOID)Heap32ListFirst;
    //  pv = (PVOID)Heap32ListNext;
    //  pv = (PVOID)Heap32Next;
    pv = (PVOID)HeapAlloc;
    pv = (PVOID)HeapCompact;
    pv = (PVOID)HeapCreate;
    //  pv = (PVOID)HeapCreateTagsW;
    pv = (PVOID)HeapDestroy;
    //  pv = (PVOID)HeapExtend;
    pv = (PVOID)HeapFree;
    pv = (PVOID)HeapLock;
    //  pv = (PVOID)HeapQueryTagW;
    pv = (PVOID)HeapReAlloc;
    pv = (PVOID)HeapSize;
    //  pv = (PVOID)HeapSummary;
    pv = (PVOID)HeapUnlock;
    //  pv = (PVOID)HeapUsage;
    pv = (PVOID)HeapValidate;
    pv = (PVOID)HeapWalk;
    pv = (PVOID)InitAtomTable;
    pv = (PVOID)InitializeCriticalSection;
    //  pv = (PVOID)InitializeCriticalSectionAndSpinCount;
    //  pv = (PVOID)InterlockedCompareExchange;
    //  pv = (PVOID)InterlockedDecrement;
    //  pv = (PVOID)InterlockedExchange;
    //  pv = (PVOID)InterlockedExchangeAdd;
    //  pv = (PVOID)InterlockedIncrement;
    //  pv = (PVOID)InvalidateConsoleDIBits;
    pv = (PVOID)IsBadCodePtr;
    pv = (PVOID)IsBadHugeReadPtr;
    pv = (PVOID)IsBadHugeWritePtr;
    pv = (PVOID)IsBadReadPtr;
    pv = (PVOID)IsBadStringPtrA;
    pv = (PVOID)IsBadStringPtrW;
    pv = (PVOID)IsBadWritePtr;
    pv = (PVOID)IsDBCSLeadByte;
    pv = (PVOID)IsDBCSLeadByteEx;
    pv = (PVOID)IsDebuggerPresent;
    pv = (PVOID)IsProcessorFeaturePresent;
    //  pv = (PVOID)IsSystemResumeAutomatic;
    pv = (PVOID)IsValidCodePage;
    //  pv = (PVOID)IsValidLanguageGroup;
    pv = (PVOID)IsValidLocale;
    //  pv = (PVOID)LCMapStringA;
    //  pv = (PVOID)LCMapStringW;
    pv = (PVOID)LeaveCriticalSection;
    pv = (PVOID)LoadLibraryA;
    pv = (PVOID)LoadLibraryExA;
    pv = (PVOID)LoadLibraryExW;
    pv = (PVOID)LoadLibraryW;
    pv = (PVOID)LoadModule;
    pv = (PVOID)LoadResource;
    pv = (PVOID)LocalAlloc;
    pv = (PVOID)LocalCompact;
    pv = (PVOID)LocalFileTimeToFileTime;
    pv = (PVOID)LocalFlags;
    pv = (PVOID)LocalFree;
    pv = (PVOID)LocalHandle;
    pv = (PVOID)LocalLock;
    pv = (PVOID)LocalReAlloc;
    pv = (PVOID)LocalShrink;
    pv = (PVOID)LocalSize;
    pv = (PVOID)LocalUnlock;
    pv = (PVOID)LockFile;
    pv = (PVOID)LockFileEx;
    pv = (PVOID)LockResource;
    //  pv = (PVOID)MapUserPhysicalPages;
    pv = (PVOID)MapViewOfFile;
    pv = (PVOID)MapViewOfFileEx;
    //  pv = (PVOID)MapViewOfFileVlm;
    //  pv = (PVOID)Module32First;
    //  pv = (PVOID)Module32FirstW;
    //  pv = (PVOID)Module32Next;
    //  pv = (PVOID)Module32NextW;
    pv = (PVOID)MoveFileA;
    pv = (PVOID)MoveFileExA;
    pv = (PVOID)MoveFileExW;
    pv = (PVOID)MoveFileW;
    //  pv = (PVOID)MoveFileWithProgressA;
    //  pv = (PVOID)MoveFileWithProgressW;
    pv = (PVOID)MulDiv;
    //  pv = (PVOID)MultiByteToWideChar;
    //  pv = (PVOID)NlsGetCacheUpdateCount;
    //  pv = (PVOID)OpenConsoleW;
    pv = (PVOID)OpenEventA;
    pv = (PVOID)OpenEventW;
    pv = (PVOID)OpenFile;
    pv = (PVOID)OpenFileMappingA;
    pv = (PVOID)OpenFileMappingW;
    //  pv = (PVOID)OpenJobObjectA;
    //  pv = (PVOID)OpenJobObjectW;
    pv = (PVOID)OpenMutexA;
    pv = (PVOID)OpenMutexW;
    pv = (PVOID)OpenProcess;
    //  pv = (PVOID)OpenProfileUserMapping;
    pv = (PVOID)OpenSemaphoreA;
    pv = (PVOID)OpenSemaphoreW;
    //  pv = (PVOID)OpenThread;
    pv = (PVOID)OpenWaitableTimerA;
    pv = (PVOID)OpenWaitableTimerW;
    pv = (PVOID)OutputDebugStringA;
    pv = (PVOID)OutputDebugStringW;
    pv = (PVOID)PeekConsoleInputA;
    pv = (PVOID)PeekConsoleInputW;
    pv = (PVOID)PeekNamedPipe;
    pv = (PVOID)PostQueuedCompletionStatus;
    pv = (PVOID)PrepareTape;
    //  pv = (PVOID)PrivCopyFileExW;
    //  pv = (PVOID)PrivMoveFileIdentityW;
    //  pv = (PVOID)Process32First;
    //  pv = (PVOID)Process32FirstW;
    //  pv = (PVOID)Process32Next;
    //  pv = (PVOID)Process32NextW;
    //  pv = (PVOID)ProcessIdToSessionId;
    pv = (PVOID)PulseEvent;
    pv = (PVOID)PurgeComm;
    pv = (PVOID)QueryDosDeviceA;
    pv = (PVOID)QueryDosDeviceW;
    //  pv = (PVOID)QueryInformationJobObject;
    pv = (PVOID)QueryPerformanceCounter;
    pv = (PVOID)QueryPerformanceFrequency;
    //  pv = (PVOID)QueryWin31IniFilesMappedToRegistry;
    pv = (PVOID)QueueUserAPC;
    //  pv = (PVOID)QueueUserWorkItem;
    pv = (PVOID)RaiseException;
    pv = (PVOID)ReadConsoleA;
    pv = (PVOID)ReadConsoleInputA;
    //  pv = (PVOID)ReadConsoleInputExA;
    //  pv = (PVOID)ReadConsoleInputExW;
    pv = (PVOID)ReadConsoleInputW;
    pv = (PVOID)ReadConsoleOutputA;
    pv = (PVOID)ReadConsoleOutputAttribute;
    pv = (PVOID)ReadConsoleOutputCharacterA;
    pv = (PVOID)ReadConsoleOutputCharacterW;
    pv = (PVOID)ReadConsoleOutputW;
    pv = (PVOID)ReadConsoleW;
    pv = (PVOID)ReadDirectoryChangesW;
    pv = (PVOID)ReadFile;
    pv = (PVOID)ReadFileEx;
    //  pv = (PVOID)ReadFileScatter;
    //  pv = (PVOID)ReadFileVlm;
    pv = (PVOID)ReadProcessMemory;
    //  pv = (PVOID)ReadProcessMemoryVlm;
    //  pv = (PVOID)RegisterConsoleIME;
    //  pv = (PVOID)RegisterConsoleOS2;
    //  pv = (PVOID)RegisterConsoleVDM;
    //  pv = (PVOID)RegisterWaitForInputIdle;
    //  pv = (PVOID)RegisterWaitForSingleObject;
    //  pv = (PVOID)RegisterWaitForSingleObjectEx;
    //  pv = (PVOID)RegisterWowBaseHandlers;
    //  pv = (PVOID)RegisterWowExec;
    pv = (PVOID)ReleaseMutex;
    pv = (PVOID)ReleaseSemaphore;
    pv = (PVOID)RemoveDirectoryA;
    pv = (PVOID)RemoveDirectoryW;
    //  pv = (PVOID)ReplaceFile;
    //  pv = (PVOID)ReplaceFileA;
    //  pv = (PVOID)ReplaceFileW;
    //  pv = (PVOID)RequestDeviceWakeup;
    //  pv = (PVOID)RequestWakeupLatency;
    pv = (PVOID)ResetEvent;
    pv = (PVOID)ResumeThread;
    pv = (PVOID)ScrollConsoleScreenBufferA;
    pv = (PVOID)ScrollConsoleScreenBufferW;
    pv = (PVOID)SearchPathA;
    pv = (PVOID)SearchPathW;
    //  pv = (PVOID)SetCPGlobal;
    //  pv = (PVOID)SetCalendarInfoA;
    //  pv = (PVOID)SetCalendarInfoW;
    pv = (PVOID)SetCommBreak;
    pv = (PVOID)SetCommConfig;
    pv = (PVOID)SetCommMask;
    pv = (PVOID)SetCommState;
    pv = (PVOID)SetCommTimeouts;
    pv = (PVOID)SetComputerNameA;
    //  pv = (PVOID)SetComputerNameExA;
    //  pv = (PVOID)SetComputerNameExW;
    pv = (PVOID)SetComputerNameW;
    pv = (PVOID)SetConsoleActiveScreenBuffer;
    pv = (PVOID)SetConsoleCP;
    //  pv = (PVOID)SetConsoleCommandHistoryMode;
    pv = (PVOID)SetConsoleCtrlHandler;
    //  pv = (PVOID)SetConsoleCursor;
    pv = (PVOID)SetConsoleCursorInfo;
    //  pv = (PVOID)SetConsoleCursorMode;
    pv = (PVOID)SetConsoleCursorPosition;
    //  pv = (PVOID)SetConsoleDisplayMode;
    //  pv = (PVOID)SetConsoleFont;
    //  pv = (PVOID)SetConsoleHardwareState;
    //  pv = (PVOID)SetConsoleIcon;
    //  pv = (PVOID)SetConsoleInputExeNameA;
    //  pv = (PVOID)SetConsoleInputExeNameW;
    //  pv = (PVOID)SetConsoleKeyShortcuts;
    //  pv = (PVOID)SetConsoleLocalEUDC;
    //  pv = (PVOID)SetConsoleMaximumWindowSize;
    //  pv = (PVOID)SetConsoleMenuClose;
    pv = (PVOID)SetConsoleMode;
    //  pv = (PVOID)SetConsoleNlsMode;
    //  pv = (PVOID)SetConsoleNumberOfCommandsA;
    //  pv = (PVOID)SetConsoleNumberOfCommandsW;
    //  pv = (PVOID)SetConsoleOS2OemFormat;
    pv = (PVOID)SetConsoleOutputCP;
    //  pv = (PVOID)SetConsolePalette;
    pv = (PVOID)SetConsoleScreenBufferSize;
    pv = (PVOID)SetConsoleTextAttribute;
    pv = (PVOID)SetConsoleTitleA;
    pv = (PVOID)SetConsoleTitleW;
    pv = (PVOID)SetConsoleWindowInfo;
    //  pv = (PVOID)SetCriticalSectionSpinCount;
    pv = (PVOID)SetCurrentDirectoryA;
    pv = (PVOID)SetCurrentDirectoryW;
    pv = (PVOID)SetDefaultCommConfigA;
    pv = (PVOID)SetDefaultCommConfigW;
    pv = (PVOID)SetEndOfFile;
    pv = (PVOID)SetEnvironmentVariableA;
    pv = (PVOID)SetEnvironmentVariableW;
    pv = (PVOID)SetErrorMode;
    pv = (PVOID)SetEvent;
    pv = (PVOID)SetFileApisToANSI;
    pv = (PVOID)SetFileApisToOEM;
    pv = (PVOID)SetFileAttributesA;
    pv = (PVOID)SetFileAttributesW;
    pv = (PVOID)SetFilePointer;
    //  pv = (PVOID)SetFilePointerEx;
    pv = (PVOID)SetFileTime;
    pv = (PVOID)SetHandleCount;
    pv = (PVOID)SetHandleInformation;
    //  pv = (PVOID)SetInformationJobObject;
    //  pv = (PVOID)SetLastConsoleEventActive;
    //  pv = (PVOID)SetLastError;
    pv = (PVOID)SetLocalTime;
    pv = (PVOID)SetLocaleInfoA;
    pv = (PVOID)SetLocaleInfoW;
    pv = (PVOID)SetMailslotInfo;
    //  pv = (PVOID)SetMessageWaitingIndicator;
    pv = (PVOID)SetNamedPipeHandleState;
    pv = (PVOID)SetPriorityClass;
    pv = (PVOID)SetProcessAffinityMask;
    pv = (PVOID)SetProcessPriorityBoost;
    pv = (PVOID)SetProcessShutdownParameters;
    pv = (PVOID)SetProcessWorkingSetSize;
    pv = (PVOID)SetStdHandle;
    pv = (PVOID)SetSystemPowerState;
    pv = (PVOID)SetSystemTime;
    pv = (PVOID)SetSystemTimeAdjustment;
    pv = (PVOID)SetTapeParameters;
    pv = (PVOID)SetTapePosition;
    //  pv = (PVOID)SetTermsrvAppInstallMode;
    pv = (PVOID)SetThreadAffinityMask;
    pv = (PVOID)SetThreadContext;
    //  pv = (PVOID)SetThreadExecutionState;
    pv = (PVOID)SetThreadIdealProcessor;
    pv = (PVOID)SetThreadLocale;
    pv = (PVOID)SetThreadPriority;
    pv = (PVOID)SetThreadPriorityBoost;
    pv = (PVOID)SetTimeZoneInformation;
    //  pv = (PVOID)SetTimerQueueTimer;
    pv = (PVOID)SetUnhandledExceptionFilter;
    //  pv = (PVOID)SetVDMCurrentDirectories;
    pv = (PVOID)SetVolumeLabelA;
    pv = (PVOID)SetVolumeLabelW;
    //  pv = (PVOID)SetVolumeMountPointA;
    //  pv = (PVOID)SetVolumeMountPointW;
    pv = (PVOID)SetWaitableTimer;
    pv = (PVOID)SetupComm;
    //  pv = (PVOID)ShowConsoleCursor;
    pv = (PVOID)SignalObjectAndWait;
    pv = (PVOID)SizeofResource;
    pv = (PVOID)Sleep;
    pv = (PVOID)SleepEx;
    pv = (PVOID)SuspendThread;
    pv = (PVOID)SwitchToFiber;
    pv = (PVOID)SwitchToThread;
    pv = (PVOID)SystemTimeToFileTime;
    pv = (PVOID)SystemTimeToTzSpecificLocalTime;
    //  pv = (PVOID)TerminateJobObject;
    pv = (PVOID)TerminateProcess;
    pv = (PVOID)TerminateThread;
    //  pv = (PVOID)TermsrvAppInstallMode;
    //  pv = (PVOID)Thread32First;
    //  pv = (PVOID)Thread32Next;
    //  pv = (PVOID)ThreadPoolCleanup;
    pv = (PVOID)TlsAlloc;
    pv = (PVOID)TlsFree;
    pv = (PVOID)TlsGetValue;
    pv = (PVOID)TlsSetValue;
    //  pv = (PVOID)Toolhelp32ReadProcessMemory;
    pv = (PVOID)TransactNamedPipe;
    pv = (PVOID)TransmitCommChar;
    //  pv = (PVOID)TrimVirtualBuffer;
    pv = (PVOID)TryEnterCriticalSection;
    //  pv = (PVOID)UTRegister;
    //  pv = (PVOID)UTUnRegister;
    pv = (PVOID)UnhandledExceptionFilter;
    pv = (PVOID)UnlockFile;
    pv = (PVOID)UnlockFileEx;
    pv = (PVOID)UnmapViewOfFile;
    //  pv = (PVOID)UnmapViewOfFileVlm;
    //  pv = (PVOID)UnregisterConsoleIME;
    //  pv = (PVOID)UnregisterWait;
    //  pv = (PVOID)UnregisterWaitEx;
    pv = (PVOID)UpdateResourceA;
    pv = (PVOID)UpdateResourceW;
    //  pv = (PVOID)VDMConsoleOperation;
    //  pv = (PVOID)VDMOperationStarted;
    //  pv = (PVOID)ValidateLCType;
    //  pv = (PVOID)ValidateLocale;
    pv = (PVOID)VerLanguageNameA;
    pv = (PVOID)VerLanguageNameW;
    //  pv = (PVOID)VerSetConditionMask;
    //  pv = (PVOID)VerifyConsoleIoHandle;
    //  pv = (PVOID)VerifyVersionInfoA;
    //  pv = (PVOID)VerifyVersionInfoW;
    pv = (PVOID)VirtualAlloc;
    pv = (PVOID)VirtualAllocEx;
    //  pv = (PVOID)VirtualAllocVlm;
    //  pv = (PVOID)VirtualBufferExceptionHandler;
    pv = (PVOID)VirtualFree;
    pv = (PVOID)VirtualFreeEx;
    //  pv = (PVOID)VirtualFreeVlm;
    pv = (PVOID)VirtualLock;
    pv = (PVOID)VirtualProtect;
    pv = (PVOID)VirtualProtectEx;
    //  pv = (PVOID)VirtualProtectVlm;
    pv = (PVOID)VirtualQuery;
    pv = (PVOID)VirtualQueryEx;
    //  pv = (PVOID)VirtualQueryVlm;
    pv = (PVOID)VirtualUnlock;
    pv = (PVOID)WaitCommEvent;
    pv = (PVOID)WaitForDebugEvent;
    pv = (PVOID)WaitForMultipleObjects;
    pv = (PVOID)WaitForMultipleObjectsEx;
    pv = (PVOID)WaitForSingleObject;
    pv = (PVOID)WaitForSingleObjectEx;
    pv = (PVOID)WaitNamedPipeA;
    pv = (PVOID)WaitNamedPipeW;
    //  pv = (PVOID)WideCharToMultiByte;
    pv = (PVOID)WinExec;
    pv = (PVOID)WriteConsoleA;
    pv = (PVOID)WriteConsoleInputA;
    //  pv = (PVOID)WriteConsoleInputVDMA;
    //  pv = (PVOID)WriteConsoleInputVDMW;
    pv = (PVOID)WriteConsoleInputW;
    pv = (PVOID)WriteConsoleOutputA;
    pv = (PVOID)WriteConsoleOutputAttribute;
    pv = (PVOID)WriteConsoleOutputCharacterA;
    pv = (PVOID)WriteConsoleOutputCharacterW;
    pv = (PVOID)WriteConsoleOutputW;
    pv = (PVOID)WriteConsoleW;
    pv = (PVOID)WriteFile;
    pv = (PVOID)WriteFileEx;
    //  pv = (PVOID)WriteFileGather;
    //  pv = (PVOID)WriteFileVlm;
    pv = (PVOID)WritePrivateProfileSectionA;
    pv = (PVOID)WritePrivateProfileSectionW;
    pv = (PVOID)WritePrivateProfileStringA;
    pv = (PVOID)WritePrivateProfileStringW;
    pv = (PVOID)WritePrivateProfileStructA;
    pv = (PVOID)WritePrivateProfileStructW;
    pv = (PVOID)WriteProcessMemory;
    //  pv = (PVOID)WriteProcessMemoryVlm;
    pv = (PVOID)WriteProfileSectionA;
    pv = (PVOID)WriteProfileSectionW;
    pv = (PVOID)WriteProfileStringA;
    pv = (PVOID)WriteProfileStringW;
    pv = (PVOID)WriteTapemark;
    pv = (PVOID)_hread;
    pv = (PVOID)_hwrite;
    pv = (PVOID)_lclose;
    pv = (PVOID)_lcreat;
    pv = (PVOID)_llseek;
    pv = (PVOID)_lopen;
    pv = (PVOID)_lread;
    pv = (PVOID)_lwrite;
    pv = (PVOID)lstrcat;
    pv = (PVOID)lstrcatA;
    pv = (PVOID)lstrcatW;
    pv = (PVOID)lstrcmp;
    pv = (PVOID)lstrcmpA;
    pv = (PVOID)lstrcmpW;
    pv = (PVOID)lstrcmpi;
    pv = (PVOID)lstrcmpiA;
    pv = (PVOID)lstrcmpiW;
    pv = (PVOID)lstrcpy;
    pv = (PVOID)lstrcpyA;
    pv = (PVOID)lstrcpyW;
    pv = (PVOID)lstrcpyn;
    pv = (PVOID)lstrcpynA;
    pv = (PVOID)lstrcpynW;
    pv = (PVOID)lstrlen;
    pv = (PVOID)lstrlenA;
    pv = (PVOID)lstrlenW;

    // gdi32.dll
    pv = (PVOID)AbortDoc;
    pv = (PVOID)AbortPath;
    //  pv = (PVOID)AddFontMemResourceEx;
    pv = (PVOID)AddFontResourceA;
    //  pv = (PVOID)AddFontResourceExA;
    //  pv = (PVOID)AddFontResourceExW;
    //  pv = (PVOID)AddFontResourceTracking;
    pv = (PVOID)AddFontResourceW;
    pv = (PVOID)AngleArc;
    pv = (PVOID)AnimatePalette;
    //  pv = (PVOID)AnyLinkedFonts;
    pv = (PVOID)Arc;
    pv = (PVOID)ArcTo;
    //  pv = (PVOID)BRUSHOBJ_hGetColorTransform;
    //  pv = (PVOID)BRUSHOBJ_pvAllocRbrush;
    //  pv = (PVOID)BRUSHOBJ_pvGetRbrush;
    //  pv = (PVOID)BRUSHOBJ_ulGetBrushColor;
    pv = (PVOID)BeginPath;
    pv = (PVOID)BitBlt;
    //  pv = (PVOID)CLIPOBJ_bEnum;
    //  pv = (PVOID)CLIPOBJ_cEnumStart;
    //  pv = (PVOID)CLIPOBJ_ppoGetPath;
    pv = (PVOID)CancelDC;
    pv = (PVOID)CheckColorsInGamut;
    pv = (PVOID)ChoosePixelFormat;
    pv = (PVOID)Chord;
    pv = (PVOID)CloseEnhMetaFile;
    pv = (PVOID)CloseFigure;
    pv = (PVOID)CloseMetaFile;
    //  pv = (PVOID)ColorCorrectPalette;
    pv = (PVOID)ColorMatchToTarget;
    pv = (PVOID)CombineRgn;
    pv = (PVOID)CombineTransform;
    pv = (PVOID)CopyEnhMetaFileA;
    pv = (PVOID)CopyEnhMetaFileW;
    pv = (PVOID)CopyMetaFileA;
    pv = (PVOID)CopyMetaFileW;
    pv = (PVOID)CreateBitmap;
    pv = (PVOID)CreateBitmapIndirect;
    pv = (PVOID)CreateBrushIndirect;
    pv = (PVOID)CreateColorSpaceA;
    pv = (PVOID)CreateColorSpaceW;
    pv = (PVOID)CreateCompatibleBitmap;
    pv = (PVOID)CreateCompatibleDC;
    pv = (PVOID)CreateDCA;
    pv = (PVOID)CreateDCW;
    pv = (PVOID)CreateDIBPatternBrush;
    pv = (PVOID)CreateDIBPatternBrushPt;
    pv = (PVOID)CreateDIBSection;
    pv = (PVOID)CreateDIBitmap;
    pv = (PVOID)CreateDiscardableBitmap;
    pv = (PVOID)CreateEllipticRgn;
    pv = (PVOID)CreateEllipticRgnIndirect;
    pv = (PVOID)CreateEnhMetaFileA;
    pv = (PVOID)CreateEnhMetaFileW;
    pv = (PVOID)CreateFontA;
    pv = (PVOID)CreateFontIndirectA;
    //  pv = (PVOID)CreateFontIndirectExA;
    //  pv = (PVOID)CreateFontIndirectExW;
    pv = (PVOID)CreateFontIndirectW;
    pv = (PVOID)CreateFontW;
    pv = (PVOID)CreateHalftonePalette;
    pv = (PVOID)CreateHatchBrush;
    pv = (PVOID)CreateICA;
    pv = (PVOID)CreateICW;
    pv = (PVOID)CreateMetaFileA;
    pv = (PVOID)CreateMetaFileW;
    pv = (PVOID)CreatePalette;
    pv = (PVOID)CreatePatternBrush;
    pv = (PVOID)CreatePen;
    pv = (PVOID)CreatePenIndirect;
    pv = (PVOID)CreatePolyPolygonRgn;
    pv = (PVOID)CreatePolygonRgn;
    pv = (PVOID)CreateRectRgn;
    pv = (PVOID)CreateRectRgnIndirect;
    pv = (PVOID)CreateRoundRectRgn;
    pv = (PVOID)CreateScalableFontResourceA;
    pv = (PVOID)CreateScalableFontResourceW;
    pv = (PVOID)CreateSolidBrush;
    pv = (PVOID)DPtoLP;
    pv = (PVOID)DeleteColorSpace;
    pv = (PVOID)DeleteDC;
    pv = (PVOID)DeleteEnhMetaFile;
    pv = (PVOID)DeleteMetaFile;
    pv = (PVOID)DeleteObject;
    pv = (PVOID)DescribePixelFormat;
    //  pv = (PVOID)DeviceCapabilitiesExA;
    //  pv = (PVOID)DeviceCapabilitiesExW;
    pv = (PVOID)DrawEscape;
    pv = (PVOID)Ellipse;
    //  pv = (PVOID)EnableEUDC;
    pv = (PVOID)EndDoc;
    //  pv = (PVOID)EndFormPage;
    pv = (PVOID)EndPage;
    pv = (PVOID)EndPath;
    //  pv = (PVOID)EngAcquireSemaphore;
    //  pv = (PVOID)EngAlphaBlend;
    //  pv = (PVOID)EngAssociateSurface;
    //  pv = (PVOID)EngBitBlt;
    //  pv = (PVOID)EngCheckAbort;
    //  pv = (PVOID)EngComputeGlyphSet;
    //  pv = (PVOID)EngCopyBits;
    //  pv = (PVOID)EngCreateBitmap;
    //  pv = (PVOID)EngCreateClip;
    //  pv = (PVOID)EngCreateDeviceBitmap;
    //  pv = (PVOID)EngCreateDeviceSurface;
    //  pv = (PVOID)EngCreatePalette;
    //  pv = (PVOID)EngCreateSemaphore;
    //  pv = (PVOID)EngDeleteClip;
    //  pv = (PVOID)EngDeletePalette;
    //  pv = (PVOID)EngDeletePath;
    //  pv = (PVOID)EngDeleteSemaphore;
    //  pv = (PVOID)EngDeleteSurface;
    //  pv = (PVOID)EngEraseSurface;
    //  pv = (PVOID)EngFillPath;
    //  pv = (PVOID)EngFindResource;
    //  pv = (PVOID)EngFreeModule;
    //  pv = (PVOID)EngGetCurrentCodePage;
    //  pv = (PVOID)EngGetDriverName;
    //  pv = (PVOID)EngGetPrinterDataFileName;
    //  pv = (PVOID)EngGradientFill;
    //  pv = (PVOID)EngLineTo;
    //  pv = (PVOID)EngLoadModule;
    //  pv = (PVOID)EngLockSurface;
    //  pv = (PVOID)EngMarkBandingSurface;
    //  pv = (PVOID)EngMultiByteToUnicodeN;
    //  pv = (PVOID)EngMultiByteToWideChar;
    //  pv = (PVOID)EngPaint;
    //  pv = (PVOID)EngPlgBlt;
    //  pv = (PVOID)EngQueryLocalTime;
    //  pv = (PVOID)EngReleaseSemaphore;
    //  pv = (PVOID)EngStretchBlt;
    //  pv = (PVOID)EngStretchBltROP;
    //  pv = (PVOID)EngStrokeAndFillPath;
    //  pv = (PVOID)EngStrokePath;
    //  pv = (PVOID)EngTextOut;
    //  pv = (PVOID)EngTransparentBlt;
    //  pv = (PVOID)EngUnicodeToMultiByteN;
    //  pv = (PVOID)EngUnlockSurface;
    //  pv = (PVOID)EngWideCharToMultiByte;
    pv = (PVOID)EnumEnhMetaFile;
    pv = (PVOID)EnumFontFamiliesA;
    pv = (PVOID)EnumFontFamiliesExA;
    pv = (PVOID)EnumFontFamiliesExW;
    pv = (PVOID)EnumFontFamiliesW;
    pv = (PVOID)EnumFontsA;
    pv = (PVOID)EnumFontsW;
    pv = (PVOID)EnumICMProfilesA;
    pv = (PVOID)EnumICMProfilesW;
    pv = (PVOID)EnumMetaFile;
    pv = (PVOID)EnumObjects;
    pv = (PVOID)EqualRgn;
    pv = (PVOID)Escape;
    //  pv = (PVOID)EudcLoadLinkW;
    //  pv = (PVOID)EudcUnloadLinkW;
    pv = (PVOID)ExcludeClipRect;
    pv = (PVOID)ExtCreatePen;
    pv = (PVOID)ExtCreateRegion;
    pv = (PVOID)ExtEscape;
    pv = (PVOID)ExtFloodFill;
    pv = (PVOID)ExtSelectClipRgn;
    pv = (PVOID)ExtTextOutA;
    pv = (PVOID)ExtTextOutW;
    //  pv = (PVOID)FONTOBJ_cGetAllGlyphHandles;
    //  pv = (PVOID)FONTOBJ_cGetGlyphs;
    //  pv = (PVOID)FONTOBJ_pQueryGlyphAttrs;
    //  pv = (PVOID)FONTOBJ_pfdg;
    //  pv = (PVOID)FONTOBJ_pifi;
    //  pv = (PVOID)FONTOBJ_pvTrueTypeFontFile;
    //  pv = (PVOID)FONTOBJ_pxoGetXform;
    //  pv = (PVOID)FONTOBJ_vGetInfo;
    pv = (PVOID)FillPath;
    pv = (PVOID)FillRgn;
    pv = (PVOID)FixBrushOrgEx;
    pv = (PVOID)FlattenPath;
    pv = (PVOID)FloodFill;
    //  pv = (PVOID)FontIsLinked;
    pv = (PVOID)FrameRgn;
    //  pv = (PVOID)GdiAddFontResourceW;
    //  pv = (PVOID)GdiAddGlsBounds;
    //  pv = (PVOID)GdiAddGlsRecord;
    //  pv = (PVOID)GdiAlphaBlend;
    //  pv = (PVOID)GdiArtificialDecrementDriver;
    //  pv = (PVOID)GdiCleanCacheDC;
    pv = (PVOID)GdiComment;
    //  pv = (PVOID)GdiConsoleTextOut;
    //  pv = (PVOID)GdiConvertAndCheckDC;
    //  pv = (PVOID)GdiConvertBitmap;
    //  pv = (PVOID)GdiConvertBitmapV5;
    //  pv = (PVOID)GdiConvertBrush;
    //  pv = (PVOID)GdiConvertDC;
    //  pv = (PVOID)GdiConvertEnhMetaFile;
    //  pv = (PVOID)GdiConvertFont;
    //  pv = (PVOID)GdiConvertMetaFilePict;
    //  pv = (PVOID)GdiConvertPalette;
    //  pv = (PVOID)GdiConvertRegion;
    //  pv = (PVOID)GdiConvertToDevmodeW;
    //  pv = (PVOID)GdiCreateLocalEnhMetaFile;
    //  pv = (PVOID)GdiCreateLocalMetaFilePict;
    //  pv = (PVOID)GdiDeleteLocalDC;
    //  pv = (PVOID)GdiDeleteSpoolFileHandle;
    //  pv = (PVOID)GdiDescribePixelFormat;
    //  pv = (PVOID)GdiDllInitialize;
    //  pv = (PVOID)GdiEndDocEMF;
    //  pv = (PVOID)GdiEndPageEMF;
    //  pv = (PVOID)GdiEntry1;
    //  pv = (PVOID)GdiEntry10;
    //  pv = (PVOID)GdiEntry11;
    //  pv = (PVOID)GdiEntry12;
    //  pv = (PVOID)GdiEntry13;
    //  pv = (PVOID)GdiEntry14;
    //  pv = (PVOID)GdiEntry15;
    //  pv = (PVOID)GdiEntry16;
    //  pv = (PVOID)GdiEntry2;
    //  pv = (PVOID)GdiEntry3;
    //  pv = (PVOID)GdiEntry4;
    //  pv = (PVOID)GdiEntry5;
    //  pv = (PVOID)GdiEntry6;
    //  pv = (PVOID)GdiEntry7;
    //  pv = (PVOID)GdiEntry8;
    //  pv = (PVOID)GdiEntry9;
    //  pv = (PVOID)GdiFixUpHandle;
    pv = (PVOID)GdiFlush;
    //  pv = (PVOID)GdiFullscreenControl;
    pv = (PVOID)GdiGetBatchLimit;
    //  pv = (PVOID)GdiGetCharDimensions;
    //  pv = (PVOID)GdiGetCodePage;
    //  pv = (PVOID)GdiGetDC;
    //  pv = (PVOID)GdiGetDevmodeForPage;
    //  pv = (PVOID)GdiGetLocalBrush;
    //  pv = (PVOID)GdiGetLocalDC;
    //  pv = (PVOID)GdiGetLocalFont;
    //  pv = (PVOID)GdiGetPageCount;
    //  pv = (PVOID)GdiGetPageHandle;
    //  pv = (PVOID)GdiGetSpoolFileHandle;
    //  pv = (PVOID)GdiGetSpoolMessage;
    //  pv = (PVOID)GdiGradientFill;
    //  pv = (PVOID)GdiInitSpool;
    //  pv = (PVOID)GdiInitializeLanguagePack;
    //  pv = (PVOID)GdiIsMetaFileDC;
    //  pv = (PVOID)GdiIsMetaPrintDC;
    //  pv = (PVOID)GdiIsPlayMetafileDC;
    //  pv = (PVOID)GdiPlayDCScript;
    //  pv = (PVOID)GdiPlayEMF;
    //  pv = (PVOID)GdiPlayJournal;
    //  pv = (PVOID)GdiPlayPageEMF;
    //  pv = (PVOID)GdiPlayPrivatePageEMF;
    //  pv = (PVOID)GdiPlayScript;
    //  pv = (PVOID)GdiPrinterThunk;
    //  pv = (PVOID)GdiProcessSetup;
    //  pv = (PVOID)GdiQueryFonts;
    //  pv = (PVOID)GdiQueryTable;
    //  pv = (PVOID)GdiRealizationInfo;
    //  pv = (PVOID)GdiReleaseDC;
    //  pv = (PVOID)GdiReleaseLocalDC;
    //  pv = (PVOID)GdiResetDCEMF;
    //  pv = (PVOID)GdiSetAttrs;
    pv = (PVOID)GdiSetBatchLimit;
    //  pv = (PVOID)GdiSetLastError;
    //  pv = (PVOID)GdiSetPixelFormat;
    //  pv = (PVOID)GdiSetServerAttr;
    //  pv = (PVOID)GdiStartDocEMF;
    //  pv = (PVOID)GdiStartPageEMF;
    //  pv = (PVOID)GdiSwapBuffers;
    //  pv = (PVOID)GdiTransparentBlt;
    //  pv = (PVOID)GdiValidateHandle;
    pv = (PVOID)GetArcDirection;
    pv = (PVOID)GetAspectRatioFilterEx;
    pv = (PVOID)GetBitmapBits;
    pv = (PVOID)GetBitmapDimensionEx;
    pv = (PVOID)GetBkColor;
    pv = (PVOID)GetBkMode;
    pv = (PVOID)GetBoundsRect;
    pv = (PVOID)GetBrushOrgEx;
    pv = (PVOID)GetCharABCWidthsA;
    pv = (PVOID)GetCharABCWidthsFloatA;
    pv = (PVOID)GetCharABCWidthsFloatW;
    //  pv = (PVOID)GetCharABCWidthsI;
    pv = (PVOID)GetCharABCWidthsW;
    pv = (PVOID)GetCharWidth32A;
    pv = (PVOID)GetCharWidth32W;
    pv = (PVOID)GetCharWidthA;
    pv = (PVOID)GetCharWidthFloatA;
    pv = (PVOID)GetCharWidthFloatW;
    //  pv = (PVOID)GetCharWidthI;
    //  pv = (PVOID)GetCharWidthInfo;
    pv = (PVOID)GetCharWidthW;
    pv = (PVOID)GetCharacterPlacementA;
    pv = (PVOID)GetCharacterPlacementW;
    pv = (PVOID)GetClipBox;
    pv = (PVOID)GetClipRgn;
    pv = (PVOID)GetColorAdjustment;
    pv = (PVOID)GetColorSpace;
    pv = (PVOID)GetCurrentObject;
    pv = (PVOID)GetCurrentPositionEx;
    //  pv = (PVOID)GetDCBrushColor;
    pv = (PVOID)GetDCOrgEx;
    //  pv = (PVOID)GetDCPenColor;
    pv = (PVOID)GetDIBColorTable;
    pv = (PVOID)GetDIBits;
    pv = (PVOID)GetDeviceCaps;
    pv = (PVOID)GetDeviceGammaRamp;
    //  pv = (PVOID)GetETM;
    //  pv = (PVOID)GetEUDCTimeStamp;
    //  pv = (PVOID)GetEUDCTimeStampExW;
    pv = (PVOID)GetEnhMetaFileA;
    pv = (PVOID)GetEnhMetaFileBits;
    pv = (PVOID)GetEnhMetaFileDescriptionA;
    pv = (PVOID)GetEnhMetaFileDescriptionW;
    pv = (PVOID)GetEnhMetaFileHeader;
    pv = (PVOID)GetEnhMetaFilePaletteEntries;
    pv = (PVOID)GetEnhMetaFilePixelFormat;
    pv = (PVOID)GetEnhMetaFileW;
    //  pv = (PVOID)GetFontAssocStatus;
    pv = (PVOID)GetFontData;
    pv = (PVOID)GetFontLanguageInfo;
    //  pv = (PVOID)GetFontResourceInfoW;
    //  pv = (PVOID)GetFontUnicodeRanges;
    //  pv = (PVOID)GetGlyphIndicesA;
    //  pv = (PVOID)GetGlyphIndicesW;
    pv = (PVOID)GetGlyphOutline;
    pv = (PVOID)GetGlyphOutlineA;
    pv = (PVOID)GetGlyphOutlineW;
    //  pv = (PVOID)GetGlyphOutlineWow;
    pv = (PVOID)GetGraphicsMode;
    //  pv = (PVOID)GetHFONT;
    pv = (PVOID)GetICMProfileA;
    pv = (PVOID)GetICMProfileW;
    pv = (PVOID)GetKerningPairs;
    pv = (PVOID)GetKerningPairsA;
    pv = (PVOID)GetKerningPairsW;
    //  pv = (PVOID)GetLayout;
    pv = (PVOID)GetLogColorSpaceA;
    pv = (PVOID)GetLogColorSpaceW;
    pv = (PVOID)GetMapMode;
    pv = (PVOID)GetMetaFileA;
    pv = (PVOID)GetMetaFileBitsEx;
    pv = (PVOID)GetMetaFileW;
    pv = (PVOID)GetMetaRgn;
    pv = (PVOID)GetMiterLimit;
    pv = (PVOID)GetNearestColor;
    pv = (PVOID)GetNearestPaletteIndex;
    pv = (PVOID)GetObjectA;
    pv = (PVOID)GetObjectType;
    pv = (PVOID)GetObjectW;
    pv = (PVOID)GetOutlineTextMetricsA;
    pv = (PVOID)GetOutlineTextMetricsW;
    pv = (PVOID)GetPaletteEntries;
    pv = (PVOID)GetPath;
    pv = (PVOID)GetPixel;
    pv = (PVOID)GetPixelFormat;
    pv = (PVOID)GetPolyFillMode;
    pv = (PVOID)GetROP2;
    //  pv = (PVOID)GetRandomRgn;
    pv = (PVOID)GetRasterizerCaps;
    pv = (PVOID)GetRegionData;
    //  pv = (PVOID)GetRelAbs;
    pv = (PVOID)GetRgnBox;
    pv = (PVOID)GetStockObject;
    pv = (PVOID)GetStretchBltMode;
    //  pv = (PVOID)GetStringBitmapA;
    //  pv = (PVOID)GetStringBitmapW;
    pv = (PVOID)GetSystemPaletteEntries;
    pv = (PVOID)GetSystemPaletteUse;
    pv = (PVOID)GetTextAlign;
    pv = (PVOID)GetTextCharacterExtra;
    pv = (PVOID)GetTextCharset;
    pv = (PVOID)GetTextCharsetInfo;
    pv = (PVOID)GetTextColor;
    pv = (PVOID)GetTextExtentExPointA;
    //  pv = (PVOID)GetTextExtentExPointI;
    pv = (PVOID)GetTextExtentExPointW;
    //  pv = (PVOID)GetTextExtentExPointWPri;
    pv = (PVOID)GetTextExtentPoint32A;
    pv = (PVOID)GetTextExtentPoint32W;
    pv = (PVOID)GetTextExtentPointA;
    //  pv = (PVOID)GetTextExtentPointI;
    pv = (PVOID)GetTextExtentPointW;
    pv = (PVOID)GetTextFaceA;
    //  pv = (PVOID)GetTextFaceAliasW;
    pv = (PVOID)GetTextFaceW;
    pv = (PVOID)GetTextMetricsA;
    pv = (PVOID)GetTextMetricsW;
    //  pv = (PVOID)GetTransform;
    pv = (PVOID)GetViewportExtEx;
    pv = (PVOID)GetViewportOrgEx;
    pv = (PVOID)GetWinMetaFileBits;
    pv = (PVOID)GetWindowExtEx;
    pv = (PVOID)GetWindowOrgEx;
    pv = (PVOID)GetWorldTransform;
    //  pv = (PVOID)HT_Get8BPPFormatPalette;
    //  pv = (PVOID)HT_Get8BPPMaskPalette;
    pv = (PVOID)IntersectClipRect;
    pv = (PVOID)InvertRgn;
    pv = (PVOID)LPtoDP;
    pv = (PVOID)LineDDA;
    pv = (PVOID)LineTo;
    pv = (PVOID)MaskBlt;
    //  pv = (PVOID)MirrorRgn;
    pv = (PVOID)ModifyWorldTransform;
    pv = (PVOID)MoveToEx;
    //  pv = (PVOID)NamedEscape;
    pv = (PVOID)OffsetClipRgn;
    pv = (PVOID)OffsetRgn;
    pv = (PVOID)OffsetViewportOrgEx;
    pv = (PVOID)OffsetWindowOrgEx;
    //  pv = (PVOID)PATHOBJ_bEnum;
    //  pv = (PVOID)PATHOBJ_bEnumClipLines;
    //  pv = (PVOID)PATHOBJ_vEnumStart;
    //  pv = (PVOID)PATHOBJ_vEnumStartClipLines;
    //  pv = (PVOID)PATHOBJ_vGetBounds;
    pv = (PVOID)PaintRgn;
    pv = (PVOID)PatBlt;
    pv = (PVOID)PathToRegion;
    pv = (PVOID)Pie;
    pv = (PVOID)PlayEnhMetaFile;
    pv = (PVOID)PlayEnhMetaFileRecord;
    pv = (PVOID)PlayMetaFile;
    pv = (PVOID)PlayMetaFileRecord;
    pv = (PVOID)PlgBlt;
    pv = (PVOID)PolyBezier;
    pv = (PVOID)PolyBezierTo;
    pv = (PVOID)PolyDraw;
    //  pv = (PVOID)PolyPatBlt;
    pv = (PVOID)PolyPolygon;
    pv = (PVOID)PolyPolyline;
    pv = (PVOID)PolyTextOutA;
    pv = (PVOID)PolyTextOutW;
    pv = (PVOID)Polygon;
    pv = (PVOID)Polyline;
    pv = (PVOID)PolylineTo;
    pv = (PVOID)PtInRegion;
    pv = (PVOID)PtVisible;
    //  pv = (PVOID)QueryFontAssocStatus;
    pv = (PVOID)RealizePalette;
    pv = (PVOID)RectInRegion;
    pv = (PVOID)RectVisible;
    pv = (PVOID)Rectangle;
    //  pv = (PVOID)RemoveFontMemResourceEx;
    pv = (PVOID)RemoveFontResourceA;
    //  pv = (PVOID)RemoveFontResourceExA;
    //  pv = (PVOID)RemoveFontResourceExW;
    //  pv = (PVOID)RemoveFontResourceTracking;
    pv = (PVOID)RemoveFontResourceW;
    pv = (PVOID)ResetDCA;
    pv = (PVOID)ResetDCW;
    pv = (PVOID)ResizePalette;
    pv = (PVOID)RestoreDC;
    pv = (PVOID)RoundRect;
    //  pv = (PVOID)STROBJ_bEnum;
    //  pv = (PVOID)STROBJ_bEnumPositionsOnly;
    //  pv = (PVOID)STROBJ_bGetAdvanceWidths;
    //  pv = (PVOID)STROBJ_dwGetCodePage;
    //  pv = (PVOID)STROBJ_vEnumStart;
    pv = (PVOID)SaveDC;
    pv = (PVOID)ScaleViewportExtEx;
    pv = (PVOID)ScaleWindowExtEx;
    //  pv = (PVOID)SelectBrushLocal;
    pv = (PVOID)SelectClipPath;
    pv = (PVOID)SelectClipRgn;
    //  pv = (PVOID)SelectFontLocal;
    pv = (PVOID)SelectObject;
    pv = (PVOID)SelectPalette;
    pv = (PVOID)SetAbortProc;
    pv = (PVOID)SetArcDirection;
    pv = (PVOID)SetBitmapBits;
    pv = (PVOID)SetBitmapDimensionEx;
    pv = (PVOID)SetBkColor;
    pv = (PVOID)SetBkMode;
    pv = (PVOID)SetBoundsRect;
    pv = (PVOID)SetBrushOrgEx;
    pv = (PVOID)SetColorAdjustment;
    pv = (PVOID)SetColorSpace;
    //  pv = (PVOID)SetDCBrushColor;
    //  pv = (PVOID)SetDCPenColor;
    pv = (PVOID)SetDIBColorTable;
    pv = (PVOID)SetDIBits;
    pv = (PVOID)SetDIBitsToDevice;
    pv = (PVOID)SetDeviceGammaRamp;
    pv = (PVOID)SetEnhMetaFileBits;
    //  pv = (PVOID)SetFontEnumeration;
    pv = (PVOID)SetGraphicsMode;
    pv = (PVOID)SetICMMode;
    pv = (PVOID)SetICMProfileA;
    pv = (PVOID)SetICMProfileW;
    //  pv = (PVOID)SetLayout;
    //  pv = (PVOID)SetLayoutWidth;
    //  pv = (PVOID)SetMagicColors;
    pv = (PVOID)SetMapMode;
    pv = (PVOID)SetMapperFlags;
    pv = (PVOID)SetMetaFileBitsEx;
    pv = (PVOID)SetMetaRgn;
    pv = (PVOID)SetMiterLimit;
    pv = (PVOID)SetPaletteEntries;
    pv = (PVOID)SetPixel;
    pv = (PVOID)SetPixelFormat;
    pv = (PVOID)SetPixelV;
    pv = (PVOID)SetPolyFillMode;
    pv = (PVOID)SetROP2;
    pv = (PVOID)SetRectRgn;
    //  pv = (PVOID)SetRelAbs;
    pv = (PVOID)SetStretchBltMode;
    pv = (PVOID)SetSystemPaletteUse;
    pv = (PVOID)SetTextAlign;
    pv = (PVOID)SetTextCharacterExtra;
    pv = (PVOID)SetTextColor;
    pv = (PVOID)SetTextJustification;
    pv = (PVOID)SetViewportExtEx;
    pv = (PVOID)SetViewportOrgEx;
    //  pv = (PVOID)SetVirtualResolution;
    pv = (PVOID)SetWinMetaFileBits;
    pv = (PVOID)SetWindowExtEx;
    pv = (PVOID)SetWindowOrgEx;
    pv = (PVOID)SetWorldTransform;
    pv = (PVOID)StartDocA;
    pv = (PVOID)StartDocW;
    //  pv = (PVOID)StartFormPage;
    pv = (PVOID)StartPage;
    pv = (PVOID)StretchBlt;
    pv = (PVOID)StretchDIBits;
    pv = (PVOID)StrokeAndFillPath;
    pv = (PVOID)StrokePath;
    pv = (PVOID)SwapBuffers;
    pv = (PVOID)TextOutA;
    pv = (PVOID)TextOutW;
    pv = (PVOID)TranslateCharsetInfo;
    //  pv = (PVOID)UnloadNetworkFonts;
    pv = (PVOID)UnrealizeObject;
    pv = (PVOID)UpdateColors;
    pv = (PVOID)UpdateICMRegKeyA;
    pv = (PVOID)UpdateICMRegKeyW;
    pv = (PVOID)WidenPath;
    //  pv = (PVOID)XFORMOBJ_bApplyXform;
    //  pv = (PVOID)XFORMOBJ_iGetXform;
    //  pv = (PVOID)XLATEOBJ_cGetPalette;
    //  pv = (PVOID)XLATEOBJ_hGetColorTransform;
    //  pv = (PVOID)XLATEOBJ_iXlate;
    //  pv = (PVOID)XLATEOBJ_piVector;
    //  pv = (PVOID)bInitSystemAndFontsDirectoriesW;
    //  pv = (PVOID)bMakePathNameW;
    //  pv = (PVOID)cGetTTFFromFOT;
    //  pv = (PVOID)gdiPlaySpoolStream;

    pv = (PVOID)GetUserNameA;
    pv = (PVOID)GetUserNameW;
    pv = (PVOID)RegCloseKey;
    pv = (PVOID)RegCreateKeyExA;
    pv = (PVOID)RegCreateKeyExW;
    pv = (PVOID)RegDeleteKeyA;
    pv = (PVOID)RegDeleteKeyW;
    pv = (PVOID)RegEnumKeyA;
    pv = (PVOID)RegEnumKeyW;
    pv = (PVOID)RegOpenKeyExA;
    pv = (PVOID)RegOpenKeyExW;
    pv = (PVOID)RegQueryValueExA;
    pv = (PVOID)RegQueryValueExW;
    pv = (PVOID)RegSetValueA;
    pv = (PVOID)RegSetValueW;
    pv = (PVOID)RegSetValueExA;
    pv = (PVOID)RegSetValueExW;
    pv = (PVOID)GetFileVersionInfoA;
    pv = (PVOID)GetFileVersionInfoW;
    pv = (PVOID)GetFileVersionInfoSizeA;
    pv = (PVOID)GetFileVersionInfoSizeW;
    pv = (PVOID)VerQueryValueA;
    pv = (PVOID)VerQueryValueW;
    pv = (PVOID)auxGetDevCapsA;
    pv = (PVOID)auxGetDevCapsW;
    pv = (PVOID)auxGetNumDevs;
    pv = (PVOID)auxGetVolume;
    pv = (PVOID)auxSetVolume;
    pv = (PVOID)mciSendCommandA;
    pv = (PVOID)mciSendCommandW;
    pv = (PVOID)timeBeginPeriod;
    pv = (PVOID)timeEndPeriod;
    pv = (PVOID)timeGetTime;
    pv = (PVOID)CoCreateInstance;
    pv = (PVOID)CoInitialize;
    pv = (PVOID)ShellExecuteA;
    pv = (PVOID)ShellExecuteW;
    pv = (PVOID)LZClose;
    pv = (PVOID)LZOpenFileA;
    pv = (PVOID)LZOpenFileW;
    pv = (PVOID)wcslen;



    pv = (PVOID)AbortSystemShutdownA;
    pv = (PVOID)AbortSystemShutdownW;
    pv = (PVOID)AccessCheck;
    pv = (PVOID)AccessCheckAndAuditAlarmA;
    pv = (PVOID)AccessCheckAndAuditAlarmW;
    pv = (PVOID)AddAce;
    pv = (PVOID)AdjustTokenGroups;
    pv = (PVOID)AdjustTokenPrivileges;
    pv = (PVOID)AllocateAndInitializeSid;
    pv = (PVOID)AllocateLocallyUniqueId;
    pv = (PVOID)AreAllAccessesGranted;
    pv = (PVOID)AreAnyAccessesGranted;
    pv = (PVOID)BackupEventLogA;
    pv = (PVOID)BackupEventLogW;
    pv = (PVOID)ChangeServiceConfigA;
    pv = (PVOID)ChangeServiceConfig2A;
    pv = (PVOID)ChangeServiceConfigW;
    pv = (PVOID)ChangeServiceConfig2W;
    pv = (PVOID)ClearEventLog;
    pv = (PVOID)CloseServiceHandle;
    pv = (PVOID)ControlService;
    pv = (PVOID)CopySid;
    pv = (PVOID)CreatePrivateObjectSecurity;
    pv = (PVOID)CreateProcessAsUserA;
    pv = (PVOID)CreateProcessAsUserW;
    pv = (PVOID)CreateRestrictedToken;
    pv = (PVOID)CreateServiceA;
    pv = (PVOID)CreateServiceW;


}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\SDK\test\maketrac.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  maketrac.cpp
//
//  Creator: Galen C. Hunt (galenh), Rob Stets (stets@cs.rochester.edu)
//
//  Copyright 1996 - 1999 Microsoft Corporation.  All rights reserved.
//
//  Revision History
//   11-1999: Lee Hart, change to log only counts of API calls, not each & every API call.

#include <windows.h>
#include <assert.h>
#include <string.h>
#include <stdlib.h>
#include <ctype.h>
#include <iostream.h>

#include "ast.h"

#ifndef INC_AstCL_H
#include "AstCL.h"
#endif

#ifndef INC_TOOLKIT_H
#include "toolkit.h"
#endif

//////////////////////////////////////////////////////////////////////

#ifndef _DEFINED_ASMBREAK_
#define _DEFINED_ASMBREAK_
#define ASMBREAK()  __asm { int 3 }
//#define ASMBREAK()    DebugBreak()
#endif  // _DEFINED_ASMBREAK_


#define ASSERT_ALWAYS(x)   \
    do {                                                        \
    if (!(x)) {                                                 \
            AssertMessage(#x, __FILE__, __LINE__);              \
            ASMBREAK();                                         \
    }                                                           \
    } while (0)

#ifndef NDEBUG
#define ASSERT(x)           ASSERT_ALWAYS(x)
#else
#define ASSERT(x)
#endif

#define UNUSED(c)    (c) = (c)

//////////////////////////////////////////////////////////////////////////////
//
void AssertMessage(CONST PCHAR pszMsg, CONST PCHAR pszFile, ULONG nLine)
{
    printf("ASSERT(%s) failed in %s, line %d.\n", pszMsg, pszFile, nLine);
}

////////////////////////////////////////////////////////// Assertion Handling.
//

//
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
//
static char * CallingConventionToString(CallingConvention cc)
{
    switch (cc) {
    case ccC:           return "__cdecl";
    case ccPascal:      return "__pascal";
    case ccFastCall:    return "__fastcall";
    case ccStdCall:     return "__stdcall";
    case ccSysCall:     return "__syscall";
    default:    ASSERT(!"Unsupported CallingConvention."); return NULL;
    }
}

static char * PrimitiveKindToString(PrimitiveKind pk)
{
    switch (pk) {
    case ptChar:        return "char";
    case ptSChar:       return "signed char";
    case ptUChar:       return "unsigned char";
    case ptSShort:      return "short";
    case ptUShort:      return "unsigned short";
    case ptSInt:        return "int";
    case ptUInt:        return "unsigned int";
    case ptSLong:       return "long";
    case ptULong:       return "unsigned long";
    case ptSInt64:      return "__int64";
    case ptUInt64:      return "unsigned __int64";
    case ptFloat:       return "float";
    case ptDouble:      return "double";
    case ptLDouble:     return "long double";
    case ptVoid:        return "void";
    case ptWChar:       return "WCHAR";
    default:    ASSERT(!"Unsupported PrimitiveKind."); return NULL;
    }
}

static PCHAR StrAdv(PCHAR pszOut, CONST CHAR *pszIn)
{
    while (*pszOut) {
        pszOut++;
    }
    if (__iscsym(pszOut[-1]) && __iscsym(pszIn[0])) {
        *pszOut++ = ' ';
    }
    while (*pszIn) {
        *pszOut++ = *pszIn++;
    }
    *pszOut = '\0';
    return pszOut;
}

void DumpTypeToString(char *pszOut, Type *ptArg, TypeIndex tiStop, char *pszStop, BOOL fConst)
{
    if (ptArg == NULL)
        return;

    if (ptArg->GetIndex() == tiStop) {
        pszOut = StrAdv(pszOut, pszStop);
        return;
    }

    switch (ptArg->GetTypeKind()) {

    case tkPrimitive:
        {
            TypePrimitive *pt = ptArg->asPrimitive();

            pszOut = StrAdv(pszOut, PrimitiveKindToString(pt->GetPrimitiveKind()));
        } break;

    case tkPointer:
        {
            TypePointer *pt =  ptArg->asPointer();
            pt = static_cast<TypePointer *>(ptArg);

            if (pt->FVolatile()) {
                pszOut = StrAdv(pszOut, "volatile");
            }
            if (pt->FConst() && fConst) {
                pszOut = StrAdv(pszOut, "const");
            }

            DumpTypeToString(pszOut, pt->GetTargetType(), tiStop, pszStop, fConst);
            if (pt->GetPointerKind() == pkReference) {
                pszOut = StrAdv(pszOut, "&");
            }
            else {
                pszOut = StrAdv(pszOut, "*");
            }
        } break;

    case tkArray:
        {
            TypeArray *pt = ptArg->asArray();

            DumpTypeToString(pszOut, pt->GetElemType(), tiStop, pszStop, fConst);
            pszOut = StrAdv(pszOut, "[");
            if (pt->GetLength()) {
                sprintf(pszOut, "%d", pt->GetLength());
            }
            pszOut = StrAdv(pszOut, "]");
        } break;

    case tkStruct:
        {
            TypeStruct *pt = ptArg->asStruct();
            pszOut = StrAdv(pszOut, "struct");
            pszOut = StrAdv(pszOut, pt->GetParseName());
        } break;

    case tkClass:
        {
            TypeClass *pt = ptArg->asClass();

            pszOut = StrAdv(pszOut, "class");
            pszOut = StrAdv(pszOut, pt->GetParseName());
        } break;

    case tkUnion:
        {
            TypeUnion *pt = ptArg->asUnion();

            pszOut = StrAdv(pszOut, "union");
            pszOut = StrAdv(pszOut, pt->GetParseName());
        } break;

    case tkEnum:
        {
            TypeEnum *pt = ptArg->asEnum();

            pszOut = StrAdv(pszOut, "enum");
            pszOut = StrAdv(pszOut, pt->GetParseName());
        } break;

    case tkModifier:
        {
            TypeModifier *pt = static_cast <TypeModifier *>(ptArg);

            if (pt->FVolatile()) {
                pszOut = StrAdv(pszOut, "volatile");
            }
            if (pt->FConst() && fConst) {
                pszOut = StrAdv(pszOut, "const");
            }
            DumpTypeToString(pszOut, pt->GetBaseType(), tiStop, pszStop, fConst);
        } break;

    case tkTypedef:
        {
            TypeTypedef *pt = ptArg->asTypedef();

            pszOut = StrAdv(pszOut, pt->GetSymbol()->GetName());
        } break;

    case tkProcedure:
        {
            TypeProcedure *pt = static_cast<TypeProcedure *>(ptArg);

            DumpTypeToString(pszOut, pt->GetReturnType(), -1, NULL, fConst);
            pszOut = StrAdv(pszOut, "(");
            pszOut = StrAdv(pszOut,
                            CallingConventionToString(pt->GetCallingConvention()));
            pszOut = StrAdv(pszOut, "^)(");

            TypeArgumentListIterator Arguments = pt->GetArgumentIterator();
            int nParm;
            Type *ptArgument = NULL;
            for (nParm = 0, ptArgument = Arguments.NextType();
                 ptArgument != NULL;
                 ptArgument = Arguments.NextType(), nParm++) {

                if (nParm) {
                    pszOut = StrAdv(pszOut, ", ");
                }

                DumpTypeToString(pszOut, ptArgument, -1, NULL, fConst);
            }

            if (pt->FVarArgs()) {
                if (nParm) {
                    pszOut = StrAdv(pszOut, ", ");
                }
                pszOut = StrAdv(pszOut, "...");
                nParm++;
            }
            if (nParm == 0) {
                pszOut = StrAdv(pszOut, "void");
            }
            pszOut = StrAdv(pszOut, ")");
        } break;


    default:
        ASSERT(!"Unsupported TypeKind.");
        break;
    }
}

//////////////////////////////////////////////////////////////////////////////
//
class CFunction
{
protected:
    struct CArgument
    {
    public:
        CArgument();
        ~CArgument();

        HRESULT         Initialize(Symbol *psSymbol, Type *ptType, PCHAR pszSpec);

    public:
        PCHAR           m_pszName;
        PCHAR           m_pszSpec;
        PCHAR           m_pszType;

        Type *          m_ptType;
        Symbol *        m_psSymbol;

        BOOL            m_fIsString;
        BOOL            m_fIsUnicode;
        BOOL            m_fIsInput;
        BOOL            m_fIsOutput;

    };

public:
    CFunction();
    ~CFunction();

    HRESULT         Initialize(SymbolCommonFunctionStuff *psSymbol);

    PCHAR           GetFunctionName()           { return m_pszName; }
    PCHAR           GetFunctionSpec()           { return m_pszSpec; }
    PCHAR           GetFunctionCallConv();

    PCHAR           GetReturnType()             { return m_pRetVal->m_pszType; }

    CArgument       *GetArgument(INT nArg)      { return m_pArgs[nArg]; }

    PCHAR           GetArgumentName(INT nArg)   { return m_pArgs[nArg]
                                                      ? m_pArgs[nArg]->m_pszName
                                                      : "..."; }
    PCHAR           GetArgumentSpec(INT nArg)   { return m_pArgs[nArg]
                                                      ? m_pArgs[nArg]->m_pszSpec
                                                      : NULL; }
    PCHAR           GetArgumentType(INT nArg)   { return m_pArgs[nArg]
                                                      ? m_pArgs[nArg]->m_pszType
                                                      : NULL; }
    BOOL            IsArgumentString(INT nArg)
    {
        return m_pArgs[nArg] ? m_pArgs[nArg]->m_fIsString : FALSE;
    }
    BOOL            IsArgumentUnicode(INT nArg)
    {
        return m_pArgs[nArg] ? m_pArgs[nArg]->m_fIsUnicode : FALSE;
    }
    BOOL            IsArgumentInput(INT nArg)
    {
        return m_pArgs[nArg] ? m_pArgs[nArg]->m_fIsInput : FALSE;
    }
    BOOL            IsArgumentOutput(INT nArg)
    {
        return m_pArgs[nArg] ? m_pArgs[nArg]->m_fIsOutput : FALSE;
    }

    BOOL            IsReturnString()
    {
        return m_pRetVal->m_fIsString;
    }
    BOOL            IsReturnUnicode()
    {
        return m_pRetVal->m_fIsUnicode;
    }

    INT             GetArgumentCount()          { return m_nArgs; }
    BOOL            IsVoid()                    { return m_fVoid; }
    BOOL            HasVarArgs()                { return m_fVarArgs; }

    static VOID     SetTypeManager(TypeManager *ptmTypeManager);

protected:
    PCHAR           m_pszName;
    PCHAR           m_pszSpec;

    BOOL            m_fVoid;
    BOOL            m_fVarArgs;
    INT             m_nArgs;

    CArgument *     m_pRetVal;
    CArgument **    m_pArgs;

    AstFuncDecl *   m_pafdDeclaration;
    TypeProcedure * m_ptpType;
    SymbolCommonFunctionStuff * m_pscfsSymbol;

protected:
    static TypeManager *    s_ptmTypeManager;
};

//////////////////////////////////////////////////////////////////////////////
//
VOID CFunction::SetTypeManager(TypeManager *ptmTypeManager)
{
    s_ptmTypeManager = ptmTypeManager;
}

CFunction::CArgument::CArgument()
{
    m_pszName = NULL;
    m_pszSpec = NULL;
    m_pszType = NULL;

    m_ptType = NULL;
    m_psSymbol = NULL;

    m_fIsString = FALSE;
    m_fIsUnicode = FALSE;
    m_fIsInput = TRUE;
    m_fIsOutput = FALSE;
}

HRESULT CFunction::CArgument::Initialize(Symbol *psSymbol, Type *ptType, PCHAR pszSpec)
{
    ASSERT(m_ptType == NULL);                           // Only call once.

    m_ptType = ptType;
    m_psSymbol = psSymbol;

    if (pszSpec) {
        m_pszSpec = pszSpec;
    }
    if (psSymbol) {
        pszSpec = psSymbol->GetLintSpec();
        if (pszSpec && pszSpec[0] == '\0') {
            pszSpec = NULL;
        }
        if (pszSpec) {
            m_pszSpec = pszSpec;
        }
        // Type *ptRetyped = s_ptmTypeManager->RetypeSymbol(psSymbol);
    }

    if (m_pszSpec) {
        m_fIsInput = (strchr(m_pszSpec, 'i') != NULL);
        m_fIsOutput = (strchr(m_pszSpec, 'o') != NULL);
    }

    Type *ptStop = NULL;
    CHAR *pszStop = NULL;
    TypeIndex tiStop = -1;

    if (psSymbol) {
        ptStop = psSymbol->GetType();
        tiStop = ptStop->GetIndex();
        pszStop = psSymbol->GetName();
    }

    CHAR szOut[1024];
    szOut[0] = '\0';
    szOut[1] = '\0';
#if 0
    DumpTypeToString(&szOut[1], ptType, NULL, pszStop, FALSE);
#else
    DumpTypeToString(&szOut[1], ptType, tiStop, pszStop, FALSE);
#endif

    INT cbLen = strlen(&szOut[1]) + 1;
    m_pszType = new CHAR [cbLen];
    ASSERT(m_pszType);

    strcpy(m_pszType, &szOut[1]);

    if (strcmp(m_pszType, "PSTR") == 0) {
        m_fIsString = TRUE;
        m_fIsUnicode = FALSE;
    }
    else if (strcmp(m_pszType, "PWSTR") == 0) {
        m_fIsString = TRUE;
        m_fIsUnicode = TRUE;
    }
    else if (strcmp(m_pszType, "LPSTR") == 0) {
        m_fIsString = TRUE;
        m_fIsUnicode = FALSE;
    }
    else if (strcmp(m_pszType, "LPCSTR") == 0) {
        m_fIsString = TRUE;
        m_fIsUnicode = FALSE;
    }
    else if (strcmp(m_pszType, "LPCWSTR") == 0) {
        m_fIsString = TRUE;
        m_fIsUnicode = TRUE;
    }
    else if (strcmp(m_pszType, "LPWSTR") == 0) {
        m_fIsString = TRUE;
        m_fIsUnicode = TRUE;
    }
    return S_OK;
}

CFunction::CArgument::~CArgument()
{
    if (m_pszType) {
        delete[] m_pszType;
        m_pszType = NULL;
    }
    m_pszName = NULL;
    m_pszSpec = NULL;
    m_psSymbol = NULL;
    m_ptType = NULL;
}

//////////////////////////////////////////////////////////////////////////////
//
TypeManager *   CFunction::s_ptmTypeManager = NULL;

CFunction::CFunction()
{
    m_pszName = NULL;
    m_pszSpec = NULL;

    m_fVoid = FALSE;
    m_fVarArgs = FALSE;

    m_nArgs = 0;
    m_pArgs = NULL;
    m_pRetVal = NULL;

    m_pafdDeclaration = NULL;
    m_ptpType = NULL;
    m_pscfsSymbol = NULL;

}

HRESULT CFunction::Initialize(SymbolCommonFunctionStuff *pscfsSymbol)
{
    ASSERT(m_pscfsSymbol == NULL);                      // Only call once.

    ASSERT(pscfsSymbol->GetKind() == skImport ||
           pscfsSymbol->GetKind() == skFunction);

    m_pscfsSymbol = pscfsSymbol;
    m_pszName = pscfsSymbol->GetName();
    m_pszSpec = pscfsSymbol->GetLintSpec();
    if (m_pszSpec && m_pszSpec[0] == '\0')
        m_pszSpec = NULL;

    Symbol *psDecl = NULL;
    if (pscfsSymbol->GetKind() == skFunction) {
        psDecl = (static_cast <SymbolFunction *>(pscfsSymbol))->GetDeclaredType();
    }
    else if (pscfsSymbol->GetKind() == skImport) {
        psDecl = (static_cast <SymbolImport *>(pscfsSymbol))->GetDeclaredType();
    }
    else {
        ASSERT(!"Unsupported symbol kind.");
    }

    m_pafdDeclaration = static_cast <AstFuncDecl *>(pscfsSymbol->GetDeclaration());;
    ASSERT(m_pafdDeclaration->FDeclaration());
    ASSERT(m_pafdDeclaration->GetOpCode() == ocFuncDecl);

    m_ptpType = static_cast <TypeProcedure *>(pscfsSymbol->GetType());;
    ASSERT(m_ptpType->GetTypeKind() == tkProcedure);

    m_fVarArgs = m_ptpType->FVarArgs();
    m_fVoid = FALSE;

    if (m_ptpType->GetReturnType()) {
        TypePrimitive *pt = static_cast <TypePrimitive *>(m_ptpType->GetReturnType());
        if (pt->GetTypeKind() == tkPrimitive && pt->GetPrimitiveKind() == ptVoid) {
            m_fVoid = TRUE;
        }
    }

    m_nArgs = m_pafdDeclaration->GetParameterCount();
    Symbol ** psParms = m_pafdDeclaration->GetParameterDeclaredTypeVector();
    char **ppszSpecs = m_pafdDeclaration->GetParameterLintSpecVector();

    m_pRetVal = new CArgument;
    ASSERT(m_pRetVal);
    m_pArgs = new CArgument * [m_nArgs];
    ASSERT(m_pArgs);
    for (INT nArg = 0; nArg < m_nArgs; nArg++) {
        m_pArgs[nArg] = NULL;
    }

    m_pRetVal->Initialize(psDecl, m_ptpType->GetReturnType(), NULL);

    TypeArgumentListIterator Arguments = m_ptpType->GetArgumentIterator();
    Type *ptArgument = NULL;
    for (nArg = 0, ptArgument = Arguments.NextType();
         ptArgument != NULL;
         ptArgument = Arguments.NextType(), nArg++) {

        Symbol *psSymbol = NULL;
        if (nArg < m_nArgs && psParms && psParms[nArg]) {
            psSymbol = psParms[nArg];
        }

        m_pArgs[nArg] = new CArgument;
        ASSERT(m_pArgs[nArg]);

        m_pArgs[nArg]->Initialize(psSymbol,
                                  ptArgument,
                                  ppszSpecs ? ppszSpecs[nArg] : NULL);
    }

    if (m_fVarArgs) {
        ASSERT(nArg + 1 == m_nArgs);
    }
    else {
        if (nArg != m_nArgs) {
            printf("AST made error in counting args for %s (%d != %d).\n",
                   m_pszName, nArg, m_nArgs);
        }
        // @todo: Sometimes AST lies about the argument count: ASSERT(nArg == m_nArgs);
    }
    if (m_fVoid) {
        ASSERT(GetReturnType());
    }

    return S_OK;
}

CFunction::~CFunction()
{
    if (m_pRetVal) {
        delete m_pRetVal;
        m_pRetVal = NULL;
    }
    if (m_pArgs) {
        for (INT n = 0; n < m_nArgs; n++) {
            if (m_pArgs[n]) {
                delete m_pArgs[n];
                m_pArgs[n] = NULL;
            }
        }
        delete m_pArgs;
        m_pArgs = NULL;
    }
}

PCHAR CFunction::GetFunctionCallConv()
{
    ASSERT(m_ptpType);
    return CallingConventionToString(m_ptpType->GetCallingConvention());
}

//////////////////////////////////////////////////////////////////////////////
//

class COutputFile
{
public:
    COutputFile();
    ~COutputFile();

    HRESULT     Initialize(PCHAR pszFile);
    HRESULT     Print(PCHAR pszMsg, ...);

protected:
    FILE *      m_pFile;
    BOOL        m_fOnNewLine;
    INT         m_nColumn;
    INT         m_nIndent;
    INT         m_nParens;
    INT         m_nParenIndents[64];
};

COutputFile::COutputFile()
{
    m_pFile = NULL;
    m_nColumn = 0;
    m_nIndent = 0;
    m_nParens = 0;
    m_fOnNewLine = FALSE;
}

COutputFile::~COutputFile()
{
    if (m_pFile) {
        fclose(m_pFile);
        m_pFile = NULL;
    }
}

HRESULT COutputFile::Initialize(PCHAR pszFile)
{
    ASSERT(m_pFile == NULL);                            // Only call once.
    ASSERT(pszFile);

    m_pFile = fopen(pszFile, "w");
    if (FAILED(m_pFile)) {
        return E_FAIL;
    }

    return S_OK;
}

HRESULT COutputFile::Print(PCHAR pszMsg, ...)
{
    CHAR szBuffer[2048];
    double d = 0.0;                                     // Required for FP support

    va_list args;
    va_start(args, pszMsg);

    vsprintf(szBuffer, pszMsg, args);

    for (PCHAR psz = szBuffer; *psz; psz++) {
        if (*psz == '\n') {
            m_fOnNewLine = TRUE;
            fputc(*psz, m_pFile);
            m_nColumn = 0;
        }
        else {
            if (*psz == '}') {
                m_nIndent -= 4;
            }

            if (m_fOnNewLine) {
                for (INT n = 0; n < m_nIndent; n++) {
                    fputc(' ', m_pFile);
                }
                m_nColumn = m_nIndent;
                m_fOnNewLine = FALSE;
            }

            if (*psz == '\t') {
                INT nSpace = (m_nColumn + 4) % 4;
                m_nColumn += nSpace - 1;                // 1 for char default below.
            }
            else if (*psz == '(') {
                m_nParenIndents[m_nParens++] = m_nIndent;
                m_nIndent = m_nColumn + 1;
            }
            else if (*psz == ')') {
                ASSERT(m_nParens > 0);
                m_nIndent = m_nParenIndents[--m_nParens];
            }
            else if (*psz == '{') {
                m_nIndent += 4;
            }

            fputc(*psz, m_pFile);
            m_nColumn++;
        }
    }
    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////
//
VOID DumpTrampoline(COutputFile *pcof, CFunction *pcd)
{
    pcof->Print("\n");
    pcof->Print("DETOUR_TRAMPOLINE(%s %s ",
                pcd->GetReturnType(),
                pcd->GetFunctionCallConv());
    pcof->Print("Real_%s(", pcd->GetFunctionName());

    INT nArgs = pcd->GetArgumentCount();
    for (INT nArg = 0; nArg < nArgs; nArg++) {
        if (pcd->GetArgumentType(nArg)) {
            pcof->Print("%s ", pcd->GetArgumentType(nArg));
        }
        if (pcd->GetArgumentName(nArg)) {
            pcof->Print("%s", pcd->GetArgumentName(nArg));
        }
        else {
            pcof->Print("a%d", nArg);
        }
        if (nArg < nArgs - 1) {
            pcof->Print(",\n");
        }
    }
    if (nArgs == 0) {
        pcof->Print("void");
    }
    pcof->Print("),\n");
    pcof->Print("%s);\n", pcd->GetFunctionName());
}

//////////////////////////////////////////////////////////////////////////////
//
VOID DumpTrampolineWith(COutputFile *pcof, CFunction *pcd)
{
    pcof->Print("DetourFunctionWithTrampoline((PBYTE)Real_%s,\n",
                pcd->GetFunctionName());
    pcof->Print("(PBYTE)Mine_%s);\n",
                pcd->GetFunctionName());
}

//////////////////////////////////////////////////////////////////////////////
//
VOID PrintEnter(COutputFile *pcof, CFunction *pcd)
{
    INT nArgs = pcd->GetArgumentCount();
    INT nArg;

    BOOL bHasString = FALSE;
    for (nArg = 0; nArg < nArgs; nArg++) {
        if (pcd->IsArgumentString(nArg) && pcd->IsArgumentInput(nArg)) {
            bHasString = TRUE;
            break;
        }
    }
#ifdef ONLY_PRINT_STRINGS
    if (!bHasString) {
        return;
    }
#endif

    pcof->Print("//_PrintEnter(\"%s(", pcd->GetFunctionName());
#ifdef LIMIT_TO_FIRST_FOUR_ARGUMENTS
    if (nArgs > 4) {
        nArgs = 4;
    }
#endif
    for (nArg = 0; nArg < nArgs; nArg++) {
        PCHAR pszSpec = pcd->GetArgumentSpec(nArg);

        if (pcd->IsArgumentString(nArg) && pcd->IsArgumentInput(nArg)) {
            if (pcd->IsArgumentUnicode(nArg)) {
                pcof->Print("%%ls");
            }
            else {
                pcof->Print("%%hs");
            }
        }
        else {
            pcof->Print("%%lx");
        }
        if (nArg < (nArgs - 1))
            pcof->Print(",");
    }
    pcof->Print(")\\n\"");
    for (nArg = 0; nArg < nArgs; nArg++) {
        pcof->Print(", ");
        if (pcd->GetArgumentName(nArg)) {
            pcof->Print("%s", pcd->GetArgumentName(nArg));
        }
        else {
            pcof->Print("a%d", nArg);
        }
    }
    pcof->Print(");\n\n");
}

//////////////////////////////////////////////////////////////////////////////
//
VOID PrintExit(COutputFile *pcof, CFunction *pcd, PCHAR pszRtn)
{
    INT nArgs = pcd->GetArgumentCount();
    INT nArg;

    BOOL bHasString = FALSE;
    for (nArg = 0; nArg < nArgs; nArg++) {
        if (pcd->IsArgumentString(nArg) && pcd->IsArgumentOutput(nArg)) {
            bHasString = TRUE;
            break;
        }
    }
#ifdef ONLY_PRINT_STRINGS
    if (!bHasString) {
        return;
    }
#endif

    pcof->Print("//_PrintExit(\"%s(", pcd->GetFunctionName());
#ifdef LIMIT_TO_FIRST_FOUR_ARGUMENTS
    if (nArgs > 4) {
        nArgs = 4;
    }
#endif
    for (nArg = 0; nArg < nArgs; nArg++) {
        if (pcd->IsArgumentString(nArg) && pcd->IsArgumentOutput(nArg)) {
            if (pcd->IsArgumentUnicode(nArg)) {
                pcof->Print("%%ls");
            }
            else {
                pcof->Print("%%hs");
            }
        }
        if (nArg < (nArgs - 1))
            pcof->Print(",");
    }
    pcof->Print(")");
    if (pszRtn) {
        if (pcd->IsReturnString()) {
            if (pcd->IsReturnUnicode()) {
                pcof->Print(" -> %%ls\\n\"");
            }
            else {
                pcof->Print(" -> %%hs\\n\"");
            }
        }
        else {
            pcof->Print(" -> %%lx\\n\"");
        }
    }
    else {
        pcof->Print(" ->\\n\"");
    }
    for (nArg = 0; nArg < nArgs; nArg++) {
        if (pcd->IsArgumentString(nArg) && pcd->IsArgumentOutput(nArg)) {
            pcof->Print(", ");
            if (pcd->GetArgumentName(nArg)) {
                pcof->Print("%s", pcd->GetArgumentName(nArg));
            }
            else {
                pcof->Print("a%d", nArg);
            }
        }
    }
    if (pszRtn)
        pcof->Print(", %s", pszRtn);
    pcof->Print(");\n");
}

//////////////////////////////////////////////////////////////////////////////
//
VOID DumpDetour(COutputFile *pcof, CFunction *pcd, PCHAR pszInterfaceVar, DWORD dwImport)
{

    pcof->Print("%s %s ",
                pcd->GetReturnType(),
                pcd->GetFunctionCallConv());
    pcof->Print("Mine_%s(", pcd->GetFunctionName());

    INT nArgs = pcd->GetArgumentCount();
    for (INT nArg = 0; nArg < nArgs; nArg++) {

        if (pcd->GetArgumentType(nArg)) {
            pcof->Print("%s ", pcd->GetArgumentType(nArg));
        }
        if (pcd->GetArgumentName(nArg)) {
            pcof->Print("%s", pcd->GetArgumentName(nArg));
        }
        else {
            pcof->Print("a%d", nArg);
        }
        if (nArg < nArgs - 1) {
            pcof->Print(",\n");
        }
    }
    if (nArgs == 0) {
        pcof->Print("void");
    }
    pcof->Print(")\n");
    pcof->Print("{\n");

    PrintEnter(pcof, pcd);

    if (!pcd->IsVoid()) {
        pcof->Print("%s rv = 0;\n", pcd->GetReturnType());
        pcof->Print("__try {\n");
        pcof->Print("rv = ");
    }
    else {
        pcof->Print("__try {\n");
    }

    pcof->Print("Real_%s(", pcd->GetFunctionName());

    nArgs = pcd->GetArgumentCount();
    for (nArg = 0; nArg < nArgs; nArg++) {
        if (pcd->GetArgumentName(nArg)) {
            pcof->Print("%s", pcd->GetArgumentName(nArg));
        }
        else {
            pcof->Print("a%d", nArg);
        }
        if (nArg < nArgs - 1) {
            pcof->Print(", ");
        }
    }
    pcof->Print(");\n");
    pcof->Print("} __finally {\n");
    PrintExit(pcof, pcd, (pcd->IsVoid() ? NULL : "rv"));
    pcof->Print("};\n");

    pcof->Print("m_dwAPICount[%d]++;\n",dwImport);
    if (!pcd->IsVoid()) {

        pcof->Print("return rv;\n");
    }

    pcof->Print("}\n");
}

//////////////////////////////////////////////////////////////////////////////
//
VOID DumpCleanup(COutputFile *pcof, CFunction *pcd, DWORD dwImport)
{

  pcof->Print("if (m_dwAPICount[%d]) {\n",dwImport);
  pcof->Print("_Print(\"\\t%s\\t",pcd->GetFunctionName());
  pcof->Print("%%");
  pcof->Print("d\\n\",m_dwAPICount[%d]);\n}\n",dwImport );

 }

//////////////////////////////////////////////////////////////////////////////
//
int __cdecl CompareFunctionNames(const void *e1, const void *e2)
{
    CFunction *pcf1 = *(CFunction **)e1;
    CFunction *pcf2 = *(CFunction **)e2;

    return strcmp(pcf1->GetFunctionName(), pcf2->GetFunctionName());
}

//////////////////////////////////////////////////////////////////////////////
//
CHAR *aszFilters[] = {
    "memcmp",
    "memset",
    "DeleteCriticalSection",
    "EnterCriticalSection",
    "InitializeCriticalSection",
    "LeaveCriticalSection",
    "GetLastError",
    "SetLastError",
    "TlsAlloc",
    "TlsFree",
    "TlsGetValue",
    "TlsSetValue",
    "UnhandledExceptionFilter",
    "VirtualAlloc",
    "VirtualFree",
    "VirtualLock",
    "VirtualProtect",
    "VirtualQuery",
    "VirtualUnlock",
    "GetProcessHeap",
    "HeapAlloc",
    "HeapCompact",
    "HeapCreate",
    "HeapDestroy",
    "HeapFree",
    "HeapReAlloc",
    "HeapSize",
    "HeapValidate",
    "HeapWalk",
    "InterlockedDecrement",
    "InterlockedExchange",
    "InterlockedIncrement"
};


INT nFilters = sizeof(aszFilters) / sizeof(CHAR *);


BOOL FFilterImport(const CHAR *pszName)
{
    BOOL  fRes = FALSE;

    for(INT i=0; (i < nFilters) && (FALSE == fRes); i++) {

        fRes = (BOOL)(0 == strcmp(pszName, aszFilters[i]));
    }

    return fRes;
}

class CompilerInterface : public AstCL
{
public:
    CompilerInterface() : AstCL()
    {
    }

    // Uses c1 or c1xx from AstCL

    int c2(char **args)
    {
        // Read c1/c1xx temp files into AST format
        ReadModule(args);

        CFunction::SetTypeManager(module->GetTypeManager());

        SymbolTable *Globals = module->GetGlobalSymbolTable();
        SymbolTableMaskedEntryIterator Symbols
            = Globals->GetMaskedEntryIterator(skImport);

        INT nImports = 0;
        for (Symbol *psSymbol = Symbols.NextSymbol();
             psSymbol != NULL;
             psSymbol = Symbols.NextSymbol()) {

            if (FFilterImport(psSymbol->GetName()))
                continue;

            AstNode *panDeclaration = psSymbol->GetDeclaration();
            if (panDeclaration == NULL ||
                panDeclaration->FCompilerGenerated()) {

                continue;
            }

            if (psSymbol->GetKind() == skImport) {
                nImports++;
            }
        }

        CFunction **pImports = new CFunction * [nImports];
        ASSERT(pImports);
        for (INT nImport = 0; nImport < nImports; nImport++) {
            pImports[nImport] = NULL;
        }

        nImport = 0;
        Symbols = Globals->GetMaskedEntryIterator(skImport);
        for (psSymbol = Symbols.NextSymbol();
             psSymbol != NULL;
             psSymbol = Symbols.NextSymbol()) {

            if (FFilterImport(psSymbol->GetName()))
                continue;

            AstNode *panDeclaration = psSymbol->GetDeclaration();
            if (panDeclaration == NULL ||
                panDeclaration->FCompilerGenerated()) {

                continue;
            }

            if (psSymbol->GetKind() == skImport) {
                pImports[nImport] = new CFunction;
                ASSERT(pImports[nImport]);

                pImports[nImport++]->Initialize(static_cast <SymbolImport *>(psSymbol));
            }
        }
        ASSERT(nImports == nImport);

        qsort(pImports, nImports, sizeof(pImports[0]), CompareFunctionNames);

        //////////////////////////////////////////////////////////////////////
        //
        COutputFile coutput;

        coutput.Initialize(objName);
        coutput.Print("/////////////////////////////////////////////////////////////\n");
        coutput.Print("//\n");
        coutput.Print("//  %s - Generated by MakeTrac from %s\n", objName, fileName);
        coutput.Print("//\n");
        coutput.Print("\n");
        coutput.Print("/////////////////////////////////////////////////////////////\n");
        coutput.Print("// Globals\n");
        coutput.Print("//\n");
        coutput.Print("DWORD m_dwAPICount[%d];\n",nImports);

        coutput.Print("/////////////////////////////////////////////////////////////\n");
        coutput.Print("// Trampolines\n");
        coutput.Print("//\n");
        for (nImport = 0; nImport < nImports; nImport++) {
            DumpTrampoline(&coutput, pImports[nImport]);
        }

        coutput.Print("\n");
        coutput.Print("/////////////////////////////////////////////////////////////\n");
        coutput.Print("// Detours\n");
        coutput.Print("//\n");
        for (nImport = 0; nImport < nImports; nImport++) {
            coutput.Print("\n");
            DumpDetour(&coutput, pImports[nImport], "pIWin32", nImport);
        }

        coutput.Print("\n");
        coutput.Print("/////////////////////////////////////////////////////////////\n");
        coutput.Print("// TrampolineWith\n");
        coutput.Print("//\n");
        coutput.Print("VOID TrampolineWith(VOID)\n");
        coutput.Print("{\n");
        for (nImport = 0; nImport < nImports; nImport++) {
            DumpTrampolineWith(&coutput, pImports[nImport]);
        }
        coutput.Print("}\n");

        coutput.Print("\n");
        coutput.Print("/////////////////////////////////////////////////////////////\n");
        coutput.Print("// Cleanup\n");
        coutput.Print("//\n");
        coutput.Print("VOID Cleanup(VOID)\n");
        coutput.Print("{\n");
        for (nImport = 0; nImport < nImports; nImport++) {
            DumpCleanup(&coutput, pImports[nImport], nImport);
        }
        coutput.Print("}\n");

        if (pImports) {
            for (nImport = 0; nImport < nImports; nImport++) {
                if (pImports[nImport]) {
                    delete pImports[nImport];
                    pImports[nImport] = NULL;
                }
            }
            delete[] pImports;
            pImports = NULL;
        }

        delete module;
        delete ilPath;

        return 0;
    }

    int link(char **args)
    {
        return 0;
    }

};

//////////////////////////////////////////////////////////////////////////////
//

int main(int argc, char **argv)
{
    Astlib::Initialize(stderr);

    CompilerInterface hooks;
    int rc = RunCL(&hooks, argc, argv);

    Astlib::Finalize();

    return rc;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\SDK\test\include\astcl.h ===
// -*- Mode:C++ -*-
//
//      Copyright (c) 1996 Microsoft Corporation.  All rights reserved.
//
//    This work is a trade secret of Microsoft Corporation.
//    Unauthorized disclosure is unlawful.
//
// $Header: /ast/driver\60/AstCL.h 1     8/27/98 4:30p Lindaog $
// $NoKeywords: $
//
//
// File:    driver/AstCL.h
// Creator: 

// Exported Function List: 
#ifndef INC_AstCL_H
#define INC_AstCL_H

#include "astdriver.h"

BEGIN_AST_NAMESPACE

// This class contains methods that are called by the driver to
// emulate the various compiler passes. Each pass receives an argv-style
// argument list (use GetPassname() to get the name of the executable).
// The result of these functions is treated as a program exit code.

// For a particular analysis frontend, the user should create a subclass
// of AstCL that defines appropriate c1/c1xxx/c2/link methods. See
// the calltree project for a simple complete example.

class AstCL
{
 public:
    ASTDRIVERAPI AstCL();

    // Default pass implementations.
    // c1 and c1xx call the AST frontend with RunRaw.
    // c2 creates (with ReadModule) and then immediately deletes the
    // AST tree.
    // link executes the link.exe program found in the AST\bin
    // directory.
    ASTDRIVERAPI virtual int c1(char **args);
    ASTDRIVERAPI virtual int c1xx(char **args);
    ASTDRIVERAPI virtual int c2(char **args);
    ASTDRIVERAPI virtual int link(char **args);

    // Utility functions, these should probably be used by inheritors of
    // AstCL to run the frontend and build the AST tree

    ASTDRIVERAPI void ReadModule(char **args);
    // Requires: args (c2 arguments) must specify filename (-f), object name
    //   (-Fo) and IL path (-il).
    // Effects: Reads the IL files specified by the c2 arguments in 'args',
    //   and builds an AST tree from that. ilPath is initialised with
    //   the IL path, module points to the loaded AST tree.
    //   fileName, objName and ilName are also initialised from the c2
    //   arguments.

    ASTDRIVERAPI static int ASTDRIVERCALL
      RunRawPath(char *astc1path, char **args, bool fDll = TRUE);
    // Requires:
    //   astc1path (of astc1(xx) to execute)
    //   args (original c1 arguments),
    //   fDll indicates whether args were produced
    //   by c1.dll (TRUE) or c1.exe (FALSE)
    // Effects:
    //   Executes the AST frontend (astc1path)
    //   with c1 arguments 'args', modified as follows:
    //     c1 (c1xx) in args[0] becomes astc1 (astc1xx)
    //     -Zi/-Z7 is added
    //     -Yd is added if -Yc is present
    //     if arguments are in DLL form (i.e., unquoted)
    //       and AST frontend is an .EXE,
    //       arguments will be quoted before being passed

    ASTDRIVERAPI static int ASTDRIVERCALL
      RunRaw(char **args, bool fDll = TRUE)
      { return RunRawPath(args[0], args, fDll); }
    // RunRaw is being deprecated;
    // replace RunRaw(args) with
    //         RunRawPath(GetPassname(), args,
    //                    FPassIsDLL(pkC1{XX}))

    ASTDRIVERAPI static char *GetPassExecutable();
    // When invoking a pass, the driver supplies both an argument vector
    // and the name of the executable to be invoked (which won't *always*
    // be the same as args[0]; args[0] can have quotes in it...)
    // The former is passed to the hook routine as ARGS, GetPassExecutable()
    // retrieves the latter.  Since this returns a pointer to static
    // storage, you must copy it if you need it beyond the return of
    // the hook routine.

    enum PassKind { 
        pkC1 = 1,               // C front end
        pkC1XX,                 // C++ front end
        pkC2,                   // back end
        pkLINK,                 // linker

        pkERROR = -1,
    };

    ASTDRIVERAPI static bool FPassIsDLL(PassKind);
    // Is the given pass a .dll pass?
    // TRUE  => arguments are pristine.
    // FALSE => arguments are quoted.
    // Should be called only from hook routines.

    ASTDRIVERAPI static PassKind 
      PathnameToPassKind(char *name, bool *fDebug = NULL);
    // Return the PassKind corresponding to the executable NAME
    // no matter whether this points to
    //   the real version of a pass executable (e.g., ...\c1.dll)
    //   or our own version (e.g., ...\astcl.exe).
    // If FDEBUG non-null, set *FDEBUG true according as NAME appears
    // to be a debug version (e.g., ...\c1d.dll).

    ASTDRIVERAPI static bool fAllowC1Warnings;
    // If set FALSE, warnings will be suppressed in astc1(xx) runs.
    // Defaults to TRUE unless environment variable ASTC1WARN="no"

 protected:
    // Current state, set by ReadModule
    char *fileName;
    char *objName; 
    char *ilName;
    IlPath *ilPath;
    Module *module;
};

ASTDRIVERAPI int ASTDRIVERCALL RunCL(AstCL *hks, int argc, char **argv);
// Effects: Runs the usual CL driver, intercepting calls to execute program
//   and calling the methods in hks instead.
// Result: CL's exit code.

END_AST_NAMESPACE

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\SDK\test\apitrace.cpp ===
//////////////////////////////////////////////////////////////////////
//
//	Module:		apitrace.dll
//	Author:		Galen C. Hunt
//	Copyright:	1996-1999, Microsoft Corporation
//

//////////////////////////////////////////////////////////////////////

#define _WIN32_WINNT		0x0400
#define WIN32
#define NT

#define DBG_TRACE   0

#include <windows.h>
#include <stdio.h>
#include "detours.h"

#define PULONG_PTR			PVOID
#define PLONG_PTR			PVOID
#define ULONG_PTR			PVOID
#define LONG_PTR			PVOID
#define ENUMRESNAMEPROCA 	PVOID
#define ENUMRESNAMEPROCW 	PVOID
#define ENUMRESLANGPROCA 	PVOID
#define ENUMRESLANGPROCW 	PVOID
#define ENUMRESTYPEPROCA 	PVOID
#define ENUMRESTYPEPROCW 	PVOID

//////////////////////////////////////////////////////////////////////

#ifndef _DEFINED_ASMBREAK_
#define _DEFINED_ASMBREAK_
#define ASMBREAK()	__asm { int 3 }
//#define ASMBREAK()	DebugBreak()
#endif	// _DEFINED_ASMBREAK_


#define ASSERT_ALWAYS(x)   \
    do {                                                        \
	if (!(x)) {                                                 \
            AssertMessage(#x, __FILE__, __LINE__);              \
			ASMBREAK();                                         \
	}                                                           \
    } while (0)

#ifndef NDEBUG
#define ASSERT(x)           ASSERT_ALWAYS(x)
#else
#define ASSERT(x)
#endif

#define UNUSED(c)    (c) = (c)

//////////////////////////////////////////////////////////////////////

VOID _PrintEnter(const CHAR *psz, ...);
VOID _PrintExit(const CHAR *psz, ...);
VOID _Print(const CHAR *psz, ...);
VOID _VPrint(PCSTR msg, va_list args, PCHAR pszBuf, LONG cbBuf);

//////////////////////////////////////////////////////////////////////////////
//
#include "_win32.cpp"
//
//////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////// Logging System.
//
static PCHAR do_hex(PCHAR pszOut, DWORD dwValue)
{
	CHAR szHex[9];
	for (int nHex = 7; nHex >= 0; nHex--) {
		szHex[nHex] = "0123456789ABCDEF"[dwValue & 0xf];
		dwValue >>= 4;
	}
	for (nHex = 0; nHex < 7 && szHex[nHex] == '0'; nHex++) {
		// skip leading zeros.
	}
	for (; nHex < 8; nHex++) {
		*pszOut++ = szHex[nHex];
	}
	return pszOut;
}

static VOID _VPrint(PCSTR pszMsg, va_list args, PCHAR pszBuffer, LONG cbBuffer)
{
	PCHAR pszOut = pszBuffer;
	pszBuffer[0] = '\0';

	__try {
		while (*pszMsg) {
			if (*pszMsg == '%') {
				pszMsg++;
				
				BOOL fLarge = FALSE;
				if (*pszMsg == 'h') {
					fLarge = FALSE;
					pszMsg++;
				}
				else if (*pszMsg == 'l') {
					fLarge = TRUE;
					pszMsg++;
				}

				if (*pszMsg == 's') {
					pszMsg++;
					PCHAR pszBuf = pszOut;
					PVOID pvData = va_arg(args, PVOID);
					
					__try {
						*pszOut++ = '\"';
						if (fLarge) {
							PWCHAR pwz = (PWCHAR)pvData;

							for (int n = 0; *pwz && n < 120; n++) {
								WCHAR w = *pwz++;
								*pszOut++ = (w >= ' ' && w < 127) ? (CHAR)w : '.';
							}
						}
						else {
							PCHAR psz = (PCHAR)pvData;

							for (int n = 0; *psz && n < 120; n++) {
								CHAR c = *psz++;
								*pszOut++ = (c >= ' ' && c < 127) ? c : '.';
							}
						}
						*pszOut++ = '\"';
					} __except(EXCEPTION_EXECUTE_HANDLER) {
						pszOut = pszBuf;
						*pszOut++ = 'x';
						pszOut = do_hex(pszOut, (DWORD)pvData);
					}
				}
				else if (*pszMsg == 'x') {
					pszMsg++;
					*pszOut++ = 'x';
					pszOut = do_hex(pszOut, va_arg(args, DWORD));
				}	
				else {
					*pszOut++ = *pszMsg++;
				}
			}
			else {
				*pszOut++ = *pszMsg++;
			}
		}
		*pszOut = '\0';
		pszBuffer[cbBuffer - 1] = '\0';
	} __except(EXCEPTION_EXECUTE_HANDLER) {
		strcpy(pszBuffer, "<exception>");
	}
}

class CLog
{
  public:
	static VOID Print(PCSTR msg, ...);
	static VOID Write(PCHAR pszBuf, LONG cbBuf);
	static VOID Close();

  protected:
	static BOOL Open();
	
	static HANDLE	s_hLogFile;
	static WCHAR	s_wzLogFile[];
};

HANDLE 	CLog::s_hLogFile = (HANDLE)-2L;
WCHAR 	CLog::s_wzLogFile[] = L"\\apitrace.log";

BOOL CLog::Open()
{
	if (s_hLogFile == (HANDLE)-2L) {
		s_hLogFile = Real_CreateFileW(s_wzLogFile,
									  GENERIC_WRITE,
									  FILE_SHARE_READ,
									  NULL,
									  CREATE_ALWAYS,
									  FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,
									  NULL);
	}
	return (s_hLogFile != INVALID_HANDLE_VALUE);
}

VOID CLog::Write(PCHAR pszBuf, LONG cbBuf)
{
	if (Open()) {
		DWORD cbWritten = 0;
		Real_WriteFile(s_hLogFile, pszBuf, cbBuf, &cbWritten, NULL);
	}
}

VOID CLog::Close()
{
	if (s_hLogFile != (HANDLE)-2L && s_hLogFile != INVALID_HANDLE_VALUE) {
		Real_CloseHandle(s_hLogFile);
		s_hLogFile = INVALID_HANDLE_VALUE;
	}
}

VOID CLog::Print(PCSTR pszMsg, ...)
{
	CHAR szBuf[4096];
	
	va_list args;
	va_start(args, pszMsg);
	_VPrint(pszMsg, args, szBuf, sizeof(szBuf));
	va_end(args);

	Write(szBuf, strlen(szBuf));
}

//
//////////////////////////////////////////////////////////////////////////////

static BOOL s_bLog = 1;
static LONG s_nTlsIndent = -1;
static LONG s_nTlsThread = -1;
static LONG s_nThreadCnt = 0;

VOID _PrintEnter(const CHAR *psz, ...)
{
	DWORD dwErr = GetLastError();
	
	LONG nIndent = 0;
	LONG nThread = 0;
	if (s_nTlsIndent >= 0) {
		nIndent = (LONG)TlsGetValue(s_nTlsIndent);
		TlsSetValue(s_nTlsIndent, (PVOID)(nIndent + 1));
	}
	if (s_nTlsThread >= 0) {
		nThread = (LONG)TlsGetValue(s_nTlsThread);
	}
		
	if (s_bLog) {
		CHAR szBuf[4096];
		LONG nLen = 3 + (nIndent < 35 ? nIndent * 2 : 70);
		FillMemory(szBuf, nLen, ' ');

		szBuf[0] = '0' + ((nThread / 10) % 10);
		szBuf[1] = '0' + ((nThread / 1) % 10);
		
		va_list  args;
		va_start(args, psz);
		_VPrint(psz, args, szBuf + nLen, sizeof(szBuf) - nLen);
		va_end(args);
		
		CLog::Write(szBuf, strlen(szBuf));
	}
	SetLastError(dwErr);
}

VOID _PrintExit(const CHAR *psz, ...)
{
	DWORD dwErr = GetLastError();
	
	LONG nIndent = 0;
	LONG nThread = 0;
	if (s_nTlsIndent >= 0) {
		nIndent = (LONG)TlsGetValue(s_nTlsIndent) - 1;
		TlsSetValue(s_nTlsIndent, (PVOID)nIndent);
	}
	if (s_nTlsThread >= 0) {
		nThread = (LONG)TlsGetValue(s_nTlsThread);
	}
		
	if (s_bLog) {
		CHAR szBuf[4096];
		LONG nLen = 3 + (nIndent < 35 ? nIndent * 2 : 70);
		FillMemory(szBuf, nLen, ' ');
	
		szBuf[0] = '0' + ((nThread / 10) % 10);
		szBuf[1] = '0' + ((nThread / 1) % 10);
		
		va_list  args;
		va_start(args, psz);
		_VPrint(psz, args, szBuf + nLen, sizeof(szBuf) - nLen);
		va_end(args);
		
		CLog::Write(szBuf, strlen(szBuf));
	}
	SetLastError(dwErr);
}

VOID _Print(const CHAR *psz, ...)
{
	DWORD dwErr = GetLastError();
	
	LONG nIndent = 0;
	LONG nThread = 0;
	if (s_nTlsIndent >= 0) {
		nIndent = (LONG)TlsGetValue(s_nTlsIndent);
	}
	if (s_nTlsThread >= 0) {
		nThread = (LONG)TlsGetValue(s_nTlsThread);
	}

	CHAR szBuf[4096];
	LONG nLen = 3 + (nIndent < 35 ? nIndent * 2 : 70);
	FillMemory(szBuf, nLen, ' ');
	
	szBuf[0] = '0' + ((nThread / 10) % 10);
	szBuf[1] = '0' + ((nThread / 1) % 10);
		
    va_list  args;
    va_start(args, psz);
	_VPrint(psz, args, szBuf + nLen, sizeof(szBuf) - nLen);
    va_end(args);
	
	CLog::Write(szBuf, strlen(szBuf));
	
	SetLastError(dwErr);
}

VOID AssertMessage(CONST PCHAR pszMsg, CONST PCHAR pszFile, ULONG nLine)
{
	CHAR szBuf[512];
    sprintf(szBuf, "ASSERT(%s) failed in %s, line %d.\n", pszMsg, pszFile, nLine);

	CLog::Write(szBuf, strlen(szBuf));
}

VOID NullExport()
{
}

//////////////////////////////////////////////////////////////////////////////
//
// DLL module information
//
BOOL ThreadAttach(HMODULE hDll)
{
	if (s_nTlsIndent >= 0) {
		TlsSetValue(s_nTlsIndent, (PVOID)0);
	}
	if (s_nTlsThread >= 0) {
		LONG nThread = InterlockedIncrement(&s_nThreadCnt);
		TlsSetValue(s_nTlsThread, (PVOID)nThread);
	}
	return TRUE;
}

BOOL ThreadDetach(HMODULE hDll)
{
	if (s_nTlsIndent >= 0) {
		TlsSetValue(s_nTlsIndent, (PVOID)0);
	}
	if (s_nTlsThread >= 0) {
		TlsSetValue(s_nTlsThread, (PVOID)0);
	}
	return TRUE;
}

BOOL ProcessAttach(HMODULE hDll)
{
	s_bLog = FALSE;
	s_nTlsIndent = TlsAlloc();
	s_nTlsThread = TlsAlloc();

	WCHAR wzDllName[MAX_PATH];
	WCHAR wzExeName[MAX_PATH];

	Real_GetModuleFileNameW(hDll, wzDllName, sizeof(wzDllName));
	Real_GetModuleFileNameW(NULL, wzExeName, sizeof(wzExeName));

	CLog::Print("##################################################################\n");
	CLog::Print("### %ls\n", wzExeName);
	CLog::Print("### %ls built %hs %hs\n", wzDllName, __DATE__, __TIME__);
	TrampolineWith();

	ThreadAttach(hDll);
	
	s_bLog = TRUE;
	return TRUE;
}

BOOL ProcessDetach(HMODULE hDll)
{
	ThreadDetach(hDll);
	
	Cleanup();
	s_bLog = FALSE;
	CLog::Close();

	if (s_nTlsIndent >= 0) {
		TlsFree(s_nTlsIndent);
	}
	if (s_nTlsThread >= 0) {
		TlsFree(s_nTlsThread);
	}
	return TRUE;
}

BOOL APIENTRY DllMain(HINSTANCE hModule, DWORD dwReason, PVOID lpReserved)
{
	switch (dwReason) {
	  case DLL_PROCESS_ATTACH:
		return ProcessAttach(hModule);
	  case DLL_PROCESS_DETACH:
		return ProcessDetach(hModule);
	  case DLL_THREAD_ATTACH:
		return ThreadAttach(hModule);
	  case DLL_THREAD_DETACH:
		return ThreadDetach(hModule);
	}
	return TRUE;
}
//
///////////////////////////////////////////////////////////////// End of File.
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\SDK\test\include\astlib.h ===
// -*- Mode:C++ -*-
//
//      Copyright (c) 1996, Microsoft Corp. All rights reserved. 
//
// $Header: /ast/sdk/lib/astlib.h 4     5/09/96 3:40p Erikruf $
// $NoKeywords: $
//
// Top=level methods for AST library


#ifndef INC_ASTLIB_H 
#define INC_ASTLIB_H

class Astlib
{
  public:
    // Initialization, finalization
    ASTAPI static void ASTCALL     Initialize(FILE *debugOutputFile);
    ASTAPI static void ASTCALL     Finalize();
    ASTAPI static Version* ASTCALL GetVersion()
#ifdef AST_LIBRARY
      { return &version; }
#else
    ;
#endif

  private:
    static Version version;
};

#endif // INC_ASTLIB_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\SDK\test\include\base.h ===
// -*- Mode:C++ -*-
//
//      Copyright (c) 1996-1998, Microsoft Corp. All rights reserved. 
//
// $Header: /ast/sdk/lib/base.h 4     5/09/96 1:25p Erikruf $
// $NoKeywords: $
//

// Our virtual machine 

#ifndef INC_BASE_H 
#define INC_BASE_H

///////////////////////////////////////////////////////////////////////////////
// Types

// Ideally, we want to use C++'s built-in "bool" type.  Unfortunately
// for us, VC (4.1 anyway) reserves the "bool" keyword, but doesn't
// give it a meaning!  The same goes for "true" and "false."

// This looks nice, but has no default coercion from relational!
//enum Bool {FALSE=0, TRUE=1};

// Ok, ok, we'll do it the old-fashioned way
typedef unsigned int Bool;
#ifndef TRUE
 // client might already have included a .h file defining these
 #define FALSE ((unsigned int)0)
 #define TRUE  ((unsigned int)1)
#endif // TRUE

// Ha!  We can fake out the stinkin' compiler with macro tricks.
#undef bool
#undef true
#undef false
#define bool Bool
#define true TRUE
#define false FALSE

typedef unsigned char Byte;
typedef __int8 Int8;
typedef __int16 Int16;
typedef __int32 Int32;
typedef __int64 Int64;
typedef unsigned __int8 UInt8;
typedef unsigned __int16 UInt16;
typedef unsigned __int32 UInt32;
typedef unsigned __int64 UInt64;

///////////////////////////////////////////////////////////////////////////////
// Useful constants

#define MAX_ID_LENGTH 512

///////////////////////////////////////////////////////////////////////////////
// Forward declarations

typedef unsigned long MapIndex;
typedef MapIndex AttribKey;
typedef unsigned long TypeIndex;


// Language type
enum FrontEndType {frontC, frontCXX};

#endif // INC_BASE_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\SDK\test\include\attrib.h ===
// -*- Mode:C++ -*-
//
//      Copyright (c) 1996-1998, Microsoft Corp. All rights reserved. 
//
// $Header: /ast/sdk/lib/proto.h 2     3/08/96 10:12a Erikruf $
// $NoKeywords: $
//
//

#ifndef INC_ATTRIB_H
#define INC_ATTRIB_H

///////////////////////////////////////////////////////////////////////////////
// Provides mappings from keys to values and uses these mappings
// to provide attributes on AST nodes.
// 
//   VoidPointerMap:              MapIndex -> void*
//   Attribute<OBJ, OBJMANAGER>:  OBJ -> void*
//   PointerMap<KEY, VALUE>:      KEY -> VALUE
// 
// (... and yes there should be a version of Attribute that
//      uses the PointerMap template... --rfc)

typedef unsigned long MapIndex;

//
// Class structure (forward declarations)
//
//   hit ^X^E at end of this line (cxx-replace-class-hierarchy)

class VoidPointerMap;
class   DirectVoidPointerMap;
class     ExpandingDirectVoidPointerMap;
class   OpenHashedVoidPointerMap;
class VoidPointerMapIterator;
class   DirectVoidPointerMapIterator;
class   OpenHashedVoidPointerMapIterator;

////END////


///////////////////////////////////////////////////////////////////////////////
// VoidPointerMap 
        
// provides a MapIndex -> void* mapping.  
// This abstract class has essentially 2 implementations:
// 
//   (1) DirectVoidPointerMap
//       ExpandingDirectVoidPointerMap 
//         implement this mapping as an array and should be used whenever one
//         is planning to insert values for most or all possible index values
//         in the range 0..capacity-1.  
// 
//         For DirectVoidPointerMap, the capacity must be given at construction
//         time, is immutable and all indices must thereafter be within this range.
//         For ExpandingDirectVoidPointerMap, the capacity will be doubled
//         on demand (i.e., upon insertion of values at indices >= capacity).
// 
//   (2) OpenHashedVoidPointerMap
//         uses an open hashtable and should be used if a relatively small
//         proportion of the available indices will have values or if the
//         time/space overhead of a hashtable is not an issue.
// 
//      The constructor's capacity argument is the size of the hashtable and
//         should be somewhat greater than the number of indices expected to be
//         used (i.e., have values inserted for them), however the hashtable
//         will grow on demand.
// 

#define AST_OPENHASH_MIN 2 // must be a power of 2

// find the next power of two >= N and >= PREV
// PREV is assumed to be a power of 2.
static inline size_t
nextTwoPower(size_t n, size_t prev = AST_OPENHASH_MIN)
{
    for (; prev < n; prev*=2)
      AstAssert(prev);
    return prev;
}

class VoidPointerMapIterator;

// Abstract class for mapping
class VoidPointerMap: public Object
{
  public:
    ASTAPI virtual ~VoidPointerMap() {}

    // return true iff index has been assigned
    ASTAPI virtual Bool   FSet(MapIndex index) = 0;

    // return value assigned to index; error if none
    ASTAPI virtual void * Get(MapIndex index) = 0;

    // assign value to index
    ASTAPI virtual void   Set(MapIndex index, void * value) = 0;

    // assign value to index; error if already set
    ASTAPI virtual void   SetNew(MapIndex index, void * value);

    // return value assigned to index; defaultValue if none
    ASTAPI virtual void * GetDefaulting(MapIndex index, void *defaultValue) = 0;

    // return a fresh iterator; caller must delete it
    ASTAPI virtual        VoidPointerMapIterator *NewIterator() = 0;

    // make index be unassigned
    ASTAPI virtual void   UnSet(MapIndex index);

  protected:
    ASTAPI VoidPointerMap() {}
  private:
    // don't even THINK about copying one of these!
    VoidPointerMap(const VoidPointerMap &); // leave undefined!
    VoidPointerMap & operator = (const VoidPointerMap &);  // leave undefined!
};

class VoidPointerMapIterator
{
  public:
    ASTAPI virtual ~VoidPointerMapIterator() { }

    // advance iterator
    ASTAPI virtual Bool     FNext()    = 0;
    ASTAPI virtual void *   Next()     { return FNext() ? GetValue() : NULL; }
    ASTAPI virtual MapIndex GetIndex() = 0;
    ASTAPI virtual void *   GetValue() = 0;
  protected:
    ASTAPI VoidPointerMapIterator() { }
};

// Use an array for the mapping
class DirectVoidPointerMap: public VoidPointerMap
{
  public:
    ASTAPI DirectVoidPointerMap(
        size_t capacity,
        Allocator *allocator = Allocator::heapAllocator
      );
    ASTAPI virtual ~DirectVoidPointerMap();
    // overrides
    ASTAPI virtual Bool   FSet(MapIndex index);
    ASTAPI virtual void * Get(MapIndex index);
    ASTAPI virtual void   Set(MapIndex index, void * value);
    ASTAPI virtual void   SetNew(MapIndex index, void * value);
    ASTAPI virtual void   UnSet(MapIndex index);
    ASTAPI virtual void * GetDefaulting(MapIndex index, void *defaultValue);
    ASTAPI virtual VoidPointerMapIterator *NewIterator();
  protected:
    friend class DirectVoidPointerMapIterator;
    Allocator *allocator;
    MapIndex capacity;
    void **mapArray;
};

class ExpandingDirectVoidPointerMap: public DirectVoidPointerMap
{
  public:
    ASTAPI ExpandingDirectVoidPointerMap(
        size_t initialCapacity,
        Allocator *allocator = Allocator::heapAllocator
      );
    // overrides
    //             void * Get(MapIndex index) is the same;
    ASTAPI virtual Bool   FSet(MapIndex index);
    ASTAPI virtual void   Set(MapIndex index, void * value);
    ASTAPI virtual void   SetNew(MapIndex index, void * value);
    ASTAPI virtual void   UnSet(MapIndex index);
    ASTAPI virtual void * GetDefaulting(MapIndex index, void *defaultValue);
  private:
    void CheckExpand(MapIndex index);
};

class DirectVoidPointerMapIterator : public VoidPointerMapIterator
{
  public:
    DirectVoidPointerMapIterator(DirectVoidPointerMap *map) :
        map(map), position(0) { }

    //overrides
    ASTAPI virtual Bool     FNext();
    ASTAPI virtual void *   Next();
    ASTAPI virtual MapIndex GetIndex() { return position-1; }
    ASTAPI virtual void *   GetValue() { return map->mapArray[position-1]; }

  private:
    DirectVoidPointerMap *map;
    MapIndex position;
};

// Use an open hash table for the mapping


class OpenHashedVoidPointerMap: public VoidPointerMap
{
  public:
    ASTAPI OpenHashedVoidPointerMap(
        size_t initialCapacity,
        Allocator *allocator = Allocator::heapAllocator
      );
    ASTAPI virtual ~OpenHashedVoidPointerMap();
    // overrides
    ASTAPI virtual Bool   FSet(MapIndex index);
    ASTAPI virtual void * Get(MapIndex index);
    ASTAPI virtual void   Set(MapIndex index, void * value);
    ASTAPI virtual void   SetNew(MapIndex index, void * value);
    ASTAPI virtual void   UnSet(MapIndex index);
    ASTAPI virtual void * GetDefaulting(MapIndex index, void *defaultValue);
    ASTAPI virtual VoidPointerMapIterator *NewIterator();
  private:
    friend class OpenHashedVoidPointerMapIterator;
    Allocator *allocator;
    size_t capacity;            // number of slots
    size_t freeSpace;           // number of never-used slots
    size_t elements;            // number of live slots
    struct Pair {
        MapIndex index;
        void *value;
    };
    Pair *hashArray;
    void Rehash();
    Pair *MakeEmptyHashArray(size_t capacity);
    Pair *Find(MapIndex mapIndex);
    // size_t H(MapIndex mapIndex, int iter);
    // static MapIndex bogusIndex;
};

class OpenHashedVoidPointerMapIterator : public VoidPointerMapIterator
{
  public:
    OpenHashedVoidPointerMapIterator(OpenHashedVoidPointerMap *map):
        map(map), position(0) {}

    // overrides
    ASTAPI virtual Bool     FNext();
    ASTAPI virtual void *   Next();
    ASTAPI virtual MapIndex GetIndex() { return map->hashArray[position-1].index; }
    ASTAPI virtual void *   GetValue() { return map->hashArray[position-1].value; }

  private:
    OpenHashedVoidPointerMap *map;
    MapIndex position;
};

///////////////////////////////////////////////////////////////////////////////
// PointerMap
//
// provides a KEY -> ITEM* mapping
//        
// ITEM is a class of data items that are to be stored in the map.
// Any ITEM class must have an associated KEY class that contains
// unique identifiers for the ITEM instances stored in the map. Valid
// KEY types are pointers or MapIndex values.  When inserting a new
// element using Set or SetNew, allocate a new key in the appropriate
// arena, as this key is stored in the hash table without being
// duplicated.  It should be valid as long as the hash table is valid
// (so, use the same arena as that of the hash table). (The key could
// also be stored as a field of the associated ITEM object for which
// it is the unique identifier.) For search operations, using a local
// KEY and passing its address should suffice.
//
// Hash and equality operations must be provided by the KEY class, as defined below:
//
//   MapIndex KEY::KeyHash() : returns a MapIndex (possibly non-unique) that is the
//                             result of applying a hash function to the key
//
//   Bool operator==(KEY key) : returns TRUE iff this key and key identify the same item
//
// - Manuvir
////////////


// Sample implementation:
//
// class SymbolHashKey
// {
//     Symbol *symInfo;
//
//     MapIndex KeyHash()                 { return (MapIndex)symInfo; }
//     Bool operator==(SymbolHashKey key) { return symInfo==key.GetSymInfo(); }
// };
//
// class SymbolNode : public Object
// {
//     ...
//     SymbolHashKey key;
//     ...
// };
//
// OpenHashedPointerMap<SymbolNode,SymbolHashKey *> table;
//
//////
// 
// Sample implementation:
//
// class NameHashKey
// {
//     char *name;
//
//     MapIndex KeyHash()               { return StringToNumberHash(name); // your hash function }
//     Bool operator==(NameHashKey key) { return !strcmp(name,key->GetName()); }
// };
//
// class SymbolNode : public Object
// {
//     ...
//     NameHashKey key;
//     ...
// };
//
// OpenHashedPointerMap<SymbolNode,NameHashKey *> table;
// 

// The code below is almost identical to the code for the non-templatized maps.
// The only differences are wrt the use of template parameters.

#define ASTTAPI   AST_TEMPLATE_API
#define FLegalIndex(index)     (!((MapIndex)(index) & 0xC0000000))
#define FNeverUsedIndex(index)   ((MapIndex)(index) & 0x80000000)
#define FDeletedIndex(index)     ((MapIndex)(index) & 0x40000000)

#define SET_NEVERUSED(index)     (index = (KEY)0x80000000)
#define SET_DELETED(index)       (index = (KEY)0x40000000)

template<class ITEM, class KEY> class PointerMapIterator;
template<class ITEM, class KEY> class OpenHashedPointerMapIterator;

template<class ITEM, class KEY>
class PointerMap: public Object
{
  public:
    ASTTAPI virtual ~PointerMap() {}
    ASTTAPI virtual Bool   FSet(KEY index) = 0;
    ASTTAPI virtual ITEM * Get(KEY index) = 0;
    ASTTAPI virtual void   Set(KEY index, ITEM * value) = 0;
    ASTTAPI virtual void   SetNew(KEY index, ITEM * value);
    ASTTAPI virtual ITEM * GetDefaulting(KEY index, ITEM *defaultValue) = 0;
    ASTTAPI virtual        PointerMapIterator<ITEM,KEY> *NewIterator() = 0;
    ASTTAPI virtual void   UnSet(KEY index);

  protected:
    ASTTAPI PointerMap() {}

  private:
    PointerMap(const PointerMap &);
    PointerMap & operator = (const PointerMap &);
};

template<class ITEM, class KEY>
class PointerMapIterator
{
  public:
    ASTTAPI virtual ~PointerMapIterator() { }
    ASTTAPI virtual Bool   FNext()    = 0;
    ASTTAPI virtual ITEM * Next()     { return FNext() ? GetValue() : NULL; }
    ASTTAPI virtual KEY    GetIndex() = 0;
    ASTTAPI virtual ITEM * GetValue() = 0;
  protected:
    ASTTAPI PointerMapIterator() { }
};

template<class ITEM, class KEY>
class OpenHashedPointerMap: public PointerMap<ITEM,KEY>
{
  public:
    ASTTAPI OpenHashedPointerMap(
        size_t initialCapacity,
        Allocator *allocator = Allocator::heapAllocator
      );
    ASTTAPI virtual ~OpenHashedPointerMap();

    // overrides
    ASTTAPI virtual Bool   FSet(KEY index);
    ASTTAPI virtual ITEM * Get(KEY index);
    ASTTAPI virtual void   Set(KEY index, ITEM * value);
    ASTTAPI virtual void   SetNew(KEY index, ITEM * value);
    ASTTAPI virtual void   UnSet(KEY index);
    ASTTAPI virtual ITEM * GetDefaulting(KEY index, ITEM * defaultValue);
    ASTTAPI virtual PointerMapIterator<ITEM,KEY> *NewIterator();
  private:
    friend class OpenHashedPointerMapIterator<ITEM,KEY>;
    Allocator * allocator;
    size_t capacity;
    size_t freeSpace; 
    size_t elements;
    struct Pair {
        KEY index;
        ITEM * value;
    };
    Pair * hashArray;
    void Rehash();
    Pair * MakeEmptyHashArray(size_t capacity);
    Pair * Find(KEY mapIndex);
};

template<class ITEM, class KEY>
class OpenHashedPointerMapIterator : public PointerMapIterator<ITEM,KEY>
{
  public:
    OpenHashedPointerMapIterator(OpenHashedPointerMap<ITEM,KEY> *map):
        map(map), position(0) {}

    // overrides
    ASTTAPI virtual Bool   FNext();
    ASTTAPI virtual ITEM * Next();
    ASTTAPI virtual KEY    GetIndex() { return map->hashArray[position-1].index; }
    ASTTAPI virtual ITEM * GetValue() { return map->hashArray[position-1].value; }

  private:
    OpenHashedPointerMap<ITEM,KEY> *map;
    MapIndex position;
};

//
// PointerMap methods
//

template<class ITEM, class KEY>
void
PointerMap<ITEM,KEY>::UnSet(KEY index)
{
    USER_ERROR("This version of VoidPointerMap does not support UnSet!");;
}

template<class ITEM, class KEY>
void
PointerMap<ITEM,KEY>::SetNew(KEY index, ITEM *value)
{
    AstDeny(FSet(index));
    Set(index,value);
}

//
// OpenHashedPointerMap methods
//

template<class ITEM, class KEY>
OpenHashedPointerMap<ITEM,KEY>::OpenHashedPointerMap(size_t initialCapacity, Allocator *allocator):
    allocator(allocator), elements(0)
{
    capacity  = nextTwoPower(initialCapacity);
    freeSpace = capacity;
    hashArray = MakeEmptyHashArray(capacity);
}

template<class ITEM, class KEY>
OpenHashedPointerMap<ITEM,KEY>::~OpenHashedPointerMap()
{
    allocator->Dealloc(hashArray);
}

template<class ITEM, class KEY>
Bool
OpenHashedPointerMap<ITEM,KEY>::FSet(KEY mapIndex)
{
    AstAssert(FLegalIndex(mapIndex));
    Pair *p = Find(mapIndex);
    return FLegalIndex(p->index);
}

template<class ITEM, class KEY>
ITEM *
OpenHashedPointerMap<ITEM,KEY>::Get(KEY mapIndex)
{
    AstAssert(FLegalIndex(mapIndex));
    Pair *p = Find(mapIndex);
    AstAssert(FLegalIndex(p->index));
    return p->value;
}

template<class ITEM, class KEY>
ITEM *
OpenHashedPointerMap<ITEM,KEY>::GetDefaulting(KEY mapIndex, ITEM *defaultValue)
{
    AstAssert(FLegalIndex(mapIndex));
    Pair *p = Find(mapIndex);
    return FLegalIndex(p->index) ? p->value : defaultValue;
}

template<class ITEM, class KEY>
void
OpenHashedPointerMap<ITEM,KEY>::Set(KEY mapIndex, ITEM *value)
{
    AstAssert(FLegalIndex(mapIndex));

    if ((freeSpace - 1) * 5 < capacity)
      Rehash();

    Pair *p = Find(mapIndex);
    if (!FLegalIndex(p->index)) {
        elements++;
        if (FNeverUsedIndex(p->index))
          freeSpace--;
    }
    p->index = mapIndex;
    p->value = value;
}

template<class ITEM, class KEY>
void
OpenHashedPointerMap<ITEM,KEY>::SetNew(KEY mapIndex, ITEM *value)
{
    AstAssert(FLegalIndex(mapIndex));

    if ((freeSpace - 1) * 5 < capacity)
      Rehash();

    Pair *p = Find(mapIndex);
    AstDeny(FLegalIndex(p->index));

    elements++;
    if (FNeverUsedIndex(p->index))
      freeSpace--;

    p->index = mapIndex;
    p->value = value;
}

template<class ITEM, class KEY>
void
OpenHashedPointerMap<ITEM,KEY>::UnSet(KEY mapIndex)
{
    AstAssert(FLegalIndex(mapIndex));
    Pair *p = Find(mapIndex);
    if (FLegalIndex(p->index)) {
        SET_DELETED(p->index);
        elements--;
    }
}

#define KEY_EQUAL(a,b)          FLegalIndex(a)?(*a==*b):FALSE

template<class ITEM, class KEY>
OpenHashedPointerMap<ITEM,KEY>::Pair *
OpenHashedPointerMap<ITEM,KEY>::Find(KEY mapIndex)
{
    size_t i = 0;
    Pair *thisSlot = hashArray + mapIndex->KeyHash() % capacity;
    Pair *openSlot = NULL;
    for (;;) {
        if (KEY_EQUAL(thisSlot->index,mapIndex)) {
            if (openSlot) {
                openSlot->index = thisSlot->index;
                openSlot->value = thisSlot->value;
                SET_DELETED(thisSlot->index);
                return openSlot;
            }
            else
              return thisSlot;
        }
        else if (FNeverUsedIndex(thisSlot->index)) {
            return openSlot ? openSlot : thisSlot;
        }
        if ((!openSlot) && FDeletedIndex(thisSlot->index))
          openSlot = thisSlot;
        ++i;
        AstAssert (i < capacity);

        thisSlot += ((thisSlot < hashArray + i) ? capacity : 0) - i;
    }
    AST_NOT_REACHED;
    return NULL;
}

template<class ITEM, class KEY>
OpenHashedPointerMap<ITEM,KEY>::Pair *
OpenHashedPointerMap<ITEM,KEY>::MakeEmptyHashArray(size_t capacity)
{
    Pair *result = (Pair *)allocator->Alloc(capacity * sizeof(Pair));
    size_t i;
    for (i=0; i<capacity; i++)
      SET_NEVERUSED(result[i].index);
    return result;
}

template<class ITEM, class KEY>
void
OpenHashedPointerMap<ITEM,KEY>::Rehash()
{
    Pair *oldHashArray = hashArray;
    size_t oldCapacity = capacity;

    if (2*(elements+1) > capacity)
      capacity *= 2;
    freeSpace = capacity;
    elements  = 0;

    hashArray = MakeEmptyHashArray(capacity);
    Pair *op  = oldHashArray + oldCapacity;
    do {
        --op;
        if (FLegalIndex(op->index))
          Set(op->index, op->value);
    } while (op > oldHashArray);

    allocator->Dealloc(oldHashArray);
}

template<class ITEM, class KEY>
Bool
OpenHashedPointerMapIterator<ITEM,KEY>::FNext()
{
    if (map != NULL)
      while (position < map->capacity)
        if (FLegalIndex(map->hashArray[position++].index))
          return TRUE;
    return FALSE;
}

template<class ITEM, class KEY>
ITEM *
OpenHashedPointerMapIterator<ITEM,KEY>::Next()
{
    if (map != NULL)
      for (; position < map->capacity; ++position)
        if (FLegalIndex(map->hashArray[position].index))
          return map->hashArray[position++].value;
    return NULL;
}

template<class ITEM, class KEY>
PointerMapIterator<ITEM,KEY> *
OpenHashedPointerMap<ITEM,KEY>::NewIterator()
{
    return new OpenHashedPointerMapIterator<ITEM,KEY>(this);
}

#undef FLegalIndex
#undef FNeverUsedIndex
#undef FDeletedIndex
#undef SET_NEVERUSED
#undef SET_DELETED

///////////////////////////////////////////////////////////////////////////////
// Attribute
// 
// provides an OBJ -> void* mapping, where all of the applicable OBJs
// were assigned keys by the same MANAGER object (the one provided to
// the constructor for the Attribute object)
// 
//     OBJ     must define   MapIndex GetAttribKey();
//     MANAGER must define   MapIndex GetMaxAttribKey();
// 
// DenseAttribute is implemented using DirectVoidPointerMap 
// (array size == manager->GetMaxAttribKey())
// while SparseAttribute is implemented using OpenHashedVoidPointerMap 
// (table size == manager->GetMaxAttribKey()/capacityFactor)
// 
// Rather than using the templates directly, Attribute classes are often
// defined using the AST_DEFINE_ATTRIBUTE_CLASSES macro, e.g.,
// 
//     AST_DEFINE_ATTRIBUTE_CLASSES(Wombat, WombatNode, WombatManager);
// 
//     void TormentWombats(WombatManager *wManager)
//     {
//         WombatAttribute frobnicity(wManager, someAllocator);
//         Wombat *w;
// 
//         w = ...
// 
//         frobnicity->Set(w, (void *)(...value...));
// 
//         ... frobnicity->Get(w) ...;
//     }


typedef MapIndex AttribKey;

template<class OBJ, class MANAGER>
class Attribute
{
  public:
    // return true iff obj has been assigned a value
    AST_TEMPLATE_API Bool   FSet(OBJ *obj) 
      { return map->FSet(obj->GetAttribKey()); }

    // return value assigned to obj; error if none
    AST_TEMPLATE_API void * Get(OBJ *obj) 
      { return map->Get(obj->GetAttribKey()); }

    // assign value to obj
    AST_TEMPLATE_API void   Set(OBJ *obj, void *val) 
      { map->Set(obj->GetAttribKey(), val); }

    // assign value to obj; error if already set
    AST_TEMPLATE_API void   SetNew(OBJ *obj, void *val) 
      { map->SetNew(obj->GetAttribKey(), val); }

    // make obj be unassigned
    AST_TEMPLATE_API virtual void UnSet(OBJ *obj)
      { map->UnSet(obj->GetAttribKey()); }

    // return value assigned to obj; defaultValue if none
    AST_TEMPLATE_API void * GetDefaulting(OBJ *obj, void *defaultValue) 
      { return map->GetDefaulting(obj->GetAttribKey(), defaultValue); }

    // returns a heap-allocated iterator; caller must delete
    AST_TEMPLATE_API VoidPointerMapIterator *NewIterator() 
      { return map->NewIterator(); }

    AST_TEMPLATE_API void Print(OBJ *obj, IndentingStream *stream)
      {
          if (FSet(obj))
          {
              void *val = Get(obj);
              if (printMethod != NULL)
                (*printMethod)(val, stream);
              else
                stream->Printf("0x%x", val);
          }
      }

  protected:
    typedef void (*PrintMethod)(void *value, IndentingStream *stream);
    AST_TEMPLATE_API Attribute(VoidPointerMap *map, PrintMethod printMethod):
        map(map), printMethod(printMethod)
      { }
    AST_TEMPLATE_API ~Attribute() {}

    VoidPointerMap *map;
    PrintMethod printMethod;
};

template<class OBJ, class MANAGER>
class DenseAttribute: public Attribute<OBJ, MANAGER>
{
  public:
    AST_TEMPLATE_API DenseAttribute(
        MANAGER *manager,
        Allocator *allocator = Allocator::heapAllocator,
        PrintMethod printMethod=NULL
      ):
        Attribute<OBJ, MANAGER>(&denseMap, printMethod),
        denseMap(manager->GetMaxAttribKey()+1, allocator)
      { }
    AST_TEMPLATE_API ~DenseAttribute() {}
  protected:
    DirectVoidPointerMap denseMap;
};

template<class OBJ, class MANAGER>
class SparseAttribute: public Attribute<OBJ, MANAGER>
{
  public:
    AST_TEMPLATE_API SparseAttribute(
        MANAGER *manager,
        Allocator *allocator = Allocator::heapAllocator,
        int capacityFactor=10,
        PrintMethod printMethod=NULL
      ):
        Attribute<OBJ, MANAGER>(&sparseMap, printMethod),
        sparseMap((manager->GetMaxAttribKey()+1)/capacityFactor, allocator)
      { }
    AST_TEMPLATE_API ~SparseAttribute() {}
  protected:
    OpenHashedVoidPointerMap sparseMap;
};

///////////////////////////////////////////////////////////////////////////////
// Attribute instances

// usage:
//   AST_DEFINE_ATTRIBUTE_CLASSES(_NAME_, NODE, MGR)
//
// defines the types
//   _NAME_Attribute       -- abstract attribute class for NODE and MGR
//   Dense_NAME_Attribute  -- implementation using DirectVoidPointerMap
//   Sparse_NAME_Attribute -- implementation using OpenHashedVoidPointerMap
// 
#define AST_DEFINE_ATTRIBUTE_CLASSES(NAME, NODE, MGR) \
 typedef Attribute<NODE, MGR> NAME##Attribute ;\
 typedef DenseAttribute<NODE, MGR> Dense##NAME##Attribute ;\
 typedef SparseAttribute<NODE, MGR> Sparse##NAME##Attribute \

// the following have been moved to node.h, symbol.h, and type.h
//AST_DEFINE_ATTRIBUTE_CLASSES(Ast,    AstNode,    AstManager);
//AST_DEFINE_ATTRIBUTE_CLASSES(Symbol, Symbol,     SymbolManager);
//AST_DEFINE_ATTRIBUTE_CLASSES(Type,   TypeRecord, TypeManager);

#endif // INC_ATTRIB_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\SDK\test\include\ilpath.h ===
// -*- Mode:C++ -*-
//
//      Copyright (c) 1996-1998, Microsoft Corp. All rights reserved. 
//
// $Header: /ast/sdk/lib/ilpath.h 2     4/30/96 6:53p Erikruf $
// $NoKeywords: $
//
// 


#ifndef INC_ILPATH_H 
#define INC_ILPATH_H

//
// Descriptor for a source module's Il streams.
// Right now, it's completely specified by the prefix used to
// generate the IL file names, but in the future it will also
// include PDB paths, etc.
//

class IlPath: public Object, private WithOwnArena
{
  public: 
    ASTAPI IlPath();
    ASTAPI ~IlPath();
    ASTAPI void         Instantiate(char *buf);
    ASTAPI void         Serialize(char *buf, int len);
    ASTAPI void         DeleteIl();
    ASTAPI static void  DeleteIlFiles(char *rootname);
    // overrides
    ASTAPI virtual void DumpMethod(DumpContext *pDC);
    ASTAPI FrontEndType GetLanguage() { return language; }

    ASTAPI void Open();
    ASTAPI void Close();
    ASTAPI FILE *GetEXFile() { return exFile; }
    ASTAPI FILE *GetGLFile() { return glFile; }
    ASTAPI FILE *GetSYFile() { return syFile; }
    ASTAPI FILE *GetDBFile() { return dbFile; }
    ASTAPI FILE *GetINFile() { return inFile; }
    ASTAPI char *GetPath()   { return path; }
  private: 
    char *path;
    Bool fOpen;
    FILE *exFile, *glFile, *syFile, *dbFile, *inFile;
    FrontEndType language;
};

// Forward declarations
class IlPath;                   // Also declared in type.h
class IlStream;                 // Also declared in type.h

#endif // INC_ILPATH_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\SDK\test\include\c1cmdln.h ===
// -*- Mode:C++ -*-
//
//      Copyright (c) 1997 Microsoft Corporation.  All rights reserved.
//
//    This work is a trade secret of Microsoft Corporation.
//    Unauthorized disclosure is unlawful.
//
// $Header: $
// $NoKeywords: $
//
//
// File:    clients/cmdcl/c1cmdln.h
// Creator: rfc

#ifndef INC_C1CMDLN_H
#define INC_C1CMDLN_H

struct C1Cmdline
{
    char *objname;              // name of object file
    char *srcname;              // name of source file
    char *cwd;                  // working directory for CL
    char **args;                // argv for CL
    short ilindex;              // ilname = args[ilindex]
    short efindex;
    short zindex;
    short ycindex;
    bool  fDll;                 // is argv in DLL format?
    //                (in DLL format, args are unquoted)
    C1Cmdline():
        objname(NULL), srcname(NULL), cwd(NULL), args(NULL),
        ilindex(0), efindex(0), zindex(0), ycindex(0),
        fDll(0)
      { }

    bool          FCppOnly();   // does .args contain -E?
    int           ArgCount()    { return CountArgs(const_cast<const char **>(args)); }

    // Perform various sanity checks on OARGV.
    // Assign ilindex, efindex, zindex, ycindex.
    // Return TRUE iff successful;
    // otherwise return FALSE
    // and DigestError() will say what went wrong.
    // If nargv is non-NULL, copy oargv there.
    bool          DigestArgs(int oargc, char **oargv, char **nargv = NULL);
    char *        DigestError() { return objname; }

    // ensure that ilindex, efindex, zindex, ycindex,
    // read in from elsewhere are correct,
    // Return NULL iff so,
    // otherwise return a warning message
    char *        CheckIndices();

    // utilities
    static const char * GetCWD();
    static int          CountArgs(const char **argv)
      { for (const char **a = argv; *a; ++a); return a - argv; }

  protected:
    void SetSrcName(char *newname);
};

#endif // INC_C1CMDLN_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\SDK\test\include\literal.h ===
// -*- Mode:C++ -*-
//
//      Copyright (c) 1996, Microsoft Corp. All rights reserved. 
//
// $Header: /ast/sdk/lib/literal.h 4     5/02/96 4:43p Erikruf $
// $NoKeywords: $
//
// 

#ifndef INC_LITERAL_H 
#define INC_LITERAL_H

enum ConstantKind
{
    ckIntegral,
    ckString,
    ckWString,
    ckFloating
};

class ConstantValue: public Object
{
  public:
    ASTAPI ConstantKind   GetKind()  { return kind; }
    ASTAPI virtual char * AsString() = 0;

  protected:
    ASTAPI ConstantValue(ConstantKind kind);
    ConstantKind kind;
};

class IntegralValue: public ConstantValue
{
  public:
    // Use Make to create an IntegralValue. Common values (e.g. 0) are
    // pre-allocated and shared.  Other values are allocated on demand.
    ASTAPI static IntegralValue *Make(Allocator*, __int64 value, Bool fSigned);
    ASTAPI __int64 GetValue() { return value; }
    ASTAPI Bool    FSigned()  { return fSigned; }
    ASTAPI virtual char *AsString();
  private: 
    IntegralValue(__int64 value, Bool fSigned);
    __int64 value;
    Bool fSigned;
};

class FloatingValue: public ConstantValue
{
  public:
    ASTAPI FloatingValue(long double value): 
        ConstantValue(ckFloating), value(value) 
      { }
    ASTAPI long double    GetValue() { return value; }
    ASTAPI virtual char * AsString();
  private:
    long double value;
};

class StringValue: public ConstantValue
{
  public:
    ASTAPI StringValue(int cBytes, char *pBytes): // N.B.: doesn't copy string!
        ConstantValue(ckString), cBytes(cBytes), pBytes(pBytes),
        isWide(FALSE) {}
    ASTAPI int            GetCBytes() { return cBytes; }
    ASTAPI char *         GetPBytes() { return pBytes; }
    ASTAPI virtual char * AsString();
    ASTAPI Bool           FWide()     { return isWide; } // TRUE for wide strings
  internal:
    void SetWide() { kind = ckWString; }
    void Unparse(class OutputStream *);
  private:
    int cBytes;
    char *pBytes;
    Bool isWide;
};

class AsmValue: public Object
{
  public:
    ASTAPI AsmValue(int length, Byte *codeBytes): // N.B. doesn't copy code bytes!
        length(length), codeBytes(codeBytes) {}
    ASTAPI int    GetLength()    { return length; }
    ASTAPI Byte * GetCodeBytes() { return codeBytes; }
  private:
    int length;
    Byte *codeBytes;
};

#endif // INC_LITERAL_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\SDK\test\include\detours.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Module:     detours.lib
//  File:       detours.h
//  Author:     Galen Hunt
//
//  Detours for binary functions.  Version 1.2. (Build 35)
//
//  Copyright 1995-1999, Microsoft Corporation
//
//  http://research.microsoft.com/sn/detours
//

#pragma once
#ifndef _DETOURS_H_
#define _DETOURS_H_

#pragma comment(lib, "detours")

//////////////////////////////////////////////////////////////////////////////
//
#ifndef GUID_DEFINED
#define GUID_DEFINED
typedef struct  _GUID
{
    DWORD Data1;
    WORD Data2;
    WORD Data3;
    BYTE Data4[ 8 ];
} GUID;
#endif // !GUID_DEFINED

#if defined(__cplusplus)
#ifndef _REFGUID_DEFINED
#define _REFGUID_DEFINED
#define REFGUID             const GUID &
#endif // !_REFGUID_DEFINED
#else // !__cplusplus
#ifndef _REFGUID_DEFINED
#define _REFGUID_DEFINED
#define REFGUID             const GUID * const
#endif // !_REFGUID_DEFINED
#endif // !__cplusplus
//
//////////////////////////////////////////////////////////////////////////////

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

/////////////////////////////////////////////////////////// Trampoline Macros.
//
// DETOUR_TRAMPOLINE(trampoline_prototype, target_name)
//
// The naked trampoline must be at least DETOUR_TRAMPOLINE_SIZE bytes.
//
enum {
    DETOUR_TRAMPOLINE_SIZE          = 32,
    DETOUR_SECTION_HEADER_SIGNATURE = 0x00727444,   // "Dtr\0"
};

#define DETOUR_TRAMPOLINE(trampoline,target) \
static PVOID __fastcall _Detours_GetVA_##target(VOID) \
{ \
    return &target; \
} \
\
__declspec(naked) trampoline \
{ \
    __asm { nop };\
    __asm { nop };\
    __asm { call _Detours_GetVA_##target };\
    __asm { jmp eax };\
    __asm { ret };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
}

#define DETOUR_TRAMPOLINE_WO_TARGET(trampoline) \
__declspec(naked) trampoline \
{ \
    __asm { nop };\
    __asm { nop };\
    __asm { xor eax, eax };\
    __asm { mov eax, [eax] };\
    __asm { ret };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
}

/////////////////////////////////////////////////// Instruction Target Macros.
//
#define DETOUR_INSTRUCTION_TARGET_NONE          ((PBYTE)0)
#define DETOUR_INSTRUCTION_TARGET_DYNAMIC       ((PBYTE)~0ul)

/////////////////////////////////////////////////////////// Binary Structures.
//
#pragma pack(push, 8)
typedef struct _DETOUR_SECTION_HEADER
{
    DWORD       cbHeaderSize;
    DWORD       nSignature;
    DWORD       nDataOffset;
    DWORD       cbDataSize;

    DWORD       nOriginalImportVirtualAddress;
    DWORD       nOriginalImportSize;
    DWORD       nOriginalBoundImportVirtualAddress;
    DWORD       nOriginalBoundImportSize;

    DWORD       nOriginalIatVirtualAddress;
    DWORD       nOriginalIatSize;
    DWORD       nOriginalSizeOfImage;
    DWORD       nReserve;
} DETOUR_SECTION_HEADER, *PDETOUR_SECTION_HEADER;

typedef struct _DETOUR_SECTION_RECORD
{
    DWORD       cbBytes;
    DWORD       nReserved;
    GUID        guid;
} DETOUR_SECTION_RECORD, *PDETOUR_SECTION_RECORD;
#pragma pack(pop)

#define DETOUR_SECTION_HEADER_DECLARE(cbSectionSize) \
{ \
      sizeof(DETOUR_SECTION_HEADER),\
      DETOUR_SECTION_HEADER_SIGNATURE,\
      sizeof(DETOUR_SECTION_HEADER),\
      (cbSectionSize),\
      \
      0,\
      0,\
      0,\
      0,\
      \
      0,\
      0,\
      0,\
      0,\
}

///////////////////////////////////////////////////////////// Binary Typedefs.
//
typedef BOOL (CALLBACK *PF_DETOUR_BINARY_BYWAY_CALLBACK)(PVOID pContext,
                                                         PCHAR pszFile,
                                                         PCHAR *ppszOutFile);
typedef BOOL (CALLBACK *PF_DETOUR_BINARY_FILE_CALLBACK)(PVOID pContext,
                                                        PCHAR pszOrigFile,
                                                        PCHAR pszFile,
                                                        PCHAR *ppszOutFile);
typedef BOOL (CALLBACK *PF_DETOUR_BINARY_SYMBOL_CALLBACK)(PVOID pContext,
                                                          DWORD nOrdinal,
                                                          PCHAR pszOrigSymbol,
                                                          PCHAR pszSymbol,
                                                          PCHAR *ppszOutSymbol);
typedef BOOL (CALLBACK *PF_DETOUR_BINARY_FINAL_CALLBACK)(PVOID pContext);
typedef BOOL (CALLBACK *PF_DETOUR_BINARY_EXPORT_CALLBACK)(PVOID pContext,
                                                          DWORD nOrdinal,
                                                          PCHAR pszName,
                                                          PBYTE pbCode);

typedef VOID * PDETOUR_BINARY;
typedef VOID * PDETOUR_LOADED_BINARY;

//////////////////////////////////////////////////////// Trampoline Functions.
//
PBYTE WINAPI DetourFunction(PBYTE pbTargetFunction,
                            PBYTE pbDetourFunction);

BOOL WINAPI DetourFunctionWithEmptyTrampoline(PBYTE pbTrampoline,
                                              PBYTE pbTarget,
                                              PBYTE pbDetour);

BOOL WINAPI DetourFunctionWithEmptyTrampolineEx(PBYTE pbTrampoline,
                                                PBYTE pbTarget,
                                                PBYTE pbDetour,
                                                PBYTE *ppbRealTrampoline,
                                                PBYTE *ppbRealTarget,
                                                PBYTE *ppbRealDetour);

BOOL  WINAPI DetourFunctionWithTrampoline(PBYTE pbTrampoline,
                                          PBYTE pbDetour);

BOOL  WINAPI DetourFunctionWithTrampolineEx(PBYTE pbTrampoline,
                                            PBYTE pbDetour,
                                            PBYTE *ppbRealTrampoline,
                                            PBYTE *ppbRealTarget);

BOOL  WINAPI DetourRemoveWithTrampoline(PBYTE pbTrampoline,
                                        PBYTE pbDetour);

PBYTE WINAPI DetourFindFunction(PCHAR pszModule, PCHAR pszFunction);
PBYTE WINAPI DetourFindFinalCode(PBYTE pbCode);

PBYTE WINAPI DetourCopyInstruction(PBYTE pbDst, PBYTE pbSrc, PBYTE *ppbTarget);
PBYTE WINAPI DetourCopyInstructionEx(PBYTE pbDst,
                                     PBYTE pbSrc,
                                     PBYTE *ppbTarget,
                                     LONG *plExtra);

///////////////////////////////////////////////////// Loaded Binary Functions.
//
HINSTANCE WINAPI DetourEnumerateInstances(HINSTANCE hinstLast);
PBYTE WINAPI DetourFindEntryPointForInstance(HINSTANCE hInst);
BOOL WINAPI DetourEnumerateExportsForInstance(HINSTANCE hInst,
                                              PVOID pContext,
                                              PF_DETOUR_BINARY_EXPORT_CALLBACK pfExport);

PDETOUR_LOADED_BINARY WINAPI DetourBinaryFromInstance(HINSTANCE hInst);
PBYTE WINAPI DetourFindPayloadInBinary(PDETOUR_LOADED_BINARY pBinary,
                                       REFGUID rguid,
                                       DWORD *pcbData);
DWORD WINAPI DetourGetSizeOfBinary(PDETOUR_LOADED_BINARY pBinary);

///////////////////////////////////////////////// Persistent Binary Functions.
//
BOOL WINAPI DetourBinaryBindA(PCHAR pszFile, PCHAR pszDll, PCHAR pszPath);
BOOL WINAPI DetourBinaryBindW(PWCHAR pwzFile, PWCHAR pwzDll, PWCHAR pwzPath);
#ifdef UNICODE
#define DetourBinaryBind  DetourBinaryBindW
#else
#define DetourBinaryBind  DetourBinaryBindA
#endif // !UNICODE

PDETOUR_BINARY WINAPI DetourBinaryOpen(HANDLE hFile);
PBYTE WINAPI DetourBinaryEnumeratePayloads(PDETOUR_BINARY pBinary,
                                           GUID *pGuid,
                                           DWORD *pcbData,
                                           DWORD *pnIterator);
PBYTE WINAPI DetourBinaryFindPayload(PDETOUR_BINARY pBinary,
                                     REFGUID rguid,
                                     DWORD *pcbData);
PBYTE WINAPI DetourBinarySetPayload(PDETOUR_BINARY pBinary,
                                    REFGUID rguid,
                                    PBYTE pbData,
                                    DWORD cbData);
BOOL WINAPI DetourBinaryDeletePayload(PDETOUR_BINARY pBinary, REFGUID rguid);
BOOL WINAPI DetourBinaryPurgePayload(PDETOUR_BINARY pBinary);
BOOL WINAPI DetourBinaryResetImports(PDETOUR_BINARY pBinary);
BOOL WINAPI DetourBinaryEditImports(PDETOUR_BINARY pBinary,
                                    PVOID pContext,
                                    PF_DETOUR_BINARY_BYWAY_CALLBACK pfByway,
                                    PF_DETOUR_BINARY_FILE_CALLBACK pfFile,
                                    PF_DETOUR_BINARY_SYMBOL_CALLBACK pfSymbol,
                                    PF_DETOUR_BINARY_FINAL_CALLBACK pfFinal);
BOOL WINAPI DetourBinaryWrite(PDETOUR_BINARY pBinary, HANDLE hFile);
BOOL WINAPI DetourBinaryClose(PDETOUR_BINARY pBinary);

///////////////////////////////////////// Symbolic Debug Information Creation.
//
enum {
    DETOUR_SYNTH_HEADERSIZE = 512,
};

typedef VOID * PDETOUR_SYNTH;

PDETOUR_SYNTH WINAPI DetourSynthCreate();

PDETOUR_SYNTH WINAPI DetourSynthCreatePseudoFile(PCHAR pszBinPath,
                                                 PVOID pvBase);

BOOL WINAPI DetourSynthAddSymbol(PDETOUR_SYNTH pSynth,
                                 PVOID pvSymbol,
                                 PCSTR pszSymbol);

BOOL WINAPI DetourSynthAddSource(PDETOUR_SYNTH pSynth,
                                 PVOID pvSource,
                                 DWORD cbSource,
                                 PCSTR pszFile,
                                 DWORD nLine);

BOOL WINAPI DetourSynthAddOpcode(PDETOUR_SYNTH pSynth,
                                 PVOID pvCode,
                                 DWORD cbCode);

BOOL WINAPI DetourSynthWriteToFile(PDETOUR_SYNTH pSynth,
                                   HANDLE hFile,
                                   WORD Machine,
                                   WORD Characteristics,
                                   DWORD TimeDateStamp,
                                   DWORD CheckSum,
                                   DWORD ImageBase,
                                   DWORD SizeOfImage,
                                   DWORD SectionAlignment,
                                   PIMAGE_SECTION_HEADER pSections,
                                   DWORD nSections);

DWORD WINAPI DetourSynthAppendToFile(PDETOUR_SYNTH pBinary,
                                     HANDLE hFile,
                                     DWORD ImageBase,
                                     PIMAGE_SECTION_HEADER pSections,
                                     DWORD nSections,
                                     PIMAGE_DEBUG_DIRECTORY pDir);

BOOL WINAPI DetourSynthFlushPseudoFile(PDETOUR_SYNTH pSynth);

BOOL WINAPI DetourSynthClose(PDETOUR_SYNTH pSynth);

DWORD WINAPI DetourSynthLoadMissingSymbols(VOID);
VOID WINAPI DetourSynthNotifyDebuggerOfLoad(PBYTE pbData, PCSTR pszDllPath);

/////////////////////////////////////////////// First Chance Exception Filter.
//
LPTOP_LEVEL_EXCEPTION_FILTER WINAPI
DetourFirstChanceExceptionFilter(LPTOP_LEVEL_EXCEPTION_FILTER lpTopLevelFilter);

///////////////////////////////////////////////// Create Process & Inject Dll.
//
typedef BOOL (WINAPI *PCREATE_PROCESS_ROUTINEA)
    (LPCSTR lpApplicationName,
     LPSTR lpCommandLine,
     LPSECURITY_ATTRIBUTES lpProcessAttributes,
     LPSECURITY_ATTRIBUTES lpThreadAttributes,
     BOOL bInheritHandles,
     DWORD dwCreationFlags,
     LPVOID lpEnvironment,
     LPCSTR lpCurrentDirectory,
     LPSTARTUPINFOA lpStartupInfo,
     LPPROCESS_INFORMATION lpProcessInformation);

typedef BOOL (WINAPI *PCREATE_PROCESS_ROUTINEW)
    (LPCWSTR lpApplicationName,
     LPWSTR lpCommandLine,
     LPSECURITY_ATTRIBUTES lpProcessAttributes,
     LPSECURITY_ATTRIBUTES lpThreadAttributes,
     BOOL bInheritHandles,
     DWORD dwCreationFlags,
     LPVOID lpEnvironment,
     LPCWSTR lpCurrentDirectory,
     LPSTARTUPINFOW lpStartupInfo,
     LPPROCESS_INFORMATION lpProcessInformation);

BOOL WINAPI CreateProcessWithDllA(LPCSTR lpApplicationName,
                                  LPSTR lpCommandLine,
                                  LPSECURITY_ATTRIBUTES lpProcessAttributes,
                                  LPSECURITY_ATTRIBUTES lpThreadAttributes,
                                  BOOL bInheritHandles,
                                  DWORD dwCreationFlags,
                                  LPVOID lpEnvironment,
                                  LPCSTR lpCurrentDirectory,
                                  LPSTARTUPINFOA lpStartupInfo,
                                  LPPROCESS_INFORMATION lpProcessInformation,
                                  LPCSTR lpDllName,
                                  PCREATE_PROCESS_ROUTINEA pfCreateProcessA);

BOOL WINAPI CreateProcessWithDllW(LPCWSTR lpApplicationName,
                                  LPWSTR lpCommandLine,
                                  LPSECURITY_ATTRIBUTES lpProcessAttributes,
                                  LPSECURITY_ATTRIBUTES lpThreadAttributes,
                                  BOOL bInheritHandles,
                                  DWORD dwCreationFlags,
                                  LPVOID lpEnvironment,
                                  LPCWSTR lpCurrentDirectory,
                                  LPSTARTUPINFOW lpStartupInfo,
                                  LPPROCESS_INFORMATION lpProcessInformation,
                                  LPCWSTR lpDllName,
                                  PCREATE_PROCESS_ROUTINEW pfCreateProcessW);

#ifdef UNICODE
#define CreateProcessWithDll        CreateProcessWithDllW
#define PCREATE_PROCESS_ROUTINE     PCREATE_PROCESS_ROUTINEW
#else
#define CreateProcessWithDll        CreateProcessWithDllA
#define PCREATE_PROCESS_ROUTINE     PCREATE_PROCESS_ROUTINEA
#endif // !UNICODE

BOOL WINAPI ContinueProcessWithDllA(HANDLE hProcess, LPCSTR lpDllName);
BOOL WINAPI ContinueProcessWithDllW(HANDLE hProcess, LPCWSTR lpDllName);

#ifdef UNICODE
#define ContinueProcessWithDll          ContinueProcessWithDllW
#else
#define ContinueProcessWithDll          ContinueProcessWithDllA
#endif // !UNICODE
//
//////////////////////////////////////////////////////////////////////////////
#ifdef __cplusplus
}
#endif // __cplusplus
#endif // _DETOURS_H_

////////////////////////////////////////////////////////////////  End of File.
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\SDK\test\include\debug.h ===
// -*- Mode:C++ -*-
//
//      Copyright (c) 1996, Microsoft Corp. All rights reserved.
//
// $Header: /ast/sdk/lib/debug.h 3     5/01/96 4:40p Erikruf $
// $NoKeywords: $
//

// Debugging support: assertions, breakpoints, messages

#ifndef INC_DEBUG_H
#define INC_DEBUG_H

#ifndef DECLSPEC_NORETURN
#if (_MSC_VER >= 1200)
#define DECLSPEC_NORETURN __declspec(noreturn)
#else
#define DECLSPEC_NORETURN
#endif
#endif

// forward decls
class FileOutputStream;
class IndentingStream;

class Debug
{
  public:
    // debugging support
    typedef void (*BreakAction)();
    ASTAPI static void        Breakpoint();
    ASTAPI static BreakAction GetBreakpointAction()                  { return breakAction; }
    ASTAPI static void        SetBreakpointAction(BreakAction newBA) { breakAction = newBA; }
    ASTAPI DECLSPEC_NORETURN static void Malfunction();
    ASTAPI DECLSPEC_NORETURN static void UserError(int errcode = 1) { exit(errcode); }
    ASTAPI DECLSPEC_NORETURN static void UserError(char *fmt, ...); // errcode == 1
    ASTAPI DECLSPEC_NORETURN static void UserError(int errcode, char *fmt, ...);
    ASTAPI static void InternalWarning(char *fmt, ...);
    ASTAPI static void InternalWarning(struct SFA *sfa, char *fmt, ...);

    ASTAPI DECLSPEC_NORETURN static void FailAssert(const char *fileName,
                                                    int line,
                                                    const char *details = 0,
                                                    const char *kind = 0);
    ASTAPI static void FailAssertWarn(const char *fileName, int line,
                                      const char *details = 0,
                                      const char *kind = 0);
    // message support
    ASTAPI static void Message(char *fmt, ...);
    ASTAPI static void Message(Bool fDisplay, char *fmt, ...);
    ASTAPI static IndentingStream *pMessageStream;
    ASTAPI static OutputStream *pOutputStream;
    ASTAPI static void SetMessageMode(Bool fEnabled);
    ASTAPI static bool GetMessageMode();

  internal:
    static void Initialize(FILE *messageFile, Bool fEnableMsgs);
    static void Finalize();
    static Bool fMessagesEnabled;
    static BreakAction breakAction;
};

//
// Indent the message stream
//
class MessageIndentor: public Indentor
{
  public:
    ASTAPI MessageIndentor(int incr=1): Indentor(Debug::pMessageStream, incr) {}
    ASTAPI ~MessageIndentor() {}
};

#ifdef AST_INCLUDE_NON_ESSENTIAL
#define MESSAGE_INDENT MessageIndentor theBogusMessageIndentVariableName()
#endif

#ifdef AST_INCLUDE_NON_ESSENTIAL

///////////////////////////////////////////////////////////////////////////////
// "Assert" and friends

// inherit from IDE's notion of debug build
#ifdef _DEBUG
#define AST_DEBUG
#endif

// the usual ; trick
#define AstDoStatement(S)      do S; while (0)
#define AstDoStatementBlock(S) do { S } while (0)

#ifdef AST_DEBUG

#define AstDebug(x)         x
#define AstAssertWarn(b)    \
 AstDoStatement(if (!(b)) AST_NAMESPACE_IZE(Debug::FailAssertWarn)(__FILE__, __LINE__, #b, 0))
#define AstDenyWarn(b)      \
 AstDoStatement(if (b)  AST_NAMESPACE_IZE(Debug::FailAssertWarn)(__FILE__, __LINE__, #b, "ASTLIB deny warning"))

#else // AST_DEBUG

#define AstDebug(x)
#define AstAssertWarn(b)
#define AstDenyWarn(b)

#endif // AST_DEBUG

#define AstAssert(b)        AstDoStatement(if (!(b)) \
                                AST_NAMESPACE_IZE(Debug::FailAssert)(__FILE__, __LINE__, #b, 0))
#define AstDeny(b)          AstDoStatement(if (b) \
                                AST_NAMESPACE_IZE(Debug::FailAssert)(__FILE__, __LINE__, #b, "ASTLIB deny failed"))
#define AstAssertDo(b)      AstAssert(b)

#define AST_NOT_REACHED     AstDoStatement(AST_NAMESPACE_IZE(Debug::FailAssert)(__FILE__, __LINE__, "Unreachable code", 0))
#define AST_NOT_IMPLEMENTED AstDoStatement(AST_NAMESPACE_IZE(Debug::FailAssert)(__FILE__, __LINE__, "Unimplemented code", 0))


// And yes, we know asserts should disappear in production code.
// Someday, we'll figure out how to keep windoze from
// popping up those f@@@ing dialog boxes whenever we GPF
// and then we'll actually be able to TEST our production code
// without going insane.  
// We also need to go through and fix the various asserts
// that really shouldn't be asserts (i.e., that *do* belong
// in the production version).
// So, for now, most of the asserts, i.e.,
// those that aren't mere warnings, are staying in.  --rfc 3/6/98

#if 0

// Eventual definitions for our "retail" code.
#define AstAssert(b)
#define AstDeny(b)
#define AstAssertDo(b)      AstDoStatement(b)
#define AST_NOT_REACHED
#define AST_NOT_IMPLEMENTED

#endif


///////////////////////////////////////////////////////////////////////////////
// C++ RTTI stuff.

// We only want to use RTTI in debug mode, so we'll define our own
// casting operator that resolves to either dynamic_cast or static_cast

#ifdef AST_DEBUG
#define cast dynamic_cast
#else
#define cast static_cast
#endif // AST_DEBUG

// Friendly macros/defs for debugging

#define MESSAGE     AST_NAMESPACE_IZE(Debug::Message)
#define BREAKPOINT  AST_NAMESPACE_IZE(Debug::Breakpoint())
#define MALFUNCTION AST_NAMESPACE_IZE(Debug::Malfunction())
#define USER_ERROR  AST_NAMESPACE_IZE(Debug::UserError)

ASTAPI void D(Object *pObj);

#endif // AST_INCLUDE_NON_ESSENTIAL


#ifdef  AST_UNPREFIX_MACROS
#define Statement(S)        AstDoStatement(S)
#define StatementBlock(S)   AstDoStatementBlock(S)
#define Debug(x)            AstDebug(x)
#define Assert(b)           AstAssert(b)
#define Deny(b)             AstDeny(b)
#define AssertDo(b)         AstAssertDo(b)
#define AssertWarn(b)       AstAssertWarn(b)
#define DenyWarn(b)         AstDenyWarn(b)
#define NOT_REACHED         AST_NOT_REACHED
#define NOT_IMPLEMENTED     AST_NOT_IMPLEMENTED
#endif

#endif // INC_DEBUG_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\SDK\test\include\object.h ===
// -*- Mode:C++ -*-
//
//      Copyright (c) 1996, Microsoft Corp. All rights reserved. 
//
// $Header: /ast/sdk/lib/object.h 6     5/09/96 1:25p Erikruf $
// $NoKeywords: $
//

// A base class for our objects

#ifndef INC_OBJECT_H 
#define INC_OBJECT_H


//
// forward declarations
//

class Object;
class DumpContext;
class Allocator;

//
// The root of all evil 
//

class Object
{
  public: 
    // A bunch of custom allocation methods
    // 1. We want to be able to use an Allocator placement operand
    //    (at the moment, this is reundant because alloc.h/alloc.cpp
    //    hacks the GLOBAL "new" to do this, but that will go away once
    //    operator new[] comes online).
    ASTAPI void * ASTCALL operator new(size_t size, Allocator *baseAllocator);
    // 2. We also need to override the normal "new" and "delete" to force
    // library clients to use the DLL's malloc/delete (see VC bug Q122675).
    ASTAPI void * ASTCALL operator new(size_t size);
    ASTAPI void ASTCALL operator delete(void *pMem);
    // Return a string denoting the instance's class
    ASTAPI virtual const char *ClassName(void);
    // Dump something printable onto a dump context
    ASTAPI void Dump(DumpContext *dc = NULL);
    ASTAPI void RecursiveDump(DumpContext *dc);
  protected:
    // The protected methods need to have the export bit set because 
    // client classes may inherit them, and because library classes
    // may have inline methods (e.g. constructors) referencing them.

    // Subclasses override this dump method
    ASTAPI virtual void DumpMethod(DumpContext *dc);
    // Utility fcns visible to subclasses
    ASTAPI virtual void DumpStandardPrefix(DumpContext *dc);
    ASTAPI Object() {};
    ASTAPI ~Object() {};
  private:
};

#endif // INC_OBJECT_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\SDK\test\include\node.h ===
// -*- Mode:C++ -*-
//
//      Copyright (c) 1996-1998, Microsoft Corp. All rights reserved.
//
// $Header: /ast/sdk/lib/node.h 7     5/09/96 1:25p Erikruf $
// $NoKeywords: $
//
//


#ifndef INC_NODE_H
#define INC_NODE_H

///////////////////////////////////////////////////////////////////////////////
// Class structure (forward declarations)
//
//   hit ^X^E at end of this line (cxx-replace-class-hierarchy)

class AstNode;
class   AstFunction;
class     AstConstructor;
class   AstExpression;
class     AstNullExpr;
class     AstConstant;
class     AstSymbol;
class     AstIntrinsic;
class     AstNew;
class       AstNewObject;
class       AstNewArray;
class     AstDelete;
class     AstFunctionCall;
class     AstConstructorFn;
class       AstRealConstructorFn;
class     AstUnary;
class       AstCast;
class     AstBinary;
class     AstAssignment;
class     AstQuestion;
class     AstSizeof;
class     AstThrow;
class     AstInitList;
class     AstMemberAddress;
class   AstDeclStat;
class     AstLint;
class     AstDeclare;
class       AstDeclaration;
class         AstInitialization;
class         AstFuncDecl;
class       AstFuncDefn;
class     AstStatement;
class       AstExpr;
class       AstNullStmt;
class       AstBlock;
class       AstIf;
class       AstSwitch;
class       AstFor;
class       AstWhile;
class       AstDo;
class       AstGoto;
class       AstLabelStmt;
class         AstLabel;
class         AstCase;
class         AstDefault;
class       AstBreak;
class       AstContinue;
class       AstReturn;
class       AstAsmBlock;
class       AstAsmStatement;
class         AstAsmStmt;
class         AstAsmLabel;
class         AstAsmAlign;
class       AstSehTryExcept;
class       AstSehTryFinally;
class       AstSehLeave;
class       AstTry;
class       AstCatch;

class AstManager;

////END////

AST_DEFINE_ATTRIBUTE_CLASSES(Ast, AstNode, AstManager);

// Forward declaration
struct IlTree;

///////////////////////////////////////////////////////////////////////////////
// Opcodes

enum OpCode {
#define OPDAT(name, class, friendly) name,
#include "opcode.h"
#undef OPDAT
};

///////////////////////////////////////////////////////////////////////////////
// Intrinsics

enum IntrinsicKind {
    ikStart, ikSetjmp, ikSetjmpex, ikAlloca, ikDisable, ikOutp, ikMemset,
    ikEnable, ikOutpw, ikOutpd, ikFabs, ikStrcat, ikInp, ikRotl,
    ikAbs, ikStrcmp, ikInpw, ikInpd, ikRotr, ikMemcmp, ikStrcpy,
    ikLrotl, ikStrset, ikMemcpy, ikStrlen, ikLrotr, ikAcos,
    ikCosh, ikPow, ikTanh, ikAsin, ikFmod, ikSinh, ikAtan,
    ikExp, ikLog10, ikSqrt, ikAtan2, ikLog, ikSin, ikTan,
    ikCos, ikReturnAddress, ikExceptionCode, ikExceptionInfo,
    ikAbnormalTermination, ikInterlockedDecrement, 
#if CC_VERSION60
    ikCxxThrow,
#endif
    ikEnd
};

///////////////////////////////////////////////////////////////////////////////
// Node Keys
typedef unsigned long NodeKey;

///////////////////////////////////////////////////////////////////////////////
// Nodes

class AstNode: public Object
{
  public:
    ASTAPI AttribKey    GetAttribKey()       { return (AttribKey)nodeKey; }
    ASTAPI OpCode       GetOpCode()          { return opCode; }
    ASTAPI AstNode **   GetInputVector()     { return inputVector; }
    ASTAPI int          GetInputCount()      { return inputCount; }
    ASTAPI SFA *        GetSFA()             { return &sfa; }
    ASTAPI AstNode *    GetParent()          { return parent; }
    ASTAPI void         ReplaceChild(AstNode* oldChild, AstNode *newChild);
    ASTAPI void         PrefixPrint(
        IndentingStream *pStream = Debug::pMessageStream,
        AstAttribute *attribute = NULL
      );
    ASTAPI char *       FriendlyOpCodeName();
    ASTAPI Bool         FCompilerGenerated() { return fCompilerGenerated; }
    ASTAPI Bool         FToolGenerated()     { return fToolGenerated; }
    ASTAPI virtual Bool FExpression()        { return FALSE; }
    ASTAPI virtual Bool FStatement()         { return FALSE; }
    ASTAPI virtual Bool FDeclaration()       { return FALSE; }
    ASTAPI virtual Bool FFunction()          { return FALSE; }
    ASTAPI static void * ASTCALL operator new(size_t size, AstManager *astManager);
  internal:
    void InstallInputs(AstNode **inputs, int count);
    void SetParent(AstNode *astNodeParent) {parent = astNodeParent;}
    void InitFromIl(IlTree *ilTree, SymbolTable *symTab);
    void PrefixPrintInternal(IndentingStream *pStream, AstAttribute *attribute);
    void SetSFA(SFA *sfa);

    void Install0Inputs();
    void InstallInput(AstNode *input1, AstManager*);
    void InstallInputs(AstNode *input1, AstNode *input2, AstManager*);
    void InstallInputs(AstNode *input1, AstNode *input2, AstNode *input3,
                       AstManager*);
    // For evil hacks
    //void SetOpCode(OpCode newOpCode) { opCode = newOpCode; }
    // overrides
    virtual void DumpMethod(DumpContext *pDC);
    virtual void DumpStandardPrefix(DumpContext *dc);
    virtual void PrefixPrintMethod(IndentingStream *pStream);
  protected:
    AstNode(AstManager *astManager, OpCode opCode, SFA sfa); // for tool nodes
    AstNode(AstManager *astManager, OpCode opCode = ocError); // for IL nodes
    ASTAPI ~AstNode() {}

    NodeKey nodeKey;
    OpCode opCode           : 16;
    Bool fCompilerGenerated : 1;
    Bool fToolGenerated     : 1;

    AstNode *parent;
    AstNode **inputVector;
    int inputCount;
    SFA sfa;
};

///////////////////////////////////////////////////////////////////////////////
// Definition nodes (functions and constructors)

class AstFunction: public AstNode
{
  public:
    ASTAPI AstFunction(AstManager *astManager, OpCode opCode,
                       AstSymbol *name, AstBlock *body,
                       AstSymbol **formalVector, int formalCount,
                       SFA sfa = SFANULL);
    ASTAPI SymbolTable * GetScope();
    ASTAPI AstSymbol *   GetName() { return (AstSymbol *) inputVector[0]; }
    ASTAPI AstBlock *    GetBody() { return (AstBlock *) inputVector[1]; }

    ASTAPI int           GetFormalCount() { return formalCount; }
    ASTAPI AstSymbol  ** GetFormalVector();
    // overrides:
    ASTAPI Bool          FFunction() { return TRUE; }
  internal:
    AstFunction(AstManager *astManager, int formalCount, OpCode opCode):
        formalCount(formalCount), AstNode(astManager, opCode) {}
  protected:
    AstFunction(AstManager *astManager, OpCode opCode, SFA sfa):
        AstNode(astManager, opCode, sfa) {}
    int formalCount;
  private:
    SymbolTable *scope;
};

class AstConstructor: public AstFunction
{
  public:
    ASTAPI AstConstructor(AstManager *astManager, AstSymbol *name,
                          AstBlock *body, AstSymbol **formalVector,
                          int formalCount, AstExpression **initializerVector,
                          int initializerCount, SFA sfa = SFANULL);
    ASTAPI int GetInitializerCount()  { return inputCount - formalCount - 2; }
    ASTAPI AstExpression ** GetInitializerVector()
      {return reinterpret_cast<AstExpression **>(&inputVector[formalCount+2]);}
  internal:
    AstConstructor(AstManager *astManager, int formalCount):
        AstFunction(astManager, formalCount, ocConstructor) { }
};

///////////////////////////////////////////////////////////////////////////////
// Expression nodes

class AstExpression: public AstNode
{
  public:
    ASTAPI Type *     GetReturnType()  { return returnType; }
    // overrides
    ASTAPI Bool       FExpression()    { return TRUE; }
  internal:
    // overrides
    void InitFromIl(IlTree *ilTree, SymbolTable *symTab);
    // For evil hacks
    void SetReturnType(Type *newType) { returnType = newType; }
  protected:
    // Used for nodes corresponding to IL
    AstExpression(AstManager *astManager, OpCode opCode):
        AstNode(astManager, opCode) {}
    AstExpression(AstManager *astManager, OpCode opCode,
		  Type *returnType, SFA sfa);
    virtual void DumpStandardPrefix(DumpContext *dc);
    Type *returnType;
};

class AstNullExpr: public AstExpression
{
  public:
    ASTAPI AstNullExpr(AstManager *astManager, SFA sfa = SFANULL):
        AstExpression(astManager, ocNullExpr) {}
  internal:
    // overrides
    void InitFromIl(IlTree *ilTree, SymbolTable *symtab);
};

class AstConstant: public AstExpression
{
  public:
    ASTAPI AstConstant(AstManager *astManager, ConstantValue *constantValue,
                       Type *returnType, SFA sfa = SFANULL);
    ASTAPI ConstantValue *GetConstantValue() { return constantValue; }
  internal:
    AstConstant(AstManager *astManager):
        AstExpression(astManager, ocConstant) {}
    // overrides
    void InitFromIl(IlTree *ilTree, SymbolTable *symTab);
    virtual void DumpMethod(DumpContext *pDC);
    virtual void PrefixPrintMethod(IndentingStream *pStream);
  private:
    ConstantValue *constantValue;
};

class AstSymbol: public AstExpression
{
  public:
    ASTAPI AstSymbol(AstManager *astManager, Symbol *symbol, Type *returnType,
                     SFA sfa = SFANULL);
    ASTAPI Symbol *  GetSymbol() { return symbol; }
    ASTAPI SymbolKey GetKey()    { return GetSymbol()->GetKey(); }
    ASTAPI char *    GetName()   { return GetSymbol()->GetName(); }
  internal:
    AstSymbol(AstManager *astManager): AstExpression(astManager, ocSymbol) {}
    void InitFromSymbol(Symbol *symbol, IlTree *ilTree, SymbolTable *symTab);
    void SetSymbol(Symbol *to) { symbol = to; }
    // overrides
    void InitFromIl(IlTree *ilTree, SymbolTable *symTab);
    virtual void DumpMethod(DumpContext *pDC);
    virtual void PrefixPrintMethod(IndentingStream *pStream);
  private:
    Symbol *symbol;
};

class AstFunctionCall: public AstExpression
{
  public:
    ASTAPI AstFunctionCall(AstManager *astManager, OpCode opCode,
                           AstExpression *function,
                           AstExpression **actualVector, int actualCount,
                           int firstDefault, Type *returnType,
                           SFA sfa = SFANULL);
    ASTAPI AstExpression *  GetFunction()
      { return (AstExpression *) inputVector[0]; }
    ASTAPI int              GetActualCount()  { return inputCount-1; }
    ASTAPI AstExpression ** GetActualVector();
    ASTAPI int              GetFirstDefault() { return firstDefault; }
    // Returns: first default arg, -1 for none (first arg is numbered 0)
  internal:
    AstFunctionCall(AstManager *astManager, OpCode opCode, int firstDefault) :
        AstExpression(astManager, opCode), firstDefault(firstDefault) {}
  private:
    int firstDefault;
};

// Used for default constructor and copy functions
class AstConstructorFn: public AstExpression
{
  public:
    ASTAPI AstConstructorFn(AstManager *astManager, OpCode opCode,
                            AstSymbol *classSymbol, Type *returnType,
                            SFA sfa = SFANULL);
    ASTAPI AstSymbol *GetClass() { return (AstSymbol *) inputVector[0]; }
  internal:
    AstConstructorFn(AstManager *astManager, OpCode opCode):
        AstExpression(astManager, opCode) {}
    // overrides
    void InitFromIl(IlTree *ilTree, SymbolTable *symTab);
  protected:
    AstConstructorFn(AstManager *astManager, OpCode opCode,
                     Type *returnType, SFA sfa):
        AstExpression(astManager, opCode, returnType, sfa) { }
};

class AstRealConstructorFn: public AstConstructorFn
{
  public:
    ASTAPI AstRealConstructorFn(AstManager *astManager, AstSymbol *classSymbol,
                                AstSymbol *fnSymbol, Type *returnType,
                                SFA sfa = SFANULL);
    ASTAPI AstSymbol *GetConstructor() { return (AstSymbol *) inputVector[1]; }
  internal:
    AstRealConstructorFn(AstManager *astManager):
        AstConstructorFn(astManager, ocRealConstructorFn) {}
};



// REVIEW: describe which AstNew variant one gets for different expressions.
//  e.g.  new int(n+1)  // initialized but no ctor

// AstNew       (ocNew)
//   no initialization e.g. new int;
// AstNewObject (ocNewObject)
//   e.g. new int(n+1);  
//   e.g. new MyClass(n+1);  
// AstNewArray  (ocNewArray)
//   e.g. new int[3];
//   e.g. new MyCLass[3];

class AstNew: public AstExpression
{
  public:
    ASTAPI AstNew(AstManager *astManager, OpCode opCode,
                  AstFunctionCall *newCall, Type *returnType,
                  SFA sfa = SFANULL);
    ASTAPI AstFunctionCall *GetNewCall()
      { return (AstFunctionCall *) inputVector[0]; }
  internal:
    AstNew(AstManager *astManager, OpCode opCode):
        AstExpression(astManager, opCode) {}
  protected:
    AstNew(AstManager *astManager, OpCode opCode, Type *returnType, SFA sfa):
        AstExpression(astManager, opCode, returnType, sfa) {}
};

class AstNewObject: public AstNew
{
  public:
    ASTAPI AstNewObject(AstManager *astManager, AstFunctionCall *newCall,
                        AstExpression *initializer, Type *returnType,
                        SFA sfa = SFANULL);
    ASTAPI AstExpression *GetConstructor()
      { return (AstExpression *) inputVector[1]; }
  internal:
    AstNewObject(AstManager *astManager): AstNew(astManager, ocNewObject) {}
};

class AstNewArray: public AstNew
{
  public:
    ASTAPI AstNewArray(AstManager *astManager, AstFunctionCall *newCall,
                       AstExpression *size, Type *returnType,
                       SFA sfa = SFANULL);
    ASTAPI AstExpression *GetSize();
  internal:
    AstNewArray(AstManager *astManager): AstNew(astManager, ocNewArray) {}
};

class AstDelete: public AstExpression
{
  public:
    ASTAPI AstDelete(AstManager *astManager, AstSymbol *deleteOperator,
                     AstExpression *expression, Bool fIsArray,
                     Type *returnType, SFA sfa = SFANULL);
    ASTAPI AstSymbol *     GetDeleteOperator()
      { return (AstSymbol *) inputVector[0]; }
    ASTAPI AstExpression * GetExpression()
      { return (AstExpression *) inputVector[1]; }
    Bool                   FIsArray()      { return fIsArray; }
  internal:
    AstDelete(AstManager *astManager, Bool fIsArray):
        AstExpression(astManager, ocDelete), fIsArray(fIsArray) {}
  private:
    Bool fIsArray;
};

class AstIntrinsic: public AstExpression
{
  public:
    ASTAPI AstIntrinsic(AstManager *astManager, TypeManager *typeManager, 
                        TypeMap *typeMap,
                        IntrinsicKind kind, AstExpression **actualVector,
                        int actualCount, Type *returnType, SFA sfa = SFANULL);
    ASTAPI IntrinsicKind    GetOrdinal()     { return kind; }
    ASTAPI char *           GetName()        { return name; }
    ASTAPI int              GetActualCount() { return inputCount-1; }
    ASTAPI AstExpression ** GetActualVector();
    ASTAPI static char *    GetName(IntrinsicKind kind);
  internal:
    AstIntrinsic(AstManager *astManager):
        AstExpression(astManager, ocIntrinsic) {}
    // overrides
    void InitFromIl(IlTree *ilTree, SymbolTable *symTab);
  private:
    IntrinsicKind kind;
    char *name;
    static struct tuple {int ordinal; IntrinsicKind kind; char *name;}iTable[];
};

class AstUnary: public AstExpression
{
  public:
    ASTAPI AstUnary(AstManager *astManager, OpCode opCode,
                    AstExpression *operand, Type *returnType,
                    SFA sfa = SFANULL);
    ASTAPI AstExpression *GetOperand()
      { return (AstExpression *) inputVector[0]; }
  internal:
    AstUnary(AstManager *astManager, OpCode opCode):
        AstExpression(astManager, opCode) {}
    // overrides
    void InitFromIl(IlTree *ilTree, SymbolTable *symTab);
    virtual void PrefixPrintMethod(IndentingStream *pStream);
};

class AstCast: public AstUnary
{
  public:
    ASTAPI AstCast(AstManager *astManager, OpCode opCode,
                   AstExpression *operand, Type *returnType,
                   SFA sfa = SFANULL);
  internal:
    AstCast(AstManager *astManager, OpCode opCode):
        AstUnary(astManager, opCode) {}
    // overrides
    void InitFromIl(IlTree *ilTree, SymbolTable *symTab);
    //virtual void DumpStandardPrefix(DumpContext *dc);
  private:
};

class AstBinary: public AstExpression
{
  public:
    ASTAPI AstBinary(AstManager *astManager, OpCode opCode,
                     AstExpression *leftOperand, AstExpression *rightOperand,
                     Type *returnType, SFA sfa = SFANULL);
    ASTAPI AstExpression * GetLeftOperand()
      { return (AstExpression *) inputVector[0]; }
    ASTAPI AstExpression * GetRightOperand()
      { return (AstExpression *) inputVector[1]; }
  internal:
    AstBinary(AstManager *astManager, OpCode opCode):
        AstExpression(astManager, opCode) {}
};

class AstAssignment: public AstExpression
{
  public:
    ASTAPI AstAssignment(AstManager *astManager, OpCode opCode,
                         AstExpression *target, AstExpression *value,
                         Type *returnType, SFA sfa = SFANULL);
    ASTAPI AstExpression * GetTarget()
      { return (AstExpression *) inputVector[0]; }
    ASTAPI AstExpression * GetNewValue()
      { return GetInputCount() == 2
            ? (AstExpression *) inputVector[1]
            : NULL; }
  internal:
    AstAssignment(AstManager *astManager, OpCode opCode):
        AstExpression(astManager, opCode) {}
};

class AstQuestion: public AstExpression
{
  public:
    ASTAPI AstQuestion(AstManager *astManager, AstExpression *predicate,
                       AstExpression *consequent, AstExpression *alternative,
                       Type *returnType, SFA sfa = SFANULL);
    ASTAPI AstExpression * GetPredicate()
      { return (AstExpression *) inputVector[0]; }
    ASTAPI AstExpression * GetConsequent()
      { return (AstExpression *) inputVector[1]; }
    ASTAPI AstExpression * GetAlternative()
      { return (AstExpression *) inputVector[2]; }
  internal:
    AstQuestion(AstManager *astManager):
        AstExpression(astManager, ocQuestion) {}
};

class AstSizeof: public AstExpression
{
  public:
    ASTAPI AstSizeof(AstManager *astManager, __int64 size, Type *typeExpr,
                     AstExpression *expression, Type *returnType,
                     SFA sfa = SFANULL);
    ASTAPI __int64         GetSize() { return size; }
    ASTAPI Type          * GetType() { return typeExpression; }
    ASTAPI AstExpression * GetExpression(); // may be NULL
  internal:
    AstSizeof(AstManager *astManager): AstExpression(astManager, ocSizeof) {}
    // overrides
    void InitFromIl(IlTree *ilTree, SymbolTable *symTab);
  private:
    __int64 size;
    Type *typeExpression;
};

class AstThrow: public AstExpression
{
  public:
    ASTAPI AstThrow(AstManager *astManager, AstExpression *expression,
                    Type *returnType, SFA sfa = SFANULL);
    ASTAPI AstExpression *GetOperand();  // may be NULL
  internal:
    AstThrow(AstManager *astManager): AstExpression(astManager, ocThrow) {}
};

class AstInitList: public AstExpression
{
  public:
    ASTAPI AstInitList(AstManager *astManager, AstExpression **initVector,
                       int initCount, Type *returnType, SFA sfa = SFANULL);
    ASTAPI AstExpression ** GetInitVector()
      { return reinterpret_cast<AstExpression **>(inputVector); }
    ASTAPI int              GetInitCount() { return inputCount; }
    ASTAPI void             AddToInitList(AstExpression *astExpression);
 internal:
    AstInitList(AstManager *astManager);
  private:
    int vectorLength;
    ArenaAllocator *allocator;
};

class AstMemberAddress: public AstExpression
{
  public:
    ASTAPI AstMemberAddress(AstManager *astManager, Symbol *class, 
                         Symbol *member, Type *returnType, SFA sfa = SFANULL);
    ASTAPI Symbol * GetClassSymbol()  { return classSymbol; }
    ASTAPI Symbol * GetMemberSymbol() { return memberSymbol; }
  internal:
    AstMemberAddress(AstManager *astManager): AstExpression(astManager, ocMemberAddress) {}
    // overrides
    void InitFromIl(IlTree *ilTree, SymbolTable *symTab);
  private:
    Symbol *classSymbol;
    Symbol *memberSymbol;
};

///////////////////////////////////////////////////////////////////////////////
// Declaration and statement nodes

class AstDeclStat: public AstNode
{
  protected:
    AstDeclStat(AstManager *astManager, OpCode opCode, SFA sfa):
        AstNode(astManager, opCode, sfa) {} // for tool nodes
    AstDeclStat(AstManager *astManager, OpCode opCode):
        AstNode(astManager, opCode) {} // for IL nodes
};

class AstLint: public AstDeclStat
{
  public:
    ASTAPI AstLint(AstManager *astManager, char *lintSpec,
                   SFA sfa = SFANULL):
        AstDeclStat(astManager, ocLint, sfa), lintSpec(lintSpec) {}
    ASTAPI char * GetLintSpec()  { return lintSpec; }
    // overrides
    ASTAPI Bool   FDeclaration() { return TRUE; }
  internal:
    AstLint(AstManager *astManager): AstDeclStat(astManager, ocLint) {}
    // overrides
    void InitFromIl(IlTree *ilTree, SymbolTable *symTab);
  private:
    char *lintSpec;
};

///////////////////////////////////////////////////////////////////////////////
// Declaration nodes (special, since C and C++ differ in classification)
//
// This is how various delarations map onto AstDeclare and its derived classes:
//
//   typedef int INT;   -- AstDeclaration.
//   struct S;          -- AstDeclaration, forward.
//   extern int x;      -- AstDeclaration, extern.
//   extern int x = 2;  -- AstInitialization, extern.
//   void f();          -- AstFuncDecl
//   extern void f();   -- AstFuncDecl, extern.
//   void f() {};       -- AstFuncDefn.
//
// AstDeclaration::FForward() is always false for AstInitialization.
// Only AstDeclarations of types (enum, classes, structs and unions)
// can be foreward.
//
// The difference between AstDeclaration and AstFuncDecl is not
// whether the thing being declared is a function or not, but whether
// it was in the function part of a declarator.  Thus typedefs and
// variables can be declared via AstFuncDecls, and functions might be
// declared via AstDeclarations:
//
//   typedef int F(float);         -- AstFuncDecl declares a typedef
//   F f1;                         -- AstDeclaration declares a function
//   typedef int (**PPF)(float);   -- AstFuncDecl declares another typedef
//   int (*pf)(int);               -- AstFuncDecl declared a variable
//   PPF f2;                       -- AstDeclaration declares a variable


class AstDeclare: public AstDeclStat
{
  public:
    ASTAPI AstSymbol * GetDeclared()  { return (AstSymbol *) inputVector[0]; }
    // overrides
    ASTAPI Bool        FDeclaration() { return TRUE; }
  protected:
    AstDeclare(AstManager *astManager, OpCode opCode, SFA sfa):
        AstDeclStat(astManager, opCode, sfa) {}
    AstDeclare(AstManager *astManager, OpCode opCode):
        AstDeclStat(astManager, opCode) {}
};

class AstDeclaration: public AstDeclare
{
  public:
    ASTAPI AstDeclaration(AstManager *astManager, AstSymbol *declaredSymbol,
                          Bool fForward = FALSE, Bool fExtern = FALSE,
                          SFA sfa = SFANULL);
    ASTAPI Bool FForward() { return fForward; }
    ASTAPI Bool FExtern()  { return fExtern; }


  internal:
    AstDeclaration(AstManager *astManager)
        : AstDeclare(astManager, ocDecl),
          fExtern(FALSE), fForward(FALSE)
      {}
    void InitFromSymbol(AstSymbol *symbol, IlTree *ilTree, SymbolTable *symTab);
  protected:
    AstDeclaration(AstManager *astManager, OpCode opCode)
        : AstDeclare(astManager, opCode) {}

    Bool fForward       : 1 ;
    Bool fExtern        : 1 ;
};

class AstInitialization: public AstDeclaration
{
  public:
    ASTAPI AstInitialization(AstManager *astManager, AstSymbol *declaredSymbol,
                             AstExpression *initializer, Bool fExtern = FALSE,
                             SFA sfa = SFANULL);
    ASTAPI AstExpression *GetInitializer()       
      { return (AstExpression *) inputVector[1]; }
  internal:
    AstInitialization(AstManager *astManager)
        : AstDeclaration(astManager, ocInit) {}
    // overrides
    void InitFromIl(IlTree *ilTree, SymbolTable *symTab);
  private:
};

class AstFuncDecl: public AstDeclaration
{
  // This node describes function prototypes.  Besides the obvious, two pieces
  // of info are kept for each paramter: the declared type (eg class name) and
  // lint spec string.  Either may be null.
  public:
    ASTAPI AstFuncDecl * GetNextFuncDecl()   { return nextFuncDecl; }
    ASTAPI int           GetParameterCount() { return parameterCount; }
    ASTAPI Symbol **     GetParameterDeclaredTypeVector() 
                                             { return parameterDeclaredTypeVector; }
    ASTAPI char **       GetParameterLintSpecVector() 
                                             { return parameterLintSpecVector; }
    ASTAPI Bool          FVoidParamList()    { return fVoidParamList; }
    ASTAPI Bool          FVarArgs()          { return fVarArgs; }

  internal:
    AstFuncDecl(AstManager *astManager)
        : AstDeclaration(astManager, ocFuncDecl), parameterCount(0),
          nextFuncDecl(0), parameterDeclaredTypeVector(NULL),
          parameterLintSpecVector(NULL),
          fVoidParamList(FALSE), fVarArgs(FALSE)
      { AstAssert(opCode == ocFuncDecl); }
    void InitFromSymbol(AstManager *astManager, AstSymbol *symbol, IlTree *ilTree, SymbolTable *symTab);

  private:
    int parameterCount;
    Symbol **parameterDeclaredTypeVector;
    char **parameterLintSpecVector;
    AstFuncDecl *nextFuncDecl;
    Bool fVoidParamList  : 1 ;
    Bool fVarArgs        : 1 ;
};


class AstFuncDefn: public AstDeclare
{
  public:
    ASTAPI AstFuncDefn(AstManager *astManager, AstSymbol *declaredSymbol,
                       Bool fForward = FALSE, Bool fExtern = FALSE,
                       SFA sfa = SFANULL);
    ASTAPI AstFunction*  GetFunction();
  internal:
    AstFuncDefn(AstManager *astManager): AstDeclare(astManager, ocFuncDefn) {}
};


///////////////////////////////////////////////////////////////////////////////
// Statement nodes

class AstStatement: public AstDeclStat
{
  public:
    // overrides
    ASTAPI Bool FStatement() { return TRUE; }
  protected:
    AstStatement(AstManager *astManager, OpCode opCode):
        AstDeclStat(astManager, opCode) {}
    AstStatement(AstManager *astManager, OpCode opCode, SFA sfa):
        AstDeclStat(astManager, opCode, sfa) {}
};

class AstExpr: public AstStatement
{
  public:
    ASTAPI AstExpr(AstManager *astManager, AstExpression *expression,
                   SFA sfa = SFANULL);
    ASTAPI AstExpression *GetExpression()
      { return (AstExpression *) inputVector[0]; }
  internal:
    AstExpr(AstManager *astManager):
        AstStatement(astManager, ocExpr) {}
};

class AstNullStmt: public AstStatement
{
  public:
    ASTAPI AstNullStmt(AstManager *astManager, SFA sfa = SFANULL):
        AstStatement(astManager, ocNullStmt, sfa) {}
};


class AstBlock: public AstStatement
{
  public:
    ASTAPI AstBlock(AstManager *astManager, AstDeclStat **declStatVector,
                    int declStatCount, SFA sfa = SFANULL);
    ASTAPI SymbolTable *   GetScope()         { return symbolTable; }
    ASTAPI AstDeclStat **  GetDeclStatVector()
      { return reinterpret_cast<AstDeclStat **>(inputVector); }
    ASTAPI AstStatement ** GetStatementVector(); // deprecated; going away soon
    ASTAPI int             GetDeclStatCount() { return inputCount; }
    ASTAPI int             GetStatementCount(); // deprecated; going away soon
    ASTAPI int             GetChildIndex(AstDeclStat *child);
    ASTAPI void            AddDeclStats(AstManager *astManager,
                                        AstDeclStat **declStatVector,
                                        int declStatCount, int position);
  internal:
    AstBlock(AstManager *astManager): AstStatement(astManager, ocBlock) {}
    void SetScope(SymbolTable *symTab) { symbolTable = symTab; }
    // overrides
    virtual void PrefixPrintMethod(IndentingStream *pStream);
  private:
    SymbolTable *symbolTable;
};

class AstIf: public AstStatement
{
  public:
    ASTAPI AstIf(AstManager *astManager, AstExpression *predicate,
                 AstStatement *consequent, AstStatement *alternative = NULL,
                 SFA sfa = SFANULL);
    ASTAPI AstExpression* GetPredicate()
      { return (AstExpression*) inputVector[0]; }
    ASTAPI AstStatement *  GetConsequent()
      { return (AstStatement*) inputVector[1]; }
    ASTAPI Bool            FHasAlternative() { return (inputCount == 3); }
    ASTAPI AstStatement *  GetAlternative();
    ASTAPI void SetPredicate(AstExpression *newPredicate);
    ASTAPI void SetConsequent(AstStatement *newConsequent);
    ASTAPI void SetAlternative(AstStatement *newAlternative);
  internal:
    AstIf(AstManager *astManager): AstStatement(astManager, ocIf) {}
};

class AstSwitch: public AstStatement
{
  public:
    ASTAPI AstSwitch(AstManager *astManager, AstExpression *switchExpression,
                     AstStatement *body, SFA sfa = SFANULL);
    ASTAPI AstExpression * GetSwitch()
      { return (AstExpression *) inputVector[0]; }
    ASTAPI AstStatement *  GetBody()
      { return (AstStatement *) inputVector[1]; }
  internal:
    AstSwitch(AstManager *astManager): AstStatement(astManager, ocSwitch) {}
};

class AstFor: public AstStatement
{
  public:
    ASTAPI AstFor(AstManager *astManager, AstStatement *initializer,
                  AstExpression *test, AstExpression *increment,
                  AstStatement *body, SFA sfa = SFANULL);
    ASTAPI AstStatement * GetInit() { return (AstStatement *) inputVector[0]; }
    ASTAPI void SetInit(AstStatement *newInit)
      { inputVector[0] = newInit;  inputVector[0]->SetParent(this); }
    ASTAPI AstExpression * GetTest()
      { return (AstExpression *) inputVector[1]; }
    ASTAPI void SetTest(AstExpression *newTest) { inputVector[1] = newTest; }
    ASTAPI AstExpression * GetIncrement()
      { return (AstExpression *) inputVector[2]; }
    ASTAPI void SetIncrement(AstExpression *newIncrement)
      { inputVector[2] = newIncrement; }
    ASTAPI AstStatement * GetBody() { return (AstStatement *) inputVector[3];}
    ASTAPI void SetBody(AstStatement *newBody) { inputVector[3] = newBody; }
  internal:
    AstFor(AstManager *astManager): AstStatement(astManager, ocFor) {}
};

class AstWhile: public AstStatement
{
  public:
    ASTAPI AstWhile(AstManager *astManager, AstExpression *test,
                    AstStatement *body, SFA sfa = SFANULL);
    ASTAPI AstExpression * GetTest()
      { return (AstExpression *) inputVector[0]; }
    ASTAPI AstStatement *  GetBody()
      { return (AstStatement *) inputVector[1]; }
  internal:
    AstWhile(AstManager *astManager): AstStatement(astManager, ocWhile) {}
};

class AstDo: public AstStatement
{
  public:
    ASTAPI AstDo(AstManager *astManager, AstExpression *test,
                 AstStatement *body, SFA sfa = SFANULL);
    ASTAPI AstExpression * GetTest()
      { return (AstExpression *) inputVector[1]; }
    ASTAPI AstStatement *  GetBody()
      { return (AstStatement *) inputVector[0]; }
  internal:
    AstDo(AstManager *astManager): AstStatement(astManager, ocDo) {}
};

class AstGoto: public AstStatement
{
  public:
    ASTAPI AstGoto(AstManager *astManager, AstSymbol *destination,
                   SFA sfa = SFANULL);
    ASTAPI AstSymbol * GetLabel() { return (AstSymbol *) inputVector[0]; }
  internal:
    AstGoto(AstManager *astManager): AstStatement(astManager, ocGoto) {}
};

class AstLabelStmt: public AstStatement
{
  public:
    ASTAPI AstStatement * GetReferent()
      { return (AstStatement *) inputVector[0]; }
    ASTAPI void SetReferent(AstStatement *stmt) { inputVector[0] = stmt; }
  protected:
    AstLabelStmt(AstManager *astManager, OpCode opCode):
        AstStatement(astManager, opCode) {}
    AstLabelStmt(AstManager *astManager, OpCode opCode, SFA sfa):
        AstStatement(astManager, opCode, sfa) {}
};

class AstLabel: public AstLabelStmt
{
  public:
    ASTAPI AstLabel(AstManager *astManager, AstSymbol *label,
                    AstStatement *referent, SFA sfa = SFANULL);
    ASTAPI AstSymbol * GetLabel()
      { return (AstSymbol *) inputVector[1]; }
  internal:
    AstLabel(AstManager *astManager): AstLabelStmt(astManager, ocLabel) {}
};

class AstDefault: public AstLabelStmt
{
  public:
    ASTAPI AstDefault(AstManager *astManager, AstStatement *referent,
                      SFA sfa = SFANULL);
  internal:
    AstDefault(AstManager *astManager): AstLabelStmt(astManager, ocDefault) {}
};

class AstCase: public AstLabelStmt
{
  public:
    ASTAPI AstCase(AstManager *astManager, AstExpression *constant,
                   AstStatement *referent, SFA sfa = SFANULL);
    ASTAPI AstExpression * GetConstant()
      { return (AstExpression *) inputVector[1]; }
  internal:
    AstCase(AstManager *astManager): AstLabelStmt(astManager, ocCase) {}
};

class AstBreak: public AstStatement
{
  public:
    AstBreak(AstManager *astManager, SFA sfa = SFANULL):
        AstStatement(astManager, ocBreak, sfa) { }
};

class AstContinue: public AstStatement
{
  public:
    AstContinue(AstManager *astManager, SFA sfa = SFANULL):
    AstStatement(astManager, ocContinue, sfa) { }
};

class AstReturn: public AstStatement
{
  public:
    ASTAPI AstReturn(AstManager *astManager,
                     AstExpression *returnValue /* may be NULL */,
                     SFA sfa = SFANULL);
    ASTAPI Bool            FReturnsValue();
    ASTAPI AstExpression * GetReturnValue(); // May be NULL
  internal:
    AstReturn(AstManager *astManager): AstStatement(astManager, ocReturn) {}
};

class AstAsmBlock: public AstStatement
{
  public:
    // public constructor not yet implemented
    ASTAPI AstAsmStatement ** GetStatementVector()
      { return (AstAsmStatement **) inputVector; }
    ASTAPI int                GetStatementCount() { return inputCount; }
  internal:
    AstAsmBlock(AstManager *astManager):
        AstStatement(astManager, ocAsmBlock) {}
};

class AstAsmStatement: public AstStatement
{
  internal:
    // public constructor not yet implemented
    AstAsmStatement(AstManager *astManager, OpCode opCode):
        AstStatement(astManager, opCode) {}
};

class AstAsmStmt: public AstAsmStatement
{
  public:
    // public constructor not yet implemented
    ASTAPI AsmValue *       GetAsmValue()       { return asmValue; }
    ASTAPI AsmInstruction * GetAsmInstruction() { return asmInstruction; }
  internal:
    AstAsmStmt(AstManager *astManager):
        AstAsmStatement(astManager, ocAsmStmt) {}
    void ParseAsmIl(SymbolTable *symbolTable, AstManager *astManager);
    // overrides
    void InitFromIl(IlTree *ilTree, SymbolTable *symTab);
  private:
    AsmValue *asmValue;
    AsmInstruction *asmInstruction;
};

class AstAsmLabel: public AstAsmStatement
{
  public:
    // public constructor not yet implemented
    ASTAPI AstSymbol * GetLabel() { return (AstSymbol *) inputVector[0]; }
  internal:
    AstAsmLabel(AstManager *astManager):
        AstAsmStatement(astManager, ocAsmLabel) {}
};

class AstAsmAlign: public AstAsmStatement
{
  public:
    // public constructor not yet implemented
    ASTAPI UInt32       GetAsmAlign()       { return asmAlign; }
  internal:
    AstAsmAlign(AstManager *astManager):
        AstAsmStatement(astManager, ocAsmAlign) {}
    // overrides
    void InitFromIl(IlTree *ilTree, SymbolTable *symTab);
  private:
    UInt32 asmAlign;
};

class AstSehTryExcept: public AstStatement
{
  public:
    ASTAPI AstSehTryExcept(AstManager *astManager, AstStatement *body,
                           AstStatement *handler, AstExpression *filter,
                           SFA sfa = SFANULL);
    ASTAPI AstStatement *GetBody()
      { return (AstStatement *) inputVector[0]; }
    ASTAPI AstStatement *GetHandler()
      { return (AstStatement *) inputVector[1]; }
    ASTAPI AstExpression *GetFilter() // the guard
      { return (AstExpression *) inputVector[2]; }
  internal:
    AstSehTryExcept(AstManager *astManager):
        AstStatement(astManager, ocSehTryExcept) {}
};

class AstSehTryFinally: public AstStatement
{
  public:
    ASTAPI AstSehTryFinally(AstManager *astManager, AstStatement *body,
                            AstStatement *handler, SFA sfa = SFANULL);
    ASTAPI AstStatement * GetBody()
      { return (AstStatement *) inputVector[0]; }
    ASTAPI AstStatement * GetHandler()
      { return (AstStatement *) inputVector[1]; }
  internal:
    AstSehTryFinally(AstManager *astManager): AstStatement(astManager, ocSehTryFinally) {}
};

class AstSehLeave: public AstStatement
{
  public:
    AstSehLeave(AstManager *astManager, SFA sfa = SFANULL):
        AstStatement(astManager, ocSehLeave, sfa) { }
};

class AstTry: public AstStatement
{
  public:
    ASTAPI AstTry(AstManager *astManager, AstBlock *body,
                  AstCatch **handlerVector, int handlerCount,
                  SFA sfa = SFANULL);
    ASTAPI AstBlock * GetBody()         { return (AstBlock *) inputVector[0]; }
    ASTAPI int        GetHandlerCount() { return inputCount - 1; }
    ASTAPI AstCatch **GetHandlerVector(); // REVIEW: was AstBlock ** --RFC
  internal:
    AstTry(AstManager *astManager): AstStatement(astManager, ocTry) {}
};

class AstCatch: public AstStatement
{
  public:
    ASTAPI AstCatch(AstManager *astManager, AstSymbol *caughtSymbol,
                    Type *caughtType, AstBlock *body, SFA sfa = SFANULL);
    ASTAPI AstSymbol * GetCaughtSymbol(); // NULL if no symbol
    ASTAPI Type * GetCaughtType() { return caughtType; } // NULL if catch(...)
    ASTAPI AstBlock * GetBody()   { return (AstBlock *) inputVector[0]; }
  internal:
    AstCatch(AstManager *astManager):
        AstStatement(astManager, ocCatch) {}
    void InitFromIl(IlTree *ilTree, SymbolTable *symTab);
    void SetCaughtType(Type *type) { caughtType = type; }
  private:
    Type *caughtType;
};

///////////////////////////////////////////////////////////////////////////////
// AstManager

#ifndef AST_LIBRARY
typedef unsigned long symkey_t;
#endif

class AstManager: public Object, public WithArena
{
  public:
    ASTAPI AstManager(ArenaAllocator *pAllocator, FrontEndType language);
    ASTAPI ~AstManager();
    ASTAPI AttribKey GetMaxAttribKey() { return (AttribKey)nextKey-1; }
  internal:
    void ParseSy(long syOffset, Bool fInPch, SymbolTable *symbolTable,
                 SymbolTable **labelsTableHandle, TypeManager *typeManager,
                 TypeIO *, SymbolManager *symbolManager);
    AstNode *ParseEx(long exOffset, Bool fInPch, SymbolTable *globalScope,
                     SymbolTable *formalsScope, TypeManager *typeManager,
                     TypeIO *typeIO);
    AstBlock *ParseIn(IlPath *ilModule, SymbolTable *globalScope,
                      TypeManager *typeManager, TypeIO *typeIO);
    void InitializeExParser(IlPath *ilPath);
    void FinalizeExParser();
    void InitializePchParser(long pchChecksym, char* pchFileName);
    ArenaAllocator * GetAllocator()     { return pAllocator; }
    NodeKey NextKey();
#ifdef AST_LIBRARY
    friend bool missingLhsSymbol (IlTree *, AstManager *);
#endif
  private:
    Symbol *LookupSymbol(SymbolKey);
    bool missingLhsSymbol(IlTree *ilTree);

    NodeKey nextKey;

    // IL reader methods and state
    FrontEndType language;
    struct AstStackFrame;

    static SymbolTable *symbolTable;    // to be dynamically changed
    static AstStackFrame *astStackTop;  // to be dynamically changed
    ArenaAllocator *pTempAllocator;     // to be dynamically changed
    IlStream *exStream;
    IlStream *syStream;
    FILE *pchFile;
    IlStream *pchExStream;
    IlStream *pchSyStream;

    void Push(AstNode *astNode);
    AstNode *Pop();
    AstNode *Top();
    AstNode *SecondTop();
    AstExpression *TopExpression();
    void ReverseTopN(int n);
    enum NeedDeref { needLvalue, needRvalue };
    enum HaveDeref { Dereferenced , PlainValue };
    AstNode *ParseEntryBlock(IlTree *ilTree, SymbolTable *globalScope, SymbolTable *formalsScope);
    void ParseIlFunction(IlTree *ilTree);
    void ParseIlStmt(IlTree *ilTree);
    void ParseLhsExpr(IlTree *ilTree, Type *derefType);
    void ParseAsmBlockIlStmt(IlTree *ilTree);
    void ParseBinaryChildren(IlTree *ilTree, NeedDeref needDerefLeft, Type *derefType);
    void ParseHybridList(IlTree *ilTree, Bool fSkip1st, int *childCount);
    void ParseHybridChildren(IlTree *ilTree, int *childCount);
    void ParseAdditionalChildren(IlTree *ilTree, int *childCount);
    void ParseAsmBlockChildren(IlTree *ilTree, int *childCount);
    void InstallChildren(AstNode *node, int count);
    void InstallFunctionChildren(AstNode *node, int count, int formalCount);
    void InstallChildrenSwapped(AstNode *node);
    void InstallChildrenSEHExcept(AstNode *node);
    Bool FIsSymbol(IlTree *ilTree, char *name);
    Bool FIsReturnUdt(IlTree *ilTree);
    Bool FIsInitVBases(IlTree *ilTree);
    Bool FDtoractionTree(IlTree *ilTree);
    TypeFunction *GetFunctionType(Type *fnNodeType);
    // Pushing nodes on the stack
    AstSymbol *PushSymbol(IlTree *symTree);
    void PushClassSymbol(Type *cls, IlTree *iltree);
    void PushFunctionCall(IlTree *call, OpCode callOpCode, int childCount,
                          int firstDefault);
    void PushDefaultConstructor(Type *cls, IlTree *iltree);
    void PushNew(IlTree *newCall);
    void PushNewObject(IlTree *newCall);
    void PushNewArray(IlTree *newCall);
    void PushDelete(IlTree *ilTree, Bool fIsArray);
    void PushAssignment(IlTree *ilTree, OpCode opCode, int childCount);
    void PushNullStmt(IlTree *ilTree);
    void PushNullExpr(IlTree *ilTree);
    void PushUnary(IlTree *ilTree, OpCode opCode);
    void PushCast(IlTree *ilTree, OpCode opCode = ocCast);
    void PushBinary(IlTree *ilTree, OpCode opCode);
    void PushInitialization(IlTree *ilTree);
    void PushExpr(IlTree *ilTree);
    void PushMemberAddress(IlTree *ilTree);

    void RemovePointer(AstExpression *expression);
    void RemovePointerHack(AstExpression *expression);

    void ParseFnArguments(IlTree *ilTree, TypeFunction *calledType,
                          Bool fSkip1st, Bool fSkip1stType,
                          Bool f1stCGisNotOptional,
                          Bool fSkipLast,
                          int *childCount, int *firstDefault);
    void ParseNewCall(IlTree *newCall);
    Bool ParseNewCount(IlTree *newCall);
    void ParseNew(IlTree *newCall, IlTree *constructor);
    // Statement parser functions
    void ParseOPpragma(IlTree *ilTree);
    void ParseOPlabel(IlTree *ilTree);
    void ParseOPasmlabel(IlTree *ilTree);
    void ParseOPgoto(IlTree *ilTree);
    void ParseOPblock(IlTree *ilTree);

    int ParseBlock(IlTree *ilTree,
                   Bool fReducible,
                   Bool fFileScopeInitializer,
                   Bool fConstructor);
    int ParseBlockNoCatch(IlTree *ilTree, IlTree *kid,
                          Bool fReducible,
                          Bool fFileScopeInitializer,
                          Bool fConstructor);
    Bool FIsBaseClassInitializer(IlTree *functionPtr, IlTree *objPtr);
    Bool FIsFieldOfThis(IlTree *objPtr); // OPfield(OPextract("this"),k)
    Bool match_InitVBasesTest(IlTree *ilTree, symkey_t *endLabel);
    Bool match_HiddenVBaseStmt(IlTree *ilStmt);
    Bool match_ctor_init_of_member_with_dtor_but_no_ctor(IlTree *ilStmt);
    Bool match_CG_Call_atexit(IlTree *ilTree);
    void PopSecondKeepingLabels();

    void ParseOPpushstate(IlTree *ilTree);
    void ParseOPtry(IlTree *ilTree);
    void ParseOPdecl(IlTree *ilTree);
    void ParseOPfuncdecl(IlTree *ilTree);
    void ParseOPfuncdefn(IlTree *ilTree);
    void ParseOPinit(IlTree *ilTree);
    void ParseOPentry(IlTree *ilTree);
    void ParseOPreturn(IlTree *ilTree);
    void ParseOPcomma(IlTree *ilTree);
    void ParseOPfor(IlTree *ilTree);
    void ParseOPif(IlTree *ilTree);
    void ParseOPdo(IlTree *ilTree);

    // File scope declarations parser statments
    //   Each returns a count of declarartions parsed.
    int ParseToplevelDecls(IlTree *ilTree);
    int ParseInitializationThunk(Symbol *thunkName);

    // Expression parser functions
    HaveDeref ParseIlExpr(IlTree *ilTree, NeedDeref needDeref, Type *derefType);
    HaveDeref ParseUnaryChild(IlTree *ilTree, NeedDeref needDeref, Type *derefType);
    HaveDeref ParseOPconstant(IlTree *ilTree, NeedDeref *needDeref, Type *derefType);
    HaveDeref ParseOPextract(IlTree *ilTree, NeedDeref *needDeref, Type *derefType);
    HaveDeref ParseOPquestion(IlTree *ilTree, NeedDeref *needDeref, Type *derefType);
    HaveDeref ParseOPpushstate(IlTree *ilTree, NeedDeref *needDeref, Type *derefType);
    HaveDeref ParseOPaddress(IlTree *ilTree, NeedDeref *needDeref, Type *derefType);
    HaveDeref ParseOPsizeof(IlTree *ilTree, NeedDeref *needDeref, Type *derefType);
    HaveDeref ParseOPfield(IlTree *ilTree, NeedDeref *needDeref, Type *derefType);
    HaveDeref ParseOPindex(IlTree *ilTree, NeedDeref *needDeref, Type *derefType);
    HaveDeref ParseOPmfunc(IlTree *ilTree, NeedDeref *needDeref, Type *derefType);
    HaveDeref ParseOPvfunc(IlTree *ilTree, NeedDeref *needDeref, Type *derefType);
    HaveDeref ParseOPfunction(IlTree *ilTree, NeedDeref *needDeref, Type *derefType);
    HaveDeref ParseOPcomma(IlTree *ilTree, NeedDeref *needDeref, Type *derefType);
    HaveDeref ParsePTMFComparisonArgument (IlTree* ilTree);

    HaveDeref ParseOPassign(IlTree *ilTree, NeedDeref *needDeref, Type *derefType);
    HaveDeref ParseOPinit(IlTree *ilTree, NeedDeref *needDeref, Type *derefType);
    HaveDeref ParseOPcast(IlTree *ilTree, NeedDeref *needDeref, Type *derefType);
    HaveDeref ParseOPdyncast(IlTree *ilTree, NeedDeref *needDeref, Type *derefType);
    HaveDeref ParseOPplus(IlTree *ilTree, NeedDeref *needDeref, Type *derefType);
    HaveDeref ParseOPminus(IlTree *ilTree, NeedDeref *needDeref, Type *derefType);
    HaveDeref ParseOPpluseq(IlTree *ilTree, NeedDeref *needDeref, Type *derefType);
    HaveDeref ParseOPminuseq(IlTree *ilTree, NeedDeref *needDeref, Type *derefType);
    HaveDeref ParseOPintrinsic(IlTree *ilTree, NeedDeref *needDeref, Type *derefType);
    HaveDeref ParseOPargument(IlTree *ilTree, NeedDeref *needDeref, Type *derefType);
    HaveDeref ParseOPname(IlTree *ilTree, NeedDeref *needDeref, Type *derefType);

    void MissingOPaddress(IlTree* ilTree, const char *raid_number);


    bool AstManager::match_60NewCall(IlTree *ilTree, IlTree **callTree,
                                     Type **type);
    AstManager::HaveDeref
    AstManager::Parse60NewCall(IlTree *newCall,
                               Type *type,
                               IlTree *rhs,
                               NeedDeref *needDeref,
                               Type *derefType);

};


#endif // INC_NODE_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\SDK\test\include\module.h ===
// -*- Mode:C++ -*-
//
//      Copyright (c) 1996-1998, Microsoft Corp. All rights reserved. 
//
// $Header: /ast/sdk/lib/module.h 7     5/07/96 5:15p Erikruf $
// $NoKeywords: $
//
// 


#ifndef INC_MODULE_H 
#define INC_MODULE_H

class Module: public Object, public WithOwnArena
{
  public: // client methods
    ASTAPI Module(IlPath *ilPath);
    ASTAPI ~Module();
    ASTAPI void Read();   
    ASTAPI void Write(char *outpath);
    ASTAPI SymbolTable *   GetGlobalSymbolTable() { return globalSymbolTable; }
    ASTAPI AstBlock *      GetInitBlock()         { return initBlock; }
    ASTAPI SymbolManager * GetSymbolManager()     { return symbolManager; }
    ASTAPI TypeManager *   GetTypeManager()       { return typeManager; }
    ASTAPI AstManager *    GetAstManager()        { return astManager; }

    ASTAPI FrontEndType    GetLanguage()          { return ilPath->GetLanguage(); }

    ASTAPI ModuleFunctionIterator GetFunctionIterator();

    // DEPRECATED:
    ASTAPI Type * LookupType(TypeIndex);
        // used for program mutation (modification)

  internal:
    // for debugging, we want to make the allocator visible;
    WithOwnArena::pAllocator;

    static Module *current;  // fluid bound during reading.

    ASTAPI Module(IlPath *ilPath, bool usesPCH);

    Bool FUsesPCH() { return fUsesPCH; }
    void SetfUsesPCH( Bool usesPCH ) { fUsesPCH = usesPCH; }

  private:
    // bookkeeping stuff
    SymbolManager *symbolManager;
    TypeManager *typeManager;
    AstManager *astManager;
    TypeIO *typeIO;  // reads/writes type info to/from .pdb/.db
    // state
    IlPath *ilPath;
    SymbolTable *globalSymbolTable;
    AstBlock *initBlock;
    bool fUsesPCH;  // compiled with -Yu

};


#endif // INC_MODULE_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\SDK\test\include\stream.h ===
// -*- Mode:C++ -*-
//
//      Copyright (c) 1996, Microsoft Corp. All rights reserved. 
//
// $Header: /ast/sdk/lib/stream.h 9     5/01/96 4:40p Erikruf $
// $NoKeywords: $
//

// Simple text output streams


#ifndef INC_STREAM_H 
#define INC_STREAM_H

#include <stdio.h>
#include <stdarg.h>

///////////////////////////////////////////////////////////////////////////////
// Class structure (forward declarations) for CFG nodes
//
//   hit ^X^E at end of this line (cxx-replace-class-hierarchy)

class OutputStream;
class   DebugOutputStream;
class   FileOutputStream;
class   StringStream;
class   NullOutputStream;
class   IndentingStream;
class     DumpContext;

class Indentor;

////END////

//
// General output streams (abstract class)
//
class OutputStream: public Object
{
  public: 
    ASTAPI virtual      ~OutputStream() {}
    ASTAPI virtual void Putc(char c);
    ASTAPI virtual void Puts(const char *buf) = 0;
    ASTAPI void         Printf(const char *format, ...);
    ASTAPI virtual void Vprintf(const char *format, va_list data);
    ASTAPI virtual void Flush()         = 0;
    ASTAPI void         Newline();
  protected:
    ASTAPI OutputStream() {};
};

//
// Debug output streams
// These write either to stderr or the debugger transcript window.
//
class DebugOutputStream: public OutputStream
{
  public: 
    enum DebugOutputMode {toStderr, toDebugger};

    ASTAPI         DebugOutputStream(DebugOutputMode m = toStderr) : mode(m) {}
    ASTAPI virtual ~DebugOutputStream()                                      {}

    ASTAPI void         SetMode(DebugOutputMode m) { mode = m; }
    // overrides
    ASTAPI virtual void Puts(char *buf);
    ASTAPI virtual void Flush();
  private:
    DebugOutputMode mode;
};

//
// File output streams
// These write to a specified stdio file descriptor.
//
class FileOutputStream: public OutputStream
{
  public:
    ASTAPI         FileOutputStream(FILE *f): file(f) {}
    ASTAPI virtual ~FileOutputStream()                {}

    ASTAPI void         Redirect(FILE *f); 
    // overrides
    ASTAPI virtual void Puts(const char *buf);
    ASTAPI virtual void Putc(char c);
    ASTAPI virtual void Vprintf(const char *format, va_list data);
    ASTAPI virtual void Flush();
  private: 
    FILE *file;
};

//
// String streams
// These write to an extensible string
//
// This implementation uses a small initial non-heap buffer and moves
// the string into the heap if the buffer overflows.  This makes
// StringStreams quite efficient for making small formatted strings.


class StringStream: public OutputStream
{
  public:
    ASTAPI StringStream();
    ASTAPI virtual ~StringStream();

    // Additional operations
    ASTAPI unsigned int GetLength() { return cursor; }
    ASTAPI const char* GetString();

    ASTAPI void Reset();  // "empties" string stream
    ASTAPI void Set(const char *contents); // copies
    ASTAPI void Prepend(const char *buf);
    ASTAPI void PrePrintf(const char *format, ...);

    //overrides
    ASTAPI virtual void Putc(char c);
    ASTAPI virtual void Puts(const char *buf);
    ASTAPI virtual void Vprintf(const char *format, va_list data);
    ASTAPI virtual void Flush() {}

  private:
    void Ensure(unsigned int needed_length);
    void Grow(unsigned int needed_length);
    static char* Alloc(unsigned int bytes);
    ASTAPI void  FreeAccumulator();

    unsigned int length;
    unsigned int cursor;
    char *accumulator;

    enum { initial_length = 128 };
    char initial_accumulator[initial_length];
};


// inlined StringStream methods

__inline StringStream::StringStream()
    : length(initial_length),
      accumulator(initial_accumulator),
      cursor(0)
{}

__inline StringStream::~StringStream()
{
    if (accumulator != initial_accumulator)
      FreeAccumulator();
}

__inline const char *StringStream::GetString()
{
    // safe assignment: see Ensure.
    accumulator[cursor] = '\0';
    return accumulator;
}

__inline void StringStream::Reset() { cursor = 0; }

//
// /dev/null output stream
// This doesn't actually write anything anywhere.
//
class NullOutputStream : public OutputStream
{
  public:
    // ASTAPI           NullOutputStream()               {}
    ASTAPI virtual      ~NullOutputStream()              {}

    // overrides
    ASTAPI virtual void Puts(const char *buf)                     {}
    ASTAPI virtual void Putc(char c)                              {}
    ASTAPI virtual void Vprintf(const char *format, va_list data) {}
    ASTAPI virtual void Flush()                                   {}
};

// 
// Indenting streams
//
class IndentingStream: public OutputStream
{
  public: 
    ASTAPI         IndentingStream(OutputStream *baseStream);
    ASTAPI virtual ~IndentingStream();

    ASTAPI void         Indent(int incr = 1);
    ASTAPI void         Unindent(int decr = 1);
    ASTAPI void         ResetIndent();
    // overrides
    ASTAPI virtual void Puts(const char *buf);
    ASTAPI virtual void Flush();

  private: 
    OutputStream *pBaseStream;
    int currentIndent;
    Bool pendingIndent;
};

//
// Convenient way to indent/unindent a stream
//
// Declare an Indentor variable and let the constructor/destructor do the
// indenting and unindenting.
// 
class Indentor
{
  public: 
    ASTAPI Indentor(IndentingStream *baseStream, int incr=1);
    ASTAPI ~Indentor();
  private:
    IndentingStream *baseStream;
    int incr;
};      


#ifdef AST_INCLUDE_NON_ESSENTIAL
 #define INDENT(pDC) AST_NAMESPACE_IZE(Indentor) theBogusIndentVariableName(pDC)
 #define INDENT2(pDC, amount) AST_NAMESPACE_IZE(Indentor) theBogusIndentVariableName((pDC), (amount))
#endif

//
// Dump Contexts
//
class DumpContext: public IndentingStream
{
  public: 
    ASTAPI DumpContext(OutputStream *baseStream, int depth)
        : IndentingStream(baseStream), depth(depth) {} 
    ASTAPI virtual ~DumpContext() {} 
    int depth;
};

#endif // INC_STREAM_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\SDK\test\include\project.h ===
// -*- Mode:C++ -*-
//
//      Copyright (c) 1997 Microsoft Corporation.  All rights reserved.
//
//    This work is a trade secret of Microsoft Corporation.
//    Unauthorized disclosure is unlawful.
//
// $Header: /ast/clients/cmdcl/project.h 13    7/12/98 5:03p Rfc $
// $NoKeywords: $
//
//
// File:    clients/cmdcl/project.h
// Creator: Roger Crew

// Exported Function List: 

#ifndef INC_PROJECT_H
#define INC_PROJECT_H

///////////////////////////////////////////////////////////////////////////////
// Class structure for projects
//
//   hit ^X^E at end of this line (cxx-replace-class-hierarchy)

class AstProject;

////END////


#pragma warning(disable:4512 4511 4100)
#include "ast.h"
#include "c1cmdln.h"

class AstProject : public WithOwnUnalignedArena
{
  public:
    class ObjFile;
    struct ObjFileIterator;

    class LinkEntry;
    struct LinkEntryIterator;

    enum LinkKind {
        lkUnknown,              // LIB/LINK we have no idea what it's doing
        lkLink,                 // LINK (build an .exe or .dll)
        lkLib,                  // LIB  (build a .lib)
        lkDef,                  // LIB /DEF (build .lib + .exp)
        lkExtract,              // LIB /EXTRACT (extract .obj)
        lkError                 // illegal value
    };

    class ObjAuxFile;           // pdb/pch reference

    typedef ObjFile *(*ObjFileBuilder)(
        Allocator *resultAllocator, int key, const C1Cmdline &fdata
      );

    typedef LinkEntry *(*LinkBuilder)(
        Allocator *resultAllocator, LinkKind kind, 
        const char *binname, const char *wd, const char **args
      );

  private:
    static char *ildirectory;   // where to create new IL files

    char     *   name;          // print name
    ObjFile **   objfiles;      // C1/C1xx/C2 entries
    int          objcount;
    LinkEntry ** linkentries;   // LINK/LIB entries
    int          linkcount;

  internal:
    Allocator *GetStringAllocator() { return pAllocator; }

  public:
    AstProject(char *name):
        name(name),
        objfiles(NULL), 
        objcount(0),
        linkentries(NULL),
        linkcount(0)
      { }
    ~AstProject();

    // Two ways to create a project.  In both cases ObjFiles are
    // allocated in resultAllocator and fileBuilder (NULL => DefaultBuilder)
    // is used to create them.
    // 
    // (1) Create a project from a file
    static AstProject *NewFileProject(
        char *filename,
        ArenaAllocator *resultAllocator,
        ObjFileBuilder fileBuilder = NULL,
        LinkBuilder linkBuilder    = NULL,
        char *defaultName          = NULL,
        char *ilDirectory          = NULL,
        bool fNoRelocation         = FALSE
      );

    // (2) Create a project from an invocation of the CL driver on argc/argv
    static AstProject *NewCLProject(
        int argc, 
        char **argv,
        ArenaAllocator *resultAllocator,
        ObjFileBuilder fileBuilder = NULL,
        LinkBuilder linkBuilder    = NULL,
        char *defaultName          = NULL,
        char *ilDirectory          = NULL
      );

    static char * GetIlDirectory()           { return ildirectory; }
    static char * InitIlDirectory(char *ild = NULL, bool fMustWork = TRUE);

    char *        GetPrintName()             { return name ? name : "<<unnamed>>"; }
    void          SetPrintName(char *rename) { name = rename; }
    ObjFile **    GetFileArray()             { return objfiles; }
    int           GetFileCount()             { return objcount; }
    ObjFile *     NthFile(int n) const 
      { return (0 <= n && n < objcount) ? objfiles[n] : NULL; }

    // Write out project to OUTS,
    // Exclude -E files unless fKeepCPPs is true
    // Exclude ilname==NULL files if fStripUnbuilt is true
    // Reset all .fGenerated flags
    void          Write(OutputStream *outs, 
                        bool fKeepCPPs = FALSE, 
                        bool fStripUnbuilt = FALSE);

    enum  AuxKind { akPDB = 0, akPCH, akERROR, akCOUNT=akERROR };
    void          RelocateAuxFiles(AuxKind, Allocator *);
    static bool   fTrustPCHdates;

    void          RestoreEmbeddedSources();

    friend class  PFileReader;
    friend class  ProjectBuilder;
    friend class  ObjFile;
    friend struct ObjFileIterator;
    friend struct LinkEntryIterator;
};


class AstProject::ObjFile : public C1Cmdline
{
    friend class PFileReader;
    friend class PCapture;
    friend class ProjectBuilder;
    friend class AstProject;
    friend class AstProject::ObjAuxFile;

    AstProject *parent;

    int   key;                  // 
    FrontEndType language;      // C, C++, or what?

    char  *ilname;              // name generated for IL (NULL => must run C1)
    time_t ildate;              // creation time for ilname+"DB"
    IlPath ilPath;
    bool   fGenerated;          // true iff the IL files were generated during this
                                // session and the corresponding IL name has not
                                // been written out to a new log file.

    bool    fc2Dll;             // are c2 args in DLL format?
    char  **c2args;             // argument vector for c2 (NULL => c2 never run)
    char   *pdbname;            // name of corresponding .pdb file or NULL
    char   *pchname;            // name of corresponding .pch file or NULL
    time_t       pchdate;
    unsigned long pchsig;

    char **esource;             // embedded source

    // how might building IL depend on a .pch/.pdb file
    typedef AstProject::ObjAuxFile ObjAuxFile;
  public:
    typedef AstProject::AuxKind AuxKind;
    enum AuxRefKind {
        arkNone,                // no dependency
        arkCreator,             // building IL creates it (-Yc -YX -Zi)
        arkUser,                // it must exist before IL can be built (-Yu)
    };
  internal:
    void SetAuxName(AuxKind ak, char *newname) {
        switch(ak) { 
          default:    AST_NOT_REACHED;   break;
          case akPCH: pchname = newname; break;
          case akPDB: pdbname = newname; break;
        }
    }

  private:
    struct AuxRef {
        AuxRefKind kind;
        ObjAuxFile *file;
        AuxRef(): kind(arkNone), file(NULL) { }
    };
    AuxRef aux[akCOUNT];

    Module *module;

    // set .ilname if args[ilindex] is for real
    void CheckExistingIL(time_t ildate);
    FrontEndType ExecLanguage(char *path);

  public:
    int          GetKey() const              { return key; }
    char *       GetSrcName() const          { return srcname; }
    char *       GetObjName() const          { return objname; }
    char *       GetWorkingDirectory() const { return cwd; }
    char *       GetILName() const           { return ilname; }
    IlPath *     GetILPath()                 { return &ilPath; }
    FrontEndType GetLanguage() const         { return language; }
    char **      GetC1Args() const          { return args; }
    char **      GetC2Args() const          { return c2args; }

    void         SetC1Args(char **newargs) { args   = newargs; }
    void         SetC2Args(char **newargs) { c2args = newargs; }

    bool         ReplaceC1Arg(char *arg, int prefix, char *newarg);
    void         AppendC1Arg(char *newarg);

    // if necessary, generate ilname and run C1
    bool         EnsureIlPath(bool fRequired = TRUE, bool fForceRebuild = FALSE);       
    bool         FIlExists()         { return ilname != NULL; }
    bool         FModuleExists()     { return module != NULL; }
    bool         FSrcExists();

    // Run preprocessor on this file write output to outfile.
    bool         RunCPP(char *outfile);
    static bool  fDebugC1;      // use astc1d instead of astc1?

    ObjFile(int key, const C1Cmdline &fdata):
        C1Cmdline(fdata),
        parent(NULL), key(key), language(ExecLanguage(fdata.args[0])), 
        ilname(NULL), fGenerated(FALSE), ildate(0),
        module(NULL),
        pchname(NULL), pdbname(NULL),
        pchdate(0), pchsig(0),
        esource(NULL),
        c2args(NULL)
      { }
    ~ObjFile();

    static ObjFile *DefaultBuilder(
        Allocator *resultAllocator,
        // args to ObjFile constructor
        int key, 
        const C1Cmdline &fdata)
      { 
          return new(resultAllocator) ObjFile(key, fdata);
      }

    void PutName(OutputStream *o)
      { o->Printf("%s(%d)", objname, key); }

    Module *        GetModule(bool fRequired = TRUE);
    void            KillModule(bool fIlToo = FALSE);
    void            KillIlFiles();
    SymbolTable *   GetGlobalSymbolTable() { return GetModule()->GetGlobalSymbolTable(); }
    AstBlock *      GetInitBlock()         { return GetModule()->GetInitBlock(); }
    SymbolManager * GetSymbolManager()     { return GetModule()->GetSymbolManager(); }
    TypeManager *   GetTypeManager()       { return GetModule()->GetTypeManager(); }
    AstManager *    GetAstManager()        { return GetModule()->GetAstManager(); }

    void Write(OutputStream *outs);
  internal:
    void SetParent(AstProject *p) { parent = p; }
};

struct AstProject::ObjFileIterator
{
    typedef AstProject::ObjFile ObjFile;
    ObjFile **after;
    ObjFile **current;
  public:
    ObjFileIterator(AstProject *project): 
        current(project->objfiles - 1),
        after(project->objfiles + project->objcount)
      { }
    bool      FNext()    { return (++current < after); }
    ObjFile * NextFile() { return (++current < after) ? *current : NULL; }
    ObjFile * GetFile() const
      { AstAssert (current < after); return *current; }

    // included for hack purposes, ignore it for now...
    ObjFile * PrevFile() { return current[-1]; }
};

class AstProject::ObjAuxFile
{
  public:
    typedef AstProject::ObjFile::AuxKind Kind;

    Kind        kind;              // .pch? .pdb? or what?
    bool        fBuilt;            // IL has been built for some creator
    ObjFile    *firstCreator;      // the first creator (always non-NULL)
    ObjAuxFile *prev;              // previous instance of this file
                                   // (i.e., if file was rewritten during build)

    char *GetWorkingDirectory()   
      { return firstCreator->GetWorkingDirectory(); }
    char *GetName() 
      { 
          switch (kind) { 
            default: 
              AST_NOT_REACHED; 
              return NULL;      // shut up compiler
            case AstProject::akPCH: 
              return firstCreator->pchname;
            case AstProject::akPDB: 
              return firstCreator->pdbname;
          }
      }

    ObjAuxFile(ObjFile *creator, Kind kind, bool fBuilt, ObjAuxFile *prev):
        firstCreator(creator),
        kind(kind),
        prev(prev),
        fBuilt(fBuilt)
      { }

    // If there exists a creator for which ilname is set
    // (and it passes CheckExistingIL()) .firstCreator is the first such;
    // otherwise, .firstCreator is the first creator in the file.

    // It is possible for a .pch to be referenced only via -Yu flags,
    // in which case, we do not bother to create an ObjAuxFile entry
    // since there will be nothing we can do if the .pch does not exist
    // (or is bogus).

    // General:
    //   If IL has already been built for some creator,
    //     fBuilt will be set TRUE and we assume that
    //     the auxiliary file is genuine
    //   When building IL for a creator and fBuilt is FALSE,
    //     we first check if the auxiliary file exists and,
    //     if so, blow it away (since nobody is depending
    //     on it and it might be bogus),
    //   When building IL for a user and fBuilt is FALSE
    //     we first invoke the IL build for .firstCreator
  internal:
    void RemoveIfBogus(char *name);
    void SetParent(AstProject *p) { } // keep V5 compiler happy
};


class AstProject::LinkEntry
{
    friend class PFileReader;
    friend class PCapture;
    friend class ProjectBuilder;
    friend class AstProject;

    typedef AstProject::ObjFile  ObjFile;
    typedef AstProject::LinkKind LinkKind;
  public:

    LinkKind      GetKind() const             { return kind; }
    const char *  GetWorkingDirectory() const { return wd; }
    const char ** GetArgs() const             { return args; }
    const char *  GetBinName() const          { return bin; }

    // list of .obj files this depends on
    size_t        GetFileCount() const        { return C1Cmdline::CountArgs(firstFile); }
    const char ** GetFilenameVector() const   { return firstFile; }
    ObjFile    ** GetObjFileVector() const    { return objIndex; }

    static LinkEntry *DefaultBuilder(
        Allocator *resultAllocator, 
        // args to LinkEntry constructor
        LinkKind kind, 
        const char *binname, 
        const char *wd, 
        const char **args)
      { 
          return new(resultAllocator) LinkEntry(kind, binname, wd, args);
      }

    LinkEntry(LinkKind kind, const char *binName, const char *wd, const char **args);

    ~LinkEntry() { }

    void Write(OutputStream *outs);

  private:
    LinkKind kind;
    const char *  wd;
    const char *  bin;          // what this entry builds
    const char ** args;         // all arguments (arg0, then switches, then files)

    const char ** firstFile;    // first filename argument
    AstProject *  parent;
    int           objsBefore;   // number of c1 entries preceding this one
    ObjFile **    objIndex;     // for each file, corresponding ObjFile or NULL

  internal:
    void SetParent(AstProject *p) { parent = p; }
  public:
    static const char *LinkDescription(LinkKind);
};

struct AstProject::LinkEntryIterator
{
    typedef AstProject::LinkEntry LinkEntry;
    LinkEntry **after;
    LinkEntry **current;
  public:
    LinkEntryIterator(AstProject *project): 
        current(project->linkentries - 1),
        after(project->linkentries + project->linkcount)
      { }
    bool        FNext()     { return (++current < after); }
    LinkEntry * NextEntry() { return (++current < after) ? *current : NULL; }
    LinkEntry * GetEntry() const
      { AstAssert (current < after); return *current; }
};

#endif // INC_PROJECT_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\SDK\test\include\opcode.h ===
// -*- Mode:C++ -*-
//
//      Copyright (c) 1996 Microsoft Corporation.  All rights reserved.
//
//    This work is a trade secret of Microsoft Corporation.
//    Unauthorized disclosure is unlawful.
//
// $Header: $
// $NoKeywords: $
//
//

#ifdef OPDAT
// Ast opcodes
//   opcode name        class                   friendly name
//   --------------------------------------------------------
OPDAT(ocError,            AstNode,                "ERROR")
OPDAT(ocNullStmt,         AstNullStmt,            "NULLSTMT")
OPDAT(ocNullExpr,         AstNullExpr,            "NULLEXPR")
OPDAT(ocConstant,         AstConstant,            "CONSTANT")
OPDAT(ocSymbol,           AstSymbol,              "SYMBOL")
OPDAT(ocFunction,         AstFunction,            "FUNCTION")
OPDAT(ocConstructor,      AstConstructor,         "CONSTRUCTOR")
OPDAT(ocDestructor,       AstFunction,            "DESTRUCTOR")
OPDAT(ocIntrinsic,        AstIntrinsic,           "INTRINSIC")
OPDAT(ocFunctionCall,     AstFunctionCall,        "FUNCTIONCALL")
OPDAT(ocConstructorCall,  AstFunctionCall,        "CONSTRUCTORCALL")
OPDAT(ocRealConstructorFn,AstRealConstructorFn,   "CONSTRUCTORFN")
OPDAT(ocDefConstructorFn, AstConstructorFn,       "DEFCONSTRUCTORFN")
OPDAT(ocDefCopyFn,        AstConstructorFn,       "DEFCOPYFN")
OPDAT(ocNew,              AstNew,                 "NEW")
OPDAT(ocNewObject,        AstNewObject,           "NEWOBJECT")
OPDAT(ocNewArray,         AstNewArray,            "NEW[]")
OPDAT(ocDelete,           AstDelete,              "DELETE")
OPDAT(ocDecl,             AstDeclaration,         "DECLARATION")
OPDAT(ocInit,             AstInitialization,      "=INIT")
OPDAT(ocFuncDecl,         AstFuncDecl,            "FUNCTIONDECLARATION")
OPDAT(ocFuncDefn,         AstFuncDefn,            "FUNCTIONDEFINITION")
OPDAT(ocNeg,              AstUnary,               "-X")
OPDAT(ocNot,              AstUnary,               "!")
OPDAT(ocBitNot,           AstUnary,               "~")
OPDAT(ocCast,             AstCast,                "CAST")
OPDAT(ocStaticCast,       AstCast,                "STATIC_CAST")
OPDAT(ocDynamicCast,      AstCast,                "DYNAMIC_CAST")
OPDAT(ocConstCast,        AstCast,                "CONST_CAST")
OPDAT(ocReinterpretCast,  AstCast,                "REINTERPRET_CAST")
OPDAT(ocDeref,            AstUnary,               "*X")
OPDAT(ocAddress,          AstUnary,               "&X")
OPDAT(ocMemberAddress,    AstMemberAddress,       "&C::X")
OPDAT(ocParen,            AstUnary,               "PAREN")
OPDAT(ocUnaryPlus,        AstUnary,               "+X")
//OPDAT(ocDelete,           AstUnary,               "DELETE")
OPDAT(ocDestructorCall,   AstUnary,               "DESTRUCTORCALL")
OPDAT(ocAssume,           AstUnary,               "ASSUME")
OPDAT(ocSizeof,           AstSizeof,              "SIZEOF")
OPDAT(ocBitAnd,           AstBinary,              "&")
OPDAT(ocBitOr,            AstBinary,              "|")
OPDAT(ocDiv,              AstBinary,              "/")
OPDAT(ocLshift,           AstBinary,              "<<")
OPDAT(ocMinus,            AstBinary,              "-")
OPDAT(ocMul,              AstBinary,              "*")
OPDAT(ocPlus,             AstBinary,              "+")
OPDAT(ocRem,              AstBinary,              "%")
OPDAT(ocRshift,           AstBinary,              ">>")
OPDAT(ocXor,              AstBinary,              "^")
OPDAT(ocEq,               AstBinary,              "==")
OPDAT(ocGe,               AstBinary,              ">=")
OPDAT(ocGt,               AstBinary,              ">")
OPDAT(ocLe,               AstBinary,              "<=")
OPDAT(ocLt,               AstBinary,              "<")
OPDAT(ocNe,               AstBinary,              "!=")
OPDAT(ocField,            AstBinary,              ".")
OPDAT(ocArrow,            AstBinary,              "->")
OPDAT(ocFieldStar,        AstBinary,              ".*")
OPDAT(ocArrowStar,        AstBinary,              "->*")
OPDAT(ocMethodInCall,     AstBinary,              "METHODINCALL")
OPDAT(ocVMethodInCall,    AstBinary,              "VMETHODINCALL")
OPDAT(ocIndex,            AstBinary,              "INDEX")
OPDAT(ocAnd,              AstBinary,              "&&")
OPDAT(ocOr,               AstBinary,              "||")
OPDAT(ocComma,            AstBinary,              ",")
OPDAT(ocAssign,           AstAssignment,          "=")
OPDAT(ocDefine,           AstAssignment,          "DEFINE")
OPDAT(ocAssignBitAnd,     AstAssignment,          "&=")
OPDAT(ocAssignBitOr,      AstAssignment,          "|=")
OPDAT(ocAssignDiv,        AstAssignment,          "/=")
OPDAT(ocAssignLshift,     AstAssignment,          "<<=")
OPDAT(ocAssignMinus,      AstAssignment,          "-=")
OPDAT(ocAssignMul,        AstAssignment,          "*=")
OPDAT(ocAssignPlus,       AstAssignment,          "+=")
OPDAT(ocAssignRem,        AstAssignment,          "%=")
OPDAT(ocAssignRshift,     AstAssignment,          ">>=")
OPDAT(ocAssignXor,        AstAssignment,          "^=")
OPDAT(ocPreInc,           AstAssignment,          "++X")
OPDAT(ocPreDec,           AstAssignment,          "--X")
OPDAT(ocPostInc,          AstAssignment,          "X++")
OPDAT(ocPostDec,          AstAssignment,          "X--")
OPDAT(ocQuestion,         AstQuestion,            "?")
OPDAT(ocThrow,            AstThrow,               "THROW")
OPDAT(ocInitList,         AstInitList,            "INITLIST")
OPDAT(ocExpr,             AstExpr,                "EXPRESSION")
OPDAT(ocBlock,            AstBlock,               "BLOCK")
OPDAT(ocIf,               AstIf,                  "IF")
OPDAT(ocSwitch,           AstSwitch,              "SWITCH")
OPDAT(ocFor,              AstFor,                 "FOR")
OPDAT(ocWhile,            AstWhile,               "WHILE")
OPDAT(ocDo,               AstDo,                  "DO")
OPDAT(ocGoto,             AstGoto,                "GOTO")
OPDAT(ocLabel,            AstLabel,               "LABEL")
OPDAT(ocDefault,          AstDefault,             "DEFAULT")
OPDAT(ocCase,             AstCase,                "CASE")
OPDAT(ocBreak,            AstBreak,               "BREAK")
OPDAT(ocContinue,         AstContinue,            "CONTINUE")
OPDAT(ocReturn,           AstReturn,              "RETURN")
OPDAT(ocAsmBlock,         AstAsmBlock,            "ASMBLOCK")
OPDAT(ocAsmStmt,          AstAsmStmt,             "ASMSTMT")
OPDAT(ocAsmLabel,         AstAsmLabel,            "ASMLABEL")
OPDAT(ocAsmAlign,         AstAsmAlign,            "ASMALIGN")
OPDAT(ocLint,             AstLint,                "LINT")
OPDAT(ocSehTryExcept,     AstSehTryExcept,        "__TRYEXCEPT")
OPDAT(ocSehTryFinally,    AstSehTryFinally,       "__TRYFINALLY")
OPDAT(ocSehLeave,         AstSehLeave,            "__LEAVE")
OPDAT(ocTry,              AstTry,                 "TRY")
OPDAT(ocCatch,            AstCatch,               "CATCH")
OPDAT(ocMax,              AstNode,                "*** END MARKER ***")
#endif // OPDAT


#ifdef PRIMDAT
// unparsing information about AST operators
//      opcode,         name,   kind,           fixity,         prec,   assoc
//      ---------------------------------------------------------------------
PRIMDAT(ocNeg,          "-",    UNARY,          PREFIX,         14,     RIGHT   )
PRIMDAT(ocNot,          "!",    UNARY,          PREFIX,         14,     RIGHT   )
PRIMDAT(ocBitNot,       "~",    UNARY,          PREFIX,         14,     RIGHT   )
PRIMDAT(ocCast,         "",     UNARY,          SPECIAL,        14,     RIGHT   )
PRIMDAT(ocStaticCast,   "static_cast",
                                UNARY,          SPECIAL,        14,     RIGHT   )
PRIMDAT(ocDynamicCast,  "dynamic_cast",
                                UNARY,          SPECIAL,        14,     RIGHT   )
PRIMDAT(ocConstCast,    "const_cast",
                                UNARY,          SPECIAL,        14,     RIGHT   )
PRIMDAT(ocReinterpretCast,"reinterpret_cast",
                                UNARY,          SPECIAL,        14,     RIGHT   )
PRIMDAT(ocDeref,        "*",    UNARY,          PREFIX,         14,     RIGHT   )
PRIMDAT(ocAddress,      "&",    UNARY,          PREFIX,         14,     RIGHT   )
PRIMDAT(ocParen,        "",     UNARY,          SPECIAL,        16,     NONE    )
PRIMDAT(ocUnaryPlus,    "+",    UNARY,          PREFIX,         14,     RIGHT   )
PRIMDAT(ocDelete,       "delete ",UNARY,        PREFIX, 14,     RIGHT   )
PRIMDAT(ocDestructorCall,"",    UNARY,          SPECIAL,        15,     LEFT   )
PRIMDAT(ocAssume,       "__assume ", UNARY,       SPECIAL,       16,     NONE,   )
PRIMDAT(ocSizeof,       "sizeof ", UNARY,       SPECIAL,        16,     NONE,   )
PRIMDAT(ocBitAnd,       "&",    BINARY,         INFIX,          7,      LEFT    )
PRIMDAT(ocBitOr,        "|",    BINARY,         INFIX,          5,      LEFT    )
PRIMDAT(ocDiv,          "/",    BINARY,         INFIX,          12,     LEFT    )
PRIMDAT(ocLshift,       "<<",   BINARY,         INFIX,          10,     LEFT    )
PRIMDAT(ocMinus,        "-",    BINARY,         INFIX,          11,     LEFT    )
PRIMDAT(ocMul,          "*",    BINARY,         INFIX,          12,     LEFT    )
PRIMDAT(ocPlus,         "+",    BINARY,         INFIX,          11,     LEFT    )
PRIMDAT(ocRem,          "%",    BINARY,         INFIX,          12,     LEFT    )
PRIMDAT(ocRshift,       ">>",   BINARY,         INFIX,          10,     LEFT    )
PRIMDAT(ocXor,          "^",    BINARY,         INFIX,          6,      LEFT    )
PRIMDAT(ocEq,           "==",   BINARY,         INFIX,          8,      LEFT    )
PRIMDAT(ocGe,           ">=",   BINARY,         INFIX,          9,      LEFT    )
PRIMDAT(ocGt,           ">",    BINARY,         INFIX,          9,      LEFT    )
PRIMDAT(ocLe,           "<=",   BINARY,         INFIX,          9,      LEFT    )
PRIMDAT(ocLt,           "<",    BINARY,         INFIX,          9,      LEFT    )
PRIMDAT(ocNe,           "!=",   BINARY,         INFIX,          8,      LEFT    )
PRIMDAT(ocField,        ".",    BINARY,         INFIX,          15,     LEFT    )
PRIMDAT(ocArrow,        "->",   BINARY,         INFIX,          15,     LEFT    )
PRIMDAT(ocFieldStar,    ".*",   BINARY,         INFIX,          13,     LEFT    )
PRIMDAT(ocArrowStar,    "->*",  BINARY,         INFIX,          13,     LEFT    )
PRIMDAT(ocIndex,        "",     BINARY,         SPECIAL,        15,     LEFT    )
PRIMDAT(ocAnd,          "&&",   BINARY,         INFIX,          4,      LEFT    )
PRIMDAT(ocOr,           "||",   BINARY,         INFIX,          3,      LEFT    )
PRIMDAT(ocComma,        ",",    BINARY,         INFIX,          -1,     LEFT    )
PRIMDAT(ocAssign,       "=",    BINARY,         INFIX,          1,      RIGHT   )
PRIMDAT(ocAssignBitAnd, "&=",   BINARY,         INFIX,          1,      RIGHT   )
PRIMDAT(ocAssignBitOr,  "|=",   BINARY,         INFIX,          1,      RIGHT   )
PRIMDAT(ocAssignDiv,    "/=",   BINARY,         INFIX,          1,      RIGHT   )
PRIMDAT(ocAssignLshift, "<<=",  BINARY,         INFIX,          1,      RIGHT   )
PRIMDAT(ocAssignMinus,  "-=",   BINARY,         INFIX,          1,      RIGHT   )
PRIMDAT(ocAssignMul,    "*=",   BINARY,         INFIX,          1,      RIGHT   )
PRIMDAT(ocAssignPlus,   "+=",   BINARY,         INFIX,          1,      RIGHT   )
PRIMDAT(ocAssignRem,    "%=",   BINARY,         INFIX,          1,      RIGHT   )
PRIMDAT(ocAssignRshift, ">>=",  BINARY,         INFIX,          1,      RIGHT   )
PRIMDAT(ocAssignXor,    "^=",   BINARY,         INFIX,          1,      RIGHT   )
PRIMDAT(ocPreInc,       "++",   UNARY,          PREFIX,         14,     LEFT    )
PRIMDAT(ocPreDec,       "--",   UNARY,          PREFIX,         14,     LEFT    )
PRIMDAT(ocPostInc,      "++",   UNARY,          POSTFIX,        15,     LEFT    )
PRIMDAT(ocPostDec,      "--",   UNARY,          POSTFIX,        15,     LEFT    )
PRIMDAT(ocQuestion,     "",     TERNARY,        SPECIAL,        2,      LEFT    )
PRIMDAT(ocInitList,     "",     NARY,           SPECIAL,        16,     NONE    )
PRIMDAT(ocFunctionCall, "",     NARY,           SPECIAL,        15,     LEFT    )
PRIMDAT(ocConstructorCall, "",  NARY,           SPECIAL,        15,     LEFT    )
PRIMDAT(ocMethodInCall, ".",    BINARY,         INFIX,          15,     LEFT    )
PRIMDAT(ocVMethodInCall,".",    BINARY,         INFIX,          15,     LEFT    )
PRIMDAT(ocThrow,        "",     NARY,           SPECIAL,        0,      RIGHT   )

#endif // PRIMDAT
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\SDK\test\include\source.h ===
// -*- Mode:C++ -*-
//
//      Copyright (c) 1996-1998, Microsoft Corp. All rights reserved. 
//
// $Header: /ast/sdk/lib/source.h 6     5/02/96 4:43p Erikruf $
// $NoKeywords: $
//
// Source file address support


#ifndef INC_SOURCE_H 
#define INC_SOURCE_H

typedef unsigned long LineNumber;
typedef unsigned short LinePosition;
class SymbolFilename;
class SymbolTable;

//
// Source File Address (SFA)
// SFAs may be "NULL".
//
struct SFA
{
  public: 
    ASTAPI SFA(SymbolFilename *file, LineNumber line, LinePosition pos)
        : fileSymbol(file), lineNumber(line), position(pos)
      {}

    ASTAPI const char*    GetFileName() const;
    // Note: may return NULL if SFA is "NULL".
    // Guarantee: if two SFAs point into the same file then
    // GetFileName will return the same pointer (so pointer comparison
    // can be used instead of strcmp)

    ASTAPI LineNumber     GetLineNumber()   const { return lineNumber; }
    ASTAPI LinePosition   GetLinePosition() const { return position; }
    ASTAPI Bool           Equal(const SFA *other) const;

    ASTAPI Bool IsNull() const { return  fileSymbol==NULL; }
    ASTAPI static SFA GetNull() { return SFA(NULL,0,0);}

    // DEPRECATED: use GetFileName()
    ASTAPI SymbolFilename * GetFileSymbol(void) const  { return fileSymbol; }

  internal:
    SFA() : fileSymbol(0), lineNumber(0), position(0) {}
#if AST_LIBRARY
    SFA(ILSFA ilSFA, SymbolTable *symbolTable);
#endif
    //~SFA() {}
    // contrary to our usual scheme, this class can be copied/assigned
    // we'll just use the default copy constructor and assignment operator!
  private: 
    SymbolFilename *fileSymbol;
    LineNumber lineNumber;
    LinePosition position;

    friend Bool Equal(const SFA*, const struct ILSFA&);
};

ASTAPI extern const SFA SFANULL;

 
#endif // INC_SOURCE_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\SDK\test\include\symbol.h ===
// -*- Mode:C++ -*-
//
//      Copyright (c) 1996-1998, Microsoft Corp. All rights reserved. 
//
// $Header: /ast/sdk/lib/symbol.h 5     5/09/96 1:25p Erikruf $
// $NoKeywords: $
//
// 


#ifndef INC_SYMBOL_H 
#define INC_SYMBOL_H

// only one of these may be set on any given symbol; we assign each
// a unique bit value so we can OR them together to specify sets
// of SymbolKinds in searches.
enum SymbolKind {
    skVariable     = 0x001,   // variables, parameters, static data members
    skField        = 0x002,   // data member
    skTypedef      = 0x004,
    skTag          = 0x008,   // class, struct, union, enum
    skFilename     = 0x010,
    skFunction     = 0x020,
    skImport       = 0x040,
    skWeakImport   = 0x080,
    skEnumConstant = 0x100,
    skLabel        = 0x200,
    skCTemplate    = 0x400,   // class template
    skFTemplate    = 0x800,   // function template

    // mask for all of the above
    skAny          = 0xfff
};

typedef int SymbolKindMask;
typedef unsigned long SymbolKey; 
class TypeMap;

///////////////////////////////////////////////////////////////////////////////
// Class structure for symbols
//
//   hit ^X^E at end of this line (cxx-replace-class-hierarchy)

class Symbol;
class   SymbolVariable;
class   SymbolField;
class   SymbolTypedef;
class   SymbolTag;
class   SymbolLabel;
class   SymbolCommonFunctionStuff;
class     SymbolFunction;
class     SymbolImport;
class       SymbolWeakImport;
class   SymbolEnumConstant;
class   SymbolFilename;
class   SymbolCTemplate;
class   SymbolFTemplate;

class SymbolList;
struct SymbolListIterator;

class SymbolTable;
struct SymbolTableEntryIterator;
struct SymbolTableMaskedEntryIterator;
struct SymbolTableChildIterator;
struct SymbolTableTreeIterator;

class SymbolManager;
struct ModuleFunctionIterator;

////END////

AST_DEFINE_ATTRIBUTE_CLASSES(Symbol, Symbol, SymbolManager);

///////////////////////////////////////////////////////////////////////////////
// Symbol Tables

struct SSR;
class AstBlock;
class AstManager;

typedef OpenHashedVoidPointerMap SymbolMap;
typedef OpenHashedVoidPointerMapIterator SymbolMapIterator;

const int GlobalScopeLevel = 0;

class SymbolTable: public Object
{
  public:
    ASTAPI SymbolTable * GetParent()   { return parent; }
    ASTAPI int           GetLevel()    { return level; }
    ASTAPI Bool          FGlobal()     { return level == GlobalScopeLevel; }
    ASTAPI AstBlock *    GetAstBlock() { return astBlock; }
    ASTAPI Symbol *      LookupName(char *name, Bool fDecorated=FALSE, SymbolKindMask mask=skAny);
    ASTAPI Symbol *      LookupNameLocally(char *name, Bool fDecorated=FALSE, SymbolKindMask mask = skAny);
    ASTAPI void          AddSymbol(Symbol *symbol, SymbolManager *symbolManager);
    // ^^ the key is in the symbol. resolvetypes has gone away.
    ASTAPI SymbolTableChildIterator       GetChildIterator();
    ASTAPI SymbolTableTreeIterator        GetTreeIterator();
    ASTAPI SymbolTableEntryIterator       GetEntryIterator();
    ASTAPI SymbolTableEntryIterator       GetTagTypeIterator();
    ASTAPI SymbolTableMaskedEntryIterator GetMaskedEntryIterator(SymbolKindMask mask, Bool fIncludeCGSymbols = FALSE);
    ASTAPI void Print(OutputStream *stream, Bool fComment=FALSE, SymbolAttribute *attribute = NULL);
    // overrides
    ASTAPI virtual void DumpMethod(DumpContext *pDC);
    ASTAPI static void * operator new(size_t size, SymbolManager *symbolManager);

  internal:
    Symbol *      LookupSymbol(SymbolKey symbolKey);
    Symbol *      LookupSymbolLocally(SymbolKey symbolKey);
    SymbolTable * GetNext()                       { return nextScope; }
    void          SetAstBlock(AstBlock *astBlock) { this->astBlock = astBlock; }

    void Parse(IlPath *ilPath, 
               AstManager *astManager,
               TypeManager *typeManager,
               TypeIO *typeIO,
               SymbolManager *symbolManager);
    int ParseStreams(AstManager *astManager,
                     TypeManager *typeManager,
                     TypeIO *typeIO,
                     SymbolManager *symbolManager,
                     SymbolTable **labelsTableHandle,
                     IlStream *ilStream,
                     int functionLexicalLevel);
    void PrintInternal(IndentingStream *stream, SymbolAttribute *attribute);
    //Functions which Ralph added
    void DumpSymbols(SymbolManager *, TypeIO *, char *);
    void IterateDopeVector (int, TypeIO *, IlStream *, Symbol *, SymbolManager *);
    int IterateFunctionSymbolTable (SymbolTable *, TypeIO *,IlStream *); 

    // used to 'scope' unscoped pdb types
    void  SetType(TypeIndex, Symbol *declaredSymbol, Type*);
    Type* FindTypeLocally(TypeIndex index, Symbol *declaredSymbol);
    TypeMap *typeMap;  // TypeIndex -> Type*
    Type *FindType(TypeIndex index, Symbol *declaredSymbol);

  private: // private state
    SymbolTable(SymbolTable *parent, int level);
    friend struct SymbolTableChildIterator;
    friend struct SymbolTableTreeIterator;
    friend struct SymbolTableEntryIterator;
    friend struct SymbolTableMaskedEntryIterator;
    friend class SymbolManager;

    static SymbolTable *lastScope; // dynamically changed by parser

    SymbolTable *parent;
    SymbolMap *symbolMap;
    SymbolTable *nextScope;
    int level;
    AstBlock *astBlock;
};

///////////////////////////////////////////////////////////////////////////////
// Symbols

class AstNode;
class AstFunction;

//
// Base class for symbols (not instantiable)                        
//
class Symbol: public Object
{
  public:
    ASTAPI SymbolKind    GetKind()          { return symbolKind; }
    ASTAPI SymbolKey     GetKey()           { return symbolKey; }
    ASTAPI AttribKey     GetAttribKey()     { return (AttribKey)symbolKey; }
    ASTAPI Type *        GetType()          { return type; }
    //ASTAPI Type *        GetForwardType()   { return forwardType; }
    ASTAPI Bool          FCompilerGenerated() { return fCompilerGenerated; }
    ASTAPI Bool          FToolGenerated()   { return fToolGenerated; }

    // Every symbol has both a name and a decorated name.
    // They may be the same.
    ASTAPI char *        GetName()          { return name; }
    ASTAPI char *        GetDecoratedName() { return decoratedName; }
    ASTAPI char *        GetLintSpec()      { return lintSpec; }
    ASTAPI SFA *         GetSFA()           { return &sfa; }
    ASTAPI AstNode *     GetDeclaration()   { return declaration; }
    ASTAPI SymbolTable * GetScope()         { return scope; }
    ASTAPI void          DumpRecord(TypeIO *, IlStream *);

    // The visited flag
    ASTAPI Bool          GetVisited()       { return fVisited; }
    ASTAPI void          SetVisited()       { fVisited = TRUE; }
    ASTAPI void          ClearVisited()     { fVisited = FALSE; }

    // A symbol has an owning class (or struct, union, enum or
    // template class) if it names a member or definition local to
    // that "owner".  If the symbol is not "owned", e.g. a plain
    // function or a function parameter, GetOwningClass returns NULL.
    ASTAPI SymbolTag *   GetOwningClass()   { return owningClass; }

    // Downcasts/predicates
    //  (Implementation at end)
    ASTAPI SymbolVariable*  asSymbolVariable();
    ASTAPI SymbolField*     asSymbolField();
    ASTAPI SymbolTypedef*   asSymbolTypedef();
    ASTAPI SymbolTag*       asSymbolTag();
    ASTAPI SymbolLabel*     asSymbolLabel();
    ASTAPI SymbolCommonFunctionStuff*  asSymbolCommonFunctionStuff();
    ASTAPI SymbolFunction*  asSymbolFunction();
    ASTAPI SymbolImport*    asSymbolImport();
    ASTAPI SymbolWeakImport*  asSymbolWeakImport();
    ASTAPI SymbolEnumConstant*  asSymbolEnumConstant();
    ASTAPI SymbolFilename*   asSymbolFilename();
    ASTAPI SymbolCTemplate*  asSymbolCTemplate();
    ASTAPI SymbolFTemplate*  asSymbolFTemplate();

    // overrides
    ASTAPI virtual void  DumpMethod(DumpContext *pDC);
    ASTAPI static void * operator new(size_t size, SymbolManager *symbolManager);
  internal:

    virtual void Initialize(SymbolTable *symTable, TypeManager *typeManager,  TypeIO *typeIO) = 0;
    virtual void Initialize(SymbolTable *symTable, TypeManager *typeManager,
                            TypeIO *typeIO, SymbolKey declaredTypeKey);
    virtual void PrintMethod(IndentingStream *stream) = 0;
    void         Print(IndentingStream *stream, SymbolAttribute *attribute);
    void         SetDeclaration(AstNode *decl) { declaration = decl; }
    void         SetScope(SymbolTable *sc)  { scope = sc; }
    void SetType(Type *ty) { type = ty; }
    //void SetForwardType(Type *ty) {forwardType = ty; }
    //Type *ResolveSymbolType(TypeManager *, TypeIndex, TypeIO *, SymbolTable *);
    TypeIndex GetTypeIndex() { return typeIndex; }
    TypeIndex GetForwardTypeIndex() { return forwardTypeIndex; }

  protected:
    Symbol(SymbolManager *symbolManager, SymbolKind sk, Type *type, char *name,
           char *decoratedName, SymbolTag *owningClass, SFA sfa, char *lintSpec);
    Symbol(SymbolKind sk, SSR *ssr); // constructor used while parsing IL

    SymbolKind symbolKind   : 16;

    Bool fCompilerGenerated : 1 ;
    Bool fToolGenerated     : 1 ;
    Bool fVisited           : 1 ;
    Bool fInitialized       : 1 ;  //needed for SymbolTypedefs when reading PDB

    SymbolKey symbolKey;
    union {
        TypeIndex typeIndex;    // Only used during AST construction
        Type *type;             // Valid when AST has been constructed
    };
    TypeIndex forwardTypeIndex; // Only used during AST construction
    char *name;
    char *decoratedName;        // often same as name (e.g. in C code)
    char *lintSpec;
    SFA sfa;

    AstNode *declaration;
    SymbolTable *scope;
    union
    {
        SymbolKey   owningClassKey;
        SymbolTag*  owningClass;    // NULL if symbol is not a member of a ESU
    };

    friend class SymbolManager;
    friend class SymbolTypedef;
    friend class TypeIO;
};


// Mix-in for symbols which have a "declared type", i.e. a typedef
// symbol which occured in the declaration

class WithDeclaredType
{
  protected:
    WithDeclaredType(SymbolKey key) : declaredTypeKey(key) {};
    WithDeclaredType(Symbol* symbol) : declaredType(symbol) {};
    WithDeclaredType() {};
    union
    {
        SymbolKey declaredTypeKey;
        Symbol *      declaredType;
    };
};

// Answers the question "In what function is this symbol defined".
// Returns the Ast tree for the function in which the symbol is
// defined.  Returns NULL for symbols not defined in some function
// (e.g. global symbols).

ASTAPI AstFunction* AstFunctionWhereSymbolIsDefined(Symbol*);

//
// Represents SSR_NAME, SSR_ARRAY
//
class SymbolVariable: public Symbol, WithDeclaredType
{
  public:
    ASTAPI SymbolVariable(SymbolManager *symbolManager, Type *type,
                          char *name, Bool fGlobal, Bool fFormal, Bool fLocal,
                          char *decoratedName = NULL,
                          SymbolTag *owningClass = NULL,
                          Symbol *declaredType = NULL, Bool fDefined = FALSE,
                          Bool fRegister = FALSE, Bool fThreadStorage = FALSE,
                          Bool fInstantiate = FALSE, Bool fComdate = FALSE,
                          Bool fDllImport = FALSE, Bool fDllExport = FALSE,
                          Bool fStatic = FALSE, 
                          SFA sfa = SFANULL, char *lintSpec = NULL);
    // Miscellaneous info
    ASTAPI Bool        FRegister()       { return fRegister; }
    ASTAPI Bool        FThreadStorage()  { return fThreadStorage; }
    ASTAPI Bool        FInstantiate()    { return fInstantiate; } //COMDAT only
    ASTAPI Bool        FComdat()         { return fComdat; } // COMDAT symbol
    ASTAPI Bool        FDll()            { return fDllImport || fDllExport; }
    ASTAPI Bool        FDllImport()      { return fDllImport; }
    ASTAPI Bool        FDllExport()      { return fDllExport; }
    ASTAPI Bool        FStatic()         { return fStatic; }
    ASTAPI Bool        FDefined()        { return fDefined; }
    ASTAPI Bool        FGlobal()         { return fGlobal; }
    ASTAPI Bool        FFormal()         { return fFormal; }
    ASTAPI Bool        FLocal()          { return fLocal; }
    ASTAPI Bool        FStaticMember()   { return (owningClass != NULL); }
    ASTAPI Symbol *    GetDeclaredType() { return declaredType; }
  internal:
    SymbolVariable(SSR *ssr);        // Standard constructor used while parsing
    SymbolVariable(SSR *ssr, SymbolVariable *symbolVariable); // for COMEQU
    SymbolVariable   * GetAliasSymbol() { return aliasSymbol;} // for COMEQU
    void               SetAliasSymbol(SymbolVariable *); // for COMEQU
    virtual void PrintMethod(IndentingStream *stream);
    virtual void Initialize(SymbolTable *symTable, TypeManager *typeManager, TypeIO *typeIO);
    Bool        FClassLoc()         { return fClassLoc; }
  private:
    Bool fRegister      : 1;
    Bool fThreadStorage : 1;
    Bool fInstantiate   : 1;
    Bool fComdat        : 1;
    Bool fDllImport     : 1;
    Bool fDllExport     : 1;
    Bool fStatic        : 1;
    Bool fDefined       : 1;
    Bool fGlobal        : 1;
    Bool fFormal        : 1;
    Bool fLocal         : 1;
    Bool fClassLoc      : 1;  // need to disambiguate local statics
                              // promoted to global scope
    SymbolVariable * aliasSymbol;
};

//
// Represents SSR_FIELD
//
class SymbolField: public Symbol, WithDeclaredType
{
  public:
    ASTAPI SymbolField(SymbolManager *symbolManager, Type *type, char *name,
                       Symbol *declaredType, SymbolTag *owningClass = NULL,
                       char *decoratedName = NULL, SFA sfa = SFANULL, 
                       char *lintSpec = NULL);
    ASTAPI Symbol *   GetDeclaredType() { return declaredType; }
  internal:
    SymbolField(SSR *ssr);   // Standard constructor used while parsing
    virtual void PrintMethod(IndentingStream *stream);
    virtual void Initialize(SymbolTable *symTable, TypeManager *typeManager, TypeIO *typeIO);
  private:
    friend class SymbolManager;

    // Note: while static fields are a bit like ordinary variables, we
    // don't need the Alias/COMEQU feature since C++ forbids static
    // data members in locally defined classes.
};

//
// Represents SSR_TYPEDEF
//

class SymbolTypedef: public Symbol, WithDeclaredType
{
  public:
    ASTAPI SymbolTypedef(SymbolManager *symbolManager,
                         Type *type,
                         char *name,
                         Symbol *declaredType = NULL, 
                         char *decoratedName = NULL, 
                         SymbolTag *owningClass = NULL,
                         SFA sfa = SFANULL,
                         char *lintSpec = NULL);
    ASTAPI Symbol *      GetDeclaredType() { return declaredType; }
  internal:
    SymbolTypedef(SSR *ssr); // Standard constructor used while parsing
    virtual void PrintMethod(IndentingStream *stream);
    virtual void Initialize(SymbolTable *symTable, TypeManager *typeManager, TypeIO *typeIO);
    //void SetDeclaredType(Symbol * sy) {declaredType = sy; }
  private:
    // For handling, e.g.,  typedef int FOO; typedef FOO BAR.
    //  ^WithDeclaredType
};

//
// Represents SSR_TAG
//
class SymbolTag: public Symbol, WithDeclaredType
{
  public:
    ASTAPI SymbolTag(SymbolManager *symbolManager, Type *type, char *name,
                     Symbol *declaredType = NULL, char *decoratedName = NULL,
                     SymbolTag *owningClass = NULL,
                     SFA sfa = SFANULL, char *lintSpec = NULL);
    ASTAPI Symbol     * GetDeclaredType() { return declaredType; }
    ASTAPI SymbolList * GetMemberList()   { return memberList; }
    ASTAPI void         AddTagMember (Symbol *, SymbolManager *);
    ASTAPI virtual void  DumpMethod(DumpContext *pDC);
  internal:
    SymbolTag(SSR *ssr); // used while parsing only
    virtual void Initialize(SymbolTable *symTable, TypeManager *typeManager, TypeIO *typeIO);
    virtual void PrintMethod(IndentingStream *stream);
  private:
    SymbolList *memberList;
    SymbolList *lastMember;
};

//
// Represents SSR_CTEMPLATE
//
class SymbolCTemplate: public Symbol
{
  internal:
    SymbolCTemplate(SSR *ssr);       // Standard constructor used while parsing
    virtual void PrintMethod(IndentingStream *stream);
    virtual void Initialize(SymbolTable *symTable, TypeManager *typeManager, TypeIO *typeIO);
  private:
};

//
// Represents SSR_FTEMPLATE
//
class SymbolFTemplate: public Symbol
{
  internal:
    SymbolFTemplate(SSR *ssr);
    virtual void PrintMethod(IndentingStream *stream);
    virtual void Initialize(SymbolTable *symTable, TypeManager *typeManager, TypeIO *typeIO);
  private:
};

//
// Represents SSR_LABEL
//
class SymbolLabel: public Symbol
{
  public:
    SymbolLabel(SymbolManager *symbolManager, Type *type, char *name,
                char *decoratedName = NULL, SymbolTag *owningClass = NULL,
                SFA sfa = SFANULL,
                char *lintSpec = NULL);
  internal:
    SymbolLabel(SSR *ssr);   // Standard constructor used while parsing
    void Initialize(SymbolTable *, TypeManager *,  TypeIO *);
    virtual void PrintMethod(IndentingStream *stream);
  private:
};

// 
// Base class for function symbols (not instantiable)
//
class SymbolCommonFunctionStuff: public Symbol //
{
  public:
    ASTAPI Bool FStatic()    { return fStatic; }
    ASTAPI Bool FDll()       { return fDllImport || fDllExport; }
    ASTAPI Bool FDllImport() { return fDllImport; }
    ASTAPI Bool FDllExport() { return fDllExport; }
    ASTAPI Bool FSysapi()    { return fSysapi; } // declared as __sysapi
    ASTAPI Bool FNaked()     { return fNaked; } // _declspec(naked)
    ASTAPI Bool FNoThrow()   { return fNoThrow; }
    // ie. declared with __declspec(nothrow) or throw() exception-specification
    ASTAPI Bool FNoReturn()  { return fNoReturn; } // __declspec(noreturn)
    ASTAPI Bool FVoidParamList() { return fVoidParamList; }
    // ie. declared  int f(void);  rather than  int f();
  protected:
    SymbolCommonFunctionStuff(SymbolManager *symbolManager, SymbolKind sk,
                              Type *type, char *name, char *decoratedName,
                              SymbolTag *owningClass,
                              Bool fVoidParamList, Bool fStatic,
                              Bool fDllImport, Bool fDllExport, Bool fSysapi,
                              Bool fNaked, Bool fNoThrow, Bool fNoReturn,
                              SFA sfa,
                              char *lintSpec);
    SymbolCommonFunctionStuff(SymbolKind sk, SSR *ssr);
    Bool fVoidParamList : 1;
  private:
    Bool fStatic        : 1;
    Bool fDllImport     : 1;
    Bool fDllExport     : 1;
    Bool fSysapi        : 1;
    Bool fNaked         : 1;
    Bool fNoThrow       : 1;
    Bool fNoReturn      : 1;
};

//
// Represents SSR_EXTENTRY (defined, externally visible functions)
//

class SymbolFunction: public SymbolCommonFunctionStuff, WithDeclaredType
{
  public:
    ASTAPI SymbolFunction(SymbolManager *symbolManager, Type *type, char *name,
                          Symbol *declaredType, SymbolTable *formalsScope,
                          char *decoratedName = NULL,
                          SymbolTag *owningClass = NULL,
                          Bool fVoidParamList = FALSE, Bool fStatic = FALSE,
                          Bool fDllImport = FALSE, Bool fDllExport = FALSE,
                          Bool fSysapi = FALSE, Bool fNaked = FALSE,
                          Bool fNoThrow = FALSE, Bool fNoReturn = FALSE,
                          Bool fInline = FALSE,
                          SFA sfa = SFANULL, char *lintSpec = NULL);
    ASTAPI AstFunction * GetAstFunction();
    ASTAPI Bool          FInline()         { return fInline; }
    ASTAPI Bool          FInPch()          { return fInPch; }
    ASTAPI Symbol *      GetDeclaredType() { return declaredType; }
    // overrides
    ASTAPI virtual void  DumpMethod(DumpContext *pDC);
    ASTAPI SymbolTable * GetFormalsSymbolTable() { return formalsScope; }
  internal:
    SymbolFunction(SSR *ssr);        // Standard constructor used while parsing
    void ParseBodySymbols(SymbolTable *prevScope,
                          SymbolTable *parent,
                          AstManager *astManager,
                          TypeManager *typeManager,
                          TypeIO *typeIO,
                          SymbolManager *symbolManager);
    void ParseBodyCode(AstManager *astManager, 
                       TypeManager *typeManager,
                       TypeIO *typeIO);
    virtual void PrintMethod(IndentingStream *stream);
    //Symbol *GetRealFunction(); // returns functions this is an alias for
                               // or NULL.
    virtual void Initialize(SymbolTable *symTable, TypeManager *typeManager, TypeIO *typeIO);
    long GetEXOffset() {return exOffset;}
    long GetSYOffset() {return syOffset;}
    void SetEXOffset(long newOf);
    void SetSYOffset(long newOf);
  private:
    SymbolTable *formalsScope;
    long exOffset;
    long syOffset;
    AstNode *astDefinition; // for thunks, points to real symbol
    Bool fInline : 1;
    Bool fInPch  : 1;
};    

//
// Represents SSR_ENTRY (externally defined (imported) functions)
//
class SymbolImport: public SymbolCommonFunctionStuff, WithDeclaredType
{
  public:
    ASTAPI SymbolImport(SymbolManager *symbolManager, Type *type, char *name,
                        Symbol *declaredType, char *decoratedName = NULL,
                        SymbolTag *owningClass = NULL,
                        Bool fVoidParamList = FALSE, Bool fStatic = FALSE,
                        Bool fDllImport = FALSE, Bool fDllExport = FALSE,
                        Bool fSysapi = FALSE, Bool fNaked = FALSE,
                        Bool fNoThrow = FALSE, Bool fNoReturn = FALSE,
                        SFA sfa = SFANULL,
                        char *lintSpec = NULL);
    ASTAPI Symbol *GetDeclaredType() { return declaredType; }
  internal:
    SymbolImport(SSR *ssr);  // Standard constructor used while parsing
    SymbolImport(SymbolKind sk, SSR *ssr); // Symbolkind is specifiable
    virtual void PrintMethod(IndentingStream *stream);
    virtual void Initialize(SymbolTable *symTable, TypeManager *typeManager, TypeIO *typeIO);
  private:
};

//
// Represents SSR_WEAKENTRY
// (externally defined (imported) functions, which need not be user defined)
//
class SymbolWeakImport: public SymbolImport
{
  public:
    ASTAPI SymbolWeakImport(SymbolManager *symbolManager, Type *type,
                            char *name, Symbol *declaredType,
                            SymbolKey weakExternKey,
                            char *decoratedName = NULL,
                            SymbolTag *owningClass = NULL,
                            Bool fVoidParamList = FALSE, Bool fStatic = FALSE,
                            Bool fDllImport = FALSE, Bool fDllExport = FALSE,
                            Bool fSysapi = FALSE, Bool fNaked = FALSE,
                            Bool fNoThrow = FALSE, Bool fNoReturn = FALSE,
                            SFA sfa = SFANULL,
                            char *lintSpec = NULL);
    ASTAPI SymbolKey GetWeakExternKey() { return weakExternKey; }
  internal:
    SymbolWeakImport(SSR *ssr);      // Standard constructor used while parsing
    virtual void PrintMethod(IndentingStream *stream);
  private:
    SymbolKey weakExternKey;
};

//
// Represents SSR_CONSTANT
//

// The owning class of a SymbolEnumConstant is the SymbolTag which
// names the enum type, e.g.
//
//    class C { enum E { A, B }; };
//
// The owning class of "A" is "E", and the owning class of "E" is "C".

class SymbolEnumConstant: public Symbol
{
  public:
    ASTAPI SymbolEnumConstant(SymbolManager *symbolManager, Type *type,
                              char *name, long value,
                              char *decoratedName = NULL, 
                              SymbolTag *owningClass = NULL,
                              SFA sfa = SFANULL,
                              char *lintSpec = NULL);
    ASTAPI long GetValue() { return value; }
  internal:
    SymbolEnumConstant(SSR *ssr); // Standard constructor used while parsing
    virtual void Initialize(SymbolTable *symTable, TypeManager *typeManager, TypeIO *typeIO);
    virtual void PrintMethod(IndentingStream *stream);
  private:
    long value;
};


//
// Represents SSR_FILENAME
//

// SymbolFilenames are a bit wierd - they have all the symbol
// attributes but the only useful thing about them is the name, which
// is a source file name.

class SymbolFilename: public Symbol
{
  public:
  internal:
    ASTAPI SymbolFilename(SymbolManager *symbolManager, Type *type, char *name,
                          SFA sfa = SFANULL);
    SymbolFilename(SSR *ssr);
    virtual void Initialize(SymbolTable *symTable, TypeManager *typeManager, TypeIO *typeIO);
    virtual void PrintMethod(IndentingStream *stream);
  private:
};

///////////////////////////////////////////////////////////////////////////////
// Symbol List

class SymbolList: public Object {
   public:
     ASTAPI Symbol *GetSymbol() { return symbol; }
   internal:
      SymbolList(Symbol *sy) { symbol = sy; next = NULL; }
      void AddSymbol(Symbol *, SymbolList **, SymbolManager *);
   private:
     friend struct SymbolListIterator;
     friend void SymbolTag::AddTagMember(Symbol *, SymbolManager *);

     SymbolList *next;
     Symbol *symbol;
};

///////////////////////////////////////////////////////////////////////////////
// Symbol Managers
//
// Symbol managers are allocators of symbols as well as the holder of the
// global symbol table.

class SymbolManager: public Object, public WithArena
{
  public:
    ASTAPI SymbolManager(ArenaAllocator *pAllocator);
    ASTAPI ~SymbolManager() {}
    ASTAPI Allocator *   GetAllocator()    { return pAllocator; };
    ASTAPI void          Write(char *, TypeIO *);
    ASTAPI SymbolTable * GetRoot()         { return rootSymbolTable; }
    ASTAPI AttribKey     GetMaxAttribKey() { return (AttribKey)maxKey; }
    ASTAPI short         GetProductID()    { return productID; }
    ASTAPI long          GetIlID()         { return ilID; }
    ASTAPI char          GetTranslatorID() { return translatorID;    }
    // overrides
    // virtual void DumpMethod(DumpContext *pDC);
  internal:
    void RegisterSymbol(Symbol *symbol);
    void RegisterKey(SymbolKey symbolKey);
    void SetProductID(short id) { productID = id; }
    void SetIlID(long id) { ilID = id; }
    void SetTranslatorID(char id) { translatorID = id; }

    // Used to note all functions (globals and methods) in definition order:
    SymbolFunction **allFunctions;
    int allFunctionsCount;
    int allFunctionsLength;
    void AddFunction(SymbolFunction *function);
    SymbolMap *allFunctionsByKey;

    // allTags is used to remember all tags so we can look them up
    // independent of scope.
    // Used in finding correct scope for member functions and static
    // data members.

    OpenHashedVoidPointerMap *allTags;
    Symbol* MakeSymbolFromSSR(SSR& ssr, SymbolTable *symbolTable);
    void InsertSymbolIntoOwnersScope(Symbol* symbol, SymbolKey tagKey);
    void NoteTagNowHasScope(Symbol* tag);
    struct TagInfo* GetTagInfo(SymbolKey tagKey);

    void ResolveTagTypes(TypeIO *typeIO, TypeManager*);
    void FixTagMemberTypes(TypeIO *typeIO, TypeManager*);

    TypeMap *MakeTypeMap();

  private:
    SymbolKey maxKey;
    SymbolTable *rootSymbolTable;
    short productID;
    long ilID;
    char translatorID;
    
    friend class Symbol;
};


// Usage:
//   for (ModuleFunctionIterator iter = module.GetFunctionIterator();
//        iter.FMore();
//        iter.Advance())
//     SymbolFunction *f = iter.GetSymbolFunction();
//
// This delivers the functions in definition order.

struct ModuleFunctionIterator
{
  public:
    ASTAPI Bool FMore();
    ASTAPI void Advance();
  public:
    ASTAPI SymbolFunction* GetSymbolFunction();
  private:
    ASTAPI ModuleFunctionIterator(SymbolManager*);
    friend class Module;
    SymbolManager *symbolManager;
    int index;
};

inline ASTAPI
ModuleFunctionIterator::ModuleFunctionIterator(SymbolManager* symbolManager)
    : symbolManager(symbolManager), index(0)
{
}

inline ASTAPI SymbolFunction* ModuleFunctionIterator::GetSymbolFunction()
{
    return  symbolManager->allFunctions[index];
}

inline ASTAPI Bool ModuleFunctionIterator::FMore()
{
    return  index < symbolManager->allFunctionsCount;
}

inline ASTAPI void ModuleFunctionIterator::Advance()
{
    index++;
}

///////////////////////////////////////////////////////////////////////////////
// Iterators


// iterates through a symtab's child symbol tables
//  - child symbol tables have a particular level (= currentlevel + 1)
struct SymbolTableChildIterator
{
  public:
    ASTAPI SymbolTableChildIterator(); // Allows creation of uninitialized vars
    ASTAPI SymbolTable *NextChild();
  internal:
    SymbolTableChildIterator(SymbolTable *parent, SymbolTable *firstChild);
  private:
    SymbolTable *child;
};

struct SymbolTableTreeIterator
{
  public:
    ASTAPI SymbolTableTreeIterator(); // Allows creation of uninitialized vars
    ASTAPI SymbolTable *NextSymbolTable();
  internal:
    SymbolTableTreeIterator(SymbolTable *parent, SymbolTable *firstChild);
  private:
    SymbolTable *child;
    int parentLevel;
};

struct SymbolTableEntryIterator
{
  public:
    ASTAPI SymbolTableEntryIterator(); // Allows creation of uninitialized vars
    ASTAPI inline Bool      FNextEntry() { return iterator.FNext(); }
    ASTAPI inline Symbol *  NextSymbol() { return static_cast<Symbol *>(iterator.Next()); }
    ASTAPI inline SymbolKey GetKey()
      { return static_cast<SymbolKey>(iterator.GetIndex()); }
    ASTAPI inline Symbol *  GetSymbol()
      { return static_cast<Symbol*>(iterator.GetValue()); }
  internal:
    SymbolTableEntryIterator(SymbolMap *symbolMap):
        iterator(SymbolMapIterator(symbolMap)) {};
  private:
    SymbolMapIterator iterator;
};

struct SymbolTableMaskedEntryIterator
{
  public:
    ASTAPI SymbolTableMaskedEntryIterator(); // Allows creation of uninit vars
    ASTAPI Bool             FNextEntry();
    ASTAPI Symbol *         NextSymbol();
    ASTAPI inline SymbolKey GetKey()
      { return static_cast<SymbolKey>(iterator.GetIndex());}
    ASTAPI inline Symbol *  GetSymbol()
      { return static_cast<Symbol*>(iterator.GetValue());}
  internal:
    SymbolTableMaskedEntryIterator(SymbolKindMask mask, SymbolMap *symbolMap,
                                   Bool fIncludeCGSymbols):
        mask(mask),
        iterator(SymbolMapIterator(symbolMap)),
        fIncludeCGSymbols(fIncludeCGSymbols) {};
  private:
    SymbolMapIterator iterator;
    SymbolKindMask mask;
    Bool fIncludeCGSymbols;
};

// iterates through a symbol list
struct SymbolListIterator
{
  public:
    ASTAPI SymbolListIterator(SymbolList *l):
        current(l), fInitialized(FALSE) { }
    // Cursor must be advanced at least once before getting a field.
    ASTAPI Bool    FNext();     // Advance cursor; return success
    ASTAPI Bool    FDone();     // Has iterator been traversed?
    ASTAPI Symbol *NextSymbol(); // Advance cursor; return next symbol
    ASTAPI Symbol *GetSymbol();  // Return current symbol
    ASTAPI Bool    FLast();     // will FNext() will return false?
  protected:
    Bool fInitialized;
    SymbolList *current;
};


//////////////////////////////////////////////////////////////////////////////
//
// (Another way of doing this is to use virtual functions but
//  they don't inline well)

#define DOWNCAST(kind,class)\
inline ASTAPI class* Symbol::as##class()\
{\
     return  symbolKind == kind ? static_cast<class*>(this) : 0;\
}\
\
inline ASTAPI class* as##class (Symbol* symbol)\
{\
     return  symbol == 0 ? 0 : symbol->as##class();\
}

DOWNCAST(skVariable,SymbolVariable)
DOWNCAST(skField,SymbolField)
DOWNCAST(skTypedef,SymbolTypedef)
DOWNCAST(skTag,SymbolTag)
DOWNCAST(skFilename,SymbolFilename)
DOWNCAST(skFunction,SymbolFunction)
DOWNCAST(skImport,SymbolImport)
DOWNCAST(skWeakImport,SymbolWeakImport)
DOWNCAST(skEnumConstant,SymbolEnumConstant)
DOWNCAST(skLabel,SymbolLabel)
DOWNCAST(skCTemplate,SymbolCTemplate)
DOWNCAST(skFTemplate,SymbolFTemplate)
#undef DOWNCAST

#endif // INC_SYMBOL_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\SDK\test\include\toolkit.h ===
// -*- Mode:C++ -*-
//
//      Copyright (c) 1997 Microsoft Corporation.  All rights reserved.
//
//    This work is a trade secret of Microsoft Corporation.
//    Unauthorized disclosure is unlawful.
//
// $Header: $
// $NoKeywords: $
//
//
// File:    clients/cookbook/toolkit.h
// Creator: ljo

// Exported Function List: 
#ifndef INC_TOOLKIT_H
#define INC_TOOLKIT_H

#include "AstCL.h"

//  An object of class MyAstDataCollection is used during the traversal of
//  AST to collect data.  The user edits the class to add data members to
//  collect information of interest.  The base class AstDataCollection contains
//  virtual member functions.  These functions are invoked during tree 
//  traversal and do nothing.  To use any of these functions to collect 
//  information, create a MyAstDataCollection member function to override the
//  base class function.
//
//  There's one set of functions referenced during traversal of statements, 
//  and one set referenced during traversal of expressions.  The set for 
//  statements consists of a function to be invoked during a preorder 
//  traversal of the statement level AST, and one for the postorder traversal.
//  (Inorder traversal will be if needed.)  For the expression level AST, 
//  the set contains functions to be invoked during a preorder, inorder, 
//  and postorder traversal.  The Cut methods are for telling the walker
//  to ignore a given subtree.  If true when applied to that node, the preorder
//  and postorder functions won't be called on the node or any of its descendents.
//
//  A quick example -
//  If I want to count the number of 'for' statements, I edit the definition
//  of MyAstDataCollection to add a member to keep the count of 'for'
//  statements.  Add a preorder statement traversal function to 
//  MyAstDataCollection to check the opcode of the AstNode argument, adding 
//  one to the counter if it's a 'for' node (i.e, ocFor).


class AstDataCollection : public Object {
public:
    // Processing control functions
    virtual bool WantToProcessFile(char *fileName);
    virtual bool WantToProcessFunction(SymbolFunction *);

    // Collection functions
    virtual bool PreOrderStatement(AstDeclStat *);  // was (AstStatement *)
    virtual bool PostOrderStatement(AstDeclStat *); // was (AstStatement *)
    virtual bool FCutStatement(AstDeclStat *);
    virtual bool PreOrderExpression(AstExpression *);
    virtual bool InOrderExpression(AstExpression *);
    virtual bool PostOrderExpression(AstExpression *);
    virtual bool FCutExpression(AstExpression *);

    // Traversal functions
    virtual void WalkFunctions (Module *mod);
    virtual bool WalkStatement (AstDeclStat *);
    virtual bool WalkExpression (AstExpression *);

    // Ctors/Dtors
    AstDataCollection () {};
    ~AstDataCollection () {};

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\SDK\test\include\util.h ===
// -*- Mode:C++ -*-
//
//      Copyright (c) 1996, Microsoft Corp. All rights reserved. 
//
// $Header: /ast/sdk/lib/util.h 2     5/07/96 12:56p Erikruf $
// $NoKeywords: $
//

// random utils that don't seem to fit anywhere else

#ifndef INC_UTIL_H 
#define INC_UTIL_H


class Util
{
  public:
    ASTAPI static int EscapeString(char *pBytes, int cBytes, char *buf, int bufSize);
    ASTAPI static int EscapeWideString(short *pWords, int cWords, char *buf, int bufSize);
};

class PathUtil
{
  public:

    // is this an absolute path?
    ASTAPI static bool
    FAbsolute(const char *path);

    // Utilities for path surgery:

    // Common features of all Expand* routines:
    //   If WDIR is NULL,  print PATH to OUTS
    //   If WDIR is given, print expansion of PATH relative to WDIR
    //     In both cases, resolve . and .. components appropriately.
    //   Return TRUE iff successful, otherwise return FALSE and print nothing
    //   Failure occurs only if either
    //     (1) path is NULL 
    //     (2) PATH is relative, WDIR is given, *and*
    //         WDIR and PATH both have explicit, distinct drives
    //         (i.e., somebody grabbed the *wrong* current directory).

    // vanilla Expand
    ASTAPI static bool
    Expand(OutputStream *outs, 
           const char *wdir, 
           const char *path);

    // Expand, and if the filename in PATH has
    // no extension fill in a default extension EXT
    ASTAPI static bool
    ExpandDefaultExt(
        OutputStream *outs, 
        const char *wdir, 
        const char *path,
        const char *ext);

    // Expand, replace (fill in) extension with EXT
    ASTAPI static bool
    ExpandForceExt(
        OutputStream *outs, 
        const char *wdir, 
        const char *path,
        const char *ext);

    // Expand, omitting any extension
    ASTAPI static bool
    ExpandNoExt(
        OutputStream *outs, 
        const char *wdir, 
        const char *path);

    // Both of the following emit any necessary trailing path separator
    // and thus may be followed immediately with
    //   outs->Puts(filename)

    // Expand and omit final component (if it is not . or ..)
    ASTAPI static bool
    ExpandDirOnly(
        OutputStream *outs, 
        const char *wdir, 
        const char *path);

    // Expand assuming final component is a directory.
    ASTAPI static bool
    ExpandAsDir(
        OutputStream *outs, 
        const char *wdir, 
        const char *path);

    // Do  PATH1 relative to working directory WDIR1
    // and PATH2 relative to working directory WDIR2
    // refer to the same file?
    //
    // WDIR1 and WDIR2 are expected to have drive letters or shares.
    // Returns
    //    0 if definitely yes
    //    1 if definitely no
    //   -1 if weirdness is encountered
    ASTAPI static int
    Compare(const char *wdir1,
            const char *path1,
            const char *wdir2,
            const char *path2);

    enum {
        pathEQ  = 0,            // must be same file
        pathNEQ = 1,            // cannot be the same file
        pathINC = -1,           // punt
    };

};

#endif // INC_UTIL_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\SDK\test\include\type.h ===
// -*- Mode:C++ -*-
//
//      Copyright (c) 1996-1998, Microsoft Corp. All rights reserved. 
//
// $Header$
// $NoKeywords: $
//
// 
 
#ifndef INC_TYPE_H 
#define INC_TYPE_H

///////////////////////////////////////////////////////////////////////////////
// Class structure for types
//
//   hit ^X^E at end of this line (cxx-replace-class-hierarchy)

// Type manager
class TypeManager;

class BasicType;
// Indexed types
class   Type;
// Compiler Types
class     TypeVTableShape;
// Named Types
class     TypeTypedef;
// Basic Types
class     TypePrimitive;
class     TypePointer;
class     TypeArray;
// Declared types
class     TypeDeclared;
class       TypeEnum;
class       TypeCSU;
class         TypeStructClass;
class           TypeStruct;
class           TypeClass;
class         TypeUnion;
// Function types
class     TypeFunction;
class       TypeProcedure;
class       TypeMemberFunction;
// Derived types
class     TypeModifier;
class     TypeBitField;
class     TypeDefaultArgument;
// Type lists
class     TypeList;
class       TypeArgumentList;
class       TypeFieldList;
class       TypeMethodList;
// Type list elements
class   TypeField;
class     TypeFieldBaseClass;
class       TypeFieldVirtualBaseClass;
class         TypeFieldIndirectVirtualBaseClass;
class     TypeFieldEnumerate;
class     TypeFieldFriendFunction;
class     TypeFieldFriendClass;
class     TypeFieldMember;
class       TypeFieldStaticMember;
class     TypeFieldMethod;
class     TypeFieldOneMethod;
class     TypeFieldTypeDefinition;
class       TypeFieldTypeDefinitionExt;
class     TypeFieldMemberModification;

// Type list CONS cells;
struct TypeArgumentListPair;
struct TypeFieldListPair;
struct TypeMethodListPair;

// Iterators
struct TypeArgumentListIterator;
struct TypeFieldListIterator;
struct   TypeBaseClassIterator;
struct   TypeDataFieldIterator;
struct TypeMethodListIterator;
class TypeMap;

////END////

// forward declarations

class Symbol;
class SymbolTypedef;
class SymbolManager;
typedef unsigned long SymbolKey; 
class IlPath;
class IlStream;
enum FrontEndType;
class AstBinary;
class AstUnary;
class AstNode;
class AstExpression;
class TypeMap;

//////////////////////////////////////////////////////////////////////////////

enum TypeMemberProtection { prNone, prProtected, prPrivate, prPublic };

enum MethodKind { mkPlain, mkVirtual, mkStatic, mkFriend, mkPureVirtual };

enum FieldMethodKind { fmNormal, fmConstructor, fmDestructor, fmConversion,
                       fmUnknown };

class TypeManager: public Object, public WithArena
{
  public:
    ASTAPI TypeManager(ArenaAllocator *pAllocator);
    ASTAPI ~TypeManager();
    //ASTAPI FrontEndType GetLanguage() { return language; }
    // The routines for retyping symbols must be public so retyping clients can use them.
    // DEPRECATED
    ASTAPI Type *       RetypeSymbol(Symbol *psymbol);
    ASTAPI TypeTypedef *RetypeTypeSymbol(Symbol *psymbol);
    ASTAPI static Bool  SameTypeIgnoringSpecialCases(Type *t1, Type *t2); //not for abstract types.

  internal:
    FrontEndType language;
    WithArena::pAllocator;
};

struct TypeFieldListPair
{
    TypeField *type;
    struct TypeFieldListPair *next;
};

struct TypeArgumentListPair
{
    union {
        TypeIndex typeIndex;    // Only used during AST construction
        Type *type;             // Valid when AST has been constructed
    };
    struct TypeArgumentListPair *next;
};

struct TypeMethodListPair
{
    MethodKind kind                 : 8;
    TypeMemberProtection protection : 8;
    union {
        TypeIndex typeIndex;    // Only used during AST construction
        TypeFunction *type;     // Valid when AST has been constructed
    };
    struct TypeMethodListPair *next;
};

struct TypeArgumentListIterator
{
  public:
    ASTAPI TypeArgumentListIterator(struct TypeArgumentListPair *firstPair):
        current(firstPair), ordinal(-1) { }
    // Cursor must be advanced at least once before getting a field or asking FDone.
    ASTAPI Bool   FNext();      // Advance cursor; return success status
    ASTAPI Type * NextType();   // Advance cursor; return new field
    ASTAPI Type * GetType();    // Return current field
    ASTAPI Bool   FLast();      // Will FNext() will return false?
    ASTAPI Bool   FDone();      // Has iterator been traversed?
    ASTAPI int    GetOrdinal() { return ordinal; }
  private:
    int ordinal;
    struct TypeArgumentListPair *current;
};


struct TypeFieldListIterator
{
  public:
    ASTAPI TypeFieldListIterator(struct TypeFieldListPair *firstPair):
        current(firstPair), fInitialized(FALSE) { }
    // Cursor must be advanced at least once before getting a field or asking FDone.
    ASTAPI virtual Bool        FNext();     // Advance cursor; return success
    ASTAPI virtual TypeField * NextField(); // Advance cursor; return new field
    ASTAPI         TypeField * GetField();  // Return current field
    ASTAPI virtual Bool        FLast();     // will FNext() will return false?
    ASTAPI         Bool        FDone();     // Has iterator been traversed?
  protected:
    Bool fInitialized;  // This flag handles the startup boundary condition.
                        // By convention, the iterator's client must start by advancing the conceptual cursor, but
                        // the physical cursor stays put since the list doesn't have a fake header.
    struct TypeFieldListPair *current;
};

struct TypeBaseClassIterator: public TypeFieldListIterator
{
  public:
    ASTAPI TypeBaseClassIterator(struct TypeFieldListPair *firstPair):
        TypeFieldListIterator(firstPair) { }
    // overrides
    ASTAPI Bool                 FNext();
    ASTAPI Bool                 FLast();
    ASTAPI Bool                 FDone();      // Has iterator been traversed?
    ASTAPI TypeFieldBaseClass * NextBaseClass();
};

struct TypeDataFieldIterator: public TypeFieldListIterator
{
  public:
    ASTAPI TypeDataFieldIterator(struct TypeFieldListPair *firstPair):
        TypeFieldListIterator(firstPair) { }
    // overrides
    ASTAPI Bool        FNext();
    ASTAPI Bool        FLast();
    ASTAPI Bool        FDone();      // Has iterator been traversed?
    ASTAPI TypeField * NextField();
};

struct TypeMethodListIterator
{
 public:
    ASTAPI TypeMethodListIterator(TypeMethodListPair *firstPair):
        current(firstPair), fInitialized(FALSE) {}
    // Cursor must be advanced at least once before getting a field or asking FDone.
    ASTAPI Bool                 FNext(); // Advance cursor; return success
    ASTAPI TypeFunction *       NextMethod(); // Advance cursor; return method
    ASTAPI Bool                 FLast();         // Will FNext() return false?
    ASTAPI Bool                 FDone();      // Has iterator been traversed?
    ASTAPI TypeFunction *       GetMethodType(); // Return current method
    ASTAPI TypeMemberProtection GetProtection(); // Return current protection
    ASTAPI MethodKind           GetMethodKind(); // Return current MethodKind
 private:
    Bool fInitialized;
    struct TypeMethodListPair *current;
};

class BasicType: public Object
{
  public:

  internal:
    // Initialize replaces type indices with pointers to type objects.
    virtual void Initialize(TypeManager *typeManager, SymbolTable *symbolTable, TypeIO *typeIO) = 0;
    static inline void * operator new(size_t size, TypeManager *typeManager)
      { return typeManager->Alloc(size); }

  protected:
    BasicType() { }
  private:
    BasicType(BasicType&) { }
};


// Typedefs are a way of generating many types that are names for the
// same type.  A Type's PlainType is the type with no
// TypeTypedefs.  This is different from SkipTypedefs, which just
// removes the immediately accessible typedefs.
//
//  typedef int INT;
//  typedef INT *P;
//  P p;
//
//  The type of "p" (lets call it p.type) is
//     "P"-which-is  pointer-to  "INT"-which-is "int".
//     (TypeTypedef  TypePointer TypeTypedef    TypePrimitive)
//  p.type->PlainType() is pointer-to "int".
//  p.type->SkipTypedefs() is pointer-to "INT"-which-is "int".
//
//  There is an exception to this rule.  The types of struct (etc)
//  members retain their typedefs.

enum TypeKind
{
    tkPrimitive, tkVTableShape, tkPointer, tkArray, tkStruct,
    tkClass, tkUnion, tkEnum, tkProcedure, tkMemberFunction,
    tkModifier, tkBitField, tkDefaultArgument, tkTypedef,
    tkError
};

class Type: public BasicType
{
  public:
    ASTAPI TypeIndex        GetIndex()                 { return index; }
    ASTAPI virtual TypeKind GetTypeKind()              = 0;
    //
    ASTAPI         Type*    PlainType()                { return plainType; }
    ASTAPI virtual Type *   SkipModifiers()            { return this; }
    ASTAPI virtual Type *   SkipTypedefs()             { return this; }
    ASTAPI virtual Type *   SkipModifiersAndTypedefs() { return this; }

    ASTAPI virtual size_t   GetSize()                  = 0;
    ASTAPI virtual Bool     FHasSize()                 { return FALSE; }

    ASTAPI         Bool     FPlain() { return this == PlainType(); }

  public:
    // "Downcasts".
    // These member functions return NULL if the type is not of the
    // appropriate kind, otherwise they act as a downcast.

    ASTAPI virtual TypePrimitive* asPrimitive() { return 0; }
    ASTAPI virtual TypeModifier*  asModifier() { return 0; }

    // asPointer: it is a simple pointer (NOT reference or member-pointer)
    ASTAPI virtual TypePointer* asPointer()    { return 0; }
    ASTAPI virtual TypePointer* asReference()  { return 0; }
    ASTAPI virtual TypePointer* asPointerToMember()         { return 0; }
    ASTAPI virtual TypePointer* asPointerToMemberFunction() { return 0; }
    ASTAPI virtual TypePointer* asPointerToDataMember()     { return 0; }

    ASTAPI virtual TypeDeclared*    asTypeDeclared() { return 0; }
    ASTAPI virtual TypeEnum*        asEnum()         { return 0; }
    ASTAPI virtual TypeCSU*         asCSU()          { return 0; }
    ASTAPI virtual TypeUnion*       asUnion()        { return 0; }
    ASTAPI virtual TypeStructClass* asStructClass()  { return 0; }
    ASTAPI virtual TypeStruct*      asStruct()       { return 0; }
    ASTAPI virtual TypeClass*       asClass()        { return 0; }

    ASTAPI virtual TypeTypedef*     asTypedef()      { return 0; }

    ASTAPI virtual TypeArray*       asArray()        { return 0; }

    ASTAPI virtual TypeFunction*       asFunction()       { return 0; }
    ASTAPI virtual TypeProcedure*      asProcedure()      { return 0; }
    ASTAPI virtual TypeMemberFunction* asMemberFunction() { return 0; }

    ASTAPI virtual TypeBitField*    asBitField() { return 0; }

    // These never occur in practice:
    ASTAPI virtual TypeVTableShape*     asVTableShape()     { return 0; }
    ASTAPI virtual TypeDefaultArgument* asDefaultArgument() { return 0; }

    // "Missing Downcasts". There are no downcasts for TypeList,
    // TypeArgumentList etc because the list is always part of
    // something else, e.g. a TypeStruct or TypeProcedure.

  public:
    // Useful types that are always available

    ASTAPI static TypePrimitive * const  Char;
    ASTAPI static TypePrimitive * const  SChar;
    ASTAPI static TypePrimitive * const  UChar;
    ASTAPI static TypePrimitive * const  SShort;
    ASTAPI static TypePrimitive * const  UShort;
    ASTAPI static TypePrimitive * const  SInt;
    ASTAPI static TypePrimitive * const  UInt;
    ASTAPI static TypePrimitive * const  SLong;
    ASTAPI static TypePrimitive * const  ULong;
    ASTAPI static TypePrimitive * const  SInt64;
    ASTAPI static TypePrimitive * const  UInt64;
    ASTAPI static TypePrimitive * const  Float;
    ASTAPI static TypePrimitive * const  Double;
    ASTAPI static TypePrimitive * const  LDouble;
    ASTAPI static TypePrimitive * const  Void;
    ASTAPI static TypePrimitive * const  WChar;

    ASTAPI static TypePrimitive * const  NoType;   // used for ellipsis (...)
    ASTAPI static TypePrimitive * const  Unknown;  // used for templates

  public:
    ASTAPI void WriteDescription(OutputStream&,
                                 Bool includeObjectAddresses = FALSE);

  internal:
    Type(TypeIndex index);
    virtual void InstallNestedTypeLink();
    virtual void InstallUnparseName(TypeManager *typeManager);

    void DumpStandardPrefix(DumpContext *dc);

  protected:
    Type();
    TypeIndex index;
    Type *plainType;

    //friend class TypeModifier;
};


class TypeTypedef: public Type
{
  public:
    ASTAPI static TypeTypedef* Make(Symbol *typedefSymbol, Type *type,
                                    TypeManager*);
    ASTAPI TypeKind GetTypeKind()              { return tkTypedef; }
    //ASTAPI Type *   PlainType()                { return plainType; }
    ASTAPI Type *   GetType()                  { return type; }
    ASTAPI Symbol * GetSymbol()                { return typedefSymbol; }
    ASTAPI size_t   GetSize()                  { return type->GetSize(); }
    ASTAPI Bool     FHasSize()                 { return type->FHasSize(); }
    ASTAPI Type *   SkipTypedefs()             { return type->SkipTypedefs(); }
    ASTAPI Type *   SkipModifiersAndTypedefs() { return type->SkipModifiersAndTypedefs(); }
    ASTAPI TypeTypedef* asTypedef();

    ASTAPI void     DumpMethod(DumpContext *pDC);

  internal:
    void     Initialize(TypeManager *typeManager, 
                        SymbolTable *symbolTable, 
                        TypeIO *typeIO);
  private:
    // The first argument must be a SymbolTypedef or a SymbolTag.
    TypeTypedef(Symbol *typedefSymbol, Type *type);

    Symbol *typedefSymbol;  
    Type *type;  // What the typedef means.  (May be another typedef.)
};

class TypeVTableShape: public Type
{
  public:
    enum VTableShapeKind {
        vtsNear, vtsFar, vtsThin, vtsOuter,
        vtsMeta, vtsNear32, vtsFar32, vtsError
    };
    ASTAPI TypeVTableShape* asVTableShape();

    ASTAPI TypeKind          GetTypeKind()    { return tkVTableShape; }
    ASTAPI size_t            GetSize()        { return 4 * count; }
    ASTAPI Bool              FHasSize()       { return TRUE; }
    ASTAPI unsigned short    GetCount()       { return count; }
    ASTAPI VTableShapeKind * GetShapeVector() { return shapeVector; }

  protected:
    // Used while parsing types
    TypeVTableShape(TypeIndex typeIndex): Type(typeIndex) { }
    void Initialize(TypeManager *typeManager, SymbolTable *symbolTable, TypeIO *typeIO) { }

    ASTAPI TypeVTableShape(unsigned short count, VTableShapeKind *shapeVector);
  private:
    unsigned short count;
    VTableShapeKind *shapeVector;

    friend class TypeIO;
};


enum PrimitiveKind
{
    ptChar, ptSChar, ptUChar, ptSShort, ptUShort,
    ptSInt, ptUInt, ptSLong, ptULong, ptSInt64, ptUInt64,
    ptFloat, ptDouble, ptLDouble,
    ptVoid, ptWChar,
    ptNoType,  // used for Varargs, elipsis catch expressions etc
    // workaround for frontEnd bug;
    // unresolved template parameters will be of this type --rfc
    ptUnknown
};

class TypePrimitive: public Type
{
  public:
    ASTAPI static TypePrimitive* Make(PrimitiveKind pk);
    ASTAPI TypeKind      GetTypeKind() { return tkPrimitive; }
    ASTAPI TypePrimitive* asPrimitive();
    ASTAPI Bool          FReal();
    ASTAPI Bool          FUnsigned();
    ASTAPI Bool          FSigned();
    // ASTAPI Bool       FComplex();
    // ASTAPI Bool       FBoolean();
    ASTAPI size_t        GetSize();
    ASTAPI Bool          FHasSize();
    ASTAPI PrimitiveKind GetPrimitiveKind() { return kind; }
    ASTAPI const char *  GetName();
    ASTAPI void          DumpMethod(DumpContext *pDC);

  internal:
    void Initialize(TypeManager *typeManager, SymbolTable *symbolTable, TypeIO *typeIO) { }
    static TypePrimitive* MakeFromIndex(TypeIndex index);
    TypePrimitive(PrimitiveKind kind, TypeIndex index);

  protected:
    PrimitiveKind kind : 8;

    friend void InitializeTypes();
};
    
class TypeModifier: public Type
{
  public:
    ASTAPI virtual TypeModifier*  asModifier();

    ASTAPI static TypeModifier* Make(Bool fConst, Bool fVolatile,
                                     Bool fUnaligned, Bool fRestricted,
                                     Type *base,
                                     TypeManager*);
    ASTAPI static TypeModifier* MakeConst(Type *base, TypeManager*);

    ASTAPI TypeKind GetTypeKind()   { return tkModifier; }
    ASTAPI Type *   SkipModifiers() { return baseType->SkipModifiers(); }
    ASTAPI Type *   SkipModifiersAndTypedefs() {return baseType->SkipModifiersAndTypedefs();}
    ASTAPI Type *   GetBaseType()   { return baseType; }
    ASTAPI size_t   GetSize()       { return baseType->GetSize(); }
    ASTAPI Bool     FHasSize()      { return baseType->FHasSize(); }
    ASTAPI Bool     FConst()        { return fConst; }
    ASTAPI Bool     FVolatile()     { return fVolatile; }
    ASTAPI Bool     FUnaligned()    { return fUnaligned; }
    ASTAPI Bool     FRestricted()   { return fRestricted; }

  internal:
  private:
    static TypeModifier* Make(TypeIndex myIndex,
                              Bool fConst, Bool fVolatile,
                              Bool fUnaligned, Bool fRestricted,
                              Type *base,
                              TypeManager*);
    TypeModifier(TypeIndex baseTypeIndex, Type *baseType,
                 Bool fConst, Bool fVolatile,
                 Bool fUnaligned, Bool fRestricted,
                 TypeManager*);

    // Only used during type parsing
    TypeModifier(TypeIndex typeIndex);
    void Initialize(TypeManager *typeManager, SymbolTable *symbolTable, TypeIO *typeIO);
    void SetPlainType(TypeManager*);

    Bool fConst      : 1 ;
    Bool fVolatile   : 1 ;
    Bool fUnaligned  : 1 ;
    Bool fRestricted : 1 ;
    union {
        TypeIndex baseIndex;    // Only used during AST construction
        Type *baseType;         // Valid when AST has been constructed
    };

    friend class TypeIO;
};


enum PointerAttribute { paNormal, paBasedGlobal, paBasedVoid };

enum PointerKind { pkPointer, pkReference,
                   pkDataMemberPointer, pkMethodPointer };

class TypePointer: public Type
{
  public:
    ASTAPI TypeKind GetTypeKind()   { return tkPointer; }
    ASTAPI size_t   GetSize()       { return size; }
    ASTAPI Bool     FHasSize()      { return TRUE; }
    ASTAPI Bool     FVolatile()     { return fVolatile; }
    ASTAPI Bool     FConst()        { return fConst; }
    ASTAPI Bool     FUnaligned()    { return fUnaligned; }
    ASTAPI Bool     FRestricted()   { return fRestricted; }
    ASTAPI Type *   GetTargetType() { return targetType; }
    ASTAPI PointerAttribute GetPointerAttribute()
      { return pointerAttribute; }

    ASTAPI virtual TypePointer* asPointer();
    ASTAPI virtual TypePointer* asReference();
    ASTAPI virtual TypePointer* asPointerToMember();
    ASTAPI virtual TypePointer* asPointerToMemberFunction();
    ASTAPI virtual TypePointer* asPointerToDataMember();

    // "Constructors"
    ASTAPI static TypePointer *MakePointer(Type *baseType, TypeManager*);
    ASTAPI static TypePointer *MakeReference(Type *baseType, TypeManager*);
    ASTAPI static TypePointer *MakePointerToMemberFunction(Type* classType,
                                                           Type* memberType,
                                                           TypeManager*);
    ASTAPI static TypePointer *MakePointerToDataMember(Type* classType,
                                                       Type* memberType,
                                                       TypeManager*);

    ASTAPI PointerKind       GetPointerKind() { return pointerKind; }
    ASTAPI Symbol *          GetBasedGlobal(SymbolManager *symbolManager);
    ASTAPI TypeCSU*          GetMemberClass();
    ASTAPI void     DumpMethod(DumpContext *pDC);
    // DEPRECATED:
    ASTAPI TypePointer *NewTargetType(Type *newTarget, TypeManager *typeManager);  // creates pointers with new targets.

  internal:
  protected:    // Used only during type parsing
    TypePointer(TypeIndex typeIndex): Type(typeIndex) { }

    TypePointer(TypeIndex index, Type *targetType, size_t size,
                Bool fVolatile, Bool fConst,
                Bool fUnaligned, Bool fRestricted,
                PointerAttribute pointerAttribute,
                PointerKind pointerKind,
                TypeManager *typeManager);

    void Initialize(TypeManager *typeManager, SymbolTable *symbolTable, TypeIO *typeIO);
    void SetPlainType(TypeManager*);

    // used in making types with index < CV_FIRST_NONPRIM
    static TypePointer *MakePointer(TypeIndex index, Type *baseType, short size, TypeManager*);

  private:
    PointerAttribute pointerAttribute : 8;
    PointerKind pointerKind           : 8;
    short size;
    Bool fVolatile   : 1;
    Bool fConst      : 1;
    Bool fUnaligned  : 1;
    Bool fRestricted : 1 ;
    union {
        TypeIndex targetTypeIndex; // Only used during AST construction
        Type *targetType;          // Valid when AST has been constructed
    };

    union {
        // Valid only when __based on a global
        struct {
            Bool fDone;
            union {
                char *name;
                Symbol *symbol;
            };
        };
        // Valid only when __based on type (e.g. __based(void))
        union {
            TypeIndex basedPtrTypeIndex;
            Type *basedPtrType;
        };
        // Valid only for normal (unbased) pointers)
        //   Pointer to data member or pointer to method
        struct {
            Int16 format;
            union {
                TypeIndex memberClassIndex; // Only used for AST construction
                TypeCSU *memberClassType; // Use this
            };
        };
    };

    friend class TypeIO;
};

class TypeArray: public Type
{
  public:
    ASTAPI static TypeArray* Make(Type *elemType, size_t length, TypeManager*);
    ASTAPI TypeArray* asArray();

    ASTAPI TypeKind GetTypeKind() { return tkArray; }
    ASTAPI size_t   GetSize()     { return size; }
    ASTAPI Bool     FHasSize()    { return TRUE; }
    ASTAPI Type *   GetElemType() { return elemType; }
    ASTAPI size_t   GetLength()   { return length; }

  internal:
  protected:
    TypeArray(TypeIndex typeIndex): Type(typeIndex) { } // Used only during type parsing
    TypeArray(TypeIndex myIndex, Type* elemType, size_t length, TypeManager*);
    void Initialize(TypeManager *typeManager, SymbolTable *symbolTable, TypeIO *typeIO);
    void SetPlainType(TypeManager*);
  private:
    union {
        TypeIndex elemTypeIndex; // Only used during AST construction
        Type *elemType;          // Valid when AST has been constructed
    };
    size_t size;
    size_t length;

    friend class TypeIO;
};

class TypeDeclared: public Type
{
  public:
    ASTAPI Type *                SkipModifiers()  { return this; }
    ASTAPI Type *                SkipModifiersAndTypedefs() {return this; }
    // FForwardRef() is true iff the type is only declared but never defined
    ASTAPI Bool                  FForwardRef()    { return fForwardref; }
    ASTAPI Bool                  FIsNested()      { return fIsNested; }
    ASTAPI Bool                  FIsUnnamed()     { return parseName == NULL; }
    // FIsUnnamed, e.g. enum { A=1 }; struct { int i; }
    ASTAPI const char *          GetParseName()   { return parseName; }
    ASTAPI const char *          GetUnparseName() { return unparseName; }
    ASTAPI unsigned short        GetCount()       { return count; }
    ASTAPI TypeFieldList *       GetFieldList()   { return fieldListType; }

    // Should only be called if FForwardRef() is false:
    ASTAPI TypeFieldListIterator GetFieldListIterator();

    ASTAPI char                  GetPackSize()    { return packSize; }
    ASTAPI TypeDeclared *        GetParentType()  { return parentType; }
    ASTAPI Symbol *              GetTagSymbol()   { return tagSymbol; }
    ASTAPI TypeField *           FindNamedField(char *name);

    ASTAPI virtual TypeDeclared* asTypeDeclared();

  internal:
    TypeDeclared(TypeIndex typeIndex);

    void ReadFields(TypeManager *typeManager, SymbolTable *symbolTable, TypeIO *typeIO);

    void SetPackSize(char size) { packSize = size; }
    void SetParentType(TypeDeclared *declared);
    void InstallUnparseName(TypeManager *typeManager);
    void SetTagSymbol(Symbol *sy) { tagSymbol = sy; }

    virtual void DumpMethod(DumpContext *pDC);
    //virtual void DumpStandardPrefix(DumpContext *dc);

  protected:
    //ASTAPI TypeDeclared *        GetForwardType() { return forwardType; }
    TypeDeclared(Bool fForwardRef, Bool fIsNested, char packSize,
                 unsigned short fieldCount, char *parseName,
                 TypeIndex fieldListIndex);
    TypeDeclared(Bool fForwardRef, Bool fIsNested, char packSize,
                 unsigned short fieldCount, char *parseName,
                 TypeFieldList *fieldListType);

    Bool fForwardref : 1;
    Bool fIsNested   : 1;
    char packSize;
    unsigned short count;
    char *parseName;            // tag name from input program (possibly "")
    char *unparseName;          // tag name usable for output (never "")
    TypeDeclared *parentType;
    Symbol *tagSymbol;          // symbol node for this tag
    //Type *abstractType;         // abstract version of the type for anonymous structs/unions.
                                // Normally the abstract type is associated with a symbol.
    union {
        TypeIndex fieldListIndex; // Only used during AST construction
        TypeFieldList *fieldListType; // Valid only for non-forward types
        //TypeDeclared *forwardType; // "real" type for which this is a forward 
    };
  private:
};


class TypeCSU: public TypeDeclared  // class, struct or union
{
  public:
    ASTAPI TypeCSU *             asCSU();
    ASTAPI size_t                GetSize();
    ASTAPI Bool                  FHasSize();
    ASTAPI TypeDataFieldIterator GetDataFieldIterator();

  protected:
    TypeCSU(TypeIndex typeIndex): TypeDeclared(typeIndex) { }
    void Initialize(TypeManager *typeManager, SymbolTable *symbolTable, TypeIO *typeIO);

    TypeCSU(Bool fForwardRef, Bool fIsNested, char packSize,
            unsigned short fieldCount, char *parseName,
            TypeIndex fieldListIndex, size_t size);
    TypeCSU(Bool fForwardRef, Bool fIsNested, char packSize,
            unsigned short fieldCount, char *parseName,
            TypeFieldList *fieldListType, size_t size);

  internal:
    size_t length;

    friend class TypeIO;
};

class TypeStructClass: public TypeCSU
{
  public:
    ASTAPI TypeStructClass* asStructClass();

    ASTAPI TypeBaseClassIterator GetBaseClassIterator();
    ASTAPI Bool                  FHasVirtualBaseClass();
  internal:
    // Unly used during parsing
    TypeStructClass(TypeIndex typeIndex): TypeCSU(typeIndex) { }

  protected:
    TypeStructClass(Bool fForwardRef, Bool fIsNested, char packSize,
                    unsigned short fieldCount, char *parseName,
                    TypeIndex fieldListIndex, size_t size);
    TypeStructClass(Bool fForwardRef, Bool fIsNested, char packSize,
                    unsigned short fieldCount, char *parseName,
                    TypeFieldList *fieldListType, size_t size);
  internal:
    friend class TypeIO;
};

class TypeStruct: public TypeStructClass
{
  public:
    ASTAPI TypeKind  GetTypeKind() { return tkStruct; }
    ASTAPI TypeStruct* asStruct();

  protected:
    // Users of this constructor must call both Initialize and Fixup later
    ASTAPI TypeStruct(Bool fForwardRef, Bool fIsNested, char packSize,
                      unsigned short fieldCount, char *parseName,
                      TypeIndex fieldListIndex, size_t size);
    // Users of this constructor must call Fixup later (if necessary)
    ASTAPI TypeStruct(Bool fForwardRef, Bool fIsNested, char packSize,
                      unsigned short fieldCount, char *parseName,
                      TypeFieldList *fieldListType, size_t size);
    // Only used for parsing
    TypeStruct(TypeIndex typeIndex): TypeStructClass(typeIndex) { }

    friend class TypeIO;
};

class TypeClass: public TypeStructClass
{
  public:
    ASTAPI TypeKind GetTypeKind() { return tkClass; }
    ASTAPI TypeClass* asClass();

  protected:
    // Users of this constructor must call both Initialize and Fixup later
    ASTAPI TypeClass(Bool fForwardRef, Bool fIsNested, char packSize,
                     unsigned short fieldCount, char *parseName,
                     TypeIndex fieldListIndex, size_t size);
    // Users of this constructor must call Fixup later (if necessary)
    ASTAPI TypeClass(Bool fForwardRef, Bool fIsNested, char packSize,
                     unsigned short fieldCount, char *parseName,
                     TypeFieldList *fieldListType, size_t size);

    // Only used for parsing
    TypeClass(TypeIndex typeIndex): TypeStructClass(typeIndex) { }

    friend class TypeIO;
};

class TypeUnion: public TypeCSU
{
  public:
    ASTAPI TypeUnion* asUnion();
    ASTAPI TypeKind GetTypeKind() { return tkUnion; }

  internal:
  protected:
    // Only used for type parsing
    TypeUnion(TypeIndex typeIndex): TypeCSU(typeIndex) { }

    // Users of this constructor must call both Initialize and Fixup later
    TypeUnion(Bool fForwardRef, Bool fIsNested, char packSize,
              unsigned short fieldCount, char *parseName,
              TypeIndex fieldListIndex, size_t size);
    // Users of this constructor must call Fixup later (if necessary)
    TypeUnion(Bool fForwardRef, Bool fIsNested, char packSize,
              unsigned short fieldCount, char *parseName,
              TypeFieldList *fieldListType, size_t size);

    friend class TypeIO;
};

class TypeEnum: public TypeDeclared
{
  public:
    ASTAPI TypeEnum* asEnum();

    ASTAPI TypeKind GetTypeKind() { return tkEnum; }
    ASTAPI size_t   GetSize();
    ASTAPI Bool     FHasSize();
    ASTAPI Type *   GetBaseType() { return baseType; }
  internal:
  protected:
    // Only used for type parsing
    TypeEnum(TypeIndex typeIndex): TypeDeclared(typeIndex) { }

    // Users of this constructor must call both Initialize and Fixup later
    TypeEnum(Bool fForwardRef, Bool fIsNested, char packSize,
             unsigned short fieldCount, char *parseName,
             TypeIndex fieldListIndex, 
             TypeIndex baseTypeIndex);
    // Users of this constructor must call Fixup later (if necessary)
    TypeEnum(Bool fForwardRef, Bool fIsNested, char packSize,
             unsigned short fieldCount, char *parseName,
             TypeFieldList *fieldListType,
             Type *baseType);

    void Initialize(TypeManager *typeManager, SymbolTable *symbolTable, TypeIO *typeIO);

  private:
    union {
        TypeIndex baseTypeIndex; // Only used during AST construction
        Type *baseType;         // Valid when AST has been constructed
    };

    friend class TypeIO;
};

enum CallingConvention
{
    ccC, ccPascal, ccFastCall, ccStdCall, ccSysCall,
    ccThisCall, ccMIPSCall, ccAlphaCall, ccPPCCall,
    ccGenericCall
};


// TypeFunction represents both ordinary functions and member functions
class TypeFunction: public Type
{
  public:
    ASTAPI TypeFunction*     asFunction();
    ASTAPI size_t            GetSize(); // Will cause an error if called
    ASTAPI Type *            GetReturnType()        { return returnType; }
    ASTAPI CallingConvention GetCallingConvention() { return callingConvention; }
    ASTAPI unsigned short    GetArgumentCount()     { return parameterCount; }
    ASTAPI TypeArgumentList *GetArgumentListType()  { return parameterListType; }
    ASTAPI TypeArgumentListIterator GetArgumentIterator();
    ASTAPI Bool              FVarArgs();

  internal:
    TypeFunction(TypeIndex typeIndex): Type(typeIndex) { } // Only used while parsing types
  protected:
    TypeFunction(TypeIndex returnTypeIndex,
                 CallingConvention callingConvention,
                 TypeIndex parameterListIndex, int parameterCount);
                 // General use constructor
    TypeFunction(Type *returnType, CallingConvention callingConvention,
                 TypeArgumentList *parameterList, int parameterCount);
                 // General use constructor
    union {
        TypeIndex returnTypeIndex;
        Type *returnType;
    };
    CallingConvention callingConvention : 8;
    unsigned short parameterCount;
    union {
        TypeIndex parameterListIndex;
        TypeArgumentList *parameterListType;
    };
};

class TypeProcedure: public TypeFunction
{
  public:
    ASTAPI TypeProcedure* asProcedure();
    ASTAPI TypeKind GetTypeKind() { return tkProcedure; }

  internal:
  protected:
     // Only used while parsing
    TypeProcedure(TypeIndex typeIndex): TypeFunction(typeIndex) { }

    TypeProcedure(TypeIndex myIndex, Type *returnType,
                  CallingConvention callingConvention,
                  TypeArgumentList *parameterList, int parameterCount,
                  TypeManager*);

    void Initialize(TypeManager *typeManager, SymbolTable *symbolTable, TypeIO *typeIO);
    void SetPlainType(TypeManager*);

    friend class TypeIO;
};

class TypeMemberFunction: public TypeFunction
{
  public:
    ASTAPI TypeKind          GetTypeKind() { return tkMemberFunction; }
    ASTAPI TypeMemberFunction *asMemberFunction();
    ASTAPI TypeCSU*          GetClass()    { return classType; }
    ASTAPI Type *            GetThisType() { return thisType; }
    ASTAPI Bool              FConst();
    ASTAPI Bool              FVolatile();
    ASTAPI Bool              FUnaligned();
  internal:
  protected:
    // Only used while parsing
    TypeMemberFunction(TypeIndex typeIndex): TypeFunction(typeIndex) { }

    TypeMemberFunction(TypeIndex myIndex, Type *returnType,
                       CallingConvention callingConvention,
                       TypeArgumentList *parameterList,
                       int parameterCount,
                       TypeCSU *classType, Type *thisType,
                       TypeManager*);

    void Initialize(TypeManager *typeManager, SymbolTable *symbolTable, TypeIO *typeIO);
    void SetPlainType(TypeManager*);

  private:
    union {
        TypeIndex classTypeIndex;
        TypeCSU *classType;
    };
    union {
        TypeIndex thisTypeIndex;
        Type *thisType;
    };

    friend class TypeIO;
};

class TypeBitField: public Type
{
  public:
    static ASTAPI TypeBitField *Make(Int8 length, Int8 startPosition,
                                     Type* fieldType,
                                     TypeManager *typeManager);
    ASTAPI TypeBitField* asBitField();
    ASTAPI TypeKind GetTypeKind() { return tkBitField; }
    ASTAPI size_t   GetSize()     { return fieldType->GetSize(); }
    ASTAPI Bool     FHasSize()    { return fieldType->FHasSize(); }
    ASTAPI Int8     GetLength()   { return length; }
    ASTAPI Int8     GetPosition() { return startPosition; }
    ASTAPI Type *   GetBaseType() { return fieldType; }

  private:
    TypeBitField(TypeIndex typeIndex): Type(typeIndex) { }
    //TypeBitField(Int8 length, Int8 startPosition, TypeIndex fieldTypeIndex);

    TypeBitField(Int8 length, Int8 startPos, Type *fieldType, TypeManager*);
    void Initialize(TypeManager *typeManager, SymbolTable *symbolTable, TypeIO *typeIO);
    void SetPlainType(TypeManager* typeManager);

    Int8 length;
    Int8 startPosition;
    union {
        TypeIndex fieldTypeIndex;
        Type *fieldType;
    };

    friend class TypeIO;
};

class TypeDefaultArgument: public Type
{
  public:
    ASTAPI TypeDefaultArgument* asDefaultArgument();
    ASTAPI TypeKind GetTypeKind()     { return tkDefaultArgument; }
    ASTAPI size_t   GetSize();
    ASTAPI Bool     FHasSize();
    ASTAPI Type *   GetType()         { return argumentType; }
    ASTAPI char *   GetDefaultValue() { return expression; }

  protected:
    TypeDefaultArgument(TypeIndex typeIndex);    // Only used while parsing

    //ASTAPI TypeDefaultArgument(TypeIndex argumentTypeIndex,
    //                           char *expression);
    //ASTAPI TypeDefaultArgument(Type *argumentType, char *expression);
    void Initialize(TypeManager *typeManager, SymbolTable *symbolTable, TypeIO *typeIO);

  private:
    union {
        TypeIndex argumentTypeIndex;
        Type *argumentType;
    };
    char *expression;

    friend class TypeIO;
};


class TypeList: public Type
{
  public:
    ASTAPI TypeKind        GetTypeKind() { return tkError; }
    ASTAPI size_t          GetSize(); // Will cause an error if called
    ASTAPI unsigned long   GetCount()    { return count; }
  protected:
     // Only used while parsing types
    TypeList(TypeIndex typeIndex): Type(typeIndex) { }
    TypeList(int count);
    unsigned long count;
};


class TypeArgumentList: public TypeList
{
  public:
    ASTAPI Bool          FVarArgs() { return fVarArgs; }
    // Note: not pointer to iterator; permits stack allocation of structure:
    ASTAPI TypeArgumentListIterator GetIterator()
      { return TypeArgumentListIterator(firstPair); }

  protected:
    // Only used while parsing types
    TypeArgumentList(TypeIndex typeIndex): TypeList(typeIndex) { }

    void Initialize(TypeManager *typeManager, SymbolTable *symbolTable, TypeIO *typeIO);

    TypeArgumentList(int count, struct TypeArgumentListPair *firstPair,
                     Bool fVarArgs);
  private:
    struct TypeArgumentListPair *firstPair;
    Bool fVarArgs;

    friend class TypeIO;
};

class TypeFieldList: public TypeList
{
  public:
    ASTAPI TypeFieldList(int count, struct TypeFieldListPair *firstPair);
    ASTAPI void Initialize(TypeManager *typeManager, SymbolTable *symbolTable, TypeIO *typeIO);
    // Note: not pointer to iterator; permits stack allocation of structure:
    ASTAPI TypeFieldListIterator GetIterator()
      { return TypeFieldListIterator(firstPair); }
    ASTAPI TypeBaseClassIterator GetBaseClassIterator()
      { return TypeBaseClassIterator(firstPair); }
    ASTAPI TypeDataFieldIterator GetDataFieldIterator()
      { return TypeDataFieldIterator(firstPair); }
    ASTAPI TypeField *FindNamedField(char *name);
  internal:
    TypeFieldList(TypeIndex typeIndex);

    struct TypeFieldListPair *GetList() { return firstPair; }
    void SetBackLink(TypeDeclared *typeDeclared);
    void InstallNestedTypeLink();
    void DestroyList() { firstPair = NULL; count = 0; }
  private:
    TypeIndex continuationIndex;
    struct TypeFieldListPair *firstPair;
    TypeDeclared *backLink;   // to "owner"

    friend class TypeIO;
};

class TypeMethodList: public TypeList
{
  public:
    ASTAPI TypeMethodList(int count, struct TypeMethodListPair *firstPair);
    ASTAPI void   Initialize(TypeManager *typeManager, SymbolTable *symbolTable, TypeIO *typeIO);
    ASTAPI TypeMethodListIterator GetIterator()
      { return TypeMethodListIterator(firstPair); }
  internal:
    // Only used while parsing types
    TypeMethodList(TypeIndex typeIndex): TypeList(typeIndex) { }

  private:
    struct TypeMethodListPair *firstPair;

    friend class TypeIO;
};

enum TypeFieldKind
{
    tfkBase, tfkVirtualBase, tfkIndirectVirtualBase, tfkEnumerate,
    tfkFriendFunction, tfkFriendClass, tfkMember, tfkStaticMember,
    tfkMethod, tfkOneMethod, tfkType, tfkMemberModification, tfkError
};

class TypeField: public BasicType
{
  public:
    ASTAPI virtual TypeFieldKind GetFieldKind() = 0;
  // These next two virtual functions are so Daniel can avoid multiple random downcasts.
    ASTAPI virtual const char *  GetName()      { return NULL; } // Typefields with no name return NULL
    ASTAPI virtual Type *        GetType()      { 
      USER_ERROR("\nNo Type for this TypeField of kind %i.", this->GetFieldKind());
      return NULL; } // shut up the stupid compiler.
  internal:
    void DumpMethod(DumpContext *pDC);
  protected:
    ASTAPI TypeField();
};

class TypeFieldBaseClass: public TypeField
{
  public:
    // Users of this constructor must call both Initialize and Fixup later
    ASTAPI TypeFieldBaseClass(TypeIndex classTypeIndex);
    // Users of this constructor must call Fixup later (if necessary)
    ASTAPI TypeFieldBaseClass(TypeStructClass *classType, TypeMemberProtection protection);
    ASTAPI void                 Initialize(TypeManager *typeManager, SymbolTable *symbolTable, TypeIO *typeIO);
    ASTAPI TypeFieldKind        GetFieldKind()  { return tfkBase; }
    ASTAPI TypeStructClass *    GetClassType()  { return classType; }
    ASTAPI TypeMemberProtection GetProtection() { return protection; }
  internal:
    TypeFieldBaseClass(): TypeField() { } // Used only when parsing types

  protected:
    union {
        TypeIndex classTypeIndex;
        TypeStructClass *classType;
    };
    TypeMemberProtection protection : 8;

    friend class TypeIO;
};

class TypeFieldVirtualBaseClass: public TypeFieldBaseClass
{
  public:
    // Users of this constructor must call both Initialize and Fixup later
    ASTAPI TypeFieldVirtualBaseClass(TypeIndex classTypeIndex,
                                     TypeIndex classPointerTypeIndex);
    // Users of this constructor must call Fixup later (if necessary)
    ASTAPI TypeFieldVirtualBaseClass(TypeStructClass *classType,
                                     Type *classPointerType,
                                     TypeMemberProtection protection);
    ASTAPI void          Initialize(TypeManager *typeManager, SymbolTable *symbolTable, TypeIO *typeIO);
    ASTAPI TypeFieldKind GetFieldKind()        { return tfkVirtualBase; }
    ASTAPI Type *        GetClassPointerType() { return classPointerType; }
  internal:
    TypeFieldVirtualBaseClass(): TypeFieldBaseClass() { } // Only for parsing

  private:
    union {
        TypeIndex classPointerTypeIndex;
        Type *classPointerType;
    };

    friend class TypeIO;
};

class TypeFieldIndirectVirtualBaseClass: public TypeFieldVirtualBaseClass
{
  public:
    // Users of this constructor must call both Initialize and Fixup later
    ASTAPI TypeFieldIndirectVirtualBaseClass(TypeIndex classTypeIndex,
                                             TypeIndex classPointerTypeIndex);
    // Users of this constructor must call Fixup later (if necessary)
    ASTAPI TypeFieldIndirectVirtualBaseClass(TypeStructClass *classType,
                                             Type *classPointerType,
                                             TypeMemberProtection protection);
    ASTAPI TypeFieldKind GetFieldKind() { return tfkIndirectVirtualBase; }
  internal:
    TypeFieldIndirectVirtualBaseClass(): // Only for use when parsing types
        TypeFieldVirtualBaseClass() { }
};

class TypeFieldEnumerate: public TypeField
{
  public:
    ASTAPI TypeFieldEnumerate(Int64 value, char *name);
    ASTAPI void          Initialize(TypeManager *typeManager, SymbolTable *symbolTable, TypeIO *typeIO) { }
    ASTAPI TypeFieldKind GetFieldKind() { return tfkEnumerate; }
    ASTAPI Int64         GetValue()     { return value; }
    ASTAPI const char *  GetName()      { return name; }
  internal:
    TypeFieldEnumerate(): TypeField() { } // Only for use when parsing types

  private:
    Int64 value;
    char *name;

    friend class TypeIO;
};

class TypeFieldFriendFunction: public TypeField
{
  public:
    // Users of this constructor must call both Initialize and Fixup later
    ASTAPI TypeFieldFriendFunction(TypeIndex friendFunctionIndex);
    // Users of this constructor must call Fixup later (if necessary)
    ASTAPI TypeFieldFriendFunction(TypeFunction* friendFunctionType);
    ASTAPI void           Initialize(TypeManager *typeManager, SymbolTable *symbolTable, TypeIO *typeIO);
    ASTAPI TypeFieldKind  GetFieldKind()    { return tfkFriendFunction; }
    ASTAPI TypeFunction * GetFunctionType() { return friendFunctionType;}
    ASTAPI const char *   GetName()         { return name; }
  internal:
    TypeFieldFriendFunction(): TypeField() { } // Only use when parsing types

  private:
    union {
        TypeIndex friendFunctionIndex;
        TypeFunction *friendFunctionType;
    };
    char *name;

    friend class TypeIO;
};
    
class TypeFieldFriendClass: public TypeField
{
  public:
    // Users of this constructor must call both Initialize and Fixup later
    ASTAPI TypeFieldFriendClass(TypeIndex friendClassIndex);
    // Users of this constructor must call Fixup later (if necessary)
    ASTAPI TypeFieldFriendClass(TypeCSU *friendClassType);
    ASTAPI void              Initialize(TypeManager *typeManager, SymbolTable *symbolTable, TypeIO *typeIO);
    ASTAPI TypeFieldKind     GetFieldKind() { return tfkFriendClass; }
    ASTAPI TypeCSU*          GetClassType() { return friendClassType; }
    ASTAPI const char *      GetName()      { return friendClassType->GetUnparseName(); }
  internal:
    TypeFieldFriendClass(): TypeField() { } // Only for use when parsing types

  private:
    union {
        TypeIndex friendClassIndex;
        TypeCSU *friendClassType;
    };

    friend class TypeIO;
};

class TypeFieldMember: public TypeField
{
  public:
    // Users of this constructor must call both Initialize and Fixup later
    ASTAPI TypeFieldMember(TypeIndex memberIndex,
                           TypeMemberProtection protection,
                           size_t offset, char *name);
    // Users of this constructor must call Fixup later (if necessary)
    ASTAPI TypeFieldMember(Type* memberType,
                           TypeMemberProtection protection,
                           size_t offset, char *name);
    ASTAPI void                 Initialize(TypeManager *typeManager, SymbolTable *symbolTable, TypeIO *typeIO);
    ASTAPI TypeFieldKind        GetFieldKind()  { return tfkMember; }
    ASTAPI Type *               GetType()       { return memberType; }
    ASTAPI TypeMemberProtection GetProtection() { return protection; }
    ASTAPI size_t               GetOffset()     { return offset; }
    ASTAPI const char *         GetName()       { return name; }
  internal:
    TypeFieldMember(): TypeField() { } // Only use when parsing types
    void SetType(Type *ty) { memberType = ty; }

  protected:
    union {
        TypeIndex memberIndex;
        Type *memberType;
    };
    TypeMemberProtection protection : 8;
    size_t offset;
    char *name;

    friend class TypeIO;
};

class TypeFieldStaticMember: public TypeFieldMember
{
  public:
    // Users of this constructor must call both Initialize and Fixup later
    ASTAPI TypeFieldStaticMember(TypeIndex memberIndex,
                                 TypeMemberProtection protection,
                                 size_t offset, char *name);
    // Users of this constructor must call Fixup later (if necessary)
    ASTAPI TypeFieldStaticMember(Type* memberType,
                                 TypeMemberProtection protection,
                                 size_t offset, char *name);
    ASTAPI TypeFieldKind GetFieldKind() { return tfkStaticMember; }
  internal:
    TypeFieldStaticMember(): TypeFieldMember() { } // For parsing types only
};

class TypeFieldMethod: public TypeField
{
  public:
    // Users of this constructor must call both Initialize and Fixup later
    ASTAPI TypeFieldMethod(unsigned short count, TypeIndex methodListIndex,
                           char *name);
    // Users of this constructor must call Fixup later (if necessary)
    ASTAPI TypeFieldMethod(unsigned short count, TypeMethodList *methodList,
                           char *name);
    ASTAPI void               Initialize(TypeManager *typeManager, SymbolTable *symbolTable, TypeIO *typeIO);
    ASTAPI TypeFieldKind      GetFieldKind()  { return tfkMethod; }
    ASTAPI unsigned short     GetCount()      { return count; }
    ASTAPI TypeMethodList *   GetMethodList() { return methodListType; }
    ASTAPI const char *       GetName()       { return name; }
    ASTAPI FieldMethodKind    GetFieldMethodKind();
    ASTAPI TypeMethodListIterator GetMethodListIterator()
      { return methodListType->GetIterator(); }
  internal:
    TypeFieldMethod(): TypeField() { } // Only use when parsing types
    TypeIndex GetMethodListIndex() { return methodListIndex; }
    void SetType(Type *ty) { methodListType = ((TypeMethodList *)ty); }

  private:
    unsigned short count;
    union {
        TypeIndex methodListIndex;
        TypeMethodList *methodListType;
    };
    char *name;

    friend class TypeIO;
};

class TypeFieldOneMethod: public TypeField
{
  public:
    // Users of this constructor must call both Initialize and Fixup later
    ASTAPI TypeFieldOneMethod(TypeMemberProtection protection,
                              MethodKind methodKind,
                              TypeIndex functionTypeIndex,
                              char *name);
    // Users of this constructor must call Fixup later (if necessary)
    ASTAPI TypeFieldOneMethod(TypeMemberProtection protection,
                              MethodKind methodKind,
                              TypeFunction* functionType, char *name);
    ASTAPI void                 Initialize(TypeManager *typeManager, SymbolTable *symbolTable, TypeIO *typeIO);
    ASTAPI TypeFieldKind        GetFieldKind()  { return tfkOneMethod; }
    ASTAPI TypeMemberProtection GetProtection() { return protection; }
    ASTAPI MethodKind           GetMethodKind() { return methodKind; }
    ASTAPI TypeFunction *       GetMethodType() { return functionType; }
    ASTAPI const char *         GetName()       { return name; }
    ASTAPI FieldMethodKind      GetFieldMethodKind();
  internal:
    TypeFieldOneMethod(): TypeField() { } // Use when parsing types only
    void SetType(Type *ty) { functionType = ((TypeFunction *)ty); }
    TypeIndex GetFunctionTypeIndex() { return functionTypeIndex; }

  private:
    TypeMemberProtection protection : 8;
    MethodKind methodKind           : 8;
    union {
        TypeIndex functionTypeIndex;
        TypeFunction *functionType;
    };
    char *name;

    friend class TypeIO;
};

class TypeFieldTypeDefinition: public TypeField
{
  public:
    // Users of this constructor must call both Initialize and Fixup later
    ASTAPI TypeFieldTypeDefinition(TypeIndex nestedTypeIndex, char *name);
    // Users of this constructor must call Fixup later (if necessary)
    ASTAPI TypeFieldTypeDefinition(Type *nestedType, char *name);
    ASTAPI void                 Initialize(TypeManager *typeManager, SymbolTable *symbolTable, TypeIO *typeIO);
    ASTAPI TypeFieldKind        GetFieldKind()  { return tfkType; }
    ASTAPI Type *               GetType()       { return nestedType; }
    ASTAPI TypeMemberProtection GetProtection() { return protection; }
    ASTAPI const char *         GetName()       { return name; }
  internal:
    TypeFieldTypeDefinition(): TypeField() { } // For type parsing only

  protected:
    TypeMemberProtection protection : 8;
    union {
        TypeIndex nestedTypeIndex;
        Type *nestedType;
    };
    char *name;

    friend class TypeIO;
};

class TypeFieldTypeDefinitionExt: public TypeFieldTypeDefinition
{
  public:
    // Users of this constructor must call both Initialize and Fixup later
    ASTAPI TypeFieldTypeDefinitionExt(TypeMemberProtection protection,
                                      TypeIndex nestedTypeIndex, char *name);
    // Users of this constructor must call Fixup later (if necessary)
    ASTAPI TypeFieldTypeDefinitionExt(TypeMemberProtection protection,
                                      Type *nestedType, char *name);
  internal:
    TypeFieldTypeDefinitionExt(): TypeFieldTypeDefinition() { } // Parsing only

    friend class TypeIO;
};

class TypeFieldMemberModification: public TypeField
{
  public:
    ASTAPI TypeFieldKind        GetFieldKind()     { return tfkMemberModification; }
    ASTAPI TypeStructClass *    GetBaseClass()     { return baseClassType; }
    ASTAPI TypeMemberProtection GetNewProtection() { return protection; }
    ASTAPI const char *         GetName()          { return name; }
  internal:
  private:
    TypeFieldMemberModification(): TypeField() { } // For type parsing only

    // Users of this constructor must call both Initialize and Fixup later
    ASTAPI TypeFieldMemberModification(TypeIndex baseClassIndex,
                                       TypeMemberProtection protection,
                                       char *name);
    // Users of this constructor must call Fixup later (if necessary)
    ASTAPI TypeFieldMemberModification(TypeStructClass *baseClassType,
                                       TypeMemberProtection protection,
                                       char *name);
    void Initialize(TypeManager *typeManager, SymbolTable *symbolTable, TypeIO *typeIO);

  private:
    union {
        TypeIndex baseClassIndex;
        TypeStructClass *baseClassType;
    };
    TypeMemberProtection protection : 8;
    char *name;

    friend class TypeIO;
};



class  TypeMap : public Object {
  public:
    //static TypeMap* Make(Allocator*);
    Type *Lookup(TypeIndex, Symbol*);  // returns NULL for no match
    void Set(TypeIndex, Symbol*, Type*);
  protected:
    TypeMap();
};

#endif INC_TYPE_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\SDK\test\include\version.h ===
// -*- Mode:C++ -*-
//
//      Copyright (c) 1997 Microsoft Corporation.  All rights reserved.
//
//    This work is a trade secret of Microsoft Corporation.
//    Unauthorized disclosure is unlawful.
//
// $Header: $
// $NoKeywords: $
//
//
// File:    lib/version.h
// Creator: 

// Facilities for version numbering

#ifndef INC_VERSION_H 
#define INC_VERSION_H

#include <time.h>

struct Version
{
    int major;                  // major version number
    int minor;                  // minor version number
    int build;                  // build number
    time_t timestamp;           // time of build
    char *kind;                 // what kind of build (e.g., Debug, Release)

    // print version-id string to OUTS
    ASTAPI void Print(OutputStream *outs);

    // compare version numbers, negative means "don't care"
    // Return true iff version numbers match
    ASTAPI bool FEqual(int omajor, int ominor = -1, int obuild = -1)
      {
          return major == omajor
              && (ominor < 0 || ominor == minor)
              && (obuild < 0 || obuild == build);
      }
    
    // compare version numbers, negative means "don't care"
    // Return true iff this represents a newer version
    // than (OMAJOR, OMINOR, OBUILD)
    ASTAPI bool FNewerThan(int omajor, int ominor = -1, int obuild = -1)
      {
          return (major > omajor 
                  || (major == omajor &&
                      (minor > ominor
                       || (minor == ominor && build > obuild))));
      }

    Version(int major, int minor, int build,
            time_t timestamp, 
            char *ignore,       // was .who
            char *kind
      ):
        major(major),
        minor(minor),
        build(build),
        timestamp(timestamp),
        kind(kind)
      { }
};

#endif // INC_VERSION_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\autoupd\patch\api\md5.h ===
/*
 ***********************************************************************
 ** md5.h -- Header file for implementation of MD5                    **
 ** RSA Data Security, Inc. MD5 Message-Digest Algorithm              **
 ** Created: 2/17/90 RLR                                              **
 ** Revised: 12/27/90 SRD,AJ,BSK,JT Reference C version               **
 ** Revised (for MD5): RLR 4/27/91                                    **
 **   -- G modified to have y&~z instead of y&z                       **
 **   -- FF, GG, HH modified to add in last register done             **
 **   -- Access pattern: round 2 works mod 5, round 3 works mod 3     **
 **   -- distinct additive constant for each step                     **
 **   -- round 4 added, working mod 7                                 **
 ***********************************************************************
 */

/*
 ***********************************************************************
 ** Copyright (C) 1990, RSA Data Security, Inc. All rights reserved.  **
 **                                                                   **
 ** License to copy and use this software is granted provided that    **
 ** it is identified as the "RSA Data Security, Inc. MD5 Message-     **
 ** Digest Algorithm" in all material mentioning or referencing this  **
 ** software or this function.                                        **
 **                                                                   **
 ** License is also granted to make and use derivative works          **
 ** provided that such works are identified as "derived from the RSA  **
 ** Data Security, Inc. MD5 Message-Digest Algorithm" in all          **
 ** material mentioning or referencing the derived work.              **
 **                                                                   **
 ** RSA Data Security, Inc. makes no representations concerning       **
 ** either the merchantability of this software or the suitability    **
 ** of this software for any particular purpose.  It is provided "as  **
 ** is" without express or implied warranty of any kind.              **
 **                                                                   **
 ** These notices must be retained in any copies of any part of this  **
 ** documentation and/or software.                                    **
 ***********************************************************************
 */

#ifndef _MD5_H_
#define _MD5_H_

/*                                                                         */
/* This copy of md5.h modified and adapted for my purposes, tommcg 6/28/96 */
/*                                                                         */

#pragma warning( disable: 4201 4204 )


#ifndef VOID
    typedef void VOID;
#endif
#ifndef UCHAR
    typedef unsigned char UCHAR;
#endif
#ifndef ULONG
    typedef unsigned long ULONG;
#endif
#ifndef ULONGLONG
    typedef unsigned __int64 ULONGLONG;
#endif
#ifndef PCVOID
    typedef const void * PCVOID;
#endif
#ifndef IN
    #define IN
#endif
#ifndef OUT
    #define OUT
#endif


typedef struct _MD5_HASH MD5_HASH, *PMD5_HASH;

struct _MD5_HASH {
    union {
        ULONG Word32[  4 ];
        UCHAR Byte  [ 16 ];
        };
    };

#define MD5_INITIAL_VALUE { 0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476 }

VOID
InitMD5(
    IN OUT PMD5_HASH HashValue
    );

VOID
UpdateMD5_64ByteChunk(
    IN OUT PMD5_HASH HashValue,         // existing hash value
    IN     PCVOID    DataChunk          // pointer to 64 bytes of data
    );

VOID
FinalizeMD5(
    IN OUT PMD5_HASH HashValue,         // existing hash value
    IN     PCVOID    RemainingData,     // remaining data to hash
    IN     ULONG     RemainingBytes,    // 0 <= RemainingBytes < 64
    IN     ULONGLONG TotalBytesHashed   // total bytes hashed
    );

VOID
ComputeCompleteMD5(                     // complete MD5 in one call
    IN  PCVOID    DataBuffer,           // buffer to compute MD5 over
    IN  ULONGLONG DataLength,           // bytes of data in buffer
    OUT PMD5_HASH HashValue             // return finalized MD5 value
    );


#endif // _MD5_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\autoupd\patch\api\md5.c ===
/*
 ***********************************************************************
 ** md5.c                                                             **
 ** RSA Data Security, Inc. MD5 Message-Digest Algorithm              **
 ** Created: 2/17/90 RLR                                              **
 ** Revised: 1/91 SRD,AJ,BSK,JT Reference C Version                   **
 ***********************************************************************
 */

/*
 ***********************************************************************
 ** Copyright (C) 1990, RSA Data Security, Inc. All rights reserved.  **
 **                                                                   **
 ** License to copy and use this software is granted provided that    **
 ** it is identified as the "RSA Data Security, Inc. MD5 Message-     **
 ** Digest Algorithm" in all material mentioning or referencing this  **
 ** software or this function.                                        **
 **                                                                   **
 ** License is also granted to make and use derivative works          **
 ** provided that such works are identified as "derived from the RSA  **
 ** Data Security, Inc. MD5 Message-Digest Algorithm" in all          **
 ** material mentioning or referencing the derived work.              **
 **                                                                   **
 ** RSA Data Security, Inc. makes no representations concerning       **
 ** either the merchantability of this software or the suitability    **
 ** of this software for any particular purpose.  It is provided "as  **
 ** is" without express or implied warranty of any kind.              **
 **                                                                   **
 ** These notices must be retained in any copies of any part of this  **
 ** documentation and/or software.                                    **
 ***********************************************************************
 */

//  Portions copyright (c) 1992 Microsoft Corp.
//  All rights reserved

//
//  This copy of md5.c modified and adapted for my purposes, tommcg 6/28/96
//  Copyright (C) 1996-1999, Microsoft Corporation.
//


#include "md5.h"

#ifndef PCUCHAR
    typedef const unsigned char * PCUCHAR;
#endif
#ifndef PCULONG
    typedef const unsigned long * PCULONG;
#endif

#include <stdlib.h>     /* _rotl */
#include <memory.h>     /* memcpy, memset */

#pragma intrinsic(memcpy, memset)

/* Constants for Transform routine. */
#define S11 7
#define S12 12
#define S13 17
#define S14 22
#define S21 5
#define S22 9
#define S23 14
#define S24 20
#define S31 4
#define S32 11
#define S33 16
#define S34 23
#define S41 6
#define S42 10
#define S43 15
#define S44 21


/* ROTATE_LEFT rotates x left n bits. */

#define ROTATE_LEFT(x, n) ((x << n) | (x >> (32 - n)))

//
//  Intel and PowerPC both have a hardware rotate instruction with intrinsic
//  (inline) function for them.  Rough measurements show a 25% speed increase
//  for Intel and 10% speed increase for PowerPC when using the instrinsic
//  rotate versus the above defined shift/shift/or implemenation.
//

#if defined(_M_IX86) || defined(_M_PPC)
    #undef  ROTATE_LEFT
    #define ROTATE_LEFT(x, n) _rotl(x, n)
    #pragma intrinsic(_rotl)
#endif


/* F, G and H are basic MD5 functions */
#define F(x, y, z) ((x & y) | (~x & z))
#define G(x, y, z) ((x & z) | (y & ~z))
#define H(x, y, z) (x ^ y ^ z)
#define I(x, y, z) (y ^ (x | ~z))


/* FF, GG, HH, and II transformations for rounds 1, 2, 3, and 4 */
/* Rotation is separate from addition to prevent recomputation */
#define FF(a, b, c, d, x, s, ac) \
   a += F(b, c, d) + x + ac; \
   a = ROTATE_LEFT(a, s); \
   a += b;

#define GG(a, b, c, d, x, s, ac) \
   a += G(b, c, d) + x + ac; \
   a = ROTATE_LEFT(a, s); \
   a += b;

#define HH(a, b, c, d, x, s, ac) \
   a += H(b, c, d) + x + ac; \
   a = ROTATE_LEFT(a, s); \
   a += b;

#define II(a, b, c, d, x, s, ac) \
   a += I(b, c, d) + x + ac; \
   a = ROTATE_LEFT(a, s); \
   a += b;


VOID
InitMD5(
    IN OUT PMD5_HASH HashValue
    )
    {
    HashValue->Word32[ 0 ] = 0x67452301;
    HashValue->Word32[ 1 ] = 0xefcdab89;
    HashValue->Word32[ 2 ] = 0x98badcfe;
    HashValue->Word32[ 3 ] = 0x10325476;
    }

VOID
UpdateMD5_64ByteChunk(
    IN OUT PMD5_HASH HashValue,         // existing hash value
    IN     PCVOID    DataChunk          // ULONG-aligned pointer to 64-byte message chunk
    )
    {
    PCULONG MessageWord32 = DataChunk;
    ULONG a = HashValue->Word32[ 0 ];
    ULONG b = HashValue->Word32[ 1 ];
    ULONG c = HashValue->Word32[ 2 ];
    ULONG d = HashValue->Word32[ 3 ];

    /* Round 1 */
    FF ( a, b, c, d, MessageWord32[  0 ], S11, 0xd76aa478 ) /* 1 */
    FF ( d, a, b, c, MessageWord32[  1 ], S12, 0xe8c7b756 ) /* 2 */
    FF ( c, d, a, b, MessageWord32[  2 ], S13, 0x242070db ) /* 3 */
    FF ( b, c, d, a, MessageWord32[  3 ], S14, 0xc1bdceee ) /* 4 */
    FF ( a, b, c, d, MessageWord32[  4 ], S11, 0xf57c0faf ) /* 5 */
    FF ( d, a, b, c, MessageWord32[  5 ], S12, 0x4787c62a ) /* 6 */
    FF ( c, d, a, b, MessageWord32[  6 ], S13, 0xa8304613 ) /* 7 */
    FF ( b, c, d, a, MessageWord32[  7 ], S14, 0xfd469501 ) /* 8 */
    FF ( a, b, c, d, MessageWord32[  8 ], S11, 0x698098d8 ) /* 9 */
    FF ( d, a, b, c, MessageWord32[  9 ], S12, 0x8b44f7af ) /* 10 */
    FF ( c, d, a, b, MessageWord32[ 10 ], S13, 0xffff5bb1 ) /* 11 */
    FF ( b, c, d, a, MessageWord32[ 11 ], S14, 0x895cd7be ) /* 12 */
    FF ( a, b, c, d, MessageWord32[ 12 ], S11, 0x6b901122 ) /* 13 */
    FF ( d, a, b, c, MessageWord32[ 13 ], S12, 0xfd987193 ) /* 14 */
    FF ( c, d, a, b, MessageWord32[ 14 ], S13, 0xa679438e ) /* 15 */
    FF ( b, c, d, a, MessageWord32[ 15 ], S14, 0x49b40821 ) /* 16 */

    /* Round 2 */
    GG ( a, b, c, d, MessageWord32[  1 ], S21, 0xf61e2562 ) /* 17 */
    GG ( d, a, b, c, MessageWord32[  6 ], S22, 0xc040b340 ) /* 18 */
    GG ( c, d, a, b, MessageWord32[ 11 ], S23, 0x265e5a51 ) /* 19 */
    GG ( b, c, d, a, MessageWord32[  0 ], S24, 0xe9b6c7aa ) /* 20 */
    GG ( a, b, c, d, MessageWord32[  5 ], S21, 0xd62f105d ) /* 21 */
    GG ( d, a, b, c, MessageWord32[ 10 ], S22, 0x02441453 ) /* 22 */
    GG ( c, d, a, b, MessageWord32[ 15 ], S23, 0xd8a1e681 ) /* 23 */
    GG ( b, c, d, a, MessageWord32[  4 ], S24, 0xe7d3fbc8 ) /* 24 */
    GG ( a, b, c, d, MessageWord32[  9 ], S21, 0x21e1cde6 ) /* 25 */
    GG ( d, a, b, c, MessageWord32[ 14 ], S22, 0xc33707d6 ) /* 26 */
    GG ( c, d, a, b, MessageWord32[  3 ], S23, 0xf4d50d87 ) /* 27 */
    GG ( b, c, d, a, MessageWord32[  8 ], S24, 0x455a14ed ) /* 28 */
    GG ( a, b, c, d, MessageWord32[ 13 ], S21, 0xa9e3e905 ) /* 29 */
    GG ( d, a, b, c, MessageWord32[  2 ], S22, 0xfcefa3f8 ) /* 30 */
    GG ( c, d, a, b, MessageWord32[  7 ], S23, 0x676f02d9 ) /* 31 */
    GG ( b, c, d, a, MessageWord32[ 12 ], S24, 0x8d2a4c8a ) /* 32 */

    /* Round 3 */
    HH ( a, b, c, d, MessageWord32[  5 ], S31, 0xfffa3942 ) /* 33 */
    HH ( d, a, b, c, MessageWord32[  8 ], S32, 0x8771f681 ) /* 34 */
    HH ( c, d, a, b, MessageWord32[ 11 ], S33, 0x6d9d6122 ) /* 35 */
    HH ( b, c, d, a, MessageWord32[ 14 ], S34, 0xfde5380c ) /* 36 */
    HH ( a, b, c, d, MessageWord32[  1 ], S31, 0xa4beea44 ) /* 37 */
    HH ( d, a, b, c, MessageWord32[  4 ], S32, 0x4bdecfa9 ) /* 38 */
    HH ( c, d, a, b, MessageWord32[  7 ], S33, 0xf6bb4b60 ) /* 39 */
    HH ( b, c, d, a, MessageWord32[ 10 ], S34, 0xbebfbc70 ) /* 40 */
    HH ( a, b, c, d, MessageWord32[ 13 ], S31, 0x289b7ec6 ) /* 41 */
    HH ( d, a, b, c, MessageWord32[  0 ], S32, 0xeaa127fa ) /* 42 */
    HH ( c, d, a, b, MessageWord32[  3 ], S33, 0xd4ef3085 ) /* 43 */
    HH ( b, c, d, a, MessageWord32[  6 ], S34, 0x04881d05 ) /* 44 */
    HH ( a, b, c, d, MessageWord32[  9 ], S31, 0xd9d4d039 ) /* 45 */
    HH ( d, a, b, c, MessageWord32[ 12 ], S32, 0xe6db99e5 ) /* 46 */
    HH ( c, d, a, b, MessageWord32[ 15 ], S33, 0x1fa27cf8 ) /* 47 */
    HH ( b, c, d, a, MessageWord32[  2 ], S34, 0xc4ac5665 ) /* 48 */

    /* Round 4 */
    II ( a, b, c, d, MessageWord32[  0 ], S41, 0xf4292244 ) /* 49 */
    II ( d, a, b, c, MessageWord32[  7 ], S42, 0x432aff97 ) /* 50 */
    II ( c, d, a, b, MessageWord32[ 14 ], S43, 0xab9423a7 ) /* 51 */
    II ( b, c, d, a, MessageWord32[  5 ], S44, 0xfc93a039 ) /* 52 */
    II ( a, b, c, d, MessageWord32[ 12 ], S41, 0x655b59c3 ) /* 53 */
    II ( d, a, b, c, MessageWord32[  3 ], S42, 0x8f0ccc92 ) /* 54 */
    II ( c, d, a, b, MessageWord32[ 10 ], S43, 0xffeff47d ) /* 55 */
    II ( b, c, d, a, MessageWord32[  1 ], S44, 0x85845dd1 ) /* 56 */
    II ( a, b, c, d, MessageWord32[  8 ], S41, 0x6fa87e4f ) /* 57 */
    II ( d, a, b, c, MessageWord32[ 15 ], S42, 0xfe2ce6e0 ) /* 58 */
    II ( c, d, a, b, MessageWord32[  6 ], S43, 0xa3014314 ) /* 59 */
    II ( b, c, d, a, MessageWord32[ 13 ], S44, 0x4e0811a1 ) /* 60 */
    II ( a, b, c, d, MessageWord32[  4 ], S41, 0xf7537e82 ) /* 61 */
    II ( d, a, b, c, MessageWord32[ 11 ], S42, 0xbd3af235 ) /* 62 */
    II ( c, d, a, b, MessageWord32[  2 ], S43, 0x2ad7d2bb ) /* 63 */
    II ( b, c, d, a, MessageWord32[  9 ], S44, 0xeb86d391 ) /* 64 */

    HashValue->Word32[ 0 ] += a;
    HashValue->Word32[ 1 ] += b;
    HashValue->Word32[ 2 ] += c;
    HashValue->Word32[ 3 ] += d;
    }


VOID
FinalizeMD5(
    IN OUT PMD5_HASH HashValue,
    IN     PCVOID    RemainingData,     // remaining data to hash
    IN     ULONG     RemainingBytes,    // 0 <= RemainingBytes < 64
    IN     ULONGLONG TotalBytesHashed   // total bytes hashed
    )
    {
    union {
        ULONGLONG Qword[  8 ];
        UCHAR     Byte [ 64 ];
        } LocalBuffer;

    //
    //  Always append a pad byte of 0x80 to the message.
    //
    //  If RemainingBytes is less than (but not equal to) 56 bytes, then
    //  the final bits hashed count will be stored in the last 8 bytes of
    //  this 64 byte hash chunk.
    //
    //  If RemainingBytes is exactly 56 bytes, the appended 0x80 pad byte
    //  will force an extra chunk.
    //
    //  If RemainingBytes is greater than or equal to 56 bytes, then the
    //  final bits hashed count will be stored in the last 8 bytes of the
    //  NEXT 64 byte chunk that is otherwise zeroed, so THIS chunk needs to
    //  be zero-padded beyond the first pad byte and then hashed, then zero
    //  the first 56 bytes of the LocalBuffer for the NEXT chunk hash.
    //

    RemainingBytes &= 63;           // only care about partial frames

    //
    //  Zero init local buffer.
    //

    memset( &LocalBuffer, 0, 64 );

    //
    //  Append 0x80 pad byte to message.
    //

    LocalBuffer.Byte[ RemainingBytes ] = 0x80;

    if ( RemainingBytes > 0 ) {

        //
        //  Copy remaining data bytes (0 < RemainingBytes < 64) to LocalBuffer
        //  (remainder of LocalBuffer already zeroed except for pad byte).
        //

        memcpy( &LocalBuffer, RemainingData, RemainingBytes );

        if ( RemainingBytes >= 56 ) {

            UpdateMD5_64ByteChunk( HashValue, &LocalBuffer );

            memset( &LocalBuffer, 0, 56 );

            }
        }

    //
    //  Number of BITS hashed goes into last 8 bytes of last chunk.  This
    //  is a 64-bit value.  Note that if the number of BITS exceeds 2^64
    //  then this number is the low order 64 bits of the result.
    ///

    LocalBuffer.Qword[ 7 ] = ( TotalBytesHashed * 8 );      // number of BITS

    UpdateMD5_64ByteChunk( HashValue, &LocalBuffer );

    }


VOID
ComputeCompleteMD5(
    IN  PCVOID    DataBuffer,
    IN  ULONGLONG DataLength,
    OUT PMD5_HASH HashValue
    )
    {
    PCUCHAR   DataPointer = DataBuffer;
    ULONGLONG ChunkCount  = DataLength / 64;
    ULONG     OddBytes    = (ULONG)DataLength & 63;

    InitMD5( HashValue );

    while ( ChunkCount-- ) {
        UpdateMD5_64ByteChunk( HashValue, DataPointer );
        DataPointer += 64;
        }

    FinalizeMD5( HashValue, DataPointer, OddBytes, DataLength );
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\autoupd\patch\api\misc.h ===
//
//  misc.h
//
//  Author: Tom McGuire (tommcg) 2/97 - 9/97
//
//  Copyright (C) Microsoft, 1997-2001.
//
//  MICROSOFT CONFIDENTIAL
//

#ifndef _PATCH_MISC_H_
#define _PATCH_MISC_H_

#ifdef __cplusplus
extern "C" {
#endif

#pragma intrinsic( memcpy, memset, memcmp, strcpy, strcmp, strlen, strcat, abs, _rotl )

#ifndef ROUNDUP2
#define ROUNDUP2( x, n ) ((((ULONG)(x)) + (((ULONG)(n)) - 1 )) & ~(((ULONG)(n)) - 1 ))
#endif

#ifndef MIN
#define MIN( a, b ) (((a)<(b))?(a):(b))
#endif

#ifndef offsetof
#define offsetof(s,m)   (size_t)&(((s *)0)->m)
#endif

#ifndef __cplusplus
typedef int bool;
#endif

#ifndef byte
typedef unsigned char byte;
#endif

#define SUBALLOCATOR_ALIGNMENT 8

#define MINIMUM_VM_ALLOCATION 0x10000


#if defined( DEBUG ) || defined( DBG ) || defined( TESTCODE )

#include <stdlib.h>
#include <stdio.h>

#endif


#ifndef ASSERT

BOOL
Assert(
    LPCSTR szText,
    LPCSTR szFile,
    DWORD  dwLine
    );

#if defined( DEBUG ) || defined( DBG ) || defined( TESTCODE )
#define ASSERT( a ) (( a ) ? 1 : Assert( #a, __FILE__, __LINE__ ))
#define DEBUGCODE( a ) a
#else
#define ASSERT( a )
#define DEBUGCODE( a )
#endif
#endif // ASSERT


VOID
InitializeCrc32Table(
    VOID
    );

ULONG
Crc32(
    IN ULONG InitialCrc,
    IN PVOID Buffer,
    IN ULONG ByteCount
    );

BOOL
SafeCompleteCrc32(
    IN  PVOID  Buffer,
    IN  ULONG  ByteCount,
    OUT PULONG CrcValue
    );

BOOL
SafeCompleteMD5(
    IN  PVOID     Buffer,
    IN  ULONG     ByteCount,
    OUT PMD5_HASH MD5Value
    );

BOOL
MyMapViewOfFileByHandle(
    IN  HANDLE  FileHandle,
    OUT ULONG  *FileSize,
    OUT PVOID  *MapBase
    );

BOOL
MyMapViewOfFileA(
    IN  LPCSTR  FileName,
    OUT ULONG  *FileSize,
    OUT HANDLE *FileHandle,
    OUT PVOID  *MapBase
    );

BOOL
MyCreateMappedFileA(
    IN  LPCSTR  FileName,
    IN  ULONG   InitialSize,
    OUT HANDLE *FileHandle,
    OUT PVOID  *MapBase
    );

BOOL
MyCreateMappedFileByHandle(
    IN  HANDLE FileHandle,
    IN  ULONG  InitialSize,
    OUT PVOID *MapBase
    );

VOID
MyUnmapCreatedMappedFile(
    IN HANDLE    FileHandle,
    IN PVOID     MapBase,
    IN ULONG     FileSize,
    IN PFILETIME FileTime OPTIONAL
    );

PVOID
__fastcall
MyVirtualAlloc(
    ULONG Size
    );

VOID
__fastcall
MyVirtualFree(
    PVOID Allocation
    );

HANDLE
CreateSubAllocator(
    IN ULONG InitialCommitSize,
    IN ULONG GrowthCommitSize
    );

PVOID
__fastcall
SubAllocate(
    IN HANDLE hAllocator,
    IN ULONG  Size
    );

VOID
DestroySubAllocator(
    IN HANDLE hAllocator
    );

LPSTR
__fastcall
MySubAllocStrDup(
    IN HANDLE SubAllocator,
    IN LPCSTR String
    );

LPSTR
MySubAllocStrDupAndCat(
    IN HANDLE SubAllocator,
    IN LPCSTR String1,
    IN LPCSTR String2,
    IN CHAR   Separator
    );

PVOID
MyHeapAllocZero(
    IN ULONG Size
    );

VOID
MyHeapFree(
    IN PVOID Allocation
    );

ULONG
HashName(
    IN LPCSTR Name
    );

ULONG
HashNameCaseInsensitive(
    IN LPCSTR Name
    );

VOID
MyLowercase(
    IN OUT LPSTR String
    );

VOID
DwordToHexString(
    IN  DWORD Value,
    OUT LPSTR Buffer    // writes exactly 9 bytes including terminator
    );

BOOL
HashToHexString(
    IN  PMD5_HASH HashValue,
    OUT LPSTR     Buffer        // must be at least 33 bytes
    );

//
//  FILETIME units are 100ns intervals from 01/01/1601.
//
//  ULONG units are seconds from 01/01/1970.
//
//  There are 10,000,000 FILETIME units in one second.
//
//  There are 11,644,473,600 seconds from 01/01/1601 to 01/01/1970.
//

#define FILETIME_UNITS_PER_SECOND      10000000
#define FILETIME_TO_ULONG_OFFSET    11644473600

VOID
__inline
UlongTimeToFileTime(
    IN  ULONG     UlongTime,
    OUT PFILETIME FileTime
    )
    {
    *(UNALIGNED DWORDLONG *)FileTime = ( UlongTime + FILETIME_TO_ULONG_OFFSET ) * FILETIME_UNITS_PER_SECOND;
    }

ULONG
__inline
FileTimeToUlongTime(
    IN PFILETIME FileTime
    )
    {
    return (ULONG)(( *(UNALIGNED DWORDLONG *)FileTime / FILETIME_UNITS_PER_SECOND ) - FILETIME_TO_ULONG_OFFSET );
    }


#ifdef __cplusplus
}
#endif

#endif // _PATCH_MISC_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\autoupd\patch\api\patchlzx.c ===
#include <precomp.h>

//
//  patchlzx.c
//
//  Author: Tom McGuire (tommcg) 2/97 - 9/97
//
//  Copyright (C) Microsoft, 1997-2001.
//
//  MICROSOFT CONFIDENTIAL
//



typedef struct _LZX_OUTPUT_CONTEXT {
    PUCHAR                   PatchBufferPointer;
    ULONG                    PatchBufferSize;
    ULONG                    PatchSize;
    BOOL                     DiscardOutput;
    } LZX_OUTPUT_CONTEXT, *PLZX_OUTPUT_CONTEXT;


ULONG
__fastcall
LzxWindowSize(
    IN ULONG OldDataSize,
    IN ULONG NewDataSize,
    IN DWORD OptionFlags,
    IN ULONG AbsoluteMax
    )
    {
    ULONG WindowSize;
    ULONG DataSize;

    DataSize = ROUNDUP2( OldDataSize, LZX_BLOCKSIZE ) + NewDataSize;

    if ( DataSize <= LZX_MINWINDOW )
    {
        return LZX_MINWINDOW;
    }

    WindowSize = LzxMaxWindowSize( OptionFlags, AbsoluteMax );

    while (( WindowSize >> 1 ) >= DataSize )
    {
        WindowSize = WindowSize >> 1;
    }

    return WindowSize;
    }


ULONG
__fastcall
LzxMaxWindowSize(
    IN ULONG OptionFlags,
    IN ULONG AbsoluteMax
    )
{
    ULONG WindowSize = ( OptionFlags & PATCH_OPTION_USE_LZX_LARGE ) ?
                            LZX_MAXWINDOW_32 :
                            LZX_MAXWINDOW_8;

    if ( AbsoluteMax )
    {
        if ( AbsoluteMax < LZX_MINWINDOW )
        {
             AbsoluteMax = LZX_MINWINDOW;
        }

        while ( WindowSize > AbsoluteMax )
        {
            WindowSize >>= 1;
        }
    }

    return WindowSize;
}


ULONG
__fastcall
LzxOldFileInsertSize(
    IN ULONG OldDataSize,
    IN DWORD OptionFlags,
    IN ULONG AbsoluteMaxLzxWindow,
    IN PPATCH_INTERLEAVE_MAP InterleaveMap
    )
{
    ULONG OldInsertSize = 0;

    if (( OptionFlags & PATCH_OPTION_INTERLEAVE_FILES ) &&
        ( InterleaveMap != NULL ) &&
        ( InterleaveMap->CountRanges > 0 ))
    {
        ULONG i;

        for ( i = 0; i < InterleaveMap->CountRanges; i++ )
        {
            OldInsertSize += InterleaveMap->Range[ i ].OldLength;
        }
    }
    else
    {
        ULONG MaxWindowSize = LzxMaxWindowSize( OptionFlags, AbsoluteMaxLzxWindow );

        OldInsertSize = MIN( OldDataSize, MaxWindowSize );
    }

    return OldInsertSize;
}


//
//  Following group of functions and exported apis are exclusively for
//  creating patches.  If we're only compiling the apply code, ignore
//  this group of functions.
//

#ifndef PATCH_APPLY_CODE_ONLY


PPATCH_INTERLEAVE_MAP
CreateDefaultInterleaveMap(
    IN HANDLE SubAllocator,
    IN ULONG  OldFileSize,
    IN ULONG  NewFileSize,
    IN ULONG  OptionFlags,
    IN ULONG  MaxWindow
    )
{
    ULONG LzxWindow = LzxMaxWindowSize( OptionFlags, MaxWindow );
    PPATCH_INTERLEAVE_MAP Imap = NULL;

    if (( ! ( OptionFlags & PATCH_OPTION_INTERLEAVE_FILES )) ||
        ( OldFileSize == 0 ) ||
        ( NewFileSize == 0 ))
    {
    return NULL;
    }

    if (( ROUNDUP2( OldFileSize, LZX_BLOCKSIZE ) + NewFileSize ) > LzxWindow )
    {
        ULONG NewChunkSize = ROUNDUP2(( LzxWindow / 4 ), LZX_BLOCKSIZE );
        ULONG OldChunkSize = NewChunkSize * 3;
        ULONG RangeCount   = ( NewFileSize / NewChunkSize ) + 1;
        ULONG AllocSize    = sizeof( *Imap ) + ( RangeCount * sizeof( Imap->Range[ 0 ] ));
        ULONG RangeIndex   = 0;

        Imap = SubAllocate( SubAllocator, AllocSize );

        if ( Imap != NULL )
        {
            ULONG NewRemain = NewFileSize;
            ULONG NewLength = MIN( NewChunkSize, NewFileSize );
            ULONG OldLength = MIN( OldChunkSize, OldFileSize );
            ULONG NewOffset = 0;
            ULONG OldOffset = 0;

            while ( NewRemain > 0 ) {

                ULONG NewMidPoint = NewOffset + ( NewChunkSize / 2 );
                ULONG OldMidPoint = (ULONG)(((UINT64) OldFileSize * NewMidPoint ) / NewFileSize );

                if ( OldMidPoint > ( OldChunkSize / 2 ))
                {
                    OldOffset = OldMidPoint - ( OldChunkSize / 2 );
                }

                if (( OldOffset + OldLength ) > OldFileSize )
                {
                    if ( OldFileSize > OldChunkSize )
                    {
                        OldOffset = OldFileSize - OldChunkSize;
                        OldLength = OldChunkSize;
                    }
                    else
                    {
                        OldOffset = 0;
                        OldLength = OldFileSize;
                    }
                }

                ASSERT( RangeIndex < RangeCount );

                Imap->Range[ RangeIndex ].OldOffset = OldOffset;
                Imap->Range[ RangeIndex ].OldLength = OldLength;
                Imap->Range[ RangeIndex ].NewLength = NewLength;

                NewOffset += NewLength;
                NewRemain -= NewLength;

                if ( NewRemain < NewChunkSize )
                {
                     NewLength = NewRemain;
                }

                RangeIndex++;
            }

            Imap->CountRanges = RangeIndex;

#ifdef TESTCODE

            {
                ULONG TotalNew = 0;
                ULONG i;

                printf( "\n" );

                for ( i = 0; i < Imap->CountRanges; i++ )
                {
                    printf(
                        "Preload  Old: 0x%08X (%u) from offset 0x%08X\n"
                        "Compress New: 0x%08X (%u) from offset 0x%08X\n",
                        Imap->Range[ i ].OldLength,
                        Imap->Range[ i ].OldLength,
                        Imap->Range[ i ].OldOffset,
                        Imap->Range[ i ].NewLength,
                        Imap->Range[ i ].NewLength,
                        TotalNew
                        );

                    TotalNew += Imap->Range[ i ].NewLength;
                }

                printf( "\n" );

                ASSERT( TotalNew == NewFileSize );
            }

#endif /* TESTCODE */

        }
    }
    else
    {
        Imap = SubAllocate( SubAllocator, sizeof( PATCH_INTERLEAVE_MAP ));

        if ( Imap != NULL )
        {
            Imap->CountRanges = 1;
            Imap->Range[ 0 ].OldOffset = 0;
            Imap->Range[ 0 ].OldLength = MIN( OldFileSize, LzxWindow );
            Imap->Range[ 0 ].NewLength = NewFileSize;
        }
    }

    return Imap;
}


ULONG
WINAPI
EstimateLzxCompressionMemoryRequirement(
    IN ULONG OldDataSize,
    IN ULONG NewDataSize,
    IN ULONG OptionFlags,
    IN ULONG AbsoluteMaxLzxWindow
    )
    {
    //
    //  Currently the LZX engine requires 9 times the size of the window
    //  plus a fixed overhead of just under 0x1A0000 bytes (1.7MB).
    //

    ULONG WindowSize = LzxWindowSize(
                           OldDataSize,
                           NewDataSize,
                           OptionFlags,
                           AbsoluteMaxLzxWindow
                           );

    return (( WindowSize * 9 ) + 0x1A0000 );
    }


int
__stdcall
MyLzxOutputCallback(
    PVOID  CallerContext,
    PUCHAR CompressedData,
    LONG   CompressedSize,
    LONG   UncompressedSize
    )
    {
    PLZX_OUTPUT_CONTEXT OutputContext = CallerContext;

    UNREFERENCED_PARAMETER( UncompressedSize );

    OutputContext->PatchSize += CompressedSize + sizeof( USHORT );

    if ( ! OutputContext->DiscardOutput ) {
        if ( OutputContext->PatchSize <= OutputContext->PatchBufferSize ) {
            *(UNALIGNED USHORT *)( OutputContext->PatchBufferPointer ) = (USHORT) CompressedSize;
            memcpy( OutputContext->PatchBufferPointer + sizeof( USHORT ), CompressedData, CompressedSize );
            OutputContext->PatchBufferPointer += CompressedSize + sizeof( USHORT );
            }
        }

    return TRUE;
    }


ULONG
WINAPI
CreateRawLzxPatchDataFromBuffers(
    IN  PVOID    OldDataBuffer,
    IN  ULONG    OldDataSize,
    IN  PVOID    NewDataBuffer,
    IN  ULONG    NewDataSize,
    IN  ULONG    PatchBufferSize,
    OUT PVOID    PatchBuffer,
    OUT ULONG   *PatchSize,
    IN  ULONG    OptionFlags,
    IN  ULONG    AbsoluteMaxWindowSize,
    IN  PPATCH_INTERLEAVE_MAP InterleaveMap,
    IN  PFNALLOC pfnAlloc,
    IN  HANDLE   AllocHandle,
    IN  PPATCH_PROGRESS_CALLBACK ProgressCallback,
    IN  PVOID    CallbackContext,
    IN  ULONG    ProgressInitialValue,
    IN  ULONG    ProgressMaximumValue
    )
    {
    LZX_OUTPUT_CONTEXT OutputContext;
    PATCH_INTERLEAVE_MAP SingleMap;
    PIMAGE_NT_HEADERS NtHeader;
    PVOID  LzxContext;
    ULONG  LzxWindow;
    ULONG  LzxOptE8;
    LONG   LzxStatus;
    PUCHAR PadBuffer;
    PUCHAR OldBlockPointer;
    PUCHAR NewBlockPointer;
    ULONG  NewBlockLength;
    ULONG  NewBytesRemaining;
    ULONG  OddBytes;
    ULONG  OldOffset;
    ULONG  OldLength;
    ULONG  NewLength;
    ULONG  ProgressPosition;
    LONG   Estimate;
    BOOL   Success;
    ULONG  ImapCount;
    ULONG  ImapIndex;

    if ( ! ( OptionFlags & ( PATCH_OPTION_USE_LZX_A | PATCH_OPTION_USE_LZX_B ))) {
        return ERROR_INVALID_PARAMETER;
        }

    LzxWindow = LzxWindowSize( OldDataSize, NewDataSize, OptionFlags, AbsoluteMaxWindowSize );

    if (( InterleaveMap == NULL ) ||
        ( InterleaveMap->CountRanges == 0 )) {

        InterleaveMap = &SingleMap;

        SingleMap.CountRanges = 1;
        SingleMap.Range[ 0 ].OldOffset = 0;
        SingleMap.Range[ 0 ].OldLength = MIN( OldDataSize, LzxWindow );
        SingleMap.Range[ 0 ].NewLength = NewDataSize;
        }

    else {

        //
        //  Verify specified interleave map is valid for LZX:
        //
        //    Each OldLength value non-zero and multiple of LZX_BLOCKSIZE.
        //    Each NewLength value non-zero and multiple of LZX_BLOCKSIZE,
        //      except for last NewLength which is ignored.
        //    Each OldOffset/OldLength pair does not exceed OldDataSize.
        //    Sum of Count-1 NewLength values does not exceed NewDataSize.
        //
        //

        ULONG TotalNew = 0;

        ImapCount = InterleaveMap->CountRanges;

        for ( ImapIndex = 0; ImapIndex < ImapCount; ImapIndex++ ) {

            OldOffset = InterleaveMap->Range[ ImapIndex ].OldOffset;
            OldLength = InterleaveMap->Range[ ImapIndex ].OldLength;
            NewLength = InterleaveMap->Range[ ImapIndex ].NewLength;

            if ( ImapIndex == ( ImapCount - 1 )) {
                NewLength = NewDataSize - TotalNew;
                }

            TotalNew += NewLength;

            if ((( TotalNew > NewDataSize ))               ||
                (( OldOffset + OldLength ) > OldDataSize ) ||
                (( OldLength == 0 ))                       ||
                (( NewLength == 0 ))                       ||
                (( NewLength % LZX_BLOCKSIZE ) &&
                 ( TotalNew != NewDataSize ))) {

                return ERROR_INVALID_PARAMETER;
                }
            }
        }

    //
    //  If OptionFlags requests LZX E8 transformation, and
    //     If file has MZ signature AND it's NOT a PE image,
    //     OR it's a PE image AND it's an x86 image,
    //       turn on x86-specific E8 call translation optimization.
    //

    NtHeader = GetNtHeader( NewDataBuffer, NewDataSize );

    if (( OptionFlags & PATCH_OPTION_USE_LZX_B ) &&
        ((( NtHeader ) && ( NtHeader->FileHeader.Machine == IMAGE_FILE_MACHINE_I386 )) ||
         (( ! NtHeader ) && ( *(UNALIGNED USHORT *)NewDataBuffer == 0x5A4D )))) {

        LzxOptE8 = NewDataSize;
        }
    else {
        LzxOptE8 = 0;
        }

    OutputContext.DiscardOutput      = TRUE;
    OutputContext.PatchBufferSize    = PatchBufferSize;
    OutputContext.PatchBufferPointer = PatchBuffer;
    OutputContext.PatchSize          = 0;

    Success = LZX_EncodeInit(
                  &LzxContext,
                  LzxWindow,
                  LZX_BLOCKSIZE,
                  pfnAlloc,
                  AllocHandle,
                  MyLzxOutputCallback,
                  &OutputContext
                  );

    PadBuffer = pfnAlloc( AllocHandle, LZX_BLOCKSIZE );

    if (( ! Success ) || ( PadBuffer == NULL )) {
        return ERROR_OUTOFMEMORY;
        }

    ProgressPosition = ProgressInitialValue;

    NewBlockPointer   = NewDataBuffer;
    NewBytesRemaining = NewDataSize;

    ImapCount = InterleaveMap->CountRanges;

    for ( ImapIndex = 0; ImapIndex < ImapCount; ImapIndex++ ) {

        OldOffset = InterleaveMap->Range[ ImapIndex ].OldOffset;
        OldLength = InterleaveMap->Range[ ImapIndex ].OldLength;
        NewLength = InterleaveMap->Range[ ImapIndex ].NewLength;

        if ( ImapIndex == ( ImapCount - 1 )) {
            NewLength = NewBytesRemaining;      // ignore final Imap NewLength
            }

        ASSERT( NewLength <= NewBytesRemaining );

        ASSERT(( OldOffset + OldLength ) <= OldDataSize );

#ifdef TESTCODE

        if ( ImapCount > 1 ) {

            printf(
                "\nLZX inserting   0x%08X bytes from old file at offset 0x%08X\n",
                OldLength,
                OldOffset
                );
            }
#endif

        OutputContext.DiscardOutput = TRUE;

        if ( ImapIndex > 0 ) {
            LZX_EncodeNewGroup( LzxContext );
            }

        OldBlockPointer = (PUCHAR)OldDataBuffer + OldOffset;

        OddBytes = OldLength % LZX_BLOCKSIZE;

#ifdef TRACING
        EncTracingDefineOffsets(
            LzxWindow,
            OddBytes ? (LZX_BLOCKSIZE - OddBytes) : 0,
            OddBytes ? (OldBytesRemaining + LZX_BLOCKSIZE - OddBytes) : OldLength
            );
#endif

        if ( OddBytes ) {

            //
            //  We must insert a multiple of LZX_BLOCKSIZE (32K) of old
            //  data.  If we have OddBytes, we pre-fill a 32K buffer with
            //  zeros and copy the first OddBytes to the tail of the 32K
            //  buffer.  By dealing with the odd bytes in the first 32K
            //  of inserted data, the last block of inserted data will come
            //  out exactly a 32K boundary (adjacent to following new data).
            //

            ZeroMemory( PadBuffer, LZX_BLOCKSIZE - OddBytes );

            memcpy(
                PadBuffer + ( LZX_BLOCKSIZE - OddBytes ),
                OldBlockPointer,
                OddBytes
                );

            Success = LZX_EncodeInsertDictionary(
                          LzxContext,
                          PadBuffer,
                          LZX_BLOCKSIZE
                          );

            if ( ! Success ) {
                return ERROR_INVALID_DATA;  // don't know how could fail
                }

            OldLength        -= OddBytes;
            OldBlockPointer  += OddBytes;
            ProgressPosition += OddBytes;

            Success = ProgressCallbackWrapper(
                          ProgressCallback,
                          CallbackContext,
                          ProgressPosition,
                          ProgressMaximumValue
                          );

            if ( ! Success ) {
                return GetLastError();      // guaranteed non-zero by wrapper
                }
            }

        //
        //  Now insert remaining 32K packets of old data.
        //

        ASSERT(( OldLength % LZX_BLOCKSIZE ) == 0 );

        while ( OldLength > 0 ) {

            Success = LZX_EncodeInsertDictionary(
                          LzxContext,
                          OldBlockPointer,
                          LZX_BLOCKSIZE
                          );

            if ( ! Success ) {
                return ERROR_INVALID_DATA;  // don't know how could fail
                }

            OldLength        -= LZX_BLOCKSIZE;
            OldBlockPointer  += LZX_BLOCKSIZE;
            ProgressPosition += LZX_BLOCKSIZE;

            Success = ProgressCallbackWrapper(
                          ProgressCallback,
                          CallbackContext,
                          ProgressPosition,
                          ProgressMaximumValue
                          );

            if ( ! Success ) {
                return GetLastError();      // guaranteed non-zero by wrapper
                }
            }

        LZX_EncodeResetState( LzxContext );

        OutputContext.DiscardOutput = FALSE;

#ifdef TESTCODE

        if ( ImapCount > 1 ) {

            printf(
                "\nLZX compressing 0x%08X bytes from new file at offset 0x%08X\n",
                NewLength,
                NewBlockPointer - (PUCHAR) NewDataBuffer
                );
            }
#endif

        while ( NewLength > 0 ) {

            NewBlockLength = MIN( NewLength, LZX_BLOCKSIZE );

            LzxStatus = LZX_Encode(
                            LzxContext,
                            NewBlockPointer,
                            NewBlockLength,
                            &Estimate,
                            LzxOptE8
                            );

            if ( LzxStatus != ENCODER_SUCCESS ) {
                return ERROR_INVALID_DATA;      // don't know how could fail
                }

            NewBytesRemaining -= NewBlockLength;
            NewLength         -= NewBlockLength;
            NewBlockPointer   += NewBlockLength;
            ProgressPosition  += NewBlockLength;

            Success = ProgressCallbackWrapper(
                          ProgressCallback,
                          CallbackContext,
                          ProgressPosition,
                          ProgressMaximumValue
                          );

            if ( ! Success ) {
                return GetLastError();      // guaranteed non-zero by wrapper
                }
            }

        Success = LZX_EncodeFlush( LzxContext );

        if ( ! Success ) {
            return ERROR_INVALID_DATA;      // don't know how could fail
            }
        }

    *PatchSize = OutputContext.PatchSize;

    if ( OutputContext.PatchSize > OutputContext.PatchBufferSize ) {
        return ERROR_INSUFFICIENT_BUFFER;
        }

    return NO_ERROR;
    }



ULONG
WINAPI
RawLzxCompressBuffer(
    IN  PVOID    InDataBuffer,
    IN  ULONG    InDataSize,
    IN  ULONG    OutDataBufferSize,
    OUT PVOID    OutDataBuffer OPTIONAL,
    OUT PULONG   OutDataSize,
    IN  ULONG    MaxWindowSize OPTIONAL,
    IN  PFNALLOC pfnAlloc,
    IN  HANDLE   AllocHandle,
    IN  PPATCH_PROGRESS_CALLBACK ProgressCallback,
    IN  PVOID    CallbackContext,
    IN  ULONG    ProgressInitialValue,
    IN  ULONG    ProgressMaximumValue
    )
    {
    LZX_OUTPUT_CONTEXT OutputContext;
    PIMAGE_NT_HEADERS NtHeader;
    ULONG  ProgressPosition;
    PVOID  LzxContext;
    ULONG  LzxWindow;
    ULONG  LzxOptE8;
    LONG   LzxStatus;
    PUCHAR BlockPointer;
    ULONG  BytesRemaining;
    LONG   Estimate;
    BOOL   Success;
    ULONG  ErrorCode;

    if ( OutDataBufferSize == 0 ) {
         OutDataBuffer = NULL;
         }
    else if ( OutDataBuffer == NULL ) {
         OutDataBufferSize = 0;
         }

    ErrorCode = ERROR_OUTOFMEMORY;

    OutputContext.DiscardOutput      = OutDataBuffer ? FALSE : TRUE;
    OutputContext.PatchBufferSize    = OutDataBufferSize;
    OutputContext.PatchBufferPointer = OutDataBuffer;
    OutputContext.PatchSize          = 0;

    LzxWindow = LzxWindowSize( 0, InDataSize, LZX_MAXWINDOW_32, MaxWindowSize );

    Success = LZX_EncodeInit(
                  &LzxContext,
                  LzxWindow,
                  LZX_BLOCKSIZE,
                  pfnAlloc,
                  AllocHandle,
                  MyLzxOutputCallback,
                  &OutputContext
                  );

    if ( Success ) {

        LzxOptE8 = 0;
        NtHeader = GetNtHeader( InDataBuffer, InDataSize );

        //
        //  If file has MZ signature AND it's NOT a PE image,
        //  OR it's a PE image AND it's an i386 image, turn on
        //  the i386-specific E8 call translation optimization.
        //

        if ((( NtHeader ) && ( NtHeader->FileHeader.Machine == IMAGE_FILE_MACHINE_I386 )) ||
            (( ! NtHeader ) && ( *(UNALIGNED USHORT *)InDataBuffer == 0x5A4D ))) {

            LzxOptE8 = InDataSize;
            }

        ProgressPosition = ProgressInitialValue;
        ErrorCode        = ERROR_PATCH_ENCODE_FAILURE;
        BlockPointer     = InDataBuffer;
        BytesRemaining   = InDataSize;
        LzxStatus        = ENCODER_SUCCESS;
        Success          = TRUE;

        while (( BytesRemaining >= LZX_BLOCKSIZE ) && ( LzxStatus == ENCODER_SUCCESS ) && ( Success )) {

            LzxStatus = LZX_Encode(
                            LzxContext,
                            BlockPointer,
                            LZX_BLOCKSIZE,
                            &Estimate,
                            LzxOptE8
                            );

            if ( LzxStatus == ENCODER_SUCCESS ) {

                ProgressPosition += LZX_BLOCKSIZE;

                Success = ProgressCallbackWrapper(
                              ProgressCallback,
                              CallbackContext,
                              ProgressPosition,
                              ProgressMaximumValue
                              );

                if ( ! Success ) {
                    ErrorCode = GetLastError();
                    }
                }

            BlockPointer   += LZX_BLOCKSIZE;
            BytesRemaining -= LZX_BLOCKSIZE;
            }

        if (( BytesRemaining ) && ( LzxStatus == ENCODER_SUCCESS ) && ( Success )) {

            LzxStatus = LZX_Encode(
                            LzxContext,
                            BlockPointer,
                            BytesRemaining,
                            &Estimate,
                            LzxOptE8
                            );

            if ( LzxStatus == ENCODER_SUCCESS ) {

                ProgressPosition += BytesRemaining;

                Success = ProgressCallbackWrapper(
                              ProgressCallback,
                              CallbackContext,
                              ProgressPosition,
                              ProgressMaximumValue
                              );

                if ( ! Success ) {
                    ErrorCode = GetLastError();
                    }
                }
            }

        if (( LzxStatus == ENCODER_SUCCESS ) && ( Success )) {

            Success = LZX_EncodeFlush( LzxContext );

            if ( Success ) {

                if ( OutDataSize ) {
                    *OutDataSize = OutputContext.PatchSize;
                    }

                if (( OutDataBufferSize ) && ( OutputContext.PatchSize > OutDataBufferSize )) {
                    ErrorCode = ERROR_INSUFFICIENT_BUFFER;
                    }
                else {
                    ErrorCode = NO_ERROR;
                    }
                }
            }
        }

    return ErrorCode;
    }

#endif // ! PATCH_APPLY_CODE_ONLY


//
//  Following group of functions and exported apis are exclusively for
//  applying patches.  If we're only compiling the create code, ignore
//  this group of functions.
//

#ifndef PATCH_CREATE_CODE_ONLY


ULONG
WINAPI
EstimateLzxDecompressionMemoryRequirement(
    IN ULONG OldDataSize,
    IN ULONG NewDataSize,
    IN ULONG OptionFlags,
    IN ULONG WindowSize
    )
    {
    if ( WindowSize == 0 )
    {
         WindowSize = LzxWindowSize( OldDataSize, NewDataSize, OptionFlags, 0 );
    }

    //
    //  Currently the LZX decompression engine requires the size of the
    //  window plus some slop and the size of the context.  We'll add 64K
    //  to cover the context size and slop.
    //

    return ( WindowSize + 0x10000 );
    }


ULONG
WINAPI
ApplyRawLzxPatchToBuffer(
    IN  PVOID    OldDataBuffer,
    IN  ULONG    OldDataSize,
    IN  PVOID    PatchDataBuffer,
    IN  ULONG    PatchDataSize,
    OUT PVOID    NewDataBuffer,
    IN  ULONG    NewDataSize,
    IN  ULONG    OptionFlags,
    IN  ULONG    WindowSize,
    IN  PPATCH_INTERLEAVE_MAP InterleaveMap,
    IN  PFNALLOC pfnAlloc,
    IN  HANDLE   AllocHandle,
    IN  PPATCH_PROGRESS_CALLBACK ProgressCallback,
    IN  PVOID    CallbackContext,
    IN  ULONG    ProgressInitialValue,
    IN  ULONG    ProgressMaximumValue
    )
    {
    PPATCH_INTERLEAVE_MAP Imap        = InterleaveMap;
    PUCHAR CompressedInputPointer     = PatchDataBuffer;
    PUCHAR CompressedInputExtent      = CompressedInputPointer + PatchDataSize;
    PUCHAR UncompressedOutputPointer  = NewDataBuffer;
    ULONG  ProgressPosition           = ProgressInitialValue;

    PATCH_INTERLEAVE_MAP SingleMap;
    ULONG  UncompBlockLength;
    ULONG  CompressedLength;
    LONG   ActualSize;
    PUCHAR OldPointer;
    ULONG  OldOffset;
    ULONG  OldLength;
    ULONG  NewLength;
    ULONG  ImapIndex;
    ULONG  ImapCount;
    PVOID  LzxContext;
    ULONG  LzxWindow;
    LONG   LzxStatus;
    BOOL   Success;

    if ( ! ( OptionFlags & ( PATCH_OPTION_USE_LZX_A | PATCH_OPTION_USE_LZX_B ))) {
        return ERROR_INVALID_PARAMETER;
        }

    if ( WindowSize ) {
        LzxWindow = WindowSize;
        }
    else {
        LzxWindow = LzxWindowSize( OldDataSize, NewDataSize, OptionFlags, 0 );
        }

    if ( Imap == NULL ) {

        SingleMap.CountRanges = 1;
        SingleMap.Range[ 0 ].OldOffset = 0;
        SingleMap.Range[ 0 ].OldLength = MIN( OldDataSize, LzxWindow );
        SingleMap.Range[ 0 ].NewLength = NewDataSize;

        Imap = &SingleMap;
        }

#ifdef TESTCODE

    if (( OptionFlags & PATCH_OPTION_INTERLEAVE_FILES ) &&
        ( InterleaveMap != NULL ) &&
        ( InterleaveMap->CountRanges > 1 )) {

        ULONG TotalNew = 0;
        ULONG i;

        printf( "\n" );

        for ( i = 0; i < Imap->CountRanges; i++ ) {

            printf(
                "Preload  Old: 0x%08X (%u) from offset 0x%08X\n"
                "Decomp   New: 0x%08X (%u) from offset 0x%08X\n",
                Imap->Range[ i ].OldLength,
                Imap->Range[ i ].OldLength,
                Imap->Range[ i ].OldOffset,
                Imap->Range[ i ].NewLength,
                Imap->Range[ i ].NewLength,
                TotalNew
                );

            TotalNew += Imap->Range[ i ].NewLength;
            }

        ASSERT( TotalNew == NewDataSize );

        printf( "\n" );
        }

#endif /* TESTCODE */

    Success = LZX_DecodeInit(
                  &LzxContext,
                  LzxWindow,
                  pfnAlloc,
                  AllocHandle
                  );

    if ( ! Success ) {
        return ERROR_OUTOFMEMORY;
        }

    ImapCount = Imap->CountRanges;

    for ( ImapIndex = 0; ImapIndex < ImapCount; ImapIndex++ ) {

        OldOffset = Imap->Range[ ImapIndex ].OldOffset;
        OldLength = Imap->Range[ ImapIndex ].OldLength;
        NewLength = Imap->Range[ ImapIndex ].NewLength;

        ASSERT(( OldOffset + OldLength ) <= OldDataSize );
        ASSERT( OldLength <= LzxWindow );

        if ( ImapIndex > 0 ) {
            LZX_DecodeNewGroup( LzxContext );
            }

        OldPointer = (PUCHAR)OldDataBuffer + OldOffset;

        Success = LZX_DecodeInsertDictionary(
                      LzxContext,
                      OldPointer,
                      OldLength
                      );

        if ( ! Success ) {
            return ERROR_PATCH_DECODE_FAILURE;
            }

        while ( NewLength > 0 ) {

            CompressedLength = *(UNALIGNED USHORT *)( CompressedInputPointer );

            CompressedInputPointer += sizeof( USHORT );

            if (( CompressedLength == 0 ) ||
                (( CompressedInputPointer + CompressedLength ) > CompressedInputExtent )) {

                return ERROR_PATCH_DECODE_FAILURE;
                }

            UncompBlockLength = MIN( NewLength, LZX_BLOCKSIZE );

            LzxStatus = LZX_Decode(
                            LzxContext,
                            UncompBlockLength,
                            CompressedInputPointer,
                            CompressedLength,
                            UncompressedOutputPointer,
                            UncompBlockLength,
                            &ActualSize
                            );

            if (( LzxStatus != 0 ) || ((ULONG)ActualSize != UncompBlockLength )) {
                return ERROR_PATCH_DECODE_FAILURE;
                }

            CompressedInputPointer     += CompressedLength;
            UncompressedOutputPointer  += UncompBlockLength;
            NewLength                  -= UncompBlockLength;
            ProgressPosition           += UncompBlockLength;

            Success = ProgressCallbackWrapper(
                          ProgressCallback,
                          CallbackContext,
                          ProgressPosition,
                          ProgressMaximumValue
                          );

            if ( ! Success ) {
                return GetLastError();  // guaranteed nonzero by wrapper
                }
            }
        }

    return NO_ERROR;
    }


#endif // ! PATCH_CREATE_CODE_ONLY
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\autoupd\patch\api\patchapi.h ===
//
//  patchapi.h
//
//  Interface for creating and applying patches to files.
//
//  Copyright (C) Microsoft, 1997-2001.
//

#ifndef _PATCHAPI_H_
#define _PATCHAPI_H_

#ifdef __cplusplus
extern "C" {
#endif

//
//  The following constants can be combined and used as the OptionFlags
//  parameter in the patch creation apis.
//

#define PATCH_OPTION_USE_BEST           0x00000000  // auto choose best (slower)

#define PATCH_OPTION_USE_LZX_BEST       0x00000003  // auto choose best of LZX A/B (but not large)
#define PATCH_OPTION_USE_LZX_A          0x00000001  // normal
#define PATCH_OPTION_USE_LZX_B          0x00000002  // better on some x86 binaries
#define PATCH_OPTION_USE_LZX_LARGE      0x00000004  // better support for large files (version 1.97 and higher)

#define PATCH_OPTION_NO_BINDFIX         0x00010000  // PE bound imports
#define PATCH_OPTION_NO_LOCKFIX         0x00020000  // PE smashed locks
#define PATCH_OPTION_NO_REBASE          0x00040000  // PE rebased image
#define PATCH_OPTION_FAIL_IF_SAME_FILE  0x00080000  // don't create if same
#define PATCH_OPTION_FAIL_IF_BIGGER     0x00100000  // fail if patch is larger than simply compressing new file (slower)
#define PATCH_OPTION_NO_CHECKSUM        0x00200000  // PE checksum zero
#define PATCH_OPTION_NO_RESTIMEFIX      0x00400000  // PE resource timestamps
#define PATCH_OPTION_NO_TIMESTAMP       0x00800000  // don't store new file timestamp in patch
#define PATCH_OPTION_SIGNATURE_MD5      0x01000000  // use MD5 instead of CRC32
#define PATCH_OPTION_INTERLEAVE_FILES   0x40000000  // better support for large files (requires 5.2 or higher applyer)
#define PATCH_OPTION_RESERVED1          0x80000000  // (used internally)

#define PATCH_OPTION_VALID_FLAGS        0xC0FF0007

//
//  The following flags are used with PATCH_OPTION_DATA SymbolOptionFlags:
//

#define PATCH_SYMBOL_NO_IMAGEHLP        0x00000001  // don't use imagehlp.dll
#define PATCH_SYMBOL_NO_FAILURES        0x00000002  // don't fail patch due to imagehlp failures
#define PATCH_SYMBOL_UNDECORATED_TOO    0x00000004  // after matching decorated symbols, try to match remaining by undecorated names
#define PATCH_SYMBOL_RESERVED1          0x80000000  // (used internally)

//
//  The following flags are used with PATCH_OPTION_DATA ExtendedOptionFlags:
//

#define PATCH_TRANSFORM_PE_RESOURCE_2   0x00000100  // better handling of PE resources, requires 5.2 or higher applyer
#define PATCH_TRANSFORM_PE_IRELOC_2     0x00000200  // better handling of PE stripped relocs, requires 5.2 or higher applyer


//
//  The following constants can be combined and used as the ApplyOptionFlags
//  parameter in the patch apply and test apis.
//

#define APPLY_OPTION_FAIL_IF_EXACT      0x00000001  // don't copy new file
#define APPLY_OPTION_FAIL_IF_CLOSE      0x00000002  // differ by rebase, bind
#define APPLY_OPTION_TEST_ONLY          0x00000004  // don't create new file
#define APPLY_OPTION_VALID_FLAGS        0x00000007

//
//  In addition to standard Win32 error codes, the following error codes may
//  be returned via GetLastError() when one of the patch APIs fails.
//

#define ERROR_PATCH_ENCODE_FAILURE          0xC00E3101  // create
#define ERROR_PATCH_INVALID_OPTIONS         0xC00E3102  // create
#define ERROR_PATCH_SAME_FILE               0xC00E3103  // create
#define ERROR_PATCH_RETAIN_RANGES_DIFFER    0xC00E3104  // create
#define ERROR_PATCH_BIGGER_THAN_COMPRESSED  0xC00E3105  // create
#define ERROR_PATCH_IMAGEHLP_FAILURE        0xC00E3106  // create
#define ERROR_PATCH_CREATE_RESERVED_07      0xC00E3107  // create

#define ERROR_PATCH_DECODE_FAILURE          0xC00E4101  // apply
#define ERROR_PATCH_CORRUPT                 0xC00E4102  // apply
#define ERROR_PATCH_NEWER_FORMAT            0xC00E4103  // apply
#define ERROR_PATCH_WRONG_FILE              0xC00E4104  // apply
#define ERROR_PATCH_NOT_NECESSARY           0xC00E4105  // apply
#define ERROR_PATCH_NOT_AVAILABLE           0xC00E4106  // apply

typedef BOOL (CALLBACK PATCH_PROGRESS_CALLBACK)(
    PVOID CallbackContext,
    ULONG CurrentPosition,
    ULONG MaximumPosition
    );

typedef PATCH_PROGRESS_CALLBACK *PPATCH_PROGRESS_CALLBACK;

typedef BOOL (CALLBACK PATCH_SYMLOAD_CALLBACK)(
    IN ULONG  WhichFile,          // 0 for new file, 1 for first old file, etc
    IN LPCSTR SymbolFileName,
    IN ULONG  SymType,            // see SYM_TYPE in imagehlp.h
    IN ULONG  SymbolFileCheckSum,
    IN ULONG  SymbolFileTimeDate,
    IN ULONG  ImageFileCheckSum,
    IN ULONG  ImageFileTimeDate,
    IN PVOID  CallbackContext
    );

typedef PATCH_SYMLOAD_CALLBACK *PPATCH_SYMLOAD_CALLBACK;

typedef struct _PATCH_IGNORE_RANGE {
    ULONG OffsetInOldFile;
    ULONG LengthInBytes;
    } PATCH_IGNORE_RANGE, *PPATCH_IGNORE_RANGE;

typedef struct _PATCH_RETAIN_RANGE {
    ULONG OffsetInOldFile;
    ULONG LengthInBytes;
    ULONG OffsetInNewFile;
    } PATCH_RETAIN_RANGE, *PPATCH_RETAIN_RANGE;

typedef struct _PATCH_OLD_FILE_INFO_A {
    ULONG               SizeOfThisStruct;
    LPCSTR              OldFileName;
    ULONG               IgnoreRangeCount;               // maximum 255
    PPATCH_IGNORE_RANGE IgnoreRangeArray;
    ULONG               RetainRangeCount;               // maximum 255
    PPATCH_RETAIN_RANGE RetainRangeArray;
    } PATCH_OLD_FILE_INFO_A, *PPATCH_OLD_FILE_INFO_A;

typedef struct _PATCH_OLD_FILE_INFO_W {
    ULONG               SizeOfThisStruct;
    LPCWSTR             OldFileName;
    ULONG               IgnoreRangeCount;               // maximum 255
    PPATCH_IGNORE_RANGE IgnoreRangeArray;
    ULONG               RetainRangeCount;               // maximum 255
    PPATCH_RETAIN_RANGE RetainRangeArray;
    } PATCH_OLD_FILE_INFO_W, *PPATCH_OLD_FILE_INFO_W;

typedef struct _PATCH_OLD_FILE_INFO_H {
    ULONG               SizeOfThisStruct;
    HANDLE              OldFileHandle;
    ULONG               IgnoreRangeCount;               // maximum 255
    PPATCH_IGNORE_RANGE IgnoreRangeArray;
    ULONG               RetainRangeCount;               // maximum 255
    PPATCH_RETAIN_RANGE RetainRangeArray;
    } PATCH_OLD_FILE_INFO_H, *PPATCH_OLD_FILE_INFO_H;

typedef struct _PATCH_OLD_FILE_INFO {
    ULONG               SizeOfThisStruct;
    union {
        LPCSTR          OldFileNameA;
        LPCWSTR         OldFileNameW;
        HANDLE          OldFileHandle;
        };
    ULONG               IgnoreRangeCount;               // maximum 255
    PPATCH_IGNORE_RANGE IgnoreRangeArray;
    ULONG               RetainRangeCount;               // maximum 255
    PPATCH_RETAIN_RANGE RetainRangeArray;
    } PATCH_OLD_FILE_INFO, *PPATCH_OLD_FILE_INFO;

typedef struct _PATCH_INTERLEAVE_MAP {
    ULONG CountRanges;
    struct {
        ULONG OldOffset;
        ULONG OldLength;
        ULONG NewLength;    // NewOffset implied by sum of previous NewLengths
        } Range[ 1 ];       // Variable length (CountRanges)
    } PATCH_INTERLEAVE_MAP, *PPATCH_INTERLEAVE_MAP;

typedef struct _PATCH_OPTION_DATA {
    ULONG                   SizeOfThisStruct;
    ULONG                   SymbolOptionFlags;      // PATCH_SYMBOL_xxx flags
    LPCSTR                  NewFileSymbolPath;      // always ANSI, never Unicode
    LPCSTR                 *OldFileSymbolPathArray; // array[ OldFileCount ]
    ULONG                   ExtendedOptionFlags;
    PPATCH_SYMLOAD_CALLBACK SymLoadCallback;
    PVOID                   SymLoadContext;
    PPATCH_INTERLEAVE_MAP*  InterleaveMapArray;     // array[ OldFileCount ]
    ULONG                   MaxLzxWindowSize;
    } PATCH_OPTION_DATA, *PPATCH_OPTION_DATA;

//
//  Note that PATCH_OPTION_DATA contains LPCSTR paths, and no LPCWSTR (Unicode)
//  path argument is available, even when used with one of the Unicode APIs
//  such as CreatePatchFileW.  This is because the underlying system services
//  for symbol file handling (IMAGEHLP.DLL) only support ANSI file/path names.
//

//
//  A note about PATCH_RETAIN_RANGE specifiers with multiple old files:
//
//  Each old version file must have the same RetainRangeCount, and the same
//  retain range LengthInBytes and OffsetInNewFile values in the same order.
//  Only the OffsetInOldFile values can differ between old files for retain
//  ranges.
//

#ifdef IMPORTING_PATCHAPI_DLL
#define PATCHAPI WINAPI __declspec( dllimport )
#else
#define PATCHAPI WINAPI
#endif


//
//  The following prototypes are interface for creating patches from files.
//

BOOL
PATCHAPI
CreatePatchFileA(
    IN  LPCSTR OldFileName,
    IN  LPCSTR NewFileName,
    OUT LPCSTR PatchFileName,
    IN  ULONG  OptionFlags,
    IN  PPATCH_OPTION_DATA OptionData       // optional
    );

BOOL
PATCHAPI
CreatePatchFileW(
    IN  LPCWSTR OldFileName,
    IN  LPCWSTR NewFileName,
    OUT LPCWSTR PatchFileName,
    IN  ULONG   OptionFlags,
    IN  PPATCH_OPTION_DATA OptionData       // optional
    );

BOOL
PATCHAPI
CreatePatchFileByHandles(
    IN  HANDLE OldFileHandle,
    IN  HANDLE NewFileHandle,
    OUT HANDLE PatchFileHandle,
    IN  ULONG  OptionFlags,
    IN  PPATCH_OPTION_DATA OptionData       // optional
    );

BOOL
PATCHAPI
CreatePatchFileExA(
    IN  ULONG                    OldFileCount,          // maximum 255
    IN  PPATCH_OLD_FILE_INFO_A   OldFileInfoArray,
    IN  LPCSTR                   NewFileName,
    OUT LPCSTR                   PatchFileName,
    IN  ULONG                    OptionFlags,
    IN  PPATCH_OPTION_DATA       OptionData,            // optional
    IN  PPATCH_PROGRESS_CALLBACK ProgressCallback,
    IN  PVOID                    CallbackContext
    );

BOOL
PATCHAPI
CreatePatchFileExW(
    IN  ULONG                    OldFileCount,          // maximum 255
    IN  PPATCH_OLD_FILE_INFO_W   OldFileInfoArray,
    IN  LPCWSTR                  NewFileName,
    OUT LPCWSTR                  PatchFileName,
    IN  ULONG                    OptionFlags,
    IN  PPATCH_OPTION_DATA       OptionData,            // optional
    IN  PPATCH_PROGRESS_CALLBACK ProgressCallback,
    IN  PVOID                    CallbackContext
    );

BOOL
PATCHAPI
CreatePatchFileByHandlesEx(
    IN  ULONG                    OldFileCount,          // maximum 255
    IN  PPATCH_OLD_FILE_INFO_H   OldFileInfoArray,
    IN  HANDLE                   NewFileHandle,
    OUT HANDLE                   PatchFileHandle,
    IN  ULONG                    OptionFlags,
    IN  PPATCH_OPTION_DATA       OptionData,            // optional
    IN  PPATCH_PROGRESS_CALLBACK ProgressCallback,
    IN  PVOID                    CallbackContext
    );

BOOL
PATCHAPI
ExtractPatchHeaderToFileA(
    IN  LPCSTR PatchFileName,
    OUT LPCSTR PatchHeaderFileName
    );

BOOL
PATCHAPI
ExtractPatchHeaderToFileW(
    IN  LPCWSTR PatchFileName,
    OUT LPCWSTR PatchHeaderFileName
    );

BOOL
PATCHAPI
ExtractPatchHeaderToFileByHandles(
    IN  HANDLE PatchFileHandle,
    OUT HANDLE PatchHeaderFileHandle
    );

//
//  The following prototypes are interface for creating new file from old file
//  and patch file.  Note that it is possible for the TestApply API to succeed
//  but the actual Apply to fail since the TestApply only verifies that the
//  old file has the correct CRC without actually applying the patch.  The
//  TestApply API only requires the patch header portion of the patch file,
//  but its CRC must be fixed up.
//

BOOL
PATCHAPI
TestApplyPatchToFileA(
    IN LPCSTR PatchFileName,
    IN LPCSTR OldFileName,
    IN ULONG  ApplyOptionFlags
    );

BOOL
PATCHAPI
TestApplyPatchToFileW(
    IN LPCWSTR PatchFileName,
    IN LPCWSTR OldFileName,
    IN ULONG   ApplyOptionFlags
    );

BOOL
PATCHAPI
TestApplyPatchToFileByHandles(
    IN HANDLE PatchFileHandle,      // requires GENERIC_READ access
    IN HANDLE OldFileHandle,        // requires GENERIC_READ access
    IN ULONG  ApplyOptionFlags
    );

BOOL
PATCHAPI
ApplyPatchToFileA(
    IN  LPCSTR PatchFileName,
    IN  LPCSTR OldFileName,
    OUT LPCSTR NewFileName,
    IN  ULONG  ApplyOptionFlags
    );

BOOL
PATCHAPI
ApplyPatchToFileW(
    IN  LPCWSTR PatchFileName,
    IN  LPCWSTR OldFileName,
    OUT LPCWSTR NewFileName,
    IN  ULONG   ApplyOptionFlags
    );

BOOL
PATCHAPI
ApplyPatchToFileByHandles(
    IN  HANDLE PatchFileHandle,     // requires GENERIC_READ access
    IN  HANDLE OldFileHandle,       // requires GENERIC_READ access
    OUT HANDLE NewFileHandle,       // requires GENERIC_READ | GENERIC_WRITE
    IN  ULONG  ApplyOptionFlags
    );

BOOL
PATCHAPI
ApplyPatchToFileExA(
    IN  LPCSTR                   PatchFileName,
    IN  LPCSTR                   OldFileName,
    OUT LPCSTR                   NewFileName,
    IN  ULONG                    ApplyOptionFlags,
    IN  PPATCH_PROGRESS_CALLBACK ProgressCallback,
    IN  PVOID                    CallbackContext
    );

BOOL
PATCHAPI
ApplyPatchToFileExW(
    IN  LPCWSTR                  PatchFileName,
    IN  LPCWSTR                  OldFileName,
    OUT LPCWSTR                  NewFileName,
    IN  ULONG                    ApplyOptionFlags,
    IN  PPATCH_PROGRESS_CALLBACK ProgressCallback,
    IN  PVOID                    CallbackContext
    );

BOOL
PATCHAPI
ApplyPatchToFileByHandlesEx(
    IN  HANDLE                   PatchFileHandle,
    IN  HANDLE                   OldFileHandle,
    OUT HANDLE                   NewFileHandle,
    IN  ULONG                    ApplyOptionFlags,
    IN  PPATCH_PROGRESS_CALLBACK ProgressCallback,
    IN  PVOID                    CallbackContext
    );

//
//  The following prototypes provide a unique patch "signature" for a given
//  file.  Consider the case where you have a new foo.dll and the machines
//  to be updated with the new foo.dll may have one of three different old
//  foo.dll files.  Rather than creating a single large patch file that can
//  update any of the three older foo.dll files, three separate smaller patch
//  files can be created and "named" according to the patch signature of the
//  old file.  Then the patch applyer application can determine at runtime
//  which of the three foo.dll patch files is necessary given the specific
//  foo.dll to be updated.  If patch files are being downloaded over a slow
//  network connection (Internet over a modem), this signature scheme provides
//  a mechanism for choosing the correct single patch file to download at
//  application time thus decreasing total bytes necessary to download.
//

BOOL
PATCHAPI
GetFilePatchSignatureA(
    IN  LPCSTR FileName,
    IN  ULONG  OptionFlags,
    IN  PVOID  OptionData,
    IN  ULONG  IgnoreRangeCount,
    IN  PPATCH_IGNORE_RANGE IgnoreRangeArray,
    IN  ULONG  RetainRangeCount,
    IN  PPATCH_RETAIN_RANGE RetainRangeArray,
    IN  ULONG  SignatureBufferSize,
    OUT PVOID  SignatureBuffer
    );

BOOL
PATCHAPI
GetFilePatchSignatureW(
    IN  LPCWSTR FileName,
    IN  ULONG   OptionFlags,
    IN  PVOID   OptionData,
    IN  ULONG   IgnoreRangeCount,
    IN  PPATCH_IGNORE_RANGE IgnoreRangeArray,
    IN  ULONG   RetainRangeCount,
    IN  PPATCH_RETAIN_RANGE RetainRangeArray,
    IN  ULONG   SignatureBufferSizeInBytes,
    OUT PVOID   SignatureBuffer
    );

BOOL
PATCHAPI
GetFilePatchSignatureByHandle(
    IN  HANDLE  FileHandle,
    IN  ULONG   OptionFlags,
    IN  PVOID   OptionData,
    IN  ULONG   IgnoreRangeCount,
    IN  PPATCH_IGNORE_RANGE IgnoreRangeArray,
    IN  ULONG   RetainRangeCount,
    IN  PPATCH_RETAIN_RANGE RetainRangeArray,
    IN  ULONG   SignatureBufferSize,
    OUT PVOID   SignatureBuffer
    );


//
//  Depending on whether UNICODE is defined, map the generic API names to the
//  appropriate Unicode or Ansi APIs.
//

#ifdef UNICODE

    #define CreatePatchFile          CreatePatchFileW
    #define CreatePatchFileEx        CreatePatchFileExW
    #define TestApplyPatchToFile     TestApplyPatchToFileW
    #define ApplyPatchToFile         ApplyPatchToFileW
    #define ApplyPatchToFileEx       ApplyPatchToFileExW
    #define ExtractPatchHeaderToFile ExtractPatchHeaderToFileW
    #define GetFilePatchSignature    GetFilePatchSignatureW

#else

    #define CreatePatchFile          CreatePatchFileA
    #define CreatePatchFileEx        CreatePatchFileExA
    #define TestApplyPatchToFile     TestApplyPatchToFileA
    #define ApplyPatchToFile         ApplyPatchToFileA
    #define ApplyPatchToFileEx       ApplyPatchToFileExA
    #define ExtractPatchHeaderToFile ExtractPatchHeaderToFileA
    #define GetFilePatchSignature    GetFilePatchSignatureA

#endif // UNICODE

#ifdef __cplusplus
}
#endif

#endif // _PATCHAPI_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\autoupd\patch\api\misc.c ===
#include <precomp.h>

//
//  misc.c
//
//  Author: Tom McGuire (tommcg) 2/97 - 12/97
//
//  Copyright (C) Microsoft, 1997-2001.
//
//  MICROSOFT CONFIDENTIAL
//

typedef struct _SUBALLOCATOR SUBALLOCATOR, *PSUBALLOCATOR;

struct _SUBALLOCATOR {

    PVOID  VirtualListTerminator;

    PVOID *VirtualList;
    PCHAR  NextAvailable;
    PCHAR  LastAvailable;
    ULONG  GrowSize;

#ifdef TESTCODE
    ULONG  TotalCommit;
#endif

    };


const ULONG gCrcTable32[ 256 ] = {
    0x00000000, 0x77073096, 0xEE0E612C, 0x990951BA, 0x076DC419, 0x706AF48F,
    0xE963A535, 0x9E6495A3, 0x0EDB8832, 0x79DCB8A4, 0xE0D5E91E, 0x97D2D988,
    0x09B64C2B, 0x7EB17CBD, 0xE7B82D07, 0x90BF1D91, 0x1DB71064, 0x6AB020F2,
    0xF3B97148, 0x84BE41DE, 0x1ADAD47D, 0x6DDDE4EB, 0xF4D4B551, 0x83D385C7,
    0x136C9856, 0x646BA8C0, 0xFD62F97A, 0x8A65C9EC, 0x14015C4F, 0x63066CD9,
    0xFA0F3D63, 0x8D080DF5, 0x3B6E20C8, 0x4C69105E, 0xD56041E4, 0xA2677172,
    0x3C03E4D1, 0x4B04D447, 0xD20D85FD, 0xA50AB56B, 0x35B5A8FA, 0x42B2986C,
    0xDBBBC9D6, 0xACBCF940, 0x32D86CE3, 0x45DF5C75, 0xDCD60DCF, 0xABD13D59,
    0x26D930AC, 0x51DE003A, 0xC8D75180, 0xBFD06116, 0x21B4F4B5, 0x56B3C423,
    0xCFBA9599, 0xB8BDA50F, 0x2802B89E, 0x5F058808, 0xC60CD9B2, 0xB10BE924,
    0x2F6F7C87, 0x58684C11, 0xC1611DAB, 0xB6662D3D, 0x76DC4190, 0x01DB7106,
    0x98D220BC, 0xEFD5102A, 0x71B18589, 0x06B6B51F, 0x9FBFE4A5, 0xE8B8D433,
    0x7807C9A2, 0x0F00F934, 0x9609A88E, 0xE10E9818, 0x7F6A0DBB, 0x086D3D2D,
    0x91646C97, 0xE6635C01, 0x6B6B51F4, 0x1C6C6162, 0x856530D8, 0xF262004E,
    0x6C0695ED, 0x1B01A57B, 0x8208F4C1, 0xF50FC457, 0x65B0D9C6, 0x12B7E950,
    0x8BBEB8EA, 0xFCB9887C, 0x62DD1DDF, 0x15DA2D49, 0x8CD37CF3, 0xFBD44C65,
    0x4DB26158, 0x3AB551CE, 0xA3BC0074, 0xD4BB30E2, 0x4ADFA541, 0x3DD895D7,
    0xA4D1C46D, 0xD3D6F4FB, 0x4369E96A, 0x346ED9FC, 0xAD678846, 0xDA60B8D0,
    0x44042D73, 0x33031DE5, 0xAA0A4C5F, 0xDD0D7CC9, 0x5005713C, 0x270241AA,
    0xBE0B1010, 0xC90C2086, 0x5768B525, 0x206F85B3, 0xB966D409, 0xCE61E49F,
    0x5EDEF90E, 0x29D9C998, 0xB0D09822, 0xC7D7A8B4, 0x59B33D17, 0x2EB40D81,
    0xB7BD5C3B, 0xC0BA6CAD, 0xEDB88320, 0x9ABFB3B6, 0x03B6E20C, 0x74B1D29A,
    0xEAD54739, 0x9DD277AF, 0x04DB2615, 0x73DC1683, 0xE3630B12, 0x94643B84,
    0x0D6D6A3E, 0x7A6A5AA8, 0xE40ECF0B, 0x9309FF9D, 0x0A00AE27, 0x7D079EB1,
    0xF00F9344, 0x8708A3D2, 0x1E01F268, 0x6906C2FE, 0xF762575D, 0x806567CB,
    0x196C3671, 0x6E6B06E7, 0xFED41B76, 0x89D32BE0, 0x10DA7A5A, 0x67DD4ACC,
    0xF9B9DF6F, 0x8EBEEFF9, 0x17B7BE43, 0x60B08ED5, 0xD6D6A3E8, 0xA1D1937E,
    0x38D8C2C4, 0x4FDFF252, 0xD1BB67F1, 0xA6BC5767, 0x3FB506DD, 0x48B2364B,
    0xD80D2BDA, 0xAF0A1B4C, 0x36034AF6, 0x41047A60, 0xDF60EFC3, 0xA867DF55,
    0x316E8EEF, 0x4669BE79, 0xCB61B38C, 0xBC66831A, 0x256FD2A0, 0x5268E236,
    0xCC0C7795, 0xBB0B4703, 0x220216B9, 0x5505262F, 0xC5BA3BBE, 0xB2BD0B28,
    0x2BB45A92, 0x5CB36A04, 0xC2D7FFA7, 0xB5D0CF31, 0x2CD99E8B, 0x5BDEAE1D,
    0x9B64C2B0, 0xEC63F226, 0x756AA39C, 0x026D930A, 0x9C0906A9, 0xEB0E363F,
    0x72076785, 0x05005713, 0x95BF4A82, 0xE2B87A14, 0x7BB12BAE, 0x0CB61B38,
    0x92D28E9B, 0xE5D5BE0D, 0x7CDCEFB7, 0x0BDBDF21, 0x86D3D2D4, 0xF1D4E242,
    0x68DDB3F8, 0x1FDA836E, 0x81BE16CD, 0xF6B9265B, 0x6FB077E1, 0x18B74777,
    0x88085AE6, 0xFF0F6A70, 0x66063BCA, 0x11010B5C, 0x8F659EFF, 0xF862AE69,
    0x616BFFD3, 0x166CCF45, 0xA00AE278, 0xD70DD2EE, 0x4E048354, 0x3903B3C2,
    0xA7672661, 0xD06016F7, 0x4969474D, 0x3E6E77DB, 0xAED16A4A, 0xD9D65ADC,
    0x40DF0B66, 0x37D83BF0, 0xA9BCAE53, 0xDEBB9EC5, 0x47B2CF7F, 0x30B5FFE9,
    0xBDBDF21C, 0xCABAC28A, 0x53B39330, 0x24B4A3A6, 0xBAD03605, 0xCDD70693,
    0x54DE5729, 0x23D967BF, 0xB3667A2E, 0xC4614AB8, 0x5D681B02, 0x2A6F2B94,
    0xB40BBE37, 0xC30C8EA1, 0x5A05DF1B, 0x2D02EF8D };


#if defined( DEBUG ) || defined( DBG ) || defined( TESTCODE )

BOOL
Assert(
    LPCSTR szText,
    LPCSTR szFile,
    DWORD  dwLine
    )
    {
    CHAR Buffer[ 512 ];
    wsprintf( Buffer, "ASSERT( %s ) FAILED, %s (%d)\n", szText, szFile, dwLine );
    OutputDebugString( Buffer );
    DebugBreak();
    return FALSE;
    }

#endif


#ifdef DONTCOMPILE  // Not currently being used

VOID
InitializeCrc32Table(
    VOID
    )
    {
    ULONG i, j, Value;

    for ( i = 0; i < 256; i++ ) {
        for ( Value = i, j = 8; j > 0; j-- ) {
            if ( Value & 1 ) {
                Value = ( Value >> 1 ) ^ 0xEDB88320;
                }
            else {
                Value >>= 1;
                }
            }
        gCrcTable32[ i ] = Value;
        }
    }

#endif // DONTCOMPILE


#ifdef _M_IX86
#pragma warning( disable: 4035 )    // no return value
#endif

ULONG
Crc32(
    IN ULONG InitialCrc,
    IN PVOID Buffer,
    IN ULONG ByteCount
    )
    {

#ifdef DONTCOMPILE  // Not currently being used

    //
    //  First determine if the CRC table has been initialized by checking
    //  that the last value in it is nonzero.  Believe it or not, this is
    //  thread safe because two threads could initialize the table at the
    //  same time with no harm, and the last value to be initialized in the
    //  table is used to determine if the table has been initialized.  On
    //  all hardware platforms (including Alpha) it is safe to assume that
    //  an aligned DWORD written to memory by one processor will be seen by
    //  the other processor(s) as either containing the value previously
    //  contained in that memory location, or the new written value, but not
    //  some weird unpredictable value.
    //

    if ( gCrcTable32[ 255 ] == 0 ) {
        InitializeCrc32Table();
        }

#endif // DONTCOMPILE

#ifdef _M_IX86

    __asm {

            mov     ecx, ByteCount          ; number of bytes in buffer
            xor     ebx, ebx                ; ebx (bl) will be our table index
            mov     esi, Buffer             ; buffer pointer
            test    ecx, ecx                ; test for zero length buffer
            mov     eax, InitialCrc         ; CRC-32 value

            jnz     short loopentry         ; if non-zero buffer, start loop
            jmp     short exitfunc          ; else exit (crc already in eax)

looptop:    shr     eax, 8                  ; (crc>>8)                      (U1)
            mov     edx, gCrcTable32[ebx*4] ; fetch Table[ index ]          (V1)

            xor     eax, edx                ; crc=(crc>>8)^Table[index]     (U1)
loopentry:  mov     bl, [esi]               ; fetch next *buffer            (V1)

            inc     esi                     ; buffer++                      (U1)
            xor     bl, al                  ; index=(byte)crc^*buffer       (V1)

            dec     ecx                     ; adjust counter                (U1)
            jnz     short looptop           ; loop while nBytes             (V1)

            shr     eax, 8                  ; remaining math on last byte
            xor     eax, gCrcTable32[ebx*4] ; eax returns new crc value

exitfunc:

        }

#else // ! _M_IX86

    {
    ULONG  Value = InitialCrc;
    ULONG  Count = ByteCount;
    PUCHAR p     = Buffer;

    while ( Count-- ) {
        Value = ( Value >> 8 ) ^ gCrcTable32[ (UCHAR)( *p++ ^ Value ) ];
        }

    return Value;
    }

#endif // ! _M_IX86
    }

#ifdef _M_IX86
#pragma warning( default: 4035 )    // no return value
#endif


BOOL
SafeCompleteCrc32(
    IN  PVOID  Buffer,
    IN  ULONG  ByteCount,
    OUT PULONG CrcValue
    )
    {
    BOOL Success = TRUE;

    __try {
        *CrcValue = Crc32( 0xFFFFFFFF, Buffer, ByteCount ) ^ 0xFFFFFFFF;
        }
    __except( EXCEPTION_EXECUTE_HANDLER ) {
        SetLastError( GetExceptionCode() );
        Success = FALSE;
        }

    return Success;
    }


BOOL
SafeCompleteMD5(
    IN  PVOID     Buffer,
    IN  ULONG     ByteCount,
    OUT PMD5_HASH MD5Value
    )
    {
    BOOL Success = TRUE;

    __try {
        ComputeCompleteMD5( Buffer, ByteCount, MD5Value );
        }
    __except( EXCEPTION_EXECUTE_HANDLER ) {
        SetLastError( GetExceptionCode() );
        Success = FALSE;
        }

    return Success;
    }


BOOL
MyMapViewOfFileA(
    IN  LPCSTR  FileName,
    OUT ULONG  *FileSize,
    OUT HANDLE *FileHandle,
    OUT PVOID  *MapBase
    )
    {
    HANDLE InternalFileHandle;
    BOOL   Success;

    InternalFileHandle = CreateFileA(
                             FileName,
                             GENERIC_READ,
                             FILE_SHARE_READ | FILE_SHARE_WRITE,
                             NULL,
                             OPEN_EXISTING,
                             FILE_FLAG_SEQUENTIAL_SCAN,
                             NULL
                             );

    if ( InternalFileHandle != INVALID_HANDLE_VALUE ) {

        Success = MyMapViewOfFileByHandle(
                      InternalFileHandle,
                      FileSize,
                      MapBase
                      );

        if ( Success ) {

            *FileHandle = InternalFileHandle;

            return TRUE;
            }

        CloseHandle( InternalFileHandle );
        }

    return FALSE;
    }


BOOL
MyMapViewOfFileByHandle(
    IN  HANDLE  FileHandle,
    OUT ULONG  *FileSize,
    OUT PVOID  *MapBase
    )
    {
    ULONG  InternalFileSize;
    ULONG  InternalFileSizeHigh;
    HANDLE InternalMapHandle;
    PVOID  InternalMapBase;

    InternalFileSize = GetFileSize( FileHandle, &InternalFileSizeHigh );

    if ( InternalFileSizeHigh != 0 ) {
        SetLastError( ERROR_OUTOFMEMORY );
        return FALSE;
        }

    if ( InternalFileSize == 0 ) {
        *MapBase  = NULL;
        *FileSize = 0;
        return TRUE;
        }

    if ( InternalFileSize != 0xFFFFFFFF ) {

        InternalMapHandle = CreateFileMapping(
                                FileHandle,
                                NULL,
                                PAGE_WRITECOPY,
                                0,
                                0,
                                NULL
                                );

        if ( InternalMapHandle != NULL ) {

            InternalMapBase = MapViewOfFile(
                                  InternalMapHandle,
                                  FILE_MAP_COPY,
                                  0,
                                  0,
                                  0
                                  );

            CloseHandle( InternalMapHandle );

            if ( InternalMapBase != NULL ) {

                *MapBase  = InternalMapBase;
                *FileSize = InternalFileSize;

                return TRUE;
                }
            }
        }

    return FALSE;
    }


BOOL
MyCreateMappedFileA(
    IN  LPCSTR  FileName,
    IN  ULONG   InitialSize,
    OUT HANDLE *FileHandle,
    OUT PVOID  *MapBase
    )
    {
    HANDLE InternalFileHandle;
    BOOL   Success;

    InternalFileHandle = CreateFileA(
                             FileName,
                             GENERIC_READ | GENERIC_WRITE,
                             FILE_SHARE_READ,
                             NULL,
                             CREATE_ALWAYS,
                             FILE_ATTRIBUTE_NORMAL,
                             NULL
                             );

    if ( InternalFileHandle != INVALID_HANDLE_VALUE ) {

        Success = MyCreateMappedFileByHandle(
                       InternalFileHandle,
                       InitialSize,
                       MapBase
                       );

        if ( Success ) {

            *FileHandle = InternalFileHandle;

            return TRUE;
            }

        CloseHandle( InternalFileHandle );
        }

    return FALSE;
    }


BOOL
MyCreateMappedFileByHandle(
    IN  HANDLE FileHandle,
    IN  ULONG  InitialSize,
    OUT PVOID *MapBase
    )
    {
    HANDLE InternalMapHandle;
    PVOID  InternalMapBase;

    InternalMapHandle = CreateFileMapping(
                            FileHandle,
                            NULL,
                            PAGE_READWRITE,
                            0,
                            InitialSize,
                            NULL
                            );

    if ( InternalMapHandle != NULL ) {

        InternalMapBase = MapViewOfFile(
                              InternalMapHandle,
                              FILE_MAP_WRITE,
                              0,
                              0,
                              0
                              );

        CloseHandle( InternalMapHandle );

        if ( InternalMapBase != NULL ) {

            *MapBase = InternalMapBase;

            return TRUE;
            }
        }

    return FALSE;
    }


VOID
MyUnmapCreatedMappedFile(
    IN HANDLE    FileHandle,
    IN PVOID     MapBase,
    IN ULONG     FileSize,
    IN PFILETIME FileTime OPTIONAL
    )
    {
    FlushViewOfFile( MapBase, 0 );
    UnmapViewOfFile( MapBase );
    SetFilePointer( FileHandle, (LONG) FileSize, NULL, FILE_BEGIN );
    SetEndOfFile( FileHandle );
    SetFileTime( FileHandle, NULL, NULL, FileTime );
    }


PVOID
__fastcall
MyVirtualAlloc(
    ULONG Size
    )
    {
    return VirtualAlloc( NULL, Size, MEM_COMMIT, PAGE_READWRITE );
    }


VOID
__fastcall
MyVirtualFree(
    PVOID Allocation
    )
    {
    VirtualFree( Allocation, 0, MEM_RELEASE );
    }


HANDLE
CreateSubAllocator(
    IN ULONG InitialCommitSize,
    IN ULONG GrowthCommitSize
    )
    {
    PSUBALLOCATOR SubAllocator;
    ULONG InitialSize;
    ULONG GrowthSize;

    InitialSize = ROUNDUP2( InitialCommitSize, MINIMUM_VM_ALLOCATION );
    GrowthSize  = ROUNDUP2( GrowthCommitSize,  MINIMUM_VM_ALLOCATION );

    SubAllocator = MyVirtualAlloc( InitialSize );

    //
    //  If can't allocate entire initial size, back off to minimum size.
    //  Very large initial requests sometimes cannot be allocated simply
    //  because there is not enough contiguous address space.
    //

    if (( SubAllocator == NULL ) && ( InitialSize > GrowthSize )) {
        InitialSize  = GrowthSize;
        SubAllocator = MyVirtualAlloc( InitialSize );
        }

    if (( SubAllocator == NULL ) && ( InitialSize > MINIMUM_VM_ALLOCATION )) {
        InitialSize  = MINIMUM_VM_ALLOCATION;
        SubAllocator = MyVirtualAlloc( InitialSize );
        }

    if ( SubAllocator != NULL ) {
        SubAllocator->NextAvailable = (PCHAR)SubAllocator + ROUNDUP2( sizeof( SUBALLOCATOR ), SUBALLOCATOR_ALIGNMENT );
        SubAllocator->LastAvailable = (PCHAR)SubAllocator + InitialSize;
        SubAllocator->VirtualList   = (PVOID*)SubAllocator;
        SubAllocator->GrowSize      = GrowthSize;

        SubAllocator->VirtualListTerminator = NULL;     // (prefix) shouldn't be necessary because VirtualAlloc returns zeroed memory.

#ifdef TESTCODE
        SubAllocator->TotalCommit   = InitialSize;
#endif
        }

    return (HANDLE) SubAllocator;
    }


PVOID
__fastcall
SubAllocate(
    IN HANDLE hAllocator,
    IN ULONG  Size
    )
    {
    PSUBALLOCATOR SubAllocator = (PSUBALLOCATOR) hAllocator;
    PCHAR NewVirtual;
    PCHAR Allocation;
    ULONG AllocSize;
    ULONG Available;
    ULONG GrowSize;

    ASSERT( Size < (ULONG)( ~(( SUBALLOCATOR_ALIGNMENT * 2 ) - 1 )));

    AllocSize = ROUNDUP2( Size, SUBALLOCATOR_ALIGNMENT );

    Available = (ULONG)( SubAllocator->LastAvailable - SubAllocator->NextAvailable );

    if ( AllocSize <= Available ) {

        Allocation = SubAllocator->NextAvailable;

        SubAllocator->NextAvailable = Allocation + AllocSize;

        ASSERT( *(DWORD*)( Allocation ) == 0 );
        ASSERT( *(DWORD*)( Allocation + AllocSize - 4 ) == 0 );
        ASSERT(( (ULONG)Allocation & ( SUBALLOCATOR_ALIGNMENT - 1 )) == 0 );

        return Allocation;
        }

    //
    //  Insufficient VM, so grow it.  Make sure we grow it enough to satisfy
    //  the allocation request in case the request is larger than the grow
    //  size specified in CreateSubAllocator.
    //

    GrowSize = SubAllocator->GrowSize;

    if ( GrowSize < ( AllocSize + SUBALLOCATOR_ALIGNMENT )) {
        GrowSize = ROUNDUP2(( AllocSize + SUBALLOCATOR_ALIGNMENT ), MINIMUM_VM_ALLOCATION );
        }

    NewVirtual = MyVirtualAlloc( GrowSize );

    //
    //  If failed to alloc GrowSize VM, and the allocation could be satisfied
    //  with a minimum VM allocation, try allocating minimum VM to satisfy
    //  this request.
    //

    if (( NewVirtual == NULL ) && ( AllocSize <= ( MINIMUM_VM_ALLOCATION - SUBALLOCATOR_ALIGNMENT ))) {
        GrowSize = MINIMUM_VM_ALLOCATION;
        NewVirtual = MyVirtualAlloc( GrowSize );
        }

    if ( NewVirtual != NULL ) {

#ifdef TESTCODE

        SubAllocator->TotalCommit += GrowSize;

        printf(
            "\n"
            "Growing VM SubAllocator 0x%08X to 0x%08X (%u) committed bytes\n"
            "  to satisfy 0x%08X (%u) byte request, wasting 0x%08X (%u)\n"
            "  bytes from previous commit chunk.\n",
            SubAllocator,
            SubAllocator->TotalCommit,
            SubAllocator->TotalCommit,
            Size,
            Size,
            Available,
            Available
            );

#endif

        //
        //  Set LastAvailable to end of new VM block.
        //

        SubAllocator->LastAvailable = NewVirtual + GrowSize;

        //
        //  Link new VM into list of VM allocations.
        //

        *(PVOID*)NewVirtual = SubAllocator->VirtualList;
        SubAllocator->VirtualList = (PVOID*)NewVirtual;

        //
        //  Requested allocation comes next.
        //

        Allocation = NewVirtual + SUBALLOCATOR_ALIGNMENT;

        //
        //  Then set the NextAvailable for what's remaining.
        //

        SubAllocator->NextAvailable = Allocation + AllocSize;

        //
        //  And return the allocation.
        //

        return Allocation;
        }

    //
    //  Could not allocate enough VM to satisfy request.
    //

#ifdef TESTCODE

    printf(
        "\nFailed to grow VM SubAllocator 0x%08X for 0x%08X (%u) byte request\n",
        SubAllocator,
        Size,
        Size
        );

#endif

    return NULL;
    }


VOID
DestroySubAllocator(
    IN HANDLE hAllocator
    )
    {
    PSUBALLOCATOR SubAllocator = (PSUBALLOCATOR) hAllocator;
    PVOID VirtualBlock = SubAllocator->VirtualList;
    PVOID NextVirtualBlock;

    do  {
        NextVirtualBlock = *(PVOID*)VirtualBlock;
        MyVirtualFree( VirtualBlock );
        VirtualBlock = NextVirtualBlock;
        }
    while ( VirtualBlock != NULL );
    }


LPSTR
__fastcall
MySubAllocStrDup(
    IN HANDLE SubAllocator,
    IN LPCSTR String
    )
    {
    ULONG Length = (ULONG)strlen( String );
    LPSTR Buffer = SubAllocate( SubAllocator, Length + 1 );

    if ( Buffer ) {
        memcpy( Buffer, String, Length );   // no need to copy NULL terminator
        }

    return Buffer;
    }


LPSTR
MySubAllocStrDupAndCat(
    IN HANDLE SubAllocator,
    IN LPCSTR String1,
    IN LPCSTR String2,
    IN CHAR   Separator
    )
    {
    ULONG Length1 = (ULONG)strlen( String1 );
    ULONG Length2 = (ULONG)strlen( String2 );
    LPSTR Buffer = SubAllocate( SubAllocator, Length1 + Length2 + 2 );

    if ( Buffer ) {

        memcpy( Buffer, String1, Length1 );

        if (( Separator != 0 ) && ( Length1 > 0 ) && ( Buffer[ Length1 - 1 ] != Separator )) {
            Buffer[ Length1++ ] = Separator;
            }

        memcpy( Buffer + Length1, String2, Length2 );   // no need to terminate
        }

    return Buffer;
    }


VOID
MyLowercase(
    IN OUT LPSTR String
    )
    {
    LPSTR p;

    for ( p = String; *p; p++ ) {
        if (( *p >= 'A' ) && ( *p <= 'Z' )) {
            *p |= 0x20;
            }
        }
    }



#ifdef DONTCOMPILE  // not used currently

DWORD MyProcessHeap;

PVOID
MyHeapAllocZero(
    IN ULONG Size
    )
    {
    PVOID Allocation;

    if ( MyProcessHeap == NULL ) {
        MyProcessHeap = GetProcessHeap();
        }

    Allocation = HeapAlloc( MyProcessHeap, HEAP_ZERO_MEMORY, Size );

    if ( Allocation == NULL ) {
        SetLastError( ERROR_OUTOFMEMORY );
        }

    return Allocation;
    }


VOID
MyHeapFree(
    IN PVOID Allocation
    )
    {
    HeapFree( MyProcessHeap, 0, Allocation );
    }

#endif // DONTCOMPILE


ULONG
HashName(
    IN LPCSTR Name
    )
    {
    ULONG Length = (ULONG)strlen( Name );
    ULONG Hash   = ~Length;

    while ( Length-- ) {
        Hash = _rotl( Hash, 3 ) ^ *Name++;
        }

    return Hash;
    }


ULONG
HashNameCaseInsensitive(
    IN LPCSTR Name
    )
    {
    ULONG Length = (ULONG)strlen( Name );
    ULONG Hash   = ~Length;

    while ( Length-- ) {
        Hash = _rotl( Hash, 3 ) ^ ( *Name++ & 0xDF );   // mask case bit
        }

    return Hash;
    }


UCHAR
__inline
LowNibbleToHexChar(
    ULONG Value
    )
    {
    return "0123456789abcdef"[ Value & 0x0000000F ];
    }


VOID
DwordToHexString(
    IN  DWORD Value,
    OUT LPSTR Buffer    // writes exactly 9 bytes including terminator
    )
    {
    ULONG i;

    Buffer[ 8 ] = 0;

    i = 8;

    do  {
        Buffer[ --i ] = LowNibbleToHexChar( Value );
        Value >>= 4;
        }
    while ( i != 0 );
    }


BOOL
HashToHexString(
    IN  PMD5_HASH HashValue,
    OUT LPSTR     Buffer                // must be at least 33 bytes
    )
    {
    ULONG i;

    for ( i = 0; i < sizeof( MD5_HASH ); i++ ) {

        *Buffer++ = LowNibbleToHexChar( HashValue->Byte[ i ] >> 4 );
        *Buffer++ = LowNibbleToHexChar( HashValue->Byte[ i ] );
        }

    *Buffer = 0;

    return TRUE;
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\autoupd\patch\api\patchlzx.h ===
#ifndef _PATCH_LZX_H_
#define _PATCH_LZX_H_

#ifdef __cplusplus
extern "C" {
#endif

//
//  BUGBUG: The patch code is using the LZX_MAXWINDOW value to compute
//          progress ranges.  We need a better way to compute progress
//          ranges that doesn't need to know the details of the underlying
//          compression engine.
//

#define LZX_BLOCKSIZE       0x8000          // 32K
#define LZX_MINWINDOW       0x20000         // 128K

#define LZX_MAXWINDOW_8     ( 8*1024*1024)  // 8MB
#define LZX_MAXWINDOW_32    (32*1024*1024)  // 32MB

#ifndef PFNALLOC
typedef PVOID ( __fastcall * PFNALLOC )( HANDLE hAllocator, ULONG Size );
#endif

//
//  The PFNALLOC function must return zeroed memory its caller, or NULL to
//  indicate insufficient memory.
//
//  Note that no PFNFREE corresponding to PFNALLOC is specified.  Functions
//  that take a PFNALLOC parameter use that routine for multiple allocations,
//  but it is the responsibility of the caller to free any allocations made
//  through the PFNALLOC allocator after the function has returned.  This
//  scheme is used to facilitate multiple allocations that can be freed with
//  a single call such as a HeapCreate/HeapAlloc[...]/HeapDestroy sequence.
//

ULONG
WINAPI
EstimateLzxCompressionMemoryRequirement(
    IN ULONG OldDataSize,
    IN ULONG NewDataSize,
    IN ULONG OptionFlags,
    IN ULONG MaxWindow
    );

ULONG
WINAPI
EstimateLzxDecompressionMemoryRequirement(
    IN ULONG OldDataSize,
    IN ULONG NewDataSize,
    IN ULONG OptionFlags,
    IN ULONG WindowSize
    );

ULONG
WINAPI
RawLzxCompressBuffer(
    IN  PVOID    InDataBuffer,
    IN  ULONG    InDataSize,
    IN  ULONG    OutDataBufferSize,
    OUT PVOID    OutDataBuffer OPTIONAL,
    OUT PULONG   OutDataSize,
    IN  ULONG    WindowSize,
    IN  PFNALLOC pfnAlloc,
    IN  HANDLE   AllocHandle,
    IN  PPATCH_PROGRESS_CALLBACK ProgressCallback,
    IN  PVOID    CallbackContext,
    IN  ULONG    ProgressInitialValue,
    IN  ULONG    ProgressMaximumValue
    );

ULONG
WINAPI
CreateRawLzxPatchDataFromBuffers(
    IN  PVOID    OldDataBuffer,
    IN  ULONG    OldDataSize,
    IN  PVOID    NewDataBuffer,
    IN  ULONG    NewDataSize,
    IN  ULONG    PatchBufferSize,
    OUT PVOID    PatchBuffer,
    OUT ULONG   *PatchSize,
    IN  ULONG    OptionFlags,
    IN  ULONG    MaxWindowSize,
    IN  PPATCH_INTERLEAVE_MAP InterleaveMap,
    IN  PFNALLOC pfnAlloc,
    IN  HANDLE   AllocHandle,
    IN  PPATCH_PROGRESS_CALLBACK ProgressCallback,
    IN  PVOID    CallbackContext,
    IN  ULONG    ProgressInitialValue,
    IN  ULONG    ProgressMaximumValue
    );

ULONG
WINAPI
ApplyRawLzxPatchToBuffer(
    IN  PVOID    OldDataBuffer,
    IN  ULONG    OldDataSize,
    IN  PVOID    PatchDataBuffer,
    IN  ULONG    PatchDataSize,
    OUT PVOID    NewDataBuffer,
    IN  ULONG    NewDataSize,
    IN  ULONG    OptionFlags,
    IN  ULONG    WindowSize,
    IN  PPATCH_INTERLEAVE_MAP InterleaveMap,
    IN  PFNALLOC pfnAlloc,
    IN  HANDLE   AllocHandle,
    IN  PPATCH_PROGRESS_CALLBACK ProgressCallback,
    IN  PVOID    CallbackContext,
    IN  ULONG    ProgressInitialValue,
    IN  ULONG    ProgressMaximumValue
    );

ULONG
__fastcall
LzxWindowSize(
    IN ULONG OldDataSize,
    IN ULONG NewDataSize,
    IN DWORD OptionFlags,
    IN ULONG AbsoluteMax
    );

ULONG
__fastcall
LzxMaxWindowSize(
    IN ULONG OptionFlags,
    IN ULONG AbsoluteMax
    );

ULONG
__fastcall
LzxOldFileInsertSize(
    IN ULONG OldDataSize,
    IN DWORD OptionFlags,
    IN ULONG AbsoluteMaxWindow,
    IN PPATCH_INTERLEAVE_MAP InterleaveMap
    );

PPATCH_INTERLEAVE_MAP
CreateDefaultInterleaveMap(
    IN HANDLE SubAllocator,
    IN ULONG  OldFileSize,
    IN ULONG  NewFileSize,
    IN ULONG  OptionFlags,
    IN ULONG  MaxWindow
    );


#ifdef __cplusplus
}
#endif

#endif // _PATCH_LZX_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\sdktools\autoupd\patch\api\patchapi.c ===
#include <precomp.h>

//
//  patchapi.c
//
//  Implementation of PatchAPI for creating and applying patches to files.
//
//  Author: Tom McGuire (tommcg) 2/97 - 9/97
//
//  Copyright (C) Microsoft, 1997-2001.
//
//  MICROSOFT CONFIDENTIAL
//

typedef struct _PATCH_DATA {
    PVOID PatchData;
    ULONG PatchSize;
    } PATCH_DATA, *PPATCH_DATA;

//
//  If we're building a DLL, and it's not the applyer-only DLL, we need to
//  hook DLL_PROCESS_DETACH so we can unload imagehlp.dll if we dynamically
//  load it.  We only need imagehlp.dll if we're creating patches.
//

#ifdef BUILDING_PATCHAPI_DLL
#ifndef PATCH_APPLY_CODE_ONLY

BOOL
WINAPI
DllEntryPoint(
    HANDLE hDll,
    DWORD  Reason,
    PVOID  Reserved     // NULL for dynamic unload, non-NULL for terminating
    )
    {
    if ( Reason == DLL_PROCESS_ATTACH ) {
        DisableThreadLibraryCalls( hDll );
        InitImagehlpCritSect();
        }
    else if (( Reason == DLL_PROCESS_DETACH ) && ( ! Reserved )) {
        UnloadImagehlp();
        }

    return TRUE;
    }

#endif // ! PATCH_APPLY_CODE_ONLY
#endif // BUILDING_PATCHAPI_DLL


BOOL
ProgressCallbackWrapper(
    IN PPATCH_PROGRESS_CALLBACK ProgressCallback,
    IN PVOID                    CallbackContext,
    IN ULONG                    CurrentPosition,
    IN ULONG                    MaximumPosition
    )
    {
    BOOL Success = TRUE;

    if ( ProgressCallback != NULL ) {

        __try {

            Success = ProgressCallback(
                          CallbackContext,
                          CurrentPosition,
                          MaximumPosition
                          );

            if (( ! Success ) && ( GetLastError() == ERROR_SUCCESS )) {
                SetLastError( ERROR_CANCELLED );
                }
            }

        __except( EXCEPTION_EXECUTE_HANDLER ) {
            SetLastError( ERROR_CANCELLED );
            Success = FALSE;
            }
        }

    return Success;
    }


BOOL
WINAPIV
NormalizeOldFileImageForPatching(
    IN PVOID FileMappedImage,
    IN ULONG FileSize,
    IN ULONG OptionFlags,
    IN PVOID OptionData,
    IN ULONG NewFileCoffBase,
    IN ULONG NewFileCoffTime,
    IN ULONG IgnoreRangeCount,
    IN PPATCH_IGNORE_RANGE IgnoreRangeArray,
    IN ULONG RetainRangeCount,
    IN PPATCH_RETAIN_RANGE RetainRangeArray,
    ...
    )
    {
    PUCHAR            MappedFile;
    PIMAGE_NT_HEADERS NtHeader;
    BOOL              Modified;
    BOOL              Success;
    ULONG             i;

    MappedFile = FileMappedImage;
    Modified   = FALSE;
    Success    = TRUE;

    __try {

        NtHeader = GetNtHeader( MappedFile, FileSize );

        if ( NtHeader ) {

            //
            //  This is a coff image.
            //

            Modified = NormalizeCoffImage(
                           NtHeader,
                           MappedFile,
                           FileSize,
                           OptionFlags,
                           OptionData,
                           NewFileCoffBase,
                           NewFileCoffTime
                           );

            }

        else {

            //
            //  Other file type normalizations could be performed here.
            //

            }

#ifdef TESTCODE

        //
        //  The following test-only code creates a file containing
        //  the modified coff image to verify that the coff image
        //  is really a valid coff image.  This is for debugging
        //  only.
        //

        if ( Modified ) {

            HANDLE hFile = CreateFile(
                               "Normalized.out",
                               GENERIC_WRITE,
                               FILE_SHARE_READ,
                               NULL,
                               CREATE_ALWAYS,
                               FILE_ATTRIBUTE_NORMAL,
                               NULL
                               );

            if ( hFile != INVALID_HANDLE_VALUE ) {

                DWORD Actual;

                WriteFile( hFile, MappedFile, FileSize, &Actual, NULL );

                CloseHandle( hFile );

                }
            }

#endif // TESTCODE

        for ( i = 0; i < IgnoreRangeCount; i++ ) {
            if (( IgnoreRangeArray[ i ].OffsetInOldFile + IgnoreRangeArray[ i ].LengthInBytes ) <= FileSize ) {
                ZeroMemory( MappedFile + IgnoreRangeArray[ i ].OffsetInOldFile, IgnoreRangeArray[ i ].LengthInBytes );
                }
            }

        for ( i = 0; i < RetainRangeCount; i++ ) {
            if (( RetainRangeArray[ i ].OffsetInOldFile + RetainRangeArray[ i ].LengthInBytes ) <= FileSize ) {
                ZeroMemory( MappedFile + RetainRangeArray[ i ].OffsetInOldFile, RetainRangeArray[ i ].LengthInBytes );
                }
            }
        }

    __except( EXCEPTION_EXECUTE_HANDLER ) {
        SetLastError( GetExceptionCode() );
        Success = FALSE;
        }

    return Success;
    }


BOOL
PATCHAPI
GetFilePatchSignatureA(
    IN  LPCSTR FileName,
    IN  ULONG  OptionFlags,
    IN  PVOID  OptionData,
    IN  ULONG  IgnoreRangeCount,
    IN  PPATCH_IGNORE_RANGE IgnoreRangeArray,
    IN  ULONG  RetainRangeCount,
    IN  PPATCH_RETAIN_RANGE RetainRangeArray,
    IN  ULONG  SignatureBufferSize,
    OUT PVOID  SignatureBuffer
    )
    {
    BOOL   Success = FALSE;
    HANDLE FileHandle;

    FileHandle = CreateFileA(
                    FileName,
                    GENERIC_READ,
                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                    NULL,
                    OPEN_EXISTING,
                    FILE_FLAG_SEQUENTIAL_SCAN,
                    NULL
                    );

    if ( FileHandle != INVALID_HANDLE_VALUE ) {

        Success = GetFilePatchSignatureByHandle(
                      FileHandle,
                      OptionFlags,
                      OptionData,
                      IgnoreRangeCount,
                      IgnoreRangeArray,
                      RetainRangeCount,
                      RetainRangeArray,
                      SignatureBufferSize,
                      SignatureBuffer
                      );

        CloseHandle( FileHandle );
        }

    return Success;
    }


BOOL
PATCHAPI
GetFilePatchSignatureW(
    IN  LPCWSTR FileName,
    IN  ULONG   OptionFlags,
    IN  PVOID   OptionData,
    IN  ULONG   IgnoreRangeCount,
    IN  PPATCH_IGNORE_RANGE IgnoreRangeArray,
    IN  ULONG   RetainRangeCount,
    IN  PPATCH_RETAIN_RANGE RetainRangeArray,
    IN  ULONG   SignatureBufferSizeInBytes,
    OUT PVOID   SignatureBuffer
    )
    {
    CHAR   AnsiSignatureBuffer[ 40 ];   // big enough for hex MD5 (33 bytes)
    HANDLE FileHandle;
    INT    Converted;
    BOOL   Success = FALSE;

    FileHandle = CreateFileW(
                    FileName,
                    GENERIC_READ,
                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                    NULL,
                    OPEN_EXISTING,
                    FILE_FLAG_SEQUENTIAL_SCAN,
                    NULL
                    );

    if ( FileHandle != INVALID_HANDLE_VALUE ) {

        Success = GetFilePatchSignatureByHandle(
                      FileHandle,
                      OptionFlags,
                      OptionData,
                      IgnoreRangeCount,
                      IgnoreRangeArray,
                      RetainRangeCount,
                      RetainRangeArray,
                      sizeof( AnsiSignatureBuffer ),
                      AnsiSignatureBuffer
                      );

        if ( Success ) {

            //
            //  Worst case growth from ANSI to UNICODE is 2X.
            //

            if (( SignatureBufferSizeInBytes / 2 ) < ( strlen( AnsiSignatureBuffer ) + 1 )) {
                SetLastError( ERROR_INSUFFICIENT_BUFFER );
                Success = FALSE;
                }

            else {

                Converted = MultiByteToWideChar(
                                CP_ACP,
                                MB_PRECOMPOSED,
                                AnsiSignatureBuffer,
                                -1,
                                SignatureBuffer,
                                SignatureBufferSizeInBytes / 2
                                );

                Success = Converted ? TRUE : FALSE;
                }
            }

        CloseHandle( FileHandle );
        }

    return Success;
    }


BOOL
PATCHAPI
GetFilePatchSignatureByHandle(
    IN  HANDLE  FileHandle,
    IN  ULONG   OptionFlags,
    IN  PVOID   OptionData,
    IN  ULONG   IgnoreRangeCount,
    IN  PPATCH_IGNORE_RANGE IgnoreRangeArray,
    IN  ULONG   RetainRangeCount,
    IN  PPATCH_RETAIN_RANGE RetainRangeArray,
    IN  ULONG   SignatureBufferSize,
    OUT PVOID   SignatureBuffer
    )
    {
    PVOID FileMapped;
    ULONG FileSize;
    ULONG FileCrc;
    MD5_HASH FileMD5;
    BOOL  Success;

    Success = MyMapViewOfFileByHandle(
                  FileHandle,
                  &FileSize,
                  &FileMapped
                  );

    if ( Success ) {

        //
        //  Note that we must normalize to a fixed known rebase address,
        //  so the CRC from this might be different than the OldFileCrc
        //  in a patch header that is specific to a new file's rebase
        //  address.  Note that if PATCH_OPTION_NO_REBASE is specified
        //  then the rebase address is ignored.
        //

        Success = NormalizeOldFileImageForPatching(
                      FileMapped,
                      FileSize,
                      OptionFlags,
                      OptionData,
                      0x10000000,           // non-zero fixed coff base
                      0x10000000,           // non-zero fixed coff time
                      IgnoreRangeCount,
                      IgnoreRangeArray,
                      RetainRangeCount,
                      RetainRangeArray
                      );

        if ( Success ) {

            if ( OptionFlags & PATCH_OPTION_SIGNATURE_MD5 ) {

                Success = SafeCompleteMD5(
                            FileMapped,
                            FileSize,
                            &FileMD5
                            );

                if ( Success ) {

                    if ( SignatureBufferSize < 33 ) {
                        SetLastError( ERROR_INSUFFICIENT_BUFFER );
                        Success = FALSE;
                        }

                    else {
                        HashToHexString( &FileMD5, ((LPSTR) SignatureBuffer ));
                        }
                    }
                }

            else {    // signature type is CRC-32

                Success = SafeCompleteCrc32(
                            FileMapped,
                            FileSize,
                            &FileCrc
                            );

                if ( Success ) {

                    if ( SignatureBufferSize < 9 ) {
                        SetLastError( ERROR_INSUFFICIENT_BUFFER );
                        Success = FALSE;
                        }

                    else {
                        DwordToHexString( FileCrc, (LPSTR) SignatureBuffer );
                        }
                    }
                }
            }

        UnmapViewOfFile( FileMapped );
        }

    if (( ! Success ) &&
        ( GetLastError() == ERROR_SUCCESS )) {

        SetLastError( ERROR_EXTENDED_ERROR );
        }

    return Success;
    }


#ifndef PATCH_APPLY_CODE_ONLY

VOID
ReduceRiftTable(
    IN PRIFT_TABLE RiftTable
    )
    {
    PRIFT_ENTRY RiftEntryArray = RiftTable->RiftEntryArray;
    PUCHAR      RiftUsageArray = RiftTable->RiftUsageArray;
    ULONG       RiftEntryCount = RiftTable->RiftEntryCount;
    LONG        CurrentDisplacement;
    LONG        ThisDisplacement;
    ULONG       i;

    //
    //  Essentially we want to remove the usage count from any entry where
    //  the preceding USED entry would produce the same rift displacement.
    //
    //  The first used entry should contain a non-zero displacement (any
    //  USED entries before that should be marked UNUSED because they will
    //  coast from zero).
    //

    CurrentDisplacement = 0;

    for ( i = 0; i < RiftEntryCount; i++ ) {

        if ( RiftUsageArray[ i ] != 0 ) {

            ThisDisplacement = RiftEntryArray[ i ].NewFileRva - RiftEntryArray[ i ].OldFileRva;

            if ( ThisDisplacement == CurrentDisplacement ) {
                RiftUsageArray[ i ] = 0;    // not needed
                }
            else {
                CurrentDisplacement = ThisDisplacement;
                }
            }
        }
    }

#endif // PATCH_APPLY_CODE_ONLY


BOOL
WINAPIV
TransformOldFileImageForPatching(
    IN OUT PULONG TransformOptions,
    IN OUT PVOID  OldFileMapped,
    IN     ULONG  OldFileSize,
    IN     ULONG  NewFileResTime,
    IN OUT PRIFT_TABLE RiftTable,
    ...
    )
    {
    PIMAGE_NT_HEADERS NtHeader;
    BOOL Success = TRUE;

    __try {

        NtHeader = GetNtHeader( OldFileMapped, OldFileSize );

        if ( NtHeader ) {

            *TransformOptions |= PATCH_TRANSFORM_ANY_PE;

            Success = TransformCoffImage(
                          TransformOptions,
                          NtHeader,
                          OldFileMapped,
                          OldFileSize,
                          NewFileResTime,
                          RiftTable,
                          NULL
                          );
            }

        else {

            //
            //  Other file type transformations could be performed here.
            //

            }

#ifndef PATCH_APPLY_CODE_ONLY

        if ( RiftTable->RiftUsageArray != NULL ) {

            ReduceRiftTable( RiftTable );

#ifdef TESTCODE

            {
            HANDLE hFile = CreateFile(
                               "ReducedRiftInfo.out",
                               GENERIC_WRITE,
                               FILE_SHARE_READ,
                               NULL,
                               CREATE_ALWAYS,
                               FILE_ATTRIBUTE_NORMAL,
                               NULL
                               );

            if ( hFile != INVALID_HANDLE_VALUE ) {

                CHAR  TextBuffer[ 24 ];
                DWORD Actual;
                ULONG i;

                for ( i = 0; i < RiftTable->RiftEntryCount; i++ ) {
                    if ( RiftTable->RiftUsageArray[ i ] != 0 ) {
                        sprintf( TextBuffer, "%08X %08X\r\n", RiftTable->RiftEntryArray[ i ].OldFileRva, RiftTable->RiftEntryArray[ i ].NewFileRva );
                        WriteFile( hFile, TextBuffer, 19, &Actual, NULL );
                        }
                    }

                CloseHandle( hFile );
                }
            }

#endif // TESTCODE

            }

#endif // PATCH_APPLY_CODE_ONLY

        }

    __except( EXCEPTION_EXECUTE_HANDLER ) {
        SetLastError( GetExceptionCode() );
        Success = FALSE;
        }

#ifdef TESTCODE

    //
    //  The following test-only code creates a file containing
    //  the modified coff image to verify that the coff image
    //  is really a valid coff image.  This is for debugging
    //  only.
    //

    if ( Success ) {

        HANDLE hFile = CreateFile(
                           "Transformed.out",
                           GENERIC_WRITE,
                           FILE_SHARE_READ,
                           NULL,
                           CREATE_ALWAYS,
                           FILE_ATTRIBUTE_NORMAL,
                           NULL
                           );

        if ( hFile != INVALID_HANDLE_VALUE ) {

            DWORD Actual;

            WriteFile( hFile, OldFileMapped, OldFileSize, &Actual, NULL );

            CloseHandle( hFile );

            }
        }

#endif // TESTCODE

    return Success;
    }


PUCHAR
__fastcall
VariableLengthUnsignedDecode(
    IN  PUCHAR Buffer,
    OUT PULONG ReturnValue
    )
    {
    PUCHAR p = Buffer;
    ULONG Value = 0;
    ULONG Shift = 0;

    do  {
        Value |= (( *p & 0x7F ) << Shift );
        Shift += 7;
        }
    while (( ! ( *p++ & 0x80 )) && ( Shift < 32 ));

    *ReturnValue = Value;

    return p;
    }


PUCHAR
__fastcall
VariableLengthSignedDecode(
    IN  PUCHAR Buffer,
    OUT PLONG  ReturnValue
    )
    {
    PUCHAR p = Buffer;
    ULONG Shift;
    LONG  Value;

    Value = *p & 0x3F;
    Shift = 6;

    if ( ! ( *p++ & 0x80 )) {
        do  {
            Value |= (( *p & 0x7F ) << Shift );
            Shift += 7;
            }
        while (( ! ( *p++ & 0x80 )) && ( Shift < 32 ));
        }

    if ( *Buffer & 0x40 ) {
        Value = -Value;
        }

    *ReturnValue = Value;

    return p;
    }


UCHAR
PatchVersion(
    IN ULONG PatchSignature
    )
    {
    union {
        ULONG Signature;
        UCHAR Byte[ 4 ];
        } u;

    u.Signature = PatchSignature;

    if (( u.Byte[ 0 ] == 'P' ) && ( u.Byte[ 1 ] == 'A' ) &&
        ( u.Byte[ 2 ] >= '0' ) && ( u.Byte[ 2 ] <= '9' ) &&
        ( u.Byte[ 3 ] >= '0' ) && ( u.Byte[ 3 ] <= '9' )) {

        return (UCHAR)(( u.Byte[ 2 ] - '0' ) * 10 + ( u.Byte[ 3 ] - '0' ));
        }

    return 0;
    }


BOOL
DecodePatchHeader(
    IN  PVOID               PatchHeader,
    IN  ULONG               PatchHeaderMaxSize,
    IN  HANDLE              SubAllocator,
    OUT PULONG              PatchHeaderActualSize,
    OUT PPATCH_HEADER_INFO *HeaderInfo
    )
    {
    PHEADER_OLD_FILE_INFO OldFileInfo;
    PPATCH_HEADER_INFO Header;
    ULONG  i, j;
    LONG   Delta;
    LONG   DeltaNew;
    ULONG  DeltaPos;
    ULONG  Length;
    ULONG  PreviousOffset;
    ULONG  PreviousOldRva;
    ULONG  PreviousNewRva;
    ULONG  OldFileCount;
    BOOL   Success;
    PUCHAR p;

    //
    //  A couple of implementation notes here.  The PatchHeaderMaxSize
    //  value does NOT guarantee that we won't try to read beyond that
    //  memory address in this routine.  This routine should be called
    //  under try/except to trap the case where we walk off the end of
    //  a corrupt patch header.  The PatchHeaderMaxSize is just a helper
    //  value that lets us know if we did have a corrupt header in the
    //  case where we walked too far but not off the end of the page.
    //

    Success = FALSE;

    p = PatchHeader;

    Header = SubAllocate( SubAllocator, sizeof( PATCH_HEADER_INFO ));

    //
    //  SubAllocate provides zeroed memory.
    //

    if ( Header != NULL ) {

        __try {

            Header->Signature = *(UNALIGNED ULONG *)( p );
            p += sizeof( ULONG );

            if ( Header->Signature != PATCH_SIGNATURE ) {
                if ( PatchVersion( Header->Signature ) > PatchVersion( PATCH_SIGNATURE )) {
                    SetLastError( ERROR_PATCH_NEWER_FORMAT );
                    }
                else {
                    SetLastError( ERROR_PATCH_CORRUPT );
                    }
                __leave;
                }

            Header->OptionFlags = *(UNALIGNED ULONG *)( p );
            p += sizeof( ULONG );

            //
            //  The PATCH_OPTION_NO_TIMESTAMP flag is stored inverse for
            //  backward compatibility, so flip it back here.
            //

            Header->OptionFlags ^= PATCH_OPTION_NO_TIMESTAMP;

            //
            //  Now check for invalid flags.
            //

            if ( Header->OptionFlags & ~PATCH_OPTION_VALID_FLAGS ) {
                SetLastError( ERROR_PATCH_CORRUPT );
                __leave;
                }

            //
            //  If the PATCH_OPTION_EXTENDED_OPTIONS flag is set, the next
            //  4 bytes is the ExtendedOptionFlags value.
            //

            if ( Header->OptionFlags & PATCH_OPTION_EXTENDED_OPTIONS ) {

                Header->ExtendedOptionFlags = *(UNALIGNED ULONG *)( p );
                p += sizeof( ULONG );
                }

            if ( ! ( Header->OptionFlags & PATCH_OPTION_NO_TIMESTAMP )) {

                Header->NewFileTime = *(UNALIGNED ULONG *)( p );
                p += sizeof( ULONG );
                }

            if ( ! ( Header->OptionFlags & PATCH_OPTION_NO_REBASE )) {

                Header->NewFileCoffBase = ((ULONG)*(UNALIGNED USHORT *)( p )) << 16;
                p += sizeof( USHORT );

                ASSERT( Header->NewFileCoffBase != 0 );

                //
                //  If NewFileTime is nonzero, CoffTime is stored as a signed
                //  delta from NewFileTime since they are usually very close.
                //  If NewFileTime is zero, CoffTime is encoded as a ULONG.
                //

                if ( Header->NewFileTime != 0 ) {

                    p = VariableLengthSignedDecode( p, &Delta );
                    Header->NewFileCoffTime = Header->NewFileTime - Delta;
                    }

                else {

                    Header->NewFileCoffTime = *(UNALIGNED ULONG *)( p );
                    p += sizeof( ULONG );
                    }
                }

            if ( ! ( Header->OptionFlags & PATCH_OPTION_NO_RESTIMEFIX )) {

                //
                //  If NewFileCoffTime is nonzero, ResTime is stored as a
                //  signed delta from NewFileCoffTime since they are usually
                //  very close.  If NewFileCoffTime is zero, ResTime is
                //  encoded as a ULONG.
                //

                if ( Header->NewFileCoffTime != 0 ) {

                    p = VariableLengthSignedDecode( p, &Delta );
                    Header->NewFileResTime = Header->NewFileCoffTime - Delta;
                    }

                else {

                    Header->NewFileResTime = *(UNALIGNED ULONG *)( p );
                    p += sizeof( ULONG );
                    }
                }

            p = VariableLengthUnsignedDecode( p, &Header->NewFileSize );

            Header->NewFileCrc = *(UNALIGNED ULONG *)( p );
            p += sizeof( ULONG );

            if ( Header->ExtendedOptionFlags & PATCH_OPTION_SPECIFIED_WINDOW ) {

                BYTE ShiftCount = *p++;
                Header->WindowSize = 1UL << ShiftCount;
                }

            Header->OldFileCount = OldFileCount = *p++;

            Header->OldFileInfoArray = SubAllocate( SubAllocator, OldFileCount * sizeof( HEADER_OLD_FILE_INFO ));

            if ( Header->OldFileInfoArray == NULL ) {
                __leave;
                }

            if ( Header->OptionFlags & PATCH_OPTION_INTERLEAVE_FILES ) {

                Header->InterleaveMapArray = SubAllocate( SubAllocator, OldFileCount * sizeof( PVOID ));

                if ( Header->InterleaveMapArray == NULL ) {
                    __leave;
                    }
                }

            for ( i = 0; i < OldFileCount; i++ ) {

                OldFileInfo = &Header->OldFileInfoArray[ i ];

                p = VariableLengthSignedDecode( p, &Delta );

                if ((LONG)( Header->NewFileSize + Delta ) < 0 ) {
                    SetLastError( ERROR_PATCH_CORRUPT );
                    __leave;
                    }

                OldFileInfo->OldFileSize = Header->NewFileSize + Delta;

                OldFileInfo->OldFileCrc = *(UNALIGNED ULONG *)( p );
                p += sizeof( ULONG );

                OldFileInfo->IgnoreRangeCount = *p++;

                if ( OldFileInfo->IgnoreRangeCount != 0 ) {

                    OldFileInfo->IgnoreRangeArray = SubAllocate( SubAllocator, OldFileInfo->IgnoreRangeCount * sizeof( PATCH_IGNORE_RANGE ));

                    if ( OldFileInfo->IgnoreRangeArray == NULL ) {
                        __leave;
                        }

                    PreviousOffset = 0;

                    for ( j = 0; j < OldFileInfo->IgnoreRangeCount; j++ ) {

                        p = VariableLengthSignedDecode( p, &Delta );
                        p = VariableLengthUnsignedDecode( p, &Length );

                        OldFileInfo->IgnoreRangeArray[ j ].OffsetInOldFile = PreviousOffset + Delta;
                        OldFileInfo->IgnoreRangeArray[ j ].LengthInBytes = Length;

                        PreviousOffset = PreviousOffset + Delta + Length;

                        if ( PreviousOffset > OldFileInfo->OldFileSize ) {
                            SetLastError( ERROR_PATCH_CORRUPT );
                            __leave;
                            }
                        }
                    }

                OldFileInfo->RetainRangeCount = *p++;

                if ( OldFileInfo->RetainRangeCount != 0 ) {

                    OldFileInfo->RetainRangeArray = SubAllocate( SubAllocator, OldFileInfo->RetainRangeCount * sizeof( PATCH_RETAIN_RANGE ));

                    if ( OldFileInfo->RetainRangeArray == NULL ) {
                        __leave;
                        }

                    PreviousOffset = 0;

                    for ( j = 0; j < OldFileInfo->RetainRangeCount; j++ ) {

                        p = VariableLengthSignedDecode( p, &Delta );
                        p = VariableLengthSignedDecode( p, &DeltaNew );
                        p = VariableLengthUnsignedDecode( p, &Length );

                        OldFileInfo->RetainRangeArray[ j ].OffsetInOldFile = PreviousOffset + Delta;
                        OldFileInfo->RetainRangeArray[ j ].OffsetInNewFile = PreviousOffset + Delta + DeltaNew;
                        OldFileInfo->RetainRangeArray[ j ].LengthInBytes   = Length;

                        PreviousOffset = PreviousOffset + Delta + Length;

                        if (( PreviousOffset > OldFileInfo->OldFileSize ) ||
                            (( PreviousOffset + DeltaNew ) > Header->NewFileSize )) {
                            SetLastError( ERROR_PATCH_CORRUPT );
                            __leave;
                            }
                        }
                    }

                p = VariableLengthUnsignedDecode( p, &OldFileInfo->RiftTable.RiftEntryCount );

                if ( OldFileInfo->RiftTable.RiftEntryCount != 0 ) {

                    OldFileInfo->RiftTable.RiftEntryArray = SubAllocate( SubAllocator, OldFileInfo->RiftTable.RiftEntryCount * sizeof( RIFT_ENTRY ));

                    if ( OldFileInfo->RiftTable.RiftEntryArray == NULL ) {
                        __leave;
                        }

                    OldFileInfo->RiftTable.RiftUsageArray = NULL;

                    PreviousOldRva = 0;
                    PreviousNewRva = 0;

                    for ( j = 0; j < OldFileInfo->RiftTable.RiftEntryCount; j++ ) {

                        p = VariableLengthUnsignedDecode( p, &DeltaPos );
                        p = VariableLengthSignedDecode( p, &DeltaNew );

                        OldFileInfo->RiftTable.RiftEntryArray[ j ].OldFileRva = PreviousOldRva + DeltaPos;
                        OldFileInfo->RiftTable.RiftEntryArray[ j ].NewFileRva = PreviousNewRva + DeltaNew;

                        PreviousOldRva += DeltaPos;
                        PreviousNewRva += DeltaNew;
                        }
                    }

                if ( Header->OptionFlags & PATCH_OPTION_INTERLEAVE_FILES ) {

                    PPATCH_INTERLEAVE_MAP Imap;
                    ULONG CountRanges = 0;

                    p = VariableLengthUnsignedDecode( p, &CountRanges );

                    if ( CountRanges > 0 ) {

                        ULONG LastOldOffset = 0;
                        ULONG LastOldLength = 0;
                        ULONG LastNewLength = 0;
                        LONG  LastDeltaOldOffset = 0;
                        LONG  LastDeltaOldLength = 0;
                        ULONG RemainingNew  = Header->NewFileSize;
                        ULONG AllocSize     = sizeof( PATCH_INTERLEAVE_MAP );

                        AllocSize += ( CountRanges - 1 ) * sizeof( Imap[ 0 ].Range[ 0 ] );

                        Imap = SubAllocate( SubAllocator, AllocSize );

                        if ( Imap == NULL ) {
                            __leave;
                            }

                        Imap->CountRanges = CountRanges;

                        for ( j = 0; j < CountRanges; j++ ) {

                            LONG DeltaDeltaOldOffset;
                            LONG DeltaDeltaOldLength;
                            LONG DeltaNewLength;

                            p = VariableLengthSignedDecode( p, &DeltaDeltaOldOffset );
                            p = VariableLengthSignedDecode( p, &DeltaDeltaOldLength );

                            LastDeltaOldOffset += DeltaDeltaOldOffset;
                            LastDeltaOldLength += DeltaDeltaOldLength;

                            LastOldLength  += LastDeltaOldLength;
                            LastOldOffset  += LastDeltaOldOffset;

                            Imap->Range[ j ].OldOffset = LastOldOffset;
                            Imap->Range[ j ].OldLength = LastOldLength;

                            ASSERT(( LastOldOffset + LastOldLength ) <= OldFileInfo->OldFileSize );

                            if ( j < ( CountRanges - 1 )) {

                                p = VariableLengthSignedDecode( p, &DeltaNewLength );

                                DeltaNewLength *= LZX_BLOCKSIZE;    // LZX specific

                                LastNewLength  += DeltaNewLength;

                                Imap->Range[ j ].NewLength = LastNewLength;

                                ASSERT( RemainingNew > LastNewLength );

                                RemainingNew -= LastNewLength;

                                }

                            else {

                                Imap->Range[ j ].NewLength = RemainingNew;

                                }
                            }

                        Header->InterleaveMapArray[ i ] = Imap;
                        }
                    }

                p = VariableLengthUnsignedDecode( p, &OldFileInfo->PatchDataSize );
                }

            if ( p > ((PUCHAR)PatchHeader + PatchHeaderMaxSize )) {
                SetLastError( ERROR_PATCH_CORRUPT );
                __leave;
                }

            Success = TRUE;
            }

        __except( EXCEPTION_EXECUTE_HANDLER ) {
            SetLastError( ERROR_PATCH_CORRUPT );
            Success = FALSE;
            }
        }

    if ( Success ) {

        if ( PatchHeaderActualSize ) {
            *PatchHeaderActualSize = p - (PUCHAR)PatchHeader;
            }

        if ( HeaderInfo ) {
            *HeaderInfo = Header;
            }
        }

    return Success;
    }


//
//  Following group of functions and exported apis are exclusively for
//  creating patches.  If we're only compiling the apply code, ignore
//  this group of functions.
//

#ifndef PATCH_APPLY_CODE_ONLY

PUCHAR
__fastcall
VariableLengthUnsignedEncode(
    OUT PUCHAR Buffer,
    IN  ULONG  Value
    )
    {
    UCHAR Byte = (UCHAR)( Value & 0x7F );       // low order 7 bits

    Value >>= 7;

    while ( Value ) {

        *Buffer++ = Byte;

        Byte = (UCHAR)( Value & 0x7F );         // next 7 higher order bits

        Value >>= 7;

        }

    *Buffer++ = (UCHAR)( Byte | 0x80 );

    return Buffer;
    }


PUCHAR
__fastcall
VariableLengthSignedEncode(
    OUT PUCHAR Buffer,
    IN  LONG   Value
    )
    {
    UCHAR Byte;

    if ( Value < 0 ) {
        Value = -Value;
        Byte = (UCHAR)(( Value & 0x3F ) | 0x40 );
        }
    else {
        Byte = (UCHAR)( Value & 0x3F );
        }

    Value >>= 6;

    while ( Value ) {

        *Buffer++ = Byte;

        Byte = (UCHAR)( Value & 0x7F );         // next 7 higher order bits

        Value >>= 7;

        }

    *Buffer++ = (UCHAR)( Byte | 0x80 );

    return Buffer;
    }


ULONG
EncodePatchHeader(
    IN  PPATCH_HEADER_INFO HeaderInfo,
    OUT PVOID              PatchHeaderBuffer
    )
    {
    PHEADER_OLD_FILE_INFO OldFileInfo;
    ULONG  i, j;
    LONG   Delta;
    ULONG  PreviousOffset;
    ULONG  PreviousOldRva;
    ULONG  PreviousNewRva;
    ULONG  ActiveRiftCount;

    PUCHAR p = PatchHeaderBuffer;

#ifdef TESTCODE
    PUCHAR q;
#endif // TESTCODE

    ASSERT( HeaderInfo->Signature == PATCH_SIGNATURE );
    ASSERT((( HeaderInfo->OptionFlags & ~PATCH_OPTION_VALID_FLAGS      ) == 0 ));
    ASSERT((( HeaderInfo->OptionFlags &  PATCH_OPTION_EXTENDED_OPTIONS ) != 0 ) == ( HeaderInfo->ExtendedOptionFlags != 0 ));
    ASSERT((( HeaderInfo->OptionFlags &  PATCH_OPTION_NO_TIMESTAMP     ) == 0 ) == ( HeaderInfo->NewFileTime         != 0 ));
    ASSERT((( HeaderInfo->OptionFlags &  PATCH_OPTION_NO_REBASE        ) == 0 ) == ( HeaderInfo->NewFileCoffBase     != 0 ));
    ASSERT((( HeaderInfo->OptionFlags &  PATCH_OPTION_NO_REBASE        ) == 0 ) == ( HeaderInfo->NewFileCoffTime     != 0 ));
    ASSERT((( HeaderInfo->OptionFlags &  PATCH_OPTION_NO_RESTIMEFIX    ) == 0 ) == ( HeaderInfo->NewFileResTime      != 0 ));
    ASSERT((( HeaderInfo->ExtendedOptionFlags & PATCH_OPTION_SPECIFIED_WINDOW ) == 0 ) == ( HeaderInfo->WindowSize == 0 ));

    if ( HeaderInfo->OptionFlags & PATCH_OPTION_INTERLEAVE_FILES ) {
        ASSERT( HeaderInfo->InterleaveMapArray != NULL );
        }

    *(UNALIGNED ULONG *)( p ) = HeaderInfo->Signature;
    p += sizeof( ULONG );

    //
    //  The PATCH_OPTION_NO_TIMESTAMP flag is stored inverse for
    //  backward compatibility, so flip it when storing it here.
    //

    *(UNALIGNED ULONG *)( p ) = ( HeaderInfo->OptionFlags ^ PATCH_OPTION_NO_TIMESTAMP );
    p += sizeof( ULONG );

    //
    //  If the PATCH_OPTION_EXTENDED_OPTIONS flag is set, the next
    //  4 bytes is the ExtendedOptionFlags value.
    //

    if ( HeaderInfo->OptionFlags & PATCH_OPTION_EXTENDED_OPTIONS ) {

        *(UNALIGNED ULONG *)( p ) = HeaderInfo->ExtendedOptionFlags;
        p += sizeof( ULONG );
        }

    if ( ! ( HeaderInfo->OptionFlags & PATCH_OPTION_NO_TIMESTAMP )) {

        *(UNALIGNED ULONG *)( p ) = HeaderInfo->NewFileTime;
        p += sizeof( ULONG );
        }

    if ( ! ( HeaderInfo->OptionFlags & PATCH_OPTION_NO_REBASE )) {

        ASSERT(( HeaderInfo->NewFileCoffBase >> 16 ) != 0 );

        *(UNALIGNED USHORT *)( p ) = (USHORT)( HeaderInfo->NewFileCoffBase >> 16 );
        p += sizeof( USHORT );

        //
        //  If NewFileTime is nonzero, CoffTime is stored as a signed
        //  delta from NewFileTime since they are usually very close.
        //  If NewFileTime is zero, CoffTime is encoded as a ULONG.
        //

        if ( HeaderInfo->NewFileTime != 0 ) {

            Delta = HeaderInfo->NewFileTime - HeaderInfo->NewFileCoffTime;
            p = VariableLengthSignedEncode( p, Delta );
            }

        else {

            *(UNALIGNED ULONG *)( p ) = HeaderInfo->NewFileCoffTime;
            p += sizeof( ULONG );
            }
        }

    if ( ! ( HeaderInfo->OptionFlags & PATCH_OPTION_NO_RESTIMEFIX )) {

        //
        //  If NewFileCoffTime is nonzero, ResTime is stored as a
        //  signed delta from NewFileCoffTime since they are usually
        //  very close.  If NewFileCoffTime is zero, ResTime is
        //  encoded as a ULONG.
        //

        if ( HeaderInfo->NewFileCoffTime != 0 ) {

            Delta = HeaderInfo->NewFileCoffTime - HeaderInfo->NewFileResTime;
            p = VariableLengthSignedEncode( p, Delta );
            }

        else {

            *(UNALIGNED ULONG *)( p ) = HeaderInfo->NewFileResTime;
            p += sizeof( ULONG );
            }
        }

    p = VariableLengthUnsignedEncode( p, HeaderInfo->NewFileSize );

    *(UNALIGNED ULONG *)( p ) = HeaderInfo->NewFileCrc;
    p += sizeof( ULONG );

    if ( HeaderInfo->ExtendedOptionFlags & PATCH_OPTION_SPECIFIED_WINDOW ) {

        ULONG WindowSize = HeaderInfo->WindowSize;
        ULONG ShiftCount = 0;

        ASSERT( WindowSize != 0 );
        ASSERT( WindowSize >= LZX_MINWINDOW );
        ASSERT( WindowSize <= LZX_MAXWINDOW_32 );
        ASSERT(( WindowSize % LZX_BLOCKSIZE ) == 0 );
        ASSERT(( WindowSize & ( WindowSize - 1 )) == 0 );

        while (( 1UL << ShiftCount ) < WindowSize ) {
            ++ShiftCount;
            }

        *p++ = (BYTE) ShiftCount;

#ifdef TESTCODE

        printf( "\rEncoded LZX window size %u (0x%X) as 1<<%u\n", WindowSize, WindowSize, ShiftCount );

#endif // TESTCODE

        }

    ASSERT( HeaderInfo->OldFileCount < 256 );

    *p++ = (UCHAR)( HeaderInfo->OldFileCount );

    for ( i = 0; i < HeaderInfo->OldFileCount; i++ ) {

        OldFileInfo = &HeaderInfo->OldFileInfoArray[ i ];

        Delta = OldFileInfo->OldFileSize - HeaderInfo->NewFileSize;
        p = VariableLengthSignedEncode( p, Delta );

        *(UNALIGNED ULONG *)( p ) = OldFileInfo->OldFileCrc;
        p += sizeof( ULONG );

        ASSERT( OldFileInfo->IgnoreRangeCount < 256 );

        *p++ = (UCHAR)( OldFileInfo->IgnoreRangeCount );

        PreviousOffset = 0;

        for ( j = 0; j < OldFileInfo->IgnoreRangeCount; j++ ) {

            Delta = OldFileInfo->IgnoreRangeArray[ j ].OffsetInOldFile - PreviousOffset;

            PreviousOffset = OldFileInfo->IgnoreRangeArray[ j ].OffsetInOldFile +
                             OldFileInfo->IgnoreRangeArray[ j ].LengthInBytes;

            ASSERT( PreviousOffset <= OldFileInfo->OldFileSize );

            p = VariableLengthSignedEncode( p, Delta );

            p = VariableLengthUnsignedEncode( p, OldFileInfo->IgnoreRangeArray[ j ].LengthInBytes );
            }

        ASSERT( OldFileInfo->RetainRangeCount < 256 );

        *p++ = (UCHAR)( OldFileInfo->RetainRangeCount );

        PreviousOffset = 0;

        for ( j = 0; j < OldFileInfo->RetainRangeCount; j++ ) {

            Delta = OldFileInfo->RetainRangeArray[ j ].OffsetInOldFile - PreviousOffset;

            PreviousOffset = OldFileInfo->RetainRangeArray[ j ].OffsetInOldFile +
                             OldFileInfo->RetainRangeArray[ j ].LengthInBytes;

            ASSERT( PreviousOffset <= OldFileInfo->OldFileSize );

            p = VariableLengthSignedEncode( p, Delta );

            Delta = OldFileInfo->RetainRangeArray[ j ].OffsetInNewFile -
                    OldFileInfo->RetainRangeArray[ j ].OffsetInOldFile;

            p = VariableLengthSignedEncode( p, Delta );

            p = VariableLengthUnsignedEncode( p, OldFileInfo->RetainRangeArray[ j ].LengthInBytes );
            }

        if ( OldFileInfo->RiftTable.RiftUsageArray == NULL ) {

            ActiveRiftCount = OldFileInfo->RiftTable.RiftEntryCount;
            }

        else {

            ActiveRiftCount = 0;

            for ( j = 0; j < OldFileInfo->RiftTable.RiftEntryCount; j++ ) {
                if ( OldFileInfo->RiftTable.RiftUsageArray[ j ] ) {
                    ++ActiveRiftCount;
                    }
                }
            }

#ifdef TESTCODE2

        fprintf( stderr, "\n\n" );

#endif // TESTCODE2

#ifdef TESTCODE

        q = p;

#endif // TESTCODE

        if (( OldFileInfo->RiftTable.RiftEntryCount ) && ( ActiveRiftCount == 0 )) {

            //
            //  This is a special case.  We have a rift table but didn't use
            //  any entries during transformation.  This can happen if all the
            //  rifts coast to zero for extremely similar files.  If we encode
            //  the rift count as zero, no transformations will be performed
            //  during patch apply.  To prevent that, we'll encode one rift of
            //  0,0 which is usually just the implied initial rift.
            //

            ActiveRiftCount = 1;

            p = VariableLengthUnsignedEncode( p, ActiveRiftCount );
            p = VariableLengthUnsignedEncode( p, 0 );
            p = VariableLengthSignedEncode(   p, 0 );

            }

        else {

            p = VariableLengthUnsignedEncode( p, ActiveRiftCount );

            PreviousOldRva = 0;
            PreviousNewRva = 0;

            for ( j = 0; j < OldFileInfo->RiftTable.RiftEntryCount; j++ ) {

                if (( OldFileInfo->RiftTable.RiftUsageArray == NULL ) ||
                    ( OldFileInfo->RiftTable.RiftUsageArray[ j ] )) {

#ifdef TESTCODE2
                    fprintf( stderr, "%9X ", OldFileInfo->RiftTable.RiftEntryArray[ j ].OldFileRva );
                    fprintf( stderr, "%9X ", OldFileInfo->RiftTable.RiftEntryArray[ j ].NewFileRva );
#endif // TESTCODE2

                    Delta = OldFileInfo->RiftTable.RiftEntryArray[ j ].OldFileRva - PreviousOldRva;

                    ASSERT( Delta > 0 );    // sorted by OldFileRva

#ifdef TESTCODE2
                    fprintf( stderr, "%9d ", Delta );

#endif // TESTCODE2

                    PreviousOldRva = OldFileInfo->RiftTable.RiftEntryArray[ j ].OldFileRva;

                    p = VariableLengthUnsignedEncode( p, Delta );

                    Delta = OldFileInfo->RiftTable.RiftEntryArray[ j ].NewFileRva - PreviousNewRva;

#ifdef TESTCODE2
                    fprintf( stderr, "%9d\n", Delta );
#endif // TESTCODE2

                    PreviousNewRva = OldFileInfo->RiftTable.RiftEntryArray[ j ].NewFileRva;

                    p = VariableLengthSignedEncode( p, Delta );
                    }
                }
            }

#ifdef TESTCODE

        if ( ActiveRiftCount > 0 ) {
            printf( "\r%9d rifts encoded in %d bytes (%.1f bytes per rift)\n", ActiveRiftCount, p - q, ((double)( p - q ) / ActiveRiftCount ));
            }

#endif // TESTCODE

        if ( HeaderInfo->OptionFlags & PATCH_OPTION_INTERLEAVE_FILES ) {

#ifdef TESTCODE
            q = p;
#endif
            if (( HeaderInfo->InterleaveMapArray      != NULL ) &&
                ( HeaderInfo->InterleaveMapArray[ i ] != NULL ) &&
                ( HeaderInfo->InterleaveMapArray[ i ]->CountRanges != 0 )) {

                PPATCH_INTERLEAVE_MAP Imap = HeaderInfo->InterleaveMapArray[ i ];

                ULONG LastOldOffset = 0;
                ULONG LastOldLength = 0;
                ULONG LastNewLength = 0;

                LONG  LastDeltaOldOffset = 0;
                LONG  LastDeltaOldLength = 0;

                p = VariableLengthUnsignedEncode( p, Imap->CountRanges );

                for ( j = 0; j < Imap->CountRanges; j++ ) {

                    LONG DeltaOldOffset = Imap->Range[ j ].OldOffset - LastOldOffset;
                    LONG DeltaOldLength = Imap->Range[ j ].OldLength - LastOldLength;
                    LONG DeltaNewLength = Imap->Range[ j ].NewLength - LastNewLength;

                    LONG DeltaDeltaOldOffset = DeltaOldOffset - LastDeltaOldOffset;
                    LONG DeltaDeltaOldLength = DeltaOldLength - LastDeltaOldLength;

                    p = VariableLengthSignedEncode( p, DeltaDeltaOldOffset );
                    p = VariableLengthSignedEncode( p, DeltaDeltaOldLength );

                    if ( j < ( Imap->CountRanges - 1 )) {

                        ASSERT(( DeltaNewLength % LZX_BLOCKSIZE ) == 0 );

                        DeltaNewLength /= LZX_BLOCKSIZE;

                        p = VariableLengthSignedEncode( p, DeltaNewLength );

                        }

                    LastDeltaOldOffset = DeltaOldOffset;
                    LastDeltaOldLength = DeltaOldLength;

                    LastOldOffset = Imap->Range[ j ].OldOffset;
                    LastOldLength = Imap->Range[ j ].OldLength;
                    LastNewLength = Imap->Range[ j ].NewLength;
                    }

#ifdef TESTCODE
                printf( "\rInterleave map encoded in %u bytes\n", p - q );
#endif
                }

            else {

                p = VariableLengthUnsignedEncode( p, 0 );

                }
            }

        p = VariableLengthUnsignedEncode( p, OldFileInfo->PatchDataSize );
        }

    return (ULONG)( p - (PUCHAR) PatchHeaderBuffer );
    }


BOOL
PATCHAPI
CreatePatchFileA(
    IN  LPCSTR OldFileName,
    IN  LPCSTR NewFileName,
    OUT LPCSTR PatchFileName,
    IN  ULONG  OptionFlags,
    IN  PPATCH_OPTION_DATA OptionData   // optional
    )
    {
    PATCH_OLD_FILE_INFO_A OldFileInfo = {
                              sizeof( PATCH_OLD_FILE_INFO_A ),
                              OldFileName,
                              0,
                              NULL,
                              0,
                              NULL
                              };

    return CreatePatchFileExA(
               1,
               &OldFileInfo,
               NewFileName,
               PatchFileName,
               OptionFlags,
               OptionData,
               NULL,
               NULL
               );
    }


BOOL
PATCHAPI
CreatePatchFileW(
    IN  LPCWSTR OldFileName,
    IN  LPCWSTR NewFileName,
    OUT LPCWSTR PatchFileName,
    IN  ULONG   OptionFlags,
    IN  PPATCH_OPTION_DATA OptionData   // optional
    )
    {
    PATCH_OLD_FILE_INFO_W OldFileInfo = {
                              sizeof( PATCH_OLD_FILE_INFO_W ),
                              OldFileName,
                              0,
                              NULL,
                              0,
                              NULL
                              };

    return CreatePatchFileExW(
               1,
               &OldFileInfo,
               NewFileName,
               PatchFileName,
               OptionFlags,
               OptionData,
               NULL,
               NULL
               );
    }


BOOL
PATCHAPI
CreatePatchFileByHandles(
    IN  HANDLE OldFileHandle,
    IN  HANDLE NewFileHandle,
    OUT HANDLE PatchFileHandle,
    IN  ULONG  OptionFlags,
    IN  PPATCH_OPTION_DATA OptionData   // optional
    )
    {
    PATCH_OLD_FILE_INFO_H OldFileInfo = {
                              sizeof( PATCH_OLD_FILE_INFO_H ),
                              OldFileHandle,
                              0,
                              NULL,
                              0,
                              NULL
                              };

    return CreatePatchFileByHandlesEx(
               1,
               &OldFileInfo,
               NewFileHandle,
               PatchFileHandle,
               OptionFlags,
               OptionData,
               NULL,
               NULL
               );
    }


BOOL
PATCHAPI
CreatePatchFileExA(
    IN  ULONG                    OldFileCount,
    IN  PPATCH_OLD_FILE_INFO_A   OldFileInfoArray,
    IN  LPCSTR                   NewFileName,
    OUT LPCSTR                   PatchFileName,
    IN  ULONG                    OptionFlags,
    IN  PPATCH_OPTION_DATA       OptionData,            // optional
    IN  PPATCH_PROGRESS_CALLBACK ProgressCallback,
    IN  PVOID                    CallbackContext
    )
    {
    PPATCH_OLD_FILE_INFO_H OldFileInfoByHandle;
    HANDLE PatchFileHandle;
    HANDLE NewFileHandle;
    BOOL   Success;
    ULONG  i;

    if (( OldFileCount == 0 ) || ( OldFileCount > 127 )) {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
        }

    OldFileInfoByHandle =   _alloca( OldFileCount * sizeof( PATCH_OLD_FILE_INFO_H ));
    ZeroMemory( OldFileInfoByHandle, OldFileCount * sizeof( PATCH_OLD_FILE_INFO_H ));

    Success = TRUE;

    for ( i = 0; i < OldFileCount; i++ ) {

        OldFileInfoByHandle[ i ].SizeOfThisStruct = sizeof( PATCH_OLD_FILE_INFO_H );
        OldFileInfoByHandle[ i ].IgnoreRangeCount = OldFileInfoArray[ i ].IgnoreRangeCount;
        OldFileInfoByHandle[ i ].IgnoreRangeArray = OldFileInfoArray[ i ].IgnoreRangeArray;
        OldFileInfoByHandle[ i ].RetainRangeCount = OldFileInfoArray[ i ].RetainRangeCount;
        OldFileInfoByHandle[ i ].RetainRangeArray = OldFileInfoArray[ i ].RetainRangeArray;

        if ( OldFileInfoArray[ i ].OldFileName == NULL ) {

            if ( OldFileCount != 1 ) {
                SetLastError( ERROR_INVALID_PARAMETER );
                Success = FALSE;
                break;
                }

            OldFileInfoByHandle[ i ].OldFileHandle = INVALID_HANDLE_VALUE;
            }
        else {

            OldFileInfoByHandle[ i ].OldFileHandle = CreateFileA(
                                                         OldFileInfoArray[ i ].OldFileName,
                                                         GENERIC_READ,
                                                         FILE_SHARE_READ | FILE_SHARE_WRITE,
                                                         NULL,
                                                         OPEN_EXISTING,
                                                         FILE_FLAG_SEQUENTIAL_SCAN,
                                                         NULL
                                                         );

            if ( OldFileInfoByHandle[ i ].OldFileHandle == INVALID_HANDLE_VALUE ) {
                Success = FALSE;
                break;
                }
            }
        }

    if ( Success ) {

        Success = FALSE;

        NewFileHandle = CreateFileA(
                            NewFileName,
                            GENERIC_READ,
                            FILE_SHARE_READ | FILE_SHARE_WRITE,
                            NULL,
                            OPEN_EXISTING,
                            FILE_FLAG_SEQUENTIAL_SCAN,
                            NULL
                            );

        if ( NewFileHandle != INVALID_HANDLE_VALUE ) {

            PatchFileHandle = CreateFileA(
                                  PatchFileName,
                                  GENERIC_READ | GENERIC_WRITE,
                                  FILE_SHARE_READ,
                                  NULL,
                                  CREATE_ALWAYS,
                                  FILE_ATTRIBUTE_NORMAL,
                                  NULL
                                  );

            if ( PatchFileHandle != INVALID_HANDLE_VALUE ) {

                Success = CreatePatchFileByHandlesEx(
                              OldFileCount,
                              OldFileInfoByHandle,
                              NewFileHandle,
                              PatchFileHandle,
                              OptionFlags,
                              OptionData,
                              ProgressCallback,
                              CallbackContext
                              );

                CloseHandle( PatchFileHandle );

                if ( ! Success ) {
                    DeleteFileA( PatchFileName );
                    }
                }

            CloseHandle( NewFileHandle );
            }
        }

    for ( i = 0; i < OldFileCount; i++ ) {
        if (( OldFileInfoByHandle[ i ].OldFileHandle != NULL ) &&
            ( OldFileInfoByHandle[ i ].OldFileHandle != INVALID_HANDLE_VALUE )) {

            CloseHandle( OldFileInfoByHandle[ i ].OldFileHandle );
            }
        }

    return Success;
    }


BOOL
PATCHAPI
CreatePatchFileExW(
    IN  ULONG                    OldFileCount,
    IN  PPATCH_OLD_FILE_INFO_W   OldFileInfoArray,
    IN  LPCWSTR                  NewFileName,
    OUT LPCWSTR                  PatchFileName,
    IN  ULONG                    OptionFlags,
    IN  PPATCH_OPTION_DATA       OptionData,            // optional
    IN  PPATCH_PROGRESS_CALLBACK ProgressCallback,
    IN  PVOID                    CallbackContext
    )
    {
    PPATCH_OLD_FILE_INFO_H OldFileInfoByHandle;
    HANDLE PatchFileHandle;
    HANDLE NewFileHandle;
    BOOL   Success;
    ULONG  i;

    if (( OldFileCount == 0 ) || ( OldFileCount > 127 )) {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
        }

    OldFileInfoByHandle =   _alloca( OldFileCount * sizeof( PATCH_OLD_FILE_INFO_H ));
    ZeroMemory( OldFileInfoByHandle, OldFileCount * sizeof( PATCH_OLD_FILE_INFO_H ));

    Success = TRUE;

    for ( i = 0; i < OldFileCount; i++ ) {

        OldFileInfoByHandle[ i ].SizeOfThisStruct = sizeof( PATCH_OLD_FILE_INFO_H );
        OldFileInfoByHandle[