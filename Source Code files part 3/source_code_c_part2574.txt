upBits );
				m_pTimeline->AddToNotifyList( (IDMUSProdStripMgr *)this, GUID_Sequence_Color_Change, m_dwGroupBits );
				m_pTimeline->AddToNotifyList( (IDMUSProdStripMgr *)this, GUID_Segment_AllTracksAdded, m_dwGroupBits );
				m_pTimeline->AddToNotifyList( (IDMUSProdStripMgr *)this, GUID_TimeSignature, m_dwGroupBits );
				m_pTimeline->AddToNotifyList( (IDMUSProdStripMgr *)this, GUID_Segment_RecordButton, m_dwGroupBits );
				m_pTimeline->AddToNotifyList( (IDMUSProdStripMgr *)this, GUID_Segment_WindowActive, m_dwGroupBits );
				m_pTimeline->AddToNotifyList( (IDMUSProdStripMgr *)this, GUID_Segment_Start, m_dwGroupBits );
				m_pTimeline->AddToNotifyList( (IDMUSProdStripMgr *)this, GUID_Segment_Stop, m_dwGroupBits );
				m_pTimeline->AddToNotifyList( (IDMUSProdStripMgr *)this, GUID_ChordSharpsFlats, m_dwGroupBits );
				m_pTimeline->AddToNotifyList( (IDMUSProdStripMgr *)this, GUID_ChordKey, m_dwGroupBits );
				m_pTimeline->AddToNotifyList( (IDMUSProdStripMgr *)this, GUID_Segment_PickupLength, m_dwGroupBits );
				m_pTimeline->AddToNotifyList( (IDMUSProdStripMgr *)this, GUID_Segment_ExtensionLength, m_dwGroupBits );

				// Make sure there is a curve strip for each type of Curve in this sequence
				m_pSequenceStrip->SyncCurveStripStateList();

				// Initialize the Sequence Strip's UI data
				m_pSequenceStrip->ApplyUIChunk( &m_SeqStripDesign );
			}
		}
		break;

	case SMP_IDIRECTMUSICTRACK:
		if( variant.vt != VT_UNKNOWN )
		{
			return E_INVALIDARG;
		}
		if( m_pIDMTrack )
		{
			m_pIDMTrack->Release();
		}
		if( V_UNKNOWN( &variant ) )
		{
			V_UNKNOWN( &variant )->QueryInterface( IID_IDirectMusicTrack, (void**)&m_pIDMTrack );
		}
		else
		{
			m_pIDMTrack = NULL;
		}
		break;

	case SMP_IDMUSPRODFRAMEWORK:
		if( variant.vt != VT_UNKNOWN )
		{
			return E_INVALIDARG;
		}
		if( m_pDMProdFramework )
		{
			m_pDMProdFramework->Release();
			m_pDMProdFramework = NULL;
		}
		if( SUCCEEDED( V_UNKNOWN( &variant )->QueryInterface( IID_IDMUSProdFramework, (void**) &m_pDMProdFramework ) ) )
		{
			IDMUSProdComponent* pIComponent = NULL;
			if( SUCCEEDED ( m_pDMProdFramework->FindComponent( CLSID_CConductor,  &pIComponent ) ))
			{
				pIComponent->QueryInterface( IID_IDMUSProdConductor, (void**)&m_pIConductor );
				pIComponent->Release();
			}

			if( m_pIConductor && (m_pIDMPerformance == NULL) )
			{
				IUnknown* punk;
				if( SUCCEEDED( m_pIConductor->GetPerformanceEngine( &punk ) ) )
				{
					punk->QueryInterface( IID_IDirectMusicPerformance, (void **)&m_pIDMPerformance );
					punk->Release();
				}
			}
			return S_OK;
		}
		else
		{
			return E_FAIL;
		}
		break;

	case SMP_DMUSIOTRACKHEADER:
		if( variant.vt != VT_BYREF )
		{
			return E_INVALIDARG;
		}
		else
		{
			DMUS_IO_TRACK_HEADER *pioTrackHeader = static_cast<DMUS_IO_TRACK_HEADER *>(V_BYREF( &variant ));
			if( pioTrackHeader == NULL )
			{
				return E_POINTER;
			}
			m_dwGroupBits = pioTrackHeader->dwGroup;
			m_dwOldGroupBits = pioTrackHeader->dwGroup;
			if( m_pSequenceStrip )
			{
				m_pSequenceStrip->UpdateName();
			}
		}
		break;

	case SMP_DMUSIOTRACKEXTRASHEADER:
		if( variant.vt != VT_BYREF )
		{
			return E_INVALIDARG;
		}
		else
		{
			DMUS_IO_TRACK_EXTRAS_HEADER *pioTrackExtrasHeader = static_cast<DMUS_IO_TRACK_EXTRAS_HEADER *>(V_BYREF( &variant ));
			if( pioTrackExtrasHeader == NULL )
			{
				return E_POINTER;
			}

			m_dwTrackExtrasFlags = TRACKCONFIG_VALID_MASK & (pioTrackExtrasHeader->dwFlags);
		}
		break;

	case SMP_PRODUCERONLY_FLAGS:
		if( variant.vt != VT_BYREF )
		{
			return E_INVALIDARG;
		}
		else
		{
			IOProducerOnlyChunk *pioProducerOnlyChunk = static_cast<IOProducerOnlyChunk *>(V_BYREF( &variant ));
			if( pioProducerOnlyChunk == NULL )
			{
				return E_POINTER;
			}

			m_dwProducerOnlyFlags = pioProducerOnlyChunk->dwProducerOnlyFlags;
		}
		break;

	default:
		return E_INVALIDARG;
	}
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CSequenceMgr IPersist implementation

/////////////////////////////////////////////////////////////////////////////
// CSequenceMgr::GetClassID

HRESULT CSequenceMgr::GetClassID( CLSID* pClsId )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if ( pClsId == NULL )
	{
		return E_POINTER;
	}

	// return our CLSID
	memcpy( pClsId, &CLSID_SequenceMgr, sizeof( CLSID ) );

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CSequenceMgr IPersistStream implementation

/////////////////////////////////////////////////////////////////////////////
// CSequenceMgr::IsDirty

HRESULT CSequenceMgr::IsDirty()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if ( m_fDirty )
	{
		return S_OK;
	}
	else
	{
		return S_FALSE;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CSequenceMgr::Load


HRESULT CSequenceMgr::Load( IStream* pIStream )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( pIStream == NULL )
	{
		return E_INVALIDARG;
	}

	IDMUSProdRIFFStream* pIRiffStream;
	HRESULT hr = E_FAIL;

	// Check for Direct Music format
	if( FAILED( hr = AllocRIFFStream( pIStream, &pIRiffStream ) ) )
	{
		return hr;
	}

	// Remove all existing sequences
	EmptySequenceList();
	m_dwPChannel = 0;
	m_fSetPChannel = FALSE;

	m_strName.LoadString( IDS_STRIP_NAME );

	MMCKINFO	ck, ckList;
	// Load the Track
	while( pIRiffStream->Descend( &ck, NULL, 0 ) == 0 )
	{
		switch( ck.ckid )
		{
		case FOURCC_LIST:
			switch( ck.fccType )
			{
			case DMUS_FOURCC_UNFO_LIST:
				while( pIRiffStream->Descend( &ckList, &ck, 0 ) == 0 )
				{
					switch( ckList.ckid )
					{
						case DMUS_FOURCC_UNAM_CHUNK:
						case RIFFINFO_INAM:
							ReadMBSfromWCS( pIStream, ckList.cksize, &m_strName );
							break;

						case RIFFINFO_IART:
						case DMUS_FOURCC_UART_CHUNK:
							ReadMBSfromWCS( pIStream, ckList.cksize, &m_strAuthor );
							break;

						case RIFFINFO_ICOP:
						case DMUS_FOURCC_UCOP_CHUNK:
							ReadMBSfromWCS( pIStream, ckList.cksize, &m_strCopyright );
							break;

						case RIFFINFO_ISBJ:
						case DMUS_FOURCC_USBJ_CHUNK:
							ReadMBSfromWCS( pIStream, ckList.cksize, &m_strSubject );
							break;

						case RIFFINFO_ICMT:
						case DMUS_FOURCC_UCMT_CHUNK:
							ReadMBSfromWCS( pIStream, ckList.cksize, &m_strInfo );
							break;
					}
					pIRiffStream->Ascend( &ckList, 0 );
				}
				break;

			case DMUS_FOURCC_SEQUENCE_UI_LIST:
				hr = LoadSequenceUIList( pIRiffStream, &ck );
				if( FAILED( hr ) )
				{
					hr = E_FAIL;
			        goto ON_ERROR;
				}
				break;
			}
			break;

		case DMUS_FOURCC_SEQ_TRACK:
			hr = LoadSeqTrack( pIRiffStream, ck );
			if( FAILED( hr ) )
			{
				hr = E_FAIL;
				goto ON_ERROR;
			}
			break;
		}

		pIRiffStream->Ascend( &ck, 0 );
	}

	if( !m_fSetPChannel )
	{
		m_dwPChannel = m_SeqStripDesign.m_dwPChannel;
	}

	SyncWithDirectMusic();

ON_ERROR:
	pIRiffStream->Release();
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CSequenceMgr::Save

HRESULT CSequenceMgr::Save( IStream* pIStream, BOOL fClearDirty )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	UNREFERENCED_PARAMETER(fClearDirty);

	if( pIStream == NULL )
	{
		return E_INVALIDARG;
	}

	DMUSProdStreamInfo	StreamInfo;//Added ECW 4/24/98
	FileType ftFileType = FT_RUNTIME;
	GUID guidDataFormat = GUID_CurrentVersion;

	// Get additional stream information
	IDMUSProdPersistInfo* pPersistInfo;

	if( SUCCEEDED ( pIStream->QueryInterface( IID_IDMUSProdPersistInfo, (void **)&pPersistInfo ) ) )
	{
		pPersistInfo->GetStreamInfo( &StreamInfo );
		ftFileType = StreamInfo.ftFileType;
		guidDataFormat = StreamInfo.guidDataFormat;
		pPersistInfo->Release();
	}

	// We only support saving to a design-time stream (GUID_CurrentVersion) or a DirectMusic
	// stream that will be loaded into a DirectMusicSequenceTrack (GUID_DirectMusicObject)
	if( !::IsEqualGUID( guidDataFormat, GUID_CurrentVersion ) &&
		!::IsEqualGUID( guidDataFormat, GUID_DirectMusicObject ) )
	{
		return E_INVALIDARG;
	}

	// Now, finally save ourself
	IDMUSProdRIFFStream* pIRiffStream;
	HRESULT hr = E_FAIL;

	// Alloc an IDMUSProdRIFFStream from the IStream
	if( FAILED( hr = AllocRIFFStream( pIStream, &pIRiffStream ) ) )
	{
		return hr;
	}

	DWORD dwBytesWritten;

	// If design file, save track unfo chunk
	if( ftFileType == FT_DESIGN )
	{
		WriteListChunk listUnfo(pIRiffStream, DMUS_FOURCC_UNFO_LIST);
		hr = listUnfo.State();
		if( hr == S_OK )
		{
			if( !m_strName.IsEmpty() )
			{
				WriteChunk chunk(pIRiffStream, DMUS_FOURCC_UNAM_CHUNK);
				hr = chunk.State();
				if( hr == S_OK )
				{
					hr = SaveMBStoWCS( pIStream, &m_strName );
				}
				if( FAILED( hr ) )
				{
					goto ON_ERROR;
				}
			}

			if( !m_strAuthor.IsEmpty() )
			{
				WriteChunk chunk(pIRiffStream, DMUS_FOURCC_UART_CHUNK);
				hr = chunk.State();
				if( hr == S_OK )
				{
					hr = SaveMBStoWCS( pIStream, &m_strAuthor );
				}
				if( FAILED( hr ) )
				{
					goto ON_ERROR;
				}
			}

			if( !m_strCopyright.IsEmpty() )
			{
				WriteChunk chunk(pIRiffStream, DMUS_FOURCC_UCOP_CHUNK);
				hr = chunk.State();
				if( hr == S_OK )
				{
					hr = SaveMBStoWCS( pIStream, &m_strCopyright );
				}
				if( FAILED( hr ) )
				{
					goto ON_ERROR;
				}
			}

			if( !m_strSubject.IsEmpty() )
			{
				WriteChunk chunk(pIRiffStream, DMUS_FOURCC_USBJ_CHUNK);
				hr = chunk.State();
				if( hr == S_OK )
				{
					hr = SaveMBStoWCS( pIStream, &m_strSubject );
				}
				if( FAILED( hr ) )
				{
					goto ON_ERROR;
				}
			}

			if( !m_strInfo.IsEmpty() )
			{
				WriteChunk chunk(pIRiffStream, DMUS_FOURCC_UCMT_CHUNK);
				hr = chunk.State();
				if( hr == S_OK )
				{
					hr = SaveMBStoWCS( pIStream, &m_strInfo );
				}
				if( FAILED( hr ) )
				{
					goto ON_ERROR;
				}
			}
		}
	}

	{
		WriteChunk chunk(pIRiffStream, DMUS_FOURCC_SEQ_TRACK);
		hr = chunk.State();
		if(hr == S_OK)
		{
			// write notes
			WriteChunk chunk(pIRiffStream, DMUS_FOURCC_SEQ_LIST);
			hr = chunk.State();
			if(hr == S_OK)
			{
				WriteDWORD(pIRiffStream, sizeof(DMUS_IO_SEQ_ITEM));
				DMUS_IO_SEQ_ITEM oSequence;
				POSITION pos = m_lstSequences.GetHeadPosition();
				while( pos )
				{
					// Clear out the structure (clears out the padding bytes as well).
					ZeroMemory( &oSequence, sizeof(DMUS_IO_SEQ_ITEM) );
					m_lstSequences.GetNext(pos)->CopyTo(oSequence);

					oSequence.dwPChannel = m_dwPChannel;

					hr = pIStream->Write( &oSequence, sizeof(DMUS_IO_SEQ_ITEM), &dwBytesWritten );
					if( FAILED( hr ) || dwBytesWritten != sizeof(DMUS_IO_SEQ_ITEM) )
					{
						hr = E_FAIL;
						goto ON_ERROR;
					}

					if( FAILED( hr ) )
					{
						goto ON_ERROR;
					}
				}
			}
		}
		// write curves
		if(hr == S_OK)
		{
			WriteChunk curve(pIRiffStream, DMUS_FOURCC_CURVE_LIST);
			hr = curve.State();
			if(hr == S_OK)
			{			
				WriteDWORD(pIRiffStream, sizeof(DMUS_IO_CURVE_ITEM));
				POSITION pos = m_lstCurves.GetHeadPosition();
				while( pos )
				{
					CCurveItem* pCurveItem;
					pCurveItem = m_lstCurves.GetNext( pos );
					ASSERT( pCurveItem );
					if( pCurveItem )
					{
						DMUS_IO_CURVE_ITEM oCurve;
						// Clear out the structure (clears out the padding bytes as well).
						ZeroMemory( &oCurve, sizeof(DMUS_IO_CURVE_ITEM) );
						pCurveItem->CopyTo(oCurve);

						oCurve.dwPChannel = m_dwPChannel;

						hr = pIStream->Write( &oCurve, sizeof(DMUS_IO_CURVE_ITEM), &dwBytesWritten );
						if( FAILED( hr ) || dwBytesWritten != sizeof(DMUS_IO_CURVE_ITEM) )
						{
							hr = E_FAIL;
							goto ON_ERROR;
						}

						if( FAILED( hr ) )
						{
							goto ON_ERROR;
						}
					}
				}
			}
		}
	}

	if( ftFileType == FT_DESIGN )
	{
		SaveSequenceUIList( pIRiffStream );
	}


ON_ERROR:
	pIRiffStream->Release();
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CSequenceMgr::GetSizeMax

HRESULT CSequenceMgr::GetSizeMax( ULARGE_INTEGER FAR* pcbSize )
{
	//AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	UNREFERENCED_PARAMETER(pcbSize);
	// Compute size of stream needed to persist ourself into.
	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CSequenceMgr IDMUSProdPropPageObject implementation

/////////////////////////////////////////////////////////////////////////////
// CSequenceMgr::GetData

// This method is called by CNotePropPageMgr to get data to send to the
// Sequence property page.
// The CSequenceStrip::GetData() method is called by CSequenceStripPropPageMgr
// to get the strip's properties (Group Bits, etc.)
HRESULT STDMETHODCALLTYPE CSequenceMgr::GetData( /* [retval][out] */ void **ppData)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if ( ppData == NULL )
	{
		return E_INVALIDARG;
	}

	if( GetNumSelected() )
	{
		if( m_fDisplayingFlats )
		{
			m_PropSequence.m_dwBits |= BF_DISPLAYFLATS;
		}
		else
		{
			m_PropSequence.m_dwBits &= ~BF_DISPLAYFLATS;
		}
		*ppData = (void*)&m_PropSequence;
		return S_OK;
	}
	else
	{
		*ppData = NULL;
		return S_FALSE;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CSequenceMgr::SetData

// This method is called by CSequencePropPageMgr in response to user actions
// in the Sequence Property page.  It changes the currenly selected Sequence. 
HRESULT STDMETHODCALLTYPE CSequenceMgr::SetData( /* [in] */ void *pData)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if ( pData == NULL )
	{
		return E_INVALIDARG;
	}

	DWORD dwChanged = ApplyToSelectedNotes( (CPropSequence *)pData );

	// Play the selected Note if the velocity or value has changed.
	/* Don't do this
	if ( m_pSequenceStrip->m_pActiveNote &&
		 ((dwChanged & (UD_OCTAVE | UD_MIDIVALUE | UD_VELOCITY)) != 0) )
	{
		PlayNote( m_pSequenceStrip->m_pActiveNote );
	}
	*/

	// If anything has changed, redraw the strip(s)
	if( dwChanged != 0 )
	{
		m_fDirty = TRUE;

		m_pSequenceStrip->m_nLastEdit = IDS_UNDO_CHANGE;
		OnDataChanged();
		m_pSequenceStrip->InvalidateStrip();

		// Always recompute m_SelectedPropNote and update the property page
		RefreshPropertyPage();
		return S_OK;
	}
	else
	{
		// Nothing changed - return S_FALSE
		// Update the property page
		RefreshPropertyPage();
		return S_FALSE;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CSequenceMgr::OnShowProperties

HRESULT STDMETHODCALLTYPE CSequenceMgr::OnShowProperties( void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Ensure our timeline pointer is valid
	if( m_pTimeline == NULL )
	{
		ASSERT(FALSE);
		return E_FAIL;
	}

	// Get a pointer to the property sheet
	IDMUSProdPropSheet* pIPropSheet = NULL;
	m_pDMProdFramework->QueryInterface( IID_IDMUSProdPropSheet, (void **)&pIPropSheet);
	if( pIPropSheet == NULL )
	{
		ASSERT(FALSE);
		return E_FAIL;
	}

	//  If the property sheet is hidden, exit
	if( pIPropSheet->IsShowing() != S_OK )
	{
		pIPropSheet->Release();
		return S_OK;
	}
	pIPropSheet->Release();

	HRESULT hr = S_OK;

	// If we don't have a property page manager yet, create one.
	if( m_pPropPageMgr == NULL )
	{
		CNotePropPageMgr* pPPM = new CNotePropPageMgr;
		if( pPPM == NULL )
		{
			return E_OUTOFMEMORY;
		}

		hr = pPPM->QueryInterface( IID_IDMUSProdPropPageManager, (void**)&m_pPropPageMgr );
		
		// Remove the reference created by the contrustor, leaving the one created by QueryInterface.
		// If QueryInterface failed, this will delete m_pPropPageMgr.
		m_pPropPageMgr->Release();

		if( FAILED(hr) )
		{
			return hr;
		}
	}

	// Save the focus so we can restore after changing the property page
	HWND hwndHadFocus = ::GetFocus();

	// Set the displayed property page to our property page
	m_pTimeline->SetPropertyPage(m_pPropPageMgr, (IDMUSProdPropPageObject*)this);

	// Restore the focus if it changed
	if( hwndHadFocus != ::GetFocus() )
	{
		::SetFocus( hwndHadFocus );
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CSequenceMgr::OnRemoveFromPageManager

HRESULT STDMETHODCALLTYPE CSequenceMgr::OnRemoveFromPageManager( void)
{
	// If you want to do something special when your property page is no longer
	// displayed, do it here.
	return E_NOTIMPL;
}

/////////////////////////////////////////////////////////////////////////////
// CSequenceMgr implementation

/////////////////////////////////////////////////////////////////////////////
// CSequenceMgr::OnDataChanged

HRESULT STDMETHODCALLTYPE CSequenceMgr::OnDataChanged( void)
{
	if( m_fUpdateDirectMusic )
	{
		SyncWithDirectMusic();
	}
	else
	{
		m_fUpdateDirectMusic = TRUE;
	}

	ASSERT( m_pTimeline );
	if ( m_pTimeline == NULL )
	{
		return E_UNEXPECTED;
	}

	// Let our hosting editor know about the change
	m_pTimeline->OnDataChanged( (ISequenceMgr*)this );

	m_fNoteInserted = FALSE;
	m_fCurveInserted = FALSE;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CSequenceMgr::DeleteSelectedSequences

HRESULT CSequenceMgr::DeleteSelectedSequences()
{
	// If fChanged is set, something changed (so we should update our editor)
	BOOL fChanged = FALSE;

	CSequenceItem* pSequenceItem; // Temp. variable
	POSITION pos2, pos1 = m_lstSequences.GetHeadPosition();
	while( pos1 )
	{
		// Need to save current position, since GetNext will set pos1 to point
		// to the next sequence.
		pos2 = pos1;
		pSequenceItem = m_lstSequences.GetNext( pos1 );
		if ( pSequenceItem->m_fSelected )
		{
			// Remove the sequence from the current position.  pos1 will
			// still be valid, and it will still point to the next sequence.
			m_lstSequences.RemoveAt( pos2 );
			if(m_pSequenceStrip && pSequenceItem == m_pSequenceStrip->m_pSelectPivotSeq)
			{
				m_pSequenceStrip->m_pSelectPivotSeq = 0;
			}
			delete pSequenceItem;
			fChanged = TRUE;
		}
	}

	// If fChanged is set, something changed (so we should update our editor)
	if( fChanged )
	{
		m_fDirty = TRUE;
		m_pSequenceStrip->m_nLastEdit = IDS_UNDO_DELETE;
		OnDataChanged();
		RefreshPropertyPage();
	}
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CSequenceMgr::SaveSelectedSequenceChunk

HRESULT CSequenceMgr::SaveSelectedSequenceChunk(IDMUSProdRIFFStream* pIRiffStream, MUSIC_TIME mtBeatsOffset)
{
	IStream *pIStream =	pIRiffStream->GetStream();

	// write notes
	WriteChunk chunk(pIRiffStream, DMUS_FOURCC_SEQ_LIST);
	HRESULT hr = chunk.State();
	if(hr == S_OK)
	{
		WriteDWORD(pIRiffStream, sizeof(DMUS_IO_SEQ_ITEM));
		POSITION pos = m_lstSequences.GetHeadPosition();
		while( pos )
		{
			DMUS_IO_SEQ_ITEM oSequence;
			CSequenceItem* pSequenceItem = m_lstSequences.GetNext( pos );
			if ( pSequenceItem->m_fSelected )
			{
				ASSERT( Status(pSequenceItem->m_bStatus) == MIDI_NOTEON );

				// Clear out the structure (clears out the padding bytes as well).
				ZeroMemory( &oSequence, sizeof(DMUS_IO_SEQ_ITEM) );
				pSequenceItem->CopyTo(oSequence);
				// POSSIBLE BUG: need to recalibrate time to meter
				oSequence.mtTime -= mtBeatsOffset;

				DWORD dwBytesWritten;
				hr = pIStream->Write( &oSequence, sizeof(DMUS_IO_SEQ_ITEM), &dwBytesWritten );
				if( FAILED( hr ) || dwBytesWritten != sizeof(DMUS_IO_SEQ_ITEM) )
				{
					hr = E_FAIL;
					goto ON_ERROR;
				}

				if( FAILED( hr ) )
				{
					goto ON_ERROR;
				}
			}
		}
	}

ON_ERROR:
	pIStream->Release();
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CSequenceMgr::SaveSelectedCurveChunk

HRESULT CSequenceMgr::SaveSelectedCurveChunk(IDMUSProdRIFFStream* pIRiffStream, MUSIC_TIME mtBeatsOffset)
{
	IStream *pIStream =	pIRiffStream->GetStream();

	WriteChunk curve(pIRiffStream, DMUS_FOURCC_CURVE_LIST);
	HRESULT hr = curve.State();
	if(hr == S_OK)
	{			
		WriteDWORD(pIRiffStream, sizeof(DMUS_IO_CURVE_ITEM));
		POSITION pos = m_lstCurves.GetHeadPosition();
		while( pos )
		{
			CCurveItem* pCurveItem = m_lstCurves.GetNext( pos );
			ASSERT( pCurveItem );
			if( pCurveItem->m_fSelected )
			{
				DMUS_IO_CURVE_ITEM oCurve;
				// Clear out the structure (clears out the padding bytes as well).
				ZeroMemory( &oCurve, sizeof(DMUS_IO_CURVE_ITEM) );
				pCurveItem->CopyTo(oCurve);
				oCurve.mtStart -= mtBeatsOffset;

				DWORD dwBytesWritten;
				hr = pIStream->Write( &oCurve, sizeof(DMUS_IO_CURVE_ITEM), &dwBytesWritten );
				if( FAILED( hr ) || dwBytesWritten != sizeof(DMUS_IO_CURVE_ITEM) )
				{
					hr = E_FAIL;
					goto ON_ERROR;
				}

				if( FAILED( hr ) )
				{
					goto ON_ERROR;
				}
			}
		}
	}

ON_ERROR:
	pIStream->Release();
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CSequenceMgr::SaveSelectedSequences

HRESULT CSequenceMgr::SaveSelectedSequences( LPSTREAM pIStream, MUSIC_TIME mtOffset )
{
	IDMUSProdRIFFStream* pIRiffStream;
	HRESULT hr = E_FAIL;

	if( FAILED( hr = AllocRIFFStream( pIStream, &pIRiffStream ) ) )
	{
		return hr;
	}

	// If the Sequence list has anything in it, look for selected Sequences
	if ( !m_lstSequences.IsEmpty() )
	{
		MUSIC_TIME mtTime = 0;
		if ( mtOffset != 0 )
		{
			// Snap mtOffset to the nearest grid before it
			mtTime = m_pSequenceStrip->FloorTimeToGrid( mtOffset, NULL );
		}
		
		// Now, write out each selected item
		WriteChunk chunk(pIRiffStream, DMUS_FOURCC_SEQ_TRACK);
		hr = chunk.State();
		if(hr == S_OK)
		{
			hr = SaveSelectedSequenceChunk( pIRiffStream, mtTime );
		}
	}
	else
	{
		hr = S_FALSE; // Nothing in the list
	}

	pIRiffStream->Release();
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CSequenceMgr::SaveSelectedEvents

HRESULT CSequenceMgr::SaveSelectedEvents( LPSTREAM pIStream, MUSIC_TIME mtOffset )
{
	IDMUSProdRIFFStream* pIRiffStream;
	HRESULT hr = E_FAIL;

	if( FAILED( hr = AllocRIFFStream( pIStream, &pIRiffStream ) ) )
	{
		return hr;
	}

	// If the Sequence list has anything in it, look for selected Sequences
	if( !m_lstCurves.IsEmpty()
	||	!m_lstSequences.IsEmpty() )
	{
		MUSIC_TIME mtTime = 0;
		if ( mtOffset != 0 )
		{
			// Snap mtOffset to the nearest grid before it
			mtTime = m_pSequenceStrip->FloorTimeToGrid( mtOffset, NULL );
		}
		
		// Now, write out each selected item
		WriteChunk chunk(pIRiffStream, DMUS_FOURCC_SEQ_TRACK);
		hr = chunk.State();
		if(hr == S_OK)
		{
			hr = SaveSelectedSequenceChunk( pIRiffStream, mtTime );
			if( SUCCEEDED( hr ) )
			{
				hr = SaveSelectedCurveChunk( pIRiffStream, mtTime );
			}
		}
	}
	else
	{
		hr = S_FALSE; // Nothing in the list
	}

	pIRiffStream->Release();
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CSequenceMgr::SaveSelectedSequencesAsMidi

HRESULT CSequenceMgr::SaveSelectedSequencesAsMidi( LPSTREAM pIStream, MUSIC_TIME mtOffset )
{
	HRESULT hr = S_FALSE;

	// If the Sequence list has anything in it, look for selected Sequences
	if ( !m_lstSequences.IsEmpty() )
	{
		MUSIC_TIME mtTime = 0;
		if ( mtOffset != 0 )
		{
			// Snap mtOffset to the nearest grid before it
			mtTime = m_pSequenceStrip->FloorTimeToGrid( mtOffset, NULL );
		}

		// Offset times
		CTypedPtrList<CPtrList, CSequenceItem*> lstSequences;
		POSITION pos = m_lstSequences.GetHeadPosition();
		while(pos)
		{
			CSequenceItem* pItem = m_lstSequences.GetNext(pos);
			if(pItem->m_fSelected)
			{
				CSequenceItem* pItemNew = new CSequenceItem(*pItem);
				// Subtract off the offset to normalize the item
				// (if not normalizing, mtBeatsOffset will be 0)
				pItemNew->m_mtTime -= mtTime;
				lstSequences.AddTail(pItemNew);
			}
		}

		if( !lstSequences.IsEmpty() )
		{
			// Only need to do this if anything was selected
			hr = WriteMidiSequenceToStream(pIStream, m_dwPChannel, lstSequences);

			// cleanup
			while( !lstSequences.IsEmpty() )
			{
				delete lstSequences.RemoveHead();
			}
		}
	}
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CSequenceMgr::FirstGutterSelectedSequenceMgr

BOOL CSequenceMgr::FirstGutterSelectedSequenceMgr( void )
{
	IDMUSProdStrip *pStrip;
	DWORD dwEnum = 0;
	BOOL fFirstSelectedSequenceMgr = FALSE;
	BOOL fContinueEnum = TRUE;
	// Iterate through all the strips
	while( fContinueEnum && SUCCEEDED( m_pTimeline->EnumStrip( dwEnum, &pStrip ) ) )
	{
		VARIANT varGutter;
		if( SUCCEEDED( m_pTimeline->StripGetTimelineProperty( pStrip, STP_GUTTER_SELECTED, &varGutter ) )
		&&	(varGutter.vt == VT_BOOL) && ( V_BOOL(&varGutter) == TRUE ) )
		{
			// Get their strip manager
			VARIANT varStripMgr;
			if( SUCCEEDED( pStrip->GetStripProperty( SP_STRIPMGR, &varStripMgr ) ) )
			{
				// Check if they belong to a Sequence strip manager
				ISequenceMgr *pISequenceMgr;
				if( SUCCEEDED( V_UNKNOWN( &varStripMgr )->QueryInterface( IID_ISequenceMgr, (void**)&pISequenceMgr ) ) )
				{
					// Yes - check if it is this Sequence strip manager
					ISequenceMgr *pThisSequenceMgr = NULL;
					if( SUCCEEDED( QueryInterface( IID_ISequenceMgr, (void **)&pThisSequenceMgr ) ) )
					{
						if( pThisSequenceMgr == pISequenceMgr )
						{
							// We are the first selected sequence strip - do the save to MIDI file operation
							fFirstSelectedSequenceMgr = TRUE;
						}
						pThisSequenceMgr->Release();
					}
					fContinueEnum = FALSE;
					pISequenceMgr->Release();
				}
				V_UNKNOWN( &varStripMgr )->Release();
			}
		}
		pStrip->Release();
		dwEnum++;
	}

	return fFirstSelectedSequenceMgr;
}


/////////////////////////////////////////////////////////////////////////////
// CSequenceMgr::SaveSelectedEventsAsMidi

HRESULT CSequenceMgr::SaveSelectedEventsAsMidi( LPSTREAM pIStream )
{
	// This method is only called by CSequenceStrip::Copy when
	// m_bGutterSelected && (m_lBeginSelect >= 0) && (m_lEndSelect > 0) is true

	if( !FirstGutterSelectedSequenceMgr() )
	{
		// Not the first selected sequence strip - return S_FALSE so we don't add MIDI data to the clipboard
		return S_FALSE;
	}

	// We are the first selected sequence strip - do the save to MIDI file operation

	// Count the number of sequence strips in this MIDI file
	HRESULT hr = S_FALSE;
	WORD wNumMIDITracks = 0;
	IDMUSProdStrip *pStrip;
	DWORD dwEnum = 0;
	// Iterate through all the strips
	while( SUCCEEDED( m_pTimeline->EnumStrip( dwEnum, &pStrip ) ) )
	{
		VARIANT varGutter;
		if( SUCCEEDED( m_pTimeline->StripGetTimelineProperty( pStrip, STP_GUTTER_SELECTED, &varGutter ) )
		&&	(varGutter.vt == VT_BOOL) && ( V_BOOL(&varGutter) == TRUE ) )
		{
			// Get their strip manager
			VARIANT varStripMgr;
			if( SUCCEEDED( pStrip->GetStripProperty( SP_STRIPMGR, &varStripMgr ) ) )
			{
				// Check if they belong to a Sequence strip manager
				ISequenceMgr *pISequenceMgr;
				if( SUCCEEDED( V_UNKNOWN( &varStripMgr )->QueryInterface( IID_ISequenceMgr, (void**)&pISequenceMgr ) ) )
				{
					// Yes - Sequence strip - increment number of tracks
					wNumMIDITracks++;
					pISequenceMgr->Release();
				}
				V_UNKNOWN( &varStripMgr )->Release();
			}
		}
		pStrip->Release();
		dwEnum++;
	}

	wNumMIDITracks++;

	// write header
	hr = WriteSMFHeader(pIStream, wNumMIDITracks);
	if(FAILED(hr))
	{
		return hr;
	}

	// Write empty Tempo map track
	static const BYTE abControlTrack[12] = {
		0x4d, 0x54, 0x72, 0x6b, // MTrk
		0x00, 0x00, 0x00, 0x04, // Length
		0x00, 0xFF, 0x2F, 0x00 }; // Track end marker

	pIStream->Write( abControlTrack, 12, NULL );

	// write tracks
	dwEnum = 0;

	// Save a copy of the pointer to the last SequenceMgr so we don't add the same
	// strip more than once
	ISequenceMgr *rpLastISequenceMgr = NULL;

	// Iterate through all the strips
	while( SUCCEEDED( m_pTimeline->EnumStrip( dwEnum, &pStrip ) ) )
	{
		VARIANT varGutter;
		if( SUCCEEDED( m_pTimeline->StripGetTimelineProperty( pStrip, STP_GUTTER_SELECTED, &varGutter ) )
		&&	(varGutter.vt == VT_BOOL) && ( V_BOOL(&varGutter) == TRUE ) )
		{
			// Get their strip manager
			VARIANT varStripMgr;
			if( SUCCEEDED( pStrip->GetStripProperty( SP_STRIPMGR, &varStripMgr ) ) )
			{
				// Check if they belong to a Sequence strip manager
				ISequenceMgr *pISequenceMgr;
				if( SUCCEEDED( V_UNKNOWN( &varStripMgr )->QueryInterface( IID_ISequenceMgr, (void**)&pISequenceMgr ) ) )
				{
					if( rpLastISequenceMgr != pISequenceMgr )
					{
						// Yes - Sequence strip - Write the track
						pISequenceMgr->SaveEventsToMIDITrack(pIStream);
						rpLastISequenceMgr = pISequenceMgr;
					}
					pISequenceMgr->Release();
				}
				V_UNKNOWN( &varStripMgr )->Release();
			}
		}
		pStrip->Release();
		dwEnum++;
	}
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CSequenceMgr::ImportMIDIFileToMultipleTracks

HRESULT CSequenceMgr::ImportMIDIFileToMultipleTracks( LPSTREAM pStream )
{
	if(pStream == NULL)
	{
		return E_POINTER;
	}

	// Save the location of the start of the file
	DWORD dwStartOfFile = StreamTell( pStream );

	// Determined the length of the MIDI clip
	CTypedPtrList<CPtrList, CSequenceItem*> lstSequences;
	CTypedPtrList<CPtrList, CCurveItem*> lstCurves;
	DWORD dwLength;
	HRESULT hr = ReadMidiSequenceFromStream(pStream, lstSequences, lstCurves, 0, dwLength);
	while( !lstSequences.IsEmpty() )
	{
		delete lstSequences.RemoveHead();
	}
	while( !lstCurves.IsEmpty() )
	{
		delete lstCurves.RemoveHead();
	}
	ASSERT(hr == S_OK);
	if( FAILED(hr) )
	{
		return hr;
	}

	// Jump back to the start of the file
	StreamSeek( pStream, dwStartOfFile, STREAM_SEEK_SET );

    DWORD dwID, dwSize;
    if( ( S_OK != pStream->Read( &dwID, sizeof( FOURCC ), NULL ) ) ||
		!GetMLong( pStream, dwSize ) )
    {
		return E_FAIL;
    }
// check for RIFF MIDI files
    if( dwID == mmioFOURCC( 'R', 'I', 'F', 'F' ) )
    {
		StreamSeek( pStream, 12, STREAM_SEEK_CUR );
		if( ( S_OK != pStream->Read( &dwID, sizeof( FOURCC ), NULL ) ) ||
			!GetMLong( pStream, dwSize ) )
		{
			return E_FAIL;
		}
    }
// check for normal MIDI files
	if( dwID != mmioFOURCC( 'M', 'T', 'h', 'd' ) )
	{
		return E_FAIL;
	}

    short nFormat, nNumTracks;
    GetMShort( pStream, nFormat );
    GetMShort( pStream, nNumTracks );
    GetMShort( pStream, gnPPQN );
    if( dwSize > 6 )
    {
		StreamSeek( pStream, dwSize - 6, STREAM_SEEK_CUR );
    }

	DWORD dwStreamPos = StreamTell( pStream );

	// Check for a MIDI track that only includes Meta-Events, and ignore it if found
	if( nFormat == 1 )
	{
		BOOL fOnly0xFFMIDIEvents = TRUE;

		// Check for the MIDI Track header
		DWORD dwID;
		pStream->Read( &dwID, sizeof( FOURCC ), NULL );
		if( dwID != mmioFOURCC( 'M', 'T', 'r', 'k' ) )
		{
			return E_UNEXPECTED;
		}

		// Get the size of this track
		DWORD dwSize;
		GetMLong( pStream, dwSize );

		BYTE bRunningStatus = 0;

		while( dwSize > 0 )
		{
			DWORD dwOffsetTime;
			dwSize -= GetVarLength( pStream, dwOffsetTime );
			BYTE b;

			if( FAILED( pStream->Read( &b, 1, NULL ) ) )
			{
				return E_FAIL;
			}

		    DWORD dwBytes;
			if( b < 0x80 )
			{
				StreamSeek( pStream, -1, STREAM_SEEK_CUR );
				b = bRunningStatus;
				dwBytes = 0;
			}
			else
			{
				dwBytes = 1;
			}

			if( b < 0xf0 )
			{
				bRunningStatus = b;

				switch( b & 0xf0 )
				{
				case MIDI_CCHANGE:
				case MIDI_PTOUCH:
				case MIDI_PBEND:
				case MIDI_NOTEOFF:
				case MIDI_NOTEON:
					if( FAILED( pStream->Read( &b, 1, NULL ) ) )
					{
						return E_FAIL;
					}
					++dwBytes;
					/*if( FAILED( pStream->Read( &b, 1, NULL ) ) )
					{
						return E_FAIL;
					}
					++dwBytes;
					break;*/
				case MIDI_PCHANGE:
				case MIDI_MTOUCH:
					if(FAILED(pStream->Read(&b, 1, NULL)))
					{
						return E_FAIL;
					}
					++dwBytes;
					fOnly0xFFMIDIEvents = FALSE;
					break;
				default:
					// this should NOT be possible - unknown midi note event type
					ASSERT(FALSE);
					fOnly0xFFMIDIEvents = FALSE;
					break;
				}
			}
			else
			{
				DWORD dwLen;
				switch( b )
				{
				case 0xff:
					if( FAILED( pStream->Read( &b, 1, NULL ) ) )
					{
						return E_FAIL;
					}
					++dwBytes;
					dwBytes += GetVarLength( pStream, dwLen );
					StreamSeek( pStream, dwLen, STREAM_SEEK_CUR );
					dwBytes += dwLen;
					break;
				case 0xf0:
				case 0xf7:
					dwBytes += GetVarLength( pStream, dwLen );
					StreamSeek( pStream, dwLen, STREAM_SEEK_CUR );
					dwBytes += dwLen;
					fOnly0xFFMIDIEvents = FALSE;
					break;
				default:
					TRACE( "Unknown midi event type: 0x%x", b );
					fOnly0xFFMIDIEvents = FALSE;
					break;
				}
			}

			// Subtrack off the number of bytes read
			dwSize -= dwBytes;
		}

		if( !fOnly0xFFMIDIEvents )
		{
			// Seek back to the begining, since there are some useful MIDI events
			// in ths track
			StreamSeek( pStream, dwStreamPos, STREAM_SEEK_SET );
		}
	}

	// Iterate through all the strips
	DWORD dwStripEnum = 0;
	IDMUSProdStrip *pStrip;
	while( SUCCEEDED( m_pTimeline->EnumStrip( dwStripEnum, &pStrip ) ) )
	{
		VARIANT varGutter;
		if( SUCCEEDED( m_pTimeline->StripGetTimelineProperty( pStrip, STP_GUTTER_SELECTED, &varGutter ) )
		&&	(varGutter.vt == VT_BOOL) && ( V_BOOL(&varGutter) == TRUE ) )
		{
			// Get their strip manager
			VARIANT varStripMgr;
			if( SUCCEEDED( pStrip->GetStripProperty( SP_STRIPMGR, &varStripMgr ) ) )
			{
				// Check if they belong to a Sequence strip manager
				ISequenceMgr *pISequenceMgr;
				if( SUCCEEDED( V_UNKNOWN( &varStripMgr )->QueryInterface( IID_ISequenceMgr, (void**)&pISequenceMgr ) ) )
				{
					// Yes - Sequence strip - read the track
					pISequenceMgr->PasteEventsFromMIDITrack(pStream, gnPPQN, dwLength);
					pISequenceMgr->Release();
				}
				V_UNKNOWN( &varStripMgr )->Release();
			}
		}
		pStrip->Release();
		dwStripEnum++;
	}
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CSequenceMgr::ImportSequenceChunkData

HRESULT CSequenceMgr::ImportSequenceChunkData( LPSTREAM pIStream, long lChunkSize, long lTimeOffset )
{
	DWORD dwSequenceSize, dwByteCount;
	HRESULT hr = pIStream->Read( &dwSequenceSize, sizeof(DWORD), &dwByteCount );
	if( FAILED( hr ) || dwByteCount != sizeof(DWORD) )
	{
		return E_FAIL;
	}

	ASSERT( dwSequenceSize == sizeof(DMUS_IO_SEQ_ITEM) );
	if( dwSequenceSize != sizeof(DMUS_IO_SEQ_ITEM) )
	{
		return E_FAIL;
	}

	lChunkSize -= sizeof(DWORD);

	DMUS_IO_SEQ_ITEM iSequence;
	while( lChunkSize > 0 )
	{
		ZeroMemory(&iSequence, sizeof(DMUS_IO_SEQ_ITEM));
		hr = pIStream->Read( &iSequence, sizeof(DMUS_IO_SEQ_ITEM), &dwByteCount );
		if( FAILED( hr ) || dwByteCount != sizeof(DMUS_IO_SEQ_ITEM) )
		{
			return E_FAIL;
		}

		lChunkSize -= dwByteCount;

		CSequenceItem* pItem = new CSequenceItem;
		if ( pItem == NULL )
		{
			return E_OUTOFMEMORY;
		}
		
		pItem->CopyFrom(iSequence);

		// offset the note's MusicTime value
		pItem->MusicTime() += lTimeOffset;

		pItem->m_fSelected = TRUE;

		InsertByAscendingTime(pItem);
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CSequenceMgr::ImportCurveChunkData

HRESULT CSequenceMgr::ImportCurveChunkData( LPSTREAM pIStream, long lChunkSize, long lTimeOffset )
{
	DWORD dwCurveSize, dwByteCount;
	HRESULT hr = pIStream->Read(&dwCurveSize, sizeof(DWORD), &dwByteCount);
	if(FAILED(hr) || dwByteCount != sizeof(DWORD))
	{	
		return E_FAIL;
	}
	lChunkSize -= sizeof(DWORD);

	DMUS_IO_CURVE_ITEM iCurve;
	while(lChunkSize > 0)
	{
		ZeroMemory(&iCurve, sizeof(DMUS_IO_CURVE_ITEM));
		hr = pIStream->Read(&iCurve, dwCurveSize, &dwByteCount);
		if(FAILED(hr) || dwByteCount != dwCurveSize)
		{
			return E_FAIL;
		}

		lChunkSize -= dwByteCount;

		CCurveItem* pItem = new CCurveItem;
		if(pItem == NULL)
		{
			return E_OUTOFMEMORY;
		}

		pItem->CopyFrom(iCurve);

		// offset the curve's MusicTime value
		pItem->MusicTime() = iCurve.mtStart + lTimeOffset;

		pItem->m_fSelected = TRUE;

		InsertByAscendingTime(pItem);
	}

	return S_OK;
}


/*
/////////////////////////////////////////////////////////////////////////////
// CSequenceMgr::MarkSelectedSequences

void CSequenceMgr::MarkSelectedSequences( DWORD dwFlags )
{
	// For all selected items, OR dwFlags with the item's m_dwBits member.
	POSITION pos = m_lstSequences.GetHeadPosition();
	while( pos )
	{
		CSequenceItem* pSequenceItem;
		pSequenceItem = m_lstSequences.GetNext( pos );
		if ( pSequenceItem->m_fSelected )
		{
			pSequenceItem->m_dwBits |= dwFlags;
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CSequenceMgr::DeleteMarked

void CSequenceMgr::DeleteMarked( DWORD dwFlags )
{
	// For all items, if the item's m_dwBits member has any of the same bits set as
	// dwFlags (m_dwBits & dwFlags is non-zero), delete it.
	CSequenceItem* pSequenceItem;
	POSITION pos2, pos1 = m_lstSequences.GetHeadPosition();
	while( pos1 )
	{
		pos2 = pos1;
		pSequenceItem = m_lstSequences.GetNext( pos1 );
		if ( pSequenceItem->m_dwBits & dwFlags )
		{
			m_lstSequences.RemoveAt( pos2 );
			if(m_pSequenceStrip && pSequenceItem == m_pSequenceStrip->m_pSelectPivotSeq)
			{
				m_pSequenceStrip->m_pSelectPivotSeq = 0;
			}
			m_fDirty = TRUE;
			delete pSequenceItem;
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CSequenceMgr::UnMarkSequences

void CSequenceMgr::UnMarkSequences( DWORD dwFlags )
{
	// For all items, clear the bits in the item's m_dwBits member that are also set in dwFlags.
	POSITION pos = m_lstSequences.GetHeadPosition();
	while( pos )
	{
		m_lstSequences.GetNext( pos )->m_dwBits &= ~dwFlags;
	}
}
*/


/////////////////////////////////////////////////////////////////////////////
// CSequenceMgr::SelectAllNotes

void CSequenceMgr::SelectAllNotes()
{
	BOOL fChanged = FALSE;
	POSITION pos = m_lstSequences.GetHeadPosition();
	while( pos )
	{
		CSequenceItem *pSeqItem = m_lstSequences.GetNext( pos );
		if( !pSeqItem->m_fSelected )
		{
			fChanged = TRUE;
			pSeqItem->m_fSelected = TRUE;
		}
	}

	// If anything changed, refresh the display and property pages
	if (fChanged)
	{
		m_pSequenceStrip->InvalidateStrip();
		RefreshPropertyPage( );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CSequenceMgr::IsSelected

BOOL CSequenceMgr::IsSelected()
{
	// If anything is selected, return TRUE.
	POSITION pos = m_lstSequences.GetHeadPosition();
	while( pos )
	{
		if ( m_lstSequences.GetNext( pos )->m_fSelected )
		{
			return TRUE;
		}
	}

	if( !m_pSequenceStrip ) 
	{
		return FALSE;
	}

	// If the gutter is selected, need to also check for selected curves
	if( m_pSequenceStrip->m_bGutterSelected && (m_pSequenceStrip->m_lBeginSelect >= 0) && (m_pSequenceStrip->m_lEndSelect > 0))
	{
		pos = m_lstCurves.GetHeadPosition();
		while( pos )
		{
			if ( m_lstCurves.GetNext( pos )->m_fSelected )
			{
				return TRUE;
			}
		}
	}

	return FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CSequenceMgr::FirstSelectedSequence

CSequenceItem* CSequenceMgr::FirstSelectedSequence(POSITION* pPos)
{
	POSITION pos;
	if(pPos == NULL)
	{
		pPos = &pos;
	}

	*pPos = m_lstSequences.GetHeadPosition();

	CSequenceItem* pSequenceItem;
	while( *pPos )
	{
		pSequenceItem = m_lstSequences.GetNext( *pPos );
		if ( pSequenceItem->m_fSelected )
		{
			return pSequenceItem;
		}
	}
	return NULL;
}


/////////////////////////////////////////////////////////////////////////////
// CSequenceMgr::SelectSegmentNotes

BOOL CSequenceMgr::SelectSegmentNotes(long lBeginTime, long lEndTime)
{
	ASSERT(m_pTimeline);
	if( !m_pTimeline )
	{
		return FALSE;
	}

	BOOL result = FALSE;
	if( lBeginTime == -1)
	{
		// till we implement m_lShiftFromMeasure (see CommandMgr::SelectSegment),
		// just set it to beginning
		lBeginTime = 0;
	}

	CSequenceItem* pSequenceItem;
	POSITION pos = m_lstSequences.GetHeadPosition();
	while( pos )
	{
		pSequenceItem = m_lstSequences.GetNext( pos );
		pSequenceItem->m_fSelected = FALSE;
		if( (lBeginTime <= pSequenceItem->AbsTime()) && (pSequenceItem->AbsTime() < lEndTime) )
		{
			pSequenceItem->m_fSelected = TRUE;
			result = TRUE;
		}
	}
	return result;
}


/////////////////////////////////////////////////////////////////////////////
// CSequenceMgr::EmptySequenceList

void CSequenceMgr::EmptySequenceList(void)
{
	// Remove all items from the list
	if( !m_lstSequences.IsEmpty() )
	{
		CSequenceItem *pSequenceItem;
		while ( !m_lstSequences.IsEmpty() )
		{
			pSequenceItem = m_lstSequences.RemoveHead();
			if(m_pSequenceStrip && pSequenceItem == m_pSequenceStrip->m_pSelectPivotSeq)
			{
				m_pSequenceStrip->m_pSelectPivotSeq = 0;
			}
			delete pSequenceItem;
		}
	}
	// Remove all items from the list
	if( !m_lstCurves.IsEmpty() )
	{
		CCurveItem *pCurveItem;
		while ( !m_lstCurves.IsEmpty() )
		{
			pCurveItem = m_lstCurves.RemoveHead();
			/*
			if(m_pCurveStrip && pCurveItem == m_pCurveStrip->m_pSelectPivotSeq)
			{
				m_pCurveStrip->m_pSelectPivotSeq = 0;
			}
			*/
			delete pCurveItem;
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CSequenceMgr::InsertByAscendingTime

void CSequenceMgr::InsertByAscendingTime( CSequenceItem *pSequence )
{
	// Insert pSequence into the list in ascending order, determined by the values of
	// the item's start time.
	ASSERT( pSequence );
	if ( pSequence == NULL )
	{
		return;
	}

	POSITION pos2, pos1 = m_lstSequences.GetHeadPosition();
	while( pos1 )
	{
		pos2 = pos1;
		if ( m_lstSequences.GetNext( pos1 )->AbsTime() >= pSequence->AbsTime() )
		{
			// insert before pos2 (which is current position of pSequenceItem)
			m_lstSequences.InsertBefore( pos2, pSequence );
			return;
		}
	}
	// insert at end of list
	m_lstSequences.AddTail( pSequence );
	return;
}


/////////////////////////////////////////////////////////////////////////////
// CSequenceMgr::InsertByAscendingTime

void CSequenceMgr::InsertByAscendingTime( CCurveItem *pCurve )
{
	// Insert pCurve into the list in ascending order, determined by the values of
	// the item's start time.
	ASSERT( pCurve );
	if ( pCurve == NULL )
	{
		return;
	}

	POSITION pos2, pos1 = m_lstCurves.GetHeadPosition();
	while( pos1 )
	{
		pos2 = pos1;
		if ( m_lstCurves.GetNext( pos1 )->AbsTime() >= pCurve->AbsTime() )
		{
			// insert before pos2 (which is current position of pCurveItem)
			m_lstCurves.InsertBefore( pos2, pCurve );
			return;
		}
	}
	// insert at end of list
	m_lstCurves.AddTail( pCurve );
	return;
}


/////////////////////////////////////////////////////////////////////////////
// CSequenceMgr::InsertByAscendingTimeReplaceSame
/*
void CSequenceMgr::InsertByAscendingTimeReplaceSame( CSequenceItem *pSequence )
{
	// Insert pSequence into the list in ascending order, determined by the values of
	// the item's start time.
	ASSERT( pSequence );
	if ( pSequence == NULL )
	{
		return;
	}

	CSequenceItem* pTempSeq;
	POSITION pos2, pos1 = m_lstSequences.GetHeadPosition();
	while( pos1 )
	{
		pos2 = pos1;
		pTempSeq = m_lstSequences.GetNext( pos1 );
		ASSERT( pTempSeq );
		if ( pTempSeq )
		{
			if ( pTempSeq->AbsTime() >= pSequence->AbsTime() )
			{
				// insert before pos2 (which is current position of pSequenceItem)
				m_lstSequences.InsertBefore( pos2, pSequence );

				if( (pTempSeq->AbsTime() == pSequence->AbsTime()) &&
					(pTempSeq->m_dwPChannel == pSequence->m_dwPChannel) &&
					(pTempSeq->m_bStatus == pSequence->m_bStatus) &&
					(pTempSeq->m_bByte1 == pSequence->m_bByte1) )
				{
					//TRACE("Replacing item %x,%d,%d with %d on %d.\n", pTempSeq->m_bStatus, pTempSeq->m_bByte1, pTempSeq->m_nStartValue, pSequence->m_nStartValue, pSequence->m_dwPChannel );
					// delete the item
					m_lstSequences.RemoveAt(pos2);
					delete pTempSeq;
				}
				// replace all events whose start is in the span of pSequenceItem
				while(pos1)
				{
					pos2 = pos1;
					pTempSeq = m_lstSequences.GetNext(pos1);
					if( (pTempSeq->AbsTime() == pSequence->AbsTime()) &&
						(pTempSeq->m_dwPChannel == pSequence->m_dwPChannel) &&
						(pTempSeq->m_bStatus == pSequence->m_bStatus) &&
						(pTempSeq->m_bByte1 == pSequence->m_bByte1) )
					{
						//TRACE("Replacing item %x,%d,%d with %d on %d.\n", pTempSeq->m_bStatus, pTempSeq->m_bByte1, pTempSeq->m_nStartValue, pSequence->m_nStartValue, pSequence->m_dwPChannel );
						// delete the item
						m_lstSequences.RemoveAt(pos2);
						delete pTempSeq;
					}
					else
					{
						break;	// seqlist ascending -> no more events in timespan
					}
				}
				return;
			}
		}
	}
	// insert at end of list
	m_lstSequences.AddTail( pSequence );
	return;
}
*/

/////////////////////////////////////////////////////////////////////////////
// CSequenceMgr::InsertByAscendingTimeBackwards

void CSequenceMgr::InsertByAscendingTimeBackwards( CSequenceItem *pSequence )
{
	// Insert pSequence into the list in ascending order, determined by the values of
	// the item's m_lTime member.  Search from the end of the list forwards.
	ASSERT( pSequence );
	if ( pSequence == NULL )
	{
		return;
	}

	POSITION pos2, pos1 = m_lstSequences.GetTailPosition();
	while( pos1 )
	{
		pos2 = pos1;
		if ( m_lstSequences.GetPrev( pos1 )->AbsTime() < pSequence->AbsTime() )
		{
			// insert after pos2 (which is current position of pSequenceItem)
			m_lstSequences.InsertAfter( pos2, pSequence );
			return;
		}
	}
	// insert at head of list
	m_lstSequences.AddHead( pSequence );
	return;
}


/////////////////////////////////////////////////////////////////////////////
// CSequenceMgr::InsertByAscendingTimeBackwards

void CSequenceMgr::InsertByAscendingTimeBackwards( CCurveItem *pCurve )
{
	// Insert pCurve into the list in ascending order, determined by the values of
	// the item's start time.  Search from the end of the list forwards.
	ASSERT( pCurve );
	if ( pCurve == NULL )
	{
		return;
	}

	CCurveItem* pCurveItem;
	POSITION pos2, pos1 = m_lstCurves.GetTailPosition();
	while( pos1 )
	{
		pos2 = pos1;
		pCurveItem = m_lstCurves.GetPrev( pos1 );
		ASSERT( pCurveItem );
		if ( pCurveItem )
		{
			if ( pCurveItem->AbsTime() < pCurve->AbsTime() )
			{
				// insert after pos2 (which is current position of pCurveItem)
				m_lstCurves.InsertAfter( pos2, pCurve );
				return;
			}
		}
	}
	// insert at head of list
	m_lstCurves.AddHead( pCurve );
	return;
}


/////////////////////////////////////////////////////////////////////////////
// CSequenceMgr::RemoveItem

BOOL CSequenceMgr::RemoveItem( CSequenceItem* pItem )
{
	// Removes the specified item from the list
	POSITION pos2;
	POSITION pos1 = m_lstSequences.GetHeadPosition();
	while( pos1 )
	{
		pos2 = pos1;
		if ( m_lstSequences.GetNext( pos1 ) == pItem )
		{
			m_lstSequences.RemoveAt( pos2 );
			return TRUE;
		}
	}
	return FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CSequenceMgr::SyncWithDirectMusic

HRESULT CSequenceMgr::SyncWithDirectMusic(  )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	HRESULT hr = S_OK;
//	return hr;

	// 1. persist the strip as a sequence track to a stream
	IStream* pIMemStream = NULL;
	IPersistStream* pIPersistStream = NULL;
	hr = m_pDMProdFramework->AllocMemoryStream( FT_RUNTIME, GUID_CurrentVersion, &pIMemStream );
	if( SUCCEEDED ( hr ) )
	{
		StreamSeek( pIMemStream, 0, STREAM_SEEK_SET );
		hr = Save(pIMemStream, FALSE);
		if ( SUCCEEDED( hr ) )
		{
			// 2. load the stream into m_pIDMTrack
			hr = m_pIDMTrack->QueryInterface(IID_IPersistStream, (void**)&pIPersistStream);
			if ( SUCCEEDED( hr ) )
			{
				StreamSeek( pIMemStream, 0, STREAM_SEEK_SET );
				hr = pIPersistStream->Load(pIMemStream);

				if( m_pDMProdSegmentNode )
				{
					IDirectMusicSegment *pSegment;
					if( SUCCEEDED( m_pDMProdSegmentNode->GetObject(CLSID_DirectMusicSegment, IID_IDirectMusicSegment, (void **)&pSegment ) ) )
					{
						m_pIDMTrack->Init( pSegment );
						pSegment->Release();
					}
				}

				pIPersistStream->Release();
			}
		}
		pIMemStream->Release();
	}

	return hr;
}


HRESULT CSequenceMgr::GetBoundariesOfSelectedEvents(long & lStartTime, long & lEndTime)
{

	ASSERT(m_pTimeline);
	HRESULT hr = S_OK;
	lStartTime = lEndTime = -1;
	CMusicTimeConverter cmtTime, cmtDur;
	CSequenceItem* pSequenceItem;
	POSITION pos = m_lstSequences.GetHeadPosition();
	while(pos)
	{
		pSequenceItem = m_lstSequences.GetNext( pos );
		if( pSequenceItem->m_fSelected )
		{
			cmtTime = pSequenceItem->AbsTime();
			cmtDur = pSequenceItem->m_mtDuration > 0 
							? pSequenceItem->m_mtDuration : 1;
			long lTestEnd = cmtTime + cmtDur;
			if(lStartTime == -1 || cmtTime < lStartTime)
			{
				lStartTime = cmtTime;
			}
			if(lEndTime == -1 || (lTestEnd > lEndTime))
			{
				lEndTime = lTestEnd;
			}
		}
	}
	if(hr == S_OK && (lStartTime == -1 || lEndTime == -1))
	{
		// nothing selected
		hr = S_FALSE;
	}
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CSequenceMgr::DeleteBetweenTimes

void CSequenceMgr::DeleteBetweenTimes( long lStart, long lEnd )
{
	// Iterate through the list
	CSequenceItem* pSequenceItem;
	POSITION pos2, pos = m_lstSequences.GetHeadPosition();
	while( pos )
	{
		// Save the current position
		pos2 = pos;
		pSequenceItem = m_lstSequences.GetNext( pos );

		// If the tempo occurs between lStart and lEnd, delete it
		if( (pSequenceItem->AbsTime() >= lStart) && (pSequenceItem->AbsTime() <= lEnd) ) 
		{
			m_lstSequences.RemoveAt( pos2 );
			delete pSequenceItem;
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CSequenceMgr::LoadSeqTrack

HRESULT CSequenceMgr::LoadSeqTrack( IDMUSProdRIFFStream* pIRiffStream, MMCKINFO ck )
{
	ASSERT( pIRiffStream );
	if( pIRiffStream == NULL )
	{
		return E_POINTER;
	}

	IStream *pIStream;
	pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream );
	if( pIStream == NULL )
	{
		return E_POINTER;
	}

	HRESULT hr = E_FAIL;

	MMCKINFO ck1;
	ck1.ckid = DMUS_FOURCC_SEQ_LIST;
	if(pIRiffStream->Descend(&ck1, &ck, MMIO_FINDCHUNK) == 0)
	{
		DWORD dwSequenceSize, dwByteCount;
		hr = pIStream->Read(&dwSequenceSize, sizeof(DWORD), &dwByteCount);
		if( FAILED( hr ) || dwByteCount != sizeof(DWORD) )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}

		dwSequenceSize = min( dwSequenceSize, sizeof(DMUS_IO_SEQ_ITEM) );

		DMUS_IO_SEQ_ITEM iSequence;
		long lChunkSize = ck1.cksize - sizeof(DWORD);
		while(lChunkSize > 0)
		{
			ZeroMemory(	&iSequence, sizeof(DMUS_IO_SEQ_ITEM) );
			hr = pIStream->Read( &iSequence, dwSequenceSize, &dwByteCount );
			if( FAILED( hr ) || dwByteCount != dwSequenceSize )
			{
				hr = E_FAIL;
				goto ON_ERROR;
			}

			lChunkSize -= dwSequenceSize;

			if( Status(iSequence.bStatus) != MIDI_NOTEON )
			{
				CCurveItem* pItem = new CCurveItem;
				if ( pItem == NULL )
				{
					hr = E_OUTOFMEMORY;
					goto ON_ERROR;
				}

				if( !m_fSetPChannel )
				{
					m_fSetPChannel = TRUE;
					m_dwPChannel = iSequence.dwPChannel;
				}

				pItem->CopyFrom(iSequence);

				InsertByAscendingTimeBackwards( pItem );
			}
			else
			{
				CSequenceItem* pItem = new CSequenceItem;
				if ( pItem == NULL )
				{
					hr = E_OUTOFMEMORY;
					goto ON_ERROR;
				}

				if( !m_fSetPChannel )
				{
					m_fSetPChannel = TRUE;
					m_dwPChannel = iSequence.dwPChannel;
				}

				pItem->CopyFrom(iSequence);

				InsertByAscendingTimeBackwards( pItem );
			}
		}
		pIRiffStream->Ascend(&ck1, 0);
	}

	ck1.ckid = DMUS_FOURCC_CURVE_LIST;
	if(pIRiffStream->Descend(&ck1, &ck, MMIO_FINDCHUNK) == 0)
	{
		DWORD dwSequenceSize, dwByteCount;
		hr = pIStream->Read(&dwSequenceSize, sizeof(DWORD), &dwByteCount);
		if( FAILED( hr ) || dwByteCount != sizeof(DWORD) )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}

		dwSequenceSize = min( dwSequenceSize, sizeof(DMUS_IO_CURVE_ITEM) );

		DMUS_IO_CURVE_ITEM iCurve;
		long lChunkSize = ck1.cksize - sizeof(DWORD);
		while(lChunkSize > 0)
		{
			ZeroMemory(	&iCurve, sizeof(DMUS_IO_CURVE_ITEM) );
			hr = pIStream->Read( &iCurve, dwSequenceSize, &dwByteCount );
			if( FAILED( hr ) || dwByteCount != dwSequenceSize )
			{
				hr = E_FAIL;
				goto ON_ERROR;
			}

			lChunkSize -= dwSequenceSize;

			CCurveItem* pItem = new CCurveItem;
			if ( pItem == NULL )
			{
				hr = E_OUTOFMEMORY;
				goto ON_ERROR;
			}

			if( !m_fSetPChannel )
			{
				m_fSetPChannel = TRUE;
				m_dwPChannel = iCurve.dwPChannel;
			}

			pItem->CopyFrom(iCurve);

			InsertByAscendingTimeBackwards( pItem );
		}
		pIRiffStream->Ascend(&ck1, 0);
	}

ON_ERROR:
	pIStream->Release();
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CSequenceMgr::UnselectAllNotes

void CSequenceMgr::UnselectAllNotes()
{
	BOOL fChanged = FALSE;
	POSITION pos = m_lstSequences.GetHeadPosition();
	while( pos )
	{
		CSequenceItem *pSeqItem = m_lstSequences.GetNext( pos );
		if( pSeqItem->m_fSelected )
		{
			fChanged = TRUE;
			pSeqItem->m_fSelected = FALSE;
		}
	}

	// If anything changed, refresh the display and property pages
	if (fChanged)
	{
		m_pSequenceStrip->InvalidateStrip();
		RefreshPropertyPage( );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CSequenceMgr::UnselectAllCurves

void CSequenceMgr::UnselectAllCurves()
{
	BOOL fChanged = FALSE;
	POSITION pos = m_lstCurves.GetHeadPosition();
	while( pos )
	{
		CCurveItem *pCurveItem = m_lstCurves.GetNext( pos );
		if( pCurveItem->m_fSelected )
		{
			fChanged = TRUE;
			pCurveItem->m_fSelected = FALSE;
		}
	}

	// If anything changes, refresh the display and property page
	if (fChanged)
	{
		// This also refreshes the curve strip property page(s)
		m_pSequenceStrip->InvalidateCurveStrips();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CSequenceMgr::PlayPatch

void CSequenceMgr::PlayPatch( MUSIC_TIME mtTime )
{
	bool fFoundPatch = false;
	DWORD dwPatch = 0;
	DWORD dwIndex = 0;
	MUSIC_TIME mtLatestBandTime = LONG_MIN;

	// Continue forever
	while( TRUE )
	{
		// Get a pointer to the Band stripmgr at index dwIndex
		IDMUSProdStripMgr *pBandStripMgr = NULL;
		if( SUCCEEDED( m_pTimeline->GetStripMgr( GUID_BandStrip_InstrumentItem, m_dwGroupBits, dwIndex, &pBandStripMgr ) ) )
		{
			// Try and get the instrument on PChannel m_dwPChannel
			BandStrip_InstrumentItem bandStrip_InstrumentItem;
			bandStrip_InstrumentItem.dwPChannel = m_dwPChannel;
			MUSIC_TIME mtNextBand;
			HRESULT hr = pBandStripMgr->GetParam( GUID_BandStrip_InstrumentItem, mtTime, &mtNextBand, &bandStrip_InstrumentItem );

			// If we found the instrument
			if( SUCCEEDED( hr ) )
			{
				// Flag that we found a patch
				fFoundPatch = true;

				// If we found a band and it's later than all other bands,
				// save it to use for this time span
				if( bandStrip_InstrumentItem.lPhysicalTime > mtLatestBandTime )
				{
					dwPatch = bandStrip_InstrumentItem.dwPatch;
					mtLatestBandTime = bandStrip_InstrumentItem.lPhysicalTime;
				}
			}

			pBandStripMgr->Release();
		}
		else
		{
			// No more strips to check - exit
			break;
		}
		dwIndex++;
	}

	if( fFoundPatch )
	{
		DMUS_PATCH_PMSG *pPatchEvent;
		if( FAILED( m_pIDMPerformance->AllocPMsg( sizeof(DMUS_PATCH_PMSG), (DMUS_PMSG **)&pPatchEvent ) ) )
		{
			return;
		}

		REFERENCE_TIME rtLatency;
		m_pIDMPerformance->GetLatencyTime( &rtLatency );

		ZeroMemory( pPatchEvent, sizeof(DMUS_PATCH_PMSG) );
		// PMSG fields
		pPatchEvent->dwSize = sizeof(DMUS_PATCH_PMSG);
		m_pIDMPerformance->GetLatencyTime( &pPatchEvent->rtTime );
	//	pPatchEvent->mtTime = 0;
		pPatchEvent->dwFlags = DMUS_PMSGF_REFTIME;
		pPatchEvent->dwPChannel = m_dwPChannel;
		pPatchEvent->dwVirtualTrackID = 1;
	//	pPatchEvent->pTool = NULL;
	//	pPatchEvent->pGraph = NULL;
		pPatchEvent->dwType = DMUS_PMSGT_PATCH;
	//	pPatchEvent->punkUser = 0;

		// PATCH fields
		pPatchEvent->byInstrument = BYTE(dwPatch & 0x7f);
		pPatchEvent->byMSB = BYTE((dwPatch >> 16) & 0x7f);
		pPatchEvent->byLSB = BYTE((dwPatch >> 8) & 0x7f);
	//	pPatchEvent->byPad[0] = 0;

		SendPMsg( (DMUS_PMSG *)pPatchEvent );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CSequenceMgr::PlayNote

void CSequenceMgr::PlayNote( CSequenceItem *pSequence )
{
	ASSERT( pSequence );

	if( !pSequence || !m_pIDMPerformance )
	{
		return;
	}

	// Stop any playing note
	StopNote();

	DMUS_MIDI_PMSG *pMIDIOnEvent = NULL;
	if( FAILED( m_pIDMPerformance->AllocPMsg( sizeof(DMUS_MIDI_PMSG), (DMUS_PMSG **)&pMIDIOnEvent ) ) )
	{
		return;
	}

	// If there currently is no primary segment playing, try and play the patch for this PChannel
	REFERENCE_TIME rtLatency;
	m_pIDMPerformance->GetLatencyTime( &rtLatency );
	MUSIC_TIME mtLatency;
	m_pIDMPerformance->ReferenceToMusicTime( rtLatency, &mtLatency );

	IDirectMusicSegmentState *pSegState;
	if( FAILED( m_pIDMPerformance->GetSegmentState( &pSegState, mtLatency ) ) )
	{
		PlayPatch( pSequence->AbsTime() );
	}
	else
	{
		pSegState->Release();
	}

	ASSERT( pMIDIOnEvent != NULL );
	ZeroMemory( pMIDIOnEvent, sizeof(DMUS_MIDI_PMSG) );
	// PMSG fields
	pMIDIOnEvent->dwSize = sizeof(DMUS_MIDI_PMSG);
	m_pIDMPerformance->GetLatencyTime( &rtLatency );
	pMIDIOnEvent->rtTime = rtLatency + 5000; // Add 0.5ms
//	pMIDIOnEvent->mtTime = 0;
	pMIDIOnEvent->dwFlags = DMUS_PMSGF_REFTIME;
	pMIDIOnEvent->dwPChannel = m_dwPChannel;
	pMIDIOnEvent->dwVirtualTrackID = 1;
//	pMIDIOnEvent->pTool = NULL;
//	pMIDIOnEvent->pGraph = NULL;
	pMIDIOnEvent->dwType = DMUS_PMSGT_MIDI;
//	pMIDIOnEvent->punkUser = 0;

	// DMNoteEvent fields
	pMIDIOnEvent->bStatus = MIDI_NOTEON;
	pMIDIOnEvent->bByte1 = pSequence->m_bByte1;
	pMIDIOnEvent->bByte2 = pSequence->m_bByte2;
//	pMIDIOnEvent->bPad[0] = 0;

	SendPMsg( (DMUS_PMSG *)pMIDIOnEvent );
	// The playback engine will release the event

	//TRACE("Note On sent at %I64x for %x on %x.\n", pMIDIOffEvent->rtTime, pMIDIOnEvent->bByte1, m_dwPChannel );

	// Reset the time and value of the last note played
	m_rtLastPlayNoteOffTime = rtLatency + 10000;
	m_bLastPlayNoteMIDIValue = pSequence->m_bByte1;

	return;
}


/////////////////////////////////////////////////////////////////////////////
// CSequenceMgr::StopNote

void CSequenceMgr::StopNote( void )
{
	if( !m_pIDMPerformance )
	{
		return;
	}

	if( !m_rtLastPlayNoteOffTime ) 
	{
		return;
	}

	DMUS_MIDI_PMSG *pMIDIOffEvent = NULL;
	if( FAILED( m_pIDMPerformance->AllocPMsg( sizeof(DMUS_MIDI_PMSG), (DMUS_PMSG **)&pMIDIOffEvent ) ) )
	{
		return;
	}

	REFERENCE_TIME rtLatency;
	if( SUCCEEDED( m_pIDMPerformance->GetLatencyTime( &rtLatency ) )
	&&	(rtLatency > m_rtLastPlayNoteOffTime) )
	{
		m_rtLastPlayNoteOffTime = rtLatency;
	}

	ASSERT( pMIDIOffEvent != NULL );
	ZeroMemory( pMIDIOffEvent, sizeof(DMUS_MIDI_PMSG) );
	// PMSG fields
	pMIDIOffEvent->dwSize = sizeof(DMUS_MIDI_PMSG);
	pMIDIOffEvent->rtTime = m_rtLastPlayNoteOffTime;
//	pMIDIOffEvent->mtTime = 0;
	pMIDIOffEvent->dwFlags = DMUS_PMSGF_REFTIME;
	pMIDIOffEvent->dwPChannel = m_dwPChannel;
	pMIDIOffEvent->dwVirtualTrackID = 1;
//	pMIDIOffEvent->pTool = NULL;
//	pMIDIOffEvent->pGraph = NULL;
	pMIDIOffEvent->dwType = DMUS_PMSGT_MIDI;
//	pMIDIOffEvent->punkUser = 0;

	// DMNoteEvent fields
	pMIDIOffEvent->bStatus = MIDI_NOTEOFF;
	pMIDIOffEvent->bByte1 = m_bLastPlayNoteMIDIValue;
//	pMIDIOffEvent->bByte2 = 0;
//	pMIDIOffEvent->bPad[0] = 0;

	SendPMsg( (DMUS_PMSG *)pMIDIOffEvent );
	// The playback engine will release the event

	//TRACE("Note Off sent at %I64x for %x on %x.\n", pMIDIOffEvent->rtTime, pMIDIOnEvent->bByte1, m_dwPChannel );

	// Reset the time and value of the last note played
	m_rtLastPlayNoteOffTime = 0;

	return;
}


/////////////////////////////////////////////////////////////////////////////
// CSequenceMgr::SendPMsg

HRESULT CSequenceMgr::SendPMsg( DMUS_PMSG *pPMsg )
{
	if( !m_pIDMPerformance )
	{
		return E_FAIL;
	}

	HRESULT hr = E_FAIL;
	IDirectMusicPerformance8 *pDMPerf8;
	if( SUCCEEDED( m_pIDMPerformance->QueryInterface( IID_IDirectMusicPerformance8, (void **)&pDMPerf8 ) ) )
	{
		IDirectMusicAudioPath *pDMAudioPath;
		if( SUCCEEDED( pDMPerf8->GetDefaultAudioPath( &pDMAudioPath ) ) )
		{
			if( (pPMsg->dwPChannel == DMUS_PCHANNEL_BROADCAST_AUDIOPATH)
			||	(pPMsg->dwPChannel == DMUS_PCHANNEL_BROADCAST_SEGMENT) )
			{
				pPMsg->dwPChannel = DMUS_PCHANNEL_BROADCAST_PERFORMANCE;
			}

			if( (pPMsg->dwPChannel >= DMUS_PCHANNEL_BROADCAST_GROUPS)
			||	SUCCEEDED( pDMAudioPath->ConvertPChannel( pPMsg->dwPChannel, &pPMsg->dwPChannel ) ) )
			{
				hr = pDMPerf8->SendPMsg( pPMsg );
			}
			pDMAudioPath->Release();
		}
		pDMPerf8->Release();
	}

	return hr;
}

/////////////////////////////////////////////////////////////////////////////
// CSequenceMgr::OffsetSelectedNoteDurationAndVelocity

BOOL CSequenceMgr::OffsetSelectedNoteDurationAndVelocity( long lDuration, long lVelocity, BOOL fMakeCopy )
{
	//TODO: Implement fMakeCopy parameter (make a copy of the notes, don't change the existing ones)
	UNREFERENCED_PARAMETER(fMakeCopy);

	BOOL fChange = FALSE;

	CSequenceItem* pSequenceItem;
	POSITION pos2, pos = m_lstSequences.GetHeadPosition();
	while( pos )
	{
		pos2 = pos;
		pSequenceItem = m_lstSequences.GetNext( pos );
		if( pSequenceItem->m_fSelected )
		{
			if( lDuration != 0 )
			{
				long lNewValue = pSequenceItem->m_mtDuration + lDuration;

				if( lNewValue < 1 )
				{
					lNewValue = 1;
				}
				if( lNewValue != pSequenceItem->m_mtDuration )
				{
					// Duplicate the note if fMakeCopy is set
					if( fMakeCopy )
					{
						CSequenceItem *pSeqItem = new CSequenceItem( pSequenceItem );
						pSeqItem->m_fSelected = FALSE;
						m_lstSequences.InsertBefore( pos2, pSeqItem );
					}

					fChange = TRUE;
					pSequenceItem->m_mtDuration = lNewValue;
				}
			}

			if( lVelocity != 0 )
			{
				long lNewValue = pSequenceItem->m_bByte2 + lVelocity;

				if( lNewValue < 1 )
				{
					lNewValue = 1;
				}
				if( lNewValue > 127 )
				{
					lNewValue = 127;
				}
				if( lNewValue != pSequenceItem->m_bByte2 )
				{
					// Duplicate the note if fMakeCopy is set
					if( fMakeCopy )
					{
						CSequenceItem *pSeqItem = new CSequenceItem( pSequenceItem );
						pSeqItem->m_fSelected = FALSE;
						m_lstSequences.InsertBefore( pos2, pSeqItem );
					}

					fChange = TRUE;
					pSequenceItem->m_bByte2 = (BYTE)lNewValue;

					if( pSequenceItem == m_pSequenceStrip->m_pActiveNote )
					{
						PlayNote( pSequenceItem );
					}
				}
			}
		}
	}

	if( fChange )
	{
		m_pSequenceStrip->InvalidateStrip();
		RefreshPropertyPage();
	}

	return fChange;
}


/////////////////////////////////////////////////////////////////////////////
// CSequenceMgr::OffsetSelectedNoteValuePositionAndStart

BOOL CSequenceMgr::OffsetSelectedNoteValuePositionAndStart( int nValue, long lMoveOffset, long lStartOffset, BOOL fMakeCopy )
{
	//TODO: Implement fMakeCopy parameter (make a copy of the notes, don't change the existing ones)
	UNREFERENCED_PARAMETER(fMakeCopy);

	BOOL fChange = FALSE;

	// Compute the length of the pickup bar
	long lEarlyMeasureClocks = 0;
	DMUS_TIMESIGNATURE ts;
	if( SUCCEEDED( m_pTimeline->GetParam( GUID_TimeSignature, m_dwGroupBits, m_dwIndex, 0, NULL, &ts ) ) )
	{
		lEarlyMeasureClocks = -ts.bBeatsPerMeasure * ((DMUS_PPQ * 4) / ts.bBeat);
	}

	// Compute the length of the extension bar
	long lLateMeasureClocks = 0;
	if( SUCCEEDED( m_pTimeline->GetParam( GUID_TimeSignature, m_dwGroupBits, m_dwIndex, m_pSequenceStrip->m_mtLength - 1, NULL, &ts ) ) )
	{
		lLateMeasureClocks = ts.bBeatsPerMeasure * ((DMUS_PPQ * 4) / ts.bBeat);
	}

	CTypedPtrList<CPtrList, CSequenceItem*> lstMovedSequences;
	CSequenceItem* pSequenceItem;
	POSITION pos2, pos = m_lstSequences.GetHeadPosition();
	while( pos )
	{
		pos2 = pos;
		pSequenceItem = m_lstSequences.GetNext( pos );
		if( pSequenceItem->m_fSelected )
		{
			if( nValue != 0 )
			{
				int nNewValue = pSequenceItem->m_bByte1 + nValue;

				if( nNewValue < 0 )
				{
					nNewValue = 0;
				}
				if( nNewValue > 127 )
				{
					nNewValue = 127;
				}
				if( nNewValue != pSequenceItem->m_bByte1 )
				{
					// Duplicate the note if fMakeCopy is set
					if( fMakeCopy )
					{
						CSequenceItem *pSeqItem = new CSequenceItem( pSequenceItem );
						pSeqItem->m_fSelected = FALSE;
						m_lstSequences.InsertBefore( pos2, pSeqItem );
					}

					fChange = TRUE;
					pSequenceItem->m_bByte1 = (BYTE)nNewValue;

					if( pSequenceItem == m_pSequenceStrip->m_pActiveNote )
					{
						PlayNote( pSequenceItem );
					}
				}
			}

			// TODO: These could be optimized into two functions, one for lMoveOffset < 0
			// (using GetPrev() to step through the list, and one for lMoveOffset > 0
			// (using GetNext() to step through the list.
			if( lMoveOffset != 0 )
			{
				// Note: Don't use AbsTime() here - we only want to modify m_mtTime
				long lNewValue = pSequenceItem->MusicTime() + lMoveOffset;

				if( lNewValue < 0 )
				{
					lNewValue = 0;
				}
				if( lNewValue >= m_pSequenceStrip->m_mtLength )
				{
					lNewValue = m_pSequenceStrip->m_mtLength - 1;
				}

				// Now ensure lAbsTime does not put the event more than one measure ahead of the sequence
				long lAbsTime = lNewValue + pSequenceItem->m_nOffset;
				if(lAbsTime < lEarlyMeasureClocks )
				{
					lAbsTime = lEarlyMeasureClocks;
				}

				// Now ensure lStartTime does not put the event more than one measure after the segment
				if( lAbsTime > m_pSequenceStrip->m_mtLength - 1 + lLateMeasureClocks )
				{
					lAbsTime = m_pSequenceStrip->m_mtLength - 1 + lLateMeasureClocks;
				}

				lNewValue = lAbsTime - pSequenceItem->m_nOffset;

				/*
				long lNewMusicTime = pSequenceItem->MusicTime();
				long lNewOffset = pSequenceItem->m_nOffset;

				ASSERT( lNewMusicTime >= 0 );

				if( (lNewMusicTime == 0)
				&&	(lNewOffset < 0) )
				{
					lNewOffset += lMoveOffset;
					if( lNewOffset > 0 )
					{
						lNewMusicTime = lNewOffset;
						lNewOffset = 0;

						// Ensure the music time is before the segment's end
						if( lNewMusicTime >= m_pSequenceStrip->m_mtLength )
						{
							lNewMusicTime = m_pSequenceStrip->m_mtLength - 1;
						}
					}

					// Now ensure the event is not more than one measure ahead of the sequence
					ASSERT( lNewMusicTime + lNewOffset >= lEarlyMeasureClocks );
					//if( lNewMusicTime + lNewOffset < lEarlyMeasureClocks )
					//{
					//	lNewOffset = lEarlyMeasureClocks;
					//}
				}
				else
				{
					lNewMusicTime += lMoveOffset;

					if( lNewMusicTime < 0 )
					{
						lNewOffset += lNewMusicTime;
						lNewMusicTime = 0;
					}
					if( lNewMusicTime >= m_pSequenceStrip->m_mtLength )
					{
						lNewMusicTime = m_pSequenceStrip->m_mtLength - 1;
					}

					// Now ensure the event is not more than one measure ahead of the sequence
					ASSERT( lNewMusicTime + lNewOffset >= lEarlyMeasureClocks );
					//if( lNewMusicTime + lNewOffset < lEarlyMeasureClocks )
					//{
					//	lNewOffset = lEarlyMeasureClocks - lNewMusicTime;
					//}
				}

				lNewOffset = max( SHRT_MIN, min( SHRT_MAX, lNewOffset ) );

				// Now ensure lStartTime does not put the event more than one measure after the segment
				ASSERT( lNewMusicTime <= m_pSequenceStrip->m_mtLength - 1 + lLateMeasureClocks - lNewOffset );
				//if( lNewMusicTime > m_pSequenceStrip->m_mtLength - 1 + lLateMeasureClocks - lNewOffset)
				//{
				//	lNewMusicTime = m_pSequenceStrip->m_mtLength - 1 + lLateMeasureClocks - lNewOffset;
				//}

				if( (lNewMusicTime != pSequenceItem->MusicTime())
				||	(lNewOffset != pSequenceItem->m_nOffset) )
				*/
				if( lNewValue != pSequenceItem->MusicTime() )
				{
					// Duplicate the note if fMakeCopy is set
					if( fMakeCopy )
					{
						CSequenceItem *pSeqItem = new CSequenceItem( pSequenceItem );
						pSeqItem->m_fSelected = FALSE;
						if( lMoveOffset < 0 )
						{
							m_lstSequences.InsertAfter( pos2, pSeqItem );
						}
						else
						{
							m_lstSequences.InsertBefore( pos2, pSeqItem );
						}
					}

					fChange = TRUE;
					pSequenceItem->MusicTime() = lNewValue;
					/*
					pSequenceItem->m_nOffset = short(lNewOffset);
					*/

					// If lMoveOffset < 0, only add to lstMovedSequences if we're now before
					// the item before the one at pos2.
					if( lMoveOffset < 0 )
					{
						POSITION pos3 = pos2;
						m_lstSequences.GetPrev( pos3 );
						if( pos3 )
						{
							//CSequenceItem* pItem = m_lstSequences.GetAt( pos3 );
							if( pSequenceItem->AbsTime() < m_lstSequences.GetAt( pos3 )->AbsTime() )
							{
								m_lstSequences.RemoveAt( pos2 );
								lstMovedSequences.AddTail( pSequenceItem );
							}
						}
					}

					// If lMoveOffset > 0, only add to lstMovedSequences if we're now after
					// the item at pos.
					else if( pos && lMoveOffset > 0 )
					{
						//CSequenceItem* pItem = m_lstSequences.GetAt( pos );
						if( pSequenceItem->AbsTime() > m_lstSequences.GetAt( pos )->AbsTime() )
						{
							m_lstSequences.RemoveAt( pos2 );
							lstMovedSequences.AddTail( pSequenceItem );
						}
					}
				}
			}

			// TODO: These could be optimized into two functions, one for lStartOffset < 0
			// (using GetPrev() to step through the list, and one for lStartOffset > 0
			// (using GetNext() to step through the list.
			if( lStartOffset != 0 )
			{
				/*
				long lNewMusicTime = pSequenceItem->MusicTime();
				long lNewOffset = pSequenceItem->m_nOffset;
				long lNewDuration = pSequenceItem->m_mtDuration - lStartOffset;

				ASSERT( lNewDuration > 0 );

				ASSERT( lNewMusicTime >= 0 );

				if( (lNewMusicTime == 0)
				&&	(lNewOffset <= 0) )
				{
					lNewOffset += lMoveOffset;
					if( lNewOffset > 0 )
					{
						lNewMusicTime = lNewOffset;
						lNewOffset = 0;
					}

					// Ensure the event is not more than one measure ahead of the sequence
					ASSERT( lNewMusicTime + lNewOffset >= lEarlyMeasureClocks );

					// Ensure the event starts before the end of the segment
					ASSERT( lNewMusicTime < m_pSequenceStrip->m_mtLength );
				}
				else
				{
					lNewMusicTime += lMoveOffset;

					// Ensure the event is not more than one measure ahead of the sequence
					if( lNewMusicTime + lNewOffset < lEarlyMeasureClocks )
					{
						lNewMusicTime += lEarlyMeasureClocks - (lNewMusicTime + lNewOffset);
					}

					if( lNewMusicTime < 0 )
					{
						lNewOffset += lNewMusicTime;
						lNewMusicTime = 0;
					}
					if( lNewMusicTime >= m_pSequenceStrip->m_mtLength )
					{
						lNewMusicTime = m_pSequenceStrip->m_mtLength - 1;
					}
				}
				*/

				// Note: Don't use AbsTime() here - we only want to modify m_mtTime
				long lNewValue = pSequenceItem->MusicTime() + lStartOffset;
				long lNewDuration = pSequenceItem->m_mtDuration - lStartOffset;

				if( lNewValue < 0 )
				{
					lNewDuration += lNewValue;
					lNewValue = 0;
				}
				if( lNewValue >= m_pSequenceStrip->m_mtLength )
				{
					lNewDuration += lNewValue - m_pSequenceStrip->m_mtLength - 1;
					lNewValue = m_pSequenceStrip->m_mtLength - 1;
				}
				if( lNewDuration <= 0 )
				{
					lNewValue += lNewDuration - 1;
					lNewDuration = 1;
				}

				// Now ensure lAbsTime does not put the event more than one measure ahead of the sequence
				long lAbsTime = lNewValue + pSequenceItem->m_nOffset;
				if( lAbsTime < lEarlyMeasureClocks )
				{
					lAbsTime = lEarlyMeasureClocks;
				}

				// Now ensure lStartTime does not put the event more than one measure after the segment
				if( lAbsTime > m_pSequenceStrip->m_mtLength - 1 + lLateMeasureClocks )
				{
					lAbsTime = m_pSequenceStrip->m_mtLength - 1 + lLateMeasureClocks;
				}

				lNewValue = lAbsTime - pSequenceItem->m_nOffset;

				if( lNewValue != pSequenceItem->MusicTime() )
				{
					fChange = TRUE;
					pSequenceItem->MusicTime() = lNewValue;
					pSequenceItem->m_mtDuration = lNewDuration;

					// If lStartOffset < 0, only add to lstMovedSequences if we're now before
					// the item before the one at pos2.
					if( lStartOffset < 0 )
					{
						POSITION pos3 = pos2;
						m_lstSequences.GetPrev( pos3 );
						if( pos3 )
						{
							//CSequenceItem* pItem = m_lstSequences.GetAt( pos3 );
							if( pSequenceItem->AbsTime() < m_lstSequences.GetAt( pos3 )->AbsTime() )
							{
								m_lstSequences.RemoveAt( pos2 );
								lstMovedSequences.AddTail( pSequenceItem );
							}
						}
					}

					// If lStartOffset > 0, only add to lstMovedSequences if we're now after
					// the item at pos.
					else if( pos && lStartOffset > 0 )
					{
						//CSequenceItem* pItem = m_lstSequences.GetAt( pos );
						if( pSequenceItem->AbsTime() > m_lstSequences.GetAt( pos )->AbsTime() )
						{
							m_lstSequences.RemoveAt( pos2 );
							lstMovedSequences.AddTail( pSequenceItem );
						}
					}
				}
			}
		}
	}

	if( fChange )
	{
		if( !lstMovedSequences.IsEmpty() )
		{
			MergeSequence( lstMovedSequences );
		}

		m_pSequenceStrip->InvalidateStrip();
		RefreshPropertyPage();
	}

	return fChange;
}

void CSequenceMgr::MergeSequence( CTypedPtrList<CPtrList, CSequenceItem*>& lstSequences )
{
	// We assume lstSequences is in sorted (ascending) order
	if( lstSequences.IsEmpty() )
	{
		return;
	}

	POSITION pos = m_lstSequences.GetHeadPosition();
	while( !lstSequences.IsEmpty() )
	{
		CSequenceItem *pMergeSeq = lstSequences.RemoveHead();

		while( pos && (pMergeSeq->AbsTime() > m_lstSequences.GetAt(pos)->AbsTime()) )
		{
			m_lstSequences.GetNext( pos );
		}

		if( pos )
		{
			m_lstSequences.InsertBefore( pos, pMergeSeq );
		}
		else
		{
			m_lstSequences.AddTail( pMergeSeq );
		}
	}
}

void CSequenceMgr::MergeCurve( CTypedPtrList<CPtrList, CCurveItem*>& lstCurves )
{
	// We assume lstCurves is in sorted (ascending) order
	if( lstCurves.IsEmpty() )
	{
		return;
	}

	POSITION pos = m_lstCurves.GetHeadPosition();
	while( !lstCurves.IsEmpty() )
	{
		CCurveItem *pMergeCurve = lstCurves.RemoveHead();

		while( pos && (pMergeCurve->AbsTime() > m_lstCurves.GetAt(pos)->AbsTime()) )
		{
			m_lstCurves.GetNext( pos );
		}

		if( pos )
		{
			m_lstCurves.InsertBefore( pos, pMergeCurve );
		}
		else
		{
			m_lstCurves.AddTail( pMergeCurve );
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CSequenceMgr::GetNumSelected

int CSequenceMgr::GetNumSelected()
{
	int nRes = 0;
	POSITION pos = m_lstSequences.GetHeadPosition();
	while( pos )
	{
		if( m_lstSequences.GetNext(pos)->m_fSelected )
		{
			nRes++;
		}
	}
	return nRes;
}


/////////////////////////////////////////////////////////////////////////////
// CSequenceMgr::RefreshPropertyPage

void CSequenceMgr::RefreshPropertyPage( )
{
	bool fFoundOne = false;
	POSITION pos = m_lstSequences.GetHeadPosition();
	while( pos )
	{
		CSequenceItem *pTempSeq = m_lstSequences.GetNext( pos );

		if( pTempSeq->m_fSelected )
		{
			if( fFoundOne )
			{
				CPropSequence propseq(this);
				propseq.Import(pTempSeq);
				m_PropSequence += propseq;
			}
			else
			{
				m_PropSequence.Import(pTempSeq);
				fFoundOne = true;
			}
		}
	}

	// If nothing selected, re-initialize m_PropSequence
	if (!fFoundOne)
	{
		m_PropSequence.Clear();
	}

	//if (!m_fNoDisplayUpdate)
	{
		// Let the property page know about the changes
		if( m_pPropPageMgr )
		{
			m_pPropPageMgr->RefreshData();
		}
	}

	UpdateStatusBarDisplay();
}


/////////////////////////////////////////////////////////////////////////////
// CSequenceMgr::ApplyToSelectedNotes

DWORD CSequenceMgr::ApplyToSelectedNotes( const CPropSequence* pPropNote )
{
	ASSERT( pPropNote != NULL );
	if ( pPropNote == NULL )
	{
		return 0;
	}

	// A list to temporarily store the sequences in if their start times are moved
	CTypedPtrList<CPtrList, CSequenceItem*> lstMovedSequences;

	DWORD dwChanged = 0;
	POSITION pos2, pos = m_lstSequences.GetHeadPosition();
	while( pos )
	{
		pos2 = pos;
		CSequenceItem *pTempSeq = m_lstSequences.GetNext( pos );

		if ( pTempSeq->m_fSelected )
		{
			// If we should copy the note
			if( !(pPropNote->m_dwUndetermined & UD_COPY) )
			{
				// Create a new note
				CSequenceItem *pNewSeq;
				pNewSeq = new CSequenceItem;
				pNewSeq->Copy( pTempSeq );

				// Insert just after the existing note
				pos2 = m_lstSequences.InsertAfter( pos2, pNewSeq );

				pTempSeq->m_fSelected = FALSE;
				pTempSeq = pNewSeq;
			}

			// Save the old start time
			long lOldValue = pTempSeq->AbsTime();

			if (!(pPropNote->m_dwChanged & (UD_CHORDBAR | UD_CHORDBEAT| UD_STARTBARBEATGRIDTICK | UD_ENDBARBEATGRIDTICK | UD_DURBARBEATGRIDTICK)) )
			{
				// We're not changing any start/end/dur bar/beat/grid/tick

				// Apply the changes
				dwChanged |= pPropNote->ApplyToNote(pTempSeq);
			}
			else
			{
				// We're changing at least one of start/end/dur/chord bar/beat/grid/tick
				ASSERT( ~pPropNote->m_dwUndetermined & (UD_CHORDBAR | UD_CHORDBEAT| UD_STARTBARBEATGRIDTICK | UD_ENDBARBEATGRIDTICK | UD_DURBARBEATGRIDTICK) );
				CPropSequence propnote( pTempSeq, this );
				propnote.ApplyPropNote( pPropNote );

				// Duration, GridStart, and Offset should all be determined
				ASSERT( (propnote.m_dwUndetermined & (UD_DURATION | UD_TIMESTART | UD_OFFSET)) == 0);
				propnote.m_dwUndetermined = DWORD(~(UD_DURATION | UD_TIMESTART | UD_OFFSET));

				// Apply the changes
				dwChanged |= propnote.ApplyToNote(pTempSeq);
			}

			// If the note's start position changed, remove and re-add it to the list
			if( lOldValue != pTempSeq->AbsTime() )
			{
				// If moved backwards, only add to lstMovedSequences if we're now before
				// the item before the one at pos2.
				if( pTempSeq->AbsTime() < lOldValue )
				{
					POSITION pos3 = pos2;
					m_lstSequences.GetPrev( pos3 );
					if( pos3 )
					{
						//CSequenceItem* pItem = m_lstSequences.GetAt( pos3 );
						if( pTempSeq->AbsTime() < m_lstSequences.GetAt( pos3 )->AbsTime() )
						{
							// Need to move pTempSeq, so remove it from its current location
							m_lstSequences.RemoveAt( pos2 );

							lstMovedSequences.AddTail( pTempSeq );

							// This should be fine
							//InsertByAscendingTimeBackwardsFrom( pTempSeq, pos3 );
						}
					}
				}
				// If moved forwards, only add to lstMovedSequences if we're now after
				// the item at pos.
				else if( pos )
				{
					//CSequenceItem* pItem = m_lstSequences.GetAt( pos );
					if( pTempSeq->AbsTime() > m_lstSequences.GetAt( pos )->AbsTime() )
					{
						// Need to move pTempSeq, so remove it from its current location
						m_lstSequences.RemoveAt( pos2 );

						lstMovedSequences.AddTail( pTempSeq );

						// If we do this, the notes will be changed repeatedly...
						//InsertByAscendingTimeFrom( pTempSeq, pos );
					}
				}
			}
		}
	}

	if( !lstMovedSequences.IsEmpty() )
	{
		MergeSequence( lstMovedSequences );
	}

	return dwChanged;
}


/////////////////////////////////////////////////////////////////////////////
// CSequenceMgr::InsertByAscendingTimeFrom
/*
void CSequenceMgr::InsertByAscendingTimeFrom( CSequenceItem *pSequence, POSITION pos )
{
	// This optimization probably isn't worth the space - jhd
	// Move pos3 to the next item in the list (since we already
	// checked the one at pos3)
	m_lstSequences.GetNext( pos3 );
	if( pos3 )
	{
		pItem = m_lstSequends.GetAt( pos3 );
	}

	// Iterate until pos3 points to the location to insert after
	POSITION pos3 = pos;
	while( pos3 && (pTempSeq->AbsTime() > pItem->AbsTime()) )
	{
		m_lstSequences.GetNext( pos3 );
		if( pos3 )
		{
			pItem = m_lstSequends.GetAt( pos3 );
		}
	}

	// Insert pTempSeq back into the correct point in the list
	if( pos3 )
	{
		m_lstSequences.InsertBefore( pos3, pTempSeq );
	}
	else
	{
		m_lstSequences.AddTail( pTempSeq );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CSequenceMgr::InsertByAscendingTimeBackwardsFrom

void CSequenceMgr::InsertByAscendingTimeBackwardsFrom( CSequenceItem *pSequence, POSITION pos )
{
	// This optimization probably isn't worth the space - jhd
	// Move pos3 to the previous item in the list (since we already
	// checked the one at pos3)
	m_lstSequences.GetPrev( pos3 );
	if( pos3 )
	{
		pItem = m_lstSequends.GetAt( pos3 );
	}

	// Iterate until pos3 points to the location to insert after
	while( pos3 && (pTempSeq->AbsTime() < pItem->AbsTime()) )
	{
		m_lstSequences.GetPrev( pos3 );
		if( pos3 )
		{
			pItem = m_lstSequends.GetAt( pos3 );
		}
	}

	// Insert pTempSeq back into the correct point in the list
	if( pos3 )
	{
		m_lstSequences.InsertAfter( pos3, pTempSeq );
	}
	else
	{
		m_lstSequences.AddHead( pTempSeq );
	}
	}
*/


/////////////////////////////////////////////////////////////////////////////
// CSequenceMgr::InsertNote

void CSequenceMgr::InsertNote( CSequenceItem *pSequence, BOOL fUpdateSegment )
{
	//TRACE("InsertNote In %d\n",  ::timeGetTime());
	ASSERT( pSequence != NULL );
	if( pSequence == NULL )
	{
		return;
	}

	InsertByAscendingTime( pSequence );
	m_fDirty = TRUE;

	if( fUpdateSegment )
	{
		// Let the object know about the changes
		m_pSequenceStrip->m_nLastEdit = IDS_UNDO_INSERT;
		OnDataChanged( );
	}
	else
	{
		m_fNoteInserted = TRUE;
	}

	// Invalidate only this note
	RECT rect;
	if( m_pSequenceStrip->m_svView == SV_MINIMIZED )
	{
		rect.top = 0;
		rect.bottom = MINIMIZE_HEIGHT;
		m_pTimeline->ClocksToPosition( pSequence->AbsTime(), &rect.left );
		m_pTimeline->ClocksToPosition( pSequence->AbsTime() + pSequence->m_mtDuration, &rect.right );
	}
	else
	{
		m_pSequenceStrip->GetNoteRect( pSequence, &rect );
		if( m_pSequenceStrip->m_fHybridNotation )
		{
			// Extend to the left so the accidental is drawn
			rect.left -= ((m_pSequenceStrip->m_lMaxNoteHeight * 3) / 2) + 2;

			// Extend to the top and bottom so the parts of the accidental that extend outside
			// the note are drawn
			rect.top -= m_pSequenceStrip->m_lMaxNoteHeight / 2;
			rect.bottom += m_pSequenceStrip->m_lMaxNoteHeight / 2;

			// Extend to the end of the measure
			long lTime;
			m_pTimeline->ClocksToMeasureBeat( m_dwGroupBits, m_dwIndex, pSequence->AbsTime(), &lTime, NULL );
			m_pTimeline->MeasureBeatToClocks( m_dwGroupBits, m_dwIndex, lTime + 1, 0, &lTime );

			// If the end of the measure is after the end of the note, extent the
			// invalidation to the right
			if( lTime > pSequence->AbsTime() + pSequence->m_mtDuration )
			{
				m_pTimeline->ClocksToPosition( lTime, &rect.right );
			}

			// Ensure the measure line is drawn correctly
			rect.right++;
		}
	}

	m_pTimeline->StripInvalidateRect( m_pSequenceStrip, &rect, FALSE );
	//TRACE("InsertNote out %d\n",  ::timeGetTime());
}


/////////////////////////////////////////////////////////////////////////////
// CSequenceMgr::InsertCurve

void CSequenceMgr::InsertCurve( CCurveItem *pCurve, BOOL fUpdateSegment )
{
	//TRACE("InsertCurve In %d\n",  ::timeGetTime());
	ASSERT( pCurve != NULL );
	if( pCurve == NULL )
	{
		return;
	}

	InsertByAscendingTime( pCurve );
	m_fDirty = TRUE;

	if( fUpdateSegment )
	{
		// Let the object know about the changes
		m_pSequenceStrip->m_nLastEdit = IDS_UNDO_INSERT_CURVE;
		OnDataChanged( );
	}
	else
	{
		m_fCurveInserted = TRUE;
	}

	// Invalidate only this curve strip (no need to redraw if the sequence strip is minimized)
	if( m_pSequenceStrip->m_svView != SV_MINIMIZED )
	{
		if( m_pSequenceStrip->m_CurveStripView != SV_MINIMIZED )
		{
			CCurveStrip* pCurveStrip = m_pSequenceStrip->GetCurveStrip( m_pSequenceStrip->CurveTypeToStripCCType( pCurve ), pCurve->m_wParamType );
			ASSERT( pCurveStrip );
			if( pCurveStrip )
			{
				m_pTimeline->StripInvalidateRect( (IDMUSProdStrip*)pCurveStrip, NULL, TRUE );
			}
		}
		else
		{
			// Redraw the minimized curve strip
			CCurveStrip* pCurveStrip = m_pSequenceStrip->GetCurveStrip( CCTYPE_MINIMIZED_CURVE_STRIP, 0 );
			ASSERT( pCurveStrip );
			if( pCurveStrip )
			{
				m_pTimeline->StripInvalidateRect( (IDMUSProdStrip*)pCurveStrip, NULL, TRUE );
			}
		}
	}

	//TRACE("InsertCurve out %d\n",  ::timeGetTime());
}


/////////////////////////////////////////////////////////////////////////////
// CSequenceMgr::UpdateFlatsAndKey

BOOL CSequenceMgr::UpdateFlatsAndKey()
{
	BOOL fChange = FALSE;

	// Get the show Flats/Sharps flag
	BOOL fShowFlats = FALSE;
	if( m_pTimeline && m_pSequenceStrip && SUCCEEDED( m_pTimeline->GetParam( GUID_ChordSharpsFlats, m_dwGroupBits, m_dwIndex, 0, NULL, &fShowFlats) ) )
	{
		if( m_fDisplayingFlats != fShowFlats )
		{
			m_fDisplayingFlats = fShowFlats;
			fChange = TRUE;
		}
	}

	DWORD dwKey = 0;
	if( m_pTimeline && m_pSequenceStrip &&
		SUCCEEDED( m_pTimeline->GetParam( GUID_ChordKey, m_dwGroupBits, m_dwIndex, 0, NULL, &dwKey) ) )
	{
		int nNewKeyRoot, nNewNumAccidentals;
		nNewKeyRoot = dwKey & 0x0000FFFF;
		nNewKeyRoot %= 12;
		nNewNumAccidentals = (dwKey & 0xFFFF0000) >> 16;
		nNewNumAccidentals = min( nNewNumAccidentals, 7 );
		if( nNewKeyRoot != m_nKeyRoot )
		{
			m_nKeyRoot = nNewKeyRoot;
			fChange = TRUE;
		}
		if( nNewNumAccidentals != m_nNumAccidentals )
		{
			m_nNumAccidentals = nNewNumAccidentals;
			fChange = TRUE;
		}
	}

	if( fChange )
	{
		// Update KeyPattern
		m_pSequenceStrip->UpdateKeyPattern();

		// If displaying in hybrid notation
		if( m_pSequenceStrip->m_fHybridNotation )
		{
			// Redraw our strip
			m_pSequenceStrip->InvalidateStrip();
		}

		if( m_pPropPageMgr )
		{
			m_pPropPageMgr->RefreshData();
		}
	}

	return fChange;
}


/////////////////////////////////////////////////////////////////////////////
// CSequenceMgr::LoadSequenceUIList

HRESULT CSequenceMgr::LoadSequenceUIList( IDMUSProdRIFFStream* pIRiffStream, MMCKINFO *pckMain )
{
	IStream* pIStream;
	HRESULT hr = S_OK;
	MMCKINFO ck;
	DWORD dwByteCount;
	DWORD dwSize;

    pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

    while( pIRiffStream->Descend( &ck, pckMain, 0 ) == 0 )
	{
        switch( ck.ckid )
		{
			case DMUS_FOURCC_SEQUENCE_UI_CHUNK:
			{
				ioSeqStripDesign iSeqStripDesign;

				InitializeSeqStripDesign( &iSeqStripDesign );
				dwSize = min( ck.cksize, sizeof( ioSeqStripDesign ) );
				hr = pIStream->Read( &iSeqStripDesign, dwSize, &dwByteCount );
				if( FAILED( hr )
				||  dwByteCount != dwSize )
				{
					hr = E_FAIL;
					goto ON_ERROR;
				}

				// Check for garbage data from earlier versions of file format
				if( iSeqStripDesign.m_dwExtraBars > 999 )
				{
					iSeqStripDesign.m_dwExtraBars = 0;
				}
				if( iSeqStripDesign.m_fPickupBar > 1 )
				{
					iSeqStripDesign.m_fPickupBar = FALSE;
				}

				memcpy( &m_SeqStripDesign, &iSeqStripDesign, dwSize );
				break;
			}

			case DMUS_FOURCC_ALLCURVES_UI_CHUNK:
			{
				ioGlobalCurveStripState iGlobalCurveStripState;

				// Prepare ioGlobalCurveStripState structure
				memset( &iGlobalCurveStripState, 0, sizeof(ioGlobalCurveStripState) );
				
				dwSize = min( ck.cksize, sizeof( ioGlobalCurveStripState ) );
				hr = pIStream->Read( &iGlobalCurveStripState, dwSize, &dwByteCount );
				if( FAILED( hr )
				||  dwByteCount != dwSize )
				{
					hr = E_FAIL;
					goto ON_ERROR;
				}

				if( m_pSequenceStrip )
				{
					m_pSequenceStrip->m_CurveStripView = (STRIPVIEW)iGlobalCurveStripState.m_nCurveStripView;
				}
				break;
			}

			case DMUS_FOURCC_CURVE_UI_CHUNK:
			{
				ioCurveStripState* pCurveStripState = new ioCurveStripState;
				if( pCurveStripState == NULL )
				{
					hr = E_OUTOFMEMORY;
					goto ON_ERROR;
				}

				// Initialize ioCurveStripState structure
				memset( pCurveStripState, 0, sizeof(ioCurveStripState) );

				dwSize = min( ck.cksize, sizeof( ioCurveStripState ) );
				hr = pIStream->Read( pCurveStripState, dwSize, &dwByteCount );
				if( FAILED( hr )
				||  dwByteCount != dwSize )
				{
					delete pCurveStripState;
					hr = E_FAIL;
					goto ON_ERROR;
				}

				if( m_pSequenceStrip )
				{
					m_pSequenceStrip->m_lstCurveStripStates.AddTail( pCurveStripState );
				}
				break;
			}
		}

        pIRiffStream->Ascend( &ck, 0 );
	}

	if( m_pTimeline )
	{
		// Make sure there is a curve strip for each type of Curve in this sequence
		m_pSequenceStrip->SyncCurveStripStateList();
		m_pSequenceStrip->ApplyUIChunk( &m_SeqStripDesign );

		// Add Curve Strips to the Timeline
		m_pSequenceStrip->AddCurveStrips();
	}

ON_ERROR:
    pIStream->Release();
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CSequenceMgr::SaveSequenceUIList

HRESULT CSequenceMgr::SaveSequenceUIList( IDMUSProdRIFFStream* pIRiffStream )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	IStream* pIStream = NULL;
	HRESULT hr = S_OK;
	MMCKINFO ckMain;
	MMCKINFO ck;
	DWORD dwBytesWritten;

    pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );
	if( pIStream == NULL )
	{
		return E_INVALIDARG;
	}

	// Update PChannel #
	m_SeqStripDesign.m_dwPChannel = m_dwPChannel;

	if( m_pSequenceStrip )
	{
		// Write SequenceUI list header
		ckMain.fccType = DMUS_FOURCC_SEQUENCE_UI_LIST;
		if( pIRiffStream->CreateChunk(&ckMain, MMIO_CREATELIST) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}

		// Write SequenceUI chunk header
		ck.ckid = DMUS_FOURCC_SEQUENCE_UI_CHUNK;
		if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}

		// Prepare ioSeqStripDesign structure
		m_pSequenceStrip->UpdateSequenceUIChunk();

		// Write SequenceStrip chunk data
		hr = pIStream->Write( &m_SeqStripDesign, sizeof(ioSeqStripDesign), &dwBytesWritten);
		if( FAILED( hr ) || dwBytesWritten != sizeof(ioSeqStripDesign) )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}

		if( pIRiffStream->Ascend(&ck, 0) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}

		// Write UI state info for this Piano Roll's Curve Strips
		m_pSequenceStrip->SaveCurveStripStateData( pIRiffStream );

		// Ascend out of SequenceUI list chunk
		if( pIRiffStream->Ascend( &ckMain, 0 ) != 0 )
		{
 			hr = E_FAIL;
			goto ON_ERROR;
		}
	}

ON_ERROR:
	if( pIStream != NULL )
	{
		pIStream->Release();
	}
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CSequenceMgr::AddNewPart

HRESULT CSequenceMgr::AddNewPart( void )
{
	// Have user select a PChannel
	CNewPartDlg newPartDlg;

	newPartDlg.SetTrack( 0 );
	newPartDlg.SetSequenceMgr( this );

	// The dialog handles adding parts itself
	newPartDlg.DoModal();

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CSequenceMgr::Quantize

BOOL CSequenceMgr::Quantize( SequenceQuantize* pSequenceQuantize )
{
	CSequenceItem* pSequenceItem;

	BOOL fChanged = FALSE;

	if( pSequenceQuantize->m_bStrength )
	{
		// Flag if we should modify all notes
		const bool fUseAllNotes = (pSequenceQuantize->m_wQuantizeTarget != QUANTIZE_TARGET_SELECTED);

		// Iterate through all events
		// Only quantize notes
		POSITION pos = m_lstSequences.GetHeadPosition();
		while( pos )
		{
			pSequenceItem = m_lstSequences.GetNext( pos );

			if( fUseAllNotes || pSequenceItem->m_fSelected )
			{
				if( QuantizeNote( pSequenceItem, pSequenceQuantize ) )
				{
					fChanged = TRUE;
				}
			}
		}
	}

	if( fChanged )
	{
		m_fDirty = TRUE;

		m_pSequenceStrip->m_nLastEdit = IDS_UNDO_QUANTIZE;
		OnDataChanged();
		m_pSequenceStrip->InvalidateStrip();

		// Always recompute m_SelectedPropNote and update the property page
		RefreshPropertyPage();
	}

	return fChanged;
}


/////////////////////////////////////////////////////////////////////////////
// CSequenceMgr::QuantizeNote

BOOL CSequenceMgr::QuantizeNote( CSequenceItem* pSequenceItem, SequenceQuantize* pSequenceQuantize )
{
	DMUS_TIMESIGNATURE ts;
	MUSIC_TIME mtBeatClocks;
	MUSIC_TIME mtMeasureClocks;
	MUSIC_TIME mtGridClocks;
	BOOL fChanged = FALSE;

	ASSERT( pSequenceItem );
	ASSERT( pSequenceQuantize );
	ASSERT( pSequenceQuantize->m_bResolution );

	if( pSequenceQuantize->m_bStrength )
	{
		if( SUCCEEDED( m_pTimeline->GetParam( GUID_TimeSignature, m_dwGroupBits, m_dwIndex, pSequenceItem->m_mtTime, NULL, &ts ) ) )
		{
			// Compute the number of clocks per Measure, Beat, and Grid
			mtBeatClocks = (DMUS_PPQ * 4) / ts.bBeat;
			mtMeasureClocks = mtBeatClocks * ts.bBeatsPerMeasure;
			mtGridClocks = mtBeatClocks / ts.wGridsPerBeat;
			
			if( pSequenceQuantize->m_dwFlags & SEQUENCE_QUANTIZE_START_TIME )
			{
				// Split m_nOffset into 2 parts
				// 1 - Clocks for an evenly disible number of beats
				//     this represents prop page 'Belongs to Beat' 
				// 2 - Remaining ticks
				//     when m_nOffset is not zero, this represents the tru offset of the note
				long lOrigBeatClocksInOffset, lOrigBeatOffsetClocksInOffset;
				lOrigBeatClocksInOffset = (pSequenceItem->m_nOffset / mtBeatClocks) * mtBeatClocks;
				lOrigBeatOffsetClocksInOffset = pSequenceItem->m_nOffset % mtBeatClocks;

				// Compute the Measure, Beat, and Grid this note occurs in
				long lTempMeas, lTempBeat, lTempGrid, lTempTick, lTempBeatOffset;
				lTempMeas = pSequenceItem->m_mtTime / mtMeasureClocks;
				lTempBeat = pSequenceItem->m_mtTime % mtMeasureClocks;
				lTempGrid = lTempBeat % mtBeatClocks;
				lTempTick = lTempGrid % mtGridClocks;
				lTempBeat /= mtBeatClocks;
				lTempGrid /= mtGridClocks;

				// Compute our offset from lTempMeas and lTempBeat
				lTempBeatOffset = lOrigBeatOffsetClocksInOffset + lTempTick + (lTempGrid * mtGridClocks);

				BOOL fMeasureBeatMatchesChord = TRUE;
				if( (lTempBeatOffset < 0) || (lTempBeatOffset >= mtMeasureClocks) )
				{
					fMeasureBeatMatchesChord = FALSE;
				}

				// Compute how many clocks in a quantize unit
				MUSIC_TIME mtQuantizeClocks;
				mtQuantizeClocks = mtBeatClocks / pSequenceQuantize->m_bResolution;

				// Compute how many quantize units the offset is away from lTempMeas and lTempBeat
				if( lTempBeatOffset >= 0 )
				{
					lTempBeatOffset = (lTempBeatOffset + mtQuantizeClocks/2) / mtQuantizeClocks;
				}
				else
				{
					lTempBeatOffset = (lTempBeatOffset + -mtQuantizeClocks/2) / mtQuantizeClocks;
				}

				// lTempBeatOffset will now contain the new, 100% quantized offset
				// Use mtBeatClocks for each beat, mtQuantizeClocks for each grid.
				// (Otherwise, rounding errors may occur).
				lTempBeatOffset = (lTempBeatOffset % pSequenceQuantize->m_bResolution) * mtQuantizeClocks +
								  (lTempBeatOffset / pSequenceQuantize->m_bResolution) * mtBeatClocks;

				// lDeltaOffset is the amount for 100% quantization
				long lDeltaOffset = lTempBeatOffset - (lOrigBeatOffsetClocksInOffset + lTempTick + (lTempGrid * mtGridClocks));

				// Now, scale it based on bStrength
				lDeltaOffset = (lDeltaOffset * pSequenceQuantize->m_bStrength) / 100;

				if( lDeltaOffset )
				{
					fChanged = TRUE;
					// Calculate the new offset from lTempMeas and lTempBeat
					lTempBeatOffset = lOrigBeatOffsetClocksInOffset + lTempTick + (lTempGrid * mtGridClocks) + lDeltaOffset;

					// Calculate the new Bar,Beat,Grid and offset
					lTempGrid = 0;
					if( fMeasureBeatMatchesChord )
					{
						// Move lTempBeat and/or lTempMeasure to match the new location

						// Move by beats
						while( lTempBeatOffset <= -mtBeatClocks )
						{
							if( lTempBeat )
							{
								lTempBeat--;
							}
							else if( lTempMeas )
							{
								lTempMeas--;
								lTempBeat = ts.bBeatsPerMeasure - 1;
							}
							else
							{
								break;
							}
							lTempBeatOffset += mtBeatClocks;
						}
						while( lTempBeatOffset >= mtBeatClocks )
						{
							if( lTempBeat < ts.bBeatsPerMeasure - 1 )
							{
								lTempBeat++;
							}
							else
							{
								lTempMeas++;
								lTempBeat = 0;
							}
							lTempBeatOffset -= mtBeatClocks;
						}

						// Move by grids
						while( lTempBeatOffset < 0 )
						{
							if( lTempGrid )
							{
								lTempGrid--;
							}
							else if( lTempBeat )
							{
								lTempBeat--;
								lTempGrid = ts.wGridsPerBeat - 1;
							}
							else if ( lTempMeas )
							{
								lTempMeas--;
								lTempBeat = ts.bBeatsPerMeasure - 1;
								lTempGrid = ts.wGridsPerBeat - 1;
							}
							else
							{
								break;
							}
							lTempBeatOffset += mtGridClocks;
						}
						while( lTempBeatOffset >= mtGridClocks )
						{
							if( lTempGrid < ts.wGridsPerBeat - 1 )
							{
								lTempGrid++;
							}
							else if( lTempBeat < ts.bBeatsPerMeasure - 1 )
							{
								lTempBeat++;
								lTempGrid = 0;
							}
							else
							{
								lTempMeas++;
								lTempBeat = 0;
								lTempGrid = 0;
							}
							lTempBeatOffset -= mtGridClocks;
						}
					}
					else
					{
						// Don't touch lTempBeat or lTempMeas
						while( (lTempGrid < ts.wGridsPerBeat - 1) && (lTempBeatOffset > mtGridClocks / 2) )
						{
							lTempGrid++;
							lTempBeatOffset -= mtGridClocks;
						}
					}

					long lOldStartTime = pSequenceItem->AbsTime();

					// Set the note's m_mtTime and m_nOffset
					ASSERT( (lTempBeatOffset < SHRT_MAX) && (lTempBeatOffset > SHRT_MIN) );
					if( pSequenceItem->m_nOffset )
					{
						// User set 'Belongs to Beat' fields 
						// Offset belongs in m_nOffset
						pSequenceItem->m_nOffset = (short)(lTempBeatOffset + lOrigBeatClocksInOffset);
						pSequenceItem->m_mtTime = (lTempMeas * mtMeasureClocks) +
												  (lTempBeat * mtBeatClocks) +
												  (lTempGrid * mtGridClocks);
					}
					else
					{
						// User did not set 'Belongs to Beat' fields 
						// Offset belongs in m_mtTime
						pSequenceItem->m_nOffset = 0;
						pSequenceItem->m_mtTime = (lTempMeas * mtMeasureClocks) +
												  (lTempBeat * mtBeatClocks) +
												  (lTempGrid * mtGridClocks) +
												   lTempBeatOffset;
					}

					if( lOldStartTime != pSequenceItem->AbsTime() )
					{
						// Remove the event from the part's list
						POSITION pos = m_lstSequences.Find( pSequenceItem );
						ASSERT( pos != NULL);	// This should not happen!
						if( pos )
						{
							m_lstSequences.RemoveAt( pos );

							// And re-insert it in order
							InsertByAscendingTime( pSequenceItem );
						}
					}
				}
			}

			if( pSequenceQuantize->m_dwFlags & SEQUENCE_QUANTIZE_DURATION )
			{
				// Compute the Measure, Beat, and Grid of the duration
				long lTempMeas, lTempBeat, lTempBeatOffset;
				lTempMeas = pSequenceItem->m_mtDuration / mtMeasureClocks;
				lTempBeat = (pSequenceItem->m_mtDuration % mtMeasureClocks) / mtBeatClocks;

				// Compute our offset from lTempMeas and lTempBeat
				// This is valid because mtBeatClocks * ts.bBeatsPerMeasure is
				// always equal mtMeasureClocks. (No rounding occurs)
				lTempBeatOffset = pSequenceItem->m_mtDuration % mtBeatClocks;

				// Compute how many clocks in a quantize unit
				MUSIC_TIME mtQuantizeClocks;
				mtQuantizeClocks = mtBeatClocks / pSequenceQuantize->m_bResolution;

				// Compute how many quantize units the offset is away from lTempMeas and lTempBeat
				lTempBeatOffset = (lTempBeatOffset + mtQuantizeClocks/2) / mtQuantizeClocks;

				// lTempBeatOffset will now contain the new, 100% quantized offset
				if( lTempBeatOffset == pSequenceQuantize->m_bResolution )
				{
					// If we're at the next beat, use mtBeatClocks. (Otherwise rounding
					// errors may occur).
					lTempBeatOffset = mtBeatClocks;
				}
				else
				{
					lTempBeatOffset *= mtQuantizeClocks;
				}

				// lDeltaOffset is the amount for 100% quantization
				long lDeltaOffset = lTempBeatOffset - (pSequenceItem->m_mtDuration % mtBeatClocks);

				// Now, scale it based on bStrength
				lDeltaOffset = (lDeltaOffset * pSequenceQuantize->m_bStrength) / 100;

				if( lDeltaOffset )
				{
					fChanged = TRUE;

					// Set the note's m_mtDuration
					pSequenceItem->m_mtDuration += lDeltaOffset;
					pSequenceItem->m_mtDuration = max( pSequenceItem->m_mtDuration, (mtQuantizeClocks - 1) );
				}
			}
		}
	}

	return fChanged;
}


/////////////////////////////////////////////////////////////////////////////
// CSequenceMgr::Velocitize

BOOL CSequenceMgr::Velocitize( SequenceVelocitize* pSequenceVelocitize )
{
	BOOL fChanged = FALSE;

	// Flag if we should modify all notes
	const bool fUseAllNotes = (pSequenceVelocitize->m_wVelocityTarget != VELOCITY_TARGET_SELECTED);

	// The time of the first and last selected notes
	MUSIC_TIME mtFirstSelected = LONG_MAX;
	MUSIC_TIME mtLastSelected = LONG_MIN;
	MUSIC_TIME mtSelectedSpan = 0;
	const long lAbsChangeSpan = pSequenceVelocitize->m_lAbsoluteChangeEnd - pSequenceVelocitize->m_lAbsoluteChangeStart;

	// If doing an absolute change and the start and end values are different
	if( (pSequenceVelocitize->m_dwVelocityMethod != SEQUENCE_VELOCITIZE_COMPRESS)
	&&	(lAbsChangeSpan != 0) )
	{
		// Find the time of the first and last selected notes
		POSITION pos = m_lstSequences.GetHeadPosition();
		while( pos )
		{
			CSequenceItem* pSequenceItem = m_lstSequences.GetNext( pos );

			// If not looking at all notes, only look at notes that are selected
			if( fUseAllNotes || pSequenceItem->m_fSelected )
			{
				// Check if this note is earlier than all others, or later than all others
				const MUSIC_TIME mtStart = pSequenceItem->AbsTime();
				if( mtStart < mtFirstSelected )
				{
					mtFirstSelected = mtStart;
				}
				if( mtStart > mtLastSelected )
				{
					mtLastSelected = mtStart;
				}
			}
		}

		mtSelectedSpan = mtLastSelected - mtFirstSelected;
	}

	// Iterate through all events
	// Only velocitize notes
	POSITION pos = m_lstSequences.GetHeadPosition();
	while( pos )
	{
		CSequenceItem* pSequenceItem = m_lstSequences.GetNext( pos );

		if( fUseAllNotes || pSequenceItem->m_fSelected )
		{
			// Compute the absolute velocity change for this note, if necessary
			long lAbsChange = pSequenceVelocitize->m_lAbsoluteChangeStart;
			if( (pSequenceVelocitize->m_dwVelocityMethod != SEQUENCE_VELOCITIZE_COMPRESS)
			&&	(lAbsChangeSpan != 0)
			&&	(mtSelectedSpan != 0) )
			{
				lAbsChange += (lAbsChangeSpan * (pSequenceItem->AbsTime() - mtFirstSelected)) / mtSelectedSpan;
			}

			if( VelocitizeNote( pSequenceItem, pSequenceVelocitize->m_bCompressMin, pSequenceVelocitize->m_bCompressMax, lAbsChange, pSequenceVelocitize->m_dwVelocityMethod ) )
			{
				fChanged = TRUE;
			}
		}
	}

	if( fChanged )
	{
		m_fDirty = TRUE;

		m_pSequenceStrip->m_nLastEdit = IDS_UNDO_VELOCITY;
		OnDataChanged();
		m_pSequenceStrip->InvalidateStrip();

		// Always recompute m_SelectedPropNote and update the property page
		RefreshPropertyPage();
	}

	return fChanged;
}


/////////////////////////////////////////////////////////////////////////////
// CSequenceMgr::VelocitizeNote

BOOL CSequenceMgr::VelocitizeNote( CSequenceItem* pSequenceItem, BYTE bCompressMin, BYTE bCompressMax, LONG lAbsoluteChange, DWORD dwVelocityMethod )
{
	BOOL fChanged = FALSE;

	ASSERT( pSequenceItem );

	long lNewValue = pSequenceItem->m_bByte2;
	switch( dwVelocityMethod & SEQUENCE_VELOCITIZE_METHOD_MASK )
	{
	case SEQUENCE_VELOCITIZE_PERCENT:
		if( lAbsoluteChange != 0 )
		{
			lNewValue = long(pSequenceItem->m_bByte2) + (long(pSequenceItem->m_bByte2) * lAbsoluteChange) / 100;
			lNewValue = min( 127, max( lNewValue, 1 ) );
			if( BYTE(lNewValue) != pSequenceItem->m_bByte2 )
			{
				fChanged = TRUE;
				pSequenceItem->m_bByte2 = BYTE(lNewValue);
			}
		}
		break;
	case SEQUENCE_VELOCITIZE_LINEAR:
		if( lAbsoluteChange != 0 )
		{
			lNewValue = long(pSequenceItem->m_bByte2) + lAbsoluteChange;
		}
		break;
	case SEQUENCE_VELOCITIZE_COMPRESS:
		lNewValue = min( bCompressMax, max( bCompressMin, pSequenceItem->m_bByte2 ) );
		break;
	}

	lNewValue = min( 127, max( lNewValue, 1 ) );
	if( BYTE(lNewValue) != pSequenceItem->m_bByte2 )
	{
		fChanged = TRUE;
		pSequenceItem->m_bByte2 = BYTE(lNewValue);
	}

	return fChanged;
}


/////////////////////////////////////////////////////////////////////////////
// CSequenceMgr::CalculatePasteTime

MUSIC_TIME CSequenceMgr::CalculatePasteTime( MUSIC_TIME mtTime )
{
	// get offset of first sequence's drag position to normalize all sequences to offset zero:
	long lTimeOffset = mtTime;
	long lTimeOffset0=-1;
	long lTimeOffset1;

	// quantize the time to the nearest grid.
	lTimeOffset1 = m_pSequenceStrip->FloorTimeToGrid( lTimeOffset, NULL );

	// get clocks per beat
	DMUS_TIMESIGNATURE TimeSig;
	if(SUCCEEDED(m_pTimeline->GetParam(GUID_TimeSignature,
										m_dwGroupBits,
										m_dwIndex,
										lTimeOffset, NULL,
										&TimeSig)))
	{
		// see if next grid is closer to drop pos
		// (since FloorTimeToGrid returns floor of
		// time quantized to the grid)
		long lClocksPerGrid = ((DMUS_PPQ * 4) / TimeSig.bBeat) / TimeSig.wGridsPerBeat;
		lTimeOffset0 = lTimeOffset1 + lClocksPerGrid;

		// see which is closer
		lTimeOffset = (mtTime - lTimeOffset1) <= (lTimeOffset0 - mtTime) ? lTimeOffset1 : lTimeOffset0;
	}

	if(lTimeOffset0 == -1)
	{
		// pos calcs failed, fallback to first value
		lTimeOffset = lTimeOffset1;
	}

	return lTimeOffset;
}

// Helper function for RealTime display

void RefTimeToString( REFERENCE_TIME rtTime, int nResourceID, int nNegativeResourceID, CString &cstrTime )
{
	bool fNegative = false;
	if( rtTime < 0 )
	{
		fNegative = true;
		rtTime = -rtTime;
	}

	int iMillisecond, iSecond, iMinute;//, iHour;
	// Convert to milliseconds
	iMillisecond = int(rtTime / 10000);
	iSecond = iMillisecond / 1000;
	iMillisecond %= 1000;
	iMinute = iSecond / 60;
	iSecond %= 60;
	//iHour = iMinute / 60;
	//iMinute %= 60;

	CString strFormat;
	if( strFormat.LoadString( fNegative ? nNegativeResourceID : nResourceID ) )
	{
		cstrTime.Format(strFormat, iMinute, iSecond, iMillisecond);
	}
	else
	{
		cstrTime.Format(fNegative ? "-%02d:%02d.%03d" : "%02d:%02d.%03d", iMinute, iSecond, iMillisecond);
	}
}

/////////////////////////////////////////////////////////////////////////////
// CSequenceMgr::UpdateStatusBarDisplay

void CSequenceMgr::UpdateStatusBarDisplay( void )
{
	bool fShowStatusBar = false;
	if( m_pSequenceStrip )
	{
		switch( m_pSequenceStrip->m_iHaveFocus)
		{
		case 1:
			if( m_pSequenceStrip->m_pActiveNote
			&&	m_pSequenceStrip->m_pActiveNote->m_fSelected )
			{
				fShowStatusBar = true;

				if( !m_hStatusBar
				&&	SUCCEEDED( m_pDMProdFramework->SetNbrStatusBarPanes( 1, SBLS_CONTROL, &m_hStatusBar ) ) )
				{
					m_pDMProdFramework->SetStatusBarPaneInfo( m_hStatusBar, 0, SBS_SUNKEN, 14 );
				}

				if( m_hStatusBar )
				{
					REFERENCE_TIME rtNote;
					if( SUCCEEDED( m_pTimeline->ClocksToRefTime( m_pSequenceStrip->m_pActiveNote->AbsTime(),
																 &rtNote ) ) )
					{
						CString strText;
						RefTimeToString( rtNote, IDS_NOTE_STATUS_TEXT, IDS_NOTE_NEG_STATUS_TEXT, strText );
						m_pDMProdFramework->SetStatusBarPaneText( m_hStatusBar, 0, strText.AllocSysString(), TRUE );
					}
				}
			}
			break;

		case 2:
			if( m_pSequenceStrip->m_pActiveCurveStrip )
			{
				CCurveItem *pCurve = m_pSequenceStrip->m_pActiveCurveStrip->GetEarliestSelectedCurve();
				if( pCurve )
				{
					fShowStatusBar = true;

					if( !m_hStatusBar
					&&	SUCCEEDED( m_pDMProdFramework->SetNbrStatusBarPanes( 1, SBLS_CONTROL, &m_hStatusBar ) ) )
					{
						m_pDMProdFramework->SetStatusBarPaneInfo( m_hStatusBar, 0, SBS_SUNKEN, 15 );
					}

					if( m_hStatusBar )
					{
						REFERENCE_TIME rtNote;
						if( SUCCEEDED( m_pTimeline->ClocksToRefTime( pCurve->AbsTime(),
																	 &rtNote ) ) )
						{
							CString strText;
							RefTimeToString( rtNote, IDS_CURVE_STATUS_TEXT, IDS_CURVE_NEG_STATUS_TEXT, strText );
							m_pDMProdFramework->SetStatusBarPaneText( m_hStatusBar, 0, strText.AllocSysString(), TRUE );
						}
					}
				}
			}
			break;
		}
	}


	if( !fShowStatusBar
	&&	m_hStatusBar )
	{
		m_pDMProdFramework->RestoreStatusBar( m_hStatusBar );
		m_hStatusBar = NULL;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SequenceStripMgr\SequenceMgr.h ===
// SequenceMgr.h : Declaration of the CSequenceMgr

#ifndef __SEQUENCEMGR_H_
#define __SEQUENCEMGR_H_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "resource.h"		// main symbols
#include "SequenceStripMgr.h"
#include "SequenceIO.h"
#include "timeline.h"
#include <DMUSProd.h>
#include <dmusici.h>
#include "SequenceScrollbar.h"
#include "PropSequence.h"
#include <SegmentPrivate.h>
#include <Conductor.h>
#include <RectList.h>

class CSequenceStrip;
class CSequenceItem;
class CDllJazzDataObject;
class CCurveTracker;
class CCurveStrip;
class CPropItem;
class CPropCurve;
interface IDirectMusicTrack;
interface IDMUSProdRIFFStream;
interface IDMUSProdConductor;
interface IDMUSProdPChannelName;

// {4DF1708C-AFF6-11d2-B0DA-00105A26620B}
DEFINE_GUID(GUID_Sequence_Color_Change, 0x4df1708c, 0xaff6, 0x11d2, 0xb0, 0xda, 0x0, 0x10, 0x5a, 0x26, 0x62, 0xb);

// {0B12D932-ED21-11d2-A6E6-00105A26620B}
DEFINE_GUID(GUID_Sequence_Notation_Change, 0xb12d932, 0xed21, 0x11d2, 0xa6, 0xe6, 0x0, 0x10, 0x5a, 0x26, 0x62, 0xb);

#define PRIVATE_SP_CLSID		(SP_USER+45)
#define PRIVATE_SP_PCHANNEL		(SP_USER+4)

#define INVALID_PATCH			(0xFFFFFFFF)

#define TRACKCONFIG_VALID_MASK (DMUS_TRACKCONFIG_OVERRIDE_ALL | DMUS_TRACKCONFIG_OVERRIDE_PRIMARY | DMUS_TRACKCONFIG_FALLBACK |	DMUS_TRACKCONFIG_PLAY_ENABLED | DMUS_TRACKCONFIG_PLAY_CLOCKTIME | DMUS_TRACKCONFIG_CONTROL_PLAY)

// structure for sequence strip design time information
struct ioSeqStripDesign
{
	STRIPVIEW	m_svView;			// current strip view (minimized or maximized)
	long		m_lVScroll;			// current vertical scroll (in c_nChannelHeight units)
	long		m_lHeight;			// height of maximized strip
	BOOL		m_fHybridNotation;	// If set, display in hybrid notation, otherwise use PianoRoll display
	double		m_dblVerticalZoom;
	COLORREF	m_crUnselectedNoteColor;// Note color
	COLORREF	m_crSelectedNoteColor;	// Selected note color
	COLORREF	m_crOverlappingNoteColor;// Color of overlapping notes
	COLORREF	m_crAccidentalColor;	// Color of accidentals in hybrid notation
	DWORD		m_dwPChannel;		// PChannel #
	DWORD		m_dwExtraBars;		// Number of bars to display after the segment
	BOOL		m_fPickupBar;		// Whether or not to display a pickup bar
};

struct ioGlobalCurveStripState
{
	int			m_nCurveStripView;		// Minimized or maximized
};

struct ioCurveStripState
{
	int			m_nStripHeight;			// Height of strip
	BYTE		m_bCCType;				// Identifies type of control strip
	BYTE		m_bPad;
	WORD		m_wRPNType;
};

// stuff to identify the current mouse mode
typedef enum tagSEQ_MOUSEMODE
{
	SEQ_MM_NORMAL,
	SEQ_MM_MOVE,
	SEQ_MM_ACTIVEMOVE,
	SEQ_MM_RESIZE_START,
	SEQ_MM_ACTIVERESIZE_START,
	SEQ_MM_RESIZE_END,
	SEQ_MM_ACTIVERESIZE_END,
	SEQ_MM_RESIZE_VELOCITY,
	SEQ_MM_ACTIVERESIZE_VELOCITY,
	SEQ_MM_ACTIVEDRAWBOX,
} SEQ_MOUSEMODE;

typedef enum tagSELECTING
{
	SEQ_NO_SELECT,
	SEQ_SINGLE_SELECT,
	SEQ_MULTIPLE_SELECT,
} SEQ_SELECTING;

typedef enum tagSNAPTO
{
	SNAP_GRID,
	SNAP_BEAT,
	SNAP_BAR,
	SNAP_NONE,
	SNAP_UNKNOWN,
} SNAPTO;

extern class CSequenceStripMgrApp theApp;

// TODO: move to includes/ioDmStyle.h
#define DMUS_FOURCC_SEQUENCE_UI_LIST	mmioFOURCC('p','s','q','l')
#define DMUS_FOURCC_SEQUENCE_UI_CHUNK	mmioFOURCC('p','s','q','c')
#define DMUS_FOURCC_ALLCURVES_UI_CHUNK	mmioFOURCC('c','v','a','u')
#define DMUS_FOURCC_CURVE_UI_CHUNK		mmioFOURCC('c','v','s','u')

void GetTimeSig( MUSIC_TIME mtTime, DMUS_TIMESIGNATURE *pTimeSig, IDMUSProdTimeline* pTimeline, DWORD dwGroupBits );

/////////////////////////////////////////////////////////////////////////////
// CSequenceMgr
class ATL_NO_VTABLE CSequenceMgr : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CSequenceMgr, &CLSID_SequenceMgr>,
	public ISequenceMgr,
	public IDMUSProdStripMgr,
	public IPersistStream,
	public IDMUSProdPropPageObject
{
friend CSequenceStrip;
friend CPropItem;
friend CCurveStrip;
friend CPropCurve;
friend class CNoteTracker;
friend class CNewPartDlg;
friend class PropPageNote;
friend class CCurveTracker;

public:
	CSequenceMgr();
	~CSequenceMgr();

public:
	HRESULT GetBoundariesOfSelectedEvents(long& lStartTime, long& lEndTime);
DECLARE_REGISTRY_RESOURCEID(IDR_SEQUENCEMGR)

BEGIN_COM_MAP(CSequenceMgr)
	COM_INTERFACE_ENTRY_IID(IID_ISequenceMgr,ISequenceMgr)
	COM_INTERFACE_ENTRY(IDMUSProdStripMgr)
	COM_INTERFACE_ENTRY(IPersist)
	COM_INTERFACE_ENTRY(IPersistStream)
	COM_INTERFACE_ENTRY(IDMUSProdPropPageObject)
END_COM_MAP()

// IDMUSProdStripMgr methods
	HRESULT STDMETHODCALLTYPE IsParamSupported( REFGUID guidType );
	HRESULT STDMETHODCALLTYPE GetParam( REFGUID guidType, MUSIC_TIME mtTime, MUSIC_TIME* pmtNext, void* pData );
	HRESULT STDMETHODCALLTYPE SetParam( REFGUID guidType, MUSIC_TIME mtTime, void* pData );
	HRESULT STDMETHODCALLTYPE OnUpdate( REFGUID rguidType, DWORD dwGroupBits, void *pData );
	HRESULT STDMETHODCALLTYPE GetStripMgrProperty( STRIPMGRPROPERTY stripMgrProperty, VARIANT* pVariant );
	HRESULT STDMETHODCALLTYPE SetStripMgrProperty( STRIPMGRPROPERTY stripMgrProperty, VARIANT variant );

// ISequenceMgr methods
	HRESULT STDMETHODCALLTYPE SetPChannel( DWORD dwPChannel );
	HRESULT STDMETHODCALLTYPE SaveEventsToMIDITrack( IStream *pStream );
	HRESULT STDMETHODCALLTYPE PasteEventsFromMIDITrack( IStream *pStream, short nPPQN, DWORD dwLength );

// IPersist methods
	STDMETHOD(GetClassID)( CLSID* pClsId );

// IPersistStream methods
	STDMETHOD(IsDirty)();
	STDMETHOD(Load)( IStream* pIStream );
	STDMETHOD(Save)( IStream* pIStream, BOOL fClearDirty );
	STDMETHOD(GetSizeMax)( ULARGE_INTEGER FAR* pcbSize );

// IDMUSProdPropPageObject methods
	HRESULT STDMETHODCALLTYPE GetData( void **ppData);
	HRESULT STDMETHODCALLTYPE SetData( void *pData);
	HRESULT STDMETHODCALLTYPE OnShowProperties( void);
	HRESULT STDMETHODCALLTYPE OnRemoveFromPageManager( void);

protected:
	HRESULT STDMETHODCALLTYPE OnDataChanged( void);
	void	EmptySequenceList(void);
	void	InsertByAscendingTime(CSequenceItem *pSequence);
	void	InsertByAscendingTimeBackwards(CSequenceItem *pSequence);
	void	InsertByAscendingTime(CCurveItem *pSequence);
	void	InsertByAscendingTimeBackwards(CCurveItem *pSequence);
//	void	InsertByAscendingTimeReplaceSame( CSequenceItem *pSequence );
//	void	InsertByAscendingTimeFrom( CSequenceItem *pSequence, POSITION pos );
//	void	InsertByAscendingTimeBackwardsFrom( CSequenceItem *pSequence, POSITION pos );
	void	DeleteBetweenTimes( long lStart, long lEnd );
	void	UnselectAllNotes();
	void	UnselectAllCurves();
	void	PlayNote( CSequenceItem *pSequence );
	void	PlayPatch( MUSIC_TIME mtTime );
	void	StopNote( void );
	HRESULT	SendPMsg( DMUS_PMSG *pPMsg );
	BOOL	OffsetSelectedNoteValuePositionAndStart( int nValue, long lMoveOffset, long lStartOffset, BOOL fMakeCopy );
	BOOL	OffsetSelectedNoteDurationAndVelocity( long lDuration, long lVelocity, BOOL fMakeCopy );
	void	MergeSequence( CTypedPtrList<CPtrList, CSequenceItem*>& lstSequences );
	void	MergeCurve( CTypedPtrList<CPtrList, CCurveItem*>& lstCurves );
	int		GetNumSelected();
	void	RefreshPropertyPage( );
	DWORD	ApplyToSelectedNotes( const CPropSequence* pPropNote );
	void	InsertNote( CSequenceItem *pSequence, BOOL fUpdateSegment );
	void	InsertCurve( CCurveItem *pSequence, BOOL fUpdateSegment );
	BOOL	Quantize( SequenceQuantize* pSequenceQuantize );
	BOOL	QuantizeNote( CSequenceItem* pSequenceItem, SequenceQuantize* pSequenceQuantize );
	BOOL	Velocitize( SequenceVelocitize* pSequenceVelocitize );
	BOOL	VelocitizeNote( CSequenceItem* pSequenceItem, BYTE bCompressMin, BYTE bCompressMax, LONG lAbsoluteChange, DWORD dwVelocityMethod );
	MUSIC_TIME CalculatePasteTime( MUSIC_TIME mtTime );
	void UpdateStatusBarDisplay( void );

	BOOL	SelectSegmentNotes(long begintime, long endtime);
	HRESULT SyncWithDirectMusic();
	BOOL	UpdateFlatsAndKey();
	HRESULT	AddNewPart( void );

public:
	BOOL						m_fHasNotationStation; // TRUE if we have the NotationStation font installed

protected:
	IDMUSProdTimeline*			m_pTimeline;

	CTypedPtrList<CPtrList, CSequenceItem*> m_lstSequences;
	CTypedPtrList<CPtrList, CCurveItem*> m_lstCurves;
	IDMUSProdFramework* 		m_pDMProdFramework;
	IDMUSProdNode*				m_pDMProdSegmentNode;
	IDMUSProdConductor*			m_pIConductor;
	IDMUSProdPChannelName*		m_pIPChannelName;
	IDirectMusicPerformance*	m_pIDMPerformance;
	DWORD						m_dwGroupBits;
	DWORD						m_dwOldGroupBits;
	DWORD						m_dwIndex;;
	DWORD						m_dwTrackExtrasFlags;
	DWORD						m_dwProducerOnlyFlags;
	IDirectMusicTrack*			m_pIDMTrack;
	BOOL						m_fDirty;
	BOOL						m_fDisplayingFlats;// If set, display hybrid notation with flats, otherwise use sharps
	int							m_nKeyRoot;
	int							m_nNumAccidentals;
	ioSeqStripDesign			m_SeqStripDesign;
	BOOL						m_fUpdateDirectMusic;
	HANDLE						m_hStatusBar;

	BOOL						m_fSetPChannel;
	DWORD						m_dwPChannel;

	CPropSequence				m_PropSequence;
	IDMUSProdPropPageManager*	m_pPropPageMgr;

	CSequenceStrip*				m_pSequenceStrip;

	BOOL						m_fShuttingDown;
	BOOL						m_fRecordEnabled;
	IDirectMusicSegmentState	*m_pSegmentState;
	BOOL						m_fNoteInserted;
	BOOL						m_fCurveInserted;
	BOOL						m_fWindowActive;
	MUSIC_TIME					m_mtCurrentStartPoint;
	MUSIC_TIME					m_mtCurrentStartTime;
	MUSIC_TIME					m_mtCurrentLoopStart;
	MUSIC_TIME					m_mtCurrentLoopEnd;
	DWORD						m_dwCurrentMaxLoopRepeats;
	DWORD						m_dwCurrentLoopRepeats;

	// State variables for clipping off played notes when dragging them around
	REFERENCE_TIME		m_rtLastPlayNoteOffTime;
	MUSIC_TIME			m_mtLastPlayNoteEnd;
	BYTE				m_bLastPlayNoteMIDIValue;

	CString m_strName;
	CString m_strAuthor;
	CString m_strCopyright;
	CString m_strSubject;
	CString m_strInfo;

protected:
	HRESULT LoadSeqTrack( IDMUSProdRIFFStream* pIRiffStream, MMCKINFO ck );
	HRESULT DeleteSelectedSequences();
	HRESULT SaveSelectedSequences( LPSTREAM, MUSIC_TIME mtOffset );
	HRESULT SaveSelectedSequencesAsMidi( LPSTREAM, MUSIC_TIME mtOffset );
	HRESULT	SaveSelectedSequenceChunk( IDMUSProdRIFFStream* pIRiffStream, MUSIC_TIME mtBeatsOffset);
	HRESULT SaveSelectedCurveChunk( IDMUSProdRIFFStream* pIRiffStream, MUSIC_TIME mtBeatsOffset);
	HRESULT SaveSelectedEvents( LPSTREAM, MUSIC_TIME mtOffset );
	HRESULT SaveSelectedEventsAsMidi( LPSTREAM );
	HRESULT ImportSequenceChunkData( LPSTREAM, long lSize, long lTimeOffset );
	HRESULT ImportCurveChunkData( LPSTREAM, long lSize, long lTimeOffset );
	HRESULT LoadSequenceUIList( IDMUSProdRIFFStream* pIRiffStream, MMCKINFO *pckMain );
	HRESULT SaveSequenceUIList( IDMUSProdRIFFStream* pIRiffStream );
	HRESULT ImportMIDIFileToMultipleTracks( LPSTREAM );

// general helpers
	/*
	void MarkSelectedSequences(DWORD flags);
	void UnMarkSequences(DWORD flags);
	void DeleteMarked(DWORD flags);
	*/
	void SelectAllNotes();
	BOOL RemoveItem( CSequenceItem* pItem );
	BOOL FirstGutterSelectedSequenceMgr( void );

// Misc
	BOOL		IsSelected();	// returns if one or more sequences are selected.
	CSequenceItem* FirstSelectedSequence(POSITION* pos=NULL);	// make non-null for iteration
	CSequenceItem* GetFirstSequence(POSITION& pos)
	{
		pos = m_lstSequences.GetHeadPosition();
		if(pos)
		{
			return m_lstSequences.GetNext(pos);
		}
		else
		{
			return 0;
		}
	}
	CSequenceItem* GetNextSequence(POSITION& pos)
	{
		if(pos == 0)
		{
			return 0;
		}
		else
		{
			return m_lstSequences.GetNext(pos);
		}
	}
};


class CSequenceStrip :
	public IDMUSProdStrip,
	public IDMUSProdStripFunctionBar,
	public IDMUSProdTimelineEdit,
	public IDMUSProdPropPageObject,
	public IDropTarget,
	public IDMUSProdMidiInCPt
{
friend CSequenceMgr;
friend CSequenceScrollBar;
friend CCurveTracker;
friend CCurveStrip;
friend CPropCurve;
friend class CNoteTracker;
friend class CNewPartDlg;
friend class PropPageNote;
friend class CPropItem;

public:
	CSequenceStrip( CSequenceMgr* pSequenceMgr );
	~CSequenceStrip();

public:
	HRESULT PasteMidiFile(IDMUSProdTimelineDataObject* pITimelineDataObject, long lClocks, BOOL fPasteToMultipleStrips );
#ifdef _DEBUG
	//void TraceFormatsInClipboard();
#endif
// IUnknown
	STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
	STDMETHODIMP_(ULONG) AddRef();
	STDMETHODIMP_(ULONG) Release();

// IDMUSProdStrip
	HRESULT STDMETHODCALLTYPE Draw( HDC hDC, STRIPVIEW sv, LONG lXOffset );
	HRESULT STDMETHODCALLTYPE GetStripProperty( STRIPPROPERTY sp, VARIANT *pvar);
	HRESULT STDMETHODCALLTYPE SetStripProperty( STRIPPROPERTY sp, VARIANT var);
	HRESULT STDMETHODCALLTYPE OnWMMessage( UINT nMsg, WPARAM wParam, LPARAM lParam, LONG lXPos, LONG lYPos );

// IDMUSProdStripFunctionBar
	HRESULT STDMETHODCALLTYPE FBDraw( HDC hDC, STRIPVIEW sv );
	HRESULT STDMETHODCALLTYPE FBOnWMMessage( UINT nMsg, WPARAM wParam, LPARAM lParam, LONG lXPos, LONG lYPos );

// IDMUSProdTimelineEdit
	HRESULT STDMETHODCALLTYPE Cut( IDMUSProdTimelineDataObject* pITimelineDataObject = NULL );
	HRESULT STDMETHODCALLTYPE Copy( IDMUSProdTimelineDataObject* pITimelineDataObject = NULL );
	HRESULT STDMETHODCALLTYPE Paste( IDMUSProdTimelineDataObject* pITimelineDataObject = NULL );
	HRESULT STDMETHODCALLTYPE Insert( void );
	HRESULT STDMETHODCALLTYPE Delete( void );
	HRESULT STDMETHODCALLTYPE SelectAll( void );
	HRESULT STDMETHODCALLTYPE CanCut( void );
	HRESULT STDMETHODCALLTYPE CanCopy( void );
	HRESULT STDMETHODCALLTYPE CanPaste( IDMUSProdTimelineDataObject* pITimelineDataObject = NULL );
	HRESULT STDMETHODCALLTYPE CanInsert( void );
	HRESULT STDMETHODCALLTYPE CanDelete( void );
	HRESULT STDMETHODCALLTYPE CanSelectAll( void );

// IDropTarget methods
	HRESULT STDMETHODCALLTYPE DragEnter( IDataObject* pIDataObject, DWORD grfKeyState, POINTL pt, DWORD* pdwEffect);
	HRESULT STDMETHODCALLTYPE DragOver( DWORD grfKeyState, POINTL pt, DWORD* pdwEffect);
	HRESULT STDMETHODCALLTYPE DragLeave( void );
	HRESULT STDMETHODCALLTYPE Drop( IDataObject* pIDataObject, DWORD grfKeyState, POINTL pt, DWORD* pdwEffect);

// IDropTarget helpers
	HWND	GetTimelineHWnd();
	HRESULT CanPasteFromData(IDataObject* pIDataObject);
	HRESULT PasteReplace( long firstMeasure, long firstBeat, long lastMeasure, long lastBeat);
	HRESULT PasteAt( IDMUSProdTimelineDataObject* pITimelineDataObject, long lClocks, BOOL bDropNotEditPaste, BOOL fPasteMIDIToMultipleStrips);

// IDMUSProdPropPageObject functions
	HRESULT STDMETHODCALLTYPE GetData( void **ppData );
	HRESULT STDMETHODCALLTYPE SetData( void *pData );
	HRESULT STDMETHODCALLTYPE OnShowProperties( void );
	HRESULT STDMETHODCALLTYPE OnRemoveFromPageManager( void );

// IDMUSProdMidiInCPt functions
	HRESULT STDMETHODCALLTYPE OnMidiMsg(REFERENCE_TIME rtTime, BYTE bStatus, BYTE bData1, BYTE bData2);

public:
	BOOL	GetStripRect(CRect& rectStrip);
	BOOL	SelectInRect( CRect* pRect );

protected:
// Internal message handlers
	HRESULT OnLButtonDown( WPARAM wParam, LONG lXPos, LONG lYPos);
	HRESULT OnLButtonUp( long lXPos, long lYPos);
	HRESULT OnSetCursor( long lXPos, long lYPos);
	HRESULT OnRButtonUp( void );

// This is called when our scrollbar receives a WM_APP message (used for MIDI input)
	LRESULT OnApp( WPARAM wParam, LPARAM lParam );

// drawing helpers
	void	DrawMinimizedNotes( HDC hDC, POSITION pos, long lStartTime, long lEndTime, long lXOffset, BOOL fSelected );
	void	DrawMaximizedNotes( HDC hDC, POSITION pos, long lStartTime, long lEndTime, long lXOffset, int nTopNote, int nBottomNote, BOOL fSelected );
	void	DrawHybridMaximizedNotes( HDC hDC, POSITION pos, long lStartTime, long lEndTime, long lXOffset, int nTopNote, int nBottomNote, BOOL fSelected );
	void	DrawHybridMaximizedAccidentals( HDC hDC, POSITION pos, long lStartTime, long lEndTime, long lXOffset, int nTopNote, int nBottomNote );
	void	DrawFunctionBar( HDC hDC, STRIPVIEW sv );
	void	DrawHorizontalLines( HDC hDC, const RECT &rectClip, int nBottomNote, int nTopNote );
	void	DrawHybridLines( HDC hDC, const RECT &rectClip, int nBottomNote, int nTopNote );
	void	DrawDarkHorizontalLines( HDC hDC, const RECT &rectClip, int nBottomNote, int nTopNote );
	void	DrawDarkHybridLines( HDC hDC, const RECT &rectClip, int nBottomNote, int nTopNote );
	POSITION GetFirstVisibleNote( long lStartTime, long lEndTime, int nTopNote, int nBottomNote );
	void	InitializeScaleAccidentals( void );
	void	UpdateKeyPattern( void );
	void	InvalidateFunctionBar( void );
	void	InvalidatePianoRoll( void );
	void	InvalidateStrip( void );
	void	DrawSymbol( HDC hDC, const TCHAR *pstrText, int iHybridPos, long lLeftPos, long lTopAjust, long lBottomAdjust );
	void	DrawNoteInsertionMark( HDC hDC, MUSIC_TIME mtStartTime, MUSIC_TIME mtEndTime, long lXOffset );
	HFONT	GetAccidentalFont( void );

// scroll stuff
	void	UpdateVScroll();	
	void	SetVScroll(long lNewValue);
	void	LimitVScroll();
	void	OnVScroll(UINT nSBCode, UINT nPos);
	HRESULT OnVScroll( void );
	HRESULT OnSize( void );
	HRESULT OnChar( WPARAM wParam);
	HRESULT OnMouseMove( long lXPos, long lYPos);
	HRESULT OnKeyDown( WPARAM wParam );
	HRESULT OnDestroy( void );
	HRESULT OnCreate( void );
	HRESULT SetFocus( int iFocus ); // 0 = None, 1 = Sequence, 2 = Curve
	void	OnTimer( void );
	void	KillTimer( void );
	void	EnableTimer( void );
	void    OnChangeStripView( STRIPVIEW svNewStripView );
	void	AdjustScroll(long lXPos, long lYPos);

// general helpers
	void	UpdateName();
	void	GetNoteRect( const CSequenceItem* pSeqItem, RECT* pRect );
	void	GetHybridRect( RECT* pRect, int iHybridPos, int iVelocity, MUSIC_TIME mtStart, MUSIC_TIME mtDuration );
	CSequenceItem* GetSeqItemAndRectFromPoint( long lXPos, long lYPos, RECT *pRect );
	void	SetMouseMode( long lXPos, long lYPos);
	void	UnselectGutterRange( void );
	BOOL	SelectEventsBetweenTimes( long lStart, long lEnd );
	int		PositionToMIDIValue( long lYPos );
	void	ApplyUIChunk( const ioSeqStripDesign *pSeqStripDesign );
	void	UpdateSequenceUIChunk();
	void	BumpTimeCursor( SNAPTO snapTo = SNAP_UNKNOWN );
	void	UpdateNoteCursorTime( BOOL fRedraw = TRUE );
	SNAPTO	GetSnapToBoundary( long lTime ) const;
	long	GetSnapAmount( long lTime, SNAPTO st = SNAP_UNKNOWN ) const;
	long	GetGridClocks( long lTime ) const;
	void	ChangeNotationType( BOOL fHybridNotation );
	void	ChangeZoom( double dblVerticalZoom );
	HRESULT DoQuantize( void );
	HRESULT DoVelocity( void );
	void	EnsureNoteCursorVisible( void );
	void	UpdateSelectionState( void );
	DWORD	GetNumExtraBars( void ) const;
	BOOL	ShouldDisplayPickupBar( void ) const;
	CSequenceItem *CreateNoteToInsert( void ) const;
	void	UpdateInstrumentName( void );

// MIDI helpers
	void	UnRegisterMidi( void );
	void	RegisterMidi( void );
	void	SendAllNotesOffIfNotPlaying( void );
	HRESULT RecordStepNoteOn( BYTE bData1, BYTE bData2 );
	HRESULT RecordStepNoteOff( BYTE bData1 );
	HRESULT RecordRealTimeNoteOn(REFERENCE_TIME rtTime, BYTE bData1, BYTE bData2 );
	HRESULT RecordRealTimeNoteOff(REFERENCE_TIME rtTime, BYTE bData1 );
	HRESULT RecordRealTimeCurve( REFERENCE_TIME rtTime, BYTE bStatus, BYTE bData1, BYTE bData2 );
	void	SetPChannelThru();
	void	CancelPChannelThru();
	BOOL	IsEnginePlaying( void ) const;
	MUSIC_TIME FloorTimeToGrid( MUSIC_TIME mtTime, long *plGridClocks ) const;
	BOOL		m_fMIDIInRegistered;
	BOOL		m_fMIDIThruEnabled;
	DWORD		m_dwCookie;
	BYTE		m_bVelocity[128];
	MUSIC_TIME	m_mtStartTime[128];

// mouse cursors
	HCURSOR GetResizeStartCursor( void );
	HCURSOR GetResizeEndCursor( void );
	HCURSOR GetArrowCursor( void );
	HCURSOR GetNSCursor( void );
	HCURSOR GetAllCursor( void );

// Curve strip helpers
	static BOOL	CurveStripExists( void *pThis, BYTE bCCType, WORD wRPNType );
	BYTE	CurveTypeToStripCCType( CCurveItem* pDMCurve );
	void	SyncCurveStripStateList( void );
	ioCurveStripState* GetCurveStripState( BYTE bCCType, WORD wRPNType );
	CCurveStrip* GetCurveStrip( BYTE bCCType, WORD wRPNType );
	HRESULT AddCurveStrip( BYTE bCCType, WORD wRPNType );
	HRESULT AddCurveStrips( void );
	HRESULT RemoveCurveStrip( CCurveStrip* pCurveStrip );
	HRESULT OnDeleteCurveStrip( CCurveStrip* pCurveStrip );
	HRESULT OnNewCurveStrip( void );
	DWORD	DeterminePositionForCurveStrip( BYTE bCCType, WORD wRPNType );
	void	OnChangeCurveStripView( STRIPVIEW svNewStripView );
	void	InvalidateCurveStrips( void );
	HRESULT SaveCurveStripStateData( IDMUSProdRIFFStream* pIRiffStream );
	void	UpdateCurveStripGutterSelection( BOOL fChanged );

	// Useful stuff
	long				m_cRef;
	CSequenceMgr*		m_pSequenceMgr;
	IDMUSProdStripMgr*	m_pStripMgr;

// Selection parameters
	LONG		m_lBeginSelect;
	LONG		m_lEndSelect;
	BOOL		m_bGutterSelected;	// whether the gutter select is selected, use
									// CSequenceMgr::m_bSelected for whether sequence is selected
	SEQ_SELECTING	m_SelectionMode;
	BYTE		m_bSelectionCC; // If a CC strip is selected, which one
	WORD		m_wSelectionParamType; // Which RPN/NRPN CC strip is selected
	POINT		m_pointSelection;
	BOOL		m_fSelecting;

	// Random state information
	CString		m_strName;
	int			m_iHaveFocus; // 0 = No focus, 1 = Sequence, 2 = Curve
	MUSIC_TIME	m_mtLength;
	CCurveStrip	*m_pActiveCurveStrip;


	// Strip-specific data we should persist
protected:
	STRIPVIEW	m_svView;				// current strip view (minimized or maximized)
	long		m_lVScroll;				// current vertical scroll (in c_nChannelHeight units)
	BOOL		m_fHybridNotation;		// If set, display in hybrid notation, otherwise use PianoRoll display
	double		m_dblVerticalZoom;
	COLORREF	m_crSelectedNoteColor;
	COLORREF	m_crUnselectedNoteColor;
	COLORREF	m_crOverlappingNoteColor;
	COLORREF	m_crAccidentalColor;

	STRIPVIEW	m_CurveStripView;
	CTypedPtrList<CPtrList, ioCurveStripState*> m_lstCurveStripStates;
	CTypedPtrList<CPtrList, CCurveStrip*> m_lstCurveStrips;

protected:
	HRESULT	ShowPropertySheet(IDMUSProdTimeline*);

	// Edit information
	LONG		m_lXPos;				// used for temp storage of xpos when doing mouse edits
	CSequenceItem*	m_pSelectPivotSeq;	// last seq mouse clicked on when shift was not down.
	CSequenceItem*	m_pActiveNote;
	CSequenceItem	m_OriginalSeqItem;
	long		m_lInsertVal;
	long		m_lInsertTime;
	POINT		m_pointClicked;
	UINT		m_nLastEdit;			// resource id of last edit
	BOOL		m_fCtrlKeyDown;	// If set, then a ctrl-click was on (1) selected note, or (2) unselected note
	long		m_lLastDeltaStart;
	char		m_cLastDeltaValue;
	long		m_lLastDeltaDur;
	long		m_lLastDeltaVel;
	long		m_lLastDeltaMove;
	BOOL		m_fScrollTimerActive;
	bool		m_fInsertingNoteFromMouseClick;

	// Drag'n'Drop
	IDataObject*m_pITargetDataObject;
	DWORD		m_dwOverDragButton; 	// Mouse button stored in IDropTarget::DragOver
	DWORD		m_dwOverDragEffect; 	// Drag effects stored in IDropTarget::DragOver
	DWORD		m_dwDragRMenuEffect;	// Result from drag context menu

	// Cut 'n' paste
	UINT		m_cfSequenceList;		// Clipboard formats
	UINT		m_cfSequenceCurveList;	// Sequence and Curve data together
	UINT		m_cfMidiFile;

	// Drawing
	BYTE		m_bMinimizeTopNote;
	BYTE		m_bMinimizeNoteRange;
	long		m_lMaxNoteHeight;
	HCURSOR 	m_hCursor;
	SEQ_MOUSEMODE m_MouseMode;		// current Mouse Mode
	CRectList	m_aNoteRectList[128];
	int			m_aiAccidentals[75];	// Current Accidental
	int			m_aiScalePattern[7];	// Current Scale Pattern for initializing m_aiAccidentalst
	MUSIC_TIME	m_mtLastLateTime;
	DWORD		m_dwExtraBars;
	BOOL		m_fPickupBar;
	DWORD		m_dwLastPatch;

	// Bitmap status variables
	BOOL			m_fZoomInPressed;
	BOOL			m_fZoomOutPressed;
	BOOL			m_fNewBandPressed;
	BOOL			m_fInstrumentPressed;
	BOOL			m_fInstrumentEnabled;
	static long		m_lBitmapRefCount;
	static CBitmap	m_BitmapZoomInUp;
	static CBitmap	m_BitmapZoomInDown;
	static CBitmap	m_BitmapZoomOutUp;
	static CBitmap	m_BitmapZoomOutDown;
	static CBitmap	m_BitmapNewBand;

	// Property page
	BOOL		m_fShowSequenceProps;		// if TRUE, show Sequence property page, else show group property page
	BOOL		m_fPropPageActive;		// TRUE if our property page is active
	IDMUSProdPropPageManager*	m_pPropPageMgr;

	// vertical scrollbar stuff
	CRect			m_rectVScroll;		// rectangle for location of vertical scrollbar
	CSequenceScrollBar	m_VScrollBar;		// vertical scrollbar
};
#endif //__SEQUENCEMGR_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SequenceStripMgr\StdAfx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information
#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
#include <atlctl.cpp>
#include <atlwin.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SequenceStripMgr\SequenceStripMgrApp.h ===
// SequenceStripMgrApp.h : Declaration of the CSequenceStripMgrApp

#ifndef __SequenceSTRIPMGRAPP_H_
#define __SequenceSTRIPMGRAPP_H_

#include <afxwin.h>

#define RELEASE(x) if( (x) ) (x)->Release(); (x) = 0


interface IDMUSProdPropPageManager;

class CSequenceStripMgrApp : public CWinApp
{
public:
	virtual BOOL InitInstance();
	virtual int ExitInstance();

public:
	IDMUSProdPropPageManager*	m_pIPageManager;
	UINT		m_cfCurve;						// CF_CURVE clipboard format
	CFont*		m_pCurveStripFont;				// Curve strip font
};

#define MAX_GRIDS_PER_BEAT_ENTRIES	48

extern const UINT g_nGridsPerBeatBitmaps[];

#endif //__SequenceSTRIPMGRAPP_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SequenceStripMgr\SequenceStripMgr.cpp ===
// SequenceStripMgr.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//		To build a separate proxy/stub DLL, 
//		run nmake -f SequenceStripMgrps.mak in the project directory.

#include "stdafx.h"
#include "resource.h"
#include "SequenceStripMgr.h"
#include <AFXCTL.H>
#include "SequenceStripMgrApp.h"


#include <initguid.h>
#include <dmusici.h>
#include <dmusicf.h>
#include "SequenceMgr.h"
#include <SegmentGuids.h>
#include <PChannelName.h>
#include <SegmentDesigner.h>


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
	OBJECT_ENTRY(CLSID_SequenceMgr, CSequenceMgr)
END_OBJECT_MAP()

CSequenceStripMgrApp theApp;

BOOL CSequenceStripMgrApp::InitInstance()
{
	_Module.Init(ObjectMap, m_hInstance);
	AfxEnableControlContainer();

	m_pIPageManager = NULL;

	m_cfCurve = ::RegisterClipboardFormat( CF_CURVELIST );
	m_pCurveStripFont = NULL;

	return CWinApp::InitInstance();
}

int CSequenceStripMgrApp::ExitInstance()
{
	if( m_pCurveStripFont )
	{
		m_pCurveStripFont->DeleteObject();
		delete m_pCurveStripFont;
		m_pCurveStripFont = NULL;
	}

	_Module.Term();
	return CWinApp::ExitInstance();
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	return (AfxDllCanUnloadNow()==S_OK && _Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
	return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// SetRegString - Writes a string to system registry 

static BOOL SetRegString( HKEY hKey, LPCTSTR lpSubKey, LPTSTR lpValueName, LPCTSTR lpszString )
{
	HKEY  hKeyOpen;
	DWORD dwCbData;
	LONG  lResult;
	DWORD dwDisposition;
	BOOL  fSuccess = FALSE;

	lResult = RegCreateKeyEx( hKey, lpSubKey, 0, 0, REG_OPTION_NON_VOLATILE,
							  KEY_ALL_ACCESS, NULL, &hKeyOpen, &dwDisposition );
	if( lResult == ERROR_SUCCESS )
	{
		dwCbData = _tcslen(lpszString)+1; // Assume ASCII  This is BAD!!!!!

		lResult = RegSetValueEx( hKeyOpen, lpValueName, 0, REG_SZ, (LPBYTE)lpszString, dwCbData);

		if( lResult == ERROR_SUCCESS )
		{
			fSuccess = TRUE;
		}

		RegCloseKey( hKeyOpen );
	}

	return fSuccess;
}

/////////////////////////////////////////////////////////////////////////////
// RegisterComponents - Adds entries to the system registry for DMUSProducer strip managers

static BOOL RegisterComponents( void )
{
    LPOLESTR psz;
	TCHAR    szRegPath[256];
	TCHAR	 szStripManager[32];
	TCHAR	 szUserName[32];
    TCHAR    szEditorGuid[100];
	TCHAR	 szTrackGuid[100];
    CString  strTrackName, strEditorName;
    TCHAR    szComponentPath[256];
    
	_tcscpy( szStripManager, _T("StripManager") );
	_tcscpy( szUserName, _T("UserName") );

	_tcscpy( szComponentPath, _T("Software\\Microsoft\\DMUSProducer\\StripEditors\\") );
	
    if( SUCCEEDED( StringFromIID(CLSID_SequenceMgr, &psz) ) )
    {
        WideCharToMultiByte( CP_ACP, 0, psz, -1, szEditorGuid, sizeof(szEditorGuid), NULL, NULL );
        CoTaskMemFree( psz );
		if( SUCCEEDED( StringFromIID(CLSID_DirectMusicSeqTrack, &psz) ) )
		{
			WideCharToMultiByte( CP_ACP, 0, psz, -1, szTrackGuid, sizeof(szTrackGuid), NULL, NULL );
			CoTaskMemFree( psz );

			strTrackName.LoadString( IDS_TRACK_NAME );
			_tcscpy( szRegPath, szComponentPath );
			_tcscat( szRegPath, szTrackGuid );
			if( !(SetRegString(HKEY_LOCAL_MACHINE, szRegPath, _T(""), strTrackName)) )
			{
				return FALSE;
			}
			if( !(SetRegString(HKEY_LOCAL_MACHINE, szRegPath, szStripManager, szEditorGuid)) )
			{
				return FALSE;
			}
			strEditorName.LoadString( IDS_EDITOR_NAME );
			if( !(SetRegString(HKEY_LOCAL_MACHINE, szRegPath, szUserName, strEditorName)) )
			{
				return FALSE;
			}
		}
    }
	else
	{
		return FALSE;
	}

	return TRUE;
}

static BOOL UnregisterComponents( void )
{
	LPOLESTR psz;
	TCHAR    szRegPath[255];
	TCHAR    szGuid[100];
	
	if( SUCCEEDED( StringFromIID(CLSID_DirectMusicSeqTrack, &psz) ) )
   	{
		WideCharToMultiByte( CP_ACP, 0, psz, -1, szGuid, sizeof(szGuid), NULL, NULL );
		CoTaskMemFree( psz );

		_tcscpy( szRegPath, _T("Software\\Microsoft\\DMUSProducer\\StripEditors\\") );
		_tcscat( szRegPath, szGuid );
		if( RegDeleteKey(HKEY_LOCAL_MACHINE, szRegPath) != ERROR_SUCCESS )
		{
			return FALSE;
		}
	}
	else
	{
		return FALSE;
	}

	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
	// registers object
	if ( _Module.RegisterServer(FALSE) )
	{
		return ResultFromScode(SELFREG_E_CLASS);
	}

	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	if( !RegisterComponents() )
	{
		return ResultFromScode(SELFREG_E_FIRST+2);
	}

	return NOERROR;
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	/*
	if ( !AfxOleUnregisterTypeLib( LIBID_SequenceSTRIPMGRLib ) )
	{
		return ResultFromScode(SELFREG_E_TYPELIB);
	}
	*/

	if ( _Module.UnregisterServer(FALSE) )
	{
		return ResultFromScode(SELFREG_E_CLASS);
	}

	if( !UnregisterComponents() )
	{
		return ResultFromScode(SELFREG_E_FIRST+2);
	}
	return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SequenceStripMgr\SequenceStrip.cpp ===
// SequenceStrip.cpp : Implementation of CSequenceStrip
#include "stdafx.h"
#include "SequenceIO.h"
#include "SequenceStripMgr.h"
#include "SequenceMgr.h"
//#include "PropPageMgr.h"
#include "QuantizeDlg.h"
#include "DialogVelocity.h"
#include "DLLJazzDataObject.h"
#include "GroupBitsPPG.h"
#include <RiffStrm.h>
#include <dmusici.h>
#include <dmusicf.h>
#include "midifileio.h"
#include "notetracker.h"
#include "CurveStrip.h"
#include "DialogNewCCTrack.h"
#include "BandEditor.h"
#include <PChannelName.h>
#include "PropPageSeqTrack.h"
#include "SegmentIO.h"
#include "SharedPianoRoll.h"
#include "TrackFlagsPPG.h"
#include "GrayOutRect.h"
#include "windowsx.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define INSTRUMENT_BUTTON_HEIGHT 20
#define NEWBAND_BUTTON_WIDTH 20

#define WM_APP_BUMPTIMECURSOR 0
#define WM_APP_INVALIDATEPIANOROLL 1
#define WM_APP_INSTRUMENTMENU 2
#define WM_APP_BANDMENU 3

#define MIDI_NOTEOFF    0x80
#define MIDI_NOTEON     0x90
#define MIDI_PTOUCH     0xA0
#define MIDI_CCHANGE    0xB0
#define MIDI_PCHANGE    0xC0
#define MIDI_MTOUCH     0xD0
#define MIDI_PBEND      0xE0


long	CSequenceStrip::m_lBitmapRefCount = 0;
CBitmap	CSequenceStrip::m_BitmapZoomInUp;
CBitmap	CSequenceStrip::m_BitmapZoomInDown;
CBitmap	CSequenceStrip::m_BitmapZoomOutUp;
CBitmap	CSequenceStrip::m_BitmapZoomOutDown;
CBitmap CSequenceStrip::m_BitmapNewBand;

MUSIC_TIME GetTimeOffset( const MUSIC_TIME mtNow, const MUSIC_TIME mtCurrentStartTime, const MUSIC_TIME mtCurrentStartPoint,
						  const MUSIC_TIME mtCurrentLoopStart, const MUSIC_TIME mtCurrentLoopEnd, const MUSIC_TIME mtLength,
						  const DWORD dwCurrentMaxLoopRepeats )
{
	// Convert mtNow from absolute time to an offset from when the segment started playing
	LONGLONG llBigNow = mtNow - (mtCurrentStartTime - mtCurrentStartPoint);

	// If mtLoopEnd is non zero, set lLoopEnd to mtLoopEnd, otherwise use the segment length
	LONGLONG llLoopEnd = mtCurrentLoopEnd ? mtCurrentLoopEnd : mtLength;

	LONGLONG llLoopStart = mtCurrentLoopStart;

	if( (dwCurrentMaxLoopRepeats != 0) &&
		(llLoopStart < llLoopEnd) )
	{
		if( (dwCurrentMaxLoopRepeats != DMUS_SEG_REPEAT_INFINITE)
		&&	(llBigNow > (llLoopStart + (llLoopEnd - llLoopStart) * (signed)dwCurrentMaxLoopRepeats)) )
		{
			llBigNow -= (llLoopEnd - llLoopStart) * dwCurrentMaxLoopRepeats;
		}
		else if( llBigNow > llLoopStart )
		{
			llBigNow = llLoopStart + (llBigNow - llLoopStart) % (llLoopEnd - llLoopStart);
		}
	}

	llBigNow = min( llBigNow, LONG_MAX );

	return long(llBigNow);
}

/////////////////////////////////////////////////////////////////////////////
// CSequenceStrip constructor/destructor

CSequenceStrip::CSequenceStrip( CSequenceMgr* pSequenceMgr )
{
	ASSERT( pSequenceMgr );
	if ( pSequenceMgr == NULL )
	{
		return;
	}

	// initialize our reference count
	m_cRef = 0;
	AddRef();

	m_pSequenceMgr = pSequenceMgr;
	m_pStripMgr = (IDMUSProdStripMgr*)pSequenceMgr;
	//m_pStripMgr->AddRef();

	m_lBeginSelect = 0;
	m_lEndSelect = 0;
	m_bGutterSelected = FALSE;
	m_SelectionMode = SEQ_NO_SELECT;
	m_bSelectionCC = 0xFF;
	m_wSelectionParamType = 0xFFFF;

	ZeroMemory( &m_pointSelection, sizeof(POINT) );
	m_fSelecting = FALSE;

	UpdateName();
	m_iHaveFocus = 0;
	m_mtLength = 0;

	m_svView = SV_MINIMIZED;
	m_lVScroll = -1;
	m_fHybridNotation = FALSE;
	m_dblVerticalZoom = 0.1;
	ZeroMemory(m_aiAccidentals, sizeof(int) * 75);
	ZeroMemory(m_aiScalePattern, sizeof(int) * 7);

	m_fZoomInPressed		= FALSE;
	m_fZoomOutPressed		= FALSE;
	m_fNewBandPressed		= FALSE;
	m_fInstrumentPressed	= FALSE;
	m_fInstrumentEnabled	= FALSE;

	// Curve Strip fields
	m_CurveStripView = SV_MINIMIZED;
	m_lstCurveStripStates.RemoveAll();
	m_lstCurveStrips.RemoveAll();

	m_lXPos = -1;
	m_pSelectPivotSeq = NULL;
	m_pActiveNote = NULL;
	m_OriginalSeqItem.Clear();
	ZeroMemory( &m_pointClicked, sizeof(POINT) );
	m_nLastEdit = 0;
	m_fCtrlKeyDown = FALSE;
	m_lLastDeltaMove = 0;
	m_cLastDeltaValue = 0;
	m_lLastDeltaDur = 0;
	m_lLastDeltaVel = 0;
	m_lLastDeltaStart = 0;
	m_fScrollTimerActive = FALSE;
	m_crSelectedNoteColor = COLOR_DEFAULT_SELECTED;
	m_crUnselectedNoteColor = COLOR_DEFAULT_UNSELECTED;
	m_crOverlappingNoteColor = COLOR_DEFAULT_OVERLAPPING;
	m_crAccidentalColor = COLOR_DEFAULT_ACCIDENTAL;
	m_lInsertVal = 60;
	m_lInsertTime = 0;
	m_mtLastLateTime = 0;
	m_dwExtraBars = 0;
	m_fPickupBar = FALSE;
	m_fInsertingNoteFromMouseClick = false;
	m_pActiveCurveStrip = NULL;
	m_dwLastPatch = INVALID_PATCH;

	m_pITargetDataObject = NULL;
	m_dwOverDragButton = 0;
	m_dwOverDragEffect = 0;
	m_dwDragRMenuEffect = DROPEFFECT_NONE;

	m_cfSequenceList = ::RegisterClipboardFormat( CF_SEQUENCELIST );
	m_cfMidiFile = ::RegisterClipboardFormat( CF_MIDIFILE );

	m_bMinimizeTopNote = 127;
	m_bMinimizeNoteRange = 127;
	m_lMaxNoteHeight = long( MAX_NOTE_HEIGHT * m_dblVerticalZoom + HORIZ_LINE_HEIGHT );
	m_hCursor = GetArrowCursor();
	m_MouseMode = SEQ_MM_NORMAL;

	m_fShowSequenceProps = FALSE;
	m_fPropPageActive = FALSE;
	m_pPropPageMgr = NULL;

	m_rectVScroll.SetRectEmpty();
	//m_VScrollBar; // Initalized by contstructor

	// MIDI
	m_fMIDIInRegistered = FALSE;
	m_fMIDIThruEnabled = FALSE;
	m_dwCookie = 0;
	ZeroMemory( m_bVelocity, 128 * sizeof( BYTE ) );
	ZeroMemory( m_mtStartTime, 128 * sizeof( MUSIC_TIME ) );
}

CSequenceStrip::~CSequenceStrip()
{
	ASSERT( m_pStripMgr );

	// Curve Strip fields
	ioCurveStripState* pCurveStripState;
	while( !m_lstCurveStripStates.IsEmpty() )
	{
		pCurveStripState = static_cast<ioCurveStripState*>( m_lstCurveStripStates.RemoveHead() );
		delete pCurveStripState;
	}
	CCurveStrip *pCurveStrip;
	while( !m_lstCurveStrips.IsEmpty() )
	{
		pCurveStrip = static_cast<CCurveStrip*>( m_lstCurveStrips.RemoveHead() );
		if( m_pSequenceMgr && m_pSequenceMgr->m_pTimeline )
		{
			m_pSequenceMgr->m_pTimeline->RemoveStrip( (IDMUSProdStrip *)pCurveStrip );
		}
		pCurveStrip->Release();
	}

	if (m_fMIDIInRegistered)
	{
		UnRegisterMidi();
	}

	if ( m_pStripMgr )
	{
		//m_pStripMgr->Release();
		m_pStripMgr = NULL;
		m_pSequenceMgr = NULL;
	}
	if ( m_pITargetDataObject )
	{
		m_pITargetDataObject->Release();
	}
	if ( m_pPropPageMgr )
	{
		m_pPropPageMgr->Release();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CSequenceStrip IUnknown implementation

/////////////////////////////////////////////////////////////////////////////
// CSequenceStrip::QueryInterface

STDMETHODIMP CSequenceStrip::QueryInterface( REFIID riid, LPVOID *ppv )
{
	ASSERT( ppv );
	if ( ppv == NULL )
	{
		return E_INVALIDARG;
	}

    *ppv = NULL;

    if (IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_IDMUSProdStrip))
	{
        *ppv = (IUnknown *) (IDMUSProdStrip *) this;
	}
	else if (IsEqualIID(riid, IID_IDMUSProdStripFunctionBar))
	{
        *ppv = (IUnknown *) (IDMUSProdStripFunctionBar *) this;
	}
	else if( IsEqualIID( riid, IID_IDMUSProdTimelineEdit ))
	{
		*ppv = (IDMUSProdTimelineEdit*) this;
	}
	else if (IsEqualIID(riid, IID_IDMUSProdPropPageObject))
	{
        *ppv = (IUnknown *) (IDMUSProdPropPageObject *) this;
	}
	else if( IsEqualIID( riid, IID_IDropTarget ))
	{
		*ppv = (IUnknown *) (IDropTarget *) this;
	}
	else if( IsEqualIID( riid, IID_IDMUSProdMidiInCPt ))
	{
		*ppv = (IUnknown *) (IDMUSProdMidiInCPt *) this;
	}
	else
	{
		return E_NOTIMPL;
	}

    ((IUnknown *) *ppv)->AddRef();
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CSequenceStrip::AddRef

STDMETHODIMP_(ULONG) CSequenceStrip::AddRef(void)
{
	return ++m_cRef;
}


/////////////////////////////////////////////////////////////////////////////
// CSequenceStrip::Release

STDMETHODIMP_(ULONG) CSequenceStrip::Release(void)
{
	if( 0L == --m_cRef )
	{
		delete this;
		return 0;
	}
	else
	{
		return m_cRef;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CSequenceStrip IDMUSProdStrip implementation

/////////////////////////////////////////////////////////////////////////////
// CSequenceStrip::Draw

HRESULT	STDMETHODCALLTYPE CSequenceStrip::Draw( HDC hDC, STRIPVIEW sv, LONG lXOffset )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if (!hDC)
	{
		return E_INVALIDARG;
	}

	// Validate pointer to the Timeline
	if( m_pSequenceMgr->m_pTimeline == NULL )
	{
		return E_UNEXPECTED;
	}

	// Get the clipping rectangle
	RECT rectClip;
	::GetClipBox( hDC, &rectClip );

	// Find the highest and lowest MIDI values to display
	int nTopNote = 127, nBottomNote = 0;
	if (sv == SV_NORMAL)
	{
		long lOrigRightClip = rectClip.right;
		long lOrigLeftClip = rectClip.left;
		if( lXOffset < 0 )
		{
			rectClip.left = max( -lXOffset, rectClip.left);
		}

		long lTimelinePixelLength = LONG_MIN;
		if( SUCCEEDED( m_pSequenceMgr->m_pTimeline->ClocksToPosition( m_mtLength, &lTimelinePixelLength ) ) )
		{
			lTimelinePixelLength -= lXOffset;
			rectClip.right = min( rectClip.right, lTimelinePixelLength );
		}

		if( m_fHybridNotation )
		{
			nTopNote = 38 - (rectClip.top / m_lMaxNoteHeight);
			nBottomNote = 38 - (rectClip.bottom / m_lMaxNoteHeight);
			if( nBottomNote < 0 )
			{
				nBottomNote = 0;
			}

			// Draw the background horizontal lines
			DrawHybridLines( hDC, rectClip, nBottomNote, nTopNote );

			// TODO: Fix this so it's more accurate (Also in PianoRollStrip.cpp)
			nTopNote = min( nTopNote * 4, 127 );
			nBottomNote = max( nBottomNote * 3, 0);
		}
		else
		{
			nTopNote = 127 - (rectClip.top / m_lMaxNoteHeight);
			nBottomNote = 127 - (rectClip.bottom / m_lMaxNoteHeight);
			nTopNote = min( nTopNote, 127 );
			nBottomNote = max( nBottomNote, 0);

			// Draw the background horizontal lines (and white/grey bars)
			DrawHorizontalLines( hDC, rectClip, nBottomNote, nTopNote );
		}

		// Check if we are displaying part of a pick-up measure
		if( rectClip.left != lOrigLeftClip )
		{
			// Restore the clipping rectangle
			rectClip.left = lOrigLeftClip;

			// Save the old right edge of the clipping rectangle
			long lTmpRight = rectClip.right;

			// Update the right edge of the clipping rectangle to be at time 0
			rectClip.right = min( rectClip.right, -lXOffset );

			// Draw the dark background horizontal lines
			if( m_fHybridNotation )
			{
				DrawDarkHybridLines( hDC, rectClip, max( 0, 38 - (rectClip.bottom / m_lMaxNoteHeight) ), 38 - (rectClip.top / m_lMaxNoteHeight) );
			}
			else
			{
				DrawDarkHorizontalLines( hDC, rectClip, nBottomNote, nTopNote );
			}

			// Restore the clipping rectangle
			rectClip.right = lTmpRight;
		}

		// Check if we are displaying part of an extension measure
		if( rectClip.right != lOrigRightClip )
		{
			// Restore the clipping rectangle
			rectClip.right = lOrigRightClip;

			// Save the old left edge of the clipping rectangle
			long lTmpLeft = rectClip.left;

			// Update the left edge of the clipping rectangle to be at the end of normal time
			if( lTimelinePixelLength != LONG_MIN )
			{
				rectClip.left = max( rectClip.left, lTimelinePixelLength );

				// Draw the dark background horizontal lines
				if( m_fHybridNotation )
				{
					DrawDarkHybridLines( hDC, rectClip, max( 0, 38 - (rectClip.bottom / m_lMaxNoteHeight) ), 38 - (rectClip.top / m_lMaxNoteHeight) );
				}
				else
				{
					DrawDarkHorizontalLines( hDC, rectClip, nBottomNote, nTopNote );
				}
			}

			// Restore the clipping rectangle
			rectClip.left = lTmpLeft;
		}

		// Draw Measure and Beat lines in our strip
		m_pSequenceMgr->m_pTimeline->DrawMusicLines( hDC, ML_DRAW_MEASURE_BEAT_GRID, m_pSequenceMgr->m_dwGroupBits, 0, lXOffset );
	}
	else if (sv == SV_MINIMIZED)
	{
		// Compute the top and bottom notes to display so we can scale the display accordingly
		BYTE bBottomNote = 127;
		m_bMinimizeTopNote = 0;
		POSITION pos = m_pSequenceMgr->m_lstSequences.GetHeadPosition();
		while( pos )
		{
			const CSequenceItem *pSequenceItem = m_pSequenceMgr->m_lstSequences.GetNext( pos );
			ASSERT( pSequenceItem );

			if ( m_bMinimizeTopNote < pSequenceItem->m_bByte1 )
			{
				m_bMinimizeTopNote = pSequenceItem->m_bByte1;
			}
			if ( bBottomNote > pSequenceItem->m_bByte1 )
			{
				bBottomNote = pSequenceItem->m_bByte1;
			}
		}

		if ( m_bMinimizeTopNote == 0 && bBottomNote == 127 )
		{
			m_bMinimizeNoteRange = 12;
			m_bMinimizeTopNote = 127;
		}
		else
		{
			m_bMinimizeNoteRange = BYTE(1 + m_bMinimizeTopNote - bBottomNote);
		}

		// If the range is less than 12, set it to 12
		ASSERT( m_bMinimizeNoteRange > 0 );
		if ( m_bMinimizeNoteRange < 12 )
		{
			m_bMinimizeNoteRange = 12;
		}

		// Draw Measure and Beat lines in our strip
		m_pSequenceMgr->m_pTimeline->DrawMusicLines( hDC, ML_DRAW_MEASURE_BEAT, m_pSequenceMgr->m_dwGroupBits, 0, lXOffset );
	}

	// invertrect selected time
	if( m_bGutterSelected && (m_lBeginSelect != m_lEndSelect) )
	{
		long beginPos, endPos;
		RECT rectInvert;
		
		m_pSequenceMgr->m_pTimeline->ClocksToPosition( m_lBeginSelect, &beginPos );
		m_pSequenceMgr->m_pTimeline->ClocksToPosition( m_lEndSelect, &endPos );
		if( ( endPos != 0 ) && ( beginPos == endPos ) )
		{
			endPos += 1;
		}
		rectInvert.left = beginPos - lXOffset;
		rectInvert.right = endPos - lXOffset;
		rectInvert.top = rectClip.top;
		rectInvert.bottom = rectClip.bottom;
		GrayOutRect( hDC, &rectInvert );
	}

	long	lStartTime, lEndTime;
	m_pSequenceMgr->m_pTimeline->PositionToClocks( rectClip.left + lXOffset, &lStartTime );
	m_pSequenceMgr->m_pTimeline->PositionToClocks( rectClip.right + lXOffset, &lEndTime );
	
	if( sv == SV_NORMAL )
	{
		POSITION pos = GetFirstVisibleNote( lStartTime, lEndTime, nTopNote, nBottomNote );

		if( pos )
		{
			if( m_fHybridNotation )
			{
				// Clear out the list that keeps track of overlapping notes
				m_aNoteRectList[0].RemoveAll();

				// Draw unselected notes
				DrawHybridMaximizedNotes( hDC, pos, lStartTime, lEndTime, lXOffset, nTopNote, nBottomNote, FALSE );

				// Clear out the list that keeps track of overlapping notes
				m_aNoteRectList[0].RemoveAll();

				// Draw selected notes
				DrawHybridMaximizedNotes( hDC, pos, lStartTime, lEndTime, lXOffset, nTopNote, nBottomNote, TRUE );

				// Draw the Accidentals
				DrawHybridMaximizedAccidentals( hDC, pos, lStartTime, lEndTime, lXOffset, nTopNote, nBottomNote );
			}
			else
			{
				// Clear out the list that keeps track of overlapping notes
				for( int i=nBottomNote; i<=nTopNote; i++ )
				{
					m_aNoteRectList[i].RemoveAll();
				}

				// Draw unselected notes
				DrawMaximizedNotes( hDC, pos, lStartTime, lEndTime, lXOffset, nTopNote, nBottomNote, FALSE );

				// Clear out the list that keeps track of overlapping notes
				for( i=nBottomNote; i<=nTopNote; i++ )
				{
					m_aNoteRectList[i].RemoveAll();
				}

				// Draw selected notes
				DrawMaximizedNotes( hDC, pos, lStartTime, lEndTime, lXOffset, nTopNote, nBottomNote, TRUE );
			}
		}

		if( (m_iHaveFocus == 1) && (m_lInsertVal <= nTopNote) && (m_lInsertVal >= nBottomNote) )
		{
			DrawNoteInsertionMark( hDC, lStartTime, lEndTime, lXOffset );
		}
	}
	else if( sv == SV_MINIMIZED )
	{
		POSITION pos = GetFirstVisibleNote( lStartTime, lEndTime, 127, 0 );

		if( !pos )
		{
			return S_OK;
		}

		DrawMinimizedNotes( hDC, pos, lStartTime, lEndTime, lXOffset, FALSE );
		DrawMinimizedNotes( hDC, pos, lStartTime, lEndTime, lXOffset, TRUE );
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CSequenceStrip::GetStripProperty

HRESULT STDMETHODCALLTYPE CSequenceStrip::GetStripProperty( STRIPPROPERTY sp, VARIANT *pvar)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	if( NULL == pvar )
	{
		return E_POINTER;
	}

	switch( sp )
	{
	case SP_RESIZEABLE:
		pvar->vt = VT_BOOL;
		V_BOOL(pvar) = TRUE;
		break;
	case SP_GUTTERSELECTABLE:
		pvar->vt = VT_BOOL;
		V_BOOL(pvar) = TRUE;
		break;
	case SP_MINMAXABLE:
		pvar->vt = VT_BOOL;
		V_BOOL(pvar) = TRUE;
		break;
	case SP_DEFAULTHEIGHT:
		pvar->vt = VT_INT;
		V_INT(pvar) = DEFAULT_HEIGHT;
		break;
	case SP_MAXHEIGHT:
		pvar->vt = VT_INT;
		if( m_fHybridNotation )
		{
			V_INT(pvar) = m_lMaxNoteHeight * 38;
		}
		else
		{
			V_INT(pvar) = m_lMaxNoteHeight * 128;
		}
		break;
	case SP_MINHEIGHT:
	case SP_MINIMIZE_HEIGHT:
		pvar->vt = VT_INT;
		V_INT(pvar) = MINIMIZE_HEIGHT;
		break;
	case SP_NAME:
		{
			BSTR bstr;

			UpdateName();
			pvar->vt = VT_BSTR; 
			try
			{
				bstr = m_strName.AllocSysString();
			}
			catch(CMemoryException*)
			{
				return E_OUTOFMEMORY;
			}
			V_BSTR(pvar) = bstr;
		}
		break;
	case SP_CURSOR_HANDLE:
		pvar->vt = VT_I4;
		V_I4(pvar) = (int) m_hCursor;
		break;
	case PRIVATE_SP_CLSID:
		// CLSID used to identify type of strip
		if( (pvar->vt == VT_BYREF)
		&&  (V_BYREF(pvar) != NULL) )
		{
			CLSID* pCLSID = (CLSID *)V_BYREF(pvar);
		   *pCLSID = CLSID_DirectMusicSeqTrack;
		}
		else
		{
			return E_FAIL;
		}
		break;
	case SP_STRIPMGR:
		pvar->vt = VT_UNKNOWN;
		m_pSequenceMgr->QueryInterface( IID_IUnknown, (void **) &V_UNKNOWN(pvar) );
		break;

	case SP_FUNCTIONBAR_EXCLUDE_WIDTH:
		pvar->vt = VT_I4;
		V_I4(pvar) = m_BitmapZoomInUp.GetBitmapDimension().cx;
		break;

	case PRIVATE_SP_PCHANNEL:
		pvar->vt = VT_I4;
		V_I4(pvar) = m_pSequenceMgr->m_dwPChannel;
		break;

	case SP_EARLY_TIME:
		m_fPickupBar = ShouldDisplayPickupBar();
		if( m_fPickupBar )
		{
			DMUS_TIMESIGNATURE dmTimeSig;
			GetTimeSig( 0, &dmTimeSig, m_pSequenceMgr->m_pTimeline, m_pSequenceMgr->m_dwGroupBits );

			// Found an early note
			pvar->vt = VT_I4;
			V_I4(pvar) = dmTimeSig.bBeatsPerMeasure * ((DMUS_PPQ * 4) / dmTimeSig.bBeat);
			//m_mtLastEarlyTime = m_lMeasureClocks;
			return S_OK;
		}

		// No early notes
		//m_mtLastEarlyTime = 0;
		return E_FAIL;
		break;

	case SP_LATE_TIME:
		m_dwExtraBars = GetNumExtraBars();

		if( m_dwExtraBars )
		{
			//this->m_mtLength;

			// Find out when the last measure starts
			long lLastMeasureStart;
			m_pSequenceMgr->m_pTimeline->ClocksToMeasureBeat( m_pSequenceMgr->m_dwGroupBits, m_pSequenceMgr->m_dwIndex, m_mtLength, &lLastMeasureStart, NULL );
			m_pSequenceMgr->m_pTimeline->MeasureBeatToClocks( m_pSequenceMgr->m_dwGroupBits, m_pSequenceMgr->m_dwIndex, lLastMeasureStart, 0, &lLastMeasureStart );

			// Find out the TimeSig of the last measure
			DMUS_TIMESIGNATURE dmTimeSig;
			GetTimeSig( m_mtLength - 1, &dmTimeSig, m_pSequenceMgr->m_pTimeline, m_pSequenceMgr->m_dwGroupBits );
			const long lMeasureLength = dmTimeSig.bBeatsPerMeasure * ((DMUS_PPQ * 4) / dmTimeSig.bBeat);

			// Compute the amount of time to display
			pvar->vt = VT_I4;
			V_I4(pvar) = m_dwExtraBars * lMeasureLength + lLastMeasureStart - m_mtLength;
			m_mtLastLateTime = V_I4(pvar);

			return S_OK;
		}

		// No late notes
		m_mtLastLateTime = 0;
		return E_FAIL;
		break;

	default:
		return E_FAIL;
	}
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CSequenceStrip::SetStripProperty

HRESULT STDMETHODCALLTYPE CSequenceStrip::SetStripProperty( STRIPPROPERTY sp, VARIANT var)
{
	switch( sp )
	{
	case SP_BEGINSELECT:
	case SP_ENDSELECT:
	{
		long lNewSelection;
		BOOL fChanged;
		
		fChanged = FALSE;

		// Validate parameter
		if( var.vt != VT_I4)
		{
			return E_FAIL;
		}

		// Set selection
		lNewSelection = V_I4( &var );
		if( sp == SP_BEGINSELECT )
		{
			if( m_lBeginSelect != lNewSelection )
			{
				m_lBeginSelect = lNewSelection;
				fChanged = TRUE;
			}
		}
		else
		{
			if( m_lEndSelect != lNewSelection )
			{
				m_lEndSelect = lNewSelection;
				fChanged = TRUE;
			}
		}

		// Update our curve strips with the new selection
		UpdateCurveStripGutterSelection( fChanged );

		// Exit early if we're just clearing the Timeline selection
		if( m_fSelecting )
		{
			if( m_bGutterSelected )
			{
				InvalidateStrip();
			}
			break;
		}

		// If start time == end time, deselect everything
		if( m_lBeginSelect == m_lEndSelect )
		{
			if( m_SelectionMode != SEQ_NO_SELECT )
			{
				// This refreshes the display, if necessary
				m_pSequenceMgr->UnselectAllNotes();
			}
			break;
		}

		if( m_bGutterSelected && (m_lBeginSelect >= 0) && (m_lEndSelect > 0))
		{
			// This may be true if only curves were selected
			if( SelectEventsBetweenTimes( m_lBeginSelect, m_lEndSelect ) )
			{
				m_pSequenceMgr->RefreshPropertyPage();
			}

			// Redraw this piano roll
			InvalidateStrip();
		}
		break;
	}

	case SP_GUTTERSELECT:
		if( m_bGutterSelected != V_BOOL(&var) )
		{
			m_bGutterSelected = V_BOOL(&var);

			// Make sure timeline is in sync because change may be passed through from Curve strip
			if( m_pSequenceMgr->m_pTimeline )
			{
				var.vt = VT_BOOL;
				V_BOOL(&var) = (short)m_bGutterSelected;
				m_pSequenceMgr->m_pTimeline->StripSetTimelineProperty( (IDMUSProdStrip *)this, STP_GUTTER_SELECTED, var );
			}
			
			// Update our curve strips with the new selection state
			UpdateCurveStripGutterSelection( TRUE );

			if(m_bGutterSelected  && (m_lBeginSelect >= 0) && (m_lEndSelect > 0))
			{
				// This may be true if only curves were selected
				if( SelectEventsBetweenTimes( m_lBeginSelect, m_lEndSelect ) )
				{
					m_pSequenceMgr->RefreshPropertyPage();
				}
			}
			else
			{
				m_pSequenceMgr->UnselectAllNotes();
			}

			// Redraw this piano roll
			InvalidateStrip();
		}
		break;
	default:
		return E_FAIL;
	}
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CSequenceStrip::OnRButtonUp

HRESULT CSequenceStrip::OnRButtonUp( void )
{
	HRESULT hr = S_OK;
	POINT pt;
	BOOL  bResult;

	// Get the cursor position (To put the menu there)
	bResult = ::GetCursorPos( &pt );
	ASSERT( bResult );
	if( !bResult )
	{
		return E_UNEXPECTED;
	}

	ASSERT( m_pSequenceMgr != NULL );
	if ( m_pSequenceMgr == NULL )
	{
		return E_UNEXPECTED;
	}

	ASSERT( m_pSequenceMgr->m_pTimeline != NULL );
	if ( m_pSequenceMgr->m_pTimeline == NULL )
	{
		return E_UNEXPECTED;
	}

	HMENU hMenu, hMenuPopup;
	hMenu = ::LoadMenu( AfxGetInstanceHandle(), MAKEINTRESOURCE(IDR_EDIT_MENU));
	if (hMenu == NULL)
	{
		return E_UNEXPECTED;
	}

	hMenuPopup = ::GetSubMenu( hMenu, 0 );
	if (hMenuPopup == NULL)
	{
		DestroyMenu(hMenu);
		return E_UNEXPECTED;
	}

	// update items
	EnableMenuItem( hMenuPopup, ID_EDIT_CUT, ( CanCut() == S_OK ) ?
					MF_ENABLED : MF_GRAYED );
	EnableMenuItem( hMenuPopup, ID_EDIT_COPY, ( CanCopy() == S_OK ) ?
					MF_ENABLED : MF_GRAYED );
	EnableMenuItem( hMenuPopup, 2, ( CanPaste() == S_OK ) ?
					MF_BYPOSITION | MF_ENABLED : MF_BYPOSITION | MF_GRAYED );
	EnableMenuItem( hMenuPopup, ID_EDIT_SELECT_ALL, ( CanSelectAll() == S_OK ) ?
					MF_ENABLED : MF_GRAYED );
	EnableMenuItem( hMenuPopup, ID_EDIT_INSERT, ( (m_svView == SV_NORMAL) && (CanInsert() == S_OK) ) ?
					MF_ENABLED : MF_GRAYED );
	EnableMenuItem( hMenuPopup, ID_EDIT_DELETE, ( CanDelete() == S_OK ) ?
					MF_ENABLED : MF_GRAYED );

	// Views menu
	EnableMenuItem( hMenuPopup, 12, ( m_svView == SV_NORMAL ) ?
					MF_BYPOSITION | MF_ENABLED : MF_BYPOSITION | MF_GRAYED );
	::CheckMenuItem( hMenuPopup, ID_EDIT_VIEW_PIANOROLL, m_fHybridNotation ? MF_UNCHECKED : MF_CHECKED );
	::CheckMenuItem( hMenuPopup, ID_EDIT_VIEW_HYBRID, m_fHybridNotation ? MF_CHECKED : MF_UNCHECKED );

	// Snap-to menu
	VARIANT var;
	if( SUCCEEDED( m_pSequenceMgr->m_pTimeline->GetTimelineProperty( TP_SNAP_TO, &var ) ) )
	{
		::EnableMenuItem( hMenuPopup, 10, MF_BYPOSITION | MF_ENABLED );
		switch( (DMUSPROD_TIMELINE_SNAP_TO) V_I4( &var ) )
		{
		case DMUSPROD_TIMELINE_SNAP_NONE:
			::CheckMenuItem( hMenuPopup, ID_SNAP_NONE, MF_CHECKED );
			::CheckMenuItem( hMenuPopup, ID_SNAP_GRID, MF_UNCHECKED );
			::CheckMenuItem( hMenuPopup, ID_SNAP_BEAT, MF_UNCHECKED );
			::CheckMenuItem( hMenuPopup, ID_SNAP_BAR, MF_UNCHECKED );
			break;
		case DMUSPROD_TIMELINE_SNAP_GRID:
			::CheckMenuItem( hMenuPopup, ID_SNAP_NONE, MF_UNCHECKED );
			::CheckMenuItem( hMenuPopup, ID_SNAP_GRID, MF_CHECKED );
			::CheckMenuItem( hMenuPopup, ID_SNAP_BEAT, MF_UNCHECKED );
			::CheckMenuItem( hMenuPopup, ID_SNAP_BAR, MF_UNCHECKED );
			break;
		case DMUSPROD_TIMELINE_SNAP_BEAT:
			::CheckMenuItem( hMenuPopup, ID_SNAP_NONE, MF_UNCHECKED );
			::CheckMenuItem( hMenuPopup, ID_SNAP_GRID, MF_UNCHECKED );
			::CheckMenuItem( hMenuPopup, ID_SNAP_BEAT, MF_CHECKED );
			::CheckMenuItem( hMenuPopup, ID_SNAP_BAR, MF_UNCHECKED );
			break;
		case DMUSPROD_TIMELINE_SNAP_BAR:
			::CheckMenuItem( hMenuPopup, ID_SNAP_NONE, MF_UNCHECKED );
			::CheckMenuItem( hMenuPopup, ID_SNAP_GRID, MF_UNCHECKED );
			::CheckMenuItem( hMenuPopup, ID_SNAP_BEAT, MF_UNCHECKED );
			::CheckMenuItem( hMenuPopup, ID_SNAP_BAR, MF_CHECKED );
			break;
		default:
			ASSERT(FALSE);
			break;
		}
	}
	else
	{
		::EnableMenuItem( hMenuPopup, 10, MF_BYPOSITION | MF_GRAYED );
	}

	// Zoom items
	EnableMenuItem( hMenuPopup, ID_EDIT_ZOOMIN, ( m_svView == SV_NORMAL ) ?
					MF_ENABLED : MF_GRAYED );
	EnableMenuItem( hMenuPopup, ID_EDIT_ZOOMOUT, ( m_svView == SV_NORMAL ) ?
					MF_ENABLED : MF_GRAYED );

	m_pSequenceMgr->m_pTimeline->TrackPopupMenu(hMenuPopup, pt.x, pt.y, (IDMUSProdStrip *)this, FALSE);
	DestroyMenu(hMenu); // This will destroy the submenu as well.

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CSequenceStrip::OnWMMessage

HRESULT STDMETHODCALLTYPE CSequenceStrip::OnWMMessage( UINT nMsg, WPARAM wParam, LPARAM lParam, LONG lXPos, LONG lYPos )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	UNREFERENCED_PARAMETER(lParam);

	// Validate state
	if( !m_pSequenceMgr || !m_pSequenceMgr->m_pTimeline )
	{
		ASSERT(FALSE);
		return E_UNEXPECTED;
	}

	// Process the window message
	HRESULT hr = S_OK;

	switch( nMsg )
	{
	case WM_TIMER:
		OnTimer();
		break;

	case WM_SETFOCUS:
		hr = SetFocus( 1 );
		break;

	case WM_KILLFOCUS:
		// Stop any playing note
		m_pSequenceMgr->StopNote();

		hr = SetFocus( 0 );
		break;

	case WM_LBUTTONDOWN:
	case WM_LBUTTONDBLCLK:
		hr = OnLButtonDown( wParam, lXPos, lYPos );
		break;

	case WM_LBUTTONUP:
		hr = OnLButtonUp( lXPos, lYPos );
		break;

/*
	case WM_LBUTTONUP:
		m_lXPos = lXPos;
		// Make sure everything on the timeline is deselected.
		m_fSelecting = TRUE;
		m_pSequenceMgr->m_pTimeline->SetMarkerTime( MARKER_BEGINSELECT, TIMETYPE_CLOCKS, 0 );
		m_pSequenceMgr->m_pTimeline->SetMarkerTime( MARKER_ENDSELECT, TIMETYPE_CLOCKS, 0 );
		m_fSelecting = FALSE;
		hr = S_OK;
		break;*/

	case WM_RBUTTONDOWN:
		UpdateNoteCursorTime();

		{	// Update insert value
			long lNewPosition = PositionToMIDIValue( lYPos );
			if( m_lInsertVal != lNewPosition )
			{
				m_lInsertVal = lNewPosition;
				InvalidatePianoRoll();
			}
		}
		break;

	case WM_RBUTTONUP:
		{
			m_fShowSequenceProps = TRUE;

			UnselectGutterRange();
			if (m_svView != SV_MINIMIZED)
			{
				// Select the note click on iff
				CSequenceItem *pSeqItem = GetSeqItemAndRectFromPoint( lXPos, lYPos, NULL );
				if( (pSeqItem != NULL) && (m_SelectionMode != SEQ_MULTIPLE_SELECT) )
				{
					if (m_pActiveNote != pSeqItem)
					{
						m_pSequenceMgr->UnselectAllNotes();
						pSeqItem->m_fSelected = TRUE;
						m_pActiveNote = pSeqItem;
						m_pSelectPivotSeq = pSeqItem;
						m_SelectionMode = SEQ_SINGLE_SELECT;
						InvalidateStrip();
						m_pSequenceMgr->RefreshPropertyPage();
					}
				}
				else if( pSeqItem == NULL )
				{
					m_pSequenceMgr->UnselectAllNotes();
				}
			}

			m_pSequenceMgr->OnShowProperties();

			hr = OnRButtonUp( );
		}
		break;

	case WM_SETCURSOR:
		hr = OnSetCursor( lXPos, lYPos);
		break;

	case WM_MOUSEMOVE:
		hr = OnMouseMove( lXPos, lYPos );
		break;

	case WM_KEYDOWN:
		hr = OnKeyDown( wParam );
		break;

	case WM_CHAR:
		hr = OnChar( wParam );
		break;

	case WM_VSCROLL:
		hr = OnVScroll( );
		break;

	case WM_SIZE:
		if( wParam == SIZE_MAXIMIZED )
		{
			OnChangeStripView( SV_NORMAL );
		}
		else if( wParam == SIZE_MINIMIZED )
		{
			OnChangeStripView( SV_MINIMIZED );
		}
	
		{
			// Get the new length of the segment
			VARIANT varLength;
			if( SUCCEEDED( m_pSequenceMgr->m_pTimeline->GetTimelineProperty( TP_CLOCKLENGTH, &varLength ) ) )
			{
				if( varLength.vt == VT_I4 )
				{
					m_mtLength = V_I4( &varLength );
				}
			}
		}

		UpdateSequenceUIChunk();
	case WM_MOVE:
		hr = OnSize();
		break;

	case WM_DESTROY:
		hr = OnDestroy();
		break;

	case WM_CREATE:
		hr = OnCreate();
		break;

	case WM_MOUSEWHEEL:
		if (m_svView == SV_NORMAL)
		{
			long lNewVertScroll = m_lVScroll;
			// scroll the piano roll up and down
			short zDelta = HIWORD(wParam);
			if (zDelta>0)
			{
				lNewVertScroll -= 6 * ( m_lMaxNoteHeight);
			}
			else if (zDelta<0)
			{
				lNewVertScroll += 6 * ( m_lMaxNoteHeight);
			}

			if ( lNewVertScroll / m_lMaxNoteHeight > 127)
			{
				lNewVertScroll = m_lMaxNoteHeight * 127;
			}
			else if ( lNewVertScroll < 0)
			{
				lNewVertScroll = 0;
			}

			if ( lNewVertScroll != m_lVScroll )
			{
				SetVScroll( lNewVertScroll );
			}
		}
		break;

	case WM_COMMAND:
		// We should only get this message in response to a selection in the right-click context menu.
		//WORD wNotifyCode;
		WORD wID;

		//wNotifyCode	= HIWORD( wParam );	// notification code 
		wID			= LOWORD( wParam );	// item, control, or accelerator identifier 
		switch( wID )
		{
		case ID_VIEW_PROPERTIES:
			hr = ShowPropertySheet(m_pSequenceMgr->m_pTimeline);
			if (m_fShowSequenceProps)
			{
				// Change to the sequence property page
				m_pSequenceMgr->OnShowProperties();
			}
			else
			{
				// Change to our property page
				OnShowProperties();
			}
			break;
		case ID_EDIT_CUT:
			hr = Cut();
			break;
		case ID_EDIT_COPY:
			hr = Copy();
			break;
		case ID_EDIT_DELETE:
			hr = Delete();
			break;
		case ID_EDIT_PASTE_MERGE:
			m_pSequenceMgr->m_pTimeline->SetPasteType( TL_PASTE_MERGE );
			hr = Paste();
			break;
		case ID_EDIT_PASTE_OVERWRITE:
			m_pSequenceMgr->m_pTimeline->SetPasteType( TL_PASTE_OVERWRITE );
			hr = Paste();
			break;
		case ID_EDIT_PASTE:
			hr = Paste();
			break;
		case ID_EDIT_INSERT:
			hr = Insert();
			break;
		case ID_EDIT_SELECT_ALL:
			hr = SelectAll();
			break;
		case ID_EDIT_QUANTIZE:
			hr = DoQuantize();
			break;
		case ID_EDIT_VELOCITY:
			hr = DoVelocity();
			break;
		case ID_EDIT_DELETE_TRACK:
		case ID_EDIT_ADD_TRACK:
			{
				HWND hwnd = GetTimelineHWnd();
				if( hwnd )
				{
					hwnd = ::GetParent( hwnd );
					if( hwnd )
					{
						::SendMessage( hwnd, WM_COMMAND, wParam, lParam );
					}
				}
			}
			break;

		case ID_EDIT_ADD_PART:
			hr = m_pSequenceMgr->AddNewPart();
			break;

		case ID_EDIT_DELETE_PART:
			{
				HWND hwnd = GetTimelineHWnd();
				if( hwnd )
				{
					hwnd = ::GetParent( hwnd );
					if( hwnd )
					{
						::SendMessage( hwnd, WM_COMMAND, MAKEWPARAM( ID_EDIT_DELETE_TRACK, HIWORD( wParam ) ), lParam );
					}
				}
			}
			break;

		case ID_EDIT_VIEW_PIANOROLL:
			// This handles notifying the other strips, and adding an Undo state
			ChangeNotationType( FALSE );
			break;

		case ID_EDIT_VIEW_HYBRID:
			// This handles notifying the other strips, and adding an Undo state
			ChangeNotationType( TRUE );
			break;

		case ID_SNAP_NONE:
		case ID_SNAP_GRID:
		case ID_SNAP_BEAT:
		case ID_SNAP_BAR:
		{
			DMUSPROD_TIMELINE_SNAP_TO tlSnapTo = DMUSPROD_TIMELINE_SNAP_NONE;
			switch( wID )
			{
			case ID_SNAP_NONE:
				tlSnapTo = DMUSPROD_TIMELINE_SNAP_NONE;
				break;
			case ID_SNAP_GRID:
				tlSnapTo = DMUSPROD_TIMELINE_SNAP_GRID;
				break;
			case ID_SNAP_BEAT:
				tlSnapTo = DMUSPROD_TIMELINE_SNAP_BEAT;
				break;
			case ID_SNAP_BAR:
				tlSnapTo = DMUSPROD_TIMELINE_SNAP_BAR;
				break;
			}
			VARIANT var;
			var.vt = VT_I4;
			V_I4( &var ) = tlSnapTo;
			m_pSequenceMgr->m_pTimeline->SetTimelineProperty( TP_SNAP_TO, var );
			break;
		}

		case ID_EDIT_ZOOMIN:
		case ID_EDIT_ZOOMOUT:
			// The following code is very similar to OnChar()
			//if( m_svView == SV_NORMAL )
			{
				if( wID == ID_EDIT_ZOOMIN )
				{
					ChangeZoom(	m_dblVerticalZoom + 0.01);
					// TODO: Add Undo?
					/*
					// Let the object know about the changes
					m_nLastEdit = nLastEdit;
					m_pSequenceMgr->m_fUpdateDirectMusic = FALSE;
					m_pSequenceMgr->OnDataChanged(); 
					*/
				}
				else if( wID == ID_EDIT_ZOOMOUT )
				{
					ChangeZoom(	m_dblVerticalZoom - 0.01);
					// TODO: Add Undo?
					/*
					// Let the object know about the changes
					m_nLastEdit = nLastEdit;
					m_pSequenceMgr->m_fUpdateDirectMusic = FALSE;
					m_pSequenceMgr->OnDataChanged(); 
					*/
				}
			}
			break;

		case ID_INSERT_NEWINSTRUMENT:
			{
				// Need to insert a new band track
				IDMUSProdSegmentEdit *pIDMUSProdSegmentEdit;
				if( SUCCEEDED( m_pSequenceMgr->m_pDMProdSegmentNode->QueryInterface( IID_IDMUSProdSegmentEdit, (void **)&pIDMUSProdSegmentEdit ) ) )
				{
					// Assume the strip creation succeeds
					// BUGBUG: We will add an extra undo stip of AddStrip fails.  Oh well.
					m_nLastEdit = IDS_UNDO_ADD_BANDTRACK;
					m_pSequenceMgr->m_pTimeline->OnDataChanged( (ISequenceMgr*)m_pSequenceMgr );

					IUnknown *punkStripMgr;
					if( SUCCEEDED( pIDMUSProdSegmentEdit->AddStrip( CLSID_DirectMusicBandTrack, m_pSequenceMgr->m_dwGroupBits, &punkStripMgr ) ) )
					{
						IUnknown *pStripMgr;
						if( SUCCEEDED( punkStripMgr->QueryInterface( IID_IUnknown, (void **)&pStripMgr) ) )
						{
							// Now, find the band strip for this band track
							IDMUSProdStrip *pIDMUSProdStrip;
							DWORD dwEnum = 0;
							VARIANT varStripMgr;
							while( SUCCEEDED( m_pSequenceMgr->m_pTimeline->EnumStrip( dwEnum, &pIDMUSProdStrip ) ) )
							{
								V_UNKNOWN(&varStripMgr) = NULL;
								if( SUCCEEDED( pIDMUSProdStrip->GetStripProperty( SP_STRIPMGR, &varStripMgr ) )
								&&	V_UNKNOWN(&varStripMgr) )
								{
									if( V_UNKNOWN(&varStripMgr) == pStripMgr )
									{
										// Check if TP_FREEZE_UNDO is NOT set.
										BOOL fFreezeUndo = FALSE;
										VARIANT var;
										if( SUCCEEDED( m_pSequenceMgr->m_pTimeline->GetTimelineProperty( TP_FREEZE_UNDO, &var ) ) )
										{
											fFreezeUndo = V_BOOL(&var);
										}

										if( !fFreezeUndo )
										{
											// Need to set TP_FREEZE_UNDO or the segment will add an undo state for us
											var.vt = VT_BOOL;
											V_BOOL(&var) = TRUE;
											m_pSequenceMgr->m_pTimeline->SetTimelineProperty( TP_FREEZE_UNDO, var );
										}

										// Found the band strip - now insert a new band
										pIDMUSProdStrip->OnWMMessage( WM_COMMAND, ID_INSERT_NEWINSTRUMENT, 0, 0, 0 );

										if( !fFreezeUndo )
										{
											// Need to reset TP_FREEZE_UNDO or the segment will add an undo state for us
											var.vt = VT_BOOL;
											V_BOOL(&var) = FALSE;
											m_pSequenceMgr->m_pTimeline->SetTimelineProperty( TP_FREEZE_UNDO, var );
										}

										// Flag to exit the loop (after doing the Release() calls below
										dwEnum = LONG_MAX;
									}
									V_UNKNOWN(&varStripMgr)->Release();
								}
								pIDMUSProdStrip->Release();

								dwEnum++;
							}
							pStripMgr->Release();
						}

						punkStripMgr->Release();
					}
					pIDMUSProdSegmentEdit->Release();
				}
			}
			break;

		default:
			break;
		}
		break;

	default:
		break;
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CSequenceStrip::OnCreate

HRESULT CSequenceStrip::OnCreate(void)
{
	UpdateName();
	m_iHaveFocus = 0;

	// Get Left and right selection boundaries
	m_bGutterSelected = FALSE;
	m_pSequenceMgr->m_pTimeline->GetMarkerTime( MARKER_BEGINSELECT, TIMETYPE_CLOCKS, &m_lBeginSelect );
	m_pSequenceMgr->m_pTimeline->GetMarkerTime( MARKER_ENDSELECT, TIMETYPE_CLOCKS, &m_lEndSelect );

	VARIANT var;
	m_pSequenceMgr->m_pTimeline->StripGetTimelineProperty( (IDMUSProdStrip*)this, STP_STRIPVIEW, &var );
	m_svView = (STRIPVIEW) V_I4(&var);

	// Find the position to scroll to
	long lValue = -1;
	if( m_lVScroll == -1 )
	{
		// since this is a new strip, let's auto-scroll so the data is showing
		CSequenceItem *pSeqItem;
		POSITION pos = m_pSequenceMgr->m_lstSequences.GetHeadPosition();
		while( pos )
		{
			pSeqItem = m_pSequenceMgr->m_lstSequences.GetNext( pos );
			if( pSeqItem->m_bByte1 > lValue )
			{
				lValue = pSeqItem->m_bByte1;
			}
		}

		// If the value is valid, 
		if( ( lValue >= 0 ) && ( lValue < 128 ) )
		{
			VARIANT var;
			var.vt = VT_I4;
			m_lVScroll = ( 127 - lValue ) * m_lMaxNoteHeight;
			V_I4(&var) = m_lVScroll;
			m_pSequenceMgr->m_pTimeline->StripSetTimelineProperty( (IDMUSProdStrip*)this, STP_VERTICAL_SCROLL, var );
		}
		else
		{
			VARIANT var;
			var.vt = VT_I4;
			// Default scroll position is C4
			m_lVScroll = ( 127 - DEFAULT_VERTICAL_SCROLL ) * m_lMaxNoteHeight;
			V_I4(&var) = m_lVScroll;
			m_pSequenceMgr->m_pTimeline->StripSetTimelineProperty( (IDMUSProdStrip*)this, STP_VERTICAL_SCROLL, var );
		}
	}
	else
	{
		m_pSequenceMgr->m_pTimeline->StripGetTimelineProperty( (IDMUSProdStrip*)this, STP_VERTICAL_SCROLL, &var );
		m_lVScroll = V_I4(&var);
	}

	// Load button bitmaps
	if( InterlockedIncrement( &m_lBitmapRefCount ) == 1 )
	{
		// Load button bitmaps
		BITMAP bmParam;
		if( m_BitmapZoomInUp.GetSafeHandle() == NULL )
		{
			m_BitmapZoomInUp.LoadBitmap( IDB_ZOOMIN_UP );
			m_BitmapZoomInUp.GetBitmap( &bmParam );
			m_BitmapZoomInUp.SetBitmapDimension( bmParam.bmWidth, bmParam.bmHeight );
		}
		if( m_BitmapZoomInDown.GetSafeHandle() == NULL )
		{
			m_BitmapZoomInDown.LoadBitmap( IDB_ZOOMIN_DOWN );
			m_BitmapZoomInDown.GetBitmap( &bmParam );
			m_BitmapZoomInDown.SetBitmapDimension( bmParam.bmWidth, bmParam.bmHeight );
		}
		if( m_BitmapZoomOutUp.GetSafeHandle() == NULL )
		{
			m_BitmapZoomOutUp.LoadBitmap( IDB_ZOOMOUT_UP );
			m_BitmapZoomOutUp.GetBitmap( &bmParam );
			m_BitmapZoomOutUp.SetBitmapDimension( bmParam.bmWidth, bmParam.bmHeight );
		}
		if( m_BitmapZoomOutDown.GetSafeHandle() == NULL )
		{
			m_BitmapZoomOutDown.LoadBitmap( IDB_ZOOMOUT_DOWN );
			m_BitmapZoomOutDown.GetBitmap( &bmParam );
			m_BitmapZoomOutDown.SetBitmapDimension( bmParam.bmWidth, bmParam.bmHeight );
		}
		if( m_BitmapNewBand.GetSafeHandle() == NULL )
		{
			m_BitmapNewBand.LoadBitmap( IDB_NEWBAND );
			m_BitmapNewBand.GetBitmap( &bmParam );
			m_BitmapNewBand.SetBitmapDimension( bmParam.bmWidth, bmParam.bmHeight );
		}
	}

	// setup the vertical scrollbar
	if (m_VScrollBar.GetSafeHwnd() == NULL)
	{
		IOleWindow* pIOleWindow;
		m_pSequenceMgr->m_pTimeline->QueryInterface(IID_IOleWindow, (void**)&pIOleWindow);
		
		if (pIOleWindow)
		{
			HWND hWnd;
			if (pIOleWindow->GetWindow(&hWnd) == S_OK)
			{
				CWnd wnd;
				wnd.Attach(hWnd);

				m_rectVScroll = CRect(0, 0, 40, 100);
				m_VScrollBar.Create(SBS_RIGHTALIGN | SBS_VERT | WS_CHILD | WS_CLIPSIBLINGS,
					m_rectVScroll, &wnd, IDC_VSCROLL);
				m_VScrollBar.SetSequenceStrip(this);

				SCROLLINFO si;
				si.cbSize = sizeof( SCROLLINFO );
				si.fMask = SIF_POS | SIF_RANGE;
				si.nMin = 0;
				si.nMax = 127;
				if ( ( lValue >= 0 ) && ( lValue < 128 ) )
				{
					si.nPos = 127 - lValue;
				}
				else
				{
					si.nPos = 127 - DEFAULT_VERTICAL_SCROLL;
				}
				m_VScrollBar.SetScrollInfo( &si, TRUE );
				wnd.Detach();
			}
			pIOleWindow->Release();
			UpdateVScroll();
		}
	}

	VARIANT varLength;
	if( SUCCEEDED( m_pSequenceMgr->m_pTimeline->GetTimelineProperty( TP_CLOCKLENGTH, &varLength ) ) )
	{
		if( varLength.vt == VT_I4 )
		{
			m_mtLength = V_I4( &varLength );
		}
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CSequenceStrip IDMUSProdStripFunctionBar

/////////////////////////////////////////////////////////////////////////////
// CSequenceStrip::FBDraw

HRESULT CSequenceStrip::FBDraw( HDC hDC, STRIPVIEW sv )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( !m_pSequenceMgr->m_pTimeline )
	{
		return E_UNEXPECTED;
	}

	DrawFunctionBar( hDC, sv );

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CSequenceStrip::FBOnWMMessage

HRESULT CSequenceStrip::FBOnWMMessage( UINT nMsg, WPARAM wParam, LPARAM lParam, LONG lXPos, LONG lYPos )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	UNREFERENCED_PARAMETER(wParam);
	UNREFERENCED_PARAMETER(lParam);

	// Process the window message
	HRESULT hr = S_OK;
	switch( nMsg )
	{
	case WM_LBUTTONDBLCLK:
	case WM_LBUTTONDOWN:
		{
			BOOL fShowProps = TRUE;
			if( lYPos <= m_lVScroll + m_BitmapZoomInDown.GetBitmapDimension().cy + m_BitmapZoomOutDown.GetBitmapDimension().cy )
			{
				VARIANT varXS;
				if( SUCCEEDED( m_pSequenceMgr->m_pTimeline->GetTimelineProperty( TP_HORIZONTAL_SCROLL, &varXS ) ) )
				{
					if( lXPos >= V_I4( &varXS ) - m_BitmapZoomInDown.GetBitmapDimension().cx - 2 )
					{
						fShowProps = FALSE;

						// capture mouse so we get the LBUTTONUP message as well
						// the timeline will release the capture when it receives the
						// LBUTTONUP message
						VARIANT var;
						var.vt = VT_BOOL;
						V_BOOL(&var) = TRUE;
						m_pSequenceMgr->m_pTimeline->SetTimelineProperty( TP_STRIPMOUSECAPTURE, var );

						//CString strUndoText;

						if( lYPos <= m_lVScroll + m_BitmapZoomInDown.GetBitmapDimension().cy )
						{
							m_fZoomInPressed = TRUE;
							ChangeZoom(	m_dblVerticalZoom + 0.01);
							// TODO: Undo Zoom?
						}
						else
						{
							m_fZoomOutPressed = TRUE;
							ChangeZoom(	m_dblVerticalZoom - 0.01);
							// TODO: Undo Zoom?
						}
					}
				}
			}

			VARIANT varFNHeight;
			if( fShowProps
			&&	SUCCEEDED( m_pSequenceMgr->m_pTimeline->GetTimelineProperty( TP_FUNCTIONNAME_HEIGHT, &varFNHeight ) ) )
			{
				if( lYPos > m_lVScroll + V_I4(&varFNHeight)
				&&	lYPos < m_lVScroll + V_I4(&varFNHeight) + INSTRUMENT_BUTTON_HEIGHT )
				{
					VARIANT varXS;
					if( SUCCEEDED( m_pSequenceMgr->m_pTimeline->GetTimelineProperty( TP_HORIZONTAL_SCROLL, &varXS ) ) )
					{
						if( lXPos < V_I4( &varXS ) - m_rectVScroll.Width() - NEWBAND_BUTTON_WIDTH - 1 )
						{
							if( m_fInstrumentEnabled )
							{
								m_fInstrumentPressed = TRUE;
							}
						}
						else
						{
							m_fNewBandPressed = TRUE;
						}

						InvalidateFunctionBar();
						fShowProps = FALSE;
					}
				}
			}

			if( fShowProps )
			{
				m_fShowSequenceProps = FALSE;
				OnShowProperties();
				if( m_svView == SV_NORMAL )
				{
					// Play note with the value clicked on
					CSequenceItem seqItem;
					seqItem.m_mtDuration = 768;
					seqItem.m_bByte2 = 100;
					seqItem.m_bByte1 = BYTE(PositionToMIDIValue( lYPos ));
					m_pSequenceMgr->m_pTimeline->GetMarkerTime( MARKER_CURRENTTIME, TIMETYPE_CLOCKS, &seqItem.m_mtTime );
					m_pSequenceMgr->PlayNote( &seqItem );

					// Move the insert cursor to the note the user clicked on
					if( seqItem.m_bByte1 != m_lInsertVal )
					{
						m_lInsertVal = seqItem.m_bByte1;
						InvalidatePianoRoll();
					}

					VARIANT var;
					var.vt = VT_BOOL;
					V_BOOL(&var) = TRUE;
					m_pSequenceMgr->m_pTimeline->SetTimelineProperty( TP_STRIPMOUSECAPTURE, var );
				}
			}
		}
		break;

	case WM_LBUTTONUP:
		{
			VARIANT varFNHeight;
			if( SUCCEEDED( m_pSequenceMgr->m_pTimeline->GetTimelineProperty( TP_FUNCTIONNAME_HEIGHT, &varFNHeight ) ) )
			{
				if( lYPos > m_lVScroll + V_I4(&varFNHeight)
				&&	lYPos < m_lVScroll + V_I4(&varFNHeight) + INSTRUMENT_BUTTON_HEIGHT )
				{
					VARIANT varXS;
					if( SUCCEEDED( m_pSequenceMgr->m_pTimeline->GetTimelineProperty( TP_HORIZONTAL_SCROLL, &varXS ) ) )
					{
						POINT point;
						GetCursorPos( &point );
						LPARAM lParam = MAKELPARAM(point.x, point.y);
						if( lXPos < V_I4( &varXS ) - m_rectVScroll.Width() - NEWBAND_BUTTON_WIDTH - 1 )
						{
							if( m_fInstrumentPressed )
							{
								::PostMessage( m_VScrollBar.m_hWnd, WM_APP, WM_APP_INSTRUMENTMENU, lParam );
							}
						}
						else
						{
							if( m_fNewBandPressed )
							{
								::PostMessage( m_VScrollBar.m_hWnd, WM_APP, WM_APP_BANDMENU, lParam );
							}
						}
					}
				}
			}
		}
		// Zoom buttons and StopNote handled on OnLButtonUp
		hr = OnLButtonUp( lXPos, lYPos );
		m_MouseMode = SEQ_MM_NORMAL;
		break;

	case WM_RBUTTONUP:
		m_fShowSequenceProps = FALSE;
		OnShowProperties();
		m_lXPos = -1;

		// Display a right-click context menu.
		OnRButtonUp();
		break;

	case WM_SETCURSOR:
		m_hCursor = GetArrowCursor();
		break;

	case WM_MOUSEMOVE:
		if (m_svView != SV_MINIMIZED)
		{
			hr = OnMouseMove( lXPos, lYPos );
		}
		break;

	default:
		break;
	}
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CSequenceStrip IDMUSProdTimelineEdit

/////////////////////////////////////////////////////////////////////////////
// CSequenceStrip::Cut

HRESULT CSequenceStrip::Cut( IDMUSProdTimelineDataObject* pITimelineDataObject )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	HRESULT hr;

	hr = CanCut();
	ASSERT( hr == S_OK );
	if( hr != S_OK )
	{
		return E_UNEXPECTED;
	}

	// Cut is simply a Copy followed by a Delete.
	hr = Copy(pITimelineDataObject);
	if( SUCCEEDED( hr ))
	{
		hr = Delete();
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CSequenceStrip::Copy

HRESULT CSequenceStrip::Copy( IDMUSProdTimelineDataObject* pITimelineDataObject )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	HRESULT				hr;
	IStream*			pStreamCopy;
	IStream*			pStreamMidiCopy;

#ifdef _DEBUG
	//TraceFormatsInClipboard();
#endif

	hr = CanCopy();
	ASSERT( hr == S_OK );
	if( hr != S_OK )
	{
		return E_UNEXPECTED;
	}

	ASSERT( m_pSequenceMgr != NULL );
	if( m_pSequenceMgr == NULL )
	{
		return E_UNEXPECTED;
	}

	// If the format hasn't been registered yet, fail
	// The formats are registered in OnAddedToTimeline
	if( m_cfSequenceList == 0 || m_cfMidiFile == 0)
	{
		ASSERT(FALSE);
		return E_FAIL;
	}

	// Create an IStream to save the selected notes as a Seuqnce chunk in.
	hr = CreateStreamOnHGlobal( NULL, TRUE, &pStreamCopy );
	if( FAILED( hr ))
	{
		return E_OUTOFMEMORY;
	}

	// Create an IStream to save the selected notes as a MIDI file in
	hr = CreateStreamOnHGlobal( NULL, TRUE, &pStreamMidiCopy);
	if( FAILED( hr ))
	{
		pStreamCopy->Release();
		return E_OUTOFMEMORY;
	}

	if( m_bGutterSelected && (m_lBeginSelect >= 0) && (m_lEndSelect > 0))
	{
		// Save the notes into the stream.
		hr = m_pSequenceMgr->SaveSelectedEvents( pStreamCopy, m_lBeginSelect );
		if( FAILED( hr ))
		{
			pStreamCopy->Release();
			pStreamMidiCopy->Release();
			return E_UNEXPECTED;
		}

		// Save into Midi Stream
		hr = m_pSequenceMgr->SaveSelectedEventsAsMidi( pStreamMidiCopy );
		if( FAILED( hr ))
		{
			pStreamCopy->Release();
			pStreamMidiCopy->Release();
			return E_UNEXPECTED;
		}
		else if( hr == S_FALSE )
		{
			// No data saved - don't add pStreamMidiCopy
			pStreamMidiCopy->Release();
			pStreamMidiCopy = NULL;
		}
	}
	else
	{
		// Save the notes into the stream.
		CSequenceItem* pSequenceAtDragPoint = m_pSequenceMgr->FirstSelectedSequence();
		if( pSequenceAtDragPoint == NULL )
		{
			pStreamCopy->Release();
			pStreamMidiCopy->Release();
			return E_UNEXPECTED;
		}

		hr = m_pSequenceMgr->SaveSelectedSequences( pStreamCopy, pSequenceAtDragPoint->AbsTime() );
		if( FAILED( hr ))
		{
			pStreamCopy->Release();
			pStreamMidiCopy->Release();
			return E_UNEXPECTED;
		}

		// Save into Midi Stream
		hr = m_pSequenceMgr->SaveSelectedSequencesAsMidi( pStreamMidiCopy, pSequenceAtDragPoint->AbsTime() );
		if( FAILED( hr ))
		{
			pStreamCopy->Release();
			pStreamMidiCopy->Release();
			return E_UNEXPECTED;
		}
		else if( hr == S_FALSE )
		{
			// No data saved - don't add pStreamMidiCopy
			pStreamMidiCopy->Release();
			pStreamMidiCopy = NULL;
		}
	}

	if(pITimelineDataObject != NULL)
	{
		// add the stream to the passed ITimelineDataObject
		hr = pITimelineDataObject->AddInternalClipFormat( m_cfSequenceList, pStreamCopy );
		if( pStreamMidiCopy && (hr == S_OK) )
		{
			hr = pITimelineDataObject->AddExternalClipFormat( m_cfMidiFile, pStreamMidiCopy );
		}
		pStreamCopy->Release();
		if( pStreamMidiCopy )
		{
			pStreamMidiCopy->Release();
			//pStreamMidiCopy = NULL; // Not necessary - not used below this point
		}
		ASSERT( hr == S_OK );
		if ( hr != S_OK )
		{
			return E_FAIL;
		}
	}
	// Otherwise, add it to the clipboard
	else
	{
		// create timeline object
		hr = m_pSequenceMgr->m_pTimeline->AllocTimelineDataObject(&pITimelineDataObject);
		ASSERT(hr == S_OK);
		if( hr != S_OK)
		{
			return E_FAIL;
		}

		// Set the start and end time of this copy
		long lStartTime, lEndTime;
		m_pSequenceMgr->GetBoundariesOfSelectedEvents(lStartTime, lEndTime);
		hr = pITimelineDataObject->SetBoundaries(lStartTime, lEndTime);

		// add the stream to the DataObject
		hr = pITimelineDataObject->AddInternalClipFormat( m_cfSequenceList, pStreamCopy );
		pStreamCopy->Release();
		ASSERT( hr == S_OK );
		if ( hr != S_OK )
		{
			pITimelineDataObject->Release();
			return E_FAIL;
		}
		if( pStreamMidiCopy )
		{
			hr = pITimelineDataObject->AddExternalClipFormat( m_cfMidiFile, pStreamMidiCopy );
			pStreamMidiCopy->Release();
			//pStreamMidiCopy = NULL; // Not necessary - not used below this point
		}
		ASSERT( hr == S_OK );
		if ( hr != S_OK )
		{
			pITimelineDataObject->Release();
			return E_FAIL;
		}

		// get the new IDataObject to place on the clipboard
		IDataObject* pIDataObject;
		hr = pITimelineDataObject->Export(&pIDataObject);

		// Release the ITimelineDataObject
		pITimelineDataObject->Release();

		// Exit if the Export failed
		if(FAILED(hr))
		{
			return E_UNEXPECTED;
		}

		// Send the IDataObject to the clipboard
		hr = OleSetClipboard( pIDataObject );

		// Make sure the clipboard has a copy of the data
		OleFlushClipboard();

		// Release our reference to the data object
		pIDataObject->Release();

		if( hr != S_OK )
		{
			ASSERT(FALSE);
			return E_FAIL;
		}
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CSequenceStrip::PasteAt

HRESULT CSequenceStrip::PasteAt( IDMUSProdTimelineDataObject* pITimelineDataObject, long lClocks, BOOL fDropNotEditPaste, BOOL fPasteMIDIToMultipleStrips)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	UNREFERENCED_PARAMETER(fDropNotEditPaste);

	if( (m_pSequenceMgr->m_pTimeline == NULL)
	||	(pITimelineDataObject == NULL) )
	{
		return E_INVALIDARG;
	}

	IDMUSProdRIFFStream* pIRiffStream = NULL;
	HRESULT hr = E_FAIL;

	if(lClocks < 0)
		lClocks = 0;	// no negative time

	if( S_OK ==	pITimelineDataObject->IsClipFormatAvailable( m_cfSequenceList) )
	{
		IStream* pIStream;
		if(SUCCEEDED (pITimelineDataObject->AttemptRead( m_cfSequenceList, &pIStream)))
		{
			// 20171: Suck up the first copy of the data in MIDI format, if it's available.
			if( S_OK ==	pITimelineDataObject->IsClipFormatAvailable( m_cfMidiFile) )
			{
				IStream* pIStreamMIDI;
				if(SUCCEEDED (pITimelineDataObject->AttemptRead( m_cfMidiFile, &pIStreamMIDI)))
				{
					pIStreamMIDI->Release();
					pIStreamMIDI = NULL;
				}
			}

			// Check for RIFF format
			if( FAILED( hr = AllocRIFFStream( pIStream, &pIRiffStream ) ) )
			{
				goto Leave;
			}

			ASSERT(hr == S_OK);

			MMCKINFO ck;
			ck.ckid = DMUS_FOURCC_SEQ_TRACK;
			if ( pIRiffStream->Descend( &ck, NULL, MMIO_FINDCHUNK ) == 0 )
			{
				// Calculate the offset
				long lTimeOffset = m_pSequenceMgr->CalculatePasteTime( lClocks );

				// Load the Track
				MMCKINFO ck1;
				BOOL fUnselectedNotes = FALSE, fUnselectedCurves = FALSE;
				while( pIRiffStream->Descend( &ck1, NULL, 0 ) == 0 )
				{
					switch( ck1.ckid )
					{
					case DMUS_FOURCC_SEQ_LIST:
						// If necessary, unselect all existing notes
						if( !fUnselectedNotes )
						{
							fUnselectedNotes = TRUE;
							m_pSequenceMgr->UnselectAllNotes( );
						}

						hr = m_pSequenceMgr->ImportSequenceChunkData( pIStream, ck1.cksize, lTimeOffset );
						if( FAILED(hr) )
						{
							goto Leave;
						}
						break;
					case DMUS_FOURCC_CURVE_LIST:
						// If necessary, unselect all existing curves
						if( !fUnselectedCurves )
						{
							fUnselectedCurves = TRUE;
							m_pSequenceMgr->UnselectAllCurves( );
						}

						hr = m_pSequenceMgr->ImportCurveChunkData( pIStream, ck1.cksize, lTimeOffset );
						if( FAILED(hr) )
						{
							goto Leave;
						}
						break;
					}
					pIRiffStream->Ascend(&ck1, 0);
				}

				pIRiffStream->Ascend( &ck, 0 );
				if( SUCCEEDED(hr) )
				{
					SyncCurveStripStateList();
					AddCurveStrips();
					m_nLastEdit = IDS_UNDO_PASTE;
					m_pSequenceMgr->OnDataChanged();
					InvalidateStrip();
					InvalidateCurveStrips();
				}
			}
		}
	}
	else if( S_OK == pITimelineDataObject->IsClipFormatAvailable(m_cfMidiFile))
	{
		hr = PasteMidiFile(pITimelineDataObject, lClocks, fPasteMIDIToMultipleStrips);
		if( SUCCEEDED( hr ) )
		{
			SyncCurveStripStateList();
			AddCurveStrips();
			m_nLastEdit = IDS_UNDO_PASTE_MIDI;
			m_pSequenceMgr->OnDataChanged();
			InvalidateStrip();
			InvalidateCurveStrips();
		}
	}

	UpdateSelectionState();
Leave:
	if ( pIRiffStream )
	{
		pIRiffStream->Release();
	}
	
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CSequenceStrip::Paste

HRESULT CSequenceStrip::Paste( IDMUSProdTimelineDataObject* pITimelineDataObject )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	HRESULT				hr;
	
	hr = CanPaste( pITimelineDataObject );
	ASSERT( hr == S_OK );
	if( hr != S_OK )
	{
		return E_UNEXPECTED;
	}

	ASSERT( m_pSequenceMgr != NULL );
	if( m_pSequenceMgr == NULL || m_pSequenceMgr->m_pTimeline == NULL )
	{
		return E_UNEXPECTED;
	}

	// Make sure everything on the timeline is deselected.
	// JHD 8/5/98: I don't know why everybody does this..
	/*
	m_fSelecting = TRUE;
	m_pSequenceMgr->m_pTimeline->SetMarkerTime( MARKER_BEGINSELECT, TIMETYPE_CLOCKS, 0 );
	m_pSequenceMgr->m_pTimeline->SetMarkerTime( MARKER_ENDSELECT, TIMETYPE_CLOCKS, 0 );
	m_fSelecting = FALSE;
	*/
	
	// If the format hasn't been registered yet, fail
	// The formats are registered in OnAddedToTimeline
	if( m_cfSequenceList == 0 || m_cfMidiFile == 0)
	{
		ASSERT(FALSE);
		return E_FAIL;
	}

	// If true, split a MIDI file out into the gutter selected strips
	BOOL fPasteMIDIToMultipleStrips = FALSE;
	
	// Get the time to paste at
	MUSIC_TIME mtTime;

	if(pITimelineDataObject == NULL)
	{
		// Get the IDataObject from the clipboard
		IDataObject *pIDataObject;
		hr = OleGetClipboard(&pIDataObject);
		if(FAILED(hr) || (pIDataObject == NULL))
		{
			return E_FAIL;
		}

		// Create a new TimelineDataObject
		hr = m_pSequenceMgr->m_pTimeline->AllocTimelineDataObject( &pITimelineDataObject );
		if( FAILED(hr) || (pITimelineDataObject == NULL) )
		{
			pIDataObject->Release();
			return E_FAIL;
		}

		// Insert the IDataObject into the TimelineDataObject
		hr = pITimelineDataObject->Import( pIDataObject );
		pIDataObject->Release();
		if( FAILED(hr) )
		{
			pITimelineDataObject->Release();
			return E_FAIL;
		}

		// If this is a single-strip paste, use our m_lInsertTime position, since it should already have
		// been set using the snap-to value
		mtTime = m_lInsertTime;
	}
	else
	{
		fPasteMIDIToMultipleStrips = TRUE;

		// If this is a multiple-strip paste, then use the Time Cursor, since it should already have
		// been set using the snap-to value
		if (FAILED(m_pSequenceMgr->m_pTimeline->GetMarkerTime( MARKER_CURRENTTIME, TIMETYPE_CLOCKS, &mtTime )))
		{
			return E_FAIL;
		}

		pITimelineDataObject->AddRef();
	}

	// Get the paste type
	TIMELINE_PASTE_TYPE tlPasteType;
	if( FAILED( m_pSequenceMgr->m_pTimeline->GetPasteType( &tlPasteType ) ) )
	{
		pITimelineDataObject->Release();
		return E_FAIL;
	}

	// Quantize it to the nearest grid
	mtTime = FloorTimeToGrid( mtTime, NULL );

	if( tlPasteType == TL_PASTE_OVERWRITE )
	{
		long lStart, lEnd;
		if( SUCCEEDED( pITimelineDataObject->GetBoundaries( &lStart, &lEnd ) ) )
		{
			m_pSequenceMgr->DeleteBetweenTimes( mtTime, mtTime + lEnd - lStart );
		}
	}

	hr = PasteAt(pITimelineDataObject, mtTime, false, fPasteMIDIToMultipleStrips);
	if(SUCCEEDED(hr))
	{
		InvalidateStrip();
		m_pSequenceMgr->RefreshPropertyPage();
		m_pSequenceMgr->OnShowProperties();
	}
	pITimelineDataObject->Release();

	return hr;
}

CSequenceItem *CSequenceStrip::CreateNoteToInsert( void ) const
{
	long lValue = m_lInsertVal;

	if (lValue < 0)
	{
		lValue = 0;
	}

	if (lValue > 127)
	{
		lValue = 127;
	}

	CSequenceItem *pSeqItem = new CSequenceItem;
	if( pSeqItem )
	{
		pSeqItem->m_bByte1 = BYTE(lValue);
		pSeqItem->m_bByte2 = 100;
		pSeqItem->m_bStatus = MIDI_NOTEON;
		if( m_lInsertTime < 0 )
		{
			// Set the time of the note to 0
			pSeqItem->m_mtTime = 0;

			// Find out the TimeSig of the first measure
			DMUS_TIMESIGNATURE dmTimeSig;
			GetTimeSig( 0, &dmTimeSig, m_pSequenceMgr->m_pTimeline, m_pSequenceMgr->m_dwGroupBits );

			// Compute the smallest possible offset before time 0
			const long lNegativeMeasureLength = max( SHRT_MIN, -dmTimeSig.bBeatsPerMeasure * ((DMUS_PPQ * 4) / dmTimeSig.bBeat) );

			// Set the note's offset
			pSeqItem->m_nOffset = short( max( m_lInsertTime, lNegativeMeasureLength) );
		}
		else
		{
			pSeqItem->m_mtTime = FloorTimeToGrid( m_lInsertTime, NULL );
			ASSERT( abs(m_lInsertTime - pSeqItem->m_mtTime) <= (SHRT_MAX + 1));
			pSeqItem->m_nOffset = short(m_lInsertTime - pSeqItem->m_mtTime);
		}
		/// Minimum note duration is 1/2 grid
		pSeqItem->m_mtDuration = max( GetSnapAmount(pSeqItem->AbsTime()) - 1, GetGridClocks(pSeqItem->AbsTime()) / 2 );
		pSeqItem->m_fSelected = TRUE;
	}
	return pSeqItem;
}


/////////////////////////////////////////////////////////////////////////////
// CSequenceStrip::Insert

HRESULT CSequenceStrip::Insert( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Make sure everything on the timeline is deselected first.
	UnselectGutterRange();

	// Unselect all notes, so only the new note is selected
	m_pSequenceMgr->UnselectAllNotes( );

	CSequenceItem *pSeqItem = CreateNoteToInsert();
	if( pSeqItem == NULL )
	{
		return E_FAIL;
	}

	if( !m_pActiveNote )
	{
		m_pActiveNote = pSeqItem;
	}

	m_pSequenceMgr->InsertNote( pSeqItem, TRUE );
	m_pSequenceMgr->RefreshPropertyPage();
	m_pSequenceMgr->OnShowProperties();

	UpdateSelectionState();

	// Bump Time cursor to the right
	SNAPTO snapTo = GetSnapToBoundary( m_lInsertTime );
	if( snapTo == SNAP_NONE )
	{
		snapTo = SNAP_GRID;
	}
	BumpTimeCursor( snapTo );

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CSequenceStrip::Delete

HRESULT CSequenceStrip::Delete( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	/* This may be part of a Cut operation. (You can cut empty space, but you can't delete it)
	if( CanDelete() != S_OK )
	{
		ASSERT( FALSE );
		return E_UNEXPECTED;
	}
	*/

	ASSERT( m_pSequenceMgr != NULL );
	if( m_pSequenceMgr == NULL )
	{
		return E_UNEXPECTED;
	}

	ASSERT( m_pSequenceMgr->m_pTimeline != NULL );
	if( m_pSequenceMgr->m_pTimeline == NULL )
	{
		return E_FAIL;
	}

	m_pSequenceMgr->DeleteSelectedSequences();

	m_SelectionMode = SEQ_NO_SELECT;
	m_pActiveNote = NULL;

	InvalidateStrip();

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CSequenceStrip::SelectAll

HRESULT CSequenceStrip::SelectAll( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	ASSERT( m_pSequenceMgr != NULL );
	if( m_pSequenceMgr == NULL )
	{
		return E_UNEXPECTED;
	}

	ASSERT( m_pSequenceMgr->m_pTimeline != NULL );
	if( m_pSequenceMgr->m_pTimeline == NULL )
	{
		return E_FAIL;
	}

	// This takes care of updating the property page and redrawing the strip, if necessary
	m_pSequenceMgr->SelectAllNotes();

	UpdateSelectionState();

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CSequenceStrip::CanCut

HRESULT CSequenceStrip::CanCut( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	ASSERT( m_pSequenceMgr != NULL );
	if( m_pSequenceMgr == NULL )
	{
		return E_UNEXPECTED;
	}

	// If our gutter is selected, and the user selected a range of time in the time strip,
	// we can cut even if nothing is selected.
	VARIANT variant;
	long lTimeStart, lTimeEnd;
	if( SUCCEEDED( m_pSequenceMgr->m_pTimeline->StripGetTimelineProperty( this, STP_GUTTER_SELECTED, &variant ) )
	&&	(V_BOOL( &variant ) == TRUE)
	&&	SUCCEEDED( m_pSequenceMgr->m_pTimeline->GetMarkerTime( MARKER_BEGINSELECT, TIMETYPE_CLOCKS, &lTimeStart ) )
	&&	(lTimeStart >= 0)
	&&	SUCCEEDED( m_pSequenceMgr->m_pTimeline->GetMarkerTime( MARKER_ENDSELECT, TIMETYPE_CLOCKS, &lTimeEnd ) )
	&&	(lTimeEnd > lTimeStart) )
	{
		return S_OK;
	}

	if( CanCopy() == S_OK && CanDelete() == S_OK )
	{
		return S_OK;
	}
	else
	{
		return S_FALSE;
	}

}


/////////////////////////////////////////////////////////////////////////////
// CSequenceStrip::CanCopy

HRESULT CSequenceStrip::CanCopy( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	ASSERT( m_pSequenceMgr != NULL );
	if( m_pSequenceMgr == NULL )
	{
		return E_UNEXPECTED;
	}

	// If our gutter is selected, and the user selected a range of time in the time strip,
	// we can copy even if nothing is selected.
	VARIANT variant;
	long lTimeStart, lTimeEnd;
	if( SUCCEEDED( m_pSequenceMgr->m_pTimeline->StripGetTimelineProperty( this, STP_GUTTER_SELECTED, &variant ) )
	&&	(V_BOOL( &variant ) == TRUE)
	&&	SUCCEEDED( m_pSequenceMgr->m_pTimeline->GetMarkerTime( MARKER_BEGINSELECT, TIMETYPE_CLOCKS, &lTimeStart ) )
	&&	(lTimeStart >= 0)
	&&	SUCCEEDED( m_pSequenceMgr->m_pTimeline->GetMarkerTime( MARKER_ENDSELECT, TIMETYPE_CLOCKS, &lTimeEnd ) )
	&&	(lTimeEnd > lTimeStart) )
	{
		return S_OK;
	}

	return m_pSequenceMgr->IsSelected() ? S_OK : S_FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CSequenceStrip::CanPaste

HRESULT CSequenceStrip::CanPaste( IDMUSProdTimelineDataObject* pITimelineDataObject )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	HRESULT				hr;

	ASSERT( m_pSequenceMgr != NULL );
	if( m_pSequenceMgr == NULL )
	{
		return E_UNEXPECTED;
	}

	// If the format hasn't been registered yet, fail
	// The formats are registered in OnAddedToTimeline
	if( m_cfSequenceList == 0 || m_cfMidiFile == 0)
	{
		ASSERT(FALSE);
		return E_FAIL;
	}

	// If pITimelineDataObject != NULL, check it.
	if( pITimelineDataObject != NULL )
	{
		hr = pITimelineDataObject->IsClipFormatAvailable( m_cfSequenceList );
		if(hr != S_OK)
		{
			hr = pITimelineDataObject->IsClipFormatAvailable( m_cfMidiFile );
		}
	}
	// Otherwise, check the clipboard
	else
	{
		// Get the IDataObject from the clipboard
		IDataObject *pIDataObject;

		hr = E_FAIL;
		if( SUCCEEDED( OleGetClipboard(&pIDataObject) ) )
		{
			// Create a new TimelineDataObject
			IDMUSProdTimelineDataObject *pITimelineDataObject;
			if( SUCCEEDED( m_pSequenceMgr->m_pTimeline->AllocTimelineDataObject( &pITimelineDataObject ) ) )
			{
				// Insert the IDataObject into the TimelineDataObject
				if( SUCCEEDED( pITimelineDataObject->Import( pIDataObject ) ) )
				{
					hr = pITimelineDataObject->IsClipFormatAvailable(m_cfSequenceList);
				}
				if(hr != S_OK)
				{
					hr = pITimelineDataObject->IsClipFormatAvailable(m_cfMidiFile);
				}
				pITimelineDataObject->Release();
			}
			pIDataObject->Release();
		}
	}

	if (hr == S_OK)
	{
		return S_OK;
	}

	return S_FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CSequenceStrip::CanInsert

HRESULT CSequenceStrip::CanInsert( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if (m_svView == SV_MINIMIZED)
	{
		return S_FALSE;
	}
	if ( m_lInsertVal >= 0 )
	{
		return S_OK;
	}
	else
	{
		return S_FALSE;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CSequenceStrip::CanDelete

HRESULT CSequenceStrip::CanDelete( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	ASSERT( m_pSequenceMgr != NULL );
	if( m_pSequenceMgr == NULL )
	{
		return E_UNEXPECTED;
	}

	return m_pSequenceMgr->IsSelected() ? S_OK : S_FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CSequenceStrip::CanSelectAll

HRESULT CSequenceStrip::CanSelectAll( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	if( m_pSequenceMgr->m_lstSequences.IsEmpty() )
	{
		return S_FALSE;
	}
	else
	{
		return S_OK;
	}
}


// IDropTarget Methods

/////////////////////////////////////////////////////////////////////////////
// CSequenceStrip::DragEnter

HRESULT CSequenceStrip::DragEnter( IDataObject* pIDataObject, DWORD grfKeyState, POINTL pt, DWORD* pdwEffect )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	ASSERT( pIDataObject != NULL );
	ASSERT( m_pITargetDataObject == NULL );

	// Store IDataObject associated with current drag-drop operation
	m_pITargetDataObject = pIDataObject;
	m_pITargetDataObject->AddRef();

	// Determine effect of drop
	return DragOver( grfKeyState, pt, pdwEffect );
}


/////////////////////////////////////////////////////////////////////////////
// CSequenceStrip::DragOver

HRESULT CSequenceStrip::DragOver( DWORD grfKeyState, POINTL pt, DWORD* pdwEffect)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	UNREFERENCED_PARAMETER(pt);
	UNREFERENCED_PARAMETER(grfKeyState);

	if(m_pITargetDataObject == NULL)
		ASSERT( m_pITargetDataObject != NULL );

	// Determine effect of drop
	DWORD dwEffect = DROPEFFECT_NONE;

	if( CanPasteFromData( m_pITargetDataObject ) == S_OK )
	{
		if( grfKeyState & MK_RBUTTON )
		{
			dwEffect = *pdwEffect;
		}
		else
		{
			if( grfKeyState & MK_CONTROL )
			{
				dwEffect = DROPEFFECT_COPY;
			}
			else
			{
				if( *pdwEffect & DROPEFFECT_COPY
				&&  *pdwEffect & DROPEFFECT_MOVE )
				{
					dwEffect = DROPEFFECT_MOVE;
				}
				else
				{
					dwEffect = *pdwEffect;
				}
			}
		}
	}

	// Set temp drag over fields
	if( grfKeyState & (MK_RBUTTON | MK_LBUTTON) )
	{
		m_dwOverDragButton = grfKeyState & (MK_RBUTTON | MK_LBUTTON);
		m_dwOverDragEffect = dwEffect;
	}

	*pdwEffect = dwEffect;
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CSequenceStrip::DragLeave

HRESULT CSequenceStrip::DragLeave( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Release IDataObject
	if( m_pITargetDataObject )
	{
		m_pITargetDataObject->Release();
		m_pITargetDataObject = NULL;
	}

	//Reset temp drag over fields
	m_dwOverDragButton = 0;
	m_dwOverDragEffect = 0;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CSequenceStrip::Drop

HRESULT CSequenceStrip::Drop( IDataObject* pIDataObject, DWORD grfKeyState, POINTL pt, DWORD* pdwEffect)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	UNREFERENCED_PARAMETER(grfKeyState);

	ASSERT( m_pITargetDataObject != NULL );
	ASSERT( m_pITargetDataObject == pIDataObject );

	// Set default values
	HRESULT hr = S_OK;
	*pdwEffect = DROPEFFECT_NONE;

	// Choose effect when right mouse drag - Move, Copy, or Cancel?
	if( m_dwOverDragButton & MK_RBUTTON )
	{
		HMENU hMenu;
		HMENU hMenuPopup;
		
		// Display arrow cursor
		::LoadCursor( AfxGetInstanceHandle(), IDC_ARROW );
	
		// Prepare context menu
		hMenu = ::LoadMenu( AfxGetInstanceHandle(), MAKEINTRESOURCE(IDM_DRAG_RMENU) );
		if( hMenu )
		{
			m_dwDragRMenuEffect = DROPEFFECT_NONE;

			// Track right context menu for drag-drop via TrackPopupMenu
			hMenuPopup = ::GetSubMenu( hMenu, 0 );

			// Init state of menu items
			if( !(m_dwOverDragEffect & DROPEFFECT_MOVE) )
			{
				::EnableMenuItem( hMenuPopup, IDM_DRAG_MOVE, (MF_GRAYED | MF_BYCOMMAND) );
			}

			// Get a window to attach menu to
			HWND hwnd = GetTimelineHWnd();
			if( hwnd )
			{
				// Display and track menu
				::TrackPopupMenu( hMenuPopup, (TPM_LEFTALIGN | TPM_RIGHTBUTTON),
							  pt.x, pt.y, 0, hwnd, NULL );
				DestroyMenu( hMenu );

				// Need to process WM_COMMAND from TrackPopupMenu
				MSG msg;
				while( ::PeekMessage( &msg, hwnd, NULL, NULL, PM_REMOVE) )
				{
					TranslateMessage( &msg );
					DispatchMessage( &msg );
				}

				// WM_COMMAND from TrackPopupMenu will have set m_dwDragRMenuEffect
				m_dwOverDragEffect = m_dwDragRMenuEffect;
				m_dwDragRMenuEffect = DROPEFFECT_NONE;
			}
		}
	}

	// Paste data
	if( m_dwOverDragEffect != DROPEFFECT_NONE )
	{
		IDMUSProdTimelineDataObject *pITimelineDataObject;
		if( SUCCEEDED( m_pSequenceMgr->m_pTimeline->AllocTimelineDataObject( &pITimelineDataObject ) ) )
		{
			if( SUCCEEDED( pITimelineDataObject->Import( pIDataObject ) ) )
			{
				if( SUCCEEDED( m_pSequenceMgr->m_pTimeline->PositionToClocks( pt.x, &pt.x ) ) )
				{
					hr = PasteAt( pITimelineDataObject, pt.x, true, FALSE );
					if( SUCCEEDED ( hr ) )
					{
						*pdwEffect = m_dwOverDragEffect;
					}
				}
			}
			pITimelineDataObject->Release();
		}
	}

	// Cleanup
	DragLeave();

	return hr;
}


// IDropTarget helpers

/////////////////////////////////////////////////////////////////////////////
// CSequenceStrip::GetTimelineHWnd

HWND CSequenceStrip::GetTimelineHWnd()
{
	// Get the DC of our Strip
	if( m_pSequenceMgr->m_pTimeline )
	{
		IOleWindow *pIOleWindow;
		if( SUCCEEDED( m_pSequenceMgr->m_pTimeline->QueryInterface( IID_IOleWindow, (void**)&pIOleWindow ) ) )
		{
			HWND hwnd = NULL;
			pIOleWindow->GetWindow( &hwnd );
			pIOleWindow->Release();
			return hwnd;
		}
	}
	return NULL;;
}


/////////////////////////////////////////////////////////////////////////////
// CSequenceStrip::CanPasteFromData

HRESULT CSequenceStrip::CanPasteFromData(IDataObject* pIDataObject)
{
	if( pIDataObject == NULL )
	{
		return E_INVALIDARG;
	}

	// Create a new CDllJazzDataObject and see if it can read the data object's format.
	CDllJazzDataObject* pDataObject = new CDllJazzDataObject();
	if( pDataObject == NULL )
	{
		return E_OUTOFMEMORY;
	}

	HRESULT hr = S_FALSE;
	
	if( SUCCEEDED (	pDataObject->IsClipFormatAvailable( pIDataObject, m_cfSequenceList ) ))
	{
		hr = S_OK;
	}

	pDataObject->Release();
	return hr;
}


// IDMUSProdPropPageObject Methods

/////////////////////////////////////////////////////////////////////////////
// CSequenceStrip::GetData

HRESULT CSequenceStrip::GetData( void **ppData )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	if( (ppData == NULL) || (ppData == NULL) )
	{
		return E_INVALIDARG;
	}

	DWORD *pdwIndex = static_cast<DWORD *>(*ppData);
	switch( *pdwIndex )
	{
	case 0:
	{
		ioGroupBitsPPG *pioGroupBitsPPG = static_cast<ioGroupBitsPPG *>(*ppData);
		pioGroupBitsPPG->dwGroupBits = m_pSequenceMgr->m_dwGroupBits;;
		break;
	}
	case 1:
	{
		PPGTrackFlagsParams *pPPGTrackFlagsParams = static_cast<PPGTrackFlagsParams *>(*ppData);
		pPPGTrackFlagsParams->dwTrackExtrasFlags = m_pSequenceMgr->m_dwTrackExtrasFlags;
		pPPGTrackFlagsParams->dwTrackExtrasMask = TRACKCONFIG_VALID_MASK;
		pPPGTrackFlagsParams->dwProducerOnlyFlags = m_pSequenceMgr->m_dwProducerOnlyFlags;
		pPPGTrackFlagsParams->dwProducerOnlyMask = SEG_PRODUCERONLY_AUDITIONONLY;
		break;
	}
	case 2:
	{
		ioSeqTrackPPG *pioSeqTrackPPG = static_cast<ioSeqTrackPPG *>(*ppData);

		pioSeqTrackPPG->dwPChannel = m_pSequenceMgr->m_dwPChannel;
		pioSeqTrackPPG->crSelectedNoteColor = m_crSelectedNoteColor;
		pioSeqTrackPPG->crUnselectedNoteColor = m_crUnselectedNoteColor;
		pioSeqTrackPPG->crOverlappingNoteColor = m_crOverlappingNoteColor;
		pioSeqTrackPPG->crAccidentalColor = m_crAccidentalColor;
		pioSeqTrackPPG->strName = m_pSequenceMgr->m_strName;
		pioSeqTrackPPG->dwExtraBars = m_dwExtraBars;
		pioSeqTrackPPG->fPickupBar = m_fPickupBar;

		// Get PChannel name
		WCHAR wstrName[MAX_PATH];
		if( m_pSequenceMgr->m_pIPChannelName &&
			SUCCEEDED( m_pSequenceMgr->m_pIPChannelName->GetPChannelName( m_pSequenceMgr->m_dwPChannel, wstrName) ) )
		{
			pioSeqTrackPPG->strPChannelName = wstrName;
		}
		break;
	}
	default:
		ASSERT(FALSE);
		break;
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CSequenceStrip::SetData

HRESULT CSequenceStrip::SetData( void *pData )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	if( pData == NULL )
	{
		return E_INVALIDARG;
	}

	DWORD *pdwIndex = reinterpret_cast<DWORD *>(pData);
	
	BOOL fNeedToRefresh = FALSE;
	BOOL fNeedToReposition = TRUE;

	switch( *pdwIndex )
	{
	case 0:
	{
		ioGroupBitsPPG *pioGroupBitsPPG = static_cast<ioGroupBitsPPG *>(pData);

		if( pioGroupBitsPPG->dwGroupBits != m_pSequenceMgr->m_dwGroupBits )
		{
			m_nLastEdit = IDS_UNDO_TRACK_GROUP;
			m_pSequenceMgr->m_dwGroupBits = pioGroupBitsPPG->dwGroupBits;
			m_pSequenceMgr->UpdateFlatsAndKey();
			UpdateName();
			m_pSequenceMgr->m_pTimeline->OnDataChanged( (ISequenceMgr*)m_pSequenceMgr );
			m_pSequenceMgr->m_dwOldGroupBits = pioGroupBitsPPG->dwGroupBits;
			// Need to reposition to make Curve strips show up in the correct place
			// Handled by the removing and re-adding of this strip by the segment designer.
			//fNeedToReposition = FALSE;
		}
		break;
	}
	case 1:
	{
		PPGTrackFlagsParams *pPPGTrackFlagsParams = static_cast<PPGTrackFlagsParams *>(pData);

		if( pPPGTrackFlagsParams->dwTrackExtrasFlags != m_pSequenceMgr->m_dwTrackExtrasFlags )
		{
			m_nLastEdit = IDS_UNDO_TRACKEXTRAS;
			m_pSequenceMgr->m_dwTrackExtrasFlags = pPPGTrackFlagsParams->dwTrackExtrasFlags;
			m_pSequenceMgr->m_pTimeline->OnDataChanged( (ISequenceMgr*)m_pSequenceMgr );
		}
		else if( pPPGTrackFlagsParams->dwProducerOnlyFlags != m_pSequenceMgr->m_dwProducerOnlyFlags )
		{
			m_nLastEdit = IDS_UNDO_PRODUCERONLY;
			m_pSequenceMgr->m_dwProducerOnlyFlags = pPPGTrackFlagsParams->dwProducerOnlyFlags;
			m_pSequenceMgr->m_pTimeline->OnDataChanged( (ISequenceMgr*)m_pSequenceMgr );
		}
		break;
	}
	case 2:
	{
		ioSeqTrackPPG *pioSeqTrackPPG = static_cast<ioSeqTrackPPG *>(pData);

		if( pioSeqTrackPPG->dwPChannel != m_pSequenceMgr->m_dwPChannel )
		{
			m_nLastEdit = IDS_UNDO_PCHANNEL_CHANGE;
			m_pSequenceMgr->m_dwPChannel = pioSeqTrackPPG->dwPChannel;
			UpdateName();
			fNeedToRefresh = TRUE;
		}
		else if( pioSeqTrackPPG->crSelectedNoteColor != m_crSelectedNoteColor ||
				 pioSeqTrackPPG->crUnselectedNoteColor != m_crUnselectedNoteColor ||
				 pioSeqTrackPPG->crOverlappingNoteColor != m_crOverlappingNoteColor ||
				 pioSeqTrackPPG->crAccidentalColor != m_crAccidentalColor )
		{
			m_crSelectedNoteColor = pioSeqTrackPPG->crSelectedNoteColor;
			m_crUnselectedNoteColor = pioSeqTrackPPG->crUnselectedNoteColor;
			m_crOverlappingNoteColor = pioSeqTrackPPG->crOverlappingNoteColor;
			m_crAccidentalColor = pioSeqTrackPPG->crAccidentalColor;

			m_nLastEdit = IDS_UNDO_CHANGE_COLOR;
			InvalidateCurveStrips();
			InvalidateStrip();
			fNeedToReposition = FALSE;

			// This must be done before NotifyStripMgrs is called
			m_pSequenceMgr->OnDataChanged();
			m_pSequenceMgr->m_pTimeline->NotifyStripMgrs( GUID_Sequence_Color_Change, 0xFFFFFFFF, pioSeqTrackPPG );
		}
		else if( pioSeqTrackPPG->strName != m_pSequenceMgr->m_strName )
		{
			m_nLastEdit = IDS_UNDO_NAME_CHANGE;
			m_pSequenceMgr->m_strName = pioSeqTrackPPG->strName;
			UpdateName();
			fNeedToRefresh = TRUE;
		}
		else if( (pioSeqTrackPPG->dwExtraBars != m_dwExtraBars)
			 ||  (pioSeqTrackPPG->fPickupBar != m_fPickupBar) )
		{
			const BOOL fOrigPickup = m_fPickupBar;
			m_fPickupBar = pioSeqTrackPPG->fPickupBar;
			m_fPickupBar = ShouldDisplayPickupBar();
			const DWORD dwOrigExtra = m_dwExtraBars;
			m_dwExtraBars = pioSeqTrackPPG->dwExtraBars;
			m_dwExtraBars = GetNumExtraBars();

			if( fOrigPickup != m_fPickupBar )
			{
				m_nLastEdit = IDS_UNDO_PICKUP_CHANGE;
				fNeedToRefresh = TRUE;
			}
			if ( dwOrigExtra != m_dwExtraBars )
			{
				m_nLastEdit = IDS_UNDO_EXTRABARS_CHANGE;
				fNeedToRefresh = TRUE;
			}

			if( (pioSeqTrackPPG->dwExtraBars != m_dwExtraBars)
			||	(pioSeqTrackPPG->fPickupBar != m_fPickupBar) )
			{
				m_pPropPageMgr->RefreshData();
			}
		}
		else if( m_pSequenceMgr->m_pIPChannelName )
		{
			// PChannel name
			WCHAR wstrName[MAX_PATH];
			if( m_pSequenceMgr->m_pIPChannelName &&
				SUCCEEDED( m_pSequenceMgr->m_pIPChannelName->GetPChannelName( m_pSequenceMgr->m_dwPChannel, wstrName) ) )
			{
				CString strPChName = wstrName;
				if( strPChName.Compare( pioSeqTrackPPG->strPChannelName ) != 0 )
				{
					MultiByteToWideChar( CP_ACP, 0, pioSeqTrackPPG->strPChannelName, -1, wstrName, MAX_PATH );

					m_pSequenceMgr->m_pIPChannelName->SetPChannelName( m_pSequenceMgr->m_dwPChannel, wstrName );

					UpdateName();
					InvalidateStrip();

					// Let the object know about the changes
					// This doesn't affect anything in the segment - just the PChannel names
					// in the Producer project file.
				}
			}
		}

		break;
	}
	default:
		ASSERT(FALSE);
		break;
	}
	if( fNeedToReposition )
	{
		// Remove and re-add ourselves to make our position in the Timeline correct
		ASSERT( m_cRef > 1 );
		m_pSequenceMgr->m_pTimeline->RemoveStrip( (IDMUSProdStrip *)this );
		m_pSequenceMgr->m_pTimeline->InsertStripAtDefaultPos( (IDMUSProdStrip *)this, CLSID_DirectMusicSeqTrack, m_pSequenceMgr->m_dwGroupBits, PChannelToStripIndex( m_pSequenceMgr->m_dwPChannel ) );

		// Initialize our UI data
		ApplyUIChunk( &m_pSequenceMgr->m_SeqStripDesign );

		// Add Curve Strips to the Timeline
		AddCurveStrips();

		VARIANT var;
		var.vt = VT_UNKNOWN;
		if( SUCCEEDED( QueryInterface( IID_IUnknown, (void **) &(V_UNKNOWN(&var)) ) ) )
		{
			m_pSequenceMgr->m_pTimeline->SetTimelineProperty( TP_ACTIVESTRIP, var );
		}
	}

	if( fNeedToRefresh )
	{
		m_pSequenceMgr->OnDataChanged();
		InvalidateStrip();
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CSequenceStrip::OnShowProperties

HRESULT CSequenceStrip::OnShowProperties( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Get a pointer to the Timeline
	if( m_pSequenceMgr->m_pTimeline == NULL )
	{
		ASSERT(FALSE);
		return E_FAIL;
	}

	// Get a pointer to the Framework from the timeline
	IDMUSProdFramework* pIFramework = NULL;
	VARIANT var;
	m_pSequenceMgr->m_pTimeline->GetTimelineProperty( TP_DMUSPRODFRAMEWORK, &var );
	pIFramework = (IDMUSProdFramework*) V_UNKNOWN(&var);
	if (pIFramework == NULL)
	{
		ASSERT(FALSE);
		return E_FAIL;
	}


	// Get a pointer to the property sheet
	IDMUSProdPropSheet* pIPropSheet = NULL;
	pIFramework->QueryInterface( IID_IDMUSProdPropSheet, (void **)&pIPropSheet);
	pIFramework->Release();
	if( pIPropSheet == NULL )
	{
		ASSERT(FALSE);
		return E_FAIL;
	}

	//  If the property sheet is hidden, exit
	if( pIPropSheet->IsShowing() != S_OK )
	{
		pIPropSheet->Release();
		return S_OK;
	}

	// release our reference to the property sheet
	pIPropSheet->Release();

	// If our property page is already displayed, exit
	if(m_fPropPageActive)
	{
		ASSERT( m_pPropPageMgr != NULL );
		return S_OK;
	}

	// Get a reference to our property page manager
	HRESULT hr = S_OK;
	if( m_pPropPageMgr == NULL )
	{
		CGroupBitsPropPageMgr* pPPM = new CGroupBitsPropPageMgr;
		if( NULL == pPPM ) return E_OUTOFMEMORY;
		hr = pPPM->QueryInterface( IID_IDMUSProdPropPageManager, (void**)&m_pPropPageMgr );
		m_pPropPageMgr->Release(); // this releases the 2nd ref, leaving only one
		if( FAILED(hr) )
		{
			goto EXIT;
		}
	}

	// Set the property page to refer to the groupbits or sequence track property page.
	short nActiveTab;
	nActiveTab = CGroupBitsPropPageMgr::sm_nActiveTab;
	m_pSequenceMgr->m_pTimeline->SetPropertyPage(m_pPropPageMgr, (IDMUSProdPropPageObject*)this);
	m_fPropPageActive = TRUE;
	pIPropSheet->SetActivePage( nActiveTab ); 

EXIT:
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CSequenceStrip::OnRemoveFromPageManager

HRESULT CSequenceStrip::OnRemoveFromPageManager( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	if( m_pPropPageMgr )
	{
		m_pPropPageMgr->SetObject(NULL);
	}
	m_fPropPageActive = FALSE;
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CSequenceStrip::ShowPropertySheet

HRESULT CSequenceStrip::ShowPropertySheet(IDMUSProdTimeline* pTimeline)
{
	HRESULT hr = S_OK;

	// Get a pointer to the property sheet and show it
	VARIANT			var;
	LPUNKNOWN		punk;
	IDMUSProdPropSheet*	pIPropSheet;
	pTimeline->GetTimelineProperty( TP_DMUSPRODFRAMEWORK, &var );
	if( var.vt == VT_UNKNOWN )
	{
		punk = V_UNKNOWN( &var );
		if( punk )
		{
			hr = punk->QueryInterface( IID_IDMUSProdPropSheet, (void**)&pIPropSheet );
			ASSERT( SUCCEEDED( hr ));
			if( FAILED( hr ))
			{
				hr = E_UNEXPECTED;
			}
			else
			{
				pIPropSheet->Show( TRUE );
				pIPropSheet->Release();
			}
			punk->Release();
		}
	}
//	m_pSequenceMgr->OnShowProperties();
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CSequenceStrip::OnLButtonDown

HRESULT CSequenceStrip::OnLButtonDown( WPARAM wParam, LONG lXPos, LONG lYPos)
{
	// If we're already dragging, just return
	/* TODO: Need another check
	if( m_pDragImage )
	{
		return S_OK;
	}
	*/

	UpdateNoteCursorTime();

	// Validate reference to the timeline
	if( !m_pSequenceMgr->m_pTimeline )
	{
		return E_FAIL;
	}

	// Unselect all other strips
	UnselectGutterRange();

	if (m_svView == SV_MINIMIZED)
	{
		return S_OK;
	}

	HRESULT hr = S_OK;

	BOOL fNeedToRefresh = FALSE;

	// See if there is a sequence under the cursor.
	CSequenceItem* pSequence = GetSeqItemAndRectFromPoint( lXPos, lYPos, NULL);
	if( pSequence != NULL )
	{
		// Update the insert cursor position
		/*
		if( m_lInsertVal != pSequence->m_bByte1 )
		{
			m_lInsertVal = pSequence->m_bByte1;
			InvalidatePianoRoll();
		}
		*/

		if (wParam & MK_CONTROL)
		{
			m_pActiveNote = pSequence;
			if( pSequence->m_fSelected )
			{
				m_fCtrlKeyDown = 1;
			}
			else
			{
				m_fCtrlKeyDown = 2;
				// Select
				m_pSelectPivotSeq = pSequence;
				pSequence->m_fSelected = TRUE;
				UpdateSelectionState();
				fNeedToRefresh = TRUE;
			}
		}
		else if (wParam & MK_SHIFT)
		{
			m_pActiveNote = pSequence;
			RECT rect1, rect2;

			if ( m_pSelectPivotSeq == NULL )
			{
				m_pSelectPivotSeq = pSequence;
			}

			GetNoteRect( m_pSelectPivotSeq, &rect1 );
			GetNoteRect( pSequence, &rect2 );

			// The '+1' is because CRect::PtInRect makes the left and top side 'inside' the rect, but the
			// right and bottom sides are 'outside' the rect.  By adding one to the right and bottom, the
			// real edge is now 'inside' the rect.
			CRect rect( min(rect1.left, rect2.left), min(rect1.top, rect2.top), max(rect1.left, rect2.left) + 1, max(rect1.bottom, rect2.bottom) + 1);
			
			if( SelectInRect( &rect ) )
			{
				// If something changed, invalidate the strip
				fNeedToRefresh = TRUE;
			}
		}
		else if (pSequence->m_fSelected == FALSE)
		{
			m_pSequenceMgr->UnselectAllNotes( );
			pSequence->m_fSelected = TRUE;
			m_pActiveNote = pSequence;
			m_pSelectPivotSeq = pSequence;
			m_SelectionMode = SEQ_SINGLE_SELECT;
			fNeedToRefresh = TRUE;
		}
		else
		{
			// The note's already selected, why re-select it? -jd
			//pSequence->m_fSelected = TRUE;
			m_pSelectPivotSeq = pSequence;
			m_pActiveNote = pSequence;
		}

		// Update the status bar
		m_pSequenceMgr->UpdateStatusBarDisplay();

		// Play the note
		m_pSequenceMgr->PlayNote( pSequence );
	}
	else
	{
		long lNewPosition = PositionToMIDIValue( lYPos );
		if( m_lInsertVal != lNewPosition )
		{
			m_lInsertVal = lNewPosition;
			InvalidatePianoRoll();
		}

		if (wParam & MK_CONTROL)
		{
			// Insert note;

			// Make sure everything on the timeline is deselected first.
			UnselectGutterRange();

			// Unselect all notes, so only the new note is selected
			m_pSequenceMgr->UnselectAllNotes( );

			pSequence = CreateNoteToInsert();
			if( pSequence != NULL )
			{
				if( !m_pActiveNote )
				{
					m_pActiveNote = pSequence;
				}

				m_pSequenceMgr->InsertNote( pSequence, FALSE );
				m_pSequenceMgr->RefreshPropertyPage();
				m_pSequenceMgr->OnShowProperties();

				UpdateSelectionState();

				// Bump Time cursor to the right
				SNAPTO snapTo = GetSnapToBoundary( m_lInsertTime );
				if( snapTo == SNAP_NONE )
				{
					snapTo = SNAP_GRID;
				}
				BumpTimeCursor( snapTo );

				hr = S_OK;
				m_fInsertingNoteFromMouseClick = true;
				m_MouseMode = SEQ_MM_RESIZE_END;
			}
			else
			{
				hr = E_FAIL;
			}
		}
	}

	m_pointClicked.x = lXPos;
	m_pointClicked.y = lYPos;

	switch(m_MouseMode)
	{
	case SEQ_MM_NORMAL:
		if (!(wParam & MK_CONTROL))
		{
			m_pActiveNote = NULL;
			m_pSequenceMgr->UnselectAllNotes( );
			m_SelectionMode = SEQ_NO_SELECT;

			// Create bounding box
			IOleWindow* pIOleWindow;
			m_pSequenceMgr->m_pTimeline->QueryInterface( IID_IOleWindow, (void**)&pIOleWindow );
			if( pIOleWindow )
			{
				CWnd wnd;
				HWND hWnd;

				if( pIOleWindow->GetWindow( &hWnd ) == S_OK )
				{
					CPoint point( lXPos, lYPos );

					if( SUCCEEDED ( m_pSequenceMgr->m_pTimeline->StripToWindowPos( this, &point ) ) )
					{
						wnd.Attach( hWnd );
						CNoteTracker noteTracker( &wnd, m_pSequenceMgr->m_pTimeline, this, NTRK_SELECTING );
						noteTracker.TrackRubberBand( &wnd, point, TRUE );
						wnd.Detach();

						// Set m_SelectionMode based on the number of selected notes
						UpdateSelectionState();
					}
				}

				pIOleWindow->Release();
			}
		}

		// leave m_pShiftDMNote at whatever it last was
		//m_pShiftDMNote = NULL;
		
		// update our display and the property page
		InvalidateStrip();
		m_pSequenceMgr->OnShowProperties();
		break;
	case SEQ_MM_MOVE:
		if (pSequence)
		{
			m_OriginalSeqItem = *pSequence;
			m_lLastDeltaMove = 0;
			m_cLastDeltaValue = 0;
			VARIANT var;
			var.vt = VT_BOOL;
			V_BOOL(&var) = TRUE;
			m_pSequenceMgr->m_pTimeline->SetTimelineProperty( TP_STRIPMOUSECAPTURE, var );
			m_MouseMode = SEQ_MM_ACTIVEMOVE;
		}
		break;
	case SEQ_MM_RESIZE_START:
		if (pSequence)
		{
			m_OriginalSeqItem = *pSequence;
			m_lLastDeltaStart = 0;
			VARIANT var;
			var.vt = VT_BOOL;
			V_BOOL(&var) = TRUE;
			m_pSequenceMgr->m_pTimeline->SetTimelineProperty( TP_STRIPMOUSECAPTURE, var );
			m_MouseMode = SEQ_MM_ACTIVERESIZE_START;
		}
		break;
	case SEQ_MM_RESIZE_END:
		if (pSequence)
		{
			m_OriginalSeqItem = *pSequence;
			m_lLastDeltaDur = 0;
			VARIANT var;
			var.vt = VT_BOOL;
			V_BOOL(&var) = TRUE;
			m_pSequenceMgr->m_pTimeline->SetTimelineProperty( TP_STRIPMOUSECAPTURE, var );
			m_MouseMode = SEQ_MM_ACTIVERESIZE_END;
		}
		break;
	case SEQ_MM_RESIZE_VELOCITY:
		if (pSequence)
		{
			m_OriginalSeqItem = *pSequence;
			m_lLastDeltaVel = 0;
			VARIANT var;
			var.vt = VT_BOOL;
			V_BOOL(&var) = TRUE;
			m_pSequenceMgr->m_pTimeline->SetTimelineProperty( TP_STRIPMOUSECAPTURE, var );
			m_MouseMode = SEQ_MM_ACTIVERESIZE_VELOCITY;
		}
		break;
	case SEQ_MM_ACTIVERESIZE_VELOCITY:
	case SEQ_MM_ACTIVERESIZE_END:
	case SEQ_MM_ACTIVERESIZE_START:
	case SEQ_MM_ACTIVEMOVE:
		// This shouldn't happen...
		ASSERT(FALSE);
		break;
	default:
		break;
	}

	m_fShowSequenceProps = TRUE;

	if( fNeedToRefresh )
	{
		InvalidateStrip();
		m_pSequenceMgr->RefreshPropertyPage();
	}

	m_pSequenceMgr->OnShowProperties();

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CSequenceStrip::OnLButtonUp

HRESULT CSequenceStrip::OnLButtonUp( long lXPos, long lYPos)
{
	if (m_svView == SV_MINIMIZED)
	{
		return S_OK;
	}

	// Stop any playing note
	m_pSequenceMgr->StopNote();

	KillTimer();

	if( m_fZoomInPressed || m_fZoomOutPressed || m_fNewBandPressed || m_fInstrumentPressed )
	{
		m_fZoomInPressed = FALSE;
		m_fZoomOutPressed = FALSE;
		m_fNewBandPressed = FALSE;
		m_fInstrumentPressed = FALSE;

		// Redraw the fuction bar
		InvalidateFunctionBar();
		return S_OK;
	}

	if( m_fInsertingNoteFromMouseClick )
	{
		// Let the object know about the changes
		m_nLastEdit = IDS_UNDO_INSERT;
		m_pSequenceMgr->OnDataChanged();
	}

	VARIANT var;
	if( m_fCtrlKeyDown == 1)
	{
		// Unselect
		if( m_pActiveNote )
		{
			m_pActiveNote->m_fSelected = FALSE;
			InvalidateStrip();
		}

		UpdateSelectionState();
		m_pSequenceMgr->RefreshPropertyPage();
	}
	m_fCtrlKeyDown = 0;

	switch(m_MouseMode)
	{
	case SEQ_MM_NORMAL:
		break;
	case SEQ_MM_MOVE:
	case SEQ_MM_RESIZE_START:
	case SEQ_MM_RESIZE_END:
	case SEQ_MM_RESIZE_VELOCITY:
		break;

	case SEQ_MM_ACTIVERESIZE_VELOCITY:
	case SEQ_MM_ACTIVERESIZE_END:
	case SEQ_MM_ACTIVERESIZE_START:
	case SEQ_MM_ACTIVEMOVE:
		// Release the mouse capture
		var.vt = VT_BOOL;
		V_BOOL(&var) = FALSE;
		m_pSequenceMgr->m_pTimeline->SetTimelineProperty( TP_STRIPMOUSECAPTURE, var );

		// Reset m_MouseMode
		switch( m_MouseMode )
		{
		case SEQ_MM_ACTIVERESIZE_VELOCITY:
			m_MouseMode = SEQ_MM_RESIZE_VELOCITY;
			break;
		case SEQ_MM_ACTIVERESIZE_END:
			m_MouseMode = SEQ_MM_RESIZE_END;
			break;
		case SEQ_MM_ACTIVERESIZE_START:
			m_MouseMode = SEQ_MM_RESIZE_START;
			break;
		case SEQ_MM_ACTIVEMOVE:
			m_MouseMode = SEQ_MM_MOVE;
			break;
		}

		if( !m_fInsertingNoteFromMouseClick && m_pActiveNote && !m_OriginalSeqItem.IsEqual( m_pActiveNote ) )
		{
			// Let the object know about the changes
			m_nLastEdit = IDS_UNDO_CHANGE;
			m_pSequenceMgr->OnDataChanged();
		}
		break;
	default:
		break;
	}

	// Reset the insertion flag
	m_fInsertingNoteFromMouseClick = FALSE;

	// We don't need to refresh the property page here because it should already
	// be up-to-date from the last mouse message (LBUTTON_DOWN or MOUSE_MOVE).
	SetMouseMode( lXPos, lYPos );

	// Unselect all items in other strips
	UnselectGutterRange();
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CSequenceStrip::OnMouseMove

HRESULT CSequenceStrip::OnMouseMove( long lXPos, long lYPos)
{
	if (m_svView == SV_MINIMIZED)
	{
		return S_OK;
	}

	long xDelta, yDelta;

	switch(m_MouseMode)
	{
	case SEQ_MM_ACTIVERESIZE_VELOCITY:
		// compute the new velocity
		yDelta = m_pointClicked.y - lYPos;
		yDelta = long((double)yDelta/m_dblVerticalZoom);
		if ( (m_SelectionMode == SEQ_SINGLE_SELECT) && m_pActiveNote )
		{
			long lVel;
			lVel = m_OriginalSeqItem.m_bByte2 + yDelta / 2;
			if ( lVel > 127 )
				lVel = 127;
			if ( lVel < 1 )
				lVel = 1;

			if( lVel != m_pActiveNote->m_bByte2 )
			{
				m_pActiveNote->m_bByte2 = (BYTE)lVel;
				InvalidateStrip();
				m_pSequenceMgr->RefreshPropertyPage();

				m_pSequenceMgr->PlayNote( m_pActiveNote );
			}
		}
		else if( (m_SelectionMode == SEQ_MULTIPLE_SELECT) && ((yDelta / 2) - m_lLastDeltaVel) )
		{
			if( m_pSequenceMgr->OffsetSelectedNoteDurationAndVelocity( 0, (yDelta / 2) - m_lLastDeltaVel, FALSE ) )
			{
				m_lLastDeltaVel = yDelta / 2;
			}
		}
		break;

	case SEQ_MM_ACTIVERESIZE_END:
		if ( (m_SelectionMode == SEQ_MULTIPLE_SELECT) ||
			 (m_SelectionMode == SEQ_SINGLE_SELECT) && m_pActiveNote)
		{
			// compute the original and new end points
			long lTemp1, lTemp2;
			m_pSequenceMgr->m_pTimeline->PositionToClocks(m_pointClicked.x,&lTemp1);
			m_pSequenceMgr->m_pTimeline->PositionToClocks(lXPos,&lTemp2);

			// compute the change
			xDelta = lTemp2 - lTemp1;

			// scroll if necessary
			AdjustScroll(lXPos, lYPos);

			if( m_SelectionMode == SEQ_SINGLE_SELECT )
			{
				// Resize in clocks
				long lDur;
				lDur = m_OriginalSeqItem.m_mtDuration + xDelta;
				if ( lDur < 1 )
				{
					lDur = 1;
				}

				if( lDur != m_pActiveNote->m_mtDuration )
				{
					m_pActiveNote->m_mtDuration = lDur;
					InvalidateStrip();
					m_pSequenceMgr->RefreshPropertyPage();
				}
			}
			else if( xDelta - m_lLastDeltaDur )
			{
				if( m_pSequenceMgr->OffsetSelectedNoteDurationAndVelocity( xDelta - m_lLastDeltaDur, 0, FALSE ) )
				{
					m_lLastDeltaDur = xDelta;
				}
			}
		}
		break;

	case SEQ_MM_ACTIVERESIZE_START:
		if ( (m_SelectionMode == SEQ_SINGLE_SELECT) || (m_SelectionMode == SEQ_MULTIPLE_SELECT) )
		{
			// compute the original and new start points
			long lTemp1, lTemp2;
			m_pSequenceMgr->m_pTimeline->PositionToClocks(m_pointClicked.x,&lTemp1);
			m_pSequenceMgr->m_pTimeline->PositionToClocks(lXPos,&lTemp2);
			
			// Get the snap amound
			long lSnapAmount = GetSnapAmount( lTemp1 + m_lLastDeltaStart );

			// compute the change
			long lDeltaStart;
			if( lSnapAmount > 1 )
			{
				lDeltaStart = lSnapAmount * ((abs(lTemp2 - lTemp1) + (lSnapAmount / 2)) / lSnapAmount);
				lDeltaStart *= lTemp2 > lTemp1 ? 1 : -1;
				lDeltaStart -= m_lLastDeltaStart;
			}
			else
			{
				lDeltaStart = lTemp2 - lTemp1 - m_lLastDeltaStart;
			}

			if ( lDeltaStart != 0 )
			{
				// Compute the length of the pickup bar
				long lEarlyMeasureClocks = 0;
				DMUS_TIMESIGNATURE ts;
				if( SUCCEEDED( m_pSequenceMgr->m_pTimeline->GetParam( GUID_TimeSignature, m_pSequenceMgr->m_dwGroupBits, m_pSequenceMgr->m_dwIndex, 0, NULL, &ts ) ) )
				{
					lEarlyMeasureClocks = -ts.bBeatsPerMeasure * ((DMUS_PPQ * 4) / ts.bBeat);
				}

				// Compute the length of the extension bar
				long lLateMeasureClocks = 0;
				if( SUCCEEDED( m_pSequenceMgr->m_pTimeline->GetParam( GUID_TimeSignature, m_pSequenceMgr->m_dwGroupBits, m_pSequenceMgr->m_dwIndex, m_mtLength - 1, NULL, &ts ) ) )
				{
					lLateMeasureClocks = ts.bBeatsPerMeasure * ((DMUS_PPQ * 4) / ts.bBeat);
				}

				POSITION pos = m_pSequenceMgr->m_lstSequences.GetHeadPosition();
				while( pos )
				{
					CSequenceItem *pSeqItem = m_pSequenceMgr->m_lstSequences.GetNext( pos );
					if ( pSeqItem->m_fSelected )
					{
						// Make sure the start time doesn't go out of bounds
						/*
						if( (pSeqItem->MusicTime() >= 0)
						&&	(pSeqItem->MusicTime() + lDeltaStart < 0) )
						*/
						if ( pSeqItem->MusicTime() + lDeltaStart < 0 )
						{
							if( lSnapAmount > 1 )
							{
								lDeltaStart = lSnapAmount * (-pSeqItem->MusicTime() / lSnapAmount);
							}
							else
							{
								lDeltaStart = -pSeqItem->MusicTime();
							}
						}
						else if ( pSeqItem->MusicTime() + lDeltaStart >= m_mtLength )
						{
							if( lSnapAmount > 1 )
							{
								lDeltaStart = lSnapAmount * ((m_mtLength - pSeqItem->MusicTime() - 1) / lSnapAmount);
							}
							else
							{
								lDeltaStart = m_mtLength - pSeqItem->MusicTime() - 1;
							}
						}

						// Now ensure lDeltaStart does not put the event more than one measure ahead of the sequence
						if( lDeltaStart + pSeqItem->AbsTime() < lEarlyMeasureClocks )
						{
							if( lSnapAmount > 1 )
							{
								lDeltaStart = lSnapAmount * ((lEarlyMeasureClocks - pSeqItem->AbsTime()) / lSnapAmount);
							}
							else
							{
								lDeltaStart = lEarlyMeasureClocks - pSeqItem->AbsTime();
							}
						}

						// Now ensure lStartTime does not put the event more than one measure after the segment
						if( lDeltaStart + pSeqItem->AbsTime() > m_mtLength - 1 + lLateMeasureClocks )
						{
							if( lSnapAmount > 1 )
							{
								lDeltaStart = lSnapAmount * ((m_mtLength - 1 + lLateMeasureClocks - pSeqItem->AbsTime()) / lSnapAmount);
							}
							else
							{
								lDeltaStart = m_mtLength - 1 + lLateMeasureClocks - pSeqItem->AbsTime();
							}
						}

						// Make sure the duration stays in bounds
						if (  pSeqItem->m_mtDuration - lDeltaStart - 1 < 0 )
						{
							lDeltaStart = pSeqItem->m_mtDuration - 1;
						}
					}
				}

				// scroll if necessary
				AdjustScroll(lXPos, lYPos);

				if( (m_SelectionMode == SEQ_SINGLE_SELECT) && m_pActiveNote &&
					(m_pActiveNote->m_mtDuration - lDeltaStart <= 0) )
				{
					lDeltaStart = m_pActiveNote->m_mtDuration - 1;
				}

				if( lDeltaStart &&
					(((m_SelectionMode == SEQ_SINGLE_SELECT) &&
					  m_pActiveNote &&
					  (m_pActiveNote->m_mtDuration - lDeltaStart > 0)) ||
					 (m_SelectionMode == SEQ_MULTIPLE_SELECT)) )
				{
					if( m_pSequenceMgr->OffsetSelectedNoteValuePositionAndStart( 0, 0, lDeltaStart, FALSE ) )
					{
						m_lLastDeltaStart = m_lLastDeltaStart + lDeltaStart;
					}
				}
			}

		}
		break;

	case SEQ_MM_ACTIVEMOVE:
		if ( (m_SelectionMode == SEQ_SINGLE_SELECT) || (m_SelectionMode == SEQ_MULTIPLE_SELECT) )
		{
			// compute the original and new start points
			long lTemp1, lTemp2;
			m_pSequenceMgr->m_pTimeline->PositionToClocks(m_pointClicked.x,&lTemp1);
			m_pSequenceMgr->m_pTimeline->PositionToClocks(lXPos,&lTemp2);
			
			// Get the snap amound
			long lSnapAmount = GetSnapAmount( lTemp1 + m_lLastDeltaMove );

			// compute the change
			long lDeltaStart;
			if( lSnapAmount > 1 )
			{
				lDeltaStart = lSnapAmount * ((abs(lTemp2 - lTemp1) + (lSnapAmount / 2)) / lSnapAmount);
				lDeltaStart *= lTemp2 > lTemp1 ? 1 : -1;
				lDeltaStart -= m_lLastDeltaMove;
			}
			else
			{
				lDeltaStart = lTemp2 - lTemp1 - m_lLastDeltaMove;
			}

			// Compute the length of the pickup bar
			long lEarlyMeasureClocks = 0;
			DMUS_TIMESIGNATURE ts;
			if( SUCCEEDED( m_pSequenceMgr->m_pTimeline->GetParam( GUID_TimeSignature, m_pSequenceMgr->m_dwGroupBits, m_pSequenceMgr->m_dwIndex, 0, NULL, &ts ) ) )
			{
				lEarlyMeasureClocks = -ts.bBeatsPerMeasure * ((DMUS_PPQ * 4) / ts.bBeat);
			}

			// Compute the length of the extension bar
			long lLateMeasureClocks = 0;
			if( SUCCEEDED( m_pSequenceMgr->m_pTimeline->GetParam( GUID_TimeSignature, m_pSequenceMgr->m_dwGroupBits, m_pSequenceMgr->m_dwIndex, m_mtLength - 1, NULL, &ts ) ) )
			{
				lLateMeasureClocks = ts.bBeatsPerMeasure * ((DMUS_PPQ * 4) / ts.bBeat);
			}

			// Compute the new note value
			yDelta = m_pointClicked.y - lYPos;
			long lDeltaValue;
			if( m_fHybridNotation )
			{
				// These divide m_lMaxNoteHeight by 8 instead of 4 because we want to decrease the
				// 'null' zone around the original note
				if ( yDelta < 0 )
				{
					// Convert from ypos to a scale position (with B#10 as 0)
					lDeltaValue = (4 * (-yDelta + m_lMaxNoteHeight/8)) / m_lMaxNoteHeight;

					// Convert from a scale position to a MIDI value
					lDeltaValue = (lDeltaValue / 14) * 12 + aDoubleScaleToChrom[lDeltaValue % 14];

					lDeltaValue = -lDeltaValue - m_cLastDeltaValue;
				}
				else
				{
					// Convert from ypos to a scale position (with B#10 as 0)
					lDeltaValue = (4 * (yDelta + m_lMaxNoteHeight/8)) / m_lMaxNoteHeight;

					// Convert from a scale position to a MIDI value
					lDeltaValue = (lDeltaValue / 14) * 12 + aDoubleScaleToChrom[lDeltaValue % 14];

					lDeltaValue = lDeltaValue - m_cLastDeltaValue;
				}
			}
			else
			{
				if ( yDelta < 0 )
				{
					lDeltaValue = ((yDelta - m_lMaxNoteHeight/2) / m_lMaxNoteHeight) - m_cLastDeltaValue;
				}
				else
				{
					lDeltaValue = ((yDelta + m_lMaxNoteHeight/2) / m_lMaxNoteHeight) - m_cLastDeltaValue;
				}
			}

			if ( lDeltaStart != 0 || lDeltaValue != 0 )
			{
				CSequenceItem *pSeqItem;
				POSITION pos = m_pSequenceMgr->m_lstSequences.GetHeadPosition();

				while( pos )
				{
					pSeqItem = m_pSequenceMgr->m_lstSequences.GetNext( pos );
					if ( pSeqItem->m_fSelected )
					{
						// Make sure the start time doesn't go out of bounds
						if ( pSeqItem->MusicTime() + lDeltaStart < 0 )
						{
							if( lSnapAmount > 1 )
							{
								lDeltaStart = lSnapAmount * (-pSeqItem->MusicTime() / lSnapAmount);
							}
							else
							{
								lDeltaStart = -pSeqItem->MusicTime();
							}
						}
						else if ( pSeqItem->MusicTime() + lDeltaStart >= m_mtLength )
						{
							if( lSnapAmount > 1 )
							{
								lDeltaStart = lSnapAmount * ((m_mtLength - pSeqItem->MusicTime() - 1) / lSnapAmount);
							}
							else
							{
								lDeltaStart = m_mtLength - pSeqItem->MusicTime() - 1;
							}
						}

						// Now ensure lDeltaStart does not put the event more than one measure ahead of the sequence
						if( lDeltaStart + pSeqItem->AbsTime() < lEarlyMeasureClocks )
						{
							if( lSnapAmount > 1 )
							{
								lDeltaStart = lSnapAmount * ((lEarlyMeasureClocks - pSeqItem->AbsTime()) / lSnapAmount);
							}
							else
							{
								lDeltaStart = lEarlyMeasureClocks - pSeqItem->AbsTime();
							}
						}

						// Now ensure lStartTime does not put the event more than one measure after the segment
						if( lDeltaStart + pSeqItem->AbsTime() > m_mtLength - 1 + lLateMeasureClocks )
						{
							if( lSnapAmount > 1 )
							{
								lDeltaStart = lSnapAmount * ((m_mtLength - 1 + lLateMeasureClocks - pSeqItem->AbsTime()) / lSnapAmount);
							}
							else
							{
								lDeltaStart = m_mtLength - 1 + lLateMeasureClocks - pSeqItem->AbsTime();
							}
						}

						// Make sure the value doesn't go out of bounds
						long lValue = pSeqItem->m_bByte1 + lDeltaValue;

						if( lValue < 0 )
						{
							// Ensure bottom does not go below 0
							lDeltaValue += -lValue;
							// TODO: Probably not necessary:
							lValue = pSeqItem->m_bByte1 + lDeltaValue;
						}

						if ( lValue > 127 )
						{
							// Ensure top does not go above 127
							lDeltaValue += 127 - lValue;
						}
					}
				}

				// scroll if necessary
				AdjustScroll(lXPos, lYPos);

				if( lDeltaStart || lDeltaValue )
				{
					if( m_pSequenceMgr->OffsetSelectedNoteValuePositionAndStart( lDeltaValue, lDeltaStart, 0, m_fCtrlKeyDown ) )
					{
						m_lLastDeltaMove = m_lLastDeltaMove + lDeltaStart;
						m_cLastDeltaValue = char (m_cLastDeltaValue + char (lDeltaValue));

						if( m_fCtrlKeyDown )
						{
							m_fCtrlKeyDown = 0;
						}
					}
				}
			}

		}
		break;
	case SEQ_MM_NORMAL:
	case SEQ_MM_MOVE:
	case SEQ_MM_RESIZE_START:
	case SEQ_MM_RESIZE_END:
	case SEQ_MM_RESIZE_VELOCITY:
		break;
	default:
		break;
	}
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CSequenceStrip::OnKeyDown

HRESULT CSequenceStrip::OnKeyDown( WPARAM wParam )
{
	if( (wParam == VK_INSERT)
	||	(wParam == VK_DELETE) )
	{
		if( (0x8000 & GetKeyState( VK_CONTROL ))
		&&	(0x8000 & GetKeyState( VK_SHIFT )) )
		{
			if( wParam == VK_INSERT )
			{
				return m_pSequenceMgr->AddNewPart();
			}
			else
			{
				HWND hwnd = GetTimelineHWnd();
				if( hwnd )
				{
					hwnd = ::GetParent( hwnd );
					if( hwnd )
					{
						::SendMessage( hwnd, WM_COMMAND, MAKEWPARAM( ID_EDIT_DELETE_TRACK, 0 ), 0 );
					}
				}
			}
		}
	}

	if (m_svView == SV_MINIMIZED)
	{
		return S_OK;
	}

	switch(m_MouseMode)
	{
	case SEQ_MM_NORMAL:
	case SEQ_MM_MOVE:
	case SEQ_MM_RESIZE_START:
	case SEQ_MM_RESIZE_END:
	case SEQ_MM_RESIZE_VELOCITY:
		// Up arrow / Down arrow / Page Up / Page Down
		if ( (wParam == 38) || (wParam == 40 ) || (wParam == 33) || (wParam == 34 ) )
		{
			long lNewVertScroll = m_lVScroll;
			long lNewInsertVal = m_lInsertVal;

			// scroll the piano roll up and down and move the note cursor
			// DOWN arrow
			if (wParam == 40)
			{
				lNewInsertVal--;
				if( lNewInsertVal < 0 )
				{
					lNewInsertVal = 0;
				}
				else
				{
					if( m_fHybridNotation )
					{
						int iNewHybridPos, iOldHybridPos;
						// FLATS
						if( m_pSequenceMgr->m_fDisplayingFlats )
						{
							iNewHybridPos = MIDIToHybridPos( (BYTE) lNewInsertVal, aChromToScaleFlats);
							iOldHybridPos = MIDIToHybridPos( (BYTE) m_lInsertVal, aChromToScaleFlats);
						}
						// SHARPS
						else
						{
							iNewHybridPos = MIDIToHybridPos( (BYTE) lNewInsertVal, aChromToScaleSharps);
							iOldHybridPos = MIDIToHybridPos( (BYTE) m_lInsertVal, aChromToScaleSharps);
						}

						if( iNewHybridPos / 2 != iOldHybridPos / 2 )
						{
							lNewVertScroll += m_lMaxNoteHeight;
						}

						if ( lNewVertScroll / m_lMaxNoteHeight > 37)
						{
							lNewVertScroll = m_lMaxNoteHeight * 37;
						}
					}
					else
					{
						lNewVertScroll += m_lMaxNoteHeight;
						if ( lNewVertScroll / m_lMaxNoteHeight > 127)
						{
							lNewVertScroll = m_lMaxNoteHeight * 127;
						}
					}
				}
			}

			// UP arrow
			else if (wParam == 38)
			{
				lNewInsertVal++;
				if( lNewInsertVal > 127 )
				{
					lNewInsertVal = 127;
				}
				else
				{
					if( m_fHybridNotation )
					{
						int iNewHybridPos, iOldHybridPos;
						// FLATS
						if( m_pSequenceMgr->m_fDisplayingFlats )
						{
							iNewHybridPos = MIDIToHybridPos( (BYTE) lNewInsertVal, aChromToScaleFlats);
							iOldHybridPos = MIDIToHybridPos( (BYTE) m_lInsertVal, aChromToScaleFlats);
						}
						// SHARPS
						else
						{
							iNewHybridPos = MIDIToHybridPos( (BYTE) lNewInsertVal, aChromToScaleSharps);
							iOldHybridPos = MIDIToHybridPos( (BYTE) m_lInsertVal, aChromToScaleSharps);
						}

						if( iNewHybridPos / 2 != iOldHybridPos / 2 )
						{
							lNewVertScroll -= m_lMaxNoteHeight;
						}
					}
					else
					{
						lNewVertScroll -= m_lMaxNoteHeight;
					}

					if ( lNewVertScroll < 0)
					{
						lNewVertScroll = 0;
					}
				}
			}

			// Page Down
			else if (wParam == 34)
			{
				lNewInsertVal -= 12;
				if( lNewInsertVal < 0 )
				{
					lNewInsertVal = 0;
				}

				if( m_fHybridNotation )
				{
					int iNewHybridPos, iOldHybridPos;
					// FLATS
					if( m_pSequenceMgr->m_fDisplayingFlats )
					{
						iNewHybridPos = MIDIToHybridPos( (BYTE) lNewInsertVal, aChromToScaleFlats);
						iOldHybridPos = MIDIToHybridPos( (BYTE) m_lInsertVal, aChromToScaleFlats);
					}
					// SHARPS
					else
					{
						iNewHybridPos = MIDIToHybridPos( (BYTE) lNewInsertVal, aChromToScaleSharps);
						iOldHybridPos = MIDIToHybridPos( (BYTE) m_lInsertVal, aChromToScaleSharps);
					}

					lNewVertScroll -= ((iNewHybridPos / 2) - (iOldHybridPos / 2)) * m_lMaxNoteHeight;

					if ( lNewVertScroll / m_lMaxNoteHeight > 37)
					{
						lNewVertScroll = m_lMaxNoteHeight * 37;
					}
				}
				else
				{
					lNewVertScroll += 12 * m_lMaxNoteHeight;
					if ( lNewVertScroll / m_lMaxNoteHeight > 127)
					{
						lNewVertScroll = m_lMaxNoteHeight * 127;
					}
				}
			}

			// Page Up
			else if (wParam == 33)
			{
				lNewInsertVal += 12;
				if( lNewInsertVal > 127 )
				{
					lNewInsertVal = 127;
				}

				if( m_fHybridNotation )
				{
					int iNewHybridPos, iOldHybridPos;
					// FLATS
					if( m_pSequenceMgr->m_fDisplayingFlats )
					{
						iNewHybridPos = MIDIToHybridPos( (BYTE) lNewInsertVal, aChromToScaleFlats);
						iOldHybridPos = MIDIToHybridPos( (BYTE) m_lInsertVal, aChromToScaleFlats);
					}
					// SHARPS
					else
					{
						iNewHybridPos = MIDIToHybridPos( (BYTE) lNewInsertVal, aChromToScaleSharps);
						iOldHybridPos = MIDIToHybridPos( (BYTE) m_lInsertVal, aChromToScaleSharps);
					}

					lNewVertScroll += ((iOldHybridPos / 2) - (iNewHybridPos / 2)) * m_lMaxNoteHeight;
				}
				else
				{
					lNewVertScroll -= 12 * m_lMaxNoteHeight;
				}

				if ( lNewVertScroll < 0)
				{
					lNewVertScroll = 0;
				}
			}

			if (lNewVertScroll != m_lVScroll)
			{
				SetVScroll( lNewVertScroll );
			}

			// Redraw the strip
			if( lNewInsertVal != m_lInsertVal )
			{
				m_lInsertVal = lNewInsertVal;
				InvalidatePianoRoll();
			}
		}
		break;
	case SEQ_MM_ACTIVERESIZE_VELOCITY:
		if( (wParam == 40) || (wParam == 38) )
		{
			long lDelta = 0;
			// UP
			if (wParam == 38) lDelta = 1;
			// DOWN
			if (wParam == 40) lDelta = -1;
			if ( (m_SelectionMode == SEQ_SINGLE_SELECT) && m_pActiveNote )
			{
				long lVel;
				lVel = m_OriginalSeqItem.m_bByte2 + lDelta;
				if ( lVel > 127 )
					lVel = 127;
				if ( lVel < 1 )
					lVel = 1;

				if( lVel != m_pActiveNote->m_bByte2 )
				{
					m_pActiveNote->m_bByte2 = (BYTE)lVel;
					InvalidateStrip();
					m_pSequenceMgr->RefreshPropertyPage();
				}
			}
			else if(m_SelectionMode == SEQ_MULTIPLE_SELECT)
			{
				m_pSequenceMgr->OffsetSelectedNoteDurationAndVelocity( 0, lDelta, FALSE ); 
			}
		}
		break;
	case SEQ_MM_ACTIVERESIZE_END:
		if ((wParam == 39) || (wParam == 37))
		{
			long lDelta = 0;
			// LEFT
			if (wParam == 37) lDelta = -1;
			// RIGHT
			if (wParam == 39) lDelta = 1;

			if( (m_SelectionMode == SEQ_SINGLE_SELECT) && m_pActiveNote )
			{
				// Resize in clocks
				long lDur;
				lDur = m_OriginalSeqItem.m_mtDuration + lDelta;
				if ( lDur < 1 )
				{
					lDur = 1;
				}

				if( lDur != m_pActiveNote->m_mtDuration )
				{
					m_pActiveNote->m_mtDuration = lDur;
					InvalidateStrip();
					m_pSequenceMgr->RefreshPropertyPage();
				}
			}
			else if(m_SelectionMode == SEQ_MULTIPLE_SELECT)
			{
				m_pSequenceMgr->OffsetSelectedNoteDurationAndVelocity( lDelta, 0, FALSE );
			}
		}
		break;

	case SEQ_MM_ACTIVERESIZE_START:
		if ( (m_SelectionMode == SEQ_SINGLE_SELECT) || (m_SelectionMode == SEQ_MULTIPLE_SELECT) )
		if ( ((m_SelectionMode == SEQ_SINGLE_SELECT) || (m_SelectionMode == SEQ_MULTIPLE_SELECT))
		  && ((wParam == 39) || (wParam == 37 )))
		{
			// compute the original and new start points
			long lTemp1;
			m_pSequenceMgr->m_pTimeline->PositionToClocks(m_pointClicked.x,&lTemp1);
			
			// Get the snap amound
			long lSnapAmount = GetSnapAmount( lTemp1 + m_lLastDeltaStart );

			// compute the change
			long lDeltaStart = lSnapAmount * ((wParam == 39) ? 1 : -1);

			if ( lDeltaStart != 0 )
			{
				CSequenceItem *pSeqItem;
				POSITION pos = m_pSequenceMgr->m_lstSequences.GetHeadPosition();

				while( pos )
				{
					pSeqItem = m_pSequenceMgr->m_lstSequences.GetNext( pos );
					if ( pSeqItem->m_fSelected )
					{
						// Make sure the start time doesn't go out of bounds
						if ( pSeqItem->MusicTime() + lDeltaStart < 0 )
						{
							lDeltaStart = 0;
						}
						else if ( pSeqItem->MusicTime() + lDeltaStart >= m_mtLength )
						{
							lDeltaStart = 0;
						}

						// Now ensure lDeltaStart does not put the event more than one measure ahead of the sequence
						DMUS_TIMESIGNATURE ts;
						if( SUCCEEDED( m_pSequenceMgr->m_pTimeline->GetParam( GUID_TimeSignature, m_pSequenceMgr->m_dwGroupBits, m_pSequenceMgr->m_dwIndex, 0, NULL, &ts ) ) )
						{
							if( lDeltaStart + pSeqItem->AbsTime() < -(ts.bBeatsPerMeasure * ((DMUS_PPQ * 4) / ts.bBeat)) )
							{
								lDeltaStart = 0;
							}
						}

						// Now ensure lStartTime does not put the event more than one measure after the segment
						if( SUCCEEDED( m_pSequenceMgr->m_pTimeline->GetParam( GUID_TimeSignature, m_pSequenceMgr->m_dwGroupBits, m_pSequenceMgr->m_dwIndex, m_mtLength - 1, NULL, &ts ) ) )
						{
							if( lDeltaStart + pSeqItem->AbsTime() > m_mtLength - 1 + (ts.bBeatsPerMeasure * ((DMUS_PPQ * 4) / ts.bBeat)) )
							{
								lDeltaStart = 0;
							}
						}
					}
				}

				// scroll if necessary
				//TODO: Implement
				//AdjustScroll(lXPos, lYPos);

				if( lDeltaStart )
				{
					if( m_pSequenceMgr->OffsetSelectedNoteValuePositionAndStart( 0, 0, lDeltaStart, FALSE ) )
					{
						m_lLastDeltaStart = m_lLastDeltaStart + lDeltaStart;
					}
				}
			}

		}
		break;

	case SEQ_MM_ACTIVEMOVE:
		if ( (m_SelectionMode == SEQ_SINGLE_SELECT) || (m_SelectionMode == SEQ_MULTIPLE_SELECT) )
		{
			long lDeltaValue = 0;
			long lDeltaStart = 0;

			// UP
			if (wParam == 38)
			{
				lDeltaValue = +1;
			}
			// DOWN
			if (wParam == 40)
			{
				lDeltaValue = -1;
			}

			// LEFT
			// RIGHT
			if ( (wParam == 37) || (wParam == 39) )
			{
				if( m_pActiveNote )
				{
					lDeltaStart = m_pActiveNote->AbsTime();
				}
				else
				{
					CSequenceItem *pItem = m_pSequenceMgr->FirstSelectedSequence();
					if( pItem )
					{
						lDeltaStart = pItem->AbsTime();
					}
					else
					{
						ASSERT(FALSE);
						lDeltaStart = 0;
					}
				}
				lDeltaStart = GetSnapAmount( lDeltaStart );
				lDeltaStart *= (wParam == 39) ? 1 : -1;
			}
			
			if ( lDeltaStart != 0 || lDeltaValue != 0 )
			{
				CSequenceItem *pSeqItem;
				POSITION pos = m_pSequenceMgr->m_lstSequences.GetHeadPosition();
				while( pos )
				{
					pSeqItem = m_pSequenceMgr->m_lstSequences.GetNext( pos );
					if ( pSeqItem->m_fSelected )
					{
						// Make sure the start time doesn't go out of bounds
						if ( pSeqItem->MusicTime() + lDeltaStart < 0 )
						{
							lDeltaStart = 0;
						}
						else if ( pSeqItem->MusicTime() + lDeltaStart >= m_mtLength )
						{
							lDeltaStart = 0;
						}

						// Now ensure lDeltaStart does not put the event more than one measure ahead of the sequence
						DMUS_TIMESIGNATURE ts;
						if( SUCCEEDED( m_pSequenceMgr->m_pTimeline->GetParam( GUID_TimeSignature, m_pSequenceMgr->m_dwGroupBits, m_pSequenceMgr->m_dwIndex, 0, NULL, &ts ) ) )
						{
							if( lDeltaStart + pSeqItem->AbsTime() < -(ts.bBeatsPerMeasure * ((DMUS_PPQ * 4) / ts.bBeat)) )
							{
								lDeltaStart = 0;
							}
						}

						// Now ensure lStartTime does not put the event more than one measure after the segment
						if( SUCCEEDED( m_pSequenceMgr->m_pTimeline->GetParam( GUID_TimeSignature, m_pSequenceMgr->m_dwGroupBits, m_pSequenceMgr->m_dwIndex, m_mtLength - 1, NULL, &ts ) ) )
						{
							if( lDeltaStart + pSeqItem->AbsTime() > m_mtLength - 1 + (ts.bBeatsPerMeasure * ((DMUS_PPQ * 4) / ts.bBeat)) )
							{
								lDeltaStart = 0;
							}
						}

						// Make sure the value doesn't go out of bounds
						long lValue = pSeqItem->m_bByte1 + lDeltaValue;

						if( lValue < 0 )
						{
							// Ensure bottom does not go below 0
							lDeltaValue += -lValue;
							// Probably not necessary:
							lValue = pSeqItem->m_bByte1 + lDeltaValue;
						}

						if ( lValue > 127 )
						{
							// Ensure top does not go above 127
							lDeltaValue += 127 - lValue;
						}
					}
				}

				if( m_pSequenceMgr->OffsetSelectedNoteValuePositionAndStart( lDeltaValue, lDeltaStart, 0, m_fCtrlKeyDown ) )
				{
					m_lLastDeltaMove = m_lLastDeltaMove + lDeltaStart;
					m_cLastDeltaValue = char (m_cLastDeltaValue + char (lDeltaValue));

					if( m_fCtrlKeyDown )
					{
						m_fCtrlKeyDown = 0;
					}
				}
			}
		}
		break;
	default:
		break;
	}
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CSequenceStrip::OnChangeStripView

void CSequenceStrip::OnChangeStripView( STRIPVIEW svNewStripView )
{
	if( m_svView != svNewStripView )
	{
		// Change StripView field
		m_svView = svNewStripView;

		// Remove all existing Curve Strips
		CCurveStrip *pCurveStrip;
		while( !m_lstCurveStrips.IsEmpty() )
		{
			pCurveStrip = static_cast<CCurveStrip*>( m_lstCurveStrips.GetHead() );
			RemoveCurveStrip( pCurveStrip );
		}

		// If minimizing and gutter is not selected, unselect all events in our variations
		if( (m_svView == SV_MINIMIZED) && m_bGutterSelected &&
			(m_lBeginSelect >= 0) && (m_lEndSelect > 0) )
		{
			if ( m_SelectionMode != SEQ_NO_SELECT )
			{
				//BUGBUG: Should we unselect curves here as well?  The PianoRollStrip does...
				m_pSequenceMgr->UnselectAllNotes();
				m_SelectionMode = SEQ_NO_SELECT;
			}
		}

		AddCurveStrips();

		// Let the object know about the changes
		if( m_svView == SV_NORMAL )
		{
			m_nLastEdit = IDS_UNDO_STRIP_MAXIMIZED;
			m_VScrollBar.ShowWindow(TRUE);
		}
		else // m_svView == SV_MINIMIZED
		{
			m_nLastEdit = IDS_UNDO_STRIP_MINIMIZED;
			m_VScrollBar.ShowWindow(FALSE);
		}

		// Fix 27283: Don't store Undo states for Minimize/Maximize events

		// Check if TP_FREEZE_UNDO is NOT set.
		BOOL fFreezeUndo = FALSE;
		VARIANT var;
		if( SUCCEEDED( m_pSequenceMgr->m_pTimeline->GetTimelineProperty( TP_FREEZE_UNDO, &var ) ) )
		{
			fFreezeUndo = V_BOOL(&var);
		}

		if( !fFreezeUndo )
		{
			// Need to set TP_FREEZE_UNDO or the segment will add an undo state for us
			var.vt = VT_BOOL;
			V_BOOL(&var) = TRUE;
			m_pSequenceMgr->m_pTimeline->SetTimelineProperty( TP_FREEZE_UNDO, var );
		}

		// No need to update performance engine
		m_pSequenceMgr->m_fUpdateDirectMusic = FALSE;
		m_pSequenceMgr->OnDataChanged( );

		if( !fFreezeUndo )
		{
			// Need to reset TP_FREEZE_UNDO or the segment will add an undo state for us
			var.vt = VT_BOOL;
			V_BOOL(&var) = FALSE;
			m_pSequenceMgr->m_pTimeline->SetTimelineProperty( TP_FREEZE_UNDO, var );
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CSequenceStrip::OnDestroy

HRESULT CSequenceStrip::OnDestroy( void )
{
	ASSERT( m_pStripMgr != NULL );

	// Update the UI chunk
	UpdateSequenceUIChunk();

	// Don't delete curve strip states - delete them in the destructor

	CCurveStrip *pCurveStrip;
	while( !m_lstCurveStrips.IsEmpty() )
	{
		pCurveStrip = static_cast<CCurveStrip*>( m_lstCurveStrips.RemoveHead() );
		if( m_pSequenceMgr && m_pSequenceMgr->m_pTimeline )
		{
			m_pSequenceMgr->m_pTimeline->RemoveStrip( (IDMUSProdStrip *)pCurveStrip );
		}
		pCurveStrip->Release();
	}

	// Delete the Bitmap buttons
	if( InterlockedDecrement( &m_lBitmapRefCount ) == 0 )
	{
		if( m_BitmapZoomInUp.GetSafeHandle() != NULL )
		{
			m_BitmapZoomInUp.DeleteObject();
		}
		if( m_BitmapZoomInDown.GetSafeHandle() != NULL )
		{
			m_BitmapZoomInDown.DeleteObject();
		}
		if( m_BitmapZoomOutUp.GetSafeHandle() != NULL )
		{
			m_BitmapZoomOutUp.DeleteObject();
		}
		if( m_BitmapZoomOutDown.GetSafeHandle() != NULL )
		{
			m_BitmapZoomOutDown.DeleteObject();
		}
		if( m_BitmapNewBand.GetSafeHandle() != NULL )
		{
			m_BitmapNewBand.DeleteObject();
		}
	}

	if (m_VScrollBar.GetSafeHwnd())
	{
		m_VScrollBar.ShowWindow( FALSE );
		//m_VScrollBar.Detach();
		m_VScrollBar.DestroyWindow();
	}

	// Kill timer, if active
	KillTimer();
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CSequenceStrip::SetFocus

HRESULT CSequenceStrip::SetFocus( int iFocus )
{
	// When changing strip focus, KillFocus is always sent to the original strip before
	// SetFocus is sent to the strip that gains focus.  As a result, we will only have
	// the transitions 0->1, 1->0, 0->2, and 2->0 in this function.
	if( m_iHaveFocus != iFocus )
	{
		ASSERT( ((m_iHaveFocus == 0) && ( (iFocus == 1) || (iFocus == 2) ))
			 || ((iFocus == 0) && ( (m_iHaveFocus == 1) || (m_iHaveFocus == 2) )) );

		switch( iFocus )
		{
		case 0:
			// Save the current state
			iFocus = m_iHaveFocus;

			// Update m_iHaveFocus
			m_iHaveFocus = 0;

			// If the sequence strip had focus, redraw
			if( iFocus == 1 )
			{
				// Need to erase note cursor
				InvalidatePianoRoll();
			}
			
			// Always unregister MIDI
			UnRegisterMidi();

			// Stop any playing note
			m_pSequenceMgr->StopNote();

			// Fake a mouse-up
			OnLButtonUp( 0, 0 );
			break;

		case 1:
			// If there currently is no primary segment playing, try and play the patch for this PChannel
			{
				REFERENCE_TIME rtLatency;
				m_pSequenceMgr->m_pIDMPerformance->GetLatencyTime( &rtLatency );
				MUSIC_TIME mtLatency;
				m_pSequenceMgr->m_pIDMPerformance->ReferenceToMusicTime( rtLatency, &mtLatency );

				IDirectMusicSegmentState *pSegState;
				if( FAILED( m_pSequenceMgr->m_pIDMPerformance->GetSegmentState( &pSegState, mtLatency ) ) )
				{
					long lTime;
					if (SUCCEEDED(m_pSequenceMgr->m_pTimeline->GetMarkerTime( MARKER_CURRENTTIME, TIMETYPE_CLOCKS, &lTime )))
					{
						m_pSequenceMgr->PlayPatch( lTime );
					}
				}
				else
				{
					pSegState->Release();
				}
			}

			// Always fall through to the case below
		case 2:
			// Register MIDI if both strips previously didn't have focus
			ASSERT( m_iHaveFocus == 0 );
			if( (m_iHaveFocus == 0) && m_pSequenceMgr->m_fWindowActive )
			{
				RegisterMidi();
			}

			// Update m_iHaveFocus
			m_iHaveFocus = iFocus;
			if( m_iHaveFocus == 1 )
			{
				UpdateNoteCursorTime();
				// Need to draw the note cursor
				InvalidatePianoRoll();
			}

			if( (m_pSequenceMgr->m_dwPChannel >= DMUS_PCHANNEL_BROADCAST_GROUPS)
			&&	m_pSequenceMgr->m_pSegmentState && m_pSequenceMgr->m_fRecordEnabled
			&&	m_pSequenceMgr->m_fWindowActive )
			{
				// Try and set up MIDI thruing
				SetPChannelThru();
			}
			break;
		default:
			ASSERT(FALSE);
			break;
		}
	}

	m_pSequenceMgr->UpdateStatusBarDisplay();
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CSequenceStrip::UpdateName

void CSequenceStrip::UpdateName()
{
	CString strText, strTmp;
	BOOL fFoundGroup = FALSE;
	BOOL fLastSet = FALSE;
	int nStartGroup = -1;

	for( int i = 0 ;  i < 32 ;  i++ )
	{
		if( m_pSequenceMgr->m_dwGroupBits & (1 << i) )
		{
			if( !fLastSet )
			{
				fLastSet = TRUE;
				nStartGroup = i;
			}
		}
		else
		{
			if( fLastSet )
			{
				fLastSet = FALSE;
				if( nStartGroup == i - 1 )
				{
					if( fFoundGroup )
					{
						strTmp.Format(", %d", i);
					}
					else
					{
						strTmp.Format("%d", i);
						fFoundGroup = TRUE;
					}
				}
				else
				{
					if( fFoundGroup )
					{
						strTmp.Format(", %d-%d", nStartGroup + 1, i);
					}
					else
					{
						strTmp.Format("%d-%d", nStartGroup + 1, i);
						fFoundGroup = TRUE;
					}
				}
				strText += strTmp;
			}
		}
	}

	if( fLastSet )
	{
		fLastSet = FALSE;
		if( nStartGroup == i - 1 )
		{
			if( fFoundGroup )
			{
				strTmp.Format(", %d", i);
			}
			else
			{
				strTmp.Format("%d", i);
				fFoundGroup = TRUE;
			}
		}
		else
		{
			if( fFoundGroup )
			{
				strTmp.Format(", %d-%d", nStartGroup + 1, i);
			}
			else
			{
				strTmp.Format("%d-%d", nStartGroup + 1, i);
				fFoundGroup = TRUE;
			}
		}
		strText += strTmp;
	}

	// If available, query the IDMUSProdPChannelName interface for the PChannel name
	WCHAR wszName[MAX_PATH];
	if( m_pSequenceMgr->m_pIPChannelName &&
		SUCCEEDED( m_pSequenceMgr->m_pIPChannelName->GetPChannelName( m_pSequenceMgr->m_dwPChannel, wszName ) ) )
	{
		if( m_pSequenceMgr->m_dwPChannel < DMUS_PCHANNEL_BROADCAST_GROUPS )
		{
			m_strName.Format( "%s: %d (%S): %s", strText, m_pSequenceMgr->m_dwPChannel + 1, wszName, m_pSequenceMgr->m_strName );
		}
		else
		{
			CString strNewName;
			if( m_pSequenceMgr->m_dwPChannel == DMUS_PCHANNEL_BROADCAST_SEGMENT )
			{
				strNewName.LoadString( IDS_BROADCAST_SEG );
			}
			else if( m_pSequenceMgr->m_dwPChannel == DMUS_PCHANNEL_BROADCAST_PERFORMANCE )
			{
				strNewName.LoadString( IDS_BROADCAST_PERF );
			}
			else if( m_pSequenceMgr->m_dwPChannel == DMUS_PCHANNEL_BROADCAST_GROUPS )
			{
				strNewName.LoadString( IDS_BROADCAST_GRP );
			}
			else if( m_pSequenceMgr->m_dwPChannel == DMUS_PCHANNEL_BROADCAST_AUDIOPATH )
			{
				strNewName.LoadString( IDS_BROADCAST_APATH );
			}
			m_strName.Format( "%s: %s (%S): %s", strText, strNewName, wszName, m_pSequenceMgr->m_strName );
		}
	}
	// If unable to get name from IPChannelName interface, default to just the #
	else
	{
		if( m_pSequenceMgr->m_dwPChannel < DMUS_PCHANNEL_BROADCAST_GROUPS )
		{
			m_strName.Format("%s: %d: %s", strText, m_pSequenceMgr->m_dwPChannel + 1, m_pSequenceMgr->m_strName );
		}
		else
		{
			CString strNewName;
			if( m_pSequenceMgr->m_dwPChannel == DMUS_PCHANNEL_BROADCAST_SEGMENT )
			{
				strNewName.LoadString( IDS_BROADCAST_SEG );
			}
			else if( m_pSequenceMgr->m_dwPChannel == DMUS_PCHANNEL_BROADCAST_PERFORMANCE )
			{
				strNewName.LoadString( IDS_BROADCAST_PERF );
			}
			else if( m_pSequenceMgr->m_dwPChannel == DMUS_PCHANNEL_BROADCAST_GROUPS )
			{
				strNewName.LoadString( IDS_BROADCAST_GRP );
			}
			else if( m_pSequenceMgr->m_dwPChannel == DMUS_PCHANNEL_BROADCAST_AUDIOPATH )
			{
				strNewName.LoadString( IDS_BROADCAST_APATH );
			}
			m_strName.Format( "%s: %s: %s", strText, strNewName, m_pSequenceMgr->m_strName );
		}
	}
}

#ifdef _DEBUG
/*
void CSequenceStrip::TraceFormatsInClipboard()
{
	char buf[MAX_PATH];
	IOleInPlaceObjectWindowless* pIOleInPlaceObjectWindowless;
	m_pSequenceMgr->m_pTimeline->QueryInterface( IID_IOleWindow, (void**)&pIOleInPlaceObjectWindowless );
	if (pIOleInPlaceObjectWindowless)
	{
		HWND hwnd;
		if (pIOleInPlaceObjectWindowless->GetWindow(&hwnd) == S_OK)
		{
			if(OpenClipboard(hwnd))
			{
				UINT format = 0;
				while(format = EnumClipboardFormats(format))
				{
					GetClipboardFormatName(format, buf, MAX_PATH);
					TRACE("Format = %s\n", buf);
				}
				CloseClipboard();
			}
		}
		pIOleInPlaceObjectWindowless->Release();
	}
}
*/
#endif

HRESULT CSequenceStrip::PasteMidiFile(IDMUSProdTimelineDataObject * pITimelineDataObject, long lClocks, BOOL fPasteToMultipleStrips )
{
	IStream* pIStream = NULL;
	HRESULT hr = pITimelineDataObject->AttemptRead(m_cfMidiFile, &pIStream);
	if(SUCCEEDED(hr))
	{
		if( fPasteToMultipleStrips )
		{
			if( !m_pSequenceMgr->FirstGutterSelectedSequenceMgr() )
			{
				// Already handled by the first sequence strip mgr.
				hr = S_FALSE;
			}
			else
			{
				// Split the MIDI file into multiple tracks and paste them in the correct spots
				hr = m_pSequenceMgr->ImportMIDIFileToMultipleTracks( pIStream );
			}
			pIStream->Release();
			return hr;
		}

		// Paste the entire MIDI file into this track.

		// get offset of first sequence's drag position to normalize all sequences to offset 0
		long lTimeOffset;
		if(m_pSequenceMgr->m_pTimeline)
		{
			CTypedPtrList<CPtrList, CSequenceItem*> lstSequences;
			CTypedPtrList<CPtrList, CCurveItem*> lstCurves;
			lTimeOffset = lClocks;
			if(SUCCEEDED(hr))
			{
				DWORD dwLength;
				hr = ReadMidiSequenceFromStream(pIStream, lstSequences, lstCurves, lTimeOffset, dwLength);
				// BUGBUG: no way to propagate dwLength to segment, user will have to set
				// to see pasted sequence longer than segment

				ASSERT(hr == S_OK);

				// Get the paste type
				TIMELINE_PASTE_TYPE tlPasteType;
				if( SUCCEEDED( m_pSequenceMgr->m_pTimeline->GetPasteType( &tlPasteType ) )
				&&	(tlPasteType == TL_PASTE_OVERWRITE) )
				{
					// Delete sequences
					m_pSequenceMgr->DeleteBetweenTimes( lClocks, lClocks + dwLength );

					// Delete curves
					POSITION pos2, pos;
					pos = m_pSequenceMgr->m_lstCurves.GetHeadPosition();
					while(pos)
					{
						// Save the current position
						pos2 = pos;
						CCurveItem* pCurveItem = m_pSequenceMgr->m_lstCurves.GetNext(pos);

						// If the curve occurs between lStart and lEnd, delete it
						if( (pCurveItem->AbsTime() >= lClocks) && (pCurveItem->AbsTime() <= lClocks + (signed)dwLength) ) 
						{
							m_pSequenceMgr->m_lstCurves.RemoveAt( pos2 );
							delete pCurveItem;
						}
					}
				}

				POSITION pos = lstSequences.GetHeadPosition();
				while(pos)
				{
					CSequenceItem* pItem = lstSequences.GetNext(pos);

					pItem->m_fSelected = TRUE;
					m_pSequenceMgr->InsertByAscendingTime(pItem);
				}

				pos = lstCurves.GetHeadPosition();
				while(pos)
				{
					CCurveItem* pCurveItem = lstCurves.GetNext(pos);

					pCurveItem->SetDefaultResetValues( m_mtLength );
					pCurveItem->m_fSelected = TRUE;
					m_pSequenceMgr->InsertByAscendingTime( pCurveItem );
				}
			}
			lstSequences.RemoveAll();
			lstCurves.RemoveAll();
		}
	}
	return hr;
}

void CSequenceStrip::DrawMinimizedNotes( HDC hDC, POSITION pos, long lStartTime, long lEndTime, long lXOffset, BOOL fSelected )
{
	long lNoteHeight = MINIMIZE_HEIGHT / m_bMinimizeNoteRange;
	if( lNoteHeight == 0 )
	{
		lNoteHeight = 1;
	}

	// Save the old background color
	COLORREF crOldBkColor = ::GetBkColor( hDC );

	// Set the notes' color
	::SetBkColor( hDC, ::GetNearestColor(hDC, fSelected ? m_crSelectedNoteColor : m_crUnselectedNoteColor) );

	RECT rectNote;
	while( pos )
	{
		const CSequenceItem *pSequenceItem = m_pSequenceMgr->m_lstSequences.GetNext( pos );
		const MUSIC_TIME mtStart = pSequenceItem->AbsTime();
		if ( (pSequenceItem->m_fSelected == fSelected) && 
			(mtStart + pSequenceItem->m_mtDuration > lStartTime) &&
			(mtStart < lEndTime) )
		{
			// Get position to draw at
			rectNote.top = ((m_bMinimizeTopNote - pSequenceItem->m_bByte1) * MINIMIZE_HEIGHT) / m_bMinimizeNoteRange;
			rectNote.bottom = rectNote.top + lNoteHeight;

			const MUSIC_TIME mtEnd = mtStart + pSequenceItem->m_mtDuration;

			m_pSequenceMgr->m_pTimeline->ClocksToPosition( mtEnd, &rectNote.right );
			m_pSequenceMgr->m_pTimeline->ClocksToPosition( mtStart, &rectNote.left );
			rectNote.left -= lXOffset;
			rectNote.right -= lXOffset;

			if ( rectNote.left == rectNote.right )
			{
				rectNote.right++;
			}

			::ExtTextOut( hDC, 0, 0, ETO_OPAQUE, &rectNote, NULL, 0, NULL);
		}
		else if ( pSequenceItem->AbsTime() > lEndTime )
		{
			break;
		}
	}

	// Reset the old background color
	::SetBkColor( hDC, crOldBkColor );
}

void CSequenceStrip::DrawMaximizedNotes( HDC hDC, POSITION pos, long lStartTime, long lEndTime, long lXOffset, int nTopNote, int nBottomNote, BOOL fSelected )
{
	// Set the notes' color
	COLORREF crNoteColor;
	if( fSelected )
	{
		crNoteColor = ::GetNearestColor(hDC, m_crSelectedNoteColor);
	}
	else
	{
		crNoteColor = ::GetNearestColor(hDC, m_crUnselectedNoteColor);
	}
	COLORREF crOldBkColor = ::SetBkColor( hDC, crNoteColor );

	// Create the brush to draw the early notes with
	HBRUSH hbrushHatchVert = ::CreateHatchBrush( HS_VERTICAL, ::GetNearestColor(hDC, COLOR_EARLY_NOTES) ); 

	// Create pen for drawing the overlapping note lines
	HPEN hpenOverlappingLine = ::CreatePen( PS_DOT, 1, ::GetNearestColor(hDC, GetSysColor(COLOR_WINDOW)) );
	HPEN hpenOld = static_cast<HPEN> (::SelectObject( hDC, hpenOverlappingLine ));
	HBRUSH hbrushHatchOverlapping = ::CreateHatchBrush( HS_FDIAGONAL, ::GetNearestColor(hDC, COLOR_HATCH_OVERLAPPING) ); 

	RECT rectNote;
	while( pos )
	{
		const CSequenceItem *pSequenceItem = m_pSequenceMgr->m_lstSequences.GetNext( pos );
		MUSIC_TIME mtStartTime = pSequenceItem->AbsTime();
		if ( (pSequenceItem->m_fSelected == fSelected) && (pSequenceItem->m_bByte1 <= nTopNote) &&
			(pSequenceItem->m_bByte1 >= nBottomNote) &&
			(mtStartTime + pSequenceItem->m_mtDuration > lStartTime) &&
			(mtStartTime < lEndTime) )
		{
			// Get position to draw at
			GetNoteRect( pSequenceItem, &rectNote );

			// Move the note so we draw it at the correct position
			rectNote.left -= lXOffset;
			rectNote.right -= lXOffset;

			// Check if the note is early or late
			if( ((mtStartTime >= m_mtLength) || (mtStartTime < 0)) && hbrushHatchVert )
			{
				// Yep - use a vertical hash
				::FillRect( hDC, &rectNote, hbrushHatchVert );
			}
			else
			{
				// Nope - just fill it
				::ExtTextOut( hDC, 0, 0, ETO_OPAQUE, &rectNote, NULL, 0, NULL);
			}

			const RECT* pRect = m_aNoteRectList[pSequenceItem->m_bByte1].GetFirst();
			while (pRect)
			{
				// compute the intersection of the notes
				CRect rect;
				rect.IntersectRect( pRect, &rectNote);

				// draw it
				if ((rect.left != rect.right) || (rect.top != rect.bottom))
				{
					// These rects have already been offset by -lXOffset
					::MoveToEx( hDC, rect.left, rect.bottom, NULL );
					::LineTo( hDC, rect.left, rect.top );
					::LineTo( hDC, rect.right, rect.top );
					::LineTo( hDC, rect.right, rect.bottom );

					rect.top++;
					rect.left++;
					if( (rect.top < rect.bottom) && (rect.left < rect.right) )
					{
						::SetBkColor( hDC, m_crOverlappingNoteColor );
						//::ExtTextOut( hDC, 0, 0, ETO_OPAQUE, &rect, NULL, 0, NULL);
						::FillRect( hDC, &rect, hbrushHatchOverlapping );
						::SetBkColor( hDC, crNoteColor );
					}
				}
				// Get the next overlapping note
				pRect = m_aNoteRectList[pSequenceItem->m_bByte1].GetNext();
			}
			m_aNoteRectList[pSequenceItem->m_bByte1].InsertRect( rectNote );
		}
		else if ( mtStartTime > lEndTime )
		{
			break;
		}
	}

	::SelectObject( hDC, hpenOld );
	if( hbrushHatchVert )
	{
		::DeleteObject( hbrushHatchVert );
	}
	if( hpenOverlappingLine )
	{
		::DeleteObject( hpenOverlappingLine );
	}
	if( hbrushHatchOverlapping )
	{
		::DeleteObject( hbrushHatchOverlapping );
	}

	// Reset the old background color
	::SetBkColor( hDC, crOldBkColor );
}

void CSequenceStrip::DrawHybridMaximizedAccidentals( HDC hDC, POSITION pos, long lStartTime, long lEndTime, long lXOffset, int nTopNote, int nBottomNote )
{
	// Create and select the font to draw the sharps and flats with
	HFONT hOldFont, hfont;
	hfont = GetAccidentalFont();
	hOldFont = static_cast<HFONT>(::SelectObject( hDC, hfont ));

	// Load the sharp/flat strings
	CString strSharp, strFlat, strNatural;
	strSharp.LoadString(IDS_SHARP_TEXT);
	strFlat.LoadString(IDS_FLAT_TEXT);
	strNatural.LoadString(IDS_NATURAL_TEXT);

	const long lTopAdjust = TOPADJUST;
	const long lBottomAdjust = BOTTOMADJUST;

	// Set up the text drawing modes
	int nOldBkMode = ::SetBkMode( hDC, TRANSPARENT );
	COLORREF crOldColor = ::SetTextColor( hDC, ::GetNearestColor(hDC, m_crAccidentalColor) );

	long lAccidentalWidth;
	m_pSequenceMgr->m_pTimeline->PositionToClocks( 20, &lAccidentalWidth );

	RECT rectNote;
	long lCurrentMeasure;

	// Determine the first measure we display
	m_pSequenceMgr->m_pTimeline->ClocksToMeasureBeat( m_pSequenceMgr->m_dwGroupBits, m_pSequenceMgr->m_dwIndex, lStartTime, &lCurrentMeasure, NULL );
	long lStartMeasureTime;
	lCurrentMeasure = max( lCurrentMeasure, 0 );
	m_pSequenceMgr->m_pTimeline->MeasureBeatToClocks( m_pSequenceMgr->m_dwGroupBits, m_pSequenceMgr->m_dwIndex, lCurrentMeasure, 0, &lStartMeasureTime );

	// Need to search for the first event in this measure
	pos = m_pSequenceMgr->m_lstSequences.GetHeadPosition();
	POSITION pos2 = NULL;
	while( pos )
	{
		pos2 = pos;
		const CSequenceItem *pSequenceItem = m_pSequenceMgr->m_lstSequences.GetNext( pos );
		if( pSequenceItem->AbsTime() >= lStartMeasureTime )
		{
			// Found first item to use
			break;
		}
		pos2 = NULL;
	}

	// If we found something
	if( pos2 )
	{
		// Reset pos to the index of the first item to use
		pos = pos2;
	}

	// Initialize the accidental array
	InitializeScaleAccidentals();

	while( pos )
	{
		const CSequenceItem *pSequenceItem = m_pSequenceMgr->m_lstSequences.GetNext( pos );
		MUSIC_TIME mtStartTime = max( 0, pSequenceItem->AbsTime());

		if ( mtStartTime > lEndTime )
		{
			break;
		}

		if ( (pSequenceItem->m_bByte1 <= nTopNote) &&
			(pSequenceItem->m_bByte1 >= nBottomNote) )
		{
			long lMeasure;
			m_pSequenceMgr->m_pTimeline->ClocksToMeasureBeat( m_pSequenceMgr->m_dwGroupBits, m_pSequenceMgr->m_dwIndex, mtStartTime, &lMeasure, NULL );
			if( lMeasure != lCurrentMeasure )
			{
				lCurrentMeasure = lMeasure;

				InitializeScaleAccidentals();
			}

			// 0 == NATURAL
			// 1 == SHARP
			//-1 == FLAT
			int iHybridPos, iAccidental;
			// FLATS
			if( m_pSequenceMgr->m_fDisplayingFlats )
			{
				iHybridPos = MIDIToHybridPos( pSequenceItem->m_bByte1, aChromToScaleFlats);
				iAccidental = aChromToFlatAccidentals[pSequenceItem->m_bByte1 % 12];
			}
			// SHARPS
			else
			{
				iHybridPos = MIDIToHybridPos( pSequenceItem->m_bByte1, aChromToScaleSharps);
				iAccidental = aChromToSharpAccidentals[pSequenceItem->m_bByte1 % 12];
			}

			// Check if we need to draw an accidental
			// BUGBUG: This will sometimes cause accidentals to be drawn that aren't actually visible.
			// If mtStartTime is just before lStartTime, and lStartTime is greater than a beat or so,
			// this check will succeed, even thought he accidental is not visible.
			// BUGBUG: If mtStartTime is just greater than lEndTime, this check will fail, even
			// though the accidental should be visible.  DavidY would like to have the accidental
			// visible in this case, though since it's easier not to I've left it as-is.
			if( (iAccidental != m_aiAccidentals[iHybridPos]) && 
				(mtStartTime + lAccidentalWidth > lStartTime)  &&
				(mtStartTime < lEndTime) )
			{
				// Get position to draw at
				GetHybridRect( &rectNote, iHybridPos, 127, mtStartTime, pSequenceItem->m_mtDuration );

				// Put the accidental before the note, if possible
				UINT uFormat;
				rectNote.right = rectNote.left - 2;
				rectNote.left -= (m_lMaxNoteHeight * 3) / 2;
				if( rectNote.left < 0 )
				{
					rectNote.right = (m_lMaxNoteHeight * 3) / 2 - 2;
					rectNote.left = 0;
					uFormat = DT_LEFT | DT_VCENTER | DT_SINGLELINE | DT_NOPREFIX;
				}
				else
				{
					uFormat = DT_RIGHT | DT_VCENTER | DT_SINGLELINE | DT_NOPREFIX;
				}

				if( m_pSequenceMgr->m_fHasNotationStation )
				{
					rectNote.top -= lTopAdjust;
					rectNote.bottom += lBottomAdjust;
				}

				// Move the note so we draw it at the correct position
				rectNote.left -= lXOffset;
				rectNote.right -= lXOffset;

				if( iAccidental )
				{
					// Draw iAccidental
					if( iAccidental > 0 )
					{
						// Draw sharp before note
						::DrawText( hDC, strSharp, 1, &rectNote, uFormat);
					}
					else
					{
						// Draw flat before note
						::DrawText( hDC, strFlat, 1, &rectNote, uFormat);
					}
				}
				else
				{
					// Draw natural before note
					::DrawText( hDC, strNatural, 1, &rectNote, uFormat);
				}
			}

			m_aiAccidentals[iHybridPos] = iAccidental;
		}
	}
	::SetTextColor( hDC, crOldColor );
	::SetBkMode( hDC, nOldBkMode );
	if( hfont )
	{
		::SelectObject( hDC, hOldFont );
		::DeleteObject( hfont );
	}
}

void CSequenceStrip::DrawHybridMaximizedNotes( HDC hDC, POSITION pos, long lStartTime, long lEndTime, long lXOffset, int nTopNote, int nBottomNote, BOOL fSelected )
{
	// Set the notes' color and save the old background color
	COLORREF crNoteColor;
	if( fSelected )
	{
		crNoteColor = ::GetNearestColor(hDC, m_crSelectedNoteColor);
	}
	else
	{
		crNoteColor = ::GetNearestColor(hDC, m_crUnselectedNoteColor);
	}
	COLORREF crOldBkColor = ::SetBkColor( hDC, crNoteColor );

	// Create the brush to draw the early notes with
	HBRUSH hbrushHatchVert = ::CreateHatchBrush( HS_VERTICAL, ::GetNearestColor(hDC, COLOR_EARLY_NOTES) ); 

	// Create pen for drawing the overlapping note lines
	HPEN hpenOverlappingLine = ::CreatePen( PS_DOT, 1, ::GetNearestColor(hDC, GetSysColor(COLOR_WINDOW)) );
	HPEN hpenOld = static_cast<HPEN> (::SelectObject( hDC, hpenOverlappingLine ));
	HBRUSH hbrushHatchOverlapping = ::CreateHatchBrush( HS_FDIAGONAL, ::GetNearestColor(hDC, COLOR_HATCH_OVERLAPPING) ); 

	RECT rectNote;
	while( pos )
	{
		const CSequenceItem *pSequenceItem = m_pSequenceMgr->m_lstSequences.GetNext( pos );
		MUSIC_TIME mtStartTime = pSequenceItem->AbsTime();
		if ( (pSequenceItem->m_fSelected == fSelected) && (pSequenceItem->m_bByte1 <= nTopNote) &&
			(pSequenceItem->m_bByte1 >= nBottomNote) && 
			(mtStartTime + pSequenceItem->m_mtDuration > lStartTime) &&
			(mtStartTime < lEndTime) )
		{
			int iHybridPos;
			// FLATS
			if( m_pSequenceMgr->m_fDisplayingFlats )
			{
				iHybridPos = MIDIToHybridPos( pSequenceItem->m_bByte1, aChromToScaleFlats);
			}
			// SHARPS
			else
			{
				iHybridPos = MIDIToHybridPos( pSequenceItem->m_bByte1, aChromToScaleSharps);
			}

			// Get position to draw at
			GetHybridRect( &rectNote, iHybridPos, pSequenceItem->m_bByte2, mtStartTime, pSequenceItem->m_mtDuration );

			// Move the note so we draw it at the correct position
			rectNote.left -= lXOffset;
			rectNote.right -= lXOffset;

			::ExtTextOut( hDC, 0, 0, ETO_OPAQUE, &rectNote, NULL, 0, NULL);

			if( (pSequenceItem->AbsTime() < 0) && hbrushHatchVert )
			{
				::FillRect( hDC, &rectNote, hbrushHatchVert );
			}

			const RECT* pRect = m_aNoteRectList[0].GetFirst();
			while (pRect)
			{
				// compute the intersection of the notes
				CRect rect;
				rect.IntersectRect( pRect, &rectNote);

				// draw it
				if ((rect.left != rect.right) || (rect.top != rect.bottom))
				{
					// These rects have already been offset by -lXOffset
					::MoveToEx( hDC, rect.left, rect.bottom, NULL );
					::LineTo( hDC, rect.left, rect.top );
					::LineTo( hDC, rect.right, rect.top );
					::LineTo( hDC, rect.right, rect.bottom );
					::LineTo( hDC, rect.left, rect.bottom );

					rect.top++;
					rect.left++;
					if( (rect.top < rect.bottom) && (rect.left < rect.right) )
					{
						::SetBkColor( hDC, m_crOverlappingNoteColor );
						//::ExtTextOut( hDC, 0, 0, ETO_OPAQUE, &rect, NULL, 0, NULL);
						::FillRect( hDC, &rect, hbrushHatchOverlapping );
						::SetBkColor( hDC, crNoteColor );
					}
				}
				// Get the next overlapping note
				pRect = m_aNoteRectList[0].GetNext();
			}
			m_aNoteRectList[0].InsertRect( rectNote );
		}
		else if ( mtStartTime > lEndTime )
		{
			break;
		}
	}

	::SelectObject( hDC, hpenOld );
	if( hbrushHatchVert )
	{
		::DeleteObject( hbrushHatchVert );
	}
	if( hpenOverlappingLine )
	{
		::DeleteObject( hpenOverlappingLine );
	}
	if( hbrushHatchOverlapping )
	{
		::DeleteObject( hbrushHatchOverlapping );
	}

	// Reset the old background color
	::SetBkColor( hDC, crOldBkColor );
}

/////////////////////////////////////////////////////////////////////////////
// CSequenceStrip::UpdateVScroll
//
// Updates the vertical scrollbar's position, range and page size.  This
// is called when the sequence strip is resized
//
void CSequenceStrip::UpdateVScroll()
{
	RECT rectVisible, rectAll;
	VARIANT var;
	var.vt = VT_BYREF;
	V_BYREF(&var) = &rectVisible;

	VERIFY(SUCCEEDED(m_pSequenceMgr->m_pTimeline->StripGetTimelineProperty((IDMUSProdStrip *)this, STP_FBAR_RECT, &var)));

	var.vt = VT_BYREF;
	V_BYREF(&var) = &rectAll;
	VERIFY(SUCCEEDED(m_pSequenceMgr->m_pTimeline->StripGetTimelineProperty((IDMUSProdStrip *)this, STP_ENTIRE_STRIP_RECT, &var)));

	RECT oldRect = m_rectVScroll;
	
	// move the vertical scroll bar to where it needs to go
	m_VScrollBar.GetClientRect(&m_rectVScroll);
	m_rectVScroll.left = rectVisible.right - m_rectVScroll.right - 2;
	m_rectVScroll.right = m_rectVScroll.left + m_rectVScroll.right;
	m_rectVScroll.bottom = rectVisible.bottom;
	m_rectVScroll.top = min( rectVisible.bottom, max( rectVisible.top, rectAll.top + m_BitmapZoomInDown.GetBitmapDimension().cy + m_BitmapZoomOutDown.GetBitmapDimension().cy ) );
	
	// Always update
	//if( m_rectVScroll != oldRect )
	{
		// move the scroll bar
		if( m_rectVScroll != oldRect )
		{
			m_VScrollBar.MoveWindow(&m_rectVScroll, TRUE);
		}

		// Get the strip's height
		VARIANT varHeight;
		VERIFY( SUCCEEDED( m_pSequenceMgr->m_pTimeline->StripGetTimelineProperty( (IDMUSProdStrip *)this, STP_HEIGHT, &varHeight ) ) );

		if ( (m_fHybridNotation && (V_I4(&varHeight) / m_lMaxNoteHeight >= 38)) ||
			 (!m_fHybridNotation && (V_I4(&varHeight) / m_lMaxNoteHeight >= 127)) )
		{
			// If we can view all 128 notes, disable the scrollbar
			m_VScrollBar.EnableScrollBar(ESB_DISABLE_BOTH);
		}
		else
		{
			// compute the scrollbar pagesize
			SCROLLINFO si;
			si.cbSize = sizeof(SCROLLINFO);

			// enable the scrollbar
			m_VScrollBar.EnableScrollBar(ESB_ENABLE_BOTH);

			// set the new page size
			si.fMask = SIF_PAGE | SIF_RANGE | SIF_POS;
			si.nPage = V_I4(&varHeight) / m_lMaxNoteHeight;

			// set the new position
			si.nPos = m_lVScroll / m_lMaxNoteHeight;

			if( m_fHybridNotation )
			{
				si.nMin = 0;
				si.nMax = 37;
			}
			else
			{
				si.nMin = 0;
				si.nMax = 127;
			}

			m_VScrollBar.SetScrollInfo(&si, TRUE);
		}
	}
}

/////////////////////////////////////////////////////////////////////////////
// CSequenceStrip::SetVScroll
//
// Set a new vertical scroll value for the sequence strip.  The scrollbar and
// strip are updated accordingly.
//
void CSequenceStrip::SetVScroll(long lNewValue)
{
	// Set the new scroll position
	long lOldScroll = m_lVScroll;
	m_lVScroll = lNewValue;

	// Limit it to the maximum and minimum values
	LimitVScroll();

	// If the scroll position didn't change, return
	if (lOldScroll == m_lVScroll)
	{
		return;
	}

	// Otherwise, pospone drawing operations - this avoids flickering
	// in the strip's title and maximize/minimize button
	HWND hwnd = GetTimelineHWnd();
	if( hwnd )
	{
		::LockWindowUpdate( hwnd );
	}

	// Tell the timeline the new VScroll position
	VARIANT var;
	var.vt = VT_I4;
	V_I4(&var) = m_lVScroll;
	m_pSequenceMgr->m_pTimeline->StripSetTimelineProperty((IDMUSProdStrip*)this, STP_VERTICAL_SCROLL, var);

	// restore drawing operations (and redraw the strip)
	if( hwnd )
	{
		::LockWindowUpdate( NULL );
	}

	// Tell the new position to the scroll bar
	m_VScrollBar.SetScrollPos(m_lVScroll / m_lMaxNoteHeight);
}

/////////////////////////////////////////////////////////////////////////////
// CSequenceStrip::LimitVScroll
//
// Limits the Y scroll value to be within acceptable range.
//
void CSequenceStrip::LimitVScroll() 
{
	VARIANT var;
	if( SUCCEEDED(m_pSequenceMgr->m_pTimeline->StripGetTimelineProperty( (IDMUSProdStrip *)this, STP_HEIGHT, &var )) )
	{
		long lMax;
		if( m_fHybridNotation )
		{
			lMax = max( 0, 38 - V_I4(&var) / m_lMaxNoteHeight);
		}
		else
		{
			lMax = max( 0, 128 - V_I4(&var) / m_lMaxNoteHeight);
		}

		if (m_lVScroll < 0)
		{
			m_lVScroll = 0;
		}
		else if (m_lVScroll > lMax * m_lMaxNoteHeight)
		{
			m_lVScroll = lMax * m_lMaxNoteHeight;
		}
	}
}

/////////////////////////////////////////////////////////////////////////////
// CSequenceStrip::OnVScroll
//
// Called by the vertical scrollbar when the user scrolls.
//
void CSequenceStrip::OnVScroll(UINT nSBCode, UINT nPos)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	long lTestPos, lNewPos;
	lTestPos = m_lVScroll / m_lMaxNoteHeight;

	VARIANT var;
	VERIFY( SUCCEEDED( m_pSequenceMgr->m_pTimeline->StripGetTimelineProperty( (IDMUSProdStrip *)this, STP_HEIGHT, &var ) ) );

	switch(nSBCode)
	{
	case SB_TOP:
		lNewPos = 0;
		break;
	case SB_LINEDOWN:
		lNewPos = lTestPos + 1;
		break;
	case SB_LINEUP:
		lNewPos = lTestPos - 1;
		break;
	case SB_PAGEDOWN:
		lNewPos = lTestPos + (V_I4(&var) / m_lMaxNoteHeight);
		break;
	case SB_PAGEUP:
		lNewPos = lTestPos - (V_I4(&var) / m_lMaxNoteHeight);
		break;
	case SB_THUMBPOSITION:
	case SB_THUMBTRACK:
		lNewPos = nPos;
		break;
	case SB_BOTTOM:
		if( m_fHybridNotation )
		{
			lNewPos = 38 - (V_I4(&var) / m_lMaxNoteHeight);
		}
		else
		{
			lNewPos = 128 - (V_I4(&var) / m_lMaxNoteHeight);
		}
		break;
	case SB_ENDSCROLL:
	default:
		return;
	}

	long lNewVertScroll;
	lNewVertScroll = lNewPos * (m_lMaxNoteHeight);
	if( m_fHybridNotation )
	{
		if ( lNewVertScroll / m_lMaxNoteHeight > 37)
		{
			lNewVertScroll = m_lMaxNoteHeight * 37;
		}
	}
	else
	{
		if ( lNewVertScroll / m_lMaxNoteHeight > 127)
		{
			lNewVertScroll = m_lMaxNoteHeight * 127;
		}
	}
	if ( lNewVertScroll < 0)
	{
		lNewVertScroll = 0;
	}
	if (lNewVertScroll != m_lVScroll)
	{
		SetVScroll( lNewVertScroll );
	}
}

/////////////////////////////////////////////////////////////////////////////
// CSequenceStrip::OnVScroll
//
// Windows message handler for vertical scrolling.
//
HRESULT CSequenceStrip::OnVScroll( void )
{
	// update position of scrollbar
	UpdateVScroll();
	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CSequenceStrip::OnSize
//
// Message handler for strip resizing.
//
HRESULT CSequenceStrip::OnSize( void )
{
	// make sure current scroll position is within range (since size was changed)
	long lMaxVertScroll;
	if( m_fHybridNotation )
	{
		lMaxVertScroll = 38 * m_lMaxNoteHeight;
	}
	else
	{
		lMaxVertScroll = 128 * m_lMaxNoteHeight;
	}

	VARIANT var;
	if( SUCCEEDED(m_pSequenceMgr->m_pTimeline->StripGetTimelineProperty( (IDMUSProdStrip *)this, STP_HEIGHT, &var )) )
	{
		lMaxVertScroll -= V_I4(&var);
	}

	if ( m_lVScroll > lMaxVertScroll )
	{
		SetVScroll( lMaxVertScroll );
	}

	// update position of scrollbar
	UpdateVScroll();

	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CSequenceStrip::OnChar
//
// Message handler for strip resizing.
//
HRESULT CSequenceStrip::OnChar(WPARAM wParam)
{
	if( wParam == 0x11 ) // Ctrl+Q
	{
		return DoQuantize();
	}

	if( wParam == 0x0c ) // Ctrl+L
	{
		return DoVelocity();
	}

	// The following code is very similar to OnWMMessage()'s handler for ID_EDIT_VIEW_HYBRID, etc.
	if( m_svView == SV_NORMAL )
	{
		if( (wParam == 'h') || (wParam == 'H') )
		{
			// This handles notifying the other strips, and adding an Undo state
			ChangeNotationType( !m_fHybridNotation );
		}
		else if( (wParam == 'a') || (wParam == 'A') )
		{
			ChangeZoom(	m_dblVerticalZoom + 0.01);
			// TODO: Add Undo?
			/*
			// Let the object know about the changes
			m_nLastEdit = nLastEdit;
			m_pSequenceMgr->m_fUpdateDirectMusic = FALSE;
			m_pSequenceMgr->OnDataChanged(); 
			*/
		}
		else if( (wParam == 'z') || (wParam == 'Z') )
		{
			ChangeZoom(	m_dblVerticalZoom - 0.01);
			// TODO: Add Undo?
			/*
			// Let the object know about the changes
			m_nLastEdit = nLastEdit;
			m_pSequenceMgr->m_fUpdateDirectMusic = FALSE;
			m_pSequenceMgr->OnDataChanged(); 
			*/
		}
	}

	return S_OK;
}

HRESULT CSequenceStrip::OnSetCursor( long lXPos, long lYPos)
{
	if (m_svView == SV_MINIMIZED)
	{
		m_hCursor = GetArrowCursor();
		return S_OK;
	}

	SetMouseMode( lXPos, lYPos );
	switch(m_MouseMode)
	{
	case SEQ_MM_NORMAL:
		m_hCursor = GetArrowCursor();
		break;
	case SEQ_MM_ACTIVEMOVE:
	case SEQ_MM_MOVE:
		m_hCursor = GetAllCursor();
		break;
	case SEQ_MM_ACTIVERESIZE_START:
	case SEQ_MM_RESIZE_START:
		m_hCursor = GetResizeStartCursor();
		break;
	case SEQ_MM_ACTIVERESIZE_END:
	case SEQ_MM_RESIZE_END:
		m_hCursor = GetResizeEndCursor();
		break;
	case SEQ_MM_ACTIVERESIZE_VELOCITY:
	case SEQ_MM_RESIZE_VELOCITY:
		m_hCursor = GetNSCursor();
		break;
	default:
		break;
	}
	return S_OK;
}

IDMUSProdBandEdit8a *GetBandEditInterface( IDMUSProdTimeline *pTimeline, DWORD dwGroupBits, DWORD dwPChannel )
{
	IDMUSProdBandEdit8a *pIBandEdit = NULL;
	MUSIC_TIME mtTime;
	if( SUCCEEDED( pTimeline->GetMarkerTime( MARKER_CURRENTTIME, TIMETYPE_CLOCKS, &mtTime ) ) )
	{
		DMUSPROD_INTERFACEFORPCHANNEL dmpInterfaceForPChannel;
		dmpInterfaceForPChannel.dwPChannel = dwPChannel;
		dmpInterfaceForPChannel.punkInterface = NULL;
		if( SUCCEEDED ( pTimeline->GetParam( GUID_BandInterfaceForPChannel, dwGroupBits, 0, 
															   mtTime, NULL, (void *)&dmpInterfaceForPChannel ) ) )
		{
			if( FAILED ( dmpInterfaceForPChannel.punkInterface->QueryInterface( IID_IDMUSProdBandEdit8a, (void **)&pIBandEdit ) ) )
			{
				pIBandEdit = NULL;
			}

			dmpInterfaceForPChannel.punkInterface->Release();
		}
	}

	return pIBandEdit;
}

IDMUSProdBandMgrEdit *GetBandMgrEditInterface( IDMUSProdTimeline *pTimeline, DWORD dwGroupBits, DWORD dwPChannel )
{
	// Initialize the interface to NULL
	IDMUSProdBandMgrEdit *pIDMUSProdBandMgrEdit = NULL;

	// Get the cursor position
	MUSIC_TIME mtTime;
	if( SUCCEEDED( pTimeline->GetMarkerTime( MARKER_CURRENTTIME, TIMETYPE_CLOCKS, &mtTime ) ) )
	{
		// Try and find the band manager that has a band that has an instrument for this PChannel
		DMUSPROD_INTERFACEFORPCHANNEL dmpInterfaceForPChannel;
		dmpInterfaceForPChannel.dwPChannel = dwPChannel;
		dmpInterfaceForPChannel.punkInterface = NULL;
		if( SUCCEEDED ( pTimeline->GetParam( GUID_BandMgrEditForPChannel, dwGroupBits, 0, 
															   mtTime, NULL, (void *)&dmpInterfaceForPChannel ) ) )
		{
			// Ask for the edit interface
			if( FAILED ( dmpInterfaceForPChannel.punkInterface->QueryInterface( IID_IDMUSProdBandMgrEdit, (void **)&pIDMUSProdBandMgrEdit ) ) )
			{
				pIDMUSProdBandMgrEdit = NULL;
			}

			dmpInterfaceForPChannel.punkInterface->Release();
		}

		// If we didn't find a band manager
		if( pIDMUSProdBandMgrEdit == NULL )
		{
			// Just look for the first band manager
			IDMUSProdStripMgr *pStripMgr;
			if( SUCCEEDED ( pTimeline->GetStripMgr( GUID_BandMgrEditForPChannel, dwGroupBits, 0, &pStripMgr ) ) )
			{
				// Ask for the edit interface
				if( FAILED ( pStripMgr->QueryInterface( IID_IDMUSProdBandMgrEdit, (void **)&pIDMUSProdBandMgrEdit ) ) )
				{
					pIDMUSProdBandMgrEdit = NULL;
				}

				pStripMgr->Release();
			}
		}
	}

	return pIDMUSProdBandMgrEdit;
}

/////////////////////////////////////////////////////////////////////////////
// CSequenceStrip::DrawFunctionBar

void CSequenceStrip::DrawFunctionBar( HDC hDC, STRIPVIEW sv )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	ASSERT( hDC );

	if( sv == SV_FUNCTIONBAR_NORMAL )
	{
		// get function bar rect
		RECT rectFBar;
		VARIANT var;
		var.vt = VT_BYREF;
		V_BYREF(&var) = &rectFBar;
		if (FAILED(m_pSequenceMgr->m_pTimeline->StripGetTimelineProperty((IDMUSProdStrip *)this, STP_FBAR_CLIENT_RECT, &var)))
		{
			return;
		}

		// Draw Zoom buttons
		// Save DC
		RECT rectExcludeClip = { 0, 0, 0, 0 };
		int iSavedDC = ::SaveDC( hDC );
		{
			// fix the clipping region
			RECT rectClip;
			::GetClipBox( hDC, &rectClip );

			POINT point;
			::GetWindowOrgEx( hDC, &point );

			rectClip.left -= point.x;
			rectClip.right -= point.x;
			rectClip.top = -point.y;
			rectClip.bottom -= point.y;

			HRGN hRgn;
			hRgn = ::CreateRectRgnIndirect( &rectClip );
			if( !hRgn )
			{
				return;
			}
			::SelectClipRgn( hDC, hRgn );
			::DeleteObject( hRgn );

			if( m_fZoomInPressed )
			{
				::DrawState( hDC, NULL, NULL, reinterpret_cast<LPARAM>( m_BitmapZoomInDown.GetSafeHandle() ), NULL,
					rectFBar.right - m_BitmapZoomInDown.GetBitmapDimension().cx - 2, m_lVScroll,
					m_BitmapZoomInDown.GetBitmapDimension().cx, m_BitmapZoomInDown.GetBitmapDimension().cy, DST_BITMAP | DSS_NORMAL );
			}
			else
			{
				::DrawState( hDC, NULL, NULL, reinterpret_cast<LPARAM>( m_BitmapZoomInUp.GetSafeHandle() ), NULL,
					rectFBar.right - m_BitmapZoomInUp.GetBitmapDimension().cx - 2, m_lVScroll,
					m_BitmapZoomInUp.GetBitmapDimension().cx, m_BitmapZoomInUp.GetBitmapDimension().cy, DST_BITMAP | DSS_NORMAL );
			}
			if( m_fZoomOutPressed )
			{
				::DrawState( hDC, NULL, NULL, reinterpret_cast<LPARAM>( m_BitmapZoomOutDown.GetSafeHandle() ), NULL,
					rectFBar.right - m_BitmapZoomOutDown.GetBitmapDimension().cx - 2, m_BitmapZoomInUp.GetBitmapDimension().cy + m_lVScroll,
					m_BitmapZoomOutDown.GetBitmapDimension().cx, m_BitmapZoomOutDown.GetBitmapDimension().cy, DST_BITMAP | DSS_NORMAL );
			}
			else
			{
				::DrawState( hDC, NULL, NULL, reinterpret_cast<LPARAM>( m_BitmapZoomOutUp.GetSafeHandle() ), NULL,
					rectFBar.right - m_BitmapZoomOutUp.GetBitmapDimension().cx - 2, m_BitmapZoomInUp.GetBitmapDimension().cy + m_lVScroll,
					m_BitmapZoomOutUp.GetBitmapDimension().cx, m_BitmapZoomOutUp.GetBitmapDimension().cy, DST_BITMAP | DSS_NORMAL );
			}

			// Set up the rect to exclude
			rectExcludeClip.right = rectFBar.right - 2;
			rectExcludeClip.left = rectExcludeClip.right - m_BitmapZoomInDown.GetBitmapDimension().cx;
			rectExcludeClip.top = m_lVScroll;
			rectExcludeClip.bottom = m_lVScroll + m_BitmapZoomInDown.GetBitmapDimension().cy + m_BitmapZoomOutDown.GetBitmapDimension().cy;
		}
		// Restore the DC
		::RestoreDC( hDC, iSavedDC );

		// Exclude the zooom buttons
		::ExcludeClipRect( hDC, rectExcludeClip.left, rectExcludeClip.top, rectExcludeClip.right, rectExcludeClip.bottom );

		// Get the clipping rectangle
		RECT rectClip, rectNote;
		::GetClipBox( hDC, &rectClip );

		// Pointer to interface from which DLS region text can be obtained
		IDMUSProdBandEdit8a* pIBandEdit = NULL;

		// If the instrument button is visible
		VARIANT varFNHeight;
		m_pSequenceMgr->m_pTimeline->GetTimelineProperty( TP_FUNCTIONNAME_HEIGHT, &varFNHeight );
		if( rectClip.bottom > m_lVScroll + V_I4(&varFNHeight)
		&&	rectClip.top < m_lVScroll + V_I4(&varFNHeight) + INSTRUMENT_BUTTON_HEIGHT )
		{
			// Try to get the band edit interface
			if( !pIBandEdit )
			{
				pIBandEdit = GetBandEditInterface( m_pSequenceMgr->m_pTimeline, m_pSequenceMgr->m_dwGroupBits, m_pSequenceMgr->m_dwPChannel );
			}

			// Initialize the last (displayed) patch to an invalid value
			m_dwLastPatch = INVALID_PATCH;

			// Get the instrument's name
			CString strInstrumentName;
			bool fNoInstrument = true;
			strInstrumentName.LoadString( IDS_NOINSTRUMENT );
			if( pIBandEdit )
			{
				BSTR bstrInstrumentName;
				if( SUCCEEDED( pIBandEdit->GetInstNameForPChannel( m_pSequenceMgr->m_dwPChannel, &bstrInstrumentName ) ) )
				{
					strInstrumentName = bstrInstrumentName;
					::SysFreeString( bstrInstrumentName );

					fNoInstrument = false;
				}

				pIBandEdit->GetPatchForPChannel( m_pSequenceMgr->m_dwPChannel, &m_dwLastPatch );
			}

			// Compute the rectangle for the button
			RECT rectButton;
			rectButton.left = 0;
			rectButton.right = (rectFBar.right - rectFBar.left) - m_rectVScroll.Width() - NEWBAND_BUTTON_WIDTH - 1;
			rectButton.top = m_lVScroll + V_I4(&varFNHeight);
			rectButton.bottom = rectButton.top + INSTRUMENT_BUTTON_HEIGHT;

			// Compute the rectangle for the text
			RECT rectText;
			rectText.top = rectButton.top + ::GetSystemMetrics( SM_CYEDGE );
			rectText.bottom = rectButton.bottom - ::GetSystemMetrics( SM_CYEDGE );
			rectText.left = rectButton.left + ::GetSystemMetrics( SM_CXEDGE );
			rectText.right = rectButton.right - ::GetSystemMetrics( SM_CXEDGE );

			// If no instrument, modify the text to include ellipses (if necessary)
			if( fNoInstrument )
			{
				::DrawText( hDC, strInstrumentName, -1, &rectText, DT_LEFT | DT_END_ELLIPSIS | DT_NOPREFIX | DT_SINGLELINE | DT_VCENTER | DT_MODIFYSTRING );
			}

			// Set the enable/disable flag for the instrument button
			m_fInstrumentEnabled = !fNoInstrument;

			// Draw the instrument button
			::DrawFrameControl( hDC, &rectButton, DFC_BUTTON, m_fInstrumentPressed ? DFCS_PUSHED | DFCS_BUTTONPUSH : DFCS_BUTTONPUSH );

			// Compute if we need to move the text (because the button is pressed)
			if( m_fInstrumentPressed )
			{
				rectText.left++;
				rectText.top++;
			}

			int nOldBkMode = ::SetBkMode( hDC, TRANSPARENT );
			if( fNoInstrument )
			{
				// If no instrument, draw the text as embossed (disabled)
				::DrawState( hDC, NULL, NULL, reinterpret_cast<LPARAM>((const char *)strInstrumentName), NULL, rectText.left, rectText.top, rectText.right - rectText.left, rectText.bottom - rectText.top, DST_TEXT | DSS_DISABLED );
			}
			else
			{
				// Have an instrument, draw normally
				::DrawText( hDC, strInstrumentName, -1, &rectText, DT_LEFT | DT_END_ELLIPSIS | DT_NOPREFIX | DT_SINGLELINE | DT_VCENTER );
			}
			::SetBkMode( hDC, nOldBkMode );

			// Draw the new band button
			rectButton.left = rectButton.right;
			rectButton.right = rectButton.left + NEWBAND_BUTTON_WIDTH - 1;
			::DrawFrameControl( hDC, &rectButton, DFC_BUTTON, m_fNewBandPressed ? DFCS_PUSHED | DFCS_BUTTONPUSH : DFCS_BUTTONPUSH );

			// Compute if we need to move the bitmap (because the button is pressed)
			int nShiftAmount = m_fNewBandPressed ? 1 : 0;

			// Draw the band bitmap
			::DrawState( hDC, NULL, NULL, reinterpret_cast<LPARAM>( m_BitmapNewBand.GetSafeHandle() ), NULL,
				rectButton.left + GetSystemMetrics( SM_CXEDGE ) + nShiftAmount, rectButton.top + GetSystemMetrics( SM_CYEDGE ) + nShiftAmount,
				m_BitmapNewBand.GetBitmapDimension().cx, m_BitmapNewBand.GetBitmapDimension().cy, DST_BITMAP | DSS_NORMAL );

			// Exclude the instrument buttons
			rectButton.left = 0;
			rectButton.right += 3;
			::ExcludeClipRect( hDC, rectButton.left, rectButton.top, rectButton.right, rectButton.bottom );
		}

		LOGFONT lf;
		memset( &lf, 0 , sizeof(LOGFONT));
		lf.lfHeight = long(MAX_NOTE_HEIGHT * 1.4 * m_dblVerticalZoom);
		//lf.lfWidth = 0;
		//lf.lfEscapement = 0;
		//lf.lfOrientation = 0;
		lf.lfWeight = FW_NORMAL;
		//lf.lfItalic = FALSE;
		//lf.lfUnderline = FALSE;
		//lf.lfStrikeOut = FALSE;
		//lf.lfCharSet = ANSI_CHARSET;
		//lf.lfOutPrecision = OUT_DEFAULT_PRECIS;
		//lf.lfClipPrecision = CLIP_DEFAULT_PRECIS;
		//lf.lfQuality = DEFAULT_QUALITY;
		lf.lfPitchAndFamily = DEFAULT_PITCH | FF_MODERN;
		//lf.lfFaceName = NULL;

		HFONT hfont;
		hfont = ::CreateFontIndirect( &lf );
		if ( !hfont )
		{
			return;
		}

		int nOldBkMode = ::SetBkMode( hDC, TRANSPARENT );
		HFONT hOldFont = static_cast<HFONT>(::SelectObject( hDC, hfont ));

		if( m_fHybridNotation )
		{
			COLORREF oldColor = ::SetTextColor( hDC, PIANOROLL_BLACKKEY_COLOR );

			int nTopNote, nBottomNote;
			nTopNote = 38 - (rectClip.top / m_lMaxNoteHeight);
			nBottomNote = 38 - (rectClip.bottom / m_lMaxNoteHeight);

			nBottomNote = max( nBottomNote, 13 );
			nTopNote = min( nTopNote, 23 );

			DrawHybridLines( hDC, rectClip, nBottomNote, nTopNote );

			if( m_pSequenceMgr->m_fHasNotationStation )
			{
				// Create the font to draw the treble and bass clefs with
				LOGFONT lf;
				memset( &lf, 0 , sizeof(LOGFONT));
				lf.lfHeight = - long(NOTATION_FONT_CLEF_ZOOMFACTOR * MAX_NOTE_HEIGHT * m_dblVerticalZoom);
				lf.lfCharSet = SYMBOL_CHARSET;
				lf.lfPitchAndFamily = DEFAULT_PITCH;

				CString strFontName;
				strFontName.LoadString(IDS_NOTATION_FONT);
				_tcsncpy( lf.lfFaceName, strFontName, LF_FACESIZE );
				lf.lfWeight = FW_NORMAL;
				//lf.lfWidth = 0;
				//lf.lfEscapement = 0;
				//lf.lfOrientation = 0;
				//lf.lfItalic = FALSE;
				//lf.lfUnderline = FALSE;
				//lf.lfStrikeOut = FALSE;
				//lf.lfOutPrecision = OUT_DEFAULT_PRECIS;
				//lf.lfClipPrecision = CLIP_DEFAULT_PRECIS;
				//lf.lfQuality = DEFAULT_QUALITY;
				
				// Create and select the font
				HFONT hfontMusic;
				hfontMusic = ::CreateFontIndirect( &lf );
				if( hfontMusic )
				{
					HFONT hNewOldFont = static_cast<HFONT>(::SelectObject( hDC, hfontMusic ));

					// get function bar rect
					RECT rectLocalFBar = rectFBar;
					{
						// Draw the treble clef
						rectLocalFBar.top = TREBLE_TOP * m_lMaxNoteHeight;
						rectLocalFBar.bottom = TREBLE_BOTTOM * m_lMaxNoteHeight;

						// Load the treble clef string
						CString strClef;
						strClef.LoadString(IDS_TREBLE_CLEF);

						::DrawText( hDC, strClef, -1, &rectLocalFBar, DT_LEFT | DT_VCENTER | DT_SINGLELINE | DT_NOPREFIX );

						// Draw the bass clef
						rectLocalFBar.top = BASS_TOP * m_lMaxNoteHeight;
						rectLocalFBar.bottom = BASS_BOTTOM * m_lMaxNoteHeight;

						// Load the bass clef string
						strClef.LoadString(IDS_BASS_CLEF);

						::DrawText( hDC, strClef, -1, &rectLocalFBar, DT_LEFT | DT_VCENTER | DT_SINGLELINE | DT_NOPREFIX );
					}

					::SelectObject( hDC, hNewOldFont );
					::DeleteObject( hfontMusic );
				}

				// Create the font to draw the sharps and flats with
				hfontMusic = GetAccidentalFont();
				if( hfontMusic )
				{
					HFONT hNewOldFont = static_cast<HFONT>(::SelectObject( hDC, hfontMusic ));

					{
						// Load sharp or flat text
						CString strSymbol;
						if( m_pSequenceMgr->m_fDisplayingFlats )
						{
							strSymbol.LoadString(IDS_FLAT_TEXT);
						}
						else
						{
							strSymbol.LoadString(IDS_SHARP_TEXT);
						}

						const long lTopAdjust = TOPADJUST;
						const long lBottomAdjust = BOTTOMADJUST;

						// Draw treble clef sharps/flats
						for( int i = 0; i < m_pSequenceMgr->m_nNumAccidentals; i++ )
						{
							long lXSymbolOffset = (m_lMaxNoteHeight * (10 + i) ) / 3;
							if( m_pSequenceMgr->m_fDisplayingFlats )
							{
								DrawSymbol( hDC, strSymbol, aTrebleFlatKeyToPosx2[i] + 1, lXSymbolOffset, lTopAdjust, lBottomAdjust );
								DrawSymbol( hDC, strSymbol, aBassFlatKeyToPosx2[i] + 1, lXSymbolOffset, lTopAdjust, lBottomAdjust );
							}
							else
							{
								DrawSymbol( hDC, strSymbol, aTrebleSharpKeyToPosx2[i] + 1, lXSymbolOffset, lTopAdjust, lBottomAdjust );
								DrawSymbol( hDC, strSymbol, aBassSharpKeyToPosx2[i] + 1, lXSymbolOffset, lTopAdjust, lBottomAdjust );
							}
						}
					}

					::SelectObject( hDC, hNewOldFont );
					::DeleteObject( hfontMusic );
				}
			}
			else
			{
				rectNote.left = 0;
				rectNote.right = rectClip.right;

				char strTxt[2];
				ZeroMemory( strTxt, sizeof( char ) * 2 );

				int nVertPos = (38 - nBottomNote) * m_lMaxNoteHeight;
				for( int nValue = nBottomNote; nValue < nTopNote; nValue++ )
				{
					// Skip the 'B' and 'D' next to middle C
					if( nValue == 18 || nValue == 17 )
					{
						nVertPos -= m_lMaxNoteHeight;
						continue;
					}

					rectNote.bottom = nVertPos;
					rectNote.top = nVertPos - m_lMaxNoteHeight;

					strTxt[0] = ScaleToName[ nValue - 13 ];

					::DrawText( hDC, strTxt, -1, &rectNote,	DT_LEFT | DT_VCENTER | DT_SINGLELINE | DT_NOPREFIX );

					nVertPos -= m_lMaxNoteHeight;
				}
			}
			::SetTextColor( hDC, oldColor );
		}
		else
		{
			short	value;
			long	lTop;

			::SetBkColor( hDC, ::GetNearestColor( hDC, GetSysColor(COLOR_WINDOW)) );
			::ExtTextOut( hDC, 0, 0, ETO_OPAQUE, &rectClip, NULL, 0, NULL);
			
			HPEN hpenNoteLine;
			hpenNoteLine = ::CreatePen( PS_SOLID, 1, RGB(0,0,0) );
			if( !hpenNoteLine )
			{
				::SelectObject( hDC, hOldFont );
				::DeleteObject( hfont );
				return;
			}

			// Get IDMUSProdBandEdit interface from which DLS region name can be obtained
			CString strRegionName;
			BSTR bstrRegionName;
			if( !pIBandEdit )
			{
				pIBandEdit = GetBandEditInterface( m_pSequenceMgr->m_pTimeline, m_pSequenceMgr->m_dwGroupBits, m_pSequenceMgr->m_dwPChannel );
			}

			HPEN hpenOld = static_cast<HPEN>(::SelectObject( hDC, hpenNoteLine ));
			// TODO: Optimize this to only draw the visible notes (get top and bottom notes)
			// The continue and break statements can then be taken out
			// Also optimize in CPianoRollStrip.cpp
			for( value = 0; value < 128; value++ )
			{
				lTop = ( 127 - value ) * m_lMaxNoteHeight;
				if( lTop > rectClip.bottom )
				{
					continue;
				}
				rectNote.top = lTop;
				rectNote.bottom = lTop + m_lMaxNoteHeight - HORIZ_LINE_HEIGHT;
				if( rectNote.bottom < rectClip.top )
				{
					break;
				}
				rectNote.left = rectClip.left;
				rectNote.right = rectClip.right;
				if( PianoKeyColor[ value % 12 ] == BLACK )
				{
					::SetBkColor( hDC, ::GetNearestColor( hDC, PIANOROLL_BLACKKEY_COLOR) );
				}
				else
				{
					::SetBkColor( hDC, ::GetNearestColor( hDC, PIANOROLL_WHITEKEY_COLOR) );
				}
				::ExtTextOut( hDC, 0, 0, ETO_OPAQUE, &rectNote, NULL, 0, NULL);

				::MoveToEx( hDC, rectNote.left, rectNote.bottom, NULL );
				::LineTo( hDC, rectNote.right, rectNote.bottom );


				// Get DLS Region name
				strRegionName.Empty();
				if( pIBandEdit )
				{
					if( SUCCEEDED ( pIBandEdit->GetDLSRegionName( m_pSequenceMgr->m_dwPChannel, (BYTE)value, &bstrRegionName ) ) )
					{
						strRegionName = bstrRegionName;
						::SysFreeString( bstrRegionName );
					}
				}

				const COLORREF oldColor = ::GetTextColor( hDC );

				if( strRegionName.IsEmpty() == FALSE )
				{
					// Draw DLS region name
					rectNote.left = 0;
					if( value % 12 == 0 )
					{
						CString cstrTxt;
						cstrTxt.Format( "C%d: ", value/12 );
						::SetTextColor( hDC, PIANOROLL_RED_COLOR );
						::DrawText( hDC, cstrTxt, -1, &rectNote,
							DT_LEFT | DT_VCENTER | DT_SINGLELINE | DT_NOPREFIX );

						SIZE size;
						::GetTextExtentPoint( hDC, cstrTxt, cstrTxt.GetLength(), &size );
						rectNote.left = size.cx;
					}

					::SetTextColor( hDC, (PianoKeyColor[ value % 12 ] == BLACK) ? PIANOROLL_WHITEKEY_COLOR : PIANOROLL_BLACKKEY_COLOR );

					::DrawText( hDC, strRegionName, -1, &rectNote,
						DT_LEFT | DT_VCENTER | DT_SINGLELINE | DT_NOPREFIX );
				}
				else if ( (m_pSequenceMgr->m_dwPChannel < DMUS_PCHANNEL_BROADCAST_GROUPS)
					 &&	  ((m_pSequenceMgr->m_dwPChannel & 0xF) == 9)
					 &&	  (value >=27) && (value <= 87) )
				{
					// Draw GM drum kit names
					::SetTextColor( hDC, (PianoKeyColor[ value % 12 ] == BLACK) ? PIANOROLL_WHITEKEY_COLOR : PIANOROLL_BLACKKEY_COLOR );

					rectNote.left = 0;
					::DrawText( hDC, acDrums[value-27], -1, &rectNote,
						DT_LEFT | DT_VCENTER | DT_SINGLELINE | DT_NOPREFIX );
				}
				else if (value % 12 == 0)
				{
					::SetTextColor( hDC, PIANOROLL_BLACKKEY_COLOR );

					CString cstrTxt;
					//cstrTxt.Format( "%s%d", CString(MidiValueToName).Mid((value % 12)*5, 5) , value/12 );
					cstrTxt.Format( "C %d", value/12 );
					rectNote.left = 0;
					::DrawText( hDC, cstrTxt, -1, &rectNote,
						DT_LEFT | DT_VCENTER | DT_SINGLELINE | DT_NOPREFIX );
				}

				::SetTextColor( hDC, oldColor );
			}
			::SelectObject( hDC, hpenOld );
			::DeleteObject( hpenNoteLine );

			if (rectClip.top <= m_lVScroll)
			{
				HPEN	hpenTopLine = ::CreatePen( PS_SOLID, 1, RGB(0,0,0) );
				if( hpenTopLine )
				{
					HPEN hpenOld = static_cast<HPEN>(::SelectObject( hDC, hpenTopLine ));
					::MoveToEx( hDC, rectClip.left, m_lVScroll, NULL );
					::LineTo( hDC, rectClip.right, m_lVScroll );
					::SelectObject( hDC, hpenOld );
					::DeleteObject( hpenTopLine );
				}
			}
		}

		if( pIBandEdit )
		{
			pIBandEdit->Release();
		}

		::SetBkMode( hDC, nOldBkMode );
		::SelectObject( hDC, hOldFont );
		::DeleteObject( hfont );
	}
}

void CSequenceStrip::DrawDarkHybridLines( HDC hDC, const RECT &rectClip, int nOldBottomNote, int nOldTopNote )
{
	DrawHybridLinesHelper( hDC, rectClip, nOldBottomNote, nOldTopNote, RGB(230,230,230), m_lMaxNoteHeight, true );
}

void CSequenceStrip::DrawHybridLines( HDC hDC, const RECT &rectClip, int nOldBottomNote, int nOldTopNote )
{
	DrawHybridLinesHelper( hDC, rectClip, nOldBottomNote, nOldTopNote, RGB(255,255,255), m_lMaxNoteHeight, m_iHaveFocus != 1 );
}

void CSequenceStrip::DrawDarkHorizontalLines( HDC hDC, const RECT &rectClip, int nBottomNote, int nTopNote )
{
	DrawHorizontalLinesHelper( hDC, rectClip, nBottomNote, nTopNote, RGB(230, 230, 230), RGB(200, 200, 200), m_lMaxNoteHeight, true );
}

void CSequenceStrip::DrawHorizontalLines( HDC hDC, const RECT &rectClip, int nBottomNote, int nTopNote )
{
	DrawHorizontalLinesHelper( hDC, rectClip, nBottomNote, nTopNote, RGB(255, 255, 255), RGB(230, 230, 230), m_lMaxNoteHeight, m_iHaveFocus != 1 );
}

void CSequenceStrip::GetHybridRect( RECT* pRect, int iHybridPos, int iVelocity, MUSIC_TIME mtStart, MUSIC_TIME mtDuration )
{
	ASSERT( pRect );

	if ( m_pSequenceMgr->m_pTimeline )
	{
		pRect->bottom = ((76 - iHybridPos) * m_lMaxNoteHeight) >> 1;
		
		// Find the top of the note's rectangle
		// The velocity offset isn't precisely correct - but it's close enough if m_lMaxNoteHeight < 127.
		long lHeight = ((iVelocity * m_lMaxNoteHeight) >> 7);
		pRect->bottom -= (m_lMaxNoteHeight - lHeight) >> 1;
		pRect->top = pRect->bottom - lHeight;
		
		// Ensure the note is at least one pixel high
		if( pRect->top == pRect->bottom )
		{
			pRect->top--;
		}

		// Convert its starting time to a position
		m_pSequenceMgr->m_pTimeline->ClocksToPosition( mtStart, &pRect->left );

		// Find the position of the note's end, or the end of the segment, whichever is sooner
		m_pSequenceMgr->m_pTimeline->ClocksToPosition( min( m_mtLength, mtStart + mtDuration), &pRect->right );

		// Ensure the note is at least one pixel long
		if ( pRect->right <= pRect->left )
		{
			pRect->right = pRect->left + 1;
		}
	}
	else
	{
		memset( pRect, 0, sizeof(RECT) );
	}
}

void CSequenceStrip::GetNoteRect( const CSequenceItem* pSeqItem, RECT* pRect )
{
	long position;

	ASSERT( pRect );
	ASSERT( pSeqItem );

	if ( pSeqItem && m_pSequenceMgr->m_pTimeline )
	{
		if( m_fHybridNotation )
		{
			// FLATS
			int iHybridPos;
			if( m_pSequenceMgr->m_fDisplayingFlats )
			{
				iHybridPos = MIDIToHybridPos( pSeqItem->m_bByte1, aChromToScaleFlats);
			}
			// SHARPS
			else
			{
				iHybridPos = MIDIToHybridPos( pSeqItem->m_bByte1, aChromToScaleSharps);
			}

			// Get position to draw at
			GetHybridRect( pRect, iHybridPos, pSeqItem->m_bByte2, pSeqItem->AbsTime(), pSeqItem->m_mtDuration );
		}
		else
		{
			// set the bottom
			pRect->bottom = ( 128 - pSeqItem->m_bByte1 ) * m_lMaxNoteHeight - HORIZ_LINE_HEIGHT;

			// Find the top of the note's rectangle
			// The velocity offset isn't precisely correct - but it's close enough if m_lMaxNoteHeight < 127.
			pRect->top = pRect->bottom - ((pSeqItem->m_bByte2 * m_lMaxNoteHeight) >> 7);
		
			// Ensure the note is at least one pixel high
			if( pRect->top == pRect->bottom )
			{
				pRect->top--;
			}

			// Convert the note's starting time to a position
			position = pSeqItem->AbsTime();
			m_pSequenceMgr->m_pTimeline->ClocksToPosition( position, &pRect->left );

			// Find the position of the note's end, or the end of the segment, whichever is sooner
			m_pSequenceMgr->m_pTimeline->ClocksToPosition( min( m_mtLength + m_mtLastLateTime, position + pSeqItem->m_mtDuration), &pRect->right );

			// Ensure the note is at least one pixel long
			if ( pRect->right <= pRect->left )
			{
				pRect->right = pRect->left + 1;
			}
		}
	}
	else
	{
		memset( pRect, 0, sizeof(RECT) );
	}
}
void CSequenceStrip::SetMouseMode( long lXPos, long lYPos)
{
	CSequenceItem* pSeqItem = NULL;
	RECT rectNote; // left, right, top, bottom
	pSeqItem = GetSeqItemAndRectFromPoint( lXPos, lYPos, &rectNote );
	m_MouseMode = SEQ_MM_NORMAL;
	if( pSeqItem )
	{
		{
			// we're inside a note
			LONG lWidth, lHeight;
			lWidth = rectNote.right - rectNote.left + 1;
			lHeight = rectNote.bottom - rectNote.top;
			if( lWidth >= 3 )
			{
				if( lWidth >= 12 )
				{
					lWidth /= 4;
				}
				else
				{
					lWidth /= 3;
				}
				lWidth --; // Because rectNote.right and rectNote.left are selectable.
				if ( lXPos >= rectNote.right - lWidth )
				{
					m_MouseMode = SEQ_MM_RESIZE_END;
				}
				else if ( lXPos - rectNote.left <= lWidth )
				{
					m_MouseMode = SEQ_MM_RESIZE_START;
				}
				else if ( lYPos <= rectNote.top + lHeight/2 )
				{
					m_MouseMode = SEQ_MM_RESIZE_VELOCITY;
				}
				else
				{
					m_MouseMode = SEQ_MM_MOVE;
				}
			}
			else // if ( lWidth <= 2 )
			{
				if ( lXPos >= rectNote.right ) //- lWidth/4 is always 0
				{
					m_MouseMode = SEQ_MM_RESIZE_END;
				}
				// If the note is just one pixel high, then this is true when the mouse is on the note and
				// SEQ_MM_MOVE will be set when the mouse is just below the note.
				else if ( lYPos <= rectNote.top + lHeight/2 )
				{
					m_MouseMode = SEQ_MM_RESIZE_VELOCITY;
				}
				else
				{
					m_MouseMode = SEQ_MM_MOVE;
				}
			}
		}
	}
}
CSequenceItem* CSequenceStrip::GetSeqItemAndRectFromPoint( long lXPos, long lYPos, RECT *pRect )
{
	RECT rectNote, rectSave;

	CSequenceItem* pItemSave = NULL;
	ASSERT( m_pSequenceMgr != NULL );
	if (m_pSequenceMgr != NULL)
	{
		// See which MIDINote grid lYPos is in
		// TODO: Optimize this for Hybrid notation
		// Also optimize in PianoRollStrip.cpp
		int nMIDINote = 127 - (lYPos / m_lMaxNoteHeight);

		// Compute the time of the point asked far
		MUSIC_TIME mtPointTime = 0;

		// Compute the position of the point
		m_pSequenceMgr->m_pTimeline->PositionToClocks( lXPos, &mtPointTime );
		
		// Compute the width of a pixel
		MUSIC_TIME mtPixelWidth;
		m_pSequenceMgr->m_pTimeline->PositionToClocks( 1, &mtPixelWidth );
		// This is a faster way of doing AbsTime() - (mtPixelWidth / 2) - 1 < mtPointTime
		mtPointTime += (mtPixelWidth / 2) + 1;

		POSITION pos = m_pSequenceMgr->m_lstSequences.GetHeadPosition();
		while( pos )
		{
			CSequenceItem *pTmpItem = m_pSequenceMgr->m_lstSequences.GetNext( pos );

			if( pTmpItem->AbsTime() > mtPointTime )
			{
				// Gone too far in list - no need to check further
				break;
			}

			// Check to see if its MIDI value is the one we're looking for
			if( !m_fHybridNotation && (pTmpItem->m_bByte1 != nMIDINote) )
			{
				continue;
			}

			GetNoteRect( pTmpItem, &rectNote );

			// if yPos is above or below the note, continue
			if( ( lYPos < rectNote.top ) || ( lYPos > rectNote.bottom ) )
			{
				continue;
			}

			// Check if lXPos is before the right side of the note
			// Also check against the left side, since mtPointTime may be LONG_MAX.
			if( (lXPos <= rectNote.right) && (lXPos >= rectNote.left) )
			{
				if( !pItemSave )
				{
					pItemSave = pTmpItem;
					rectSave = rectNote;
					continue;
				}
				else
				{
					// Use the selected note
					if( pTmpItem->m_fSelected && !pItemSave->m_fSelected ) 
					{
						pItemSave = pTmpItem;
						rectSave = rectNote;
						continue;
					}

					// If selection state is the same
					if( pItemSave->m_fSelected == pTmpItem->m_fSelected )
					{
						// If start time is the same
						if( pTmpItem->AbsTime() == pItemSave->AbsTime() )
						{
							// Use note with least velocity
							if ( pTmpItem->m_bByte2 <= pItemSave->m_bByte2 ) 
							{
								pItemSave = pTmpItem;
								rectSave = rectNote;
								continue;
							}
						}
						else
						{
							// Use note with later start time
							pItemSave = pTmpItem;
							rectSave = rectNote;
							continue;
						}
					}
				}
			}
		}
	}

	if( pRect && pItemSave )
	{
		memcpy( pRect, &rectSave, sizeof(RECT) );
	}

	return pItemSave;
}

HCURSOR CSequenceStrip::GetResizeStartCursor(void)
{
	static HCURSOR hCursorResizeStart;
	if (!hCursorResizeStart)
		hCursorResizeStart = LoadCursor( AfxGetInstanceHandle( ), MAKEINTRESOURCE(IDC_CURSOR_STARTEDIT) );
	return hCursorResizeStart;
}

HCURSOR CSequenceStrip::GetResizeEndCursor(void)
{
	static HCURSOR hCursorResizeEnd;
	if (!hCursorResizeEnd)
		hCursorResizeEnd = LoadCursor( AfxGetInstanceHandle( ), MAKEINTRESOURCE(IDC_CURSOR_ENDEDIT) );
	return hCursorResizeEnd;
}

HCURSOR CSequenceStrip::GetArrowCursor(void)
{
	static HCURSOR hCursorArrow;
	if (!hCursorArrow)
		hCursorArrow = LoadCursor( NULL, IDC_ARROW );
	return hCursorArrow;
}

HCURSOR CSequenceStrip::GetNSCursor(void)
{
	static HCURSOR hCursorSizeNS;
	if (!hCursorSizeNS)
		hCursorSizeNS = LoadCursor( NULL, IDC_SIZENS ); // North/south resize
	return hCursorSizeNS;
}

HCURSOR CSequenceStrip::GetAllCursor(void)
{
	static HCURSOR hCursorSizeALL;
	if (!hCursorSizeALL)
		//hCursorSizeALL = LoadCursor( NULL, IDC_SIZEALL ); // All resize
		hCursorSizeALL = LoadCursor( AfxGetInstanceHandle( ), MAKEINTRESOURCE(IDC_CURSOR_MOVE) );
	return hCursorSizeALL;
}


/////////////////////////////////////////////////////////////////////////////
// CSequenceStrip::UnselectGutterRange

void CSequenceStrip::UnselectGutterRange( void )
{
	ASSERT( m_pSequenceMgr->m_pTimeline != NULL );

	// Make sure everything on the timeline is deselected.
	m_fSelecting = TRUE;
	m_bSelectionCC = 0xFF;
	m_wSelectionParamType = 0xFFFF;
	m_pSequenceMgr->m_pTimeline->SetMarkerTime( MARKER_BEGINSELECT, TIMETYPE_CLOCKS, 0 );
	m_pSequenceMgr->m_pTimeline->SetMarkerTime( MARKER_ENDSELECT, TIMETYPE_CLOCKS, 0 );
	m_fSelecting = FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CSequenceStrip::SelectInRect

// return: whether anything changed or not
BOOL CSequenceStrip::SelectInRect( CRect* pRect )
{
	BOOL fChange = FALSE;
	int iRes = 0;
	POSITION pos = m_pSequenceMgr->m_lstSequences.GetHeadPosition();
	if( pos != NULL )
	{
		pRect->NormalizeRect();

		RECT rectSel = *pRect;

		// Compute the low and high MIDI values that rectSel touch
		long lMIDILow, lMIDIHigh;
		if( m_fHybridNotation )
		{
			// Convert from rectSel.bottom to a MIDI value
			lMIDILow = PositionToMIDIValue( rectSel.bottom );

			// lMIDILow could be 128, if rectSel.bottom is in the top half of G10
			if( lMIDILow > 127 )
			{
				lMIDILow = 127;
			}

			// Notes a full scale value below may overlap onto our space
			lMIDILow -= 3;
			if( lMIDILow < 0 )
			{
				lMIDILow = 0;
			}

			// Convert from rectSel.top to a MIDI value
			lMIDIHigh = PositionToMIDIValue( rectSel.top );

			// Notes a full scale value above may overlap onto our space
			lMIDIHigh += 3;
			if( lMIDIHigh > 127 )
			{
				lMIDIHigh = 127;
			}
		}
		else
		{
			lMIDILow = 127 - (rectSel.bottom / m_lMaxNoteHeight);
			lMIDIHigh = 127 - (rectSel.top / m_lMaxNoteHeight);
		}

		// m_pActiveNote will be updated by the method UpdateSelectionState, called
		// if any of the item's selection state changes
		CSequenceItem *pSeqItem;
		while( pos )
		{
			pSeqItem = m_pSequenceMgr->m_lstSequences.GetNext( pos );
			// If the note is within the MIDI value range
			if ( (pSeqItem->m_bByte1 <= lMIDIHigh) &&
				 (pSeqItem->m_bByte1 >= lMIDILow) )
			{
				// Get the rectangle defining the note
				RECT rect;
				GetNoteRect( pSeqItem, &rect );

				// Check to see if note is within our horizontal selection range
				if( (rectSel.left <= rect.left) && (rect.left <= rectSel.right) )
				{
					// Check to see if note is within our vertical selection range
					if( ((rectSel.top <= rect.top) && (rect.top <= rectSel.bottom)) ||
						((rectSel.top <= rect.bottom) && (rect.bottom <= rectSel.bottom)) ||
						((rect.top <= rectSel.top) && (rectSel.top <= rect.bottom)) ||
						((rect.top <= rectSel.bottom) && (rectSel.bottom <= rect.bottom)) )
					{
						iRes ++;
						if( !pSeqItem->m_fSelected )
						{
							pSeqItem->m_fSelected = TRUE;
							fChange = TRUE;
						}
					}
					else if( pSeqItem->m_fSelected )
					{
						pSeqItem->m_fSelected = FALSE;
						fChange = TRUE;
					}
				}
				else if( pSeqItem->m_fSelected )
				{
					pSeqItem->m_fSelected = FALSE;
					fChange = TRUE;
				}
			}
			else if( pSeqItem->m_fSelected )
			{
				pSeqItem->m_fSelected = FALSE;
				fChange = TRUE;
			}
		}
	}
	if( fChange )
	{
		m_pSequenceMgr->RefreshPropertyPage( );
		UpdateSelectionState();
	}
	return fChange;
}

/*
/////////////////////////////////////////////////////////////////////////////
// CSequenceStrip::GetStripRect

BOOL CSequenceStrip::GetStripRect(CRect& rectStrip)
{
	VARIANT var;
	var.vt = VT_BYREF;
	V_BYREF(&var) = &rectStrip;
	if( FAILED ( m_pSequenceMgr->m_pTimeline->StripGetTimelineProperty( (IDMUSProdStrip *)this, STP_STRIP_RECT, &var ) ) )
	{
		return FALSE;
	}

	// adjust the strip rect to encompass the WHOLE strip, not only the part
	// that is visible on the screen
	long lHeight;
	if( m_svView == SV_MINIMIZED )
	{
		lHeight = MINIMIZE_HEIGHT;
	}
	else
	{
		//if( FAILED ( m_pSequenceMgr->m_pTimeline->StripGetTimelineProperty( (IDMUSProdStrip *)this, STP_HEIGHT, &var ) ) )
		//{
		//	return FALSE;
		//}
		//lHeight = V_I4(&var);
		lHeight = m_lMaxNoteHeight * 128;
	}

	CPoint ptTop(0, 0);
	CPoint ptBottom(0, lHeight);
	
	VERIFY(SUCCEEDED(m_pSequenceMgr->m_pTimeline->StripToWindowPos(this, &ptTop)));
	VERIFY(SUCCEEDED(m_pSequenceMgr->m_pTimeline->StripToWindowPos(this, &ptBottom)));

	rectStrip.top = ptTop.y;
	rectStrip.bottom = ptBottom.y;
	
	return TRUE;
}
*/


/////////////////////////////////////////////////////////////////////////////
// CSequenceStrip::GetStripRect

BOOL CSequenceStrip::GetStripRect(CRect& rectStrip)
{
	VARIANT var;
	var.vt = VT_BYREF;
	V_BYREF(&var) = &rectStrip;
	if( FAILED ( m_pSequenceMgr->m_pTimeline->StripGetTimelineProperty( (IDMUSProdStrip *)this, STP_STRIP_RECT, &var ) ) )
	{
		return FALSE;
	}

	// adjust the strip rect to encompass the WHOLE strip, not only the part
	// that is visible on the screen
	long lHeight;
	if( m_svView == SV_MINIMIZED )
	{
		lHeight = MINIMIZE_HEIGHT;
	}
	else
	{
		if( m_fHybridNotation )
		{
			lHeight = m_lMaxNoteHeight * 38;
		}
		else
		{
			lHeight = m_lMaxNoteHeight * 128;
		}
	}

	CPoint ptTop(0, 0);
	CPoint ptBottom(0, lHeight);
	
	VERIFY(SUCCEEDED(m_pSequenceMgr->m_pTimeline->StripToWindowPos(this, &ptTop)));
	VERIFY(SUCCEEDED(m_pSequenceMgr->m_pTimeline->StripToWindowPos(this, &ptBottom)));

	rectStrip.top = ptTop.y;
	rectStrip.bottom = ptBottom.y;
	
	return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
// CSequenceStrip::RegisterMidi

void CSequenceStrip::RegisterMidi() 
{
	//TRACE("CSequenceStrip::RegisterMidi %d %d\n", m_pSequenceMgr->m_dwPChannel, m_cRef);
	if ( (m_pSequenceMgr->m_pIConductor != NULL) && !m_fMIDIInRegistered )
	{
		//TRACE("Register\n");
		REGISTER_MIDI_IN(m_pSequenceMgr->m_pIConductor, m_dwCookie);
		m_fMIDIInRegistered = TRUE;
		// Release the Reference gained in the REGISTER_MIDI_IN call.
		// If we don't do this, we will never be destroyed (because our RefCount
		// will not go down to zero.)
		//Release();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CSequenceStrip::UnRegisterMidi

void CSequenceStrip::UnRegisterMidi()
{
	//TRACE("CSequenceStrip::UnRegisterMidi %d %d\n", m_pSequenceMgr->m_dwPChannel, m_cRef);
	if ( (m_pSequenceMgr->m_pIConductor != NULL) && m_fMIDIInRegistered )
	{
		// Send fake MIDI_NOTEOFF messages for all currently playing notes
		// But only if we're not shutting down
		if( !m_pSequenceMgr->m_fShuttingDown )
		{
			REFERENCE_TIME rtTime;
			if( SUCCEEDED(m_pSequenceMgr->m_pIDMPerformance->GetTime( &rtTime, NULL )) )
			{
				//TRACE("NoteOffs\n");
				for( BYTE bNote = 0; bNote < 128; bNote++ )
				{
					if( m_bVelocity[bNote] )
					{
						OnMidiMsg( rtTime, MIDI_NOTEOFF, bNote, m_bVelocity[bNote] );
					}
				}
			}
		}

		if( m_fMIDIThruEnabled )
		{
			CancelPChannelThru();
		}

		// If we're not playing, send all notes off to the performance engine
		SendAllNotesOffIfNotPlaying();

		//TRACE("UnRegister\n");

		UNREGISTER_MIDI_IN(m_pSequenceMgr->m_pIConductor, m_dwCookie);
		/*
		// Add a reference, since UNREGISTER_MIDI_IN will cause one to be taken away.
		if ( m_cRef > 0 )
		{
			AddRef();
			UNREGISTER_MIDI_IN(m_pSequenceMgr->m_pIConductor, m_dwCookie);
		}
		else
		{
			m_cRef = 2;
			UNREGISTER_MIDI_IN(m_pSequenceMgr->m_pIConductor, m_dwCookie);
			m_cRef = 0;
		}
		*/
		m_fMIDIInRegistered = FALSE;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CSequenceStrip::IsEnginePlaying

BOOL CSequenceStrip::IsEnginePlaying( void ) const
{
	return (m_pSequenceMgr->m_pSegmentState != NULL) ? TRUE : FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CSequenceStrip::SendAllNotesOffIfNotPlaying

void CSequenceStrip::SendAllNotesOffIfNotPlaying( void )
{
	// If we're not playing, send all notes off to the performance engine
	if ( !IsEnginePlaying() )
	{
		DMUS_MIDI_PMSG *pDMMIDIEvent = NULL;
		if( SUCCEEDED( m_pSequenceMgr->m_pIDMPerformance->AllocPMsg( sizeof(DMUS_MIDI_PMSG), (DMUS_PMSG **)&pDMMIDIEvent ) ) )
		{
			ZeroMemory( pDMMIDIEvent, sizeof(DMUS_MIDI_PMSG) );
			// PMSG fields
			pDMMIDIEvent->dwSize = sizeof(DMUS_MIDI_PMSG);
			pDMMIDIEvent->dwFlags = DMUS_PMSGF_REFTIME;
			pDMMIDIEvent->dwPChannel = m_pSequenceMgr->m_dwPChannel;
			pDMMIDIEvent->dwVirtualTrackID = 1;
			pDMMIDIEvent->dwType = DMUS_PMSGT_MIDI;

			// DMMIDIEvent fields
			pDMMIDIEvent->bStatus = MIDI_CCHANGE;
			// Send Reset All Controllers (121)
			pDMMIDIEvent->bByte1 = 121;

			m_pSequenceMgr->SendPMsg( (DMUS_PMSG *)pDMMIDIEvent );
			// The playback engine will release the event

			if( SUCCEEDED( m_pSequenceMgr->m_pIDMPerformance->AllocPMsg( sizeof(DMUS_MIDI_PMSG), (DMUS_PMSG **)&pDMMIDIEvent ) ) )
			{
				ZeroMemory( pDMMIDIEvent, sizeof(DMUS_MIDI_PMSG) );
				// PMSG fields
				pDMMIDIEvent->dwSize = sizeof(DMUS_MIDI_PMSG);
				pDMMIDIEvent->dwFlags = DMUS_PMSGF_REFTIME;
				pDMMIDIEvent->dwPChannel = m_pSequenceMgr->m_dwPChannel;
				pDMMIDIEvent->dwVirtualTrackID = 1;
				pDMMIDIEvent->dwType = DMUS_PMSGT_MIDI;

				// DMMIDIEvent fields
				pDMMIDIEvent->bStatus = MIDI_CCHANGE;
				// Send All Notes Off (123)
				pDMMIDIEvent->bByte1 = 123;

				m_pSequenceMgr->SendPMsg( (DMUS_PMSG *)pDMMIDIEvent );
				// The playback engine will release the event
			}
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CSequenceStrip::OnMidiMsg

HRESULT CSequenceStrip::OnMidiMsg(REFERENCE_TIME rtTime, 
									   BYTE bStatus, 
									   BYTE bData1, 
									   BYTE bData2)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	ASSERT( m_pSequenceMgr != NULL );
	if (m_pSequenceMgr == NULL)
	{
		return E_UNEXPECTED;
	}

	ASSERT( m_pSequenceMgr->m_pTimeline != NULL );
	if (m_pSequenceMgr->m_pTimeline == NULL)
	{
		return E_UNEXPECTED;
	}

	// If shutting down, ignore all MIDI messages.
	if( m_pSequenceMgr->m_fShuttingDown )
	{
		return E_UNEXPECTED;
	}

	// If not recording, just pass through the MIDI input
	if( !m_pSequenceMgr->m_fRecordEnabled )
	{
		// If we're not already thruing, output a message to the performance engine
		if ( !m_fMIDIThruEnabled )
		{
			/* This sometimes makes the notes play forever.
			if( (bStatus & 0xF0) == MIDI_NOTEON )
			{
				DMUS_NOTE_PMSG *pDMNoteEvent = NULL;
				if( FAILED( m_pSequenceMgr->m_pIDMPerformance->AllocPMsg( sizeof(DMUS_NOTE_PMSG), (DMUS_PMSG **)&pDMNoteEvent ) ) )
				{
					return;
				}

				ASSERT( pDMNoteEvent != NULL );
				ZeroMemory( pDMNoteEvent, sizeof(DMUS_NOTE_PMSG) );
				// PMSG fields
				pDMNoteEvent->dwSize = sizeof(DMUS_NOTE_PMSG);
			//	pDMNoteEvent->rtTime = 0;
			//	pDMNoteEvent->mtTime = 0;
				pDMNoteEvent->dwFlags = DMUS_PMSGF_REFTIME;
				pDMNoteEvent->dwPChannel = m_pSequenceMgr->m_dwPChannel;
				pDMNoteEvent->dwVirtualTrackID = 1;
			//	pDMNoteEvent->pTool = NULL;
			//	pDMNoteEvent->pGraph = NULL;
				pDMNoteEvent->dwType = DMUS_PMSGT_NOTE;
			//	pDMNoteEvent->punkUser = 0;
				// DMNoteEvent fields
				pDMNoteEvent->mtDuration = LONG_MAX / 2;
			//	pDMNoteEvent->wMusicValue = pPropNote->m_wMusicvalue;
			//	pDMNoteEvent->wMeasure = (WORD) pPropNote->m_lStartBar;
			//	pDMNoteEvent->nOffset = pPropNote->m_nOffset;
			//	pDMNoteEvent->bBeat = (BYTE) pPropNote->m_lStartBeat;
			//	pDMNoteEvent->bGrid = (BYTE) pPropNote->m_lStartGrid;
				pDMNoteEvent->bVelocity = bData2;
				pDMNoteEvent->bFlags = DMUS_NOTEF_NOTEON;
			//	pDMNoteEvent->bTimeRange = pPropNote->m_bTimeRange;
			//	pDMNoteEvent->bDurRange = pPropNote->m_bDurRange;
			//	pDMNoteEvent->bVelRange = pPropNote->m_bVelRange;
			//	pDMNoteEvent->bInversionID = pPropNote->m_bInversionId;
			//	pDMNoteEvent->bPlayModeFlags = pPropNote->m_bPlayMode;
				pDMNoteEvent->bMidiValue = bData1;

				DMUS_PMSG *pPMsg = (DMUS_PMSG *)pDMNoteEvent;
				m_pSequenceMgr->SendPMsg( pPMsg );
			}
			else
			*/
			{
				DMUS_MIDI_PMSG *pDMMIDIEvent = NULL;
				if( SUCCEEDED( m_pSequenceMgr->m_pIDMPerformance->AllocPMsg( sizeof(DMUS_MIDI_PMSG), (DMUS_PMSG **)&pDMMIDIEvent ) ) )
				{
					ZeroMemory( pDMMIDIEvent, sizeof(DMUS_MIDI_PMSG) );
					// PMSG fields
					pDMMIDIEvent->dwSize = sizeof(DMUS_MIDI_PMSG);
				//	pDMNoteEvent->rtTime = 0;
				//	pDMNoteEvent->mtTime = 0;
					pDMMIDIEvent->dwFlags = DMUS_PMSGF_REFTIME;
					//m_pSequenceMgr->m_pIDMPerformance->GetTime( &pDMMIDIEvent->rtTime, &pDMMIDIEvent->mtTime );
					//pDMMIDIEvent->dwFlags = DMUS_PMSGF_REFTIME | DMUS_PMSGF_MUSICTIME;
					pDMMIDIEvent->dwPChannel = m_pSequenceMgr->m_dwPChannel;
					pDMMIDIEvent->dwVirtualTrackID = 1;
				//	pDMNoteEvent->pTool = NULL;
				//	pDMNoteEvent->pGraph = NULL;
					pDMMIDIEvent->dwType = DMUS_PMSGT_MIDI;
				//	pDMNoteEvent->punkUser = 0;

					// DMMIDIEvent fields
					pDMMIDIEvent->bStatus = bStatus;
					pDMMIDIEvent->bByte1 = bData1;
					pDMMIDIEvent->bByte2 = bData2;
				//	pDMMIDIEvent->bPad[0] = 0;

					m_pSequenceMgr->SendPMsg( (DMUS_PMSG *)pDMMIDIEvent );
					// The playback engine will release the event
				}
			}
		}
		return S_OK;
	}

	// Note On
	if((int)(bStatus & 0xF0) == (int)MIDI_NOTEON)
	{
		//TRACE("Inside  CSequenceStrip::OnMidiMsg going to play %d note on with %d at %d\n", bData1, bData2, ::timeGetTime());
		if (!IsEnginePlaying())
		{
			return RecordStepNoteOn( bData1, bData2 );
		}
		else
		{
			if( FAILED( RecordRealTimeNoteOn( rtTime, bData1, bData2 ) ) )
			{
				TRACE("MIDIStripMgr: RecordRealTimeNoteOn failed, falling back to RecordStepNoteOn\n");
				return RecordStepNoteOn( bData1, bData2 );
			}
			return S_OK;
		}
	}

	// Note Off
	if((int)(bStatus & 0xF0) == (int)MIDI_NOTEOFF)
	{
		//TRACE("Inside  CSequenceStrip::OnMidiMsg going to play %d note off at %d\n", bData1, ::timeGetTime());
		if ( !IsEnginePlaying() )
		{
			return RecordStepNoteOff( bData1 );
		}
		else
		{
			return RecordRealTimeNoteOff( rtTime, bData1 );
		}
	}

	// Curves
	if( (int)(bStatus & 0xF0) == (int)MIDI_PBEND 
	||  (int)(bStatus & 0xF0) == (int)MIDI_CCHANGE 
	||  (int)(bStatus & 0xF0) == (int)MIDI_PTOUCH 
	||  (int)(bStatus & 0xF0) == (int)MIDI_MTOUCH )
	{
		// No step recording
		if( IsEnginePlaying() )
		{
			return RecordRealTimeCurve( rtTime, bStatus, bData1, bData2 );
		}
	}
	
	//TRACE("OnMidiMsg out at %d\n", ::timeGetTime());
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CSequenceStrip::RecordStepNoteOn

HRESULT CSequenceStrip::RecordStepNoteOn( BYTE bData1, BYTE bData2 )
{
	if (m_bVelocity[bData1] != 0)
	{
		return E_UNEXPECTED;
	}

	if (bData2 > 0)
	{
		m_bVelocity[bData1] = bData2;
	}
	else
	{
		m_bVelocity[bData1] = 127;
	}
	m_mtStartTime[bData1] = m_lInsertTime;

	// Can't call m_pSequenceMgr->PlayNote, because that will clip off any notes that are already playing

	// Play the entire note
	if( m_pSequenceMgr->m_pIDMPerformance )
	{
		REFERENCE_TIME rtLatency;
		m_pSequenceMgr->m_pIDMPerformance->GetLatencyTime( &rtLatency );

		DMUS_NOTE_PMSG *pDMNoteEvent = NULL;
		if( SUCCEEDED( m_pSequenceMgr->m_pIDMPerformance->AllocPMsg( sizeof(DMUS_NOTE_PMSG), (DMUS_PMSG **)&pDMNoteEvent ) ) )
		{
			ASSERT( pDMNoteEvent != NULL );
			ZeroMemory( pDMNoteEvent, sizeof(DMUS_NOTE_PMSG) );
			// PMSG fields
			pDMNoteEvent->dwSize = sizeof(DMUS_NOTE_PMSG);
			pDMNoteEvent->rtTime = rtLatency;
		//	pDMNoteEvent->mtTime = 0;
			pDMNoteEvent->dwFlags = DMUS_PMSGF_REFTIME;
			pDMNoteEvent->dwPChannel = m_pSequenceMgr->m_dwPChannel;
			pDMNoteEvent->dwVirtualTrackID = 1;
		//	pDMNoteEvent->pTool = NULL;
		//	pDMNoteEvent->pGraph = NULL;
			pDMNoteEvent->dwType = DMUS_PMSGT_NOTE;
		//	pDMNoteEvent->punkUser = 0;
			// DMNoteEvent fields
			pDMNoteEvent->mtDuration = max( GetSnapAmount( m_lInsertTime ) - 1, GetGridClocks(m_lInsertTime) / 2 );
		//	pDMNoteEvent->wMusicValue = pPropNote->m_wMusicvalue;
		//	pDMNoteEvent->wMeasure = (WORD) pPropNote->m_lStartBar;
		//	pDMNoteEvent->nOffset = pPropNote->m_nOffset;
		//	pDMNoteEvent->bBeat = (BYTE) pPropNote->m_lStartBeat;
		//	pDMNoteEvent->bGrid = (BYTE) pPropNote->m_lStartGrid;
			pDMNoteEvent->bVelocity = bData2;
			pDMNoteEvent->bFlags = DMUS_NOTEF_NOTEON;
		//	pDMNoteEvent->bTimeRange = pPropNote->m_bTimeRange;
		//	pDMNoteEvent->bDurRange = pPropNote->m_bDurRange;
		//	pDMNoteEvent->bVelRange = pPropNote->m_bVelRange;
		//	pDMNoteEvent->bInversionID = pPropNote->m_bInversionId;
		//	pDMNoteEvent->bPlayModeFlags = pPropNote->m_bPlayMode;
			pDMNoteEvent->bMidiValue = bData1;

			DMUS_PMSG *pPMsg = (DMUS_PMSG *)pDMNoteEvent;
			m_pSequenceMgr->SendPMsg( pPMsg );
			// The playback engine will release the event
		}
	}

	// Move the insert cursor to a new position
	m_lInsertVal = bData1;

	::PostMessage( m_VScrollBar.m_hWnd, WM_APP, WM_APP_INVALIDATEPIANOROLL, 0 );

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CSequenceStrip::RecordStepNoteOff

HRESULT CSequenceStrip::RecordStepNoteOff( BYTE bData1 )
{
	// if the velocity is 0, we didn't receive a NOTEON message, so exit
	if (m_bVelocity[bData1] == 0)
	{
		return E_UNEXPECTED;
	}

	long mtStartTime = m_mtStartTime[bData1];

	BYTE bVelocity = m_bVelocity[bData1];

	MUSIC_TIME mtEndTime;

	SNAPTO snapTo = GetSnapToBoundary( mtStartTime );
	mtEndTime = m_lInsertTime + GetSnapAmount( mtStartTime, snapTo );

	while ( mtEndTime < mtStartTime)
	{
		mtEndTime += m_mtLength;
	}

	CSequenceItem* pSeqItem;
	pSeqItem = new CSequenceItem;
	
	if( mtStartTime < 0 )
	{
		// Set the time of the note to 0
		pSeqItem->m_mtTime = 0;

		// Find out the TimeSig of the first measure
		DMUS_TIMESIGNATURE dmTimeSig;
		GetTimeSig( 0, &dmTimeSig, m_pSequenceMgr->m_pTimeline, m_pSequenceMgr->m_dwGroupBits );

		// Compute the smallest possible offset before time 0
		const long lNegativeMeasureLength = max( SHRT_MIN, -dmTimeSig.bBeatsPerMeasure * ((DMUS_PPQ * 4) / dmTimeSig.bBeat) );

		// Set the note's offset
		pSeqItem->m_nOffset = short( max( mtStartTime, lNegativeMeasureLength) );
	}
	else
	{
		pSeqItem->m_mtTime = mtStartTime;
		pSeqItem->m_nOffset = 0;
	}
	pSeqItem->m_mtDuration = max( mtEndTime - mtStartTime - 1, GetGridClocks(pSeqItem->AbsTime()) / 2 );
	pSeqItem->m_bStatus = MIDI_NOTEON;
	pSeqItem->m_bByte1 = bData1;
	pSeqItem->m_bByte2 = bVelocity;
	pSeqItem->m_fSelected = FALSE;
	
	ASSERT( pSeqItem->m_mtDuration != 0 );

	m_pSequenceMgr->InsertNote( pSeqItem, FALSE );

	m_bVelocity[bData1] = 0;
	m_mtStartTime[bData1] = 0;

	BOOL fNotesOn = FALSE;
	for (int i=0; i < 128; i++)
	{
		if (m_mtStartTime[i] != 0 || m_bVelocity[i] != 0)
		{
			fNotesOn = TRUE;
			break;
		}
	}

	// If all notes are off, increment the time cursor by one grid and update the pattern editor
	if (!fNotesOn)
	{
		m_nLastEdit = IDS_UNDO_INSERT;
		CoInitialize( NULL );
		m_pSequenceMgr->OnDataChanged();
		CoUninitialize();
		// Handled by OnDataChanged
		//m_pSequenceMgr->m_fNoteInserted = FALSE;

		// Bump to the right (this eventually causes BumpTimeCursor() to be
		// called in a message handler thread
		::PostMessage( m_VScrollBar.m_hWnd, WM_APP, WM_APP_BUMPTIMECURSOR, 0 );
	}
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CSequenceStrip::RecordRealTimeNoteOn

HRESULT CSequenceStrip::RecordRealTimeNoteOn(REFERENCE_TIME rtTime, BYTE bData1, BYTE bData2 )
{
	if (m_bVelocity[bData1] != 0)
	{
		return E_UNEXPECTED;
	}

	if( m_pSequenceMgr->m_pSegmentState )
	{
		MUSIC_TIME mtTime;
		m_pSequenceMgr->m_pIDMPerformance->ReferenceToMusicTime( rtTime, &mtTime );

		//TRACE("Start time: %d\n",mtTime);
		m_mtStartTime[bData1] = mtTime;

		if (bData2 > 0)
		{
			m_bVelocity[bData1] = bData2;
		}
		else
		{
			m_bVelocity[bData1] = 127;
		}
	}
	else
	{
		return E_FAIL;
	}
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CSequenceStrip::RecordRealTimeNoteOff

HRESULT CSequenceStrip::RecordRealTimeNoteOff(REFERENCE_TIME rtTime, BYTE bData1 )
{
	// if the velocity is 0, we didn't receive a NOTEON message, so exit
	if (m_bVelocity[bData1] == 0)
	{
		//TRACE("Oops: velocity 0\n");
		return E_UNEXPECTED;
	}

	MUSIC_TIME mtTime;
	m_pSequenceMgr->m_pIDMPerformance->ReferenceToMusicTime( rtTime, &mtTime );

	CSequenceItem* pSeqItem;
	pSeqItem = new CSequenceItem;

	pSeqItem->m_mtDuration = mtTime - m_mtStartTime[bData1];

	mtTime = m_mtStartTime[bData1];

	// Convert mtTime from absolute time to an offset from when the segment started playing
	mtTime = GetTimeOffset( mtTime, m_pSequenceMgr->m_mtCurrentStartTime, m_pSequenceMgr->m_mtCurrentStartPoint,
				m_pSequenceMgr->m_mtCurrentLoopStart, m_pSequenceMgr->m_mtCurrentLoopEnd, m_mtLength,
				m_pSequenceMgr->m_dwCurrentMaxLoopRepeats );

	if( mtTime < 0 )
	{
		// Set the time of the note to 0
		pSeqItem->m_mtTime = 0;

		// Find out the TimeSig of the first measure
		DMUS_TIMESIGNATURE dmTimeSig;
		GetTimeSig( 0, &dmTimeSig, m_pSequenceMgr->m_pTimeline, m_pSequenceMgr->m_dwGroupBits );

		// Compute the smallest possible offset before time 0
		const long lNegativeMeasureLength = max( SHRT_MIN, -dmTimeSig.bBeatsPerMeasure * ((DMUS_PPQ * 4) / dmTimeSig.bBeat) );

		// Set the note's offset
		pSeqItem->m_nOffset = short ( max( mtTime, lNegativeMeasureLength) );
	}
	else
	{
		pSeqItem->m_mtTime = mtTime;
		pSeqItem->m_nOffset = 0;
	}
	pSeqItem->m_bByte2 = m_bVelocity[bData1];
	pSeqItem->m_bByte1 = bData1;
	pSeqItem->m_bStatus = MIDI_NOTEON;
	pSeqItem->m_fSelected = FALSE;

	if (pSeqItem->m_mtDuration == 0)
	{
		//TRACE("Duration == 0 at %d\n", ::timeGetTime());
		// BUGBUG: Need to replace with a better value
		pSeqItem->m_mtDuration = 768 / 4;
	}
	m_pSequenceMgr->InsertNote( pSeqItem, FALSE );

	m_bVelocity[bData1] = 0;
	m_mtStartTime[bData1] = 0;
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CSequenceStrip::RecordRealTimeCurve

HRESULT CSequenceStrip::RecordRealTimeCurve( REFERENCE_TIME rtTime, BYTE bStatus, BYTE bData1, BYTE bData2 )
{
	UNREFERENCED_PARAMETER(bStatus);
	UNREFERENCED_PARAMETER(bData1);
	UNREFERENCED_PARAMETER(bData2);

	// Get the MUSIC_TIME
	MUSIC_TIME mtTime;
	m_pSequenceMgr->m_pIDMPerformance->ReferenceToMusicTime( rtTime, &mtTime );

	// Create the Curve
	CCurveItem* pDMCurve = new CCurveItem;
	if( pDMCurve )
	{
		switch( (int)(bStatus & 0xF0) )
		{
			case MIDI_PBEND:
				pDMCurve->m_bType = DMUS_CURVET_PBCURVE;
				pDMCurve->m_nStartValue = short(((bData2 & 0x7F) << 7) + (bData1 & 0x7F));
				break;

			case MIDI_CCHANGE:
				pDMCurve->m_bType = DMUS_CURVET_CCCURVE;
				pDMCurve->m_bCCData = bData1;
				pDMCurve->m_nStartValue = bData2;
				break;

			case MIDI_PTOUCH:
				pDMCurve->m_bType = DMUS_CURVET_PATCURVE;
				pDMCurve->m_bCCData = bData1;
				pDMCurve->m_nStartValue = bData2;
				break;

			case MIDI_MTOUCH:
				pDMCurve->m_bType = DMUS_CURVET_MATCURVE;
				pDMCurve->m_nStartValue = bData1;
				break;
		}

		// Convert mtTime from absolute time to an offset from when the segment started playing
		mtTime -= m_pSequenceMgr->m_mtCurrentStartTime - m_pSequenceMgr->m_mtCurrentStartPoint;

		// If mtLoopEnd is non zero, set lLoopEnd to mtLoopEnd, otherwise use the segment length
		long lLoopEnd;
		lLoopEnd = m_pSequenceMgr->m_mtCurrentLoopEnd ? m_pSequenceMgr->m_mtCurrentLoopEnd : m_mtLength;

		// Subtract off the loops if we started before the loop end time
		// It should be '<=' - if the start point is the loop end point, it will loop.
		if( (lLoopEnd != m_pSequenceMgr->m_mtCurrentLoopStart) &&
			(m_pSequenceMgr->m_mtCurrentStartPoint <= lLoopEnd) )
		{

			// Subtract off time for the repeats already finished
			mtTime -= m_pSequenceMgr->m_dwCurrentLoopRepeats * (lLoopEnd - m_pSequenceMgr->m_mtCurrentLoopStart);

			// If we're beyond the loop end and there are loops left, subtract off
			// another loop and increment our current loops count
			if( (m_pSequenceMgr->m_dwCurrentLoopRepeats < m_pSequenceMgr->m_dwCurrentMaxLoopRepeats) &&
				(mtTime >= lLoopEnd) )
			{
				int nRepeats;
				nRepeats = (mtTime - m_pSequenceMgr->m_mtCurrentLoopStart) /
					(lLoopEnd - m_pSequenceMgr->m_mtCurrentLoopStart);
				m_pSequenceMgr->m_dwCurrentLoopRepeats += nRepeats;
				mtTime -= nRepeats * (lLoopEnd - m_pSequenceMgr->m_mtCurrentLoopStart);
			}
		}

		if( mtTime < 0 )
		{
			pDMCurve->m_mtTime = 0;
			pDMCurve->m_nOffset = short ( max( mtTime, SHRT_MIN) );
		}
		else
		{
			pDMCurve->m_mtTime = mtTime;
			pDMCurve->m_nOffset = 0;
		}

		pDMCurve->m_mtDuration = 1;
		pDMCurve->m_bCurveShape = DMUS_CURVES_INSTANT;
		pDMCurve->m_nEndValue = pDMCurve->m_nStartValue;

		pDMCurve->SetDefaultResetValues( m_mtLength );

		// Make sure a corresponding Curve strip exists
		BYTE bCCType = CurveTypeToStripCCType( pDMCurve ); 
		if( m_CurveStripView == SV_MINIMIZED )
		{
			GetCurveStripState( bCCType, pDMCurve->m_wParamType );
		}
		else
		{
			AddCurveStrip( bCCType, pDMCurve->m_wParamType );
		}

		// Place curve in Sequence's event list
		m_pSequenceMgr->InsertCurve( pDMCurve, FALSE );
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CSequenceStrip::FloorTimeToGrid

MUSIC_TIME CSequenceStrip::FloorTimeToGrid( MUSIC_TIME mtTime, long *plGridClocks ) const
{
	ASSERT( m_pSequenceMgr && m_pSequenceMgr->m_pTimeline );

	// Find out which measure we're in
	long lMeasure;
	if( SUCCEEDED( m_pSequenceMgr->m_pTimeline->ClocksToMeasureBeat( m_pSequenceMgr->m_dwGroupBits, m_pSequenceMgr->m_dwIndex, mtTime, &lMeasure, NULL ) ) )
	{
		// Find the time of the start of this measure
		long lTime;
		if( SUCCEEDED( m_pSequenceMgr->m_pTimeline->MeasureBeatToClocks( m_pSequenceMgr->m_dwGroupBits, m_pSequenceMgr->m_dwIndex, lMeasure, 0, &lTime ) ) )
		{
			// Get the TimeSig for this measure
			DMUS_TIMESIGNATURE ts;
			if( SUCCEEDED( m_pSequenceMgr->m_pTimeline->GetParam( GUID_TimeSignature, m_pSequenceMgr->m_dwGroupBits, m_pSequenceMgr->m_dwIndex, lTime, NULL, &ts ) ) )
			{
				long lBeat, lGrid;
				// Compute the number of clocks in a beat and a grid
				long lBeatClocks = (DMUS_PPQ * 4) / ts.bBeat;
				long lGridClocks = lBeatClocks / ts.wGridsPerBeat;

				// BUGBUG: This doesn't work correctly if lGridClocks * wGridsPerBeat != lBeatClocks
				// Any notes in the second half of the last grid in a beat will have the WRONG tick
				// (since there are more ticks in the last grid of the beat than in the other grids).

				// Convert mtTime into an offset from the start of this measure
				mtTime -= lTime;

				lBeat = mtTime / lBeatClocks;
				lGrid = (mtTime % lBeatClocks) / lGridClocks;

				if( plGridClocks )
				{
					*plGridClocks = lGridClocks;
				}

				return lTime + (lBeat * lBeatClocks) + (lGrid * lGridClocks);
			}
		}
	}

	return mtTime;
}


/////////////////////////////////////////////////////////////////////////////
// CSequenceStrip::CurveStripExists
	
BOOL CSequenceStrip::CurveStripExists( void *pThis, BYTE bCCType, WORD wRPNType )
{
	ASSERT( pThis );
	if( pThis == NULL )
	{
		return FALSE;
	}

	// Always return FALSE for generic RPN and NRPN strips
	if( (wRPNType == 0xFFFF)
	&&	((bCCType == CCTYPE_RPN_CURVE_STRIP) || (bCCType == CCTYPE_NRPN_CURVE_STRIP)) )
	{
		return FALSE;
	}

	CSequenceStrip *pSequenceStrip = static_cast<CSequenceStrip *>(pThis);

	ioCurveStripState* pCurveStripState;

	// Use CurveStripState list instead of CurveStrip list
	// because it contains accurate info whether or not
	// CurveStrip(s) are minimized
	POSITION pos = pSequenceStrip->m_lstCurveStripStates.GetHeadPosition();
	while( pos )
	{
		pCurveStripState = pSequenceStrip->m_lstCurveStripStates.GetNext( pos );

		if( pCurveStripState->m_bCCType == bCCType )
		{
			if( (wRPNType != 0xFFFF)
			&&	((bCCType == CCTYPE_RPN_CURVE_STRIP) || (bCCType == CCTYPE_NRPN_CURVE_STRIP)) )
			{
				if( pCurveStripState->m_wRPNType == wRPNType )
				{
					return TRUE;
				}
			}
			else
			{
				// CurveStrip already exists
				return TRUE;
			}
		}
	}

	return FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CSequenceStrip::CurveTypeToStripCCType

BYTE CSequenceStrip::CurveTypeToStripCCType( CCurveItem* pDMCurve )
{
	return ::CurveTypeToStripCCType( pDMCurve->m_bType, pDMCurve->m_bCCData );
}


/////////////////////////////////////////////////////////////////////////////
// CSequenceStrip::SyncCurveStripStateList

void CSequenceStrip::SyncCurveStripStateList( void )
{
	POSITION pos = m_pSequenceMgr->m_lstCurves.GetHeadPosition();
	while( pos )
	{
		CCurveItem *pDMCurve = m_pSequenceMgr->m_lstCurves.GetNext( pos );
		GetCurveStripState( CurveTypeToStripCCType( pDMCurve ), pDMCurve->m_wParamType );
	}

	if( m_lstCurveStripStates.IsEmpty() )
	{
		m_CurveStripView = SV_MINIMIZED;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CSequenceStrip::GetCurveStripState

ioCurveStripState* CSequenceStrip::GetCurveStripState( BYTE bCCType, WORD wRPNType )
{
	ioCurveStripState* pNewCurveStripState;
	ioCurveStripState* pCurveStripState;

	// Minimized CurveStrips do not store state information
	if( bCCType == CCTYPE_MINIMIZED_CURVE_STRIP )
	{
		return NULL;
	}

	// See if CurveStripState info already exists
	POSITION pos = m_lstCurveStripStates.GetHeadPosition();
	while( pos )
	{
		pCurveStripState = m_lstCurveStripStates.GetNext( pos );

		if( pCurveStripState->m_bCCType == bCCType )
		{
			// Check if this is an RPN or an NRPN curve
			if( (pCurveStripState->m_bCCType == CCTYPE_NRPN_CURVE_STRIP)
			||	(pCurveStripState->m_bCCType == CCTYPE_RPN_CURVE_STRIP) )
			{
				// RPN/NRPN curve - check m_wRPNType also
				if( pCurveStripState->m_wRPNType == wRPNType )
				{
					// CurveStripState already exists
					return pCurveStripState;
				}
			}
			else
			{
				// CurveStripState already exists
				return pCurveStripState;
			}
		}
	}

	// Create a new CurveStripState struct	
	pNewCurveStripState = new ioCurveStripState;
	
	if( pNewCurveStripState )
	{
		pNewCurveStripState->m_nStripHeight = CRV_DEFAULT_HEIGHT;
		pNewCurveStripState->m_bCCType = bCCType;
		pNewCurveStripState->m_bPad = 0;
		if( (bCCType == CCTYPE_NRPN_CURVE_STRIP)
		||	(bCCType == CCTYPE_RPN_CURVE_STRIP) )
		{
			pNewCurveStripState->m_wRPNType = wRPNType;
		}
		else
		{
			pNewCurveStripState->m_wRPNType = 0;
		}

		WORD wCCTypeSortValue = GetCCTypeSortValue( pNewCurveStripState->m_bCCType, pNewCurveStripState->m_wRPNType );
		WORD wCCTypeListSortValue;

		// Add this state info to the list of PianoRoll CurveStripStates
		// Sort on bCCType (ascending)
		POSITION pos = m_lstCurveStripStates.GetHeadPosition();
		POSITION posPrev;

		while( pos )
		{
			posPrev = pos;
			pCurveStripState = m_lstCurveStripStates.GetNext( pos );

			wCCTypeListSortValue = GetCCTypeSortValue( pCurveStripState->m_bCCType, pCurveStripState->m_wRPNType );
			if( wCCTypeListSortValue > wCCTypeSortValue )
			{
				m_lstCurveStripStates.InsertBefore( posPrev, pNewCurveStripState );
				return pNewCurveStripState; 
			}
		}

		m_lstCurveStripStates.AddTail( pNewCurveStripState );
		return pNewCurveStripState; 
	}

	return NULL;
}


/////////////////////////////////////////////////////////////////////////////
// CSequenceStrip::GetCurveStrip
	
CCurveStrip* CSequenceStrip::GetCurveStrip( BYTE bCCType, WORD wRPNType )
{
    POSITION pos = m_lstCurveStrips.GetHeadPosition();
    while( pos )
    {
		CCurveStrip* pCurveStrip = m_lstCurveStrips.GetNext( pos );

		if( pCurveStrip->m_bCCType == bCCType )
		{
			if( (pCurveStrip->m_bCCType == CCTYPE_NRPN_CURVE_STRIP)
			||	(pCurveStrip->m_bCCType == CCTYPE_RPN_CURVE_STRIP) )
			{
				if( pCurveStrip->m_wRPNType == wRPNType )
				{
					return pCurveStrip;
				}
			}
			else
			{
				return pCurveStrip;
			}
		}
    }

	return NULL; 
}


/////////////////////////////////////////////////////////////////////////////
// CSequenceStrip::AddCurveStrip
	
HRESULT CSequenceStrip::AddCurveStrip( BYTE bCCType, WORD wRPNType )
{
	ASSERT( m_pSequenceMgr != NULL );
	ASSERT( m_pSequenceMgr->m_pTimeline != NULL );

	// Make sure Curve Strip does not already exist
	CCurveStrip* pCurveStrip = GetCurveStrip( bCCType, wRPNType );
	if( pCurveStrip )
	{
		// Curve Strip already exists
		return S_OK;
	}
	
	// Create the Curve strip
	pCurveStrip = new CCurveStrip( m_pSequenceMgr, this, bCCType, wRPNType );
	if( pCurveStrip )
	{
		ioCurveStripState* pTheCurveStripState = NULL;

		// Get/create state info struct for maximized Curve strips
		if( bCCType != CCTYPE_MINIMIZED_CURVE_STRIP )
		{
			pTheCurveStripState = GetCurveStripState( bCCType, wRPNType );

			if( pTheCurveStripState == NULL )
			{
				pCurveStrip->Release();
				return E_FAIL;
			}
		}

		// Add this strip to the list of PianoRoll CurveStrips
		m_lstCurveStrips.AddTail( pCurveStrip );
	
		// Determine proper position for the new CurveStrip
		DWORD dwPosition = DeterminePositionForCurveStrip( bCCType, wRPNType );

		// Add Curve Strip to the Timeline
		m_pSequenceMgr->m_pTimeline->InsertStripAtPos( (IDMUSProdStrip *)pCurveStrip, dwPosition );

		VARIANT var;
		
		// Set Curve Strip StripView
		if( m_CurveStripView == SV_MINIMIZED )
		{
			ASSERT( bCCType == CCTYPE_MINIMIZED_CURVE_STRIP );

			var.vt = VT_I4;
			V_I4(&var) = m_CurveStripView;
			m_pSequenceMgr->m_pTimeline->StripSetTimelineProperty( (IDMUSProdStrip *)pCurveStrip, STP_STRIPVIEW, var );
		}

		if( bCCType != CCTYPE_MINIMIZED_CURVE_STRIP )
		{
			// Set Curve Strip Height
			var.vt = VT_I4;
			V_I4(&var) = pTheCurveStripState->m_nStripHeight;
			m_pSequenceMgr->m_pTimeline->StripSetTimelineProperty( (IDMUSProdStrip *)pCurveStrip, STP_HEIGHT, var );
		}

		return S_OK;
	}

	return E_FAIL;
}


/////////////////////////////////////////////////////////////////////////////
// CSequenceStrip::AddCurveStrips
	
HRESULT CSequenceStrip::AddCurveStrips( void )
{
	HRESULT hr = S_OK;

	// Only add curve strips when PianoRoll is not minimized
	if( m_svView == SV_NORMAL )
	{
		if( m_CurveStripView == SV_MINIMIZED )
		{
			hr = AddCurveStrip( CCTYPE_MINIMIZED_CURVE_STRIP, 0 );
		}
		else
		{
			ioCurveStripState* pCurveStripState;

			POSITION pos = m_lstCurveStripStates.GetHeadPosition();
			while( pos )
			{
				pCurveStripState = m_lstCurveStripStates.GetNext( pos );

				// There should not be a CurveStripState for a minimized CurveStrip!
				ASSERT( pCurveStripState->m_bCCType != CCTYPE_MINIMIZED_CURVE_STRIP );

				hr = AddCurveStrip( pCurveStripState->m_bCCType, pCurveStripState->m_wRPNType );
				if( FAILED ( hr ) )
				{
					break;
				}
			}
		}
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CSequenceStrip::RemoveCurveStrip
	
HRESULT CSequenceStrip::RemoveCurveStrip( CCurveStrip* pCurveStrip )
{
	ASSERT( m_pSequenceMgr != NULL );
	ASSERT( m_pSequenceMgr->m_pTimeline != NULL );

	// Remove from list of Curve Strips
	POSITION pos = m_lstCurveStrips.Find( pCurveStrip );
	if( pos )
	{
		m_lstCurveStrips.RemoveAt( pos );

		// If not doing gutter selection, unselect all curves
		if( !m_bGutterSelected )
		{
			pCurveStrip->SelectAllCurves( FALSE );
		}

		pCurveStrip->Release();
	}

	// Remove Curve Strip from the Timeline
	m_pSequenceMgr->m_pTimeline->RemoveStrip( (IDMUSProdStrip *)pCurveStrip );

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CSequenceStrip::OnDeleteCurveStrip
	
HRESULT CSequenceStrip::OnDeleteCurveStrip( CCurveStrip* pCurveStrip )
{
	ASSERT( m_pSequenceMgr != NULL );

	ioCurveStripState* pCurveStripState;

	// Remove from list of Curve Strip states
	POSITION pos = m_lstCurveStripStates.GetHeadPosition();
	while( pos )
	{
		pCurveStripState = m_lstCurveStripStates.GetNext( pos );

		if( pCurveStripState->m_bCCType == pCurveStrip->m_bCCType )
		{
			if( (pCurveStripState->m_bCCType == CCTYPE_NRPN_CURVE_STRIP)
			||	(pCurveStripState->m_bCCType == CCTYPE_RPN_CURVE_STRIP) )
			{
				if( pCurveStripState->m_wRPNType == pCurveStrip->m_wRPNType )
				{
					POSITION pos2 = m_lstCurveStripStates.Find( pCurveStripState );
					if( pos2 )
					{
						m_lstCurveStripStates.RemoveAt( pos2 );
						delete pCurveStripState;
					}

					break;
				}
			}
			else
			{
				POSITION pos2 = m_lstCurveStripStates.Find( pCurveStripState );
				if( pos2 )
				{
					m_lstCurveStripStates.RemoveAt( pos2 );
					delete pCurveStripState;
				}

				break;
			}
		}
	}

	// Remove from list of Curve Strips
	pCurveStrip->DeleteAllCurves();
	RemoveCurveStrip( pCurveStrip );

	// Insert minimized CurveStrip if there are no other CurveStrips
	if( m_lstCurveStripStates.IsEmpty() )
	{
		m_CurveStripView = SV_MINIMIZED;
		AddCurveStrips();
	}

	// Let the object know about the changes
	m_nLastEdit = IDS_UNDO_DELETE_CC_TRACK;
	m_pSequenceMgr->OnDataChanged(); 

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CSequenceStrip::OnNewCurveStrip
	
HRESULT CSequenceStrip::OnNewCurveStrip( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	ASSERT( m_pSequenceMgr != NULL );
	ASSERT( m_pSequenceMgr->m_pTimeline != NULL );

	HRESULT hr = E_FAIL;

	// Have user select the type of CC strip
	CDialogNewCCTrack dlgNewCCTrack;
	dlgNewCCTrack.m_pfCurveStripExists = CSequenceStrip::CurveStripExists;
	dlgNewCCTrack.m_pVoid = this;
	if( dlgNewCCTrack.DoModal() == IDCANCEL )
	{
		return S_FALSE;
	}

	if( m_CurveStripView == SV_MINIMIZED )
	{
		if( GetCurveStripState( dlgNewCCTrack.m_bCCType, dlgNewCCTrack.m_wRPNType ) )
		{
			// Redraw minimized strip
			InvalidateCurveStrips();

			hr = S_OK;
		}
	}
	else
	{
		// Add the Curve Strip
		hr = AddCurveStrip( dlgNewCCTrack.m_bCCType, dlgNewCCTrack.m_wRPNType );
	}

	if( hr == S_OK )
	{
		// Let the object know about the changes
		m_nLastEdit = IDS_UNDO_ADD_CC_TRACK;
		m_pSequenceMgr->OnDataChanged(); 
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CSequenceStrip::DeterminePositionForCurveStrip
	
DWORD CSequenceStrip::DeterminePositionForCurveStrip( BYTE bCCType, WORD wRPNType)
{
	ASSERT( m_pSequenceMgr != NULL );
	ASSERT( m_pSequenceMgr->m_pTimeline != NULL );

	WORD wCCTypeSortValue = GetCCTypeSortValue( bCCType, wRPNType );

	VARIANT var;

	if( SUCCEEDED( m_pSequenceMgr->m_pTimeline->StripGetTimelineProperty((IDMUSProdStrip *)this, STP_POSITION, &var) ) )
	{
		CCurveStrip* pCurveStrip;
		IDMUSProdStrip* pIStrip;
		VARIANT varClsid;
		CLSID clsid;

		DWORD dwPosition = V_I4(&var);

		BOOL fContinue = TRUE;

		while( fContinue  &&  SUCCEEDED( m_pSequenceMgr->m_pTimeline->EnumStrip( ++dwPosition, &pIStrip ) ) )
		{
			varClsid.vt = VT_BYREF;
			V_BYREF(&varClsid) = &clsid;
			fContinue = FALSE;

			// Is this strip a Curve or Sequence strip?
			if( SUCCEEDED ( pIStrip->GetStripProperty( (STRIPPROPERTY) PRIVATE_SP_CLSID, &varClsid ) ) )
			{
				if( ::IsEqualCLSID( clsid, CLSID_DirectMusicSeqTrack ) )
				{
					// Is this a curve strip?
					if( SUCCEEDED ( pIStrip->GetStripProperty( SP_CURVESTRIP, &var ) ) )
					{
						if( V_BOOL(&var) == TRUE )
						{
							// Is this curve strip supposed to go before ours?
							pCurveStrip = (CCurveStrip *)pIStrip;

							WORD wCCTypeListSortValue = GetCCTypeSortValue( pCurveStrip->m_bCCType, pCurveStrip->m_wRPNType );
							if( wCCTypeListSortValue <= wCCTypeSortValue )
							{
								fContinue = TRUE;
							}
						}
					}
				}
			}

			pIStrip->Release();
		}

		return dwPosition;
	}

	return 0xFFFFFFFF;
}


/////////////////////////////////////////////////////////////////////////////
// CSequenceStrip::OnChangeCurveStripView

void CSequenceStrip::OnChangeCurveStripView( STRIPVIEW svNewStripView )
{
	ASSERT( m_pSequenceMgr != NULL );

	if( m_CurveStripView == svNewStripView )
	{
		return;
	}

	CCurveStrip *pCurveStrip;

	// Don't allow SV_NORMAL when there are no CurveStripStates
	if( svNewStripView == SV_NORMAL
	&&  m_lstCurveStripStates.IsEmpty() )
	{
		m_CurveStripView = SV_MINIMIZED;

		VARIANT var;
		var.vt = VT_I4;
		V_I4(&var) = m_CurveStripView;

		POSITION pos = m_lstCurveStrips.GetHeadPosition();
		while( pos )
		{
			pCurveStrip = m_lstCurveStrips.GetNext( pos );
			m_pSequenceMgr->m_pTimeline->StripSetTimelineProperty( (IDMUSProdStrip *)pCurveStrip, STP_STRIPVIEW, var );
		}

		return;
	}

	// Change Curve StripView field
	m_CurveStripView = svNewStripView;

	// Remove all existing Curve Strips
	while( m_lstCurveStrips.IsEmpty() == FALSE )
	{
		pCurveStrip = static_cast<CCurveStrip*>( m_lstCurveStrips.GetHead() );
		RemoveCurveStrip( pCurveStrip );
	}

	// Add new Curve Strips
	AddCurveStrips();

	// Let the object know about the changes
	m_pSequenceMgr->m_fDirty = TRUE;
	if( m_CurveStripView == SV_NORMAL )
	{
		m_nLastEdit = IDS_UNDO_CURVE_MAXIMIZE;
	}
	else // m_CurveStripView == SV_MINIMIZED
	{
		m_nLastEdit = IDS_UNDO_CURVE_MINIMIZE;
	}

	// Fix 27283: Don't store Undo states for Minimize/Maximize events

	// Check if TP_FREEZE_UNDO is NOT set.
	BOOL fFreezeUndo = FALSE;
	VARIANT var;
	if( SUCCEEDED( m_pSequenceMgr->m_pTimeline->GetTimelineProperty( TP_FREEZE_UNDO, &var ) ) )
	{
		fFreezeUndo = V_BOOL(&var);
	}

	if( !fFreezeUndo )
	{
		// Need to set TP_FREEZE_UNDO or the segment will add an undo state for us
		var.vt = VT_BOOL;
		V_BOOL(&var) = TRUE;
		m_pSequenceMgr->m_pTimeline->SetTimelineProperty( TP_FREEZE_UNDO, var );
	}

	// No need to update performance engine
	m_pSequenceMgr->m_fUpdateDirectMusic = FALSE;
	m_pSequenceMgr->OnDataChanged(); 

	if( !fFreezeUndo )
	{
		// Need to reset TP_FREEZE_UNDO or the segment will add an undo state for us
		var.vt = VT_BOOL;
		V_BOOL(&var) = FALSE;
		m_pSequenceMgr->m_pTimeline->SetTimelineProperty( TP_FREEZE_UNDO, var );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CSequenceStrip::InvalidateCurveStrips

void CSequenceStrip::InvalidateCurveStrips( void )
{
	ASSERT( m_pSequenceMgr != NULL );
	ASSERT( m_pSequenceMgr->m_pTimeline != NULL );

	CCurveStrip* pCurveStrip;

    POSITION pos = m_lstCurveStrips.GetHeadPosition();
    while( pos )
    {
        pCurveStrip = m_lstCurveStrips.GetNext( pos );
		m_pSequenceMgr->m_pTimeline->StripInvalidateRect( (IDMUSProdStrip*)pCurveStrip, NULL, TRUE );
		pCurveStrip->RefreshCurvePropertyPage();
    }
}


/////////////////////////////////////////////////////////////////////////////
// CSequenceStrip::SaveCurveStripStateData

HRESULT CSequenceStrip::SaveCurveStripStateData( IDMUSProdRIFFStream* pIRiffStream )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	HRESULT hr = S_OK;
	MMCKINFO ck;
	DWORD dwBytesWritten;
	POSITION pos;

    IStream* pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );
	if( pIStream == NULL )
	{
		return E_INVALIDARG;
	}
	
	// Write global CurveStripState information
	{
		ioGlobalCurveStripState oGlobalCurveStripState;

		// Write global CurveStripState chunk header
		ck.ckid = DMUS_FOURCC_ALLCURVES_UI_CHUNK;
		if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}

		// Prepare ioGlobalCurveStripState structure
		memset( &oGlobalCurveStripState, 0, sizeof(ioGlobalCurveStripState) );
		
		oGlobalCurveStripState.m_nCurveStripView = m_CurveStripView;

		// Write global CurveStripState chunk data
		hr = pIStream->Write( &oGlobalCurveStripState, sizeof(ioGlobalCurveStripState), &dwBytesWritten);
		if( FAILED( hr )
		||  dwBytesWritten != sizeof(ioGlobalCurveStripState) )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}

		if( pIRiffStream->Ascend(&ck, 0) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}
	}

	ioCurveStripState* pCurveStripState;

	// Write CurveStripState information for each CurveStrip
	pos = m_lstCurveStripStates.GetHeadPosition();
	while( pos != NULL )
	{
		pCurveStripState = m_lstCurveStripStates.GetNext( pos );

		// Write CurveStripState chunk header
		ck.ckid = DMUS_FOURCC_CURVE_UI_CHUNK;
		if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}

		// Write CurveStripState chunk data
		hr = pIStream->Write( pCurveStripState, sizeof(ioCurveStripState), &dwBytesWritten);
		if( FAILED( hr )
		||  dwBytesWritten != sizeof(ioCurveStripState) )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}

		if( pIRiffStream->Ascend(&ck, 0) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}
	
	}

ON_ERROR:
	pIStream->Release();
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CSequenceStrip::UpdateCurveStripGutterSelection

void CSequenceStrip::UpdateCurveStripGutterSelection( BOOL fChanged )
{
	ASSERT( m_pSequenceMgr != NULL );
	ASSERT( m_pSequenceMgr->m_pTimeline != NULL );

	CCurveStrip* pCurveStrip;

    POSITION pos = m_lstCurveStrips.GetHeadPosition();
    while( pos )
    {
        pCurveStrip = m_lstCurveStrips.GetNext( pos );

		pCurveStrip->OnGutterSelectionChange( fChanged );
    }
}


/////////////////////////////////////////////////////////////////////////////
// CSequenceStrip::SelectEventsBetweenTimes

BOOL CSequenceStrip::SelectEventsBetweenTimes( long lStart, long lEnd )
{
	BOOL fChange = FALSE;

	if( lEnd < lStart )
	{
		long lTmp = lStart;
		lStart = lEnd;
		lEnd = lTmp;
	}

	// m_pActiveNote will be updated by the method UpdateSelectionState, called
	// if any of the item's selection state changes
	POSITION pos = m_pSequenceMgr->m_lstSequences.GetHeadPosition();
	while( pos )
	{
		CSequenceItem *pSeqItem = m_pSequenceMgr->m_lstSequences.GetNext( pos );
		if( ( lStart <= pSeqItem->AbsTime() ) &&
			( lEnd >= pSeqItem->AbsTime() ) )
		{
			if( !pSeqItem->m_fSelected )
			{
				pSeqItem->m_fSelected = TRUE;
				fChange = TRUE;
			}
		}
		else if( pSeqItem->m_fSelected )
		{
			pSeqItem->m_fSelected = FALSE;
			fChange = TRUE;
		}
	}

	if( fChange )
	{
		UpdateSelectionState();
	}

	pos = m_pSequenceMgr->m_lstCurves.GetHeadPosition();
	while( pos )
	{
		CCurveItem *pCurveItem = m_pSequenceMgr->m_lstCurves.GetNext( pos );

		// Only update curve item if its strip was clicked on
		if( (m_bSelectionCC != CurveTypeToStripCCType(pCurveItem))
		||	(m_wSelectionParamType != pCurveItem->m_wParamType) )
		{
			if( ( lStart <= pCurveItem->AbsTime() ) &&
				( lEnd >= pCurveItem->AbsTime() ) )
			{
				if( !pCurveItem->m_fSelected )
				{
					pCurveItem->m_fSelected = TRUE;
					fChange = TRUE;
				}
			}
			else if( pCurveItem->m_fSelected )
			{
				pCurveItem->m_fSelected = FALSE;
				fChange = TRUE;
			}
		}
	}

	return fChange;
}

int CSequenceStrip::PositionToMIDIValue( long lYPos )
{
	if( m_fHybridNotation )
	{
		// Convert from ypos to a scale position (with B10 as 0)
		long lValue = 1 + ((2 * (lYPos + m_lMaxNoteHeight / 4)) / m_lMaxNoteHeight);

		// Convert from a scale position to a MIDI value
		return 120 - (lValue / 7) * 12 + aScaleToChromNat[6 - (lValue % 7)] + m_aiScalePattern[6 - (lValue % 7)];
	}
	else
	{
		return 127 - (lYPos / m_lMaxNoteHeight);
	}
}


/////////////////////////////////////////////////////////////////////////////
// CSequenceStrip::GetFirstVisibleNote

POSITION CSequenceStrip::GetFirstVisibleNote( long lStartTime, long lEndTime, int nTopNote, int nBottomNote )
{
	POSITION pos2, pos = m_pSequenceMgr->m_lstSequences.GetHeadPosition();
	while( pos )
	{
		pos2 = pos;
		const CSequenceItem *pSequenceItem = m_pSequenceMgr->m_lstSequences.GetNext( pos );
		// Check vertical range, then horizontal range
		if ( (pSequenceItem->m_bByte1 <= nTopNote)
		&&	 (pSequenceItem->m_bByte1 >= nBottomNote)
		&&	 ((pSequenceItem->AbsTime() + pSequenceItem->m_mtDuration > lStartTime) ||
			  ((pSequenceItem->AbsTime() < 0) && (pSequenceItem->m_mtDuration > lStartTime)))
		&&	 (pSequenceItem->AbsTime() < lEndTime) )
		{
			return pos2;
		}
	}
	return NULL;
}


/////////////////////////////////////////////////////////////////////////////
// CSequenceStrip::InitializeScaleAccidentals

void CSequenceStrip::InitializeScaleAccidentals( void )
{
	for( int i=0; i < 10; i++ )
	{
		memcpy( &(m_aiAccidentals[i * 7]), m_aiScalePattern, sizeof(int) * 7);
	}

	memcpy( &(m_aiAccidentals[70]), m_aiScalePattern, sizeof(int) * 5);
}

/////////////////////////////////////////////////////////////////////////////
// CSequenceStrip::UpdateKeyPattern

void CSequenceStrip::UpdateKeyPattern( void )
{
	ZeroMemory( m_aiScalePattern, sizeof(int) * 7 );
	if( m_pSequenceMgr->m_fDisplayingFlats )
	{
		// Set the # of flats
		for( int i=0; i < m_pSequenceMgr->m_nNumAccidentals; i++ )
		{
			// Cirlce of fourths
			m_aiScalePattern[(6 + i * 3) % 7] = -1;
		}

		// Set the Key Root to the chosen accidental
		// (Say they want 3b with key of E - then this resets Eb back to Enat)
		m_aiScalePattern[aChromToScaleFlats[m_pSequenceMgr->m_nKeyRoot]] = aChromToFlatAccidentals[m_pSequenceMgr->m_nKeyRoot];
	}
	else
	{
		// Set the # of sharps
		for( int i=0; i < m_pSequenceMgr->m_nNumAccidentals; i++ )
		{
			// Cirlce of fifths
			m_aiScalePattern[(3 + i * 4) % 7] = 1;
		}

		// Set the Key Root to the chosen accidental
		// (Say they want 2# with key of F - then this resets F# back to Fnat)
		m_aiScalePattern[aChromToScaleSharps[m_pSequenceMgr->m_nKeyRoot]] = aChromToSharpAccidentals[m_pSequenceMgr->m_nKeyRoot];
	}
}

/////////////////////////////////////////////////////////////////////////////
// CSequenceStrip::InvalidateFunctionBar

void CSequenceStrip::InvalidateFunctionBar( void )
{
	if ( m_svView == SV_MINIMIZED )
	{
		InvalidateStrip();
		return;
	}

	// Invalidate the function bar
	VARIANT var;
	var.vt = VT_I4;
	if (FAILED(m_pSequenceMgr->m_pTimeline->StripGetTimelineProperty( (IDMUSProdStrip *)this, STP_HEIGHT, &var )))
	{
		InvalidateStrip();
		return;
	}

	RECT rect;
	rect.right = 0;
	rect.top = m_lVScroll;
	rect.bottom = m_lVScroll + V_I4(&var);
	if( FAILED(m_pSequenceMgr->m_pTimeline->GetTimelineProperty( TP_FUNCTIONBAR_WIDTH, &var )) )
	{
		InvalidateStrip();
		return;
	}
	rect.left = -V_I4(&var);

	long lLeftDisplay;
	m_pSequenceMgr->m_pTimeline->GetMarkerTime( MARKER_LEFTDISPLAY, TIMETYPE_CLOCKS, &lLeftDisplay );
	m_pSequenceMgr->m_pTimeline->ClocksToPosition( lLeftDisplay, &lLeftDisplay );
	rect.left  += lLeftDisplay;
	rect.right += lLeftDisplay;

	// Really invalidate the function bar
	m_pSequenceMgr->m_pTimeline->StripInvalidateRect( (IDMUSProdStrip*)this, &rect, FALSE );
}

/////////////////////////////////////////////////////////////////////////////
// CSequenceStrip::InvalidatePianoRoll

void CSequenceStrip::InvalidatePianoRoll( void )
{
	if ( m_svView == SV_MINIMIZED )
	{
		InvalidateStrip();
		return;
	}

	// Invalidate the piano roll
	RECT rect;
	long lLeftDisplay;
	m_pSequenceMgr->m_pTimeline->GetMarkerTime( MARKER_LEFTDISPLAY, TIMETYPE_CLOCKS, &lLeftDisplay );
	m_pSequenceMgr->m_pTimeline->ClocksToPosition( lLeftDisplay, &lLeftDisplay );
	rect.left = lLeftDisplay;
	rect.top = m_lVScroll;
	
	// Find the right and bottom boundaries of our strip					
	CDC cDC;
	VARIANT var;
	var.vt = VT_I4;
	if( FAILED(m_pSequenceMgr->m_pTimeline->StripGetTimelineProperty( (IDMUSProdStrip *)this, STP_GET_HDC, &var )) )
	{
		return;
	}
	CWnd *pWnd = NULL;
	if( cDC.Attach( (HDC)(V_I4(&var)) ) != 0 )
	{
		RECT	rtStrip;
		
		cDC.GetClipBox( &rtStrip );
		rect.right = lLeftDisplay + rtStrip.right + 1;
		pWnd = cDC.GetWindow();
		cDC.Detach();
	}
	if( pWnd )
	{
		::ReleaseDC( pWnd->GetSafeHwnd(), (HDC)(V_I4(&var)) );
	}
	else
	{
		::ReleaseDC( NULL, (HDC)(V_I4(&var)) );
	}

	if (SUCCEEDED(m_pSequenceMgr->m_pTimeline->StripGetTimelineProperty( (IDMUSProdStrip *)this, STP_HEIGHT, &var )))
	{
		rect.bottom = m_lVScroll + V_I4(&var);
	}

	// Really invalidate the piano roll
	// Don't need to erase, since the horizontal bars will overwrite the area
	m_pSequenceMgr->m_pTimeline->StripInvalidateRect( (IDMUSProdStrip*)this, &rect, FALSE );
}

/////////////////////////////////////////////////////////////////////////////
// CSequenceStrip::InvalidateStrip

void CSequenceStrip::InvalidateStrip( void )
{
	m_pSequenceMgr->m_pTimeline->StripInvalidateRect( this, NULL, FALSE );
}

/////////////////////////////////////////////////////////////////////////////
// CSequenceStrip::DrawSymbol

void CSequenceStrip::DrawSymbol( HDC hDC, const TCHAR *pstrText, int iHybridPos, long lRightPos, long lTopAdjust, long lBottomAdjust )
{
	// Get position to draw at
	RECT rectNote;
	GetHybridRect( &rectNote, iHybridPos, 127, 0, 0 );
	rectNote.top -= lTopAdjust;
	rectNote.bottom += lBottomAdjust;
	rectNote.left = lRightPos - (m_lMaxNoteHeight * 3) / 2;
	rectNote.right = lRightPos;

	// Draw sharp in treble clef
	::DrawText( hDC, pstrText, 1, &rectNote, DT_RIGHT | DT_VCENTER | DT_SINGLELINE | DT_NOPREFIX);
}

/////////////////////////////////////////////////////////////////////////////
// CSequenceStrip::AdjustScroll

void CSequenceStrip::AdjustScroll(long lXPos, long lYPos)
{
	VARIANT var;
	long lHeight = 0;
	if (SUCCEEDED(m_pSequenceMgr->m_pTimeline->StripGetTimelineProperty((IDMUSProdStrip *)this, STP_HEIGHT, &var)))
	{
		lHeight = V_I4(&var);
	}

	long lMaxHeight;
	if( m_fHybridNotation )
	{
		lMaxHeight = 38 * m_lMaxNoteHeight;
	}
	else
	{
		lMaxHeight = 128 * m_lMaxNoteHeight;
	}

	if ((lYPos < m_lVScroll) && (m_lVScroll > 0))
	{
		// Start Scroll up
		EnableTimer();
	}
	else if ( (lHeight > 0) && (lYPos > m_lVScroll + lHeight) &&
			  (m_lVScroll < lMaxHeight) )
	{
		// Start Scroll down
		EnableTimer();
	}
	else
	{
		// Check horizontal ranges

		// Get current scroll position
		long lHScroll = 0;
		if( SUCCEEDED( m_pSequenceMgr->m_pTimeline->GetTimelineProperty( TP_HORIZONTAL_SCROLL, &var ) ) )
		{
			lHScroll = V_I4(&var);
		}

		if ((lXPos < lHScroll) && (lHScroll > 0))
		{
			// Start Scroll left
			EnableTimer();
		}
		else
		{
			// Get rectangle defining strip position
			var.vt = VT_BYREF;
			RECT rectStrip;
			rectStrip.left = 0;
			rectStrip.right = 0;
			V_BYREF(&var) = &rectStrip;
			m_pSequenceMgr->m_pTimeline->StripGetTimelineProperty((IDMUSProdStrip *)this, STP_STRIP_RECT, &var);

			// Compute the right side of the display
			long lMaxScreenPos = lHScroll + rectStrip.right - rectStrip.left;

			// Compute the maximum scroll position
			long lMaxHScroll = 0;
			m_pSequenceMgr->m_pTimeline->ClocksToPosition( m_mtLength, &lMaxHScroll );

			lMaxHScroll -= rectStrip.right - rectStrip.left;

			// Check for need to scroll right
			if( (lHScroll < lMaxHScroll) && (lXPos > lMaxScreenPos) )
			{
				// Start Scroll right
				EnableTimer();
			}
			else
			{
				// Mouse withing screen position - disable timer
				KillTimer();
			}
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CSequenceStrip::OnTimer

void CSequenceStrip::OnTimer( void )
{
	POINT point;
	if( ::GetCursorPos( &point ) && SUCCEEDED(m_pSequenceMgr->m_pTimeline->ScreenToStripPosition((IDMUSProdStrip *)this, &point)) )
	{
		// SEQ_MM_ACTIVERESIZE_END also?
		if( (m_MouseMode == SEQ_MM_ACTIVEMOVE)
		||	(m_MouseMode == SEQ_MM_ACTIVERESIZE_END)
		||	(m_MouseMode == SEQ_MM_ACTIVERESIZE_START) )
		{
			OnMouseMove( point.x, point.y );
		}

		// Get the height of the strip
		VARIANT var;
		long lHeight = 0;
		if (SUCCEEDED(m_pSequenceMgr->m_pTimeline->StripGetTimelineProperty((IDMUSProdStrip *)this, STP_HEIGHT, &var)))
		{
			lHeight = V_I4(&var);
		}

		// Calculate the maximum scroll position
		long lMaxVScroll;
		if( m_fHybridNotation )
		{
			lMaxVScroll = 38 * m_lMaxNoteHeight;
		}
		else
		{
			lMaxVScroll = 128 * m_lMaxNoteHeight;
		}

		if ((point.y < m_lVScroll) && (m_lVScroll > 0))
		{
			// Scroll up
			SetVScroll( max( 0, m_lVScroll - SCROLL_VERT_AMOUNT * ((SCROLL_VERT_RANGE + m_lVScroll - point.y) / SCROLL_VERT_RANGE) ) );
		}
		else if ( (lHeight > 0) && (point.y > m_lVScroll + lHeight) &&
				  (m_lVScroll < lMaxVScroll) )
		{
			// Scroll down
			SetVScroll( min( lMaxVScroll, m_lVScroll + SCROLL_VERT_AMOUNT * ((SCROLL_VERT_RANGE + point.y - m_lVScroll - lHeight) / SCROLL_VERT_RANGE) ) );
		}

		// Update horizontal scroll, if necessary
		long lHScroll = 0;
		if( SUCCEEDED( m_pSequenceMgr->m_pTimeline->GetTimelineProperty( TP_HORIZONTAL_SCROLL, &var ) ) )
		{
			lHScroll = V_I4(&var);
		}

		// Check for need to scroll left
		if( (lHScroll > 0) && (point.x < lHScroll) )
		{
			// Scroll left
			var.vt = VT_I4;
			V_I4(&var) = max( lHScroll - SCROLL_HORIZ_AMOUNT * ((SCROLL_HORIZ_RANGE + lHScroll - point.x) / SCROLL_HORIZ_RANGE), 0 );
			m_pSequenceMgr->m_pTimeline->SetTimelineProperty( TP_HORIZONTAL_SCROLL, var );

			// No more checks necessary - return
			return;
		}

		// Get rectangle defining strip position
		var.vt = VT_BYREF;
		RECT rectStrip;
		V_BYREF(&var) = &rectStrip;
		if ( SUCCEEDED( m_pSequenceMgr->m_pTimeline->StripGetTimelineProperty((IDMUSProdStrip *)this, STP_STRIP_RECT, &var) ) )
		{
			// Compute the right side of the display
			long lMaxScreenPos = lHScroll + rectStrip.right - rectStrip.left;

			// Compute the maximum scroll position
			long lMaxHScroll;
			if( SUCCEEDED( m_pSequenceMgr->m_pTimeline->ClocksToPosition( m_mtLength, &lMaxHScroll ) ) )
			{
				lMaxHScroll -= rectStrip.right - rectStrip.left;

				// Check for need to scroll right
				if( (lHScroll < lMaxHScroll) && (point.x > lMaxScreenPos) )
				{
					// Scroll right
					var.vt = VT_I4;
					V_I4(&var) = min( lHScroll + SCROLL_HORIZ_AMOUNT * ((SCROLL_HORIZ_RANGE + point.x - lMaxScreenPos) / SCROLL_HORIZ_RANGE), lMaxHScroll);
					m_pSequenceMgr->m_pTimeline->SetTimelineProperty( TP_HORIZONTAL_SCROLL, var );

					// No more checks necessary - return
					return;
				}
			}
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CSequenceStrip::KillTimer

void CSequenceStrip::KillTimer( void )
{
	if( m_fScrollTimerActive )
	{
		HWND hwnd = GetTimelineHWnd();
		if( hwnd )
		{
			::KillTimer(hwnd, 1);
			m_fScrollTimerActive = FALSE;
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CSequenceStrip::EnableTimer

void CSequenceStrip::EnableTimer( void )
{
	if( !m_fScrollTimerActive )
	{
		HWND hwnd = GetTimelineHWnd();
		if( hwnd )
		{
			::SetTimer(hwnd, 1, 100, NULL);
			m_fScrollTimerActive = TRUE;
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CSequenceStrip::ApplyUIChunk

void CSequenceStrip::ApplyUIChunk( const ioSeqStripDesign *pSeqStripDesign )
{
	ASSERT( pSeqStripDesign );
	if( !pSeqStripDesign )
	{
		return;
	}

	BOOL fChanged = FALSE;
	if ( pSeqStripDesign->m_crUnselectedNoteColor != m_crUnselectedNoteColor )
	{
		fChanged = TRUE;
		m_crUnselectedNoteColor = pSeqStripDesign->m_crUnselectedNoteColor;
	}
	if ( pSeqStripDesign->m_crSelectedNoteColor != m_crSelectedNoteColor )
	{
		fChanged = TRUE;
		m_crSelectedNoteColor = pSeqStripDesign->m_crSelectedNoteColor;
	}
	if ( pSeqStripDesign->m_crOverlappingNoteColor != m_crOverlappingNoteColor )
	{
		fChanged = TRUE;
		m_crOverlappingNoteColor = pSeqStripDesign->m_crOverlappingNoteColor;
	}
	if ( pSeqStripDesign->m_crAccidentalColor != m_crAccidentalColor )
	{
		fChanged = TRUE;
		m_crAccidentalColor = pSeqStripDesign->m_crAccidentalColor;
	}

	if ( pSeqStripDesign->m_fHybridNotation != m_fHybridNotation )
	{
		fChanged = TRUE;
		m_fHybridNotation = pSeqStripDesign->m_fHybridNotation;
	}
	if ( pSeqStripDesign->m_dblVerticalZoom != m_dblVerticalZoom )
	{
		fChanged = TRUE;
		m_dblVerticalZoom = pSeqStripDesign->m_dblVerticalZoom;
		m_lMaxNoteHeight = long( MAX_NOTE_HEIGHT * m_dblVerticalZoom + HORIZ_LINE_HEIGHT );
	}
	if ( (pSeqStripDesign->m_lVScroll >= 0) &&
		 (pSeqStripDesign->m_lVScroll != m_lVScroll) )
	{
		fChanged = TRUE;
		SetVScroll( pSeqStripDesign->m_lVScroll );
	}

	VARIANT var;
	m_pSequenceMgr->m_pTimeline->StripGetTimelineProperty( (IDMUSProdStrip*)this, STP_HEIGHT, &var );
	ASSERT(	var.vt == VT_I4 );
	if ( pSeqStripDesign->m_lHeight != V_I4(&var) )
	{
		fChanged = TRUE;
		var.vt = VT_I4;
		V_I4(&var) = pSeqStripDesign->m_lHeight;
		m_pSequenceMgr->m_pTimeline->StripSetTimelineProperty( (IDMUSProdStrip*)this, STP_HEIGHT, var );

		// Resize the vertical scroll bar
		OnSize();
	}
	m_pSequenceMgr->m_pTimeline->StripGetTimelineProperty( (IDMUSProdStrip*)this, STP_STRIPVIEW, &var );
	ASSERT(	var.vt == VT_I4 );
	if ( pSeqStripDesign->m_svView != m_svView ||
		 pSeqStripDesign->m_svView != V_I4(&var) )
	{
		fChanged = TRUE;
		m_svView = pSeqStripDesign->m_svView;

		// Tell the Timeline what our stripview currently is
		var.vt = VT_I4;
		V_I4(&var) = pSeqStripDesign->m_svView;
		m_pSequenceMgr->m_pTimeline->StripSetTimelineProperty( (IDMUSProdStrip*)this, STP_STRIPVIEW, var );
	}

	// Show/Hide the scrollbar appropriately
	if( m_svView == SV_NORMAL )
	{
		m_VScrollBar.ShowWindow(TRUE);
	}
	else // m_svView == SV_MINIMIZED
	{
		m_VScrollBar.ShowWindow(FALSE);
	}

	// Set number of extension bars
	if( m_dwExtraBars != pSeqStripDesign->m_dwExtraBars )
	{
		m_dwExtraBars = pSeqStripDesign->m_dwExtraBars;
		fChanged = TRUE;
	}

	// Set whether or not to display pickup bar
	if( m_fPickupBar != pSeqStripDesign->m_fPickupBar )
	{
		m_fPickupBar = pSeqStripDesign->m_fPickupBar;
		fChanged = TRUE;
	}

	// Set scroll bar range, page size, and screen position
	UpdateVScroll();

	// Update name (needs to happen here so the correct name is displayed when the
	// strip is first added).
	UpdateName();

	if ( fChanged )
	{
		//BUGBUG: should be smarter about what we invalidate here..
		InvalidateStrip();
	}
}

/////////////////////////////////////////////////////////////////////////////
// CSequenceStrip::UpdateSequenceUIChunk
//
// Update design state data structure (m_pSequenceMgr->m_SeqStripDesign).
//
void CSequenceStrip::UpdateSequenceUIChunk()
{
	// fill the structure with data
	if( m_pSequenceMgr->m_pTimeline )
	{
		VARIANT var;
		if( SUCCEEDED( m_pSequenceMgr->m_pTimeline->StripGetTimelineProperty((IDMUSProdStrip*)this, STP_HEIGHT, &var) ) )
		{
			m_pSequenceMgr->m_SeqStripDesign.m_lHeight = V_I4(&var);
		}
	}

	m_pSequenceMgr->m_SeqStripDesign.m_lVScroll = m_lVScroll;
	m_pSequenceMgr->m_SeqStripDesign.m_svView = m_svView;
	m_pSequenceMgr->m_SeqStripDesign.m_fHybridNotation = m_fHybridNotation;
	m_pSequenceMgr->m_SeqStripDesign.m_dblVerticalZoom = m_dblVerticalZoom;
	m_pSequenceMgr->m_SeqStripDesign.m_crUnselectedNoteColor = m_crUnselectedNoteColor;
	m_pSequenceMgr->m_SeqStripDesign.m_crSelectedNoteColor = m_crSelectedNoteColor;
	m_pSequenceMgr->m_SeqStripDesign.m_crOverlappingNoteColor = m_crOverlappingNoteColor;
	m_pSequenceMgr->m_SeqStripDesign.m_crAccidentalColor = m_crAccidentalColor;
	m_pSequenceMgr->m_SeqStripDesign.m_dwPChannel = m_pSequenceMgr->m_dwPChannel;
	m_pSequenceMgr->m_SeqStripDesign.m_dwExtraBars = m_dwExtraBars;
	m_pSequenceMgr->m_SeqStripDesign.m_fPickupBar = m_fPickupBar;
}


/////////////////////////////////////////////////////////////////////////////
// CSequenceStrip::OnApp

LRESULT CSequenceStrip::OnApp( WPARAM wParam, LPARAM lParam )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( wParam == WM_APP_BUMPTIMECURSOR )
	{
		// Get the time of the time cursor
		long lTime;
		if (FAILED(m_pSequenceMgr->m_pTimeline->GetMarkerTime( MARKER_CURRENTTIME, TIMETYPE_CLOCKS, &lTime )))
		{
			return 0;
		}

		SNAPTO snapTo = GetSnapToBoundary( lTime );
		if( snapTo == SNAP_NONE )
		{
			snapTo = SNAP_GRID;
		}
		BumpTimeCursor( snapTo );
	}
	else if( wParam == WM_APP_INVALIDATEPIANOROLL )
	{
		Sleep( 50 );
		MSG msg;
		while( 0 != PeekMessage( &msg, m_VScrollBar.m_hWnd, WM_APP, WM_APP, PM_REMOVE ) )
		{
			if( msg.wParam == 0 )
			{
				OnApp( 0, 0 );
			}
		}

		const long lOldVScroll = m_lVScroll;
		EnsureNoteCursorVisible();
		if( lOldVScroll == m_lVScroll )
		{
			InvalidatePianoRoll();
		}
	}
	else if( wParam == WM_APP_INSTRUMENTMENU )
	{
		// Pointer to interface from which DLS region text can be obtained
		IDMUSProdBandEdit8a* pIBandEdit;

		// Try to get the band edit interface
		pIBandEdit = GetBandEditInterface( m_pSequenceMgr->m_pTimeline, m_pSequenceMgr->m_dwGroupBits, m_pSequenceMgr->m_dwPChannel );

		if( pIBandEdit )
		{
			pIBandEdit->DisplayInstrumentButton(m_pSequenceMgr->m_dwPChannel, GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam));
			pIBandEdit->Release();
		}

		m_fInstrumentPressed = FALSE;
		InvalidateFunctionBar();
	}
	else if( wParam == WM_APP_BANDMENU )
	{
		// Pointer to interface to display the band edit menu
		IDMUSProdBandMgrEdit* pIDMUSProdBandMgrEdit;

		// Try to get the band edit interface
		pIDMUSProdBandMgrEdit = GetBandMgrEditInterface( m_pSequenceMgr->m_pTimeline, m_pSequenceMgr->m_dwGroupBits, m_pSequenceMgr->m_dwPChannel );

		if( pIDMUSProdBandMgrEdit )
		{
			pIDMUSProdBandMgrEdit->DisplayEditBandButton(m_pSequenceMgr->m_dwPChannel, GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam));
			pIDMUSProdBandMgrEdit->Release();
		}
		else
		{
			// If no band manager, display our own menu
			HMENU hMenu, hMenuPopup;
			hMenu = ::LoadMenu( AfxGetInstanceHandle(), MAKEINTRESOURCE(IDR_BANDMENU));
			if (hMenu)
			{
				hMenuPopup = ::GetSubMenu( hMenu, 0 );
				if (hMenuPopup)
				{
					m_pSequenceMgr->m_pTimeline->TrackPopupMenu(hMenuPopup, GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam), (IDMUSProdStrip *)this, FALSE);
				}
				DestroyMenu(hMenu); // This will destroy the submenu as well.
			}
		}
		
		m_fNewBandPressed = FALSE;
		InvalidateFunctionBar();
	}

	return 0;
}


/////////////////////////////////////////////////////////////////////////////
// CSequenceStrip::BumpTimeCursor

void CSequenceStrip::BumpTimeCursor( SNAPTO snapTo )
{
	// Get the time of the time cursor
	long lTime;
	if (FAILED(m_pSequenceMgr->m_pTimeline->GetMarkerTime( MARKER_CURRENTTIME, TIMETYPE_CLOCKS, &lTime )))
	{
		return;
	}

	// Get the amount to move the note cursor and time cursor by
	long lSnapAmount = GetSnapAmount( lTime, snapTo );

	// If the Time cursor would go beyond the end of the pattern, move the cursor back to the beginning
	if( /*fBumpRight &&*/ (lTime + lSnapAmount >= m_mtLength) )
	{
		ASSERT( lSnapAmount > 0 );
		lTime %= lSnapAmount;
		m_lInsertTime = 0;

		// Force the Timeline to scroll all the way to the beginning
		m_pSequenceMgr->m_pTimeline->SetMarkerTime( MARKER_CURRENTTIME, TIMETYPE_CLOCKS, lTime );

		// Redraw
		InvalidatePianoRoll();
	}
	/*
	// If the Time cursor would go below 0, move the cursor to the end
	else if( !fBumpRight && (lTime < lSnapAmount) )
	{
		// Snap to nearest value from m_mtLength - 1
		m_pSequenceMgr->m_pTimeline->SetMarkerTime( MARKER_CURRENTTIME, TIMETYPE_CLOCKS, m_mtLength - 1 );

		// This sets m_lInsertTime to the correct value and redraws the strip, if necessary
		UpdateNoteCursorTime();

		// Snap m_lInsertTime to Bar
		long lMeasureSnap;
		m_pSequenceMgr->m_pTimeline->ClocksToMeasureBeat( m_pSequenceMgr->m_dwGroupBits, m_pSequenceMgr->m_dwIndex, m_mtLength - 1, &lMeasureSnap, NULL );
		m_pSequenceMgr->m_pTimeline->MeasureBeatToClocks( m_pSequenceMgr->m_dwGroupBits, m_pSequenceMgr->m_dwIndex, lMeasureSnap, 0, &lMeasureSnap );

		// Now reset the time cursor to the correct value
		m_pSequenceMgr->m_pTimeline->SetMarkerTime( MARKER_CURRENTTIME, TIMETYPE_CLOCKS,
			min( m_mtLength - 1, lMeasureSnap + lTime + m_lInsertTime ) );
	}
	*/
	else
	{
		long lOldInsertTime = m_lInsertTime;
		long lOldDuration = GetSnapAmount( m_lInsertTime );
		/*
		if( !fBumpRight )
		{
			lSnapAmount *= -1;
		}
		*/

		lTime += lSnapAmount;

		// Snap to nearest value from lTime
		m_pSequenceMgr->m_pTimeline->SetMarkerTime( MARKER_CURRENTTIME, TIMETYPE_CLOCKS, lTime );

		// This sets m_lInsertTime to the correct value and redraws the strip, if necessary
		UpdateNoteCursorTime( FALSE );

		// Invalidate only this note
		RECT rect;
		if( m_svView == SV_MINIMIZED )
		{
			rect.top = 0;
			rect.bottom = MINIMIZE_HEIGHT;
			m_pSequenceMgr->m_pTimeline->ClocksToPosition( min(lOldInsertTime, m_lInsertTime), &rect.left );
			m_pSequenceMgr->m_pTimeline->ClocksToPosition( max(lOldInsertTime + lOldDuration, m_lInsertTime + GetSnapAmount( m_lInsertTime )), &rect.right );
		}
		else
		{
			CSequenceItem seqItem;
			seqItem.m_bByte1 = (BYTE)m_lInsertVal;
			seqItem.m_bByte2 = 127;
			seqItem.m_mtTime = min(lOldInsertTime, m_lInsertTime);
			seqItem.m_mtDuration = max(lOldInsertTime + lOldDuration, m_lInsertTime + GetSnapAmount( m_lInsertTime )) - seqItem.m_mtTime;
			GetNoteRect( &seqItem, &rect );
			// Fix off-by-one redraw problem
			rect.right++;
			// Note marker's width is is duration or 5 pixels, whichever is more.
			rect.right = max( 5 + rect.left, rect.right );

			if( m_fHybridNotation )
			{
				// Extend to the left so the accidental is drawn
				rect.left -= ((m_lMaxNoteHeight * 3) / 2) + 2;

				// Extend to the top and bottom so the parts of the accidental that extend outside
				// the note are drawn
				rect.top -= m_lMaxNoteHeight / 2;
				rect.bottom += m_lMaxNoteHeight / 2;
			}
		}


		m_pSequenceMgr->m_pTimeline->StripInvalidateRect( this, &rect, FALSE );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CSequenceStrip::DrawNoteInsertionMark

void CSequenceStrip::DrawNoteInsertionMark( HDC hDC, MUSIC_TIME mtStartTime, MUSIC_TIME mtEndTime, long lXOffset )
{
	if( m_lInsertTime > mtEndTime )
	{
		return;
	}

	// Get the snap amount
	long lDuration = GetSnapAmount( m_lInsertTime );

	if( m_lInsertTime + lDuration  < mtStartTime )
	{
		return;
	}

	RECT rectMark;
	ComputeNoteMarkerVerticalRect( rectMark, m_fHybridNotation, m_pSequenceMgr->m_fDisplayingFlats, m_lMaxNoteHeight, m_lInsertVal );

	// Compute the mark's length
	m_pSequenceMgr->m_pTimeline->ClocksToPosition( lDuration, &rectMark.right );
	lDuration = max( rectMark.right, 5 ); // Minimum of 5 pixels wide

	// Set up the accidental font, if necessary
	if( m_fHybridNotation )
	{
		// Compute the hybrid position
		int iHybridPos;
		if( m_pSequenceMgr->m_fDisplayingFlats )
		{
			iHybridPos = MIDIToHybridPos( BYTE(m_lInsertVal), aChromToScaleFlats);
		}
		else
		{
			iHybridPos = MIDIToHybridPos( BYTE(m_lInsertVal), aChromToScaleSharps);
		}

		// Compute the accidental
		int iAccidental;
		// FLATS
		if( m_pSequenceMgr->m_fDisplayingFlats )
		{
			iAccidental = aChromToFlatAccidentals[m_lInsertVal % 12];
		}
		// SHARPS
		else
		{
			iAccidental = aChromToSharpAccidentals[m_lInsertVal % 12];
		}

		if( iAccidental != m_aiScalePattern[iHybridPos % 7] )
		{
			int nOldBkMode = ::SetBkMode( hDC, TRANSPARENT );
			COLORREF oldColor = ::SetTextColor( hDC, PIANOROLL_BLACKKEY_COLOR );
			// Create and select the font to draw the sharps and flats with
			HFONT hfontMusic = GetAccidentalFont();
			if( hfontMusic )
			{
				HFONT hNewOldFont = static_cast<HFONT>(::SelectObject( hDC, hfontMusic ));

				// Load sharp or flat text
				CString strSymbol;
				if( iAccidental < 0 )
				{
					strSymbol.LoadString(IDS_FLAT_TEXT);
				}
				else if( iAccidental > 0 )
				{
					strSymbol.LoadString(IDS_SHARP_TEXT);
				}
				else
				{
					strSymbol.LoadString(IDS_NATURAL_TEXT);
				}

				const long lTopAdjust = TOPADJUST;
				const long lBottomAdjust = BOTTOMADJUST;

				// Compute the mark's start and end position
				m_pSequenceMgr->m_pTimeline->ClocksToPosition( m_lInsertTime, &rectMark.left );

				DrawSymbol( hDC, strSymbol, iHybridPos, rectMark.left - 2 - lXOffset, lTopAdjust, lBottomAdjust );

				::SelectObject( hDC, hNewOldFont );
				::DeleteObject( hfontMusic );
			}

			// Reset the color and mode
			::SetTextColor( hDC, oldColor );
			::SetBkMode( hDC, nOldBkMode );
		}
	}

	// Compute the mark's start and end position
	m_pSequenceMgr->m_pTimeline->ClocksToPosition( m_lInsertTime, &rectMark.left );
	rectMark.left -= lXOffset;
	rectMark.right = lDuration + rectMark.left;

	int nCaps = ::GetDeviceCaps( hDC, RASTERCAPS );
	if( (nCaps & RC_BITBLT) && !(nCaps & RC_PALETTE) )
	{
		// Device support BitBlt and is not palette-based - draw transparent box
		// Calculate the source rectangle
		RECT rectNewRect;
		rectNewRect.left = 0;
		rectNewRect.top = 0;
		rectNewRect.right = rectMark.right - rectMark.left;
		rectNewRect.bottom = rectMark.bottom - rectMark.top;

		// Create the source bitmap
		HBITMAP hBitMap = ::CreateCompatibleBitmap( hDC, rectNewRect.right, rectNewRect.bottom );
		ASSERT( hBitMap );
		// Create the source DC
		HDC hNewDC = ::CreateCompatibleDC( hDC );
		HBITMAP hOldBitMap = static_cast<HBITMAP> (::SelectObject( hNewDC, hBitMap ) );
		// Draw the source bitmsp
		::SetBkColor( hNewDC, RGB(127,127,127) );
		::ExtTextOut( hNewDC, 0, 0, ETO_OPAQUE, &rectNewRect, NULL, 0, NULL);

		// Draw it
		::BitBlt( hDC, rectMark.left, rectMark.top, rectNewRect.right, rectNewRect.bottom, hNewDC, 0, 0, SRCAND);

		// Clean up
		::SelectObject( hNewDC, hOldBitMap );
		::DeleteDC( hNewDC );
		::DeleteObject( hBitMap );
	}
	else
	{
		// Device doesn't support BitBlt or is palette-based -  draw black box
		// Save the old background color
		COLORREF crOldBkColor = ::SetBkColor( hDC, ::GetNearestColor(hDC, 0) );

		// Draw it
		::ExtTextOut( hDC, 0, 0, ETO_OPAQUE, &rectMark, NULL, 0, NULL);

		// Reset the old background color
		::SetBkColor( hDC, crOldBkColor );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CSequenceStrip::UpdateNoteCursorTime

void CSequenceStrip::UpdateNoteCursorTime( BOOL fRedraw )
{
	long lTime;
	if (FAILED(m_pSequenceMgr->m_pTimeline->GetMarkerTime( MARKER_CURRENTTIME, TIMETYPE_CLOCKS, &lTime )))
	{
		return;
	}

	switch( GetSnapToBoundary( lTime ) )
	{
	case SNAP_GRID:
		// Snap to Grid
		{
			long lBeat, lGrid;
			lGrid = lTime;
			m_pSequenceMgr->m_pTimeline->ClocksToMeasureBeat( m_pSequenceMgr->m_dwGroupBits, m_pSequenceMgr->m_dwIndex, lTime, &lTime, &lBeat );
			m_pSequenceMgr->m_pTimeline->MeasureBeatToClocks( m_pSequenceMgr->m_dwGroupBits, m_pSequenceMgr->m_dwIndex, lTime, lBeat, &lTime );
			lGrid -= lTime; // lGrid is now offset from start of beat.

			long lGridClocks = GetGridClocks( lTime );
			lGrid /= lGridClocks;
			lTime += lGrid * lGridClocks;
		}
		break;
	case SNAP_BEAT:
		// Snap to Beat
		{
			long lBeat;
			m_pSequenceMgr->m_pTimeline->ClocksToMeasureBeat( m_pSequenceMgr->m_dwGroupBits, m_pSequenceMgr->m_dwIndex, lTime, &lTime, &lBeat );
			m_pSequenceMgr->m_pTimeline->MeasureBeatToClocks( m_pSequenceMgr->m_dwGroupBits, m_pSequenceMgr->m_dwIndex, lTime, lBeat, &lTime );
		}
		break;
	case SNAP_BAR:
		// Snap to Bar
		m_pSequenceMgr->m_pTimeline->ClocksToMeasureBeat( m_pSequenceMgr->m_dwGroupBits, m_pSequenceMgr->m_dwIndex, lTime, &lTime, NULL );
		m_pSequenceMgr->m_pTimeline->MeasureBeatToClocks( m_pSequenceMgr->m_dwGroupBits, m_pSequenceMgr->m_dwIndex, lTime, 0, &lTime );
		break;
	case SNAP_NONE:
		// Snap to None
		// No need to update lTime, nothing changed
		break;
	default:
		ASSERT(FALSE);
		break;
	}

	if( lTime != m_lInsertTime )
	{
		m_lInsertTime = lTime;
		if( fRedraw )
		{
			InvalidatePianoRoll();
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CSequenceStrip::GetSnapToBoundary

SNAPTO CSequenceStrip::GetSnapToBoundary( long lTime ) const
{
	VARIANT var;
	var.vt = VT_I4;
	V_I4( &var ) = lTime;
	m_pSequenceMgr->m_pTimeline->GetTimelineProperty( TP_SNAPAMOUNT, &var );

	// Get TimeSig
	DMUS_TIMESIGNATURE TimeSig;
	if(SUCCEEDED(m_pSequenceMgr->m_pTimeline->GetParam(GUID_TimeSignature,
										0xFFFFFFFF,
										0,
										lTime, NULL,
										&TimeSig)))
	{
		long lBeatClocks = (DMUS_PPQ * 4) / TimeSig.bBeat;
		if( V_I4( &var ) == lBeatClocks )
		{
			// Snap to Beat
			return SNAP_BEAT;
		}
		if( V_I4( &var ) == lBeatClocks * TimeSig.bBeatsPerMeasure )
		{
			// Snap to Bar
			return SNAP_BAR;
		}
		if( V_I4( &var ) == lBeatClocks / TimeSig.wGridsPerBeat )
		{
			// Snap to Grid
			return SNAP_GRID;
		}
	}

	ASSERT( V_I4( &var ) == 1 );
	// Snap to 'none'
	return SNAP_NONE;
}


/////////////////////////////////////////////////////////////////////////////
// CSequenceStrip::GetSnapAmount

long CSequenceStrip::GetSnapAmount( long lTime, SNAPTO st ) const 
{
	if( st == SNAP_UNKNOWN )
	{
		st = GetSnapToBoundary( lTime );
	}

	if( st == SNAP_NONE )
	{
		// Snap to None
		return 1;
	}

	// Get TimeSig
	DMUS_TIMESIGNATURE TimeSig;
	if(SUCCEEDED(m_pSequenceMgr->m_pTimeline->GetParam(GUID_TimeSignature,
										m_pSequenceMgr->m_dwGroupBits,
										m_pSequenceMgr->m_dwIndex,
										lTime, NULL,
										&TimeSig)))
	{
		long lBeatClocks = (DMUS_PPQ * 4) / TimeSig.bBeat;
		switch( st )
		{
		case SNAP_GRID:
			// Snap to Grid
			return lBeatClocks / TimeSig.wGridsPerBeat;
		case SNAP_BEAT:
			// Snap to Beat
			return lBeatClocks;
		case SNAP_BAR:
			// Snap to Bar
			return lBeatClocks * TimeSig.bBeatsPerMeasure;
		}
	}

	ASSERT(FALSE);
	return 1;
}


/////////////////////////////////////////////////////////////////////////////
// CSequenceStrip::GetAccidentalFont

HFONT CSequenceStrip::GetAccidentalFont( void )
{
	// Create the font to draw the sharps and flats with
	LOGFONT lf;
	memset( &lf, 0 , sizeof(LOGFONT));
	if( m_pSequenceMgr->m_fHasNotationStation )
	{
		lf.lfHeight = - long(MAX_NOTE_HEIGHT * NOTATION_FONT_ZOOMFACTOR * m_dblVerticalZoom);
		lf.lfCharSet = SYMBOL_CHARSET;
		lf.lfPitchAndFamily = DEFAULT_PITCH;

		CString strFontName;
		strFontName.LoadString(IDS_NOTATION_FONT);
		_tcsncpy( lf.lfFaceName, strFontName, LF_FACESIZE );
		lf.lfWeight = FW_NORMAL;
	}
	else
	{
		lf.lfHeight = long(MAX_NOTE_HEIGHT * 1.4 * m_dblVerticalZoom);
		//lf.lfCharSet = ANSI_CHARSET;
		lf.lfPitchAndFamily = DEFAULT_PITCH | FF_MODERN;
		//lf.lfFaceName = NULL;
		lf.lfWeight = FW_SEMIBOLD;
	}
	//lf.lfWidth = 0;
	//lf.lfEscapement = 0;
	//lf.lfOrientation = 0;
	//lf.lfItalic = FALSE;
	//lf.lfUnderline = FALSE;
	//lf.lfStrikeOut = FALSE;
	//lf.lfOutPrecision = OUT_DEFAULT_PRECIS;
	//lf.lfClipPrecision = CLIP_DEFAULT_PRECIS;
	//lf.lfQuality = DEFAULT_QUALITY;

	return ::CreateFontIndirect( &lf );
}


/////////////////////////////////////////////////////////////////////////////
// CSequenceStrip::GetGridClocks

long CSequenceStrip::GetGridClocks( long lTime ) const
{
	// Get TimeSig
	DMUS_TIMESIGNATURE TimeSig;
	if(SUCCEEDED(m_pSequenceMgr->m_pTimeline->GetParam(GUID_TimeSignature,
										m_pSequenceMgr->m_dwGroupBits,
										m_pSequenceMgr->m_dwIndex,
										lTime, NULL,
										&TimeSig)))
	{
		ASSERT( TimeSig.bBeat && TimeSig.wGridsPerBeat );
		if( TimeSig.bBeat && TimeSig.wGridsPerBeat )
		{
			return ((DMUS_PPQ * 4) / TimeSig.bBeat) / TimeSig.wGridsPerBeat;
		}
	}

	// Shouldn't happen
	ASSERT(FALSE);
	return DMUS_PPQ / 4;
}


/////////////////////////////////////////////////////////////////////////////
// CSequenceStrip::ChangeNotationType

void CSequenceStrip::ChangeNotationType( BOOL fHybridNotation )
{
	if( m_fHybridNotation == fHybridNotation )
	{
		return;
	}

	int nLastEdit = 0;

	if( fHybridNotation )
	{
		m_fHybridNotation = TRUE;

		// Update the range
		SCROLLINFO si;
		si.cbSize = sizeof( SCROLLINFO );
		si.fMask = SIF_RANGE;
		si.nMin = 0;
		si.nMax = 37;
		m_VScrollBar.SetScrollInfo( &si, TRUE );

		// Fix 21001: Don't change zoom level when changing notation type.
		//m_dblVerticalZoom *= 1.6;
		nLastEdit = IDS_UNDO_DISP_HYBRID;
	}
	else
	{
		m_fHybridNotation = FALSE;

		// Update the range
		SCROLLINFO si;
		si.cbSize = sizeof( SCROLLINFO );
		si.fMask = SIF_RANGE;
		si.nMin = 0;
		si.nMax = 127;
		m_VScrollBar.SetScrollInfo( &si, TRUE );

		// Fix 21001: Don't change zoom level when changing notation type.
		//m_dblVerticalZoom /= 1.6;
		nLastEdit = IDS_UNDO_DISP_NORMAL;
	}

	VARIANT var;
	if( SUCCEEDED ( m_pSequenceMgr->m_pTimeline->StripGetTimelineProperty( (IDMUSProdStrip *)this, STP_HEIGHT, &var ) ) )
	{
		int nHeightDiv2 = V_I4( &var ) / 2;
		int nMiddle = (m_lVScroll + nHeightDiv2 ) / m_lMaxNoteHeight;
		m_lMaxNoteHeight = long( MAX_NOTE_HEIGHT * m_dblVerticalZoom + HORIZ_LINE_HEIGHT );

		if( m_fHybridNotation )
		{
			// Changed to Hybrid Notation
			nMiddle = MulDiv( nMiddle, 38, 128 );
		}
		else
		{
			// Changed to PianoRoll notation
			nMiddle = MulDiv( nMiddle, 128, 38 );
		}

		SetVScroll( nMiddle * m_lMaxNoteHeight - nHeightDiv2 );
		if( m_svView == SV_NORMAL )
		{
			UpdateVScroll();
			InvalidateStrip();
		}

		ASSERT( nLastEdit != 0 );

		// Let the object know about the changes
		m_nLastEdit = nLastEdit;
		m_pSequenceMgr->m_fUpdateDirectMusic = FALSE;
		m_pSequenceMgr->OnDataChanged();

		// If we're not a drum track, notify the other sequence strips so they change also.
		if( (m_pSequenceMgr->m_dwPChannel >= DMUS_PCHANNEL_BROADCAST_GROUPS)
		||	(m_pSequenceMgr->m_dwPChannel & 0xF) != 9 )
		{
			// Only notify if TP_FREEZE_UNDO is NOT set.
			BOOL fFreezeUndo = FALSE;
			if( SUCCEEDED( m_pSequenceMgr->m_pTimeline->GetTimelineProperty( TP_FREEZE_UNDO, &var ) ) )
			{
				fFreezeUndo = V_BOOL(&var);
			}

			if( !fFreezeUndo )
			{
				m_pSequenceMgr->m_pTimeline->NotifyStripMgrs( GUID_Sequence_Notation_Change, 0xFFFFFFFF, &m_fHybridNotation );
			}
		}

		EnsureNoteCursorVisible();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CSequenceStrip::ChangeZoom

void CSequenceStrip::ChangeZoom( double dblVerticalZoom )
{
	if( dblVerticalZoom < MINIMUM_ZOOM_LEVEL )
	{
		return;
	}

	if( m_dblVerticalZoom == dblVerticalZoom )
	{
		return;
	}

	m_dblVerticalZoom = dblVerticalZoom;

	VARIANT var;
	if( SUCCEEDED ( m_pSequenceMgr->m_pTimeline->StripGetTimelineProperty( (IDMUSProdStrip *)this, STP_HEIGHT, &var ) ) )
	{
		int nHeightDiv2 = V_I4( &var ) / 2;
		int nMiddle = (m_lVScroll + nHeightDiv2 ) / m_lMaxNoteHeight;
		m_lMaxNoteHeight = long( MAX_NOTE_HEIGHT * m_dblVerticalZoom + HORIZ_LINE_HEIGHT );

		SetVScroll( nMiddle * m_lMaxNoteHeight - nHeightDiv2 );
		if( m_svView == SV_NORMAL )
		{
			UpdateVScroll();
			InvalidateStrip();
		}

		EnsureNoteCursorVisible();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CSequenceStrip::DoQuantize

HRESULT CSequenceStrip::DoQuantize( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Store window that has focus
	HWND hwndFocus = ::GetFocus();
	
	CQuantizeDlg dlgQuantize;

	// Initialize the dialog's settings
	SequenceQuantize sq;
	if( SUCCEEDED ( m_pSequenceMgr->m_pTimeline->GetParam( GUID_Sequence_QuantizeParams,
														   m_pSequenceMgr->m_dwGroupBits,
														   m_pSequenceMgr->m_dwIndex,
														   0,
														   NULL,
														   &sq ) ) )
	{
		dlgQuantize.m_qtTarget = (QUANTIZE_TARGET)sq.m_wQuantizeTarget;
		dlgQuantize.m_lResolution = sq.m_bResolution;
		dlgQuantize.m_lStrength = sq.m_bStrength;
		dlgQuantize.m_dwFlags = sq.m_dwFlags;
	}
	else
	{
		dlgQuantize.m_qtTarget = QUANTIZE_TARGET_SELECTED;
		dlgQuantize.m_lResolution = 4;
		dlgQuantize.m_lStrength = 100;
		dlgQuantize.m_dwFlags = SEQUENCE_QUANTIZE_START_TIME;
	}

	// Get time signature beat
	DMUS_TIMESIGNATURE TimeSig;
	if( SUCCEEDED ( m_pSequenceMgr->m_pTimeline->GetParam( GUID_TimeSignature,
														   m_pSequenceMgr->m_dwGroupBits,
														   m_pSequenceMgr->m_dwIndex,
														   0,
														   NULL,
														   &TimeSig ) ) )
	{
		dlgQuantize.m_bBeat = TimeSig.bBeat;
	}
	else
	{
		dlgQuantize.m_bBeat = 4;
	}

	// Check if we should enable the 'Selected Note(s)' option
	if( CanCopy() == S_OK )
	{
		dlgQuantize.m_fEnableSelected = TRUE;
	}
	else
	{
		dlgQuantize.m_fEnableSelected = FALSE;
		if( dlgQuantize.m_qtTarget == QUANTIZE_TARGET_SELECTED )
		{
			dlgQuantize.m_qtTarget = QUANTIZE_TARGET_PART;
		}
	}

	// Display the dialog.  Only act if the user clicked on 'OK'.
	if( dlgQuantize.DoModal() == IDOK )
	{
		sq.m_wQuantizeTarget = (WORD)dlgQuantize.m_qtTarget;
		sq.m_dwFlags = dlgQuantize.m_dwFlags;		

		ASSERT( (dlgQuantize.m_lResolution < UCHAR_MAX) && (dlgQuantize.m_lResolution > 0 ) );
		sq.m_bResolution = (BYTE)dlgQuantize.m_lResolution;	

		ASSERT( (dlgQuantize.m_lStrength <= 100) && (dlgQuantize.m_lStrength >= 0 ) );
		sq.m_bStrength = (BYTE)dlgQuantize.m_lStrength;

		// Save the dialog's settings
		m_pSequenceMgr->m_pTimeline->SetParam( GUID_Sequence_QuantizeParams,
											   m_pSequenceMgr->m_dwGroupBits,
											   m_pSequenceMgr->m_dwIndex,
											   NULL,
											   &sq );

		// Quantize either selected notes, entire Part, or entire Sequence
		switch( sq.m_wQuantizeTarget )
		{
			case QUANTIZE_TARGET_SELECTED:
			case QUANTIZE_TARGET_PART:
				m_pSequenceMgr->Quantize( &sq );
				break;
			case QUANTIZE_TARGET_SEQUENCE:
				// Assume something will change
				// This must be done before NotifyStripMgrs is called
				m_nLastEdit = IDS_UNDO_QUANTIZE;
				m_pSequenceMgr->OnDataChanged();
				m_pSequenceMgr->m_pTimeline->NotifyStripMgrs( GUID_Sequence_Quantize, m_pSequenceMgr->m_dwGroupBits, &sq );
				break;
			default:
				break;
		}
	}

	// Restore focus
	if( hwndFocus )
	{
		::SetFocus( hwndFocus );
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CSequenceStrip::DoVelocity

HRESULT CSequenceStrip::DoVelocity( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Store window that has focus
	HWND hwndFocus = ::GetFocus();
	
	CDialogVelocity dlgVelocity;

	// Initialize the dialog's settings
	SequenceVelocitize sv;
	if( SUCCEEDED ( m_pSequenceMgr->m_pTimeline->GetParam( GUID_Sequence_VelocitizeParams,
														   m_pSequenceMgr->m_dwGroupBits,
														   m_pSequenceMgr->m_dwIndex,
														   0,
														   NULL,
														   &sv ) ) )
	{
		dlgVelocity.m_vtTarget = (VELOCITY_TARGET)sv.m_wVelocityTarget;
		dlgVelocity.m_lAbsoluteChangeStart = sv.m_lAbsoluteChangeStart;
		dlgVelocity.m_lAbsoluteChangeEnd = sv.m_lAbsoluteChangeEnd;
		dlgVelocity.m_bCompressMax = sv.m_bCompressMax;
		dlgVelocity.m_bCompressMin = sv.m_bCompressMin;
		switch( sv.m_dwVelocityMethod & SEQUENCE_VELOCITIZE_METHOD_MASK )
		{
		case SEQUENCE_VELOCITIZE_PERCENT:
			dlgVelocity.m_fAbsolute = true;
			dlgVelocity.m_fPercent = true;
			break;
		case SEQUENCE_VELOCITIZE_LINEAR:
			dlgVelocity.m_fAbsolute = true;
			dlgVelocity.m_fPercent = false;
			break;
		case SEQUENCE_VELOCITIZE_COMPRESS:
			dlgVelocity.m_fAbsolute = false;
			dlgVelocity.m_fPercent = true;
			break;
		}
	}
	else
	{
		dlgVelocity.m_vtTarget = VELOCITY_TARGET_SELECTED;
		dlgVelocity.m_lAbsoluteChangeStart = 0;
		dlgVelocity.m_lAbsoluteChangeEnd = 0;
		dlgVelocity.m_bCompressMax = 127;
		dlgVelocity.m_bCompressMin = 0;
		dlgVelocity.m_fAbsolute = true;
		dlgVelocity.m_fPercent = true;
	}

	// Check if we should enable the 'Selected Note(s)' option
	if( CanCopy() == S_OK )
	{
		dlgVelocity.m_fEnableSelected = true;
	}
	else
	{
		dlgVelocity.m_fEnableSelected = false;
		if( dlgVelocity.m_vtTarget == VELOCITY_TARGET_SELECTED )
		{
			dlgVelocity.m_vtTarget = VELOCITY_TARGET_PART;
		}
	}

	// Display the dialog.  Only act if the user clicked on 'OK'.
	if( dlgVelocity.DoModal() == IDOK )
	{
		sv.m_wVelocityTarget = (WORD)dlgVelocity.m_vtTarget;
		sv.m_lAbsoluteChangeStart = dlgVelocity.m_lAbsoluteChangeStart;
		sv.m_lAbsoluteChangeEnd = dlgVelocity.m_lAbsoluteChangeEnd;
		sv.m_bCompressMax = dlgVelocity.m_bCompressMax;
		sv.m_bCompressMin = dlgVelocity.m_bCompressMin;
		if( dlgVelocity.m_fAbsolute )
		{
			sv.m_dwVelocityMethod = dlgVelocity.m_fPercent ? SEQUENCE_VELOCITIZE_PERCENT : SEQUENCE_VELOCITIZE_LINEAR;
		}
		else
		{
			sv.m_dwVelocityMethod = SEQUENCE_VELOCITIZE_COMPRESS;
		}

		// Save the dialog's settings
		m_pSequenceMgr->m_pTimeline->SetParam( GUID_Sequence_VelocitizeParams,
											   m_pSequenceMgr->m_dwGroupBits,
											   m_pSequenceMgr->m_dwIndex,
											   NULL,
											   &sv );

		// Quantize either selected notes, entire Part, or entire Sequence
		switch( sv.m_wVelocityTarget )
		{
			case VELOCITY_TARGET_SELECTED:
			case VELOCITY_TARGET_PART:
				m_pSequenceMgr->Velocitize( &sv );
				break;
			case VELOCITY_TARGET_PATTERN:
				// Assume something will change
				// This must be done before NotifyStripMgrs is called
				m_nLastEdit = IDS_UNDO_VELOCITY;
				m_pSequenceMgr->OnDataChanged();
				m_pSequenceMgr->m_pTimeline->NotifyStripMgrs( GUID_Sequence_Velocitize, m_pSequenceMgr->m_dwGroupBits, &sv );
				break;
			default:
				break;
		}
	}

	// Restore focus
	if( hwndFocus )
	{
		::SetFocus( hwndFocus );
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CSequenceStrip::EnsureNoteCursorVisible

void CSequenceStrip::EnsureNoteCursorVisible( void )
{
	RECT rectMark;
	ComputeNoteMarkerVerticalRect( rectMark, m_fHybridNotation, m_pSequenceMgr->m_fDisplayingFlats, m_lMaxNoteHeight, m_lInsertVal );

	if( rectMark.bottom <= m_lVScroll )
	{
		// Need to scroll up
		SetVScroll( ((rectMark.top / m_lMaxNoteHeight) - 1) * m_lMaxNoteHeight );
	}
	else
	{
		VARIANT var;
		if( SUCCEEDED( m_pSequenceMgr->m_pTimeline->StripGetTimelineProperty( (IDMUSProdStrip *)this, STP_HEIGHT, &var ) )
		&&	(rectMark.top > V_I4(&var) + m_lVScroll) )
		{
			// Need to scroll down
			SetVScroll( (((rectMark.top - V_I4(&var)) / m_lMaxNoteHeight) + 2) * m_lMaxNoteHeight );
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CSequenceStrip::UpdateSelectionState

void CSequenceStrip::UpdateSelectionState( void )
{
	if( !m_pActiveNote || !m_pActiveNote->m_fSelected )
	{
		m_pActiveNote = m_pSequenceMgr->FirstSelectedSequence( NULL );
	}

	if( !m_pActiveNote )
	{
		m_SelectionMode = SEQ_NO_SELECT;
		return;
	}

	// Set m_prsSelecting based on the number of selected notes
	int nSelected = m_pSequenceMgr->GetNumSelected();
	if (nSelected == 1)
	{
		m_SelectionMode = SEQ_SINGLE_SELECT;
	}
	else if (nSelected > 1)
	{
		m_SelectionMode = SEQ_MULTIPLE_SELECT;
	}
	else if (nSelected == 0)
	{
		ASSERT(FALSE);
		// Shouldn't ever happen
		//m_SelectionMode = SEQ_NO_SELECT;
		//m_pActiveNote = NULL;
	}

	m_pSequenceMgr->UpdateStatusBarDisplay();
}


/////////////////////////////////////////////////////////////////////////////
// CSequenceStrip::GetNumExtraBars

DWORD CSequenceStrip::GetNumExtraBars( void ) const
{
	MUSIC_TIME mtLastNoteOff = LONG_MIN;
	POSITION pos = m_pSequenceMgr->m_lstSequences.GetHeadPosition();
	while( pos )
	{
		CSequenceItem *pItem = m_pSequenceMgr->m_lstSequences.GetNext( pos );
		MUSIC_TIME mtOffTime = pItem->AbsTime() + pItem->m_mtDuration;
		if( mtOffTime > mtLastNoteOff )
		{
			mtLastNoteOff = mtOffTime;
		}
	}

	pos = m_pSequenceMgr->m_lstCurves.GetHeadPosition();
	while( pos )
	{
		CCurveItem *pItem = m_pSequenceMgr->m_lstCurves.GetNext( pos );
		MUSIC_TIME mtOffTime = pItem->AbsTime() + pItem->m_mtDuration;
		if( mtOffTime > mtLastNoteOff )
		{
			mtLastNoteOff = mtOffTime;
		}
	}

	if( mtLastNoteOff > m_mtLength )
	{
		// Find out when the last measure starts
		long lLastMeasureStart;
		m_pSequenceMgr->m_pTimeline->ClocksToMeasureBeat( m_pSequenceMgr->m_dwGroupBits, m_pSequenceMgr->m_dwIndex, m_mtLength, &lLastMeasureStart, NULL );
		m_pSequenceMgr->m_pTimeline->MeasureBeatToClocks( m_pSequenceMgr->m_dwGroupBits, m_pSequenceMgr->m_dwIndex, lLastMeasureStart, 0, &lLastMeasureStart );

		// Find out the TimeSig of the last measure
		DMUS_TIMESIGNATURE dmTimeSig;
		GetTimeSig( m_mtLength - 1, &dmTimeSig, m_pSequenceMgr->m_pTimeline, m_pSequenceMgr->m_dwGroupBits );
		const long lMeasureLength = dmTimeSig.bBeatsPerMeasure * ((DMUS_PPQ * 4) / dmTimeSig.bBeat);

		// Compute how far away the last note off is from the start of the last measure
		MUSIC_TIME mtOffset = mtLastNoteOff - lLastMeasureStart;

		// Return how many measure we need to display
		return max( m_dwExtraBars, DWORD((mtOffset + lMeasureLength - 1) / lMeasureLength) );
	}

	return m_dwExtraBars;
}


/////////////////////////////////////////////////////////////////////////////
// CSequenceStrip::ShouldDisplayPickupBar

BOOL CSequenceStrip::ShouldDisplayPickupBar( void ) const
{
	if( m_fPickupBar )
	{
		return TRUE;
	}

	if( !m_pSequenceMgr->m_lstSequences.IsEmpty() )
	{
		if( m_pSequenceMgr->m_lstSequences.GetHead()->AbsTime() < 0 )
		{
			// Found an early note - return TRUE
			return TRUE;
		}
	}

	if( !m_pSequenceMgr->m_lstCurves.IsEmpty() )
	{
		if( m_pSequenceMgr->m_lstCurves.GetHead()->AbsTime() < 0 )
		{
			// Found an early curve - return TRUE
			return TRUE;
		}
	}

	return FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CSequenceStrip::SetPChannelThru

void CSequenceStrip::SetPChannelThru( void )
{
	int iChannel;
	for( iChannel=0; iChannel < 16; iChannel++ )
	{
		if( FAILED( m_pSequenceMgr->m_pIConductor->SetPChannelThru( iChannel, m_pSequenceMgr->m_dwPChannel ) ) )
		{
			break;
		}
	}

	// If we didn't successfullly complete SetPChannelThru for all 16 channels,
	// cancel the MIDI thruing
	if( iChannel != 16 )
	{
		CancelPChannelThru();
		return;
	}

	// All sixteen completed successfully, set m_fMIDIThruEnabled
	m_fMIDIThruEnabled = TRUE;
}


/////////////////////////////////////////////////////////////////////////////
// CSequenceStrip::CancelPChannelThru

void CSequenceStrip::CancelPChannelThru( void )
{
	for( int iChannel=0; iChannel < 16; iChannel++ )
	{
		m_pSequenceMgr->m_pIConductor->CancelPChannelThru( iChannel );
	}

	m_fMIDIThruEnabled = FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CSequenceStrip::UpdateInstrumentName

void CSequenceStrip::UpdateInstrumentName( void )
{
	// Initialize our temporary patch to an invalid value
	DWORD dwPatch = INVALID_PATCH;

	// Pointer to interface from which DLS region text can be obtained
	IDMUSProdBandEdit8a* pIBandEdit;

	// Try to get the band edit interface
	pIBandEdit = GetBandEditInterface( m_pSequenceMgr->m_pTimeline, m_pSequenceMgr->m_dwGroupBits, m_pSequenceMgr->m_dwPChannel );

	if( pIBandEdit )
	{
		pIBandEdit->GetPatchForPChannel( m_pSequenceMgr->m_dwPChannel, &dwPatch );
		pIBandEdit->Release();
	}

	if( m_dwLastPatch != dwPatch )
	{
		m_dwLastPatch = dwPatch;

		if( SV_NORMAL == m_svView )
		{
			InvalidateFunctionBar();
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SequenceStripMgr\StdAfx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__1B397D8F_BB36_11D0_BBD3_00A0C922E6EB__INCLUDED_)
#define AFX_STDAFX_H__1B397D8F_BB36_11D0_BBD3_00A0C922E6EB__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define STRICT

#include <afxwin.h>
#include <afxdisp.h>

#define _WIN32_WINNT 0x0400
#define _ATL_APARTMENT_THREADED

#include <afxdlgs.h>
#include <AFXCMN.H>
#include <atlbase.h>
#include <Afxdisp.h>
#include <afxtempl.h>

//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <atlctl.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__1B397D8F_BB36_11D0_BBD3_00A0C922E6EB__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SequenceStripMgr\Tracker.h ===
#ifndef __CURVETRACKER_H__
#define __CURVETRACKER_H__

// Tracker.h : header file
//

#include "timeline.h"
#include <afxext.h>

#define CTRK_NOTHING		0
#define CTRK_SELECTING		1
#define CTRK_INSERTING		2
#define CTRK_EDITING		3
#define CTRK_DRAGGING		4
#define CTRK_DRAGGING_EDGE	5

class CCurveItem;

/////////////////////////////////////////////////////////////////////////////
// CCurveTracker class

class CCurveStrip;

typedef CList<CCurveItem*, CCurveItem*> CCurveList;
class CCurveTracker : public CRectTracker
{
public:
   CCurveTracker( CWnd* pWnd, IDMUSProdTimeline* pITimeline, CCurveStrip* pCurveStrip, short nAction,
	   CRect* initialRect = NULL);
   CCurveTracker( CRect* initialRect );
   virtual ~CCurveTracker();
   
protected:
	WORD DoAction();
	void ScrollPianoRoll();
	void SetStartEndPoints(int nHandle);
	void LimitRects();

public:
	void SetCurve( CCurveItem* pDMCurve );
	void SetCurveList(CTypedPtrList<CPtrList, CCurveItem*>* pCurveList);
	void SetXOffset(int nXOffset);

// Overrides
public:
	virtual void AdjustRect( int nHandle, RECT* pRect );
	virtual void DrawTrackerRect( LPCRECT lpRect, CWnd* pWndClipTo, CDC* pDC, CWnd* pWnd );

// public members
public:
	// used for dragging
	CSize			m_offset;
	CCurveItem*	m_pDMCurve;	
	CTypedPtrList<CPtrList, CCurveItem*> *m_pCurveList;
	int				m_nXOffset;			

// private members
protected:
	CWnd*				m_pWnd;
	IDMUSProdTimeline*	m_pITimeline;
	CCurveStrip*		m_pCurveStrip;
	short				m_nAction;
	long				m_lPartClockLength;

	CPoint			m_ptStart;	
	CPoint			m_ptEnd;
	BOOL			m_fSetStartPoint;
	
	DWORD			m_dwScrollTick;
	BOOL			m_fScrolledPianoRoll;
};

#endif // __CURVETRACKER_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SequenceStripMgr\Tracker.cpp ===
// Tracker.cpp : implementation file
//

#include "stdafx.h"
#include "SequenceStripMgr.h"

#include "SequenceMgr.h"
#include "CurveStrip.h"

#include "Tracker.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/////////////////////////////////////////////////////////////////////////////
// CCurveTracker constructor/ destructor

CCurveTracker::CCurveTracker(CWnd* pWnd, IDMUSProdTimeline* pITimeline, CCurveStrip* pCurveStrip, short nAction,
							 CRect* initialRect)
{
	ASSERT( pITimeline != NULL );
	ASSERT( pCurveStrip != NULL );
	ASSERT( pCurveStrip->m_pSequenceStrip != NULL );

	m_pITimeline = pITimeline;
	m_pITimeline->AddRef();

	m_pCurveStrip = pCurveStrip;
	m_pCurveStrip->AddRef();

	m_pWnd = pWnd;
	m_nAction = nAction;

	m_lPartClockLength = pCurveStrip->m_pSequenceStrip->m_mtLength;
	
	if (m_nAction == CTRK_DRAGGING) {
		// a little trick to avoid resizing when not intended...
		m_nHandleSize = 0;
	}

	m_pDMCurve = NULL;
	m_pCurveList = NULL;
	m_nXOffset = 0;

	m_dwScrollTick = 0;
	m_fSetStartPoint = TRUE;

	if (initialRect != NULL) {
		m_rect = *initialRect;
	}
	m_nStyle = resizeInside;
	m_fScrolledPianoRoll = FALSE;

	m_sizeMin.cx = 0;
	m_sizeMin.cy = 0;
}

// construct a curve tracker for the SOLE purpose of
// doing hit testing or drawing
CCurveTracker::CCurveTracker(CRect* initialRect)
{
	ASSERT(initialRect != NULL);
	
	m_pITimeline = NULL;
	m_pCurveStrip = NULL;
	m_pWnd = NULL;
	m_nAction = CTRK_NOTHING;
	m_lPartClockLength = 0;
	m_pDMCurve = NULL;
	m_pCurveList = NULL;
	m_nXOffset = 0;
	m_rect = *initialRect;
	m_nStyle = resizeInside;
	m_fScrolledPianoRoll = FALSE;
}

CCurveTracker::~CCurveTracker()
{
	if( m_pITimeline )
	{
		m_pITimeline->Release();
	}

	if( m_pCurveStrip )
	{
		m_pCurveStrip->Release();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CCurveTracker::SetCurve

void CCurveTracker::SetCurve( CCurveItem* pDMCurve )
{
	ASSERT( pDMCurve != NULL );
	m_pDMCurve = pDMCurve;
}

/////////////////////////////////////////////////////////////////////////////
// CCurveTracker::SetCurveList
//
void CCurveTracker::SetCurveList(CTypedPtrList<CPtrList, CCurveItem*>* pCurveList)
{
	ASSERT(pCurveList != NULL);
	m_pCurveList = pCurveList;
}

/////////////////////////////////////////////////////////////////////////////
// CCurveTracker::SetXOffset
//
void CCurveTracker::SetXOffset(int nXOffset)
{
	ASSERT(nXOffset >= 0);
	m_nXOffset = nXOffset;
}

/////////////////////////////////////////////////////////////////////////////
// CCurveTracker::DoAction

WORD CCurveTracker::DoAction( void )
{
	CRect rectTracker(m_ptStart, m_ptEnd);
	rectTracker.NormalizeRect();

	WORD wRefreshUI = FALSE;

	switch( m_nAction )
	{
		case CTRK_SELECTING:
			wRefreshUI = m_pCurveStrip->SelectCurvesInRect( &rectTracker );
			break;

		case CTRK_INSERTING:
		{
			CPoint ptLeft;
			CPoint ptRight;

			if( m_ptStart.x < m_ptEnd.x )
			{
				ptLeft.x = m_ptStart.x;
				ptLeft.y = m_ptStart.y;
				ptRight.x = m_ptEnd.x;
				ptRight.y = m_ptEnd.y;
			}
			else
			{
				ptLeft.x = m_ptEnd.x;
				ptLeft.y = m_ptEnd.y;
				ptRight.x = m_ptStart.x;
				ptRight.y = m_ptStart.y;
			}

			m_pCurveStrip->OnUpdateInsertCurveValue( ptLeft, ptRight );
			break;
		}

		case CTRK_DRAGGING:
		case CTRK_DRAGGING_EDGE:
			m_pCurveStrip->OnUpdateDragCurveValue( *this, m_nAction );
			break;

	}

	return wRefreshUI;
}


/////////////////////////////////////////////////////////////////////////////
// CCurveTracker::ScrollPianoRoll

void CCurveTracker::ScrollPianoRoll( void )
{
	// Reset m_dwScrollTick to zero
	DWORD dwScrollTick = m_dwScrollTick;
	m_dwScrollTick = 0;

	// Get cursor position
	CPoint point;
	::GetCursorPos( &point );
	m_pWnd->ScreenToClient( &point );

	// Get Curve Strip rectangle
	CRect rectStrip;
	if( !m_pCurveStrip->GetStripRect( rectStrip ) )
	{
		return;
	}
	
	// Get Curve Strip max right
	long lMaxXPosition;
	long lLeftPosition;
	CRect rectFBar;
	VARIANT var;
	var.vt = VT_BYREF;
	V_BYREF(&var) = &rectFBar;
	if( FAILED ( m_pITimeline->StripGetTimelineProperty( (IDMUSProdStrip *)m_pCurveStrip, STP_FBAR_RECT, &var ) ) )
	{
		return;
	}
	m_pITimeline->GetMarkerTime( MARKER_LEFTDISPLAY, TIMETYPE_CLOCKS, &lLeftPosition );
	m_pITimeline->ClocksToPosition( lLeftPosition, &lLeftPosition );
	m_pITimeline->ClocksToPosition( m_lPartClockLength, &lMaxXPosition );
	lMaxXPosition += rectFBar.right - 1;
	lMaxXPosition -= lLeftPosition;

	// Exit if point.x is already at end of Curve Strip
	if( m_nAction != CTRK_SELECTING )
	{
		if( point.x >= lMaxXPosition )
		{
			return;
		}
	}

	// Get Piano Roll scrollbar values
	int nScrollMin;
	int nScrollMax;
	int nScrollPos;
	CScrollBar* pScrollBar = (CScrollBar *)m_pWnd->GetDlgItem( 103 );	// Timeline HORZ scoll bar
	nScrollPos = pScrollBar->GetScrollPos();
	pScrollBar->GetScrollRange( &nScrollMin, &nScrollMax );

	// Does position of cursor indicate user wants to scroll?
	short nDirection = -1;
	if( point.x > rectStrip.right )
	{
		if( nScrollPos < nScrollMax )
		{
			nDirection = SB_LINERIGHT;
		}
	}
	else if( point.x < rectStrip.left )
	{
		if( nScrollPos > nScrollMin )
		{
			nDirection = SB_LINELEFT;
		}
	}
	if( nDirection == -1 )
	{
		return;
	}

	// We may need to scroll
	DWORD dwTick = GetTickCount();
	if( dwScrollTick )
	{
		// scroll only if the proper amount of time has elapsed
		// since the last scroll
		if( dwTick >= dwScrollTick )
		{
			m_pWnd->SendMessage( WM_HSCROLL,
								 MAKELONG(nDirection, nScrollPos), (LPARAM)pScrollBar->m_hWnd );
			m_pWnd->UpdateWindow();
			m_fScrolledPianoRoll = TRUE;

			m_dwScrollTick = dwTick + 350;	// wait 350 ms
		}
		else
		{
			m_dwScrollTick = dwScrollTick;	// still waiting...
		}
	}
	else
	{
		m_dwScrollTick = dwTick + 200;		// wait 200 ms
	}
}


/////////////////////////////////////////////////////////////////////////////
// CCurveTracker::SetStartEndPoints
//
// Sets the start and end points after restricting them within the strip.
void CCurveTracker::SetStartEndPoints( int nHandle )
{
	// Get Curve Strip rectangle
	CRect rectStrip;
	if( !m_pCurveStrip->GetStripRect(rectStrip) )
	{
		return;
	}

	// Get Curve Strip left position
	long lLeftPosition;
	m_pITimeline->GetMarkerTime( MARKER_LEFTDISPLAY, TIMETYPE_CLOCKS, &lLeftPosition );
	m_pITimeline->ClocksToPosition( lLeftPosition, &lLeftPosition );

	// Make sure m_rect.top is within this CurveStrip
	if( m_rect.top < rectStrip.top )
	{
		m_rect.top = rectStrip.top;
	}
	if( m_rect.top >= rectStrip.bottom )
	{
		m_rect.top = rectStrip.bottom;
	}

	// Make sure m_rect.bottom is within this CurveStrip
	if( m_rect.bottom > rectStrip.bottom )
	{
		m_rect.bottom = rectStrip.bottom;
	}
	if( m_rect.bottom <= rectStrip.top )
	{
		m_rect.bottom = rectStrip.top;
	}
	
	// Make tracker rect relative to beginning of the strip
	CRect rectTracker = m_rect;
	rectTracker.OffsetRect( -rectStrip.left, -rectStrip.top );
	rectTracker.OffsetRect( lLeftPosition, 0 );

	// Get the strip rect relative to its beginning
	CRect rectStripAdjusted = rectStrip;
	rectStripAdjusted.OffsetRect( -rectStrip.left, -rectStrip.top );
	rectStripAdjusted.OffsetRect( lLeftPosition, 0 );

	// Adjust leftmost point
	if( m_nAction == CTRK_DRAGGING_EDGE )
	{
		if( nHandle == hitTopLeft
		||  nHandle == hitBottomLeft
		||  nHandle == hitLeft )
		{
			if( rectTracker.left <= rectTracker.right )
			{
				if( rectTracker.left < rectStripAdjusted.left )
				{
					rectTracker.left = rectStripAdjusted.left;
				}
			}
			else
			{
				if( rectTracker.right < rectStripAdjusted.left )
				{
					rectTracker.right = rectStripAdjusted.left;
				}
			}
		}
	}
	
	bool bKeepLeft = false;
	bool bKeepRight = false;

	
	if (!m_fSetStartPoint && (m_nAction == CTRK_DRAGGING_EDGE)) {
		switch (nHandle) {
		case hitTopLeft:
		case hitBottomLeft:
		case hitLeft:
			bKeepRight = true;
			break;
		case hitTopRight:
		case hitBottomRight:
		case hitRight:
			bKeepLeft = true;
			break;

		}
	}

	// Store starting point if we haven't set it yet
	if (m_fSetStartPoint || m_nAction == CTRK_DRAGGING_EDGE)
	{
		m_fSetStartPoint = FALSE;

		if (bKeepLeft) {
			m_ptStart.y = rectTracker.top;
		}
		else
		{
			m_ptStart = rectTracker.TopLeft();
		}
	}

	// Store ending point
	if (bKeepRight) {
		m_ptEnd.y = rectTracker.bottom;
	}
	else {
		m_ptEnd = rectTracker.BottomRight();
	}

	// Enforce minimum width
	int nNewWidth = m_ptEnd.x - m_ptStart.x;
	int nAbsWidth = m_bAllowInvert ? abs(nNewWidth) : nNewWidth;
	if( nAbsWidth < m_sizeMin.cx )
	{
		if( m_ptStart.x <= m_ptEnd.x )
		{
			if( m_ptEnd.x > (rectStripAdjusted.right - m_sizeMin.cx) )
			{
				m_ptStart.x = m_ptEnd.x - m_sizeMin.cx;
			}
			else
			{
				m_ptEnd.x = m_ptStart.x + m_sizeMin.cx;
			}
		}
		else
		{
			if( m_ptStart.x > (rectStripAdjusted.right - m_sizeMin.cx) )
			{
				m_ptEnd.x = m_ptStart.x - m_sizeMin.cx;
			}
			else
			{
				m_ptStart.x = m_ptEnd.x + m_sizeMin.cx;
			}
		}
	}

	// Enforce minimum height
	int nNewHeight = m_ptEnd.y - m_ptStart.y;
	int nAbsHeight = m_bAllowInvert ? abs(nNewHeight) : nNewHeight;
	if( nAbsHeight < m_sizeMin.cy )
	{
		if( m_ptStart.y <= m_ptEnd.y )
		{
			if( m_ptEnd.y > (rectStripAdjusted.bottom - m_sizeMin.cy) )
			{
				m_ptStart.y = m_ptEnd.y - m_sizeMin.cy;
			}
			else
			{
				m_ptEnd.y = m_ptStart.y + m_sizeMin.cy;
			}
		}
		else
		{
			if( m_ptStart.y > (rectStripAdjusted.bottom - m_sizeMin.cy) )
			{
				m_ptEnd.y = m_ptStart.y - m_sizeMin.cy;
			}
			else
			{
				m_ptStart.y = m_ptEnd.y + m_sizeMin.cy;
			}
		}
	}

	// put the values back into m_rect
	m_rect = CRect(m_ptStart, m_ptEnd);
	m_rect.OffsetRect( rectStrip.left, rectStrip.top );
	m_rect.OffsetRect( -lLeftPosition, 0 );
}

/////////////////////////////////////////////////////////////////////////////
// CCurveTracker::LimitRects
//
// Used when m_nAction = CTRK_DRAGGING
// Limits m_rect so that all selected curves will be within the boundaries
// of the strip.
void CCurveTracker::LimitRects() 
{
	// Get Curve Strip rectangle
	CRect rectStrip;
	if (!m_pCurveStrip->GetStripRect(rectStrip)) {
		return;
	}
	
	// Get Curve Strip left position
	long lLeftPosition;
	m_pITimeline->GetMarkerTime( MARKER_LEFTDISPLAY, TIMETYPE_CLOCKS, &lLeftPosition );
	m_pITimeline->ClocksToPosition( lLeftPosition, &lLeftPosition );
	long lOurLeftPosition = 0;
	if( m_pCurveStrip->m_pSequenceStrip->m_fPickupBar )
	{
		DMUS_TIMESIGNATURE dmTimeSig;
		GetTimeSig( 0, &dmTimeSig, m_pITimeline, m_pCurveStrip->m_pSequenceMgr->m_dwGroupBits );

		lOurLeftPosition = -dmTimeSig.bBeatsPerMeasure * ((DMUS_PPQ * 4) / dmTimeSig.bBeat);
		m_pITimeline->ClocksToPosition( lOurLeftPosition, &lOurLeftPosition );
	}
	if( lLeftPosition > 0 )
	{
		rectStrip.left -= lLeftPosition;
	}
	else if( lLeftPosition < lOurLeftPosition )
	{
		rectStrip.left += lOurLeftPosition - lLeftPosition;
	}

	// Get Curve Strip max right
	long lMaxPosition;
	m_pITimeline->ClocksToPosition( m_lPartClockLength, &lMaxPosition );
	
	CRect rectFBar;
	VARIANT var;
	var.vt = VT_BYREF;
	V_BYREF(&var) = &rectFBar;
	if( FAILED ( m_pITimeline->StripGetTimelineProperty( (IDMUSProdStrip *)m_pCurveStrip, STP_FBAR_RECT, &var ) ) )
	{
		return;
	}
	rectStrip.right = lMaxPosition + rectFBar.right - 1;
	rectStrip.right -= lLeftPosition;

	// adjust tracker rect
	CRect rectTracker = m_rect;
	rectTracker.OffsetRect( -m_nXOffset, 0 );

	// make a rect that includes all the curve rects
	CRect rectAllCurves = m_pDMCurve->m_rectFrame;
	rectAllCurves.OffsetRect(rectStrip.TopLeft());
	if( lLeftPosition < 0 )
	{
		if( lLeftPosition < lOurLeftPosition )
		{
			rectAllCurves.left -= lOurLeftPosition;
			rectAllCurves.right -= lOurLeftPosition;
		}
		else
		{
			rectAllCurves.left -= lLeftPosition;
			rectAllCurves.right -= lLeftPosition;
		}
	}
	CSize curveOffset =  rectTracker.CenterPoint() - rectAllCurves.CenterPoint();
	rectAllCurves.right = rectAllCurves.left;
	
	// iterate through the list of selected curves and update curveRect
	POSITION listPos;
	listPos = m_pCurveList->GetHeadPosition();
	while (listPos != NULL) {
		CCurveItem* pCurve = m_pCurveList->GetNext(listPos);
		
		CRect newRect = pCurve->m_rectFrame;
		newRect.OffsetRect(rectStrip.TopLeft());
		
		rectAllCurves.left = min(rectAllCurves.left, newRect.left);
		rectAllCurves.right = max(rectAllCurves.right, newRect.left);
		rectAllCurves.top = min(rectAllCurves.top, newRect.top);
		rectAllCurves.bottom = max(rectAllCurves.bottom, newRect.bottom);
	}
	
	rectAllCurves.OffsetRect(curveOffset);
	
	// figure out how much we are going to have to offset m_rect to make it
	// within the strip.
	CSize offset(0, 0);

	// make sure curveRect is within the bounds of the strip
	if (rectAllCurves.top < rectStrip.top) {
		offset.cy = rectStrip.top - rectAllCurves.top;
	}
	else if (rectAllCurves.bottom > rectStrip.bottom) {
		offset.cy = rectStrip.bottom - rectAllCurves.bottom;
	}
	if (rectAllCurves.left < rectStrip.left) {
		offset.cx = rectStrip.left - rectAllCurves.left;
	}
	else if (rectAllCurves.right > rectStrip.right) {
		offset.cx = rectStrip.right - rectAllCurves.right;
	}
	m_rect.OffsetRect(offset);
	m_offset = curveOffset + offset;
}

/////////////////////////////////////////////////////////////////////////////
// CCurveTracker::AdjustRect

void CCurveTracker::AdjustRect( int nHandle, RECT* pRect )
{
	CRectTracker::AdjustRect( nHandle, pRect );

	// Scroll if necessary
	ScrollPianoRoll();

	if (m_nAction == CTRK_DRAGGING) {
		LimitRects();
	}
	else {
		// Set the Start and End points
		SetStartEndPoints(nHandle);
	}
}


/////////////////////////////////////////////////////////////////////////////
// CCurveTracker::DrawTrackerRect

void CCurveTracker::DrawTrackerRect( LPCRECT lpRect, CWnd* pWndClipTo, CDC* pDC, CWnd* pWnd )
{
	UNREFERENCED_PARAMETER(pWnd);
	UNREFERENCED_PARAMETER(pWndClipTo);

	// Do not draw if we just scrolled the PianoRoll
	if( m_fScrolledPianoRoll )
	{
		m_fScrolledPianoRoll = FALSE;
		return;
	}

	// clip to the strip
	CRect rectStrip;
	if( !m_pCurveStrip->GetStripRect(rectStrip) )
	{
		return;
	}
	
	VARIANT var;
	CRect rectFBar;
	var.vt = VT_BYREF;
	V_BYREF(&var) = &rectFBar;
	if( FAILED ( m_pITimeline->StripGetTimelineProperty( (IDMUSProdStrip *)m_pCurveStrip, STP_FBAR_RECT, &var ) ) )
	{
		return;
	}
	rectFBar.InflateRect(1, 1);
	rectStrip.left = rectFBar.right;
	CRgn rgn;
	rgn.CreateRectRgn(rectStrip.left, rectStrip.top, rectStrip.right, rectStrip.bottom);
	pDC->SelectClipRgn(&rgn);
		
	// prepare DC for dragging
	pDC->SelectObject(CBrush::FromHandle((HBRUSH)::GetStockObject(NULL_BRUSH)));
	pDC->SetROP2(R2_XORPEN);
	CPen* pOldPen = NULL;
	CPen dragPen;
	if (dragPen.CreatePen(PS_DOT, 0, RGB(0, 0, 0))) {
		pOldPen = pDC->SelectObject(&dragPen);
	}

	if ( m_bErase == FALSE )
	{
		WORD wRefreshUI = DoAction();

		if( wRefreshUI )
		{
			m_pCurveStrip->RefreshCurveStrips();
			m_pCurveStrip->RefreshCurvePropertyPage();
			m_pWnd->UpdateWindow();
		}
	}

	
	if (m_nAction == CTRK_DRAGGING)
	{
		CRect rectFrame;

		// draw the other rects being dragged
		rectFrame = m_pDMCurve->m_rectFrame;
		rectFrame.OffsetRect( m_nXOffset, 0 );
		CSize offset = rectFrame.CenterPoint() - CRect(lpRect).CenterPoint();
		
		// iterate through the list of selected curves
		POSITION listPos;
		listPos = m_pCurveList->GetHeadPosition();
		while (listPos != NULL)
		{
			CCurveItem* pCurve = m_pCurveList->GetNext(listPos);
			rectFrame = pCurve->m_rectFrame;
			rectFrame.OffsetRect( m_nXOffset, 0 );
			pDC->Rectangle(rectFrame - offset);
		}
	}

	// draw the rect 
	pDC->Rectangle( lpRect );

	// cleanup
	if (pOldPen) {
		pDC->SelectObject(pOldPen);
		dragPen.DeleteObject();
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Shared\alist.h ===
//
// alist.h
//
#ifndef __ALIST_H__
#define __ALIST_H__

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

class AListItem
{
public:
    AListItem() { m_pNext=NULL; };
	virtual ~AListItem() {}
    AListItem *GetNext() const {return m_pNext;};
    void SetNext(AListItem *pNext) {m_pNext=pNext;};
    LONG GetCount() const;
    AListItem* Cat(AListItem* pItem);
    AListItem* AddTail(AListItem* pItem) {return Cat(pItem);};
    AListItem* Remove(AListItem* pItem);
    AListItem* GetPrev(AListItem *pItem) const;
    AListItem* GetItem(LONG index);

protected:
    AListItem *m_pNext;
};

class AList
{
public:
    AList() {m_pHead=NULL;};
	virtual ~AList() {} 
    AListItem *GetHead() const { return m_pHead;};

    void RemoveAll() { m_pHead=NULL;};
    LONG GetCount() const {return m_pHead->GetCount();}; 
    AListItem *GetItem(LONG index) { return m_pHead->GetItem(index);}; 
    void InsertBefore(AListItem *pItem,AListItem *pInsert);
    void Cat(AListItem *pItem) {m_pHead=m_pHead->Cat(pItem);};
    void Cat(AList *pList)
        {
//            assert(pList!=NULL);
            m_pHead=m_pHead->Cat(pList->GetHead());
        };
    void AddHead(AListItem *pItem)
        {
//            assert(pItem!=NULL);
            pItem->SetNext(m_pHead);
            m_pHead=pItem;
        }
    void AddTail(AListItem *pItem);// {m_pHead=m_pHead->AddTail(pItem);};
    void Remove(AListItem *pItem) {m_pHead=m_pHead->Remove(pItem);};
    AListItem *GetPrev(AListItem *pItem) const {return m_pHead->GetPrev(pItem);};
    AListItem *GetTail() const {return GetPrev(NULL);};
    BOOL IsEmpty(void) const {return (m_pHead==NULL);};
    BOOL IsMember(AListItem *pItem);
    AListItem *RemoveHead(void)
        {
            AListItem *li;
            li=m_pHead;
            if(m_pHead)
                m_pHead=m_pHead->GetNext();
            if (li)
                li->SetNext(NULL);
            return li;
        }
    void Reverse();

protected:
    AListItem *m_pHead;
};

#endif // __ALIST_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Shared\AList.cpp ===
//
// alist.cpp
//

#include "stdafx.h"
#include "alist.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

LONG AListItem::GetCount(void) const
{
    LONG l;
    const AListItem *li;

    for(l=0,li=this; li!=NULL ; li=li->m_pNext,++l);
    return l;
}

AListItem* AListItem::Cat(AListItem *pItem)
{
    AListItem *li;

    if(this==NULL)
        return pItem;
    for(li=this ; li->m_pNext!=NULL ; li=li->m_pNext);
    li->m_pNext=pItem;
    return this;
}

AListItem* AListItem::Remove(AListItem *pItem)
{
    AListItem *li,*prev;

    //treat remove(NULL) same as item not found in list
    if (pItem==NULL) 
    return this;

    if(pItem==this)
	{
		li = m_pNext;
		m_pNext = NULL;
        return li;
	}
    prev=NULL;
    for(li=this; li!=NULL && li!=pItem ; li=li->m_pNext)
        prev=li;
    if(li==NULL)     // item not found in list
        return this;

//  here it is guaranteed that prev is non-NULL since we checked for
//  that condition at the very beginning

    prev->SetNext(li->m_pNext);
    li->SetNext(NULL);
    return this;
}

AListItem* AListItem::GetPrev(AListItem *pItem) const
{
    const AListItem *li,*prev;

    prev=NULL;
    for(li=this ; li!=NULL && li!=pItem ; li=li->m_pNext)
        prev=li;
    return (AListItem*)prev;
}

AListItem * AListItem::GetItem(LONG index)

{
	AListItem *scan;
	for (scan = this; scan!=NULL && index; scan = scan->m_pNext) 
	{
		index--;
	}
	return (scan);
}

void AList::InsertBefore(AListItem *pItem,AListItem *pInsert)

{
	AListItem *prev = GetPrev(pItem);
	pInsert->SetNext(pItem);
	if (prev) prev->SetNext(pInsert);
	else m_pHead = pInsert;
}

void AList::AddTail(AListItem *pItem) 

{
    if (m_pHead == NULL)
    {
        AddHead(pItem);
    }
    else
    {
        m_pHead = m_pHead->AddTail(pItem);
    }
}

void AList::Reverse()
{
    AList Temp;
    AListItem *pItem;
    while (pItem = RemoveHead())
    {
        Temp.AddHead(pItem);
    }
    m_pHead = Temp.GetHead();
}

BOOL AList::IsMember(AListItem *pItem)
{
    AListItem *pScan = GetHead();
    for (;pScan;pScan = pScan->GetNext())
    {
        if (pItem == pScan) return TRUE;
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Shared\BaseMgr.cpp ===
/************************************************************************
*                                                                       *
*   Copyright (c) 1998-1999 Microsoft Corp. All rights reserved.        *
*                                                                       *
************************************************************************/

// BaseMgr.cpp : implementation file
//

#include "stdafx.h"
#include "BaseMgr.h"
#include <dmusici.h>
#include <dmusicf.h>
#include "SegmentGuids.h"
#include "SegmentIO.h"

// This sets up information for Visual C++'s memory leak tracing
#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/////////////////////////////////////////////////////////////////////////////
// CBaseMgr constructor/destructor 

CBaseMgr::CBaseMgr()
{
	// Initialize all our pointers to NULL
	m_pTimeline = NULL;
	m_pDMProdFramework = NULL;
	m_pIDocRootNode = NULL;
	m_pPropPageMgr = NULL;
	m_pCopyDataObject = NULL;
	m_pIDMTrack = NULL;
	m_pBaseStrip = NULL;

	// By default, belong to Group 1 only
	m_dwGroupBits = 1;
	m_dwOldGroupBits = 1;

	// Initially we don't need to be saved
	m_fDirty = FALSE;

	// Initially, no edits have happened
	m_nLastEdit = 0;

	// Initalize track flags
	m_dwTrackExtrasFlags = DMUS_TRACKCONFIG_DEFAULT;
	m_dwProducerOnlyFlags = 0;

	// TODO: Derived class must create a strip and assign it to m_pBaseStrip
	// OR: Derived class must override all methods referencing m_pBaseStrip
}

CBaseMgr::~CBaseMgr()
{
	// Clean up our references
	if( m_pDMProdFramework )
	{
		m_pDMProdFramework->Release();
		m_pDMProdFramework = NULL;
	}

	ASSERT( m_pTimeline == NULL );
	ASSERT( m_pBaseStrip == NULL );

	if( m_pPropPageMgr )
	{
		m_pPropPageMgr->Release();
		m_pPropPageMgr = NULL;
	}
	if( m_pIDMTrack )
	{
		m_pIDMTrack->Release();
		m_pIDMTrack = NULL;
	}

	// If we have an object on the clipboard, make sure it doesn't have any references
	// back to us.
	if( m_pCopyDataObject )
	{
		if( S_OK == OleIsCurrentClipboard( m_pCopyDataObject ))
		{
			OleFlushClipboard();
		}
		m_pCopyDataObject->Release();
		m_pCopyDataObject = NULL;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CBaseMgr IDMUSProdStripMgr implementation


/////////////////////////////////////////////////////////////////////////////
// CBaseMgr::GetParam

HRESULT STDMETHODCALLTYPE CBaseMgr::GetParam(
		/* [in] */	REFGUID 	guidType,
		/* [in] */	MUSIC_TIME	mtTime,
		/* [out] */ MUSIC_TIME* pmtNext,
		/* [out] */ void*		pData)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	UNREFERENCED_PARAMETER(mtTime);
	UNREFERENCED_PARAMETER(pmtNext);

	ASSERT( pData != NULL );
	if( pData == NULL )
	{
		return E_POINTER;
	}

	// Check if the segment is asking for a string to display in the Undo and Redo edit menu items
	if( ::IsEqualGUID( guidType, GUID_Segment_Undo_BSTR ) )
	{
		// Try and load our current undo string
		CComBSTR comBSTR;
		if( comBSTR.LoadString( m_nLastEdit ) )
		{
			// Succeeded - return the BSTR
			*(BSTR*)pData = comBSTR.Detach();
			return S_OK;
		}
		return E_FAIL;
	}

	// Get DocRoot node of StripMgr's file (i.e. the Segment)
	if( ::IsEqualGUID( guidType, GUID_DocRootNode ) )
	{
		IDMUSProdNode** ppIDocRootNode = (IDMUSProdNode **)pData;

		*ppIDocRootNode = m_pIDocRootNode;
		if( m_pIDocRootNode )
		{
			m_pIDocRootNode->AddRef();
		}
		return S_OK;
	}

	return E_INVALIDARG;
}


/////////////////////////////////////////////////////////////////////////////
// CBaseMgr::SetParam

HRESULT STDMETHODCALLTYPE CBaseMgr::SetParam(
		/* [in] */ REFGUID		guidType,
		/* [in] */ MUSIC_TIME	mtTime,
		/* [in] */ void*		pData)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	UNREFERENCED_PARAMETER(mtTime);

	if( pData == NULL )
	{
		return E_POINTER;
	}

	if( ::IsEqualGUID( guidType, GUID_DocRootNode ) )
	{
		IDMUSProdNode* pIDocRootNode = (IDMUSProdNode *)pData;

		m_pIDocRootNode = pIDocRootNode;
		return S_OK;
	}

	return E_INVALIDARG;
}


/////////////////////////////////////////////////////////////////////////////
// CBaseMgr::IsParamSupported

HRESULT STDMETHODCALLTYPE CBaseMgr::IsParamSupported(
		/* [in] */ REFGUID		guidType)
{
	// Not needed
	//AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// We support returning text to display in the Undo and Redo edit menu items.
	// We support GUID_DocRootNode for maintaining pointer to our DocRoot node.
	if( ::IsEqualGUID( guidType, GUID_Segment_Undo_BSTR ) 
	||  ::IsEqualGUID( guidType, GUID_DocRootNode ) )
	{
		return S_OK;
	}
	return E_INVALIDARG;
}


/////////////////////////////////////////////////////////////////////////////
// CBaseMgr::OnUpdate

HRESULT STDMETHODCALLTYPE CBaseMgr::OnUpdate(
		/* [in] */  REFGUID		rguidType,
		/* [in] */  DWORD		dwGroupBits,
		/* [in] */	void*		pData)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	UNREFERENCED_PARAMETER(pData);

	// If the update isn't for our strip, exit
	if( !(dwGroupBits & m_dwGroupBits) )
	{
		return E_INVALIDARG;
	}

	// TimeSig change
	if( ::IsEqualGUID( rguidType, GUID_TimeSignature ) )
	{
		// Update the m_mtTime value of all items
		if( RecomputeTimes() )
		{
			if( m_pPropPageMgr )
			{
				m_pPropPageMgr->RefreshData();
			}
			OnDataChanged();
		}

		// Redraw our strip
		if( m_pBaseStrip )
		{
			m_pTimeline->StripInvalidateRect( m_pBaseStrip, NULL, TRUE );
		}
		return S_OK;
	}

	// All Tracks Added
	if( ::IsEqualGUID( rguidType, GUID_Segment_AllTracksAdded ) )
	{
		// Update the m_mtTime value of all items
		RecomputeTimes();

		// Redraw our strip
		if( m_pBaseStrip )
		{
			m_pTimeline->StripInvalidateRect( m_pBaseStrip, NULL, TRUE );
		}
		return S_OK;
	}

	// We don't handle whichever notification was passed to us
	return E_INVALIDARG;
}


/////////////////////////////////////////////////////////////////////////////
// CBaseMgr::GetStripMgrProperty

HRESULT STDMETHODCALLTYPE CBaseMgr::GetStripMgrProperty(
		/* [in] */ STRIPMGRPROPERTY stripMgrProperty,
		/* [out] */ VARIANT*	pVariant)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	ASSERT( pVariant );
	if( !pVariant )
	{
		return E_POINTER;
	}

	switch( stripMgrProperty )
	{
	case SMP_ITIMELINECTL:
		// Return a copy of our timeline pointer
		pVariant->vt = VT_UNKNOWN;
		if( m_pTimeline )
		{
			return m_pTimeline->QueryInterface( IID_IUnknown, (void**)&V_UNKNOWN( pVariant ) );
		}
		else
		{
			V_UNKNOWN( pVariant ) = NULL;
			return E_FAIL;
		}
		break;

	case SMP_IDIRECTMUSICTRACK:
		// Return a copy of our DirectMusic track pointer
		pVariant->vt = VT_UNKNOWN;
		if( m_pIDMTrack )
		{
			return m_pIDMTrack->QueryInterface( IID_IUnknown, (void**)&V_UNKNOWN( pVariant ) );
		}
		else
		{
			V_UNKNOWN( pVariant ) = NULL;
			return E_FAIL;
		}
		break;

	case SMP_IDMUSPRODFRAMEWORK:
		// Return a copy of our framework pointer
		pVariant->vt = VT_UNKNOWN;
		if( m_pDMProdFramework )
		{
			return m_pDMProdFramework->QueryInterface( IID_IUnknown, (void**)&V_UNKNOWN( pVariant ) );
		}
		else
		{
			V_UNKNOWN( pVariant ) = NULL;
			return E_FAIL;
		}
		break;

	case SMP_DMUSIOTRACKHEADER:
		// Check that the caller passed in a reference
		if( pVariant->vt != VT_BYREF )
		{
			return E_INVALIDARG;
		}
		else
		{
			// The reference passed by the caller is a pointer to a DMUS_TRACK_HEADER structure.
			DMUS_IO_TRACK_HEADER *pioTrackHeader = static_cast<DMUS_IO_TRACK_HEADER *>(V_BYREF( pVariant ));
			if( pioTrackHeader == NULL )
			{
				return E_POINTER;
			}

			// Fill in the structure with our data
			pioTrackHeader->guidClassID = m_clsid;
			pioTrackHeader->dwPosition = 0;
			pioTrackHeader->dwGroup = m_dwGroupBits;
			pioTrackHeader->ckid = m_ckid;
			pioTrackHeader->fccType = m_fccType;
		}
		break;

	case SMP_DMUSIOTRACKEXTRASHEADER:
		if( pVariant->vt != VT_BYREF )
		{
			return E_INVALIDARG;
		}
		else
		{
			DMUS_IO_TRACK_EXTRAS_HEADER *pioTrackExtrasHeader = static_cast<DMUS_IO_TRACK_EXTRAS_HEADER *>(V_BYREF( pVariant ));
			if( pioTrackExtrasHeader == NULL )
			{
				return E_POINTER;
			}

			pioTrackExtrasHeader->dwFlags = m_dwTrackExtrasFlags;
		}
		break;

	case SMP_DMUSIOTRACKEXTRASHEADER_MASK:
		pVariant->vt = VT_I4;
		V_I4(pVariant) = g_dwTrackExtrasMask;
		break;

	case SMP_PRODUCERONLY_FLAGS:
		if( pVariant->vt != VT_BYREF )
		{
			return E_INVALIDARG;
		}
		else
		{
			IOProducerOnlyChunk *pioProducerOnlyChunk = static_cast<IOProducerOnlyChunk *>(V_BYREF( pVariant ));
			if( pioProducerOnlyChunk == NULL )
			{
				return E_POINTER;
			}

			pioProducerOnlyChunk->dwProducerOnlyFlags = m_dwProducerOnlyFlags;
		}
		break;

	default:
		return E_INVALIDARG;
	}
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CBaseMgr::SetStripMgrProperty

HRESULT STDMETHODCALLTYPE CBaseMgr::SetStripMgrProperty(
		/* [in] */ STRIPMGRPROPERTY stripMgrProperty,
		/* [in] */ VARIANT		variant)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	switch( stripMgrProperty )
	{
	case SMP_ITIMELINECTL:
		// Check that the caller passed in an IUnknown pointer
		if( variant.vt != VT_UNKNOWN )
		{
			return E_INVALIDARG;
		}

		// If we were previously attached to a timeline
		if( m_pTimeline )
		{
			// Make sure our property page isn't displayed
			m_pTimeline->RemovePropertyPageObject((IDMUSProdPropPageObject*)this);

			// Release our reference on our property page manager
			if( m_pPropPageMgr )
			{
				m_pPropPageMgr->Release();
				m_pPropPageMgr = NULL;
			}

			// Remove our strip from the Timeline
			if ( m_pBaseStrip )
			{
				// Make sure our strip's property page isn't displayed
				m_pTimeline->RemovePropertyPageObject((IDMUSProdPropPageObject*)m_pBaseStrip);
				m_pTimeline->RemoveStrip( (IDMUSProdStrip *)m_pBaseStrip );
			}

			// Remove ourself from the Timeline's notification list
			m_pTimeline->RemoveFromNotifyList( (IDMUSProdStripMgr *)this, GUID_TimeSignature, m_dwOldGroupBits );
			m_pTimeline->RemoveFromNotifyList( (IDMUSProdStripMgr *)this, GUID_Segment_AllTracksAdded, m_dwOldGroupBits );

			// Release our reference on the Timeline
			m_pTimeline->Release();
			m_pTimeline = NULL;
		}

		// If a non-NULL pointer was passed in
		if( V_UNKNOWN( &variant ) )
		{
			// Query the pointer for a Timeline interface
			if( FAILED( V_UNKNOWN( &variant )->QueryInterface( IID_IDMUSProdTimeline, (void**)&m_pTimeline )))
			{
				return E_FAIL;
			}
			else
			{
				// Add the strip to the timeline
				ASSERT( m_pBaseStrip );
				m_pTimeline->InsertStripAtDefaultPos( (IDMUSProdStrip *)m_pBaseStrip, m_clsid, m_dwGroupBits, 0 );

				// Add ourself to the Timeline's notification list
				m_pTimeline->AddToNotifyList( (IDMUSProdStripMgr *)this, GUID_TimeSignature, m_dwGroupBits );
				m_pTimeline->AddToNotifyList( (IDMUSProdStripMgr *)this, GUID_Segment_AllTracksAdded, m_dwGroupBits );
			}
		}
		break;

	case SMP_IDIRECTMUSICTRACK:
		// Check that the caller passed in an IUnknown pointer
		if( variant.vt != VT_UNKNOWN )
		{
			return E_INVALIDARG;
		}

		// If we have an existing DirectMusic track pointer, release it
		if( m_pIDMTrack )
		{
			m_pIDMTrack->Release();
			m_pIDMTrack = NULL;
		}

		// If we were passed a non-NULL pointer, query it for an IDirectMusicTrack interface
		if( V_UNKNOWN( &variant ) )
		{
			V_UNKNOWN( &variant )->QueryInterface( IID_IDirectMusicTrack, (void**)&m_pIDMTrack );
		}
		break;

	case SMP_IDMUSPRODFRAMEWORK:
		// Check that the caller passed in an IUnknown pointer
		if( variant.vt != VT_UNKNOWN )
		{
			return E_INVALIDARG;
		}

		// If we have an existing Framework pointer, release it
		if( m_pDMProdFramework )
		{
			m_pDMProdFramework->Release();
			m_pDMProdFramework = NULL;
		}

		// If we were passed a non-NULL pointer, query it for an IDMUSProdFramework interface
		if( V_UNKNOWN( &variant ) )
		{
			return V_UNKNOWN( &variant )->QueryInterface( IID_IDMUSProdFramework, (void**)&m_pDMProdFramework);
		}
		break;

	case SMP_DMUSIOTRACKHEADER:
		// Check that the caller passed in a reference
		if( variant.vt != VT_BYREF )
		{
			return E_INVALIDARG;
		}
		else
		{
			// The reference should be a pointer to a DMUS_IO_TRACK_HEADER structure
			DMUS_IO_TRACK_HEADER *pioTrackHeader = static_cast<DMUS_IO_TRACK_HEADER *>(V_BYREF( &variant ));
			if( pioTrackHeader == NULL )
			{
				return E_POINTER;
			}

			// Update our group bits settings
			// If your strip does not support changing its group bits, you must override
			// this method so that m_dwGroupBits and m_dwOldGroupBits do not get updated.
			m_dwGroupBits = pioTrackHeader->dwGroup;
			m_dwOldGroupBits = pioTrackHeader->dwGroup;

			// Ignore everything else in the structure, since we don't care about it
		}
		break;

	case SMP_DMUSIOTRACKEXTRASHEADER:
		if( variant.vt != VT_BYREF )
		{
			return E_INVALIDARG;
		}
		else
		{
			DMUS_IO_TRACK_EXTRAS_HEADER *pioTrackExtrasHeader = static_cast<DMUS_IO_TRACK_EXTRAS_HEADER *>(V_BYREF( &variant ));
			if( pioTrackExtrasHeader == NULL )
			{
				return E_POINTER;
			}

			m_dwTrackExtrasFlags = pioTrackExtrasHeader->dwFlags;
		}
		break;

	case SMP_PRODUCERONLY_FLAGS:
		if( variant.vt != VT_BYREF )
		{
			return E_INVALIDARG;
		}
		else
		{
			IOProducerOnlyChunk *pioProducerOnlyChunk = static_cast<IOProducerOnlyChunk *>(V_BYREF( &variant ));
			if( pioProducerOnlyChunk == NULL )
			{
				return E_POINTER;
			}

			m_dwProducerOnlyFlags = pioProducerOnlyChunk->dwProducerOnlyFlags;
		}
		break;

	default:
		// We don't support whichever property was given
		return E_INVALIDARG;
	}
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CBaseMgr IPersist implementation

/////////////////////////////////////////////////////////////////////////////
// CBaseMgr::GetClassID

HRESULT CBaseMgr::GetClassID( CLSID* pClsId )
{
	// Not needed
	//AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Validate pClsId
	if ( pClsId == NULL )
	{
		return E_POINTER;
	}

	// return our CLSID
	memcpy( pClsId, &m_clsid, sizeof( CLSID ) );

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CBaseMgr IPersistStream implementation

/////////////////////////////////////////////////////////////////////////////
// CBaseMgr::IsDirty

HRESULT CBaseMgr::IsDirty()
{
	// Not needed
	//AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if ( m_fDirty )
	{
		return S_OK; // Dirty
	}
	else
	{
		return S_FALSE; // Clean
	}
}


/////////////////////////////////////////////////////////////////////////////
// CBaseMgr::GetSizeMax

HRESULT CBaseMgr::GetSizeMax( ULARGE_INTEGER FAR* pcbSize )
{
	// Not needed
	//AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	UNREFERENCED_PARAMETER(pcbSize);

	// Compute size of stream needed to persist ourself into.
	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CBaseMgr IDMUSProdPropPageObject implementation

/////////////////////////////////////////////////////////////////////////////
// CBaseMgr::OnRemoveFromPageManager

HRESULT STDMETHODCALLTYPE CBaseMgr::OnRemoveFromPageManager( void)
{
	// Not needed
	//AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// If you want to do something special when your property page is no longer
	// displayed, do it here.
	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CBaseMgr implementation

/////////////////////////////////////////////////////////////////////////////
// CBaseMgr::OnDataChanged

void CBaseMgr::OnDataChanged( void )
{
	// Verify that we have a valid pointer to the Timeline
	if ( m_pTimeline == NULL )
	{
		return;
	}

	// Let our hosting editor know about the change
	IUnknown *punkStripMgr;
	if( SUCCEEDED( QueryInterface( IID_IUnknown, (void **)&punkStripMgr ) ) )
	{
		m_pTimeline->OnDataChanged( punkStripMgr );
		punkStripMgr->Release();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CBaseMgr::SyncWithDirectMusic

HRESULT CBaseMgr::SyncWithDirectMusic( void )
{
	// If there is no DirectMusic Track, return S_FALSE
	if( m_pIDMTrack == NULL )
	{
		return S_FALSE;
	}

	// Create a memory stream to use
	IStream* pIMemStream = NULL;
	HRESULT hr = m_pDMProdFramework->AllocMemoryStream( FT_RUNTIME, GUID_DirectMusicObject, &pIMemStream );
	if( SUCCEEDED ( hr ) )
	{
		// Ensure the stream is at the beginning
		const LARGE_INTEGER liStart = {0,0};
		pIMemStream->Seek( liStart, STREAM_SEEK_SET, NULL );

		// Save our self
		hr = Save(pIMemStream, FALSE);
		if ( SUCCEEDED( hr ) )
		{
			// Query the DirectMusic Track for its IPersistStream interface
			IPersistStream* pIPersistStream = NULL;
			hr = m_pIDMTrack->QueryInterface(IID_IPersistStream, (void**)&pIPersistStream);
			if ( SUCCEEDED( hr ) )
			{
				// Seek back to the beginning of the stream
				pIMemStream->Seek( liStart, STREAM_SEEK_SET, NULL );

				// Load the DirectMusic Track with the new data
				hr = pIPersistStream->Load(pIMemStream);

				// If we have a Segment DocRoot Node pointer, initialize the DirectMusic Track
				if( m_pIDocRootNode )
				{
					// Get a pointer to the DirectMusic segment the track is in
					IDirectMusicSegment *pSegment;
					if( SUCCEEDED( m_pIDocRootNode->GetObject(CLSID_DirectMusicSegment, IID_IDirectMusicSegment, (void **)&pSegment ) ) )
					{
						// Now, initialize the track.
						m_pIDMTrack->Init( pSegment );
						pSegment->Release();
					}
				}

				// Release the track's IPersistStream interface reference
				pIPersistStream->Release();
			}
		}

		// Release the reference to the memory stream
		pIMemStream->Release();
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// MeasureBeatToBeats

HRESULT MeasureBeatToBeats( IDMUSProdTimeline *pITimeline, DWORD dwGroupBits, DWORD dwIndex, long lMeasure, long lBeat, long &lNumBeats )
{
	// Validate parameters
	ASSERT( pITimeline );
	ASSERT( dwGroupBits );
	ASSERT( lMeasure >= 0 );
	ASSERT( lBeat >= 0 );

	if( NULL == pITimeline )
	{
		return E_POINTER;
	}

	if( dwGroupBits == 0 )
	{
		return E_INVALIDARG;
	}

	// Initialize variables
	HRESULT hr;
	DMUS_TIMESIGNATURE TimeSig;
	MUSIC_TIME mtTSCur = 0, mtTSNext = 1;

	// Initialize value to return
	lNumBeats = 0;

	// Loop until lMeasure is zero
	do
	{
		// Get the time signature at mtTSCur
		hr = pITimeline->GetParam( GUID_TimeSignature, dwGroupBits, dwIndex, mtTSCur, &mtTSNext, &TimeSig );
		if ( FAILED( hr ) )
		{
			return E_UNEXPECTED;
		}

		// Check if this time signature is valid forever
		if( mtTSNext == 0 )
		{
			// Just compute the number of beats to add and break out of the loop
			lNumBeats += lMeasure * TimeSig.bBeatsPerMeasure;
			break;
		}
		else
		{
			// Compute the number of clocks in a measure
			long lMeasureClocks = TimeSig.bBeatsPerMeasure * NOTE_TO_CLOCKS( TimeSig.bBeat, DMUS_PPQ );

			// Compute the number of measures until the next time signature
			long lTmpMeasures = mtTSNext / lMeasureClocks;

			// If we won't reach the next time signature
			if( lMeasure <= lTmpMeasures )
			{
				// Just compute the number of beats to add and break out of the loop
				lNumBeats += lMeasure * TimeSig.bBeatsPerMeasure;
				break;
			}
			else
			{
				// Compute when to look for the next time signature
				mtTSCur += lMeasureClocks * lTmpMeasures;

				// Compute the number of beats to add
				lNumBeats += lTmpMeasures * TimeSig.bBeatsPerMeasure;

				// Update the number of measures we have left to traverse
				lMeasure -= lTmpMeasures;
			}
		}
	}
	while( lMeasure > 0 );

	// We've compute all the beats from the lMeasure paramter - now just add lBeat
	lNumBeats += lBeat;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// BeatsToMeasureBeat

HRESULT BeatsToMeasureBeat( IDMUSProdTimeline *pITimeline, DWORD dwGroupBits, DWORD dwIndex, long lNumBeats, long &lMeasure, long &lBeat )
{
	// Validate parameters
	ASSERT( pITimeline );
	ASSERT( dwGroupBits );
	ASSERT( lNumBeats >= 0 );

	if( NULL == pITimeline )
	{
		return E_POINTER;
	}

	if( dwGroupBits == 0 )
	{
		return E_INVALIDARG;
	}

	// Initialize variables
	DMUS_TIMESIGNATURE TimeSig;
	MUSIC_TIME mtTSCur = 0, mtTSNext;
	lBeat = 0;
	lMeasure = 0;

	do
	{
		// Try and get the current time signature
		if ( FAILED( pITimeline->GetParam( GUID_TimeSignature, dwGroupBits, dwIndex, mtTSCur, &mtTSNext, &TimeSig ) ) )
		{
			return E_UNEXPECTED;
		}

		// If there is no next time signature, do the math to find how many more measures to add
		if( mtTSNext == 0 )
		{
			lMeasure += lNumBeats / TimeSig.bBeatsPerMeasure;
			lNumBeats %= TimeSig.bBeatsPerMeasure;
			break;
		}
		// Otherwise it's more complicated
		else
		{
			// Compute the number of clocks in a beat
			long lBeatClocks = NOTE_TO_CLOCKS( TimeSig.bBeat, DMUS_PPQ );

			// If the next time signature is after the time we're looking for
			if( lNumBeats < mtTSNext / lBeatClocks )
			{
				// Add the number of complete measures between here and there
				lMeasure += lNumBeats / TimeSig.bBeatsPerMeasure;

				// lNumBeats now stores an offset from the beginning of the measure
				lNumBeats %= TimeSig.bBeatsPerMeasure;
				break;
			}
			// The next time signature is before the time we're looking for
			else
			{
				// Compute how many complete measures there are between now and the next Time signature
				long lMeasureDiff= mtTSNext / (TimeSig.bBeatsPerMeasure * lBeatClocks);

				// Add them to lMeasure
				lMeasure += lMeasureDiff;

				// Subtract off the number of beats between mtTSCur and mtTSNext
				lNumBeats -= lMeasureDiff * TimeSig.bBeatsPerMeasure;

				// Change lMeasureDiff from measures to clocks
				lMeasureDiff *= TimeSig.bBeatsPerMeasure * lBeatClocks;

				// Add the clocks of the measures between mtTSCur and mtTSNext to mtTSCur
				mtTSCur += lMeasureDiff;
			}
		}
	}
	// While the beats left is greater than 0
	while ( lNumBeats > 0 );

	// Any leftover beats are assigned to lBeat
	lBeat = lNumBeats;

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Shared\BaseMgr.h ===
/************************************************************************
*                                                                       *
*   Copyright (c) 1998-2001 Microsoft Corp. All rights reserved.        *
*                                                                       *
************************************************************************/

// BaseMgr.h : Declaration of the CBaseMgr

#ifndef __BASEMGR_H_
#define __BASEMGR_H_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include <DMUSProd.h>

class CDllJazzDataObject;
interface IDirectMusicTrack;
class CBaseMgr;
class CBaseStrip;
class CListSelectedRegion;

extern const DWORD g_dwTrackExtrasMask;
extern const DWORD g_dwProducerOnlyMask;

#define NOTE_TO_CLOCKS(note, ppq) ( (ppq)*4 /(note) )

CString GetName(DWORD dwGroupBits, CString strName);
HRESULT CopyDataToClipboard( IDMUSProdTimelineDataObject* pITimelineDataObject, IStream* pStreamCopy, UINT uiClipFormat, CBaseMgr *pBaseMgr, CBaseStrip *pBaseStrip );
HRESULT GetTimelineDataObject( IDMUSProdTimelineDataObject* &pITimelineDataObject, IDMUSProdTimeline* pTimeline, IDataObject *pIDataObject = NULL );
HRESULT MeasureBeatToBeats( IDMUSProdTimeline *pITimeline, DWORD dwGroupBits, DWORD dwIndex, long lMeasure, long lBeat, long &lNumBeats );
HRESULT BeatsToMeasureBeat( IDMUSProdTimeline *pITimeline, DWORD dwGroupBits, DWORD dwIndex, long lNumBeats, long &lMeasure, long &lBeat );

/////////////////////////////////////////////////////////////////////////////
// CBaseMgr
class ATL_NO_VTABLE CBaseMgr : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public IDMUSProdStripMgr,
	public IPersistStream,
	public IDMUSProdPropPageObject
{
friend CBaseStrip;

public:
	CBaseMgr();
	virtual ~CBaseMgr();

BEGIN_COM_MAP(CBaseMgr)
	COM_INTERFACE_ENTRY(IDMUSProdStripMgr)
	COM_INTERFACE_ENTRY(IPersist)
	COM_INTERFACE_ENTRY(IPersistStream)
	COM_INTERFACE_ENTRY(IDMUSProdPropPageObject)
END_COM_MAP()

// IDMUSProdStripMgr methods
	virtual STDMETHODIMP IsParamSupported( REFGUID guidType );
	virtual STDMETHODIMP GetParam( REFGUID guidType, MUSIC_TIME mtTime, MUSIC_TIME* pmtNext, void* pData );
	virtual STDMETHODIMP SetParam( REFGUID guidType, MUSIC_TIME mtTime, void* pData );
	virtual STDMETHODIMP OnUpdate( REFGUID rguidType, DWORD dwGroupBits, void *pData );
	virtual STDMETHODIMP GetStripMgrProperty( STRIPMGRPROPERTY stripMgrProperty, VARIANT* pVariant );
	virtual STDMETHODIMP SetStripMgrProperty( STRIPMGRPROPERTY stripMgrProperty, VARIANT variant );

// IPersist methods
	virtual STDMETHODIMP GetClassID( CLSID* pClsId );

// IPersistStream methods
	virtual HRESULT STDMETHODCALLTYPE IsDirty();
	virtual HRESULT STDMETHODCALLTYPE Load( IStream* pIStream ) = 0;
	virtual HRESULT STDMETHODCALLTYPE Save( IStream* pIStream, BOOL fClearDirty ) = 0;
	virtual HRESULT STDMETHODCALLTYPE GetSizeMax( ULARGE_INTEGER FAR* pcbSize );

// IDMUSProdPropPageObject methods
	virtual HRESULT STDMETHODCALLTYPE GetData( void **ppData) = 0;
	virtual HRESULT STDMETHODCALLTYPE SetData( void *pData) = 0;
	virtual HRESULT STDMETHODCALLTYPE OnShowProperties( void) = 0;
	virtual HRESULT STDMETHODCALLTYPE OnRemoveFromPageManager( void);

protected:
	virtual void	OnDataChanged( void );
	virtual bool	RecomputeTimes( void ) = 0; // Returns true if anything changed
	virtual HRESULT	SyncWithDirectMusic( void ); // Returns S_OK if succeeded, S_FALSE if no track, E_* if failed.

public:
	IDMUSProdNode* GetDocRootNode()
	{
		return m_pIDocRootNode;
	}

public:
	IDMUSProdTimeline*			m_pTimeline;
	IDataObject*				m_pCopyDataObject;

protected:
	IDMUSProdFramework* 		m_pDMProdFramework;
	IDMUSProdNode*		 		m_pIDocRootNode;		// strip mgr belongs to this file (i.e. segment)
	IDMUSProdPropPageManager*	m_pPropPageMgr;
	IDirectMusicTrack*			m_pIDMTrack;
	CBaseStrip*					m_pBaseStrip;
	DWORD						m_dwGroupBits;
	DWORD						m_dwOldGroupBits;
	bool						m_fDirty;
	UINT						m_nLastEdit;			// resource id of last edit
	DWORD						m_dwTrackExtrasFlags;
	DWORD						m_dwProducerOnlyFlags;

protected:
	static const CLSID			m_clsid;
	static const DWORD			m_fccType;
	static const DWORD			m_ckid;
};


class CBaseStrip :
	public IDMUSProdStrip,
	public IDMUSProdStripFunctionBar,
	public IDMUSProdTimelineEdit,
	public IDropSource,
	public IDropTarget,
	public IDMUSProdPropPageObject
{
friend CBaseMgr;

public:
	CBaseStrip( CBaseMgr* pLyricMgr );
	virtual ~CBaseStrip();

// IUnknown
	virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
	virtual STDMETHODIMP_(ULONG) AddRef();
	virtual STDMETHODIMP_(ULONG) Release();

// IDMUSProdStrip
	virtual HRESULT STDMETHODCALLTYPE Draw( HDC hDC, STRIPVIEW sv, LONG lXOffset );
	virtual HRESULT STDMETHODCALLTYPE GetStripProperty( STRIPPROPERTY sp, VARIANT *pvar);
	virtual HRESULT STDMETHODCALLTYPE SetStripProperty( STRIPPROPERTY sp, VARIANT var);
	virtual HRESULT STDMETHODCALLTYPE OnWMMessage( UINT nMsg, WPARAM wParam, LPARAM lParam, LONG lXPos, LONG lYPos );

// IDMUSProdStripFunctionBar
	virtual HRESULT STDMETHODCALLTYPE FBDraw( HDC hDC, STRIPVIEW sv );
	virtual HRESULT STDMETHODCALLTYPE FBOnWMMessage( UINT nMsg, WPARAM wParam, LPARAM lParam, LONG lXPos, LONG lYPos );

// IDMUSProdTimelineEdit
	virtual HRESULT STDMETHODCALLTYPE Cut( IDMUSProdTimelineDataObject* pITimelineDataObject = NULL );
	virtual HRESULT STDMETHODCALLTYPE Copy( IDMUSProdTimelineDataObject* pITimelineDataObject = NULL ) = 0;
	virtual HRESULT STDMETHODCALLTYPE Paste( IDMUSProdTimelineDataObject* pITimelineDataObject = NULL ) = 0;
	virtual HRESULT STDMETHODCALLTYPE Insert( void ) = 0;
	virtual HRESULT STDMETHODCALLTYPE Delete( void ) = 0;
	virtual HRESULT STDMETHODCALLTYPE SelectAll( void );
	virtual HRESULT STDMETHODCALLTYPE CanCut( void );
	virtual HRESULT STDMETHODCALLTYPE CanCopy( void );
	virtual HRESULT STDMETHODCALLTYPE CanPaste( IDMUSProdTimelineDataObject* pITimelineDataObject ) = 0;
	virtual HRESULT STDMETHODCALLTYPE CanInsert( void ) = 0;
	virtual HRESULT STDMETHODCALLTYPE CanDelete( void );
	virtual HRESULT STDMETHODCALLTYPE CanSelectAll( void );

// IDropSource
	virtual HRESULT STDMETHODCALLTYPE QueryContinueDrag( BOOL fEscapePressed, DWORD grfKeyState );
	virtual HRESULT STDMETHODCALLTYPE GiveFeedback( DWORD dwEffect );

// IDropTarget methods
	virtual HRESULT STDMETHODCALLTYPE DragEnter( IDataObject* pIDataObject, DWORD grfKeyState, POINTL pt, DWORD* pdwEffect);
	virtual HRESULT STDMETHODCALLTYPE DragOver( DWORD grfKeyState, POINTL pt, DWORD* pdwEffect);
	virtual HRESULT STDMETHODCALLTYPE DragLeave( void );
	virtual HRESULT STDMETHODCALLTYPE Drop( IDataObject* pIDataObject, DWORD grfKeyState, POINTL pt, DWORD* pdwEffect) = 0;

// IDMUSProdPropPageObject functions
	virtual HRESULT STDMETHODCALLTYPE GetData( void **ppData );
	virtual HRESULT STDMETHODCALLTYPE SetData( void *pData );
	virtual HRESULT STDMETHODCALLTYPE OnShowProperties( void );
	virtual HRESULT STDMETHODCALLTYPE OnRemoveFromPageManager( void );

protected:
// General helpers
	virtual bool	SelectItemsInSelectedRegions( void ) = 0;
	virtual bool	IsSelected( void ) = 0; // Returns true if any items are selected
	virtual bool	IsEmpty( void ) = 0;	// Returns false if there are any items
	virtual bool	SelectSegment(long begintime, long endtime) = 0; // Returns true if anything changed
	virtual HRESULT	ShowPropertySheet( void );
	virtual HRESULT	PostRightClickMenu( POINT pt );
	virtual HWND	GetTimelineHWND();

// IDropTarget helper
	virtual HRESULT CanPasteFromData(IDataObject* pIDataObject) = 0;

protected:
	long		m_cRef;
	CBaseMgr*	m_pBaseMgr;

public:
	CListSelectedRegion*	m_pSelectedRegions;

protected:
	LONG		m_lGutterBeginSelect;
	LONG		m_lGutterEndSelect;
	BOOL		m_bGutterSelected;		// whether the gutter select is selected, use
	
	BOOL		m_fSelecting;
	short		m_nStripIsDragDropSource;	
	static IDMUSProdNode*	m_pIDocRootOfDragDropSource;
	static BOOL				m_fDragDropIntoSameDocRoot;

	LONG		m_lXPos;				// used for temp storage of xpos when doing mouse edits

	IDataObject*m_pISourceDataObject;	// Object being dragged 
	IDataObject*m_pITargetDataObject;
	DWORD		m_dwStartDragButton;	// Mouse button that initiated drag operation
	DWORD		m_dwOverDragButton; 	// Mouse button stored in IDropTarget::DragOver
	DWORD		m_dwOverDragEffect; 	// Drag effects stored in IDropTarget::DragOver
	DWORD		m_dwDragRMenuEffect;	// Result from drag context menu
	LONG		m_lStartDragPosition;	// xpos where drag was started
	BOOL		m_fPropPageActive;		// TRUE if our property page is active
	DWORD		m_dwDropEffect;			// temp storage of whether drag/drop completed or aborted
	bool		m_fInRightClickMenu;
	bool		m_fShowItemProps;
	bool		m_fInFunctionBarMenu;	// true if the user right-clicked in the function bar
	IDMUSProdPropPageManager*	m_pPropPageMgr;
};


#endif //__LYRICMGR_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Shared\ChordInversionPropPage.cpp ===
// ChordInversionPropPage.cpp : implementation file
//

#include "stdafx.h"
#include "..\includes\DMUSProd.h"
#include "..\includes\Conductor.h"
#include "PropChord.h"
#include "PropPageMgr.h"
#include "chordmapstripmgr.h"
#include "ChordInversionPropPage.h"


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CChordInversionPropPage property page

IMPLEMENT_DYNCREATE(CChordInversionPropPage, CPropertyPage)

CChordInversionPropPage::CChordInversionPropPage() : CPropertyPage(CChordInversionPropPage::IDD)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	//{{AFX_DATA_INIT(CChordInversionPropPage)
	//}}AFX_DATA_INIT
	m_pPropPageMgr = NULL;
	m_pIConductor = 0;
	m_cRef = 0;
	AddRef();
	m_bValidChord = false;
	m_fNeedToDetach = FALSE;
}

CChordInversionPropPage::~CChordInversionPropPage()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	if(m_pIConductor)
	{
		m_pIConductor->Release();
	}
}

void CChordInversionPropPage::DoDataExchange(CDataExchange* pDX)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CChordInversionPropPage)
	DDX_Control(pDX, IDC_KEYS_INVERSIONS4, m_keysinv4);
	DDX_Control(pDX, IDC_KEYS_INVERSIONS3, m_keysinv3);
	DDX_Control(pDX, IDC_KEYS_INVERSIONS2, m_keysinv2);
	DDX_Control(pDX, IDC_KEYS_INVERSIONS1, m_keysinv1);
	DDX_Control(pDX, IDC_KEYS_BASECHORD4, m_keysbase4);
	DDX_Control(pDX, IDC_KEYS_BASECHORD3, m_keysbase3);
	DDX_Control(pDX, IDC_KEYS_BASECHORD2, m_keysbase2);
	DDX_Control(pDX, IDC_KEYS_BASECHORD1, m_keysbase1);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CChordInversionPropPage, CPropertyPage)
	//{{AFX_MSG_MAP(CChordInversionPropPage)
	ON_WM_CREATE()
	ON_WM_DESTROY()
	ON_WM_DRAWITEM()
	ON_WM_MEASUREITEM()
	ON_BN_CLICKED(IDC_BUTTON_INVERT1, OnButtonInvert1)
	ON_BN_CLICKED(IDC_BUTTON_INVERT2, OnButtonInvert2)
	ON_BN_CLICKED(IDC_BUTTON_INVERT3, OnButtonInvert3)
	ON_BN_CLICKED(IDC_BUTTON_INVERT4, OnButtonInvert4)
	ON_BN_CLICKED(IDC_BUTTON_IPLAY1, OnButtonIplay1)
	ON_BN_CLICKED(IDC_BUTTON_IPLAY2, OnButtonIplay2)
	ON_BN_CLICKED(IDC_BUTTON_IPLAY3, OnButtonIplay3)
	ON_BN_CLICKED(IDC_BUTTON_IPLAY4, OnButtonIplay4)
	ON_BN_CLICKED(IDC_CHECK_LEGAL1, OnCheckLegal1)
	ON_BN_CLICKED(IDC_CHECK_LEGAL2, OnCheckLegal2)
	ON_BN_CLICKED(IDC_CHECK_LEGAL3, OnCheckLegal3)
	ON_BN_CLICKED(IDC_CHECK_LEGAL4, OnCheckLegal4)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CChordInversionPropPage message handlers



////////////////////////////////////////////////////////////////////////////
// CChordInversionPropPage other funcs


/////////////////////////////////////////////////////////////////////////////
// PropPageChord IUnknown
STDMETHODIMP CChordInversionPropPage::QueryInterface( REFIID riid, LPVOID *ppv )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));


	ASSERT( ppv );
    *ppv = NULL;
    if (IsEqualIID(riid, IID_IUnknown))
	{
        *ppv = (IUnknown *) this;
	}
	else if (IsEqualIID(riid, IID_IDMUSProdMidiInCPt))
	{
        *ppv = (IUnknown *) (IDMUSProdMidiInCPt *) this;
	}
	else
	{
		return E_NOTIMPL;
	}
    ((IUnknown *) *ppv)->AddRef();
	return S_OK;
}

STDMETHODIMP_(ULONG) CChordInversionPropPage::AddRef(void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));


	return ++m_cRef;
}

STDMETHODIMP_(ULONG) CChordInversionPropPage::Release(void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));


	if( 0L == --m_cRef )
	{
		delete this;
		return 0;
	}
	else
	{
		return m_cRef;
	}
}


/////////////////////////////////////////////////////
//// Data transfer
void  CChordInversionPropPage::CopyDataToTab( CPropChord*  pTabData )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	if(pTabData && m_bValidChord)
	{
		*pTabData = m_Chord;
	}
	else
	{
		pTabData = 0;
	}
}

void CChordInversionPropPage::GetDataFromTab( const CPropChord* pTabData )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	if(pTabData)
	{
		m_Chord = *pTabData;
		for(int i = 0; i < m_Chord.MAX_POLY; i++)
		{
			m_invertVector[i].SetChord(m_Chord.SubChord(i)->ChordPattern());
			m_invertVector[i].SetInversion(m_Chord.SubChord(i)->InvertPattern());
		}
		m_bValidChord = true;
	}
	else
	{
		m_bValidChord = false;
	}
}

int CChordInversionPropPage::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Attach the window to the property page structure.
	// This has been done once already in the main application
	// since the main application owns the property sheet.
	// It needs to be done here so that the window handle can
	// be found in the DLLs handle map.
	if( !FromHandlePermanent( m_hWnd ) )
	{
		HWND hWnd = m_hWnd;
		m_hWnd = NULL;
		Attach( hWnd );
		m_fNeedToDetach = TRUE;
	}

	if( CPropertyPage::OnCreate(lpCreateStruct) == -1 )
	{
		return -1;
	}

	return 0;
}

void CChordInversionPropPage::OnDestroy() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));


	// Detach the window from the property page structure.
	// This will be done again by the main application since
	// it owns the property sheet.  It needs o be done here
	// so that the window handle can be removed from the
	// DLLs handle map.

	if( m_fNeedToDetach && m_hWnd )
	{
		HWND hWnd = m_hWnd;
		Detach();
		m_hWnd = hWnd;
	}
	CPropertyPage::OnDestroy();	
}

// required to get owner draw controls to paint 
void CChordInversionPropPage::OnDrawItem(int nIDCtl, LPDRAWITEMSTRUCT lpDrawItemStruct) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	
	CPropertyPage::OnDrawItem(nIDCtl, lpDrawItemStruct);
}

void CChordInversionPropPage::OnMeasureItem(int nIDCtl, LPMEASUREITEMSTRUCT lpMeasureItemStruct) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	
	CPropertyPage::OnMeasureItem(nIDCtl, lpMeasureItemStruct);
}

BOOL CChordInversionPropPage::OnInitDialog() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	
	
	m_nextinvert4.AutoLoad(IDC_BUTTON_INVERT4, this);
	m_nextinvert3.AutoLoad(IDC_BUTTON_INVERT3, this);
	m_nextinvert2.AutoLoad(IDC_BUTTON_INVERT2, this);
	m_nextinvert1.AutoLoad(IDC_BUTTON_INVERT1, this);

	m_play4.AutoLoad(IDC_BUTTON_IPLAY4, this);
	m_play3.AutoLoad(IDC_BUTTON_IPLAY3, this);
	m_play2.AutoLoad(IDC_BUTTON_IPLAY2, this);
	m_play1.AutoLoad(IDC_BUTTON_IPLAY1, this);

	CPropertyPage::OnInitDialog();
	
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CChordInversionPropPage::OnButtonInvert1() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	m_invertStates[0].Rotate(m_Chord.SubChord(0)->NoteCount());
	SetChord(&m_Chord, 0);
}

void CChordInversionPropPage::OnButtonInvert2() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	m_invertStates[1].Rotate(m_Chord.SubChord(1)->NoteCount());
	SetChord(&m_Chord, 1);
}

void CChordInversionPropPage::OnButtonInvert3() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	m_invertStates[2].Rotate(m_Chord.SubChord(2)->NoteCount());
	SetChord(&m_Chord, 2);
}

void CChordInversionPropPage::OnButtonInvert4() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	m_invertStates[3].Rotate(m_Chord.SubChord(3)->NoteCount());
	SetChord(&m_Chord, 3);
}

void CChordInversionPropPage::OnButtonIplay1() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	PlayChordInversion(0);
}

void CChordInversionPropPage::OnButtonIplay2() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	PlayChordInversion(1);	
}

void CChordInversionPropPage::OnButtonIplay3() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	PlayChordInversion(2);	
}

void CChordInversionPropPage::OnButtonIplay4() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	PlayChordInversion(3);	
}

void CChordInversionPropPage::OnCheckLegal1() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	CButton* pButton = (CButton*)GetDlgItem(IDC_CHECK_LEGAL1);
	bool state = pButton->GetCheck() == 1 ? true : false;
	int inversion = m_invertStates[0].Get()-1;
	if(inversion < 0)
	{
		pButton->SetCheck(1);
	}
	else
	{
		m_invertVector[0].SetAllowedInversion(inversion, state);
		m_Chord.SubChord(0)->InvertPattern() = m_invertVector[0].GetInvertPattern();
		if (m_pPropPageMgr && m_pPropPageMgr->m_pIPropPageObject)
		{
			m_pPropPageMgr->m_pIPropPageObject->SetData((void *) &m_Chord);
		}
	}	
}

void CChordInversionPropPage::OnCheckLegal2() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	CButton* pButton = (CButton*)GetDlgItem(IDC_CHECK_LEGAL2);
	bool state = pButton->GetCheck() == 1 ? true : false;
	int inversion = m_invertStates[1].Get()-1;
	if(inversion < 0)
	{
		pButton->SetCheck(1);
	}
	else
	{
		m_invertVector[1].SetAllowedInversion(inversion, state);
		m_Chord.SubChord(1)->InvertPattern() = m_invertVector[1].GetInvertPattern();
		if (m_pPropPageMgr && m_pPropPageMgr->m_pIPropPageObject)
		{
			m_pPropPageMgr->m_pIPropPageObject->SetData((void *) &m_Chord);
		}
	}	
}

void CChordInversionPropPage::OnCheckLegal3() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	CButton* pButton = (CButton*)GetDlgItem(IDC_CHECK_LEGAL3);
	bool state = pButton->GetCheck() == 1 ? true : false;
	int inversion = m_invertStates[2].Get()-1;
	if(inversion < 0)
	{
		pButton->SetCheck(1);
	}
	else
	{
		m_invertVector[2].SetAllowedInversion(inversion, state);
		m_Chord.SubChord(2)->InvertPattern() = m_invertVector[2].GetInvertPattern();
		if (m_pPropPageMgr && m_pPropPageMgr->m_pIPropPageObject)
		{
			m_pPropPageMgr->m_pIPropPageObject->SetData((void *) &m_Chord);
		}
	}	
	
}

void CChordInversionPropPage::OnCheckLegal4() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	CButton* pButton = (CButton*)GetDlgItem(IDC_CHECK_LEGAL4);
	bool state = pButton->GetCheck() == 1 ? true : false;
	int inversion = m_invertStates[3].Get()-1;
	if(inversion < 0)
	{
		pButton->SetCheck(1);
	}
	else
	{
		m_invertVector[3].SetAllowedInversion(inversion, state);
		m_Chord.SubChord(3)->InvertPattern() = m_invertVector[3].GetInvertPattern();
		if (m_pPropPageMgr && m_pPropPageMgr->m_pIPropPageObject)
		{
			m_pPropPageMgr->m_pIPropPageObject->SetData((void *) &m_Chord);
		}
	}	
	
}

void CChordInversionPropPage::SetChord(CPropChord * pChord, int subchord)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	char str[30];
	m_Chord = *pChord;
	
	if( IsWindow( m_hWnd ) == 0 ) return;

	if (pChord->GetUndetermined(pChord->RootIndex()) & UD_NAME)
	{
		SetDlgItemText(IDC_EDIT_NAME,"");
	}
	else
	{
		SetDlgItemText(IDC_EDIT_INAME,pChord->Name());
	}
	pChord->RootToString(str, pChord->RootIndex());
	SetDlgItemText(IDC_EDIT_IROOT,str);
//	SetCheckBox(pChord, UD_FLAT, IDC_CHECKBOX_FLATS, pChord->Base()->UseFlat() && 1);
	short nGrayed;
	if (pChord->GetUndetermined(pChord->RootIndex()) & UD_CHORDPATTERN) nGrayed = 4;
	else nGrayed = 0;
	int nX;
	int k0 = subchord == -1 ? 0 : subchord;
	int k1 = subchord == -1 ? CPropChord::MAX_POLY : subchord + 1;
	bool globalset = (subchord == -1);
	
	for(int n = k0; n < k1; n++)
	{
		// determine chord inversions
		int bass,third,fifth, seventh;
		BitFlag bfChord(pChord->SubChord(n)->ChordPattern());
		pChord->SubChord(n)->ChordNotes(bass, third, fifth, seventh);
		int inversion = m_invertStates[n].Get();
		if(inversion >= InversionState::First && third > -1)
		{
			bfChord.ClearBit(bass);
			bfChord.SetBit(bass+12);
		}
		if(inversion >= InversionState::Second && fifth > -1)
		{
			bfChord.ClearBit(third);
			bfChord.SetBit(third+12);
		}
		if(inversion >= InversionState::Third &&  seventh > -1)
		{
			bfChord.ClearBit(fifth);
			bfChord.SetBit(fifth+12);
		}
		DWORD dwChord = bfChord;
		// make sure pattern is tranposed
		dwChord = Rotate24(dwChord, pChord->SubChord(n)->ChordRoot() % 12);

		GetChordKeyboard(n)->Transpose(pChord->SubChord(n)->ChordRoot(), true);
		int shift = (pChord->SubChord(n)->ChordRoot())%12;
		if(globalset)
		{
			// only do this when all keys chords change (ie you've switched to this prop page)
			GetInversionKeyboard(n)->SetLowerBound(shift);
		}
		for (nX = 0; nX < 24; nX++)
		{
			short nState = nGrayed;
			if ((pChord->SubChord(n)->ChordPattern() >> nX) & 1) nState += 2;
			GetChordKeyboard(n)->SetNoteState(nX,"",nState);
			DrawInversionNote(pChord, dwChord, n, nX);
		}
		// finally set check box according to legality of inversion
		m_invertVector[n].SetChord(m_Chord.SubChord(n)->ChordPattern());
		m_invertVector[n].SetInversion(m_Chord.SubChord(n)->InvertPattern());
		CButton* pButton=0;
		switch(n)
		{
		case 0:
			pButton = (CButton*)GetDlgItem(	IDC_CHECK_LEGAL1);
			break;
		case 1:
			pButton = (CButton*)GetDlgItem(	IDC_CHECK_LEGAL2);
			break;
		case 2:
			pButton = (CButton*)GetDlgItem(	IDC_CHECK_LEGAL3);
			break;
		case 3:
			pButton = (CButton*)GetDlgItem(	IDC_CHECK_LEGAL4);
			break;
		}
		if(pButton)
		{
			if(inversion == 0)
			{
				pButton->SetCheck(1);
			}
			else if(m_invertVector[n].GetAllowedInversion(inversion-1))
			{
				pButton->SetCheck(1);
			}
			else
			{
				pButton->SetCheck(0);
			}
		}
	}

}

CKeyboard* CChordInversionPropPage::GetChordKeyboard(int index)
{
		switch(index)
		{
		case 0:
			return &m_keysbase1;			
			break;
		case 1:
			return &m_keysbase2;
			break;
		case 2:
			return &m_keysbase3;
			break;
		case 3:
			return &m_keysbase4;
			break;
		default:
			return 0;
			break;
		}
}

int CChordInversionPropPage::GetChordKeyboardIndex(const CKeyboard * pKeyboard)
{
	int i = 0;
	for(i; i < CPropChord::MAX_POLY; i++)
	{
		if(GetChordKeyboard(i) == pKeyboard)
		{
			break;
		}
	}
	return i >= CPropChord::MAX_POLY ? -1 : i;

}

CKeyboard* CChordInversionPropPage::GetInversionKeyboard(int index)
{
		switch(index)
		{
		case 0:
			return &m_keysinv1;			
			break;
		case 1:
			return &m_keysinv2;
			break;
		case 2:
			return &m_keysinv3;
			break;
		case 3:
			return &m_keysinv4;
			break;
		default:
			return 0;
			break;
		}

}

int CChordInversionPropPage::GetInversionKeyboardIndex(const CKeyboard * pKeyboard)
{
	int i = 0;
	for(i; i < CPropChord::MAX_POLY; i++)
	{
		if(GetInversionKeyboard(i) == pKeyboard)
		{
			break;
		}
	}
	return i >= CPropChord::MAX_POLY ? -1 : i;

}


void CChordInversionPropPage::DrawInversionNote(CPropChord* pChord, DWORD dwChordInversion, int index, short nX)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	nX += GetInversionKeyboard(index)->LowerBound();
	short nX24 = nX%24;
	short nGrayed;
	if (pChord->GetUndetermined(index) & UD_SCALEPATTERN) nGrayed = 4;
	else nGrayed = 0;

	short nState = nGrayed;
	if ((dwChordInversion >> nX24) & 1) 
		nState += 2;
	GetInversionKeyboard(index)->SetNoteState(nX,"",nState);
}

BOOL CChordInversionPropPage::OnSetActive() 
{
	// TODO: Add your specialized code here and/or call the base class
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	CPropChord* pChord;
	// make sure chord in sync from any changes in chordscaleproppage.
	if( SUCCEEDED ( m_pPropPageMgr->m_pIPropPageObject->GetData( (void **)&pChord ) ) )
	{
		SetChord(pChord);
	}
	return CPropertyPage::OnSetActive();
}

#define MIDI_NOTEOFF    0x80
#define MIDI_NOTEON     0x90
#define MIDI_PTOUCH     0xA0
#define MIDI_CCHANGE    0xB0
#define MIDI_PCHANGE    0xC0
#define MIDI_MTOUCH     0xD0
#define MIDI_PBEND      0xE0

#define MIDI_BASEPITCH		36


void CChordInversionPropPage::PlayChordInversion(int index)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	IDMUSProdConductor *pConductor = NULL;
	IDMUSProdComponent* pIComponent = NULL;
	if (m_pPropPageMgr->m_pIFramework)
	{
		if( SUCCEEDED ( m_pPropPageMgr->m_pIFramework->FindComponent( CLSID_CConductor,  &pIComponent ) ))
		{
			pIComponent->QueryInterface( IID_IDMUSProdConductor, (void**)&pConductor );
			if (pConductor)
			{
				short nX;
				DWORD dwTime = 0;
				pConductor->PlayMIDIEvent( MIDI_PCHANGE, 0, 0, 0 );
				pConductor->PlayMIDIEvent( MIDI_PCHANGE+1, 10, 0, 0 );

				// determine chord inversions
				int bass,third,fifth, seventh;
				BitFlag bfChord(m_Chord.SubChord(index)->ChordPattern());
				m_Chord.SubChord(index)->ChordNotes(bass, third, fifth, seventh);
				int inversion = m_invertStates[index].Get();
				if(inversion >= InversionState::First && third > -1)
				{
					bfChord.ClearBit(bass);
					bfChord.SetBit(bass+12);
				}
				if(inversion >= InversionState::Second && fifth > -1)
				{
					bfChord.ClearBit(third);
					bfChord.SetBit(third+12);
				}
				if(inversion >= InversionState::Third &&  seventh > -1)
				{
					bfChord.ClearBit(fifth);
					bfChord.SetBit(fifth+12);
				}
				DWORD dwChord = bfChord;
				// make sure pattern is tranposed
				dwChord = Rotate24(dwChord, m_Chord.SubChord(index)->ChordRoot() % 12);

				for (nX = 0; nX < 24; nX++)
				{
					if ((dwChord >> nX) & 1)
					{
						 unsigned char note = static_cast<unsigned char>(MIDI_BASEPITCH + nX + m_Chord.SubChord(index)->ChordRoot());
						pConductor->PlayMIDIEvent( MIDI_NOTEON, 
							note, 120, dwTime );
						dwTime += CHORDNOTE_DUR;
						pConductor->PlayMIDIEvent( MIDI_NOTEOFF, 
							note, 120, dwTime );
					}
				}
				dwTime += CHORDNOTE_DELAY;
				pConductor->Release();
			}
			pIComponent->Release();
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Shared\BaseStrip.cpp ===
/************************************************************************
*                                                                       *
*   Copyright (c) 1998-1999 Microsoft Corp. All rights reserved.        *
*                                                                       *
************************************************************************/

// BaseStrip.cpp : Implementation of CBaseStrip
#include "stdafx.h"
#include "BaseMgr.h"
#include "selectedregion.h"
#include "resource.h"
#include "GroupBitsPPG.h"
#include "TrackFlagsPPG.h"
#include "SegmentIO.h"

// This sets up information for Visual C++'s memory leak tracing
#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define DEFAULT_STRIP_HEIGHT 20

CString GetName(DWORD dwGroupBits, CString strName)
{
	CString strText, strTmp;
	BOOL fFoundGroup = FALSE;
	BOOL fLastSet = FALSE;
	int nStartGroup = -1;

	for( int i = 0 ;  i < 32 ;  i++ )
	{
		if( dwGroupBits & (1 << i) )
		{
			if( !fLastSet )
			{
				fLastSet = TRUE;
				nStartGroup = i;
			}
		}
		else
		{
			if( fLastSet )
			{
				fLastSet = FALSE;
				if( nStartGroup == i - 1 )
				{
					if( fFoundGroup )
					{
						strTmp.Format(", %d", i);
					}
					else
					{
						strTmp.Format("%d", i);
						fFoundGroup = TRUE;
					}
				}
				else
				{
					if( fFoundGroup )
					{
						strTmp.Format(", %d-%d", nStartGroup + 1, i);
					}
					else
					{
						strTmp.Format("%d-%d", nStartGroup + 1, i);
						fFoundGroup = TRUE;
					}
				}
				strText += strTmp;
			}
		}
	}

	if( fLastSet )
	{
		fLastSet = FALSE;
		if( nStartGroup == i - 1 )
		{
			if( fFoundGroup )
			{
				strTmp.Format(", %d", i);
			}
			else
			{
				strTmp.Format("%d", i);
				fFoundGroup = TRUE;
			}
		}
		else
		{
			if( fFoundGroup )
			{
				strTmp.Format(", %d-%d", nStartGroup + 1, i);
			}
			else
			{
				strTmp.Format("%d-%d", nStartGroup + 1, i);
				fFoundGroup = TRUE;
			}
		}
		strText += strTmp;
	}

	return strText + CString(": ") + strName;
}


IDMUSProdNode*	CBaseStrip::m_pIDocRootOfDragDropSource = NULL;
BOOL			CBaseStrip::m_fDragDropIntoSameDocRoot = FALSE;

/////////////////////////////////////////////////////////////////////////////
// CBaseStrip constructor/destructor

CBaseStrip::CBaseStrip( CBaseMgr* pBaseMgr )
{
	ASSERT( pBaseMgr );
	if ( pBaseMgr == NULL )
	{
		return;
	}

	m_pBaseMgr = pBaseMgr;

	// initialize our reference count
	m_cRef = 0;
	AddRef();

	m_bGutterSelected = FALSE;
	m_lGutterBeginSelect = 0;
	m_lGutterEndSelect = 0;

	m_fSelecting = FALSE;
	m_nStripIsDragDropSource = 0;

	m_lXPos = 0;
	m_pSelectedRegions = NULL;

	m_pISourceDataObject = NULL;
	m_pITargetDataObject = NULL;
	m_dwStartDragButton = 0;
	m_dwOverDragButton = 0;
	m_dwOverDragEffect = 0;
	m_dwDragRMenuEffect = DROPEFFECT_NONE;
	m_lStartDragPosition = 0;
	m_fPropPageActive = FALSE;
	m_dwDropEffect = DROPEFFECT_NONE;
	m_fInRightClickMenu = false;
	m_pPropPageMgr = NULL;
	m_fInFunctionBarMenu = false;
}

CBaseStrip::~CBaseStrip()
{
	ASSERT( m_pBaseMgr );
	if ( m_pBaseMgr )
	{
		//m_pBaseMgr->Release();
		m_pBaseMgr = NULL;
	}
	if ( m_pISourceDataObject )
	{
		m_pISourceDataObject->Release();
		m_pISourceDataObject = NULL;
	}
	if ( m_pITargetDataObject )
	{
		m_pITargetDataObject->Release();
		m_pITargetDataObject = NULL;
	}
	if ( m_pPropPageMgr )
	{
		m_pPropPageMgr->Release();
		m_pPropPageMgr = NULL;
	}

	if(m_pSelectedRegions)
	{
		delete m_pSelectedRegions;
		m_pSelectedRegions = NULL;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CBaseStrip IUnknown implementation

/////////////////////////////////////////////////////////////////////////////
// CBaseStrip::QueryInterface

STDMETHODIMP CBaseStrip::QueryInterface( REFIID riid, LPVOID *ppv )
{
	// Not needed
	//AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	ASSERT( ppv );
	if ( ppv == NULL )
	{
		return E_INVALIDARG;
	}

    *ppv = NULL;

    if (IsEqualIID(riid, IID_IUnknown))
	{
        *ppv = (IUnknown *) (IDMUSProdStrip*) this;
	}
	else if (IsEqualIID(riid, IID_IDMUSProdStrip))
	{
        *ppv = (IUnknown *) (IDMUSProdStrip *) this;
	}
	else if (IsEqualIID(riid, IID_IDMUSProdStripFunctionBar))
	{
        *ppv = (IUnknown *) (IDMUSProdStripFunctionBar *) this;
	}
	else if (IsEqualIID(riid, IID_IDMUSProdPropPageObject))
	{
        *ppv = (IUnknown *) (IDMUSProdPropPageObject *) this;
	}
	else if( IsEqualIID( riid, IID_IDMUSProdTimelineEdit ))
	{
		*ppv = (IDMUSProdTimelineEdit*) this;
	}
	else if( IsEqualIID( riid, IID_IDropSource ))
	{
		*ppv = (IDropSource*) this;
	}
	else if( IsEqualIID( riid, IID_IDropTarget ))
	{
		*ppv = (IDropTarget*) this;
	}
	else
	{
		return E_NOTIMPL;
	}

    ((IUnknown *) *ppv)->AddRef();
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CBaseStrip::AddRef

STDMETHODIMP_(ULONG) CBaseStrip::AddRef(void)
{
	// Not needed
	//AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	return ++m_cRef;
}


/////////////////////////////////////////////////////////////////////////////
// CBaseStrip::Release

STDMETHODIMP_(ULONG) CBaseStrip::Release(void)
{
	// Not needed
	//AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	if( 0L == --m_cRef )
	{
		delete this;
		return 0;
	}
	else
	{
		return m_cRef;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CBaseStrip IDMUSProdStrip implementation

/////////////////////////////////////////////////////////////////////////////
// CBaseStrip::Draw

HRESULT	STDMETHODCALLTYPE CBaseStrip::Draw( HDC hDC, STRIPVIEW sv, LONG lXOffset )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	UNREFERENCED_PARAMETER(sv);

	// Validate our pointer to the Timeline
	if( m_pBaseMgr->m_pTimeline )
	{
		// Draw Measure and Beat lines in our strip
		m_pBaseMgr->m_pTimeline->DrawMusicLines( hDC, ML_DRAW_MEASURE_BEAT, m_pBaseMgr->m_dwGroupBits, 0, lXOffset );
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CBaseStrip::GetStripProperty

HRESULT STDMETHODCALLTYPE CBaseStrip::GetStripProperty( STRIPPROPERTY sp, VARIANT *pvar)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( NULL == pvar )
	{
		return E_POINTER;
	}

	switch( sp )
	{
	case SP_RESIZEABLE:
		// We are not resizable
		pvar->vt = VT_BOOL;
		V_BOOL(pvar) = FALSE;
		break;

	case SP_GUTTERSELECTABLE:
		// We support gutter selection
		pvar->vt = VT_BOOL;
		V_BOOL(pvar) = TRUE;
		break;

	case SP_MINMAXABLE:
		// We don't support Minimize/maximize
		pvar->vt = VT_BOOL;
		V_BOOL(pvar) = FALSE;
		break;

	case SP_DEFAULTHEIGHT:
	case SP_MAXHEIGHT:
	case SP_MINHEIGHT:
		// Our height is 20 pixels
		pvar->vt = VT_INT;
		V_INT(pvar) = DEFAULT_STRIP_HEIGHT;
		break;

	case SP_NAME:
		{
			BSTR bstr;
			CString strStripName;
			strStripName.LoadString( IDS_STRIP_NAME );

			pvar->vt = VT_BSTR; 
			try
			{
				bstr = GetName(m_pBaseMgr->m_dwGroupBits, strStripName).AllocSysString();
			}
			catch(CMemoryException*)
			{
				return E_OUTOFMEMORY;
			}
			V_BSTR(pvar) = bstr;
		}
		break;

	case SP_STRIPMGR:
		pvar->vt = VT_UNKNOWN;
		if( m_pBaseMgr )
		{
			m_pBaseMgr->QueryInterface( IID_IUnknown, (void **) &V_UNKNOWN(pvar) );
		}
		else
		{
			V_UNKNOWN(pvar) = NULL;
		}
		break;

	default:
		return E_FAIL;
	}
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CBaseStrip::SetStripProperty

HRESULT STDMETHODCALLTYPE CBaseStrip::SetStripProperty( STRIPPROPERTY sp, VARIANT var)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	bool fRefresh = false;

	switch( sp )
	{
	case SP_BEGINSELECT:
	case SP_ENDSELECT:
		// Verify that we're passed an integer
		if( var.vt != VT_I4)
		{
			return E_FAIL;
		}

		// Update the appropriate member variables with the new information
		if( sp == SP_BEGINSELECT )
		{
			m_lGutterBeginSelect = V_I4( &var );
		}
		else
		{
			m_lGutterEndSelect = V_I4( &var );
		}

		// This flag will be true iff we're trying to clear the selections in all other strips
		if( m_fSelecting )
		{
			break;
		}

		// Initialize anchor for future shift-select operations
		m_pSelectedRegions->SetShiftSelectAnchor( 0 );

		// If the start time and the end time are identical, unselect everything
		if( m_lGutterBeginSelect == m_lGutterEndSelect )
		{	
			// Clear all selections
			if( m_pSelectedRegions )
			{
				fRefresh = m_pSelectedRegions->Clear();
			}

			// Deselect all items
			if( SelectItemsInSelectedRegions() || fRefresh )
			{
				// If any items become unselected, redraw the strip
				m_pBaseMgr->m_pTimeline->StripInvalidateRect( (IDMUSProdStrip*)this, NULL, TRUE );
			}
			break;
		}

		// If our gutter is selected
		if( m_bGutterSelected )
		{
			// Clear all current selections
			if( m_pSelectedRegions )
			{
				m_pSelectedRegions->Clear();
			}

			// Always need to refresh the display
			fRefresh = true;

			// Select all items between the new time range, and deselect all items
			// outside the new time range
			SelectSegment( m_lGutterBeginSelect, m_lGutterEndSelect );
		}
		else
		{
			// Our gutter is not selected
			// Clear all current selections
			if( m_pSelectedRegions )
			{
				fRefresh = m_pSelectedRegions->Clear();
			}

			// If any items become unselected, set fRefresh to true
			fRefresh |= SelectItemsInSelectedRegions();
		}

		// If the selection state of any item was changed
		if( fRefresh )
		{
			// Redraw the strip
			m_pBaseMgr->m_pTimeline->StripInvalidateRect( (IDMUSProdStrip*)this, NULL, TRUE );

			// Update the item property page
			if( m_pBaseMgr->m_pPropPageMgr != NULL )
			{
				m_pBaseMgr->m_pPropPageMgr->RefreshData();
			}
		}
		break;

	case SP_GUTTERSELECT:
		// Check if the gutter selection state changed
		if( m_bGutterSelected != V_BOOL(&var) )
		{
			// Save the new state of the gutter selection
			m_bGutterSelected = V_BOOL(&var);

			// If the time range is empty
			if( m_lGutterBeginSelect == m_lGutterEndSelect )
			{	
				// Clear all current selections
				if( m_pSelectedRegions )
				{
					m_pSelectedRegions->Clear();
				}

				// If any items become unselected, redraw the strip
				if( SelectItemsInSelectedRegions() )
				{
					m_pBaseMgr->m_pTimeline->StripInvalidateRect( (IDMUSProdStrip*)this, NULL, TRUE );
				}
				break;
			}

			// Check if the gutter became selected
			if( m_bGutterSelected )
			{
				// Clear the list of selected regions
				if( m_pSelectedRegions )
				{
					m_pSelectedRegions->Clear();
				}

				// Select the segment of the timeline
				// This will return true if the selection state of any item changed
				fRefresh = SelectSegment( m_lGutterBeginSelect, m_lGutterEndSelect );
			}
			else
			{
				// Clear the list of selected regions
				if( m_pSelectedRegions )
				{
					m_pSelectedRegions->Clear();
				}

				// Clear the selection state of all items
				// This will return true if the selection state of any item changed
				fRefresh = SelectItemsInSelectedRegions();
			}

			// Since the gutter state changed, we need to redraw the strip
			m_pBaseMgr->m_pTimeline->StripInvalidateRect( (IDMUSProdStrip*)this, NULL, TRUE );

			// However, only update the property page if the selection state of any items
			// changed
			if( fRefresh )
			{
				// Update the property page
				if( m_pBaseMgr->m_pPropPageMgr != NULL )
				{
					m_pBaseMgr->m_pPropPageMgr->RefreshData();
				}
			}
		}
		break;

	default:
		return E_FAIL;
	}
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CBaseStrip::OnWMMessage

HRESULT STDMETHODCALLTYPE CBaseStrip::OnWMMessage( UINT nMsg, WPARAM wParam, LPARAM lParam, LONG lXPos, LONG lYPos )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	UNREFERENCED_PARAMETER(lYPos);
	UNREFERENCED_PARAMETER(lParam);

	// Process the window message
	HRESULT hr = S_OK;
	if( m_pBaseMgr->m_pTimeline == NULL )
	{
		return E_FAIL;
	}
	switch( nMsg )
	{
	case WM_RBUTTONUP:
		// Display a right-click context menu.

		// Get the cursor position (To put the menu there)
		POINT pt;
		if( !GetCursorPos( &pt ) )
		{
			ASSERT(FALSE);
			hr = E_UNEXPECTED;
			break;
		}

		// Save the position of the click so we know where to insert a Lyric. if Insert is selected.
		m_lXPos = lXPos;

		// Display the menu
		PostRightClickMenu( pt );
		hr = S_OK;
		break;

	case WM_COMMAND:
		// We should only get this message in response to a selection in the right-click context menu.
		WORD wNotifyCode;
		WORD wID;

		wNotifyCode	= HIWORD( wParam );	// notification code 
		wID			= LOWORD( wParam );	// item, control, or accelerator identifier 
		switch( wID )
		{
		case ID_VIEW_PROPERTIES:
			hr = ShowPropertySheet();
			if (m_fShowItemProps)
			{
				// Change to the lyric property page
				m_pBaseMgr->OnShowProperties();

				// Update the property page, if it exists
				if( m_pBaseMgr->m_pPropPageMgr )
				{
					m_pBaseMgr->m_pPropPageMgr->RefreshData();
				}
			}
			else
			{
				// Change to our property page
				OnShowProperties();

				// Update the property page, if it exists
				if( m_pPropPageMgr )
				{
					m_pPropPageMgr->RefreshData();
				}
			}
			break;
		case ID_EDIT_CUT:
			hr = Cut();
			break;
		case ID_EDIT_COPY:
			hr = Copy();
			break;
		case ID_EDIT_DELETE:
			hr = Delete();
			break;
		case ID_EDIT_PASTE_OVERWRITE:
		case ID_EDIT_PASTE:
			// TODO: Paste->Merge vs. Paste->Overwrite distinction?
			hr = Paste();
			break;
		case ID_EDIT_INSERT:
			hr = Insert();
			break;
		case ID_EDIT_SELECT_ALL:
			hr = SelectAll();
			break;
		default:
			break;
		}
		break;

	case WM_CREATE:
		// Get Left and right selection boundaries
		m_bGutterSelected = FALSE;
		m_pBaseMgr->m_pTimeline->GetMarkerTime( MARKER_BEGINSELECT, TIMETYPE_CLOCKS, &m_lGutterBeginSelect );
		m_pBaseMgr->m_pTimeline->GetMarkerTime( MARKER_ENDSELECT, TIMETYPE_CLOCKS, &m_lGutterEndSelect );

		if(!m_pSelectedRegions)
		{
			m_pSelectedRegions = new CListSelectedRegion(m_pBaseMgr->m_pTimeline, m_pBaseMgr->m_dwGroupBits);
		}
		else
		{
			m_pSelectedRegions->Timeline() = m_pBaseMgr->m_pTimeline;
			m_pSelectedRegions->GroupBits() = m_pBaseMgr->m_dwGroupBits;
		}
		break;

	default:
		break;
	}
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CBaseStrip IDMUSProdStripFunctionBar

/////////////////////////////////////////////////////////////////////////////
// CBaseStrip::FBDraw

HRESULT CBaseStrip::FBDraw( HDC hDC, STRIPVIEW sv )
{
	// Not needed
	//AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	UNREFERENCED_PARAMETER(hDC);
	UNREFERENCED_PARAMETER(sv);
	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CBaseStrip::FBOnWMMessage

HRESULT CBaseStrip::FBOnWMMessage( UINT nMsg, WPARAM wParam, LPARAM lParam, LONG lXPos, LONG lYPos )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	UNREFERENCED_PARAMETER(lXPos);
	UNREFERENCED_PARAMETER(lYPos);
	UNREFERENCED_PARAMETER(lParam);
	UNREFERENCED_PARAMETER(wParam);

	// Process the window message
	HRESULT hr = S_OK;
	switch( nMsg )
	{
	case WM_LBUTTONDOWN:
		// Change the property page to the strip (group bits) property page
		m_fShowItemProps = FALSE;
		OnShowProperties();
		break;

	case WM_RBUTTONUP:
		// Change the property page to the strip (group bits) property page
		m_fShowItemProps = FALSE;
		OnShowProperties();

		// Set the cursor position for the insert operation to -1
		m_lXPos = -1;

		// Get the cursor position (To put the menu there)
		POINT pt;
		if( !GetCursorPos( &pt ) )
		{
			hr = E_UNEXPECTED;
			break;
		}

		// Display a right-click context menu.
		m_fInFunctionBarMenu = true;
		hr = PostRightClickMenu( pt );
		m_fInFunctionBarMenu = false;
		break;

	default:
		break;
	}
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CBaseStrip IDMUSProdTimelineEdit

/////////////////////////////////////////////////////////////////////////////
// CBaseStrip::Cut

HRESULT CBaseStrip::Cut( IDMUSProdTimelineDataObject* pITimelineDataObject )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Double-check that we can actually cut
	if( CanCut() != S_OK )
	{
		ASSERT( FALSE );
		return E_UNEXPECTED;
	}

	// Cut is simply a Copy followed by a Delete.
	HRESULT hr = Copy(pITimelineDataObject);

	// If the copy succeeded, do the delete
	if( SUCCEEDED( hr ))
	{
		hr = Delete();
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CBaseStrip::Copy

// Pure virtual
// HRESULT CBaseStrip::Copy( IDMUSProdTimelineDataObject* pITimelineDataObject ) = 0;


/////////////////////////////////////////////////////////////////////////////
// CBaseStrip::Paste

// Pure virtual
// HRESULT CBaseStrip::Paste( IDMUSProdTimelineDataObject* pITimelineDataObject ) = 0;


/////////////////////////////////////////////////////////////////////////////
// CBaseStrip::Insert

// Pure virtual
// HRESULT CBaseStrip::Insert( void ) = 0;


/////////////////////////////////////////////////////////////////////////////
// CBaseStrip::Delete

// Pure virtual
// HRESULT CBaseStrip::Delete( void ) = 0;


/////////////////////////////////////////////////////////////////////////////
// CBaseStrip::SelectAll

HRESULT CBaseStrip::SelectAll( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	ASSERT( m_pBaseMgr != NULL );
	if( m_pBaseMgr == NULL )
	{
		return E_UNEXPECTED;
	}

	ASSERT( m_pBaseMgr->m_pTimeline != NULL );
	if( m_pBaseMgr->m_pTimeline == NULL )
	{
		return E_UNEXPECTED;
	}

	// Select everything
	m_pSelectedRegions->SelectAll();

	// Update the selection state of the items
	if( SelectItemsInSelectedRegions() )
	{
		// If an an item became selected, redraw the strip
		m_pBaseMgr->m_pTimeline->StripInvalidateRect( (IDMUSProdStrip *)this, NULL, TRUE );

		// Update the item property page
		if( m_pBaseMgr->m_pPropPageMgr != NULL )
		{
			m_pBaseMgr->m_pPropPageMgr->RefreshData();
		}
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CBaseStrip::CanCut

HRESULT CBaseStrip::CanCut( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	ASSERT( m_pBaseMgr != NULL );
	if( m_pBaseMgr == NULL )
	{
		return E_UNEXPECTED;
	}

	// If our gutter is selected, and the user selected a range of time in the time strip,
	// we can cut even if nothing is selected.
	VARIANT variant;
	long lTimeStart, lTimeEnd;
	if( SUCCEEDED( m_pBaseMgr->m_pTimeline->StripGetTimelineProperty( this, STP_GUTTER_SELECTED, &variant ) )
	&&	(V_BOOL( &variant ) == TRUE)
	&&	SUCCEEDED( m_pBaseMgr->m_pTimeline->GetMarkerTime( MARKER_BEGINSELECT, TIMETYPE_CLOCKS, &lTimeStart ) )
	&&	(lTimeStart >= 0)
	&&	SUCCEEDED( m_pBaseMgr->m_pTimeline->GetMarkerTime( MARKER_ENDSELECT, TIMETYPE_CLOCKS, &lTimeEnd ) )
	&&	(lTimeEnd > lTimeStart) )
	{
		return S_OK;
	}

	// Otherwise, Cut is simply a Copy followed by a Delete
	if( CanCopy() == S_OK && CanDelete() == S_OK )
	{
		return S_OK;
	}
	else
	{
		return S_FALSE;
	}

}


/////////////////////////////////////////////////////////////////////////////
// CBaseStrip::CanCopy

HRESULT CBaseStrip::CanCopy( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	ASSERT( m_pBaseMgr != NULL );
	if( m_pBaseMgr == NULL )
	{
		return E_UNEXPECTED;
	}

	// If our gutter is selected, and the user selected a range of time in the time strip,
	// we can cut even if nothing is selected.
	VARIANT variant;
	long lTimeStart, lTimeEnd;
	if( SUCCEEDED( m_pBaseMgr->m_pTimeline->StripGetTimelineProperty( this, STP_GUTTER_SELECTED, &variant ) )
	&&	(V_BOOL( &variant ) == TRUE)
	&&	SUCCEEDED( m_pBaseMgr->m_pTimeline->GetMarkerTime( MARKER_BEGINSELECT, TIMETYPE_CLOCKS, &lTimeStart ) )
	&&	(lTimeStart >= 0)
	&&	SUCCEEDED( m_pBaseMgr->m_pTimeline->GetMarkerTime( MARKER_ENDSELECT, TIMETYPE_CLOCKS, &lTimeEnd ) )
	&&	(lTimeEnd > lTimeStart) )
	{
		return S_OK;
	}

	// Otherwise, check if anything is selected
	return IsSelected() ? S_OK : S_FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CBaseStrip::CanPaste

// Pure virtual
// HRESULT CBaseStrip::CanPaste( IDMUSProdTimelineDataObject *pITimelineDataObject ) = 0;


/////////////////////////////////////////////////////////////////////////////
// CBaseStrip::CanInsert

// Pure virtual
// HRESULT CBaseStrip::CanInsert( void ) = 0;


/////////////////////////////////////////////////////////////////////////////
// CBaseStrip::CanDelete

HRESULT CBaseStrip::CanDelete( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Check if anything is selected
	return IsSelected() ? S_OK : S_FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CBaseStrip::CanSelectAll

HRESULT CBaseStrip::CanSelectAll( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_fInRightClickMenu == FALSE )
	{
		// Always enable when gutter is selected
		if( m_bGutterSelected )
		{
			return S_OK;
		}
	}

	if( IsEmpty() )
	{
		return S_FALSE;
	}

	return S_OK;
}


// IDropSource Methods

/////////////////////////////////////////////////////////////////////////////
// CBaseStrip::QueryContinueDrag

HRESULT CBaseStrip::QueryContinueDrag( BOOL fEscapePressed, DWORD grfKeyState )
{
	// Not needed
	//AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
 
	if( fEscapePressed )
	{
        return DRAGDROP_S_CANCEL;
	}

	if( m_dwStartDragButton & MK_LBUTTON )
	{
		if( grfKeyState & MK_RBUTTON )
		{
			return DRAGDROP_S_CANCEL;
		}

		if( !(grfKeyState & MK_LBUTTON) )
		{
			return DRAGDROP_S_DROP;
		}
	}

	if( m_dwStartDragButton & MK_RBUTTON )
	{
		if( grfKeyState & MK_LBUTTON )
		{
			return DRAGDROP_S_CANCEL;
		}
		
		if( !(grfKeyState & MK_RBUTTON) )
		{
			return DRAGDROP_S_DROP;
		}
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CBaseStrip::GiveFeedback

HRESULT CBaseStrip::GiveFeedback( DWORD dwEffect )
{
	// Not needed
	//AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	UNREFERENCED_PARAMETER(dwEffect);

	return DRAGDROP_S_USEDEFAULTCURSORS;
}


// IDropTarget Methods

/////////////////////////////////////////////////////////////////////////////
// CBaseStrip::DragEnter

HRESULT CBaseStrip::DragEnter( IDataObject* pIDataObject, DWORD grfKeyState, POINTL pt, DWORD* pdwEffect )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( pIDataObject == NULL )
	{
		ASSERT(FALSE); // This shouldn't happen
		return E_POINTER;
	}

	if( m_pITargetDataObject )
	{
		ASSERT(FALSE); // This shouldn't happen

		m_pITargetDataObject->Release();
		// No need - it's overwritten just below
		// m_pITargetDataObject = NULL;
	}

	// Store IDataObject associated with current drag-drop operation
	m_pITargetDataObject = pIDataObject;
	m_pITargetDataObject->AddRef();

	// Determine effect of drop
	return DragOver( grfKeyState, pt, pdwEffect );
}


/////////////////////////////////////////////////////////////////////////////
// CBaseStrip::DragOver

HRESULT CBaseStrip::DragOver( DWORD grfKeyState, POINTL pt, DWORD* pdwEffect)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	UNREFERENCED_PARAMETER(pt);

	// Determine effect of drop
	DWORD dwEffect = DROPEFFECT_NONE;

	if(m_pITargetDataObject == NULL)
	{
		ASSERT( FALSE ); // Shouldn't happen - CanPasteFromData will return E_POINTER.
	}

	if( CanPasteFromData( m_pITargetDataObject ) == S_OK )
	{
		if( grfKeyState & MK_RBUTTON )
		{
			dwEffect = *pdwEffect;
		}
		else
		{
			if( grfKeyState & MK_CONTROL )
			{
				dwEffect = DROPEFFECT_COPY;
			}
			else
			{
				if( *pdwEffect & DROPEFFECT_COPY
				&&  *pdwEffect & DROPEFFECT_MOVE )
				{
					dwEffect = DROPEFFECT_MOVE;
				}
				else
				{
					dwEffect = *pdwEffect;
				}
			}
		}
	}

	// Set temp drag over fields
	if( grfKeyState & (MK_RBUTTON | MK_LBUTTON) )
	{
		m_dwOverDragButton = grfKeyState & (MK_RBUTTON | MK_LBUTTON);
		m_dwOverDragEffect = dwEffect;
	}

	*pdwEffect = dwEffect;
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CBaseStrip::DragLeave

HRESULT CBaseStrip::DragLeave( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Release IDataObject
	if( m_pITargetDataObject )
	{
		m_pITargetDataObject->Release();
		m_pITargetDataObject = NULL;
	}

	//Reset temp drag over fields
	m_dwOverDragButton = 0;
	m_dwOverDragEffect = 0;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CBaseStrip::Drop

// Pure virtual
//HRESULT CBaseStrip::Drop( IDataObject* pIDataObject, DWORD grfKeyState, POINTL pt, DWORD* pdwEffect) = 0;


// IDMUSProdPropPageObject Methods

/////////////////////////////////////////////////////////////////////////////
// CBaseStrip::GetData

HRESULT CBaseStrip::GetData( void **ppData )
{
	// Not needed
	//AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Validate parameter
	if( (ppData == NULL) || (*ppData == NULL) )
	{
		return E_INVALIDARG;
	}

	// Check which property page is requesting the data
	DWORD *pdwIndex = reinterpret_cast<DWORD *>(*ppData);
	switch( *pdwIndex )
	{
	case GROUPBITSPPG_INDEX:
	{
		// Copy our groupbits to the location pointed to by ppData
		PPGTrackParams *pPPGTrackParams = static_cast<PPGTrackParams *>(*ppData);
		pPPGTrackParams->dwGroupBits = m_pBaseMgr->m_dwGroupBits;
		break;
	}
	case TRACKFLAGSPPG_INDEX:
	{
		// Copy our track setting to the location pointed to by ppData
		PPGTrackFlagsParams *pPPGTrackFlagsParams = reinterpret_cast<PPGTrackFlagsParams *>(*ppData);
		pPPGTrackFlagsParams->dwTrackExtrasFlags = m_pBaseMgr->m_dwTrackExtrasFlags;
		pPPGTrackFlagsParams->dwTrackExtrasMask = g_dwTrackExtrasMask;
		pPPGTrackFlagsParams->dwProducerOnlyFlags = m_pBaseMgr->m_dwProducerOnlyFlags;
		pPPGTrackFlagsParams->dwProducerOnlyMask = g_dwProducerOnlyMask;
		break;
	}
	default:
		ASSERT(FALSE);
		return E_FAIL;
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CBaseStrip::SetData

HRESULT CBaseStrip::SetData( void *pData )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Validate parameter
	if( pData == NULL )
	{
		return E_POINTER;
	}

	// Check which property page is setting the data
	DWORD *pdwIndex = reinterpret_cast<DWORD *>(pData);
	switch( *pdwIndex )
	{
	case GROUPBITSPPG_INDEX:
	{
		PPGTrackParams *pPPGTrackParams = reinterpret_cast<PPGTrackParams *>(pData);

		// Update our group bits setting, if necessary
		if( pPPGTrackParams->dwGroupBits != m_pBaseMgr->m_dwGroupBits )
		{
			m_pBaseMgr->m_dwGroupBits = pPPGTrackParams->dwGroupBits;

			// Time signature may have changed
			m_pBaseMgr->OnUpdate( GUID_TimeSignature, m_pBaseMgr->m_dwGroupBits, NULL );

			// Notify our editor that we've changed
			m_pBaseMgr->m_nLastEdit = IDS_UNDO_TRACK_GROUP;
			m_pBaseMgr->OnDataChanged();

			// Update m_dwOldGroupBits after the call to OnDataChanged, because it is needed
			// to ensure the StripMgre removes itself correctly from the Timeline's notification
			// list.
			m_pBaseMgr->m_dwOldGroupBits = pPPGTrackParams->dwGroupBits;
		}
		break;
	}
	case TRACKFLAGSPPG_INDEX:
	{
		PPGTrackFlagsParams *pPPGTrackFlagsParams = reinterpret_cast<PPGTrackFlagsParams *>(pData);

		// Update our track extras flags, if necessary
		if( pPPGTrackFlagsParams->dwTrackExtrasFlags != m_pBaseMgr->m_dwTrackExtrasFlags )
		{
			m_pBaseMgr->m_dwTrackExtrasFlags = pPPGTrackFlagsParams->dwTrackExtrasFlags;

			// Notify our editor that we've changed
			m_pBaseMgr->m_nLastEdit = IDS_UNDO_TRACKEXTRAS;
			m_pBaseMgr->OnDataChanged();
		}
		// Update our Producer-specific flags, if necessary
		else if( pPPGTrackFlagsParams->dwProducerOnlyFlags != m_pBaseMgr->m_dwProducerOnlyFlags )
		{
			m_pBaseMgr->m_dwProducerOnlyFlags = pPPGTrackFlagsParams->dwProducerOnlyFlags;

			// Notify our editor that we've changed
			m_pBaseMgr->m_nLastEdit = IDS_UNDO_PRODUCERONLY;
			m_pBaseMgr->OnDataChanged();
		}
		break;
	}
	default:
		ASSERT(FALSE);
		return E_INVALIDARG;
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CBaseStrip::OnShowProperties

HRESULT CBaseStrip::OnShowProperties( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Validate our Timeline pointer
	if( m_pBaseMgr->m_pTimeline == NULL )
	{
		ASSERT(FALSE);
		return E_FAIL;
	}

	// Validate our Framework pointer
	if( m_pBaseMgr->m_pDMProdFramework == NULL )
	{
		ASSERT(FALSE);
		return E_FAIL;
	}

	// Get a pointer to the property sheet
	IDMUSProdPropSheet* pIPropSheet = NULL;
	m_pBaseMgr->m_pDMProdFramework->QueryInterface( IID_IDMUSProdPropSheet, (void **)&pIPropSheet);
	if( pIPropSheet == NULL )
	{
		ASSERT(FALSE);
		return E_FAIL;
	}

	//  If the property sheet is hidden, exit
	if( pIPropSheet->IsShowing() != S_OK )
	{
		pIPropSheet->Release();
		return S_OK;
	}

	// If our property page is already displayed, exit
	if(m_fPropPageActive)
	{
		ASSERT( m_pPropPageMgr != NULL );
		pIPropSheet->Release();
		return S_OK;
	}

	// Check if our property page manager exists yet
	if( m_pPropPageMgr == NULL )
	{
		// Nope, need to create it
		CGroupBitsPropPageMgr* pPPM = new CGroupBitsPropPageMgr;

		// Check if the creation succeeded.
		if( pPPM == NULL )
		{
			pIPropSheet->Release();
			return E_OUTOFMEMORY;
		}

		// Set m_pPropPageMgr with a reference to the IDMUSProdPropPageManager interface
		HRESULT hr = pPPM->QueryInterface( IID_IDMUSProdPropPageManager, (void**)&m_pPropPageMgr );

		// Release our original reference on the property page manager (added when it
		// was created).
		m_pPropPageMgr->Release();

		// If the QueryInterface failed, return.
		if( FAILED(hr) )
		{
			pIPropSheet->Release();
			// Nothing to release for pPPM, since no reference was added by the call to QueryInterface.
			return hr;
		}
	}

	// Store the current active tab
	short nActiveTab = CGroupBitsPropPageMgr::sm_nActiveTab;

	// Set the property page to refer to the group bits property page.
	m_pBaseMgr->m_pTimeline->SetPropertyPage(m_pPropPageMgr, (IDMUSProdPropPageObject*)this);

	// Flag that the group bits property page is active
	m_fPropPageActive = TRUE;

	// Reset the active tab
	pIPropSheet->SetActivePage( nActiveTab ); 

	// release our reference to the property sheet
	pIPropSheet->Release();

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CBaseStrip::OnRemoveFromPageManager

HRESULT CBaseStrip::OnRemoveFromPageManager( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Clear our property page manager
	if( m_pPropPageMgr )
	{
		m_pPropPageMgr->SetObject(NULL);
	}

	// Flag thar the group bits property page is not active
	m_fPropPageActive = FALSE;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CBaseStrip::ShowPropertySheet

HRESULT CBaseStrip::ShowPropertySheet( void )
{
	HRESULT hr = E_UNEXPECTED;

	// Get a pointer to the property sheet and show it
	IDMUSProdPropSheet*	pIPropSheet;
	if( m_pBaseMgr->m_pDMProdFramework )
	{
		hr = m_pBaseMgr->m_pDMProdFramework->QueryInterface( IID_IDMUSProdPropSheet, (void**)&pIPropSheet );
		ASSERT( SUCCEEDED( hr ));
		if( SUCCEEDED( hr ))
		{
			pIPropSheet->Show( TRUE );
			pIPropSheet->Release();
			hr = S_OK;
		}
	}
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CBaseStrip::PostRightClickMenu

HRESULT CBaseStrip::PostRightClickMenu( POINT pt )
{
	m_fInRightClickMenu = TRUE;
	HRESULT hr = m_pBaseMgr->m_pTimeline->TrackPopupMenu(NULL, pt.x, pt.y, (IDMUSProdStrip *)this, TRUE);
	m_fInRightClickMenu = FALSE;

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CBaseStrip::GetTimelineHWND

HWND CBaseStrip::GetTimelineHWND()
{
	HWND hwnd = NULL;
	IOleWindow *pOleWindow;
	if( m_pBaseMgr->m_pTimeline
	&&	SUCCEEDED( m_pBaseMgr->m_pTimeline->QueryInterface( IID_IOleWindow, (void**)&pOleWindow) ) )
	{
		pOleWindow->GetWindow( &hwnd );
		pOleWindow->Release();
	}

	return hwnd;
}


/////////////////////////////////////////////////////////////////////////////
// Helper methods

/////////////////////////////////////////////////////////////////////////////
// CopyDataToClipboard

HRESULT CopyDataToClipboard( IDMUSProdTimelineDataObject* pITimelineDataObject, IStream* pStreamCopy, UINT uiClipFormat, CBaseMgr *pBaseMgr, CBaseStrip *pBaseStrip )
{
	HRESULT hr;
	if(pITimelineDataObject != NULL)
	{
		// add the stream to the passed IDMUSProdTimelineDataObject
		hr = pITimelineDataObject->AddInternalClipFormat( uiClipFormat, pStreamCopy );
		if ( hr != S_OK )
		{
			ASSERT(FALSE);
			return E_FAIL;
		}
	}
	else
	{
		// There is no existing data object, so just create a new one
		hr = pBaseMgr->m_pTimeline->AllocTimelineDataObject(&pITimelineDataObject);
		ASSERT(hr == S_OK);
		if(hr != S_OK)
		{
			return E_FAIL;
		}

		// Set the start and edit time of this copy
		long lRegionStart, lRegionEnd;
		pBaseStrip->m_pSelectedRegions->GetSpan(lRegionStart, lRegionEnd);
		hr = pITimelineDataObject->SetBoundaries(lRegionStart, (lRegionEnd - 1));

		// add the stream to the DataObject
		hr = pITimelineDataObject->AddInternalClipFormat( uiClipFormat, pStreamCopy );
		ASSERT( hr == S_OK );
		if ( hr != S_OK )
		{
			pITimelineDataObject->Release();
			return E_FAIL;
		}

		// get the new IDataObject to place on the clipboard
		IDataObject* pIDataObject;
		hr = pITimelineDataObject->Export(&pIDataObject);

		// Release the ITimelineDataObject
		pITimelineDataObject->Release();

		// Exit if the Export failed
		if(FAILED(hr))
		{
			return E_UNEXPECTED;
		}

		// Send the IDataObject to the clipboard
		hr = OleSetClipboard( pIDataObject );
		if( hr != S_OK )
		{
			pIDataObject->Release();
			return E_FAIL;
		}

		// If we already have a pBaseMgr->m_pCopyDataObject, release it
		if(pBaseMgr->m_pCopyDataObject)
		{
			pBaseMgr->m_pCopyDataObject->Release();
		}

		// set pBaseMgr->m_pCopyDataObject to the object we just copied to the clipboard
		pBaseMgr->m_pCopyDataObject = pIDataObject;

		// Not needed = Object was AddRef()'d when it was exported from the IDMUSProdTimelineDataObject
		// pBaseMgr->m_pCopyDataObject->AddRef
	}

	return hr;
}

/////////////////////////////////////////////////////////////////////////////
// GetTimelineDataObject

HRESULT GetTimelineDataObject( IDMUSProdTimelineDataObject* &pITimelineDataObject, IDMUSProdTimeline* pTimeline, IDataObject *pIDataObject )
{
	if(pITimelineDataObject == NULL)
	{
		if( pIDataObject == NULL )
		{
			// Get the IDataObject from the clipboard
			HRESULT hr = OleGetClipboard(&pIDataObject);
			if(FAILED(hr) || (pIDataObject == NULL))
			{
				return E_FAIL;
			}
		}
		else
		{
			pIDataObject->AddRef();
		}

		// Create a new TimelineDataObject
		HRESULT hr = pTimeline->AllocTimelineDataObject( &pITimelineDataObject );
		if( FAILED(hr) || (pITimelineDataObject == NULL) )
		{
			pIDataObject->Release();
			return E_FAIL;
		}

		// Insert the IDataObject into the TimelineDataObject
		hr = pITimelineDataObject->Import( pIDataObject );
		pIDataObject->Release();
		if( FAILED(hr) )
		{
			pITimelineDataObject->Release();
			pITimelineDataObject = NULL;
			return E_FAIL;
		}
	}
	else
	{
		pITimelineDataObject->AddRef();
	}
	
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Shared\ChordInversionPropPage.h ===
#if !defined(AFX_CHORDINVERSIONPROPPAGE_H__E4A7E136_B485_11D1_9875_00805FA67D16__INCLUDED_)
#define AFX_CHORDINVERSIONPROPPAGE_H__E4A7E136_B485_11D1_9875_00805FA67D16__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "resource.h"
#include "conductor.h"
#include "..\shared\keyboard.h"
#include "..\shared\invertvector.h"

// ChordInversionPropPage.h : header file
//

class BitFlag
{
	unsigned long	dw;
public:
	BitFlag() { dw = 0; }
	BitFlag(unsigned long l) { dw = l; }
	BitFlag& operator = (unsigned long l)
	{
		dw = l;
		return *this;
	}
	unsigned long GetBit(int bit)
	{
		return dw & (1 << bit);
	}
	void SetBit(int bit)
	{
		dw |= (1 << bit);
	}
	void ClearBit(int bit)
	{
		dw &= ~(1<<bit);
	}
	operator unsigned long()
	{
		return dw;
	}
};

class InversionState
{
	int m_state;
public:
	enum { Root=0, First, Second, Third, NStates };
	InversionState()
	{
		m_state = Root;
	}
	void Reset()
	{
		m_state = Root;
	}
	int Get() const { return m_state; }
	void Set(int m)
	{
		ASSERT(Root <= m && m <= Third);
		if(Root <=m && m <= Third)
		{
			m_state = m;
		}
	}
	int Rotate(int highestInvert = -1)
	{
		//highestInvert == # notes in chord
		//highestInvert == -1 -> no inversion limit
		//highestInvert == 0 -> only a single note--nothing to invert
		if(highestInvert > NStates)
			highestInvert = NStates;	// 3 inversions is limit
		if(highestInvert != 0)
		{
			m_state = (m_state + 1) % ((highestInvert==-1) ? NStates : highestInvert );
		}
		return m_state;
	}
};


/////////////////////////////////////////////////////////////////////////////
// CChordInversionPropPage dialog
class CChordPropPageMgr;

class CChordInversionPropPage : public CPropertyPage
{
	friend class CChordPropPageMgr;
	DECLARE_DYNCREATE(CChordInversionPropPage)

// Construction
public:
	CChordInversionPropPage();
	~CChordInversionPropPage();
	enum { MAX_POLY = 4 , CHORDNOTE_DUR = 250, SCALENOTE_DUR = 250, CHORDNOTE_DELAY = 125, SCALENOTE_DELAY=125};

// Dialog Data
	//{{AFX_DATA(CChordInversionPropPage)
	enum { IDD = IDD_CHORDINVERSION_PROPPAGE };
	CKeyboard	m_keysinv4;
	CKeyboard	m_keysinv3;
	CKeyboard	m_keysinv2;
	CKeyboard	m_keysinv1;
	CKeyboard	m_keysbase4;
	CKeyboard	m_keysbase3;
	CKeyboard	m_keysbase2;
	CKeyboard	m_keysbase1;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CChordInversionPropPage)
	public:
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CChordInversionPropPage)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnDestroy();
	afx_msg void OnDrawItem(int nIDCtl, LPDRAWITEMSTRUCT lpDrawItemStruct);
	afx_msg void OnMeasureItem(int nIDCtl, LPMEASUREITEMSTRUCT lpMeasureItemStruct);
	virtual BOOL OnInitDialog();
	afx_msg void OnButtonInvert1();
	afx_msg void OnButtonInvert2();
	afx_msg void OnButtonInvert3();
	afx_msg void OnButtonInvert4();
	afx_msg void OnButtonIplay1();
	afx_msg void OnButtonIplay2();
	afx_msg void OnButtonIplay3();
	afx_msg void OnButtonIplay4();
	afx_msg void OnCheckLegal1();
	afx_msg void OnCheckLegal2();
	afx_msg void OnCheckLegal3();
	afx_msg void OnCheckLegal4();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

public:
	void PlayChordInversion(int index);
	int GetInversionKeyboardIndex(const CKeyboard* pKeyboard);
	CKeyboard* GetInversionKeyboard(int index);
	int GetChordKeyboardIndex(const CKeyboard* pKeyboard);
	CKeyboard* GetChordKeyboard(int index);
	void SetChord(CPropChord* pChord, int SubChord = -1 /* default = all subchords */);
	void DrawInversionNote(CPropChord* pChord, DWORD dwChordInversion, int index, short nX);
	// IUnknown functions
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

	// data transfer
	void CopyDataToTab( CPropChord*  TabData );
	void GetDataFromTab( const CPropChord* TabData );


private:
	CBitmapButton	m_nextinvert4;
	CBitmapButton	m_nextinvert3;
	CBitmapButton	m_nextinvert2;
	CBitmapButton	m_nextinvert1;
	
	CBitmapButton	m_play4;
	CBitmapButton	m_play3;
	CBitmapButton	m_play2;
	CBitmapButton	m_play1;

	InversionState	m_invertStates[CPropChord::MAX_POLY];
	InvertVector	m_invertVector[CPropChord::MAX_POLY];
	
	DWORD			m_cRef;
	CPropChord		m_Chord;
	CChordPropPageMgr*	m_pPropPageMgr;
	IDMUSProdConductor*	m_pIConductor;
	bool	m_bValidChord;
	BOOL	m_fNeedToDetach;};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_CHORDINVERSIONPROPPAGE_H__E4A7E136_B485_11D1_9875_00805FA67D16__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Shared\chordproppagemgr.h ===
// PropPageMgr.h : Handles the property pages

#ifndef __PROPPAGEMGR_H_
#define __PROPPAGEMGR_H_

#include "..\shared\PropPageChord.h"
#include "..\includes\staticproppagemanager.h"

class CChordPropPageMgr : CStaticPropPageManager
{
	friend class PropPageChord;
public:
	CChordPropPageMgr();
	~CChordPropPageMgr();
	HRESULT STDMETHODCALLTYPE QueryInterface( REFIID riid, LPVOID *ppv );
    // IDMUSProdPropPageManager functions
    HRESULT STDMETHODCALLTYPE GetPropertySheetTitle( BSTR* pbstrTitle, BOOL* pfAddPropertiesText );
    HRESULT STDMETHODCALLTYPE GetPropertySheetPages( IDMUSProdPropSheet* pIPropSheet, 
		LONG* hPropSheetPage[], short* pnNbrPages );
    HRESULT STDMETHODCALLTYPE RefreshData();
	PropPageChord*		m_pPropPageChord;
	IDMUSProdFramework*		m_pJazzFramework;
};

#endif // __PROPPAGEMGR_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Shared\ChordScalePropPage.cpp ===
// ChordScalePropPage.cpp : implementation file
//

#include "stdafx.h"
#include "..\includes\DMUSProd.h"
#include "..\includes\Conductor.h"
#include "DllBasePropPageManager.h"
#include "PropChord.h"
#include "PropPageMgr.h"
#include "chordmapstripmgr.h"
#include "ChordScalePropPage.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

///////////////////////// Callback for CKeyboard Events
//
void KeyboardChangeCallback(CKeyboard* pKeyboard, void* hint, short nKey)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	CChordScalePropPage* pdlg = (CChordScalePropPage*)hint;
	pdlg->DispatchKeyboardChange(pKeyboard, nKey);
}


/////////////////////////////////////////////////////////////////////////////
// CChordScalePropPage property page

IMPLEMENT_DYNCREATE(CChordScalePropPage, CPropertyPage)

CChordScalePropPage::CChordScalePropPage() : CPropertyPage(CChordScalePropPage::IDD)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	
	//{{AFX_DATA_INIT(CChordScalePropPage)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT

	m_pPropPageMgr = NULL;
	m_fMidiInputTarget = None;
	m_dwCookie = 0;
	m_pIConductor = 0;
	m_cRef = 0;
	m_cRegCount = 0;
	m_bValidChord = false;
	m_fNeedToDetach = FALSE;
	AddRef();

	m_MidiInIds[0] = IDC_BUTTON_MIDICHORD1;
	m_MidiInIds[1] = IDC_BUTTON_MIDICHORD2;
	m_MidiInIds[2] = IDC_BUTTON_MIDICHORD3;
	m_MidiInIds[3] = IDC_BUTTON_MIDICHORD4;

	m_MidiInIds[4] = IDC_BUTTON_MIDISCALE1;
	m_MidiInIds[5] = IDC_BUTTON_MIDISCALE2;
	m_MidiInIds[6] = IDC_BUTTON_MIDISCALE3;
	m_MidiInIds[7] = IDC_BUTTON_MIDISCALE4;

	m_MidiInIds[8] = IDC_BUTTON_MIDIROOT;

}

CChordScalePropPage::~CChordScalePropPage()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));


	UnRegisterMidi();	// make sure we're unregistered
	if(m_pIConductor)
	{
		m_pIConductor->Release();
	}
}

void CChordScalePropPage::DoDataExchange(CDataExchange* pDX)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CChordScalePropPage)
	DDX_Control(pDX, IDC_KEYS_SCALE4, m_keysscale4);
	DDX_Control(pDX, IDC_KEYS_SCALE3, m_keysscale3);
	DDX_Control(pDX, IDC_KEYS_SCALE2, m_keysscale2);
	DDX_Control(pDX, IDC_KEYS_SCALE1, m_keysscale1);
	DDX_Control(pDX, IDC_KEYS_CHORD4, m_keyschord4);
	DDX_Control(pDX, IDC_KEYS_CHORD3, m_keyschord3);
	DDX_Control(pDX, IDC_KEYS_CHORD2, m_keyschord2);
	DDX_Control(pDX, IDC_KEYS_CHORD1, m_keyschord1);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CChordScalePropPage, CPropertyPage)
	//{{AFX_MSG_MAP(CChordScalePropPage)
	ON_WM_CREATE()
	ON_WM_DESTROY()
	ON_BN_CLICKED(IDC_BUTTON_MIDICHORD4, OnButtonMidichord4)
	ON_WM_DRAWITEM()
	ON_WM_MEASUREITEM()
	ON_BN_CLICKED(IDC_BUTTON_MIDICHORD1, OnButtonMidichord1)
	ON_BN_CLICKED(IDC_BUTTON_MIDICHORD2, OnButtonMidichord2)
	ON_BN_CLICKED(IDC_BUTTON_MIDICHORD3, OnButtonMidichord3)
	ON_BN_CLICKED(IDC_BUTTON_MIDIROOT, OnButtonMidiroot)
	ON_BN_CLICKED(IDC_BUTTON_MIDISCALE1, OnButtonMidiscale1)
	ON_BN_CLICKED(IDC_BUTTON_MIDISCALE2, OnButtonMidiscale2)
	ON_BN_CLICKED(IDC_BUTTON_MIDISCALE3, OnButtonMidiscale3)
	ON_BN_CLICKED(IDC_BUTTON_MIDISCALE4, OnButtonMidiscale4)
	ON_BN_CLICKED(IDC_BUTTON_PLAY1, OnButtonPlay1)
	ON_BN_CLICKED(IDC_BUTTON_PLAY2, OnButtonPlay2)
	ON_BN_CLICKED(IDC_BUTTON_PLAY3, OnButtonPlay3)
	ON_BN_CLICKED(IDC_BUTTON_PLAY4, OnButtonPlay4)
	ON_BN_CLICKED(IDC_BUTTON_PLAYALL, OnButtonPlayall)
	ON_BN_CLICKED(IDC_BUTTON_SHIFTL1, OnButtonShiftl1)
	ON_BN_CLICKED(IDC_BUTTON_SHIFTL2, OnButtonShiftl2)
	ON_BN_CLICKED(IDC_BUTTON_SHIFTL3, OnButtonShiftl3)
	ON_BN_CLICKED(IDC_BUTTON_SHIFTL4, OnButtonShiftl4)
	ON_BN_CLICKED(IDC_BUTTON_SHIFTR1, OnButtonShiftr1)
	ON_BN_CLICKED(IDC_BUTTON_SHIFTR2, OnButtonShiftr2)
	ON_BN_CLICKED(IDC_BUTTON_SHIFTR3, OnButtonShiftr3)
	ON_BN_CLICKED(IDC_BUTTON_SHIFTR4, OnButtonShiftr4)
	ON_BN_CLICKED(IDC_CHECKBOX_FLATS, OnCheckboxFlats)
	ON_EN_CHANGE(IDC_EDIT_NAME, OnChangeEditName)
	ON_WM_KILLFOCUS()
	ON_BN_CLICKED(IDC_USEFLATS, OnUseflats)
	ON_BN_CLICKED(IDC_USESHARPS, OnUsesharps)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CChordScalePropPage message handlers


///////////////////////////////////////////////////////////////////////////
// CChordScalePropPage other funcs
const short KeyOCXTrans = 48;
const short KeyOCXLow = 0;
const short KeyOCXHigh = 23;
#define MIDI_NOTEOFF    0x80
#define MIDI_NOTEON     0x90
#define MIDI_PTOUCH     0xA0
#define MIDI_CCHANGE    0xB0
#define MIDI_PCHANGE    0xC0
#define MIDI_MTOUCH     0xD0
#define MIDI_PBEND      0xE0

#define MIDI_BASEPITCH		36

HRESULT CChordScalePropPage::OnMidiMsg(REFERENCE_TIME rtTime,
									   BYTE bStatus, 
									   BYTE bData1, 
									   BYTE bData2)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));


	// Note On
	if((int)(bStatus & 0xF0) == (int)0x90)
	{

		char Text[128];
		sprintf(Text, "Inside  PropPageChord::OnMidiMsg going to play %d note on\n", bData1); 
		TRACE0(Text);

		// set note
		short nKey = bData1 - KeyOCXTrans;

		if(m_fMidiInputTarget < 4)
		{
			bool rootHasChanged = m_fMidiInputTarget == 0 && (nKey <= m_Chord.Base()->ChordRoot());
			DispatchKeyboardChange(GetChordKeyboard(m_fMidiInputTarget), nKey);
			if(rootHasChanged)
			{
				GetChordKeyboard(m_fMidiInputTarget)->SetLowerBound(GetChordKeyboard(m_fMidiInputTarget)->Transpose());
			}
		}
		else if(m_fMidiInputTarget < 8)
		{
			DispatchKeyboardChange(GetScaleKeyboard(m_fMidiInputTarget - 4), nKey);
		}
		/*
		else
		{
			m_Chord.SubChord(m_Chord.RootIndex())->ChordRoot() = static_cast<unsigned char>(nKey);
			OnChangeRoot();
		}
		*/
	}

	// Note Off
	if((int)(bStatus & 0xF0) == (int)0x80)
	{
		char Text[128];
		sprintf(Text, "Inside  PropPageChord::OnMidiMsg going to play %d note off\n", bData1); 
		TRACE0(Text);
	}

	// set up patch
	m_pIConductor->PlayMIDIEvent( MIDI_PCHANGE, 0, 0, 0 );
	m_pIConductor->PlayMIDIEvent( MIDI_PCHANGE+1, 10, 0, 0 );

	m_pIConductor->PlayMIDIEvent((bStatus & 0xF0),
								 bData1,
								 bData2,
								 0);	
	
	return S_OK;
}

void CChordScalePropPage::RegisterMidi() 
{
	ASSERT(m_cRegCount <= 1);
	if(m_fMidiInputTarget != None && m_cRegCount == 0)
	{
		++m_cRegCount;
		REGISTER_MIDI_IN(m_pIConductor, m_dwCookie)	
	}
}

void CChordScalePropPage::UnRegisterMidi()
{
	ASSERT(m_cRegCount <= 1);
	if(m_cRegCount)
	{
		m_cRegCount--;
		UNREGISTER_MIDI_IN(m_pIConductor, m_dwCookie)
	}
}


/////////////////////////////////////////////////////////////////////////////
// PropPageChord IUnknown
STDMETHODIMP CChordScalePropPage::QueryInterface( REFIID riid, LPVOID *ppv )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));


	ASSERT( ppv );
    *ppv = NULL;
    if (IsEqualIID(riid, IID_IUnknown))
	{
        *ppv = (IUnknown *) this;
	}
	else if (IsEqualIID(riid, IID_IDMUSProdMidiInCPt))
	{
        *ppv = (IUnknown *) (IDMUSProdMidiInCPt *) this;
	}
	else
	{
		return E_NOTIMPL;
	}
    ((IUnknown *) *ppv)->AddRef();
	return S_OK;
}

STDMETHODIMP_(ULONG) CChordScalePropPage::AddRef(void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));


	return ++m_cRef;
}

STDMETHODIMP_(ULONG) CChordScalePropPage::Release(void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));


	if( 0L == --m_cRef )
	{
		delete this;
		return 0;
	}
	else
	{
		return m_cRef;
	}
}

/////////////////////////////////////////////////////
//// Data transfer
void  CChordScalePropPage::CopyDataToTab( CPropChord*  pTabData )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	if(pTabData && m_bValidChord)
	{
		*pTabData = m_Chord;
	}
	else
	{
		pTabData = 0;
	}
}

void CChordScalePropPage::GetDataFromTab( const CPropChord* pTabData )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	if(pTabData)
	{
		m_Chord = *pTabData;
		m_bValidChord = true;
	}
	else
	{
		m_bValidChord = false;
	}
}

BOOL CChordScalePropPage::OnInitDialog() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	
	for(int i = 0; i < MAX_POLY; i++)
	{
		GetChordKeyboard(i)->SetLButtonUpCallback(KeyboardChangeCallback, this);
		GetScaleKeyboard(i)->SetLButtonUpCallback(KeyboardChangeCallback, this);
	}
	
	m_midichord4.AutoLoad(IDC_BUTTON_MIDICHORD4, this);
	m_midichord3.AutoLoad(IDC_BUTTON_MIDICHORD3, this);
	m_midichord2.AutoLoad(IDC_BUTTON_MIDICHORD2, this);
	/*
	m_midichord1.Create( "MIDIPLUG", 
									 BS_OWNERDRAW | BS_AUTOCHECKBOX | WS_CHILD | WS_VISIBLE | WS_TABSTOP,
									 CRect(14,84,26,94), 
									 this, 
									 IDC_BUTTON_MIDICHORD1 );
									 */
	m_midichord1.AutoLoad(IDC_BUTTON_MIDICHORD1, this);
//	m_midichord1.LoadBitmaps( "MIDIPLUGU", "MIDIPLUGD");



	m_midiscale4.AutoLoad(IDC_BUTTON_MIDISCALE4, this);
	m_midiscale3.AutoLoad(IDC_BUTTON_MIDISCALE3, this);
	m_midiscale2.AutoLoad(IDC_BUTTON_MIDISCALE2, this);
	m_midiscale1.AutoLoad(IDC_BUTTON_MIDISCALE1, this);


//	m_midiroot.AutoLoad(IDC_BUTTON_MIDIROOT, this);


	m_shiftl4.AutoLoad(IDC_BUTTON_SHIFTL4, this);
	m_shiftl3.AutoLoad(IDC_BUTTON_SHIFTL3, this);
	m_shiftl2.AutoLoad(IDC_BUTTON_SHIFTL2, this);
	m_shiftl1.AutoLoad(IDC_BUTTON_SHIFTL1, this);

	m_shiftr4.AutoLoad(IDC_BUTTON_SHIFTR4, this);
	m_shiftr3.AutoLoad(IDC_BUTTON_SHIFTR3, this);
	m_shiftr2.AutoLoad(IDC_BUTTON_SHIFTR2, this);
	m_shiftr1.AutoLoad(IDC_BUTTON_SHIFTR1, this);

	m_play4.AutoLoad(IDC_BUTTON_PLAY4, this);
	m_play3.AutoLoad(IDC_BUTTON_PLAY3, this);
	m_play2.AutoLoad(IDC_BUTTON_PLAY2, this);
	m_play1.AutoLoad(IDC_BUTTON_PLAY1, this);

	m_playall.AutoLoad(IDC_BUTTON_PLAYALL, this);



	CPropertyPage::OnInitDialog();
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

int CChordScalePropPage::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));


	// Attach the window to the property page structure.
	// This has been done once already in the main application
	// since the main application owns the property sheet.
	// It needs to be done here so that the window handle can
	// be found in the DLLs handle map.
	if( !FromHandlePermanent( m_hWnd ) )
	{
		HWND hWnd = m_hWnd;
		m_hWnd = NULL;
		Attach( hWnd );
		m_fNeedToDetach = TRUE;
	}

	if( CPropertyPage::OnCreate(lpCreateStruct) == -1 )
	{
		return -1;
	}

	return 0;
}

void CChordScalePropPage::OnDestroy() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));


	// Detach the window from the property page structure.
	// This will be done again by the main application since
	// it owns the property sheet.  It needs o be done here
	// so that the window handle can be removed from the
	// DLLs handle map.

	if( m_fNeedToDetach && m_hWnd )
	{
		HWND hWnd = m_hWnd;
		Detach();
		m_hWnd = hWnd;
	}
	UnRegisterMidi();

	CPropertyPage::OnDestroy();	
}


void CChordScalePropPage::OnDrawItem(int nIDCtl, LPDRAWITEMSTRUCT lpDrawItemStruct) 
{
	// TODO: Add your message handler code here and/or call default
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
/*
	CButton* pButton = GetButton(nIDCtl);
	if(pButton)
	{
		lpDrawItemStruct->itemState = pButton->GetChecked() ? ODS_SELECTED : ODS_DEFAULT;
	}
*/		
	CPropertyPage::OnDrawItem(nIDCtl, lpDrawItemStruct);	
}

void CChordScalePropPage::OnMeasureItem(int nIDCtl, LPMEASUREITEMSTRUCT lpMeasureItemStruct) 
{
	// TODO: Add your message handler code here and/or call default
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	
	CPropertyPage::OnMeasureItem(nIDCtl, lpMeasureItemStruct);
}

void CChordScalePropPage::OnButtonMidichord1() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	SetMidiIn(Chord1);
}

void CChordScalePropPage::OnButtonMidichord2() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	SetMidiIn(Chord2);
}

void CChordScalePropPage::OnButtonMidichord3() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	SetMidiIn(Chord3);
}
void CChordScalePropPage::OnButtonMidichord4() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	SetMidiIn(Chord4);	
}

void CChordScalePropPage::OnButtonMidiroot() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	SetMidiIn(Root);
}

void CChordScalePropPage::OnButtonMidiscale1() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	SetMidiIn(Scale1);
}

void CChordScalePropPage::OnButtonMidiscale2() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	SetMidiIn(Scale2);
}

void CChordScalePropPage::OnButtonMidiscale3() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	SetMidiIn(Scale3);
}

void CChordScalePropPage::OnButtonMidiscale4() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	SetMidiIn(Scale4);
}

void CChordScalePropPage::OnButtonPlay1() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	PlaySubChord(0);
}

void CChordScalePropPage::OnButtonPlay2() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	PlaySubChord(1);	
}

void CChordScalePropPage::OnButtonPlay3() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	PlaySubChord(2);
}

void CChordScalePropPage::OnButtonPlay4() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	PlaySubChord(3);
}

void CChordScalePropPage::OnButtonPlayall() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	PlayAllChords();
}

void CChordScalePropPage::OnButtonShiftl1() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
//	m_keyschord1.Transpose(-1, true);
//	m_keysscale1.Transpose(-1, true);
	m_keyschord1.ShiftKeys(-1);
	m_keysscale1.ShiftKeys(-1);
}

void CChordScalePropPage::OnButtonShiftl2() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	m_keyschord2.ShiftKeys(-1);
	m_keysscale2.ShiftKeys(-1);
	
}

void CChordScalePropPage::OnButtonShiftl3() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	m_keyschord3.ShiftKeys(-1);
	m_keysscale3.ShiftKeys(-1);
	
}

void CChordScalePropPage::OnButtonShiftl4() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	m_keyschord4.ShiftKeys(-1);
	m_keysscale4.ShiftKeys(-1);
	
}

void CChordScalePropPage::OnButtonShiftr1() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	m_keyschord1.ShiftKeys(1);
//	m_keysscale1.ShiftKeys(1);
	
}

void CChordScalePropPage::OnButtonShiftr2() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	m_keyschord2.ShiftKeys(1);
//	m_keysscale2.ShiftKeys(1);
	
}

void CChordScalePropPage::OnButtonShiftr3() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	m_keyschord3.ShiftKeys(1);
//	m_keysscale3.ShiftKeys(1);
	
}

void CChordScalePropPage::OnButtonShiftr4() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	m_keyschord4.ShiftKeys(1);
//	m_keysscale4.ShiftKeys(1);
	
}

void CChordScalePropPage::OnCheckboxFlats() 
//
// this sets UseFlats for all chords, but looks at base chord to determine current state
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	UINT nChecked = IsDlgButtonChecked(IDC_CHECKBOX_FLATS);
	UINT nState;
	if (m_Chord.Undetermined(m_Chord.RootIndex())  & UD_FLAT)
	{
		nState = 2;
	}
	else if (m_Chord.Base()->UseFlat())
	{
		nState = 1;
	}
	else nState = 0;
	if (nState != nChecked)
	{
		if (nChecked == 2)
		{
			CButton *pButton = (CButton *) GetDlgItem(IDC_CHECKBOX_FLATS);
			if (pButton)
			{
				pButton->SetButtonStyle(BS_AUTOCHECKBOX);
				pButton->SetCheck(nState);			
			}
		}
		else
		{
			for(int i = 0; i < CPropChord::MAX_POLY; i++)
			{
				m_Chord.Undetermined(i)  &= ~UD_FLAT;
				if (nChecked == 1)
				{
					m_Chord.SubChord(i)->UseFlat() = TRUE;
				}
				else 
				{
					m_Chord.SubChord(i)->UseFlat() = FALSE;
				}
			}
			if (m_pPropPageMgr && m_pPropPageMgr->m_pIPropPageObject)
			{
				m_pPropPageMgr->m_pIPropPageObject->SetData((void *) &m_Chord);
			}	
		}
	}

}

void CChordScalePropPage::OnChangeEditName() 
{
	// TODO: If this is a RICHEDIT control, the control will not
	// send this notification unless you override the CPropertyPage::OnInitDialog()
	// function to send the EM_SETEVENTMASK message to the control
	// with the ENM_CHANGE flag ORed into the lParam mask.
	
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	char szName[30];
	GetDlgItemText(IDC_EDIT_NAME,szName,sizeof(m_Chord.Name()));
	if (strcmp("",szName) && (strcmp(m_Chord.Name(),szName)))
	{
		strncpy(m_Chord.Name(),szName, DMPolyChord::MAX_NAME);
		m_Chord.Undetermined(m_Chord.RootIndex())  &= ~UD_NAME;
		if (m_pPropPageMgr && m_pPropPageMgr->m_pIPropPageObject)
		{
			m_pPropPageMgr->m_pIPropPageObject->SetData((void *) &m_Chord);
		}	
	}

	
}

void CChordScalePropPage::DispatchKeyboardChange(CKeyboard* pKeyboard, short nKey)
{
	int i;
	if( (i = GetChordKeyboardIndex(pKeyboard))  >= 0 )
	{
		// send both CKeyboard* and index to save loakup
		OnNoteDownChordKeys(pKeyboard, i, nKey);
	}
	else if( (i = GetScaleKeyboardIndex(pKeyboard)) >= 0 )
	{
		// send both CKeyboard* and index to save loakup
		OnNoteDownScaleKeys(pKeyboard, i, nKey);
	}
}

int CChordScalePropPage::GetChordKeyboardIndex(const CKeyboard* pKeyboard)
{
	int i = 0;
	for(i; i < MAX_POLY; i++)
	{
		if(GetChordKeyboard(i) == pKeyboard)
		{
			break;
		}
	}
	return i >= MAX_POLY ? -1 : i;
}

int CChordScalePropPage::GetScaleKeyboardIndex(const CKeyboard* pKeyboard)
{
	int i = 0;
	for(i; i < MAX_POLY; i++)
	{
		if(GetScaleKeyboard(i) == pKeyboard)
		{
			break;
		}
	}
	return i >= MAX_POLY ? -1 : i;
}

void CChordScalePropPage::OnNoteDownChordKeys(CKeyboard* pKeyboard, int index, short nKey) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	ASSERT(0 <= index && index < MAX_POLY && pKeyboard);



	if (m_Chord.GetUndetermined(index) & UD_CHORDPATTERN)
	{
		m_Chord.Undetermined(index) &= ~UD_CHORDPATTERN;
		for (nKey = 0; nKey < 24; nKey++)
		{
			pKeyboard->SetNoteState(nKey,"",(1 && ((m_Chord.SubChord(index)->ChordPattern() >> nKey) & 1)) << 1);
		}
	}
	else
	{
		bool rootHasChanged = false;
		short root = static_cast<short>(m_Chord.SubChord(index)->ChordRoot());
		short note = nKey - pKeyboard->Transpose();
		if(nKey < root)
		{
			// new root
			rootHasChanged = true;
			m_Chord.SubChord(index)->ChordRoot() = static_cast<unsigned char>(nKey);
			// root is lower, but we want to keep same chord members so shift up
			m_Chord.SubChord(index)->ChordPattern() <<= (root - nKey);
			// add member for root note
			m_Chord.SubChord(index)->ChordPattern() |= 0x1;
			// transpose keyboard
			pKeyboard->Transpose(nKey, false);
			m_Chord.Undetermined(index) &= ~UD_CHORDPATTERN;
		}
		else if(nKey == root)
		{
			// root must be set so clear it
			pKeyboard->SetNoteState(nKey-pKeyboard->Transpose(),"",0);
			// new root
			rootHasChanged = true;
			// third of chord is now root
			root = static_cast<short>(m_Chord.SubChord(index)->Third(0));
			if(root < 0)
			{
				// no chord, set root to highest note
				root = 23;
				m_Chord.SubChord(index)->ChordRoot() = static_cast<unsigned char>(root);
				m_Chord.SubChord(index)->ChordPattern() = 0;
			}
			else
			{
				m_Chord.SubChord(index)->ChordRoot() = root + nKey;
				// shift chord to "root" position, this also gets rid of old root note
				m_Chord.SubChord(index)->ChordPattern() >>= root;
			}
			// transpose keyboard
			pKeyboard->Transpose(m_Chord.SubChord(index)->ChordRoot(), false);
			m_Chord.Undetermined(index) &= ~UD_CHORDPATTERN;
		}
		else
		{
			//  just update chord
			short note = nKey - pKeyboard->Transpose();
			m_Chord.SubChord(index)->ChordPattern() ^= (1 << note);
			m_Chord.Undetermined(index) &= ~UD_CHORDPATTERN;
			pKeyboard->SetNoteState(note,"",(1 && ((m_Chord.SubChord(index)->ChordPattern() >> note) & 1)) << 1);
		}
		if(rootHasChanged)
		{
			// need to redraw chord and scale keyboards
			for (int nX = 0; nX < 24; nX++)
			{
				short nGrayed;
				if (m_Chord.GetUndetermined(m_Chord.RootIndex()) & UD_CHORDPATTERN) 
					nGrayed = 4;
				else 
					nGrayed = 0;
				short nState = nGrayed;
				if ((m_Chord.SubChord(index)->ChordPattern() >> nX) & 1) nState += 2;
				pKeyboard->SetNoteState(nX,"",nState);
				DrawScaleNote(&m_Chord,  index, (nX + pKeyboard->Transpose()) % 24);
				DrawScaleNote(&m_Chord,  index, (nX, pKeyboard->Transpose() + 12) % 24);
			}
			if(index == m_Chord.RootIndex())
			{
				OnChangeRoot();
			}
		}
		else
		{
			DrawScaleNote(&m_Chord,  index, nKey);
			DrawScaleNote(&m_Chord,  index, (nKey + 12) % 24);
		}
	}


	if (m_pPropPageMgr && m_pPropPageMgr->m_pIPropPageObject)
	{
		m_pPropPageMgr->m_pIPropPageObject->SetData((void *) &m_Chord);
	}
}


void CChordScalePropPage::OnNoteDownScaleKeys(CKeyboard* pKeyboard, int index, short nKey) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	ASSERT(0 <= index && index < MAX_POLY && pKeyboard);

	short nOtherKey = (nKey + 12) % 24;
	if (m_Chord.Undetermined(index) & UD_SCALEPATTERN)
	{
		m_Chord.Undetermined(index) &= ~UD_SCALEPATTERN;
//		m_Chord.m_dwScalePattern ^= (1 << nKey);
		for (nKey = 0; nKey < 24; nKey++)
		{
			DrawScaleNote(&m_Chord, index, nKey);
		}
	}
	else
	{
		m_Chord.SubChord(index)->ScalePattern() ^= (1 << nKey);
		m_Chord.SubChord(index)->ScalePattern() ^= (1 << nOtherKey);
		DrawScaleNote(&m_Chord, index, nKey);
		DrawScaleNote(&m_Chord, index, nOtherKey);
	}
	if (m_pPropPageMgr && m_pPropPageMgr->m_pIPropPageObject)
	{
		m_pPropPageMgr->m_pIPropPageObject->SetData((void *) &m_Chord);
	}	
}

void CChordScalePropPage::DrawScaleNote(CPropChord* pChord, int index, short nX)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	short nGrayed;
	if (pChord->GetUndetermined(index) & UD_SCALEPATTERN) nGrayed = 4;
	else nGrayed = 0;
	DWORD dwChord = pChord->SubChord(index)->ChordPattern();
	dwChord = Rotate24(dwChord, pChord->SubChord(index)->ChordRoot() % 12);
	short nState = nGrayed;
	
	if ((pChord->SubChord(index)->ScalePattern() >> nX) & 1) 
	{
		nState = 2;
//		if ((dwChord >> nX) & 1) nState += 2;
	}
	else
	{
		// draw chord not in scale "blue" note
		if ((dwChord >> nX) & 1) nState = 1;
	}
	GetScaleKeyboard(index)->SetNoteState(nX,"",nState);
}

void CChordScalePropPage::SetChord(CPropChord * pChord)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	char str[30];
	m_Chord = *pChord;
	
	if( IsWindow( m_hWnd ) == 0 ) return;

	if (pChord->GetUndetermined(pChord->RootIndex()) & UD_NAME)
	{
		SetDlgItemText(IDC_EDIT_NAME,"");
	}
	else
	{
		SetDlgItemText(IDC_EDIT_NAME,pChord->Name());
	}
	pChord->RootToString(str, pChord->RootIndex());
	SetDlgItemText(IDC_EDIT_ROOT,str);
	SetCheckBox(pChord, UD_FLAT, IDC_USEFLATS, pChord->Base()->UseFlat() && 1);
	SetCheckBox(pChord, UD_FLAT, IDC_USESHARPS, !(pChord->Base()->UseFlat() && 1));
	short nGrayed;
	if (pChord->GetUndetermined(pChord->RootIndex()) & UD_CHORDPATTERN) nGrayed = 4;
	else nGrayed = 0;
	int nX;
	for(int n = 0; n < CPropChord::MAX_POLY; n++)
	{
		CKeyboard* pKeyboard = GetChordKeyboard(n);
		DMChord* pdm = pChord->SubChord(n);
		pKeyboard->Transpose(pdm->ChordRoot(), true);
		for (nX = 0; nX < 24; nX++)
		{
			short nState = nGrayed;
			if ((pChord->SubChord(n)->ChordPattern() >> nX) & 1) nState += 2;
			GetChordKeyboard(n)->SetNoteState(nX,"",nState);
			DrawScaleNote(pChord, n, nX);
		}
	}
}

void CChordScalePropPage::SetCheckBox(CPropChord * pChord, DWORD dwUDFlag, UINT nDlgID, UINT nState)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));


	if (pChord->GetUndetermined(pChord->RootIndex()) & dwUDFlag)
	{
		CButton *pButton = (CButton *) GetDlgItem(nDlgID);
		if (pButton)
		{
//			pButton->SetButtonStyle(BS_AUTO3STATE);
			pButton->SetCheck(0);		
		}
	}
	else
	{
		CButton *pButton = (CButton *) GetDlgItem(nDlgID);
		if (pButton)
		{
//			pButton->SetButtonStyle(BS_AUTOCHECKBOX);
			pButton->SetCheck(nState);
		}
	}

}

BOOL CChordScalePropPage::OnSetActive() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	RegisterMidi();
	
	return CPropertyPage::OnSetActive();
}


void CChordScalePropPage::OnKillFocus(CWnd* pNewWnd) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	CPropertyPage::OnKillFocus(pNewWnd);
	
	// TODO: Add your message handler code here
	
}


void CChordScalePropPage::OnChangeRoot() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	char str[30];
	m_Chord.RootToString(str, m_Chord.RootIndex());
	SetDlgItemText(IDC_EDIT_ROOT, str);
	m_Chord.Undetermined(m_Chord.RootIndex())  &= ~UD_CHORDROOT;
	for (int nX = 0; nX < 24; nX++)
	{
		DrawScaleNote(&m_Chord, m_Chord.RootIndex(), nX);
	}
	if (m_pPropPageMgr && m_pPropPageMgr->m_pIPropPageObject)
	{
		m_pPropPageMgr->m_pIPropPageObject->SetData((void *) &m_Chord);
	}	

}

void CChordScalePropPage::OnUseflats() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	for(int i = 0; i < CPropChord::MAX_POLY; i++)
	{
		m_Chord.Undetermined(i) &= ~UD_FLAT;
		m_Chord.SubChord(i)->UseFlat() = 1;
	}
	OnChangeRoot();
	if (m_pPropPageMgr && m_pPropPageMgr->m_pIPropPageObject)
	{
		m_pPropPageMgr->m_pIPropPageObject->SetData((void *) &m_Chord);
	}	
}

void CChordScalePropPage::OnUsesharps() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	for(int i = 0; i < CPropChord::MAX_POLY; i++)
	{
		m_Chord.Undetermined(i) &= ~UD_FLAT;
		m_Chord.SubChord(i)->UseFlat() = 0;
	}
	OnChangeRoot();
	if (m_pPropPageMgr && m_pPropPageMgr->m_pIPropPageObject)
	{
		m_pPropPageMgr->m_pIPropPageObject->SetData((void *) &m_Chord);
	}	
}

void CChordScalePropPage::SetMidiIn(int keyboard)
{
	if(m_fMidiInputTarget == keyboard)
	{
			CButton* pButton = (CButton*)GetDlgItem(m_MidiInIds[m_fMidiInputTarget]);
			pButton->SetState(FALSE);
			m_fMidiInputTarget  = None;
			UnRegisterMidi();
			return;
	}

	if(m_fMidiInputTarget != None)
	{
			CButton* pButton = (CButton*)GetDlgItem(m_MidiInIds[m_fMidiInputTarget]);
			pButton->SetState(FALSE);
	}
	
	m_fMidiInputTarget = keyboard;
	CButton* pButton = (CButton*)GetDlgItem(m_MidiInIds[m_fMidiInputTarget]);
	pButton->SetState(TRUE);
	RegisterMidi();
}

CButton* CChordScalePropPage::GetButton(int id)
{
	CButton* pButton = 0;
	switch(id)
	{
	case IDC_BUTTON_MIDICHORD1:
		pButton = dynamic_cast<CButton*>(&m_midichord1);
		break;
	case IDC_BUTTON_MIDICHORD2:
		pButton = dynamic_cast<CButton*>(&m_midichord2);
		break;
	case IDC_BUTTON_MIDICHORD3:
		pButton = dynamic_cast<CButton*>(&m_midichord3);
		break;
	case IDC_BUTTON_MIDICHORD4:
		pButton = dynamic_cast<CButton*>(&m_midichord4);
		break;
	case IDC_BUTTON_MIDISCALE1:
		pButton = dynamic_cast<CButton*>(&m_midiscale1);
		break;
	case IDC_BUTTON_MIDISCALE2:
		pButton = dynamic_cast<CButton*>(&m_midiscale3);
		break;
	case IDC_BUTTON_MIDISCALE3:
		pButton = dynamic_cast<CButton*>(&m_midiscale3);
		break;
	case IDC_BUTTON_MIDISCALE4:
		pButton = dynamic_cast<CButton*>(&m_midiscale4);
		break;
	}
	return pButton;
}

void CChordScalePropPage::PlaySubChord(int index)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));


	IDMUSProdConductor *pConductor = NULL;
	IDMUSProdComponent* pIComponent = NULL;
	if (m_pPropPageMgr->m_pIFramework)
	{
		if( SUCCEEDED ( m_pPropPageMgr->m_pIFramework->FindComponent( CLSID_CConductor,  &pIComponent ) ))
		{
			pIComponent->QueryInterface( IID_IDMUSProdConductor, (void**)&pConductor );
			if (pConductor)
			{
				short nX;
				DWORD dwTime = 0;
				pConductor->PlayMIDIEvent( MIDI_PCHANGE, 0, 0, 0 );
				pConductor->PlayMIDIEvent( MIDI_PCHANGE+1, 10, 0, 0 );
				for (nX = 0; nX < 24; nX++)
				{
					if ((m_Chord.SubChord(index)->ChordPattern() >> nX) & 1)
					{
						 unsigned char note = static_cast<unsigned char>(MIDI_BASEPITCH + nX + m_Chord.SubChord(index)->ChordRoot());
						pConductor->PlayMIDIEvent( MIDI_NOTEON, 
							note, 120, dwTime );
						dwTime += CHORDNOTE_DUR;
						pConductor->PlayMIDIEvent( MIDI_NOTEOFF, 
							note, 120, dwTime );
					}
				}
				dwTime += CHORDNOTE_DELAY;
				for (nX = 0; nX < 25; nX++)
				{
					if ((m_Chord.SubChord(index)->ScalePattern() >> nX) & 1)
					{
						unsigned char note = static_cast<unsigned char>(MIDI_BASEPITCH + nX+ m_Chord.SubChord(index)->ScaleRoot());
						pConductor->PlayMIDIEvent( MIDI_NOTEON+1, 
							note,  100, dwTime );
						dwTime += SCALENOTE_DUR;
						pConductor->PlayMIDIEvent( MIDI_NOTEOFF+1, 
							note,  100, dwTime );
						dwTime += SCALENOTE_DELAY;
					}
				}
				pConductor->Release();
			}
			pIComponent->Release();
		}
	}
}

void CChordScalePropPage::PlayAllChords()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	IDMUSProdConductor *pConductor = NULL;
	IDMUSProdComponent* pIComponent = NULL;
	if (m_pPropPageMgr->m_pIFramework)
	{
		if( SUCCEEDED ( m_pPropPageMgr->m_pIFramework->FindComponent( CLSID_CConductor,  &pIComponent ) ))
		{
			pIComponent->QueryInterface( IID_IDMUSProdConductor, (void**)&pConductor );
			if (pConductor)
			{
				short nX;
				DWORD dwTime = 0;
				pConductor->PlayMIDIEvent( MIDI_PCHANGE, 0, 0, 0 );
				pConductor->PlayMIDIEvent( MIDI_PCHANGE+1, 10, 0, 0 );
				for(int index = 0; index < MAX_POLY; index++)
				{
					for (nX = 0; nX < 24; nX++)
					{
						if ((m_Chord.SubChord(index)->ChordPattern() >> nX) & 1)
						{
							 unsigned char note = static_cast<unsigned char>(MIDI_BASEPITCH + nX + m_Chord.SubChord(index)->ChordRoot());
							pConductor->PlayMIDIEvent( MIDI_NOTEON, 
								note, 120, dwTime );
							dwTime += CHORDNOTE_DUR;
							pConductor->PlayMIDIEvent( MIDI_NOTEOFF, 
								note, 120, dwTime + CHORDNOTE_DUR*2 );
						}
					}
				}
				pConductor->Release();
			}
			pIComponent->Release();
		}
	}

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Shared\comhelp.h ===
// ---------------------------------------------
// IUnknown macros for implementing redirection to parent
// IUnknown implementation
// ---------------------------------------------

#ifndef IMPLEMENT_IUNKNOWN

#define IMPLEMENT_IUNKNOWN_ADDREF(ObjectClass, InterfaceClass) \
    STDMETHODIMP_(ULONG) ObjectClass::X##InterfaceClass::AddRef(void) \
    { \
        METHOD_PROLOGUE(ObjectClass, InterfaceClass); \
        return pThis->ExternalAddRef(); \
    }

#define IMPLEMENT_IUNKNOWN_RELEASE(ObjectClass, InterfaceClass) \
    STDMETHODIMP_(ULONG) ObjectClass::X##InterfaceClass::Release(void) \
    { \
        METHOD_PROLOGUE(ObjectClass, InterfaceClass); \
        return pThis->ExternalRelease(); \
    }

#define IMPLEMENT_IUNKNOWN_QUERYINTERFACE(ObjectClass, InterfaceClass) \
    STDMETHODIMP ObjectClass::X##InterfaceClass::QueryInterface(REFIID riid, LPVOID *ppVoid) \
    { \
        METHOD_PROLOGUE(ObjectClass, InterfaceClass); \
        return (HRESULT)pThis->ExternalQueryInterface(&riid, ppVoid); \
    }

#define IMPLEMENT_IUNKNOWN(ObjectClass, InterfaceClass) \
    IMPLEMENT_IUNKNOWN_ADDREF(ObjectClass, InterfaceClass) \
    IMPLEMENT_IUNKNOWN_RELEASE(ObjectClass, InterfaceClass) \
    IMPLEMENT_IUNKNOWN_QUERYINTERFACE(ObjectClass, InterfaceClass)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Shared\ChordScalePropPage.h ===
#if !defined(AFX_CHORDSCALEPROPPAGE_H__E4A7E135_B485_11D1_9875_00805FA67D16__INCLUDED_)
#define AFX_CHORDSCALEPROPPAGE_H__E4A7E135_B485_11D1_9875_00805FA67D16__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include <afxext.h>
#include "resource.h"
#include "conductor.h"
#include "..\shared\keyboard.h"
// ChordScalePropPage.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CChordScalePropPage dialog
class CChordPropPageMgr;

class CChordScalePropPage : public CPropertyPage, public IDMUSProdMidiInCPt
{
	friend class CChordPropPageMgr;
	DECLARE_DYNCREATE(CChordScalePropPage)

// Construction
public:
	enum { MAX_POLY = 4 , CHORDNOTE_DUR = 250, SCALENOTE_DUR = 250, CHORDNOTE_DELAY = 125, SCALENOTE_DELAY=125};
	CChordScalePropPage();
	~CChordScalePropPage();
// dispatch callbacks from keyboard controls
	void DispatchKeyboardChange(CKeyboard* pKeyboard, short nKey);

// Dialog Data
	//{{AFX_DATA(CChordScalePropPage)
	enum { IDD = IDD_CHORDSCALE_PROPPAGE };
	CKeyboard	m_keysscale4;
	CKeyboard	m_keysscale3;
	CKeyboard	m_keysscale2;
	CKeyboard	m_keysscale1;
	CKeyboard	m_keyschord4;
	CKeyboard	m_keyschord3;
	CKeyboard	m_keyschord2;
	CKeyboard	m_keyschord1;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CChordScalePropPage)
	public:
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CChordScalePropPage)
	virtual BOOL OnInitDialog();
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnDestroy();
	afx_msg void OnButtonMidichord4();
	afx_msg void OnDrawItem(int nIDCtl, LPDRAWITEMSTRUCT lpDrawItemStruct);
	afx_msg void OnMeasureItem(int nIDCtl, LPMEASUREITEMSTRUCT lpMeasureItemStruct);
	afx_msg void OnButtonMidichord1();
	afx_msg void OnButtonMidichord2();
	afx_msg void OnButtonMidichord3();
	afx_msg void OnButtonMidiroot();
	afx_msg void OnButtonMidiscale1();
	afx_msg void OnButtonMidiscale2();
	afx_msg void OnButtonMidiscale3();
	afx_msg void OnButtonMidiscale4();
	afx_msg void OnButtonPlay1();
	afx_msg void OnButtonPlay2();
	afx_msg void OnButtonPlay3();
	afx_msg void OnButtonPlay4();
	afx_msg void OnButtonPlayall();
	afx_msg void OnButtonShiftl1();
	afx_msg void OnButtonShiftl2();
	afx_msg void OnButtonShiftl3();
	afx_msg void OnButtonShiftl4();
	afx_msg void OnButtonShiftr1();
	afx_msg void OnButtonShiftr2();
	afx_msg void OnButtonShiftr3();
	afx_msg void OnButtonShiftr4();
	afx_msg void OnCheckboxFlats();
	afx_msg void OnChangeEditName();
	afx_msg void OnKillFocus(CWnd* pNewWnd);
	afx_msg void OnUseflats();
	afx_msg void OnUsesharps();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

public:
	void PlayAllChords();
	void PlaySubChord(int index);
	void SetMidiIn(int keyboard);
	void SetChord(CPropChord* pChord);
	// IUnknown functions
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

	// IDMUSProdMidiInCPt functions
	HRESULT STDMETHODCALLTYPE OnMidiMsg(REFERENCE_TIME rtTime, 
										BYTE bStatus, 
										BYTE bData1, 
										BYTE bData2);

	// data transfer functions
	void CopyDataToTab(  CPropChord* pTabData );
	void GetDataFromTab( const CPropChord* pTabData );

private:
	CButton* GetButton(int id);
	enum {None = -1, Chord1 = 0, Chord2 = 1, Chord3 = 2, Chord4 = 3, Scale1 = 4, Scale2 = 5, Scale3 = 6, Scale4 = 7, Root = 8};
	UINT	m_MidiInIds[MAX_POLY*2 + 1];
	int m_fMidiInputTarget;
	void OnChangeRoot();
	void SetCheckBox(CPropChord* pChord, DWORD dwUDFlag, UINT nDlgID, UINT nState);
	void OnNoteDownChordKeys(CKeyboard* pKeyboard, int index, short nKey);
	void OnNoteDownScaleKeys(CKeyboard* pKeyboard, int index, short nKey);
	void DrawScaleNote(CPropChord* pChord, int index, short nX);
	int	GetChordKeyboardIndex(const CKeyboard* pKeyboard);
	int GetScaleKeyboardIndex(const CKeyboard* pKeybaord);
	CKeyboard*		GetChordKeyboard(int index)
	{
		switch(index)
		{
		case 0:
			return &m_keyschord1;			
			break;
		case 1:
			return &m_keyschord2;
			break;
		case 2:
			return &m_keyschord3;
			break;
		case 3:
			return &m_keyschord4;
			break;
		default:
			return 0;
			break;
		}
	}
	CKeyboard*		GetScaleKeyboard(int index)
	{
		switch(index)
		{
		case 0:
			return &m_keysscale1;
			break;
		case 1:
			return &m_keysscale2;
			break;
		case 2:
			return &m_keysscale3;
			break;
		case 3:
			return &m_keysscale4;
			break;
		default:
			return 0;
			break;
		}
	}

	CBitmapButton	m_midichord4;
	CBitmapButton	m_midichord3;
	CBitmapButton	m_midichord2;
	CBitmapButton	m_midichord1;
	CBitmapButton* GetMidiChordButton(int index)
	{
		switch(index)
		{
		case 0:
			return &m_midichord1;			
			break;
		case 1:
			return &m_midichord2;
			break;
		case 2:
			return &m_midichord3;
			break;
		case 3:
			return &m_midichord4;
			break;
		default:
			return 0;
			break;
		}
	}

	CBitmapButton	m_midiscale4;
	CBitmapButton	m_midiscale3;
	CBitmapButton	m_midiscale2;
	CBitmapButton	m_midiscale1;
	CBitmapButton*	GetMidiScaleButton(int index)
	{
		switch(index)
		{
		case 0:
			return &m_midiscale1;
			break;
		case 1:
			return &m_midiscale2;
			break;
		case 2:
			return &m_midiscale3;
			break;
		case 3:
			return &m_midiscale4;
			break;
		default:
			return 0;
			break;
		}
	}

	
	CBitmapButton	m_midiroot;
	
	CBitmapButton	m_shiftl4;
	CBitmapButton	m_shiftl3;
	CBitmapButton	m_shiftl2;
	CBitmapButton	m_shiftl1;
	CBitmapButton* GetShiftLButton(int index)
	{
		switch(index)
		{
		case 0:
			return &m_shiftl1;
			break;
		case 1:
			return &m_shiftl2;
			break;
		case 2:
			return &m_shiftl3;
			break;
		case 3:
			return &m_shiftl4;
			break;
		default:
			return 0;
			break;
		}
	}

	CBitmapButton	m_shiftr4;
	CBitmapButton	m_shiftr3;
	CBitmapButton	m_shiftr2;
	CBitmapButton	m_shiftr1;
	CBitmapButton* GetShiftRButton(int index)
	{
		switch(index)
		{
		case 0:
			return &m_shiftr1;
			break;
		case 1:
			return &m_shiftr2;
			break;
		case 2:
			return &m_shiftr3;
			break;
		case 3:
			return &m_shiftr4;
			break;
		default:
			return 0;
			break;
		}
	}
	
	CBitmapButton	m_play4;
	CBitmapButton	m_play3;
	CBitmapButton	m_play2;
	CBitmapButton	m_play1;
	CBitmapButton* GetPlayButton(int index)
	{
		switch(index)
		{
		case 0:
			return &m_play1;
			break;
		case 1:
			return &m_play2;
			break;
		case 2:
			return &m_play3;
			break;
		case 3:
			return &m_play4;
			break;
		default:
			return 0;
			break;
		}
	}
		
	CBitmapButton	m_playall;
	
	BOOL			m_fNeedToDetach;
	bool				m_bValidChord;
	DWORD			m_cRef;
	CPropChord		m_Chord;
	CChordPropPageMgr*	m_pPropPageMgr;
	IDMUSProdConductor* m_pIConductor;
	void RegisterMidi();
	void UnRegisterMidi();
	DWORD m_dwCookie;		// may be used to distinguish what chord is receiving input (if necessary)
	DWORD m_cRegCount;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_CHORDSCALEPROPPAGE_H__E4A7E135_B485_11D1_9875_00805FA67D16__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Shared\DialogNewCCTrack.cpp ===
// DialogNewCCTrack.cpp : implementation file
//

#include "stdafx.h"
#include "DialogNewCCTrack.h"
#include "CurveIO.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define NBR_EXTRA_CCS			5	// PB, AT(M), AT(P), RPN, NRPN (CC's other than 0-127)

/////////////////////////////////////////////////////////////////////////////
// CDialogNewCCTrack dialog


CDialogNewCCTrack::CDialogNewCCTrack(CWnd* pParent /*=NULL*/)
	: CDialog(CDialogNewCCTrack::IDD, pParent)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	//{{AFX_DATA_INIT(CDialogNewCCTrack)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT

	m_pfCurveStripExists = NULL;
	m_pVoid = NULL;
	m_bCCType = 0xFF;
	m_wRPNType = 0xFFFF;
}


void CDialogNewCCTrack::DoDataExchange(CDataExchange* pDX)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CDialogNewCCTrack)
	DDX_Control(pDX, IDC_COMBO_CC, m_comboCC);
	DDX_Control(pDX, IDC_STATIC_RPN_DESC, m_staticRPNDesc);
	DDX_Control(pDX, IDC_STATIC_RPN_FRIENDLYTEXT, m_staticRPNFriendlyName);
	DDX_Control(pDX, IDC_STATIC_CCTRACK_EXIST, m_staticRPNExists);
	DDX_Control(pDX, IDC_SPIN_RPN_TYPE, m_spinRPNType);
	DDX_Control(pDX, IDC_EDIT_RPN_TYPE, m_editRPNType);
	DDX_Control(pDX, IDOK, m_btnOK);
	//}}AFX_DATA_MAP
}


void CDialogNewCCTrack::FillComboCC( void )
{
	ASSERT( m_pfCurveStripExists != NULL );

	// Don't redraw until we are finished building the list
	m_comboCC.SetRedraw( FALSE );
	
	// Remove all items
	m_comboCC.ResetContent();

	// Load "create" string
	CString cstrCreate; 
	cstrCreate.LoadString( IDS_CREATE_TEXT );

	CString cstrCCText;
	TCHAR tcstrText[100];
	CString strTemp;

	// #define NBR_EXTRA_CCS = number of CC's added by this for loop
	// Build Control Change list
	for( int i = IDS_PitchBend ;  i <= IDS_NRPN ;  i++ )
	{
		strTemp.LoadString( i );
		AfxExtractSubString( cstrCCText, strTemp, 0, '\n' );

		// Add the 'CC' text
		_tcsncpy( tcstrText,cstrCCText, 99 );
		if( !m_pfCurveStripExists( m_pVoid, BYTE(i - IDS_ControlChange0), 0xFFFF ) )
		{
			// Add the ' - Create' text
			_tcscat( tcstrText, cstrCreate );
		}

		m_comboCC.AddString( tcstrText );
	}

	for( i = IDS_ControlChange0 ;  i <= IDS_ControlChange127 ;  i++ )
	{
		strTemp.LoadString( i );
		AfxExtractSubString( cstrCCText, strTemp, 0, '\n' );

		// Add the 'CC' text
		_tcsncpy( tcstrText,cstrCCText, 99 );

		if( !m_pfCurveStripExists( m_pVoid, BYTE(i - IDS_ControlChange0), 0xFFFF ) )
		{
			// Add the ' - Create' text
			_tcscat( tcstrText, cstrCreate );
		}

		m_comboCC.AddString( tcstrText );
	}

	// Redraw the new list
	m_comboCC.SetRedraw( TRUE );
	m_comboCC.SetCurSel( 0 );
}


BEGIN_MESSAGE_MAP(CDialogNewCCTrack, CDialog)
	//{{AFX_MSG_MAP(CDialogNewCCTrack)
	ON_EN_CHANGE(IDC_EDIT_RPN_TYPE, OnChangeEditRPNType)
	ON_CBN_SELCHANGE(IDC_COMBO_CC, OnSelChangeComboCC)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CDialogNewCCTrack message handlers

BOOL CDialogNewCCTrack::OnInitDialog() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	CDialog::OnInitDialog();

	FillComboCC();

	m_spinRPNType.SetRange( MIN_RPN_TYPE_NUMBER, MAX_RPN_TYPE_NUMBER );
	m_editRPNType.SetLimitText( 5 );
	m_staticRPNDesc.ShowWindow( SW_HIDE );
	m_staticRPNFriendlyName.ShowWindow( SW_HIDE );
	m_staticRPNExists.ShowWindow( SW_HIDE );
	m_spinRPNType.ShowWindow( SW_HIDE );
	m_editRPNType.ShowWindow( SW_HIDE );

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CDialogNewCCTrack::OnOK() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	int nCurSel = m_comboCC.GetCurSel();

	if( nCurSel == CB_ERR )
	{
		HINSTANCE hInstance = AfxGetResourceHandle();
		AfxSetResourceHandle( AfxGetInstanceHandle() );
		AfxMessageBox( IDS_ERR_CC_TRACK );
		AfxSetResourceHandle( hInstance );

		m_comboCC.SetFocus();
	}
	else
	{
		// Ensure RPN and NRPN number is valid
		if( (nCurSel == 3) || (nCurSel == 4) )
		{
			// Get text from edit control
			TCHAR tcstrTmp[6];
			m_editRPNType.GetWindowText( tcstrTmp, 6 );

			// If empty, exit early
			if( tcstrTmp[0] == NULL )
			{
				HINSTANCE hInstance = AfxGetResourceHandle();
				AfxSetResourceHandle( AfxGetInstanceHandle() );
				AfxMessageBox( IDS_ERR_CC_TRACK );
				AfxSetResourceHandle( hInstance );

				m_editRPNType.SetFocus();
				return;
			}

			// Convert from text to an integer
			long lNewValue = _ttoi( tcstrTmp );

			// Assign the RPN/NRPN type, with a max of MAX_RPN_TYPE_NUMBER and min of MIN_RPN_TYPE_NUMBER
			m_wRPNType = WORD(max(MIN_RPN_TYPE_NUMBER, min(MAX_RPN_TYPE_NUMBER, lNewValue)));
		}

		// PitchBend and Aftertouch (Mono & Polyphonic) appear
		// first in combo list but appear after other CC's based
		// on bCCType value.
		if( nCurSel >= NBR_EXTRA_CCS )
		{
			nCurSel -= NBR_EXTRA_CCS; 
		}
		else
		{
			nCurSel += 128;
		}

		m_bCCType = (BYTE)nCurSel;

		CDialog::OnOK();
	}
}

void CDialogNewCCTrack::OnChangeEditRPNType() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if (!::IsWindow(m_spinRPNType.m_hWnd))
	{
		return;
	}

	// Get text from edit control
	TCHAR tcstrTmp[6];
	m_editRPNType.GetWindowText( tcstrTmp, 6 );

	// Get current CC selection
	int nCurSel = m_comboCC.GetCurSel();

	// If empty, exit early
	if( tcstrTmp[0] == NULL )
	{
		m_staticRPNFriendlyName.ShowWindow( SW_HIDE );
		m_staticRPNExists.ShowWindow( SW_HIDE );

		if( (nCurSel == 3) || (nCurSel == 4) )
		{
			m_btnOK.EnableWindow( FALSE );
		}
		else
		{
			m_btnOK.EnableWindow( TRUE );
		}
		return;
	}

	m_btnOK.EnableWindow( TRUE );

	// Get range
	int nMin;
	int nMax;
	m_spinRPNType.GetRange( nMin, nMax );

	// Convert from text to an integer
	long lNewValue = _ttoi( tcstrTmp );

	// Ensure the value stays within bounds
	if ( lNewValue < nMin )
	{
		lNewValue = nMin;
		m_spinRPNType.SetPos( nMin );
	}
	else if (lNewValue > nMax)
	{
		lNewValue = nMax;
		m_spinRPNType.SetPos( nMax );
	}

	if( (nCurSel == 3) && (lNewValue < 5) )
	{
		CString strTemp;
		if( strTemp.LoadString( lNewValue + IDS_RPN_PITCHBEND ) )
		{
			CString strRPNName;
			AfxExtractSubString( strRPNName, strTemp, 0, '\n' );
			m_staticRPNFriendlyName.SetWindowText( strRPNName );
			m_staticRPNFriendlyName.ShowWindow( SW_NORMAL );
		}
		else
		{
			m_staticRPNFriendlyName.ShowWindow( SW_HIDE );
		}
	}
	else
	{
		m_staticRPNFriendlyName.ShowWindow( SW_HIDE );
	}

	if( (nCurSel == 3) || (nCurSel == 4) )
	{
		// Display whether RPN/NRPN strip is already in use
		if( m_pfCurveStripExists( m_pVoid, BYTE(nCurSel + 0x80), WORD(lNewValue) ) )
		{
			m_staticRPNExists.ShowWindow( SW_NORMAL );
		}
		else
		{
			m_staticRPNExists.ShowWindow( SW_HIDE );
		}
	}
	else
	{
		m_staticRPNExists.ShowWindow( SW_HIDE );
	}
}

void CDialogNewCCTrack::OnSelChangeComboCC() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	int nCurSel = m_comboCC.GetCurSel();

	if( nCurSel != CB_ERR )
	{
		switch( nCurSel )
		{
		case 3: // RPN
		case 4: // NRPN
			m_staticRPNDesc.ShowWindow( SW_NORMAL );
			m_spinRPNType.ShowWindow( SW_NORMAL );
			m_editRPNType.ShowWindow( SW_NORMAL );

			// Update the friendly RPN text
			OnChangeEditRPNType();
			break;
		default:
			m_staticRPNDesc.ShowWindow( SW_HIDE );
			m_staticRPNExists.ShowWindow( SW_HIDE );
			m_staticRPNFriendlyName.ShowWindow( SW_HIDE );
			m_spinRPNType.ShowWindow( SW_HIDE );
			m_editRPNType.ShowWindow( SW_HIDE );
			m_btnOK.EnableWindow( TRUE );
			break;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Shared\DialogNewCCTrack.h ===
#if !defined(AFX_DIALOGNEWCCTRACK_H__66590545_D86D_11D1_89B1_00C04FD912C8__INCLUDED_)
#define AFX_DIALOGNEWCCTRACK_H__66590545_D86D_11D1_89B1_00C04FD912C8__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// DialogNewCCTrack.h : header file
//

#include "resource.h"

/////////////////////////////////////////////////////////////////////////////
// CDialogNewCCTrack dialog

typedef BOOL (*FuncPtr)(void *, BYTE, WORD);

class CDialogNewCCTrack : public CDialog
{
// Construction
public:
	CDialogNewCCTrack(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CDialogNewCCTrack)
	enum { IDD = IDD_NEW_CC_TRACK };
	CComboBox	m_comboCC;
	CStatic	m_staticRPNDesc;
	CStatic	m_staticRPNFriendlyName;
	CStatic m_staticRPNExists;
	CSpinButtonCtrl	m_spinRPNType;
	CEdit	m_editRPNType;
	CButton		m_btnOK;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CDialogNewCCTrack)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
public:
	FuncPtr			 m_pfCurveStripExists;
	BYTE			 m_bCCType;
	WORD			 m_wRPNType; // RPN or NRPN type
	void			*m_pVoid;

protected:
	void FillComboCC();

	// Generated message map functions
	//{{AFX_MSG(CDialogNewCCTrack)
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	afx_msg void OnChangeEditRPNType();
	afx_msg void OnSelChangeComboCC();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DIALOGNEWCCTRACK_H__66590545_D86D_11D1_89B1_00C04FD912C8__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Shared\DialogVelocity.h ===
#if !defined(AFX_DIALOGVELOCITY_H__8F946A98_5182_4206_BE6E_57678957D44F__INCLUDED_)
#define AFX_DIALOGVELOCITY_H__8F946A98_5182_4206_BE6E_57678957D44F__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// DialogVelocity.h : header file
//

#include "resource.h"

class CVelocityEdit :
	public CEdit
{
	DECLARE_DYNCREATE(CVelocityEdit)
public:
	CVelocityEdit();

	// for processing Windows messages
	virtual LRESULT WindowProc(UINT message, WPARAM wParam, LPARAM lParam);
};

typedef enum
{
	VELOCITY_TARGET_SELECTED,
	VELOCITY_TARGET_PART,
	VELOCITY_TARGET_PATTERN
} VELOCITY_TARGET;

/////////////////////////////////////////////////////////////////////////////
// CDialogVelocity dialog

class CDialogVelocity : public CDialog
{
// Construction
public:
	CDialogVelocity(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CDialogVelocity)
	enum { IDD = IDD_VELOCITY };
	CSpinButtonCtrl	m_spinStrengthEnd;
	CVelocityEdit	m_editStrengthEnd;
	CSpinButtonCtrl	m_spinStrength;
	CSpinButtonCtrl	m_spinMin;
	CSpinButtonCtrl	m_spinMax;
	CVelocityEdit	m_editStrength;
	CEdit	m_editMin;
	CEdit	m_editMax;
	//}}AFX_DATA

	bool				m_fEnableSelected;
	bool				m_fEndTracksStart;

	VELOCITY_TARGET		m_vtTarget;
	bool				m_fAbsolute;
	bool				m_fPercent;
	long				m_lAbsoluteChangeStart;
	long				m_lAbsoluteChangeEnd;
	BYTE				m_bCompressMin;
	BYTE				m_bCompressMax;

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CDialogVelocity)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	void EnableDlgItem( int nItemID, BOOL fEnable );

	// Generated message map functions
	//{{AFX_MSG(CDialogVelocity)
	afx_msg void OnRadioAbsolute();
	afx_msg void OnRadioCompress();
	afx_msg void OnRadioLinear();
	afx_msg void OnRadioPercent();
	afx_msg void OnKillfocusEditMax();
	afx_msg void OnKillfocusEditMin();
	afx_msg void OnKillfocusEditStrength();
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	afx_msg void OnKillfocusEditStrengthEnd();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DIALOGVELOCITY_H__8F946A98_5182_4206_BE6E_57678957D44F__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Shared\DialogVelocity.cpp ===
// DialogVelocity.cpp : implementation file
//

#include "stdafx.h"
#include "DialogVelocity.h"
#include "Windowsx.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


// Custom edit control that only accepts numbers, editing keys, and '-'
IMPLEMENT_DYNCREATE( CVelocityEdit, CEdit )

CVelocityEdit::CVelocityEdit() : CEdit()
{
}

LRESULT CVelocityEdit::WindowProc(UINT message, WPARAM wParam, LPARAM lParam)
{
	switch( message )
	{
	case WM_CHAR:
		switch( wParam )
		{
		case 8:  // Backspace
		case '-':
		case '+':
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
		case 71: // Home
		case 75: // Left
		case 77: // Right
		case 79: // End
		case 82: // Ins
		case 83: // Del
			break;
		default:
			return TRUE;
		break;
		}
	}
	return CEdit::WindowProc( message, wParam, lParam );
}

/////////////////////////////////////////////////////////////////////////////
// CDialogVelocity dialog


CDialogVelocity::CDialogVelocity(CWnd* pParent /*=NULL*/)
	: CDialog(CDialogVelocity::IDD, pParent)
{
	//{{AFX_DATA_INIT(CDialogVelocity)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT

	m_fEnableSelected = false;
	m_fEndTracksStart = true;

	m_vtTarget = VELOCITY_TARGET_PART;
	m_fAbsolute = true;
	m_fPercent = true;
	m_lAbsoluteChangeStart = 0;
	m_lAbsoluteChangeEnd = 0;
	m_bCompressMin = 1;
	m_bCompressMax = 127;
}


void CDialogVelocity::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CDialogVelocity)
	DDX_Control(pDX, IDC_SPIN_STRENGTH_END, m_spinStrengthEnd);
	DDX_Control(pDX, IDC_EDIT_STRENGTH_END, m_editStrengthEnd);
	DDX_Control(pDX, IDC_SPIN_STRENGTH, m_spinStrength);
	DDX_Control(pDX, IDC_SPIN_MIN, m_spinMin);
	DDX_Control(pDX, IDC_SPIN_MAX, m_spinMax);
	DDX_Control(pDX, IDC_EDIT_STRENGTH, m_editStrength);
	DDX_Control(pDX, IDC_EDIT_MIN, m_editMin);
	DDX_Control(pDX, IDC_EDIT_MAX, m_editMax);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CDialogVelocity, CDialog)
	//{{AFX_MSG_MAP(CDialogVelocity)
	ON_BN_CLICKED(IDC_RADIO_ABSOLUTE, OnRadioAbsolute)
	ON_BN_CLICKED(IDC_RADIO_COMPRESS, OnRadioCompress)
	ON_BN_CLICKED(IDC_RADIO_LINEAR, OnRadioLinear)
	ON_BN_CLICKED(IDC_RADIO_PERCENT, OnRadioPercent)
	ON_EN_KILLFOCUS(IDC_EDIT_MAX, OnKillfocusEditMax)
	ON_EN_KILLFOCUS(IDC_EDIT_MIN, OnKillfocusEditMin)
	ON_EN_KILLFOCUS(IDC_EDIT_STRENGTH, OnKillfocusEditStrength)
	ON_EN_KILLFOCUS(IDC_EDIT_STRENGTH_END, OnKillfocusEditStrengthEnd)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CDialogVelocity message handlers

void SetAbsEditText( CVelocityEdit &editCtrl, CSpinButtonCtrl &spinCtrl, int nValue )
{
	// Set the spin control
	spinCtrl.SetPos( nValue );

	// Get the text string for the number (including the +/- sign)
	TCHAR tcstrText[20];
	_stprintf( tcstrText, _T("%+d"), nValue );

	// Set the edit control's text
	editCtrl.SetWindowText( tcstrText );
}

BOOL CDialogVelocity::OnInitDialog() 
{
	CDialog::OnInitDialog();
	
	// Enable/Disable the Selected Notes radio button
	EnableDlgItem( IDC_RADIO_SELECTED_NOTES, m_fEnableSelected );

	// Set the Velocity Target radio button
	switch( m_vtTarget )
	{
	case VELOCITY_TARGET_SELECTED:
		ASSERT( m_fEnableSelected );
		CheckRadioButton( IDC_RADIO_SELECTED_NOTES, IDC_RADIO_PATTERN, IDC_RADIO_SELECTED_NOTES );
		break;
	case VELOCITY_TARGET_PART:
		CheckRadioButton( IDC_RADIO_SELECTED_NOTES, IDC_RADIO_PATTERN, IDC_RADIO_PART );
		break;
	case VELOCITY_TARGET_PATTERN:
		CheckRadioButton( IDC_RADIO_SELECTED_NOTES, IDC_RADIO_PATTERN, IDC_RADIO_PATTERN );
		break;
	default:
		break;
	}

	// Initialize min/max edit boxes
	m_editMin.SetLimitText( 3 );
	m_editMax.SetLimitText( 3 );
	m_spinMin.SetRange( 1, 127 );
	m_spinMax.SetRange( 1, 127 );
	m_spinMin.SetPos( m_bCompressMin );
	m_spinMax.SetPos( m_bCompressMax );

	// Initialize Strength edit box
	if( m_fPercent )
	{
		m_editStrength.SetLimitText( 4 ); // +200
		m_editStrengthEnd.SetLimitText( 4 );
		m_spinStrength.SetRange32( -99, 200 );
		m_spinStrengthEnd.SetRange32( -99, 200 );
	}
	else
	{
		m_editStrength.SetLimitText( 4 ); // +127
		m_editStrengthEnd.SetLimitText( 4 );
		m_spinStrength.SetRange32( -126, 127 );
		m_spinStrengthEnd.SetRange32( -126, 127 );
	}
	SetAbsEditText( m_editStrength, m_spinStrength, m_lAbsoluteChangeStart );
	SetAbsEditText( m_editStrengthEnd, m_spinStrengthEnd, m_lAbsoluteChangeEnd );
	CheckRadioButton( IDC_RADIO_PERCENT, IDC_RADIO_LINEAR, m_fPercent ? IDC_RADIO_PERCENT : IDC_RADIO_LINEAR );

	// Initialize whether the end value tracks the start value
	m_fEndTracksStart = (m_lAbsoluteChangeStart == m_lAbsoluteChangeEnd);

	// Initialize the absolute/compress radio buttons
	CheckRadioButton( IDC_RADIO_ABSOLUTE, IDC_RADIO_COMPRESS, m_fAbsolute ? IDC_RADIO_ABSOLUTE : IDC_RADIO_COMPRESS );

	// Enable/Disable the controls appropriately
	m_editMin.EnableWindow( m_fAbsolute ? FALSE : TRUE );
	m_editMax.EnableWindow( m_fAbsolute ? FALSE : TRUE );
	m_spinMin.EnableWindow( m_fAbsolute ? FALSE : TRUE );
	m_spinMax.EnableWindow( m_fAbsolute ? FALSE : TRUE );
	EnableDlgItem( IDC_STATIC_MIN, m_fAbsolute ? FALSE : TRUE );
	EnableDlgItem( IDC_STATIC_MAX, m_fAbsolute ? FALSE : TRUE );

	m_editStrength.EnableWindow( m_fAbsolute ? TRUE : FALSE );
	m_spinStrength.EnableWindow( m_fAbsolute ? TRUE : FALSE );
	m_editStrengthEnd.EnableWindow( m_fAbsolute ? TRUE : FALSE );
	m_spinStrengthEnd.EnableWindow( m_fAbsolute ? TRUE : FALSE );
	EnableDlgItem( IDC_RADIO_PERCENT, m_fAbsolute ? TRUE : FALSE );
	EnableDlgItem( IDC_RADIO_LINEAR, m_fAbsolute ? TRUE : FALSE );
	EnableDlgItem( IDC_STATIC_START, m_fAbsolute ? TRUE : FALSE );
	EnableDlgItem( IDC_STATIC_END, m_fAbsolute ? TRUE : FALSE );

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CDialogVelocity::OnRadioAbsolute() 
{
	// Enable/Disable the controls appropriately
	m_editMin.EnableWindow( FALSE );
	m_editMax.EnableWindow( FALSE );
	m_spinMin.EnableWindow( FALSE );
	m_spinMax.EnableWindow( FALSE );
	EnableDlgItem( IDC_STATIC_MIN, FALSE );
	EnableDlgItem( IDC_STATIC_MAX, FALSE );

	m_editStrength.EnableWindow( TRUE );
	m_spinStrength.EnableWindow( TRUE );
	m_editStrengthEnd.EnableWindow( TRUE );
	m_spinStrengthEnd.EnableWindow( TRUE );
	EnableDlgItem( IDC_RADIO_PERCENT, TRUE );
	EnableDlgItem( IDC_RADIO_LINEAR, TRUE );
	EnableDlgItem( IDC_STATIC_START, TRUE );
	EnableDlgItem( IDC_STATIC_END, TRUE );
}

void CDialogVelocity::OnRadioCompress() 
{
	// Enable/Disable the controls appropriately
	m_editMin.EnableWindow( TRUE );
	m_editMax.EnableWindow( TRUE );
	m_spinMin.EnableWindow( TRUE );
	m_spinMax.EnableWindow( TRUE );
	EnableDlgItem( IDC_STATIC_MIN, TRUE );
	EnableDlgItem( IDC_STATIC_MAX, TRUE );

	m_editStrength.EnableWindow( FALSE );
	m_spinStrength.EnableWindow( FALSE );
	m_editStrengthEnd.EnableWindow( FALSE );
	m_spinStrengthEnd.EnableWindow( FALSE );
	EnableDlgItem( IDC_RADIO_PERCENT, FALSE );
	EnableDlgItem( IDC_RADIO_LINEAR, FALSE );
	EnableDlgItem( IDC_STATIC_START, FALSE );
	EnableDlgItem( IDC_STATIC_END, FALSE );
}

void CDialogVelocity::OnRadioLinear() 
{
	// Initialize Strength edit box
	m_editStrength.SetLimitText( 4 ); // +127
	m_spinStrength.SetRange32( -126, 127 );
	m_editStrengthEnd.SetLimitText( 4 );
	m_spinStrengthEnd.SetRange32( -126, 127 );

	OnKillfocusEditStrength();
	OnKillfocusEditStrengthEnd();
}

void CDialogVelocity::OnRadioPercent() 
{
	// Initialize Strength edit box
	m_editStrength.SetLimitText( 4 ); // +200
	m_spinStrength.SetRange32( -99, 200 );
	m_editStrengthEnd.SetLimitText( 4 );
	m_spinStrengthEnd.SetRange32( -99, 200 );

	OnKillfocusEditStrength();
	OnKillfocusEditStrengthEnd();
}

void CDialogVelocity::OnKillfocusEditMax() 
{
	BOOL fTransSucceeded;
	int nValue = GetDlgItemInt( IDC_EDIT_MAX, &fTransSucceeded, FALSE );
	if ( !fTransSucceeded || (nValue > 127) )
	{
		m_spinMax.SetPos( 127 );
		nValue = 127;
	}
	else if( nValue < 1 )
	{
		m_spinMax.SetPos( 1 );
		m_spinMin.SetPos( 1 );
	}
	else if ( nValue < m_spinMin.GetPos() )
	{
		m_spinMin.SetPos( nValue );
	}
}

void CDialogVelocity::OnKillfocusEditMin() 
{
	BOOL fTransSucceeded;
	int nValue = GetDlgItemInt( IDC_EDIT_MIN, &fTransSucceeded, FALSE );
	if ( !fTransSucceeded )
	{
		m_spinMin.SetPos( 1 );
	}
	else if( nValue > 127 )
	{
		m_spinMin.SetPos( 127 );
		m_spinMax.SetPos( 127 );
	}
	else if( nValue < 1 )
	{
		m_spinMin.SetPos( 1 );
	}
	else if( nValue > m_spinMax.GetPos() )
	{
		m_spinMax.SetPos( nValue );
	}
}

void CDialogVelocity::OnKillfocusEditStrength() 
{
	CString strText;
	m_editStrength.GetWindowText( strText );
	strText.TrimLeft();
	strText.TrimRight();

	// Strip off the leading '+'
	if( strText.GetAt(0) == _T('+') )
	{
		strText = strText.Right( strText.GetLength() - 1 );
	}

	TCHAR tcstrExtra[256];
	tcstrExtra[0] = 0;
	int nValue = 0;
	if( !strText.IsEmpty() )
	{
		_stscanf( strText, _T("%d%s"), &nValue, tcstrExtra );
	}

	if( strText.IsEmpty()
	||	(_tcslen(tcstrExtra) > 0) )
	{
		nValue = 0;
	}
	else if( IDC_RADIO_PERCENT == GetCheckedRadioButton( IDC_RADIO_PERCENT, IDC_RADIO_LINEAR ) )
	{
		// Percent
		if( nValue > 200 )
		{
			nValue = 200;
		}
		else if( nValue < -99 )
		{
			nValue = -99;
		}
	}
	else
	{
		// Absolute
		if( nValue > 127 )
		{
			nValue = 127;
		}
		else if( nValue < -126 )
		{
			nValue = -126;
		}
	}

	if( m_fEndTracksStart )
	{
		SetAbsEditText( m_editStrengthEnd, m_spinStrengthEnd, (int)(short)LOWORD(m_spinStrength.GetPos()) );
	}

	SetAbsEditText( m_editStrength, m_spinStrength, nValue );
}

void CDialogVelocity::OnKillfocusEditStrengthEnd()
{
	CString strText;
	m_editStrengthEnd.GetWindowText( strText );
	strText.TrimLeft();
	strText.TrimRight();

	// Strip off the leading '+'
	if( strText.GetAt(0) == _T('+') )
	{
		strText = strText.Right( strText.GetLength() - 1 );
	}

	TCHAR tcstrExtra[256];
	tcstrExtra[0] = 0;
	int nValue = 0;
	if( !strText.IsEmpty() )
	{
		_stscanf( strText, _T("%d%s"), &nValue, tcstrExtra );
	}

	if( strText.IsEmpty()
	||	(_tcslen(tcstrExtra) > 0) )
	{
		nValue = 0;
	}
	else if( IDC_RADIO_PERCENT == GetCheckedRadioButton( IDC_RADIO_PERCENT, IDC_RADIO_LINEAR ) )
	{
		// Percent
		if( nValue > 200 )
		{
			nValue = 200;
		}
		else if( nValue < -99 )
		{
			nValue = -99;
		}
	}
	else
	{
		// Absolute
		if( nValue > 127 )
		{
			nValue = 127;
		}
		else if( nValue < -126 )
		{
			nValue = -126;
		}
	}

	if( (int)(short)LOWORD(m_spinStrength.GetPos()) != nValue )
	{
		m_fEndTracksStart = false;
	}

	SetAbsEditText( m_editStrengthEnd, m_spinStrengthEnd, nValue );
}

void CDialogVelocity::OnOK() 
{
	// Set the Edit Velocity Target
	switch( GetCheckedRadioButton( IDC_RADIO_SELECTED_NOTES, IDC_RADIO_PATTERN ) )
	{
	case IDC_RADIO_SELECTED_NOTES:
		m_vtTarget = VELOCITY_TARGET_SELECTED;
		break;
	case IDC_RADIO_PART:
		m_vtTarget = VELOCITY_TARGET_PART;
		break;
	case IDC_RADIO_PATTERN:
		m_vtTarget = VELOCITY_TARGET_PATTERN;
		break;
	default:
		break;
	}

	m_bCompressMin = BYTE(m_spinMin.GetPos());
	m_bCompressMax = BYTE(m_spinMax.GetPos());
	m_lAbsoluteChangeStart = (int)(short)LOWORD(m_spinStrength.GetPos());
	m_lAbsoluteChangeEnd = (int)(short)LOWORD(m_spinStrengthEnd.GetPos());

	// Set the linear/percent flag
	m_fPercent = (IDC_RADIO_PERCENT == GetCheckedRadioButton( IDC_RADIO_PERCENT, IDC_RADIO_LINEAR ));

	// Set the absolute/compres flag
	m_fAbsolute = (IDC_RADIO_ABSOLUTE == GetCheckedRadioButton( IDC_RADIO_ABSOLUTE, IDC_RADIO_COMPRESS ));

	CDialog::OnOK();
}

void CDialogVelocity::EnableDlgItem( int nItemID, BOOL fEnable )
{
	CWnd* pWnd = GetDlgItem( nItemID );
	if (pWnd)
	{
		pWnd->EnableWindow( fEnable );
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Shared\DlgAddPChannel.cpp ===
// DlgAddPChannel.cpp : implementation file
//

#include "stdafx.h"
#include "DlgAddPChannel.h"
#include "PChannelName.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define PCHANNEL_NAME_BUFFER_SIZE	(MAX_PATH + 10)

/////////////////////////////////////////////////////////////////////////////
// CDlgAddPChannel dialog


CDlgAddPChannel::CDlgAddPChannel(CWnd* pParent /*=NULL*/)
	: CDialog(CDlgAddPChannel::IDD, pParent)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	//{{AFX_DATA_INIT(CDlgAddPChannel)
	//}}AFX_DATA_INIT
	m_pIPChannelName = NULL;
	m_fChanged = false;
}

CDlgAddPChannel::~CDlgAddPChannel()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pIPChannelName )
	{
		m_pIPChannelName->Release();
		m_pIPChannelName = NULL;
	}
}

void CDlgAddPChannel::DoDataExchange(CDataExchange* pDX)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CDlgAddPChannel)
	DDX_Control(pDX, IDC_LIST_CHANNEL, m_listPChannel);
	DDX_Control(pDX, IDC_BTN_REMOVE, m_btnRemove);
	DDX_Control(pDX, IDC_BUTTON_ADD16, m_btnAdd16);
	DDX_Control(pDX, IDC_BUTTON_ADD, m_btnAdd);
	DDX_Control(pDX, IDC_EDIT_PCHANNEL_NAME, m_editPChannelName);
	DDX_Control(pDX, IDC_SPIN_PCHANNEL, m_spinPChannel);
	DDX_Control(pDX, IDC_EDIT_PCHANNEL, m_editPChannel);
	DDX_Control(pDX, IDOK, m_btnOK);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CDlgAddPChannel, CDialog)
	//{{AFX_MSG_MAP(CDlgAddPChannel)
	ON_EN_UPDATE(IDC_EDIT_PCHANNEL, OnUpdateEditPchannel)
	ON_BN_CLICKED(IDC_BUTTON_ADD, OnButtonAdd)
	ON_BN_CLICKED(IDC_BTN_REMOVE, OnBtnRemove)
	ON_BN_CLICKED(IDC_BUTTON_ADD16, OnButtonAdd16)
	ON_LBN_SELCHANGE(IDC_LIST_CHANNEL, OnSelchangeListChannel)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CDlgAddPChannel message handlers

void CDlgAddPChannel::OnUpdateEditPchannel() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_btnAdd.GetSafeHwnd() == NULL )
	{
		return;
	}

	BOOL fTrans;
	DWORD dwPChannel = GetDlgItemInt( IDC_EDIT_PCHANNEL, &fTrans, FALSE );
	if( fTrans && dwPChannel > 0 && dwPChannel < 1000 )
	{
		dwPChannel--;
		for( int i=m_adwExistingPChannels.GetUpperBound(); i >= 0; i-- )
		{
			if( m_adwExistingPChannels.GetAt( i ) == dwPChannel )
			{
				break;
			}
		}
		if( i == -1 )
		{
			// Didn't find the PChannel - look through the mix group's list
			for(  i=m_adwPChannels.GetUpperBound(); i >= 0; i-- )
			{
				if( m_adwPChannels.GetAt( i ) == dwPChannel )
				{
					break;
				}
			}
		}

		if( i == -1 )
		{
			// Didn't find the PChannel - enable the Add button
			m_btnAdd.EnableWindow( TRUE );
			m_btnAdd16.EnableWindow( TRUE );
		}
		else
		{
			// Found the PChannel - disable the Add button
			m_btnAdd.EnableWindow( FALSE );
			m_btnAdd16.EnableWindow( FALSE );
		}

		WCHAR wcstrPChannelName[MAX_PATH];
		if( m_pIPChannelName && SUCCEEDED( m_pIPChannelName->GetPChannelName( dwPChannel, wcstrPChannelName ) ) )
		{
			CString strText = wcstrPChannelName;
			m_editPChannelName.SetWindowText( strText );
		}
		else
		{
			m_editPChannelName.SetWindowText(NULL);
		}
	}
	else
	{
		// PChannel number invalid - disable the Add button
		m_btnAdd.EnableWindow( FALSE );
		m_btnAdd16.EnableWindow( FALSE );
		m_editPChannelName.SetWindowText(NULL);
	}
}

BOOL CDlgAddPChannel::OnInitDialog() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CDialog::OnInitDialog();

	// Set dialog title
	if( m_strTitle.IsEmpty() == FALSE )
	{
		SetWindowText( m_strTitle );
	}

	// Set the range of the spin control
	m_spinPChannel.SetRange( 1, 999 );

	// Limit the text size of the PChannel edit box
	m_editPChannel.SetLimitText( 3 );

	// Update the PChannel number with the first available PChannel
	m_spinPChannel.SetPos( FindNextValidPChannel( 0 ) + 1 );

	// Update the PChannel name
	OnUpdateEditPchannel();

	// Resync the listbox
	RefreshListbox();

	// Update the state of the 'Remove' button
	OnSelchangeListChannel();

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CDlgAddPChannel::RefreshListbox( void )
{
	m_listPChannel.SetRedraw( FALSE );
	m_listPChannel.ResetContent();

	WCHAR wcstrPChannelName[MAX_PATH];
	TCHAR tcstrPChannel[PCHANNEL_NAME_BUFFER_SIZE];

	for( int i=m_adwPChannels.GetUpperBound(); i >= 0; i-- )
	{
		DWORD dwPChannel = m_adwPChannels.GetAt(i);
		ASSERT( dwPChannel < 1000 ); 
		_itot( dwPChannel + 1, tcstrPChannel, 10 );

		if( m_pIPChannelName && SUCCEEDED( m_pIPChannelName->GetPChannelName( dwPChannel, wcstrPChannelName ) ) )
		{
			_tcsncat( tcstrPChannel, _T(" - "), 3 );
			CString strText = wcstrPChannelName;
			_tcsncat( tcstrPChannel, strText, strText.GetLength() );
		}

		int nIndex = m_listPChannel.InsertString( 0, tcstrPChannel );
		m_listPChannel.SetItemData( nIndex, dwPChannel );
	}
	m_listPChannel.SetRedraw( TRUE );
	m_listPChannel.Invalidate( TRUE );
}

DWORD CDlgAddPChannel::FindNextValidPChannel( DWORD dwPChannel ) const
{
	while( dwPChannel < 999 )
	{
		// Check through m_adwExistingPChannels for dwPChannel
		for( int i=m_adwExistingPChannels.GetUpperBound(); i >= 0; i-- )
		{
			if( m_adwExistingPChannels.GetAt( i ) == dwPChannel )
			{
				break;
			}
		}
		if( i == -1 )
		{
			// Didn't find the PChannel - look through the mix group's list
			for(  i=m_adwPChannels.GetUpperBound(); i >= 0; i-- )
			{
				if( m_adwPChannels.GetAt( i ) == dwPChannel )
				{
					break;
				}
			}
		}

		// Didn't find the PChannel
		if( i == -1 )
		{
			// Break out of the while() loop and return dwPChannel
			break;
		}

		// Found the PChannel, go through the loop again with the next PChannel
		dwPChannel++;
	}

	return min( dwPChannel, 998 );
}

void CDlgAddPChannel::OnOK() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	/*
	if( m_pfnInsertPChannel )
	{
		if( (*m_pfnInsertPChannel)( m_pCallbackData, m_fChanged, m_dwPChannel ) )
		{
			DWORD *adwNewArray = new DWORD[m_lCountExistingPChannels + 1];
			memcpy( adwNewArray, m_adwExistingPChannels, sizeof(DWORD) * m_lCountExistingPChannels );
			adwNewArray[m_lCountExistingPChannels] = m_dwPChannel;
			delete[] m_adwExistingPChannels;
			m_adwExistingPChannels = adwNewArray;
			m_lCountExistingPChannels++;

			// Increment the PChannel # by one
			m_dwPChannel++;

			// Find the next available PChannel and return it (up to a maximum of 999)
			m_dwPChannel = FindNextValidPChannel( m_dwPChannel );

			// Update the PChannel number
			m_spinPChannel.SetPos( m_dwPChannel + 1 );

			OnUpdateEditPchannel();
			return;
		}
	}
	*/

	CDialog::OnOK();
}

bool CDlgAddPChannel::AddToList( DWORD dwPChannel )
{
	// Search through all items in the array
	for( int i=m_adwPChannels.GetUpperBound(); i >= 0; i-- )
	{
		// Get the PChannel value for each index
		DWORD dwTmpPChannel = m_adwPChannels.GetAt(i);

		// Ensure the PChannel # is valid
		ASSERT( dwTmpPChannel < 1000 );

		// Check that the PChannel doesn't already exist
		if( dwTmpPChannel == dwPChannel )
		{
			ASSERT(FALSE);
			return false;
		}

		// Check if the new PChannel should be inserted above the current one
		if( dwTmpPChannel < dwPChannel )
		{
			// Yes - break out and insert above the current index
			break;
		}
	}

	// Insert the new PChannel at the index above the one we have.
	// If the for() loop completes, i will be -1.
	m_adwPChannels.InsertAt( i+1, dwPChannel, 1 );
	return true;
}

void CDlgAddPChannel::OnButtonAdd()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Get the PChannel # to add
	BOOL fTrans;
	DWORD dwPChannel = GetDlgItemInt( IDC_EDIT_PCHANNEL, &fTrans, FALSE );

	// Ensure the PChannel # is valid
	dwPChannel = min( dwPChannel-1, 998 );

	// Do a sorted add to the list of channels
	if( AddToList( dwPChannel ) )
	{
		RefreshListbox();
	}

	// Remove selection from all strings
	m_listPChannel.SetSel(-1, FALSE);

	// Search for the PChannel # we added
	for( int i=0; i < m_listPChannel.GetCount(); i++ )
	{
		if( m_listPChannel.GetItemData( i ) == dwPChannel )
		{
			// Select the PChannel
			m_listPChannel.SetSel( i, TRUE );
			break;
		}
	}

	// Find the next available PChannel and return it (up to a maximum of 999)
	dwPChannel = FindNextValidPChannel( dwPChannel + 1 );

	// Update the PChannel number
	m_spinPChannel.SetPos( dwPChannel + 1 );

	// Update the PChannel name
	OnUpdateEditPchannel();

	// Update the state of the 'Remove' button
	OnSelchangeListChannel();
}

void CDlgAddPChannel::OnBtnRemove() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Check that something is selected
	if (m_listPChannel.GetSelCount() <= 0)
	{
		return;
	}

	m_listPChannel.SetRedraw( FALSE );

	// Remove channels selected in the list
	for (int nCount = m_listPChannel.GetCount() - 1; nCount >= 0; nCount--) 
	{
		// Check if this string is selected
		if (m_listPChannel.GetSel(nCount)) 
		{
			// Yes - get the PChannel #
			DWORD dwPChannel = m_listPChannel.GetItemData(nCount);			

			// Search for and remove the PChannel from our list
			for( int i=m_adwPChannels.GetUpperBound(); i >= 0; i-- )
			{
				if( m_adwPChannels.GetAt(i) == dwPChannel )
				{
					m_adwPChannels.RemoveAt( i, 1 );
					break;
				}
			}

			// Remove the string from the listbox
			m_listPChannel.DeleteString(nCount);
		}
	}

	m_listPChannel.SetRedraw( TRUE );
	m_listPChannel.Invalidate( TRUE );

	// Update the state of the add/add16 buttons.
	OnUpdateEditPchannel();

	// Update the state of the 'Remove' button
	OnSelchangeListChannel();
}

void CDlgAddPChannel::OnButtonAdd16() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	DWORD dwLastPChannelAdded = 0;
	bool fChanged = false;

	for( int i=0; i < 16; i++ )
	{
		if( m_btnAdd.IsWindowEnabled() )
		{
			// Get the PChannel # to add
			BOOL fTrans;
			DWORD dwPChannel = GetDlgItemInt( IDC_EDIT_PCHANNEL, &fTrans, FALSE );

			// Ensure the PChannel # is valid
			dwPChannel = min( dwPChannel-1, 998 );

			// Do a sorted add to the list of channels
			if( AddToList( dwPChannel ) )
			{
				dwLastPChannelAdded = dwPChannel;
				fChanged = true;
			}

			// Find the next available PChannel and return it (up to a maximum of 999)
			dwPChannel = FindNextValidPChannel( dwPChannel + 1 );

			// Update the PChannel number
			m_spinPChannel.SetPos( dwPChannel + 1 );

			// Update the PChannel name and add/add16 button state
			OnUpdateEditPchannel();
		}
	}

	if( fChanged )
	{
		RefreshListbox();

		// Remove selection from all strings
		m_listPChannel.SetSel(-1, FALSE);

		// Search for the PChannel # we added
		for( int i=0; i < m_listPChannel.GetCount(); i++ )
		{
			if( m_listPChannel.GetItemData( i ) == dwLastPChannelAdded )
			{
				// Select the PChannel
				m_listPChannel.SetSel( i, TRUE );
				break;
			}
		}

		// Update the state of the 'Remove' button
		OnSelchangeListChannel();
	}
}

void CDlgAddPChannel::OnSelchangeListChannel() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if (m_listPChannel.GetSelCount() > 0)
	{
		m_btnRemove.EnableWindow( TRUE );
	}
	else
	{
		m_btnRemove.EnableWindow( FALSE );
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Shared\DlgAddPChannelresource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by DlgAddPChannel.rc
//
#define IDC_LIST_CHANNEL                201
#define IDC_EDIT_PCHANNEL               203
#define IDC_BUTTON_ADD                  204
#define IDC_BTN_REMOVE                  205
#define IDC_SPIN_PCHANNEL               206
#define IDC_EDIT_PCHANNEL_NAME          207
#define IDD_DLG_ADD_PCHANNEL            208
#define IDC_BUTTON_ADD16                243

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Shared\DlgAddPChannel.h ===
#if !defined(AFX_DLGADDPCHANNEL_H__2C21E9CF_D13A_4B70_BB9D_AFFE95F0A98D__INCLUDED_)
#define AFX_DLGADDPCHANNEL_H__2C21E9CF_D13A_4B70_BB9D_AFFE95F0A98D__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// DlgAddPChannel.h : header file
//

#include "DlgAddPChannelresource.h"

interface IDMUSProdPChannelName;

typedef bool (*INSERT_PCHANNEL_FUNC)(void *pCallbackData, bool &fChanged, DWORD dwPChannel);

/////////////////////////////////////////////////////////////////////////////
// CDlgAddPChannel dialog

class CDlgAddPChannel : public CDialog
{
// Construction
public:
	CDlgAddPChannel(CWnd* pParent = NULL);   // standard constructor
	virtual ~CDlgAddPChannel();

	CDWordArray	m_adwPChannels;
	CDWordArray	m_adwExistingPChannels;
	CString		m_strTitle;

	IDMUSProdPChannelName *m_pIPChannelName;

// Dialog Data
	//{{AFX_DATA(CDlgAddPChannel)
	enum { IDD = IDD_DLG_ADD_PCHANNEL };
	CListBox	m_listPChannel;
	CButton	m_btnRemove;
	CButton	m_btnAdd16;
	CButton	m_btnAdd;
	CEdit	m_editPChannelName;
	CSpinButtonCtrl	m_spinPChannel;
	CEdit	m_editPChannel;
	CButton	m_btnOK;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CDlgAddPChannel)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	DWORD	FindNextValidPChannel( DWORD dwPChannel ) const;
	void	RefreshListbox( void );
	bool	AddToList( DWORD dwPChannel );
	bool	m_fChanged;

	// Generated message map functions
	//{{AFX_MSG(CDlgAddPChannel)
	afx_msg void OnUpdateEditPchannel();
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	afx_msg void OnButtonAdd();
	afx_msg void OnBtnRemove();
	afx_msg void OnButtonAdd16();
	afx_msg void OnSelchangeListChannel();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DLGADDPCHANNEL_H__2C21E9CF_D13A_4B70_BB9D_AFFE95F0A98D__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Shared\GroupBitsPPG.h ===
/************************************************************************
*                                                                       *
*   Copyright (c) 1998-2001 Microsoft Corp. All rights reserved.        *
*                                                                       *
************************************************************************/

#if !defined(AFX_GROUPBITSPPG_H__9D655C81_CE44_11D1_88BC_00C04FBF8D15__INCLUDED_)
#define AFX_GROUPBITSPPG_H__9D655C81_CE44_11D1_88BC_00C04FBF8D15__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include <staticproppagemanager.h>
#include <afxdlgs.h>
#include "GroupBitsPPGresource.h"

extern const GUID GUID_GroupBitsPPGMgr;


// GroupBitsPPG.h : header file
//

#define GROUPBITSPPG_INDEX 0

#define GROUPBITSPPG_GROUPBITS_RO 0x1

typedef struct _PPGTrackParams
{
	DWORD	dwPageIndex;
	DWORD	dwGroupBits;
	DWORD	dwPropPageFlags;
} PPGTrackParams;

/////////////////////////////////////////////////////////////////////////////
// CGroupBitsPropPageMgr

class CGroupBitsPropPageMgr : public CStaticPropPageManager
{
public:
	CGroupBitsPropPageMgr();
	~CGroupBitsPropPageMgr();
	HRESULT STDMETHODCALLTYPE QueryInterface( REFIID riid, LPVOID *ppv );

    // IDMUSProdPropPageManager functions
    HRESULT STDMETHODCALLTYPE GetPropertySheetTitle( BSTR* pbstrTitle, BOOL* pfAddPropertiesText );
    HRESULT STDMETHODCALLTYPE GetPropertySheetPages( IDMUSProdPropSheet* pIPropSheet, 
													 LONG* hPropSheetPage[], short* pnNbrPages );
    HRESULT STDMETHODCALLTYPE RefreshData();
    HRESULT STDMETHODCALLTYPE SetObject( IDMUSProdPropPageObject* pINewPropPageObject );

protected:
	class CGroupBitsPPG*	m_pGroupBitsPPG;
	class CTrackFlagsPPG*	m_pTrackFlagsPPG;

public:
	static short			sm_nActiveTab;
};

/////////////////////////////////////////////////////////////////////////////
// CGroupBitsPPG dialog

class CGroupBitsPPG : public CPropertyPage
{
	DECLARE_DYNCREATE(CGroupBitsPPG)

// Construction
public:
	CGroupBitsPPG();
	~CGroupBitsPPG();

// Dialog Data
	//{{AFX_DATA(CGroupBitsPPG)
	enum { IDD = IDD_PROPPAGE_GROUP_BITS };
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CGroupBitsPPG)
	public:
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam);
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CGroupBitsPPG)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnDestroy();
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

protected:
	void EnableControls( BOOL fEnable );
	void UpdatePPO();
	void EnableItem(int nItem, BOOL fEnable);

public:
	void SetObject( IDMUSProdPropPageObject* pPPO );
	void RefreshData( void );

	// Variables for keeping track of the active property tab (if there is more than one)
	static short*				sm_pnActiveTab;
	IDMUSProdPropSheet*			m_pIPropSheet;

protected:
	IDMUSProdPropPageObject*	m_pPPO;
	PPGTrackParams				m_PPGTrackParams;
	BOOL						m_fNeedToDetach;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_GROUPBITSPPG_H__9D655C81_CE44_11D1_88BC_00C04FBF8D15__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Shared\DLSLoadSaveUtils.cpp ===
// DLSLoadSaveUtils.Cpp : header file
//

#include "stdafx.h"

#ifndef DLSLOADSAVEUTILS_H
#include "DLSLoadSaveUtils.h"
#endif

BOOL notinrange(long a, long b, long range)
{
    if (a > b)
    {
        return ((a - b) > range);
    }
    return ((b - a) > range);
}

void makeconnection(CONNECTION *pChunk,
					USHORT usSource, 
					USHORT usControl,
                    USHORT usDestination, 
					USHORT usTransform, 
					long lScale)
{
    pChunk->usSource = usSource;
    pChunk->usControl = usControl;
    pChunk->usDestination = usDestination;
    pChunk->usTransform = usTransform;
    pChunk->lScale = lScale;
}


unsigned long GetFilePos(IStream* pIStream)
{
    LARGE_INTEGER   dlibSeekTo;
    ULARGE_INTEGER  dlibNewPos;
    dlibSeekTo.HighPart = 0;
    dlibSeekTo.LowPart = 0;
    pIStream->Seek(dlibSeekTo, STREAM_SEEK_CUR, &dlibNewPos);
    return (dlibNewPos.LowPart);
}

void SetFilePos(IStream* pIStream, unsigned long ulPos)
{
    LARGE_INTEGER   dlibSeekTo;
    dlibSeekTo.HighPart = 0;
    dlibSeekTo.LowPart = ulPos;
    pIStream->Seek(dlibSeekTo, STREAM_SEEK_SET, NULL);
}

DWORD TimeCents2Mils(TCENT tcTime)

{
    DWORD dwMils;
    double dTime = tcTime;
    dTime /= (65536 * 1200);
    dTime = pow(2.0,dTime);
    dTime *= 1000;
    dwMils = (DWORD) (dTime + 0.5);
	if (dwMils > 40000) dwMils = 40000;
    return(dwMils);
}

DWORD PitchCents2Hertz(PCENT pcPitch)

{
    DWORD dwHertz;
    double dTemp = pcPitch;
    dTemp /= 65536;
    dTemp -= 6900;
    dTemp /= 1200;
    dTemp = pow(2.0,dTemp);
    dTemp *= 440;
    dTemp *= 1000.0;
    dwHertz = (DWORD) dTemp;
    return(dwHertz);
}

PCENT Hertz2PitchCents(DWORD dwHertz)
{
	double dTemp = dwHertz;
	dTemp /= 440;
	dTemp /= 1000;
	dTemp = log(dTemp);
	dTemp /= log(2);
	dTemp *= 1200;
	dTemp += 6900;
	dTemp *= 65536;
	return (PCENT)dTemp;
}

DWORD PitchCents2PitchFract(PCENT pcRate,DWORD dwSampleRate)

{
    double fTemp = pcRate;
    fTemp /= 65536;
    fTemp -= 6900;
    fTemp /= 1200;
    fTemp = pow(2.0,fTemp);
    fTemp *= 7381975040.0; // (440*256*16*4096);
    fTemp /= dwSampleRate;
    return (DWORD) (fTemp);
}

TCENT Mils2TimeCents(DWORD dwMils)
{
    double dTime;
    if (dwMils < 1) dwMils = 1;
    dTime = dwMils;
	dTime -= 0.5;
    dTime /= 1000.0;
    dTime = log10(dTime) / 0.301;
    dTime *= (1200 * 65536);
    return (TCENT)dTime;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Shared\DLSLoadSaveUtils.h ===
//
// DLSLoadSaveUtils.h : header file for DLSLoadSaveUtils.cpp
//

#ifndef DLSLOADSAVEUTILS_H
#define DLSLOADSAVEUTILS_H

#include "dls1.h"
#include "dls2.h"
#include "RiffStrm.h"
#include <math.h>

typedef long    PCENT;
typedef long    GCENT;
typedef long    TCENT;
typedef long    PERCENT;

BOOL notinrange(long a, long b, long range);

void makeconnection(CONNECTION *pChunk,
					USHORT usSource, 
					USHORT usControl,
                    USHORT usDestination, 
					USHORT usTransform, 
					long lScale);

unsigned long GetFilePos(IStream* pIStream);
void SetFilePos(IStream* pIStream, unsigned long ulPos);
DWORD TimeCents2Mils(TCENT tcTime);
TCENT Mils2TimeCents(DWORD dwMils);
DWORD PitchCents2Hertz(PCENT pcPitch);
PCENT Hertz2PitchCents(DWORD dwHertz);
DWORD PitchCents2PitchFract(PCENT pcRate,DWORD dwSampleRate);

typedef struct LFOParams
{
	// Modulator LFO params
    PCENT       m_pcFrequency;
    TCENT       m_tcDelay;

	GCENT       m_gcVolumeScale;
    PCENT       m_pcPitchScale;
    GCENT       m_gcMWToVolume;
    PCENT       m_pcMWToPitch;
	GCENT		m_gcChanPressToGain;
	PCENT		m_pcChanPressToPitch;
	PCENT		m_pcChanPressToFc;

	// Vibrato LFO Params
	PCENT       m_pcFrequencyVibrato;
    TCENT       m_tcDelayVibrato;

	PCENT       m_pcPitchScaleVibrato;
	PCENT       m_pcMWToPitchVibrato;
	PCENT		m_pcChanPressToPitchVibrato;

} LFOParams;

typedef struct VEGParams
{
	TCENT		m_tcDelay;
    TCENT       m_tcAttack;
	TCENT		m_tcHold;
    TCENT       m_tcDecay;
    PERCENT     m_ptSustain;
    TCENT       m_tcRelease;
	TCENT       m_tcShutdownTime;
    TCENT       m_tcVel2Attack;
    TCENT       m_tcKey2Decay;
	TCENT		m_tcKey2Hold;

} VEGParams;

typedef struct PEGParams
{
	TCENT		m_tcDelay;
    TCENT       m_tcAttack;
	TCENT		m_tcHold;
    TCENT       m_tcDecay;
    PERCENT     m_ptSustain;
    TCENT       m_tcRelease;
    TCENT       m_tcVel2Attack;
	TCENT       m_tcKey2Hold;
    TCENT       m_tcKey2Decay;
    PCENT       m_pcRange;
} PEGParams;

typedef struct FilterParams
{
	PCENT	m_pcInitialFc;
	GCENT	m_gcInitialQ;
	PCENT	m_pcModLFOToFc;
	PCENT	m_pcModLFOCC1ToFc;
	PCENT	m_pcEGToFc;
	PCENT	m_pcVelocityToFc;
	PCENT	m_pcKeyNumToFc;
} FilterParams;

typedef struct MSCParams
{
    PERCENT     m_ptDefaultPan;
} MSCParams;

typedef struct ArticParams
{
    LFOParams		m_LFO;
    VEGParams		m_VolEG;
    PEGParams		m_PitchEG;
	FilterParams	m_FilterParams;
    MSCParams		m_Misc;
} ArticParams;

#define FIVE_HERTZ  (-55791972)

// For J3 move into another file begin
#define MIDI_NOTEOFF    0x80
#define MIDI_NOTEON     0x90
#define MIDI_PTOUCH     0xA0
#define MIDI_CCHANGE    0xB0
#define MIDI_PCHANGE    0xC0
#define MIDI_MTOUCH     0xD0
#define MIDI_PBEND      0xE0
#define MIDI_SYSX       0xF0
#define MIDI_MTC        0xF1
#define MIDI_SONGPP     0xF2
#define MIDI_SONGS      0xF3
#define MIDI_EOX        0xF7
#define MIDI_CLOCK      0xF8
#define MIDI_START      0xFA
#define MIDI_CONTINUE   0xFB
#define MIDI_STOP       0xFC
#define MIDI_SENSE      0xFE

// controller numbers
#define CC_BANKSELECTH  0x00
#define CC_BANKSELECTL  0x20

// are these right?  What about 0x64, 0x65?
#define CC_DATAENTRYMSB 0x06
#define CC_DATAENTRYLSB 0x26

#define CC_MODWHEEL     0x01
#define CC_VOLUME       0x07
#define CC_PAN          0x0A
#define CC_EXPRESSION   0x0B
#define CC_SUSTAIN      0x40
#define CC_ALLSOUNDSOFF 0x78
#define CC_RESETALL     0x79
#define CC_ALLNOTESOFF  0x7B
#define CC_FILTERCUTOFF 0x7E
#define CC_FILTERRESO	0x7F

// For J3 move into another file End

#endif // #ifndef DLSLOADSAVEUTILS_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Shared\DupeFileDlg.h ===
#if !defined(AFX_DUPEFILEDLG_H__96FC19CA_87EF_11D3_B473_00105A2796DE__INCLUDED_)
#define AFX_DUPEFILEDLG_H__96FC19CA_87EF_11D3_B473_00105A2796DE__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// DupeFileDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CDupeFileDlg dialog

class CDupeFileDlg : public CDialog
{
// Construction
public:
	CDupeFileDlg(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CDupeFileDlg)
	enum { IDD = IDD_DUPLICATE_FILE };
	CButton	m_btnOKAll;
	CStatic	m_staticPrompt;
	CButton	m_radioUseExisting;
	CButton	m_radioUseEmbedded;
	CButton	m_radioKeepBoth;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CDupeFileDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

public:
	CString		m_strPrompt;
	CString		m_strPromptUseExisting;
	CString		m_strPromptUseEmbedded;
	CString		m_strPromptKeepBoth;

	// Generated message map functions
	//{{AFX_MSG(CDupeFileDlg)
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	afx_msg void OnOKAll();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DUPEFILEDLG_H__96FC19CA_87EF_11D3_B473_00105A2796DE__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Shared\dmuspriv.h ===
/************************************************************************
*                                                                       *
*   dmuspriv.h -- This module defines the DirectMusic file formats       *
*                 used privately by DMUSProducer                        *
*   Copyright (c) 1998, Microsoft Corp. All rights reserved.            *
*                                                                       *
************************************************************************/

#ifndef DMUSPRIV_H
#define DMUSPRIV_H


typedef struct _DMUS_IO_BANKSELECT_ITEM
{
    BYTE    byLSB;
    BYTE    byMSB;
    BYTE    byPad[2];
} DMUS_IO_BANKSELECT_ITEM;


typedef struct _DMUS_IO_PATCH_ITEM
{
    MUSIC_TIME                  lTime;
    BYTE                        byStatus;
    BYTE                        byPChange;
    BYTE                        byMSB;
    BYTE                        byLSB;
    DWORD                       dwFlags;
    IDirectMusicCollection*     pIDMCollection;
    struct _DMUS_IO_PATCH_ITEM* pNext;  
} DMUS_IO_PATCH_ITEM;



#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Shared\GroupBitsPPG.cpp ===
/************************************************************************
*                                                                       *
*   Copyright (c) 1998-1999 Microsoft Corp. All rights reserved.        *
*                                                                       *
************************************************************************/

// GroupBitsPPG.cpp : implementation file
//

#include "stdafx.h"
#include "GroupBitsPPG.h"
#include "TrackFlagsPPG.h"
#pragma warning( push )
#pragma warning( disable : 4201 )
#include <dmusici.h>
#pragma warning( pop )
#include "resource.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

// {18E70D80-EA88-4224-8EA2-F336F24C053B}
const GUID GUID_GroupBitsPPGMgr = 
{ 0x18e70d80, 0xea88, 0x4224, { 0x8e, 0xa2, 0xf3, 0x36, 0xf2, 0x4c, 0x5, 0x3b } };

short CGroupBitsPropPageMgr::sm_nActiveTab = 0;
short* CGroupBitsPPG::sm_pnActiveTab = NULL;

/////////////////////////////////////////////////////////////////////////////
// CGroupBitsPropPageMgr property page

CGroupBitsPropPageMgr::CGroupBitsPropPageMgr()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	m_pGroupBitsPPG = NULL;
	m_pTrackFlagsPPG = NULL;
	m_GUIDManager = GUID_GroupBitsPPGMgr;
	CStaticPropPageManager::CStaticPropPageManager();
}

CGroupBitsPropPageMgr::~CGroupBitsPropPageMgr()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	if( m_pGroupBitsPPG )
	{
		delete m_pGroupBitsPPG;
		m_pGroupBitsPPG = NULL;
	}
	if( m_pTrackFlagsPPG )
	{
		delete m_pTrackFlagsPPG;
		m_pTrackFlagsPPG = NULL;
	}
	CStaticPropPageManager::~CStaticPropPageManager();
}

HRESULT CGroupBitsPropPageMgr::QueryInterface( REFIID riid, LPVOID *ppv )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	return CStaticPropPageManager::QueryInterface( riid, ppv );
}

HRESULT CGroupBitsPropPageMgr::GetPropertySheetTitle( BSTR* pbstrTitle, 
	BOOL* pfAddPropertiesText )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	if( (pbstrTitle == NULL)
	||  (pfAddPropertiesText == NULL) )
	{
		return E_POINTER;
	}

	*pfAddPropertiesText = TRUE;

	CString cstrPart;
	cstrPart.LoadString( IDS_PROPPAGE_GROUP_BITS );
	*pbstrTitle = cstrPart.AllocSysString();

	return S_OK;
}

HRESULT CGroupBitsPropPageMgr::GetPropertySheetPages( IDMUSProdPropSheet* pIPropSheet, 
	LONG* hPropSheetPage[], short* pnNbrPages )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	if( (hPropSheetPage == NULL)
	||  (pnNbrPages == NULL) )
	{
		return E_POINTER;
	}

	if( pIPropSheet == NULL )
	{
		return E_INVALIDARG;
	}

	m_pIPropSheet = pIPropSheet;
	m_pIPropSheet->AddRef();

	hPropSheetPage[0] = NULL;
	*pnNbrPages = 0;

	// Add Group bits tab
	HPROPSHEETPAGE hPage;
	short nNbrPages = 0;
	if( NULL == m_pGroupBitsPPG )
	{
		m_pGroupBitsPPG = new CGroupBitsPPG();
	}
	if( m_pGroupBitsPPG )
	{
		hPage = ::CreatePropertySheetPage( (LPCPROPSHEETPAGE)&m_pGroupBitsPPG->m_psp );
		if( hPage )
		{
			hPropSheetPage[nNbrPages] = (LONG *)hPage;
			nNbrPages++;
		}			

		// Weak reference
		m_pGroupBitsPPG->m_pIPropSheet = m_pIPropSheet;

		// Tell the property page to update the active tab setting
		CGroupBitsPPG::sm_pnActiveTab = &CGroupBitsPropPageMgr::sm_nActiveTab;
	}

	// Add track flags tab
	if( NULL == m_pTrackFlagsPPG )
	{
		m_pTrackFlagsPPG = new CTrackFlagsPPG();
	}
	if( m_pTrackFlagsPPG )
	{
		hPage = ::CreatePropertySheetPage( (LPCPROPSHEETPAGE)&m_pTrackFlagsPPG->m_psp );
		if( hPage )
		{
			hPropSheetPage[nNbrPages] = (LONG *)hPage;
			nNbrPages++;
		}			

		// Weak reference
		m_pTrackFlagsPPG->m_pIPropSheet = m_pIPropSheet;

		// Tell the property page to update the active tab setting
		CTrackFlagsPPG::sm_pnActiveTab = &CGroupBitsPropPageMgr::sm_nActiveTab;
	}

	// Set number of pages
	*pnNbrPages = nNbrPages;
	return S_OK;
}

HRESULT CGroupBitsPropPageMgr::RefreshData()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	if( m_pGroupBitsPPG )
	{
		m_pGroupBitsPPG->RefreshData();
	}
	if( m_pTrackFlagsPPG )
	{
		m_pTrackFlagsPPG->RefreshData();
	}
	return S_OK;
}

HRESULT CGroupBitsPropPageMgr::SetObject( IDMUSProdPropPageObject* pINewPropPageObject )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	if( m_pGroupBitsPPG )
	{
		m_pGroupBitsPPG->SetObject( pINewPropPageObject );
	}
	if( m_pTrackFlagsPPG )
	{
		m_pTrackFlagsPPG->SetObject( pINewPropPageObject );
	}
	return CBasePropPageManager::SetObject( pINewPropPageObject );
}

/////////////////////////////////////////////////////////////////////////////
// CGroupBitsPPG property page

IMPLEMENT_DYNCREATE(CGroupBitsPPG, CPropertyPage)

CGroupBitsPPG::CGroupBitsPPG() : CPropertyPage(CGroupBitsPPG::IDD)
{
	//{{AFX_DATA_INIT(CGroupBitsPPG)
	//}}AFX_DATA_INIT
	m_pPPO = NULL;
	m_pIPropSheet = NULL;
	m_fNeedToDetach = FALSE;
	m_PPGTrackParams.dwPageIndex = GROUPBITSPPG_INDEX;
	m_PPGTrackParams.dwGroupBits = 0;
	m_PPGTrackParams.dwPropPageFlags = 0;
}

CGroupBitsPPG::~CGroupBitsPPG()
{
	if( m_pPPO )
	{
		m_pPPO->Release();
		m_pPPO = NULL;
	}
}

void CGroupBitsPPG::DoDataExchange(CDataExchange* pDX)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CGroupBitsPPG)
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CGroupBitsPPG, CPropertyPage)
	//{{AFX_MSG_MAP(CGroupBitsPPG)
	ON_WM_CREATE()
	ON_WM_DESTROY()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

// private functions
void CGroupBitsPPG::SetObject( IDMUSProdPropPageObject* pPPO )
{
	if( m_pPPO )
	{
		m_pPPO->Release();
	}
	m_pPPO = pPPO;
	if( m_pPPO )
	{
		m_pPPO->AddRef();
	}
}

void CGroupBitsPPG::EnableControls( BOOL fEnable ) 
{
	if( ::IsWindow(m_hWnd) == FALSE )
	{
		return;
	}

	// Copy the fEnable flag to a private flag for setting the group bits checkboxes
	BOOL fGroupBitsEnable = fEnable;

	// If the read-only flag is set, set fGroupBitsEnable to FALSE
	if( m_PPGTrackParams.dwPropPageFlags & GROUPBITSPPG_GROUPBITS_RO )
	{
		fGroupBitsEnable = FALSE;
	}

	// Now, enable or disable the group bits checkboxes
	for( int i = IDC_CHECK_GROUP1 ;  i <= IDC_CHECK_GROUP32 ;  i++ )
	{
		EnableItem( i, fGroupBitsEnable );
	}
}

/////////////////////////////////////////////////////////////////////////////
// CGroupBitsPPG message handlers

int CGroupBitsPPG::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Attach the window to the property page structure.
	// This has been done once already in the main application
	// since the main application owns the property sheet.
	// It needs to be done here so that the window handle can
	// be found in the DLLs handle map.
	if( !FromHandlePermanent( m_hWnd ) )
	{
		HWND hWnd = m_hWnd;
		m_hWnd = NULL;
		Attach( hWnd );
		m_fNeedToDetach = TRUE;
	}

	if (CPropertyPage::OnCreate(lpCreateStruct) == -1)
		return -1;
	
	return 0;
}

void CGroupBitsPPG::OnDestroy() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Detach the window from the property page structure.
	// This will be done again by the main application since
	// it owns the property sheet.  It needs o be done here
	// so that the window handle can be removed from the
	// DLLs handle map.
	if( m_fNeedToDetach && m_hWnd )
	{
		HWND hWnd = m_hWnd;
		Detach();
		m_hWnd = hWnd;
	}

	CPropertyPage::OnDestroy();
}

BOOL CGroupBitsPPG::OnInitDialog() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	CPropertyPage::OnInitDialog();
	
	return FALSE;  // return TRUE unless you set the focus to a control
	               // EXCEPTION: OCX Property Pages should return FALSE
}

void CGroupBitsPPG::RefreshData( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_pPPO == NULL )
	{
		EnableControls( FALSE );
		return;
	}

	PPGTrackParams *pPPGTrackParams = &m_PPGTrackParams;
	if( FAILED( m_pPPO->GetData( (void**)&pPPGTrackParams ) ) )
	{
		EnableControls( FALSE );
		return;
	}

	// Make sure controls have been created
	if( ::IsWindow(m_hWnd) == FALSE )
	{
		return;
	}

	// Prevent control notifications from being dispatched during UpdateData
	_AFX_THREAD_STATE* pThreadState = AfxGetThreadState();
	HWND hWndOldLockout = pThreadState->m_hLockoutNotifyWindow;
	ASSERT(hWndOldLockout != m_hWnd);   // must not recurse
	pThreadState->m_hLockoutNotifyWindow = m_hWnd;

	EnableControls( TRUE );

	CWnd* pWnd;

	// Group Bits check boxes
	int nState;
	int j;

	for( int i = IDC_CHECK_GROUP1 ;  i <= IDC_CHECK_GROUP32 ;  i++ )
	{
		pWnd = GetDlgItem( i );
		if( pWnd )
		{
			j = i - IDC_CHECK_GROUP1;

			if( m_PPGTrackParams.dwGroupBits & (1 << j) )
			{
				nState = 1;
			}
			else
			{
				nState = 0;
			}

			CheckDlgButton( i, nState );
		}
	}

	pThreadState->m_hLockoutNotifyWindow = hWndOldLockout;

}

BOOL CGroupBitsPPG::OnSetActive() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	RefreshData();

	// Store active tab
	if( sm_pnActiveTab && m_pIPropSheet )
	{
		m_pIPropSheet->GetActivePage( sm_pnActiveTab );
	}

	return CPropertyPage::OnSetActive();
}

BOOL CGroupBitsPPG::OnCommand( WPARAM wParam, LPARAM lParam ) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	int nControlID = LOWORD( wParam );
	int nCommandID = HIWORD( wParam );

	if( nCommandID == BN_CLICKED
	||  nCommandID == BN_DOUBLECLICKED )
	{
		if( nControlID >= IDC_CHECK_GROUP1
		&&  nControlID <= IDC_CHECK_GROUP32 )
		{
			CWnd* pWnd = GetDlgItem( nControlID );
			if( pWnd )
			{
				int nVariation = nControlID - IDC_CHECK_GROUP1;

				switch( IsDlgButtonChecked( nControlID ) )
				{
					case 0:		// Currently unchecked
						CheckDlgButton( nControlID, 1 );
						m_PPGTrackParams.dwGroupBits |= (1 << nVariation);
						UpdatePPO();
						break;

					case 1:		// Currently checked
						{
							// Don't allow ourself to be removed from all groups
							DWORD dwNewGroupBits = m_PPGTrackParams.dwGroupBits & ~(1 << nVariation);
							if( dwNewGroupBits == 0 )
							{
								CheckDlgButton( nControlID, 1 );
							}
							else
							{
								CheckDlgButton( nControlID, 0 );
								m_PPGTrackParams.dwGroupBits = dwNewGroupBits;
								UpdatePPO();
							}
						}
						break;
				}
			}

			return TRUE;
		}
	}
	
	return CPropertyPage::OnCommand( wParam, lParam );
}

void CGroupBitsPPG::UpdatePPO()
{
	if( m_pPPO )
	{
		m_pPPO->SetData( (void *)&m_PPGTrackParams );
	}
}

void CGroupBitsPPG::EnableItem(int nItem, BOOL fEnable)
{
	CWnd* pWnd;
	pWnd = GetDlgItem(nItem);
	if (pWnd)
	{
		pWnd->EnableWindow(fEnable);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Shared\DupeFileDlg.cpp ===
// DupeFileDlg.cpp : implementation file
//

#include "stdafx.h"
#include "resource.h"
#include "DupeFileDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CDupeFileDlg dialog


CDupeFileDlg::CDupeFileDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CDupeFileDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CDupeFileDlg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}


void CDupeFileDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CDupeFileDlg)
	DDX_Control(pDX, IDC_OK_ALL, m_btnOKAll);
	DDX_Control(pDX, IDC_DUPE_PROMPT, m_staticPrompt);
	DDX_Control(pDX, IDC_USE_EXISTING, m_radioUseExisting);
	DDX_Control(pDX, IDC_USE_EMBEDDED, m_radioUseEmbedded);
	DDX_Control(pDX, IDC_KEEP_BOTH, m_radioKeepBoth);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CDupeFileDlg, CDialog)
	//{{AFX_MSG_MAP(CDupeFileDlg)
	ON_BN_CLICKED(IDC_OK_ALL, OnOKAll)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CDupeFileDlg message handlers

/////////////////////////////////////////////////////////////////////////////
// CDupeFileDlg::OnInitDialog

BOOL CDupeFileDlg::OnInitDialog() 
{
	CDialog::OnInitDialog();
	
	m_staticPrompt.SetWindowText( m_strPrompt );

	m_radioUseExisting.SetWindowText( m_strPromptUseExisting );
	m_radioUseEmbedded.SetWindowText( m_strPromptUseEmbedded );
	m_radioKeepBoth.SetWindowText( m_strPromptKeepBoth );

	m_radioUseExisting.SetCheck( 1 );
	m_radioUseEmbedded.SetCheck( 0 );
	m_radioKeepBoth.SetCheck( 0 );
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}


/////////////////////////////////////////////////////////////////////////////
// CDupeFileDlg::OnOK

void CDupeFileDlg::OnOK() 
{
	if( m_radioUseExisting.GetCheck() )
	{
		EndDialog( IDC_USE_EXISTING );
	}
	else if( m_radioUseEmbedded.GetCheck() )
	{
		EndDialog( IDC_USE_EMBEDDED );
	}
	else if( m_radioKeepBoth.GetCheck() )
	{
		EndDialog( IDC_KEEP_BOTH );
	}
	else
	{
		// Should not happen!
		ASSERT( 0 );
		CDialog::OnOK();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CDupeFileDlg::OnOKAll

void CDupeFileDlg::OnOKAll() 
{
	if( m_radioUseExisting.GetCheck() )
	{
		EndDialog( IDC_USE_EXISTING_ALL_FILES );
	}
	else if( m_radioUseEmbedded.GetCheck() )
	{
		EndDialog( IDC_USE_EMBEDDED_ALL_FILES );
	}
	else if( m_radioKeepBoth.GetCheck() )
	{
		EndDialog( IDC_KEEP_BOTH_ALL_FILES );
	}
	else
	{
		// Should not happen!
		ASSERT( 0 );
		CDialog::OnOK();
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Shared\GroupBitsPPGresource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by GroupBitsPPG.rc
//
#define IDC_CHECK_GROUP1                223
#define IDC_CHECK_GROUP2                224
#define IDC_CHECK_GROUP3                225
#define IDC_CHECK_GROUP4                226
#define IDC_CHECK_GROUP5                227
#define IDC_CHECK_GROUP6                228
#define IDC_CHECK_GROUP7                229
#define IDC_CHECK_GROUP8                230
#define IDC_CHECK_GROUP9                231
#define IDC_CHECK_GROUP10               232
#define IDC_CHECK_GROUP11               233
#define IDC_CHECK_GROUP12               234
#define IDC_CHECK_GROUP13               235
#define IDC_CHECK_GROUP14               236
#define IDC_CHECK_GROUP15               237
#define IDC_CHECK_GROUP16               238
#define IDC_CHECK_GROUP17               239
#define IDC_CHECK_GROUP18               240
#define IDC_CHECK_GROUP19               241
#define IDC_CHECK_GROUP20               242
#define IDC_CHECK_GROUP21               243
#define IDC_CHECK_GROUP22               244
#define IDC_CHECK_GROUP23               245
#define IDC_CHECK_GROUP24               246
#define IDC_CHECK_GROUP25               247
#define IDC_CHECK_GROUP26               248
#define IDC_CHECK_GROUP27               249
#define IDC_CHECK_GROUP28               250
#define IDC_CHECK_GROUP29               251
#define IDC_CHECK_GROUP30               252
#define IDC_CHECK_GROUP31               253
#define IDC_CHECK_GROUP32               254
#define IDC_CHECK_OVERRIDE_PLAY         255
#define IDC_CHECK_OVERRIDE_NOTIFICATION 256
#define IDC_CHECK_OVERRIDE_ALL          261
#define IDC_CHECK_OVERRIDE_PRIMARY      262
#define IDC_CHECK_FALLBACK              263
#define IDC_CHECK_ENABLE_PLAY           264
#define IDC_CHECK_ENABLE_CONTROL        265
#define IDC_CHECK_SEND_NOTIFICATIONS    266
#define IDC_CHECK_USE_CLOCKTIME         267
#define IDC_CHECK_RECOMPOSE_ON_PLAY     268
#define IDC_CHECK_RECOMPOSE_ON_LOOP     269
#define IDC_CHECK_AUDITION_ONLY         270
#define IDC_CHECK_TRANSITION            271
#define IDC_RADIO_TRANS_FROMSEGSTART    272
#define IDC_RADIO_TRANS_FROMSEGCURRENT  273
#define IDC_RADIO_TRANS_TOSEGSTART      274
#define IDD_PROPPAGE_GROUP_BITS         3242
#define IDD_PROPPAGE_TRACK_FLAGS        3243

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         275
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Shared\GuidDlg.cpp ===
// GuidDlg.cpp : implementation file
//

#include "stdafx.h"
#include "guiddlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CGuidDlg dialog


CGuidDlg::CGuidDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CGuidDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CGuidDlg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}


void CGuidDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CGuidDlg)
	DDX_Control(pDX, IDOK, m_btnOK);
	DDX_Control(pDX, IDC_EDIT_GUID, m_editGuid);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CGuidDlg, CDialog)
	//{{AFX_MSG_MAP(CGuidDlg)
	ON_BN_CLICKED(IDC_NEW_GUID, OnNewGuid)
	ON_EN_KILLFOCUS(IDC_EDIT_GUID, OnKillfocusEditGuid)
	ON_EN_UPDATE(IDC_EDIT_GUID, OnUpdateEditGuid)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CGuidDlg message handlers

BOOL CGuidDlg::OnInitDialog() 
{
	CDialog::OnInitDialog();

	LPOLESTR psz;
	if( SUCCEEDED( ::StringFromIID(m_guid, &psz) ) )
    {
		TCHAR szGuid[100];
		WideCharToMultiByte( CP_ACP, 0, psz, -1, szGuid, sizeof(szGuid), NULL, NULL );
		CoTaskMemFree( psz );

		m_editGuid.SetWindowText( szGuid );
	}
	
	memcpy( &m_guidOriginal, &m_guid, sizeof( GUID ) );

	m_btnOK.EnableWindow( FALSE );

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CGuidDlg::OnNewGuid() 
{
	if( SUCCEEDED( ::CoCreateGuid( &m_guid ) ) )
	{
		LPOLESTR psz;
		if( SUCCEEDED( ::StringFromIID(m_guid, &psz) ) )
		{
			TCHAR szGuid[100];
			WideCharToMultiByte( CP_ACP, 0, psz, -1, szGuid, sizeof(szGuid), NULL, NULL );
			CoTaskMemFree( psz );

			m_editGuid.SetWindowText( szGuid );

			m_btnOK.EnableWindow( TRUE );
		}
	}
}

void CGuidDlg::OnKillfocusEditGuid() 
{
}

void CGuidDlg::OnCancel() 
{
	memcpy( &m_guid, &m_guidOriginal, sizeof( GUID ) );
	
	CDialog::OnCancel();
}

void CGuidDlg::OnOK() 
{
	CString strText;
	m_editGuid.GetWindowText( strText );

	WCHAR szWChar[100];
	ZeroMemory( szWChar, 100 * sizeof( WCHAR ) );
	::MultiByteToWideChar( CP_ACP, 0, strText, -1, szWChar, 100 );
	if( SUCCEEDED( ::IIDFromString( szWChar, &m_guid ) ) )
	{
		CDialog::OnOK();
	}
#ifdef _DEBUG
	else
	{
		TRACE("CGuidDlg::OnOK: Edit box doesn't contain a valid GUID.\n");
		ASSERT( FALSE );
	}
#endif
}

void CGuidDlg::OnUpdateEditGuid() 
{
	CString strText;
	m_editGuid.GetWindowText( strText );

	GUID guid;

	WCHAR szWChar[100];
	HRESULT hr;
	hr = ::MultiByteToWideChar( CP_ACP, 0, strText, -1, szWChar, 100 );
	hr = ::IIDFromString( szWChar, &guid );
	if( SUCCEEDED( hr ) )
	{
		if( memcmp( &guid, &m_guidOriginal, sizeof(GUID) ) != 0 )
		{
			m_btnOK.EnableWindow( TRUE );
		}
		else
		{
			m_btnOK.EnableWindow( FALSE );
		}
	}
	else
	{
		m_btnOK.EnableWindow( FALSE );
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Shared\LockoutNotification.h ===
/************************************************************************
*                                                                       *
*   Copyright (c) 1998-1999 Microsoft Corp. All rights reserved.        *
*                                                                       *
************************************************************************/

#if !defined(AFX_LOCKOUTNOTIFICATION_H__8B971CDC_E747_11D0_BC07_00A0C922E6EB__INCLUDED_)
#define AFX_LOCKOUTNOTIFICATION_H__8B971CDC_E747_11D0_BC07_00A0C922E6EB__INCLUDED_

// CLockoutNotification class

class CLockoutNotification
{
public:
	CLockoutNotification( HWND hWnd)
	{
		// prevent control notifications from being dispatched
		m_pThreadState = AfxGetThreadState();
		m_hWndOldLockout = m_pThreadState->m_hLockoutNotifyWindow;
		m_fReset = FALSE;
		if( m_hWndOldLockout != hWnd )
		{
			m_fReset = TRUE;
			m_pThreadState->m_hLockoutNotifyWindow = hWnd;
		}
	}
	~CLockoutNotification()
	{
		// Reinstate control notifications
		if( m_fReset )
		{
			m_pThreadState->m_hLockoutNotifyWindow = m_hWndOldLockout;
		}
	}

	BOOL				m_fReset;
	_AFX_THREAD_STATE*	m_pThreadState;
	HWND				m_hWndOldLockout;

};

#endif // !defined(AFX_LOCKOUTNOTIFICATION_H__8B971CDC_E747_11D0_BC07_00A0C922E6EB__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Shared\Info.h ===
//////////////////////////////////////////////////////////////////////
//
//	Info.h
//
//////////////////////////////////////////////////////////////////////

#ifndef _INC_INFO
#define _INC_INFO

#include "riffstrm.h"
#include "UnknownChunk.h"

class CInfo
{
public:
	friend class CCollectionPropPg;
    friend class CInstrumentPropPg;
    friend class CWaveInfoPropPg;
	friend class CInstrument;
	friend class CStereoWave;
	friend class CMonoWave;

	void Load(IDMUSProdRIFFStream* pIRiffStream, MMCKINFO* pckMain);
    DWORD Save(IDMUSProdRIFFStream* pIRiffStream);

	bool Load(IStream* pIStream);
	bool Save(IStream* pIStream);
public:
	CString m_csName;

private:	
	void Alloc_and_Read(CString& csDest, IStream* pIStream, MMCKINFO* pck);
    CString m_csCopyright;
    CString m_csSoftware; 
    CString m_csSubject;
    CString m_csDate;
    CString m_csEngineer;
    CString m_csProduct;
    CString m_csComment;

    CUnknownChunk   m_UnknownChunk;
};

#endif // _INC_INFO
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Shared\InvertVector.cpp ===
#include <stdafx.h>
#include "InvertVector.h"

void InvertVector::FindBitPos()
{
	int i;
	int nextinversion = 0;
	highestChordMember = -1;
	for(i = 0; i < MAX_INVERT+1; i++)
	{
		ChordMemberBitPos[i] = -1;
	}
	for(i = 0; i < 24 && nextinversion < MAX_INVERT+1; i++)
	{
		if(ulChord & (1 << i))
		{
			ChordMemberBitPos[nextinversion++] = i;
			++highestChordMember;
		}
	}
}

void InvertVector::ComputeDisallowedMasks()
{
	FindBitPos();
	for(int i = 0; i < highestChordMember; i++)
	{
		DisallowedMasks[i] = 0x00000FFF;
		for(int j = ChordMemberBitPos[i]; j <= ChordMemberBitPos[i+1]; j++)
		{
			DisallowedMasks[i] &= ~(1 << j);
		}
		unsigned long tmpmask = DisallowedMasks[i] << 12;
		DisallowedMasks[i] |= tmpmask;
	}
}


InvertVector::InvertVector(unsigned long chord, unsigned long invert)
: ulInvert(invert), ulChord(chord)
{
	ComputeDisallowedMasks();
}

void InvertVector::SetAllowedInversion(int inversion, bool allowed)
{
	// assumes that InvertBitPos, bAllowed, ulChord, and ulInvert set
	// changes ulInvert and bAllowed to conform to other settings
//	ASSERT(inversion > - 1 && inversion < highestChordMember);
	if(inversion < 0 || inversion >= highestChordMember)
	{
		return;
	}
	else if(ChordMemberBitPos[inversion] < 0 || ChordMemberBitPos[inversion+1] < 0)
	{
		return;
	}
	if(allowed)
	{
		bool Allowed[3];
		int i;
		for(i = 0; i < highestChordMember; i++)
		{
			if(i == inversion)
			{
				Allowed[i] = true;;
			}
			else
			{
				Allowed[i] = GetAllowedInversion(i);
			}
		}
		ulInvert = 0xFFFFFF;
		for(i = 0; i < highestChordMember; i++)
		{
			if(!Allowed[i])
				ulInvert &= DisallowedMasks[i];
		}
	}
	else
	{
		ulInvert &= DisallowedMasks[inversion];
	}
}

void InvertVector::SetChord(unsigned long chord)
{
	// need to preserve allowed inversion info
	bool Allowed[3] = {false, false, false};
	int i;
	for(i = 0; i < highestChordMember; i++)
	{
		Allowed[i] = GetAllowedInversion(i);
	}

	ulChord = chord;
	// now recompute masks and set invert vector according to perserved inversion info
	ComputeDisallowedMasks();
	ulInvert = 0xFFFFFF;
	for(i = 0; i < highestChordMember; i++)
	{
		if(!Allowed[i])
		{
			ulInvert &= DisallowedMasks[i];
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Shared\Info.cpp ===
//////////////////////////////////////////////////////////////////////
//
//	Info.cpp
//
//////////////////////////////////////////////////////////////////////
#include "stdafx.h"
#include "info.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//////////////////////////////////////////////////////////////////////
//
// CInfo::Load
//
//////////////////////////////////////////////////////////////////////
void CInfo::Load(IDMUSProdRIFFStream* pIRiffStream, MMCKINFO* pckMain)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	
	IStream* pIStream;
    MMCKINFO ck;
	
	pIStream = pIRiffStream->GetStream();
	
	ck.ckid = 0;
	ck.fccType = 0;
    
	while(pIRiffStream->Descend(&ck, pckMain, 0) == 0)
	{
		
		switch(ck.ckid) 
		{
			case mmioFOURCC('I','C','O','P'):
				Alloc_and_Read(m_csCopyright, pIStream, &ck);
				break;

			case mmioFOURCC('I','S','F','T'):
				Alloc_and_Read(m_csSoftware, pIStream, &ck);
				break;
		
			case mmioFOURCC('I','N','A','M'):
				Alloc_and_Read(m_csName, pIStream, &ck);
				break;
		
			case mmioFOURCC('I','C','R','D'):
				Alloc_and_Read(m_csDate, pIStream, &ck);
				break;
			
			case mmioFOURCC('I','E','N','G'):
				Alloc_and_Read(m_csEngineer, pIStream, &ck);
				break;
		
			case mmioFOURCC('I','P','R','D'):
				Alloc_and_Read(m_csName, pIStream, &ck);
				break;
		
			case mmioFOURCC('I','C','M','T'):
				Alloc_and_Read(m_csComment, pIStream, &ck);
				break;
		
			case mmioFOURCC('I','S','B','J'):
				Alloc_and_Read(m_csSubject, pIStream, &ck);
				break;

            default: // we don't know what this is - just copy the data.
                m_UnknownChunk.Load(pIRiffStream, &ck, FALSE);
                break;
		}

        pIRiffStream->Ascend(&ck, 0);
		
		ck.ckid = 0;
		ck.fccType = 0;
	}
	pIStream->Release();
}

//////////////////////////////////////////////////////////////////////
//
//	SaveString
//
//////////////////////////////////////////////////////////////////////
static DWORD SaveString(DWORD dwID, IDMUSProdRIFFStream* pIRiffStream, CString csString)
{
	HRESULT hr = S_OK; // Return code
	MMCKINFO ck;
	DWORD cb;
    
	ck.ckid = dwID;
	
	IStream *pIStream = pIRiffStream->GetStream();
    
	hr = pIRiffStream->CreateChunk(&ck, 0);
    if(FAILED(hr))
    {
		pIStream->Release();
        return (hr);
    }
    
	hr = pIStream->Write((LPCTSTR) csString, csString.GetLength()+1, &cb);
    if(FAILED(hr))
    {
		pIStream->Release();
        return (hr);
    }
    
	if(FAILED(pIRiffStream->Ascend(&ck, 0)))
    {
		pIStream->Release();
        return (E_FAIL);
    }
	
	pIStream->Release();
    return (hr);
}

//////////////////////////////////////////////////////////////////////
//
//	CInfo::Save
//
//////////////////////////////////////////////////////////////////////
DWORD CInfo::Save(IDMUSProdRIFFStream* pIRiffStream)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	
	HRESULT hr = S_OK; // Return code
	MMCKINFO ck;
	
	IStream* pIStream = pIRiffStream->GetStream();
    
	ck.fccType = mmioFOURCC('I','N','F','O') ;
    
	hr = pIRiffStream->CreateChunk(&ck, MMIO_CREATELIST);
    
	if (FAILED(hr))
    {
		pIStream->Release();
        return (hr);
    }

    SaveString(mmioFOURCC('I','C','M','T'), pIRiffStream, m_csComment);
    
    SaveString(mmioFOURCC('I','C','O','P'), pIRiffStream, m_csCopyright);

    if(!m_csDate.IsEmpty())
    {
        SaveString(mmioFOURCC('D','A','T','E'), pIRiffStream, m_csDate);
    }

    SaveString(mmioFOURCC('I','E','N','G'), pIRiffStream, m_csEngineer);

    if(!m_csName.IsEmpty())
    {
        SaveString(mmioFOURCC('I','N','A','M'), pIRiffStream, m_csName);
    }

    if(!m_csProduct.IsEmpty())
    {
        SaveString(mmioFOURCC('I','P','R','D'), pIRiffStream, m_csProduct);
    }

    if(!m_csSoftware.IsEmpty())
    {
        SaveString(mmioFOURCC('I','S','F','T'), pIRiffStream, m_csSoftware);
    }

    SaveString(mmioFOURCC('I','S','B','J'), pIRiffStream, m_csSubject);

    //save unknown chunks
    m_UnknownChunk.Save(pIRiffStream);

    pIRiffStream->Ascend(&ck, 0);
	pIStream->Release();
    
	return (hr);
}

bool CInfo::Load(IStream* pIStream)
{
	return true;
}

bool CInfo::Save(IStream* pIStream)
{
	return true;
}

void CInfo::Alloc_and_Read(CString & csDest,IStream* pIStream, MMCKINFO* pck)
{
	DWORD cb;
	void* pstring = NULL;

	pstring = new char[pck->cksize];
	if (pstring)
	{
		pIStream->Read(pstring, pck->cksize, &cb);
		csDest = (char*) pstring;
		delete pstring;
	}
	else
	{
		return;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Shared\InvertVector.h ===
#ifndef INVERTVECTOR_H
#define INVERTVECTOR_H

/*

  The purpose of this object is to assist in applying intelligent voice leading. Given a pattern and
  a chord, the user can determine which chord inversions are allowed when transposing portions of a
  pattern that extend beyond an upper or lower (MIDI note) boundary.  For this to work, the pattern
  must be in root position and all voices within one octave.

  This algorithm uses two DWORD bitmasks.  The Chord position bit mask is used to determine where
  the root first, second, and third inversions are.  This mask is used for internal computations.
  The inversion mask is the resulting mask used by DirectMusic to determine which transpositions
  are allowed.  The input to the algorithm is the chord position bit mask, the output

  The chord position bitmask is defined as follows

  Root of chord = position of 1st bit in pattern whose value is 1.  This is always bit 0 of the chord mask.
  Third of chord = position of 2nd bit in pattern whose value is 1
  Fifth of chord = position of 3rd bit in pattern whose value is 1
  Seventh of chord = position of 4th bit in pattern whose value is 1

  Inversions can be characterized by chord functions

  Root position = original chord pattern: from top to bottom: root, 3rd, 5th, optional 7th
  1st Inversion = 3rd is lowest note
  2nd Inversion = 5th is lowest note
  3rd Inversion = 7th is bass note

  Example:

  CM7 = 0x891 = 0100 1001 0001
  Cm7 = 0x489 = 0100 1000 1001

  The default inversion mask is 0x00000000.  This blocks all inversions, i.e., the pattern is not transposed.
  To block a single inversion, we want to keep the note defining the inversion out of the bass.  For example,
  to block a first inversion chord, we must keep the third from being the lowest tone.  This will be the
  case if we force the root always to be below the third.  Thus when transposing either the root and third must
  be transposed as a pair or must remain in place.

  This can be extended to block multiple inversions.  For example to block the second and third inversions and allow 
  the first,   we must force the third and fifth to stay together (blocking the second inversion) and the fifth and 
  seventh together (blocking the third inversion).  To block all three inversions, we force the root and third to
  stay together (1st inversion), the third and fifth to stay together (2nd inversion) and the fifth and seventh
  to stay together( 3rd inversion).  We thus get a the following schema for blocking inversions:

  Inversion to block	Notes to keep together
  ------------------	----------------------
  1st inversion			root and third
  2nd inversion			third and fifth
  3rd inversion			fifth and seventh

  Now we need to discuss how direct music computes where to invert.  Given an upper and lower boundary (specified as
  MIDI notes in the pattern editor) and a note in the pattern outside one of those boundaries, it maps the boundary
  to the corresponding position in the inversion mask and scans up from the lower boundary or down from the upper
  boundary till it either hits a "1" in the inversion or the offending note.  If the former, inversion is allowed,
  otherwise it is blocked.

  The chord position mask is used to determine where the positions are in the given chord.  Thus to block a certain
  inversion, we determine the notes to keep together and set all the bit positions in between them to 0's.  The
  zero'd bits include the lower member (eg root in the first inversion case), but not the upper member (this is to
  satisfy some differences in the scan directions).  A complete table of masks for blocking inversions in a Cm7
  chord (0x489 = 0100 1000 1001) follows (masks are shown for one octave only.  In practise they are doubled
  at the octave and the upper 8 bits are set to zero

  Inversion to block		Notes to keep together			inversion mask
  ------------------		----------------------			--------------
  1st						Root and third					1111 1111 0000
  2nd						third and fifth					1111 1000 1111
  3rd						fifth and seventh				1100 0111 1111
  
  An inversion is disallowed if the bits in its pattern between its bass note and the next lower chord member are zero
  inclusive at the bottom, exclusive at the top.  Let ChordMember(n) return the bit position of the nth chord member.  Thus
  ChordMember(0) returns the root, ChordMember(1) returns the third, and so on.  Then the nth inversion, n > 0, is disallowed
  if

  Bitpos(m) == 0 for ChordMember(n-1)<= m < ChordMember(n)

  Using the above example,	0100 1001 0001

  Disallow 1st Inversion:	1111 1111 0000
  Disallow 2nd Inversion:  1111 1000 1111
  Disallow 3rd Inversion:  1100 0111 1111

  Inversion Arithmetic:

  Inversions disallows can be combined by anding them:

  Disallow 1st and 3rd Inversion: 1100 0111 0000 == 1111 1111 0000 & 1100 0111 1111

  Inversions can be reallowed by or'ing in the complement of the disallowal mask.  For example we can reallow 3rd inversion in
  1100 0111 0000, by oring in 0011 1000 0000

  Given the bit positions of the chord members, a disallowal mask for the nth inversion can be computed as follows:

	DWORD mask = 0xFFFFFFFF;
	for(int i = ChordMember(n-1); i < ChordMember(n); i++)
	{
		mask &= ~(1 << i);
	}

  Given an inversion vector, and assuming disallowal masks have been computed, an inversion, N,  is disallowed if

	(1 << ChordMember(N-1)+1) & DisallowalMask[N] = 0;

  Where DisallowalMask[N] is the disallowal mask for the Nth inversion.  Note the disallowed condition in the inversion vector
  is weaker than the mask, this is because inversion patterns also apply to scales.


*/

#ifdef TESTIT
#include <stdio.h>
#endif

class InvertVector
{
public:
	enum { MAX_INVERT = 3, ALL = -1 };
private:
	unsigned long	ulInvert;
	unsigned long	ulChord;
	int	ChordMemberBitPos[MAX_INVERT+1];
	unsigned long DisallowedMasks[MAX_INVERT];
	int highestChordMember;
public:
	InvertVector(unsigned long chord = 0x91, unsigned long invert = 0xFFFFFFFF);
	int MaxInversions() { return highestChordMember; }
	unsigned long GetInvertPattern() const
	{
		return ulInvert;
	}
	unsigned long GetChordPattern() const
	{
		return ulChord;
	}
	void SetInversion(unsigned long inversion)
	{
		ulInvert = inversion;
	}
	void SetChord(unsigned long chord);
	void SetAllowedInversion(int inversion, bool allowed);
	bool GetAllowedInversion(int inversion) const
	{
		if(inversion < 0 || inversion >= highestChordMember)
			return false;
		return (ulInvert & (1 << (ChordMemberBitPos[inversion] + 1))) != 0;
	}
#ifdef TESTIT
	const char* Dump()
	{
		static char buf[200];
		sprintf(buf, "chord: %x\t invert: %x\n", ulChord, ulInvert);
		return buf;
	}
#endif
private:
	void FindBitPos();
	void ComputeDisallowedMasks();
};



#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Shared\Keyboard.cpp ===
// Keyboard.cpp : implementation file
//
#include "stdafx.h"

#include "Keyboard.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


KeyInfo::KeyInfo()

{
	m_nState = 0;
	m_fRootKey = FALSE;
}

void KeyInfo::SetState(short nState)

{
	m_nState = nState;
	switch (nState)
	{
	case 0:
		if (m_fBlackKey)
		{
			m_Color = RGB( 0,0,0 );
		}
		else if(m_fRootKey)
		{
			m_Color = RGB( 0xFF,0xFF,0xC0 );
		}
		else
		{
			m_Color = RGB( 0xFF,0xFF,0xFF );
		}
		break;
	case 1 :
		m_Color = RGB( 0,0,0xFF );
		break;
	case 2 :
		m_Color = RGB( 0xFF,0,0 );
		break;
	case 3 :
		m_Color = RGB( 0xFF,0,0xFF );
		break;
	case 4 :
		if (m_fBlackKey)
		{
			m_Color = RGB( 0x20,0x20,0x20 );
		}
		else
		{
			m_Color = RGB( 0xE0,0xE0,0xE0 );
		}
		break;
	case 5 :
		m_Color = RGB( 0x80,0x80,0x80 );
		break;
	case 6 :
		m_Color = RGB( 0x40,0x40,0x40 );
		break;
	case 7 :
		m_Color = RGB( 0xC0,0xC0,0xC0 );
		break;
	default :
		m_Color = RGB( nState, nState, nState );
		break;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CKeyboard

CKeyboard::CKeyboard()
{
	static BOOL fBlackKey[Size] = { 
		FALSE, TRUE, FALSE, TRUE, FALSE, FALSE, TRUE, FALSE, TRUE, FALSE, TRUE, FALSE,
		FALSE, TRUE, FALSE, TRUE, FALSE, FALSE, TRUE, FALSE, TRUE, FALSE, TRUE, FALSE,
		FALSE, TRUE, FALSE, TRUE, FALSE, FALSE, TRUE, FALSE, TRUE, FALSE, TRUE, FALSE,
		FALSE, TRUE, FALSE, TRUE, FALSE, FALSE, TRUE, FALSE, TRUE, FALSE, TRUE, FALSE
	};
	int nX;
	for (nX = 0; nX < Size; nX++)
	{
		m_Keys[nX].m_fBlackKey = fBlackKey[nX];
		m_Keys[nX].SetState(0);
		if(nX % 12 == 0)
		{
			m_Keys[nX].m_csName.Format("%d", (nX/12) + 1);
		}
	}
	m_lowerbound = 0;
	m_transpose = 0;
	m_pfnLButtonDown = 0;
	m_pHintLButtonDown = 0;
	m_pfnRButtonDown = 0;
	m_pHintRButtonDown = 0;
	m_pfnLButtonUp = 0;
	m_pHintLButtonUp = 0;
	m_visible = 24;
	m_nRootKeys = 0;
}

CKeyboard::~CKeyboard()
{
}


BEGIN_MESSAGE_MAP(CKeyboard, CButton)
	//{{AFX_MSG_MAP(CKeyboard)
	ON_WM_LBUTTONDOWN()
	ON_WM_LBUTTONUP()
	ON_WM_RBUTTONDOWN()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


void CKeyboard::DrawKeyboard(CDC* pDC)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	int nX;
	CBrush Frame;
	Frame.CreateSolidBrush( 0 );
	for (nX = m_lowerbound; nX < m_lowerbound+m_visible; nX++)
	{
		if (!m_Keys[nX].m_fBlackKey)
		{
			CBrush Color;
			Color.CreateSolidBrush( m_Keys[nX].m_Color );
			pDC->FillRect(m_Keys[nX].m_crDrawRect,&Color);
			pDC->FrameRect(m_Keys[nX].m_crDrawRect,&Frame);
		}
	}
	for (nX = m_lowerbound; nX < m_lowerbound + m_visible; nX++)
	{
		if (m_Keys[nX].m_fBlackKey)
		{
			CBrush Color;
			Color.CreateSolidBrush( m_Keys[nX].m_Color );
			pDC->FillRect(m_Keys[nX].m_crDrawRect,&Color);
//			pDC->FillSolidRect(m_Keys[nX].m_crDrawRect,m_Keys[nX].m_Color);
			pDC->FrameRect(m_Keys[nX].m_crDrawRect,&Frame);
		}
	}
	CFont font;
	CFont *oldfont;
	if (font.CreateFont(10,0,0,0,0,0,0,0,0,0,0,0,0,0))
	{
		int oldmode = pDC->SetBkMode(TRANSPARENT);
		COLORREF oldcolor = pDC->GetTextColor();
		oldfont = pDC->SelectObject(&font);
		for (nX=m_lowerbound; nX < m_lowerbound+m_visible;nX++)
		{
			char string[30];
			if(nX % 12 == 0 && m_Keys[nX].m_csName.IsEmpty())
			{
				m_Keys[nX].m_csName.Format("%d", (nX/12) + 1);
			}
			if (!m_Keys[nX].m_csName.IsEmpty())
			{
				strcpy(string,m_Keys[nX].m_csName);
				string[3] = 0;
				if (m_Keys[nX].m_fBlackKey)
				{
					pDC->SetTextColor(RGB(0xFF,0xFF,0xFF));
				}
				else
				{
					pDC->SetTextColor(RGB(0,0,0));
				}
				pDC->ExtTextOut(m_Keys[nX].m_crDrawRect.TopLeft().x,
					m_Keys[nX].m_crDrawRect.BottomRight().y - 14,
					ETO_CLIPPED,
					m_Keys[nX].m_crDrawRect,
					m_Keys[nX].m_csName, NULL);
			}
		} 
		pDC->SelectObject(oldfont); 
		pDC->SetBkMode(oldmode);
		pDC->SetTextColor(oldcolor);
	} 
}

void CKeyboard::SetNewSize(const CRect& crNewRect)

{
	int nX;
	double dKeyWidth = crNewRect.Width();
	double widthDivisor = 7.*(m_visible/12.);	// heuristic: 7 for each octave
	dKeyWidth /= widthDivisor;
	double dLeft = crNewRect.TopLeft().x;
	int dBlackHeight = crNewRect.Height() * 6;
	dBlackHeight /= 10;
	int nBlackWidth = (int) dKeyWidth * 2 + 2;
	nBlackWidth /= 3;
	for (nX = m_lowerbound; nX < m_lowerbound+m_visible; nX++)
	{
		if (m_Keys[nX].m_fBlackKey)
		{
			if(m_lowerbound < nX && nX < m_lowerbound + m_visible - 1)
			{
				m_Keys[nX].m_crDrawRect.SetRect(
						(int) (dLeft - dKeyWidth) + nBlackWidth,
						crNewRect.TopLeft().y,
						(int) (dLeft - dKeyWidth) + nBlackWidth + nBlackWidth,
						crNewRect.TopLeft().y + dBlackHeight);
			}
			else if(nX == m_lowerbound)
			{
				// make sure we don't paint over the edges of controls
				m_Keys[nX].m_crDrawRect.SetRect(
						(int) (dLeft - dKeyWidth + nBlackWidth/2) + nBlackWidth,
						crNewRect.TopLeft().y,
						(int) (dLeft - dKeyWidth) + nBlackWidth + nBlackWidth,
						crNewRect.TopLeft().y + dBlackHeight);
			}
			else
			{
				// make sure we don't paint over the edges of controls
				m_Keys[nX].m_crDrawRect.SetRect(
						(int) (dLeft - dKeyWidth) + nBlackWidth,
						crNewRect.TopLeft().y,
						(int) (dLeft - dKeyWidth) + nBlackWidth + nBlackWidth/2,
						crNewRect.TopLeft().y + dBlackHeight);
			}
		}
		else
		{
			m_Keys[nX].m_crDrawRect.SetRect(
				(int) dLeft,
				crNewRect.TopLeft().y,
				(int) (dLeft+dKeyWidth),
				crNewRect.BottomRight().y);
			dLeft += dKeyWidth; 
		}
	}
}

void CKeyboard::SetNoteState(short nKey, LPCTSTR pszName, short nState) 
{
	nKey = static_cast<short>(nKey + m_transpose);
	if ((nKey < Size) && (nKey >= 0))
	{
		m_Keys[nKey].m_csName = pszName;
		m_Keys[nKey].SetState(nState);
		Invalidate(FALSE);
//		CClientDC dc(this);
//		DrawKeyboard(&dc);
	}
}

void CKeyboard::OnLButtonDown(UINT nFlags, CPoint point) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	short nX = static_cast<short>(FindKey(point));
//	ASSERT(0<= (nX-m_transpose) && (nX-m_transpose) <= m_visible);
	TRACE("Mouse down on %d\n", nX);
	if(m_pfnLButtonDown)
	{
		m_pfnLButtonDown(this, m_pHintLButtonDown, nX);
	}
	CButton::OnLButtonDown(nFlags, point);
}

void CKeyboard::OnLButtonUp(UINT nFlags, CPoint point) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	short nX = static_cast<short>(FindKey(point));
	TRACE("Mouse up on %d\n", nX);
	if(m_pfnLButtonUp)
	{
		m_pfnLButtonUp(this, m_pHintLButtonUp, nX);
	}
	CButton::OnLButtonUp(nFlags, point);
}

int CKeyboard::FindKey(CPoint point)

{
	int nX;
	for (nX = m_lowerbound; nX < m_visible + m_lowerbound; nX++)
	{
		if (m_Keys[nX].m_fBlackKey)
		{
			if (m_Keys[nX].m_crDrawRect.PtInRect(point))
				return nX;
		}
	}
	for (nX = m_lowerbound; nX < m_visible + m_lowerbound; nX++)
	{
		if (!m_Keys[nX].m_fBlackKey)
		{
			if (m_Keys[nX].m_crDrawRect.PtInRect(point))
				return nX;
		}
	}
	return -1;
}

void CKeyboard::DrawItem(LPDRAWITEMSTRUCT lpDrawItemStruct) 
{
//	CPaintDC dc(this); // device context for painting
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	CDC* pDC = CDC::FromHandle(lpDrawItemStruct->hDC);
	CRect rect(lpDrawItemStruct->rcItem);
	m_crBoundRect = rect;
	SetNewSize(m_crBoundRect);
	DrawKeyboard(pDC);
	
}

void CKeyboard::ClearKeys()
{
	for(int i = 0; i < Size; i++)
	{
		SetNoteState(static_cast<short>(i), "", 0);
	}
}

BOOL CKeyboard::OnCommand(WPARAM wParam, LPARAM lParam) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	
	return CButton::OnCommand(wParam, lParam);
}

void CKeyboard::OnRButtonDown(UINT nFlags, CPoint point) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	short nX = static_cast<short>(FindKey(point));
	TRACE("RightMouse(%d,%d) down on %d\n", point.x, point.y, nX);
	if(m_pfnRButtonDown)
	{
		m_pfnRButtonDown(this, m_pHintRButtonDown, nX, point);
	}
	CButton::OnRButtonDown(nFlags, point);
}

void CKeyboard::SetRootKeys(short n)
{
	m_nRootKeys = n;
	for(short i = 0; i < Size; i++)
	{
		if(i < m_nRootKeys)
		{
			m_Keys[i].m_fRootKey = TRUE;
		}
		else
		{
			m_Keys[i].m_fRootKey = FALSE;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Shared\MusicTimeConverter.h ===
/************************************************************************
*                                                                       *
*   Copyright (c) 1998-1999 Microsoft Corp. All rights reserved.        *
*                                                                       *
************************************************************************/

#ifndef MusicTimeConverter_H
#define MusicTimeConverter_H

#include "timeline.h"
#include "dmusici.h"

#define PPQ DMUS_PPQ

#define NOTE_CLOCKS(note, ppq) ( (ppq)*4 /(note) )



// draw helper function
inline long LeftMargin(IDMUSProdTimeline* pTimeline)
{
	long lClocks, lPosition;
	pTimeline->GetMarkerTime(MARKER_LEFTDISPLAY, TIMETYPE_CLOCKS, &lClocks);
	pTimeline->ClocksToPosition(lClocks, &lPosition);
	return --lPosition;
}



class CMusicTimeConverter
// conversions as functions of timesig, measure, beat, 
{
	long	m_lTime;
public:
	CMusicTimeConverter()
	{
		m_lTime = 0;
	}
	CMusicTimeConverter(long time) : m_lTime(time)
	{
	}
	CMusicTimeConverter(long lMeasure, long lBeat, IDMUSProdTimeline* pTimeline, DWORD dwGroupBits, DWORD dwIndex=0)
	{
		SetTime( lMeasure, lBeat, pTimeline, dwGroupBits, dwIndex );
	}
	CMusicTimeConverter(long lPosition,IDMUSProdTimeline* pTimeline, DWORD dwGroupBits, DWORD dwIndex=0)
	{
		SetTimeUsingPosition( lPosition, pTimeline, dwGroupBits, dwIndex );
	}
	CMusicTimeConverter(const CMusicTimeConverter& cmt)
	{
		m_lTime = cmt.m_lTime;
	}
	CMusicTimeConverter& operator=(const CMusicTimeConverter& cmt)
	{
		m_lTime = cmt.m_lTime;
		return *this;
	}
	HRESULT GetMeasure(long& lMeasure, IDMUSProdTimeline* pTimeline, DWORD dwGroupBits, DWORD dwIndex=0)
	{
		ASSERT(pTimeline);
		if(pTimeline == NULL)
		{
			return E_POINTER;
		}
		HRESULT hr = pTimeline->ClocksToMeasureBeat(dwGroupBits, dwIndex, m_lTime, &lMeasure, NULL);
		ASSERT(hr == S_OK);
		return hr;
	}
	HRESULT GetBeat(long& lBeat, IDMUSProdTimeline* pTimeline, DWORD dwGroupBits, DWORD dwIndex=0)
	{
		ASSERT(pTimeline);
		if(pTimeline == NULL)
		{
			return E_POINTER;
		}
		HRESULT hr = pTimeline->ClocksToMeasureBeat(dwGroupBits, dwIndex, m_lTime, NULL, &lBeat);
		ASSERT(hr == S_OK);
		return hr;
	}
	HRESULT GetMeasureBeat(long& lMeasure, long& lBeat, IDMUSProdTimeline* pTimeline, DWORD dwGroupBits, DWORD dwIndex=0)
	{
		ASSERT(pTimeline);
		if(pTimeline == NULL)
		{
			return E_POINTER;
		}
		HRESULT hr = pTimeline->ClocksToMeasureBeat(dwGroupBits, dwIndex, m_lTime, &lMeasure, &lBeat);
		ASSERT(hr == S_OK);
		return hr;
	}
	HRESULT GetMeasureBeat(long& lMeasureReturn, long& lBeatReturn, long lBeatsPerMeasure, long lBeat)
	{
		lBeatReturn = (m_lTime * lBeat) / (4 * PPQ);
		lMeasureReturn = lBeatReturn / lBeatsPerMeasure;
		lBeatReturn = lBeatReturn % lBeatsPerMeasure;
		return S_OK;
	}
	HRESULT GetTimeSig(DMUS_TIMESIGNATURE& dmTimeSig, IDMUSProdTimeline* pTimeline, 
						DWORD dwGroupBits, DWORD dwIndex=0)
	{
		ASSERT(pTimeline);
		if(pTimeline == NULL)
		{
			return E_POINTER;
		}
		return pTimeline->GetParam( GUID_TimeSignature, dwGroupBits, dwIndex, m_lTime, NULL, &dmTimeSig);
	}
	HRESULT SetTime(long lMeasure, long lBeat, IDMUSProdTimeline* pTimeline, DWORD dwGroupBits, DWORD dwIndex=0)
	{
		ASSERT(pTimeline);
		if(pTimeline == NULL)
		{
			return E_POINTER;
		}
		HRESULT hr = pTimeline->MeasureBeatToClocks(dwGroupBits, dwIndex, lMeasure, lBeat, &m_lTime);
		ASSERT(hr == S_OK);
		return hr;
	}
	HRESULT SetTimeUsingPosition(long lPosition, IDMUSProdTimeline* pTimeline, DWORD dwGroupBits, DWORD dwIndex=0)
	{
		ASSERT (pTimeline);
		long lMeasure, lBeat;
		HRESULT hr = pTimeline->PositionToMeasureBeat(dwGroupBits, dwIndex, lPosition, &lMeasure, &lBeat);
		ASSERT(hr == S_OK);
		hr = pTimeline->MeasureBeatToClocks(dwGroupBits, dwIndex, lMeasure, lBeat, &m_lTime);
		ASSERT(hr == S_OK);
		return hr;
	}
	// dangerous because allows adding cmusictimeconverters by adding times which could be wrong in multimeters
	// useful for relational ops
	operator long()
	{
		return m_lTime;
	}
	/*
	bool operator < (const CMusicTimeConverter& cmt)
	{
		return m_lTime < cmt.m_lTime;
	}
	bool operator > (const CMusicTimeConverter& cmt)
	{
		return m_lTime > cmt.m_lTime;
	}
	*/
	long& Time()
	{
		return m_lTime;
	}
	CMusicTimeConverter& operator=(long lTime)
	{
		m_lTime = lTime;
		return *this;
	}
	HRESULT AddOffset(long lMeasure, long lBeat, IDMUSProdTimeline* pTimeline, DWORD dwGroupBits, DWORD dwIndex=0)
	{
		// find time sig at m_lTime
		DMUS_TIMESIGNATURE dmTimeSig;
		HRESULT hr;
		hr = GetTimeSig(dmTimeSig, pTimeline, dwGroupBits, dwIndex);
		if(SUCCEEDED(hr))
		{
			// find our measure and beat
			long lTmpMeasure, lTmpBeat;
			hr = GetMeasureBeat(lTmpMeasure,lTmpBeat, pTimeline, dwGroupBits, dwIndex);
			if(SUCCEEDED(hr))
			{
				long lTmpBeat2 = (lTmpBeat + lBeat) % dmTimeSig.bBeatsPerMeasure;
				lTmpMeasure = lTmpMeasure + lMeasure + (lTmpBeat + lBeat) / dmTimeSig.bBeatsPerMeasure;
				hr = SetTime(lTmpMeasure, lTmpBeat2, pTimeline, dwGroupBits, dwIndex);
			}
		}
		return hr;
	}
};



inline CMusicTimeConverter operator+(CMusicTimeConverter& a, CMusicTimeConverter& b)
{
	CMusicTimeConverter t(a);
	t.Time() += b.Time();
	return t;
}

inline CMusicTimeConverter operator-(CMusicTimeConverter& a, CMusicTimeConverter& b)
{
	CMusicTimeConverter t(a);
	t.Time() -= b.Time();
	return t;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Shared\guiddlg.h ===
#if !defined(AFX_GUIDDLG_H__F2B9A029_63AF_11D2_8918_00C04FBF8D15__INCLUDED_)
#define AFX_GUIDDLG_H__F2B9A029_63AF_11D2_8918_00C04FBF8D15__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// guiddlg.h : header file
//

#include "resource.h"

/////////////////////////////////////////////////////////////////////////////
// CGuidDlg dialog

class CGuidDlg : public CDialog
{
// Construction
public:
	CGuidDlg(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CGuidDlg)
	enum { IDD = IDD_DLG_GUID };
	CButton	m_btnOK;
	CEdit	m_editGuid;
	//}}AFX_DATA

	GUID m_guid;

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CGuidDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	GUID m_guidOriginal;

	// Generated message map functions
	//{{AFX_MSG(CGuidDlg)
	virtual BOOL OnInitDialog();
	afx_msg void OnNewGuid();
	afx_msg void OnKillfocusEditGuid();
	virtual void OnCancel();
	virtual void OnOK();
	afx_msg void OnUpdateEditGuid();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_GUIDDLG_H__F2B9A029_63AF_11D2_8918_00C04FBF8D15__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Shared\Keyboard.h ===
#if !defined(AFX_KEYBOARD_H__E41D1398_A999_11D1_9858_00805FA67D16__INCLUDED_)
#define AFX_KEYBOARD_H__E41D1398_A999_11D1_9858_00805FA67D16__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// Keyboard.h : header file
//
// Keyboard.h : header file
//
class KeyInfo
{
public:
				KeyInfo();
	void		SetState(short nState);
	CRect		m_crDrawRect;
	CString		m_csName;
	short		m_nState;
	BOOL		m_fBlackKey;
	BOOL		m_fRootKey;
	COLORREF	m_Color;
};


inline int HighestBit(DWORD pattern)
{
	int highestbit = -1;
	for(int i = 0; i < sizeof(DWORD) * 8; i++, pattern = pattern >> 1)
	{
		if(pattern & 1)
		{
			highestbit = i;
		}
	}
	return highestbit;
}

class CKeyboard;

typedef void (*CKeyboardCallback)(CKeyboard* caller, void* hint, short nKey);
typedef void (*CMouseCallback)(CKeyboard* caller, void* hint, short nKey, CPoint& ptMouse);

/////////////////////////////////////////////////////////////////////////////
// CKeyboard window

class CKeyboard : public CButton
{
// Construction
public:
	CKeyboard();

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CKeyboard)
	public:
	virtual void DrawItem(LPDRAWITEMSTRUCT lpDrawItemStruct);
	protected:
	virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam);
	//}}AFX_VIRTUAL

// Implementation
private:
	// use to get mouse down/up calls
	CKeyboardCallback m_pfnLButtonDown;
	CKeyboardCallback m_pfnLButtonUp;
	CMouseCallback m_pfnRButtonDown;
	void*	m_pHintLButtonDown;
	void*	m_pHintLButtonUp;
	void*	m_pHintRButtonDown;
public:
	enum {Size = 48};
	virtual ~CKeyboard();
	void SetLowerBound( int where)
	{
		ASSERT(0 <= where && where < 24);
		m_lowerbound  = static_cast<short>(where);
		Invalidate(FALSE);
	}
	void ShiftKeys(short howmuch)
	{
		m_lowerbound = static_cast<short>(m_lowerbound + howmuch);
		if(m_lowerbound < 0)
		{
			m_lowerbound = 0;
		}
		else if(m_lowerbound > m_visible)
		{
			m_lowerbound = m_visible;
		}
		Invalidate(FALSE);
	}
	int Transpose() const
	{
		return m_transpose;
	}
	void Transpose(int newval, bool bShift=false)
	{
		int howmuch = newval - m_transpose;
		m_transpose = static_cast<short>(newval);
		if(m_transpose < 0)
		{
			m_transpose = 0;
		}
		/* this code is faulty and needs to be rethought
		else if(m_transpose > Visible + m_lowerbound)
		{
			// need to shift keyboard to make chord visible
			bShift = true;
//			m_transpose = Visible;
//			bShift = true;	// must shift keyboard
//			m_lowerbound = howmuch;
		}
		*/
		if(bShift)
		{
			ShiftKeys(static_cast<short>(howmuch));
		}
	}
	void SetLButtonDownCallback(CKeyboardCallback pfn, void* hint)
	{
		m_pfnLButtonDown = pfn;
		m_pHintLButtonDown = hint;
	}
	void SetLButtonUpCallback(CKeyboardCallback pfn, void* hint)
	{
		m_pfnLButtonUp = pfn;
		m_pHintLButtonUp = hint;
	}
	void SetRButtonDownCallback(CMouseCallback pfn, void* hint)
	{
		m_pfnRButtonDown = pfn;
		m_pHintRButtonDown = hint;
	}
	short LowerBound()
	{
		return m_lowerbound;
	}
	short Extent()
	{
		return m_visible;
	}
	void SetExtent(short s)
	{
		m_visible = s;
	}
	short GetRootKeys()
	{
		return m_nRootKeys;
	}
	void SetRootKeys(short n);
	void		DrawKeyboard(CDC* pdc);
	int FindKey(CPoint point);
	short GetNoteState(short nKey)
	{
		return m_Keys[nKey].m_nState;
	}
	void SetNoteState(short nKey, LPCTSTR pszName, short nState);

	void SetNewSize(const CRect& crNewRect);

	void ClearKeys();

private:
	short		  m_lowerbound;
	short		  m_transpose;
	short		  m_visible;
	short		  m_nRootKeys;
	KeyInfo		m_Keys[Size];
	CRect		m_crBoundRect;


	// Generated message map functions
protected:
	//{{AFX_MSG(CKeyboard)
	afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnLButtonUp(UINT nFlags, CPoint point);
	afx_msg void OnRButtonDown(UINT nFlags, CPoint point);
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_KEYBOARD_H__E41D1398_A999_11D1_9858_00805FA67D16__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Shared\MidiFileIO.cpp ===
#include "stdafx.h"
#include <stdlib.h>
#include "SequenceIO.h"
#include "CurveIO.h"
#include "midifileio.h"
#include <RiffStrm.h>

#define MIDI_NOTEOFF    0x80
#define MIDI_NOTEON     0x90
#define MIDI_PTOUCH     0xA0
#define MIDI_CCHANGE    0xB0
#define MIDI_PCHANGE    0xC0
#define MIDI_MTOUCH     0xD0
#define MIDI_PBEND      0xE0

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

static HRESULT StreamRead(IStream* pStream, void* data, DWORD cbData)
{
	DWORD cbRead;
	HRESULT hr;
	hr = pStream->Read((char*)data, cbData, &cbRead);
	if(FAILED(hr) || cbData != cbRead)
		return E_FAIL;
	else
		return hr;
}

static short snPPQN;

#ifdef _MAC
static DWORD ConvertTime( DWORD dwTime )
{
	wide d;
	long l;  // storage for the remainder

	if( snPPQN == DMUS_PPQ )  {
		return dwTime;
	}
	WideMultiply( dwTime, DMUS_PPQ, &d );
	return WideDivide( &d, snPPQN, &l );
}
#else
static DWORD ConvertTime( DWORD dwTime )
{
    __int64 d;

    if( snPPQN == DMUS_PPQ )
    {
		return dwTime;
    }
    d = dwTime;
    d *= DMUS_PPQ;
    d /= snPPQN;
    return (DWORD)d;
}
#endif


const DWORD	gdwSMFHeader =	mmioFOURCC('M', 'T', 'h', 'd'); 
const DWORD gdwSMFTrack	 =	mmioFOURCC('M', 'T', 'r', 'k');
const DWORD gdwEndOfTrack = mmioFOURCC('\x00', '\xFF', '\x2F', '\x00');

BYTE gbChannel;





int _cdecl CompareCSequenceItem(const void* m1,const void* m2)
{
	CSequenceItem* item1 = (CSequenceItem*)m1;
	CSequenceItem* item2 = (CSequenceItem*)m2;
	if(item1->Before(*item2))
		return -1;
	else if(item1->After(*item2))
		return 1;
	else
	{
		if( item1->m_bStatus == item2->m_bStatus )
		{
			return 0;
		}
		else
		{
			switch( item1->m_bStatus )
			{
			case MIDI_CCHANGE:
				return -1;
			case MIDI_NOTEON:
				return 1;
			default:
				switch( item2->m_bStatus )
				{
				case MIDI_CCHANGE:
					return 1;
				case MIDI_NOTEON:
					return -1;
				default:
					return 0;
				}
			}
		}
	}
}

static void swap(char& c1, char& c2)
{
	char temp = c2;
	c2 = c1;
	c1 = temp;
}

void ReverseIfNotMac(DWORD &dw)
{

#ifndef _MAC
	char* p = reinterpret_cast<char*>(&dw);
	swap(p[0], p[3]);
	swap(p[1], p[2]);
#endif

}

void ReverseIfNotMac(WORD &w)
{

#ifndef _MAC
	char* p = reinterpret_cast<char*>(&w);
	swap(p[0], p[1]);
#endif

}


DWORD WriteVarLen(IStream* pStream, long value)
// returns number of bytes written
{
	long buffer;
	DWORD cb = 0;
	buffer = value & 0x7f;
	while((value >>=7) > 0)
	{
		buffer <<= 8;
		buffer |= 0x80;
		buffer += (value & 0x7f);
	}

	while(true)
	{
		char c = static_cast<char>(buffer & 0xFF);
		pStream->Write(&c, 1, 0);
		cb++;
		if(buffer & 0x80)
		{
			buffer >>= 8;
		}
		else
		{
			break;
		}
	}
	return cb;
}

HRESULT WriteTrackHeader(IStream* pStream, DWORD cbSize)
{

	HRESULT hr = pStream->Write(&gdwSMFTrack, sizeof(DWORD), 0);
	if(SUCCEEDED(hr))
	{
		ReverseIfNotMac(cbSize);
		hr = pStream->Write(&cbSize, sizeof(DWORD), 0);
	}
	return hr;
}

HRESULT ReadTrackHeader(IStream* pStream, DWORD& cbHeader)
{
	DWORD streampos = StreamTell(pStream);

	// read header type
	DWORD dwType;
	HRESULT hr = StreamRead(pStream, &dwType, sizeof(DWORD));
	if(FAILED(hr))
		return hr;
	if(dwType != gdwSMFTrack)
		return E_UNEXPECTED;
	

	// read chunk size
	hr = StreamRead(pStream, &cbHeader,sizeof(DWORD));
	if(FAILED(hr))
		return hr;
	else
		ReverseIfNotMac(cbHeader);

	// move stream to end of chunk
	hr = StreamSeek(pStream, streampos + sizeof(DWORD) + cbHeader, STREAM_SEEK_SET);
	return hr;
}

HRESULT WriteEndOfTrack(IStream* pStream, DWORD& cbWritten)
{
	char buf[] = {'\x00','\xFF', '\x2F', '\x00'};
	HRESULT hr = pStream->Write(buf, 4, &cbWritten);
	hr = hr == S_OK && cbWritten == 4 ? S_OK : E_FAIL;
	return hr;
}

HRESULT WriteSMFHeader(IStream* pStream, WORD nTracks)
{
	DWORD cbWritten;
	DWORD cbSize = 6;
	WORD format = 1;
	WORD PPQ = DMUS_PPQ;

	HRESULT hr = pStream->Write(&gdwSMFHeader, sizeof(DWORD), 0);
	if(FAILED(hr))
		goto Leave;

	ReverseIfNotMac(cbSize);
	hr = pStream->Write(&cbSize, sizeof(DWORD), &cbWritten);
	if(FAILED(hr) || sizeof(DWORD) != cbWritten)
	{
		hr = E_FAIL;
		goto Leave;
	}

	// write format
	ReverseIfNotMac(format);
	hr = pStream->Write(&format, sizeof(WORD), &cbWritten);
	if(FAILED(hr) || sizeof(WORD) != cbWritten)
	{
		hr = E_FAIL;
		goto Leave;
	}
	
	// write number of tracks
	ReverseIfNotMac(nTracks);
	hr = pStream->Write(&nTracks, sizeof(WORD), &cbWritten);
	if(FAILED(hr) || sizeof(WORD) != cbWritten)
	{
		hr = E_FAIL;
		goto Leave;
	}

	// write timing info
	ReverseIfNotMac(PPQ);
	hr = pStream->Write(&PPQ, sizeof(WORD), &cbWritten);
	if(sizeof(WORD) != cbWritten)
		hr = E_FAIL;

Leave:
	return hr;
}

HRESULT ReadSMFHeader(IStream* pStream, WORD& nTracks, WORD& nFormat, WORD& nDiv)
{
	DWORD chunk;
	DWORD cbHeader;

	DWORD streampos = StreamTell(pStream);

	// read header type
	HRESULT hr = StreamRead(pStream, &chunk, sizeof(DWORD));
	if(FAILED(hr))
		return hr;

	if(chunk != gdwSMFHeader)
		return E_UNEXPECTED;

	// read chunk size
	hr = StreamRead(pStream, &cbHeader,sizeof(DWORD));
	if(FAILED(hr))
		return hr;
	else
		ReverseIfNotMac(cbHeader);

	// read format
	hr = StreamRead(pStream, &nFormat, sizeof(WORD));
	if(FAILED(hr))
		return hr;
	else
		ReverseIfNotMac(nFormat);

	// read ntracks
	hr = StreamRead(pStream, &nTracks, sizeof(WORD));
	if(FAILED(hr))
		return hr;
	else
		ReverseIfNotMac(nTracks);

	// read ndiv
	hr = StreamRead(pStream, &nDiv, sizeof(WORD));
	if(FAILED(hr))
		return hr;
	else
		ReverseIfNotMac(nDiv);

	// move stream to end of chunk
	hr = StreamSeek(pStream, streampos + sizeof(DWORD) + cbHeader, STREAM_SEEK_SET);
	return hr;
}

HRESULT WriteMidiEvent(IStream* pStream, CSequenceItem* pItem, DWORD delta_t, DWORD& cbWritten)
{
	BYTE status = Status(pItem->m_bStatus);
	BYTE bNewStatus = BYTE(status | gbChannel );
	
	HRESULT hr = S_OK;

	if( status == MIDI_PCHANGE
	||  status == MIDI_MTOUCH )
	{
		cbWritten = 2;	// size of supported types excluding delta-time
		cbWritten += WriteVarLen(pStream, delta_t);

		if(cbWritten == 2)
		{
			hr = E_FAIL;
			goto Leave;
		}

		hr = pStream->Write(&bNewStatus, 1, 0)
				|| pStream->Write(&pItem->m_bByte1, 1, 0);
	}
	else
	{
		// If this is a RPN or NRPN event
		if( (pItem->m_bStatus == MIDI_CCHANGE)
		&&	(pItem->m_bByte1 == 0xFF) )
		{
			cbWritten = 12;
			cbWritten += WriteVarLen(pStream, delta_t);

			if(cbWritten == 12)
			{
				hr = E_FAIL;
				goto Leave;
			}

			BYTE bRPNMSB = (BYTE)((pItem->m_dwMIDISaveData >> 23) & 0x7F);
			BYTE bRPNLSB = (BYTE)((pItem->m_dwMIDISaveData >> 16) & 0x7F);
			BYTE bDataMSB = (BYTE)((pItem->m_dwMIDISaveData >> 7) & 0x7F);
			BYTE bDataLSB = (BYTE)(pItem->m_dwMIDISaveData & 0x7F);
			BYTE bDataMSBCC = 0x6;
			BYTE bDataLSBCC = 0x26;
			BYTE bZero = 0;
			BYTE bRPNMSBCC;
			BYTE bRPNLSBCC;
			if( pItem->m_bByte2 == DMUS_CURVET_RPNCURVE )
			{
				bRPNMSBCC = 0x65;
				bRPNLSBCC = 0x64;
			}
			else
			{
				ASSERT( pItem->m_bByte2 == DMUS_CURVET_NRPNCURVE );
				bRPNMSBCC = 0x63;
				bRPNLSBCC = 0x62;
			}
			hr = pStream->Write(&bNewStatus, 1, 0)
					|| pStream->Write(&bRPNMSBCC, 1, 0)
					|| pStream->Write(&bRPNMSB, 1, 0)
					|| pStream->Write(&bZero, 1, 0)
					|| pStream->Write(&bRPNLSBCC, 1, 0)
					|| pStream->Write(&bRPNLSB, 1, 0)
					|| pStream->Write(&bZero, 1, 0)
					|| pStream->Write(&bDataMSBCC, 1, 0)
					|| pStream->Write(&bDataMSB, 1, 0)
					|| pStream->Write(&bZero, 1, 0)
					|| pStream->Write(&bDataLSBCC, 1, 0)
					|| pStream->Write(&bDataLSB, 1, 0);
			//BYTE bNullFunction = 0x7F;
			/* Don't write out null function - Cakewalk gets confused by it
					|| pStream->Write(&bZero, 1, 0)
					|| pStream->Write(&bRPNMSBCC, 1, 0)
					|| pStream->Write(&bNullFunction, 1, 0)
					|| pStream->Write(&bZero, 1, 0)
					|| pStream->Write(&bRPNLSBCC, 1, 0)
					|| pStream->Write(&bNullFunction, 1, 0);
			*/
		}
		else
		{
			cbWritten = 3;	// size of supported types excluding delta-time
			cbWritten += WriteVarLen(pStream, delta_t);

			if(cbWritten == 3)
			{
				hr = E_FAIL;
				goto Leave;
			}

			hr = pStream->Write(&bNewStatus, 1, 0)
					|| pStream->Write(&pItem->m_bByte1, 1, 0)
					|| pStream->Write(&pItem->m_bByte2, 1, 0);
		}
	}


Leave:
	return hr;
}


//////////////////////////////////////// Track class

CSMFTrack::~CSMFTrack()
{
	m_notes.RemoveAll();
	m_curves.RemoveAll();
}

void CSMFTrack::AddItem(CSequenceItem* pItem)
{
	m_notes.AddTail(pItem);
}

void CSMFTrack::AddCurveItem(CSequenceItem* pItem)
{
	m_curves.AddTail(pItem);
}


HRESULT CSMFTrack::Write(IStream* pStream)
{
	DWORD	cbSize=0;
	DWORD	cbInc;
	HRESULT hr;

	// need to add notes off and sort.
	int cItems = m_notes.GetCount()*2 + m_curves.GetCount();
	CSequenceItem* ary = new CSequenceItem[cItems];
	POSITION pos = m_notes.GetHeadPosition();
	int i = 0;
	while(pos)
	{
		CSequenceItem* pItem = m_notes.GetNext(pos);
		ary[i++] = *pItem;
		if( Status(pItem->m_bStatus) == MIDI_NOTEON )
		{
			pItem->m_bStatus -= 0x10;	// convert to note off - but keep MIDI Channel
			pItem->m_mtTime += pItem->m_mtDuration;
			ary[i++] = *pItem;
		}
	}

	// add curves
	pos = m_curves.GetHeadPosition();
	while(pos)
	{
		CSequenceItem* pItem = m_curves.GetNext(pos);
		ary[i++] = *pItem;
	}

	cItems = i;

	// sort
	qsort(ary, cItems, sizeof(CSequenceItem), CompareCSequenceItem);

	// save current pos
	DWORD streampos = StreamTell(pStream);

	// write header, leaving room for count
	hr = WriteTrackHeader(pStream, 0);
	//write track
	i = 0;
	DWORD t0=0, delta_t = 0;
	while(i < cItems && hr == S_OK)
	{
		CSequenceItem* pItem = &(ary[i++]);
		delta_t = (pItem->m_mtTime+pItem->m_nOffset) - t0;
		t0 = pItem->m_mtTime + pItem->m_nOffset;
		hr = WriteMidiEvent(pStream, pItem, delta_t, cbInc);
		cbSize += cbInc;
	}

	if(SUCCEEDED(hr))
	{
		DWORD cbEnd;
		// write end of track
		hr = WriteEndOfTrack(pStream, cbEnd);
		cbSize += cbEnd;
		// now back fill size
		hr = StreamSeek(pStream, streampos, STREAM_SEEK_SET);
		if(FAILED(hr))
			goto Leave;
		hr = WriteTrackHeader(pStream, cbSize);
	}

Leave:
	// set stream to end
	hr = StreamSeek(pStream,0,STREAM_SEEK_END);
	delete []ary;
	return hr;
}

HRESULT CSMFTrack::Read(IStream*)
{
	return E_NOTIMPL;
}

///////////////////////////////////////////////// MidiMerger
// Merges Midi Note on/offs into CSequenceEvents
// Assumes note on/offs are added in ascending time order
class MidiMerger
{
	CTypedPtrList<CPtrList, CSequenceItem*> m_notes;
public:
	~MidiMerger();
	bool AddNoteOn(CSequenceItem* pItem)
	{
		if(Status(pItem->m_bStatus) != MIDI_NOTEON)
			return false;

		m_notes.AddTail(pItem);
		return true;
	}

	CSequenceItem* Merge(CSequenceItem* pItem);
};

MidiMerger::~MidiMerger()
{
	POSITION pos = m_notes.GetHeadPosition();
	while(pos)
	{
		CSequenceItem* pItem = m_notes.GetNext(pos);
		delete pItem;
	}
	m_notes.RemoveAll();
}

CSequenceItem* MidiMerger::Merge(CSequenceItem* pItem)
// pItem must be a note off.  Returns 0 is corresponding note on not found
{
	if(Status(pItem->m_bStatus) != MIDI_NOTEOFF)
		return 0;

	CSequenceItem* pOn = NULL;
	POSITION pos = m_notes.GetHeadPosition();
	bool found = false;
	while(pos && !found)
	{
		POSITION tempos = pos;
		pOn = m_notes.GetNext(pos);
		if( ((pItem->m_bStatus & 0xF) == (pOn->m_bStatus & 0xF))
			&& (pItem->m_bByte1 == pOn->m_bByte1) )
		{
			found = true;
			m_notes.RemoveAt(tempos);
		}
	}

	if(!found)
		pOn = 0;

	return pOn;
}



///////////////////////////////////////////////// File class

class CSMFFile	
// sorts into different tracks based on channel
{
	CSMFTrack	tracks[16];
public:
	CSMFFile() {}
	CSMFTrack*	operator()(int i)
	{
		ASSERT( 0 <= i && i < 16);
		if( 0 <= i && i < 16)
		{
			return &tracks[i];
		}
		else
		{
			return 0;
		}
	}
	void AddItem(CSequenceItem*);
	void InsertSequence(CTypedPtrList<CPtrList, CSequenceItem*>& lst);
	HRESULT Write(IStream*);
	HRESULT Read(IStream*);
};


void CSMFFile::AddItem(CSequenceItem* pItem)
{
	tracks[gbChannel].AddItem(pItem);
}

HRESULT CSMFFile::Write(IStream* pStream)
{
	ASSERT(pStream);
	if(pStream == NULL)
		return E_INVALIDARG;

	// count # of active tracks
	WORD nTrack = 0;
	int i;
	for(i = 0; i < 16; i++)
	{
		if(!tracks[i].IsEmpty())
			nTrack++;
	}

	// write header
	HRESULT hr = WriteSMFHeader(pStream, nTrack);
	if(FAILED(hr))
	{
		goto Leave;
	}

	// write tracks
	for(i = 0; i < 16 && hr == S_OK; i++)
	{
		if(tracks[i].IsEmpty())
			continue;

		hr = tracks[i].Write(pStream);
	}

Leave:
	return hr;
}

HRESULT CSMFFile::Read(IStream* pStream)
{
	ASSERT(pStream);
	if(pStream == NULL)
		return E_INVALIDARG;

	return E_NOTIMPL;
/*
	// read file header
	WORD nTracks, nFormat
	HRESULT hr = ReadSMFHeader(pStream, nTracks, nFormat, ssnPPQ);

	if(ssnPPQ & 0x8000)
		return E_NOTIMPL;	// SMPTE not supported

	if(nTracks > 16)
		return E_NOTIMPL;	// Can't handle > 16 tracks

	// Read Tracks
	for(WORD i = 0; i < nTracks; i++)
	{
		// read track header
		DWORD cb;
		hr = ReadTrackHeader(pStream, cb);
		// read events
		bool bCont = (cb != 0);
		DWORD elapsedTime = 0;
		DWORD deltaTime;
		while(bCont)
		{
			CSequenceItem* pItem;
			hr = ReadMidiEvent(pStream, pItem, deltaTime);
		}

	}
Leave:

	return hr;
*/
}

void CSMFFile::InsertSequence(CTypedPtrList<CPtrList, CSequenceItem*>& lst)
{
	POSITION pos = lst.GetHeadPosition();
	while(pos)
	{
		CSequenceItem* pItem = lst.GetNext(pos);
		AddItem(pItem);
	}
}


//////////////////////////////////////// Public funcs
//
HRESULT	WriteMidiSequenceToStream(IStream* pIStream, DWORD dwPChannel,
								  CTypedPtrList<CPtrList, CSequenceItem*>& lstSequences)
{
	if( dwPChannel >= DMUS_PCHANNEL_BROADCAST_GROUPS )
	{
		gbChannel = 0;
	}
	else
	{
		gbChannel = static_cast<BYTE>(dwPChannel & 0xF);
	}
	CSMFFile midifile;
	midifile.InsertSequence(lstSequences);
	return midifile.Write(pIStream);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Shared\MidiFileIO.h ===
#ifndef MIDIFILEIO_H
#define MIDIFILEIO_H

class CSequenceItem;

HRESULT	WriteMidiSequenceToStream(IStream* pIStream, DWORD dwPChannel,
								  CTypedPtrList<CPtrList, CSequenceItem*>& lstSequences);


HRESULT ReadMidiSequenceFromStream(LPSTREAM pStream,
								  CTypedPtrList<CPtrList, CSequenceItem*>& lstSequences,
								  CTypedPtrList<CPtrList, CCurveItem*>& lstCurves,
								  long lOffsetTime,
								  DWORD& dwLength);

HRESULT WriteSMFHeader(IStream* pStream, WORD nTracks);

DWORD ReadEvent( LPSTREAM pStream, DWORD dwTime, FullSeqEvent** plstEvent, struct _DMUS_IO_PATCH_ITEM** pplstPatchEvent);
WORD GetVarLength( LPSTREAM pStream, DWORD& rfdwValue );
FullSeqEvent* SortEventList( FullSeqEvent* lstEvent );
FullSeqEvent* CompressEventList( FullSeqEvent* lstEvent );

inline BYTE Status(BYTE x)
{
	return BYTE(x & 0xF0);
}

inline BYTE Channel(BYTE x)
{
	return BYTE(x & 0x0F);
}

// this function gets a short that is formatted the correct way
// i.e. the motorola way as opposed to the intel way
BOOL __inline GetMShort( LPSTREAM pStream, short& n )
{
	union uShort
	{
	unsigned char buf[2];
	short n;
	} u;

	if( S_OK != pStream->Read( u.buf, 2, NULL ) )
	{
	return FALSE;
	}

#ifndef _MAC
	// swap bytes
	unsigned char ch;
	ch = u.buf[0];
	u.buf[0] = u.buf[1];
	u.buf[1] = ch;
#endif

	n = u.n;
	return TRUE;
}

#ifndef _GetMLong_Defined_
#define _GetMLong_Defined_

// this function gets a long that is formatted the correct way
// i.e. the motorola way as opposed to the intel way
BOOL __inline GetMLong( LPSTREAM pStream, DWORD& dw )
{
	union uLong
	{
		unsigned char buf[4];
	DWORD dw;
	} u;

	if( S_OK != pStream->Read( u.buf, 4, NULL ) )
	{
	return FALSE;
	}


#ifndef _MAC
	// swap bytes
	unsigned char ch;
	ch = u.buf[0];
	u.buf[0] = u.buf[3];
	u.buf[3] = ch;

	ch = u.buf[1];
	u.buf[1] = u.buf[2];
	u.buf[2] = ch;
#endif

	dw = u.dw;
	return TRUE;
}

#endif

//////////////////////////////////////// Track class
class CSMFTrack
{
public:
	CTypedPtrList<CPtrList, CSequenceItem*> m_notes;
	CTypedPtrList<CPtrList, CSequenceItem*> m_curves; // Doesn't add note offs to this list

	CSMFTrack() {}
	~CSMFTrack(); /* list management by user not this class, all this does is remove ptrs */
	HRESULT	Write(IStream*);
	HRESULT Read(IStream*);
	void AddItem(CSequenceItem* pItem);
	void AddCurveItem(CSequenceItem* pItem); // Doesn't add note offs
	BOOL IsEmpty()
	{
		return m_notes.IsEmpty() && m_curves.IsEmpty();
	}

protected:
	CSMFTrack(const CSMFTrack&);
	CSMFTrack& operator = (const CSMFTrack&);
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Shared\makefile.inc ===
#
# The contents of this file were moved from windows\directx\dmusic\makefil0.
# 

TARGETSRCS= \
    $(DMPROOT)\AudioPathDesigner\DlgAddPChannel.cpp \
    $(DMPROOT)\AudioPathDesigner\GuidDlg.cpp \
    $(DMPROOT)\AudioPathDesigner\OlePropPage.cpp \
    $(DMPROOT)\AudioPathDesigner\OlePropSheet.cpp \
    $(DMPROOT)\AudioPathDesigner\RiffStrm.cpp \
    $(DMPROOT)\BandEditor\AList.cpp \
    $(DMPROOT)\BandEditor\GuidDlg.cpp \
    $(DMPROOT)\BandEditor\Info.cpp \
    $(DMPROOT)\BandEditor\RiffStrm.cpp \
    $(DMPROOT)\BandEditor\Unknownchunk.cpp \
    $(DMPROOT)\BandStripMgr\GroupBitsPPG.cpp \
    $(DMPROOT)\BandStripMgr\RiffStrm.cpp \
    $(DMPROOT)\BandStripMgr\TrackFlagsPPG.cpp \
    $(DMPROOT)\ChordMapStripMgr\InvertVector.cpp \
    $(DMPROOT)\ChordMapStripMgr\Keyboard.cpp \
    $(DMPROOT)\ChordMapStripMgr\RiffStrm.cpp \
    $(DMPROOT)\ChordStripMgr\GroupBitsPPG.cpp \
    $(DMPROOT)\ChordStripMgr\InvertVector.cpp \
    $(DMPROOT)\ChordStripMgr\Keyboard.cpp \
    $(DMPROOT)\ChordStripMgr\RiffStrm.cpp \
    $(DMPROOT)\ChordStripMgr\SelectedRegion.cpp \
    $(DMPROOT)\ChordStripMgr\TrackFlagsPPG.cpp \
    $(DMPROOT)\CommandStripMgr\GroupBitsPPG.cpp \
    $(DMPROOT)\CommandStripMgr\RiffStrm.cpp \
    $(DMPROOT)\CommandStripMgr\TrackFlagsPPG.cpp \
    $(DMPROOT)\Conductor\AList.cpp \
    $(DMPROOT)\Conductor\NodeRefChunk.cpp \
    $(DMPROOT)\Conductor\RiffStrm.cpp \
    $(DMPROOT)\ContainerDesigner\DupeFileDlg.cpp \
    $(DMPROOT)\ContainerDesigner\GuidDlg.cpp \
    $(DMPROOT)\ContainerDesigner\RiffStrm.cpp \
    $(DMPROOT)\DLSDesigner\AList.cpp \
    $(DMPROOT)\DLSDesigner\DLSLoadSaveUtils.cpp \
    $(DMPROOT)\DLSDesigner\Info.cpp \
    $(DMPROOT)\DLSDesigner\myslider.cpp \
    $(DMPROOT)\DLSDesigner\RiffStrm.cpp \
    $(DMPROOT)\DLSDesigner\Unknownchunk.cpp \
    $(DMPROOT)\LyricStripMgr\BaseMgr.cpp \
    $(DMPROOT)\LyricStripMgr\BaseStrip.cpp \
    $(DMPROOT)\LyricStripMgr\GroupBitsPPG.cpp \
    $(DMPROOT)\LyricStripMgr\RiffStrm.cpp \
    $(DMPROOT)\LyricStripMgr\SelectedRegion.cpp \
    $(DMPROOT)\LyricStripMgr\TrackFlagsPPG.cpp \
    $(DMPROOT)\MarkerStripMgr\BaseMgr.cpp \
    $(DMPROOT)\MarkerStripMgr\BaseStrip.cpp \
    $(DMPROOT)\MarkerStripMgr\GroupBitsPPG.cpp \
    $(DMPROOT)\MarkerStripMgr\RiffStrm.cpp \
    $(DMPROOT)\MarkerStripMgr\SelectedRegion.cpp \
    $(DMPROOT)\MarkerStripMgr\TrackFlagsPPG.cpp \
    $(DMPROOT)\MelGenStripMgr\RiffStrm.cpp \
    $(DMPROOT)\MelGenStripMgr\TrackFlagsPPG.cpp \
    $(DMPROOT)\MIDIStripMgr\AList.cpp \
    $(DMPROOT)\MIDIStripMgr\DialogNewCCTrack.cpp \
    $(DMPROOT)\MIDIStripMgr\DialogVelocity.cpp \
    $(DMPROOT)\MIDIStripMgr\MidiFileIO.cpp \
    $(DMPROOT)\MIDIStripMgr\midifileIO2.cpp \
    $(DMPROOT)\MIDIStripMgr\RiffStrm.cpp \
    $(DMPROOT)\MIDIStripMgr\SharedPattern.cpp \
    $(DMPROOT)\MIDIStripMgr\SharedPianoRoll.cpp \
    $(DMPROOT)\MIDIStripMgr\SharedPropPageCurve.cpp \
    $(DMPROOT)\MIDIStripMgr\SharedPropPageNote.cpp \
    $(DMPROOT)\MIDIStripMgr\TrackFlagsPPG.cpp \
    $(DMPROOT)\MuteStripMgr\GroupBitsPPG.cpp \
    $(DMPROOT)\MuteStripMgr\RiffStrm.cpp \
    $(DMPROOT)\MuteStripMgr\TrackFlagsPPG.cpp \
    $(DMPROOT)\ParamStripMgr\BaseMgr.cpp \
    $(DMPROOT)\ParamStripMgr\BaseStrip.cpp \
    $(DMPROOT)\ParamStripMgr\DLSLoadSaveUtils.cpp \
    $(DMPROOT)\ParamStripMgr\RiffStrm.cpp \
    $(DMPROOT)\ParamStripMgr\SelectedRegion.cpp \
    $(DMPROOT)\ParamStripMgr\TrackFlagsPPG.cpp \
    $(DMPROOT)\PersonalityDesigner\GuidDlg.cpp \
    $(DMPROOT)\PersonalityDesigner\InvertVector.cpp \
    $(DMPROOT)\PersonalityDesigner\Keyboard.cpp \
    $(DMPROOT)\PersonalityDesigner\RiffStrm.cpp \
    $(DMPROOT)\PersRefStripMgr\GroupBitsPPG.cpp \
    $(DMPROOT)\PersRefStripMgr\RiffStrm.cpp \
    $(DMPROOT)\PersRefStripMgr\TrackFlagsPPG.cpp \
    $(DMPROOT)\ScriptDesigner\GuidDlg.cpp \
    $(DMPROOT)\ScriptDesigner\RiffStrm.cpp \
    $(DMPROOT)\ScriptStripMgr\BaseMgr.cpp \
    $(DMPROOT)\ScriptStripMgr\BaseStrip.cpp \
    $(DMPROOT)\ScriptStripMgr\GroupBitsPPG.cpp \
    $(DMPROOT)\ScriptStripMgr\RiffStrm.cpp \
    $(DMPROOT)\ScriptStripMgr\SelectedRegion.cpp \
    $(DMPROOT)\ScriptStripMgr\TrackFlagsPPG.cpp \
    $(DMPROOT)\SegmentDesigner\GroupBitsPPG.cpp \
    $(DMPROOT)\SegmentDesigner\GuidDlg.cpp \
    $(DMPROOT)\SegmentDesigner\RiffStrm.cpp \
    $(DMPROOT)\SegmentDesigner\TabBoundaryFlags.cpp \
    $(DMPROOT)\SegmentDesigner\TrackFlagsPPG.cpp \
    $(DMPROOT)\SegmentStripMgr\BaseMgr.cpp \
    $(DMPROOT)\SegmentStripMgr\BaseStrip.cpp \
    $(DMPROOT)\SegmentStripMgr\GroupBitsPPG.cpp \
    $(DMPROOT)\SegmentStripMgr\RiffStrm.cpp \
    $(DMPROOT)\SegmentStripMgr\SelectedRegion.cpp \
    $(DMPROOT)\SegmentStripMgr\TrackFlagsPPG.cpp \
    $(DMPROOT)\SequenceStripMgr\DialogNewCCTrack.cpp \
    $(DMPROOT)\SequenceStripMgr\DialogVelocity.cpp \
    $(DMPROOT)\SequenceStripMgr\MidiFileIO.cpp \
    $(DMPROOT)\SequenceStripMgr\midifileIO2.cpp \
    $(DMPROOT)\SequenceStripMgr\RiffStrm.cpp \
    $(DMPROOT)\SequenceStripMgr\SharedPianoRoll.cpp \
    $(DMPROOT)\SequenceStripMgr\SharedPropPageCurve.cpp \
    $(DMPROOT)\SequenceStripMgr\SharedPropPageNote.cpp \
    $(DMPROOT)\SequenceStripMgr\TrackFlagsPPG.cpp \
    $(DMPROOT)\SignPostStripMgr\RiffStrm.cpp \
    $(DMPROOT)\SignPostStripMgr\TrackFlagsPPG.cpp \
    $(DMPROOT)\StyleDesigner\AList.cpp \
    $(DMPROOT)\StyleDesigner\GuidDlg.cpp \
    $(DMPROOT)\StyleDesigner\RiffStrm.cpp \
    $(DMPROOT)\StyleDesigner\SharedPattern.cpp \
    $(DMPROOT)\StyleDesigner\TabBoundaryFlags.cpp \
    $(DMPROOT)\StyleRefStripMgr\RiffStrm.cpp \
    $(DMPROOT)\StyleRefStripMgr\TrackFlagsPPG.cpp \
    $(DMPROOT)\TempoStripMgr\GroupBitsPPG.cpp \
    $(DMPROOT)\TempoStripMgr\RiffStrm.cpp \
    $(DMPROOT)\TempoStripMgr\TrackFlagsPPG.cpp \
    $(DMPROOT)\timeline\RiffStrm.cpp \
    $(DMPROOT)\TimeSigStripMgr\RiffStrm.cpp \
    $(DMPROOT)\TimeSigStripMgr\TrackFlagsPPG.cpp \
    $(DMPROOT)\ToolGraphDesigner\DlgAddPChannel.cpp \
    $(DMPROOT)\ToolGraphDesigner\GuidDlg.cpp \
    $(DMPROOT)\ToolGraphDesigner\OlePropPage.cpp \
    $(DMPROOT)\ToolGraphDesigner\OlePropSheet.cpp \
    $(DMPROOT)\ToolGraphDesigner\RiffStrm.cpp \
    $(DMPROOT)\WaveStripMgr\BaseMgr.cpp \
    $(DMPROOT)\WaveStripMgr\BaseStrip.cpp \
    $(DMPROOT)\WaveStripMgr\DLSLoadSaveUtils.cpp \
    $(DMPROOT)\WaveStripMgr\myslider.cpp \
    $(DMPROOT)\WaveStripMgr\RiffStrm.cpp \
    $(DMPROOT)\WaveStripMgr\SelectedRegion.cpp \
    $(DMPROOT)\WaveStripMgr\TrackFlagsPPG.cpp

dmusic: $(TARGETSRCS)

clean:
     -del /F /Q $(TARGETSRCS)

# Inference rules.
.SUFFIXES:.cpp

# Copy .cpp file from here to wherever specified
{}.cpp{$(O)}.cpp:
   
    copy $** $@

{}.cpp{$(DMPROOT)\3rdParty}.cpp:
	copy $** $@ 
{}.cpp{$(DMPROOT)\ADSREnvelope}.cpp:
	copy $** $@ 
{}.cpp{$(DMPROOT)\AudioPathDesigner}.cpp:
	copy $** $@ 
{}.cpp{$(DMPROOT)\BandEditor}.cpp:
	copy $** $@ 
{}.cpp{$(DMPROOT)\BandStripMgr}.cpp:
	copy $** $@ 
{}.cpp{$(DMPROOT)\build}.cpp:
	copy $** $@ 
{}.cpp{$(DMPROOT)\ChordMapStripMgr}.cpp:
    copy $** $@ 
{}.cpp{$(DMPROOT)\ChordStripMgr}.cpp:
    copy $** $@ 
{}.cpp{$(DMPROOT)\CommandStripMgr}.cpp:
    copy $** $@ 
{}.cpp{$(DMPROOT)\Conductor}.cpp:
    copy $** $@ 
{}.cpp{$(DMPROOT)\ContainerDesigner}.cpp:
    copy $** $@ 
{}.cpp{$(DMPROOT)\DLSDesigner}.cpp:
    copy $** $@ 
{}.cpp{$(DMPROOT)\DMUSProdGUID}.cpp:
    copy $** $@ 
{}.cpp{$(DMPROOT)\DMUSProdGUIDPrivate}.cpp:
    copy $** $@ 
{}.cpp{$(DMPROOT)\Externals}.cpp:
    copy $** $@ 
{}.cpp{$(DMPROOT)\Framework}.cpp:
    copy $** $@ 
{}.cpp{$(DMPROOT)\Includes}.cpp:
    copy $** $@ 
{}.cpp{$(DMPROOT)\InstallShield}.cpp:
    copy $** $@ 
{}.cpp{$(DMPROOT)\JazzCommon}.cpp:
    copy $** $@ 
{}.cpp{$(DMPROOT)\JazzComplete}.cpp:
    copy $** $@ 
{}.cpp{$(DMPROOT)\JazzDemo}.cpp:
    copy $** $@ 
{}.cpp{$(DMPROOT)\KeysOCX}.cpp:
    copy $** $@ 
{}.cpp{$(DMPROOT)\Libs}.cpp:
    copy $** $@ 
{}.cpp{$(DMPROOT)\LyricStripMgr}.cpp:
    copy $** $@ 
{}.cpp{$(DMPROOT)\MarkerStripMgr}.cpp:
    copy $** $@ 
{}.cpp{$(DMPROOT)\MelGenStripMgr}.cpp:
    copy $** $@ 
{}.cpp{$(DMPROOT)\MIDIStripMgr}.cpp:
    copy $** $@ 
{}.cpp{$(DMPROOT)\MuteStripMgr}.cpp:
    copy $** $@ 
{}.cpp{$(DMPROOT)\PanVol}.cpp:
    copy $** $@ 
{}.cpp{$(DMPROOT)\ParamStripMgr}.cpp:
    copy $** $@ 
{}.cpp{$(DMPROOT)\PersonalityDesigner}.cpp:
    copy $** $@ 
{}.cpp{$(DMPROOT)\PersRefStripMgr}.cpp:
    copy $** $@ 
{}.cpp{$(DMPROOT)\RegionKeyboard}.cpp:
    copy $** $@ 
{}.cpp{$(DMPROOT)\ScriptDesigner}.cpp:
    copy $** $@ 
{}.cpp{$(DMPROOT)\ScriptStripMgr}.cpp:
    copy $** $@ 
{}.cpp{$(DMPROOT)\SegmentDesigner}.cpp:
    copy $** $@ 
{}.cpp{$(DMPROOT)\SegmentStripMgr}.cpp:
    copy $** $@ 
{}.cpp{$(DMPROOT)\SequenceStripMgr}.cpp:
    copy $** $@ 
{}.cpp{$(DMPROOT)\Shared}.cpp:
    copy $** $@ 
{}.cpp{$(DMPROOT)\SignPostStripMgr}.cpp:
    copy $** $@ 
{}.cpp{$(DMPROOT)\SongDesigner}.cpp:
    copy $** $@ 
{}.cpp{$(DMPROOT)\StyleDesigner}.cpp:
    copy $** $@ 
{}.cpp{$(DMPROOT)\StyleRefStripMgr}.cpp:
    copy $** $@ 
{}.cpp{$(DMPROOT)\TempoStripMgr}.cpp:
    copy $** $@ 
{}.cpp{$(DMPROOT)\Timeline}.cpp:
    copy $** $@ 
{}.cpp{$(DMPROOT)\TimeSigStripMgr}.cpp:
    copy $** $@ 
{}.cpp{$(DMPROOT)\ToolGraphDesigner}.cpp:
    copy $** $@ 
{}.cpp{$(DMPROOT)\Tutorial}.cpp:
    copy $** $@ 
{}.cpp{$(DMPROOT)\Tutorial2}.cpp:
    copy $** $@ 
{}.cpp{$(DMPROOT)\Uninst}.cpp:
    copy $** $@ 
{}.cpp{$(DMPROOT)\WaveSaveDMO}.cpp:
    copy $** $@ 
{}.cpp{$(DMPROOT)\WaveStripMgr}.cpp:
    copy $** $@ 
{}.cpp{$(DMPROOT)\XboxAddin}.cpp:
    copy $** $@ 
{}.cpp{$(DMPROOT)\XboxSynth}.cpp:
    copy $** $@ 
{}.cpp{$(DMPROOT)\XDmime}.cpp:
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Shared\NodeRefChunk.h ===
#ifndef __STYLEREF_H__
#define __STYLEREF_H__ 1

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "RiffStrm.h"

interface IDMUSProdFramework;
interface IDMUSProdNode;

class CNodeRefChunk {
public:
	CNodeRefChunk( IDMUSProdFramework* pIFramework, IDMUSProdNode* pINode );
	~CNodeRefChunk();

	HRESULT Load( IStream* pIStream );
	HRESULT Save( IStream* pIStream );

	IDMUSProdFramework* m_pIFramework;
	IDMUSProdNode* m_pINode;

protected:
	HRESULT SaveChildNode( IStream* pIStream, IDMUSProdNode *pDocRootNode );
	HRESULT LoadChildNode( IDMUSProdRIFFStream* pIRiffStream, MMCKINFO *pckMain );
	IDMUSProdNode *FindChildNode( IDMUSProdNode *pDocRootNode, const CString *pcstrName, const REFGUID rguidID );
};

#endif //__STYLEREF_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Shared\NodeRefChunk.cpp ===
//	StyleRef.cpp

// This class loads a Reference chunk

#include "stdafx.h"
#include "NodeRefChunk.h"
#include <DMUSProd.h>
#include <dmusici.h>
#include <dmusicf.h>

#define FOURCC_CHILD_NODE_RIFFCHUNK		mmioFOURCC('c','h','n','r')
#define FOURCC_CHILD_NODE_CHUNK			mmioFOURCC('c','h','n','c')

CNodeRefChunk::CNodeRefChunk( IDMUSProdFramework* pIFramework, IDMUSProdNode* pINode )
{
	m_pIFramework = pIFramework;
	ASSERT( m_pIFramework );

	m_pINode = pINode;
	if( m_pINode )
	{
		m_pINode->AddRef();
	}
}

CNodeRefChunk::~CNodeRefChunk()
{
	if( m_pINode )
	{
		m_pINode->Release();
	}
}

HRESULT CNodeRefChunk::Save( IStream* pIStream )
{
	HRESULT hr;

	ASSERT(m_pIFramework);
	ASSERT( m_pINode != NULL );
	if(!m_pIFramework || !m_pINode )
	{
		return E_UNEXPECTED;
	}

	IDMUSProdNode *pDocRootNode = NULL;
	if( SUCCEEDED( m_pINode->GetDocRootNode( &pDocRootNode ) ) )
	{
		if( pDocRootNode )
		{
			pDocRootNode->Release();
		}

		if( (pDocRootNode == m_pINode) || (pDocRootNode == NULL) )
		{
			// Get the IDMUSProdFileRefChunk
			IDMUSProdFileRefChunk*	pIFileRefChunk = NULL;
			hr = m_pIFramework->QueryInterface(IID_IDMUSProdFileRefChunk, (void **)&pIFileRefChunk);
			ASSERT(SUCCEEDED(hr));
			if(FAILED(hr))
			{
				return E_UNEXPECTED;
			}

			// Save the chunk
			hr = pIFileRefChunk->SaveRefChunk(pIStream, m_pINode);
			pIFileRefChunk->Release();
			if(FAILED(hr))
			{
				return E_FAIL;
			}

			return hr;
		}
		else
		{
			return SaveChildNode( pIStream, pDocRootNode );
		}
	}

	return E_FAIL;
}

HRESULT CNodeRefChunk::Load( IStream* pIStream )
{
	HRESULT hr;

	ASSERT(m_pIFramework);
	ASSERT( m_pINode == NULL );
	if(!m_pIFramework)
	{
		return E_UNEXPECTED;
	}

	// Allocate an IDMUSProdRIFFStream
	IDMUSProdRIFFStream* pIRiffStream;
	if( FAILED( AllocRIFFStream( pIStream, &pIRiffStream ) ) )
	{
		return E_FAIL;
	}

	DWORD dwStreamPos = StreamTell( pIStream );

	MMCKINFO ckChunk;
	if( pIRiffStream->Descend( &ckChunk, NULL, 0 ) != 0 )
	{
		pIRiffStream->Release();
		return E_FAIL;
	}

	// Look for a child node chunk
	if( (ckChunk.ckid == FOURCC_RIFF) &&
		(ckChunk.fccType == FOURCC_CHILD_NODE_RIFFCHUNK) )
	{
		// Found a child node chunk - load it
		hr = LoadChildNode( pIRiffStream, &ckChunk );
		pIRiffStream->Release();
	}
	else
	{
		pIRiffStream->Release();

		// Much be a normal refChunk - load it
		StreamSeek( pIStream, dwStreamPos, SEEK_SET );

		// Get the IDMUSProdFileRefChunk
		IDMUSProdFileRefChunk*	pIFileRefChunk = NULL;
		hr = m_pIFramework->QueryInterface(IID_IDMUSProdFileRefChunk, (void **)&pIFileRefChunk);
		ASSERT(SUCCEEDED(hr));
		if(FAILED(hr))
		{
			return E_UNEXPECTED;
		}

		// Load the chunk
		hr = pIFileRefChunk->LoadRefChunk(pIStream, &m_pINode);
		pIFileRefChunk->Release();
		if(FAILED(hr))
		{
			return E_FAIL;
		}
	}

	//ASSERT(m_pINode != NULL);

	return hr;
}

HRESULT CNodeRefChunk::SaveChildNode( IStream* pIStream, IDMUSProdNode *pDocRootNode )
{
	ASSERT( pIStream );
	ASSERT( pDocRootNode );
	ASSERT( m_pINode );

	// Allocate an IDMUSProdRIFFStream
	IDMUSProdRIFFStream* pIRiffStream;
	if( FAILED( AllocRIFFStream( pIStream, &pIRiffStream ) ) )
	{
		return E_FAIL;
	}

	// Create the main RIFF chunk
	MMCKINFO ckMain;
	ckMain.fccType = FOURCC_CHILD_NODE_RIFFCHUNK;
	pIRiffStream->CreateChunk( &ckMain, MMIO_CREATERIFF );

	// Try and get and write the NodeID for the child node
	HRESULT hr = S_OK;
	GUID guidNodeID;
	if( SUCCEEDED( m_pINode->GetNodeId( &guidNodeID ) ) )
	{
		MMCKINFO ckSubChunk;
		ckSubChunk.ckid = DMUS_FOURCC_GUID_CHUNK;
		pIRiffStream->CreateChunk( &ckSubChunk, 0 );

		DWORD cbWritten;
		hr = pIStream->Write( &guidNodeID, sizeof(GUID), &cbWritten );
		if( FAILED( hr ) || (cbWritten != sizeof(GUID)) )
		{
			hr = E_FAIL;
		}

		pIRiffStream->Ascend( &ckSubChunk, 0 );
	}

	// Try and get and write the name of the child node
	BSTR bstrNodeName;
	if( SUCCEEDED( hr ) && SUCCEEDED( m_pINode->GetNodeName( &bstrNodeName ) ) )
	{
		MMCKINFO ckSubChunk;
		ckSubChunk.ckid = DMUS_FOURCC_UNAM_CHUNK;
		pIRiffStream->CreateChunk( &ckSubChunk, 0 );

		CString strNodeName = bstrNodeName;
		::SysFreeString( bstrNodeName );
		hr = SaveMBStoWCS( pIStream, &strNodeName );

		pIRiffStream->Ascend( &ckSubChunk, 0 );
	}

	// Get the IDMUSProdFileRefChunk
	IDMUSProdFileRefChunk*	pIFileRefChunk = NULL;
	if( SUCCEEDED( hr ) && SUCCEEDED( m_pIFramework->QueryInterface(IID_IDMUSProdFileRefChunk, (void **)&pIFileRefChunk) ) )
	{
		// Save the chunk
		hr = pIFileRefChunk->SaveRefChunk(pIStream, pDocRootNode);
		pIFileRefChunk->Release();
	}

	// Clean up
	pIRiffStream->Ascend( &ckMain, 0 );
	pIRiffStream->Release();

	return hr;
}

HRESULT CNodeRefChunk::LoadChildNode( IDMUSProdRIFFStream* pIRiffStream, MMCKINFO *pckMain )
{
	// Get a stream pointer
	IStream *pIStream;
	pIStream = pIRiffStream->GetStream();

	// Initialize the HRESULT
	HRESULT hr = S_OK;

	// The subchunk
	MMCKINFO ckSubChunk;

	// Data identifying the child node
	GUID guidNode;
	ZeroMemory( &guidNode, sizeof(GUID) );
	CString cstrNodeName;
	IDMUSProdNode *pDocRootNode = NULL;

	// Count of byes read and the position just before the current subchunk
	DWORD cbRead, dwStreamPos = StreamTell( pIStream );

	// Iterate through all subchunks in pckMain
	while( pIRiffStream->Descend( &ckSubChunk, pckMain, 0 ) == 0 )
	{
		switch( ckSubChunk.ckid )
		{
		case DMUS_FOURCC_GUID_CHUNK:
			// Read in the node's GUID
			hr = pIStream->Read( &guidNode, sizeof(GUID), &cbRead );
			ASSERT( (cbRead == sizeof(GUID)) && SUCCEEDED( hr ) );
			break;

		case DMUS_FOURCC_UNAM_CHUNK:
			// Read in the node's name
			ReadMBSfromWCS( pIStream, ckSubChunk.cksize, &cstrNodeName );
			break;

		default:
			// Read in the node's DocRoot node
			StreamSeek( pIStream, dwStreamPos, SEEK_SET );

			{
				// Get the IDMUSProdFileRefChunk
				IDMUSProdFileRefChunk*	pIFileRefChunk = NULL;
				hr = m_pIFramework->QueryInterface(IID_IDMUSProdFileRefChunk, (void **)&pIFileRefChunk);
				ASSERT(SUCCEEDED(hr));
				if(SUCCEEDED(hr))
				{
					// Load the chunk
					hr = pIFileRefChunk->LoadRefChunk(pIStream, &pDocRootNode);
					pIFileRefChunk->Release();
				}
			}
			break;
		}
		pIRiffStream->Ascend( &ckSubChunk, 0 );
		dwStreamPos = StreamTell( pIStream );
	}

	/*
	ASSERT( pDocRootNode );
	ASSERT( !cstrNodeName.IsEmpty() );
	ASSERT( !::IsEqualGUID( guidNode, GUID_AllZeros ) );
	*/

	if( pDocRootNode )
	{
		m_pINode = FindChildNode( pDocRootNode, &cstrNodeName, guidNode );
		pDocRootNode->Release();
	}
	pIStream->Release();

	if( m_pINode )
	{
		return S_OK;
	}
	else
	{
		return E_FAIL;
	}
}

IDMUSProdNode *CNodeRefChunk::FindChildNode( IDMUSProdNode *pDocRootNode, const CString *pcstrName, const REFGUID rguidID )
{
	if( pDocRootNode == NULL )
	{
		return NULL;
	}

	// Compare GUIDs
	GUID guidID;
	if( SUCCEEDED( pDocRootNode->GetNodeId( &guidID ) ) &&
		::IsEqualGUID( rguidID, guidID ) )
	{
		// Compare names
		BSTR bstrNodeName;
		if( SUCCEEDED( pDocRootNode->GetNodeName( &bstrNodeName ) ) )
		{
			CString cstrNodeName = bstrNodeName;
			::SysFreeString( bstrNodeName );
			if( pcstrName->Compare( cstrNodeName ) == 0 )
			{
				// Found it - AddRef and return pDocRootNode
				pDocRootNode->AddRef();
				return pDocRootNode;
			}
		}
	}

	// Look in the child nodes
	IDMUSProdNode *pNode = NULL;
	if( SUCCEEDED( pDocRootNode->GetFirstChild( &pNode ) )
	&&	(pNode != NULL) )
	{
		// See if we find it in this child node
		IDMUSProdNode *pNodeToReturn;
		pNodeToReturn = FindChildNode( pNode, pcstrName, rguidID );

		if( pNodeToReturn != NULL )
		{
			// Found it, so release pNode
			pNode->Release();

			// pNodeToReturn was already AddRef()'d
			return pNodeToReturn;
		}

		// Iterate through the rest of the child nodes
		IDMUSProdNode *pNextChild;
		while( SUCCEEDED( pDocRootNode->GetNextChild( pNode, &pNextChild ) )
			   && (pNextChild != NULL) )
		{
			// Release the previous child node
			pNode->Release();

			// See if pNode contains the requested node
			pNodeToReturn = FindChildNode( pNextChild, pcstrName, rguidID );
			if( pNodeToReturn != NULL )
			{
				// Found it, so release pNextChild
				pNextChild->Release();

				// pNodeToReturn was already AddRef()'d
				return pNodeToReturn;
			}

			// Update pOrigChild and try to get the next child node
			pNode = pNextChild;

			pNextChild = NULL;
		}

		// Release the previous child node
		pNode->Release();
	}

	return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Shared\myslider.h ===
/*  MySlider.h
*/

#ifndef _INC_MYSLIDER
#define _INC_MYSLIDER

#define MYSLIDER_MIDIRANGE			1
#define MYSLIDER_LFORANGE			2
#define MYSLIDER_TIMECENTS			3
#define MYSLIDER_VOLUMECENTS		4
#define MYSLIDER_PITCHCENTS			5
#define MYSLIDER_PERCENT			6
#define MYSLIDER_PAN				7
#define MYSLIDER_VOLUME				8
#define MYSLIDER_LFODELAY			9
#define MYSLIDER_NOTE				10
#define MYSLIDER_GROUP				11
#define MYSLIDER_TIMESCALE			12
#define MYSLIDER_FILTERPITCHCENTS	13
#define MYSLIDER_FILTERGAIN			14
#define MYSLIDER_FILTERABSPITCH		15

/*--------------------------------------------------------------------------
MySlider

Creates a slider with optional edit and spinner controls, all linked together.

Slider: control must be in dialog resource, specify ID in Init call

Edit:
- control must be in dialog resource, specify DisplayID in Init call
- call HandleDisplayMessage unless using MySliderCollection

Spinner:
- resource (not control) must be in resource (VC: View\Resource Symbols\New)
- specify SpinnerID in Init call
- call HandleSpinnerMessage unless using MySliderCollection
- watch the edit size, it usually needs to be at least 35 pixels wide
--------------------------------------------------------------------------*/
class MySlider {
public:
    MySlider();
    ~MySlider();
    
    void            SetValue(CWnd *pWnd, long lData);
    BOOL			Init(CWnd *pWnd, UINT nID, UINT nDisplayID, DWORD dwType, long * plData, UINT nSpinnerID = 0);
    bool			Init(CWnd *pWnd, UINT nID, UINT nDisplayID, UINT nSpinnerID, DWORD dwType, long lDefaultValue, UINT uStrRes, long * plData);
    long            SetPosition(CWnd *pWnd, UINT nSBCode, UINT nPos, bool bUpdateDisplay = true);
    void            Update(CWnd *pWnd, bool bUpdateDisplay = true);
	CString			GetPanString(float fPan);
	void			SetDataValueToEdit(long * plData) { m_plData = plData; }

	/* sets the slider position to undetermined */
	void SetUndetermined(CWnd *pWnd);
	
	/* sets the control to the display value and returns new position. If bUpdateDisplay is true, recomputes display text using new position. */
    long SetPositionFromDisplay(CWnd *pWnd, bool bUpdateDisplay);

	/* enables or disables control and display */
	void EnableControl(CWnd *pWnd, bool bEnable);

	/* handles edit notifications to update position */
	void HandleDisplayMessage(CWnd *pWnd, WORD wMsg);

	/* handles spinner notifications to update position */
	void HandleSpinnerMessage(CWnd *pWnd, NMHDR* pNMHDR);

	/* accessors */
	long GetPosition() { return m_lPosition; }
	long GetValue() { return Position2Value(m_lPosition); }
	bool GetFocus() { return m_bFocus; }
	UINT SliderID() { return m_nID; }
	UINT DisplayID() { return m_nDisplayID; }
	UINT SpinnerID() { return m_nSpinnerID; }
	long GetDefaultValue() { return m_lDefaultValue; }
	UINT GetUndoStringID() { return m_uStrRes; }

	/* returns the position corresponding to the value */
	long Value2Position(long lValue);

	/* computes new position given slider change */
	long ComputeNewPositionFromSlider(UINT nSBCode, UINT nPos);
	
private:
	/* returns the value corresponding to the position */
	long Position2Value(long lPosition);

    long            m_lPosition;    // Slider position.
    long*			m_plData;       // Converted data in native format.
    long            m_lBase;        // Base for conversion.
    long            m_lRange;       // Range for slider and spinner
    long            m_lPageSize;    // For slider and spinner
    long            m_lLineSize;	// For slider and spinner
    UINT            m_nID;          // ID for slider control.
    UINT            m_nDisplayID;   // ID for display control.
    DWORD           m_dwType;       // Type of data managed by slider.
    bool			m_bFocus;		// has the focus and accepts display updates
    bool			m_bDisplayEdited; // true if display contents were edited by the user
    bool			m_bUndetermined;	// slider value should be displayed as "----"
	CSpinButtonCtrl *m_pSpinButtonCtrl; // spinner control, if any
	UINT			m_nSpinnerID; // ID for spinner control
	UINT			m_uStrRes;		// ID for undo string
	long			m_lDefaultValue; // default value for Ctrl+click
};


#define dwmscupdfStart		0x1
#define dwmscupdfEnd		0x2

/*--------------------------------------------------------------------------
CSliderCollection

Holds a collection of MySlider objects, and simplifies message processing for host
dialogs. To insert a MySlider control in your dialog:
- make your dialog inherit from CSliderCollection
- instead of calling MySlider.Init, call CSliderCollection.Insert
- add a OnNotify handler to your dialog (ClassWizard), and call OnNotify
- add a OnCommand handler to your dialog (ClassWizard), and call OnCommand
- add a OnHScroll handler to your dialog (ClassWizard), and call OnHScroll
- override the OnSliderUpdate method to process start/end of updates
See WavePropPg.* for a property page example
See PitchDialog.* for a dialog example
--------------------------------------------------------------------------*/
class CSliderCollection {
public:
	CSliderCollection(WORD cMaxSliders);
	~CSliderCollection();

	// this must be called before any other method, and succeed
	void Init(CWnd *pWnd);
	
	/* creates a new slider/edit/spinner control. Returns pointer to spinner control if successful. */
    MySlider *Insert(UINT nID, UINT nDisplayID, UINT nSpinnerID, DWORD dwType,
		long lDefaultValue, UINT uStrRes, long * plData);

	/* handles onCommand messages (for edit controls). If the message was processed, returns true,
		and fills *plResult with the message return value. */
	bool OnCommand(WPARAM wParam, LPARAM lParam, LRESULT *plResult);

	/* handles onNotify messages (for spinner controls). If the message was processed, returns true,
		and fills *plResult with the message return value. */
	bool OnNotify(WPARAM wParam, LPARAM lParam, LRESULT *plResult);

	/* handles OnHScroll messages (for sliders). Returns true if message was handled. Calls
		OnSaveUndoState and OnEndUpdate as necessary. */
	bool OnHScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar);

	// free all contained controls (call on property page switch, when spinners need to be recreated)
	void Free();

	/* called when parameter values start or end changing. Return true on success. This method
		is intended for override.
			dwmscupdfStart: update starts. If you return false, SliderCollection will assume that
							you reset the state, and will call Start again on next update.
			dwmscupdfEnd: update ends. You can do expensive operations there, like commit &
							download. Return value is ignored. */
	virtual bool OnSliderUpdate(MySlider *pms, DWORD dwmscupdf);

private:
	CWnd*		m_pWnd;				// cache the dialog window
	WORD		m_cSliders;			// number of slider controls in m_rgpSliders
	WORD		m_cMaxSliders;		// maximum number of sliders
	MySlider*	m_prgSliders;		// array of sliders
	MySlider*	m_pmsFocus;			// slider in array which has focus, NULL if none
	bool		m_bSaveUndo;		// whether to call undo
};


/*--------------------------------------------------------------------------
Utilities
--------------------------------------------------------------------------*/
void notetostring(DWORD note, char *string);
short stringtonote(char *string);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Shared\midifileIO2.cpp ===
// midifileIO2.cpp
//
// original author: Dave Miller
// orignal project: AudioActive
// modified by: Mark Burton
// Adopted for use in DMUSProducer by: Jeff Fried
// project: DirectMusic
//
#define assert ASSERT
#include "stdafx.h"
#include "Templates.h"
//#include "initguid.h"
//#include "dmperf.h"
#include <dmusici.h>
#include <dmusicf.h>
#include <dmusicc.h>
#include <dmuspriv.h>
//#include "..\dmusic\dmcollec.h"
#include "alist.h"
//#include "dmime_i.c"
//#include "dmime.h"
//#include "..\dmband\dmbndtrk.h"
//#include "..\dmband\bandinst.h"

//#include "Segment.h"
//#include "SegmentComponent.h"

#include "SeqSegmentRiff.h"
#include "curveio.h"
#include "sequenceio.h"
#include "midifileio.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

bool IsGS(DWORD dwBank, DWORD dwInstrument)
{
	BYTE	bMSB, bLSB, bPatch;

	bMSB = (BYTE) ((dwBank & 0x00007F00) >> 8);
	bLSB = (BYTE) (dwBank & 0x0000007F);
	bPatch = (BYTE) (dwInstrument & 0x0000007F);
	
	if (bLSB != 0) return false;

	if ( (bMSB == 0) ) // && (bLSB == 0) 
	{
		if ((dwBank & 0x80000000)) //Drum Kit
		{
			if ((bPatch == 0x0)  ||
				(bPatch == 0x08) ||
				(bPatch == 0x10) ||
				(bPatch == 0x18) ||
				(bPatch == 0x19) ||
				(bPatch == 0x20) ||
				(bPatch == 0x28) ||
				(bPatch == 0x30) || 
				(bPatch == 0x38) )
			{
				return  true;
			}
			else
				return false;
		}
		else return true;//is GM
	}
	// check for GS
	switch (bMSB)
	{
		case 6:
		case 7:
			if (bPatch == 0x7D) return true;
			break;
		case 24:
			if ((bPatch == 0x04) || (bPatch == 0x06)) return true;
			break;
		case 9:
			if ((bPatch == 0x0E) || (bPatch == 0x76) || (bPatch == 0x7D)) return true;
			break;
		case 2:
			if ( (bPatch == 0x66) || (bPatch == 0x78) || ((bPatch > 0x79)&&(bPatch < 0x80) )) return true;
			break;
		case 3:
			if ((bPatch > 0x79) && (bPatch < 0x80)) return true;
			break;
		case 4:
		case 5:
			if ( (bPatch == 0x7A) || ((bPatch > 0x7B)&&(bPatch < 0x7F) )) return true;
			break;
		case 32:
			if ((bPatch == 0x10) ||
				(bPatch == 0x11) ||
				(bPatch == 0x18) ||
				(bPatch == 0x34) ) return true;
			break;
		case 1:
			if ((bPatch == 0x26) ||
				(bPatch == 0x39) ||
				(bPatch == 0x3C) ||
				(bPatch == 0x50) ||
				(bPatch == 0x51) ||
				(bPatch == 0x62) ||
				(bPatch == 0x66) ||
				(bPatch == 0x68) ||
				((bPatch > 0x77) && (bPatch < 0x80))) return true;
				break;
		case 16:
			switch (bPatch)
			{
				case 0x00:
					return true;
					break;
				case 0x04:
					return true;
					break;
				case 0x05:
					return true;
					break;
				case 0x06:
					return true;
					break;
				case 0x10:
					return true;
					break;
				case 0x13:
					return true;
					break;
				case 0x18:
					return true;
					break;
				case 0x19:
					return true;
					break;
				case 0x1C:
					return true;
					break;
				case 0x27:
					return true;
					break;
				case 0x3E:
					return true;
					break;
				case 0x3F:
					return true;
					break;
				default:
					return false;
			}
			break;
		case 8:
			if ((bPatch < 0x07) || ((bPatch == 0x7D)))
			{
				return true;
			}
			else if ((bPatch > 0x3F) && (bPatch < 0x50))
			{
				return false;
			}
			else if ((bPatch > 0x4F) && (bPatch < 0x72)  )
			{
				if ((bPatch == 0x50) || 
					(bPatch == 0x51) ||
					(bPatch == 0x6B))
				{
					return true;
				}
				return false;
			}
			else if ((bPatch > 0x1F) && (bPatch < 0x40))
			{
				if ((bPatch > 0x25) && (bPatch < 0x29) ||
					(bPatch > 0x3C)  ||
					(bPatch == 0x30) || 
					(bPatch == 0x32) )
				{
					return true;
				}
				return false;
			}
			else if ((bPatch > 0x0A) && (bPatch < 0x12) && 
				     (bPatch != 0x0D) && (bPatch != 0x0F))
			{
				return true;
			}
			else if ((bPatch > 0x0F) && (bPatch < 0x20))
			{
				if (bPatch > 0x17)
				{
					return true;
				}
				else if ( (bPatch == 0x13) || (bPatch == 0x15) )
					return true;
				else
					return false;
			}
			break;
		default:
			return false;
	}
	return false;
}



inline bool operator == (const ULARGE_INTEGER& i1, const ULARGE_INTEGER& i2)
{
	if(i1.LowPart == i2.LowPart && i1.HighPart == i2.HighPart)
		return true;
	else
		return false;
}


// One for each MIDI channel 0-15	
DMUS_IO_BANKSELECT_ITEM gBankSelect[NUM_MIDI_CHANNELS];

#ifndef  _CRIFFStream_
// seeks to a 32-bit position in a stream.
HRESULT __inline StreamSeek( LPSTREAM pStream, long lSeekTo, DWORD dwOrigin )
{
	LARGE_INTEGER li;

	if( lSeekTo < 0 )
	{
		li.HighPart = -1;
	}
	else
	{
	li.HighPart = 0;
	}
	li.LowPart = lSeekTo;
	return pStream->Seek( li, dwOrigin, NULL );
}
#endif

short gnPPQN;
IStream* gpTempoStream = NULL;
IStream* gpSysExStream = NULL;
IStream* gpTimeSigStream = NULL;
long	glTimeSig = 1; // flag to see if we should be paying attention to time sigs.
	// this is needed because we only care about the time sigs on the first track to
	// contain them that we read

WORD GetVarLength( LPSTREAM pStream, DWORD& rfdwValue )
{
    BYTE b;
    WORD wBytes;

    if( S_OK != pStream->Read( &b, 1, NULL ) )
    {
		rfdwValue = 0;
		return 0;
    }
    wBytes = 1;
    rfdwValue = b & 0x7f;
    while( ( b & 0x80 ) != 0 )
    {
		if( S_OK != pStream->Read( &b, 1, NULL ) )
		{
			break;
		}
		++wBytes;
		rfdwValue = ( rfdwValue << 7 ) + ( b & 0x7f );
    }
    return wBytes;
}

#ifdef _MAC
static DWORD ConvertTime( DWORD dwTime )
{
	wide d;
	long l;  // storage for the remainder

	if( gnPPQN == DMUS_PPQ )  {
		return dwTime;
	}
	WideMultiply( dwTime, DMUS_PPQ, &d );
	return WideDivide( &d, gnPPQN, &l );
}
#else
static DWORD ConvertTime( DWORD dwTime )
{
    //__int64 d;

    if( gnPPQN == DMUS_PPQ )
    {
		return dwTime;
    }
	/*
    d = dwTime;
    d *= DMUS_PPQ;
    d /= gnPPQN;
	*/
    return MulDiv( dwTime, DMUS_PPQ, gnPPQN );
}
#endif

FullSeqEvent* CompressEventList( FullSeqEvent* lstEvent )
{
    static FullSeqEvent* paNoteOnEvent[16][128];
    FullSeqEvent* pEvent;
    FullSeqEvent* pPrevEvent;
    FullSeqEvent* pNextEvent;
    int nChannel;

	ZeroMemory( paNoteOnEvent, sizeof( paNoteOnEvent ) );
    pPrevEvent = NULL;

    for( pEvent = lstEvent ; pEvent != NULL ; pEvent = pNextEvent )
    {
		pEvent->pTempNext = NULL;
		pNextEvent = pEvent->pNext;
		nChannel = pEvent->bStatus & 0xf;
		if( ( pEvent->bStatus & 0xf0 ) == MIDI_NOTEON )
		{
			// add this event to the end of the list of events based
			// on the event's pitch. Keeping track of multiple events
			// of the same pitch allows us to have overlapping notes
			// of the same pitch, choosing that note on's and note off's
			// follow in the same order.
			if( NULL == paNoteOnEvent[nChannel][pEvent->bByte1] )
			{
				paNoteOnEvent[nChannel][pEvent->bByte1] = pEvent;
			}
			else
			{
				FullSeqEvent* pScan;
				for( pScan = paNoteOnEvent[nChannel][pEvent->bByte1];
					 pScan->pTempNext != NULL; pScan = pScan->pTempNext );
				pScan->pTempNext = pEvent;
			}
		}
		else if( ( pEvent->bStatus & 0xf0 ) == MIDI_NOTEOFF )
		{
			if( paNoteOnEvent[nChannel][pEvent->bByte1] != NULL )
			{
				paNoteOnEvent[nChannel][pEvent->bByte1]->mtDuration =
					pEvent->mtTime - paNoteOnEvent[nChannel][pEvent->bByte1]->mtTime;
				paNoteOnEvent[nChannel][pEvent->bByte1] =
					paNoteOnEvent[nChannel][pEvent->bByte1]->pTempNext;
			}
			if( pPrevEvent == NULL )
			{
				lstEvent = pNextEvent;
			}
			else
			{
				pPrevEvent->pNext = pNextEvent;
			}
			delete pEvent;
			continue;
		}
		pPrevEvent = pEvent;
    }

    for( pEvent = lstEvent ; pEvent != NULL ; pEvent = pEvent->pNext )
    {
		pEvent->mtTime = ConvertTime( pEvent->mtTime );
		if( ( pEvent->bStatus & 0xf0 ) == MIDI_NOTEON )
		{
			pEvent->mtDuration = ConvertTime( pEvent->mtDuration );
			if( pEvent->mtDuration == 0 ) pEvent->mtDuration = 1;
		}
    }

    return lstEvent;
}

static int CompareEvents( FullSeqEvent* pEvent1, FullSeqEvent* pEvent2 )
{
    if( pEvent1->mtTime < pEvent2->mtTime )
    {
		return -1;
    }
    else if( pEvent1->mtTime > pEvent2->mtTime )
    {
		return 1;
    }
    else if( Status(pEvent1->bStatus) != MIDI_SYSX && Status(pEvent2->bStatus) != MIDI_SYSX )
    {
		BYTE bStatus1;
		BYTE bStatus2;

		bStatus1 = (BYTE)( pEvent1->bStatus & 0xf0 );
		bStatus2 = (BYTE)( pEvent2->bStatus & 0xf0 );
		if( bStatus1 == bStatus2 )
		{
			return 0;
		}
		else if( bStatus1 == MIDI_NOTEON )
		{
			return -1;
		}
		else if( bStatus2 == MIDI_NOTEON )
		{
			return 1;
		}
		else if( bStatus1 > bStatus2 )
		{
			return 1;
		}
		else if( bStatus1 < bStatus2 )
		{
			return -1;
		}
    }
    return 0;
}

static FullSeqEvent* MergeEvents( FullSeqEvent* lstLeftEvent, FullSeqEvent* lstRightEvent )
{
    FullSeqEvent  anchorEvent;
    FullSeqEvent* pEvent;

    anchorEvent.pNext = NULL;
    pEvent = &anchorEvent;

    do
    {
	if( CompareEvents( lstLeftEvent, lstRightEvent ) < 0 )
	{
	    pEvent->pNext = lstLeftEvent;
	    pEvent = lstLeftEvent;
	    lstLeftEvent = lstLeftEvent->pNext;
	    if( lstLeftEvent == NULL )
	    {
		pEvent->pNext = lstRightEvent;
	    }
	}
	else
	{
	    pEvent->pNext = lstRightEvent;
	    pEvent = lstRightEvent;
	    lstRightEvent = lstRightEvent->pNext;
	    if( lstRightEvent == NULL )
	    {
		pEvent->pNext = lstLeftEvent;
		lstLeftEvent = NULL;
	    }
	}
    } while( lstLeftEvent != NULL );

    return anchorEvent.pNext;
}

FullSeqEvent* SortEventList( FullSeqEvent* lstEvent )
{
    FullSeqEvent* pMidEvent;
    FullSeqEvent* pRightEvent;

    if( lstEvent != NULL && lstEvent->pNext != NULL )
    {
	pMidEvent = lstEvent;
	pRightEvent = pMidEvent->pNext->pNext;
	if( pRightEvent != NULL )
	{
	    pRightEvent = pRightEvent->pNext;
	}
	while( pRightEvent != NULL )
	{
	    pMidEvent = pMidEvent->pNext;
	    pRightEvent = pRightEvent->pNext;
	    if( pRightEvent != NULL )
	    {
		pRightEvent = pRightEvent->pNext;
	    }
	}
	pRightEvent = pMidEvent->pNext;
	pMidEvent->pNext = NULL;
	return MergeEvents( SortEventList( lstEvent ),
			    SortEventList( pRightEvent ) );
    }
    return lstEvent;
}

static int ComparePatches( DMUS_IO_PATCH_ITEM* pPatch1, DMUS_IO_PATCH_ITEM* pPatch2 )
{
    if( pPatch1->lTime < pPatch2->lTime )
    {
		return -1;
    }
    else if( pPatch1->lTime > pPatch2->lTime )
    {
		return 1;
    }
    else if( pPatch1->byStatus < pPatch2->byStatus)
    {
		return -1;
	}
	else if( pPatch1->byStatus == pPatch2->byStatus)
	{
		return 0;
	}
	else
	{
		return 1;
	}
}

static DMUS_IO_PATCH_ITEM* MergePatches( DMUS_IO_PATCH_ITEM* lstLeftPatch, DMUS_IO_PATCH_ITEM* lstRightPatch )
{
    DMUS_IO_PATCH_ITEM  anchorPatch;
    DMUS_IO_PATCH_ITEM* pPatch;

    anchorPatch.pNext = NULL;
    pPatch = &anchorPatch;

    do
    {
	if( ComparePatches( lstLeftPatch, lstRightPatch ) < 0 )
	{
	    pPatch->pNext = lstLeftPatch;
	    pPatch = lstLeftPatch;
	    lstLeftPatch = lstLeftPatch->pNext;
	    if( lstLeftPatch == NULL )
	    {
		pPatch->pNext = lstRightPatch;
	    }
	}
	else
	{
	    pPatch->pNext = lstRightPatch;
	    pPatch = lstRightPatch;
	    lstRightPatch = lstRightPatch->pNext;
	    if( lstRightPatch == NULL )
	    {
		pPatch->pNext = lstLeftPatch;
		lstLeftPatch = NULL;
	    }
	}
    } while( lstLeftPatch != NULL );

    return anchorPatch.pNext;
}

static DMUS_IO_PATCH_ITEM* SortPatchList( DMUS_IO_PATCH_ITEM* lstPatch )
{
    DMUS_IO_PATCH_ITEM* pMidPatch;
    DMUS_IO_PATCH_ITEM* pRightPatch;

    if( lstPatch != NULL && lstPatch->pNext != NULL )
    {
	pMidPatch = lstPatch;
	pRightPatch = pMidPatch->pNext->pNext;
	if( pRightPatch != NULL )
	{
	    pRightPatch = pRightPatch->pNext;
	}
	while( pRightPatch != NULL )
	{
	    pMidPatch = pMidPatch->pNext;
	    pRightPatch = pRightPatch->pNext;
	    if( pRightPatch != NULL )
	    {
		pRightPatch = pRightPatch->pNext;
	    }
	}
	pRightPatch = pMidPatch->pNext;
	pMidPatch->pNext = NULL;
	return MergePatches( SortPatchList( lstPatch ),
			    SortPatchList( pRightPatch ) );
    }
    return lstPatch;
}

DWORD ReadEvent( LPSTREAM pStream, DWORD dwTime, FullSeqEvent** plstEvent, DMUS_IO_PATCH_ITEM** pplstPatchEvent)
{
    static BYTE bRunningStatus;

    DWORD dwBytes;
    DWORD dwLen;
    FullSeqEvent* pEvent;
	DMUS_IO_PATCH_ITEM* pPatchEvent;
    DMUS_IO_SYSEX_ITEM* pSysEx;

	BYTE* pbSysExData = 0;
    BYTE b;

    if( FAILED( pStream->Read( &b, 1, NULL ) ) )
    {
		return 0;
    }

    if( b < 0x80 )
    {
		StreamSeek( pStream, -1, STREAM_SEEK_CUR );
		b = bRunningStatus;
		dwBytes = 0;
    }
    else
    {
		dwBytes = 1;
    }

    if( b < 0xf0 )
    {
		bRunningStatus = (BYTE)b;

		switch( b & 0xf0 )
		{
		case MIDI_CCHANGE:
		case MIDI_PTOUCH:
		case MIDI_PBEND:
		case MIDI_NOTEOFF:
		case MIDI_NOTEON:
			if( FAILED( pStream->Read( &b, 1, NULL ) ) )
			{
				return dwBytes;
			}
			++dwBytes;

			pEvent = new FullSeqEvent;
			if( pEvent == NULL )
			{
				return 0;
			}

			pEvent->mtTime = dwTime;
			pEvent->mtDuration = 0;
			pEvent->nOffset = 0;
			pEvent->bStatus = bRunningStatus;
			pEvent->bByte1 = b;
//			( (NoteEvent*)pEvent )->voiceid = (char)( ( ( bRunningStatus - 4 ) & 0xf ) + 1 );
			if( FAILED( pStream->Read( &b, 1, NULL ) ) )
			{
				delete pEvent;
				return dwBytes;
			}
			++dwBytes;
			pEvent->bByte2 = b;

			if( ( pEvent->bStatus & 0xf0 ) == MIDI_NOTEON &&
				pEvent->bByte2 == 0 )
			{
				pEvent->bStatus = (BYTE)( MIDI_NOTEOFF | ( pEvent->bStatus & 0xf ) );
			}


			if(((pEvent->bStatus & 0xf0) == MIDI_CCHANGE) && (pEvent->bByte1 == 0 || pEvent->bByte1 == 0x20))
			{
				// We have a bank select or its LSB either of which are not added to event list
				if(pEvent->bByte1 == 0x20)
				{
					gBankSelect[pEvent->bStatus & 0xf].byLSB = pEvent->bByte2;
				}
				else // pEvent->bByte1 == 0
				{
					gBankSelect[pEvent->bStatus & 0xf].byMSB = pEvent->bByte2;
				}
				// We no longer need the event so we can free it
				delete pEvent;
			}
			else // Add to event list
			{
				pEvent->pNext = *plstEvent;
				*plstEvent = pEvent;
			}

			break;

		case MIDI_PCHANGE:
		{
			if(FAILED(pStream->Read(&b, 1, NULL)))
			{
				return dwBytes;
			}
			
			++dwBytes;

			if( pplstPatchEvent )
			{
				pPatchEvent = new DMUS_IO_PATCH_ITEM;

				if(pPatchEvent == NULL)
				{
					return 0;
				}

				pPatchEvent->lTime = ConvertTime(dwTime);
				pPatchEvent->byStatus = bRunningStatus;
				pPatchEvent->byPChange = b;	// byte 0 in dwPatch
				pPatchEvent->byMSB = gBankSelect[bRunningStatus & 0xF].byMSB;
				pPatchEvent->byLSB = gBankSelect[bRunningStatus & 0xF].byLSB;
				pPatchEvent->dwFlags &= 0;
				pPatchEvent->dwFlags |= DMUS_IO_INST_PATCH;

				if(pPatchEvent->byMSB != 0xFF)
				{
					pPatchEvent->dwFlags |= DMUS_IO_INST_BANKSELECT;						
				}
				
				if(pPatchEvent->byLSB != 0xFF)
				{
					pPatchEvent->dwFlags |= DMUS_IO_INST_BANKSELECT;				
				}

				if(!(pPatchEvent->dwFlags & DMUS_IO_INST_BANKSELECT ) )
				{
					// no bank select in effect, defaults to GM
						pPatchEvent->dwFlags |= DMUS_IO_INST_GM;
				}
				else
				{
					// test and set GM/GS flags
					DWORD dwPatch = pPatchEvent->byPChange & 0x7F
													| (pPatchEvent->byLSB & 0x7F) << 8
													| (pPatchEvent->byMSB & 0x7F) << 16;

					DWORD dwInstrument = dwPatch & 0xFF;
					DWORD dwBank = (dwPatch & ~(0x0 | 0xFF)) >> 8;

					if(IsGS(dwBank, dwInstrument))
					{
						pPatchEvent->dwFlags |= DMUS_IO_INST_GS;
						if(dwBank == 0 || (dwBank & ~(0x80000000)) == 0)
						{
							pPatchEvent->dwFlags |= DMUS_IO_INST_GM;
						}
					}
				}

				pPatchEvent->pNext = *pplstPatchEvent;
				pPatchEvent->pIDMCollection = NULL;

				*pplstPatchEvent = pPatchEvent;
			}
			break;
		}
		case MIDI_MTOUCH:
			if( FAILED( pStream->Read( &b, 1, NULL ) ) )
			{
				return dwBytes;
			}
			++dwBytes;
			pEvent = new FullSeqEvent;
			if( pEvent == NULL )
			{
				return 0;
			}

			pEvent->mtTime = dwTime;
			pEvent->mtDuration = 0;
			pEvent->bStatus = bRunningStatus;
			pEvent->bByte1 = b;
//			( (NoteEvent*)pEvent )->voiceid = (char)( ( ( bRunningStatus - 4 ) & 0xf ) + 1 );

			pEvent->pNext = *plstEvent;
			*plstEvent = pEvent;
			break;
		default:
			// this should NOT be possible - unknown midi note event type
			ASSERT(FALSE);
			break;
		}
    }
    else
    {
		switch( b )
		{
		case 0xf0:
			dwBytes += GetVarLength( pStream, dwLen );
			pSysEx = new DMUS_IO_SYSEX_ITEM;
			if( pSysEx != NULL )
			{
//				pSysEx->pbSysExData = new BYTE[dwLen + 1];
				pbSysExData = new BYTE[dwLen + 1];
//				if( pSysEx->pbSysExData != NULL )
				if(pbSysExData != NULL)
				{
//					pSysEx->pbSysExData[0] = 0xf0;
					pbSysExData[0] = 0xf0;
					if( FAILED( pStream->Read( pbSysExData + 1, dwLen, NULL ) ) )
					{
						delete []pbSysExData;
						delete pSysEx;
						return dwBytes;
					}
					pSysEx->dwPChannel = 0;
					pSysEx->mtTime = dwTime;
					DWORD dwTempLen = dwLen + 1;
					pSysEx->dwSysExLength = dwTempLen;
					if( NULL == gpSysExStream )
					{
						// create a stream to hold sysex events
						CreateStreamOnHGlobal( NULL, TRUE, &gpSysExStream );
					}
					if( gpSysExStream )
					{
						// bugbug error checking needs to be here
						gpSysExStream->Write( &pSysEx->mtTime, sizeof(long), NULL );
						gpSysExStream->Write( &pSysEx->dwPChannel, sizeof(DWORD), NULL);
						gpSysExStream->Write( &pSysEx->dwSysExLength, sizeof(DWORD), NULL );
//						gpSysExStream->Write( pSysEx->pbSysExData, pSysEx->dwSysExLength, NULL );
						gpSysExStream->Write( pbSysExData, dwTempLen, NULL );
					}
//					delete pSysEx->pbSysExData;
					delete []pbSysExData;
					delete pSysEx;
				}
				else
				{
					StreamSeek( pStream, dwLen, STREAM_SEEK_CUR );
				}
			}
			else
			{
				StreamSeek( pStream, dwLen, STREAM_SEEK_CUR );
			}
			dwBytes += dwLen;
			break;
		case 0xf7:
			// ignore sysex f7 chunks
			dwBytes += GetVarLength( pStream, dwLen );
			StreamSeek( pStream, dwLen, STREAM_SEEK_CUR );
			dwBytes += dwLen;
			break;
		case 0xff:
			if( FAILED( pStream->Read( &b, 1, NULL ) ) )
			{
				return dwBytes;
			}
			++dwBytes;
			dwBytes += GetVarLength( pStream, dwLen );
			if( b == 0x51 ) // tempo change
			{
				DWORD dw = 0;
				DMUS_IO_TEMPO_ITEM tempo;

				while( dwLen > 0 )
				{
					if( FAILED( pStream->Read( &b, 1, NULL ) ) )
					{
						return dwBytes;
					}
					++dwBytes;
					--dwLen;
					dw <<= 8;
					dw += b;
				}
				tempo.lTime = ConvertTime( dwTime );
				tempo.dblTempo = 60000000 / (double)dw;
				if( NULL == gpTempoStream )
				{
					// create a stream to hold tempo events
					CreateStreamOnHGlobal( NULL, TRUE, &gpTempoStream );
				}
				if( gpTempoStream )
				{
					gpTempoStream->Write( &tempo, sizeof(DMUS_IO_TEMPO_ITEM), NULL );
					// bugbug error checking needs to be here
				}
			}
			else if( b == 0x58 && glTimeSig )
			{
				// glTimeSig will be set to 0 inside the main calling function
				// once we no longer care about time sigs.
				DMUS_IO_TIMESIGNATURE_ITEM timesig;
				if( FAILED( pStream->Read( &b, 1, NULL ) ) )
				{
					return dwBytes;
				}
				// set glTimeSig to 2 to signal to the main function that we've
				// read a time sig on this track
				glTimeSig = 2;
				timesig.lTime = ConvertTime( dwTime );
				timesig.bBeatsPerMeasure = b;
				++dwBytes;
				if( FAILED( pStream->Read( &b, 1, NULL ) ) )
				{
					return dwBytes;
				}
				timesig.bBeat = (BYTE)( 1 << b ); // 0 means 256th note
				timesig.wGridsPerBeat = 0; // this is irrelavent for MIDI files
				if( NULL == gpTimeSigStream )
				{
					CreateStreamOnHGlobal( NULL, TRUE, &gpTimeSigStream );
				}
				if( gpTimeSigStream )
				{
					gpTimeSigStream->Write( &timesig, sizeof(DMUS_IO_TIMESIGNATURE_ITEM), NULL );
				}
				++dwBytes;
				StreamSeek( pStream, dwLen - 2, STREAM_SEEK_CUR );
				dwBytes += ( dwLen - 2 );
			}
			else
			{
				StreamSeek( pStream, dwLen, STREAM_SEEK_CUR );
				dwBytes += dwLen;
			}
			break;
		default:
	//            DisplayDebug( 1, "Unknown midi event type: 0x%x", b );
			break;
		}
    }
    return dwBytes;
}


BOOL NeedDefaultResetValues( CCurveItem* pItem )
{
	BOOL fNeedDefaultResetValues = FALSE;

	switch( pItem->m_bType )
	{
		case DMUS_CURVET_PBCURVE:
		case DMUS_CURVET_PATCURVE:
		case DMUS_CURVET_MATCURVE:
			fNeedDefaultResetValues = TRUE;
			break;
		
		case DMUS_CURVET_CCCURVE:
			switch( pItem->m_bCCData )
			{
				case 1:		// Mod Wheel
				case 2:		// Breath Controller
				case 4:		// Foot Controller
				case 5:		// Portamento Time
				case 12:	// FX1
				case 13:	// FX2
				case 64:	// Sustain Pedal
				case 65:	// Portamento On/Off
				case 66:	// Sostenuto Pedal
				case 67:	// Soft Pedal
				case 68:	// Legato Footswitch
				case 69:	// Hold 2
					fNeedDefaultResetValues = TRUE;
					break;
			}
			break;
	}

	return fNeedDefaultResetValues;
}


void SetDefaultResetValues( CCurveItem* pItem, MUSIC_TIME mtClockLength  )
{
	pItem->m_bFlags &= ~DMUS_CURVE_RESET;	
	pItem->m_nResetValue = 0;	
	pItem->m_mtResetDuration = 0;
	
	switch( pItem->m_bType )
	{
		case DMUS_CURVET_PBCURVE:
			pItem->m_bFlags |= DMUS_CURVE_RESET;	
			pItem->m_nResetValue = 8192;	
			pItem->m_mtResetDuration = mtClockLength;
			break;
		
		case DMUS_CURVET_CCCURVE:
			switch( pItem->m_bCCData )
			{
				case 1:		// Mod Wheel
				case 2:		// Breath Controller
				case 4:		// Foot Controller
				case 5:		// Portamento Time
				case 12:	// FX1
				case 13:	// FX2
				case 64:	// Sustain Pedal
				case 65:	// Portamento On/Off
				case 66:	// Sostenuto Pedal
				case 67:	// Soft Pedal
				case 68:	// Legato Footswitch
				case 69:	// Hold 2
					pItem->m_bFlags |= DMUS_CURVE_RESET;	
					pItem->m_nResetValue = 0;	
					pItem->m_mtResetDuration = mtClockLength;
					break;
			}
			break;

		case DMUS_CURVET_PATCURVE:
		case DMUS_CURVET_MATCURVE:
			pItem->m_bFlags |= DMUS_CURVE_RESET;	
			pItem->m_nResetValue = 0;	
			pItem->m_mtResetDuration = mtClockLength;
			break;
	}
}



HRESULT ReadMidiSequenceFromStream(LPSTREAM pOrigStream,
								  CTypedPtrList<CPtrList, CSequenceItem*>& lstSequences,
								  CTypedPtrList<CPtrList, CCurveItem*>& lstCurves,
								  long	lOffsetTime,
								  DWORD& dwLength)
{
	IStream* pStream;

	pOrigStream->Clone(&pStream);

	if(pStream == NULL)
	{
		return E_POINTER;
	}

	HRESULT hr = S_OK;
    DWORD dwID;
    DWORD dwCurTime;
	DWORD dwSize;
    short nFormat;
    short nNumTracks;
    short nTracksRead;
     FullSeqEvent* lstEvent;
	FullSeqEvent* lstTrackEvent;


    lstEvent = NULL;

    nNumTracks = nTracksRead = 0;
    dwLength = 0;

	FillMemory(&gBankSelect, (sizeof(DMUS_IO_BANKSELECT_ITEM) * NUM_MIDI_CHANNELS), 0xFF);

    if( ( S_OK != pStream->Read( &dwID, sizeof( FOURCC ), NULL ) ) ||
		!GetMLong( pStream, dwSize ) )
    {
		return E_FAIL;
    }
// check for RIFF MIDI files
    if( dwID == mmioFOURCC( 'R', 'I', 'F', 'F' ) )
    {
		StreamSeek( pStream, 12, STREAM_SEEK_CUR );
		if( ( S_OK != pStream->Read( &dwID, sizeof( FOURCC ), NULL ) ) ||
			!GetMLong( pStream, dwSize ) )
		{
			return E_FAIL;
		}
    }
// check for normal MIDI files
	if( dwID != mmioFOURCC( 'M', 'T', 'h', 'd' ) )
	{
		return E_FAIL;
	}

    GetMShort( pStream, nFormat );
    GetMShort( pStream, nNumTracks );
    GetMShort( pStream, gnPPQN );
    if( dwSize > 6 )
    {
		StreamSeek( pStream, dwSize - 6, STREAM_SEEK_CUR );
    }
    pStream->Read( &dwID, sizeof( FOURCC ), NULL );
    while( dwID == mmioFOURCC( 'M', 'T', 'r', 'k' ) )
    {
		GetMLong( pStream, dwSize );
		dwCurTime = 0;
		lstTrackEvent = NULL;
		while( dwSize > 0 )
		{
			dwSize -= GetVarLength( pStream, dwID );
			dwCurTime += dwID;
			dwSize -= ReadEvent( pStream, dwCurTime, &lstTrackEvent, NULL);
		}
		if( glTimeSig > 1 )
		{
			// if glTimeSig is greater than 1, it means we've read some time sigs
			// from this track (it was set to 2 inside ReadEvent.) This means that
			// we no longer want ReadEvent to pay any attention to time sigs, so
			// we set this to 0.
			glTimeSig = 0;
		}
		if( dwCurTime > dwLength )
		{
			dwLength = dwCurTime;
		}
		lstTrackEvent = SortEventList( lstTrackEvent );
		lstTrackEvent = CompressEventList( lstTrackEvent );
		lstEvent = List_Cat( lstEvent, lstTrackEvent );
		if( FAILED( pStream->Read( &dwID, sizeof( FOURCC ), NULL ) ) )
		{
			break;
		}
    }
	dwLength = ConvertTime(dwLength);

    lstEvent = SortEventList( lstEvent );


	if(lstEvent)
	{

		// bugbug could be checking to see if there are actually tempo events,
		// sysex events, etc. to see if it's really necessary to create these
		// tracks...
		// Create a Tempo Track chunk in which to store the tempo events
		if( gpTempoStream )
		{
			// nothing to do
		}


		// sort list
//		lstEvent = SortEventList(lstEvent); 

		// Create a Sequence Track in which to store the notes, curves
		// and SysEx events.
		//
		CSequenceItem* pItem;
		CCurveItem* pCurveItem;
		dwLength = 0;
		if(hr == S_OK)
		{
			for(FullSeqEvent* pEvent = lstEvent; pEvent; pEvent = pEvent->pNext )
			{
				pEvent->mtTime += lOffsetTime;

				if( (Status(pEvent->bStatus) == MIDI_PBEND)
				||  (Status(pEvent->bStatus) == MIDI_PTOUCH)
				||  (Status(pEvent->bStatus) == MIDI_MTOUCH)
				||  (Status(pEvent->bStatus) == MIDI_CCHANGE) )
				{
					pCurveItem = new CCurveItem( pEvent );
					if( pCurveItem )
					{
						lstCurves.AddTail( pCurveItem );
					}
				}
				else
				{
					pItem = new CSequenceItem( pEvent );
					if( pItem )
					{
						lstSequences.AddTail( pItem );
					}
				}
				
				if( dwLength < (DWORD)(pEvent->mtTime + pEvent->mtDuration) )
				{
					dwLength = pEvent->mtTime + pEvent->mtDuration;
				}
			}
		}

		if( gpSysExStream && hr == S_OK)
		{
			// nothing to do
		}

		if( gpTimeSigStream && hr == S_OK)
		{
			// nothing to do
		}
	}
	else
	{
		hr = E_POINTER;
	}
	

	List_Free( lstEvent );

	// release our hold on the streams
	if(gpTempoStream)
		gpTempoStream->Release();
	if(gpSysExStream)
		gpSysExStream->Release();
	if(gpTimeSigStream)
		gpTimeSigStream->Release();
	gpTempoStream = NULL;
	gpSysExStream = NULL;
	gpTimeSigStream = NULL;
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Shared\myslider.cpp ===
/*
    MySlider.cpp

*/

#include "stdafx.h"
#include "myslider.h"
#include <math.h>
#include "DLSLoadSaveUtils.h"

MySlider::MySlider():
    m_lPosition(0), m_plData(0), m_lBase(0), m_lRange(100), m_lPageSize(10), m_lLineSize(1), m_nID(0), m_nDisplayID(0),
	m_bFocus(false), m_bDisplayEdited(false), m_pSpinButtonCtrl(NULL), m_nSpinnerID(0), m_lDefaultValue(0), m_uStrRes(0),
	m_bUndetermined(false)
{}

MySlider::~MySlider()
{
	if (m_pSpinButtonCtrl)
		delete m_pSpinButtonCtrl;
}

void MySlider::Update(CWnd *pWnd, bool bUpdateDisplay)
{
	// update slider
    CSliderCtrl* pControl = (CSliderCtrl*) pWnd->GetDlgItem(m_nID);
    if (pControl)
		pControl->SetPos(m_lPosition);

	// update spinner
	if (m_pSpinButtonCtrl)
		m_pSpinButtonCtrl->SetPos(m_lPosition);

	// update data and compute display string
    char text[100];
    long lTemp = 0;
    double flTemp = 0;

	if (m_bUndetermined)
		strcpy(text, "-----------");
	else switch(m_dwType)
		{
		case MYSLIDER_MIDIRANGE :
		{
			break;
		}

		case MYSLIDER_LFORANGE :
		{
			*m_plData = (m_lPosition + m_lBase) << 16;
			lTemp = PitchCents2Hertz(*m_plData);
			sprintf(text," %02d.%03d",lTemp / 1000, lTemp % 1000);
			break;
		}

		case MYSLIDER_FILTERABSPITCH :
		{
			lTemp = m_lPosition + m_lBase;
			*m_plData = lTemp << 16;
			sprintf(text," %02d", lTemp);
			break;
		}

		case MYSLIDER_TIMECENTS :
		case MYSLIDER_LFODELAY :
		{
			*m_plData = (m_lPosition + m_lBase) << 16;
			lTemp = TimeCents2Mils(*m_plData);
			sprintf(text," %02d.%03d",lTemp / 1000, lTemp % 1000);
			break;
		}

		case MYSLIDER_FILTERGAIN :
		case MYSLIDER_VOLUMECENTS :
		case MYSLIDER_VOLUME :
		{
			*m_plData = (m_lPosition + m_lBase) << 16;
			lTemp = m_lPosition + m_lBase;
			if (lTemp < 0)
			{
				lTemp = -lTemp;
				sprintf(text,"-%02d.%01d",lTemp / 10, lTemp % 10);
			}
			else 
			{
				sprintf(text," %02d.%01d",lTemp / 10, lTemp % 10);
			}
			break;
		}

		case MYSLIDER_FILTERPITCHCENTS :
		{
			*m_plData = (m_lPosition + m_lBase) << 16;
			lTemp = m_lPosition + m_lBase;
			if (lTemp < 0)
			{
				sprintf(text,"-%d",-lTemp);
			}
			else
			{
				sprintf(text," %d",lTemp);
			}
			break;
		}

		case MYSLIDER_PITCHCENTS :
		{
			*m_plData = (m_lPosition + m_lBase) << 16;
			lTemp = m_lPosition + m_lBase;
			if (lTemp < 0)
			{
				lTemp = -lTemp;
				sprintf(text,"-%02d.%02d",lTemp / 100, lTemp % 100);
			}
			else
			{
				sprintf(text," %02d.%02d",lTemp / 100, lTemp % 100);
			}
			break;
		}

		case MYSLIDER_PERCENT :
		{
			*m_plData = m_lPosition << 16;
			sprintf(text," %02d",m_lPosition / 10);
			break;
		}

		case MYSLIDER_PAN :
		{
			*m_plData = (m_lPosition + m_lBase) << 16;
			CString sPanString = GetPanString((float)(m_lPosition + m_lBase) / 10);
			sprintf(text, sPanString);
				
			break;
		}

		case MYSLIDER_NOTE :
		{
			*m_plData = m_lPosition;
			sprintf(text," %ld = ",m_lPosition);
			notetostring( (DWORD) m_lPosition, &text[strlen(text)]);
			break;
		}

		case MYSLIDER_GROUP :
		{
			*m_plData = m_lPosition;
			if (m_lPosition == 0)
			{
				strcpy(text," No Group");
			}
			else
			{
				sprintf(text," Group %ld",m_lPosition);
			}
			break;
		}

		case MYSLIDER_TIMESCALE :
		{
			*m_plData = (m_lPosition + m_lBase) << 16;
			lTemp = m_lPosition + m_lBase;
			flTemp = lTemp / 1200.0;
			flTemp = pow(2.0,flTemp);
			if (lTemp < 0)
			{
				sprintf(text," (%04.3f->1) * Time",flTemp);
			}
			else
			{
				sprintf(text," (1->%05.2f) * Time",flTemp);
			}
			break;
		}

		default :
		{
			strcpy(text," Error");
			break;
		}
    }

	// update display
	if (bUpdateDisplay)
		{
		CWnd* pDisplay = pWnd->GetDlgItem(m_nDisplayID);
		if (pDisplay)
			pDisplay->SetWindowText(text);
		}
}

/**
	Gets the String to be displayed for a Pan value. 
	(0 is extreme Left, 63 Mid and 127 extreme Right)
*/
CString MySlider::GetPanString(float fPan)
{
	CString sPanString;
	if(fPan < 0)
		sPanString.Format("L%2.1f%%%%", 0 - fPan); 
	else if(fPan > 0)
		sPanString.Format("R%2.1f%%%%", fPan);
	else if(fPan == 0)
		sPanString.Format("Mid");
	else
		sPanString.Format("---");

	return sPanString;
}


BOOL MySlider::Init(CWnd *pWnd, UINT nID, UINT nDisplayID, 
                    DWORD dwType, long * plData, UINT nSpinnerID)
{
    CSliderCtrl *pControl = (CSliderCtrl *)
        pWnd->GetDlgItem(nID);
    m_lPageSize = 100;
    m_lLineSize = 10;

    if (pControl != NULL)
    {
        m_plData = plData;
        m_nID = nID;
        m_nDisplayID = nDisplayID;
        m_dwType = dwType;
        switch (dwType)
        {
			case MYSLIDER_MIDIRANGE :
			{
				m_lBase = 0;
				m_lRange = 127;
				m_lPageSize = 12;
				m_lLineSize = 1;
				break;
			}

			case MYSLIDER_LFORANGE :
			{
				m_lBase = -7625;
				//m_lRange = 7973;
				m_lRange = 9174;
				break;
			}

			case MYSLIDER_TIMECENTS :
			{
				m_lBase = -11960;
				m_lRange = 18347;
				break;
			}

			case MYSLIDER_VOLUMECENTS :
			{
				m_lBase = 0;
				m_lRange = 120;
				m_lPageSize = 10;
				m_lLineSize = 1;
				break;
			}

			case MYSLIDER_FILTERGAIN :
			{
				m_lBase = 0;
				m_lRange = 225;
				m_lPageSize = 10;
				m_lLineSize = 1;
				break;
			}

			case MYSLIDER_PITCHCENTS :
			{
				m_lBase = -1200;
				m_lRange = 2400;
				m_lLineSize = 1;
				break;
			}

			case MYSLIDER_FILTERPITCHCENTS :
			{
				m_lBase = -12800;
				m_lRange = 25600;
				m_lLineSize = 1;
				break;
			}

			case MYSLIDER_FILTERABSPITCH:
			{
				m_lBase = 5535;
				m_lRange = 6386;
				m_lLineSize = 1;
				break;
			}

			case MYSLIDER_PERCENT :
			{
				m_lBase = 0;
				m_lRange = 1000;
				break;
			}

			case MYSLIDER_PAN :
			{
				m_lBase = -500;	// 
				m_lRange = 1000;	// Hard right
				m_lLineSize = 1;
				m_lPageSize = 10;
				break;
			}

			case MYSLIDER_VOLUME :
			{
				m_lBase = -960;
				m_lRange = 960;
				m_lPageSize = 10;
				m_lLineSize = 1;
				break;
			}

			case MYSLIDER_LFODELAY :
			{
				m_lBase = -11960;
				m_lRange = 15947;
				break;
			}

			case MYSLIDER_NOTE :
			{
				m_lBase = 0;
				m_lRange = 127;
				m_lLineSize = 1;
				m_lPageSize = 12;
				break;
			}

			case MYSLIDER_GROUP :
			{
				m_lBase = 0;
				m_lRange = 15;
				m_lLineSize = 1;
				m_lPageSize = 3;
				break;
			}

			case MYSLIDER_TIMESCALE :
			{
				m_lBase = -4800;
				m_lRange = 9600;
				m_lPageSize = 1200;
				m_lLineSize = 12;
				break;
			}
        }
        pControl->SetRange(0,m_lRange,FALSE);
        pControl->SetLineSize(m_lLineSize);
        pControl->SetPageSize(m_lPageSize);
        m_nID = nID;
        m_nDisplayID = nDisplayID;

		// create spinner control on the fly
		if (nSpinnerID != 0)
			{
		    CWnd* pDisplay = pWnd->GetDlgItem(nDisplayID);
		    if (pDisplay)
		    	{
				// create a spinner control attached to the display
				ASSERT(m_pSpinButtonCtrl == NULL); // I don't expect multiple Init calls, call SetValue instead
				m_pSpinButtonCtrl = new CSpinButtonCtrl();
				if (!m_pSpinButtonCtrl)
					return FALSE;
					
				RECT rc;
				m_pSpinButtonCtrl->Create(WS_VISIBLE | UDS_ARROWKEYS | UDS_ALIGNRIGHT, rc, pWnd, nSpinnerID);
				m_pSpinButtonCtrl->SetBuddy(pDisplay);
		    	m_nSpinnerID = nSpinnerID;
				}
			}

		// initialize spinner parameters too
		if (m_pSpinButtonCtrl)
			{
			m_pSpinButtonCtrl->SetRange(m_lBase, m_lRange);
			UDACCEL rguda[2];
			rguda[0].nSec = 0;
			rguda[0].nInc = m_lLineSize; // increment by m_lLineSize at first
			rguda[1].nSec = 2;
			rguda[1].nInc = m_lPageSize; // increment by m_lPageSize after two seconds
			m_pSpinButtonCtrl->SetAccel(2, rguda);
			}

        SetValue(pWnd, *plData);
        return (TRUE);
    }
    return (FALSE);
}

bool MySlider::Init(CWnd *pWnd, UINT nID, UINT nDisplayID, UINT nSpinnerID, DWORD dwType, long lDefaultValue, UINT uStrRes, long * plData)
{
	if (!Init(pWnd, nID, nDisplayID, dwType, plData, nSpinnerID))
		return false;
	m_lDefaultValue = lDefaultValue;
	m_uStrRes = uStrRes;
	return true;
}

void MySlider::SetValue(CWnd *pWnd, long lData)
{
    CSliderCtrl *pControl = (CSliderCtrl *)
        pWnd->GetDlgItem(m_nID);

    if (pControl != NULL)
    {
		m_bUndetermined = false;
    	m_lPosition = Value2Position(lData);
		if (m_lPosition > m_lRange)
			m_lPosition = m_lRange;
		else if (m_lPosition < 0)
			m_lPosition = 0;

		// turn off focus flag to prevent edit control from processing EN_CHANGE
		bool bFocusSav = m_bFocus;
		m_bFocus = false;
	
        SetPosition(pWnd, TB_THUMBPOSITION, (UINT)m_lPosition);

		// reset focus flag
		m_bFocus = bFocusSav;
    }
}

/* computes new position given slider change */
long MySlider::ComputeNewPositionFromSlider(UINT nSBCode, UINT nPos)
{
	long lPosition;
    switch (nSBCode)
    {
		case TB_THUMBPOSITION:
		case TB_THUMBTRACK:
		{
			lPosition = nPos;
			break;
		}

		case TB_LINEDOWN:
		{
			lPosition = m_lPosition+m_lLineSize;
			break;
		}

		case TB_PAGEDOWN:
		{
			lPosition = m_lPosition+m_lPageSize;
			break;
		}

		case TB_LINEUP:
		{
			lPosition = m_lPosition-m_lLineSize;
			break;
		}

		case TB_PAGEUP:
		{
			lPosition = m_lPosition-m_lPageSize;
			break;
		}

		case TB_TOP:
		{
			lPosition = 0;
			break;
		}

		case TB_BOTTOM:
		{
			lPosition = m_lRange;
			break;
		}

		default:
		{
			lPosition = m_lPosition;
		}
    }

	if (lPosition > m_lRange)
		lPosition = m_lRange;
	else if (lPosition < 0)
		lPosition = 0;
	return lPosition;
}

long MySlider::SetPosition(CWnd *pWnd, UINT nSBCode, UINT nPos, bool bUpdateDisplay)
{
	m_bUndetermined = false;
	m_lPosition = ComputeNewPositionFromSlider(nSBCode, nPos);
    Update(pWnd, bUpdateDisplay);
    return m_lPosition;
}

/* sets the control to the display value and returns new position. If bUpdateDisplay is true, recomputes display text using new position. */
long MySlider::SetPositionFromDisplay(CWnd *pWnd, bool bUpdateDisplay)
{
	// if no focus, refuse all updates
	if (!m_bFocus)
		return m_lPosition;

    CSliderCtrl* pControl = (CSliderCtrl*) pWnd->GetDlgItem(m_nID);
    CWnd* pDisplay = pWnd->GetDlgItem(m_nDisplayID);
    UINT nPos;

	ASSERT(pControl);
	ASSERT(pDisplay);

	// get string from display control
   	TCHAR szText[50];
   	ASSERT(pDisplay->GetWindowTextLength() < sizeof(szText)/sizeof(szText[0])); // control text won't fit in szText
	if (pDisplay->GetWindowText(szText, sizeof(szText)/sizeof(TCHAR)) == 0)
		{
		// an empty string is considered zero
		// FUTURE: use default slider value instead
		szText[0] = '0';
		szText[1] = 0;
		}

	// convert from text string to control position
	float f;
    switch(m_dwType)
		{
		case MYSLIDER_LFORANGE :
			sscanf(szText, "%f", &f);
			nPos = (Hertz2PitchCents((int)(f*1000)) >> 16) - m_lBase;
			break;

		case MYSLIDER_PITCHCENTS :
			sscanf(szText, "%f", &f);
			nPos = (int)(f*100)-m_lBase;
			break;

		case MYSLIDER_FILTERPITCHCENTS :
		case MYSLIDER_FILTERABSPITCH :
			{
			int i;
			sscanf(szText, "%d", &i);
			nPos = i-m_lBase;
			break;
			}

		case MYSLIDER_PAN :
			{
			// remove percent sign if present
			TCHAR *pch = szText;
			while (*pch)
				{
				if (*pch == '%')
					{
					*pch = 0;
					break;
					}
				pch++;
				}

			// skip leading spaces
			pch = szText;
			while (*pch && (*pch == ' '))
				pch++;
			
			// get signed float value (L is negative, R positive)
			switch (*pch)
				{
				case '-':
				case 'l':
				case 'L':
					// left
					sscanf(pch+1, "%f", &f);
					f = -f;
					break;

				case '+':
				case 'r':
				case 'R':
					// right
					pch++;
					// fall thru

				default:
					// right or mid (any string that can't be parsed is considered mid)
					sscanf(pch, "%f", &f);
				}

			// convert to slider position
			nPos = int(f*10)-m_lBase;
			break;
			}
		
		case MYSLIDER_FILTERGAIN :
		case MYSLIDER_VOLUMECENTS :
		case MYSLIDER_VOLUME :
			sscanf(szText, "%f", &f);
			nPos = (int)(f*10)-m_lBase;
			break;

		case MYSLIDER_TIMECENTS :
		case MYSLIDER_LFODELAY :
			sscanf(szText, "%f", &f);
			nPos = (Mils2TimeCents((DWORD)(f*1000)) >> 16) - m_lBase;
			break;

		default:
			ASSERT(FALSE); // slider type not implemented
			return m_lPosition;
		}
        
	SetPosition(pWnd, TB_THUMBPOSITION, nPos, bUpdateDisplay);
	return m_lPosition;
}

/* enables or disables display window */
void MySlider::EnableControl(CWnd *pWnd, bool bEnable)
{
	// control
    CSliderCtrl* pControl = (CSliderCtrl*) pWnd->GetDlgItem(m_nID);
	if (pControl)
		pControl->EnableWindow(bEnable);

	// display
	CWnd* pDisplay = pWnd->GetDlgItem(m_nDisplayID);
	if (pDisplay)
		pDisplay->EnableWindow(bEnable);

	// spinner
	if (m_pSpinButtonCtrl)
		m_pSpinButtonCtrl->EnableWindow(bEnable);
}

/* handles edit notifications to update position */
void MySlider::HandleDisplayMessage(CWnd *pWnd, WORD wMsg)
{
	switch (wMsg)
		{
		case EN_SETFOCUS:
			ASSERT(!m_bFocus);
			m_bFocus = true;
			m_bDisplayEdited = false;
			break;
				
		case EN_CHANGE:
			if (m_bFocus)
				{
				SetPositionFromDisplay(pWnd, false);
				m_bDisplayEdited = true;
				}
			break;
				
		case EN_KILLFOCUS:
			ASSERT(m_bFocus);
			if (m_bDisplayEdited)
				SetPositionFromDisplay(pWnd, true);
			m_bFocus = false;
			break;
		}
}

/* handles spinner notifications to update position */
void MySlider::HandleSpinnerMessage(CWnd *pWnd, NMHDR* pNMHDR)
{
	NM_UPDOWN* pNMUpDown = (NM_UPDOWN*)pNMHDR;

	// turn off focus flag to prevent edit control from processing EN_CHANGE
	bool bFocusSav = m_bFocus;
	m_bFocus = false;
	
	SetPosition(pWnd, TB_THUMBPOSITION, pNMUpDown->iPos+pNMUpDown->iDelta);

	// reset focus flag
	m_bFocus = bFocusSav;
	
	// update message with new position
	pNMUpDown->iPos = m_lPosition;
	pNMUpDown->iDelta = 0;
}

long MySlider::Value2Position(long lValue)
{
	switch (m_dwType)
        {
		case MYSLIDER_MIDIRANGE :
		case MYSLIDER_NOTE :
		case MYSLIDER_GROUP :
			return lValue;

		case MYSLIDER_LFORANGE :
		case MYSLIDER_TIMECENTS :
		case MYSLIDER_VOLUMECENTS :
		case MYSLIDER_FILTERGAIN :
		case MYSLIDER_PITCHCENTS :
		case MYSLIDER_FILTERPITCHCENTS :
		case MYSLIDER_VOLUME :
		case MYSLIDER_LFODELAY :
		case MYSLIDER_TIMESCALE :
			return ((lValue + 32768) >> 16) - m_lBase;

		case MYSLIDER_FILTERABSPITCH:
		case MYSLIDER_PAN :
			return (lValue >> 16) - m_lBase;

		case MYSLIDER_PERCENT :
			return lValue >> 16;

		default:
			ASSERT(FALSE); // slider type not handled
			return 0;
    }
}

/* returns the value corresponding to the position */
long MySlider::Position2Value(long lPosition)
{
	switch (m_dwType)
        {
		case MYSLIDER_MIDIRANGE :
		case MYSLIDER_NOTE :
		case MYSLIDER_GROUP :
			return lPosition;

		case MYSLIDER_LFORANGE :
		case MYSLIDER_TIMECENTS :
		case MYSLIDER_VOLUMECENTS :
		case MYSLIDER_FILTERGAIN :
		case MYSLIDER_PITCHCENTS :
		case MYSLIDER_FILTERPITCHCENTS :
		case MYSLIDER_VOLUME :
		case MYSLIDER_LFODELAY :
		case MYSLIDER_TIMESCALE :
			return ((lPosition + m_lBase) << 16) - 32768;

		case MYSLIDER_FILTERABSPITCH:
		case MYSLIDER_PAN :
			return (lPosition + m_lBase) << 16;

		case MYSLIDER_PERCENT :
			return lPosition << 16;

		default:
			ASSERT(FALSE); // slider type not handled
			return 0;
    }
}

void MySlider::SetUndetermined(CWnd *pWnd)
{
	m_bUndetermined = true;
	m_lPosition = Value2Position(m_lDefaultValue);
    Update(pWnd, true);
}


/*==============================================================*/
/*  CSliderCollection
/*==============================================================*/
CSliderCollection::CSliderCollection(WORD cMaxSliders):
	m_pWnd(NULL), m_cSliders(0), m_cMaxSliders(cMaxSliders),
	m_prgSliders(NULL), m_pmsFocus(NULL), m_bSaveUndo(true)
{
	ASSERT(cMaxSliders > 0); // must be positive
}

CSliderCollection::~CSliderCollection()
{
	Free();
}

void CSliderCollection::Init(CWnd *pWnd)
{
	ASSERT(m_pWnd == NULL); // Init must be called just once
	m_pWnd = pWnd;
}
	
/* creates a new slider/edit/spinner control. Returns pointer to spinner control if successful. */
MySlider *CSliderCollection::Insert(UINT nID, UINT nDisplayID, UINT nSpinnerID, DWORD dwType,
		long lDefaultValue, UINT uStrRes, long * plData)
{
	ASSERT(m_pWnd); // Init must have been called
	
	if (m_cSliders == m_cMaxSliders)
		{
		ASSERT(FALSE); // array is full
		return NULL;
		}

	// create the array if this is the first slider
	if (m_prgSliders == NULL)
		{
		ASSERT(m_cMaxSliders > 0); // must be positive
		m_prgSliders = new MySlider[m_cMaxSliders]; // this calls the MySlider constructor on each array element
		if (m_prgSliders == NULL)
			return NULL;
		}

#if _DEBUG
	// verify that a slider of this ID isn't in the array yet
	for (int iSlider = 0; iSlider < m_cSliders; iSlider++)
		if (m_prgSliders[iSlider].SliderID() == nID)
			{
			ASSERT(FALSE); // duplicate slider ID
			return NULL;
			}
	
#endif

	// initialize control
	MySlider *pSlider = &m_prgSliders[m_cSliders];
	if (!pSlider->Init(m_pWnd, nID, nDisplayID, nSpinnerID, dwType, lDefaultValue, uStrRes, plData))
		return NULL;
	
	m_cSliders++;
	return pSlider;
}

/* handles onCommand messages (for edit controls). If the message was processed, returns true,
	and fills *plResult with the message return value. */
bool CSliderCollection::OnCommand(WPARAM wParam, LPARAM lParam, LRESULT *plResult)
{
	lParam; // unreferenced
	ASSERT(m_pWnd); // Init must have been called
	ASSERT(plResult);

	int iSlider;
	WORD wMsg = HIWORD(wParam);
	UINT nDisplayID = LOWORD(wParam);

	switch (wMsg)
		{
		case EN_SETFOCUS:
			ASSERT(m_pmsFocus == NULL); // focus shouldn't have been set yet

			// a slider just got the focus, find out which one it is
			for (iSlider = 0; iSlider < m_cSliders; iSlider++)
				if (m_prgSliders[iSlider].DisplayID() == nDisplayID)
					break;
			if (iSlider == m_cSliders)
				return false; // message not handled

			m_pmsFocus = &m_prgSliders[iSlider];

			// FALL THRU

		case EN_CHANGE:
		case EN_KILLFOCUS:
			// ignore message if it's not for us
			if ((m_pmsFocus == NULL) || (m_pmsFocus->DisplayID() != nDisplayID))
				return false;

			if (m_bSaveUndo && (wMsg == EN_CHANGE) && m_pmsFocus->GetFocus())
				{
				if (!OnSliderUpdate(m_pmsFocus, dwmscupdfStart))
					return true; // handled

				m_bSaveUndo = false;
				}

			m_pmsFocus->HandleDisplayMessage(m_pWnd, wMsg);

			// kill focus
			if (wMsg == EN_KILLFOCUS)
				{
				OnSliderUpdate(m_pmsFocus, dwmscupdfEnd);
				m_bSaveUndo = true;
				m_pmsFocus = NULL;
				}

			*plResult = 0; // message processed
			return true;
		}

	return false; // message not handled
}

/* handles onNotify messages (for spinner controls). If the message was processed, returns true,
	and fills *plResult with the message return value. */
bool CSliderCollection::OnNotify(WPARAM wParam, LPARAM lParam, LRESULT *plResult)
{
	ASSERT(m_pWnd); // Init must have been called
	ASSERT(plResult);
	
	NMHDR *pNMHDR = (NMHDR *)lParam;
	if (pNMHDR->code == UDN_DELTAPOS)
		{
		// find slider if it's one of ours
		for (int iSlider = 0; iSlider < m_cSliders; iSlider++)
			if (m_prgSliders[iSlider].SpinnerID() == LOWORD(wParam))
				break;
		if (iSlider == m_cSliders)
			return false; // not handled

		if (m_bSaveUndo)
			{
			if (!OnSliderUpdate(&m_prgSliders[iSlider], dwmscupdfStart))
				return true; // handled

			m_bSaveUndo = false;
			}

		m_prgSliders[iSlider].HandleSpinnerMessage(m_pWnd, pNMHDR);
		*plResult = 0; // allow the spin control to update to the values in pNMHDR
		return true;
		}
	
	return false; // caller should call its handler
}

// free all contained controls (call on property page switch, when spinners need to be recreated)
void CSliderCollection::Free()
{
	delete[] m_prgSliders; // this calls the MySlider destructor on each element
	m_prgSliders = NULL;
	m_cSliders = NULL;
	m_bSaveUndo = true;
}

bool CSliderCollection::OnHScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar)
{
	if (pScrollBar == NULL)
		return false; // not handled

	// find slider if it's one of ours
	UINT nID = (UINT)pScrollBar->GetDlgCtrlID();
	for (int iSlider = 0; iSlider < m_cSliders; iSlider++)
		if (m_prgSliders[iSlider].SliderID() == nID)
			break;
	if (iSlider == m_cSliders)
		return false; // not handled

	MySlider *pms = &m_prgSliders[iSlider];

	if (GetKeyState(VK_CONTROL) & 0x1000)
		{
		nPos = pms->Value2Position(pms->GetDefaultValue());
		if (nSBCode != TB_ENDTRACK)
			nSBCode = TB_THUMBPOSITION;
		}

	long lPosition = pms->ComputeNewPositionFromSlider(nSBCode, nPos);
	if (m_bSaveUndo && (lPosition == pms->GetPosition()))
		{
		pms->SetPosition(m_pWnd, nSBCode, nPos);
		return true; // handled, no change in position
		}

	if ( m_bSaveUndo )
		{
		if (!OnSliderUpdate(pms, dwmscupdfStart))
			return true; // handled, even though we're not setting position
					
		m_bSaveUndo = false;
		}

	pms->SetPosition(m_pWnd, nSBCode, nPos);

	if ( TB_ENDTRACK == nSBCode )
		{
		OnSliderUpdate(pms, dwmscupdfEnd);
		m_bSaveUndo = true;
		}

	return true;
}

/* called when parameter values start or end changing. Return true on success. This method
	is intended for override.
		dwmscupdfStart: update starts. If you return false, SliderCollection will assume that
						you reset the state, and will call Start again on next update.
		dwmscupdfEnd: update ends. You can do expensive operations there, like commit &
						download. Return value is ignored. */
bool CSliderCollection::OnSliderUpdate(MySlider *pms, DWORD dwmscupdf)
{
	pms; // unused
	dwmscupdf; // unused
	return true;
}


/*==============================================================*/
/*  Utilities
/*==============================================================*/
const char *convert[] = { "C","C#","D","D#","E","F","F#","G","G#","A","A#","B" } ;

void notetostring( DWORD note, char *string )
{
    int octave ;
    int dontoctave = note & 0x100 ;

    note  &= 0xFF ;
    octave = note / 12 ;
    note   = note % 12 ;

    strcpy( string, convert[note] ) ;

    if( dontoctave )
        return ;

    wsprintf( &string[lstrlen(string)], "%1d", octave ) ;
    
}   /* end of notetostring() */

short stringtonote(char *string)
{
    char letter;
    unsigned short index;
    short note = 0;
	int octave;
    static char convert[] = { 9,11,0,2,4,5,7 };
    index = 0;
    for (;string[index] == ' ';index++);
    letter = string[index++];
    if ((letter >= 'a') && (letter <= 'g')) 
	{
		note = convert[letter - 'a'];
	}
    else if ((letter >= 'A') && (letter <= 'G'))
	{
		note = convert[letter - 'A'];
	}

    letter = string[index];
    if (letter == '#') 
	{
        index++;
        note++;
    }
    else if (letter == 'b' || letter == 'B') 
	{
        index++;
        note--;
    }
    for(;string[index] == ' ';index++);
    octave = atoi(&string[index]);
    octave = octave * 12;
    octave += note;

	// the note has to be within 0 - 127. 
	if(octave < 0)
		octave = 0;
	else if(octave > 127)
		octave = 127;

    return (short)octave;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Shared\PropPageChord.h ===
#include "..\shared\keyboard.h"

#if !defined(AFX_PROPPAGECHORD_H__1118E501_E93F_11D0_89AB_00A0C9054129__INCLUDED_)
#define AFX_PROPPAGECHORD_H__1118E501_E93F_11D0_89AB_00A0C9054129__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "resource.h"
#include "conductor.h"
// PropPageChord.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// PropPageChord dialog
class CChordPropPageMgr;

class PropPageChord : public CPropertyPage, public IDMUSProdMidiInCPt
{
	friend class CChordPropPageMgr;
	DECLARE_DYNCREATE(PropPageChord)

// Construction
public:
	PropPageChord();
	~PropPageChord();
	void DispatchKeyboardChange(CKeyboard* pKeyboard, short nKey);

// Dialog Data
	//{{AFX_DATA(PropPageChord)
	enum { IDD = IDD_CHORD_PROPPAGE };
	CKeyboard	m_cScale;
	CKeyboard	m_cChord;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(PropPageChord)
	public:
	virtual BOOL OnSetActive();
	virtual int DoModal();
	virtual BOOL Create(LPCTSTR lpszClassName, LPCTSTR lpszWindowName, DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID, CCreateContext* pContext = NULL);
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	virtual LRESULT WindowProc(UINT message, WPARAM wParam, LPARAM lParam);
	//}}AFX_VIRTUAL

// Implementation
protected:

	afx_msg long OnWMUser(WPARAM, LPARAM);
	// Generated message map functions
	//{{AFX_MSG(PropPageChord)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnDestroy();
	virtual BOOL OnInitDialog();
	afx_msg void OnNoteDownChordKeys(short nKey);
	afx_msg void OnChordDropoctave();
	afx_msg void OnChordFlat();
	afx_msg void OnChordFournotes();
	afx_msg void OnChordInvert();
	afx_msg void OnChangeChordName();
	afx_msg void OnDeltaposRootSpin(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnChangeRootText();
	afx_msg void OnNoteDownScaleKeys(short nKey);
	afx_msg void OnTest();
	afx_msg void OnChordMidiIn();
	afx_msg void OnScaleMidiIn();
	afx_msg void OnKillFocus(CWnd* pNewWnd);
	DECLARE_EVENTSINK_MAP()
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

public:
	void PreProcessPSP( PROPSHEETPAGE& psp, BOOL bWizard );
	void SetChord( CPropChord * pChord );

// IUnknown
public:
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

	// IDMUSProdMidiInCPt functions
	HRESULT STDMETHODCALLTYPE OnMidiMsg(REFERENCE_TIME rtTime, 
										BYTE bStatus, 
										BYTE bData1, 
										BYTE bData2);

private:
	DWORD	m_cRef;
	void DrawScaleNote(CPropChord* pChord, short nX);
	void SetCheckBox(CPropChord* pChord, DWORD dwUDFlag, UINT nDlgID, UINT nState);
	CPropChord				m_Chord;
	CChordPropPageMgr*		m_pPropPageMgr;
	IDMUSProdConductor*		m_pIConductor;
	// midi chord/scale input members
	void RegisterMidi();
	void UnRegisterMidi();
	DWORD m_dwCookie;		// may be used to distinguish what chord is receiving input (if necessary)
	enum {None, Chord, Scale };
	int	 m_fMidiInputTarget;
	DWORD m_cRegCount;
	BOOL m_fNeedToDetach;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_PROPPAGECHORD_H__1118E501_E93F_11D0_89AB_00A0C9054129__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Shared\OlePropSheet.h ===
#if !defined(AFX_MODELESSOPS_H__828CE901_15EE_11D3_AE81_00105AA22F40__INCLUDED_)
#define AFX_MODELESSOPS_H__828CE901_15EE_11D3_AE81_00105AA22F40__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// OlePropSheet.h : header file
//

interface IDMUSProdUpdateObjectNow;

/////////////////////////////////////////////////////////////////////////////
// COlePropSheet

class COlePropSheet : public CPropertySheet
{
	DECLARE_DYNAMIC(COlePropSheet)

// Construction
public:
	COlePropSheet(UINT nIDCaption, CWnd* pParentWnd = NULL, UINT iSelectPage = 0);
	COlePropSheet(LPUNKNOWN lpUnk, LPCTSTR pszCaption, IDMUSProdUpdateObjectNow *pIDMUSProdUpdateObjectNow, CWnd* pParentWnd = NULL, UINT iSelectPage = 0);
	virtual ~COlePropSheet();
// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(COlePropSheet)
	public:
	virtual int DoModal();
	protected:
	virtual void PostNcDestroy();
	//}}AFX_VIRTUAL

// Implementation
public:
	LPUNKNOWN			m_pUnkServer;
	IDMUSProdUpdateObjectNow	*m_pIDMUSProdUpdateObjectNow;
	CPtrArray			m_pageArray;
	UINT				m_iPageCnt;

	// Generated message map functions
protected:
	//{{AFX_MSG(COlePropSheet)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
	// Generated OLE dispatch map functions
	//{{AFX_DISPATCH(COlePropSheet)
		// NOTE - the ClassWizard will add and remove member functions here.
	//}}AFX_DISPATCH
	DECLARE_DISPATCH_MAP()
	DECLARE_INTERFACE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_MODELESSOPS_H__828CE901_15EE_11D3_AE81_00105AA22F40__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Shared\PropChord.h ===
#ifndef __PROPCHORD_H_
#define __PROPCHORD_H_

#define CHORD_INVERT  0x10      /* This chord may be inverted           */
#define CHORD_FOUR    0x20      /* This should be a 4 note chord        */
#define CHORD_UPPER   0x40      /* Shift upper octave down              */
#define CHORD_SIMPLE  0x80      /* This is a simple chord               */
#define CHORD_COUNT   0x0F      /* Number of notes in chord (up to 15)  */

class CPropChord 
{
public:
				CPropChord();
				CPropChord(const CPropChord&);
	void		SetBits();
	void		CopyToPropChord( CPropChord *pPropChord );
	void		CopyFromPropChord( CPropChord *pPropChord );
	void		RootToString(char *pszName);
	CPropChord&	operator = (const CPropChord&);
	BOOL		operator < (const CPropChord&);
    DWORD		m_dwTime;
    DWORD		m_dwChordPattern;	// Pattern that defines chord
    DWORD		m_dwScalePattern;	// Scale Pattern for the chord
    short		m_nMeasure;			// What measure
    char		m_szName[12];		// Text for display
    BYTE		m_bRoot;			// Root note of chord
    BYTE		m_bFlat;			// Display with flat
    BYTE		m_bBeat;			// What beat this falls on
    BYTE		m_bBits;			// Invert and item count
//	Used to track which fields are shared by multiple 
//	chords and have multiple values, so are undetermined.
	DWORD		m_dwUndetermined;
};

// Flags for m_dwUndetermined:

#define UD_CHORDPATTERN		(1 << 0)
#define UD_SCALEPATTERN		(1 << 1)
#define UD_NAME				(1 << 2)
#define UD_ROOT				(1 << 3)
#define UD_FLAT				(1 << 4)
#define UD_INVERT			(1 << 5)
#define UD_FOUR				(1 << 6)
#define UD_UPPER			(1 << 7)
#define UD_SIMPLE			(1 << 8)
#define UD_DRAGSELECT		(1 << 9)
#define UD_DROPSELECT		(1 << 10)
#define UD_FROMCHORDPALETTE	(1 << 11)

#endif // __PROPCHORD_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Shared\OlePropPage.h ===
#if !defined(AFX_OLEPROPPAGE_H__469F345B_1A8B_11D3_B009_00105AA22F40__INCLUDED_)
#define AFX_OLEPROPPAGE_H__469F345B_1A8B_11D3_B009_00105AA22F40__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// OlePropPage.h : header file
//

#include "resource.h"

/////////////////////////////////////////////////////////////////////////////
// IDMUSProdUpdateObjectNow

// {18890BB4-97EE-465b-B523-2939C44CB2B6}
DEFINE_GUID( IID_IDMUSProdUpdateObjectNow, 0x18890bb4, 0x97ee, 0x465b, 0xb5, 0x23, 0x29, 0x39, 0xc4, 0x4c, 0xb2, 0xb6);

#undef INTERFACE
#define INTERFACE IDMUSProdUpdateObjectNow
DECLARE_INTERFACE_(IDMUSProdUpdateObjectNow, IUnknown)
{
    // IUnknown members
    STDMETHOD(QueryInterface)(REFIID riid, LPVOID *ppv) PURE;
    STDMETHOD_(ULONG, AddRef)() PURE;
    STDMETHOD_(ULONG, Release)() PURE;

    // IDMUSProdUpdateObjectNow members
    STDMETHOD(UpdateObjectNow)(LPUNKNOWN punkObject) PURE;
};

// COlePropPageTemplate - dialog template class used by COlePropPage
struct COlePropPageTemplate : public DLGTEMPLATE
{
    WCHAR MenuName;
    WCHAR ClassName;
    WCHAR szCaption;
    WORD wPointSize;
    WCHAR szFontName;

    COlePropPageTemplate();
    void SetSize(SIZE& size);
};

/////////////////////////////////////////////////////////////////////////////
// COlePropPage dialog

class COlePropPage : public CPropertyPage
{
	DECLARE_DYNCREATE(COlePropPage)

// Construction
public:
	IPropertyPage*				m_pPropPage;
	LPUNKNOWN					m_pObject;
	IDMUSProdUpdateObjectNow*	m_pIDMUSProdUpdateObjectNow;
	CLSID						m_clsidPage;
    COlePropPageTemplate		m_dlgTemplate;
	bool						m_fConstructionSucceeded;

	COlePropPage(CLSID clsidPage, LPUNKNOWN lpUnkPage, IDMUSProdUpdateObjectNow *pIDMUSProdUpdateObjectNow);
	COlePropPage();
	~COlePropPage();

// Dialog Data
	//{{AFX_DATA(COlePropPage)
	enum { IDD = IDD_OLE_PROPPAGE_LARGE };
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(COlePropPage)
	public:
	virtual void OnFinalRelease();
	virtual BOOL OnKillActive();
	virtual BOOL PreTranslateMessage(MSG* pMsg);
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(COlePropPage)
	afx_msg void OnDestroy();
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	HWND	m_hwndProducer; // Handle to Producer's main window

	// Generated OLE dispatch map functions
	//{{AFX_DISPATCH(COlePropPage)
		// NOTE - the ClassWizard will add and remove member functions here.
	//}}AFX_DISPATCH
	DECLARE_DISPATCH_MAP()
	DECLARE_INTERFACE_MAP()

    BEGIN_INTERFACE_PART(PropertySite, IPropertyPageSite)
        STDMETHOD(GetLocaleID)(LCID* pLocaleID);
        STDMETHOD(OnStatusChange)(DWORD dwFlags);
        STDMETHOD(GetPageContainer)(IUnknown **ppUnk);
        STDMETHOD(TranslateAccelerator)(MSG *pMsg);
	END_INTERFACE_PART(PropertySite)
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_OLEPROPPAGE_H__469F345B_1A8B_11D3_B009_00105AA22F40__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Shared\OlePropSheet.cpp ===
// OlePropSheet.cpp : implementation file
//

#include "stdafx.h"
#include "OlePropSheet.h"
#include "OlePropPage.h"

#include "comhelp.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// COlePropSheet

IMPLEMENT_DYNAMIC(COlePropSheet, CPropertySheet)

COlePropSheet::COlePropSheet(UINT nIDCaption, CWnd* pParentWnd, UINT iSelectPage)
	:CPropertySheet(nIDCaption, pParentWnd, iSelectPage)
{
	m_pUnkServer = NULL;
	m_pIDMUSProdUpdateObjectNow = NULL;
	EnableAutomation();
}

COlePropSheet::COlePropSheet(LPUNKNOWN lpUnk, LPCTSTR pszCaption, IDMUSProdUpdateObjectNow *pIDMUSProdUpdateObjectNow, CWnd* pParentWnd, UINT iSelectPage)
	:CPropertySheet(pszCaption, pParentWnd, iSelectPage)
{
	m_pUnkServer = lpUnk;
	m_pIDMUSProdUpdateObjectNow = pIDMUSProdUpdateObjectNow;
	EnableAutomation();
}

COlePropSheet::~COlePropSheet()
{
	for (UINT i = 0; i < m_iPageCnt; i++)
	{
		delete ((COlePropPage *)m_pageArray[i]);			
	}
}


BEGIN_MESSAGE_MAP(COlePropSheet, CPropertySheet)
	//{{AFX_MSG_MAP(COlePropSheet)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

BEGIN_DISPATCH_MAP(COlePropSheet, CPropertySheet)
	//{{AFX_DISPATCH_MAP(COlePropSheet)
		// NOTE - the ClassWizard will add and remove mapping macros here.
	//}}AFX_DISPATCH_MAP
END_DISPATCH_MAP()

// Note: we add support for IID_IOlePropSheet to support typesafe binding
//  from VBA.  This IID must match the GUID that is attached to the 
//  dispinterface in the .ODL file.

// {828CE900-15EE-11D3-AE81-00105AA22F40}
static const IID IID_IOlePropSheet =
{ 0x828ce900, 0x15ee, 0x11d3, { 0xae, 0x81, 0x0, 0x10, 0x5a, 0xa2, 0x2f, 0x40 } };

BEGIN_INTERFACE_MAP(COlePropSheet, CPropertySheet)
	INTERFACE_PART(COlePropSheet, IID_IOlePropSheet, Dispatch)
END_INTERFACE_MAP()


void COlePropSheet::PostNcDestroy() 
{
	CPropertySheet::PostNcDestroy();
	delete this;	
}


int COlePropSheet::DoModal() 
{
	// Check that we have a pointer to the object to display properties for
	ASSERT(m_pUnkServer != NULL);
	if( m_pUnkServer == NULL )
	{
		return FALSE;
	}

	// Remove the apply button
	m_psh.dwFlags |= PSH_NOAPPLYNOW;

	// Get number of property pages that reside in object
	ISpecifyPropertyPages * lpSPP;
	HRESULT hRes = m_pUnkServer->QueryInterface(IID_ISpecifyPropertyPages, (LPVOID*)&lpSPP);
	if( FAILED( hRes ) )
	{
		return FALSE;
	}

	// Get the array of property sheet pages
	CAUUID cauuid;
	if( FAILED( lpSPP->GetPages( &cauuid ) ) )
	{
		lpSPP->Release();
		return FALSE;
	}
	lpSPP->Release();

	// Set the number of pages to display
	m_iPageCnt = cauuid.cElems;

	for (UINT i = 0; i < m_iPageCnt; i++)
	{
		// Create CPropertyPages and Property page sites.
		COlePropPage * pPage = new COlePropPage(cauuid.pElems[i], m_pUnkServer, m_pIDMUSProdUpdateObjectNow );

		// Check if construction failed
		if( (pPage == NULL)
		||	!pPage->m_fConstructionSucceeded )
		{
			// construction failed - delete the object, if necessary
			if( pPage )
			{
				delete pPage;
			}

			// Fail
			return FALSE;
		}

		// Add the page to our array of pages
		m_pageArray.Add(pPage);

		// Add the page to the dialog
		AddPage((COlePropPage*)m_pageArray[i]);
	}

	// Now, actually display the dialog
	return CPropertySheet::DoModal();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Shared\PropPageChord.cpp ===
// PropPageChord.cpp : implementation file
//

#include "stdafx.h"
#include "..\includes\DMUSProd.h"
#include "..\includes\Conductor.h"
#include "PropChord.h"
#include "PropPageMgr.h"
#include "PropPageChord.h"


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

///////////////////////// Callback for CKeyboard Events
//
void KeyboardChangeCallback(CKeyboard* pKeyboard, void* hint, short nKey)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	PropPageChord* pdlg = (PropPageChord*)hint;
	pdlg->DispatchKeyboardChange(pKeyboard, nKey);
}

/////////////////////////////////////////////////////////////////////////////
// CChordPropPageMgr property page

CChordPropPageMgr::CChordPropPageMgr()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	m_pPropPageChord = NULL;
	m_pJazzFramework = NULL;
	CStaticPropPageManager::CStaticPropPageManager();
}

CChordPropPageMgr::~CChordPropPageMgr()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	if( m_pPropPageChord )
	{
		m_pPropPageChord->Release();
		m_pPropPageChord = 0;
	}
	if ( m_pJazzFramework )
	{
		m_pJazzFramework->Release();
		m_pJazzFramework = 0;
	}
	CStaticPropPageManager::~CStaticPropPageManager();
}

HRESULT STDMETHODCALLTYPE CChordPropPageMgr::QueryInterface( REFIID riid, LPVOID *ppv )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	return CStaticPropPageManager::QueryInterface( riid, ppv );
};

HRESULT STDMETHODCALLTYPE CChordPropPageMgr::GetPropertySheetTitle( BSTR* pbstrTitle, 
	BOOL* pfAddPropertiesText )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	if( (pbstrTitle == NULL)
	||  (pfAddPropertiesText == NULL) )
	{
		return E_POINTER;
	}

	*pfAddPropertiesText = TRUE;

	CString strTitle;

	strTitle.LoadString( IDS_PROPPAGE_CHORD );
	*pbstrTitle = strTitle.AllocSysString();

	return S_OK;
};

HRESULT STDMETHODCALLTYPE CChordPropPageMgr::GetPropertySheetPages( IDMUSProdPropSheet* pIPropSheet, 
	LONG* hPropSheetPage[], short* pnNbrPages )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	if( (hPropSheetPage == NULL)
	||  (pnNbrPages == NULL) )
	{
		return E_POINTER;
	}

	if( pIPropSheet == NULL )
	{
		return E_INVALIDARG;
	}

	m_pIPropSheet = pIPropSheet;
	m_pIPropSheet->AddRef();

	hPropSheetPage[0] = NULL;
	*pnNbrPages = 0;

	// Add Chord tab
	HPROPSHEETPAGE hPage;
	short nNbrPages = 0;

	if(!m_pPropPageChord)
		m_pPropPageChord = new PropPageChord();
	if( m_pPropPageChord )
	{
		PROPSHEETPAGE psp;
		memcpy( &psp, &m_pPropPageChord->m_psp, sizeof(PROPSHEETPAGE) );
		m_pPropPageChord->PreProcessPSP( psp, FALSE );

		hPage = ::CreatePropertySheetPage( &psp );
		if( hPage )
		{
			hPropSheetPage[nNbrPages] = (LONG *)hPage;
			nNbrPages++;
		}
		m_pPropPageChord->m_pPropPageMgr = this;
		if (!m_pJazzFramework)
		{
			pIPropSheet->QueryInterface( IID_IDMUSProdFramework, (void**)&m_pJazzFramework );
		}
		// fill in proppage's conductor member
		if(!m_pPropPageChord->m_pIConductor)
		{
			ASSERT(m_pJazzFramework);
			IDMUSProdComponent* pIComponent = NULL;
			IDMUSProdConductor* pConductor = NULL;
			if( SUCCEEDED ( m_pJazzFramework->FindComponent( CLSID_CConductor,  &pIComponent ) ))
			{
				pIComponent->QueryInterface( IID_IDMUSProdConductor, (void**)&pConductor );
				if (pConductor)
				{
					m_pPropPageChord->m_pIConductor = pConductor;
				}
				pIComponent->Release();
			}
		}
	}

	// Set number of pages
	*pnNbrPages = nNbrPages;
	return S_OK;
};

HRESULT STDMETHODCALLTYPE CChordPropPageMgr::RefreshData()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	CPropChord* pChord;
	if( m_pIPropPageObject == NULL )
	{
		pChord = NULL;
	}
	else if( FAILED ( m_pIPropPageObject->GetData( (void **)&pChord ) ) )
	{
		return E_FAIL;
	}
	if (m_pPropPageChord && pChord)
	{
		m_pPropPageChord->SetChord( pChord );
	}
	else
	{
		return E_FAIL;
	}
	return S_OK;
};

/////////////////////////////////////////////////////////////////////////////
// PropPageChord property page

IMPLEMENT_DYNCREATE(PropPageChord, CPropertyPage)

PropPageChord::PropPageChord(): CPropertyPage(PropPageChord::IDD)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));


//	CPropertyPage(IDD_CHORD_PROPPAGE);
	//{{AFX_DATA_INIT(PropPageChord)
	//}}AFX_DATA_INIT
	m_pPropPageMgr = NULL;
	m_fMidiInputTarget = None;
	m_dwCookie = 0;
	m_pIConductor = 0;
	m_cRef = 0;
	m_cRegCount = 0;
	m_fNeedToDetach = FALSE;
	AddRef();
}

PropPageChord::~PropPageChord()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));


	UnRegisterMidi();	// make sure we're unregistered
	if(m_pIConductor)
	{
		m_pIConductor->Release();
	}
}

void PropPageChord::DoDataExchange(CDataExchange* pDX)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));


	CPropertyPage::DoDataExchange(pDX);

	//{{AFX_DATA_MAP(PropPageChord)
	DDX_Control(pDX, IDC_SCALE_KEYS, m_cScale);
	DDX_Control(pDX, IDC_CHORD_KEYS, m_cChord);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(PropPageChord, CPropertyPage)
	ON_MESSAGE(WM_USER, OnWMUser)
	//{{AFX_MSG_MAP(PropPageChord)
	ON_WM_CREATE()
	ON_WM_DESTROY()
	ON_BN_CLICKED(IDC_CHORD_DROPOCTAVE, OnChordDropoctave)
	ON_BN_CLICKED(IDC_CHORD_FLAT, OnChordFlat)
	ON_BN_CLICKED(IDC_CHORD_FOURNOTES, OnChordFournotes)
	ON_BN_CLICKED(IDC_CHORD_INVERT, OnChordInvert)
	ON_EN_CHANGE(IDC_CHORD_NAME, OnChangeChordName)
	ON_NOTIFY(UDN_DELTAPOS, IDC_ROOT_SPIN, OnDeltaposRootSpin)
	ON_EN_CHANGE(IDC_ROOT_TEXT, OnChangeRootText)
	ON_BN_CLICKED(IDC_TEST, OnTest)
	ON_BN_CLICKED(IDC_CHORD_MIDI_IN, OnChordMidiIn)
	ON_BN_CLICKED(IDC_CHORD_MIDI_IN2, OnScaleMidiIn)
	ON_WM_KILLFOCUS()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// PropPageChord custom functions

void PropPageChord::DrawScaleNote(CPropChord* pChord, short nX)

{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));


	short nGrayed;
	if (pChord->m_dwUndetermined & UD_SCALEPATTERN) nGrayed = 4;
	else nGrayed = 0;
	DWORD dwChord = pChord->m_dwChordPattern << (pChord->m_bRoot % 12);
	short nState = nGrayed;
	if ((pChord->m_dwScalePattern >> nX) & 1) 
	{
		nState++;
		if ((dwChord >> nX) & 1) nState += 2;
	}
	else
	{
		if ((dwChord >> nX) & 1) nState += 2;
	}
	m_cScale.SetNoteState(nX,"",nState);
}

void PropPageChord::SetCheckBox(CPropChord* pChord, DWORD dwUDFlag, UINT nDlgID, UINT nState)

{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));


	if (pChord->m_dwUndetermined & dwUDFlag)
	{
		CButton *pButton = (CButton *) GetDlgItem(nDlgID);
		if (pButton)
		{
			pButton->SetButtonStyle(BS_AUTO3STATE);
			pButton->SetCheck(2);		
		}
	}
	else
	{
		CButton *pButton = (CButton *) GetDlgItem(nDlgID);
		if (pButton)
		{
			pButton->SetButtonStyle(BS_AUTOCHECKBOX);
			pButton->SetCheck(nState);
		}
	}
}

void PropPageChord::SetChord( CPropChord* pChord )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));


	char str[30];
	m_Chord = *pChord;
	
	if( IsWindow( m_hWnd ) == 0 ) return;

	if (pChord->m_dwUndetermined & UD_NAME)
	{
		SetDlgItemText(IDC_CHORD_NAME,"");
	}
	else
	{
		SetDlgItemText(IDC_CHORD_NAME,pChord->m_szName);
	}
	pChord->RootToString(str);
	SetDlgItemText(IDC_ROOT_TEXT,str);
	SetCheckBox(pChord, UD_INVERT, IDC_CHORD_INVERT,(pChord->m_bBits & CHORD_INVERT) && 1);
	SetCheckBox(pChord, UD_UPPER, IDC_CHORD_DROPOCTAVE,(pChord->m_bBits & CHORD_UPPER) && 1);
	SetCheckBox(pChord, UD_FOUR, IDC_CHORD_FOURNOTES,(pChord->m_bBits & CHORD_FOUR) && 1);
	SetCheckBox(pChord, UD_FLAT, IDC_CHORD_FLAT,pChord->m_bFlat && 1);
	short nGrayed;
	if (pChord->m_dwUndetermined & UD_CHORDPATTERN) nGrayed = 4;
	else nGrayed = 0;
	int nX;
	for (nX = 0; nX < 24; nX++)
	{
		short nState = nGrayed;
		if ((pChord->m_dwChordPattern >> nX) & 1) nState += 2;
		m_cChord.SetNoteState(nX,"",nState);
	}
	for (nX = 0; nX < 24; nX++)
	{
		DrawScaleNote(pChord, nX);
	}
}

/////////////////////////////////////////////////////////////////////////////
// PropPageChord message handlers

int PropPageChord::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));


	// Attach the window to the property page structure.
	// This has been done once already in the main application
	// since the main application owns the property sheet.
	// It needs to be done here so that the window handle can
	// be found in the DLLs handle map.
	if( !FromHandlePermanent( m_hWnd ) )
	{
		HWND hWnd = m_hWnd;
		m_hWnd = NULL;
		Attach( hWnd );
		m_fNeedToDetach = TRUE;
	}

	if( CPropertyPage::OnCreate(lpCreateStruct) == -1 )
	{
		return -1;
	}

	return 0;
}

void PropPageChord::OnDestroy() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));


	// Detach the window from the property page structure.
	// This will be done again by the main application since
	// it owns the property sheet.  It needs o be done here
	// so that the window handle can be removed from the
	// DLLs handle map.

	if( m_fNeedToDetach && m_hWnd )
	{
		HWND hWnd = m_hWnd;
		Detach();
		m_hWnd = hWnd;
	}
	UnRegisterMidi();

	CPropertyPage::OnDestroy();	
}

BOOL PropPageChord::OnSetActive() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));


	RegisterMidi();

	return CPropertyPage::OnSetActive();
}


int PropPageChord::DoModal() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));


	return CPropertyPage::DoModal();
}

BOOL PropPageChord::Create(LPCTSTR lpszClassName, LPCTSTR lpszWindowName, DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID, CCreateContext* pContext) 
{
	// TODO: Add your specialized code here and/or call the base class
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));


	return CWnd::Create(lpszClassName, lpszWindowName, dwStyle, rect, pParentWnd, nID, pContext);
}

/////////////////////////////////////////////////////////////////////////////
// PropPageChord::PreProcessPSP

void PropPageChord::PreProcessPSP( PROPSHEETPAGE& psp, BOOL bWizard )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));


	PreProcessPageTemplate( psp, FALSE );
}

BOOL PropPageChord::OnInitDialog() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	m_cChord.SetLButtonUpCallback(KeyboardChangeCallback, this);
	m_cScale.SetLButtonUpCallback(KeyboardChangeCallback, this);

	CPropertyPage::OnInitDialog();
	
	return TRUE;  // return TRUE unless you set the focus to a control
	               // EXCEPTION: OCX Property Pages should return FALSE
}

LRESULT PropPageChord::WindowProc(UINT message, WPARAM wParam, LPARAM lParam) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	return CPropertyPage::WindowProc(message, wParam, lParam);
}

BEGIN_EVENTSINK_MAP(PropPageChord, CPropertyPage)
    //{{AFX_EVENTSINK_MAP(PropPageChord)
	//}}AFX_EVENTSINK_MAP
END_EVENTSINK_MAP()


void PropPageChord::OnNoteDownChordKeys(short nKey) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));


	if (m_Chord.m_dwUndetermined & UD_CHORDPATTERN)
	{
		m_Chord.m_dwUndetermined &= ~UD_CHORDPATTERN;
		for (nKey = 0; nKey < 24; nKey++)
		{
			m_cChord.SetNoteState(nKey,"",(1 && ((m_Chord.m_dwChordPattern >> nKey) & 1)) << 1);
		}
	}
	else
	{
		m_Chord.m_dwChordPattern ^= (1 << nKey);
		m_Chord.m_dwUndetermined &= ~UD_CHORDPATTERN;
		m_cChord.SetNoteState(nKey,"",(1 && ((m_Chord.m_dwChordPattern >> nKey) & 1)) << 1);
		DrawScaleNote(&m_Chord, (nKey + m_Chord.m_bRoot) % 24);
		DrawScaleNote(&m_Chord, (nKey + m_Chord.m_bRoot + 12) % 24);
	}
	if (m_pPropPageMgr && m_pPropPageMgr->m_pIPropPageObject)
	{
		m_pPropPageMgr->m_pIPropPageObject->SetData((void *) &m_Chord);
	}
}


void PropPageChord::OnNoteDownScaleKeys(short nKey) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));


	short nOtherKey = (nKey + 12) % 24;
	if (m_Chord.m_dwUndetermined & UD_SCALEPATTERN)
	{
		m_Chord.m_dwUndetermined &= ~UD_SCALEPATTERN;
//		m_Chord.m_dwScalePattern ^= (1 << nKey);
		for (nKey = 0; nKey < 24; nKey++)
		{
			DrawScaleNote(&m_Chord,nKey);
		}
	}
	else
	{
		m_Chord.m_dwScalePattern ^= (1 << nKey);
		m_Chord.m_dwScalePattern ^= (1 << nOtherKey);
		DrawScaleNote(&m_Chord,nKey);
		DrawScaleNote(&m_Chord,nOtherKey);
	}
	if (m_pPropPageMgr && m_pPropPageMgr->m_pIPropPageObject)
	{
		m_pPropPageMgr->m_pIPropPageObject->SetData((void *) &m_Chord);
	}	
}

void PropPageChord::OnChordDropoctave() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));


	UINT nChecked = IsDlgButtonChecked(IDC_CHORD_DROPOCTAVE);
	UINT nState;
	if (m_Chord.m_dwUndetermined & UD_UPPER)
	{
		nState = 2;
	}
	else if (m_Chord.m_bBits & CHORD_UPPER)
	{
		nState = 1;
	}
	else nState = 0;
	if (nState != nChecked)
	{
		if (nChecked == 2)
		{
			CButton *pButton = (CButton *) GetDlgItem(IDC_CHORD_DROPOCTAVE);
			if (pButton)
			{
				pButton->SetButtonStyle(BS_AUTOCHECKBOX);
				pButton->SetCheck(nState);			
			}
		}
		else
		{
			m_Chord.m_dwUndetermined &= ~UD_UPPER;
			if (nChecked == 1)
			{
				m_Chord.m_bBits |= CHORD_UPPER;
			}
			else 
			{
				m_Chord.m_bBits &= ~CHORD_UPPER;
			}
			if (m_pPropPageMgr && m_pPropPageMgr->m_pIPropPageObject)
			{
				m_pPropPageMgr->m_pIPropPageObject->SetData((void *) &m_Chord);
			}	
		}
	}
}

void PropPageChord::OnChordFlat() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));


	UINT nChecked = IsDlgButtonChecked(IDC_CHORD_FLAT);
	UINT nState;
	if (m_Chord.m_dwUndetermined & UD_FLAT)
	{
		nState = 2;
	}
	else if (m_Chord.m_bFlat)
	{
		nState = 1;
	}
	else nState = 0;
	if (nState != nChecked)
	{
		if (nChecked == 2)
		{
			CButton *pButton = (CButton *) GetDlgItem(IDC_CHORD_FLAT);
			if (pButton)
			{
				pButton->SetButtonStyle(BS_AUTOCHECKBOX);
				pButton->SetCheck(nState);			
			}
		}
		else
		{
			m_Chord.m_dwUndetermined &= ~UD_FLAT;
			if (nChecked == 1)
			{
				m_Chord.m_bFlat = TRUE;
			}
			else 
			{
				m_Chord.m_bFlat = FALSE;
			}
			if (m_pPropPageMgr && m_pPropPageMgr->m_pIPropPageObject)
			{
				m_pPropPageMgr->m_pIPropPageObject->SetData((void *) &m_Chord);
			}	
		}
	}
}

void PropPageChord::OnChordFournotes() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));


	UINT nChecked = IsDlgButtonChecked(IDC_CHORD_FOURNOTES);
	UINT nState;
	if (m_Chord.m_dwUndetermined & UD_FOUR)
	{
		nState = 2;
	}
	else if (m_Chord.m_bBits & CHORD_FOUR)
	{
		nState = 1;
	}
	else nState = 0;
	if (nState != nChecked)
	{
		if (nChecked == 2)
		{
			CButton *pButton = (CButton *) GetDlgItem(IDC_CHORD_FOURNOTES);
			if (pButton)
			{
				pButton->SetButtonStyle(BS_AUTOCHECKBOX);
				pButton->SetCheck(nState);			
			}
		}
		else
		{
			m_Chord.m_dwUndetermined &= ~UD_FOUR;
			if (nChecked == 1)
			{
				m_Chord.m_bBits |= CHORD_FOUR;
			}
			else 
			{
				m_Chord.m_bBits &= ~CHORD_FOUR;
			}
			if (m_pPropPageMgr && m_pPropPageMgr->m_pIPropPageObject)
			{
				m_pPropPageMgr->m_pIPropPageObject->SetData((void *) &m_Chord);
			}	
		}
	}
}

void PropPageChord::OnChordInvert() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));


	UINT nChecked = IsDlgButtonChecked(IDC_CHORD_INVERT);
	UINT nState;
	
	if (m_Chord.m_dwUndetermined & UD_INVERT)
	{
		nState = 2;
	}
	else if (m_Chord.m_bBits & CHORD_INVERT)
	{
		nState = 1;
	}
	else nState = 0;
	if (nState != nChecked)
	{
		if (nChecked == 2)
		{
			CButton *pButton = (CButton *) GetDlgItem(IDC_CHORD_INVERT);
			if (pButton)
			{
				pButton->SetButtonStyle(BS_AUTOCHECKBOX);
				pButton->SetCheck(nState);			
			}
		}
		else
		{
			m_Chord.m_dwUndetermined &= ~UD_INVERT;
			if (nChecked == 1)
			{
				m_Chord.m_bBits |= CHORD_INVERT;
			}
			else 
			{
				m_Chord.m_bBits &= ~CHORD_INVERT;
			}
			if (m_pPropPageMgr && m_pPropPageMgr->m_pIPropPageObject)
			{
				m_pPropPageMgr->m_pIPropPageObject->SetData((void *) &m_Chord);
			}	
		}
	}
}

void PropPageChord::OnChangeChordName() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));


	char szName[30];
	GetDlgItemText(IDC_CHORD_NAME,szName,sizeof(m_Chord.m_szName));
	if (strcmp("",szName) && (strcmp(m_Chord.m_szName,szName)))
	{
		strcpy(m_Chord.m_szName,szName);
		m_Chord.m_dwUndetermined &= ~UD_NAME;
		if (m_pPropPageMgr && m_pPropPageMgr->m_pIPropPageObject)
		{
			m_pPropPageMgr->m_pIPropPageObject->SetData((void *) &m_Chord);
		}	
	}
}

void PropPageChord::OnDeltaposRootSpin(NMHDR* pNMHDR, LRESULT* pResult) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

#ifdef CHORDMAP
	if(m_Chord.m_dwUndetermined & UD_FROMCHORDPALETTE)
		return;	// can't change root of palette chords
#endif
	NM_UPDOWN* pNMUpDown = (NM_UPDOWN*)pNMHDR;

	short nX = m_Chord.m_bRoot - pNMUpDown->iDelta;
	if (nX < 0) nX = 0;
	if (nX > 23) nX = 23;
	m_Chord.m_bRoot = (BYTE) nX;
	char str[10];
	m_Chord.RootToString(str);
	SetDlgItemText(IDC_ROOT_TEXT,str);
	m_Chord.m_dwUndetermined &= ~UD_ROOT;
	for (nX = 0; nX < 24; nX++)
	{
		DrawScaleNote(&m_Chord, nX);
	}
	if (m_pPropPageMgr && m_pPropPageMgr->m_pIPropPageObject)
	{
		m_pPropPageMgr->m_pIPropPageObject->SetData((void *) &m_Chord);
	}	
	*pResult = 0;
}

void PropPageChord::OnChangeRootText() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));


	if (m_pPropPageMgr && m_pPropPageMgr->m_pIPropPageObject)
	{
		m_pPropPageMgr->m_pIPropPageObject->SetData((void *) &m_Chord);
	}	
}
#define MIDI_NOTEOFF    0x80
#define MIDI_NOTEON     0x90
#define MIDI_PTOUCH     0xA0
#define MIDI_CCHANGE    0xB0
#define MIDI_PCHANGE    0xC0
#define MIDI_MTOUCH     0xD0
#define MIDI_PBEND      0xE0

#define MIDI_BASEPITCH		60

void PropPageChord::OnTest() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));


	IDMUSProdConductor *pConductor = NULL;
	IDMUSProdComponent* pIComponent = NULL;
	if (m_pPropPageMgr->m_pJazzFramework)
	{
		if( SUCCEEDED ( m_pPropPageMgr->m_pJazzFramework->FindComponent( CLSID_CConductor,  &pIComponent ) ))
		{
			pIComponent->QueryInterface( IID_IDMUSProdConductor, (void**)&pConductor );
			if (pConductor)
			{
				short nX;
				DWORD dwTime = 500;
				pConductor->PlayMIDIEvent( MIDI_PCHANGE, 0, 0, 0 );
				pConductor->PlayMIDIEvent( MIDI_PCHANGE+1, 10, 0, 0 );
				for (nX = 0; nX < 24; nX++)
				{
					if ((m_Chord.m_dwChordPattern >> nX) & 1)
					{
						short note = MIDI_BASEPITCH + nX + m_Chord.m_bRoot;
						pConductor->PlayMIDIEvent( MIDI_NOTEON, 
							note, 120, dwTime );
						pConductor->PlayMIDIEvent( MIDI_NOTEOFF, 
							note, 120, dwTime + 1000 );
					}
				}
				dwTime += 1000;
				for (nX = 0; nX < 25; nX++)
				{
					if ((m_Chord.m_dwScalePattern >> nX) & 1)
					{
						short note = MIDI_BASEPITCH + nX;
						pConductor->PlayMIDIEvent( MIDI_NOTEON+1, 
							note,  100, dwTime );
						pConductor->PlayMIDIEvent( MIDI_NOTEOFF+1, 
							note,  100, dwTime + 180);
						dwTime += 200;
					}
				}
				pConductor->Release();
			}
			pIComponent->Release();
		}
	}
}

void PropPageChord::OnChordMidiIn() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));


	CButton* chord = (CButton*)GetDlgItem(IDC_CHORD_MIDI_IN);
	ASSERT(chord);
	CButton* scale = (CButton*)GetDlgItem(IDC_CHORD_MIDI_IN2);
	ASSERT(scale);


	if(m_fMidiInputTarget == None || m_fMidiInputTarget == Scale)
	{
		m_fMidiInputTarget = Chord;
		chord->SetCheck(1);
		scale->SetCheck(0);
		RegisterMidi();
	}
	else if(m_fMidiInputTarget == Chord)
	{
		m_fMidiInputTarget = None;
		chord->SetCheck(0);
		scale->SetCheck(0);
		UnRegisterMidi();
	}
}

void PropPageChord::OnScaleMidiIn() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));


	CButton* chord = (CButton*)GetDlgItem(IDC_CHORD_MIDI_IN);
	ASSERT(chord);
	CButton* scale = (CButton*)GetDlgItem(IDC_CHORD_MIDI_IN2);
	ASSERT(scale);


	if(m_fMidiInputTarget == None || m_fMidiInputTarget == Chord)
	{
		m_fMidiInputTarget = Scale;
		chord->SetCheck(0);
		scale->SetCheck(1);
		RegisterMidi();
	}
	else if(m_fMidiInputTarget == Scale)
	{
		m_fMidiInputTarget = None;
		chord->SetCheck(0);
		scale->SetCheck(0);
		UnRegisterMidi();
	}
}

const short KeyOCXTrans = 48;
const short KeyOCXLow = 0;
const short KeyOCXHigh = 23;

HRESULT PropPageChord::OnMidiMsg(REFERENCE_TIME rtTime,
									   BYTE bStatus, 
									   BYTE bData1, 
									   BYTE bData2)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));


	// Note On
	if((int)(bStatus & 0xF0) == (int)0x90)
	{

		char Text[128];
		sprintf(Text, "Inside  PropPageChord::OnMidiMsg going to play %d note on\n", bData1); 
		TRACE0(Text);
		
		// set note
		short nKey = bData1 - KeyOCXTrans;
		if(nKey >= KeyOCXLow && nKey <= KeyOCXHigh)
		{
			this->PostMessage(WM_USER, nKey, 0);
		}
	}

	// Note Off
	if((int)(bStatus & 0xF0) == (int)0x80)
	{
		char Text[128];
		sprintf(Text, "Inside  PropPageChord::OnMidiMsg going to play %d note off\n", bData1); 
		TRACE0(Text);
	}

	// set up patch
	m_pIConductor->PlayMIDIEvent( MIDI_PCHANGE, 0, 0, 0 );
	m_pIConductor->PlayMIDIEvent( MIDI_PCHANGE+1, 10, 0, 0 );

	m_pIConductor->PlayMIDIEvent((bStatus & 0xF0),
								 bData1,
								 bData2,
								 0);	
	
	return S_OK;
}

void PropPageChord::RegisterMidi() 
{
	ASSERT(m_cRegCount <= 1);
	if(m_fMidiInputTarget != None && m_cRegCount == 0)
	{
		++m_cRegCount;
		REGISTER_MIDI_IN(m_pIConductor, m_dwCookie)	
	}
}

void PropPageChord::UnRegisterMidi()
{
	ASSERT(m_cRegCount <= 1);
	if(m_cRegCount)
	{
		m_cRegCount--;
		UNREGISTER_MIDI_IN(m_pIConductor, m_dwCookie)
	}
}


/////////////////////////////////////////////////////////////////////////////
// PropPageChord IUnknown
STDMETHODIMP PropPageChord::QueryInterface( REFIID riid, LPVOID *ppv )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));


	ASSERT( ppv );
    *ppv = NULL;
    if (IsEqualIID(riid, IID_IUnknown))
	{
        *ppv = (IUnknown *) this;
	}
	else if (IsEqualIID(riid, IID_IDMUSProdMidiInCPt))
	{
        *ppv = (IUnknown *) (IDMUSProdMidiInCPt *) this;
	}
	else
	{
		return E_NOTIMPL;
	}
    ((IUnknown *) *ppv)->AddRef();
	return S_OK;
}

STDMETHODIMP_(ULONG) PropPageChord::AddRef(void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));


	return ++m_cRef;
}

STDMETHODIMP_(ULONG) PropPageChord::Release(void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));


	if( 0L == --m_cRef )
	{
		delete this;
		return 0;
	}
	else
	{
		return m_cRef;
	}
}

void PropPageChord::OnKillFocus(CWnd* pNewWnd) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));


	CPropertyPage::OnKillFocus(pNewWnd);
	
	AfxMessageBox("Losing Focus");	
}

long PropPageChord::OnWMUser(WPARAM midinote, LPARAM)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));


	if(m_fMidiInputTarget == Chord)
	{
		OnNoteDownChordKeys(midinote);
	}
	else if(m_fMidiInputTarget == Scale)
	{
		OnNoteDownScaleKeys(midinote);
	}
	return 0;
}

void PropPageChord::DispatchKeyboardChange(CKeyboard* pKeyboard, short nKey)
{
	if(pKeyboard == &m_cChord)
	{
		OnNoteDownChordKeys(nKey);
	}
	else if(pKeyboard == &m_cScale)
	{
		OnNoteDownScaleKeys(nKey);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Shared\OlePropPage.cpp ===
// OlePropPage.cpp : implementation file
//

#include "stdafx.h"
#include "comhelp.h"
#include <comdef.h>
#include <initguid.h>
#include "OlePropPage.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

// Extended dialog template (from atlhost.h)
#pragma pack(push, 1)
struct DLGTEMPLATEEX
{
	WORD dlgVer;
	WORD signature;
	DWORD helpID;
	DWORD exStyle;
	DWORD style;
	WORD cDlgItems;
	short x;
	short y;
	short cx;
	short cy;

	// Everything else in this structure is variable length,
	// and therefore must be determined dynamically

	// sz_Or_Ord menu;			// name or ordinal of a menu resource
	// sz_Or_Ord windowClass;	// name or ordinal of a window class
	// WCHAR title[titleLen];	// title string of the dialog box
	// short pointsize;			// only if DS_SETFONT is set
	// short weight;			// only if DS_SETFONT is set
	// short bItalic;			// only if DS_SETFONT is set
	// WCHAR font[fontLen];		// typeface name, if DS_SETFONT is set
};
#pragma pack(pop)


//*********************************************************************
// GetPropSheetFont
//*********************************************************************

#define IDD_PROPSHEET	1006

static HFONT GetPropSheetFont()
{
	// Create a LOGFONTA structure
    LOGFONTA logfont;

	// Initialize it
    memset(&logfont, 0, sizeof(LOGFONTA));
    logfont.lfHeight = 8;
    logfont.lfWeight = FW_NORMAL;
    logfont.lfCharSet = DEFAULT_CHARSET;
    strcpy(logfont.lfFaceName, "MS Sans Serif");

	// Try and load ComCtrl32.dll
    HINSTANCE hInst = LoadLibraryA("COMCTL32");
    if (hInst != NULL)
	{
		// Find the standard property sheet template
		HRSRC hResource = ::FindResource(hInst, MAKEINTRESOURCE(IDD_PROPSHEET), RT_DIALOG);

		// Load the standard property sheet template
		HGLOBAL hTemplate = LoadResource(hInst, hResource);
		DLGTEMPLATE* pTemplate = (DLGTEMPLATE*)LockResource(hTemplate);
		if (pTemplate != NULL)
		{
			// Check if this is an extended dialogm template
			bool bDialogEx = ((pTemplate->style & 0xFFFF0000) == 0xFFFF0000);

			// A pointer used to iterate through the dialog template
			WORD* pw;

			// Skip over the dialog template
			if (bDialogEx)
			{
				pw = (WORD*)((DLGTEMPLATEEX*)pTemplate + 1);
			}
			else
			{
				pw = (WORD*)(pTemplate + 1);
			}

			if (*pw == (WORD)-1)		// Skip menu name string or ordinal
				pw += 2; // WORDs
			else
				while(*pw++);
				
			if (*pw == (WORD)-1)		// Skip class name string or ordinal
				pw += 2; // WORDs
			else
				while(*pw++);

			while (*pw++);			// Skip caption string

			// Get the default device context
			HDC hdc = ::GetDC(NULL);

			// Convert *pw into 1/72ths of an inch
			logfont.lfHeight = -MulDiv(*pw, GetDeviceCaps(hdc, LOGPIXELSY), 72);

			// Release the default device context
			::ReleaseDC(NULL, hdc);

			pw += (bDialogEx ? 3 : 1);

			// Convert the font name from a WCHAR string to an ASCII string
			WideCharToMultiByte(CP_ACP, 0, pw, -1, logfont.lfFaceName, sizeof(logfont.lfFaceName), NULL, NULL);
		}

		// Release our lock on the ComCtl32.dll library
		FreeLibrary(hInst);
    }

	// Try and create the font
    return CreateFontIndirectA(&logfont);
}

COlePropPageTemplate::COlePropPageTemplate()
{
	// Initialize the property page template
	style = WS_CHILD | WS_TABSTOP | DS_CONTROL;
	dwExtendedStyle = WS_EX_CONTROLPARENT;
	cdit = 0;
	x = 0;
	y = 0;
	cx = 0;
	cy = 0;
	MenuName = 0;
	ClassName = 0;
	szCaption = 0;
	wPointSize = 0;
	szFontName = 0;
}

void COlePropPageTemplate::SetSize(SIZE& size)
{
	// Variables to store the size of characters in the system font
	static UINT cxSysChar = 0;
	static UINT cySysChar = 0;

	// If the size is not yet initialized
	if ((cxSysChar == 0) && (cySysChar == 0))
	{
		// Get the default device context
		HDC hdc = ::GetDC(NULL);

		// Get the property sheet font
		HFONT hfontSys;
		if ((hfontSys = GetPropSheetFont()) != NULL)
		{
			// Select the property sheet font
			HFONT hfontOld = (HFONT)SelectObject(hdc, hfontSys);

			// Get the metrics for this font
			TEXTMETRIC tm;
			GetTextMetrics(hdc, &tm);

			// Get the size of the entire alphabet, both upper and lower cases
			SIZE sizeText;
			::GetTextExtentPointA(hdc, "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz", 52, &sizeText);

			// Compute the average width of a character (rounding to the nearest value)
			cxSysChar = (sizeText.cx + 26) / 52;

			// compute the height of the characters, including the white space between rows
			cySysChar = tm.tmHeight + tm.tmExternalLeading;

			// Select the old font
			SelectObject(hdc, hfontOld);

			// Delete the property sheet font
			DeleteObject((HGDIOBJ)hfontSys);
		}
		else
		{
			// Could not create the font so just use the system's values
			LONG l = GetDialogBaseUnits();
			cxSysChar = LOWORD(l);
			cySysChar = HIWORD(l);
		}

		// Release the default device context
		::ReleaseDC(NULL, hdc);
	}

	// Ensure cxSysChar and cySysChar are at least 1
	cxSysChar = max( cxSysChar, 1 );
	cySysChar = max( cySysChar, 1 );

	// Translate pixels to dialog units
	cx = short(MulDiv(size.cx, 4, cxSysChar));
	cy = short(MulDiv(size.cy, 8, cySysChar));
}

/////////////////////////////////////////////////////////////////////////////
// COlePropPage property page

IMPLEMENT_DYNCREATE(COlePropPage, CPropertyPage)

COlePropPage::COlePropPage() : CPropertyPage(COlePropPage::IDD)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	EnableAutomation();
	//{{AFX_DATA_INIT(COlePropPage)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT

	m_pPropPage = NULL;
	m_pObject = NULL;
	m_pIDMUSProdUpdateObjectNow = NULL;
	m_hwndProducer = NULL;
}

COlePropPage::COlePropPage(CLSID clsidPage, LPUNKNOWN lpUnkPage, IDMUSProdUpdateObjectNow *pIDMUSProdUpdateObjectNow) : CPropertyPage(COlePropPage::IDD),
	m_clsidPage(clsidPage), m_pObject(lpUnkPage), m_pIDMUSProdUpdateObjectNow(pIDMUSProdUpdateObjectNow)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Create COM Property page and get IPropertyPage interface

	// Enable automation for this dialog
	EnableAutomation();

	// Initialize m_fConstructionSucceeded to true
	m_fConstructionSucceeded = true;

	// Initialize the property page pointer to NULL
	m_pPropPage = NULL;

	// Try and initialize everything
	try
	{
		// A variable to store the results
		HRESULT hRes;

		// Try and create the property page
		hRes = CoCreateInstance( m_clsidPage, NULL, CLSCTX_INPROC, IID_IPropertyPage, (void**)&m_pPropPage );
		if( FAILED( hRes ) )
		{
			AfxThrowOleException( hRes );
		}

		// Point the property page back to us
		hRes = m_pPropPage->SetPageSite( (IPropertyPageSite*) GetInterface( &IID_IPropertyPageSite ) );
		if( FAILED( hRes ) )
		{
			AfxThrowOleException( hRes );
		}

		// Point the property page to its object
		hRes = m_pPropPage->SetObjects( 1, &m_pObject );
		if( FAILED( hRes ) )
		{
			AfxThrowOleException( hRes );
		}

		// Get a pointer to the IMalloc allocator
		IMalloc *pIMalloc;
		if( FAILED( CoGetMalloc( MEMCTX_TASK, &pIMalloc ) ) )
		{
			AfxThrowOleException(E_FAIL);
		}

		// Allocate a PROPPAGEINFO structure
		PROPPAGEINFO* pPPI = (PROPPAGEINFO*) pIMalloc->Alloc(sizeof(PROPPAGEINFO));

		// If memory allocated failed
		if( NULL == pPPI )
		{
			AfxThrowOleException(E_OUTOFMEMORY);
		}

		// Initialize the PROPPAGEINFO structure
		ZeroMemory( pPPI, sizeof( PROPPAGEINFO ) );

		// Initialize the size of the PROPPAGEINFO structure
		pPPI->cb = sizeof(PROPPAGEINFO);

		// Get the property page information (from the propety page)
		hRes = m_pPropPage->GetPageInfo(pPPI);
		if( SUCCEEDED( hRes ) )
		{
			// Set the dialog title
			m_strCaption = pPPI->pszTitle;
			m_psp.pszTitle = m_strCaption;
			m_psp.dwFlags |= PSP_USETITLE;

			// Free the memory allocated by the strings in pPPI
			CoTaskMemFree( pPPI->pszDocString );
			CoTaskMemFree( pPPI->pszHelpFile );
			CoTaskMemFree( pPPI->pszTitle );

			// set the dialog template size
			m_dlgTemplate.SetSize( pPPI->size );
		}

		// Make sure the property sheet uses pResource
		m_psp.dwFlags |= PSP_DLGINDIRECT;
		m_psp.pResource = &m_dlgTemplate;

		// Free the PROPPAGEINFO structure
		pIMalloc->Free(pPPI);

		// Release the IMalloc allocator
		pIMalloc->Release();
	} catch (COleException * e)
	{
		// Just delete the exception
		delete e;

		// And set the construction succeeded flag to false
		m_fConstructionSucceeded = false;
	}

	m_hwndProducer = NULL;

	//{{AFX_DATA_INIT(COlePropPage)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}


COlePropPage::~COlePropPage()
{
	// Release COM Property Page
	if (m_pPropPage)
	{
		m_pPropPage->Release();
		m_pPropPage = NULL;
	}
}

void COlePropPage::OnFinalRelease()
{
	// When the last reference for an automation object is released
	// OnFinalRelease is called.  The base class will automatically
	// deletes the object.  Add additional cleanup required for your
	// object before calling the base class.

	CPropertyPage::OnFinalRelease();
}

void COlePropPage::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(COlePropPage)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(COlePropPage, CPropertyPage)
	//{{AFX_MSG_MAP(COlePropPage)
	ON_WM_DESTROY()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

BEGIN_DISPATCH_MAP(COlePropPage, CPropertyPage)
	//{{AFX_DISPATCH_MAP(COlePropPage)
		// NOTE - the ClassWizard will add and remove mapping macros here.
	//}}AFX_DISPATCH_MAP
END_DISPATCH_MAP()

// Note: we add support for IID_IOlePropPage to support typesafe binding
//  from VBA.  This IID must match the GUID that is attached to the 
//  dispinterface in the .ODL file.

// {469F345A-1A8B-11D3-B009-00105AA22F40}
static const IID IID_IOlePropPage =
{ 0x469f345a, 0x1a8b, 0x11d3, { 0xb0, 0x9, 0x0, 0x10, 0x5a, 0xa2, 0x2f, 0x40 } };

BEGIN_INTERFACE_MAP(COlePropPage, CPropertyPage)
	INTERFACE_PART(COlePropPage, IID_IOlePropPage, Dispatch)
	INTERFACE_PART(COlePropPage, IID_IPropertyPageSite, PropertySite)
END_INTERFACE_MAP()

/////////////////////////////////////////////////////////////////////////////
// COlePropPage message handlers
IMPLEMENT_IUNKNOWN(COlePropPage, PropertySite)


STDMETHODIMP COlePropPage::XPropertySite::GetLocaleID(LCID* pLocaleID)
{
	//METHOD_PROLOGUE(COlePropPage, PropertySite);     // Creates a pThis pointer 
	//TRACE("COlePropPage::PropertySite::GetLocaleID()\n");
	*pLocaleID = ::GetThreadLocale();

	return (HRESULT)NOERROR;   
}

STDMETHODIMP COlePropPage::XPropertySite::OnStatusChange(DWORD dwFlags)
{
	METHOD_PROLOGUE(COlePropPage, PropertySite);     // Creates a pThis pointer 
	//TRACE("COlePropPage::PropertySite::OnStatusChange()\n");

	if (dwFlags & PROPPAGESTATUS_DIRTY)
	{
		// Update the object
		pThis->m_pPropPage->Apply();

		// Notify the editor that the object was updated
		if( pThis->m_pIDMUSProdUpdateObjectNow )
		{
			pThis->m_pIDMUSProdUpdateObjectNow->UpdateObjectNow( pThis->m_pObject );
		}
	}

	return (HRESULT)NOERROR;   
}

STDMETHODIMP COlePropPage::XPropertySite::GetPageContainer(IUnknown **ppUnk)
{
	UNREFERENCED_PARAMETER(ppUnk);
	//METHOD_PROLOGUE(COlePropPage, PropertySite);     // Creates a pThis pointer 
	//TRACE("COlePropPage::PropertySite::GetPageContainer()\n");

	return (HRESULT)E_NOTIMPL;   
}

STDMETHODIMP COlePropPage::XPropertySite::TranslateAccelerator(MSG *pMsg)
{
	UNREFERENCED_PARAMETER(pMsg);
	//METHOD_PROLOGUE(COlePropPage, PropertySite);     // Creates a pThis pointer to 
	//TRACE("COlePropPage::PropertySite::TranslateAccelerator()\n");

	return (HRESULT)E_NOTIMPL;   
}

/////////////////////////////////////////////////////////////////////////////
// COlePropPage message handlers


BOOL COlePropPage::OnInitDialog() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CPropertyPage::OnInitDialog();

	// Initialize the property page
	try {
		// Get the rectangle of our window
		CRect pgrect;
		GetWindowRect(&pgrect);

		// Convert it to client coordinates
		ScreenToClient(pgrect);

		// Try and activate the property page
		HRESULT hRes = m_pPropPage->Activate( GetSafeHwnd(), pgrect, TRUE );
		if( FAILED( hRes ) )
			AfxThrowOleException( hRes );

		hRes = m_pPropPage->Show( SW_SHOW );
		if( FAILED( hRes ) )
			AfxThrowOleException( hRes );

	} catch (COleException * e)
	{
		throw (e);
	}

	// Add WS_EX_CONTROLPARENT style to property page
	// necessary to allow tabbing from page to sheet.

	// Get COM Prop Page
	CWnd * pWnd = GetWindow(GW_CHILD);

	// Get the class name
	CString str;
	::GetClassName(pWnd->GetSafeHwnd(), str.GetBuffer(128), 128);
    str.ReleaseBuffer();

	// Check if the class name is #32770 (dialog box)
	if (str == (CString)_T("#32770"))
	{
		// If so, add the WS_EX_CONTROLPARENT flag
		pWnd->ModifyStyleEx(0,WS_EX_CONTROLPARENT,0);
	}

	m_hwndProducer = ::FindWindow("JzApBR", NULL );

	return TRUE;  // return TRUE unless you set the focus to a control
	// EXCEPTION: OCX Property Pages should return FALSE
}


BOOL COlePropPage::OnKillActive() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// The window was deactivated - update the object
	m_pPropPage->Apply();

	// Notify the editor that the object was updated
	if( m_pIDMUSProdUpdateObjectNow )
	{
		m_pIDMUSProdUpdateObjectNow->UpdateObjectNow( m_pObject );
	}

	return CPropertyPage::OnKillActive();
}

void COlePropPage::OnDestroy() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Try and de-activate the property page
	if( m_pPropPage )
	{
		m_pPropPage->Deactivate();
	}

	CPropertyPage::OnDestroy();
}

BOOL COlePropPage::PreTranslateMessage(MSG* pMsg) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// This allows the Transport accelerators to continue working while the property page is open
	if( pMsg->message == WM_SYSCHAR )
	{
		if( m_hwndProducer )
		{
			HWND hWndHasFocus = ::GetFocus();
			::SendMessage( m_hwndProducer, WM_APP, WPARAM(pMsg), 0 );
			if( hWndHasFocus != ::GetFocus() )
			{
				::SetFocus( hWndHasFocus );
			}
		}
	}
	
	return CPropertyPage::PreTranslateMessage(pMsg);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Shared\RiffStrm.h ===
/************************************************************************
*                                                                       *
*   Contains the definition of CRIFFStream                              *
*                                                                       *
*   Copyright (c) 1995-1999 Microsoft Corp. All rights reserved.        *
*                                                                       *
************************************************************************/

#ifndef _CRIFFStream_
#define _CRIFFStream_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#pragma warning( push )
#pragma warning( disable : 4201 )
#include <mmsystem.h>
#pragma warning( pop )
#include <ole2.h>

// {F809DCE1-859D-11d0-89AC-00A0C9054129}
DEFINE_GUID( IID_IDMUSProdRIFFStream, 0xf809dce1, 0x859d, 0x11d0, 0x89, 0xac, 0x0, 0xa0, 0xc9, 0x5, 0x41, 0x29 );

#undef INTERFACE
#define INTERFACE IDMUSProdRIFFStream
DECLARE_INTERFACE_(IDMUSProdRIFFStream, IUnknown)
{
    // IUnknown members
    STDMETHOD(QueryInterface)(REFIID riid, LPVOID *ppv) PURE;
    STDMETHOD_(ULONG, AddRef)() PURE;
    STDMETHOD_(ULONG, Release)() PURE;

    // IDMUSProdRIFFStream members
    STDMETHOD_(UINT, Descend)(LPMMCKINFO lpck, LPMMCKINFO lpckParent, UINT wFlags) PURE;
    STDMETHOD_(UINT, Ascend)(LPMMCKINFO lpck, UINT wFlags) PURE;
    STDMETHOD_(UINT, CreateChunk)(LPMMCKINFO lpck, UINT wFlags) PURE;
    STDMETHOD(SetStream)(IStream* pIStream) PURE;
    STDMETHOD_(IStream*, GetStream)() PURE;
};


// **************************************
//
// Platform Independent RIFF Tags
//
// **************************************

// **************************************
//
// CRIFFStream
//
// Implementation of IDMUSProdRIFFStream interface, and IUnknown
//
// **************************************


STDAPI AllocRIFFStream( IStream* pIStream, IDMUSProdRIFFStream** ppIRiffStream );
HRESULT SaveMBStoWCS( IStream* pIStream, const CString* pstrText );
void ReadMBSfromWCS( IStream* pIStream, DWORD dwSize, CString* pstrText );



struct CRIFFStream : IDMUSProdRIFFStream
{
///// object state
    ULONG       m_cRef;         // object reference count
    IStream*    m_pStream;      // stream to operate on

///// construction and destruction
    CRIFFStream(IStream* pStream)
    {
        m_cRef = 1;
		m_pStream = NULL;

        SetStream( pStream );
    }
    ~CRIFFStream()
    {
        if( m_pStream != NULL )
        {
            m_pStream->Release();
        }
    }

///// IUnknown methods
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppvObj)
    {
        if( IsEqualIID( riid, IID_IUnknown ) ||
            IsEqualIID( riid, IID_IDMUSProdRIFFStream ) )
        {
            *ppvObj = (IDMUSProdRIFFStream*)this;
            AddRef();
            return NOERROR;
        }
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }
    STDMETHODIMP_(ULONG) AddRef()
    {
        return ++m_cRef;
    }
    STDMETHODIMP_(ULONG) Release()
    {
        if( --m_cRef == 0L )
        {
            delete this;
            return 0;
        }
        return m_cRef;
    }

// IDMUSProdRIFFStream methods
    STDMETHODIMP_(UINT) Descend( LPMMCKINFO lpck, LPMMCKINFO lpckParent, UINT wFlags );
    STDMETHODIMP_(UINT) Ascend( LPMMCKINFO lpck, UINT wFlags );
    STDMETHODIMP_(UINT) CreateChunk( LPMMCKINFO lpck, UINT wFlags );
    STDMETHOD(SetStream)(LPSTREAM pStream)
    {
        if( m_pStream != NULL )
        {
            m_pStream->Release();
        }
        m_pStream = pStream;
        if( m_pStream != NULL )
        {
            m_pStream->AddRef();
        }
        return S_OK;
    }
    STDMETHOD_(LPSTREAM, GetStream)()
    {
        if( m_pStream != NULL )
        {
            m_pStream->AddRef();
        }
        return m_pStream;
    }

// private methods
    long MyRead( void *pv, long cb );
    long MyWrite( const void *pv, long cb );
    long MySeek( long lOffset, int iOrigin );
};


// seeks to a 32-bit position in a stream.
HRESULT __inline StreamSeek( LPSTREAM pStream, long lSeekTo, DWORD dwOrigin )
{
	LARGE_INTEGER li;

	if( lSeekTo < 0 )
	{
		li.HighPart = -1;
	}
	else
	{
        li.HighPart = 0;
	}
	li.LowPart = lSeekTo;
	return pStream->Seek( li, dwOrigin, NULL );
}


// returns the current 32-bit position in a stream.
DWORD __inline StreamTell( LPSTREAM pStream )
{
	LARGE_INTEGER li;
    ULARGE_INTEGER ul;
#ifdef _DEBUG
    HRESULT hr;
#endif

    li.HighPart = 0;
    li.LowPart = 0;
#ifdef _DEBUG
    hr = pStream->Seek( li, STREAM_SEEK_CUR, &ul );
    if( FAILED( hr ) )
#else
    if( FAILED( pStream->Seek( li, STREAM_SEEK_CUR, &ul ) ) )
#endif
    {
        return 0;
    }
    return ul.LowPart;
}

#ifndef _GetMLong_Defined_
#define _GetMLong_Defined_


// this function gets a long that is formatted the correct way
// i.e. the motorola way as opposed to the intel way
BOOL __inline GetMLong( LPSTREAM pStream, DWORD& dw )
{
	union uLong
	{
		unsigned char buf[4];
	DWORD dw;
	} u;

	if( S_OK != pStream->Read( u.buf, 4, NULL ) )
	{
	return FALSE;
	}


#ifndef _MAC
	// swap bytes
	unsigned char ch;
	ch = u.buf[0];
	u.buf[0] = u.buf[3];
	u.buf[3] = ch;

	ch = u.buf[1];
	u.buf[1] = u.buf[2];
	u.buf[2] = ch;
#endif

	dw = u.dw;
	return TRUE;
}

#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Shared\PropChord.cpp ===
#include "stdafx.h"
#include "PropChord.h"

CPropChord::CPropChord()
{
	m_bBeat = 0;
	m_bBits = 0;
	m_bFlat = 0;
	m_bRoot = 12;
	m_dwChordPattern = 0;
	m_dwScalePattern = 0;
	m_dwTime = 0;
	m_nMeasure = 0;
	m_szName[0] = 0;
	m_dwUndetermined = 0;
}

static char *convert[] = {"C","C#","D","D#","E","F","F#","G","G#","A","A#","B"};
static char *flatconvert[] = {"C","Db","D","Eb","E","F","Gb","G","Ab","A","Bb","B"};

void CPropChord::RootToString(char *pszName)

{
	short nX = (char)( m_bRoot % 12 );
	if( m_bFlat )
		wsprintf( pszName,"%d%s",1 + (m_bRoot / 12), (LPSTR)flatconvert[nX] ) ;
	else
		wsprintf( pszName,"%d%s",1 + (m_bRoot / 12), (LPSTR)convert[nX] ) ;
}


void CPropChord::SetBits()
{
	LONG    nX;
	short   nCount = 0;

    for( nX=0L ;  nX<32L ;  nX++ )
    {
        if( m_dwChordPattern & (1L << nX) )
            nCount++;
    }

    if( !m_bBits )
    {
        m_bBits |= CHORD_INVERT;
        if( nCount > 3 )
            m_bBits |= CHORD_FOUR;
        if( m_dwChordPattern & (15L << 18L) )
            m_bBits |= CHORD_UPPER;
    }
    m_bBits &= ~CHORD_COUNT;
    m_bBits |= nCount;
}

void CPropChord::CopyToPropChord( CPropChord *pPropChord )

{
	DWORD dwChangeFlags = 0;
	if (m_dwChordPattern != pPropChord->m_dwChordPattern)
	{
		dwChangeFlags |= UD_CHORDPATTERN;
	}
	if (m_dwScalePattern != pPropChord->m_dwScalePattern)
	{
		dwChangeFlags |= UD_SCALEPATTERN;
	}
	if (strcmp(m_szName, pPropChord->m_szName))
	{
		dwChangeFlags |= UD_NAME;
	}
	if (m_bRoot != pPropChord->m_bRoot)
	{
		dwChangeFlags |= UD_ROOT;
	}
	if (m_bFlat != pPropChord->m_bFlat)
	{
		dwChangeFlags |= UD_FLAT;
	}
	if ((m_bBits & CHORD_INVERT) != (pPropChord->m_bBits & CHORD_INVERT))
	{
		dwChangeFlags |= UD_INVERT;
	}
	if ((m_bBits & CHORD_FOUR) != (pPropChord->m_bBits & CHORD_FOUR))
	{
		dwChangeFlags |= UD_FOUR;
	}	
	if ((m_bBits & CHORD_UPPER) != (pPropChord->m_bBits & CHORD_UPPER))
	{
		dwChangeFlags |= UD_UPPER;
	}
	pPropChord->m_dwUndetermined = dwChangeFlags;
}

  
void CPropChord::CopyFromPropChord( CPropChord *pPropChord )

{
	DWORD dwChangeFlags = ~pPropChord->m_dwUndetermined;
	if (dwChangeFlags & UD_CHORDPATTERN)
	{
		m_dwChordPattern = pPropChord->m_dwChordPattern;
	}
	if (dwChangeFlags & UD_SCALEPATTERN)
	{
		m_dwScalePattern = pPropChord->m_dwScalePattern;
	}
	if (dwChangeFlags & UD_NAME)
	{
		strcpy(m_szName, pPropChord->m_szName);
	}
	if (dwChangeFlags & UD_ROOT)
	{
		m_bRoot = pPropChord->m_bRoot;
	}
	if (dwChangeFlags & UD_FLAT)
	{
		m_bFlat = pPropChord->m_bFlat;
	}
	if (dwChangeFlags & UD_INVERT)
	{
		m_bBits &= ~CHORD_INVERT;
		m_bBits |= (pPropChord->m_bBits & CHORD_INVERT);
	}
	if (dwChangeFlags & UD_FOUR)
	{
		m_bBits &= ~CHORD_FOUR;
		m_bBits |= (pPropChord->m_bBits & CHORD_FOUR);
	}
	if (dwChangeFlags & UD_UPPER)
	{
		m_bBits &= ~CHORD_UPPER;
		m_bBits |= (pPropChord->m_bBits & CHORD_UPPER);
	}
}


BOOL CPropChord :: operator < (const CPropChord& chord)
{
	if( m_nMeasure == chord.m_nMeasure)
	{
		if(m_bBeat < chord.m_bBeat)
		{
			return TRUE;
		}
		else
		{
			return FALSE;
		}
	}
	else if (m_nMeasure < chord.m_nMeasure)
	{
		return TRUE;
	}
	else
	{
		return FALSE;
	}
}

CPropChord& CPropChord::operator = (const CPropChord& chord)
{
	if(&chord == this)
	{
		return *this;
	}

	m_dwTime = chord.m_dwTime;
	m_dwChordPattern = chord.m_dwChordPattern;
	m_dwScalePattern = chord.m_dwScalePattern;
	m_nMeasure = chord.m_nMeasure;
	strcpy(m_szName, chord.m_szName);
	m_bRoot = chord.m_bRoot;
	m_bFlat = chord.m_bFlat;
	m_bBeat = chord.m_bBeat;
	m_bBits = chord.m_bBits;
	m_dwUndetermined = chord.m_dwUndetermined;

	return *this;
}

CPropChord::CPropChord(const CPropChord& chord)
{

	m_dwTime = chord.m_dwTime;
	m_dwChordPattern = chord.m_dwChordPattern;
	m_dwScalePattern = chord.m_dwScalePattern;
	m_nMeasure = chord.m_nMeasure;
	strcpy(m_szName, chord.m_szName);
	m_bRoot = chord.m_bRoot;
	m_bFlat = chord.m_bFlat;
	m_bBeat = chord.m_bBeat;
	m_bBits = chord.m_bBits;
	m_dwUndetermined = chord.m_dwUndetermined;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Shared\ReadOnlyEdit.cpp ===
// ReadOnlyEdit.cpp : implementation file
//

#include "stdafx.h"
#include "readonlyedit.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define MY_BACKGROUND_COLOR ::GetSysColor( COLOR_WINDOW )

/////////////////////////////////////////////////////////////////////////////
// CReadOnlyEdit

CReadOnlyEdit::CReadOnlyEdit()
{
}

CReadOnlyEdit::~CReadOnlyEdit()
{
}


BEGIN_MESSAGE_MAP(CReadOnlyEdit, CEdit)
	//{{AFX_MSG_MAP(CReadOnlyEdit)
	ON_WM_CTLCOLOR_REFLECT()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CReadOnlyEdit message handlers

HBRUSH CReadOnlyEdit::CtlColor(CDC* pDC, UINT nCtlColor) 
{
	// TODO: Change any attributes of the DC here
	pDC->SetBkColor( MY_BACKGROUND_COLOR );

	// TODO: Return a non-NULL brush if the parent's handler should not be called
	LOGBRUSH lb;
	lb.lbColor = MY_BACKGROUND_COLOR;
	lb.lbHatch = 0;
	lb.lbStyle = BS_SOLID;
	return ::CreateBrushIndirect( &lb );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Shared\SelectedRegion.h ===
/************************************************************************
*                                                                       *
*   Copyright (c) 1998-1999 Microsoft Corp. All rights reserved.        *
*                                                                       *
************************************************************************/

#ifndef SELECTED_REGION_H
#define SELECTED_REGION_H

#include "stdafx.h"
#include <afxtempl.h>
#include "..\shared\musictimeconverter.h"

class CListSelectedRegion;

class CSelectedRegion
{
	friend class CListSelectedRegion;
	CMusicTimeConverter m_mtcBeg;
	CMusicTimeConverter m_mtcEnd;
	DWORD	m_dwFlags;
public:
	// if m_dwFlags == WasSelected, then region was selected before click select.  If successful drag drop
	// then remains selected, otherwise its deselected.  
	// Used by the pair CSelectedRegionList::DelayToggle/CompleteToggle
	enum { WasToggleSelected=1, WasSelected=2 };
	CSelectedRegion()
	{
		m_dwFlags = 0;
	}
	~CSelectedRegion()
	{
	}
	CSelectedRegion(CMusicTimeConverter beg, CMusicTimeConverter end)
		: m_mtcBeg(beg), m_mtcEnd(end)
	{
		m_dwFlags = 0;
	}
	CSelectedRegion(const CSelectedRegion& sel)
	{
		m_mtcBeg = sel.m_mtcBeg;
		m_mtcEnd = sel.m_mtcEnd;
		m_dwFlags = sel.m_dwFlags;
	}
	CSelectedRegion& operator=(const CSelectedRegion& sel)
	{
		m_mtcBeg = sel.m_mtcBeg;
		m_mtcEnd = sel.m_mtcEnd;
		m_dwFlags = sel.m_dwFlags;
		return *this;
	}
	CMusicTimeConverter& Beg()
	{
		return m_mtcBeg;
	}
	CMusicTimeConverter& End()
	{
		return m_mtcEnd;
	}
	DWORD& Flags()
	{
		return m_dwFlags;
	}
	// create
	CSelectedRegion(long position, long measure, long beat, IDMUSProdTimeline* pTimeline, DWORD dwGroupBits)
	{
		m_mtcBeg.SetTimeUsingPosition(position, pTimeline, dwGroupBits);
		DMUS_TIMESIGNATURE dmTimeSig;
		m_mtcBeg.GetTimeSig(dmTimeSig, pTimeline, dwGroupBits);
		long m,b;
		m_mtcBeg.GetMeasureBeat(m, b, pTimeline, dwGroupBits);
		long beats = beat + b;
		beat = beats % dmTimeSig.bBeatsPerMeasure;
		measure += m + beats/dmTimeSig.bBeatsPerMeasure;
		m_mtcEnd.SetTime(measure, beat, pTimeline, dwGroupBits);
		m_dwFlags = 0;
	}
	bool Contains(CSelectedRegion& sel)
	{
		if(m_mtcBeg <= sel.m_mtcBeg && m_mtcEnd >= sel.m_mtcEnd)
		{
			return true;
		}
		else
		{
			return false;
		}
	}
	bool Contains(long measure, long beat, IDMUSProdTimeline* pTimeline, DWORD dwGroupBits)
	{
		long ltime;
		HRESULT hr = pTimeline->MeasureBeatToClocks(dwGroupBits, 0, measure, beat, &ltime);
		if(hr == S_OK)
		{
			if(ltime >= m_mtcBeg.Time() && ltime < m_mtcEnd.Time())
			{
				return true;
			}
			else
			{
				return false;
			}
		}
		else
		{
			return false;
		}
	}
	bool Intersects(CSelectedRegion& sel)
	{
		long b = sel.m_mtcBeg > m_mtcBeg ? sel.m_mtcBeg : m_mtcBeg; // b = max(beginning times)
		long e = sel.m_mtcEnd < m_mtcEnd ? sel.m_mtcEnd : m_mtcEnd; // e = min(ending times)
		// intersection is empty if min(ending times) <= max(beginning times)
		return e <= b ? false : true;
	}
	bool IsNull()
	{
		return m_mtcEnd < m_mtcBeg;
	}

	long BeginPos(IDMUSProdTimeline* pTimeline)
	{
		long pos;
		pTimeline->ClocksToPosition( m_mtcBeg.Time(), &pos);
		return pos;
	}
	long EndPos(IDMUSProdTimeline* pTimeline)
	{
		long pos;
		pTimeline->ClocksToPosition( m_mtcEnd.Time(), &pos);
		return pos;
	}
	HRESULT Load(IStream* pIStream)
	{
		HRESULT hr, hrBeg, hrEnd, hrFlags;
		DWORD cbBeg, cbEnd, cbFlags;
		hrBeg = pIStream->Read(&m_mtcBeg, sizeof(CMusicTimeConverter), &cbBeg);
		hrEnd = pIStream->Read(&m_mtcEnd, sizeof(CMusicTimeConverter), &cbEnd);
		hrFlags = pIStream->Read(&m_dwFlags, sizeof(DWORD), &cbFlags);
		hr = (cbBeg == sizeof(CMusicTimeConverter)) && (cbEnd == sizeof(CMusicTimeConverter)
				&& (cbFlags == sizeof(DWORD))
				&& SUCCEEDED(hrBeg) && SUCCEEDED(hrEnd) && SUCCEEDED(hrFlags))
			? S_OK : E_FAIL;
		return hr;
	}
	HRESULT Save(IStream* pIStream)
	{
		HRESULT hr, hrBeg, hrEnd, hrFlags;
		DWORD cbBeg, cbEnd, cbFlags;
		hrBeg = pIStream->Write(&m_mtcBeg, sizeof(CMusicTimeConverter), &cbBeg);
		hrEnd = pIStream->Write(&m_mtcEnd, sizeof(CMusicTimeConverter), &cbEnd);
		hrFlags = pIStream->Write(&m_dwFlags, sizeof(DWORD), &cbFlags);
		hr = (cbBeg == sizeof(CMusicTimeConverter)) && (cbEnd == sizeof(CMusicTimeConverter))
				&& (cbFlags == sizeof(DWORD))
				&& SUCCEEDED(hrBeg) && SUCCEEDED(hrEnd) && SUCCEEDED(hrFlags)
			? S_OK : E_FAIL;
		return hr;
	}

};

// list handles memory for regions
class CListSelectedRegion : public CTypedPtrList<CPtrList, CSelectedRegion *>
{
	friend class CChordStrip;
	DWORD m_dwGroupbits;
	IDMUSProdTimeline*	m_pTimeline;
	long lShiftSelectAnchorPosition;
public:
	HRESULT SelectAll();
	CListSelectedRegion(IDMUSProdTimeline* pTimeline, DWORD dwGroupbits);
	~CListSelectedRegion();

	IDMUSProdTimeline*& Timeline()
	{
		return m_pTimeline;
	}

	DWORD& GroupBits()
	{
		return m_dwGroupbits;
	}

	CListSelectedRegion& operator=(const CListSelectedRegion& list);
	// methods to add and modify region list
	// add a region at position(converted to a time) whose duration = measure:beat
	void AddRegion(long position, long measure=0, long beat=1);
	void AddRegion(const CSelectedRegion& csr);
	// select, but delay deselecting so that multiple selected regions can be dragged.
	void AddAndDelayDeselect(long position, long measure=0, long beat=1);
	// completes above by deselecting and removing
	void CompleteDeselect();
	// toggle the beat that contains the specified position
	void ToggleRegion(long position);
	// toggle the specified measure and beat
	void ToggleRegion(long measure, long beat);
	// delay toggle: complete after drag by calling CompleteToggle
	// behavior: (if not selected before and drag aborted, deselect)
	void DelayToggle(long position, long measure=0, long beat=1);
	void CompleteToggle();
	// delay select
	// select all between current position and anchor region (first region in list).  If list is empty
	// then just do an add region
	void ShiftAddRegion(long position, long measure=0, long beat=1);
	void SetShiftSelectAnchor(long position);
	long GetShiftSelectAnchor();
	bool Clear();
	void Sort(void);

	// methods to access list (by draw and cut, copy, paste, etc)
	// can also use CList methods
	POSITION FindContainingRegion(long lPosition);
	POSITION FindContainingRegion(long lMeasure, long lBeat);
	bool Contains(long measure, long beat);
	bool Contains(long lTime);
	HRESULT Load(IStream* pIStream);
	HRESULT Save(IStream* pIStream);
	void Copy(CListSelectedRegion& list)
	{
		*this = list;
	}
	void GetSpan(long& beg, long& end);
};



#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Shared\readonlyedit.h ===
#if !defined(AFX_READONLYEDIT_H__A1D70182_B723_11D2_B0E3_00105A26620B__INCLUDED_)
#define AFX_READONLYEDIT_H__A1D70182_B723_11D2_B0E3_00105A26620B__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// readonlyedit.h : header file
//

#include <afxwin.h>

/////////////////////////////////////////////////////////////////////////////
// CReadOnlyEdit window


class CReadOnlyEdit : public CEdit
{
// Construction
public:
	CReadOnlyEdit();

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CReadOnlyEdit)
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CReadOnlyEdit();

	// Generated message map functions
protected:
	//{{AFX_MSG(CReadOnlyEdit)
	afx_msg HBRUSH CtlColor(CDC* pDC, UINT nCtlColor);
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_READONLYEDIT_H__A1D70182_B723_11D2_B0E3_00105A26620B__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Shared\SelectedRegion.cpp ===
/************************************************************************
*                                                                       *
*   Copyright (c) 1998-1999 Microsoft Corp. All rights reserved.        *
*                                                                       *
************************************************************************/

#include "stdafx.h"
#include <dmusici.h>
#include <dmusicf.h>

#include "SelectedRegion.h"

// This sets up information for Visual C++'s memory leak tracing
#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

CListSelectedRegion::CListSelectedRegion(IDMUSProdTimeline* pTimeline, DWORD dwGroupbits)
: m_dwGroupbits(dwGroupbits), m_pTimeline(pTimeline)
{
//	m_pTimeline->AddRef();
	lShiftSelectAnchorPosition = 0;
}

CListSelectedRegion::~CListSelectedRegion()
{
	Clear();
//	m_pTimeline->Release();
}

// methods to add and modify region list

// add a region at position(converted to a time) whose duration = measure:beat
void CListSelectedRegion::AddRegion(long position, long measure, long beat)
{
	// now create and add this one
	CSelectedRegion* psr = new CSelectedRegion(position, measure, beat, m_pTimeline, m_dwGroupbits);
	AddHead(psr);
}

void CListSelectedRegion::AddRegion(const CSelectedRegion& csr)
{
	CSelectedRegion* psr = new CSelectedRegion(csr);
	AddHead(psr);
}


// toggle a region that contains the region formed by the given position
void CListSelectedRegion::ToggleRegion(long position)
{
	POSITION pos = FindContainingRegion(position);
	if(pos == NULL)
	{
		AddRegion(position, 0, 1);
	}
	else
	{
		CMusicTimeConverter mtcPos;
		mtcPos.SetTimeUsingPosition( position, m_pTimeline, m_dwGroupbits );
		CSelectedRegion* psr = GetAt(pos);
		if( (psr->m_mtcEnd == mtcPos) && (psr->m_mtcBeg == mtcPos) )
		{
			// Only this beat is in the selected regions, delete it
			RemoveAt(pos);
			delete psr;
		}
		else if( psr->m_mtcEnd == mtcPos )
		{
			// The region to toggle is at the end of psr - shorten psr
			psr->m_mtcEnd = psr->m_mtcEnd - 1;
			long lMeasure, lBeat;
			psr->m_mtcEnd.GetMeasureBeat( lMeasure, lBeat, m_pTimeline, m_dwGroupbits );
			psr->m_mtcEnd.SetTime( lMeasure, lBeat, m_pTimeline, m_dwGroupbits );

			// Check if this region is empty.  If so, delete it
			if( psr->m_mtcBeg == psr->m_mtcEnd )
			{
				RemoveAt(pos);
				delete psr;
			}
		}
		else if( psr->m_mtcBeg == mtcPos )
		{
			// The region to toggle is at the start of psr - shorten psr
			long lMeasure, lBeat;
			psr->m_mtcBeg.GetMeasureBeat( lMeasure, lBeat, m_pTimeline, m_dwGroupbits );
			lBeat++;
			psr->m_mtcBeg.SetTime( lMeasure, lBeat, m_pTimeline, m_dwGroupbits );

			// Check if this region is empty.  If so, delete it
			if( psr->m_mtcBeg == psr->m_mtcEnd )
			{
				RemoveAt(pos);
				delete psr;
			}
		}
		else
		{
			// Create a new CSelectedRegion for the first half
			CSelectedRegion *psrNew = new CSelectedRegion( psr->m_mtcBeg, mtcPos );
			InsertBefore( pos, psrNew );

			// Modify the existing CSelectedRegion to display the second half
			long lMeasure, lBeat;
			mtcPos.GetMeasureBeat( lMeasure, lBeat, m_pTimeline, m_dwGroupbits );
			lBeat++;
			psr->m_mtcBeg.SetTime( lMeasure, lBeat, m_pTimeline, m_dwGroupbits );
		}
	}
}


// toggle a region that contains the region formed by the given measure and beat
void CListSelectedRegion::ToggleRegion(long lMeasure, long lBeat)
{
	POSITION pos = FindContainingRegion(lMeasure, lBeat);
	if(pos == NULL)
	{
		CSelectedRegion *pSelectedRegion = new CSelectedRegion;
		if( pSelectedRegion )
		{
			pSelectedRegion->m_mtcBeg.SetTime( lMeasure, lBeat, m_pTimeline, m_dwGroupbits );
			pSelectedRegion->m_mtcEnd.SetTime( lMeasure, lBeat + 1, m_pTimeline, m_dwGroupbits );
			AddRegion( *pSelectedRegion );
		}
	}
	else
	{
		CMusicTimeConverter mtcPos;
		mtcPos.SetTime( lMeasure, lBeat, m_pTimeline, m_dwGroupbits );
		CSelectedRegion* psr = GetAt(pos);
		if( (psr->m_mtcEnd == mtcPos) && (psr->m_mtcBeg == mtcPos) )
		{
			// Only this beat is in the selected regions, delete it
			RemoveAt(pos);
			delete psr;
		}
		else if( psr->m_mtcEnd == mtcPos )
		{
			// The region to toggle is at the end of psr - shorten psr
			psr->m_mtcEnd = psr->m_mtcEnd - 1;
			long lMeasure, lBeat;
			psr->m_mtcEnd.GetMeasureBeat( lMeasure, lBeat, m_pTimeline, m_dwGroupbits );
			psr->m_mtcEnd.SetTime( lMeasure, lBeat, m_pTimeline, m_dwGroupbits );

			// Check if this region is empty.  If so, delete it
			if( psr->m_mtcBeg == psr->m_mtcEnd )
			{
				RemoveAt(pos);
				delete psr;
			}
		}
		else if( psr->m_mtcBeg == mtcPos )
		{
			// The region to toggle is at the start of psr - shorten psr
			long lMeasure, lBeat;
			psr->m_mtcBeg.GetMeasureBeat( lMeasure, lBeat, m_pTimeline, m_dwGroupbits );
			lBeat++;
			psr->m_mtcBeg.SetTime( lMeasure, lBeat, m_pTimeline, m_dwGroupbits );

			// Check if this region is empty.  If so, delete it
			if( psr->m_mtcBeg == psr->m_mtcEnd )
			{
				RemoveAt(pos);
				delete psr;
			}
		}
		else
		{
			// Create a new CSelectedRegion for the first half
			CSelectedRegion *psrNew = new CSelectedRegion( psr->m_mtcBeg, mtcPos );
			InsertBefore( pos, psrNew );

			// Modify the existing CSelectedRegion to display the second half
			long lMeasure, lBeat;
			mtcPos.GetMeasureBeat( lMeasure, lBeat, m_pTimeline, m_dwGroupbits );
			lBeat++;
			psr->m_mtcBeg.SetTime( lMeasure, lBeat, m_pTimeline, m_dwGroupbits );
		}
	}
}

// delay toggle: complete after drag by calling CompleteToggle
// behavior: (if not selected before and drag aborted, deselect)
void CListSelectedRegion::DelayToggle(long position, long measure, long beat)
{
	POSITION pos = FindContainingRegion(position);
	if(pos == NULL)
	{
		// unconditional add
		AddRegion(position, measure, beat);
	}
	else
	{
		CSelectedRegion* psr = GetAt(pos);
		psr->Flags() |= CSelectedRegion::WasToggleSelected;
	}
}
void CListSelectedRegion::CompleteToggle()
{
	POSITION pos = GetHeadPosition();
	while(pos)
	{
		POSITION tmpPos = pos;
		CSelectedRegion* psr = GetNext(pos);
		if(psr->Flags() & CSelectedRegion::WasToggleSelected)
		{
			RemoveAt(tmpPos);
			delete psr;
		}
	}
}

// select, but delay deselecting so that multiple selected regions can be dragged.
// call CompleteDeselect after drop to complete
void CListSelectedRegion::AddAndDelayDeselect(long position, long measure, long beat)
{
	POSITION pos = FindContainingRegion(position);
	if(pos == NULL)
	{
		// mark other selected regions so they can be removed later if drop was aborted
		pos = GetHeadPosition();
		while(pos)
		{
			CSelectedRegion* psr = GetNext(pos);
			psr->Flags() |= CSelectedRegion::WasSelected;
		}
		// now add region
		AddRegion(position, measure, beat);
	}
	else
	{
		CSelectedRegion* pCur = GetNext(pos);
		// mark all regions except for this one
		pos = GetHeadPosition();
		while(pos)
		{
			CSelectedRegion* psr = GetNext(pos);
			if(psr != pCur)
			{
				psr->Flags() |= CSelectedRegion::WasSelected;
			}
		}
	}
}

void CListSelectedRegion::CompleteDeselect()
{
	POSITION pos = GetHeadPosition();
	while(pos)
	{
		POSITION tmpPos = pos;
		CSelectedRegion* psr = GetNext(pos);
		if(psr->Flags() & CSelectedRegion::WasSelected)
		{
			RemoveAt(tmpPos);
			delete psr;
		}
	}
}

// select all between current position and anchor region (first region in list).  If list is empty
// then just do an add region from first measure first beat to current position
void CListSelectedRegion::ShiftAddRegion(long position, long measure, long beat)
{
	if(IsEmpty())
	{
		lShiftSelectAnchorPosition = 0;
	}

	CSelectedRegion* psrAnchor = NULL;

	// Get the shift-select anchor
	POSITION pos = FindContainingRegion(lShiftSelectAnchorPosition);
	if(pos)
	{
		psrAnchor = GetAt(pos);
		RemoveAt(pos);
	}
	else
	{
		psrAnchor = new CSelectedRegion(0, 0, 0, m_pTimeline, m_dwGroupbits);
	}

	// Delete all items in the list
	while(!IsEmpty())
	{
		CSelectedRegion* psr = RemoveHead();
		delete psr;
	}

	// Rebuild the selected region list
	CSelectedRegion* psrX = new CSelectedRegion(position, measure, beat, m_pTimeline, m_dwGroupbits);
	if(psrX->m_mtcBeg >= psrAnchor->m_mtcEnd)
	{
		psrX->m_mtcBeg = psrAnchor->m_mtcEnd;
	}
	if(psrX->m_mtcEnd <= psrAnchor->m_mtcBeg)
	{
		psrX->m_mtcEnd = psrAnchor->m_mtcBeg;
	}
	AddHead(psrAnchor);
	AddTail(psrX);
}

void CListSelectedRegion::SetShiftSelectAnchor(long position)
{
	// Set shift-select anchor
	lShiftSelectAnchorPosition = position;
}

long CListSelectedRegion::GetShiftSelectAnchor(void)
{
	// Get shift-select anchor
	return lShiftSelectAnchorPosition;
}

POSITION CListSelectedRegion::FindContainingRegion(long lPosition)
{
	CSelectedRegion srTarget(lPosition, 0, 1, m_pTimeline, m_dwGroupbits);

	// Get a pointer to the first item in the list
	POSITION pos = GetHeadPosition();
	while(pos)
	{
		// Save a pointer to this item
		POSITION posMatch = pos;

		// Get a pointer to the data in this item
		CSelectedRegion* psrTest = GetNext(pos);

		// Check if this selected range is the one we want
		if(psrTest->Contains(srTarget))
		{
			// Found it - return it.
			return posMatch;
		}
	}

	// Didn't find it - return NULL
	return NULL;
}

POSITION CListSelectedRegion::FindContainingRegion(long lMeasure, long lBeat)
{
	// Get a pointer to the first item in the list
	POSITION pos = GetHeadPosition();
	while(pos)
	{
		// Save a pointer to this item
		POSITION posMatch = pos;

		// Get a pointer to the data in this item
		CSelectedRegion* psrTest = GetNext(pos);

		// Check if this selected range is the one we want
		if(psrTest->Contains(lMeasure, lBeat, m_pTimeline, m_dwGroupbits))
		{
			// Found it - return it.
			return posMatch;
		}
	}

	return NULL;
}

bool CListSelectedRegion::Clear()
{
	// Check if there's anything to remove
	if( IsEmpty() )
	{
		// Nothing to remove - return false
		return false;
	}

	// Delete all items in the list
	while(!IsEmpty())
	{
		CSelectedRegion* psr = RemoveHead();
		delete psr;
	}

	// Found something to remove - return true
	return true;
}

HRESULT CListSelectedRegion::Load(IStream* pIStream)
{
	// Initialize shift-select anchor
	lShiftSelectAnchorPosition = 0;

	ASSERT(pIStream);
	if(pIStream == NULL)
		return E_INVALIDARG;
	HRESULT hr = S_OK;

	// check if anything to read
	DWORD nRegion, cb;
	hr = pIStream->Read(&nRegion, sizeof(DWORD), &cb);
	if(FAILED(hr))
	{
		return hr;
	}
	else if(cb == 0)
	{
		return S_FALSE;
	}
	else
	{
		Clear();
		for(unsigned int i = 0; i < nRegion && hr == S_OK; i++)
		{
			CSelectedRegion* psr = new CSelectedRegion;
			hr = psr->Load(pIStream);
		}
	}

	return hr;
}

HRESULT CListSelectedRegion::Save(IStream* pIStream)
{
	ASSERT(pIStream);
	if(pIStream == NULL)
		return E_INVALIDARG;
	HRESULT hr = S_OK;

	DWORD nRegion = static_cast<DWORD>(GetCount());
	DWORD cb;
	hr = pIStream->Write(&nRegion, sizeof(DWORD), &cb);

	hr = cb == sizeof(DWORD) && SUCCEEDED(hr) ? S_OK : E_FAIL;

	POSITION pos = GetHeadPosition();
	while(pos)
	{
		CSelectedRegion* psr = GetNext(pos);
		hr = psr->Save(pIStream);
	}
	return hr;
}

CListSelectedRegion& CListSelectedRegion::operator=(const CListSelectedRegion& list)
{
	if(&list != this)
	{
		Clear();
		POSITION pos = list.GetHeadPosition();
		while(pos)
		{
			CSelectedRegion* psr = list.GetNext(pos);
			AddTail(new CSelectedRegion(*psr));
		}
	}
	return *this;
}

void CListSelectedRegion::GetSpan(long& beg, long& end)
{
	beg = LONG_MAX;
	end = LONG_MIN;

	POSITION pos = GetHeadPosition();
	while(pos)
	{
		CSelectedRegion* psr = GetNext(pos);
		if(psr->m_mtcBeg.Time() < beg)
		{
			beg = psr->m_mtcBeg.Time();
		}
		if(psr->m_mtcEnd.Time() > end)
		{
			end = psr->m_mtcEnd.Time();
		}
	}
}

HRESULT CListSelectedRegion::SelectAll()
{
	VARIANT var;
	long ltime;
	HRESULT hr = m_pTimeline->GetTimelineProperty( TP_CLOCKLENGTH, &var );
	if(hr == S_OK)
	{
		ltime = V_I4(&var);
		CMusicTimeConverter cmtBeg(0);
		CMusicTimeConverter cmtEnd(ltime);
		CSelectedRegion* psr = new CSelectedRegion(cmtBeg, cmtEnd);
		Clear();
		AddHead(psr);
	}
	return hr;
}

bool CListSelectedRegion::Contains(long measure, long beat)
{
	return FindContainingRegion((short)measure, (BYTE)beat) != NULL;
}

bool CListSelectedRegion::Contains(long lTime)
{
	// Get a pointer to the first item in the list
	POSITION pos = GetHeadPosition();
	while(pos)
	{
		// Get a pointer to the data in this item
		CSelectedRegion* psrTest = GetNext(pos);

		if(lTime >= psrTest->m_mtcBeg.Time() && lTime < psrTest->m_mtcEnd.Time())
		{
			return true;
		}
	}

	return false;
}

void CListSelectedRegion::Sort(void)
{
	// Do a simple bubble sort on the list of selected regions
	// Order them by their start time

	// Initialize fChange to true so we go through the sort at least once
	bool fChange = true;

	// Continue while something changed the last time through
	while( fChange )
	{
		// Now initialize fChange to false, since nothing's changed
		fChange = false;

		// Get a pointer to the head of the list
		POSITION posRegion = GetHeadPosition();

		// Continue until there are no more items to look at
		while( posRegion )
		{
			// Save the current position
			POSITION posPrev = posRegion;

			// Get the next position
			GetNext( posRegion );

			// If there is a next position, and the current item should be
			// after the next item
			if( posRegion && (GetAt(posPrev)->Beg() > GetAt(posRegion)->Beg()) )
			{
				// Get a pointer to the current item
				CSelectedRegion* psr = GetAt(posPrev);

				// Remove it from the list
				RemoveAt( posPrev );

				// Insert it after the next item, and update our list pointer to point at it
				posRegion = InsertAfter( posRegion, psr );

				// Note that we changed so we go through the list again
				fChange = true;
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Shared\SeqSegmentRiff.h ===
#ifndef SEGMENTRIFF_H
#define SEGMENTRIFF_H


#include <dmusici.h>
#include <dmusicf.h>

#include <riffstrm.h>

#define MIDI_NOTEOFF    0x80
#define MIDI_NOTEON     0x90
#define MIDI_PTOUCH     0xA0
#define MIDI_CCHANGE    0xB0
#define MIDI_PCHANGE    0xC0
#define MIDI_MTOUCH     0xD0
#define MIDI_PBEND      0xE0
#define MIDI_SYSX       0xF0
#define MIDI_MTC        0xF1
#define MIDI_SONGPP     0xF2
#define MIDI_SONGS      0xF3
#define MIDI_EOX        0xF7
#define MIDI_CLOCK      0xF8
#define MIDI_START      0xFA
#define MIDI_CONTINUE   0xFB
#define MIDI_STOP       0xFC
#define MIDI_SENSE      0xFE
#define ET_NOTEOFF  ( MIDI_NOTEOFF >> 4 )  // 0x08
#define ET_NOTEON       ( MIDI_NOTEON >> 4 )   // 0x09
#define ET_PTOUCH       ( MIDI_PTOUCH >> 4 )   // 0x0A
#define ET_CCHANGE      ( MIDI_CCHANGE >> 4 )  // 0x0B
#define ET_PCHANGE      ( MIDI_PCHANGE >> 4 )  // 0x0C
#define ET_MTOUCH       ( MIDI_MTOUCH >> 4 )   // 0x0D
#define ET_PBEND        ( MIDI_PBEND >> 4 )    // 0x0E
#define ET_SYSX         ( MIDI_SYSX >> 4 )     // 0x0F
#define ET_PBCURVE          0x03
#define ET_CCCURVE      0x04
#define ET_MATCURVE     0x05
#define ET_PATCURVE     0x06
#define ET_TEMPOEVENT   0x01
#define ET_NOTDEFINED   0

#define NUM_MIDI_CHANNELS	16

#define EVENT_VOICE     1       // Performance event
#define EVENT_REALTIME  2       // qevent() must invoke interrupt
#define EVENT_ONTIME    3       // event should be handled on time



/* FullSeqEvent is SeqEvent plus next pointers*/
struct FullSeqEvent : DMUS_IO_SEQ_ITEM
{
	struct FullSeqEvent*   pNext;
	struct FullSeqEvent*	pTempNext; /* used in the compresseventlist routine */
	FullSeqEvent()
	{
		memset(this, 0, sizeof(FullSeqEvent));
	}
	FullSeqEvent(const FullSeqEvent& ev)
	{
		memset(this, 0, sizeof(FullSeqEvent));
		mtTime = ev.mtTime;
		mtDuration = ev.mtDuration;
		nOffset = ev.nOffset;
		bStatus = ev.bStatus;
		bByte1 = ev.bByte1;
		bByte2 = ev.bByte2;
//		pNext = pTempNext = 0;
	}
	FullSeqEvent& operator=(const FullSeqEvent& ev)
	{
		if(&ev != this)
		{
			memset(this, 0, sizeof(FullSeqEvent));
			mtTime = ev.mtTime;
			mtDuration = ev.mtDuration;
			nOffset = ev.nOffset;
			bStatus = ev.bStatus;
			bByte1 = ev.bByte1;
			bByte2 = ev.bByte2;
//			pNext = pTempNext = 0;
		}
		return *this;
	}	
};



inline HRESULT ReadWord(IDMUSProdRIFFStream* pIRiffStream, WORD& val)
{
	ASSERT(pIRiffStream);
	IStream* pIStream = pIRiffStream->GetStream();
	ASSERT(pIStream);
	if(pIStream)
	{
		HRESULT hr = pIStream->Read(&val, sizeof(WORD), 0);
		pIStream->Release();
		return hr;
	}
	else
	{
		return E_FAIL;
	}
}

inline HRESULT WriteWord(IDMUSProdRIFFStream* pIRiffStream, WORD val)
{
	ASSERT(pIRiffStream);
	IStream* pIStream = pIRiffStream->GetStream();
	ASSERT(pIStream);
	if(pIStream)
	{
		HRESULT hr = pIStream->Write(&val, sizeof(WORD), 0);
		pIStream->Release();
		return hr;
	}
	else
	{
		return E_FAIL;
	}
}

inline HRESULT ReadDWORD(IDMUSProdRIFFStream* pIRiffStream, DWORD& val)
{
	ASSERT(pIRiffStream);
	IStream* pIStream = pIRiffStream->GetStream();
	ASSERT(pIStream);
	if(pIStream)
	{
		HRESULT hr = pIStream->Read(&val, sizeof(DWORD), 0);
		pIStream->Release();
		return hr;
	}
	else
	{
		return E_FAIL;
	}
}

inline HRESULT WriteDWORD(IDMUSProdRIFFStream* pIRiffStream, DWORD val)
{
	ASSERT(pIRiffStream);
	IStream* pIStream = pIRiffStream->GetStream();
	ASSERT(pIStream);
	if(pIStream)
	{
		HRESULT hr = pIStream->Write(&val, sizeof(DWORD), 0);
		pIStream->Release();
		return hr;
	}
	else
	{
		return E_FAIL;
	}
}

// chunk navigators
class WriteChunk
{
	MMCKINFO m_ck;
	IDMUSProdRIFFStream* m_pRiffStream;
	HRESULT m_hr;
public:
	WriteChunk(IDMUSProdRIFFStream* pRiffStream, FOURCC id)
	{
		m_ck.ckid = id;
		m_pRiffStream = pRiffStream;
		m_hr = pRiffStream->CreateChunk( &m_ck, 0 );
	}
	HRESULT	State(MMCKINFO* pck = 0)
	{
		if(pck)
		{
			memcpy(pck,  &m_ck, sizeof(MMCKINFO));
		}
		return m_hr;
	}
	FOURCC Id()
	{
		return m_ck.ckid;
	}
	~WriteChunk()
	{
		if(m_hr == 0)
		{
			m_hr = m_pRiffStream->Ascend(&m_ck, 0);
		}
	}
};

class ReadChunk
{
	MMCKINFO m_ck;
	MMCKINFO* m_pckParent;
	IDMUSProdRIFFStream* m_pRiffStream;
	HRESULT m_hr;
public:
	ReadChunk(IDMUSProdRIFFStream* pRiffStream, MMCKINFO* pckParent) : m_pRiffStream(pRiffStream)
	{
		m_pckParent = pckParent;
		m_hr = pRiffStream->Descend( &m_ck,  m_pckParent, 0 );
	}
	~ReadChunk()
	{
		if(m_hr == 0)
		{
			m_hr = m_pRiffStream->Ascend(&m_ck, 0);
		}
	}
	HRESULT	State(MMCKINFO* pck=0)
	{
		if(pck)
		{
			memcpy(pck, &m_ck, sizeof(MMCKINFO));
		}
		return m_hr;
	}
	FOURCC Id()
	{
		if(m_ck.ckid == FOURCC_LIST)
		{
			return m_ck.fccType;
		}
		else
		{
			return m_ck.ckid;
		}
	}
};

// list navigators
class WriteListChunk
{
	MMCKINFO m_ck;
	IDMUSProdRIFFStream* m_pRiffStream;
	HRESULT m_hr;
public:
	WriteListChunk(IDMUSProdRIFFStream* pRiffStream, FOURCC id)
	{
		m_ck.fccType = id;
		m_pRiffStream = pRiffStream;
 		m_hr = pRiffStream->CreateChunk( &m_ck, MMIO_CREATELIST );
	}
	HRESULT	State(MMCKINFO* pck=0)
	{
		if(pck)
		{
			memcpy(pck, &m_ck, sizeof(MMCKINFO));
		}
		return m_hr;
	}
	FOURCC Id()
	{
		return m_ck.ckid;
	}
	~WriteListChunk()
	{
		if(m_hr == 0)
		{
			m_hr = m_pRiffStream->Ascend(&m_ck, 0);
		}
	}
};

// Riff navigators
class WriteRiffChunk
{
	MMCKINFO m_ck;
	IDMUSProdRIFFStream* m_pRiffStream;
	HRESULT m_hr;
public:
	WriteRiffChunk(IDMUSProdRIFFStream* pRiffStream, FOURCC id)
	{
		m_ck.fccType = id;
		m_pRiffStream = pRiffStream;
 		m_hr = pRiffStream->CreateChunk( &m_ck, MMIO_CREATERIFF );
	}
	HRESULT	State(MMCKINFO* pck=0)
	{
		if(pck)
		{
			memcpy(pck, &m_ck, sizeof(MMCKINFO));
		}
		return m_hr;
	}
	FOURCC Id()
	{
		return m_ck.ckid;
	}
	~WriteRiffChunk()
	{
		if(m_hr == 0)
		{
			m_hr = m_pRiffStream->Ascend(&m_ck, 0);
		}
	}
};



////////////////////////////////////////////////////// Segment RIFF Objects
//
class SequenceChunk : public DMUS_IO_SEQ_ITEM
{
public:
	SequenceChunk() {}
	SequenceChunk(const DMUS_IO_SEQ_ITEM& item)
	{
		Extract(item);
	}
	HRESULT Extract(const DMUS_IO_SEQ_ITEM& item);
	HRESULT Write(IDMUSProdRIFFStream* pRiffStream);
};

class SysexChunk : public DMUS_IO_SYSEX_ITEM
{
public:
	SysexChunk() {}
	SysexChunk(const DMUS_IO_SYSEX_ITEM& item)
	{
		Extract(item);
	}
	HRESULT Extract(const DMUS_IO_SYSEX_ITEM& item);
	HRESULT Write(IDMUSProdRIFFStream* pRiffStream);
};


class TrackHeaderChunk : public DMUS_IO_TRACK_HEADER
{
public:
	TrackHeaderChunk(GUID guid, FOURCC id, FOURCC type) 
	{
		guidClassID = guid;
		ckid = id;
		fccType = type;
		dwPosition = 0;	// this is undetermined
		dwGroup = 1;	// so is this
	}
	TrackHeaderChunk(GUID guid, FOURCC id, FOURCC type, DWORD position, DWORD group)
	{
		guidClassID = guid;
		ckid = id;
		fccType = type;
		dwPosition = position;
		dwGroup = group;
	}
	HRESULT Write(IDMUSProdRIFFStream* pRiffStream)
	{
		ASSERT(pRiffStream);
		HRESULT hr;
		DWORD dwBytesRead;
		IStream* pIStream = pRiffStream->GetStream();
		ASSERT(pIStream != NULL);
		if(pIStream == NULL)
		{
			return E_FAIL;
		}
		WriteChunk chunk(pRiffStream, DMUS_FOURCC_TRACK_CHUNK);
		hr = chunk.State();
		if(hr == S_OK)
		{
			hr = pIStream->Write(dynamic_cast<DMUS_IO_TRACK_HEADER*>(this),
											  sizeof(DMUS_IO_TRACK_HEADER), &dwBytesRead);
			hr = (hr == S_OK) && (dwBytesRead == sizeof(DMUS_IO_TRACK_HEADER)) ? S_OK : E_FAIL;
		}
		pIStream->Release();
		return hr;
	}
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Shared\RiffStrm.cpp ===
/************************************************************************
*                                                                       *
*   Contains the implementation of CRIFFStream                          *
*                                                                       *
*   Copyright (c) 1995-1999 Microsoft Corp. All rights reserved.        *
*                                                                       *
************************************************************************/

#include "stdafx.h"
#include <ole2.h>
#include <initguid.h>
#include "RiffStrm.h"

// This sets up information for Visual C++'s memory leak tracing
#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

// this takes care of a ton of compiler complaints
#ifndef WIN32
#define E_FAIL	(void __far *)MAKE_SCODE(SEVERITY_ERROR,   FACILITY_NULL, 8)
#endif


/////////////////////////////////////////////////////////////////////////////
// AllocRIFFStream

// Allocate an IDMUSProdRIFFStream from an IStream
STDAPI AllocRIFFStream( IStream* pIStream, IDMUSProdRIFFStream** ppIRiffStream )
{
	// Validate arguments
	if( (pIStream == NULL) || (ppIRiffStream == NULL) )
	{
		return E_POINTER;
	}

	// Create a new CRIFFStream that wraps the IStream
    if( ( *ppIRiffStream = (IDMUSProdRIFFStream*) new CRIFFStream( pIStream ) ) == NULL )
    {
		// Couldn't create the CRIFFStream object, probably out of memory
        return E_OUTOFMEMORY;
    }

	// Succeeded
    return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// MyRead, MyWrite, MySeek
//
// These are functionally identical to mmioRead, mmioWrite, and mmioSeek,
// except for the absence of the HMMIO parameter.

/////////////////////////////////////////////////////////////////////////////
// CRIFFStream::MyRead

// Read a chunk of data from m_pStream.
long CRIFFStream::MyRead(void *pv, long cb)
{
    ULONG cbRead;
    if (FAILED(m_pStream->Read(pv, cb, &cbRead)))
        return -1;
    return cbRead;
}


/////////////////////////////////////////////////////////////////////////////
// CRIFFStream::MyWrite

// Write a chunk of data to m_pStream.
long CRIFFStream::MyWrite(const void *pv, long cb)
{
    ULONG cbWritten;
    if (FAILED(m_pStream->Write(pv, cb, &cbWritten)))
        return -1;
    return cbWritten;
}


/////////////////////////////////////////////////////////////////////////////
// CRIFFStream::MySeek

// Seek to a different position in m_pStream
long CRIFFStream::MySeek(long lOffset, int iOrigin)
{
    LARGE_INTEGER   dlibSeekTo;
    ULARGE_INTEGER  dlibNewPos;

    dlibSeekTo.HighPart = 0;
    dlibSeekTo.LowPart = lOffset;
    if (FAILED(m_pStream->Seek(dlibSeekTo, iOrigin, &dlibNewPos)))
        return -1;

    return dlibNewPos.LowPart;
}


/////////////////////////////////////////////////////////////////////////////
// CRIFFStream::Descend

// Descend into a RIFF chunk and return information about the chunk in the lpck parameter.
UINT CRIFFStream::Descend(LPMMCKINFO lpck, LPMMCKINFO lpckParent, UINT wFlags)
{
    FOURCC          ckidFind;       // chunk ID to find (or NULL)
    FOURCC          fccTypeFind;    // form/list type to find (or NULL)

    // figure out what chunk id and form/list type to search for
    if (wFlags & MMIO_FINDCHUNK)
        ckidFind = lpck->ckid, fccTypeFind = NULL;
    else
    if (wFlags & MMIO_FINDRIFF)
        ckidFind = FOURCC_RIFF, fccTypeFind = lpck->fccType;
    else
    if (wFlags & MMIO_FINDLIST)
        ckidFind = FOURCC_LIST, fccTypeFind = lpck->fccType;
    else
        ckidFind = fccTypeFind = NULL;

    lpck->dwFlags = 0L;

    for(;;)
    {
        UINT        w;

        // read the chunk header
        if (MyRead(lpck, 2 * sizeof(DWORD)) !=
            2 * sizeof(DWORD))
        return MMIOERR_CHUNKNOTFOUND;

        // store the offset of the data part of the chunk
        if ((lpck->dwDataOffset = MySeek(0L, SEEK_CUR)) == -1)
            return MMIOERR_CANNOTSEEK;

        // see if the chunk is within the parent chunk (if given)
        if ((lpckParent != NULL) &&
            (lpck->dwDataOffset - 8L >=
             lpckParent->dwDataOffset + lpckParent->cksize))
            return MMIOERR_CHUNKNOTFOUND;

        // if the chunk if a 'RIFF' or 'LIST' chunk, read the
        // form type or list type
        if ((lpck->ckid == FOURCC_RIFF) || (lpck->ckid == FOURCC_LIST))
        {
            if (MyRead(&lpck->fccType,
                     sizeof(DWORD)) != sizeof(DWORD))
                return MMIOERR_CHUNKNOTFOUND;
        }
        else
            lpck->fccType = NULL;

        // if this is the chunk we're looking for, stop looking
        if ( ((ckidFind == NULL) || (ckidFind == lpck->ckid)) &&
             ((fccTypeFind == NULL) || (fccTypeFind == lpck->fccType)) )
            break;

        // ascend out of the chunk and try again
        if ((w = Ascend(lpck, 0)) != 0)
            return w;
    }

    return 0;
}


/////////////////////////////////////////////////////////////////////////////
// CRIFFStream::Ascend

// Ascend out of a RIFF chunk and update its size from the size in the lpck parameter.
UINT CRIFFStream::Ascend(LPMMCKINFO lpck, UINT /*wFlags*/)
{
    if (lpck->dwFlags & MMIO_DIRTY)
    {
        // <lpck> refers to a chunk created by CreateChunk();
        // check that the chunk size that was written when
        // CreateChunk() was called is the real chunk size;
        // if not, fix it
        LONG            lOffset;        // current offset in file
        LONG            lActualSize;    // actual size of chunk data

        if ((lOffset = MySeek(0L, SEEK_CUR)) == -1)
            return MMIOERR_CANNOTSEEK;
        if ((lActualSize = lOffset - lpck->dwDataOffset) < 0)
            return MMIOERR_CANNOTWRITE;

        if (LOWORD(lActualSize) & 1)
        {
            // chunk size is odd -- write a null pad byte
            if (MyWrite("\0", 1) != 1)
                return MMIOERR_CANNOTWRITE;

        }

        if (lpck->cksize == (DWORD)lActualSize)
            return 0;

        // fix the chunk header
        lpck->cksize = lActualSize;
        if (MySeek(lpck->dwDataOffset - sizeof(DWORD), SEEK_SET) == -1)
            return MMIOERR_CANNOTSEEK;
        if (MyWrite(&lpck->cksize, sizeof(DWORD)) != sizeof(DWORD))
            return MMIOERR_CANNOTWRITE;
    }

    // seek to the end of the chunk, past the null pad byte
    // (which is only there if chunk size is odd)
    if (MySeek(lpck->dwDataOffset + lpck->cksize + (lpck->cksize & 1L),
            SEEK_SET) == -1)
        return MMIOERR_CANNOTSEEK;

    return 0;
}


/////////////////////////////////////////////////////////////////////////////
// CRIFFStream::CreateChunk

// Create a RIFF chunk, passed in as lpck.
UINT CRIFFStream::CreateChunk(LPMMCKINFO lpck, UINT wFlags)
{
    int             iBytes;         // bytes to write
    LONG            lOffset;        // current offset in file

    // store the offset of the data part of the chunk
    if ((lOffset = MySeek(0L, SEEK_CUR)) == -1)
        return MMIOERR_CANNOTSEEK;
    lpck->dwDataOffset = lOffset + 2 * sizeof(DWORD);

    // figure out if a form/list type needs to be written
    if (wFlags & MMIO_CREATERIFF)
        lpck->ckid = FOURCC_RIFF, iBytes = 3 * sizeof(DWORD);
    else
    if (wFlags & MMIO_CREATELIST)
        lpck->ckid = FOURCC_LIST, iBytes = 3 * sizeof(DWORD);
    else
        iBytes = 2 * sizeof(DWORD);

    // write the chunk header
    if (MyWrite(lpck, (LONG) iBytes) != (LONG) iBytes)
        return MMIOERR_CANNOTWRITE;

    lpck->dwFlags = MMIO_DIRTY;

    return 0;
}


//////////////////////////////////
// Save routines
//////////////////////////////////
HRESULT SaveMBStoWCS( IStream* pIStream, const CString* pstrText )
{
	HRESULT		hr = S_OK;
	wchar_t*	wstrText = NULL;
	DWORD		dwLength;
	DWORD		dwBytesWritten;
		
	if( pstrText == NULL )
	{
		hr = E_FAIL;
		goto ON_ERR;
	}

	dwLength = pstrText->GetLength() + 1;
	wstrText = new wchar_t[dwLength];
	if( wstrText == NULL )
	{
		hr = E_FAIL;
		goto ON_ERR;
	}

    MultiByteToWideChar( CP_ACP, 0, *pstrText, -1, wstrText, (size_t)dwLength );
	dwLength *= sizeof(wchar_t);

	hr = pIStream->Write( wstrText, dwLength, &dwBytesWritten );
	if( FAILED( hr )
	||  dwBytesWritten != dwLength )
	{
		goto ON_ERR;
	}

ON_ERR:
	if( wstrText )
		delete wstrText;
	return hr;
}

/////////////////////////////////////////////////////////////////////////////
// ReadMBSfromWCS

void ReadMBSfromWCS( IStream* pIStream, DWORD dwSize, CString* pstrText )
{
	HRESULT		hr = S_OK;
	wchar_t*	wstrText = NULL;
	DWORD		dwBytesRead;
	
	pstrText->Empty();
	
	wstrText = new wchar_t[dwSize];
	if( wstrText == NULL )
	{
		hr = E_FAIL;
		goto ON_ERR;
	}

	hr = pIStream->Read( wstrText, dwSize, &dwBytesRead );
	if( FAILED( hr )
	||  dwBytesRead != dwSize )
	{
		goto ON_ERR;
	}

	*pstrText = wstrText;
	
ON_ERR:
	if( wstrText )
		delete wstrText;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Shared\SharedPattern.cpp ===
// SharedPattern.cpp : implementation file
//

#include "stdafx.h"
#include "Pattern.h"
#include "SharedPattern.h"
#include "DMUSProd.h"
#include "RiffStrm.h"

// Variation Choices bit associated with DirectMusic buttons
const static short sga_DM_AssociatedBit[DM_NBR_COLUMNS] =
		{ 0,7,14, 1,8,15, 2,9,16, 3,10,17, 4,11,18, 5,12,19, 6,13,20, 21, 22, 23, 24, 25, 26, 27, 28, 30 };

// Variation Choices bit associated with IMA buttons
const static short sga_IMA_AssociatedBit[IMA_NBR_COLUMNS] =
		{ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 13, 14, 11, 12 };

const short* sga_nBtnBit[NBR_ROWTYPES] = {					// Associated dwVariationChoices bits
	&sga_IMA_AssociatedBit[0],
	&sga_DM_AssociatedBit[0] };

IStream *CreateStreamForVarChoices( IDMUSProdFramework *pIDMUSProdFramework, DWORD adwVariationChoices[NBR_VARIATIONS] )
{
	// Validate the parameter
	ASSERT( adwVariationChoices );
	ASSERT( pIDMUSProdFramework );
	if( adwVariationChoices == NULL
	||	pIDMUSProdFramework == NULL )
	{
		return NULL;
	}

	// Try and allocate the stream
	IStream *pStream = NULL;
	if( SUCCEEDED( pIDMUSProdFramework->AllocMemoryStream( FT_DESIGN, GUID_CurrentVersion, &pStream ) ) )
	{
		IDMUSProdRIFFStream* pIRiffStream;
		if( SUCCEEDED( AllocRIFFStream( pStream, &pIRiffStream ) ) )
		{
			// Prepare the chunk headers
			MMCKINFO ckMain, ckSubChunk;
			ckMain.fccType = DM_FOURCC_VARCHOICES_FORM;
			ckSubChunk.ckid = DM_FOURCC_VARCHOICES_CHUNK;

			// Prepare ioVarChoices structure
			ioVarChoices oVarChoices;
			memset( &oVarChoices, 0, sizeof(ioVarChoices) );
			memcpy( oVarChoices.m_dwVariationChoices, adwVariationChoices, sizeof(DWORD) * NBR_VARIATIONS );

			// Write out the data
			DWORD dwBytesWritten;
			if( pIRiffStream->CreateChunk( &ckMain, MMIO_CREATERIFF ) != 0
			||	pIRiffStream->CreateChunk( &ckSubChunk, 0 ) != 0
			||	FAILED( pStream->Write( &oVarChoices, sizeof(ioVarChoices), &dwBytesWritten) )
			||	sizeof(ioVarChoices) != dwBytesWritten
			||	pIRiffStream->Ascend( &ckSubChunk, 0 ) != 0
			||	pIRiffStream->Ascend( &ckMain, 0 ) != 0 )
			{
				pStream->Release();
				pStream = NULL;
			}
			pIRiffStream->Release();
		}
		else
		{
			pStream->Release();
			pStream = NULL;
		}
	}

	return pStream;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicStyleCurve::SetDefaultResetValues

void CDirectMusicStyleCurve::SetDefaultResetValues( MUSIC_TIME mtLength  )
{
	m_bFlags &= ~DMUS_CURVE_RESET;	
	m_nResetValue = 0;	
	m_mtResetDuration = 0;
	
	switch( m_bEventType )
	{
		case DMUS_CURVET_PBCURVE:
			m_bFlags |= DMUS_CURVE_RESET;	
			m_nResetValue = 8192;	
			m_mtResetDuration = mtLength;
			break;
		
		case DMUS_CURVET_CCCURVE:
			switch( m_bCCData )
			{
				case 1:		// Mod Wheel
				case 2:		// Breath Controller
				case 4:		// Foot Controller
				case 5:		// Portamento Time
				case 12:	// FX1
				case 13:	// FX2
				case 64:	// Sustain Pedal
				case 65:	// Portamento On/Off
				case 66:	// Sostenuto Pedal
				case 67:	// Soft Pedal
				case 68:	// Legato Footswitch
				case 69:	// Hold 2
					m_bFlags |= DMUS_CURVE_RESET;	
					m_nResetValue = 0;	
					m_mtResetDuration = mtLength;
					break;
			}
			break;

		case DMUS_CURVET_PATCURVE:
		case DMUS_CURVET_MATCURVE:
			m_bFlags |= DMUS_CURVE_RESET;	
			m_nResetValue = 0;	
			m_mtResetDuration = mtLength;
			break;

		case DMUS_CURVET_RPNCURVE:
			switch( m_wParamType )
			{
			case 0: // Pitch Bend range
				m_bFlags |= DMUS_CURVE_RESET;
				m_nResetValue = 2 << 7; // Want MSB set to 2 (Whole step)
				m_mtResetDuration = mtLength;
				break;
			/* No acceptable default values for any other RPN types
			default:
				break;
			*/
			}
			break;

		/* No acceptable default values
		case DMUS_CURVET_NRPNCURVE:
			break;
		*/
	}
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPart::IsVarChoicesRowDisabled

bool CDirectMusicPart::IsVarChoicesRowDisabled( short nRow )
{
	short nRowType = GetVarChoicesRowType( nRow );
    short nNbrColumns = GetVarChoicesNbrColumns( nRow );
	DWORD dwOffset;

	for( short nColumn = 0 ;  nColumn < nNbrColumns ;  nColumn++ )
    {
		dwOffset = sga_nBtnBit[nRowType][nColumn];

		if( m_dwVariationChoices[nRow] & (1 << dwOffset) )
		{
			return false;
		}
    }

	return true;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPart::GetVarChoicesRowType

short CDirectMusicPart::GetVarChoicesRowType( short nRow )
{
	return (short)((m_dwVariationChoices[nRow] & DM_VF_MODE_BITS) >> 29);
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPart::GetVarChoicesNbrColumns

short CDirectMusicPart::GetVarChoicesNbrColumns( short nRow )
{
	short nNbrColumns = 0;
	
	switch( GetVarChoicesRowType(nRow) )
	{
		case IMA_ROWTYPE:
			nNbrColumns = IMA_NBR_COLUMNS;
			break;

		case DM_ROWTYPE:
			nNbrColumns = DM_NBR_COLUMNS;
			break;
	}

	ASSERT( nNbrColumns != 0 );
	return nNbrColumns;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPartRef::DM_SavePartRefInfoList

HRESULT CDirectMusicPartRef::DM_SavePartRefInfoList( IDMUSProdRIFFStream* pIRiffStream ) const
{
	if( m_strName.IsEmpty() )
	{
		return S_OK;
	}

 	IStream* pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

	HRESULT hr = S_OK;
    MMCKINFO ckMain;
    MMCKINFO ck;

	// Write INFO LIST header
	ckMain.fccType = DMUS_FOURCC_UNFO_LIST;
	if( pIRiffStream->CreateChunk(&ckMain, MMIO_CREATELIST) != 0 )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

	// Write PartRef name
	if( !m_strName.IsEmpty() )
	{
		ck.ckid = DMUS_FOURCC_UNAM_CHUNK;
		if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}

		hr = SaveMBStoWCS( pIStream, &m_strName );
		if( FAILED( hr ) )
		{
			goto ON_ERROR;
		}

		if( pIRiffStream->Ascend(&ck, 0) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}
	}

	if( pIRiffStream->Ascend(&ckMain, 0) != 0 )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

ON_ERROR:
    pIStream->Release();
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern IPersistStream::IsDirty

HRESULT CDirectMusicPattern::IsDirty()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_fModified )
	{
		return S_OK;
	}

    return S_FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern IPersistStream::GetSizeMax

HRESULT CDirectMusicPattern::GetSizeMax( ULARGE_INTEGER FAR* pcbSize )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(pcbSize);

    return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern::AllocPartRef

CDirectMusicPartRef* CDirectMusicPattern::AllocPartRef( void )
{
	CDirectMusicPartRef* pPartRef = new CDirectMusicPartRef( this );

	if( pPartRef )
	{
		// Add PartRef to Pattern's list of PartRefs
		m_lstPartRefs.AddTail( pPartRef );
	}

	return pPartRef;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern::DeletePartRef

void CDirectMusicPattern::DeletePartRef( CDirectMusicPartRef* pPartRef )
{
	ASSERT( pPartRef != NULL );

	// Remove PartRef from Pattern's PartRef list
	POSITION pos = m_lstPartRefs.Find( pPartRef );

	if( pos )
	{
		m_lstPartRefs.RemoveAt( pos );
	}

	pPartRef->SetPart( NULL );
	delete pPartRef;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern::DM_SavePatternRhythm

HRESULT CDirectMusicPattern::DM_SavePatternRhythm( IDMUSProdRIFFStream* pIRiffStream )
{
	// Ensure we have a rhythm map to save
	if( m_pRhythmMap == NULL )
	{
		return S_FALSE;
	}

    IStream* pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

	// Write Rhythm chunk header
    HRESULT hr = S_OK;
	MMCKINFO ck;
	ck.ckid = DMUS_FOURCC_RHYTHM_CHUNK;
    if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

	// Now save the RhythmMap for each measure
	DWORD dwBytesWritten;
	int i;
	for( i = 0 ;  i < m_wNbrMeasures ;  i++ )
	{
		// Write Rhythm chunk data
		hr = pIStream->Write( &m_pRhythmMap[i], sizeof(DWORD), &dwBytesWritten);
		if( FAILED( hr )
		||  dwBytesWritten != sizeof(DWORD) )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}
	}
	
	if( pIRiffStream->Ascend( &ck, 0 ) != 0 )
	{
 		hr = E_FAIL;
		goto ON_ERROR;
	}

ON_ERROR:
	pIStream->Release();
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern::DM_SavePatternInfoList

HRESULT CDirectMusicPattern::DM_SavePatternInfoList( IDMUSProdRIFFStream* pIRiffStream )
{
	if( m_strName.IsEmpty() )
	{
		return S_OK;
	}

	IStream* pIStream;
    pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

	// Write INFO LIST header
	HRESULT hr = S_OK;
    MMCKINFO ckMain;
	ckMain.fccType = DMUS_FOURCC_UNFO_LIST;
	if( pIRiffStream->CreateChunk(&ckMain, MMIO_CREATELIST) != 0 )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

	// Write Pattern name
	if( !m_strName.IsEmpty() )
	{
		MMCKINFO ck;
		ck.ckid = DMUS_FOURCC_UNAM_CHUNK;
		if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}

		hr = SaveMBStoWCS( pIStream, &m_strName );
		if( FAILED( hr ) )
		{
			goto ON_ERROR;
		}

		if( pIRiffStream->Ascend(&ck, 0) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}
	}

	if( pIRiffStream->Ascend(&ckMain, 0) != 0 )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

ON_ERROR:
    pIStream->Release();
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern::DM_SaveMotifSettingsChunk

HRESULT CDirectMusicPattern::DM_SaveMotifSettingsChunk( IDMUSProdRIFFStream* pIRiffStream )
{
    IStream* pIStream;
    HRESULT hr;
    MMCKINFO ck;
	DWORD dwBytesWritten;
	DMUS_IO_MOTIFSETTINGS dmusMotifSettingsIO;

	// Only save if this Pattern is a Motif
	if( !(m_wEmbellishment & EMB_MOTIF) )
	{
		return S_OK;
	}

    pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

	// Write Motif Settings chunk header
    ck.ckid = DMUS_FOURCC_MOTIFSETTINGS_CHUNK;
    if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

	// Prepare DMUS_IO_MOTIFSETTINGS
	memset( &dmusMotifSettingsIO, 0, sizeof(DMUS_IO_MOTIFSETTINGS) );

	ASSERT( m_mtLoopStart >= 0 );  
	ASSERT( m_mtLoopEnd > m_mtLoopStart );  
	ASSERT( m_mtLoopEnd <= CalcLength() );  

	dmusMotifSettingsIO.dwRepeats = m_dwRepeats;
	dmusMotifSettingsIO.mtPlayStart = m_mtPlayStart;
	dmusMotifSettingsIO.mtLoopStart = m_mtLoopStart;
	dmusMotifSettingsIO.mtLoopEnd = m_mtLoopEnd;
	dmusMotifSettingsIO.dwResolution = m_dwResolution;

	// Write Motif Settings chunk data
	hr = pIStream->Write( &dmusMotifSettingsIO, sizeof(DMUS_IO_MOTIFSETTINGS), &dwBytesWritten);
	if( FAILED( hr )
	||  dwBytesWritten != sizeof(DMUS_IO_MOTIFSETTINGS) )
	{
        hr = E_FAIL;
        goto ON_ERROR;
	}
	
	if( pIRiffStream->Ascend( &ck, 0 ) != 0 )
	{
 		hr = E_FAIL;
		goto ON_ERROR;
	}

ON_ERROR:
	RELEASE( pIStream );
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern::FindPart

CDirectMusicPart* CDirectMusicPattern::FindPart( DWORD dwChannelID ) const
{
    POSITION pos = m_lstPartRefs.GetHeadPosition();

    while( pos )
    {
        CDirectMusicPartRef *pPartRef = m_lstPartRefs.GetNext( pos );

		if( dwChannelID == pPartRef->m_dwPChannel )
		{
			return pPartRef->m_pDMPart;
		}
    }

	return NULL;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicPattern::FindPartRefByPChannel

CDirectMusicPartRef* CDirectMusicPattern::FindPartRefByPChannel( DWORD dwPChannel ) const
{
	POSITION pos = m_lstPartRefs.GetHeadPosition();

	while( pos )
	{
		CDirectMusicPartRef* pPartRef = m_lstPartRefs.GetNext( pos );

		if( pPartRef->m_dwPChannel == dwPChannel )
		{
			return pPartRef;
		}
	}

	return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Shared\SharedPianoRoll.h ===
// SharedPianoRoll.h : Declarations for shared PianoRoll code between sequences and midistrips

#ifndef __SHAREDPIANOROLL_H_
#define __SHAREDPIANOROLL_H_

#define MAX_NOTE_HEIGHT		100
#define HORIZ_LINE_HEIGHT	1

#define DEFAULT_VERTICAL_SCROLL 70

#define NOTATION_FONT_ZOOMFACTOR 4
#define NOTATION_FONT_CLEF_ZOOMFACTOR 7
//int nTopAdjustNumerator = 10;
//int nTopAdjustDenominator = 3;
//int nBottomAdjustNumerator = 3;
//int nBottomAdjustDenominator = 2;
#define TOPADJUST ((m_lMaxNoteHeight * 10) / 3)
#define BOTTOMADJUST ((m_lMaxNoteHeight * 3) / 2)
#define TREBLE_TOP 13
#define TREBLE_BOTTOM 21
#define BASS_TOP 19
#define BASS_BOTTOM 25

#define MINIMUM_ZOOM_LEVEL (0.02)

#define SCROLL_HORIZ_AMOUNT 10 
#define SCROLL_HORIZ_RANGE 40
#define SCROLL_VERT_AMOUNT 10
#define SCROLL_VERT_RANGE 30

#define MINIMIZE_HEIGHT		   20
#define DEFAULT_HEIGHT		  200
#define MAXIMUM_HEIGHT		 1000

#define COLOR_EARLY_NOTES RGB(230,230,230)
#define COLOR_HATCH_OVERLAPPING RGB(230,230,230)

#define COLOR_DEFAULT_UNSELECTED RGB(10,10,255)
#define COLOR_DEFAULT_SELECTED RGB(255,0,0)
#define COLOR_DEFAULT_OVERLAPPING RGB(128,0,128)
#define COLOR_DEFAULT_ACCIDENTAL RGB(30, 160, 35)

#define PIANOROLL_BLACKKEY_COLOR	RGB( 0, 0, 0 )
#define PIANOROLL_WHITEKEY_COLOR	RGB( 255, 255, 232 )
#define PIANOROLL_RED_COLOR			RGB( 255, 0, 0 )

typedef enum tagPIANO_KEY_COLOR
{
	WHITE,
	BLACK
} PIANO_KEY_COLOR;

extern const PIANO_KEY_COLOR PianoKeyColor[];

extern const int aChromToScaleSharps[12];
extern const int aChromToScaleFlats[12];
extern const int aChromToSharpAccidentals[12];
extern const int aChromToFlatAccidentals[12];
extern const int aScaleToChromNat[7];
extern const int aDoubleScaleToChrom[14];

extern const int aTrebleSharpKeyToPosx2[7];
extern const int aBassSharpKeyToPosx2[7];
extern const int aTrebleFlatKeyToPosx2[7];
extern const int aBassFlatKeyToPosx2[7];
extern const char MidiValueToName[61];
extern const char ScaleToName[11];

extern const char *acDrums[61];

int MIDIToHybridPos( BYTE bMIDIValue, const int *paChromToScale );
void ComputeNoteMarkerVerticalRect( RECT &rectMark, BOOL fHybridNotation, BOOL fDisplayingFlats, long lMaxNoteHeight, long lInsertVal );
void DrawHybridLinesHelper( HDC hDC, const RECT &rectClip, int nOldBottomNote, int nOldTopNote, COLORREF crWhite, long lMaxNoteHeight, bool fDrawWhite );
void DrawHorizontalLinesHelper( HDC hDC, const RECT &rectClip, int nBottomNote, int nTopNote, COLORREF crWhite, COLORREF crBlack, long lMaxNoteHeight, bool fDrawWhite );
BYTE CurveTypeToStripCCType( BYTE bType, BYTE bCCData );
BYTE StripCCTypeToCurveType( BYTE bStripCCType );
WORD GetCCTypeSortValue( BYTE bCCType, WORD wRPNType );
DWORD PChannelToStripIndex( DWORD dwPChannel );

#endif //__SHAREDPIANOROLL_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Shared\SharedPianoRoll.cpp ===
// SharedPianoRoll.cpp : Shared PianoRoll code between sequences and midistrips
#include "stdafx.h"
#include "SharedPianoRoll.h"
#include <dmusici.h>
#include "CurveStrip.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

const PIANO_KEY_COLOR PianoKeyColor[] = {
	WHITE,BLACK,WHITE,BLACK,WHITE,WHITE,BLACK,WHITE,BLACK,WHITE,BLACK,WHITE };

const int aChromToScaleSharps[12] = { 0, 0, 1, 1, 2, 3, 3, 4, 4, 5, 5, 6 };
const int aChromToScaleFlats[12] = { 0, 1, 1, 2, 2, 3, 4, 4, 5, 5, 6, 6 };
const int aChromToSharpAccidentals[12] = { 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0 };
const int aChromToFlatAccidentals[12] =  { 0,-1, 0,-1, 0, 0,-1, 0,-1, 0,-1, 0 };
const int aScaleToChromNat[7] = { 0, 2, 4, 5, 7, 9, 11 };
const int aDoubleScaleToChrom[14] = { 0, 1, 2, 3, 4, 4, 5, 6, 7, 8, 9, 10, 11, 11 };

const int aTrebleSharpKeyToPosx2[7] = { 44, 41, 45, 42, 39, 43, 40 };
const int aBassSharpKeyToPosx2[7] = { 30, 27, 31, 28, 25, 29, 26 };
const int aTrebleFlatKeyToPosx2[7] = { 40, 43, 39, 42, 38, 41, 37 };
const int aBassFlatKeyToPosx2[7] = { 26, 29, 25, 28, 24, 27, 23 };
const char MidiValueToName[61] = "C    C#/DbD    D#/EbE    F    F#/GbG    G#/AbA    A#/BbB    ";
const char ScaleToName[11] = "ACEGBDFACE";

// Drums
const char *acDrums[61] = {
"High Q",
"Slap ",
"Scratch Push",
"Scratch Pull",
"Sticks",
"Square Click",
"Click Metronome",
"Bell Metronome",
"Kick Drum 2",
"C3: Kick Drum 1",
"Side Stick",
"Snare Drum 1",
"Hand Clap",
"Snare Drum 2",
"Low Tom 2",
"Closed Hi-Hat",
"Low Tom 1",
"Pedal Hi-Hat",
"Mid Tom 2",
"Open Hi-Hat",
"Mid Tom 1",
"C4: Hi Tom 2 ",
"Crash Cymbal 1",
"Hi Tom 1",
"Ride Cymbal 1",
"Chinese Cymbal ",
"Ride Bell",
"Tambourine",
"Splash Cymbal",
"Cowbell",
"Crash Cymbal 2",
"Vibra-slap",
"Ride Cymbal 2",
"C5: Hi Bongo",
"Low Bongo",
"Mute Hi Conga",
"Open Hi Conga",
"Low Conga",
"Hi Timbale",
"Low Timbale",
"Hi Agogo",
"Low Agogo",
"Cabasa",
"Maracas",
"Short Whistle",
"C6: Long Whistle",
"Short Guiro",
"Long Guiro",
"Claves",
"Hi Woodblock",
"Low Woodblock",
"Mute Cuica",
"Open Cuica",
"Mute Triangle",
"Open Triangle",
"Shaker",
"Jingle Bell",
"C7: Belltree",
"Castanets",
"Mute Surdo",
"Open Surdo" };

int MIDIToHybridPos( BYTE bMIDIValue, const int *paChromToScale )
{
	return (bMIDIValue / 12) * 7 + paChromToScale[bMIDIValue % 12];
}

void ComputeNoteMarkerVerticalRect( RECT &rectMark, BOOL fHybridNotation, BOOL fDisplayingFlats, long lMaxNoteHeight, long lInsertVal )
{
	if( fHybridNotation )
	{
		int iHybridPos;
		// FLATS
		if( fDisplayingFlats )
		{
			iHybridPos = MIDIToHybridPos( (BYTE)lInsertVal, aChromToScaleFlats);
		}
		// SHARPS
		else
		{
			iHybridPos = MIDIToHybridPos( (BYTE)lInsertVal, aChromToScaleSharps);
		}

		rectMark.bottom = ((76 - iHybridPos) * lMaxNoteHeight) >> 1;
		
		// Find the top of the note's rectangle
		// Note: (m_lMaxNoteHeight - m_lMaxNoteHeight / 2) != m_lMaxNoteHeight / 2 because of rounding errors
		rectMark.bottom -= (lMaxNoteHeight - lMaxNoteHeight / 2) / 2;
		rectMark.top = rectMark.bottom - (lMaxNoteHeight / 2);
		
		// Ensure the note is at least one pixel high
		if( rectMark.top == rectMark.bottom )
		{
			rectMark.top--;
		}
	}
	else
	{
		rectMark.top = (127 - lInsertVal) * lMaxNoteHeight + lMaxNoteHeight / 4;

		// Find the bottom of the mark's rectangle
		if( (lMaxNoteHeight / 2) != 0 )
		{
			rectMark.bottom = rectMark.top + (lMaxNoteHeight / 2);
		}
		else
		{
			rectMark.bottom = rectMark.top + 1;
		}
	}
}

void DrawHybridLinesHelper( HDC hDC, const RECT &rectClip, int nOldBottomNote, int nOldTopNote, COLORREF crWhite, long lMaxNoteHeight, bool fDrawWhite )
{
	HPEN hpenLine = ::CreatePen( PS_SOLID, 1, RGB(0, 0, 0) );
	if( !hpenLine )
	{
		return;
	}

	HPEN hpenGreyLine = ::CreatePen( PS_SOLID, 1, RGB(200, 200, 200) );
	if( !hpenGreyLine )
	{
		::DeleteObject( hpenLine );
		return;
	}

	// Set background to white
	if( fDrawWhite )
	{
		COLORREF crOldBkColor = ::GetBkColor( hDC );
		::SetBkColor( hDC, ::GetNearestColor( hDC, crWhite ) );
		::ExtTextOut( hDC, 0, 0, ETO_OPAQUE, &rectClip, NULL, 0, NULL);
		::SetBkColor( hDC, crOldBkColor );
	}

	// Save the current pen
	HPEN hpenOld = static_cast<HPEN> (::SelectObject( hDC, hpenLine ));

	// Draw the black lines of the staves
	int nBottomNote = max( nOldBottomNote, 13 );
	int nTopNote = min( nOldTopNote, 23 );

	int nVertPos = (38 - nBottomNote) * ( lMaxNoteHeight );
	for( int nValue = nBottomNote; nValue <= nTopNote; nValue++ )
	{
		// Skip middle C
		if( nValue == 18 )
		{
			nVertPos -= lMaxNoteHeight;
			continue;
		}

		::MoveToEx( hDC, rectClip.left, nVertPos, NULL );
		::LineTo( hDC, rectClip.right, nVertPos );
		nVertPos -= lMaxNoteHeight;
	}

	// Draw the grey lines outside of the staves
	::SelectObject( hDC, hpenGreyLine );
	nVertPos = (38 - nOldBottomNote) * ( lMaxNoteHeight );
	for( nValue = nOldBottomNote; nValue <= nOldTopNote; nValue++ )
	{
		// Skip the staves
		if( (nValue != 18) && (nValue >= 13) && (nValue <= 23) )
		{
			nVertPos -= lMaxNoteHeight;
			continue;
		}

		::MoveToEx( hDC, rectClip.left, nVertPos, NULL );
		::LineTo( hDC, rectClip.right, nVertPos );
		nVertPos -= lMaxNoteHeight;
	}

	::SelectObject( hDC, hpenOld );
	::DeleteObject( hpenLine );
	::DeleteObject( hpenGreyLine );
}

void DrawHorizontalLinesHelper( HDC hDC, const RECT &rectClip, int nBottomNote, int nTopNote, COLORREF crWhite, COLORREF crBlack, long lMaxNoteHeight, bool fDrawWhite )
{
	HPEN hpenNoteLine = ::CreatePen( PS_SOLID, 1, RGB(0, 0, 0) );
	if( !hpenNoteLine )
	{
		return;
	}

	HPEN hpenOld = static_cast<HPEN> (::SelectObject( hDC, hpenNoteLine ));

	RECT rectNote;
	rectNote.left = rectClip.left;
	rectNote.right = rectClip.right;

	COLORREF crOldBkColor = ::GetBkColor( hDC );

	// Set background to white (this takes care of all the white keys)
	if( fDrawWhite )
	{
		::SetBkColor( hDC, ::GetNearestColor( hDC, crWhite ) );
		::ExtTextOut( hDC, 0, 0, ETO_OPAQUE, &rectClip, NULL, 0, NULL);
	}

	// Now, draw all the black keys
	::SetBkColor( hDC, ::GetNearestColor( hDC, crBlack ) );
	for( int nValue = nBottomNote; nValue <= nTopNote; nValue++ )
	{
		// Compute the top of the note
		rectNote.top = ( 127 - nValue ) * ( lMaxNoteHeight );

		// If the top is below the display, continue
		// TODO: Remove this check
		if( rectNote.top > rectClip.bottom )
		{
			ASSERT(FALSE);
			continue;
		}

		// Compute the bottom of the note
		rectNote.bottom = rectNote.top + ( lMaxNoteHeight );

		// If the bottom is above the display, break out of the loop (since we're done)
		// TODO: Remove this check
		if( rectNote.bottom < rectClip.top )
		{
			ASSERT(FALSE);
			break;
		}

		rectNote.top--;
		rectNote.bottom--;

		if( PianoKeyColor[ nValue % 12 ] == BLACK )
		{
			// Copied from the implementation of CDC::FillSolidRect (the SetBkColor is above)
			::ExtTextOut( hDC, 0, 0, ETO_OPAQUE, &rectNote, NULL, 0, NULL);
		}
		
		::MoveToEx( hDC, rectNote.left, rectNote.top, NULL );
		::LineTo( hDC, rectNote.right, rectNote.top );
	}
	::SetBkColor( hDC, crOldBkColor );
	::SelectObject( hDC, hpenOld );
	::DeleteObject( hpenNoteLine );
}

BYTE CurveTypeToStripCCType( BYTE bType, BYTE bCCData )
{
	switch( bType )
	{
		case DMUS_CURVET_PBCURVE:
			return CCTYPE_PB_CURVE_STRIP;
			break;

		case DMUS_CURVET_CCCURVE:
			ASSERT( (bCCData >= 0)  &&  (bCCData <= 127 ) );
			return bCCData;
			break;

		case DMUS_CURVET_MATCURVE:
			return CCTYPE_MAT_CURVE_STRIP;
			break;

		case DMUS_CURVET_PATCURVE:
			return CCTYPE_PAT_CURVE_STRIP;
			break;

		case DMUS_CURVET_RPNCURVE:
			return CCTYPE_RPN_CURVE_STRIP;
			break;

		case DMUS_CURVET_NRPNCURVE:
			return CCTYPE_NRPN_CURVE_STRIP;
			break;

		default:
			ASSERT( FALSE );	// Should not happen
			break;
	}

	return 0xFF;
}

BYTE StripCCTypeToCurveType( BYTE bStripCCType )
{
	if( bStripCCType >= 0
	&&  bStripCCType <= 127 )
	{
		return DMUS_CURVET_CCCURVE;
	}
	else
	{
		switch( bStripCCType )
		{
			case CCTYPE_PB_CURVE_STRIP:
				return DMUS_CURVET_PBCURVE;
				break;

			case CCTYPE_MAT_CURVE_STRIP:
				return DMUS_CURVET_MATCURVE;
				break;

			case CCTYPE_PAT_CURVE_STRIP:
				return DMUS_CURVET_PATCURVE;
				break;

			case CCTYPE_RPN_CURVE_STRIP:
				return DMUS_CURVET_RPNCURVE;
				break;

			case CCTYPE_NRPN_CURVE_STRIP:
				return DMUS_CURVET_NRPNCURVE;
				break;

			default:
				ASSERT( FALSE );	// Should not happen
				break;
		}
	}

	return 0xFF;
}

WORD GetCCTypeSortValue( BYTE bCCType, WORD wRPNType )
{
	WORD wCCTypeSortValue = bCCType;

	if( wCCTypeSortValue >= 128 )
	{
		wCCTypeSortValue -= 128; 
	}
	else
	{
		wCCTypeSortValue += NBR_EXTRA_CCS;
	}

	if( bCCType == CCTYPE_RPN_CURVE_STRIP )
	{
		return WORD(NBR_EXTRA_CCS + wRPNType + 128);
	}
	else if( bCCType == CCTYPE_NRPN_CURVE_STRIP )
	{
		return WORD(NBR_EXTRA_CCS + wRPNType + 128 + 0x4000);
	}

	return wCCTypeSortValue;
}

DWORD PChannelToStripIndex( DWORD dwPChannel )
{
	switch( dwPChannel )
	{
	case DMUS_PCHANNEL_BROADCAST_SEGMENT:
		return 0xFFFFFFFF; // -1
	case DMUS_PCHANNEL_BROADCAST_AUDIOPATH:
		return 0xFFFFFFFE; // -2
	case DMUS_PCHANNEL_BROADCAST_GROUPS:
		return 0xFFFFFFFD; // -3
	case DMUS_PCHANNEL_BROADCAST_PERFORMANCE:
		return 0xFFFFFFFC; // -4
	default:
		return dwPChannel;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Shared\SharedPattern.h ===
#ifndef __SHAREDPATTERN_H__
#define __SHAREDPATTERN_H__

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

// SharedPattern.h : header file
//

#define DX8_PART_SIZE 160
#define DX8_PARTREF_SIZE 28

// Pattern Flags
#define PF_FILL     0x0001      // Fill pattern
#define PF_START    0x0002      // May be starting pattern
#define PF_INTRO    0x0002
#define PF_WHOLE    0x0004      // Handles chords on measures
#define PF_HALF     0x0008      // Chords every two beats
#define PF_QUARTER  0x0010      // Chords on beats
#define PF_BREAK    0x0020
#define PF_END      0x0040
#define PF_A        0x0080
#define PF_B        0x0100
#define PF_C        0x0200
#define PF_D        0x0400
#define PF_E        0x0800
#define PF_F        0x1000
#define PF_G        0x2000
#define PF_H        0x10000
#define PF_STOPNOW  0x4000
#define PF_INRIFF   0x8000
#define PF_MOTIF    0x20000     // this pattern is a motif, not a regular pattern
#define PF_BEATS    ( PF_WHOLE | PF_HALF | PF_QUARTER )
#define PF_RIFF     ( PF_INTRO | PF_BREAK | PF_FILL | PF_END )
#define PF_GROOVE   ( PF_A | PF_B | PF_C | PF_D | PF_E | PF_F | PF_G | PF_H )


// Curve flip flags
#define CURVE_FLIPTIME	1
#define CURVE_FLIPVALUE	2


// Chord flags
#define CHORD_INVERT    0x10        // This chord may be inverted       
#define CHORD_FOUR      0x20        // This should be a 4 note chord    
#define CHORD_UPPER     0x40        // Shift upper octave down          
#define CHORD_SIMPLE    0x80        // This is a simple chord           
#define CHORD_COUNT     0xF         // Chord count bits (up to 15)      
#define CHORD_EX_INVERT 0x10000000  // This chord may be inverted       
#define CHORD_EX_FOUR   0x20000000  // This should be a 4 note chord    
#define CHORD_EX_UPPER  0x40000000  // Shift upper octave down          
#define CHORD_EX_SIMPLE 0x80000000  // This is a simple chord           
#define CHORD_EX_COUNT  0x0F000000  // Chord count bits (up to 15)      
#define CHORD_EX_BITS   0xFF000000  // Flag bits region of chord.
#define CHORD_PATTERN   0x00FFFFFF  // Pattern region of chord.


// Embellishment flags
#define EMB_NORMAL	0
#define EMB_FILL	1
#define EMB_BREAK	2
#define EMB_INTRO	4
#define EMB_END		8
#define EMB_MOTIF	16
#define EMB_ALL		0xFFFF


// Conversion macros
#define TS_GRID_TO_CLOCKS( grid, TimeSig ) ( ((grid) / (TimeSig).m_wGridsPerBeat) * (DM_PPQNx4 / (TimeSig).m_bBeat) + ((grid) % (TimeSig).m_wGridsPerBeat) * ((DM_PPQNx4 / (TimeSig).m_bBeat) / (TimeSig).m_wGridsPerBeat) )
#define TS_CLOCKS_TO_GRID( clocks, TimeSig ) ( ((clocks) / (DM_PPQNx4 / (TimeSig).m_bBeat)) * (TimeSig).m_wGridsPerBeat + ((clocks) % (DM_PPQNx4 / (TimeSig).m_bBeat)) / ((DM_PPQNx4 / (TimeSig).m_bBeat) / (TimeSig).m_wGridsPerBeat) )

#define GRID_TO_CLOCKS( grid, pDMPart ) ( ((grid) / (pDMPart)->m_TimeSignature.m_wGridsPerBeat) * (pDMPart)->m_mtClocksPerBeat + ((grid) % (pDMPart)->m_TimeSignature.m_wGridsPerBeat) * (pDMPart)->m_mtClocksPerGrid )
#define CLOCKS_TO_GRID( clocks, pDMPart ) ( ((clocks) / (pDMPart)->m_mtClocksPerBeat) * (pDMPart)->m_TimeSignature.m_wGridsPerBeat + ((clocks) % (pDMPart)->m_mtClocksPerBeat) / (pDMPart)->m_mtClocksPerGrid )


// Number of variations
#define NBR_VARIATIONS	32

#define DM_FOURCC_VARCHOICES_FORM    mmioFOURCC('v','a','r','f')
#define DM_FOURCC_VARCHOICES_CHUNK   mmioFOURCC('v','a','r','h')

// Format used for Copy/Paste
typedef struct ioVarChoices
{
    DWORD   m_dwVariationChoices[NBR_VARIATIONS];	// MAOW VarChoices bit field
	DWORD   m_dwSelectedFlagBtns[NBR_VARIATIONS];	// selected function buttons
	BYTE    m_bSelectedRowBtns[NBR_VARIATIONS];		// selected function buttons
} ioVarChoices;


// Various types of modes (rows) ////////////////////////////
#define IMA_ROWTYPE		0
#define DM_ROWTYPE		1
#define NBR_ROWTYPES	2
#define IMA_NBR_COLUMNS		15
#define DM_NBR_COLUMNS		30


// Variation Choices Flags
#define IMA_VF_FLAG_BITS	0x00007FFF	 // Flag bits used for IMA mode 
#define DM_VF_FLAG_BITS		0x5FFFFFFF	 // Flag bits used for all other modes 
#define DM_VF_MODE_BITS		0xA0000000	 // 2 bits reserved for modes
#define DM_VF_MODE_IMA		0x00000000	 // IMA mode 
#define DM_VF_MODE_DMUSIC	0x20000000	 // DirectMusic mode 

#define DM_VF_MAJOR			0x0000007F   // Seven positions in the scale - major chords.    
#define DM_VF_MINOR			0x00003F80   // Seven positions in the scale - minor chords.    
#define DM_VF_OTHER			0x001FC000   // Seven positions in the scale - other chords.    
#define DM_VF_ROOT_SCALE	0x00200000   // Handles chord roots in the scale.         
#define DM_VF_ROOT_FLAT		0x00400000   // Handles flat chord roots (based on scale notes).         
#define DM_VF_ROOT_SHARP	0x00800000   // Handles sharp chord roots (based on scale notes).         
#define DM_VF_TYPE_TRIAD	0x01000000   // Handles simple chords - triads.  
#define DM_VF_TYPE_6AND7	0x02000000   // Handles simple chords - 6 and 7.  
#define DM_VF_TYPE_COMPLEX  0x04000000   // Handles complex chords.  
#define DM_VF_DEST_TO1      0x08000000   // Handles transitions to 1 chord.  
#define DM_VF_DEST_TO5      0x10000000   // Handles transitions to 5 chord. 
#define DM_VF_DEST_TOOTHER  0x40000000   // Handles transitions to other chord. 


#define SUBCHORD_BASS		0
#define SUBCHORD_UPPER_1	1
#define SUBCHORD_UPPER_2	2
#define SUBCHORD_UPPER_3	3


interface IDMUSProdFramework;
IStream *CreateStreamForVarChoices( IDMUSProdFramework *pIDMUSProdFramework, DWORD adwVariationChoices[NBR_VARIATIONS] );

#endif // __SHAREDPATTERN_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Shared\TabBoundaryFlagsResource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by TabBoundaryFlags.rc
//
#define IDD_TAB_BOUNDARY_FLAGS          275
#define IDC_STATIC_PROMPT               501
#define IDC_COMBO_BOUNDARY              502
#define IDC_RADIO_SWITCH_ANY_TIME       503
#define IDC_RADIO_SWITCH_ANY_GRID       504
#define IDC_RADIO_SWITCH_ANY_BEAT       505
#define IDC_RADIO_SWITCH_NEXT_BOUNDARY  506
#define IDC_ALIGN_OPTIONS_PROMPT        507
#define IDC_CHECK_BOUNDARY              508
#define IDC_STATIC_NO_MARKERS           509
#define IDC_RADIO_TIMING_QUICK          510
#define IDC_RADIO_TIMING_AFTERPREPARETIME 511
#define IDS_START_PROMPT1               512
#define IDC_RADIO_SWITCH_ANY_BAR        512
#define IDS_START_PROMPT2               513
#define IDS_TRANSITION_PROMPT1          514
#define IDS_TRANSITION_PROMPT2          515
#define IDC_CHECK_SEG_DEFAULT           516
#define IDC_RADIO_NOINVALIDATE          1216
#define IDC_RADIO_INVALIDATEPRI         1217
#define IDC_RADIO_INVALIDATE            1218

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         517
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Shared\SharedPropPageNote.cpp ===
// SharedPropPageNote.cpp : implementation file
//

#include "stdafx.h"
#include "resource.h"
#include "PropPageNote.h"
#include "LockoutNotification.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


//static const TCHAR g_MidiValueToName[25] = _T("C DbD EbE F GbG AbA BbB ");
static const TCHAR g_pstrUnknown[11] = _T("----------");

PropPageNote::~PropPageNote()
{
}

void PropPageNote::SetObject( IDMUSProdPropPageObject* pINewPropPageObject )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	m_pIPPO = pINewPropPageObject;
}

int PropPageNote::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	// Attach the window to the property page structure.
	// This has been done once already in the main application
	// since the main application owns the property sheet.
	// It needs to be done here so that the window handle can
	// be found in the DLLs handle map.
	if( !FromHandlePermanent( m_hWnd ) )
	{
		HWND hWnd = m_hWnd;
		m_hWnd = NULL;
		Attach( hWnd );
		m_fNeedToDetach = TRUE;
	}

	if (CPropertyPage::OnCreate(lpCreateStruct) == -1)
		return -1;
	return 0;
}

void PropPageNote::OnDestroy() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Detach the window from the property page structure.
	// This will be done again by the main application since
	// it owns the property sheet.  It needs o be done here
	// so that the window handle can be removed from the
	// DLLs handle map.
	if( m_fNeedToDetach && m_hWnd )
	{
		HWND hWnd = m_hWnd;
		Detach();
		m_hWnd = hWnd;
	}

	CPropertyPage::OnDestroy();
	
}

void PropPageNote::SetItemWidth( int nItem, int nWidth)
{
	CEdit* pEdit;
	pEdit = (CEdit *) GetDlgItem(nItem);
	if ((pEdit != NULL) && (nWidth >=0))
	{
		pEdit->LimitText( nWidth );
	}
}

BOOL PropPageNote::IsEditEmpty(CEdit* pEdit)
{
	CString csTmp;

	pEdit->GetWindowText(csTmp);
	if (csTmp.GetLength() == 0)
	{
		return FALSE;
	}
	return TRUE;
}

void PropPageNote::EnableItem(int nItem, BOOL fEnable)
{
	// prevent control notifications from being dispatched changing edit text
	CLockoutNotification LockoutNotification( m_hWnd );

	CWnd* pWnd;
	pWnd = GetDlgItem(nItem);
	if (pWnd)
	{
		BOOL fRes, fRes2;
		fRes = FALSE;
		fRes2 = pWnd->EnableWindow(TRUE);
		if ( !fEnable )
		{
			TCHAR tcstrTmp[DIALOG_LEN];
			GetDlgItemText( nItem, tcstrTmp, DIALOG_LEN );
			if ( _tcscmp( tcstrTmp, g_pstrUnknown ) != 0 )
			{
				SetDlgItemText( nItem, g_pstrUnknown );
				fRes = TRUE;
			}
		}
		/*
		if (fRes || fRes2)
		{
			RECT rect;
			pWnd->GetWindowRect(&rect);
			ScreenToClient(&rect);
			InvalidateRect(&rect);
		}
		*/
	}
}

void PropPageNote::EnableItem(int nItem, BOOL fEnable, long lValue)
{
	// Not necessary - this method is only called from SetNote, which already
	// does the notification lockout
	/*
	CLockoutNotification LockoutNotification( m_hWnd );
	*/

	CWnd* pWnd;
	pWnd = GetDlgItem(nItem);
	if (pWnd)
	{
		BOOL fRes, fRes2;
		fRes = FALSE;
		fRes2 = pWnd->EnableWindow(TRUE);
		if (fEnable)
		{
			BOOL fTrans;
			if( (lValue != (signed int) GetDlgItemInt( nItem, &fTrans )) || !fTrans  )
			{
				SetDlgItemInt( nItem, lValue );
				fRes = TRUE;
			}
			else
			{
				TCHAR tcstrTmp[DIALOG_LEN];
				GetDlgItemText( nItem, tcstrTmp, DIALOG_LEN );
				if ( (tcstrTmp[0] == NULL) || (_tcscmp( tcstrTmp, g_pstrUnknown ) == 0) )
				{
					SetDlgItemInt( nItem, lValue );
					fRes = TRUE;
				}
			}
		}
		else
		{
			TCHAR tcstrTmp[DIALOG_LEN];
			GetDlgItemText( nItem, tcstrTmp, DIALOG_LEN );
			if ( _tcscmp( tcstrTmp, g_pstrUnknown ) != 0 )
			{
				SetDlgItemText( nItem, g_pstrUnknown );
				fRes = TRUE;
			}
		}
		/*
		if (fRes || fRes2)
		{
			RECT rect;
			pWnd->GetWindowRect(&rect);
			ScreenToClient(&rect);
			InvalidateRect(&rect);
		}
		*/
	}
}

void PropPageNote::DisableItem(int nItem)
{
	// prevent control notifications from being dispatched changing edit text
	CLockoutNotification LockoutNotification( m_hWnd );

	CWnd* pWnd;
	//TRACE("DisableItem in %d\n", ::timeGetTime());
	pWnd = GetDlgItem(nItem);
	if (pWnd)
	{
		SetDlgItemText( nItem, g_pstrUnknown );
		// BUGBUG: This call can be really slow when we get here when adding notes
		// from a MIDI keyboard
		pWnd->EnableWindow(FALSE);
	}
	//TRACE("DisableItem out %d\n", ::timeGetTime());
}

void PropPageNote::OnChangeNoteEditDurtick() 
{
	HandleEditChange(m_spinDurTick, CHGD_DURTICK,
		m_PropNote.m_lDurTick);
}

void PropPageNote::OnChangeNoteEditDurgrid() 
{
	HandleEditChange(m_spinDurGrid, CHGD_DURGRID,
		m_PropNote.m_lDurGrid);
}

void PropPageNote::OnChangeNoteEditDurbeat() 
{
	HandleEditChange(m_spinDurBeat, CHGD_DURBEAT,
		m_PropNote.m_lDurBeat);
}

void PropPageNote::OnChangeNoteEditDurbar() 
{
	HandleEditChange(m_spinDurBar, CHGD_DURBAR,
		m_PropNote.m_lDurBar);
}

void PropPageNote::OnChangeNoteEditVelocity() 
{
	HandleEditChangeByte(m_spinVelocity, CHGD_VELOCITY,
		m_PropNote.m_bVelocity);
}

void PropPageNote::OnDeltaposNoteSpinMidinote(NMHDR* pNMHDR, LRESULT* pResult) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if (m_spinMidiNote.GetSafeHwnd() == NULL)
	{
		return;
	}

	if( m_dwChanging & CHGD_MIDIVALUE )
	{
		return;
	}

	NM_UPDOWN* pNMUpDown = (NM_UPDOWN*)pNMHDR;
	long lTemp;

	lTemp = m_PropNote.m_bMIDIValue + pNMUpDown->iDelta;

	// Move up or down an octave if we've wrapped around
	long lNewOctave = m_PropNote.m_bOctave;
	if (lTemp > 11)
	{
		if( !(m_PropNote.m_dwUndetermined & UD_OCTAVE) )
		{
			if( lNewOctave < 10)
			{
				// Go up an octave
				lTemp -= 12;
				lNewOctave++;
			}
			else
			{
				// Snap to 7 (G10)
				lTemp = 7;
			}
		}
		else
		{
			lTemp -= 12;
		}
	}
	else if (lTemp < 0)
	{
		if( !(m_PropNote.m_dwUndetermined & UD_OCTAVE) )
		{
			if( lNewOctave > 0)
			{
				// Go down an octave
				lTemp += 12;
				lNewOctave--;
			}
			else
			{
				// Snap to C0
				lTemp = 0;
			}
		}
		else
		{
			lTemp += 12;
		}
	}

	// Snap to G10
	if( lNewOctave * 12 + lTemp > 127 )
	{
		ASSERT( lNewOctave == 10 );
		lTemp = 7;
	}

	// update mPropNote
	BYTE bValue = BYTE(lNewOctave * 12 + lTemp);
	if ( bValue <= 127 && (lTemp != m_PropNote.m_bMIDIValue) )
	{
		m_PropNote.m_bMIDIValue = (BYTE)lTemp;
		m_PropNote.m_dwUndetermined = ~UD_MIDIVALUE;
		m_PropNote.m_dwChanged = CHGD_MIDIVALUE;

		// The text will be updated when SetNote() is called in response to UpdatePPO()
		/*
		// update the displayed MidiNote character representation
		CString strTmp = CString(g_MidiValueToName).Mid(lTemp*2, 2);
		m_editMidiNote.SetWindowText( strTmp );

		// The the ScaleValue slider and editbox and the accidntal spin controls will be updated
		// by the the MIDIMgr calling the NotePropPageMgr's Refresh() method.
		EnableItem(IDC_NOTE_EDIT_MIDINOTE, TRUE);
		*/

		if( lNewOctave != m_PropNote.m_bOctave )
		{
			m_PropNote.m_bOctave = (BYTE) lNewOctave;
			m_PropNote.m_dwUndetermined &= ~UD_OCTAVE;
			m_PropNote.m_dwChanged |= CHGD_OCTAVE;
		}

		UpdatePPO();
	}
	// Yes, we've handled this message, don't change the position of the spin control
	*pResult = 1;
}

void PropPageNote::OnKillfocusNoteEditOctave() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	if (m_spinOctave.GetSafeHwnd() != NULL)
	{
		TCHAR tcstrTmp[DIALOG_LEN];
		GetDlgItemText(IDC_NOTE_EDIT_OCTAVE, tcstrTmp, DIALOG_LEN);
		ValidateOctave( tcstrTmp );
	}
}

void PropPageNote::OnChangeNoteEditOctave() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	if (m_spinOctave.GetSafeHwnd() != NULL)
	{
		TCHAR tcstrTmp[DIALOG_LEN];
		if (GetDlgItemText(IDC_NOTE_EDIT_OCTAVE, tcstrTmp, DIALOG_LEN))
		{
			ValidateOctave( tcstrTmp );
		}
	}
}

void PropPageNote::OnChangeNoteEditChordbar() 
{
	HandleEditChange(m_spinChordBar, CHGD_CHORDBAR,
		m_PropNote.m_lChordBar);
}

void PropPageNote::OnChangeNoteEditChordbeat() 
{
	HandleEditChange(m_spinChordBeat, CHGD_CHORDBEAT,
		m_PropNote.m_lChordBeat);
}

void PropPageNote::OnChangeNoteEditStartbar() 
{
	HandleEditChange(m_spinStartBar, CHGD_STARTBAR,
		m_PropNote.m_lStartBar);
}

void PropPageNote::OnChangeNoteEditStartbeat() 
{
	HandleEditChange(m_spinStartBeat, CHGD_STARTBEAT,
		m_PropNote.m_lStartBeat);
}

void PropPageNote::OnChangeNoteEditStartgrid() 
{
	HandleEditChange(m_spinStartGrid, CHGD_STARTGRID,
		m_PropNote.m_lStartGrid);
}

void PropPageNote::OnChangeNoteEditStarttick() 
{
	HandleEditChange(m_spinStartTick, CHGD_STARTTICK,
		m_PropNote.m_lStartTick);
}

void PropPageNote::OnChangeNoteEditEndbar() 
{
	HandleEditChange(m_spinEndBar, CHGD_ENDBAR,
		m_PropNote.m_lEndBar);
}

void PropPageNote::OnChangeNoteEditEndbeat() 
{
	HandleEditChange(m_spinEndBeat, CHGD_ENDBEAT,
		m_PropNote.m_lEndBeat);
}

void PropPageNote::OnChangeNoteEditEndgrid() 
{
	HandleEditChange(m_spinEndGrid, CHGD_ENDGRID,
		m_PropNote.m_lEndGrid);
}

void PropPageNote::OnChangeNoteEditEndtick() 
{
	HandleEditChange(m_spinEndTick, CHGD_ENDTICK,
		m_PropNote.m_lEndTick);
}

void PropPageNote::OnKillfocusNoteEditVelocity() 
{
	HandleKillFocusByte(m_spinVelocity, CHGD_VELOCITY,
		m_PropNote.m_bVelocity);
}

void PropPageNote::OnKillfocusNoteEditChordbar() 
{
	HandleKillFocus(m_spinChordBar, CHGD_CHORDBAR,
		m_PropNote.m_lChordBar);
}

void PropPageNote::OnKillfocusNoteEditChordbeat() 
{
	HandleKillFocus(m_spinChordBeat, CHGD_CHORDBEAT,
		m_PropNote.m_lChordBeat);
}

void PropPageNote::OnKillfocusNoteEditDurtick() 
{
	HandleKillFocus(m_spinDurTick, CHGD_DURTICK,
		m_PropNote.m_lDurTick);
}

void PropPageNote::OnKillfocusNoteEditDurgrid() 
{
	HandleKillFocus(m_spinDurGrid, CHGD_DURGRID,
		m_PropNote.m_lDurGrid);
}

void PropPageNote::OnKillfocusNoteEditDurbeat() 
{
	HandleKillFocus(m_spinDurBeat, CHGD_DURBEAT,
		m_PropNote.m_lDurBeat);
}

void PropPageNote::OnKillfocusNoteEditDurbar() 
{
	HandleKillFocus(m_spinDurBar, CHGD_DURBAR,
		m_PropNote.m_lDurBar);
}

void PropPageNote::OnKillfocusNoteEditEndbar() 
{
	HandleKillFocus(m_spinEndBar, CHGD_ENDBAR,
		m_PropNote.m_lEndBar);
}

void PropPageNote::OnKillfocusNoteEditEndbeat() 
{
	HandleKillFocus(m_spinEndBeat, CHGD_ENDBEAT,
		m_PropNote.m_lEndBeat);
}

void PropPageNote::OnKillfocusNoteEditEndgrid() 
{
	HandleKillFocus(m_spinEndGrid, CHGD_ENDGRID,
		m_PropNote.m_lEndGrid);
}

void PropPageNote::OnKillfocusNoteEditEndtick() 
{
	HandleKillFocus(m_spinEndTick, CHGD_ENDTICK,
		m_PropNote.m_lEndTick);
}

void PropPageNote::OnKillfocusNoteEditStartbar() 
{
	HandleKillFocus(m_spinStartBar, CHGD_STARTBAR,
		m_PropNote.m_lStartBar);
}

void PropPageNote::OnKillfocusNoteEditStartbeat() 
{
	HandleKillFocus(m_spinStartBeat, CHGD_STARTBEAT,
		m_PropNote.m_lStartBeat);
}

void PropPageNote::OnKillfocusNoteEditStartgrid() 
{
	HandleKillFocus(m_spinStartGrid, CHGD_STARTGRID,
		m_PropNote.m_lStartGrid);
}

void PropPageNote::OnKillfocusNoteEditStarttick() 
{
	HandleKillFocus(m_spinStartTick, CHGD_STARTTICK,
		m_PropNote.m_lStartTick);
}

void PropPageNote::OnDeltaposNoteSpinChordbeat(NMHDR* pNMHDR, LRESULT* pResult) 
{
	HandleDeltaChange( pNMHDR, pResult, CHGD_CHORDBEAT, m_PropNote.m_lChordBeat );
}

void PropPageNote::OnDeltaposNoteSpinDurbeat(NMHDR* pNMHDR, LRESULT* pResult) 
{
	HandleDeltaChange( pNMHDR, pResult, CHGD_DURBEAT, m_PropNote.m_lDurBeat );
}

void PropPageNote::OnDeltaposNoteSpinDurgrid(NMHDR* pNMHDR, LRESULT* pResult) 
{
	HandleDeltaChange( pNMHDR, pResult, CHGD_DURGRID, m_PropNote.m_lDurGrid );
}

void PropPageNote::OnDeltaposNoteSpinDurtick(NMHDR* pNMHDR, LRESULT* pResult) 
{
	HandleDeltaChange( pNMHDR, pResult, CHGD_DURTICK, m_PropNote.m_lDurTick );
}

void PropPageNote::OnDeltaposNoteSpinEndbeat(NMHDR* pNMHDR, LRESULT* pResult) 
{
	HandleDeltaChange( pNMHDR, pResult, CHGD_ENDBEAT, m_PropNote.m_lEndBeat );
}

void PropPageNote::OnDeltaposNoteSpinEndgrid(NMHDR* pNMHDR, LRESULT* pResult) 
{
	HandleDeltaChange( pNMHDR, pResult, CHGD_ENDGRID, m_PropNote.m_lEndGrid );
}

void PropPageNote::OnDeltaposNoteSpinEndtick(NMHDR* pNMHDR, LRESULT* pResult) 
{
	HandleDeltaChange( pNMHDR, pResult, CHGD_ENDTICK, m_PropNote.m_lEndTick );
}

void PropPageNote::OnDeltaposNoteSpinStartbeat(NMHDR* pNMHDR, LRESULT* pResult) 
{
	HandleDeltaChange( pNMHDR, pResult, CHGD_STARTBEAT, m_PropNote.m_lStartBeat );
}

void PropPageNote::OnDeltaposNoteSpinStartgrid(NMHDR* pNMHDR, LRESULT* pResult) 
{
	HandleDeltaChange( pNMHDR, pResult, CHGD_STARTGRID, m_PropNote.m_lStartGrid );
}

void PropPageNote::OnDeltaposNoteSpinStarttick(NMHDR* pNMHDR, LRESULT* pResult) 
{
	HandleDeltaChange( pNMHDR, pResult, CHGD_STARTTICK, m_PropNote.m_lStartTick );
}

BOOL PropPageNote::OnKillActive()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	ASSERT_VALID(this);

	return TRUE;
}


void PropPageNote::ValidateOctave( LPCTSTR lpszTmp )
{
	// If the string is equal to the string denoting 'unknown value', return
	if ( _tcscmp( lpszTmp, g_pstrUnknown ) == 0 )
	{
		return;
	}

	// Convert from text to an integer
	long lOctave = _ttoi( lpszTmp );

	// Ensure the value stays within bounds
	if ( lOctave < 0 ) 
	{
		lOctave = 0;
		SetDlgItemInt(IDC_NOTE_EDIT_OCTAVE, lOctave);
	}
	else if ( lOctave >= 10 )
	{
		if( m_PropNote.m_dwUndetermined & UD_MIDIVALUE )
		{
			// Undetermined MIDI value, compare against upper limit of octave 10
			if( lOctave > 10 )
			{
				lOctave = 10;
				SetDlgItemInt(IDC_NOTE_EDIT_OCTAVE, lOctave);
			}
		}
		else
		{
			// Determined MIDI value - make sure the MIDI value is below 127
			long lValue;
			lValue = lOctave * 12 + m_PropNote.m_bMIDIValue;
			if( lValue > 127 )
			{
				lOctave -= (lValue - 116) / 12; // (11 + lValue - 127) / 12
				ASSERT( lOctave <= 10 );
				SetDlgItemInt(IDC_NOTE_EDIT_OCTAVE, lOctave);
			}
		}
	}
	else if( lpszTmp[0] == NULL )
	{
		SetDlgItemInt( IDC_NOTE_EDIT_OCTAVE, 0);
	}

	if( (m_PropNote.m_dwUndetermined & UD_OCTAVE) ||
		(m_PropNote.m_bOctave != lOctave ) )
	{
		// Copy the value to m_PropNote
		m_PropNote.m_bOctave = (BYTE) lOctave;

		// Enable the edit control
		EnableItem(IDC_NOTE_EDIT_OCTAVE, TRUE);

		// Clear the octave undetermined flag
		m_PropNote.m_dwUndetermined = ~UD_OCTAVE;

		// Notify the PPO that the DurRange changed
		m_PropNote.m_dwChanged = CHGD_OCTAVE;

		// Update the notes
		UpdatePPO();
	}
}

/////////////////////////////////////////////////////////////////////////////
// PropPageNote::HandleEditChange
//
// Generic handler for edit box value changes
void PropPageNote::HandleEditChange(CSpinButtonCtrl& spin,
										   DWORD dwChg,
										   long& lUpdateVal)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_pPageManager->m_pIPropPageObject == NULL
	||  m_fInUpdateControls == TRUE )
	{
		return;
	}

	if (!::IsWindow(spin.m_hWnd)) {
		return;
	}

	// Get text from edit control
	TCHAR tcstrTmp[DIALOG_LEN];
	CWnd* pEditCtrl = spin.GetBuddy();
	ASSERT(pEditCtrl != NULL);
	pEditCtrl->GetWindowText( tcstrTmp, DIALOG_LEN );

	// If empty, exit early
	if( tcstrTmp[0] == NULL )
	{
		return;
	}

	// Get StartBar range
	int nMin;
	int nMax;
	spin.GetRange( nMin, nMax );

	// Convert from text to an integer
	BOOL fTransSuccess;
	long lNewValue = GetDlgItemInt( pEditCtrl->GetDlgCtrlID(), &fTransSuccess, TRUE );

	// If unable to translate (if dialog contains invalid data, such as '-'), exit early
	if( !fTransSuccess )
	{
		return;
	}

	// Ensure the value stays within bounds
	if ( lNewValue < nMin )
	{
		lNewValue = nMin;
		spin.SetPos( nMin );
	}
	else if (lNewValue > nMax)
	{
		lNewValue = nMax;
		spin.SetPos( nMax );
	}
	
	// If the value changed, or it was previously undetermined - update the selected PropCurves
	if( (m_PropNote.m_dwUndetermined & dwChg) || (lNewValue != lUpdateVal) )
	{
		m_PropNote.m_dwChanged = dwChg;
		lUpdateVal = lNewValue;
		UpdatePPO();
	}
}

/////////////////////////////////////////////////////////////////////////////
// PropPageNote::HandleKillFocus
//
// Generic handler for edit box kill focus events.
void PropPageNote::HandleKillFocus(CSpinButtonCtrl& spin,
									 DWORD dwChg,
									 long& lUpdateVal)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_pPageManager->m_pIPropPageObject == NULL
	||  m_fInUpdateControls == TRUE )
	{
		return;
	}

	if (!::IsWindow(spin.m_hWnd)) {
		return;
	}

	// Get StartBar range
	int nMin;
	int nMax;
	spin.GetRange( nMin, nMax );

	// Get text from edit control
	TCHAR tcstrTmp[DIALOG_LEN];
	CWnd* pEditCtrl = spin.GetBuddy();
	ASSERT(pEditCtrl != NULL);
	pEditCtrl->GetWindowText( tcstrTmp, DIALOG_LEN );

	// Handle unknown text
	if( _tcsncmp( tcstrTmp, g_pstrUnknown, 10 ) == 0 )
	{
		return;
	}
	// Handle empty text
	else if( tcstrTmp[0] == NULL )
	{
		// Set it back to the minimum value (or 0, whichever is greater)
		spin.SetPos( max( nMin, 0) );

		if( (m_PropNote.m_dwUndetermined & dwChg) || (max( nMin, 0) != lUpdateVal) )
		{
			m_PropNote.m_dwChanged = dwChg;
			lUpdateVal = max( nMin, 0);
			UpdatePPO();
		}
	}
	else
	{
		// Convert from text to an integer
		BOOL fTransSuccess;
		GetDlgItemInt( pEditCtrl->GetDlgCtrlID(), &fTransSuccess, TRUE );

		// If unable to translate (if dialog contains invalid data, such as '-'), exit early
		if( !fTransSuccess )
		{
			// If conversion failed, update dialog item text
			SetDlgItemInt( pEditCtrl->GetDlgCtrlID(), lUpdateVal );
		}
	}
}

/////////////////////////////////////////////////////////////////////////////
// PropPageNote::HandleEditChangeByte
//
// Generic handler for edit box value changes
void PropPageNote::HandleEditChangeByte(CSpinButtonCtrl& spin,
										   DWORD dwChg,
										   BYTE& bUpdateVal)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_pPageManager->m_pIPropPageObject == NULL
	||  m_fInUpdateControls == TRUE )
	{
		return;
	}

	if (!::IsWindow(spin.m_hWnd)) {
		return;
	}

	// Get text from edit control
	TCHAR tcstrTmp[DIALOG_LEN];
	CWnd* pEditCtrl = spin.GetBuddy();
	ASSERT(pEditCtrl != NULL);
	pEditCtrl->GetWindowText( tcstrTmp, DIALOG_LEN );

	// If empty, exit early
	if( tcstrTmp[0] == NULL )
	{
		return;
	}

	// Get StartBar range
	int nMin;
	int nMax;
	spin.GetRange( nMin, nMax );

	// Convert from text to an integer
	long lNewValue = _ttoi( tcstrTmp );

	// Ensure the value stays within bounds
	if ( lNewValue < nMin )
	{
		lNewValue = nMin;
		spin.SetPos( nMin );
	}
	else if (lNewValue > nMax)
	{
		lNewValue = nMax;
		spin.SetPos( nMax );
	}
	
	// If the value changed, or it was previously undetermined - update the selected PropCurves
	if( (m_PropNote.m_dwUndetermined & dwChg) || ((BYTE)lNewValue != bUpdateVal) )
	{
		m_PropNote.m_dwChanged = dwChg;
		bUpdateVal = (BYTE)lNewValue;
		UpdatePPO();
	}
}

/////////////////////////////////////////////////////////////////////////////
// PropPageNote::HandleKillFocusByte
//
// Generic handler for edit box kill focus events.
void PropPageNote::HandleKillFocusByte(CSpinButtonCtrl& spin,
									 DWORD dwChg,
									 BYTE& bUpdateVal)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_pPageManager->m_pIPropPageObject == NULL
	||  m_fInUpdateControls == TRUE )
	{
		return;
	}

	if (!::IsWindow(spin.m_hWnd)) {
		return;
	}

	// Get StartBar range
	int nMin;
	int nMax;
	spin.GetRange( nMin, nMax );

	// Get text from edit control
	TCHAR tcstrTmp[DIALOG_LEN];
	CWnd* pEditCtrl = spin.GetBuddy();
	ASSERT(pEditCtrl != NULL);
	pEditCtrl->GetWindowText( tcstrTmp, DIALOG_LEN );

	// Handle unknown text
	if( _tcsncmp( tcstrTmp, g_pstrUnknown, 10 ) == 0 )
	{
		return;
	}
	// Handle empty text
	else if( tcstrTmp[0] == NULL )
	{
		// Set it back to the minimum value (or 0, whichever is greater)
		spin.SetPos( max( nMin, 0) );

		if( (m_PropNote.m_dwUndetermined & dwChg) || ((BYTE)max( nMin, 0) != bUpdateVal) )
		{
			m_PropNote.m_dwChanged = dwChg;
			bUpdateVal = (BYTE)max( nMin, 0);
			UpdatePPO();
		}
	}
}

/////////////////////////////////////////////////////////////////////////////
// PropPageNote::HandleDeltaChange
//
// Generic handler for deltapos changes
void PropPageNote::HandleDeltaChange(NMHDR* pNMHDR,
									 LRESULT* pResult,
									 DWORD dwChg,
									 long& lUpdateVal )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_pPageManager->m_pIPropPageObject == NULL
	||  m_fInUpdateControls == TRUE )
	{
		return;
	}

	// If the value changed - update the selected PropNote
	if( ((NM_UPDOWN* )pNMHDR)->iDelta != 0 ) 
	{
		lUpdateVal += ((NM_UPDOWN* )pNMHDR)->iDelta;
		m_PropNote.m_dwChanged = dwChg;
		UpdatePPO();
	}
	
	*pResult = 1;
}


// Custom edit control that only accepts numbers, editing keys, and '-'
IMPLEMENT_DYNCREATE( CMyEdit, CEdit )

CMyEdit::CMyEdit() : CEdit()
{
}

LRESULT CMyEdit::WindowProc(UINT message, WPARAM wParam, LPARAM lParam)
{
	switch( message )
	{
	case WM_CHAR:
		switch( wParam )
		{
		case 8:  // Backspace
		case '-':
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
		case 71: // Home
		case 75: // Left
		case 77: // Right
		case 79: // End
		case 82: // Ins
		case 83: // Del
			break;
		default:
			return TRUE;
		break;
		}
	}
	return CEdit::WindowProc( message, wParam, lParam );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Shared\TabBoundaryFlags.cpp ===
// TabBoundaryFlags.cpp : implementation file
//

#include "stdafx.h"
#include "TabBoundaryFlags.h"
#pragma warning( push )
#pragma warning( disable : 4201 )
#include <dmusici.h>
#pragma warning( pop )

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

short* CTabBoundaryFlags::sm_pnActiveTab = NULL;

/////////////////////////////////////////////////////////////////////////////
// CTabBoundaryFlags property page

CTabBoundaryFlags::CTabBoundaryFlags( IDMUSProdPropPageManager* pIPageManager ) : CPropertyPage(CTabBoundaryFlags::IDD)
{
	//{{AFX_DATA_INIT(CTabBoundaryFlags)
	//}}AFX_DATA_INIT

	ASSERT( pIPageManager != NULL );

	m_pIPropPageObject = NULL;
	m_pIPageManager = pIPageManager;
	m_fNeedToDetach = FALSE;
	m_fUseTransitionPrompts = FALSE;
	m_rpIPropSheet = NULL;
}

CTabBoundaryFlags::~CTabBoundaryFlags()
{
	if( m_pIPropPageObject )
	{
		m_pIPropPageObject->Release();
		m_pIPropPageObject = NULL;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabBoundaryFlags::UseTransitionPrompts

void CTabBoundaryFlags::UseTransitionPrompts( BOOL fUseTransitionPrompts )
{
	m_fUseTransitionPrompts = fUseTransitionPrompts;
}


void CTabBoundaryFlags::DoDataExchange(CDataExchange* pDX)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CTabBoundaryFlags)
	DDX_Control(pDX, IDC_RADIO_INVALIDATE, m_radioInvalidate);
	DDX_Control(pDX, IDC_RADIO_INVALIDATEPRI, m_radioInvalidatePri);
	DDX_Control(pDX, IDC_RADIO_NOINVALIDATE, m_radioNoInvalidate);
	DDX_Control(pDX, IDC_STATIC_PROMPT, m_staticPrompt);
	DDX_Control(pDX, IDC_STATIC_NO_MARKERS, m_staticNoMarkers);
	DDX_Control(pDX, IDC_ALIGN_OPTIONS_PROMPT, m_staticAlignPrompt);
	DDX_Control(pDX, IDC_CHECK_SEG_DEFAULT, m_checkSegDefault);
	DDX_Control(pDX, IDC_CHECK_BOUNDARY, m_checkMarker);
	DDX_Control(pDX, IDC_COMBO_BOUNDARY, m_comboBoundary);
	DDX_Control(pDX, IDC_RADIO_SWITCH_ANY_TIME, m_radioSwitchAnyTime);
	DDX_Control(pDX, IDC_RADIO_SWITCH_ANY_GRID, m_radioSwitchAnyGrid);
	DDX_Control(pDX, IDC_RADIO_SWITCH_ANY_BEAT, m_radioSwitchAnyBeat);
	DDX_Control(pDX, IDC_RADIO_SWITCH_ANY_BAR, m_radioSwitchAnyBar);
	DDX_Control(pDX, IDC_RADIO_TIMING_QUICK, m_radioTimingQuick);
	DDX_Control(pDX, IDC_RADIO_TIMING_AFTERPREPARETIME, m_radioTimingAfterPrepareTime);
	//}}AFX_DATA_MAP
}


/////////////////////////////////////////////////////////////////////////////
// CTabBoundaryFlags::SetObject

void CTabBoundaryFlags::SetObject( IDMUSProdPropPageObject* pIPropPageObject )
{
	if( m_pIPropPageObject )
	{
		m_pIPropPageObject->Release();
	}
	m_pIPropPageObject = pIPropPageObject;
	if( m_pIPropPageObject )
	{
		m_pIPropPageObject->AddRef();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabBoundaryFlags::UpdateObject

void CTabBoundaryFlags::UpdateObject()
{
	if( m_pIPropPageObject )
	{
		m_pIPropPageObject->SetData( (void *)&m_PPGTabBoundaryFlags );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabBoundaryFlags::RefreshTab

void CTabBoundaryFlags::RefreshTab( void )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Make sure controls have been created
	if( ::IsWindow(m_hWnd) == FALSE )
	{
		return;
	}

	CString strPrompt;
	m_staticPrompt.SetWindowText( NULL );
	if( m_fUseTransitionPrompts )
	{
		strPrompt.LoadString( IDS_TRANSITION_PROMPT1 );
		m_checkMarker.SetWindowText( strPrompt );
		strPrompt.LoadString( IDS_TRANSITION_PROMPT2 );
		m_staticNoMarkers.SetWindowText( strPrompt );
	}
	else
	{
		strPrompt.LoadString( IDS_START_PROMPT1 );
		m_checkMarker.SetWindowText( strPrompt );
		strPrompt.LoadString( IDS_START_PROMPT2 );
		m_staticNoMarkers.SetWindowText( strPrompt );
	}

	if( m_pIPropPageObject == NULL )
	{
		EnableControls( FALSE );
		return;
	}

	PPGTabBoundaryFlags *pPPGTabBoundaryFlags = &m_PPGTabBoundaryFlags;
	if( FAILED( m_pIPropPageObject->GetData( (void**)&pPPGTabBoundaryFlags ) ) )
	{
		EnableControls( FALSE );
		return;
	}

	m_staticPrompt.SetWindowText( m_PPGTabBoundaryFlags.strPrompt );

	if( !(m_PPGTabBoundaryFlags.dwFlagsUI & PROPF_HAVE_VALID_DATA) )
	{
		EnableControls( FALSE );
		return;
	}

	// Prevent control notifications from being dispatched during RefreshObject
	_AFX_THREAD_STATE* pThreadState = AfxGetThreadState();
	HWND hWndOldLockout = pThreadState->m_hLockoutNotifyWindow;
	ASSERT(hWndOldLockout != m_hWnd);   // must not recurse
	pThreadState->m_hLockoutNotifyWindow = m_hWnd;

	EnableControls( TRUE );

	// "Marker" check box
	if( (m_PPGTabBoundaryFlags.dwPlayFlags & DMUS_SEGF_ALIGN)
	||	(m_PPGTabBoundaryFlags.dwPlayFlags & DMUS_SEGF_QUEUE) )
	{
		m_checkMarker.SetCheck( 0 );
	}
	else
	{
		m_checkMarker.SetCheck( (m_PPGTabBoundaryFlags.dwPlayFlags & DMUS_SEGF_MARKER) ? 1 : 0 );
	}

	// "Segment Default" check box
	m_checkSegDefault.SetCheck( (m_PPGTabBoundaryFlags.dwPlayFlags & DMUS_SEGF_DEFAULT) ? 1 : 0 );

	// "Boundary" combo box
	int nCurSel = -1;
	if( m_PPGTabBoundaryFlags.dwPlayFlags & DMUS_SEGF_DEFAULT )
	{
		// Default to Barline
		nCurSel = 3; 
	}
	else
	{
		if( m_PPGTabBoundaryFlags.dwPlayFlags & DMUS_SEGF_ALIGN )
		{
			if( m_PPGTabBoundaryFlags.dwPlayFlags & DMUS_SEGF_BEAT )
			{
				// Align to Beat
				nCurSel = 4;
			}
			else if( m_PPGTabBoundaryFlags.dwPlayFlags & DMUS_SEGF_MEASURE )
			{
				// Align to Barline
				nCurSel = 5;
			}
			else if( m_PPGTabBoundaryFlags.dwPlayFlags & DMUS_SEGF_SEGMENTEND )
			{
				// Align to Segment
				nCurSel = 6;
			}
		}
		else
		{
			if( m_PPGTabBoundaryFlags.dwPlayFlags & DMUS_SEGF_GRID )
			{
				// Grid
				nCurSel = 1;
			}
			else if( m_PPGTabBoundaryFlags.dwPlayFlags & DMUS_SEGF_BEAT )
			{
				// Beat
				nCurSel = 2;
			}
			else if( m_PPGTabBoundaryFlags.dwPlayFlags & DMUS_SEGF_MEASURE )
			{
				// Barline
				nCurSel = 3;
			}
			else if( m_PPGTabBoundaryFlags.dwPlayFlags & DMUS_SEGF_SEGMENTEND )
			{
				// End of Segment
				nCurSel = 7;
			}
			else if( m_PPGTabBoundaryFlags.dwPlayFlags & DMUS_SEGF_QUEUE )
			{
				// End of Segment Queue
				nCurSel = 8;
			}
			else
			{
				// Immediate
				nCurSel = 0;
			}
		}
	}
	m_comboBoundary.SetCurSel( nCurSel );

	// Set the 'Don't Cutoff' radio button state
	int nRadioButton = IDC_RADIO_INVALIDATE;
	if( m_PPGTabBoundaryFlags.dwPlayFlags & DMUS_SEGF_INVALIDATE_PRI )
	{
		nRadioButton = IDC_RADIO_INVALIDATEPRI;
	}
	else if( m_PPGTabBoundaryFlags.dwPlayFlags & DMUS_SEGF_NOINVALIDATE )
	{
		nRadioButton = IDC_RADIO_NOINVALIDATE;
	}
	CheckRadioButton( IDC_RADIO_NOINVALIDATE, IDC_RADIO_INVALIDATE, nRadioButton );

	// "Switch" radio buttons
	if( m_PPGTabBoundaryFlags.dwPlayFlags & DMUS_SEGF_ALIGN )
	{
		m_radioSwitchAnyTime.SetCheck( 0 );
		m_radioSwitchAnyGrid.SetCheck( 0 );
		m_radioSwitchAnyBeat.SetCheck( 0 );
		m_radioSwitchAnyBar.SetCheck( 0 );
		if( m_PPGTabBoundaryFlags.dwPlayFlags & DMUS_SEGF_VALID_START_GRID )
		{
			m_radioSwitchAnyGrid.SetCheck( 1 );
		}
		else if( m_PPGTabBoundaryFlags.dwPlayFlags & DMUS_SEGF_VALID_START_BEAT )
		{
			m_radioSwitchAnyBeat.SetCheck( 1 );
		}
		else if( m_PPGTabBoundaryFlags.dwPlayFlags & DMUS_SEGF_VALID_START_MEASURE )
		{
			m_radioSwitchAnyBar.SetCheck( 1 );
		}
		else //if( m_PPGTabBoundaryFlags.dwPlayFlags & DMUS_SEGF_VALID_START_TICK )
		{
			m_radioSwitchAnyTime.SetCheck( 1 );
		}
	}

	// "Timing" radio buttons
	m_radioTimingQuick.SetCheck( 0 );
	m_radioTimingAfterPrepareTime.SetCheck( 0 );
	if( m_PPGTabBoundaryFlags.dwPlayFlags & DMUS_SEGF_AFTERPREPARETIME )
	{
		m_radioTimingAfterPrepareTime.SetCheck( 1 );
	}
	else
	{
		m_radioTimingQuick.SetCheck( 1 );
	}

	pThreadState->m_hLockoutNotifyWindow = hWndOldLockout;
}


/////////////////////////////////////////////////////////////////////////////
// CTabBoundaryFlags::EnableControls

void CTabBoundaryFlags::EnableControls( BOOL fEnable ) 
{
	m_staticPrompt.EnableWindow( fEnable );
	if( !fEnable
	||	(m_PPGTabBoundaryFlags.dwPlayFlags & DMUS_SEGF_ALIGN)
	||	(m_PPGTabBoundaryFlags.dwPlayFlags & DMUS_SEGF_QUEUE) )
	{
		m_checkMarker.EnableWindow( FALSE );
		m_staticNoMarkers.ShowWindow( SW_HIDE );
	}
	else
	{
		m_checkMarker.EnableWindow( TRUE );
		m_staticNoMarkers.ShowWindow( (m_PPGTabBoundaryFlags.dwPlayFlags & DMUS_SEGF_MARKER) ? SW_SHOW : SW_HIDE );
	}

	m_radioInvalidate.EnableWindow( fEnable );
	m_radioInvalidatePri.EnableWindow( fEnable );
	m_radioNoInvalidate.EnableWindow( fEnable );
	m_radioTimingQuick.EnableWindow( fEnable );
	m_radioTimingAfterPrepareTime.EnableWindow( fEnable );

	BOOL fEnableSegDefault = fEnable;
	if( m_PPGTabBoundaryFlags.dwFlagsUI & PROPF_OMIT_SEGF_DEFAULT )
	{
		m_PPGTabBoundaryFlags.dwPlayFlags &= ~DMUS_SEGF_DEFAULT;
		fEnableSegDefault = FALSE;
	}
	m_checkSegDefault.EnableWindow( fEnableSegDefault );

	BOOL fEnableComboBoundary = fEnable;
	if( m_PPGTabBoundaryFlags.dwPlayFlags & DMUS_SEGF_DEFAULT )
	{
		fEnableComboBoundary = FALSE;
	}
	m_comboBoundary.EnableWindow( fEnableComboBoundary );

	BOOL fEnableSwitchRadioButtons = fEnable;
	if( !(m_PPGTabBoundaryFlags.dwPlayFlags & DMUS_SEGF_ALIGN) )
	{
		fEnableSwitchRadioButtons = FALSE;
	}
	m_staticAlignPrompt.EnableWindow( fEnableSwitchRadioButtons );
	m_radioSwitchAnyTime.EnableWindow( fEnableSwitchRadioButtons );
	m_radioSwitchAnyGrid.EnableWindow( fEnableSwitchRadioButtons );
	m_radioSwitchAnyBeat.EnableWindow( fEnableSwitchRadioButtons );
	m_radioSwitchAnyBar.EnableWindow( fEnableSwitchRadioButtons );

	if( fEnable == FALSE )
	{
		m_checkMarker.SetCheck( 0 );
		m_comboBoundary.SetCurSel( -1 );
		m_radioInvalidate.SetCheck( 0 );
		m_radioInvalidatePri.SetCheck( 0 );
		m_radioNoInvalidate.SetCheck( 0 );
		m_radioTimingQuick.SetCheck( 0 );
		m_radioTimingAfterPrepareTime.SetCheck( 0 );
	}

	if( fEnableSegDefault == FALSE )
	{
		m_checkSegDefault.SetCheck( 0 );
	}

	if( fEnableSwitchRadioButtons == FALSE )
	{
		m_radioSwitchAnyTime.SetCheck( 0 );
		m_radioSwitchAnyGrid.SetCheck( 0 );
		m_radioSwitchAnyBeat.SetCheck( 0 );
		m_radioSwitchAnyBar.SetCheck( 0 );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabBoundaryFlags::HandlePlayFlags

void CTabBoundaryFlags::HandlePlayFlags() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Determine new flags
	DWORD dwNewPlayFlags = 0;

	if( m_checkSegDefault.GetCheck() )
	{
		dwNewPlayFlags |= DMUS_SEGF_DEFAULT;
	}
	else
	{
		switch( m_comboBoundary.GetCurSel() )
		{
			// Immediate
			case 0:
				dwNewPlayFlags = 0;
				break;

			// Grid
			case 1:
				dwNewPlayFlags = DMUS_SEGF_GRID;
				break;

			// Beat
			case 2:
				dwNewPlayFlags = DMUS_SEGF_BEAT;
				break;

			// Barline
			case 3:
				dwNewPlayFlags = DMUS_SEGF_MEASURE;
				break;

			// Align to Beat
			case 4:
				dwNewPlayFlags = (DMUS_SEGF_ALIGN | DMUS_SEGF_BEAT);
				break;

			// Align to Barline
			case 5:
				dwNewPlayFlags = (DMUS_SEGF_ALIGN | DMUS_SEGF_MEASURE);
				break;

			// Align to Segment
			case 6:
				dwNewPlayFlags = (DMUS_SEGF_ALIGN | DMUS_SEGF_SEGMENTEND);
				break;

			// End of Segment
			case 7:
				dwNewPlayFlags = DMUS_SEGF_SEGMENTEND;
				break;

			// End of Segment Queue
			case 8:
				dwNewPlayFlags = DMUS_SEGF_QUEUE;
				break;

			default:
				break;
		}
	}

	// Clear "Marker" check box, if necessary
	if( (dwNewPlayFlags & DMUS_SEGF_ALIGN)
	||	(dwNewPlayFlags & DMUS_SEGF_QUEUE) )
	{
		m_checkMarker.SetCheck( 0 );
	}

	if( dwNewPlayFlags & DMUS_SEGF_ALIGN )
	{
		// Check radio buttons for 'Switch' points
		if( m_radioSwitchAnyTime.GetCheck() )
		{
			dwNewPlayFlags |= DMUS_SEGF_VALID_START_TICK;
		}
		else if( m_radioSwitchAnyGrid.GetCheck() )
		{
			dwNewPlayFlags |= DMUS_SEGF_VALID_START_GRID;
		}
		else if( m_radioSwitchAnyBeat.GetCheck() )
		{
			dwNewPlayFlags |= DMUS_SEGF_VALID_START_BEAT;
		}
		else if( m_radioSwitchAnyBar.GetCheck() )
		{
			dwNewPlayFlags |= DMUS_SEGF_VALID_START_MEASURE;
		}
	}

	if( m_checkMarker.GetCheck() )
	{
		dwNewPlayFlags |= DMUS_SEGF_MARKER;
	}

	// Get the 'Don't Cutoff' radio button states
	switch( GetCheckedRadioButton( IDC_RADIO_NOINVALIDATE, IDC_RADIO_INVALIDATE ) )
	{
	case IDC_RADIO_NOINVALIDATE:
		dwNewPlayFlags |= DMUS_SEGF_NOINVALIDATE;
		break;
	case IDC_RADIO_INVALIDATEPRI:
		dwNewPlayFlags |= DMUS_SEGF_INVALIDATE_PRI;
		break;
	case IDC_RADIO_INVALIDATE:
		// Do nothing
		break;
	}

	if( m_radioTimingAfterPrepareTime.GetCheck() )
	{
		dwNewPlayFlags |= DMUS_SEGF_AFTERPREPARETIME;
	}

	// If flags have changed, update the object
	if( dwNewPlayFlags != m_PPGTabBoundaryFlags.dwPlayFlags ) 
	{
		m_PPGTabBoundaryFlags.dwPlayFlags = dwNewPlayFlags;
		UpdateObject();
		RefreshTab();
	}
}


BEGIN_MESSAGE_MAP(CTabBoundaryFlags, CPropertyPage)
	//{{AFX_MSG_MAP(CTabBoundaryFlags)
	ON_WM_DESTROY()
	ON_WM_CREATE()
	ON_BN_CLICKED(IDC_CHECK_BOUNDARY, OnCheckMarker)
	ON_BN_DOUBLECLICKED(IDC_CHECK_BOUNDARY, OnDoubleClickedCheckMarker)
	ON_BN_CLICKED(IDC_CHECK_SEG_DEFAULT, OnCheckSegDefault)
	ON_BN_DOUBLECLICKED(IDC_CHECK_SEG_DEFAULT, OnDoubleClickedCheckSegDefault)
	ON_CBN_SELCHANGE(IDC_COMBO_BOUNDARY, OnSelChangeComboBoundary)
	ON_BN_CLICKED(IDC_RADIO_SWITCH_ANY_BAR, OnRadioSwitchAnyBar)
	ON_BN_DOUBLECLICKED(IDC_RADIO_SWITCH_ANY_BAR, OnDoubleClickedRadioSwitchAnyBar)
	ON_BN_CLICKED(IDC_RADIO_SWITCH_ANY_BEAT, OnRadioSwitchAnyBeat)
	ON_BN_DOUBLECLICKED(IDC_RADIO_SWITCH_ANY_BEAT, OnDoubleClickedRadioSwitchAnyBeat)
	ON_BN_CLICKED(IDC_RADIO_SWITCH_ANY_GRID, OnRadioSwitchAnyGrid)
	ON_BN_DOUBLECLICKED(IDC_RADIO_SWITCH_ANY_GRID, OnDoubleClickedRadioSwitchAnyGrid)
	ON_BN_CLICKED(IDC_RADIO_SWITCH_ANY_TIME, OnRadioSwitchAnyTime)
	ON_BN_DOUBLECLICKED(IDC_RADIO_SWITCH_ANY_TIME, OnDoubleClickedRadioSwitchAnyTime)
	ON_BN_CLICKED(IDC_RADIO_TIMING_AFTERPREPARETIME, OnRadioTimingAfterPrepareTime)
	ON_BN_DOUBLECLICKED(IDC_RADIO_TIMING_AFTERPREPARETIME, OnDoubleClickedRadioTimingAfterPrepareTime)
	ON_BN_CLICKED(IDC_RADIO_TIMING_QUICK, OnRadioTimingQuick)
	ON_BN_DOUBLECLICKED(IDC_RADIO_TIMING_QUICK, OnDoubleClickedRadioTimingQuick)
	ON_BN_CLICKED(IDC_RADIO_INVALIDATE, OnRadioInvalidate)
	ON_BN_CLICKED(IDC_RADIO_INVALIDATEPRI, OnRadioInvalidatepri)
	ON_BN_CLICKED(IDC_RADIO_NOINVALIDATE, OnRadioNoinvalidate)
	ON_BN_DOUBLECLICKED(IDC_RADIO_INVALIDATE, OnDoubleClickedRadioInvalidate)
	ON_BN_DOUBLECLICKED(IDC_RADIO_INVALIDATEPRI, OnDoubleClickedRadioInvalidatepri)
	ON_BN_DOUBLECLICKED(IDC_RADIO_NOINVALIDATE, OnDoubleClickedRadioNoinvalidate)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CTabBoundaryFlags message handlers

/////////////////////////////////////////////////////////////////////////////
// CTabBoundaryFlags::OnSetActive

BOOL CTabBoundaryFlags::OnSetActive() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	RefreshTab();

	// Store active tab
	if( sm_pnActiveTab && m_rpIPropSheet )
	{
		m_rpIPropSheet->GetActivePage( sm_pnActiveTab );
	}
	
	return CPropertyPage::OnSetActive();
}


/////////////////////////////////////////////////////////////////////////////
// CTabBoundaryFlags::OnDestroy

void CTabBoundaryFlags::OnDestroy() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Detach the window from the property page structure.
	// This will be done again by the main application since
	// it owns the property sheet.  It needs o be done here
	// so that the window handle can be removed from the
	// DLLs handle map.
	if( m_fNeedToDetach && m_hWnd )
	{
		HWND hWnd = m_hWnd;
		Detach();
		m_hWnd = hWnd;
	}

	CPropertyPage::OnDestroy();
}


/////////////////////////////////////////////////////////////////////////////
// CTabBoundaryFlags::OnCreate

int CTabBoundaryFlags::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Attach the window to the property page structure.
	// This has been done once already in the main application
	// since the main application owns the property sheet.
	// It needs to be done here so that the window handle can
	// be found in the DLLs handle map.
	if( !FromHandlePermanent( m_hWnd ) )
	{
		HWND hWnd = m_hWnd;
		m_hWnd = NULL;
		Attach( hWnd );
		m_fNeedToDetach = TRUE;
	}

	if( CPropertyPage::OnCreate(lpCreateStruct) == -1 )
	{
		return -1;
	}
	
	return 0;
}


/////////////////////////////////////////////////////////////////////////////
// CTabBoundaryFlags::OnCheckMarker

void CTabBoundaryFlags::OnCheckMarker() 
{
	HandlePlayFlags();
}


/////////////////////////////////////////////////////////////////////////////
// CTabBoundaryFlags::OnDoubleClickedCheckMarker

void CTabBoundaryFlags::OnDoubleClickedCheckMarker() 
{
	OnCheckMarker();
}


/////////////////////////////////////////////////////////////////////////////
// CTabBoundaryFlags::OnCheckSegDefault

void CTabBoundaryFlags::OnCheckSegDefault() 
{
	HandlePlayFlags();
}


/////////////////////////////////////////////////////////////////////////////
// CTabBoundaryFlags::OnDoubleClickedCheckSegDefault

void CTabBoundaryFlags::OnDoubleClickedCheckSegDefault() 
{
	OnCheckSegDefault();
}


/////////////////////////////////////////////////////////////////////////////
// CTabBoundaryFlags::OnRadioInvalidate

void CTabBoundaryFlags::OnRadioInvalidate() 
{
	HandlePlayFlags();
}


/////////////////////////////////////////////////////////////////////////////
// CTabBoundaryFlags::OnRadioInvalidatepri

void CTabBoundaryFlags::OnRadioInvalidatepri() 
{
	HandlePlayFlags();
}


/////////////////////////////////////////////////////////////////////////////
// CTabBoundaryFlags::OnRadioNoinvalidate

void CTabBoundaryFlags::OnRadioNoinvalidate() 
{
	HandlePlayFlags();
}


/////////////////////////////////////////////////////////////////////////////
// CTabBoundaryFlags::OnDoubleClickedRadioInvalidate

void CTabBoundaryFlags::OnDoubleClickedRadioInvalidate() 
{
	OnRadioInvalidate();
}


/////////////////////////////////////////////////////////////////////////////
// CTabBoundaryFlags::OnDoubleClickedRadioInvalidatepri

void CTabBoundaryFlags::OnDoubleClickedRadioInvalidatepri() 
{
	OnRadioInvalidatepri();
}


/////////////////////////////////////////////////////////////////////////////
// CTabBoundaryFlags::OnDoubleClickedRadioNoinvalidate

void CTabBoundaryFlags::OnDoubleClickedRadioNoinvalidate() 
{
	OnRadioNoinvalidate();
}


/////////////////////////////////////////////////////////////////////////////
// CTabBoundaryFlags::OnSelChangeComboBoundary

void CTabBoundaryFlags::OnSelChangeComboBoundary() 
{
	HandlePlayFlags();
}


/////////////////////////////////////////////////////////////////////////////
// CTabBoundaryFlags::OnRadioSwitchAnyBar

void CTabBoundaryFlags::OnRadioSwitchAnyBar() 
{
	HandlePlayFlags();
}


/////////////////////////////////////////////////////////////////////////////
// CTabBoundaryFlags::OnDoubleClickedRadioSwitchAnyBar

void CTabBoundaryFlags::OnDoubleClickedRadioSwitchAnyBar() 
{
	OnRadioSwitchAnyBar();
}


/////////////////////////////////////////////////////////////////////////////
// CTabBoundaryFlags::OnRadioSwitchAnyBeat

void CTabBoundaryFlags::OnRadioSwitchAnyBeat() 
{
	HandlePlayFlags();
}


/////////////////////////////////////////////////////////////////////////////
// CTabBoundaryFlags::OnDoubleClickedRadioSwitchAnyBeat

void CTabBoundaryFlags::OnDoubleClickedRadioSwitchAnyBeat() 
{
	OnRadioSwitchAnyBeat();
}


/////////////////////////////////////////////////////////////////////////////
// CTabBoundaryFlags::OnRadioSwitchAnyGrid

void CTabBoundaryFlags::OnRadioSwitchAnyGrid() 
{
	HandlePlayFlags();
}


/////////////////////////////////////////////////////////////////////////////
// CTabBoundaryFlags::OnDoubleClickedRadioSwitchAnyGrid

void CTabBoundaryFlags::OnDoubleClickedRadioSwitchAnyGrid() 
{
	OnRadioSwitchAnyGrid();
}


/////////////////////////////////////////////////////////////////////////////
// CTabBoundaryFlags::OnRadioSwitchAnyTime

void CTabBoundaryFlags::OnRadioSwitchAnyTime() 
{
	HandlePlayFlags();
}


/////////////////////////////////////////////////////////////////////////////
// CTabBoundaryFlags::OnDoubleClickedRadioSwitchAnyTime

void CTabBoundaryFlags::OnDoubleClickedRadioSwitchAnyTime() 
{
	OnRadioSwitchAnyTime();
}


/////////////////////////////////////////////////////////////////////////////
// CTabBoundaryFlags::OnRadioSwitchNextBoundary

void CTabBoundaryFlags::OnRadioSwitchNextBoundary() 
{
	HandlePlayFlags();
}


/////////////////////////////////////////////////////////////////////////////
// CTabBoundaryFlags::OnDoubleClickedRadioSwitchNextBoundary

void CTabBoundaryFlags::OnDoubleClickedRadioSwitchNextBoundary() 
{
	OnRadioSwitchNextBoundary();
}


/////////////////////////////////////////////////////////////////////////////
// CTabBoundaryFlags::OnRadioTimingAfterPrepareTime

void CTabBoundaryFlags::OnRadioTimingAfterPrepareTime() 
{
	HandlePlayFlags();
}


/////////////////////////////////////////////////////////////////////////////
// CTabBoundaryFlags::OnDoubleClickedRadioTimingAfterPrepareTime

void CTabBoundaryFlags::OnDoubleClickedRadioTimingAfterPrepareTime() 
{
	OnRadioTimingAfterPrepareTime();
}


/////////////////////////////////////////////////////////////////////////////
// CTabBoundaryFlags::OnRadioTimingQuick

void CTabBoundaryFlags::OnRadioTimingQuick() 
{
	HandlePlayFlags();
}


/////////////////////////////////////////////////////////////////////////////
// CTabBoundaryFlags::OnDoubleClickedRadioTimingQuick

void CTabBoundaryFlags::OnDoubleClickedRadioTimingQuick() 
{
	OnRadioTimingQuick();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Shared\SharedPropPageCurve.cpp ===
// PropPageCurve.cpp : implementation file
//

#include "stdafx.h"
#include "resource.h"
#include "PropPageCurve.h"
#include "PropCurve.h"
#include "CurveStrip.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define SMALL_BUFFER	32
#define DIALOG_LEN		20

static const TCHAR achUnknown[11] = "----------";

//////////////////////////////////////////////////////////////////////
// CPropPageCurve Construction/Destruction
//////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// CPropPageCurve property page

CPropPageCurve::CPropPageCurve( CCurvePropPageMgr* pCurvePropPageMgr ) : CPropertyPage(CPropPageCurve::IDD)
{
	//{{AFX_DATA_INIT(CPropPageCurve)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
	
	ASSERT( pCurvePropPageMgr != NULL );

	m_pPageManager = pCurvePropPageMgr;
	m_fInUpdateControls = FALSE;
	m_fNeedToDetach = FALSE;
	m_fInOnKillFocusStartValue = FALSE;
	m_fInOnKillFocusEndValue = FALSE;
}

CPropPageCurve::~CPropPageCurve()
{
}


/////////////////////////////////////////////////////////////////////////////
// CPropPageCurve::EnableItem

void CPropPageCurve::EnableItem( int nID, BOOL fEnable )
{
	CWnd* pWnd = GetDlgItem( nID );

	if( pWnd )
	{
		if( fEnable == FALSE )
		{
			pWnd->SetWindowText( achUnknown );
		}
		pWnd->EnableWindow( fEnable );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CPropPageCurve::EnableControls

void CPropPageCurve::EnableControls( BOOL fEnable ) 
{
	EnableItem( IDC_EDIT_STARTBAR, fEnable );
	m_spinStartBar.EnableWindow( fEnable );
	EnableItem( IDC_EDIT_STARTBEAT, fEnable );
	m_spinStartBeat.EnableWindow( fEnable );
	EnableItem( IDC_EDIT_STARTGRID, fEnable );
	m_spinStartGrid.EnableWindow( fEnable );
	EnableItem( IDC_EDIT_STARTTICK, fEnable );
	m_spinStartTick.EnableWindow( fEnable );

	EnableItem( IDC_EDIT_ENDBAR, fEnable );
	m_spinEndBar.EnableWindow( fEnable );
	EnableItem( IDC_EDIT_ENDBEAT, fEnable );
	m_spinEndBeat.EnableWindow( fEnable );
	EnableItem( IDC_EDIT_ENDGRID, fEnable );
	m_spinEndGrid.EnableWindow( fEnable );
	EnableItem( IDC_EDIT_ENDTICK, fEnable );
	m_spinEndTick.EnableWindow( fEnable );

	EnableItem( IDC_EDIT_DURBAR, fEnable );
	m_spinDurBar.EnableWindow( fEnable );
	EnableItem( IDC_EDIT_DURBEAT, fEnable );
	m_spinDurBeat.EnableWindow( fEnable );
	EnableItem( IDC_EDIT_DURGRID, fEnable );
	m_spinDurGrid.EnableWindow( fEnable );
	EnableItem( IDC_EDIT_DURTICK, fEnable );
	m_spinDurTick.EnableWindow( fEnable );

	EnableItem( IDC_EDIT_STARTVALUE, fEnable );
	m_spinStartValue.EnableWindow( fEnable );
	EnableItem( IDC_EDIT_ENDVALUE, fEnable );
	m_spinEndValue.EnableWindow( fEnable );

	if( m_pPageManager
	&& (m_pPageManager->m_PropCurve.m_bEventType == DMUS_CURVET_PBCURVE
		|| (m_pPageManager->m_PropCurve.m_bEventType == DMUS_CURVET_CCCURVE
			&& (m_pPageManager->m_PropCurve.m_bCCData == 7 // Volume
				|| m_pPageManager->m_PropCurve.m_bCCData == 11 // Expression
				|| m_pPageManager->m_PropCurve.m_bCCData == 1 // Mod wheel
				|| m_pPageManager->m_PropCurve.m_bCCData == 91 // Reverb send
				|| m_pPageManager->m_PropCurve.m_bCCData == 93))) ) // Chorus send
	{
		m_spinMergeIndex.ShowWindow( SW_NORMAL );
		m_editMergeIndex.ShowWindow( SW_NORMAL );
		m_staticMergeIndex.ShowWindow( SW_NORMAL );

		m_checkStartCurrent.ShowWindow( SW_NORMAL );

		EnableItem( IDC_EDIT_MERGE_INDEX, fEnable );
		m_spinMergeIndex.EnableWindow( fEnable );

		m_checkStartCurrent.EnableWindow( fEnable );
	}
	else
	{
		m_spinMergeIndex.ShowWindow( SW_HIDE );
		m_editMergeIndex.ShowWindow( SW_HIDE );
		m_staticMergeIndex.ShowWindow( SW_HIDE );

		m_checkStartCurrent.ShowWindow( SW_HIDE );
	}

	if( m_pPageManager
	&&	m_pPageManager->m_PropCurve.m_bEventType == DMUS_CURVET_RPNCURVE
	&&	m_pPageManager->m_PropCurve.m_wParamType == 0 )
	{
		m_staticPBRSemitones.ShowWindow( SW_NORMAL );
		m_staticPBRCents.ShowWindow( SW_NORMAL );
		m_spinPBRStartCents.ShowWindow( SW_NORMAL );
		m_editPBRStartCents.ShowWindow( SW_NORMAL );
		m_spinPBREndCents.ShowWindow( SW_NORMAL );
		m_editPBREndCents.ShowWindow( SW_NORMAL );


		EnableItem( IDC_EDIT_PBR_START_CENTS, fEnable );
		EnableItem( IDC_EDIT_PBR_END_CENTS, fEnable );
		m_spinPBRStartCents.EnableWindow( fEnable );
		m_spinPBREndCents.EnableWindow( fEnable );
	}
	else
	{
		m_staticPBRSemitones.ShowWindow( SW_HIDE );
		m_staticPBRCents.ShowWindow( SW_HIDE );
		m_spinPBRStartCents.ShowWindow( SW_HIDE );
		m_editPBRStartCents.ShowWindow( SW_HIDE );
		m_spinPBREndCents.ShowWindow( SW_HIDE );
		m_editPBREndCents.ShowWindow( SW_HIDE );
	}

	m_comboShape.EnableWindow( fEnable );
	m_btnFlipHorz.EnableWindow( fEnable );
	m_btnFlipVert.EnableWindow( fEnable );
}


/////////////////////////////////////////////////////////////////////////////
// CPropPageCurve::SetSpinStartValuePos

void CPropPageCurve::SetSpinStartValuePos( int nStartValue )
{
	if( m_pPageManager->m_PropCurve.m_bEventType == DMUS_CURVET_PBCURVE )
	{
		m_spinStartValue.SetPos( nStartValue + PB_DISP_OFFSET );
	}
	else if( m_pPageManager->m_PropCurve.m_bEventType == DMUS_CURVET_RPNCURVE
		&&	 m_pPageManager->m_PropCurve.m_wParamType == 0 )
	{
		m_spinStartValue.SetPos( nStartValue / 128 );
	}
	else
	{
		m_spinStartValue.SetPos( nStartValue );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CPropPageCurve::SetSpinStartCentsValuePos

void CPropPageCurve::SetSpinStartCentsValuePos( int nStartValue )
{
	m_spinPBRStartCents.SetPos( nStartValue % 128 );
}


/////////////////////////////////////////////////////////////////////////////
// CPropPageCurve::GetSpinStartValuePos

int CPropPageCurve::GetSpinStartValuePos( void )
{
	int nStartValue;

	if( m_pPageManager->m_PropCurve.m_bEventType == DMUS_CURVET_PBCURVE )
	{
		nStartValue = LOWORD(m_spinStartValue.GetPos()) - PB_DISP_OFFSET;
	}
	else
	{
		nStartValue = LOWORD(m_spinStartValue.GetPos());
	}

	return nStartValue;
}


/////////////////////////////////////////////////////////////////////////////
// CPropPageCurve::SetSpinEndValuePos

void CPropPageCurve::SetSpinEndValuePos( int nEndValue )
{
	if( m_pPageManager->m_PropCurve.m_bEventType == DMUS_CURVET_PBCURVE )
	{
		m_spinEndValue.SetPos( nEndValue + PB_DISP_OFFSET );
	}
	else if( m_pPageManager->m_PropCurve.m_bEventType == DMUS_CURVET_RPNCURVE
		&&	 m_pPageManager->m_PropCurve.m_wParamType == 0 )
	{
		m_spinEndValue.SetPos( nEndValue / 128 );
	}
	else
	{
		m_spinEndValue.SetPos( nEndValue );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CPropPageCurve::SetSpinEndCentsValuePos

void CPropPageCurve::SetSpinEndCentsValuePos( int nEndValue )
{
	m_spinPBREndCents.SetPos( nEndValue % 128 );
}


/////////////////////////////////////////////////////////////////////////////
// CPropPageCurve::GetSpinEndValuePos

int CPropPageCurve::GetSpinEndValuePos( void )
{
	int nEndValue;

	if( m_pPageManager->m_PropCurve.m_bEventType == DMUS_CURVET_PBCURVE )
	{
		nEndValue = LOWORD(m_spinEndValue.GetPos()) - PB_DISP_OFFSET;
	}
	else
	{
		nEndValue = LOWORD(m_spinEndValue.GetPos());
	}

	return nEndValue;
}


/////////////////////////////////////////////////////////////////////////////
// CPropPageCurve::UpdateControls

void CPropPageCurve::UpdateControls( CPropCurve* pPropCurve )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	ASSERT( m_pPageManager != NULL );
	
	// Make sure controls have been created
	if( ::IsWindow(m_btnFlipVert.m_hWnd) == FALSE )
	{
		return;
	}

	m_fInUpdateControls = TRUE;

	// Update controls
	if( pPropCurve == NULL )
	{
		EnableControls( FALSE );
		m_comboShape.SetCurSel( -1 );

		m_fInUpdateControls = FALSE;
		return;
	}

	EnableControls( TRUE );
	SetControlRanges( pPropCurve );

	int nPos;

	if( pPropCurve->m_dwUndetermined & UNDT_STARTBAR )
	{
		m_editStartBar.SetWindowText( achUnknown );
	}
	else
	{
		nPos = m_spinStartBar.GetPos();
		if( HIWORD(nPos) != 0
		||  LOWORD(nPos) != pPropCurve->m_lStartBar )
		{
			m_spinStartBar.SetPos( pPropCurve->m_lStartBar );
		}
	}

	if( pPropCurve->m_dwUndetermined & UNDT_STARTBEAT )
	{
		m_editStartBeat.SetWindowText( achUnknown );
	}
	else
	{
		nPos = m_spinStartBeat.GetPos();
		if( HIWORD(nPos) != 0
		||  LOWORD(nPos) != pPropCurve->m_lStartBeat )
		{
			m_spinStartBeat.SetPos( pPropCurve->m_lStartBeat );
		}
	}

	if( pPropCurve->m_dwUndetermined & UNDT_STARTGRID )
	{
		m_editStartGrid.SetWindowText( achUnknown );
	}
	else
	{
		nPos = m_spinStartGrid.GetPos();
		if( HIWORD(nPos) != 0
		||  LOWORD(nPos) != pPropCurve->m_lStartGrid )
		{
			m_spinStartGrid.SetPos( pPropCurve->m_lStartGrid );
		}
	}

	if( pPropCurve->m_dwUndetermined & UNDT_STARTTICK )
	{
		m_editStartTick.SetWindowText( achUnknown );
	}
	else
	{
		nPos = m_spinStartTick.GetPos();
		if( HIWORD(nPos) != 0
		||  LOWORD(nPos) != pPropCurve->m_lStartTick )
		{
			m_spinStartTick.SetPos( pPropCurve->m_lStartTick );
		}
	}

	if( pPropCurve->m_dwUndetermined & UNDT_ENDBAR )
	{
		m_editEndBar.SetWindowText( achUnknown );
	}
	else
	{
		nPos = m_spinEndBar.GetPos();
		if( HIWORD(nPos) != 0
		||  LOWORD(nPos) != pPropCurve->m_lEndBar )
		{
			m_spinEndBar.SetPos( pPropCurve->m_lEndBar );
		}
	}

	if( pPropCurve->m_dwUndetermined & UNDT_ENDBEAT )
	{
		m_editEndBeat.SetWindowText( achUnknown );
	}
	else
	{
		nPos = m_spinEndBeat.GetPos();
		if( HIWORD(nPos) != 0
		||  LOWORD(nPos) != pPropCurve->m_lEndBeat )
		{
			m_spinEndBeat.SetPos( pPropCurve->m_lEndBeat );
		}
	}

	if( pPropCurve->m_dwUndetermined & UNDT_ENDGRID )
	{
		m_editEndGrid.SetWindowText( achUnknown );
	}
	else
	{
		nPos = m_spinEndGrid.GetPos();
		if( HIWORD(nPos) != 0
		||  LOWORD(nPos) != pPropCurve->m_lEndGrid )
		{
			m_spinEndGrid.SetPos( pPropCurve->m_lEndGrid );
		}
	}

	if( pPropCurve->m_dwUndetermined & UNDT_ENDTICK )
	{
		m_editEndTick.SetWindowText( achUnknown );
	}
	else
	{
		nPos = m_spinEndTick.GetPos();
		if( HIWORD(nPos) != 0
		||  LOWORD(nPos) != pPropCurve->m_lEndTick )
		{
			m_spinEndTick.SetPos( pPropCurve->m_lEndTick );
		}
	}

	if( pPropCurve->m_dwUndetermined & UNDT_DURBAR )
	{
		m_editDurBar.SetWindowText( achUnknown );
	}
	else
	{
		nPos = m_spinDurBar.GetPos();
		if( HIWORD(nPos) != 0
		||  LOWORD(nPos) != pPropCurve->m_lDurBar )
		{
			m_spinDurBar.SetPos( pPropCurve->m_lDurBar );
		}
	}

	if( pPropCurve->m_dwUndetermined & UNDT_DURBEAT )
	{
		m_editDurBeat.SetWindowText( achUnknown );
	}
	else
	{
		nPos = m_spinDurBeat.GetPos();
		if( HIWORD(nPos) != 0
		||  LOWORD(nPos) != pPropCurve->m_lDurBeat )
		{
			m_spinDurBeat.SetPos( pPropCurve->m_lDurBeat );
		}
	}

	if( pPropCurve->m_dwUndetermined & UNDT_DURGRID )
	{
		m_editDurGrid.SetWindowText( achUnknown );
	}
	else
	{
		nPos = m_spinDurGrid.GetPos();
		if( HIWORD(nPos) != 0
		||  LOWORD(nPos) != pPropCurve->m_lDurGrid )
		{
			m_spinDurGrid.SetPos( pPropCurve->m_lDurGrid );
		}
	}

	if( pPropCurve->m_dwUndetermined & UNDT_DURTICK )
	{
		m_editDurTick.SetWindowText( achUnknown );
	}
	else
	{
		nPos = m_spinDurTick.GetPos();
		if( HIWORD(nPos) != 0
		||  LOWORD(nPos) != pPropCurve->m_lDurTick )
		{
			m_spinDurTick.SetPos( pPropCurve->m_lDurTick );
		}
	}

	if( pPropCurve->m_dwUndetermined & UNDT_STARTVAL )
	{
		m_editStartValue.SetWindowText( achUnknown );
	}
	else
	{
		CString strValue;
		StartEndValueToString( pPropCurve->m_nStartValue, strValue );

		CString strCurrentText;
		m_editStartValue.GetWindowText( strCurrentText );
		if( strValue != strCurrentText )
		{
			m_editStartValue.SetWindowText( strValue );
			// SetSel's needed to get caret to end of string
			m_editStartValue.SetSel( 0, -1 );
			m_editStartValue.SetSel( -1, -1 );

			SetSpinStartValuePos( pPropCurve->m_nStartValue ); 
		}
	}

	if( pPropCurve->m_dwUndetermined & UNDT_ENDVAL )
	{
		m_editEndValue.SetWindowText( achUnknown );
	}
	else
	{
		CString strValue;
		StartEndValueToString( pPropCurve->m_nEndValue, strValue );

		CString strCurrentText;
		m_editEndValue.GetWindowText( strCurrentText );
		if( strValue != strCurrentText )
		{
			m_editEndValue.SetWindowText( strValue );
			// SetSel's needed to get caret to end of string
			m_editEndValue.SetSel( 0, -1 );
			m_editEndValue.SetSel( -1, -1 );
			SetSpinEndValuePos( pPropCurve->m_nEndValue );
		}
	}

	if( pPropCurve->m_dwUndetermined & UNDT_SHAPE )
	{
		m_comboShape.SetCurSel( -1 );
	}
	else
	{
		if( pPropCurve->m_bCurveShape == DMUS_CURVES_SINE )
		{
			m_comboShape.SetCurSel( 0 );
		}
		else if( pPropCurve->m_bCurveShape == DMUS_CURVES_LOG )
		{
			m_comboShape.SetCurSel( 1 );
		}
		else if( pPropCurve->m_bCurveShape ==  DMUS_CURVES_EXP )
		{
			m_comboShape.SetCurSel( 2 );
		}
		else if( pPropCurve->m_bCurveShape == DMUS_CURVES_INSTANT )
		{
			m_comboShape.SetCurSel( 3 );
		}
		else if( pPropCurve->m_bCurveShape == DMUS_CURVES_LINEAR )
		{
			m_comboShape.SetCurSel( 4 );
		}
		else
		{
			m_comboShape.SetCurSel( -1 );
		}
	}

	if( pPropCurve->m_bEventType == DMUS_CURVET_PBCURVE
	|| (pPropCurve->m_bEventType == DMUS_CURVET_CCCURVE
		&& (pPropCurve->m_bCCData == 7 // Volume
			|| pPropCurve->m_bCCData == 11 // Expression
			|| pPropCurve->m_bCCData == 1 // Mod wheel
			|| pPropCurve->m_bCCData == 91 // Reverb send
			|| pPropCurve->m_bCCData == 93)) ) // Chorus send
	{
		// Merge index
		if( pPropCurve->m_dwUndetermined2 & UNDT2_MERGEINDEX )
		{
			m_editMergeIndex.SetWindowText( achUnknown );
		}
		else
		{
			nPos = m_spinMergeIndex.GetPos();
			if( HIWORD(nPos) != 0
			||  LOWORD(nPos) != pPropCurve->m_wMergeIndex )
			{
				m_spinMergeIndex.SetPos( pPropCurve->m_wMergeIndex );
			}
		}

		// Start from current checkbox
		if( pPropCurve->m_dwUndetermined2 & UNDT2_STARTCURRENT )
		{
			m_checkStartCurrent.SetCheck( 2 );
		}
		else
		{
			m_checkStartCurrent.SetCheck( pPropCurve->m_bFlags & DMUS_CURVE_START_FROM_CURRENT ? 1 : 0 );
		}
	}

	if( m_pPageManager
	&&	m_pPageManager->m_PropCurve.m_bEventType == DMUS_CURVET_RPNCURVE
	&&	m_pPageManager->m_PropCurve.m_wParamType == 0 )
	{
		// Start value
		if( pPropCurve->m_dwUndetermined & UNDT_STARTVAL )
		{
			m_editPBRStartCents.SetWindowText( achUnknown );
		}
		else
		{
			CString strValue;
			StartEndValueToCentsString( pPropCurve->m_nStartValue, strValue );

			CString strCurrentText;
			m_editPBRStartCents.GetWindowText( strCurrentText );
			if( strValue != strCurrentText )
			{
				m_editPBRStartCents.SetWindowText( strValue );
				// SetSel's needed to get caret to end of string
				m_editPBRStartCents.SetSel( 0, -1 );
				m_editPBRStartCents.SetSel( -1, -1 );

				SetSpinStartCentsValuePos( pPropCurve->m_nStartValue ); 
			}
		}

		// End value
		if( pPropCurve->m_dwUndetermined & UNDT_STARTVAL )
		{
			m_editPBREndCents.SetWindowText( achUnknown );
		}
		else
		{
			CString strValue;
			StartEndValueToCentsString( pPropCurve->m_nEndValue, strValue );

			CString strCurrentText;
			m_editPBREndCents.GetWindowText( strCurrentText );
			if( strValue != strCurrentText )
			{
				m_editPBREndCents.SetWindowText( strValue );
				// SetSel's needed to get caret to end of string
				m_editPBREndCents.SetSel( 0, -1 );
				m_editPBREndCents.SetSel( -1, -1 );
				SetSpinEndCentsValuePos( pPropCurve->m_nEndValue );
			}
		}
	}

	m_fInUpdateControls = FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CPropPageCurve message handlers


/////////////////////////////////////////////////////////////////////////////
// CPropPageCurve::OnCreate

int CPropPageCurve::OnCreate( LPCREATESTRUCT lpCreateStruct ) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Attach the window to the property page structure.
	// This has been done once already in the main application
	// since the main application owns the property sheet.
	// It needs to be done here so that the window handle can
	// be found in the DLLs handle map.
	if( !FromHandlePermanent( m_hWnd ) )
	{
		HWND hWnd = m_hWnd;
		m_hWnd = NULL;
		Attach( hWnd );
		m_fNeedToDetach = TRUE;
	}

	if( CPropertyPage::OnCreate(lpCreateStruct) == -1 )
	{
		return -1;
	}
	
	return 0;
}


/////////////////////////////////////////////////////////////////////////////
// CPropPageCurve::OnDestroy

void CPropPageCurve::OnDestroy() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Detach the window from the property page structure.
	// This will be done again by the main application since
	// it owns the property sheet.  It needs o be done here
	// so that the window handle can be removed from the
	// DLLs handle map.
	if( m_fNeedToDetach && m_hWnd )
	{
		HWND hWnd = m_hWnd;
		Detach();
		m_hWnd = hWnd;
	}

	CPropertyPage::OnDestroy();
}


/////////////////////////////////////////////////////////////////////////////
// CPropPageCurve::OnSetActive

BOOL CPropPageCurve::OnSetActive() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Update controls
	m_pPageManager->RefreshData();

	// Store active tab
	m_pPageManager->m_pIPropSheet->GetActivePage( &CCurvePropPageMgr::sm_nActiveTab );
	
	return CPropertyPage::OnSetActive();
}


/////////////////////////////////////////////////////////////////////////////
// CPropPageCurve::OnInitDialog

BOOL CPropPageCurve::OnInitDialog() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	CPropertyPage::OnInitDialog();

	// Fill shape combo box
	TCHAR achShape[SMALL_BUFFER];

	for ( int i = IDS_CURVE_SHAPE1 ;  i <= IDS_CURVE_SHAPE5 ;  i++ )
	{
		::LoadString( theApp.m_hInstance, i, achShape, SMALL_BUFFER );
		m_comboShape.AddString( achShape );
	}
	
	return FALSE;  // return TRUE unless you set the focus to a control
	               // EXCEPTION: OCX Property Pages should return FALSE
}


/////////////////////////////////////////////////////////////////////////////
// CPropPageCurve::OnSelChangeComboShape

void CPropPageCurve::OnSelChangeComboShape() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_pPageManager->m_pIPropPageObject == NULL
	||  m_fInUpdateControls == TRUE )
	{
		return;
	}

	m_pPageManager->m_PropCurve.m_bCurveShape = 0xFF; 

	switch( m_comboShape.GetCurSel() )
	{
		case 0:
			m_pPageManager->m_PropCurve.m_bCurveShape = DMUS_CURVES_SINE; 
			break;

		case 1:
			m_pPageManager->m_PropCurve.m_bCurveShape = DMUS_CURVES_LOG; 
			break;

		case 2:
			m_pPageManager->m_PropCurve.m_bCurveShape = DMUS_CURVES_EXP; 
			break;

		case 3:
			m_pPageManager->m_PropCurve.m_bCurveShape = DMUS_CURVES_INSTANT; 
			break;

		case 4:
			m_pPageManager->m_PropCurve.m_bCurveShape = DMUS_CURVES_LINEAR; 
			break;
	}

	if( m_pPageManager->m_PropCurve.m_bCurveShape != 0xFF )
	{
		m_pPageManager->m_PropCurve.m_dwChanged = CHGD_SHAPE;
		m_pPageManager->m_pIPropPageObject->SetData( &m_pPageManager->m_PropCurve );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CPropPageCurve::OnBtnFlipVert

void CPropPageCurve::OnBtnFlipVert() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_pPageManager->m_pIPropPageObject == NULL
	||  m_fInUpdateControls == TRUE )
	{
		return;
	}

	m_pPageManager->m_PropCurve.m_dwChanged = CHGD_FLIPVERT;
	m_pPageManager->m_pIPropPageObject->SetData( &m_pPageManager->m_PropCurve );
}


/////////////////////////////////////////////////////////////////////////////
// CPropPageCurve::OnDoubleClickedBtnFlipVert

void CPropPageCurve::OnDoubleClickedBtnFlipVert() 
{
	OnBtnFlipVert();
}


/////////////////////////////////////////////////////////////////////////////
// CPropPageCurve::OnBtnFlipHorz

void CPropPageCurve::OnBtnFlipHorz() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_pPageManager->m_pIPropPageObject == NULL
	||  m_fInUpdateControls == TRUE )
	{
		return;
	}

	m_pPageManager->m_PropCurve.m_dwChanged = CHGD_FLIPHORZ;
	m_pPageManager->m_pIPropPageObject->SetData( &m_pPageManager->m_PropCurve );
}


/////////////////////////////////////////////////////////////////////////////
// CPropPageCurve::OnDoubleClickedBtnFlipHorz

void CPropPageCurve::OnDoubleClickedBtnFlipHorz() 
{
	OnBtnFlipHorz();
}


/////////////////////////////////////////////////////////////////////////////
// CPropPageCurve::OnKillFocusStartValue

void CPropPageCurve::OnKillFocusStartValue() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_pPageManager->m_pIPropPageObject == NULL
	||  m_fInUpdateControls == TRUE 
	||  m_fInOnKillFocusStartValue == TRUE )
	{
		return;
	}

	m_fInOnKillFocusStartValue = TRUE;

	if( m_pPageManager->m_PropCurve.m_bEventType == DMUS_CURVET_RPNCURVE
	&&	m_pPageManager->m_PropCurve.m_wParamType == 0 )
	{
		HandleKillFocusStartPBRange();
		m_fInOnKillFocusStartValue = FALSE;
		return;
	}

	// Get current start value
	int nCurStartValue = GetSpinStartValuePos();

	// Get text from edit control
	CString strNewStartValue;
	m_editStartValue.GetWindowText( strNewStartValue );
	strNewStartValue.TrimRight();
	strNewStartValue.TrimLeft();

	int nNewStartValue;

	// Handle unknown text
	if( _tcsncmp( strNewStartValue, achUnknown, 10 ) == 0 )
	{
		return;
	}
	// Handle empty text
	else if( strNewStartValue.IsEmpty() )
	{
		nNewStartValue = 0; // Set to 0
	}
	else
	{
		nNewStartValue = StringToStartEndValue( strNewStartValue );
		if( nNewStartValue == INVALID_CC_VALUE )
		{
			nNewStartValue = nCurStartValue;	// No change
		}
		else
		{
			// Get StartValue range
			int nMin;
			int nMax;
			if( m_pPageManager->m_PropCurve.m_bEventType == DMUS_CURVET_PBCURVE )
			{
				nMin = MIN_PB_DISP_VALUE;
				nMax = MAX_PB_DISP_VALUE;
			}
			else if( (m_pPageManager->m_PropCurve.m_bEventType == DMUS_CURVET_RPNCURVE)
				 ||  (m_pPageManager->m_PropCurve.m_bEventType == DMUS_CURVET_NRPNCURVE) )
			{
				nMin = MIN_RPN_VALUE;
				nMax = MAX_RPN_VALUE;
			}
			else
			{
				nMin = MIN_CC_VALUE;
				nMax = MAX_CC_VALUE;
			}

			// Make sure value is within range
			if( nNewStartValue < nMin )
			{
				nNewStartValue = nMin;
			}
			if( nNewStartValue > nMax )
			{
				nNewStartValue = nMax;
			}
		}
	}

	// Text in edit control will by synced in response to the SetData() call, if necessary

	if( nCurStartValue != nNewStartValue )
	{
		SetSpinStartValuePos( nNewStartValue );

		m_pPageManager->m_PropCurve.m_dwChanged = UNDT_STARTVAL;
		m_pPageManager->m_PropCurve.m_nStartValue = (short)nNewStartValue;
		m_pPageManager->m_pIPropPageObject->SetData( &m_pPageManager->m_PropCurve );
	}
	else
	{
		// Check if edit control's text needs to be updated
		CString strValue;
		CString strCurValue;
		StartEndValueToString( nNewStartValue, strValue );
		m_editStartValue.GetWindowText( strCurValue );
		if( strCurValue != strValue )
		{
			m_editStartValue.SetWindowText( strValue );
			// SetSel's needed to get caret to end of string
			m_editStartValue.SetSel( 0, -1 );
			m_editStartValue.SetSel( -1, -1 );
		}
	}

	m_fInOnKillFocusStartValue = FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CPropPageCurve::HandleKillFocusStartPBRange

void CPropPageCurve::HandleKillFocusStartPBRange() 
{
	// Get text from edit control
	CString strNewStartSemiTones, strNewStartCents;
	m_editStartValue.GetWindowText( strNewStartSemiTones );
	strNewStartSemiTones.TrimRight();
	strNewStartSemiTones.TrimLeft();
	m_editPBRStartCents.GetWindowText( strNewStartCents );
	strNewStartCents.TrimRight();
	strNewStartCents.TrimLeft();

	// Handle unknown text
	if( _tcsncmp( strNewStartSemiTones, achUnknown, 10 ) == 0
	&&	_tcsncmp( strNewStartCents, achUnknown, 10 ) == 0 )
	{
		return;
	}

	BOOL fSucceeded = FALSE;
	int nSemiTones = GetDlgItemInt( IDC_EDIT_STARTVALUE, &fSucceeded, FALSE );
	if( !fSucceeded )
	{
		nSemiTones = 0;
	}

	int nCents = GetDlgItemInt( IDC_EDIT_PBR_START_CENTS, &fSucceeded, FALSE );
	if( !fSucceeded )
	{
		nCents = 0;
	}

	nCents = min( 127, max( nCents, 0 ) );
	nSemiTones = min( 127, max( nSemiTones, 0 ) );

	int nNewStartValue = nSemiTones * 128 + nCents;

	if( m_pPageManager->m_PropCurve.m_nStartValue != nNewStartValue )
	{
		SetSpinStartValuePos( nNewStartValue );
		SetSpinStartCentsValuePos( nNewStartValue );

		// Text in edit control will by synced in response to the SetData() call, if necessary
		m_pPageManager->m_PropCurve.m_dwChanged = UNDT_STARTVAL;
		m_pPageManager->m_PropCurve.m_nStartValue = (short)nNewStartValue;
		m_pPageManager->m_pIPropPageObject->SetData( &m_pPageManager->m_PropCurve );
	}
	else
	{
		// Check if edit control's text needs to be updated
		CString strValue;
		CString strCurValue;
		StartEndValueToString( nNewStartValue, strValue );
		m_editStartValue.GetWindowText( strCurValue );
		if( strCurValue != strValue )
		{
			m_editStartValue.SetWindowText( strValue );
			// SetSel's needed to get caret to end of string
			m_editStartValue.SetSel( 0, -1 );
			m_editStartValue.SetSel( -1, -1 );
		}

		StartEndValueToCentsString( nNewStartValue, strValue );
		m_editPBRStartCents.GetWindowText( strCurValue );
		if( strCurValue != strValue )
		{
			m_editPBRStartCents.SetWindowText( strValue );
			// SetSel's needed to get caret to end of string
			m_editPBRStartCents.SetSel( 0, -1 );
			m_editPBRStartCents.SetSel( -1, -1 );
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CPropPageCurve::OnDeltaPosSpinStartValue

void CPropPageCurve::OnDeltaPosSpinStartValue(NMHDR* pNMHDR, LRESULT* pResult) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_pPageManager->m_pIPropPageObject == NULL
	||  m_fInUpdateControls == TRUE )
	{
		return;
	}

	// Just in case user clicked on spin control immediately after typing text
	OnKillFocusStartValue();

	NM_UPDOWN* pNMUpDown = (NM_UPDOWN*)pNMHDR;

	int nNewStartValue = GetSpinStartValuePos() + pNMUpDown->iDelta;

	// Get StartValue range
	int nMin;
	int nMax;
	if( m_pPageManager->m_PropCurve.m_bEventType == DMUS_CURVET_PBCURVE )
	{
		nMin = MIN_PB_DISP_VALUE;
		nMax = MAX_PB_DISP_VALUE;
	}
	else if( m_pPageManager->m_PropCurve.m_bEventType == DMUS_CURVET_RPNCURVE
		 &&  m_pPageManager->m_PropCurve.m_wParamType == 0 )
	{
		nMin = MIN_CC_VALUE;
		nMax = MAX_CC_VALUE;
	}
	else if( (m_pPageManager->m_PropCurve.m_bEventType == DMUS_CURVET_RPNCURVE)
		 ||  (m_pPageManager->m_PropCurve.m_bEventType == DMUS_CURVET_NRPNCURVE) )
	{
		nMin = MIN_RPN_VALUE;
		nMax = MAX_RPN_VALUE;
	}
	else
	{
		nMin = MIN_CC_VALUE;
		nMax = MAX_CC_VALUE;
	}

	// Make sure value is within range
	if( nNewStartValue < nMin )
	{
		nNewStartValue = nMin;
	}
	if( nNewStartValue > nMax )
	{
		nNewStartValue = nMax;
	}

	// If a PB Range value, multiply by 128
	if( m_pPageManager->m_PropCurve.m_bEventType == DMUS_CURVET_RPNCURVE
	&&	m_pPageManager->m_PropCurve.m_wParamType == 0 )
	{
		nNewStartValue *= 128;
	}

	CString strValue;

	StartEndValueToString( nNewStartValue, strValue );
	m_editStartValue.SetWindowText( strValue );
	SetSpinStartValuePos( nNewStartValue );

	m_pPageManager->m_PropCurve.m_dwChanged = CHGD_STARTVAL;
	if( m_pPageManager->m_PropCurve.m_bEventType == DMUS_CURVET_RPNCURVE
	&&	m_pPageManager->m_PropCurve.m_wParamType == 0 )
	{
		m_pPageManager->m_PropCurve.m_nStartValue &= 0x007F;
		m_pPageManager->m_PropCurve.m_nStartValue |= (short)nNewStartValue;
	}
	else
	{
		m_pPageManager->m_PropCurve.m_nStartValue = (short)nNewStartValue;
	}
	m_pPageManager->m_pIPropPageObject->SetData( &m_pPageManager->m_PropCurve );
	
	*pResult = 1;
}


/////////////////////////////////////////////////////////////////////////////
// CPropPageCurve::OnKillFocusEndValue

void CPropPageCurve::OnKillFocusEndValue() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_pPageManager->m_pIPropPageObject == NULL
	||  m_fInUpdateControls == TRUE 
	||  m_fInOnKillFocusEndValue == TRUE )
	{
		return;
	}

	m_fInOnKillFocusEndValue = TRUE;

	if( m_pPageManager->m_PropCurve.m_bEventType == DMUS_CURVET_RPNCURVE
	&&	m_pPageManager->m_PropCurve.m_wParamType == 0 )
	{
		HandleKillFocusEndPBRange();
		m_fInOnKillFocusEndValue = FALSE;
		return;
	}

	// Get current end value
	int nCurEndValue = GetSpinEndValuePos();

	// Get text from edit control
	CString strNewEndValue;
	m_editEndValue.GetWindowText( strNewEndValue );
	strNewEndValue.TrimRight();
	strNewEndValue.TrimLeft();

	int nNewEndValue;

	// Handle unknown text
	if( _tcsncmp( strNewEndValue, achUnknown, 10 ) == 0 )
	{
		return;
	}
	// Handle empty text
	else if( strNewEndValue.IsEmpty() )
	{
		nNewEndValue = 0; // Set to 0
	}
	else
	{
		nNewEndValue = StringToStartEndValue( strNewEndValue );
		if( nNewEndValue == INVALID_CC_VALUE )
		{
			nNewEndValue = nCurEndValue;	// No change
		}
		else
		{
			// Get EndValue range
			int nMin;
			int nMax;
			if( m_pPageManager->m_PropCurve.m_bEventType == DMUS_CURVET_PBCURVE )
			{
				nMin = MIN_PB_DISP_VALUE;
				nMax = MAX_PB_DISP_VALUE;
			}
			else if( (m_pPageManager->m_PropCurve.m_bEventType == DMUS_CURVET_RPNCURVE)
				 ||  (m_pPageManager->m_PropCurve.m_bEventType == DMUS_CURVET_NRPNCURVE) )
			{
				nMin = MIN_RPN_VALUE;
				nMax = MAX_RPN_VALUE;
			}
			else
			{
				nMin = MIN_CC_VALUE;
				nMax = MAX_CC_VALUE;
			}

			// Make sure value is within range
			if( nNewEndValue < nMin )
			{
				nNewEndValue = nMin;
			}
			if( nNewEndValue > nMax )
			{
				nNewEndValue = nMax;
			}
		}
	}

	// Text in edit control will by synced in response to the SetData() call, if necessary

	if( nCurEndValue != nNewEndValue )
	{
		SetSpinEndValuePos( nNewEndValue );

		m_pPageManager->m_PropCurve.m_dwChanged = CHGD_ENDVAL;
		m_pPageManager->m_PropCurve.m_nEndValue = (short)nNewEndValue;
		m_pPageManager->m_pIPropPageObject->SetData( &m_pPageManager->m_PropCurve );
	}
	else
	{
		// Check if edit control's text needs to be updated
		CString strValue;
		CString strCurValue;
		StartEndValueToString( nNewEndValue, strValue );
		m_editEndValue.GetWindowText( strCurValue );
		if( strCurValue != strValue )
		{
			m_editEndValue.SetWindowText( strValue );
			// SetSel's needed to get caret to end of string
			m_editEndValue.SetSel( 0, -1 );
			m_editEndValue.SetSel( -1, -1 );
		}
	}

	m_fInOnKillFocusEndValue = FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CPropPageCurve::HandleKillFocusEndPBRange

void CPropPageCurve::HandleKillFocusEndPBRange() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Get text from edit control
	CString strNewEndSemiTones, strNewEndCents;
	m_editEndValue.GetWindowText( strNewEndSemiTones );
	strNewEndSemiTones.TrimRight();
	strNewEndSemiTones.TrimLeft();
	m_editPBREndCents.GetWindowText( strNewEndCents );
	strNewEndCents.TrimRight();
	strNewEndCents.TrimLeft();

	// Handle unknown text
	if( _tcsncmp( strNewEndSemiTones, achUnknown, 10 ) == 0
	&&	_tcsncmp( strNewEndCents, achUnknown, 10 ) == 0 )
	{
		return;
	}

	BOOL fSucceeded = FALSE;
	int nSemiTones = GetDlgItemInt( IDC_EDIT_ENDVALUE, &fSucceeded, FALSE );
	if( !fSucceeded )
	{
		nSemiTones = 0;
	}

	int nCents = GetDlgItemInt( IDC_EDIT_PBR_END_CENTS, &fSucceeded, FALSE );
	if( !fSucceeded )
	{
		nCents = 0;
	}

	nCents = min( 127, max( nCents, 0 ) );
	nSemiTones = min( 127, max( nSemiTones, 0 ) );

	int nNewEndValue = nSemiTones * 128 + nCents;

	if( m_pPageManager->m_PropCurve.m_nEndValue != nNewEndValue )
	{
		SetSpinEndValuePos( nNewEndValue );
		SetSpinEndCentsValuePos( nNewEndValue );

		// Text in edit control will by synced in response to the SetData() call, if necessary
		m_pPageManager->m_PropCurve.m_dwChanged = UNDT_ENDVAL;
		m_pPageManager->m_PropCurve.m_nEndValue = (short)nNewEndValue;
		m_pPageManager->m_pIPropPageObject->SetData( &m_pPageManager->m_PropCurve );
	}
	else
	{
		// Check if edit control's text needs to be updated
		CString strValue;
		CString strCurValue;
		StartEndValueToString( nNewEndValue, strValue );
		m_editEndValue.GetWindowText( strCurValue );
		if( strCurValue != strValue )
		{
			m_editEndValue.SetWindowText( strValue );
			// SetSel's needed to get caret to end of string
			m_editEndValue.SetSel( 0, -1 );
			m_editEndValue.SetSel( -1, -1 );
		}

		StartEndValueToCentsString( nNewEndValue, strValue );
		m_editPBREndCents.GetWindowText( strCurValue );
		if( strCurValue != strValue )
		{
			m_editPBREndCents.SetWindowText( strValue );
			// SetSel's needed to get caret to end of string
			m_editPBREndCents.SetSel( 0, -1 );
			m_editPBREndCents.SetSel( -1, -1 );
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CPropPageCurve::OnDeltaPosSpinEndValue

void CPropPageCurve::OnDeltaPosSpinEndValue(NMHDR* pNMHDR, LRESULT* pResult) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_pPageManager->m_pIPropPageObject == NULL
	||  m_fInUpdateControls == TRUE )
	{
		return;
	}

	// Just in case user clicked on spin control immediately after typing text
	OnKillFocusEndValue();

	NM_UPDOWN* pNMUpDown = (NM_UPDOWN*)pNMHDR;

	int nNewEndValue = GetSpinEndValuePos() + pNMUpDown->iDelta;

	// Get EndValue range
	int nMin;
	int nMax;
	if( m_pPageManager->m_PropCurve.m_bEventType == DMUS_CURVET_PBCURVE )
	{
		nMin = MIN_PB_DISP_VALUE;
		nMax = MAX_PB_DISP_VALUE;
	}
	else if( m_pPageManager->m_PropCurve.m_bEventType == DMUS_CURVET_RPNCURVE
		 &&  m_pPageManager->m_PropCurve.m_wParamType == 0 )
	{
		nMin = MIN_CC_VALUE;
		nMax = MAX_CC_VALUE;
	}
	else if( (m_pPageManager->m_PropCurve.m_bEventType == DMUS_CURVET_RPNCURVE)
		 ||  (m_pPageManager->m_PropCurve.m_bEventType == DMUS_CURVET_NRPNCURVE) )
	{
		nMin = MIN_RPN_VALUE;
		nMax = MAX_RPN_VALUE;
	}
	else
	{
		nMin = MIN_CC_VALUE;
		nMax = MAX_CC_VALUE;
	}

	// Make sure value is within range
	if( nNewEndValue < nMin )
	{
		nNewEndValue = nMin;
	}
	if( nNewEndValue > nMax )
	{
		nNewEndValue = nMax;
	}

	// If a PB Range value, multiply by 128
	if( m_pPageManager->m_PropCurve.m_bEventType == DMUS_CURVET_RPNCURVE
	&&	m_pPageManager->m_PropCurve.m_wParamType == 0 )
	{
		nNewEndValue *= 128;
	}

	CString strValue;

	StartEndValueToString( nNewEndValue, strValue );
	m_editEndValue.SetWindowText( strValue );
	SetSpinEndValuePos( nNewEndValue );

	m_pPageManager->m_PropCurve.m_dwChanged = CHGD_ENDVAL;
	if( m_pPageManager->m_PropCurve.m_bEventType == DMUS_CURVET_RPNCURVE
	&&	m_pPageManager->m_PropCurve.m_wParamType == 0 )
	{
		m_pPageManager->m_PropCurve.m_nEndValue &= 0x007F;
		m_pPageManager->m_PropCurve.m_nEndValue |= (short)nNewEndValue;
	}
	else
	{
		m_pPageManager->m_PropCurve.m_nEndValue = (short)nNewEndValue;
	}
	m_pPageManager->m_pIPropPageObject->SetData( &m_pPageManager->m_PropCurve );
	
	*pResult = 1;
}


/////////////////////////////////////////////////////////////////////////////
// CPropPageCurve::OnChangeStartBar

void CPropPageCurve::OnChangeStartBar() 
{
	HandleEditChange(m_spinStartBar, CHGD_STARTBAR,
		m_pPageManager->m_PropCurve.m_lStartBar);
}


/////////////////////////////////////////////////////////////////////////////
// CPropPageCurve::OnKillFocusStartBar

void CPropPageCurve::OnKillFocusStartBar() 
{
	HandleKillFocus(m_spinStartBar, CHGD_STARTBAR,
		m_pPageManager->m_PropCurve.m_lStartBar);
}


/////////////////////////////////////////////////////////////////////////////
// CPropPageCurve::OnChangeStartBeat

void CPropPageCurve::OnChangeStartBeat() 
{
	HandleEditChange(m_spinStartBeat, CHGD_STARTBEAT,
		m_pPageManager->m_PropCurve.m_lStartBeat);
}


/////////////////////////////////////////////////////////////////////////////
// CPropPageCurve::OnKillFocusStartBeat

void CPropPageCurve::OnKillFocusStartBeat() 
{
	HandleKillFocus(m_spinStartBeat, CHGD_STARTBEAT,
		m_pPageManager->m_PropCurve.m_lStartBeat);
}


/////////////////////////////////////////////////////////////////////////////
// CPropPageCurve::OnChangeStartGrid

void CPropPageCurve::OnChangeStartGrid() 
{
	HandleEditChange(m_spinStartGrid, CHGD_STARTGRID,
		m_pPageManager->m_PropCurve.m_lStartGrid);
}


/////////////////////////////////////////////////////////////////////////////
// CPropPageCurve::OnKillFocusStartGrid

void CPropPageCurve::OnKillFocusStartGrid() 
{
	HandleKillFocus(m_spinStartGrid, CHGD_STARTGRID,
		m_pPageManager->m_PropCurve.m_lStartGrid);
}


/////////////////////////////////////////////////////////////////////////////
// CPropPageCurve::OnChangeStartTick

void CPropPageCurve::OnChangeStartTick() 
{
	HandleEditChange(m_spinStartTick, CHGD_STARTTICK,
		m_pPageManager->m_PropCurve.m_lStartTick);
}


/////////////////////////////////////////////////////////////////////////////
// CPropPageCurve::OnKillFocusStartTick

void CPropPageCurve::OnKillFocusStartTick() 
{
	HandleKillFocus(m_spinStartTick, CHGD_STARTTICK,
		m_pPageManager->m_PropCurve.m_lStartTick);
}


/////////////////////////////////////////////////////////////////////////////
// CPropPageCurve::OnChangeEndBar

void CPropPageCurve::OnChangeEndBar() 
{
	HandleEditChange(m_spinEndBar, CHGD_ENDBAR,
		m_pPageManager->m_PropCurve.m_lEndBar);
}


/////////////////////////////////////////////////////////////////////////////
// CPropPageCurve::OnKillFocusEndBar

void CPropPageCurve::OnKillFocusEndBar() 
{
	HandleKillFocus(m_spinEndBar, CHGD_ENDBAR,
		m_pPageManager->m_PropCurve.m_lEndBar);
}


/////////////////////////////////////////////////////////////////////////////
// CPropPageCurve::OnChangeEndBeat

void CPropPageCurve::OnChangeEndBeat() 
{
	HandleEditChange(m_spinEndBeat, CHGD_ENDBEAT,
		m_pPageManager->m_PropCurve.m_lEndBeat);
}


/////////////////////////////////////////////////////////////////////////////
// CPropPageCurve::OnKillFocusEndBeat

void CPropPageCurve::OnKillFocusEndBeat() 
{
	HandleKillFocus(m_spinEndBeat, CHGD_ENDBEAT,
		m_pPageManager->m_PropCurve.m_lEndBeat);
}


/////////////////////////////////////////////////////////////////////////////
// CPropPageCurve::OnChangeEndGrid

void CPropPageCurve::OnChangeEndGrid() 
{
	HandleEditChange(m_spinEndGrid, CHGD_ENDGRID,
		m_pPageManager->m_PropCurve.m_lEndGrid);
}


/////////////////////////////////////////////////////////////////////////////
// CPropPageCurve::OnKillFocusEndGrid

void CPropPageCurve::OnKillFocusEndGrid() 
{
	HandleKillFocus(m_spinEndGrid, CHGD_ENDGRID,
		m_pPageManager->m_PropCurve.m_lEndGrid);
}


/////////////////////////////////////////////////////////////////////////////
// CPropPageCurve::OnChangeEndTick

void CPropPageCurve::OnChangeEndTick() 
{
	HandleEditChange(m_spinEndTick, CHGD_ENDTICK,
		m_pPageManager->m_PropCurve.m_lEndTick);
}


/////////////////////////////////////////////////////////////////////////////
// CPropPageCurve::OnKillFocusEndTick

void CPropPageCurve::OnKillFocusEndTick() 
{
	HandleKillFocus(m_spinEndTick, CHGD_ENDTICK,
		m_pPageManager->m_PropCurve.m_lEndTick);
}


/////////////////////////////////////////////////////////////////////////////
// CPropPageCurve::OnChangeDurBar

void CPropPageCurve::OnChangeDurBar() 
{
	HandleEditChange(m_spinDurBar, CHGD_DURBAR,
		m_pPageManager->m_PropCurve.m_lDurBar);
}


/////////////////////////////////////////////////////////////////////////////
// CPropPageCurve::OnKillFocusDurBar

void CPropPageCurve::OnKillFocusDurBar() 
{
	HandleKillFocus(m_spinDurBar, CHGD_DURBAR,
		m_pPageManager->m_PropCurve.m_lDurBar);
}


/////////////////////////////////////////////////////////////////////////////
// CPropPageCurve::OnChangeDurBeat

void CPropPageCurve::OnChangeDurBeat() 
{
	HandleEditChange(m_spinDurBeat, CHGD_DURBEAT,
		m_pPageManager->m_PropCurve.m_lDurBeat);
}


/////////////////////////////////////////////////////////////////////////////
// CPropPageCurve::OnKillFocusDurBeat

void CPropPageCurve::OnKillFocusDurBeat() 
{
	HandleKillFocus(m_spinDurBeat, CHGD_DURBEAT,
		m_pPageManager->m_PropCurve.m_lDurBeat);
}


/////////////////////////////////////////////////////////////////////////////
// CPropPageCurve::OnChangeDurGrid

void CPropPageCurve::OnChangeDurGrid() 
{
	HandleEditChange(m_spinDurGrid, CHGD_DURGRID,
		m_pPageManager->m_PropCurve.m_lDurGrid);
}


/////////////////////////////////////////////////////////////////////////////
// CPropPageCurve::OnKillFocusDurGrid

void CPropPageCurve::OnKillFocusDurGrid() 
{
	HandleKillFocus(m_spinDurGrid, CHGD_DURGRID,
		m_pPageManager->m_PropCurve.m_lDurGrid);
}


/////////////////////////////////////////////////////////////////////////////
// CPropPageCurve::OnChangeDurTick

void CPropPageCurve::OnChangeDurTick() 
{
	HandleEditChange(m_spinDurTick, CHGD_DURTICK,
		m_pPageManager->m_PropCurve.m_lDurTick);
}


/////////////////////////////////////////////////////////////////////////////
// CPropPageCurve::OnKillFocusDurTick

void CPropPageCurve::OnKillFocusDurTick() 
{
	HandleKillFocus(m_spinDurTick, CHGD_DURTICK,
		m_pPageManager->m_PropCurve.m_lDurTick);
}


/////////////////////////////////////////////////////////////////////////////
// CPropPageCurve::StartEndValueToString

void CPropPageCurve::StartEndValueToString( int nValue, CString& strValue ) 
{
	strValue.Format( "%d", nValue );

	if( m_pPageManager
	&&  m_pPageManager->m_pIPropPageObject )
	{
		CCurveStrip* pCurveStrip = (CCurveStrip *)m_pPageManager->m_pIPropPageObject;

		if( pCurveStrip->m_bCCType == CCTYPE_PAN_CURVE_STRIP )
		{
			CString strTemp;

			if( nValue < 63 )
			{
				strTemp.LoadString( IDS_PAN_LEFT );
				strValue.Format( "%s%d", strTemp, (63 - nValue) );
			}
			else if( nValue > 63 )
			{
				strTemp.LoadString( IDS_PAN_RIGHT );
				strValue.Format( "%s%d", strTemp, (nValue - 63) );
			}
			else
			{
				strValue.LoadString( IDS_PAN_MID );
			} 
		}

		if( pCurveStrip->m_bCCType == CCTYPE_RPN_CURVE_STRIP
		&&	pCurveStrip->m_wRPNType == 0 )
		{
			strValue.Format( "%d", nValue/128 );
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CPropPageCurve::StringToStartEndValue

int CPropPageCurve::StringToStartEndValue( LPCTSTR pszNewValue )
{
	CString strNewValue = pszNewValue;
	int nLength = strNewValue.GetLength();

	int nNewValue = INVALID_CC_VALUE;

	if( m_pPageManager
	&&  m_pPageManager->m_pIPropPageObject )
	{
		CCurveStrip* pCurveStrip = (CCurveStrip *)m_pPageManager->m_pIPropPageObject;

		if( pCurveStrip->m_bCCType == CCTYPE_PAN_CURVE_STRIP )
		{
			CString strTemp;
			strTemp.LoadString( IDS_PAN_MID );

			if( strTemp.CompareNoCase( strNewValue) == 0 )
			{
				nNewValue = 63;
			}
			else
			{
				CString strMinus;
				strMinus.LoadString( IDS_MINUS_TEXT );

				CString strBalance = strNewValue.Left( 1 );
				CString strValue = strNewValue.Right( nLength - 1 );

				// 1st char of 'L' or negative number means LEFT
				strTemp.LoadString( IDS_PAN_LEFT);
				if( (strTemp.CompareNoCase( strBalance ) == 0)
				||  (strMinus.CompareNoCase( strBalance ) == 0) )
				{
					nNewValue = _ttoi( strValue );
					nNewValue = 63 - nNewValue;
				}
				else
				{
					// 1st char of 'R' or positive number means RIGHT
					strTemp.LoadString( IDS_PAN_RIGHT);
					if( strTemp.CompareNoCase( strBalance ) == 0 )
					{
						nNewValue = _ttoi( strValue );
						nNewValue = 63 + nNewValue;
					}
					else
					{
						nNewValue = _ttoi( strNewValue );
						nNewValue = 63 + nNewValue;
					}
				}
			}
		}
		else
		{
			nNewValue = _ttoi( strNewValue );
		}
	}

	return nNewValue;
}


/////////////////////////////////////////////////////////////////////////////
// CPropPageCurve::StartEndValueToCentsString

void CPropPageCurve::StartEndValueToCentsString( int nValue, CString& strValue ) 
{
	strValue.Format( "%d", nValue % 128 );
}

void CPropPageCurve::OnChangeEditEndValue() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_pPageManager->m_pIPropPageObject == NULL
	||  m_fInUpdateControls == TRUE )
	{
		return;
	}

	// Get text from edit control
	CString strNewEndValue;
	m_editEndValue.GetWindowText( strNewEndValue );
	strNewEndValue.TrimRight();
	strNewEndValue.TrimLeft();

	// Return if string is empty
	if( strNewEndValue.IsEmpty() )
	{
		return;
	}

	// Return if string equals minus sign
	CString strMinus;
	strMinus.LoadString( IDS_MINUS_TEXT );
	if( strMinus.CompareNoCase(strNewEndValue) == 0 )
	{
		return;
	}

	if( m_pPageManager
	&&  m_pPageManager->m_pIPropPageObject )
	{
		CCurveStrip* pCurveStrip = (CCurveStrip *)m_pPageManager->m_pIPropPageObject;

		if( pCurveStrip->m_bCCType == CCTYPE_PAN_CURVE_STRIP )
		{
			// Load strings
			CString strLeft;
			CString strRight;
			strLeft.LoadString( IDS_PAN_LEFT );
			strRight.LoadString( IDS_PAN_RIGHT );

			if( (strLeft.CompareNoCase(strNewEndValue) == 0)
			||  (strRight.CompareNoCase(strNewEndValue) == 0) )
			{
				return;
			}
		}
	}

	OnKillFocusEndValue();
}

void CPropPageCurve::OnChangeEditStartValue() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_pPageManager->m_pIPropPageObject == NULL
	||  m_fInUpdateControls == TRUE )
	{
		return;
	}

	// Get text from edit control
	CString strNewStartValue;
	m_editStartValue.GetWindowText( strNewStartValue );
	strNewStartValue.TrimRight();
	strNewStartValue.TrimLeft();

	// Return if string is empty
	if( strNewStartValue.IsEmpty() )
	{
		return;
	}

	// Return if string equals minus sign
	CString strMinus;
	strMinus.LoadString( IDS_MINUS_TEXT );
	if( strMinus.CompareNoCase(strNewStartValue) == 0 )
	{
		return;
	}

	if( m_pPageManager
	&&  m_pPageManager->m_pIPropPageObject )
	{
		CCurveStrip* pCurveStrip = (CCurveStrip *)m_pPageManager->m_pIPropPageObject;

		if( pCurveStrip->m_bCCType == CCTYPE_PAN_CURVE_STRIP )
		{
			// Load strings
			CString strLeft;
			CString strRight;
			strLeft.LoadString( IDS_PAN_LEFT );
			strRight.LoadString( IDS_PAN_RIGHT );

			if( (strLeft.CompareNoCase(strNewStartValue) == 0)
			||  (strRight.CompareNoCase(strNewStartValue) == 0) )
			{
				return;
			}
		}
	}

	OnKillFocusStartValue();
}


/////////////////////////////////////////////////////////////////////////////
// CPropPageCurve::HandleEditChange
//
// Generic handler for edit box value changes
void CPropPageCurve::HandleEditChange(CSpinButtonCtrl& spin,
										   DWORD dwChg,
										   long& lUpdateVal)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_pPageManager->m_pIPropPageObject == NULL
	||  m_fInUpdateControls == TRUE )
	{
		return;
	}

	if (!::IsWindow(spin.m_hWnd)) {
		return;
	}

	// Get text from edit control
	TCHAR tcstrTmp[DIALOG_LEN];
	CWnd* pEditCtrl = spin.GetBuddy();
	ASSERT(pEditCtrl != NULL);
	pEditCtrl->GetWindowText( tcstrTmp, DIALOG_LEN );

	// If empty, exit early
	if( tcstrTmp[0] == NULL )
	{
		return;
	}

	// Get StartBar range
	int nMin;
	int nMax;
	spin.GetRange( nMin, nMax );

	// Convert from text to an integer
	long lNewValue = _ttoi( tcstrTmp );

	// Ensure the value stays within bounds
	if ( lNewValue < nMin )
	{
		lNewValue = nMin;
		spin.SetPos( nMin );
	}
	else if (lNewValue > nMax)
	{
		lNewValue = nMax;
		spin.SetPos( nMax );
	}
	
	// If the value changed, or it was previously undetermined - update the selected PropCurves
	if( (m_pPageManager->m_PropCurve.m_dwUndetermined & dwChg) || (lNewValue != lUpdateVal) )
	{
		m_pPageManager->m_PropCurve.m_dwChanged = dwChg;
		lUpdateVal = lNewValue;
		m_pPageManager->m_pIPropPageObject->SetData( &m_pPageManager->m_PropCurve );
	}
}

/////////////////////////////////////////////////////////////////////////////
// CPropPageCurve::HandleKillFocus
//
// Generic handler for edit box kill focus events.
void CPropPageCurve::HandleKillFocus(CSpinButtonCtrl& spin,
									 DWORD dwChg,
									 long& lUpdateVal)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_pPageManager->m_pIPropPageObject == NULL
	||  m_fInUpdateControls == TRUE )
	{
		return;
	}

	if (!::IsWindow(spin.m_hWnd)) {
		return;
	}

	// Get StartBar range
	int nMin;
	int nMax;
	spin.GetRange( nMin, nMax );

	// Get text from edit control
	TCHAR tcstrTmp[DIALOG_LEN];
	CWnd* pEditCtrl = spin.GetBuddy();
	ASSERT(pEditCtrl != NULL);
	pEditCtrl->GetWindowText( tcstrTmp, DIALOG_LEN );

	// Handle unknown text
	if( _tcsncmp( tcstrTmp, achUnknown, 10 ) == 0 )
	{
		return;
	}
	// Handle empty text
	else if( tcstrTmp[0] == NULL )
	{
		// Set it back to the minimum value
		spin.SetPos( min( nMin, 0) );

		if( (m_pPageManager->m_PropCurve.m_dwUndetermined & dwChg) || (nMin != lUpdateVal) )
		{
			m_pPageManager->m_PropCurve.m_dwChanged = dwChg;
			lUpdateVal = min( nMin, 0);
			m_pPageManager->m_pIPropPageObject->SetData( &m_pPageManager->m_PropCurve );
		}
	}
}

/////////////////////////////////////////////////////////////////////////////
// CPropPageCurve::OnChangeEditMergeIndex
//
void CPropPageCurve::OnChangeEditMergeIndex() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_pPageManager->m_pIPropPageObject == NULL
	||  m_fInUpdateControls == TRUE )
	{
		return;
	}

	if (!::IsWindow(m_spinMergeIndex.m_hWnd))
	{
		return;
	}

	// Get text from edit control
	TCHAR tcstrTmp[DIALOG_LEN];
	m_editMergeIndex.GetWindowText( tcstrTmp, DIALOG_LEN );

	// If empty, exit early
	if( tcstrTmp[0] == NULL )
	{
		return;
	}

	// Get range
	int nMin;
	int nMax;
	m_spinMergeIndex.GetRange( nMin, nMax );

	// Convert from text to an integer
	long lNewValue = _ttoi( tcstrTmp );

	// Ensure the value stays within bounds
	if ( lNewValue < nMin )
	{
		lNewValue = nMin;
		m_spinMergeIndex.SetPos( nMin );
	}
	else if (lNewValue > nMax)
	{
		lNewValue = nMax;
		m_spinMergeIndex.SetPos( nMax );
	}
	
	// If the value changed, or it was previously undetermined - update the selected PropCurves
	if( (m_pPageManager->m_PropCurve.m_dwUndetermined2 & UNDT2_MERGEINDEX) || ((unsigned)lNewValue != m_pPageManager->m_PropCurve.m_wMergeIndex) )
	{
		m_pPageManager->m_PropCurve.m_dwChanged2 = UNDT2_MERGEINDEX;
		m_pPageManager->m_PropCurve.m_wMergeIndex = WORD(lNewValue);
		m_pPageManager->m_pIPropPageObject->SetData( &m_pPageManager->m_PropCurve );
	}
}

/////////////////////////////////////////////////////////////////////////////
// CPropPageCurve::OnKillfocusEditMergeIndex
//
void CPropPageCurve::OnKillfocusEditMergeIndex() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_pPageManager->m_pIPropPageObject == NULL
	||  m_fInUpdateControls == TRUE )
	{
		return;
	}

	if (!::IsWindow(m_spinMergeIndex.m_hWnd)) {
		return;
	}

	// Get range
	int nMin;
	int nMax;
	m_spinMergeIndex.GetRange( nMin, nMax );

	// Get text from edit control
	TCHAR tcstrTmp[DIALOG_LEN];
	m_editMergeIndex.GetWindowText( tcstrTmp, DIALOG_LEN );

	// Handle unknown text
	if( _tcsncmp( tcstrTmp, achUnknown, 10 ) == 0 )
	{
		return;
	}
	// Handle empty text
	else if( tcstrTmp[0] == NULL )
	{
		// Set it back to the minimum value
		m_spinMergeIndex.SetPos( min( nMin, 0) );

		if( (m_pPageManager->m_PropCurve.m_dwUndetermined2 & UNDT2_MERGEINDEX) || ((unsigned)nMin != m_pPageManager->m_PropCurve.m_wMergeIndex) )
		{
			m_pPageManager->m_PropCurve.m_dwChanged2 = CHGD2_MERGEINDEX;
			m_pPageManager->m_PropCurve.m_wMergeIndex = (WORD)min( nMin, 0);
			m_pPageManager->m_pIPropPageObject->SetData( &m_pPageManager->m_PropCurve );
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CPropPageCurve::OnCheckStartCurrent
//
void CPropPageCurve::OnCheckStartCurrent() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_pPageManager->m_pIPropPageObject == NULL
	||  m_fInUpdateControls == TRUE )
	{
		return;
	}

	int nCurState = m_checkStartCurrent.GetCheck();

	switch( nCurState )
	{
	case 0:
		m_checkStartCurrent.SetCheck( 1 );
		m_pPageManager->m_PropCurve.m_bFlags = DMUS_CURVE_START_FROM_CURRENT;
		break;
	case 1:
	case 2:
		m_checkStartCurrent.SetCheck( 0 );
		m_pPageManager->m_PropCurve.m_bFlags = 0;
		break;
	default:
		ASSERT(FALSE);
		break;
	}

	m_pPageManager->m_PropCurve.m_dwChanged2 = CHGD2_STARTCURRENT;
	m_pPageManager->m_pIPropPageObject->SetData( &m_pPageManager->m_PropCurve );
}

void CPropPageCurve::OnChangeEditPbrStartCents() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_pPageManager->m_pIPropPageObject == NULL
	||  m_fInUpdateControls == TRUE )
	{
		return;
	}

	// Get text from edit control
	CString strNewStartValue;
	m_editPBRStartCents.GetWindowText( strNewStartValue );
	strNewStartValue.TrimRight();
	strNewStartValue.TrimLeft();

	// Return if string is empty
	if( strNewStartValue.IsEmpty() )
	{
		return;
	}

	OnKillfocusEditPbrStartCents();
}

void CPropPageCurve::OnKillfocusEditPbrStartCents() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_pPageManager->m_pIPropPageObject == NULL
	||  m_fInUpdateControls == TRUE 
	||  m_fInOnKillFocusStartValue == TRUE )
	{
		return;
	}

	m_fInOnKillFocusStartValue = TRUE;
	HandleKillFocusStartPBRange();
	m_fInOnKillFocusStartValue = FALSE;
}

void CPropPageCurve::OnChangeEditPbrEndCents() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_pPageManager->m_pIPropPageObject == NULL
	||  m_fInUpdateControls == TRUE )
	{
		return;
	}

	// Get text from edit control
	CString strNewEndValue;
	m_editPBREndCents.GetWindowText( strNewEndValue );
	strNewEndValue.TrimRight();
	strNewEndValue.TrimLeft();

	// Return if string is empty
	if( strNewEndValue.IsEmpty() )
	{
		return;
	}

	OnKillfocusEditPbrEndCents();
}

void CPropPageCurve::OnKillfocusEditPbrEndCents() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_pPageManager->m_pIPropPageObject == NULL
	||  m_fInUpdateControls == TRUE 
	||  m_fInOnKillFocusEndValue == TRUE )
	{
		return;
	}

	m_fInOnKillFocusEndValue = TRUE;
	HandleKillFocusEndPBRange();
	m_fInOnKillFocusEndValue = FALSE;
}

void CPropPageCurve::OnDeltaposSpinPbrEndCents(NMHDR* pNMHDR, LRESULT* pResult) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_pPageManager->m_pIPropPageObject == NULL
	||  m_fInUpdateControls == TRUE )
	{
		return;
	}

	// Just in case user clicked on spin control immediately after typing text
	OnKillfocusEditPbrEndCents();

	NM_UPDOWN* pNMUpDown = (NM_UPDOWN*)pNMHDR;

	int nNewEndValue = LOWORD(m_spinPBREndCents.GetPos()) + pNMUpDown->iDelta;

	// Make sure value is within range
	if( nNewEndValue < MIN_CC_VALUE )
	{
		nNewEndValue = MIN_CC_VALUE;
	}
	if( nNewEndValue > MAX_CC_VALUE )
	{
		nNewEndValue = MAX_CC_VALUE;
	}

	CString strValue;

	// It's ok to use nNewEndValue without the high-order value, since the value
	// is % 128 inside the conversion functions.
	StartEndValueToCentsString( nNewEndValue, strValue );
	m_editPBREndCents.SetWindowText( strValue );
	SetSpinEndCentsValuePos( nNewEndValue );

	m_pPageManager->m_PropCurve.m_dwChanged = CHGD_ENDVAL;
	m_pPageManager->m_PropCurve.m_nEndValue &= 0xFF80;
	m_pPageManager->m_PropCurve.m_nEndValue |= (short)nNewEndValue;
	m_pPageManager->m_pIPropPageObject->SetData( &m_pPageManager->m_PropCurve );
	
	*pResult = 1;
}

void CPropPageCurve::OnDeltaposSpinPbrStartCents(NMHDR* pNMHDR, LRESULT* pResult) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_pPageManager->m_pIPropPageObject == NULL
	||  m_fInUpdateControls == TRUE )
	{
		return;
	}

	// Just in case user clicked on spin control immediately after typing text
	OnKillfocusEditPbrStartCents();

	NM_UPDOWN* pNMUpDown = (NM_UPDOWN*)pNMHDR;

	int nNewStartValue = LOWORD(m_spinPBRStartCents.GetPos()) + pNMUpDown->iDelta;

	// Make sure value is within range
	if( nNewStartValue < MIN_CC_VALUE )
	{
		nNewStartValue = MIN_CC_VALUE;
	}
	if( nNewStartValue > MAX_CC_VALUE )
	{
		nNewStartValue = MAX_CC_VALUE;
	}

	CString strValue;

	// It's ok to use nNewStartValue without the high-order value, since the value
	// is % 128 inside the conversion functions.
	StartEndValueToCentsString( nNewStartValue, strValue );
	m_editPBRStartCents.SetWindowText( strValue );
	SetSpinStartCentsValuePos( nNewStartValue );

	m_pPageManager->m_PropCurve.m_dwChanged = CHGD_STARTVAL;
	m_pPageManager->m_PropCurve.m_nStartValue &= 0xFF80;
	m_pPageManager->m_PropCurve.m_nStartValue |= (short)nNewStartValue;
	m_pPageManager->m_pIPropPageObject->SetData( &m_pPageManager->m_PropCurve );
	
	*pResult = 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Shared\TabBoundaryFlags.h ===
#if !defined(AFX_TABBOUNDARYFLAGS_H__4B3A5402_6B29_11D1_89AE_00A0C9054129__INCLUDED_)
#define AFX_TABBOUNDARYFLAGS_H__4B3A5402_6B29_11D1_89AE_00A0C9054129__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

// TabBoundaryFlags.h : header file
//

#include "DMUSProd.h"
#include "TabBoundaryFlagsResource.h"

#define PROPF_HAVE_VALID_DATA	0x00000001
#define PROPF_OMIT_SEGF_DEFAULT	0x00000002

typedef struct _PPGTabBoundaryFlags
{
	_PPGTabBoundaryFlags( void )
	{
		dwPageIndex = 2;
		dwPlayFlags = 0;
		dwFlagsUI = 0;
	}

	DWORD	dwPageIndex;
	DWORD	dwPlayFlags;
	DWORD	dwFlagsUI;
	CString strPrompt;
} PPGTabBoundaryFlags;


/////////////////////////////////////////////////////////////////////////////
// CTabBoundaryFlags dialog

class CTabBoundaryFlags : public CPropertyPage
{
// Construction
public:
	CTabBoundaryFlags( IDMUSProdPropPageManager* pIPageManager );
	~CTabBoundaryFlags();

// Dialog Data
	//{{AFX_DATA(CTabBoundaryFlags)
	enum { IDD = IDD_TAB_BOUNDARY_FLAGS };
	CButton	m_radioInvalidate;
	CButton	m_radioInvalidatePri;
	CButton	m_radioNoInvalidate;
	CStatic	m_staticPrompt;
	CStatic	m_staticNoMarkers;
	CStatic	m_staticAlignPrompt;
	CButton	m_checkSegDefault;
	CButton	m_checkMarker;
	CComboBox	m_comboBoundary;
	CButton	m_radioSwitchOnBoundary;
	CButton	m_radioSwitchAnyTime;
	CButton	m_radioSwitchAnyGrid;
	CButton	m_radioSwitchAnyBeat;
	CButton	m_radioSwitchAnyBar;
	CButton	m_radioTimingQuick;
	CButton	m_radioTimingAfterPrepareTime;
	//}}AFX_DATA

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CTabBoundaryFlags)
	public:
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CTabBoundaryFlags)
	afx_msg void OnDestroy();
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnCheckMarker();
	afx_msg void OnDoubleClickedCheckMarker();
	afx_msg void OnCheckSegDefault();
	afx_msg void OnDoubleClickedCheckSegDefault();
	afx_msg void OnSelChangeComboBoundary();
	afx_msg void OnRadioSwitchAnyBar();
	afx_msg void OnDoubleClickedRadioSwitchAnyBar();
	afx_msg void OnRadioSwitchAnyBeat();
	afx_msg void OnDoubleClickedRadioSwitchAnyBeat();
	afx_msg void OnRadioSwitchAnyGrid();
	afx_msg void OnDoubleClickedRadioSwitchAnyGrid();
	afx_msg void OnRadioSwitchAnyTime();
	afx_msg void OnDoubleClickedRadioSwitchAnyTime();
	afx_msg void OnRadioSwitchNextBoundary();
	afx_msg void OnDoubleClickedRadioSwitchNextBoundary();
	afx_msg void OnRadioTimingAfterPrepareTime();
	afx_msg void OnDoubleClickedRadioTimingAfterPrepareTime();
	afx_msg void OnRadioTimingQuick();
	afx_msg void OnDoubleClickedRadioTimingQuick();
	afx_msg void OnRadioInvalidate();
	afx_msg void OnRadioInvalidatepri();
	afx_msg void OnRadioNoinvalidate();
	afx_msg void OnDoubleClickedRadioInvalidate();
	afx_msg void OnDoubleClickedRadioInvalidatepri();
	afx_msg void OnDoubleClickedRadioNoinvalidate();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

protected:
	void EnableControls( BOOL fEnable );
	void UpdateObject();
	void HandlePlayFlags();

public:
	void UseTransitionPrompts( BOOL fUseTransitionPrompts );
	void SetObject( IDMUSProdPropPageObject* pPropPageObject );
	void RefreshTab( void );

	// Variables for keeping track of the active property tab (if there is more than one)
	static short*				sm_pnActiveTab;
	IDMUSProdPropSheet*			m_rpIPropSheet;

protected:
	IDMUSProdPropPageManager*	m_pIPageManager;
	IDMUSProdPropPageObject*	m_pIPropPageObject;
	PPGTabBoundaryFlags			m_PPGTabBoundaryFlags;
	BOOL						m_fNeedToDetach;
	BOOL						m_fUseTransitionPrompts;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_TABBOUNDARYFLAGS_H__4B3A5402_6B29_11D1_89AE_00A0C9054129__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SignPostStripMgr\ContextMenuHandler.h ===
#if !defined(AFX_CONTEXTMENUHANDLER_H__B49AF6C3_EE6A_11D0_BAD6_00805F493F43__INCLUDED_)
#define AFX_CONTEXTMENUHANDLER_H__B49AF6C3_EE6A_11D0_BAD6_00805F493F43__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// ContextMenuHandler.h : header file
//

#include "timeline.h"

/////////////////////////////////////////////////////////////////////////////
// CContextMenuHandler window

class CContextMenuHandler : public CWnd
{
// Construction
public:
	CContextMenuHandler();

// Attributes
public:

	IDMUSProdStrip *m_pStrip;

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CContextMenuHandler)
	protected:
	virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam);
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CContextMenuHandler();

	// Generated message map functions
protected:
	//{{AFX_MSG(CContextMenuHandler)
		// NOTE - the ClassWizard will add and remove member functions here.
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_CONTEXTMENUHANDLER_H__B49AF6C3_EE6A_11D0_BAD6_00805F493F43__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Shared\Templates.h ===
// templates.h

#ifndef __TEMPLATES_H__
#define __TEMPLATES_H__

#include <winbase.h>

template< class T > T* List_Cat( T* p1, T* p2 )
{
    T* pScan;

    if( p1 == NULL )
    {
        return p2;
    }
    for( pScan = p1 ; pScan->pNext != NULL ; pScan = (T*)pScan->pNext );
    pScan->pNext = p2;
    return p1;
}

template< class T > DWORD List_Len( T* p )
{
    DWORD dw;

    for( dw = 0 ; p != NULL ; p = (T*)p->pNext )
    {
         ++dw;
    }

    return dw;
}

template< class T > BOOL inlist( T* lst, T* p )
{
    if( p == NULL )
    {
        return TRUE;
    }

    for( ; lst != NULL ; lst = (T*)lst->pNext )
    {
        if( p == lst )
        {
            return TRUE;
        }
    }

    return FALSE;
}

template< class T > T* List_Index( T* lst, DWORD dwIndex )
{
    T* pScan;

    for( pScan = lst ; dwIndex > 0 && pScan != NULL && pScan->pNext != NULL ; --dwIndex, pScan = (T*)pScan->pNext );

    return pScan;
}

template< class T > T* List_Insert( T* lst, T* p, DWORD dwIndex )
{
    T* pPrev;

    if( lst == NULL || dwIndex == 0 )
    {
        p->pNext = lst;
        lst = p;
    }
    else
    {
        pPrev = List_Index( lst, dwIndex - 1 );
        p->pNext = pPrev->pNext;
        pPrev->pNext = p;
    }

    return lst;
}

template< class T > T* List_Remove( T* lst, T* p )
{
    if( lst != NULL )
    {
        if( lst == p )
        {
            lst = (T*)lst->pNext;
            p->pNext = NULL;
        }
        else
        {
            T* pScan;

            for( pScan = lst ; pScan->pNext != p && pScan->pNext != NULL ; pScan = (T*)pScan->pNext );
            if( pScan->pNext != NULL )
            {
                pScan->pNext = pScan->pNext->pNext;
                p->pNext = NULL;
            }
        }
    }

    return lst;
}

template< class T > long List_Position( T* lst, T* p )
{
    long lPos;

    lPos = 0;
    while( lst != NULL && lst != p )
    {
        lst = lst->pNext;
        ++lPos;
    }
    if( lst == NULL )
    {
        return -1;
    }

    return lPos;
}

template< class T > T* List_Clone( T* lst )
{
    T* pPrev;
    T* lstClone;
    T* pCopy;

    lstClone = NULL;
    pPrev = NULL;

    for( ; lst ; lst = (T*)lst->pNext )
    {
        pCopy = new T;
        if( pCopy != NULL )
        {
            memcpy( pCopy, lst, sizeof( T ) );
            pCopy->pNext = NULL;
            if( pPrev != NULL )
            {
                pPrev->pNext = pCopy;
            }
            else
            {
                lstClone = pCopy;
            }
            pPrev = pCopy;
        }
    }

    return lstClone;
}

template< class T > void List_Free( T* lst )
{
    T* pNext;

    for( ; lst != NULL ; lst = pNext )
    {
        pNext = (T*)lst->pNext;
        delete lst;
    }
}

template< class T > T* Clone( T* p )
{
    T* pCopy;

    pCopy = new T;
    if( pCopy != NULL )
    {
        memcpy( pCopy, p, sizeof( T ) );
        pCopy->pNext = NULL;
    }

    return pCopy;
}

#endif // __TEMPLATES_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Shared\TrackFlagsPPG.h ===
#if !defined(AFX_TRACKFLAGSPPG_H__EC7D0C20_F414_4138_8083_BB1A4A729ECD__INCLUDED_)
#define AFX_TRACKFLAGSPPG_H__EC7D0C20_F414_4138_8083_BB1A4A729ECD__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// TrackFlagsPPG.h : header file
//

#include <afxdlgs.h>
#include "GroupBitsPPGresource.h"

typedef struct _PPGTrackFlagsParams
{
	DWORD	dwPageIndex;
	DWORD	dwTrackExtrasFlags;
	DWORD	dwTrackExtrasMask;
	DWORD	dwProducerOnlyFlags;
	DWORD	dwProducerOnlyMask;
} PPGTrackFlagsParams;

#define TRACKFLAGSPPG_INDEX 1

#define ALLEXTRAS_FLAGS (DMUS_TRACKCONFIG_OVERRIDE_ALL | DMUS_TRACKCONFIG_OVERRIDE_PRIMARY | DMUS_TRACKCONFIG_FALLBACK | DMUS_TRACKCONFIG_CONTROL_ENABLED | \
	DMUS_TRACKCONFIG_PLAY_ENABLED | DMUS_TRACKCONFIG_NOTIFICATION_ENABLED | DMUS_TRACKCONFIG_PLAY_CLOCKTIME | DMUS_TRACKCONFIG_PLAY_COMPOSE | \
	DMUS_TRACKCONFIG_LOOP_COMPOSE | DMUS_TRACKCONFIG_COMPOSING | DMUS_TRACKCONFIG_CONTROL_PLAY | DMUS_TRACKCONFIG_CONTROL_NOTIFICATION | \
	DMUS_TRACKCONFIG_TRANS1_FROMSEGSTART | DMUS_TRACKCONFIG_TRANS1_FROMSEGCURRENT | DMUS_TRACKCONFIG_TRANS1_TOSEGSTART )

interface IDMUSProdPropSheet;
interface IDMUSProdPropPageObject;

/////////////////////////////////////////////////////////////////////////////
// CTrackFlagsPPG dialog

class CTrackFlagsPPG : public CPropertyPage
{
	DECLARE_DYNCREATE(CTrackFlagsPPG)

// Construction
public:
	CTrackFlagsPPG();
	~CTrackFlagsPPG();

// Dialog Data
	//{{AFX_DATA(CTrackFlagsPPG)
	enum { IDD = IDD_PROPPAGE_TRACK_FLAGS };
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CTrackFlagsPPG)
	public:
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam);
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CTrackFlagsPPG)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnDestroy();
	afx_msg void OnCheckAuditionOnly();
	afx_msg void OnCheckTransition();
	afx_msg void OnDoubleclickedCheckTransition();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

protected:
	void EnableControls( BOOL fEnable );
	void UpdatePPO();
	void OnTransHelper( int nButtonID, DWORD dwFlag );
	void OnCheckHelper( int nButtonID, DWORD dwFlag );
	void EnableItem(int nItem, BOOL fEnable);

public:
	void SetObject( IDMUSProdPropPageObject* pPPO );
	void RefreshData( void );

	// Variables for keeping track of the active property tab (if there is more than one)
	static short*				sm_pnActiveTab;
	IDMUSProdPropSheet*			m_pIPropSheet;

protected:
	IDMUSProdPropPageObject*	m_pPPO;
	PPGTrackFlagsParams			m_PPGTrackFlagsParams;
	BOOL						m_fNeedToDetach;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_TRACKFLAGSPPG_H__EC7D0C20_F414_4138_8083_BB1A4A729ECD__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Shared\TrackFlagsPPG.cpp ===
/************************************************************************
*                                                                       *
*   Copyright (c) 2000-2001 Microsoft Corp. All rights reserved.        *
*                                                                       *
************************************************************************/

// TrackFlagsPPG.cpp : implementation file
//

#include "stdafx.h"
#include "TrackFlagsPPG.h"
#include "SegmentIO.h"
#pragma warning( push )
#pragma warning( disable : 4201 )
#include <dmusici.h>
#pragma warning( pop )
#include "DMUSProd.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

short *CTrackFlagsPPG::sm_pnActiveTab = NULL;

#define DMUS_TRACKCONFIG_TRANS_ALL (DMUS_TRACKCONFIG_TRANS1_TOSEGSTART | DMUS_TRACKCONFIG_TRANS1_FROMSEGSTART | DMUS_TRACKCONFIG_TRANS1_FROMSEGCURRENT)

/////////////////////////////////////////////////////////////////////////////
// CTrackFlagsPPG property page

IMPLEMENT_DYNCREATE(CTrackFlagsPPG, CPropertyPage)

CTrackFlagsPPG::CTrackFlagsPPG() : CPropertyPage(CTrackFlagsPPG::IDD)
{
	//{{AFX_DATA_INIT(CTrackFlagsPPG)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
	m_pPPO = NULL;
	m_pIPropSheet = NULL;
	m_fNeedToDetach = FALSE;
	m_PPGTrackFlagsParams.dwPageIndex = TRACKFLAGSPPG_INDEX;
	m_PPGTrackFlagsParams.dwTrackExtrasFlags = 0;
	m_PPGTrackFlagsParams.dwTrackExtrasMask = 0;
	m_PPGTrackFlagsParams.dwProducerOnlyFlags = 0;
	m_PPGTrackFlagsParams.dwProducerOnlyMask = 0;
}

CTrackFlagsPPG::~CTrackFlagsPPG()
{
	if( m_pPPO )
	{
		m_pPPO->Release();
		m_pPPO = NULL;
	}
}

void CTrackFlagsPPG::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CTrackFlagsPPG)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CTrackFlagsPPG, CPropertyPage)
	//{{AFX_MSG_MAP(CTrackFlagsPPG)
	ON_WM_CREATE()
	ON_WM_DESTROY()
	ON_BN_CLICKED(IDC_CHECK_AUDITION_ONLY, OnCheckAuditionOnly)
	ON_BN_CLICKED(IDC_CHECK_TRANSITION, OnCheckTransition)
	ON_BN_DOUBLECLICKED(IDC_CHECK_TRANSITION, OnDoubleclickedCheckTransition)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

// private functions
void CTrackFlagsPPG::SetObject( IDMUSProdPropPageObject* pPPO )
{
	if( m_pPPO )
	{
		m_pPPO->Release();
	}
	m_pPPO = pPPO;
	if( m_pPPO )
	{
		m_pPPO->AddRef();
	}
}

void CTrackFlagsPPG::EnableControls( BOOL fEnable ) 
{
	if( ::IsWindow(m_hWnd) == FALSE )
	{
		return;
	}

	if( !fEnable )
	{
		for( int i = IDC_CHECK_OVERRIDE_PLAY ;  i <= IDC_RADIO_TRANS_TOSEGSTART ;  i++ )
		{
			EnableItem( i, FALSE );
		}
	}
	else
	{
		EnableItem( IDC_CHECK_OVERRIDE_ALL, (m_PPGTrackFlagsParams.dwTrackExtrasMask & DMUS_TRACKCONFIG_OVERRIDE_ALL) ? TRUE : FALSE );
		EnableItem( IDC_CHECK_OVERRIDE_PRIMARY, (m_PPGTrackFlagsParams.dwTrackExtrasMask & DMUS_TRACKCONFIG_OVERRIDE_PRIMARY) ? TRUE : FALSE );
		EnableItem( IDC_CHECK_FALLBACK, (m_PPGTrackFlagsParams.dwTrackExtrasMask & DMUS_TRACKCONFIG_FALLBACK) ? TRUE : FALSE );
		EnableItem( IDC_CHECK_OVERRIDE_PLAY, (m_PPGTrackFlagsParams.dwTrackExtrasMask & DMUS_TRACKCONFIG_CONTROL_PLAY) ? TRUE : FALSE );
		EnableItem( IDC_CHECK_OVERRIDE_NOTIFICATION, (m_PPGTrackFlagsParams.dwTrackExtrasMask & DMUS_TRACKCONFIG_CONTROL_NOTIFICATION) ? TRUE : FALSE );

		EnableItem( IDC_CHECK_ENABLE_PLAY, (m_PPGTrackFlagsParams.dwTrackExtrasMask & DMUS_TRACKCONFIG_PLAY_ENABLED) ? TRUE : FALSE );
		EnableItem( IDC_CHECK_ENABLE_CONTROL, (m_PPGTrackFlagsParams.dwTrackExtrasMask & DMUS_TRACKCONFIG_CONTROL_ENABLED) ? TRUE : FALSE );
		EnableItem( IDC_CHECK_SEND_NOTIFICATIONS, (m_PPGTrackFlagsParams.dwTrackExtrasMask & DMUS_TRACKCONFIG_NOTIFICATION_ENABLED) ? TRUE : FALSE );

		EnableItem( IDC_CHECK_USE_CLOCKTIME, (m_PPGTrackFlagsParams.dwTrackExtrasMask & DMUS_TRACKCONFIG_PLAY_CLOCKTIME) ? TRUE : FALSE );
		EnableItem( IDC_CHECK_RECOMPOSE_ON_PLAY, (m_PPGTrackFlagsParams.dwTrackExtrasMask & DMUS_TRACKCONFIG_PLAY_COMPOSE) ? TRUE : FALSE );
		EnableItem( IDC_CHECK_RECOMPOSE_ON_LOOP, (m_PPGTrackFlagsParams.dwTrackExtrasMask & DMUS_TRACKCONFIG_LOOP_COMPOSE) ? TRUE : FALSE );
		//EnableItem( IDC_CHECK_COMPOSING, (m_PPGTrackFlagsParams.dwTrackExtrasMask & DMUS_TRACKCONFIG_COMPOSING) ? TRUE : FALSE );

		// Enable checkbox if any of the transition flags are valid
		EnableItem( IDC_CHECK_TRANSITION, (m_PPGTrackFlagsParams.dwTrackExtrasMask & DMUS_TRACKCONFIG_TRANS_ALL) ? TRUE : FALSE );

		// Only enable radio buttons if the checkbox will be checked (if at least one transition flag is checked)
		if( m_PPGTrackFlagsParams.dwTrackExtrasFlags & DMUS_TRACKCONFIG_TRANS_ALL )
		{
			EnableItem( IDC_RADIO_TRANS_TOSEGSTART, (m_PPGTrackFlagsParams.dwTrackExtrasMask & DMUS_TRACKCONFIG_TRANS1_TOSEGSTART) ? TRUE : FALSE );
			EnableItem( IDC_RADIO_TRANS_FROMSEGSTART, (m_PPGTrackFlagsParams.dwTrackExtrasMask & DMUS_TRACKCONFIG_TRANS1_FROMSEGSTART) ? TRUE : FALSE );
			EnableItem( IDC_RADIO_TRANS_FROMSEGCURRENT, (m_PPGTrackFlagsParams.dwTrackExtrasMask & DMUS_TRACKCONFIG_TRANS1_FROMSEGCURRENT) ? TRUE : FALSE );
		}
		else
		{
			EnableItem( IDC_RADIO_TRANS_TOSEGSTART, FALSE );
			EnableItem( IDC_RADIO_TRANS_FROMSEGSTART, FALSE );
			EnableItem( IDC_RADIO_TRANS_FROMSEGCURRENT, FALSE );
		}

		EnableItem( IDC_CHECK_AUDITION_ONLY, (m_PPGTrackFlagsParams.dwProducerOnlyMask & SEG_PRODUCERONLY_AUDITIONONLY) ? TRUE : FALSE );
	}

}

/////////////////////////////////////////////////////////////////////////////
// CTrackFlagsPPG message handlers

int CTrackFlagsPPG::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Attach the window to the property page structure.
	// This has been done once already in the main application
	// since the main application owns the property sheet.
	// It needs to be done here so that the window handle can
	// be found in the DLLs handle map.
	if( !FromHandlePermanent( m_hWnd ) )
	{
		HWND hWnd = m_hWnd;
		m_hWnd = NULL;
		Attach( hWnd );
		m_fNeedToDetach = TRUE;
	}

	if (CPropertyPage::OnCreate(lpCreateStruct) == -1)
		return -1;
	
	return 0;
}

void CTrackFlagsPPG::OnDestroy() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Detach the window from the property page structure.
	// This will be done again by the main application since
	// it owns the property sheet.  It needs o be done here
	// so that the window handle can be removed from the
	// DLLs handle map.
	if( m_fNeedToDetach && m_hWnd )
	{
		HWND hWnd = m_hWnd;
		Detach();
		m_hWnd = hWnd;
	}

	CPropertyPage::OnDestroy();
}

void CTrackFlagsPPG::RefreshData( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_pPPO == NULL )
	{
		EnableControls( FALSE );
		return;
	}

	PPGTrackFlagsParams *pPPGTrackFlagsParams = &m_PPGTrackFlagsParams;
	if( FAILED( m_pPPO->GetData( (void**)&pPPGTrackFlagsParams ) ) )
	{
		EnableControls( FALSE );
		return;
	}

	// Make sure controls have been created
	if( ::IsWindow(m_hWnd) == FALSE )
	{
		return;
	}

	// Prevent control notifications from being dispatched during UpdateData
	_AFX_THREAD_STATE* pThreadState = AfxGetThreadState();
	HWND hWndOldLockout = pThreadState->m_hLockoutNotifyWindow;
	ASSERT(hWndOldLockout != m_hWnd);   // must not recurse
	pThreadState->m_hLockoutNotifyWindow = m_hWnd;

	EnableControls( TRUE );

	// Control Flags
	CheckDlgButton( IDC_CHECK_OVERRIDE_ALL, m_PPGTrackFlagsParams.dwTrackExtrasFlags & DMUS_TRACKCONFIG_OVERRIDE_ALL ? BST_CHECKED : BST_UNCHECKED );
	CheckDlgButton( IDC_CHECK_OVERRIDE_PRIMARY, m_PPGTrackFlagsParams.dwTrackExtrasFlags & DMUS_TRACKCONFIG_OVERRIDE_PRIMARY ? BST_CHECKED : BST_UNCHECKED );
	CheckDlgButton( IDC_CHECK_FALLBACK, m_PPGTrackFlagsParams.dwTrackExtrasFlags & DMUS_TRACKCONFIG_FALLBACK ? BST_CHECKED : BST_UNCHECKED );
	CheckDlgButton( IDC_CHECK_OVERRIDE_PLAY, m_PPGTrackFlagsParams.dwTrackExtrasFlags & DMUS_TRACKCONFIG_CONTROL_PLAY ? BST_CHECKED : BST_UNCHECKED );
	CheckDlgButton( IDC_CHECK_OVERRIDE_NOTIFICATION, m_PPGTrackFlagsParams.dwTrackExtrasFlags & DMUS_TRACKCONFIG_CONTROL_NOTIFICATION ? BST_CHECKED : BST_UNCHECKED );

	// General Flags
	CheckDlgButton( IDC_CHECK_ENABLE_PLAY, m_PPGTrackFlagsParams.dwTrackExtrasFlags & DMUS_TRACKCONFIG_PLAY_ENABLED ? BST_CHECKED : BST_UNCHECKED );
	CheckDlgButton( IDC_CHECK_ENABLE_CONTROL, m_PPGTrackFlagsParams.dwTrackExtrasFlags & DMUS_TRACKCONFIG_CONTROL_ENABLED ? BST_CHECKED : BST_UNCHECKED );
	CheckDlgButton( IDC_CHECK_SEND_NOTIFICATIONS, m_PPGTrackFlagsParams.dwTrackExtrasFlags & DMUS_TRACKCONFIG_NOTIFICATION_ENABLED ? BST_CHECKED : BST_UNCHECKED );
	CheckDlgButton( IDC_CHECK_USE_CLOCKTIME, m_PPGTrackFlagsParams.dwTrackExtrasFlags & DMUS_TRACKCONFIG_PLAY_CLOCKTIME ? BST_CHECKED : BST_UNCHECKED );

	// Ensure only one transition flag is set
	if( m_PPGTrackFlagsParams.dwTrackExtrasFlags & DMUS_TRACKCONFIG_TRANS1_FROMSEGCURRENT )
	{
		m_PPGTrackFlagsParams.dwTrackExtrasFlags &= ~(DMUS_TRACKCONFIG_TRANS1_TOSEGSTART | DMUS_TRACKCONFIG_TRANS1_FROMSEGSTART);
	}
	else if( m_PPGTrackFlagsParams.dwTrackExtrasFlags & DMUS_TRACKCONFIG_TRANS1_FROMSEGSTART )
	{
		m_PPGTrackFlagsParams.dwTrackExtrasFlags &= ~(DMUS_TRACKCONFIG_TRANS1_TOSEGSTART | DMUS_TRACKCONFIG_TRANS1_FROMSEGCURRENT);
	}
	else if( m_PPGTrackFlagsParams.dwTrackExtrasFlags & DMUS_TRACKCONFIG_TRANS1_TOSEGSTART )
	{
		m_PPGTrackFlagsParams.dwTrackExtrasFlags &= ~(DMUS_TRACKCONFIG_TRANS1_FROMSEGSTART | DMUS_TRACKCONFIG_TRANS1_FROMSEGCURRENT);
	}

	// Transition flags
	CheckDlgButton( IDC_CHECK_TRANSITION, (m_PPGTrackFlagsParams.dwTrackExtrasFlags & DMUS_TRACKCONFIG_TRANS_ALL) ? TRUE : FALSE );
	CheckDlgButton( IDC_RADIO_TRANS_TOSEGSTART, m_PPGTrackFlagsParams.dwTrackExtrasFlags & DMUS_TRACKCONFIG_TRANS1_TOSEGSTART ? BST_CHECKED : BST_UNCHECKED );
	CheckDlgButton( IDC_RADIO_TRANS_FROMSEGSTART, m_PPGTrackFlagsParams.dwTrackExtrasFlags & DMUS_TRACKCONFIG_TRANS1_FROMSEGSTART ? BST_CHECKED : BST_UNCHECKED );
	CheckDlgButton( IDC_RADIO_TRANS_FROMSEGCURRENT, m_PPGTrackFlagsParams.dwTrackExtrasFlags & DMUS_TRACKCONFIG_TRANS1_FROMSEGCURRENT ? BST_CHECKED : BST_UNCHECKED );

	// Composing flags
	CheckDlgButton( IDC_CHECK_RECOMPOSE_ON_PLAY, m_PPGTrackFlagsParams.dwTrackExtrasFlags & DMUS_TRACKCONFIG_PLAY_COMPOSE ? BST_CHECKED : BST_UNCHECKED );
	CheckDlgButton( IDC_CHECK_RECOMPOSE_ON_LOOP, m_PPGTrackFlagsParams.dwTrackExtrasFlags & DMUS_TRACKCONFIG_LOOP_COMPOSE ? BST_CHECKED : BST_UNCHECKED );
	//CheckDlgButton( IDC_CHECK_COMPOSING, m_PPGTrackFlagsParams.dwTrackExtrasFlags & DMUS_TRACKCONFIG_COMPOSING ? BST_CHECKED : BST_UNCHECKED );

	// Producer-only Flags
	CheckDlgButton( IDC_CHECK_AUDITION_ONLY, m_PPGTrackFlagsParams.dwProducerOnlyFlags & SEG_PRODUCERONLY_AUDITIONONLY ? BST_CHECKED : BST_UNCHECKED );

	pThreadState->m_hLockoutNotifyWindow = hWndOldLockout;

}

BOOL CTrackFlagsPPG::OnSetActive() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	RefreshData();

	// Store active tab
	if( sm_pnActiveTab && m_pIPropSheet )
	{
		m_pIPropSheet->GetActivePage( sm_pnActiveTab );
	}

	return CPropertyPage::OnSetActive();
}

BOOL CTrackFlagsPPG::OnCommand(WPARAM wParam, LPARAM lParam) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	int nControlID = LOWORD( wParam );
	int nCommandID = HIWORD( wParam );

	if( nCommandID == BN_CLICKED
	||  nCommandID == BN_DOUBLECLICKED )
	{
		switch( nControlID )
		{
		case IDC_CHECK_OVERRIDE_ALL:
			OnCheckHelper( IDC_CHECK_OVERRIDE_ALL, DMUS_TRACKCONFIG_OVERRIDE_ALL );
			return TRUE;
		case IDC_CHECK_OVERRIDE_PRIMARY:
			OnCheckHelper( IDC_CHECK_OVERRIDE_PRIMARY, DMUS_TRACKCONFIG_OVERRIDE_PRIMARY );
			return TRUE;
		case IDC_CHECK_FALLBACK:
			OnCheckHelper( IDC_CHECK_FALLBACK, DMUS_TRACKCONFIG_FALLBACK );
			return TRUE;
		case IDC_CHECK_OVERRIDE_PLAY:
			OnCheckHelper( IDC_CHECK_OVERRIDE_PLAY, DMUS_TRACKCONFIG_CONTROL_PLAY );
			return TRUE;
		case IDC_CHECK_OVERRIDE_NOTIFICATION:
			OnCheckHelper( IDC_CHECK_OVERRIDE_NOTIFICATION, DMUS_TRACKCONFIG_CONTROL_NOTIFICATION );
			return TRUE;

		case IDC_CHECK_ENABLE_PLAY:
			OnCheckHelper( IDC_CHECK_ENABLE_PLAY, DMUS_TRACKCONFIG_PLAY_ENABLED );
			return TRUE;
		case IDC_CHECK_ENABLE_CONTROL:
			OnCheckHelper( IDC_CHECK_ENABLE_CONTROL, DMUS_TRACKCONFIG_CONTROL_ENABLED );
			return TRUE;
		case IDC_CHECK_SEND_NOTIFICATIONS:
			OnCheckHelper( IDC_CHECK_SEND_NOTIFICATIONS, DMUS_TRACKCONFIG_NOTIFICATION_ENABLED );
			return TRUE;

		case IDC_RADIO_TRANS_TOSEGSTART:
			OnTransHelper( IDC_RADIO_TRANS_TOSEGSTART, DMUS_TRACKCONFIG_TRANS1_TOSEGSTART );
			return TRUE;
		case IDC_RADIO_TRANS_FROMSEGSTART:
			OnTransHelper( IDC_RADIO_TRANS_FROMSEGSTART, DMUS_TRACKCONFIG_TRANS1_FROMSEGSTART );
			return TRUE;
		case IDC_RADIO_TRANS_FROMSEGCURRENT:
			OnTransHelper( IDC_RADIO_TRANS_FROMSEGCURRENT, DMUS_TRACKCONFIG_TRANS1_FROMSEGCURRENT );
			return TRUE;

		case IDC_CHECK_USE_CLOCKTIME:
			OnCheckHelper( IDC_CHECK_USE_CLOCKTIME, DMUS_TRACKCONFIG_PLAY_CLOCKTIME );
			return TRUE;
		case IDC_CHECK_RECOMPOSE_ON_PLAY:
			OnCheckHelper( IDC_CHECK_RECOMPOSE_ON_PLAY, DMUS_TRACKCONFIG_PLAY_COMPOSE );
			return TRUE;
		case IDC_CHECK_RECOMPOSE_ON_LOOP:
			OnCheckHelper( IDC_CHECK_RECOMPOSE_ON_LOOP, DMUS_TRACKCONFIG_LOOP_COMPOSE );
			return TRUE;
//		case IDC_CHECK_COMPOSING:
//			OnCheckHelper( IDC_CHECK_COMPOSING, DMUS_TRACKCONFIG_COMPOSING );
//			return TRUE;
		}
	}

	return CPropertyPage::OnCommand( wParam, lParam );
}

void CTrackFlagsPPG::UpdatePPO()
{
	if( m_pPPO )
	{
		m_pPPO->SetData( (void *)&m_PPGTrackFlagsParams );
	}
}

void CTrackFlagsPPG::OnTransHelper( int nButtonID, DWORD dwFlag )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	// Mask out the transition flags
	DWORD dwNewTrackFlags = m_PPGTrackFlagsParams.dwTrackExtrasFlags & ~DMUS_TRACKCONFIG_TRANS_ALL;

	// Set the transition flag
	dwNewTrackFlags |= dwFlag;

	if( m_PPGTrackFlagsParams.dwTrackExtrasFlags != dwNewTrackFlags )
	{
		m_PPGTrackFlagsParams.dwTrackExtrasFlags = dwNewTrackFlags;
		UpdatePPO();
	}
}

void CTrackFlagsPPG::OnCheckHelper( int nButtonID, DWORD dwFlag )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	DWORD dwNewTrackFlags = m_PPGTrackFlagsParams.dwTrackExtrasFlags;

	// If the button is checked
	if( IsDlgButtonChecked( nButtonID ) )
	{
		dwNewTrackFlags |= dwFlag;
	}
	else // The button is unchecked
	{
		dwNewTrackFlags &= ~dwFlag;
	}

	if( m_PPGTrackFlagsParams.dwTrackExtrasFlags != dwNewTrackFlags )
	{
		m_PPGTrackFlagsParams.dwTrackExtrasFlags = dwNewTrackFlags;
		UpdatePPO();
	}
}

void CTrackFlagsPPG::OnCheckAuditionOnly() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	DWORD dwNewProducerOnlyFlags = m_PPGTrackFlagsParams.dwProducerOnlyFlags;

	if( IsDlgButtonChecked( IDC_CHECK_AUDITION_ONLY ) )
	{
		dwNewProducerOnlyFlags |= SEG_PRODUCERONLY_AUDITIONONLY;
	}
	else
	{
		dwNewProducerOnlyFlags &= ~SEG_PRODUCERONLY_AUDITIONONLY;
	}

	if( m_PPGTrackFlagsParams.dwProducerOnlyFlags != dwNewProducerOnlyFlags )
	{
		m_PPGTrackFlagsParams.dwProducerOnlyFlags = dwNewProducerOnlyFlags;
		UpdatePPO();
	}
}

void CTrackFlagsPPG::EnableItem(int nItem, BOOL fEnable)
{
	CWnd* pWnd;
	pWnd = GetDlgItem(nItem);
	if (pWnd)
	{
		pWnd->EnableWindow(fEnable);
	}
}

void CTrackFlagsPPG::OnCheckTransition() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	if( IsDlgButtonChecked( IDC_CHECK_TRANSITION ) )
	{
		if( m_PPGTrackFlagsParams.dwTrackExtrasMask & DMUS_TRACKCONFIG_TRANS1_FROMSEGCURRENT )
		{
			CheckDlgButton( IDC_RADIO_TRANS_FROMSEGCURRENT, BST_CHECKED );
			OnTransHelper( IDC_RADIO_TRANS_FROMSEGCURRENT, DMUS_TRACKCONFIG_TRANS1_FROMSEGCURRENT );
		}
		else if( m_PPGTrackFlagsParams.dwTrackExtrasMask & DMUS_TRACKCONFIG_TRANS1_FROMSEGSTART )
		{
			CheckDlgButton( IDC_RADIO_TRANS_FROMSEGSTART,  BST_CHECKED );
			OnTransHelper( IDC_RADIO_TRANS_FROMSEGSTART, DMUS_TRACKCONFIG_TRANS1_FROMSEGSTART );
		}
		else if( m_PPGTrackFlagsParams.dwTrackExtrasMask & DMUS_TRACKCONFIG_TRANS1_TOSEGSTART )
		{
			CheckDlgButton( IDC_RADIO_TRANS_TOSEGSTART, BST_CHECKED );
			OnTransHelper( IDC_RADIO_TRANS_TOSEGSTART, DMUS_TRACKCONFIG_TRANS1_TOSEGSTART );
		}
	}
	else
	{
		// Mask out the transition flags
		DWORD dwNewTrackFlags = m_PPGTrackFlagsParams.dwTrackExtrasFlags & ~DMUS_TRACKCONFIG_TRANS_ALL;

		// Uncheck the transition buttons
		CheckDlgButton( IDC_RADIO_TRANS_FROMSEGCURRENT, BST_UNCHECKED );
		CheckDlgButton( IDC_RADIO_TRANS_FROMSEGSTART, BST_UNCHECKED );
		CheckDlgButton( IDC_RADIO_TRANS_TOSEGSTART, BST_UNCHECKED );

		if( m_PPGTrackFlagsParams.dwTrackExtrasFlags != dwNewTrackFlags )
		{
			m_PPGTrackFlagsParams.dwTrackExtrasFlags = dwNewTrackFlags;
			UpdatePPO();
		}
	}

	EnableControls( TRUE );
}

void CTrackFlagsPPG::OnDoubleclickedCheckTransition() 
{
	OnCheckTransition();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Shared\xguids.h ===
DEFINE_GUID(CLSID_XDirectMusicSegmentState, 
0xb60adc01, 0x5c97, 0x4ed2, 0xb7, 0xac, 0xcd, 0x6c, 0x68, 0x8b, 0x8a, 0xd9);

DEFINE_GUID(CLSID_XDirectMusicParamControlTrack, 
0xb60adc02, 0x5c97, 0x4ed2, 0xb7, 0xac, 0xcd, 0x6c, 0x68, 0x8b, 0x8a, 0xda);

DEFINE_GUID(CLSID_XDirectMusicLyricsTrack, 
0xb60adc03, 0x5c97, 0x4ed2, 0xb7, 0xac, 0xcd, 0x6c, 0x68, 0x8b, 0x8a, 0xdb);

DEFINE_GUID(CLSID_XDirectMusicSegmentTriggerTrack, 
0xb60adc04, 0x5c97, 0x4ed2, 0xb7, 0xac, 0xcd, 0x6c, 0x68, 0x8b, 0x8a, 0xdc);

DEFINE_GUID(CLSID_XDirectMusicWaveTrack, 
0xb60adc05, 0x5c97, 0x4ed2, 0xb7, 0xac, 0xcd, 0x6c, 0x68, 0x8b, 0x8a, 0xdd);

DEFINE_GUID(CLSID_XDirectMusicMarkerTrack, 
0xb60adc06, 0x5c97, 0x4ed2, 0xb7, 0xac, 0xcd, 0x6c, 0x68, 0x8b, 0x8a, 0xde);

DEFINE_GUID(CLSID_XDirectMusicTimeSigTrack, 
0xb60adc07, 0x5c97, 0x4ed2, 0xb7, 0xac, 0xcd, 0x6c, 0x68, 0x8b, 0x8a, 0xdf);

DEFINE_GUID(CLSID_XDirectMusicTempoTrack, 
0xb60adc08, 0x5c97, 0x4ed2, 0xb7, 0xac, 0xcd, 0x6c, 0x68, 0x8b, 0x8a, 0xd0);

DEFINE_GUID(CLSID_XDirectMusicSysExTrack, 
0xb60adc09, 0x5c97, 0x4ed2, 0xb7, 0xac, 0xcd, 0x6c, 0x68, 0x8b, 0x8a, 0xd1);

DEFINE_GUID(CLSID_XDirectMusicGraph, 
0xb60adc0a, 0x5c97, 0x4ed2, 0xb7, 0xac, 0xcd, 0x6c, 0x68, 0x8b, 0x8a, 0xd2);

DEFINE_GUID(CLSID_XDirectMusicSeqTrack, 
0xb60adc0b, 0x5c97, 0x4ed2, 0xb7, 0xac, 0xcd, 0x6c, 0x68, 0x8b, 0x8a, 0xd3);

DEFINE_GUID(CLSID_XDirectMusicAudioPathConfig, 
0xb60adc0c, 0x5c97, 0x4ed2, 0xb7, 0xac, 0xcd, 0x6c, 0x68, 0x8b, 0x8a, 0xd4);

DEFINE_GUID(CLSID_XDirectMusicSong, 
0xb60adc0d, 0x5c97, 0x4ed2, 0xb7, 0xac, 0xcd, 0x6c, 0x68, 0x8b, 0x8a, 0xd5);

DEFINE_GUID(CLSID_XDirectMusicSegment, 
0xb60adc0e, 0x5c97, 0x4ed2, 0xb7, 0xac, 0xcd, 0x6c, 0x68, 0x8b, 0x8a, 0xd6);

DEFINE_GUID(CLSID_XDirectMusicPerformance, 
0xb60adc0f, 0x5c97, 0x4ed2, 0xb7, 0xac, 0xcd, 0x6c, 0x68, 0x8b, 0x8a, 0xd7);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Shared\UnknownChunk.h ===
// ===========================================================
// UnknownDLSChunk.h
// ===========================================================
#ifndef __UNKDLSCHUNK_H__
#define __UNKDLSCHUNK_H__

#include "RiffStrm.h"
#include "alist.h"

//NOTE: Keeping 2 classes to follow the model for AList and AListItem.
//  as in CCollectionInstruments and CInstruments
class CUnknownChunkItem;

class CUnknownChunk: public AList
{
public:
    CUnknownChunk();
	~CUnknownChunk();

    // IUnknown functions
    HRESULT STDMETHODCALLTYPE QueryInterface( REFIID riid, LPVOID *ppv );
    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();

    //	AList overrides
    CUnknownChunkItem *GetHead();
    CUnknownChunkItem *RemoveHead();

	void Remove(CUnknownChunkItem *pChunk);
	void AddTail(CUnknownChunkItem *pChunk);

    // Additional functions
	HRESULT Load(IDMUSProdRIFFStream* pIRiffStream, MMCKINFO* pckMain, BOOL bIsListType);
    HRESULT Save(IDMUSProdRIFFStream* pIRiffStream);
    
// member variables
private:
    DWORD	  m_dwRef;
};


class CUnknownChunkItem : public AListItem
{
friend class CUnknownChunk;
public:
	
	DWORD Size();
    CUnknownChunkItem();
	~CUnknownChunkItem();
    
	// IUnknown functions
    HRESULT STDMETHODCALLTYPE QueryInterface( REFIID riid, LPVOID *ppv );
    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();

    // Additional methods
    HRESULT Load( IDMUSProdRIFFStream* pIRiffStream, MMCKINFO* pckMain );
    HRESULT Save(IDMUSProdRIFFStream* pIRiffStream);

	HRESULT Write(void* pv, DWORD* pdwCurOffset, DWORD dwIndexNextExtChk);

	
private:
	DWORD GetChunkSize(IDMUSProdRIFFStream* pIRiffStream, MMCKINFO* pckMain); // Descends through the subchunks and reports the size

// member variables
private:
    DWORD       m_dwRef;
    MMCKINFO    m_ck;
    BYTE *      m_pData;
    int         m_ListCount; 
    BOOL        m_bIsListItem;  // if true this is a list entry 

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\Shared\Unknownchunk.cpp ===
// =======================================================================
// UnkDLSChunk.cpp
// =======================================================================
#include "stdafx.h"

#include "UnknownChunk.h"
#include "alist.h"


// ========================================================================
// CUnknownChunk implementation
// ========================================================================

//constructor/desctructor

CUnknownChunk::CUnknownChunk()
{
    m_dwRef = 0;
    AddRef();
}

CUnknownChunk::~CUnknownChunk()
{
	while(!IsEmpty())
	{
        CUnknownChunkItem *pItem = RemoveHead();
        pItem->Release();
	}
}

// ===============================================================
// Alist implementation
// ===============================================================

void CUnknownChunk::AddTail(CUnknownChunkItem *pINode)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT(pINode);

	AList::AddTail((AListItem *) pINode);
}

CUnknownChunkItem *CUnknownChunk::GetHead() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	
	return (CUnknownChunkItem *) AList::GetHead();
}

CUnknownChunkItem *CUnknownChunk::RemoveHead() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	
	return (CUnknownChunkItem *) AList::RemoveHead();
}

void CUnknownChunk::Remove(CUnknownChunkItem *pChunk) 
{ 
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	
	ASSERT(pChunk);
	
	AList::Remove((AListItem *) pChunk);
}

// =============================================================================
// CUnknownChunk IUnknown implementation
// =============================================================================
HRESULT CUnknownChunk::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
    AFX_MANAGE_STATE(_afxModuleAddrThis);
	
	if( ::IsEqualIID(riid, IID_IUnknown))
    {
        AddRef();
        *ppvObj = this;
        return S_OK;
    }

    *ppvObj = NULL;
    return E_NOINTERFACE;
}

ULONG CUnknownChunk::AddRef()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	
	AfxOleLockApp();
    return ++m_dwRef;
}

ULONG CUnknownChunk::Release()
{
    AFX_MANAGE_STATE(_afxModuleAddrThis);
	
	ASSERT( m_dwRef != 0 );

	AfxOleUnlockApp();
    --m_dwRef;

    if( m_dwRef == 0 )
    {
        delete this;
        return 0;
    }

    return m_dwRef;
}




// ===================================================================================
// CUnknownChunk::Load
// ===================================================================================
HRESULT CUnknownChunk::Load(IDMUSProdRIFFStream* pIRiffStream, MMCKINFO* pckMain, BOOL bIsListType)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
    
    ASSERT(pIRiffStream);
    ASSERT(pckMain);

    HRESULT			hr = S_OK;
         
    CUnknownChunkItem * pItem = new CUnknownChunkItem;
    pItem->m_bIsListItem = bIsListType;
    hr = pItem->Load(pIRiffStream, pckMain);
    if (SUCCEEDED(hr))
    {
        AddTail(pItem);
    }

    return hr;
}


HRESULT CUnknownChunk::Save(IDMUSProdRIFFStream* pIRiffStream)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
    
    ASSERT(pIRiffStream);

    HRESULT			hr = S_OK;

    // go through the items and call save on it.
    CUnknownChunkItem * pItem = GetHead();
    for (int i = 0; pItem && i < pItem->GetCount(); i++)
    {
        pItem = (CUnknownChunkItem *)pItem->GetItem(i);
        pItem->Save(pIRiffStream);
    }

    return hr;

}


// ========================================================================
// CUnknownChunkItem implementation
// ========================================================================
CUnknownChunkItem::CUnknownChunkItem()
{
    m_pData = NULL;

    m_bIsListItem = FALSE;

    m_dwRef = 0;
    AddRef();
}

CUnknownChunkItem::~CUnknownChunkItem()
{
    if (m_pData)
        delete [] m_pData;

    ASSERT(m_dwRef == 0);
}


HRESULT CUnknownChunkItem::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
    AFX_MANAGE_STATE(_afxModuleAddrThis);
	
	if( ::IsEqualIID(riid, IID_IUnknown))
    {
        AddRef();
        *ppvObj = this;
        return S_OK;
    }

    *ppvObj = NULL;
    return E_NOINTERFACE;
}

ULONG CUnknownChunkItem::AddRef()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	AfxOleLockApp();
    return ++m_dwRef;
}

ULONG CUnknownChunkItem::Release()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    ASSERT( m_dwRef != 0 );

	AfxOleUnlockApp();
    --m_dwRef;

    if( m_dwRef == 0 )
    {
        delete this;
        return 0;
    }

    return m_dwRef;
}

// ========================================================================
// Additional methods
// ========================================================================
HRESULT CUnknownChunkItem::Load( IDMUSProdRIFFStream* pIRiffStream, MMCKINFO* pckMain )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    ASSERT(pIRiffStream);
    ASSERT(pckMain);

    HRESULT	hr = S_OK;
    DWORD cb = 0;

    IStream* pIStream = pIRiffStream->GetStream();
    ASSERT( pIStream != NULL );
    if(pIStream == NULL)
    {
        return E_OUTOFMEMORY;
    }
        
	// If this is a LIST chunk, descend down this unknown chunk 
	// and find out the actual size of the chunk by adding the 
	// sizes of the subchunks. This is required as we might be 
	// dealing with corrupt RIFF files....
	DWORD dwRealChunkSize = pckMain->cksize;
	if(pckMain->ckid == FOURCC_LIST)
    {
        DWORD dwStreamPosition = StreamTell(pIStream);
		dwRealChunkSize = GetChunkSize(pIRiffStream, pckMain);
        StreamSeek(pIStream, dwStreamPosition, STREAM_SEEK_SET );
    }

    // remember what the chunk has.
    memcpy((void *)&m_ck, pckMain, sizeof(MMCKINFO));
	m_ck.cksize = dwRealChunkSize;

    // Read the data into m_pData.
    m_pData = new BYTE[m_ck.cksize];

    if (m_pData)
    {
	    hr = pIStream->Read( m_pData, m_ck.cksize, &cb );
        // even if this fails the code below will release the stream.
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }
    // if fails we do nothing & return;

	pIStream->Release();
    return hr;
}

DWORD CUnknownChunkItem::GetChunkSize(IDMUSProdRIFFStream* pIRiffStream, MMCKINFO* pckMain)
{
	DWORD dwTallySize = pckMain->cksize;
	DWORD dwSubChunkSize = 0;
	
	MMCKINFO ck;
	ck.ckid = 0;
	ck.fccType = 0;
	ck.cksize = 0;

	while(pIRiffStream->Descend(&ck, pckMain, 0) == 0)
	{
		if(dwSubChunkSize + ck.cksize <= dwTallySize)
		{
			// Add the sizes for the header and the size fields
			dwSubChunkSize += 2 * sizeof(DWORD);
			dwSubChunkSize += ck.cksize;
			pIRiffStream->Ascend(&ck, 0);
		}
		else
			break;

		ck.ckid = 0;
		ck.fccType = 0;
	}

	LARGE_INTEGER   dlibSeekTo;
	dlibSeekTo.HighPart = 0;
	dlibSeekTo.LowPart = ck.dwDataOffset - (dwSubChunkSize + 2 * sizeof(DWORD));
	IStream* pIStream = pIRiffStream->GetStream();
	ASSERT(pIStream != NULL);
	pIStream->Seek(dlibSeekTo, SEEK_SET, NULL);
	pIStream->Release();

	return dwSubChunkSize;
}


HRESULT CUnknownChunkItem::Save(IDMUSProdRIFFStream* pIRiffStream)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
    
    ASSERT(pIRiffStream);

    MMCKINFO ck;
    DWORD cb = 0;
    HRESULT hr = S_OK;
    IStream* pIStream = pIRiffStream->GetStream();
    ASSERT( pIStream);

    // write out the chunk.
    ck.ckid = m_ck.ckid;
    ck.fccType = m_ck.fccType;   

    if (m_bIsListItem == FALSE)
    {
        hr = pIRiffStream->CreateChunk(&ck, 0);
    }
    else    // it's a list item
    {
        // Just create the list chunk and return. The createchunk sets
        // up the dwoffset in the ck that the chunk is to be written at.
        hr = pIRiffStream->CreateChunk(&ck, MMIO_CREATELIST);
    }

    if (FAILED(hr))
    {
		pIStream->Release();
        return (hr);
    }

    // write the data
    hr = pIStream->Write((LPSTR) m_pData,m_ck.cksize, &cb);	
	pIStream->Release();
    
	if (FAILED(hr) || cb != m_ck.cksize)
    {
		pIStream->Release();
        return hr;
    }

    if (FAILED(pIRiffStream->Ascend(&ck, 0)))
    {
		pIStream->Release();
	    return (E_FAIL);
    }
	return hr;
}

HRESULT CUnknownChunkItem::Write(void * pv, DWORD * pdwCurOffset, DWORD dwIndexNextExtChk)
{
	return S_OK;
}

DWORD CUnknownChunkItem::Size()
{
	return 0;//m_ck.cksize;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SignPostStripMgr\ContextMenuHandler.cpp ===
// ContextMenuHandler.cpp : implementation file
//

#include "stdafx.h"
#include "SignPostStripMgr.h"
#include "ContextMenuHandler.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CContextMenuHandler

CContextMenuHandler::CContextMenuHandler()
{
	m_pStrip = NULL;
}

CContextMenuHandler::~CContextMenuHandler()
{
}


BEGIN_MESSAGE_MAP(CContextMenuHandler, CWnd)
	//{{AFX_MSG_MAP(CContextMenuHandler)
		// NOTE - the ClassWizard will add and remove mapping macros here.
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CContextMenuHandler message handlers

BOOL CContextMenuHandler::OnCommand(WPARAM wParam, LPARAM lParam) 
{
	HRESULT hr = S_FALSE;

	if(m_pStrip != NULL)
	{
		hr = m_pStrip->OnWMMessage(WM_COMMAND, wParam, lParam);
	}
	
	if(hr == S_OK)
	{
		return TRUE;
	}

	return CWnd::OnCommand(wParam, lParam);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SignPostStripMgr\GroupBitsPPG.h ===
#if !defined(AFX_GROUPBITSPPG_H__9D655C64_CE44_11D1_88BC_00C04FBF8D15__INCLUDED_)
#define AFX_GROUPBITSPPG_H__9D655C64_CE44_11D1_88BC_00C04FBF8D15__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include <staticproppagemanager.h>
#include "resource.h"

typedef struct 
{
	DWORD	dwPageIndex;
	DWORD	dwGroupBits;
} ioGroupBitsPPGData;

// GroupBitsPPG.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CGroupBitsPPG dialog

class CGroupBitsPPG : public CPropertyPage
{
	DECLARE_DYNCREATE(CGroupBitsPPG)

// Construction
public:
	CGroupBitsPPG();
	~CGroupBitsPPG();

// Dialog Data
	//{{AFX_DATA(CGroupBitsPPG)
	enum { IDD = IDD_PROPPAGE_SIGNPOST_GROUP };
	CComboBox	m_GroupDropDownList;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CGroupBitsPPG)
	public:
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CGroupBitsPPG)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnDestroy();
	afx_msg void OnSelchangeComboGroupList();
	afx_msg LRESULT OnApp(WPARAM, LPARAM);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

protected:
	void EnableControls( BOOL fEnable );
	void UpdatePPO();

public:
	void SetObject( IDMUSProdPropPageObject* pPPO );
	void RefreshData( void );

	// Variables for keeping track of the active property tab
	static short*				sm_pnActiveTab;
	IDMUSProdPropSheet*			m_pIPropSheet;

protected:
	IDMUSProdPropPageObject*	m_pPPO;
	ioGroupBitsPPGData			m_PPGTrackParams;
	BOOL						m_fNeedToDetach;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_GROUPBITSPPG_H__9D655C64_CE44_11D1_88BC_00C04FBF8D15__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SignPostStripMgr\GroupBitsPPG.cpp ===
// GroupBitsPPG.cpp : implementation file
//

#include "stdafx.h"
#include "GroupBitsPPG.h"
#include "TrackFlagsPPG.h"
#include "SegmentIO.h"
#include <dmusici.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


short *CGroupBitsPPG::sm_pnActiveTab = NULL;

/////////////////////////////////////////////////////////////////////////////
// CGroupBitsPPG property page

IMPLEMENT_DYNCREATE(CGroupBitsPPG, CPropertyPage)

CGroupBitsPPG::CGroupBitsPPG() : CPropertyPage(CGroupBitsPPG::IDD)
{
	//{{AFX_DATA_INIT(CGroupBitsPPG)
	//}}AFX_DATA_INIT
	m_pPPO = NULL;
	m_PPGTrackParams.dwPageIndex = 0;
	m_PPGTrackParams.dwGroupBits = 0;
	m_fNeedToDetach = FALSE;
}

CGroupBitsPPG::~CGroupBitsPPG()
{
	if( m_pPPO )
	{
		m_pPPO->Release();
		m_pPPO = NULL;
	}
}

void CGroupBitsPPG::DoDataExchange(CDataExchange* pDX)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CGroupBitsPPG)
	DDX_Control(pDX, IDC_COMBO_GROUP_LIST, m_GroupDropDownList);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CGroupBitsPPG, CPropertyPage)
	//{{AFX_MSG_MAP(CGroupBitsPPG)
	ON_WM_CREATE()
	ON_WM_DESTROY()
	ON_CBN_SELCHANGE(IDC_COMBO_GROUP_LIST, OnSelchangeComboGroupList)
	ON_MESSAGE( WM_APP, OnApp )
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

// private functions
void CGroupBitsPPG::SetObject( IDMUSProdPropPageObject* pPPO )
{
	if( m_pPPO )
	{
		m_pPPO->Release();
	}
	m_pPPO = pPPO;
	if( m_pPPO )
	{
		m_pPPO->AddRef();
	}
}

void CGroupBitsPPG::EnableControls( BOOL fEnable ) 
{
	if( ::IsWindow(m_hWnd) == FALSE )
	{
		return;
	}

	if(::IsWindow(m_GroupDropDownList.m_hWnd))
	{
		m_GroupDropDownList.EnableWindow(fEnable);
	}
}

/////////////////////////////////////////////////////////////////////////////
// CGroupBitsPPG message handlers

int CGroupBitsPPG::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Attach the window to the property page structure.
	// This has been done once already in the main application
	// since the main application owns the property sheet.
	// It needs to be done here so that the window handle can
	// be found in the DLLs handle map.
	if( !FromHandlePermanent( m_hWnd ) )
	{
		HWND hWnd = m_hWnd;
		m_hWnd = NULL;
		Attach( hWnd );
		m_fNeedToDetach = TRUE;
	}

	if (CPropertyPage::OnCreate(lpCreateStruct) == -1)
		return -1;
	
	return 0;
}

void CGroupBitsPPG::OnDestroy() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Detach the window from the property page structure.
	// This will be done again by the main application since
	// it owns the property sheet.  It needs o be done here
	// so that the window handle can be removed from the
	// DLLs handle map.
	if( m_fNeedToDetach && m_hWnd )
	{
		HWND hWnd = m_hWnd;
		Detach();
		m_hWnd = hWnd;
	}

	CPropertyPage::OnDestroy();
}

void CGroupBitsPPG::RefreshData( void )
{
	int iIndex;
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_pPPO == NULL )
	{
		EnableControls( FALSE );
		return;
	}

	ioGroupBitsPPGData *pioGroupBitsPPGData = &m_PPGTrackParams;
	if( FAILED( m_pPPO->GetData( (void**)&pioGroupBitsPPGData ) ) )
	{
		EnableControls( FALSE );
		return;
	}

	// Make sure controls have been created
	if( ::IsWindow(m_hWnd) == FALSE )
	{
		return;
	}

	// Prevent control notifications from being dispatched during UpdateData
	_AFX_THREAD_STATE* pThreadState = AfxGetThreadState();
	HWND hWndOldLockout = pThreadState->m_hLockoutNotifyWindow;
	ASSERT(hWndOldLockout != m_hWnd);   // must not recurse
	pThreadState->m_hLockoutNotifyWindow = m_hWnd;

	EnableControls( TRUE );

	// Group Bits combo box
	if (!m_PPGTrackParams.dwGroupBits)
	{
		m_PPGTrackParams.dwGroupBits = 1;
	}
	for (iIndex = 0; iIndex < 32; iIndex++)
	{
		if (m_PPGTrackParams.dwGroupBits & (1 << iIndex) )
			break;
	}
	m_GroupDropDownList.SetCurSel(iIndex);

	pThreadState->m_hLockoutNotifyWindow = hWndOldLockout;

}

BOOL CGroupBitsPPG::OnSetActive() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	RefreshData();

	// Store active tab
	if( sm_pnActiveTab && m_pIPropSheet )
	{
		m_pIPropSheet->GetActivePage( sm_pnActiveTab );
	}

	return CPropertyPage::OnSetActive();
}

void CGroupBitsPPG::UpdatePPO()
{
	if( m_pPPO )
	{
		VERIFY( SUCCEEDED( m_pPPO->SetData(&m_PPGTrackParams) ) );
	}
}

void CGroupBitsPPG::OnSelchangeComboGroupList() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	PostMessage( WM_APP, 0, 0 );
}

LRESULT CGroupBitsPPG::OnApp(WPARAM, LPARAM)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	// Custom handler for OnSelChanged to work-around bug in user32.dll
	int iIndex = m_GroupDropDownList.GetCurSel();

	if (iIndex >= 0 && iIndex < 32)
	{
		m_PPGTrackParams.dwGroupBits = (1 << iIndex);
	}
	else
	{
		ASSERT(FALSE);
		return 0;
	}

	UpdatePPO();
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SignPostStripMgr\Resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by SignPostStripMgr.rc
//
#define IDS_PROJNAME                    100
#define IDS_PROPPAGE_SIGNPOST           101
#define IDR_SIGNPOSTMGR                 102
#define IDS_PROPPAGE_GROUP_BITS         107
#define IDR_SIGNPOSTSTRIP_RMENU         201
#define IDC_SIGNPOSTCOMBO               201
#define IDC_BUTTON1                     202
#define IDC_SIGNPOST_INSERT             202
#define IDC_SIGNPOSTLIST                203
#define IDC_SIGNPOST_LIST               203
#define IDB_COMPOSE                     204
#define IDD_PROPPAGE_AUDITION           205
#define IDC_SIGNPOST_CADENCE            208
#define IDD_PROPPAGE_SIGNPOSTS          209
#define IDD_PROPPAGE_SIGNPOSTS1         210
#define IDC_COMBO_SIGNPOST              210
#define IDI_DRAGICON                    210
#define IDD_PROPPAGE_SIGNPOST_GROUP     217
#define IDC_ACTIVITYLEVEL               222
#define IDC_COMBO_GROUP_LIST            231
#define IDM_DRAG_RMENU                  243
#define IDC_SP1                         250
#define IDC_SPA                         251
#define IDC_SPB                         252
#define IDC_SPC                         253
#define IDC_SPD                         254
#define IDC_SPE                         255
#define IDC_SPF                         256
#define IDC_NOSIGNPOST                  257
#define IDC_CADENCE                     258
#define ID_VIEW_PROPERTIES              32768
#define ID_EDIT_DELETE                  32771
#define ID_EDIT_INSERT                  32772
#define IDM_DRAG_MOVE                   32806
#define IDM_DRAG_CANCEL                 32807
#define IDM_DRAG_COPY                   32808
#define IDS_FUNCTIONBAR_TEXT            57638
#define IDS_EDITOR_NAME                 57643
#define IDS_TRACK_NAME                  57644
#define IDS_CANT_COMPOSE                57645
#define IDS_ERR_COMPOSE_WHILE_PLAYING   57645
#define IDS_COMPOSE_FAILED              57646
#define IDS_ERR_COMPOSE_NOSTYLE_CHORDMAP 57646
#define IDS_ERR_COMPOSE_UNEXPECTED      57647
#define IDS_ERR_COMPOSE_NOCHORDS        57648
#define IDS_PASTE                       57649
#define IDS_DELETE                      57650
#define IDS_INSERT                      57651
#define IDS_ERR_COMPOSE_DX8_REQUIRED    57652
#define IDS_UNDO_PASTE                  57712
#define IDS_UNDO_DELETE                 57713
#define IDS_UNDO_INSERT                 57714
#define IDS_UNDO_CHANGE                 57715
#define IDS_UNDO_TRACK_GROUP            57716
#define IDS_UNDO_MOVE                   57717
#define IDS_UNDO_TRACKEXTRAS            57718
#define IDS_UNDO_PRODUCERONLY           57719
#define IDS_UNDO_ACTIVITYLEVEL          57720

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        207
#define _APS_NEXT_COMMAND_VALUE         32781
#define _APS_NEXT_CONTROL_VALUE         213
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SignPostStripMgr\SignPostIO.h ===
#ifndef __SIGNPOSTIOH_
#define __SIGNPOSTIOH_

typedef struct SignPostExt
{
    SignPostExt	*pNext;
    long		lTime;		// Time, in clocks
    short		nMeasure;	// Which measure
    DWORD		dwSignPost;	// SignPost type
	DWORD		dwDragDrop;
} SignPostExt;

typedef struct SignPostMeasureInfo
{
	SignPostExt	*pSignPost;	// The signpost in this measure.
	DWORD		dwFlags;	// Currently, just whether the measure is selected.
} SignPostMeasureInfo;

typedef struct ioSignPost
{
    long	lTime;		// Time, in clocks.
    DWORD	dwSignPost;	// SignPost type.
} ioSignPost;

typedef struct PPGSignPost
{
	long			lMeasure;
	DWORD			dwValid;
	DWORD			dwSignPost;
} PPGSignPost;

#define SP_A        0x1
#define SP_B        0x2
#define SP_C        0x4
#define SP_D        0x8
#define SP_E        0x10
#define SP_F        0x20
#define SP_LETTER   (SP_A | SP_B | SP_C | SP_D | SP_E | SP_F)
#define SP_1        0x100
#define SP_2        0x200
#define SP_3        0x400
#define SP_4        0x800
#define SP_5        0x1000
#define SP_6        0x2000
#define SP_7        0x4000
#define SP_ROOT     (SP_1 | SP_2 | SP_3 | SP_4 | SP_5 | SP_6 | SP_7)
#define SP_CADENCE  0x8000

#define VALID_SIGNPOST	0x1
#define VALID_CADENCE	0x2

#define SPMI_SELECTED	0x1 // The measure is selected.
#define DRAG_SELECT		0x2 // Measure selected as part of a drag/drop


#define MEASURE_MASK	0x0FFFF000	// position of measure info in dwCommand for persisted commands


long __inline GetMeasureFromSignPost(DWORD dwDragDrop)
{
	long m = long(dwDragDrop) & MEASURE_MASK;
	m = (m >> 12) & 0xFFFF;
	return m;
}

void __inline SetMeasureInSignPost(DWORD& dwDragDrop, long lMeasure)
{
	lMeasure = (lMeasure << 12) & MEASURE_MASK;
	dwDragDrop &= ~MEASURE_MASK;  // clear any previous value
	dwDragDrop |= lMeasure;
}




#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SignPostStripMgr\SignPostPPG.cpp ===
// SignPostPPG.cpp : Implementation of signpost property page.
//

#include "stdafx.h"
#include "SignPostStripMgr.h"
#include "SignPostPPG.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CSignPostPPG property page

IMPLEMENT_DYNCREATE(CSignPostPPG, CPropertyPage)

CSignPostPPG::CSignPostPPG() : CPropertyPage(CSignPostPPG::IDD)
{
	m_pPageManager = NULL;
	m_pSignPostData = NULL;
	//{{AFX_DATA_INIT(CSignPostPPG)
	//}}AFX_DATA_INIT
}

CSignPostPPG::~CSignPostPPG()
{
	if(m_pSignPostData != NULL)
	{
		delete m_pSignPostData;
	}
}

void CSignPostPPG::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CSignPostPPG)
	DDX_Control(pDX, IDC_COMBO_SIGNPOST, m_SignPostDropDownList);
	DDX_Control(pDX, IDC_SIGNPOST_CADENCE, m_CadenceCheck);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CSignPostPPG, CPropertyPage)
	//{{AFX_MSG_MAP(CSignPostPPG)
	ON_BN_CLICKED(IDC_SIGNPOST_CADENCE, OnSignpostCadence)
	ON_CBN_SELCHANGE(IDC_COMBO_SIGNPOST, OnSelchangeComboSignpost)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CSignPostPPG message handlers

void CSignPostPPG::OnSignpostCadence() 
{
	HRESULT hr;

	ASSERT(m_pSignPostData != NULL);
	if(m_pSignPostData == NULL)
	{
		return;
	}

	// Find out what the current state of the button is
	if(m_CadenceCheck.GetButtonStyle() == BS_AUTO3STATE)
	{
		// Now set the checkbox to be only 2-state
		m_CadenceCheck.SetButtonStyle(BS_AUTOCHECKBOX, FALSE);
		m_CadenceCheck.SetCheck(0);
		m_pSignPostData->dwSignPost &= ~SP_CADENCE;
		m_pSignPostData->dwValid |= VALID_CADENCE;
	}
	else
	{
		ASSERT(m_pSignPostData->dwValid & VALID_CADENCE);
		if(m_pSignPostData->dwSignPost & SP_CADENCE)
		{
			m_pSignPostData->dwSignPost &= ~SP_CADENCE;
			ASSERT(m_CadenceCheck.GetCheck() == 0);
		}
		else if(m_pSignPostData->dwSignPost)
		{
			m_pSignPostData->dwSignPost |= SP_CADENCE;
			ASSERT(m_CadenceCheck.GetCheck() == 1);
		}
	}

	if(m_pPageManager != NULL)
	{
		hr = m_pPageManager->m_pIPropPageObject->SetData(m_pSignPostData);
		ASSERT(SUCCEEDED(hr));
		if(S_FALSE == hr)
		{
			// The new data was rejected!
			PPGSignPost *pSignPost;

			hr = m_pPageManager->m_pIPropPageObject->GetData((void **) &pSignPost);
			ASSERT(SUCCEEDED(hr));
			hr = SetData(pSignPost);
			ASSERT(SUCCEEDED(hr));
		}
	}	
}

BOOL CSignPostPPG::OnInitDialog() 
{
	CPropertyPage::OnInitDialog();

	// Fill the dropdown box.

	m_SignPostDropDownList.AddString("None");
	m_SignPostDropDownList.AddString("1");
	m_SignPostDropDownList.AddString("2");
	m_SignPostDropDownList.AddString("3");
	m_SignPostDropDownList.AddString("4");
	m_SignPostDropDownList.AddString("5");
	m_SignPostDropDownList.AddString("6");
	m_SignPostDropDownList.AddString("7");
	m_SignPostDropDownList.AddString("A");
	m_SignPostDropDownList.AddString("B");
	m_SignPostDropDownList.AddString("C");
	m_SignPostDropDownList.AddString("D");
	m_SignPostDropDownList.AddString("E");
	m_SignPostDropDownList.AddString("F");


	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

BOOL CSignPostPPG::OnSetActive() 
{
	// Set the controls in case they have changed since this was last activated
	// and RefreshData has not yet been called.
	SetData(m_pSignPostData);

	return CPropertyPage::OnSetActive();
}

/////////////////////////////////////////////////////////////////////////////
// CSignPostPPG additional functions

HRESULT CSignPostPPG::SetData(PPGSignPost *pSignPost)
{
	if(pSignPost == NULL)
	{
		// Disable the property page.
		if(IsWindow(m_SignPostDropDownList.m_hWnd))
		{
			m_SignPostDropDownList.EnableWindow(FALSE);
		}
		if(IsWindow(m_CadenceCheck.m_hWnd))
		{
			m_CadenceCheck.EnableWindow(FALSE);
		}
		return S_OK;
	}
	if(m_pSignPostData == NULL)
	{
		m_pSignPostData = new PPGSignPost;
		if(m_pSignPostData == NULL)
		{
			return E_OUTOFMEMORY;
		}
	}
	if(IsWindow(m_SignPostDropDownList.m_hWnd))
	{
		m_SignPostDropDownList.EnableWindow(TRUE);
	}
	if(IsWindow(m_CadenceCheck.m_hWnd))
	{
		m_CadenceCheck.EnableWindow(TRUE);
	}

	if(pSignPost != m_pSignPostData)
	{
		memcpy(m_pSignPostData, pSignPost, sizeof(PPGSignPost));
	}

	if(!(m_pSignPostData->dwValid & VALID_SIGNPOST))
	{
		// If we don't have a valid signpost, just don't select anything
		m_SignPostDropDownList.SetCurSel(-1);
	}
	else
	{
		// Otherwise go select the appropriate value in the listbox.
		int iIndex = -1;

		if(m_pSignPostData->dwSignPost & SP_ROOT)
		{
			switch(m_pSignPostData->dwSignPost & SP_ROOT)
			{
			case SP_1:
				iIndex = m_SignPostDropDownList.FindStringExact(-1, "1");
				break;
			case SP_2:
				iIndex = m_SignPostDropDownList.FindStringExact(-1, "2");
				break;
			case SP_3:
				iIndex = m_SignPostDropDownList.FindStringExact(-1, "3");
				break;
			case SP_4:
				iIndex = m_SignPostDropDownList.FindStringExact(-1, "4");
				break;
			case SP_5:
				iIndex = m_SignPostDropDownList.FindStringExact(-1, "5");
				break;
			case SP_6:
				iIndex = m_SignPostDropDownList.FindStringExact(-1, "6");
				break;
			case SP_7:
				iIndex = m_SignPostDropDownList.FindStringExact(-1, "7");
				break;
			default:
				return E_INVALIDARG;
				break;
			}
			ASSERT(iIndex > -1);
			m_SignPostDropDownList.SetCurSel(iIndex);
		}
		else if(m_pSignPostData->dwSignPost & SP_LETTER)
		{
			switch(m_pSignPostData->dwSignPost & SP_LETTER)
			{
			case SP_A:
				iIndex = m_SignPostDropDownList.FindStringExact(-1, "A");
				break;
			case SP_B:
				iIndex = m_SignPostDropDownList.FindStringExact(-1, "B");
				break;
			case SP_C:
				iIndex = m_SignPostDropDownList.FindStringExact(-1, "C");
				break;
			case SP_D:
				iIndex = m_SignPostDropDownList.FindStringExact(-1, "D");
				break;
			case SP_E:
				iIndex = m_SignPostDropDownList.FindStringExact(-1, "E");
				break;
			case SP_F:
				iIndex = m_SignPostDropDownList.FindStringExact(-1, "F");
				break;
			default:
				return E_INVALIDARG;
				break;
			}
			ASSERT(iIndex > -1);
			m_SignPostDropDownList.SetCurSel(iIndex);
		}
		else if(m_pSignPostData->dwSignPost == 0)
		{
			iIndex = m_SignPostDropDownList.FindStringExact(-1, "None");
			ASSERT(iIndex > -1);
			m_SignPostDropDownList.SetCurSel(iIndex);
			if(IsWindow(m_CadenceCheck.m_hWnd))
			{
				m_CadenceCheck.EnableWindow(FALSE);
			}
		}
		else
		{
			return E_INVALIDARG;
		}
	}
	if(!(m_pSignPostData->dwValid & VALID_CADENCE))
	{
		m_CadenceCheck.SetButtonStyle(BS_AUTO3STATE, FALSE);
		m_CadenceCheck.SetCheck(2);
	}
	else
	{
		m_CadenceCheck.SetCheck((m_pSignPostData->dwSignPost & SP_CADENCE) ? 1 : 0);
		m_CadenceCheck.SetButtonStyle(BS_AUTOCHECKBOX, FALSE);
	}

	return S_OK;
}


void CSignPostPPG::OnSelchangeComboSignpost() 
{
	ASSERT(m_pSignPostData != NULL);
	if(m_pSignPostData == NULL)
	{
		return;
	}
	
	HRESULT	hr;
	CString	strSignPost;
	int		iIndex;

	iIndex = m_SignPostDropDownList.GetCurSel();
	ASSERT(iIndex >= 0);

	m_SignPostDropDownList.GetLBText(iIndex, strSignPost);
	ASSERT(strSignPost.GetLength() > 0);
	
	// Set the signpost.
	if(strSignPost == "1")
	{
		m_pSignPostData->dwSignPost = ((m_pSignPostData->dwSignPost & SP_CADENCE) | SP_1);
	}
	else if(strSignPost == "2")
	{
		m_pSignPostData->dwSignPost = ((m_pSignPostData->dwSignPost & SP_CADENCE) | SP_2);
	}
	else if(strSignPost == "3")
	{
		m_pSignPostData->dwSignPost = ((m_pSignPostData->dwSignPost & SP_CADENCE) | SP_3);
	}
	else if(strSignPost == "4")
	{
		m_pSignPostData->dwSignPost = ((m_pSignPostData->dwSignPost & SP_CADENCE) | SP_4);
	}
	else if(strSignPost == "5")
	{
		m_pSignPostData->dwSignPost = ((m_pSignPostData->dwSignPost & SP_CADENCE) | SP_5);
	}
	else if(strSignPost == "6")
	{
		m_pSignPostData->dwSignPost = ((m_pSignPostData->dwSignPost & SP_CADENCE) | SP_6);
	}
	else if(strSignPost == "7")
	{
		m_pSignPostData->dwSignPost = ((m_pSignPostData->dwSignPost & SP_CADENCE) | SP_7);
	}
	else if(strSignPost == "A")
	{
		m_pSignPostData->dwSignPost = ((m_pSignPostData->dwSignPost & SP_CADENCE) | SP_A);
	}
	else if(strSignPost == "B")
	{
		m_pSignPostData->dwSignPost = ((m_pSignPostData->dwSignPost & SP_CADENCE) | SP_B);
	}
	else if(strSignPost == "C")
	{
		m_pSignPostData->dwSignPost = ((m_pSignPostData->dwSignPost & SP_CADENCE) | SP_C);
	}
	else if(strSignPost == "D")
	{
		m_pSignPostData->dwSignPost = ((m_pSignPostData->dwSignPost & SP_CADENCE) | SP_D);
	}
	else if(strSignPost == "E")
	{
		m_pSignPostData->dwSignPost = ((m_pSignPostData->dwSignPost & SP_CADENCE) | SP_E);
	}
	else if(strSignPost == "F")
	{
		m_pSignPostData->dwSignPost = ((m_pSignPostData->dwSignPost & SP_CADENCE) | SP_F);
	}
	else if(strSignPost == "None")
	{
		//m_pSignPostData->dwSignPost = (m_pSignPostData->dwSignPost & SP_CADENCE); //?cadence to nothing?
		m_pSignPostData->dwSignPost = 0;
	}
	else
	{
		ASSERT(FALSE);
		return;
	}
	if(IsWindow(m_CadenceCheck.m_hWnd))
	{
		m_CadenceCheck.EnableWindow(m_pSignPostData->dwSignPost != 0);
	}
	m_pSignPostData->dwValid |= VALID_SIGNPOST;

	if(m_pPageManager != NULL && m_pPageManager->m_pIPropPageObject != NULL)
	{
		hr = m_pPageManager->m_pIPropPageObject->SetData(m_pSignPostData);
		ASSERT(SUCCEEDED(hr));
		if(S_FALSE == hr)
		{
			// The new data was rejected!
			PPGSignPost *pSignPost;

			hr = m_pPageManager->m_pIPropPageObject->GetData((void **) &pSignPost);
			ASSERT(SUCCEEDED(hr));
			hr = SetData(pSignPost);
			ASSERT(SUCCEEDED(hr));
		}
	}	
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SignPostStripMgr\SignPostMgr.h ===
// SignPostMgr.h : Declaration of the CSignPostMgr

#ifndef __SIGNPOSTMGR_H_
#define __SIGNPOSTMGR_H_


#include "resource.h"       // main symbols
#include "DllJazzDataObject.h"
#include "timeline.h"
#include "SignPostPPGMgr.h"
#include "SignPostIO.h"
#include <dmusici.h>
#include <afxcmn.h>

#define CF_SIGNPOST "Microsoft Jazz v.1 SignPost"

#define TRACKCONFIG_VALID_MASK (DMUS_TRACKCONFIG_PLAY_ENABLED | DMUS_TRACKCONFIG_CONTROL_PLAY | DMUS_TRACKCONFIG_NOTIFICATION_ENABLED | DMUS_TRACKCONFIG_CONTROL_NOTIFICATION | DMUS_TRACKCONFIG_PLAY_COMPOSE | DMUS_TRACKCONFIG_LOOP_COMPOSE | DMUS_TRACKCONFIG_COMPOSING | DMUS_TRACKCONFIG_TRANS1_FROMSEGSTART | DMUS_TRACKCONFIG_TRANS1_FROMSEGCURRENT | DMUS_TRACKCONFIG_TRANS1_TOSEGSTART)

class CSignPostStripMgrApp;
interface IDMUSProdFramework;

extern CSignPostStripMgrApp theApp;

/////////////////////////////////////////////////////////////////////////////
// CSignPostStripMgrApp
class CSignPostStripMgrApp : public CWinApp
{
public:
	virtual BOOL InitInstance();
	virtual int ExitInstance();
};

/////////////////////////////////////////////////////////////////////////////
// CSignPostMgr
class ATL_NO_VTABLE CSignPostMgr : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CSignPostMgr, &CLSID_SignPostMgr>,
	public IDMUSProdStripMgr,
	public IPersistStream,
	public IDMUSProdPropPageObject
{
friend class CSignPostStrip;
public:
	CSignPostMgr()
	{
		m_pTimeline					= NULL;
		m_pSignPostList				= NULL;
		m_pMeasureArray				= NULL;
		m_pIPageManager				= NULL;
		m_pDragDataObject			= NULL;
		m_pCopyDataObject			= NULL;
		m_pSignPostStrip			= NULL;
		m_bSelected					= FALSE;
		m_PPGSignPost.lMeasure		= 0;
		m_PPGSignPost.dwValid		= 0;
		m_PPGSignPost.dwSignPost	= 0;
		m_nMeasures					= 0;
		m_lShiftFromMeasure			= 0;
		m_dwGroupBits				= 1;
		m_dwOldGroupBits			= 1;
		m_dwTrackExtrasFlags		= DMUS_TRACKCONFIG_DEFAULT & TRACKCONFIG_VALID_MASK;
		m_dwProducerOnlyFlags		= 0;
		m_pIDMTrack					= NULL;
		m_pTempIStream				= NULL;
		m_pIFramework				= NULL;
		m_dwActivityLevel			= 4;
	}
	~CSignPostMgr()
	{
		ClearSignPostList(m_pSignPostList);

		if(m_pMeasureArray != NULL)
		{
			delete [] m_pMeasureArray;
		}

		if(m_pIFramework != NULL)
		{
			m_pIFramework->Release();
			m_pIFramework = NULL;
		}
		if(m_pIPageManager != NULL)
		{
			m_pIPageManager->Release();
			m_pIPageManager = NULL;
		}
		if( m_pIDMTrack )
		{
			m_pIDMTrack->Release();
		}
		if( m_pTempIStream )
		{
			m_pTempIStream->Release();
		}
		if(m_pDragDataObject)
		{
			m_pDragDataObject->Release();
			m_pDragDataObject = NULL;
		}
		if(m_pCopyDataObject)
		{
			if(S_OK == OleIsCurrentClipboard(m_pCopyDataObject))
			{
				OleFlushClipboard();
			}
			m_pCopyDataObject->Release();
			m_pCopyDataObject = NULL;
		}
	}

protected:
	IDMUSProdTimeline			*m_pTimeline;
	struct SignPostExt			*m_pSignPostList;
	struct SignPostMeasureInfo	*m_pMeasureArray;	// SignPostMeasureInfo[m_nMeasures]
	IDMUSProdPropPageManager		*m_pIPageManager;
	BOOL						m_bSelected;
	PPGSignPost					m_PPGSignPost;
	CDllJazzDataObject			*m_pDragDataObject;
	IDataObject					*m_pCopyDataObject;
	long						m_lShiftFromMeasure;
	short						m_nMeasures;
	DWORD						m_dwGroupBits;
	DWORD						m_dwOldGroupBits;
	DWORD						m_dwTrackExtrasFlags;
	DWORD						m_dwProducerOnlyFlags;
	IDirectMusicTrack*			m_pIDMTrack;
	class CSignPostStrip		*m_pSignPostStrip;
	IStream						*m_pTempIStream;
	IDMUSProdFramework*			m_pIFramework;
	DWORD						m_dwActivityLevel;

public:

DECLARE_REGISTRY_RESOURCEID(IDR_SIGNPOSTMGR)

BEGIN_COM_MAP(CSignPostMgr)
	COM_INTERFACE_ENTRY(IDMUSProdStripMgr)
	COM_INTERFACE_ENTRY(IPersist)
	COM_INTERFACE_ENTRY(IPersistStream)
	COM_INTERFACE_ENTRY(IDMUSProdPropPageObject)
END_COM_MAP()


// IPersist functions
    STDMETHOD(GetClassID)( CLSID* pClsId );

// IPersistStream functions
    STDMETHOD(IsDirty)();
    STDMETHOD(Load)( IStream* pIStream );
    STDMETHOD(Save)( IStream* pIStream, BOOL fClearDirty );
    STDMETHOD(GetSizeMax)( ULARGE_INTEGER FAR* pcbSize );

// IDMUSProdPropPageObject functions
	HRESULT STDMETHODCALLTYPE GetData( /* [retval][out] */ void **ppData);
	HRESULT STDMETHODCALLTYPE SetData( /* [in] */ void *pData);
	HRESULT STDMETHODCALLTYPE OnShowProperties( void);
	HRESULT STDMETHODCALLTYPE OnRemoveFromPageManager( void);

// IDMUSProdStripMgr
public:
	HRESULT STDMETHODCALLTYPE IsParamSupported(
		/* [in] */ REFGUID		guidType);
	HRESULT STDMETHODCALLTYPE GetParam(
		/* [in] */  REFGUID		guidType,
		/* [in] */  MUSIC_TIME	mtTime,
		/* [out] */ MUSIC_TIME*	pmtNext,
		/* [out] */ void*		pData);
	HRESULT STDMETHODCALLTYPE SetParam(
		/* [in] */ REFGUID		guidType,
		/* [in] */ MUSIC_TIME	mtTime,
		/* [in] */ void*		pData);
	HRESULT STDMETHODCALLTYPE OnUpdate(
		/* [in] */  REFGUID		rguidType,
		/* [in] */  DWORD		dwGroupBits,
		/* [in] */	void*		pData);
	HRESULT STDMETHODCALLTYPE GetStripMgrProperty( 
		/* [in] */ STRIPMGRPROPERTY stripMgrProperty,
		/* [out] */ VARIANT*	pVariant);
	HRESULT STDMETHODCALLTYPE SetStripMgrProperty( 
		/* [in] */ STRIPMGRPROPERTY smp,
		/* [in] */ VARIANT		variant);

protected:
	SignPostExt* GetFirstSelectedSignPost();
	void UnMarkAtMeasure(DWORD measure, WORD flags);
	HRESULT SaveDroppedSignPostList(IStream* pStream, BOOL bOnlySelected, short nOffsetMeasure);
	void UnMarkSignPosts(WORD flags);
	void DeleteMarkedSignPosts(DWORD flags);
	short MarkSelectedSignPosts(DWORD flags);

protected:
	HRESULT SyncWithDirectMusic(  );
	void UpdateSegment( void );
	HRESULT VerifyMeasureArray();
	HRESULT LoadSignPostList(IStream* pStream, long lDropPos, BOOL bDrop, BOOL &fChanged );
	HRESULT SaveSignPostList( IStream* pIStream, BOOL bOnlySelected, bool bNormalize=false );
	HRESULT InsertSignPost(long lMeasure);
	void	ClearSignPostList(SignPostExt *pSignPostList, BOOL bClearSelection = TRUE);
	void	SelectSegment(long lBeginTime, long lEndTime);
	void	ClearSelected();
	void	SelectAll();
	void	DeleteSelected();
	void	ToggleSelect(long lMeasure);
	BOOL	IsSelected(long lMeasure);
	short	GetFirstSelectedMeasure();
	void	GetBoundariesOfSelectedCommands( long *plStart, long *plEnd );
	BOOL	DeleteBetweenTimes( long lStart, long lEnd );

	SignPostExt*	GetSignPostAtMeasure(long lMeasure)
	{
		ASSERT(m_pMeasureArray);
		if(lMeasure >= 0 && lMeasure < m_nMeasures)
		{
			return m_pMeasureArray[lMeasure].pSignPost;
		}
		else
		{
			return 0;
		}
	}
private:
	void RecalculateMusicTimeValues();
	void RemoveOrphanSignposts();
	void SyncMeasureArray();
	HRESULT ResizeMeasureArray();
};


class CSignPostStrip : 
	public IDMUSProdStrip,
	public IDMUSProdTimelineEdit,
	public IDMUSProdStripFunctionBar,
	public IDMUSProdPropPageObject,
	public IDropSource, 
	public IDropTarget
{
friend class CSignPostMgr;
protected:
	long				m_cRef;
	CSignPostMgr		*m_pSignPostMgr;
	IDMUSProdStripMgr	*m_pStripMgr;
	BOOL				m_fSelected;
	BOOL				m_bSelecting;
	BOOL				m_bContextMenuPaste;
	long				m_lBeginSelect;
	long				m_lEndSelect;
	UINT				m_cfFormat;
	CBitmap				m_bmCompose;
	BOOL				m_fLButtonDown;
	BOOL				m_fComposeButtonDown;
	BOOL				m_fInAllTracksAdded;

	// drag/drop support
	IDataObject*	m_pISourceDataObject;	// Object being dragged	
	IDataObject*	m_pITargetDataObject;
	DWORD			m_dwStartDragButton;	// Mouse button that initiated drag operation
	DWORD			m_dwOverDragButton;		// Mouse button stored in IDropTarget::DragOver
	DWORD			m_dwOverDragEffect;		// Drag effects stored in IDropTarget::DragOver
	CImageList*		m_pDragImage;			// Image used for drag operation feedback
	DWORD			m_dwDragRMenuEffect;	// Result from drag context menu
	LONG			m_startDragPosition;	// xpos where drag was started
	UINT			m_nLastEdit;			// resource id of last edit
	short			m_nStripIsDragDropSource;
	bool			m_bWasSelected;
public:
	CSignPostStrip( CSignPostMgr* pSignPostMgr )
	{
		RECT rect;

		rect.top = 0;
		rect.bottom = 0;
		rect.left = 0;
		rect.right = 0;
		ASSERT( pSignPostMgr );
		m_pSignPostMgr = pSignPostMgr;
		m_pStripMgr = (IDMUSProdStripMgr*)pSignPostMgr;
		//if(pSignPostMgr)
		//{
		//	m_pStripMgr->AddRef();
		//}
		m_cRef = 0;
		AddRef();
		m_fSelected = FALSE;
		m_bSelecting = FALSE;
		m_bContextMenuPaste = FALSE;
		m_bWasSelected = FALSE;	// used as signal for toggle select
		m_cfFormat = RegisterClipboardFormat(CF_SIGNPOST);
		m_lBeginSelect = 0;
		m_lEndSelect = 0;
		m_pISourceDataObject = NULL;
		m_pITargetDataObject = NULL;
		m_dwStartDragButton = 0;
		m_dwOverDragButton = 0;
		m_dwOverDragEffect = 0;
		m_pDragImage = NULL;
		m_dwDragRMenuEffect = DROPEFFECT_NONE;
		m_fShowGroupProps = FALSE;
		m_fPropPageActive = FALSE;
		m_pPropPageMgr = NULL;
		m_fLButtonDown = FALSE;
		m_fInAllTracksAdded = FALSE;
		m_nStripIsDragDropSource = 0;
		m_nLastEdit = 0;
		m_fComposeButtonDown = FALSE;

		// Initialize bitmap
		m_bmCompose.LoadBitmap( IDB_COMPOSE );

		BITMAP bmParam;
		m_bmCompose.GetBitmap( &bmParam );
		m_bmCompose.SetBitmapDimension( bmParam.bmWidth, bmParam.bmHeight );
	};

	~CSignPostStrip()
	{
		//ASSERT(m_pStripMgr);
		//if(m_pStripMgr)
		//{
		//	m_pStripMgr->Release();
		//}
		if(m_pPropPageMgr)
		{
			m_pPropPageMgr->Release();
		}

		m_bmCompose.DeleteObject();
	}

// IUnknown
public:
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

// IDMUSProdStrip
public:
	HRESULT	STDMETHODCALLTYPE	Draw( HDC hDC, STRIPVIEW sv, LONG lXOffset );
    HRESULT STDMETHODCALLTYPE	GetStripProperty( STRIPPROPERTY sp, VARIANT *pvar);
    HRESULT STDMETHODCALLTYPE	SetStripProperty( STRIPPROPERTY sp, VARIANT var);
	HRESULT STDMETHODCALLTYPE	OnWMMessage( UINT nMsg, WPARAM wParam, LPARAM lParam, LONG lXPos, LONG lYPos );

// IDropTarget
public:
	HRESULT STDMETHODCALLTYPE DragEnter( IDataObject* pIDataObject, DWORD grfKeyState, POINTL pt, DWORD* pdwEffect);
	HRESULT STDMETHODCALLTYPE DragOver( DWORD grfKeyState, POINTL pt, DWORD* pdwEffect);
	HRESULT STDMETHODCALLTYPE DragLeave( void );
	HRESULT STDMETHODCALLTYPE Drop( IDataObject* pIDataObject, DWORD grfKeyState, POINTL pt, DWORD* pdwEffect);
// IDropTarget helpers
protected:
	CWnd* GetTimelineCWnd();
	HRESULT CanPasteFromData(IDataObject* pIDataObject);
	HRESULT PasteAt( IDataObject* pIDataObject, POINTL pt);

// IDropSource
public:
	HRESULT STDMETHODCALLTYPE QueryContinueDrag( BOOL fEscapePressed, DWORD grfKeyState );
	HRESULT STDMETHODCALLTYPE GiveFeedback( DWORD dwEffect );
// IDropSource helpers
protected:
	CImageList* CreateDragImage();
	HRESULT		CreateDataObject(IDataObject**, long measure);
	HRESULT		DoDragDrop(WPARAM mousekeybutton, LONG lXPos, long lmeasure);

// IDMUSProdStripFunctionBar
public:
	HRESULT STDMETHODCALLTYPE FBDraw( HDC hDC, STRIPVIEW sv );
	HRESULT STDMETHODCALLTYPE FBOnWMMessage( UINT nMsg, WPARAM wParam, LPARAM lParam, LONG lXPos, LONG lYPos );

// IDMUSProdTimelineEdit
public:
	HRESULT STDMETHODCALLTYPE Cut( /* in */ IDMUSProdTimelineDataObject* pITimelineDataObject = NULL );
	HRESULT STDMETHODCALLTYPE Copy( /* in */ IDMUSProdTimelineDataObject* pITimelineDataObjectt = NULL );
	HRESULT STDMETHODCALLTYPE Paste( /* in */ IDMUSProdTimelineDataObject* pITimelineDataObject = NULL );
	HRESULT STDMETHODCALLTYPE Insert( void );
	HRESULT STDMETHODCALLTYPE Delete( void );
	HRESULT STDMETHODCALLTYPE SelectAll( void );
	HRESULT STDMETHODCALLTYPE CanCut( void );
	HRESULT STDMETHODCALLTYPE CanCopy( void );
	HRESULT STDMETHODCALLTYPE CanPaste( IDMUSProdTimelineDataObject* pITimelineDataObject = NULL );
	HRESULT STDMETHODCALLTYPE CanInsert( void );
	HRESULT STDMETHODCALLTYPE CanDelete( void );
	HRESULT STDMETHODCALLTYPE CanSelectAll( void );

// IDMUSProdPropPageObject functions
	HRESULT STDMETHODCALLTYPE GetData( void **ppData );
	HRESULT STDMETHODCALLTYPE SetData( void *pData );
	HRESULT STDMETHODCALLTYPE OnShowProperties( void );
	HRESULT STDMETHODCALLTYPE OnRemoveFromPageManager( void );

// Other
protected:
	void SetEnabledItems(HMENU hMenu);
	void UnselectGutterRange( void );

	HRESULT OnRButtonUp( WPARAM wParam, LONG lXPos, LONG lYPos );
	HRESULT OnLButtonUp( WPARAM wParam, LONG lXPos, LONG lYPos );
	HRESULT OnLButtonDown( WPARAM wParam, LONG lXPos, LONG lYPos );
	HRESULT OnMouseMove( WPARAM wParam, LPARAM lParam, LONG lXPos, LONG lYPos );

// Helper
private:
	LONG		m_lXPos;				// used for temp storage of xpos when doing mouse edits
	long		m_lMouseXPos;			// second temp storage for keeping mouse position between
										// click states
	long		m_lMouseYPos;			// second temp storage for keeping mouse position between
										// click states
	BOOL		m_fShowGroupProps;		// if TRUE, show Group property page, else show SignPost property page
	BOOL		m_fPropPageActive;		// TRUE if our property page is active
	IDMUSProdPropPageManager*	m_pPropPageMgr;
};



#endif //__SIGNPOSTMGR_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SignPostStripMgr\RiffStructs.h ===
#ifndef __RIFFSTRUCTS_SEGMENT_H__
#define __RIFFSTRUCTS_SEGMENT_H__ 1

#pragma pack(2)

// *********************************************************************
// *********************************************************************
// ********************* File io for IMA 25 objects ********************
// *********************************************************************
// *********************************************************************

typedef struct ioCommand
{
    long    lTime;       // Time, in clocks.
    DWORD   dwCommand;    // Command type.
} ioCommand;


typedef struct ioChord
{
	long	lChordPattern;	// pattern that defines chord
	long	lScalePattern;	// scale pattern for the chord
	long	lInvertPattern;	// inversion pattern
    	BYTE    bRoot;		// root note of chord
	BYTE    bReserved;	// expansion room
	WORD    wCFlags;	// bit flags
	long	lReserved;	// expansion room
} ioChord;

enum
{
	CSF_KEYDOWN = 	1,	// key currently held down in sjam kybd
	CSF_INSCALE = 	2,	// member of scale
	CSF_FLAT =		4,	// display with flat
	CSF_SIMPLE =	8,	// simple chord, display at top of sjam list
};

typedef struct ioChordSelection
{
    wchar_t wstrName[16];   // text for display
    BYTE    fCSFlags;      // ChordSelection flags
    BYTE    bBeat;         // beat this falls on
    WORD    wMeasure;       // measure this falls on
    ioChord aChord[4];      // array of chords: levels
    BYTE    bClick;        // click this falls on
} ioChordSelection;


#define KEY_FLAT 0x80
typedef struct ioSect
{
    long    lTime;           // Time this section starts.
    wchar_t wstrName[16];       // Each section has a name.
    WORD    wTempo;             // Tempo.
    WORD    wRepeats;           // Number of repeats.
    WORD    wMeasureLength;     // Length, in measures.
    WORD    wClocksPerMeasure;  // Length of each measure.
    WORD    wClocksPerBeat;     // Length of each beat.
    WORD    wTempoFract;        // Tempo fraction.  (0-65536) (Score only)
    DWORD   dwFlags;           // Currently not used in SuperJAM!
    char    chKey;          // key sig. High bit is flat bit, the rest is root.
    char    chPad[3];
    GUID    guidStyle;
    GUID    guidPersonality;
    wchar_t wstrCategory[16];
} ioSection;

#pragma pack()

#endif //__RIFFSTRUCTS_SEGMENT_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SignPostStripMgr\SignPostMgr.cpp ===
// SignPostMgr.cpp : Implementation of CSignPostMgr

#include "stdafx.h"
#include "SignPostStripMgr.h"
#include "SignPostMgr.h"
#include "SignPostIO.h"
#include <dmusici.h>
#include <dmusicf.h>
#include "RiffStructs.h"
#include "RiffStrm.h"
#include "SegmentGuids.h"
#include "SegmentIO.h"

/////////////////////////////////////////////////////////////////////////////
// CSignPostMgr

typedef struct _ioSignPostDesign
{
	DWORD	dwActivityLevel;
} ioSignPostDesign;

#define DMUSPROD_FOURCC_SIGNPOST_DESIGN_CHUNK	mmioFOURCC('p','s','p','d')

/////////////////////////////////////////////////////////////////////////////
// CSignPostMgr IDMUSProdStripMgr

HRESULT STDMETHODCALLTYPE CSignPostMgr::GetParam(
		/* [in] */  REFGUID		guidType,
		/* [in] */  MUSIC_TIME	mtTime,
		/* [out] */ MUSIC_TIME*	pmtNext,
		/* [out] */ void*		pData)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	UNREFERENCED_PARAMETER(mtTime);
	UNREFERENCED_PARAMETER(pmtNext);
	
	ASSERT( pData != NULL );
	if( pData == NULL )
	{
		return E_POINTER;
	}

	if( ::IsEqualGUID( guidType, GUID_Segment_Undo_BSTR ) )
	{
		BSTR bstr;
		CString str;
		str.LoadString(m_pSignPostStrip->m_nLastEdit);
		try
		{
			bstr = str.AllocSysString();
		}
		catch(CMemoryException*)
		{
			return E_OUTOFMEMORY;
		}
		*(BSTR*)pData = bstr;
		return S_OK;
	}

	return E_NOTIMPL;
}

HRESULT STDMETHODCALLTYPE CSignPostMgr::SetParam(
		/* [in] */ REFGUID		guidType,
		/* [in] */ MUSIC_TIME	mtTime,
		/* [in] */ void*		pData)
{
	//AFX_MANAGE_STATE(AfxGetStaticModuleState());
	UNREFERENCED_PARAMETER(guidType);
	UNREFERENCED_PARAMETER(mtTime);
	UNREFERENCED_PARAMETER(pData);
	return E_NOTIMPL;
}

HRESULT STDMETHODCALLTYPE CSignPostMgr::IsParamSupported(
		/* [in] */ REFGUID		guidType)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	
	if(::IsEqualGUID( guidType, GUID_Segment_Undo_BSTR ) )
	{
		return S_OK;
	}
	return S_FALSE;

}

HRESULT STDMETHODCALLTYPE CSignPostMgr::OnUpdate(
		/* [in] */  REFGUID		rguidType,
		/* [in] */  DWORD		dwGroupBits,
		/* [in] */	void*		pData)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	UNREFERENCED_PARAMETER(dwGroupBits);
	UNREFERENCED_PARAMETER(pData);

	HRESULT hr = S_OK;
	if(::IsEqualGUID(rguidType, GUID_Segment_Length_Change))
	{
		hr = ResizeMeasureArray();
		if(hr == S_OK)
		{
			m_pTimeline->StripInvalidateRect((IDMUSProdStrip *)m_pSignPostStrip, NULL, TRUE);
		}
	}
	else if(::IsEqualGUID(rguidType, GUID_TimeSignature))
	{
		RecalculateMusicTimeValues();
		UpdateSegment();
	}
	else if(::IsEqualGUID(rguidType, GUID_Segment_AllTracksAdded))
	{
		// Make sure measure array is the correct size
		hr = VerifyMeasureArray();
		if( FAILED ( hr ) )
		{
			return hr;
		}
		m_pSignPostStrip->m_fInAllTracksAdded = TRUE;
		ResizeMeasureArray();
		m_pSignPostStrip->m_fInAllTracksAdded = FALSE;
		// Load stream (deferred load)
		if( m_pTempIStream )
		{
			//seek to beginning
			LARGE_INTEGER	liTemp;
			liTemp.QuadPart = 0;
			m_pTempIStream->Seek(liTemp, STREAM_SEEK_SET, NULL);	//seek to beginning
			Load( m_pTempIStream );

			// No need to keep m_pTempIStream around - we'll still have the same data
			// when the Timeline closes and re-opens
			m_pTempIStream->Release();
			m_pTempIStream = NULL;
		}
		// Make sure signpost times match time signature
		RecalculateMusicTimeValues();
		// Sync with DirectMusic
		SyncWithDirectMusic();
	}
	// Set the "Use to Compose" flag by default
	else if( ::IsEqualGUID(rguidType, GUID_Segment_CreateTrack))
	{
		m_dwTrackExtrasFlags |= DMUS_TRACKCONFIG_COMPOSING;
		UpdateSegment();
	}
	return hr;
}
HRESULT STDMETHODCALLTYPE CSignPostMgr::GetStripMgrProperty(
		/* [in] */ STRIPMGRPROPERTY stripMgrProperty,
		/* [out] */ VARIANT*	pVariant)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	ASSERT( pVariant );
	if( !pVariant )
	{
		return E_POINTER;
	}

	switch( stripMgrProperty )
	{
	case SMP_ITIMELINECTL:
		pVariant->vt = VT_UNKNOWN;
		if( m_pTimeline )
		{
			V_UNKNOWN( pVariant ) = m_pTimeline;
			V_UNKNOWN( pVariant )->AddRef();
			return S_OK;
		}
		else
		{
			V_UNKNOWN( pVariant ) = NULL;
			return E_FAIL;
		}
		break;

	case SMP_IDIRECTMUSICTRACK:
		pVariant->vt = VT_UNKNOWN;
		if( m_pIDMTrack )
		{
			return m_pIDMTrack->QueryInterface( IID_IUnknown, (void**)&V_UNKNOWN( pVariant ) );
		}
		else
		{
			V_UNKNOWN( pVariant ) = NULL;
			return E_FAIL;
		}
		break;

	case SMP_IDMUSPRODFRAMEWORK:
		pVariant->vt = VT_UNKNOWN;
		if( m_pIFramework )
		{
			return m_pIFramework->QueryInterface( IID_IUnknown, (void**)&V_UNKNOWN( pVariant ) );
		}
		else
		{
			V_UNKNOWN( pVariant ) = NULL;
			return E_FAIL;
		}
		break;

	case SMP_DMUSIOTRACKHEADER:
		if( pVariant->vt != VT_BYREF )
		{
			return E_INVALIDARG;
		}
		else
		{
			DMUS_IO_TRACK_HEADER *pioTrackHeader = static_cast<DMUS_IO_TRACK_HEADER *>(V_BYREF( pVariant ));
			if( pioTrackHeader == NULL )
			{
				return E_POINTER;
			}

			// Make sure track belongs to only one track group
			for( int i = 0 ;  i < 32 ;  i++ )
			{
				if( m_dwGroupBits & (1 << i) )
				{
					m_dwGroupBits = (1 << i);
					m_dwOldGroupBits = (1 << i);
					break;
				}
			}
			pioTrackHeader->guidClassID = CLSID_DirectMusicSignPostTrack;
			pioTrackHeader->dwPosition = 0;
			pioTrackHeader->dwGroup = m_dwGroupBits;
			pioTrackHeader->ckid = DMUS_FOURCC_SIGNPOST_TRACK_CHUNK;
			pioTrackHeader->fccType = NULL;
		}
		break;

	case SMP_DMUSIOTRACKEXTRASHEADER:
		if( pVariant->vt != VT_BYREF )
		{
			return E_INVALIDARG;
		}
		else
		{
			DMUS_IO_TRACK_EXTRAS_HEADER *pioTrackExtrasHeader = static_cast<DMUS_IO_TRACK_EXTRAS_HEADER *>(V_BYREF( pVariant ));
			if( pioTrackExtrasHeader == NULL )
			{
				return E_POINTER;
			}

			// Always set DMUS_TRACKCONFIG_COMPOSING
			m_dwTrackExtrasFlags |= DMUS_TRACKCONFIG_COMPOSING;
			pioTrackExtrasHeader->dwFlags = m_dwTrackExtrasFlags;
			pioTrackExtrasHeader->dwPriority = COMPOSITION_PRIORITY_SIGNPOST_STRIP;
		}
		break;

	case SMP_DMUSIOTRACKEXTRASHEADER_MASK:
		pVariant->vt = VT_I4;
		V_I4(pVariant) = TRACKCONFIG_VALID_MASK;
		break;

	case SMP_PRODUCERONLY_FLAGS:
		if( pVariant->vt != VT_BYREF )
		{
			return E_INVALIDARG;
		}
		else
		{
			IOProducerOnlyChunk *pioProducerOnlyChunk = static_cast<IOProducerOnlyChunk *>(V_BYREF( pVariant ));
			if( pioProducerOnlyChunk == NULL )
			{
				return E_POINTER;
			}

			pioProducerOnlyChunk->dwProducerOnlyFlags = m_dwProducerOnlyFlags;
		}
		break;

	default:
		return E_INVALIDARG;
	}
	return S_OK;
}

HRESULT STDMETHODCALLTYPE CSignPostMgr::SetStripMgrProperty(
		/* [in] */ STRIPMGRPROPERTY stripMgrProperty,
		/* [in] */ VARIANT		variant)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	switch( stripMgrProperty )
	{
	case SMP_ITIMELINECTL:
		if( variant.vt != VT_UNKNOWN )
		{
			return E_INVALIDARG;
		}
		if(m_pTimeline)
		{
			m_pTimeline->RemovePropertyPageObject((IDMUSProdPropPageObject *)this);
			if( m_pSignPostStrip )
			{
				m_pTimeline->RemovePropertyPageObject((IDMUSProdPropPageObject *)m_pSignPostStrip);
				m_pTimeline->RemoveStrip( (IDMUSProdStrip *)m_pSignPostStrip );
				m_pSignPostStrip->Release();
				m_pSignPostStrip = NULL;
			}
			m_pTimeline->RemoveFromNotifyList( (IDMUSProdStripMgr *)this, GUID_Segment_Length_Change, m_dwOldGroupBits);
			m_pTimeline->RemoveFromNotifyList( (IDMUSProdStripMgr *)this, GUID_TimeSignature, m_dwOldGroupBits);
			m_pTimeline->RemoveFromNotifyList( (IDMUSProdStripMgr *)this, GUID_Segment_AllTracksAdded, m_dwOldGroupBits);
			m_pTimeline->Release();
			m_pTimeline = NULL;
		}
		if( V_UNKNOWN( &variant ) )
		{
			if ( FAILED(V_UNKNOWN( &variant )->QueryInterface(IID_IDMUSProdTimeline, (void**)&m_pTimeline) ) )
			{
				return E_FAIL;
			}
			else
			{
				// Only support handling one strip at a time
				if ( m_pSignPostStrip )
				{
					return E_FAIL;
				}


				// Create a strip and add it to the timeline
				m_pSignPostStrip = new CSignPostStrip(this);
				if( !m_pSignPostStrip )
				{
					return E_OUTOFMEMORY;
				}

				m_pTimeline->InsertStripAtDefaultPos( (IDMUSProdStrip *)m_pSignPostStrip, CLSID_DirectMusicSignPostTrack, m_dwGroupBits, 0 );
				m_pTimeline->AddToNotifyList((IDMUSProdStripMgr *)this, GUID_Segment_Length_Change, m_dwGroupBits);
				m_pTimeline->AddToNotifyList((IDMUSProdStripMgr *)this, GUID_TimeSignature, m_dwGroupBits );
				m_pTimeline->AddToNotifyList((IDMUSProdStripMgr *)this, GUID_Segment_AllTracksAdded, m_dwGroupBits );
			}
		}
		break;

	case SMP_IDIRECTMUSICTRACK:
		if( variant.vt != VT_UNKNOWN )
		{
			return E_INVALIDARG;
		}
		if( m_pIDMTrack )
		{
			m_pIDMTrack->Release();
		}
		if( V_UNKNOWN( &variant ) )
		{
			V_UNKNOWN( &variant )->QueryInterface( IID_IDirectMusicTrack, (void**)&m_pIDMTrack );
		}
		else
		{
			m_pIDMTrack = NULL;
		}
		break;

	case SMP_IDMUSPRODFRAMEWORK:
		if( variant.vt != VT_UNKNOWN )
		{
			return E_INVALIDARG;
		}
		if( m_pIFramework )
		{
			m_pIFramework->Release();
			m_pIFramework = NULL;
		}
		if( V_UNKNOWN( &variant ) )
		{
			return V_UNKNOWN( &variant )->QueryInterface( IID_IDMUSProdFramework, (void**)&m_pIFramework);
		}
		break;

	case SMP_DMUSIOTRACKHEADER:
		if( variant.vt != VT_BYREF )
		{
			return E_INVALIDARG;
		}
		else
		{
			DMUS_IO_TRACK_HEADER *pioTrackHeader = static_cast<DMUS_IO_TRACK_HEADER *>(V_BYREF( &variant ));
			if( pioTrackHeader == NULL )
			{
				return E_POINTER;
			}
			m_dwGroupBits = pioTrackHeader->dwGroup;
			m_dwOldGroupBits = pioTrackHeader->dwGroup;
		}
		break;

	case SMP_DMUSIOTRACKEXTRASHEADER:
		if( variant.vt != VT_BYREF )
		{
			return E_INVALIDARG;
		}
		else
		{
			DMUS_IO_TRACK_EXTRAS_HEADER *pioTrackExtrasHeader = static_cast<DMUS_IO_TRACK_EXTRAS_HEADER *>(V_BYREF( &variant ));
			if( pioTrackExtrasHeader == NULL )
			{
				return E_POINTER;
			}

			m_dwTrackExtrasFlags = TRACKCONFIG_VALID_MASK & (pioTrackExtrasHeader->dwFlags);

			// Always set DMUS_TRACKCONFIG_COMPOSING
			m_dwTrackExtrasFlags |= DMUS_TRACKCONFIG_COMPOSING;
		}
		break;

	case SMP_PRODUCERONLY_FLAGS:
		if( variant.vt != VT_BYREF )
		{
			return E_INVALIDARG;
		}
		else
		{
			IOProducerOnlyChunk *pioProducerOnlyChunk = static_cast<IOProducerOnlyChunk *>(V_BYREF( &variant ));
			if( pioProducerOnlyChunk == NULL )
			{
				return E_POINTER;
			}

			m_dwProducerOnlyFlags = pioProducerOnlyChunk->dwProducerOnlyFlags;
		}
		break;

	default:
		return E_INVALIDARG;
	}
	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CSignPostMgr IPersist

HRESULT CSignPostMgr::GetClassID(CLSID* pClsId)
{
	//AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	UNREFERENCED_PARAMETER(pClsId);
	return E_NOTIMPL;
}

/////////////////////////////////////////////////////////////////////////////
// CSignPostMgr IPersistStream functions

HRESULT CSignPostMgr::IsDirty()
{
	//AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	return S_FALSE;
}

HRESULT CSignPostMgr::Load(IStream* pIStream)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	if( pIStream == NULL )
	{
		return E_INVALIDARG;
	}

	// If the strip hasn't been added to the timeline, save the stream until it
	// is added to the Timeline.
	if( m_pTimeline == NULL )
	{
		if( m_pTempIStream )
		{
			m_pTempIStream->Release();
			m_pTempIStream = NULL;
		}
		if( SUCCEEDED( CreateStreamOnHGlobal( NULL, TRUE, &m_pTempIStream ) ) )
		{
			STATSTG StatStg;
			if ( SUCCEEDED( pIStream->Stat( &StatStg, STATFLAG_NONAME ) ) )
			{
				if( SUCCEEDED( pIStream->CopyTo( m_pTempIStream, StatStg.cbSize, NULL, NULL ) ) )
				{
					if( m_pIDMTrack )
					{
						IPersistStream* pIPersistStream;
						if( SUCCEEDED( m_pIDMTrack->QueryInterface( IID_IPersistStream, (void **)&pIPersistStream ) ) )
						{
							//seek to beginning
							LARGE_INTEGER	liTemp;
							liTemp.QuadPart = 0;
							m_pTempIStream->Seek( liTemp, STREAM_SEEK_SET, NULL );
							pIPersistStream->Load( m_pTempIStream );
							pIPersistStream->Release();
						}
					}
					return S_OK;
				}
				else
				{
					TRACE("CSignPostMgr: Unable to copy to memory stream\n");
					m_pTempIStream->Release();
					m_pTempIStream = NULL;
					return E_FAIL;
				}
			}
			else
			{
				TRACE("CSignPostMgr: Unable to stat stream\n");
				m_pTempIStream->Release();
				m_pTempIStream = NULL;
				return E_FAIL;
			}
		}
		else
		{
			TRACE("CSignPostMgr: Unable to create memory stream\n");
			return E_FAIL;
		}
	}

	VARIANT var;
	long	lMeasureLength;
	long	lTimeLength;

	// Clear the list in case the clocks per measure has changed.
	ClearSignPostList(m_pSignPostList, FALSE);
	m_pSignPostList = NULL;

	// Get the length of the timeline and make sure that m_nMeasures and m_lShiftFromMeasure
	// are accurate.

	m_pTimeline->GetTimelineProperty( TP_CLOCKLENGTH, &var );
	lTimeLength = V_I4( &var );
	m_pTimeline->ClocksToMeasureBeat( m_dwGroupBits, 0, lTimeLength, &lMeasureLength, NULL );
	// Ensure lMeasureLength is at least 1
	lMeasureLength = max( 1, lMeasureLength );
	if( m_nMeasures != (short) lMeasureLength )
	{
		if( m_pMeasureArray != NULL )
		{
			delete [] m_pMeasureArray;
			m_pMeasureArray = NULL;
		}

		m_pMeasureArray = new SignPostMeasureInfo[lMeasureLength];
		if( m_pMeasureArray == NULL)
		{
			return E_OUTOFMEMORY;
		}
		m_nMeasures = (short) lMeasureLength;
		// Initialize the array.
		for( short n = 0; n < m_nMeasures; n++ )
		{
			m_pMeasureArray[n].dwFlags = 0;
			m_pMeasureArray[n].pSignPost = NULL;
		}

		if( m_lShiftFromMeasure >= m_nMeasures )
		{
			m_lShiftFromMeasure = m_nMeasures - 1;
		}
	}
	
	BOOL fChanged = FALSE;

	IDMUSProdRIFFStream* pIRiffStream;
	HRESULT hr = E_FAIL;

	// Check for Direct Music format
	if( FAILED( hr = AllocRIFFStream( pIStream, &pIRiffStream ) ) )
	{
		return hr;
	}

	// Load the Track
	MMCKINFO	ck;
	DWORD dwCurPos = StreamTell( pIStream );
	bool fLoadedDesignChunk = false;
	while( SUCCEEDED(hr)
	&&	(pIRiffStream->Descend( &ck, NULL, 0 ) == 0) )
	{
		switch( ck.ckid )
		{
		case DMUS_FOURCC_SIGNPOST_TRACK_CHUNK:
			StreamSeek( pIStream, dwCurPos, STREAM_SEEK_SET );
			hr = LoadSignPostList( pIStream, -1, FALSE, fChanged );
			break;

		case DMUSPROD_FOURCC_SIGNPOST_DESIGN_CHUNK:
			{
				ioSignPostDesign iSignPostDesign;
				ZeroMemory( &iSignPostDesign, sizeof(ioSignPostDesign) );
				DWORD dwRead, dwSize = min( ck.cksize, sizeof(ioSignPostDesign) );
				hr = pIStream->Read( &iSignPostDesign, dwSize, &dwRead );
				if( FAILED(hr) || (dwSize != dwRead) )
				{
					hr = E_FAIL;
				}
				else
				{
					m_dwActivityLevel = iSignPostDesign.dwActivityLevel;
				}
				fLoadedDesignChunk = true;
			}
			break;
		}
		pIRiffStream->Ascend( &ck, 0 );
		dwCurPos = StreamTell( pIStream );
	}

	pIRiffStream->Release();

	// If we didn't load a design chunk, try and get the activity level from the segment
	if( !fLoadedDesignChunk )
	{
		m_pTimeline->GetParam( GUID_LegacyTemplateActivityLevel, 0xFFFFFFFF, 0, 0, NULL, &m_dwActivityLevel );
	}

	ClearSelected();
	return hr;
}

HRESULT CSignPostMgr::Save(IStream* pIStream, BOOL fClearDirty)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	UNREFERENCED_PARAMETER(fClearDirty);
	HRESULT hr = SaveSignPostList(pIStream, FALSE);
	if( FAILED( hr ) )
	{
		return hr;
	}

	DMUSProdStreamInfo	StreamInfo;
	StreamInfo.ftFileType = FT_DESIGN;
	StreamInfo.guidDataFormat = GUID_CurrentVersion;

	// Get additional stream information
	IDMUSProdPersistInfo* pPersistInfo;
	if( SUCCEEDED ( pIStream->QueryInterface( IID_IDMUSProdPersistInfo, (void **)&pPersistInfo ) ) )
	{
		pPersistInfo->GetStreamInfo( &StreamInfo );
		pPersistInfo->Release();
	}

	// If we're saving the design file
	if( StreamInfo.ftFileType == FT_DESIGN )
	{
		// Create a RIFF Stream
		IDMUSProdRIFFStream* pIRiffStream;
		if( FAILED( hr = AllocRIFFStream( pIStream, &pIRiffStream ) ) )
		{
			return hr;
		}

		// Create a design chunk
		MMCKINFO ck;
		ck.ckid = DMUSPROD_FOURCC_SIGNPOST_DESIGN_CHUNK;
		if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
		{
			pIRiffStream->Release();
			return E_FAIL;
		}

		// Write out the design data
		ioSignPostDesign oSignPostDesign;
		ZeroMemory( &oSignPostDesign, sizeof(ioSignPostDesign) );
		oSignPostDesign.dwActivityLevel = m_dwActivityLevel;
		DWORD dwWritten;
		hr = pIStream->Write( &oSignPostDesign, sizeof(ioSignPostDesign), &dwWritten );
		if( FAILED(hr) || (sizeof(ioSignPostDesign) != dwWritten) )
		{
			hr = E_FAIL;
		}

		// Ascend out of the design chunk
		if( pIRiffStream->Ascend( &ck, 0 ) != 0 )
		{
			hr = E_FAIL;
		}

		// Release the RIFF stream
		pIRiffStream->Release();
	}

	return hr;
}

/////////////////////////////////////////////////////////////////////////////
// CSignPostMgr::SyncWithDirectMusic

HRESULT CSignPostMgr::SyncWithDirectMusic(  )
{
	HRESULT hr = E_FAIL;

	// Validate m_pIDMTrack and m_pIFramework
	ASSERT( m_pIDMTrack );
	ASSERT( m_pIFramework );
	if( m_pIDMTrack && m_pIFramework )
	{
		// Create a Memory stream
		IStream* pIMemStream;
		hr = m_pIFramework->AllocMemoryStream( FT_RUNTIME, GUID_DirectMusicObject, &pIMemStream );
		if( SUCCEEDED ( hr ) )
		{
			// Seek to the beginning
			StreamSeek( pIMemStream, 0, STREAM_SEEK_SET );

			// Save ourself
			hr = Save(pIMemStream, FALSE);
			if (SUCCEEDED(hr))
			{
				// Query m_pIDMTrack for a IPersistStream interface
				IPersistStream* pIPersistStream;
				hr = m_pIDMTrack->QueryInterface(IID_IPersistStream, (void**)&pIPersistStream);
				if (SUCCEEDED(hr))
				{
					// Seek to the beginning
					hr = StreamSeek( pIMemStream, 0, STREAM_SEEK_SET );
					if( SUCCEEDED( hr ) )
					{
						// Load the stream into the track.
						hr = pIPersistStream->Load(pIMemStream);
					}
					pIPersistStream->Release();
				}
			}
			pIMemStream->Release();
		}
	}

	return hr;
}


HRESULT CSignPostMgr::GetSizeMax(ULARGE_INTEGER FAR* pcbSize)
{
	//AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	UNREFERENCED_PARAMETER(pcbSize);
	return E_NOTIMPL;
}

HRESULT CSignPostMgr::VerifyMeasureArray()
{
	if(m_pMeasureArray == NULL)
	{
		VARIANT var;
		long	lMeasureLength;
		long	lTimeLength;

		m_pTimeline->GetTimelineProperty( TP_CLOCKLENGTH, &var );
		lTimeLength = V_I4( &var );
		m_pTimeline->ClocksToMeasureBeat( m_dwGroupBits, 0, lTimeLength, &lMeasureLength, NULL );
		// Ensure lMeasureLength is at least 1
		lMeasureLength = max( 1, lMeasureLength );

		m_pMeasureArray = new SignPostMeasureInfo[lMeasureLength];
		if( m_pMeasureArray == NULL)
		{
			return E_OUTOFMEMORY;
		}
		m_nMeasures = (short) lMeasureLength;
		// Initialize the array.
		for( short n = 0; n < m_nMeasures; n++ )
		{
			m_pMeasureArray[n].dwFlags = 0;
			m_pMeasureArray[n].pSignPost = NULL;
		}

		if( m_lShiftFromMeasure >= m_nMeasures )
		{
			m_lShiftFromMeasure = m_nMeasures - 1;
		}
	}
	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// IDMUSProdPropPageObject functions

HRESULT STDMETHODCALLTYPE CSignPostMgr::GetData( /* [retval][out] */ void **ppData)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	BOOL	bValid = FALSE;
	short	n;

	//ASSERT(m_pMeasureArray != NULL);
	HRESULT hr = VerifyMeasureArray();
	if (FAILED(hr)) return hr;

	m_PPGSignPost.dwValid = 0;

	if(m_bSelected)
	{
		// Set the fields of the PPGSignPost
		for( n = 0; n < m_nMeasures; n++ )
		{
			if( m_pMeasureArray[n].dwFlags & SPMI_SELECTED )
			{
				if( m_pMeasureArray[n].pSignPost != NULL )
				{
					if( !bValid )
					{
						m_PPGSignPost.dwValid		= VALID_SIGNPOST | VALID_CADENCE;
						m_PPGSignPost.dwSignPost	= m_pMeasureArray[n].pSignPost->dwSignPost;
						bValid						= TRUE;
					}
					else
					{
						 if(m_PPGSignPost.dwValid & VALID_SIGNPOST)
						 {
							 if((m_PPGSignPost.dwSignPost & ~SP_CADENCE) !=
								(m_pMeasureArray[n].pSignPost->dwSignPost & ~SP_CADENCE))
							 {
								 m_PPGSignPost.dwValid &= ~VALID_SIGNPOST;
							 }
						 }
						 if(m_PPGSignPost.dwValid & VALID_CADENCE)
						 {
							 if((m_PPGSignPost.dwSignPost & SP_CADENCE) !=
								(m_pMeasureArray[n].pSignPost->dwSignPost & SP_CADENCE))
							 {
								 m_PPGSignPost.dwValid &= ~VALID_CADENCE;
							 }
						 }

						 if(m_PPGSignPost.dwValid == 0)
						 {
							 break;
						 }
					}
				}
				else if(!bValid)
				{
					bValid = TRUE;
					m_PPGSignPost.dwValid = VALID_SIGNPOST | VALID_CADENCE;
					m_PPGSignPost.dwSignPost = 0;
				}
				else
				{
					if(m_PPGSignPost.dwValid & VALID_SIGNPOST && 
					  (m_PPGSignPost.dwSignPost & ~SP_CADENCE) != 0)
					{
						m_PPGSignPost.dwValid &= ~VALID_SIGNPOST;
					}
					if( m_PPGSignPost.dwValid & VALID_CADENCE && 
						( m_PPGSignPost.dwSignPost & SP_CADENCE) != 0 )
					{
						m_PPGSignPost.dwValid &= ~VALID_CADENCE;
					}
					m_PPGSignPost.dwSignPost = 0;
				}		
			}
		}
		*ppData = &m_PPGSignPost;
	}
	else
	{
		*ppData = NULL;
	}

	return S_OK;
}

HRESULT STDMETHODCALLTYPE CSignPostMgr::SetData( /* [in] */ void *pData)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	BOOL		bValid = FALSE;
	DWORD		dwSignPost;
	SignPostExt	*pSPE;
	short		n;

	if(pData == NULL)
	{
		return E_INVALIDARG;
	}

	ASSERT(m_bSelected && m_pMeasureArray != NULL);
	if(!m_bSelected || m_pMeasureArray == NULL)
	{
		return E_UNEXPECTED;
	}

	memcpy(&m_PPGSignPost, pData, sizeof(PPGSignPost));

	if(m_PPGSignPost.dwValid == (VALID_SIGNPOST | VALID_CADENCE) &&
	   m_PPGSignPost.dwSignPost == 0)
	{
		DeleteSelected();
		if (m_pTimeline)
		{
			m_pTimeline->Refresh();
		}
		return S_OK;
	}

	// Apply the changes to the selected measures.
	for(n = 0; n < m_nMeasures; n++)
	{
		if(m_pMeasureArray[n].dwFlags & SPMI_SELECTED)
		{
			if(m_pMeasureArray[n].pSignPost != NULL)
			{
				dwSignPost = m_pMeasureArray[n].pSignPost->dwSignPost;
			}
			else
			{
				dwSignPost = 0;
			}

			// Get the signpost for this measure.
			if(m_PPGSignPost.dwValid & VALID_SIGNPOST)
			{
				dwSignPost = ((dwSignPost & SP_CADENCE) | (m_PPGSignPost.dwSignPost & ~SP_CADENCE));
			}
			if(m_PPGSignPost.dwValid & VALID_CADENCE)
			{
				dwSignPost = ((dwSignPost & ~SP_CADENCE) | (m_PPGSignPost.dwSignPost & SP_CADENCE));
			}

			// Update the measure.
			if(dwSignPost == 0 && m_pMeasureArray[n].pSignPost != NULL)
			{
				delete m_pMeasureArray[n].pSignPost;
				m_pMeasureArray[n].pSignPost = NULL;
			}
			if(dwSignPost != 0)
			{
				if(m_pMeasureArray[n].pSignPost == NULL)
				{
					m_pMeasureArray[n].pSignPost = new SignPostExt;
					if(m_pMeasureArray[n].pSignPost == NULL)
					{
						return E_OUTOFMEMORY;
					}
				}
				m_pMeasureArray[n].pSignPost->dwSignPost = dwSignPost;
				m_pTimeline->MeasureBeatToClocks( m_dwGroupBits, 0, (long) n, 0, &(m_pMeasureArray[n].pSignPost->lTime));
			}
			bValid = TRUE;
		}
	}

	// Update the "next" pointers
	m_pSignPostList = NULL;
	pSPE = NULL;
	for(n = 0; n < m_nMeasures; n++)
	{
		if(m_pMeasureArray[n].pSignPost != NULL)
		{
			if(m_pSignPostList == NULL)
			{
				m_pSignPostList = m_pMeasureArray[n].pSignPost;
			}
			else
			{
				pSPE->pNext = m_pMeasureArray[n].pSignPost;
			}
			pSPE = m_pMeasureArray[n].pSignPost;
			pSPE->pNext = NULL;
		}
	}

	ASSERT(bValid);
	ASSERT(m_pTimeline != NULL);
	if(!bValid || m_pTimeline == NULL)
	{
		return E_UNEXPECTED;
	}
	m_pTimeline->Refresh();

	// Let the object know about the changes
	m_pSignPostStrip->m_nLastEdit = IDS_UNDO_CHANGE;
	UpdateSegment();
	return S_OK;
}

HRESULT CSignPostMgr::OnShowProperties(void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	HRESULT hr = S_OK;
	if(m_pIPageManager == NULL)
	{
		CSignPostPPGMgr *pPPM = new CSignPostPPGMgr;
		if(pPPM == NULL)
		{
			return E_OUTOFMEMORY;
		}
		hr = pPPM->QueryInterface(IID_IDMUSProdPropPageManager, (void**)&m_pIPageManager);
		m_pIPageManager->Release(); // this releases the 2nd ref, leaving only one
		if(FAILED(hr))
		{
			return hr;
		}
	}
	ASSERT(m_pTimeline != NULL);
	if(m_pTimeline == NULL)
	{
		return E_UNEXPECTED;
	}
	m_pTimeline->SetPropertyPage(m_pIPageManager, (IDMUSProdPropPageObject*)this);
	m_pIPageManager->RefreshData();
	return hr;
}

HRESULT CSignPostMgr::OnRemoveFromPageManager(void)
{
	//AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	return S_OK;
}

HRESULT CSignPostMgr::SaveSignPostList(IStream* pStream, BOOL bOnlySelected, bool bNormalize)
{
    MMCKINFO ck;
	HRESULT		hr;
    DWORD		dwSizeSignPost;
	DWORD		cb;
    DMUS_IO_SIGNPOST	iSignPost;
	WORD		wMeasureOffset = 0;

	if( m_pTimeline == NULL )
	{
		return E_UNEXPECTED;
	}

	ASSERT( m_pMeasureArray != NULL );
	if( m_pMeasureArray == NULL )
	{
		return E_UNEXPECTED;
	}

	if(NULL == pStream)
	{
		return E_INVALIDARG;
	}

	IDMUSProdRIFFStream* pIRiffStream;
	if( FAILED( hr = AllocRIFFStream( pStream, &pIRiffStream ) ) )
	{
		return hr;
	}

	ck.ckid = DMUS_FOURCC_SIGNPOST_TRACK_CHUNK;
	hr = pIRiffStream->CreateChunk( &ck, 0 );
    if( hr == S_OK )
    {
		if(bNormalize)
		{
			wMeasureOffset = GetFirstSelectedMeasure();
		}
		// Write the size of the signpost structure
		dwSizeSignPost = sizeof(DMUS_IO_SIGNPOST);
		hr = pStream->Write(&dwSizeSignPost, sizeof(dwSizeSignPost), &cb);
		if(FAILED(hr) || cb != sizeof(dwSizeSignPost))
		{
			hr = E_FAIL;
		}

		else
		{
			// Write the signposts
			for(short n = 0; n < m_nMeasures; n++)
			{
				m_pTimeline->MeasureBeatToClocks( m_dwGroupBits, 0, n, 0, &iSignPost.mtTime);
				if(m_pMeasureArray[n].pSignPost != NULL)
				{
					iSignPost.dwChords = m_pMeasureArray[n].pSignPost->dwSignPost;
					m_pMeasureArray[n].pSignPost->lTime = iSignPost.mtTime;
				}
				else
				{
					iSignPost.dwChords = 0;
				}
				iSignPost.wMeasure = (WORD)(n - wMeasureOffset);

				if((bOnlySelected && (m_pMeasureArray[n].dwFlags & SPMI_SELECTED)) ||
				   (!bOnlySelected && iSignPost.dwChords != 0))
				{
					hr = pStream->Write(&iSignPost, sizeof(DMUS_IO_SIGNPOST), &cb);
					if(FAILED(hr) || cb != sizeof(DMUS_IO_SIGNPOST))
					{
						hr = E_FAIL;
						break;
					}
				}
			}
		}
	}
	hr = pIRiffStream->Ascend( &ck, 0 );
	pIRiffStream->Release();

	return hr;
}


void CSignPostMgr::ClearSignPostList(SignPostExt *pSignPostList, BOOL bClearSelection)
{
	SignPostExt* pSPE;

	if(pSignPostList == m_pSignPostList)
	{
		if(m_nMeasures > 0)
		{
			ASSERT(m_pMeasureArray != NULL);
			if(m_pMeasureArray != NULL)
			{
				for(short n = 0; n < m_nMeasures; n++)
				{
					m_pMeasureArray[n].pSignPost = NULL;
					if(bClearSelection)
					{
						m_pMeasureArray[n].dwFlags &= ~SPMI_SELECTED;
					}
				}
			}
		}
	}

	while(pSignPostList)
	{
		pSPE = pSignPostList->pNext;
		delete pSignPostList;
		pSignPostList = pSPE;
	}
}

void CSignPostMgr::SelectSegment(long lBeginTime, long lEndTime)
{
	long	lBegin;
	long	lEnd;
	long	lMeasure;
	long	lTemp;

	ASSERT( m_pTimeline != NULL );
	if( m_pTimeline == NULL )
	{
		return;
	}

	ASSERT( m_pMeasureArray != NULL );
	if( m_pMeasureArray == NULL )
	{
		return;
	}

	lTemp = lBeginTime;
	if(lBeginTime == -1)	// Use shiftfrommeasure
	{
		m_pTimeline->MeasureBeatToClocks( m_dwGroupBits, 0, m_lShiftFromMeasure, 0, &lTemp);
	}

	if(lTemp > lEndTime)
	{
		lBegin	= lEndTime;
		lEnd	= lTemp;
	}
	else
	{
		lBegin	= lTemp;
		lEnd	= lEndTime;
	}

	// Convert lBegin and lEnd to measures.
	m_pTimeline->ClocksToMeasureBeat( m_dwGroupBits, 0, lBegin, &lMeasure, NULL);
	lBegin = lMeasure;
	m_pTimeline->ClocksToMeasureBeat( m_dwGroupBits, 0, lEnd, &lMeasure, NULL);
	lEnd = lMeasure;

	ASSERT(lEnd <= (long) m_nMeasures);
	if(lEnd > m_nMeasures)
	{
		return;
	}

	// Set the selected flag of the signposts in this segment.
	short n;
	for(n = (short) lBegin; n <= (short) lEnd && n < m_nMeasures; n++)
	{
		m_pMeasureArray[n].dwFlags |= SPMI_SELECTED;
		m_bSelected = TRUE;
	}
}

HRESULT CSignPostMgr::InsertSignPost(long lMeasure)
{
	long		lClocks;
	long		lInsertMeasure;

	lInsertMeasure = lMeasure;
	if(lInsertMeasure == -1)
	{
		lInsertMeasure = (long) GetFirstSelectedMeasure();
	}

	ASSERT(lInsertMeasure > -1 && lInsertMeasure < (long) m_nMeasures);
	if(lInsertMeasure < 0 || lInsertMeasure >= (long)m_nMeasures)
	{
		return E_UNEXPECTED;
	}

	ASSERT(m_pTimeline != NULL && m_pMeasureArray != NULL);
	if(m_pTimeline == NULL || m_pMeasureArray == NULL)
	{
		return E_UNEXPECTED;
	}

	if(m_pMeasureArray[lInsertMeasure].pSignPost != NULL)
	{
		// Just open the property page.
		OnShowProperties();
		return S_OK;
	}

	m_pMeasureArray[lInsertMeasure].pSignPost = new SignPostExt;
	if(m_pMeasureArray[lInsertMeasure].pSignPost == NULL)
	{
		return E_OUTOFMEMORY;
	}

	ClearSelected();
	m_pMeasureArray[lInsertMeasure].dwFlags |= SPMI_SELECTED;
	m_bSelected = TRUE;

	// Update the list pointers.
	short n;

	// Find the previous signpost.
	for(n = short (lInsertMeasure - 1); n > -1; n--)
	{
		if(m_pMeasureArray[n].pSignPost != NULL)
		{
			break;
		}
	}

	if(n > -1)
	{
		m_pMeasureArray[n].pSignPost->pNext = m_pMeasureArray[lInsertMeasure].pSignPost;

		// Find the next signpost.
		for(n = short (lInsertMeasure + 1); n < m_nMeasures; n++)
		{
			if(m_pMeasureArray[n].pSignPost != NULL)
			{
				break;
			}
		}
		if(n < m_nMeasures)
		{
			m_pMeasureArray[lInsertMeasure].pSignPost->pNext = m_pMeasureArray[n].pSignPost;
		}
		else
		{
			m_pMeasureArray[lInsertMeasure].pSignPost->pNext = NULL;
		}
	}

	else
	{
		/* this doesn't seem right
		ASSERT(m_pSignPostList == NULL);
		if(m_pSignPostList != NULL)
		{
			return E_UNEXPECTED;
		}
		*/
		SignPostExt* pSignPost = m_pSignPostList;
		m_pSignPostList = m_pMeasureArray[lInsertMeasure].pSignPost;
		m_pSignPostList->pNext = pSignPost;
	}

	m_pTimeline->MeasureBeatToClocks( m_dwGroupBits, 0, lInsertMeasure, 0, &lClocks);

	// Initialize the signpost.
	m_pMeasureArray[lInsertMeasure].pSignPost->lTime		= lClocks;
	m_pMeasureArray[lInsertMeasure].pSignPost->dwSignPost	= SP_1;


	// Get a pointer to the property sheet and show it
	ASSERT( m_pIFramework );
	IDMUSProdPropSheet	*pIPropSheet;
	if( FAILED( m_pIFramework->QueryInterface(IID_IDMUSProdPropSheet, (void**)&pIPropSheet) ) )
	{
		return E_FAIL;
	}
	pIPropSheet->Show(TRUE);
	pIPropSheet->Release();

	// Update the property page.
	OnShowProperties();
	UpdateSegment();
	return S_OK;
}

void CSignPostMgr::ClearSelected()
{
	//ASSERT(m_pMeasureArray != NULL);
	HRESULT hr = VerifyMeasureArray();
	if (FAILED(hr)) return;

	short n;

	for(n = 0; n < m_nMeasures; n++)
	{
		m_pMeasureArray[n].dwFlags &= ~SPMI_SELECTED;
	}

	m_bSelected = FALSE;
}

void CSignPostMgr::SelectAll()
{
	//ASSERT(m_pMeasureArray != NULL);
	HRESULT hr = VerifyMeasureArray();
	if (FAILED(hr)) return;

	short n;

	for(n = 0; n < m_nMeasures; n++)
	{
		m_pMeasureArray[n].dwFlags |= SPMI_SELECTED;
	}

	m_bSelected = TRUE;

	if(m_pIPageManager != NULL)
	{
		m_pIPageManager->RefreshData();
	}
}

void CSignPostMgr::DeleteSelected()
{
	SignPostExt *pSPE = NULL;
	short		n;

	//ASSERT(m_pMeasureArray != NULL || m_nMeasures != 0);
	HRESULT hr = VerifyMeasureArray();
	if (FAILED(hr)) return;

	for(n = 0; n < m_nMeasures; n++)
	{
		if(m_pMeasureArray[n].pSignPost != NULL)
		{
			if(m_pMeasureArray[n].dwFlags & SPMI_SELECTED)
			{
				if(pSPE == NULL)
				{
					ASSERT(m_pSignPostList == m_pMeasureArray[n].pSignPost);
					m_pSignPostList = m_pMeasureArray[n].pSignPost->pNext;
				}
				else
				{
					ASSERT(pSPE->pNext == m_pMeasureArray[n].pSignPost);
					pSPE->pNext = m_pMeasureArray[n].pSignPost->pNext;
				}
				delete m_pMeasureArray[n].pSignPost;
				m_pMeasureArray[n].pSignPost = NULL;
			}
			else
			{
				pSPE = m_pMeasureArray[n].pSignPost;
			}
		}
		// Leave the measure selected, so the user can still use the selection.
//		m_pMeasureArray[n].dwFlags &= ~SPMI_SELECTED;
	}

	if(m_pIPageManager != NULL)
	{
		m_pIPageManager->RefreshData();
	}

	m_pSignPostStrip->m_nLastEdit = IDS_UNDO_DELETE;
	UpdateSegment();
}

void CSignPostMgr::ToggleSelect(long lMeasure)
{
	//ASSERT(m_pMeasureArray != NULL);
	HRESULT hr = VerifyMeasureArray();
	if (FAILED(hr)) return;

	if(lMeasure >= (long) m_nMeasures)
	{
		return;
	}

	m_pMeasureArray[lMeasure].dwFlags ^= SPMI_SELECTED;
	if(m_pMeasureArray[lMeasure].dwFlags & SPMI_SELECTED)
	{
		m_bSelected = TRUE;
	}

	if( m_pIPageManager != NULL )
	{
		m_pIPageManager->RefreshData();
	}
}

BOOL CSignPostMgr::IsSelected(long lMeasure)
{
	//ASSERT(m_pMeasureArray != NULL);
	HRESULT hr = VerifyMeasureArray();
	if (FAILED(hr)) return FALSE;

	ASSERT(lMeasure < (long) m_nMeasures);
	if(lMeasure >= (long) m_nMeasures)
	{
		return FALSE;
	}

	return (m_pMeasureArray[lMeasure].dwFlags & SPMI_SELECTED ? TRUE : FALSE);
}

short CSignPostMgr::GetFirstSelectedMeasure()
{
	short n;

	if(m_pMeasureArray == NULL)
	{
		return -1;
	}

	for(n = 0; n < m_nMeasures; n++)
	{
		if(m_pMeasureArray[n].dwFlags & SPMI_SELECTED)
		{
			return n;
		}
	}

	return -1;
}

SignPostExt* CSignPostMgr::GetFirstSelectedSignPost()
{
	for(int n = 0; n < m_nMeasures; n++)
	{
		if(m_pMeasureArray[n].pSignPost && m_pMeasureArray[n].dwFlags & SPMI_SELECTED)
		{
			return m_pMeasureArray[n].pSignPost;
		}
	}
	return NULL;
}

void CSignPostMgr::GetBoundariesOfSelectedCommands( long *plStart, long *plEnd )
{
	ASSERT( plStart );
	ASSERT( plEnd );

	if( m_pMeasureArray == NULL )
	{
		*plStart = -1;
		*plEnd = -1;
		return;
	}

	BOOL fSetStart = FALSE;
	long lEnd = -1;
	for( int n = 0; n < m_nMeasures; n++ )
	{
		if( m_pMeasureArray[n].dwFlags & SPMI_SELECTED )
		{
			if( lEnd < n )
			{
				lEnd = n;
			}
			if( !fSetStart )
			{
				fSetStart = TRUE;
				*plStart = n;
			}
		}
	}

	if( !fSetStart )
	{
		*plStart = -1;
		*plEnd = -1;
	}
	else
	{
		m_pTimeline->MeasureBeatToClocks( m_dwGroupBits, 0, *plStart, 0, plStart );
		m_pTimeline->MeasureBeatToClocks( m_dwGroupBits, 0, lEnd, 0, plEnd );
		if( *plEnd <= *plStart )
		{
			*plEnd = *plStart + 1;
		}
	}
}

BOOL CSignPostMgr::DeleteBetweenTimes( long lStart, long lEnd )
{
	ASSERT( lStart >=0 );
	ASSERT( lEnd >= 0 );

	BOOL fChanged = FALSE;

	if( SUCCEEDED( m_pTimeline->ClocksToMeasureBeat( m_dwGroupBits, 0, lStart, &lStart, NULL ) )
	&&  SUCCEEDED( m_pTimeline->ClocksToMeasureBeat( m_dwGroupBits, 0, lEnd, &lEnd, NULL ) ) )
	{
		lEnd = min( lEnd, (m_nMeasures - 1) );
		SignPostExt*	pCE = NULL;
		for( int n=0; n <= lEnd; n++ )
		{
			if( n >= lStart )
			{
				if( n > lEnd )
				{
					break;
				}
				if( m_pMeasureArray[n].pSignPost )
				{
					if( pCE == NULL )
					{
						ASSERT( m_pSignPostList == m_pMeasureArray[n].pSignPost );
						m_pSignPostList = m_pMeasureArray[n].pSignPost->pNext;
					}
					else
					{
						ASSERT( pCE->pNext == m_pMeasureArray[n].pSignPost );
						pCE->pNext = m_pMeasureArray[n].pSignPost->pNext;
					}
					delete m_pMeasureArray[n].pSignPost;
					m_pMeasureArray[n].pSignPost = NULL;
					fChanged = TRUE;
				}
			}
			else
			{
				if( m_pMeasureArray[n].pSignPost )
				{
					pCE = m_pMeasureArray[n].pSignPost;
				}
			}
		}
	}

	return fChanged;
}

void CSignPostMgr::UpdateSegment( void )
{
	ASSERT( m_pTimeline );
	if( m_pTimeline )
	{
		m_pTimeline->OnDataChanged( (IDMUSProdStripMgr *)this );
	}

	SyncWithDirectMusic();
}

short CSignPostMgr::MarkSelectedSignPosts(DWORD flags)
// returns offset of first measure from zero
{
	short	n;
	BOOL	bFirstTime = TRUE;
	short	nOffset = 0;

	//ASSERT(m_pMeasureArray != NULL || m_nMeasures == 0 );
	HRESULT hr = VerifyMeasureArray();
	if (FAILED(hr)) return 0;

	for( n = 0; n < m_nMeasures; n++ )
	{
		if( m_pMeasureArray[n].dwFlags & SPMI_SELECTED )
		{
			if(bFirstTime)
			{
				nOffset = n;
				bFirstTime = FALSE;
			}
			if( m_pMeasureArray[n].pSignPost != NULL )
			{
				m_pMeasureArray[n].pSignPost->dwDragDrop |= flags;
			}
		}
	}
	return nOffset;
}

void CSignPostMgr::DeleteMarkedSignPosts(DWORD dwFlags)
{
	SignPostExt*	pCE = NULL;
	short		n;

	//ASSERT(m_pMeasureArray != NULL || m_nMeasures == 0 );
	HRESULT hr = VerifyMeasureArray();
	if (FAILED(hr)) return;

	for( n = 0; n < m_nMeasures; n++ )
	{
		if( m_pMeasureArray[n].pSignPost != NULL )
		{
			if( m_pMeasureArray[n].pSignPost->dwDragDrop & dwFlags )
			{
				if( pCE == NULL )
				{
					ASSERT( m_pSignPostList == m_pMeasureArray[n].pSignPost );
					m_pSignPostList = m_pMeasureArray[n].pSignPost->pNext;
				}
				else
				{
					ASSERT( pCE->pNext == m_pMeasureArray[n].pSignPost );
					pCE->pNext = m_pMeasureArray[n].pSignPost->pNext;
				}
				delete m_pMeasureArray[n].pSignPost;
				m_pMeasureArray[n].pSignPost = NULL;
			}
			else
			{
				pCE = m_pMeasureArray[n].pSignPost;
			}
		}
		// Leave the measure selected, so the user can still use the selection.
//		m_pMeasureArray[n].dwFlags &= ~CMI_SELECTED;
	}

	if( m_pIPageManager != NULL )
	{
		m_pIPageManager->RefreshData();
	}
//	UpdateSegment();
}

void CSignPostMgr::UnMarkSignPosts(WORD flags)
{
	short		n;
	//ASSERT(m_pMeasureArray != NULL || m_nMeasures == 0 );
	HRESULT hr = VerifyMeasureArray();
	if (FAILED(hr)) return;

	for( n = 0; n < m_nMeasures; n++ )
	{
		if( m_pMeasureArray[n].pSignPost != NULL )
		{
			m_pMeasureArray[n].pSignPost->dwDragDrop &= ~flags;
		}
	}
}

HRESULT CSignPostMgr::SaveDroppedSignPostList( IStream * pStream, BOOL bOnlySelected, short nOffsetMeasure )
{
	HRESULT		hr;
    DWORD		dwSizeSignPost;
	DWORD		cb;
    DMUS_IO_SIGNPOST	iSignPost;
	long		lMeasureLength;

	ASSERT( m_pTimeline != NULL );
	if( m_pTimeline == NULL )
	{
		return E_UNEXPECTED;
	}

	//ASSERT(m_pMeasureArray != NULL );
	hr = VerifyMeasureArray();
	if (FAILED(hr)) return hr;

	if( NULL == pStream )
	{
		return E_INVALIDARG;
	}

	m_pTimeline->MeasureBeatToClocks( m_dwGroupBits, 0, 1, 0, &lMeasureLength );

	// Write the size of the signpost structure
	dwSizeSignPost = sizeof( DMUS_IO_SIGNPOST );
	hr = pStream->Write( &dwSizeSignPost, sizeof( dwSizeSignPost ), &cb );
    if( FAILED( hr ) || cb != sizeof( dwSizeSignPost ))
	{
		return E_FAIL;
	}

	// Write the signposts
	for( short n = 0; n < m_nMeasures; n++ )
	{
		iSignPost.mtTime		= (long) n * lMeasureLength;
		iSignPost.wMeasure		= WORD (n - nOffsetMeasure);
		if( m_pMeasureArray[n].pSignPost != NULL )
		{
			iSignPost.dwChords = m_pMeasureArray[n].pSignPost->dwSignPost;
		}
		else
		{
			iSignPost.dwChords = 0;
		}

		if(( bOnlySelected && ( m_pMeasureArray[n].dwFlags & SPMI_SELECTED )) ||
		   ( !bOnlySelected && (iSignPost.dwChords != 0 )))
		{
			hr = pStream->Write( &iSignPost, sizeof( DMUS_IO_SIGNPOST ), &cb );
			if( FAILED( hr ) || cb != sizeof( DMUS_IO_SIGNPOST ))
			{
				return E_FAIL;
			}
		}
	}
	return S_OK;
}

HRESULT CSignPostMgr::LoadSignPostList(IStream *pStream, long lDropPos, BOOL bDrop, BOOL &fChanged)
{
	HRESULT 		hr = S_OK;

	ASSERT( m_pTimeline );
	if( !m_pTimeline )
	{
		return E_UNEXPECTED;
	}

	ASSERT( pStream );
	if( !pStream )
	{
		return E_POINTER;
	}

	hr = VerifyMeasureArray();
	if (FAILED(hr))
	{
		return hr;
	}

	DWORD			cSize;	// Size of stream
	DWORD			cb; 	// Byte count when reading in data
	long			lDragMeasure = 0;	// measure at which mouse grabbed dragged data
	if( bDrop )
	{
		// Get the size of the stream.
		STATSTG statstg;
		hr = pStream->Stat( &statstg, STATFLAG_NONAME );
		if( FAILED( hr ))
		{
			return hr;
		}

		// Set the initial size
		cSize = statstg.cbSize.LowPart;

		// load drag pt
		hr = pStream->Read(&lDragMeasure, sizeof( long), &cb);
		if( FAILED( hr ) || cb != sizeof( long ) )
		{
			return E_FAIL;
		}

		// Subtract off what we just read
		cSize -= cb;
	}
	else
	{
		// Try and allocate a RIFF Stream
		IDMUSProdRIFFStream* pIRIFFStream;
		if( FAILED( hr = AllocRIFFStream( pStream, &pIRIFFStream ) ) )
		{
			return hr;
		}

		// Descend into the next chunk
		MMCKINFO ck;
		hr = pIRIFFStream->Descend( &ck, NULL, 0 );
		pIRIFFStream->Release();

		// Verify that the descend succeeded, and that we found a SignPost chunk
		if (hr != S_OK || ck.ckid != DMUS_FOURCC_SIGNPOST_TRACK_CHUNK)
		{
			return E_FAIL;
		}

		// Set the initial size
		cSize = ck.cksize;
	}

	// load size of signpost structure
	DWORD dwSizeSignPost;
	hr = pStream->Read( &dwSizeSignPost, sizeof( dwSizeSignPost ), &cb );
	if( FAILED( hr ) || cb != sizeof( dwSizeSignPost ) )
	{
		return E_FAIL;
	}

	cSize -= cb;

	DMUS_IO_SIGNPOST iSignPost;
	LARGE_INTEGER liStreamPos;

	// Save our current position
	DWORD cSizeOrig = cSize;	// Size of stream
	DWORD cCurPos = StreamTell( pStream );

	long lLastMeasure = LONG_MIN;
	while( cSize >= dwSizeSignPost )
	{
		// Read the signpost struct.
		if( dwSizeSignPost > sizeof( DMUS_IO_SIGNPOST ) )
		{
			hr = pStream->Read( &iSignPost, sizeof( DMUS_IO_SIGNPOST ), &cb );
			if( FAILED( hr ) || cb != sizeof( DMUS_IO_SIGNPOST ) )
			{
				return E_FAIL;
			}
			// Seek past the extra data.
			liStreamPos.QuadPart = dwSizeSignPost - sizeof( DMUS_IO_SIGNPOST );
			hr = pStream->Seek( liStreamPos, STREAM_SEEK_CUR, NULL );
			if( FAILED( hr ) )
			{
				return E_FAIL;
			}
		}
		else
		{
			hr = pStream->Read( &iSignPost, dwSizeSignPost, &cb );
			if( FAILED( hr ) || cb != dwSizeSignPost )
			{
				return E_FAIL;
			}
		}

		// If this measure is greater than any previous ones, save it
		if( iSignPost.wMeasure > lLastMeasure )
		{
			lLastMeasure = iSignPost.wMeasure;
		}

		cSize -= dwSizeSignPost;
	}

	// Restore our position back to the start of the signposts
	cSize = cSizeOrig;
	StreamSeek( pStream, cCurPos, STREAM_SEEK_SET );

	BOOL bFirstTime = TRUE;
	long lAdjustMeasure = 0;
	long lMeasure;
	while( cSize >= dwSizeSignPost )
	{
		// Read the signpost struct.
		if( dwSizeSignPost > sizeof( DMUS_IO_SIGNPOST ) )
		{
			hr = pStream->Read( &iSignPost, sizeof( DMUS_IO_SIGNPOST ), &cb );
			if( FAILED( hr ) || cb != sizeof( DMUS_IO_SIGNPOST ) )
			{
				return E_FAIL;
			}
			// Seek past the extra data.
			liStreamPos.QuadPart = dwSizeSignPost - sizeof( DMUS_IO_SIGNPOST );
			hr = pStream->Seek( liStreamPos, STREAM_SEEK_CUR, NULL );
			if( FAILED( hr ) )
			{
				return E_FAIL;
			}
		}
		else
		{
			hr = pStream->Read( &iSignPost, dwSizeSignPost, &cb );
			if( FAILED( hr ) || cb != dwSizeSignPost )
			{
				return E_FAIL;
			}
		}

		// If this is a paste, and we are looking at the first signpost, determine the amount
		// of time the lTime field of each of the signposts being inserted should be shifted.
		if( bFirstTime )
		{
			if( !bDrop )
			{
				if( lDropPos == -1 )
				{
					// In Load() - no adjustment necessary
					lAdjustMeasure = 0;
				}
				else
				{
					// Use position of cursor
					long lTime;
					m_pTimeline->GetMarkerTime(MARKER_CURRENTTIME, TIMETYPE_CLOCKS, &lTime);
					m_pTimeline->ClocksToMeasureBeat(m_dwGroupBits, 0, lTime, &lMeasure, NULL);

					// Adjust the commands so the first one starts in lMeasure
					lAdjustMeasure = lMeasure - iSignPost.wMeasure;
				}
			}
			else
			{
				// If drop position is less than or equal to 0, drop in measure 0
				if(lDropPos <= 0)
				{
					lMeasure = 0;
				}
				else
				{
					m_pTimeline->PositionToMeasureBeat(m_dwGroupBits, 0, lDropPos, &lMeasure, NULL );
				}

				// Adjustment is drop measure - drag measure
				lAdjustMeasure = lMeasure - lDragMeasure;
			}

			// Ensure that the last signpost starts before the end of the segment
			if( lAdjustMeasure + lLastMeasure >= m_nMeasures )
			{
				lAdjustMeasure = m_nMeasures - lLastMeasure - 1;
			}

			// Ensure that the first signpost starts at or after measure 0
			if(  lAdjustMeasure < -iSignPost.wMeasure )
			{
				lAdjustMeasure = -iSignPost.wMeasure;
			}
			bFirstTime = FALSE;
			ClearSelected();
		}

		// Adjust the time of the signpost from the drag and drop measures
		lMeasure = iSignPost.wMeasure + lAdjustMeasure;

		// Should be at least 0
		ASSERT( lMeasure >= 0 );
		if(lMeasure < 0)
		{
			lMeasure = 0;
		}

		// convert measure to a time
		m_pTimeline->MeasureBeatToClocks(m_dwGroupBits, 0, lMeasure, 0, &iSignPost.mtTime);

		cSize -= dwSizeSignPost;

		if( lMeasure >= (long) m_nMeasures )
		{
			break;
		}

		if( iSignPost.dwChords == 0)
		{
			if( bDrop && (m_pMeasureArray[lMeasure].pSignPost != NULL) )
			{
				delete m_pMeasureArray[lMeasure].pSignPost;
				m_pMeasureArray[lMeasure].pSignPost = NULL;
				fChanged = TRUE;
			}
		}
		else
		{
			if( m_pMeasureArray[lMeasure].pSignPost == NULL )
			{
				m_pMeasureArray[lMeasure].pSignPost = new SignPostExt;
				if( m_pMeasureArray[lMeasure].pSignPost == NULL )
				{
					return E_OUTOFMEMORY;
				}
			}
			m_pMeasureArray[lMeasure].pSignPost->lTime	= iSignPost.mtTime;
			m_pMeasureArray[lMeasure].pSignPost->dwSignPost = iSignPost.dwChords;
			UnMarkAtMeasure(lMeasure, DRAG_SELECT);
			fChanged = TRUE;
		}

		m_pMeasureArray[lMeasure].dwFlags |= SPMI_SELECTED;
		m_bSelected = TRUE;
	} // while( cSize > 0 )

	// Update the "next" pointers
	SignPostExt *pSPE = NULL;
	m_pSignPostList = NULL;
	for( short n = 0; n < m_nMeasures; n++ )
	{
		if( m_pMeasureArray[n].pSignPost != NULL )
		{
			if( m_pSignPostList == NULL )
			{
				m_pSignPostList = m_pMeasureArray[n].pSignPost;
			}
			else
			{
				pSPE->pNext = m_pMeasureArray[n].pSignPost;
			}
			pSPE = m_pMeasureArray[n].pSignPost;
			pSPE->pNext = NULL;
		}
	}

	// Update the property page and the object we represent.
	if( m_pIPageManager != NULL )
	{
		m_pIPageManager->RefreshData();
	}

	return S_OK;
}

void CSignPostMgr::UnMarkAtMeasure(DWORD measure, WORD flags)
{
	//ASSERT(m_pMeasureArray != NULL || m_nMeasures == 0 );
	HRESULT hr = VerifyMeasureArray();
	if (FAILED(hr)) return;

	if(m_pMeasureArray[measure].pSignPost != NULL)
	{
		m_pMeasureArray[measure].pSignPost->dwDragDrop &= ~flags;
	}

}

HRESULT CSignPostMgr::ResizeMeasureArray()
{
	HRESULT hr = S_OK;
	VARIANT var;
	long	lMeasureLength;
	long	lTimeLength;
	bool	bSmallerNotLarger;
	hr = m_pTimeline->GetTimelineProperty( TP_CLOCKLENGTH, &var );
	if(hr != S_OK)
	{
		ASSERT(FALSE);
		return E_UNEXPECTED;
	}
	lTimeLength = V_I4( &var );
	hr = m_pTimeline->ClocksToMeasureBeat( m_dwGroupBits, 0, lTimeLength, &lMeasureLength, NULL );
	if(hr != S_OK)
	{
		ASSERT(FALSE);
		return E_UNEXPECTED;
	}
	// Ensure lMeasureLength is at least 1
	lMeasureLength = max( 1, lMeasureLength );
	if( m_nMeasures != (short) lMeasureLength )
	{
		bSmallerNotLarger = (short)lMeasureLength < m_nMeasures;
		SignPostMeasureInfo* pMeasureArray = new SignPostMeasureInfo[lMeasureLength];
		if( m_pMeasureArray == NULL)
		{
			return E_OUTOFMEMORY;
		}
		// copy from the array.
		short nlen = m_nMeasures <= (short)lMeasureLength ? m_nMeasures : (short)lMeasureLength;
		short n = 0;
		for(n = 0; n < nlen; n++)
		{
			pMeasureArray[n].dwFlags = m_pMeasureArray[n].dwFlags;
			pMeasureArray[n].pSignPost = m_pMeasureArray[n].pSignPost;
		}
		// initialize any remaining new measures 
		// (if lMeasure < m_pMeasureArray, then this for loop never entered)
		for( n = nlen; n < (short)lMeasureLength; n++ )
		{
			pMeasureArray[n].dwFlags = 0;
			pMeasureArray[n].pSignPost = NULL;
		}

		m_nMeasures = (short) lMeasureLength;
		delete [] m_pMeasureArray;
		m_pMeasureArray = pMeasureArray;
		if( m_lShiftFromMeasure >= m_nMeasures )
		{
			m_lShiftFromMeasure = m_nMeasures - 1;
		}
		if(hr == S_OK)
		{
			if(bSmallerNotLarger)
			{
				SyncMeasureArray();
			}
			if( m_pSignPostStrip->m_fInAllTracksAdded == FALSE )
			{
				m_pSignPostStrip->m_nLastEdit = IDS_UNDO_CHANGE;
				UpdateSegment();
			}
		}
	}

	return hr;
}

void CSignPostMgr::SyncMeasureArray()
{
	SignPostExt	*pSPE;
	RemoveOrphanSignposts();
	// Update the "next" pointers
	m_pSignPostList = NULL;
	pSPE = NULL;
	for(short n = 0; n < m_nMeasures; n++)
	{
		if(m_pMeasureArray[n].pSignPost != NULL)
		{
			if(m_pSignPostList == NULL)
			{
				m_pSignPostList = m_pMeasureArray[n].pSignPost;
			}
			else
			{
				pSPE->pNext = m_pMeasureArray[n].pSignPost;
			}
			pSPE = m_pMeasureArray[n].pSignPost;
			pSPE->pNext = NULL;
		}
	}
}

void CSignPostMgr::RemoveOrphanSignposts()
// removes signposts that don't have a corresponding measure
// for purposes of this function, signposts with corresponding measures
// are said to be "legal".
{
	SignPostExt* pExt = NULL;
	for(short n = 0; n < m_nMeasures; n++)
	{
		if(m_pMeasureArray[n].pSignPost)
		{
			SignPostExt* p = new SignPostExt;
			memcpy(p, m_pMeasureArray[n].pSignPost, sizeof(SignPostExt));
			p->pNext = 0;
			m_pMeasureArray[n].pSignPost = p;
			if(pExt)
			{
				pExt->pNext = p;
			}
			else
			{
				pExt = p;
			}
		}
	}

	SignPostExt* p = m_pSignPostList;
	while(p)
	{
		SignPostExt* q = p->pNext;
		delete p;
		p = q;
	}
	m_pSignPostList = pExt;
}

void CSignPostMgr::RecalculateMusicTimeValues()
{
	SignPostExt	*pSPE;
	RemoveOrphanSignposts();
	// Update the "next" pointers
	m_pSignPostList = NULL;
	pSPE = NULL;
	for(short n = 0; n < m_nMeasures; n++)
	{
		if(m_pMeasureArray[n].pSignPost != NULL)
		{
			long lTemp;
			m_pTimeline->MeasureBeatToClocks( m_dwGroupBits, 0, n, 0, &lTemp);

			m_pMeasureArray[n].pSignPost->lTime = lTemp;

			if(m_pSignPostList == NULL)
			{
				m_pSignPostList = m_pMeasureArray[n].pSignPost;
			}
			else
			{
				pSPE->pNext = m_pMeasureArray[n].pSignPost;
			}
			pSPE = m_pMeasureArray[n].pSignPost;
			pSPE->pNext = NULL;
		}
	}
}

/*
HRESULT	CSignPostMgr::Compose( void )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( (m_pISegmentNode == NULL) || (m_pIFramework == NULL) )
	{
		return E_UNEXPECTED;
	}

	IDirectMusicSegment *pIDirectMusicSegment;
	if( FAILED( m_pISegmentNode->GetObject( CLSID_DirectMusicSegment, IID_IDirectMusicSegment, (void **)&pIDirectMusicSegment ) ) )
	{
		return E_UNEXPECTED;
	}

	IDirectMusicPerformance *pIDirectMusicPerformance = NULL;
	IDMUSProdComponent* pIComponent;
	if( SUCCEEDED ( m_pIFramework->FindComponent( CLSID_CConductor,  &pIComponent ) ))
	{
		IDMUSProdConductor *pIDMUSProdConductor;
		if( SUCCEEDED( pIComponent->QueryInterface( IID_IDMUSProdConductor, (void**)&pIDMUSProdConductor ) ) )
		{
			IUnknown* punk;
			if( SUCCEEDED( m_pIConductor->GetPerformanceEngine( &punk ) ) )
			{
				punk->QueryInterface( IID_IDirectMusicPerformance, (void **)&pIDirectMusicPerformance );
				punk->Release();
			}
			pIDMUSProdConductor->Release();
		}
		pIComponent->Release();
	}

	if( pIDirectMusicPerformance == NULL) )
	{
		pIDirectMusicSegment->Release();
		return E_UNEXPECTED;
	}

	// Illegal to compose chords while a segment is playing.
	if( pIDirectMusicPerformance->IsPlaying( pIDirectMusicSegment, NULL ) == S_OK )
	{
		pIDirectMusicSegment->Release();
		pIDirectMusicPerformance->Release();
		return E_ABORT;
	}

	IDirectMusicComposer8 *pIDMComposer;
	::CoCreateInstance( CLSID_DirectMusicComposer, NULL, CLSCTX_INPROC, 
					   IID_IDirectMusicComposer8, (void**)&pIDMComposer );
	if( !pIDMComposer )
	{
		pIDirectMusicSegment->Release();
		pIDirectMusicPerformance->Release();
		return E_NOINTERFACE;
	}

	IDirectMusicStyle *pIDMStyle = NULL;
	IDirectMusicChordMap *pIDMChordMap = NULL;

	HRESULT hr = S_OK;
	IDirectMusicSegment* pIDMComposedSegment = NULL;
	IDirectMusicTrack* pIDMTrack = NULL;
	IDirectMusicTrack* pIDMComposedChordTrack = NULL;
	CTrack* pTrack = NULL;
	IPersistStream* pIPersistStream = NULL;
	IStream* pIStream = NULL;
	IDMUSProdStripMgr* pIStripMgr = NULL;
	DWORD dwChordTrackGroup = dwGroupBits;

	// Remove the existing ChordTrack, if any
	if( SUCCEEDED( pIDirectMusicSegment->GetTrack( CLSID_DirectMusicChordTrack, dwGroupBits, 0, &pIDMTrack ) ) )
	{
		pIDirectMusicSegment->GetTrackGroup( pIDMTrack, &dwChordTrackGroup );
		pIDirectMusicSegment->RemoveTrack( pIDMTrack );
	}

	// Compose a segment with a new Chord Track
	DWORD dwComposerFlags = DMUS_COMPOSE_TEMPLATEF_CLONE;
	if( m_wLegacyActivityLevel < 4 )
	{
		dwComposerFlags = DMUS_COMPOSE_TEMPLATEF_CLONE | DMUS_COMPOSE_TEMPLATEF_ACTIVITY;
	}
	hr = pIDMComposer->ComposeSegmentFromTemplateEx( pIDMStyle, pIDirectMusicSegment, dwComposerFlags, m_wLegacyActivityLevel, pIDMChordMap, &pIDMComposedSegment );
	if( FAILED( hr ) )
	{
		if( pIDMTrack )
		{
			// Add the chord track back.
			pIDirectMusicSegment->InsertTrack( pIDMTrack, dwChordTrackGroup );
			UpdateTrackConfig( FindCTrackFromDMTrack( pIDMTrack ) );
		}

		//hr = E_FAIL;
		goto ON_ERROR;
	}

	BOOL fSaved = FALSE;

	if( pIDMTrack )
	{
		// Old chord track exists, update the Chord strip with the new chord track

		// Find the new Chord Track
		if( FAILED( pIDMComposedSegment->GetTrack( CLSID_DirectMusicChordTrack, dwGroupBits, 0, &pIDMComposedChordTrack) ) )
		{
			TRACE("Whoops, can't find a Chord track in a composed segment.\n");
			// Add the chord track back.
			pIDirectMusicSegment->InsertTrack( pIDMTrack, dwChordTrackGroup );
			UpdateTrackConfig( FindCTrackFromDMTrack( pIDMTrack ) );
			hr = S_FALSE;
			goto ON_ERROR;
		}

		// Find the old ChordStrip
		CTrack *pTmpTrack;
		pTmpTrack = NULL;
		POSITION position;
		position = m_lstTracks.GetHeadPosition();
		while(position != NULL)
		{
			pTmpTrack = m_lstTracks.GetNext(position);
			ASSERT( pTmpTrack );
			IDirectMusicTrack* pIDMTmpTrack;
			pTmpTrack->GetDMTrack( &pIDMTmpTrack );
			if( pIDMTmpTrack == pIDMTrack )
			{
				pTmpTrack->SetDMTrack( pIDMComposedChordTrack );
				pIDMTmpTrack->Release();
				pIDMTmpTrack = NULL;

				if( FAILED( pIDirectMusicSegment->InsertTrack( pIDMComposedChordTrack, dwChordTrackGroup ) ) )
				{
					hr = E_UNEXPECTED;
					goto ON_ERROR;
				}
				pTmpTrack->GetStripMgr( &pIStripMgr );
				if( pIStripMgr == NULL )
				{
					hr = E_UNEXPECTED;
					goto ON_ERROR;
				}

				VARIANT varDMTrack;
				varDMTrack.vt = VT_UNKNOWN;
				V_UNKNOWN( &varDMTrack ) = pIDMComposedChordTrack;
				hr = pIStripMgr->SetStripMgrProperty( SMP_IDIRECTMUSICTRACK, varDMTrack );
				if( FAILED( hr ) )
				{
					hr = E_UNEXPECTED;
					goto ON_ERROR;
				}
				if( FAILED( pIStripMgr->QueryInterface( IID_IPersistStream, (void**)&pIPersistStream ) ) )
				{
					hr = E_UNEXPECTED;
					goto ON_ERROR;
				}

				// This causes the ChordStrip to load chords from its attached IDirectMusicTrack.
				if( FAILED( pIPersistStream->Load( NULL ) ) )
				{
					hr = E_UNEXPECTED;
					goto ON_ERROR;
				}

				if( FAILED( m_pIFramework->AllocMemoryStream( FT_DESIGN, GUID_CurrentVersion, &pIStream ) ) )
				{
					hr = E_UNEXPECTED;
					goto ON_ERROR;
				}
				if( FAILED( pIPersistStream->Save( pIStream, TRUE ) ) )
				{
					hr = E_UNEXPECTED;
					goto ON_ERROR;
				}
				UpdateSavedState(fSaved, IDS_UNDO_COMPOSE);
				pTmpTrack->SetStream( pIStream );
			}
			if( pIDMTmpTrack )
			{
				pIDMTmpTrack->Release();
				pIDMTmpTrack = NULL;
			}
		}
	}
	else
	{
		// Created a new Chord Track, add it to the display and our internal list of tracks.
		if( FAILED( pIDMComposedSegment->GetTrack( CLSID_DirectMusicChordTrack, dwGroupBits, 0, &pIDMComposedChordTrack) ) )
		{
			TRACE("Whoops, can't find a Chord track in a composed segment.\n");
			hr = S_FALSE;
			goto ON_ERROR;
		}

		DWORD dwNewChordTrackGroupBits = dwGroupBits;
		if( FAILED( pIDMComposedSegment->GetTrackGroup( pIDMComposedChordTrack, &dwNewChordTrackGroupBits) ) )
		{
			TRACE("CSegment: Whoops, can't find group bits of the compose chord track.\n");
		}

		pTrack = new CTrack();
		if( pTrack == NULL )
		{
			hr = E_UNEXPECTED;
			goto ON_ERROR;
		}

		pTrack->m_dwGroupBits = dwNewChordTrackGroupBits;
		memcpy( &pTrack->m_guidClassID, &CLSID_DirectMusicChordTrack, sizeof( GUID ) );
		if( FAILED( GUIDToStripMgr( pTrack->m_guidClassID, &pTrack->m_guidEditorID ) ) )
		{
			TRACE("Segment::AddTrack: Unable to find Strip Editor for Track's CLSID.\n");
			ASSERT(FALSE); // This shouldn't happen, since GUIDToStripMgr should default
			// to the UnknownStripMgr if it can't find a match in the registry.
			hr = E_UNEXPECTED;
			goto ON_ERROR;
		}

		BOOL fUnknownStripMgr = FALSE;
		hr = ::CoCreateInstance( pTrack->m_guidEditorID, NULL, CLSCTX_INPROC,
								 IID_IDMUSProdStripMgr, (void**)&pIStripMgr );
		if( FAILED( hr ) )
		{
			TRACE("Segment: Unable to CoCreate an IDMUSProdStripMgr - going to try the UnknownStripMgr\n");
			memcpy( &pTrack->m_guidEditorID, &CLSID_UnknownStripMgr, sizeof(GUID) );
			hr = ::CoCreateInstance( pTrack->m_guidEditorID, NULL, CLSCTX_INPROC,
									 IID_IDMUSProdStripMgr, (void**)&pIStripMgr );
			if( FAILED( hr ) )
			{
				TRACE("Segment: Unable to CoCreate an UnknownStripMgr\n");
				hr = E_UNEXPECTED;
				goto ON_ERROR;
			}
			fUnknownStripMgr = TRUE;
		}

		pTrack->SetStripMgr( pIStripMgr );
		pTrack->SetDMTrack( pIDMComposedChordTrack );
		if( FAILED( pIDirectMusicSegment->InsertTrack( pIDMComposedChordTrack, dwNewChordTrackGroupBits ) ) )
		{
			hr = E_UNEXPECTED;
			goto ON_ERROR;
		}

		VARIANT varDMTrack;
		varDMTrack.vt = VT_UNKNOWN;
		V_UNKNOWN( &varDMTrack ) = pIDMComposedChordTrack;
		if( FAILED( pIStripMgr->SetStripMgrProperty( SMP_IDIRECTMUSICTRACK, varDMTrack ) ) )
		{
			hr = E_UNEXPECTED;
			goto ON_ERROR;
		}

		varDMTrack.vt = VT_UNKNOWN;
		V_UNKNOWN( &varDMTrack ) = m_pIFramework;
		if( FAILED( pIStripMgr->SetStripMgrProperty( SMP_IDMUSPRODFRAMEWORK, varDMTrack ) ) )
		{
			hr = E_UNEXPECTED;
			goto ON_ERROR;
		}

		// Tell the strip manager what its group bits are
		DMUS_IO_TRACK_HEADER ioTrackHeader;
		memcpy( &ioTrackHeader.guidClassID, &pTrack->m_guidClassID, sizeof(GUID) );
		ioTrackHeader.dwPosition = pTrack->m_dwPosition;
		ioTrackHeader.dwGroup = pTrack->m_dwGroupBits;
		ioTrackHeader.ckid = pTrack->m_ckid;
		ioTrackHeader.fccType = pTrack->m_fccType;
		varDMTrack.vt = VT_BYREF;
		V_BYREF(&varDMTrack) = &ioTrackHeader;

		if( FAILED( pIStripMgr->SetStripMgrProperty( SMP_DMUSIOTRACKHEADER, varDMTrack ) ) )
		{
			hr = E_UNEXPECTED;
			goto ON_ERROR;
		}


		// The unknown stripmgr doesn't have a way to get the data out of the Chord Track
		if( !fUnknownStripMgr )
		{
			if( FAILED( pIStripMgr->QueryInterface( IID_IPersistStream, (void**)&pIPersistStream ) ) )
			{
				hr = E_UNEXPECTED;
				goto ON_ERROR;
			}

			// This causes the ChordStrip to load chords from its attached IDirectMusicTrack.
			if( FAILED( pIPersistStream->Load( NULL ) ) )
			{
				hr = E_UNEXPECTED;
				goto ON_ERROR;
			}

			if( FAILED( m_pIFramework->AllocMemoryStream( FT_DESIGN, GUID_CurrentVersion, &pIStream ) ) )
			{
				hr = E_UNEXPECTED;
				goto ON_ERROR;
			}
			if( FAILED( pIPersistStream->Save( pIStream, TRUE ) ) )
			{
				hr = E_UNEXPECTED;
				goto ON_ERROR;
			}
			UpdateSavedState(fSaved, IDS_UNDO_COMPOSE);
			pTrack->SetStream( pIStream );
		}

		// Add the track to our list and the dialog (if it exists)
		InsertTrackAtDefaultPos( pTrack );
		//m_lstTracks.AddTail( pTrack );
		if(m_pSegmentDlg != NULL)
		{
			m_pSegmentDlg->AddTrack( pTrack );
		}
	}

ON_ERROR:
	if( FAILED( hr ) )
	{
		if( pTrack )
		{
			delete pTrack;
		}
	}
	if( pIStripMgr )
	{
		pIStripMgr->Release();
	}
	if( pIDMComposedSegment )
	{
		pIDMComposedSegment->Release();
	}
	if( pIDMTrack )
	{
		pIDMTrack->Release();
	}
	if( pIDMComposedChordTrack )
	{
		pIDMComposedChordTrack->Release();
	}
	if( pIPersistStream )
	{
		pIPersistStream->Release();
	}
	if( pIStream )
	{
		pIStream->Release();
	}
	if( pIDMChordMap )
	{
		pIDMChordMap->Release();
	}
	if( pIDMStyle )
	{
		pIDMStyle->Release();
	}
	pIDMComposer->Release();
	return hr;
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SignPostStripMgr\SignPostPPGMgr.h ===
// SignPostPPGMgr.h: interface for the CSignPostPPGMgr class.
//
//////////////////////////////////////////////////////////////////////

#ifndef __SIGNPOSTPPGMGR_H__
#define __SIGNPOSTPPGMGR_H__

// {9E2864D1-EB88-11d0-BAD3-00805F493F43}
static const GUID GUID_SignPostPPGMgr = 
{ 0x9e2864d1, 0xeb88, 0x11d0, { 0xba, 0xd3, 0x0, 0x80, 0x5f, 0x49, 0x3f, 0x43 } };

#include "StaticPropPageManager.h"
#include "SignPostPPG.h"

class CSignPostPPG;

//////////////////////////////////////////////////////////////////////
//  CSignPostPPGMgr

class CSignPostPPGMgr : public CStaticPropPageManager 
{
friend class CSignPostPPG;
public:
	CSignPostPPGMgr();
	virtual ~CSignPostPPGMgr();

    // IDMUSProdPropPageManager functions
	HRESULT STDMETHODCALLTYPE RemoveObject( IDMUSProdPropPageObject* pIPropPageObject );
    HRESULT STDMETHODCALLTYPE GetPropertySheetTitle( BSTR* pbstrTitle, BOOL* pfAddPropertiesText );
    HRESULT STDMETHODCALLTYPE GetPropertySheetPages( IDMUSProdPropSheet* pIPropSheet, LONG* hPropSheetPage[], short* pnNbrPages );
	HRESULT STDMETHODCALLTYPE OnRemoveFromPropertySheet();
    HRESULT STDMETHODCALLTYPE RefreshData();

	// Member variables
private:
	CSignPostPPG				*m_pSignPostPPG;
};

#endif //__SIGNPOSTPPGMGR_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SignPostStripMgr\SignPostPPG.h ===
#if !defined(AFX_SIGNPOSTPPG_H__1A2A29E5_EF4E_11D0_BAD9_00805F493F43__INCLUDED_)
#define AFX_SIGNPOSTPPG_H__1A2A29E5_EF4E_11D0_BAD9_00805F493F43__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// SignPostPPG.h : header file
//

#include <afxctl.h>
#include "resource.h"
#include "stdafx.h"
#include "SignPostPPGMgr.h"
#include "SignPostMgr.h"
#include "SignPostIO.h"

class CSignPostPPGMgr;

/////////////////////////////////////////////////////////////////////////////
// CSignPostPPG dialog

class CSignPostPPG : public CPropertyPage
{
	DECLARE_DYNCREATE(CSignPostPPG)

// Construction
public:
	CSignPostPPG();
	~CSignPostPPG();

// Attributes
	CSignPostPPGMgr	*m_pPageManager;
	PPGSignPost		*m_pSignPostData;

// Functions
	HRESULT SetData(PPGSignPost *pSignPost);

// Dialog Data
	//{{AFX_DATA(CSignPostPPG)
	enum { IDD = IDD_PROPPAGE_SIGNPOSTS };
	CComboBox	m_SignPostDropDownList;
	CButton	m_CadenceCheck;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CSignPostPPG)
	public:
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CSignPostPPG)
	virtual BOOL OnInitDialog();
	afx_msg void OnSignpostCadence();
	afx_msg void OnSelchangeComboSignpost();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SIGNPOSTPPG_H__1A2A29E5_EF4E_11D0_BAD9_00805F493F43__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SignPostStripMgr\SignPostPPGMgr.cpp ===
// SignPostPPGMgr.cpp: implementation of the CSignPostPPGMgr class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "SignPostStripMgr.h"
#include "SignPostIO.h"
#include "SignPostPPGMgr.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

//////////////////////////////////////////////////////////////////////
// CSignPostPPGMgr Construction/Destruction
//////////////////////////////////////////////////////////////////////

CSignPostPPGMgr::CSignPostPPGMgr() : CStaticPropPageManager()
{
	m_pSignPostPPG	= NULL;
	m_GUIDManager	= GUID_SignPostPPGMgr;
}

CSignPostPPGMgr::~CSignPostPPGMgr()
{
	if(m_pSignPostPPG)
	{
		delete m_pSignPostPPG;
	}
}

/////////////////////////////////////////////////////////////////////////////
// CSignPostPPGMgr IDMUSProdPropPageManager implementation

/////////////////////////////////////////////////////////////////////////////
// CSignPostPPGMgr IDMUSProdPropPageManager::GetPropertySheetTitle

HRESULT CSignPostPPGMgr::GetPropertySheetTitle(BSTR* pbstrTitle, BOOL* pfAddPropertiesText)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	if((pbstrTitle == NULL)
	|| (pfAddPropertiesText == NULL))
	{
		return E_POINTER;
	}

	*pfAddPropertiesText = TRUE;

	CString strTitle;

	strTitle.LoadString(IDS_PROPPAGE_SIGNPOST);
	*pbstrTitle = strTitle.AllocSysString();

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CSignPostPPGMgr IDMUSProdPropPageManager::GetPropertySheetPages

HRESULT CSignPostPPGMgr::GetPropertySheetPages(IDMUSProdPropSheet *pIPropSheet, LONG *hPropSheetPage[], short *pnNbrPages)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	if((hPropSheetPage == NULL)
	|| (pnNbrPages == NULL))
	{
		return E_POINTER;
	}

	if(pIPropSheet == NULL)
	{
		return E_INVALIDARG;
	}

	m_pIPropSheet = pIPropSheet;
	m_pIPropSheet->AddRef();

	HPROPSHEETPAGE hPage;

	// If the property page has already been created, get a handle for it.
	if(m_pSignPostPPG)
	{
		hPage = ::CreatePropertySheetPage((LPCPROPSHEETPAGE)&m_pSignPostPPG->m_psp);
		if(hPage)
		{
			hPropSheetPage[0] = (long *) hPage;
			*pnNbrPages = 1;
			return S_OK;
		}
		*pnNbrPages = 0;
		delete m_pSignPostPPG;
		m_pSignPostPPG = NULL;
		return E_OUTOFMEMORY;
	}

	// Otherwise, create a new property page.
	m_pSignPostPPG = new CSignPostPPG();
	if(m_pSignPostPPG)
	{
		m_pSignPostPPG->m_pPageManager = this;
		hPage = ::CreatePropertySheetPage((LPCPROPSHEETPAGE)&m_pSignPostPPG->m_psp);
		if(hPage)
		{
			hPropSheetPage[0] = (long *) hPage;
			*pnNbrPages = 1;
			return S_OK;
		}
		delete m_pSignPostPPG;
		m_pSignPostPPG = NULL;
	}

	// We couldn't create the page
	*pnNbrPages = 0;
	return E_OUTOFMEMORY;
}

/////////////////////////////////////////////////////////////////////////////
// CSignPostPPGMgr IDMUSProdPropPageManager::OnRemoveFromPropertySheet

HRESULT CSignPostPPGMgr::OnRemoveFromPropertySheet()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	HRESULT hr;

	hr = CBasePropPageManager::OnRemoveFromPropertySheet();
	if(FAILED(hr))
	{
		return hr;
	}

	if(m_pIPropSheet)
	{
		m_pIPropSheet->Release();
		m_pIPropSheet = NULL;
	}

	if(m_pSignPostPPG)
	{
		hr = m_pSignPostPPG->SetData(NULL);
	}

	return hr;
}

/////////////////////////////////////////////////////////////////////////////
// CSignPostPPGMgr IDMUSProdPropPageManager::RefreshData

HRESULT CSignPostPPGMgr::RefreshData( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	HRESULT		hr = S_OK;
	PPGSignPost	*pSignPost = NULL;
	
	if(m_pIPropPageObject != NULL)
	{
		hr = m_pIPropPageObject->GetData((void **)&pSignPost);
		if(FAILED(hr))
		{
			return hr;
		}
	}

	if(m_pSignPostPPG)
	{
		hr = m_pSignPostPPG->SetData(pSignPost);
	}

	return hr;
}

/////////////////////////////////////////////////////////////////////////////
// CSignPostPPGMgr IDMUSProdPropPageManager::RemoveObject

HRESULT CSignPostPPGMgr::RemoveObject( IDMUSProdPropPageObject *pIPropPageObject )
{
	HRESULT hr;

	hr = CStaticPropPageManager::RemoveObject(pIPropPageObject);
	if(SUCCEEDED(hr))
	{
		if(m_pSignPostPPG)
		{
			hr = m_pSignPostPPG->SetData(NULL);
		}
	}
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SignPostStripMgr\SignPostStrip.cpp ===
// SignPostStrip.cpp : Implementation of CSignPostStrip
#include "stdafx.h"
#include "SignPostStripMgr.h"
#include "SignPostMgr.h"
#include "SignPostIO.h"
#include "GroupBitsPPG.h"
#include "TrackFlagsPPG.h"
#include "SignPostStripPPG.h"
#include <SegmentGuids.h>
#include "MusicTimeConverter.h"
#include "SegmentIO.h"
#include <dmusicp.h>
#include "GrayOutRect.h"

#define STRIP_HEIGHT 20

interface IPrivateSegment : public IUnknown
{
    public:
        virtual HRESULT STDMETHODCALLTYPE Compose( DWORD dwFlags, DWORD dwActivity ) = 0;
};

CString GetName(DWORD dwGroupBits, CString strName)
{
	CString strText, strTmp;
	BOOL fFoundGroup = FALSE;
	BOOL fLastSet = FALSE;
	int nStartGroup = -1;

	for( int i = 0 ;  i < 32 ;  i++ )
	{
		if( dwGroupBits & (1 << i) )
		{
			if( !fLastSet )
			{
				fLastSet = TRUE;
				nStartGroup = i;
			}
		}
		else
		{
			if( fLastSet )
			{
				fLastSet = FALSE;
				if( nStartGroup == i - 1 )
				{
					if( fFoundGroup )
					{
						strTmp.Format(", %d", i);
					}
					else
					{
						strTmp.Format("%d", i);
						fFoundGroup = TRUE;
					}
				}
				else
				{
					if( fFoundGroup )
					{
						strTmp.Format(", %d-%d", nStartGroup + 1, i);
					}
					else
					{
						strTmp.Format("%d-%d", nStartGroup + 1, i);
						fFoundGroup = TRUE;
					}
				}
				strText += strTmp;
			}
		}
	}

	if( fLastSet )
	{
		fLastSet = FALSE;
		if( nStartGroup == i - 1 )
		{
			if( fFoundGroup )
			{
				strTmp.Format(", %d", i);
			}
			else
			{
				strTmp.Format("%d", i);
				fFoundGroup = TRUE;
			}
		}
		else
		{
			if( fFoundGroup )
			{
				strTmp.Format(", %d-%d", nStartGroup + 1, i);
			}
			else
			{
				strTmp.Format("%d-%d", nStartGroup + 1, i);
				fFoundGroup = TRUE;
			}
		}
		strText += strTmp;
	}

	return strText + CString(": ") + strName;
}

/////////////////////////////////////////////////////////////////////////////
// CSignPostStrip

/////////////////////////////////////////////////////////////////////////////
// CSignPostStrip IUnknown
STDMETHODIMP CSignPostStrip::QueryInterface( REFIID riid, LPVOID *ppv )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	ASSERT(ppv);
    *ppv = NULL;
    if(IsEqualIID(riid, IID_IUnknown))
	{
        *ppv = (IUnknown *) (IDMUSProdStrip *) this;
	}
	else if (IsEqualIID(riid, IID_IDMUSProdStrip))
	{
        *ppv = (IDMUSProdStrip *) this;
	}
	else if (IsEqualIID(riid, IID_IDMUSProdStripFunctionBar))
	{
        *ppv = (IUnknown *) (IDMUSProdStripFunctionBar *) this;
	}
	else if (IsEqualIID(riid, IID_IDMUSProdPropPageObject))
	{
        *ppv = (IUnknown *) (IDMUSProdPropPageObject *) this;
	}
	else if (IsEqualIID(riid, IID_IDMUSProdTimelineEdit))
	{
		*ppv = (IDMUSProdTimelineEdit *) this;
	}
	else if( IsEqualIID( riid, IID_IDropSource ))
	{
		*ppv = (IDropSource*) this;
	}
	else if( IsEqualIID( riid, IID_IDropTarget ))
	{
		*ppv = (IDropTarget*) this;
	}
	else
	{
		return E_NOINTERFACE;
	}
    ((IUnknown *) *ppv)->AddRef();
	return S_OK;
}

STDMETHODIMP_(ULONG) CSignPostStrip::AddRef(void)
{
	return ++m_cRef;
}

STDMETHODIMP_(ULONG) CSignPostStrip::Release(void)
{
	if(0L == --m_cRef)
	{
		delete this;
		return 0;
	}
	else
	{
		return m_cRef;
	}
}

/////////////////////////////////////////////////////////////////////////////
// CSignPostStrip IDMUSProdStrip

CString FormatSignPostString(SignPostExt* pSignPost)
{
	CString strSignPost = "";
	if(pSignPost->dwSignPost & SP_CADENCE)
	{
		strSignPost += "^";
	}
	switch(pSignPost->dwSignPost & (SP_ROOT | SP_LETTER))
	{
		case SP_1 : strSignPost += "1"; break; 
		case SP_2 : strSignPost += "2"; break; 
		case SP_3 : strSignPost += "3"; break; 
		case SP_4 : strSignPost += "4"; break; 
		case SP_5 : strSignPost += "5"; break; 
		case SP_6 : strSignPost += "6"; break; 
		case SP_7 : strSignPost += "7"; break;
		case SP_A : strSignPost += "A"; break;
		case SP_B : strSignPost += "B"; break;
		case SP_C : strSignPost += "C"; break;
		case SP_D : strSignPost += "D"; break;
		case SP_E : strSignPost += "E"; break;
		case SP_F : strSignPost += "F"; break;
		default:	strSignPost  = "" ; break;
	}
	return strSignPost;
}

HRESULT	STDMETHODCALLTYPE CSignPostStrip::Draw(HDC hDC, STRIPVIEW sv, LONG lXOffset )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	UNREFERENCED_PARAMETER(sv);

	CRect			rectHighlight;
	long			lMeasureBeginPosition = 0;
	long			lMeasureEndPosition = 0;
	long			lBeginSelMeasure;
	long			lEndSelMeasure;

	ASSERT(m_pSignPostMgr != NULL && m_pStripMgr != NULL);
	if(m_pSignPostMgr == NULL || m_pStripMgr == NULL)
	{
		return E_UNEXPECTED;
	}

	if( m_pSignPostMgr->m_pTimeline )
	{
		m_pSignPostMgr->m_pTimeline->DrawMusicLines(hDC, ML_DRAW_MEASURE_BEAT, m_pSignPostMgr->m_dwGroupBits, 0, lXOffset);

		CDC			dc;
		if(dc.Attach(hDC))
		{
			// draw the signposts

			CRect		rectClip;
			CString		strSignPost;
			SignPostExt	*pSignPost = m_pSignPostMgr->m_pSignPostList;
			SignPostExt*	pGhostSignPost = NULL;
			long		position;
			long		lMeasure;
			long		lFirstVisibleMeasure, lPartialVisibleMeasure;
			long		lClocks;
			RECT		rectGhost;
			CString		strGhost;

			rectGhost.top = 0;
			rectGhost.bottom = STRIP_HEIGHT;
			rectGhost.left = rectGhost.right = 0;

			::GetClipBox( hDC, &rectClip );
			rectHighlight = rectClip;

			// find first visible measure for ghosting chords
			bool bGhostSignPostCovered = false;	// indicates a real signpost exists where ghost would be
			IDMUSProdTimeline* pTimeline = m_pSignPostMgr->m_pTimeline;
			pTimeline->GetMarkerTime(MARKER_LEFTDISPLAY, TIMETYPE_CLOCKS, &lClocks);
			CMusicTimeConverter cmtFirstVisible(lClocks);
			cmtFirstVisible.GetMeasure(lPartialVisibleMeasure, pTimeline, m_pSignPostMgr->m_dwGroupBits);
			CMusicTimeConverter cmtNearestMeasureBeat(lPartialVisibleMeasure, 0, pTimeline, 
														m_pSignPostMgr->m_dwGroupBits);
			if(cmtNearestMeasureBeat.Time() < cmtFirstVisible.Time())
			{
				lFirstVisibleMeasure = lPartialVisibleMeasure + 1;
			}
			else
			{
				lFirstVisibleMeasure = lPartialVisibleMeasure;
			}

			// find latest signpost before first visible measure
			ASSERT(m_pSignPostMgr->m_pMeasureArray != NULL);
			if(m_pSignPostMgr->m_pMeasureArray == NULL)
			{
				return E_UNEXPECTED;
			}
			for(int idx = lFirstVisibleMeasure - 1; idx >= 0; idx--)
			{
				if(idx >= m_pSignPostMgr->m_nMeasures)
					continue;
				if(m_pSignPostMgr->m_pMeasureArray[idx].pSignPost != NULL)
				{
					pGhostSignPost = m_pSignPostMgr->m_pMeasureArray[idx].pSignPost;
					pGhostSignPost->nMeasure = static_cast<short>(idx & 0xFFFF);
					break;
				}
			}

			if(pGhostSignPost)
			{
				// get rect of signpost, will have to truncate if ghost signpost covers part of 
				// real signpost
				m_pSignPostMgr->m_pTimeline->MeasureBeatToPosition(m_pSignPostMgr->m_dwGroupBits, 0,
																	lFirstVisibleMeasure, 0, &position);
				position++;
				strGhost = FormatSignPostString(pGhostSignPost);
				CSize csize;
				csize = dc.GetTextExtent(strGhost);
				rectGhost.left = position - lXOffset;
				rectGhost.right = rectGhost.left + csize.cx;
			}
			// we'll draw ghost signpost after checking whether real signpost covers it

			while(pSignPost)
			{
				m_pSignPostMgr->m_pTimeline->ClocksToMeasureBeat( m_pSignPostMgr->m_dwGroupBits, 0, pSignPost->lTime, &lMeasure, NULL);

				if(lMeasure == lFirstVisibleMeasure )
				{
					// real signpost covers ghost
					bGhostSignPostCovered = true;
				}

				m_pSignPostMgr->m_pTimeline->ClocksToPosition(pSignPost->lTime, &position);
				position++;

				if(pGhostSignPost)
				{
					// truncate ghost signpost's text so it doesn't cover up real signpost's text
					long lTruePos = position - lXOffset;
					if(lTruePos > rectGhost.left && lTruePos < rectGhost.right)
					{
						rectGhost.right = lTruePos;
					}
				}
				strSignPost = FormatSignPostString(pSignPost);
				::TextOut( hDC, position - lXOffset, 0, LPCSTR(strSignPost), strSignPost.GetLength() );

				pSignPost = pSignPost->pNext;
				if(position - lXOffset > rectClip.right)
				{
					break;
				}
			} // while(pSignPost)

			// now draw ghost signpost
			// but not if original signpost is still showing
			if(!bGhostSignPostCovered && pGhostSignPost)
			{
				long leftMargin = LeftMargin(pTimeline);
				pTimeline->MeasureBeatToPosition(m_pSignPostMgr->m_dwGroupBits, 0,
													pGhostSignPost->nMeasure, 0, &position);
						
				CSize extent = dc.GetTextExtent(strGhost);
				if(!((position + extent.cx) > leftMargin))
				{
					COLORREF cr = dc.SetTextColor(RGB(168, 168, 168));
					dc.DrawText(strGhost, &rectGhost, (DT_LEFT | DT_NOPREFIX));
					dc.SetTextColor(cr);
				}
			}

			// Highlight the selected measures.
			if(m_pSignPostMgr->m_bSelected)
			{
				ASSERT(m_pSignPostMgr->m_pMeasureArray != NULL);
				if(m_pSignPostMgr->m_pMeasureArray == NULL)
				{
					return E_UNEXPECTED;
				}

				short n;

				lBeginSelMeasure = -1;
				lEndSelMeasure = -1;
				for(n = 0; n < m_pSignPostMgr->m_nMeasures; n++)
				{
					if(m_pSignPostMgr->m_pMeasureArray[n].dwFlags & SPMI_SELECTED)
					{
						if(lBeginSelMeasure == -1)
						{
							lBeginSelMeasure = (long) n;
						}
						lEndSelMeasure = (long) n + 1;
					}
					else if(lBeginSelMeasure != -1)
					{
						ASSERT(lEndSelMeasure > lBeginSelMeasure);

						// Highlight the range which just ended.
						m_pSignPostMgr->m_pTimeline->MeasureBeatToPosition( m_pSignPostMgr->m_dwGroupBits, 0, lBeginSelMeasure, 0, &lMeasureBeginPosition);
						m_pSignPostMgr->m_pTimeline->MeasureBeatToPosition( m_pSignPostMgr->m_dwGroupBits, 0, lEndSelMeasure, 0, &lMeasureEndPosition);
						rectHighlight.left = lMeasureBeginPosition - lXOffset;
						rectHighlight.right = lMeasureEndPosition - lXOffset;
						GrayOutRect( hDC, &rectHighlight );
						lBeginSelMeasure = -1;
						lEndSelMeasure = -1;
					}
				}

				if(lBeginSelMeasure != -1)
				{
					// The last measure was highlighted.
					m_pSignPostMgr->m_pTimeline->MeasureBeatToPosition( m_pSignPostMgr->m_dwGroupBits, 0, lBeginSelMeasure, 0, &lMeasureBeginPosition);
					m_pSignPostMgr->m_pTimeline->MeasureBeatToPosition( m_pSignPostMgr->m_dwGroupBits, 0, lEndSelMeasure, 0, &lMeasureEndPosition);
					rectHighlight.left = lMeasureBeginPosition - lXOffset;
					rectHighlight.right = lMeasureEndPosition - lXOffset;
					GrayOutRect( hDC, &rectHighlight );
				}
			}
			dc.Detach();
		}
	}
	return S_OK;
}

HRESULT STDMETHODCALLTYPE CSignPostStrip::GetStripProperty(STRIPPROPERTY sp, VARIANT *pvar)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	if(NULL == pvar)
	{
		return E_POINTER;
	}

	switch(sp)
	{
	case SP_RESIZEABLE:
		pvar->vt = VT_BOOL;
		V_BOOL(pvar) = FALSE;
		break;
	case SP_GUTTERSELECTABLE:
		pvar->vt = VT_BOOL;
		V_BOOL(pvar) = TRUE;
		break;
	case SP_MINMAXABLE:
		pvar->vt = VT_BOOL;
		V_BOOL(pvar) = FALSE;
		break;
	case SP_DEFAULTHEIGHT:
		pvar->vt = VT_INT;
		V_INT(pvar) = STRIP_HEIGHT;
		break;
	case SP_NAME:
		{
			BSTR bstr;
			CString strName;
			strName.LoadString(IDS_FUNCTIONBAR_TEXT);

			CString str = GetName(m_pSignPostMgr->m_dwGroupBits, strName);

			pvar->vt = VT_BSTR;
			try
			{
				bstr = str.AllocSysString();
			}
			catch(CMemoryException*)
			{
				return E_OUTOFMEMORY;
			}
			V_BSTR(pvar) = bstr;
		}
		break;
	case SP_BEGINSELECT:
		pvar->vt = VT_I4;
		V_I4(pvar) = m_lBeginSelect;
		break;
	case SP_ENDSELECT:
		pvar->vt = VT_I4;
		V_I4(pvar) = m_lEndSelect;
		break;

	case SP_STRIPMGR:
		pvar->vt = VT_UNKNOWN;
		if( m_pSignPostMgr )
		{
			m_pSignPostMgr->QueryInterface( IID_IUnknown, (void **) &V_UNKNOWN(pvar) );
		}
		else
		{
			V_UNKNOWN(pvar) = NULL;
		}
		break;

	default:
		return E_FAIL;
	}
	return S_OK;
}

HRESULT STDMETHODCALLTYPE CSignPostStrip::SetStripProperty(STRIPPROPERTY sp, VARIANT var)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	ASSERT(m_pSignPostMgr != NULL);
	if(m_pSignPostMgr == NULL)
	{
		return E_UNEXPECTED;
	}
	ASSERT(m_pSignPostMgr->m_pTimeline != NULL);
	if(m_pSignPostMgr->m_pTimeline == NULL)
	{
		return E_UNEXPECTED;
	}

	switch(sp)
	{
	case SP_BEGINSELECT:
	case SP_ENDSELECT:
		if(var.vt != VT_I4)
		{
			return E_FAIL;
		}
		if(sp == SP_BEGINSELECT)
		{
			m_lBeginSelect = V_I4(&var);
		}
		else
		{
			m_lEndSelect = V_I4(&var);
		}

		if(m_bSelecting)
		{
			break;
		}

		if(m_lBeginSelect == m_lEndSelect)
		{
			if(m_pSignPostMgr->m_bSelected)
			{
				m_pSignPostMgr->ClearSelected();
			}
			m_pSignPostMgr->m_pTimeline->StripInvalidateRect((IDMUSProdStrip *)this, NULL, TRUE);
			break;
		}
		if(m_fSelected)
		{
			m_pSignPostMgr->ClearSelected();
			m_pSignPostMgr->SelectSegment(m_lBeginSelect, m_lEndSelect);
		}
		else if(m_pSignPostMgr->m_bSelected)
		{
			m_pSignPostMgr->ClearSelected();
		}
		else
		{
			break;
		}
		m_pSignPostMgr->m_pTimeline->StripInvalidateRect((IDMUSProdStrip *)this, NULL, TRUE);

		// Update the property page
		if(m_pSignPostMgr->m_pIPageManager != NULL)
		{
			m_pSignPostMgr->m_pIPageManager->RefreshData();
		}
		break;
	case SP_GUTTERSELECT:
		m_fSelected = V_BOOL(&var);
		if(m_lBeginSelect == m_lEndSelect)
		{
			// Selection doesn't change.
			break;
		}
		if(m_fSelected)
		{
			ASSERT(!m_pSignPostMgr->m_bSelected);
			m_pSignPostMgr->SelectSegment(m_lBeginSelect, m_lEndSelect);
		}
		else
		{
			m_pSignPostMgr->ClearSelected();
		}
		m_pSignPostMgr->m_pTimeline->StripInvalidateRect((IDMUSProdStrip *)this, NULL, TRUE);
		break;
	default:
		return E_FAIL;
	}
	return S_OK;
}

HRESULT STDMETHODCALLTYPE CSignPostStrip::OnWMMessage(UINT nMsg, WPARAM wParam, LPARAM lParam, LONG lXPos, LONG lYPos )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	HRESULT			hr = S_FALSE;

	ASSERT(m_pSignPostMgr != NULL);
	if(m_pSignPostMgr == NULL)
	{
		return E_UNEXPECTED;
	}

	ASSERT(m_pSignPostMgr->m_pTimeline != NULL);
	if(m_pSignPostMgr->m_pTimeline == NULL)
	{
		return E_UNEXPECTED;
	}

	switch(nMsg)
	{
	case WM_LBUTTONDOWN:
		m_lMouseXPos = lXPos;
		m_lMouseYPos = lYPos;
		hr = OnLButtonDown( wParam, lXPos, lYPos );
		break;

	case WM_LBUTTONUP:
		m_lXPos = lXPos;
		hr = OnLButtonUp( wParam, lXPos, lYPos );
		break;

	case WM_RBUTTONDOWN:
		// Make sure everything on the timeline is deselected.
		UnselectGutterRange();
		break;

	case WM_RBUTTONUP:
		m_lXPos = lXPos;
		hr = OnRButtonUp( wParam, lXPos, lYPos );
		break;

	case WM_MOUSEMOVE:
		hr = OnMouseMove( wParam, lParam, lXPos, lYPos );
		break;

	case WM_SETFOCUS:
		m_pSignPostMgr->m_lShiftFromMeasure = 0;
		break;

	case WM_COMMAND:
		WORD wNotifyCode;
		WORD wID;

		wNotifyCode	= HIWORD(wParam);	// notification code 
		wID			= LOWORD(wParam);	// item, control, or accelerator identifier 
		switch(wID)
		{
		case ID_VIEW_PROPERTIES:
			// Get a pointer to the property sheet and show it
			IDMUSProdPropSheet*	pIPropSheet;
			if( SUCCEEDED( m_pSignPostMgr->m_pIFramework->QueryInterface( IID_IDMUSProdPropSheet, (void**)&pIPropSheet ) ) )
			{
				pIPropSheet->Show( TRUE );
				pIPropSheet->Release();

				if (!m_fShowGroupProps)
				{
					// Change to the signpost property page
					m_pSignPostMgr->OnShowProperties();
				}
				else
				{
					// Change to our property page
					OnShowProperties();
				}
			}
			hr = S_OK;
			break;
		case ID_EDIT_CUT:
			hr = Cut( NULL );
			break;
		case ID_EDIT_COPY:
			hr = Copy( NULL );
			break;
		case ID_EDIT_DELETE:
			hr = Delete();
			break;
		case ID_EDIT_PASTE:
			if( m_lXPos >= 0 )
			{
				m_bContextMenuPaste = TRUE;
			}
			hr = Paste( NULL );
			m_bContextMenuPaste = FALSE;
			break;
		case ID_EDIT_INSERT:
			hr = Insert();
			m_pSignPostMgr->OnShowProperties();
			if(m_pSignPostMgr->m_pIPageManager != NULL)
			{
				m_pSignPostMgr->m_pIPageManager->RefreshData();
			}
			break;
		case ID_EDIT_SELECT_ALL:
			hr = SelectAll();
			break;
		default:
			break;
		}
		break;

	case WM_CREATE:
		// Get Left and right selection boundaries
		m_fSelected = FALSE;
		m_pSignPostMgr->m_pTimeline->GetMarkerTime( MARKER_BEGINSELECT, TIMETYPE_CLOCKS, &m_lBeginSelect );
		m_pSignPostMgr->m_pTimeline->GetMarkerTime( MARKER_ENDSELECT, TIMETYPE_CLOCKS, &m_lEndSelect );
		m_pSignPostMgr->ClearSelected();
		m_pSignPostMgr->m_lShiftFromMeasure = 0;
		break;

	default:
		break;
	}

	return hr;
}

// IDMUSProdPropPageObject Methods

/////////////////////////////////////////////////////////////////////////////
// CSignPostStrip::GetData

HRESULT CSignPostStrip::GetData( void **ppData )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	if( (ppData == NULL) || (*ppData == NULL) )
	{
		return E_INVALIDARG;
	}

	DWORD *pdwIndex = static_cast<DWORD *>(*ppData);

	switch( *pdwIndex )
	{
	
	case 0:
	{
		// Copy our groupbits to the location pointed to by ppData
		ioGroupBitsPPGData *pGroupBitsPPGData = reinterpret_cast<ioGroupBitsPPGData *>(*ppData);
		pGroupBitsPPGData->dwGroupBits = m_pSignPostMgr->m_dwGroupBits;
		break;
	}

	case 1:
	{
		// Copy our track setting to the location pointed to by ppData
		PPGTrackFlagsParams *pPPGTrackFlagsParams = reinterpret_cast<PPGTrackFlagsParams *>(*ppData);
		pPPGTrackFlagsParams->dwTrackExtrasFlags = m_pSignPostMgr->m_dwTrackExtrasFlags;
		pPPGTrackFlagsParams->dwTrackExtrasMask = TRACKCONFIG_VALID_MASK;
		pPPGTrackFlagsParams->dwProducerOnlyFlags = m_pSignPostMgr->m_dwProducerOnlyFlags;
		pPPGTrackFlagsParams->dwProducerOnlyMask = SEG_PRODUCERONLY_AUDITIONONLY;
		break;
	}

	case 2:
		{
			ioSignPostStripPPG *poSignPostStripPPG = (ioSignPostStripPPG *)*ppData;
			poSignPostStripPPG->dwActivityLevel = m_pSignPostMgr->m_dwActivityLevel;
			break;
		}
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CSignPostStrip::SetData

HRESULT CSignPostStrip::SetData( void *pData )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	if( pData == NULL )
	{
		return E_INVALIDARG;
	}

	DWORD *pdwIndex = static_cast<DWORD *>(pData);
	switch( *pdwIndex )
	{

	case 0:
	{
		ioGroupBitsPPGData *pGroupBitsPPGData = reinterpret_cast<ioGroupBitsPPGData *>(pData);

		// Update our group bits setting, if necessary
		if( pGroupBitsPPGData->dwGroupBits != m_pSignPostMgr->m_dwGroupBits )
		{
			m_pSignPostMgr->m_dwGroupBits = pGroupBitsPPGData->dwGroupBits;

			// Notify our editor that we've changed
			m_nLastEdit = IDS_UNDO_TRACK_GROUP;
			m_pSignPostMgr->UpdateSegment();
		}
		break;
	}

	case 1:
	{
		PPGTrackFlagsParams *pPPGTrackFlagsParams = reinterpret_cast<PPGTrackFlagsParams *>(pData);

		// Update our track extras flags, if necessary
		if( pPPGTrackFlagsParams->dwTrackExtrasFlags != m_pSignPostMgr->m_dwTrackExtrasFlags )
		{
			m_pSignPostMgr->m_dwTrackExtrasFlags = pPPGTrackFlagsParams->dwTrackExtrasFlags;

			// Notify our editor that we've changed
			m_nLastEdit = IDS_UNDO_TRACKEXTRAS;
			m_pSignPostMgr->UpdateSegment();
		}
		// Update our Producer-specific flags, if necessary
		else if( pPPGTrackFlagsParams->dwProducerOnlyFlags != m_pSignPostMgr->m_dwProducerOnlyFlags )
		{
			m_pSignPostMgr->m_dwProducerOnlyFlags = pPPGTrackFlagsParams->dwProducerOnlyFlags;

			// Notify our editor that we've changed
			m_nLastEdit = IDS_UNDO_PRODUCERONLY;
			m_pSignPostMgr->UpdateSegment();
		}
		break;
	}

	case 2:
		{
			ioSignPostStripPPG *piSignPostStripPPG = (ioSignPostStripPPG *)pData;
			m_nLastEdit = IDS_UNDO_ACTIVITYLEVEL;
			m_pSignPostMgr->m_dwActivityLevel = piSignPostStripPPG->dwActivityLevel;
			m_pSignPostMgr->UpdateSegment();
			break;
		}
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CSignPostStrip::OnShowProperties

HRESULT CSignPostStrip::OnShowProperties( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Get a pointer to the Timeline
	if( !m_pSignPostMgr->m_pTimeline )
	{
		ASSERT(FALSE);
		return E_FAIL;
	}

	// Validate m_pSignPostMgr->m_pIFramework
	ASSERT( m_pSignPostMgr->m_pIFramework );

	// Get a pointer to the property sheet
	IDMUSProdPropSheet* pIPropSheet = NULL;
	m_pSignPostMgr->m_pIFramework->QueryInterface( IID_IDMUSProdPropSheet, (void **)&pIPropSheet);
	if( pIPropSheet == NULL )
	{
		ASSERT(FALSE);
		return E_FAIL;
	}

	//  If the property sheet is hidden, exit
	if( pIPropSheet->IsShowing() != S_OK )
	{
		pIPropSheet->Release();
		return S_OK;
	}

	// If our property page is already displayed, exit
	if(m_fPropPageActive)
	{
		ASSERT( m_pPropPageMgr != NULL );
		pIPropSheet->Release();
		return S_OK;
	}

	// Get a reference to our property page manager
	HRESULT hr = S_OK;
	if( m_pPropPageMgr == NULL )
	{
		CSignPostStripPropPageMgr* pPPM = new CSignPostStripPropPageMgr;
		if( NULL == pPPM )
		{
			hr = E_OUTOFMEMORY;
			goto EXIT;
		}
		hr = pPPM->QueryInterface( IID_IDMUSProdPropPageManager, (void**)&m_pPropPageMgr );
		m_pPropPageMgr->Release(); // this releases the 2nd ref, leaving only one
		if( FAILED(hr) )
		{
			goto EXIT;
		}
	}

	// Set the property page to refer to the Group property page.
	short nActiveTab;
	nActiveTab = CSignPostStripPropPageMgr::sm_nActiveTab;
	m_pSignPostMgr->m_pTimeline->SetPropertyPage(m_pPropPageMgr, (IDMUSProdPropPageObject*)this);
	m_fPropPageActive = TRUE;
	pIPropSheet->SetActivePage( nActiveTab ); 

EXIT:
	// release our reference to the property sheet
	pIPropSheet->Release();
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CSignPostStrip::OnRemoveFromPageManager

HRESULT CSignPostStrip::OnRemoveFromPageManager( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	if( m_pPropPageMgr )
	{
		m_pPropPageMgr->SetObject(NULL);
	}
	m_fPropPageActive = FALSE;
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CLyricStrip IDMUSProdStripFunctionBar

/////////////////////////////////////////////////////////////////////////////
// CLyricStrip::FBDraw

HRESULT CSignPostStrip::FBDraw( HDC hDC, STRIPVIEW sv )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	UNREFERENCED_PARAMETER(sv);

	// get function bar rect
	CRect rectFBar;
	VARIANT var;
	var.vt = VT_BYREF;
	V_BYREF(&var) = &rectFBar;
	if (FAILED(m_pSignPostMgr->m_pTimeline->StripGetTimelineProperty((IDMUSProdStrip *)this, STP_FBAR_CLIENT_RECT, &var)))
	{
		return E_FAIL;
	}

	// fix the clipping region
	RECT rectClip;
	::GetClipBox( hDC, &rectClip );

	POINT point;
	::GetWindowOrgEx( hDC, &point );

	rectClip.left -= point.x;
	rectClip.right -= point.x;
	rectClip.top = -point.y;
	rectClip.bottom -= point.y;

	HRGN hRgn;
	hRgn = ::CreateRectRgnIndirect( &rectClip );
	if( !hRgn )
	{
		return E_FAIL;
	}
	::SelectClipRgn( hDC, hRgn );
	::DeleteObject( hRgn );

	::DrawState( hDC, NULL, NULL, LPARAM (m_bmCompose.GetSafeHandle()), NULL,
		rectFBar.right - m_bmCompose.GetBitmapDimension().cx - 3 + m_fComposeButtonDown, m_fComposeButtonDown,
		m_bmCompose.GetBitmapDimension().cx, m_bmCompose.GetBitmapDimension().cy, DST_BITMAP | DSS_NORMAL );

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CLyricStrip::FBOnWMMessage

HRESULT CSignPostStrip::FBOnWMMessage( UINT nMsg, WPARAM wParam, LPARAM lParam, LONG lXPos, LONG lYPos )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	UNREFERENCED_PARAMETER(lParam);
	UNREFERENCED_PARAMETER(wParam);

	// Process the window message
	HRESULT hr = S_OK;
	switch( nMsg )
	{
	case WM_LBUTTONDOWN:
		{
			BOOL fShowProps = TRUE;
			if( lYPos <= m_bmCompose.GetBitmapDimension().cy )
			{
				VARIANT varXS;
				if( SUCCEEDED( m_pSignPostMgr->m_pTimeline->GetTimelineProperty( TP_HORIZONTAL_SCROLL, &varXS ) ) )
				{
					if( lXPos >= V_I4( &varXS ) - m_bmCompose.GetBitmapDimension().cx - 3 )
					{
						if( SUCCEEDED( m_pSignPostMgr->m_pTimeline->GetTimelineProperty( TP_TIMELINECALLBACK, &varXS ) ) )
						{
							IPrivateSegment *pISegment;
							if( SUCCEEDED( V_UNKNOWN( &varXS )->QueryInterface( IID_IPrivateSegment, (void**)&pISegment ) ) )
							{
								fShowProps = FALSE;
								m_fComposeButtonDown = TRUE;

								// capture mouse so we get the LBUTTONUP message as well
								// the timeline will release the capture when it receives the
								// LBUTTONUP message
								VARIANT var;
								var.vt = VT_BOOL;
								V_BOOL(&var) = TRUE;
								m_pSignPostMgr->m_pTimeline->SetTimelineProperty( TP_STRIPMOUSECAPTURE, var );

								m_pSignPostMgr->m_pTimeline->StripInvalidateRect((IDMUSProdStrip *)this, NULL, TRUE);

								// Compose Chords
								hr = pISegment->Compose( m_pSignPostMgr->m_dwActivityLevel < 4 ? DMUS_COMPOSE_TEMPLATEF_ACTIVITY : 0, m_pSignPostMgr->m_dwActivityLevel );
								if( FAILED( hr ) || (hr == S_FALSE) )
								{
									// An argument is wrong (no valid personality and/or style)
									HWND hwndOld;
									CString strWarning;

									// Store the window with the focus so it gets it back.
									hwndOld = ::GetFocus();

									if( hr == E_ABORT )
									{
										// Segment is playing
										strWarning.LoadString(IDS_ERR_COMPOSE_WHILE_PLAYING);
									}
									else if ( hr == S_FALSE )
									{
										// No chords were generated
										strWarning.LoadString(IDS_ERR_COMPOSE_NOCHORDS);
									}
									else if( hr == E_UNEXPECTED )
									{
										// An unexpected error occurred
										strWarning.LoadString(IDS_ERR_COMPOSE_UNEXPECTED);
									}
									else if( hr == E_INVALIDARG )
									{
										// No style and/or no chordmap
										strWarning.LoadString(IDS_ERR_COMPOSE_NOSTYLE_CHORDMAP);
									}
									else if( hr == E_NOINTERFACE )
									{
										// Running on DX7 bits
										strWarning.LoadString(IDS_ERR_COMPOSE_DX8_REQUIRED);
									}
									else
									{
										// Shouldn't happen
										TRACE("SignPost Strip: Received an unknown error code %x\n", hr );
										ASSERT( FALSE );
										strWarning.LoadString(IDS_ERR_COMPOSE_UNEXPECTED);
									}
									AfxMessageBox(strWarning);
//									::MessageBox(NULL, LPCSTR(strWarning), NULL, MB_OK | MB_ICONEXCLAMATION | MB_TASKMODAL);
									::SetFocus(hwndOld);
									hr = S_OK;

									m_fComposeButtonDown = FALSE;
									m_pSignPostMgr->m_pTimeline->StripInvalidateRect((IDMUSProdStrip *)this, NULL, TRUE);
								}
								pISegment->Release();
								V_UNKNOWN( &varXS )->Release();
							}
						}
					}
				}
			}
			if( fShowProps )
			{
				m_fShowGroupProps = TRUE;
				OnShowProperties();
			}
		}
		break;

	case WM_RBUTTONUP:
		m_fShowGroupProps = TRUE;
		OnShowProperties();
		m_lXPos = -1;

		// Display a right-click context menu.
		POINT pt;
		// Get the cursor position (To put the menu there)
		if( !GetCursorPos( &pt ) )
		{
			hr = E_UNEXPECTED;
			break;
		}

		if( m_pSignPostMgr->m_pTimeline )
		{
			m_pSignPostMgr->m_pTimeline->TrackPopupMenu(NULL, pt.x, pt.y, (IDMUSProdStrip *)this, TRUE);
		}
		break;

	case WM_LBUTTONUP:
		if( m_fComposeButtonDown )
		{
			m_fComposeButtonDown = FALSE;
			m_pSignPostMgr->m_pTimeline->StripInvalidateRect((IDMUSProdStrip *)this, NULL, TRUE);
		}
		break;

	default:
		break;
	}
	return hr;
}

void CSignPostStrip::SetEnabledItems(HMENU hMenu)
{
	ASSERT(m_pSignPostMgr != NULL);
	if(m_pSignPostMgr == NULL)
	{
		return;
	}

	EnableMenuItem( hMenu, ID_EDIT_CUT, ( CanCut() == S_OK ) ? MF_ENABLED :
					MF_GRAYED | MF_BYCOMMAND );
	EnableMenuItem( hMenu, ID_EDIT_COPY, ( CanCopy() == S_OK ) ? MF_ENABLED :
					MF_GRAYED | MF_BYCOMMAND );
	EnableMenuItem( hMenu, ID_EDIT_PASTE, ( CanPaste() == S_OK ) ? MF_ENABLED :
					MF_GRAYED | MF_BYCOMMAND );
	EnableMenuItem( hMenu, ID_EDIT_INSERT, ( CanInsert() == S_OK ) ? MF_ENABLED :
					MF_GRAYED | MF_BYCOMMAND );
	EnableMenuItem( hMenu, ID_EDIT_DELETE, ( CanDelete() == S_OK ) ? MF_ENABLED :
					MF_GRAYED | MF_BYCOMMAND );
	EnableMenuItem( hMenu, ID_VIEW_PROPERTIES, m_pSignPostMgr->m_bSelected ? MF_ENABLED :
					MF_GRAYED | MF_BYCOMMAND );
}


void CSignPostStrip::UnselectGutterRange( void )
{
	ASSERT( m_pSignPostMgr->m_pTimeline != NULL );

	// Make sure everything on the timeline is deselected.
	m_bSelecting = TRUE;
	m_pSignPostMgr->m_pTimeline->SetMarkerTime( MARKER_BEGINSELECT, TIMETYPE_CLOCKS, 0 );
	m_pSignPostMgr->m_pTimeline->SetMarkerTime( MARKER_ENDSELECT, TIMETYPE_CLOCKS, 0 );
	m_bSelecting = FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// CSignPostStrip IDMUSProdTimelineEdit

HRESULT CSignPostStrip::Cut( IDMUSProdTimelineDataObject* pITimelineDataObject )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	HRESULT hr;

	hr = CanCut();
	ASSERT(hr == S_OK);
	if(hr != S_OK)
	{
		return E_UNEXPECTED;
	}

	hr = Copy(pITimelineDataObject);
	if(SUCCEEDED(hr))
	{
		hr = Delete();
	}

	return hr;
}

HRESULT CSignPostStrip::Copy(IDMUSProdTimelineDataObject* pITimelineDataObject)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	HRESULT				hr;
	IStream				*pStreamCopy;

	hr = CanCopy();
	ASSERT(hr == S_OK);
	if(hr != S_OK)
	{
		return E_UNEXPECTED;
	}

	ASSERT(m_pSignPostMgr != NULL);
	if(m_pSignPostMgr == NULL)
	{
		return E_UNEXPECTED;
	}

	// If the format hasn't been registered yet, do it now.
	if(m_cfFormat == 0)
	{
		m_cfFormat = RegisterClipboardFormat(CF_SIGNPOST);
		if(m_cfFormat == 0)
		{
			return E_FAIL;
		}
	}

	// Create an IStream to save the selected signposts in.
	hr = CreateStreamOnHGlobal(NULL, TRUE, &pStreamCopy);
	if(FAILED(hr))
	{
		return E_OUTOFMEMORY;
	}

	// Save the signposts into the stream.
	hr = m_pSignPostMgr->SaveSignPostList(pStreamCopy, TRUE, true);
	if(FAILED(hr))
	{
		pStreamCopy->Release();
		return E_UNEXPECTED;
	}

	if(pITimelineDataObject != NULL)
	{
		// add the stream to the passed IDMUSProdTimelineDataObject
		hr = pITimelineDataObject->AddInternalClipFormat( m_cfFormat, pStreamCopy );
		pStreamCopy->Release();
		ASSERT( hr == S_OK );
		if ( hr != S_OK )
		{
			return E_FAIL;
		}
	}
	// Otherwise, add it to the clipboard
	else
	{
		// There is no existing data object, so just create a new one
		hr = m_pSignPostMgr->m_pTimeline->AllocTimelineDataObject( &pITimelineDataObject );
		ASSERT( hr == S_OK );
		if( hr != S_OK )
		{
			return E_FAIL;
		}

		// Set the start and edit time of this copy
		long lStartTime, lEndTime;
		m_pSignPostMgr->GetBoundariesOfSelectedCommands( &lStartTime, &lEndTime );
		hr = pITimelineDataObject->SetBoundaries( lStartTime, lEndTime );

		// add the stream to the IDMUSProdTimelineDataObject
		hr = pITimelineDataObject->AddInternalClipFormat( m_cfFormat, pStreamCopy );

		// Release the IStream we copied into
		pStreamCopy->Release();

		// Exit with an error if we failed to add the stream
		ASSERT( hr == S_OK );
		if ( hr != S_OK )
		{
			pITimelineDataObject->Release();
			return E_FAIL;
		}

		// get the IDataObject to place on the clipboard
		IDataObject* pIDataObject;
		hr = pITimelineDataObject->Export( &pIDataObject );

		// Release the IDMUSProdTimelineDataObject
		pITimelineDataObject->Release();

		// Exit if the export failed
		if( FAILED(hr) )
		{
			return E_UNEXPECTED;
		}

		// Send the IDataObject to the clipboard
		hr = OleSetClipboard( pIDataObject );

		// Exit if we failed to set the clipboard with our data
		if( hr != S_OK )
		{
			// Release the IDataObject
			pIDataObject->Release();
			return E_FAIL;
		}

		// If we already have a CopyDataObject, release it
		if(	m_pSignPostMgr->m_pCopyDataObject )
		{
			m_pSignPostMgr->m_pCopyDataObject->Release();
		}

		// Set m_pCopyDataObject to the object we just copied to the clipboard
		m_pSignPostMgr->m_pCopyDataObject = pIDataObject;

		// Not needed - Object was AddRef()'d when it was exported from the ITimelienDataObject
		//m_pSignPostMgr->m_pCopyDataObject->AddRef();
	}

	return hr;
}

HRESULT CSignPostStrip::Paste(IDMUSProdTimelineDataObject* pITimelineDataObject)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	HRESULT				hr;
	IStream*			pStreamPaste;

	hr = CanPaste( pITimelineDataObject );
	ASSERT(hr == S_OK);
	if(hr != S_OK)
	{
		return E_UNEXPECTED;
	}

	ASSERT(m_pSignPostMgr != NULL);
	if(m_pSignPostMgr == NULL)
	{
		return E_UNEXPECTED;
	}

	ASSERT(m_pSignPostMgr->m_pTimeline != NULL);
	if(m_pSignPostMgr->m_pTimeline == NULL)
	{
		return E_UNEXPECTED;
	}

	// If the format hasn't been registered yet, do it now.
	if(m_cfFormat == 0)
	{
		m_cfFormat = RegisterClipboardFormat(CF_SIGNPOST);
		if(m_cfFormat == 0)
		{
			return E_FAIL;
		}
	}

	if(pITimelineDataObject == NULL)
	{
		// Get the IDataObject from the clipboard
		IDataObject *pIDataObject;
		hr = OleGetClipboard(&pIDataObject);
		if(FAILED(hr) || (pIDataObject == NULL))
		{
			return E_FAIL;
		}

		// Create a new TimelineDataObject
		hr = m_pSignPostMgr->m_pTimeline->AllocTimelineDataObject( &pITimelineDataObject );
		if( FAILED(hr) || (pITimelineDataObject == NULL) )
		{
			pIDataObject->Release();
			return E_FAIL;
		}

		// Insert the IDataObject into the TimelineDataObject
		hr = pITimelineDataObject->Import( pIDataObject );
		pIDataObject->Release();
		if( FAILED(hr) )
		{
			pITimelineDataObject->Release();
			return E_FAIL;
		}
	}
	else
	{
		pITimelineDataObject->AddRef();
	}

	// Determine paste measure
	MUSIC_TIME mtTime;
	long lMeasure, lBeat;
	if( m_bContextMenuPaste )
	{
		m_pSignPostMgr->m_pTimeline->PositionToClocks( m_lXPos, &mtTime );
	}
	else
	{
		if( FAILED( m_pSignPostMgr->m_pTimeline->GetMarkerTime( MARKER_CURRENTTIME, TIMETYPE_CLOCKS, &mtTime ) ) )
		{
			pITimelineDataObject->Release();
			return E_FAIL;
		}
	}
	m_pSignPostMgr->m_pTimeline->ClocksToMeasureBeat( m_pSignPostMgr->m_dwGroupBits, 0, mtTime, &lMeasure, &lBeat );
	m_pSignPostMgr->m_pTimeline->MeasureBeatToClocks( m_pSignPostMgr->m_dwGroupBits, 0, lMeasure, 0, &mtTime );

	hr = pITimelineDataObject->IsClipFormatAvailable(m_cfFormat);
	if(hr != S_OK)
	{
		pITimelineDataObject->Release();
		return E_FAIL;
	}
	
	hr = pITimelineDataObject->AttemptRead(m_cfFormat, &pStreamPaste);
	if(hr != S_OK)
	{
		pITimelineDataObject->Release();
		return E_FAIL;
	}

	// Get the paste type
	TIMELINE_PASTE_TYPE tlPasteType;
	if( FAILED( m_pSignPostMgr->m_pTimeline->GetPasteType( &tlPasteType ) ) )
	{
		pITimelineDataObject->Release();
		return E_FAIL;
	}

	BOOL fChanged = FALSE;

	if( tlPasteType == TL_PASTE_OVERWRITE )
	{
		long lStart, lEnd, lDiff;
		if( SUCCEEDED( pITimelineDataObject->GetBoundaries( &lStart, &lEnd ) ) )
		{
			ASSERT( lStart < lEnd );

			lDiff = lEnd - lStart;
			lStart = mtTime;
			lEnd = lStart + lDiff;

			fChanged = m_pSignPostMgr->DeleteBetweenTimes( lStart, lEnd );
		}
	}
	pITimelineDataObject->Release();
	pITimelineDataObject = NULL;

	// Clear all selections
	m_pSignPostMgr->ClearSelected();

	// Now, do the paste operation
	hr = m_pSignPostMgr->LoadSignPostList( pStreamPaste, 0, FALSE, fChanged );

	pStreamPaste->Release(); 
	if( FAILED( hr ) )
	{
		return E_FAIL;
	}


	if(SUCCEEDED(hr) && fChanged)
	{
		m_nLastEdit = IDS_UNDO_PASTE;
		m_pSignPostMgr->UpdateSegment();
		m_pSignPostMgr->m_pTimeline->StripInvalidateRect((IDMUSProdStrip *)this, NULL, TRUE);
	}

	return S_OK;
}

HRESULT CSignPostStrip::Insert(void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	HRESULT			hr;

	hr = CanInsert();
	ASSERT(hr == S_OK);
	if(hr != S_OK)
	{
		return E_UNEXPECTED;
	}

	ASSERT(m_pSignPostMgr != NULL);
	if(m_pSignPostMgr == NULL)
	{
		return E_UNEXPECTED;
	}

	ASSERT(m_pSignPostMgr->m_pTimeline != NULL);
	if(m_pSignPostMgr->m_pTimeline == NULL)
	{
		return E_UNEXPECTED;
	}

	// Make sure everything on the timeline is deselected.
	UnselectGutterRange();

	m_nLastEdit = IDS_UNDO_INSERT;
	hr = m_pSignPostMgr->InsertSignPost(-1);	// Insert at first selected.
	m_pSignPostMgr->m_pTimeline->StripInvalidateRect((IDMUSProdStrip *)this, NULL, TRUE);

	return hr;
}

HRESULT CSignPostStrip::Delete(void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	/* Ignore this, since we can be in a Cut() operation.  We can cut blank data, but we can't delete it.
	HRESULT hr = CanDelete();
	ASSERT(hr == S_OK);
	if(hr != S_OK)
	{
		return E_UNEXPECTED;
	}
	*/

	ASSERT(m_pSignPostMgr != NULL);
	if(m_pSignPostMgr == NULL)
	{
		return E_UNEXPECTED;
	}

	ASSERT(m_pSignPostMgr->m_pTimeline != NULL);
	if(m_pSignPostMgr->m_pTimeline == NULL)
	{
		return E_UNEXPECTED;
	}

	m_nLastEdit = IDS_UNDO_DELETE;
	m_pSignPostMgr->DeleteSelected();
	m_pSignPostMgr->m_pTimeline->StripInvalidateRect((IDMUSProdStrip *)this, NULL, TRUE);

	return S_OK;
}

HRESULT CSignPostStrip::SelectAll(void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	ASSERT(m_pSignPostMgr != NULL);
	if(m_pSignPostMgr == NULL)
	{
		return E_UNEXPECTED;
	}

	ASSERT(m_pSignPostMgr->m_pTimeline != NULL);
	if(m_pSignPostMgr->m_pTimeline == NULL)
	{
		return E_UNEXPECTED;
	}

	m_pSignPostMgr->SelectAll();

	m_pSignPostMgr->m_pTimeline->StripInvalidateRect((IDMUSProdStrip *)this, NULL, TRUE);
	if(m_pSignPostMgr->m_pIPageManager != NULL)
	{
		m_pSignPostMgr->m_pIPageManager->RefreshData();
	}
	
	return S_OK;
}

HRESULT CSignPostStrip::CanCut(void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	ASSERT(m_pSignPostMgr != NULL);
	if(m_pSignPostMgr == NULL)
	{
		return E_UNEXPECTED;
	}

	// If our gutter is selected, and the user selected a range of time in the time strip,
	// we can cut even if nothing is selected.
	VARIANT variant;
	long lTimeStart, lTimeEnd;
	if( SUCCEEDED( m_pSignPostMgr->m_pTimeline->StripGetTimelineProperty( this, STP_GUTTER_SELECTED, &variant ) )
	&&	(V_BOOL( &variant ) == TRUE)
	&&	SUCCEEDED( m_pSignPostMgr->m_pTimeline->GetMarkerTime( MARKER_BEGINSELECT, TIMETYPE_CLOCKS, &lTimeStart ) )
	&&	(lTimeStart >= 0)
	&&	SUCCEEDED( m_pSignPostMgr->m_pTimeline->GetMarkerTime( MARKER_ENDSELECT, TIMETYPE_CLOCKS, &lTimeEnd ) )
	&&	(lTimeEnd > lTimeStart) )
	{
		return S_OK;
	}

	if(CanCopy() == S_OK && CanDelete() == S_OK)
	{
		return S_OK;
	}
	else
	{
		return S_FALSE;
	}
}

HRESULT CSignPostStrip::CanCopy(void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	ASSERT(m_pSignPostMgr != NULL);
	if(m_pSignPostMgr == NULL)
	{
		return E_UNEXPECTED;
	}

	// If our gutter is selected, and the user selected a range of time in the time strip,
	// we can cut even if nothing is selected.
	VARIANT variant;
	long lTimeStart, lTimeEnd;
	if( SUCCEEDED( m_pSignPostMgr->m_pTimeline->StripGetTimelineProperty( this, STP_GUTTER_SELECTED, &variant ) )
	&&	(V_BOOL( &variant ) == TRUE)
	&&	SUCCEEDED( m_pSignPostMgr->m_pTimeline->GetMarkerTime( MARKER_BEGINSELECT, TIMETYPE_CLOCKS, &lTimeStart ) )
	&&	(lTimeStart >= 0)
	&&	SUCCEEDED( m_pSignPostMgr->m_pTimeline->GetMarkerTime( MARKER_ENDSELECT, TIMETYPE_CLOCKS, &lTimeEnd ) )
	&&	(lTimeEnd > lTimeStart) )
	{
		return S_OK;
	}

	//return m_pSignPostMgr->m_bSelected ? S_OK : S_FALSE;
	if (m_pSignPostMgr->m_bSelected)
	{
		SignPostExt* pSignPost = m_pSignPostMgr->GetFirstSelectedSignPost();
		return pSignPost == NULL ? S_FALSE : S_OK;
	}
	else return S_FALSE;
}

HRESULT CSignPostStrip::CanPaste( IDMUSProdTimelineDataObject* pITimelineDataObject )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	HRESULT				hr = S_OK;

	ASSERT(m_pSignPostMgr != NULL);
	if(m_pSignPostMgr == NULL)
	{
		return E_UNEXPECTED;
	}

	// If the format hasn't been registered yet, do it now.
	if(m_cfFormat == 0)
	{
		m_cfFormat = RegisterClipboardFormat(CF_SIGNPOST);
		if(m_cfFormat == 0)
		{
			return E_FAIL;
		}
	}

	// If pITimelineDataObject != NULL, check it.
	if( pITimelineDataObject != NULL )
	{
		hr = pITimelineDataObject->IsClipFormatAvailable( m_cfFormat );
	}
	// Otherwise, check the clipboard
	else
	{
		// Get the IDataObject from the clipboard
		IDataObject *pIDataObject;
		if( SUCCEEDED( OleGetClipboard(&pIDataObject) ) )
		{
			// Create a new TimelineDataObject
			IDMUSProdTimelineDataObject *pITimelineDataObject;
			if( SUCCEEDED( m_pSignPostMgr->m_pTimeline->AllocTimelineDataObject( &pITimelineDataObject ) ) )
			{
				// Insert the IDataObject into the TimelineDataObject
				if( SUCCEEDED( pITimelineDataObject->Import( pIDataObject ) ) )
				{
					hr = pITimelineDataObject->IsClipFormatAvailable(m_cfFormat);
				}
				pITimelineDataObject->Release();
			}
			pIDataObject->Release();
		}
	}

	if (hr == S_OK)
	{
		return S_OK;
	}

	return S_FALSE;
}

HRESULT CSignPostStrip::CanInsert(void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	ASSERT(m_pSignPostMgr != NULL);
	if(m_pSignPostMgr == NULL)
	{
		return E_UNEXPECTED;
	}

	//return m_pSignPostMgr->m_bSelected ? S_OK : S_FALSE;
	if (m_pSignPostMgr->m_bSelected)
	{
		SignPostExt* pSignPost = m_pSignPostMgr->GetFirstSelectedSignPost();
		return pSignPost == NULL ? S_OK : S_FALSE;
	}
	else return S_FALSE;
}

HRESULT CSignPostStrip::CanDelete(void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	ASSERT(m_pSignPostMgr != NULL);
	if(m_pSignPostMgr == NULL)
	{
		return E_UNEXPECTED;
	}

	//return m_pSignPostMgr->m_bSelected ? S_OK : S_FALSE;
	if (m_pSignPostMgr->m_bSelected)
	{
		SignPostExt* pSignPost = m_pSignPostMgr->GetFirstSelectedSignPost();
		return pSignPost == NULL ? S_FALSE : S_OK;
	}
	else return S_FALSE;
}

HRESULT CSignPostStrip::CanSelectAll(void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	for(int n = 0; n < m_pSignPostMgr->m_nMeasures; n++)
	{
		if( m_pSignPostMgr->m_pMeasureArray[n].pSignPost )
		{
			return S_OK;
		}
	}
	return S_FALSE;
}


//////////////////////////////////////////////////////////////////////////////// drag drop methods
////////
////////

HRESULT CSignPostStrip::DoDragDrop(WPARAM mousekeybutton, LONG lXPos, long lmeasure)
{
	HRESULT hr;
	BOOL bDrop = FALSE;
	IDropSource*	pIDropSource;
	DWORD			dwEffect = DROPEFFECT_NONE;
	if(SUCCEEDED(QueryInterface(IID_IDropSource, (void**)&pIDropSource)))
	{
		// create data object and image
		hr = CreateDataObject(&m_pISourceDataObject, lmeasure);
		if(SUCCEEDED(hr))
		{
			bDrop = TRUE;
			m_nStripIsDragDropSource = 1;	

			m_pDragImage = CreateDragImage();
			if(m_pDragImage)
			{
				m_pDragImage->BeginDrag(0, CPoint(8,12));
			}
			// start drag drop
			DWORD dwOKDragEffects = DROPEFFECT_COPY;
			if(CanCut() == S_OK)
			{
				dwOKDragEffects |= DROPEFFECT_MOVE;
			}
			m_dwStartDragButton = (unsigned long)mousekeybutton;
			m_startDragPosition = lXPos;
			hr = ::DoDragDrop(m_pISourceDataObject, pIDropSource, dwOKDragEffects, &dwEffect);

			// drag drop completed, clean up
			m_dwStartDragButton = 0;
			if(m_pDragImage)
			{
				m_pDragImage->EndDrag();
				delete m_pDragImage;
				m_pDragImage = NULL;
			}
			switch(hr)
			{
			case DRAGDROP_S_DROP:
				if(dwEffect & DROPEFFECT_MOVE)
				{
					m_pSignPostMgr->DeleteMarkedSignPosts(DRAG_SELECT);
				}
				if(dwEffect == DROPEFFECT_NONE)
				{
					bDrop = FALSE;
				}
				break;
			default:
				bDrop = FALSE;
				break;
			}
			hr = S_OK;
			m_pISourceDataObject->Release();
			m_pISourceDataObject = NULL;
		}
		pIDropSource->Release();
		m_pSignPostMgr->UnMarkSignPosts(DRAG_SELECT);
	}
	else
	{
		m_nStripIsDragDropSource = 0;	
		hr = E_FAIL;
	}

	if(bDrop)
	{
		if( dwEffect != DROPEFFECT_NONE )
		{
			if( m_nStripIsDragDropSource == 2 )
			{
				// Drag/drop target and source are the same PersRef strip
				if( dwEffect == DROPEFFECT_MOVE )
				{
					m_nLastEdit = IDS_UNDO_MOVE;
				}
				else
				{
					m_nLastEdit = IDS_UNDO_PASTE;
				}
				m_pSignPostMgr->UpdateSegment();
			}
			else
			{
				if( dwEffect == DROPEFFECT_MOVE )
				{
					m_nLastEdit = IDS_UNDO_DELETE;
					m_pSignPostMgr->UpdateSegment();
				}
			}

		}
		
		// Done with drag/drop
		m_nStripIsDragDropSource = 0;

		m_pSignPostMgr->m_pTimeline->StripInvalidateRect((IDMUSProdStrip *)this, NULL, TRUE);
		m_pSignPostMgr->OnShowProperties();
		// BUGBUG: I don't think this is necessary
		
	}
	return hr;
}

// IDropSource Methods
HRESULT CSignPostStrip::QueryContinueDrag( BOOL fEscapePressed, DWORD grfKeyState )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
 
	if( fEscapePressed )
	{
        return DRAGDROP_S_CANCEL;
	}

	if( m_dwStartDragButton & MK_LBUTTON )
	{
		if( grfKeyState & MK_RBUTTON )
		{
			return DRAGDROP_S_CANCEL;
		}

		if( !(grfKeyState & MK_LBUTTON) )
		{
			return DRAGDROP_S_DROP;
		}
	}

	if( m_dwStartDragButton & MK_RBUTTON )
	{
		if( grfKeyState & MK_LBUTTON )
		{
			return DRAGDROP_S_CANCEL;
		}
		
		if( !(grfKeyState & MK_RBUTTON) )
		{
			return DRAGDROP_S_DROP;
		}
	}

	return S_OK;
}

HRESULT CSignPostStrip::GiveFeedback( DWORD dwEffect )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	UNREFERENCED_PARAMETER(dwEffect);

	if( m_pDragImage )
	{
		CPoint pt;

		GetCursorPos( &pt );

		// Move the drag image
		m_pDragImage->DragMove( pt );
	}

	return DRAGDROP_S_USEDEFAULTCURSORS;
}

CImageList* CSignPostStrip::CreateDragImage()
{
	return NULL;
}

HRESULT	CSignPostStrip::CreateDataObject(IDataObject** ppIDataObject, long measure)
{
	if( ppIDataObject == NULL )
	{
		return E_POINTER;
	}

	ASSERT( m_pSignPostMgr != NULL );
	if( m_pSignPostMgr == NULL )
	{
		return E_UNEXPECTED;
	}

	ASSERT( m_pSignPostMgr->m_pTimeline != NULL );
	if( m_pSignPostMgr->m_pTimeline == NULL )
	{
		return E_UNEXPECTED;
	}

	// Validate m_pSignPostMgr->m_pIFramework
	ASSERT( m_pSignPostMgr->m_pIFramework );

	*ppIDataObject = NULL;

	// Create the CDllJazzDataObject 
	CDllJazzDataObject* pDataObject = new CDllJazzDataObject();
	if( pDataObject == NULL )
	{
		return E_OUTOFMEMORY;
	}

	IStream* pIStream;

	// Save Selected SignPosts into stream
	HRESULT hr = E_FAIL;


	if( SUCCEEDED ( m_pSignPostMgr->m_pIFramework->AllocMemoryStream(FT_DESIGN, GUID_CurrentVersion, &pIStream) ) )
	{

		// mark the chords as being dragged: this used later for deleting chords in drag move
		// make sure that if this strip is drop target that they get deselected!
		short nZeroOffset = m_pSignPostMgr->MarkSelectedSignPosts(DRAG_SELECT);
		measure -= nZeroOffset;
		// write measure at which mouse grabbed drag selection into the stream
		DWORD cb;
		hr = pIStream->Write( &measure, sizeof( long ), &cb );
	    if( FAILED( hr ) || cb != sizeof( long ))
		{
			hr = E_FAIL;
			goto Leave;
		}


		if( SUCCEEDED ( m_pSignPostMgr->SaveDroppedSignPostList( pIStream, TRUE, nZeroOffset ) ) )
		{
			// Place CF_SignPostLIST into CDllJazzDataObject
			if( SUCCEEDED ( pDataObject->AddClipFormat( m_cfFormat, pIStream ) ) )
			{
				hr = S_OK;
			}
		}

		pIStream->Release();
	}

Leave:
	if( SUCCEEDED ( hr ) )
	{
		*ppIDataObject = pDataObject;	// already AddRef'd
	}
	else
	{
		pDataObject->Release();
	}

	return hr;

}

/////////////////////////////////////////////////// IDropTarget Methods

/////////////////////////////////////////////////////////////////////////////
// IDropTarget CSignPostStrip::DragEnter

HRESULT CSignPostStrip::DragEnter( IDataObject* pIDataObject, DWORD grfKeyState, POINTL pt, DWORD* pdwEffect )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	//TRACE("CSignPostStrip Drag Enter!\n");
	ASSERT( pIDataObject != NULL );
	ASSERT( m_pITargetDataObject == NULL );

	// Store IDataObject associated with current drag-drop operation
	m_pITargetDataObject = pIDataObject;
	m_pITargetDataObject->AddRef();

	if( m_pDragImage )
	{
		CPoint point( pt.x, pt.y );

		// Show the feedback image
		m_pDragImage->DragEnter( GetTimelineCWnd()->GetDesktopWindow (), point );
	}
/*
	// Make sure editor is on top
	if( m_pStyle->m_hWndEditor )
	{
		::BringWindowToTop( m_pStyle->m_hWndEditor );
	}
*/
	// Determine effect of drop
	return DragOver( grfKeyState, pt, pdwEffect );
}


/////////////////////////////////////////////////////////////////////////////
// IDropTarget CSignPostStrip::DragOver

HRESULT CSignPostStrip::DragOver( DWORD grfKeyState, POINTL pt, DWORD* pdwEffect)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	UNREFERENCED_PARAMETER(pt);

	//TRACE("CSignPostStrip Drag OVER!\n");
	if(m_pITargetDataObject == NULL)
		ASSERT( m_pITargetDataObject != NULL );

	if( m_pDragImage )
	{
		// Hide the feedback image
		m_pDragImage->DragShowNolock( FALSE );
	}

	// Determine effect of drop
	DWORD dwEffect = DROPEFFECT_NONE;

	LONG lLeftSide;
	if( (pt.x >= 0) &&
		SUCCEEDED( m_pSignPostMgr->m_pTimeline->GetMarkerTime( MARKER_LEFTDISPLAY, TIMETYPE_CLOCKS, &lLeftSide ) ) &&
		SUCCEEDED( m_pSignPostMgr->m_pTimeline->ClocksToPosition( lLeftSide, &lLeftSide ) ) &&
		(pt.x >= lLeftSide) && (CanPasteFromData( m_pITargetDataObject ) == S_OK) )
	{

		if( grfKeyState & MK_RBUTTON )
		{
			dwEffect = *pdwEffect;
		}
		else
		{
			if( grfKeyState & MK_CONTROL )
			{
				dwEffect = DROPEFFECT_COPY;
			}
			else
			{
				if( *pdwEffect & DROPEFFECT_COPY
				&&  *pdwEffect & DROPEFFECT_MOVE )
				{
					dwEffect = DROPEFFECT_MOVE;
				}
				else
				{
					dwEffect = *pdwEffect;
				}
			}
		}
	}

	if( m_pDragImage )
	{
		// Show the feedback image
		m_pDragImage->DragShowNolock( TRUE );
	}

	// Set temp drag over fields
	if( grfKeyState & (MK_RBUTTON | MK_LBUTTON) )
	{
		m_dwOverDragButton = grfKeyState & (MK_RBUTTON | MK_LBUTTON);
		m_dwOverDragEffect = dwEffect;
	}

	*pdwEffect = dwEffect;
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// IDropTarget CSignPostStrip::DragLeave

HRESULT CSignPostStrip::DragLeave( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	//TRACE("CSignPostStrip Drag Leave!\n");

	// Release IDataObject
	if( m_pITargetDataObject )
	{
		m_pITargetDataObject->Release();
		m_pITargetDataObject = NULL;
	}

	if( m_pDragImage )
	{
		// Hide the feedback image
		m_pDragImage->DragLeave( GetTimelineCWnd()->GetDesktopWindow () );
	}

	//Reset temp drag over fields
	m_dwOverDragButton = 0;
	m_dwOverDragEffect = 0;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// IDropTarget CSignPostStrip::Drop

HRESULT CSignPostStrip::Drop( IDataObject* pIDataObject, DWORD grfKeyState, POINTL pt, DWORD* pdwEffect)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	UNREFERENCED_PARAMETER(grfKeyState);

	ASSERT( m_pITargetDataObject != NULL );
	ASSERT( m_pITargetDataObject == pIDataObject );

	if( m_pDragImage )
	{
		// Hide the feedback image
		m_pDragImage->DragLeave( GetTimelineCWnd()->GetDesktopWindow () );
	}

	// Set default values
	HRESULT hr = S_OK;
	*pdwEffect = DROPEFFECT_NONE;

	// Choose effect when right mouse drag - Move, Copy, or Cancel?
	if( m_dwOverDragButton & MK_RBUTTON )
	{
		HMENU hMenu;
		HMENU hMenuPopup;
		
		// Display arrow cursor
		::LoadCursor( AfxGetInstanceHandle(), IDC_ARROW );
	
		// Prepare context menu
		hMenu = ::LoadMenu( AfxGetInstanceHandle(), MAKEINTRESOURCE(IDM_DRAG_RMENU) );
		if( hMenu )
		{
			m_dwDragRMenuEffect = DROPEFFECT_NONE;

			// Track right context menu for drag-drop via TrackPopupMenu
			hMenuPopup = ::GetSubMenu( hMenu, 0 );

			// Init state of menu items
			if( !(m_dwOverDragEffect & DROPEFFECT_MOVE) )
			{
				::EnableMenuItem( hMenuPopup, IDM_DRAG_MOVE, (MF_GRAYED | MF_BYCOMMAND) );
			}

			// Get a window to attach menu to
			CWnd* pWnd = GetTimelineCWnd();
			if(pWnd)
			{
				// Display and track menu
				CPoint point( pt.x, pt.y );
				::TrackPopupMenu( hMenuPopup, (TPM_LEFTALIGN | TPM_RIGHTBUTTON),
							  point.x, point.y, 0, pWnd->GetSafeHwnd(), NULL );
				DestroyMenu( hMenu );

				// Need to process WM_COMMAND from TrackPopupMenu
				MSG msg;
				while( ::PeekMessage( &msg, pWnd->GetSafeHwnd(), NULL, NULL, PM_REMOVE) )
				{
					if( msg.message == WM_COMMAND )
					{
						OnWMMessage( msg.message, msg.wParam, msg.lParam, 0, 0 );
					}
					else
					{
						TranslateMessage( &msg );
						DispatchMessage( &msg );
					}
				}

				// WM_COMMAND from TrackPopupMenu will have set m_dwDragRMenuEffect
				m_dwOverDragEffect = m_dwDragRMenuEffect;
				m_dwDragRMenuEffect = DROPEFFECT_NONE;
			}
		}
	}

	// Paste data
	if( m_dwOverDragEffect != DROPEFFECT_NONE )
	{
		hr = PasteAt( pIDataObject, pt );
		if( SUCCEEDED ( hr ) )
		{
			*pdwEffect = m_dwOverDragEffect;
		}
	}

	// Cleanup
	DragLeave();

	return hr;
}



CWnd* CSignPostStrip::GetTimelineCWnd()
{
	CDC cDC;
	VARIANT vt;
	vt.vt = VT_I4;

	CWnd* pWnd = 0;

	// Get the DC of our Strip
	if( m_pSignPostMgr->m_pTimeline )
	{
		if( SUCCEEDED(m_pSignPostMgr->m_pTimeline->StripGetTimelineProperty( this, STP_GET_HDC, &vt )) )
		{
			if( cDC.Attach( (HDC)(vt.lVal) ) != 0 )
			{
				pWnd = cDC.GetWindow();
				cDC.Detach();
			}
			if( pWnd )
			{
				::ReleaseDC( pWnd->GetSafeHwnd(), (HDC)(vt.lVal) );
			}
			else
			{
				::ReleaseDC( NULL, (HDC)(vt.lVal) );
			}
		}
	}
	return pWnd;
}


/////////////////////////////////////////////////////////// Drop (and paste) helpers
//
HRESULT CSignPostStrip::CanPasteFromData(IDataObject* pIDataObject)
{
	if( pIDataObject == NULL )
	{
		return E_INVALIDARG;
	}

	// Create a new CDllJazzDataObject and see if it can read the data object's format.
	CDllJazzDataObject* pDataObject = new CDllJazzDataObject();
	if( pDataObject == NULL )
	{
		return E_OUTOFMEMORY;
	}

	HRESULT hr = S_FALSE;
	
	if( SUCCEEDED (	pDataObject->IsClipFormatAvailable( pIDataObject, m_cfFormat ) ))
	{
		hr = S_OK;
	}

	pDataObject->Release();
	return hr;
}



HRESULT CSignPostStrip::PasteAt(IDataObject* pIDataObject, POINTL pt)
{
	if( pIDataObject == NULL )
	{
		return E_NOTIMPL;
	}

	// Create a new CDllJazzDataObject to get the data object's stream.
	CDllJazzDataObject* pDataObject = new CDllJazzDataObject();
	if( pDataObject == NULL )
	{
		return E_OUTOFMEMORY;
	}

	HRESULT hr = E_FAIL;

	if( SUCCEEDED (	pDataObject->IsClipFormatAvailable( pIDataObject, m_cfFormat ) ) )
	{
		IStream* pIStream;
		if(SUCCEEDED (pDataObject->AttemptRead( pIDataObject, m_cfFormat, &pIStream)))
		{
			LARGE_INTEGER liTemp;
			// seek to beginning of stream
			liTemp.QuadPart = 0;
			pIStream->Seek(liTemp, STREAM_SEEK_SET, NULL);

			BOOL fChanged = FALSE;
			
			hr = m_pSignPostMgr->LoadSignPostList( pIStream, pt.x, TRUE, fChanged );
			
			if( m_nStripIsDragDropSource )
			{
				// Drag/drop Target and Source are the same StyleRef strip
				m_nStripIsDragDropSource = 2;
			}
			else
			{
				if( fChanged )
				{
					m_nLastEdit = IDS_UNDO_PASTE;
					m_pSignPostMgr->UpdateSegment();
					UnselectGutterRange();
				}
			}
			
			m_pSignPostMgr->m_pTimeline->StripInvalidateRect((IDMUSProdStrip *)this, NULL, TRUE);
		}
	}

	
	pDataObject->Release();
	
	return hr;
	
}

HRESULT CSignPostStrip::OnRButtonUp( WPARAM wParam, LONG lXPos, LONG lYPos )
{
	UNREFERENCED_PARAMETER(lYPos);
	POINT pt;
	BOOL  bResult;

	m_fShowGroupProps = FALSE;

	// Get the measure number 
	long lMeasure;
	if(FAILED(m_pSignPostMgr->m_pTimeline->PositionToMeasureBeat( m_pSignPostMgr->m_dwGroupBits, 0, lXPos, &lMeasure, NULL)))
	{
		ASSERT( FALSE );
		return E_UNEXPECTED;
	}

	if(!m_pSignPostMgr->m_bSelected)
	{
		// Make sure everything on the timeline is deselected.
		UnselectGutterRange();

		// If nothing is selected, select this measure.
		m_pSignPostMgr->ToggleSelect(lMeasure);
		m_pSignPostMgr->m_lShiftFromMeasure = lMeasure;

		m_pSignPostMgr->m_pTimeline->StripInvalidateRect((IDMUSProdStrip *) this, NULL, TRUE);
	}
	else if(!(wParam & (MK_SHIFT | MK_CONTROL)))
	{
		// Make sure this measure is in the selected list.  If it isn't, make it the only one selected
		if(!m_pSignPostMgr->IsSelected(lMeasure))
		{
			// Make sure everything on the timeline is deselected first.
			UnselectGutterRange();

			m_pSignPostMgr->ClearSelected();
			m_pSignPostMgr->ToggleSelect(lMeasure);
			m_pSignPostMgr->m_lShiftFromMeasure = lMeasure;
		}
		m_pSignPostMgr->m_pTimeline->StripInvalidateRect((IDMUSProdStrip *) this, NULL, TRUE);
	}

	if (!m_fShowGroupProps)
	{
		// Change to the signpost property page
		m_pSignPostMgr->OnShowProperties();
	}
	else
	{
		// Change to our property page
		OnShowProperties();
	}
	//if(m_pSignPostMgr->m_pIPageManager != NULL)
	//{
	//	m_pSignPostMgr->m_pIPageManager->RefreshData();
	//}

	// Get the cursor position (To put the menu there)
	bResult = GetCursorPos(&pt);
	ASSERT(bResult);
	if(!bResult)
	{
		return E_UNEXPECTED;
	}

	// Display the popup menu
	return m_pSignPostMgr->m_pTimeline->TrackPopupMenu(NULL, pt.x, pt.y, (IDMUSProdStrip *)this, TRUE);
}

HRESULT CSignPostStrip::OnLButtonUp( WPARAM wParam, LONG lXPos, LONG lYPos )
{
	UNREFERENCED_PARAMETER(wParam);
	UNREFERENCED_PARAMETER(lYPos);
	m_fShowGroupProps = FALSE;

	// Release mouse capture
	VARIANT var;
	var.vt = VT_BOOL;
	V_BOOL(&var) = FALSE;
	m_pSignPostMgr->m_pTimeline->SetTimelineProperty( TP_STRIPMOUSECAPTURE, var );

	m_fLButtonDown = FALSE;
	m_dwStartDragButton = 0;

	// Get the clock position
	long lClocks;
	if( FAILED( m_pSignPostMgr->m_pTimeline->PositionToClocks( lXPos, &lClocks) ) )
	{
		ASSERT( FALSE );
		return E_UNEXPECTED;
	}

	// Get the measure number 
	long lMeasure;
	if(FAILED(m_pSignPostMgr->m_pTimeline->ClocksToMeasureBeat( m_pSignPostMgr->m_dwGroupBits, 0, lClocks, &lMeasure, NULL)))
	{
		ASSERT( FALSE );
		return E_UNEXPECTED;
	}

	if(!(wParam & MK_CONTROL) && !(wParam & MK_SHIFT))
	{
		m_pSignPostMgr->ClearSelected();
		// Toggle the selection state of this measure
		m_pSignPostMgr->ToggleSelect(lMeasure);
		// Redraw our strip
		m_pSignPostMgr->m_pTimeline->StripInvalidateRect((IDMUSProdStrip *)this, NULL, TRUE);
	}
	else if((wParam & MK_CONTROL) && m_bWasSelected)
	{
		m_bWasSelected = false;
		m_pSignPostMgr->ToggleSelect(lMeasure);
		// redraw our strip
		m_pSignPostMgr->m_pTimeline->StripInvalidateRect((IDMUSProdStrip *)this, NULL, TRUE);
	}

	m_bWasSelected = false;	// so toggle select is in sync
	return S_OK;
}

HRESULT CSignPostStrip::OnLButtonDown( WPARAM wParam, LONG lXPos, LONG lYPos )
{
	UNREFERENCED_PARAMETER(lYPos);
	m_fShowGroupProps = FALSE;
	m_fLButtonDown = FALSE;

	// Make sure everything on the timeline is deselected.
	UnselectGutterRange();

	// Get the clock position
	long lClocks;
	if( FAILED( m_pSignPostMgr->m_pTimeline->PositionToClocks( lXPos, &lClocks) ) )
	{
		ASSERT( FALSE );
		return E_UNEXPECTED;
	}

	if(wParam & MK_SHIFT)
	{
		if(!(wParam & MK_CONTROL))
		{
			m_pSignPostMgr->ClearSelected();
		}
		m_pSignPostMgr->SelectSegment(-1, lClocks);
		m_pSignPostMgr->m_pTimeline->StripInvalidateRect((IDMUSProdStrip *)this, NULL, TRUE);
		m_pSignPostMgr->OnShowProperties();
		//GiveTimelineFocus();
		return S_OK;
	}

	// Get the measure number 
	long lMeasure;
	if(FAILED(m_pSignPostMgr->m_pTimeline->ClocksToMeasureBeat( m_pSignPostMgr->m_dwGroupBits, 0, lClocks, &lMeasure, NULL)))
	{
		ASSERT( FALSE );
		return E_UNEXPECTED;
	}

	m_pSignPostMgr->m_lShiftFromMeasure = lMeasure;

	// Get the info for the selected measure
	SignPostMeasureInfo* pMeasureInfo = NULL;
	if( lMeasure >=0 && lMeasure < m_pSignPostMgr->m_nMeasures)
	{
		pMeasureInfo = &(m_pSignPostMgr->m_pMeasureArray[lMeasure]);
	}

	if( pMeasureInfo )
	{
		if(pMeasureInfo->pSignPost && pMeasureInfo->dwFlags & SPMI_SELECTED )
		{
			m_pSignPostMgr->OnShowProperties();
			// start drag
//			DoDragDrop(wParam, lXPos, lMeasure);
			if(pMeasureInfo->pSignPost)
			{
				m_dwStartDragButton = wParam;
				m_fLButtonDown = TRUE;
			}
			// capture mouse so we get the LBUTTONUP message as well
			// the timeline will release the capture when it receives the
			// LBUTTONUP message
			VARIANT var;
			var.vt = VT_BOOL;
			V_BOOL(&var) = TRUE;
			m_pSignPostMgr->m_pTimeline->SetTimelineProperty( TP_STRIPMOUSECAPTURE, var );
			// indicate toggle select to mouse up
			if(wParam & MK_CONTROL)
			{
				m_bWasSelected = true;
			}
		}
		else
		{
			// capture mouse so we get the LBUTTONUP message as well
			// the timeline will release the capture when it receives the
			// LBUTTONUP message
			VARIANT var;
			var.vt = VT_BOOL;
			V_BOOL(&var) = TRUE;
			m_pSignPostMgr->m_pTimeline->SetTimelineProperty( TP_STRIPMOUSECAPTURE, var );

			// If we clicked on a signpost, set m_fLButtonDown to TRUE
			if( pMeasureInfo->pSignPost )
			{
				m_dwStartDragButton = wParam;
				m_fLButtonDown = TRUE;
			}

			// If CTRL is not pressed, clear all selections in our strip
			if(!(wParam & MK_CONTROL))
			{
				m_pSignPostMgr->ClearSelected();
				m_pSignPostMgr->ToggleSelect(lMeasure);
				// Redraw our strip
				m_pSignPostMgr->m_pTimeline->StripInvalidateRect((IDMUSProdStrip *)this, NULL, TRUE);

				// Set the properties to the ones for the current selection.
				m_pSignPostMgr->OnShowProperties();
			}
			else if(wParam & MK_CONTROL && pMeasureInfo->dwFlags & SPMI_SELECTED)
			{
				// indicate toggle select to mouse up
				m_bWasSelected = true;
			}
			else
			{
				// Toggle the selection state of this measure
				m_pSignPostMgr->ToggleSelect(lMeasure);

				// Redraw our strip
				m_pSignPostMgr->m_pTimeline->StripInvalidateRect((IDMUSProdStrip *)this, NULL, TRUE);

				// Set the properties to the ones for the current selection.
				m_pSignPostMgr->OnShowProperties();
				//GiveTimelineFocus();
			}
		}
	}

	return S_OK;
}

HRESULT CSignPostStrip::OnMouseMove( WPARAM wParam, LPARAM lParam, LONG lXPos, LONG lYPos )
{
	UNREFERENCED_PARAMETER(lYPos);
	UNREFERENCED_PARAMETER(lParam);
	UNREFERENCED_PARAMETER(wParam);

	// Get the measure number
	long lMeasure;
	if( FAILED( m_pSignPostMgr->m_pTimeline->PositionToMeasureBeat( m_pSignPostMgr->m_dwGroupBits, 0, lXPos, &lMeasure, NULL ) ))
	{
		ASSERT( FALSE );
		return E_UNEXPECTED;
	}

	if( m_fLButtonDown )
	{
		if( abs(m_lMouseXPos - lXPos) <= 3 
		&&  abs(m_lMouseYPos - lYPos) <= 3 )
			return S_OK;
		// Release mouse capture
		VARIANT var;
		var.vt = VT_BOOL;
		V_BOOL(&var) = FALSE;
		m_pSignPostMgr->m_pTimeline->SetTimelineProperty( TP_STRIPMOUSECAPTURE, var );

		// Do Drag'n'drop
		DoDragDrop(m_dwStartDragButton, lXPos, lMeasure);

		// Clear button down flag so we don't do drag'n'drop again.
		m_fLButtonDown= FALSE;
	}

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SignPostStripMgr\SignPostStripPPG.h ===
#if !defined(AFX_SIGNPOSTSTRIPPPG_H__8D655C81_CE44_11D1_88BC_00C04FBF8D15__INCLUDED_)
#define AFX_SIGNPOSTSTRIPPPG_H__8D655C81_CE44_11D1_88BC_00C04FBF8D15__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include <staticproppagemanager.h>
#include <afxdlgs.h>
#include "resource.h"

struct ioSignPostStripPPG
{
	DWORD	dwPageIndex;
	DWORD	dwActivityLevel;
};

// SignPostStripPPG.h : header file
//

class CKeyRootEdit :
	public CEdit
{
	DECLARE_DYNCREATE(CKeyRootEdit)
public:
	CKeyRootEdit();

	// for processing Windows messages
	virtual LRESULT WindowProc(UINT message, WPARAM wParam, LPARAM lParam);

protected:
};

/////////////////////////////////////////////////////////////////////////////
// CSignPostStripPropPageMgr

class CSignPostStripPropPageMgr : public CStaticPropPageManager
{
friend class CSignPostStripPPG;
public:
	CSignPostStripPropPageMgr();
	~CSignPostStripPropPageMgr();
	HRESULT STDMETHODCALLTYPE QueryInterface( REFIID riid, LPVOID *ppv );

    // IDMUSProdPropPageManager functions
    HRESULT STDMETHODCALLTYPE GetPropertySheetTitle( BSTR* pbstrTitle, BOOL* pfAddPropertiesText );
    HRESULT STDMETHODCALLTYPE GetPropertySheetPages( IDMUSProdPropSheet* pIPropSheet, 
													 LONG* hPropSheetPage[], short* pnNbrPages );
    HRESULT STDMETHODCALLTYPE RefreshData();
    HRESULT STDMETHODCALLTYPE SetObject( IDMUSProdPropPageObject* pINewPropPageObject );

	BOOL					m_fShowGroupBits;
	static short			sm_nActiveTab;

protected:
	class CSignPostStripPPG*	m_pSignPostStripPPG;
	class CGroupBitsPPG*	m_pGroupBitsPPG;
	class CTrackFlagsPPG*	m_pTrackFlagsPPG;
};

/////////////////////////////////////////////////////////////////////////////
// CSignPostStripPPG dialog

class CSignPostStripPPG : public CPropertyPage
{
	DECLARE_DYNCREATE(CSignPostStripPPG)

// Construction
public:
	CSignPostStripPPG();
	~CSignPostStripPPG();

// Dialog Data
	//{{AFX_DATA(CSignPostStripPPG)
	enum { IDD = IDD_PROPPAGE_AUDITION };
	CComboBox	m_comboActivityLevel;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CSignPostStripPPG)
	public:
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CSignPostStripPPG)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnDestroy();
	afx_msg void OnSelchangeActivitylevel();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

protected:
	void EnableControls( BOOL fEnable );
	void UpdatePPO();

public:
	void SetObject( IDMUSProdPropPageObject* pPPO );
	void RefreshData( void );

	CSignPostStripPropPageMgr*		m_pPropPageMgr;

protected:
	IDMUSProdPropPageObject*	m_pPPO;
	BOOL						m_fNeedToDetach;

	// Audition data
	DWORD						m_dwActivityLevel;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SIGNPOSTSTRIPPPG_H__8D655C81_CE44_11D1_88BC_00C04FBF8D15__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SignPostStripMgr\SignPostStripMgr.cpp ===
// SignPostStripMgr.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//		To build a separate proxy/stub DLL, 
//		run nmake -f SignPostStripMgrps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include "initguid.h"
#include "SignPostStripMgr.h"

#include "SignPostMgr.h"
#include <dmusici.h>
#include <SegmentGuids.h>


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
	OBJECT_ENTRY(CLSID_SignPostMgr, CSignPostMgr)
END_OBJECT_MAP()

CSignPostStripMgrApp theApp;

////////////////////////////////////////////////////////////////////////////
// CSignPostStripMgrApp::InitInstance - DLL initialization

BOOL CSignPostStripMgrApp::InitInstance()
{
	_Module.Init(ObjectMap, m_hInstance);
	return CWinApp::InitInstance();
}

////////////////////////////////////////////////////////////////////////////
// CSignPostStripMgrApp::ExitInstance - DLL termination

int CSignPostStripMgrApp::ExitInstance()
{
	_Module.Term();
	return CWinApp::ExitInstance();
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	return (AfxDllCanUnloadNow()==S_OK && _Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
	return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// SetRegString - Writes a string to system registry 

static BOOL SetRegString( HKEY hKey, LPCTSTR lpSubKey, LPTSTR lpValueName, LPCTSTR lpszString )
{
	HKEY  hKeyOpen;
	DWORD dwCbData;
	LONG  lResult;
	DWORD dwDisposition;
	BOOL  fSuccess = FALSE;

	lResult = RegCreateKeyEx( hKey, lpSubKey, 0, 0, REG_OPTION_NON_VOLATILE,
							  KEY_ALL_ACCESS, NULL, &hKeyOpen, &dwDisposition );
	if( lResult == ERROR_SUCCESS )
	{
		dwCbData = _tcslen(lpszString)+1; // Assume ASCII  This is BAD!!!!!

		lResult = RegSetValueEx( hKeyOpen, lpValueName, 0, REG_SZ, (LPBYTE)lpszString, dwCbData);

		if( lResult == ERROR_SUCCESS )
		{
			fSuccess = TRUE;
		}

		RegCloseKey( hKeyOpen );
	}

	return fSuccess;
}

/////////////////////////////////////////////////////////////////////////////
// RegisterComponents - Adds entries to the system registry for DMUSProducer strip managers

static BOOL RegisterComponents( void )
{
    LPOLESTR psz;
	TCHAR    szRegPath[256];
	TCHAR	 szStripManager[32];
	TCHAR	 szUserName[32];
    TCHAR    szEditorGuid[100];
	TCHAR	 szTrackGuid[100];
    CString  strTrackName, strEditorName;
    TCHAR    szComponentPath[256];
    
	_tcscpy( szStripManager, _T("StripManager") );
	_tcscpy( szUserName, _T("UserName") );

	_tcscpy( szComponentPath, _T("Software\\Microsoft\\DMUSProducer\\StripEditors\\") );
	
    if( SUCCEEDED( StringFromIID(CLSID_SignPostMgr, &psz) ) )
    {
        WideCharToMultiByte( CP_ACP, 0, psz, -1, szEditorGuid, sizeof(szEditorGuid), NULL, NULL );
        CoTaskMemFree( psz );
		if( SUCCEEDED( StringFromIID(CLSID_DirectMusicSignPostTrack, &psz) ) )
		{
			WideCharToMultiByte( CP_ACP, 0, psz, -1, szTrackGuid, sizeof(szTrackGuid), NULL, NULL );
			CoTaskMemFree( psz );

			strTrackName.LoadString( IDS_TRACK_NAME );
			_tcscpy( szRegPath, szComponentPath );
			_tcscat( szRegPath, szTrackGuid );
			if( !(SetRegString(HKEY_LOCAL_MACHINE, szRegPath, _T(""), strTrackName)) )
			{
				return FALSE;
			}
			if( !(SetRegString(HKEY_LOCAL_MACHINE, szRegPath, szStripManager, szEditorGuid)) )
			{
				return FALSE;
			}
			strEditorName.LoadString( IDS_EDITOR_NAME );
			if( !(SetRegString(HKEY_LOCAL_MACHINE, szRegPath, szUserName, strEditorName)) )
			{
				return FALSE;
			}
		}
    }
	else
	{
		return FALSE;
	}

	return TRUE;
}

static BOOL UnregisterComponents( void )
{
	LPOLESTR psz;
	TCHAR    szRegPath[255];
	TCHAR    szGuid[100];
	
	if( SUCCEEDED( StringFromIID(CLSID_DirectMusicSignPostTrack, &psz) ) )
   	{
		WideCharToMultiByte( CP_ACP, 0, psz, -1, szGuid, sizeof(szGuid), NULL, NULL );
		CoTaskMemFree( psz );

		_tcscpy( szRegPath, _T("Software\\Microsoft\\DMUSProducer\\StripEditors\\") );
		_tcscat( szRegPath, szGuid );
		if( RegDeleteKey(HKEY_LOCAL_MACHINE, szRegPath) != ERROR_SUCCESS )
		{
			return FALSE;
		}
	}
	else
	{
		return FALSE;
	}

	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
	// registers object
	if ( _Module.RegisterServer(FALSE) )
	{
		return ResultFromScode(SELFREG_E_CLASS);
	}

	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	if( !RegisterComponents() )
	{
		return ResultFromScode(SELFREG_E_FIRST+2);
	}

	return NOERROR;
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	/*
	if ( !AfxOleUnregisterTypeLib(LIBID_SIGNPOSTSTRIPMGRLib) )
	{
		return ResultFromScode(SELFREG_E_TYPELIB);
	}
	*/

	if ( _Module.UnregisterServer(FALSE) )
	{
		return ResultFromScode(SELFREG_E_CLASS);
	}

	if( !UnregisterComponents() )
	{
		return ResultFromScode(SELFREG_E_FIRST+2);
	}
	return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SignPostStripMgr\StdAfx.h ===
#if !defined(AFX_STDAFX_H__5A52AF0A_E135_11D0_BACA_00805F493F43__INCLUDED_)
#define AFX_STDAFX_H__5A52AF0A_E135_11D0_BACA_00805F493F43__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#define STRICT

#include <afxwin.h>
#include <afxdisp.h>

#define _WIN32_WINNT 0x0400
#define _ATL_APARTMENT_THREADED


#include <afxdlgs.h>
#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__5A52AF0A_E135_11D0_BACA_00805F493F43__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SongDesigner\DlgAddTracks.cpp ===
// DlgAddTracks.cpp : implementation file
//

#include "stdafx.h"
#include "SongDesignerDLL.h"

#include "Song.h"
#include "DlgAddTracks.h"
#include "SegmentDesigner.h"
#include <dmusicf.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/////////////////////////////////////////////////////////////////////////////
// CDlgAddTracks dialog

CDlgAddTracks::CDlgAddTracks(CWnd* pParent /*=NULL*/)
	: CDialog(CDlgAddTracks::IDD, pParent)
{
	//{{AFX_DATA_INIT(CDlgAddTracks)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT

	m_pSong = NULL;
}

CDlgAddTracks::~CDlgAddTracks()
{
	CTrack* pTrack;

	while( !m_lstTracks.IsEmpty() )
	{
		pTrack = m_lstTracks.RemoveHead();

		RELEASE( pTrack );
	}

	while( !m_lstSegmentTracks.IsEmpty() )
	{
		pTrack = m_lstSegmentTracks.RemoveHead();

		RELEASE( pTrack );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CDlgAddTracks:BuildSegmentTrackList

void CDlgAddTracks::BuildSegmentTrackList( void )
{
	// Initialize list
	while( !m_lstSegmentTracks.IsEmpty() )
	{
		CTrack* pTrack = m_lstSegmentTracks.RemoveHead();

		RELEASE( pTrack );
	}

	// Enumerate SourceSegments
	CSourceSegment* pSourceSegment;
	for( DWORD dwIndex = 0 ;  pSourceSegment = m_pSong->IndexToSourceSegment(dwIndex) ;  dwIndex++ )
	{
		if( pSourceSegment == NULL )
		{
			break;
		}

		IDMUSProdNode* pISegmentNode;
		if( SUCCEEDED ( pSourceSegment->GetSegmentDocRootNode( &pISegmentNode ) ) )
		{
			// Get an IDMUSProdSegmentEdit8 interface pointer
			IDMUSProdSegmentEdit8* pISegmentEdit8;
			if( SUCCEEDED ( pISegmentNode->QueryInterface( IID_IDMUSProdSegmentEdit8, (void **)&pISegmentEdit8 ) ) )
			{
				DMUS_IO_TRACK_HEADER dmusTrackHeader;
				DMUS_IO_TRACK_EXTRAS_HEADER dmusTrackExtrasHeader;
				HRESULT hr = S_OK;

				DWORD dwSequenceTrackGroups = 0;

				// Enumerate Tracks
				for( DWORD dwIdx = 0 ;  (hr == S_OK) ;  dwIdx++ )
				{
					hr = pISegmentEdit8->EnumTrack( dwIdx,
							 						sizeof(DMUS_IO_TRACK_HEADER), &dmusTrackHeader,
													sizeof(DMUS_IO_TRACK_EXTRAS_HEADER), &dmusTrackExtrasHeader );
					if( hr == S_OK )
					{
						// If this is a sequence track
						if( CLSID_DirectMusicSeqTrack == dmusTrackHeader.guidClassID )
						{
							// If we've already found a sequence track in this track group
							if( dmusTrackHeader.dwGroup & dwSequenceTrackGroups )
							{
								// Continue enumerating
								continue;
							}

							// Mark that we've found a sequence track in this track group
							dwSequenceTrackGroups |= dmusTrackHeader.dwGroup;
						}

						// Add the track to our list to display
						CTrack* pTrack = new CTrack( m_pSong, pSourceSegment, dwIdx, &dmusTrackHeader, &dmusTrackExtrasHeader );

						m_lstSegmentTracks.AddTail( pTrack );
					}
				}

				RELEASE( pISegmentEdit8 );
			}

			RELEASE( pISegmentNode );
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CDlgAddTracks:FillSegmentTrackListBox

void CDlgAddTracks::FillSegmentTrackListBox( void )
{
	m_lstbxSegmentTracks.SetRedraw( FALSE );
	m_lstbxSegmentTracks.ResetContent();
	m_lstbxSegmentTracks.SetHorizontalExtent( 0 );

	POSITION pos = m_lstSegmentTracks.GetHeadPosition();
	while( pos )
	{
		CTrack* pTrack = m_lstSegmentTracks.GetNext( pos );

		int nPos = m_lstbxSegmentTracks.AddString( (LPCTSTR)pTrack  );
	}

	m_lstbxSegmentTracks.SetRedraw( TRUE );
}


/////////////////////////////////////////////////////////////////////////////
// CDlgAddTracks::CreateFont

CFont* CDlgAddTracks::CreateFont( void )
{
	CFont* pFont = new CFont;

	if( pFont 
	&&  pFont->CreateFont( 10, 0, 0, 0, FW_NORMAL, 0, 0, 0,
 						   DEFAULT_CHARSET, OUT_CHARACTER_PRECIS, CLIP_CHARACTER_PRECIS,
						   DEFAULT_QUALITY, DEFAULT_PITCH | FF_DONTCARE, "MS Sans Serif" ) )
	{
		return pFont;
	}

	if( pFont )
	{
		delete pFont;
	}
	return NULL;
}


void CDlgAddTracks::DoDataExchange(CDataExchange* pDX)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CDlgAddTracks)
	DDX_Control(pDX, IDC_LIST_TRACKS, m_lstbxSegmentTracks);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CDlgAddTracks, CDialog)
	//{{AFX_MSG_MAP(CDlgAddTracks)
	ON_WM_DRAWITEM()
	ON_WM_MEASUREITEM()
	ON_WM_COMPAREITEM()
	ON_LBN_DBLCLK(IDC_LIST_TRACKS, OnDblClkListTracks)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CDlgAddTracks message handlers

/////////////////////////////////////////////////////////////////////////////
// CDlgAddTracks::OnInitDialog

BOOL CDlgAddTracks::OnInitDialog() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CDialog::OnInitDialog();

	BuildSegmentTrackList();
	FillSegmentTrackListBox();
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}


/////////////////////////////////////////////////////////////////////////////
// CDlgAddTracks::OnOK

void CDlgAddTracks::OnOK() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_lstTracks.IsEmpty() );

	int nNbrSelItems = m_lstbxSegmentTracks.GetSelCount();
	if( nNbrSelItems > 0 )
	{
		int* pnSelItems = new int[nNbrSelItems];
		if( pnSelItems )
		{
			m_lstbxSegmentTracks.GetSelItems( nNbrSelItems, pnSelItems );

			for( int i = 0;  i < nNbrSelItems ;  i++ )
			{
				CTrack* pTrack = (CTrack *)m_lstbxSegmentTracks.GetItemDataPtr( pnSelItems[i] );
			
				if( pTrack
				&&  pTrack != (CTrack *)0xFFFFFFFF )
				{
					pTrack->AddRef();
					m_lstTracks.AddTail( pTrack );
				}
			}

			delete [] pnSelItems;
		}
	}
	
	CDialog::OnOK();
}


/////////////////////////////////////////////////////////////////////////////
// CDlgAddTracks::OnDrawItem

void CDlgAddTracks::OnDrawItem( int nIDCtl, LPDRAWITEMSTRUCT lpDrawItemStruct ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( nIDCtl != IDC_LIST_TRACKS )
	{
		CDialog::OnDrawItem( nIDCtl, lpDrawItemStruct );
		return;
	}

	if( lpDrawItemStruct->itemID == -1 )
	{
		return;
	}

	CDC* pDC = CDC::FromHandle( lpDrawItemStruct->hDC );
	if( pDC == NULL )
	{
		return;
	}

    if( lpDrawItemStruct->itemAction & ODA_DRAWENTIRE
    ||  lpDrawItemStruct->itemAction & ODA_SELECT 
    ||  lpDrawItemStruct->itemAction & ODA_FOCUS )
	{
		CTrack* pTrack = (CTrack *)lpDrawItemStruct->itemData; 
		ASSERT( pTrack != NULL );

	    int nWidth  = lpDrawItemStruct->rcItem.right  - lpDrawItemStruct->rcItem.left;
		int nHeight = lpDrawItemStruct->rcItem.bottom - lpDrawItemStruct->rcItem.top;

		CRect rect( 0, 0, nWidth, nHeight );

		CDC dc;
		CBitmap bmp;

		if( dc.CreateCompatibleDC( pDC )
		&&  bmp.CreateCompatibleBitmap( pDC, nWidth, nHeight ) )
		{
			CFont* pFontOld = NULL;
			CFont* pFont = CreateFont();
			if( pFont )
			{
				pFontOld = dc.SelectObject( pFont );
			}
			CBitmap* pBitmapOld = dc.SelectObject( &bmp );
			int nBkModeOld = dc.SetBkMode( TRANSPARENT );

			// Fill the background color
			if( lpDrawItemStruct->itemState & ODS_SELECTED )
			{
				dc.FillSolidRect( &rect, ::GetSysColor(COLOR_HIGHLIGHT) );
				dc.SetTextColor( ::GetSysColor(COLOR_HIGHLIGHTTEXT) );
			}
			else
			{
				dc.FillSolidRect( &rect, ::GetSysColor(COLOR_WINDOW) );
				dc.SetTextColor( ::GetSysColor(COLOR_WINDOWTEXT) );
			}

			// Get the Track's name
			CString strName;
			pTrack->FormatTextUI( strName );

			// Set horizontal extent
			TEXTMETRIC tm;
			dc.GetTextMetrics( &tm );
			CSize sizeText = dc.GetTextExtent( strName );
			sizeText.cx += tm.tmMaxCharWidth;
			if( sizeText.cx > m_lstbxSegmentTracks.GetHorizontalExtent() )
			{
				m_lstbxSegmentTracks.SetHorizontalExtent( sizeText.cx );
			}

			// Draw the item
			rect.left  += 3;
			dc.DrawText( strName, -1, &rect, (DT_SINGLELINE | DT_TOP | DT_LEFT) );
			pDC->BitBlt( lpDrawItemStruct->rcItem.left, lpDrawItemStruct->rcItem.top, nWidth, nHeight, 
						 &dc, 0, 0, SRCCOPY );

			// Clean up
			dc.SetBkMode( nBkModeOld );
			if( pFontOld )
			{
				dc.SelectObject( pFontOld );
				pFont->DeleteObject();
				delete pFont;
			}
			if( pBitmapOld )
			{
				dc.SelectObject( pBitmapOld );
			}
		}

		if( (lpDrawItemStruct->itemAction & ODA_FOCUS)
		&&  (lpDrawItemStruct->itemState & ODS_FOCUS) )
		{
			InflateRect( &lpDrawItemStruct->rcItem, -1, -1 );
			lpDrawItemStruct->rcItem.bottom--;
			pDC->DrawFocusRect( &lpDrawItemStruct->rcItem );
			lpDrawItemStruct->rcItem.bottom++;
			InflateRect( &lpDrawItemStruct->rcItem, 1, 1 );
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CDlgAddTracks::OnMeasureItem

void CDlgAddTracks::OnMeasureItem( int nIDCtl, LPMEASUREITEMSTRUCT lpMeasureItemStruct ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	switch( nIDCtl )
	{
		case IDC_LIST_TRACKS:
		{
			CDC* pDC = GetDC();
			if( pDC )
			{
				CFont* pFontOld = NULL;
				CFont* pFont = CreateFont();
				if( pFont )
				{
					pFontOld = pDC->SelectObject( pFont );
				}

				TEXTMETRIC tm;
				pDC->GetTextMetrics( &tm );
				lpMeasureItemStruct->itemHeight = tm.tmHeight + 2;
				
				if( pFontOld )
				{
					pDC->SelectObject( pFontOld );
					pFont->DeleteObject();
					delete pFont;
				}

				ReleaseDC( pDC );
			}
			return;
		}
	}

	CDialog::OnMeasureItem( nIDCtl, lpMeasureItemStruct );
}


/////////////////////////////////////////////////////////////////////////////
// CDlgAddTracks::OnCompareItem

int CDlgAddTracks::OnCompareItem( int nIDCtl, LPCOMPAREITEMSTRUCT lpCompareItemStruct ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( nIDCtl != IDC_LIST_TRACKS )
	{
		return CDialog::OnCompareItem( nIDCtl, lpCompareItemStruct );
	}

	CTrack* pTrack1 = (CTrack *)lpCompareItemStruct->itemData1;
	CTrack* pTrack2 = (CTrack *)lpCompareItemStruct->itemData2;

	CString strName1;
	pTrack1->FormatFileNameText( strName1 );

	CString strName2;
	pTrack2->FormatFileNameText( strName2 );

	// If filenames are equal, sort by track index
	if( strName1.CompareNoCase( strName2 ) == 0 )
	{
		if( pTrack1->m_TrackUI.dwTrackIndex < pTrack2->m_TrackUI.dwTrackIndex )
		{
			return -1;
		}
		else if( pTrack1->m_TrackUI.dwTrackIndex > pTrack2->m_TrackUI.dwTrackIndex )
		{
			return 1;
		}
		else
		{
			return 0;
		}
	}

	// Sort by filename
	return strName1.CompareNoCase( strName2 );
}


/////////////////////////////////////////////////////////////////////////////
// CDlgAddTracks::OnDblClkListTracks

void CDlgAddTracks::OnDblClkListTracks( void ) 
{
	OnOK();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SignPostStripMgr\StdAfx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SongDesigner\DlgAddTracks.h ===
#if !defined(AFX_DLGADDTRACKS_H__AF7EBB6B_B222_44FE_AC01_8A63376BCA1C__INCLUDED_)
#define AFX_DLGADDTRACKS_H__AF7EBB6B_B222_44FE_AC01_8A63376BCA1C__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// DlgAddTracks.h : header file
//

#include "Track.h"

/////////////////////////////////////////////////////////////////////////////
// CDlgAddTracks dialog

class CDlgAddTracks : public CDialog
{
// Construction
public:
	CDlgAddTracks(CWnd* pParent = NULL);   // standard constructor
	virtual ~CDlgAddTracks();

// Dialog Data
	//{{AFX_DATA(CDlgAddTracks)
	enum { IDD = IDD_DLG_ADD_TRACKS };
	CListBox	m_lstbxSegmentTracks;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CDlgAddTracks)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	void BuildSegmentTrackList();
	void FillSegmentTrackListBox();
	CFont* CreateFont();

public:
	CDirectMusicSong*	m_pSong;
	CTypedPtrList<CPtrList, CTrack*> m_lstTracks;

protected:
	CTypedPtrList<CPtrList, CTrack*> m_lstSegmentTracks;

	// Generated message map functions
	//{{AFX_MSG(CDlgAddTracks)
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	afx_msg void OnDrawItem(int nIDCtl, LPDRAWITEMSTRUCT lpDrawItemStruct);
	afx_msg void OnMeasureItem(int nIDCtl, LPMEASUREITEMSTRUCT lpMeasureItemStruct);
	afx_msg int OnCompareItem(int nIDCtl, LPCOMPAREITEMSTRUCT lpCompareItemStruct);
	afx_msg void OnDblClkListTracks();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DLGADDTRACKS_H__AF7EBB6B_B222_44FE_AC01_8A63376BCA1C__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SignPostStripMgr\SignPostStripPPG.cpp ===
// SignPostStripPPG.cpp : implementation file
//

#include "stdafx.h"
#include "SignPostStripPPG.h"
#include "GroupBitsPPG.h"
#include "TrackFlagsPPG.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

short CSignPostStripPropPageMgr::sm_nActiveTab = 0;


/////////////////////////////////////////////////////////////////////////////
// CSignPostStripPropPageMgr property page

CSignPostStripPropPageMgr::CSignPostStripPropPageMgr()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	m_pSignPostStripPPG = NULL;
	m_pGroupBitsPPG = NULL;
	m_pTrackFlagsPPG = NULL;
	CStaticPropPageManager::CStaticPropPageManager();
}

CSignPostStripPropPageMgr::~CSignPostStripPropPageMgr()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	if( m_pSignPostStripPPG )
	{
		delete m_pSignPostStripPPG;
		m_pSignPostStripPPG = NULL;
	}
	if( m_pGroupBitsPPG )
	{
		delete m_pGroupBitsPPG;
		m_pGroupBitsPPG = NULL;
	}
	if( m_pTrackFlagsPPG )
	{
		delete m_pTrackFlagsPPG;
		m_pTrackFlagsPPG = NULL;
	}
	CStaticPropPageManager::~CStaticPropPageManager();
}

HRESULT CSignPostStripPropPageMgr::QueryInterface( REFIID riid, LPVOID *ppv )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	return CStaticPropPageManager::QueryInterface( riid, ppv );
}

HRESULT CSignPostStripPropPageMgr::GetPropertySheetTitle( BSTR* pbstrTitle, 
	BOOL* pfAddPropertiesText )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	if( (pbstrTitle == NULL)
	||  (pfAddPropertiesText == NULL) )
	{
		return E_POINTER;
	}

	*pfAddPropertiesText = TRUE;

	CString cstrPart;
	cstrPart.LoadString( IDS_PROPPAGE_GROUP_BITS );
	*pbstrTitle = cstrPart.AllocSysString();

	return S_OK;
}

HRESULT CSignPostStripPropPageMgr::GetPropertySheetPages( IDMUSProdPropSheet* pIPropSheet, 
	LONG* hPropSheetPage[], short* pnNbrPages )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	if( (hPropSheetPage == NULL)
	||  (pnNbrPages == NULL) )
	{
		return E_POINTER;
	}

	if( pIPropSheet == NULL )
	{
		return E_INVALIDARG;
	}

	m_pIPropSheet = pIPropSheet;
	m_pIPropSheet->AddRef();

	hPropSheetPage[0] = NULL;
	*pnNbrPages = 0;

	HPROPSHEETPAGE hPage;
	short nNbrPages = 0;
	// Add Group Bits tab
	if( NULL == m_pGroupBitsPPG )
	{
		m_pGroupBitsPPG = new CGroupBitsPPG();
	}
	if( m_pGroupBitsPPG )
	{
		hPage = ::CreatePropertySheetPage( (LPCPROPSHEETPAGE)&m_pGroupBitsPPG->m_psp );
		if( hPage )
		{
			hPropSheetPage[nNbrPages] = (LONG *)hPage;
			nNbrPages++;
		}

		// Weak reference
		m_pGroupBitsPPG->m_pIPropSheet = m_pIPropSheet;

		// Tell the property page to update the active tab setting
		CGroupBitsPPG::sm_pnActiveTab = &CSignPostStripPropPageMgr::sm_nActiveTab;
	}

	// Add track flags tab
	if( NULL == m_pTrackFlagsPPG )
	{
		m_pTrackFlagsPPG = new CTrackFlagsPPG();
	}
	if( m_pTrackFlagsPPG )
	{
		hPage = ::CreatePropertySheetPage( (LPCPROPSHEETPAGE)&m_pTrackFlagsPPG->m_psp );
		if( hPage )
		{
			hPropSheetPage[nNbrPages] = (LONG *)hPage;
			nNbrPages++;
		}			

		// Weak reference
		m_pTrackFlagsPPG->m_pIPropSheet = m_pIPropSheet;

		// Tell the property page to update the active tab setting
		CTrackFlagsPPG::sm_pnActiveTab = &CSignPostStripPropPageMgr::sm_nActiveTab;
	}

	// Add audition tab
	if( NULL == m_pSignPostStripPPG )
	{
		m_pSignPostStripPPG = new CSignPostStripPPG();
	}
	if( m_pSignPostStripPPG )
	{
		hPage = ::CreatePropertySheetPage( (LPCPROPSHEETPAGE)&m_pSignPostStripPPG->m_psp );
		if( hPage )
		{
			hPropSheetPage[nNbrPages] = (LONG *)hPage;
			nNbrPages++;
		}
		
		// Weak reference
		m_pSignPostStripPPG->m_pPropPageMgr = this;
	}

	// Set number of pages
	*pnNbrPages = nNbrPages;
	return S_OK;
}

HRESULT CSignPostStripPropPageMgr::RefreshData()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	if( m_pSignPostStripPPG )
	{
		m_pSignPostStripPPG->RefreshData();
	}
	if( m_pGroupBitsPPG )
	{
		m_pGroupBitsPPG->RefreshData();
	}
	if( m_pTrackFlagsPPG )
	{
		m_pTrackFlagsPPG->RefreshData();
	}
	return S_OK;
}

HRESULT CSignPostStripPropPageMgr::SetObject( IDMUSProdPropPageObject* pINewPropPageObject )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	if( m_pSignPostStripPPG )
	{
		m_pSignPostStripPPG->SetObject( pINewPropPageObject );
	}
	if( m_pGroupBitsPPG )
	{
		m_pGroupBitsPPG->SetObject( pINewPropPageObject );
	}
	if( m_pTrackFlagsPPG )
	{
		m_pTrackFlagsPPG->SetObject( pINewPropPageObject );
	}
	return CBasePropPageManager::SetObject( pINewPropPageObject );
}

/////////////////////////////////////////////////////////////////////////////
// CSignPostStripPPG property page

IMPLEMENT_DYNCREATE(CSignPostStripPPG, CPropertyPage)

CSignPostStripPPG::CSignPostStripPPG() : CPropertyPage(CSignPostStripPPG::IDD)
{
	//{{AFX_DATA_INIT(CSignPostStripPPG)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
	m_pPPO = NULL;
	m_pPropPageMgr = NULL;
	m_fNeedToDetach = FALSE;
	m_dwActivityLevel = 5;
}

CSignPostStripPPG::~CSignPostStripPPG()
{
	if( m_pPPO )
	{
		m_pPPO->Release();
	}
}

void CSignPostStripPPG::DoDataExchange(CDataExchange* pDX)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CSignPostStripPPG)
	DDX_Control(pDX, IDC_ACTIVITYLEVEL, m_comboActivityLevel);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CSignPostStripPPG, CPropertyPage)
	//{{AFX_MSG_MAP(CSignPostStripPPG)
	ON_WM_CREATE()
	ON_WM_DESTROY()
	ON_CBN_SELCHANGE(IDC_ACTIVITYLEVEL, OnSelchangeActivitylevel)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

// private functions
void CSignPostStripPPG::SetObject( IDMUSProdPropPageObject* pPPO )
{
	if( m_pPPO )
	{
		m_pPPO->Release();
	}
	m_pPPO = pPPO;
	if( m_pPPO )
	{
		m_pPPO->AddRef();
	}
}

void CSignPostStripPPG::EnableControls( BOOL fEnable ) 
{
	if( ::IsWindow(m_hWnd) == FALSE )
	{
		return;
	}

	if( ::IsWindow(m_comboActivityLevel.m_hWnd))
	{
		m_comboActivityLevel.EnableWindow( fEnable );
	}
}

/////////////////////////////////////////////////////////////////////////////
// CSignPostStripPPG message handlers

int CSignPostStripPPG::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Attach the window to the property page structure.
	// This has been done once already in the main application
	// since the main application owns the property sheet.
	// It needs to be done here so that the window handle can
	// be found in the DLLs handle map.
	if( !FromHandlePermanent( m_hWnd ) )
	{
		HWND hWnd = m_hWnd;
		m_hWnd = NULL;
		Attach( hWnd );
		m_fNeedToDetach = TRUE;
	}

	if (CPropertyPage::OnCreate(lpCreateStruct) == -1)
		return -1;
	
	return 0;
}

void CSignPostStripPPG::OnDestroy() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// Detach the window from the property page structure.
	// This will be done again by the main application since
	// it owns the property sheet.  It needs o be done here
	// so that the window handle can be removed from the
	// DLLs handle map.
	if( m_fNeedToDetach && m_hWnd )
	{
		HWND hWnd = m_hWnd;
		Detach();
		m_hWnd = hWnd;
	}

	CPropertyPage::OnDestroy();
}

void CSignPostStripPPG::RefreshData( void )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	if( m_pPPO == NULL )
	{
		EnableControls( FALSE );
		return;
	}

	ioSignPostStripPPG iSignPostStripPPG, *pioSignPostStripPPG;
	iSignPostStripPPG.dwPageIndex = 2;
	pioSignPostStripPPG = &iSignPostStripPPG;
	if( FAILED( m_pPPO->GetData( (void**)&pioSignPostStripPPG ) ) )
	{
		EnableControls( FALSE );
		return;
	}

	// Make sure controls have been created
	if( ::IsWindow(m_hWnd) == FALSE )
	{
		return;
	}

	m_dwActivityLevel = iSignPostStripPPG.dwActivityLevel;

	if( m_dwActivityLevel < 4 )
	{
		m_comboActivityLevel.SetCurSel( m_dwActivityLevel );
	}
	else
	{
		m_comboActivityLevel.SetCurSel( 4 );
	}

	EnableControls( TRUE );
}

BOOL CSignPostStripPPG::OnSetActive() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	RefreshData();

	// Store active tab
	if( m_pPropPageMgr && m_pPropPageMgr->m_pIPropSheet )
	{
		m_pPropPageMgr->m_pIPropSheet->GetActivePage( &CSignPostStripPropPageMgr::sm_nActiveTab );
	}

	return CPropertyPage::OnSetActive();
}

void CSignPostStripPPG::UpdatePPO()
{
	if( m_pPPO )
	{
		ioSignPostStripPPG oSignPostStripPPG;
		oSignPostStripPPG.dwPageIndex = 2;
		oSignPostStripPPG.dwActivityLevel = m_dwActivityLevel;

		m_pPPO->SetData( (void *)&oSignPostStripPPG );
	}
}

void CSignPostStripPPG::OnSelchangeActivitylevel() 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	int nChoice = m_comboActivityLevel.GetCurSel();
	if ( nChoice != (signed)m_dwActivityLevel )
	{
		m_dwActivityLevel = nChoice;

		UpdatePPO();
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SongDesigner\DlgSetLength.cpp ===
// DlgSetLength.cpp : implementation file
//

#include "stdafx.h"
#include "SongDesignerDLL.h"

#include "Song.h"
#include "DlgSetLength.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/////////////////////////////////////////////////////////////////////////////
// CDlgSetLength dialog

CDlgSetLength::CDlgSetLength( CWnd* pParent /*=NULL*/)
	: CDialog(CDlgSetLength::IDD, pParent)
{
	//{{AFX_DATA_INIT(CDlgSetLength)
	//}}AFX_DATA_INIT

	m_dwNbrMeasures = 0;
}


void CDlgSetLength::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CDlgSetLength)
	DDX_Control(pDX, IDC_LENGTH, m_editLength);
	DDX_Control(pDX, IDOK, m_btnOK);
	DDX_Control(pDX, IDC_LENGTH_SPIN, m_spinLength);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CDlgSetLength, CDialog)
	//{{AFX_MSG_MAP(CDlgSetLength)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CDlgSetLength message handlers


/////////////////////////////////////////////////////////////////////////////
// CDlgSetLength::OnInitDialog

BOOL CDlgSetLength::OnInitDialog() 
{
	CDialog::OnInitDialog();

	// Set length
	m_editLength.LimitText( 3 );
	m_spinLength.SetRange( MIN_VIRTUAL_SEGMENT_LENGTH, MAX_VIRTUAL_SEGMENT_LENGTH );
	m_spinLength.SetPos( m_dwNbrMeasures );
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}


/////////////////////////////////////////////////////////////////////////////
// CDlgSetLength::OnOK

void CDlgSetLength::OnOK() 
{
	CString strNewNbrMeasures;
	m_editLength.GetWindowText( strNewNbrMeasures );

	// Strip leading and trailing spaces
	strNewNbrMeasures.TrimRight();
	strNewNbrMeasures.TrimLeft();

	DWORD dwNewNbrMeasures = (DWORD)( _ttoi( strNewNbrMeasures ) );

	// Validate new length
	if( dwNewNbrMeasures < MIN_VIRTUAL_SEGMENT_LENGTH
	||  dwNewNbrMeasures > MAX_VIRTUAL_SEGMENT_LENGTH )
	{
		CString strMsg;
		CString strMin;
		CString strMax;
		
		strMin.Format( "%d", MIN_VIRTUAL_SEGMENT_LENGTH );
		strMax.Format( "%d", MAX_VIRTUAL_SEGMENT_LENGTH );
		
		HINSTANCE hInstance = AfxGetResourceHandle();
		AfxSetResourceHandle( theApp.m_hInstance );
		AfxFormatString2( strMsg, IDS_ERR_MIN_MAX, strMin, strMax );
		AfxSetResourceHandle( hInstance );
		AfxMessageBox( strMsg );
		return;
	}

	m_dwNbrMeasures = dwNewNbrMeasures;

	CDialog::OnOK();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SongDesigner\FolderSegments.cpp ===
// FolderSegments.cpp : implementation file
//

#include "stdafx.h"

#include "SongDesignerDLL.h"
#include "Song.h"
#include <SegmentDesigner.h>
#include <dmusicf.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/////////////////////////////////////////////////////////////////////////////
// CFolderSegments constructor/destructor

CFolderSegments::CFolderSegments()
{
	m_pSong = NULL;
	m_pIDocRootNode = NULL;
	m_pIParentNode = NULL;
	m_fModified = FALSE;

	TCHAR achName[MID_BUFFER];

	m_FolderEmbed.m_guidTypeNode = GUID_Song_SegmentEmbedFolderNode;
	::LoadString( theApp.m_hInstance, IDS_EMBED_FOLDER_NAME, achName, MID_BUFFER );
	m_FolderEmbed.m_strName = achName;

	m_FolderReference.m_guidTypeNode = GUID_Song_SegmentRefFolderNode;
	::LoadString( theApp.m_hInstance, IDS_REF_FOLDER_NAME, achName, MID_BUFFER );
	m_FolderReference.m_strName = achName;
}

CFolderSegments::~CFolderSegments()
{
}


/////////////////////////////////////////////////////////////////////////////
// CFolderSegments IUnknown implementation

HRESULT CFolderSegments::QueryInterface( REFIID riid, LPVOID FAR* ppvObj )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    if( ::IsEqualIID(riid, IID_IDMUSProdNode)
	||  ::IsEqualIID(riid, IID_IUnknown) )
    {
        AddRef();
        *ppvObj = this;
        return S_OK;
    }

    if( ::IsEqualIID(riid, IID_IDMUSProdPropPageObject) )
    {
		if( m_pSong )
		{
	        return m_pSong->QueryInterface( riid, ppvObj );
		}

		*ppvObj = NULL;
		return E_NOINTERFACE;
    }

    *ppvObj = NULL;
    return E_NOINTERFACE;
}

ULONG CFolderSegments::AddRef()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pSong != NULL );

	AfxOleLockApp(); 

	return m_pSong->AddRef();
}

ULONG CFolderSegments::Release()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pSong != NULL );

	AfxOleUnlockApp(); 

	return m_pSong->Release();
}


/////////////////////////////////////////////////////////////////////////////
// CFolderSegments IDMUSProdNode implementation

/////////////////////////////////////////////////////////////////////////////
// CFolderSegments IDMUSProdNode::GetNodeImageIndex

HRESULT CFolderSegments::GetNodeImageIndex( short* pnFirstImage )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( theApp.m_pSongComponent != NULL );

	return( theApp.m_pSongComponent->GetFolderImageIndex(pnFirstImage) );
}


/////////////////////////////////////////////////////////////////////////////
// CFolderSegments IDMUSProdNode::GetFirstChild

HRESULT CFolderSegments::GetFirstChild( IDMUSProdNode** ppIFirstChildNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( ppIFirstChildNode == NULL )
	{
		return E_POINTER;
	}
	
	m_FolderEmbed.AddRef();
	*ppIFirstChildNode = (IDMUSProdNode *)&m_FolderEmbed;

    return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CFolderSegments IDMUSProdNode::GetNextChild

HRESULT CFolderSegments::GetNextChild( IDMUSProdNode* pIChildNode, IDMUSProdNode** ppINextChildNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( ppINextChildNode == NULL )
	{
		return E_POINTER;
	}
	
	*ppINextChildNode = NULL;

	if( pIChildNode == NULL )
	{
		return E_INVALIDARG;
	}

	if( pIChildNode == (IDMUSProdNode *)&m_FolderEmbed )
	{
		m_FolderReference.AddRef();
		*ppINextChildNode = (IDMUSProdNode *)&m_FolderReference;
	}

    return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CFolderSegments IDMUSProdNode::GetComponent

HRESULT CFolderSegments::GetComponent( IDMUSProdComponent** ppIComponent )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( theApp.m_pSongComponent != NULL );

	return theApp.m_pSongComponent->QueryInterface( IID_IDMUSProdComponent, (void**)ppIComponent );
}


/////////////////////////////////////////////////////////////////////////////
// CFolderSegments IDMUSProdNode::GetDocRootNode

HRESULT CFolderSegments::GetDocRootNode( IDMUSProdNode** ppIDocRootNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pIDocRootNode )
	{
		m_pIDocRootNode->AddRef();
		*ppIDocRootNode = m_pIDocRootNode;
		return S_OK;
	}

	*ppIDocRootNode = NULL;
	return E_FAIL;
}


/////////////////////////////////////////////////////////////////////////////
// CFolderSegments IDMUSProdNode::SetDocRootNode

HRESULT CFolderSegments::SetDocRootNode( IDMUSProdNode* pIDocRootNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( pIDocRootNode != NULL );

	m_pIDocRootNode = pIDocRootNode;
//	m_pIDocRootNode->AddRef();		intentionally missing

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CFolderSegments IDMUSProdNode::GetParentNode

HRESULT CFolderSegments::GetParentNode( IDMUSProdNode** ppIParentNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pIParentNode != NULL );

	m_pIParentNode->AddRef();
	*ppIParentNode = m_pIParentNode;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CFolderSegments IDMUSProdNode::SetParentNode

HRESULT CFolderSegments::SetParentNode( IDMUSProdNode* pIParentNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( pIParentNode != NULL );

	m_pIParentNode = pIParentNode;
//	m_pIParentNode->AddRef();		intentionally missing

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CFolderSegments IDMUSProdNode::GetNodeId

HRESULT CFolderSegments::GetNodeId( GUID* pguid )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( pguid == NULL )
	{
		return E_POINTER;
	}

	*pguid = GUID_Song_SegmentsFolderNode;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CFolderSegments IDMUSProdNode::GetNodeName

HRESULT CFolderSegments::GetNodeName( BSTR* pbstrName )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CString strName;
	TCHAR achBuffer[MID_BUFFER];

	if( ::LoadString(theApp.m_hInstance, IDS_SEGMENTS_FOLDER_NAME, achBuffer, MID_BUFFER) )
	{
		strName = achBuffer;
	}

    *pbstrName = strName.AllocSysString();

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CFolderSegments IDMUSProdNode::GetNodeNameMaxLength

HRESULT CFolderSegments::GetNodeNameMaxLength( short* pnMaxLength )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	*pnMaxLength = -1;	// Can't rename a 'Source Segments' folder

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CFolderSegments IDMUSProdNode::ValidateNodeName

HRESULT CFolderSegments::ValidateNodeName( BSTR bstrName )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);

	return E_NOTIMPL;	// Can't rename a 'Source Segments' folder
}


/////////////////////////////////////////////////////////////////////////////
// CFolderSegments IDMUSProdNode::SetNodeName

HRESULT CFolderSegments::SetNodeName( BSTR bstrName )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);

	return E_NOTIMPL;	// Can't rename a 'Source Segments' folder
}


/////////////////////////////////////////////////////////////////////////////
// CFolderSegments IDMUSProdNode::GetNodeListInfo

HRESULT CFolderSegments::GetNodeListInfo( DMUSProdListInfo* pListInfo )
{
//	AFX_MANAGE_STATE( _afxModuleAddrThis );

	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CFolderSegments IDMUSProdNode::GetEditorClsId

HRESULT CFolderSegments::GetEditorClsId( CLSID* pClsId )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);

	return E_NOTIMPL;	// Can't edit a 'Source Segments' folder
}


/////////////////////////////////////////////////////////////////////////////
// CFolderSegments IDMUSProdNode::GetEditorTitle

HRESULT CFolderSegments::GetEditorTitle( BSTR* pbstrTitle )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);

	return E_NOTIMPL;	// Can't edit a 'Source Segments' folder
}


/////////////////////////////////////////////////////////////////////////////
// CFolderSegments IDMUSProdNode::GetEditorWindow

HRESULT CFolderSegments::GetEditorWindow( HWND* hWndEditor )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);

	return E_NOTIMPL;	// Can't edit a 'Source Segments' folder
}


/////////////////////////////////////////////////////////////////////////////
// CFolderSegments IDMUSProdNode::SetEditorWindow

HRESULT CFolderSegments::SetEditorWindow( HWND hWndEditor )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);

	return E_NOTIMPL;	// Can't edit a 'Source Segments' folder
}


/////////////////////////////////////////////////////////////////////////////
// CFolderSegments IDMUSProdNode::UseOpenCloseImages

HRESULT CFolderSegments::UseOpenCloseImages( BOOL* pfUseOpenCloseImages )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	*pfUseOpenCloseImages = TRUE;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CFolderSegments IDMUSProdNode::GetRightClickMenuId

HRESULT CFolderSegments::GetRightClickMenuId( HINSTANCE* phInstance, UINT* pnMenuId )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	*phInstance = theApp.m_hInstance;
	*pnMenuId   = IDM_FOLDER_SEGMENTS_NODE_RMENU;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CFolderSegments IDMUSProdNode::OnRightClickMenuInit

HRESULT CFolderSegments::OnRightClickMenuInit( HMENU hMenu )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CMenu menu;

	if( menu.Attach(hMenu) )
	{
		// IDM_PASTE
		{
			IDataObject* pIDataObject;
			BOOL fWillSetReference;

			menu.EnableMenuItem( ID_EDIT_PASTE, (MF_GRAYED | MF_BYCOMMAND) );

			if( SUCCEEDED ( ::OleGetClipboard( &pIDataObject ) ) )
			{
				if( CanPasteFromData( pIDataObject, &fWillSetReference ) == S_OK )
				{
					menu.EnableMenuItem( ID_EDIT_PASTE, (MF_ENABLED | MF_BYCOMMAND) );
				}
				
				pIDataObject->Release();
			}
		}

		// IDM_PROPERTIES
		IDMUSProdPropPageObject* pIPageObject;
		if( SUCCEEDED ( QueryInterface( IID_IDMUSProdPropPageObject, (void **)&pIPageObject ) ) )
		{
			menu.EnableMenuItem( IDM_PROPERTIES, (MF_ENABLED | MF_BYCOMMAND) );
			RELEASE( pIPageObject );
		}
		else
		{
			menu.EnableMenuItem( IDM_PROPERTIES, (MF_GRAYED | MF_BYCOMMAND) );
		}

		menu.Detach();
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CFolderSegments IDMUSProdNode::OnRightClickMenuSelect

HRESULT CFolderSegments::OnRightClickMenuSelect( long lCommandId )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pSong != NULL );

	HRESULT hr = E_FAIL;

	switch( lCommandId )
	{
		case IDM_NEW_SOURCE_SEGMENT:
			hr = m_FolderReference.InsertChildNode( NULL );
			break;

		case ID_EDIT_PASTE:
		{
			IDataObject* pIDataObject;
			BOOL fWillSetReference;

			if( SUCCEEDED ( ::OleGetClipboard( &pIDataObject ) ) )
			{
				if( CanPasteFromData( pIDataObject, &fWillSetReference ) == S_OK )
				{
					PasteFromData( pIDataObject );
				}
				
				RELEASE( pIDataObject );
			}
			break;
		}

		case IDM_PROPERTIES:
		{
			IDMUSProdPropPageObject* pIPageObject;

			if( SUCCEEDED ( QueryInterface( IID_IDMUSProdPropPageObject, (void **)&pIPageObject ) ) )
			{
				pIPageObject->OnShowProperties();
				RELEASE( pIPageObject );
			}
			hr = S_OK;
			break;
		}
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CFolderSegments IDMUSProdNode::DeleteChildNode

HRESULT CFolderSegments::DeleteChildNode( IDMUSProdNode* pIChildNode, BOOL fPromptUser )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(pIChildNode);
	UNREFERENCED_PARAMETER(fPromptUser);

	return E_NOTIMPL;	// Can't delete children from a 'Source Segments' folder
}


/////////////////////////////////////////////////////////////////////////////
// CFolderSegments IDMUSProdNode::InsertChildNode

HRESULT CFolderSegments::InsertChildNode( IDMUSProdNode* pIChildNode )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(pIChildNode);

	return E_NOTIMPL;	// Can't insert children into a 'Source Segments' folder
}


/////////////////////////////////////////////////////////////////////////////
// CFolderSegments IDMUSProdNode::DeleteNode

HRESULT CFolderSegments::DeleteNode( BOOL fPromptUser )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);

	return E_NOTIMPL;	// Can't delete a 'Source Segments' folder
}


/////////////////////////////////////////////////////////////////////////////
// CFolderSegments IDMUSProdNode::OnNodeSelChanged

HRESULT CFolderSegments::OnNodeSelChanged( BOOL fSelected )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CFolderSegments IDMUSProdNode::CreateDataObject

HRESULT CFolderSegments::CreateDataObject( IDataObject** ppIDataObject )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( ppIDataObject == NULL )
	{
		return E_POINTER;
	}

	*ppIDataObject = NULL;

	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CFolderSegments IDMUSProdNode::CanCut

HRESULT CFolderSegments::CanCut( void )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
 
	return S_FALSE;		// Can't remove the 'Source Segments' folder from Song
}


/////////////////////////////////////////////////////////////////////////////
// CFolderSegments IDMUSProdNode::CanCopy

HRESULT CFolderSegments::CanCopy( void )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
 
	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CFolderSegments IDMUSProdNode::CanDelete

HRESULT CFolderSegments::CanDelete( void )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);

	return S_FALSE;		// Can't remove the 'Source Segments' folder from Song
}


/////////////////////////////////////////////////////////////////////////////
// CFolderSegments IDMUSProdNode::CanDeleteChildNode

HRESULT CFolderSegments::CanDeleteChildNode( IDMUSProdNode* pIChildNode )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(pIChildNode);

	ASSERT( 0 );

	return E_NOTIMPL;	// Cannot delete children
}


/////////////////////////////////////////////////////////////////////////////
// CFolderSegments IDMUSProdNode::CanPasteFromData

HRESULT CFolderSegments::CanPasteFromData( IDataObject* pIDataObject, BOOL* pfWillSetReference )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Let reference folder handle CanPasteFromData()
	return m_FolderReference.CanPasteFromData( pIDataObject, pfWillSetReference );
}


/////////////////////////////////////////////////////////////////////////////
// CFolderSegments IDMUSProdNode::PasteFromData

HRESULT CFolderSegments::PasteFromData( IDataObject* pIDataObject )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Let reference folder handle PasteFromData()
	return m_FolderReference.PasteFromData( pIDataObject );
}


/////////////////////////////////////////////////////////////////////////////
// CFolderSegments IDMUSProdNode::CanChildPasteFromData

HRESULT CFolderSegments::CanChildPasteFromData( IDataObject* pIDataObject, IDMUSProdNode* pIChildNode,
											   BOOL* pfWillSetReference )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	
	ASSERT( 0 );	// Should not happen!
	return E_FAIL;
}


/////////////////////////////////////////////////////////////////////////////
// CFolderSegments IDMUSProdNode::ChildPasteFromData

HRESULT CFolderSegments::ChildPasteFromData( IDataObject* pIDataObject, IDMUSProdNode* pIChildNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	
	ASSERT( 0 );	// Should not happen!
	return E_FAIL;
}


/////////////////////////////////////////////////////////////////////////////
// CFolderSegments IDMUSProdNode::GetObject

HRESULT CFolderSegments::GetObject( REFCLSID rclsid, REFIID riid, void** ppvObject )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);

	return E_NOTIMPL;
}


///////////////////////////////////////////////////////////////////////////
// CFolderSegments::OnUpdate

HRESULT CFolderSegments::OnUpdate( IDMUSProdNode* pIDocRootNode, GUID guidUpdateType, VOID* pData )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Check Embed Runtime folder
	m_FolderEmbed.OnUpdate( pIDocRootNode, guidUpdateType, pData );

	// Check Reference Runtime folder
	m_FolderReference.OnUpdate( pIDocRootNode, guidUpdateType, pData );

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CFolderSegments SaveSegments
    
HRESULT CFolderSegments::SaveSegments( IDMUSProdRIFFStream* pIRiffStream )
{
	HRESULT hr = S_OK;
    MMCKINFO ckMain;

	// Write DMUS_FOURCC_SONGSEGMENTS_LIST header
	ckMain.fccType = DMUS_FOURCC_SONGSEGMENTS_LIST;
	if( pIRiffStream->CreateChunk(&ckMain, MMIO_CREATELIST) != 0 )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

	// Save embedded list
	hr = m_FolderEmbed.SaveSegments( pIRiffStream );
	if( FAILED( hr ) )
	{
		goto ON_ERROR;
	}

	// Save referenced list
	hr = m_FolderReference.SaveSegments( pIRiffStream );
	if( FAILED( hr ) )
	{
		goto ON_ERROR;
	}

	if( pIRiffStream->Ascend(&ckMain, 0) != 0 )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

ON_ERROR:
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CFolderSegments LoadSegments
    
HRESULT CFolderSegments::LoadSegments( IDMUSProdRIFFStream* pIRiffStream, MMCKINFO* pckMain )
{
	IStream* pIStream;
	HRESULT hr = S_OK;
    MMCKINFO ck;
	DWORD dwPos;

    pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

    dwPos = StreamTell( pIStream );

	while( pIRiffStream->Descend( &ck, pckMain, 0 ) == 0 )
	{
		switch( ck.ckid )
		{
			case FOURCC_LIST:
				switch( ck.fccType )
				{
					case DMUS_FOURCC_SONGSEGMENT_LIST:
					{
						CSourceSegment* pSourceSegment = new CSourceSegment( m_pSong );
						if( pSourceSegment == NULL )
						{
							hr = E_OUTOFMEMORY;
							goto ON_ERROR;
						}

						BOOL fReference = FALSE;

						hr = pSourceSegment->Load( pIRiffStream, &ck, &fReference );
						if( hr == S_OK )
						{
							if( fReference  )
							{
								m_FolderReference.m_lstSegments.AddTail( pSourceSegment );
							}
							else
							{
								m_FolderEmbed.m_lstSegments.AddTail( pSourceSegment );
							}
						}
						else if( hr == S_FALSE )
						{
							// Could not resolve file reference so discard this object
							delete pSourceSegment;
							hr = S_OK;
						}
						else
						{
							delete pSourceSegment;
							goto ON_ERROR;
						}
						break;
					}
				}
		}

		pIRiffStream->Ascend( &ck, 0 );
	    dwPos = StreamTell( pIStream );
	}

ON_ERROR:
	RELEASE( pIStream );
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SongDesigner\DlgSetLength.h ===
#if !defined(AFX_DLGSETLENGTH_H__B2B7FA22_73ED_11D1_89AE_00A0C9054129__INCLUDED_)
#define AFX_DLGSETLENGTH_H__B2B7FA22_73ED_11D1_89AE_00A0C9054129__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// DlgSetLength.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CDlgSetLength dialog

class CDlgSetLength : public CDialog
{
// Construction
public:
	CDlgSetLength(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CDlgSetLength)
	enum { IDD = IDD_SET_LENGTH };
	CEdit	m_editLength;
	CButton	m_btnOK;
	CSpinButtonCtrl	m_spinLength;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CDlgSetLength)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CDlgSetLength)
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

public:
	DWORD	m_dwNbrMeasures;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DLGSETLENGTH_H__B2B7FA22_73ED_11D1_89AE_00A0C9054129__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SongDesigner\Folder.h ===
#ifndef __FOLDER_H__
#define __FOLDER_H__

// Folder.h : header file
//

#include "SourceSegment.h"
#include <afxtempl.h>


class CDirectMusicSong;

class CFolder : public IDMUSProdNode
{
friend class CDirectMusicSong;
friend class CFolderSegments;

public:
    CFolder();
	~CFolder();

    // IUnknown functions
    HRESULT STDMETHODCALLTYPE QueryInterface( REFIID riid, LPVOID *ppv );
    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();

    // IDMUSProdNode functions
	HRESULT STDMETHODCALLTYPE GetNodeImageIndex( short* pnNbrFirstImage );
    HRESULT STDMETHODCALLTYPE GetFirstChild( IDMUSProdNode** ppIFirstChildNode );
    HRESULT STDMETHODCALLTYPE GetNextChild( IDMUSProdNode* pIChildNode, IDMUSProdNode** ppINextChildNode );

    HRESULT STDMETHODCALLTYPE GetComponent( IDMUSProdComponent** ppIComponent );
    HRESULT STDMETHODCALLTYPE GetDocRootNode( IDMUSProdNode** ppIDocRootNode );
    HRESULT STDMETHODCALLTYPE SetDocRootNode( IDMUSProdNode* pIDocRootNode );
    HRESULT STDMETHODCALLTYPE GetParentNode( IDMUSProdNode** ppIParentNode );
    HRESULT STDMETHODCALLTYPE SetParentNode( IDMUSProdNode* pIParentNode );
    HRESULT STDMETHODCALLTYPE GetNodeId( GUID* pguid );
    HRESULT STDMETHODCALLTYPE GetNodeName( BSTR* pbstrName );
    HRESULT STDMETHODCALLTYPE GetNodeNameMaxLength( short* pnMaxLength );
    HRESULT STDMETHODCALLTYPE ValidateNodeName( BSTR bstrName );
    HRESULT STDMETHODCALLTYPE SetNodeName( BSTR bstrName );
	HRESULT STDMETHODCALLTYPE GetNodeListInfo( DMUSProdListInfo* pListInfo );

    HRESULT STDMETHODCALLTYPE GetEditorClsId( CLSID* pclsid );
    HRESULT STDMETHODCALLTYPE GetEditorTitle( BSTR* pbstrTitle );
    HRESULT STDMETHODCALLTYPE GetEditorWindow( HWND* hWndEditor );
    HRESULT STDMETHODCALLTYPE SetEditorWindow( HWND hWndEditor );

	HRESULT STDMETHODCALLTYPE UseOpenCloseImages( BOOL* pfUseOpenCloseImages );

    HRESULT STDMETHODCALLTYPE GetRightClickMenuId( HINSTANCE* phInstance, UINT* pnResourceId );
    HRESULT STDMETHODCALLTYPE OnRightClickMenuInit( HMENU hMenu );
    HRESULT STDMETHODCALLTYPE OnRightClickMenuSelect( long lCommandId );

    HRESULT STDMETHODCALLTYPE DeleteChildNode( IDMUSProdNode* pIChildNode, BOOL fPromptUser );
    HRESULT STDMETHODCALLTYPE InsertChildNode( IDMUSProdNode* pIChildNode );
    HRESULT STDMETHODCALLTYPE DeleteNode( BOOL fPromptUser );

	HRESULT STDMETHODCALLTYPE OnNodeSelChanged( BOOL fSelected );

	HRESULT STDMETHODCALLTYPE CreateDataObject( IDataObject** ppIDataObject );
	HRESULT STDMETHODCALLTYPE CanCut();
	HRESULT STDMETHODCALLTYPE CanCopy();
	HRESULT STDMETHODCALLTYPE CanDelete();
	HRESULT STDMETHODCALLTYPE CanDeleteChildNode( IDMUSProdNode* pIChildNode );
	HRESULT STDMETHODCALLTYPE CanPasteFromData( IDataObject* pIDataObject, BOOL* pfWillSetReference );
	HRESULT STDMETHODCALLTYPE PasteFromData( IDataObject* pIDataObject );
	HRESULT STDMETHODCALLTYPE CanChildPasteFromData( IDataObject* pIDataObject, IDMUSProdNode* pIChildNode, BOOL* pfWillSetReference );
	HRESULT STDMETHODCALLTYPE ChildPasteFromData( IDataObject* pIDataObject, IDMUSProdNode* pIChildNode );

	HRESULT STDMETHODCALLTYPE GetObject( REFCLSID rclsid, REFIID riid, void** ppvObject ); 

	// Additional methods
private:
    HRESULT SaveSegments( IDMUSProdRIFFStream* pIRiffStream );
	HRESULT InsertSourceSegment( CSourceSegment* pSourceSegment );
	HRESULT RemoveSourceSegment( CSourceSegment* pSourceSegment );
	HRESULT OnUpdate( IDMUSProdNode* pIDocRootNode, GUID guidUpdateType, VOID* pData );
	CSourceSegment* GetSourceSegmentFromDocRoot( IDMUSProdNode* pIDocRootNode );
	void EmptySourceSegmentList();

public:
	BOOL IsDocRootInFolder( IDMUSProdNode* pIDocRootNode );

private:
	IDMUSProdNode*			m_pIDocRootNode;
	IDMUSProdNode*			m_pIParentNode;

	CDirectMusicSong*		m_pSong;
	CString					m_strName;
	GUID					m_guidTypeNode;

	// Persisted for DirectMusic
	CTypedPtrList<CPtrList, CSourceSegment*> m_lstSegments;
};

#endif // __FOLDER_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SongDesigner\FolderSegments.h ===
#ifndef __FOLDERSEGMENTS_H__
#define __FOLDERSEGMENTS_H__

// FolderSegments.h : header file
//

#include "Folder.h"
#include <afxtempl.h>

class CDirectMusicSong;

class CFolderSegments : public IDMUSProdNode
{
friend class CDirectMusicSong;
friend class CSongDlg;

public:
    CFolderSegments();
	~CFolderSegments();

    // IUnknown functions
    HRESULT STDMETHODCALLTYPE QueryInterface( REFIID riid, LPVOID *ppv );
    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();

    // IDMUSProdNode functions
	HRESULT STDMETHODCALLTYPE GetNodeImageIndex( short* pnNbrFirstImage );
    HRESULT STDMETHODCALLTYPE GetFirstChild( IDMUSProdNode** ppIFirstChildNode );
    HRESULT STDMETHODCALLTYPE GetNextChild( IDMUSProdNode* pIChildNode, IDMUSProdNode** ppINextChildNode );

    HRESULT STDMETHODCALLTYPE GetComponent( IDMUSProdComponent** ppIComponent );
    HRESULT STDMETHODCALLTYPE GetDocRootNode( IDMUSProdNode** ppIDocRootNode );
    HRESULT STDMETHODCALLTYPE SetDocRootNode( IDMUSProdNode* pIDocRootNode );
    HRESULT STDMETHODCALLTYPE GetParentNode( IDMUSProdNode** ppIParentNode );
    HRESULT STDMETHODCALLTYPE SetParentNode( IDMUSProdNode* pIParentNode );
    HRESULT STDMETHODCALLTYPE GetNodeId( GUID* pguid );
    HRESULT STDMETHODCALLTYPE GetNodeName( BSTR* pbstrName );
    HRESULT STDMETHODCALLTYPE GetNodeNameMaxLength( short* pnMaxLength );
    HRESULT STDMETHODCALLTYPE ValidateNodeName( BSTR bstrName );
    HRESULT STDMETHODCALLTYPE SetNodeName( BSTR bstrName );
	HRESULT STDMETHODCALLTYPE GetNodeListInfo( DMUSProdListInfo* pListInfo );

    HRESULT STDMETHODCALLTYPE GetEditorClsId( CLSID* pclsid );
    HRESULT STDMETHODCALLTYPE GetEditorTitle( BSTR* pbstrTitle );
    HRESULT STDMETHODCALLTYPE GetEditorWindow( HWND* hWndEditor );
    HRESULT STDMETHODCALLTYPE SetEditorWindow( HWND hWndEditor );

	HRESULT STDMETHODCALLTYPE UseOpenCloseImages( BOOL* pfUseOpenCloseImages );

    HRESULT STDMETHODCALLTYPE GetRightClickMenuId( HINSTANCE* phInstance, UINT* pnResourceId );
    HRESULT STDMETHODCALLTYPE OnRightClickMenuInit( HMENU hMenu );
    HRESULT STDMETHODCALLTYPE OnRightClickMenuSelect( long lCommandId );

    HRESULT STDMETHODCALLTYPE DeleteChildNode( IDMUSProdNode* pIChildNode, BOOL fPromptUser );
    HRESULT STDMETHODCALLTYPE InsertChildNode( IDMUSProdNode* pIChildNode );
    HRESULT STDMETHODCALLTYPE DeleteNode( BOOL fPromptUser );

	HRESULT STDMETHODCALLTYPE OnNodeSelChanged( BOOL fSelected );

	HRESULT STDMETHODCALLTYPE CreateDataObject( IDataObject** ppIDataObject );
	HRESULT STDMETHODCALLTYPE CanCut();
	HRESULT STDMETHODCALLTYPE CanCopy();
	HRESULT STDMETHODCALLTYPE CanDelete();
	HRESULT STDMETHODCALLTYPE CanDeleteChildNode( IDMUSProdNode* pIChildNode );
	HRESULT STDMETHODCALLTYPE CanPasteFromData( IDataObject* pIDataObject, BOOL* pfWillSetReference );
	HRESULT STDMETHODCALLTYPE PasteFromData( IDataObject* pIDataObject );
	HRESULT STDMETHODCALLTYPE CanChildPasteFromData( IDataObject* pIDataObject, IDMUSProdNode* pIChildNode, BOOL* pfWillSetReference );
	HRESULT STDMETHODCALLTYPE ChildPasteFromData( IDataObject* pIDataObject, IDMUSProdNode* pIChildNode );

	HRESULT STDMETHODCALLTYPE GetObject( REFCLSID rclsid, REFIID riid, void** ppvObject ); 

	// Additional methods
private:
	HRESULT OnUpdate( IDMUSProdNode* pIDocRootNode, GUID guidUpdateType, VOID* pData );

public:
    HRESULT SaveSegments( IDMUSProdRIFFStream* pIRiffStream );
    HRESULT LoadSegments( IDMUSProdRIFFStream* pIRiffStream, MMCKINFO* pckMain );

private:
	IDMUSProdNode*			m_pIDocRootNode;
	IDMUSProdNode*		    m_pIParentNode;

	CFolder					m_FolderEmbed;
	CFolder					m_FolderReference;

	CDirectMusicSong*		m_pSong;
	BOOL					m_fModified;
};

#endif // __FOLDERSEGMENTS_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SongDesigner\Folder.cpp ===
// Folder.cpp : implementation file
//

#include "stdafx.h"

#include "SongDesignerDLL.h"
#include "Song.h"
#include "SongCtl.h"
#include <SegmentDesigner.h>
#include <SegmentGuids.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/////////////////////////////////////////////////////////////////////////////
// CFolder constructor/destructor

CFolder::CFolder()
{
	m_pSong = NULL;
	m_pIDocRootNode = NULL;
	m_pIParentNode = NULL;
}

CFolder::~CFolder()
{
	EmptySourceSegmentList();
}


/////////////////////////////////////////////////////////////////////////////
// CFolder IUnknown implementation

HRESULT CFolder::QueryInterface( REFIID riid, LPVOID FAR* ppvObj )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    if( ::IsEqualIID(riid, IID_IDMUSProdNode)
	||  ::IsEqualIID(riid, IID_IUnknown) )
    {
        AddRef();
        *ppvObj = this;
        return S_OK;
    }

    if( ::IsEqualIID(riid, IID_IDMUSProdPropPageObject) )
    {
		if( m_pSong )
		{
	        return m_pSong->QueryInterface( riid, ppvObj );
		}

		*ppvObj = NULL;
		return E_NOINTERFACE;
    }

    *ppvObj = NULL;
    return E_NOINTERFACE;
}

ULONG CFolder::AddRef()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pSong != NULL );

	AfxOleLockApp(); 

	return m_pSong->AddRef();
}

ULONG CFolder::Release()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pSong != NULL );

	AfxOleUnlockApp(); 

	return m_pSong->Release();
}


/////////////////////////////////////////////////////////////////////////////
// CFolder IDMUSProdNode implementation

/////////////////////////////////////////////////////////////////////////////
// CFolder IDMUSProdNode::GetNodeImageIndex

HRESULT CFolder::GetNodeImageIndex( short* pnFirstImage )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( theApp.m_pSongComponent != NULL );

	return( theApp.m_pSongComponent->GetFolderImageIndex(pnFirstImage) );
}


/////////////////////////////////////////////////////////////////////////////
// CFolder IDMUSProdNode::GetFirstChild

HRESULT CFolder::GetFirstChild( IDMUSProdNode** ppIFirstChildNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( ppIFirstChildNode == NULL )
	{
		return E_POINTER;
	}
	
	*ppIFirstChildNode = NULL;

	if( !m_lstSegments.IsEmpty() )
	{
		CSourceSegment* pSourceSegment = m_lstSegments.GetHead();
		
		if( pSourceSegment )
		{
			pSourceSegment->AddRef();
			*ppIFirstChildNode = (IDMUSProdNode *)pSourceSegment;
		}
	}

    return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CFolder IDMUSProdNode::GetNextChild

HRESULT CFolder::GetNextChild( IDMUSProdNode* pIChildNode, IDMUSProdNode** ppINextChildNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( ppINextChildNode == NULL )
	{
		return E_POINTER;
	}
	
	*ppINextChildNode = NULL;

	if( pIChildNode == NULL )
	{
		return E_INVALIDARG;
	}

	CSourceSegment* pSourceSegment;

    POSITION pos = m_lstSegments.GetHeadPosition();

    while( pos )
    {
        pSourceSegment = m_lstSegments.GetNext( pos );
		if( pIChildNode == (IDMUSProdNode *)pSourceSegment )
		{
			if( pos )
			{
				pSourceSegment = m_lstSegments.GetNext( pos );

				pSourceSegment->AddRef();
				*ppINextChildNode = (IDMUSProdNode *)pSourceSegment;
			}
			break;
		}
    }

    return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CFolder IDMUSProdNode::GetComponent

HRESULT CFolder::GetComponent( IDMUSProdComponent** ppIComponent )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( theApp.m_pSongComponent != NULL );

	return theApp.m_pSongComponent->QueryInterface( IID_IDMUSProdComponent, (void**)ppIComponent );
}


/////////////////////////////////////////////////////////////////////////////
// CFolder IDMUSProdNode::GetDocRootNode

HRESULT CFolder::GetDocRootNode( IDMUSProdNode** ppIDocRootNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pIDocRootNode )
	{
		m_pIDocRootNode->AddRef();
		*ppIDocRootNode = m_pIDocRootNode;
		return S_OK;
	}

	*ppIDocRootNode = NULL;
	return E_FAIL;
}


/////////////////////////////////////////////////////////////////////////////
// CFolder IDMUSProdNode::SetDocRootNode

HRESULT CFolder::SetDocRootNode( IDMUSProdNode* pIDocRootNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( pIDocRootNode != NULL );

	m_pIDocRootNode = pIDocRootNode;
//	m_pIDocRootNode->AddRef();		intentionally missing

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CFolder IDMUSProdNode::GetParentNode

HRESULT CFolder::GetParentNode( IDMUSProdNode** ppIParentNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pIParentNode != NULL );

	m_pIParentNode->AddRef();
	*ppIParentNode = m_pIParentNode;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CFolder IDMUSProdNode::SetParentNode

HRESULT CFolder::SetParentNode( IDMUSProdNode* pIParentNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( pIParentNode != NULL );

	m_pIParentNode = pIParentNode;
//	m_pIParentNode->AddRef();		intentionally missing

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CFolder IDMUSProdNode::GetNodeId

HRESULT CFolder::GetNodeId( GUID* pguid )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( pguid == NULL )
	{
		return E_POINTER;
	}

	*pguid = m_guidTypeNode;		// GUID_SegmentEmbedFolderNode
									// GUID_SegmentRefFolderNode
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CFolder IDMUSProdNode::GetNodeName

HRESULT CFolder::GetNodeName( BSTR* pbstrName )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    *pbstrName = m_strName.AllocSysString();

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CFolder IDMUSProdNode::GetNodeNameMaxLength

HRESULT CFolder::GetNodeNameMaxLength( short* pnMaxLength )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	*pnMaxLength = -1;	// Can't rename a folder

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CFolder IDMUSProdNode::ValidateNodeName

HRESULT CFolder::ValidateNodeName( BSTR bstrName )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(bstrName);

	return E_NOTIMPL;	// Can't rename a folder
}


/////////////////////////////////////////////////////////////////////////////
// CFolder IDMUSProdNode::SetNodeName

HRESULT CFolder::SetNodeName( BSTR bstrName )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(bstrName);

	return E_NOTIMPL;	// Can't rename a folder
}


/////////////////////////////////////////////////////////////////////////////
// CFolder IDMUSProdNode::GetNodeListInfo

HRESULT CFolder::GetNodeListInfo( DMUSProdListInfo* pListInfo )
{
//	AFX_MANAGE_STATE( _afxModuleAddrThis );
	UNREFERENCED_PARAMETER(pListInfo);

	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CFolder IDMUSProdNode::GetEditorClsId

HRESULT CFolder::GetEditorClsId( CLSID* pClsId )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(pClsId);

	return E_NOTIMPL;	// Can't edit a folder
}


/////////////////////////////////////////////////////////////////////////////
// CFolder IDMUSProdNode::GetEditorTitle

HRESULT CFolder::GetEditorTitle( BSTR* pbstrTitle )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(pbstrTitle);

	return E_NOTIMPL;	// Can't edit a folder
}


/////////////////////////////////////////////////////////////////////////////
// CFolder IDMUSProdNode::GetEditorWindow

HRESULT CFolder::GetEditorWindow( HWND* hWndEditor )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(hWndEditor);

	return E_NOTIMPL;	// Can't edit a folder
}


/////////////////////////////////////////////////////////////////////////////
// CFolder IDMUSProdNode::SetEditorWindow

HRESULT CFolder::SetEditorWindow( HWND hWndEditor )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(hWndEditor);

	return E_NOTIMPL;	// Can't edit a folder
}


/////////////////////////////////////////////////////////////////////////////
// CFolder IDMUSProdNode::UseOpenCloseImages

HRESULT CFolder::UseOpenCloseImages( BOOL* pfUseOpenCloseImages )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	*pfUseOpenCloseImages = TRUE;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CFolder IDMUSProdNode::GetRightClickMenuId

HRESULT CFolder::GetRightClickMenuId( HINSTANCE* phInstance, UINT* pnMenuId )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	*phInstance = theApp.m_hInstance;
	*pnMenuId   = IDM_FOLDER_NODE_RMENU;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CFolder IDMUSProdNode::OnRightClickMenuInit

HRESULT CFolder::OnRightClickMenuInit( HMENU hMenu )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CMenu menu;

	if( menu.Attach(hMenu) )
	{
		// IDM_PASTE
		{
			IDataObject* pIDataObject;
			BOOL fWillSetReference;

			menu.EnableMenuItem( ID_EDIT_PASTE, (MF_GRAYED | MF_BYCOMMAND) );

			if( SUCCEEDED ( ::OleGetClipboard( &pIDataObject ) ) )
			{
				if( CanPasteFromData( pIDataObject, &fWillSetReference ) == S_OK )
				{
					menu.EnableMenuItem( ID_EDIT_PASTE, (MF_ENABLED | MF_BYCOMMAND) );
				}
				
				pIDataObject->Release();
			}
		}

		// IDM_PROPERTIES
		IDMUSProdPropPageObject* pIPageObject;
		if( SUCCEEDED ( QueryInterface( IID_IDMUSProdPropPageObject, (void **)&pIPageObject ) ) )
		{
			menu.EnableMenuItem( IDM_PROPERTIES, (MF_ENABLED | MF_BYCOMMAND) );
			RELEASE( pIPageObject );
		}
		else
		{
			menu.EnableMenuItem( IDM_PROPERTIES, (MF_GRAYED | MF_BYCOMMAND) );
		}

		menu.Detach();
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CFolder IDMUSProdNode::OnRightClickMenuSelect

HRESULT CFolder::OnRightClickMenuSelect( long lCommandId )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pSong != NULL );

	HRESULT hr = E_FAIL;

	switch( lCommandId )
	{
		case IDM_NEW_SOURCE_SEGMENT:
			hr = InsertChildNode( NULL );
			break;

		case ID_EDIT_PASTE:
		{
			IDataObject* pIDataObject;
			BOOL fWillSetReference;

			if( SUCCEEDED ( ::OleGetClipboard( &pIDataObject ) ) )
			{
				if( CanPasteFromData( pIDataObject, &fWillSetReference ) == S_OK )
				{
					PasteFromData( pIDataObject );
				}
				
				RELEASE( pIDataObject );
			}
			break;
		}

		case IDM_PROPERTIES:
		{
			IDMUSProdPropPageObject* pIPageObject;

			if( SUCCEEDED ( QueryInterface( IID_IDMUSProdPropPageObject, (void **)&pIPageObject ) ) )
			{
				pIPageObject->OnShowProperties();
				RELEASE( pIPageObject );
			}
			hr = S_OK;
			break;
		}
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CFolder IDMUSProdNode::DeleteChildNode

HRESULT CFolder::DeleteChildNode( IDMUSProdNode* pIChildNode, BOOL fPromptUser )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( pIChildNode != NULL );
	ASSERT( m_pSong != NULL );
	ASSERT( theApp.m_pSongComponent != NULL );
	ASSERT( theApp.m_pSongComponent->m_pIFramework8 != NULL );

	CWaitCursor wait;

	if( pIChildNode == NULL )
	{
		return E_INVALIDARG;
	}

	// Make sure we received a SourceSegment node
	GUID guidNodeId;
	HRESULT hr = pIChildNode->GetNodeId( &guidNodeId );
	if( SUCCEEDED ( hr ) )
	{
		if( ::IsEqualGUID( guidNodeId, GUID_Song_SourceSegmentNode ) == FALSE )
		{
			hr = E_FAIL;
		}
	}
	if( FAILED( hr ) )
	{
		return hr;
	}
	CSourceSegment* pSourceSegment = (CSourceSegment *)pIChildNode;

	// Are you sure?
	if( fPromptUser )
	{
		CString strName;
		ASSERT( pSourceSegment->m_FileRef.pIRefNode != NULL );
		if( pSourceSegment->m_FileRef.pIRefNode == NULL )
		{
			TCHAR achNoObject[MID_BUFFER];
			::LoadString( theApp.m_hInstance, IDS_EMPTY_TEXT, achNoObject, MID_BUFFER );
			strName = achNoObject;
		}
		else
		{
			BSTR bstrName;
			if( SUCCEEDED ( pSourceSegment->m_FileRef.pIRefNode->GetNodeName( &bstrName ) ) )
			{
				strName = bstrName;
				::SysFreeString( bstrName );
			}
		}
		CString strPrompt;
		AfxFormatString1( strPrompt, IDS_DELETE_NODE_PROMPT, strName );
		if( AfxMessageBox( strPrompt, MB_OKCANCEL ) != IDOK )
		{
			return E_FAIL;
		}
	}

	// Remove node from Project Tree
	if( theApp.m_pSongComponent->m_pIFramework8->RemoveNode( pIChildNode, FALSE ) == S_FALSE )
	{
		return E_FAIL;
	}

	// Save undo state
//	m_pSong->m_pINodeBeingDeleted = pIChildNode;
//	m_pSong->m_pUndoMgr->SaveState( m_pSong, theApp.m_hInstance, IDS_UNDO_DELETE_BAND );
//	m_pSong->m_pINodeBeingDeleted = NULL;

	// Remove from Segment list
	RemoveSourceSegment( pSourceSegment );

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CFolder IDMUSProdNode::InsertChildNode

HRESULT CFolder::InsertChildNode( IDMUSProdNode* pIChildNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pSong != NULL );
	ASSERT( theApp.m_pSongComponent != NULL );
	ASSERT( theApp.m_pSongComponent->m_pIFramework8 != NULL );

	HRESULT hr = E_FAIL;

	if( pIChildNode )
	{
		// Make sure we received a SourceSegment node
		GUID guidNodeId;
		hr = pIChildNode->GetNodeId( &guidNodeId );
		if( SUCCEEDED ( hr ) )
		{
			if( ::IsEqualGUID( guidNodeId, GUID_Song_SourceSegmentNode ) )
			{
				// Add to SourceSegment list
				InsertSourceSegment( (CSourceSegment *)pIChildNode );
			}
			else
			{
				hr = E_FAIL;
			}
		}
	}
	else
	{
		// Create the Segment
		IDMUSProdDocType* pIDocType;
		hr = theApp.m_pSongComponent->m_pIFramework8->FindDocTypeByNodeId( GUID_SegmentNode, &pIDocType );
		if( SUCCEEDED ( hr ) ) 
		{
			IDMUSProdNode* pIDocRootNode;
			hr = theApp.m_pSongComponent->m_pIFramework8->CreateNewFile( pIDocType, m_pSong, &pIDocRootNode );
			if( SUCCEEDED ( hr ) )
			{
				CSourceSegment* pSourceSegment = new CSourceSegment( m_pSong );
				if( pSourceSegment )
				{
					hr = pSourceSegment->SetFileReference( pIDocRootNode );
					if( SUCCEEDED ( hr ) )
					{
						// Add to SourceSegment list
						InsertSourceSegment( pSourceSegment );
						pSourceSegment->Release();

						pIChildNode = (IDMUSProdNode *)pSourceSegment;
					}
				}
				else
				{
					hr = E_OUTOFMEMORY;
				}

				RELEASE( pIDocRootNode );
			}

			RELEASE( pIDocType );
		}
	}

	if( SUCCEEDED ( hr ) )
	{
		// Set root and parent node of ALL children
		ASSERT( pIChildNode != NULL );
		ASSERT( m_pIDocRootNode != NULL );
		theApp.SetNodePointers( pIChildNode, m_pIDocRootNode, (IDMUSProdNode *)this );

		// Add node to Project Tree
		hr = theApp.m_pSongComponent->m_pIFramework8->AddNode( pIChildNode, (IDMUSProdNode *)this );
		if( FAILED ( hr ) )
		{
			DeleteChildNode( pIChildNode, FALSE );
		}
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CFolder IDMUSProdNode::DeleteNode

HRESULT CFolder::DeleteNode( BOOL fPromptUser )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(fPromptUser);

	return E_NOTIMPL;	// Can't delete a folder
}


/////////////////////////////////////////////////////////////////////////////
// CFolder IDMUSProdNode::OnNodeSelChanged

HRESULT CFolder::OnNodeSelChanged( BOOL fSelected )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(fSelected);

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CFolder IDMUSProdNode::CreateDataObject

HRESULT CFolder::CreateDataObject( IDataObject** ppIDataObject )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( ppIDataObject == NULL )
	{
		return E_POINTER;
	}

	*ppIDataObject = NULL;

	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CFolder IDMUSProdNode::CanCut

HRESULT CFolder::CanCut( void )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
 
	return S_FALSE;		// Can't remove a folder
}


/////////////////////////////////////////////////////////////////////////////
// CFolder IDMUSProdNode::CanCopy

HRESULT CFolder::CanCopy( void )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
 
	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CFolder IDMUSProdNode::CanDelete

HRESULT CFolder::CanDelete( void )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);

	return S_FALSE;		// Can't delete a folder
}


/////////////////////////////////////////////////////////////////////////////
// CFolder IDMUSProdNode::CanDeleteChildNode

HRESULT CFolder::CanDeleteChildNode( IDMUSProdNode* pIChildNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Make sure we received a SourceSegment node
	GUID guidNodeId;
	HRESULT hr = pIChildNode->GetNodeId( &guidNodeId );
	if( SUCCEEDED ( hr ) )
	{
		if( ::IsEqualGUID( guidNodeId, GUID_Song_SourceSegmentNode ) == FALSE )
		{
			ASSERT( 0 );
			hr = E_FAIL;
		}
	}
	if( FAILED( hr ) )
	{
		return hr;
	}

	// Make sure node is in Segment list
	POSITION pos = m_lstSegments.Find( (CSourceSegment *)pIChildNode );
	if( pos == NULL )
	{
		return E_FAIL;
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CFolder IDMUSProdNode::CanPasteFromData

HRESULT CFolder::CanPasteFromData( IDataObject* pIDataObject, BOOL* pfWillSetReference )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pSong != NULL );
	ASSERT( theApp.m_pSongComponent->m_pIFramework8 != NULL );

	if( pfWillSetReference == NULL )
	{
		return E_POINTER;
	}

	*pfWillSetReference = TRUE;

	if( pIDataObject == NULL )
	{
		return E_INVALIDARG;
	}

	// Create a new CDllJazzDataObject and see if it can read the data object's format.
	CDllJazzDataObject* pDataObject = new CDllJazzDataObject();
	if( pDataObject == NULL )
	{
		return E_OUTOFMEMORY;
	}

	HRESULT hr = E_FAIL;
	
	if( SUCCEEDED (	pDataObject->IsClipFormatAvailable( pIDataObject, theApp.m_pSongComponent->m_cfSegment ) ) )
	{
		IDMUSProdNode* pIDocRootNode;

		if( SUCCEEDED ( theApp.m_pSongComponent->m_pIFramework8->GetDocRootNodeFromData( pIDataObject, &pIDocRootNode ) ) )
		{
			if( IsDocRootInFolder( pIDocRootNode ) == FALSE )
			{
				hr = S_OK;
			}

			RELEASE( pIDocRootNode );
		}
	}

	RELEASE( pDataObject );
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CFolder IDMUSProdNode::PasteFromData

HRESULT CFolder::PasteFromData( IDataObject* pIDataObject )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pSong != NULL );
	ASSERT( theApp.m_pSongComponent->m_pIFramework8 != NULL );

	if( pIDataObject == NULL )
	{
		return E_INVALIDARG;
	}

	// Create a new CDllJazzDataObject and see if it can read the data object's format.
	CDllJazzDataObject* pDataObject = new CDllJazzDataObject();
	if( pDataObject == NULL )
	{
		return E_OUTOFMEMORY;
	}

	HRESULT hr;

	hr = pDataObject->IsClipFormatAvailable( pIDataObject, theApp.m_pSongComponent->m_cfSegment );
	if( SUCCEEDED ( hr ) )
	{
		IDMUSProdNode* pIDocRootNode;
		hr = theApp.m_pSongComponent->m_pIFramework8->GetDocRootNodeFromData( pIDataObject, &pIDocRootNode );
		if( SUCCEEDED ( hr ) )
		{
			CSourceSegment* pSourceSegment = NULL;

			// If DocRoot is in the other folder - remove it
			if( ::IsEqualGUID( m_guidTypeNode, GUID_Song_SegmentEmbedFolderNode ) ) 
			{
				CFolder* pFolderReference = m_pSong->GetSegmentRefFolder();
				pSourceSegment = pFolderReference->GetSourceSegmentFromDocRoot( pIDocRootNode );
				if( pSourceSegment )
				{
					pSourceSegment->AddRef();
					m_pSong->m_fChangingFolder = true;
					pFolderReference->DeleteChildNode( pSourceSegment, FALSE );
					m_pSong->m_fChangingFolder = false;
				}
			}
			else if( ::IsEqualGUID( m_guidTypeNode, GUID_Song_SegmentRefFolderNode ) ) 
			{
				CFolder* pFolderEmbed = m_pSong->GetSegmentEmbedFolder();
				pSourceSegment = pFolderEmbed->GetSourceSegmentFromDocRoot( pIDocRootNode );
				if( pSourceSegment )
				{
					pSourceSegment->AddRef();
					m_pSong->m_fChangingFolder = true;
					pFolderEmbed->DeleteChildNode( pSourceSegment, FALSE );
					m_pSong->m_fChangingFolder = false;
				}
			}
			else
			{
				ASSERT( 0 );
			}
			
			// Make sure a SourceSegment exists for the DocRoot
			if( pSourceSegment == NULL )
			{
				pSourceSegment = new CSourceSegment( m_pSong );
				if( pSourceSegment )
				{
					if( FAILED ( pSourceSegment->SetFileReference( pIDocRootNode ) ) )
					{
						RELEASE( pSourceSegment );
					}
				}
			}

			// Add the DocRoot to this folder
			if( pSourceSegment )
			{
				hr = InsertChildNode( pSourceSegment );
				if( FAILED ( hr ) )
				{
					pSourceSegment->AddRef();
					DeleteChildNode( pSourceSegment, FALSE );
				}
			}
			else
			{
				hr = E_FAIL;
			}

			RELEASE( pSourceSegment );
			RELEASE( pIDocRootNode );
		}
	}

	RELEASE( pDataObject );
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CFolder IDMUSProdNode::CanChildPasteFromData

HRESULT CFolder::CanChildPasteFromData( IDataObject* pIDataObject, IDMUSProdNode* pIChildNode,
										BOOL *pfWillSetReference )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(pIChildNode);

	return CanPasteFromData( pIDataObject, pfWillSetReference );
}


/////////////////////////////////////////////////////////////////////////////
// CFolder IDMUSProdNode::ChildPasteFromData

HRESULT CFolder::ChildPasteFromData( IDataObject* pIDataObject, IDMUSProdNode* pIChildNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(pIChildNode);

	return PasteFromData( pIDataObject );
}


/////////////////////////////////////////////////////////////////////////////
// CFolder IDMUSProdNode::GetObject

HRESULT CFolder::GetObject( REFCLSID rclsid, REFIID riid, void** ppvObject )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(rclsid);
	UNREFERENCED_PARAMETER(riid);
	UNREFERENCED_PARAMETER(ppvObject);

	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CFolder SaveSegments
    
HRESULT CFolder::SaveSegments( IDMUSProdRIFFStream* pIRiffStream )
{
	HRESULT hr = S_OK;

	BOOL fReference = TRUE;
	if( ::IsEqualGUID( m_guidTypeNode, GUID_Song_SegmentEmbedFolderNode ) ) 
	{
		fReference = FALSE;
	}

	POSITION pos = m_lstSegments.GetHeadPosition();
	while( pos )
	{
		CSourceSegment* pSourceSegment = m_lstSegments.GetNext( pos );

		hr = pSourceSegment->Save( pIRiffStream, fReference );
		if( FAILED( hr ) )
		{
			goto ON_ERROR;
		}
		hr = S_OK;	// Change possible S_FALSE to S_OK;
	}

ON_ERROR:
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CFolder::InsertSourceSegment

HRESULT CFolder::InsertSourceSegment( CSourceSegment* pSourceSegmentToInsert )
{
	if( pSourceSegmentToInsert == NULL )
	{
		ASSERT( 0 );
		return E_INVALIDARG;
	}

	pSourceSegmentToInsert->AddRef();

	// Add SourceSegment to list
	m_lstSegments.AddTail( pSourceSegmentToInsert );

	// Sync changes
	m_pSong->SetModified( TRUE );
	m_pSong->SyncChanges( SC_EDITOR | SC_DIRECTMUSIC,
						  SSE_SOURCE_SEGMENT_LIST | SSE_TRANSITION_LIST | SSE_TRACK_LIST | SSE_SELECTED_VIRTUAL_SEGMENT,
						  NULL );
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CFolder::RemoveSourceSegment

HRESULT CFolder::RemoveSourceSegment( CSourceSegment* pSourceSegment )
{
	if( pSourceSegment == NULL )
	{
		ASSERT( 0 );
		return E_INVALIDARG;
	}

	// If we are not dropping pSourceSegment in a different Container folder....
	if( m_pSong->m_fChangingFolder == false )
	{
		// Make sure other VirtualSegments do not point to pSourceSegment
		m_pSong->RemoveSourceSegmentReferences( pSourceSegment );
	}

	// Remove from Segment list
	POSITION pos = m_lstSegments.Find( pSourceSegment );
	if( pos )
	{
		m_lstSegments.RemoveAt( pos );

		// Sync changes
		m_pSong->SetModified( TRUE );
		m_pSong->SyncChanges( SC_EDITOR | SC_DIRECTMUSIC,
							  SSE_SOURCE_SEGMENT_LIST | SSE_TRANSITION_LIST | SSE_TRACK_LIST | SSE_SELECTED_VIRTUAL_SEGMENT,
							  NULL );

		RELEASE( pSourceSegment );
		return S_OK;
	}

	return E_FAIL;
}


///////////////////////////////////////////////////////////////////////////
// CFolder::OnUpdate	(handles Song's IDMUSProdNotifSink notifications)

HRESULT CFolder::OnUpdate( IDMUSProdNode* pIDocRootNode, GUID guidUpdateType, VOID* pData )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CSourceSegment* pSourceSegment;

	// FRAMEWORK_FileLoadFinished
	if( ::IsEqualGUID( guidUpdateType, FRAMEWORK_FileLoadFinished ) )
	{
		GUID guidFile = *(GUID *)pData;

		BOOL fChanged = FALSE;
		
		POSITION pos = m_lstSegments.GetHeadPosition();
		while( pos )
		{
			pSourceSegment = m_lstSegments.GetNext( pos );

			if( ::IsEqualGUID( pSourceSegment->m_FileRef.li.guidFile, guidFile ) )
			{ 
				if( SUCCEEDED ( pSourceSegment->SetFileReference( guidFile ) ) )
				{
					if( pSourceSegment->m_pIDocRootNode
					&&  pSourceSegment->m_pIParentNode )
					{
						// Need to refresh node name and node image index
						theApp.m_pSongComponent->m_pIFramework8->RefreshNode( pSourceSegment );
					}
				}

				fChanged = TRUE;
			}
		}

		if( fChanged )
		{
			if( m_pIDocRootNode
			&&  m_pIDocRootNode != this )
			{
				// Notify DocRoot that the Song has changed
				IDMUSProdNotifySink* pINotifySink;
				if( SUCCEEDED ( m_pIDocRootNode->QueryInterface( IID_IDMUSProdNotifySink, (void**)&pINotifySink ) ) )
				{
					pINotifySink->OnUpdate( m_pSong, SONG_FileLoadFinished, NULL );

					RELEASE( pINotifySink );
				}
			}
		}

		if( theApp.m_pSongComponent->m_pEmbeddedFileRootFile )
		{
			if( ::IsEqualGUID(theApp.m_pSongComponent->m_pEmbeddedFileRootFile->guidNotification, guidFile) )
			{ 
				delete theApp.m_pSongComponent->m_pEmbeddedFileRootFile;
				theApp.m_pSongComponent->m_pEmbeddedFileRootFile = NULL;
			}
		}
	}
	else
	{
		POSITION pos = m_lstSegments.GetHeadPosition();
		while( pos )
		{
			pSourceSegment = m_lstSegments.GetNext( pos );

			if( pSourceSegment->m_FileRef.pIDocRootNode == pIDocRootNode )
			{
				// FRAMEWORK_FileDeleted
				// FRAMEWORK_FileClosed
				if( ::IsEqualGUID( guidUpdateType, FRAMEWORK_FileDeleted )
				||  ::IsEqualGUID( guidUpdateType, FRAMEWORK_FileClosed ) )
				{
					DeleteChildNode( pSourceSegment, FALSE );
					return S_OK;
				}

				// FRAMEWORK_FileReplaced
				else if( ::IsEqualGUID( guidUpdateType, FRAMEWORK_FileReplaced ) )
				{
					pSourceSegment->SetFileReference( (IDMUSProdNode *)pData );
					theApp.m_pSongComponent->m_pIFramework8->RefreshNode( pSourceSegment );
					m_pSong->SetModified( TRUE );
					return S_OK;
				}

				// DOCROOT_GuidChange
				else if( ::IsEqualGUID( guidUpdateType, DOCROOT_GuidChange ) )
				{
					m_pSong->SetModified( TRUE );
					return S_OK;
				}
				
				// FRAMEWORK_FileNameChange
				else if( ::IsEqualGUID( guidUpdateType, FRAMEWORK_FileNameChange ) )
				{
					pSourceSegment->SyncListInfo();
					m_pSong->SetModified( TRUE );
					m_pSong->SyncChanges( SC_EDITOR,
										  SSE_REDRAW_TRACK_LIST,
										  NULL );
					return S_OK;
				}

				// GUID_Segment_Name_Change
				else if( ::IsEqualGUID(guidUpdateType, GUID_Segment_Name_Change ) )
				{
					theApp.m_pSongComponent->m_pIFramework8->RefreshNode( pSourceSegment );
					pSourceSegment->SyncListInfo();
					m_pSong->SyncChanges( SC_EDITOR,
										  SSE_SOURCE_SEGMENT_LIST | SSE_REDRAW_TRACK_LIST,
										  NULL );
					return S_OK;
				}

				// GUID_TimeSignature
				else if( ::IsEqualGUID(guidUpdateType, GUID_TimeSignature ) )
				{
					m_pSong->RecomputeVirtualSegmentLengths();
					return S_OK;
				}

				// All other notifications
				else
				{
					theApp.m_pSongComponent->m_pIFramework8->RefreshNode( pSourceSegment );
					pSourceSegment->SyncListInfo();
					return S_OK;
				}
			}
		}
	}

	return E_INVALIDARG;
}


///////////////////////////////////////////////////////////////////////////
// CFolder::IsDocRootInFolder

BOOL CFolder::IsDocRootInFolder( IDMUSProdNode* pIDocRootNode )
{
	CSourceSegment* pSourceSegment;

    POSITION pos = m_lstSegments.GetHeadPosition();
    while( pos )
    {
        pSourceSegment = m_lstSegments.GetNext( pos );

		if( pSourceSegment->m_FileRef.pIDocRootNode == pIDocRootNode )
		{
			return TRUE;
		}
	}

	return FALSE;
}


///////////////////////////////////////////////////////////////////////////
// CFolder::GetSourceSegmentFromDocRoot

CSourceSegment* CFolder::GetSourceSegmentFromDocRoot( IDMUSProdNode* pIDocRootNode )
{
	CSourceSegment* pTheSourceSegment = NULL;
	CSourceSegment* pSourceSegment;

    POSITION pos = m_lstSegments.GetHeadPosition();
    while( pos )
    {
        pSourceSegment = m_lstSegments.GetNext( pos );

		if( pSourceSegment->m_FileRef.pIDocRootNode == pIDocRootNode )
		{
			pTheSourceSegment = pSourceSegment;
			break;
		}
	}

	return pTheSourceSegment;
}


///////////////////////////////////////////////////////////////////////////
// CFolder::EmptySourceSegmentList

void CFolder::EmptySourceSegmentList( void )
{
	CSourceSegment* pSourceSegment;

	while( !m_lstSegments.IsEmpty() )
	{
		pSourceSegment = m_lstSegments.RemoveHead();

		pSourceSegment->SetFileReference( NULL );
		RELEASE( pSourceSegment );
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SongDesigner\FolderToolGraphs.cpp ===
// FolderToolGraphs.cpp : implementation file
//

#include "stdafx.h"

#include "SongDesignerDLL.h"
#include "Song.h"
#include <ToolGraphDesigner.h>
#include <dmusicf.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/////////////////////////////////////////////////////////////////////////////
// CFolderToolGraphs constructor/destructor

CFolderToolGraphs::CFolderToolGraphs()
{
	m_pSong = NULL;
	m_pIDocRootNode = NULL;
	m_pIParentNode = NULL;
	m_fModified = FALSE;
}

CFolderToolGraphs::~CFolderToolGraphs()
{
	EmptyToolGraphList();
}


/////////////////////////////////////////////////////////////////////////////
// CFolderToolGraphs IUnknown implementation

HRESULT CFolderToolGraphs::QueryInterface( REFIID riid, LPVOID FAR* ppvObj )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    if( ::IsEqualIID(riid, IID_IDMUSProdNode)
	||  ::IsEqualIID(riid, IID_IUnknown) )
    {
        AddRef();
        *ppvObj = this;
        return S_OK;
    }

    if( ::IsEqualIID(riid, IID_IDMUSProdPropPageObject) )
    {
		if( m_pSong )
		{
	        return m_pSong->QueryInterface( riid, ppvObj );
		}

		*ppvObj = NULL;
		return E_NOINTERFACE;
    }

    *ppvObj = NULL;
    return E_NOINTERFACE;
}

ULONG CFolderToolGraphs::AddRef()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pSong != NULL );

	AfxOleLockApp(); 

	return m_pSong->AddRef();
}

ULONG CFolderToolGraphs::Release()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pSong != NULL );

	AfxOleUnlockApp(); 

	return m_pSong->Release();
}


/////////////////////////////////////////////////////////////////////////////
// CFolderToolGraphs IDMUSProdNode implementation

/////////////////////////////////////////////////////////////////////////////
// CFolderToolGraphs IDMUSProdNode::GetNodeImageIndex

HRESULT CFolderToolGraphs::GetNodeImageIndex( short* pnFirstImage )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( theApp.m_pSongComponent != NULL );

	return( theApp.m_pSongComponent->GetFolderImageIndex(pnFirstImage) );
}


/////////////////////////////////////////////////////////////////////////////
// CFolderToolGraphs IDMUSProdNode::GetFirstChild

HRESULT CFolderToolGraphs::GetFirstChild( IDMUSProdNode** ppIFirstChildNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( ppIFirstChildNode == NULL )
	{
		return E_POINTER;
	}
	
	*ppIFirstChildNode = NULL;

	if( !m_lstToolGraphs.IsEmpty() )
	{
		IDMUSProdNode* pIToolGraph = m_lstToolGraphs.GetHead();
		
		if( pIToolGraph )
		{
			pIToolGraph->AddRef();
			*ppIFirstChildNode = pIToolGraph;
		}
	}

    return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CFolderToolGraphs IDMUSProdNode::GetNextChild

HRESULT CFolderToolGraphs::GetNextChild( IDMUSProdNode* pIChildNode, IDMUSProdNode** ppINextChildNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( ppINextChildNode == NULL )
	{
		return E_POINTER;
	}
	
	*ppINextChildNode = NULL;

	if( pIChildNode == NULL )
	{
		return E_INVALIDARG;
	}

    POSITION pos = m_lstToolGraphs.GetHeadPosition();
    while( pos )
    {
        IDMUSProdNode* pIToolGraph = m_lstToolGraphs.GetNext( pos );
		if( pIToolGraph == pIChildNode )
		{
			if( pos )
			{
				pIToolGraph = m_lstToolGraphs.GetNext( pos );

				pIToolGraph->AddRef();
				*ppINextChildNode = pIToolGraph;
			}
			break;
		}
    }

    return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CFolderToolGraphs IDMUSProdNode::GetComponent

HRESULT CFolderToolGraphs::GetComponent( IDMUSProdComponent** ppIComponent )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( theApp.m_pSongComponent != NULL );

	return theApp.m_pSongComponent->QueryInterface( IID_IDMUSProdComponent, (void**)ppIComponent );
}


/////////////////////////////////////////////////////////////////////////////
// CFolderToolGraphs IDMUSProdNode::GetDocRootNode

HRESULT CFolderToolGraphs::GetDocRootNode( IDMUSProdNode** ppIDocRootNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pIDocRootNode )
	{
		m_pIDocRootNode->AddRef();
		*ppIDocRootNode = m_pIDocRootNode;
		return S_OK;
	}

	*ppIDocRootNode = NULL;
	return E_FAIL;
}


/////////////////////////////////////////////////////////////////////////////
// CFolderToolGraphs IDMUSProdNode::SetDocRootNode

HRESULT CFolderToolGraphs::SetDocRootNode( IDMUSProdNode* pIDocRootNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( pIDocRootNode != NULL );

	m_pIDocRootNode = pIDocRootNode;
//	m_pIDocRootNode->AddRef();		intentionally missing

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CFolderToolGraphs IDMUSProdNode::GetParentNode

HRESULT CFolderToolGraphs::GetParentNode( IDMUSProdNode** ppIParentNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pIParentNode != NULL );

	m_pIParentNode->AddRef();
	*ppIParentNode = m_pIParentNode;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CFolderToolGraphs IDMUSProdNode::SetParentNode

HRESULT CFolderToolGraphs::SetParentNode( IDMUSProdNode* pIParentNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( pIParentNode != NULL );

	m_pIParentNode = pIParentNode;
//	m_pIParentNode->AddRef();		intentionally missing

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CFolderToolGraphs IDMUSProdNode::GetNodeId

HRESULT CFolderToolGraphs::GetNodeId( GUID* pguid )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( pguid == NULL )
	{
		return E_POINTER;
	}

	*pguid = GUID_Song_ToolGraphsFolderNode;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CFolderToolGraphs IDMUSProdNode::GetNodeName

HRESULT CFolderToolGraphs::GetNodeName( BSTR* pbstrName )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CString strName;
	TCHAR achBuffer[MID_BUFFER];

	if( ::LoadString(theApp.m_hInstance, IDS_TOOLGRAPHS_FOLDER_NAME, achBuffer, MID_BUFFER) )
	{
		strName = achBuffer;
	}

    *pbstrName = strName.AllocSysString();

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CFolderToolGraphs IDMUSProdNode::GetNodeNameMaxLength

HRESULT CFolderToolGraphs::GetNodeNameMaxLength( short* pnMaxLength )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	*pnMaxLength = -1;	// Can't rename a 'Source ToolGraphs' folder

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CFolderToolGraphs IDMUSProdNode::ValidateNodeName

HRESULT CFolderToolGraphs::ValidateNodeName( BSTR bstrName )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);

	return E_NOTIMPL;	// Can't rename a 'Source ToolGraphs' folder
}


/////////////////////////////////////////////////////////////////////////////
// CFolderToolGraphs IDMUSProdNode::SetNodeName

HRESULT CFolderToolGraphs::SetNodeName( BSTR bstrName )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);

	return E_NOTIMPL;	// Can't rename a 'Source ToolGraphs' folder
}


/////////////////////////////////////////////////////////////////////////////
// CFolderToolGraphs IDMUSProdNode::GetNodeListInfo

HRESULT CFolderToolGraphs::GetNodeListInfo( DMUSProdListInfo* pListInfo )
{
//	AFX_MANAGE_STATE( _afxModuleAddrThis );

	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CFolderToolGraphs IDMUSProdNode::GetEditorClsId

HRESULT CFolderToolGraphs::GetEditorClsId( CLSID* pClsId )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);

	return E_NOTIMPL;	// Can't edit a 'Source ToolGraphs' folder
}


/////////////////////////////////////////////////////////////////////////////
// CFolderToolGraphs IDMUSProdNode::GetEditorTitle

HRESULT CFolderToolGraphs::GetEditorTitle( BSTR* pbstrTitle )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);

	return E_NOTIMPL;	// Can't edit a 'Source ToolGraphs' folder
}


/////////////////////////////////////////////////////////////////////////////
// CFolderToolGraphs IDMUSProdNode::GetEditorWindow

HRESULT CFolderToolGraphs::GetEditorWindow( HWND* hWndEditor )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);

	return E_NOTIMPL;	// Can't edit a 'Source ToolGraphs' folder
}


/////////////////////////////////////////////////////////////////////////////
// CFolderToolGraphs IDMUSProdNode::SetEditorWindow

HRESULT CFolderToolGraphs::SetEditorWindow( HWND hWndEditor )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);

	return E_NOTIMPL;	// Can't edit a 'Source ToolGraphs' folder
}


/////////////////////////////////////////////////////////////////////////////
// CFolderToolGraphs IDMUSProdNode::UseOpenCloseImages

HRESULT CFolderToolGraphs::UseOpenCloseImages( BOOL* pfUseOpenCloseImages )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	*pfUseOpenCloseImages = TRUE;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CFolderToolGraphs IDMUSProdNode::GetRightClickMenuId

HRESULT CFolderToolGraphs::GetRightClickMenuId( HINSTANCE* phInstance, UINT* pnMenuId )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	*phInstance = theApp.m_hInstance;
	*pnMenuId   = IDM_FOLDER_TOOLGRAPHS_NODE_RMENU;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CFolderToolGraphs IDMUSProdNode::OnRightClickMenuInit

HRESULT CFolderToolGraphs::OnRightClickMenuInit( HMENU hMenu )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CMenu menu;

	if( menu.Attach(hMenu) )
	{
		// IDM_PASTE
		{
			IDataObject* pIDataObject;
			BOOL fWillSetReference;

			menu.EnableMenuItem( ID_EDIT_PASTE, (MF_GRAYED | MF_BYCOMMAND) );

			if( SUCCEEDED ( ::OleGetClipboard( &pIDataObject ) ) )
			{
				if( CanPasteFromData( pIDataObject, &fWillSetReference ) == S_OK )
				{
					menu.EnableMenuItem( ID_EDIT_PASTE, (MF_ENABLED | MF_BYCOMMAND) );
				}
				
				pIDataObject->Release();
			}
		}

		// IDM_PROPERTIES
		IDMUSProdPropPageObject* pIPageObject;
		if( SUCCEEDED ( QueryInterface( IID_IDMUSProdPropPageObject, (void **)&pIPageObject ) ) )
		{
			menu.EnableMenuItem( IDM_PROPERTIES, (MF_ENABLED | MF_BYCOMMAND) );
			RELEASE( pIPageObject );
		}
		else
		{
			menu.EnableMenuItem( IDM_PROPERTIES, (MF_GRAYED | MF_BYCOMMAND) );
		}

		menu.Detach();
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CFolderToolGraphs IDMUSProdNode::OnRightClickMenuSelect

HRESULT CFolderToolGraphs::OnRightClickMenuSelect( long lCommandId )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pSong != NULL );

	HRESULT hr = E_FAIL;

	switch( lCommandId )
	{
		case IDM_NEW_SOURCE_TOOLGRAPH:
			hr = InsertChildNode( NULL );
			break;

		case ID_EDIT_PASTE:
		{
			IDataObject* pIDataObject;
			BOOL fWillSetReference;

			if( SUCCEEDED ( ::OleGetClipboard( &pIDataObject ) ) )
			{
				if( CanPasteFromData( pIDataObject, &fWillSetReference ) == S_OK )
				{
					PasteFromData( pIDataObject );
				}
				
				RELEASE( pIDataObject );
			}
			break;
		}

		case IDM_PROPERTIES:
		{
			IDMUSProdPropPageObject* pIPageObject;

			if( SUCCEEDED ( QueryInterface( IID_IDMUSProdPropPageObject, (void **)&pIPageObject ) ) )
			{
				pIPageObject->OnShowProperties();
				RELEASE( pIPageObject );
			}
			hr = S_OK;
			break;
		}
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CFolderToolGraphs IDMUSProdNode::DeleteChildNode

HRESULT CFolderToolGraphs::DeleteChildNode( IDMUSProdNode* pIChildNode, BOOL fPromptUser )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( pIChildNode != NULL );
	ASSERT( m_pSong != NULL );
	ASSERT( theApp.m_pSongComponent != NULL );
	ASSERT( theApp.m_pSongComponent->m_pIFramework8 != NULL );

	CWaitCursor wait;

	if( pIChildNode == NULL )
	{
		return E_INVALIDARG;
	}

	// Remove node from Project Tree
	if( theApp.m_pSongComponent->m_pIFramework8->RemoveNode( pIChildNode, fPromptUser ) == S_FALSE )
	{
		return E_FAIL;
	}

	// Save undo state
//	m_pSong->m_pINodeBeingDeleted = pIChildNode;
//	m_pSong->m_pUndoMgr->SaveState( m_pSong, theApp.m_hInstance, IDS_UNDO_DELETE_PATTERN );
//	m_pSong->m_pINodeBeingDeleted = NULL;

	// Remove from ToolGraph list
	RemoveToolGraph( (IDMUSProdNode *)pIChildNode );

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CFolderToolGraphs IDMUSProdNode::InsertChildNode

HRESULT CFolderToolGraphs::InsertChildNode( IDMUSProdNode* pIChildNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pSong != NULL );
	ASSERT( theApp.m_pSongComponent != NULL );
	ASSERT( theApp.m_pSongComponent->m_pIFramework8 != NULL );

	IDMUSProdNode* pIToolGraph = (IDMUSProdNode *)pIChildNode;

	bool fOpenEditor = false;

	if( pIToolGraph )
	{
		// Make sure we received a ToolGraph node
		GUID guidNodeId;
		HRESULT hr = pIChildNode->GetNodeId( &guidNodeId );
		if( SUCCEEDED ( hr ) )
		{
			if( ::IsEqualGUID( guidNodeId, GUID_ToolGraphNode ) == FALSE )
			{
				hr = E_FAIL;
			}
		}
		if( FAILED( hr ) )
		{
			return hr;
		}

		// Add to ToolGraph list
		InsertToolGraph( pIToolGraph );
	}
	else
	{
		// Create the ToolGraph
		IDMUSProdDocType* pIDocType;
		HRESULT hr = theApp.m_pSongComponent->m_pIFramework8->FindDocTypeByNodeId( GUID_ToolGraphNode, &pIDocType );
		if( SUCCEEDED ( hr ) ) 
		{
			hr = pIDocType->AllocNode( GUID_ToolGraphNode, &pIToolGraph );
			if( SUCCEEDED ( hr ) )
			{
				// Add to ToolGraph list
				fOpenEditor = true;
				InsertToolGraph( pIToolGraph );
				pIToolGraph->Release();
			}

			RELEASE( pIDocType );
		}
	}

	// Set root and parent node of ALL children
	ASSERT( m_pIDocRootNode != NULL );
	theApp.SetNodePointers( pIToolGraph, m_pIDocRootNode, (IDMUSProdNode *)this );

	// Add node to Project Tree
	HRESULT hr = theApp.m_pSongComponent->m_pIFramework8->AddNode( pIToolGraph, (IDMUSProdNode *)this );
	if( SUCCEEDED ( hr ) )
	{
		if( fOpenEditor )
		{
			theApp.m_pSongComponent->m_pIFramework8->OpenEditor( pIToolGraph );
		}
	}
	else
	{
		DeleteChildNode( pIToolGraph, FALSE );
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CFolderToolGraphs IDMUSProdNode::DeleteNode

HRESULT CFolderToolGraphs::DeleteNode( BOOL fPromptUser )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);

	return E_NOTIMPL;	// Can't delete a 'Source ToolGraphs' folder
}


/////////////////////////////////////////////////////////////////////////////
// CFolderToolGraphs IDMUSProdNode::OnNodeSelChanged

HRESULT CFolderToolGraphs::OnNodeSelChanged( BOOL fSelected )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CFolderToolGraphs IDMUSProdNode::CreateDataObject

HRESULT CFolderToolGraphs::CreateDataObject( IDataObject** ppIDataObject )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( ppIDataObject == NULL )
	{
		return E_POINTER;
	}

	*ppIDataObject = NULL;

	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CFolderToolGraphs IDMUSProdNode::CanCut

HRESULT CFolderToolGraphs::CanCut( void )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
 
	return S_FALSE;		// Can't remove 'Source ToolGraphs' folder from Song
}


/////////////////////////////////////////////////////////////////////////////
// CFolderToolGraphs IDMUSProdNode::CanCopy

HRESULT CFolderToolGraphs::CanCopy( void )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
 
	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CFolderToolGraphs IDMUSProdNode::CanDelete

HRESULT CFolderToolGraphs::CanDelete( void )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);

	return S_FALSE;		// Can't delete 'Source ToolGraphs' folder from Song
}


/////////////////////////////////////////////////////////////////////////////
// CFolderToolGraphs IDMUSProdNode::CanDeleteChildNode

HRESULT CFolderToolGraphs::CanDeleteChildNode( IDMUSProdNode* pIChildNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Make sure node is in ToolGraph list
	POSITION pos = m_lstToolGraphs.Find( pIChildNode );
	if( pos == NULL )
	{
		return E_FAIL;
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CFolderToolGraphs IDMUSProdNode::CanPasteFromData

HRESULT CFolderToolGraphs::CanPasteFromData( IDataObject* pIDataObject, BOOL* pfWillSetReference )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( pfWillSetReference == NULL )
	{
		return E_POINTER;
	}

	*pfWillSetReference = FALSE;

	if( pIDataObject == NULL )
	{
		return E_INVALIDARG;
	}

	// Create a new CDllJazzDataObject and see if it can read the data object's format.
	CDllJazzDataObject* pDataObject = new CDllJazzDataObject();
	if( pDataObject == NULL )
	{
		return E_OUTOFMEMORY;
	}

	HRESULT hr = S_FALSE;
	
	if( SUCCEEDED (	pDataObject->IsClipFormatAvailable( pIDataObject, theApp.m_pSongComponent->m_cfGraph ) ) )
	{
		hr = S_OK;
	}

	RELEASE( pDataObject );
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CFolderToolGraphs IDMUSProdNode::PasteFromData

HRESULT CFolderToolGraphs::PasteFromData( IDataObject* pIDataObject )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pSong != NULL );

	if( pIDataObject == NULL )
	{
		return E_INVALIDARG;
	}

	// Create a new CDllJazzDataObject and see if it can read the data object's format.
	CDllJazzDataObject* pDataObject = new CDllJazzDataObject();
	if( pDataObject == NULL )
	{
		return E_OUTOFMEMORY;
	}

	HRESULT hr = E_FAIL;
	
	if( SUCCEEDED ( pDataObject->IsClipFormatAvailable( pIDataObject, theApp.m_pSongComponent->m_cfGraph ) ) )
	{
		hr = PasteCF_GRAPH( pDataObject, pIDataObject );
	}

	RELEASE( pDataObject );
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CFolderToolGraphs IDMUSProdNode::CanChildPasteFromData

HRESULT CFolderToolGraphs::CanChildPasteFromData( IDataObject* pIDataObject, IDMUSProdNode* pIChildNode,
											   BOOL* pfWillSetReference )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( pfWillSetReference == NULL )
	{
		return E_POINTER;
	}

	*pfWillSetReference = FALSE;

	if( pIDataObject == NULL )
	{
		return E_INVALIDARG;
	}

	// Create a new CDllJazzDataObject and see if it can read the data object's format.
	CDllJazzDataObject* pDataObject = new CDllJazzDataObject();
	if( pDataObject == NULL )
	{
		return E_OUTOFMEMORY;
	}

	HRESULT hr = S_FALSE;
	
	if( SUCCEEDED (	pDataObject->IsClipFormatAvailable( pIDataObject, theApp.m_pSongComponent->m_cfGraph ) ) )
	{
		hr = S_OK;
	}

	RELEASE( pDataObject );
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CFolderToolGraphs IDMUSProdNode::ChildPasteFromData

HRESULT CFolderToolGraphs::ChildPasteFromData( IDataObject* pIDataObject, IDMUSProdNode* pIChildNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pSong != NULL );

	if( pIDataObject == NULL 
	||  pIChildNode == NULL )
	{
		return E_INVALIDARG;
	}

	// Create a new CDllJazzDataObject and see if it can read the data object's format.
	CDllJazzDataObject* pDataObject = new CDllJazzDataObject();
	if( pDataObject == NULL )
	{
		return E_OUTOFMEMORY;
	}

	HRESULT hr = E_FAIL;
	
	if( SUCCEEDED ( pDataObject->IsClipFormatAvailable( pIDataObject, theApp.m_pSongComponent->m_cfGraph ) ) )
	{
		hr = PasteCF_GRAPH( pDataObject, pIDataObject );
	}

	RELEASE( pDataObject );
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CFolderToolGraphs IDMUSProdNode::GetObject

HRESULT CFolderToolGraphs::GetObject( REFCLSID rclsid, REFIID riid, void** ppvObject )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);

	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CFolderToolGraphs::PasteCF_GRAPH

HRESULT CFolderToolGraphs::PasteCF_GRAPH( CDllJazzDataObject* pDataObject, IDataObject* pIDataObject )
{
	IStream* pIStream;
	HRESULT hr = E_FAIL;

	if( SUCCEEDED (	pDataObject->AttemptRead( pIDataObject, theApp.m_pSongComponent->m_cfGraph, &pIStream ) ) )
	{
		LARGE_INTEGER liTemp;

		// Seek to beginning of stream
		liTemp.QuadPart = 0;
		pIStream->Seek( liTemp, STREAM_SEEK_SET, NULL );

		// Create and load a new ToolGraph
		IDMUSProdRIFFExt* pIRIFFExt;
		IDMUSProdNode* pINode;

		if( SUCCEEDED ( theApp.m_pSongComponent->m_pIToolGraphComponent->QueryInterface( IID_IDMUSProdRIFFExt, (void**)&pIRIFFExt ) ) )
		{
			hr = pIRIFFExt->LoadRIFFChunk( pIStream, &pINode );
			if( SUCCEEDED ( hr ) )
			{
				InsertChildNode( pINode );
				RELEASE( pINode );
			}

			RELEASE( pIRIFFExt );
		}

		RELEASE( pIStream );
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CFolderToolGraphs::InsertToolGraph

HRESULT CFolderToolGraphs::InsertToolGraph( IDMUSProdNode* pIToolGraphNodeToInsert )
{
	if( pIToolGraphNodeToInsert == NULL )
	{
		ASSERT( 0 );
		return E_INVALIDARG;
	}

	pIToolGraphNodeToInsert->AddRef();

	// Add to ToolGraph list
	m_lstToolGraphs.AddTail( pIToolGraphNodeToInsert );

	// Sync changes
	m_pSong->SetModified( TRUE );
	m_pSong->SyncChanges( SC_EDITOR | SC_DIRECTMUSIC,
						  SSE_TOOLGRAPH_LIST,
						  NULL );
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CFolderToolGraphs::RemoveToolGraph

HRESULT CFolderToolGraphs::RemoveToolGraph( IDMUSProdNode* pIToolGraphNode )
{
	if( pIToolGraphNode == NULL )
	{
		ASSERT( 0 );
		return E_INVALIDARG;
	}

	// Make sure other VirtualSegments do not point to pIToolGraphNode
	m_pSong->RemoveToolGraphReferences( pIToolGraphNode );

	// Remove from ToolGraph list
	POSITION pos = m_lstToolGraphs.Find( pIToolGraphNode );
	if( pos )
	{
		m_lstToolGraphs.RemoveAt( pos );

		// Sync changes
		m_pSong->SetModified( TRUE );
		m_pSong->SyncChanges( SC_EDITOR | SC_DIRECTMUSIC,
							  SSE_TOOLGRAPH_LIST,
							  NULL );
		
		RELEASE( pIToolGraphNode );
		return S_OK;
	}

	return E_FAIL;
}


/////////////////////////////////////////////////////////////////////////////
// CFolderToolGraphs SaveToolGraphs
    
HRESULT CFolderToolGraphs::SaveToolGraphs( IDMUSProdRIFFStream* pIRiffStream, BOOL fClearDirty )
{
	IStream* pIStream;
	HRESULT hr = S_OK;
    MMCKINFO ckMain;
	POSITION pos;

	if( m_lstToolGraphs.IsEmpty() )
	{
		return S_OK;
	}

    pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

	// Write DMUS_FOURCC_TOOLGRAPHS_LIST header
	ckMain.fccType = DMUS_FOURCC_TOOLGRAPHS_LIST;
	if( pIRiffStream->CreateChunk(&ckMain, MMIO_CREATELIST) != 0 )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

	// Save each ToolGraph
	pos = m_lstToolGraphs.GetHeadPosition();
	while( pos )
	{
		IDMUSProdNode* pIToolGraphNode = m_lstToolGraphs.GetNext( pos );

		IPersistStream* pIPersistStream;
		hr = pIToolGraphNode->QueryInterface( IID_IPersistStream, (void**)&pIPersistStream );
		if( FAILED( hr ) )
		{
			goto ON_ERROR;
		}
		hr = pIPersistStream->Save( pIStream, fClearDirty );
		RELEASE( pIPersistStream );
		if( FAILED( hr ) )
		{
			goto ON_ERROR;
		}
	}

	if( pIRiffStream->Ascend(&ckMain, 0) != 0 )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

ON_ERROR:
    RELEASE( pIStream );
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CFolderToolGraphs LoadToolGraphs
    
HRESULT CFolderToolGraphs::LoadToolGraphs( IDMUSProdRIFFStream* pIRiffStream, MMCKINFO* pckMain )
{
	IStream* pIStream;
	HRESULT hr = S_OK;
    MMCKINFO ck;
	DWORD dwPos;

    pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

    dwPos = StreamTell( pIStream );

	while( pIRiffStream->Descend( &ck, pckMain, 0 ) == 0 )
	{
		switch( ck.ckid )
		{
			case FOURCC_RIFF:
				switch( ck.fccType )
				{
					case DMUS_FOURCC_TOOLGRAPH_FORM: 
					{
						IDMUSProdRIFFExt* pIRIFFExt;
						IDMUSProdNode* pIToolGraphNode;

						hr = theApp.m_pSongComponent->m_pIToolGraphComponent->QueryInterface( IID_IDMUSProdRIFFExt, (void**)&pIRIFFExt );
						if( FAILED( hr ) )
						{
			                goto ON_ERROR;
						}
					    StreamSeek( pIStream, dwPos, STREAM_SEEK_SET );
						hr = pIRIFFExt->LoadRIFFChunk( pIStream, &pIToolGraphNode );
						RELEASE( pIRIFFExt );
						if( FAILED( hr ) )
						{
			                goto ON_ERROR;
						}
						m_lstToolGraphs.AddTail( pIToolGraphNode );
						break;
					}
				}
		}

		pIRiffStream->Ascend( &ck, 0 );
	    dwPos = StreamTell( pIStream );
	}

ON_ERROR:
	RELEASE( pIStream );
	return hr;
}


///////////////////////////////////////////////////////////////////////////
// CFolderToolGraphs::EmptyToolGraphList

void CFolderToolGraphs::EmptyToolGraphList( void )
{
	IDMUSProdNode* pIToolGraphNode;

	while( !m_lstToolGraphs.IsEmpty() )
	{
		pIToolGraphNode = m_lstToolGraphs.RemoveHead();
		RELEASE( pIToolGraphNode );
	}
}


///////////////////////////////////////////////////////////////////////////
// CFolderToolGraphs::OnUpdate	(handles Song's IDMUSProdNotifSink notifications)

HRESULT CFolderToolGraphs::OnUpdate( IDMUSProdNode* pIDocRootNode, GUID guidUpdateType, VOID* pData )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	IDMUSProdNode* pIToolGraphNode;

	POSITION pos = m_lstToolGraphs.GetHeadPosition();
	while( pos )
	{
		pIToolGraphNode = m_lstToolGraphs.GetNext( pos );

		if( pIToolGraphNode == pIDocRootNode )
		{
			// TOOLGRAPH_NameChange
			if( ::IsEqualGUID(guidUpdateType, TOOLGRAPH_NameChange ) )
			{
				m_pSong->SetModified( TRUE );
				m_pSong->SyncChanges( SC_EDITOR,
									  SSE_TOOLGRAPH_LIST,
									  NULL );
				return S_OK;
			}

			// All other notifications
			else
			{
				m_pSong->SetModified( TRUE );
				return S_OK;
			}
		}
	}

	return E_INVALIDARG;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SongDesigner\FolderToolGraphs.h ===
#ifndef __FOLDERTOOLGRAPHS_H__
#define __FOLDERTOOLGRAPHS_H__

// FolderToolGraphs.h : header file
//

#include <afxtempl.h>

class CDirectMusicSong;

class CFolderToolGraphs : public IDMUSProdNode
{
friend class CDirectMusicSong;
friend class CSongDlg;

public:
    CFolderToolGraphs();
	~CFolderToolGraphs();

    // IUnknown functions
    HRESULT STDMETHODCALLTYPE QueryInterface( REFIID riid, LPVOID *ppv );
    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();

    // IDMUSProdNode functions
	HRESULT STDMETHODCALLTYPE GetNodeImageIndex( short* pnNbrFirstImage );
    HRESULT STDMETHODCALLTYPE GetFirstChild( IDMUSProdNode** ppIFirstChildNode );
    HRESULT STDMETHODCALLTYPE GetNextChild( IDMUSProdNode* pIChildNode, IDMUSProdNode** ppINextChildNode );

    HRESULT STDMETHODCALLTYPE GetComponent( IDMUSProdComponent** ppIComponent );
    HRESULT STDMETHODCALLTYPE GetDocRootNode( IDMUSProdNode** ppIDocRootNode );
    HRESULT STDMETHODCALLTYPE SetDocRootNode( IDMUSProdNode* pIDocRootNode );
    HRESULT STDMETHODCALLTYPE GetParentNode( IDMUSProdNode** ppIParentNode );
    HRESULT STDMETHODCALLTYPE SetParentNode( IDMUSProdNode* pIParentNode );
    HRESULT STDMETHODCALLTYPE GetNodeId( GUID* pguid );
    HRESULT STDMETHODCALLTYPE GetNodeName( BSTR* pbstrName );
    HRESULT STDMETHODCALLTYPE GetNodeNameMaxLength( short* pnMaxLength );
    HRESULT STDMETHODCALLTYPE ValidateNodeName( BSTR bstrName );
    HRESULT STDMETHODCALLTYPE SetNodeName( BSTR bstrName );
	HRESULT STDMETHODCALLTYPE GetNodeListInfo( DMUSProdListInfo* pListInfo );

    HRESULT STDMETHODCALLTYPE GetEditorClsId( CLSID* pclsid );
    HRESULT STDMETHODCALLTYPE GetEditorTitle( BSTR* pbstrTitle );
    HRESULT STDMETHODCALLTYPE GetEditorWindow( HWND* hWndEditor );
    HRESULT STDMETHODCALLTYPE SetEditorWindow( HWND hWndEditor );

	HRESULT STDMETHODCALLTYPE UseOpenCloseImages( BOOL* pfUseOpenCloseImages );

    HRESULT STDMETHODCALLTYPE GetRightClickMenuId( HINSTANCE* phInstance, UINT* pnResourceId );
    HRESULT STDMETHODCALLTYPE OnRightClickMenuInit( HMENU hMenu );
    HRESULT STDMETHODCALLTYPE OnRightClickMenuSelect( long lCommandId );

    HRESULT STDMETHODCALLTYPE DeleteChildNode( IDMUSProdNode* pIChildNode, BOOL fPromptUser );
    HRESULT STDMETHODCALLTYPE InsertChildNode( IDMUSProdNode* pIChildNode );
    HRESULT STDMETHODCALLTYPE DeleteNode( BOOL fPromptUser );

	HRESULT STDMETHODCALLTYPE OnNodeSelChanged( BOOL fSelected );

	HRESULT STDMETHODCALLTYPE CreateDataObject( IDataObject** ppIDataObject );
	HRESULT STDMETHODCALLTYPE CanCut();
	HRESULT STDMETHODCALLTYPE CanCopy();
	HRESULT STDMETHODCALLTYPE CanDelete();
	HRESULT STDMETHODCALLTYPE CanDeleteChildNode( IDMUSProdNode* pIChildNode );
	HRESULT STDMETHODCALLTYPE CanPasteFromData( IDataObject* pIDataObject, BOOL* pfWillSetReference );
	HRESULT STDMETHODCALLTYPE PasteFromData( IDataObject* pIDataObject );
	HRESULT STDMETHODCALLTYPE CanChildPasteFromData( IDataObject* pIDataObject, IDMUSProdNode* pIChildNode, BOOL* pfWillSetReference );
	HRESULT STDMETHODCALLTYPE ChildPasteFromData( IDataObject* pIDataObject, IDMUSProdNode* pIChildNode );

	HRESULT STDMETHODCALLTYPE GetObject( REFCLSID rclsid, REFIID riid, void** ppvObject ); 

	// Additional methods
private:
	HRESULT OnUpdate( IDMUSProdNode* pIDocRootNode, GUID guidUpdateType, VOID* pData );
	HRESULT PasteCF_GRAPH( CDllJazzDataObject* pDataObject, IDataObject* pIDataObject );
	HRESULT InsertToolGraph( IDMUSProdNode* pIToolGraphNode );
	HRESULT RemoveToolGraph( IDMUSProdNode* pIToolGraphNode );
	void EmptyToolGraphList();

public:
    HRESULT SaveToolGraphs( IDMUSProdRIFFStream* pIRiffStream, BOOL fClearDirty );
    HRESULT LoadToolGraphs( IDMUSProdRIFFStream* pIRiffStream, MMCKINFO* pckMain );

private:
	IDMUSProdNode*			m_pIDocRootNode;
	IDMUSProdNode*		    m_pIParentNode;

	CTypedPtrList<CPtrList, IDMUSProdNode*> m_lstToolGraphs;
	CDirectMusicSong*		m_pSong;
	BOOL					m_fModified;
};

#endif // __FOLDERTOOLGRAPHS_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SongDesigner\Song.cpp ===
// Song.cpp : implementation file
//

#include "stdafx.h"
#include "SongDesignerDLL.h"

#include "RiffStrm.h"
#include "Song.h"
#include <mmreg.h>
#include <math.h>
#include "TabSong.h"
#include "TabInfo.h"
#include "SongCtl.h"
#include <SegmentDesigner.h>
#include <ContainerDesigner.h>
#include <AudioPathDesigner.h>
#include <ToolGraphDesigner.h>
#include <dmusicf.h>


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

// {77ABC763-8BD4-4967-A4BD-683C1667F9D2}
static const GUID GUID_SongPropPageManager = 
{ 0x77abc763, 0x8bd4, 0x4967, { 0xa4, 0xbd, 0x68, 0x3c, 0x16, 0x67, 0xf9, 0xd2 } };

short CSongPropPageManager::sm_nActiveTab = 0;


//////////////////////////////////////////////////////////////////////
// CSongPropPageManager Construction/Destruction
//////////////////////////////////////////////////////////////////////

CSongPropPageManager::CSongPropPageManager()
{
    m_dwRef = 0;
	AddRef();

	m_pIPropPageObject = NULL;
	m_pIPropSheet = NULL;

	m_pTabSong = NULL;
	m_pTabInfo = NULL;
}

CSongPropPageManager::~CSongPropPageManager()
{
	RELEASE( m_pIPropSheet );

	if( m_pTabSong )
	{
		delete m_pTabSong;
	}

	if( m_pTabInfo )
	{
		delete m_pTabInfo;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CSongPropPageManager::RemoveCurrentObject

void CSongPropPageManager::RemoveCurrentObject( void )
{
	if( m_pIPropPageObject == NULL )
	{
		return;
	}

	m_pIPropPageObject->OnRemoveFromPageManager();
	m_pIPropPageObject = NULL;
}


/////////////////////////////////////////////////////////////////////////////
// CSongPropPageManager IUnknown implementation

HRESULT CSongPropPageManager::QueryInterface( REFIID riid, LPVOID FAR* ppvObj )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    if( ::IsEqualIID(riid, IID_IDMUSProdPropPageManager)
	||  ::IsEqualIID(riid, IID_IUnknown) )
    {
        AddRef();
        *ppvObj = (IDMUSProdPropPageManager *)this;
        return S_OK;
    }

    *ppvObj = NULL;
    return E_NOINTERFACE;
}

ULONG CSongPropPageManager::AddRef()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    return ++m_dwRef;
}

ULONG CSongPropPageManager::Release()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    ASSERT( m_dwRef != 0 );

    --m_dwRef;

    if( m_dwRef == 0 )
    {
        delete this;
        return 0;
    }

    return m_dwRef;
}


/////////////////////////////////////////////////////////////////////////////
// CSongPropPageManager IDMUSProdPropPageManager implementation

/////////////////////////////////////////////////////////////////////////////
// CSongPropPageManager IDMUSProdPropPageManager::GetPropertySheetTitle

HRESULT CSongPropPageManager::GetPropertySheetTitle( BSTR* pbstrTitle, BOOL* pfAddPropertiesText )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( (pbstrTitle == NULL)
	||  (pfAddPropertiesText == NULL) )
	{
		return E_POINTER;
	}

	*pfAddPropertiesText = TRUE;

	CString strTitle;
	strTitle.LoadString( IDS_SONG_TEXT );

	CDirectMusicSong *pSong;

	if( m_pIPropPageObject
	&& (SUCCEEDED (m_pIPropPageObject->GetData((void **)&pSong))) )
	{
		CString strNodeName;
		BSTR bstrNodeName;

		if( SUCCEEDED ( pSong->GetNodeName( &bstrNodeName ) ) )
		{
			strNodeName = bstrNodeName;
			::SysFreeString( bstrNodeName );
		}
		strTitle = strNodeName + _T(" ") + strTitle;
	}

	*pbstrTitle = strTitle.AllocSysString();

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CSongPropPageManager IDMUSProdPropPageManager::GetPropertySheetPages

HRESULT CSongPropPageManager::GetPropertySheetPages( IDMUSProdPropSheet* pIPropSheet, LONG* hPropSheetPage[], short* pnNbrPages )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( (hPropSheetPage == NULL)
	||  (pnNbrPages == NULL) )
	{
		return E_POINTER;
	}

	if( pIPropSheet == NULL )
	{
		return E_INVALIDARG;
	}

	m_pIPropSheet = pIPropSheet;
	m_pIPropSheet->AddRef();

	hPropSheetPage[0] = NULL;
	*pnNbrPages = 0;

	HPROPSHEETPAGE hPage;
	short nNbrPages = 0;

	// Add Song tab
	m_pTabSong = new CTabSong( this );
	if( m_pTabSong )
	{
		hPage = ::CreatePropertySheetPage( (LPPROPSHEETPAGE)&m_pTabSong->m_psp );
		if( hPage )
		{
			hPropSheetPage[nNbrPages] = (LONG *)hPage;
			nNbrPages++;
		}			
	}

	// Add Info tab
	m_pTabInfo = new CTabInfo( this );
	if( m_pTabInfo )
	{
		hPage = ::CreatePropertySheetPage( (LPPROPSHEETPAGE)&m_pTabInfo->m_psp );
		if( hPage )
		{
			hPropSheetPage[nNbrPages] = (LONG *)hPage;
			nNbrPages++;
		}			
	}

	// Set number of pages
	*pnNbrPages = nNbrPages;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CSongPropPageManager IDMUSProdPropPageManager::OnRemoveFromPropertySheet

HRESULT CSongPropPageManager::OnRemoveFromPropertySheet()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pIPropSheet != NULL );
	m_pIPropSheet->GetActivePage( &CSongPropPageManager::sm_nActiveTab );

	RemoveCurrentObject();
	theApp.m_pIPageManager = NULL;

	Release();	// delete myself

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CSongPropPageManager IDMUSProdPropPageManager::SetObject

HRESULT CSongPropPageManager::SetObject( IDMUSProdPropPageObject* pINewPropPageObject )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( pINewPropPageObject == NULL )
	{
		return E_INVALIDARG;
	}
	if( m_pIPropPageObject == pINewPropPageObject )
	{
		return S_OK;
	}

	RemoveCurrentObject();

	m_pIPropPageObject = pINewPropPageObject;
//	m_pIPropPageObject->AddRef();		intentionally missing

	RefreshData();

	if( m_pIPropSheet )
	{
		m_pIPropSheet->RefreshTitle();
		m_pIPropSheet->RefreshActivePage();
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CSongPropPageManager IDMUSProdPropPageManager::RemoveObject

HRESULT CSongPropPageManager::RemoveObject( IDMUSProdPropPageObject* pIPropPageObject )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( (pIPropPageObject == NULL)
	||  (pIPropPageObject != m_pIPropPageObject) )
	{
		return E_INVALIDARG;
	}

	RemoveCurrentObject();
	RefreshData();

	if( m_pIPropSheet )
	{
		m_pIPropSheet->RefreshTitle();
		m_pIPropSheet->RefreshActivePage();
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CSongPropPageManager  IDMUSProdPropPageManager::IsEqualObject

HRESULT FAR EXPORT CSongPropPageManager::IsEqualObject( IDMUSProdPropPageObject* pIPropPageObject )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( pIPropPageObject == NULL )
	{
		return E_INVALIDARG;
	}

	if( pIPropPageObject == m_pIPropPageObject )
	{
		return S_OK;
	}

	return S_FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CSongPropPageManager IDMUSProdPropPageManager::RefreshData

HRESULT CSongPropPageManager::RefreshData( void )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CDirectMusicSong* pSong;
	
	if( m_pIPropPageObject == NULL )
	{
		pSong = NULL;
	}
	else if( FAILED ( m_pIPropPageObject->GetData( (void **)&pSong ) ) )
	{
		return E_FAIL;
	}

	// Make sure changes to current Song are processed in OnKillFocus
	// messages before setting the new Song
	CWnd* pWndHadFocus = CWnd::GetFocus();
	CWnd* pWnd = pWndHadFocus;
	CWnd* pWndParent = m_pTabSong->GetParent();

	while( pWnd )
	{
		if( pWnd == pWndParent )
		{
			::SetFocus( NULL );
			break;
		}
		pWnd = pWnd->GetParent();
	}

	// Set Property tabs to display the new Song
	m_pTabSong->SetSong( pSong);
	m_pTabInfo->SetSong( pSong);

	// Restore focus
	if( pWndHadFocus
	&&  pWndHadFocus != CWnd::GetFocus() )
	{
		pWndHadFocus->SetFocus();
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CSongPropPageManager  IDMUSProdPropPageManager::IsEqualPageManagerGUID

HRESULT CSongPropPageManager::IsEqualPageManagerGUID( REFGUID rguidPageManager )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( ::IsEqualGUID(rguidPageManager, GUID_SongPropPageManager) )
	{
		return S_OK;
	}

	return S_FALSE;
}


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// CNotificationHandler constructor/destructor

CNotificationHandler::CNotificationHandler()
{
	m_pSong = NULL;
}

CNotificationHandler::~CNotificationHandler()
{
	m_pSong = NULL;
}


/////////////////////////////////////////////////////////////////////////////
// CNotificationHandler

BEGIN_MESSAGE_MAP(CNotificationHandler, CWnd)
	//{{AFX_MSG_MAP(CNotificationHandler)
	//}}AFX_MSG_MAP
	ON_MESSAGE(WM_NEXT_VIRTUAL_SEGMENT, OnNextVirtualSegment)
	ON_MESSAGE(WM_STOP_VIRTUAL_SEGMENT, OnStopVirtualSegment)
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CNotificationHandler::OnNextVirtualSegment

LRESULT CNotificationHandler::OnNextVirtualSegment( WPARAM wParam, LPARAM lParam )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(wParam);

	BSTR bstrName = (BSTR)lParam;
	CString strName = bstrName;
	::SysFreeString( bstrName );

	if( m_pSong )
	{
//		TRACE( "\nNEXT = %s ", strName );

		CVirtualSegment* pVirtualSegment = m_pSong->FindVirtualSegmentByName( strName );
		if( pVirtualSegment )
		{
			CVirtualSegment* pVirtualSegmentList;
			for( int i = 0 ;  pVirtualSegmentList = m_pSong->IndexToVirtualSegment(i) ;  i++ )
			{
				if( pVirtualSegmentList == NULL )
				{
					break;
				}

				if( pVirtualSegmentList == pVirtualSegment )
				{
					pVirtualSegmentList->m_fIsPlaying = true;
				}
				else
				{
					pVirtualSegmentList->m_fIsPlaying = false;
				}
			}

			if( m_pSong )
			{
				m_pSong->SyncChanges( SC_EDITOR,
									  SSE_INVALIDATE_VIRTUAL_SEGMENT_LIST,
									  NULL );
			}

//			TRACE( " %x", pVirtualSegment );
		}
	}

	return 0;
}


/////////////////////////////////////////////////////////////////////////////
// CNotificationHandler::OnStopVirtualSegment

LRESULT CNotificationHandler::OnStopVirtualSegment( WPARAM wParam, LPARAM lParam )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(wParam);

	BSTR bstrName = (BSTR)lParam;
	CString strName = bstrName;
	::SysFreeString( bstrName );

	if( m_pSong )
	{
//		TRACE( "\nSTOP = %s ", strName );

		CVirtualSegment* pVirtualSegment = m_pSong->FindVirtualSegmentByName( strName );
		if( pVirtualSegment )
		{
			pVirtualSegment->m_fIsPlaying = false;

			if( m_pSong )
			{
				m_pSong->SyncChanges( SC_EDITOR,
									  SSE_INVALIDATE_VIRTUAL_SEGMENT_LIST,
									  NULL );
			}

//			TRACE( " %x", pVirtualSegment );
		}
	}

	return 0;
}


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// CDirectMusicSong constructor/destructor

CDirectMusicSong::CDirectMusicSong()
{
	ASSERT( theApp.m_pSongComponent != NULL );

	// Song needs Song Component
	theApp.m_pSongComponent->AddRef();

    m_dwRef = 0;
	AddRef();

	m_pUndoMgr = NULL;
	m_fModified = FALSE;

	m_pIDocRootNode = NULL;
	m_pIParentNode = NULL;
	m_pIContainerNode = NULL;
	m_pIAudioPathNode = NULL;
	m_pIDMSong = NULL;
	m_pIDMSegmentState = NULL;
	m_rpIDMStoppedSegmentState = NULL;
	m_pIDMTransitionSegmentState = NULL;
	m_fInTransition = false;
	m_dwTransitionPlayFlags = 0;
	m_pIDMTransitionSegment = NULL;

	m_fDeletingContainer = false;
	m_fChangingFolder = false;

	m_FolderSegments.m_pSong = this;
	m_FolderSegments.m_FolderEmbed.m_pSong = this;
	m_FolderSegments.m_FolderReference.m_pSong = this;
	m_FolderToolGraphs.m_pSong = this;

	m_hWndEditor = NULL;
	m_pSongCtrl = NULL;
	m_pINodeBeingDeleted = NULL;
	m_pIProject = NULL;

	m_dwSongFlagsDM = 0;
	m_dwStartSegID = 0;

// Song info block
	TCHAR achName[SMALL_BUFFER];
	::LoadString( theApp.m_hInstance, IDS_SONG_TEXT, achName, SMALL_BUFFER );
    m_strName.Format( "%s%d", achName, ++theApp.m_pSongComponent->m_nNextSong );

	CoCreateGuid( &m_guidSong ); 
	m_vVersion.dwVersionMS = 0x00010000;
	m_vVersion.dwVersionLS = 0x00000000;

	InitializeCriticalSection( &m_csSegmentState );

	// Create the notification window
	RECT rect;
	rect.top = 0;
	rect.bottom = 0;
	rect.left = 0;
	rect.right = 0;
	m_wndNotificationHandler.m_pSong = this;
	m_wndNotificationHandler.Create( NULL, _T("Hidden song notification handler"), WS_CHILD, rect, CWnd::FromHandle(GetDesktopWindow()), 0 );
}

CDirectMusicSong::~CDirectMusicSong()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( theApp.m_pSongComponent != NULL );
	ASSERT( theApp.m_pSongComponent->m_pIFramework8 != NULL );

	// Remove Song from clipboard
	theApp.FlushClipboard( this );

	// Remove Song from property sheet
	IDMUSProdPropSheet* pIPropSheet;

	if( SUCCEEDED ( theApp.m_pSongComponent->m_pIFramework8->QueryInterface( IID_IDMUSProdPropSheet, (void**)&pIPropSheet ) ) )
	{
		pIPropSheet->RemovePageManagerByObject( this );
		RELEASE( pIPropSheet );
	}

	// Cleanup the Undo Manager
	if( m_pUndoMgr )
	{
		delete m_pUndoMgr;
	}

	// Empty VirtualSegment list
	EmptyVirtualSegmentList();

	// Cleanup references
	RELEASE( m_pIDMTransitionSegmentState );
	RELEASE( m_pIDMTransitionSegment );
	
	EnterCriticalSection( &m_csSegmentState );
	RELEASE( m_pIDMSegmentState );
	LeaveCriticalSection( &m_csSegmentState );

	// Make sure that Containers cleanup properly.  Otherwise
	// Container that happens to be in the Framework's notification
	// list will never have its destructor called.
	if( m_pIContainerNode )
	{
		m_fDeletingContainer = true;
		m_pIContainerNode->DeleteNode( FALSE );
		m_fDeletingContainer = false;
	}

	RELEASE( m_pIContainerNode );
	RELEASE( m_pIAudioPathNode );

	if( m_pIDMSong )
	{
		IDirectMusicObjectP* pIDMObjectP;
		if( SUCCEEDED ( m_pIDMSong->QueryInterface( IID_IDirectMusicObjectP, (void**)&pIDMObjectP ) ) )
		{
			pIDMObjectP->Zombie();
			RELEASE( pIDMObjectP );
		}
	}
	RELEASE( m_pIDMSong );

	// Don't release m_rpIDMStoppedSegmentState, it's just a reference

	// Song no longer needs Song Component
	theApp.m_pSongComponent->Release();

	m_wndNotificationHandler.DestroyWindow();

	DeleteCriticalSection( &m_csSegmentState );
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicSong::OnNewContainer

HRESULT CDirectMusicSong::OnNewContainer( void )
{
	IDMUSProdNode* pIContainerNode;
	IDMUSProdDocType* pIDocType;

	ASSERT( theApp.m_pSongComponent != NULL );
	ASSERT( theApp.m_pSongComponent->m_pIFramework8 != NULL );

	// Do not call if Song already has a container!
	ASSERT( m_pIContainerNode == NULL );
	if( m_pIContainerNode )
	{
		return S_OK;
	}

	// Create the Container
	HRESULT hr = theApp.m_pSongComponent->m_pIFramework8->FindDocTypeByNodeId( GUID_ContainerNode, &pIDocType );
	if( SUCCEEDED ( hr ) ) 
	{
		hr = pIDocType->AllocNode( GUID_ContainerNode, &pIContainerNode );
		if( SUCCEEDED ( hr ) )
		{
			// Set name
			CString strName;
			strName.LoadString( IDS_CONTAINER_TEXT );
			BSTR bstrName = strName.AllocSysString();
			pIContainerNode->SetNodeName( bstrName );

			InsertChildNode( pIContainerNode );
			pIContainerNode->Release();
		}

		RELEASE( pIDocType );
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicSong::OnNewAudioPath

HRESULT CDirectMusicSong::OnNewAudioPath( void )
{
	IDMUSProdNode* pIAudioPathNode;
	IDMUSProdDocType* pIDocType;

	ASSERT( theApp.m_pSongComponent != NULL );
	ASSERT( theApp.m_pSongComponent->m_pIFramework8 != NULL );

	// Do not call if Song already has a AudioPath!
	ASSERT( m_pIAudioPathNode == NULL );
	if( m_pIAudioPathNode )
	{
		return S_OK;
	}

	// Create the AudioPath
	HRESULT hr = theApp.m_pSongComponent->m_pIFramework8->FindDocTypeByNodeId( GUID_AudioPathNode, &pIDocType );
	if( SUCCEEDED ( hr ) ) 
	{
		hr = pIDocType->AllocNode( GUID_AudioPathNode, &pIAudioPathNode );
		if( SUCCEEDED ( hr ) )
		{
			// Set name
			CString strName;
			strName.LoadString( IDS_AUDIOPATH_TEXT );
			BSTR bstrName = strName.AllocSysString();
			pIAudioPathNode->SetNodeName( bstrName );

			InsertChildNode( pIAudioPathNode );
			pIAudioPathNode->Release();
		}

		RELEASE( pIDocType );
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicSong::CreateUndoMgr

BOOL CDirectMusicSong::CreateUndoMgr()
{
	// Should only be called once - after Song first created
	ASSERT( m_pUndoMgr == NULL );

	ASSERT( theApp.m_pSongComponent != NULL ); 
	ASSERT( theApp.m_pSongComponent->m_pIFramework8 != NULL ); 

	m_pUndoMgr = new CJazzUndoMan( theApp.m_pSongComponent->m_pIFramework8 );
	if( m_pUndoMgr )
	{
		m_pUndoMgr->SetStreamAttributes( FT_DESIGN, GUID_CurrentVersion );
		return TRUE;
	}

	return FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicSong::SyncChanges

void CDirectMusicSong::SyncChanges( DWORD dwFlags, DWORD dwEditorFlags, IDMUSProdPropPageObject* pIPropPageObject )
{
	CWaitCursor wait;

	ASSERT( theApp.m_pSongComponent != NULL );
	ASSERT( theApp.m_pSongComponent->m_pIFramework8 != NULL );

	// Editor
	if( dwFlags & SC_EDITOR )
	{
		if( m_pSongCtrl
		&&  m_pSongCtrl->m_pSongDlg )
		{
			ASSERT( dwEditorFlags != 0 );
			m_pSongCtrl->m_pSongDlg->SyncSongEditor( dwEditorFlags );
		}
	}

	// Property sheet
	if( dwFlags & SC_PROPERTIES )
	{
		IDMUSProdPropSheet* pIPropSheet;
		if( SUCCEEDED ( theApp.m_pSongComponent->m_pIFramework8->QueryInterface( IID_IDMUSProdPropSheet, (void**)&pIPropSheet ) ) )
		{
			if( pIPropPageObject )
			{
				pIPropSheet->RefreshTitleByObject( pIPropPageObject );
				pIPropSheet->RefreshActivePageByObject( pIPropPageObject );
			}
			else
			{
				pIPropSheet->RefreshTitle();
				pIPropSheet->RefreshActivePage();
			}
			RELEASE( pIPropSheet );
		}
	}
	
	// DirectMusic
	if( dwFlags & SC_DIRECTMUSIC )
	{
		if( m_pIDMSong == NULL )
		{
			if( FAILED ( ::CoCreateInstance( CLSID_DirectMusicSong, NULL, CLSCTX_INPROC_SERVER,
											 IID_IDirectMusicSong, (void**)&m_pIDMSong ) ) )
			{
				RELEASE( m_pIDMSong );
			}
		}

		if( m_pIDMSong )
		{
			IStream* pIMemStream;
			if( SUCCEEDED ( theApp.m_pSongComponent->m_pIFramework8->AllocMemoryStream( FT_RUNTIME, GUID_DirectMusicObject, &pIMemStream ) ) )
			{
				if( SUCCEEDED ( Save( pIMemStream, FALSE ) ) )
				{
					IPersistStream* pIPersistStream;
					m_pIDMSong->QueryInterface( IID_IPersistStream, (void **)&pIPersistStream );
					if( pIPersistStream )
					{
						StreamSeek( pIMemStream, 0, STREAM_SEEK_SET );
						HRESULT hr = pIPersistStream->Load( pIMemStream );
						ASSERT( (hr == DMUS_E_NOT_INIT)  ||  (SUCCEEDED(hr)) );

						RELEASE( pIPersistStream );
					}
				}

				RELEASE( pIMemStream );
			}
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicSong::SetModified

void CDirectMusicSong::SetModified( BOOL fModified )
{
	m_fModified = fModified;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicSong IUnknown implementation

HRESULT CDirectMusicSong::QueryInterface( REFIID riid, LPVOID* ppvObj )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    if( ::IsEqualIID(riid, IID_IDMUSProdNode)
	||  ::IsEqualIID(riid, IID_IUnknown) )
    {
        *ppvObj = (IDMUSProdNode *)this;
    }
    else if( ::IsEqualIID(riid, IID_IPersist) )
    {
        *ppvObj = (IPersist *)this;
    }
    else if( ::IsEqualIID(riid, IID_IPersistStream) )
    {
        *ppvObj = (IPersistStream *)this;
    }
    else if( ::IsEqualIID(riid, IID_IDMUSProdPropPageObject) )
    {
        *ppvObj = (IDMUSProdPropPageObject *)this;
    }
	else if( ::IsEqualIID(riid, IID_IDMUSProdTransport) )
	{
		*ppvObj = (IDMUSProdTransport*) this;
	}
	else if( ::IsEqualIID(riid, IID_IDMUSProdSecondaryTransport) )
	{
		*ppvObj = (IDMUSProdSecondaryTransport*) this;
	}
	else if( ::IsEqualIID(riid, IID_IDMUSProdNotifySink) )
	{
		*ppvObj = (IDMUSProdNotifySink*) this;
	}
	else if( ::IsEqualIID(riid, IID_IDMUSProdSortNode) )
	{
		*ppvObj = (IDMUSProdSortNode*) this;
	}
	else
	{
		*ppvObj = NULL;
		return E_NOINTERFACE;
	}

	AddRef();
	return S_OK;
}

ULONG CDirectMusicSong::AddRef()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	AfxOleLockApp(); 
    return ++m_dwRef;
}

ULONG CDirectMusicSong::Release()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    ASSERT( m_dwRef != 0 );

	AfxOleUnlockApp(); 
    --m_dwRef;

    if( m_dwRef == 0 )
    {
        delete this;
        return 0;
    }

    return m_dwRef;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicSong IDMUSProdNode implementation

/////////////////////////////////////////////////////////////////////////////
// CDirectMusicSong IDMUSProdNode::GetNodeImageIndex

HRESULT CDirectMusicSong::GetNodeImageIndex( short* pnFirstImage )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( theApp.m_pSongComponent != NULL );

	return( theApp.m_pSongComponent->GetSongImageIndex(pnFirstImage) );
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicSong IDMUSProdNode::GetFirstChild

HRESULT CDirectMusicSong::GetFirstChild( IDMUSProdNode** ppIFirstChildNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( ppIFirstChildNode == NULL )
	{
		return E_POINTER;
	}
	
	m_FolderSegments.AddRef();
	*ppIFirstChildNode = (IDMUSProdNode *)&m_FolderSegments;

    return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicSong IDMUSProdNode::GetNextChild

HRESULT CDirectMusicSong::GetNextChild( IDMUSProdNode* pIChildNode, IDMUSProdNode** ppINextChildNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( ppINextChildNode == NULL )
	{
		return E_POINTER;
	}
	*ppINextChildNode = NULL;

	if( pIChildNode == NULL )
	{
		return E_INVALIDARG;
	}

	if( pIChildNode == (IDMUSProdNode *)&m_FolderSegments )
	{
		*ppINextChildNode = (IDMUSProdNode *)&m_FolderToolGraphs;
	}
	else if( pIChildNode == (IDMUSProdNode *)&m_FolderToolGraphs )
	{
		if( m_pIContainerNode )
		{
			*ppINextChildNode = (IDMUSProdNode *)m_pIContainerNode;
		}
		else if( m_pIAudioPathNode )
		{
			*ppINextChildNode = (IDMUSProdNode *)m_pIAudioPathNode;
		}
	}
	else if( pIChildNode == m_pIContainerNode )
	{
		if( m_pIAudioPathNode )
		{
			*ppINextChildNode = m_pIAudioPathNode;
		}
	}

	if( *ppINextChildNode )
	{
		(*ppINextChildNode)->AddRef();
	}

    return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicSong IDMUSProdNode::GetComponent

HRESULT CDirectMusicSong::GetComponent( IDMUSProdComponent** ppIComponent )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( theApp.m_pSongComponent != NULL );

	return theApp.m_pSongComponent->QueryInterface( IID_IDMUSProdComponent, (void**)ppIComponent );
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicSong IDMUSProdNode::GetDocRootNode

HRESULT CDirectMusicSong::GetDocRootNode( IDMUSProdNode** ppIDocRootNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pIDocRootNode )
	{
		m_pIDocRootNode->AddRef();
		*ppIDocRootNode = m_pIDocRootNode;
		return S_OK;
	}

	*ppIDocRootNode = NULL;
	return E_FAIL;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicSong IDMUSProdNode::SetDocRootNode

HRESULT CDirectMusicSong::SetDocRootNode( IDMUSProdNode* pIDocRootNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( pIDocRootNode != NULL );

	m_pIDocRootNode = pIDocRootNode;
//	m_pIDocRootNode->AddRef();		intentionally missing

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicSong IDMUSProdNode::GetParentNode

HRESULT CDirectMusicSong::GetParentNode( IDMUSProdNode** ppIParentNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( ppIParentNode == NULL )
	{
		return E_POINTER;
	}

	*ppIParentNode = m_pIParentNode;

	if( m_pIParentNode )
	{
		m_pIParentNode->AddRef();
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicSong IDMUSProdNode::SetParentNode

HRESULT CDirectMusicSong::SetParentNode( IDMUSProdNode* pIParentNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	m_pIParentNode = pIParentNode;
//	m_pIParentNode->AddRef();		intentionally missing

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicSong IDMUSProdNode::GetNodeId

HRESULT CDirectMusicSong::GetNodeId( GUID* pguid )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( pguid == NULL )
	{
		return E_POINTER;
	}

	*pguid = GUID_SongNode;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicSong IDMUSProdNode::GetNodeName

HRESULT CDirectMusicSong::GetNodeName( BSTR* pbstrName )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    *pbstrName = m_strName.AllocSysString();

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicSong IDMUSProdNode::GetNodeNameMaxLength

HRESULT CDirectMusicSong::GetNodeNameMaxLength( short* pnMaxLength )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	*pnMaxLength = DMUS_MAX_NAME;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicSong IDMUSProdNode::ValidateNodeName

HRESULT CDirectMusicSong::ValidateNodeName( BSTR bstrName )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CString strName;

	strName = bstrName;
	::SysFreeString( bstrName );

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicSong IDMUSProdNode::SetNodeName

HRESULT CDirectMusicSong::SetNodeName( BSTR bstrName )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( theApp.m_pSongComponent != NULL );
	ASSERT( theApp.m_pSongComponent->m_pIFramework8 != NULL );

	CString strName = bstrName;
	::SysFreeString( bstrName );

	if( m_strName == strName )
	{
		return S_OK;
	}

	m_pUndoMgr->SaveState( this, theApp.m_hInstance, IDS_UNDO_SONG_NAME );
	m_strName = strName;

	// Sync changes
	SetModified( TRUE );
	SyncChanges( SC_PROPERTIES | SC_DIRECTMUSIC,
		   	     0,
			    (IDMUSProdPropPageObject *)this );

	// Notify connected nodes that Song name has changed
	UpdateTransportName();
	theApp.m_pSongComponent->m_pIFramework8->NotifyNodes( this, SONG_NameChange, NULL );

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicSong IDMUSProdNode::GetNodeListInfo

HRESULT CDirectMusicSong::GetNodeListInfo( DMUSProdListInfo* pListInfo )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CString strDescriptor;

    pListInfo->bstrName = m_strName.AllocSysString();
    pListInfo->bstrDescriptor = strDescriptor.AllocSysString();
	memcpy( &pListInfo->guidObject, &m_guidSong, sizeof(GUID) );

	// Must check pListInfo->wSize before populating additional fields
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicSong IDMUSProdNode::GetEditorClsId

HRESULT CDirectMusicSong::GetEditorClsId( CLSID* pClsId )
{
 	AFX_MANAGE_STATE(_afxModuleAddrThis);

   *pClsId = CLSID_SongEditor;
	
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicSong IDMUSProdNode::GetEditorTitle

HRESULT CDirectMusicSong::GetEditorTitle( BSTR* pbstrTitle )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CString strTitle;
	TCHAR achTitle[MID_BUFFER];

	::LoadString( theApp.m_hInstance, IDS_SONG_TEXT, achTitle, MID_BUFFER );
	strTitle  = achTitle;
	strTitle += _T(": " );
	strTitle += m_strName;

    *pbstrTitle = strTitle.AllocSysString();

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicSong IDMUSProdNode::GetEditorWindow

HRESULT CDirectMusicSong::GetEditorWindow( HWND* hWndEditor )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	*hWndEditor = m_hWndEditor;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicSong IDMUSProdNode::SetEditorWindow

HRESULT CDirectMusicSong::SetEditorWindow( HWND hWndEditor )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	m_hWndEditor = hWndEditor;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicSong IDMUSProdNode::UseOpenCloseImages

HRESULT CDirectMusicSong::UseOpenCloseImages( BOOL* pfUseOpenCloseImages )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	*pfUseOpenCloseImages = FALSE;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicSong IDMUSProdNode::GetRightClickMenuId

HRESULT CDirectMusicSong::GetRightClickMenuId( HINSTANCE* phInstance, UINT* pnMenuId )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	*phInstance = theApp.m_hInstance;
	*pnMenuId   = IDM_SONG_NODE_RMENU;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicSong IDMUSProdNode::OnRightClickMenuInit

HRESULT CDirectMusicSong::OnRightClickMenuInit( HMENU hMenu )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	::EnableMenuItem( hMenu, IDM_NEW_AUDIOPATH, m_pIAudioPathNode ? (MF_GRAYED | MF_BYCOMMAND) : (MF_ENABLED | MF_BYCOMMAND) );
	::EnableMenuItem( hMenu, IDM_NEW_CONTAINER, m_pIContainerNode ? (MF_GRAYED | MF_BYCOMMAND) : (MF_ENABLED | MF_BYCOMMAND) );

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicSong IDMUSProdNode::OnRightClickMenuSelect

HRESULT CDirectMusicSong::OnRightClickMenuSelect( long lCommandId )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( theApp.m_pSongComponent != NULL );
	ASSERT( theApp.m_pSongComponent->m_pIFramework8 != NULL );

	HRESULT hr = E_FAIL;

	switch( lCommandId )
	{
		case IDM_NEW_AUDIOPATH:
			hr = OnNewAudioPath();
			if( m_pIAudioPathNode )
			{
				theApp.m_pSongComponent->m_pIFramework8->OpenEditor( m_pIAudioPathNode );
			}
			break;

		case IDM_NEW_CONTAINER:
			hr = OnNewContainer();
			break;

		case IDM_NEW_SOURCE_SEGMENT:
			hr = m_FolderSegments.m_FolderReference.InsertChildNode( NULL );
			break;

		case IDM_NEW_SOURCE_TOOLGRAPH:
			hr = m_FolderToolGraphs.InsertChildNode( NULL );
			break;

		case IDM_RENAME:
			hr = theApp.m_pSongComponent->m_pIFramework8->EditNodeLabel( this );
			break;

		case IDM_PROPERTIES:
			OnShowProperties();
			hr = S_OK;
			break;
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicSong IDMUSProdNode::DeleteChildNode

HRESULT CDirectMusicSong::DeleteChildNode( IDMUSProdNode* pIChildNode, BOOL fPromptUser )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( theApp.m_pSongComponent != NULL );
	ASSERT( theApp.m_pSongComponent->m_pIFramework8 != NULL );

	if(	m_fDeletingContainer )
	{
		// Nothing to do
		return S_OK;
	}


	CWaitCursor wait;

	if( pIChildNode == NULL 
	|| !(pIChildNode == m_pIContainerNode 
		 || pIChildNode == m_pIAudioPathNode) )
	{
		ASSERT( 0 );
		return E_INVALIDARG;
	}

	// Remove node from Project Tree
	if( theApp.m_pSongComponent->m_pIFramework8->RemoveNode( pIChildNode, fPromptUser ) == S_FALSE )
	{
		return E_FAIL;
	}

	// Remove from Song
	if( pIChildNode == m_pIContainerNode )
	{
		// Make sure that Containers cleanup properly.  Otherwise
		// Container that happens to be in the Framework's notification
		// list will never have its destructor called.
		if( m_pIContainerNode )
		{
			m_fDeletingContainer = true;
			m_pIContainerNode->DeleteNode( FALSE );
			m_fDeletingContainer = false;
		}
		RELEASE( m_pIContainerNode );
	}
	else if( pIChildNode == m_pIAudioPathNode )
	{
		RELEASE( m_pIAudioPathNode );
	}

	// Sync changes
	SetModified( TRUE );
	SyncChanges( SC_DIRECTMUSIC, 0, NULL );

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicSong IDMUSProdNode::InsertChildNode

HRESULT CDirectMusicSong::InsertChildNode( IDMUSProdNode* pIChildNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( theApp.m_pSongComponent != NULL );
	ASSERT( theApp.m_pSongComponent->m_pIFramework8 != NULL );

	if( pIChildNode == NULL )
	{
		return E_INVALIDARG;
	}

	pIChildNode->AddRef();

	// Songs can only have one Container or AudioPath
	GUID guidNode;
	if( FAILED( pIChildNode->GetNodeId( &guidNode ) ) )
	{
		return E_INVALIDARG;
	}

	if( guidNode == GUID_ContainerNode )
	{
		if( m_pIContainerNode )
		{
			DeleteChildNode( m_pIContainerNode, FALSE );
		}

		// Set the Segment's Container
		ASSERT( m_pIContainerNode == NULL );
		m_pIContainerNode = pIChildNode;

		// Set root and parent node of ALL children
		theApp.SetNodePointers( m_pIContainerNode, (IDMUSProdNode *)this, (IDMUSProdNode *)this );

		// Add node to Project Tree
		if( !SUCCEEDED ( theApp.m_pSongComponent->m_pIFramework8->AddNode(m_pIContainerNode, (IDMUSProdNode *)this) ) )
		{
			DeleteChildNode( m_pIContainerNode, FALSE );
			return E_FAIL;
		}
	}
	else if( guidNode == GUID_AudioPathNode )
	{
		if( m_pIAudioPathNode )
		{
			DeleteChildNode( m_pIAudioPathNode, FALSE );
		}

		// Set the Segment's Audio Path
		ASSERT( m_pIAudioPathNode == NULL );
		m_pIAudioPathNode = pIChildNode;

		// Set root and parent node of ALL children
		theApp.SetNodePointers( m_pIAudioPathNode, (IDMUSProdNode *)this, (IDMUSProdNode *)this );

		// Add node to Project Tree
		if( !SUCCEEDED ( theApp.m_pSongComponent->m_pIFramework8->AddNode(m_pIAudioPathNode, (IDMUSProdNode *)this) ) )
		{
			DeleteChildNode( m_pIAudioPathNode, FALSE );
			return E_FAIL;
		}
	}
	else
	{
		return E_INVALIDARG;
	}

	// Sync changes
	SetModified( TRUE );
	SyncChanges( SC_DIRECTMUSIC, 0, NULL );

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicSong IDMUSProdNode::DeleteNode

HRESULT CDirectMusicSong::DeleteNode( BOOL fPromptUser )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CWaitCursor wait;

	// No parent so we will delete ourself
	ASSERT( theApp.m_pSongComponent != NULL );
	ASSERT( theApp.m_pSongComponent->m_pIFramework8 != NULL );

	// Remove from Project Tree
	if( theApp.m_pSongComponent->m_pIFramework8->RemoveNode( this, fPromptUser ) == S_FALSE )
	{
		// User cancelled delete
		return E_FAIL;
	}

	// Song no longer needs Transport Controls
	UnRegisterWithTransport();

	// Make sure that Containers cleanup properly.  Otherwise
	// Container that happens to be in the Framework's notification
	// list will never have its destructor called.
	if( m_pIContainerNode )
	{
		m_fDeletingContainer = true;
		m_pIContainerNode->DeleteNode( FALSE );
		m_fDeletingContainer = false;
	}

	// Release the Song's container and AudioPath
	RELEASE( m_pIContainerNode );
	RELEASE( m_pIAudioPathNode );

	// Remove from Component Song list
	theApp.m_pSongComponent->RemoveFromSongFileList( this );

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicSong IDMUSProdNode::OnNodeSelChanged

HRESULT CDirectMusicSong::OnNodeSelChanged( BOOL fSelected )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( fSelected )
	{
		SetActiveTransport();
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicSong IDMUSProdNode::CreateDataObject

HRESULT CDirectMusicSong::CreateDataObject( IDataObject** ppIDataObject )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( theApp.m_pSongComponent != NULL );
	ASSERT( theApp.m_pSongComponent->m_pIFramework8 != NULL );

	if( ppIDataObject == NULL )
	{
		return E_POINTER;
	}

	*ppIDataObject = NULL;

	// Create the CDllJazzDataObject 
	CDllJazzDataObject* pDataObject = new CDllJazzDataObject();
	if( pDataObject == NULL )
	{
		return E_OUTOFMEMORY;
	}

	IStream* pIStream;

	// Save Song into stream
	HRESULT hr = E_FAIL;

	if( SUCCEEDED ( theApp.m_pSongComponent->m_pIFramework8->AllocMemoryStream(FT_DESIGN, GUID_CurrentVersion, &pIStream) ) )
	{
		if( SUCCEEDED ( Save( pIStream, FALSE ) ) )
		{
			// Place CF_SONG into CDllJazzDataObject
			if( SUCCEEDED ( pDataObject->AddClipFormat( theApp.m_pSongComponent->m_cfSong, pIStream ) ) )
			{
				hr = S_OK;
			}
		}

		RELEASE( pIStream );
	}

	if( SUCCEEDED ( hr ) )
	{
		hr = E_FAIL;

		// Create a stream in CF_DMUSPROD_FILE format
		if( SUCCEEDED ( theApp.m_pSongComponent->m_pIFramework8->SaveClipFormat( theApp.m_pSongComponent->m_cfProducerFile, this, &pIStream ) ) )
		{
			// Song nodes represent files so we must also
			// place CF_DMUSPROD_FILE into CDllJazzDataObject
			if( SUCCEEDED ( pDataObject->AddClipFormat( theApp.m_pSongComponent->m_cfProducerFile, pIStream ) ) )
			{
				hr = S_OK;
			}

			RELEASE( pIStream );
		}
	}

	if( SUCCEEDED ( hr ) )
	{
		*ppIDataObject = pDataObject;	// already AddRef'd
	}
	else
	{
		RELEASE( pDataObject );
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicSong IDMUSProdNode::CanCut

HRESULT CDirectMusicSong::CanCut( void )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
 
	return CanDelete();
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicSong IDMUSProdNode::CanCopy

HRESULT CDirectMusicSong::CanCopy( void )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
 
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicSong IDMUSProdNode::CanDelete

HRESULT CDirectMusicSong::CanDelete( void )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicSong IDMUSProdNode::CanDeleteChildNode

HRESULT CDirectMusicSong::CanDeleteChildNode( IDMUSProdNode* pIChildNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( pIChildNode == NULL )
	{
		return E_POINTER;
	}

	if( pIChildNode == m_pIContainerNode 
	||  pIChildNode == m_pIAudioPathNode )
	{
		return S_OK;
	}

	return S_FALSE;	
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicSong IDMUSProdNode::CanPasteFromData

HRESULT CDirectMusicSong::CanPasteFromData( IDataObject* pIDataObject, BOOL* pfWillSetReference )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( theApp.m_pSongComponent != NULL );
	ASSERT( theApp.m_pSongComponent->m_pIFramework8 != NULL );

	if( pfWillSetReference == NULL )
	{
		return E_POINTER;
	}

	*pfWillSetReference = FALSE;

	if( pIDataObject == NULL )
	{
		return E_INVALIDARG;
	}

	// Create a new CDllJazzDataObject and see if it can read the data object's format.
	CDllJazzDataObject* pDataObject = new CDllJazzDataObject();
	if( pDataObject == NULL )
	{
		return E_OUTOFMEMORY;
	}
	if( pDataObject->IsClipFormatAvailable(pIDataObject, theApp.m_pSongComponent->m_cfContainer) == S_OK 
	||  pDataObject->IsClipFormatAvailable(pIDataObject, theApp.m_pSongComponent->m_cfAudioPath) == S_OK )
	{
		RELEASE( pDataObject );
		return S_OK;
	}
	RELEASE( pDataObject );

	// Delegate to parent
	if( m_pIDocRootNode != this )
	{
		if( m_pIParentNode )
		{
			return m_pIParentNode->CanChildPasteFromData( pIDataObject, this, pfWillSetReference );
		}
	}
	
	return S_FALSE; 	
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicSong IDMUSProdNode::PasteFromData

HRESULT CDirectMusicSong::PasteFromData( IDataObject* pIDataObject )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	HRESULT hr = E_FAIL;

	// Create a new CDllJazzDataObject and see if it can read the data object's format.
	CDllJazzDataObject* pDataObject = new CDllJazzDataObject();
	if( pDataObject == NULL )
	{
		return E_OUTOFMEMORY;
	}

	if( SUCCEEDED ( pDataObject->IsClipFormatAvailable( pIDataObject, theApp.m_pSongComponent->m_cfContainer ) ) )
	{
		// Handle CF_CONTAINER 
		hr = PasteCF_CONTAINER( pDataObject, pIDataObject );
	}
	else if( SUCCEEDED ( pDataObject->IsClipFormatAvailable( pIDataObject, theApp.m_pSongComponent->m_cfAudioPath ) ) )
	{
		// Handle CF_AUDIOPATH 
		hr = PasteCF_AUDIOPATH( pDataObject, pIDataObject );
	}

	RELEASE( pDataObject );
	
	if( hr == S_OK )
	{
		return hr;
	}

	// Let parent handle paste
	if( m_pIDocRootNode != this )
	{
		if( m_pIParentNode )
		{
			return m_pIParentNode->ChildPasteFromData( pIDataObject, this );
		}
	}

	return E_FAIL;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicSong IDMUSProdNode::CanChildPasteFromData

HRESULT CDirectMusicSong::CanChildPasteFromData( IDataObject* pIDataObject, IDMUSProdNode* pIChildNode,
												  BOOL* pfWillSetReference )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( pfWillSetReference == NULL )
	{
		return E_POINTER;
	}

	*pfWillSetReference = FALSE;

	if( pIDataObject == NULL )
	{
		return E_INVALIDARG;
	}

	GUID guidNodeId;
	pIChildNode->GetNodeId( &guidNodeId );

	// Create a new CDllJazzDataObject and see if it can read the data object's format.
	CDllJazzDataObject* pDataObject = new CDllJazzDataObject();
	if( pDataObject == NULL )
	{
		return E_OUTOFMEMORY;
	}

	HRESULT hr = S_FALSE;
	
	if( SUCCEEDED ( pDataObject->IsClipFormatAvailable( pIDataObject, theApp.m_pSongComponent->m_cfContainer ) ) )
	{
		if( ::IsEqualGUID( guidNodeId, GUID_ContainerNode ) )
		{
			hr = S_OK;
		}
	}
	else if( SUCCEEDED ( pDataObject->IsClipFormatAvailable( pIDataObject, theApp.m_pSongComponent->m_cfAudioPath ) ) )
	{
		if( ::IsEqualGUID( guidNodeId, GUID_AudioPathNode ) )
		{
			hr = S_OK;
		}
	}

	RELEASE( pDataObject );
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicSong IDMUSProdNode::ChildPasteFromData

HRESULT CDirectMusicSong::ChildPasteFromData( IDataObject* pIDataObject, IDMUSProdNode* pIChildNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( pIDataObject == NULL
	||  pIChildNode == NULL )
	{
		return E_INVALIDARG;
	}

	// Create a new CDllJazzDataObject to get the data object's stream.
	CDllJazzDataObject* pDataObject = new CDllJazzDataObject();
	if( pDataObject == NULL )
	{
		return E_OUTOFMEMORY;
	}

	HRESULT hr = E_FAIL;

	if( SUCCEEDED ( pDataObject->IsClipFormatAvailable( pIDataObject, theApp.m_pSongComponent->m_cfContainer ) ) )
	{
		// Handle CF_CONTAINER format
		hr = PasteCF_CONTAINER( pDataObject, pIDataObject );
	}
	else if( SUCCEEDED ( pDataObject->IsClipFormatAvailable( pIDataObject, theApp.m_pSongComponent->m_cfAudioPath ) ) )
	{
		// Handle CF_AUDIOPATH format
		hr = PasteCF_AUDIOPATH( pDataObject, pIDataObject );
	}

	RELEASE( pDataObject );
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicSong IDMUSProdNode::GetObject

HRESULT CDirectMusicSong::GetObject( REFCLSID rclsid, REFIID riid, void** ppvObject )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Must be asking for an interface to a CLSID_DMSong object
	if( ::IsEqualCLSID( rclsid, CLSID_DirectMusicSong ) )
	{
		if( m_pIDMSong )
		{
			return m_pIDMSong->QueryInterface( riid, ppvObject );
		}
	}

    *ppvObject = NULL;
    return E_NOINTERFACE;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicSong IDMUSProdPropPageObject implementation

/////////////////////////////////////////////////////////////////////////////
// CDirectMusicSong IDMUSProdPropPageObject::GetData

HRESULT CDirectMusicSong::GetData( void** ppData )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( ppData == NULL )
	{
		return E_POINTER;
	}

	*ppData = this;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicSong IDMUSProdPropPageObject::SetData

HRESULT CDirectMusicSong::SetData( void* pData )
{
	//AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(pData);

	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicSong IDMUSProdPropPageObject::OnShowProperties

HRESULT CDirectMusicSong::OnShowProperties( void )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( theApp.m_pSongComponent != NULL );
	ASSERT( theApp.m_pSongComponent->m_pIFramework8 != NULL );

	// Get the Song page manager
	CSongPropPageManager* pPageManager;

	if( theApp.m_pIPageManager
	&&  theApp.m_pIPageManager->IsEqualPageManagerGUID( GUID_SongPropPageManager ) == S_OK )
	{
		pPageManager = (CSongPropPageManager *)theApp.m_pIPageManager;
	}
	else
	{
		pPageManager = new CSongPropPageManager();
	}

	if( pPageManager == NULL )
	{
		return E_FAIL;
	}

	// Show the Song properties
	IDMUSProdPropSheet* pIPropSheet;

	if( SUCCEEDED ( theApp.m_pSongComponent->m_pIFramework8->QueryInterface( IID_IDMUSProdPropSheet, (void**)&pIPropSheet ) ) )
	{
		short nActiveTab = CSongPropPageManager::sm_nActiveTab;

		if( SUCCEEDED ( pIPropSheet->SetPageManager(pPageManager) ) )
		{
			theApp.m_pIPageManager = pPageManager;
			pPageManager->SetObject( this );
			pIPropSheet->SetActivePage( nActiveTab ); 
		}

		pIPropSheet->Show( TRUE );
		RELEASE( pIPropSheet );
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicSong IDMUSProdPropPageObject::OnRemoveFromPageManager

HRESULT CDirectMusicSong::OnRemoveFromPageManager( void )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicSong IPersist implementation

/////////////////////////////////////////////////////////////////////////////
// CDirectMusicSong IPersist::GetClassID

HRESULT CDirectMusicSong::GetClassID( CLSID* pClsId )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    ASSERT( pClsId != NULL );

    memset( pClsId, 0, sizeof( CLSID ) );

    return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicSong IPersistStream implementation

/////////////////////////////////////////////////////////////////////////////
// CDirectMusicSong IPersistStream::IsDirty

HRESULT CDirectMusicSong::IsDirty()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_fModified )
	{
		return S_OK;
	}

	return S_FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicSong::LoadSong

HRESULT CDirectMusicSong::LoadSong( IDMUSProdRIFFStream* pIRiffStream, MMCKINFO* pckMain )
{
    IStream*      pIStream;
	MMCKINFO	  ck;
	MMCKINFO	  ckList;
	DWORD		  dwByteCount;
	DWORD		  dwSize;
	DWORD		  dwPos;
    HRESULT       hr = S_OK;

	ASSERT( theApp.m_pSongComponent != NULL );

	// Determine if Song is in Project Tree
	bool fIsInProjectTree = false;
	GUID guidFile;
	if( SUCCEEDED ( theApp.m_pSongComponent->m_pIFramework8->GetNodeFileGUID( this, &guidFile ) ) )
	{
		fIsInProjectTree = true;
	}

	// Clear the Song to prepare for load
	{
		// Remove pointers from Song editor (when open)
		SyncChanges( SC_EDITOR, SSE_EMPTY_ALL_LISTS, NULL );

		// Remove folders from Project Tree
		if( fIsInProjectTree )
		{
			theApp.m_pSongComponent->m_pIFramework8->RemoveNode( (IDMUSProdNode* )&m_FolderToolGraphs, FALSE );
			theApp.m_pSongComponent->m_pIFramework8->RemoveNode( (IDMUSProdNode* )&m_FolderSegments.m_FolderEmbed, FALSE );
			theApp.m_pSongComponent->m_pIFramework8->RemoveNode( (IDMUSProdNode* )&m_FolderSegments.m_FolderReference, FALSE );
		}

		// Empty lists
		EmptyVirtualSegmentList();
		m_FolderToolGraphs.EmptyToolGraphList();
		m_FolderSegments.m_FolderEmbed.EmptySourceSegmentList();
		m_FolderSegments.m_FolderReference.EmptySourceSegmentList();

		// Following strings only saved when they have values
		// So make sure they are initialized!!
		m_strAuthor.Empty();
		m_strCopyright.Empty();
		m_strSubject.Empty();
		m_strInfo.Empty();
	}

    pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

    dwPos = StreamTell( pIStream );

    while( pIRiffStream->Descend( &ck, pckMain, 0 ) == 0 )
	{
        switch( ck.ckid )
		{
			case DMUS_FOURCC_SONG_CHUNK:
			{
			    DMUS_IO_SONG_HEADER dmusSongIO;

				dwSize = min( ck.cksize, sizeof( DMUS_IO_SONG_HEADER ) );
				hr = pIStream->Read( &dmusSongIO, dwSize, &dwByteCount );
				if( FAILED( hr )
				||  dwByteCount != dwSize )
				{
					hr = E_FAIL;
					goto ON_ERROR;
				}

				m_dwSongFlagsDM = dmusSongIO.dwFlags;
				m_dwStartSegID = dmusSongIO.dwStartSegID;
				if( m_dwStartSegID == DMUS_SONG_NOSEG )
				{
					m_dwStartSegID = 0;
				}
				break;
			}

			case DMUS_FOURCC_GUID_CHUNK:
				dwSize = min( ck.cksize, sizeof( GUID ) );
				hr = pIStream->Read( &m_guidSong, dwSize, &dwByteCount );
				if( FAILED( hr )
				||  dwByteCount != dwSize )
				{
					hr = E_FAIL;
					goto ON_ERROR;
				}
				break;

			case DMUS_FOURCC_VERSION_CHUNK:
			{
			    DMUS_IO_VERSION dmusVersionIO;

				dwSize = min( ck.cksize, sizeof( DMUS_IO_VERSION ) );
				hr = pIStream->Read( &dmusVersionIO, dwSize, &dwByteCount );
				if( FAILED( hr )
				||  dwByteCount != dwSize )
				{
					hr = E_FAIL;
					goto ON_ERROR;
				}

				m_vVersion.dwVersionMS = dmusVersionIO.dwVersionMS;
				m_vVersion.dwVersionLS = dmusVersionIO.dwVersionLS;
				break;
			}

			case FOURCC_RIFF:
				switch( ck.fccType )
				{
					case DMUS_FOURCC_CONTAINER_FORM: 
					{
						IDMUSProdRIFFExt* pIRIFFExt;
						IDMUSProdNode* pINode;

						hr = theApp.m_pSongComponent->m_pIContainerComponent->QueryInterface( IID_IDMUSProdRIFFExt, (void**)&pIRIFFExt );
						if( FAILED( hr ) )
						{
			                goto ON_ERROR;
						}
					    StreamSeek( pIStream, dwPos, STREAM_SEEK_SET );
						hr = pIRIFFExt->LoadRIFFChunk( pIStream, &pINode );
						RELEASE( pIRIFFExt );
						if( FAILED( hr ) )
						{
			                goto ON_ERROR;
						}
						if( m_pIContainerNode )
						{
							InsertChildNode( pINode);
							pINode->Release();
						}
						else
						{
							m_pIContainerNode = pINode;
						}
						break;
					}

					case DMUS_FOURCC_AUDIOPATH_FORM: 
					{
						IDMUSProdRIFFExt* pIRIFFExt;
						IDMUSProdNode* pINode;

						hr = theApp.m_pSongComponent->m_pIAudioPathComponent->QueryInterface( IID_IDMUSProdRIFFExt, (void**)&pIRIFFExt );
						if( FAILED( hr ) )
						{
			                goto ON_ERROR;
						}
					    StreamSeek( pIStream, dwPos, STREAM_SEEK_SET );
						hr = pIRIFFExt->LoadRIFFChunk( pIStream, &pINode );
						RELEASE( pIRIFFExt );
						if( FAILED( hr ) )
						{
			                goto ON_ERROR;
						}
						if( m_pIAudioPathNode )
						{
							InsertChildNode( pINode);
							pINode->Release();
						}
						else
						{
							m_pIAudioPathNode = pINode;
						}
						break;
					}
				}
				break;

			case FOURCC_LIST:
				switch( ck.fccType )
				{
					case DMUS_FOURCC_SONGSEGMENTS_LIST:
						hr = m_FolderSegments.LoadSegments( pIRiffStream, &ck );
						if( FAILED ( hr ) )
						{
							goto ON_ERROR;
						}
						break;

					case DMUS_FOURCC_TOOLGRAPHS_LIST:
						hr = m_FolderToolGraphs.LoadToolGraphs( pIRiffStream, &ck );
						if( FAILED ( hr ) )
						{
							goto ON_ERROR;
						}
						break;

					case DMUS_FOURCC_SEGREFS_LIST:
						while( pIRiffStream->Descend( &ckList, &ck, 0 ) == 0 )
						{
							switch( ckList.ckid )
							{
								case FOURCC_LIST:
									switch( ckList.fccType )
									{
										case DMUS_FOURCC_SEGREF_LIST:
										{
											CVirtualSegment* pVirtualSegment = new CVirtualSegment( this );
											if( pVirtualSegment == NULL )
											{
												hr = E_OUTOFMEMORY;
												goto ON_ERROR;
											}

											hr = pVirtualSegment->Load( pIRiffStream, &ck );
											if( FAILED ( hr ) )
											{
												delete pVirtualSegment;
												goto ON_ERROR;
											}

											// Add to VirtualSegment list
											InsertVirtualSegment( pVirtualSegment, -1 );
											RELEASE( pVirtualSegment );
											break;
										}
									}
							}
					        pIRiffStream->Ascend( &ckList, 0 );
						}
						break;

					case DMUS_FOURCC_UNFO_LIST:
						while( pIRiffStream->Descend( &ckList, &ck, 0 ) == 0 )
						{
							switch( ckList.ckid )
							{
								case DMUS_FOURCC_UNAM_CHUNK:
								{
									CString strName;

									ReadMBSfromWCS( pIStream, ckList.cksize, &strName );
									if( strName.CompareNoCase( m_strName ) != 0 )
									{
										m_strName = strName;
										theApp.m_pSongComponent->m_pIFramework8->RefreshNode( this );

										// Notify connected nodes that the Song name has changed
										UpdateTransportName();
										theApp.m_pSongComponent->m_pIFramework8->NotifyNodes( this, SONG_NameChange, NULL );
									}
									break;
								}

								case DMUS_FOURCC_UART_CHUNK:
									ReadMBSfromWCS( pIStream, ckList.cksize, &m_strAuthor );
									break;

								case DMUS_FOURCC_UCOP_CHUNK:
									ReadMBSfromWCS( pIStream, ckList.cksize, &m_strCopyright );
									break;

								case DMUS_FOURCC_USBJ_CHUNK:
									ReadMBSfromWCS( pIStream, ckList.cksize, &m_strSubject );
									break;

								case DMUS_FOURCC_UCMT_CHUNK:
									ReadMBSfromWCS( pIStream, ckList.cksize, &m_strInfo );
									break;
							}
					        pIRiffStream->Ascend( &ckList, 0 );
						}
						break;
				}
				break;
        }

        pIRiffStream->Ascend( &ck, 0 );
	    dwPos = StreamTell( pIStream );
    }

	ResolveVirtualSegmentIDs();

	if( fIsInProjectTree )
	{
		// Set root and parent node of ALL children
		theApp.SetNodePointers( (IDMUSProdNode* )&m_FolderToolGraphs, (IDMUSProdNode *)this, (IDMUSProdNode *)this );
		theApp.SetNodePointers( (IDMUSProdNode* )&m_FolderSegments.m_FolderEmbed, (IDMUSProdNode *)this, (IDMUSProdNode *)&m_FolderSegments );
		theApp.SetNodePointers( (IDMUSProdNode* )&m_FolderSegments.m_FolderReference, (IDMUSProdNode *)this, (IDMUSProdNode *)&m_FolderSegments );

		// Place folders back in Project Tree
		theApp.m_pSongComponent->m_pIFramework8->AddNode( (IDMUSProdNode* )&m_FolderToolGraphs, (IDMUSProdNode *)this );
		theApp.m_pSongComponent->m_pIFramework8->AddNode( (IDMUSProdNode* )&m_FolderSegments.m_FolderEmbed, (IDMUSProdNode *)&m_FolderSegments );
		theApp.m_pSongComponent->m_pIFramework8->AddNode( (IDMUSProdNode* )&m_FolderSegments.m_FolderReference, (IDMUSProdNode *)&m_FolderSegments );
	}

ON_ERROR:
    RELEASE( pIStream );
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicSong IPersistStream::Load

HRESULT CDirectMusicSong::Load( IStream* pIStream )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    ASSERT( pIStream != NULL );
	if( pIStream == NULL )
	{
		return E_INVALIDARG;
	}

	// Generate EmbeddedFile list
	DWORD dwCurrentFilePos = StreamTell( pIStream );
	theApp.m_pSongComponent->CreateEmbeddedFileList( pIStream );
	StreamSeek( pIStream, dwCurrentFilePos, 0 );

	// Load the Song
    IDMUSProdRIFFStream* pIRiffStream;
    MMCKINFO ckMain;
    HRESULT hr = E_FAIL;

    DWORD dwPos = StreamTell( pIStream );

	// Check for Direct Music format
	BOOL fFoundFormat = FALSE;
	if( SUCCEEDED( AllocRIFFStream( pIStream, &pIRiffStream ) ) )
	{
		ckMain.fccType = DMUS_FOURCC_SONG_FORM;

		if( pIRiffStream->Descend( &ckMain, NULL, MMIO_FINDRIFF ) == 0 )
		{
			fFoundFormat = TRUE;
			hr = LoadSong( pIRiffStream, &ckMain );
		}

		RELEASE( pIRiffStream );
	}

	// Sync UI
	if( m_pIDocRootNode )
	{
		// Already in Project Tree so sync changes
		// Refresh Song editor (when open)
		SyncChanges( SC_EDITOR | SC_PROPERTIES,
					 SSE_ALL,
					 NULL );
	}

	//	Persist Song to the DirectMusic DLLs.
	if( SUCCEEDED( hr ) )
	{
		SyncChanges( SC_DIRECTMUSIC, 0, NULL );
	}

 	// Release EmbeddedFile list
	theApp.m_pSongComponent->ReleaseEmbeddedFileList();

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicSong SaveInfoList
    
HRESULT CDirectMusicSong::SaveInfoList( IDMUSProdRIFFStream* pIRiffStream )
{
	IStream* pIStream;
	HRESULT hr;
    MMCKINFO ckMain;
    MMCKINFO ck;

	if( m_strName.IsEmpty()
	&&  m_strAuthor.IsEmpty()
	&&  m_strCopyright.IsEmpty()
	&&  m_strSubject.IsEmpty() 
	&&  m_strInfo.IsEmpty() )
	{
		return S_OK;
	}

    pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

	// Write UNFO LIST header
	ckMain.fccType = DMUS_FOURCC_UNFO_LIST;
	if( pIRiffStream->CreateChunk(&ckMain, MMIO_CREATELIST) != 0 )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

	// Write Song name
	if( !m_strName.IsEmpty() )
	{
		ck.ckid = DMUS_FOURCC_UNAM_CHUNK;
		if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}

		hr = SaveMBStoWCS( pIStream, &m_strName );
		if( FAILED( hr ) )
		{
			goto ON_ERROR;
		}

		if( pIRiffStream->Ascend(&ck, 0) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}
	}

	// Write Song author
	if( !m_strAuthor.IsEmpty() )
	{
		ck.ckid = DMUS_FOURCC_UART_CHUNK;
		if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}

		hr = SaveMBStoWCS( pIStream, &m_strAuthor );
		if( FAILED( hr ) )
		{
			goto ON_ERROR;
		}

		if( pIRiffStream->Ascend(&ck, 0) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}
	}

	// Write Song copyright
	if( !m_strCopyright.IsEmpty() )
	{
		ck.ckid = DMUS_FOURCC_UCOP_CHUNK;
		if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}

		hr = SaveMBStoWCS( pIStream, &m_strCopyright );
		if( FAILED( hr ) )
		{
			goto ON_ERROR;
		}

		if( pIRiffStream->Ascend(&ck, 0) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}
	}

	// Write Song subject
	if( !m_strSubject.IsEmpty() )
	{
		ck.ckid = DMUS_FOURCC_USBJ_CHUNK;
		if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}

		hr = SaveMBStoWCS( pIStream, &m_strSubject );
		if( FAILED( hr ) )
		{
			goto ON_ERROR;
		}

		if( pIRiffStream->Ascend(&ck, 0) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}
	}

	// Write Song comments
	if( !m_strInfo.IsEmpty() )
	{
		ck.ckid = DMUS_FOURCC_UCMT_CHUNK;
		if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}

		hr = SaveMBStoWCS( pIStream, &m_strInfo );
		if( FAILED( hr ) )
		{
			goto ON_ERROR;
		}

		if( pIRiffStream->Ascend(&ck, 0) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}
	}

	if( pIRiffStream->Ascend(&ckMain, 0) != 0 )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

ON_ERROR:
    RELEASE( pIStream );
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicSong SaveVersion
    
HRESULT CDirectMusicSong::SaveVersion( IDMUSProdRIFFStream* pIRiffStream )
{
	IStream* pIStream;
	HRESULT hr;
	MMCKINFO ck;
	DWORD dwBytesWritten;
	DMUS_IO_VERSION dmusVersionIO;

    pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

	// Write Version chunk header
	ck.ckid = DMUS_FOURCC_VERSION_CHUNK;
	if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

	// Prepare DMUS_IO_VERSION structure
	memset( &dmusVersionIO, 0, sizeof(DMUS_IO_VERSION) );

	dmusVersionIO.dwVersionMS = m_vVersion.dwVersionMS ;
	dmusVersionIO.dwVersionLS = m_vVersion.dwVersionLS;

	// Write Version chunk data
	hr = pIStream->Write( &dmusVersionIO, sizeof(DMUS_IO_VERSION), &dwBytesWritten);
	if( FAILED( hr )
	||  dwBytesWritten != sizeof(DMUS_IO_VERSION) )
	{
        hr = E_FAIL;
        goto ON_ERROR;
	}
	
	if( pIRiffStream->Ascend( &ck, 0 ) != 0 )
	{
 		hr = E_FAIL;
		goto ON_ERROR;
	}

ON_ERROR:
    RELEASE( pIStream );
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicSong SaveGUID
    
HRESULT CDirectMusicSong::SaveGUID( IDMUSProdRIFFStream* pIRiffStream )
{
	IStream* pIStream;
	HRESULT hr;
	MMCKINFO ck;
	DWORD dwBytesWritten;

    pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

	// Write GUID chunk header
	ck.ckid = DMUS_FOURCC_GUID_CHUNK;
	if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

	// Write Song GUID
	hr = pIStream->Write( &m_guidSong, sizeof(GUID), &dwBytesWritten);
	if( FAILED( hr )
	||  dwBytesWritten != sizeof(GUID) )
	{
        hr = E_FAIL;
        goto ON_ERROR;
	}
	
	if( pIRiffStream->Ascend( &ck, 0 ) != 0 )
	{
 		hr = E_FAIL;
		goto ON_ERROR;
	}

ON_ERROR:
    RELEASE( pIStream );
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicSong SaveHeader
    
HRESULT CDirectMusicSong::SaveHeader( IDMUSProdRIFFStream* pIRiffStream )
{
	IStream* pIStream;
	HRESULT hr;
	MMCKINFO ck;
	DWORD dwBytesWritten;
	DMUS_IO_SONG_HEADER dmusSongIO;

    pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

	// Write Song chunk header
	ck.ckid = DMUS_FOURCC_SONG_CHUNK;
	if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

	// Prepare DMUS_IO_SONG_HEADER structure
	memset( &dmusSongIO, 0, sizeof(DMUS_IO_SONG_HEADER) );

	dmusSongIO.dwFlags = m_dwSongFlagsDM;
	dmusSongIO.dwStartSegID = m_dwStartSegID;

	// Write Song chunk data
	hr = pIStream->Write( &dmusSongIO, sizeof(DMUS_IO_SONG_HEADER), &dwBytesWritten);
	if( FAILED( hr )
	||  dwBytesWritten != sizeof(DMUS_IO_SONG_HEADER) )
	{
        hr = E_FAIL;
        goto ON_ERROR;
	}
	
	if( pIRiffStream->Ascend( &ck, 0 ) != 0 )
	{
 		hr = E_FAIL;
		goto ON_ERROR;
	}

ON_ERROR:
    RELEASE( pIStream );
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicSong SaveSong
    
HRESULT CDirectMusicSong::SaveSong( IDMUSProdRIFFStream* pIRiffStream, BOOL fClearDirty )
{
	HRESULT hr = S_OK;
	POSITION pos;

    IStream* pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

// Save Song header chunk
	hr = SaveHeader( pIRiffStream );
	if( FAILED ( hr ) )
	{
		goto ON_ERROR;
	}

// Save Song GUID
	hr = SaveGUID( pIRiffStream );
	if( FAILED ( hr ) )
	{
		goto ON_ERROR;
	}

// Save Song version
	hr = SaveVersion( pIRiffStream );
	if( FAILED ( hr ) )
	{
		goto ON_ERROR;
	}

// Save Song info
	hr = SaveInfoList( pIRiffStream );
	if( FAILED ( hr ) )
	{
		goto ON_ERROR;
	}

// Save Song's Container
	if( m_pIContainerNode )
	{
		IPersistStream* pIPersistStream;

		hr = m_pIContainerNode->QueryInterface( IID_IPersistStream, (void**)&pIPersistStream );
		if( FAILED( hr ) )
		{
			goto ON_ERROR;
		}
		hr = pIPersistStream->Save( pIStream, fClearDirty );
		RELEASE( pIPersistStream );
		if( FAILED( hr ) )
		{
			goto ON_ERROR;
		}
	}

// Save Song's SourceSegments
	hr = m_FolderSegments.SaveSegments( pIRiffStream );
	if( FAILED( hr ) )
	{
		goto ON_ERROR;
	}

// Save Song's SourceToolGraphs
	hr = m_FolderToolGraphs.SaveToolGraphs( pIRiffStream, fClearDirty );
	if( FAILED( hr ) )
	{
		goto ON_ERROR;
	}

// Save Song's AudioPath
	if( m_pIAudioPathNode )
	{
		IPersistStream* pIPersistStream;

		hr = m_pIAudioPathNode->QueryInterface( IID_IPersistStream, (void**)&pIPersistStream );
		if( FAILED( hr ) )
		{
			goto ON_ERROR;
		}
		hr = pIPersistStream->Save( pIStream, fClearDirty );
		RELEASE( pIPersistStream );
		if( FAILED( hr ) )
		{
			goto ON_ERROR;
		}
	}

// Save Song's VirtualSegments
	{
		// Write DMUS_FOURCC_SEGREFS_LIST header
		MMCKINFO ck;
		ck.fccType = DMUS_FOURCC_SEGREFS_LIST;
		if( pIRiffStream->CreateChunk(&ck, MMIO_CREATELIST) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}

		pos = m_lstVirtualSegments.GetHeadPosition();
		while( pos )
		{
			CVirtualSegment* pVirtualSegment = m_lstVirtualSegments.GetNext( pos );

			pVirtualSegment->Save( pIRiffStream );
		}

		if( pIRiffStream->Ascend(&ck, 0) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}
	}

ON_ERROR:
    RELEASE( pIStream );
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicSong SaveSelectedVirtualSegments
    
HRESULT CDirectMusicSong::SaveSelectedVirtualSegments( IDMUSProdRIFFStream* pIRiffStream )
{
	HRESULT hr = S_OK;
	POSITION pos;

    IStream* pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

// Save Song GUID
	hr = SaveGUID( pIRiffStream );
	if( FAILED ( hr ) )
	{
		goto ON_ERROR;
	}

// Save selected VirtualSegments
	{
		// Write DMUS_FOURCC_SEGREFS_LIST header
		MMCKINFO ck;
		ck.fccType = DMUS_FOURCC_SEGREFS_LIST;
		if( pIRiffStream->CreateChunk(&ck, MMIO_CREATELIST) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}

		pos = m_lstVirtualSegments.GetHeadPosition();
		while( pos )
		{
			CVirtualSegment* pVirtualSegment = m_lstVirtualSegments.GetNext( pos );

			if( pVirtualSegment->m_dwBitsUI & BF_SELECTED )
			{
				pVirtualSegment->Save( pIRiffStream );
			}
		}

		if( pIRiffStream->Ascend(&ck, 0) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}
	}

ON_ERROR:
    RELEASE( pIStream );
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicSong IPersistStream::Save

HRESULT CDirectMusicSong::Save( IStream* pIStream, BOOL fClearDirty )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( pIStream == NULL )
	{
		return E_INVALIDARG;
	}

	DMUSProdStreamInfo StreamInfo;
	StreamInfo.ftFileType = FT_RUNTIME;
	StreamInfo.guidDataFormat = GUID_CurrentVersion;
	StreamInfo.pITargetDirectoryNode = NULL;

	// Get additional stream information
	IDMUSProdPersistInfo* pPersistInfo;

	if( SUCCEEDED ( pIStream->QueryInterface( IID_IDMUSProdPersistInfo, (void **)&pPersistInfo ) ) )
	{
		pPersistInfo->GetStreamInfo( &StreamInfo );
		RELEASE( pPersistInfo );
	}

    IDMUSProdRIFFStream* pIRiffStream;
    MMCKINFO ckMain;

    HRESULT hr = E_FAIL;

	// Validate requested data format
	if( ::IsEqualGUID( StreamInfo.guidDataFormat, GUID_CurrentVersion )
	||  ::IsEqualGUID( StreamInfo.guidDataFormat, GUID_DirectMusicObject ) )
	{
		// DirectMusic format
		if( SUCCEEDED( AllocRIFFStream( pIStream, &pIRiffStream ) ) )
		{
			ckMain.fccType = DMUS_FOURCC_SONG_FORM;

			if( pIRiffStream->CreateChunk( &ckMain, MMIO_CREATERIFF ) == 0
			&&  SUCCEEDED( SaveSong( pIRiffStream, fClearDirty ) )
			&&  pIRiffStream->Ascend( &ckMain, 0 ) == 0 )
			{
				if( fClearDirty )
				{
					SetModified( FALSE );
				}

				hr = S_OK;
			}
			RELEASE( pIRiffStream );
		}
	}
	else if( ::IsEqualGUID( StreamInfo.guidDataFormat, GUID_SaveSelectedVirtualSegments ) )
	{
		// Copy/Paste (Save selected virtual segments)
		// Do not reset dirty flag
		if( SUCCEEDED( AllocRIFFStream( pIStream, &pIRiffStream ) ) )
		{
			ckMain.fccType = DMUS_FOURCC_SONG_FORM;

			if( pIRiffStream->CreateChunk( &ckMain, MMIO_CREATERIFF ) == 0
			&&  SUCCEEDED( SaveSelectedVirtualSegments( pIRiffStream ) )
			&&  pIRiffStream->Ascend( &ckMain, 0 ) == 0 )
			{
				hr = S_OK;
			}
			RELEASE( pIRiffStream );
		}
	}

    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicSong IPersistStream::GetSizeMax

HRESULT CDirectMusicSong::GetSizeMax( ULARGE_INTEGER FAR* /*pcbSize*/ )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);

    return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicSong IDMUSProdNotifySink implementation

///////////////////////////////////////////////////////////////////////////
// CDirectMusicSong  IDMUSProdNotifySink::OnUpdate

HRESULT CDirectMusicSong::OnUpdate( IDMUSProdNode* pIDocRootNode, GUID guidUpdateType, VOID* pData )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( pIDocRootNode == m_pIContainerNode )
	{
		// CONTAINER_ChangeNotification
		if( ::IsEqualGUID(guidUpdateType, CONTAINER_ChangeNotification ) )
		{
			SetModified( TRUE );
			// No need to sync segment with DMusic
			// because containers do not affect performance
			return S_OK;
		}

		// CONTAINER_FileLoadFinished
		if( ::IsEqualGUID(guidUpdateType, CONTAINER_FileLoadFinished ) )
		{
			// No need to sync segment with DMusic
			// because containers do not affect performance
			return S_OK;
		}
	}
	else if( pIDocRootNode == m_pIAudioPathNode )
	{
		// AUDIOPATH_DirtyNotification
		if( ::IsEqualGUID(guidUpdateType, AUDIOPATH_DirtyNotification ) )
		{
			// Sync changes
			SetModified( TRUE );
			SyncChanges( SC_DIRECTMUSIC, 0, NULL );
			return S_OK;
		}
	}
	else if( pIDocRootNode == this )
	{
		// FRAMEWORK_FileNameChange
		if( ::IsEqualGUID( guidUpdateType, FRAMEWORK_FileNameChange ) )
		{
			UpdateTransportName();
			return S_OK;
		}

		// FRAMEWORK_AfterFileSave
		if( ::IsEqualGUID( guidUpdateType, FRAMEWORK_AfterFileSave ) )
		{
			UpdateTransportName();
			return S_OK;
		}
	}

	// Check SourceSegments folder
	m_FolderSegments.OnUpdate( pIDocRootNode, guidUpdateType, pData );

	// Check ToolGraphs folder
	m_FolderToolGraphs.OnUpdate( pIDocRootNode, guidUpdateType, pData );

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicSong Additional functions

/////////////////////////////////////////////////////////////////////////////
// CDirectMusicSong::ReadListInfoFromStream

HRESULT CDirectMusicSong::ReadListInfoFromStream( IStream* pIStream, DMUSProdListInfo* pListInfo )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    IDMUSProdRIFFStream* pIRiffStream;
    MMCKINFO ckMain;
	MMCKINFO ck;
	DWORD dwSize;
	DWORD dwByteCount;
	CString strName;
	CString strDescriptor;
	GUID guidSong;

	ASSERT( pIStream != NULL );
    ASSERT( pListInfo != NULL );

	if( pIStream == NULL
	||  pListInfo == NULL )
	{
		return E_INVALIDARG;
	}

	memset( &guidSong, 0, sizeof(GUID) );

    DWORD dwPos = StreamTell( pIStream );

	// Check for Direct Music format
	BOOL fFoundFormat = FALSE;
	if( SUCCEEDED( AllocRIFFStream( pIStream, &pIRiffStream ) ) )
	{
		ckMain.fccType = DMUS_FOURCC_SONG_FORM;

		if( pIRiffStream->Descend( &ckMain, NULL, MMIO_FINDRIFF ) == 0 )
		{
			fFoundFormat = TRUE;

			// Get Song GUID
			ck.ckid = DMUS_FOURCC_GUID_CHUNK;

			if( pIRiffStream->Descend( &ck, &ckMain, MMIO_FINDCHUNK ) == 0 )
			{
				dwSize = min( ck.cksize, sizeof( GUID ) );
				if( FAILED ( pIStream->Read( &guidSong, dwSize, &dwByteCount ) )
				||  dwByteCount != dwSize )
				{
					memset( &guidSong, 0, sizeof(GUID) );
				}
			}

			// Get Song name
			ck.fccType = DMUS_FOURCC_UNFO_LIST;

			if( pIRiffStream->Descend( &ck, &ckMain, MMIO_FINDLIST ) == 0 )
			{
				ck.ckid = DMUS_FOURCC_UNAM_CHUNK;
				if( pIRiffStream->Descend( &ck, &ckMain, MMIO_FINDCHUNK ) == 0 )
				{
					ReadMBSfromWCS( pIStream, ck.cksize, &strName );
				}
			}
		}

		RELEASE( pIRiffStream );
	}

	if( !strName.IsEmpty() )
	{
		pListInfo->bstrName = strName.AllocSysString();
		pListInfo->bstrDescriptor = strDescriptor.AllocSysString();
		memcpy( &pListInfo->guidObject, &guidSong, sizeof(GUID) );

		// Must check pListInfo->wSize before populating additional fields
		return S_OK;
	}

	return E_FAIL;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicSong::GetObjectDescriptor

HRESULT CDirectMusicSong::GetObjectDescriptor( void* pObjectDesc )
{
	// Make sure method was passed a valid DMUS_OBJECTDESC pointer
	if( pObjectDesc == NULL ) 
	{
		ASSERT( FALSE );
		return E_POINTER;
	}

	DMUS_OBJECTDESC *pDMObjectDesc = (DMUS_OBJECTDESC *)pObjectDesc;

	if( pDMObjectDesc->dwSize == 0 ) 
	{
		ASSERT( FALSE );
		return E_INVALIDARG;
	}

	// Initialize DMUS_OBJECTDESC structure
	DWORD dwOrigSize = pDMObjectDesc->dwSize;
	memset( pDMObjectDesc, 0, dwOrigSize );
	pDMObjectDesc->dwSize = dwOrigSize;

	// Set values in DMUS_OBJECTDESC structure
	pDMObjectDesc->dwValidData = (DMUS_OBJ_OBJECT | DMUS_OBJ_CLASS | DMUS_OBJ_VERSION | DMUS_OBJ_NAME );
	
	memcpy( &pDMObjectDesc->guidObject, &m_guidSong, sizeof(GUID) );
	memcpy( &pDMObjectDesc->guidClass, &CLSID_DirectMusicSong, sizeof(CLSID) );
	pDMObjectDesc->vVersion.dwVersionMS = m_vVersion.dwVersionMS;
	pDMObjectDesc->vVersion.dwVersionLS = m_vVersion.dwVersionLS;
	MultiByteToWideChar( CP_ACP, 0, m_strName, -1, pDMObjectDesc->wszName, DMUS_MAX_NAME );

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicSong IDMUSProdSortNode implementation

/////////////////////////////////////////////////////////////////////////////
// IDMUSProdSortNode::CompareNodes

HRESULT CDirectMusicSong::CompareNodes( IDMUSProdNode* pINode1, IDMUSProdNode* pINode2, int* pnResult )
{
	ASSERT(pINode1);
	ASSERT(pINode2);
	
	if( pINode1 == NULL
	||  pINode2 == NULL )
	{
		return E_INVALIDARG;
	}

	if( pnResult == NULL )
	{
		return E_POINTER;
	}
	*pnResult = 0;

	GUID guidNodeId1;
	pINode1->GetNodeId( &guidNodeId1 );

	GUID guidNodeId2;
	pINode2->GetNodeId( &guidNodeId2 );

	if( ::IsEqualGUID(guidNodeId1, GUID_Song_SegmentsFolderNode) )
	{
		// Source Segment folder always first
		*pnResult = -1;
	}
	else if( ::IsEqualGUID(guidNodeId1, GUID_Song_ToolGraphsFolderNode) )
	{
		if( ::IsEqualGUID(guidNodeId2, GUID_ContainerNode) 
		||  ::IsEqualGUID(guidNodeId2, GUID_AudioPathNode) )
		{
			*pnResult = -1;
		}
		else
		{
			*pnResult = 1;
		}
	}
	else if( ::IsEqualGUID(guidNodeId1, GUID_ContainerNode) )
	{
		if( ::IsEqualGUID(guidNodeId2, GUID_AudioPathNode) )
		{
			*pnResult = -1;
		}
		else
		{
			*pnResult = 1;
		}
	}
	else if( ::IsEqualGUID(guidNodeId1, GUID_AudioPathNode) )
	{
		// AudioPath always last
		*pnResult = 1;
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicSong::PasteCF_CONTAINER

HRESULT CDirectMusicSong::PasteCF_CONTAINER( CDllJazzDataObject* pDataObject, IDataObject* pIDataObject )
{
	IStream* pIStream;
	HRESULT hr = E_FAIL;

	if( SUCCEEDED (	pDataObject->AttemptRead( pIDataObject, theApp.m_pSongComponent->m_cfContainer, &pIStream ) ) )
	{
		LARGE_INTEGER liTemp;

		// Seek to beginning of stream
		liTemp.QuadPart = 0;
		pIStream->Seek( liTemp, STREAM_SEEK_SET, NULL );

		// Create and load a new Container
		IDMUSProdRIFFExt* pIRIFFExt;
		IDMUSProdNode* pINode;

		if( SUCCEEDED ( theApp.m_pSongComponent->m_pIContainerComponent->QueryInterface( IID_IDMUSProdRIFFExt, (void**)&pIRIFFExt ) ) )
		{
			hr = pIRIFFExt->LoadRIFFChunk( pIStream, &pINode );
			if( SUCCEEDED ( hr ) )
			{
				InsertChildNode( pINode );
				RELEASE( pINode );
			}

			RELEASE( pIRIFFExt );
		}

		RELEASE( pIStream );
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicSong::PasteCF_AUDIOPATH

HRESULT CDirectMusicSong::PasteCF_AUDIOPATH( CDllJazzDataObject* pDataObject, IDataObject* pIDataObject )
{
	IStream* pIStream;
	HRESULT hr = E_FAIL;

	if( SUCCEEDED (	pDataObject->AttemptRead( pIDataObject, theApp.m_pSongComponent->m_cfAudioPath, &pIStream ) ) )
	{
		LARGE_INTEGER liTemp;

		// Seek to beginning of stream
		liTemp.QuadPart = 0;
		pIStream->Seek( liTemp, STREAM_SEEK_SET, NULL );

		// Create and load a new AudioPath
		IDMUSProdRIFFExt* pIRIFFExt;
		IDMUSProdNode* pINode;

		if( SUCCEEDED ( theApp.m_pSongComponent->m_pIAudioPathComponent->QueryInterface( IID_IDMUSProdRIFFExt, (void**)&pIRIFFExt ) ) )
		{
			hr = pIRIFFExt->LoadRIFFChunk( pIStream, &pINode );
			if( SUCCEEDED ( hr ) )
			{
				InsertChildNode( pINode );
				RELEASE( pINode );
			}

			RELEASE( pIRIFFExt );
		}

		RELEASE( pIStream );
	}

	return hr;
}


///////////////////////////////////////////////////////////////////////////
// CDirectMusicSong::EmptyVirtualSegmentList

void CDirectMusicSong::EmptyVirtualSegmentList( void )
{
	CVirtualSegment* pVirtualSegment;

	while( !m_lstVirtualSegments.IsEmpty() )
	{
		pVirtualSegment = m_lstVirtualSegments.GetHead();

		RemoveVirtualSegment( pVirtualSegment );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicSong::InsertVirtualSegment

void CDirectMusicSong::InsertVirtualSegment( CVirtualSegment* pVirtualSegmentToInsert, int nIndex )
{
	if( pVirtualSegmentToInsert == NULL )
	{
		ASSERT( FALSE );
		return;
	}

	// Make sure the VirtualSegment has a unique name
	GetUniqueVirtualSegmentName( pVirtualSegmentToInsert );

	pVirtualSegmentToInsert->AddRef();

	// Place VirtualSegment in m_lstVirtualSegments
	POSITION pos = m_lstVirtualSegments.FindIndex( nIndex );
	if( pos )
	{
		m_lstVirtualSegments.InsertBefore( pos, pVirtualSegmentToInsert );
		return;
	}

	m_lstVirtualSegments.AddTail( pVirtualSegmentToInsert );
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicSong::RemoveVirtualSegment

void CDirectMusicSong::RemoveVirtualSegment( CVirtualSegment* pVirtualSegmentToRemove )
{
	if( pVirtualSegmentToRemove == NULL )
	{
		ASSERT( FALSE );
		return;
	}

	// Make sure other VirtualSegments do not point to pVirtualSegmentToRemove
	POSITION pos = m_lstVirtualSegments.GetHeadPosition();
	while( pos )
	{
		CVirtualSegment* pVirtualSegment = m_lstVirtualSegments.GetNext( pos );

		pVirtualSegment->RemoveVirtualSegmentReferences( pVirtualSegmentToRemove );
	}

	// If item is in m_lstVirtualSegments, remove it
	pos = m_lstVirtualSegments.Find( pVirtualSegmentToRemove );
	if( pos )
	{
		m_lstVirtualSegments.RemoveAt( pos );

		RELEASE( pVirtualSegmentToRemove );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicSong::RemoveToolGraphReferences

void CDirectMusicSong::RemoveToolGraphReferences( IDMUSProdNode* pIToolGraphNodeToRemove )
{
	if( pIToolGraphNodeToRemove == NULL )
	{
		ASSERT( FALSE );
		return;
	}

	// Make sure other VirtualSegments do not point to pIToolGraphNodeToRemove
	POSITION pos = m_lstVirtualSegments.GetHeadPosition();
	while( pos )
	{
		CVirtualSegment* pVirtualSegment = m_lstVirtualSegments.GetNext( pos );
		
		pVirtualSegment->RemoveToolGraphReferences( pIToolGraphNodeToRemove );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicSong::RemoveSourceSegmentReferences

void CDirectMusicSong::RemoveSourceSegmentReferences( CSourceSegment* pSourceSegmentToRemove )
{
	if( pSourceSegmentToRemove == NULL )
	{
		ASSERT( FALSE );
		return;
	}

	// Make sure other VirtualSegments do not point to pSourceSegmentToRemove
	POSITION pos = m_lstVirtualSegments.GetHeadPosition();
	while( pos )
	{
		CVirtualSegment* pVirtualSegment = m_lstVirtualSegments.GetNext( pos );

		pVirtualSegment->RemoveSourceSegmentReferences( pSourceSegmentToRemove );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicSong::GetSegmentEmbedFolder
	
CFolder* CDirectMusicSong::GetSegmentEmbedFolder( void )
{
	return &m_FolderSegments.m_FolderEmbed;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicSong::GetSegmentRefFolder

CFolder* CDirectMusicSong::GetSegmentRefFolder( void )
{
	return &m_FolderSegments.m_FolderReference;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicSong::IsSourceSegmentInSong

BOOL CDirectMusicSong::IsSourceSegmentInSong( IDMUSProdNode* pIDocRootNode )
{
	if( m_FolderSegments.m_FolderEmbed.IsDocRootInFolder( pIDocRootNode )
	||  m_FolderSegments.m_FolderReference.IsDocRootInFolder( pIDocRootNode ) )
	{
		return TRUE;
	}

	return FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicSong::GetSourceSegmentFromDocRoot

CSourceSegment* CDirectMusicSong::GetSourceSegmentFromDocRoot( IDMUSProdNode* pIDocRootNode )
{
	CSourceSegment* pTheSourceSegment = NULL;

	pTheSourceSegment = m_FolderSegments.m_FolderEmbed.GetSourceSegmentFromDocRoot( pIDocRootNode );
	if( pTheSourceSegment == NULL )
	{
		pTheSourceSegment = m_FolderSegments.m_FolderReference.GetSourceSegmentFromDocRoot( pIDocRootNode );
	}

	return pTheSourceSegment;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicSong::IsVirtualSegmentNameUnique

BOOL CDirectMusicSong::IsVirtualSegmentNameUnique( CVirtualSegment* pVirtualSegment )
{
	CString strNameList;
	CString strName;
	pVirtualSegment->GetName( strName );

	POSITION pos = m_lstVirtualSegments.GetHeadPosition();
	while( pos )
	{
		CVirtualSegment* pVirtualSegmentList = m_lstVirtualSegments.GetNext( pos );
		if( pVirtualSegmentList != pVirtualSegment )
		{
			pVirtualSegmentList->GetName( strNameList );

			if( strNameList.CompareNoCase( strName ) == 0 )
			{
				return FALSE;
			}
		}
	}

	return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicSong::GetUniqueVirtualSegmentName

void CDirectMusicSong::GetUniqueVirtualSegmentName( CVirtualSegment* pVirtualSegment )
{
	CString	strOrigName;
	int	nOrigRootLength;
	int	nPrefixSuffixLength;

	CString strName;
	pVirtualSegment->GetName( strName );

	if( strName.IsEmpty() )
	{
		strName.LoadString( IDS_V_EMPTY_TEXT );
	}
	ASSERT( strName.IsEmpty() == FALSE );

	if( strName.GetLength() > DMUS_MAX_NAME )
	{
		strName = strName.Left( DMUS_MAX_NAME );
		strName.TrimRight();
	}

	strOrigName = strName;

	// Determine prefix - root name - suffix
	CString strPrefix;
	CString strRootName;
	CString strSuffix;
	{
		strRootName = strOrigName;

		// Prefix
		strPrefix.LoadString( IDS_VIRTUAL_SEGMENT_PREFIX_TEXT ); 
		int nFindPos = strRootName.Find( strPrefix );
		if( nFindPos == 0 )
		{
			strRootName = strRootName.Right( strRootName.GetLength() - strPrefix.GetLength() );
		}
		else
		{
			strPrefix.Empty();
		}

		// Root name
		CString strSourceSegmentName;
		pVirtualSegment->GetSourceSegmentName( strSourceSegmentName );
		if( strSourceSegmentName.IsEmpty() )
		{
			strSourceSegmentName.LoadString( IDS_EMPTY_TEXT );
		}
		nFindPos = strRootName.Find( strSourceSegmentName );
		if( nFindPos == 0 )
		{
			strSuffix = strRootName.Right( strRootName.GetLength() - strSourceSegmentName.GetLength() );
			strRootName = strSourceSegmentName;
		}
		else
		{
			nFindPos = strRootName.ReverseFind( (TCHAR)'_' );
			if( nFindPos != -1 )
			{
				strSuffix = strRootName.Right( strRootName.GetLength() - nFindPos );
				strRootName = strRootName.Left( nFindPos );
			}
		}

		// Suffix
		nFindPos = strSuffix.ReverseFind( (TCHAR)'_' );
		if( nFindPos == -1 )
		{
			strRootName += strSuffix;
			strSuffix.Empty();
		}
		else if( nFindPos > 0 )
		{
			strRootName += strSuffix.Left( nFindPos );
			strSuffix = strSuffix.Right( strSuffix.GetLength() - nFindPos );
		}
	}

	nOrigRootLength = strRootName.GetLength();

	while( IsVirtualSegmentNameUnique( pVirtualSegment ) == FALSE )
	{
		// Name is not unique
		if( strSuffix.IsEmpty() ) 
		{
			strSuffix  = (TCHAR)'_';
			strSuffix += (TCHAR)'a';
		}
		else
		{
			ASSERT( strSuffix[0] == (TCHAR)'_' );

			// Increment the existing suffix
			for( int i = (strSuffix.GetLength() - 1) ;  i >= 0 ;  i-- )
			{
				if( i == 0 )
				{
					strSuffix += (TCHAR) 'a';
					break;
				}

				char ch = strSuffix[i];
				ch += 1;

				if( _istalpha(ch) )
				{
					strSuffix.SetAt( i, ch );
					break;
				}

				strSuffix.SetAt( i, (TCHAR)'a' );
			}
		}

		// Set the new name
		nPrefixSuffixLength = strPrefix.GetLength() + strSuffix.GetLength();
		if( (nOrigRootLength + nPrefixSuffixLength) <= DMUS_MAX_NAME )
		{
			pVirtualSegment->SetName( strPrefix + strRootName + strSuffix );
		}
		else
		{
			pVirtualSegment->SetName( strPrefix + strRootName.Left(DMUS_MAX_NAME - nPrefixSuffixLength) + strSuffix );
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicSong::GUIDToVirtualSegment

CVirtualSegment* CDirectMusicSong::GUIDToVirtualSegment( GUID guidVirtualSegment )
{
	CVirtualSegment* pTheVirtualSegment = NULL;

	POSITION pos = m_lstVirtualSegments.GetHeadPosition();
	while( pos )
	{
		CVirtualSegment* pVirtualSegment = m_lstVirtualSegments.GetNext( pos );

		if( ::IsEqualGUID( pVirtualSegment->m_VirtualSegmentUI.guidVirtualSegment, guidVirtualSegment ) )
		{
			pTheVirtualSegment = pVirtualSegment;
			break;
		}
	}

	return pTheVirtualSegment;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicSong::IndexToVirtualSegment

CVirtualSegment* CDirectMusicSong::IndexToVirtualSegment( int nVirtualSegmentIndex )
{
	CVirtualSegment* pTheVirtualSegment = NULL;

	int nNbrVirtualSegments = m_lstVirtualSegments.GetCount();

	if( nVirtualSegmentIndex >= 0
	&&  nVirtualSegmentIndex < nNbrVirtualSegments )
	{
		POSITION pos = m_lstVirtualSegments.FindIndex( nVirtualSegmentIndex );
		if( pos )
		{
			pTheVirtualSegment = m_lstVirtualSegments.GetAt( pos );
		}
	}

	return pTheVirtualSegment;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicSong::FindVirtualSegmentByName

CVirtualSegment* CDirectMusicSong::FindVirtualSegmentByName( LPCTSTR pszName )
{
	CVirtualSegment* pTheVirtualSegment = NULL;
	CString strNameList;

	POSITION pos = m_lstVirtualSegments.GetHeadPosition();
	while( pos )
	{
		CVirtualSegment* pVirtualSegmentList = m_lstVirtualSegments.GetNext( pos );

		pVirtualSegmentList->GetName( strNameList );

		if( strNameList.CompareNoCase( pszName ) == 0 )
		{
			pTheVirtualSegment = pVirtualSegmentList;
			break;
		}
	}

	return pTheVirtualSegment;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicSong::PtrToVirtualSegment

CVirtualSegment* CDirectMusicSong::PtrToVirtualSegment( CVirtualSegment* pVirtualSegment )
{
	CVirtualSegment* pTheVirtualSegment = NULL;

	POSITION pos = m_lstVirtualSegments.GetHeadPosition();
	while( pos )
	{
		CVirtualSegment* pVirtualSegmentList = m_lstVirtualSegments.GetNext( pos );

		if( pVirtualSegmentList == pVirtualSegment )
		{
			pTheVirtualSegment = pVirtualSegmentList;
			break;
		}
	}

	return pTheVirtualSegment;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicSong::RecomputeVirtualSegmentLengths

void CDirectMusicSong::RecomputeVirtualSegmentLengths( void )
{
	BOOL fChanged = FALSE;

	POSITION pos = m_lstVirtualSegments.GetHeadPosition();
	while( pos )
	{
		CVirtualSegment* pVirtualSegment = m_lstVirtualSegments.GetNext( pos );

		fChanged |= pVirtualSegment->RecomputeLength();
	}

	if( fChanged )
	{
		SyncChanges( SC_PROPERTIES | SC_DIRECTMUSIC,
		 			 0,
					 NULL );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicSong::VirtualSegmentToIndex

int CDirectMusicSong::VirtualSegmentToIndex( CVirtualSegment* pVirtualSegment )
{
	int nTheIndex = 0;

	if( pVirtualSegment )
	{
		int nIndex = 0;

		POSITION pos = m_lstVirtualSegments.GetHeadPosition();
		while( pos )
		{
			CVirtualSegment* pVirtualSegmentList = m_lstVirtualSegments.GetNext( pos );

			if( pVirtualSegmentList == pVirtualSegment )
			{
				nTheIndex = nIndex;
				break;
			}

			nIndex++;
		}

	}

	return nTheIndex;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicSong::IndexToSourceSegment

CSourceSegment* CDirectMusicSong::IndexToSourceSegment( int nSourceSegmentIndex )
{
	CSourceSegment* pTheSourceSegment = NULL;

	int nNbrSourceSegments = m_FolderSegments.m_FolderEmbed.m_lstSegments.GetCount();

	if( nSourceSegmentIndex >= 0
	&&  nSourceSegmentIndex < nNbrSourceSegments )
	{
		POSITION pos = m_FolderSegments.m_FolderEmbed.m_lstSegments.FindIndex( nSourceSegmentIndex );
		if( pos )
		{
			pTheSourceSegment = m_FolderSegments.m_FolderEmbed.m_lstSegments.GetAt( pos );
		}
	}
	else
	{
		nSourceSegmentIndex -= nNbrSourceSegments;

		nNbrSourceSegments = m_FolderSegments.m_FolderReference.m_lstSegments.GetCount();

		if( nSourceSegmentIndex >= 0
		&&  nSourceSegmentIndex < nNbrSourceSegments )
		{
			POSITION pos = m_FolderSegments.m_FolderReference.m_lstSegments.FindIndex( nSourceSegmentIndex );
			if( pos )
			{
				pTheSourceSegment = m_FolderSegments.m_FolderReference.m_lstSegments.GetAt( pos );
			}
		}
	}

	return pTheSourceSegment;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicSong::SourceSegmentToIndex

int CDirectMusicSong::SourceSegmentToIndex( CSourceSegment* pSourceSegment )
{
	int nTheIndex = -1;

	if( pSourceSegment )
	{
		int nIndex = 0;

		POSITION pos = m_FolderSegments.m_FolderEmbed.m_lstSegments.GetHeadPosition();
		while( pos )
		{
			CSourceSegment* pSourceSegmentList = m_FolderSegments.m_FolderEmbed.m_lstSegments.GetNext( pos );

			if( pSourceSegmentList == pSourceSegment )
			{
				nTheIndex = nIndex;
				break;
			}

			nIndex++;
		}

		if( nTheIndex == -1 )
		{
			POSITION pos = m_FolderSegments.m_FolderReference.m_lstSegments.GetHeadPosition();
			while( pos )
			{
				CSourceSegment* pSourceSegmentList = m_FolderSegments.m_FolderReference.m_lstSegments.GetNext( pos );

				if( pSourceSegmentList == pSourceSegment )
				{
					nTheIndex = nIndex;
					break;
				}

				nIndex++;
			}
		}
	}

	return nTheIndex;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicSong::PtrToSourceSegment

CSourceSegment* CDirectMusicSong::PtrToSourceSegment( CSourceSegment* pSourceSegment )
{
	CSourceSegment* pTheSourceSegment = NULL;

	POSITION pos = m_FolderSegments.m_FolderEmbed.m_lstSegments.GetHeadPosition();
	while( pos )
	{
		CSourceSegment* pSourceSegmentList = m_FolderSegments.m_FolderEmbed.m_lstSegments.GetNext( pos );

		if( pSourceSegmentList == pSourceSegment )
		{
			pTheSourceSegment = pSourceSegmentList;
			break;
		}
	}

	if( pTheSourceSegment == NULL )
	{
		POSITION pos = m_FolderSegments.m_FolderReference.m_lstSegments.GetHeadPosition();
		while( pos )
		{
			CSourceSegment* pSourceSegmentList = m_FolderSegments.m_FolderReference.m_lstSegments.GetNext( pos );

			if( pSourceSegmentList == pSourceSegment )
			{
				pTheSourceSegment = pSourceSegmentList;
				break;
			}
		}
	}

	return pTheSourceSegment;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicSong::IndexToToolGraph

IDMUSProdNode* CDirectMusicSong::IndexToToolGraph( int nToolGraphIndex )
{
	IDMUSProdNode* pITheToolGraphNode = NULL;

	int nNbrToolGraphs = m_FolderToolGraphs.m_lstToolGraphs.GetCount();

	if( nToolGraphIndex >= 0
	&&  nToolGraphIndex < nNbrToolGraphs )
	{
		POSITION pos = m_FolderToolGraphs.m_lstToolGraphs.FindIndex( nToolGraphIndex );
		if( pos )
		{
			pITheToolGraphNode = m_FolderToolGraphs.m_lstToolGraphs.GetAt( pos );
		}
	}

	return pITheToolGraphNode;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicSong::ToolGraphToIndex

int CDirectMusicSong::ToolGraphToIndex( IDMUSProdNode* pIToolGraphNode )
{
	int nTheIndex = 0;

	if( pIToolGraphNode )
	{
		int nIndex = 0;

		POSITION pos = m_FolderToolGraphs.m_lstToolGraphs.GetHeadPosition();
		while( pos )
		{
			IDMUSProdNode* pIToolGraphNodelist = m_FolderToolGraphs.m_lstToolGraphs.GetNext( pos );

			if( pIToolGraphNodelist == pIToolGraphNode )
			{
				nTheIndex = nIndex;
				break;
			}

			nIndex++;
		}

	}

	return nTheIndex;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicSong::PtrToToolGraph

IDMUSProdNode* CDirectMusicSong::PtrToToolGraph( IDMUSProdNode* pIToolGraphNode )
{
	IDMUSProdNode* pITheToolGraphNode = NULL;

	POSITION pos = m_FolderToolGraphs.m_lstToolGraphs.GetHeadPosition();
	while( pos )
	{
		IDMUSProdNode* pIToolGraphNodeList = m_FolderToolGraphs.m_lstToolGraphs.GetNext( pos );

		if( pIToolGraphNodeList == pIToolGraphNode )
		{
			pITheToolGraphNode = pIToolGraphNodeList;
			break;
		}
	}

	return pITheToolGraphNode;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicSong::ResolveVirtualSegmentIDs

void CDirectMusicSong::ResolveVirtualSegmentIDs( void )
{
	POSITION pos = m_lstVirtualSegments.GetHeadPosition();
	while( pos )
	{
		CVirtualSegment* pVirtualSegment = m_lstVirtualSegments.GetNext( pos );

		pVirtualSegment->ResolveVirtualSegmentIDs();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicSong::RegisterWithTransport

HRESULT CDirectMusicSong::RegisterWithTransport( void )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( theApp.m_pSongComponent != NULL );
	ASSERT( theApp.m_pSongComponent->m_pIConductor != NULL );

	// Register Song with Conductor's Secondary Transport
	if( FAILED ( theApp.m_pSongComponent->m_pIConductor->RegisterSecondaryTransport( this ) ) )
	{
		return E_FAIL;
	}

	// Register Song with Conductor's Transport and notification system
	if( SUCCEEDED ( theApp.m_pSongComponent->m_pIConductor->RegisterTransport( this, BS_AUTO_UPDATE ) )
	&&  SUCCEEDED ( theApp.m_pSongComponent->m_pIConductor->RegisterNotify( this, GUID_NOTIFICATION_SEGMENT ) ) )
	{
		SetActiveTransport();
		return S_OK;
	}

	return E_FAIL;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicSong::UnRegisterWithTransport

HRESULT CDirectMusicSong::UnRegisterWithTransport( void )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( theApp.m_pSongComponent != NULL );
	ASSERT( theApp.m_pSongComponent->m_pIConductor != NULL );

	// Make sure Song is not playing
	Stop( TRUE );
	theApp.m_pSongComponent->m_pIConductor->TransportStopped( (IDMUSProdTransport*)this );

	// Unregister Song from Conductor's Secondary Transport's Play, Stop functionality.
	theApp.m_pSongComponent->m_pIConductor->UnRegisterSecondaryTransport( this );

	// Unregister Song from Conductor's Transport and notification system
	theApp.m_pSongComponent->m_pIConductor->UnRegisterTransport( this );
	theApp.m_pSongComponent->m_pIConductor->UnregisterNotify( this, GUID_NOTIFICATION_SEGMENT );

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicSong::SetActiveTransport

HRESULT CDirectMusicSong::SetActiveTransport( void )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( theApp.m_pSongComponent == NULL
	||  theApp.m_pSongComponent->m_pIConductor == NULL )
	{
		ASSERT( 0 );
		return E_UNEXPECTED;
	}

	theApp.m_pSongComponent->m_pIConductor->SetActiveTransport( (IDMUSProdTransport *)this, BS_AUTO_UPDATE );

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicSong::UpdateTransportName

HRESULT CDirectMusicSong::UpdateTransportName( void )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( theApp.m_pSongComponent == NULL
	||  theApp.m_pSongComponent->m_pIConductor == NULL )
	{
		ASSERT( 0 );
		return E_UNEXPECTED;
	}

	BSTR bstrTransportName;
	if( SUCCEEDED ( GetName( &bstrTransportName ) ) )
	{
		theApp.m_pSongComponent->m_pIConductor->SetTransportName( (IDMUSProdTransport *)this, bstrTransportName );
		if( SUCCEEDED ( GetName( &bstrTransportName ) ) )
		{
			theApp.m_pSongComponent->m_pIConductor->SetSecondaryTransportName( (IDMUSProdSecondaryTransport *)this, bstrTransportName );
		}
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicSong::TransitionWithinSong

HRESULT CDirectMusicSong::TransitionWithinSong( void )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pIDMSong == NULL )
	{
		return S_OK;
	}

	if( theApp.m_pSongComponent == NULL 
	||  theApp.m_pSongComponent->m_pIDMPerformance8 == NULL )
	{
		ASSERT( 0 );
		return E_UNEXPECTED;
	}
	
	HRESULT hr = E_FAIL;

	// Determine which VirtualSegment should play
	CVirtualSegment* pVirtualSegment = NULL;
	if( m_pSongCtrl
	&&  m_pSongCtrl->m_pSongDlg )
	{
		pVirtualSegment = m_pSongCtrl->m_pSongDlg->GetFirstSelectedVirtualSegment();
	}

	// Compose the Song
	if( m_pIDMSegmentState == NULL )
	{
		m_pIDMSong->Compose();
	}

	// Initialize states before starting transition
	RELEASE( m_pIDMTransitionSegmentState );

	EnterCriticalSection( &m_csSegmentState );
	RELEASE( m_pIDMSegmentState );
	LeaveCriticalSection( &m_csSegmentState );

	m_rpIDMStoppedSegmentState = NULL;

	// Do transition
	if( pVirtualSegment )
	{
		// Get name of VirtualSegment
		WCHAR awchVirtualSegmentName[DMUS_MAX_NAME+1];
		MultiByteToWideChar( CP_ACP, 0, pVirtualSegment->m_strName, -1, awchVirtualSegmentName, DMUS_MAX_NAME+1 );

		EnterCriticalSection( &m_csSegmentState );
		hr = theApp.m_pSongComponent->m_pIDMPerformance8->PlaySegmentEx( m_pIDMSong,
		  																 awchVirtualSegmentName,
																		 NULL,
																		 DMUS_SEGF_AUTOTRANSITION | pVirtualSegment->m_dwResolution_SEGH,
																		 0,
																		 &m_pIDMSegmentState,
																		 NULL,
																		 NULL );
		LeaveCriticalSection( &m_csSegmentState );
	}
	else
	{
		theApp.m_pSongComponent->m_pIDMPerformance8->StopEx( m_pIDMSong, 0, DMUS_SEGF_AUTOTRANSITION );
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicSong::GetTransitionOptions

DWORD CDirectMusicSong::TransitionOptionsToDMUS_SEGF( ConductorTransitionOptions* pTransitionOptions )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( pTransitionOptions == NULL )
	{
		ASSERT( 0 );
		return 0;
	}

	// Translate options into DMUS_SEGF flags
	DWORD dwOptions = 0;

	// Set the Boundary settings (bar/beat/grid/immediate/end of segment)
	if( pTransitionOptions->dwFlags & TRANS_END_OF_SEGMENT )
	{
		dwOptions = DMUS_SEGF_QUEUE;
	}
	else if( pTransitionOptions->dwBoundaryFlags & DMUS_COMPOSEF_IMMEDIATE )
	{
		dwOptions = 0;
	}
	else if( pTransitionOptions->dwBoundaryFlags & DMUS_COMPOSEF_GRID )
	{
		dwOptions = DMUS_SEGF_GRID;
	}
	else if( pTransitionOptions->dwBoundaryFlags & DMUS_COMPOSEF_BEAT )
	{
		dwOptions = DMUS_SEGF_BEAT;
	}
	else if( pTransitionOptions->dwBoundaryFlags & DMUS_COMPOSEF_MEASURE )
	{
		dwOptions = DMUS_SEGF_MEASURE;
	}
	else if( pTransitionOptions->dwBoundaryFlags & DMUS_COMPOSEF_SEGMENTEND )
	{
		dwOptions = DMUS_SEGF_SEGMENTEND;
	}
	else
	{
		ASSERT( 0 );
		dwOptions = 0;
	}

	// Set alignment flags
	if( pTransitionOptions->dwBoundaryFlags & DMUS_COMPOSEF_ALIGN )
	{
		dwOptions |= DMUS_SEGF_ALIGN;

		if( pTransitionOptions->dwBoundaryFlags & DMUS_COMPOSEF_VALID_START_TICK )
		{
			dwOptions |= DMUS_SEGF_VALID_START_TICK;
		}
		else if( pTransitionOptions->dwBoundaryFlags & DMUS_COMPOSEF_VALID_START_GRID )
		{
			dwOptions |= DMUS_SEGF_VALID_START_GRID;
		}
		else if( pTransitionOptions->dwBoundaryFlags & DMUS_COMPOSEF_VALID_START_BEAT )
		{
			dwOptions |= DMUS_SEGF_VALID_START_BEAT;
		}
	}

	// Set marker flags
	if( pTransitionOptions->dwBoundaryFlags & DMUS_COMPOSEF_MARKER )
	{
		dwOptions |= DMUS_SEGF_MARKER;
	}

	// Additional flags
	dwOptions |= DMUS_SEGF_AFTERPREPARETIME | DMUS_SEGF_NOINVALIDATE;

	return dwOptions;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicSong IDMUSProdTransport implementation

/////////////////////////////////////////////////////////////////////////////
// CDirectMusicSong::Play

HRESULT CDirectMusicSong::Play( BOOL fPlayFromStart )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pIDMSong == NULL )
	{
		return S_OK;
	}

	if( theApp.m_pSongComponent == NULL 
	||  theApp.m_pSongComponent->m_pIDMPerformance8 == NULL )
	{
		ASSERT( 0 );
		return E_UNEXPECTED;
	}

	// If we're already playing, Stop()
	if( m_pIDMSegmentState != NULL )
	{
		Stop( TRUE );
	}

	ASSERT( m_pIDMSegmentState == NULL );
	ASSERT( m_pIDMTransitionSegmentState == NULL );

	// Determine which VirtualSegment should play first
	CVirtualSegment* pVirtualSegment = NULL;
	if( m_pSongCtrl
	&&  m_pSongCtrl->m_pSongDlg )
	{
		if( fPlayFromStart == FALSE )
		{
			pVirtualSegment = m_pSongCtrl->m_pSongDlg->GetFirstSelectedVirtualSegment();
		}
	}
	if( pVirtualSegment == NULL )
	{
		pVirtualSegment = IndexToVirtualSegment( 0 );
	}

	HRESULT hr = E_FAIL;
	
	if( pVirtualSegment )
	{
		// Get name of VirtualSegment
		WCHAR awchVirtualSegmentName[DMUS_MAX_NAME+1];
		MultiByteToWideChar( CP_ACP, 0, pVirtualSegment->m_strName, -1, awchVirtualSegmentName, DMUS_MAX_NAME+1 );

		// Determine PlaySegmentEx parameters pertaining to transitions
		DWORD dwFlags;
		IDirectMusicSegment* pIDMTransitionSegment;
		if( m_fInTransition )
		{
			pIDMTransitionSegment = m_pIDMTransitionSegment;
			dwFlags = m_dwTransitionPlayFlags;
		}
		else
		{
			pIDMTransitionSegment = NULL;
			dwFlags = (DMUS_SEGF_QUEUE | DMUS_SEGF_AFTERPREPARETIME | DMUS_SEGF_NOINVALIDATE);
		}

		// Compose the Song
		m_pIDMSong->Compose();

		// Play the Song
		EnterCriticalSection( &m_csSegmentState );
		hr = theApp.m_pSongComponent->m_pIDMPerformance8->PlaySegmentEx( m_pIDMSong,
		  																 awchVirtualSegmentName,
																		 pIDMTransitionSegment,
																		 dwFlags,
																		 0,
																		 &m_pIDMSegmentState,
																		 NULL,
																		 NULL );
		LeaveCriticalSection( &m_csSegmentState );
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicSong::Stop

HRESULT CDirectMusicSong::Stop( BOOL fStopImmediate )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pIDMSong == NULL )
	{
		return S_OK;
	}

	if( theApp.m_pSongComponent == NULL 
	||  theApp.m_pSongComponent->m_pIDMPerformance8 == NULL )
	{
		ASSERT( 0 );
		return E_UNEXPECTED;
	}

	MUSIC_TIME mtNow;
	REFERENCE_TIME rtNow;
	theApp.m_pSongComponent->m_pIDMPerformance8->GetTime( &rtNow, &mtNow );

	if( m_pIDMSegmentState == NULL
	&&  m_pIDMTransitionSegmentState == NULL )
	{
		if ( FAILED( theApp.m_pSongComponent->m_pIDMPerformance8->StopEx( m_pIDMSong,
																		  0,
																		  fStopImmediate ? 0 : DMUS_SEGF_DEFAULT ) ) )
		{
			return E_FAIL;
		}

//		TRACE("Song: Stop() called when SegmentState is NULL!\n");
//		TRACE("Song: Stopping playback at %ld | %I64d\n", mtNow, rtNow );
		return E_UNEXPECTED;
	}

	MUSIC_TIME mtStartTime = 0;
	bool fStoppedSomething = false;

	// Try and stop the transition segment state, if there is one
	if( m_pIDMTransitionSegmentState )
	{
		m_pIDMTransitionSegmentState->GetStartTime( &mtStartTime );

		if( SUCCEEDED( theApp.m_pSongComponent->m_pIDMPerformance8->Stop( NULL,
																		  m_pIDMTransitionSegmentState,
																		  0, 
																		  fStopImmediate ? 0 : DMUS_SEGF_DEFAULT ) ) )
		{
			fStoppedSomething = true;
		}

		RELEASE( m_pIDMTransitionSegmentState );
	}

	// Now stop the segment state
	EnterCriticalSection( &m_csSegmentState );
	if( m_pIDMSegmentState )
	{
		if( mtStartTime == 0 )
		{
			m_pIDMSegmentState->GetStartTime( &mtStartTime );
		}

		if( SUCCEEDED( theApp.m_pSongComponent->m_pIDMPerformance8->Stop( NULL,
																		  m_pIDMSegmentState,
																		  0, 
																		  fStopImmediate ? 0 : DMUS_SEGF_DEFAULT ) ) )
		{
			fStoppedSomething = true;
		}

		m_rpIDMStoppedSegmentState = m_pIDMSegmentState;
		RELEASE( m_pIDMSegmentState );
	}
	LeaveCriticalSection( &m_csSegmentState );

	if( fStoppedSomething )
	{
		// If we are asked to stop our segment state before it begins playing, return an error code because
		// it probably won't stop whatever is currently playing.
		if( mtNow < mtStartTime )
		{
			return E_UNEXPECTED;
		}
		else
		{
			return S_OK;
		}
	}

	return E_FAIL;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicSong::Transition

HRESULT CDirectMusicSong::Transition( void )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pIDMSong == NULL )
	{
		return S_OK;
	}

	if( theApp.m_pSongComponent == NULL 
	||  theApp.m_pSongComponent->m_pIConductor == NULL 
	||  theApp.m_pSongComponent->m_pIDMPerformance8 == NULL )
	{
		ASSERT( 0 );
		return E_UNEXPECTED;
	}

	HRESULT hr = S_OK;

	// Get transition options from Conductor
	ConductorTransitionOptions TransitionOptions;
	if( FAILED( theApp.m_pSongComponent->m_pIConductor->GetTransitionOptions( &TransitionOptions ) ) )
	{
		return E_NOTIMPL;
	}

	m_dwTransitionPlayFlags = 0;
	if( TransitionOptions.pDMUSProdNodeSegmentTransition )
	{
		IDMUSProdNode *pINode;
		if( SUCCEEDED( TransitionOptions.pDMUSProdNodeSegmentTransition->QueryInterface( IID_IDMUSProdNode, (void **)&pINode ) ) )
		{
			if( SUCCEEDED( pINode->GetObject( CLSID_DirectMusicSegment, IID_IDirectMusicSegment, (void **)&m_pIDMTransitionSegment ) ) )
			{
				m_dwTransitionPlayFlags |= DMUS_SEGF_AUTOTRANSITION;
			}

			RELEASE( pINode );
		}
	}

	RELEASE( m_pIDMTransitionSegmentState );

	EnterCriticalSection( &m_csSegmentState );
	RELEASE( m_pIDMSegmentState );
	LeaveCriticalSection( &m_csSegmentState );

	m_rpIDMStoppedSegmentState = NULL;

	// Play the segment
	m_fInTransition = true;
	m_dwTransitionPlayFlags |= TransitionOptionsToDMUS_SEGF( &TransitionOptions );
	hr = Play( TRUE );
	m_fInTransition = false;
	m_dwTransitionPlayFlags = 0;

	RELEASE( m_pIDMTransitionSegment );
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicSong::Record

HRESULT CDirectMusicSong::Record( BOOL fPressed )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);

	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicSong::GetName

HRESULT CDirectMusicSong::GetName( BSTR* pbstrName )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( theApp.m_pSongComponent != NULL );
	ASSERT( theApp.m_pSongComponent->m_pIFramework8 != NULL );

	if( pbstrName == NULL )
	{
		return E_POINTER;
	}

	// Song file name
	CString strName;
	BSTR bstrSongFileName;

	if( SUCCEEDED ( theApp.m_pSongComponent->m_pIFramework8->GetNodeFileName( this, &bstrSongFileName ) ) )
	{
		// Node is in the Project tree
		strName = bstrSongFileName;
		::SysFreeString( bstrSongFileName );
		int nFindPos = strName.ReverseFind( (TCHAR)'\\' );
		if( nFindPos != -1 )
		{
			strName = strName.Right( strName.GetLength() - nFindPos - 1 );
		}
		strName += _T(": ");
	}
	else
	{
		// Node has not yet been placed in the Project Tree
		// because the Song is still in the process of being loaded
		strName = m_strOrigFileName;
		strName += _T(": ");
	}
	
	// Plus "name"
	strName += m_strName;

    *pbstrName = strName.AllocSysString();

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicSong::TrackCursor

HRESULT CDirectMusicSong::TrackCursor( BOOL fTrackCursor )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);

	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicSong IDMUSProdSecondaryTransport implementation

// CDirectMusicSong::GetSecondaryTransportSegment

HRESULT CDirectMusicSong::GetSecondaryTransportSegment( IUnknown **ppunkSegment )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Validate ppunkSegment
	if( ppunkSegment == NULL )
	{
		return E_POINTER;
	}

	if( m_pIDMSong == NULL )
	{
		return E_FAIL;
	}

	return m_pIDMSong->QueryInterface( IID_IUnknown, (void**)ppunkSegment );
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicSong::GetSecondaryTransportName

HRESULT CDirectMusicSong::GetSecondaryTransportName( BSTR* pbstrName )
{
	return GetName( pbstrName );
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicSong IDMUSProdNotifyCPt implementation

/////////////////////////////////////////////////////////////////////////////
// CDirectMusicSong::OnNotify

HRESULT CDirectMusicSong::OnNotify( ConductorNotifyEvent *pConductorNotifyEvent )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( theApp.m_pSongComponent == NULL 
	||  theApp.m_pSongComponent->m_pIConductor == NULL )
	{
		return E_UNEXPECTED;
	}

	switch( pConductorNotifyEvent->m_dwType )
	{
		case DMUS_PMSGT_NOTIFICATION:
		{
			DMUS_NOTIFICATION_PMSG* pNotifyEvent = (DMUS_NOTIFICATION_PMSG *)pConductorNotifyEvent->m_pbData;

			EnterCriticalSection( &m_csSegmentState );

			// GUID_NOTIFICATION_SEGMENT 
			if( ::IsEqualGUID ( pNotifyEvent->guidNotificationType, GUID_NOTIFICATION_SEGMENT ) )
			{
				switch( pNotifyEvent->dwNotificationOption )
				{
					case DMUS_NOTIFICATION_SEGSTART:
//						TRACE( "\nSEGSTART");
						if( pNotifyEvent->punkUser )
						{
							// Make sure VirtualSegment is highlighted in editor
							IDirectMusicSegmentState *pITempSegmentState;
							if( SUCCEEDED( pNotifyEvent->punkUser->QueryInterface( IID_IDirectMusicSegmentState, (void**)&pITempSegmentState ) ) )
							{
								IDirectMusicSegment *pITempSegment;
								if( SUCCEEDED( pITempSegmentState->GetSegment( &pITempSegment ) ) )
								{
									IDirectMusicObject* pITempObject;
									if( SUCCEEDED ( pITempSegment->QueryInterface( IID_IDirectMusicObject, (void**)&pITempObject ) ) )
									{
										DMUS_OBJECTDESC dmusObjectDesc;
										memset( &dmusObjectDesc, 0, sizeof(DMUS_OBJECTDESC) );
										dmusObjectDesc.dwSize = sizeof(DMUS_OBJECTDESC);

										if( SUCCEEDED ( pITempObject->GetDescriptor( &dmusObjectDesc ) ) )
										{
											if( dmusObjectDesc.dwValidData & DMUS_OBJ_NAME )
											{
												CString strName = dmusObjectDesc.wszName;
												BSTR bstrName = strName.AllocSysString();
												::PostMessage( m_wndNotificationHandler.GetSafeHwnd(), WM_NEXT_VIRTUAL_SEGMENT, 0, (LPARAM)bstrName );
											}
										}
										RELEASE( pITempObject );
									}
									RELEASE( pITempSegment );
								}
								RELEASE( pITempSegmentState );
							}
						}
						break;

					case DMUS_NOTIFICATION_SEGABORT:
					case DMUS_NOTIFICATION_SEGEND:
//						TRACE( "\nSEGEND");
						if( pNotifyEvent->punkUser )
						{
							// Make sure VirtualSegment is not highlighted in editor
							IDirectMusicSegmentState *pITempSegmentState;
							if( SUCCEEDED( pNotifyEvent->punkUser->QueryInterface( IID_IDirectMusicSegmentState, (void**)&pITempSegmentState ) ) )
							{
								IDirectMusicSegment *pITempSegment;
								if( SUCCEEDED( pITempSegmentState->GetSegment( &pITempSegment ) ) )
								{
									IDirectMusicObject* pITempObject;
									if( SUCCEEDED ( pITempSegment->QueryInterface( IID_IDirectMusicObject, (void**)&pITempObject ) ) )
									{
										DMUS_OBJECTDESC dmusObjectDesc;
										memset( &dmusObjectDesc, 0, sizeof(DMUS_OBJECTDESC) );
										dmusObjectDesc.dwSize = sizeof(DMUS_OBJECTDESC);

										if( SUCCEEDED ( pITempObject->GetDescriptor( &dmusObjectDesc ) ) )
										{
											if( dmusObjectDesc.dwValidData & DMUS_OBJ_NAME )
											{
												CString strName = dmusObjectDesc.wszName;
												BSTR bstrName = strName.AllocSysString();
												::PostMessage( m_wndNotificationHandler.GetSafeHwnd(), WM_STOP_VIRTUAL_SEGMENT, 0, (LPARAM)bstrName );
											}
										}
										RELEASE( pITempObject );
									}
									RELEASE( pITempSegment );
								}
								RELEASE( pITempSegmentState );
							}

							if( pNotifyEvent->punkUser == m_pIDMSegmentState
							||  pNotifyEvent->punkUser == m_rpIDMStoppedSegmentState )
							{
								// Notify the Conductor we stopped playing
								theApp.m_pSongComponent->m_pIConductor->TransportStopped( (IDMUSProdTransport*) this );

								RELEASE( m_pIDMSegmentState );
								RELEASE( m_pIDMTransitionSegmentState );

								// Don't need this reference anymore
								m_rpIDMStoppedSegmentState = NULL;
							}
						}
						break;
				}
			}

			LeaveCriticalSection( &m_csSegmentState );
		}
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicSong::GetGUID

void CDirectMusicSong::GetGUID( GUID* pguidSong )
{
	if( pguidSong )
	{
		*pguidSong = m_guidSong;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CDirectMusicSong::SetGUID

void CDirectMusicSong::SetGUID( GUID guidSong )
{
	m_guidSong = guidSong;

	// Sync changes
	SetModified( TRUE );
	SyncChanges( SC_DIRECTMUSIC, 0, NULL );

	// Notify connected nodes that Song GUID has changed
	theApp.m_pSongComponent->m_pIFramework8->NotifyNodes( this, DOCROOT_GuidChange, NULL );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SongDesigner\SongComponent.h ===
#ifndef __SONGCOMPONENT_H__
#define __SONGCOMPONENT_H__

// SongComponent.h : header file
//

#include <afxtempl.h>
#include <Conductor.h>
#include <PrivateUnpackingFiles.h>

class CDirectMusicSong;


#pragma pack(2)

typedef struct RegisteredTrack
{
	RegisteredTrack()
	{
		memset( &clsidTrack, 0, sizeof(CLSID) );
	}

	CLSID				clsidTrack;
	CString				strName;
} RegisteredTrack;

typedef struct RegisteredObject
{
	RegisteredObject()
	{
		memset( &guidNodeId, 0, sizeof(GUID) );
		memset( &guidRefNodeId, 0, sizeof(GUID) );
		memset( &clsidComponent, 0, sizeof(CLSID) );
		memset( &clsidDMObject, 0, sizeof(CLSID) );
		dwRIFFckid = 0;
		dwRIFFfccType = 0;
	}

	GUID    guidNodeId;
	GUID    guidRefNodeId;
	CLSID	clsidComponent;
	CLSID	clsidDMObject;
	CString strObjectType;
	DWORD	dwRIFFckid;
	DWORD	dwRIFFfccType;
} RegisteredObject;

typedef struct EmbeddedFile
{
	EmbeddedFile()
	{
		dwStreamPos = 0;
		memset( &guidDMClass, 0, sizeof(GUID) );
		memset( &guidObject, 0, sizeof(GUID) );
		memset( &guidFile, 0, sizeof(GUID) );
		CoCreateGuid( &guidNotification ); 
		fBeingLoaded = false;
	}

	~EmbeddedFile()
	{
 		IDMUSProdNotifySink* pINotifySink;
		while( !m_lstNotifyWhenLoadFinished.IsEmpty() )
		{
			pINotifySink = static_cast<IDMUSProdNotifySink*>( m_lstNotifyWhenLoadFinished.RemoveHead() );
			RELEASE( pINotifySink );
		}
	}

	DWORD		dwStreamPos;		// Stream position
    GUID        guidDMClass;		// DirectMusic GUID for the class of object
    GUID        guidObject;			// Unique GUID for this object
    CString		strObjectName;		// Name of object

	// Filled in when file is actually loaded
	GUID        guidFile;			// Producer generated GUID
	GUID		guidNotification;	// Used for FRAMEWORK_FileLoadFinished notifications
	bool		fBeingLoaded;		// Indicates file in process of loading
	CTypedPtrList<CPtrList, IDMUSProdNotifySink*> m_lstNotifyWhenLoadFinished;
} EmbeddedFile;

#pragma pack()


////////////////////////////////////////////////////////////////////////////////
class CSongComponent : public IDMUSProdComponent, public IDMUSProdRIFFExt, public IDMUSProdUnpackingFiles
{
public:
    CSongComponent();
	~CSongComponent();

    // IUnknown functions
    HRESULT STDMETHODCALLTYPE QueryInterface( REFIID riid, LPVOID *ppv );
    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();

    // IDMUSProdComponent functions
    HRESULT STDMETHODCALLTYPE Initialize( IDMUSProdFramework* pIFramework, BSTR* pbstrErrMsg );
    HRESULT STDMETHODCALLTYPE CleanUp( void );
    HRESULT STDMETHODCALLTYPE GetName( BSTR* pbstrName );
	HRESULT STDMETHODCALLTYPE AllocReferenceNode( GUID guidRefNodeId, IDMUSProdNode** ppIRefNode );
	HRESULT STDMETHODCALLTYPE OnActivateApp( BOOL fActivate );

    // IDMUSProdRIFFExt functions
    HRESULT STDMETHODCALLTYPE LoadRIFFChunk( IStream* pIStream, IDMUSProdNode** ppINode );

	// IDMUSProdUnpackingFiles functions
    HRESULT STDMETHODCALLTYPE GetDocRootOfEmbeddedFile( IUnknown* pIDocType, BSTR bstrObjectName, IUnknown** ppIDocRootNode );
	HRESULT STDMETHODCALLTYPE AddToNotifyWhenLoadFinished( IUnknown* pIDocType, BSTR bstrObjectName, IUnknown* punkNotifySink, GUID* pguidFile );

    // Additional functions
private:
    HRESULT STDMETHODCALLTYPE AddNodeImageLists();
    HRESULT LoadRegisteredTracks();
	BOOL RegisterClipboardFormats();
	void ReleaseAll();
	BOOL LoadRegisteredObjects();

public:
    HRESULT STDMETHODCALLTYPE GetSongImageIndex( short* pnNbrFirstImage );
    HRESULT STDMETHODCALLTYPE GetSongRefImageIndex( short* pnNbrFirstImage );
    HRESULT STDMETHODCALLTYPE GetFolderImageIndex( short* pnFirstImage );
	void GetRegisteredTrackName( CLSID clsidTrack, CString& strName );

	int DetermineAction( IDMUSProdNode* pIDocRootNode, IStream* pIStream, IDMUSProdNode** ppIDupeDocRootNode );
	IDMUSProdNode* LoadEmbeddedSegment( IStream* pIStream );

	void AddToSongFileList( CDirectMusicSong* pSong );
	void RemoveFromSongFileList( CDirectMusicSong* pSong );

	// RegisteredObject list methods
	RegisteredObject* FindRegisteredObjectByCLSID( CLSID clsidDMObject );
	RegisteredObject* FindRegisteredObjectByRIFFIds( DWORD dwRIFFckid, DWORD dwRIFFfccType );

	// EmbeddedFile list methods
	HRESULT CreateEmbeddedFileList( IStream* pIStream );
	void ReleaseEmbeddedFileList();
	HRESULT ParseSongForEmbeddedSegments( IDMUSProdRIFFStream* pIRiffStream, MMCKINFO* pckMain );
	HRESULT ParseContainerForEmbeddedSongs( IDMUSProdRIFFStream* pIRiffStream, MMCKINFO* pckMain );
	HRESULT AddEmbeddedFileListItem( IDMUSProdRIFFStream* pIRiffStream, MMCKINFO* pckMain );
	EmbeddedFile* FindEmbeddedFile( IDMUSProdDocType* pIDocType, CString& strObjectName );

public:
	IDMUSProdFramework8*		m_pIFramework8;
	IDirectMusicPerformance8*	m_pIDMPerformance8;
	IDMUSProdConductor*			m_pIConductor;
	IDMUSProdComponent*			m_pISegmentComponent;
	IDMUSProdComponent*			m_pIContainerComponent;
	IDMUSProdComponent*			m_pIAudioPathComponent;
	IDMUSProdComponent*			m_pIToolGraphComponent;

	short						m_nNextSong;			// appended to name of new Song
	UINT						m_cfProducerFile;		//CF_DMUSPROD_FILE clipboard format
	UINT						m_cfSong;				// CF_SONG clipboard format
	UINT						m_cfSongList;			// CF_SONGLIST clipboard format
	UINT						m_cfSegment;			// CF_SEGMENT clipboard format
	UINT						m_cfContainer;			// CF_CONTAINER clipboard format
	UINT						m_cfAudioPath;			// CF_AUDIOPATH clipboard format
	UINT						m_cfGraph;				// CF_GRAPH clipboard format
	UINT						m_cfVirtualSegmentList;	// CF_VIRTUAL_SEGMENT_LIST clipboard format
	UINT						m_cfTrackList;			// CF_TRACK_LIST clipboard format
	UINT						m_cfTransitionList;		// CF_TRANSITION_LIST clipboard format
	
	// Used when unpacking files from runtime Song
    DWORD						m_dwEmbeddedFileListUseCount;
    IStream*					m_pIEmbeddedFileStream;
	EmbeddedFile*				m_pEmbeddedFileRootFile;
	CTypedPtrList<CPtrList, EmbeddedFile*> m_lstEmbeddedFiles;

	// Used when unpacking duplicate files from runtime Song
	IDMUSProdNode*				m_pSongBeingLoaded;
	IDMUSProdProject*			m_pIDupeFileTargetProject;
	int							m_nDupeFileDlgReturnCode;

private:
    DWORD						m_dwRef;
	IDMUSProdDocType8*			m_pISongDocType8;
	short						m_nFirstImage;

	CTypedPtrList<CPtrList, CDirectMusicSong*> m_lstSongs;
	CTypedPtrList<CPtrList, RegisteredTrack*> m_lstRegisteredTracks;
	CTypedPtrList<CPtrList, RegisteredObject*> m_lstRegisteredObjects;
};

#endif // __SONGCOMPONENT_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SongDesigner\Song.h ===
#ifndef __SONG_H__
#define __SONG_H__

// Song.h : header file
//

#include <RiffStrm.h>
#include "SongComponent.h"
#include "SongDocType.h"
#include "FolderSegments.h"
#include "FolderToolGraphs.h"
#include "VirtualSegment.h"


// Next VirtualSegment has begun playing
#define WM_NEXT_VIRTUAL_SEGMENT	(WM_USER + 0xF0)
#define WM_STOP_VIRTUAL_SEGMENT	(WM_USER + 0xF1)

// VirtualSegment min/max length
#define MIN_VIRTUAL_SEGMENT_LENGTH		1
#define MAX_VIRTUAL_SEGMENT_LENGTH		999

// m_dwBitsUI flags
#define BF_SELECTED						0x00000001

// SyncSongEditor flags
#define SSE_SOURCE_SEGMENT_LIST				0x00000001
#define SSE_VIRTUAL_SEGMENT_LIST			0x00000002
#define SSE_TOOLGRAPH_LIST					0x00000004
#define SSE_TRACK_LIST						0x00000008
#define SSE_TRANSITION_LIST					0x00000010
#define SSE_REDRAW_VIRTUAL_SEGMENT_LIST		0x00000020
#define SSE_REDRAW_TRACK_LIST				0x00000040
#define SSE_REDRAW_TRANSITION_LIST			0x00000080
#define SSE_SELECTED_VIRTUAL_SEGMENT		0x00000100
#define SSE_INVALIDATE_VIRTUAL_SEGMENT_LIST	0x00000200
#define SSE_ALL								0x00FFFFFF
#define SSE_EMPTY_ALL_LISTS					0x01000000

// SyncChanges flags
#define SC_DIRECTMUSIC				0x00000001
#define SC_PROPERTIES				0x00000002
#define SC_EDITOR					0x00000004
#define SC_ALL						0xFFFFFFFF


// Flags for property tabs
#define	PROPF_NONE_SELECTED			0x00000001
#define	PROPF_ONE_SELECTED			0x00000002
#define	PROPF_MULTI_SELECTED		0x00000004
#define	PROPF_HAVE_AUDIOPATH		0x00001000
#define	PROPF_TIME_CONVERSIONS_OK	0x00002000


class CDirectMusicSong;
class CSongCtrl;


//////////////////////////////////////////////////////////////////////
//  CNotificationHandler

class CNotificationHandler : public CWnd
{
// Construction
public:
	CNotificationHandler();
	virtual ~CNotificationHandler();

private:
	LRESULT OnNextVirtualSegment( WPARAM wParam, LPARAM lParam );
	LRESULT OnStopVirtualSegment( WPARAM wParam, LPARAM lParam );

// Attributes
public:
	CDirectMusicSong*	m_pSong;

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CNotificationHandler)
		// NOTE - the ClassWizard will add and remove member functions here.
	//}}AFX_VIRTUAL

	// Generated message map functions
protected:
	//{{AFX_MSG(CNotificationHandler)
		// NOTE - the ClassWizard will add and remove member functions here.
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


//////////////////////////////////////////////////////////////////////
//  CSongPropPageManager

class CSongPropPageManager : public IDMUSProdPropPageManager 
{
friend class CTabSong;
friend class CTabInfo;

public:
	CSongPropPageManager();
	virtual ~CSongPropPageManager();

    // IUnknown functions
    HRESULT STDMETHODCALLTYPE QueryInterface( REFIID riid, LPVOID *ppv );
    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();

    // IDMUSProdPropPageManager functions
    HRESULT STDMETHODCALLTYPE GetPropertySheetTitle( BSTR* pbstrTitle, BOOL* pfAddPropertiesText );
    HRESULT STDMETHODCALLTYPE GetPropertySheetPages( IDMUSProdPropSheet* pIPropSheet, LONG* hPropSheetPage[], short* pnNbrPages );
	HRESULT STDMETHODCALLTYPE OnRemoveFromPropertySheet();

    HRESULT STDMETHODCALLTYPE SetObject( IDMUSProdPropPageObject* pINewPropPageObject );
    HRESULT STDMETHODCALLTYPE RemoveObject( IDMUSProdPropPageObject* pIPropPageObject );
    HRESULT STDMETHODCALLTYPE IsEqualObject( IDMUSProdPropPageObject* pIPropPageObject );

    HRESULT STDMETHODCALLTYPE RefreshData();
    HRESULT STDMETHODCALLTYPE IsEqualPageManagerGUID( REFGUID rguidPageManager );

	//Additional functions
private:
	void RemoveCurrentObject();

	// Member variables
private:
    DWORD						m_dwRef;
	IDMUSProdPropSheet*			m_pIPropSheet;
	IDMUSProdPropPageObject*	m_pIPropPageObject;
	
	CTabSong*					m_pTabSong;
	CTabInfo*					m_pTabInfo;

public:
	static short				sm_nActiveTab;
};


//////////////////////////////////////////////////////////////////////
//  CDirectMusicSong

class CDirectMusicSong : public IDMUSProdNode, public IPersistStream, public IDMUSProdPropPageObject,
						 public IDMUSProdNotifySink, public IDMUSProdSortNode, public IDMUSProdTransport,
						 public IDMUSProdSecondaryTransport, public IDMUSProdNotifyCPt
{
friend class CVirtualSegmentPropPageObject;
friend class CTrackPropPageObject;
friend class CTransitionPropPageObject;
friend class CFolderToolGraphs;
friend class CFolder;
friend class CSongCtrl;
friend class CSongDlg;
friend class CTabSong;
friend class CTabInfo;

public:
    CDirectMusicSong();
	~CDirectMusicSong();

    // IUnknown functions
    HRESULT STDMETHODCALLTYPE QueryInterface( REFIID riid, LPVOID *ppv );
    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();

    // IDMUSProdNode functions
	HRESULT STDMETHODCALLTYPE GetNodeImageIndex( short* pnNbrFirstImage );
    HRESULT STDMETHODCALLTYPE GetFirstChild( IDMUSProdNode** ppIFirstChildNode );
    HRESULT STDMETHODCALLTYPE GetNextChild( IDMUSProdNode* pIChildNode, IDMUSProdNode** ppINextChildNode );

    HRESULT STDMETHODCALLTYPE GetComponent( IDMUSProdComponent** ppIComponent );
    HRESULT STDMETHODCALLTYPE GetDocRootNode( IDMUSProdNode** ppIDocRootNode );
    HRESULT STDMETHODCALLTYPE SetDocRootNode( IDMUSProdNode* pIDocRootNode );
    HRESULT STDMETHODCALLTYPE GetParentNode( IDMUSProdNode** ppIParentNode );
    HRESULT STDMETHODCALLTYPE SetParentNode( IDMUSProdNode* pIParentNode );
    HRESULT STDMETHODCALLTYPE GetNodeId( GUID* pguid );
    HRESULT STDMETHODCALLTYPE GetNodeName( BSTR* pbstrName );
    HRESULT STDMETHODCALLTYPE GetNodeNameMaxLength( short* pnMaxLength );
    HRESULT STDMETHODCALLTYPE ValidateNodeName( BSTR bstrName );
    HRESULT STDMETHODCALLTYPE SetNodeName( BSTR bstrName );
	HRESULT STDMETHODCALLTYPE GetNodeListInfo( DMUSProdListInfo* pListInfo );

    HRESULT STDMETHODCALLTYPE GetEditorClsId( CLSID* pclsid );
    HRESULT STDMETHODCALLTYPE GetEditorTitle( BSTR* pbstrTitle );
    HRESULT STDMETHODCALLTYPE GetEditorWindow( HWND* hWndEditor );
    HRESULT STDMETHODCALLTYPE SetEditorWindow( HWND hWndEditor );

	HRESULT STDMETHODCALLTYPE UseOpenCloseImages( BOOL* pfUseOpenCloseImages );

    HRESULT STDMETHODCALLTYPE GetRightClickMenuId( HINSTANCE* phInstance, UINT* pnResourceId );
    HRESULT STDMETHODCALLTYPE OnRightClickMenuInit( HMENU hMenu );
    HRESULT STDMETHODCALLTYPE OnRightClickMenuSelect( long lCommandId );

    HRESULT STDMETHODCALLTYPE DeleteChildNode( IDMUSProdNode* pIChildNode, BOOL fPromptUser );
    HRESULT STDMETHODCALLTYPE InsertChildNode( IDMUSProdNode* pIChildNode );
    HRESULT STDMETHODCALLTYPE DeleteNode( BOOL fPromptUser );

	HRESULT STDMETHODCALLTYPE OnNodeSelChanged( BOOL fSelected );

	HRESULT STDMETHODCALLTYPE CreateDataObject( IDataObject** ppIDataObject );
	HRESULT STDMETHODCALLTYPE CanCut();
	HRESULT STDMETHODCALLTYPE CanCopy();
	HRESULT STDMETHODCALLTYPE CanDelete();
	HRESULT STDMETHODCALLTYPE CanDeleteChildNode( IDMUSProdNode* pIChildNode );
	HRESULT STDMETHODCALLTYPE CanPasteFromData( IDataObject* pIDataObject, BOOL *pfWillSetReference );
	HRESULT STDMETHODCALLTYPE PasteFromData( IDataObject* pIDataObject );
	HRESULT STDMETHODCALLTYPE CanChildPasteFromData( IDataObject* pIDataObject, IDMUSProdNode* pIChildNode, BOOL *pfWillSetReference );
	HRESULT STDMETHODCALLTYPE ChildPasteFromData( IDataObject* pIDataObject, IDMUSProdNode* pIChildNode );

	HRESULT STDMETHODCALLTYPE GetObject( REFCLSID rclsid, REFIID riid, void** ppvObject ); 

    // IPersist functions
    STDMETHOD(GetClassID)( CLSID* pClsId );

    // IPersistStream functions
    STDMETHOD(IsDirty)();
    STDMETHOD(Load)( IStream* pIStream );
    STDMETHOD(Save)( IStream* pIStream, BOOL fClearDirty );
    STDMETHOD(GetSizeMax)( ULARGE_INTEGER FAR* pcbSize );

    // IDMUSProdPropPageObject functions
    HRESULT STDMETHODCALLTYPE GetData( void** ppData );
    HRESULT STDMETHODCALLTYPE SetData( void* pData );
	HRESULT STDMETHODCALLTYPE OnShowProperties();
	HRESULT STDMETHODCALLTYPE OnRemoveFromPageManager();

	// IDMUSProdNotifySink
	HRESULT STDMETHODCALLTYPE OnUpdate( IDMUSProdNode* pINode, GUID guidUpdateType, VOID* pData );

	// IDMUSProdSortNode : Sorting interface
	HRESULT STDMETHODCALLTYPE CompareNodes(IDMUSProdNode* pINode1, IDMUSProdNode* pINode2, int* pnResult);

	// IDMUSProdTransport methods
	STDMETHOD(Play)(BOOL fPlayFromStart);
	STDMETHOD(Stop)(BOOL fStopImmediate);
	STDMETHOD(Transition)();
	STDMETHOD(Record)( BOOL fPressed );
	STDMETHOD(GetName)( BSTR* pbstrName );
	STDMETHOD(TrackCursor)(BOOL fTrackCursor);

	// IDMUSProdSecondaryTransport methods
	STDMETHOD(GetSecondaryTransportSegment)( IUnknown **ppunkSegment );
	STDMETHOD(GetSecondaryTransportName)( BSTR* pbstrName );

	//IDMUSProdNotifyCPt method
	HRESULT STDMETHODCALLTYPE OnNotify( ConductorNotifyEvent *pConductorNotifyEvent );

	//Additional functions
protected:
	HRESULT LoadSong( IDMUSProdRIFFStream* pIRiffStream, MMCKINFO* pckMain );
    HRESULT SaveSong( IDMUSProdRIFFStream* pIRiffStream, BOOL fClearDirty );
    HRESULT SaveHeader( IDMUSProdRIFFStream* pIRiffStream );
    HRESULT SaveGUID( IDMUSProdRIFFStream* pIRiffStream );
    HRESULT SaveInfoList( IDMUSProdRIFFStream* pIRiffStream );
    HRESULT SaveVersion( IDMUSProdRIFFStream* pIRiffStream );
	HRESULT SaveSelectedVirtualSegments( IDMUSProdRIFFStream* pIRiffStream );
	HRESULT PasteCF_CONTAINER( CDllJazzDataObject* pDataObject, IDataObject* pIDataObject );
	HRESULT PasteCF_AUDIOPATH( CDllJazzDataObject* pDataObject, IDataObject* pIDataObject );
	void EmptyVirtualSegmentList();
	void InsertVirtualSegment( CVirtualSegment* pVirtualSegment, int nIndex );
	void RemoveVirtualSegment( CVirtualSegment* pVirtualSegment );
	void RemoveToolGraphReferences( IDMUSProdNode* pIToolGraphNode );
	void RemoveSourceSegmentReferences( CSourceSegment* pSourceSegment );

public:
	HRESULT ReadListInfoFromStream( IStream* pIStream, DMUSProdListInfo* pListInfo );
    HRESULT GetObjectDescriptor( void* pObjectDesc );

	HRESULT OnNewContainer();
	HRESULT OnNewAudioPath();
	BOOL CreateUndoMgr();
	void SetModified( BOOL fModified );
	void SyncChanges( DWORD dwFlags, DWORD dwEditorFlags, IDMUSProdPropPageObject* pIPropPageObject );
	void ResolveVirtualSegmentIDs();

	CFolder* GetSegmentEmbedFolder();
	CFolder* GetSegmentRefFolder();

	BOOL IsVirtualSegmentNameUnique( CVirtualSegment* pVirtualSegment );
	void GetUniqueVirtualSegmentName( CVirtualSegment* pVirtualSegment );
	int VirtualSegmentToIndex( CVirtualSegment* pVirtualSegment );
	CVirtualSegment* GUIDToVirtualSegment( GUID guidVirtualSegment );
	CVirtualSegment* IndexToVirtualSegment( int nVirtualSegmentIndex );
	CVirtualSegment* FindVirtualSegmentByName( LPCTSTR pszName );
	CVirtualSegment* PtrToVirtualSegment( CVirtualSegment* pVirtualSegment );
	void RecomputeVirtualSegmentLengths();

	BOOL IsSourceSegmentInSong( IDMUSProdNode* pIDocRootNode );
	CSourceSegment* GetSourceSegmentFromDocRoot( IDMUSProdNode* pIDocRootNode );
	int SourceSegmentToIndex( CSourceSegment* pSourceSegment );
	CSourceSegment* IndexToSourceSegment( int nSourceSegmentIndex );
	CSourceSegment* PtrToSourceSegment( CSourceSegment* pSourceSegment );
	
	int ToolGraphToIndex( IDMUSProdNode* pIToolGraphNode );
	IDMUSProdNode* IndexToToolGraph( int nToolGraphIndex );
	IDMUSProdNode* PtrToToolGraph( IDMUSProdNode* pIToolGraphNode );

	HRESULT UnRegisterWithTransport();
	HRESULT RegisterWithTransport();
	HRESULT SetActiveTransport();
	HRESULT UpdateTransportName();
	HRESULT TransitionWithinSong();
	DWORD TransitionOptionsToDMUS_SEGF( ConductorTransitionOptions* pTransitionOptions );

	void GetGUID( GUID* pguidSong );
	void SetGUID( GUID guidSong);

private:
    DWORD					m_dwRef;
	BOOL					m_fModified;

	CJazzUndoMan*			m_pUndoMgr;
	HWND					m_hWndEditor;

	IDirectMusicSong*			m_pIDMSong;
	IDirectMusicSegmentState*	m_pIDMSegmentState;
	IDirectMusicSegmentState*	m_rpIDMStoppedSegmentState;
	IDirectMusicSegmentState*	m_pIDMTransitionSegmentState;

	bool					m_fInTransition;
	DWORD					m_dwTransitionPlayFlags;
	IDirectMusicSegment*	m_pIDMTransitionSegment;

	IDMUSProdNode*			m_pIDocRootNode;
	IDMUSProdNode*			m_pIParentNode;

	CFolderSegments			m_FolderSegments;
	CFolderToolGraphs		m_FolderToolGraphs;
	IDMUSProdNode*			m_pIContainerNode;
	IDMUSProdNode*			m_pIAudioPathNode;
	bool					m_fDeletingContainer;
	bool					m_fChangingFolder;

public:
	CString					m_strOrigFileName;
	CSongCtrl*				m_pSongCtrl;
	IDMUSProdNode*			m_pINodeBeingDeleted;
	IDMUSProdProject*		m_pIProject;
	CRITICAL_SECTION		m_csSegmentState;

	// A window so we can handle DMusic notification in a messaging thread
	CNotificationHandler	m_wndNotificationHandler;

private:
	// Persisted for DirectMusic
	GUID					m_guidSong;
	DMUS_VERSION			m_vVersion;
    CString					m_strName;
    CString					m_strAuthor;
    CString					m_strCopyright;
    CString					m_strSubject;
    CString					m_strInfo;

	DWORD					m_dwSongFlagsDM;
	DWORD					m_dwStartSegID;

	CTypedPtrList<CPtrList, CVirtualSegment*> m_lstVirtualSegments;
};

#endif // __SONG_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SongDesigner\SongCtl.cpp ===
// SongCtl.cpp : Implementation of the CSongCtrl ActiveX Control class.

#include "stdafx.h"
#include "SongDesignerDLL.h"
#include "Song.h"
#include "SongCtl.h"
#include "SongRef.h"


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


IMPLEMENT_DYNCREATE(CSongCtrl, COleControl)


/////////////////////////////////////////////////////////////////////////////
// Message map

BEGIN_MESSAGE_MAP(CSongCtrl, COleControl)
	//{{AFX_MSG_MAP(CSongCtrl)
	ON_WM_CREATE()
	ON_COMMAND(ID_APP_ABOUT, AboutBox)
	ON_WM_DESTROY()
	ON_WM_SIZE()
	ON_UPDATE_COMMAND_UI(ID_EDIT_CUT, OnUpdateEditCut)
	ON_COMMAND(ID_EDIT_CUT, OnEditCut)
	ON_UPDATE_COMMAND_UI(ID_EDIT_COPY, OnUpdateEditCopy)
	ON_COMMAND(ID_EDIT_COPY, OnEditCopy)
	ON_UPDATE_COMMAND_UI(ID_EDIT_PASTE, OnUpdateEditPaste)
	ON_COMMAND(ID_EDIT_PASTE, OnEditPaste)
	ON_UPDATE_COMMAND_UI(ID_EDIT_DELETE, OnUpdateEditDelete)
	ON_COMMAND(ID_EDIT_DELETE, OnEditDelete)
	ON_UPDATE_COMMAND_UI(ID_EDIT_INSERT, OnUpdateEditInsert)
	ON_COMMAND(ID_EDIT_INSERT, OnEditInsert)
	ON_COMMAND(ID_EDIT_SELECT_ALL, OnEditSelectAll)
	ON_UPDATE_COMMAND_UI(ID_EDIT_UNDO, OnUpdateEditUndo)
	ON_COMMAND(ID_EDIT_UNDO, OnEditUndo)
	ON_UPDATE_COMMAND_UI(ID_EDIT_REDO, OnUpdateEditRedo)
	ON_COMMAND(ID_EDIT_REDO, OnEditRedo)
	ON_COMMAND(IDM_HELP_FINDER, OnHelpFinder)
	ON_WM_PARENTNOTIFY()
	ON_WM_SETFOCUS()
	ON_WM_MOUSEACTIVATE()
	//}}AFX_MSG_MAP
	ON_OLEVERB(AFX_IDS_VERB_PROPERTIES, OnProperties)
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// Dispatch map

BEGIN_DISPATCH_MAP(CSongCtrl, COleControl)
	//{{AFX_DISPATCH_MAP(CSongCtrl)
	// NOTE - ClassWizard will add and remove dispatch map entries
	//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DISPATCH_MAP
	DISP_FUNCTION_ID(CSongCtrl, "AboutBox", DISPID_ABOUTBOX, AboutBox, VT_EMPTY, VTS_NONE)
END_DISPATCH_MAP()


/////////////////////////////////////////////////////////////////////////////
// Event map

BEGIN_EVENT_MAP(CSongCtrl, COleControl)
	//{{AFX_EVENT_MAP(CSongCtrl)
	// NOTE - ClassWizard will add and remove event map entries
	//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_EVENT_MAP
END_EVENT_MAP()


/////////////////////////////////////////////////////////////////////////////
// CSongCtrl Interface map

BEGIN_INTERFACE_MAP(CSongCtrl, COleControl)
    INTERFACE_PART(CSongCtrl, IID_IOleInPlaceActiveObject, MyOleInPlaceActiveObject)
    INTERFACE_PART(CSongCtrl, IID_IDMUSProdEditor, Editor)
END_INTERFACE_MAP()


/////////////////////////////////////////////////////////////////////////////
// Initialize class factory and guid

IMPLEMENT_OLECREATE_EX(CSongCtrl, "SONGDESIGNER.SongCtrl.1",
	0x35327daf, 0x7151, 0x43da, 0xaf, 0x9b, 0x57, 0x9d, 0x8a, 0x20, 0x41, 0x03)


/////////////////////////////////////////////////////////////////////////////
// Type library ID and version

IMPLEMENT_OLETYPELIB(CSongCtrl, _tlid, _wVerMajor, _wVerMinor)


/////////////////////////////////////////////////////////////////////////////
// Interface IDs

const IID BASED_CODE IID_DSong =
		{ 0x9cb3a837, 0xb566, 0x4b17, { 0x8a, 0x9b, 0x1f, 0x9a, 0x19, 0xd9, 0x9c, 0xe2 } };
const IID BASED_CODE IID_DSongEvents =
		{ 0x958130e0, 0x9d27, 0x4ecf, { 0x9d, 0xe2, 0x6a, 0x38, 0xed, 0x58, 0xae, 0xdd } };


/////////////////////////////////////////////////////////////////////////////
// Control type information

static const DWORD BASED_CODE _dwSongOleMisc =
	OLEMISC_ACTIVATEWHENVISIBLE |
	OLEMISC_SETCLIENTSITEFIRST |
	OLEMISC_INSIDEOUT |
	OLEMISC_CANTLINKINSIDE |
	OLEMISC_RECOMPOSEONRESIZE;

IMPLEMENT_OLECTLTYPE(CSongCtrl, IDS_SONG, _dwSongOleMisc)


/////////////////////////////////////////////////////////////////////////////
// CSongCtrl::CSongCtrlFactory::UpdateRegistry -
// Adds or removes system registry entries for CSongCtrl

BOOL CSongCtrl::CSongCtrlFactory::UpdateRegistry(BOOL bRegister)
{
	// TODO: Verify that your control follows apartment-model threading rules.
	// Refer to MFC TechNote 64 for more information.
	// If your control does not conform to the apartment-model rules, then
	// you must modify the code below, changing the 6th parameter from
	// afxRegApartmentThreading to 0.

	if (bRegister)
		return AfxOleRegisterControlClass(
			AfxGetInstanceHandle(),
			m_clsid,
			m_lpszProgID,
			IDS_SONG,
			IDB_SONG,
			afxRegApartmentThreading,
			_dwSongOleMisc,
			_tlid,
			_wVerMajor,
			_wVerMinor);
	else
		return AfxOleUnregisterClass(m_clsid, m_lpszProgID);
}


/////////////////////////////////////////////////////////////////////////////
// CSongCtrl::CSongCtrl - Constructor

CSongCtrl::CSongCtrl()
{
/////////////////////////////////////////////////////////////////////////
// Following commented out to prevent 3 ASSERTS that occur
// because we are not building a typelib
//	InitializeIIDs(&IID_DSong, &IID_DSongEvents);
//
// Following code copied from InitializeIIDs (since we cannot override)
	m_piidPrimary = &IID_DSong;
	m_piidEvents = &IID_DSongEvents;
	EnableTypeLib();	// Needed to prevent ASSERT when closing editor
	InitStockEventMask();
	InitStockPropMask();
//////////////////////////////////////////////////////////////////////////

	m_pSongDlg = NULL;
	m_hWndContainer = NULL;
	m_hMenuInPlace = NULL;
	m_hAcceleratorTable	= NULL;
	m_pSong = NULL;
}


/////////////////////////////////////////////////////////////////////////////
// CSongCtrl::~CSongCtrl - Destructor

CSongCtrl::~CSongCtrl()
{
	RELEASE( m_pSong );
}


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// CSongCtrl IDMUSProdEditor implementation

/////////////////////////////////////////////////////////////////////////////
// CSongCtrl::XEditor::AddRef

STDMETHODIMP_(ULONG) CSongCtrl::XEditor::AddRef()
{
	METHOD_PROLOGUE_EX_( CSongCtrl, Editor )

	return (ULONG)pThis->ExternalAddRef();
}


/////////////////////////////////////////////////////////////////////////////
// CSongCtrl::XEditor::Release

STDMETHODIMP_(ULONG) CSongCtrl::XEditor::Release()
{
	METHOD_PROLOGUE_EX_( CSongCtrl, Editor )

	return (ULONG)pThis->ExternalRelease();
}


/////////////////////////////////////////////////////////////////////////////
// CSongCtrl::XEditor::QueryInterface

STDMETHODIMP CSongCtrl::XEditor::QueryInterface( REFIID iid, LPVOID* ppvObj )
{
	METHOD_PROLOGUE_EX_( CSongCtrl, Editor )

	return (HRESULT)pThis->ExternalQueryInterface( &iid, ppvObj );
}


/////////////////////////////////////////////////////////////////////////////
// CSongCtrl::XEditor::AttachObjects implementation

HRESULT CSongCtrl::XEditor::AttachObjects( IDMUSProdNode* pINode )
{
	METHOD_MANAGE_STATE( CSongCtrl, Editor )

	ASSERT_VALID( pThis );
	ASSERT( pINode != NULL );

	GUID guidNode;

	pINode->GetNodeId( &guidNode );
	if( ::IsEqualGUID( guidNode, GUID_SongRefNode ) )
	{
		CSongRef* pSongRef = (CSongRef *)pINode;
		ASSERT( pSongRef->m_pSong != NULL );
		pThis->m_pSong = pSongRef->m_pSong;
	}
	else
	{
		pThis->m_pSong = (CDirectMusicSong *)pINode;
	}

	ASSERT( pThis->m_pSong != NULL );
	pThis->m_pSong->AddRef();

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CSongCtrl::XEditor::OnInitMenuFilePrint

HRESULT CSongCtrl::XEditor::OnInitMenuFilePrint( HMENU hMenu, UINT nMenuId )
{
	METHOD_MANAGE_STATE( CSongCtrl, Editor )

	::EnableMenuItem( hMenu, nMenuId, (MF_GRAYED | MF_BYCOMMAND) );

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CSongCtrl::XEditor::OnFilePrint

HRESULT CSongCtrl::XEditor::OnFilePrint( void )
{
	METHOD_MANAGE_STATE( CSongCtrl, Editor )

	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CSongCtrl::XEditor::OnInitMenuFilePrintPreview

HRESULT CSongCtrl::XEditor::OnInitMenuFilePrintPreview( HMENU hMenu, UINT nMenuId )
{
	METHOD_MANAGE_STATE( CSongCtrl, Editor )

	::EnableMenuItem( hMenu, nMenuId, (MF_GRAYED | MF_BYCOMMAND) );

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CSongCtrl::XEditor::OnFilePrintPreview

HRESULT CSongCtrl::XEditor::OnFilePrintPreview( void )
{
	METHOD_MANAGE_STATE( CSongCtrl, Editor )

	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CSongCtrl::XEditor::OnViewProperties

HRESULT CSongCtrl::XEditor::OnViewProperties( void )
{
	METHOD_MANAGE_STATE( CSongCtrl, Editor )

	HRESULT hr = E_FAIL;

	if( pThis->m_pSongDlg )
	{
		if( pThis->m_pSongDlg->OnViewProperties() )
		{
			hr = S_OK;
		}
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CSongCtrl::XEditor::OnF1Help

HRESULT CSongCtrl::XEditor::OnF1Help( void )
{
	METHOD_MANAGE_STATE( CSongCtrl, Editor )
	
    // Determine name of DMUSProd.exe help file
	CString strHelpFileName;

	if( theApp.GetHelpFileName( strHelpFileName ) )
	{
		strHelpFileName += "::/htm/SongDesignerWindow.htm";
		::HtmlHelp( NULL, strHelpFileName, HH_DISPLAY_TOPIC, 0 );
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// CSongCtrl::XMyOleInPlaceActiveObject implementation

STDMETHODIMP_(ULONG) CSongCtrl::XMyOleInPlaceActiveObject::AddRef()
{
	METHOD_MANAGE_STATE( CSongCtrl, MyOleInPlaceActiveObject )
	ASSERT_VALID( pThis );

	return pThis->m_xOleInPlaceActiveObject.AddRef();
}

STDMETHODIMP_(ULONG) CSongCtrl::XMyOleInPlaceActiveObject::Release()
{
	METHOD_MANAGE_STATE( CSongCtrl, MyOleInPlaceActiveObject )
	ASSERT_VALID( pThis );

	return pThis->m_xOleInPlaceActiveObject.Release();
}

STDMETHODIMP CSongCtrl::XMyOleInPlaceActiveObject::QueryInterface( REFIID iid, LPVOID* ppvObj )
{
	METHOD_MANAGE_STATE( CSongCtrl, MyOleInPlaceActiveObject )
	ASSERT_VALID( pThis );

	return pThis->m_xOleInPlaceActiveObject.QueryInterface( iid, ppvObj );
}

STDMETHODIMP CSongCtrl::XMyOleInPlaceActiveObject::GetWindow( HWND* lphwnd )
{
	METHOD_MANAGE_STATE( CSongCtrl, MyOleInPlaceActiveObject )
	ASSERT_VALID( pThis );

	return pThis->m_xOleInPlaceActiveObject.GetWindow( lphwnd );
}

STDMETHODIMP CSongCtrl::XMyOleInPlaceActiveObject::ContextSensitiveHelp( BOOL fEnterMode )
{
	METHOD_MANAGE_STATE( CSongCtrl, MyOleInPlaceActiveObject )
	ASSERT_VALID( pThis );

	return pThis->m_xOleInPlaceActiveObject.ContextSensitiveHelp( fEnterMode );
}

STDMETHODIMP CSongCtrl::XMyOleInPlaceActiveObject::TranslateAccelerator( LPMSG lpmsg )
{
	METHOD_MANAGE_STATE( CSongCtrl, MyOleInPlaceActiveObject )
	ASSERT_VALID( pThis );

	if( pThis->m_pSongDlg )
	{
		if( (lpmsg->message == WM_KEYDOWN && lpmsg->wParam == 0x59) 
		||  (lpmsg->message == WM_KEYDOWN && lpmsg->wParam == 0x5A) )  
		{
			// Translate CTRL + Y when any control in the editor has focus
			// Translate CTRL + Z when any control in the editor has focus
			CWnd* pWnd = pThis->GetFocus();
			if( pThis == pWnd
			||  pThis->IsChild(pWnd) ) 
			{
				if( ::TranslateAccelerator(pThis->m_hWnd, pThis->m_hAcceleratorTable, lpmsg) )
				{
					return S_OK;
				}
			}
		}

		if( lpmsg->message == WM_KEYDOWN && lpmsg->wParam == 0xDE ) 
		{
			// Translate CTRL + SHIFT + " when any control in the editor has focus
			if( (GetKeyState(VK_CONTROL) & 0x8000)
			&&	(GetKeyState(VK_SHIFT) & 0x8000) )
			{
				CWnd* pWnd = pThis->GetFocus();
				if( pThis == pWnd
				||  pThis->IsChild(pWnd) ) 
				{
					if( pThis->m_pSong )
					{
						pThis->m_pSong->TransitionWithinSong();
						return S_OK;
					}
				}
			}
		}

		// Everything else
		else
		{
			// Translate everything else only when one of the listbox controls has focus
			if( ::IsWindow(pThis->m_pSongDlg->m_lstbxSegments.m_hWnd) )
			{
				HWND hwndFocus = ::GetFocus();
				if( pThis->m_pSongDlg->m_lstbxSegments.m_hWnd == hwndFocus 
				||  pThis->m_pSongDlg->m_lstbxTracks.m_hWnd == hwndFocus 
				||  pThis->m_pSongDlg->m_lstbxTransitions.m_hWnd == hwndFocus )
				{
					if( ::TranslateAccelerator(pThis->m_hWnd, pThis->m_hAcceleratorTable, lpmsg) )
					{
						return S_OK;
					}
				}
			}
		}
	}

//	OLEINPLACEFRAMEINFO frameInfo = pThis->m_frameInfo;
//	if( ::OleTranslateAccelerator(pThis->m_pInPlaceFrame, &frameInfo, lpmsg) == S_OK )
//	{
//		return S_OK;
//	}

	return pThis->m_xOleInPlaceActiveObject.TranslateAccelerator( lpmsg );
}

STDMETHODIMP CSongCtrl::XMyOleInPlaceActiveObject::OnFrameWindowActivate( BOOL fActivate )
{
	METHOD_MANAGE_STATE( CSongCtrl, MyOleInPlaceActiveObject )
	ASSERT_VALID( pThis );

	return pThis->m_xOleInPlaceActiveObject.OnFrameWindowActivate( fActivate );
}

STDMETHODIMP CSongCtrl::XMyOleInPlaceActiveObject::OnDocWindowActivate( BOOL fActivate )
{
	METHOD_MANAGE_STATE( CSongCtrl, MyOleInPlaceActiveObject )
	ASSERT_VALID( pThis );

	return pThis->m_xOleInPlaceActiveObject.OnDocWindowActivate( fActivate );
}

STDMETHODIMP CSongCtrl::XMyOleInPlaceActiveObject::ResizeBorder(
	LPCRECT, LPOLEINPLACEUIWINDOW, BOOL fFrameWindow )
{
	METHOD_MANAGE_STATE( CSongCtrl, MyOleInPlaceActiveObject )
	ASSERT_VALID( pThis );

    if( fFrameWindow == TRUE )
	{
		pThis->OnShowToolBars();
	}

	return S_OK;
}

STDMETHODIMP CSongCtrl::XMyOleInPlaceActiveObject::EnableModeless( BOOL fEnable )
{
	METHOD_MANAGE_STATE( CSongCtrl, MyOleInPlaceActiveObject )
	ASSERT_VALID( pThis );

	return pThis->m_xOleInPlaceActiveObject.EnableModeless( fEnable );
}


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// CSongCtrl::OnDraw - Drawing function

void CSongCtrl::OnDraw( CDC* pdc, const CRect& rcBounds, const CRect& rcInvalid )
{
	UNREFERENCED_PARAMETER(pdc);
	UNREFERENCED_PARAMETER(rcBounds);
	UNREFERENCED_PARAMETER(rcInvalid);
}


/////////////////////////////////////////////////////////////////////////////
// CSongCtrl::DoPropExchange - Persistence support

void CSongCtrl::DoPropExchange(CPropExchange* pPX)
{
	ExchangeVersion(pPX, MAKELONG(_wVerMinor, _wVerMajor));
	COleControl::DoPropExchange(pPX);
}


/////////////////////////////////////////////////////////////////////////////
// CSongCtrl::OnResetState - Reset control to default state

void CSongCtrl::OnResetState()
{
	COleControl::OnResetState();  // Resets defaults found in DoPropExchange

	// TODO: Reset any other control state here.
}


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// CSongAbout dialog used for Song Editor About Box

class CSongAbout : public CDialog
{
public:
	CSongAbout();

// Dialog Data
	//{{AFX_DATA(CSongAbout)
	enum { IDD = IDD_ABOUTBOX_SONG };
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CSongAbout)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	//{{AFX_MSG(CSongAbout)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

CSongAbout::CSongAbout() : CDialog(CSongAbout::IDD)
{
	//{{AFX_DATA_INIT(CSongAbout)
	//}}AFX_DATA_INIT
}

void CSongAbout::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CSongAbout)
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CSongAbout, CDialog)
	//{{AFX_MSG_MAP(CSongAbout)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


BOOL CSongAbout::OnInitDialog() 
{
	CDialog::OnInitDialog();

	// Get version information
	TCHAR achExeName[FILENAME_MAX + 1];
	TCHAR achFileVersion[MID_BUFFER];

	if( GetModuleFileName ( theApp.m_hInstance, achExeName, FILENAME_MAX ) )
	{
		if( theApp.GetFileVersion( achExeName, achFileVersion, MID_BUFFER ) )
		{
			CString strFileVersion;

			AfxFormatString1( strFileVersion, IDS_SONG_VERSION_TEXT, achFileVersion );
			SetDlgItemText( IDC_FILE_VERSION, strFileVersion );
		}
	}
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
// CSongCtrl::AboutBox - Display an "About" box to the user

void CSongCtrl::AboutBox()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CSongAbout dlgAbout;
	dlgAbout.DoModal();
}


/////////////////////////////////////////////////////////////////////////////
// CSongCtrl message handlers

/////////////////////////////////////////////////////////////////////////////
// CSongCtrl::OnHideToolBars

void CSongCtrl::OnHideToolBars() 
{
	COleControl::OnHideToolBars();
}


/////////////////////////////////////////////////////////////////////////////
// CSongCtrl::OnShowToolBars

void CSongCtrl::OnShowToolBars() 
{
	if( m_pInPlaceFrame == NULL )
	{
		return;
	}

	m_pInPlaceFrame->SetActiveObject( &m_xMyOleInPlaceActiveObject, NULL );

	if( m_pInPlaceDoc != NULL )
	{
		m_pInPlaceDoc->SetActiveObject( &m_xMyOleInPlaceActiveObject, NULL );
	}

	COleControl::OnShowToolBars();
}


/////////////////////////////////////////////////////////////////////////////
// CSongCtrl::OnGetInPlaceMenu

HMENU CSongCtrl::OnGetInPlaceMenu() 
{
	return m_hMenuInPlace;
}


/////////////////////////////////////////////////////////////////////////////
// CSongCtrl::OnCreate

int CSongCtrl::OnCreate( LPCREATESTRUCT lpCreateStruct ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( COleControl::OnCreate(lpCreateStruct) == -1 )
	{
		return -1;
	}

	if( m_pInPlaceFrame )
	{
		m_pInPlaceFrame->GetWindow( &m_hWndContainer );
	}
	else
	{
		// out of place active?
		if( m_bOpen )
		{
			m_hWndContainer = GetParent()->GetSafeHwnd();
		}
	}

	// Load control's in-place menu
	m_hMenuInPlace = ::LoadMenu( theApp.m_hInstance, MAKEINTRESOURCE(IDR_SONG_EDITOR) );

	// Load control's accelerator table
	m_hAcceleratorTable = ::LoadAccelerators( theApp.m_hInstance, MAKEINTRESOURCE(IDR_SONG_ACCELS) );

	// Create control's dialog
	m_pSongDlg = new CSongDlg;
	if( m_pSongDlg == NULL )
	{
		return -1;
	}

	m_pSong->m_pSongCtrl = this;

	m_pSongDlg->m_pSong = m_pSong;
	m_pSongDlg->m_pSongCtrl = this;
	m_pSongDlg->Create( NULL, "WindowName", WS_CHILD | WS_VISIBLE, CRect( 0, 0, 800, 400 ), this, 888, NULL );
	m_pSongDlg->OnInitialUpdate();
	
	return 0;
}


/////////////////////////////////////////////////////////////////////////////
// CSongCtrl::OnDestroy

void CSongCtrl::OnDestroy() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	COleControl::OnDestroy();

	if( m_hMenuInPlace )
	{
		::DestroyMenu( m_hMenuInPlace );
		m_hMenuInPlace = NULL;
	}

	if( m_hAcceleratorTable )
	{
		::DestroyAcceleratorTable( m_hAcceleratorTable );
		m_hAcceleratorTable = NULL;
	}

	ASSERT( m_pSong != NULL );

	m_pSong->m_pSongCtrl = NULL;
}


/////////////////////////////////////////////////////////////////////////////
// CSongCtrl::OnSize

void CSongCtrl::OnSize( UINT nType, int cx, int cy ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	COleControl::OnSize( nType, cx, cy );

	m_pSongDlg->MoveWindow( 0, 0, cx, cy );
}


/////////////////////////////////////////////////////////////////////////////
// CSongCtrl::OnMouseActivate

int CSongCtrl::OnMouseActivate( CWnd* pDesktopWnd, UINT nHitTest, UINT message ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pSong )
	{
		m_pSong->SetActiveTransport();
	}

	return COleControl::OnMouseActivate( pDesktopWnd, nHitTest, message );
}


/////////////////////////////////////////////////////////////////////////////
// CSongCtrl::OnSetFocus

void CSongCtrl::OnSetFocus( CWnd* pOldWnd ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	COleControl::OnSetFocus( pOldWnd );

	if( m_pSong )
	{
		m_pSong->SetActiveTransport();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CSongCtrl::OnUpdateEditUndo

void CSongCtrl::OnUpdateEditUndo( CCmdUI* pCmdUI ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pSong != NULL );

	CString strUndo;
	CString strUndoAccel;

	strUndo.LoadString( IDS_UNDO );
	strUndoAccel.LoadString( IDS_UNDO_ACCEL );

	BOOL fEnable = FALSE;

	if( m_pSong )
	{
		TCHAR achText[MAX_BUFFER];

		ASSERT( m_pSong->m_pUndoMgr != NULL );

		if( m_pSong->m_pUndoMgr )
		{
			if( m_pSong->m_pUndoMgr->GetUndo(achText, MAX_BUFFER) )
			{
				if( *achText )
				{
					strUndo += " ";
					strUndo += achText;
				}

				fEnable = TRUE;
			}
		}
	}

	strUndo += strUndoAccel;
	pCmdUI->SetText( strUndo );
	pCmdUI->Enable( fEnable );
}


/////////////////////////////////////////////////////////////////////////////
// CSongCtrl::OnEditUndo

void CSongCtrl::OnEditUndo() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pSong != NULL );

	if( m_pSong )
	{
		ASSERT( m_pSong->m_pUndoMgr != NULL );

		if( m_pSong->m_pUndoMgr )
		{
			TCHAR achText[MAX_BUFFER];

			if( m_pSong->m_pUndoMgr->GetUndo(achText, MAX_BUFFER) )
			{
				m_pSong->m_pUndoMgr->Undo( m_pSong );
				m_pSong->SetModified( TRUE );
			}
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CSongCtrl::OnUpdateEditRedo

void CSongCtrl::OnUpdateEditRedo( CCmdUI* pCmdUI ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pSong != NULL );

	CString strRedo;
	CString strRedoAccel;

	strRedo.LoadString( IDS_REDO );
	strRedoAccel.LoadString( IDS_REDO_ACCEL );

	BOOL fEnable = FALSE;

	if( m_pSong )
	{
		TCHAR achText[MAX_BUFFER];

		ASSERT( m_pSong->m_pUndoMgr != NULL );

		if( m_pSong->m_pUndoMgr )
		{
			if( m_pSong->m_pUndoMgr->GetRedo(achText, MAX_BUFFER) )
			{
				if( *achText )
				{
					strRedo += " ";
					strRedo += achText;
				}

				fEnable = TRUE;
			}
		}
	}

	strRedo += strRedoAccel;
	pCmdUI->SetText( strRedo );
	pCmdUI->Enable( fEnable );
}


/////////////////////////////////////////////////////////////////////////////
// CSongCtrl::OnEditRedo

void CSongCtrl::OnEditRedo() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pSong != NULL );

	if( m_pSong )
	{
		ASSERT( m_pSong->m_pUndoMgr != NULL );

		if( m_pSong->m_pUndoMgr )
		{
			TCHAR achText[MAX_BUFFER];

			if( m_pSong->m_pUndoMgr->GetRedo(achText, MAX_BUFFER) )
			{
				m_pSong->m_pUndoMgr->Redo( m_pSong );
				m_pSong->SetModified( TRUE );
			}
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CSongCtrl::OnUpdateEditCut

void CSongCtrl::OnUpdateEditCut( CCmdUI* pCmdUI ) 
{
	if( m_pSongDlg )
	{
		m_pSongDlg->OnUpdateEditCut( pCmdUI );
		return;
	}

	pCmdUI->Enable( FALSE );
}


/////////////////////////////////////////////////////////////////////////////
// CSongCtrl::OnEditCut

void CSongCtrl::OnEditCut() 
{
	if( m_pSongDlg )
	{
		m_pSongDlg->OnEditCut();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CSongCtrl::OnUpdateEditCopy

void CSongCtrl::OnUpdateEditCopy( CCmdUI* pCmdUI ) 
{
	if( m_pSongDlg )
	{
		m_pSongDlg->OnUpdateEditCopy( pCmdUI );
		return;
	}

	pCmdUI->Enable( FALSE );
}


/////////////////////////////////////////////////////////////////////////////
// CSongCtrl::OnEditCopy

void CSongCtrl::OnEditCopy() 
{
	if( m_pSongDlg )
	{
		m_pSongDlg->OnEditCopy();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CSongCtrl::OnUpdateEditPaste

void CSongCtrl::OnUpdateEditPaste( CCmdUI* pCmdUI ) 
{
	if( m_pSongDlg )
	{
		m_pSongDlg->OnUpdateEditPaste( pCmdUI );
		return;
	}

	pCmdUI->Enable( FALSE );
}


/////////////////////////////////////////////////////////////////////////////
// CSongCtrl::OnEditPaste

void CSongCtrl::OnEditPaste() 
{
	if( m_pSongDlg )
	{
		m_pSongDlg->OnEditPaste();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CSongCtrl::OnUpdateEditInsert

void CSongCtrl::OnUpdateEditInsert( CCmdUI* pCmdUI ) 
{
	if( m_pSongDlg )
	{
		m_pSongDlg->OnUpdateEditInsert( pCmdUI );
		return;
	}

	pCmdUI->Enable( FALSE );
}


/////////////////////////////////////////////////////////////////////////////
// CSongCtrl::OnEditInsert

void CSongCtrl::OnEditInsert() 
{
	if( m_pSongDlg )
	{
		m_pSongDlg->OnEditInsert();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CSongCtrl::OnEditSelectAll

void CSongCtrl::OnEditSelectAll() 
{
	if( m_pSongDlg )
	{
		m_pSongDlg->OnEditSelectAll();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CSongCtrl::OnUpdateEditDelete

void CSongCtrl::OnUpdateEditDelete( CCmdUI* pCmdUI ) 
{
	if( m_pSongDlg )
	{
		m_pSongDlg->OnUpdateEditDelete( pCmdUI );
		return;
	}

	pCmdUI->Enable( FALSE );
}


/////////////////////////////////////////////////////////////////////////////
// CSongCtrl::OnEditDelete

void CSongCtrl::OnEditDelete() 
{
	if( m_pSongDlg )
	{
		m_pSongDlg->OnEditDelete();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CSongCtrl::OnHelpFinder

void CSongCtrl::OnHelpFinder() 
{
 	AFX_MANAGE_STATE(_afxModuleAddrThis);

   // Determine name of DMUSProd.exe help file
	CString strHelpFileName;

	if( theApp.GetHelpFileName( strHelpFileName ) )
	{
		strHelpFileName += "::/htm/directmusicproducer.htm";
		::HtmlHelp( NULL, strHelpFileName, HH_DISPLAY_TOPIC, 0 );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CSongCtrl::PreTranslateMessage

BOOL CSongCtrl::PreTranslateMessage( MSG* pMsg ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( IsDialogMessage( pMsg ) )
	{
		return TRUE;
	}
	
	return COleControl::PreTranslateMessage(pMsg);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SongDesigner\SongCtl.h ===
#if !defined(AFX_SONGCTL_H__D135DB66_66ED_11D3_B45D_00105A2796DE__INCLUDED_)
#define AFX_SONGCTL_H__D135DB66_66ED_11D3_B45D_00105A2796DE__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

// SongCtl.h : Declaration of the CSongCtrl ActiveX Control class.

#include "SongDlg.h"

/////////////////////////////////////////////////////////////////////////////
// CSongCtrl : See SongCtl.cpp for implementation.

class CSongCtrl : public COleControl
{
	DECLARE_DYNCREATE(CSongCtrl)

// Constructor
public:
	CSongCtrl();

// Attributes
public:
	CSongDlg*			m_pSongDlg;

private:
	HWND				m_hWndContainer;
	HMENU				m_hMenuInPlace;
	HACCEL				m_hAcceleratorTable;
	CDirectMusicSong*	m_pSong;

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CSongCtrl)
	public:
	virtual void OnDraw(CDC* pdc, const CRect& rcBounds, const CRect& rcInvalid);
	virtual void DoPropExchange(CPropExchange* pPX);
	virtual void OnResetState();
	virtual void OnHideToolBars();
	virtual void OnShowToolBars();
	virtual HMENU OnGetInPlaceMenu();
	virtual BOOL PreTranslateMessage(MSG* pMsg);
	//}}AFX_VIRTUAL

// Implementation
protected:
	~CSongCtrl();

	DECLARE_OLECREATE_EX(CSongCtrl)    // Class factory and guid
	DECLARE_OLETYPELIB(CSongCtrl)      // GetTypeInfo
	DECLARE_OLECTLTYPE(CSongCtrl)	   // Type name and misc status

// Message maps
	//{{AFX_MSG(CSongCtrl)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void AboutBox();
	afx_msg void OnDestroy();
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnUpdateEditCut(CCmdUI* pCmdUI);
	afx_msg void OnEditCut();
	afx_msg void OnUpdateEditCopy(CCmdUI* pCmdUI);
	afx_msg void OnEditCopy();
	afx_msg void OnUpdateEditPaste(CCmdUI* pCmdUI);
	afx_msg void OnEditPaste();
	afx_msg void OnUpdateEditDelete(CCmdUI* pCmdUI);
	afx_msg void OnEditDelete();
	afx_msg void OnUpdateEditInsert(CCmdUI* pCmdUI);
	afx_msg void OnEditInsert();
	afx_msg void OnEditSelectAll();
	afx_msg void OnUpdateEditUndo(CCmdUI* pCmdUI);
	afx_msg void OnEditUndo();
	afx_msg void OnUpdateEditRedo(CCmdUI* pCmdUI);
	afx_msg void OnEditRedo();
	afx_msg void OnHelpFinder();
	afx_msg void OnSetFocus(CWnd* pOldWnd);
	afx_msg int OnMouseActivate(CWnd* pDesktopWnd, UINT nHitTest, UINT message);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

// Dispatch maps
	//{{AFX_DISPATCH(CSongCtrl)
		// NOTE - ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DISPATCH
	DECLARE_DISPATCH_MAP()

// Event maps
	//{{AFX_EVENT(CSongCtrl)
		// NOTE - ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_EVENT
	DECLARE_EVENT_MAP()

// Interface Maps
public:
	// IOleInPlaceActiveObject
	BEGIN_INTERFACE_PART(MyOleInPlaceActiveObject, IOleInPlaceActiveObject)
		INIT_INTERFACE_PART(COleControl, MyOleInPlaceActiveObject)
		STDMETHOD(GetWindow)(HWND*);
		STDMETHOD(ContextSensitiveHelp)(BOOL);
		STDMETHOD(TranslateAccelerator)(LPMSG);
		STDMETHOD(OnFrameWindowActivate)(BOOL);
		STDMETHOD(OnDocWindowActivate)(BOOL);
		STDMETHOD(ResizeBorder)(LPCRECT, LPOLEINPLACEUIWINDOW, BOOL);
		STDMETHOD(EnableModeless)(BOOL);
	END_INTERFACE_PART(MyOleInPlaceActiveObject)

    // IDMUSProdEditor functions
	BEGIN_INTERFACE_PART(Editor, IDMUSProdEditor)
		STDMETHOD(AttachObjects)(IDMUSProdNode*);
		STDMETHOD(OnInitMenuFilePrint)(HMENU, UINT);
		STDMETHOD(OnFilePrint)();
		STDMETHOD(OnInitMenuFilePrintPreview)(HMENU, UINT);
		STDMETHOD(OnFilePrintPreview)();
		STDMETHOD(OnViewProperties)();
		STDMETHOD(OnF1Help)();
	END_INTERFACE_PART(Editor)

	DECLARE_INTERFACE_MAP()

// Dispatch and event IDs
public:
	enum {
	//{{AFX_DISP_ID(CSongCtrl)
		// NOTE: ClassWizard will add and remove enumeration elements here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DISP_ID
	};
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SONGCTL_H__D135DB66_66ED_11D3_B45D_00105A2796DE__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SongDesigner\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by SongDesignerDLL.rc
//
#define IDI_ABOUTDLL                    1
#define IDS_SONG                        2
#define IDD_ABOUTBOX_SONG               2
#define IDB_SONG                        2
#define IDS_SONG_PPG                    3
#define IDD_DLG_SONG                    101
#define IDD_TAB_SEGMENT_DESIGN          153
#define IDD_TAB_SEGMENT_RUNTIME         154
#define IDD_SET_LENGTH                  199
#define IDS_SONG_PPG_CAPTION            200
#define IDS_SONG_COMPONENT_NAME         201
#define IDS_HELP_FILE_EXT               202
#define IDS_ERR_INVALIDARG              203
#define IDR_SONG_DOCTYPE                204
#define IDI_SONG_DOCTYPE_SEL            205
#define IDS_ERR_REGISTER_CF             206
#define IDM_SONG_NODE_RMENU             207
#define IDI_SONGREF                     208
#define IDS_ERR_ADD_CLIPFORMAT          209
#define IDI_SONGREF_SEL                 210
#define IDS_ERR_ADD_IMAGELIST           211
#define IDS_ERR_MEMORY                  212
#define IDS_ERR_ADD_DOCTYPE             213
#define IDS_ERR_MISSING_CONDUCTOR       214
#define IDS_SONG_TEXT                   215
#define IDS_SONG_VERSION_TEXT           216
#define IDS_NO_SONG                     217
#define IDS_UNDO_SONG_NAME              218
#define IDS_UNDO_SONG_GUID              219
#define IDD_DUPLICATE_FILE              220
#define IDS_UNDO                        221
#define IDS_UNDO_ACCEL                  222
#define IDS_REDO                        223
#define IDS_REDO_ACCEL                  224
#define IDS_REDO_ACCEL2                 225
#define IDS_UNDO_SONG_DOWNLOAD_ALL      226
#define IDC_FILE_VERSION                227
#define IDS_UNDO_SONG_AUTHOR            228
#define IDS_UNDO_SONG_COPYRIGHT         229
#define IDS_UNDO_SONG_SUBJECT           230
#define IDC_AUTHOR                      231
#define IDS_UNDO_SONG_VERSION           232
#define IDC_COPYRIGHT                   233
#define IDC_LENGTH                      233
#define IDS_SONG_OBJECT_TEXT            234
#define IDC_VERSION_1                   235
#define IDC_VERSION_2                   236
#define IDC_LENGTH_SPIN                 236
#define IDM_FOLDER_SEGMENTS_NODE_RMENU  237
#define IDC_VERSION_3                   238
#define IDC_VERSION_4                   239
#define IDD_TAB_SONG                    240
#define IDC_NAME                        241
#define IDC_SUBJECT                     242
#define IDS_CONTAINER_NODE_NAME         243
#define IDS_UNDO_SONG_LOAD_ALL          244
#define IDS_ERR_MISSING_CONTAINER_DESIGNER 245
#define IDS_UNDO_SOURCE                 246
#define IDS_ERR_MISSING_SEGMENT_DESIGNER 247
#define IDM_DRAG_RMENU                  248
#define IDS_ERR_MISSING_AUDIOPATH_DESIGNER 249
#define IDC_BUTTON_LENGTH               249
#define IDR_SONG_EDITOR                 250
#define IDS_ERR_MISSING_TOOLGRAPH_DESIGNER 251
#define IDS_SEGMENTS_FOLDER_NAME        252
#define IDR_SONG_ACCELS                 253
#define IDS_TOOLGRAPHS_FOLDER_NAME      254
#define IDS_EMBED_FOLDER_NAME           255
#define IDS_REF_FOLDER_NAME             256
#define IDC_EDIT_PLAY_START_BAR         256
#define IDM_SONGREF_NODE_RMENU          257
#define IDS_DELETE_NODE_PROMPT          258
#define IDC_SPIN_PLAY_START_BAR         258
#define IDM_FOLDER_TOOLGRAPHS_NODE_RMENU 259
#define IDC_EDIT_PLAY_START_BEAT        259
#define IDS_EMPTY_TEXT                  260
#define IDC_SPIN_PLAY_START_BEAT        260
#define IDD_DLG_GUID                    261
#define IDC_EDIT_PLAY_START_GRID        261
#define IDS_V_EMPTY_TEXT                261
#define IDS_SEGMENT_TEXT                262
#define IDC_SPIN_PLAY_START_GRID        262
#define IDD_TAB_INFO                    263
#define IDC_EDIT_PLAY_START_TICK        263
#define IDS_VIRTUAL_SEGMENT_PREFIX_TEXT 263
#define IDS_NOT_SAVED                   264
#define IDC_SPIN_PLAY_START_TICK        264
#define IDS_UNKNOWN                     265
#define IDC_EDIT_LOOP_START_BAR         265
#define IDD_TAB_SEGMENT_FLAGS           266
#define IDC_SPIN_LOOP_START_BAR         266
#define IDS_SIZE_BYTES                  267
#define IDC_EDIT_LOOP_START_BEAT        267
#define IDC_SPIN_LOOP_START_BEAT        268
#define IDD_TAB_TRANSITION              268
#define IDS_SIZE_KB                     269
#define IDC_EDIT_LOOP_START_GRID        269
#define IDC_SPIN_LOOP_START_GRID        270
#define IDS_UNDO_SONG_INFO              271
#define IDC_EDIT_LOOP_START_TICK        271
#define IDD_TAB_VIRTUAL_SEGMENT_FLAGS   272
#define IDC_SPIN_LOOP_START_TICK        272
#define IDC_INFO                        273
#define IDD_TAB_VIRTUAL_SEGMENT         273
#define IDC_EDIT_LOOP_END_BAR           273
#define IDS_FILE_OPEN_SEGMENT           274
#define IDC_SPIN_LOOP_END_BAR           274
#define IDD_TAB_VIRTUAL_SEGMENT_LOOP    274
#define IDS_FILE_OPEN_ANY_SEGMENT       275
#define IDC_EDIT_LOOP_END_BEAT          275
#define IDS_DUPE_FILE_PROMPT1           276
#define IDC_SPIN_LOOP_END_BEAT          276
#define IDS_DUPE_FILE_PROMPT2           277
#define IDC_EDIT_LOOP_END_GRID          277
#define IDS_DUPE_FILE_PROMPT3           278
#define IDC_SPIN_LOOP_END_GRID          278
#define IDS_DUPE_FILE_PROMPT4           279
#define IDC_EDIT_LOOP_END_TICK          279
#define IDS_DUPE_FILE_PROMPT5           280
#define IDC_SPIN_LOOP_END_TICK          280
#define IDS_DUPE_FILE_PROMPT6           281
#define IDC_EDIT_LOOP_REPEAT            281
#define IDS_MULTIPLE_SEGMENTS_SELECTED  282
#define IDC_SPIN_LOOP_REPEAT            282
#define IDS_UNDO_CHANGE_SOURCE_TOOLGRAPH 283
#define IDC_EDIT_TRACK_GROUP            283
#define IDS_UNDO_DELETE_SOURCE_TOOLGRAPH 284
#define IDC_SPIN_TRACK_GROUP            284
#define IDS_UNDO_CHANGE_SOURCE_SEGMENT  285
#define IDC_COMBO_RESOLUTION            285
#define IDS_UNDO_DELETE_SOURCE_SEGMENT  286
#define IDS_UNDO_CHANGE_NEXT_SEGMENT    287
#define IDS_UNDO_DELETE_NEXT_SEGMENT    288
#define IDS_UNDO_ADD_VIRTUAL_SEGMENT    289
#define IDS_UNDO_DELETE_VIRTUAL_SEGMENT 290
#define IDS_UNDO_CHANGE_VIRTUAL_SEGMENT_NAME 291
#define IDS_DUPE_VIRTUAL_SEGMENT_NAME   292
#define IDS_NONE_TEXT                   293
#define IDC_RESET_LOOP                  293
#define IDS_UNDO_MOVE_VIRTUAL_SEGMENTS  294
#define IDS_ANY_TEXT                    295
#define IDS_UNDO_MOVE_TRANSITIONS       296
#define IDC_QUICK_RESPONSE              296
#define IDS_UNDO_ADD_TRANSITION         297
#define IDC_AFTER_PREPARE_TIME          297
#define IDS_UNDO_DELETE_TRACK           298
#define IDS_UNDO_DELETE_TRANSITION      299
#define IDC_CHECK_ALIGN                 299
#define IDC_COMBO_ALIGNMENT             300
#define IDS_UNDO_ADD_TRACK              301
#define IDC_STATIC_ALIGNMENT            301
#define IDC_CHECK_REPEAT_FOREVER        302
#define IDS_UNDO_MOVE_TRACKS            302
#define IDS_TRANSITION_TEXT             303
#define IDC_CHECK_AUDIOPATH             303
#define IDS_TRACK_TEXT                  304
#define IDC_CHECK_EXTEND_TIMESIG        304
#define IDS_VIRTUAL_SEGMENT_TEXT        305
#define IDI_FOLDER_SEL                  306
#define IDS_ERR_REG_OBJECT              306
#define IDI_FOLDER                      307
#define IDM_FOLDER_NODE_RMENU           308
#define IDM_SOURCE_SEGMENT_NODE_RMENU   309
#define IDC_EDIT_GUID                   310
#define IDM_VIRTUAL_SEGMENT_RMENU       311
#define IDC_NEW_GUID                    312
#define IDM_TRACK_RMENU                 313
#define IDC_DUPE_PROMPT                 314
#define IDM_TRANSITION_RMENU            315
#define IDC_USE_EXISTING                316
#define IDC_USE_EMBEDDED                317
#define IDC_KEEP_BOTH                   318
#define IDC_OK_ALL                      319
#define IDC_USE_EXISTING_ALL_FILES      320
#define IDC_USE_EMBEDDED_ALL_FILES      321
#define IDC_KEEP_BOTH_ALL_FILES         322
#define IDM_DRAG_MOVE                   323
#define IDM_DRAG_CANCEL                 324
#define IDM_DRAG_COPY                   325
#define IDC_LIST_VIRTUAL_SEGMENTS       326
#define IDC_EDIT_NAME                   327
#define IDC_LIST_TRANSITIONS            328
#define IDC_COMBO_SEGMENT               329
#define IDC_COMBO_NEXT_VIRTUAL_SEGMENT  330
#define IDC_LIST_TRACKS                 331
#define IDC_COMBO_TOOLGRAPH             332
#define IDC_COMBO_TO_SEGMENT            333
#define IDC_COMBO_TRANSITION_SEGMENT    334
#define IDM_PROPERTIES                  335
#define IDM_RENAME                      336
#define IDM_NEW_AUDIOPATH               337
#define IDM_NEW_CONTAINER               338
#define IDM_NEW_SOURCE_TOOLGRAPH        339
#define IDM_NEW_SOURCE_SEGMENT          340
#define IDM_DELETE                      341
#define IDM_LOCATE                      342
#define IDM_DELETE_VIRTUAL_SEGMENT      343
#define IDM_DELETE_TRACKS               344
#define IDM_DELETE_TRANSITIONS          345
#define IDM_INSERT_TRANSITION           346
#define IDM_INSERT_TRACK                347
#define IDM_TRACK_PROPERTIES            348
#define IDM_TRANSITION_PROPERTIES       349
#define IDM_VIRTUAL_SEGMENT_PROPERTIES  350
#define IDM_HELP_FINDER                 351
#define IDS_TO_TEXT                     352
#define IDS_TRAN_TEXT                   353
#define IDS_NEXT_BOUNDARY_TEXT          354
#define IDS_UNDO_TRACK_EXTRAS_FLAGS     355
#define IDD_DLG_ADD_TRACKS              356
#define IDS_UNDO_TRANSITION_FROM_SEGMENT 356
#define IDS_UNDO_TRANSITION_TRAN_SEGMENT 357
#define IDS_MULTIPLE_TRANSITIONS_SELECTED 358
#define IDS_UNDO_VIRTUAL_SEGMENT_START  359
#define IDB_TRANSITION                  359
#define IDS_UNDO_VIRTUAL_SEGMENT_LENGTH 360
#define IDS_UNDO_VIRTUAL_SEGMENT_LOOP_REPEATS 361
#define IDS_UNDO_VIRTUAL_SEGMENT_LOOP_START 362
#define IDS_UNDO_VIRTUAL_SEGMENT_LOOP_END 363
#define IDS_UNDO_VIRTUAL_SEGMENT_GROUP_BITS 364
#define IDS_INTRO_TEXT                  365
#define IDS_UNDO_VIRTUAL_SEGMENT_USE_AUDIOPATH 366
#define IDS_UNDO_VIRTUAL_SEGMENT_EXTEND_TIMESIG 367
#define IDS_UNDO_VIRTUAL_SEGMENT_BOUNDARY_FLAGS 368
#define IDS_UNDO_VIRTUAL_SEGMENT_RESET_LOOP 369
#define IDS_ERR_MIN_MAX                 370
#define IDS_CONTAINER_TEXT              371
#define IDS_AUDIOPATH_TEXT              372
#define IDS_INTRO_PROMPT                373
#define IDC_TRANSITION                  515
#define IDC_CHECK_INTRO                 516
#define IDC_STATIC_INTRO_PROMPT         517
#define IDC_DESIGN_MODIFIED             1015
#define IDC_DESIGN_FILENAME             1016
#define IDC_DESIGN_CREATE               1017
#define IDC_DESIGN_SIZE                 1019
#define IDC_RUNTIME_FILE                1043
#define IDC_RUNTIME_CREATE              1044
#define IDC_RUNTIME_MODIFIED            1045
#define IDC_RUNTIME_SIZE                1046
#define ID_EDIT_DELETE                  32777
#define IDM_INSERT_VIRTUAL_SEGMENT      32787
#define ID_EDIT_INSERT                  32796

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        360
#define _APS_NEXT_COMMAND_VALUE         32788
#define _APS_NEXT_CONTROL_VALUE         518
#define _APS_NEXT_SYMED_VALUE           103
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SongDesigner\SongDesignerDLL.cpp ===
// SongDesigner.cpp : Implementation of CSongDesignerApp and DLL registration.

#include "stdafx.h"
#include "StripMgr.h"
#include <RiffStrm.h>

#include <initguid.h>
#include "SongDesignerDLL.h"
#include "SongComponent.h"
#include <SegmentGuids.h>
#include <SegmentDesigner.h>
#include <ContainerDesigner.h>
#include <AudioPathDesigner.h>
#include <ToolGraphDesigner.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


CSongDesignerApp NEAR theApp;

const GUID CDECL BASED_CODE _tlid =
		{ 0x41606c30, 0x9721, 0x43ea, { 0xa9, 0x2c, 0x21, 0x96, 0xe0, 0x1e, 0x2e, 0xe8 } };
const WORD _wVerMajor = 1;
const WORD _wVerMinor = 0;


////////////////////////////////////////////////////////////////////////////
// CSongDesignerApp::InitInstance - DLL initialization

BOOL CSongDesignerApp::InitInstance()
{
	BOOL bInit = COleControlModule::InitInstance();

	if (bInit)
	{
		AfxEnableControlContainer();
	}

	m_pIPageManager = NULL;
	m_pSongComponent = NULL;

	m_pClipboardObject = NULL;
	m_pIClipboardDataObject = NULL;

	return bInit;
}


////////////////////////////////////////////////////////////////////////////
// CSongDesignerApp::ExitInstance - DLL termination

int CSongDesignerApp::ExitInstance()
{
	return COleControlModule::ExitInstance();
}


/////////////////////////////////////////////////////////////////////////////
// CSongDesignerApp::GetHelpFileName

BOOL CSongDesignerApp::GetHelpFileName( CString& strHelpFileName )
{
	TCHAR achHelpFileName[FILENAME_MAX];
	TCHAR achDrive[_MAX_DRIVE];
	TCHAR achDir[_MAX_DIR];
	TCHAR achFName[_MAX_FNAME];
	TCHAR achExt[_MAX_EXT];

	if( GetModuleFileName(NULL, achHelpFileName, FILENAME_MAX) > 0 )
	{
		_tsplitpath( achHelpFileName, achDrive, achDir, achFName, NULL );
		::LoadString( theApp.m_hInstance, IDS_HELP_FILE_EXT, achExt, _MAX_EXT );
		_tmakepath( achHelpFileName, achDrive, achDir, achFName, achExt );

		strHelpFileName = achHelpFileName;
		return TRUE;
	}

	return FALSE;
}


////////////////////////////////////////////////////////////////////////////
// CSongDesignerApp::SetNodePointers  (used by all components)

void CSongDesignerApp::SetNodePointers( IDMUSProdNode* pINode, IDMUSProdNode* pIDocRootNode, IDMUSProdNode* pIParentNode )
{
	HRESULT hr;
    IDMUSProdNode* pIChild;
    IDMUSProdNode* pINextChild;

	ASSERT( pINode != NULL );
	ASSERT( pIDocRootNode != NULL );

	pINode->SetDocRootNode( pIDocRootNode );    
	pINode->SetParentNode( pIParentNode );    

	hr = pINode->GetFirstChild( &pINextChild );

	while( SUCCEEDED( hr )  &&  pINextChild )
	{
		pIChild = pINextChild;

		SetNodePointers( pIChild, pIDocRootNode, pINode );

		hr = pINode->GetNextChild( pIChild, &pINextChild );
		RELEASE( pIChild );
	}
}


////////////////////////////////////////////////////////////////////////////
// CSongDesignerApp::PutDataInClipboard

BOOL CSongDesignerApp::PutDataInClipboard( IDataObject* pIDataObject, void* pObject )
{
	if( pIDataObject )
	{
		if( ::OleSetClipboard( pIDataObject ) == S_OK )
		{
			RELEASE( m_pIClipboardDataObject );

			m_pIClipboardDataObject = pIDataObject;
			m_pIClipboardDataObject->AddRef();

			m_pClipboardObject = pObject;

			return TRUE;
		}
	}

	return FALSE;
}


////////////////////////////////////////////////////////////////////////////
// CSongDesignerApp::FlushClipboard

void CSongDesignerApp::FlushClipboard( void* pClipboardObject )
{
	if( m_pClipboardObject == pClipboardObject )
	{
		ASSERT( m_pIClipboardDataObject != NULL );

		if( ::OleIsCurrentClipboard( m_pIClipboardDataObject ) == S_OK )
		{
			::OleFlushClipboard();
		}

		RELEASE( m_pIClipboardDataObject );

		m_pClipboardObject = NULL;
	}
}


////////////////////////////////////////////////////////////////////////////
// CSongDesignerApp::GetFileVersion  (used by all components)

BOOL CSongDesignerApp::GetFileVersion( LPTSTR szExeName, LPTSTR szFileVersion, short nFileVersionSize )
{
	DWORD dwBufferSize;
	DWORD dwReserved;
	
	dwBufferSize = GetFileVersionInfoSize( szExeName, &dwReserved );
	if( dwBufferSize > 0 )
	{
		void* pBuffer;

		pBuffer = (void *)malloc( dwBufferSize );
		if( pBuffer )
		{
			CString strTheFileVersion;
			VS_FIXEDFILEINFO* pFixedInfo;
			UINT nInfoSize;

			GetFileVersionInfo( szExeName, dwReserved, dwBufferSize, pBuffer );
			VerQueryValue( pBuffer, _T("\\"), (void **)&pFixedInfo, &nInfoSize );

			WORD wVer1 = HIWORD( pFixedInfo->dwFileVersionMS );
			WORD wVer2 = LOWORD( pFixedInfo->dwFileVersionMS );
			WORD wVer3 = HIWORD( pFixedInfo->dwFileVersionLS );
			WORD wVer4 = LOWORD( pFixedInfo->dwFileVersionLS );

			strTheFileVersion.Format( _T("%u.%u.%u.%u"), wVer1, wVer2, wVer3, wVer4 );

			_tcsncpy( szFileVersion, strTheFileVersion, nFileVersionSize );

			free( pBuffer );
			return TRUE;
		}
	}

	return FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// SetRegString - Writes a string to system registry 

static BOOL SetRegString( HKEY hKey, LPCTSTR lpSubKey, LPTSTR lpValueName, LPCTSTR lpszString )
{
	HKEY  hKeyOpen;
	DWORD dwCbData;
	LONG  lResult;
	DWORD dwDisposition;
	BOOL  fSuccess = FALSE;

	lResult = RegCreateKeyEx( hKey, lpSubKey, 0, 0, REG_OPTION_NON_VOLATILE,
							  KEY_ALL_ACCESS, NULL, &hKeyOpen, &dwDisposition );
	if( lResult == ERROR_SUCCESS )
	{
		dwCbData = _tcslen(lpszString)+1; // Assume ASCII  This is BAD!!!!!

		lResult = RegSetValueEx( hKeyOpen, lpValueName, 0, REG_SZ, (LPBYTE)lpszString, dwCbData);

		if( lResult == ERROR_SUCCESS )
		{
			fSuccess = TRUE;
		}

		RegCloseKey( hKeyOpen );
	}

	return fSuccess;
}


/////////////////////////////////////////////////////////////////////////////
// SetRegDWORD - Writes a DWORD to system registry 

static BOOL SetRegDWORD( HKEY hKey, LPCTSTR lpSubKey,
						 LPTSTR lpValueName, LPDWORD lpDWORD, BOOL fOverWrite )
{
	HKEY  hKeyOpen;
	DWORD dwCbData;
	LONG  lResult;
	DWORD dwDisposition;
	DWORD dwType;
	BOOL  fSuccess = FALSE;

	lResult = RegCreateKeyEx( hKey, lpSubKey, 0, 0, REG_OPTION_NON_VOLATILE,
							  KEY_ALL_ACCESS, NULL, &hKeyOpen, &dwDisposition );
	if( lResult == ERROR_SUCCESS )
	{

		lResult = ::RegQueryValueEx( hKeyOpen, lpValueName, NULL, &dwType, NULL, NULL );

		if( (lResult != ERROR_SUCCESS)
		||  (dwType != REG_DWORD)
		||  (fOverWrite == TRUE) )
		{
			dwCbData = sizeof( DWORD );
			lResult = RegSetValueEx( hKeyOpen, lpValueName, 0, REG_DWORD, (LPBYTE)lpDWORD, dwCbData);

			if( lResult == ERROR_SUCCESS )
			{
				fSuccess = TRUE;
			}
		}
		else
		{
			fSuccess = TRUE;
		}

		RegCloseKey( hKeyOpen );
	}

	return fSuccess;
}


/////////////////////////////////////////////////////////////////////////////
// RegisterComponents - Adds registry entries for DMUS Producer components

static BOOL RegisterComponents( void )
{
    LPOLESTR psz1;
    LPOLESTR psz2;
    LPOLESTR psz3;
    LPOLESTR psz4;
	TCHAR    szRegPath[MAX_BUFFER];
	TCHAR	 szCLSID[SMALL_BUFFER];
	TCHAR	 szInProcServer32[SMALL_BUFFER];
	TCHAR	 szThreadingModel[SMALL_BUFFER];
	TCHAR	 szApartment[SMALL_BUFFER];
    TCHAR    szOCXPath[MAX_BUFFER];
    TCHAR    szOCXLongPath[MAX_BUFFER];
    TCHAR    szGuid1[MID_BUFFER];
    TCHAR    szGuid2[MID_BUFFER];
    TCHAR    szGuid3[MID_BUFFER];
    TCHAR    szGuid4[MID_BUFFER];
    CString  strName;
    TCHAR    szComponentPath[MAX_BUFFER];
	TCHAR	 szSkip[SMALL_BUFFER];
	DWORD    dwSkip = 0;
    TCHAR    szContainerPath[MAX_BUFFER];
    
	GetModuleFileName( theApp.m_hInstance, szOCXLongPath, MAX_BUFFER ); 
	// This needs to be the short name, since the AfxRegister... functions
	// use the short name. (Except for AfxOleRegisterTypeLib()).
	// The type library is still using the long filename, hopefully that's ok.
	GetShortPathName( szOCXLongPath, szOCXPath, MAX_BUFFER);

	_tcscpy( szCLSID, _T("CLSID") );
	_tcscpy( szInProcServer32, _T("InProcServer32") );
	_tcscpy( szThreadingModel, _T("ThreadingModel") );
	_tcscpy( szApartment, _T("Apartment") );

	_tcscpy( szComponentPath, _T("Software\\Microsoft\\DMUSProducer\\Components\\") );
	_tcscpy( szSkip, _T("Skip") );

	_tcscpy( szContainerPath, _T("Software\\Microsoft\\DMUSProducer\\Container Objects\\") );
	
// Register Song Editor Component
    if( SUCCEEDED( StringFromIID(CLSID_SongEditor, &psz1) ) )
    {
        WideCharToMultiByte( CP_ACP, 0, psz1, -1, szGuid1, sizeof(szGuid1), NULL, NULL );
        CoTaskMemFree( psz1 );
		strName.LoadString( IDS_SONG_COMPONENT_NAME );

		_tcscpy( szRegPath, szCLSID );
		_tcscat( szRegPath, _T("\\") );
		_tcscat( szRegPath, szGuid1 );
		if( !(SetRegString(HKEY_CLASSES_ROOT, szRegPath, _T(""), strName)) )
		{
			return FALSE;
		}

		_tcscat( szRegPath, _T("\\") );
		_tcscat( szRegPath, szInProcServer32 );
		if( !(SetRegString(HKEY_CLASSES_ROOT, szRegPath, _T(""), szOCXPath))
		||  !(SetRegString(HKEY_CLASSES_ROOT, szRegPath, szThreadingModel, szApartment)) )
		{
			return FALSE;
		}
	}
    if( SUCCEEDED( StringFromIID(CLSID_SongComponent, &psz1) ) )
    {
        WideCharToMultiByte( CP_ACP, 0, psz1, -1, szGuid1, sizeof(szGuid1), NULL, NULL );
        CoTaskMemFree( psz1 );
		strName.LoadString( IDS_SONG_COMPONENT_NAME );

		_tcscpy( szRegPath, szCLSID );
		_tcscat( szRegPath, _T("\\") );
		_tcscat( szRegPath, szGuid1 );
		if( !(SetRegString(HKEY_CLASSES_ROOT, szRegPath, _T(""), strName)) )
		{
			return FALSE;
		}

		_tcscat( szRegPath, _T("\\") );
		_tcscat( szRegPath, szInProcServer32 );
		if( !(SetRegString(HKEY_CLASSES_ROOT, szRegPath, _T(""), szOCXPath))
		||  !(SetRegString(HKEY_CLASSES_ROOT, szRegPath, szThreadingModel, szApartment)) )
		{
			return FALSE;
		}

		_tcscpy( szRegPath, szComponentPath );
		_tcscat( szRegPath, szGuid1 );
		if( !(SetRegString(HKEY_LOCAL_MACHINE, szRegPath, _T(""), strName))
		||  !(SetRegDWORD(HKEY_LOCAL_MACHINE, szRegPath, szSkip, &dwSkip, FALSE)) )
		{
			return FALSE;
		}

		if( SUCCEEDED( StringFromIID(GUID_SongNode, &psz1) ) 
		&&  SUCCEEDED( StringFromIID(GUID_SongRefNode, &psz2) ) 
		&&  SUCCEEDED( StringFromIID(CLSID_SongComponent, &psz3) ) 
		&&  SUCCEEDED( StringFromIID(CLSID_DirectMusicSong, &psz4) ) )
		{
			WideCharToMultiByte( CP_ACP, 0, psz1, -1, szGuid1, sizeof(szGuid1), NULL, NULL );
			CoTaskMemFree( psz1 );
			WideCharToMultiByte( CP_ACP, 0, psz2, -1, szGuid2, sizeof(szGuid2), NULL, NULL );
			CoTaskMemFree( psz2 );
			WideCharToMultiByte( CP_ACP, 0, psz3, -1, szGuid3, sizeof(szGuid3), NULL, NULL );
			CoTaskMemFree( psz3 );
			WideCharToMultiByte( CP_ACP, 0, psz4, -1, szGuid4, sizeof(szGuid4), NULL, NULL );
			CoTaskMemFree( psz4 );
			strName.LoadString( IDS_SONG_OBJECT_TEXT );

			_tcscpy( szRegPath, szContainerPath );
			_tcscat( szRegPath, szGuid1 );
			if( !(SetRegString(HKEY_LOCAL_MACHINE, szRegPath, _T(""), strName))
			||  !(SetRegString(HKEY_LOCAL_MACHINE, szRegPath, _T("RefNode"), szGuid2)) 
			||  !(SetRegString(HKEY_LOCAL_MACHINE, szRegPath, _T("Component"), szGuid3)) 
			||  !(SetRegString(HKEY_LOCAL_MACHINE, szRegPath, _T("DMObject"), szGuid4)) )
			{
				return FALSE;
			}
		}
		else
		{
			return FALSE;
		}
    }
	else
	{
		return FALSE;
	}

	return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	/*
	if( !AfxOleRegisterTypeLib(AfxGetInstanceHandle(), _tlid) )
	{
		return ResultFromScode(SELFREG_E_TYPELIB);
	}

	if( !COleObjectFactoryEx::UpdateRegistryAll(TRUE) )
	{
		return ResultFromScode(SELFREG_E_CLASS);
	}
	*/

	if( !RegisterComponents() )
	{
		return ResultFromScode(SELFREG_E_FIRST+2);
	}

	return NOERROR;
}


/////////////////////////////////////////////////////////////////////////////
// UnregisterComponents - Removes registry entries for DMUS Producer components

static BOOL UnregisterComponents( void )
{
    LPOLESTR psz;
	TCHAR    szRegPath[MAX_BUFFER];
	TCHAR	 szCLSID[SMALL_BUFFER];
    TCHAR    szGuid[MID_BUFFER];
    TCHAR    szComponentPath[MAX_BUFFER];
    TCHAR    szContainerPath[MAX_BUFFER];
	TCHAR	 szRefNode[SMALL_BUFFER];
    
	_tcscpy( szCLSID, _T("CLSID") );
	_tcscpy( szComponentPath, _T("Software\\Microsoft\\DMUSProducer\\Components\\") );
	_tcscpy( szContainerPath, _T("Software\\Microsoft\\DMUSProducer\\Container Objects\\") );
	_tcscpy( szRefNode, _T("RefNode") );
	
// Unregister Song Editor Component
    if( SUCCEEDED( StringFromIID(CLSID_SongEditor, &psz) ) )
    {
        WideCharToMultiByte( CP_ACP, 0, psz, -1, szGuid, sizeof(szGuid), NULL, NULL );
        CoTaskMemFree( psz );

		_tcscpy( szRegPath, szCLSID );
		_tcscat( szRegPath, _T("\\") );
		_tcscat( szRegPath, szGuid );
		_tcscat( szRegPath, _T("\\") );
		_tcscat( szRegPath, _T("InProcServer32") );
		// First delete the subkey
		if( RegDeleteKey(HKEY_CLASSES_ROOT, szRegPath) != ERROR_SUCCESS )
		{
			return FALSE;
		}

		_tcscpy( szRegPath, szCLSID );
		_tcscat( szRegPath, _T("\\") );
		_tcscat( szRegPath, szGuid );
		// Then the main key
		if( RegDeleteKey(HKEY_CLASSES_ROOT, szRegPath) != ERROR_SUCCESS )
		{
			return FALSE;
		}
	}
    if( SUCCEEDED( StringFromIID(CLSID_SongComponent, &psz) ) )
    {
        WideCharToMultiByte( CP_ACP, 0, psz, -1, szGuid, sizeof(szGuid), NULL, NULL );
        CoTaskMemFree( psz );

		_tcscpy( szRegPath, szCLSID );
		_tcscat( szRegPath, _T("\\") );
		_tcscat( szRegPath, szGuid );
		_tcscat( szRegPath, _T("\\") );
		_tcscat( szRegPath, _T("InProcServer32") );
		// First delete the subkey
		if( RegDeleteKey(HKEY_CLASSES_ROOT, szRegPath) != ERROR_SUCCESS )
		{
			return FALSE;
		}

		_tcscpy( szRegPath, szCLSID );
		_tcscat( szRegPath, _T("\\") );
		_tcscat( szRegPath, szGuid );
		// Then the main key
		if( RegDeleteKey(HKEY_CLASSES_ROOT, szRegPath) != ERROR_SUCCESS )
		{
			return FALSE;
		}

		_tcscpy( szRegPath, szComponentPath );
		_tcscat( szRegPath, szGuid );
		if( RegDeleteKey(HKEY_LOCAL_MACHINE, szRegPath) != ERROR_SUCCESS )
		{
			return FALSE;
		}

		if( SUCCEEDED( StringFromIID(GUID_SongNode, &psz) ) )
		{
			WideCharToMultiByte( CP_ACP, 0, psz, -1, szGuid, sizeof(szGuid), NULL, NULL );
			CoTaskMemFree( psz );

			_tcscpy( szRegPath, szContainerPath );
			_tcscat( szRegPath, szGuid );
			if( RegDeleteKey(HKEY_LOCAL_MACHINE, szRegPath) != ERROR_SUCCESS )
			{
				return FALSE;
			}
		}
		else
		{
			return FALSE;
		}
    }
	else
	{
		return FALSE;
	}

	return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	/*
	if( !AfxOleUnregisterTypeLib(_tlid, _wVerMajor, _wVerMinor) )
	{
		return ResultFromScode(SELFREG_E_TYPELIB);
	}

	if( !COleObjectFactoryEx::UpdateRegistryAll(FALSE) )
	{
		return ResultFromScode(SELFREG_E_CLASS);
	}
	*/

	if( !UnregisterComponents() )
	{
		return ResultFromScode(SELFREG_E_FIRST+2);
	}

	return NOERROR;
}


/////////////////////////////////////////////////////////////////////////////
// DllCanUnloadNow

STDAPI DllCanUnloadNow()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    return AfxDllCanUnloadNow();
}


//////////////////////////////////////////////////////////////////////////////
// CClassFactory
//
// Class factory object for creating any object implemented by this DLL.
//

typedef  HRESULT (__stdcall CreateInstanceFunc) (IUnknown *punkOuter,
    REFIID riid, void **ppv);

class CClassFactory : public IClassFactory
{
///// IUnknown implementation
protected:
    ULONG	m_dwRef;         // interface reference count
public:
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv)
    {
        if (IsEqualIID(riid, IID_IUnknown) ||
            IsEqualIID(riid, IID_IClassFactory))
        {
            *ppv = (LPVOID) this;
            AddRef();
            return NOERROR;
        }
        else
        {
            *ppv = NULL;
            return E_NOINTERFACE;
        }
    }
    STDMETHODIMP_(ULONG) AddRef()
    {
        return ++m_dwRef;
    }
    STDMETHODIMP_(ULONG) Release()
    {
        if (--m_dwRef == 0L)
        {
            delete this;
            return 0;
        }
        else
            return m_dwRef;
    }

///// IClassFactory implementation
protected:
    CreateInstanceFunc *m_pfunc;    // function that creates an object instance
public:
    STDMETHODIMP CreateInstance(LPUNKNOWN punkOuter, REFIID riid, LPVOID *ppv)
    {
        return (*m_pfunc)(punkOuter, riid, ppv);
    }
    STDMETHODIMP LockServer(BOOL fLock)
    {
        if( fLock )
        {
			AfxOleLockApp(); 
        }
        else
        {
			AfxOleUnlockApp(); 
        }

        return NOERROR;
    }

///// Construction
    CClassFactory(CreateInstanceFunc *pfunc) : m_pfunc(pfunc)
	{
		m_dwRef = 0;
	}
};

//////////////////////////////////////////////////////////////////////////////
// CREATE_INSTANCE macro
//

#define CREATE_INSTANCE( cls ) STDAPI cls##_CreateInstance( LPUNKNOWN /*punkOuter*/, REFIID riid, LPVOID *ppv ) \
{ \
    HRESULT   hrReturn; \
    cls* pthis; \
    pthis = new cls; \
    if( pthis == NULL ) \
    { \
        return E_OUTOFMEMORY; \
    } \
    hrReturn = pthis->QueryInterface( riid, ppv ); \
    if( FAILED( hrReturn ) ) \
    { \
        delete pthis; \
        *ppv = NULL; \
    } \
    return hrReturn; \
}

CREATE_INSTANCE( CSongComponent )


/////////////////////////////////////////////////////////////////////////////
// DllGetClassObject

STDAPI DllGetClassObject( REFCLSID rclsid, REFIID riid, LPVOID *ppv )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	*ppv = NULL;

    // this DLL can only create class factory objects that support
    // IUnknown and IClassFactory
    if( !IsEqualIID(riid, IID_IUnknown)
    &&  !IsEqualIID(riid, IID_IClassFactory) )
	{
        return E_NOINTERFACE;
	}

// point <pfunc> to a function that can create a new object instance
    CreateInstanceFunc *pfunc;

    if( IsEqualCLSID(rclsid, CLSID_SongComponent) )
	{
        pfunc = CSongComponent_CreateInstance;
		if( ( *ppv = static_cast<void*>( static_cast<IClassFactory *>( new CClassFactory( pfunc ) ) ) ) == NULL )
		{
			return E_OUTOFMEMORY;
		}
	    static_cast<IUnknown*>( *ppv )->AddRef();
	}
    else if( IsEqualCLSID(rclsid, CLSID_SongEditor) )
	{
		AfxDllGetClassObject( rclsid, riid, ppv );
		if( *ppv == NULL )
		{
			return E_OUTOFMEMORY;
		}
	}
    else
	{
        return E_FAIL;
	}

    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SongDesigner\SongComponent.cpp ===
// SongComponent.cpp : implementation file
//

#include "stdafx.h"

#include "SongDesignerDLL.h"
#include "Song.h"
#include "SongRef.h"
#include "DupeFileDlg.h"
#include <SegmentDesigner.h>
#include <ContainerDesigner.h>
#include <AudioPathDesigner.h>
#include <ToolGraphDesigner.h>
#include <dmusici.h>


/////////////////////////////////////////////////////////////////////////////
// CSongComponent constructor/destructor 

CSongComponent::CSongComponent()
{
    m_dwRef = 0;
	
	m_pISongDocType8 = NULL;

	m_pIFramework8 = NULL;
	m_pIDMPerformance8 = NULL;
	m_pIConductor = NULL;

	m_pISegmentComponent = NULL;
	m_pIContainerComponent = NULL;
	m_pIAudioPathComponent = NULL;
	m_pIToolGraphComponent = NULL;
	
	m_nFirstImage = 0;
	m_nNextSong = 0;

	m_dwEmbeddedFileListUseCount = 0;
	m_pIEmbeddedFileStream = NULL;
	m_pEmbeddedFileRootFile = NULL;
	m_pSongBeingLoaded = NULL;
	m_pIDupeFileTargetProject = NULL;
	m_nDupeFileDlgReturnCode = 0;

	m_cfProducerFile = 0;
	m_cfSong = 0;
	m_cfSongList = 0;
	m_cfSegment = 0;
	m_cfContainer = 0;
	m_cfAudioPath = 0;
	m_cfGraph = 0;
}

CSongComponent::~CSongComponent()
{
	ReleaseAll();
}


/////////////////////////////////////////////////////////////////////////////
// CSongComponent::ReleaseAll

void CSongComponent::ReleaseAll( void )
{
 	CDirectMusicSong* pSong;
	while( !m_lstSongs.IsEmpty() )
	{
		pSong = static_cast<CDirectMusicSong*>( m_lstSongs.RemoveHead() );
		RELEASE( pSong );
	}

 	RegisteredTrack* pRegisteredTrack;
	while( !m_lstRegisteredTracks.IsEmpty() )
	{
		pRegisteredTrack = m_lstRegisteredTracks.RemoveHead();
		delete pRegisteredTrack;
	}

 	RegisteredObject* pRegisteredObject;
	while( !m_lstRegisteredObjects.IsEmpty() )
	{
		pRegisteredObject = static_cast<RegisteredObject*>( m_lstRegisteredObjects.RemoveHead() );
		delete pRegisteredObject;
	}

	ASSERT( m_lstEmbeddedFiles.IsEmpty() );
 	EmbeddedFile* pEmbeddedFile;
	while( !m_lstEmbeddedFiles.IsEmpty() )
	{
		pEmbeddedFile = static_cast<EmbeddedFile*>( m_lstEmbeddedFiles.RemoveHead() );
		delete pEmbeddedFile;
	}
	m_dwEmbeddedFileListUseCount = 0;
	RELEASE( m_pIEmbeddedFileStream );

	if( m_pEmbeddedFileRootFile )
	{
		delete m_pEmbeddedFileRootFile;
		m_pEmbeddedFileRootFile = NULL;
	}

	RELEASE( m_pIToolGraphComponent );
	RELEASE( m_pIAudioPathComponent );
	RELEASE( m_pIContainerComponent );
	RELEASE( m_pISegmentComponent );
	RELEASE( m_pIFramework8 );
	RELEASE( m_pISongDocType8 );
	RELEASE( m_pIDMPerformance8 );
	RELEASE( m_pIConductor );
}


/////////////////////////////////////////////////////////////////////////////
// CSongComponent::LoadRegisteredObjects

BOOL CSongComponent::LoadRegisteredObjects( void )
{
	HKEY	  hKeyOpen;
	HKEY	  hKeyOpenClsId;
	DWORD	  dwIndex;
	LONG	  lResult;
	DWORD	  dwType;
	DWORD	  dwCbData;
	FILETIME  ftFileTime;
	wchar_t	  awchBuffer[MID_BUFFER << 1];
	_TCHAR	  achClsId[MID_BUFFER];
	_TCHAR	  achGuid[MID_BUFFER];
	RegisteredObject* pRegisteredObject;

	lResult = ::RegOpenKeyEx( HKEY_LOCAL_MACHINE,
						  	  _T("Software\\Microsoft\\DMUSProducer\\Container Objects"),
							  0, KEY_READ, &hKeyOpen );
	if( lResult != ERROR_SUCCESS )
	{
		AfxMessageBox( IDS_ERR_REG_OBJECT);
		return FALSE;
	}

	dwIndex = 0;
	for( ; ; )
	{
		dwCbData = MID_BUFFER;
		lResult  = ::RegEnumKeyEx( hKeyOpen, dwIndex++, achClsId, &dwCbData,
								   NULL, NULL, NULL, &ftFileTime );
		if( lResult == ERROR_NO_MORE_ITEMS )
		{
			break;
		}
		if( lResult != ERROR_SUCCESS )
		{
			AfxMessageBox( IDS_ERR_REG_OBJECT);
			break;
		}

		lResult    = ::RegOpenKeyEx( hKeyOpen, achClsId,
								     0, KEY_QUERY_VALUE, &hKeyOpenClsId );
		if( lResult == ERROR_SUCCESS )
		{
			// We have another registered object
			pRegisteredObject = new RegisteredObject();
			
			if( pRegisteredObject )
			{
				// Store GUID of Node
				if( MultiByteToWideChar( CP_ACP, 0, achClsId, -1, awchBuffer, sizeof(awchBuffer) / sizeof(wchar_t) ) != 0 )
				{
					IIDFromString( awchBuffer, &pRegisteredObject->guidNodeId );
				}

				// Store object type of Node
				dwCbData = MID_BUFFER;
				lResult  = ::RegQueryValueEx( hKeyOpenClsId, _T(""), NULL,
											  &dwType, (LPBYTE)&achGuid, &dwCbData );
				if( (lResult == ERROR_SUCCESS)
				&&  (dwType == REG_SZ) )
				{
					pRegisteredObject->strObjectType = achGuid;
				}

				// Store GUID of RefNode
				dwCbData = MID_BUFFER;
				lResult  = ::RegQueryValueEx( hKeyOpenClsId, _T("RefNode"), NULL,
											  &dwType, (LPBYTE)&achGuid, &dwCbData );
				if( (lResult == ERROR_SUCCESS)
				&&  (dwType == REG_SZ) )
				{
					if( MultiByteToWideChar( CP_ACP, 0, achGuid, -1, awchBuffer, sizeof(awchBuffer) / sizeof(wchar_t) ) != 0 )
					{
						IIDFromString( awchBuffer, &pRegisteredObject->guidRefNodeId );
					}
				}
			
				// Store CLSID of Component
				dwCbData = MID_BUFFER;
				lResult  = ::RegQueryValueEx( hKeyOpenClsId, _T("Component"), NULL,
											  &dwType, (LPBYTE)&achGuid, &dwCbData );
				if( (lResult == ERROR_SUCCESS)
				&&  (dwType == REG_SZ) )
				{
					if( MultiByteToWideChar( CP_ACP, 0, achGuid, -1, awchBuffer, sizeof(awchBuffer) / sizeof(wchar_t) ) != 0 )
					{
						IIDFromString( awchBuffer, &pRegisteredObject->clsidComponent );
					}
				}
			
				// Store CLSID of corresponding DirectMusic object
				dwCbData = MID_BUFFER;
				lResult  = ::RegQueryValueEx( hKeyOpenClsId, _T("DMObject"), NULL,
											  &dwType, (LPBYTE)&achGuid, &dwCbData );
				if( (lResult == ERROR_SUCCESS)
				&&  (dwType == REG_SZ) )
				{
					if( MultiByteToWideChar( CP_ACP, 0, achGuid, -1, awchBuffer, sizeof(awchBuffer) / sizeof(wchar_t) ) != 0 )
					{
						IIDFromString( awchBuffer, &pRegisteredObject->clsidDMObject );
					}
				}

				// Place registered object in list
				m_lstRegisteredObjects.AddTail( pRegisteredObject );
			}
			
			::RegCloseKey( hKeyOpenClsId );
		}
	}

	::RegCloseKey( hKeyOpen );

	return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
// CSongComponent::FindRegisteredObjectByCLSID

RegisteredObject* CSongComponent::FindRegisteredObjectByCLSID( CLSID clsidDMObject )
{
	RegisteredObject* pTheRegisteredObject = NULL;

	RegisteredObject* pRegisteredObject;
	POSITION pos = m_lstRegisteredObjects.GetHeadPosition();
	while( pos )
	{
		pRegisteredObject = m_lstRegisteredObjects.GetNext( pos );

		if( ::IsEqualGUID( pRegisteredObject->clsidDMObject, clsidDMObject ) )
		{
			pTheRegisteredObject = pRegisteredObject;
			break;
		}
	}

	return pTheRegisteredObject;
}


/////////////////////////////////////////////////////////////////////////////
// CSongComponent::FindRegisteredObjectByRIFFIds

RegisteredObject* CSongComponent::FindRegisteredObjectByRIFFIds( DWORD dwRIFFckid, DWORD dwRIFFfccType )
{
	RegisteredObject* pTheRegisteredObject = NULL;

	RegisteredObject* pRegisteredObject;
	POSITION pos = m_lstRegisteredObjects.GetHeadPosition();
	while( pos )
	{
		pRegisteredObject = m_lstRegisteredObjects.GetNext( pos );

		if( pRegisteredObject->dwRIFFckid == 0
		&&  pRegisteredObject->dwRIFFfccType == 0 )
		{
			// Needs to be initialized!
			// Can't initialize in LoadRegisteredObjects() because
			// Components still in process of loading and all DocTypes
			// have not been registered
			IDMUSProdDocType* pIDocType;
			if( SUCCEEDED ( m_pIFramework8->FindDocTypeByNodeId( pRegisteredObject->guidNodeId, &pIDocType ) ) )
			{
				IDMUSProdDocType8* pIDocType8;
				if( SUCCEEDED ( pIDocType->QueryInterface( IID_IDMUSProdDocType8, (void**)&pIDocType8 ) ) )
				{
					DWORD dwRIFFckid;
					DWORD dwRIFFfccType;
					if( SUCCEEDED ( pIDocType8->GetObjectRiffId( pRegisteredObject->guidNodeId, &dwRIFFckid, &dwRIFFfccType ) ) )
					{
						pRegisteredObject->dwRIFFckid = dwRIFFckid;
						pRegisteredObject->dwRIFFfccType = dwRIFFfccType;
					}
			
					RELEASE( pIDocType8 );
				}

				RELEASE( pIDocType );
			}
		}

		if( pRegisteredObject->dwRIFFckid == dwRIFFckid
		&&  pRegisteredObject->dwRIFFfccType == dwRIFFfccType )
		{
			pTheRegisteredObject = pRegisteredObject;
			break;
		}
	}

	return pTheRegisteredObject;
}


/////////////////////////////////////////////////////////////////////////////
// CSongComponent IUnknown implementation

HRESULT CSongComponent::QueryInterface( REFIID riid, LPVOID FAR* ppvObj )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    if( ::IsEqualIID(riid, IID_IDMUSProdComponent)
	||  ::IsEqualIID(riid, IID_IUnknown) )
    {
        AddRef();
        *ppvObj = (IDMUSProdComponent *)this;
        return S_OK;
    }

    if( ::IsEqualIID(riid, IID_IDMUSProdRIFFExt) )
    {
        AddRef();
        *ppvObj = (IDMUSProdRIFFExt *)this;
        return S_OK;
    }
	
    if( ::IsEqualIID(riid, IID_IDMUSProdUnpackingFiles) )
    {
        AddRef();
        *ppvObj = (IDMUSProdUnpackingFiles *)this;
        return S_OK;
    }

    *ppvObj = NULL;
    return E_NOINTERFACE;
}

ULONG CSongComponent::AddRef()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	AfxOleLockApp(); 
    return ++m_dwRef;
}

ULONG CSongComponent::Release()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    ASSERT( m_dwRef != 0 );

	AfxOleUnlockApp(); 
    --m_dwRef;

    if( m_dwRef == 0 )
    {
        delete this;
        return 0;
    }

    return m_dwRef;
}


/////////////////////////////////////////////////////////////////////////////
// CSongComponent IDMUSProdComponent implementation

/////////////////////////////////////////////////////////////////////////////
// CSongComponent IDMUSProdComponent::Initialize

HRESULT CSongComponent::Initialize( IDMUSProdFramework* pIFramework, BSTR* pbstrErrMsg )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	TCHAR achErrMsg[MID_BUFFER];
	CString strErrMsg;

	if( m_pIFramework8 )		// already initialized
	{
		return S_OK;
	}

	ASSERT( pIFramework != NULL );
	ASSERT( pbstrErrMsg != NULL );

	if( pbstrErrMsg == NULL )
	{
		return E_POINTER;
	}

	if( pIFramework == NULL )
	{
		::LoadString( theApp.m_hInstance, IDS_ERR_INVALIDARG, achErrMsg, MID_BUFFER );
		strErrMsg = achErrMsg;
		*pbstrErrMsg = strErrMsg.AllocSysString();
		return E_INVALIDARG;
	}

	// Get IDMUSProdFramework8 interface pointers
	if( FAILED ( pIFramework->QueryInterface( IID_IDMUSProdFramework8, (void**)&m_pIFramework8 ) ) )
	{
		m_pIFramework8 = NULL;
		ReleaseAll();
		::LoadString( theApp.m_hInstance, IDS_ERR_INVALIDARG, achErrMsg, MID_BUFFER );
		strErrMsg = achErrMsg;
		*pbstrErrMsg = strErrMsg.AllocSysString();
		return E_FAIL;
	}

	theApp.m_pSongComponent = this;
//	theApp.m_pSongComponent->AddRef();	intentionally missing

	// Get IConductor and IDirectMusicPerformance interface pointers 
	IDMUSProdComponent* pIComponent = NULL;
	IUnknown* pIUnknown = NULL;
	if( FAILED ( pIFramework->FindComponent( CLSID_CConductor,  &pIComponent ) )
	||  FAILED ( pIComponent->QueryInterface( IID_IDMUSProdConductor, (void**)&m_pIConductor ) )
	||  FAILED ( m_pIConductor->GetPerformanceEngine( (IUnknown**)&pIUnknown ) ) 
	||  FAILED ( pIUnknown->QueryInterface( IID_IDirectMusicPerformance8, (void**)&m_pIDMPerformance8 ) ) )
	{
		ReleaseAll();
		RELEASE( pIComponent );
		RELEASE( pIUnknown );
		::LoadString( theApp.m_hInstance, IDS_ERR_MISSING_CONDUCTOR, achErrMsg, MID_BUFFER );
		strErrMsg = achErrMsg;
		*pbstrErrMsg = strErrMsg.AllocSysString();
		return E_FAIL;
	}
	RELEASE( pIComponent );
	RELEASE( pIUnknown );

	// Get IDMUSProdComponent for Segment Designer
	if( FAILED ( pIFramework->FindComponent( CLSID_SegmentComponent, &m_pISegmentComponent ) ) )
	{
		ReleaseAll();
		::LoadString( theApp.m_hInstance, IDS_ERR_MISSING_SEGMENT_DESIGNER, achErrMsg, MID_BUFFER );
		strErrMsg = achErrMsg;
		*pbstrErrMsg = strErrMsg.AllocSysString();
		return E_FAIL;
	}

	// Get IDMUSProdComponent for Container Designer
	if( FAILED ( pIFramework->FindComponent( CLSID_ContainerComponent, &m_pIContainerComponent ) ) )
	{
		ReleaseAll();
		::LoadString( theApp.m_hInstance, IDS_ERR_MISSING_CONTAINER_DESIGNER, achErrMsg, MID_BUFFER );
		strErrMsg = achErrMsg;
		*pbstrErrMsg = strErrMsg.AllocSysString();
		return E_FAIL;
	}

	// Get IDMUSProdComponent for AudioPath Designer
	if( FAILED ( pIFramework->FindComponent( CLSID_AudioPathComponent, &m_pIAudioPathComponent ) ) )
	{
		ReleaseAll();
		::LoadString( theApp.m_hInstance, IDS_ERR_MISSING_AUDIOPATH_DESIGNER, achErrMsg, MID_BUFFER );
		strErrMsg = achErrMsg;
		*pbstrErrMsg = strErrMsg.AllocSysString();
		return E_FAIL;
	}

	// Get IDMUSProdComponent for ToolGraph Designer
	if( FAILED ( pIFramework->FindComponent( CLSID_ToolGraphComponent, &m_pIToolGraphComponent ) ) )
	{
		ReleaseAll();
		::LoadString( theApp.m_hInstance, IDS_ERR_MISSING_TOOLGRAPH_DESIGNER, achErrMsg, MID_BUFFER );
		strErrMsg = achErrMsg;
		*pbstrErrMsg = strErrMsg.AllocSysString();
		return E_FAIL;
	}

	// Add applicable images to the Project Tree control's image list 
	if( FAILED ( AddNodeImageLists() ) )
	{
		ReleaseAll();
		::LoadString( theApp.m_hInstance, IDS_ERR_ADD_IMAGELIST, achErrMsg, MID_BUFFER );
		strErrMsg = achErrMsg;
		*pbstrErrMsg = strErrMsg.AllocSysString();
		return E_FAIL;
	}

	// Register clipboard formats
	if( RegisterClipboardFormats() == FALSE )
	{
		ReleaseAll();
		::LoadString( theApp.m_hInstance, IDS_ERR_REGISTER_CF, achErrMsg, MID_BUFFER );
		strErrMsg = achErrMsg;
		*pbstrErrMsg = strErrMsg.AllocSysString();
		return E_FAIL;
	}

	// Register the clipboard format for an .snp file 
	CString strExt = _T(".snp");
	BSTR bstrExt = strExt.AllocSysString();
	if( FAILED ( pIFramework->RegisterClipFormatForFile(m_cfSong, bstrExt) ) )
	{
		ReleaseAll();
		::LoadString( theApp.m_hInstance, IDS_ERR_ADD_CLIPFORMAT, achErrMsg, MID_BUFFER );
		strErrMsg = achErrMsg;
		*pbstrErrMsg = strErrMsg.AllocSysString();
		return E_FAIL;
	}

	// Register applicable doc types with the Framework 
	m_pISongDocType8 = new CSongDocType;
    if( m_pISongDocType8 == NULL )
	{
		ReleaseAll();
		::LoadString( theApp.m_hInstance, IDS_ERR_MEMORY, achErrMsg, MID_BUFFER );
		strErrMsg = achErrMsg;
		*pbstrErrMsg = strErrMsg.AllocSysString();
		return E_OUTOFMEMORY;
	}

	m_pISongDocType8->AddRef();

	if( FAILED ( pIFramework->AddDocType(m_pISongDocType8) ) )
	{
		ReleaseAll();
		::LoadString( theApp.m_hInstance, IDS_ERR_ADD_DOCTYPE, achErrMsg, MID_BUFFER );
		strErrMsg = achErrMsg;
		*pbstrErrMsg = strErrMsg.AllocSysString();
		return E_FAIL;
	}

	// Load registered tracks
	LoadRegisteredTracks();

	// Load registered objects
	LoadRegisteredObjects();

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CSongComponent IDMUSProdComponent::CleanUp

HRESULT CSongComponent::CleanUp( void )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Release references to Songs
	CDirectMusicSong *pSong;
	while( !m_lstSongs.IsEmpty() )
	{
		pSong = static_cast<CDirectMusicSong*>( m_lstSongs.RemoveHead() );
		RELEASE( pSong );
	}
	
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CSongComponent IDMUSProdComponent::GetName

HRESULT CSongComponent::GetName( BSTR* pbstrName )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CString strName;
	TCHAR achBuffer[MID_BUFFER];

	if( ::LoadString(theApp.m_hInstance, IDS_SONG_COMPONENT_NAME, achBuffer, MID_BUFFER) )
	{
		strName = achBuffer;
	}

    *pbstrName = strName.AllocSysString();

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CSongComponent::IDMUSProdComponent::AllocReferenceNode

HRESULT CSongComponent::AllocReferenceNode( GUID guidRefNodeId, IDMUSProdNode** ppIRefNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( ppIRefNode == NULL )
	{
		return E_POINTER;
	}

	*ppIRefNode = NULL;

	// Make sure Component can create Nodes of type guidRefNodeId
	if( !( IsEqualGUID ( guidRefNodeId, GUID_SongRefNode ) ) )
	{
		return E_INVALIDARG;
	}

	// Create SongRefNode
	CSongRef* pSongRef = new CSongRef;
	if( pSongRef == NULL )
	{
		return E_OUTOFMEMORY ;
	}

	*ppIRefNode = (IDMUSProdNode *)pSongRef;
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CSongComponent IDMUSProdComponent::OnActivateApp

HRESULT CSongComponent::OnActivateApp( BOOL fActivate )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(fActivate);

	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CSongComponent IDMUSProdRIFFExt::LoadRIFFChunk

HRESULT CSongComponent::LoadRIFFChunk( IStream* pIStream, IDMUSProdNode** ppINode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CDirectMusicSong* pSong;
	HRESULT hr;

	ASSERT( pIStream != NULL );
	ASSERT( m_pIFramework8 != NULL );

	if( ppINode == NULL )
	{
		return E_POINTER;
	}

	*ppINode = NULL;

	// Create a new Song 
	pSong = new CDirectMusicSong;
	if( pSong == NULL )
	{
		return E_OUTOFMEMORY ;
	}

	// Create the Undo Manager
	if( pSong->CreateUndoMgr() == FALSE )
	{
		pSong->Release();
		return E_OUTOFMEMORY;
	}

	// Load Song file
	hr = pSong->Load( pIStream );
	if( FAILED ( hr ) )
	{
		pSong->Release();
		return hr;
	}

	*ppINode = (IDMUSProdNode *)pSong;
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CSongComponent IDMUSProdUnpackingFiles implementation

/////////////////////////////////////////////////////////////////////////////
// CSongComponent IDMUSProdUnpackingFiles::GetDocRootOfEmbeddedFile

HRESULT CSongComponent::GetDocRootOfEmbeddedFile( IUnknown* pIDocType, BSTR bstrObjectName, IUnknown** ppIDocRootNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pIFramework8 != NULL );

	CString strObjectName;
	if( bstrObjectName == NULL )
	{
		return E_INVALIDARG;
	}
	else
	{
		strObjectName = bstrObjectName;
		::SysFreeString( bstrObjectName );
	}

	if( ppIDocRootNode == NULL )
	{
		return E_POINTER;
	}
	*ppIDocRootNode = NULL;

	if( pIDocType == NULL )
	{
		return E_INVALIDARG;
	}

	HRESULT hr = E_FAIL;

	POSITION pos = m_lstEmbeddedFiles.GetHeadPosition();
	while( pos )
	{
		EmbeddedFile* pEmbeddedFile = m_lstEmbeddedFiles.GetNext( pos );

		ASSERT( pEmbeddedFile->dwStreamPos != 0 );	// temporary check

		if( strObjectName.CompareNoCase( pEmbeddedFile->strObjectName ) == 0 )
		{
			// Object names are equal
			RegisteredObject* pRegisteredObject = FindRegisteredObjectByCLSID( pEmbeddedFile->guidDMClass );
			if( pRegisteredObject )
			{
				// Check to see if CLSID is type of object we want
				IDMUSProdDocType* pIDocTypeList;
				if( SUCCEEDED ( m_pIFramework8->FindDocTypeByNodeId( pRegisteredObject->guidNodeId, &pIDocTypeList ) ) )
				{
					if( pIDocTypeList == pIDocType )
					{
						// This is the object we are looking for...
						if( pEmbeddedFile->fBeingLoaded )
						{
							// We are already in the process of loading this file
							hr = E_PENDING;
						}
						else
						{
							// Set m_pIEmbeddedFileStream position
							DWORD dwOrigStreamPos = StreamTell( m_pIEmbeddedFileStream );
							StreamSeek( m_pIEmbeddedFileStream, pEmbeddedFile->dwStreamPos, 0 );

							*ppIDocRootNode = LoadEmbeddedSegment( m_pIEmbeddedFileStream );
							if( *ppIDocRootNode )
							{
								hr = S_OK;
							}

							// Restore original m_pIEmbeddedFileStream position
							StreamSeek( m_pIEmbeddedFileStream, dwOrigStreamPos, 0 );
						}

						RELEASE( pIDocTypeList );
						break;
					}
				
					RELEASE( pIDocTypeList );
				}
			}
		}
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CSongComponent IDMUSProdUnpackingFiles::AddToNotifyWhenLoadFinished

HRESULT CSongComponent::AddToNotifyWhenLoadFinished( IUnknown* pIDocType, BSTR bstrObjectName, IUnknown* punkNotifySink, GUID* pguidFile )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pIFramework8 != NULL );

	if( pguidFile )
	{
		*pguidFile = GUID_AllZeros;
	}

	CString strObjectName;
	if( bstrObjectName == NULL )
	{
		return E_INVALIDARG;
	}
	else
	{
		strObjectName = bstrObjectName;
		::SysFreeString( bstrObjectName );
	}

	if( pguidFile == NULL )
	{
		return E_POINTER;
	}

	if( pIDocType == NULL 
	||  punkNotifySink == NULL )
	{
		return E_INVALIDARG;
	}

	HRESULT hr = E_FAIL;

	POSITION pos = m_lstEmbeddedFiles.GetHeadPosition();
	while( pos )
	{
		EmbeddedFile* pEmbeddedFile = m_lstEmbeddedFiles.GetNext( pos );

		ASSERT( pEmbeddedFile->dwStreamPos != 0 );	// temporary check

		if( strObjectName.CompareNoCase( pEmbeddedFile->strObjectName ) == 0 )
		{
			// Object names are equal
			RegisteredObject* pRegisteredObject = FindRegisteredObjectByCLSID( pEmbeddedFile->guidDMClass );
			if( pRegisteredObject )
			{
				// Check to see if CLSID is type of object we want
				IDMUSProdDocType* pIDocTypeList;
				if( SUCCEEDED ( m_pIFramework8->FindDocTypeByNodeId( pRegisteredObject->guidNodeId, &pIDocTypeList ) ) )
				{
					if( pIDocTypeList == pIDocType )
					{
						// This is the object we are looking for...
						if( pEmbeddedFile->fBeingLoaded )
						{
							// Add pINotifySink to embedded file's notification list
							IDMUSProdNotifySink* pINotifySink;
							if( SUCCEEDED ( punkNotifySink->QueryInterface( IID_IDMUSProdNotifySink, (void **)&pINotifySink ) ) )
							{
								pEmbeddedFile->m_lstNotifyWhenLoadFinished.AddTail( pINotifySink );
								*pguidFile = pEmbeddedFile->guidNotification;
								hr = S_OK;
							}
						}

						RELEASE( pIDocTypeList );
						break;
					}
				
					RELEASE( pIDocTypeList );
				}
			}
		}
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CSongComponent additional functions

/////////////////////////////////////////////////////////////////////////////
// CSongComponent::AddNodeImageLists

HRESULT CSongComponent::AddNodeImageLists( void )
{
	CImageList lstImages;
	HICON hIcon;

	lstImages.Create( 16, 16, ILC_COLOR16, 4, 0 );
	lstImages.SetBkColor( GetSysColor(COLOR_WINDOW) );

	hIcon = ::LoadIcon( theApp.m_hInstance, MAKEINTRESOURCE(IDR_SONG_DOCTYPE) );
	lstImages.Add( hIcon );
	::DestroyIcon( hIcon );
	hIcon = ::LoadIcon( theApp.m_hInstance, MAKEINTRESOURCE(IDI_SONG_DOCTYPE_SEL) );
	lstImages.Add( hIcon );
	::DestroyIcon( hIcon );

	hIcon = ::LoadIcon( theApp.m_hInstance, MAKEINTRESOURCE(IDI_SONGREF) );
	lstImages.Add( hIcon );
	::DestroyIcon( hIcon );
	hIcon = ::LoadIcon( theApp.m_hInstance, MAKEINTRESOURCE(IDI_SONGREF_SEL) );
	lstImages.Add( hIcon );
	::DestroyIcon( hIcon );

	hIcon = ::LoadIcon( theApp.m_hInstance, MAKEINTRESOURCE(IDI_FOLDER) );
	lstImages.Add( hIcon );
	::DestroyIcon( hIcon );
	hIcon = ::LoadIcon( theApp.m_hInstance, MAKEINTRESOURCE(IDI_FOLDER_SEL) );
	lstImages.Add( hIcon );
	::DestroyIcon( hIcon );

	if( FAILED (m_pIFramework8->AddNodeImageList( lstImages.Detach(), &m_nFirstImage ) ) )
	{
		return E_FAIL;
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CSongComponent::RegisterClipboardFormats

BOOL CSongComponent::RegisterClipboardFormats( void )
{
	m_cfProducerFile = ::RegisterClipboardFormat( CF_DMUSPROD_FILE );
	m_cfSong = ::RegisterClipboardFormat( CF_SONG );
	m_cfSongList = ::RegisterClipboardFormat( CF_SONGLIST );
	m_cfSegment = ::RegisterClipboardFormat( CF_SEGMENT );
	m_cfContainer = ::RegisterClipboardFormat( CF_CONTAINER );
	m_cfAudioPath = ::RegisterClipboardFormat( CF_AUDIOPATH );
	m_cfGraph = ::RegisterClipboardFormat( CF_GRAPH );
	m_cfVirtualSegmentList = ::RegisterClipboardFormat( CF_VIRTUAL_SEGMENT_LIST );
	m_cfTrackList = ::RegisterClipboardFormat( CF_TRACK_LIST );
	m_cfTransitionList = ::RegisterClipboardFormat( CF_TRANSITION_LIST );

	if( m_cfProducerFile == 0
	||  m_cfSong == 0
	||  m_cfSongList == 0 
	||  m_cfSegment == 0
	||  m_cfContainer == 0
	||  m_cfAudioPath == 0
	||  m_cfGraph == 0
	||  m_cfVirtualSegmentList == 0
	||  m_cfTrackList == 0
	||  m_cfTransitionList == 0 )
	{
		return FALSE;
	}

	return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
// CSongComponent::LoadRegisteredTracks

HRESULT CSongComponent::LoadRegisteredTracks( void )
{
	HKEY	  hKeyOpen;
	HKEY	  hKeyOpenClsId;
	DWORD	  dwType;
	DWORD	  dwCbData;
	FILETIME  ftFileTime;
	_TCHAR	  achClsId[MID_BUFFER];
	_TCHAR	  achName[MID_BUFFER];

	LONG lResult = ::RegOpenKeyEx( HKEY_LOCAL_MACHINE,
							  	   _T("Software\\Microsoft\\DMUSProducer\\StripEditors"),
								   0, KEY_READ, &hKeyOpen );
	if( lResult != ERROR_SUCCESS )
	{
		return S_FALSE;
	}

	HRESULT hr = S_FALSE;

	DWORD dwIndex = 0;
	for( ; ; )
	{
		dwCbData = MID_BUFFER;
		lResult  = ::RegEnumKeyEx( hKeyOpen, dwIndex++, achClsId, &dwCbData,
								   NULL, NULL, NULL, &ftFileTime );
		if( lResult != ERROR_SUCCESS )
		{
			break;
		}

		_tcscpy( achName, _T("") );
		lResult    = ::RegOpenKeyEx( hKeyOpen, achClsId,
								     0, KEY_QUERY_VALUE, &hKeyOpenClsId );
		if( lResult == ERROR_SUCCESS )
		{
			dwCbData = MID_BUFFER;
			lResult  = ::RegQueryValueEx( hKeyOpenClsId, _T(""), NULL,
										  &dwType, (LPBYTE)&achName, &dwCbData );
			if( (lResult == ERROR_SUCCESS)
			&&  (dwType == REG_SZ) )
			{
				CLSID clsid;
				wchar_t awchClsId[80];

				if( MultiByteToWideChar( CP_ACP, 0, achClsId, -1, awchClsId, sizeof(awchClsId) / sizeof(wchar_t) ) != 0 )
				{
					IIDFromString( awchClsId, &clsid );

					RegisteredTrack* pRegisteredTrack = new RegisteredTrack;
					if( pRegisteredTrack )
					{
						pRegisteredTrack->clsidTrack = clsid;
						pRegisteredTrack->strName = achName;

						m_lstRegisteredTracks.AddTail( pRegisteredTrack );
						hr = S_OK;
					}
				}
			}

			::RegCloseKey( hKeyOpenClsId );
		}
	}

	::RegCloseKey( hKeyOpen );

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CSongComponent::GetRegisteredTrackName

void CSongComponent::GetRegisteredTrackName( CLSID clsidTrack, CString& strName )
{
	strName.Empty();

	POSITION pos = m_lstRegisteredTracks.GetHeadPosition();
	while( pos )
	{
		RegisteredTrack* pRegisteredTrack = m_lstRegisteredTracks.GetNext( pos );

		if( ::IsEqualGUID( pRegisteredTrack->clsidTrack, clsidTrack ) )
		{
			strName = pRegisteredTrack->strName;
			break;
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CSongComponent::GetSongImageIndex

HRESULT CSongComponent::GetSongImageIndex( short* pnFirstImage )
{
	*pnFirstImage = (short)(m_nFirstImage + FIRST_SONG_IMAGE);
	
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CSongComponent::GetSongRefImageIndex

HRESULT CSongComponent::GetSongRefImageIndex( short* pnFirstImage )
{
	*pnFirstImage = (short)(m_nFirstImage + FIRST_SONGREF_IMAGE);
	
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CSongComponent::GetFolderImageIndex

HRESULT CSongComponent::GetFolderImageIndex( short* pnFirstImage )
{
	*pnFirstImage = (short)(m_nFirstImage + FIRST_FOLDER_IMAGE);
	
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CSongComponent::DetermineAction

int CSongComponent::DetermineAction( IDMUSProdNode* pIDocRootNode, IStream* pIStream, IDMUSProdNode** ppIDupeDocRootNode )
{
	int nReturn = IDC_KEEP_BOTH;

	IDMUSProdNode* pIDupeFileNode = NULL;

	if( ppIDupeDocRootNode == NULL )
	{
		return nReturn;
	}
	*ppIDupeDocRootNode = NULL;

	if( pIDocRootNode == NULL 
	||  pIStream == NULL )
	{
		return nReturn;
	}

	// Get guidNodeId of pIDocRootNode
	GUID guidNodeId;
	if( FAILED ( pIDocRootNode->GetNodeId( &guidNodeId ) ) )
	{
		return nReturn;
	}

	// Get DocRoot of pIDocRootNode
	IDMUSProdDocType* pIDocType = NULL;
	if( FAILED ( m_pIFramework8->FindDocTypeByNodeId( guidNodeId, &pIDocType ) ) )
	{
		return nReturn;
	}

	// Initialize the DMUS_OBJECTDESC structure
	DMUS_OBJECTDESC dmusObjectDesc;
	memset( &dmusObjectDesc, 0, sizeof(DMUS_OBJECTDESC) );
	dmusObjectDesc.dwSize = sizeof(DMUS_OBJECTDESC);

	CString strDupeFileNodeName;

	// Get object descriptor for pIDocRootNode
	IDMUSProdDocType8* pIDocType8;
	if( SUCCEEDED ( pIDocType->QueryInterface( IID_IDMUSProdDocType8, (void**)&pIDocType8 ) ) )
	{
		if( SUCCEEDED ( pIDocType8->GetObjectDescriptorFromNode( pIDocRootNode, &dmusObjectDesc ) ) )
		{
			IDMUSProdProject* pINextProject;
			IDMUSProdProject* pIProject;
			IDMUSProdNode* pINextFileNode;
			IDMUSProdNode* pIFileNode;
			DMUSProdListInfo ListInfo;

			// Search all files in the Project Tree for a matching object descriptor
			HRESULT hrProject = m_pIFramework8->GetFirstProject( &pINextProject );

			while( (pIDupeFileNode == NULL)  &&  SUCCEEDED( hrProject )  &&  pINextProject )
			{
				pIProject = pINextProject;

				HRESULT hrFile = pIProject->GetFirstFileByDocType( pIDocType, &pINextFileNode );

				while( (pIDupeFileNode == NULL)  &&  (hrFile == S_OK) )
				{
					pIFileNode = pINextFileNode;

					ZeroMemory( &ListInfo, sizeof(ListInfo) );
					ListInfo.wSize = sizeof(ListInfo);

					if( SUCCEEDED ( pIFileNode->GetNodeListInfo ( &ListInfo ) ) )
					{
						CString strName;
						if( ListInfo.bstrName )
						{
							strName = ListInfo.bstrName;
							::SysFreeString( ListInfo.bstrName );
						}
						if( ListInfo.bstrDescriptor )
						{
							::SysFreeString( ListInfo.bstrDescriptor );
						}

						if( (strName == dmusObjectDesc.wszName)
						&&  (::IsEqualGUID(ListInfo.guidObject, dmusObjectDesc.guidObject)) )
						{
							strDupeFileNodeName = strName;
							pIDupeFileNode = pIFileNode;
							pIDupeFileNode->AddRef();
						}
					}

					if( pIDupeFileNode == NULL )
					{
						hrFile = pIProject->GetNextFileByDocType( pIFileNode, &pINextFileNode );
					}
					RELEASE( pIFileNode );
				}
			
				if( pIDupeFileNode == NULL )
				{
					hrProject = m_pIFramework8->GetNextProject( pIProject, &pINextProject );
				}
				RELEASE( pIProject );
			}
		}

		RELEASE( pIDocType8 );
	}

	if( pIDupeFileNode )
	{
		CDupeFileDlg dlgDupeFile;

		// Get Project name
		CString strProjectName;
		IDMUSProdProject* pIProject;
		if( SUCCEEDED ( m_pIFramework8->FindProject( pIDupeFileNode, &pIProject ) ) )
		{
			BSTR bstrProjectName;
			if( SUCCEEDED ( pIProject->GetName( &bstrProjectName ) ) )
			{
				strProjectName = bstrProjectName;
				::SysFreeString( bstrProjectName );
			}

			RELEASE( pIProject );
		}

		// Get Container's filename
		CString strContainerFileName;
		IDMUSProdPersistInfo* pIPersistInfo;
		if( SUCCEEDED ( pIStream->QueryInterface( IID_IDMUSProdPersistInfo, (void **)&pIPersistInfo ) ) )
		{
			BSTR bstrContainerFileName;
			if( SUCCEEDED ( pIPersistInfo->GetFileName( &bstrContainerFileName ) ) )
			{
				strContainerFileName = bstrContainerFileName;
				::SysFreeString( bstrContainerFileName );
			}

			TCHAR achFileName[FILENAME_MAX];
			TCHAR achFName[_MAX_FNAME];
			TCHAR achExt[_MAX_EXT];

			_tsplitpath( strContainerFileName, NULL, NULL, achFName, achExt );
			_tmakepath( achFileName, NULL, NULL, achFName, achExt );
			strContainerFileName = achFileName;

			RELEASE( pIPersistInfo );
		}
		
		// Prepare dialog's prompt text
		CString strText;
		CString strSegment;
		strSegment.LoadString( IDS_SEGMENT_TEXT );
		strSegment.MakeLower();
		AfxFormatString2( dlgDupeFile.m_strPrompt, IDS_DUPE_FILE_PROMPT1, strProjectName, strSegment );
		AfxFormatString2( strText, IDS_DUPE_FILE_PROMPT2, strDupeFileNodeName, strContainerFileName );
		dlgDupeFile.m_strPrompt += strText;

		// Prepare dialog's 'Use Existing' prompt text
		AfxFormatString1( dlgDupeFile.m_strPromptUseExisting, IDS_DUPE_FILE_PROMPT3, strProjectName );

		// Prepare dialog's 'Use Embedded' prompt text
		AfxFormatString1( dlgDupeFile.m_strPromptUseEmbedded, IDS_DUPE_FILE_PROMPT4, strProjectName );

		// Prepare dialog's 'Keep Both' prompt text
		if( m_pIDupeFileTargetProject )
		{
			CString strTargetProjectName;
			BSTR bstrTargetProjectName;
			if( SUCCEEDED ( m_pIDupeFileTargetProject->GetName( &bstrTargetProjectName ) ) )
			{
				strTargetProjectName = bstrTargetProjectName;
				::SysFreeString( bstrTargetProjectName );
			}
			AfxFormatString1( dlgDupeFile.m_strPromptKeepBoth, IDS_DUPE_FILE_PROMPT5, strTargetProjectName );
		}
		else
		{
			dlgDupeFile.m_strPromptKeepBoth.LoadString( IDS_DUPE_FILE_PROMPT6 );
		}

		// Ask user what they want to do
		switch( m_nDupeFileDlgReturnCode )
		{
			case IDC_USE_EXISTING_ALL_FILES:
			case IDC_USE_EMBEDDED_ALL_FILES:
			case IDC_KEEP_BOTH_ALL_FILES:
				nReturn = m_nDupeFileDlgReturnCode;
				break;

			default:
				nReturn = dlgDupeFile.DoModal();
				if( nReturn == IDC_USE_EXISTING_ALL_FILES
				||  nReturn == IDC_USE_EMBEDDED_ALL_FILES
				||  nReturn == IDC_KEEP_BOTH_ALL_FILES )
				{
					m_nDupeFileDlgReturnCode = nReturn;
				}
				break;
		}

		switch( nReturn )
		{
			case IDC_USE_EXISTING:
			case IDC_USE_EXISTING_ALL_FILES:
			case IDC_USE_EMBEDDED:
			case IDC_USE_EMBEDDED_ALL_FILES:
				// Get the FileNode's DocRoot node
				GUID guidFile;
				if( SUCCEEDED ( m_pIFramework8->GetNodeFileGUID ( pIDupeFileNode, &guidFile ) ) )
				{
					IDMUSProdNode* pIDupeDocRootNode;
					if( SUCCEEDED ( m_pIFramework8->FindDocRootNodeByFileGUID(guidFile, &pIDupeDocRootNode) ) )
					{
						*ppIDupeDocRootNode = pIDupeDocRootNode;
					}
				}
				break;
			
			case IDC_KEEP_BOTH:
			case IDC_KEEP_BOTH_ALL_FILES:
				// Don't need to open the file to get the FileNode's DocRoot node
				break;

			default:
				// Should not happen!
				ASSERT( 0 );
				break;
		}
	}
		
	RELEASE( pIDupeFileNode );
	RELEASE( pIDocType );
	return nReturn;
}


/////////////////////////////////////////////////////////////////////////////
// CSongComponent::LoadEmbeddedSegment

IDMUSProdNode* CSongComponent::LoadEmbeddedSegment( IStream* pIStream )
{
	IDMUSProdNode*		pITheDocRootNode = NULL;
	IDMUSProdNode*		pITargetDirectoryNode = NULL;
	IDMUSProdNode*		pIDocRootNode;
	IDMUSProdNode*		pIDupeDocRootNode;
	IDMUSProdNode*		pINewDocRootNode;
	HRESULT				hr;

	ASSERT( m_pISegmentComponent != NULL );
	ASSERT( m_pIFramework8 != NULL );
	ASSERT( pIStream != NULL );

	// No need to load the segment again if it is already loaded
	EmbeddedFile* pTheEmbeddedFile = NULL;
	DWORD dwStreamPos = StreamTell( pIStream );
	POSITION pos = m_lstEmbeddedFiles.GetHeadPosition();
	while( pos )
	{
		EmbeddedFile* pEmbeddedFile = m_lstEmbeddedFiles.GetNext( pos );

		if( pEmbeddedFile->dwStreamPos == dwStreamPos )
		{
			pTheEmbeddedFile = pEmbeddedFile;

			if( ::IsEqualGUID(pEmbeddedFile->guidFile, GUID_AllZeros) == FALSE )
			{
				if( SUCCEEDED ( m_pIFramework8->FindDocRootNodeByFileGUID( pEmbeddedFile->guidFile, &pIDocRootNode ) ) )
				{
					return pIDocRootNode;
				}
			}
			break;
		}
	}
	ASSERT( pTheEmbeddedFile );	// Just to make sure the EmbeddedFile list was built correctly

	// Set flag to indicate we are in the process of loading this embedded file
	if( pTheEmbeddedFile )
	{
		pTheEmbeddedFile->fBeingLoaded = true;
	}

	IDMUSProdRIFFExt* pIRIFFExt;
	if( SUCCEEDED ( m_pISegmentComponent->QueryInterface( IID_IDMUSProdRIFFExt, (void**)&pIRIFFExt ) ) )
	{
		hr = pIRIFFExt->LoadRIFFChunk( pIStream, &pIDocRootNode );
		if( SUCCEEDED ( hr ) )
		{
			// Set root and parent node of ALL children
			theApp.SetNodePointers( pIDocRootNode, pIDocRootNode, NULL );

			int nReturn = DetermineAction( pIDocRootNode, pIStream, &pIDupeDocRootNode );

			switch( nReturn )
			{
				case IDC_USE_EXISTING:
				case IDC_USE_EXISTING_ALL_FILES:
					// Use the file in the Project Tree
					pITheDocRootNode = pIDupeDocRootNode;
					break;

				case IDC_USE_EMBEDDED:
				case IDC_USE_EMBEDDED_ALL_FILES:
				case IDC_KEEP_BOTH:
				case IDC_KEEP_BOTH_ALL_FILES:
				{
					// Get the target directory
					DMUSProdStreamInfo	StreamInfo;
					StreamInfo.pITargetDirectoryNode = NULL;

					// Get additional stream information
					IDMUSProdPersistInfo* pPersistInfo;
					if( SUCCEEDED ( pIStream->QueryInterface( IID_IDMUSProdPersistInfo, (void **)&pPersistInfo ) ) )
					{
						pPersistInfo->GetStreamInfo( &StreamInfo );
						pITargetDirectoryNode = StreamInfo.pITargetDirectoryNode;
						pPersistInfo->Release();
					}

					// Place embedded file in the Project Tree
					if( SUCCEEDED ( m_pIFramework8->CopyFile( pIDocRootNode, pITargetDirectoryNode, &pINewDocRootNode ) ) )
					{
						// Use the embedded file that was just placed in the Project Tree
						pITheDocRootNode = pINewDocRootNode;

						if( nReturn == IDC_USE_EMBEDDED 
						||  nReturn == IDC_USE_EMBEDDED_ALL_FILES )
						{
							if( pIDupeDocRootNode )
							{
								// Update all references to point to the new file
								m_pIFramework8->NotifyNodes( pIDupeDocRootNode, FRAMEWORK_FileReplaced, pINewDocRootNode );
								// Delete the duplicate file
								pIDupeDocRootNode->DeleteNode( FALSE );
							}
						}
					}
					RELEASE( pIDupeDocRootNode );
					break;
				}

				default:
					// Should not happen
					ASSERT( 0 );
					break;
			}

			pIDocRootNode->DeleteNode( FALSE );
			RELEASE( pIDocRootNode );
		}

		RELEASE( pIRIFFExt );
	}

	if( pTheEmbeddedFile )
	{
		pTheEmbeddedFile->fBeingLoaded = false;
	    
		if( pITheDocRootNode )
		{
			m_pIFramework8->GetNodeFileGUID( pITheDocRootNode, &pTheEmbeddedFile->guidFile );

			// Send FRAMEWORK_FileLoadFinished notifications
			while( !pTheEmbeddedFile->m_lstNotifyWhenLoadFinished.IsEmpty() )
			{
				IDMUSProdNotifySink* pINotifySink = pTheEmbeddedFile->m_lstNotifyWhenLoadFinished.RemoveHead();

				pINotifySink->OnUpdate( pITheDocRootNode, FRAMEWORK_FileLoadFinished, &pTheEmbeddedFile->guidNotification );  
				RELEASE( pINotifySink );
			}
		}
	}

	return pITheDocRootNode;
}


/////////////////////////////////////////////////////////////////////////////
// CSongComponent::AddToSongFileList

void CSongComponent::AddToSongFileList( CDirectMusicSong* pSong )
{
	if( pSong )
	{
		GUID guidSong;
		pSong->GetGUID( &guidSong );

		// Prevent duplicate object GUIDs
		GUID guidSongList;
		POSITION pos = m_lstSongs.GetHeadPosition();
		while( pos )
		{
			CDirectMusicSong* pSongList = m_lstSongs.GetNext( pos );

			pSongList->GetGUID( &guidSongList );
			if( ::IsEqualGUID( guidSongList, guidSong ) )
			{
				::CoCreateGuid( &guidSong );
				pSong->SetGUID( guidSong );
				break;
			}
		}

		// Add to list
		pSong->AddRef();
		m_lstSongs.AddTail( pSong );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CSongComponent::RemoveFromSongFileList

void CSongComponent::RemoveFromSongFileList( CDirectMusicSong* pSong )
{
	if( pSong )
	{
		// Remove from list
		POSITION pos = m_lstSongs.Find( pSong );
		if( pos )
		{
			m_lstSongs.RemoveAt( pos );
			pSong->Release();
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CSongComponent::CreateEmbeddedFileList

HRESULT CSongComponent::CreateEmbeddedFileList( IStream* pIStream )
{
	if( pIStream == NULL )
	{
		return E_INVALIDARG;
	}

	m_dwEmbeddedFileListUseCount++;

	if( m_dwEmbeddedFileListUseCount > 1 )
	{
		return S_OK;
	}

	m_pIEmbeddedFileStream = pIStream;
	m_pIEmbeddedFileStream->AddRef();

    IDMUSProdRIFFStream* pIRiffStream;
    MMCKINFO ckMain;
    HRESULT hr = S_OK;

	if( SUCCEEDED( AllocRIFFStream( pIStream, &pIRiffStream ) ) )
	{
		// Make sure the file containing this Container is stored in m_pEmbeddedFileRootFile
		DWORD dwCurrentFilePos = StreamTell( pIStream );
		if( dwCurrentFilePos > 0 )
		{
			MMCKINFO ckThisFile;

			StreamSeek( pIStream, 0, 0 );
			if( pIRiffStream->Descend( &ckThisFile, 0, 0 ) == 0 )
			{
				RegisteredObject* pRegisteredObject = FindRegisteredObjectByRIFFIds( ckThisFile.ckid, ckThisFile.fccType );
				if( pRegisteredObject )
				{
					IDMUSProdDocType* pIDocType;
					if( SUCCEEDED ( m_pIFramework8->FindDocTypeByNodeId( pRegisteredObject->guidNodeId, &pIDocType ) ) )
					{
						DMUSProdListInfo ListInfo;
						ZeroMemory( &ListInfo, sizeof(ListInfo) );
						ListInfo.wSize = sizeof(ListInfo);

						StreamSeek( pIStream, 0, 0 );
						if( SUCCEEDED ( pIDocType->GetListInfo ( pIStream, &ListInfo ) ) )
						{
							EmbeddedFile* pEmbeddedFile = new EmbeddedFile();
							if( pEmbeddedFile )
							{
								pEmbeddedFile->dwStreamPos = 0;
								pEmbeddedFile->fBeingLoaded = true;
								pEmbeddedFile->guidDMClass = pRegisteredObject->clsidDMObject;

								if( ListInfo.bstrName )
								{
									pEmbeddedFile->strObjectName = ListInfo.bstrName;
									::SysFreeString( ListInfo.bstrName );
								}
								if( ListInfo.bstrDescriptor )
								{
									::SysFreeString( ListInfo.bstrDescriptor );
								}
								memcpy( &pEmbeddedFile->guidObject, &ListInfo.guidObject, sizeof(GUID) );

								if( m_pEmbeddedFileRootFile )
								{
									// Names are equal
									if( pEmbeddedFile->strObjectName.Compare(m_pEmbeddedFileRootFile->strObjectName) == 0 )
									{
										// GUIDs are equal
										if( ::IsEqualGUID(pEmbeddedFile->guidDMClass, m_pEmbeddedFileRootFile->guidDMClass)
										&&  ::IsEqualGUID(pEmbeddedFile->guidObject, m_pEmbeddedFileRootFile->guidObject) )
										{
											// We must keep the notification GUID
											pEmbeddedFile->guidNotification = m_pEmbeddedFileRootFile->guidNotification;
										}
									}
									delete m_pEmbeddedFileRootFile;
									m_pEmbeddedFileRootFile = NULL;
								}
								m_pEmbeddedFileRootFile = pEmbeddedFile;
							}
						}

						RELEASE( pIDocType );
					}
				}
			}
			StreamSeek( pIStream, dwCurrentFilePos, 0 );
		}

		// Make sure all Source Segments embedded in this Song are placed in the EmbeddedFile list
		ckMain.fccType = DMUS_FOURCC_SONG_FORM;
		if( pIRiffStream->Descend( &ckMain, NULL, MMIO_FINDRIFF ) == 0 )
		{
			hr = ParseSongForEmbeddedSegments( pIRiffStream, &ckMain );
		}

		RELEASE( pIRiffStream );
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CSongComponent::ReleaseEmbeddedFileList

void CSongComponent::ReleaseEmbeddedFileList( void )
{
    ASSERT( m_dwEmbeddedFileListUseCount != 0 );

    m_dwEmbeddedFileListUseCount--;

    if( m_dwEmbeddedFileListUseCount == 0 )
    {
 		EmbeddedFile* pEmbeddedFile;
		while( !m_lstEmbeddedFiles.IsEmpty() )
		{
			pEmbeddedFile = static_cast<EmbeddedFile*>( m_lstEmbeddedFiles.RemoveHead() );
			delete pEmbeddedFile;
		}

		RELEASE( m_pIEmbeddedFileStream );
    }
}


/////////////////////////////////////////////////////////////////////////////
// CSongComponent::ParseSongForEmbeddedSegments

HRESULT CSongComponent::ParseSongForEmbeddedSegments( IDMUSProdRIFFStream* pIRiffStream, MMCKINFO* pckMain )
{
    IStream*    pIStream;
	MMCKINFO	ck;
	MMCKINFO	ckList;
    HRESULT     hr = S_OK;

    pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

    while( pIRiffStream->Descend( &ck, pckMain, 0 ) == 0 )
	{
        switch( ck.ckid )
		{
			case FOURCC_RIFF:
				switch( ck.fccType )
				{
					case DMUS_FOURCC_CONTAINER_FORM: 
						// Look for embedded Songs in this Song's Container
						hr = ParseContainerForEmbeddedSongs( pIRiffStream, &ck );
						if( FAILED ( hr ) )
						{
							goto ON_ERROR;
						}
						break;
				}
				break;

			case FOURCC_LIST:
				switch( ck.fccType )
				{
					case DMUS_FOURCC_SONGSEGMENTS_LIST:
						while( pIRiffStream->Descend( &ckList, &ck, 0 ) == 0 )
						{
							switch( ckList.ckid )
							{
								case FOURCC_LIST:
									switch( ckList.fccType )
									{
										case DMUS_FOURCC_SONGSEGMENT_LIST:
											hr = AddEmbeddedFileListItem( pIRiffStream, &ckList );
											if( FAILED ( hr ) )
											{
												ASSERT( 0 );
												goto ON_ERROR;
											}
											else if( hr == S_FALSE )
											{
												// File was referenced
												// Change S_FALSE to S_OK
												hr = S_OK;
											}
											break;
									}
							}
					        pIRiffStream->Ascend( &ckList, 0 );
						}
						break;
				}
				break;
        }

        pIRiffStream->Ascend( &ck, 0 );
    }

ON_ERROR:
    RELEASE( pIStream );
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CSongComponent::ParseContainerForEmbeddedSongs

HRESULT CSongComponent::ParseContainerForEmbeddedSongs( IDMUSProdRIFFStream* pIRiffStream, MMCKINFO* pckMain )
{
    IStream*    pIStream;
	MMCKINFO	ck;
	MMCKINFO	ckList;
	MMCKINFO	ckObject;
    HRESULT     hr = S_OK;

    pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

    while( pIRiffStream->Descend( &ck, pckMain, 0 ) == 0 )
	{
        switch( ck.ckid )
		{
			case FOURCC_LIST:
				switch( ck.fccType )
				{
					case DMUS_FOURCC_CONTAINED_OBJECTS_LIST:
						while( pIRiffStream->Descend( &ckList, &ck, 0 ) == 0 )
						{
							switch( ckList.ckid )
							{
								case FOURCC_LIST:
									switch( ckList.fccType )
									{
										case DMUS_FOURCC_CONTAINED_OBJECT_LIST:
											while( pIRiffStream->Descend( &ckObject, &ckList, 0 ) == 0 )
											{
												switch( ckObject.ckid )
												{
													case FOURCC_RIFF:
														switch( ckObject.fccType )
														{
															case DMUS_FOURCC_SONG_FORM:
																hr = ParseSongForEmbeddedSegments( pIRiffStream, &ckObject );
																if( FAILED ( hr ) )
																{
																	ASSERT( 0 );
																	goto ON_ERROR;
																}
																break;

															case DMUS_FOURCC_CONTAINER_FORM:
																hr = ParseContainerForEmbeddedSongs( pIRiffStream, &ckObject );
																if( FAILED ( hr ) )
																{
																	ASSERT( 0 );
																	goto ON_ERROR;
																}
																break;
														}
												}
										        pIRiffStream->Ascend( &ckObject, 0 );
											}
											break;
									}
							}
					        pIRiffStream->Ascend( &ckList, 0 );
						}
						break;
				}
				break;
        }

        pIRiffStream->Ascend( &ck, 0 );
    }

ON_ERROR:
    RELEASE( pIStream );
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CSongComponent::AddEmbeddedFileListItem

HRESULT CSongComponent::AddEmbeddedFileListItem( IDMUSProdRIFFStream* pIRiffStream, MMCKINFO* pckMain )
{
    IStream*    pIStream;
	MMCKINFO	ck;
	DWORD		dwStartFilePos;
	DWORD		dwInsideFilePos;
    HRESULT     hr = S_OK;

	EmbeddedFile* pEmbeddedFile = NULL;

    pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

    dwStartFilePos = StreamTell( pIStream );

	// Find DMUS_FOURCC_REF_LIST - Is file embedded or referenced?
	ck.fccType = DMUS_FOURCC_REF_LIST;
	if( pIRiffStream->Descend( &ck, pckMain, MMIO_FINDLIST ) == 0 )
	{
		// File is referenced, nothing more to do
		hr = S_FALSE;
		goto ON_ERROR;
	}

	// Process embedded file
	{
		StreamSeek( pIStream, dwStartFilePos, 0 );

		MMCKINFO ckEmbeddedFile;
		ckEmbeddedFile.ckid = FOURCC_RIFF;
		ckEmbeddedFile.fccType = DMUS_FOURCC_SEGMENT_FORM;

		if( pIRiffStream->Descend( &ckEmbeddedFile, pckMain, MMIO_FINDRIFF ) == 0 )
		{
			dwInsideFilePos = StreamTell( pIStream );
			StreamSeek( pIStream, -12, STREAM_SEEK_CUR );
		}
		else
		{
			ASSERT( 0 );
			hr = E_FAIL;
			goto ON_ERROR;
		}

		// Fill in the EmbeddedFile struct
		if( SUCCEEDED ( hr ) )
		{
			hr = E_FAIL;

			pEmbeddedFile = new EmbeddedFile();
			if( pEmbeddedFile == NULL )
			{
				hr = E_OUTOFMEMORY;
				goto ON_ERROR;
			}

			pEmbeddedFile->dwStreamPos = StreamTell( pIStream );
			pEmbeddedFile->guidDMClass = CLSID_DirectMusicSegment;

			// Get DocType for GUID_SegmentNode
			IDMUSProdDocType* pIDocType;
			if( SUCCEEDED ( m_pIFramework8->FindDocTypeByNodeId( GUID_SegmentNode, &pIDocType ) ) )
			{
				DMUSProdListInfo ListInfo;
				ZeroMemory( &ListInfo, sizeof(ListInfo) );
				ListInfo.wSize = sizeof(ListInfo);

				if( SUCCEEDED ( pIDocType->GetListInfo ( pIStream, &ListInfo ) ) )
				{
					if( ListInfo.bstrName )
					{
						pEmbeddedFile->strObjectName = ListInfo.bstrName;
						::SysFreeString( ListInfo.bstrName );
					}
					if( ListInfo.bstrDescriptor )
					{
						::SysFreeString( ListInfo.bstrDescriptor );
					}
					memcpy( &pEmbeddedFile->guidObject, &ListInfo.guidObject, sizeof(GUID) );

					hr = S_OK;
				}

				RELEASE( pIDocType );
			}
		}
	}

ON_ERROR:
	if( hr == S_OK )
	{
		if( pEmbeddedFile )
		{
			// Keep track of the embedded Segment's stream position
			m_lstEmbeddedFiles.AddTail( pEmbeddedFile );

			// Look for a container in this embedded Segment
			MMCKINFO ckEmbeddedFile;
			StreamSeek( pIStream, dwInsideFilePos, 0 );
			ckEmbeddedFile.fccType = DMUS_FOURCC_CONTAINER_FORM;
			if( pIRiffStream->Descend( &ckEmbeddedFile, NULL, MMIO_FINDRIFF ) == 0 )
			{
				// Look for embedded Songs in this Segment's Container
				hr = ParseContainerForEmbeddedSongs( pIRiffStream, &ckEmbeddedFile );
			}
		}
		else
		{
			hr = E_UNEXPECTED;
		}
	}
	else
	{
		if( pEmbeddedFile )
		{
			delete pEmbeddedFile;
		}
	}
    RELEASE( pIStream );
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CSongComponent::FindEmbeddedFile

EmbeddedFile* CSongComponent::FindEmbeddedFile( IDMUSProdDocType* pIDocType, CString& strObjectName )
{
	ASSERT( m_pIFramework8 != NULL );

	EmbeddedFile* pTheEmbeddedFile = NULL;

	// This 'private' method must also search m_pEmbeddedFileRootFile
	if( m_pEmbeddedFileRootFile )
	{
		if( strObjectName.CompareNoCase( m_pEmbeddedFileRootFile->strObjectName ) == 0 )
		{
			// Object names are equal
			RegisteredObject* pRegisteredObject = FindRegisteredObjectByCLSID( m_pEmbeddedFileRootFile->guidDMClass );
			if( pRegisteredObject )
			{
				// Check to see if CLSID is type of object we want
				IDMUSProdDocType* pIDocTypeList;
				if( SUCCEEDED ( m_pIFramework8->FindDocTypeByNodeId( pRegisteredObject->guidNodeId, &pIDocTypeList ) ) )
				{
					if( pIDocTypeList == pIDocType )
					{
						pTheEmbeddedFile = m_pEmbeddedFileRootFile;
					}
				
					RELEASE( pIDocTypeList );
				}
			}

			if( pTheEmbeddedFile )
			{
				return pTheEmbeddedFile;
			}
		}
	}
	
	// Search m_lstEmbeddedFiles
	POSITION pos = m_lstEmbeddedFiles.GetHeadPosition();
	while( pos )
	{
		EmbeddedFile* pEmbeddedFile = m_lstEmbeddedFiles.GetNext( pos );

		if( strObjectName.CompareNoCase( pEmbeddedFile->strObjectName ) == 0 )
		{
			// Object names are equal
			RegisteredObject* pRegisteredObject = FindRegisteredObjectByCLSID( pEmbeddedFile->guidDMClass );
			if( pRegisteredObject )
			{
				// Check to see if CLSID is type of object we want
				IDMUSProdDocType* pIDocTypeList;
				if( SUCCEEDED ( m_pIFramework8->FindDocTypeByNodeId( pRegisteredObject->guidNodeId, &pIDocTypeList ) ) )
				{
					if( pIDocTypeList == pIDocType )
					{
						pTheEmbeddedFile =  pEmbeddedFile;
						RELEASE( pIDocTypeList );
						break;
					}
				
					RELEASE( pIDocTypeList );
				}
			}
		}
	}

	return pTheEmbeddedFile;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SongDesigner\SongDocType.h ===
#ifndef __SONGDOCTYPE_H__
#define __SONGDOCTYPE_H__

// SongDocType.h : header file
//


class CSongDocType : public IDMUSProdDocType8
{
public:
    CSongDocType();
	~CSongDocType();

    // IUnknown functions
    HRESULT STDMETHODCALLTYPE QueryInterface( REFIID riid, LPVOID *ppv );
    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();

    // IDMUSProdDocType functions
    HRESULT STDMETHODCALLTYPE GetResourceId( HINSTANCE* phInstance, UINT* pnResourceId );
    HRESULT STDMETHODCALLTYPE DoesExtensionMatch( BSTR bstrExt );
    HRESULT STDMETHODCALLTYPE DoesIdMatch( REFGUID rguid );
    HRESULT STDMETHODCALLTYPE AllocNode( REFGUID rguid, IDMUSProdNode** ppINode );

    HRESULT STDMETHODCALLTYPE OnFileNew(IDMUSProdProject* pITargetProject,
										IDMUSProdNode* pITargetDirectoryNode, IDMUSProdNode** ppIDocRootNode);
    HRESULT STDMETHODCALLTYPE OnFileOpen(IStream* pIStream, IDMUSProdProject* pITargetProject,
										 IDMUSProdNode* pITargetDirectoryNode, IDMUSProdNode** ppIDocRootNode);
    HRESULT STDMETHODCALLTYPE OnFileSave( IStream* pIStream, IDMUSProdNode* pIDocRootNode );
    HRESULT STDMETHODCALLTYPE GetListInfo( IStream* pIStream, DMUSProdListInfo* pListInfo );

	HRESULT STDMETHODCALLTYPE IsFileTypeExtension( FileType ftFileType, BSTR bstrExt );   

    // IDMUSProdDocType8 functions
    HRESULT STDMETHODCALLTYPE GetObjectDescriptorFromNode( IDMUSProdNode* pIDocRootNode, void* pObjectDesc );
    HRESULT STDMETHODCALLTYPE GetObjectRiffId( GUID guidNodeId, DWORD* pckid, DWORD* pfccType );
    HRESULT STDMETHODCALLTYPE GetObjectExt( GUID guidNodeId, FileType ftFileType, BSTR* pbstrExt );

	// Additional functions

	// Member variables
private:
    DWORD m_dwRef;
};

#endif // __SONGDOCTYPE_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SongDesigner\SongEditorGuids.c ===
// SongEditorGuids.c : Contains GUIDs not found in MIDL generated SongDesigner_i.c
//

#ifdef __cplusplus
extern "C"{
#endif 

#ifndef GUID_DEFINED
#define GUID_DEFINED

typedef struct _GUID
{
    unsigned long Data1;
    unsigned short Data2;
    unsigned short Data3;
    unsigned char Data4[8];
} GUID;

#endif /* GUID_DEFINED */

const GUID CLSID_SongComponent = {0x58e70af0,0x8bba,0x413c,{0xbc,0xcb,0x6,0x30,0xc8,0x2f,0xf2,0x91}};

const GUID GUID_SongNode = {0x3e3127ae,0xf57,0x4e9e,{0xae,0xeb,0xba,0x32,0x66,0x6e,0xd1,0xca}};
const GUID GUID_SongRefNode = {0x44dcfc1a,0x1b32,0x419f,{0x9f,0x5f,0xab,0x69,0xd5,0xd3,0x3,0x8a}};
const GUID GUID_Song_SegmentsFolderNode = {0xba1c61d0,0xf4f,0x4a6d,{0x92,0x1e,0x4,0x21,0x60,0x8e,0x2f,0x69}};
const GUID GUID_Song_SegmentEmbedFolderNode = {0x53652748,0x802b,0x4ac0,{0x90,0x27,0x48,0x75,0xd,0x6e,0x51,0x73}};
const GUID GUID_Song_SegmentRefFolderNode = {0x1d091e2d,0x486b,0x47ee,{0x9c,0xb8,0x1e,0x26,0xb0,0xac,0xe3,0x9d}};
const GUID GUID_Song_ToolGraphsFolderNode = {0x80e69a,0x89f4,0x4190,{0xab,0xb1,0xe7,0x9f,0x30,0x18,0xa6,0xc9}};
const GUID GUID_Song_SourceSegmentNode = {0x1dec7743,0xe16a,0x4fc1,{0xbc,0xae,0xd1,0x20,0x7e,0xd,0x8c,0xca}};

const GUID SONG_NameChange = {0xea1cdfad,0x265a,0x4b79,{0x93,0xc9,0x61,0x14,0x29,0xd,0x1,0x72}};
const GUID SONG_FileLoadFinished = {0x87f138e8,0x446c,0x4518,{0x87,0x3f,0x53,0x7e,0x66,0x11,0x71,0x76}};

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SongDesigner\SongDlg.cpp ===
// SongDlg.cpp : implementation file
//

#include "stdafx.h"
#include "SongDesignerDLL.h"
#include "Song.h"
#include "SongCtl.h"
#include "SongDlg.h"
#include "DlgAddTracks.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


// Bitmaps
long CSongDlg::sm_lBitmapRefCount = 0;
CBitmap	CSongDlg::sm_bmpTransition;


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// CSegmentListBox

CSegmentListBox::CSegmentListBox()
{
	m_pSongDlg = NULL;

	m_ptLastXYPos.x = INT_MAX;
	m_ptLastXYPos.y = INT_MAX;
}

CSegmentListBox::~CSegmentListBox()
{
}


/////////////////////////////////////////////////////////////////////////////
// CSegmentListBox::SelectVirtualSegment

void CSegmentListBox::SelectVirtualSegment( CVirtualSegment* pVirtualSegment )
{
	ASSERT( pVirtualSegment != NULL );

	int nCurSel = GetCurSel();
	int nPos = -1;
	int nNbrItems = GetCount();
	for( int i = 0 ;  i < nNbrItems ;  i++ )
	{
		CVirtualSegment* pVirtualSegmentList = (CVirtualSegment *)GetItemDataPtr( i );

		if( pVirtualSegmentList == pVirtualSegment )
		{
			nPos = i;
			break;
		}
	}

	if( nPos != LB_ERR )
	{
		SetSel( -1, FALSE );
		SetSel( nPos, TRUE ); 
		SetCaretIndex( nPos, 0 ); 
		OnSelChange();
		SetFocus();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CSegmentListBox::SelectVirtualSegmentList

void CSegmentListBox::SelectVirtualSegmentList( CTypedPtrList<CPtrList, CVirtualSegment*>& list )
{
	SetSel( -1, FALSE );

	POSITION pos = list.GetHeadPosition();
	while( pos )
	{
		CVirtualSegment* pVirtualSegment = list.GetNext( pos );
	
		int nPos = FindStringExact( -1, (LPCTSTR)pVirtualSegment );
		if( nPos != LB_ERR )
		{
			SetSel( nPos, TRUE ); 
			SetCaretIndex( nPos, 0 ); 
		}
	}

	OnSelChange();
	SetFocus();
}


/////////////////////////////////////////////////////////////////////////////
// CSegmentListBox::CreateDataObject

HRESULT CSegmentListBox::CreateDataObject( IDataObject** ppIDataObject )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( theApp.m_pSongComponent != NULL );
	ASSERT( theApp.m_pSongComponent->m_pIFramework8 != NULL );

	if( ppIDataObject == NULL )
	{
		return E_POINTER;
	}
	*ppIDataObject = NULL;

	HRESULT hr = E_FAIL;

	// Create the CDllJazzDataObject 
	CDllJazzDataObject* pDataObject = new CDllJazzDataObject();
	if( pDataObject == NULL )
	{
		return E_OUTOFMEMORY;
	}

	// Mark selected VirtualSegments
	m_pSongDlg->MarkSelectedVirtualSegments( BF_SELECTED );

	// Save selected VirtualSegments
	IStream* pIStream;
	if( SUCCEEDED ( theApp.m_pSongComponent->m_pIFramework8->AllocMemoryStream(FT_DESIGN, GUID_SaveSelectedVirtualSegments, &pIStream) ) )
	{
		if( SUCCEEDED ( m_pSongDlg->m_pSong->Save( pIStream, FALSE ) ) )
		{
			// Place CF_VIRTUAL_SEGMENT_LIST into CDllJazzDataObject
			if( SUCCEEDED ( pDataObject->AddClipFormat( theApp.m_pSongComponent->m_cfVirtualSegmentList, pIStream ) ) )
			{
				hr = S_OK;
			}
		}

		RELEASE( pIStream );
	}

	if( SUCCEEDED ( hr ) )
	{
		*ppIDataObject = pDataObject;	// already AddRef'd
	}
	else
	{
		RELEASE( pDataObject );
	}

	// Unmark selected VirtualSegments
	m_pSongDlg->UnMarkVirtualSegments( BF_SELECTED );

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CSegmentListBox message handlers

BEGIN_MESSAGE_MAP(CSegmentListBox, CListBox)
	//{{AFX_MSG_MAP(CSegmentListBox)
	ON_WM_LBUTTONDOWN()
	ON_WM_RBUTTONDOWN()
	ON_WM_SETFOCUS()
	ON_WM_KILLFOCUS()
	ON_WM_VKEYTOITEM_REFLECT()
	ON_CONTROL_REFLECT(LBN_DBLCLK, OnDblClk)
	ON_CONTROL_REFLECT(LBN_SELCHANGE, OnSelChange)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CSegmentListBox::OnSetFocus

void CSegmentListBox::OnSetFocus( CWnd* pOldWnd ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CListBox::OnSetFocus( pOldWnd );
	
	m_pSongDlg->m_nEditMenuCtrlID = IDC_LIST_VIRTUAL_SEGMENTS;
	Invalidate();
}


/////////////////////////////////////////////////////////////////////////////
// CSegmentListBox::OnKillFocus

void CSegmentListBox::OnKillFocus( CWnd* pNewWnd ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CListBox::OnKillFocus( pNewWnd );
	
	Invalidate();
}


/////////////////////////////////////////////////////////////////////////////
// CSegmentListBox::DrawItem

void CSegmentListBox::DrawItem( LPDRAWITEMSTRUCT lpDrawItemStruct ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( lpDrawItemStruct->itemID == -1 )
	{
		return;
	}

	CDC* pDC = CDC::FromHandle( lpDrawItemStruct->hDC );
	if( pDC == NULL )
	{
		return;
	}

    if( lpDrawItemStruct->itemAction & ODA_DRAWENTIRE
    ||  lpDrawItemStruct->itemAction & ODA_SELECT 
    ||  lpDrawItemStruct->itemAction & ODA_FOCUS )
	{
		CVirtualSegment* pVirtualSegment = (CVirtualSegment *)lpDrawItemStruct->itemData; 
		ASSERT( pVirtualSegment != NULL );

	    int nWidth  = lpDrawItemStruct->rcItem.right  - lpDrawItemStruct->rcItem.left;
		int nHeight = lpDrawItemStruct->rcItem.bottom - lpDrawItemStruct->rcItem.top;

		CRect rect( 0, 0, nWidth, nHeight );

		CDC dc;
		CBitmap bmp;

		if( dc.CreateCompatibleDC( pDC )
		&&  bmp.CreateCompatibleBitmap( pDC, nWidth, nHeight ) )
		{
			CFont* pFontOld = NULL;
			CFont* pFont = m_pSongDlg->CreateFont();
			if( pFont )
			{
				pFontOld = dc.SelectObject( pFont );
			}
			CBitmap* pBitmapOld = dc.SelectObject( &bmp );
			int nBkModeOld = dc.SetBkMode( TRANSPARENT );

			// Get the VirtualSegment's name
			CString strName;
			pVirtualSegment->GetName( strName );

			// Set horizontal extent
			TEXTMETRIC tm;
			dc.GetTextMetrics( &tm );
			CSize sizeText = dc.GetTextExtent( strName );
			sizeText.cx += tm.tmMaxCharWidth;
			if( sizeText.cx > GetHorizontalExtent() )
			{
				SetHorizontalExtent( sizeText.cx );
			}

			// Fill the background color
			if( pVirtualSegment->m_fIsPlaying )
			{
				dc.FillSolidRect( &rect, RGB(255,0,0) );
				dc.SetTextColor( RGB(255,255,255) );
			}
			else if( lpDrawItemStruct->itemState & ODS_SELECTED )
			{
				if( ::GetFocus() == GetSafeHwnd() )
				{
					dc.FillSolidRect( &rect, ::GetSysColor(COLOR_HIGHLIGHT) );
					dc.SetTextColor( ::GetSysColor(COLOR_HIGHLIGHTTEXT) );
				}
				else
				{
					dc.FillSolidRect( &rect, ::GetSysColor(COLOR_INACTIVECAPTION) );
					dc.SetTextColor( ::GetSysColor(COLOR_INACTIVECAPTIONTEXT) );
				}
			}
			else
			{
				dc.FillSolidRect( &rect, ::GetSysColor(COLOR_WINDOW) );
				dc.SetTextColor( ::GetSysColor(COLOR_WINDOWTEXT) );
			}

			// Draw top separator (when applicable)
			int nPos = m_pSongDlg->m_pSong->VirtualSegmentToIndex( pVirtualSegment );
			if( nPos > 0 )
			{
				CVirtualSegment* pPrevVirtualSegment = m_pSongDlg->m_pSong->IndexToVirtualSegment( nPos - 1 );
				if( pPrevVirtualSegment 
				&&  pPrevVirtualSegment->m_pNextVirtualSegment != pVirtualSegment )
				{
					CRect rectSeparator( rect );
					rectSeparator.bottom = rectSeparator.top + 1;
					dc.FillSolidRect( &rectSeparator, ::GetSysColor(COLOR_WINDOW) );
				}
			}

			// Draw bottom separator (when applicable)
			if( pVirtualSegment->m_pNextVirtualSegment == NULL )
			{
				CRect rectSeparator( rect );
				rectSeparator.top = rectSeparator.bottom - 2;
				dc.FillSolidRect( &rectSeparator, ::GetSysColor(COLOR_WINDOW) );
		
				// Draw solid horizontal line (bottom)
				CPen pen;
				if( pen.CreatePen(PS_SOLID, 1, RGB(0, 0, 0)) )
				{
					CPen* pPenOld = dc.SelectObject( &pen );
					dc.MoveTo( rect.left, (rect.bottom - 1) );
					dc.LineTo( rect.right, (rect.bottom - 1) );
					dc.SelectObject( pPenOld );
				}
			}
			else
			{
				int nPos1 = m_pSongDlg->m_pSong->VirtualSegmentToIndex( pVirtualSegment );
				int nPos2 = m_pSongDlg->m_pSong->VirtualSegmentToIndex( pVirtualSegment->m_pNextVirtualSegment );

				if( nPos1 != (nPos2 - 1) )
				{
					CRect rectSeparator( rect );
					rectSeparator.top = rectSeparator.bottom - 2;
					dc.FillSolidRect( &rectSeparator, ::GetSysColor(COLOR_WINDOW) );

					// Draw broken horizontal line (bottom)
					CPen pen;
					if( pen.CreatePen(PS_DASH, 1, RGB(0, 0, 0)) )
					{
						CPen* pPenOld = dc.SelectObject( &pen );
						dc.MoveTo( rect.left, (rect.bottom - 1) );
						dc.LineTo( rect.right, (rect.bottom - 1) );
						dc.SelectObject( pPenOld );
					}
				}
			}

			// Draw the item
			rect.left  += 3;
			dc.DrawText( strName, -1, &rect, (DT_SINGLELINE | DT_TOP | DT_LEFT | DT_NOPREFIX) );
			pDC->BitBlt( lpDrawItemStruct->rcItem.left, lpDrawItemStruct->rcItem.top, nWidth, nHeight, 
						 &dc, 0, 0, SRCCOPY );

			// Clean up
			dc.SetBkMode( nBkModeOld );
			if( pFontOld )
			{
				dc.SelectObject( pFontOld );
				pFont->DeleteObject();
				delete pFont;
			}
			if( pBitmapOld )
			{
				dc.SelectObject( pBitmapOld );
			}
		}

		if( ::GetFocus() == GetSafeHwnd() )
		{
			if( (lpDrawItemStruct->itemAction & ODA_FOCUS)
			&&  (lpDrawItemStruct->itemState & ODS_FOCUS) )
			{
				InflateRect( &lpDrawItemStruct->rcItem, -1, -1 );
				lpDrawItemStruct->rcItem.bottom--;
				pDC->DrawFocusRect( &lpDrawItemStruct->rcItem );
				lpDrawItemStruct->rcItem.bottom++;
				InflateRect( &lpDrawItemStruct->rcItem, 1, 1 );
			}
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CSegmentListBox::MeasureItem

void CSegmentListBox::MeasureItem( LPMEASUREITEMSTRUCT lpMeasureItemStruct ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CDC* pDC = GetDC();
	if( pDC )
	{
		CFont* pFontOld = NULL;
		CFont* pFont = m_pSongDlg->CreateFont();
		if( pFont )
		{
			pFontOld = pDC->SelectObject( pFont );
		}

		TEXTMETRIC tm;
		pDC->GetTextMetrics( &tm );
		lpMeasureItemStruct->itemHeight = tm.tmHeight + 2;
		
		if( pFontOld )
		{
			pDC->SelectObject( pFontOld );
			pFont->DeleteObject();
			delete pFont;
		}

		ReleaseDC( pDC );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CSegmentListBox::OnLButtonDown

void CSegmentListBox::OnLButtonDown( UINT nFlags, CPoint point ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pSongDlg != NULL );

	m_ptLastXYPos.x = point.x;
	m_ptLastXYPos.y = point.y;

	CListBox::OnLButtonDown( nFlags, point );

	// Get nearest item
	BOOL fOutside;
	int nPos = ItemFromPoint( point, fOutside );

	if( fOutside == TRUE
	||  nPos == LB_ERR )
	{
		SetSel( -1, FALSE );
		SetCaretIndex( -1, 0 ); 
		OnSelChange();
		SetFocus();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CSegmentListBox::OnRButtonDown

void CSegmentListBox::OnRButtonDown( UINT nFlags, CPoint point ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pSongDlg != NULL );

	m_ptLastXYPos.x = point.x;
	m_ptLastXYPos.y = point.y;

	// Get nearest item
	BOOL fOutside;
	int nPos = ItemFromPoint( point, fOutside );

	if( fOutside == FALSE
	&&  nPos != LB_ERR )
	{
		CRect rect;
		GetItemRect( nPos, &rect );
		if( rect.PtInRect( point ) )
		{
			// Cursor is in the nearest item
			if( GetSel( nPos ) == 0 )
			{
				// Cursor is in the nearest item
				SetSel( -1, FALSE ); 
				SetSel( nPos, TRUE ); 
			}
			SetCaretIndex( nPos, 0 ); 
			OnSelChange();
		}
	}

	CListBox::OnRButtonDown( nFlags, point );
}


/////////////////////////////////////////////////////////////////////////////
// CSegmentListBox::OnDblClk

void CSegmentListBox::OnDblClk() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	m_pSongDlg->m_fOpenProperties = true;
	m_pSongDlg->OnViewProperties();
	m_pSongDlg->m_fOpenProperties = false;
}


/////////////////////////////////////////////////////////////////////////////
// CSegmentListBox::VKeyToItem

int CSegmentListBox::VKeyToItem( UINT nKey, UINT nIndex ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	switch( nKey )
	{
		case VK_RETURN:
			m_pSongDlg->m_nEditMenuCtrlID = IDC_LIST_VIRTUAL_SEGMENTS;
			m_pSongDlg->m_fOpenProperties = true;
			m_pSongDlg->OnViewProperties();
			m_pSongDlg->m_fOpenProperties = false;
			return -2;

		case VK_INSERT:
			m_pSongDlg->OnInsertVirtualSegment();
			return -2;

		case VK_DELETE:
			m_pSongDlg->OnDeleteVirtualSegments();
			return -2;
	}
	
	return -1;
}


/////////////////////////////////////////////////////////////////////////////
// CSegmentListBox::OnSelChange

void CSegmentListBox::OnSelChange( void ) 
{
	m_pSongDlg->RefreshVirtualSegmentControls();
	m_pSongDlg->RefreshProperties( IDC_LIST_VIRTUAL_SEGMENTS );
}


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// CTrackListBox

CTrackListBox::CTrackListBox()
{
	m_pSongDlg = NULL;

	m_ptLastXYPos.x = INT_MAX;
	m_ptLastXYPos.y = INT_MAX;
}

CTrackListBox::~CTrackListBox()
{
}


/////////////////////////////////////////////////////////////////////////////
// CTrackListBox::SelectTrack

void CTrackListBox::SelectTrack( CTrack* pTrack, bool fSetFocus )
{
	ASSERT( pTrack != NULL );

	int nPos = -1;
	int nNbrItems = GetCount();
	for( int i = 0 ;  i < nNbrItems ;  i++ )
	{
		CTrack* pTrackList = (CTrack *)GetItemDataPtr( i );

		if( pTrackList == pTrack )
		{
			nPos = i;
			break;
		}
	}

	if( nPos != LB_ERR )
	{
		SetSel( -1, FALSE );
		SetSel( nPos, TRUE ); 
		SetCaretIndex( nPos, 0 ); 

		if( fSetFocus )
		{
			OnSelChange();
			SetFocus();
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTrackListBox::SelectTrackList

void CTrackListBox::SelectTrackList( CTypedPtrList<CPtrList, CTrack*>& list )
{
	SetSel( -1, FALSE );

	POSITION pos = list.GetHeadPosition();
	while( pos )
	{
		CTrack* pTrack = list.GetNext( pos );
	
		int nPos = FindStringExact( -1, (LPCTSTR)pTrack );
		if( nPos != LB_ERR )
		{
			SetSel( nPos, TRUE ); 
			SetCaretIndex( nPos, 0 ); 
		}
	}

	OnSelChange();
	SetFocus();
}


/////////////////////////////////////////////////////////////////////////////
// CTrackListBox::CreateDataObject

HRESULT CTrackListBox::CreateDataObject( IDataObject** ppIDataObject )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( theApp.m_pSongComponent != NULL );
	ASSERT( theApp.m_pSongComponent->m_pIFramework8 != NULL );

	if( ppIDataObject == NULL )
	{
		return E_POINTER;
	}
	*ppIDataObject = NULL;

	CVirtualSegment* pVirtualSegmentToEdit = m_pSongDlg->GetVirtualSegmentToEdit();
	if( pVirtualSegmentToEdit == NULL )
	{
		return E_UNEXPECTED;
	}

	// Create the CDllJazzDataObject 
	CDllJazzDataObject* pDataObject = new CDllJazzDataObject();
	if( pDataObject == NULL )
	{
		return E_OUTOFMEMORY;
	}

	HRESULT hr = E_FAIL;

	// Mark selected Tracks 
	m_pSongDlg->MarkSelectedTracks( pVirtualSegmentToEdit, BF_SELECTED );

	// Save selected Tracks
	IStream* pIStream;
	if( SUCCEEDED ( theApp.m_pSongComponent->m_pIFramework8->AllocMemoryStream(FT_DESIGN, GUID_SaveSelectedTracks, &pIStream) ) )
	{
	    IDMUSProdRIFFStream* pIRiffStream;
		if( SUCCEEDED( AllocRIFFStream( pIStream, &pIRiffStream ) ) )
		{
			if( SUCCEEDED ( pVirtualSegmentToEdit->Save( pIRiffStream ) ) )
			{
				// Place CF_TRACK_LIST into CDllJazzDataObject
				if( SUCCEEDED ( pDataObject->AddClipFormat( theApp.m_pSongComponent->m_cfTrackList, pIStream ) ) )
				{
					hr = S_OK;
				}
			}

			RELEASE( pIRiffStream );
		}

		RELEASE( pIStream );
	}

	if( SUCCEEDED ( hr ) )
	{
		*ppIDataObject = pDataObject;	// already AddRef'd
	}
	else
	{
		RELEASE( pDataObject );
	}

	// Unmark selected Tracks
	m_pSongDlg->UnMarkTracks( pVirtualSegmentToEdit, BF_SELECTED );

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CTrackListBox message handlers

BEGIN_MESSAGE_MAP(CTrackListBox, CListBox)
	//{{AFX_MSG_MAP(CTrackListBox)
	ON_WM_LBUTTONDOWN()
	ON_WM_RBUTTONDOWN()
	ON_WM_SETFOCUS()
	ON_WM_KILLFOCUS()
	ON_WM_VKEYTOITEM_REFLECT()
	ON_CONTROL_REFLECT(LBN_DBLCLK, OnDblClk)
	ON_CONTROL_REFLECT(LBN_SELCHANGE, OnSelChange)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CTrackListBox::OnSetFocus

void CTrackListBox::OnSetFocus( CWnd* pOldWnd ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CListBox::OnSetFocus( pOldWnd );
	
	m_pSongDlg->m_nEditMenuCtrlID = IDC_LIST_TRACKS;
	Invalidate();
}


/////////////////////////////////////////////////////////////////////////////
// CTrackListBox::OnKillFocus

void CTrackListBox::OnKillFocus( CWnd* pNewWnd ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CListBox::OnKillFocus( pNewWnd );
	
	Invalidate();
}


/////////////////////////////////////////////////////////////////////////////
// CTrackListBox::DrawItem

void CTrackListBox::DrawItem( LPDRAWITEMSTRUCT lpDrawItemStruct ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( lpDrawItemStruct->itemID == -1 )
	{
		return;
	}

	CDC* pDC = CDC::FromHandle( lpDrawItemStruct->hDC );
	if( pDC == NULL )
	{
		return;
	}

    if( lpDrawItemStruct->itemAction & ODA_DRAWENTIRE
    ||  lpDrawItemStruct->itemAction & ODA_SELECT 
    ||  lpDrawItemStruct->itemAction & ODA_FOCUS )
	{
		CTrack* pTrack = (CTrack *)lpDrawItemStruct->itemData; 
		ASSERT( pTrack != NULL );

	    int nWidth  = lpDrawItemStruct->rcItem.right  - lpDrawItemStruct->rcItem.left;
		int nHeight = lpDrawItemStruct->rcItem.bottom - lpDrawItemStruct->rcItem.top;

		CRect rect( 0, 0, nWidth, nHeight );

		CDC dc;
		CBitmap bmp;

		if( dc.CreateCompatibleDC( pDC )
		&&  bmp.CreateCompatibleBitmap( pDC, nWidth, nHeight ) )
		{
			CFont* pFontOld = NULL;
			CFont* pFont = m_pSongDlg->CreateFont();
			if( pFont )
			{
				pFontOld = dc.SelectObject( pFont );
			}
			CBitmap* pBitmapOld = dc.SelectObject( &bmp );
			int nBkModeOld = dc.SetBkMode( TRANSPARENT );

			if( lpDrawItemStruct->itemState & ODS_SELECTED )
			{
				if( ::GetFocus() == GetSafeHwnd() )
				{
					dc.FillSolidRect( &rect, ::GetSysColor(COLOR_HIGHLIGHT) );
					dc.SetTextColor( ::GetSysColor(COLOR_HIGHLIGHTTEXT) );
				}
				else
				{
					dc.FillSolidRect( &rect, ::GetSysColor(COLOR_INACTIVECAPTION) );
					dc.SetTextColor( ::GetSysColor(COLOR_INACTIVECAPTIONTEXT) );
				}
			}
			else
			{
				dc.FillSolidRect( &rect, ::GetSysColor(COLOR_WINDOW) );
				dc.SetTextColor( ::GetSysColor(COLOR_WINDOWTEXT) );
			}

			// Determine text
			CString strText;
			pTrack->FormatTextUI( strText );

			// Set horizontal extent
			TEXTMETRIC tm;
			dc.GetTextMetrics( &tm );
			CSize sizeText = dc.GetTextExtent( strText );
			sizeText.cx += tm.tmMaxCharWidth;
			if( sizeText.cx > GetHorizontalExtent() )
			{
				SetHorizontalExtent( sizeText.cx );
			}

			// Draw the item
			rect.left  += 3;
			dc.DrawText( strText, -1, &rect, (DT_SINGLELINE | DT_TOP | DT_LEFT | DT_NOPREFIX) );
			pDC->BitBlt( lpDrawItemStruct->rcItem.left, lpDrawItemStruct->rcItem.top, nWidth, nHeight, 
						 &dc, 0, 0, SRCCOPY );

			// Clean up
			dc.SetBkMode( nBkModeOld );
			if( pFontOld )
			{
				dc.SelectObject( pFontOld );
				pFont->DeleteObject();
				delete pFont;
			}
			if( pBitmapOld )
			{
				dc.SelectObject( pBitmapOld );
			}
		}

		if( ::GetFocus() == GetSafeHwnd() )
		{
			if( (lpDrawItemStruct->itemAction & ODA_FOCUS)
			&&  (lpDrawItemStruct->itemState & ODS_FOCUS) )
			{
				InflateRect( &lpDrawItemStruct->rcItem, -1, -1 );
				pDC->DrawFocusRect( &lpDrawItemStruct->rcItem );
				InflateRect( &lpDrawItemStruct->rcItem, 1, 1 );
			}
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTrackListBox::MeasureItem

void CTrackListBox::MeasureItem( LPMEASUREITEMSTRUCT lpMeasureItemStruct ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CDC* pDC = GetDC();
	if( pDC )
	{
		CFont* pFontOld = NULL;
		CFont* pFont = m_pSongDlg->CreateFont();
		if( pFont )
		{
			pFontOld = pDC->SelectObject( pFont );
		}

		TEXTMETRIC tm;
		pDC->GetTextMetrics( &tm );
		lpMeasureItemStruct->itemHeight = tm.tmHeight + 1;
		
		if( pFontOld )
		{
			pDC->SelectObject( pFontOld );
			pFont->DeleteObject();
			delete pFont;
		}

		ReleaseDC( pDC );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTrackListBox::CompareItem

int CTrackListBox::CompareItem( LPCOMPAREITEMSTRUCT lpCompareItemStruct ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CTrack* pTrack1 = (CTrack *)lpCompareItemStruct->itemData1;
	CTrack* pTrack2 = (CTrack *)lpCompareItemStruct->itemData2;

	CString strName1;
	pTrack1->FormatFileNameText( strName1 );

	CString strName2;
	pTrack2->FormatFileNameText( strName2 );

	// If filenames are equal, sort by track index
	if( strName1.CompareNoCase( strName2 ) == 0 )
	{
		if( pTrack1->m_TrackUI.dwTrackIndex < pTrack2->m_TrackUI.dwTrackIndex )
		{
			return -1;
		}
		else if( pTrack1->m_TrackUI.dwTrackIndex > pTrack2->m_TrackUI.dwTrackIndex )
		{
			return 1;
		}
		else
		{
			return 0;
		}
	}

	// Sort by filename
	return strName1.CompareNoCase( strName2 );
}


/////////////////////////////////////////////////////////////////////////////
// CTrackListBox::OnLButtonDown

void CTrackListBox::OnLButtonDown( UINT nFlags, CPoint point ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pSongDlg != NULL );

	m_ptLastXYPos.x = point.x;
	m_ptLastXYPos.y = point.y;

	CListBox::OnLButtonDown( nFlags, point );
}


/////////////////////////////////////////////////////////////////////////////
// CTrackListBox::OnRButtonDown

void CTrackListBox::OnRButtonDown( UINT nFlags, CPoint point ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pSongDlg != NULL );

	SetFocus();

	m_ptLastXYPos.x = point.x;
	m_ptLastXYPos.y = point.y;

	// Get nearest item
	BOOL fOutside;
	int nPos = ItemFromPoint( point, fOutside );

	if( fOutside == FALSE
	&&  nPos != LB_ERR )
	{
		CRect rect;
		GetItemRect( nPos, &rect );
		if( rect.PtInRect( point ) )
		{
			// Cursor is in the nearest item
			if( GetSel( nPos ) == 0 )
			{
				// Cursor is in the nearest item
				SetSel( -1, FALSE ); 
				SetSel( nPos, TRUE ); 
			}
			SetCaretIndex( nPos, 0 ); 
			OnSelChange();
		}
	}

	CListBox::OnRButtonDown( nFlags, point );
}


/////////////////////////////////////////////////////////////////////////////
// CTrackListBox::OnDblClk

void CTrackListBox::OnDblClk() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	m_pSongDlg->m_fOpenProperties = true;
	m_pSongDlg->OnViewProperties();
	m_pSongDlg->m_fOpenProperties = false;
}


/////////////////////////////////////////////////////////////////////////////
// CTrackListBox::VKeyToItem

int CTrackListBox::VKeyToItem( UINT nKey, UINT nIndex ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	switch( nKey )
	{
		case VK_RETURN:
			m_pSongDlg->m_nEditMenuCtrlID = IDC_LIST_TRACKS;
			m_pSongDlg->m_fOpenProperties = true;
			m_pSongDlg->OnViewProperties();
			m_pSongDlg->m_fOpenProperties = false;
			return -2;

		case VK_INSERT:
			m_pSongDlg->OnInsertTrack();
			return -2;

		case VK_DELETE:
			m_pSongDlg->OnDeleteTracks();
			return -2;
	}
	
	return -1;
}


/////////////////////////////////////////////////////////////////////////////
// CTrackListBox::OnSelChange

void CTrackListBox::OnSelChange( void ) 
{
	m_pSongDlg->RefreshProperties( IDC_LIST_TRACKS );
}


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// CTransitionListBox

CTransitionListBox::CTransitionListBox()
{
	m_pSongDlg = NULL;

	m_ptLastXYPos.x = INT_MAX;
	m_ptLastXYPos.y = INT_MAX;
}

CTransitionListBox::~CTransitionListBox()
{
}


/////////////////////////////////////////////////////////////////////////////
// CTransitionListBox::SelectTransition

void CTransitionListBox::SelectTransition( CTransition* pTransition, bool fSetFocus )
{
	ASSERT( pTransition != NULL );

	int nPos = -1;
	int nNbrItems = GetCount();
	for( int i = 0 ;  i < nNbrItems ;  i++ )
	{
		CTransition* pTransitionList = (CTransition *)GetItemDataPtr( i );

		if( pTransitionList == pTransition )
		{
			nPos = i;
			break;
		}
	}

	if( nPos != LB_ERR )
	{
		SetSel( -1, FALSE );
		SetSel( nPos, TRUE ); 
		SetCaretIndex( nPos, 0 ); 

		if( fSetFocus )
		{
			OnSelChange();
			SetFocus();
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTransitionListBox::SelectTransitionList

void CTransitionListBox::SelectTransitionList( CTypedPtrList<CPtrList, CTransition*>& list )
{
	SetSel( -1, FALSE );

	POSITION pos = list.GetHeadPosition();
	while( pos )
	{
		CTransition* pTransition = list.GetNext( pos );
	
		int nPos = FindStringExact( -1, (LPCTSTR)pTransition );
		if( nPos != LB_ERR )
		{
			SetSel( nPos, TRUE ); 
			SetCaretIndex( nPos, 0 ); 
		}
	}

	OnSelChange();
	SetFocus();
}


/////////////////////////////////////////////////////////////////////////////
// CTransitionListBox::CreateDataObject

HRESULT CTransitionListBox::CreateDataObject( IDataObject** ppIDataObject )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( theApp.m_pSongComponent != NULL );
	ASSERT( theApp.m_pSongComponent->m_pIFramework8 != NULL );

	if( ppIDataObject == NULL )
	{
		return E_POINTER;
	}
	*ppIDataObject = NULL;

	CVirtualSegment* pVirtualSegmentToEdit = m_pSongDlg->GetVirtualSegmentToEdit();
	if( pVirtualSegmentToEdit == NULL )
	{
		return E_UNEXPECTED;
	}

	// Create the CDllJazzDataObject 
	CDllJazzDataObject* pDataObject = new CDllJazzDataObject();
	if( pDataObject == NULL )
	{
		return E_OUTOFMEMORY;
	}

	HRESULT hr = E_FAIL;

	// Mark selected Transitions 
	m_pSongDlg->MarkSelectedTransitions( pVirtualSegmentToEdit, BF_SELECTED );

	// Save selected Transitions
	IStream* pIStream;
	if( SUCCEEDED ( theApp.m_pSongComponent->m_pIFramework8->AllocMemoryStream(FT_DESIGN, GUID_SaveSelectedTransitions, &pIStream) ) )
	{
	    IDMUSProdRIFFStream* pIRiffStream;
		if( SUCCEEDED( AllocRIFFStream( pIStream, &pIRiffStream ) ) )
		{
			if( SUCCEEDED ( pVirtualSegmentToEdit->Save( pIRiffStream ) ) )
			{
				// Place CF_TRANSITION_LIST into CDllJazzDataObject
				if( SUCCEEDED ( pDataObject->AddClipFormat( theApp.m_pSongComponent->m_cfTransitionList, pIStream ) ) )
				{
					hr = S_OK;
				}
			}

			RELEASE( pIRiffStream );
		}

		RELEASE( pIStream );
	}

	if( SUCCEEDED ( hr ) )
	{
		*ppIDataObject = pDataObject;	// already AddRef'd
	}
	else
	{
		RELEASE( pDataObject );
	}

	// Unmark selected Transitions
	m_pSongDlg->UnMarkTransitions( pVirtualSegmentToEdit, BF_SELECTED );

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CTransitionListBox message handlers

BEGIN_MESSAGE_MAP(CTransitionListBox, CListBox)
	//{{AFX_MSG_MAP(CTransitionListBox)
	ON_WM_LBUTTONDOWN()
	ON_WM_RBUTTONDOWN()
	ON_WM_SETFOCUS()
	ON_WM_KILLFOCUS()
	ON_WM_VKEYTOITEM_REFLECT()
	ON_CONTROL_REFLECT(LBN_DBLCLK, OnDblClk)
	ON_CONTROL_REFLECT(LBN_SELCHANGE, OnSelChange)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CTransitionListBox::OnSetFocus

void CTransitionListBox::OnSetFocus( CWnd* pOldWnd ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CListBox::OnSetFocus( pOldWnd );
	
	m_pSongDlg->m_nEditMenuCtrlID = IDC_LIST_TRANSITIONS;
	Invalidate();
}


/////////////////////////////////////////////////////////////////////////////
// CTransitionListBox::OnKillFocus

void CTransitionListBox::OnKillFocus( CWnd* pNewWnd ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CListBox::OnKillFocus( pNewWnd );
	
	Invalidate();
}


/////////////////////////////////////////////////////////////////////////////
// CTransitionListBox::DrawItem

void CTransitionListBox::DrawItem( LPDRAWITEMSTRUCT lpDrawItemStruct ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( lpDrawItemStruct->itemID == -1 )
	{
		return;
	}

	CDC* pDC = CDC::FromHandle( lpDrawItemStruct->hDC );
	if( pDC == NULL )
	{
		return;
	}

    if( lpDrawItemStruct->itemAction & ODA_DRAWENTIRE
    ||  lpDrawItemStruct->itemAction & ODA_SELECT 
    ||  lpDrawItemStruct->itemAction & ODA_FOCUS )
	{
		CTransition* pTransition = (CTransition *)lpDrawItemStruct->itemData; 
		ASSERT( pTransition != NULL );

	    int nWidth  = lpDrawItemStruct->rcItem.right  - lpDrawItemStruct->rcItem.left;
		int nHeight = lpDrawItemStruct->rcItem.bottom - lpDrawItemStruct->rcItem.top;

		CRect rect( 0, 0, nWidth, nHeight );

		CDC dc;
		CBitmap bmp;

		if( dc.CreateCompatibleDC( pDC )
		&&  bmp.CreateCompatibleBitmap( pDC, nWidth, nHeight ) )
		{
			CFont* pFontOld = NULL;
			CFont* pFont = m_pSongDlg->CreateFont();
			if( pFont )
			{
				pFontOld = dc.SelectObject( pFont );
			}
			CBitmap* pBitmapOld = dc.SelectObject( &bmp );
			int nBkModeOld = dc.SetBkMode( TRANSPARENT );

			if( lpDrawItemStruct->itemState & ODS_SELECTED )
			{
				if( ::GetFocus() == GetSafeHwnd() )
				{
					dc.FillSolidRect( &rect, ::GetSysColor(COLOR_HIGHLIGHT) );
					dc.SetTextColor( ::GetSysColor(COLOR_HIGHLIGHTTEXT) );
				}
				else
				{
					dc.FillSolidRect( &rect, ::GetSysColor(COLOR_INACTIVECAPTION) );
					dc.SetTextColor( ::GetSysColor(COLOR_INACTIVECAPTIONTEXT) );
				}
			}
			else
			{
				dc.FillSolidRect( &rect, ::GetSysColor(COLOR_WINDOW) );
				dc.SetTextColor( ::GetSysColor(COLOR_WINDOWTEXT) );
			}

			// Determine Text
			CString strText;
			pTransition->FormatTextUI( strText );

			// Set horizontal extent
			TEXTMETRIC tm;
			dc.GetTextMetrics( &tm );
			CSize sizeText = dc.GetTextExtent( strText );
			sizeText.cx += tm.tmMaxCharWidth;
			if( sizeText.cx > GetHorizontalExtent() )
			{
				SetHorizontalExtent( sizeText.cx );
			}

			// Draw Text
			rect.left += 3;
			dc.DrawText( strText, -1, &rect, (DT_SINGLELINE | DT_TOP | DT_LEFT | DT_NOPREFIX) );
			pDC->BitBlt( lpDrawItemStruct->rcItem.left, lpDrawItemStruct->rcItem.top, nWidth, nHeight, 
						 &dc, 0, 0, SRCCOPY );

			// Clean up
			dc.SetBkMode( nBkModeOld );
			if( pFontOld )
			{
				dc.SelectObject( pFontOld );
				pFont->DeleteObject();
				delete pFont;
			}
			if( pBitmapOld )
			{
				dc.SelectObject( pBitmapOld );
			}
		}

		if( ::GetFocus() == GetSafeHwnd() )
		{
			if( (lpDrawItemStruct->itemAction & ODA_FOCUS)
			&&  (lpDrawItemStruct->itemState & ODS_FOCUS) )
			{
				InflateRect( &lpDrawItemStruct->rcItem, -1, -1 );
				pDC->DrawFocusRect( &lpDrawItemStruct->rcItem );
				InflateRect( &lpDrawItemStruct->rcItem, 1, 1 );
			}
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTransitionListBox::MeasureItem

void CTransitionListBox::MeasureItem( LPMEASUREITEMSTRUCT lpMeasureItemStruct ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CDC* pDC = GetDC();
	if( pDC )
	{
		CFont* pFontOld = NULL;
		CFont* pFont = m_pSongDlg->CreateFont();
		if( pFont )
		{
			pFontOld = pDC->SelectObject( pFont );
		}

		TEXTMETRIC tm;
		pDC->GetTextMetrics( &tm );
		lpMeasureItemStruct->itemHeight = tm.tmHeight + 1;
		
		if( pFontOld )
		{
			pDC->SelectObject( pFontOld );
			pFont->DeleteObject();
			delete pFont;
		}

		ReleaseDC( pDC );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTransitionListBox::OnLButtonDown

void CTransitionListBox::OnLButtonDown( UINT nFlags, CPoint point ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pSongDlg != NULL );

	m_ptLastXYPos.x = point.x;
	m_ptLastXYPos.y = point.y;

	CListBox::OnLButtonDown( nFlags, point );
}


/////////////////////////////////////////////////////////////////////////////
// CTransitionListBox::OnRButtonDown

void CTransitionListBox::OnRButtonDown( UINT nFlags, CPoint point ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pSongDlg != NULL );

	SetFocus();

	m_ptLastXYPos.x = point.x;
	m_ptLastXYPos.y = point.y;

	// Get nearest item
	BOOL fOutside;
	int nPos = ItemFromPoint( point, fOutside );

	if( fOutside == FALSE
	&&  nPos != LB_ERR )
	{
		CRect rect;
		GetItemRect( nPos, &rect );
		if( rect.PtInRect( point ) )
		{
			// Cursor is in the nearest item
			if( GetSel( nPos ) == 0 )
			{
				// Cursor is in the nearest item
				SetSel( -1, FALSE ); 
				SetSel( nPos, TRUE ); 
			}
			SetCaretIndex( nPos, 0 ); 
			OnSelChange();
		}
	}

	CListBox::OnRButtonDown( nFlags, point );
}


/////////////////////////////////////////////////////////////////////////////
// CTransitionListBox::OnDblClk

void CTransitionListBox::OnDblClk() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	m_pSongDlg->m_fOpenProperties = true;
	m_pSongDlg->OnViewProperties();
	m_pSongDlg->m_fOpenProperties = false;
}


/////////////////////////////////////////////////////////////////////////////
// CTransitionListBox::VKeyToItem

int CTransitionListBox::VKeyToItem( UINT nKey, UINT nIndex ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	switch( nKey )
	{
		case VK_RETURN:
			m_pSongDlg->m_nEditMenuCtrlID = IDC_LIST_TRANSITIONS;
			m_pSongDlg->m_fOpenProperties = true;
			m_pSongDlg->OnViewProperties();
			m_pSongDlg->m_fOpenProperties = false;
			return -2;

		case VK_INSERT:
			m_pSongDlg->OnInsertTransition();
			return -2;

		case VK_DELETE:
			m_pSongDlg->OnDeleteTransitions();
			return -2;
	}
	
	return -1;
}


/////////////////////////////////////////////////////////////////////////////
// CTransitionListBox::OnSelChange

void CTransitionListBox::OnSelChange( void ) 
{
	m_pSongDlg->RefreshProperties( IDC_LIST_TRANSITIONS );
}


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// CSongDlg

//IMPLEMENT_DYNCREATE(CSongDlg, CFormView)

CSongDlg::CSongDlg()
	: CFormView(CSongDlg::IDD)
{
	//{{AFX_DATA_INIT(CSongDlg)
	//}}AFX_DATA_INIT

	m_pSongCtrl = NULL;
	m_pSong = NULL;

	m_nEditMenuCtrlID = 0;

	m_pVirtualSegmentPropPageObject = NULL;
	m_pTrackPropPageObject = NULL;
	m_pTransitionPropPageObject = NULL;
	m_fOpenProperties = false;

	m_pIDataObject = NULL;
	m_nStartDragControlID = 0;
	m_dwStartDragButton = 0;
	m_dwOverDragButton = 0;
	m_dwOverDragEffect = 0;
	m_pDragImage = NULL;
	m_pDragSong = NULL;
	m_dwDragRMenuEffect = DROPEFFECT_NONE;

	m_pINodeRightMenu = NULL;
	m_pointRightMenu.x = -1;
	m_pointRightMenu.y = -1;

	m_dwMouseDownButton = 0;
	m_pointMouseDown.x = 0;
	m_pointMouseDown.y = 0;

	m_dwScrollTick = 0;
}

CSongDlg::~CSongDlg()
{
	RELEASE( m_pVirtualSegmentPropPageObject );
	RELEASE( m_pTrackPropPageObject );
	RELEASE( m_pTransitionPropPageObject );
}


/////////////////////////////////////////////////////////////////////////////
// CSongDlg::RefreshProperties

void CSongDlg::RefreshProperties( UINT nControlID )
{
	ASSERT( theApp.m_pSongComponent != NULL );
	ASSERT( theApp.m_pSongComponent->m_pIFramework8 != NULL );

	IDMUSProdPropSheet* pIPropSheet;
	if( FAILED ( theApp.m_pSongComponent->m_pIFramework8->QueryInterface( IID_IDMUSProdPropSheet, (void**)&pIPropSheet ) ) )
	{
		return;
	}

	if( pIPropSheet->IsShowing() != S_OK )
	{
		RELEASE( pIPropSheet );
		return;
	}

	bool fOpenProperties = false;
	
	switch( nControlID )
	{
		case IDC_LIST_VIRTUAL_SEGMENTS:
			if( theApp.m_pIPageManager == NULL
			||  theApp.m_pIPageManager->IsEqualPageManagerGUID( GUID_VirtualSegmentPropPageManager ) != S_OK )
			{
				fOpenProperties = true;
			}
			break;
		
		case IDC_LIST_TRACKS:
			if( theApp.m_pIPageManager == NULL
			||  theApp.m_pIPageManager->IsEqualPageManagerGUID( GUID_TrackPropPageManager ) != S_OK )
			{
				fOpenProperties = true;
			}
			break;

		case IDC_LIST_TRANSITIONS:
			if( theApp.m_pIPageManager == NULL
			||  theApp.m_pIPageManager->IsEqualPageManagerGUID( GUID_TransitionPropPageManager ) != S_OK )
			{
				fOpenProperties = true;
			}
			break;

		default:
			ASSERT( 0 );
			break;
	}

	if( fOpenProperties )
	{
		m_nEditMenuCtrlID = nControlID;
		OnViewProperties();
		CWnd* pWnd = GetDlgItem( nControlID );
		if( pWnd )
		{
			pWnd->SetFocus();
		}
	}
	else
	{
		pIPropSheet->RefreshTitle();
		theApp.m_pIPageManager->RefreshData();
	}

	RELEASE( pIPropSheet );
}


/////////////////////////////////////////////////////////////////////////////
// CSongDlg::SyncSongEditor

void CSongDlg::SyncSongEditor( DWORD dwFlags )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// SSE_ALL
	if( dwFlags == SSE_ALL )
	{
		FillVirtualSegmentListBox();
		FillVirtualSegmentComboBox();
		FillSourceSegmentComboBox();
		FillToolGraphComboBox();
		RefreshVirtualSegmentControls();
		return;
	}

	// SSE_SOURCE_SEGMENT_LIST
	if( dwFlags & SSE_SOURCE_SEGMENT_LIST )
	{
		FillSourceSegmentComboBox();
	}

	// SSE_VIRTUAL_SEGMENT_LIST
	if( dwFlags & SSE_VIRTUAL_SEGMENT_LIST )
	{
		FillVirtualSegmentComboBox();
		FillVirtualSegmentListBox();
		RefreshVirtualSegmentControls();
	}

	// SSE_REDRAW_VIRTUAL_SEGMENT_LIST
	if( dwFlags & SSE_REDRAW_VIRTUAL_SEGMENT_LIST )
	{
		CVirtualSegment* pVirtualSegmentToEdit = GetVirtualSegmentToEdit();
		if( pVirtualSegmentToEdit )
		{
			m_editName.SetWindowText( pVirtualSegmentToEdit->m_strName );
		}
		m_lstbxSegments.Invalidate();
		FillVirtualSegmentComboBox();
	}

	// SSE_INVALIDATE_VIRTUAL_SEGMENT_LIST
	if( dwFlags & SSE_INVALIDATE_VIRTUAL_SEGMENT_LIST )
	{
		m_lstbxSegments.Invalidate();
	}

	// SSE_TOOLGRAPH_LIST
	if( dwFlags & SSE_TOOLGRAPH_LIST )
	{
		FillToolGraphComboBox();
	}

	// SSE_TRANSITION_LIST
	if( dwFlags & SSE_TRANSITION_LIST )
	{
		CVirtualSegment* pVirtualSegmentToEdit = GetVirtualSegmentToEdit();
		if( pVirtualSegmentToEdit )
		{
			FillTransitionListBox( pVirtualSegmentToEdit );
		}
	}

	// SSE_REDRAW_TRANSITION_LIST
	if( dwFlags & SSE_REDRAW_TRANSITION_LIST )
	{
		m_lstbxTransitions.Invalidate();
	}

	// SSE_TRACK_LIST
	if( dwFlags & SSE_TRACK_LIST )
	{
		CVirtualSegment* pVirtualSegmentToEdit = GetVirtualSegmentToEdit();
		if( pVirtualSegmentToEdit )
		{
			FillTrackListBox( pVirtualSegmentToEdit );
		}
	}

	// SSE_REDRAW_TRACK_LIST
	if( dwFlags & SSE_REDRAW_TRACK_LIST )
	{
		m_lstbxTracks.Invalidate();
	}

	// SSE_SELECTED_VIRTUAL_SEGMENT 
	if( dwFlags & SSE_SELECTED_VIRTUAL_SEGMENT )
	{
		RefreshVirtualSegmentControls();
	}

	// SSE_EMPTY_ALL_LISTS
	if( dwFlags & SSE_EMPTY_ALL_LISTS )
	{
		m_lstbxSegments.ResetContent();
		m_lstbxTracks.ResetContent();
		m_lstbxTransitions.ResetContent();
		m_comboSegment.ResetContent();
		m_comboNextSegment.ResetContent();
		m_comboToolGraph.ResetContent();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CSongDlg::RefreshVirtualSegmentControls

void CSongDlg::RefreshVirtualSegmentControls( void )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_lstbxSegments.GetCount() > 0
	&&  m_lstbxSegments.GetSelCount() == 1 )
	{
		// One item selected in VirtualSegments list
		int nSelItem;
		m_lstbxSegments.GetSelItems( 1, &nSelItem );

		CVirtualSegment* pVirtualSegment = (CVirtualSegment *)m_lstbxSegments.GetItemDataPtr( nSelItem );
	
		if( pVirtualSegment
		&&  pVirtualSegment != (CVirtualSegment *)0xFFFFFFFF )
		{
			EnableVirtualSegmentControls( TRUE );
		
			FillTrackListBox( pVirtualSegment );
			FillTransitionListBox( pVirtualSegment );

			m_editName.SetWindowText( pVirtualSegment->m_strName );
			SelectSourceSegmentComboBox( pVirtualSegment->m_pSourceSegment );
			SelectVirtualSegmentComboBox( pVirtualSegment->m_pNextVirtualSegment );
			SelectToolGraphComboBox( pVirtualSegment->m_pIToolGraphNode );
			return;
		}
	}

	// VirtualSegment list is empty OR
	// no VirtualSegments selected OR
	// multiple VirtualSegments selected
	EnableVirtualSegmentControls( FALSE );

	m_lstbxTracks.ResetContent();
	m_lstbxTransitions.ResetContent();
	m_comboSegment.SetCurSel( -1 );
	m_comboNextSegment.SetCurSel( -1 );
	m_comboToolGraph.SetCurSel( -1 );

	if( m_lstbxSegments.GetSelCount() > 1 )
	{
		CString strText;
		strText.LoadString( IDS_MULTIPLE_SEGMENTS_SELECTED );
		m_editName.SetWindowText( strText );
	}
	else
	{
		m_editName.SetWindowText( NULL );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CSongDlg::EnableVirtualSegmentControls

void CSongDlg::EnableVirtualSegmentControls( BOOL fEnable )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	m_lstbxTracks.EnableWindow( fEnable );
	m_lstbxTransitions.EnableWindow( fEnable );

	m_editName.EnableWindow( fEnable );
	
	m_comboSegment.EnableWindow( fEnable );
	m_comboNextSegment.EnableWindow( fEnable );
	m_comboToolGraph.EnableWindow( fEnable );
}


void CSongDlg::DoDataExchange(CDataExchange* pDX)
{
	CFormView::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CSongDlg)
	DDX_Control(pDX, IDC_TRANSITION, m_btnTransition);
	DDX_Control(pDX, IDC_COMBO_TOOLGRAPH, m_comboToolGraph);
	DDX_Control(pDX, IDC_EDIT_NAME, m_editName);
	DDX_Control(pDX, IDC_COMBO_SEGMENT, m_comboSegment);
	DDX_Control(pDX, IDC_COMBO_NEXT_VIRTUAL_SEGMENT, m_comboNextSegment);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CSongDlg, CFormView)
	//{{AFX_MSG_MAP(CSongDlg)
	ON_COMMAND(IDM_DRAG_MOVE, OnDragRMenuMove)
	ON_COMMAND(IDM_DRAG_COPY, OnDragRMenuCopy)
	ON_COMMAND(IDM_DRAG_CANCEL, OnDragRMenuCancel)
	ON_WM_DESTROY()
	ON_WM_SIZE()
	ON_WM_CONTEXTMENU()
	ON_CBN_SELCHANGE(IDC_COMBO_NEXT_VIRTUAL_SEGMENT, OnSelChangeNextVirtualSegment)
	ON_CBN_SELCHANGE(IDC_COMBO_SEGMENT, OnSelChangeSourceSegment)
	ON_CBN_SELCHANGE(IDC_COMBO_TOOLGRAPH, OnSelChangeToolGraph)
	ON_EN_KILLFOCUS(IDC_EDIT_NAME, OnKillFocusEditName)
	ON_BN_CLICKED(IDC_TRANSITION, OnTransition)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CSongDlg diagnostics

#ifdef _DEBUG
void CSongDlg::AssertValid() const
{
	CFormView::AssertValid();
}

void CSongDlg::Dump(CDumpContext& dc) const
{
	CFormView::Dump(dc);
}
#endif //_DEBUG


/////////////////////////////////////////////////////////////////////////////
// CSongDlg IUnknown implementation

/////////////////////////////////////////////////////////////////////////////
// IUknown CSongDlg::QueryInterface

HRESULT CSongDlg::QueryInterface( REFIID riid, LPVOID *ppvObj )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    if( ::IsEqualIID(riid, IID_IDropSource)
	||  ::IsEqualIID(riid, IID_IUnknown) )
    {
        AddRef();
        *ppvObj = (IDropSource *)this;
        return S_OK;
    }

    if( ::IsEqualIID(riid, IID_IDropTarget) )
    {
        AddRef();
        *ppvObj = (IDropTarget *)this;
        return S_OK;
    }

    *ppvObj = NULL;
    return E_NOINTERFACE;
}


/////////////////////////////////////////////////////////////////////////////
// IUnknown CSongDlg::AddRef

ULONG CSongDlg::AddRef( void )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	AfxOleLockApp(); 
    return ++m_dwRef;
}


/////////////////////////////////////////////////////////////////////////////
// IUnknown CSongDlg::Release

ULONG CSongDlg::Release( void )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    ASSERT( m_dwRef != 0 );

	AfxOleUnlockApp(); 
    --m_dwRef;

    ASSERT( m_dwRef != 0 );	// m_dwRef should never get to zero.

//  if( m_dwRef == 0 )		   CSongDlg should be deleted when		
//  {						   control is destroyed. 						
//		delete this;		
//		return 0;
//  }

    return m_dwRef;
}


/////////////////////////////////////////////////////////////////////////////
// CSongDlg IDropSource implementation

/////////////////////////////////////////////////////////////////////////////
// IDropSource CSongDlg::QueryContinueDrag

HRESULT CSongDlg::QueryContinueDrag( BOOL fEscapePressed, DWORD grfKeyState )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
 
	if( fEscapePressed )
	{
        return DRAGDROP_S_CANCEL;
	}

	if( m_dwStartDragButton == MK_LBUTTON )
	{
		if( grfKeyState & MK_RBUTTON )
		{
			return DRAGDROP_S_CANCEL;
		}

		if( !(grfKeyState & MK_LBUTTON) )
		{
			return DRAGDROP_S_DROP;
		}
	}

	if( m_dwStartDragButton == MK_RBUTTON )
	{
		if( grfKeyState & MK_LBUTTON )
		{
			return DRAGDROP_S_CANCEL;
		}
		
		if( !(grfKeyState & MK_RBUTTON) )
		{
			return DRAGDROP_S_DROP;
		}
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// IDropSource CSongDlg::GiveFeedback

HRESULT CSongDlg::GiveFeedback( DWORD dwEffect )
{
	UNREFERENCED_PARAMETER( dwEffect );

	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pDragImage )
	{
		CPoint pt;

		GetCursorPos( &pt );

		// Move the drag image
		m_pDragImage->DragMove( pt );
	}

	return DRAGDROP_S_USEDEFAULTCURSORS;
}


/////////////////////////////////////////////////////////////////////////////
// CSongDlg IDropTarget implementation

/////////////////////////////////////////////////////////////////////////////
// IDropTarget CSongDlg::DragEnter

HRESULT CSongDlg::DragEnter( IDataObject* pIDataObject, DWORD grfKeyState, POINTL pt, DWORD* pdwEffect )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( pIDataObject != NULL );
	ASSERT( m_pIDataObject == NULL );

	m_dwScrollTick = 0;

	// Store IDataObject associated with current drag-drop operation
	m_pIDataObject = pIDataObject;
	m_pIDataObject->AddRef();

	if( m_pDragImage )
	{
		CPoint point( pt.x, pt.y );

		// Show the feedback image
		m_pDragImage->DragEnter( GetDesktopWindow (), point );
	}

	// Make sure editor is on top
	if( m_pSong->m_hWndEditor )
	{
		::BringWindowToTop( m_pSong->m_hWndEditor );
	}

	// Determine effect of drop
	return DragOver( grfKeyState, pt, pdwEffect );
}


/////////////////////////////////////////////////////////////////////////////
// IDropTarget CSongDlg::DragOver

HRESULT CSongDlg::DragOver( DWORD grfKeyState, POINTL pt, DWORD* pdwEffect )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pIDataObject != NULL );

	POINT point;
	point.x = pt.x;
	point.y = pt.y;

	if( m_pDragImage )
	{
		// Hide the feedback image
		m_pDragImage->DragShowNolock( FALSE );
	}

	// Determine effect of drop
	DWORD dwEffect = DROPEFFECT_NONE;

	bool fMoveIsOK = false;
	if( CanPasteFromData( m_pIDataObject, true, point, &fMoveIsOK ) == S_OK )
	{
		if( fMoveIsOK == false )
		{
			dwEffect = DROPEFFECT_COPY;
		}
		else if( grfKeyState & MK_RBUTTON )
		{
			dwEffect = *pdwEffect;
		}
		else if( grfKeyState & MK_CONTROL )
		{
			dwEffect = DROPEFFECT_COPY;
		}
		else if( *pdwEffect & DROPEFFECT_COPY
			 &&  *pdwEffect & DROPEFFECT_MOVE )
		{
			dwEffect = DROPEFFECT_MOVE;
		}
		else
		{
			dwEffect = *pdwEffect;
		}
	}

	// Scroll
/* TODO
	{
		RECT rect;
		m_btnSongHeader.ScreenToClient( &point );
		m_btnSongHeader.GetClientRect( &rect );

		if( point.x < 0
		||  point.x > rect.right )
		{
			if( m_dwScrollTick == 0 )
			{
				m_dwScrollTick = GetTickCount() + 350;
			}
			else if( m_dwScrollTick < GetTickCount() )
			{
				if( point.x < 0 )
				{
					m_lstbxSong.SendMessage( WM_HSCROLL,
											  MAKEWPARAM( SB_THUMBPOSITION, max(0, m_lstbxSong.m_nHScrollPos - 30) ),
											  NULL );
				}
				else
				{
					int nExtent = m_lstbxSong.GetHorizontalExtent();
					m_lstbxSong.SendMessage( WM_HSCROLL,
											  MAKEWPARAM( SB_THUMBPOSITION, min(nExtent, m_lstbxSong.m_nHScrollPos + 30) ),
											  NULL );
				}

				m_dwScrollTick += 100;
			}
			
			dwEffect |= DROPEFFECT_SCROLL;
		}
		else
		{
			m_dwScrollTick = 0;
		}

		m_btnSongHeader.ClientToScreen( &point );
	}
*/

	if( m_pDragImage )
	{
		// Show the feedback image
		m_pDragImage->DragShowNolock( TRUE );
	}

	// Set temp drag over fields
	if( grfKeyState & (MK_RBUTTON | MK_LBUTTON) )
	{
		m_dwOverDragButton = grfKeyState & (MK_RBUTTON | MK_LBUTTON);
		m_dwOverDragEffect = dwEffect;
	}

	*pdwEffect = dwEffect;
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// IDropTarget CSongDlg::DragLeave

HRESULT CSongDlg::DragLeave( void )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	m_dwScrollTick = 0;

	// Release IDataObject
	RELEASE( m_pIDataObject );

	if( m_pDragImage )
	{
		// Hide the feedback image
		m_pDragImage->DragLeave( GetDesktopWindow () );
	}

	//Reset temp drag over fields
	m_dwOverDragButton = 0;
	m_dwOverDragEffect = 0;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// IDropTarget CSongDlg::Drop

HRESULT CSongDlg::Drop( IDataObject* pIDataObject, DWORD grfKeyState, POINTL pt, DWORD* pdwEffect)
{
	UNREFERENCED_PARAMETER( grfKeyState );

	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pIDataObject != NULL );
	ASSERT( m_pIDataObject == pIDataObject );
	ASSERT( m_pSong != NULL );

	if( m_pDragImage )
	{
		// Hide the feedback image
		m_pDragImage->DragLeave( GetDesktopWindow () );
	}

	// Set default values
	HRESULT hr = S_OK;
	*pdwEffect = DROPEFFECT_NONE;

	POINT point;
	point.x = pt.x;
	point.y = pt.y;
// TODO
/*	if( m_pDragSong == m_pSong )
	{
		if( m_nStartDragControlID == IDC_GRAPH_HEADER )
		{
			CTool* pToolStart = GetToolFromXPos( m_pointMouseDown.x );
			if( pToolStart )
			{
				m_btnSongHeader.ScreenToClient( &point );
				CTool* pToolEnd = GetToolFromXPos( point.x );
				m_btnSongHeader.ClientToScreen( &point );

				if( pToolStart == pToolEnd )
				{
					// Nothing to do
					DragLeave();
					return hr;
				}
			}
		}
	}
*/
	// Choose effect when right mouse drag - Move, Copy, or Cancel?
	if( m_dwOverDragButton & MK_RBUTTON )
	{
		HMENU hMenu;
		HMENU hMenuPopup;
		
		// Display arrow cursor
		::LoadCursor( theApp.m_hInstance, IDC_ARROW );
	
		// Prepare context menu
		hMenu = ::LoadMenu( theApp.m_hInstance, MAKEINTRESOURCE(IDM_DRAG_RMENU) );
		if( hMenu )
		{
			m_dwDragRMenuEffect = DROPEFFECT_NONE;

			// Track right context menu for drag-drop via TrackPopupMenu
			hMenuPopup = ::GetSubMenu( hMenu, 0 );

			// Init state of menu items
			if( !(m_dwOverDragEffect & DROPEFFECT_MOVE) )
			{
				::EnableMenuItem( hMenuPopup, IDM_DRAG_MOVE, (MF_GRAYED | MF_BYCOMMAND) );
			}

			// Display and track menu
			CPoint point( pt.x, pt.y );
			::TrackPopupMenu( hMenuPopup, (TPM_LEFTALIGN | TPM_RIGHTBUTTON),
							  point.x, point.y, 0, GetSafeHwnd(), NULL );
			DestroyMenu( hMenu );

			// Need to process WM_COMMAND from TrackPopupMenu
			MSG msg;
			while( ::PeekMessage( &msg, GetSafeHwnd(), NULL, NULL, PM_REMOVE) )
			{
				TranslateMessage( &msg );
				DispatchMessage( &msg );
			}

			// WM_COMMAND from TrackPopupMenu will have set m_dwDragRMenuEffect
			m_dwOverDragEffect = m_dwDragRMenuEffect;
			m_dwDragRMenuEffect = DROPEFFECT_NONE;
		}
	}

	if( m_dwOverDragEffect != DROPEFFECT_NONE )
	{
		// Paste data
		hr = PasteFromData( pIDataObject, true, point );
		if( SUCCEEDED ( hr ) )
		{
			*pdwEffect = m_dwOverDragEffect;
		}
	}

	// Cleanup
	DragLeave();

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CSongDlg message handlers

/////////////////////////////////////////////////////////////////////////////
// CSongDlg::Create

BOOL CSongDlg::Create( LPCTSTR lpszClassName, LPCTSTR lpszWindowName, DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID, CCreateContext* pContext ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( !CFormView::Create( lpszClassName, lpszWindowName, dwStyle, rect, pParentWnd, nID, pContext ) )
	{
		return FALSE;
	}
	
	return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
// CSongDlg::OnInitialUpdate

void CSongDlg::OnInitialUpdate() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pSong != NULL );

	CFormView::OnInitialUpdate();
	
	HRESULT hr = ::RegisterDragDrop( GetSafeHwnd(), (IDropTarget *)this );
	ASSERT(SUCCEEDED(hr));

	// Subclass controls
	m_lstbxSegments.SubclassDlgItem( IDC_LIST_VIRTUAL_SEGMENTS, this );
	m_lstbxSegments.m_pSongDlg = this;

	m_lstbxTracks.SubclassDlgItem( IDC_LIST_TRACKS, this );
	m_lstbxTracks.m_pSongDlg = this;

	m_lstbxTransitions.SubclassDlgItem( IDC_LIST_TRANSITIONS, this );
	m_lstbxTransitions.m_pSongDlg = this;

	// Set transition button bitmap

	// Load button bitmaps
	if( InterlockedIncrement( &sm_lBitmapRefCount ) == 1 )
	{
		if( sm_bmpTransition.GetSafeHandle() == NULL )
		{
			sm_bmpTransition.LoadBitmap( IDB_TRANSITION );
		}
	}
	if( sm_bmpTransition.GetSafeHandle() )
	{
		m_btnTransition.SetBitmap( (HBITMAP)sm_bmpTransition.GetSafeHandle() );
	}

	// Limit controls
	m_editName.SetLimitText( DMUS_MAX_NAME );

	// Populate all controls
	SyncSongEditor( SSE_ALL );

	// Set transport to this Song	
	m_pSong->SetActiveTransport();
}


/////////////////////////////////////////////////////////////////////////////
// CSongDlg::OnDestroy

void CSongDlg::OnDestroy() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	HRESULT hr = ::RevokeDragDrop( GetSafeHwnd() );
	ASSERT( SUCCEEDED( hr ) );

	if( InterlockedDecrement( &sm_lBitmapRefCount ) == 0 )
	{
		if( sm_bmpTransition.GetSafeHandle() != NULL )
		{
			sm_bmpTransition.DeleteObject();
		}
	}

	CFormView::OnDestroy();
}


/////////////////////////////////////////////////////////////////////////////
// CSongDlg::OnDragRMenuMove

void CSongDlg::OnDragRMenuMove() 
{
	m_dwDragRMenuEffect = DROPEFFECT_MOVE;	
}


/////////////////////////////////////////////////////////////////////////////
// CSongDlg::OnDragRMenuCopy

void CSongDlg::OnDragRMenuCopy() 
{
	m_dwDragRMenuEffect = DROPEFFECT_COPY;	
}


/////////////////////////////////////////////////////////////////////////////
// CSongDlg::OnDragRMenuCancel

void CSongDlg::OnDragRMenuCancel() 
{
	m_dwDragRMenuEffect = DROPEFFECT_NONE;	
}


/////////////////////////////////////////////////////////////////////////////
// CSongDlg::OnSize

void CSongDlg::OnSize( UINT nType, int cx, int cy ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    if( nType == SIZE_MINIMIZED )
	{
        return;
	}

	CFormView::OnSize( nType, cx, cy );
}


/////////////////////////////////////////////////////////////////////////////
// CSongDlg::DoDrag

void CSongDlg::DoDrag( UINT nID, DWORD dwStartDragButton )
{
	// If already dragging, just return
	if( m_pDragImage )
	{
		return;
	}

	IDataObject* pIDataObject = NULL;
	switch( nID )
	{
		case IDC_LIST_VIRTUAL_SEGMENTS:
// TODO		m_pSong->MarkSelectedTools( UD_DRAGSELECT );
			m_lstbxSegments.CreateDataObject( &pIDataObject );
			break;

		default:
			ASSERT( 0 );
			break;
	}

	if( pIDataObject )
	{
		DWORD dwEffect;
		HRESULT hr;

		// Create image used for drag-drop feedback
		if( m_pDragImage )
		{
			m_pDragImage->BeginDrag( 0, CPoint(8, 12) );
		}

		// Start drag-drop operation
		DWORD dwOKDragEffects = DROPEFFECT_COPY;
// TODO	if( nID == IDC_GRAPH_HEADER )
//		{
//			dwOKDragEffects |= DROPEFFECT_MOVE;
//		}

		m_pDragSong = m_pSong;
		m_nStartDragControlID = nID;
		m_dwStartDragButton = dwStartDragButton;
		hr = ::DoDragDrop( pIDataObject, (IDropSource *)this, dwOKDragEffects, &dwEffect );
		m_pDragSong = NULL;
		m_nStartDragControlID = 0;
		m_dwStartDragButton = 0;
		m_pointMouseDown.x = 0;
		m_pointMouseDown.y = 0;

		// Delete image used for drag-drop feedback
		if( m_pDragImage )
		{
			m_pDragImage->EndDrag();

			delete m_pDragImage;
			m_pDragImage = NULL;
		}

// TODO
/*
		switch( hr )
		{
			case DRAGDROP_S_DROP:
				if( dwEffect & DROPEFFECT_MOVE )
				{
					ASSERT( nID == IDC_GRAPH_HEADER );
					if( m_fDragToSameSong == false )
					{
						m_pSong->m_pUndoMgr->SaveState( m_pSong, theApp.m_hInstance, IDS_UNDO_DELETE_TOOLS );
						m_pSong->DeleteMarkedTools( UD_DRAGSELECT );
						m_pSong->SetModified( TRUE );
					}
					m_pSong->Refresh();
				}
				else if( dwEffect & DROPEFFECT_COPY )
				{
					if( m_fDragToSameSong == false )
					{
						m_pSong->UnselectAllTools();
					}
					m_pSong->Refresh();
				}
				break;
		}
*/

// TODO		m_pSong->UnMarkTools( UD_DRAGSELECT ); 
			
		RELEASE( pIDataObject );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CSongDlg::CanPasteFromData

HRESULT CSongDlg::CanPasteFromData( IDataObject* pIDataObject, bool fInDragDrop, POINT pt, bool* fMoveIsOK )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( pIDataObject == NULL )
	{
		return E_INVALIDARG;
	}

	*fMoveIsOK = true;

	if( fInDragDrop )
	{
		// Need to set m_nEditMenuCtrlID
		ScreenToClient( &pt );
		CWnd* pWnd = ChildWindowFromPoint( pt, CWP_ALL );
		if( pWnd )
		{
			m_nEditMenuCtrlID = pWnd->GetDlgCtrlID();
		}
		else
		{
			m_nEditMenuCtrlID = -1;
		}
		ClientToScreen( &pt );
	}

	HRESULT hr = E_FAIL;

	// Create a new CDllJazzDataObject and see if it contains a Song
	CDllJazzDataObject* pDataObject = new CDllJazzDataObject();
	if( pDataObject == NULL )
	{
		return E_OUTOFMEMORY;
	}

	// See what control we are over
	switch( m_nEditMenuCtrlID )
	{
		case IDC_LIST_VIRTUAL_SEGMENTS:
			if( SUCCEEDED (	pDataObject->IsClipFormatAvailable( pIDataObject, theApp.m_pSongComponent->m_cfSegment ) ) )
			{
				IDMUSProdNode* pIDocRootNode;
				if( SUCCEEDED ( theApp.m_pSongComponent->m_pIFramework8->GetDocRootNodeFromData( pIDataObject, &pIDocRootNode ) ) )
				{
					*fMoveIsOK = false;
					hr = S_OK;

					RELEASE( pIDocRootNode );
				}
			}
			else if( SUCCEEDED ( pDataObject->IsClipFormatAvailable( pIDataObject, theApp.m_pSongComponent->m_cfVirtualSegmentList ) ) )
			{
				if( IsDataObjectFromSameSong(pIDataObject) )
				{
					*fMoveIsOK = true;
					hr = S_OK;
				}
			}
			break;

		case IDC_LIST_TRACKS:
			if( SUCCEEDED ( pDataObject->IsClipFormatAvailable( pIDataObject, theApp.m_pSongComponent->m_cfTrackList ) ) )
			{
				// We will paste into ALL selected virtual segments
				if( m_lstbxSegments.GetSelCount() > 0 )
				{
					if( IsDataObjectFromSameSong(pIDataObject) )
					{
						*fMoveIsOK = false;
						hr = S_OK;
					}
				}
			}
			break;

		case IDC_LIST_TRANSITIONS:
			if( SUCCEEDED (	pDataObject->IsClipFormatAvailable( pIDataObject, theApp.m_pSongComponent->m_cfTransitionList ) ) )
			{
				// We will paste into ALL selected virtual segments
				if( m_lstbxSegments.GetSelCount() > 0 )
				{
					if( IsDataObjectFromSameSong(pIDataObject) )
					{
						*fMoveIsOK = false;
						hr = S_OK;
					}
				}
			}
			break;

	}

	RELEASE( pDataObject );
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CSongDlg::PasteFromData

HRESULT CSongDlg::PasteFromData( IDataObject* pIDataObject, bool fInDragDrop, POINT pt )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( pIDataObject == NULL )
	{
		return E_INVALIDARG;
	}

	bool fMoveIsOK = false;
	if( CanPasteFromData( pIDataObject, fInDragDrop, pt, &fMoveIsOK ) != S_OK )
	{
		ASSERT( 0 );
		return E_UNEXPECTED;
	}

	// Create a new CDllJazzDataObject to get the data object's stream.
	CDllJazzDataObject* pDataObject = new CDllJazzDataObject();
	if( pDataObject == NULL )
	{
		return E_OUTOFMEMORY;
	}
	
	HRESULT hr = E_FAIL;

	// See what control we are over
	switch( m_nEditMenuCtrlID )
	{
		case IDC_LIST_VIRTUAL_SEGMENTS:
		{
			// Determine pt
			if( fInDragDrop )
			{
				// Drop
				m_lstbxSegments.ScreenToClient( &pt );
			}
			else
			{
				// Paste
				pt = m_lstbxSegments.m_ptLastXYPos;
			}

			// Handle CF_SEGMENT format
			if( SUCCEEDED (	pDataObject->IsClipFormatAvailable( pIDataObject, theApp.m_pSongComponent->m_cfSegment ) ) )
			{
				hr = CF_SEGMENT_PasteVirtualSegment( pDataObject, pIDataObject, fInDragDrop, pt );
			}

			// Handle CF_VIRTUAL_SEGMENT_LIST format
			else if( SUCCEEDED ( pDataObject->IsClipFormatAvailable( pIDataObject, theApp.m_pSongComponent->m_cfVirtualSegmentList ) ) )
			{
				hr = CF_VIRTUAL_SEGMENT_LIST_PasteVirtualSegment( pDataObject, pIDataObject, fInDragDrop, pt );
			}
			break;
		}

		case IDC_LIST_TRACKS:
		{
			// Determine pt
			if( fInDragDrop )
			{
				// Drop
				m_lstbxTracks.ScreenToClient( &pt );
			}
			else
			{
				// Paste
				pt = m_lstbxTracks.m_ptLastXYPos;
			}

			// Handle CF_TRACK_LIST format
			if( SUCCEEDED ( pDataObject->IsClipFormatAvailable( pIDataObject, theApp.m_pSongComponent->m_cfTrackList ) ) )
			{
				hr = CF_TRACK_LIST_PasteTrack( pDataObject, pIDataObject, fInDragDrop, pt );
			}
			break;
		}

		case IDC_LIST_TRANSITIONS:
		{
			// Determine pt
			if( fInDragDrop )
			{
				// Drop
				m_lstbxTransitions.ScreenToClient( &pt );
			}
			else
			{
				// Paste
				pt = m_lstbxTransitions.m_ptLastXYPos;
			}

			// Handle CF_TRANSITION_LIST format
			if( SUCCEEDED ( pDataObject->IsClipFormatAvailable( pIDataObject, theApp.m_pSongComponent->m_cfTransitionList ) ) )
			{
				hr = CF_TRANSITION_LIST_PasteTransition( pDataObject, pIDataObject, fInDragDrop, pt );
			}
			break;
		}

		default:
			// Should not happen!
			ASSERT( 0 );
			break;
	}

	RELEASE( pDataObject );
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CSongDlg::CF_SEGMENT_PasteVirtualSegment

HRESULT CSongDlg::CF_SEGMENT_PasteVirtualSegment( CDllJazzDataObject* pDataObject, IDataObject* pIDataObject, bool fInDragDrop, POINT pt )
{
	HRESULT hr = E_FAIL;

	// Create a VirtualSegment 
	CVirtualSegment* pVirtualSegment = new CVirtualSegment( m_pSong );
	if( pVirtualSegment )
	{
		IDMUSProdNode* pIDocRootNode;
		if( SUCCEEDED ( theApp.m_pSongComponent->m_pIFramework8->GetDocRootNodeFromData( pIDataObject, &pIDocRootNode ) ) )
		{
			// Make sure the DocRoot is n the SourceSegment list
			if( m_pSong->IsSourceSegmentInSong( pIDocRootNode ) == FALSE )
			{
				m_pSong->m_FolderSegments.m_FolderReference.PasteFromData( pIDataObject );
			}

			// Get the stream containing the Segment
			IStream* pIStream;
			if( SUCCEEDED (	pDataObject->AttemptRead( pIDataObject, theApp.m_pSongComponent->m_cfSegment, &pIStream  ) ) )
			{
				LARGE_INTEGER liTemp;

				// Seek to beginning of stream
				liTemp.QuadPart = 0;
				pIStream->Seek( liTemp, STREAM_SEEK_SET, NULL );

				// Initialize VirtualSegment
				if( SUCCEEDED ( pVirtualSegment->SetDefaultValues( pIStream ) ) )
				{
					// Set m_pSourceSegment
					pVirtualSegment->m_pSourceSegment = m_pSong->GetSourceSegmentFromDocRoot( pIDocRootNode );
					if( pVirtualSegment->m_pSourceSegment )
					{
						pVirtualSegment->m_pSourceSegment->AddRef();
					}

					// Find position in list
					int nPos;
					if( fInDragDrop )
					{
						// Drop
						BOOL fOutside;
						nPos = m_lstbxSegments.ItemFromPoint( pt, fOutside );
						if( fOutside == TRUE
						||  nPos == LB_ERR )
						{
							nPos = -1;
						}
					}
					else
					{
						// Paste
						BOOL fOutside;
						nPos = m_lstbxSegments.ItemFromPoint( m_lstbxSegments.m_ptLastXYPos, fOutside );
						if( fOutside == TRUE
						||  nPos == LB_ERR )
						{
							nPos = -1;
						}
					}

					// Save undo state
					if( fInDragDrop )
					{
						if( m_dwOverDragEffect == DROPEFFECT_MOVE 
						&&  m_pDragSong == m_pSong )
						{
							m_pSong->m_pUndoMgr->SaveState( m_pSong, theApp.m_hInstance, IDS_UNDO_MOVE_VIRTUAL_SEGMENTS );
// TODO						m_pSong->DeleteMarkedTools( UD_DRAGSELECT );
						}
						else
						{
							m_pSong->m_pUndoMgr->SaveState( m_pSong, theApp.m_hInstance, IDS_UNDO_ADD_VIRTUAL_SEGMENT );
						}
					}
					else
					{
						m_pSong->m_pUndoMgr->SaveState( m_pSong, theApp.m_hInstance, IDS_UNDO_ADD_VIRTUAL_SEGMENT );
					}

					// Insert the VirtualSegment into the Song
					m_pSong->InsertVirtualSegment( pVirtualSegment, nPos );

					// Determine "next" VirtualSegment
					if( nPos == -1 )
					{
						nPos = m_pSong->VirtualSegmentToIndex( pVirtualSegment );
					}
					CVirtualSegment* pPrevVirtualSegment = m_pSong->IndexToVirtualSegment( nPos - 1 );
					CVirtualSegment* pNextVirtualSegment = m_pSong->IndexToVirtualSegment( nPos + 1 );
					if( pPrevVirtualSegment )
					{
						if( pPrevVirtualSegment->m_pNextVirtualSegment
						&&	pPrevVirtualSegment->m_pNextVirtualSegment == pNextVirtualSegment )
						{
							RELEASE( pPrevVirtualSegment->m_pNextVirtualSegment );
							pPrevVirtualSegment->m_pNextVirtualSegment = pVirtualSegment;
							pPrevVirtualSegment->m_pNextVirtualSegment->AddRef();
						}
						else if( pPrevVirtualSegment->m_pNextVirtualSegment == NULL
							 &&  pNextVirtualSegment == NULL )
						{
							RELEASE( pPrevVirtualSegment->m_pNextVirtualSegment );
							pPrevVirtualSegment->m_pNextVirtualSegment = pVirtualSegment;
							pPrevVirtualSegment->m_pNextVirtualSegment->AddRef();
						}
					}
					if( pNextVirtualSegment )
					{
						RELEASE( pVirtualSegment->m_pNextVirtualSegment );
						pVirtualSegment->m_pNextVirtualSegment = pNextVirtualSegment;
						pVirtualSegment->m_pNextVirtualSegment->AddRef();
					}

					// Sync changes
					m_pSong->SetModified( TRUE );
					m_pSong->SyncChanges( SC_EDITOR | SC_DIRECTMUSIC,
										  SSE_VIRTUAL_SEGMENT_LIST,
										  NULL );

					// Select the VirtualSegment
					SelectVirtualSegment( pVirtualSegment );
					RefreshProperties( IDC_LIST_VIRTUAL_SEGMENTS );
					hr = S_OK;
				}

				RELEASE( pIStream );
			}

			RELEASE( pIDocRootNode );
		}
	}

	RELEASE( pVirtualSegment );
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CSongDlg::CF_VIRTUAL_SEGMENT_LIST_PasteVirtualSegment

HRESULT CSongDlg::CF_VIRTUAL_SEGMENT_LIST_PasteVirtualSegment( CDllJazzDataObject* pDataObject, IDataObject* pIDataObject, bool fInDragDrop, POINT pt )
{
    IDMUSProdRIFFStream* pIRiffStream;
	IStream* pIStream;
    MMCKINFO ckMain;
	MMCKINFO ckList;
	MMCKINFO ck;
	int nThePos;

	// New VirtualSegments
	CTypedPtrList<CPtrList, CVirtualSegment*> list;

	// Find position in VirtualSegment list
	int nPos;
	BOOL fOutside;
	nPos = m_lstbxSegments.ItemFromPoint( pt, fOutside );
	if( fOutside == TRUE
	||  nPos == LB_ERR )
	{
		nPos = -1;
	}

	HRESULT hr = E_FAIL;

	// Get the stream containing the Segment
	if( SUCCEEDED (	pDataObject->AttemptRead( pIDataObject, theApp.m_pSongComponent->m_cfVirtualSegmentList, &pIStream  ) ) )
	{
		if( SUCCEEDED( AllocRIFFStream( pIStream, &pIRiffStream ) ) )
		{
			// Seek to beginning of stream
			LARGE_INTEGER liTemp;
			liTemp.QuadPart = 0;
			pIStream->Seek( liTemp, STREAM_SEEK_SET, NULL );

			ckMain.fccType = DMUS_FOURCC_SONG_FORM;
			if( pIRiffStream->Descend( &ckMain, NULL, MMIO_FINDRIFF ) == 0 )
			{
				ckList.fccType = DMUS_FOURCC_SEGREFS_LIST;
				if( pIRiffStream->Descend( &ckList, &ckMain, MMIO_FINDLIST ) == 0 )
				{
					while( pIRiffStream->Descend( &ck, &ckList, 0 ) == 0 )
					{
						switch( ck.ckid )
						{
							case FOURCC_LIST:
								switch( ck.fccType )
								{
									case DMUS_FOURCC_SEGREF_LIST:
									{
										CVirtualSegment* pVirtualSegment = new CVirtualSegment( m_pSong );
										if( pVirtualSegment == NULL )
										{
											hr = E_OUTOFMEMORY;
											break;
										}

										hr = pVirtualSegment->Load( pIRiffStream, &ck );
										if( FAILED ( hr ) )
										{
											delete pVirtualSegment;
											break;
										}

										// Keep track of the newly created Virtual Segment
										list.AddTail( pVirtualSegment );
									}
									break;
								}
						}
						
						if( FAILED ( hr ) )
						{
							break;
						}

					    pIRiffStream->Ascend( &ck, 0 );
					}
				}
			}

			RELEASE( pIRiffStream );
		}

		RELEASE( pIStream );
	}

	if( SUCCEEDED ( hr ) 
	&&  !list.IsEmpty() )
	{
		// Save undo state
		if( fInDragDrop )
		{
			if( m_dwOverDragEffect == DROPEFFECT_MOVE 
			&&  m_pDragSong == m_pSong )
			{
				m_pSong->m_pUndoMgr->SaveState( m_pSong, theApp.m_hInstance, IDS_UNDO_MOVE_VIRTUAL_SEGMENTS );
// TODO			m_pSong->DeleteMarkedTools( UD_DRAGSELECT );
			}
			else
			{
				m_pSong->m_pUndoMgr->SaveState( m_pSong, theApp.m_hInstance, IDS_UNDO_ADD_VIRTUAL_SEGMENT );
			}
		}
		else
		{
			m_pSong->m_pUndoMgr->SaveState( m_pSong, theApp.m_hInstance, IDS_UNDO_ADD_VIRTUAL_SEGMENT );
		}

		POSITION pos = list.GetHeadPosition();
		while( pos )
		{
			CVirtualSegment* pVirtualSegment = list.GetNext( pos );

			// Insert the VirtualSegment into the Song
			m_pSong->InsertVirtualSegment( pVirtualSegment, nPos );

			// Determine "next" VirtualSegment
			nThePos = nPos;
			if( nThePos == -1 )
			{
				nThePos = m_pSong->VirtualSegmentToIndex( pVirtualSegment );
			}
			CVirtualSegment* pPrevVirtualSegment = m_pSong->IndexToVirtualSegment( nThePos - 1 );
			CVirtualSegment* pNextVirtualSegment = m_pSong->IndexToVirtualSegment( nThePos + 1 );
			if( pPrevVirtualSegment )
			{
				if( pPrevVirtualSegment->m_pNextVirtualSegment
				&&	pPrevVirtualSegment->m_pNextVirtualSegment == pNextVirtualSegment )
				{
					RELEASE( pPrevVirtualSegment->m_pNextVirtualSegment );
					pPrevVirtualSegment->m_pNextVirtualSegment = pVirtualSegment;
					pPrevVirtualSegment->m_pNextVirtualSegment->AddRef();
				}
				else if( pPrevVirtualSegment->m_pNextVirtualSegment == NULL
					 &&  pNextVirtualSegment == NULL )
				{
					RELEASE( pPrevVirtualSegment->m_pNextVirtualSegment );
					pPrevVirtualSegment->m_pNextVirtualSegment = pVirtualSegment;
					pPrevVirtualSegment->m_pNextVirtualSegment->AddRef();
				}
			}
			if( pNextVirtualSegment )
			{
				RELEASE( pVirtualSegment->m_pNextVirtualSegment );
				pVirtualSegment->m_pNextVirtualSegment = pNextVirtualSegment;
				pVirtualSegment->m_pNextVirtualSegment->AddRef();
			}

			// Increment nPos
			if( nPos >= 0 )
			{
				nPos++;
			}
		}

		// Sync changes
		m_pSong->SetModified( TRUE );
		m_pSong->SyncChanges( SC_EDITOR | SC_DIRECTMUSIC,
							  SSE_VIRTUAL_SEGMENT_LIST,
							  NULL );

		// Select the VirtualSegment(s)
		m_lstbxSegments.SelectVirtualSegmentList( list );

		RefreshProperties( IDC_LIST_VIRTUAL_SEGMENTS );
	}

	// Cleanup
	while( !list.IsEmpty() )
	{
		CVirtualSegment* pVirtualSegment = list.RemoveHead();

		RELEASE( pVirtualSegment );
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CSongDlg::CF_TRANSITION_LIST_PasteTransition

HRESULT CSongDlg::CF_TRANSITION_LIST_PasteTransition( CDllJazzDataObject* pDataObject, IDataObject* pIDataObject, bool fInDragDrop, POINT pt )
{
    IDMUSProdRIFFStream* pIRiffStream;
	IStream* pIStream;
    MMCKINFO ckMain;
	MMCKINFO ck;
	DWORD dwByteCount;
	DWORD dwSize;

	// We will paste into ALL selected virtual segments
	int nNbrSelItems = m_lstbxSegments.GetSelCount();
	if( nNbrSelItems <= 0 )
	{
		ASSERT( 0 );
		return E_UNEXPECTED;
	}

	// New Transitions
	CTypedPtrList<CPtrList, CTransition*> list;

	HRESULT hr = E_FAIL;

	// Get the stream containing the Transitions
	if( SUCCEEDED (	pDataObject->AttemptRead( pIDataObject, theApp.m_pSongComponent->m_cfTransitionList, &pIStream  ) ) )
	{
		if( SUCCEEDED( AllocRIFFStream( pIStream, &pIRiffStream ) ) )
		{
			// Seek to beginning of stream
			LARGE_INTEGER liTemp;
			liTemp.QuadPart = 0;
			pIStream->Seek( liTemp, STREAM_SEEK_SET, NULL );

			ckMain.fccType = DMUS_FOURCC_SEGREF_LIST;
			if( pIRiffStream->Descend( &ckMain, NULL, MMIO_FINDLIST ) == 0 )
			{
				ck.ckid = DMUS_FOURCC_TRANSITION_COPY_PASTE_UI_CHUNK;
				if( pIRiffStream->Descend( &ck, &ckMain, MMIO_FINDCHUNK ) == 0 )
				{
					ioTransitionCopyPasteUI iTransitionCopyPasteUI;
					CTransition* pTransition;

					dwSize = ck.cksize;
					while( dwSize > 0 )
					{
						hr = pIStream->Read( &iTransitionCopyPasteUI, sizeof(ioTransitionCopyPasteUI), &dwByteCount );
						if( FAILED( hr )
						||  dwByteCount != sizeof(ioTransitionCopyPasteUI) )
						{
							hr = E_FAIL;
							break;
						}

						pTransition = new CTransition( m_pSong );
						if( pTransition == NULL )
						{
							hr = E_OUTOFMEMORY;
							break;
						}

						pTransition->m_dwToSegmentFlag = iTransitionCopyPasteUI.dwToSegmentFlag;
						pTransition->m_pToSegment = m_pSong->PtrToVirtualSegment( iTransitionCopyPasteUI.pToSegment );
						if( pTransition->m_pToSegment )
						{
							ASSERT( pTransition->m_dwToSegmentFlag == 0 ); 
							pTransition->m_pToSegment->AddRef();
						}
						else
						{
							// No "To Segment" so we must have a value in m_dwToSegmentFlag
							if( pTransition->m_dwToSegmentFlag == 0 )
							{
								pTransition->m_dwToSegmentFlag = DMUS_SONG_NOSEG;
							}
						}
						pTransition->m_pTransitionSegment = m_pSong->PtrToVirtualSegment( iTransitionCopyPasteUI.pTransitionSegment );
						if( pTransition->m_pTransitionSegment )
						{
							pTransition->m_pTransitionSegment->AddRef();
						}
						pTransition->m_dwPlayFlagsDM = iTransitionCopyPasteUI.dwPlayFlagsDM;
						list.AddTail( pTransition );

						dwSize -= dwByteCount;
					}
				}
			}

			RELEASE( pIRiffStream );
		}

		RELEASE( pIStream );
	}

	if( SUCCEEDED ( hr ) 
	&&  !list.IsEmpty() )
	{
		// Save undo state
		if( fInDragDrop )
		{
			if( m_dwOverDragEffect == DROPEFFECT_MOVE 
			&&  m_pDragSong == m_pSong )
			{
				m_pSong->m_pUndoMgr->SaveState( m_pSong, theApp.m_hInstance, IDS_UNDO_MOVE_TRANSITIONS );
// TODO			m_pSong->DeleteMarkedTools( UD_DRAGSELECT );
			}
			else
			{
				m_pSong->m_pUndoMgr->SaveState( m_pSong, theApp.m_hInstance, IDS_UNDO_ADD_TRANSITION );
			}
		}
		else
		{
			m_pSong->m_pUndoMgr->SaveState( m_pSong, theApp.m_hInstance, IDS_UNDO_ADD_TRANSITION );
		}

		// Insert Transitions into the selected VirtualSegments
		int* pnSelItems = new int[nNbrSelItems];
		if( pnSelItems )
		{
			m_lstbxSegments.GetSelItems( nNbrSelItems, pnSelItems );

			for( int i = 0;  i < nNbrSelItems ;  i++ )
			{
				CVirtualSegment* pVirtualSegment = (CVirtualSegment *)m_lstbxSegments.GetItemDataPtr( pnSelItems[i] );
			
				if( pVirtualSegment
				&&  pVirtualSegment != (CVirtualSegment *)0xFFFFFFFF )
				{
					POSITION pos = list.GetHeadPosition();
					while( pos )
					{
						CTransition* pTransition = list.GetNext( pos );

						if( i == 0 )
						{
							// Insert the Transition into the VirtualSegment
							pVirtualSegment->InsertTransition( pTransition );
						}
						else
						{
							// Insert a copy of the Transition into the VirtualSegment
							CTransition* pTransitionDupe = new CTransition( m_pSong );
							if( pTransitionDupe )
							{
								pTransitionDupe->Copy( pTransition );
								pVirtualSegment->InsertTransition( pTransitionDupe );
								RELEASE( pTransitionDupe );
							}
						}
					}
				}
			}

			delete [] pnSelItems;
		}

		// Sync changes
		m_pSong->SetModified( TRUE );
		m_pSong->SyncChanges( SC_EDITOR | SC_DIRECTMUSIC,
							  SSE_TRANSITION_LIST,
							  NULL );

		// Select the Transition(s)
		m_lstbxTransitions.SelectTransitionList( list );

		RefreshProperties( IDC_LIST_TRANSITIONS );
	}

	// Cleanup
	while( !list.IsEmpty() )
	{
		CTransition* pTransition = list.RemoveHead();

		RELEASE( pTransition );
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CSongDlg::CF_TRACK_LIST_PasteTrack

HRESULT CSongDlg::CF_TRACK_LIST_PasteTrack( CDllJazzDataObject* pDataObject, IDataObject* pIDataObject, bool fInDragDrop, POINT pt )
{
    IDMUSProdRIFFStream* pIRiffStream;
	IStream* pIStream;
    MMCKINFO ckMain;
	MMCKINFO ckList;
	MMCKINFO ck;

	// We will paste into ALL selected virtual segments
	int nNbrSelItems = m_lstbxSegments.GetSelCount();
	if( nNbrSelItems <= 0 )
	{
		ASSERT( 0 );
		return E_UNEXPECTED;
	}

	// New Tracks
	CTypedPtrList<CPtrList, CTrack*> list;

	HRESULT hr = E_FAIL;

	// Get the stream containing the Tracks
	if( SUCCEEDED (	pDataObject->AttemptRead( pIDataObject, theApp.m_pSongComponent->m_cfTrackList, &pIStream  ) ) )
	{
		if( SUCCEEDED( AllocRIFFStream( pIStream, &pIRiffStream ) ) )
		{
			// Seek to beginning of stream
			LARGE_INTEGER liTemp;
			liTemp.QuadPart = 0;
			pIStream->Seek( liTemp, STREAM_SEEK_SET, NULL );

			ckMain.fccType = DMUS_FOURCC_SEGREF_LIST;
			if( pIRiffStream->Descend( &ckMain, NULL, MMIO_FINDLIST ) == 0 )
			{
				ckList.fccType = DMUS_FOURCC_TRACKREFS_LIST;
				if( pIRiffStream->Descend( &ckList, &ckMain, MMIO_FINDLIST ) == 0 )
				{
					while( pIRiffStream->Descend( &ck, &ckList, 0 ) == 0 )
					{
						switch( ck.ckid )
						{
							case FOURCC_LIST:
								switch( ck.fccType )
								{
									case DMUS_FOURCC_TRACKREF_LIST:
									{
										CTrack* pTrack = new CTrack( m_pSong );
										if( pTrack == NULL )
										{
											hr = E_OUTOFMEMORY;
											break;
										}

										hr = pTrack->Load( pIRiffStream, &ck );
										if( hr == S_OK )
										{
											// Keep track of the newly created Track
											list.AddTail( pTrack );
										}
										else if( hr == S_FALSE )
										{
											// Could not resolve SourceSegment so discard this track
											RELEASE( pTrack );
											hr = S_OK;
										}
										else
										{
											RELEASE( pTrack );
										}
									}
									break;
								}
						}
						
						if( FAILED ( hr ) )
						{
							break;
						}

					    pIRiffStream->Ascend( &ck, 0 );
					}
				}
			}

			RELEASE( pIRiffStream );
		}

		RELEASE( pIStream );
	}

	if( SUCCEEDED ( hr ) 
	&&  !list.IsEmpty() )
	{
		// Save undo state
		if( fInDragDrop )
		{
			if( m_dwOverDragEffect == DROPEFFECT_MOVE 
			&&  m_pDragSong == m_pSong )
			{
				m_pSong->m_pUndoMgr->SaveState( m_pSong, theApp.m_hInstance, IDS_UNDO_MOVE_TRACKS );
// TODO			m_pSong->DeleteMarkedTools( UD_DRAGSELECT );
			}
			else
			{
				m_pSong->m_pUndoMgr->SaveState( m_pSong, theApp.m_hInstance, IDS_UNDO_ADD_TRACK );
			}
		}
		else
		{
			m_pSong->m_pUndoMgr->SaveState( m_pSong, theApp.m_hInstance, IDS_UNDO_ADD_TRACK );
		}

		// Insert Tracks into the selected VirtualSegments
		int* pnSelItems = new int[nNbrSelItems];
		if( pnSelItems )
		{
			m_lstbxSegments.GetSelItems( nNbrSelItems, pnSelItems );

			for( int i = 0;  i < nNbrSelItems ;  i++ )
			{
				CVirtualSegment* pVirtualSegment = (CVirtualSegment *)m_lstbxSegments.GetItemDataPtr( pnSelItems[i] );
			
				if( pVirtualSegment
				&&  pVirtualSegment != (CVirtualSegment *)0xFFFFFFFF )
				{
					POSITION pos = list.GetHeadPosition();
					while( pos )
					{
						CTrack* pTrack = list.GetNext( pos );

						if( i == 0 )
						{
							// Insert the Track into the VirtualSegment
							pVirtualSegment->InsertTrack( pTrack );
						}
						else
						{
							// Insert a copy of the Track into the VirtualSegment
							CTrack* pTrackDupe = new CTrack( m_pSong );
							if( pTrackDupe )
							{
								pTrackDupe->Copy( pTrack );
								pVirtualSegment->InsertTrack( pTrackDupe );
								RELEASE( pTrackDupe );
							}
						}
					}
				}
			}

			delete [] pnSelItems;
		}

		// Sync changes
		m_pSong->SetModified( TRUE );
		m_pSong->SyncChanges( SC_EDITOR | SC_DIRECTMUSIC,
							  SSE_TRACK_LIST,
							  NULL );

		// Select the Track(s)
		m_lstbxTracks.SelectTrackList( list );

		RefreshProperties( IDC_LIST_TRACKS );
	}

	// Cleanup
	while( !list.IsEmpty() )
	{
		CTrack* pTrack = list.RemoveHead();

		RELEASE( pTrack );
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CSongDlg::GetVirtualSegmentToEdit

CVirtualSegment* CSongDlg::GetVirtualSegmentToEdit( void ) 
{
	if( m_lstbxSegments.GetCount() > 0
	&&  m_lstbxSegments.GetSelCount() == 1 )
	{
		// One item selected in VirtualSegments list
		int nSelItem;
		m_lstbxSegments.GetSelItems( 1, &nSelItem );

		CVirtualSegment* pVirtualSegment = (CVirtualSegment *)m_lstbxSegments.GetItemDataPtr( nSelItem );
	
		if( pVirtualSegment
		&&  pVirtualSegment != (CVirtualSegment *)0xFFFFFFFF )
		{
			return pVirtualSegment;
		}
	}

	return NULL;
}


/////////////////////////////////////////////////////////////////////////////
// CSongDlg::GetTrackToEdit

CTrack* CSongDlg::GetTrackToEdit( void ) 
{
	CVirtualSegment* pVirtualSegmentToEdit = GetVirtualSegmentToEdit();
	if( pVirtualSegmentToEdit == NULL )
	{
		return NULL;
	}

	if( m_lstbxTracks.GetCount() > 0
	&&  m_lstbxTracks.GetSelCount() == 1 )
	{
		// One item selected in Tracks list
		int nSelItem;
		m_lstbxTracks.GetSelItems( 1, &nSelItem );

		CTrack* pTrack = (CTrack *)m_lstbxTracks.GetItemDataPtr( nSelItem );
	
		if( pTrack
		&&  pTrack != (CTrack *)0xFFFFFFFF )
		{
			return pTrack;
		}
	}

	return NULL;
}


/////////////////////////////////////////////////////////////////////////////
// CSongDlg::GetTransitionToEdit

CTransition* CSongDlg::GetTransitionToEdit( void ) 
{
	CVirtualSegment* pVirtualSegmentToEdit = GetVirtualSegmentToEdit();
	if( pVirtualSegmentToEdit == NULL )
	{
		return NULL;
	}

	if( m_lstbxTransitions.GetCount() > 0
	&&  m_lstbxTransitions.GetSelCount() == 1 )
	{
		// One item selected in Transitions list
		int nSelItem;
		m_lstbxTransitions.GetSelItems( 1, &nSelItem );

		CTransition* pTransition = (CTransition *)m_lstbxTransitions.GetItemDataPtr( nSelItem );
	
		if( pTransition
		&&  pTransition != (CTransition *)0xFFFFFFFF )
		{
			return pTransition;
		}
	}

	return NULL;
}


/////////////////////////////////////////////////////////////////////////////
// CSongDlg::GetVirtualSegmentSelCount

int CSongDlg::GetVirtualSegmentSelCount( void ) 
{
	if( m_lstbxSegments.GetCount() > 0 )
	{
		return m_lstbxSegments.GetSelCount();
	}

	return 0;
}


/////////////////////////////////////////////////////////////////////////////
// CSongDlg::GetTrackSelCount

int CSongDlg::GetTrackSelCount( void ) 
{
	CVirtualSegment* pVirtualSegmentToEdit = GetVirtualSegmentToEdit();
	if( pVirtualSegmentToEdit == NULL )
	{
		return 0;
	}

	if( m_lstbxTracks.GetCount() > 0 )
	{
		return m_lstbxTracks.GetSelCount();
	}

	return 0;
}


/////////////////////////////////////////////////////////////////////////////
// CSongDlg::GetTransitionSelCount

int CSongDlg::GetTransitionSelCount( void ) 
{
	CVirtualSegment* pVirtualSegmentToEdit = GetVirtualSegmentToEdit();
	if( pVirtualSegmentToEdit == NULL )
	{
		return 0;
	}

	if( m_lstbxTransitions.GetCount() > 0 )
	{
		return m_lstbxTransitions.GetSelCount();
	}

	return 0;
}


/////////////////////////////////////////////////////////////////////////////
// CSongDlg::OnKillFocusEditName

void CSongDlg::OnKillFocusEditName( void ) 
{
	CVirtualSegment* pVirtualSegmentToEdit = GetVirtualSegmentToEdit();
	if( pVirtualSegmentToEdit == NULL )
	{
		return;
	}

	CString strName;
	m_editName.GetWindowText( strName );

	// Strip leading and trailing spaces
	strName.TrimRight();
	strName.TrimLeft();

	if( strName.Compare( pVirtualSegmentToEdit->m_strName ) != 0 )
	{
		CString strOrigName = pVirtualSegmentToEdit->m_strName;
		pVirtualSegmentToEdit->m_strName = strName;
		BOOL fUnique = m_pSong->IsVirtualSegmentNameUnique( pVirtualSegmentToEdit );
		pVirtualSegmentToEdit->m_strName = strOrigName;

		if( fUnique == FALSE )
		{
			CString strMsg;
			AfxFormatString1( strMsg, IDS_DUPE_VIRTUAL_SEGMENT_NAME, strName );
			AfxMessageBox( strMsg, MB_OK );

			m_editName.SetWindowText( pVirtualSegmentToEdit->m_strName );
			m_editName.SetSel( 0, -1 );
			m_editName.SetFocus();
		}
		else
		{
			m_pSong->m_pUndoMgr->SaveState( m_pSong, theApp.m_hInstance, IDS_UNDO_CHANGE_VIRTUAL_SEGMENT_NAME );

			pVirtualSegmentToEdit->m_strName = strName;

			m_pSong->SetModified( TRUE );
			m_pSong->SyncChanges( SC_EDITOR | SC_PROPERTIES | SC_DIRECTMUSIC,
								  SSE_REDRAW_VIRTUAL_SEGMENT_LIST | SSE_REDRAW_TRANSITION_LIST,
								  NULL );
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CSongDlg::OnSelChangeNextVirtualSegment

void CSongDlg::OnSelChangeNextVirtualSegment( void ) 
{
	CVirtualSegment* pVirtualSegmentToEdit = GetVirtualSegmentToEdit();
	if( pVirtualSegmentToEdit == NULL )
	{
		ASSERT( 0 );
		return;
	}

	int nCurSel = m_comboNextSegment.GetCurSel();
	if( nCurSel != CB_ERR )
	{
		CVirtualSegment* pVirtualSegment = (CVirtualSegment *)m_comboNextSegment.GetItemDataPtr( nCurSel );

		if( pVirtualSegment != (CVirtualSegment *)0xFFFFFFFF )
		{
			m_pSong->m_pUndoMgr->SaveState( m_pSong, theApp.m_hInstance, IDS_UNDO_CHANGE_NEXT_SEGMENT );

			RELEASE( pVirtualSegmentToEdit->m_pNextVirtualSegment );
			pVirtualSegmentToEdit->m_pNextVirtualSegment = pVirtualSegment;

			// pVirtualSegmentToEdit->m_pNextVirtualSegment equals NULL when "<None>" selected
			if( pVirtualSegmentToEdit->m_pNextVirtualSegment )
			{
				pVirtualSegmentToEdit->m_pNextVirtualSegment->AddRef();
			}

			m_pSong->SetModified( TRUE );
			m_pSong->SyncChanges( SC_DIRECTMUSIC, 0, NULL );
		}
	}

	// Need to draw solid/dash lines
	m_lstbxSegments.Invalidate();	
}


/////////////////////////////////////////////////////////////////////////////
// CSongDlg::OnSelChangeSourceSegment

void CSongDlg::OnSelChangeSourceSegment( void ) 
{
	CVirtualSegment* pVirtualSegmentToEdit = GetVirtualSegmentToEdit();
	if( pVirtualSegmentToEdit == NULL )
	{
		ASSERT( 0 );
		return;
	}

	int nCurSel = m_comboSegment.GetCurSel();
	if( nCurSel != CB_ERR )
	{
		CSourceSegment* pSourceSegment = (CSourceSegment *)m_comboSegment.GetItemDataPtr( nCurSel );

		if( pSourceSegment != (CSourceSegment *)0xFFFFFFFF )
		{
			m_pSong->m_pUndoMgr->SaveState( m_pSong, theApp.m_hInstance, IDS_UNDO_CHANGE_SOURCE_SEGMENT );

			RELEASE( pVirtualSegmentToEdit->m_pSourceSegment );
			pVirtualSegmentToEdit->m_pSourceSegment = pSourceSegment;

			// pVirtualSegmentToEdit->m_pSourceSegment equals NULL when "<None>" selected
			if( pVirtualSegmentToEdit->m_pSourceSegment )
			{
				pVirtualSegmentToEdit->m_pSourceSegment->AddRef();
			}

			m_pSong->SetModified( TRUE );
			m_pSong->SyncChanges( SC_PROPERTIES | SC_DIRECTMUSIC,
								  0,
								  NULL );
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CSongDlg::OnSelChangeToolGraph

void CSongDlg::OnSelChangeToolGraph( void ) 
{
	CVirtualSegment* pVirtualSegmentToEdit = GetVirtualSegmentToEdit();
	if( pVirtualSegmentToEdit == NULL )
	{
		ASSERT( 0 );
		return;
	}

	int nCurSel = m_comboToolGraph.GetCurSel();
	if( nCurSel != CB_ERR )
	{
		IDMUSProdNode* pIToolGraphNode = (IDMUSProdNode *)m_comboToolGraph.GetItemDataPtr( nCurSel );

		if( pIToolGraphNode != (IDMUSProdNode *)0xFFFFFFFF )
		{
			m_pSong->m_pUndoMgr->SaveState( m_pSong, theApp.m_hInstance, IDS_UNDO_CHANGE_SOURCE_TOOLGRAPH );

			RELEASE( pVirtualSegmentToEdit->m_pIToolGraphNode );
			pVirtualSegmentToEdit->m_pIToolGraphNode = pIToolGraphNode;

			// pVirtualSegmentToEdit->m_pIToolGraphNode equals NULL when "<None>" selected
			if( pVirtualSegmentToEdit->m_pIToolGraphNode )
			{
				pVirtualSegmentToEdit->m_pIToolGraphNode->AddRef();
			}

			m_pSong->SetModified( TRUE );
			m_pSong->SyncChanges( SC_DIRECTMUSIC, 0, NULL );
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CSongDlg::SelectSourceSegmentComboBox

void CSongDlg::SelectSourceSegmentComboBox( CSourceSegment* pSourceSegment )
{
	int nNbrItems = m_comboSegment.GetCount();

	for( int nPos = 0 ;  nPos < nNbrItems ;  nPos++ )
	{
		CSourceSegment* pSourceSegmentList = (CSourceSegment *)m_comboSegment.GetItemDataPtr( nPos );

		if( pSourceSegmentList == pSourceSegment )
		{
			m_comboSegment.SetCurSel( nPos );
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CSongDlg::SelectVirtualSegmentComboBox

void CSongDlg::SelectVirtualSegmentComboBox( CVirtualSegment* pVirtualSegment )
{
	int nNbrItems = m_comboNextSegment.GetCount();

	for( int nPos = 0 ;  nPos < nNbrItems ;  nPos++ )
	{
		CVirtualSegment* pVirtualSegmentList = (CVirtualSegment *)m_comboNextSegment.GetItemDataPtr( nPos );

		if( pVirtualSegmentList == pVirtualSegment )
		{
			m_comboNextSegment.SetCurSel( nPos );
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CSongDlg::SelectToolGraphComboBox

void CSongDlg::SelectToolGraphComboBox( IDMUSProdNode* pIToolGraphNode )
{
	int nNbrItems = m_comboToolGraph.GetCount();

	for( int nPos = 0 ;  nPos < nNbrItems ;  nPos++ )
	{
		IDMUSProdNode* pIToolGraphNodeList = (IDMUSProdNode *)m_comboToolGraph.GetItemDataPtr( nPos );

		if( pIToolGraphNodeList == pIToolGraphNode )
		{
			m_comboToolGraph.SetCurSel( nPos );
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CSongDlg::FillSourceSegmentComboBox

void CSongDlg::FillSourceSegmentComboBox( void )
{
	CSourceSegment* pCurSelSourceSegment = NULL;

	// Get selection
	int nCurSel = m_comboSegment.GetCurSel();
	if( nCurSel != CB_ERR )
	{
		pCurSelSourceSegment = (CSourceSegment *)m_comboSegment.GetItemDataPtr( nCurSel );
	}

	// Empty combo box
	m_comboSegment.ResetContent();

	// Add "<None>"
	CString strNone;
	strNone.LoadString( IDS_NONE_TEXT );
	int nPos = m_comboSegment.AddString( strNone  );
	m_comboSegment.SetItemDataPtr( nPos, NULL );

	// Add SourceSegments
	CSourceSegment* pSourceSegment;
	for( int i = 0 ;  pSourceSegment = m_pSong->IndexToSourceSegment(i) ;  i++ )
	{
		if( pSourceSegment == NULL )
		{
			break;
		}

		BSTR bstrName;
		pSourceSegment->GetNodeName( &bstrName );
		CString strName = bstrName;
		::SysFreeString( bstrName );

		nPos = m_comboSegment.AddString( strName );
		m_comboSegment.SetItemDataPtr( nPos, pSourceSegment );
	}

	// Restore selection
	if( pCurSelSourceSegment != (CSourceSegment *)0xFFFFFFFF )
	{
		SelectSourceSegmentComboBox( pCurSelSourceSegment );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CSongDlg::FillVirtualSegmentComboBox

void CSongDlg::FillVirtualSegmentComboBox( void )
{
	CVirtualSegment* pCurSelVirtualSegment = NULL;

	// Get selection
	int nCurSel = m_comboNextSegment.GetCurSel();
	if( nCurSel != CB_ERR )
	{
		 pCurSelVirtualSegment = (CVirtualSegment *)m_comboNextSegment.GetItemDataPtr( nCurSel );
	}

	// Empty combo box
	m_comboNextSegment.ResetContent();

	// Add "<None>"
	CString strNone;
	strNone.LoadString( IDS_NONE_TEXT );
	int nPos = m_comboNextSegment.AddString( strNone  );
	m_comboNextSegment.SetItemDataPtr( nPos, NULL );

	// Add VirtualSegments
	POSITION pos = m_pSong->m_lstVirtualSegments.GetHeadPosition();
	while( pos )
	{ 
		CVirtualSegment* pVirtualSegment = m_pSong->m_lstVirtualSegments.GetNext( pos );

		nPos = m_comboNextSegment.AddString( pVirtualSegment->m_strName  );
		m_comboNextSegment.SetItemDataPtr( nPos, pVirtualSegment );
	}

	// Restore selection
	if( pCurSelVirtualSegment != (CVirtualSegment *)0xFFFFFFFF )
	{
		SelectVirtualSegmentComboBox( pCurSelVirtualSegment );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CSongDlg::FillToolGraphComboBox

void CSongDlg::FillToolGraphComboBox( void )
{
	IDMUSProdNode* pICurSelToolGraphNode = NULL;

	// Get Current selection
	int nCurSel = m_comboToolGraph.GetCurSel();
	if( nCurSel != CB_ERR )
	{
		pICurSelToolGraphNode = (IDMUSProdNode *)m_comboToolGraph.GetItemDataPtr( nCurSel );
	}

	// Empty combo box
	m_comboToolGraph.ResetContent();

	// Add "<None>"
	CString strNone;
	strNone.LoadString( IDS_NONE_TEXT );
	int nPos = m_comboToolGraph.AddString( strNone  );
	m_comboToolGraph.SetItemDataPtr( nPos, NULL );

	// Add ToolGraphs
	IDMUSProdNode* pIToolGraphNode;
	for( int i = 0 ;  pIToolGraphNode = m_pSong->IndexToToolGraph(i) ;  i++ )
	{
		if( pIToolGraphNode == NULL )
		{
			break;
		}

		BSTR bstrName;
		pIToolGraphNode->GetNodeName( &bstrName );
		CString strName = bstrName;
		::SysFreeString( bstrName );

		nPos = m_comboToolGraph.AddString( strName );
		m_comboToolGraph.SetItemDataPtr( nPos, pIToolGraphNode );
	}

	// Set selection
	if( pICurSelToolGraphNode != (IDMUSProdNode *)0xFFFFFFFF )
	{
		SelectToolGraphComboBox( pICurSelToolGraphNode );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CSongDlg::FillVirtualSegmentListBox

void CSongDlg::FillVirtualSegmentListBox( void )
{
	CVirtualSegment* pCurSelVirtualSegment = NULL;

	// Get selection
	int nCurSel = m_lstbxSegments.GetCurSel();
	if( nCurSel != CB_ERR )
	{
		 pCurSelVirtualSegment = (CVirtualSegment *)m_lstbxSegments.GetItemDataPtr( nCurSel );
	}

	// Empty list box
	m_lstbxSegments.ResetContent();
	m_lstbxSegments.SetHorizontalExtent( 0 );

	// Add VirtualSegments
	POSITION pos = m_pSong->m_lstVirtualSegments.GetHeadPosition();
	while( pos )
	{ 
		CVirtualSegment* pVirtualSegment = m_pSong->m_lstVirtualSegments.GetNext( pos );

		int nPos = m_lstbxSegments.AddString( _T( "" )  );
		m_lstbxSegments.SetItemDataPtr( nPos, pVirtualSegment );
	}

	// Restore selection
	if( pCurSelVirtualSegment
	&&  pCurSelVirtualSegment != (CVirtualSegment *)0xFFFFFFFF )
	{
		m_lstbxSegments.SelectVirtualSegment( pCurSelVirtualSegment );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CSongDlg::FillTrackListBox

void CSongDlg::FillTrackListBox( CVirtualSegment* pVirtualSegment )
{
	CTrack* pCurSelTrack = NULL;

	// Get selection
	int nCurSel = m_lstbxTracks.GetCurSel();
	if( nCurSel != CB_ERR )
	{
		 pCurSelTrack = (CTrack *)m_lstbxTracks.GetItemDataPtr( nCurSel );
	}

	// Empty list box
	m_lstbxTracks.ResetContent();
	m_lstbxTracks.SetHorizontalExtent( 0 );

	// Add Tracks
	POSITION pos = pVirtualSegment->m_lstTracks.GetHeadPosition();
	while( pos )
	{ 
		CTrack* pTrack = pVirtualSegment->m_lstTracks.GetNext( pos );

		int nPos = m_lstbxTracks.AddString( (LPCTSTR)pTrack  );
	}

	// Restore selection
	if( pCurSelTrack
	&&  pCurSelTrack != (CTrack *)0xFFFFFFFF )
	{
		m_lstbxTracks.SelectTrack( pCurSelTrack, false );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CSongDlg::FillTransitionListBox

void CSongDlg::FillTransitionListBox( CVirtualSegment* pVirtualSegment )
{
	CTransition* pCurSelTransition = NULL;

	// Get selection
	int nCurSel = m_lstbxTransitions.GetCurSel();
	if( nCurSel != CB_ERR )
	{
		 pCurSelTransition = (CTransition *)m_lstbxTransitions.GetItemDataPtr( nCurSel );
	}

	// Empty list box
	m_lstbxTransitions.ResetContent();
	m_lstbxTransitions.SetHorizontalExtent( 0 );

	// Add Transitions
	POSITION pos = pVirtualSegment->m_lstTransitions.GetHeadPosition();
	while( pos )
	{ 
		CTransition* pTransition = pVirtualSegment->m_lstTransitions.GetNext( pos );

		int nPos = m_lstbxTransitions.AddString( _T( "" )  );
		m_lstbxTransitions.SetItemDataPtr( nPos, pTransition );
	}

	// Restore selection
	if( pCurSelTransition
	&&  pCurSelTransition != (CTransition *)0xFFFFFFFF )
	{
		m_lstbxTransitions.SelectTransition( pCurSelTransition, false );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CSongDlg::CreateFont

CFont* CSongDlg::CreateFont( void )
{
	CFont* pFont = new CFont;

	if( pFont 
	&&  pFont->CreateFont( 10, 0, 0, 0, FW_NORMAL, 0, 0, 0,
 						   DEFAULT_CHARSET, OUT_CHARACTER_PRECIS, CLIP_CHARACTER_PRECIS,
						   DEFAULT_QUALITY, DEFAULT_PITCH | FF_DONTCARE, "MS Sans Serif" ) )
	{
		return pFont;
	}

	if( pFont )
	{
		delete pFont;
	}
	return NULL;
}


/////////////////////////////////////////////////////////////////////////////
// CSongDlg::SelectVirtualSegment

void CSongDlg::SelectVirtualSegment( CVirtualSegment* pVirtualSegment )
{
	// Select the VirtualSegment
	m_lstbxSegments.SelectVirtualSegment( pVirtualSegment );
}


/////////////////////////////////////////////////////////////////////////////
// CSongDlg::GetFirstSelectedVirtualSegment

CVirtualSegment* CSongDlg::GetFirstSelectedVirtualSegment( void )
{
	if( m_lstbxSegments.GetCount() > 0 )
	{
		// Get the first item selected in VirtualSegments list
		int nSelItem;
		m_lstbxSegments.GetSelItems( 1, &nSelItem );

		CVirtualSegment* pVirtualSegment = (CVirtualSegment *)m_lstbxSegments.GetItemDataPtr( nSelItem );
	
		if( pVirtualSegment
		&&  pVirtualSegment != (CVirtualSegment *)0xFFFFFFFF )
		{
			return pVirtualSegment;
		}
	}

	return NULL;
}


/////////////////////////////////////////////////////////////////////////////
// CSongDlg::OnUpdateEditCut

void CSongDlg::OnUpdateEditCut( CCmdUI* pCmdUI ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pSong != NULL );
	
	BOOL fEnable = FALSE;
	
	switch( m_nEditMenuCtrlID )
	{
		case IDC_LIST_VIRTUAL_SEGMENTS:
			if( m_lstbxSegments.GetSelCount() > 0 )
			{
				fEnable = TRUE;
			}
			break;
		
		case IDC_LIST_TRACKS:
			if( m_lstbxTracks.GetSelCount() > 0 )
			{
				fEnable = TRUE;
			}
			break;

		case IDC_LIST_TRANSITIONS:
			if( m_lstbxTransitions.GetSelCount() > 0 )
			{
				fEnable = TRUE;
			}
			break;
	}

	pCmdUI->Enable( fEnable );
}


/////////////////////////////////////////////////////////////////////////////
// CSongDlg::OnEditCut

void CSongDlg::OnEditCut() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pSong != NULL );

	switch( m_nEditMenuCtrlID )
	{
		case IDC_LIST_VIRTUAL_SEGMENTS:
		case IDC_LIST_TRACKS:
		case IDC_LIST_TRANSITIONS:
			OnEditCopy();
			OnEditDelete();
			break;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CSongDlg::OnUpdateEditCopy

void CSongDlg::OnUpdateEditCopy( CCmdUI* pCmdUI ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pSong != NULL );
	
	BOOL fEnable = FALSE;
	
	switch( m_nEditMenuCtrlID )
	{
		case IDC_LIST_VIRTUAL_SEGMENTS:
			if( m_lstbxSegments.GetSelCount() > 0 )
			{
				fEnable = TRUE;
			}
			break;
		
		case IDC_LIST_TRACKS:
			if( m_lstbxTracks.GetSelCount() > 0 )
			{
				fEnable = TRUE;
			}
			break;

		case IDC_LIST_TRANSITIONS:
			if( m_lstbxTransitions.GetSelCount() > 0 )
			{
				fEnable = TRUE;
			}
			break;
	}

	pCmdUI->Enable( fEnable );
}


/////////////////////////////////////////////////////////////////////////////
// CSongDlg::OnEditCopy

void CSongDlg::OnEditCopy() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pSong != NULL );

	switch( m_nEditMenuCtrlID )
	{
		case IDC_LIST_VIRTUAL_SEGMENTS:
			if( m_lstbxSegments.GetSelCount() > 0 )
			{
				IDataObject* pIDataObject;
				if( SUCCEEDED ( m_lstbxSegments.CreateDataObject( &pIDataObject ) ) )
				{
					theApp.PutDataInClipboard( pIDataObject, m_pSong );

					RELEASE( pIDataObject );
				}
			}
			break;
		
		case IDC_LIST_TRACKS:
			if( m_lstbxTracks.GetSelCount() > 0 )
			{
				IDataObject* pIDataObject;
				if( SUCCEEDED ( m_lstbxTracks.CreateDataObject( &pIDataObject ) ) )
				{
					theApp.PutDataInClipboard( pIDataObject, m_pSong );

					RELEASE( pIDataObject );
				}
			}
			break;

		case IDC_LIST_TRANSITIONS:
			if( m_lstbxTransitions.GetSelCount() > 0 )
			{
				IDataObject* pIDataObject;
				if( SUCCEEDED ( m_lstbxTransitions.CreateDataObject( &pIDataObject ) ) )
				{
					theApp.PutDataInClipboard( pIDataObject, m_pSong );

					RELEASE( pIDataObject );
				}
			}
			break;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CSongDlg::OnUpdateEditPaste

void CSongDlg::OnUpdateEditPaste( CCmdUI* pCmdUI ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	BOOL fEnable = FALSE;

	// Get the IDataObject
	IDataObject* pIDataObject;
	if( SUCCEEDED ( ::OleGetClipboard( &pIDataObject ) ) )
	{
		POINT pt = {0, 0};
		bool fMoveIsOK = false;
		HRESULT hr = CanPasteFromData( pIDataObject, false, pt, &fMoveIsOK );
		
		RELEASE( pIDataObject );
		
		if( hr == S_OK )
		{
			fEnable = TRUE;
		}
	}
	
	pCmdUI->Enable( fEnable );
}


/////////////////////////////////////////////////////////////////////////////
// CSongDlg::OnEditPaste

void CSongDlg::OnEditPaste() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Get the IDataObject
	IDataObject* pIDataObject;
	if( SUCCEEDED ( ::OleGetClipboard( &pIDataObject ) ) )
	{
		POINT pt = {0, 0};
		PasteFromData( pIDataObject, false, pt );
		
		RELEASE( pIDataObject );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CSongDlg::OnUpdateEditInsert

void CSongDlg::OnUpdateEditInsert( CCmdUI* pCmdUI ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pSong != NULL );
	
	BOOL fEnable = FALSE;
	
	switch( m_nEditMenuCtrlID )
	{
		case IDC_LIST_VIRTUAL_SEGMENTS:
			fEnable = TRUE;
			break;

		case IDC_LIST_TRACKS:
		case IDC_LIST_TRANSITIONS:
			if( GetVirtualSegmentToEdit() )
			{
				fEnable = TRUE;
			}
			break;
	}

	pCmdUI->Enable( fEnable );
}


/////////////////////////////////////////////////////////////////////////////
// CSongDlg::OnEditInsert

void CSongDlg::OnEditInsert() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pSong != NULL );
	
	switch( m_nEditMenuCtrlID )
	{
		case IDC_LIST_VIRTUAL_SEGMENTS:
			OnInsertVirtualSegment();
			break;

		case IDC_LIST_TRACKS:
			OnInsertTrack();
			break;
		
		case IDC_LIST_TRANSITIONS:
			OnInsertTransition();
			break;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CSongDlg::OnUpdateEditDelete

void CSongDlg::OnUpdateEditDelete( CCmdUI* pCmdUI ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pSong != NULL );
	
	BOOL fEnable = FALSE;
	
	switch( m_nEditMenuCtrlID )
	{
		case IDC_LIST_VIRTUAL_SEGMENTS:
			if( m_lstbxSegments.GetSelCount() > 0 )
			{
				fEnable = TRUE;
			}
			break;
		
		case IDC_LIST_TRACKS:
			if( m_lstbxTracks.GetSelCount() > 0 )
			{
				fEnable = TRUE;
			}
			break;

		case IDC_LIST_TRANSITIONS:
			if( m_lstbxTransitions.GetSelCount() > 0 )
			{
				fEnable = TRUE;
			}
			break;
	}

	pCmdUI->Enable( fEnable );
}


/////////////////////////////////////////////////////////////////////////////
// CSongDlg::OnEditDelete

void CSongDlg::OnEditDelete() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pSong != NULL );
	
	switch( m_nEditMenuCtrlID )
	{
		case IDC_LIST_VIRTUAL_SEGMENTS:
			OnDeleteVirtualSegments();
			break;

		case IDC_LIST_TRACKS:
			OnDeleteTracks();
			break;
		
		case IDC_LIST_TRANSITIONS:
			OnDeleteTransitions();
			break;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CSongDlg::OnEditSelectAll

void CSongDlg::OnEditSelectAll() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pSong != NULL );
	
	switch( m_nEditMenuCtrlID )
	{
		case IDC_LIST_VIRTUAL_SEGMENTS:
			m_lstbxSegments.SetSel( -1, TRUE );
			m_lstbxSegments.SetCaretIndex( m_lstbxSegments.GetTopIndex(), 0 ); 
			break;
		
		case IDC_LIST_TRACKS:
			m_lstbxTracks.SetSel( -1, TRUE );
			m_lstbxTracks.SetCaretIndex( m_lstbxTracks.GetTopIndex(), 0 ); 
			break;

		case IDC_LIST_TRANSITIONS:
			m_lstbxTransitions.SetSel( -1, TRUE );
			m_lstbxTransitions.SetCaretIndex( m_lstbxTransitions.GetTopIndex(), 0 ); 
			break;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CSongDlg::OnViewProperties

BOOL CSongDlg::OnViewProperties( void )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	IDMUSProdPropSheet* pIPropSheet;

	ASSERT( m_pSong != NULL );
	ASSERT( theApp.m_pSongComponent != NULL );
	ASSERT( theApp.m_pSongComponent->m_pIFramework8 != NULL );

	if( FAILED ( theApp.m_pSongComponent->m_pIFramework8->QueryInterface( IID_IDMUSProdPropSheet, (void**)&pIPropSheet ) ) )
	{
		return FALSE;
	}

	if( m_fOpenProperties == false
	&&  pIPropSheet->IsShowing() != S_OK )
	{
		RELEASE( pIPropSheet );
		return TRUE;
	}

	BOOL fSuccess = FALSE;
	
	switch( m_nEditMenuCtrlID )
	{
		case IDC_LIST_VIRTUAL_SEGMENTS:
		{
			if( m_pVirtualSegmentPropPageObject == NULL )
			{
				m_pVirtualSegmentPropPageObject = new CVirtualSegmentPropPageObject( this );
			}
			if( m_pVirtualSegmentPropPageObject )
			{
				if( SUCCEEDED ( m_pVirtualSegmentPropPageObject->OnShowProperties() ) )
				{
					fSuccess = TRUE;
				}
			}
			break;
		}
		
		case IDC_LIST_TRACKS:
		{
			if( m_pTrackPropPageObject == NULL )
			{
				m_pTrackPropPageObject = new CTrackPropPageObject( this );
			}
			if( m_pTrackPropPageObject )
			{
				if( SUCCEEDED ( m_pTrackPropPageObject->OnShowProperties() ) )
				{
					fSuccess = TRUE;
				}
			}
			break;
		}

		case IDC_LIST_TRANSITIONS:
		{
			if( m_pTransitionPropPageObject == NULL )
			{
				m_pTransitionPropPageObject = new CTransitionPropPageObject( this );
			}
			if( m_pTransitionPropPageObject )
			{
				if( SUCCEEDED ( m_pTransitionPropPageObject->OnShowProperties() ) )
				{
					fSuccess = TRUE;
				}
			}
			break;
		}

		default:
			if( SUCCEEDED ( m_pSong->OnShowProperties() ) )
			{
				fSuccess = TRUE;
			}
			break;
	}

	RELEASE( pIPropSheet );

	return fSuccess;
}


/////////////////////////////////////////////////////////////////////////////
// CSongDlg::OnCommand

BOOL CSongDlg::OnCommand(WPARAM wParam, LPARAM lParam) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( HIWORD(wParam) == 0 )	// menu command
	{
		if( m_pINodeRightMenu )	// can receive menu commands when m_pINodeRightMenu is NULL
		{
			m_pINodeRightMenu->OnRightClickMenuSelect( LOWORD(wParam) );
			m_pINodeRightMenu = NULL ;
			return TRUE;
		}

		switch( LOWORD(wParam) )
		{
			case IDM_INSERT_VIRTUAL_SEGMENT:
				OnInsertVirtualSegment();
				return TRUE;

			case IDM_DELETE_VIRTUAL_SEGMENT:
				OnDeleteVirtualSegments();
				return TRUE;

			case IDM_INSERT_TRACK:
				OnInsertTrack();
				return TRUE;

			case IDM_DELETE_TRACKS:
				OnDeleteTracks();
				return TRUE;

			case IDM_INSERT_TRANSITION:
				OnInsertTransition();
				return TRUE;

			case IDM_DELETE_TRANSITIONS:
				OnDeleteTransitions();
				return TRUE;

			case ID_EDIT_CUT:
				OnEditCut();
				return TRUE;

			case ID_EDIT_COPY:
				OnEditCopy();
				return TRUE;

			case ID_EDIT_PASTE:
				OnEditPaste();
				return TRUE;

			case ID_EDIT_SELECT_ALL:
				OnEditSelectAll();
				return TRUE;

			case ID_EDIT_INSERT:
				OnEditInsert();
				return TRUE;

			case ID_EDIT_DELETE:
				OnEditDelete();
				return TRUE;

			case IDM_VIRTUAL_SEGMENT_PROPERTIES:
				m_nEditMenuCtrlID = IDC_LIST_VIRTUAL_SEGMENTS;
				m_fOpenProperties = true;
				OnViewProperties();
				m_fOpenProperties = false;
				return TRUE;

			case IDM_TRACK_PROPERTIES:
				m_nEditMenuCtrlID = IDC_LIST_TRACKS;
				m_fOpenProperties = true;
				OnViewProperties();
				m_fOpenProperties = false;
				return TRUE;

			case IDM_TRANSITION_PROPERTIES:
				m_nEditMenuCtrlID = IDC_LIST_TRANSITIONS;
				m_fOpenProperties = true;
				OnViewProperties();
				m_fOpenProperties = false;
				return TRUE;
		}
	}
	
	return CFormView::OnCommand( wParam, lParam );
}


/////////////////////////////////////////////////////////////////////////////
// CSongDlg::OnContextMenu

void CSongDlg::OnContextMenu( CWnd* pWnd, CPoint point ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pSong != NULL );

	ScreenToClient( &point );
	CWnd* pWndControl= ChildWindowFromPoint( point, CWP_ALL );
	if( pWndControl )
	{
		pWnd = pWndControl;
	}
	ClientToScreen( &point );

	m_nEditMenuCtrlID = pWnd->GetDlgCtrlID();

	switch( m_nEditMenuCtrlID )
	{
		case IDC_LIST_VIRTUAL_SEGMENTS:
		{
			CVirtualSegment* pVirtualSegmentToEdit = NULL;

			m_lstbxSegments.SetFocus(); 

			// Get the item under the mouse
			BOOL fOutside;
			POINT ptClient = point;
			m_lstbxSegments.ScreenToClient( &ptClient );
			UINT nPos = m_lstbxSegments.ItemFromPoint( ptClient, fOutside );
			if( nPos != LB_ERR
			&&  fOutside == FALSE )
			{
				pVirtualSegmentToEdit = (CVirtualSegment *)m_lstbxSegments.GetItemDataPtr( nPos );
				ASSERT( pVirtualSegmentToEdit != NULL );
				ASSERT( pVirtualSegmentToEdit != (CVirtualSegment *)0xFFFFFFFF );
			}

			// Load menu
			HMENU hMenu = ::LoadMenu( theApp.m_hInstance, MAKEINTRESOURCE(IDM_VIRTUAL_SEGMENT_RMENU) );
			HMENU hMenuPopup = ::GetSubMenu(hMenu, 0);

			// Initialize menu
			int nSelCount = m_lstbxSegments.GetSelCount();
			int nCount = m_lstbxSegments.GetCount();
			::EnableMenuItem( hMenuPopup, ID_EDIT_CUT, (nSelCount > 0) ? MF_ENABLED : MF_GRAYED );
			::EnableMenuItem( hMenuPopup, ID_EDIT_COPY, (nSelCount > 0) ? MF_ENABLED : MF_GRAYED );
			::EnableMenuItem( hMenuPopup, ID_EDIT_SELECT_ALL, (nCount > 0) ? MF_ENABLED : MF_GRAYED );
			::EnableMenuItem( hMenuPopup, IDM_DELETE_VIRTUAL_SEGMENT, (nSelCount > 0) ? MF_ENABLED : MF_GRAYED );
			::EnableMenuItem( hMenuPopup, IDM_VIRTUAL_SEGMENT_PROPERTIES, (pVirtualSegmentToEdit && (nSelCount == 1))
								? MF_ENABLED : MF_GRAYED );

			// Enable Paste
			BOOL fEnable = FALSE;
			IDataObject* pIDataObject;
			if( SUCCEEDED ( ::OleGetClipboard( &pIDataObject ) ) )
			{
				POINT pt = {0, 0};
				bool fMoveIsOK = false;
				HRESULT hr = CanPasteFromData( pIDataObject, false, pt, &fMoveIsOK );
				
				RELEASE( pIDataObject );
				
				if( hr == S_OK )
				{
					fEnable = TRUE;
				}
			}
			::EnableMenuItem( hMenuPopup, ID_EDIT_PASTE, fEnable ? MF_ENABLED : MF_GRAYED );

			m_pointRightMenu = point;
			::TrackPopupMenu( hMenuPopup, (TPM_LEFTALIGN | TPM_RIGHTBUTTON),
							  point.x, point.y, 0, GetSafeHwnd(), NULL );
			::DestroyMenu( hMenu );
			break;
		}

		case IDC_LIST_TRACKS:
		{
			CVirtualSegment* pVirtualSegmentToEdit = GetVirtualSegmentToEdit();

			// Load menu
			HMENU hMenu = ::LoadMenu( theApp.m_hInstance, MAKEINTRESOURCE(IDM_TRACK_RMENU) );
			HMENU hMenuPopup = ::GetSubMenu(hMenu, 0);

			// Initialize menu
			int nSelCount = m_lstbxTracks.GetSelCount();
			int nCount = m_lstbxTracks.GetCount();
			::EnableMenuItem( hMenuPopup, ID_EDIT_CUT, (pVirtualSegmentToEdit && (nSelCount > 0))
								? MF_ENABLED : MF_GRAYED );
			::EnableMenuItem( hMenuPopup, ID_EDIT_COPY, (pVirtualSegmentToEdit && (nSelCount > 0))
								? MF_ENABLED : MF_GRAYED );
			::EnableMenuItem( hMenuPopup, ID_EDIT_SELECT_ALL, (pVirtualSegmentToEdit && (nCount > 0))
								? MF_ENABLED : MF_GRAYED );
			::EnableMenuItem( hMenuPopup, IDM_INSERT_TRACK, (pVirtualSegmentToEdit) ? MF_ENABLED : MF_GRAYED );
			::EnableMenuItem( hMenuPopup, IDM_DELETE_TRACKS, (pVirtualSegmentToEdit && (nSelCount > 0))
								? MF_ENABLED : MF_GRAYED );
			::EnableMenuItem( hMenuPopup, IDM_TRACK_PROPERTIES, (pVirtualSegmentToEdit && (nSelCount == 1))
								? MF_ENABLED : MF_GRAYED );

			// Enable Paste
			BOOL fEnable = FALSE;
			IDataObject* pIDataObject;
			if( SUCCEEDED ( ::OleGetClipboard( &pIDataObject ) ) )
			{
				POINT pt = {0, 0};
				bool fMoveIsOK = false;
				HRESULT hr = CanPasteFromData( pIDataObject, false, pt, &fMoveIsOK );
				
				RELEASE( pIDataObject );
				
				if( hr == S_OK )
				{
					fEnable = TRUE;
				}
			}
			::EnableMenuItem( hMenuPopup, ID_EDIT_PASTE, fEnable ? MF_ENABLED : MF_GRAYED );

			m_pointRightMenu = point;
			::TrackPopupMenu( hMenuPopup, (TPM_LEFTALIGN | TPM_RIGHTBUTTON),
							  point.x, point.y, 0, GetSafeHwnd(), NULL );
			::DestroyMenu( hMenu );
			break;
		}

		case IDC_LIST_TRANSITIONS:
		{
			CVirtualSegment* pVirtualSegmentToEdit = GetVirtualSegmentToEdit();

			// Load menu
			HMENU hMenu = ::LoadMenu( theApp.m_hInstance, MAKEINTRESOURCE(IDM_TRANSITION_RMENU) );
			HMENU hMenuPopup = ::GetSubMenu(hMenu, 0);

			// Initialize menu
			int nSelCount = m_lstbxTransitions.GetSelCount();
			int nCount = m_lstbxTransitions.GetCount();
			::EnableMenuItem( hMenuPopup, ID_EDIT_CUT, (pVirtualSegmentToEdit && (nSelCount > 0))
								? MF_ENABLED : MF_GRAYED );
			::EnableMenuItem( hMenuPopup, ID_EDIT_COPY, (pVirtualSegmentToEdit && (nSelCount > 0))
								? MF_ENABLED : MF_GRAYED );
			::EnableMenuItem( hMenuPopup, ID_EDIT_SELECT_ALL, (pVirtualSegmentToEdit && (nCount > 0))
								? MF_ENABLED : MF_GRAYED );
			::EnableMenuItem( hMenuPopup, IDM_INSERT_TRANSITION, (pVirtualSegmentToEdit)
								? MF_ENABLED : MF_GRAYED );
			::EnableMenuItem( hMenuPopup, IDM_DELETE_TRANSITIONS, (pVirtualSegmentToEdit && (nSelCount > 0))
								? MF_ENABLED : MF_GRAYED );
			::EnableMenuItem( hMenuPopup, IDM_TRANSITION_PROPERTIES, (pVirtualSegmentToEdit && (nSelCount == 1))
								? MF_ENABLED : MF_GRAYED );

			// Enable Paste
			BOOL fEnable = FALSE;
			IDataObject* pIDataObject;
			if( SUCCEEDED ( ::OleGetClipboard( &pIDataObject ) ) )
			{
				POINT pt = {0, 0};
				bool fMoveIsOK = false;
				HRESULT hr = CanPasteFromData( pIDataObject, false, pt, &fMoveIsOK );
				
				RELEASE( pIDataObject );
				
				if( hr == S_OK )
				{
					fEnable = TRUE;
				}
			}
			::EnableMenuItem( hMenuPopup, ID_EDIT_PASTE, fEnable ? MF_ENABLED : MF_GRAYED );

			m_pointRightMenu = point;
			::TrackPopupMenu( hMenuPopup, (TPM_LEFTALIGN | TPM_RIGHTBUTTON),
							  point.x, point.y, 0, GetSafeHwnd(), NULL );
			::DestroyMenu( hMenu );
			break;
		}

		default:
		{
			HINSTANCE hInstance;
			UINT nResourceId;
			if( SUCCEEDED ( m_pSong->GetRightClickMenuId(&hInstance, &nResourceId) ) )
			{
				HMENU hMenu = ::LoadMenu( hInstance, MAKEINTRESOURCE(nResourceId) );
				if( hMenu )
				{
					HMENU hMenuPopup = ::GetSubMenu( hMenu, 0 );
					m_pSong->OnRightClickMenuInit( hMenuPopup );

					m_pINodeRightMenu = m_pSong;
					m_pointRightMenu = point;
					::TrackPopupMenu( hMenuPopup, (TPM_LEFTALIGN | TPM_RIGHTBUTTON),
									  point.x, point.y, 0, GetSafeHwnd(), NULL );

					DestroyMenu( hMenu );
				}
			}
			break;
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CSongDlg::OnInsertVirtualSegment

void CSongDlg::OnInsertVirtualSegment( void )
{
	// Create a VirtualSegment 
	CVirtualSegment* pVirtualSegment = new CVirtualSegment( m_pSong );
	if( pVirtualSegment )
	{
		m_pSong->m_pUndoMgr->SaveState( m_pSong, theApp.m_hInstance, IDS_UNDO_ADD_VIRTUAL_SEGMENT );

		// Determine position in VirtualSegment list
		BOOL fOutside;
		int nPos = m_lstbxSegments.ItemFromPoint( m_lstbxSegments.m_ptLastXYPos, fOutside );
		if( fOutside == TRUE
		||  nPos == LB_ERR )
		{
			nPos = -1;
		}

		// Determine "next" VirtualSegment
		CVirtualSegment* pPrevVirtualSegment = m_pSong->IndexToVirtualSegment( nPos - 1 );
		CVirtualSegment* pNextVirtualSegment = m_pSong->IndexToVirtualSegment( nPos );
		if( pPrevVirtualSegment 
		&&  pPrevVirtualSegment->m_pNextVirtualSegment
		&&	pPrevVirtualSegment->m_pNextVirtualSegment == pNextVirtualSegment )
		{
			RELEASE( pPrevVirtualSegment->m_pNextVirtualSegment );
			pPrevVirtualSegment->m_pNextVirtualSegment = pVirtualSegment;
			pPrevVirtualSegment->m_pNextVirtualSegment->AddRef();
		}
		if( pNextVirtualSegment )
		{
			RELEASE( pVirtualSegment->m_pNextVirtualSegment );
			pVirtualSegment->m_pNextVirtualSegment = pNextVirtualSegment;
			pVirtualSegment->m_pNextVirtualSegment->AddRef();
		}

		// Insert the VirtualSegment into the Song
		m_pSong->InsertVirtualSegment( pVirtualSegment, nPos );

		// Sync changes
		m_pSong->SetModified( TRUE );
		m_pSong->SyncChanges( SC_EDITOR | SC_DIRECTMUSIC,
							  SSE_VIRTUAL_SEGMENT_LIST,
							  NULL );

		// Select the VirtualSegment
		SelectVirtualSegment( pVirtualSegment );

		// Open properties
		m_nEditMenuCtrlID = IDC_LIST_VIRTUAL_SEGMENTS;
		m_fOpenProperties = true;
		OnViewProperties();
		m_fOpenProperties = false;

		RELEASE( pVirtualSegment );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CSongDlg::OnDeleteVirtualSegments

void CSongDlg::OnDeleteVirtualSegments( void )
{
	int nNbrSelItems = m_lstbxSegments.GetSelCount();
	if( nNbrSelItems == 0 )
	{
		// Nothing to do
		return;
	}

	int* pnSelItems = new int[nNbrSelItems];
	if( pnSelItems )
	{
		m_pSong->m_pUndoMgr->SaveState( m_pSong, theApp.m_hInstance, IDS_UNDO_DELETE_VIRTUAL_SEGMENT );

		m_lstbxSegments.GetSelItems( nNbrSelItems, pnSelItems );

		for( int i = 0;  i < nNbrSelItems ;  i++ )
		{
			CVirtualSegment* pVirtualSegment = (CVirtualSegment *)m_lstbxSegments.GetItemDataPtr( pnSelItems[i] );
		
			if( pVirtualSegment
			&&  pVirtualSegment != (CVirtualSegment *)0xFFFFFFFF )
			{
				// Remove pVirtualSegment from m_lstVirtualSegments
				m_pSong->RemoveVirtualSegment( pVirtualSegment );
			}
		}

		m_lstbxSegments.m_ptLastXYPos.x = INT_MAX;
		m_lstbxSegments.m_ptLastXYPos.y = INT_MAX;

		// Sync changes
		m_pSong->SetModified( TRUE );
		m_pSong->SyncChanges( SC_EDITOR | SC_PROPERTIES | SC_DIRECTMUSIC,
							  SSE_VIRTUAL_SEGMENT_LIST | SSE_TRANSITION_LIST,
							  NULL );

		delete [] pnSelItems;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CSongDlg::MarkSelectedVirtualSegments

void CSongDlg::MarkSelectedVirtualSegments( DWORD dwFlags )
{
	int nNbrSelItems = m_lstbxSegments.GetSelCount();
	if( nNbrSelItems == 0 )
	{
		// Nothing to do
		return;
	}

	int* pnSelItems = new int[nNbrSelItems];
	if( pnSelItems )
	{
		m_lstbxSegments.GetSelItems( nNbrSelItems, pnSelItems );

		for( int i = 0;  i < nNbrSelItems ;  i++ )
		{
			CVirtualSegment* pVirtualSegment = (CVirtualSegment *)m_lstbxSegments.GetItemDataPtr( pnSelItems[i] );
		
			if( pVirtualSegment
			&&  pVirtualSegment != (CVirtualSegment *)0xFFFFFFFF )
			{
				pVirtualSegment->m_dwBitsUI |= dwFlags;
			}
		}

		delete [] pnSelItems;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CSongDlg::UnMarkVirtualSegments

void CSongDlg::UnMarkVirtualSegments( DWORD dwFlags )
{
	CVirtualSegment* pVirtualSegment;
	for( int i = 0 ;  pVirtualSegment = m_pSong->IndexToVirtualSegment(i) ;  i++ )
	{
		if( pVirtualSegment == NULL )
		{
			break;
		}

		pVirtualSegment->m_dwBitsUI &= ~dwFlags;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CSongDlg::DeleteMarkedVirtualSegments

void CSongDlg::DeleteMarkedVirtualSegments( DWORD dwFlags )
{
	CVirtualSegment* pVirtualSegment;
	for( int i = 0 ;  pVirtualSegment = m_pSong->IndexToVirtualSegment(i) ;  i++ )
	{
		if( pVirtualSegment == NULL )
		{
			break;
		}

		if( pVirtualSegment->m_dwBitsUI & dwFlags )
		{
			// Remove pVirtualSegment from m_lstVirtualSegments
			m_pSong->RemoveVirtualSegment( pVirtualSegment );

			m_lstbxSegments.m_ptLastXYPos.x = INT_MAX;
			m_lstbxSegments.m_ptLastXYPos.y = INT_MAX;
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CSongDlg::OnInsertTrack

void CSongDlg::OnInsertTrack( void )
{
	CVirtualSegment* pVirtualSegmentToEdit = GetVirtualSegmentToEdit();
	if( pVirtualSegmentToEdit == NULL )
	{
		ASSERT( 0 );
		return;
	}

	CDlgAddTracks dlgAddTracks;

	// Prepare dialog
	dlgAddTracks.m_pSong = m_pSong;

	// Display dialog
	if( dlgAddTracks.DoModal() == IDOK 
	&&  dlgAddTracks.m_lstTracks.IsEmpty() == FALSE )
	{
		// Add tracks
		m_pSong->m_pUndoMgr->SaveState( m_pSong, theApp.m_hInstance, IDS_UNDO_ADD_TRACK );

		// Insert the Tracks into the VirtualSegment
		CTrack* pTrack;
		POSITION pos = dlgAddTracks.m_lstTracks.GetHeadPosition();
		while( pos )
		{
			pTrack = dlgAddTracks.m_lstTracks.GetNext( pos );

			pVirtualSegmentToEdit->InsertTrack( pTrack );
		}

		// Sync changes
		m_pSong->SetModified( TRUE );
		m_pSong->SyncChanges( SC_EDITOR | SC_DIRECTMUSIC,
							  SSE_TRACK_LIST,
							  NULL );

		// Select tracks
		m_lstbxTracks.SelectTrackList( dlgAddTracks.m_lstTracks );
		
		// Open properties
		m_nEditMenuCtrlID = IDC_LIST_TRACKS;
		m_fOpenProperties = true;
		OnViewProperties();
		m_fOpenProperties = false;
	}

	m_lstbxTracks.SetFocus();
}


/////////////////////////////////////////////////////////////////////////////
// CSongDlg::OnDeleteTracks

void CSongDlg::OnDeleteTracks( void )
{
	CVirtualSegment* pVirtualSegmentToEdit = GetVirtualSegmentToEdit();
	if( pVirtualSegmentToEdit == NULL )
	{
		ASSERT( 0 );
		return;
	}

	int nNbrSelItems = m_lstbxTracks.GetSelCount();
	if( nNbrSelItems == 0 )
	{
		// Nothing to do
		return;
	}

	int* pnSelItems = new int[nNbrSelItems];
	if( pnSelItems )
	{
		m_pSong->m_pUndoMgr->SaveState( m_pSong, theApp.m_hInstance, IDS_UNDO_DELETE_TRACK );

		m_lstbxTracks.GetSelItems( nNbrSelItems, pnSelItems );

		for( int i = 0;  i < nNbrSelItems ;  i++ )
		{
			CTrack* pTrack = (CTrack *)m_lstbxTracks.GetItemDataPtr( pnSelItems[i] );
		
			if( pTrack
			&&  pTrack != (CTrack *)0xFFFFFFFF )
			{
				// Remove pTrack from m_lstTracks
				pVirtualSegmentToEdit->RemoveTrack( pTrack );
			}
		}

		m_lstbxTracks.m_ptLastXYPos.x = INT_MAX;
		m_lstbxTracks.m_ptLastXYPos.y = INT_MAX;

		// Sync changes
		m_pSong->SetModified( TRUE );
		m_pSong->SyncChanges( SC_EDITOR | SC_PROPERTIES | SC_DIRECTMUSIC,
							  SSE_TRACK_LIST,
							  NULL );

		delete [] pnSelItems;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CSongDlg::MarkSelectedTracks

void CSongDlg::MarkSelectedTracks( CVirtualSegment* pVirtualSegment, DWORD dwFlags )
{
	CVirtualSegment* pVirtualSegmentToEdit = GetVirtualSegmentToEdit();
	if( pVirtualSegmentToEdit != pVirtualSegment )
	{
		ASSERT( 0 );
		return;
	}

	int nNbrSelItems = m_lstbxTracks.GetSelCount();
	if( nNbrSelItems == 0 )
	{
		// Nothing to do
		return;
	}

	int* pnSelItems = new int[nNbrSelItems];
	if( pnSelItems )
	{
		m_lstbxTracks.GetSelItems( nNbrSelItems, pnSelItems );

		for( int i = 0;  i < nNbrSelItems ;  i++ )
		{
			CTrack* pTrack = (CTrack *)m_lstbxTracks.GetItemDataPtr( pnSelItems[i] );
		
			if( pTrack
			&&  pTrack != (CTrack *)0xFFFFFFFF )
			{
				pTrack->m_dwBitsUI |= dwFlags;
			}
		}

		delete [] pnSelItems;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CSongDlg::UnMarkTracks

void CSongDlg::UnMarkTracks( CVirtualSegment* pVirtualSegment, DWORD dwFlags )
{
	POSITION pos = pVirtualSegment->m_lstTracks.GetHeadPosition();
	while( pos )
	{ 
		CTrack* pTrack = pVirtualSegment->m_lstTracks.GetNext( pos );

		pTrack->m_dwBitsUI &= ~dwFlags;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CSongDlg::DeleteMarkedTracks

void CSongDlg::DeleteMarkedTracks( CVirtualSegment* pVirtualSegment, DWORD dwFlags )
{
	POSITION pos = pVirtualSegment->m_lstTracks.GetHeadPosition();
	while( pos )
	{ 
		CTrack* pTrack = pVirtualSegment->m_lstTracks.GetNext( pos );

		if( pTrack->m_dwBitsUI & dwFlags )
		{
			// Remove pTrack from m_lstTracks
			pVirtualSegment->RemoveTrack( pTrack );

			m_lstbxTracks.m_ptLastXYPos.x = INT_MAX;
			m_lstbxTracks.m_ptLastXYPos.y = INT_MAX;
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CSongDlg::OnInsertTransition

void CSongDlg::OnInsertTransition( void )
{
	CVirtualSegment* pVirtualSegmentToEdit = GetVirtualSegmentToEdit();
	if( pVirtualSegmentToEdit == NULL )
	{
		ASSERT( 0 );
		return;
	}

	CTransition* pTransition = new CTransition( m_pSong );
	if( pTransition )
	{
		m_pSong->m_pUndoMgr->SaveState( m_pSong, theApp.m_hInstance, IDS_UNDO_ADD_TRANSITION );

		// Insert the Transition into the VirtualSegment
		pVirtualSegmentToEdit->InsertTransition( pTransition );

		// Sync changes
		m_pSong->SetModified( TRUE );
		m_pSong->SyncChanges( SC_EDITOR | SC_DIRECTMUSIC,
							  SSE_TRANSITION_LIST,
							  NULL );

		// Select the Transition
		m_lstbxTransitions.SelectTransition( pTransition, true );

		// Open properties
		m_nEditMenuCtrlID = IDC_LIST_TRANSITIONS;
		m_fOpenProperties = true;
		OnViewProperties();
		m_fOpenProperties = false;

		RELEASE( pTransition );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CSongDlg::OnDeleteTransitions

void CSongDlg::OnDeleteTransitions( void )
{
	CVirtualSegment* pVirtualSegmentToEdit = GetVirtualSegmentToEdit();
	if( pVirtualSegmentToEdit == NULL )
	{
		ASSERT( 0 );
		return;
	}

	int nNbrSelItems = m_lstbxTransitions.GetSelCount();
	if( nNbrSelItems == 0 )
	{
		// Nothing to do
		return;
	}

	int* pnSelItems = new int[nNbrSelItems];
	if( pnSelItems )
	{
		m_pSong->m_pUndoMgr->SaveState( m_pSong, theApp.m_hInstance, IDS_UNDO_DELETE_TRANSITION );

		m_lstbxTransitions.GetSelItems( nNbrSelItems, pnSelItems );

		for( int i = 0;  i < nNbrSelItems ;  i++ )
		{
			CTransition* pTransition = (CTransition *)m_lstbxTransitions.GetItemDataPtr( pnSelItems[i] );
		
			if( pTransition
			&&  pTransition != (CTransition *)0xFFFFFFFF )
			{
				// Remove pTransition from m_lstTransitions
				pVirtualSegmentToEdit->RemoveTransition( pTransition );
			}
		}

		m_lstbxTransitions.m_ptLastXYPos.x = INT_MAX;
		m_lstbxTransitions.m_ptLastXYPos.y = INT_MAX;

		// Sync changes
		m_pSong->SetModified( TRUE );
		m_pSong->SyncChanges( SC_EDITOR | SC_PROPERTIES | SC_DIRECTMUSIC,
							  SSE_TRANSITION_LIST,
							  NULL );

		delete [] pnSelItems;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CSongDlg::MarkSelectedTransitions

void CSongDlg::MarkSelectedTransitions( CVirtualSegment* pVirtualSegment, DWORD dwFlags )
{
	CVirtualSegment* pVirtualSegmentToEdit = GetVirtualSegmentToEdit();
	if( pVirtualSegmentToEdit != pVirtualSegment )
	{
		ASSERT( 0 );
		return;
	}

	int nNbrSelItems = m_lstbxTransitions.GetSelCount();
	if( nNbrSelItems == 0 )
	{
		// Nothing to do
		return;
	}

	int* pnSelItems = new int[nNbrSelItems];
	if( pnSelItems )
	{
		m_lstbxTransitions.GetSelItems( nNbrSelItems, pnSelItems );

		for( int i = 0;  i < nNbrSelItems ;  i++ )
		{
			CTransition* pTransition = (CTransition *)m_lstbxTransitions.GetItemDataPtr( pnSelItems[i] );
		
			if( pTransition
			&&  pTransition != (CTransition *)0xFFFFFFFF )
			{
				pTransition->m_dwBitsUI |= dwFlags;
			}
		}

		delete [] pnSelItems;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CSongDlg::UnMarkTransitions

void CSongDlg::UnMarkTransitions( CVirtualSegment* pVirtualSegment, DWORD dwFlags )
{
	POSITION pos = pVirtualSegment->m_lstTransitions.GetHeadPosition();
	while( pos )
	{ 
		CTransition* pTransition = pVirtualSegment->m_lstTransitions.GetNext( pos );

		pTransition->m_dwBitsUI &= ~dwFlags;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CSongDlg::DeleteMarkedTransitions

void CSongDlg::DeleteMarkedTransitions( CVirtualSegment* pVirtualSegment, DWORD dwFlags )
{
	POSITION pos = pVirtualSegment->m_lstTransitions.GetHeadPosition();
	while( pos )
	{ 
		CTransition* pTransition = pVirtualSegment->m_lstTransitions.GetNext( pos );

		if( pTransition->m_dwBitsUI & dwFlags )
		{
			// Remove pTransition from m_lstTransitions
			pVirtualSegment->RemoveTransition( pTransition );

			m_lstbxTransitions.m_ptLastXYPos.x = INT_MAX;
			m_lstbxTransitions.m_ptLastXYPos.y = INT_MAX;
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CSongDlg::OnTransition

void CSongDlg::OnTransition() 
{
	if( m_pSong )
	{
		m_pSong->TransitionWithinSong();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CSongDlg::IsDataObjectFromSameSong

bool CSongDlg::IsDataObjectFromSameSong( IDataObject* pIDataObject ) 
{
    IDMUSProdRIFFStream* pIRiffStream;
	IStream* pIStream;
    MMCKINFO ckMain;
	MMCKINFO ck;
	DWORD dwSize;
	DWORD dwByteCount;

	GUID guidSourceSong;
	memset( &guidSourceSong, 0, sizeof(GUID) );

	GUID guidTargetSong;
	memset( &guidTargetSong, 1, sizeof(GUID) );
	if( m_pSong )
	{
		m_pSong->GetGUID( &guidTargetSong );
	}

	// Create a new CDllJazzDataObject and see if it contains a Song
	CDllJazzDataObject* pDataObject = new CDllJazzDataObject();
	if( pDataObject )
	{
		// CF_VIRTUAL_SEGMENT_LIST
		if( SUCCEEDED (	pDataObject->AttemptRead( pIDataObject, theApp.m_pSongComponent->m_cfVirtualSegmentList, &pIStream  ) ) )
		{
			if( SUCCEEDED( AllocRIFFStream( pIStream, &pIRiffStream ) ) )
			{
				// Seek to beginning of stream
				LARGE_INTEGER liTemp;
				liTemp.QuadPart = 0;
				pIStream->Seek( liTemp, STREAM_SEEK_SET, NULL );

				ckMain.fccType = DMUS_FOURCC_SONG_FORM;
				if( pIRiffStream->Descend( &ckMain, NULL, MMIO_FINDRIFF ) == 0 )
				{
					// Get Source Song GUID
					ck.ckid = DMUS_FOURCC_GUID_CHUNK;
					if( pIRiffStream->Descend( &ck, &ckMain, MMIO_FINDCHUNK ) == 0 )
					{
						dwSize = min( ck.cksize, sizeof( GUID ) );
						if( FAILED ( pIStream->Read( &guidSourceSong, dwSize, &dwByteCount ) )
						||  dwByteCount != dwSize )
						{
							memset( &guidSourceSong, 0, sizeof(GUID) );
						}
					}
				}

				RELEASE( pIRiffStream );
			}

			RELEASE( pIStream );
		}		

		// CF_TRACK_LIST
		// CF_TRANSITION_LIST
		else if( SUCCEEDED ( pDataObject->AttemptRead( pIDataObject, theApp.m_pSongComponent->m_cfTrackList, &pIStream  ) ) 
			 ||  SUCCEEDED ( pDataObject->AttemptRead( pIDataObject, theApp.m_pSongComponent->m_cfTransitionList, &pIStream  ) ) )
		{
			if( SUCCEEDED( AllocRIFFStream( pIStream, &pIRiffStream ) ) )
			{
				// Seek to beginning of stream
				LARGE_INTEGER liTemp;
				liTemp.QuadPart = 0;
				pIStream->Seek( liTemp, STREAM_SEEK_SET, NULL );

				ckMain.fccType = DMUS_FOURCC_SEGREF_LIST;
				if( pIRiffStream->Descend( &ckMain, NULL, MMIO_FINDLIST ) == 0 )
				{
					// Get Source Song GUID
					ck.ckid = DMUS_FOURCC_SONG_GUID_UI_CHUNK;
					if( pIRiffStream->Descend( &ck, &ckMain, MMIO_FINDCHUNK ) == 0 )
					{
						dwSize = min( ck.cksize, sizeof( GUID ) );
						if( FAILED ( pIStream->Read( &guidSourceSong, dwSize, &dwByteCount ) )
						||  dwByteCount != dwSize )
						{
							memset( &guidSourceSong, 0, sizeof(GUID) );
						}
					}
				}

				RELEASE( pIRiffStream );
			}

			RELEASE( pIStream );
		}		

		RELEASE( pDataObject );
	}

	if( ::IsEqualGUID( guidSourceSong, guidTargetSong ) )
	{
		return true;
	}

	return false;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SongDesigner\SongDesignerDLL.h ===
#if !defined(AFX_SONGDESIGNER_H__D135DB5E_66ED_11D3_B45D_00105A2796DE__INCLUDED_)
#define AFX_SONGDESIGNER_H__D135DB5E_66ED_11D3_B45D_00105A2796DE__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

// SongDesigner.h : main header file for SONGDESIGNER.DLL

#if !defined( __AFXCTL_H__ )
	#error include 'afxctl.h' before including this file
#endif

#include "resource.h"       // main symbols
#pragma warning( push )
#pragma warning( disable : 4201 )
#include <dmusicc.h>
#include <dmusici.h>
#include <dmusicp.h>
#pragma warning( pop )
#include "DMUSProd.h"
#include "SongDesigner.h"
#include "Conductor.h"		// Conductor interface and CLSID
#include "DllJazzDataObject.h"
#include "DllBasePropPageManager.h"
#include "JazzUndoMan.h"


/////////////////////////////////////////////////////////////////////////////
// DLL defines
//

#define RELEASE(x) if( (x) ) (x)->Release(); (x) = 0

#define SMALL_BUFFER	32
#define MID_BUFFER		100
#define MAX_BUFFER		256

#define FIRST_SONG_IMAGE		0
#define FIRST_SONGREF_IMAGE		2
#define FIRST_FOLDER_IMAGE		4


/////////////////////////////////////////////////////////////////////////////
// DLL GUIDs
//

// {075A61AE-D843-4737-B9F7-78DEFDC3AC15}
DEFINE_GUID(GUID_VirtualSegmentPropPageManager, 0x75a61ae,0xd843,0x4737,0xb9,0xf7,0x78,0xde,0xfd,0xc3,0xac,0x15);

// {05EA4449-FE9C-4f6d-AB15-915CE3B19DEE}
DEFINE_GUID(GUID_TransitionPropPageManager, 0x5ea4449,0xfe9c,0x4f6d,0xab,0x15,0x91,0x5c,0xe3,0xb1,0x9d,0xee);

// {D4A61C50-AE39-41e3-9ABC-F180CC1D1EAB}
DEFINE_GUID(GUID_TrackPropPageManager, 0xd4a61c50,0xae39,0x41e3,0x9a,0xbc,0xf1,0x80,0xcc,0x1d,0x1e,0xab);

// {EE021440-A628-4ac3-85FC-12DD887BF61F}
DEFINE_GUID(GUID_SaveSelectedVirtualSegments, 0xee021440, 0xa628, 0x4ac3, 0x85, 0xfc, 0x12, 0xdd, 0x88, 0x7b, 0xf6, 0x1f);

// {91441052-C205-4d74-98B8-DCE24D230586}
DEFINE_GUID(GUID_SaveSelectedTracks, 0x91441052, 0xc205, 0x4d74, 0x98, 0xb8, 0xdc, 0xe2, 0x4d, 0x23, 0x5, 0x86);

// {4E4285FE-BE0E-49cf-B9C3-E67A54EDDECE}
DEFINE_GUID(GUID_SaveSelectedTransitions,  0x4e4285fe, 0xbe0e, 0x49cf, 0xb9, 0xc3, 0xe6, 0x7a, 0x54, 0xed, 0xde, 0xce);

class CSongComponent;


/////////////////////////////////////////////////////////////////////////////
// CSongDesignerApp : See SongDesigner.cpp for implementation.

class CSongDesignerApp : public COleControlModule
{
public:
	BOOL InitInstance();
	int ExitInstance();
	BOOL GetHelpFileName( CString& strHelpFileName );
	void SetNodePointers( IDMUSProdNode* pINode, IDMUSProdNode* pIDocRootNode, IDMUSProdNode* pIParentNode );
	BOOL GetFileVersion( LPTSTR szExeName, LPTSTR szFileVersion, short nFileVersionSize );
	BOOL PutDataInClipboard( IDataObject* pIDataObject, void* pClipboardObject );
	void FlushClipboard( void* pClipboardObject );

private:
	IDataObject*	m_pIClipboardDataObject;	// Data copied into clipboard
	void*			m_pClipboardObject;			// Object responsible for data copied into clipboard

public:
	IDMUSProdPropPageManager*	m_pIPageManager;
	CSongComponent*				m_pSongComponent;
};

extern CSongDesignerApp NEAR theApp;

extern const GUID CDECL _tlid;
extern const WORD _wVerMajor;
extern const WORD _wVerMinor;

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SONGDESIGNER_H__D135DB5E_66ED_11D3_B45D_00105A2796DE__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SongDesigner\SongDlg.h ===
#if !defined(AFX_SONGDLG_H__E2ED8AF6_6AD9_11D3_B45F_00105A2796DE__INCLUDED_)
#define AFX_SONGDLG_H__E2ED8AF6_6AD9_11D3_B45F_00105A2796DE__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

// SongDlg.h : header file
//

#include "VirtualSegmentPropPageObject.h"
#include "TrackPropPageObject.h"
#include "TransitionPropPageObject.h"


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// CSegmentListBox window

class CSegmentListBox : public CListBox
{
// Construction
public:
	CSegmentListBox();
	virtual ~CSegmentListBox();

// Attributes
public:
	CSongDlg*	m_pSongDlg;
	POINT		m_ptLastXYPos;

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CSegmentListBox)
	public:
	virtual void DrawItem(LPDRAWITEMSTRUCT lpDrawItemStruct);
	virtual void MeasureItem(LPMEASUREITEMSTRUCT lpMeasureItemStruct);
	//}}AFX_VIRTUAL

// Implementation
public:
	void SelectVirtualSegment( CVirtualSegment* pVirtualSegment );
	void SelectVirtualSegmentList( CTypedPtrList<CPtrList, CVirtualSegment*>& list );
	HRESULT CreateDataObject( IDataObject** ppIDataObject );

	// Generated message map functions
protected:
	//{{AFX_MSG(CSegmentListBox)
	afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnRButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnSetFocus(CWnd* pOldWnd);
	afx_msg void OnKillFocus(CWnd* pNewWnd);
	afx_msg void OnDblClk();
	afx_msg int VKeyToItem(UINT nKey, UINT nIndex);
	afx_msg void OnSelChange();
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// CTrackListBox window

class CTrackListBox : public CListBox
{
// Construction
public:
	CTrackListBox();
	virtual ~CTrackListBox();

// Attributes
public:
	CSongDlg*	m_pSongDlg;
	POINT		m_ptLastXYPos;

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CTrackListBox)
	public:
	virtual void DrawItem(LPDRAWITEMSTRUCT lpDrawItemStruct);
	virtual void MeasureItem(LPMEASUREITEMSTRUCT lpMeasureItemStruct);
	virtual int CompareItem(LPCOMPAREITEMSTRUCT lpCompareItemStruct);
	//}}AFX_VIRTUAL

// Implementation
public:
	void SelectTrack( CTrack* pTrack, bool fSetFocus );
	void SelectTrackList( CTypedPtrList<CPtrList, CTrack*>& list );
	HRESULT CreateDataObject( IDataObject** ppIDataObject );

	// Generated message map functions
protected:
	//{{AFX_MSG(CTrackListBox)
	afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnRButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnSetFocus(CWnd* pOldWnd);
	afx_msg void OnKillFocus(CWnd* pNewWnd);
	afx_msg void OnDblClk();
	afx_msg int VKeyToItem(UINT nKey, UINT nIndex);
	afx_msg void OnSelChange();
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// CTransitionListBox window

class CTransitionListBox : public CListBox
{
// Construction
public:
	CTransitionListBox();
	virtual ~CTransitionListBox();

// Attributes
public:
	CSongDlg*	m_pSongDlg;
	POINT		m_ptLastXYPos;

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CTransitionListBox)
	public:
	virtual void DrawItem(LPDRAWITEMSTRUCT lpDrawItemStruct);
	virtual void MeasureItem(LPMEASUREITEMSTRUCT lpMeasureItemStruct);
	//}}AFX_VIRTUAL

// Implementation
public:
	void SelectTransition( CTransition* pTransition, bool fSetFocus );
	void SelectTransitionList( CTypedPtrList<CPtrList, CTransition*>& list );
	HRESULT CreateDataObject( IDataObject** ppIDataObject );

	// Generated message map functions
protected:
	//{{AFX_MSG(CTransitionListBox)
	afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnRButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnSetFocus(CWnd* pOldWnd);
	afx_msg void OnKillFocus(CWnd* pNewWnd);
	afx_msg void OnDblClk();
	afx_msg int VKeyToItem(UINT nKey, UINT nIndex);
	afx_msg void OnSelChange();
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// CSongDlg form view

#ifndef __AFXEXT_H__
#include <afxext.h>
#endif

class CSongDlg : public CFormView, public IDropSource, public IDropTarget
{
friend class CSegmentListBox;
friend class CTrackListBox;
friend class CTransitionListBox;

public:
	CSongDlg();           // protected constructor used by dynamic creation
	virtual ~CSongDlg();

    // IUnknown methods
    HRESULT STDMETHODCALLTYPE QueryInterface( REFIID riid, LPVOID *ppv );
    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();

	// IDropSource methods
	HRESULT STDMETHODCALLTYPE QueryContinueDrag( BOOL fEscapePressed, DWORD grfKeyState );
	HRESULT STDMETHODCALLTYPE GiveFeedback( DWORD dwEffect );

	// IDropTarget methods
	HRESULT STDMETHODCALLTYPE DragEnter( IDataObject* pIDataObject, DWORD grfKeyState, POINTL pt, DWORD* pdwEffect);
	HRESULT STDMETHODCALLTYPE DragOver( DWORD grfKeyState, POINTL pt, DWORD* pdwEffect);
	HRESULT STDMETHODCALLTYPE DragLeave();
	HRESULT STDMETHODCALLTYPE Drop( IDataObject* pIDataObject, DWORD grfKeyState, POINTL pt, DWORD* pdwEffect);

	// Additional methods
protected:
	HRESULT CanPasteFromData( IDataObject* pIDataObject, bool fInDragDrop, POINT pt, bool* fMoveIsOK );
	HRESULT PasteFromData( IDataObject* pIDataObject, bool fInDragDrop, POINT pt );
	HRESULT CF_SEGMENT_PasteVirtualSegment( CDllJazzDataObject* pDataObject, IDataObject* pIDataObject, bool fInDragDrop, POINT pt );
	HRESULT CF_VIRTUAL_SEGMENT_LIST_PasteVirtualSegment( CDllJazzDataObject* pDataObject, IDataObject* pIDataObject, bool fInDragDrop, POINT pt );
	HRESULT CF_TRANSITION_LIST_PasteTransition( CDllJazzDataObject* pDataObject, IDataObject* pIDataObject, bool fInDragDrop, POINT pt );
	HRESULT CF_TRACK_LIST_PasteTrack( CDllJazzDataObject* pDataObject, IDataObject* pIDataObject, bool fInDragDrop, POINT pt );
	
	void FillSourceSegmentComboBox();
	void FillVirtualSegmentComboBox();
	void FillToolGraphComboBox();
	void FillVirtualSegmentListBox();
	void FillTrackListBox( CVirtualSegment* pVirtualSegment );
	void FillTransitionListBox( CVirtualSegment* pVirtualSegment );

	void SelectSourceSegmentComboBox( CSourceSegment* pSourceSegment );
	void SelectVirtualSegmentComboBox( CVirtualSegment* pVirtualSegment );
	void SelectToolGraphComboBox( IDMUSProdNode* pIToolGraphNode );

	void RefreshVirtualSegmentControls();
	void EnableVirtualSegmentControls( BOOL fEnable );
	void OnInsertVirtualSegment();
	void OnDeleteVirtualSegments();
	void MarkSelectedVirtualSegments( DWORD dwFlags );
	void UnMarkVirtualSegments( DWORD dwFlags );
	void DeleteMarkedVirtualSegments( DWORD dwFlags );
	
	void OnInsertTrack();
	void OnDeleteTracks();
	void MarkSelectedTracks( CVirtualSegment* pVirtualSegment, DWORD dwFlags );
	void UnMarkTracks( CVirtualSegment* pVirtualSegment, DWORD dwFlags );
	void DeleteMarkedTracks( CVirtualSegment* pVirtualSegment, DWORD dwFlags );

	void OnInsertTransition();
	void OnDeleteTransitions();
	void MarkSelectedTransitions( CVirtualSegment* pVirtualSegment, DWORD dwFlags );
	void UnMarkTransitions( CVirtualSegment* pVirtualSegment, DWORD dwFlags );
	void DeleteMarkedTransitions( CVirtualSegment* pVirtualSegment, DWORD dwFlags );

	bool IsDataObjectFromSameSong( IDataObject* pIDataObject );

public:
	CVirtualSegment* GetVirtualSegmentToEdit();
	CTrack* GetTrackToEdit();
	CTransition* GetTransitionToEdit();
	int GetVirtualSegmentSelCount();
	int GetTrackSelCount();
	int GetTransitionSelCount();

	void DoDrag( UINT nID, DWORD dwStartDragButton ); 
	void RefreshProperties( UINT nControlID );
	void SyncSongEditor( DWORD dwFlags );
	void OnUpdateEditCut( CCmdUI* pCmdUI );
	void OnEditCut();
	void OnUpdateEditCopy( CCmdUI* pCmdUI );
	void OnEditCopy();
	void OnUpdateEditPaste( CCmdUI* pCmdUI );
	void OnEditPaste();
	void OnUpdateEditInsert( CCmdUI* pCmdUI );
	void OnEditInsert();
	void OnUpdateEditDelete( CCmdUI* pCmdUI );
	void OnEditDelete();
	void OnEditSelectAll();
	BOOL OnViewProperties();
	CFont* CreateFont();
	void SelectVirtualSegment( CVirtualSegment* pVirtualSegment );
	CVirtualSegment* GetFirstSelectedVirtualSegment();

public:
	CSegmentListBox		m_lstbxSegments;			// Subclasses IDC_LIST_VIRTUAL_SEGMENTS
	CTrackListBox		m_lstbxTracks;				// Subclasses IDC_LIST_TRACKS
	CTransitionListBox	m_lstbxTransitions;			// Subclasses IDC_LIST_TRANSITIONS

private:
	CVirtualSegmentPropPageObject*	m_pVirtualSegmentPropPageObject;
	CTrackPropPageObject*			m_pTrackPropPageObject;
	CTransitionPropPageObject*		m_pTransitionPropPageObject;
	bool							m_fOpenProperties;

	int					m_nEditMenuCtrlID;			// Last control to have the focus

	IDataObject*		m_pIDataObject;				// Object being dragged	
	UINT				m_nStartDragControlID;		// Control that initiated drag operation
	DWORD				m_dwStartDragButton;		// Mouse button that initiated drag operation
	DWORD				m_dwOverDragButton;			// Mouse button stored in IDropTarget::DragOver
	DWORD				m_dwOverDragEffect;			// Drag effects stored in IDropTarget::DragOver
	CImageList*			m_pDragImage;				// Image used for drag operation feedback
	DWORD				m_dwDragRMenuEffect;		// Result from drag context menu
	CDirectMusicSong*	m_pDragSong;				// Items being dragged from this Song

	IDMUSProdNode*		m_pINodeRightMenu;			// Recipient of right menu command id
	POINT				m_pointRightMenu;			// x,y coords of right click

	DWORD				m_dwMouseDownButton;		// MK_RBUTTON or MK_LBUTTON
	CRect				m_rectMouseDown;			// If user moves out of this rect start drag-drop
	POINT				m_pointMouseDown;			// Origin of drag-drop operation

	DWORD				m_dwScrollTick;

	static long			sm_lBitmapRefCount;
	static CBitmap		sm_bmpTransition;

public:
	CSongCtrl*			m_pSongCtrl;
	CDirectMusicSong*	m_pSong;

// Form Data
public:
	//{{AFX_DATA(CSongDlg)
	enum { IDD = IDD_DLG_SONG };
	CButton	m_btnTransition;
	CComboBox	m_comboToolGraph;
	CEdit	m_editName;
	CComboBox	m_comboSegment;
	CComboBox	m_comboNextSegment;
	CButton	m_checkStartPlayback;
	CButton	m_checkQueueNext;
	//}}AFX_DATA

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CSongDlg)
	public:
	virtual void OnInitialUpdate();
	virtual BOOL Create(LPCTSTR lpszClassName, LPCTSTR lpszWindowName, DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID, CCreateContext* pContext = NULL);
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam);
	//}}AFX_VIRTUAL

// Implementation
protected:
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

	// Generated message map functions
	//{{AFX_MSG(CSongDlg)
	afx_msg void OnDragRMenuMove();
	afx_msg void OnDragRMenuCopy();
	afx_msg void OnDragRMenuCancel();
	afx_msg void OnDestroy();
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
	afx_msg void OnSelChangeNextVirtualSegment();
	afx_msg void OnSelChangeSourceSegment();
	afx_msg void OnSelChangeToolGraph();
	afx_msg void OnKillFocusEditName();
	afx_msg void OnTransition();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SONGDLG_H__E2ED8AF6_6AD9_11D3_B45F_00105A2796DE__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SongDesigner\StdAfx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SongDesigner\SongDocType.cpp ===
// SongDocType.cpp : implementation file
//

#include "stdafx.h"

#include "SongDesignerDLL.h"
#include "Song.h"
#include <dmusicf.h>
#include <mmreg.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/////////////////////////////////////////////////////////////////////////////
// CSongDocType constructor/destructor

CSongDocType::CSongDocType()
{
    m_dwRef = 0;
}

CSongDocType::~CSongDocType()
{
}


/////////////////////////////////////////////////////////////////////////////
// CSongDocType IUnknown implementation

HRESULT CSongDocType::QueryInterface( REFIID riid, LPVOID FAR* ppvObj )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    if( ::IsEqualIID(riid, IID_IDMUSProdDocType)
    ||  ::IsEqualIID(riid, IID_IDMUSProdDocType8)
	||  ::IsEqualIID(riid, IID_IUnknown) )
    {
        AddRef();
        *ppvObj = (IDMUSProdDocType8 *)this;
        return S_OK;
    }

    *ppvObj = NULL;
    return E_NOINTERFACE;
}

ULONG CSongDocType::AddRef()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	AfxOleLockApp(); 
    return ++m_dwRef;
}

ULONG CSongDocType::Release()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    ASSERT( m_dwRef != 0 );

	AfxOleUnlockApp(); 
    --m_dwRef;

    if( m_dwRef == 0 )
    {
        delete this;
        return 0;
    }

    return m_dwRef;
}


/////////////////////////////////////////////////////////////////////////////
// CSongDocType IDMUSProdDocType implementation

/////////////////////////////////////////////////////////////////////////////
// CSongDocType::GetResourceId

HRESULT CSongDocType::GetResourceId( HINSTANCE* phInstance, UINT* pnResourceId )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	*phInstance   = theApp.m_hInstance;
	*pnResourceId = IDR_SONG_DOCTYPE;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CSongDocType::DoesExtensionMatch

HRESULT CSongDocType::DoesExtensionMatch( BSTR bstrExt )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CString strExt = bstrExt;
	::SysFreeString( bstrExt );

	CString strDocTypeExt;
	TCHAR   achBuffer[MAX_BUFFER];

	if( ::LoadString(theApp.m_hInstance, IDR_SONG_DOCTYPE, achBuffer, MID_BUFFER) == 0 )
	{
		return E_FAIL;
	}

	if( AfxExtractSubString(strDocTypeExt, achBuffer, CDocTemplate::filterExt) )
	{
		ASSERT( strDocTypeExt[0] == '.' );

		BOOL fContinue = TRUE;
		CString strDocExt;
		int nFindPos;

		nFindPos = strDocTypeExt.Find( _T(";") );
		while( fContinue )
		{
			if( nFindPos == -1 )
			{
				fContinue = FALSE;

				nFindPos = strDocTypeExt.Find( _T(".") );
				if( nFindPos != 0 )
				{
					break;
				}
				strDocExt = strDocTypeExt;
			}
			else
			{
				strDocExt = strDocTypeExt.Left( nFindPos );
				strDocTypeExt = strDocTypeExt.Right( strDocTypeExt.GetLength() - (nFindPos + 1) ); 
			}

			if( _tcsicmp(strExt, strDocExt) == 0 )
			{
				return S_OK;	// extension matches 
			}

			nFindPos = strDocTypeExt.Find( _T(";") );
		}
	}

	return S_FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CSongDocType::DoesIdMatch

HRESULT CSongDocType::DoesIdMatch( REFGUID rguid )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    if( ::IsEqualGUID(rguid, GUID_SongNode) )
	{
		return S_OK;
	}

	return S_FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CSongDocType::AllocNode

HRESULT STDMETHODCALLTYPE CSongDocType::AllocNode( REFGUID rguid, IDMUSProdNode** ppINode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( ppINode == NULL )
	{
		return E_POINTER;
	}

	*ppINode = NULL;

    if( ::IsEqualGUID(rguid, GUID_SongNode) )
	{
		// Create a new Song 
		CDirectMusicSong* pSong = new CDirectMusicSong;
		if( pSong == NULL )
		{
			return E_OUTOFMEMORY ;
		}

		// Create the Undo Manager
		if( pSong->CreateUndoMgr() == FALSE )
		{
			RELEASE( pSong );
			return E_OUTOFMEMORY;
		}

		*ppINode = (IDMUSProdNode *)pSong;
		return S_OK;
	}

	return E_INVALIDARG;
}


/////////////////////////////////////////////////////////////////////////////
// CSongDocType:::OnFileNew

HRESULT CSongDocType::OnFileNew( IDMUSProdProject* pITargetProject, IDMUSProdNode* pITargetDirectoryNode,
								  IDMUSProdNode** ppIDocRootNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	IDMUSProdNode* pISongNode;

	HRESULT hr = E_FAIL;

	ASSERT( theApp.m_pSongComponent != NULL );
	ASSERT( theApp.m_pSongComponent->m_pIFramework8 != NULL );
	
	if( ppIDocRootNode == NULL )
	{
		return E_POINTER;
	}

	*ppIDocRootNode = NULL;

	// Create a new Song 
	hr = AllocNode( GUID_SongNode, &pISongNode );
	if( SUCCEEDED ( hr ) )
	{
		// Set root and parent node of ALL children
		theApp.SetNodePointers( pISongNode, pISongNode, NULL );

		// Add node to Project Tree
		if( SUCCEEDED ( theApp.m_pSongComponent->m_pIFramework8->AddNode(pISongNode, NULL) ) )
		{
			CDirectMusicSong* pSong = (CDirectMusicSong *)pISongNode;

			// Store the Song's Project
			pSong->m_pIProject = pITargetProject;
//			pSong->m_pIProject->AddRef();			intentionally missing

			// Get the filename
			BSTR bstrName;

			if( SUCCEEDED ( pISongNode->GetNodeName( &bstrName ) ) )
			{
				pSong->m_strOrigFileName = bstrName;
				pSong->m_strOrigFileName += _T(".snp");
				::SysFreeString( bstrName );
			}

			// Add Song to Song component list 
			theApp.m_pSongComponent->AddToSongFileList( pSong );

			// Advise the ConnectionPoint for this CDirectMusicSong
			// Register CDirectMusicSong with the Transport.
			pSong->RegisterWithTransport();

			// Sync changes
			pSong->SyncChanges( SC_DIRECTMUSIC, 0, NULL );

			*ppIDocRootNode = pISongNode;
			pSong->SetModified( TRUE );
			hr = S_OK;
		}
		else
		{
			RELEASE( pISongNode );
		}
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CSongDocType::OnFileOpen

HRESULT CSongDocType::OnFileOpen( IStream* pIStream, IDMUSProdProject* pITargetProject,
								    IDMUSProdNode* pITargetDirectoryNode, IDMUSProdNode** ppIDocRootNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CWaitCursor wait;
	CDirectMusicSong* pSong;
	CString strFileName;
	HRESULT hr = E_FAIL;

	ASSERT( theApp.m_pSongComponent != NULL );
	ASSERT( theApp.m_pSongComponent->m_pIFramework8 != NULL );
	
	if( ppIDocRootNode == NULL )
	{
		return E_POINTER;
	}

	*ppIDocRootNode = NULL;
	// Create a new Song 
	pSong = new CDirectMusicSong;
	if( pSong == NULL )
	{
		return E_OUTOFMEMORY ;
	}
	theApp.m_pSongComponent->m_nNextSong--;

	// Create the Undo Manager
	if( pSong->CreateUndoMgr() == FALSE )
	{
		RELEASE( pSong );
		return E_OUTOFMEMORY;
	}

	// Store the Song's Project
	pSong->m_pIProject = pITargetProject;
//	pSong->m_pIProject->AddRef();			intentionally missing

	// Get the filename
	IDMUSProdPersistInfo* pPersistInfo;

	if( SUCCEEDED ( pIStream->QueryInterface( IID_IDMUSProdPersistInfo, (void **)&pPersistInfo ) ) )
	{
		BSTR bstrFileName;

		pPersistInfo->GetFileName( &bstrFileName );
		pSong->m_strOrigFileName = bstrFileName;
		::SysFreeString( bstrFileName );

		int nFindPos = pSong->m_strOrigFileName.ReverseFind( (TCHAR)'\\' );
		if( nFindPos != -1 )
		{
			pSong->m_strOrigFileName = pSong->m_strOrigFileName.Right( pSong->m_strOrigFileName.GetLength() - nFindPos - 1 );
		}

		pPersistInfo->Release();
	}

	// Load the Song file
	if( theApp.m_pSongComponent->m_pSongBeingLoaded == NULL )
	{
		theApp.m_pSongComponent->m_pSongBeingLoaded = pSong;
		theApp.m_pSongComponent->m_pIDupeFileTargetProject = pITargetProject;
		theApp.m_pSongComponent->m_nDupeFileDlgReturnCode = 0;
	}
	hr = pSong->Load( pIStream );
	if( theApp.m_pSongComponent->m_pSongBeingLoaded == pSong )
	{
		theApp.m_pSongComponent->m_pSongBeingLoaded = NULL;
		theApp.m_pSongComponent->m_pIDupeFileTargetProject = NULL;
		theApp.m_pSongComponent->m_nDupeFileDlgReturnCode = 0;
	}
	if( !SUCCEEDED ( hr ) )
	{
		RELEASE( pSong );
		return hr;
	}

	// Set root and parent node of ALL children
	theApp.SetNodePointers( pSong, pSong, NULL );

	// Add node to Project Tree
	if( SUCCEEDED ( theApp.m_pSongComponent->m_pIFramework8->AddNode(pSong, NULL) ) )
	{
		pSong->SetModified( FALSE );

		// Add Song to Song component list 
		theApp.m_pSongComponent->AddToSongFileList( pSong );

		// Advise the ConnectionPoint for this CDirectMusicSong
		// Register CDirectMusicSong with the Transport.
		pSong->RegisterWithTransport();

		*ppIDocRootNode = pSong;

		hr = S_OK;
	}
	else
	{
		RELEASE( pSong );
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CSongDocType::OnFileSave

HRESULT CSongDocType::OnFileSave( IStream* pIStream, IDMUSProdNode* pIDocRootNode )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);

	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CSongDocType::GetListInfo

HRESULT CSongDocType::GetListInfo( IStream* pIStream, DMUSProdListInfo* pListInfo ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( pIStream != NULL );
    ASSERT( pListInfo != NULL );

	if( pIStream == NULL
	||  pListInfo == NULL )
	{
		return E_INVALIDARG;
	}

	HRESULT hr = E_FAIL;

	// Create temporary Song object to retrieve list info
	CDirectMusicSong* pSong = new CDirectMusicSong;
	if( pSong )
	{
		// Create the Undo Manager
		if( pSong->CreateUndoMgr() )
		{
			hr = pSong->ReadListInfoFromStream( pIStream, pListInfo );
		}

		RELEASE( pSong );
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CSongDocType::IsFileTypeExtension

HRESULT CSongDocType::IsFileTypeExtension( FileType ftFileType, BSTR bstrExt )    
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CString strExt = bstrExt;
	::SysFreeString( bstrExt );

	strExt.MakeLower();

	switch( ftFileType )
	{
		case FT_DESIGN:
			if( strExt == _T(".snp") )
			{
				return S_OK;
			}
			break;

		case FT_RUNTIME:
			if( strExt == _T(".sng") )
			{
				return S_OK;
			}
			break;
	}

	return S_FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CSongDocType::GetObjectDescriptorFromNode

HRESULT CSongDocType::GetObjectDescriptorFromNode( IDMUSProdNode* pIDocRootNode, void* pObjectDesc )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
	
	// Make sure method was passed a Song Node
	CDirectMusicSong* pSong;
	GUID guidNodeId;
	if( SUCCEEDED ( pIDocRootNode->GetNodeId ( &guidNodeId ) ) )
	{
		if( !( IsEqualGUID ( guidNodeId, GUID_SongNode ) ) )
		{
			return E_INVALIDARG;
		}
	}
	pSong = (CDirectMusicSong *)pIDocRootNode;

	return pSong->GetObjectDescriptor( pObjectDesc );
}


/////////////////////////////////////////////////////////////////////////////
// CSongDocType::GetObjectRiffId

HRESULT CSongDocType::GetObjectRiffId( GUID guidNodeId, DWORD* pckid, DWORD* pfccType )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( pckid == NULL
	||  pfccType == NULL )
	{
		return E_POINTER;
	}

	// Make sure method was passed a Song Node
	if( IsEqualGUID ( guidNodeId, GUID_SongNode ) ) 
	{
		*pckid = FOURCC_RIFF;
		*pfccType = DMUS_FOURCC_SONG_FORM;
		return S_OK;
	}

	return E_INVALIDARG;
}


/////////////////////////////////////////////////////////////////////////////
// CSongDocType::GetObjectExt

HRESULT CSongDocType::GetObjectExt( GUID guidNodeId, FileType ftFileType, BSTR* pbstrExt )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( pbstrExt == NULL )
	{
		return E_POINTER;
	}

	// Make sure method was passed a Song Node
	if( IsEqualGUID ( guidNodeId, GUID_SongNode ) ) 
	{
		if( ftFileType == FT_DESIGN )
		{
			CString strExt = ".snp";
			*pbstrExt = strExt.AllocSysString();
			return S_OK;
		}

		if( ftFileType == FT_RUNTIME )
		{
			CString strExt = ".sng";
			*pbstrExt = strExt.AllocSysString();
			return S_OK;
		}
	}

	return E_INVALIDARG;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SongDesigner\StdAfx.h ===
#if !defined(AFX_STDAFX_H__D135DB5C_66ED_11D3_B45D_00105A2796DE__INCLUDED_)
#define AFX_STDAFX_H__D135DB5C_66ED_11D3_B45D_00105A2796DE__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxctl.h>         // MFC support for ActiveX Controls
#include <afxcmn.h>
#include <Afxdisp.h>
#include <htmlhelp.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__D135DB5C_66ED_11D3_B45D_00105A2796DE__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SongDesigner\SongRef.cpp ===
// SongRef.cpp : implementation file
//

#include "stdafx.h"
#include "SongDesignerDLL.h"

#include "Song.h"
#include "SongRef.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/////////////////////////////////////////////////////////////////////////////
// CSongRef constructor/destructor

CSongRef::CSongRef()
{
    m_dwRef = 0;
	AddRef();

	m_pIDocRootNode = NULL;
	m_pIParentNode = NULL;
	m_pSong = NULL;
}

CSongRef::~CSongRef()
{
	RELEASE( m_pSong );
}


/////////////////////////////////////////////////////////////////////////////
// CSongRef IUnknown implementation

HRESULT CSongRef::QueryInterface( REFIID riid, LPVOID FAR* ppvObj )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    if( ::IsEqualIID(riid, IID_IDMUSProdNode)
	||  ::IsEqualIID(riid, IID_IUnknown) )
    {
        AddRef();
        *ppvObj = (IDMUSProdNode *)this;
        return S_OK;
    }

    if( ::IsEqualIID(riid, IID_IDMUSProdReferenceNode) )
    {
        AddRef();
        *ppvObj = (IDMUSProdReferenceNode *)this;
        return S_OK;
    }

    *ppvObj = NULL;
    return E_NOINTERFACE;
}

ULONG CSongRef::AddRef()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	AfxOleLockApp(); 
    return ++m_dwRef;
}

ULONG CSongRef::Release()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    ASSERT( m_dwRef != 0 );

	AfxOleUnlockApp(); 
    --m_dwRef;

    if( m_dwRef == 0 )
    {
        delete this;
        return 0;
    }

    return m_dwRef;
}


/////////////////////////////////////////////////////////////////////////////
// CSongRef IDMUSProdNode implementation

/////////////////////////////////////////////////////////////////////////////
// CSongRef IDMUSProdNode::GetNodeImageIndex

HRESULT CSongRef::GetNodeImageIndex( short* pnFirstImage )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( theApp.m_pSongComponent != NULL );

	return( theApp.m_pSongComponent->GetSongRefImageIndex(pnFirstImage) );
}


/////////////////////////////////////////////////////////////////////////////
// CSongRef IDMUSProdNode::GetFirstChild

HRESULT CSongRef::GetFirstChild( IDMUSProdNode** ppIFirstChildNode )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(ppIFirstChildNode);

    return E_NOTIMPL;	// SongRef node does not have children
}


/////////////////////////////////////////////////////////////////////////////
// CSongRef IDMUSProdNode::GetNextChild

HRESULT CSongRef::GetNextChild( IDMUSProdNode* pIChildNode, IDMUSProdNode** ppINextChildNode )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(pIChildNode);
	UNREFERENCED_PARAMETER(ppINextChildNode);

    return E_NOTIMPL;	// SongRef node does not have children
}


/////////////////////////////////////////////////////////////////////////////
// CSongRef IDMUSProdNode::GetComponent

HRESULT CSongRef::GetComponent( IDMUSProdComponent** ppIComponent )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( theApp.m_pSongComponent != NULL );

	return theApp.m_pSongComponent->QueryInterface( IID_IDMUSProdComponent, (void**)ppIComponent );
}


/////////////////////////////////////////////////////////////////////////////
// CSongRef IDMUSProdNode::GetDocRootNode

HRESULT CSongRef::GetDocRootNode( IDMUSProdNode** ppIDocRootNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pIDocRootNode )
	{
		m_pIDocRootNode->AddRef();
		*ppIDocRootNode = m_pIDocRootNode;
		return S_OK;
	}

	*ppIDocRootNode = NULL;
	return E_FAIL;
}


/////////////////////////////////////////////////////////////////////////////
// CSongRef IDMUSProdNode::SetDocRootNode

HRESULT CSongRef::SetDocRootNode( IDMUSProdNode* pIDocRootNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( pIDocRootNode != NULL );

	m_pIDocRootNode = pIDocRootNode;
//	m_pIDocRootNode->AddRef();		intentionally missing

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CSongRef IDMUSProdNode::GetParentNode

HRESULT CSongRef::GetParentNode( IDMUSProdNode** ppIParentNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pIParentNode != NULL );

	m_pIParentNode->AddRef();
	*ppIParentNode = m_pIParentNode;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CSongRef IDMUSProdNode::SetParentNode

HRESULT CSongRef::SetParentNode( IDMUSProdNode* pIParentNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( pIParentNode != NULL );

	m_pIParentNode = pIParentNode;
//	m_pIParentNode->AddRef();		intentionally missing

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CSongRef IDMUSProdNode::GetNodeId

HRESULT CSongRef::GetNodeId( GUID* pguid )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( pguid == NULL )
	{
		return E_POINTER;
	}

	*pguid = GUID_SongRefNode;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CSongRef IDMUSProdNode::GetNodeName

HRESULT CSongRef::GetNodeName( BSTR* pbstrName )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pSong == NULL )
	{
		TCHAR achNoSong[MID_BUFFER];

		::LoadString( theApp.m_hInstance, IDS_NO_SONG, achNoSong, MID_BUFFER );
		CString strNoSong = achNoSong;
		*pbstrName = strNoSong.AllocSysString();
		return S_OK;
	}

    return m_pSong->GetNodeName( pbstrName );
}


/////////////////////////////////////////////////////////////////////////////
// CSongRef IDMUSProdNode::GetNodeNameMaxLength

HRESULT CSongRef::GetNodeNameMaxLength( short* pnMaxLength )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	*pnMaxLength = -1;	// Can't rename a SongRef node

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CSongRef IDMUSProdNode::ValidateNodeName

HRESULT CSongRef::ValidateNodeName( BSTR bstrName )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(bstrName);

	return E_NOTIMPL;	// Can't rename a SongRef node
}


/////////////////////////////////////////////////////////////////////////////
// CSongRef IDMUSProdNode::SetNodeName

HRESULT CSongRef::SetNodeName( BSTR bstrName )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(bstrName);

	return E_NOTIMPL;	// Can't rename a SongRef node
}


/////////////////////////////////////////////////////////////////////////////
// CSongRef IDMUSProdNode::GetNodeListInfo

HRESULT CSongRef::GetNodeListInfo( DMUSProdListInfo* pListInfo )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pSong == NULL )
	{
		return E_FAIL;
	}

    return m_pSong->GetNodeListInfo( pListInfo );
}


/////////////////////////////////////////////////////////////////////////////
// CSongRef IDMUSProdNode::GetEditorClsId

HRESULT CSongRef::GetEditorClsId( CLSID* pClsId )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pSong == NULL )
	{
		return E_FAIL;
	}

    *pClsId = CLSID_SongEditor;
	
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CSongRef IDMUSProdNode::GetEditorTitle

HRESULT CSongRef::GetEditorTitle( BSTR* pbstrTitle )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pSong == NULL )
	{
		return E_FAIL;
	}

    return m_pSong->GetEditorTitle( pbstrTitle );
}


/////////////////////////////////////////////////////////////////////////////
// CSongRef IDMUSProdNode::GetEditorWindow

HRESULT CSongRef::GetEditorWindow( HWND* hWndEditor )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pSong == NULL )
	{
		return E_FAIL;
	}

    return m_pSong->GetEditorWindow( hWndEditor );
}


/////////////////////////////////////////////////////////////////////////////
// CSongRef IDMUSProdNode::SetEditorWindow

HRESULT CSongRef::SetEditorWindow( HWND hWndEditor )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pSong == NULL )
	{
		return E_FAIL;
	}

    return m_pSong->SetEditorWindow( hWndEditor );
}


/////////////////////////////////////////////////////////////////////////////
// CSongRef IDMUSProdNode::UseOpenCloseImages

HRESULT CSongRef::UseOpenCloseImages( BOOL* pfUseOpenCloseImages )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	*pfUseOpenCloseImages = FALSE;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CSongRef IDMUSProdNode::GetRightClickMenuId

HRESULT CSongRef::GetRightClickMenuId( HINSTANCE* phInstance, UINT* pnMenuId )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	*phInstance = theApp.m_hInstance;
	*pnMenuId   = IDM_SONGREF_NODE_RMENU;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CSongRef IDMUSProdNode::OnRightClickMenuInit

HRESULT CSongRef::OnRightClickMenuInit( HMENU hMenu )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(hMenu);

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CSongRef IDMUSProdNode::OnRightClickMenuSelect

HRESULT CSongRef::OnRightClickMenuSelect( long lCommandId )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	switch( lCommandId )
	{
		case IDM_PROPERTIES:
			if( m_pSong )
			{
				return m_pSong->OnRightClickMenuSelect( lCommandId );
			}
			break;

		default:
			return E_FAIL;
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CSongRef IDMUSProdNode::DeleteChildNode

HRESULT CSongRef::DeleteChildNode( IDMUSProdNode* pIChildNode, BOOL fPromptUser )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(pIChildNode);
	UNREFERENCED_PARAMETER(fPromptUser);

	return E_NOTIMPL;	// SongRef nodes do not have children
}


/////////////////////////////////////////////////////////////////////////////
// CSongRef IDMUSProdNode::InsertChildNode

HRESULT CSongRef::InsertChildNode( IDMUSProdNode* pIChildNode )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(pIChildNode);

	return E_NOTIMPL;	// SongRef nodes do not have children
}


/////////////////////////////////////////////////////////////////////////////
// CSongRef IDMUSProdNode::DeleteNode

HRESULT CSongRef::DeleteNode( BOOL fPromptUser )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(fPromptUser);

	return E_FAIL;		// Cannot delete SongRef node?????
}


/////////////////////////////////////////////////////////////////////////////
// CSongRef IDMUSProdNode::OnNodeSelChanged

HRESULT CSongRef::OnNodeSelChanged( BOOL fSelected )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(fSelected);

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CSongRef IDMUSProdNode::CreateDataObject

HRESULT CSongRef::CreateDataObject( IDataObject** ppIDataObject )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( ppIDataObject == NULL )
	{
		return E_POINTER;
	}

	*ppIDataObject = NULL;

	if( m_pSong )
	{
		// Let Song create data object
		return m_pSong->CreateDataObject( ppIDataObject );
	}

	return E_FAIL;
}


/////////////////////////////////////////////////////////////////////////////
// CSongRef IDMUSProdNode::CanCut

HRESULT CSongRef::CanCut( void )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
 
	return CanDelete();
}


/////////////////////////////////////////////////////////////////////////////
// CSongRef IDMUSProdNode::CanCopy

HRESULT CSongRef::CanCopy( void )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
 
	if( m_pSong )
	{
		return S_OK;	// Will copy the Song
	}

	return S_FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CSongRef IDMUSProdNode::CanDelete

HRESULT CSongRef::CanDelete( void )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pIParentNode != NULL );

	return m_pIParentNode->CanDeleteChildNode( this );
}


/////////////////////////////////////////////////////////////////////////////
// CSongRef IDMUSProdNode::CanDeleteChildNode

HRESULT CSongRef::CanDeleteChildNode( IDMUSProdNode* pIChildNode )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(pIChildNode);

	ASSERT( 0 );

	return E_NOTIMPL;	// Song Reference nodes do not have children
}


/////////////////////////////////////////////////////////////////////////////
// CSongRef IDMUSProdNode::CanPasteFromData

HRESULT CSongRef::CanPasteFromData( IDataObject* pIDataObject, BOOL* pfWillSetReference )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( pfWillSetReference == NULL )
	{
		return E_POINTER;
	}

	*pfWillSetReference = FALSE;

	if( pIDataObject == NULL )
	{
		return E_INVALIDARG;
	}

	// Create a new CDllJazzDataObject and see if it contains a Song
	CDllJazzDataObject* pDataObject = new CDllJazzDataObject();
	if( pDataObject == NULL )
	{
		return E_OUTOFMEMORY;
	}
	
	HRESULT hr = pDataObject->IsClipFormatAvailable( pIDataObject, theApp.m_pSongComponent->m_cfSong );

	RELEASE( pDataObject );

	if( SUCCEEDED ( hr ) )
	{
		ASSERT( m_pIParentNode != NULL );

		// Let parent decide whether it wants to paste a Song
		return m_pIParentNode->CanChildPasteFromData( pIDataObject, this, pfWillSetReference );
	}

	if( m_pSong )
	{
		// Let Song decide what can be dropped
		return m_pSong->CanPasteFromData( pIDataObject, pfWillSetReference );
	}

	return S_FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CSongRef IDMUSProdNode::PasteFromData

HRESULT CSongRef::PasteFromData( IDataObject* pIDataObject )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( pIDataObject == NULL )
	{
		return E_INVALIDARG;
	}

	// Create a new CDllJazzDataObject and see if it contains a Song
	CDllJazzDataObject* pDataObject = new CDllJazzDataObject();
	if( pDataObject == NULL )
	{
		return E_OUTOFMEMORY;
	}
	
	HRESULT hr = pDataObject->IsClipFormatAvailable( pIDataObject, theApp.m_pSongComponent->m_cfSong );

	RELEASE( pDataObject );

	if( SUCCEEDED ( hr ) )
	{
		ASSERT( m_pIParentNode != NULL );

		// Let parent handle pasting of Song
		return m_pIParentNode->ChildPasteFromData( pIDataObject, this );
	}

	if( m_pSong )
	{
		// Let Song handle paste
		return m_pSong->PasteFromData( pIDataObject );
	}

	return E_FAIL;
}


/////////////////////////////////////////////////////////////////////////////
// CSongRef IDMUSProdNode::CanChildPasteFromData

HRESULT CSongRef::CanChildPasteFromData( IDataObject* pIDataObject, IDMUSProdNode* pIChildNode,
										  BOOL* pfWillSetReference )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(pIDataObject);
	UNREFERENCED_PARAMETER(pIChildNode);
	UNREFERENCED_PARAMETER(pfWillSetReference);

	return E_NOTIMPL;			// Song Reference nodes do not have children
}


/////////////////////////////////////////////////////////////////////////////
// CSongRef IDMUSProdNode::ChildPasteFromData

HRESULT CSongRef::ChildPasteFromData( IDataObject* pIDataObject, IDMUSProdNode* pIChildNode )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(pIDataObject);
	UNREFERENCED_PARAMETER(pIChildNode);

	return E_NOTIMPL;			// Song Reference nodes do not have children
}


/////////////////////////////////////////////////////////////////////////////
// CSongRef IDMUSProdNode::GetObject

HRESULT CSongRef::GetObject( REFCLSID rclsid, REFIID riid, void** ppvObject )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(rclsid);
	UNREFERENCED_PARAMETER(riid);
	UNREFERENCED_PARAMETER(ppvObject);

	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CSongRef IDMUSProdReferenceNode implementation

/////////////////////////////////////////////////////////////////////////////
// CSongRef IDMUSProdReferenceNode::GetReferencedFile

HRESULT CSongRef::GetReferencedFile( IDMUSProdNode** ppIDocRootNode )
{
 	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( ppIDocRootNode == NULL )
	{
		return E_POINTER;
	}

	*ppIDocRootNode = NULL;

	if( m_pSong )
	{
		m_pSong->AddRef();
		*ppIDocRootNode = m_pSong;
		return S_OK;
	}

    return E_FAIL;
}


/////////////////////////////////////////////////////////////////////////////
// CSongRef::IDMUSProdReferenceNode::SetReferencedFile

HRESULT CSongRef::SetReferencedFile( IDMUSProdNode* pIDocRootNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( pIDocRootNode )
	{
		// Make sure method was passed a DocRootNode
		IDMUSProdNode* pINode;
		if( FAILED ( pIDocRootNode->GetDocRootNode ( &pINode ) ) )
		{
			pINode = NULL;
		}
		if( pIDocRootNode != pINode )
		{
			RELEASE( pINode );
			return E_INVALIDARG;
		}
		RELEASE( pINode );

		// Make sure method was passed a Song Node
		GUID guidNodeId;
		if( SUCCEEDED ( pIDocRootNode->GetNodeId ( &guidNodeId ) ) )
		{
			if( !( IsEqualGUID ( guidNodeId, GUID_SongNode ) ) )
			{
				return E_INVALIDARG;
			}
		}
	}

	// Release previous DocRoot Node
	RELEASE( m_pSong );

	// Link to new DocRoot Node
	if( pIDocRootNode )
	{
		m_pSong = (CDirectMusicSong *)pIDocRootNode;
		m_pSong->AddRef();
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CSongRef Additional functions
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SongDesigner\SongRef.h ===
#ifndef __SONGREF_H__
#define __SONGREF_H__

// SongRef.h : header file
//

#include <RiffStrm.h>
#include "SongComponent.h"
#include "SongDocType.h"

class CSongRef : public IDMUSProdNode, public IDMUSProdReferenceNode
{
public:
    CSongRef();
	~CSongRef();

    // IUnknown functions
    HRESULT STDMETHODCALLTYPE QueryInterface( REFIID riid, LPVOID *ppv );
    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();

    // IDMUSProdNode functions
	HRESULT STDMETHODCALLTYPE GetNodeImageIndex( short* pnNbrFirstImage );
    HRESULT STDMETHODCALLTYPE GetFirstChild( IDMUSProdNode** ppIFirstChildNode );
    HRESULT STDMETHODCALLTYPE GetNextChild( IDMUSProdNode* pIChildNode, IDMUSProdNode** ppINextChildNode );

    HRESULT STDMETHODCALLTYPE GetComponent( IDMUSProdComponent** ppIComponent );
    HRESULT STDMETHODCALLTYPE GetDocRootNode( IDMUSProdNode** ppIDocRootNode );
    HRESULT STDMETHODCALLTYPE SetDocRootNode( IDMUSProdNode* pIDocRootNode );
    HRESULT STDMETHODCALLTYPE GetParentNode( IDMUSProdNode** ppIParentNode );
    HRESULT STDMETHODCALLTYPE SetParentNode( IDMUSProdNode* pIParentNode );
    HRESULT STDMETHODCALLTYPE GetNodeId( GUID* pguid );
    HRESULT STDMETHODCALLTYPE GetNodeName( BSTR* pbstrName );
    HRESULT STDMETHODCALLTYPE GetNodeNameMaxLength( short* pnMaxLength );
    HRESULT STDMETHODCALLTYPE ValidateNodeName( BSTR bstrName );
    HRESULT STDMETHODCALLTYPE SetNodeName( BSTR bstrName );
	HRESULT STDMETHODCALLTYPE GetNodeListInfo( DMUSProdListInfo* pListInfo );

    HRESULT STDMETHODCALLTYPE GetEditorClsId( CLSID* pclsid );
    HRESULT STDMETHODCALLTYPE GetEditorTitle( BSTR* pbstrTitle );
    HRESULT STDMETHODCALLTYPE GetEditorWindow( HWND* hWndEditor );
    HRESULT STDMETHODCALLTYPE SetEditorWindow( HWND hWndEditor );

	HRESULT STDMETHODCALLTYPE UseOpenCloseImages( BOOL* pfUseOpenCloseImages );

    HRESULT STDMETHODCALLTYPE GetRightClickMenuId( HINSTANCE* phInstance, UINT* pnResourceId );
    HRESULT STDMETHODCALLTYPE OnRightClickMenuInit( HMENU hMenu );
    HRESULT STDMETHODCALLTYPE OnRightClickMenuSelect( long lCommandId );

    HRESULT STDMETHODCALLTYPE DeleteChildNode( IDMUSProdNode* pIChildNode, BOOL fPromptUser );
    HRESULT STDMETHODCALLTYPE InsertChildNode( IDMUSProdNode* pIChildNode );
    HRESULT STDMETHODCALLTYPE DeleteNode( BOOL fPromptUser );

	HRESULT STDMETHODCALLTYPE OnNodeSelChanged( BOOL fSelected );

	HRESULT STDMETHODCALLTYPE CreateDataObject( IDataObject** ppIDataObject );
	HRESULT STDMETHODCALLTYPE CanCut();
	HRESULT STDMETHODCALLTYPE CanCopy();
	HRESULT STDMETHODCALLTYPE CanDelete();
	HRESULT STDMETHODCALLTYPE CanDeleteChildNode( IDMUSProdNode* pIChildNode );
	HRESULT STDMETHODCALLTYPE CanPasteFromData( IDataObject* pIDataObject, BOOL* pfWillSetReference );
	HRESULT STDMETHODCALLTYPE PasteFromData( IDataObject* pIDataObject );
	HRESULT STDMETHODCALLTYPE CanChildPasteFromData( IDataObject* pIDataObject, IDMUSProdNode* pIChildNode, BOOL* pfWillSetReference );
	HRESULT STDMETHODCALLTYPE ChildPasteFromData( IDataObject* pIDataObject, IDMUSProdNode* pIChildNode );

	HRESULT STDMETHODCALLTYPE GetObject( REFCLSID rclsid, REFIID riid, void** ppvObject ); 

    // IDMUSProdReferenceNode functions
	HRESULT STDMETHODCALLTYPE GetReferencedFile( IDMUSProdNode** ppIDocRootNode );
	HRESULT STDMETHODCALLTYPE SetReferencedFile( IDMUSProdNode* pIDocRootNode );

	//Additional functions

public:
	CDirectMusicSong*	m_pSong;		// SongRef refers to this Song

private:
    DWORD				m_dwRef;
	IDMUSProdNode*		m_pIDocRootNode;
	IDMUSProdNode*		m_pIParentNode;
};

#endif // __SONGREF_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SongDesigner\TabInfo.cpp ===
// TabInfo.cpp : implementation file
//

#include "stdafx.h"
#include "TabInfo.h"
#include "SongDesignerDll.h"
#include "Song.h"
#include <guiddlg.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CTabInfo property page

CTabInfo::CTabInfo( CSongPropPageManager* pSongPropPageManager ) : CPropertyPage(CTabInfo::IDD)
{
	//{{AFX_DATA_INIT(CTabInfo)
	//}}AFX_DATA_INIT
	
	ASSERT( pSongPropPageManager != NULL );

	m_pSong = NULL;
	m_pPageManager = pSongPropPageManager;
	m_fNeedToDetach = FALSE;
}

CTabInfo::~CTabInfo()
{
}


/////////////////////////////////////////////////////////////////////////////
// CTabInfo::SetSong

void CTabInfo::SetSong( CDirectMusicSong* pSong )
{
	m_pSong = pSong;

	UpdateControls();
}


/////////////////////////////////////////////////////////////////////////////
// CTabInfo::EnableControls

void CTabInfo::EnableControls( BOOL fEnable ) 
{
	m_editAuthor.EnableWindow( fEnable );
	m_editCopyright.EnableWindow( fEnable );
	m_editSubject.EnableWindow( fEnable );
	m_editInfo.EnableWindow( fEnable );
	m_editVersion_1.EnableWindow( fEnable );
	m_editVersion_2.EnableWindow( fEnable );
	m_editVersion_3.EnableWindow( fEnable );
	m_editVersion_4.EnableWindow( fEnable );
}


/////////////////////////////////////////////////////////////////////////////
// CTabInfo::UpdateControls

void CTabInfo::UpdateControls() 
{
	// Make sure controls have been created
	if( ::IsWindow(m_editVersion_1.m_hWnd) == FALSE )
	{
		return;
	}
	
	// Update controls
	m_editVersion_1.LimitText( 4 );
	m_editVersion_2.LimitText( 4 );
	m_editVersion_3.LimitText( 4 );
	m_editVersion_4.LimitText( 4 );

	if( m_pSong )
	{
		CString strText;

		EnableControls( TRUE );

		m_editAuthor.SetWindowText( m_pSong->m_strAuthor );
		m_editCopyright.SetWindowText( m_pSong->m_strCopyright );
		m_editSubject.SetWindowText( m_pSong->m_strSubject );
		m_editInfo.SetWindowText( m_pSong->m_strInfo );
		
		strText.Format( "%u", ((m_pSong->m_vVersion.dwVersionMS & 0xFFFF0000) >> 16) );
		m_editVersion_1.SetWindowText( strText );
		
		strText.Format( "%u", (m_pSong->m_vVersion.dwVersionMS & 0x0000FFFF) );
		m_editVersion_2.SetWindowText( strText );
		
		strText.Format( "%u", ((m_pSong->m_vVersion.dwVersionLS & 0xFFFF0000) >> 16) );
		m_editVersion_3.SetWindowText( strText );
		
		strText.Format( "%u", (m_pSong->m_vVersion.dwVersionLS & 0x0000FFFF) );
		m_editVersion_4.SetWindowText( strText );
	}
	else
	{
		m_editAuthor.SetWindowText( _T("") );
		m_editCopyright.SetWindowText( _T("") );
		m_editSubject.SetWindowText( _T(""));
		m_editInfo.SetWindowText( _T(""));
		m_editVersion_1.SetWindowText( _T("") );
		m_editVersion_2.SetWindowText( _T("") );
		m_editVersion_3.SetWindowText( _T("") );
		m_editVersion_4.SetWindowText( _T("") );

		EnableControls( FALSE );
	}
}


void CTabInfo::DoDataExchange(CDataExchange* pDX)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CTabInfo)
	DDX_Control(pDX, IDC_EDIT_GUID, m_btnGUID);
	DDX_Control(pDX, IDC_VERSION_4, m_editVersion_4);
	DDX_Control(pDX, IDC_VERSION_3, m_editVersion_3);
	DDX_Control(pDX, IDC_VERSION_2, m_editVersion_2);
	DDX_Control(pDX, IDC_VERSION_1, m_editVersion_1);
	DDX_Control(pDX, IDC_SUBJECT, m_editSubject);
	DDX_Control(pDX, IDC_INFO, m_editInfo);
	DDX_Control(pDX, IDC_COPYRIGHT, m_editCopyright);
	DDX_Control(pDX, IDC_AUTHOR, m_editAuthor);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CTabInfo, CPropertyPage)
	//{{AFX_MSG_MAP(CTabInfo)
	ON_WM_CREATE()
	ON_WM_DESTROY()
	ON_EN_KILLFOCUS(IDC_AUTHOR, OnKillFocusAuthor)
	ON_EN_KILLFOCUS(IDC_COPYRIGHT, OnKillFocusCopyright)
	ON_EN_KILLFOCUS(IDC_SUBJECT, OnKillFocusSubject)
	ON_EN_KILLFOCUS(IDC_INFO, OnKillFocusInfo)
	ON_EN_KILLFOCUS(IDC_VERSION_1, OnKillFocusVersion_1)
	ON_EN_KILLFOCUS(IDC_VERSION_2, OnKillFocusVersion_2)
	ON_EN_KILLFOCUS(IDC_VERSION_3, OnKillFocusVersion_3)
	ON_EN_KILLFOCUS(IDC_VERSION_4, OnKillFocusVersion_4)
	ON_BN_CLICKED(IDC_EDIT_GUID, OnEditGuid)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CTabInfo message handlers

/////////////////////////////////////////////////////////////////////////////
// CTabInfo::OnSetActive

BOOL CTabInfo::OnSetActive() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	UpdateControls();

	// Store active tab
	m_pPageManager->m_pIPropSheet->GetActivePage( &CSongPropPageManager::sm_nActiveTab );

	return CPropertyPage::OnSetActive();
}


/////////////////////////////////////////////////////////////////////////////
// CTabInfo::OnCreate

int CTabInfo::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Attach the window to the property page structure.
	// This has been done once already in the main application
	// since the main application owns the property sheet.
	// It needs to be done here so that the window handle can
	// be found in the DLLs handle map.
	if( !FromHandlePermanent( m_hWnd ) )
	{
		HWND hWnd = m_hWnd;
		m_hWnd = NULL;
		Attach( hWnd );
		m_fNeedToDetach = TRUE;
	}

	if( CPropertyPage::OnCreate(lpCreateStruct) == -1 )
	{
		return -1;
	}
	
	return 0;
}


/////////////////////////////////////////////////////////////////////////////
// CTabInfo::OnDestroy

void CTabInfo::OnDestroy() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Detach the window from the property page structure.
	// This will be done again by the main application since
	// it owns the property sheet.  It needs o be done here
	// so that the window handle can be removed from the
	// DLLs handle map.
	if( m_fNeedToDetach && m_hWnd )
	{
		HWND hWnd = m_hWnd;
		Detach();
		m_hWnd = hWnd;
	}

	CPropertyPage::OnDestroy();
}


/////////////////////////////////////////////////////////////////////////////
// CTabInfo::OnKillFocusAuthor

void CTabInfo::OnKillFocusAuthor() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pSong )
	{
		CString strAuthor;

		m_editAuthor.GetWindowText( strAuthor );

		// Strip leading and trailing spaces
		strAuthor.TrimRight();
		strAuthor.TrimLeft();

		if( strAuthor.Compare( m_pSong->m_strAuthor ) != 0 )
		{
			m_pSong->m_pUndoMgr->SaveState( m_pSong, theApp.m_hInstance, IDS_UNDO_SONG_AUTHOR );
			m_pSong->m_strAuthor = strAuthor;
			m_pSong->SetModified( TRUE );
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabInfo::OnKillFocusCopyright

void CTabInfo::OnKillFocusCopyright() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pSong )
	{
		CString strCopyright;

		m_editCopyright.GetWindowText( strCopyright );

		// Strip leading and trailing spaces
		strCopyright.TrimRight();
		strCopyright.TrimLeft();

		if( strCopyright.Compare( m_pSong->m_strCopyright ) != 0 )
		{
			m_pSong->m_pUndoMgr->SaveState( m_pSong, theApp.m_hInstance, IDS_UNDO_SONG_COPYRIGHT );
			m_pSong->m_strCopyright = strCopyright;
			m_pSong->SetModified( TRUE );
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabInfo::OnKillFocusSubject

void CTabInfo::OnKillFocusSubject() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pSong )
	{
		CString strSubject;

		m_editSubject.GetWindowText( strSubject );

		// Strip leading and trailing spaces
		strSubject.TrimRight();
		strSubject.TrimLeft();

		if( strSubject.Compare( m_pSong->m_strSubject ) != 0 )
		{
			m_pSong->m_pUndoMgr->SaveState( m_pSong, theApp.m_hInstance, IDS_UNDO_SONG_SUBJECT );
			m_pSong->m_strSubject = strSubject;
			m_pSong->SetModified( TRUE );
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabInfo::OnKillFocusInfo

void CTabInfo::OnKillFocusInfo() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pSong )
	{
		CString strInfo;

		m_editInfo.GetWindowText( strInfo );

		// Strip leading and trailing spaces
		strInfo.TrimRight();
		strInfo.TrimLeft();

		if( strInfo.Compare( m_pSong->m_strInfo ) != 0 )
		{
			m_pSong->m_pUndoMgr->SaveState( m_pSong, theApp.m_hInstance, IDS_UNDO_SONG_INFO );
			m_pSong->m_strInfo = strInfo;
			m_pSong->SetModified( TRUE );
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabInfo::OnKillFocusVersion_1

void CTabInfo::OnKillFocusVersion_1() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pSong )
	{
		CString strVersion_1;
		CString strSongVersion_1;

		m_editVersion_1.GetWindowText( strVersion_1 );

		// Strip leading and trailing spaces
		strVersion_1.TrimRight();
		strVersion_1.TrimLeft();

		if( strVersion_1.IsEmpty() )
		{
			CString strText;

			strText.Format( "%u", ((m_pSong->m_vVersion.dwVersionMS & 0xFFFF0000) >> 16) );
			m_editVersion_1.SetWindowText( strText );
		}
		else
		{
			strSongVersion_1.Format( "%u", ((m_pSong->m_vVersion.dwVersionMS & 0xFFFF0000) >> 16) );
			
			if( strVersion_1.Compare( strSongVersion_1 ) != 0 )
			{
				DWORD dwVersion_1 = _ttoi( strVersion_1 );
				dwVersion_1 = (dwVersion_1 & 0x0000FFFF) << 16;

				m_pSong->m_pUndoMgr->SaveState( m_pSong, theApp.m_hInstance, IDS_UNDO_SONG_VERSION );
				m_pSong->m_vVersion.dwVersionMS &= 0x0000FFFF;
				m_pSong->m_vVersion.dwVersionMS |= dwVersion_1;

				// Sync changes
				m_pSong->SetModified( TRUE );
				m_pSong->SyncChanges( SC_DIRECTMUSIC, 0, NULL );
			}
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabInfo::OnKillFocusVersion_2

void CTabInfo::OnKillFocusVersion_2() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pSong )
	{
		CString strVersion_2;
		CString strSongVersion_2;

		m_editVersion_2.GetWindowText( strVersion_2 );

		// Strip leading and trailing spaces
		strVersion_2.TrimRight();
		strVersion_2.TrimLeft();

		if( strVersion_2.IsEmpty() )
		{
			CString strText;

			strText.Format( "%u", (m_pSong->m_vVersion.dwVersionMS & 0x0000FFFF) );
			m_editVersion_2.SetWindowText( strText );
		}
		else
		{
			strSongVersion_2.Format( "%u", (m_pSong->m_vVersion.dwVersionMS & 0x0000FFFF) );
			
			if( strVersion_2.Compare( strSongVersion_2 ) != 0 )
			{
				DWORD dwVersion_2 = _ttoi( strVersion_2 );
				dwVersion_2 &= 0x0000FFFF;

				m_pSong->m_pUndoMgr->SaveState( m_pSong, theApp.m_hInstance, IDS_UNDO_SONG_VERSION );
				m_pSong->m_vVersion.dwVersionMS &= 0xFFFF0000;
				m_pSong->m_vVersion.dwVersionMS |= dwVersion_2;

				// Sync changes
				m_pSong->SetModified( TRUE );
				m_pSong->SyncChanges( SC_DIRECTMUSIC, 0, NULL );
			}
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabInfo::OnKillFocusVersion_3

void CTabInfo::OnKillFocusVersion_3() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pSong )
	{
		CString strVersion_3;
		CString strSongVersion_3;

		m_editVersion_3.GetWindowText( strVersion_3 );

		// Strip leading and trailing spaces
		strVersion_3.TrimRight();
		strVersion_3.TrimLeft();

		if( strVersion_3.IsEmpty() )
		{
			CString strText;

			strText.Format( "%u", ((m_pSong->m_vVersion.dwVersionLS & 0xFFFF0000) >> 16) );
			m_editVersion_3.SetWindowText( strText );
		}
		else
		{
			strSongVersion_3.Format( "%u", ((m_pSong->m_vVersion.dwVersionLS & 0xFFFF0000) >> 16) );
			
			if( strVersion_3.Compare( strSongVersion_3 ) != 0 )
			{
				DWORD dwVersion_3 = _ttoi( strVersion_3 );
				dwVersion_3 = (dwVersion_3 & 0x0000FFFF) << 16;

				m_pSong->m_pUndoMgr->SaveState( m_pSong, theApp.m_hInstance, IDS_UNDO_SONG_VERSION );
				m_pSong->m_vVersion.dwVersionLS &= 0x0000FFFF;
				m_pSong->m_vVersion.dwVersionLS |= dwVersion_3;

				// Sync changes
				m_pSong->SetModified( TRUE );
				m_pSong->SyncChanges( SC_DIRECTMUSIC, 0, NULL );
			}
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabInfo::OnKillFocusVersion_4

void CTabInfo::OnKillFocusVersion_4() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pSong )
	{
		CString strVersion_4;
		CString strSongVersion_4;

		m_editVersion_4.GetWindowText( strVersion_4 );

		// Strip leading and trailing spaces
		strVersion_4.TrimRight();
		strVersion_4.TrimLeft();

		if( strVersion_4.IsEmpty() )
		{
			CString strText;

			strText.Format( "%u", (m_pSong->m_vVersion.dwVersionLS & 0x0000FFFF) );
			m_editVersion_4.SetWindowText( strText );
		}
		else
		{
			strSongVersion_4.Format( "%u", (m_pSong->m_vVersion.dwVersionLS & 0x0000FFFF) );
			
			if( strVersion_4.Compare( strSongVersion_4 ) != 0 )
			{
				DWORD dwVersion_4 = _ttoi( strVersion_4 );
				dwVersion_4 &= 0x0000FFFF;

				m_pSong->m_pUndoMgr->SaveState( m_pSong, theApp.m_hInstance, IDS_UNDO_SONG_VERSION );
				m_pSong->m_vVersion.dwVersionLS &= 0xFFFF0000;
				m_pSong->m_vVersion.dwVersionLS |= dwVersion_4;

				// Sync changes
				m_pSong->SetModified( TRUE );
				m_pSong->SyncChanges( SC_DIRECTMUSIC, 0, NULL );
			}
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabInfo::OnEditGUID

void CTabInfo::OnEditGuid() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pSong )
	{
		CGuidDlg dlg;

		memcpy( &dlg.m_guid, &m_pSong->m_guidSong, sizeof(GUID) );

		if( dlg.DoModal() == IDOK )
		{
			m_pSong->m_pUndoMgr->SaveState( m_pSong, theApp.m_hInstance, IDS_UNDO_SONG_GUID );
			memcpy( &m_pSong->m_guidSong, &dlg.m_guid, sizeof(GUID) );

			// Sync changes
			m_pSong->SetModified( TRUE );
			m_pSong->SyncChanges( SC_DIRECTMUSIC, 0, NULL );

			// Notify connected nodes that Song GUID has changed
			theApp.m_pSongComponent->m_pIFramework8->NotifyNodes( m_pSong, DOCROOT_GuidChange, NULL );
		}

		m_btnGUID.SetFocus();
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SongDesigner\SourceSegment.cpp ===
// SourceSegment.cpp : implementation file
//

#include "stdafx.h"
#include "SongDesignerDLL.h"

#include "Song.h"
#include "SourceSegment.h"
#include <mmreg.h>
#include "TabSegmentDesign.h"
#include "TabSegmentRuntime.h"
#include <SegmentDesigner.h>
#include <dmusicf.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

// {19366A84-93B0-4e6d-ADAB-EE3CD4EFCD9E}
static const GUID GUID_SegmentPropPageManager = 
{ 0x19366a84, 0x93b0, 0x4e6d, { 0xad, 0xab, 0xee, 0x3c, 0xd4, 0xef, 0xcd, 0x9e } };

short CSegmentPropPageManager::sm_nActiveTab = 0;


//////////////////////////////////////////////////////////////////////
// CSegmentPropPageManager Construction/Destruction
//////////////////////////////////////////////////////////////////////

CSegmentPropPageManager::CSegmentPropPageManager()
{
    m_dwRef = 0;
	AddRef();

	m_pIPropPageObject = NULL;
	m_pIPropSheet = NULL;

	m_pTabDesign = NULL;
	m_pTabRuntime = NULL;
}

CSegmentPropPageManager::~CSegmentPropPageManager()
{
	RELEASE( m_pIPropSheet );

	if( m_pTabDesign )
	{
		delete m_pTabDesign;
	}

	if( m_pTabRuntime )
	{
		delete m_pTabRuntime;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CSegmentPropPageManager::RemoveCurrentObject

void CSegmentPropPageManager::RemoveCurrentObject( void )
{
	if( m_pIPropPageObject == NULL )
	{
		return;
	}

	m_pIPropPageObject->OnRemoveFromPageManager();
	m_pIPropPageObject = NULL;
}


/////////////////////////////////////////////////////////////////////////////
// CSegmentPropPageManager IUnknown implementation

HRESULT CSegmentPropPageManager::QueryInterface( REFIID riid, LPVOID FAR* ppvObj )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    if( ::IsEqualIID(riid, IID_IDMUSProdPropPageManager)
	||  ::IsEqualIID(riid, IID_IUnknown) )
    {
        AddRef();
        *ppvObj = (IDMUSProdPropPageManager *)this;
        return S_OK;
    }

    *ppvObj = NULL;
    return E_NOINTERFACE;
}

ULONG CSegmentPropPageManager::AddRef()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    return ++m_dwRef;
}

ULONG CSegmentPropPageManager::Release()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    ASSERT( m_dwRef != 0 );

    --m_dwRef;

    if( m_dwRef == 0 )
    {
        delete this;
        return 0;
    }

    return m_dwRef;
}


/////////////////////////////////////////////////////////////////////////////
// CSegmentPropPageManager IDMUSProdPropPageManager implementation

/////////////////////////////////////////////////////////////////////////////
// CSegmentPropPageManager IDMUSProdPropPageManager::GetPropertySheetTitle

HRESULT CSegmentPropPageManager::GetPropertySheetTitle( BSTR* pbstrTitle, BOOL* pfAddPropertiesText )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( (pbstrTitle == NULL)
	||  (pfAddPropertiesText == NULL) )
	{
		return E_POINTER;
	}

	*pfAddPropertiesText = TRUE;

	CString strTitle;
	strTitle.LoadString( IDS_SONG_TEXT );

	CSourceSegment *pSourceSegment;

	if( m_pIPropPageObject
	&& (SUCCEEDED (m_pIPropPageObject->GetData((void **)&pSourceSegment))) )
	{
		CString strName;
		BSTR bstrName;

		strTitle += _T(": ");

		// Add name of Song
		if( pSourceSegment->m_pSong )
		{
			if( SUCCEEDED ( pSourceSegment->m_pSong->GetNodeName( &bstrName ) ) )
			{
				strName = bstrName;
				::SysFreeString( bstrName );
		
				strTitle += strName;
				strTitle += _T(" - ");
			}
		}

		// Add Name of SourceSegment
		if( SUCCEEDED ( pSourceSegment->GetNodeName( &bstrName ) ) )
		{
			strName = bstrName;
			::SysFreeString( bstrName );
		
			strTitle += _T("'");
			strTitle += strName;
			strTitle += _T("' ");
		}

		// Add "Segment"
		CString strSegment;
		strSegment.LoadString( IDS_SEGMENT_TEXT );
		strTitle += strSegment;
	}

	*pbstrTitle = strTitle.AllocSysString();

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CSegmentPropPageManager IDMUSProdPropPageManager::GetPropertySheetPages

HRESULT CSegmentPropPageManager::GetPropertySheetPages( IDMUSProdPropSheet* pIPropSheet, LONG* hPropSheetPage[], short* pnNbrPages )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( (hPropSheetPage == NULL)
	||  (pnNbrPages == NULL) )
	{
		return E_POINTER;
	}

	if( pIPropSheet == NULL )
	{
		return E_INVALIDARG;
	}

	m_pIPropSheet = pIPropSheet;
	m_pIPropSheet->AddRef();

	hPropSheetPage[0] = NULL;
	*pnNbrPages = 0;

	HPROPSHEETPAGE hPage;
	short nNbrPages = 0;

	// Add Design tab
	m_pTabDesign = new CTabSegmentDesign( this );
	if( m_pTabDesign )
	{
		hPage = ::CreatePropertySheetPage( (LPPROPSHEETPAGE)&m_pTabDesign->m_psp );
		if( hPage )
		{
			hPropSheetPage[nNbrPages] = (LONG *)hPage;
			nNbrPages++;
		}			
	}

	// Add Runtime tab
	m_pTabRuntime = new CTabSegmentRuntime( this );
	if( m_pTabRuntime )
	{
		hPage = ::CreatePropertySheetPage( (LPPROPSHEETPAGE)&m_pTabRuntime->m_psp );
		if( hPage )
		{
			hPropSheetPage[nNbrPages] = (LONG *)hPage;
			nNbrPages++;
		}			
	}

	// Set number of pages
	*pnNbrPages = nNbrPages;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CSegmentPropPageManager IDMUSProdPropPageManager::OnRemoveFromPropertySheet

HRESULT CSegmentPropPageManager::OnRemoveFromPropertySheet()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pIPropSheet != NULL );
	m_pIPropSheet->GetActivePage( &CSegmentPropPageManager::sm_nActiveTab );

	RemoveCurrentObject();
	theApp.m_pIPageManager = NULL;

	Release();	// delete myself

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CSegmentPropPageManager IDMUSProdPropPageManager::SetObject

HRESULT CSegmentPropPageManager::SetObject( IDMUSProdPropPageObject* pINewPropPageObject )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( pINewPropPageObject == NULL )
	{
		return E_INVALIDARG;
	}
	if( m_pIPropPageObject == pINewPropPageObject )
	{
		return S_OK;
	}

	RemoveCurrentObject();

	m_pIPropPageObject = pINewPropPageObject;
//	m_pIPropPageObject->AddRef();		intentionally missing

	RefreshData();

	if( m_pIPropSheet )
	{
		m_pIPropSheet->RefreshTitle();
		m_pIPropSheet->RefreshActivePage();
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CSegmentPropPageManager IDMUSProdPropPageManager::RemoveObject

HRESULT CSegmentPropPageManager::RemoveObject( IDMUSProdPropPageObject* pIPropPageObject )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( (pIPropPageObject == NULL)
	||  (pIPropPageObject != m_pIPropPageObject) )
	{
		return E_INVALIDARG;
	}

	RemoveCurrentObject();
	RefreshData();

	if( m_pIPropSheet )
	{
		m_pIPropSheet->RefreshTitle();
		m_pIPropSheet->RefreshActivePage();
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CSegmentPropPageManager  IDMUSProdPropPageManager::IsEqualObject

HRESULT FAR EXPORT CSegmentPropPageManager::IsEqualObject( IDMUSProdPropPageObject* pIPropPageObject )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( pIPropPageObject == NULL )
	{
		return E_INVALIDARG;
	}

	if( pIPropPageObject == m_pIPropPageObject )
	{
		return S_OK;
	}

	return S_FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CSegmentPropPageManager IDMUSProdPropPageManager::RefreshData

HRESULT CSegmentPropPageManager::RefreshData( void )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CSourceSegment* pSourceSegment;
	
	if( m_pIPropPageObject == NULL )
	{
		pSourceSegment = NULL;
	}
	else if( FAILED ( m_pIPropPageObject->GetData( (void **)&pSourceSegment ) ) )
	{
		return E_FAIL;
	}

	// Make sure changes to current Container Object are processed in OnKillFocus
	// messages before setting the new Container Object
	CWnd* pWndHadFocus = CWnd::GetFocus();
	CWnd* pWnd = pWndHadFocus;
	CWnd* pWndParent = m_pTabDesign->GetParent();

	while( pWnd )
	{
		if( pWnd == pWndParent )
		{
			::SetFocus( NULL );
			break;
		}
		pWnd = pWnd->GetParent();
	}

	// Set Property tabs to display the new Container Object
	m_pTabDesign->SetSourceSegment( pSourceSegment);
	m_pTabRuntime->SetSourceSegment( pSourceSegment);

	// Restore focus
	if( pWndHadFocus
	&&  pWndHadFocus != CWnd::GetFocus() )
	{
		pWndHadFocus->SetFocus();
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CSegmentPropPageManager  IDMUSProdPropPageManager::IsEqualPageManagerGUID

HRESULT CSegmentPropPageManager::IsEqualPageManagerGUID( REFGUID rguidPageManager )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( ::IsEqualGUID(rguidPageManager, GUID_SegmentPropPageManager) )
	{
		return S_OK;
	}

	return S_FALSE;
}


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////
//	CSourceSegment Constructor/Destructor

CSourceSegment::CSourceSegment( CDirectMusicSong* pSong )
{
	m_dwRef = 0;
	AddRef();

	ASSERT( pSong != NULL );
	m_pSong = pSong;
//	m_pSong->AddRef();			intentionally missing

	m_pIDocRootNode = NULL;
	m_pIParentNode = NULL;

	SetFileReference( NULL );
//	m_dwFlagsDM = 0;
}

CSourceSegment::~CSourceSegment( void )
{
	// Remove Source Segment from property sheet
	IDMUSProdPropSheet* pIPropSheet;

	if( SUCCEEDED ( theApp.m_pSongComponent->m_pIFramework8->QueryInterface( IID_IDMUSProdPropSheet, (void**)&pIPropSheet ) ) )
	{
		pIPropSheet->RemovePageManagerByObject( this );
		RELEASE( pIPropSheet );
	}

	SetFileReference( NULL );
}


/////////////////////////////////////////////////////////////////////////////
// CSourceSegment::CreateRefNode

HRESULT CSourceSegment::CreateRefNode( IDMUSProdNode* pIDocRootNode, IDMUSProdNode** ppIRefNode )
{
	if( ppIRefNode == NULL )
	{
		return E_POINTER;
	}

	*ppIRefNode = NULL;

	if( pIDocRootNode == NULL )
	{
		return E_INVALIDARG;
	}

	HRESULT hr = E_FAIL;

	// Get DocRoot's NodeId
	GUID guidNodeId;
	if( SUCCEEDED ( pIDocRootNode->GetNodeId ( &guidNodeId ) ) )
	{
		if( ::IsEqualGUID( guidNodeId, GUID_SegmentNode ) )
		{
			// Now create the reference node
			IDMUSProdComponent* pIComponent;
			if( SUCCEEDED ( theApp.m_pSongComponent->m_pIFramework8->FindComponent( CLSID_SegmentComponent, &pIComponent ) ) )
			{
				IDMUSProdNode* pIRefNode;
				if( SUCCEEDED ( pIComponent->AllocReferenceNode( GUID_SegmentRefNode, &pIRefNode ) ) )
				{
					IDMUSProdReferenceNode* pIReferenceNode;
					if( SUCCEEDED ( pIRefNode->QueryInterface(IID_IDMUSProdReferenceNode, (void**)&pIReferenceNode ) ) )
					{
						if( SUCCEEDED ( pIReferenceNode->SetReferencedFile( pIDocRootNode ) ) )
						{
							*ppIRefNode = pIRefNode;
							pIRefNode->AddRef();
							hr = S_OK;
						}

						RELEASE( pIReferenceNode );
					}

					RELEASE( pIRefNode );
				}

				RELEASE( pIComponent );
			}
		}
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CSourceSegment IUnknown implementation

HRESULT CSourceSegment::QueryInterface( REFIID riid, LPVOID FAR* ppvObj )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    if( ::IsEqualIID(riid, IID_IDMUSProdNode)
	||  ::IsEqualIID(riid, IID_IUnknown) )
    {
        AddRef();
        *ppvObj = (IDMUSProdNode *)this;
        return S_OK;
    }
    else if( ::IsEqualIID(riid, IID_IDMUSProdPropPageObject) )
    {
        AddRef();
        *ppvObj = (IDMUSProdPropPageObject *)this;
        return S_OK;
    }

    *ppvObj = NULL;
    return E_NOINTERFACE;
}

ULONG CSourceSegment::AddRef()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	AfxOleLockApp(); 
    return ++m_dwRef;
}

ULONG CSourceSegment::Release()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    ASSERT( m_dwRef != 0 );

	AfxOleUnlockApp(); 
    --m_dwRef;

    if( m_dwRef == 0 )
    {
        delete this;
        return 0;
    }

    return m_dwRef;
}


/////////////////////////////////////////////////////////////////////////////
// CSourceSegment IDMUSProdNode implementation

/////////////////////////////////////////////////////////////////////////////
// CSourceSegment IDMUSProdNode::GetNodeImageIndex

HRESULT CSourceSegment::GetNodeImageIndex( short* pnFirstImage )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_FileRef.pIRefNode == NULL )
	{
		// Will happen while waiting for FRAMEWORK_FileLoadFinished notification
		return E_UNEXPECTED;
	}

	return( m_FileRef.pIRefNode->GetNodeImageIndex(pnFirstImage) );
}


/////////////////////////////////////////////////////////////////////////////
// CSourceSegment IDMUSProdNode::GetFirstChild

HRESULT CSourceSegment::GetFirstChild( IDMUSProdNode** ppIFirstChildNode )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(ppIFirstChildNode);

    return E_NOTIMPL;	// SourceSegment node does not have children
}


/////////////////////////////////////////////////////////////////////////////
// CSourceSegment IDMUSProdNode::GetNextChild

HRESULT CSourceSegment::GetNextChild( IDMUSProdNode* pIChildNode, IDMUSProdNode** ppINextChildNode )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(pIChildNode);
	UNREFERENCED_PARAMETER(ppINextChildNode);

    return E_NOTIMPL;	// SourceSegment node does not have children
}


/////////////////////////////////////////////////////////////////////////////
// CSourceSegment IDMUSProdNode::GetComponent

HRESULT CSourceSegment::GetComponent( IDMUSProdComponent** ppIComponent )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( theApp.m_pSongComponent != NULL );

	return theApp.m_pSongComponent->QueryInterface( IID_IDMUSProdComponent, (void**)ppIComponent );
}


/////////////////////////////////////////////////////////////////////////////
// CSourceSegment IDMUSProdNode::GetDocRootNode

HRESULT CSourceSegment::GetDocRootNode( IDMUSProdNode** ppIDocRootNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pIDocRootNode )
	{
		m_pIDocRootNode->AddRef();
		*ppIDocRootNode = m_pIDocRootNode;
		return S_OK;
	}

	*ppIDocRootNode = NULL;
	return E_FAIL;
}


/////////////////////////////////////////////////////////////////////////////
// CSourceSegment IDMUSProdNode::SetDocRootNode

HRESULT CSourceSegment::SetDocRootNode( IDMUSProdNode* pIDocRootNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( pIDocRootNode != NULL );

	m_pIDocRootNode = pIDocRootNode;
//	m_pIDocRootNode->AddRef();		intentionally missing

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CSourceSegment IDMUSProdNode::GetParentNode

HRESULT CSourceSegment::GetParentNode( IDMUSProdNode** ppIParentNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pIParentNode != NULL );

	m_pIParentNode->AddRef();
	*ppIParentNode = m_pIParentNode;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CSourceSegment IDMUSProdNode::SetParentNode

HRESULT CSourceSegment::SetParentNode( IDMUSProdNode* pIParentNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( pIParentNode != NULL );

	m_pIParentNode = pIParentNode;
//	m_pIParentNode->AddRef();		intentionally missing

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CSourceSegment IDMUSProdNode::GetNodeId

HRESULT CSourceSegment::GetNodeId( GUID* pguid )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( pguid == NULL )
	{
		return E_POINTER;
	}

	*pguid = GUID_Song_SourceSegmentNode;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CSourceSegment IDMUSProdNode::GetNodeName

HRESULT CSourceSegment::GetNodeName( BSTR* pbstrName )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	HRESULT hr = E_FAIL;

	if( m_FileRef.pIRefNode == NULL )
	{
		TCHAR achNoObject[MID_BUFFER];

		::LoadString( theApp.m_hInstance, IDS_EMPTY_TEXT, achNoObject, MID_BUFFER );
		CString strNoObject = achNoObject;
		*pbstrName = strNoObject.AllocSysString();
		hr = S_OK;
	}
	else
	{
		hr = m_FileRef.pIRefNode->GetNodeName( pbstrName );
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CSourceSegment IDMUSProdNode::GetNodeNameMaxLength

HRESULT CSourceSegment::GetNodeNameMaxLength( short* pnMaxLength )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Can't rename Source Segment
	*pnMaxLength = -1;				

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CSourceSegment IDMUSProdNode::ValidateNodeName

HRESULT CSourceSegment::ValidateNodeName( BSTR bstrName )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	::SysFreeString( bstrName );

	// Can't rename Source Segment
	ASSERT( 0 );	// This should not happen
	return S_FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CSourceSegment IDMUSProdNode::SetNodeName

HRESULT CSourceSegment::SetNodeName( BSTR bstrName )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	::SysFreeString( bstrName );

	// Can't rename Source Segment
	ASSERT( 0 );	// This should not happen
	return S_FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CSourceSegment IDMUSProdNode::GetNodeListInfo

HRESULT CSourceSegment::GetNodeListInfo( DMUSProdListInfo* pListInfo )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_FileRef.pIRefNode != NULL );
	if( m_FileRef.pIRefNode == NULL )
	{
		return E_UNEXPECTED;
	}

	return( m_FileRef.pIRefNode->GetNodeListInfo(pListInfo) );
}


/////////////////////////////////////////////////////////////////////////////
// CSourceSegment IDMUSProdNode::GetEditorClsId

HRESULT CSourceSegment::GetEditorClsId( CLSID* pClsId )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
//
//	ASSERT( m_FileRef.pIRefNode != NULL );
//	if( m_FileRef.pIRefNode == NULL )
//	{
//		return E_UNEXPECTED;
//	}
//
//	return( m_FileRef.pIRefNode->GetEditorClsId(pClsId) );
	return E_FAIL;
}


/////////////////////////////////////////////////////////////////////////////
// CSourceSegment IDMUSProdNode::GetEditorTitle

HRESULT CSourceSegment::GetEditorTitle( BSTR* pbstrTitle )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_FileRef.pIRefNode != NULL );
	if( m_FileRef.pIRefNode == NULL )
	{
		return E_UNEXPECTED;
	}

	return( m_FileRef.pIRefNode->GetEditorTitle(pbstrTitle) );
}


/////////////////////////////////////////////////////////////////////////////
// CSourceSegment IDMUSProdNode::GetEditorWindow

HRESULT CSourceSegment::GetEditorWindow( HWND* hWndEditor )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_FileRef.pIRefNode  )
	{
		return( m_FileRef.pIRefNode->GetEditorWindow(hWndEditor) );
	}

	return E_FAIL;
}


/////////////////////////////////////////////////////////////////////////////
// CSourceSegment IDMUSProdNode::SetEditorWindow

HRESULT CSourceSegment::SetEditorWindow( HWND hWndEditor )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_FileRef.pIRefNode != NULL );
	if( m_FileRef.pIRefNode == NULL )
	{
		return E_UNEXPECTED;
	}

	return( m_FileRef.pIRefNode->SetEditorWindow(hWndEditor) );
}


/////////////////////////////////////////////////////////////////////////////
// CSourceSegment IDMUSProdNode::UseOpenCloseImages

HRESULT CSourceSegment::UseOpenCloseImages( BOOL* pfUseOpenCloseImages )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	*pfUseOpenCloseImages = FALSE;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CSourceSegment IDMUSProdNode::GetRightClickMenuId

HRESULT CSourceSegment::GetRightClickMenuId( HINSTANCE* phInstance, UINT* pnMenuId )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	*phInstance = theApp.m_hInstance;
	*pnMenuId = IDM_SOURCE_SEGMENT_NODE_RMENU;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CSourceSegment IDMUSProdNode::OnRightClickMenuInit

HRESULT CSourceSegment::OnRightClickMenuInit( HMENU hMenu )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CMenu menu;

	if( menu.Attach(hMenu) )
	{
		// IDM_DELETE
		if( CanDelete() == S_OK )
		{
			menu.EnableMenuItem( IDM_DELETE, (MF_ENABLED | MF_BYCOMMAND) );
		}
		else
		{
			menu.EnableMenuItem( IDM_DELETE, (MF_GRAYED | MF_BYCOMMAND) );
		}

		menu.Detach();
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CSourceSegment IDMUSProdNode::OnRightClickMenuSelect

HRESULT CSourceSegment::OnRightClickMenuSelect( long lCommandId )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	switch( lCommandId )
	{
		case IDM_LOCATE:
			if( m_FileRef.pIDocRootNode )
			{
				theApp.m_pSongComponent->m_pIFramework8->SetSelectedNode( m_FileRef.pIDocRootNode );
			}
			break;

		case IDM_DELETE:
			DeleteNode( TRUE );
			break;

		case IDM_PROPERTIES:
			OnShowProperties();
			break;

		default:
			return E_FAIL;
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CSourceSegment IDMUSProdNode::DeleteChildNode

HRESULT CSourceSegment::DeleteChildNode( IDMUSProdNode* pIChildNode, BOOL fPromptUser )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(pIChildNode);
	UNREFERENCED_PARAMETER(fPromptUser);

	return E_NOTIMPL;	// SourceSegment nodes do not have children
}


/////////////////////////////////////////////////////////////////////////////
// CSourceSegment IDMUSProdNode::InsertChildNode

HRESULT CSourceSegment::InsertChildNode( IDMUSProdNode* pIChildNode )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(pIChildNode);

	return E_NOTIMPL;	// SourceSegment nodes do not have children
}


/////////////////////////////////////////////////////////////////////////////
// CSourceSegment IDMUSProdNode::DeleteNode

HRESULT CSourceSegment::DeleteNode( BOOL fPromptUser )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Let our parent delete us
	return m_pIParentNode->DeleteChildNode( this, fPromptUser );
}


/////////////////////////////////////////////////////////////////////////////
// CSourceSegment IDMUSProdNode::OnNodeSelChanged

HRESULT CSourceSegment::OnNodeSelChanged( BOOL fSelected )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(fSelected);

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CSourceSegment IDMUSProdNode::CreateDataObject

HRESULT CSourceSegment::CreateDataObject( IDataObject** ppIDataObject )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( ppIDataObject == NULL )
	{
		return E_POINTER;
	}

	*ppIDataObject = NULL;

	if( m_FileRef.pIRefNode )
	{
		return m_FileRef.pIRefNode->CreateDataObject( ppIDataObject );
	}

	return E_FAIL;
}


/////////////////////////////////////////////////////////////////////////////
// CSourceSegment IDMUSProdNode::CanCut

HRESULT CSourceSegment::CanCut( void )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
 
	return CanDelete();
}


/////////////////////////////////////////////////////////////////////////////
// CSourceSegment IDMUSProdNode::CanCopy

HRESULT CSourceSegment::CanCopy( void )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);
 
	if( m_FileRef.pIRefNode )
	{
		return m_FileRef.pIRefNode->CanCopy();	
	}

	return S_FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CSourceSegment IDMUSProdNode::CanDelete

HRESULT CSourceSegment::CanDelete( void )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pIParentNode != NULL );

	return m_pIParentNode->CanDeleteChildNode( this );
}


/////////////////////////////////////////////////////////////////////////////
// CSourceSegment IDMUSProdNode::CanDeleteChildNode

HRESULT CSourceSegment::CanDeleteChildNode( IDMUSProdNode* pIChildNode )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(pIChildNode);

	ASSERT( 0 );

	return E_NOTIMPL;	// Container Reference nodes do not have children
}


/////////////////////////////////////////////////////////////////////////////
// CSourceSegment IDMUSProdNode::CanPasteFromData

HRESULT CSourceSegment::CanPasteFromData( IDataObject* pIDataObject, BOOL* pfWillSetReference )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Let parent decide whether it wants to paste
	return m_pIParentNode->CanChildPasteFromData( pIDataObject, this, pfWillSetReference );
}


/////////////////////////////////////////////////////////////////////////////
// CSourceSegment IDMUSProdNode::PasteFromData

HRESULT CSourceSegment::PasteFromData( IDataObject* pIDataObject )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Let parent handle pasting of Container
	return m_pIParentNode->ChildPasteFromData( pIDataObject, this );
}


/////////////////////////////////////////////////////////////////////////////
// CSourceSegment IDMUSProdNode::CanChildPasteFromData

HRESULT CSourceSegment::CanChildPasteFromData( IDataObject* pIDataObject, IDMUSProdNode* pIChildNode,
												 BOOL* pfWillSetReference )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(pIDataObject);
	UNREFERENCED_PARAMETER(pIChildNode);
	UNREFERENCED_PARAMETER(pfWillSetReference);

	return E_NOTIMPL;			// Container Reference nodes do not have children
}


/////////////////////////////////////////////////////////////////////////////
// CSourceSegment IDMUSProdNode::ChildPasteFromData

HRESULT CSourceSegment::ChildPasteFromData( IDataObject* pIDataObject, IDMUSProdNode* pIChildNode )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(pIDataObject);
	UNREFERENCED_PARAMETER(pIChildNode);

	return E_NOTIMPL;			// Container Reference nodes do not have children
}


/////////////////////////////////////////////////////////////////////////////
// CSourceSegment IDMUSProdNode::GetObject

HRESULT CSourceSegment::GetObject( REFCLSID rclsid, REFIID riid, void** ppvObject )
{
//	AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(rclsid);
	UNREFERENCED_PARAMETER(riid);
	UNREFERENCED_PARAMETER(ppvObject);

	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CSourceSegment IDMUSProdPropPageObject implementation

/////////////////////////////////////////////////////////////////////////////
// CSourceSegment IDMUSProdPropPageObject::GetData

HRESULT CSourceSegment::GetData( void** ppData )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( ppData == NULL )
	{
		return E_POINTER;
	}

	*ppData = this;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CSourceSegment IDMUSProdPropPageObject::SetData

HRESULT CSourceSegment::SetData( void* pData )
{
	//AFX_MANAGE_STATE(_afxModuleAddrThis);
	UNREFERENCED_PARAMETER(pData);

	return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// CSourceSegment IDMUSProdPropPageObject::OnShowProperties

HRESULT CSourceSegment::OnShowProperties( void )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( theApp.m_pSongComponent != NULL );
	ASSERT( theApp.m_pSongComponent->m_pIFramework8 != NULL );

	// Get the SourceSegment page manager
	CSegmentPropPageManager* pPageManager;

	if( theApp.m_pIPageManager
	&&  theApp.m_pIPageManager->IsEqualPageManagerGUID( GUID_SegmentPropPageManager ) == S_OK )
	{
		pPageManager = (CSegmentPropPageManager *)theApp.m_pIPageManager;
	}
	else
	{
		pPageManager = new CSegmentPropPageManager();
	}

	if( pPageManager == NULL )
	{
		return E_FAIL;
	}

	// Show the SourceSegment's properties
	IDMUSProdPropSheet* pIPropSheet;

	if( SUCCEEDED ( theApp.m_pSongComponent->m_pIFramework8->QueryInterface( IID_IDMUSProdPropSheet, (void**)&pIPropSheet ) ) )
	{
		short nActiveTab = CSegmentPropPageManager::sm_nActiveTab;

		if( SUCCEEDED ( pIPropSheet->SetPageManager(pPageManager) ) )
		{
			theApp.m_pIPageManager = pPageManager;
			pPageManager->SetObject( this );
			pIPropSheet->SetActivePage( nActiveTab ); 
		}

		pIPropSheet->Show( TRUE );
		RELEASE( pIPropSheet );
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CSourceSegment IDMUSProdPropPageObject::OnRemoveFromPageManager

HRESULT CSourceSegment::OnRemoveFromPageManager( void )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	return S_OK;
}


//////////////////////////////////////////////////////////////////////
//	CSourceSegment::ClearListInfo

void CSourceSegment::ClearListInfo()
{
	HINSTANCE hInstance = AfxGetResourceHandle();
	AfxSetResourceHandle( theApp.m_hInstance );

	m_FileRef.li.pIProject = NULL;

	m_FileRef.li.strProjectName.LoadString( IDS_EMPTY_TEXT );
	m_FileRef.li.strName.LoadString( IDS_EMPTY_TEXT );
	m_FileRef.li.strDescriptor.LoadString( IDS_EMPTY_TEXT );

	memset( &m_FileRef.li.guidFile, 0, sizeof(GUID) );

	AfxSetResourceHandle( hInstance );
}


/////////////////////////////////////////////////////////////////////////////
// CSourceSegment GetSegmentDocRootNode

HRESULT CSourceSegment::GetSegmentDocRootNode( IDMUSProdNode** ppISegmentDocRootNode )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_FileRef.pIDocRootNode )
	{
		m_FileRef.pIDocRootNode->AddRef();
		*ppISegmentDocRootNode = m_FileRef.pIDocRootNode;
		return S_OK;
	}

	*ppISegmentDocRootNode = NULL;
	return E_FAIL;
}


//////////////////////////////////////////////////////////////////////
//	CSourceSegment::SetFileReference

HRESULT CSourceSegment::SetFileReference( IDMUSProdNode* pINewDocRootNode )
{
	ASSERT( theApp.m_pSongComponent->m_pIFramework8 != NULL );

	HRESULT hr = S_OK;

	// Clean up old file reference
	if( m_FileRef.pIDocRootNode )
	{
		// Turn off notifications for this node
		if( m_FileRef.fRemoveNotify )
		{
			ASSERT( m_pSong != NULL );
			if( m_pSong )
			{
				hr = theApp.m_pSongComponent->m_pIFramework8->RemoveFromNotifyList( m_FileRef.pIDocRootNode, m_pSong );
			}
		}
	}

	// Initialize pertinent fields
	RELEASE( m_FileRef.pIDocRootNode );
	RELEASE( m_FileRef.pIRefNode );
	m_FileRef.fRemoveNotify = FALSE;
	ClearListInfo();

	// Set DocRoot of new file reference
	if( pINewDocRootNode )
	{
		IDMUSProdNode* pINewRefNode;

		hr = CreateRefNode( pINewDocRootNode, &pINewRefNode );
		if( SUCCEEDED ( hr ) )
		{
			// Turn on notifications
			ASSERT( m_pSong != NULL );
			if( m_pSong )
			{
				ASSERT( m_FileRef.fRemoveNotify == FALSE );
				hr = theApp.m_pSongComponent->m_pIFramework8->AddToNotifyList( pINewDocRootNode, m_pSong );
				if( SUCCEEDED ( hr ) )
				{
					m_FileRef.fRemoveNotify = TRUE;
				}
			}
			
			// Update file reference's DocRoot member variable
			m_FileRef.pIDocRootNode = pINewDocRootNode;
			m_FileRef.pIDocRootNode->AddRef();
			
			// Update file reference's RefNode member variable
			m_FileRef.pIRefNode = pINewRefNode;
//			m_FileRef.pIRefNode->AddRef();		Already AddRef'd by CreateRefNode()

			// Update file reference's list info
			SyncListInfo();
		}
	}

	return hr;
}


//////////////////////////////////////////////////////////////////////
//	CSourceSegment::SetFileReference

HRESULT CSourceSegment::SetFileReference( GUID guidFile )
{
	ASSERT( theApp.m_pSongComponent->m_pIFramework8 != NULL );

	HRESULT hr = E_FAIL;

	IDMUSProdNode* pIDocRootNode;
	if( SUCCEEDED ( theApp.m_pSongComponent->m_pIFramework8->FindDocRootNodeByFileGUID( guidFile, &pIDocRootNode ) ) )
	{
		hr = SetFileReference( pIDocRootNode );

		RELEASE( pIDocRootNode );
	}

	return hr;
}


//////////////////////////////////////////////////////////////////////
//	CSourceSegment::SyncListInfo

HRESULT CSourceSegment::SyncListInfo( void )
{
	ASSERT( theApp.m_pSongComponent->m_pIFramework8 != NULL );

	HRESULT hr = S_OK;

	ClearListInfo();

	if( m_FileRef.pIDocRootNode )
	{
		DMUSProdListInfo ListInfo;
		ZeroMemory( &ListInfo, sizeof(ListInfo) );
		ListInfo.wSize = sizeof(ListInfo);

		hr = m_FileRef.pIDocRootNode->GetNodeListInfo ( &ListInfo );
		if( SUCCEEDED ( hr ) )
		{
			IDMUSProdProject* pIProject;

			if( ListInfo.bstrName )
			{
				m_FileRef.li.strName = ListInfo.bstrName;
				::SysFreeString( ListInfo.bstrName );
			}
			if( ListInfo.bstrDescriptor )
			{
				m_FileRef.li.strDescriptor = ListInfo.bstrDescriptor;
				::SysFreeString( ListInfo.bstrDescriptor );
			}
			if( SUCCEEDED ( theApp.m_pSongComponent->m_pIFramework8->FindProject( m_FileRef.pIDocRootNode, &pIProject ) ) )
			{
				BSTR bstrProjectName;

				m_FileRef.li.pIProject = pIProject;
//				m_FileRef.li.pIProject->AddRef();		intentionally missing

				if( SUCCEEDED ( pIProject->GetName( &bstrProjectName ) ) )
				{
					m_FileRef.li.strProjectName = bstrProjectName;
					::SysFreeString( bstrProjectName );
				}

				pIProject->Release();
			}

		    theApp.m_pSongComponent->m_pIFramework8->GetNodeFileGUID( m_FileRef.pIDocRootNode, &m_FileRef.li.guidFile );
		}
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CSourceSegment Load

HRESULT CSourceSegment::Load( IDMUSProdRIFFStream* pIRiffStream, MMCKINFO* pckMain, BOOL* pfReference )
{
    IStream*       pIStream;
	MMCKINFO	   ck;
	DWORD		   dwByteCount;
	DWORD		   dwSize;
	DWORD		   dwCurrentFilePos;
	DWORD		   dwStartFilePos;
    HRESULT        hr = S_OK;
    HRESULT        hrReference = S_OK;

	CString		   strSourceSegmentName;
	IDMUSProdNode* pIDocRootNode = NULL;
	BOOL		   fWasReference = FALSE;
	short		   nReferenceFlagUI = -1;

	ASSERT( theApp.m_pSongComponent != NULL );

	if( pfReference == NULL )
	{
		ASSERT( 0 );
		return E_POINTER;
	}

    pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

    dwCurrentFilePos = StreamTell( pIStream );
    dwStartFilePos = dwCurrentFilePos;

    while( pIRiffStream->Descend( &ck, pckMain, 0 ) == 0 )
	{
        switch( ck.ckid )
		{
			case DMUS_FOURCC_SOURCE_SEGMENT_UI_CHUNK:
			{
			    ioSourceSegmentUI iSourceSegmentUI;

				dwSize = min( ck.cksize, sizeof( ioSourceSegmentUI ) );
				hr = pIStream->Read( &iSourceSegmentUI, dwSize, &dwByteCount );
				if( FAILED( hr )
				||  dwByteCount != dwSize )
				{
					hr = E_FAIL;
					goto ON_ERROR;
				}

				if( iSourceSegmentUI.wFlags & SSUI_REFERENCE )
				{
					nReferenceFlagUI = TRUE;
				}
				else
				{
					nReferenceFlagUI = FALSE;
				}
				break;
			}

			case FOURCC_DMUSPROD_FILEREF:
			{
				IDMUSProdFileRefChunk* pIFileRef;

				fWasReference = TRUE;
				hr = theApp.m_pSongComponent->m_pIFramework8->QueryInterface( IID_IDMUSProdFileRefChunk, (void**) &pIFileRef );
				if( FAILED ( hr ) )
				{
					goto ON_ERROR;
				}
				StreamSeek( pIStream, dwCurrentFilePos, 0 );
				hrReference = pIFileRef->LoadRefChunk( pIStream, &pIDocRootNode );
				if( hrReference != S_OK )
				{
					if( hrReference == E_PENDING )
					{
						IDMUSProdNotifySink* pINotifySink;
						if( SUCCEEDED ( m_pSong->QueryInterface( IID_IDMUSProdNotifySink, (void**)&pINotifySink ) ) )
						{
							// Store File's GUID so we can resolve reference in our handler 
							// for the FRAMEWORK_FileLoadFinished notification
							StreamSeek( pIStream, dwCurrentFilePos, 0 );
							pIFileRef->ResolveWhenLoadFinished( pIStream, pINotifySink, &m_FileRef.li.guidFile );
							RELEASE( pINotifySink );
						}
					}
				}
				RELEASE( pIFileRef );
				break;
			}

			case FOURCC_LIST:
				switch( ck.fccType )
				{
					case DMUS_FOURCC_REF_LIST:
					{
						MMCKINFO ckName;

						fWasReference = TRUE;
						ckName.ckid = DMUS_FOURCC_NAME_CHUNK;
						if( pIRiffStream->Descend( &ckName, NULL, MMIO_FINDCHUNK ) == 0 )
						{
							// Store SourceSegment name
							ReadMBSfromWCS( pIStream, ckName.cksize, &strSourceSegmentName );
						}
						break;
					}
				}
				break;
        }

        pIRiffStream->Ascend( &ck, 0 );
	    dwCurrentFilePos = StreamTell( pIStream );
    }

	if( pIDocRootNode == NULL
	&&  hrReference != E_PENDING )
	{
		if( fWasReference == TRUE )
		{
			// Resolve reference
			if( !(strSourceSegmentName.IsEmpty()) ) 
			{
				// Framework could not resolve file reference
				// so we will ask user to help
				hrReference = FindSegmentFile( strSourceSegmentName, pIStream, &pIDocRootNode );
				if( SUCCEEDED ( hrReference ) )
				{
					if( m_pSong->IsSourceSegmentInSong( pIDocRootNode ) )
					{
						// Already in SourceSegment list
						// so we do not want another reference to the DocRoot
						RELEASE( pIDocRootNode );
					}
					else
					{
						m_pSong->SetModified( TRUE );
					}
				}
			}
		}
		else
		{
			// Load embedded file
			StreamSeek( pIStream, dwStartFilePos, 0 );

			MMCKINFO ckEmbeddedFile;
			ckEmbeddedFile.ckid = FOURCC_RIFF;
			ckEmbeddedFile.fccType = DMUS_FOURCC_SEGMENT_FORM;

			if( pIRiffStream->Descend( &ckEmbeddedFile, pckMain, MMIO_FINDRIFF ) == 0 )
			{
				StreamSeek( pIStream, -12, STREAM_SEEK_CUR );
				pIDocRootNode = theApp.m_pSongComponent->LoadEmbeddedSegment( pIStream );
			}
		}
	}

	if( pIDocRootNode == NULL
	&&  hrReference == E_PENDING )
	{
		if( nReferenceFlagUI == -1 )
		{
			// Did not encounter UI chunk
			// so preserve manner SourceSegment was stored in the container file
			*pfReference = fWasReference;
		}
		else
		{
			*pfReference = nReferenceFlagUI;
		}
	}
	else if( pIDocRootNode )
	{
		hr = SetFileReference( pIDocRootNode );
		pIDocRootNode->Release();

		if( FAILED ( hr ) )
		{
			goto ON_ERROR;
		}

		if( nReferenceFlagUI == -1 )
		{
			// Did not encounter UI chunk
			// so preserve manner SourceSegment was stored in the container file
			*pfReference = fWasReference;
		}
		else
		{
			*pfReference = nReferenceFlagUI;
		}
	}
	else
	{
		hr = S_FALSE;
	}

ON_ERROR:
    RELEASE( pIStream );
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CSourceSegment::SaveDMRef

HRESULT CSourceSegment::SaveDMRef( IDMUSProdRIFFStream* pIRiffStream,
									 IDMUSProdNode* pIDocRootNode, DMUS_OBJECTDESC* pdmusObjectDesc, WhichLoader whichLoader )
{
	IDMUSProdLoaderRefChunk* pIRefChunkLoader;

	ASSERT( theApp.m_pSongComponent->m_pIFramework8 != NULL );
	if( theApp.m_pSongComponent->m_pIFramework8 == NULL )
	{
		return E_FAIL;
	}

	HRESULT hr = E_FAIL;

    IStream* pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

	if( SUCCEEDED( theApp.m_pSongComponent->m_pIFramework8->QueryInterface( IID_IDMUSProdLoaderRefChunk, (void**)&pIRefChunkLoader ) ) )
	{
		if( pIRefChunkLoader )
		{
			switch( whichLoader )
			{
				case WL_DIRECTMUSIC:
				case WL_PRODUCER:
					hr = pIRefChunkLoader->SaveRefChunkForLoader( pIStream,
																  pIDocRootNode,
																  pdmusObjectDesc->guidClass,
																  pdmusObjectDesc,
																  whichLoader );
					break;
			}

			pIRefChunkLoader->Release();
		}
	}

	pIStream->Release();
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CSourceSegment::SaveProducerRef

HRESULT CSourceSegment::SaveProducerRef( IDMUSProdRIFFStream* pIRiffStream, IDMUSProdNode* pIDocRootNode )
{
	IDMUSProdFileRefChunk* pIFileRefChunk;

	ASSERT( theApp.m_pSongComponent->m_pIFramework8 != NULL );
	if( theApp.m_pSongComponent->m_pIFramework8 == NULL )
	{
		return E_FAIL;
	}

    IStream* pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

	if ( SUCCEEDED ( theApp.m_pSongComponent->m_pIFramework8->QueryInterface( IID_IDMUSProdFileRefChunk, (void**)&pIFileRefChunk ) ) )
	{
		pIFileRefChunk->SaveRefChunk( pIStream, pIDocRootNode );
		pIFileRefChunk->Release();
	}

	pIStream->Release();
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CSourceSegment Save

HRESULT CSourceSegment::Save( IDMUSProdRIFFStream* pIRiffStream, BOOL fSaveReference )
{
	IStream* pIStream;
	HRESULT hr;
	MMCKINFO ckMain;
	MMCKINFO ck;
	DWORD dwBytesWritten;
	BOOL fIsEmbeddedInStream = TRUE;

	if( m_FileRef.pIDocRootNode == NULL )
	{
		// Will happen while waiting for FRAMEWORK_FileLoadFinished notification
		return SaveSourceSegmentPendingLoad( pIRiffStream, fSaveReference );
	}

    pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

	DMUSProdStreamInfo StreamInfo;
	StreamInfo.ftFileType = FT_RUNTIME;
	StreamInfo.guidDataFormat = GUID_CurrentVersion;
	StreamInfo.pITargetDirectoryNode = NULL;

	// Get additional stream information
	IDMUSProdPersistInfo* pIPersistInfo;
	if( FAILED ( pIStream->QueryInterface( IID_IDMUSProdPersistInfo, (void **)&pIPersistInfo ) ) )
	{
		ASSERT( 0 );
		pIPersistInfo = NULL;
	}
	if( pIPersistInfo )
	{
		pIPersistInfo->GetStreamInfo( &StreamInfo );
	}

	// Initialize the DMUS_OBJECTDESC structure
	DMUS_OBJECTDESC dmusObjectDesc;
	memset( &dmusObjectDesc, 0, sizeof(DMUS_OBJECTDESC) );
	dmusObjectDesc.dwSize = sizeof(DMUS_OBJECTDESC);
	
	// Prepare the DMUS_OBJECTDESC structure
	{
		// Get DocRoot's DocType
		IDMUSProdDocType *pIDocType;
		hr = theApp.m_pSongComponent->m_pIFramework8->FindDocTypeByNodeId( GUID_SegmentNode, &pIDocType );
		if( FAILED( hr ) )
		{
			goto ON_ERROR;
		}

		IDMUSProdDocType8 *pIDocType8;
		hr = pIDocType->QueryInterface( IID_IDMUSProdDocType8, (void**)&pIDocType8 );
		RELEASE( pIDocType );
		if( FAILED( hr ) )
		{
			goto ON_ERROR;
		}

		hr = pIDocType8->GetObjectDescriptorFromNode( m_FileRef.pIDocRootNode, &dmusObjectDesc );
		RELEASE( pIDocType8 );
		if( FAILED( hr ) )
		{
			goto ON_ERROR;
		}

		if( !(dmusObjectDesc.dwValidData & DMUS_OBJ_CLASS) )
		{
			hr = E_UNEXPECTED;
			goto ON_ERROR;
		}
	}

	// Write DMUS_FOURCC_SONGSEGMENT_LIST header
	ckMain.fccType = DMUS_FOURCC_SONGSEGMENT_LIST;
	if( pIRiffStream->CreateChunk(&ckMain, MMIO_CREATELIST) != 0 )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

	// Write DMUS_FOURCC_SOURCE_SEGMENT_UI_CHUNK
	if( StreamInfo.ftFileType != FT_RUNTIME )
	{
		ioSourceSegmentUI oSourceSegmentUI;

		// Write chunk header
		ck.ckid = DMUS_FOURCC_SOURCE_SEGMENT_UI_CHUNK;
		if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}

		// Prepare ioSourceSegmentUI structure
		memset( &oSourceSegmentUI, 0, sizeof(ioSourceSegmentUI) );

		if( fSaveReference )
		{
			oSourceSegmentUI.wFlags |= SSUI_REFERENCE;
		}

		// Write SourceSegment UI chunk data
		hr = pIStream->Write( &oSourceSegmentUI, sizeof(ioSourceSegmentUI), &dwBytesWritten);
		if( FAILED( hr )
		||  dwBytesWritten != sizeof(ioSourceSegmentUI) )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}
		
		if( pIRiffStream->Ascend( &ck, 0 ) != 0 )
		{
 			hr = E_FAIL;
			goto ON_ERROR;
		}
	}
	
	// Determine whether file is already embedded in this stream
	if( pIPersistInfo 
	&&  pIPersistInfo->IsInEmbeddedFileList(m_FileRef.pIDocRootNode) == S_FALSE )
	{
		fIsEmbeddedInStream = FALSE;
	}

	// Write SourceSegment data
	if( ::IsEqualGUID(StreamInfo.guidDataFormat, GUID_DirectMusicObject)
	||  StreamInfo.ftFileType != FT_RUNTIME
	||  fSaveReference 
	||  fIsEmbeddedInStream )
	{
		if( ::IsEqualGUID( StreamInfo.guidDataFormat, GUID_DirectMusicObject ) )
		{
			SaveDMRef( pIRiffStream, m_FileRef.pIDocRootNode, &dmusObjectDesc, WL_PRODUCER );
		}
		else if( ::IsEqualGUID( StreamInfo.guidDataFormat, GUID_CurrentVersion ) )
		{
			SaveDMRef( pIRiffStream, m_FileRef.pIDocRootNode, &dmusObjectDesc, WL_DIRECTMUSIC );
			if( StreamInfo.ftFileType == FT_DESIGN )
			{
				SaveProducerRef( pIRiffStream, m_FileRef.pIDocRootNode );
			}
		}
	}
	else
	{
		IPersistStream* pIPersistStream;

		hr = m_FileRef.pIDocRootNode->QueryInterface( IID_IPersistStream, (void**)&pIPersistStream );
		if( FAILED( hr ) )
		{
			goto ON_ERROR;
		}
		if( pIPersistInfo )
		{
			// Need to do this BEFORE Save()
			pIPersistInfo->AddToEmbeddedFileList( m_FileRef.pIDocRootNode );
		}
		hr = pIPersistStream->Save( pIStream, FALSE );
		RELEASE( pIPersistStream );
		if( FAILED( hr ) )
		{
			goto ON_ERROR;
		}
	}

	if( pIRiffStream->Ascend(&ckMain, 0) != 0 )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

ON_ERROR:
	RELEASE( pIPersistInfo );
    RELEASE( pIStream );
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CSourceSegment SaveSourceSegmentPendingLoad
    
HRESULT CSourceSegment::SaveSourceSegmentPendingLoad( IDMUSProdRIFFStream* pIRiffStream, BOOL fSaveReference )
{
	IStream* pIStream;
	HRESULT hr;
	MMCKINFO ckMain;
	MMCKINFO ckRef;
	MMCKINFO ck;
	DWORD dwBytesWritten;
	DWORD dwLength;

	// Make sure we do not yet have a DocRoot pointer
	if( m_FileRef.pIDocRootNode != NULL )
	{
		ASSERT( 0 );
		return E_UNEXPECTED;
	}

	// Make sure we are waiting for this object to finish loading
	EmbeddedFile* pTheEmbeddedFile = NULL;
	if( theApp.m_pSongComponent->m_pEmbeddedFileRootFile )
	{
		if( ::IsEqualGUID(theApp.m_pSongComponent->m_pEmbeddedFileRootFile->guidNotification, m_FileRef.li.guidFile) )
		{
			pTheEmbeddedFile = theApp.m_pSongComponent->m_pEmbeddedFileRootFile;
		}
	}
	if( pTheEmbeddedFile == NULL )
	{
		POSITION pos = theApp.m_pSongComponent->m_lstEmbeddedFiles.GetHeadPosition();
		while( pos )
		{
			EmbeddedFile* pEmbeddedFile = theApp.m_pSongComponent->m_lstEmbeddedFiles.GetNext( pos );

			if( ::IsEqualGUID(pEmbeddedFile->guidNotification, m_FileRef.li.guidFile) )
			{
				pTheEmbeddedFile = pEmbeddedFile;
				break;
			}
		}
	}
	if( pTheEmbeddedFile == NULL )
	{
		// We are NOT waiting for FRAMEWORK_FileLoadFinished notification
		ASSERT( 0 );
		return S_FALSE;
	}

    pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

	DMUSProdStreamInfo StreamInfo;
	StreamInfo.ftFileType = FT_RUNTIME;
	StreamInfo.guidDataFormat = GUID_CurrentVersion;
	StreamInfo.pITargetDirectoryNode = NULL;

	// Get additional stream information
	IDMUSProdPersistInfo* pIPersistInfo;
	if( SUCCEEDED ( pIStream->QueryInterface( IID_IDMUSProdPersistInfo, (void **)&pIPersistInfo ) ) )
	{
		pIPersistInfo->GetStreamInfo( &StreamInfo );
		RELEASE( pIPersistInfo );
	}

	if( StreamInfo.ftFileType == FT_RUNTIME )
	{
		// This method cannot save FT_RUNTIME format because it cannot embed files
		// OK to return without doing anything 
		hr = S_FALSE;
		goto ON_ERROR;
	}

	// Initialize the DMUS_OBJECTDESC structure
	DMUS_OBJECTDESC dmusObjectDesc;
	memset( &dmusObjectDesc, 0, sizeof(DMUS_OBJECTDESC) );
	dmusObjectDesc.dwSize = sizeof(DMUS_OBJECTDESC);
	
	// Prepare the DMUS_OBJECTDESC structure
	{
		dmusObjectDesc.dwValidData = ( DMUS_OBJ_OBJECT | DMUS_OBJ_CLASS | DMUS_OBJ_NAME );
		memcpy( &dmusObjectDesc.guidObject, &pTheEmbeddedFile->guidObject, sizeof(GUID) );
		memcpy( &dmusObjectDesc.guidClass, &pTheEmbeddedFile->guidDMClass, sizeof(CLSID) );
		MultiByteToWideChar( CP_ACP, 0, pTheEmbeddedFile->strObjectName, -1, dmusObjectDesc.wszName, DMUS_MAX_NAME );
	}

	// Write DMUS_FOURCC_SONGSEGMENT_LIST header
	ckMain.fccType = DMUS_FOURCC_SONGSEGMENT_LIST;
	if( pIRiffStream->CreateChunk(&ckMain, MMIO_CREATELIST) != 0 )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

	// Write DMUS_FOURCC_SOURCE_SEGMENT_UI_CHUNK
	if( StreamInfo.ftFileType != FT_RUNTIME )
	{
		ioSourceSegmentUI oSourceSegmentUI;

		// Write chunk header
		ck.ckid = DMUS_FOURCC_SOURCE_SEGMENT_UI_CHUNK;
		if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}

		// Prepare ioSourceSegmentUI structure
		memset( &oSourceSegmentUI, 0, sizeof(ioSourceSegmentUI) );

		if( fSaveReference )
		{
			oSourceSegmentUI.wFlags |= SSUI_REFERENCE;
		}

		// Write SourceSegment UI chunk data
		hr = pIStream->Write( &oSourceSegmentUI, sizeof(ioSourceSegmentUI), &dwBytesWritten);
		if( FAILED( hr )
		||  dwBytesWritten != sizeof(ioSourceSegmentUI) )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}
		
		if( pIRiffStream->Ascend( &ck, 0 ) != 0 )
		{
 			hr = E_FAIL;
			goto ON_ERROR;
		}
	}
	
	// Write DMUS_FOURCC_REF_LIST
	{
		// Write REF LIST header
		ckRef.fccType = DMUS_FOURCC_REF_LIST;
		if( pIRiffStream->CreateChunk(&ckRef, MMIO_CREATELIST) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}

		// Write REF chunk
		{
			DMUS_IO_REFERENCE dmusReference;

			ck.ckid = DMUS_FOURCC_REF_CHUNK;
			if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
			{
				hr = E_FAIL;
				goto ON_ERROR;
			}

			// Prepare DMUS_IO_REFERENCE structure
			memset( &dmusReference, 0, sizeof(DMUS_IO_REFERENCE) );
			memcpy( &dmusReference.guidClassID, &dmusObjectDesc.guidClass, sizeof(GUID) );
			dmusReference.dwValidData = dmusObjectDesc.dwValidData;

			// Write REF chunk data 
			hr = pIStream->Write( &dmusReference, sizeof(DMUS_IO_REFERENCE), &dwBytesWritten);
			if( FAILED( hr )
			||  dwBytesWritten != sizeof(DMUS_IO_REFERENCE) )
			{
				hr = E_FAIL;
				goto ON_ERROR;
			}

			if( pIRiffStream->Ascend(&ck, 0) != 0 )
			{
				hr = E_FAIL;
				goto ON_ERROR;
			}
		}

		// Write GUID chunk
		{
			ck.ckid = DMUS_FOURCC_GUID_CHUNK;
			if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
			{
				hr = E_FAIL;
				goto ON_ERROR;
			}

			hr = pIStream->Write( &dmusObjectDesc.guidObject, sizeof(GUID), &dwBytesWritten);
			if( FAILED( hr )
			||  dwBytesWritten != sizeof(GUID) )
			{
				hr = E_FAIL;
				goto ON_ERROR;
			}

			if( pIRiffStream->Ascend(&ck, 0) != 0 )
			{
				hr = E_FAIL;
				goto ON_ERROR;
			}
		}

		// Write Name chunk
		{
			ck.ckid = DMUS_FOURCC_NAME_CHUNK;
			if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
			{
				hr = E_FAIL;
				goto ON_ERROR;
			}

			dwLength = wcslen( dmusObjectDesc.wszName ) + 1; 
			dwLength *= sizeof( wchar_t );
			hr = pIStream->Write( &dmusObjectDesc.wszName, dwLength, &dwBytesWritten);
			if( FAILED( hr )
			||  dwBytesWritten != dwLength )
			{
				hr = E_FAIL;
				goto ON_ERROR;
			}

			if( pIRiffStream->Ascend(&ck, 0) != 0 )
			{
				hr = E_FAIL;
				goto ON_ERROR;
			}
		}

		if( pIRiffStream->Ascend(&ckRef, 0) != 0 )
		{
			hr = E_FAIL;
			goto ON_ERROR;
		}
	}

	if( pIRiffStream->Ascend(&ckMain, 0) != 0 )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

ON_ERROR:
    RELEASE( pIStream );
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CSourceSegment::FindSegmentFile

HRESULT CSourceSegment::FindSegmentFile( CString strSourceSegmentName, IStream* pIStream, IDMUSProdNode** ppIDocRootNode )
{
	IDMUSProdNode*		pIDocRootNode = NULL;
	IDMUSProdNode*		pITargetDirectoryNode = NULL;
	IDMUSProdDocType*	pIDocType = NULL;
	HRESULT				hr;

	ASSERT( pIStream != NULL );

	// Get DocType for Segments
	hr = theApp.m_pSongComponent->m_pIFramework8->FindDocTypeByNodeId( GUID_SegmentNode, &pIDocType );
	if( FAILED ( hr ) )
	{
		goto ON_ERROR;
	}

	// Get the target directory
	DMUSProdStreamInfo	StreamInfo;
	StreamInfo.pITargetDirectoryNode = NULL;

	// Get additional stream information
	IDMUSProdPersistInfo* pPersistInfo;

	if( SUCCEEDED ( pIStream->QueryInterface( IID_IDMUSProdPersistInfo, (void **)&pPersistInfo ) ) )
	{
		pPersistInfo->GetStreamInfo( &StreamInfo );
		pITargetDirectoryNode = StreamInfo.pITargetDirectoryNode;
		pPersistInfo->Release();
	}

	// If a target directory is not associated with the stream
	// use DocRoot node
	if( pITargetDirectoryNode == NULL )
	{
		if( m_pSong )
		{
			IDMUSProdNode* pIDocNode;
			if( SUCCEEDED ( m_pSong->GetDocRootNode( &pIDocNode ) ) )
			{
				pITargetDirectoryNode = pIDocNode;
				RELEASE( pIDocNode );
			}
		}
	}

	// See if there is a segment named 'strSourceSegmentName' in this Project
	if( !strSourceSegmentName.IsEmpty() )
	{
		BSTR bstrSourceSegmentName = strSourceSegmentName.AllocSysString();
		hr = theApp.m_pSongComponent->m_pIFramework8->GetBestGuessDocRootNode( pIDocType, bstrSourceSegmentName,
																			   pITargetDirectoryNode, &pIDocRootNode );
		if( FAILED ( hr ) )
		{
			pIDocRootNode = NULL;
			if( hr == E_PENDING )
			{
				// File is in process of being loaded
				// Store temporary GUID so we can resolve reference in our handler 
				// for the FRAMEWORK_FileLoadFinished notification
				ASSERT( m_pSong != NULL );
				if( m_pSong )
				{
					IDMUSProdNotifySink* pINotifySink;
					if( SUCCEEDED ( m_pSong->QueryInterface( IID_IDMUSProdNotifySink, (void**)&pINotifySink ) ) )
					{
						HRESULT hrResolve;

						bstrSourceSegmentName = strSourceSegmentName.AllocSysString();
						hrResolve = theApp.m_pSongComponent->m_pIFramework8->ResolveBestGuessWhenLoadFinished( 
									pIDocType, bstrSourceSegmentName, pITargetDirectoryNode,
									pINotifySink, &m_FileRef.li.guidFile );
						if( SUCCEEDED ( hrResolve ) )
						{
							EmbeddedFile* pEmbeddedFile = theApp.m_pSongComponent->FindEmbeddedFile( pIDocType, strSourceSegmentName );

							if( pEmbeddedFile
							&&  pEmbeddedFile->dwStreamPos == 0 )
							{
								// Need to special case "root" file
								pEmbeddedFile->guidNotification = m_FileRef.li.guidFile;
							}

							m_FileRef.li.strName = strSourceSegmentName;
						}

						RELEASE( pINotifySink );
					}
				}
				goto ON_ERROR;
			}
		}
	}

	if( pIDocRootNode == NULL )
	{
		// Determine File Open dialog prompt
		CString	strOpenDlgTitle;
		if( strSourceSegmentName.IsEmpty() )
		{
			strOpenDlgTitle.LoadString( IDS_FILE_OPEN_ANY_SEGMENT );
		}
		else
		{
			AfxFormatString1( strOpenDlgTitle, IDS_FILE_OPEN_SEGMENT, strSourceSegmentName );
		}
		BSTR bstrOpenDlgTitle = strOpenDlgTitle.AllocSysString();

		// Display File open dialog
		hr = theApp.m_pSongComponent->m_pIFramework8->OpenFile( pIDocType, bstrOpenDlgTitle, pITargetDirectoryNode, &pIDocRootNode );
		if( hr != S_OK )
		{
			// Did not open a file, or opened file other than Segment file
			// so we do not want this DocRoot
			RELEASE( pIDocRootNode );
		}
	}

ON_ERROR:
	RELEASE( pIDocType );

	*ppIDocRootNode = pIDocRootNode;
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SongDesigner\SourceSegment.h ===
#ifndef __SOURCE_SEGMENT_H_
#define __SOURCE_SEGMENT_H_

#include "RiffStrm.h"


#define DMUS_FOURCC_SOURCE_SEGMENT_UI_CHUNK			mmioFOURCC('s','s','u','i')

#define SSUI_REFERENCE	0x0001


#pragma pack(2)

typedef struct ioSourceSegmentUI
{
	ioSourceSegmentUI()
	{
		wFlags = 0;
	}

	WORD	wFlags;			// SSUI_ flags
} ioSourceSegmentUI;

typedef struct FileListInfo
{
	FileListInfo()
	{
		pIProject = NULL;
		memset( &guidFile, 0, sizeof(GUID) );
	}

	IDMUSProdProject*	pIProject;
	CString				strProjectName;
	CString				strName;
	CString				strDescriptor;
	GUID				guidFile;
} FileListInfo;

typedef struct FileRef
{
	FileRef()
	{
		pIDocRootNode = NULL;
		pIRefNode = NULL;
		fRemoveNotify = FALSE;
	}

	IDMUSProdNode*		pIDocRootNode;	// Pointer to referenced file's DocRoot node
	IDMUSProdNode*		pIRefNode;		// Pointer to referenced file's Reference node
	BOOL				fRemoveNotify;
	FileListInfo		li;
} FileRef;

#pragma pack()


//////////////////////////////////////////////////////////////////////
//  CSegmentPropPageManager

class CSegmentPropPageManager : public IDMUSProdPropPageManager 
{
friend class CTabSegmentDesign;
friend class CTabSegmentRuntime;
friend class CTabSegmentFlags;

public:
	CSegmentPropPageManager();
	virtual ~CSegmentPropPageManager();

    // IUnknown functions
    HRESULT STDMETHODCALLTYPE QueryInterface( REFIID riid, LPVOID *ppv );
    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();

    // IDMUSProdPropPageManager functions
    HRESULT STDMETHODCALLTYPE GetPropertySheetTitle( BSTR* pbstrTitle, BOOL* pfAddPropertiesText );
    HRESULT STDMETHODCALLTYPE GetPropertySheetPages( IDMUSProdPropSheet* pIPropSheet, LONG* hPropSheetPage[], short* pnNbrPages );
	HRESULT STDMETHODCALLTYPE OnRemoveFromPropertySheet();

    HRESULT STDMETHODCALLTYPE SetObject( IDMUSProdPropPageObject* pINewPropPageObject );
    HRESULT STDMETHODCALLTYPE RemoveObject( IDMUSProdPropPageObject* pIPropPageObject );
    HRESULT STDMETHODCALLTYPE IsEqualObject( IDMUSProdPropPageObject* pIPropPageObject );

    HRESULT STDMETHODCALLTYPE RefreshData();
    HRESULT STDMETHODCALLTYPE IsEqualPageManagerGUID( REFGUID rguidPageManager );

	//Additional functions
private:
	void RemoveCurrentObject();

	// Member variables
private:
    DWORD						m_dwRef;
	IDMUSProdPropSheet*			m_pIPropSheet;
	IDMUSProdPropPageObject*	m_pIPropPageObject;
	
	CTabSegmentDesign*			m_pTabDesign;
	CTabSegmentRuntime*			m_pTabRuntime;

public:
	static short				sm_nActiveTab;
};


//////////////////////////////////////////////////////////////////////
//  CSourceSegment

class CSourceSegment : public IDMUSProdNode, public IDMUSProdPropPageObject
{
friend class CSegmentPropPageManager;
friend class CTabSegmentDesign;
friend class CTabSegmentRuntime;
friend class CTabSegmentFlags;
friend class CFolder;

public:
	CSourceSegment( CDirectMusicSong* pSong );
	virtual ~CSourceSegment();

    // IUnknown functions
    HRESULT STDMETHODCALLTYPE QueryInterface( REFIID riid, LPVOID *ppv );
    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();

    // IDMUSProdNode functions
	HRESULT STDMETHODCALLTYPE GetNodeImageIndex( short* pnNbrFirstImage );
    HRESULT STDMETHODCALLTYPE GetFirstChild( IDMUSProdNode** ppIFirstChildNode );
    HRESULT STDMETHODCALLTYPE GetNextChild( IDMUSProdNode* pIChildNode, IDMUSProdNode** ppINextChildNode );

    HRESULT STDMETHODCALLTYPE GetComponent( IDMUSProdComponent** ppIComponent );
    HRESULT STDMETHODCALLTYPE GetDocRootNode( IDMUSProdNode** ppIDocRootNode );
    HRESULT STDMETHODCALLTYPE SetDocRootNode( IDMUSProdNode* pIDocRootNode );
    HRESULT STDMETHODCALLTYPE GetParentNode( IDMUSProdNode** ppIParentNode );
    HRESULT STDMETHODCALLTYPE SetParentNode( IDMUSProdNode* pIParentNode );
    HRESULT STDMETHODCALLTYPE GetNodeId( GUID* pguid );
    HRESULT STDMETHODCALLTYPE GetNodeName( BSTR* pbstrName );
    HRESULT STDMETHODCALLTYPE GetNodeNameMaxLength( short* pnMaxLength );
    HRESULT STDMETHODCALLTYPE ValidateNodeName( BSTR bstrName );
    HRESULT STDMETHODCALLTYPE SetNodeName( BSTR bstrName );
	HRESULT STDMETHODCALLTYPE GetNodeListInfo( DMUSProdListInfo* pListInfo );

    HRESULT STDMETHODCALLTYPE GetEditorClsId( CLSID* pclsid );
    HRESULT STDMETHODCALLTYPE GetEditorTitle( BSTR* pbstrTitle );
    HRESULT STDMETHODCALLTYPE GetEditorWindow( HWND* hWndEditor );
    HRESULT STDMETHODCALLTYPE SetEditorWindow( HWND hWndEditor );

	HRESULT STDMETHODCALLTYPE UseOpenCloseImages( BOOL* pfUseOpenCloseImages );

    HRESULT STDMETHODCALLTYPE GetRightClickMenuId( HINSTANCE* phInstance, UINT* pnResourceId );
    HRESULT STDMETHODCALLTYPE OnRightClickMenuInit( HMENU hMenu );
    HRESULT STDMETHODCALLTYPE OnRightClickMenuSelect( long lCommandId );

    HRESULT STDMETHODCALLTYPE DeleteChildNode( IDMUSProdNode* pIChildNode, BOOL fPromptUser );
    HRESULT STDMETHODCALLTYPE InsertChildNode( IDMUSProdNode* pIChildNode );
    HRESULT STDMETHODCALLTYPE DeleteNode( BOOL fPromptUser );

	HRESULT STDMETHODCALLTYPE OnNodeSelChanged( BOOL fSelected );

	HRESULT STDMETHODCALLTYPE CreateDataObject( IDataObject** ppIDataObject );
	HRESULT STDMETHODCALLTYPE CanCut();
	HRESULT STDMETHODCALLTYPE CanCopy();
	HRESULT STDMETHODCALLTYPE CanDelete();
	HRESULT STDMETHODCALLTYPE CanDeleteChildNode( IDMUSProdNode* pIChildNode );
	HRESULT STDMETHODCALLTYPE CanPasteFromData( IDataObject* pIDataObject, BOOL* pfWillSetReference );
	HRESULT STDMETHODCALLTYPE PasteFromData( IDataObject* pIDataObject );
	HRESULT STDMETHODCALLTYPE CanChildPasteFromData( IDataObject* pIDataObject, IDMUSProdNode* pIChildNode, BOOL* pfWillSetReference );
	HRESULT STDMETHODCALLTYPE ChildPasteFromData( IDataObject* pIDataObject, IDMUSProdNode* pIChildNode );

	HRESULT STDMETHODCALLTYPE GetObject( REFCLSID rclsid, REFIID riid, void** ppvObject ); 

    // IDMUSProdPropPageObject functions
    HRESULT STDMETHODCALLTYPE GetData( void** ppData );
    HRESULT STDMETHODCALLTYPE SetData( void* pData );
	HRESULT STDMETHODCALLTYPE OnShowProperties();
	HRESULT STDMETHODCALLTYPE OnRemoveFromPageManager();

	// Additional methods
	HRESULT Load( IDMUSProdRIFFStream* pIRiffStream, MMCKINFO* pckMain, BOOL* pfReference );
    HRESULT Save( IDMUSProdRIFFStream* pIRiffStream, BOOL fSaveReference );
	HRESULT SetFileReference( IDMUSProdNode* pINewDocRootNode );
	HRESULT SetFileReference( GUID guidFile );
	HRESULT SyncListInfo();
	void ClearListInfo();
    HRESULT GetSegmentDocRootNode( IDMUSProdNode** ppISegmentDocRootNode );

private:
	HRESULT SaveDMRef( IDMUSProdRIFFStream* pIRiffStream, IDMUSProdNode* pIDocRootNode, DMUS_OBJECTDESC* pdmusObjectDesc, WhichLoader whichLoader );
	HRESULT SaveProducerRef( IDMUSProdRIFFStream* pIRiffStream, IDMUSProdNode* pIDocRootNode );
	HRESULT SaveSourceSegmentPendingLoad( IDMUSProdRIFFStream* pIRiffStream, BOOL fSaveReference );
	HRESULT CreateRefNode( IDMUSProdNode* pIDocRootNode, IDMUSProdNode** ppIRefNode );
	HRESULT FindSegmentFile( CString strSourceSegmentName, IStream* pIStream, IDMUSProdNode** ppIDocRootNode );

private:
    DWORD					m_dwRef;
	CDirectMusicSong*		m_pSong;
	IDMUSProdNode*			m_pIDocRootNode;
	IDMUSProdNode*			m_pIParentNode;

	FileRef					m_FileRef;		// Info pertaining to referenced file
};

#endif // __SOURCE_SEGMENT_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SongDesigner\TabInfo.h ===
#if !defined(AFX_TABINFO_H__7060E0E4_B63A_11D0_89AE_00A0C9054129__INCLUDED_)
#define AFX_TABINFO_H__7060E0E4_B63A_11D0_89AE_00A0C9054129__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// TabInfo.h : header file
//

#include "resource.h"

class CSongPropPageManager;
class CDirectMusicSong;

/////////////////////////////////////////////////////////////////////////////
// CTabInfo dialog

class CTabInfo : public CPropertyPage
{
// Construction
public:
	CTabInfo( CSongPropPageManager* pSongPropPageManager );
	virtual ~CTabInfo();
	void SetSong( CDirectMusicSong* pSong );

// Dialog Data
	//{{AFX_DATA(CTabInfo)
	enum { IDD = IDD_TAB_INFO };
	CButton	m_btnGUID;
	CEdit	m_editVersion_4;
	CEdit	m_editVersion_3;
	CEdit	m_editVersion_2;
	CEdit	m_editVersion_1;
	CEdit	m_editSubject;
	CEdit	m_editInfo;
	CEdit	m_editCopyright;
	CEdit	m_editAuthor;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CTabInfo)
	public:
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Attributes
protected:
	CDirectMusicSong*		m_pSong;
	CSongPropPageManager*	m_pPageManager;
	BOOL					m_fNeedToDetach;

// Implementation
protected:
	void EnableControls( BOOL fEnable );
	void UpdateControls();

	// Generated message map functions
	//{{AFX_MSG(CTabInfo)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnDestroy();
	afx_msg void OnKillFocusAuthor();
	afx_msg void OnKillFocusCopyright();
	afx_msg void OnKillFocusSubject();
	afx_msg void OnKillFocusInfo();
	afx_msg void OnKillFocusVersion_1();
	afx_msg void OnKillFocusVersion_2();
	afx_msg void OnKillFocusVersion_3();
	afx_msg void OnKillFocusVersion_4();
	afx_msg void OnEditGuid();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_TABINFO_H__7060E0E4_B63A_11D0_89AE_00A0C9054129__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SongDesigner\TabSegmentDesign.h ===
#if !defined(AFX_TABSEGMENTDESIGN_H__4B3A5402_6B29_11D1_89AE_00A0C9054129__INCLUDED_)
#define AFX_TABSEGMENTDESIGN_H__4B3A5402_6B29_11D1_89AE_00A0C9054129__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// TabSegmentDesign.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CTabSegmentDesign dialog

class CTabSegmentDesign : public CPropertyPage
{
// Construction
public:
	CTabSegmentDesign( CSegmentPropPageManager* pPageManager );
	~CTabSegmentDesign();
	void SetSourceSegment( CSourceSegment* pSourceSegment );

// Dialog Data
	//{{AFX_DATA(CTabSegmentDesign)
	enum { IDD = IDD_TAB_SEGMENT_DESIGN };
	CEdit	m_editDesignFileName;
	CStatic	m_staticDesignCreate;
	CStatic	m_staticDesignSize;
	CStatic	m_staticDesignModified;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CTabSegmentDesign)
	public:
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Attributes
protected:
	CSourceSegment*				m_pSourceSegment;
	CSegmentPropPageManager*	m_pPageManager;
	BOOL						m_fNeedToDetach;

// Implementation
protected:
	void EnableControls( BOOL fEnable );

	// Generated message map functions
	//{{AFX_MSG(CTabSegmentDesign)
	afx_msg void OnDestroy();
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_TABSEGMENTDESIGN_H__4B3A5402_6B29_11D1_89AE_00A0C9054129__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SongDesigner\TabSegmentDesign.cpp ===
// TabSegmentDesign.cpp : implementation file
//

#include "stdafx.h"
#include "SongDesignerDLL.h"

#include "Song.h"
#include "SourceSegment.h"
#include "TabSegmentDesign.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CTabSegmentDesign property page

CTabSegmentDesign::CTabSegmentDesign( CSegmentPropPageManager* pPageManager ) : CPropertyPage(CTabSegmentDesign::IDD)
{
	//{{AFX_DATA_INIT(CTabSegmentDesign)
	//}}AFX_DATA_INIT

	ASSERT( pPageManager != NULL );

	m_pSourceSegment = NULL;
	m_pPageManager = pPageManager;
	m_fNeedToDetach = FALSE;
}

CTabSegmentDesign::~CTabSegmentDesign()
{
}


/////////////////////////////////////////////////////////////////////////////
// CTabSegmentDesign::SetSourceSegment

void CTabSegmentDesign::SetSourceSegment( CSourceSegment* pSourceSegment )
{
	m_pSourceSegment = pSourceSegment;
}


void CTabSegmentDesign::DoDataExchange(CDataExchange* pDX)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CTabSegmentDesign)
	DDX_Control(pDX, IDC_DESIGN_FILENAME, m_editDesignFileName);
	DDX_Control(pDX, IDC_DESIGN_CREATE, m_staticDesignCreate);
	DDX_Control(pDX, IDC_DESIGN_SIZE, m_staticDesignSize);
	DDX_Control(pDX, IDC_DESIGN_MODIFIED, m_staticDesignModified);
	//}}AFX_DATA_MAP
}


/////////////////////////////////////////////////////////////////////////////
// CTabSegmentDesign::EnableControls

void CTabSegmentDesign::EnableControls( BOOL fEnable ) 
{
	// May need this method at a later time
}


BEGIN_MESSAGE_MAP(CTabSegmentDesign, CPropertyPage)
	//{{AFX_MSG_MAP(CTabSegmentDesign)
	ON_WM_DESTROY()
	ON_WM_CREATE()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CTabSegmentDesign message handlers

BOOL CTabSegmentDesign::OnSetActive() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pSourceSegment == NULL )
	{
		EnableControls( FALSE );
		return CPropertyPage::OnSetActive();
	}

	// Store active tab
	m_pPageManager->m_pIPropSheet->GetActivePage( &CSegmentPropPageManager::sm_nActiveTab );

	EnableControls( TRUE );

	HINSTANCE hInstance = AfxGetResourceHandle();
	AfxSetResourceHandle( theApp.m_hInstance );

	BSTR bstrFileName;
	CString strFileName;
	CString strFileCreate;
	CString strFileModified;
	CString strFileSize;

	strFileName.LoadString( IDS_UNKNOWN );
	strFileCreate.LoadString( IDS_UNKNOWN );
	strFileModified.LoadString( IDS_UNKNOWN );
	strFileSize.LoadString( IDS_UNKNOWN );

	// Determine design file filename
	if( SUCCEEDED ( theApp.m_pSongComponent->m_pIFramework8->GetNodeFileName( m_pSourceSegment->m_FileRef.pIDocRootNode, &bstrFileName ) ) )
	{
		CString strTheFileName = bstrFileName;
		::SysFreeString( bstrFileName );

		if( strTheFileName.IsEmpty() == FALSE )
		{
			strFileName = strTheFileName;

			// Set design file modified date and size
			HANDLE hFile = ::CreateFile( strFileName, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING,
	 									 FILE_ATTRIBUTE_NORMAL, NULL );
			if( hFile != INVALID_HANDLE_VALUE )
			{
				FILETIME ftModified;
				FILETIME ftCreate;
				DWORD dwFileSize;

				if( ::GetFileTime(hFile, &ftCreate, NULL, &ftModified) )
				{
					CTime timeFile;
					
					timeFile = ftCreate;
					strFileCreate = timeFile.Format( "%A, %B %d, %Y   %I:%M:%S %p" );

					timeFile = ftModified;
					strFileModified = timeFile.Format( "%A, %B %d, %Y   %I:%M:%S %p" );
				}

				dwFileSize = GetFileSize( hFile, NULL );

				CString strSize;
				CString strBytes;
				strSize.Format( "%u", dwFileSize );

				int i, j;
				int nLength = strSize.GetLength();

				for( i=0, j=nLength;  i < nLength ; i++ )
				{
					strBytes += strSize[i];
					j--;
					if( (j > 0)
					&& !(j % 3) )
					{
						strBytes += ',';
					}
				}
				
				if( dwFileSize < 1024 )
				{
					AfxFormatString1( strFileSize, IDS_SIZE_BYTES, strBytes );
				}
				else
				{
					CString strKB;
					
					double dblKB = dwFileSize / 1024.0;
					strKB.Format( "%.2f", dblKB );

					AfxFormatString2( strFileSize, IDS_SIZE_KB, strKB, strBytes );
				}

				CloseHandle( hFile );
			}
		}
	}

	m_editDesignFileName.SetWindowText( strFileName );
	m_staticDesignCreate.SetWindowText( strFileCreate );
	m_staticDesignModified.SetWindowText( strFileModified );
	m_staticDesignSize.SetWindowText( strFileSize );

	AfxSetResourceHandle( hInstance );
	
	return CPropertyPage::OnSetActive();
}


/////////////////////////////////////////////////////////////////////////////
// CTabSegmentDesign::OnDestroy

void CTabSegmentDesign::OnDestroy() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Detach the window from the property page structure.
	// This will be done again by the main application since
	// it owns the property sheet.  It needs o be done here
	// so that the window handle can be removed from the
	// DLLs handle map.
	if( m_fNeedToDetach && m_hWnd )
	{
		HWND hWnd = m_hWnd;
		Detach();
		m_hWnd = hWnd;
	}

	CPropertyPage::OnDestroy();
}


/////////////////////////////////////////////////////////////////////////////
// CTabSegmentDesign::OnCreate

int CTabSegmentDesign::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Attach the window to the property page structure.
	// This has been done once already in the main application
	// since the main application owns the property sheet.
	// It needs to be done here so that the window handle can
	// be found in the DLLs handle map.
	if( !FromHandlePermanent( m_hWnd ) )
	{
		HWND hWnd = m_hWnd;
		m_hWnd = NULL;
		Attach( hWnd );
		m_fNeedToDetach = TRUE;
	}

	if( CPropertyPage::OnCreate(lpCreateStruct) == -1 )
	{
		return -1;
	}
	
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SongDesigner\TabSegmentRuntime.cpp ===
// TabSegmentRuntime.cpp : implementation file
//

#include "stdafx.h"
#include "SongDesignerDLL.h"

#include "Song.h"
#include "SourceSegment.h"
#include "TabSegmentRuntime.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CTabSegmentRuntime property page

CTabSegmentRuntime::CTabSegmentRuntime( CSegmentPropPageManager* pPageManager ) : CPropertyPage(CTabSegmentRuntime::IDD)
{
	//{{AFX_DATA_INIT(CTabSegmentRuntime)
	//}}AFX_DATA_INIT

	ASSERT( pPageManager != NULL );

	m_pSourceSegment = NULL;
	m_pPageManager = pPageManager;
	m_fNeedToDetach = FALSE;
}

CTabSegmentRuntime::~CTabSegmentRuntime()
{
}


/////////////////////////////////////////////////////////////////////////////
// CTabSegmentRuntime::SetSourceSegment

void CTabSegmentRuntime::SetSourceSegment( CSourceSegment* pSourceSegment )
{
	m_pSourceSegment = pSourceSegment;
}


void CTabSegmentRuntime::DoDataExchange(CDataExchange* pDX)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CTabSegmentRuntime)
	DDX_Control(pDX, IDC_RUNTIME_FILE, m_editRuntimeFile);
	DDX_Control(pDX, IDC_RUNTIME_CREATE, m_staticRuntimeCreate);
	DDX_Control(pDX, IDC_RUNTIME_SIZE, m_staticRuntimeSize);
	DDX_Control(pDX, IDC_RUNTIME_MODIFIED, m_staticRuntimeModified);
	//}}AFX_DATA_MAP
}


/////////////////////////////////////////////////////////////////////////////
// CTabSegmentRuntime::EnableControls

void CTabSegmentRuntime::EnableControls( BOOL fEnable ) 
{
	// May need this routine later
}


BEGIN_MESSAGE_MAP(CTabSegmentRuntime, CPropertyPage)
	//{{AFX_MSG_MAP(CTabSegmentRuntime)
	ON_WM_DESTROY()
	ON_WM_CREATE()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CTabSegmentRuntime message handlers

/////////////////////////////////////////////////////////////////////////////
// CTabSegmentRuntime::OnSetActive

BOOL CTabSegmentRuntime::OnSetActive() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pSourceSegment == NULL )
	{
		EnableControls( FALSE );
		return CPropertyPage::OnSetActive();
	}

	// Store active tab
	m_pPageManager->m_pIPropSheet->GetActivePage( &CSegmentPropPageManager::sm_nActiveTab );

	EnableControls( TRUE );

	HINSTANCE hInstance = AfxGetResourceHandle();
	AfxSetResourceHandle( theApp.m_hInstance );

	// Set runtime file name, modified date, size
	BSTR bstrFile;
	CString strFile;
	CString strFileCreate;
	CString strFileModified;
	CString strFileSize;

	strFile.LoadString( IDS_NOT_SAVED );
	strFileCreate.LoadString( IDS_UNKNOWN );
	strFileModified.LoadString( IDS_UNKNOWN );
	strFileSize.LoadString( IDS_UNKNOWN );

	// Determine filename of last saved runtime file
	if( SUCCEEDED ( theApp.m_pSongComponent->m_pIFramework8->GetNodeRuntimeFileName( m_pSourceSegment->m_FileRef.pIDocRootNode, &bstrFile ) ) )
	{
		CString strTheFile = bstrFile;
		::SysFreeString( bstrFile );

		if( strTheFile.IsEmpty() == FALSE )
		{
			strFile = strTheFile;

			HANDLE hFile = ::CreateFile( strFile, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING,
	 									 FILE_ATTRIBUTE_NORMAL, NULL );
			if( hFile != INVALID_HANDLE_VALUE )
			{
				FILETIME ftCreate;
				FILETIME ftModified;
				DWORD dwFileSize;

				if( ::GetFileTime(hFile, &ftCreate, NULL, &ftModified) )
				{
					CTime timeFile;
					
					timeFile = ftCreate;
					strFileCreate = timeFile.Format( "%A, %B %d, %Y   %I:%M:%S %p" );
					
					timeFile = ftModified;
					strFileModified = timeFile.Format( "%A, %B %d, %Y   %I:%M:%S %p" );
				}

				dwFileSize = GetFileSize( hFile, NULL );

				CString strSize;
				CString strBytes;
				strSize.Format( "%u", dwFileSize );

				int i, j;
				int nLength = strSize.GetLength();

				for( i=0, j=nLength;  i < nLength ; i++ )
				{
					strBytes += strSize[i];
					j--;
					if( (j > 0)
					&& !(j % 3) )
					{
						strBytes += ',';
					}
				}
				
				if( dwFileSize < 1024 )
				{
					AfxFormatString1( strFileSize, IDS_SIZE_BYTES, strBytes );
				}
				else
				{
					CString strKB;
					
					double dblKB = dwFileSize / 1024.0;
					strKB.Format( "%.2f", dblKB );

					AfxFormatString2( strFileSize, IDS_SIZE_KB, strKB, strBytes );
				}

				CloseHandle( hFile );
			}
		}
	}

	m_editRuntimeFile.SetWindowText( strFile );
	m_staticRuntimeCreate.SetWindowText( strFileCreate );
	m_staticRuntimeModified.SetWindowText( strFileModified );
	m_staticRuntimeSize.SetWindowText( strFileSize );
	
	AfxSetResourceHandle( hInstance );
	
	return CPropertyPage::OnSetActive();
}


/////////////////////////////////////////////////////////////////////////////
// CTabSegmentRuntime::OnDestroy

void CTabSegmentRuntime::OnDestroy() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Detach the window from the property page structure.
	// This will be done again by the main application since
	// it owns the property sheet.  It needs o be done here
	// so that the window handle can be removed from the
	// DLLs handle map.
	if( m_fNeedToDetach && m_hWnd )
	{
		HWND hWnd = m_hWnd;
		Detach();
		m_hWnd = hWnd;
	}

	CPropertyPage::OnDestroy();
}


/////////////////////////////////////////////////////////////////////////////
// CTabSegmentRuntime::OnCreate

int CTabSegmentRuntime::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Attach the window to the property page structure.
	// This has been done once already in the main application
	// since the main application owns the property sheet.
	// It needs to be done here so that the window handle can
	// be found in the DLLs handle map.
	if( !FromHandlePermanent( m_hWnd ) )
	{
		HWND hWnd = m_hWnd;
		m_hWnd = NULL;
		Attach( hWnd );
		m_fNeedToDetach = TRUE;
	}

	if( CPropertyPage::OnCreate(lpCreateStruct) == -1 )
	{
		return -1;
	}
	
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SongDesigner\TabSegmentRuntime.h ===
#if !defined(AFX_TABSEGMENTRUNTIME_H__4B3A5402_6B29_11D1_89AE_00A0C9054129__INCLUDED_)
#define AFX_TABSEGMENTRUNTIME_H__4B3A5402_6B29_11D1_89AE_00A0C9054129__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// TabSegmentRuntime.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CTabSegmentRuntime dialog

class CTabSegmentRuntime : public CPropertyPage
{
// Construction
public:
	CTabSegmentRuntime( CSegmentPropPageManager* pPageManager );
	~CTabSegmentRuntime();
	void SetSourceSegment( CSourceSegment* pSourceSegment );

// Dialog Data
	//{{AFX_DATA(CTabSegmentRuntime)
	enum { IDD = IDD_TAB_SEGMENT_RUNTIME };
	CEdit	m_editRuntimeFile;
	CStatic	m_staticRuntimeCreate;
	CStatic	m_staticRuntimeSize;
	CStatic	m_staticRuntimeModified;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CTabSegmentRuntime)
	public:
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Attributes
protected:
	CSourceSegment*				m_pSourceSegment;
	CSegmentPropPageManager*	m_pPageManager;
	BOOL						m_fNeedToDetach;

// Implementation
protected:
	void EnableControls( BOOL fEnable );

	// Generated message map functions
	//{{AFX_MSG(CTabSegmentRuntime)
	afx_msg void OnDestroy();
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_TABSEGMENTRUNTIME_H__4B3A5402_6B29_11D1_89AE_00A0C9054129__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SongDesigner\TabSong.h ===
#if !defined(AFX_TABSONG_H__7060E0E4_B63A_11D0_89AE_00A0C9054129__INCLUDED_)
#define AFX_TABSONG_H__7060E0E4_B63A_11D0_89AE_00A0C9054129__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// TabSong.h : header file
//

#include "resource.h"

class CSongPropPageManager;
class CDirectMusicSong;

/////////////////////////////////////////////////////////////////////////////
// CTabSong dialog

class CTabSong : public CPropertyPage
{
// Construction
public:
	CTabSong( CSongPropPageManager* pSongPropPageManager );
	virtual ~CTabSong();
	void SetSong( CDirectMusicSong* pSong );

// Dialog Data
	//{{AFX_DATA(CTabSong)
	enum { IDD = IDD_TAB_SONG };
	CEdit	m_editName;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CTabSong)
	public:
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Attributes
protected:
	CDirectMusicSong*		m_pSong;
	CSongPropPageManager*	m_pPageManager;
	BOOL					m_fNeedToDetach;

// Implementation
protected:
	void EnableControls( BOOL fEnable );
	void UpdateControls();

	// Generated message map functions
	//{{AFX_MSG(CTabSong)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnDestroy();
	afx_msg void OnKillFocusName();
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_TABSONG_H__7060E0E4_B63A_11D0_89AE_00A0C9054129__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SongDesigner\TabTransition.h ===
#if !defined(AFX_TABTRANSITION_H__4B3A5402_6B29_11D1_89AE_00A0C9054129__INCLUDED_)
#define AFX_TABTRANSITION_H__4B3A5402_6B29_11D1_89AE_00A0C9054129__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

// TabTransition.h : header file
//

typedef struct _PPGTabTransition
{
	_PPGTabTransition( void )
	{
		dwPageIndex = 1;
		dwToSegmentFlag = 0;
		pToSegment = NULL;
		pTransitionSegment = NULL;
		pSong = NULL;
		dwFlagsUI = 0;
	}

	DWORD				dwPageIndex;
	DWORD				dwToSegmentFlag;
	CVirtualSegment*	pToSegment;
	CVirtualSegment*	pTransitionSegment;
	CDirectMusicSong*	pSong;
	DWORD				dwFlagsUI;
} PPGTabTransition;


/////////////////////////////////////////////////////////////////////////////
// CTabTransition dialog

class CTabTransition : public CPropertyPage
{
// Construction
public:
	CTabTransition( IDMUSProdPropPageManager* pIPageManager );
	~CTabTransition();

// Dialog Data
	//{{AFX_DATA(CTabTransition)
	enum { IDD = IDD_TAB_TRANSITION };
	CStatic	m_staticIntroPrompt;
	CButton	m_checkIntro;
	CComboBox	m_comboToSegment;
	CComboBox	m_comboTransitionSegment;
	//}}AFX_DATA

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CTabTransition)
	public:
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CTabTransition)
	afx_msg void OnDestroy();
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnSelChangeComboToSegment();
	afx_msg void OnSelChangeComboTransitionSegment();
	afx_msg void OnCheckIntro();
	afx_msg void OnDoubleClickedCheckIntro();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

protected:
	void EnableControls( BOOL fEnable );
	void UpdateObject();
	void FillToSegmentComboBox();
	void FillTransitionSegmentComboBox();
	void SelectToSegment();
	void SelectTransitionSegment();

public:
	void SetObject( IDMUSProdPropPageObject* pIPropPageObject );
	void RefreshTab( void );

protected:
	IDMUSProdPropPageManager*	m_pIPageManager;
	IDMUSProdPropPageObject*	m_pIPropPageObject;
	PPGTabTransition			m_PPGTabTransition;
	BOOL						m_fNeedToDetach;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_TABTRANSITION_H__4B3A5402_6B29_11D1_89AE_00A0C9054129__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SongDesigner\TabTransition.cpp ===
// TabTransition.cpp : implementation file
//

#include "stdafx.h"
#include "SongDesignerDLL.h"
#include "resource.h"

#include "Song.h"
#include "TransitionPropPageObject.h"
#include "TabTransition.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CTabTransition property page

CTabTransition::CTabTransition( IDMUSProdPropPageManager* pIPageManager ) : CPropertyPage(CTabTransition::IDD)
{
	//{{AFX_DATA_INIT(CTabTransition)
	//}}AFX_DATA_INIT

	ASSERT( pIPageManager != NULL );

	m_pIPropPageObject = NULL;
	m_pIPageManager = pIPageManager;
	m_fNeedToDetach = FALSE;
}

CTabTransition::~CTabTransition()
{
	RELEASE( m_pIPropPageObject );
}


void CTabTransition::DoDataExchange(CDataExchange* pDX)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CTabTransition)
	DDX_Control(pDX, IDC_STATIC_INTRO_PROMPT, m_staticIntroPrompt);
	DDX_Control(pDX, IDC_CHECK_INTRO, m_checkIntro);
	DDX_Control(pDX, IDC_COMBO_TO_SEGMENT, m_comboToSegment);
	DDX_Control(pDX, IDC_COMBO_TRANSITION_SEGMENT, m_comboTransitionSegment);
	//}}AFX_DATA_MAP
}


/////////////////////////////////////////////////////////////////////////////
// CTabTransition::SetObject

void CTabTransition::SetObject( IDMUSProdPropPageObject* pIPropPageObject )
{
	if( m_pIPropPageObject )
	{
		m_pIPropPageObject->Release();
	}
	m_pIPropPageObject = pIPropPageObject;
	if( m_pIPropPageObject )
	{
		m_pIPropPageObject->AddRef();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabTransition::UpdateObject

void CTabTransition::UpdateObject()
{
	if( m_pIPropPageObject )
	{
		m_pIPropPageObject->SetData( (void *)&m_PPGTabTransition );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabTransition::FillToSegmentComboBox

void CTabTransition::FillToSegmentComboBox( void )
{
	// Empty combo box
	m_comboToSegment.ResetContent();

	// Add "<Any>"
	CString strName;
	strName.LoadString( IDS_ANY_TEXT );
	int nPos = m_comboToSegment.AddString( strName  );
	m_comboToSegment.SetItemDataPtr( nPos, (void *)(NULL + 1) );

	// Add "<None>"
	strName.LoadString( IDS_NONE_TEXT );
	nPos = m_comboToSegment.AddString( strName  );
	m_comboToSegment.SetItemDataPtr( nPos, NULL );

	// Add VirtualSegments
	CVirtualSegment* pVirtualSegment;
	for( int i = 0 ;  pVirtualSegment = m_PPGTabTransition.pSong->IndexToVirtualSegment(i) ;  i++ )
	{
		if( pVirtualSegment == NULL )
		{
			break;
		}

		pVirtualSegment->GetName( strName );
		nPos = m_comboToSegment.AddString( strName  );
		m_comboToSegment.SetItemDataPtr( nPos, pVirtualSegment );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabTransition::FillTransitionSegmentComboBox

void CTabTransition::FillTransitionSegmentComboBox( void )
{
	// Empty combo box
	m_comboTransitionSegment.ResetContent();

	// Add "<None>"
	CString strName;
	strName.LoadString( IDS_NONE_TEXT );
	int nPos = m_comboTransitionSegment.AddString( strName  );
	m_comboTransitionSegment.SetItemDataPtr( nPos, NULL );

	// Add VirtualSegments
	CVirtualSegment* pVirtualSegment;
	for( int i = 0 ;  pVirtualSegment = m_PPGTabTransition.pSong->IndexToVirtualSegment(i) ;  i++ )
	{
		if( pVirtualSegment == NULL )
		{
			break;
		}

		pVirtualSegment->GetName( strName );
		nPos = m_comboTransitionSegment.AddString( strName  );
		m_comboTransitionSegment.SetItemDataPtr( nPos, pVirtualSegment );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabTransition::SelectToSegment

void CTabTransition::SelectToSegment( void )
{
	CVirtualSegment* pTheVirtualSegment;

	if( m_PPGTabTransition.dwToSegmentFlag == DMUS_SONG_NOSEG )
	{
		pTheVirtualSegment = (CVirtualSegment *)NULL;
	}
	else if( m_PPGTabTransition.dwToSegmentFlag == DMUS_SONG_ANYSEG )
	{
		pTheVirtualSegment = (CVirtualSegment *)(NULL + 1);
	}
	else if( m_PPGTabTransition.dwToSegmentFlag == DMUS_SONG_NOFROMSEG )
	{
		PPGTransition ppgTransition;
		PPGTransition* pPPGTransition = &ppgTransition;

		if( m_pIPropPageObject 
		&& (SUCCEEDED (m_pIPropPageObject->GetData((void **)&pPPGTransition))) )
		{
			pTheVirtualSegment = ppgTransition.pVirtualSegmentToEdit;
		}
		else
		{
			ASSERT( 0 );	// Should not happen!
			pTheVirtualSegment = (CVirtualSegment *)NULL;
		}
	}
	else
	{
		pTheVirtualSegment = m_PPGTabTransition.pToSegment;
	}

	int nNbrItems = m_comboToSegment.GetCount();

	for( int nPos = 0 ;  nPos < nNbrItems ;  nPos++ )
	{
		CVirtualSegment* pVirtualSegmentList = (CVirtualSegment *)m_comboToSegment.GetItemDataPtr( nPos );

		if( pVirtualSegmentList == pTheVirtualSegment )
		{
			m_comboToSegment.SetCurSel( nPos );
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabTransition::SelectTransitionSegment

void CTabTransition::SelectTransitionSegment( void )
{
	int nNbrItems = m_comboTransitionSegment.GetCount();

	for( int nPos = 0 ;  nPos < nNbrItems ;  nPos++ )
	{
		CVirtualSegment* pVirtualSegmentList = (CVirtualSegment *)m_comboTransitionSegment.GetItemDataPtr( nPos );

		if( pVirtualSegmentList == m_PPGTabTransition.pTransitionSegment )
		{
			m_comboTransitionSegment.SetCurSel( nPos );
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabTransition::RefreshTab

void CTabTransition::RefreshTab( void )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Make sure controls have been created
	if( ::IsWindow(m_hWnd) == FALSE )
	{
		return;
	}

	if( m_pIPropPageObject == NULL )
	{
		EnableControls( FALSE );
		return;
	}

	PPGTabTransition *pPPGTabTransition = &m_PPGTabTransition;
	if( FAILED( m_pIPropPageObject->GetData( (void**)&pPPGTabTransition ) ) )
	{
		EnableControls( FALSE );
		return;
	}

	if( !(m_PPGTabTransition.dwFlagsUI & PROPF_ONE_SELECTED) )
	{
		EnableControls( FALSE );
		return;
	}

	// Prevent control notifications from being dispatched during RefreshTab
	_AFX_THREAD_STATE* pThreadState = AfxGetThreadState();
	HWND hWndOldLockout = pThreadState->m_hLockoutNotifyWindow;
	ASSERT(hWndOldLockout != m_hWnd);   // must not recurse
	pThreadState->m_hLockoutNotifyWindow = m_hWnd;

	EnableControls( TRUE );

	// "To" segment
	FillToSegmentComboBox();
	SelectToSegment();

	// "Transition" segment
	FillTransitionSegmentComboBox();
	SelectTransitionSegment();

	// "Intro" check box
	if( m_PPGTabTransition.dwToSegmentFlag == DMUS_SONG_NOFROMSEG )
	{
		m_checkIntro.SetCheck( 1 );
	}
	else
	{
		m_checkIntro.SetCheck( 0 );
	}

	pThreadState->m_hLockoutNotifyWindow = hWndOldLockout;
}


/////////////////////////////////////////////////////////////////////////////
// CTabTransition::EnableControls

void CTabTransition::EnableControls( BOOL fEnable ) 
{
	if( m_PPGTabTransition.dwToSegmentFlag == DMUS_SONG_NOFROMSEG )
	{
		m_comboToSegment.EnableWindow( FALSE );
		m_staticIntroPrompt.ShowWindow( SW_NORMAL );
	}
	else
	{
		m_comboToSegment.EnableWindow( fEnable );
		m_staticIntroPrompt.ShowWindow( SW_HIDE );
	}
	
	m_comboTransitionSegment.EnableWindow( fEnable );
	m_checkIntro.EnableWindow( fEnable );
	m_staticIntroPrompt.EnableWindow( fEnable );

	if( fEnable == FALSE )
	{
		m_comboToSegment.ResetContent();
		m_comboTransitionSegment.ResetContent();
		m_checkIntro.SetCheck( 0 );
		m_staticIntroPrompt.ShowWindow( SW_HIDE );
	}
}


BEGIN_MESSAGE_MAP(CTabTransition, CPropertyPage)
	//{{AFX_MSG_MAP(CTabTransition)
	ON_WM_DESTROY()
	ON_WM_CREATE()
	ON_CBN_SELCHANGE(IDC_COMBO_TO_SEGMENT, OnSelChangeComboToSegment)
	ON_CBN_SELCHANGE(IDC_COMBO_TRANSITION_SEGMENT, OnSelChangeComboTransitionSegment)
	ON_BN_CLICKED(IDC_CHECK_INTRO, OnCheckIntro)
	ON_BN_DOUBLECLICKED(IDC_CHECK_INTRO, OnDoubleClickedCheckIntro)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CTabTransition message handlers

/////////////////////////////////////////////////////////////////////////////
// CTabTransition::OnSetActive

BOOL CTabTransition::OnSetActive() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	RefreshTab();
	
	return CPropertyPage::OnSetActive();
}


/////////////////////////////////////////////////////////////////////////////
// CTabTransition::OnDestroy

void CTabTransition::OnDestroy() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Detach the window from the property page structure.
	// This will be done again by the main application since
	// it owns the property sheet.  It needs o be done here
	// so that the window handle can be removed from the
	// DLLs handle map.
	if( m_fNeedToDetach && m_hWnd )
	{
		HWND hWnd = m_hWnd;
		Detach();
		m_hWnd = hWnd;
	}

	CPropertyPage::OnDestroy();
}


/////////////////////////////////////////////////////////////////////////////
// CTabTransition::OnCreate

int CTabTransition::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Attach the window to the property page structure.
	// This has been done once already in the main application
	// since the main application owns the property sheet.
	// It needs to be done here so that the window handle can
	// be found in the DLLs handle map.
	if( !FromHandlePermanent( m_hWnd ) )
	{
		HWND hWnd = m_hWnd;
		m_hWnd = NULL;
		Attach( hWnd );
		m_fNeedToDetach = TRUE;
	}

	if( CPropertyPage::OnCreate(lpCreateStruct) == -1 )
	{
		return -1;
	}
	
	return 0;
}


/////////////////////////////////////////////////////////////////////////////
// CTabTransition::OnSelChangeComboToSegment

void CTabTransition::OnSelChangeComboToSegment( void ) 
{
	int nCurSel = m_comboToSegment.GetCurSel();
	if( nCurSel != CB_ERR )
	{
		CVirtualSegment* pVirtualSegment = (CVirtualSegment *)m_comboToSegment.GetItemDataPtr( nCurSel );

		if( pVirtualSegment != (CVirtualSegment *)0xFFFFFFFF )
		{
			DWORD dwToSegmentFlag = 0;
			if( pVirtualSegment == (CVirtualSegment *)NULL )
			{
				pVirtualSegment = NULL;
				dwToSegmentFlag = DMUS_SONG_NOSEG;
			}
			else if( pVirtualSegment == (CVirtualSegment *)(NULL + 1) )
			{
				pVirtualSegment = NULL;
				dwToSegmentFlag = DMUS_SONG_ANYSEG;
			}
			if( m_PPGTabTransition.pToSegment != pVirtualSegment 
			||  m_PPGTabTransition.dwToSegmentFlag != dwToSegmentFlag )
			{
				m_PPGTabTransition.pToSegment = pVirtualSegment;
				m_PPGTabTransition.dwToSegmentFlag = dwToSegmentFlag;
				UpdateObject();
			}
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabTransition::OnSelChangeComboTransitionSegment

void CTabTransition::OnSelChangeComboTransitionSegment( void ) 
{
	int nCurSel = m_comboTransitionSegment.GetCurSel();
	if( nCurSel != CB_ERR )
	{
		CVirtualSegment* pVirtualSegment = (CVirtualSegment *)m_comboTransitionSegment.GetItemDataPtr( nCurSel );

		if( pVirtualSegment != (CVirtualSegment *)0xFFFFFFFF )
		{
			if( m_PPGTabTransition.pTransitionSegment != pVirtualSegment )
			{
				m_PPGTabTransition.pTransitionSegment = pVirtualSegment;
				UpdateObject();
			}
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabTransition::OnCheckIntro

void CTabTransition::OnCheckIntro() 
{
	CVirtualSegment* pVirtualSegment;
	DWORD dwToSegmentFlag;

	if( m_checkIntro.GetCheck() )
	{
		pVirtualSegment = NULL;
		dwToSegmentFlag = DMUS_SONG_NOFROMSEG;
		m_comboToSegment.EnableWindow( FALSE );
		m_staticIntroPrompt.ShowWindow( SW_NORMAL );
	}
	else
	{
		pVirtualSegment = NULL;
		dwToSegmentFlag = DMUS_SONG_NOSEG;
		m_comboToSegment.EnableWindow( TRUE );
		m_staticIntroPrompt.ShowWindow( SW_HIDE );
	}

	if( m_PPGTabTransition.pToSegment != pVirtualSegment 
	||  m_PPGTabTransition.dwToSegmentFlag != dwToSegmentFlag )
	{
		m_PPGTabTransition.pToSegment = pVirtualSegment;
		m_PPGTabTransition.dwToSegmentFlag = dwToSegmentFlag;
		UpdateObject();
		RefreshTab();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabTransition::OnDoubleClickedCheckIntro

void CTabTransition::OnDoubleClickedCheckIntro() 
{
	OnCheckIntro();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SongDesigner\TabVirtualSegment.h ===
#if !defined(AFX_TABVIRTUALSEGMENT_H__4B3A5402_6B29_11D1_89AE_00A0C9054129__INCLUDED_)
#define AFX_TABVIRTUALSEGMENT_H__4B3A5402_6B29_11D1_89AE_00A0C9054129__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

// TabVirtualSegment.h : header file
//

typedef struct _PPGTabVirtualSegment
{
	_PPGTabVirtualSegment( void )
	{
		dwPageIndex = 1;
		dwNbrMeasures = 0;
		lStartMeasure = 0;
		lStartBeat = 0;
		lStartGrid = 0;
		lStartTick = 0;
		dwTimeSigGroupBits = 0;
		dwResolution = 0;
		dwFlagsUI = 0;
	}

	DWORD				dwPageIndex;
	CString				strName;
	DWORD				dwNbrMeasures;
	long				lStartMeasure;
	long				lStartBeat;
	long				lStartGrid;
	long				lStartTick;
	DWORD				dwTimeSigGroupBits;
	DWORD				dwResolution;
	DWORD				dwFlagsUI;
} PPGTabVirtualSegment;


#define TAB_VSEG_RESOLUTION_FLAGS	(DMUS_SEGF_TIMESIG_ALWAYS | DMUS_SEGF_USE_AUDIOPATH)


/////////////////////////////////////////////////////////////////////////////
// CTabVirtualSegment dialog

class CTabVirtualSegment : public CPropertyPage
{
// Construction
public:
	CTabVirtualSegment( IDMUSProdPropPageManager* pIPageManager );
	~CTabVirtualSegment();

// Dialog Data
	//{{AFX_DATA(CTabVirtualSegment)
	enum { IDD = IDD_TAB_VIRTUAL_SEGMENT };
	CEdit	m_editName;
	CButton	m_btnLength;
	CEdit	m_editStartMeasure;
	CEdit	m_editStartBeat;
	CEdit	m_editStartGrid;
	CEdit	m_editStartTick;
	CEdit	m_editTrackGroup;
	CSpinButtonCtrl	m_spinStartMeasure;
	CSpinButtonCtrl	m_spinStartBeat;
	CSpinButtonCtrl	m_spinStartGrid;
	CSpinButtonCtrl	m_spinStartTick;
	CSpinButtonCtrl	m_spinTrackGroup;
	CButton	m_checkExtendTimeSig;
	CButton	m_checkAudioPath;
	//}}AFX_DATA

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CTabVirtualSegment)
	public:
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CTabVirtualSegment)
	afx_msg void OnDestroy();
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnKillFocusEditName();
	afx_msg void OnCheckAudioPath();
	afx_msg void OnDoubleClickedCheckAudioPath();
	afx_msg void OnCheckExtendTimeSig();
	afx_msg void OnDoubleClickedCheckExtendTimeSig();
	afx_msg void OnSpinStartMeasure(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnSpinStartBeat(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnSpinStartGrid(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnSpinStartTick(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnSpinTrackGroup(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnKillFocusStartMeasure();
	afx_msg void OnKillFocusStartBeat();
	afx_msg void OnKillFocusStartGrid();
	afx_msg void OnKillFocusStartTick();
	afx_msg void OnKillFocusTrackGroup();
	afx_msg void OnButtonLength();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

protected:
	void EnableControls( BOOL fEnable );
	void UpdateObject();
	void SetEditControl( CEdit& edit, long lValue, int nOffset );
	bool HandleKillFocus( CSpinButtonCtrl& spin, long& lUpdateVal, int nOffset );
	bool HandleKillFocus( CSpinButtonCtrl& spin, DWORD& dwUpdateVal, int nOffset );
	bool HandleDeltaChange( NMHDR* pNMHDR, LRESULT* pResult, long& lUpdateVal );

public:
	void SetObject( IDMUSProdPropPageObject* pIPropPageObject );
	void RefreshTab( void );

protected:
	IDMUSProdPropPageManager*		m_pIPageManager;
	IDMUSProdPropPageObject*		m_pIPropPageObject;
	PPGTabVirtualSegment			m_PPGTabVirtualSegment;
	long							m_lTrackGroupBits;
	BOOL							m_fNeedToDetach;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_TABVIRTUALSEGMENT_H__4B3A5402_6B29_11D1_89AE_00A0C9054129__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SongDesigner\TabSong.cpp ===
// TabSong.cpp : implementation file
//

#include "stdafx.h"
#include "TabSong.h"
#include "SongDesignerDll.h"
#include "Song.h"
#include <dmusicf.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CTabSong property page

CTabSong::CTabSong( CSongPropPageManager* pSongPropPageManager ) : CPropertyPage(CTabSong::IDD)
{
	//{{AFX_DATA_INIT(CTabSong)
	//}}AFX_DATA_INIT
	
	ASSERT( pSongPropPageManager != NULL );

	m_pSong = NULL;
	m_pPageManager = pSongPropPageManager;
	m_fNeedToDetach = FALSE;
}

CTabSong::~CTabSong()
{
}


/////////////////////////////////////////////////////////////////////////////
// CTabSong::SetSong

void CTabSong::SetSong( CDirectMusicSong* pSong )
{
	m_pSong = pSong;

	UpdateControls();
}


/////////////////////////////////////////////////////////////////////////////
// CTabSong::EnableControls

void CTabSong::EnableControls( BOOL fEnable ) 
{
	m_editName.EnableWindow( fEnable );
}


/////////////////////////////////////////////////////////////////////////////
// CTabSong::UpdateControls

void CTabSong::UpdateControls() 
{
	// Make sure controls have been created
	if( ::IsWindow(m_editName.m_hWnd) == FALSE )
	{
		return;
	}
	
	// Update controls
	m_editName.LimitText( DMUS_MAX_NAME );

	if( m_pSong )
	{
		EnableControls( TRUE );

		// Set name
		m_editName.SetWindowText( m_pSong->m_strName );
	}
	else
	{
		m_editName.SetWindowText( _T("") );

		EnableControls( FALSE );
	}
}


void CTabSong::DoDataExchange(CDataExchange* pDX)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CTabSong)
	DDX_Control(pDX, IDC_NAME, m_editName);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CTabSong, CPropertyPage)
	//{{AFX_MSG_MAP(CTabSong)
	ON_WM_CREATE()
	ON_WM_DESTROY()
	ON_EN_KILLFOCUS(IDC_NAME, OnKillFocusName)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CTabSong message handlers


/////////////////////////////////////////////////////////////////////////////
// CTabSong::OnInitDialog

BOOL CTabSong::OnInitDialog() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CPropertyPage::OnInitDialog();
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}


/////////////////////////////////////////////////////////////////////////////
// CTabSong::OnSetActive

BOOL CTabSong::OnSetActive() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	UpdateControls();

	// Store active tab
	m_pPageManager->m_pIPropSheet->GetActivePage( &CSongPropPageManager::sm_nActiveTab );

	return CPropertyPage::OnSetActive();
}


/////////////////////////////////////////////////////////////////////////////
// CTabSong::OnCreate

int CTabSong::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Attach the window to the property page structure.
	// This has been done once already in the main application
	// since the main application owns the property sheet.
	// It needs to be done here so that the window handle can
	// be found in the DLLs handle map.
	if( !FromHandlePermanent( m_hWnd ) )
	{
		HWND hWnd = m_hWnd;
		m_hWnd = NULL;
		Attach( hWnd );
		m_fNeedToDetach = TRUE;
	}

	if( CPropertyPage::OnCreate(lpCreateStruct) == -1 )
	{
		return -1;
	}
	
	return 0;
}


/////////////////////////////////////////////////////////////////////////////
// CTabSong::OnDestroy

void CTabSong::OnDestroy() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Detach the window from the property page structure.
	// This will be done again by the main application since
	// it owns the property sheet.  It needs o be done here
	// so that the window handle can be removed from the
	// DLLs handle map.
	if( m_fNeedToDetach && m_hWnd )
	{
		HWND hWnd = m_hWnd;
		Detach();
		m_hWnd = hWnd;
	}

	CPropertyPage::OnDestroy();
}


/////////////////////////////////////////////////////////////////////////////
// CTabSong::OnKillFocusName

void CTabSong::OnKillFocusName() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( theApp.m_pSongComponent != NULL );
	ASSERT( theApp.m_pSongComponent->m_pIFramework8 != NULL );

	if( m_pSong )
	{
		CString strName;

		m_editName.GetWindowText( strName );

		// Strip leading and trailing spaces
		strName.TrimRight();
		strName.TrimLeft();

		if( strName.IsEmpty() )
		{
			m_editName.SetWindowText( m_pSong->m_strName );
		}
		else
		{
			if( strName.Compare( m_pSong->m_strName ) != 0 )
			{
				BSTR bstrName = strName.AllocSysString();
				m_pSong->SetNodeName( bstrName );
				theApp.m_pSongComponent->m_pIFramework8->RefreshNode( m_pSong );
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SongDesigner\TabVirtualSegment.cpp ===
// TabVirtualSegment.cpp : implementation file
//

#include "stdafx.h"
#include "SongDesignerDLL.h"
#include "resource.h"

#include "Song.h"
#include "TabVirtualSegment.h"
#include "DlgSetLength.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


// Length (in characters) of the string to allocate to store text entered in
// the measure/beat/grid/tick edit boxes
#define DIALOG_EDIT_LEN 15

#define MAX_TICK (DMUS_PPQ << 1)


/////////////////////////////////////////////////////////////////////////////
// CTabVirtualSegment property page

CTabVirtualSegment::CTabVirtualSegment( IDMUSProdPropPageManager* pIPageManager ) : CPropertyPage(CTabVirtualSegment::IDD)
{
	//{{AFX_DATA_INIT(CTabVirtualSegment)
	//}}AFX_DATA_INIT

	ASSERT( pIPageManager != NULL );

	m_pIPropPageObject = NULL;
	m_pIPageManager = pIPageManager;
	m_lTrackGroupBits = 0;
	m_fNeedToDetach = FALSE;
}

CTabVirtualSegment::~CTabVirtualSegment()
{
	RELEASE( m_pIPropPageObject );
}


void CTabVirtualSegment::DoDataExchange(CDataExchange* pDX)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CTabVirtualSegment)
	DDX_Control(pDX, IDC_EDIT_NAME, m_editName);
	DDX_Control(pDX, IDC_BUTTON_LENGTH, m_btnLength);
	DDX_Control(pDX, IDC_EDIT_PLAY_START_BAR, m_editStartMeasure);
	DDX_Control(pDX, IDC_EDIT_PLAY_START_BEAT, m_editStartBeat);
	DDX_Control(pDX, IDC_EDIT_PLAY_START_GRID, m_editStartGrid);
	DDX_Control(pDX, IDC_EDIT_PLAY_START_TICK, m_editStartTick);
	DDX_Control(pDX, IDC_EDIT_TRACK_GROUP, m_editTrackGroup);
	DDX_Control(pDX, IDC_SPIN_PLAY_START_BAR, m_spinStartMeasure);
	DDX_Control(pDX, IDC_SPIN_PLAY_START_BEAT, m_spinStartBeat);
	DDX_Control(pDX, IDC_SPIN_PLAY_START_GRID, m_spinStartGrid);
	DDX_Control(pDX, IDC_SPIN_PLAY_START_TICK, m_spinStartTick);
	DDX_Control(pDX, IDC_SPIN_TRACK_GROUP, m_spinTrackGroup);
	DDX_Control(pDX, IDC_CHECK_EXTEND_TIMESIG, m_checkExtendTimeSig);
	DDX_Control(pDX, IDC_CHECK_AUDIOPATH, m_checkAudioPath);
	//}}AFX_DATA_MAP
}


/////////////////////////////////////////////////////////////////////////////
// CTabVirtualSegment::SetObject

void CTabVirtualSegment::SetObject( IDMUSProdPropPageObject* pIPropPageObject )
{
	if( m_pIPropPageObject )
	{
		m_pIPropPageObject->Release();
	}
	m_pIPropPageObject = pIPropPageObject;
	if( m_pIPropPageObject )
	{
		m_pIPropPageObject->AddRef();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabVirtualSegment::UpdateObject

void CTabVirtualSegment::UpdateObject()
{
	if( m_pIPropPageObject )
	{
		m_pIPropPageObject->SetData( (void *)&m_PPGTabVirtualSegment );
	}

	RefreshTab();
}


/////////////////////////////////////////////////////////////////////////////
// CTabVirtualSegment::RefreshTab

void CTabVirtualSegment::RefreshTab( void )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Make sure controls have been created
	if( ::IsWindow(m_hWnd) == FALSE )
	{
		return;
	}

	if( m_pIPropPageObject == NULL )
	{
		EnableControls( FALSE );
		return;
	}

	PPGTabVirtualSegment *pPPGTabVirtualSegment= &m_PPGTabVirtualSegment;
	if( FAILED( m_pIPropPageObject->GetData( (void**)&pPPGTabVirtualSegment ) ) )
	{
		EnableControls( FALSE );
		return;
	}

	if( !(m_PPGTabVirtualSegment.dwFlagsUI & PROPF_ONE_SELECTED) )
	{
		EnableControls( FALSE );
		return;
	}

	// Prevent control notifications from being dispatched during RefreshTab
	_AFX_THREAD_STATE* pThreadState = AfxGetThreadState();
	HWND hWndOldLockout = pThreadState->m_hLockoutNotifyWindow;
	ASSERT(hWndOldLockout != m_hWnd);   // must not recurse
	pThreadState->m_hLockoutNotifyWindow = m_hWnd;

	EnableControls( TRUE );

	// "Name"
	m_editName.SetWindowText( m_PPGTabVirtualSegment.strName );

	if( m_PPGTabVirtualSegment.dwFlagsUI & PROPF_TIME_CONVERSIONS_OK )
	{
		// "Nbr Measures"
		CString strNbrMeasures;
		strNbrMeasures.Format( "%ld", m_PPGTabVirtualSegment.dwNbrMeasures );
		m_btnLength.SetWindowText( strNbrMeasures );

		// "Start Offset"
		SetEditControl( m_editStartMeasure, m_PPGTabVirtualSegment.lStartMeasure, 1 );
		SetEditControl( m_editStartBeat, m_PPGTabVirtualSegment.lStartBeat, 1 );
		SetEditControl( m_editStartGrid, m_PPGTabVirtualSegment.lStartGrid, 1 );
		SetEditControl( m_editStartTick, m_PPGTabVirtualSegment.lStartTick, 0 );

		// "TimeSig Track Group"
		DWORD dwTimeSigGroupBits = m_PPGTabVirtualSegment.dwTimeSigGroupBits;
		m_lTrackGroupBits = 0;
		while( dwTimeSigGroupBits )
		{
			m_lTrackGroupBits++;
			dwTimeSigGroupBits = dwTimeSigGroupBits >> 1;
		}
		m_spinTrackGroup.SetPos( m_lTrackGroupBits );
	}

	// "Extend TimeSig" flag
	m_checkExtendTimeSig.SetCheck( (m_PPGTabVirtualSegment.dwResolution & DMUS_SEGF_TIMESIG_ALWAYS) ? 1 : 0 );

	// "AudioPath" flag
//  m_checkAudioPath not supported in DX8
//	m_checkAudioPath.SetCheck( ((m_PPGTabVirtualSegment.dwResolution & DMUS_SEGF_USE_AUDIOPATH) && (m_PPGTabVirtualSegment.dwFlagsUI & PROPF_HAVE_AUDIOPATH)) ? 1 : 0 );

	pThreadState->m_hLockoutNotifyWindow = hWndOldLockout;
}


/////////////////////////////////////////////////////////////////////////////
// CTabVirtualSegment::EnableControls

void CTabVirtualSegment::EnableControls( BOOL fEnable ) 
{
	m_editName.EnableWindow( fEnable );
	m_checkExtendTimeSig.EnableWindow( fEnable );
	if( fEnable == FALSE )
	{
		m_editName.SetWindowText( NULL );
		m_checkExtendTimeSig.SetCheck( 0 );
	}

	BOOL fEnableTimeConversions = fEnable;
	if( !(m_PPGTabVirtualSegment.dwFlagsUI & PROPF_TIME_CONVERSIONS_OK) )
	{
		fEnableTimeConversions = FALSE;
	}
	m_btnLength.EnableWindow( fEnableTimeConversions );
	m_editStartMeasure.EnableWindow( fEnableTimeConversions );
	m_editStartBeat.EnableWindow( fEnableTimeConversions );
	m_editStartGrid.EnableWindow( fEnableTimeConversions );
	m_editStartTick.EnableWindow( fEnableTimeConversions );
	m_editTrackGroup.EnableWindow( fEnableTimeConversions );
	m_spinStartMeasure.EnableWindow( fEnableTimeConversions );
	m_spinStartBeat.EnableWindow( fEnableTimeConversions );
	m_spinStartGrid.EnableWindow( fEnableTimeConversions );
	m_spinStartTick.EnableWindow( fEnableTimeConversions );
	m_spinTrackGroup.EnableWindow( fEnableTimeConversions );
	if( fEnableTimeConversions == FALSE )
	{
		m_btnLength.SetWindowText( NULL );
		m_editStartMeasure.SetWindowText( NULL );
		m_editStartBeat.SetWindowText( NULL );
		m_editStartGrid.SetWindowText( NULL );
		m_editStartTick.SetWindowText( NULL );
		m_editTrackGroup.SetWindowText( NULL );
	}

	BOOL fEnableAudioPath = fEnable;
	if( !(m_PPGTabVirtualSegment.dwFlagsUI & PROPF_HAVE_AUDIOPATH) )
	{
		fEnableAudioPath = FALSE;
	}
//  m_checkAudioPath not supported in DX8 /////////
	fEnableAudioPath = FALSE;
///////////////////////////////////////////////////
	m_checkAudioPath.EnableWindow( fEnableAudioPath );
	if( fEnableAudioPath == FALSE )
	{
		m_checkAudioPath.SetCheck( 0 );
	}
}
	

/////////////////////////////////////////////////////////////////////////////
// CTabVirtualSegment::SetEditControl

void CTabVirtualSegment::SetEditControl( CEdit& edit, long lValue, int nOffset )
{
	TCHAR tcstrTmp[DIALOG_EDIT_LEN];
	BOOL fTransSuccess;

	edit.GetWindowText( tcstrTmp, DIALOG_EDIT_LEN );

	// Convert from text to an integer
	long lCurValue = GetDlgItemInt( edit.GetDlgCtrlID(), &fTransSuccess, TRUE );

	// Check if the conversion failed, the text is empty, or if the values are different
	if( !fTransSuccess
	|| (tcstrTmp[0] == NULL)
	|| (lCurValue != lValue + nOffset) )
	{
		// Update the displayed number
		SetDlgItemInt( edit.GetDlgCtrlID(), lValue + nOffset );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabVirtualSegment::HandleKillFocus
//
// Generic handler for KillFocus changes
bool CTabVirtualSegment::HandleKillFocus( CSpinButtonCtrl& spin, long& lUpdateVal, int nOffset )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Check if the spin control is a valid window
	if (!::IsWindow(spin.m_hWnd))
	{
		return false;
	}

	// Get text from edit control
	TCHAR tcstrTmp[DIALOG_EDIT_LEN];
	CWnd* pEditCtrl = spin.GetBuddy();
	ASSERT(pEditCtrl != NULL);
	if( pEditCtrl == NULL )
	{
		return false;
	}
	pEditCtrl->GetWindowText( tcstrTmp, DIALOG_EDIT_LEN );

	bool fChanged = false;

	// Handle empty text
	if( tcstrTmp[0] == NULL )
	{
		// Set it back to the minimum value
		spin.SetPos( nOffset );

		// Check if the value changed
		if( lUpdateVal != 0 )
		{
			// Update the item with the new value
			lUpdateVal = 0;
			fChanged = true;
		}
	}
	else
	{
		// Convert from text to an integer
		BOOL fTransSuccess;
		long lNewValue = GetDlgItemInt( pEditCtrl->GetDlgCtrlID(), &fTransSuccess, TRUE );

		// If unable to translate (if dialog contains invalid data, such as '-'), exit early
		if( !fTransSuccess )
		{
			// If conversion failed, update dialog item text
			SetDlgItemInt( pEditCtrl->GetDlgCtrlID(), lUpdateVal + nOffset );
		}
		// If conversion succeeded, ensure the value stays in range
		else
		{
			// Get the valid range
			int iLower, iUpper;
			spin.GetRange( iLower, iUpper );

			// Check if the value is out of range
			if( lNewValue > iUpper )
			{
				// Value out of range, update dialog item text
				SetDlgItemInt( pEditCtrl->GetDlgCtrlID(), iUpper );

				// Update the value to the top of the range
				lNewValue = iUpper;
			}

			// Check if the value changed
			if( lUpdateVal != (lNewValue - nOffset) )
			{
				// Update the item with the new value
				lUpdateVal = (lNewValue - nOffset);
				fChanged = true;
			}
		}
	}

	return fChanged;
}


/////////////////////////////////////////////////////////////////////////////
// CTabVirtualSegment::HandleKillFocus
//
// Generic handler for KillFocus changes
bool CTabVirtualSegment::HandleKillFocus( CSpinButtonCtrl& spin, DWORD& dwUpdateVal, int nOffset )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Check if the spin control is a valid window
	if (!::IsWindow(spin.m_hWnd))
	{
		return false;
	}

	// Get text from edit control
	TCHAR tcstrTmp[DIALOG_EDIT_LEN];
	CWnd* pEditCtrl = spin.GetBuddy();
	ASSERT(pEditCtrl != NULL);
	if( pEditCtrl == NULL )
	{
		return false;
	}
	pEditCtrl->GetWindowText( tcstrTmp, DIALOG_EDIT_LEN );

	bool fChanged = false;

	// Handle empty text
	if( tcstrTmp[0] == NULL )
	{
		// Set it back to the minimum value
		spin.SetPos( nOffset );

		// Check if the value changed
		if( dwUpdateVal != 0 )
		{
			// Update the item with the new value
			dwUpdateVal = 0;
			fChanged = true;
		}
	}
	else
	{
		// Convert from text to an integer
		BOOL fTransSuccess;
		long lNewValue = GetDlgItemInt( pEditCtrl->GetDlgCtrlID(), &fTransSuccess, TRUE );

		// If unable to translate (if dialog contains invalid data, such as '-'), exit early
		if( !fTransSuccess )
		{
			// If conversion failed, update dialog item text
			SetDlgItemInt( pEditCtrl->GetDlgCtrlID(), dwUpdateVal + nOffset );
		}
		// If conversion succeeded, ensure the value stays in range
		else
		{
			// Get the valid range
			int iLower, iUpper;
			spin.GetRange( iLower, iUpper );

			// Check if the value is out of range
			if( lNewValue > iUpper )
			{
				// Value out of range, update dialog item text
				SetDlgItemInt( pEditCtrl->GetDlgCtrlID(), iUpper );

				// Update the value to the top of the range
				lNewValue = iUpper;
			}

			// Check if the value changed
			if( dwUpdateVal != (DWORD)(lNewValue - nOffset) )
			{
				// Update the item with the new value
				dwUpdateVal = (DWORD)(lNewValue - nOffset);
				fChanged = true;
			}
		}
	}

	return fChanged;
}


/////////////////////////////////////////////////////////////////////////////
// CTabVirtualSegment::HandleDeltaChange
//
// Generic handler for deltapos changes
bool CTabVirtualSegment::HandleDeltaChange( NMHDR* pNMHDR, LRESULT* pResult, long& lUpdateVal )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	bool fChanged = false;

	// If the value changed - update the selected item
	if( ((NM_UPDOWN* )pNMHDR)->iDelta != 0 ) 
	{
		// Update the value
		lUpdateVal += ((NM_UPDOWN* )pNMHDR)->iDelta;
		fChanged = true;
	}

	// Set the result to 1 to show that we handled this message
	*pResult = 1;

	return fChanged;
}


BEGIN_MESSAGE_MAP(CTabVirtualSegment, CPropertyPage)
	//{{AFX_MSG_MAP(CTabVirtualSegment)
	ON_WM_DESTROY()
	ON_WM_CREATE()
	ON_EN_KILLFOCUS(IDC_EDIT_NAME, OnKillFocusEditName)
	ON_BN_CLICKED(IDC_CHECK_AUDIOPATH, OnCheckAudioPath)
	ON_BN_DOUBLECLICKED(IDC_CHECK_AUDIOPATH, OnDoubleClickedCheckAudioPath)
	ON_BN_CLICKED(IDC_CHECK_EXTEND_TIMESIG, OnCheckExtendTimeSig)
	ON_BN_DOUBLECLICKED(IDC_CHECK_EXTEND_TIMESIG, OnDoubleClickedCheckExtendTimeSig)
	ON_NOTIFY(UDN_DELTAPOS, IDC_SPIN_PLAY_START_BAR, OnSpinStartMeasure)
	ON_NOTIFY(UDN_DELTAPOS, IDC_SPIN_PLAY_START_BEAT, OnSpinStartBeat)
	ON_NOTIFY(UDN_DELTAPOS, IDC_SPIN_PLAY_START_GRID, OnSpinStartGrid)
	ON_NOTIFY(UDN_DELTAPOS, IDC_SPIN_PLAY_START_TICK, OnSpinStartTick)
	ON_NOTIFY(UDN_DELTAPOS, IDC_SPIN_TRACK_GROUP, OnSpinTrackGroup)
	ON_EN_KILLFOCUS(IDC_EDIT_PLAY_START_BAR, OnKillFocusStartMeasure)
	ON_EN_KILLFOCUS(IDC_EDIT_PLAY_START_BEAT, OnKillFocusStartBeat)
	ON_EN_KILLFOCUS(IDC_EDIT_PLAY_START_GRID, OnKillFocusStartGrid)
	ON_EN_KILLFOCUS(IDC_EDIT_PLAY_START_TICK, OnKillFocusStartTick)
	ON_EN_KILLFOCUS(IDC_EDIT_TRACK_GROUP, OnKillFocusTrackGroup)
	ON_BN_CLICKED(IDC_BUTTON_LENGTH, OnButtonLength)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CTabVirtualSegment message handlers

/////////////////////////////////////////////////////////////////////////////
// CTabVirtualSegment::OnSetActive

BOOL CTabVirtualSegment::OnSetActive() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Set limits for edit controls
	m_editName.LimitText( DMUS_MAX_NAME );
	m_editStartMeasure.LimitText( 5 );
	m_editStartBeat.LimitText( 3 );
	m_editStartGrid.LimitText( 3 );
	m_editStartTick.LimitText( 5 );
	m_editTrackGroup.LimitText( 2 );

	// Set ranges of spin controls
	m_spinStartMeasure.SetRange( 1, 32767 );
	m_spinStartBeat.SetRange( 1, 256 );
	m_spinStartGrid.SetRange( 1, 256 );
	m_spinStartTick.SetRange( -MAX_TICK, MAX_TICK );
	m_spinTrackGroup.SetRange( 1, 32 );

	// Refresh the tab
	RefreshTab();
	
	return CPropertyPage::OnSetActive();
}


/////////////////////////////////////////////////////////////////////////////
// CTabVirtualSegment::OnDestroy

void CTabVirtualSegment::OnDestroy() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Detach the window from the property page structure.
	// This will be done again by the main application since
	// it owns the property sheet.  It needs o be done here
	// so that the window handle can be removed from the
	// DLLs handle map.
	if( m_fNeedToDetach && m_hWnd )
	{
		HWND hWnd = m_hWnd;
		Detach();
		m_hWnd = hWnd;
	}

	CPropertyPage::OnDestroy();
}


/////////////////////////////////////////////////////////////////////////////
// CTabVirtualSegment::OnCreate

int CTabVirtualSegment::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Attach the window to the property page structure.
	// This has been done once already in the main application
	// since the main application owns the property sheet.
	// It needs to be done here so that the window handle can
	// be found in the DLLs handle map.
	if( !FromHandlePermanent( m_hWnd ) )
	{
		HWND hWnd = m_hWnd;
		m_hWnd = NULL;
		Attach( hWnd );
		m_fNeedToDetach = TRUE;
	}

	if( CPropertyPage::OnCreate(lpCreateStruct) == -1 )
	{
		return -1;
	}
	
	return 0;
}


/////////////////////////////////////////////////////////////////////////////
// CTabVirtualSegment::OnKillFocusEditName

void CTabVirtualSegment::OnKillFocusEditName( void ) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CString strName;
	m_editName.GetWindowText( strName );

	// Strip leading and trailing spaces
	strName.TrimRight();
	strName.TrimLeft();

	if( strName.IsEmpty() )
	{
		m_editName.SetWindowText( m_PPGTabVirtualSegment.strName );
	}
	else
	{
		if( strName.Compare( m_PPGTabVirtualSegment.strName ) != 0 )
		{
			m_PPGTabVirtualSegment.strName = strName;
			UpdateObject();
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabVirtualSegment::OnCheckAudioPath

void CTabVirtualSegment::OnCheckAudioPath() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_PPGTabVirtualSegment.dwFlagsUI & PROPF_HAVE_AUDIOPATH );

	DWORD dwNewFlag = 0;
	if( m_checkAudioPath.GetCheck() )
	{
		dwNewFlag = DMUS_SEGF_USE_AUDIOPATH;
	}

	if( dwNewFlag != (m_PPGTabVirtualSegment.dwResolution & DMUS_SEGF_USE_AUDIOPATH) )
	{
		m_PPGTabVirtualSegment.dwResolution ^= DMUS_SEGF_USE_AUDIOPATH;
		UpdateObject();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabVirtualSegment::OnDoubleClickedCheckAudioPath

void CTabVirtualSegment::OnDoubleClickedCheckAudioPath() 
{
	OnCheckAudioPath();
}


/////////////////////////////////////////////////////////////////////////////
// CTabVirtualSegment::OnCheckExtendTimeSig

void CTabVirtualSegment::OnCheckExtendTimeSig() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	DWORD dwNewFlag = 0;
	if( m_checkExtendTimeSig.GetCheck() )
	{
		dwNewFlag = DMUS_SEGF_TIMESIG_ALWAYS;
	}

	if( dwNewFlag != (m_PPGTabVirtualSegment.dwResolution & DMUS_SEGF_TIMESIG_ALWAYS) )
	{
		m_PPGTabVirtualSegment.dwResolution ^= DMUS_SEGF_TIMESIG_ALWAYS;
		UpdateObject();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabVirtualSegment::OnDoubleClickedCheckExtendTimeSig

void CTabVirtualSegment::OnDoubleClickedCheckExtendTimeSig() 
{
	OnCheckExtendTimeSig();
}


/////////////////////////////////////////////////////////////////////////////
// CTabVirtualSegment::OnSpinStartMeasure

void CTabVirtualSegment::OnSpinStartMeasure( NMHDR* pNMHDR, LRESULT* pResult ) 
{
	// Need to do this in case the user clicked the spin control immediately after
	// typing in a value
	OnKillFocusStartMeasure();

	if( HandleDeltaChange( pNMHDR, pResult, m_PPGTabVirtualSegment.lStartMeasure ) )
	{
		UpdateObject();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabVirtualSegment::OnSpinStartBeat

void CTabVirtualSegment::OnSpinStartBeat( NMHDR* pNMHDR, LRESULT* pResult ) 
{
	// Need to do this in case the user clicked the spin control immediately after
	// typing in a value
	OnKillFocusStartBeat();

	if( HandleDeltaChange( pNMHDR, pResult, m_PPGTabVirtualSegment.lStartBeat ) )
	{
		UpdateObject();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabVirtualSegment::OnSpinStartGrid

void CTabVirtualSegment::OnSpinStartGrid( NMHDR* pNMHDR, LRESULT* pResult ) 
{
	// Need to do this in case the user clicked the spin control immediately after
	// typing in a value
	OnKillFocusStartGrid();

	if( HandleDeltaChange( pNMHDR, pResult, m_PPGTabVirtualSegment.lStartGrid ) )
	{
		UpdateObject();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabVirtualSegment::OnSpinStartTick

void CTabVirtualSegment::OnSpinStartTick( NMHDR* pNMHDR, LRESULT* pResult ) 
{
	// Need to do this in case the user clicked the spin control immediately after
	// typing in a value
	OnKillFocusStartTick();

	if( HandleDeltaChange( pNMHDR, pResult, m_PPGTabVirtualSegment.lStartTick ) )
	{
		UpdateObject();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabVirtualSegment::OnSpinTrackGroup

void CTabVirtualSegment::OnSpinTrackGroup( NMHDR* pNMHDR, LRESULT* pResult ) 
{
	// Need to do this in case the user clicked the spin control immediately after
	// typing in a value
	OnKillFocusTrackGroup();

	if( HandleDeltaChange( pNMHDR, pResult, m_lTrackGroupBits ) )
	{
		m_lTrackGroupBits = min( m_lTrackGroupBits, 32 );
		m_lTrackGroupBits = max( m_lTrackGroupBits, 1 );
		m_lTrackGroupBits--;

		DWORD dwTimeSigGroupBits = (1 << m_lTrackGroupBits);

		if( dwTimeSigGroupBits != m_PPGTabVirtualSegment.dwTimeSigGroupBits )
		{
			m_PPGTabVirtualSegment.dwTimeSigGroupBits = dwTimeSigGroupBits;
			UpdateObject();
		}
		else
		{
			RefreshTab();
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabVirtualSegment::OnKillFocusStartMeasure

void CTabVirtualSegment::OnKillFocusStartMeasure() 
{
	if( HandleKillFocus( m_spinStartMeasure, m_PPGTabVirtualSegment.lStartMeasure, 1 ) )
	{
		UpdateObject();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabVirtualSegment::OnKillFocusStartBeat

void CTabVirtualSegment::OnKillFocusStartBeat() 
{
	if( HandleKillFocus( m_spinStartBeat, m_PPGTabVirtualSegment.lStartBeat, 1 ) )
	{
		UpdateObject();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabVirtualSegment::OnKillFocusStartGrid

void CTabVirtualSegment::OnKillFocusStartGrid() 
{
	if( HandleKillFocus( m_spinStartGrid, m_PPGTabVirtualSegment.lStartGrid, 1 ) )
	{
		UpdateObject();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabVirtualSegment::OnKillFocusStartTick

void CTabVirtualSegment::OnKillFocusStartTick() 
{
	if( HandleKillFocus( m_spinStartTick, m_PPGTabVirtualSegment.lStartTick, 0 ) )
	{
		UpdateObject();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabVirtualSegment::OnKillFocusTrackGroup

void CTabVirtualSegment::OnKillFocusTrackGroup() 
{
	if( HandleKillFocus( m_spinTrackGroup, m_lTrackGroupBits, 0 ) )
	{
		m_lTrackGroupBits = min( m_lTrackGroupBits, 32 );
		m_lTrackGroupBits = max( m_lTrackGroupBits, 1 );
		m_lTrackGroupBits--;

		DWORD dwTimeSigGroupBits = (1 << m_lTrackGroupBits);

		if( dwTimeSigGroupBits != m_PPGTabVirtualSegment.dwTimeSigGroupBits )
		{
			m_PPGTabVirtualSegment.dwTimeSigGroupBits = dwTimeSigGroupBits;
			UpdateObject();
		}
		else
		{
			RefreshTab();
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabVirtualSegment::OnButtonLength

void CTabVirtualSegment::OnButtonLength() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CDlgSetLength dlgSetLength;
	dlgSetLength.m_dwNbrMeasures = m_PPGTabVirtualSegment.dwNbrMeasures;

	if( dlgSetLength.DoModal() == IDOK )
	{
		if( dlgSetLength.m_dwNbrMeasures != m_PPGTabVirtualSegment.dwNbrMeasures )
		{
			m_PPGTabVirtualSegment.dwNbrMeasures = dlgSetLength.m_dwNbrMeasures;
			UpdateObject();
		}
	}

	m_btnLength.SetFocus();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SongDesigner\TabVirtualSegmentLoop.cpp ===
// TabVirtualSegmentLoop.cpp : implementation file
//

#include "stdafx.h"
#include "SongDesignerDLL.h"
#include "resource.h"

#include "Song.h"
#include "TabVirtualSegmentLoop.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


// Length (in characters) of the string to allocate to store text entered in
// the measure/beat/grid/tick edit boxes
#define DIALOG_EDIT_LEN 15

#define MAX_TICK (DMUS_PPQ << 1)


/////////////////////////////////////////////////////////////////////////////
// CTabVirtualSegmentLoop property page

CTabVirtualSegmentLoop::CTabVirtualSegmentLoop( IDMUSProdPropPageManager* pIPageManager ) : CPropertyPage(CTabVirtualSegmentLoop::IDD)
{
	//{{AFX_DATA_INIT(CTabVirtualSegmentLoop)
	//}}AFX_DATA_INIT

	ASSERT( pIPageManager != NULL );

	m_pIPropPageObject = NULL;
	m_pIPageManager = pIPageManager;
	m_fNeedToDetach = FALSE;
}

CTabVirtualSegmentLoop::~CTabVirtualSegmentLoop()
{
	RELEASE( m_pIPropPageObject );
}


void CTabVirtualSegmentLoop::DoDataExchange(CDataExchange* pDX)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CTabVirtualSegmentLoop)
	DDX_Control(pDX, IDC_EDIT_LOOP_REPEAT, m_editLoopRepeat);
	DDX_Control(pDX, IDC_SPIN_LOOP_REPEAT, m_spinLoopRepeat);
	DDX_Control(pDX, IDC_CHECK_REPEAT_FOREVER, m_btnLoopInfinite);
	DDX_Control(pDX, IDC_EDIT_LOOP_START_BAR, m_editStartMeasure);
	DDX_Control(pDX, IDC_EDIT_LOOP_START_BEAT, m_editStartBeat);
	DDX_Control(pDX, IDC_EDIT_LOOP_START_GRID, m_editStartGrid);
	DDX_Control(pDX, IDC_EDIT_LOOP_START_TICK, m_editStartTick);
	DDX_Control(pDX, IDC_EDIT_LOOP_END_BAR, m_editEndMeasure);
	DDX_Control(pDX, IDC_EDIT_LOOP_END_BEAT, m_editEndBeat);
	DDX_Control(pDX, IDC_EDIT_LOOP_END_GRID, m_editEndGrid);
	DDX_Control(pDX, IDC_EDIT_LOOP_END_TICK, m_editEndTick);
	DDX_Control(pDX, IDC_SPIN_LOOP_START_BAR, m_spinStartMeasure);
	DDX_Control(pDX, IDC_SPIN_LOOP_START_BEAT, m_spinStartBeat);
	DDX_Control(pDX, IDC_SPIN_LOOP_START_GRID, m_spinStartGrid);
	DDX_Control(pDX, IDC_SPIN_LOOP_START_TICK, m_spinStartTick);
	DDX_Control(pDX, IDC_SPIN_LOOP_END_BAR, m_spinEndMeasure);
	DDX_Control(pDX, IDC_SPIN_LOOP_END_BEAT, m_spinEndBeat);
	DDX_Control(pDX, IDC_SPIN_LOOP_END_GRID, m_spinEndGrid);
	DDX_Control(pDX, IDC_SPIN_LOOP_END_TICK, m_spinEndTick);
	DDX_Control(pDX, IDC_RESET_LOOP, m_btnResetLoop);
	//}}AFX_DATA_MAP
}


/////////////////////////////////////////////////////////////////////////////
// CTabVirtualSegmentLoop::SetObject

void CTabVirtualSegmentLoop::SetObject( IDMUSProdPropPageObject* pIPropPageObject )
{
	if( m_pIPropPageObject )
	{
		m_pIPropPageObject->Release();
	}
	m_pIPropPageObject = pIPropPageObject;
	if( m_pIPropPageObject )
	{
		m_pIPropPageObject->AddRef();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabVirtualSegmentLoop::UpdateObject

void CTabVirtualSegmentLoop::UpdateObject()
{
	if( m_pIPropPageObject )
	{
		m_pIPropPageObject->SetData( (void *)&m_PPGTabVirtualSegmentLoop );
	}

	RefreshTab();
}
	

/////////////////////////////////////////////////////////////////////////////
// CTabVirtualSegmentLoop::SetEditControl

void CTabVirtualSegmentLoop::SetEditControl( CEdit& edit, long lValue, int nOffset )
{
	TCHAR tcstrTmp[DIALOG_EDIT_LEN];
	BOOL fTransSuccess;

	edit.GetWindowText( tcstrTmp, DIALOG_EDIT_LEN );

	// Convert from text to an integer
	long lCurValue = GetDlgItemInt( edit.GetDlgCtrlID(), &fTransSuccess, TRUE );

	// Check if the conversion failed, the text is empty, or if the values are different
	if( !fTransSuccess
	|| (tcstrTmp[0] == NULL)
	|| (lCurValue != lValue + nOffset) )
	{
		// Update the displayed number
		SetDlgItemInt( edit.GetDlgCtrlID(), lValue + nOffset );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabVirtualSegmentLoop::HandleKillFocus
//
// Generic handler for KillFocus changes
bool CTabVirtualSegmentLoop::HandleKillFocus( CSpinButtonCtrl& spin, long& lUpdateVal, int nOffset )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Check if the spin control is a valid window
	if (!::IsWindow(spin.m_hWnd))
	{
		return false;
	}

	// Get text from edit control
	TCHAR tcstrTmp[DIALOG_EDIT_LEN];
	CWnd* pEditCtrl = spin.GetBuddy();
	ASSERT(pEditCtrl != NULL);
	if( pEditCtrl == NULL )
	{
		return false;
	}
	pEditCtrl->GetWindowText( tcstrTmp, DIALOG_EDIT_LEN );

	bool fChanged = false;

	// Handle empty text
	if( tcstrTmp[0] == NULL )
	{
		// Set it back to the minimum value
		spin.SetPos( nOffset );

		// Check if the value changed
		if( lUpdateVal != 0 )
		{
			// Update the item with the new value
			lUpdateVal = 0;
			fChanged = true;
		}
	}
	else
	{
		// Convert from text to an integer
		BOOL fTransSuccess;
		long lNewValue = GetDlgItemInt( pEditCtrl->GetDlgCtrlID(), &fTransSuccess, TRUE );

		// If unable to translate (if dialog contains invalid data, such as '-'), exit early
		if( !fTransSuccess )
		{
			// If conversion failed, update dialog item text
			SetDlgItemInt( pEditCtrl->GetDlgCtrlID(), lUpdateVal + nOffset );
		}
		// If conversion succeeded, ensure the value stays in range
		else
		{
			// Get the valid range
			int iLower, iUpper;
			spin.GetRange( iLower, iUpper );

			// Check if the value is out of range
			if( lNewValue > iUpper )
			{
				// Value out of range, update dialog item text
				SetDlgItemInt( pEditCtrl->GetDlgCtrlID(), iUpper );

				// Update the value to the top of the range
				lNewValue = iUpper;
			}

			// Check if the value changed
			if( lUpdateVal != (lNewValue - nOffset) )
			{
				// Update the item with the new value
				lUpdateVal = (lNewValue - nOffset);
				fChanged = true;
			}
		}
	}

	return fChanged;
}


/////////////////////////////////////////////////////////////////////////////
// CTabVirtualSegmentLoop::HandleKillFocus
//
// Generic handler for KillFocus changes
bool CTabVirtualSegmentLoop::HandleKillFocus( CSpinButtonCtrl& spin, DWORD& dwUpdateVal, int nOffset )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Check if the spin control is a valid window
	if (!::IsWindow(spin.m_hWnd))
	{
		return false;
	}

	// Get text from edit control
	TCHAR tcstrTmp[DIALOG_EDIT_LEN];
	CWnd* pEditCtrl = spin.GetBuddy();
	ASSERT(pEditCtrl != NULL);
	if( pEditCtrl == NULL )
	{
		return false;
	}
	pEditCtrl->GetWindowText( tcstrTmp, DIALOG_EDIT_LEN );

	bool fChanged = false;

	// Handle empty text
	if( tcstrTmp[0] == NULL )
	{
		// Set it back to the minimum value
		spin.SetPos( nOffset );

		// Check if the value changed
		if( dwUpdateVal != 0 )
		{
			// Update the item with the new value
			dwUpdateVal = 0;
			fChanged = true;
		}
	}
	else
	{
		// Convert from text to an integer
		BOOL fTransSuccess;
		long lNewValue = GetDlgItemInt( pEditCtrl->GetDlgCtrlID(), &fTransSuccess, TRUE );

		// If unable to translate (if dialog contains invalid data, such as '-'), exit early
		if( !fTransSuccess )
		{
			// If conversion failed, update dialog item text
			SetDlgItemInt( pEditCtrl->GetDlgCtrlID(), dwUpdateVal + nOffset );
		}
		// If conversion succeeded, ensure the value stays in range
		else
		{
			// Get the valid range
			int iLower, iUpper;
			spin.GetRange( iLower, iUpper );

			// Check if the value is out of range
			if( lNewValue > iUpper )
			{
				// Value out of range, update dialog item text
				SetDlgItemInt( pEditCtrl->GetDlgCtrlID(), iUpper );

				// Update the value to the top of the range
				lNewValue = iUpper;
			}

			// Check if the value changed
			if( dwUpdateVal != (DWORD)(lNewValue - nOffset) )
			{
				// Update the item with the new value
				dwUpdateVal = (DWORD)(lNewValue - nOffset);
				fChanged = true;
			}
		}
	}

	return fChanged;
}


/////////////////////////////////////////////////////////////////////////////
// CTabVirtualSegmentLoop::HandleDeltaChange
//
// Generic handler for deltapos changes
bool CTabVirtualSegmentLoop::HandleDeltaChange( NMHDR* pNMHDR, LRESULT* pResult, long& lUpdateVal )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	bool fChanged = false;

	// If the value changed - update the selected item
	if( ((NM_UPDOWN* )pNMHDR)->iDelta != 0 ) 
	{
		// Update the value
		lUpdateVal += ((NM_UPDOWN* )pNMHDR)->iDelta;
		fChanged = true;
	}

	// Set the result to 1 to show that we handled this message
	*pResult = 1;

	return fChanged;
}


/////////////////////////////////////////////////////////////////////////////
// CTabVirtualSegmentLoop::HandleDeltaChange
//
// Generic handler for deltapos changes
bool CTabVirtualSegmentLoop::HandleDeltaChange( CSpinButtonCtrl& spin, NMHDR* pNMHDR, LRESULT* pResult, DWORD& dwUpdateVal )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	bool fChanged = false;

	// If the value changed - update the selected item
	if( ((NM_UPDOWN* )pNMHDR)->iDelta != 0 ) 
	{
		// Get current position
		int iPos = spin.GetPos();

		// Get the valid range
		int iLower, iUpper;
		spin.GetRange( iLower, iUpper );
	
		if( (iPos == iLower)  &&  (((NM_UPDOWN* )pNMHDR)->iDelta < 0) 
		||  (iPos == iUpper)  &&  (((NM_UPDOWN* )pNMHDR)->iDelta > 0) )
		{
			// Nothing to do
			fChanged = false;
		}
		else
		{
			// Update the value
			dwUpdateVal += ((NM_UPDOWN* )pNMHDR)->iDelta;
			fChanged = true;
		}
	}

	// Set the result to 1 to show that we handled this message
	*pResult = 1;

	return fChanged;
}


/////////////////////////////////////////////////////////////////////////////
// CTabVirtualSegmentLoop::RefreshTab

void CTabVirtualSegmentLoop::RefreshTab( void )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Make sure controls have been created
	if( ::IsWindow(m_hWnd) == FALSE )
	{
		return;
	}

	if( m_pIPropPageObject == NULL )
	{
		EnableControls( FALSE );
		return;
	}

	PPGTabVirtualSegmentLoop *pPPGTabVirtualSegmentLoop = &m_PPGTabVirtualSegmentLoop;
	if( FAILED( m_pIPropPageObject->GetData( (void**)&pPPGTabVirtualSegmentLoop ) ) )
	{
		EnableControls( FALSE );
		return;
	}

	if( !(m_PPGTabVirtualSegmentLoop.dwFlagsUI & PROPF_ONE_SELECTED) 
	||  !(m_PPGTabVirtualSegmentLoop.dwFlagsUI & PROPF_TIME_CONVERSIONS_OK) )
	{
		EnableControls( FALSE );
		return;
	}

	// Prevent control notifications from being dispatched during RefreshTab
	_AFX_THREAD_STATE* pThreadState = AfxGetThreadState();
	HWND hWndOldLockout = pThreadState->m_hLockoutNotifyWindow;
	ASSERT(hWndOldLockout != m_hWnd);   // must not recurse
	pThreadState->m_hLockoutNotifyWindow = m_hWnd;

	EnableControls( TRUE );

	// "Infinite"
	m_btnLoopInfinite.SetCheck( (m_PPGTabVirtualSegmentLoop.dwRepeats == DMUS_SEG_REPEAT_INFINITE) ? 1 : 0 );

	// "Repeats"
	if( m_PPGTabVirtualSegmentLoop.dwRepeats != DMUS_SEG_REPEAT_INFINITE )
	{
		SetEditControl( m_editLoopRepeat, m_PPGTabVirtualSegmentLoop.dwRepeats, 0 );
	}

	// "Start Offset"
	SetEditControl( m_editStartMeasure, m_PPGTabVirtualSegmentLoop.lStartMeasure, 1 );
	SetEditControl( m_editStartBeat, m_PPGTabVirtualSegmentLoop.lStartBeat, 1 );
	SetEditControl( m_editStartGrid, m_PPGTabVirtualSegmentLoop.lStartGrid, 1 );
	SetEditControl( m_editStartTick, m_PPGTabVirtualSegmentLoop.lStartTick, 0 );

	// "End Offset"
	SetEditControl( m_editEndMeasure, m_PPGTabVirtualSegmentLoop.lEndMeasure, 1 );
	SetEditControl( m_editEndBeat, m_PPGTabVirtualSegmentLoop.lEndBeat, 1 );
	SetEditControl( m_editEndGrid, m_PPGTabVirtualSegmentLoop.lEndGrid, 1 );
	SetEditControl( m_editEndTick, m_PPGTabVirtualSegmentLoop.lEndTick, 0 );

	pThreadState->m_hLockoutNotifyWindow = hWndOldLockout;
}


/////////////////////////////////////////////////////////////////////////////
// CTabVirtualSegmentLoop::EnableControls

void CTabVirtualSegmentLoop::EnableControls( BOOL fEnable ) 
{
	m_btnLoopInfinite.EnableWindow( fEnable );

	BOOL fEnableRepeat = fEnable;
	if( m_PPGTabVirtualSegmentLoop.dwRepeats == DMUS_SEG_REPEAT_INFINITE )
	{
		fEnableRepeat = FALSE;
	}

	m_editLoopRepeat.EnableWindow( fEnableRepeat );
	m_spinLoopRepeat.EnableWindow( fEnableRepeat );

	BOOL fEnableLoop = fEnable;
	if( m_PPGTabVirtualSegmentLoop.dwRepeats == 0 )
	{
		fEnableLoop = FALSE;
	}

	m_editStartMeasure.EnableWindow( fEnableLoop );
	m_editStartBeat.EnableWindow( fEnableLoop );
	m_editStartGrid.EnableWindow( fEnableLoop );
	m_editStartTick.EnableWindow( fEnableLoop );
	m_editEndMeasure.EnableWindow( fEnableLoop );
	m_editEndBeat.EnableWindow( fEnableLoop );
	m_editEndGrid.EnableWindow( fEnableLoop );
	m_editEndTick.EnableWindow( fEnableLoop );

	m_spinStartMeasure.EnableWindow( fEnableLoop );
	m_spinStartBeat.EnableWindow( fEnableLoop );
	m_spinStartGrid.EnableWindow( fEnableLoop );
	m_spinStartTick.EnableWindow( fEnableLoop );
	m_spinEndMeasure.EnableWindow( fEnableLoop );
	m_spinEndBeat.EnableWindow( fEnableLoop );
	m_spinEndGrid.EnableWindow( fEnableLoop );
	m_spinEndTick.EnableWindow( fEnableLoop );

	m_btnResetLoop.EnableWindow( fEnableLoop );

	if( fEnableRepeat == FALSE )
	{
		m_editLoopRepeat.SetWindowText( NULL );
	}

	if( fEnableLoop == FALSE )
	{
		m_editStartMeasure.SetWindowText( NULL );
		m_editStartBeat.SetWindowText( NULL );
		m_editStartGrid.SetWindowText( NULL );
		m_editStartTick.SetWindowText( NULL );
		m_editEndMeasure.SetWindowText( NULL );
		m_editEndBeat.SetWindowText( NULL );
		m_editEndGrid.SetWindowText( NULL );
		m_editEndTick.SetWindowText( NULL );
	}
}


BEGIN_MESSAGE_MAP(CTabVirtualSegmentLoop, CPropertyPage)
	//{{AFX_MSG_MAP(CTabVirtualSegmentLoop)
	ON_WM_DESTROY()
	ON_WM_CREATE()
	ON_NOTIFY(UDN_DELTAPOS, IDC_SPIN_LOOP_START_BAR, OnSpinStartMeasure)
	ON_NOTIFY(UDN_DELTAPOS, IDC_SPIN_LOOP_START_BEAT, OnSpinStartBeat)
	ON_NOTIFY(UDN_DELTAPOS, IDC_SPIN_LOOP_START_GRID, OnSpinStartGrid)
	ON_NOTIFY(UDN_DELTAPOS, IDC_SPIN_LOOP_START_TICK, OnSpinStartTick)
	ON_EN_KILLFOCUS(IDC_EDIT_LOOP_START_BAR, OnKillFocusStartMeasure)
	ON_EN_KILLFOCUS(IDC_EDIT_LOOP_START_BEAT, OnKillFocusStartBeat)
	ON_EN_KILLFOCUS(IDC_EDIT_LOOP_START_GRID, OnKillFocusStartGrid)
	ON_EN_KILLFOCUS(IDC_EDIT_LOOP_START_TICK, OnKillFocusStartTick)
	ON_NOTIFY(UDN_DELTAPOS, IDC_SPIN_LOOP_END_BAR, OnSpinEndMeasure)
	ON_NOTIFY(UDN_DELTAPOS, IDC_SPIN_LOOP_END_BEAT, OnSpinEndBeat)
	ON_NOTIFY(UDN_DELTAPOS, IDC_SPIN_LOOP_END_GRID, OnSpinEndGrid)
	ON_NOTIFY(UDN_DELTAPOS, IDC_SPIN_LOOP_END_TICK, OnSpinEndTick)
	ON_EN_KILLFOCUS(IDC_EDIT_LOOP_END_BAR, OnKillFocusEndMeasure)
	ON_EN_KILLFOCUS(IDC_EDIT_LOOP_END_BEAT, OnKillFocusEndBeat)
	ON_EN_KILLFOCUS(IDC_EDIT_LOOP_END_GRID, OnKillFocusEndGrid)
	ON_EN_KILLFOCUS(IDC_EDIT_LOOP_END_TICK, OnKillFocusEndTick)
	ON_NOTIFY(UDN_DELTAPOS, IDC_SPIN_LOOP_REPEAT, OnSpinRepeat)
	ON_EN_KILLFOCUS(IDC_EDIT_LOOP_REPEAT, OnKillFocusRepeat)
	ON_BN_CLICKED(IDC_CHECK_REPEAT_FOREVER, OnCheckRepeat)
	ON_BN_DOUBLECLICKED(IDC_CHECK_REPEAT_FOREVER, OnDoubleClickedCheckRepeat)
	ON_BN_CLICKED(IDC_RESET_LOOP, OnResetLoop)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CTabVirtualSegmentLoop message handlers

/////////////////////////////////////////////////////////////////////////////
// CTabVirtualSegmentLoop::OnSetActive

BOOL CTabVirtualSegmentLoop::OnSetActive() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Set limits for edit controls
	m_editLoopRepeat.LimitText( 5 );
	m_editStartMeasure.LimitText( 5 );
	m_editStartBeat.LimitText( 3 );
	m_editStartGrid.LimitText( 3 );
	m_editStartTick.LimitText( 5 );
	m_editEndMeasure.LimitText( 5 );
	m_editEndBeat.LimitText( 3 );
	m_editEndGrid.LimitText( 3 );
	m_editEndTick.LimitText( 5 );

	// Set ranges of spin controls
	m_spinLoopRepeat.SetRange( 0, 32767 );
	m_spinStartMeasure.SetRange( 1, 32767 );
	m_spinStartBeat.SetRange( 1, 256 );
	m_spinStartGrid.SetRange( 1, 256 );
	m_spinStartTick.SetRange( -MAX_TICK, MAX_TICK );
	m_spinEndMeasure.SetRange( 1, 32767 );
	m_spinEndBeat.SetRange( 1, 256 );
	m_spinEndGrid.SetRange( 1, 256 );
	m_spinEndTick.SetRange( -MAX_TICK, MAX_TICK );

	// Refresh the tab
	RefreshTab();
	
	return CPropertyPage::OnSetActive();
}


/////////////////////////////////////////////////////////////////////////////
// CTabVirtualSegmentLoop::OnDestroy

void CTabVirtualSegmentLoop::OnDestroy() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Detach the window from the property page structure.
	// This will be done again by the main application since
	// it owns the property sheet.  It needs o be done here
	// so that the window handle can be removed from the
	// DLLs handle map.
	if( m_fNeedToDetach && m_hWnd )
	{
		HWND hWnd = m_hWnd;
		Detach();
		m_hWnd = hWnd;
	}

	CPropertyPage::OnDestroy();
}


/////////////////////////////////////////////////////////////////////////////
// CTabVirtualSegmentLoop::OnCreate

int CTabVirtualSegmentLoop::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Attach the window to the property page structure.
	// This has been done once already in the main application
	// since the main application owns the property sheet.
	// It needs to be done here so that the window handle can
	// be found in the DLLs handle map.
	if( !FromHandlePermanent( m_hWnd ) )
	{
		HWND hWnd = m_hWnd;
		m_hWnd = NULL;
		Attach( hWnd );
		m_fNeedToDetach = TRUE;
	}

	if( CPropertyPage::OnCreate(lpCreateStruct) == -1 )
	{
		return -1;
	}
	
	return 0;
}


/////////////////////////////////////////////////////////////////////////////
// CTabVirtualSegmentLoop::OnSpinStartMeasure

void CTabVirtualSegmentLoop::OnSpinStartMeasure( NMHDR* pNMHDR, LRESULT* pResult ) 
{
	// Need to do this in case the user clicked the spin control immediately after
	// typing in a value
	OnKillFocusStartMeasure();

	if( HandleDeltaChange( pNMHDR, pResult, m_PPGTabVirtualSegmentLoop.lStartMeasure ) )
	{
		UpdateObject();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabVirtualSegmentLoop::OnSpinStartBeat

void CTabVirtualSegmentLoop::OnSpinStartBeat( NMHDR* pNMHDR, LRESULT* pResult ) 
{
	// Need to do this in case the user clicked the spin control immediately after
	// typing in a value
	OnKillFocusStartBeat();

	if( HandleDeltaChange( pNMHDR, pResult, m_PPGTabVirtualSegmentLoop.lStartBeat ) )
	{
		UpdateObject();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabVirtualSegmentLoop::OnSpinStartGrid

void CTabVirtualSegmentLoop::OnSpinStartGrid( NMHDR* pNMHDR, LRESULT* pResult ) 
{
	// Need to do this in case the user clicked the spin control immediately after
	// typing in a value
	OnKillFocusStartGrid();

	if( HandleDeltaChange( pNMHDR, pResult, m_PPGTabVirtualSegmentLoop.lStartGrid ) )
	{
		UpdateObject();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabVirtualSegmentLoop::OnSpinStartTick

void CTabVirtualSegmentLoop::OnSpinStartTick( NMHDR* pNMHDR, LRESULT* pResult ) 
{
	// Need to do this in case the user clicked the spin control immediately after
	// typing in a value
	OnKillFocusStartTick();

	if( HandleDeltaChange( pNMHDR, pResult, m_PPGTabVirtualSegmentLoop.lStartTick ) )
	{
		UpdateObject();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabVirtualSegmentLoop::OnSpinEndMeasure

void CTabVirtualSegmentLoop::OnSpinEndMeasure( NMHDR* pNMHDR, LRESULT* pResult ) 
{
	// Need to do this in case the user clicked the spin control immediately after
	// typing in a value
	OnKillFocusEndMeasure();

	if( HandleDeltaChange( pNMHDR, pResult, m_PPGTabVirtualSegmentLoop.lEndMeasure ) )
	{
		UpdateObject();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabVirtualSegmentLoop::OnSpinEndBeat

void CTabVirtualSegmentLoop::OnSpinEndBeat( NMHDR* pNMHDR, LRESULT* pResult ) 
{
	// Need to do this in case the user clicked the spin control immediately after
	// typing in a value
	OnKillFocusEndBeat();

	if( HandleDeltaChange( pNMHDR, pResult, m_PPGTabVirtualSegmentLoop.lEndBeat ) )
	{
		UpdateObject();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabVirtualSegmentLoop::OnSpinEndGrid

void CTabVirtualSegmentLoop::OnSpinEndGrid( NMHDR* pNMHDR, LRESULT* pResult ) 
{
	// Need to do this in case the user clicked the spin control immediately after
	// typing in a value
	OnKillFocusEndGrid();

	if( HandleDeltaChange( pNMHDR, pResult, m_PPGTabVirtualSegmentLoop.lEndGrid ) )
	{
		UpdateObject();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabVirtualSegmentLoop::OnSpinEndTick

void CTabVirtualSegmentLoop::OnSpinEndTick( NMHDR* pNMHDR, LRESULT* pResult ) 
{
	// Need to do this in case the user clicked the spin control immediately after
	// typing in a value
	OnKillFocusEndTick();

	if( HandleDeltaChange( pNMHDR, pResult, m_PPGTabVirtualSegmentLoop.lEndTick ) )
	{
		UpdateObject();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabVirtualSegmentLoop::OnKillFocusStartMeasure

void CTabVirtualSegmentLoop::OnKillFocusStartMeasure() 
{
	if( HandleKillFocus( m_spinStartMeasure, m_PPGTabVirtualSegmentLoop.lStartMeasure, 1 ) )
	{
		UpdateObject();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabVirtualSegmentLoop::OnKillFocusStartBeat

void CTabVirtualSegmentLoop::OnKillFocusStartBeat() 
{
	if( HandleKillFocus( m_spinStartBeat, m_PPGTabVirtualSegmentLoop.lStartBeat, 1 ) )
	{
		UpdateObject();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabVirtualSegmentLoop::OnKillFocusStartGrid

void CTabVirtualSegmentLoop::OnKillFocusStartGrid() 
{
	if( HandleKillFocus( m_spinStartGrid, m_PPGTabVirtualSegmentLoop.lStartGrid, 1 ) )
	{
		UpdateObject();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabVirtualSegmentLoop::OnKillFocusStartTick

void CTabVirtualSegmentLoop::OnKillFocusStartTick() 
{
	if( HandleKillFocus( m_spinStartTick, m_PPGTabVirtualSegmentLoop.lStartTick, 0 ) )
	{
		UpdateObject();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabVirtualSegmentLoop::OnKillFocusEndMeasure

void CTabVirtualSegmentLoop::OnKillFocusEndMeasure() 
{
	if( HandleKillFocus( m_spinEndMeasure, m_PPGTabVirtualSegmentLoop.lEndMeasure, 1 ) )
	{
		UpdateObject();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabVirtualSegmentLoop::OnKillFocusEndBeat

void CTabVirtualSegmentLoop::OnKillFocusEndBeat() 
{
	if( HandleKillFocus( m_spinEndBeat, m_PPGTabVirtualSegmentLoop.lEndBeat, 1 ) )
	{
		UpdateObject();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabVirtualSegmentLoop::OnKillFocusEndGrid

void CTabVirtualSegmentLoop::OnKillFocusEndGrid() 
{
	if( HandleKillFocus( m_spinEndGrid, m_PPGTabVirtualSegmentLoop.lEndGrid, 1 ) )
	{
		UpdateObject();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabVirtualSegmentLoop::OnKillFocusEndTick

void CTabVirtualSegmentLoop::OnKillFocusEndTick() 
{
	if( HandleKillFocus( m_spinEndTick, m_PPGTabVirtualSegmentLoop.lEndTick, 0 ) )
	{
		UpdateObject();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabVirtualSegmentLoop::OnSpinRepeat

void CTabVirtualSegmentLoop::OnSpinRepeat( NMHDR* pNMHDR, LRESULT* pResult ) 
{
	// Need to do this in case the user clicked the spin control immediately after
	// typing in a value
	OnKillFocusRepeat();

	if( HandleDeltaChange( m_spinLoopRepeat, pNMHDR, pResult, m_PPGTabVirtualSegmentLoop.dwRepeats) )
	{
		UpdateObject();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabVirtualSegmentLoop::OnKillFocusRepeat

void CTabVirtualSegmentLoop::OnKillFocusRepeat() 
{
	if( HandleKillFocus( m_spinLoopRepeat, m_PPGTabVirtualSegmentLoop.dwRepeats, 0 ) )
	{
		UpdateObject();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabVirtualSegmentLoop::OnCheckRepeat

void CTabVirtualSegmentLoop::OnCheckRepeat() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	DWORD dwRepeats = m_btnLoopInfinite.GetCheck() ? DMUS_SEG_REPEAT_INFINITE : 0;

	if( dwRepeats != m_PPGTabVirtualSegmentLoop.dwRepeats )
	{
		m_PPGTabVirtualSegmentLoop.dwRepeats = dwRepeats;
		UpdateObject();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabVirtualSegmentLoop::OnDoubleClickedCheckRepeat

void CTabVirtualSegmentLoop::OnDoubleClickedCheckRepeat() 
{
	OnCheckRepeat();
}


/////////////////////////////////////////////////////////////////////////////
// CTabVirtualSegmentLoop::OnResetLoop

void CTabVirtualSegmentLoop::OnResetLoop() 
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_PPGTabVirtualSegmentLoop.lStartMeasure != 0
	||  m_PPGTabVirtualSegmentLoop.lStartBeat != 0
	||  m_PPGTabVirtualSegmentLoop.lStartGrid != 0
	||  m_PPGTabVirtualSegmentLoop.lStartTick != 0
	||  m_PPGTabVirtualSegmentLoop.lEndMeasure != 0
	||  m_PPGTabVirtualSegmentLoop.lEndBeat != 0
	||  m_PPGTabVirtualSegmentLoop.lEndGrid != 0
	||  m_PPGTabVirtualSegmentLoop.lEndTick != 0 )
	{
		m_PPGTabVirtualSegmentLoop.lStartMeasure = 0;
		m_PPGTabVirtualSegmentLoop.lStartBeat = 0;
		m_PPGTabVirtualSegmentLoop.lStartGrid = 0;
		m_PPGTabVirtualSegmentLoop.lStartTick = 0;
		m_PPGTabVirtualSegmentLoop.lEndMeasure = 0;
		m_PPGTabVirtualSegmentLoop.lEndBeat = 0;
		m_PPGTabVirtualSegmentLoop.lEndGrid = 0;
		m_PPGTabVirtualSegmentLoop.lEndTick = 0;
		UpdateObject();
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTabVirtualSegmentLoop::PreTranslateMessage

BOOL CTabVirtualSegmentLoop::PreTranslateMessage( MSG* pMsg ) 
{
/*
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( !(m_PPGTabVirtualSegmentLoop.dwFlagsUI & PROPF_ONE_SELECTED) )
	{
		return CPropertyPage::PreTranslateMessage( pMsg );
	}

	switch( pMsg->message )
	{
		case WM_KEYDOWN:
			if( pMsg->lParam & 0x40000000 )
			{
				break;
			}

			switch( pMsg->wParam )
			{
				case VK_ESCAPE:
				{
					CWnd* pWnd = GetFocus();
					if( pWnd )
					{
						switch( pWnd->GetDlgCtrlID() )
						{
							case IDC_EDIT_LOOP_REPEAT: 
								m_spinRepeat.SetPos( m_pPPGSegment->dwLoopRepeats );
								break;

							case IDC_EDIT_LOOP_END_BAR:
								m_spinEndMeasure.SetPos( m_pPPGSegment->dwLoopEndMeasure + 1 );
								break;

							case IDC_EDIT_LOOP_END_BEAT:
								m_spinEndBeat.SetPos( m_pPPGSegment->bLoopEndBeat + 1 );
								break;

							case IDC_EDIT_LOOP_END_GRID:
								m_spinEndGrid.SetPos( m_pPPGSegment->wLoopEndGrid + 1 );
								break;

							case IDC_EDIT_LOOP_END_TICK:
								m_spinEndTick.SetPos( m_pPPGSegment->wLoopEndTick );
								break;

							case IDC_EDIT_LOOP_START_BAR:
								m_spinStartMeasure.SetPos( m_pPPGSegment->dwLoopStartMeasure + 1 );
								break;

							case IDC_EDIT_LOOP_START_BEAT:
								m_spinStartBeat.SetPos( m_pPPGSegment->bLoopStartBeat + 1 );
								break;

							case IDC_EDIT_LOOP_START_GRID:
								m_spinStartGrid.SetPos( m_pPPGSegment->wLoopStartGrid + 1 );
								break;

							case IDC_EDIT_LOOP_START_TICK:
								m_spinStartTick.SetPos( m_pPPGSegment->wLoopStartTick );
								break;
						}
					}
					return TRUE;
				}

				case VK_RETURN:
				{
					CWnd* pWnd = GetFocus();
					if( pWnd )
					{
						if( pWnd->GetDlgCtrlID() == IDC_EDIT_LOOP_REPEAT )
						{
							OnKillfocusEditLoopRepeat();
						}

						CWnd* pWndNext = GetNextDlgTabItem( pWnd );
						if( pWndNext )
						{
							pWndNext->SetFocus();
						}
					}
					return TRUE;
				}
			}
			break;
	}
*/	
	return CPropertyPage::PreTranslateMessage( pMsg );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SongDesigner\TabVirtualSegmentLoop.h ===
#if !defined(AFX_TABVIRTUALSEGMENTLOOP_H__4B3A5402_6B29_11D1_89AE_00A0C9054129__INCLUDED_)
#define AFX_TABVIRTUALSEGMENTLOOP_H__4B3A5402_6B29_11D1_89AE_00A0C9054129__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

// TabVirtualSegmentLoop.h : header file
//

typedef struct _PPGTabVirtualSegmentLoop
{
	_PPGTabVirtualSegmentLoop( void )
	{
		dwPageIndex = 3;
		dwRepeats = 0;
		lStartMeasure = 0;
		lStartBeat = 0;
		lStartGrid = 0;
		lStartTick = 0;
		lEndMeasure = 0;
		lEndBeat = 0;
		lEndGrid = 0;
		lEndTick = 0;
		dwFlagsUI = 0;
	}

	DWORD				dwPageIndex;
    DWORD				dwRepeats;
	long				lStartMeasure;
	long				lStartBeat;
	long				lStartGrid;
	long				lStartTick;
	long				lEndMeasure;
	long				lEndBeat;
	long				lEndGrid;
	long				lEndTick;
	DWORD				dwFlagsUI;
} PPGTabVirtualSegmentLoop;


/////////////////////////////////////////////////////////////////////////////
// CTabVirtualSegmentLoop dialog

class CTabVirtualSegmentLoop : public CPropertyPage
{
// Construction
public:
	CTabVirtualSegmentLoop( IDMUSProdPropPageManager* pIPageManager );
	~CTabVirtualSegmentLoop();

// Dialog Data
	//{{AFX_DATA(CTabVirtualSegmentLoop)
	enum { IDD = IDD_TAB_VIRTUAL_SEGMENT_LOOP };
	CEdit	m_editLoopRepeat;
	CSpinButtonCtrl	m_spinLoopRepeat;
	CButton	m_btnLoopInfinite;
	CEdit	m_editStartMeasure;
	CEdit	m_editStartBeat;
	CEdit	m_editStartGrid;
	CEdit	m_editStartTick;
	CEdit	m_editEndMeasure;
	CEdit	m_editEndBeat;
	CEdit	m_editEndGrid;
	CEdit	m_editEndTick;
	CSpinButtonCtrl	m_spinStartMeasure;
	CSpinButtonCtrl	m_spinStartBeat;
	CSpinButtonCtrl	m_spinStartGrid;
	CSpinButtonCtrl	m_spinStartTick;
	CSpinButtonCtrl	m_spinEndMeasure;
	CSpinButtonCtrl	m_spinEndBeat;
	CSpinButtonCtrl	m_spinEndGrid;
	CSpinButtonCtrl	m_spinEndTick;
	CButton	m_btnResetLoop;
	//}}AFX_DATA

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CTabVirtualSegmentLoop)
	public:
	virtual BOOL OnSetActive();
	virtual BOOL PreTranslateMessage(MSG* pMsg);
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CTabVirtualSegmentLoop)
	afx_msg void OnDestroy();
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnSpinStartMeasure(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnSpinStartBeat(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnSpinStartGrid(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnSpinStartTick(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnKillFocusStartMeasure();
	afx_msg void OnKillFocusStartBeat();
	afx_msg void OnKillFocusStartGrid();
	afx_msg void OnKillFocusStartTick();
	afx_msg void OnSpinEndMeasure(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnSpinEndBeat(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnSpinEndGrid(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnSpinEndTick(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnKillFocusEndMeasure();
	afx_msg void OnKillFocusEndBeat();
	afx_msg void OnKillFocusEndGrid();
	afx_msg void OnKillFocusEndTick();
	afx_msg void OnSpinRepeat(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnKillFocusRepeat();
	afx_msg void OnCheckRepeat();
	afx_msg void OnDoubleClickedCheckRepeat();
	afx_msg void OnResetLoop();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

protected:
	void EnableControls( BOOL fEnable );
	void UpdateObject();
	void SetEditControl( CEdit& edit, long lValue, int nOffset );
	bool HandleKillFocus( CSpinButtonCtrl& spin, long& lUpdateVal, int nOffset );
	bool HandleKillFocus( CSpinButtonCtrl& spin, DWORD& dwUpdateVal, int nOffset );
	bool HandleDeltaChange( NMHDR* pNMHDR, LRESULT* pResult, long& lUpdateVal );
	bool HandleDeltaChange( CSpinButtonCtrl& spin, NMHDR* pNMHDR, LRESULT* pResult, DWORD& dwUpdateVal );

public:
	void SetObject( IDMUSProdPropPageObject* pIPropPageObject );
	void RefreshTab( void );

protected:
	IDMUSProdPropPageManager*		m_pIPageManager;
	IDMUSProdPropPageObject*		m_pIPropPageObject;
	PPGTabVirtualSegmentLoop		m_PPGTabVirtualSegmentLoop;
	BOOL							m_fNeedToDetach;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_TABVIRTUALSEGMENTLOOP_H__4B3A5402_6B29_11D1_89AE_00A0C9054129__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SongDesigner\Transition.cpp ===
// Transition.cpp : implementation file
//

#include "stdafx.h"
#include "SongDesignerDLL.h"

#include "Song.h"
#include "SongCtl.h"
#include "SourceSegment.h"
#include "VirtualSegment.h"
#include "Transition.h"


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


//////////////////////////////////////////////////////////////////////
//	CTransition Constructor/Destructor

CTransition::CTransition( CDirectMusicSong* pSong )
{
    m_dwRef = 0;
	AddRef();

	ASSERT( pSong != NULL );
	m_pSong = pSong;
//	m_pSong->AddRef();			intentionally missing

	// UI
	m_dwToSegmentFlag = DMUS_SONG_ANYSEG;
	m_fResolveToSegmentID = false;
	m_dwToSegmentID = 0;
	m_fResolveTransitionSegmentID = false;
	m_dwTransitionSegmentID = 0;
	m_dwBitsUI = 0;

	// DMUS_IO_TRANSITION_DEF
	m_pToSegment = NULL;
	m_pTransitionSegment = NULL;
	m_dwPlayFlagsDM = 0;
}

CTransition::~CTransition( void )
{
	ASSERT( theApp.m_pSongComponent != NULL );
	ASSERT( theApp.m_pSongComponent->m_pIFramework8 != NULL );

	RELEASE( m_pToSegment );
	RELEASE( m_pTransitionSegment );
}


/////////////////////////////////////////////////////////////////////////////
// CTransition::Copy

void CTransition::Copy( CTransition* pTransition )
{
	ASSERT( pTransition != NULL );
	if ( pTransition == NULL )
	{
		return;
	}

	if( pTransition == this )
	{
		return;
	}

	// UI
	m_dwToSegmentFlag = pTransition->m_dwToSegmentFlag;
	m_fResolveToSegmentID = pTransition->m_fResolveToSegmentID;
	m_dwToSegmentID = pTransition->m_dwToSegmentID;
	m_fResolveTransitionSegmentID = pTransition->m_fResolveTransitionSegmentID;
	m_dwTransitionSegmentID = pTransition->m_dwTransitionSegmentID;
	m_dwBitsUI = pTransition->m_dwBitsUI;

	//		DMUS_IO_Transition_EXTRAS_HEADER
	m_pToSegment = pTransition->m_pToSegment;
	if( m_pToSegment )
	{
		m_pToSegment->AddRef();
	}

	m_pTransitionSegment = pTransition->m_pTransitionSegment;
	if( m_pTransitionSegment )
	{
		m_pTransitionSegment->AddRef();
	}

	m_dwPlayFlagsDM = pTransition->m_dwPlayFlagsDM;
}


/////////////////////////////////////////////////////////////////////////////
// CTransition IUnknown implementation

HRESULT CTransition::QueryInterface( REFIID riid, LPVOID* ppvObj )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    if( ::IsEqualIID(riid, IID_IUnknown) )
    {
        *ppvObj = (IUnknown *)this;
    }
	else
	{
		*ppvObj = NULL;
		return E_NOINTERFACE;
	}

	AddRef();
	return S_OK;
}

ULONG CTransition::AddRef()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	AfxOleLockApp(); 
    return ++m_dwRef;
}

ULONG CTransition::Release()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    ASSERT( m_dwRef != 0 );

	AfxOleUnlockApp(); 
    --m_dwRef;

    if( m_dwRef == 0 )
    {
        delete this;
        return 0;
    }

    return m_dwRef;
}


//////////////////////////////////////////////////////////////////////
//	Additional methods

/////////////////////////////////////////////////////////////////////////////
// CTransition FormatTextUI

void CTransition::FormatTextUI( CString& strText )
{
	// Determine "Tran:" Text (or "Intro:" text)
	CString strTemp;
	if( m_dwToSegmentFlag == DMUS_SONG_NOFROMSEG )
	{
		strText.LoadString( IDS_INTRO_TEXT );
	}
	else
	{
		strText.LoadString( IDS_TRAN_TEXT );
	}
	strText += _T(" ");
	if( m_pTransitionSegment )
	{
		m_pTransitionSegment->GetName( strTemp );
	}
	else
	{
		strTemp.LoadString( IDS_NONE_TEXT );
	}
	strText += strTemp;
	strText += _T("   ");

	// Determine "To:" Text
	strTemp.LoadString( IDS_TO_TEXT );
	strText += strTemp;
	strText += _T(" ");
	if( m_pToSegment )
	{
		m_pToSegment->GetName( strTemp );
	}
	else
	{
		if( m_dwToSegmentFlag == DMUS_SONG_ANYSEG )
		{
			strTemp.LoadString( IDS_ANY_TEXT );
		}
		else if( m_dwToSegmentFlag == DMUS_SONG_NOSEG )
		{
			strTemp.LoadString( IDS_NONE_TEXT );
		}
		else if( m_dwToSegmentFlag == DMUS_SONG_NOFROMSEG )
		{
			strTemp.Empty();
			if( m_pSong
			&&  m_pSong->m_pSongCtrl
			&&  m_pSong->m_pSongCtrl->m_pSongDlg )
			{
				CVirtualSegment* pVirtualSegmentToEdit = m_pSong->m_pSongCtrl->m_pSongDlg->GetVirtualSegmentToEdit();
				if( pVirtualSegmentToEdit )
				{
					pVirtualSegmentToEdit->GetName( strTemp );
				}
			}
		}
	}
	strText += strTemp;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SongDesigner\TrackPropPageObject.cpp ===
// TrackPropPageObject.cpp : implementation file
//

#include "stdafx.h"
#include "SongDesignerDLL.h"

#include "Song.h"
#include "SongDlg.h"
#include <TrackFlagsPPG.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


short CTrackPropPageManager::sm_nActiveTab = 0;

//////////////////////////////////////////////////////////////////////
// CTrackPropPageManager Construction/Destruction
//////////////////////////////////////////////////////////////////////

CTrackPropPageManager::CTrackPropPageManager()
{
    m_dwRef = 0;
	AddRef();

	m_pIPropPageObject = NULL;
	m_pIPropSheet = NULL;

	m_pTabFlags = NULL;
}

CTrackPropPageManager::~CTrackPropPageManager()
{
	RELEASE( m_pIPropSheet );

	if( m_pTabFlags )
	{
		delete m_pTabFlags;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTrackPropPageManager::RemoveCurrentObject

void CTrackPropPageManager::RemoveCurrentObject( void )
{
	if( m_pIPropPageObject == NULL )
	{
		return;
	}

	m_pIPropPageObject->OnRemoveFromPageManager();
	m_pIPropPageObject = NULL;
}


/////////////////////////////////////////////////////////////////////////////
// CTrackPropPageManager IUnknown implementation

HRESULT CTrackPropPageManager::QueryInterface( REFIID riid, LPVOID FAR* ppvObj )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    if( ::IsEqualIID(riid, IID_IDMUSProdPropPageManager)
	||  ::IsEqualIID(riid, IID_IUnknown) )
    {
        AddRef();
        *ppvObj = (IDMUSProdPropPageManager *)this;
        return S_OK;
    }

    *ppvObj = NULL;
    return E_NOINTERFACE;
}

ULONG CTrackPropPageManager::AddRef()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    return ++m_dwRef;
}

ULONG CTrackPropPageManager::Release()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    ASSERT( m_dwRef != 0 );

    --m_dwRef;

    if( m_dwRef == 0 )
    {
        delete this;
        return 0;
    }

    return m_dwRef;
}


/////////////////////////////////////////////////////////////////////////////
// CTrackPropPageManager IDMUSProdPropPageManager implementation

/////////////////////////////////////////////////////////////////////////////
// CTrackPropPageManager IDMUSProdPropPageManager::GetPropertySheetTitle

HRESULT CTrackPropPageManager::GetPropertySheetTitle( BSTR* pbstrTitle, BOOL* pfAddPropertiesText )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( (pbstrTitle == NULL)
	||  (pfAddPropertiesText == NULL) )
	{
		return E_POINTER;
	}

	*pfAddPropertiesText = TRUE;

	CString strTitle;
	strTitle.LoadString( IDS_TRACK_TEXT );

	PPGTrack ppgTrack;
	PPGTrack* pPPGTrack = &ppgTrack;

	if( m_pIPropPageObject 
	&& (SUCCEEDED (m_pIPropPageObject->GetData((void **)&pPPGTrack))) )
	{
		if( ppgTrack.pSong
		&&  ppgTrack.pTrack )
		{
			CString strName;
			BSTR bstrName;

			strTitle.LoadString( IDS_SONG_TEXT );
			strTitle += _T(": ");

			// Add name of Song
			if( ppgTrack.pSong )
			{
				if( SUCCEEDED ( ppgTrack.pSong->GetNodeName( &bstrName ) ) )
				{
					strName = bstrName;
					::SysFreeString( bstrName );
			
					strTitle += strName;
					strTitle += _T(" - ");
				}
			}

			// Add Name of Track
			if( ppgTrack.pTrack )
			{
				ppgTrack.pTrack ->FormatTextUI( strName );
				strTitle += _T("'");
				strTitle += strName;
				strTitle += _T("' ");
			}
		}
	}

	*pbstrTitle = strTitle.AllocSysString();

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CTrackPropPageManager IDMUSProdPropPageManager::GetPropertySheetPages

HRESULT CTrackPropPageManager::GetPropertySheetPages( IDMUSProdPropSheet* pIPropSheet, LONG* hPropSheetPage[], short* pnNbrPages )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( (hPropSheetPage == NULL)
	||  (pnNbrPages == NULL) )
	{
		return E_POINTER;
	}

	if( pIPropSheet == NULL )
	{
		return E_INVALIDARG;
	}

	m_pIPropSheet = pIPropSheet;
	m_pIPropSheet->AddRef();

	hPropSheetPage[0] = NULL;
	*pnNbrPages = 0;

	HPROPSHEETPAGE hPage;
	short nNbrPages = 0;

	// Add Flags tab
	m_pTabFlags = new CTrackFlagsPPG();
	if( m_pTabFlags )
	{
		hPage = ::CreatePropertySheetPage( (LPPROPSHEETPAGE)&m_pTabFlags->m_psp );
		if( hPage )
		{
			hPropSheetPage[nNbrPages] = (LONG *)hPage;
			nNbrPages++;
		}			

		// Weak reference
		m_pTabFlags->m_pIPropSheet = m_pIPropSheet;
	}

	// Set number of pages
	*pnNbrPages = nNbrPages;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CTrackPropPageManager IDMUSProdPropPageManager::OnRemoveFromPropertySheet

HRESULT CTrackPropPageManager::OnRemoveFromPropertySheet()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pIPropSheet != NULL );
	m_pIPropSheet->GetActivePage( &CTrackPropPageManager::sm_nActiveTab );

	RemoveCurrentObject();
	theApp.m_pIPageManager = NULL;

	Release();	// delete myself

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CTrackPropPageManager IDMUSProdPropPageManager::SetObject

HRESULT CTrackPropPageManager::SetObject( IDMUSProdPropPageObject* pINewPropPageObject )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( pINewPropPageObject == NULL )
	{
		return E_INVALIDARG;
	}

	if( m_pTabFlags )
	{
		m_pTabFlags->SetObject( pINewPropPageObject );
	}
	
	if( m_pIPropPageObject != pINewPropPageObject )
	{
		RemoveCurrentObject();

		m_pIPropPageObject = pINewPropPageObject;
//		m_pIPropPageObject->AddRef();		intentionally missing
	}

	RefreshData();

	if( m_pIPropSheet )
	{
		m_pIPropSheet->RefreshTitle();
		m_pIPropSheet->RefreshActivePage();
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CTrackPropPageManager IDMUSProdPropPageManager::RemoveObject

HRESULT CTrackPropPageManager::RemoveObject( IDMUSProdPropPageObject* pIPropPageObject )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( (pIPropPageObject == NULL)
	||  (pIPropPageObject != m_pIPropPageObject) )
	{
		return E_INVALIDARG;
	}

	RemoveCurrentObject();
	RefreshData();

	if( m_pIPropSheet )
	{
		m_pIPropSheet->RefreshTitle();
		m_pIPropSheet->RefreshActivePage();
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CTrackPropPageManager  IDMUSProdPropPageManager::IsEqualObject

HRESULT FAR EXPORT CTrackPropPageManager::IsEqualObject( IDMUSProdPropPageObject* pIPropPageObject )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( pIPropPageObject == NULL )
	{
		return E_INVALIDARG;
	}

	if( pIPropPageObject == m_pIPropPageObject )
	{
		return S_OK;
	}

	return S_FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CTrackPropPageManager IDMUSProdPropPageManager::RefreshData

HRESULT CTrackPropPageManager::RefreshData( void )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pTabFlags )
	{
		m_pTabFlags->RefreshData();
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CTrackPropPageManager  IDMUSProdPropPageManager::IsEqualPageManagerGUID

HRESULT CTrackPropPageManager::IsEqualPageManagerGUID( REFGUID rguidPageManager )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( ::IsEqualGUID(rguidPageManager, GUID_TrackPropPageManager) )
	{
		return S_OK;
	}

	return S_FALSE;
}


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////
//	CTrackPropPageObject Constructor/Destructor

CTrackPropPageObject::CTrackPropPageObject( CSongDlg* pSongDlg )
{
    m_dwRef = 0;
	AddRef();

	ASSERT( pSongDlg != NULL );
	m_pSongDlg = pSongDlg;
//	m_pSongDlg->AddRef();		intentionally missing

	m_pTrack = NULL;
	m_dwFlagsUI = 0;
}

CTrackPropPageObject::~CTrackPropPageObject( void )
{
	ASSERT( theApp.m_pSongComponent != NULL );
	ASSERT( theApp.m_pSongComponent->m_pIFramework8 != NULL );

	// Remove TrackPropPageObject from property sheet
	IDMUSProdPropSheet* pIPropSheet;
	if( SUCCEEDED ( theApp.m_pSongComponent->m_pIFramework8->QueryInterface( IID_IDMUSProdPropSheet, (void**)&pIPropSheet ) ) )
	{
		pIPropSheet->RemovePageManagerByObject( this );
		RELEASE( pIPropSheet );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTrackPropPageObject IUnknown implementation

HRESULT CTrackPropPageObject::QueryInterface( REFIID riid, LPVOID* ppvObj )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    if( ::IsEqualIID(riid, IID_IDMUSProdPropPageObject)
	||  ::IsEqualIID(riid, IID_IUnknown) )
    {
        *ppvObj = (IDMUSProdPropPageObject *)this;
    }
	else
	{
		*ppvObj = NULL;
		return E_NOINTERFACE;
	}

	AddRef();
	return S_OK;
}

ULONG CTrackPropPageObject::AddRef()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	AfxOleLockApp(); 
    return ++m_dwRef;
}

ULONG CTrackPropPageObject::Release()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    ASSERT( m_dwRef != 0 );

	AfxOleUnlockApp(); 
    --m_dwRef;

    if( m_dwRef == 0 )
    {
        delete this;
        return 0;
    }

    return m_dwRef;
}


/////////////////////////////////////////////////////////////////////////////
// CTrackPropPageObject IDMUSProdPropPageObject implementation

/////////////////////////////////////////////////////////////////////////////
// CTrackPropPageObject IDMUSProdPropPageObject::GetData

HRESULT CTrackPropPageObject::GetData( void** ppData )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( (ppData == NULL)
	|| (*ppData == NULL) )
	{
		return E_INVALIDARG;
	}

	int nSelCount = m_pSongDlg->GetTrackSelCount();
	if( nSelCount > 1 )
	{
		m_pTrack = NULL;
		m_dwFlagsUI = PROPF_MULTI_SELECTED;
	}
	else
	{
		m_pTrack = m_pSongDlg->GetTrackToEdit();
		if( m_pTrack )
		{
			m_dwFlagsUI = PROPF_ONE_SELECTED;
		}
		else
		{
			m_dwFlagsUI = PROPF_NONE_SELECTED;
		}
	}

	DWORD *pdwIndex = static_cast<DWORD *>(*ppData);
	switch( *pdwIndex )
	{
		// Asking for Song and Track pointers
		case 0:
		{
			PPGTrack *pPPGTrack = reinterpret_cast<PPGTrack *>(*ppData);

			if( m_pTrack )
			{
				pPPGTrack->pSong = m_pTrack->m_pSong;
			}
			else
			{
				pPPGTrack->pSong = NULL;
			}
			pPPGTrack->pTrack = m_pTrack;
			break;
		}

		// Track flags tab
		case 1:
		{
			PPGTrackFlagsParams *pPPGTrackFlagsParams = reinterpret_cast<PPGTrackFlagsParams *>(*ppData);

			if( m_pTrack )
			{
				pPPGTrackFlagsParams->dwTrackExtrasFlags = m_pTrack->GetExtraFlags();
				pPPGTrackFlagsParams->dwTrackExtrasMask = m_pTrack->GetExtraMask();
			}
			else
			{
				pPPGTrackFlagsParams->dwTrackExtrasFlags = 0;
				pPPGTrackFlagsParams->dwTrackExtrasMask = 0;
			}
			pPPGTrackFlagsParams->dwProducerOnlyFlags = 0;
			pPPGTrackFlagsParams->dwProducerOnlyMask = 0;
			break;
		}

		default:
			ASSERT( 0 );
			break;
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CTrackPropPageObject IDMUSProdPropPageObject::SetData

HRESULT CTrackPropPageObject::SetData( void* pData )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Validate parameter
	if( pData == NULL )
	{
		return E_POINTER;
	}

	if( m_pTrack == NULL )
	{
		ASSERT( 0 );
		return E_UNEXPECTED;
	}
	
	DWORD *pdwIndex = reinterpret_cast<DWORD *>(pData);
	switch( *pdwIndex )
	{
		// Track flags tab
		case 1:
		{
			PPGTrackFlagsParams *pPPGTrackFlagsParams = reinterpret_cast<PPGTrackFlagsParams *>(pData);

			// m_dwFlagsDM
			if( pPPGTrackFlagsParams->dwTrackExtrasFlags != m_pTrack->GetExtraFlags() )
			{
				m_pTrack->m_pSong->m_pUndoMgr->SaveState( m_pTrack->m_pSong, theApp.m_hInstance, IDS_UNDO_TRACK_EXTRAS_FLAGS );
				m_pTrack->SetExtraFlags( pPPGTrackFlagsParams->dwTrackExtrasFlags );

				// Sync changes
				m_pTrack->m_pSong->SetModified( TRUE );
				m_pTrack->m_pSong->SyncChanges( SC_DIRECTMUSIC, 0, NULL );
			}

			break;
		}

		default:
			ASSERT( 0 );
			break;
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CTrackPropPageObject IDMUSProdPropPageObject::OnShowProperties

HRESULT CTrackPropPageObject::OnShowProperties( void )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( theApp.m_pSongComponent != NULL );
	ASSERT( theApp.m_pSongComponent->m_pIFramework8 != NULL );

	// Get the Track's page manager
	CTrackPropPageManager* pPageManager;

	if( theApp.m_pIPageManager
	&&  theApp.m_pIPageManager->IsEqualPageManagerGUID( GUID_TrackPropPageManager ) == S_OK )
	{
		pPageManager = (CTrackPropPageManager *)theApp.m_pIPageManager;
	}
	else
	{
		pPageManager = new CTrackPropPageManager();
	}

	if( pPageManager == NULL )
	{
		return E_FAIL;
	}

	// Show the Track's properties
	IDMUSProdPropSheet* pIPropSheet;

	if( SUCCEEDED ( theApp.m_pSongComponent->m_pIFramework8->QueryInterface( IID_IDMUSProdPropSheet, (void**)&pIPropSheet ) ) )
	{
		if( pPageManager == theApp.m_pIPageManager )
		{
			pIPropSheet->GetActivePage( &CTrackPropPageManager::sm_nActiveTab );
		}
		short nActiveTab = CTrackPropPageManager::sm_nActiveTab;

		if( SUCCEEDED ( pIPropSheet->SetPageManager(pPageManager) ) )
		{
			theApp.m_pIPageManager = pPageManager;
			pPageManager->SetObject( this );
			pIPropSheet->SetActivePage( nActiveTab ); 
		}

		pIPropSheet->Show( TRUE );
		RELEASE( pIPropSheet );
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CTrackPropPageObject IDMUSProdPropPageObject::OnRemoveFromPageManager

HRESULT CTrackPropPageObject::OnRemoveFromPageManager( void )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SongDesigner\Track.cpp ===
// Track.cpp : implementation file
//

#include "stdafx.h"
#include "SongDesignerDLL.h"

#include "Song.h"
#include "Track.h"
#include "SegmentDesigner.h"
#include "StripMgr.h"		
#include <TrackFlagsPPG.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


//////////////////////////////////////////////////////////////////////
//	CTrack Constructor/Destructor

CTrack::CTrack( CDirectMusicSong* pSong )
{
    m_dwRef = 0;
	AddRef();

	ASSERT( pSong != NULL );
	m_pSong = pSong;
//	m_pSong->AddRef();			intentionally missing

	m_pSourceSegment = NULL;

	// UI
	m_TrackUI.dwTrackIndex = 0;
	m_dwBitsUI = 0;

	//		DMUS_IO_TRACK_HEADER
	memset( &m_clsidTrack, 0, sizeof(CLSID) );
    m_dwPosition = 0;
    m_dwGroup = 0;
    m_ckid = 0;
    m_fccType = 0;

	//		DMUS_IO_TRACK_EXTRAS_HEADER
    m_dwFlagsDM = 0;
    m_dwPriority = 0;
}

CTrack::CTrack( CDirectMusicSong* pSong, CSourceSegment* pSourceSegment, DWORD dwTrackIndex,
				DMUS_IO_TRACK_HEADER* pdmusTrackHeader, DMUS_IO_TRACK_EXTRAS_HEADER* pdmusTrackExtrasHeader )
{
    m_dwRef = 0;
	AddRef();

	ASSERT( pSong != NULL );
	m_pSong = pSong;
//	m_pSong->AddRef();			intentionally missing

	ASSERT( pSourceSegment != NULL );
	m_pSourceSegment = pSourceSegment;
	m_pSourceSegment->AddRef();

	// UI
	m_TrackUI.dwTrackIndex = dwTrackIndex;
	m_dwBitsUI = 0;

	//		DMUS_IO_TRACK_HEADER
	ASSERT( pdmusTrackHeader != NULL );
	m_clsidTrack = pdmusTrackHeader->guidClassID;
	m_dwPosition = pdmusTrackHeader->dwPosition;
	m_dwGroup = pdmusTrackHeader->dwGroup;
	m_ckid = pdmusTrackHeader->ckid;
	m_fccType = pdmusTrackHeader->fccType;

	//		DMUS_IO_TRACK_EXTRAS_HEADER
	ASSERT( pdmusTrackExtrasHeader != NULL );
	m_dwFlagsDM = pdmusTrackExtrasHeader->dwFlags;
	m_dwPriority = pdmusTrackExtrasHeader->dwPriority;
}

CTrack::~CTrack( void )
{
	RELEASE( m_pSourceSegment );
}


/////////////////////////////////////////////////////////////////////////////
// CTrack::Copy

void CTrack::Copy( CTrack* pTrack )
{
	ASSERT( pTrack != NULL );
	if ( pTrack == NULL )
	{
		return;
	}

	if( pTrack == this )
	{
		return;
	}

	ASSERT( pTrack->m_pSourceSegment != NULL );
	m_pSourceSegment = pTrack->m_pSourceSegment;
	m_pSourceSegment->AddRef();

	// UI
	m_TrackUI = pTrack->m_TrackUI;
	m_dwBitsUI = pTrack->m_dwBitsUI;

	//		DMUS_IO_TRACK_HEADER
	m_clsidTrack = pTrack->m_clsidTrack;
	m_dwPosition = pTrack->m_dwPosition;
	m_dwGroup = pTrack->m_dwGroup;
	m_ckid = pTrack->m_ckid;
	m_fccType = pTrack->m_fccType;

	//		DMUS_IO_TRACK_EXTRAS_HEADER
	m_dwFlagsDM = pTrack->m_dwFlagsDM;
	m_dwPriority = pTrack->m_dwPriority;
}


/////////////////////////////////////////////////////////////////////////////
// CTrack IUnknown implementation

HRESULT CTrack::QueryInterface( REFIID riid, LPVOID* ppvObj )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    if( ::IsEqualIID(riid, IID_IUnknown) )
    {
        *ppvObj = (IUnknown *)this;
    }
	else
	{
		*ppvObj = NULL;
		return E_NOINTERFACE;
	}

	AddRef();
	return S_OK;
}

ULONG CTrack::AddRef()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	AfxOleLockApp(); 
    return ++m_dwRef;
}

ULONG CTrack::Release()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    ASSERT( m_dwRef != 0 );

	AfxOleUnlockApp(); 
    --m_dwRef;

    if( m_dwRef == 0 )
    {
        delete this;
        return 0;
    }

    return m_dwRef;
}


/////////////////////////////////////////////////////////////////////////////
// CTrack Additional Methods

/////////////////////////////////////////////////////////////////////////////
// CTrack Load

HRESULT CTrack::Load( IDMUSProdRIFFStream* pIRiffStream, MMCKINFO* pckMain )
{
    IStream*       pIStream;
	MMCKINFO	   ck;
	DWORD		   dwByteCount;
	DWORD		   dwSize;
    HRESULT        hr = S_OK;

    pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

    while( pIRiffStream->Descend( &ck, pckMain, 0 ) == 0 )
	{
        switch( ck.ckid )
		{
			case DMUS_FOURCC_TRACKREF_CHUNK:
			{
				DMUS_IO_TRACKREF_HEADER dmusTrackRefIO;

				dwSize = min( ck.cksize, sizeof( DMUS_IO_TRACKREF_HEADER ) );
				hr = pIStream->Read( &dmusTrackRefIO, dwSize, &dwByteCount );
				if( FAILED( hr )
				||  dwByteCount != dwSize )
				{
					hr = E_FAIL;
					goto ON_ERROR;
				}

				m_pSourceSegment = m_pSong->IndexToSourceSegment( dmusTrackRefIO.dwSegmentID );
				if( m_pSourceSegment )
				{
					m_pSourceSegment->AddRef();
				}
				break;
			}

			case DMUS_FOURCC_TRACK_CHUNK:
			{
			    DMUS_IO_TRACK_HEADER dmusTrackIO;

				dwSize = min( ck.cksize, sizeof( DMUS_IO_TRACK_HEADER ) );
				hr = pIStream->Read( &dmusTrackIO, dwSize, &dwByteCount );
				if( FAILED( hr )
				||  dwByteCount != dwSize )
				{
					hr = E_FAIL;
					goto ON_ERROR;
				}

				m_clsidTrack = dmusTrackIO.guidClassID;
				m_dwPosition = dmusTrackIO.dwPosition;
				m_dwGroup = dmusTrackIO.dwGroup;
				m_ckid = dmusTrackIO.ckid;
				m_fccType = dmusTrackIO.fccType;
				break;
			}

			case DMUS_FOURCC_TRACK_EXTRAS_CHUNK:
			{
			    DMUS_IO_TRACK_EXTRAS_HEADER dmusTrackExtrasIO;

				dwSize = min( ck.cksize, sizeof( DMUS_IO_TRACK_EXTRAS_HEADER ) );
				hr = pIStream->Read( &dmusTrackExtrasIO, dwSize, &dwByteCount );
				if( FAILED( hr )
				||  dwByteCount != dwSize )
				{
					hr = E_FAIL;
					goto ON_ERROR;
				}

				m_dwFlagsDM = dmusTrackExtrasIO.dwFlags;
				m_dwPriority = dmusTrackExtrasIO.dwPriority;
				break;
			}

			case DMUS_FOURCC_TRACK_UI_CHUNK:
			{
			    ioTrackUI iTrackUI;

				dwSize = min( ck.cksize, sizeof( ioTrackUI ) );
				hr = pIStream->Read( &iTrackUI, dwSize, &dwByteCount );
				if( FAILED( hr )
				||  dwByteCount != dwSize )
				{
					hr = E_FAIL;
					goto ON_ERROR;
				}

				m_TrackUI.dwTrackIndex = iTrackUI.dwTrackIndex;
				break;
			}

			case DMUS_FOURCC_TRACK_COPY_PASTE_UI_CHUNK:
			{
			    ioTrackCopyPasteUI iTrackCopyPasteUI;

				dwSize = min( ck.cksize, sizeof( ioTrackCopyPasteUI ) );
				hr = pIStream->Read( &iTrackCopyPasteUI, dwSize, &dwByteCount );
				if( FAILED( hr )
				||  dwByteCount != dwSize )
				{
					hr = E_FAIL;
					goto ON_ERROR;
				}

				// This chunk only exists during drag/drop and copy/paste operations
				// It is used to re-establish correct links
				// Do not dereference these pointers because objects may have been deleted

				// m_pSourceSegment
				RELEASE( m_pSourceSegment );
				m_pSourceSegment = m_pSong->PtrToSourceSegment( iTrackCopyPasteUI.pSourceSegment );
				if( m_pSourceSegment )
				{
					m_pSourceSegment->AddRef();
				}
				break;
			}
        }

        pIRiffStream->Ascend( &ck, 0 );
    }

	if( m_pSourceSegment == NULL )
	{
		// Cannot use this track
		hr = S_FALSE;
	}

ON_ERROR:
    RELEASE( pIStream );
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CTrack Save

HRESULT CTrack::Save( IDMUSProdRIFFStream* pIRiffStream )
{
	IStream* pIStream;
	HRESULT hr;
	MMCKINFO ckMain;

    pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

	DMUSProdStreamInfo StreamInfo;
	StreamInfo.ftFileType = FT_RUNTIME;
	StreamInfo.guidDataFormat = GUID_CurrentVersion;
	StreamInfo.pITargetDirectoryNode = NULL;

	// Get additional stream information
	IDMUSProdPersistInfo* pPersistInfo;

	if( SUCCEEDED ( pIStream->QueryInterface( IID_IDMUSProdPersistInfo, (void **)&pPersistInfo ) ) )
	{
		pPersistInfo->GetStreamInfo( &StreamInfo );
		RELEASE( pPersistInfo );
	}
	
	static bool sfSequenceSaveLock = false;

	if( !sfSequenceSaveLock )
	{
		sfSequenceSaveLock = true;

		ASSERT( 0 == m_dwPosition );

		if( m_pSourceSegment
		&&	(CLSID_DirectMusicSeqTrack == m_clsidTrack)
		&&	((StreamInfo.ftFileType != FT_RUNTIME) || (GUID_DirectMusicObject == StreamInfo.guidDataFormat)) )
		{
			IDMUSProdNode* pISegmentNode;
			if( SUCCEEDED ( m_pSourceSegment->GetSegmentDocRootNode( &pISegmentNode ) ) )
			{
				// Get an IDMUSProdSegmentEdit8 interface pointer
				IDMUSProdSegmentEdit8* pISegmentEdit8;
				if( SUCCEEDED ( pISegmentNode->QueryInterface( IID_IDMUSProdSegmentEdit8, (void **)&pISegmentEdit8 ) ) )
				{
					DMUS_IO_TRACK_HEADER dmusTrackHeader;
					DMUS_IO_TRACK_EXTRAS_HEADER dmusTrackExtrasHeader;
					HRESULT hr = S_OK;

					DWORD dwSequenceIndex = 0;

					// Enumerate Tracks
					for( DWORD dwIdx = 0 ;  (hr == S_OK) ;  dwIdx++ )
					{
						hr = pISegmentEdit8->EnumTrack( dwIdx,
							 							sizeof(DMUS_IO_TRACK_HEADER), &dmusTrackHeader,
														sizeof(DMUS_IO_TRACK_EXTRAS_HEADER), &dmusTrackExtrasHeader );
						if( hr == S_OK )
						{
							// If this is a sequence track
							if( (m_dwGroup == dmusTrackHeader.dwGroup)
							&&	(CLSID_DirectMusicSeqTrack == dmusTrackHeader.guidClassID) )
							{
								if( dwSequenceIndex > 0 )
								{
									// Add the track to our list to display
									CTrack* pTrack = new CTrack( m_pSong );
									pTrack->Copy( this );
									pTrack->m_dwPosition = dwSequenceIndex;

									pTrack->Save( pIRiffStream );

									delete pTrack;
								}
								dwSequenceIndex++;
							}
						}
					}

					RELEASE( pISegmentEdit8 );
				}

				RELEASE( pISegmentNode );
			}
		}

		sfSequenceSaveLock = false;
	}

	// Write DMUS_FOURCC_TRACKREF_LIST header
	ckMain.fccType = DMUS_FOURCC_TRACKREF_LIST;
	if( pIRiffStream->CreateChunk(&ckMain, MMIO_CREATELIST) != 0 )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

	// Save Track header chunk
	hr = SaveTrackHeader( pIRiffStream );
	if( FAILED ( hr ) )
	{
		goto ON_ERROR;
	}

	// Save <trkh> Track header chunk
	hr = SaveSegmentTrackHeader( pIRiffStream );
	if( FAILED ( hr ) )
	{
		goto ON_ERROR;
	}

	// Save <trkx> Extras Track header chunk
	hr = SaveSegmentTrackExtrasHeader( pIRiffStream );
	if( FAILED ( hr ) )
	{
		goto ON_ERROR;
	}

	// Save UI chunk
	if( StreamInfo.ftFileType != FT_RUNTIME )
	{
		hr = SaveUI( pIRiffStream );
		if( FAILED ( hr ) )
		{
			goto ON_ERROR;
		}
	}

	// Save Copy/Paste UI chunk
	if( StreamInfo.ftFileType != FT_RUNTIME )
	{
		if( ::IsEqualGUID( StreamInfo.guidDataFormat, GUID_SaveSelectedVirtualSegments ) 
		||  ::IsEqualGUID( StreamInfo.guidDataFormat, GUID_SaveSelectedTracks ) )
		{
			hr = SaveCopyPasteUI( pIRiffStream );
			if( FAILED ( hr ) )
			{
				goto ON_ERROR;
			}
		}
	}

	if( pIRiffStream->Ascend(&ckMain, 0) != 0 )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

ON_ERROR:
    RELEASE( pIStream );
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CTrack SaveTrackHeader
    
HRESULT CTrack::SaveTrackHeader( IDMUSProdRIFFStream* pIRiffStream )
{
	IStream* pIStream;
	HRESULT hr;
	MMCKINFO ck;
	DWORD dwBytesWritten;
	DMUS_IO_TRACKREF_HEADER dmusTrackRefIO;

    pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

	// Write chunk header
	ck.ckid = DMUS_FOURCC_TRACKREF_CHUNK;
	if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

	// Prepare DMUS_IO_TRACKREF_HEADER structure
	memset( &dmusTrackRefIO, 0, sizeof(DMUS_IO_TRACKREF_HEADER) );

	dmusTrackRefIO.dwSegmentID = m_pSong->SourceSegmentToIndex( m_pSourceSegment );
	dmusTrackRefIO.dwFlags = 0;			// Not used

	// Write TrackRef header data
	hr = pIStream->Write( &dmusTrackRefIO, sizeof(DMUS_IO_TRACKREF_HEADER), &dwBytesWritten);
	if( FAILED( hr )
	||  dwBytesWritten != sizeof(DMUS_IO_TRACKREF_HEADER) )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}
	
	if( pIRiffStream->Ascend( &ck, 0 ) != 0 )
	{
 		hr = E_FAIL;
		goto ON_ERROR;
	}

ON_ERROR:
    RELEASE( pIStream );
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CTrack SaveSegmentTrackHeader
    
HRESULT CTrack::SaveSegmentTrackHeader( IDMUSProdRIFFStream* pIRiffStream )
{
	IStream* pIStream;
	HRESULT hr;
	MMCKINFO ck;
	DWORD dwBytesWritten;
	DMUS_IO_TRACK_HEADER dmusTrackIO;

    pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

	// Write chunk header
	ck.ckid = DMUS_FOURCC_TRACK_CHUNK;
	if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

	// Prepare DMUS_IO_TRACK_HEADER structure
	memset( &dmusTrackIO, 0, sizeof(DMUS_IO_TRACK_HEADER) );

    dmusTrackIO.guidClassID = m_clsidTrack;
    dmusTrackIO.dwPosition = m_dwPosition;
    dmusTrackIO.dwGroup = m_dwGroup;
    dmusTrackIO.ckid = m_ckid;
    dmusTrackIO.fccType = m_fccType;

	// Write Track header data
	hr = pIStream->Write( &dmusTrackIO, sizeof(DMUS_IO_TRACK_HEADER), &dwBytesWritten);
	if( FAILED( hr )
	||  dwBytesWritten != sizeof(DMUS_IO_TRACK_HEADER) )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}
	
	if( pIRiffStream->Ascend( &ck, 0 ) != 0 )
	{
 		hr = E_FAIL;
		goto ON_ERROR;
	}

ON_ERROR:
    RELEASE( pIStream );
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CTrack SaveSegmentTrackExtrasHeader
    
HRESULT CTrack::SaveSegmentTrackExtrasHeader( IDMUSProdRIFFStream* pIRiffStream )
{
	IStream* pIStream;
	HRESULT hr;
	MMCKINFO ck;
	DWORD dwBytesWritten;
	DMUS_IO_TRACK_EXTRAS_HEADER dmusTrackExtrasIO;

    pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

	// Write chunk header
	ck.ckid = DMUS_FOURCC_TRACK_EXTRAS_CHUNK;
	if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

	// Prepare DMUS_IO_TRACK_EXTRAS_HEADER structure
	memset( &dmusTrackExtrasIO, 0, sizeof(DMUS_IO_TRACK_EXTRAS_HEADER) );

    dmusTrackExtrasIO.dwFlags = m_dwFlagsDM;
    dmusTrackExtrasIO.dwPriority = m_dwPriority;

	// Write TrackExtras header data
	hr = pIStream->Write( &dmusTrackExtrasIO, sizeof(DMUS_IO_TRACK_EXTRAS_HEADER), &dwBytesWritten);
	if( FAILED( hr )
	||  dwBytesWritten != sizeof(DMUS_IO_TRACK_EXTRAS_HEADER) )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}
	
	if( pIRiffStream->Ascend( &ck, 0 ) != 0 )
	{
 		hr = E_FAIL;
		goto ON_ERROR;
	}

ON_ERROR:
    RELEASE( pIStream );
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CTrack SaveCopyPasteUI
    
HRESULT CTrack::SaveCopyPasteUI( IDMUSProdRIFFStream* pIRiffStream )
{
	IStream* pIStream;
	HRESULT hr;
	MMCKINFO ck;
	DWORD dwBytesWritten;
	ioTrackCopyPasteUI oTrackCopyPasteUI;

    pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

	// Write chunk header
	ck.ckid = DMUS_FOURCC_TRACK_COPY_PASTE_UI_CHUNK;
	if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

	// Prepare ioTrackCopyPasteUI structure
	memset( &oTrackCopyPasteUI, 0, sizeof(ioTrackCopyPasteUI) );

	oTrackCopyPasteUI.pSourceSegment = m_pSourceSegment;

	// Write ioTrackCopyPasteUI structure
	hr = pIStream->Write( &oTrackCopyPasteUI, sizeof(ioTrackCopyPasteUI), &dwBytesWritten);
	if( FAILED( hr )
	||  dwBytesWritten != sizeof(ioTrackCopyPasteUI) )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}
	
	if( pIRiffStream->Ascend( &ck, 0 ) != 0 )
	{
 		hr = E_FAIL;
		goto ON_ERROR;
	}

ON_ERROR:
    RELEASE( pIStream );
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CTrack SaveUI
    
HRESULT CTrack::SaveUI( IDMUSProdRIFFStream* pIRiffStream )
{
	IStream* pIStream;
	HRESULT hr;
	MMCKINFO ck;
	DWORD dwBytesWritten;

    pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

	// Write chunk header
	ck.ckid = DMUS_FOURCC_TRACK_UI_CHUNK;
	if( pIRiffStream->CreateChunk( &ck, 0 ) != 0 )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}

	// Write UI chunk data
	hr = pIStream->Write( &m_TrackUI, sizeof(ioTrackUI), &dwBytesWritten);
	if( FAILED( hr )
	||  dwBytesWritten != sizeof(ioTrackUI) )
	{
		hr = E_FAIL;
		goto ON_ERROR;
	}
	
	if( pIRiffStream->Ascend( &ck, 0 ) != 0 )
	{
 		hr = E_FAIL;
		goto ON_ERROR;
	}

ON_ERROR:
    RELEASE( pIStream );
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CTrack FormatTextUI

void CTrack::FormatTextUI( CString& strText )
{
	// Get Segment filename
	CString strFileName;
	FormatFileNameText( strFileName );
	strFileName += _T(" ");

	// Get track group
	CString strTrackGroup;
	FormatTrackGroupText( strTrackGroup );
	strTrackGroup += _T(": ");

	// Get track name
	CString strTrackName;
	theApp.m_pSongComponent->GetRegisteredTrackName( m_clsidTrack, strTrackName );

	strText = strFileName + strTrackGroup + strTrackName;
}


/////////////////////////////////////////////////////////////////////////////
// CTrack::FormatFileNameText

void CTrack::FormatFileNameText( CString& strText )
{
	strText.Empty();

	IDMUSProdNode* pISegmentNode;
	if( SUCCEEDED ( m_pSourceSegment->GetSegmentDocRootNode( &pISegmentNode ) ) )
	{
		BSTR bstrText;
		if( SUCCEEDED ( theApp.m_pSongComponent->m_pIFramework8->GetNodeFileName( pISegmentNode, &bstrText ) ) )
		{
			strText = bstrText;
			::SysFreeString( bstrText );
			int nFindPos = strText.ReverseFind( (TCHAR)'\\' );
			if( nFindPos != -1 )
			{
				strText = strText.Right( strText.GetLength() - nFindPos - 1 );
			}
			strText = _T("[") + strText + _T("] ");
		}

		RELEASE( pISegmentNode );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTrack::FormatTrackGroupText

void CTrack::FormatTrackGroupText( CString& strText )
{
	CString strTmp;
	BOOL fFoundGroup = FALSE;
	BOOL fLastSet = FALSE;
	int nStartGroup = -1;

	strText.Empty();

	for( int i = 0 ;  i < 32 ;  i++ )
	{
		if( m_dwGroup & (1 << i) )
		{
			if( !fLastSet )
			{
				fLastSet = TRUE;
				nStartGroup = i;
			}
		}
		else
		{
			if( fLastSet )
			{
				fLastSet = FALSE;
				if( nStartGroup == i - 1 )
				{
					if( fFoundGroup )
					{
						strTmp.Format(", %d", i);
					}
					else
					{
						strTmp.Format("%d", i);
						fFoundGroup = TRUE;
					}
				}
				else
				{
					if( fFoundGroup )
					{
						strTmp.Format(", %d-%d", nStartGroup + 1, i);
					}
					else
					{
						strTmp.Format("%d-%d", nStartGroup + 1, i);
						fFoundGroup = TRUE;
					}
				}
				strText += strTmp;
			}
		}
	}

	if( fLastSet )
	{
		fLastSet = FALSE;
		if( nStartGroup == i - 1 )
		{
			if( fFoundGroup )
			{
				strTmp.Format(", %d", i);
			}
			else
			{
				strTmp.Format("%d", i);
				fFoundGroup = TRUE;
			}
		}
		else
		{
			if( fFoundGroup )
			{
				strTmp.Format(", %d-%d", nStartGroup + 1, i);
			}
			else
			{
				strTmp.Format("%d-%d", nStartGroup + 1, i);
				fFoundGroup = TRUE;
			}
		}
		strText += strTmp;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTrack::GetExtraFlags

DWORD CTrack::GetExtraFlags( void )
{
	return m_dwFlagsDM;
}


/////////////////////////////////////////////////////////////////////////////
// CTrack::SetExtraFlags

void CTrack::SetExtraFlags( DWORD dwNewFlagsDM )
{
	m_dwFlagsDM = dwNewFlagsDM;
}


/////////////////////////////////////////////////////////////////////////////
// CTrack::GetExtraMask

DWORD CTrack::GetExtraMask( void )
{
	DWORD dwExtraMask = ALLEXTRAS_FLAGS;

	GUID guidStripMgr;
	if( SUCCEEDED( GUIDToStripMgr( m_clsidTrack, &guidStripMgr ) ) )
	{
		IDMUSProdStripMgr* pIStripMgr;
		if( SUCCEEDED ( CoCreateInstance( guidStripMgr, NULL, CLSCTX_INPROC, IID_IDMUSProdStripMgr, (void**)&pIStripMgr ) ) )
		{
			VARIANT var;
			var.vt = VT_I4;

			if( SUCCEEDED( pIStripMgr->GetStripMgrProperty( SMP_DMUSIOTRACKEXTRASHEADER_MASK, &var ) ) )
			{
				dwExtraMask  = V_I4(&var);
			}

			RELEASE( pIStripMgr );
		}
	}

	return dwExtraMask;
}


/////////////////////////////////////////////////////////////////////////////
// CTrack::GUIDToStripMgr

HRESULT CTrack::GUIDToStripMgr( REFGUID guidCLSID, GUID* pguidStripMgr )
{
	if ( pguidStripMgr == NULL )
	{
		return E_INVALIDARG;
	}

	LONG	lResult;

	TCHAR    szGuid[MID_BUFFER];
	LPOLESTR psz;
	
	if( FAILED( StringFromIID(guidCLSID, &psz) ) )
	{
		TRACE("Song: Unable to convert GUID to string.\n");
		goto ON_ERR;
	}

	WideCharToMultiByte( CP_ACP, 0, psz, -1, szGuid, sizeof(szGuid), NULL, NULL );
	CoTaskMemFree( psz );

	TCHAR	szRegPath[MAX_BUFFER];
	HKEY	hKeyTrack;

	_tcscpy( szRegPath, _T("Software\\Microsoft\\DMUSProducer\\StripEditors\\") );
	_tcscat( szRegPath, szGuid );
	lResult = ::RegOpenKeyEx( HKEY_LOCAL_MACHINE, szRegPath, 0, KEY_READ, &hKeyTrack );
	if ( lResult != ERROR_SUCCESS )
	{
		TRACE("Song: Unable to find track GUID.\n");
		goto ON_ERR;
	}

	_TCHAR	achClsId[MID_BUFFER];
	DWORD	dwType, dwCbData;
	dwCbData = MID_BUFFER;
	lResult  = ::RegQueryValueEx( hKeyTrack, _T("StripManager"), NULL,
				&dwType, (LPBYTE)achClsId, &dwCbData );
	::RegCloseKey( hKeyTrack );
	if( (lResult != ERROR_SUCCESS) || (dwType != REG_SZ) )
	{
		TRACE("Song: Unable to find Strip Manager CLSID in Track's key.\n");
		goto ON_ERR;
	}

	wchar_t awchClsId[80];

	if( MultiByteToWideChar( CP_ACP, 0, achClsId, -1, awchClsId, sizeof(awchClsId) / sizeof(wchar_t) ) != 0 )
	{
		IIDFromString( awchClsId, pguidStripMgr );
		return S_OK;
	}

ON_ERR:
	TRACE("Song: Using UnknownStripMgr as default\n");
	memcpy( pguidStripMgr, &CLSID_UnknownStripMgr, sizeof(GUID) );
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SongDesigner\TrackPropPageObject.h ===
#ifndef __TRAKCPROPPAGEOBJECT_H_
#define __TRAKCPROPPAGEOBJECT_H_


typedef struct _PPGTrack
{
	_PPGTrack( void )
	{
		dwPageIndex = 0;
		pSong = NULL;
		pTrack = NULL;
	}

	DWORD				dwPageIndex;
	CDirectMusicSong*	pSong;
	CTrack*				pTrack;
} PPGTrack;


//////////////////////////////////////////////////////////////////////
//  CTrackPropPageManager

class CTrackPropPageManager : public IDMUSProdPropPageManager 
{
friend class CTrackFlagsPPG;

public:
	CTrackPropPageManager();
	virtual ~CTrackPropPageManager();

    // IUnknown functions
    HRESULT STDMETHODCALLTYPE QueryInterface( REFIID riid, LPVOID *ppv );
    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();

    // IDMUSProdPropPageManager functions
    HRESULT STDMETHODCALLTYPE GetPropertySheetTitle( BSTR* pbstrTitle, BOOL* pfAddPropertiesText );
    HRESULT STDMETHODCALLTYPE GetPropertySheetPages( IDMUSProdPropSheet* pIPropSheet, LONG* hPropSheetPage[], short* pnNbrPages );
	HRESULT STDMETHODCALLTYPE OnRemoveFromPropertySheet();

    HRESULT STDMETHODCALLTYPE SetObject( IDMUSProdPropPageObject* pINewPropPageObject );
    HRESULT STDMETHODCALLTYPE RemoveObject( IDMUSProdPropPageObject* pIPropPageObject );
    HRESULT STDMETHODCALLTYPE IsEqualObject( IDMUSProdPropPageObject* pIPropPageObject );

    HRESULT STDMETHODCALLTYPE RefreshData();
    HRESULT STDMETHODCALLTYPE IsEqualPageManagerGUID( REFGUID rguidPageManager );

	//Additional functions
private:
	void RemoveCurrentObject();

	// Member variables
private:
    DWORD						m_dwRef;
	IDMUSProdPropSheet*			m_pIPropSheet;
	IDMUSProdPropPageObject*	m_pIPropPageObject;
	
	CTrackFlagsPPG*				m_pTabFlags;

public:
	static short				sm_nActiveTab;
};


//////////////////////////////////////////////////////////////////////
//  CTrackPropPageObject

class CTrackPropPageObject : public IDMUSProdPropPageObject
{
friend class CTrackPropPageManager;

public:
	CTrackPropPageObject( CSongDlg* pSongDlg );
	virtual ~CTrackPropPageObject();

    // IUnknown functions
    HRESULT STDMETHODCALLTYPE QueryInterface( REFIID riid, LPVOID *ppv );
    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();

    // IDMUSProdPropPageObject functions
    HRESULT STDMETHODCALLTYPE GetData( void** ppData );
    HRESULT STDMETHODCALLTYPE SetData( void* pData );
	HRESULT STDMETHODCALLTYPE OnShowProperties();
	HRESULT STDMETHODCALLTYPE OnRemoveFromPageManager();

	// Additional methods

private:
    DWORD				m_dwRef;
	CSongDlg*			m_pSongDlg;

	CTrack*				m_pTrack;
	DWORD				m_dwFlagsUI;
};

#endif // __TRAKCPROPPAGEOBJECT_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SongDesigner\Transition.h ===
#ifndef __TRANSITION_H_
#define __TRANSITION_H_

#include "RiffStrm.h"

class CVirtualSegment;


#define DMUS_FOURCC_TRANSITION_COPY_PASTE_UI_CHUNK	mmioFOURCC('c','p','t','u')

#pragma pack(2)

typedef struct ioTransitionCopyPasteUI
{
	ioTransitionCopyPasteUI()
	{
		dwToSegmentFlag = DMUS_SONG_ANYSEG;
		pToSegment = NULL;
		pTransitionSegment = NULL;
		dwPlayFlagsDM = 0;
	}

	DWORD				dwToSegmentFlag;
	CVirtualSegment*	pToSegment;				// From Virtual Segment list
	CVirtualSegment*	pTransitionSegment;		// From Virtual Segment list
	DWORD				dwPlayFlagsDM;
} ioTransitionCopyPasteUI;

#pragma pack()


//////////////////////////////////////////////////////////////////////
//  CTransition

class CTransition : public IUnknown
{
friend class CVirtualSegment;
friend class CSongDlg;
friend class CTransitionListBox;
friend class CTransitionPropPageObject;

public:
	CTransition( CDirectMusicSong* pSong );
	virtual ~CTransition();
	void Copy( CTransition* pTransition );

    // IUnknown functions
    HRESULT STDMETHODCALLTYPE QueryInterface( REFIID riid, LPVOID *ppv );
    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();

	// Additional methods
	void FormatTextUI( CString& strText );

private:
    DWORD					m_dwRef;
	CDirectMusicSong*		m_pSong;

	// UI
	DWORD					m_dwToSegmentFlag;
	bool					m_fResolveToSegmentID;
	DWORD					m_dwToSegmentID;
	bool					m_fResolveTransitionSegmentID;
	DWORD					m_dwTransitionSegmentID;
	DWORD					m_dwBitsUI;

	// Persisted for DirectMusic
	//		DMUS_IO_TRANSITION_DEF
	CVirtualSegment*		m_pToSegment;			// From Virtual Segment list
	CVirtualSegment*		m_pTransitionSegment;	// From Virtual Segment list
	DWORD					m_dwPlayFlagsDM;
};

#endif // __TRANSITION_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SongDesigner\Track.h ===
#ifndef __TRACK_H_
#define __TRACK_H_

#include "RiffStrm.h"
#include <dmusicf.h>


#define DMUS_FOURCC_TRACK_UI_CHUNK				mmioFOURCC('t','k','u','i')
#define DMUS_FOURCC_TRACK_COPY_PASTE_UI_CHUNK	mmioFOURCC('t','c','p','u')


#pragma pack(2)

typedef struct ioTrackUI
{
	ioTrackUI()
	{
		dwTrackIndex = 0;	
	}

	DWORD	dwTrackIndex;	// Index into Segment			
} ioTrackUI;

typedef struct ioTrackCopyPasteUI
{
	ioTrackCopyPasteUI()
	{
		pSourceSegment = NULL;
	}

	CSourceSegment*		pSourceSegment;			// From Source Segment list
} ioTrackCopyPasteUI;

#pragma pack()


//////////////////////////////////////////////////////////////////////
//  CTrack

class CTrack : public IUnknown
{
friend class CDirectMusicSong;
friend class CVirtualSegment;
friend class CSongDlg;
friend class CTrackListBox;
friend class CDlgAddTracks;
friend class CTrackPropPageObject;

public:
	CTrack( CDirectMusicSong* pSong );
	CTrack( CDirectMusicSong* pSong, CSourceSegment* pSourceSegment,
			DWORD dwTrackIndex,
			DMUS_IO_TRACK_HEADER* pdmusTrackHeader,
			DMUS_IO_TRACK_EXTRAS_HEADER* pdmusTrackExtrasHeader );
	virtual ~CTrack();
	void Copy( CTrack* pTrack );

    // IUnknown functions
    HRESULT STDMETHODCALLTYPE QueryInterface( REFIID riid, LPVOID *ppv );
    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();

	// Additional methods
	HRESULT Load( IDMUSProdRIFFStream* pIRiffStream, MMCKINFO* pckMain );
    HRESULT Save( IDMUSProdRIFFStream* pIRiffStream );
    HRESULT SaveTrackHeader( IDMUSProdRIFFStream* pIRiffStream );
    HRESULT SaveSegmentTrackHeader( IDMUSProdRIFFStream* pIRiffStream );
    HRESULT SaveSegmentTrackExtrasHeader( IDMUSProdRIFFStream* pIRiffStream );
    HRESULT SaveUI( IDMUSProdRIFFStream* pIRiffStream );
	HRESULT SaveCopyPasteUI( IDMUSProdRIFFStream* pIRiffStream );
	void FormatTextUI( CString& strText );
	void FormatFileNameText( CString& strText );
	void FormatTrackGroupText( CString& strText );
	DWORD GetExtraFlags();
	void SetExtraFlags( DWORD dwNewFlagsDM );
	DWORD GetExtraMask();
	HRESULT GUIDToStripMgr( REFGUID guidCLSID, GUID* guidStripMgr );

private:
    DWORD					m_dwRef;
	CDirectMusicSong*		m_pSong;
	CSourceSegment*			m_pSourceSegment;	// Track is from this Segment

	//		UI
	ioTrackUI				m_TrackUI;
	DWORD					m_dwBitsUI;

	// Persisted for DirectMusic
	//		DMUS_IO_TRACK_HEADER
    CLSID					m_clsidTrack;     // Class id of track 
    DWORD					m_dwPosition;     // Position in track list
    DWORD					m_dwGroup;        // Group bits for track
    FOURCC					m_ckid;           // Chunk ID of track's data chunk
    FOURCC					m_fccType;        // List type if ckid is RIFF or LIST

	//		DMUS_IO_TRACK_EXTRAS_HEADER
    DWORD					m_dwFlagsDM;      // DX8 Added flags for control tracks
    DWORD					m_dwPriority;     // Priority for composition
};

#endif // __TRACK_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SongDesigner\TransitionPropPageObject.cpp ===
// TransitionPropPageObject.cpp : implementation file
//

#include "stdafx.h"
#include "SongDesignerDLL.h"

#include "Song.h"
#include "SongDlg.h"
#include "TabTransition.h"
#include <TabBoundaryFlags.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


short CTransitionPropPageManager::sm_nActiveTab = 0;

//////////////////////////////////////////////////////////////////////
// CTransitionPropPageManager Construction/Destruction
//////////////////////////////////////////////////////////////////////

CTransitionPropPageManager::CTransitionPropPageManager()
{
    m_dwRef = 0;
	AddRef();

	m_pIPropPageObject = NULL;
	m_pIPropSheet = NULL;

	m_pTabTransition = NULL;
	m_pTabBoundary = NULL;
}

CTransitionPropPageManager::~CTransitionPropPageManager()
{
	RELEASE( m_pIPropSheet );

	if( m_pTabTransition )
	{
		delete m_pTabTransition;
	}

	if( m_pTabBoundary )
	{
		delete m_pTabBoundary;
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTransitionPropPageManager::RemoveCurrentObject

void CTransitionPropPageManager::RemoveCurrentObject( void )
{
	if( m_pIPropPageObject == NULL )
	{
		return;
	}

	m_pIPropPageObject->OnRemoveFromPageManager();
	m_pIPropPageObject = NULL;
}


/////////////////////////////////////////////////////////////////////////////
// CTransitionPropPageManager IUnknown implementation

HRESULT CTransitionPropPageManager::QueryInterface( REFIID riid, LPVOID FAR* ppvObj )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    if( ::IsEqualIID(riid, IID_IDMUSProdPropPageManager)
	||  ::IsEqualIID(riid, IID_IUnknown) )
    {
        AddRef();
        *ppvObj = (IDMUSProdPropPageManager *)this;
        return S_OK;
    }

    *ppvObj = NULL;
    return E_NOINTERFACE;
}

ULONG CTransitionPropPageManager::AddRef()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    return ++m_dwRef;
}

ULONG CTransitionPropPageManager::Release()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    ASSERT( m_dwRef != 0 );

    --m_dwRef;

    if( m_dwRef == 0 )
    {
        delete this;
        return 0;
    }

    return m_dwRef;
}


/////////////////////////////////////////////////////////////////////////////
// CTransitionPropPageManager IDMUSProdPropPageManager implementation

/////////////////////////////////////////////////////////////////////////////
// CTransitionPropPageManager IDMUSProdPropPageManager::GetPropertySheetTitle

HRESULT CTransitionPropPageManager::GetPropertySheetTitle( BSTR* pbstrTitle, BOOL* pfAddPropertiesText )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( (pbstrTitle == NULL)
	||  (pfAddPropertiesText == NULL) )
	{
		return E_POINTER;
	}

	*pfAddPropertiesText = TRUE;

	CString strTitle;

	PPGTransition ppgTransition;
	PPGTransition* pPPGTransition = &ppgTransition;

	if( m_pIPropPageObject 
	&& (SUCCEEDED (m_pIPropPageObject->GetData((void **)&pPPGTransition))) )
	{
		if( ppgTransition.pSong
		&&  ppgTransition.pTransition )
		{
			CString strName;
			BSTR bstrName;

			strTitle.LoadString( IDS_SONG_TEXT );
			strTitle += _T(": ");

			// Add name of Song
			if( ppgTransition.pSong )
			{
				if( SUCCEEDED ( ppgTransition.pSong->GetNodeName( &bstrName ) ) )
				{
					strName = bstrName;
					::SysFreeString( bstrName );
			
					strTitle += strName;
					strTitle += _T(" - ");
				}
			}
		}
	}

	// Add "Transition"
	CString strTransition;
	strTransition.LoadString( IDS_TRANSITION_TEXT );
	strTitle += strTransition;

	*pbstrTitle = strTitle.AllocSysString();

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CTransitionPropPageManager IDMUSProdPropPageManager::GetPropertySheetPages

HRESULT CTransitionPropPageManager::GetPropertySheetPages( IDMUSProdPropSheet* pIPropSheet, LONG* hPropSheetPage[], short* pnNbrPages )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( (hPropSheetPage == NULL)
	||  (pnNbrPages == NULL) )
	{
		return E_POINTER;
	}

	if( pIPropSheet == NULL )
	{
		return E_INVALIDARG;
	}

	m_pIPropSheet = pIPropSheet;
	m_pIPropSheet->AddRef();

	hPropSheetPage[0] = NULL;
	*pnNbrPages = 0;

	HPROPSHEETPAGE hPage;
	short nNbrPages = 0;

	// Add Transition tab
	m_pTabTransition = new CTabTransition( this );
	if( m_pTabTransition )
	{
		hPage = ::CreatePropertySheetPage( (LPPROPSHEETPAGE)&m_pTabTransition->m_psp );
		if( hPage )
		{
			hPropSheetPage[nNbrPages] = (LONG *)hPage;
			nNbrPages++;
		}			
	}

	// Add Boundary tab
	m_pTabBoundary = new CTabBoundaryFlags( this );
	m_pTabBoundary->UseTransitionPrompts( TRUE );
	if( m_pTabBoundary )
	{
		hPage = ::CreatePropertySheetPage( (LPPROPSHEETPAGE)&m_pTabBoundary->m_psp );
		if( hPage )
		{
			hPropSheetPage[nNbrPages] = (LONG *)hPage;
			nNbrPages++;
		}			
	}

	// Set number of pages
	*pnNbrPages = nNbrPages;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CTransitionPropPageManager IDMUSProdPropPageManager::OnRemoveFromPropertySheet

HRESULT CTransitionPropPageManager::OnRemoveFromPropertySheet()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( m_pIPropSheet != NULL );
	m_pIPropSheet->GetActivePage( &CTransitionPropPageManager::sm_nActiveTab );

	RemoveCurrentObject();
	theApp.m_pIPageManager = NULL;

	Release();	// delete myself

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CTransitionPropPageManager IDMUSProdPropPageManager::SetObject

HRESULT CTransitionPropPageManager::SetObject( IDMUSProdPropPageObject* pINewPropPageObject )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( pINewPropPageObject == NULL )
	{
		return E_INVALIDARG;
	}

	if( m_pTabTransition )
	{
		m_pTabTransition->SetObject( pINewPropPageObject );
	}

	if( m_pTabBoundary )
	{
		m_pTabBoundary->SetObject( pINewPropPageObject );
	}
	
	if( m_pIPropPageObject != pINewPropPageObject )
	{
		RemoveCurrentObject();

		m_pIPropPageObject = pINewPropPageObject;
//		m_pIPropPageObject->AddRef();		intentionally missing
	}

	RefreshData();

	if( m_pIPropSheet )
	{
		m_pIPropSheet->RefreshTitle();
		m_pIPropSheet->RefreshActivePage();
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CTransitionPropPageManager IDMUSProdPropPageManager::RemoveObject

HRESULT CTransitionPropPageManager::RemoveObject( IDMUSProdPropPageObject* pIPropPageObject )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( (pIPropPageObject == NULL)
	||  (pIPropPageObject != m_pIPropPageObject) )
	{
		return E_INVALIDARG;
	}

	RemoveCurrentObject();
	RefreshData();

	if( m_pIPropSheet )
	{
		m_pIPropSheet->RefreshTitle();
		m_pIPropSheet->RefreshActivePage();
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CTransitionPropPageManager  IDMUSProdPropPageManager::IsEqualObject

HRESULT FAR EXPORT CTransitionPropPageManager::IsEqualObject( IDMUSProdPropPageObject* pIPropPageObject )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( pIPropPageObject == NULL )
	{
		return E_INVALIDARG;
	}

	if( pIPropPageObject == m_pIPropPageObject )
	{
		return S_OK;
	}

	return S_FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// CTransitionPropPageManager IDMUSProdPropPageManager::RefreshData

HRESULT CTransitionPropPageManager::RefreshData( void )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( m_pTabTransition )
	{
		m_pTabTransition->RefreshTab();
	}

	if( m_pTabBoundary )
	{
		m_pTabBoundary->RefreshTab();
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CTransitionPropPageManager  IDMUSProdPropPageManager::IsEqualPageManagerGUID

HRESULT CTransitionPropPageManager::IsEqualPageManagerGUID( REFGUID rguidPageManager )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( ::IsEqualGUID(rguidPageManager, GUID_TransitionPropPageManager) )
	{
		return S_OK;
	}

	return S_FALSE;
}


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////
//	CTransitionPropPageObject Constructor/Destructor

CTransitionPropPageObject::CTransitionPropPageObject( CSongDlg* pSongDlg )
{
    m_dwRef = 0;
	AddRef();

	ASSERT( pSongDlg != NULL );
	m_pSongDlg = pSongDlg;
//	m_pSongDlg->AddRef();		intentionally missing

	m_pTransition = NULL;
	m_dwFlagsUI = 0;
}

CTransitionPropPageObject::~CTransitionPropPageObject( void )
{
	ASSERT( theApp.m_pSongComponent != NULL );
	ASSERT( theApp.m_pSongComponent->m_pIFramework8 != NULL );

	// Remove TransitionPropPageObject from property sheet
	IDMUSProdPropSheet* pIPropSheet;
	if( SUCCEEDED ( theApp.m_pSongComponent->m_pIFramework8->QueryInterface( IID_IDMUSProdPropSheet, (void**)&pIPropSheet ) ) )
	{
		pIPropSheet->RemovePageManagerByObject( this );
		RELEASE( pIPropSheet );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CTransitionPropPageObject IUnknown implementation

HRESULT CTransitionPropPageObject::QueryInterface( REFIID riid, LPVOID* ppvObj )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    if( ::IsEqualIID(riid, IID_IDMUSProdPropPageObject)
	||  ::IsEqualIID(riid, IID_IUnknown) )
    {
        *ppvObj = (IDMUSProdPropPageObject *)this;
    }
	else
	{
		*ppvObj = NULL;
		return E_NOINTERFACE;
	}

	AddRef();
	return S_OK;
}

ULONG CTransitionPropPageObject::AddRef()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	AfxOleLockApp(); 
    return ++m_dwRef;
}

ULONG CTransitionPropPageObject::Release()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    ASSERT( m_dwRef != 0 );

	AfxOleUnlockApp(); 
    --m_dwRef;

    if( m_dwRef == 0 )
    {
        delete this;
        return 0;
    }

    return m_dwRef;
}


/////////////////////////////////////////////////////////////////////////////
// CTransitionPropPageObject IDMUSProdPropPageObject implementation

/////////////////////////////////////////////////////////////////////////////
// CTransitionPropPageObject IDMUSProdPropPageObject::GetData

HRESULT CTransitionPropPageObject::GetData( void** ppData )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if( (ppData == NULL)
	|| (*ppData == NULL) )
	{
		return E_INVALIDARG;
	}

	int nSelCount = m_pSongDlg->GetTransitionSelCount();
	if( nSelCount > 1 )
	{
		m_pTransition = NULL;
		m_dwFlagsUI = PROPF_MULTI_SELECTED;
	}
	else
	{
		m_pTransition = m_pSongDlg->GetTransitionToEdit();
		if( m_pTransition )
		{
			m_dwFlagsUI = PROPF_ONE_SELECTED;
		}
		else
		{
			m_dwFlagsUI = PROPF_NONE_SELECTED;
		}
	}

	DWORD *pdwIndex = static_cast<DWORD *>(*ppData);
	switch( *pdwIndex )
	{
		// Asking for Song, VirtualSegment and Transition pointers
		case 0:
		{
			PPGTransition *pPPGTransition = reinterpret_cast<PPGTransition *>(*ppData);

			if( m_pTransition )
			{
				pPPGTransition->pSong = m_pTransition->m_pSong;
				if( m_pSongDlg )
				{
					pPPGTransition->pVirtualSegmentToEdit = m_pSongDlg->GetVirtualSegmentToEdit();
				}
				else
				{
					pPPGTransition->pVirtualSegmentToEdit = NULL;
				}
			}
			else
			{
				pPPGTransition->pSong = NULL;
				pPPGTransition->pVirtualSegmentToEdit = NULL;
			}
			pPPGTransition->pTransition = m_pTransition;
			break;
		}

		// Transition tab
		case 1:
		{
			PPGTabTransition *pPPGTabTransition = reinterpret_cast<PPGTabTransition *>(*ppData);

			if( m_pTransition )
			{
				pPPGTabTransition->dwToSegmentFlag = m_pTransition->m_dwToSegmentFlag;
				pPPGTabTransition->pToSegment = m_pTransition->m_pToSegment;
				pPPGTabTransition->pTransitionSegment = m_pTransition->m_pTransitionSegment;
				pPPGTabTransition->pSong = m_pTransition->m_pSong;
			}
			else
			{
				pPPGTabTransition->dwToSegmentFlag = 0;
				pPPGTabTransition->pToSegment = NULL;
				pPPGTabTransition->pTransitionSegment = NULL;
				pPPGTabTransition->pSong = NULL;
			}
			pPPGTabTransition->dwFlagsUI = m_dwFlagsUI;
			break;
		}

		// Boundary tab
		case 2:
		{
			PPGTabBoundaryFlags *pPPGTabBoundaryFlags = reinterpret_cast<PPGTabBoundaryFlags *>(*ppData);

			if( m_pTransition )
			{
				pPPGTabBoundaryFlags->dwPlayFlags = m_pTransition->m_dwPlayFlagsDM;
				pPPGTabBoundaryFlags->dwFlagsUI = PROPF_HAVE_VALID_DATA;
				m_pTransition->FormatTextUI( pPPGTabBoundaryFlags->strPrompt );
			}
			else
			{
				pPPGTabBoundaryFlags->dwPlayFlags = 0;
				pPPGTabBoundaryFlags->dwFlagsUI = 0;
				if( m_dwFlagsUI & PROPF_MULTI_SELECTED )
				{
					pPPGTabBoundaryFlags->strPrompt.LoadString( IDS_MULTIPLE_TRANSITIONS_SELECTED );
				}
				else
				{
					pPPGTabBoundaryFlags->strPrompt.Empty();
				}
			}
			break;
		}

		default:
			ASSERT( 0 );
			break;
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CTransitionPropPageObject IDMUSProdPropPageObject::SetData

HRESULT CTransitionPropPageObject::SetData( void* pData )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	// Validate parameter
	if( pData == NULL )
	{
		return E_POINTER;
	}

	if( m_pTransition == NULL )
	{
		ASSERT( 0 );
		return E_UNEXPECTED;
	}
	
	DWORD *pdwIndex = reinterpret_cast<DWORD *>(pData);
	switch( *pdwIndex )
	{
		// Transition tab
		case 1:
		{
			PPGTabTransition *pPPGTabTransition = reinterpret_cast<PPGTabTransition *>(pData);

			// m_pToSegment
			if( pPPGTabTransition->pToSegment != m_pTransition->m_pToSegment 
			||  pPPGTabTransition->dwToSegmentFlag != m_pTransition->m_dwToSegmentFlag )
			{
				m_pTransition->m_pSong->m_pUndoMgr->SaveState( m_pTransition->m_pSong, theApp.m_hInstance, IDS_UNDO_TRANSITION_FROM_SEGMENT );

				RELEASE( m_pTransition->m_pToSegment );
				m_pTransition->m_pToSegment = pPPGTabTransition->pToSegment;
				if( m_pTransition->m_pToSegment )
				{
					m_pTransition->m_pToSegment->AddRef();
				}
				m_pTransition->m_dwToSegmentFlag = pPPGTabTransition->dwToSegmentFlag;

				// Sync changes
				m_pTransition->m_pSong->SetModified( TRUE );
				m_pTransition->m_pSong->SyncChanges( SC_EDITOR | SC_DIRECTMUSIC, SSE_TRANSITION_LIST, NULL );
			}

			// m_pTransitionSegment
			if( pPPGTabTransition->pTransitionSegment != m_pTransition->m_pTransitionSegment )
			{
				m_pTransition->m_pSong->m_pUndoMgr->SaveState( m_pTransition->m_pSong, theApp.m_hInstance, IDS_UNDO_TRANSITION_TRAN_SEGMENT );

				RELEASE( m_pTransition->m_pTransitionSegment );
				m_pTransition->m_pTransitionSegment = pPPGTabTransition->pTransitionSegment;
				if( m_pTransition->m_pTransitionSegment )
				{
					m_pTransition->m_pTransitionSegment->AddRef();
				}

				// Sync changes
				m_pTransition->m_pSong->SetModified( TRUE );
				m_pTransition->m_pSong->SyncChanges( SC_EDITOR | SC_DIRECTMUSIC, SSE_TRANSITION_LIST, NULL );
			}
			break;
		}

		// Boundary tab
		case 2:
		{
			PPGTabBoundaryFlags *pPPGTabBoundaryFlags = reinterpret_cast<PPGTabBoundaryFlags *>(pData);

			// m_dwFlagsDM
			if( pPPGTabBoundaryFlags->dwPlayFlags != m_pTransition->m_dwPlayFlagsDM )
			{
				m_pTransition->m_pSong->m_pUndoMgr->SaveState( m_pTransition->m_pSong, theApp.m_hInstance, IDS_UNDO_TRACK_EXTRAS_FLAGS );
				m_pTransition->m_dwPlayFlagsDM = pPPGTabBoundaryFlags->dwPlayFlags;

				// Sync changes
				m_pTransition->m_pSong->SetModified( TRUE );
				m_pTransition->m_pSong->SyncChanges( SC_DIRECTMUSIC, 0, NULL );
			}
			break;
		}

		default:
			ASSERT( 0 );
			break;
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CTransitionPropPageObject IDMUSProdPropPageObject::OnShowProperties

HRESULT CTransitionPropPageObject::OnShowProperties( void )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	ASSERT( theApp.m_pSongComponent != NULL );
	ASSERT( theApp.m_pSongComponent->m_pIFramework8 != NULL );

	// Get the Transition's page manager
	CTransitionPropPageManager* pPageManager;

	if( theApp.m_pIPageManager
	&&  theApp.m_pIPageManager->IsEqualPageManagerGUID( GUID_TransitionPropPageManager ) == S_OK )
	{
		pPageManager = (CTransitionPropPageManager *)theApp.m_pIPageManager;
	}
	else
	{
		pPageManager = new CTransitionPropPageManager();
	}

	if( pPageManager == NULL )
	{
		return E_FAIL;
	}

	// Show the Transition's properties
	IDMUSProdPropSheet* pIPropSheet;

	if( SUCCEEDED ( theApp.m_pSongComponent->m_pIFramework8->QueryInterface( IID_IDMUSProdPropSheet, (void**)&pIPropSheet ) ) )
	{
		if( pPageManager == theApp.m_pIPageManager )
		{
			pIPropSheet->GetActivePage( &CTransitionPropPageManager::sm_nActiveTab );
		}
		short nActiveTab = CTransitionPropPageManager::sm_nActiveTab;

		if( SUCCEEDED ( pIPropSheet->SetPageManager(pPageManager) ) )
		{
			theApp.m_pIPageManager = pPageManager;
			pPageManager->SetObject( this );
			pIPropSheet->SetActivePage( nActiveTab ); 
		}

		pIPropSheet->Show( TRUE );
		RELEASE( pIPropSheet );
	}

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CTransitionPropPageObject IDMUSProdPropPageObject::OnRemoveFromPageManager

HRESULT CTransitionPropPageObject::OnRemoveFromPageManager( void )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SongDesigner\TransitionPropPageObject.h ===
#ifndef __TRANSITIONPROPPAGEOBJECT_H_
#define __TRANSITIONPROPPAGEOBJECT_H_


typedef struct _PPGTransition
{
	_PPGTransition( void )
	{
		dwPageIndex = 0;
		pSong = NULL;
		pVirtualSegmentToEdit = NULL;
		pTransition = NULL;
	}

	DWORD				dwPageIndex;
	CDirectMusicSong*	pSong;
	CVirtualSegment*	pVirtualSegmentToEdit;
	CTransition*		pTransition;
} PPGTransition;


class CTabTransition;

//////////////////////////////////////////////////////////////////////
//  CTransitionPropPageManager

class CTransitionPropPageManager : public IDMUSProdPropPageManager 
{
friend class CTabBoundaryFlags;

public:
	CTransitionPropPageManager();
	virtual ~CTransitionPropPageManager();

    // IUnknown functions
    HRESULT STDMETHODCALLTYPE QueryInterface( REFIID riid, LPVOID *ppv );
    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();

    // IDMUSProdPropPageManager functions
    HRESULT STDMETHODCALLTYPE GetPropertySheetTitle( BSTR* pbstrTitle, BOOL* pfAddPropertiesText );
    HRESULT STDMETHODCALLTYPE GetPropertySheetPages( IDMUSProdPropSheet* pIPropSheet, LONG* hPropSheetPage[], short* pnNbrPages );
	HRESULT STDMETHODCALLTYPE OnRemoveFromPropertySheet();

    HRESULT STDMETHODCALLTYPE SetObject( IDMUSProdPropPageObject* pINewPropPageObject );
    HRESULT STDMETHODCALLTYPE RemoveObject( IDMUSProdPropPageObject* pIPropPageObject );
    HRESULT STDMETHODCALLTYPE IsEqualObject( IDMUSProdPropPageObject* pIPropPageObject );

    HRESULT STDMETHODCALLTYPE RefreshData();
    HRESULT STDMETHODCALLTYPE IsEqualPageManagerGUID( REFGUID rguidPageManager );

	//Additional functions
private:
	void RemoveCurrentObject();

	// Member variables
private:
    DWORD						m_dwRef;
	IDMUSProdPropSheet*			m_pIPropSheet;
	IDMUSProdPropPageObject*	m_pIPropPageObject;
	
	CTabTransition*				m_pTabTransition;
	CTabBoundaryFlags*			m_pTabBoundary;

public:
	static short				sm_nActiveTab;
};


//////////////////////////////////////////////////////////////////////
//  CTransitionPropPageObject

class CTransitionPropPageObject : public IDMUSProdPropPageObject
{
friend class CTransitionPropPageManager;

public:
	CTransitionPropPageObject( CSongDlg* pSongDlg );
	virtual ~CTransitionPropPageObject();

    // IUnknown functions
    HRESULT STDMETHODCALLTYPE QueryInterface( REFIID riid, LPVOID *ppv );
    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();

    // IDMUSProdPropPageObject functions
    HRESULT STDMETHODCALLTYPE GetData( void** ppData );
    HRESULT STDMETHODCALLTYPE SetData( void* pData );
	HRESULT STDMETHODCALLTYPE OnShowProperties();
	HRESULT STDMETHODCALLTYPE OnRemoveFromPageManager();

	// Additional methods

private:
    DWORD				m_dwRef;
	CSongDlg*			m_pSongDlg;

	CTransition*		m_pTransition;
	DWORD				m_dwFlagsUI;
};

#endif // __TRANSITIONPROPPAGEOBJECT_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\StyleDesigner\DialogLinkExisting.cpp ===
// DialogLinkExisting.cpp : implementation file
//

#include "stdafx.h"
#include "StyleDesignerDLL.h"
#include "DialogLinkExisting.h"
#include "Style.h"
#include "Pattern.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CDialogLinkExisting dialog


CDialogLinkExisting::CDialogLinkExisting(CWnd* pParent /*=NULL*/)
	: CDialog(CDialogLinkExisting::IDD, pParent)
{
	m_pDMPartRef = NULL;
	m_pDMStyle = NULL;

	//{{AFX_DATA_INIT(CDialogLinkExisting)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}


void CDialogLinkExisting::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CDialogLinkExisting)
	DDX_Control(pDX, IDC_LIST_PART, m_listPart);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CDialogLinkExisting, CDialog)
	//{{AFX_MSG_MAP(CDialogLinkExisting)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CDialogLinkExisting message handlers

BOOL CDialogLinkExisting::OnInitDialog() 
{
	CDialog::OnInitDialog();

	// Template for strings to display ("%s : %s(%d)")
	CString strTemplate;
	strTemplate.LoadString( IDS_SELECT_PARTREF_TEMPL );

	// Template for broadcast strings to display ("%s : %s(%s)")
	CString strTemplateBCast;
	strTemplateBCast.LoadString( IDS_SELECT_BCAST_PARTREF_TEMPLATE );

	// String to display if PartRef has no name
	CString strUnnamed;
	strUnnamed.LoadString( IDS_UNNAMED_PARTREF );

	// Temporary string to hold text to add to list box and PartRef name
	CString strTmp, strPartRef;

	// Index of item in the list box
	int nIndex;

	// Iterate through all Patterns
	CDirectMusicPattern *pPattern;
	POSITION posPattern = m_pDMStyle->m_StylePatterns.m_lstPatterns.GetHeadPosition();
	while( posPattern )
	{
        pPattern = m_pDMStyle->m_StylePatterns.m_lstPatterns.GetNext( posPattern );

		// Iterate through all PartRefs
		CDirectMusicPartRef *pPartRef;
		POSITION posPartRef = pPattern->m_lstPartRefs.GetHeadPosition();
		while( posPartRef )
		{
			pPartRef = pPattern->m_lstPartRefs.GetNext( posPartRef );

			// Get the PartRef name
			strPartRef = pPartRef->m_strName.IsEmpty() ? strUnnamed : pPartRef->m_strName;
			//strTmp = pPartRef->m_strName.IsEmpty() ? strUnnamed : pPartRef->m_strName;

			// Format the name to display
			if( pPartRef->m_dwPChannel < DMUS_PCHANNEL_BROADCAST_GROUPS )
			{
				strTmp.Format( strTemplate, pPattern->m_strName, strPartRef, pPartRef->m_dwPChannel + 1 );
			}
			else
			{
				CString strPChannelName;
				if( pPartRef->m_dwPChannel == DMUS_PCHANNEL_BROADCAST_SEGMENT )
				{
					strPChannelName.LoadString( IDS_BROADCAST_SEG );
				}
				else if( pPartRef->m_dwPChannel == DMUS_PCHANNEL_BROADCAST_PERFORMANCE )
				{
					strPChannelName.LoadString( IDS_BROADCAST_PERF );
				}
				else if( pPartRef->m_dwPChannel == DMUS_PCHANNEL_BROADCAST_AUDIOPATH )
				{
					strPChannelName.LoadString( IDS_BROADCAST_APATH );
				}
				else if( pPartRef->m_dwPChannel == DMUS_PCHANNEL_BROADCAST_GROUPS )
				{
					strPChannelName.LoadString( IDS_BROADCAST_GRP );
				}

				strTmp.Format( strTemplateBCast, pPattern->m_strName, strPartRef, strPChannelName );
			}

			// Add the PartRef's name to the list box
			nIndex = m_listPart.AddString( strTmp );
			if( nIndex >= 0 )
			{
				m_listPart.SetItemDataPtr( nIndex, pPartRef );
			}
		}
	}
	
	posPattern = m_pDMStyle->m_StyleMotifs.m_lstMotifs.GetHeadPosition();
	while( posPattern )
	{
        pPattern = m_pDMStyle->m_StyleMotifs.m_lstMotifs.GetNext( posPattern );

		// Iterate through all PartRefs
		CDirectMusicPartRef *pPartRef;
		POSITION posPartRef = pPattern->m_lstPartRefs.GetHeadPosition();
		while( posPartRef )
		{
			pPartRef = pPattern->m_lstPartRefs.GetNext( posPartRef );

			// Get the PartRef name
			strPartRef = pPartRef->m_strName.IsEmpty() ? strUnnamed : pPartRef->m_strName;
			//strTmp = pPartRef->m_strName.IsEmpty() ? strUnnamed : pPartRef->m_strName;

			// Format the name to display
			if( pPartRef->m_dwPChannel < DMUS_PCHANNEL_BROADCAST_GROUPS )
			{
				strTmp.Format( strTemplate, pPattern->m_strName, strPartRef, pPartRef->m_dwPChannel + 1 );
			}
			else
			{
				CString strPChannelName;
				if( pPartRef->m_dwPChannel == DMUS_PCHANNEL_BROADCAST_SEGMENT )
				{
					strPChannelName.LoadString( IDS_BROADCAST_SEG );
				}
				else if( pPartRef->m_dwPChannel == DMUS_PCHANNEL_BROADCAST_PERFORMANCE )
				{
					strPChannelName.LoadString( IDS_BROADCAST_PERF );
				}
				else if( pPartRef->m_dwPChannel == DMUS_PCHANNEL_BROADCAST_AUDIOPATH )
				{
					strPChannelName.LoadString( IDS_BROADCAST_APATH );
				}
				else if( pPartRef->m_dwPChannel == DMUS_PCHANNEL_BROADCAST_GROUPS )
				{
					strPChannelName.LoadString( IDS_BROADCAST_GRP );
				}

				strTmp.Format( strTemplateBCast, pPattern->m_strName, strPartRef, strPChannelName );
			}

			// Add the PartRef's name to the list box
			nIndex = m_listPart.AddString( strTmp );
			if( nIndex >= 0 )
			{
				m_listPart.SetItemDataPtr( nIndex, pPartRef );
			}
		}
	}

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CDialogLinkExisting::OnOK() 
{
	// Index of the selected item in the list box
	int nIndex;
	nIndex = m_listPart.GetCurSel();

	// If index is valid, set m_pDMPartRef to the associated PartRef
	if( nIndex >= 0 )
	{
		m_pDMPartRef = (CDirectMusicPartRef *)m_listPart.GetItemDataPtr( nIndex );
	}
	
	CDialog::OnOK();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\xdktools\Producer\SongDesigner\VirtualSegment.cpp ===
// VirtualSegment.cpp : implementation file
//

#include "stdafx.h"
#include "SongDesignerDLL.h"

#include "Song.h"
#include <mmreg.h>
#include <AudioPathDesigner.h>
#include <SegmentDesigner.h>
#include <dmusicf.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


//////////////////////////////////////////////////////////////////////
//	CVirtualSegment Constructor/Destructor

CVirtualSegment::CVirtualSegment( CDirectMusicSong* pSong )
{
	m_dwRef = 0;
	AddRef();

	ASSERT( pSong != NULL );
	m_pSong = pSong;
//	m_pSong->AddRef();			intentionally missing

	// UI
	m_fResolveNextPlayID = false;
	m_dwNextPlayID = 0;
	m_dwBitsUI = 0;
	m_fIsPlaying = false;

	// UNFO/UNAM
	m_strName.LoadString( IDS_V_EMPTY_TEXT );
	
	// DMUS_IO_SEGREF_HEADER
	m_pSourceSegment = NULL;
	m_pIToolGraphNode = NULL;
	m_pNextVirtualSegment = NULL;
    
	// DMUS_IO_SEGMENT_HEADER
	m_dwRepeats_SEGH = 0;
    m_mtLength_SEGH = m_VirtualSegmentUI.dwNbrMeasures * DMUS_PPQ * 4;	// XX measures of 4/4 time
    m_mtPlayStart_SEGH = 0;
    m_mtLoopStart_SEGH = 0;
    m_mtLoopEnd_SEGH = 0;	
    m_dwResolution_SEGH = 0;
    m_rtLength_SEGH = 0;					// Length, in reference time (overrides music time length.) 
    m_dwFlags_SEGH = 0;
}

CVirtualSegment::~CVirtualSegment( void )
{
	ASSERT( theApp.m_pSongComponent != NULL );
	ASSERT( theApp.m_pSongComponent->m_pIFramework8 != NULL );

	// Empty lists
	EmptyTrackList();
	EmptyTransitionList();

	RELEASE( m_pSourceSegment );
	RELEASE( m_pIToolGraphNode );
	RELEASE( m_pNextVirtualSegment );
}


/////////////////////////////////////////////////////////////////////////////
// CVirtualSegment IUnknown implementation

HRESULT CVirtualSegment::QueryInterface( REFIID riid, LPVOID FAR* ppvObj )
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    if( ::IsEqualIID(riid, IID_IUnknown) )
    {
        AddRef();
        *ppvObj = (IUnknown *)this;
        return S_OK;
    }

    *ppvObj = NULL;
    return E_NOINTERFACE;
}

ULONG CVirtualSegment::AddRef()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	AfxOleLockApp(); 
    return ++m_dwRef;
}

ULONG CVirtualSegment::Release()
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

    ASSERT( m_dwRef != 0 );

	AfxOleUnlockApp(); 
    --m_dwRef;

    if( m_dwRef == 0 )
    {
        delete this;
        return 0;
    }

    return m_dwRef;
}


//////////////////////////////////////////////////////////////////////
//	CVirtualSegment::GetSourceSegmentName

void CVirtualSegment::GetSourceSegmentName( CString& strSourceSegmentName )
{
	strSourceSegmentName.Empty();

	if( m_pSourceSegment )
	{
		IDMUSProdNode* pISegmentDocRootNode;
		if( SUCCEEDED ( m_pSourceSegment->GetSegmentDocRootNode( &pISegmentDocRootNode ) ) )
		{
			BSTR bstrName;
			if( SUCCEEDED ( pISegmentDocRootNode->GetNodeName( &bstrName ) ) )
			{
				strSourceSegmentName = bstrName;
				::SysFreeString( bstrName );
			}

			RELEASE( pISegmentDocRootNode );
		}
	}
}


//////////////////////////////////////////////////////////////////////
//	CVirtualSegment::GetName

void CVirtualSegment::GetName( CString& strName )
{
	strName = m_strName;
}


//////////////////////////////////////////////////////////////////////
//	CVirtualSegment::SetName

void CVirtualSegment::SetName( CString strName )
{
	m_strName = strName;
}


/////////////////////////////////////////////////////////////////////////////
// CVirtualSegment::RemoveVirtualSegmentReferences

void CVirtualSegment::RemoveVirtualSegmentReferences( CVirtualSegment* pVirtualSegmentToRemove )
{
	if( pVirtualSegmentToRemove == NULL )
	{
		ASSERT( FALSE );
		return;
	}

	// Handle "next" VirtualSegment
	if( m_pNextVirtualSegment == pVirtualSegmentToRemove )
	{
		RELEASE( m_pNextVirtualSegment );
	}

	// Handle transitions
	POSITION posCur;
	POSITION pos = m_lstTransitions.GetHeadPosition();
	while( pos )
	{
		posCur = pos;
		CTransition* pTransition = m_lstTransitions.GetNext( pos );

		if( pTransition->m_pToSegment == pVirtualSegmentToRemove )
		{
			m_lstTransitions.RemoveAt( posCur );
			RELEASE( pTransition );
		}
		else if( pTransition->m_pTransitionSegment == pVirtualSegmentToRemove )
		{
			RELEASE( pTransition->m_pTransitionSegment );
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CVirtualSegment::RemoveSourceSegmentReferences

void CVirtualSegment::RemoveSourceSegmentReferences( CSourceSegment* pSourceSegmentToRemove )
{
	if( pSourceSegmentToRemove == NULL )
	{
		ASSERT( FALSE );
		return;
	}

	// Handle this VirtualSegment
	if( m_pSourceSegment == pSourceSegmentToRemove )
	{
		RELEASE( m_pSourceSegment );
	}

	// Handle tracks
	POSITION posCur;
	POSITION pos = m_lstTracks.GetHeadPosition();
	while( pos )
	{
		posCur = pos;
		CTrack* pTrack = m_lstTracks.GetNext( pos );

		if( pTrack->m_pSourceSegment == pSourceSegmentToRemove )
		{
			m_lstTracks.RemoveAt( posCur );
			RELEASE( pTrack );
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// CVirtualSegment::RemoveToolGraphReferences

void CVirtualSegment::RemoveToolGraphReferences( IDMUSProdNode* pIToolGraphNodeToRemove )
{
	if( pIToolGraphNodeToRemove == NULL )
	{
		ASSERT( FALSE );
		return;
	}

	// Handle this VirtualSegment
	if( m_pIToolGraphNode == pIToolGraphNodeToRemove )
	{
		RELEASE( m_pIToolGraphNode );
	}
}


/////////////////////////////////////////////////////////////////////////////
// CVirtualSegment::ResolveVirtualSegmentIDs

void CVirtualSegment::ResolveVirtualSegmentIDs( void )
{
	// Handle this VirtualSegment
	if( m_fResolveNextPlayID )
	{
		ASSERT( m_pNextVirtualSegment == NULL );
	
		m_pNextVirtualSegment = m_pSong->IndexToVirtualSegment( m_dwNextPlayID );
		if( m_pNextVirtualSegment )
		{
			m_pNextVirtualSegment->AddRef();
		}

		m_fResolveNextPlayID = false;
		m_dwNextPlayID = 0;
	}

	// Handle transitions
	POSITION pos = m_lstTransitions.GetHeadPosition();
	while( pos )
	{
		CTransition* pTransition = m_lstTransitions.GetNext( pos );

		if( pTransition->m_fResolveToSegmentID )
		{
			ASSERT( pTransition->m_pToSegment == NULL );
		
			pTransition->m_pToSegment = m_pSong->IndexToVirtualSegment( pTransition->m_dwToSegmentID );
			if( pTransition->m_pToSegment )
			{
				pTransition->m_pToSegment->AddRef();
			}

			pTransition->m_fResolveToSegmentID = false;
			pTransition->m_dwToSegmentID = 0;
		}

		if( pTransition->m_fResolveTransitionSegmentID )
		{
			ASSERT( pTransition->m_pTransitionSegment == NULL );
		
			pTransition->m_pTransitionSegment = m_pSong->IndexToVirtualSegment( pTransition->m_dwTransitionSegmentID );
			if( pTransition->m_pTransitionSegment )
			{
				pTransition->m_pTransitionSegment->AddRef();
			}

			pTransition->m_fResolveTransitionSegmentID = false;
			pTransition->m_dwTransitionSegmentID = 0;
		}
	}
}


//////////////////////////////////////////////////////////////////////
//	CVirtualSegment::IsVirtualSegmentInTransitionList

bool CVirtualSegment::IsVirtualSegmentInTransitionList( CVirtualSegment* pVirtualSegment )
{
	POSITION pos = m_lstTransitions.GetHeadPosition();
	while( pos )
	{
		CTransition* pTransition = m_lstTransitions.GetNext( pos );

		if( pTransition->m_pToSegment == pVirtualSegment )
		{
			return true;
		}
	}

	return false;
}


#define DMUS_FOURCC_SEGMENT_DESIGN_LIST		mmioFOURCC('s','g','d','l')
#define DMUS_FOURCC_SEGMENT_DESIGN_CHUNK	mmioFOURCC('s','e','g','d')

typedef struct _PARTIAL_SEGMENT_DESIGN_STRUCT
{
	double		dblTempo;			// Tempo. By default, 120
	float		fTempoModifier;		// Tempo modifier. By default, 0.5
	double		dblZoom;			// Timeline zoom factor. By default, 0.03125
	DWORD		dwMeasureLength;	// Length in measures
	WORD		wSegmentRepeats;	// Design-time repeats
	BYTE		bKey;				// Key 0-11 (NO LONGER USED!!!)
	BOOL		fShowFlats;			// Flats/sharps (NO LONGER USED!!!)
	BOOL		fReserved;			// No longer used (was Template/Section)
	DWORD		dwPlayStartMeasure;	// Start measure
	BYTE		bPlayStartBeat;		// Start beat
	WORD		wPlayStartGrid;		// Start grid
	WORD		wPlayStartTick;		// Start tick
	DWORD		dwTrackGroup;		// Group to get TimeSig from
} PARTIAL_SEGMENT_DESIGN_STRUCT;

//////////////////////////////////////////////////////////////////////
//	CVirtualSegment::SetDefaultValues

HRESULT CVirtualSegment::SetDefaultValues( IStream* pIStream )
{
    MMCKINFO ckMain;
    MMCKINFO ckList;
    MMCKINFO ck;
	DWORD dwSize;
	DWORD dwByteCount;

    IDMUSProdRIFFStream* pIRiffStream = NULL;
	
	HRESULT hr = AllocRIFFStream( pIStream, &pIRiffStream );
	if( FAILED( hr ) )
	{
		goto ON_ERROR;
	}

	ckMain.fccType = DMUS_FOURCC_SEGMENT_FORM;
	if( pIRiffStream->Descend( &ckMain, NULL, MMIO_FINDRIFF ) == 0 )
	{
		// Get Segment header
		ck.ckid = DMUS_FOURCC_SEGMENT_CHUNK;
		if( pIRiffStream->Descend( &ck, &ckMain, MMIO_FINDCHUNK ) == 0 )
		{
			DMUS_IO_SEGMENT_HEADER dmusSegHeaderIO;

			dwSize = min( ck.cksize, sizeof( DMUS_IO_SEGMENT_HEADER ) );
			hr = pIStream->Read( &dmusSegHeaderIO, dwSize, &dwByteCount );
			if( FAILED( hr )
			||  dwByteCount != dwSize )
			{
				hr = E_FAIL;
				goto ON_ERROR;
			}

			m_dwRepeats_SEGH = dmusSegHeaderIO.dwRepeats;
			m_mtLength_SEGH = dmusSegHeaderIO.mtLength;
			m_mtPlayStart_SEGH = dmusSegHeaderIO.mtPlayStart;
			m_mtLoopStart_SEGH = dmusSegHeaderIO.mtLoopStart;
			m_mtLoopEnd_SEGH = dmusSegHeaderIO.mtLoopEnd;
			m_dwResolution_SEGH = dmusSegHeaderIO.dwResolution;
			m_rtLength_SEGH = dmusSegHeaderIO.rtLength;
			m_dwFlags_SEGH = dmusSegHeaderIO.dwFlags;
		}

		DWORD dwPos = StreamTell( pIStream );

		// Get Segment name
		ck.fccType = DMUS_FOURCC_UNFO_LIST;
		if( pIRiffStream->Descend( &ck, &ckMain, MMIO_FINDLIST ) == 0 )
		{
			ck.ckid = DMUS_FOURCC_UNAM_CHUNK;
			if( pIRiffStream->Descend( &ck, &ckMain, MMIO_FINDCHUNK ) == 0 )
			{
				CString strPrefix;
				strPrefix.LoadString( IDS_VIRTUAL_SEGMENT_PREFIX_TEXT ); 

				CString strName;
				ReadMBSfromWCS( pIStream, ck.cksize, &strName );
				
				m_strName = strPrefix + strName;
			}
		}

		StreamSeek( pIStream, dwPos, STREAM_SEEK_SET );

		// Get Track Group
		ck.fccType = DMUS_FOURCC_SEGMENT_DESIGN_LIST;
		if( pIRiffStream->Descend( &ck, &ckMain, MMIO_FINDLIST ) == 0 )
		{
			ckList.ckid = DMUS_FOURCC_SEGMENT_DESIGN_CHUNK;
			if( pIRiffStream->Descend( &ckList, &ck, MMIO_FINDCHUNK ) == 0 )
			{
				PARTIAL_SEGMENT_DESIGN_STRUCT iDMSegmentDesign;
				ZeroMemory( &iDMSegmentDesign, sizeof( PARTIAL_SEGMENT_DESIGN_STRUCT ) );

				dwSize = min( ckList.cksize, sizeof( PARTIAL_SEGMENT_DESIGN_STRUCT ) );
				hr = pIStream->Read( &iDMSegmentDesign, dwSize, &dwByteCount );
				if( FAILED( hr )
				||  dwByteCount != dwSize )
				{
					hr = E_FAIL;
					goto ON_ERROR;
				}

				m_VirtualSegmentUI.dwTimeSigGroupBits = iDMSegmentDesign.dwTrackGroup;
			}
		}
	}

ON_ERROR:
	RELEASE( pIRiffStream );
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CVirtualSegment Load

HRESULT CVirtualSegment::Load( IDMUSProdRIFFStream* pIRiffStream, MMCKINFO* pckMain )
{
    IStream*       pIStream;
	MMCKINFO	   ck;
	MMCKINFO	   ckList;
	DWORD		   dwByteCount;
	DWORD		   dwSize;
    HRESULT        hr = S_OK;

    pIStream = pIRiffStream->GetStream();
	ASSERT( pIStream != NULL );

    while( pIRiffStream->Descend( &ck, pckMain, 0 ) == 0 )
	{
        switch( ck.ckid )
		{
			case DMUS_FOURCC_SEGREF_CHUNK:
			{
				DMUS_IO_SEGREF_HEADER dmusSegRefIO;

				dwSize = min( ck.cksize, sizeof( DMUS_IO_SEGREF_HEADER ) );
				hr = pIStream->Read( &dmusSegRefIO, dwSize, &dwByteCount );
				if( FAILED( hr )
				||  dwByteCount != dwSize )
				{
					hr = E_FAIL;
					goto ON_ERROR;
				}

				if( dmusSegRefIO.dwSegmentID == DMUS_SONG_NOSEG )
				{
					m_pSourceSegment = NULL;
				}
				else
				{
					m_pSourceSegment = m_pSong->IndexToSourceSegment( dmusSegRefIO.dwSegmentID );
					if( m_pSourceSegment )
					{
						m_pSourceSegment->AddRef();
					}
				}
				if( dmusSegRefIO.dwToolGraphID == DMUS_SONG_NOSEG )
				{
					m_pIToolGraphNode = NULL;
				}
				else
				{
					m_pIToolGraphNode = m_pSong->IndexToToolGraph( dmusSegRefIO.dwToolGraphID );
					if( m_pIToolGraphNode )
					{
						m_pIToolGraphNode->AddRef();
					}
				}
				if( dmusSegRefIO.dwNextPlayID == DMUS_SONG_NOSEG )
				{
					m_fResolveNextPlayID = false;
					m_pNextVirtualSegment = NULL;
				}
				else
				{
					m_fResolveNextPlayID = true;
					m_dwNextPlayID = dmusSegRefIO.dwNextPlayID;
				}
				break;
			}

			case DMUS_FOURCC_SEGMENT_CHUNK:
			{
			    DMUS_IO_SEGMENT_HEADER dmusSegHeaderIO;

				dwSize = min( ck.cksize, sizeof( DMUS_IO_SEGMENT_HEADER ) );
				hr = pIStream->Read( &dmusSegHeaderIO, dwSize, &dwByteCount );
				if( FAILED( hr )
				||  dwByteCount != dwSize )
				{
					hr = E_FAIL;
					goto ON_ERROR;
				}

				m_dwRepeats_SEGH = dmusSegHeaderIO.dwRepeats;
				m_mtLength_SEGH = dmusSegHeaderIO.mtLength;
				m_mtPlayStart_SEGH = dmusSegHeaderIO.mtPlayStart;
				m_mtLoopStart_SEGH = dmusSegHeaderIO.mtLoopStart;
				m_mtLoopEnd_SEGH = dmusSegHeaderIO.mtLoopEnd;
				m_dwResolution_SEGH = dmusSegHeaderIO.dwResolution;
				m_rtLength_SEGH = dmusSegHeaderIO.rtLength;
				m_dwFlags_SEGH = dmusSegHeaderIO.dwFlags;
				break;
			}

			case DMUS_FOURCC_VIRTUAL_SEGMENT_UI_CHUNK:
			{
			    ioVirtualSegmentUI iVirtualSegmentUI;

				dwSize = min( ck.cksize, sizeof( ioVirtualSegmentUI ) );
				hr = pIStream->Read( &iVirtualSegmentUI, dwSize, &dwByteCount );
				if( FAILED( hr )
				||  dwByteCount != dwSize )
				{
					hr = E_FAIL;
					goto ON_ERROR;
				}

				m_VirtualSegmentUI.wFlags = iVirtualSegmentUI.wFlags;
				m_VirtualSegmentUI.guidVirtualSegment = iVirtualSegmentUI.guidVirtualSegment;
				m_VirtualSegmentUI.dwTimeSigGroupBits = iVirtualSegmentUI.dwTimeSigGroupBits;
				m_VirtualSegmentUI.dwNbrMeasures = iVirtualSegmentUI.dwNbrMeasures;
				break;
			}

			case DMUS_FOURCC_VIRTUAL_SEGMENT_COPY_PASTE_UI_CHUNK:
			{
			    ioVirtualSegmentCopyPasteUI iVirtualSegmentCopyPasteUI;

				dwSize = min( ck.cksize, sizeof( ioVirtualSegmentCopyPasteUI ) );
				hr = pIStream->Read( &iVirtualSegmentCopyPasteUI, dwSize, &dwByteCount );
				if( FAILED( hr )
				||  dwByteCount != dwSize )
				{
					hr = E_FAIL;
					goto ON_ERROR;
				}

				// This chunk only exists during drag/drop and copy/paste operations
				// It is used to re-establish correct links
				// Do not dereference these pointers because objects may have been deleted

				// m_pSourceSegment
				RELEASE( m_pSourceSegment );
				m_pSourceSegment = m_pSong->PtrToSourceSegment( iVirtualSegmentCopyPasteUI.pSourceSegment );
				if( m_pSourceSegment )
				{
					m_pSourceSegment->AddRef();
				}
				
				// m_pIToolGraphNode
				RELEASE( m_pIToolGraphNode );
				m_pIToolGraphNode = m_pSong->PtrToToolGraph( iVirtualSegmentCopyPasteUI.pIToolGraphNode );
				if( m_pIToolGraphNode )
				{
					m_pIToolGraphNode->AddRef();
				}

				// m_pNextVirtualSegment will be set later according to drop/paste position
				m_fResolveNextPlayID = false;
				m_pNextVirtualSegment = NULL;
				break;
			}

			case DMUS_FOURCC_SEGTRANS_CHUNK:
			{
			    DMUS_IO_TRANSITION_DEF dmusTransitionIO;
				CTransition* pTransition;

				dwSize = ck.cksize;
				while( dwSize > 0 )
				{
					hr = pIStream->Read( &dmusTransitionIO, sizeof(DMUS_IO_TRANSITION_DEF), &dwByteCount );
					if( FAILED( hr )
					||  dwByteCount != sizeof(DMUS_IO_TRANSITION_DEF) )
					{
						hr = E_FAIL;
						goto ON_ERROR;
					}

					pTransition = new CTransition( m_pSong );
					if( pTransition == NULL )
					{
						hr = E_OUTOFMEMORY;
						goto ON_ERROR;
					}

					if( dmusTransitionIO.dwSegmentID == DMUS_SONG_NOSEG )
					{
						pTransition->m_dwToSegmentFlag = DMUS_SONG_NOSEG;
						pTransition->m_pToSegment = NULL;
					}
					else if( dmusTransitionIO.dwSegmentID == DMUS_SONG_ANYSEG )
					{
						pTransition->m_dwToSegmentFlag = DMUS_SONG_ANYSEG;
						pTransition->m_pToSegment = NULL;
					}
					else if( dmusTransitionIO.dwSegmentID == DMUS_SONG_NOFROMSEG )
					{
						pTransition->m_dwToSegmentFlag = DMUS_SONG_N